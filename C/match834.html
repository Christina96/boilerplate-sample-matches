<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omczmq.c &amp; imudp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omczmq.c &amp; imudp.c
      </h3>
<h1 align="center">
        10.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omczmq.c (16.767677%)<th>imudp.c (7.6709795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(98-120)<td><a href="#" name="0">(181-208)</a><td align="center"><font color="#ff0000">35</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(415-426)<td><a href="#" name="1">(990-996)</a><td align="center"><font color="#8a0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(49-59)<td><a href="#" name="2">(167-176)</a><td align="center"><font color="#7b0000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(481-489)<td><a href="#" name="3">(996-1000)</a><td align="center"><font color="#570000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include "conf.h"
12 #include "syslogd-types.h"
13 #include "srUtils.h"
14 #include "template.h"
15 #include "module-template.h"
16 #include "errmsg.h"
17 #include "cfsysline.h"
18 #include &lt;czmq.h&gt;
19 MODULE_TYPE_OUTPUT
20 MODULE_TYPE_NOKEEP
21 MODULE_CNFNAME("omczmq")
22 DEF_OMOD_STATIC_DATA
23 <a name="2"></a>static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;
24 static struct cnfparamdescr modpdescr[] = {
25 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "authenticator", eCmdHdlrBinary, 0 },
26 	{ "authtype", eCmdHdlrGetWord, 0 },
27 	{ "clientcertpath", eCmdHdlrGetWord, 0 },
28 	{ "servercertpath", eCmdHdlrGetWord, 0 }
29 };
30 static struct cnfparamblk modpblk = {
31 	CNFPARAMBLK_VERSION,
32 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
33 	modpdescr
34 };</b></font>
35 struct modConfData_s {
36 	rsconf_t *pConf;
37 	uchar *tplName;
38 	int authenticator;
39 	char *authType;
40 	char *serverCertPath;
41 	char *clientCertPath;
42 };
43 static modConfData_t *runModConf = NULL;
44 static zactor_t *authActor;
45 typedef struct _instanceData {
46 	zsock_t *sock;
47 	bool serverish;
48 	int sendTimeout;
49 	zlist_t *topics;
50 	bool sendError;
51 	char *sockEndpoints;
52 	int sockType;
53 	int sendHWM;
54 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
55 	int heartbeatIvl;
56 	int heartbeatTimeout;
57 	int heartbeatTTL;
58 	int connectTimeout;
59 #endif
60 	uchar *tplName;
61 	sbool topicFrame;
62 	sbool dynaTopic;
63 } instanceData;
64 typedef struct wrkrInstanceData {
65 	instanceData *pData;
66 <a name="0"></a>} wrkrInstanceData_t;
67 static struct cnfparamdescr actpdescr[] = {
68 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "endpoints", eCmdHdlrGetWord, 1 },
69 	{ "socktype", eCmdHdlrGetWord, 1 },
70 	{ "sendhwm", eCmdHdlrGetWord, 0 },
71 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
72 	{ "heartbeatttl", eCmdHdlrGetWord, 0},
73 	{ "heartbeativl", eCmdHdlrGetWord, 0},
74 	{ "heartbeattimeout", eCmdHdlrGetWord, 0},
75 	{ "connecttimeout", eCmdHdlrGetWord, 0},
76 #endif
77 	{ "sendtimeout", eCmdHdlrGetWord, 0 },
78 	{ "template", eCmdHdlrGetWord, 0 },
79 	{ "topics", eCmdHdlrGetWord, 0 },
80 	{ "topicframe", eCmdHdlrGetWord, 0},
81 	{ "dynatopic", eCmdHdlrBinary, 0 }
82 };
83 static struct cnfparamblk actpblk = {
84 	CNFPARAMBLK_VERSION,
85 	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
86 	actpdescr
87 };
88 static rsRetVal initCZMQ(instanceData* pData) {</b></font>
89 	DEFiRet;
90 	int rc;
91 	putenv((char*)"ZSYS_SIGHANDLER=false");
92 	pData-&gt;sock = zsock_new(pData-&gt;sockType);
93 	if(!pData-&gt;sock) {
94 		LogError(0, RS_RET_NO_ERRCODE,
95 				"omczmq: new socket failed for endpoints: %s",
96 				pData-&gt;sockEndpoints);
97 		ABORT_FINALIZE(RS_RET_SUSPENDED);
98 	}
99 	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);
100 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
101 	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
102 		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
103 		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
104 		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
105 	}
106 #endif
107 	if(runModConf-&gt;authType) {
108 		if (!strcmp(runModConf-&gt;authType, "CURVESERVER")) {
109 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
110 			if(!serverCert) {
111 				LogError(0, NO_ERRCODE, "could not load cert %s",
112 					runModConf-&gt;serverCertPath);
113 				ABORT_FINALIZE(RS_RET_ERR);
114 			}
115 			zsock_set_zap_domain(pData-&gt;sock, "global");
116 			zsock_set_curve_server(pData-&gt;sock, 1);
117 			zcert_apply(serverCert, pData-&gt;sock);
118 			zcert_destroy(&amp;serverCert);
119 		}
120 		else if(!strcmp(runModConf-&gt;authType, "CURVECLIENT")) {
121 			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
122 			if(!serverCert) {
123 				LogError(0, NO_ERRCODE, "could not load cert %s",
124 					runModConf-&gt;serverCertPath);
125 				ABORT_FINALIZE(RS_RET_ERR);
126 			}
127 			const char *server_key = zcert_public_txt(serverCert);
128 			zcert_destroy(&amp;serverCert);
129 			zsock_set_curve_serverkey(pData-&gt;sock, server_key);
130 			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
131 			if(!clientCert) {
132 				LogError(0, NO_ERRCODE, "could not load cert %s",
133 					runModConf-&gt;clientCertPath);
134 				ABORT_FINALIZE(RS_RET_ERR);
135 			}
136 			zcert_apply(clientCert, pData-&gt;sock);
137 			zcert_destroy(&amp;clientCert);
138 		}
139 	}
140 	switch(pData-&gt;sockType) {
141 		case ZMQ_PUB:
142 #if defined(ZMQ_RADIO)
143 		case ZMQ_RADIO:
144 #endif
145 			pData-&gt;serverish = true;
146 			break;
147 		case ZMQ_PUSH:
148 #if defined(ZMQ_SCATTER)
149 		case ZMQ_SCATTER:
150 #endif
151 		case ZMQ_DEALER:
152 #if defined(ZMQ_CLIENT)
153 		case ZMQ_CLIENT:
154 #endif
155 			pData-&gt;serverish = false;
156 			break;
157 	}
158 	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
159 	if(rc == -1) {
160 		LogError(0, NO_ERRCODE, "zsock_attach to %s failed",
161 				pData-&gt;sockEndpoints);
162 		ABORT_FINALIZE(RS_RET_SUSPENDED);
163 	}
164 finalize_it:
165 	RETiRet;
166 }
167 static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
168 	DEFiRet;
169 	if(NULL == pData-&gt;sock) {
170 		CHKiRet(initCZMQ(pData));
171 	}
172 #if defined(ZMQ_RADIO)
173 	DBGPRINTF("omczmq: ZMQ_RADIO is defined...\n");
174 	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
175 #else
176 	DBGPRINTF("omczmq: ZMQ_RADIO is NOT defined...\n");
177 	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
178 #endif
179 		int templateIndex = 1;
180 		const char *topic = (const char *)zlist_first(pData-&gt;topics);
181 		while(topic) {
182 			int rc;
183 			if(pData-&gt;dynaTopic)
184 				topic = (const char*)ppString[templateIndex];
185 			if (pData-&gt;sockType == ZMQ_PUB) {
186 				if(pData-&gt;topicFrame) {
187 					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
188 				}
189 				else {
190 					rc = zstr_sendf(pData-&gt;sock, "%s%s", topic, (char*)ppString[0]);
191 				}
192 				if(rc != 0) {
193 					pData-&gt;sendError = true;
194 					ABORT_FINALIZE(RS_RET_SUSPENDED);
195 				}
196 			}
197 #if defined(ZMQ_RADIO)
198 			else if(pData-&gt;sockType == ZMQ_RADIO) {
199 				DBGPRINTF("omczmq: sending on RADIO socket...\n");
200 				zframe_t *frame = zframe_from((char*)ppString[0]);
201 				if (!frame) {
202 					DBGPRINTF("omczmq: failed to create frame...\n");
203 					pData-&gt;sendError = true;
204 					ABORT_FINALIZE(RS_RET_SUSPENDED);
205 				}
206 				rc = zframe_set_group(frame, topic);
207 				if (rc != 0) {
208 					DBGPRINTF("omczmq: failed to set group '%d'...\n", rc);
209 					pData-&gt;sendError = true;
210 					ABORT_FINALIZE(RS_RET_SUSPENDED);
211 				}
212 				DBGPRINTF("omczmq: set RADIO group to '%s'\n", topic);
213 				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
214 				if(rc != 0) {
215 					pData-&gt;sendError = true;
216 					ABORT_FINALIZE(RS_RET_SUSPENDED);
217 				}
218 			}
219 #endif
220 			topic = zlist_next(pData-&gt;topics);
221 			templateIndex++;
222 		}
223 	}
224 	else {
225 		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
226 		if(rc != 0) {
227 			pData-&gt;sendError = true;
228 			DBGPRINTF("omczmq: send error: %d", rc);
229 			ABORT_FINALIZE(RS_RET_SUSPENDED);
230 		}
231 	}
232 finalize_it:
233 	RETiRet;
234 }
235 static inline void
236 setInstParamDefaults(instanceData* pData) {
237 	pData-&gt;sockEndpoints = NULL;
238 	pData-&gt;sock = NULL;
239 	pData-&gt;sendError = false;
240 	pData-&gt;serverish = false;
241 	pData-&gt;tplName = NULL;
242 	pData-&gt;sockType = -1;
243 	pData-&gt;sendTimeout = -1;
244 	pData-&gt;topics = NULL;
245 	pData-&gt;topicFrame = false;
246 #if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
247 	pData-&gt;heartbeatIvl = 0;
248 	pData-&gt;heartbeatTimeout = 0;
249 	pData-&gt;heartbeatTTL = 0;
250 #endif
251 }
252 BEGINcreateInstance
253 CODESTARTcreateInstance
254 ENDcreateInstance
255 BEGINcreateWrkrInstance
256 CODESTARTcreateWrkrInstance
257 ENDcreateWrkrInstance
258 BEGINisCompatibleWithFeature
259 CODESTARTisCompatibleWithFeature
260 	if(eFeat == sFEATURERepeatedMsgReduction) {
261 		iRet = RS_RET_OK;
262 	}
263 ENDisCompatibleWithFeature
264 BEGINdbgPrintInstInfo
265 CODESTARTdbgPrintInstInfo
266 ENDdbgPrintInstInfo
267 BEGINfreeInstance
268 CODESTARTfreeInstance
269 	zlist_destroy(&amp;pData-&gt;topics);
270 	zsock_destroy(&amp;pData-&gt;sock);
271 	free(pData-&gt;sockEndpoints);
272 	free(pData-&gt;tplName);
273 ENDfreeInstance
274 BEGINfreeWrkrInstance
275 CODESTARTfreeWrkrInstance
276 ENDfreeWrkrInstance
277 BEGINtryResume
278 	instanceData *pData;
279 CODESTARTtryResume
280 	pthread_mutex_lock(&amp;mutDoAct);
281 	pData = pWrkrData-&gt;pData;
282 	DBGPRINTF("omczmq: trying to resume...\n");
283 	zsock_destroy(&amp;pData-&gt;sock);
284 	iRet = initCZMQ(pData);
285 	pthread_mutex_unlock(&amp;mutDoAct);
286 ENDtryResume
287 BEGINbeginCnfLoad
288 CODESTARTbeginCnfLoad
289 	runModConf = pModConf;
290 	runModConf-&gt;pConf = pConf;
291 	runModConf-&gt;authenticator = 0;
292 	runModConf-&gt;authType = NULL;
293 	runModConf-&gt;serverCertPath = NULL;
294 	runModConf-&gt;clientCertPath = NULL;
295 ENDbeginCnfLoad
296 BEGINcheckCnf
297 CODESTARTcheckCnf
298 ENDcheckCnf
299 BEGINactivateCnf
300 CODESTARTactivateCnf
301 	runModConf = pModConf;
302 	if(runModConf-&gt;authenticator == 1) {
303 		if(!authActor) {
304 			DBGPRINTF("omczmq: starting authActor\n");
305 			authActor = zactor_new(zauth, NULL);
306 			if(!strcmp(runModConf-&gt;clientCertPath, "*")) {
307 				zstr_sendx(authActor, "CURVE", CURVE_ALLOW_ANY, NULL);
308 			}
309 			else {
310 				zstr_sendx(authActor, "CURVE", runModConf-&gt;clientCertPath, NULL);
311 			}
312 			zsock_wait(authActor);
313 		}
314 	}
315 ENDactivateCnf
316 BEGINfreeCnf
317 CODESTARTfreeCnf
318 	free(pModConf-&gt;tplName);
319 	free(pModConf-&gt;authType);
320 	free(pModConf-&gt;serverCertPath);
321 	free(pModConf-&gt;clientCertPath);
322 	DBGPRINTF("omczmq: stopping authActor\n");
323 	zactor_destroy(&amp;authActor);
324 ENDfreeCnf
325 BEGINsetModCnf
326 	struct cnfparamvals *pvals = NULL;
327 	int i;
328 CODESTARTsetModCnf
329 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
330 	if (pvals == NULL) {
331 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module");
332 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
333 	}
334 	for (i=0; i&lt;modpblk.nParams; ++i) {
335 		if(!pvals[i].bUsed) {
336 			DBGPRINTF("omczmq: pvals[i].bUSed continuing\n");
337 <a name="1"></a>			continue;
338 		}
339 		if(!strcmp(modpblk.descr[i].name, "authenticator")) {
340 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
341 		}
342 		else if(!strcmp(modpblk.descr[i].name, "authtype")) {
343 			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
344 			DBGPRINTF("omczmq: authtype set to %s\n", runModConf-&gt;authType);
345 		}
346 		else if(!strcmp(modpblk.descr[i].name, "servercertpath")) {
347 			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
348 			DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
349 		}
350 		else if(!strcmp(modpblk.descr[i].name, "clientcertpath")) {
351 			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
352 			DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
353 		}
354 		else {
355 			LogError(0, RS_RET_INVALID_PARAMS,
356 						"omczmq: config error, unknown "
357 						"param %s in setModCnf\n",
358 						modpblk.descr[i].name);
359 		}
360 	}
361 	DBGPRINTF("omczmq: authenticator set to %d\n", runModConf-&gt;authenticator);
362 	DBGPRINTF("omczmq: authType set to %s\n", runModConf-&gt;authType);
363 	DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
364 	DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
365 finalize_it:
366 		if(pvals != NULL)
367 			cnfparamvalsDestruct(pvals, &amp;modpblk);
368 ENDsetModCnf
369 BEGINendCnfLoad
370 CODESTARTendCnfLoad
371 	runModConf = NULL;
372 ENDendCnfLoad
373 BEGINdoAction
374 	instanceData *pData;
375 CODESTARTdoAction
376 	pthread_mutex_lock(&amp;mutDoAct);
377 	pData = pWrkrData-&gt;pData;
378 	iRet = outputCZMQ(ppString, pData);
379 	pthread_mutex_unlock(&amp;mutDoAct);
380 ENDdoAction
381 BEGINnewActInst
382 	struct cnfparamvals *pvals;
383 	int i;
384 	int iNumTpls;
385 CODESTARTnewActInst
386 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
387 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
388 	}
389 	CHKiRet(createInstance(&amp;pData));
390 	setInstParamDefaults(pData);
391 	for(i = 0; i &lt; actpblk.nParams; ++i) {
392 		if(!pvals[i].bUsed) {
393 			continue;
394 <a name="3"></a>		}
395 		if(!strcmp(actpblk.descr[i].name, "endpoints")) {
396 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
397 			DBGPRINTF("omczmq: sockEndPoints set to '%s'\n", pData-&gt;sockEndpoints);
398 		}
399 		else if(!strcmp(actpblk.descr[i].name, "template")) {
400 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
401 			DBGPRINTF("omczmq: template set to '%s'\n", pData-&gt;tplName);
402 		}
403 		else if(!strcmp(actpblk.descr[i].name, "dynatopic")) {
404 			pData-&gt;dynaTopic = pvals[i].val.d.n;</b></font>
405 			DBGPRINTF("omczmq: dynaTopic set to %s\n", pData-&gt;dynaTopic ? "true" : "false");
406 		}
407 		else if(!strcmp(actpblk.descr[i].name, "sendtimeout")) {
408 			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
409 			DBGPRINTF("omczmq: sendTimeout set to %d\n", pData-&gt;sendTimeout);
410 		}
411 		else if(!strcmp(actpblk.descr[i].name, "sendhwm")) {
412 			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
413 			DBGPRINTF("omczmq: sendHWM set to %d\n", pData-&gt;sendHWM);
414 		}
415 #if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
416 		else if(!strcmp(actpblk.descr[i].name, "heartbeativl")) {
417 			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
418 			DBGPRINTF("omczmq: heartbeatbeatIvl set to %d\n", pData-&gt;heartbeatIvl);
419 		}
420 		else if(!strcmp(actpblk.descr[i].name, "heartbeattimeout")) {
421 			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
422 			DBGPRINTF("omczmq: heartbeatTimeout set to %d\n", pData-&gt;heartbeatTimeout);
423 		}
424 		else if(!strcmp(actpblk.descr[i].name, "heartbeatttl")) {
425 			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
426 			DBGPRINTF("omczmq: heartbeatTTL set to %d\n", pData-&gt;heartbeatTTL);
427 		}
428 #endif
429 		else if(!strcmp(actpblk.descr[i].name, "socktype")){
430 			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
431 			if(stringType != NULL){
432 				if(!strcmp("PUB", stringType)) {
433 					pData-&gt;sockType = ZMQ_PUB;
434 					DBGPRINTF("omczmq: sockType set to ZMQ_PUB\n");
435 				}
436 #if defined(ZMQ_RADIO)
437 				else if(!strcmp("RADIO", stringType)) {
438 					pData-&gt;sockType = ZMQ_RADIO;
439 					DBGPRINTF("omczmq: sockType set to ZMQ_RADIO\n");
440 				}
441 #endif
442 				else if(!strcmp("PUSH", stringType)) {
443 					pData-&gt;sockType = ZMQ_PUSH;
444 					DBGPRINTF("omczmq: sockType set to ZMQ_PUSH\n");
445 				}
446 #if defined(ZMQ_SCATTER)
447 				else if(!strcmp("SCATTER", stringType)) {
448 					pData-&gt;sockType = ZMQ_SCATTER;
449 					DBGPRINTF("omczmq: sockType set to ZMQ_SCATTER\n");
450 				}
451 #endif
452 				else if(!strcmp("DEALER", stringType)) {
453 					pData-&gt;sockType = ZMQ_DEALER;
454 					DBGPRINTF("omczmq: sockType set to ZMQ_DEALER\n");
455 				}
456 #if defined(ZMQ_CLIENT)
457 				else if(!strcmp("CLIENT", stringType)) {
458 					pData-&gt;sockType = ZMQ_CLIENT;
459 					DBGPRINTF("omczmq: sockType set to ZMQ_CLIENT\n");
460 				}
461 #endif
462 				free(stringType);
463 			}
464 			else{
465 				LogError(0, RS_RET_OUT_OF_MEMORY,
466 						"omczmq: out of memory");
467 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
468 			}
469 		}
470 		else if(!strcmp(actpblk.descr[i].name, "topicframe")) {
471 			pData-&gt;topicFrame = pvals[i].val.d.n;
472 			DBGPRINTF("omczmq: topicFrame set to %s\n", pData-&gt;topicFrame ? "true" : "false");
473 		}
474 		else if(!strcmp(actpblk.descr[i].name, "topics")) {
475 			pData-&gt;topics = zlist_new();
476 			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
477 			DBGPRINTF("omczmq: topics set to %s\n", topics);
478 			char *topics_org = topics;
479 			char topic[256];
480 			if(topics == NULL){
481 				LogError(0, RS_RET_OUT_OF_MEMORY,
482 					"out of memory");
483 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
484 			}
485 			while(*topics) {
486 				char *delimiter = strchr(topics, ',');
487 				if (!delimiter) {
488 					delimiter = topics + strlen(topics);
489 				}
490 				memcpy (topic, topics, delimiter - topics);
491 				topic[delimiter-topics] = 0;
492 				char *current_topic = strdup(topic);
493 				zlist_append (pData-&gt;topics, current_topic);
494 				if(*delimiter == 0) {
495 					break;
496 				}
497 				topics = delimiter + 1;
498 			}
499 			free(topics_org);
500 		}
501 		else {
502 			LogError(0, NO_ERRCODE,
503 					"omczmq: config error - '%s' is not a valid option",
504 					actpblk.descr[i].name);
505 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
506 		}
507 	}
508 	iNumTpls = 1;
509 	if (pData-&gt;dynaTopic) {
510 		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
511 	}
512 	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
513 	if (pData-&gt;tplName == NULL) {
514 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup("RSYSLOG_ForwardFormat"),
515 					OMSR_NO_RQD_TPL_OPTS));
516 	}
517 	else {
518 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
519 	}
520 	i = 1;
521 	if (pData-&gt;dynaTopic) {
522 		char *topic = zlist_first(pData-&gt;topics);
523 		while (topic) {
524 			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
525 			i++;
526 			topic = zlist_next(pData-&gt;topics);
527 		}
528 	}
529 	CODE_STD_FINALIZERnewActInst
530 	cnfparamvalsDestruct(pvals, &amp;actpblk);
531 ENDnewActInst
532 BEGINinitConfVars
533 CODESTARTinitConfVars
534 ENDinitConfVars
535 NO_LEGACY_CONF_parseSelectorAct
536 BEGINmodExit
537 CODESTARTmodExit
538 ENDmodExit
539 BEGINqueryEtryPt
540 CODESTARTqueryEtryPt
541 	CODEqueryEtryPt_STD_OMOD_QUERIES
542 	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
543 	CODEqueryEtryPt_STD_CONF2_QUERIES
544 	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
545 	CODEqueryEtryPt_STD_OMOD8_QUERIES
546 ENDqueryEtryPt
547 BEGINmodInit()
548 CODESTARTmodInit
549 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
550 CODEmodInit_QueryRegCFSLineHdlr
551 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
552 	DBGPRINTF("omczmq: module compiled with rsyslog version %s.\n", VERSION);
553 	INITLegCnfVars
554 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imudp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;unistd.h&gt;
8 #include &lt;netdb.h&gt;
9 #include &lt;sys/socket.h&gt;
10 #include &lt;pthread.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;poll.h&gt;
13 #ifdef HAVE_SYS_EPOLL_H
14 #	include &lt;sys/epoll.h&gt;
15 #endif
16 #ifdef HAVE_SCHED_H
17 #	include &lt;sched.h&gt;
18 #endif
19 #ifdef HAVE_SYS_PRCTL_H
20 #  include &lt;sys/prctl.h&gt;
21 #endif
22 #include "rsyslog.h"
23 #include "dirty.h"
24 #include "net.h"
25 #include "cfsysline.h"
26 #include "module-template.h"
27 #include "srUtils.h"
28 #include "errmsg.h"
29 #include "glbl.h"
30 #include "msg.h"
31 #include "parser.h"
32 #include "datetime.h"
33 #include "prop.h"
34 #include "ruleset.h"
35 #include "statsobj.h"
36 #include "ratelimit.h"
37 #include "unicode-helper.h"
38 MODULE_TYPE_INPUT
39 MODULE_TYPE_NOKEEP
40 MODULE_CNFNAME("imudp")
41 #define MAX_WRKR_THREADS 32
42 DEF_IMOD_STATIC_DATA
43 DEFobjCurrIf(glbl)
44 DEFobjCurrIf(net)
45 DEFobjCurrIf(datetime)
46 DEFobjCurrIf(prop)
47 DEFobjCurrIf(ruleset)
48 DEFobjCurrIf(statsobj)
49 static struct lstn_s {
50 	struct lstn_s *next;
51 	int sock;			ruleset_t *pRuleset;		prop_t *pInputName;
52 	statsobj_t *stats;		ratelimit_t *ratelimiter;
53 	uchar *dfltTZ;
54 	STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
55 	STATSCOUNTER_DEF(ctrDisallowed, mutCtrDisallowed)
56 } *lcnfRoot = NULL, *lcnfLast = NULL;
57 static int bLegacyCnfModGlobalsPermitted;static int bDoACLCheck;			static int iMaxLine;			#define BATCH_SIZE_DFLT 32		#define TIME_REQUERY_DFLT 2
58 #define SCHED_PRIO_UNSET -12345678	static struct configSettings_s {
59 	uchar *pszBindAddr;			char  *pszBindDevice;			uchar *pszSchedPolicy;			uchar *pszBindRuleset;			int iSchedPrio;				int iTimeRequery;		} cs;
60 struct instanceConf_s {
61 	uchar *pszBindAddr;			char  *pszBindDevice;			uchar *pszBindPort;			uchar *pszBindRuleset;			uchar *inputname;
62 	ruleset_t *pBindRuleset;		uchar *dfltTZ;
63 	unsigned int ratelimitInterval;
64 	unsigned int ratelimitBurst;
65 	int ipfreebind;
66 	struct instanceConf_s *next;
67 	sbool bAppendPortToInpname;
68 };
69 static struct wrkrInfo_s {
70 	pthread_t tid;		int id;
71 	thrdInfo_t *pThrd;
72 	statsobj_t *stats;		STATSCOUNTER_DEF(ctrCall_recvmmsg, mutCtrCall_recvmmsg)
73 	STATSCOUNTER_DEF(ctrCall_recvmsg, mutCtrCall_recvmsg)
74 	STATSCOUNTER_DEF(ctrMsgsRcvd, mutCtrMsgsRcvd)
75 	uchar *pRcvBuf;		#	ifdef HAVE_RECVMMSG
76 	struct sockaddr_storage *frominet;
77 	struct mmsghdr *recvmsg_mmh;
78 	struct iovec *recvmsg_iov;
79 #	endif
80 } wrkrInfo[MAX_WRKR_THREADS];
81 struct modConfData_s {
82 	rsconf_t *pConf;			instanceConf_t *root, *tail;
83 	uchar *pszSchedPolicy;			int iSchedPolicy;			int iSchedPrio;				int iTimeRequery;			int batchSize;				int8_t wrkrMax;				sbool configSetViaV2Method;
84 	sbool bPreserveCase;	};
85 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
86 <a name="2"></a>static struct cnfparamdescr modpdescr[] = {
87 	{ "schedulingpolicy", eCmdHdlrGetWord, 0 },
88 	{ "schedulingpriority", eCmdHdlrInt, 0 },
89 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "batchsize", eCmdHdlrInt, 0 },
90 	{ "threads", eCmdHdlrPositiveInt, 0 },
91 	{ "timerequery", eCmdHdlrInt, 0 },
92 	{ "preservecase", eCmdHdlrBinary, 0 }
93 };
94 static struct cnfparamblk modpblk =
95 	{ CNFPARAMBLK_VERSION,
96 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
97 	  modpdescr
98 	};</b></font>
99 <a name="0"></a>static struct cnfparamdescr inppdescr[] = {
100 	{ "port", eCmdHdlrArray, CNFPARAM_REQUIRED }, <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "defaulttz", eCmdHdlrString, 0 },
101 	{ "inputname", eCmdHdlrGetWord, 0 },
102 	{ "inputname.appendport", eCmdHdlrBinary, 0 },
103 	{ "name", eCmdHdlrGetWord, 0 },
104 	{ "name.appendport", eCmdHdlrBinary, 0 },
105 	{ "address", eCmdHdlrString, 0 },
106 	{ "device", eCmdHdlrString, 0 },
107 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
108 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
109 	{ "rcvbufsize", eCmdHdlrSize, 0 },
110 	{ "ipfreebind", eCmdHdlrInt, 0 },
111 	{ "ruleset", eCmdHdlrString, 0 }
112 };
113 static struct cnfparamblk inppblk =
114 	{ CNFPARAMBLK_VERSION,
115 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
116 	  inppdescr
117 	};
118 #include "im-helper.h" 
119 static rsRetVal
120 createInstance(instanceConf_t **pinst)
121 {</b></font>
122 	instanceConf_t *inst;
123 	DEFiRet;
124 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
125 	inst-&gt;next = NULL;
126 	inst-&gt;pBindRuleset = NULL;
127 	inst-&gt;pszBindPort = NULL;
128 	inst-&gt;pszBindAddr = NULL;
129 	inst-&gt;pszBindDevice = NULL;
130 	inst-&gt;pszBindRuleset = NULL;
131 	inst-&gt;inputname = NULL;
132 	inst-&gt;bAppendPortToInpname = 0;
133 	inst-&gt;ratelimitBurst = 10000; 	inst-&gt;ratelimitInterval = 0; 	inst-&gt;rcvbuf = 0;
134 	inst-&gt;ipfreebind = IPFREEBIND_ENABLED_WITH_LOG;
135 	inst-&gt;dfltTZ = NULL;
136 	if(loadModConf-&gt;tail == NULL) {
137 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
138 	} else {
139 		loadModConf-&gt;tail-&gt;next = inst;
140 		loadModConf-&gt;tail = inst;
141 	}
142 	*pinst = inst;
143 finalize_it:
144 	RETiRet;
145 }
146 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
147 {
148 	instanceConf_t *inst;
149 	DEFiRet;
150 	CHKiRet(createInstance(&amp;inst));
151 	CHKmalloc(inst-&gt;pszBindPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
152 				 	       ? (uchar*) "514" : pNewVal));
153 	if((cs.pszBindAddr == NULL) || (cs.pszBindAddr[0] == '\0')) {
154 		inst-&gt;pszBindAddr = NULL;
155 	} else {
156 		CHKmalloc(inst-&gt;pszBindAddr = ustrdup(cs.pszBindAddr));
157 	}
158 	if((cs.pszBindDevice == NULL) || (cs.pszBindDevice[0] == '\0')) {
159 		inst-&gt;pszBindDevice= NULL;
160 	} else {
161 		CHKmalloc(inst-&gt;pszBindDevice = strdup(cs.pszBindDevice));
162 	}
163 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
164 		inst-&gt;pszBindRuleset = NULL;
165 	} else {
166 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
167 	}
168 finalize_it:
169 	free(pNewVal);
170 	RETiRet;
171 }
172 static rsRetVal
173 addListner(instanceConf_t *inst)
174 {
175 	DEFiRet;
176 	uchar *bindAddr;
177 	int *newSocks;
178 	int iSrc;
179 	struct lstn_s *newlcnfinfo;
180 	uchar *bindName;
181 	uchar *port;
182 	uchar dispname[64], inpnameBuf[128];
183 	uchar *inputname;
184 	if(inst-&gt;pszBindAddr == NULL)
185 		bindAddr = NULL;
186 	else if(inst-&gt;pszBindAddr[0] == '*' &amp;&amp; inst-&gt;pszBindAddr[1] == '\0')
187 		bindAddr = NULL;
188 	else
189 		bindAddr = inst-&gt;pszBindAddr;
190 	bindName = (bindAddr == NULL) ? (uchar*)"*" : bindAddr;
191 	port = (inst-&gt;pszBindPort == NULL || *inst-&gt;pszBindPort == '\0') ? (uchar*) "514" : inst-&gt;pszBindPort;
192 	DBGPRINTF("Trying to open syslog UDP ports at %s:%s.\n", bindName, inst-&gt;pszBindPort);
193 	newSocks = net.create_udp_socket(bindAddr, port, 1, inst-&gt;rcvbuf, 0, inst-&gt;ipfreebind, inst-&gt;pszBindDevice);
194 	if(newSocks != NULL) {
195 		for(iSrc = 1 ; iSrc &lt;= newSocks[0] ; ++iSrc) {
196 			struct sockaddr_in sa;
197 			socklen_t salen = sizeof(sa);
198 			const char *suffix;
199 			CHKmalloc(newlcnfinfo = (struct lstn_s*) calloc(1, sizeof(struct lstn_s)));
200 			newlcnfinfo-&gt;next = NULL;
201 			newlcnfinfo-&gt;sock = newSocks[iSrc];
202 			newlcnfinfo-&gt;pRuleset = inst-&gt;pBindRuleset;
203 			newlcnfinfo-&gt;dfltTZ = inst-&gt;dfltTZ;
204 			newlcnfinfo-&gt;ratelimiter = NULL;
205 			sa.sin_family = 0; 			if(getsockname(newlcnfinfo-&gt;sock, (struct sockaddr*) &amp;sa, &amp;salen) != 0) {
206 				suffix = "error_getting_AF...";
207 			} else {
208 				if(sa.sin_family == AF_INET) {
209 					suffix = "IPv4";
210 				} else if(sa.sin_family == AF_INET6) {
211 					suffix = "IPv6";
212 				} else {
213 					suffix = "AF_unknown";
214 				}
215 			}
216 			if(inst-&gt;inputname == NULL) {
217 				inputname = (uchar*)"imudp";
218 			} else {
219 				inputname = inst-&gt;inputname;
220 			}
221 			snprintf((char*)dispname, sizeof(dispname), "%s(%s/%s/%s)",
222 				inputname, bindName, port, suffix);
223 			dispname[sizeof(dispname)-1] = '\0'; 			CHKiRet(ratelimitNew(&amp;newlcnfinfo-&gt;ratelimiter, (char*)dispname, NULL));
224 			ratelimitSetLinuxLike(newlcnfinfo-&gt;ratelimiter, inst-&gt;ratelimitInterval,
225 					      inst-&gt;ratelimitBurst);
226 			ratelimitSetThreadSafe(newlcnfinfo-&gt;ratelimiter);
227 			if(inst-&gt;bAppendPortToInpname) {
228 				snprintf((char*)inpnameBuf, sizeof(inpnameBuf), "%s%s",
229 					inputname, port);
230 				inpnameBuf[sizeof(inpnameBuf)-1] = '\0';
231 				inputname = inpnameBuf;
232 			}
233 			CHKiRet(prop.Construct(&amp;newlcnfinfo-&gt;pInputName));
234 			CHKiRet(prop.SetString(newlcnfinfo-&gt;pInputName,
235 				inputname, ustrlen(inputname)));
236 			CHKiRet(prop.ConstructFinalize(newlcnfinfo-&gt;pInputName));
237 			CHKiRet(statsobj.Construct(&amp;(newlcnfinfo-&gt;stats)));
238 			CHKiRet(statsobj.SetName(newlcnfinfo-&gt;stats, dispname));
239 			CHKiRet(statsobj.SetOrigin(newlcnfinfo-&gt;stats, (uchar*)"imudp"));
240 			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrSubmit, newlcnfinfo-&gt;mutCtrSubmit);
241 			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT("submitted"),
242 				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrSubmit)));
243 			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrDisallowed, newlcnfinfo-&gt;mutCtrDisallowed);
244 			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT("disallowed"),
245 				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrDisallowed)));
246 			CHKiRet(statsobj.ConstructFinalize(newlcnfinfo-&gt;stats));
247 			if(lcnfRoot == NULL)
248 				lcnfRoot = newlcnfinfo;
249 			if(lcnfLast == NULL)
250 				lcnfLast = newlcnfinfo;
251 			else {
252 				lcnfLast-&gt;next = newlcnfinfo;
253 				lcnfLast = newlcnfinfo;
254 			}
255 		}
256 	} else {
257 		LogError(0, NO_ERRCODE, "imudp: Could not create udp listener,"
258 				" ignoring port %s bind-address %s.",
259 				port, bindAddr);
260 	}
261 finalize_it:
262 	if(iRet != RS_RET_OK) {
263 		if(newlcnfinfo != NULL) {
264 			if(newlcnfinfo-&gt;ratelimiter != NULL)
265 				ratelimitDestruct(newlcnfinfo-&gt;ratelimiter);
266 			if(newlcnfinfo-&gt;pInputName != NULL)
267 				prop.Destruct(&amp;newlcnfinfo-&gt;pInputName);
268 			if(newlcnfinfo-&gt;stats != NULL)
269 				statsobj.Destruct(&amp;newlcnfinfo-&gt;stats);
270 			free(newlcnfinfo);
271 		}
272 		for(; iSrc &lt;= newSocks[0]; iSrc++) {
273 			close(newSocks[iSrc]);
274 		}
275 	}
276 	free(newSocks);
277 	RETiRet;
278 }
279 static inline void
280 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
281 {
282 	LogError(0, NO_ERRCODE, "imudp: ruleset '%s' for %s:%s not found - "
283 			"using default ruleset instead", inst-&gt;pszBindRuleset,
284 			inst-&gt;pszBindAddr == NULL ? "*" : (char*) inst-&gt;pszBindAddr,
285 			inst-&gt;pszBindPort);
286 }
287 static rsRetVal
288 processPacket(struct lstn_s *lstn, struct sockaddr_storage *frominetPrev, int *pbIsPermitted,
289 	uchar *rcvBuf, ssize_t lenRcvBuf, struct syslogTime *stTime, time_t ttGenTime,
290 	struct sockaddr_storage *frominet, socklen_t socklen, multi_submit_t *multiSub)
291 {
292 	DEFiRet;
293 	smsg_t *pMsg = NULL;
294 	if(lenRcvBuf == 0)
295 		FINALIZE; 
296 	if(bDoACLCheck) {
297 		socklen = sizeof(struct sockaddr_storage);
298 		if(net.CmpHost(frominet, frominetPrev, socklen) != 0) {
299 			*pbIsPermitted = net.isAllowedSender2((uchar*)"UDP",
300 					    (struct sockaddr *)frominet, "", 0);
301 			if(*pbIsPermitted == 0) {
302 				DBGPRINTF("msg is not from an allowed sender\n");
303 				STATSCOUNTER_INC(lstn-&gt;ctrDisallowed, lstn-&gt;mutCtrDisallowed);
304 				if(glbl.GetOptionDisallowWarning(runModConf-&gt;pConf)) {
305 					LogError(0, NO_ERRCODE,
306 						"imudp: UDP message from disallowed sender discarded");
307 				}
308 			}
309 		}
310 	} else {
311 		*pbIsPermitted = 1; 	}
312 	DBGPRINTF("recv(%d,%d),acl:%d,msg:%.*s\n", lstn-&gt;sock, (int) lenRcvBuf, *pbIsPermitted,
313 			(int)lenRcvBuf, rcvBuf);
314 	if(*pbIsPermitted != 0)  {
315 		CHKiRet(msgConstructWithTime(&amp;pMsg, stTime, ttGenTime));
316 		MsgSetRawMsg(pMsg, (char*)rcvBuf, lenRcvBuf);
317 		MsgSetInputName(pMsg, lstn-&gt;pInputName);
318 		MsgSetRuleset(pMsg, lstn-&gt;pRuleset);
319 		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
320 		if(lstn-&gt;dfltTZ != NULL)
321 			MsgSetDfltTZ(pMsg, (char*) lstn-&gt;dfltTZ);
322 		pMsg-&gt;msgFlags  = NEEDS_PARSING | PARSE_HOSTNAME | NEEDS_DNSRESOL;
323 		if(*pbIsPermitted == 2) {
324 			pMsg-&gt;msgFlags |= NEEDS_ACLCHK_U; 		}
325 		if(runModConf-&gt;bPreserveCase) {
326 			pMsg-&gt;msgFlags |= PRESERVE_CASE; 		}
327 		CHKiRet(msgSetFromSockinfo(pMsg, frominet));
328 		CHKiRet(ratelimitAddMsg(lstn-&gt;ratelimiter, multiSub, pMsg));
329 		STATSCOUNTER_INC(lstn-&gt;ctrSubmit, lstn-&gt;mutCtrSubmit);
330 	}
331 finalize_it:
332 	if(iRet != RS_RET_OK) {
333 		if(pMsg != NULL &amp;&amp; iRet != RS_RET_DISCARDMSG) {
334 			msgDestruct(&amp;pMsg);
335 		}
336 	}
337 	RETiRet;
338 }
339 #ifdef HAVE_RECVMMSG
340 static rsRetVal
341 processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
342 int *pbIsPermitted)
343 {
344 	DEFiRet;
345 	int iNbrTimeUsed;
346 	struct syslogTime stTime;
347 	char errStr[1024];
348 	smsg_t *pMsgs[CONF_NUM_MULTISUB];
349 	multi_submit_t multiSub;
350 	int nelem;
351 	int i;
352 	multiSub.ppMsgs = pMsgs;
353 	multiSub.maxElem = CONF_NUM_MULTISUB;
354 	multiSub.nElem = 0;
355 	iNbrTimeUsed = 0;
356 	while(1) { 		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
357 			ABORT_FINALIZE(RS_RET_FORCE_TERM);
358 		memset(pWrkr-&gt;recvmsg_iov, 0, runModConf-&gt;batchSize * sizeof(struct iovec));
359 		memset(pWrkr-&gt;recvmsg_mmh, 0, runModConf-&gt;batchSize * sizeof(struct mmsghdr));
360 		for(i = 0 ; i &lt; runModConf-&gt;batchSize ; ++i) {
361 			pWrkr-&gt;recvmsg_iov[i].iov_base = pWrkr-&gt;pRcvBuf+(i*(iMaxLine+1));
362 			pWrkr-&gt;recvmsg_iov[i].iov_len = iMaxLine;
363 			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen = sizeof(struct sockaddr_storage);
364 			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_name = &amp;(pWrkr-&gt;frominet[i]);
365 			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov = &amp;(pWrkr-&gt;recvmsg_iov[i]);
366 			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iovlen = 1;
367 		}
368 		nelem = recvmmsg(lstn-&gt;sock, pWrkr-&gt;recvmsg_mmh, runModConf-&gt;batchSize, 0, NULL);
369 		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
370 		DBGPRINTF("imudp: recvmmsg returned %d\n", nelem);
371 		if(nelem &lt; 0 &amp;&amp; errno == ENOSYS) {
372 			DBGPRINTF("imudp: error ENOSYS on call to recvmmsg() - fall back to recvmsg\n");
373 			nelem = recvmsg(lstn-&gt;sock, &amp;(pWrkr-&gt;recvmsg_mmh[0].msg_hdr), 0);
374 			STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
375 			if(nelem &gt;= 0) {
376 				pWrkr-&gt;recvmsg_mmh[0].msg_len = nelem;
377 				nelem = 1;
378 			}
379 		}
380 		if(nelem &lt; 0) {
381 			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
382 				rs_strerror_r(errno, errStr, sizeof(errStr));
383 				DBGPRINTF("INET socket error: %d = %s.\n", errno, errStr);
384 				LogError(errno, NO_ERRCODE, "imudp: error receiving on socket: %s", errStr);
385 			}
386 			ABORT_FINALIZE(RS_RET_ERR);
387 		}
388 		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
389 			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
390 		}
391 		pWrkr-&gt;ctrMsgsRcvd += nelem;
392 		for(i = 0 ; i &lt; nelem ; ++i) {
393 			processPacket(lstn, frominetPrev, pbIsPermitted,
394 				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov-&gt;iov_base,
395 				pWrkr-&gt;recvmsg_mmh[i].msg_len, &amp;stTime, ttGenTime, &amp;(pWrkr-&gt;frominet[i]),
396 				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen, &amp;multiSub);
397 		}
398 	}
399 finalize_it:
400 	multiSubmitFlush(&amp;multiSub);
401 	RETiRet;
402 }
403 static rsRetVal
404 processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
405 int *pbIsPermitted)
406 {
407 	int iNbrTimeUsed;
408 	time_t ttGenTime;
409 	struct syslogTime stTime;
410 	ssize_t lenRcvBuf;
411 	struct sockaddr_storage frominet;
412 	multi_submit_t multiSub;
413 	smsg_t *pMsgs[CONF_NUM_MULTISUB];
414 	char errStr[1024];
415 	struct msghdr mh;
416 	struct iovec iov[1];
417 	DEFiRet;
418 	multiSub.ppMsgs = pMsgs;
419 	multiSub.maxElem = CONF_NUM_MULTISUB;
420 	multiSub.nElem = 0;
421 	iNbrTimeUsed = 0;
422 	while(1) { 		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
423 			ABORT_FINALIZE(RS_RET_FORCE_TERM);
424 		memset(iov, 0, sizeof(iov));
425 		iov[0].iov_base = pWrkr-&gt;pRcvBuf;
426 		iov[0].iov_len = iMaxLine;
427 		memset(&amp;mh, 0, sizeof(mh));
428 		mh.msg_name = &amp;frominet;
429 		mh.msg_namelen = sizeof(struct sockaddr_storage);
430 		mh.msg_iov = iov;
431 		mh.msg_iovlen = 1;
432 		lenRcvBuf = recvmsg(lstn-&gt;sock, &amp;mh, 0);
433 		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
434 		if(lenRcvBuf &lt; 0) {
435 			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
436 				rs_strerror_r(errno, errStr, sizeof(errStr));
437 				DBGPRINTF("INET socket error: %d = %s.\n", errno, errStr);
438 				LogError(errno, NO_ERRCODE, "imudp: error receiving on socket: %s", errStr);
439 			}
440 			ABORT_FINALIZE(RS_RET_ERR);
441 		}
442 		++pWrkr-&gt;ctrMsgsRcvd;
443 		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
444 			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
445 		}
446 		CHKiRet(processPacket(lstn, frominetPrev, pbIsPermitted, pWrkr-&gt;pRcvBuf, lenRcvBuf, &amp;stTime,
447 			ttGenTime, &amp;frominet, mh.msg_namelen, &amp;multiSub));
448 	}
449 finalize_it:
450 	multiSubmitFlush(&amp;multiSub);
451 	RETiRet;
452 }
453 #endif 
454 static rsRetVal
455 checkSchedulingPriority(modConfData_t *modConf)
456 {
457 	DEFiRet;
458 #ifdef HAVE_SCHED_GET_PRIORITY_MAX
459 	if(   modConf-&gt;iSchedPrio &lt; sched_get_priority_min(modConf-&gt;iSchedPolicy)
460 	   || modConf-&gt;iSchedPrio &gt; sched_get_priority_max(modConf-&gt;iSchedPolicy)) {
461 		LogError(0, NO_ERRCODE,
462 			"imudp: scheduling priority %d out of range (%d - %d)"
463 			" for scheduling policy '%s' - ignoring settings",
464 			modConf-&gt;iSchedPrio,
465 			sched_get_priority_min(modConf-&gt;iSchedPolicy),
466 			sched_get_priority_max(modConf-&gt;iSchedPolicy),
467 			modConf-&gt;pszSchedPolicy);
468 		ABORT_FINALIZE(RS_RET_VALIDATION_RUN);
469 	}
470 finalize_it:
471 #endif
472 	RETiRet;
473 }
474 static rsRetVal
475 checkSchedulingPolicy(modConfData_t *modConf)
476 {
477 	DEFiRet;
478 	if (0) { #ifdef SCHED_FIFO
479 	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "fifo")) {
480 		modConf-&gt;iSchedPolicy = SCHED_FIFO;
481 #endif
482 #ifdef SCHED_RR
483 	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "rr")) {
484 		modConf-&gt;iSchedPolicy = SCHED_RR;
485 #endif
486 #ifdef SCHED_OTHER
487 	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "other")) {
488 		modConf-&gt;iSchedPolicy = SCHED_OTHER;
489 #endif
490 	} else {
491 		LogError(errno, NO_ERRCODE,
492 			    "imudp: invalid scheduling policy '%s' "
493 			    "- ignoring setting", modConf-&gt;pszSchedPolicy);
494 		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
495 	}
496 finalize_it:
497 	RETiRet;
498 }
499 static rsRetVal
500 checkSchedParam(modConfData_t *modConf)
501 {
502 	DEFiRet;
503 	if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET) {
504 		LogError(0, RS_RET_ERR_SCHED_PARAMS,
505 			"imudp: scheduling policy set, but without priority - ignoring settings");
506 		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
507 	} else if(modConf-&gt;pszSchedPolicy == NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
508 		LogError(0, RS_RET_ERR_SCHED_PARAMS,
509 			"imudp: scheduling priority set, but without policy - ignoring settings");
510 		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
511 	} else if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
512 		CHKiRet(checkSchedulingPolicy(modConf));
513 		CHKiRet(checkSchedulingPriority(modConf));
514 	} else { 		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; 	}
515 #ifndef HAVE_PTHREAD_SETSCHEDPARAM
516 	LogError(0, NO_ERRCODE,
517 		"imudp: cannot set thread scheduling policy, "
518 		"pthread_setschedparam() not available");
519 	ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
520 #endif
521 finalize_it:
522 	if(iRet != RS_RET_OK)
523 		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; 
524 	RETiRet;
525 }
526 static rsRetVal
527 setSchedParams(modConfData_t *modConf)
528 {
529 	DEFiRet;
530 #	ifdef HAVE_PTHREAD_SETSCHEDPARAM
531 	int err;
532 	struct sched_param sparam;
533 	if(modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET)
534 		FINALIZE;
535 	memset(&amp;sparam, 0, sizeof sparam);
536 	sparam.sched_priority = modConf-&gt;iSchedPrio;
537 	dbgprintf("imudp trying to set sched policy to '%s', prio %d\n",
538 		  modConf-&gt;pszSchedPolicy, modConf-&gt;iSchedPrio);
539 	err = pthread_setschedparam(pthread_self(), modConf-&gt;iSchedPolicy, &amp;sparam);
540 	if(err != 0) {
541 		LogError(err, NO_ERRCODE, "imudp: pthread_setschedparam() failed - ignoring");
542 	}
543 finalize_it:
544 #	endif
545 	RETiRet;
546 }
547 #if defined(HAVE_EPOLL_CREATE1) || defined(HAVE_EPOLL_CREATE)
548 #define NUM_EPOLL_EVENTS 10
549 static rsRetVal
550 rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
551 {
552 	DEFiRet;
553 	int nfds;
554 	int efd;
555 	int i;
556 	struct sockaddr_storage frominetPrev;
557 	int bIsPermitted;
558 	struct epoll_event *udpEPollEvt = NULL;
559 	struct epoll_event currEvt[NUM_EPOLL_EVENTS];
560 	char errStr[1024];
561 	struct lstn_s *lstn;
562 	int nLstn;
563 	bIsPermitted = 0;
564 	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));
565 	nLstn = 0;
566 	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next)
567 		++nLstn;
568 	if(nLstn == 0) {
569 		LogError(errno, RS_RET_ERR,
570 			"imudp error: we have 0 listeners, terminating"
571 			"worker thread");
572 		ABORT_FINALIZE(RS_RET_ERR);
573 	}
574 	CHKmalloc(udpEPollEvt = calloc(nLstn, sizeof(struct epoll_event)));
575 #if defined(EPOLL_CLOEXEC) &amp;&amp; defined(HAVE_EPOLL_CREATE1)
576 	DBGPRINTF("imudp uses epoll_create1()\n");
577 	efd = epoll_create1(EPOLL_CLOEXEC);
578 	if(efd &lt; 0 &amp;&amp; errno == ENOSYS)
579 #endif
580 	{
581 		DBGPRINTF("imudp uses epoll_create()\n");
582 		efd = epoll_create(NUM_EPOLL_EVENTS);
583 	}
584 	if(efd &lt; 0) {
585 		DBGPRINTF("epoll_create1() could not create fd\n");
586 		ABORT_FINALIZE(RS_RET_IO_ERROR);
587 	}
588 	i = 0;
589 	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
590 		if(lstn-&gt;sock != -1) {
591 			udpEPollEvt[i].events = EPOLLIN | EPOLLET;
592 			udpEPollEvt[i].data.ptr = lstn;
593 			if(epoll_ctl(efd, EPOLL_CTL_ADD,  lstn-&gt;sock, &amp;(udpEPollEvt[i])) &lt; 0) {
594 				rs_strerror_r(errno, errStr, sizeof(errStr));
595 				LogError(errno, NO_ERRCODE, "epoll_ctrl failed on fd %d with %s\n",
596 					lstn-&gt;sock, errStr);
597 			}
598 		}
599 		i++;
600 	}
601 	while(1) {
602 		nfds = epoll_wait(efd, currEvt, NUM_EPOLL_EVENTS, -1);
603 		DBGPRINTF("imudp: epoll_wait() returned with %d fds\n", nfds);
604 		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
605 			break; 
606 		for(i = 0 ; i &lt; nfds ; ++i) {
607 			processSocket(pWrkr, currEvt[i].data.ptr, &amp;frominetPrev, &amp;bIsPermitted);
608 		}
609 		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
610 			break; 	}
611 finalize_it:
612 	if(udpEPollEvt != NULL)
613 		free(udpEPollEvt);
614 	RETiRet;
615 }
616 #else static rsRetVal ATTR_NONNULL()
617 rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
618 {
619 	DEFiRet;
620 	int nfds;
621 	struct sockaddr_storage frominetPrev;
622 	int bIsPermitted;
623 	int i = 0;
624 	struct lstn_s *lstn;
625 	DBGPRINTF("imudp uses poll() [ex-select]\n");
626 	bIsPermitted = 0;
627 	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));
628 	int nfd = 0;
629 	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
630 		if(lstn-&gt;sock != -1) {
631 			if(Debug) {
632 				net.debugListenInfo(lstn-&gt;sock, (char*)"UDP");
633 			}
634 			++nfd;
635 		}
636 	}
637 	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
638 	CHKmalloc(pollfds);
639 	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
640 		assert(i &lt; nfd);
641 		if (lstn-&gt;sock != -1) {
642 			pollfds[i].fd = lstn-&gt;sock;
643 			pollfds[i].events = POLLIN;
644 			++i;
645 		}
646 	}
647 	while(1) {
648 		DBGPRINTF("--------imudp calling poll() on %d fds\n", nfd);
649 		nfds = poll(pollfds, nfd, -1);
650 		if(glbl.GetGlobalInputTermState() == 1)
651 			break; 
652 		if(nfds &lt; 0) {
653 			if(errno == EINTR) {
654 				DBGPRINTF("imudp: EINTR occurred\n");
655 			} else {
656 				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, "imudp: poll "
657 					"system call failed, may cause further troubles");
658 			}
659 			nfds = 0;
660 		}
661 		i = 0;
662 		for(lstn = lcnfRoot ; nfds &amp;&amp; lstn != NULL ; lstn = lstn-&gt;next) {
663 			assert(i &lt; nfd);
664 			if(lstn-&gt;sock != -1) {
665 				if(glbl.GetGlobalInputTermState() == 1)
666 					ABORT_FINALIZE(RS_RET_FORCE_TERM); 				if(pollfds[i].revents &amp; POLLIN) {
667 					processSocket(pWrkr, lstn, &amp;frominetPrev, &amp;bIsPermitted);
668 					--nfds;
669 				}
670 				++i;
671 			}
672 	       }
673 	}
674 finalize_it:
675 	RETiRet;
676 }
677 #endif 
678 static rsRetVal
679 createListner(es_str_t *port, struct cnfparamvals *pvals)
680 {
681 	instanceConf_t *inst;
682 	int i;
683 	int bAppendPortUsed = 0;
684 	DEFiRet;
685 	CHKiRet(createInstance(&amp;inst));
686 	inst-&gt;pszBindPort = (uchar*)es_str2cstr(port, NULL);
687 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
688 		if(!pvals[i].bUsed)
689 			continue;
690 		if(!strcmp(inppblk.descr[i].name, "port")) {
691 			continue;			} else if(!strcmp(inppblk.descr[i].name, "name")) {
692 			if(inst-&gt;inputname != NULL) {
693 				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name and inputname "
694 						"parameter specified - only one can be used");
695 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
696 			}
697 			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
698 		} else if(!strcmp(inppblk.descr[i].name, "name.appendport")) {
699 			if(bAppendPortUsed) {
700 				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name.appendport and "
701 						"inputname.appendport parameter specified - only one can be used");
702 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
703 			}
704 			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
705 			bAppendPortUsed = 1;
706 		} else if(!strcmp(inppblk.descr[i].name, "inputname")) {
707 			LogError(0, RS_RET_DEPRECATED , "imudp: deprecated parameter inputname "
708 					"used. Suggest to use name instead");
709 			if(inst-&gt;inputname != NULL) {
710 				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name and inputname "
711 						"parameter specified - only one can be used");
712 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
713 			}
714 			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
715 		} else if(!strcmp(inppblk.descr[i].name, "inputname.appendport")) {
716 			LogError(0, RS_RET_DEPRECATED , "imudp: deprecated parameter inputname.appendport "
717 					"used. Suggest to use name.appendport instead");
718 			if(bAppendPortUsed) {
719 				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name.appendport and "
720 						"inputname.appendport parameter specified - only one can be used");
721 <a name="1"></a>				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
722 			}
723 			bAppendPortUsed = 1;
724 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
725 		} else if(!strcmp(inppblk.descr[i].name, "defaulttz")) {
726 			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
727 <a name="3"></a>		} else if(!strcmp(inppblk.descr[i].name, "address")) {
728 			inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
729 		} else if(!strcmp(inppblk.descr[i].name, "device")) {
730 			inst-&gt;pszBindDevice = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font><font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
731 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
732 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
733 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
734 			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</b></font>
735 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
736 			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
737 		} else if(!strcmp(inppblk.descr[i].name, "rcvbufsize")) {
738 			const uint64_t val = pvals[i].val.d.n;
739 			if(val &gt; 1024 * 1024 * 1024) {
740 				LogError(0, RS_RET_MISSING_CNFPARAMS,
741 					"imudp: rcvbufsize maximum is 1 GiB, using "
742 					"default instead");
743 			} else {
744 				inst-&gt;rcvbuf = (int) val;
745 			}
746 		} else if(!strcmp(inppblk.descr[i].name, "ipfreebind")) {
747 			inst-&gt;ipfreebind = (int) pvals[i].val.d.n;
748 		} else {
749 			dbgprintf("imudp: program error, non-handled "
750 			  "param '%s'\n", inppblk.descr[i].name);
751 		}
752 	}
753 finalize_it:
754 	RETiRet;
755 }
756 BEGINnewInpInst
757 	struct cnfparamvals *pvals;
758 	int i;
759 	int portIdx;
760 CODESTARTnewInpInst
761 	DBGPRINTF("newInpInst (imudp)\n");
762 	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
763 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
764 	}
765 	if(Debug) {
766 		dbgprintf("input param blk in imudp:\n");
767 		cnfparamsPrint(&amp;inppblk, pvals);
768 	}
769 	portIdx = cnfparamGetIdx(&amp;inppblk, "port");
770 	assert(portIdx != -1);
771 	for(i = 0 ; i &lt;  pvals[portIdx].val.d.ar-&gt;nmemb ; ++i) {
772 		createListner(pvals[portIdx].val.d.ar-&gt;arr[i], pvals);
773 	}
774 finalize_it:
775 CODE_STD_FINALIZERnewInpInst
776 	cnfparamvalsDestruct(pvals, &amp;inppblk);
777 ENDnewInpInst
778 BEGINbeginCnfLoad
779 CODESTARTbeginCnfLoad
780 	loadModConf = pModConf;
781 	pModConf-&gt;pConf = pConf;
782 	loadModConf-&gt;configSetViaV2Method = 0;
783 	loadModConf-&gt;wrkrMax = 1; 	loadModConf-&gt;batchSize = BATCH_SIZE_DFLT;
784 	loadModConf-&gt;iTimeRequery = TIME_REQUERY_DFLT;
785 	loadModConf-&gt;iSchedPrio = SCHED_PRIO_UNSET;
786 	loadModConf-&gt;pszSchedPolicy = NULL;
787 	loadModConf-&gt;bPreserveCase = 0; 	bLegacyCnfModGlobalsPermitted = 1;
788 	cs.pszBindRuleset = NULL;
789 	cs.pszSchedPolicy = NULL;
790 	cs.pszBindAddr = NULL;
791 	cs.pszBindDevice = NULL;
792 	cs.iSchedPrio = SCHED_PRIO_UNSET;
793 	cs.iTimeRequery = TIME_REQUERY_DFLT;
794 ENDbeginCnfLoad
795 BEGINsetModCnf
796 	struct cnfparamvals *pvals = NULL;
797 	int i;
798 	int wrkrMax;
799 CODESTARTsetModCnf
800 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
801 	if(pvals == NULL) {
802 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imudp: error processing module "
803 				"config parameters [module(...)]");
804 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
805 	}
806 	if(Debug) {
807 		dbgprintf("module (global) param blk for imudp:\n");
808 		cnfparamsPrint(&amp;modpblk, pvals);
809 	}
810 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
811 		if(!pvals[i].bUsed)
812 			continue;
813 		if(!strcmp(modpblk.descr[i].name, "timerequery")) {
814 			loadModConf-&gt;iTimeRequery = (int) pvals[i].val.d.n;
815 		} else if(!strcmp(modpblk.descr[i].name, "batchsize")) {
816 			loadModConf-&gt;batchSize = (int) pvals[i].val.d.n;
817 		} else if(!strcmp(modpblk.descr[i].name, "schedulingpriority")) {
818 			loadModConf-&gt;iSchedPrio = (int) pvals[i].val.d.n;
819 		} else if(!strcmp(modpblk.descr[i].name, "schedulingpolicy")) {
820 			loadModConf-&gt;pszSchedPolicy = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
821 		} else if(!strcmp(modpblk.descr[i].name, "threads")) {
822 			wrkrMax = (int) pvals[i].val.d.n;
823 			if(wrkrMax &gt; MAX_WRKR_THREADS) {
824 				LogError(0, RS_RET_PARAM_ERROR, "imudp: configured for %d"
825 						"worker threads, but maximum permitted is %d",
826 						wrkrMax, MAX_WRKR_THREADS);
827 				loadModConf-&gt;wrkrMax = MAX_WRKR_THREADS;
828 			} else {
829 				loadModConf-&gt;wrkrMax = wrkrMax;
830 			}
831 		} else if(!strcmp(modpblk.descr[i].name, "preservecase")) {
832 			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
833 		} else {
834 			dbgprintf("imudp: program error, non-handled "
835 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
836 		}
837 	}
838 	bLegacyCnfModGlobalsPermitted = 0;
839 	loadModConf-&gt;configSetViaV2Method = 1;
840 finalize_it:
841 	if(pvals != NULL)
842 		cnfparamvalsDestruct(pvals, &amp;modpblk);
843 ENDsetModCnf
844 BEGINendCnfLoad
845 CODESTARTendCnfLoad
846 	if(!loadModConf-&gt;configSetViaV2Method) {
847 		loadModConf-&gt;iSchedPrio = cs.iSchedPrio;
848 		loadModConf-&gt;iTimeRequery = cs.iTimeRequery;
849 		if((cs.pszSchedPolicy != NULL) &amp;&amp; (cs.pszSchedPolicy[0] != '\0')) {
850 			CHKmalloc(loadModConf-&gt;pszSchedPolicy = ustrdup(cs.pszSchedPolicy));
851 		}
852 	}
853 finalize_it:
854 	loadModConf = NULL; 	free(cs.pszBindRuleset);
855 	free(cs.pszSchedPolicy);
856 	free(cs.pszBindAddr);
857 	free(cs.pszBindDevice);
858 ENDendCnfLoad
859 BEGINcheckCnf
860 	instanceConf_t *inst;
861 CODESTARTcheckCnf
862 	checkSchedParam(pModConf); 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
863 		std_checkRuleset(pModConf, inst);
864 	}
865 	if(pModConf-&gt;root == NULL) {
866 		LogError(0, RS_RET_NO_LISTNERS , "imudp: module loaded, but "
867 				"no listeners defined - no input will be gathered");
868 		iRet = RS_RET_NO_LISTNERS;
869 	}
870 ENDcheckCnf
871 BEGINactivateCnfPrePrivDrop
872 	instanceConf_t *inst;
873 CODESTARTactivateCnfPrePrivDrop
874 	runModConf = pModConf;
875 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
876 		addListner(inst);
877 	}
878 	if(lcnfRoot == NULL) {
879 		LogError(0, NO_ERRCODE, "imudp: no listeners could be started, "
880 				"input not activated.\n");
881 		ABORT_FINALIZE(RS_RET_NO_RUN);
882 	}
883 finalize_it:
884 ENDactivateCnfPrePrivDrop
885 BEGINactivateCnf
886 	int i;
887 	int lenRcvBuf;
888 CODESTARTactivateCnf
889 	iMaxLine = glbl.GetMaxLine(runConf);
890 	lenRcvBuf = iMaxLine + 1;
891 #	ifdef HAVE_RECVMMSG
892 	lenRcvBuf *= runModConf-&gt;batchSize;
893 #	endif
894 	DBGPRINTF("imudp: config params iMaxLine %d, lenRcvBuf %d\n", iMaxLine, lenRcvBuf);
895 	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
896 #		ifdef HAVE_RECVMMSG
897 		CHKmalloc(wrkrInfo[i].recvmsg_iov = malloc(runModConf-&gt;batchSize * sizeof(struct iovec)));
898 		CHKmalloc(wrkrInfo[i].recvmsg_mmh = malloc(runModConf-&gt;batchSize * sizeof(struct mmsghdr)));
899 		CHKmalloc(wrkrInfo[i].frominet = malloc(runModConf-&gt;batchSize * sizeof(struct sockaddr_storage)));
900 #		endif
901 		CHKmalloc(wrkrInfo[i].pRcvBuf = malloc(lenRcvBuf));
902 		wrkrInfo[i].id = i;
903 	}
904 finalize_it:
905 ENDactivateCnf
906 BEGINfreeCnf
907 	instanceConf_t *inst, *del;
908 CODESTARTfreeCnf
909 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
910 		free(inst-&gt;pszBindPort);
911 		free(inst-&gt;pszBindAddr);
912 		free(inst-&gt;pszBindDevice);
913 		free(inst-&gt;pszBindRuleset);
914 		free(inst-&gt;inputname);
915 		free(inst-&gt;dfltTZ);
916 		del = inst;
917 		inst = inst-&gt;next;
918 		free(del);
919 	}
920 ENDfreeCnf
921 static void *
922 wrkr(void *myself)
923 {
924 	struct wrkrInfo_s *pWrkr = (struct wrkrInfo_s*) myself;
925 	uchar thrdName[32];
926 	snprintf((char*)thrdName, sizeof(thrdName), "imudp(w%d)", pWrkr-&gt;id);
927 #	if defined(HAVE_PRCTL) &amp;&amp; defined(PR_SET_NAME)
928 	if(prctl(PR_SET_NAME, thrdName, 0, 0, 0) != 0) {
929 		DBGPRINTF("prctl failed, not setting thread name for '%s'\n", thrdName);
930 	}
931 #	endif
932 	dbgOutputTID((char*)thrdName);
933 	setSchedParams(runModConf);
934 	statsobj.Construct(&amp;(pWrkr-&gt;stats));
935 	statsobj.SetName(pWrkr-&gt;stats, thrdName);
936 	statsobj.SetOrigin(pWrkr-&gt;stats, (uchar*)"imudp");
937 	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
938 	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("called.recvmmsg"),
939 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmmsg));
940 	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
941 	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("called.recvmsg"),
942 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmsg));
943 	STATSCOUNTER_INIT(pWrkr-&gt;ctrMsgsRcvd, pWrkr-&gt;mutCtrMsgsRcvd);
944 	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("msgs.received"),
945 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrMsgsRcvd));
946 	statsobj.ConstructFinalize(pWrkr-&gt;stats);
947 	rcvMainLoop(pWrkr);
948 	return NULL;
949 }
950 BEGINrunInput
951 	int i;
952 	pthread_attr_t wrkrThrdAttr;
953 CODESTARTrunInput
954 	pthread_attr_init(&amp;wrkrThrdAttr);
955 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
956 	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
957 		wrkrInfo[i].pThrd = pThrd;
958 		pthread_create(&amp;wrkrInfo[i].tid, &amp;wrkrThrdAttr, wrkr, &amp;(wrkrInfo[i]));
959 	}
960 	pthread_attr_destroy(&amp;wrkrThrdAttr);
961 	wrkrInfo[i].pThrd = pThrd;
962 	wrkrInfo[i].id = i;
963 	wrkr(&amp;wrkrInfo[i]);
964 	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
965 		pthread_kill(wrkrInfo[i].tid, SIGTTIN);
966 	}
967 	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
968 		pthread_join(wrkrInfo[i].tid, NULL);
969 	}
970 ENDrunInput
971 BEGINwillRun
972 CODESTARTwillRun
973 	net.PrintAllowedSenders(1); 	net.HasRestrictions(UCHAR_CONSTANT("UDP"), &amp;bDoACLCheck); ENDwillRun
974 BEGINafterRun
975 	struct lstn_s *lstn, *lstnDel;
976 	int i;
977 CODESTARTafterRun
978 	net.clearAllowedSenders((uchar*)"UDP");
979 	for(lstn = lcnfRoot ; lstn != NULL ; ) {
980 		statsobj.Destruct(&amp;(lstn-&gt;stats));
981 		ratelimitDestruct(lstn-&gt;ratelimiter);
982 		close(lstn-&gt;sock);
983 		prop.Destruct(&amp;lstn-&gt;pInputName);
984 		lstnDel = lstn;
985 		lstn = lstn-&gt;next;
986 		free(lstnDel);
987 	}
988 	lcnfRoot = lcnfLast = NULL;
989 	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
990 #		ifdef HAVE_RECVMMSG
991 		free(wrkrInfo[i].recvmsg_iov);
992 		free(wrkrInfo[i].recvmsg_mmh);
993 		free(wrkrInfo[i].frominet);
994 #		endif
995 		free(wrkrInfo[i].pRcvBuf);
996 	}
997 ENDafterRun
998 BEGINmodExit
999 CODESTARTmodExit
1000 	objRelease(glbl, CORE_COMPONENT);
1001 	objRelease(statsobj, CORE_COMPONENT);
1002 	objRelease(datetime, CORE_COMPONENT);
1003 	objRelease(prop, CORE_COMPONENT);
1004 	objRelease(ruleset, CORE_COMPONENT);
1005 	objRelease(net, LM_NET_FILENAME);
1006 ENDmodExit
1007 BEGINisCompatibleWithFeature
1008 CODESTARTisCompatibleWithFeature
1009 	if(eFeat == sFEATURENonCancelInputTermination)
1010 		iRet = RS_RET_OK;
1011 ENDisCompatibleWithFeature
1012 BEGINqueryEtryPt
1013 CODESTARTqueryEtryPt
1014 CODEqueryEtryPt_STD_IMOD_QUERIES
1015 CODEqueryEtryPt_STD_CONF2_QUERIES
1016 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1017 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
1018 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
1019 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1020 ENDqueryEtryPt
1021 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
1022 {
1023 	free(cs.pszBindAddr);
1024 	cs.pszBindAddr = NULL;
1025 	free(cs.pszBindDevice);
1026 	cs.pszBindDevice = NULL;
1027 	free(cs.pszSchedPolicy);
1028 	cs.pszSchedPolicy = NULL;
1029 	free(cs.pszBindRuleset);
1030 	cs.pszBindRuleset = NULL;
1031 	cs.iSchedPrio = SCHED_PRIO_UNSET;
1032 	cs.iTimeRequery = TIME_REQUERY_DFLT;	return RS_RET_OK;
1033 }
1034 BEGINmodInit()
1035 CODESTARTmodInit
1036 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1037 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1038 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1039 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1040 	CHKiRet(objUse(prop, CORE_COMPONENT));
1041 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1042 	CHKiRet(objUse(net, LM_NET_FILENAME));
1043 	DBGPRINTF("imudp: version %s initializing\n", VERSION);
1044 #	ifdef HAVE_RECVMMSG
1045 	DBGPRINTF("imdup: support for recvmmsg() present\n");
1046 #	endif
1047 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputudpserverbindruleset", 0, eCmdHdlrGetWord,
1048 		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
1049 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"udpserverrun", 0, eCmdHdlrGetWord,
1050 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
1051 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"udpserveraddress", 0, eCmdHdlrGetWord,
1052 		NULL, &amp;cs.pszBindAddr, STD_LOADABLE_MODULE_ID));
1053 	CHKiRet(regCfSysLineHdlr2((uchar *)"imudpschedulingpolicy", 0, eCmdHdlrGetWord,
1054 		NULL, &amp;cs.pszSchedPolicy, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1055 	CHKiRet(regCfSysLineHdlr2((uchar *)"imudpschedulingpriority", 0, eCmdHdlrInt,
1056 		NULL, &amp;cs.iSchedPrio, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1057 	CHKiRet(regCfSysLineHdlr2((uchar *)"udpservertimerequery", 0, eCmdHdlrInt,
1058 		NULL, &amp;cs.iTimeRequery, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
1059 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
1060 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
1061 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
