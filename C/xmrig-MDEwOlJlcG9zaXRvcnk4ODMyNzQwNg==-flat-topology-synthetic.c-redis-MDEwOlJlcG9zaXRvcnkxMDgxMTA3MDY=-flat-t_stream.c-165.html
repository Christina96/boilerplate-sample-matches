
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/misc.h&quot;
5  #include &quot;private/debug.h&quot;
6  #include &lt;limits.h&gt;
7  #include &lt;assert.h&gt;
8  #ifdef HAVE_STRINGS_H
9  #include &lt;strings.h&gt;
10  #endif
11  struct hwloc_synthetic_attr_s {
12    hwloc_obj_type_t type;
13    unsigned depth; &amp;bsol;* For caches/groups */
14    hwloc_obj_cache_type_t cachetype; &amp;bsol;* For caches */
15    hwloc_uint64_t memorysize; &amp;bsol;* For caches/memory */
16  };
17  struct hwloc_synthetic_indexes_s {
18    const char *string;
19    unsigned long string_length;
20    unsigned *array;
21    unsigned next; &amp;bsol;* id of the next object for that level */
22  };
23  struct hwloc_synthetic_level_data_s {
24    unsigned arity;
25    unsigned long totalwidth;
26    struct hwloc_synthetic_attr_s attr;
27    struct hwloc_synthetic_indexes_s indexes;
28    struct hwloc_synthetic_attached_s {
29      struct hwloc_synthetic_attr_s attr;
30      struct hwloc_synthetic_attached_s *next;
31    } *attached;
32  };
33  struct hwloc_synthetic_backend_data_s {
34    char *string;
35    unsigned long numa_attached_nr;
36    struct hwloc_synthetic_indexes_s numa_attached_indexes;
37  #define HWLOC_SYNTHETIC_MAX_DEPTH 128
38    struct hwloc_synthetic_level_data_s level[HWLOC_SYNTHETIC_MAX_DEPTH];
39  };
40  struct hwloc_synthetic_intlv_loop_s {
41    unsigned step;
42    unsigned nb;
43    unsigned level_depth;
44  };
45  static void
46  hwloc_synthetic_process_indexes(struct hwloc_synthetic_backend_data_s *data,
47  				struct hwloc_synthetic_indexes_s *indexes,
48  				unsigned long total,
49  				int verbose)
50  {
51    const char *attr = indexes-&gt;string;
52    unsigned long length = indexes-&gt;string_length;
53    unsigned *array = NULL;
54    size_t i;
55    if (!attr)
56      return;
57    array = calloc(total, sizeof(*array));
58    if (!array) {
59      if (verbose)
60        fprintf(stderr, &quot;Failed to allocate synthetic index array of size %lu\n&quot;, total);
61      goto out;
62    }
63    i = strspn(attr, &quot;0123456789,&quot;);
64    if (i == length) {
65      for(i=0; i&lt;total; i++) {
66        const char *next;
67        unsigned idx = strtoul(attr, (char **) &amp;next, 10);
68        if (next == attr) {
69  	if (verbose)
70  	  fprintf(stderr, &quot;Failed to read synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
71  	goto out_with_array;
72        }
73        array[i] = idx;
74        if (i != total-1) {
75  	if (*next != &#x27;,&#x27;) {
76  	  if (verbose)
77  	    fprintf(stderr, &quot;Missing comma after synthetic index #%lu at &#x27;%s&#x27;\n&quot;, (unsigned long) i, attr);
78  	  goto out_with_array;
79  	}
80  	attr = next+1;
81        } else {
82  	attr = next;
83        }
84      }
85      indexes-&gt;array = array;
86    } else {
87      unsigned nr_loops = 1, cur_loop;
88      unsigned minstep = total;
89      unsigned long nbs = 1;
90      unsigned j, mul;
91      const char *tmp;
92      struct hwloc_synthetic_intlv_loop_s *loops;
93      tmp = attr;
94      while (tmp) {
95        tmp = strchr(tmp, &#x27;:&#x27;);
96        if (!tmp || tmp &gt;= attr+length)
97  	break;
98        nr_loops++;
99        tmp++;
100      }
101      loops = malloc((nr_loops+1) * sizeof(*loops));
102      if (!loops)
103        goto out_with_array;
104      if (*attr &gt;= &#x27;0&#x27; &amp;&amp; *attr &lt;= &#x27;9&#x27;) {
105        unsigned step, nb;
106        tmp = attr;
107        cur_loop = 0;
108        while (tmp) {
109  	char *tmp2, *tmp3;
110  	step = (unsigned) strtol(tmp, &amp;tmp2, 0);
111  	if (tmp2 == tmp || *tmp2 != &#x27;*&#x27;) {
112  	  if (verbose)
113  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number before &#x27;*&#x27;\n&quot;, tmp);
114  	  free(loops);
115  	  goto out_with_array;
116  	}
117  	if (!step) {
118  	  if (verbose)
119  	    fprintf(stderr, &quot;Invalid interleaving loop with step 0 at &#x27;%s&#x27;\n&quot;, tmp);
120  	  free(loops);
121  	  goto out_with_array;
122  	}
123  	tmp2++;
124  	nb = (unsigned) strtol(tmp2, &amp;tmp3, 0);
125  	if (tmp3 == tmp2 || (*tmp3 &amp;&amp; *tmp3 != &#x27;:&#x27; &amp;&amp; *tmp3 != &#x27;)&#x27; &amp;&amp; *tmp3 != &#x27; &#x27;)) {
126  	  if (verbose)
127  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop &#x27;%s&#x27; without number between &#x27;*&#x27; and &#x27;:&#x27;\n&quot;, tmp);
128  	  free(loops);
129  	  goto out_with_array;
130  	}
131  	if (!nb) {
132  	  if (verbose)
133  	    fprintf(stderr, &quot;Invalid interleaving loop with number 0 at &#x27;%s&#x27;\n&quot;, tmp2);
134  	  free(loops);
135  	  goto out_with_array;
136  	}
137  	loops[cur_loop].step = step;
138  	loops[cur_loop].nb = nb;
139  	if (step &lt; minstep)
140  	  minstep = step;
141  	nbs *= nb;
142  	cur_loop++;
143  	if (*tmp3 == &#x27;)&#x27; || *tmp3 == &#x27; &#x27;)
144  	  break;
145  	tmp = (const char*) (tmp3+1);
146        }
147      } else {
148        hwloc_obj_type_t type;
149        union hwloc_obj_attr_u attrs;
150        int err;
151        tmp = attr;
152        cur_loop = 0;
153        while (tmp) {
154  	err = hwloc_type_sscanf(tmp, &amp;type, &amp;attrs, sizeof(attrs));
155  	if (err &lt; 0) {
156  	  if (verbose)
157  	    fprintf(stderr, &quot;Failed to read synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
158  	  free(loops);
159  	  goto out_with_array;
160  	}
161  	if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
162  	  if (verbose)
163  	    fprintf(stderr, &quot;Misc object type disallowed in synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;, tmp);
164  	  free(loops);
165  	  goto out_with_array;
166  	}
167  	for(i=0; ; i++) {
168  	  if (!data-&gt;level[i].arity) {
169  	    loops[cur_loop].level_depth = (unsigned)-1;
170  	    break;
171  	  }
172  	  if (type != data-&gt;level[i].attr.type)
173  	    continue;
174  	  if (type == HWLOC_OBJ_GROUP
175  	      &amp;&amp; attrs.group.depth != (unsigned) -1
176  	      &amp;&amp; attrs.group.depth != data-&gt;level[i].attr.depth)
177  	    continue;
178  	  loops[cur_loop].level_depth = (unsigned)i;
179  	  break;
180  	}
181  	if (loops[cur_loop].level_depth == (unsigned)-1) {
182  	  if (verbose)
183  	    fprintf(stderr, &quot;Failed to find level for synthetic index interleaving loop type &#x27;%s&#x27;\n&quot;,
184  		    tmp);
185  	  free(loops);
186  	  goto out_with_array;
187  	}
188  	tmp = strchr(tmp, &#x27;:&#x27;);
189  	if (!tmp || tmp &gt; attr+length)
190  	  break;
191  	tmp++;
192  	cur_loop++;
193        }
194        for(cur_loop=0; cur_loop&lt;nr_loops; cur_loop++) {
195  	unsigned mydepth = loops[cur_loop].level_depth;
196  	unsigned prevdepth = 0;
197  	unsigned step, nb;
198  	for(i=0; i&lt;nr_loops; i++) {
199  	  if (loops[i].level_depth == mydepth &amp;&amp; i != cur_loop) {
200  	    if (verbose)
201  	      fprintf(stderr, &quot;Invalid duplicate interleaving loop type in synthetic index &#x27;%s&#x27;\n&quot;, attr);
202  	    free(loops);
203  	    goto out_with_array;
204  	  }
205  	  if (loops[i].level_depth &lt; mydepth
206  	      &amp;&amp; loops[i].level_depth &gt; prevdepth)
207  	    prevdepth = loops[i].level_depth;
208  	}
209  	step = total / data-&gt;level[mydepth].totalwidth; &amp;bsol;* number of objects below us */
210  	nb = data-&gt;level[mydepth].totalwidth / data-&gt;level[prevdepth].totalwidth; &amp;bsol;* number of us within parent */
<span onclick='openModal()' class='match'>211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
</span>214  	assert(step);
215  	if (step &lt; minstep)
216  	  minstep = step;
217  	nbs *= nb;
218        }
219      }
220      assert(nbs);
221      if (nbs != total) {
222        if (minstep == total/nbs) {
223  	loops[nr_loops].step = 1;
224  	loops[nr_loops].nb = total/nbs;
225  	nr_loops++;
226        } else {
227  	if (verbose)
228  	  fprintf(stderr, &quot;Invalid index interleaving total width %lu instead of %lu\n&quot;, nbs, total);
229  	free(loops);
230  	goto out_with_array;
231        }
232      }
233      mul = 1;
234      for(i=0; i&lt;nr_loops; i++) {
235        unsigned step = loops[i].step;
236        unsigned nb = loops[i].nb;
237        for(j=0; j&lt;total; j++)
238  	array[j] += ((j / step) % nb) * mul;
239        mul *= nb;
240      }
241      free(loops);
242      for(j=0; j&lt;total; j++) {
243        if (array[j] &gt;= total) {
244  	if (verbose)
245  	  fprintf(stderr, &quot;Invalid index interleaving generates out-of-range index %u\n&quot;, array[j]);
246  	goto out_with_array;
247        }
248        if (!array[j] &amp;&amp; j) {
249  	if (verbose)
250  	  fprintf(stderr, &quot;Invalid index interleaving generates duplicate index values\n&quot;);
251  	goto out_with_array;
252        }
253      }
254      indexes-&gt;array = array;
255    }
256    return;
257   out_with_array:
258    free(array);
259   out:
260    return;
261  }
262  static hwloc_uint64_t
263  hwloc_synthetic_parse_memory_attr(const char *attr, const char **endp)
264  {
265    const char *endptr;
266    hwloc_uint64_t size;
267    size = strtoull(attr, (char **) &amp;endptr, 0);
268    if (!hwloc_strncasecmp(endptr, &quot;TB&quot;, 2)) {
269      size *= 1000ULL*1000ULL*1000ULL*1000ULL;
270      endptr += 2;
271    } else if (!hwloc_strncasecmp(endptr, &quot;TiB&quot;, 3)) {
272      size &lt;&lt;= 40;
273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, &quot;GB&quot;, 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
276      endptr += 2;
277    } else if (!hwloc_strncasecmp(endptr, &quot;GiB&quot;, 3)) {
278      size &lt;&lt;= 30;
279      endptr += 3;
280    } else if (!hwloc_strncasecmp(endptr, &quot;MB&quot;, 2)) {
281      size *= 1000ULL*1000ULL;
282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, &quot;MiB&quot;, 3)) {
284      size &lt;&lt;= 20;
285      endptr += 3;
286    } else if (!hwloc_strncasecmp(endptr, &quot;kB&quot;, 2)) {
287      size *= 1000ULL;
288      endptr += 2;
289    } else if (!hwloc_strncasecmp(endptr, &quot;kiB&quot;, 3)) {
290      size &lt;&lt;= 10;
291      endptr += 3;
292    }
293    *endp = endptr;
294    return size;
295  }
296  static int
297  hwloc_synthetic_parse_attrs(const char *attrs, const char **next_posp,
298  			    struct hwloc_synthetic_attr_s *sattr,
299  			    struct hwloc_synthetic_indexes_s *sind,
300  			    int verbose)
301  {
302    hwloc_obj_type_t type = sattr-&gt;type;
303    const char *next_pos;
304    hwloc_uint64_t memorysize = 0;
305    const char *index_string = NULL;
306    size_t index_string_length = 0;
307    next_pos = (const char *) strchr(attrs, &#x27;)&#x27;);
308    if (!next_pos) {
309      if (verbose)
310        fprintf(stderr, &quot;Missing attribute closing bracket in synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, attrs);
311      errno = EINVAL;
312      return -1;
313    }
314    while (&#x27;)&#x27; != *attrs) {
315      int iscache = hwloc__obj_type_is_cache(type);
316      if (iscache &amp;&amp; !strncmp(&quot;size=&quot;, attrs, 5)) {
317        memorysize = hwloc_synthetic_parse_memory_attr(attrs+5, &amp;attrs);
318      } else if (!iscache &amp;&amp; !strncmp(&quot;memory=&quot;, attrs, 7)) {
319        memorysize = hwloc_synthetic_parse_memory_attr(attrs+7, &amp;attrs);
320      } else if (!strncmp(&quot;indexes=&quot;, attrs, 8)) {
321        index_string = attrs+8;
322        attrs += 8;
323        index_string_length = strcspn(attrs, &quot; )&quot;);
324        attrs += index_string_length;
325      } else {
326        if (verbose)
327  	fprintf(stderr, &quot;Unknown attribute at &#x27;%s&#x27;\n&quot;, attrs);
328        errno = EINVAL;
329        return -1;
330      }
331      if (&#x27; &#x27; == *attrs)
332        attrs++;
333      else if (&#x27;)&#x27; != *attrs) {
334        if (verbose)
335  	fprintf(stderr, &quot;Missing parameter separator at &#x27;%s&#x27;\n&quot;, attrs);
336        errno = EINVAL;
337        return -1;
338      }
339    }
340    sattr-&gt;memorysize = memorysize;
341    if (index_string) {
342      if (sind-&gt;string &amp;&amp; verbose)
343        fprintf(stderr, &quot;Overwriting duplicate indexes attribute with last occurence\n&quot;);
344      sind-&gt;string = index_string;
345      sind-&gt;string_length = (unsigned long)index_string_length;
346    }
347    *next_posp = next_pos+1;
348    return 0;
349  }
350  static void
351  hwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)
352  {
353    unsigned i;
354    for(i=0; i&lt;HWLOC_SYNTHETIC_MAX_DEPTH; i++) {
355      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
356      struct hwloc_synthetic_attached_s **pprev = &amp;curlevel-&gt;attached;
357      while (*pprev) {
358        struct hwloc_synthetic_attached_s *cur = *pprev;
359        *pprev = cur-&gt;next;
360        free(cur);
361      }
362      free(curlevel-&gt;indexes.array);
363      if (!curlevel-&gt;arity)
364        break;
365    }
366    free(data-&gt;numa_attached_indexes.array);
367  }
368  static int
369  hwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,
370  			     const char *description)
371  {
372    const char *pos, *next_pos;
373    unsigned long item, count;
374    unsigned i;
375    int type_count[HWLOC_OBJ_TYPE_MAX];
376    unsigned unset;
377    int verbose = 0;
378    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
379    int err;
380    unsigned long totalarity = 1;
381    if (env)
382      verbose = atoi(env);
383    data-&gt;numa_attached_nr = 0;
384    data-&gt;numa_attached_indexes.array = NULL;
385    data-&gt;level[0].totalwidth = 1;
386    data-&gt;level[0].attr.type = HWLOC_OBJ_MACHINE;
387    data-&gt;level[0].indexes.string = NULL;
388    data-&gt;level[0].indexes.array = NULL;
389    data-&gt;level[0].attr.memorysize = 0;
390    data-&gt;level[0].attached = NULL;
391    type_count[HWLOC_OBJ_MACHINE] = 1;
392    if (*description == &#x27;(&#x27;) {
393      err = hwloc_synthetic_parse_attrs(description+1, &amp;description, &amp;data-&gt;level[0].attr, &amp;data-&gt;level[0].indexes, verbose);
394      if (err &lt; 0)
395        return err;
396    }
397    data-&gt;numa_attached_indexes.string = NULL;
398    data-&gt;numa_attached_indexes.array = NULL;
399    for (pos = description, count = 1; *pos; pos = next_pos) {
400      hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;
401      union hwloc_obj_attr_u attrs;
402      data-&gt;level[count-1].arity = 0;
403      while (*pos == &#x27; &#x27; || *pos == &#x27;\n&#x27;)
404        pos++;
405      if (!*pos)
406        break;
407      if (*pos == &#x27;[&#x27;) {
408        struct hwloc_synthetic_attached_s *attached, **pprev;
409        char *attr;
410        pos++;
411        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
412  	if (verbose)
413  	  fprintf(stderr, &quot;Synthetic string with unknown attached object type at &#x27;%s&#x27;\n&quot;, pos);
414  	errno = EINVAL;
415  	goto error;
416        }
417        if (type != HWLOC_OBJ_NUMANODE) {
418  	if (verbose)
419  	  fprintf(stderr, &quot;Synthetic string with disallowed attached object type at &#x27;%s&#x27;\n&quot;, pos);
420  	errno = EINVAL;
421  	goto error;
422        }
423        data-&gt;numa_attached_nr += data-&gt;level[count-1].totalwidth;
424        attached = malloc(sizeof(*attached));
425        if (attached) {
426  	attached-&gt;attr.type = type;
427  	attached-&gt;attr.memorysize = 0;
428  	attached-&gt;next = NULL;
429  	pprev = &amp;data-&gt;level[count-1].attached;
430  	while (*pprev)
431  	  pprev = &amp;((*pprev)-&gt;next);
432  	*pprev = attached;
433        }
434        next_pos = strchr(pos, &#x27;]&#x27;);
435        if (!next_pos) {
436  	if (verbose)
437  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a closing `]&#x27; after attached object type at &#x27;%s&#x27;\n&quot;, pos);
438  	errno = EINVAL;
439  	goto error;
440        }
441        attr = strchr(pos, &#x27;(&#x27;);
442        if (attr &amp;&amp; attr &lt; next_pos &amp;&amp; attached) {
443  	const char *dummy;
444  	err = hwloc_synthetic_parse_attrs(attr+1, &amp;dummy, &amp;attached-&gt;attr, &amp;data-&gt;numa_attached_indexes, verbose);
445  	if (err &lt; 0)
446  	  goto error;
447        }
448        next_pos++;
449        continue;
450      }
451      data-&gt;level[count].indexes.string = NULL;
452      data-&gt;level[count].indexes.array = NULL;
453      data-&gt;level[count].attached = NULL;
454      if (*pos &lt; &#x27;0&#x27; || *pos &gt; &#x27;9&#x27;) {
455        if (hwloc_type_sscanf(pos, &amp;type, &amp;attrs, sizeof(attrs)) &lt; 0) {
456  	if (!strncmp(pos, &quot;Tile&quot;, 4) || !strncmp(pos, &quot;Module&quot;, 6)) {
457  	  type = HWLOC_OBJ_GROUP;
458  	} else {
459  	  if (verbose)
460  	    fprintf(stderr, &quot;Synthetic string with unknown object type at &#x27;%s&#x27;\n&quot;, pos);
461  	  errno = EINVAL;
462  	  goto error;
463  	}
464        }
465        if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
466  	if (verbose)
467  	  fprintf(stderr, &quot;Synthetic string with disallowed object type at &#x27;%s&#x27;\n&quot;, pos);
468  	errno = EINVAL;
469  	goto error;
470        }
471        next_pos = strchr(pos, &#x27;:&#x27;);
472        if (!next_pos) {
473  	if (verbose)
474  	  fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a `:&#x27; after object type at &#x27;%s&#x27;\n&quot;, pos);
475  	errno = EINVAL;
476  	goto error;
477        }
478        pos = next_pos + 1;
479      }
480      data-&gt;level[count].attr.type = type;
481      data-&gt;level[count].attr.depth = (unsigned) -1;
482      data-&gt;level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;
483      if (hwloc__obj_type_is_cache(type)) {
484        data-&gt;level[count].attr.depth = attrs.cache.depth;
485        data-&gt;level[count].attr.cachetype = attrs.cache.type;
486      } else if (type == HWLOC_OBJ_GROUP) {
487        data-&gt;level[count].attr.depth = attrs.group.depth;
488      }
489      item = strtoul(pos, (char **)&amp;next_pos, 0);
490      if (next_pos == pos) {
491        if (verbose)
492  	fprintf(stderr,&quot;Synthetic string doesn&#x27;t have a number of objects at &#x27;%s&#x27;\n&quot;, pos);
493        errno = EINVAL;
494        goto error;
495      }
496      if (!item) {
497        if (verbose)
498  	fprintf(stderr,&quot;Synthetic string with disallow 0 number of objects at &#x27;%s&#x27;\n&quot;, pos);
499        errno = EINVAL;
500        goto error;
501      }
502      totalarity *= item;
503      data-&gt;level[count].totalwidth = totalarity;
504      data-&gt;level[count].indexes.string = NULL;
505      data-&gt;level[count].indexes.array = NULL;
506      data-&gt;level[count].attr.memorysize = 0;
507      if (*next_pos == &#x27;(&#x27;) {
508        err = hwloc_synthetic_parse_attrs(next_pos+1, &amp;next_pos, &amp;data-&gt;level[count].attr, &amp;data-&gt;level[count].indexes, verbose);
509        if (err &lt; 0)
510  	goto error;
511      }
512      if (count + 1 &gt;= HWLOC_SYNTHETIC_MAX_DEPTH) {
513        if (verbose)
514  	fprintf(stderr,&quot;Too many synthetic levels, max %d\n&quot;, HWLOC_SYNTHETIC_MAX_DEPTH);
515        errno = EINVAL;
516        goto error;
517      }
518      if (item &gt; UINT_MAX) {
519        if (verbose)
520  	fprintf(stderr,&quot;Too big arity, max %u\n&quot;, UINT_MAX);
521        errno = EINVAL;
522        goto error;
523      }
524      data-&gt;level[count-1].arity = (unsigned)item;
525      count++;
526    }
527    if (data-&gt;level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE &amp;&amp; data-&gt;level[count-1].attr.type != HWLOC_OBJ_PU) {
528      if (verbose)
529        fprintf(stderr, &quot;Synthetic string cannot use non-PU type for last level\n&quot;);
530      errno = EINVAL;
531      return -1;
532    }
533    data-&gt;level[count-1].attr.type = HWLOC_OBJ_PU;
534    for(i=HWLOC_OBJ_TYPE_MIN; i&lt;HWLOC_OBJ_TYPE_MAX; i++) {
535      type_count[i] = 0;
536    }
537    for(i=count-1; i&gt;0; i--) {
538      hwloc_obj_type_t type = data-&gt;level[i].attr.type;
539      if (type != HWLOC_OBJ_TYPE_NONE) {
540        type_count[type]++;
541      }
542    }
543    if (!type_count[HWLOC_OBJ_PU]) {
544      if (verbose)
545        fprintf(stderr, &quot;Synthetic string missing ending number of PUs\n&quot;);
546      errno = EINVAL;
547      return -1;
548    } else if (type_count[HWLOC_OBJ_PU] &gt; 1) {
549      if (verbose)
550        fprintf(stderr, &quot;Synthetic string cannot have several PU levels\n&quot;);
551      errno = EINVAL;
552      return -1;
553    }
554    if (type_count[HWLOC_OBJ_PACKAGE] &gt; 1) {
555      if (verbose)
556        fprintf(stderr, &quot;Synthetic string cannot have several package levels\n&quot;);
557      errno = EINVAL;
558      return -1;
559    }
560    if (type_count[HWLOC_OBJ_DIE] &gt; 1) {
561      if (verbose)
562        fprintf(stderr, &quot;Synthetic string cannot have several die levels\n&quot;);
563      errno = EINVAL;
564      return -1;
565    }
566    if (type_count[HWLOC_OBJ_NUMANODE] &gt; 1) {
567      if (verbose)
568        fprintf(stderr, &quot;Synthetic string cannot have several NUMA node levels\n&quot;);
569      errno = EINVAL;
570      return -1;
571    }
572    if (type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; data-&gt;numa_attached_nr) {
573      if (verbose)
574        fprintf(stderr,&quot;Synthetic string cannot have NUMA nodes both as a level and attached\n&quot;);
575      errno = EINVAL;
576      return -1;
577    }
578    if (type_count[HWLOC_OBJ_CORE] &gt; 1) {
579      if (verbose)
580        fprintf(stderr, &quot;Synthetic string cannot have several core levels\n&quot;);
581      errno = EINVAL;
582      return -1;
583    }
584    unset = 0;
585    for(i=1; i&lt;count-1; i++) {
586      if (data-&gt;level[i].attr.type == HWLOC_OBJ_TYPE_NONE)
587        unset++;
588    }
589    if (unset &amp;&amp; unset != count-2) {
590      if (verbose)
591        fprintf(stderr, &quot;Synthetic string cannot mix unspecified and specified types for levels\n&quot;);
592      errno = EINVAL;
593      return -1;
594    }
595    if (unset) {
596      unsigned _count = count;
597      unsigned neednuma = 0;
598      unsigned needpack = 0;
599      unsigned needcore = 0;
600      unsigned needcaches = 0;
601      unsigned needgroups = 0;
602      _count -= 2;
603      neednuma = (_count &gt;= 1 &amp;&amp; !data-&gt;numa_attached_nr);
604      _count -= neednuma;
605      needpack = (_count &gt;= 1);
606      _count -= needpack;
607      needcore = (_count &gt;= 1);
608      _count -= needcore;
609      needcaches = (_count &gt; 4 ? 4 : _count);
610      _count -= needcaches;
611      needgroups = _count;
612      for(i = 0; i &lt; needgroups; i++) {
613        unsigned depth = 1 + i;
614        data-&gt;level[depth].attr.type = HWLOC_OBJ_GROUP;
615        type_count[HWLOC_OBJ_GROUP]++;
616      }
617      if (needpack) {
618        unsigned depth = 1 + needgroups;
619        data-&gt;level[depth].attr.type = HWLOC_OBJ_PACKAGE;
620        type_count[HWLOC_OBJ_PACKAGE] = 1;
621      }
622      if (neednuma) {
623        unsigned depth = 1 + needgroups + needpack;
624        data-&gt;level[depth].attr.type = HWLOC_OBJ_NUMANODE;
625        type_count[HWLOC_OBJ_NUMANODE] = 1;
626      }
627      if (needcaches) {
628        unsigned l3depth = 1 + needgroups + needpack + neednuma;
629        unsigned l2depth = l3depth + (needcaches &gt;= 3);
630        unsigned l1depth = l2depth + 1;
631        unsigned l1idepth = l1depth + 1;
632        if (needcaches &gt;= 3) {
633  	data-&gt;level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;
634  	data-&gt;level[l3depth].attr.depth = 3;
635  	data-&gt;level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
636  	type_count[HWLOC_OBJ_L3CACHE] = 1;
637        }
638        data-&gt;level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;
639        data-&gt;level[l2depth].attr.depth = 2;
640        data-&gt;level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
641        type_count[HWLOC_OBJ_L2CACHE] = 1;
642        if (needcaches &gt;= 2) {
643  	data-&gt;level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;
644  	data-&gt;level[l1depth].attr.depth = 1;
645  	data-&gt;level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;
646  	type_count[HWLOC_OBJ_L1CACHE] = 1;
647        }
648        if (needcaches &gt;= 4) {
649  	data-&gt;level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;
650  	data-&gt;level[l1idepth].attr.depth = 1;
651  	data-&gt;level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;
652  	type_count[HWLOC_OBJ_L1ICACHE] = 1;
653        }
654      }
655      if (needcore) {
656        unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;
657        data-&gt;level[depth].attr.type = HWLOC_OBJ_CORE;
658        type_count[HWLOC_OBJ_CORE] = 1;
659      }
660    }
661    if (!type_count[HWLOC_OBJ_NUMANODE] &amp;&amp; !data-&gt;numa_attached_nr) {
662      if (verbose)
663        fprintf(stderr, &quot;Inserting a NUMA level with a single object at depth 1\n&quot;);
664      memmove(&amp;data-&gt;level[2], &amp;data-&gt;level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
665      data-&gt;level[1].attr.type = HWLOC_OBJ_NUMANODE;
666      data-&gt;level[1].indexes.string = NULL;
667      data-&gt;level[1].indexes.array = NULL;
668      data-&gt;level[1].attr.memorysize = 0;
669      data-&gt;level[1].totalwidth = data-&gt;level[0].totalwidth;
670      data-&gt;level[1].arity = data-&gt;level[0].arity;
671      data-&gt;level[0].arity = 1;
672      count++;
673    }
674    for (i=0; i&lt;count; i++) {
675      struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[i];
676      hwloc_obj_type_t type = curlevel-&gt;attr.type;
677      if (type == HWLOC_OBJ_GROUP) {
678        if (curlevel-&gt;attr.depth == (unsigned)-1)
679  	curlevel-&gt;attr.depth = type_count[HWLOC_OBJ_GROUP]--;
680      } else if (hwloc__obj_type_is_cache(type)) {
681        if (!curlevel-&gt;attr.memorysize) {
682  	if (1 == curlevel-&gt;attr.depth)
683  	  curlevel-&gt;attr.memorysize = 32*1024;
684  	else
685  	  curlevel-&gt;attr.memorysize = 256ULL*1024 &lt;&lt; (2*curlevel-&gt;attr.depth);
686        }
687      } else if (type == HWLOC_OBJ_NUMANODE &amp;&amp; !curlevel-&gt;attr.memorysize) {
688        curlevel-&gt;attr.memorysize = 1024*1024*1024;
689      }
690      hwloc_synthetic_process_indexes(data, &amp;data-&gt;level[i].indexes, data-&gt;level[i].totalwidth, verbose);
691    }
692    hwloc_synthetic_process_indexes(data, &amp;data-&gt;numa_attached_indexes, data-&gt;numa_attached_nr, verbose);
693    data-&gt;string = strdup(description);
694    data-&gt;level[count-1].arity = 0;
695    return 0;
696   error:
697    hwloc_synthetic_free_levels(data);
698    return -1;
699  }
700  static void
701  hwloc_synthetic_set_attr(struct hwloc_synthetic_attr_s *sattr,
702  			 hwloc_obj_t obj)
703  {
704    switch (obj-&gt;type) {
705    case HWLOC_OBJ_GROUP:
706      obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_SYNTHETIC;
707      obj-&gt;attr-&gt;group.subkind = sattr-&gt;depth-1;
708      break;
709    case HWLOC_OBJ_MACHINE:
710      break;
711    case HWLOC_OBJ_NUMANODE:
712      obj-&gt;attr-&gt;numanode.local_memory = sattr-&gt;memorysize;
713      obj-&gt;attr-&gt;numanode.page_types_len = 1;
714      obj-&gt;attr-&gt;numanode.page_types = malloc(sizeof(*obj-&gt;attr-&gt;numanode.page_types));
715      memset(obj-&gt;attr-&gt;numanode.page_types, 0, sizeof(*obj-&gt;attr-&gt;numanode.page_types));
716      obj-&gt;attr-&gt;numanode.page_types[0].size = 4096;
717      obj-&gt;attr-&gt;numanode.page_types[0].count = sattr-&gt;memorysize / 4096;
718      break;
719    case HWLOC_OBJ_PACKAGE:
720    case HWLOC_OBJ_DIE:
721      break;
722    case HWLOC_OBJ_L1CACHE:
723    case HWLOC_OBJ_L2CACHE:
724    case HWLOC_OBJ_L3CACHE:
725    case HWLOC_OBJ_L4CACHE:
726    case HWLOC_OBJ_L5CACHE:
727    case HWLOC_OBJ_L1ICACHE:
728    case HWLOC_OBJ_L2ICACHE:
729    case HWLOC_OBJ_L3ICACHE:
730      obj-&gt;attr-&gt;cache.depth = sattr-&gt;depth;
731      obj-&gt;attr-&gt;cache.linesize = 64;
732      obj-&gt;attr-&gt;cache.type = sattr-&gt;cachetype;
733      obj-&gt;attr-&gt;cache.size = sattr-&gt;memorysize;
734      break;
735    case HWLOC_OBJ_CORE:
736      break;
737    case HWLOC_OBJ_PU:
738      break;
739    default:
740      assert(0);
741      break;
742    }
743  }
744  static unsigned
745  hwloc_synthetic_next_index(struct hwloc_synthetic_indexes_s *indexes, hwloc_obj_type_t type)
746  {
747    unsigned os_index = indexes-&gt;next++;
748    if (indexes-&gt;array)
749      os_index = indexes-&gt;array[os_index];
750    else if (hwloc__obj_type_is_cache(type) || type == HWLOC_OBJ_GROUP)
751      os_index = HWLOC_UNKNOWN_INDEX;
752    return os_index;
753  }
754  static void
755  hwloc_synthetic_insert_attached(struct hwloc_topology *topology,
756  				struct hwloc_synthetic_backend_data_s *data,
757  				struct hwloc_synthetic_attached_s *attached,
758  				hwloc_bitmap_t set)
759  {
760    hwloc_obj_t child;
761    unsigned attached_os_index;
762    if (!attached)
763      return;
764    assert(attached-&gt;attr.type == HWLOC_OBJ_NUMANODE);
765    attached_os_index = hwloc_synthetic_next_index(&amp;data-&gt;numa_attached_indexes, HWLOC_OBJ_NUMANODE);
766    child = hwloc_alloc_setup_object(topology, attached-&gt;attr.type, attached_os_index);
767    child-&gt;cpuset = hwloc_bitmap_dup(set);
768    child-&gt;nodeset = hwloc_bitmap_alloc();
769    hwloc_bitmap_set(child-&gt;nodeset, attached_os_index);
770    hwloc_synthetic_set_attr(&amp;attached-&gt;attr, child);
771    hwloc__insert_object_by_cpuset(topology, NULL, child, &quot;synthetic:attached&quot;);
772    hwloc_synthetic_insert_attached(topology, data, attached-&gt;next, set);
773  }
774  static void
775  hwloc__look_synthetic(struct hwloc_topology *topology,
776  		      struct hwloc_synthetic_backend_data_s *data,
777  		      int level,
778  		      hwloc_bitmap_t parent_cpuset)
779  {
780    hwloc_obj_t obj;
781    unsigned i;
782    struct hwloc_synthetic_level_data_s *curlevel = &amp;data-&gt;level[level];
783    hwloc_obj_type_t type = curlevel-&gt;attr.type;
784    hwloc_bitmap_t set;
785    unsigned os_index;
786    assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
787    assert(type != HWLOC_OBJ_MACHINE);
788    os_index = hwloc_synthetic_next_index(&amp;curlevel-&gt;indexes, type);
789    set = hwloc_bitmap_alloc();
790    if (!curlevel-&gt;arity) {
791      hwloc_bitmap_set(set, os_index);
792    } else {
793      for (i = 0; i &lt; curlevel-&gt;arity; i++)
794        hwloc__look_synthetic(topology, data, level + 1, set);
795    }
796    hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);
797    if (hwloc_filter_check_keep_object_type(topology, type)) {
798      obj = hwloc_alloc_setup_object(topology, type, os_index);
799      obj-&gt;cpuset = hwloc_bitmap_dup(set);
800      if (type == HWLOC_OBJ_NUMANODE) {
801        obj-&gt;nodeset = hwloc_bitmap_alloc();
802        hwloc_bitmap_set(obj-&gt;nodeset, os_index);
803      }
804      hwloc_synthetic_set_attr(&amp;curlevel-&gt;attr, obj);
805      hwloc__insert_object_by_cpuset(topology, NULL, obj, &quot;synthetic&quot;);
806    }
807    hwloc_synthetic_insert_attached(topology, data, curlevel-&gt;attached, set);
808    hwloc_bitmap_free(set);
809  }
810  static int
811  hwloc_look_synthetic(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
812  {
813    struct hwloc_topology *topology = backend-&gt;topology;
814    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
815    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
816    unsigned i;
817    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_GLOBAL);
818    assert(!topology-&gt;levels[0][0]-&gt;cpuset);
819    hwloc_alloc_root_sets(topology-&gt;levels[0][0]);
820    topology-&gt;support.discovery-&gt;pu = 1;
821    topology-&gt;support.discovery-&gt;numa = 1; &amp;bsol;* we add a single NUMA node if none is given */
822    topology-&gt;support.discovery-&gt;numa_memory = 1; &amp;bsol;* specified or default size */
823    for (i = 0; data-&gt;level[i].arity &gt; 0; i++)
824      data-&gt;level[i].indexes.next = 0;
825    data-&gt;numa_attached_indexes.next = 0;
826    data-&gt;level[i].indexes.next = 0;
827    topology-&gt;levels[0][0]-&gt;type = data-&gt;level[0].attr.type;
828    hwloc_synthetic_set_attr(&amp;data-&gt;level[0].attr, topology-&gt;levels[0][0]);
829    for (i = 0; i &lt; data-&gt;level[0].arity; i++)
830      hwloc__look_synthetic(topology, data, 1, cpuset);
831    hwloc_synthetic_insert_attached(topology, data, data-&gt;level[0].attached, cpuset);
832    hwloc_bitmap_free(cpuset);
833    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Backend&quot;, &quot;Synthetic&quot;);
834    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;SyntheticDescription&quot;, data-&gt;string);
835    return 0;
836  }
837  static void
838  hwloc_synthetic_backend_disable(struct hwloc_backend *backend)
839  {
840    struct hwloc_synthetic_backend_data_s *data = backend-&gt;private_data;
841    hwloc_synthetic_free_levels(data);
842    free(data-&gt;string);
843    free(data);
844  }
845  static struct hwloc_backend *
846  hwloc_synthetic_component_instantiate(struct hwloc_topology *topology,
847  				      struct hwloc_disc_component *component,
848  				      unsigned excluded_phases __hwloc_attribute_unused,
849  				      const void *_data1,
850  				      const void *_data2 __hwloc_attribute_unused,
851  				      const void *_data3 __hwloc_attribute_unused)
852  {
853    struct hwloc_backend *backend;
854    struct hwloc_synthetic_backend_data_s *data;
855    int err;
856    if (!_data1) {
857      const char *env = getenv(&quot;HWLOC_SYNTHETIC&quot;);
858      if (env) {
859        _data1 = env;
860      } else {
861        errno = EINVAL;
862        goto out;
863      }
864    }
865    backend = hwloc_backend_alloc(topology, component);
866    if (!backend)
867      goto out;
868    data = malloc(sizeof(*data));
869    if (!data) {
870      errno = ENOMEM;
871      goto out_with_backend;
872    }
873    err = hwloc_backend_synthetic_init(data, (const char *) _data1);
874    if (err &lt; 0)
875      goto out_with_data;
876    backend-&gt;private_data = data;
877    backend-&gt;discover = hwloc_look_synthetic;
878    backend-&gt;disable = hwloc_synthetic_backend_disable;
879    backend-&gt;is_thissystem = 0;
880    return backend;
881   out_with_data:
882    free(data);
883   out_with_backend:
884    free(backend);
885   out:
886    return NULL;
887  }
888  static struct hwloc_disc_component hwloc_synthetic_disc_component = {
889    &quot;synthetic&quot;,
890    HWLOC_DISC_PHASE_GLOBAL,
891    ~0,
892    hwloc_synthetic_component_instantiate,
893    30,
894    1,
895    NULL
896  };
897  const struct hwloc_component hwloc_synthetic_component = {
898    HWLOC_COMPONENT_ABI,
899    NULL, NULL,
900    HWLOC_COMPONENT_TYPE_DISC,
901    0,
902    &amp;hwloc_synthetic_disc_component
903  };
904  static __hwloc_inline int
905  hwloc__export_synthetic_update_status(int *ret, char **tmp, ssize_t *tmplen, int res)
906  {
907    if (res &lt; 0)
908      return -1;
909    *ret += res;
910    if (res &gt;= *tmplen)
911      res = *tmplen&gt;0 ? (int)(*tmplen) - 1 : 0;
912    *tmp += res;
913    *tmplen -= res;
914    return 0;
915  }
916  static __hwloc_inline void
917  hwloc__export_synthetic_add_char(int *ret, char **tmp, ssize_t *tmplen, char c)
918  {
919    if (*tmplen &gt; 1) {
920      (*tmp)[0] = c;
921      (*tmp)[1] = &#x27;\0&#x27;;
922      (*tmp)++;
923      (*tmplen)--;
924    }
925    (*ret)++;
926  }
927  static int
928  hwloc__export_synthetic_indexes(hwloc_obj_t *level, unsigned total,
929  				char *buffer, size_t buflen)
930  {
931    unsigned step = 1;
932    unsigned nr_loops = 0;
933    struct hwloc_synthetic_intlv_loop_s *loops = NULL, *tmploops;
934    hwloc_obj_t cur;
935    unsigned i, j;
936    ssize_t tmplen = buflen;
937    char *tmp = buffer;
938    int res, ret = 0;
939    if (level[0]-&gt;os_index)
940      goto exportall;
941    while (step != total) {
942      if (total % step)
943        goto exportall;
944      for(i=1; i&lt;total; i++)
945        if (level[i]-&gt;os_index == step)
946  	break;
947      if (i == total)
948        goto exportall;
949      for(j=2; j&lt;total/i; j++)
950        if (level[i*j]-&gt;os_index != step*j)
951  	break;
952      nr_loops++;
953      tmploops = realloc(loops, nr_loops*sizeof(*loops));
954      if (!tmploops)
955        goto exportall;
956      loops = tmploops;
957      loops[nr_loops-1].step = i;
958      loops[nr_loops-1].nb = j;
959      step *= j;
960    }
961    for(i=0; i&lt;total; i++) {
962      unsigned ind = 0;
963      unsigned mul = 1;
964      for(j=0; j&lt;nr_loops; j++) {
965        ind += (i / loops[j].step) % loops[j].nb * mul;
966        mul *= loops[j].nb;
967      }
968      if (level[i]-&gt;os_index != ind)
969        goto exportall;
970    }
971    for(j=0; j&lt;nr_loops; j++) {
972      res = hwloc_snprintf(tmp, tmplen, &quot;%u*%u%s&quot;, loops[j].step, loops[j].nb,
973  			 j == nr_loops-1 ? &quot;)&quot; : &quot;:&quot;);
974      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0) {
975        free(loops);
976        return -1;
977      }
978    }
979    free(loops);
980    return ret;
981   exportall:
982    free(loops);
983    cur = level[0];
984    while (cur) {
985      res = hwloc_snprintf(tmp, tmplen, &quot;%u%s&quot;, cur-&gt;os_index,
986  			 cur-&gt;next_cousin ? &quot;,&quot; : &quot;)&quot;);
987      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
988        return -1;
989      cur = cur-&gt;next_cousin;
990    }
991    return ret;
992  }
993  static int
994  hwloc__export_synthetic_obj_attr(struct hwloc_topology * topology,
995  				 hwloc_obj_t obj,
996  				 char *buffer, size_t buflen)
997  {
998    const char * separator = &quot; &quot;;
999    const char * prefix = &quot;(&quot;;
1000    char cachesize[64] = &quot;&quot;;
1001    char memsize[64] = &quot;&quot;;
1002    int needindexes = 0;
1003    if (hwloc__obj_type_is_cache(obj-&gt;type) &amp;&amp; obj-&gt;attr-&gt;cache.size) {
1004      snprintf(cachesize, sizeof(cachesize), &quot;%ssize=%llu&quot;,
1005  	     prefix, (unsigned long long) obj-&gt;attr-&gt;cache.size);
1006      prefix = separator;
1007    }
1008    if (obj-&gt;type == HWLOC_OBJ_NUMANODE &amp;&amp; obj-&gt;attr-&gt;numanode.local_memory) {
1009      snprintf(memsize, sizeof(memsize), &quot;%smemory=%llu&quot;,
1010  	     prefix, (unsigned long long) obj-&gt;attr-&gt;numanode.local_memory);
1011      prefix = separator;
1012    }
1013    if (!obj-&gt;logical_index &amp;bsol;* only display indexes once per level (not for non-first NUMA children, etc.) */
1014        &amp;&amp; (obj-&gt;type == HWLOC_OBJ_PU || obj-&gt;type == HWLOC_OBJ_NUMANODE)) {
1015      hwloc_obj_t cur = obj;
1016      while (cur) {
1017        if (cur-&gt;os_index != cur-&gt;logical_index) {
1018  	needindexes = 1;
1019  	break;
1020        }
1021        cur = cur-&gt;next_cousin;
1022      }
1023    }
1024    if (*cachesize || *memsize || needindexes) {
1025      ssize_t tmplen = buflen;
1026      char *tmp = buffer;
1027      int res, ret = 0;
1028      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s%s&quot;, cachesize, memsize, needindexes ? &quot;&quot; : &quot;)&quot;);
1029      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1030        return -1;
1031      if (needindexes) {
1032        unsigned total;
1033        hwloc_obj_t *level;
1034        if (obj-&gt;depth &lt; 0) {
1035  	assert(obj-&gt;depth == HWLOC_TYPE_DEPTH_NUMANODE);
1036  	total = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
1037  	level = topology-&gt;slevels[HWLOC_SLEVEL_NUMANODE].objs;
1038        } else {
1039  	total = topology-&gt;level_nbobjects[obj-&gt;depth];
1040  	level = topology-&gt;levels[obj-&gt;depth];
1041        }
1042        res = hwloc_snprintf(tmp, tmplen, &quot;%sindexes=&quot;, prefix);
1043        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1044  	return -1;
1045        res = hwloc__export_synthetic_indexes(level, total, tmp, tmplen);
1046        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1047  	return -1;
1048      }
1049      return ret;
1050    } else {
1051      return 0;
1052    }
1053  }
1054  static int
1055  hwloc__export_synthetic_obj(struct hwloc_topology * topology, unsigned long flags,
1056  			    hwloc_obj_t obj, unsigned arity,
1057  			    char *buffer, size_t buflen)
1058  {
1059    char aritys[12] = &quot;&quot;;
1060    ssize_t tmplen = buflen;
1061    char *tmp = buffer;
1062    int res, ret = 0;
1063    if (arity != (unsigned)-1)
1064      snprintf(aritys, sizeof(aritys), &quot;:%u&quot;, arity);
1065    if (hwloc__obj_type_is_cache(obj-&gt;type)
1066        &amp;&amp; (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES)) {
1067      res = hwloc_snprintf(tmp, tmplen, &quot;Cache%s&quot;, aritys);
1068    } else if (obj-&gt;type == HWLOC_OBJ_PACKAGE
1069  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1070  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1071      res = hwloc_snprintf(tmp, tmplen, &quot;Socket%s&quot;, aritys);
1072    } else if (obj-&gt;type == HWLOC_OBJ_DIE
1073  	     &amp;&amp; (flags &amp; (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1074  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1075      res = hwloc_snprintf(tmp, tmplen, &quot;Group%s&quot;, aritys);
1076    } else if (obj-&gt;type == HWLOC_OBJ_GROUP &amp;bsol;* don&#x27;t export group depth */
1077        || flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES) {
1078      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, hwloc_obj_type_string(obj-&gt;type), aritys);
1079    } else {
1080      char types[64];
1081      hwloc_obj_type_snprintf(types, sizeof(types), obj, 1);
1082      res = hwloc_snprintf(tmp, tmplen, &quot;%s%s&quot;, types, aritys);
1083    }
1084    if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1085      return -1;
1086    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1087      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1088      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1089        return -1;
1090    }
1091    return ret;
1092  }
1093  static int
1094  hwloc__export_synthetic_memory_children(struct hwloc_topology * topology, unsigned long flags,
1095  					hwloc_obj_t parent,
1096  					char *buffer, size_t buflen,
1097  					int needprefix, int verbose)
1098  {
1099    hwloc_obj_t mchild;
1100    ssize_t tmplen = buflen;
1101    char *tmp = buffer;
1102    int res, ret = 0;
1103    mchild = parent-&gt;memory_first_child;
1104    if (!mchild)
1105      return 0;
1106    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1107      if (parent-&gt;memory_arity &gt; 1 || mchild-&gt;type != HWLOC_OBJ_NUMANODE) {
1108        if (verbose)
1109  	fprintf(stderr, &quot;Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n&quot;);
1110        errno = EINVAL;
1111        return -1;
1112      }
1113      if (needprefix)
1114        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1115      res = hwloc__export_synthetic_obj(topology, flags, mchild, 1, tmp, tmplen);
1116      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1117        return -1;
1118      return ret;
1119    }
1120    while (mchild) {
1121      hwloc_obj_t numanode = mchild;
1122      while (numanode &amp;&amp; numanode-&gt;type != HWLOC_OBJ_NUMANODE) {
1123        assert(numanode-&gt;arity == 1);
1124        numanode = numanode-&gt;memory_first_child;
1125      }
1126      assert(numanode); &amp;bsol;* there&#x27;s always a numanode at the bottom of the memory tree */
1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1129      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;[&#x27;);
1130      res = hwloc__export_synthetic_obj(topology, flags, numanode, (unsigned)-1, tmp, tmplen);
1131      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1132        return -1;
1133      hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27;]&#x27;);
1134      needprefix = 1;
1135      mchild = mchild-&gt;next_sibling;
1136    }
1137    return ret;
1138  }
1139  static int
1140  hwloc_check_memory_symmetric(struct hwloc_topology * topology)
1141  {
1142    hwloc_bitmap_t remaining_nodes;
1143    remaining_nodes = hwloc_bitmap_dup(hwloc_get_root_obj(topology)-&gt;nodeset);
1144    if (!remaining_nodes)
1145      return -1;
1146    while (!hwloc_bitmap_iszero(remaining_nodes)) {
1147      unsigned idx;
1148      hwloc_obj_t node;
1149      hwloc_obj_t first_parent;
1150      unsigned i;
1151      idx = hwloc_bitmap_first(remaining_nodes);
1152      node = hwloc_get_numanode_obj_by_os_index(topology, idx);
1153      assert(node);
1154      first_parent = node-&gt;parent;
1155      for(i=0; i&lt;hwloc_get_nbobjs_by_depth(topology, first_parent-&gt;depth); i++) {
1156        hwloc_obj_t parent, mchild;
1157        parent = hwloc_get_obj_by_depth(topology, first_parent-&gt;depth, i);
1158        assert(parent);
1159        if (parent-&gt;memory_arity != first_parent-&gt;memory_arity)
1160  	goto out_with_bitmap;
1161        mchild = parent-&gt;memory_first_child;
1162        while (mchild) {
1163  	hwloc_bitmap_clr(remaining_nodes, mchild-&gt;os_index); &amp;bsol;* cannot use parent-&gt;nodeset, some normal children may have other NUMA nodes */
1164  	mchild = mchild-&gt;next_sibling;
1165        }
1166      }
1167    }
1168    hwloc_bitmap_free(remaining_nodes);
1169    return 0;
1170   out_with_bitmap:
1171    hwloc_bitmap_free(remaining_nodes);
1172    return -1;
1173  }
1174  int
1175  hwloc_topology_export_synthetic(struct hwloc_topology * topology,
1176  				char *buffer, size_t buflen,
1177  				unsigned long flags)
1178  {
1179    hwloc_obj_t obj = hwloc_get_root_obj(topology);
1180    ssize_t tmplen = buflen;
1181    char *tmp = buffer;
1182    int res, ret = 0;
1183    unsigned arity;
1184    int needprefix = 0;
1185    int verbose = 0;
1186    const char *env = getenv(&quot;HWLOC_SYNTHETIC_VERBOSE&quot;);
1187    if (env)
1188      verbose = atoi(env);
1189    if (!topology-&gt;is_loaded) {
1190      errno = EINVAL;
1191      return -1;
1192    }
1193    if (flags &amp; ~(HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1194  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS
1195  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1
1196  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1197      errno = EINVAL;
1198      return -1;
1199    }
1200    if (!obj-&gt;symmetric_subtree) {
1201      if (verbose)
1202        fprintf(stderr, &quot;Cannot export to synthetic unless topology is symmetric (root-&gt;symmetric_subtree must be set).\n&quot;);
1203      errno = EINVAL;
1204      return -1;
1205    }
1206    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
1207        &amp;&amp; hwloc_check_memory_symmetric(topology) &lt; 0) {
1208      if (verbose)
1209        fprintf(stderr, &quot;Cannot export to synthetic unless memory is attached symmetrically.\n&quot;);
1210      errno = EINVAL;
1211      return -1;
1212    }
1213    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1214      hwloc_obj_t node;
1215      signed pdepth;
1216      node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
1217      assert(node);
1218      assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1219      pdepth = node-&gt;parent-&gt;depth;
1220      while ((node = node-&gt;next_cousin) != NULL) {
1221        assert(hwloc__obj_type_is_normal(node-&gt;parent-&gt;type)); &amp;bsol;* only depth-1 memory children for now */
1222        if (node-&gt;parent-&gt;depth != pdepth) {
1223  	if (verbose)
1224  	  fprintf(stderr, &quot;Cannot export to synthetic v1 if memory is attached to parents at different depths.\n&quot;);
1225  	errno = EINVAL;
1226  	return -1;
1227        }
1228      }
1229    }
1230    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1231      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1232      if (res &gt; 0)
1233        needprefix = 1;
1234      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1235        return -1;
1236    }
1237    if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1238      res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, needprefix, verbose);
1239      if (res &gt; 0)
1240        needprefix = 1;
1241      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1242        return -1;
1243    }
1244    arity = obj-&gt;arity;
1245    while (arity) {
1246      obj = obj-&gt;first_child;
1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&amp;ret, &amp;tmp, &amp;tmplen, &#x27; &#x27;);
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
1250      if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1251        return -1;
1252      if (!(flags &amp; HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1253        res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, 1, verbose);
1254        if (hwloc__export_synthetic_update_status(&amp;ret, &amp;tmp, &amp;tmplen, res) &lt; 0)
1255  	return -1;
1256      }
1257      needprefix = 1;
1258      arity = obj-&gt;arity;
1259    }
1260    return ret;
1261  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_stream.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &quot;endianconv.h&quot;
3  #include &quot;stream.h&quot;
4  #define STREAM_BYTES_PER_LISTPACK 2048
5  #define STREAM_ITEM_FLAG_NONE 0             &amp;bsol;* No special flags. */
6  #define STREAM_ITEM_FLAG_DELETED (1&lt;&lt;0)     &amp;bsol;* Entry is delted. Skip it. */
7  #define STREAM_ITEM_FLAG_SAMEFIELDS (1&lt;&lt;1)  &amp;bsol;* Same fields as master entry. */
8  void streamFreeCG(streamCG *cg);
9  void streamFreeNACK(streamNACK *na);
10  size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);
11  stream *streamNew(void) {
12      stream *s = zmalloc(sizeof(*s));
13      s-&gt;rax = raxNew();
14      s-&gt;length = 0;
15      s-&gt;last_id.ms = 0;
16      s-&gt;last_id.seq = 0;
17      s-&gt;cgroups = NULL; &amp;bsol;* Created on demand to save memory when not used. */
18      return s;
19  }
20  void freeStream(stream *s) {
21      raxFreeWithCallback(s-&gt;rax,(void(*)(void*))lpFree);
22      if (s-&gt;cgroups)
23          raxFreeWithCallback(s-&gt;cgroups,(void(*)(void*))streamFreeCG);
24      zfree(s);
25  }
26  void streamIncrID(streamID *id) {
27      if (id-&gt;seq == UINT64_MAX) {
28          if (id-&gt;ms == UINT64_MAX) {
29              id-&gt;ms = id-&gt;seq = 0;
30          } else {
31              id-&gt;ms++;
32              id-&gt;seq = 0;
33          }
34      } else {
35          id-&gt;seq++;
36      }
37  }
38  PORT_ULONG streamLength(const robj *subject) {
39      stream *s = subject-&gt;ptr;
40      return s-&gt;length;
41  }
42  void streamNextID(streamID *last_id, streamID *new_id) {
43      uint64_t ms = mstime();
44      if (ms &gt; last_id-&gt;ms) {
45          new_id-&gt;ms = ms;
46          new_id-&gt;seq = 0;
47      } else {
48          *new_id = *last_id;
49          streamIncrID(new_id);
50      }
51  }
52  unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
53      char buf[LONG_STR_SIZE];
54      int slen = ll2string(buf,sizeof(buf),value);
55      return lpAppend(lp,(unsigned char*)buf,slen);
56  }
57  unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {
58      char buf[LONG_STR_SIZE];
59      int slen = ll2string(buf,sizeof(buf),value);
60      return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);
61  }
62  int64_t lpGetInteger(unsigned char *ele) {
63      int64_t v;
64      unsigned char *e = lpGet(ele,&amp;v,NULL);
65      if (e == NULL) return v;
66      PORT_LONGLONG ll;
67      int retval = string2ll((char*)e,v,&amp;ll);
68      serverAssert(retval != 0);
69      v = ll;
70      return v;
71  }
72  void streamLogListpackContent(unsigned char *lp) {
73      unsigned char *p = lpFirst(lp);
74      while(p) {
75          unsigned char buf[LP_INTBUF_SIZE];
76          int64_t v;
77          unsigned char *ele = lpGet(p,&amp;v,buf);
78          serverLog(LL_WARNING,&quot;- [%d] &#x27;%.*s&#x27;&quot;, (int)v, (int)v, ele);
79          p = lpNext(lp,p);
80      }
81  }
82  void streamEncodeID(void *buf, streamID *id) {
83      uint64_t e[2];
84      e[0] = htonu64(id-&gt;ms);
85      e[1] = htonu64(id-&gt;seq);
86      memcpy(buf,e,sizeof(e));
87  }
88  void streamDecodeID(void *buf, streamID *id) {
89      uint64_t e[2];
90      memcpy(e,buf,sizeof(e));
91      id-&gt;ms = ntohu64(e[0]);
92      id-&gt;seq = ntohu64(e[1]);
93  }
94  int streamCompareID(streamID *a, streamID *b) {
95      if (a-&gt;ms &gt; b-&gt;ms) return 1;
96      else if (a-&gt;ms &lt; b-&gt;ms) return -1;
97      else if (a-&gt;seq &gt; b-&gt;seq) return 1;
98      else if (a-&gt;seq &lt; b-&gt;seq) return -1;
99      return 0;
100  }
101  int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {
102      streamID id;
103      if (use_id)
104          id = *use_id;
105      else
106          streamNextID(&amp;s-&gt;last_id,&amp;id);
107      if (streamCompareID(&amp;id,&amp;s-&gt;last_id) &lt;= 0) return C_ERR;
108      raxIterator ri;
109      raxStart(&amp;ri,s-&gt;rax);
110      raxSeek(&amp;ri,&quot;$&quot;,NULL,0);
111      size_t lp_bytes = 0;        &amp;bsol;* Total bytes in the tail listpack. */
112      unsigned char *lp = NULL;   &amp;bsol;* Tail listpack pointer. */
113      if (raxNext(&amp;ri)) {
114          lp = ri.data;
115          lp_bytes = lpBytes(lp);
116      }
117      raxStop(&amp;ri);
118      uint64_t rax_key[2];    &amp;bsol;* Key in the radix tree containing the listpack.*/
119      streamID master_id;     &amp;bsol;* ID of the master entry in the listpack. */
120      if (lp != NULL) {
121          if (server.stream_node_max_bytes &amp;&amp;
122              lp_bytes &gt;= server.stream_node_max_bytes)
123          {
124              lp = NULL;
125          } else if (server.stream_node_max_entries) {
126              int64_t count = lpGetInteger(lpFirst(lp));
127              if (count &gt;= server.stream_node_max_entries) lp = NULL;
128          }
129      }
130      int flags = STREAM_ITEM_FLAG_NONE;
131      if (lp == NULL || lp_bytes &gt;= server.stream_node_max_bytes) {
132          master_id = id;
133          streamEncodeID(rax_key,&amp;id);
134          lp = lpNew();
135          lp = lpAppendInteger(lp,1); &amp;bsol;* One item, the one we are adding. */
136          lp = lpAppendInteger(lp,0); &amp;bsol;* Zero deleted so far. */
137          lp = lpAppendInteger(lp,numfields);
138          for (int64_t i = 0; i &lt; numfields; i++) {
139              sds field = argv[i*2]-&gt;ptr;
140              lp = lpAppend(lp,(unsigned char*)field,sdslen(field));
141          }
142          lp = lpAppendInteger(lp,0); &amp;bsol;* Master entry zero terminator. */
143          raxInsert(s-&gt;rax,(unsigned char*)&amp;rax_key,sizeof(rax_key),lp,NULL);
144          flags |= STREAM_ITEM_FLAG_SAMEFIELDS;
145      } else {
146          serverAssert(ri.key_len == sizeof(rax_key));
147          memcpy(rax_key,ri.key,sizeof(rax_key));
148          streamDecodeID(rax_key,&amp;master_id);
149          unsigned char *lp_ele = lpFirst(lp);
150          int64_t count = lpGetInteger(lp_ele);
151          lp = lpReplaceInteger(lp,&amp;lp_ele,count+1);
152          lp_ele = lpNext(lp,lp_ele); &amp;bsol;* seek deleted. */
153          lp_ele = lpNext(lp,lp_ele); &amp;bsol;* seek master entry num fields. */
154          int64_t master_fields_count = lpGetInteger(lp_ele);
155          lp_ele = lpNext(lp,lp_ele);
156          if (numfields == master_fields_count) {
157              int64_t i;
158              for (i = 0; i &lt; master_fields_count; i++) {
159                  sds field = argv[i*2]-&gt;ptr;
160                  int64_t e_len;
161                  unsigned char buf[LP_INTBUF_SIZE];
162                  unsigned char *e = lpGet(lp_ele,&amp;e_len,buf);
163                  if (sdslen(field) != (size_t)e_len ||
164                      memcmp(e,field,e_len) != 0) break;
165                  lp_ele = lpNext(lp,lp_ele);
166              }
167              if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;
168          }
169      }
170      lp = lpAppendInteger(lp,flags);
171      lp = lpAppendInteger(lp,id.ms - master_id.ms);
172      lp = lpAppendInteger(lp,id.seq - master_id.seq);
173      if (!(flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS))
174          lp = lpAppendInteger(lp,numfields);
175      for (int64_t i = 0; i &lt; numfields; i++) {
176          sds field = argv[i*2]-&gt;ptr, value = argv[i*2+1]-&gt;ptr;
177          if (!(flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS))
178              lp = lpAppend(lp,(unsigned char*)field,sdslen(field));
179          lp = lpAppend(lp,(unsigned char*)value,sdslen(value));
180      }
181      int64_t lp_count = numfields;
182      lp_count += 3; &amp;bsol;* Add the 3 fixed fields flags + ms-diff + seq-diff. */
183      if (!(flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS)) {
184          lp_count += numfields+1;
185      }
186      lp = lpAppendInteger(lp,lp_count);
187      if (ri.data != lp)
188          raxInsert(s-&gt;rax,(unsigned char*)&amp;rax_key,sizeof(rax_key),lp,NULL);
189      s-&gt;length++;
190      s-&gt;last_id = id;
191      if (added_id) *added_id = id;
192      return C_OK;
193  }
194  int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
195      if (s-&gt;length &lt;= maxlen) return 0;
196      raxIterator ri;
197      raxStart(&amp;ri,s-&gt;rax);
198      raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
199      int64_t deleted = 0;
200      while(s-&gt;length &gt; maxlen &amp;&amp; raxNext(&amp;ri)) {
201          unsigned char *lp = ri.data, *p = lpFirst(lp);
202          int64_t entries = lpGetInteger(p);
203          if (s-&gt;length - entries &gt;= maxlen) {
204              lpFree(lp);
205              raxRemove(s-&gt;rax,ri.key,ri.key_len,NULL);
206              raxSeek(&amp;ri,&quot;&gt;=&quot;,ri.key,ri.key_len);
207              s-&gt;length -= entries;
208              deleted += entries;
209              continue;
210          }
211          if (approx) break;
212          int64_t to_delete = s-&gt;length - maxlen;
213          serverAssert(to_delete &lt; entries);
214          lp = lpReplaceInteger(lp,&amp;p,entries-to_delete);
215          p = lpNext(lp,p); &amp;bsol;* Seek deleted field. */
216          int64_t marked_deleted = lpGetInteger(p);
217          lp = lpReplaceInteger(lp,&amp;p,marked_deleted+to_delete);
218          p = lpNext(lp,p); &amp;bsol;* Seek num-of-fields in the master entry. */
219          int64_t master_fields_count = lpGetInteger(p);
220          p = lpNext(lp,p); &amp;bsol;* Seek the first field. */
221          for (int64_t j = 0; j &lt; master_fields_count; j++)
222              p = lpNext(lp,p); &amp;bsol;* Skip all master fields. */
223          p = lpNext(lp,p); &amp;bsol;* Skip the zero master entry terminator. */
224          while(p) {
225              int flags = lpGetInteger(p);
226              int to_skip;
227              if (!(flags &amp; STREAM_ITEM_FLAG_DELETED)) {
228                  flags |= STREAM_ITEM_FLAG_DELETED;
229                  lp = lpReplaceInteger(lp,&amp;p,flags);
230                  deleted++;
231                  s-&gt;length--;
232                  if (s-&gt;length &lt;= maxlen) break; &amp;bsol;* Enough entries deleted. */
233              }
234              p = lpNext(lp,p); &amp;bsol;* Skip ID ms delta. */
235              p = lpNext(lp,p); &amp;bsol;* Skip ID seq delta. */
236              p = lpNext(lp,p); &amp;bsol;* Seek num-fields or values (if compressed). */
237              if (flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS) {
238                  to_skip = master_fields_count;
239              } else {
240                  to_skip = lpGetInteger(p);
241                  to_skip = 1+(to_skip*2);
242              }
243              while(to_skip--) p = lpNext(lp,p); &amp;bsol;* Skip the whole entry. */
244              p = lpNext(lp,p); &amp;bsol;* Skip the final lp-count field. */
245          }
246          entries -= to_delete;
247          marked_deleted += to_delete;
248          if (entries + marked_deleted &gt; 10 &amp;&amp; marked_deleted &gt; entries/2) {
249          }
250          raxInsert(s-&gt;rax,ri.key,ri.key_len,lp,NULL);
251          break; &amp;bsol;* If we are here, there was enough to delete in the current
252                    node, so no need to go to the next node. */
253      }
254      raxStop(&amp;ri);
255      return deleted;
256  }
257  void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
258      if (start) {
259          streamEncodeID(si-&gt;start_key,start);
260      } else {
261          si-&gt;start_key[0] = 0;
262          si-&gt;start_key[1] = 0;
263      }
264      if (end) {
265          streamEncodeID(si-&gt;end_key,end);
266      } else {
267          si-&gt;end_key[0] = UINT64_MAX;
268          si-&gt;end_key[1] = UINT64_MAX;
269      }
270      raxStart(&amp;si-&gt;ri,s-&gt;rax);
271      if (!rev) {
272          if (start &amp;&amp; (start-&gt;ms || start-&gt;seq)) {
273              raxSeek(&amp;si-&gt;ri,&quot;&lt;=&quot;,(unsigned char*)si-&gt;start_key,
274                      sizeof(si-&gt;start_key));
275              if (raxEOF(&amp;si-&gt;ri)) raxSeek(&amp;si-&gt;ri,&quot;^&quot;,NULL,0);
276          } else {
277              raxSeek(&amp;si-&gt;ri,&quot;^&quot;,NULL,0);
278          }
279      } else {
280          if (end &amp;&amp; (end-&gt;ms || end-&gt;seq)) {
281              raxSeek(&amp;si-&gt;ri,&quot;&lt;=&quot;,(unsigned char*)si-&gt;end_key,
282                      sizeof(si-&gt;end_key));
283              if (raxEOF(&amp;si-&gt;ri)) raxSeek(&amp;si-&gt;ri,&quot;$&quot;,NULL,0);
284          } else {
285              raxSeek(&amp;si-&gt;ri,&quot;$&quot;,NULL,0);
286          }
287      }
288      si-&gt;stream = s;
289      si-&gt;lp = NULL; &amp;bsol;* There is no current listpack right now. */
290      si-&gt;lp_ele = NULL; &amp;bsol;* Current listpack cursor. */
291      si-&gt;rev = rev;  &amp;bsol;* Direction, if non-zero reversed, from end to start. */
292  }
293  int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
294      while(1) { &amp;bsol;* Will stop when element &gt; stop_key or end of radix tree. */
295          if (si-&gt;lp == NULL || si-&gt;lp_ele == NULL) {
296              if (!si-&gt;rev &amp;&amp; !raxNext(&amp;si-&gt;ri)) return 0;
297              else if (si-&gt;rev &amp;&amp; !raxPrev(&amp;si-&gt;ri)) return 0;
298              serverAssert(si-&gt;ri.key_len == sizeof(streamID));
299              streamDecodeID(si-&gt;ri.key,&amp;si-&gt;master_id);
300              si-&gt;lp = si-&gt;ri.data;
301              si-&gt;lp_ele = lpFirst(si-&gt;lp);           &amp;bsol;* Seek items count */
302              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele); &amp;bsol;* Seek deleted count. */
303              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele); &amp;bsol;* Seek num fields. */
304              si-&gt;master_fields_count = lpGetInteger(si-&gt;lp_ele);
305              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele); &amp;bsol;* Seek first field. */
306              si-&gt;master_fields_start = si-&gt;lp_ele;
307              if (!si-&gt;rev) {
308                  for (uint64_t i = 0; i &lt; si-&gt;master_fields_count; i++)
309                      si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
310              } else {
311                  si-&gt;lp_ele = lpLast(si-&gt;lp);
312              }
313          } else if (si-&gt;rev) {
314              int lp_count = lpGetInteger(si-&gt;lp_ele);
315              while(lp_count--) si-&gt;lp_ele = lpPrev(si-&gt;lp,si-&gt;lp_ele);
316              si-&gt;lp_ele = lpPrev(si-&gt;lp,si-&gt;lp_ele);
317          }
318          while(1) {
319              if (!si-&gt;rev) {
320                  si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
321                  if (si-&gt;lp_ele == NULL) break;
322              } else {
323                  int64_t lp_count = lpGetInteger(si-&gt;lp_ele);
324                  if (lp_count == 0) { &amp;bsol;* We reached the master entry. */
325                      si-&gt;lp = NULL;
326                      si-&gt;lp_ele = NULL;
327                      break;
328                  }
329                  while(lp_count--) si-&gt;lp_ele = lpPrev(si-&gt;lp,si-&gt;lp_ele);
330              }
331              si-&gt;lp_flags = si-&gt;lp_ele;
332              int flags = lpGetInteger(si-&gt;lp_ele);
333              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele); &amp;bsol;* Seek ID. */
334              *id = si-&gt;master_id;
335              id-&gt;ms += lpGetInteger(si-&gt;lp_ele);
336              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
337              id-&gt;seq += lpGetInteger(si-&gt;lp_ele);
338              si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
339              unsigned char buf[sizeof(streamID)];
340              streamEncodeID(buf,id);
341              if (flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS) {
342                  *numfields = si-&gt;master_fields_count;
343              } else {
344                  *numfields = lpGetInteger(si-&gt;lp_ele);
345                  si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
346              }
347              if (!si-&gt;rev) {
348                  if (memcmp(buf,si-&gt;start_key,sizeof(streamID)) &gt;= 0 &amp;&amp;
349                      !(flags &amp; STREAM_ITEM_FLAG_DELETED))
350                  {
351                      if (memcmp(buf,si-&gt;end_key,sizeof(streamID)) &gt; 0)
352                          return 0; &amp;bsol;* We are already out of range. */
353                      si-&gt;entry_flags = flags;
354                      if (flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS)
355                          si-&gt;master_fields_ptr = si-&gt;master_fields_start;
356                      return 1; &amp;bsol;* Valid item returned. */
357                  }
358              } else {
359                  if (memcmp(buf,si-&gt;end_key,sizeof(streamID)) &lt;= 0 &amp;&amp;
360                      !(flags &amp; STREAM_ITEM_FLAG_DELETED))
361                  {
362                      if (memcmp(buf,si-&gt;start_key,sizeof(streamID)) &lt; 0)
363                          return 0; &amp;bsol;* We are already out of range. */
364                      si-&gt;entry_flags = flags;
365                      if (flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS)
366                          si-&gt;master_fields_ptr = si-&gt;master_fields_start;
367                      return 1; &amp;bsol;* Valid item returned. */
368                  }
369              }
370              if (!si-&gt;rev) {
371                  int64_t to_discard = (flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS) ?
372                                        *numfields : *numfields*2;
373                  for (int64_t i = 0; i &lt; to_discard; i++)
374                      si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
375              } else {
376                  int64_t prev_times = 4; &amp;bsol;* flag + id ms + id seq + one more to
377                                             go back to the previous entry &quot;count&quot;
378                                             field. */
379                  if (!(flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS)) prev_times++;
380                  while(prev_times--) si-&gt;lp_ele = lpPrev(si-&gt;lp,si-&gt;lp_ele);
381              }
382          }
383      }
384  }
385  void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
386      if (si-&gt;entry_flags &amp; STREAM_ITEM_FLAG_SAMEFIELDS) {
387          *fieldptr = lpGet(si-&gt;master_fields_ptr,fieldlen,si-&gt;field_buf);
388          si-&gt;master_fields_ptr = lpNext(si-&gt;lp,si-&gt;master_fields_ptr);
389      } else {
390          *fieldptr = lpGet(si-&gt;lp_ele,fieldlen,si-&gt;field_buf);
391          si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
392      }
393      *valueptr = lpGet(si-&gt;lp_ele,valuelen,si-&gt;value_buf);
394      si-&gt;lp_ele = lpNext(si-&gt;lp,si-&gt;lp_ele);
395  }
396  void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
397      unsigned char *lp = si-&gt;lp;
398      int64_t aux;
399      int flags = lpGetInteger(si-&gt;lp_flags);
400      flags |= STREAM_ITEM_FLAG_DELETED;
401      lp = lpReplaceInteger(lp,&amp;si-&gt;lp_flags,flags);
402      unsigned char *p = lpFirst(lp);
403      aux = lpGetInteger(p);
404      if (aux == 1) {
405          lpFree(lp);
406          raxRemove(si-&gt;stream-&gt;rax,si-&gt;ri.key,si-&gt;ri.key_len,NULL);
407      } else {
408          lp = lpReplaceInteger(lp,&amp;p,aux-1);
409          p = lpNext(lp,p); &amp;bsol;* Seek deleted field. */
410          aux = lpGetInteger(p);
411          lp = lpReplaceInteger(lp,&amp;p,aux+1);
412          if (si-&gt;lp != lp)
413              raxInsert(si-&gt;stream-&gt;rax,si-&gt;ri.key,si-&gt;ri.key_len,lp,NULL);
414      }
415      si-&gt;stream-&gt;length--;
416      streamID start, end;
417      if (si-&gt;rev) {
418          streamDecodeID(si-&gt;start_key,&amp;start);
419          end = *current;
420      } else {
421          start = *current;
422          streamDecodeID(si-&gt;end_key,&amp;end);
423      }
424      streamIteratorStop(si);
425      streamIteratorStart(si,si-&gt;stream,&amp;start,&amp;end,si-&gt;rev);
426  }
427  void streamIteratorStop(streamIterator *si) {
428      raxStop(&amp;si-&gt;ri);
429  }
430  int streamDeleteItem(stream *s, streamID *id) {
431      int deleted = 0;
432      streamIterator si;
433      streamIteratorStart(&amp;si,s,id,id,0);
434      streamID myid;
435      int64_t numfields;
436      if (streamIteratorGetID(&amp;si,&amp;myid,&amp;numfields)) {
437          streamIteratorRemoveEntry(&amp;si,&amp;myid);
438          deleted = 1;
439      }
440      streamIteratorStop(&amp;si);
441      return deleted;
442  }
443  void streamLastValidID(stream *s, streamID *maxid)
444  {
445      streamIterator si;
446      streamIteratorStart(&amp;si,s,NULL,NULL,1);
447      int64_t numfields;
448      streamIteratorGetID(&amp;si,maxid,&amp;numfields);
449      streamIteratorStop(&amp;si);
450  }
451  void addReplyStreamID(client *c, streamID *id) {
452      sds replyid = sdscatfmt(sdsempty(),&quot;%U-%U&quot;,id-&gt;ms,id-&gt;seq);
453      addReplyBulkSds(c,replyid);
454  }
455  robj *createObjectFromStreamID(streamID *id) {
456      return createObject(OBJ_STRING, sdscatfmt(sdsempty(),&quot;%U-%U&quot;,
457                          id-&gt;ms,id-&gt;seq));
458  }
459  void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
460      robj *argv[14];
461      argv[0] = createStringObject(&quot;XCLAIM&quot;,6);
462      argv[1] = key;
463      argv[2] = groupname;
464      argv[3] = createStringObject(nack-&gt;consumer-&gt;name,sdslen(nack-&gt;consumer-&gt;name));
465      argv[4] = createStringObjectFromLongLong(0);
466      argv[5] = id;
467      argv[6] = createStringObject(&quot;TIME&quot;,4);
468      argv[7] = createStringObjectFromLongLong(nack-&gt;delivery_time);
469      argv[8] = createStringObject(&quot;RETRYCOUNT&quot;,10);
470      argv[9] = createStringObjectFromLongLong(nack-&gt;delivery_count);
471      argv[10] = createStringObject(&quot;FORCE&quot;,5);
472      argv[11] = createStringObject(&quot;JUSTID&quot;,6);
473      argv[12] = createStringObject(&quot;LASTID&quot;,6);
474      argv[13] = createObjectFromStreamID(&amp;group-&gt;last_id);
475      propagate(server.xclaimCommand,c-&gt;db-&gt;id,argv,14,PROPAGATE_AOF|PROPAGATE_REPL);
476      decrRefCount(argv[0]);
477      decrRefCount(argv[3]);
478      decrRefCount(argv[4]);
479      decrRefCount(argv[6]);
480      decrRefCount(argv[7]);
481      decrRefCount(argv[8]);
482      decrRefCount(argv[9]);
483      decrRefCount(argv[10]);
484      decrRefCount(argv[11]);
485      decrRefCount(argv[12]);
486      decrRefCount(argv[13]);
487  }
488  void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
489      robj *argv[5];
490      argv[0] = createStringObject(&quot;XGROUP&quot;,6);
491      argv[1] = createStringObject(&quot;SETID&quot;,5);
492      argv[2] = key;
493      argv[3] = groupname;
494      argv[4] = createObjectFromStreamID(&amp;group-&gt;last_id);
495      propagate(server.xgroupCommand,c-&gt;db-&gt;id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);
496      decrRefCount(argv[0]);
497      decrRefCount(argv[1]);
498      decrRefCount(argv[4]);
499  }
500  #define STREAM_RWR_NOACK (1&lt;&lt;0)         &amp;bsol;* Do not create entries in the PEL. */
501  #define STREAM_RWR_RAWENTRIES (1&lt;&lt;1)    &amp;bsol;* Do not emit protocol for array
502                                             boundaries, just the entries. */
503  #define STREAM_RWR_HISTORY (1&lt;&lt;2)       &amp;bsol;* Only serve consumer local PEL. */
504  size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
505      void *arraylen_ptr = NULL;
506      size_t arraylen = 0;
507      streamIterator si;
508      int64_t numfields;
509      streamID id;
510      int propagate_last_id = 0;
511      if (group &amp;&amp; (flags &amp; STREAM_RWR_HISTORY)) {
512          return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
513                                                     consumer);
514      }
515      if (!(flags &amp; STREAM_RWR_RAWENTRIES))
516          arraylen_ptr = addDeferredMultiBulkLength(c);
517      streamIteratorStart(&amp;si,s,start,end,rev);
518      while(streamIteratorGetID(&amp;si,&amp;id,&amp;numfields)) {
519          if (group &amp;&amp; streamCompareID(&amp;id,&amp;group-&gt;last_id) &gt; 0) {
520              group-&gt;last_id = id;
521              propagate_last_id = 1;
522          }
523          addReplyMultiBulkLen(c,2);
524          addReplyStreamID(c,&amp;id);
525          addReplyMultiBulkLen(c,numfields*2);
526          while(numfields--) {
527              unsigned char *key, *value;
528              int64_t key_len, value_len;
529              streamIteratorGetField(&amp;si,&amp;key,&amp;value,&amp;key_len,&amp;value_len);
530              addReplyBulkCBuffer(c,key,key_len);
531              addReplyBulkCBuffer(c,value,value_len);
532          }
533          if (group &amp;&amp; !(flags &amp; STREAM_RWR_NOACK)) {
534              unsigned char buf[sizeof(streamID)];
535              streamEncodeID(buf,&amp;id);
536              streamNACK *nack = streamCreateNACK(consumer);
537              int group_inserted =
538                  raxTryInsert(group-&gt;pel,buf,sizeof(buf),nack,NULL);
539              int consumer_inserted =
540                  raxTryInsert(consumer-&gt;pel,buf,sizeof(buf),nack,NULL);
541              if (group_inserted == 0) {
542                  streamFreeNACK(nack);
543                  nack = raxFind(group-&gt;pel,buf,sizeof(buf));
544                  serverAssert(nack != raxNotFound);
545                  raxRemove(nack-&gt;consumer-&gt;pel,buf,sizeof(buf),NULL);
546                  nack-&gt;consumer = consumer;
547                  nack-&gt;delivery_time = mstime();
548                  nack-&gt;delivery_count = 1;
549                  raxInsert(consumer-&gt;pel,buf,sizeof(buf),nack,NULL);
550              } else if (group_inserted == 1 &amp;&amp; consumer_inserted == 0) {
551                  serverPanic(&quot;NACK half-created. Should not be possible.&quot;);
552              }
553              if (spi) {
554                  robj *idarg = createObjectFromStreamID(&amp;id);
555                  streamPropagateXCLAIM(c,spi-&gt;keyname,group,spi-&gt;groupname,idarg,nack);
556                  decrRefCount(idarg);
557              }
558          } else {
559              if (propagate_last_id)
560                  streamPropagateGroupID(c,spi-&gt;keyname,group,spi-&gt;groupname);
561          }
562          arraylen++;
563          if (count &amp;&amp; count == arraylen) break;
564      }
565      streamIteratorStop(&amp;si);
566      if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
567      return arraylen;
568  }
569  size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {
570      raxIterator ri;
571      unsigned char startkey[sizeof(streamID)];
572      unsigned char endkey[sizeof(streamID)];
573      streamEncodeID(startkey,start);
574      if (end) streamEncodeID(endkey,end);
575      size_t arraylen = 0;
576      void *arraylen_ptr = addDeferredMultiBulkLength(c);
577      raxStart(&amp;ri,consumer-&gt;pel);
578      raxSeek(&amp;ri,&quot;&gt;=&quot;,startkey,sizeof(startkey));
579      while(raxNext(&amp;ri) &amp;&amp; (!count || arraylen &lt; count)) {
580          if (end &amp;&amp; memcmp(ri.key,end,ri.key_len) &gt; 0) break;
581          streamID thisid;
582          streamDecodeID(ri.key,&amp;thisid);
583          if (streamReplyWithRange(c,s,&amp;thisid,&amp;thisid,1,0,NULL,NULL,
584                                   STREAM_RWR_RAWENTRIES,NULL) == 0)
585          {
586              addReplyMultiBulkLen(c,2);
587              streamID id;
588              streamDecodeID(ri.key,&amp;id);
589              addReplyStreamID(c,&amp;id);
590              addReply(c,shared.nullmultibulk);
591          } else {
592              streamNACK *nack = ri.data;
593              nack-&gt;delivery_time = mstime();
594              nack-&gt;delivery_count++;
595          }
596          arraylen++;
597      }
598      raxStop(&amp;ri);
599      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
600      return arraylen;
601  }
602  robj *streamTypeLookupWriteOrCreate(client *c, robj *key) {
603      robj *o = lookupKeyWrite(c-&gt;db,key);
604      if (o == NULL) {
605          o = createStreamObject();
606          dbAdd(c-&gt;db,key,o);
607      } else {
608          if (o-&gt;type != OBJ_STREAM) {
609              addReply(c,shared.wrongtypeerr);
610              return NULL;
611          }
612      }
613      return o;
614  }
615  int string2ull(const char *s, PORT_ULONGLONG *value) {
616      PORT_LONGLONG ll;
617      if (string2ll(s,strlen(s),&amp;ll)) {
618          if (ll &lt; 0) return 0; &amp;bsol;* Negative values are out of range. */
619          *value = ll;
620          return 1;
621      }
622      errno = 0;
623      char *endptr = NULL;
624      *value = strtoull(s,&amp;endptr,10);
625      if (errno == EINVAL || errno == ERANGE || !(*s != &#x27;\0&#x27; &amp;&amp; *endptr == &#x27;\0&#x27;))
626          return 0; &amp;bsol;* strtoull() failed. */
627      return 1; &amp;bsol;* Conversion done! */
628  }
629  int streamGenericParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int strict) {
630      char buf[128];
631      if (sdslen(o-&gt;ptr) &gt; sizeof(buf)-1) goto invalid;
632      memcpy(buf,o-&gt;ptr,sdslen(o-&gt;ptr)+1);
633      if (strict &amp;&amp; (buf[0] == &#x27;-&#x27; || buf[0] == &#x27;+&#x27;) &amp;&amp; buf[1] == &#x27;\0&#x27;)
634          goto invalid;
635      if (buf[0] == &#x27;-&#x27; &amp;&amp; buf[1] == &#x27;\0&#x27;) {
636          id-&gt;ms = 0;
637          id-&gt;seq = 0;
638          return C_OK;
639      } else if (buf[0] == &#x27;+&#x27; &amp;&amp; buf[1] == &#x27;\0&#x27;) {
640          id-&gt;ms = UINT64_MAX;
641          id-&gt;seq = UINT64_MAX;
642          return C_OK;
643      }
644      char *dot = strchr(buf,&#x27;-&#x27;);
645      if (dot) *dot = &#x27;\0&#x27;;
646      PORT_ULONGLONG ms, seq;
647      if (string2ull(buf,&amp;ms) == 0) goto invalid;
648      if (dot &amp;&amp; string2ull(dot+1,&amp;seq) == 0) goto invalid;
649      if (!dot) seq = missing_seq;
650      id-&gt;ms = ms;
651      id-&gt;seq = seq;
652      return C_OK;
653  invalid:
654      if (c) addReplyError(c,&quot;Invalid stream ID specified as stream &quot;
655                             &quot;command argument&quot;);
656      return C_ERR;
657  }
658  int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
659      return streamGenericParseIDOrReply(c,o,id,missing_seq,0);
660  }
661  int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
662      return streamGenericParseIDOrReply(c,o,id,missing_seq,1);
663  }
664  void streamRewriteApproxMaxlen(client *c, stream *s, int maxlen_arg_idx) {
665      robj *maxlen_obj = createStringObjectFromLongLong(s-&gt;length);
666      robj *equal_obj = createStringObject(&quot;=&quot;,1);
667      rewriteClientCommandArgument(c,maxlen_arg_idx,maxlen_obj);
668      rewriteClientCommandArgument(c,maxlen_arg_idx-1,equal_obj);
669      decrRefCount(equal_obj);
670      decrRefCount(maxlen_obj);
671  }
672  void xaddCommand(client *c) {
673      streamID id;
674      int id_given = 0; &amp;bsol;* Was an ID different than &quot;*&quot; specified? */
675      PORT_LONGLONG maxlen = -1;  &amp;bsol;* If left to -1 no trimming is performed. */
676      int approx_maxlen = 0;  &amp;bsol;* If 1 only delete whole radix tree nodes, so
677                                 the maxium length is not applied verbatim. */
678      int maxlen_arg_idx = 0; &amp;bsol;* Index of the count in MAXLEN, for rewriting. */
679      int i = 2; &amp;bsol;* This is the first argument position where we could
680                    find an option, or the ID. */
681      for (; i &lt; c-&gt;argc; i++) {
682          int moreargs = (c-&gt;argc-1) - i; &amp;bsol;* Number of additional arguments. */
683          char *opt = c-&gt;argv[i]-&gt;ptr;
684          if (opt[0] == &#x27;*&#x27; &amp;&amp; opt[1] == &#x27;\0&#x27;) {
685              break;
686          } else if (!strcasecmp(opt,&quot;maxlen&quot;) &amp;&amp; moreargs) {
687              approx_maxlen = 0;
688              char *next = c-&gt;argv[i+1]-&gt;ptr;
689              if (moreargs &gt;= 2 &amp;&amp; next[0] == &#x27;~&#x27; &amp;&amp; next[1] == &#x27;\0&#x27;) {
690                  approx_maxlen = 1;
691                  i++;
692              } else if (moreargs &gt;= 2 &amp;&amp; next[0] == &#x27;=&#x27; &amp;&amp; next[1] == &#x27;\0&#x27;) {
693                  i++;
694              }
695              if (getLongLongFromObjectOrReply(c,c-&gt;argv[i+1],&amp;maxlen,NULL)
696                  != C_OK) return;
697              if (maxlen &lt; 0) {
698                  addReplyError(c,&quot;The MAXLEN argument must be &gt;= 0.&quot;);
699                  return;
700              }
701              i++;
702              maxlen_arg_idx = i;
703          } else {
704              if (streamParseStrictIDOrReply(c,c-&gt;argv[i],&amp;id,0) != C_OK) return;
705              id_given = 1;
706              break;
707          }
708      }
709      int field_pos = i+1;
710      if ((c-&gt;argc - field_pos) &lt; 2 || ((c-&gt;argc-field_pos) % 2) == 1) {
711          addReplyError(c,&quot;wrong number of arguments for XADD&quot;);
712          return;
713      }
714      if (id_given &amp;&amp; id.ms == 0 &amp;&amp; id.seq == 0) {
715          addReplyError(c,&quot;The ID specified in XADD must be greater than 0-0&quot;);
716          return;
717      }
718      robj *o;
719      stream *s;
720      if ((o = streamTypeLookupWriteOrCreate(c,c-&gt;argv[1])) == NULL) return;
721      s = o-&gt;ptr;
722      if (s-&gt;last_id.ms == UINT64_MAX &amp;&amp; s-&gt;last_id.seq == UINT64_MAX) {
723          addReplyError(c,&quot;The stream has exhausted the last possible ID, &quot;
724                          &quot;unable to add more items&quot;);
725          return;
726      }
727      if (streamAppendItem(s,c-&gt;argv+field_pos,(c-&gt;argc-field_pos)/2,
728          &amp;id, id_given ? &amp;id : NULL)
729          == C_ERR)
730      {
731          addReplyError(c,&quot;The ID specified in XADD is equal or smaller than the &quot;
732                          &quot;target stream top item&quot;);
733          return;
734      }
735      addReplyStreamID(c,&amp;id);
736      signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
737      notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xadd&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
738      server.dirty++;
739      if (maxlen &gt;= 0) {
740          if (streamTrimByLength(s,maxlen,approx_maxlen)) {
741              notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xtrim&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
742          }
743          if (approx_maxlen) streamRewriteApproxMaxlen(c,s,maxlen_arg_idx);
744      }
745      robj *idarg = createObjectFromStreamID(&amp;id);
746      rewriteClientCommandArgument(c,i,idarg);
747      decrRefCount(idarg);
748      if (server.blocked_clients_by_type[BLOCKED_STREAM])
749          signalKeyAsReady(c-&gt;db, c-&gt;argv[1]);
750  }
751  void xrangeGenericCommand(client *c, int rev) {
752      robj *o;
753      stream *s;
754      streamID startid, endid;
755      PORT_LONGLONG count = -1;
756      robj *startarg = rev ? c-&gt;argv[3] : c-&gt;argv[2];
757      robj *endarg = rev ? c-&gt;argv[2] : c-&gt;argv[3];
758      if (streamParseIDOrReply(c,startarg,&amp;startid,0) == C_ERR) return;
759      if (streamParseIDOrReply(c,endarg,&amp;endid,UINT64_MAX) == C_ERR) return;
760      if (c-&gt;argc &gt; 4) {
761          for (int j = 4; j &lt; c-&gt;argc; j++) {
762              int additional = c-&gt;argc-j-1;
763              if (strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;COUNT&quot;) == 0 &amp;&amp; additional &gt;= 1) {
764                  if (getLongLongFromObjectOrReply(c,c-&gt;argv[j+1],&amp;count,NULL)
765                      != C_OK) return;
766                  if (count &lt; 0) count = 0;
767                  j++; &amp;bsol;* Consume additional arg. */
768              } else {
769                  addReply(c,shared.syntaxerr);
770                  return;
771              }
772          }
773      }
774      if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.emptymultibulk)) == NULL
775          || checkType(c,o,OBJ_STREAM)) return;
776      s = o-&gt;ptr;
777      if (count == 0) {
778          addReply(c,shared.nullmultibulk);
779      } else {
780          if (count == -1) count = 0;
781          streamReplyWithRange(c,s,&amp;startid,&amp;endid,count,rev,NULL,NULL,0,NULL);
782      }
783  }
784  void xrangeCommand(client *c) {
785      xrangeGenericCommand(c,0);
786  }
787  void xrevrangeCommand(client *c) {
788      xrangeGenericCommand(c,1);
789  }
790  void xlenCommand(client *c) {
791      robj *o;
792      if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.czero)) == NULL
793          || checkType(c,o,OBJ_STREAM)) return;
794      stream *s = o-&gt;ptr;
795      addReplyLongLong(c,s-&gt;length);
796  }
797  #define XREAD_BLOCKED_DEFAULT_COUNT 1000
798  void xreadCommand(client *c) {
799      PORT_LONGLONG timeout = -1; &amp;bsol;* -1 means, no BLOCK argument given. */
800      PORT_LONGLONG count = 0;
801      int streams_count = 0;
802      int streams_arg = 0;
803      int noack = 0;          &amp;bsol;* True if NOACK option was specified. */
804      #define STREAMID_STATIC_VECTOR_LEN 8
805      streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
806      streamID *ids = static_ids;
807      streamCG **groups = NULL;
808      int xreadgroup = sdslen(c-&gt;argv[0]-&gt;ptr) == 10; &amp;bsol;* XREAD or XREADGROUP? */
809      robj *groupname = NULL;
810      robj *consumername = NULL;
811      for (int i = 1; i &lt; c-&gt;argc; i++) {
812          int moreargs = c-&gt;argc-i-1;
813          char *o = c-&gt;argv[i]-&gt;ptr;
814          if (!strcasecmp(o,&quot;BLOCK&quot;) &amp;&amp; moreargs) {
815              i++;
816              if (getTimeoutFromObjectOrReply(c,c-&gt;argv[i],&amp;timeout,
817                  UNIT_MILLISECONDS) != C_OK) return;
818          } else if (!strcasecmp(o,&quot;COUNT&quot;) &amp;&amp; moreargs) {
819              i++;
820              if (getLongLongFromObjectOrReply(c,c-&gt;argv[i],&amp;count,NULL) != C_OK)
821                  return;
822              if (count &lt; 0) count = 0;
823          } else if (!strcasecmp(o,&quot;STREAMS&quot;) &amp;&amp; moreargs) {
824              streams_arg = i+1;
825              streams_count = (c-&gt;argc-streams_arg);
826              if ((streams_count % 2) != 0) {
827                  addReplyError(c,&quot;Unbalanced XREAD list of streams: &quot;
828                                  &quot;for each stream key an ID or &#x27;$&#x27; must be &quot;
829                                  &quot;specified.&quot;);
830                  return;
831              }
832              streams_count /= 2; &amp;bsol;* We have two arguments for each stream. */
833              break;
834          } else if (!strcasecmp(o,&quot;GROUP&quot;) &amp;&amp; moreargs &gt;= 2) {
835              if (!xreadgroup) {
836                  addReplyError(c,&quot;The GROUP option is only supported by &quot;
837                                  &quot;XREADGROUP. You called XREAD instead.&quot;);
838                  return;
839              }
840              groupname = c-&gt;argv[i+1];
841              consumername = c-&gt;argv[i+2];
842              i += 2;
843          } else if (!strcasecmp(o,&quot;NOACK&quot;)) {
844              if (!xreadgroup) {
845                  addReplyError(c,&quot;The NOACK option is only supported by &quot;
846                                  &quot;XREADGROUP. You called XREAD instead.&quot;);
847                  return;
848              }
849              noack = 1;
850          } else {
851              addReply(c,shared.syntaxerr);
852              return;
853          }
854      }
855      if (streams_arg == 0) {
856          addReply(c,shared.syntaxerr);
857          return;
858      }
859      if (xreadgroup &amp;&amp; groupname == NULL) {
860          addReplyError(c,&quot;Missing GROUP option for XREADGROUP&quot;);
861          return;
862      }
863      if (streams_count &gt; STREAMID_STATIC_VECTOR_LEN)
864          ids = zmalloc(sizeof(streamID)*streams_count);
865      if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);
866      for (int i = streams_arg + streams_count; i &lt; c-&gt;argc; i++) {
867          int id_idx = i - streams_arg - streams_count;
868          robj *key = c-&gt;argv[i-streams_count];
869          robj *o = lookupKeyRead(c-&gt;db,key);
870          if (o &amp;&amp; checkType(c,o,OBJ_STREAM)) goto cleanup;
871          streamCG *group = NULL;
872          if (groupname) {
873              if (o == NULL ||
874                  (group = streamLookupCG(o-&gt;ptr,groupname-&gt;ptr)) == NULL)
875              {
876                  addReplyErrorFormat(c, &quot;-NOGROUP No such key &#x27;%s&#x27; or consumer &quot;
877                                         &quot;group &#x27;%s&#x27; in XREADGROUP with GROUP &quot;
878                                         &quot;option&quot;,
879                                      (char*)key-&gt;ptr,(char*)groupname-&gt;ptr);
880                  goto cleanup;
881              }
882              groups[id_idx] = group;
883          }
884          if (strcmp(c-&gt;argv[i]-&gt;ptr,&quot;$&quot;) == 0) {
885              if (xreadgroup) {
886                  addReplyError(c,&quot;The $ ID is meaningless in the context of &quot;
887                                  &quot;XREADGROUP: you want to read the history of &quot;
888                                  &quot;this consumer by specifying a proper ID, or &quot;
889                                  &quot;use the &gt; ID to get new messages. The $ ID would &quot;
890                                  &quot;just return an empty result set.&quot;);
891                  goto cleanup;
892              }
893              if (o) {
894                  stream *s = o-&gt;ptr;
895                  ids[id_idx] = s-&gt;last_id;
896              } else {
897                  ids[id_idx].ms = 0;
898                  ids[id_idx].seq = 0;
899              }
900              continue;
901          } else if (strcmp(c-&gt;argv[i]-&gt;ptr,&quot;&gt;&quot;) == 0) {
902              if (!xreadgroup) {
903                  addReplyError(c,&quot;The &gt; ID can be specified only when calling &quot;
904                                  &quot;XREADGROUP using the GROUP &lt;group&gt; &quot;
905                                  &quot;&lt;consumer&gt; option.&quot;);
906                  goto cleanup;
907              }
<span onclick='openModal()' class='match'>908              ids[id_idx].ms = UINT64_MAX;
909              ids[id_idx].seq = UINT64_MAX;
910              continue;
</span>911          }
912          if (streamParseStrictIDOrReply(c,c-&gt;argv[i],ids+id_idx,0) != C_OK)
913              goto cleanup;
914      }
915      size_t arraylen = 0;
916      void *arraylen_ptr = NULL;
917      for (int i = 0; i &lt; streams_count; i++) {
918          robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[streams_arg+i]);
919          if (o == NULL) continue;
920          stream *s = o-&gt;ptr;
921          streamID *gt = ids+i; &amp;bsol;* ID must be greater than this. */
922          int serve_synchronously = 0;
923          int serve_history = 0; &amp;bsol;* True for XREADGROUP with ID != &quot;&gt;&quot;. */
924          if (groups) {
925              if (gt-&gt;ms != UINT64_MAX ||
926                  gt-&gt;seq != UINT64_MAX)
927              {
928                  serve_synchronously = 1;
929                  serve_history = 1;
930              } else if (s-&gt;length) {
931                  streamID maxid, *last = &amp;groups[i]-&gt;last_id;
932                  streamLastValidID(s, &amp;maxid);
933                  if (streamCompareID(&amp;maxid, last) &gt; 0) {
934                      serve_synchronously = 1;
935                      *gt = *last;
936                  }
937              }
938          } else if (s-&gt;length) {
939              streamID maxid;
940              streamLastValidID(s, &amp;maxid);
941              if (streamCompareID(&amp;maxid, gt) &gt; 0) {
942                  serve_synchronously = 1;
943              }
944          }
945          if (serve_synchronously) {
946              arraylen++;
947              if (arraylen == 1) arraylen_ptr = addDeferredMultiBulkLength(c);
948              streamID start = *gt;
949              streamIncrID(&amp;start);
950              addReplyMultiBulkLen(c,2);
951              addReplyBulk(c,c-&gt;argv[streams_arg+i]);
952              streamConsumer *consumer = NULL;
953              if (groups) consumer = streamLookupConsumer(groups[i],
954                                                          consumername-&gt;ptr,
955                                                          SLC_NONE);
956              streamPropInfo spi = {c-&gt;argv[i+streams_arg],groupname};
957              int flags = 0;
958              if (noack) flags |= STREAM_RWR_NOACK;
959              if (serve_history) flags |= STREAM_RWR_HISTORY;
960              streamReplyWithRange(c,s,&amp;start,NULL,count,0,
961                                   groups ? groups[i] : NULL,
962                                   consumer, flags, &amp;spi);
963              if (groups) server.dirty++;
964          }
965      }
966      if (arraylen) {
967          setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
968          goto cleanup;
969      }
970      if (timeout != -1) {
971          if (c-&gt;flags &amp; CLIENT_MULTI) {
972              addReply(c,shared.nullmultibulk);
973              goto cleanup;
974          }
975          blockForKeys(c, BLOCKED_STREAM, c-&gt;argv+streams_arg, streams_count,
976                       timeout, NULL, ids);
977          c-&gt;bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;
978          if (groupname) {
979              incrRefCount(groupname);
980              incrRefCount(consumername);
981              c-&gt;bpop.xread_group = groupname;
982              c-&gt;bpop.xread_consumer = consumername;
983              c-&gt;bpop.xread_group_noack = noack;
984          } else {
985              c-&gt;bpop.xread_group = NULL;
986              c-&gt;bpop.xread_consumer = NULL;
987          }
988          goto cleanup;
989      }
990      addReply(c,shared.nullmultibulk);
991  cleanup: &amp;bsol;* Cleanup. */
992      preventCommandPropagation(c);
993      if (ids != static_ids) zfree(ids);
994      zfree(groups);
995  }
996  streamNACK *streamCreateNACK(streamConsumer *consumer) {
997      streamNACK *nack = zmalloc(sizeof(*nack));
998      nack-&gt;delivery_time = mstime();
999      nack-&gt;delivery_count = 1;
1000      nack-&gt;consumer = consumer;
1001      return nack;
1002  }
1003  void streamFreeNACK(streamNACK *na) {
1004      zfree(na);
1005  }
1006  void streamFreeConsumer(streamConsumer *sc) {
1007      raxFree(sc-&gt;pel); &amp;bsol;* No value free callback: the PEL entries are shared
1008                           between the consumer and the main stream PEL. */
1009      sdsfree(sc-&gt;name);
1010      zfree(sc);
1011  }
1012  streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {
1013      if (s-&gt;cgroups == NULL) s-&gt;cgroups = raxNew();
1014      if (raxFind(s-&gt;cgroups,(unsigned char*)name,namelen) != raxNotFound)
1015          return NULL;
1016      streamCG *cg = zmalloc(sizeof(*cg));
1017      cg-&gt;pel = raxNew();
1018      cg-&gt;consumers = raxNew();
1019      cg-&gt;last_id = *id;
1020      raxInsert(s-&gt;cgroups,(unsigned char*)name,namelen,cg,NULL);
1021      return cg;
1022  }
1023  void streamFreeCG(streamCG *cg) {
1024      raxFreeWithCallback(cg-&gt;pel,(void(*)(void*))streamFreeNACK);
1025      raxFreeWithCallback(cg-&gt;consumers,(void(*)(void*))streamFreeConsumer);
1026      zfree(cg);
1027  }
1028  streamCG *streamLookupCG(stream *s, sds groupname) {
1029      if (s-&gt;cgroups == NULL) return NULL;
1030      streamCG *cg = raxFind(s-&gt;cgroups,(unsigned char*)groupname,
1031                             sdslen(groupname));
1032      return (cg == raxNotFound) ? NULL : cg;
1033  }
1034  streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags) {
1035      int create = !(flags &amp; SLC_NOCREAT);
1036      int refresh = !(flags &amp; SLC_NOREFRESH);
1037      streamConsumer *consumer = raxFind(cg-&gt;consumers,(unsigned char*)name,
1038                                 sdslen(name));
1039      if (consumer == raxNotFound) {
1040          if (!create) return NULL;
1041          consumer = zmalloc(sizeof(*consumer));
1042          consumer-&gt;name = sdsdup(name);
1043          consumer-&gt;pel = raxNew();
1044          raxInsert(cg-&gt;consumers,(unsigned char*)name,sdslen(name),
1045                    consumer,NULL);
1046      }
1047      if (refresh) consumer-&gt;seen_time = mstime();
1048      return consumer;
1049  }
1050  uint64_t streamDelConsumer(streamCG *cg, sds name) {
1051      streamConsumer *consumer =
1052          streamLookupConsumer(cg,name,SLC_NOCREAT|SLC_NOREFRESH);
1053      if (consumer == NULL) return 0;
1054      uint64_t retval = raxSize(consumer-&gt;pel);
1055      raxIterator ri;
1056      raxStart(&amp;ri,consumer-&gt;pel);
1057      raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
1058      while(raxNext(&amp;ri)) {
1059          streamNACK *nack = ri.data;
1060          raxRemove(cg-&gt;pel,ri.key,ri.key_len,NULL);
1061          streamFreeNACK(nack);
1062      }
1063      raxStop(&amp;ri);
1064      raxRemove(cg-&gt;consumers,(unsigned char*)name,sdslen(name),NULL);
1065      streamFreeConsumer(consumer);
1066      return retval;
1067  }
1068  void xgroupCommand(client *c) {
1069      const char *help[] = {
1070  &quot;CREATE      &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt; [opt] -- Create a new consumer group.&quot;,
1071  &quot;            option MKSTREAM: create the empty stream if it does not exist.&quot;,
1072  &quot;SETID       &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt;  -- Set the current group ID.&quot;,
1073  &quot;DESTROY     &lt;key&gt; &lt;groupname&gt;            -- Remove the specified group.&quot;,
1074  &quot;DELCONSUMER &lt;key&gt; &lt;groupname&gt; &lt;consumer&gt; -- Remove the specified consumer.&quot;,
1075  &quot;HELP                                     -- Prints this help.&quot;,
1076  NULL
1077      };
1078      stream *s = NULL;
1079      sds grpname = NULL;
1080      streamCG *cg = NULL;
1081      char *opt = c-&gt;argv[1]-&gt;ptr; &amp;bsol;* Subcommand name. */
1082      int mkstream = 0;
1083      robj *o;
1084      if (c-&gt;argc == 6 &amp;&amp; !strcasecmp(opt,&quot;CREATE&quot;)) {
1085          if (strcasecmp(c-&gt;argv[5]-&gt;ptr,&quot;MKSTREAM&quot;)) {
1086              addReplySubcommandSyntaxError(c);
1087              return;
1088          }
1089          mkstream = 1;
1090          grpname = c-&gt;argv[3]-&gt;ptr;
1091      }
1092      if (c-&gt;argc &gt;= 4) {
1093          o = lookupKeyWrite(c-&gt;db,c-&gt;argv[2]);
1094          if (o) {
1095              if (checkType(c,o,OBJ_STREAM)) return;
1096              s = o-&gt;ptr;
1097          }
1098          grpname = c-&gt;argv[3]-&gt;ptr;
1099      }
1100      if (c-&gt;argc &gt;= 4 &amp;&amp; !mkstream) {
1101          if (s == NULL) {
1102              addReplyError(c,
1103                  &quot;The XGROUP subcommand requires the key to exist. &quot;
1104                  &quot;Note that for CREATE you may want to use the MKSTREAM &quot;
1105                  &quot;option to create an empty stream automatically.&quot;);
1106              return;
1107          }
1108          if ((cg = streamLookupCG(s,grpname)) == NULL &amp;&amp;
1109              (!strcasecmp(opt,&quot;SETID&quot;) ||
1110               !strcasecmp(opt,&quot;DELCONSUMER&quot;)))
1111          {
1112              addReplyErrorFormat(c, &quot;-NOGROUP No such consumer group &#x27;%s&#x27; &quot;
1113                                     &quot;for key name &#x27;%s&#x27;&quot;,
1114                                     (char*)grpname, (char*)c-&gt;argv[2]-&gt;ptr);
1115              return;
1116          }
1117      }
1118      if (!strcasecmp(opt,&quot;CREATE&quot;) &amp;&amp; (c-&gt;argc == 5 || c-&gt;argc == 6)) {
1119          streamID id;
1120          if (!strcmp(c-&gt;argv[4]-&gt;ptr,&quot;$&quot;)) {
1121              if (s) {
1122                  id = s-&gt;last_id;
1123              } else {
1124                  id.ms = 0;
1125                  id.seq = 0;
1126              }
1127          } else if (streamParseStrictIDOrReply(c,c-&gt;argv[4],&amp;id,0) != C_OK) {
1128              return;
1129          }
1130          if (s == NULL) {
1131              serverAssert(mkstream);
1132              o = createStreamObject();
1133              dbAdd(c-&gt;db,c-&gt;argv[2],o);
1134              s = o-&gt;ptr;
1135          }
1136          streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&amp;id);
1137          if (cg) {
1138              addReply(c,shared.ok);
1139              server.dirty++;
1140              notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xgroup-create&quot;,
1141                                  c-&gt;argv[2],c-&gt;db-&gt;id);
1142          } else {
1143              addReplySds(c,
1144                  sdsnew(&quot;-BUSYGROUP Consumer Group name already exists\r\n&quot;));
1145          }
1146      } else if (!strcasecmp(opt,&quot;SETID&quot;) &amp;&amp; c-&gt;argc == 5) {
1147          streamID id;
1148          if (!strcmp(c-&gt;argv[4]-&gt;ptr,&quot;$&quot;)) {
1149              id = s-&gt;last_id;
1150          } else if (streamParseIDOrReply(c,c-&gt;argv[4],&amp;id,0) != C_OK) {
1151              return;
1152          }
1153          cg-&gt;last_id = id;
1154          addReply(c,shared.ok);
1155          server.dirty++;
1156          notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xgroup-setid&quot;,c-&gt;argv[2],c-&gt;db-&gt;id);
1157      } else if (!strcasecmp(opt,&quot;DESTROY&quot;) &amp;&amp; c-&gt;argc == 4) {
1158          if (cg) {
1159              raxRemove(s-&gt;cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
1160              streamFreeCG(cg);
1161              addReply(c,shared.cone);
1162              server.dirty++;
1163              notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xgroup-destroy&quot;,
1164                                  c-&gt;argv[2],c-&gt;db-&gt;id);
1165          } else {
1166              addReply(c,shared.czero);
1167          }
1168      } else if (!strcasecmp(opt,&quot;DELCONSUMER&quot;) &amp;&amp; c-&gt;argc == 5) {
1169          PORT_LONGLONG pending = streamDelConsumer(cg,c-&gt;argv[4]-&gt;ptr);
1170          addReplyLongLong(c,pending);
1171          server.dirty++;
1172          notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xgroup-delconsumer&quot;,
1173                              c-&gt;argv[2],c-&gt;db-&gt;id);
1174      } else if (!strcasecmp(opt,&quot;HELP&quot;)) {
1175          addReplyHelp(c, help);
1176      } else {
1177          addReplySubcommandSyntaxError(c);
1178      }
1179  }
1180  void xsetidCommand(client *c) {
1181      robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[1],shared.nokeyerr);
1182      if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
1183      stream *s = o-&gt;ptr;
1184      streamID id;
1185      if (streamParseStrictIDOrReply(c,c-&gt;argv[2],&amp;id,0) != C_OK) return;
1186      if (s-&gt;length &gt; 0) {
1187          streamID maxid;
1188          streamLastValidID(s,&amp;maxid);
1189          if (streamCompareID(&amp;id,&amp;maxid) &lt; 0) {
1190              addReplyError(c,&quot;The ID specified in XSETID is smaller than the &quot;
1191                              &quot;target stream top item&quot;);
1192              return;
1193          }
1194      }
1195      s-&gt;last_id = id;
1196      addReply(c,shared.ok);
1197      server.dirty++;
1198      notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xsetid&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
1199  }
1200  void xackCommand(client *c) {
1201      streamCG *group = NULL;
1202      robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[1]);
1203      if (o) {
1204          if (checkType(c,o,OBJ_STREAM)) return; &amp;bsol;* Type error. */
1205          group = streamLookupCG(o-&gt;ptr,c-&gt;argv[2]-&gt;ptr);
1206      }
1207      if (o == NULL || group == NULL) {
1208          addReply(c,shared.czero);
1209          return;
1210      }
1211      int acknowledged = 0;
1212      for (int j = 3; j &lt; c-&gt;argc; j++) {
1213          streamID id;
1214          unsigned char buf[sizeof(streamID)];
1215          if (streamParseStrictIDOrReply(c,c-&gt;argv[j],&amp;id,0) != C_OK) return;
1216          streamEncodeID(buf,&amp;id);
1217          streamNACK *nack = raxFind(group-&gt;pel,buf,sizeof(buf));
1218          if (nack != raxNotFound) {
1219              raxRemove(group-&gt;pel,buf,sizeof(buf),NULL);
1220              raxRemove(nack-&gt;consumer-&gt;pel,buf,sizeof(buf),NULL);
1221              streamFreeNACK(nack);
1222              acknowledged++;
1223              server.dirty++;
1224          }
1225      }
1226      addReplyLongLong(c,acknowledged);
1227  }
1228  void xpendingCommand(client *c) {
1229      int justinfo = c-&gt;argc == 3; &amp;bsol;* Without the range just outputs general
1230                                      informations about the PEL. */
1231      robj *key = c-&gt;argv[1];
1232      robj *groupname = c-&gt;argv[2];
1233      robj *consumername = (c-&gt;argc == 7) ? c-&gt;argv[6] : NULL;
1234      streamID startid, endid;
1235      PORT_LONGLONG count;
1236      if (c-&gt;argc != 3 &amp;&amp; c-&gt;argc != 6 &amp;&amp; c-&gt;argc != 7) {
1237          addReply(c,shared.syntaxerr);
1238          return;
1239      }
1240      if (c-&gt;argc &gt;= 6) {
1241          if (getLongLongFromObjectOrReply(c,c-&gt;argv[5],&amp;count,NULL) == C_ERR)
1242              return;
1243          if (count &lt; 0) count = 0;
1244          if (streamParseIDOrReply(c,c-&gt;argv[3],&amp;startid,0) == C_ERR)
1245              return;
1246          if (streamParseIDOrReply(c,c-&gt;argv[4],&amp;endid,UINT64_MAX) == C_ERR)
1247              return;
1248      }
1249      robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[1]);
1250      streamCG *group;
1251      if (o &amp;&amp; checkType(c,o,OBJ_STREAM)) return;
1252      if (o == NULL ||
1253          (group = streamLookupCG(o-&gt;ptr,groupname-&gt;ptr)) == NULL)
1254      {
1255          addReplyErrorFormat(c, &quot;-NOGROUP No such key &#x27;%s&#x27; or consumer &quot;
1256                                 &quot;group &#x27;%s&#x27;&quot;,
1257                                 (char*)key-&gt;ptr,(char*)groupname-&gt;ptr);
1258          return;
1259      }
1260      if (justinfo) {
1261          addReplyMultiBulkLen(c,4);
1262          addReplyLongLong(c,raxSize(group-&gt;pel));
1263          if (raxSize(group-&gt;pel) == 0) {
1264              addReply(c,shared.nullbulk); &amp;bsol;* Start. */
1265              addReply(c,shared.nullbulk); &amp;bsol;* End. */
1266              addReply(c,shared.nullmultibulk); &amp;bsol;* Clients. */
1267          } else {
1268              raxIterator ri;
1269              raxStart(&amp;ri,group-&gt;pel);
1270              raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
1271              raxNext(&amp;ri);
1272              streamDecodeID(ri.key,&amp;startid);
1273              addReplyStreamID(c,&amp;startid);
1274              raxSeek(&amp;ri,&quot;$&quot;,NULL,0);
1275              raxNext(&amp;ri);
1276              streamDecodeID(ri.key,&amp;endid);
1277              addReplyStreamID(c,&amp;endid);
1278              raxStop(&amp;ri);
1279              raxStart(&amp;ri,group-&gt;consumers);
1280              raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
1281              void *arraylen_ptr = addDeferredMultiBulkLength(c);
1282              size_t arraylen = 0;
1283              while(raxNext(&amp;ri)) {
1284                  streamConsumer *consumer = ri.data;
1285                  if (raxSize(consumer-&gt;pel) == 0) continue;
1286                  addReplyMultiBulkLen(c,2);
1287                  addReplyBulkCBuffer(c,ri.key,ri.key_len);
1288                  addReplyBulkLongLong(c,raxSize(consumer-&gt;pel));
1289                  arraylen++;
1290              }
1291              setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
1292              raxStop(&amp;ri);
1293          }
1294      }
1295      else {
1296          streamConsumer *consumer = NULL;
1297          if (consumername) {
1298              consumer = streamLookupConsumer(group,
1299                                              consumername-&gt;ptr,
1300                                              SLC_NOCREAT|SLC_NOREFRESH);
1301              if (consumer == NULL) {
1302                  addReplyMultiBulkLen(c,0);
1303                  return;
1304              }
1305          }
1306          rax *pel = consumer ? consumer-&gt;pel : group-&gt;pel;
1307          unsigned char startkey[sizeof(streamID)];
1308          unsigned char endkey[sizeof(streamID)];
1309          raxIterator ri;
1310          mstime_t now = mstime();
1311          streamEncodeID(startkey,&amp;startid);
1312          streamEncodeID(endkey,&amp;endid);
1313          raxStart(&amp;ri,pel);
1314          raxSeek(&amp;ri,&quot;&gt;=&quot;,startkey,sizeof(startkey));
1315          void *arraylen_ptr = addDeferredMultiBulkLength(c);
1316          size_t arraylen = 0;
1317          while(count &amp;&amp; raxNext(&amp;ri) &amp;&amp; memcmp(ri.key,endkey,ri.key_len) &lt;= 0) {
1318              streamNACK *nack = ri.data;
1319              arraylen++;
1320              count--;
1321              addReplyMultiBulkLen(c,4);
1322              streamID id;
1323              streamDecodeID(ri.key,&amp;id);
1324              addReplyStreamID(c,&amp;id);
1325              addReplyBulkCBuffer(c,nack-&gt;consumer-&gt;name,
1326                                  sdslen(nack-&gt;consumer-&gt;name));
1327              mstime_t elapsed = now - nack-&gt;delivery_time;
1328              if (elapsed &lt; 0) elapsed = 0;
1329              addReplyLongLong(c,elapsed);
1330              addReplyLongLong(c,nack-&gt;delivery_count);
1331          }
1332          raxStop(&amp;ri);
1333          setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
1334      }
1335  }
1336  void xclaimCommand(client *c) {
1337      streamCG *group = NULL;
1338      robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[1]);
1339      PORT_LONGLONG minidle; &amp;bsol;* Minimum idle time argument. */
1340      PORT_LONGLONG retrycount = -1;   &amp;bsol;* -1 means RETRYCOUNT option not given. */
1341      mstime_t deliverytime = -1;  &amp;bsol;* -1 means IDLE/TIME options not given. */
1342      int force = 0;
1343      int justid = 0;
1344      if (o) {
1345          if (checkType(c,o,OBJ_STREAM)) return; &amp;bsol;* Type error. */
1346          group = streamLookupCG(o-&gt;ptr,c-&gt;argv[2]-&gt;ptr);
1347      }
1348      if (o == NULL || group == NULL) {
1349          addReplyErrorFormat(c,&quot;-NOGROUP No such key &#x27;%s&#x27; or &quot;
1350                                &quot;consumer group &#x27;%s&#x27;&quot;, (char*)c-&gt;argv[1]-&gt;ptr,
1351                                (char*)c-&gt;argv[2]-&gt;ptr);
1352          return;
1353      }
1354      if (getLongLongFromObjectOrReply(c,c-&gt;argv[4],&amp;minidle,
1355          &quot;Invalid min-idle-time argument for XCLAIM&quot;)
1356          != C_OK) return;
1357      if (minidle &lt; 0) minidle = 0;
1358      int j;
1359      for (j = 5; j &lt; c-&gt;argc; j++) {
1360          streamID id;
1361          if (streamParseStrictIDOrReply(NULL,c-&gt;argv[j],&amp;id,0) != C_OK) break;
1362      }
1363      int last_id_arg = j-1; &amp;bsol;* Next time we iterate the IDs we now the range. */
1364      mstime_t now = mstime();
1365      streamID last_id = {0,0};
1366      int propagate_last_id = 0;
1367      for (; j &lt; c-&gt;argc; j++) {
1368          int moreargs = (c-&gt;argc-1) - j; &amp;bsol;* Number of additional arguments. */
1369          char *opt = c-&gt;argv[j]-&gt;ptr;
1370          if (!strcasecmp(opt,&quot;FORCE&quot;)) {
1371              force = 1;
1372          } else if (!strcasecmp(opt,&quot;JUSTID&quot;)) {
1373              justid = 1;
1374          } else if (!strcasecmp(opt,&quot;IDLE&quot;) &amp;&amp; moreargs) {
1375              j++;
1376              if (getLongLongFromObjectOrReply(c,c-&gt;argv[j],&amp;deliverytime,
1377                  &quot;Invalid IDLE option argument for XCLAIM&quot;)
1378                  != C_OK) return;
1379              deliverytime = now - deliverytime;
1380          } else if (!strcasecmp(opt,&quot;TIME&quot;) &amp;&amp; moreargs) {
1381              j++;
1382              if (getLongLongFromObjectOrReply(c,c-&gt;argv[j],&amp;deliverytime,
1383                  &quot;Invalid TIME option argument for XCLAIM&quot;)
1384                  != C_OK) return;
1385          } else if (!strcasecmp(opt,&quot;RETRYCOUNT&quot;) &amp;&amp; moreargs) {
1386              j++;
1387              if (getLongLongFromObjectOrReply(c,c-&gt;argv[j],&amp;retrycount,
1388                  &quot;Invalid RETRYCOUNT option argument for XCLAIM&quot;)
1389                  != C_OK) return;
1390          } else if (!strcasecmp(opt,&quot;LASTID&quot;) &amp;&amp; moreargs) {
1391              j++;
1392              if (streamParseStrictIDOrReply(c,c-&gt;argv[j],&amp;last_id,0) != C_OK) return;
1393          } else {
1394              addReplyErrorFormat(c,&quot;Unrecognized XCLAIM option &#x27;%s&#x27;&quot;,opt);
1395              return;
1396          }
1397      }
1398      if (streamCompareID(&amp;last_id,&amp;group-&gt;last_id) &gt; 0) {
1399          group-&gt;last_id = last_id;
1400          propagate_last_id = 1;
1401      }
1402      if (deliverytime != -1) {
1403          if (deliverytime &lt; 0 || deliverytime &gt; now) deliverytime = now;
1404      } else {
1405          deliverytime = now;
1406      }
1407      streamConsumer *consumer = NULL;
1408      void *arraylenptr = addDeferredMultiBulkLength(c);
1409      size_t arraylen = 0;
1410      for (int j = 5; j &lt;= last_id_arg; j++) {
1411          streamID id;
1412          unsigned char buf[sizeof(streamID)];
1413          if (streamParseStrictIDOrReply(c,c-&gt;argv[j],&amp;id,0) != C_OK)
1414              serverPanic(&quot;StreamID invalid after check. Should not be possible.&quot;);
1415          streamEncodeID(buf,&amp;id);
1416          streamNACK *nack = raxFind(group-&gt;pel,buf,sizeof(buf));
1417          if (force &amp;&amp; nack == raxNotFound) {
1418              streamIterator myiterator;
1419              streamIteratorStart(&amp;myiterator,o-&gt;ptr,&amp;id,&amp;id,0);
1420              int64_t numfields;
1421              int found = 0;
1422              streamID item_id;
1423              if (streamIteratorGetID(&amp;myiterator,&amp;item_id,&amp;numfields)) found = 1;
1424              streamIteratorStop(&amp;myiterator);
1425              if (!found) continue;
1426              nack = streamCreateNACK(NULL);
1427              raxInsert(group-&gt;pel,buf,sizeof(buf),nack,NULL);
1428          }
1429          if (nack != raxNotFound) {
1430              if (nack-&gt;consumer &amp;&amp; minidle) {
1431                  mstime_t this_idle = now - nack-&gt;delivery_time;
1432                  if (this_idle &lt; minidle) continue;
1433              }
1434              if (nack-&gt;consumer)
1435                  raxRemove(nack-&gt;consumer-&gt;pel,buf,sizeof(buf),NULL);
1436              if (consumer == NULL)
1437                  consumer = streamLookupConsumer(group,c-&gt;argv[3]-&gt;ptr,SLC_NONE);
1438              nack-&gt;consumer = consumer;
1439              nack-&gt;delivery_time = deliverytime;
1440              if (retrycount &gt;= 0) {
1441                  nack-&gt;delivery_count = retrycount;
1442              } else if (!justid) {
1443                  nack-&gt;delivery_count++;
1444              }
1445              raxInsert(consumer-&gt;pel,buf,sizeof(buf),nack,NULL);
1446              if (justid) {
1447                  addReplyStreamID(c,&amp;id);
1448              } else {
1449                  size_t emitted = streamReplyWithRange(c,o-&gt;ptr,&amp;id,&amp;id,1,0,
1450                                      NULL,NULL,STREAM_RWR_RAWENTRIES,NULL);
1451                  if (!emitted) addReply(c,shared.nullbulk);
1452              }
1453              arraylen++;
1454              streamPropagateXCLAIM(c,c-&gt;argv[1],group,c-&gt;argv[2],c-&gt;argv[j],nack);
1455              propagate_last_id = 0; &amp;bsol;* Will be propagated by XCLAIM itself. */
1456              server.dirty++;
1457          }
1458      }
1459      if (propagate_last_id) {
1460          streamPropagateGroupID(c,c-&gt;argv[1],group,c-&gt;argv[2]);
1461          server.dirty++;
1462      }
1463      setDeferredMultiBulkLength(c,arraylenptr,arraylen);
1464      preventCommandPropagation(c);
1465  }
1466  void xdelCommand(client *c) {
1467      robj *o;
1468      if ((o = lookupKeyWriteOrReply(c,c-&gt;argv[1],shared.czero)) == NULL
1469          || checkType(c,o,OBJ_STREAM)) return;
1470      stream *s = o-&gt;ptr;
1471      streamID id;
1472      for (int j = 2; j &lt; c-&gt;argc; j++) {
1473          if (streamParseStrictIDOrReply(c,c-&gt;argv[j],&amp;id,0) != C_OK) return;
1474      }
1475      int deleted = 0;
1476      for (int j = 2; j &lt; c-&gt;argc; j++) {
1477          streamParseStrictIDOrReply(c,c-&gt;argv[j],&amp;id,0); &amp;bsol;* Retval already checked. */
1478          deleted += streamDeleteItem(s,&amp;id);
1479      }
1480      if (deleted) {
1481          signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
1482          notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xdel&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
1483          server.dirty += deleted;
1484      }
1485      addReplyLongLong(c,deleted);
1486  }
1487  #define TRIM_STRATEGY_NONE 0
1488  #define TRIM_STRATEGY_MAXLEN 1
1489  void xtrimCommand(client *c) {
1490      robj *o;
1491      if ((o = lookupKeyWriteOrReply(c,c-&gt;argv[1],shared.czero)) == NULL
1492          || checkType(c,o,OBJ_STREAM)) return;
1493      stream *s = o-&gt;ptr;
1494      int trim_strategy = TRIM_STRATEGY_NONE;
1495      PORT_LONGLONG maxlen = -1;  &amp;bsol;* If left to -1 no trimming is performed. */
1496      int approx_maxlen = 0;  &amp;bsol;* If 1 only delete whole radix tree nodes, so
1497                                 the maxium length is not applied verbatim. */
1498      int maxlen_arg_idx = 0; &amp;bsol;* Index of the count in MAXLEN, for rewriting. */
1499      int i = 2; &amp;bsol;* Start of options. */
1500      for (; i &lt; c-&gt;argc; i++) {
1501          int moreargs = (c-&gt;argc-1) - i; &amp;bsol;* Number of additional arguments. */
1502          char *opt = c-&gt;argv[i]-&gt;ptr;
1503          if (!strcasecmp(opt,&quot;maxlen&quot;) &amp;&amp; moreargs) {
1504              approx_maxlen = 0;
1505              trim_strategy = TRIM_STRATEGY_MAXLEN;
1506              char *next = c-&gt;argv[i+1]-&gt;ptr;
1507              if (moreargs &gt;= 2 &amp;&amp; next[0] == &#x27;~&#x27; &amp;&amp; next[1] == &#x27;\0&#x27;) {
1508                  approx_maxlen = 1;
1509                  i++;
1510              } else if (moreargs &gt;= 2 &amp;&amp; next[0] == &#x27;=&#x27; &amp;&amp; next[1] == &#x27;\0&#x27;) {
1511                  i++;
1512              }
1513              if (getLongLongFromObjectOrReply(c,c-&gt;argv[i+1],&amp;maxlen,NULL)
1514                  != C_OK) return;
1515              if (maxlen &lt; 0) {
1516                  addReplyError(c,&quot;The MAXLEN argument must be &gt;= 0.&quot;);
1517                  return;
1518              }
1519              i++;
1520              maxlen_arg_idx = i;
1521          } else {
1522              addReply(c,shared.syntaxerr);
1523              return;
1524          }
1525      }
1526      int64_t deleted = 0;
1527      if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
1528          deleted = streamTrimByLength(s,maxlen,approx_maxlen);
1529      } else {
1530          addReplyError(c,&quot;XTRIM called without an option to trim the stream&quot;);
1531          return;
1532      }
1533      if (deleted) {
1534          signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
1535          notifyKeyspaceEvent(NOTIFY_STREAM,&quot;xtrim&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
1536          server.dirty += deleted;
1537          if (approx_maxlen) streamRewriteApproxMaxlen(c,s,maxlen_arg_idx);
1538      }
1539      addReplyLongLong(c,deleted);
1540  }
1541  void xinfoCommand(client *c) {
1542      const char *help[] = {
1543  &quot;CONSUMERS &lt;key&gt; &lt;groupname&gt;  -- Show consumer groups of group &lt;groupname&gt;.&quot;,
1544  &quot;GROUPS &lt;key&gt;                 -- Show the stream consumer groups.&quot;,
1545  &quot;STREAM &lt;key&gt;                 -- Show information about the stream.&quot;,
1546  &quot;HELP                         -- Print this help.&quot;,
1547  NULL
1548      };
1549      stream *s = NULL;
1550      char *opt;
1551      robj *key;
1552      if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;HELP&quot;)) {
1553          addReplyHelp(c, help);
1554          return;
1555      } else if (c-&gt;argc &lt; 3) {
1556          addReplyError(c,&quot;syntax error, try &#x27;XINFO HELP&#x27;&quot;);
1557          return;
1558      }
1559      opt = c-&gt;argv[1]-&gt;ptr;
1560      key = c-&gt;argv[2];
1561      robj *o = lookupKeyWriteOrReply(c,key,shared.nokeyerr);
1562      if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
1563      s = o-&gt;ptr;
1564      if (!strcasecmp(opt,&quot;CONSUMERS&quot;) &amp;&amp; c-&gt;argc == 4) {
1565          streamCG *cg = streamLookupCG(s,c-&gt;argv[3]-&gt;ptr);
1566          if (cg == NULL) {
1567              addReplyErrorFormat(c, &quot;-NOGROUP No such consumer group &#x27;%s&#x27; &quot;
1568                                     &quot;for key name &#x27;%s&#x27;&quot;,
1569                                     (char*)c-&gt;argv[3]-&gt;ptr, (char*)key-&gt;ptr);
1570              return;
1571          }
1572          addReplyMultiBulkLen(c,raxSize(cg-&gt;consumers));
1573          raxIterator ri;
1574          raxStart(&amp;ri,cg-&gt;consumers);
1575          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
1576          mstime_t now = mstime();
1577          while(raxNext(&amp;ri)) {
1578              streamConsumer *consumer = ri.data;
1579              mstime_t idle = now - consumer-&gt;seen_time;
1580              if (idle &lt; 0) idle = 0;
1581              addReplyMultiBulkLen(c,6);
1582              addReplyBulkCString(c,&quot;name&quot;);
1583              addReplyBulkCBuffer(c,consumer-&gt;name,sdslen(consumer-&gt;name));
1584              addReplyBulkCString(c,&quot;pending&quot;);
1585              addReplyLongLong(c,raxSize(consumer-&gt;pel));
1586              addReplyBulkCString(c,&quot;idle&quot;);
1587              addReplyLongLong(c,idle);
1588          }
1589          raxStop(&amp;ri);
1590      } else if (!strcasecmp(opt,&quot;GROUPS&quot;) &amp;&amp; c-&gt;argc == 3) {
1591          if (s-&gt;cgroups == NULL) {
1592              addReplyMultiBulkLen(c,0);
1593              return;
1594          }
1595          addReplyMultiBulkLen(c,raxSize(s-&gt;cgroups));
1596          raxIterator ri;
1597          raxStart(&amp;ri,s-&gt;cgroups);
1598          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
1599          while(raxNext(&amp;ri)) {
1600              streamCG *cg = ri.data;
1601              addReplyMultiBulkLen(c,8);
1602              addReplyBulkCString(c,&quot;name&quot;);
1603              addReplyBulkCBuffer(c,ri.key,ri.key_len);
1604              addReplyBulkCString(c,&quot;consumers&quot;);
1605              addReplyLongLong(c,raxSize(cg-&gt;consumers));
1606              addReplyBulkCString(c,&quot;pending&quot;);
1607              addReplyLongLong(c,raxSize(cg-&gt;pel));
1608              addReplyBulkCString(c,&quot;last-delivered-id&quot;);
1609              addReplyStreamID(c,&amp;cg-&gt;last_id);
1610          }
1611          raxStop(&amp;ri);
1612      } else if (!strcasecmp(opt,&quot;STREAM&quot;) &amp;&amp; c-&gt;argc == 3) {
1613          addReplyMultiBulkLen(c,14);
1614          addReplyBulkCString(c,&quot;length&quot;);
1615          addReplyLongLong(c,s-&gt;length);
1616          addReplyBulkCString(c,&quot;radix-tree-keys&quot;);
1617          addReplyLongLong(c,raxSize(s-&gt;rax));
1618          addReplyBulkCString(c,&quot;radix-tree-nodes&quot;);
1619          addReplyLongLong(c,s-&gt;rax-&gt;numnodes);
1620          addReplyBulkCString(c,&quot;groups&quot;);
1621          addReplyLongLong(c,s-&gt;cgroups ? raxSize(s-&gt;cgroups) : 0);
1622          addReplyBulkCString(c,&quot;last-generated-id&quot;);
1623          addReplyStreamID(c,&amp;s-&gt;last_id);
1624          int count;
1625          streamID start, end;
1626          start.ms = start.seq = 0;
1627          end.ms = end.seq = UINT64_MAX;
1628          addReplyBulkCString(c,&quot;first-entry&quot;);
1629          count = streamReplyWithRange(c,s,&amp;start,&amp;end,1,0,NULL,NULL,
1630                                       STREAM_RWR_RAWENTRIES,NULL);
1631          if (!count) addReply(c,shared.nullbulk);
1632          addReplyBulkCString(c,&quot;last-entry&quot;);
1633          count = streamReplyWithRange(c,s,&amp;start,&amp;end,1,1,NULL,NULL,
1634                                       STREAM_RWR_RAWENTRIES,NULL);
1635          if (!count) addReply(c,shared.nullbulk);
1636      } else {
1637          addReplySubcommandSyntaxError(c);
1638      }
1639  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_stream.c</div>
                </div>
                <div class="column column_space"><pre><code>211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
</pre></code></div>
                <div class="column column_space"><pre><code>908              ids[id_idx].ms = UINT64_MAX;
909              ids[id_idx].seq = UINT64_MAX;
910              continue;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    