<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imgssapi.c &amp; imtcp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imgssapi.c &amp; imtcp.c
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imgssapi.c (2.5477707%)<th>imtcp.c (1.0535557%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(787-819)<td><a href="#" name="0">(1081-1126)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imgssapi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;sys/types.h&gt;
12 #include &lt;sys/socket.h&gt;
13 #if HAVE_FCNTL_H
14 #include &lt;fcntl.h&gt;
15 #endif
16 #include &lt;gssapi/gssapi.h&gt;
17 #include "rsyslog.h"
18 #include "dirty.h"
19 #include "cfsysline.h"
20 #include "module-template.h"
21 #include "unicode-helper.h"
22 #include "net.h"
23 #include "srUtils.h"
24 #include "gss-misc.h"
25 #include "tcpsrv.h"
26 #include "tcps_sess.h"
27 #include "errmsg.h"
28 #include "netstrm.h"
29 #include "glbl.h"
30 #include "debug.h"
31 #include "unlimited_select.h"
32 #include "rsconf.h"
33 MODULE_TYPE_INPUT
34 MODULE_TYPE_NOKEEP
35 #define ALLOWEDMETHOD_GSS 2
36 #define ALLOWEDMETHOD_TCP 1
37 static rsRetVal addGSSListener(void __attribute__((unused)) *pVal, uchar *pNewVal);
38 static rsRetVal actGSSListener(uchar *port);
39 static int TCPSessGSSInit(void);
40 static void TCPSessGSSClose(tcps_sess_t* pSess);
41 static rsRetVal TCPSessGSSRecv(tcps_sess_t *pSess, void *buf, size_t buf_len, ssize_t *);
42 static rsRetVal onSessAccept(tcpsrv_t *pThis, tcps_sess_t *ppSess);
43 static rsRetVal OnSessAcceptGSS(tcpsrv_t *pThis, tcps_sess_t *ppSess);
44 DEF_IMOD_STATIC_DATA
45 DEFobjCurrIf(tcpsrv)
46 DEFobjCurrIf(tcps_sess)
47 DEFobjCurrIf(gssutil)
48 DEFobjCurrIf(netstrm)
49 DEFobjCurrIf(net)
50 DEFobjCurrIf(glbl)
51 DEFobjCurrIf(prop)
52 static tcpsrv_t *pOurTcpsrv = NULL;  static gss_cred_id_t gss_server_creds = GSS_C_NO_CREDENTIAL;
53 static uchar *srvPort;
54 typedef struct gsssrv_s {
55 	char allowedMethods;
56 } gsssrv_t;
57 typedef struct gss_sess_s {
58 	OM_uint32 gss_flags;
59 	gss_ctx_id_t gss_context;
60 	char allowedMethods;
61 } gss_sess_t;
62 struct modConfData_s {
63 	EMPTY_STRUCT;
64 };
65 static uchar *pszLstnPortFileName = NULL;	static int iTCPSessMax = 200; static char *gss_listen_service_name = NULL;
66 static int bPermitPlainTcp = 0; static int bKeepAlive = 0; 
67 static rsRetVal OnSessConstructFinalize(void *ppUsr)
68 {
69 	DEFiRet;
70 	gss_sess_t **ppGSess = (gss_sess_t**) ppUsr;
71 	gss_sess_t *pGSess;
72 	assert(ppGSess != NULL);
73 	if((pGSess = calloc(1, sizeof(gss_sess_t))) == NULL)
74 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
75 	pGSess-&gt;gss_flags = 0;
76 	pGSess-&gt;gss_context = GSS_C_NO_CONTEXT;
77 	pGSess-&gt;allowedMethods = 0;
78 	*ppGSess = pGSess;
79 finalize_it:
80 	RETiRet;
81 }
82 static rsRetVal
83 OnSessDestruct(void *ppUsr)
84 {
85 	DEFiRet;
86 	gss_sess_t **ppGSess = (gss_sess_t**) ppUsr;
87 	assert(ppGSess != NULL);
88 	if(*ppGSess == NULL)
89 		FINALIZE;
90 	if((*ppGSess)-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS) {
91 		OM_uint32 maj_stat, min_stat;
92 		maj_stat = gss_delete_sec_context(&amp;min_stat, &amp;(*ppGSess)-&gt;gss_context, GSS_C_NO_BUFFER);
93 		if (maj_stat != GSS_S_COMPLETE)
94 			gssutil.display_status((char*)"deleting context", maj_stat, min_stat);
95 	}
96 	free(*ppGSess);
97 	*ppGSess = NULL;
98 finalize_it:
99 	RETiRet;
100 }
101 static int
102 isPermittedHost(struct sockaddr *addr, char *fromHostFQDN, void *pUsrSrv, void*pUsrSess)
103 {
104 	gsssrv_t *pGSrv;
105 	gss_sess_t *pGSess;
106 	char allowedMethods = 0;
107 	assert(pUsrSrv != NULL);
108 	pGSrv = (gsssrv_t*) pUsrSrv;
109 	pGSess = (gss_sess_t*) pUsrSess;
110 	if((pGSrv-&gt;allowedMethods &amp; ALLOWEDMETHOD_TCP) &amp;&amp;
111 	   net.isAllowedSender2((uchar*)"TCP", addr, (char*)fromHostFQDN, 1))
112 		allowedMethods |= ALLOWEDMETHOD_TCP;
113 	if((pGSrv-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS) &amp;&amp;
114 	   net.isAllowedSender2((uchar*)"GSS", addr, (char*)fromHostFQDN, 1))
115 		allowedMethods |= ALLOWEDMETHOD_GSS;
116 	if(allowedMethods &amp;&amp; pGSess != NULL)
117 		pGSess-&gt;allowedMethods = allowedMethods;
118 	return allowedMethods;
119 }
120 static rsRetVal
121 onSessAccept(tcpsrv_t *pThis, tcps_sess_t *pSess)
122 {
123 	DEFiRet;
124 	gsssrv_t *pGSrv;
125 	pGSrv = (gsssrv_t*) pThis-&gt;pUsr;
126 	if(pGSrv-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS) {
127 		iRet = OnSessAcceptGSS(pThis, pSess);
128 	}
129 	RETiRet;
130 }
131 static rsRetVal
132 onRegularClose(tcps_sess_t *pSess)
133 {
134 	DEFiRet;
135 	gss_sess_t *pGSess;
136 	assert(pSess != NULL);
137 	assert(pSess-&gt;pUsr != NULL);
138 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
139 	if(pGSess-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS)
140 		TCPSessGSSClose(pSess);
141 	else {
142 		tcps_sess.PrepareClose(pSess);
143 		tcps_sess.Close(pSess);
144 	}
145 	RETiRet;
146 }
147 static rsRetVal
148 onErrClose(tcps_sess_t *pSess)
149 {
150 	DEFiRet;
151 	gss_sess_t *pGSess;
152 	assert(pSess != NULL);
153 	assert(pSess-&gt;pUsr != NULL);
154 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
155 	if(pGSess-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS)
156 		TCPSessGSSClose(pSess);
157 	else
158 		tcps_sess.Close(pSess);
159 	RETiRet;
160 }
161 static rsRetVal
162 doOpenLstnSocks(tcpsrv_t *pSrv)
163 {
164 	gsssrv_t *pGSrv;
165 	DEFiRet;
166 	ISOBJ_TYPE_assert(pSrv, tcpsrv);
167 	pGSrv = pSrv-&gt;pUsr;
168 	assert(pGSrv != NULL);
169 	if(pGSrv-&gt;allowedMethods) {
170 		if(pGSrv-&gt;allowedMethods &amp; ALLOWEDMETHOD_GSS) {
171 			if(TCPSessGSSInit()) {
172 				LogError(0, NO_ERRCODE, "GSS-API initialization failed\n");
173 				pGSrv-&gt;allowedMethods &amp;= ~(ALLOWEDMETHOD_GSS);
174 			}
175 		}
176 		if(pGSrv-&gt;allowedMethods) {
177 			CHKiRet(tcpsrv.create_tcp_socket(pSrv));
178 		} else {
179 			ABORT_FINALIZE(RS_RET_GSS_ERR);
180 		}
181 	}
182 finalize_it:
183 	RETiRet;
184 }
185 static rsRetVal
186 doRcvData(tcps_sess_t *pSess, char *buf, size_t lenBuf, ssize_t *piLenRcvd, int *const oserr)
187 {
188 	DEFiRet;
189 	int allowedMethods;
190 	gss_sess_t *pGSess;
191 	assert(pSess != NULL);
192 	assert(pSess-&gt;pUsr != NULL);
193 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
194 	assert(piLenRcvd != NULL);
195 	allowedMethods = pGSess-&gt;allowedMethods;
196 	if(allowedMethods &amp; ALLOWEDMETHOD_GSS) {
197 		CHKiRet(TCPSessGSSRecv(pSess, buf, lenBuf, piLenRcvd));
198 	} else {
199 		*piLenRcvd = lenBuf;
200 		CHKiRet(netstrm.Rcv(pSess-&gt;pStrm, (uchar*) buf, piLenRcvd, oserr));
201 	}
202 finalize_it:
203 	RETiRet;
204 }
205 static rsRetVal
206 addGSSListener(void __attribute__((unused)) *pVal, uchar *pNewVal)
207 {
208 	DEFiRet;
209 	if((ustrcmp(pNewVal, UCHAR_CONSTANT("0")) == 0 &amp;&amp; pszLstnPortFileName == NULL)
210 			|| ustrcmp(pNewVal, UCHAR_CONSTANT("0")) &lt; 0) {
211 		CHKmalloc(srvPort = (uchar*)strdup("514"));
212 	} else {
213 		srvPort = pNewVal;
214 	}
215 finalize_it:
216 	RETiRet;
217 }
218 static rsRetVal
219 actGSSListener(uchar *port)
220 {
221 	DEFiRet;
222 	tcpLstnParams_t *cnf_params = NULL;
223 	gsssrv_t *pGSrv = NULL;
224 	assert(pOurTcpsrv == NULL);
225 	CHKmalloc(cnf_params = (tcpLstnParams_t*) calloc(1, sizeof(tcpLstnParams_t)));
226 	if((pGSrv = calloc(1, sizeof(gsssrv_t))) == NULL)
227 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
228 	pGSrv-&gt;allowedMethods = ALLOWEDMETHOD_GSS;
229 	if(bPermitPlainTcp)
230 		pGSrv-&gt;allowedMethods |= ALLOWEDMETHOD_TCP;
231 	CHKiRet(tcpsrv.Construct(&amp;pOurTcpsrv));
232 	CHKiRet(tcpsrv.SetUsrP(pOurTcpsrv, pGSrv));
233 	CHKiRet(tcpsrv.SetCBOnSessConstructFinalize(pOurTcpsrv, OnSessConstructFinalize));
234 	CHKiRet(tcpsrv.SetCBOnSessDestruct(pOurTcpsrv, OnSessDestruct));
235 	CHKiRet(tcpsrv.SetCBIsPermittedHost(pOurTcpsrv, isPermittedHost));
236 	CHKiRet(tcpsrv.SetCBRcvData(pOurTcpsrv, doRcvData));
237 	CHKiRet(tcpsrv.SetCBOpenLstnSocks(pOurTcpsrv, doOpenLstnSocks));
238 	CHKiRet(tcpsrv.SetCBOnSessAccept(pOurTcpsrv, onSessAccept));
239 	CHKiRet(tcpsrv.SetCBOnRegularClose(pOurTcpsrv, onRegularClose));
240 	CHKiRet(tcpsrv.SetCBOnErrClose(pOurTcpsrv, onErrClose));
241 	CHKiRet(tcpsrv.SetInputName(pOurTcpsrv, cnf_params, UCHAR_CONSTANT("imgssapi")));
242 	CHKiRet(tcpsrv.SetKeepAlive(pOurTcpsrv, bKeepAlive));
243 	CHKiRet(tcpsrv.SetOrigin(pOurTcpsrv, UCHAR_CONSTANT("imgssapi")));
244 	cnf_params-&gt;pszPort = port;
245 	cnf_params-&gt;bSuppOctetFram = 1;
246 	tcpsrv.configureTCPListen(pOurTcpsrv, cnf_params);
247 	CHKiRet(tcpsrv.ConstructFinalize(pOurTcpsrv));
248 	cnf_params = NULL;
249 finalize_it:
250 	if(iRet != RS_RET_OK) {
251 		LogError(0, NO_ERRCODE, "error %d trying to add listener", iRet);
252 		if(pOurTcpsrv != NULL)
253 			tcpsrv.Destruct(&amp;pOurTcpsrv);
254 		free(pGSrv);
255 	}
256 	free(cnf_params);
257 	RETiRet;
258 }
259 static int TCPSessGSSInit(void)
260 {
261 	gss_buffer_desc name_buf;
262 	gss_name_t server_name;
263 	OM_uint32 maj_stat, min_stat;
264 	if (gss_server_creds != GSS_C_NO_CREDENTIAL)
265 		return 0;
266 	name_buf.value = (gss_listen_service_name == NULL) ? (char*)"host" : gss_listen_service_name;
267 	name_buf.length = strlen(name_buf.value) + 1;
268 	maj_stat = gss_import_name(&amp;min_stat, &amp;name_buf, GSS_C_NT_HOSTBASED_SERVICE, &amp;server_name);
269 	if (maj_stat != GSS_S_COMPLETE) {
270 		gssutil.display_status((char*)"importing name", maj_stat, min_stat);
271 		return -1;
272 	}
273 	maj_stat = gss_acquire_cred(&amp;min_stat, server_name, 0,
274 				    GSS_C_NULL_OID_SET, GSS_C_ACCEPT,
275 				    &amp;gss_server_creds, NULL, NULL);
276 	if (maj_stat != GSS_S_COMPLETE) {
277 		gssutil.display_status((char*)"acquiring credentials", maj_stat, min_stat);
278 		return -1;
279 	}
280 	gss_release_name(&amp;min_stat, &amp;server_name);
281 	dbgprintf("GSS-API initialized\n");
282 	return 0;
283 }
284 static rsRetVal
285 OnSessAcceptGSS(tcpsrv_t *pThis, tcps_sess_t *pSess)
286 {
287 	DEFiRet;
288 	gss_buffer_desc send_tok, recv_tok;
289 	gss_name_t client;
290 	OM_uint32 maj_stat, min_stat, acc_sec_min_stat;
291 	gss_ctx_id_t *context;
292 	OM_uint32 *sess_flags;
293 	int fdSess;
294 	char allowedMethods;
295 	gsssrv_t *pGSrv;
296 	gss_sess_t *pGSess;
297 	uchar *pszPeer = NULL;
298 	int lenPeer = 0;
299 	char *buf = NULL;
300 	assert(pSess != NULL);
301 	pGSrv = (gsssrv_t*) pThis-&gt;pUsr;
302 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
303 	allowedMethods = pGSrv-&gt;allowedMethods;
304 	if(allowedMethods &amp; ALLOWEDMETHOD_GSS) {
305 		int ret = 0;
306 		const size_t bufsize = glbl.GetMaxLine(runConf);
307 		CHKmalloc(buf = (char*) malloc(bufsize + 1));
308 		prop.GetString(pSess-&gt;fromHostIP, &amp;pszPeer, &amp;lenPeer);
309 		dbgprintf("GSS-API Trying to accept TCP session %p from %s\n", pSess, (char *)pszPeer);
310 		CHKiRet(netstrm.GetSock(pSess-&gt;pStrm, &amp;fdSess)); 		if (allowedMethods &amp; ALLOWEDMETHOD_TCP) {
311 			int len;
312 			struct timeval tv;
313 #ifdef USE_UNLIMITED_SELECT
314 			fd_set *pFds = malloc(glbl.GetFdSetSize());
315 #else
316 			fd_set fds;
317 			fd_set *pFds = &amp;fds;
318 #endif
319 			do {
320 				FD_ZERO(pFds);
321 				FD_SET(fdSess, pFds);
322 				tv.tv_sec = 1;
323 				tv.tv_usec = 0;
324 				ret = select(fdSess + 1, pFds, NULL, NULL, &amp;tv);
325 			} while (ret &lt; 0 &amp;&amp; errno == EINTR);
326 			if (ret &lt; 0) {
327 				LogError(0, RS_RET_ERR, "TCP session %p from %s will be "
328 						"closed, error ignored\n", pSess, (char *)pszPeer);
329 				ABORT_FINALIZE(RS_RET_ERR); 			} else if (ret == 0) {
330 				dbgprintf("GSS-API Reverting to plain TCP\n");
331 				pGSess-&gt;allowedMethods = ALLOWEDMETHOD_TCP;
332 				ABORT_FINALIZE(RS_RET_OK); 			}
333 			do {
334 				ret = recv(fdSess, buf, bufsize, MSG_PEEK);
335 			} while (ret &lt; 0 &amp;&amp; errno == EINTR);
336 			if (ret &lt;= 0) {
337 				if (ret == 0) {
338 					dbgprintf("GSS-API Connection closed by peer %s\n", (char *)pszPeer);
339 				} else {
340 					LogError(0, RS_RET_ERR, "TCP(GSS) session %p from %s will be closed, "
341 					"error ignored\n", pSess, (char *)pszPeer);
342 				}
343 				ABORT_FINALIZE(RS_RET_ERR); 			}
344 			if (ret &lt; 4) {
345 				dbgprintf("GSS-API Reverting to plain TCP from %s\n", (char *)pszPeer);
346 				pGSess-&gt;allowedMethods = ALLOWEDMETHOD_TCP;
347 				ABORT_FINALIZE(RS_RET_OK); 			} else if (ret == 4) {
348 				srSleep(1, 0);
349 				do {
350 					ret = recv(fdSess, buf, bufsize, MSG_PEEK);
351 				} while (ret &lt; 0 &amp;&amp; errno == EINTR);
352 				if (ret &lt;= 0) {
353 					if (ret == 0) {
354 						dbgprintf("GSS-API Connection closed by peer %s\n", (char *)pszPeer);
355 					} else {
356 						LogError(0, NO_ERRCODE, "TCP session %p from %s will be "
357 						"closed, error ignored\n", pSess, (char *)pszPeer);
358 					}
359 					ABORT_FINALIZE(RS_RET_ERR); 				}
360 			}
361 			len = ntohl((buf[0] &lt;&lt; 24)
362 				    | (buf[1] &lt;&lt; 16)
363 				    | (buf[2] &lt;&lt; 8)
364 				    | buf[3]);
365 			if ((ret - 4) &lt; len || len == 0) {
366 				dbgprintf("GSS-API Reverting to plain TCP from %s\n", (char *)pszPeer);
367 				pGSess-&gt;allowedMethods = ALLOWEDMETHOD_TCP;
368 				ABORT_FINALIZE(RS_RET_OK); 			}
369 			freeFdSet(pFds);
370 		}
371 		context = &amp;pGSess-&gt;gss_context;
372 		*context = GSS_C_NO_CONTEXT;
373 		sess_flags = &amp;pGSess-&gt;gss_flags;
374 		do {
375 			if (gssutil.recv_token(fdSess, &amp;recv_tok) &lt;= 0) {
376 				LogError(0, NO_ERRCODE, "TCP session %p from %s will be "
377 						"closed, error ignored\n", pSess, (char *)pszPeer);
378 				ABORT_FINALIZE(RS_RET_ERR); 			}
379 			maj_stat = gss_accept_sec_context(&amp;acc_sec_min_stat, context, gss_server_creds,
380 							  &amp;recv_tok, GSS_C_NO_CHANNEL_BINDINGS, &amp;client,
381 							  NULL, &amp;send_tok, sess_flags, NULL, NULL);
382 			if (recv_tok.value) {
383 				free(recv_tok.value);
384 				recv_tok.value = NULL;
385 			}
386 			if (maj_stat != GSS_S_COMPLETE &amp;&amp; maj_stat != GSS_S_CONTINUE_NEEDED) {
387 				gss_release_buffer(&amp;min_stat, &amp;send_tok);
388 				if (*context != GSS_C_NO_CONTEXT)
389 					gss_delete_sec_context(&amp;min_stat, context, GSS_C_NO_BUFFER);
390 				if ((allowedMethods &amp; ALLOWEDMETHOD_TCP) &amp;&amp;
391 				    (GSS_ROUTINE_ERROR(maj_stat) == GSS_S_DEFECTIVE_TOKEN)) {
392 					dbgprintf("GSS-API Reverting to plain TCP from %s\n", (char *)pszPeer);
393 					dbgprintf("tcp session socket with new data: #%d\n", fdSess);
394 					if(tcps_sess.DataRcvd(pSess, buf, ret) != RS_RET_OK) {
395 						LogError(0, NO_ERRCODE, "Tearing down TCP "
396 							"Session %p from %s - see previous messages "
397 							"for reason(s)\n", pSess, (char *)pszPeer);
398 						ABORT_FINALIZE(RS_RET_ERR); 					}
399 					pGSess-&gt;allowedMethods = ALLOWEDMETHOD_TCP;
400 					ABORT_FINALIZE(RS_RET_OK); 				}
401 				gssutil.display_status((char*)"accepting context", maj_stat, acc_sec_min_stat);
402 				ABORT_FINALIZE(RS_RET_ERR); 			}
403 			if (send_tok.length != 0) {
404 				if(gssutil.send_token(fdSess, &amp;send_tok) &lt; 0) {
405 					gss_release_buffer(&amp;min_stat, &amp;send_tok);
406 					LogError(0, NO_ERRCODE, "TCP session %p from %s will be "
407 							"closed, error ignored\n", pSess, (char *)pszPeer);
408 					if (*context != GSS_C_NO_CONTEXT)
409 						gss_delete_sec_context(&amp;min_stat, context, GSS_C_NO_BUFFER);
410 					ABORT_FINALIZE(RS_RET_ERR); 				}
411 				gss_release_buffer(&amp;min_stat, &amp;send_tok);
412 			}
413 		} while (maj_stat == GSS_S_CONTINUE_NEEDED);
414 		maj_stat = gss_display_name(&amp;min_stat, client, &amp;recv_tok, NULL);
415 		if (maj_stat != GSS_S_COMPLETE) {
416 			gssutil.display_status((char*)"displaying name", maj_stat, min_stat);
417 		} else {
418 			dbgprintf("GSS-API Accepted connection from peer %s: %s\n", (char *)pszPeer,
419 				(char*) recv_tok.value);
420 		}
421 		gss_release_name(&amp;min_stat, &amp;client);
422 		gss_release_buffer(&amp;min_stat, &amp;recv_tok);
423 		dbgprintf("GSS-API Provided context flags:\n");
424 		gssutil.display_ctx_flags(*sess_flags);
425 		pGSess-&gt;allowedMethods = ALLOWEDMETHOD_GSS;
426 	}
427 finalize_it:
428 	free(buf);
429 	RETiRet;
430 }
431 int TCPSessGSSRecv(tcps_sess_t *pSess, void *buf, size_t buf_len, ssize_t *piLenRcvd)
432 {
433 	DEFiRet;
434 	gss_buffer_desc xmit_buf, msg_buf;
435 	gss_ctx_id_t *context;
436 	OM_uint32 maj_stat, min_stat;
437 	int fdSess;
438 	int     conf_state;
439 	gss_sess_t *pGSess;
440 	assert(pSess-&gt;pUsr != NULL);
441 	assert(piLenRcvd != NULL);
442 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
443 	netstrm.GetSock(pSess-&gt;pStrm, &amp;fdSess); 	if(gssutil.recv_token(fdSess, &amp;xmit_buf) &lt;= 0)
444 		ABORT_FINALIZE(RS_RET_GSS_ERR);
445 	context = &amp;pGSess-&gt;gss_context;
446 	maj_stat = gss_unwrap(&amp;min_stat, *context, &amp;xmit_buf, &amp;msg_buf,
447 			      &amp;conf_state, (gss_qop_t *) NULL);
448 	if(maj_stat != GSS_S_COMPLETE) {
449 		gssutil.display_status((char*)"unsealing message", maj_stat, min_stat);
450 		if(xmit_buf.value) {
451 			free(xmit_buf.value);
452 			xmit_buf.value = 0;
453 		}
454 		ABORT_FINALIZE(RS_RET_GSS_ERR);
455 	}
456 	if (xmit_buf.value) {
457 		free(xmit_buf.value);
458 		xmit_buf.value = 0;
459 	}
460 	*piLenRcvd = msg_buf.length &lt; buf_len ? msg_buf.length : buf_len;
461 	memcpy(buf, msg_buf.value, *piLenRcvd);
462 	gss_release_buffer(&amp;min_stat, &amp;msg_buf);
463 finalize_it:
464 	RETiRet;
465 }
466 void TCPSessGSSClose(tcps_sess_t* pSess)
467 {
468 	OM_uint32 maj_stat, min_stat;
469 	gss_ctx_id_t *context;
470 	gss_sess_t *pGSess;
471 	assert(pSess-&gt;pUsr != NULL);
472 	pGSess = (gss_sess_t*) pSess-&gt;pUsr;
473 	context = &amp;pGSess-&gt;gss_context;
474 	maj_stat = gss_delete_sec_context(&amp;min_stat, context, GSS_C_NO_BUFFER);
475 	if (maj_stat != GSS_S_COMPLETE)
476 		gssutil.display_status((char*)"deleting context", maj_stat, min_stat);
477 	*context = GSS_C_NO_CONTEXT;
478 	pGSess-&gt;gss_flags = 0;
479 	pGSess-&gt;allowedMethods = 0;
480 	tcps_sess.Close(pSess);
481 }
482 static rsRetVal
483 TCPSessGSSDeinit(void)
484 {
485 	DEFiRet;
486 	OM_uint32 maj_stat, min_stat;
487 	if (gss_server_creds != GSS_C_NO_CREDENTIAL) {
488 		maj_stat = gss_release_cred(&amp;min_stat, &amp;gss_server_creds);
489 		if (maj_stat != GSS_S_COMPLETE)
490 			gssutil.display_status((char*)"releasing credentials", maj_stat, min_stat);
491 	}
492 	RETiRet;
493 }
494 #if 0 BEGINbeginCnfLoad
495 CODESTARTbeginCnfLoad
496 ENDbeginCnfLoad
497 BEGINendCnfLoad
498 CODESTARTendCnfLoad
499 ENDendCnfLoad
500 BEGINcheckCnf
501 CODESTARTcheckCnf
502 ENDcheckCnf
503 BEGINactivateCnf
504 CODESTARTactivateCnf
505 ENDactivateCnf
506 BEGINfreeCnf
507 CODESTARTfreeCnf
508 ENDfreeCnf
509 #endif
510 BEGINrunInput
511 CODESTARTrunInput
512 	actGSSListener(srvPort);
513 	iRet = tcpsrv.Run(pOurTcpsrv);
514 ENDrunInput
515 BEGINwillRun
516 CODESTARTwillRun
517 	if(srvPort == NULL)
518 		ABORT_FINALIZE(RS_RET_NO_RUN);
519 	net.PrintAllowedSenders(2); 	net.PrintAllowedSenders(3); finalize_it:
520 ENDwillRun
521 BEGINmodExit
522 CODESTARTmodExit
523 	if(pOurTcpsrv != NULL)
524 		iRet = tcpsrv.Destruct(&amp;pOurTcpsrv);
525 	TCPSessGSSDeinit();
526 	objRelease(tcps_sess, LM_TCPSRV_FILENAME);
527 	objRelease(tcpsrv, LM_TCPSRV_FILENAME);
528 	objRelease(gssutil, LM_GSSUTIL_FILENAME);
529 	objRelease(glbl, CORE_COMPONENT);
530 	objRelease(netstrm, LM_NETSTRM_FILENAME);
531 	objRelease(net, LM_NET_FILENAME);
532 	objRelease(prop, CORE_COMPONENT);
533 ENDmodExit
534 BEGINafterRun
535 CODESTARTafterRun
536 	net.clearAllowedSenders((uchar*)"TCP");
537 	net.clearAllowedSenders((uchar*)"GSS");
538 ENDafterRun
539 BEGINisCompatibleWithFeature
540 CODESTARTisCompatibleWithFeature
541 	if(eFeat == sFEATURENonCancelInputTermination)
542 		iRet = RS_RET_OK;
543 ENDisCompatibleWithFeature
544 BEGINqueryEtryPt
545 CODESTARTqueryEtryPt
546 CODEqueryEtryPt_STD_IMOD_QUERIES
547 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
548 ENDqueryEtryPt
549 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
550 {
551 	if (gss_listen_service_name != NULL) {
552 		free(gss_listen_service_name);
553 		gss_listen_service_name = NULL;
554 	}
555 	if (pszLstnPortFileName != NULL) {
556 		free(pszLstnPortFileName);
557 		pszLstnPortFileName = NULL;
558 	}
559 <a name="0"></a>	bPermitPlainTcp = 0;
560 	iTCPSessMax = 200;
561 	bKeepAlive = 0;
562 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return RS_RET_OK;
563 }
564 BEGINmodInit()
565 CODESTARTmodInit
566 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
567 	pOurTcpsrv = NULL;
568 	CHKiRet(objUse(tcps_sess, LM_TCPSRV_FILENAME));
569 	CHKiRet(objUse(tcpsrv, LM_TCPSRV_FILENAME));
570 	CHKiRet(objUse(gssutil, LM_GSSUTIL_FILENAME));
571 	CHKiRet(objUse(glbl, CORE_COMPONENT));
572 	CHKiRet(objUse(netstrm, LM_NETSTRM_FILENAME));
573 	CHKiRet(objUse(net, LM_NET_FILENAME));
574 	CHKiRet(objUse(prop, CORE_COMPONENT));
575 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgssserverpermitplaintcp", 0, eCmdHdlrBinary,
576 				   NULL, &amp;bPermitPlainTcp, STD_LOADABLE_MODULE_ID));
577 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgssserverrun", 0, eCmdHdlrGetWord,
578 				   addGSSListener, NULL, STD_LOADABLE_MODULE_ID));
579 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgssserverservicename", 0, eCmdHdlrGetWord,
580 				   NULL, &amp;gss_listen_service_name, STD_LOADABLE_MODULE_ID));
581 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgsslistenportfilename", 0, eCmdHdlrGetWord,
582 				   NULL, &amp;pszLstnPortFileName, STD_LOADABLE_MODULE_ID));
583 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgssservermaxsessions", 0, eCmdHdlrInt,
584 				   NULL, &amp;iTCPSessMax, STD_LOADABLE_MODULE_ID));
585 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputgssserverkeepalive", 0, eCmdHdlrBinary,
586 				   NULL, &amp;bKeepAlive, STD_LOADABLE_MODULE_ID));
587 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
588 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));</b></font>
589 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imtcp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;sys/types.h&gt;
13 #include &lt;sys/socket.h&gt;
14 #if HAVE_FCNTL_H
15 #include &lt;fcntl.h&gt;
16 #endif
17 #include "rsyslog.h"
18 #include "dirty.h"
19 #include "cfsysline.h"
20 #include "module-template.h"
21 #include "unicode-helper.h"
22 #include "net.h"
23 #include "netstrm.h"
24 #include "errmsg.h"
25 #include "tcpsrv.h"
26 #include "ruleset.h"
27 #include "rainerscript.h"
28 #include "net.h"
29 #include "parserif.h"
30 MODULE_TYPE_INPUT
31 MODULE_TYPE_NOKEEP
32 MODULE_CNFNAME("imtcp")
33 DEF_IMOD_STATIC_DATA
34 DEFobjCurrIf(tcpsrv)
35 DEFobjCurrIf(tcps_sess)
36 DEFobjCurrIf(net)
37 DEFobjCurrIf(netstrm)
38 DEFobjCurrIf(ruleset)
39 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
40 typedef struct tcpsrv_etry_s {
41 	tcpsrv_t *tcpsrv;
42 	pthread_t tid;		struct tcpsrv_etry_s *next;
43 } tcpsrv_etry_t;
44 static tcpsrv_etry_t *tcpsrv_root = NULL;
45 static int n_tcpsrv = 0;
46 static permittedPeers_t *pPermPeersRoot = NULL;
47 #define FRAMING_UNSET -1
48 static struct configSettings_s {
49 	int iTCPSessMax;
50 	int iTCPLstnMax;
51 	int bSuppOctetFram;
52 	int iStrmDrvrMode;
53 	int bKeepAlive;
54 	int iKeepAliveIntvl;
55 	int iKeepAliveProbes;
56 	int iKeepAliveTime;
57 	int bEmitMsgOnClose;
58 	int iAddtlFrameDelim;
59 	int maxFrameSize;
60 	int bDisableLFDelim;
61 	int discardTruncatedMsg;
62 	int bUseFlowControl;
63 	int bPreserveCase;
64 	uchar *gnutlsPriorityString;
65 	uchar *pszStrmDrvrAuthMode;
66 	uchar *pszStrmDrvrPermitExpiredCerts;
67 	uchar *pszInputName;
68 	uchar *pszBindRuleset;
69 	uchar *lstnIP;				uchar *lstnPortFile;
70 } cs;
71 struct instanceConf_s {
72 	int iTCPSessMax;
73 	int iTCPLstnMax;
74 	uchar *pszBindRuleset;			ruleset_t *pBindRuleset;		uchar *pszInputName;			uchar *dfltTZ;
75 	sbool bSPFramingFix;
76 	unsigned int ratelimitInterval;
77 	unsigned int ratelimitBurst;
78 	int iAddtlFrameDelim; 	int maxFrameSize;
79 	int bUseFlowControl;
80 	int bDisableLFDelim;
81 	int discardTruncatedMsg;
82 	int bEmitMsgOnClose;
83 	int bPreserveCase;
84 	uchar *pszStrmDrvrName; 	int iStrmDrvrMode;
85 	uchar *pszStrmDrvrAuthMode;
86 	uchar *pszStrmDrvrPermitExpiredCerts;
87 	uchar *pszStrmDrvrCAFile;
88 	uchar *pszStrmDrvrKeyFile;
89 	uchar *pszStrmDrvrCertFile;
90 	permittedPeers_t *pPermPeersRoot;
91 	uchar *gnutlsPriorityString;
92 	int iStrmDrvrExtendedCertCheck;
93 	int iStrmDrvrSANPreference;
94 	int iStrmTlsVerifyDepth;
95 	int bKeepAlive;
96 	int iKeepAliveIntvl;
97 	int iKeepAliveProbes;
98 	int iKeepAliveTime;
99 	struct instanceConf_s *next;
100 };
101 struct modConfData_s {
102 	rsconf_t *pConf;			instanceConf_t *root, *tail;
103 	int iAddtlFrameDelim; 	int maxFrameSize;
104 	int bSuppOctetFram;
105 	sbool bDisableLFDelim; 	sbool discardTruncatedMsg;
106 	sbool bUseFlowControl; 	sbool bKeepAlive;
107 	int iKeepAliveIntvl;
108 	int iKeepAliveProbes;
109 	int iKeepAliveTime;
110 	sbool bEmitMsgOnClose; 	uchar *gnutlsPriorityString;
111 	uchar *pszStrmDrvrName; 	uchar *pszStrmDrvrAuthMode; 	uchar *pszStrmDrvrPermitExpiredCerts; 	uchar *pszStrmDrvrCAFile;
112 	uchar *pszStrmDrvrKeyFile;
113 	uchar *pszStrmDrvrCertFile;
114 	permittedPeers_t *pPermPeersRoot;
115 	sbool configSetViaV2Method;
116 	sbool bPreserveCase; };
117 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
118 static struct cnfparamdescr modpdescr[] = {
119 	{ "flowcontrol", eCmdHdlrBinary, 0 },
120 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
121 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
122 	{ "octetcountedframing", eCmdHdlrBinary, 0 },
123 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
124 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
125 	{ "maxframesize", eCmdHdlrInt, 0 },
126 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
127 	{ "maxlistners", eCmdHdlrPositiveInt, 0 },
128 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
129 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
130 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
131 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
132 	{ "streamdriver.name", eCmdHdlrString, 0 },
133 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
134 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
135 	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
136 	{ "permittedpeer", eCmdHdlrArray, 0 },
137 	{ "keepalive", eCmdHdlrBinary, 0 },
138 	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
139 	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
140 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
141 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
142 	{ "preservecase", eCmdHdlrBinary, 0 }
143 };
144 static struct cnfparamblk modpblk =
145 	{ CNFPARAMBLK_VERSION,
146 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
147 	  modpdescr
148 	};
149 static struct cnfparamdescr inppdescr[] = {
150 	{ "port", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "maxsessions", eCmdHdlrPositiveInt, 0 },
151 	{ "maxlisteners", eCmdHdlrPositiveInt, 0 },
152 	{ "flowcontrol", eCmdHdlrBinary, 0 },
153 	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
154 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
155 	{ "notifyonconnectionclose", eCmdHdlrBinary, 0 },
156 	{ "addtlframedelimiter", eCmdHdlrNonNegInt, 0 },
157 	{ "maxframesize", eCmdHdlrInt, 0 },
158 	{ "preservecase", eCmdHdlrBinary, 0 },
159 	{ "listenportfilename", eCmdHdlrString, 0 },
160 	{ "address", eCmdHdlrString, 0 },
161 	{ "name", eCmdHdlrString, 0 },
162 	{ "defaulttz", eCmdHdlrString, 0 },
163 	{ "ruleset", eCmdHdlrString, 0 },
164 	{ "streamdriver.mode", eCmdHdlrNonNegInt, 0 },
165 	{ "streamdriver.authmode", eCmdHdlrString, 0 },
166 	{ "streamdriver.permitexpiredcerts", eCmdHdlrString, 0 },
167 	{ "streamdriver.name", eCmdHdlrString, 0 },
168 	{ "streamdriver.CheckExtendedKeyPurpose", eCmdHdlrBinary, 0 },
169 	{ "streamdriver.PrioritizeSAN", eCmdHdlrBinary, 0 },
170 	{ "streamdriver.TlsVerifyDepth", eCmdHdlrPositiveInt, 0 },
171 	{ "streamdriver.cafile", eCmdHdlrString, 0 },
172 	{ "streamdriver.keyfile", eCmdHdlrString, 0 },
173 	{ "streamdriver.certfile", eCmdHdlrString, 0 },
174 	{ "permittedpeer", eCmdHdlrArray, 0 },
175 	{ "gnutlsprioritystring", eCmdHdlrString, 0 },
176 	{ "keepalive", eCmdHdlrBinary, 0 },
177 	{ "keepalive.probes", eCmdHdlrNonNegInt, 0 },
178 	{ "keepalive.time", eCmdHdlrNonNegInt, 0 },
179 	{ "keepalive.interval", eCmdHdlrNonNegInt, 0 },
180 	{ "supportoctetcountedframing", eCmdHdlrBinary, 0 },
181 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
182 	{ "framingfix.cisco.asa", eCmdHdlrBinary, 0 },
183 	{ "ratelimit.burst", eCmdHdlrInt, 0 }
184 };
185 static struct cnfparamblk inppblk =
186 	{ CNFPARAMBLK_VERSION,
187 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
188 	  inppdescr
189 	};
190 #include "im-helper.h" 
191 static int bLegacyCnfModGlobalsPermitted;
192 static int
193 isPermittedHost(struct sockaddr *addr, char *fromHostFQDN, void __attribute__((unused)) *pUsrSrv,
194 	        void __attribute__((unused)) *pUsrSess)
195 {
196 	return net.isAllowedSender2(UCHAR_CONSTANT("TCP"), addr, fromHostFQDN, 1);
197 }
198 static rsRetVal
199 doOpenLstnSocks(tcpsrv_t *pSrv)
200 {
201 	ISOBJ_TYPE_assert(pSrv, tcpsrv);
202 	dbgprintf("in imtcp doOpenLstnSocks\n");
203 	return tcpsrv.create_tcp_socket(pSrv);
204 }
205 static rsRetVal
206 doRcvData(tcps_sess_t *pSess, char *buf, size_t lenBuf, ssize_t *piLenRcvd, int *const oserr)
207 {
208 	assert(pSess != NULL);
209 	assert(piLenRcvd != NULL);
210 	*piLenRcvd = lenBuf;
211 	return netstrm.Rcv(pSess-&gt;pStrm, (uchar*) buf, piLenRcvd, oserr);
212 }
213 static rsRetVal
214 onRegularClose(tcps_sess_t *pSess)
215 {
216 	DEFiRet;
217 	assert(pSess != NULL);
218 	tcps_sess.PrepareClose(pSess);
219 	tcps_sess.Close(pSess);
220 	RETiRet;
221 }
222 static rsRetVal
223 onErrClose(tcps_sess_t *pSess)
224 {
225 	DEFiRet;
226 	assert(pSess != NULL);
227 	tcps_sess.Close(pSess);
228 	RETiRet;
229 }
230 static rsRetVal
231 setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
232 {
233 	DEFiRet;
234 	CHKiRet(net.AddPermittedPeer(&amp;pPermPeersRoot, pszID));
235 	free(pszID); finalize_it:
236 	RETiRet;
237 }
238 static rsRetVal
239 createInstance(instanceConf_t **pinst)
240 {
241 	instanceConf_t *inst = NULL;
242 	DEFiRet;
243 	CHKmalloc(inst = (instanceConf_t*) calloc(1, sizeof(instanceConf_t)));
244 	CHKmalloc(inst-&gt;cnf_params = (tcpLstnParams_t*) calloc(1, sizeof(tcpLstnParams_t)));
245 	inst-&gt;next = NULL;
246 	inst-&gt;pszBindRuleset = NULL;
247 	inst-&gt;pszInputName = NULL;
248 	inst-&gt;dfltTZ = NULL;
249 	inst-&gt;cnf_params-&gt;bSuppOctetFram = -1; 	inst-&gt;bSPFramingFix = 0;
250 	inst-&gt;ratelimitInterval = 0;
251 	inst-&gt;ratelimitBurst = 10000;
252 	inst-&gt;pszStrmDrvrName = NULL;
253 	inst-&gt;pszStrmDrvrAuthMode = NULL;
254 	inst-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
255 	inst-&gt;pszStrmDrvrCAFile = NULL;
256 	inst-&gt;pszStrmDrvrKeyFile = NULL;
257 	inst-&gt;pszStrmDrvrCertFile = NULL;
258 	inst-&gt;pPermPeersRoot = NULL;
259 	inst-&gt;gnutlsPriorityString = NULL;
260 	inst-&gt;iStrmDrvrMode = loadModConf-&gt;iStrmDrvrMode;
261 	inst-&gt;iStrmDrvrExtendedCertCheck = loadModConf-&gt;iStrmDrvrExtendedCertCheck;
262 	inst-&gt;iStrmDrvrSANPreference = loadModConf-&gt;iStrmDrvrSANPreference;
263 	inst-&gt;iStrmTlsVerifyDepth = loadModConf-&gt;iStrmTlsVerifyDepth;
264 	inst-&gt;bKeepAlive = loadModConf-&gt;bKeepAlive;
265 	inst-&gt;iKeepAliveIntvl = loadModConf-&gt;iKeepAliveIntvl;
266 	inst-&gt;iKeepAliveProbes = loadModConf-&gt;iKeepAliveProbes;
267 	inst-&gt;iKeepAliveTime = loadModConf-&gt;iKeepAliveTime;
268 	inst-&gt;iAddtlFrameDelim = loadModConf-&gt;iAddtlFrameDelim;
269 	inst-&gt;maxFrameSize = loadModConf-&gt;maxFrameSize;
270 	inst-&gt;bUseFlowControl = loadModConf-&gt;bUseFlowControl;
271 	inst-&gt;bDisableLFDelim = loadModConf-&gt;bDisableLFDelim;
272 	inst-&gt;discardTruncatedMsg = loadModConf-&gt;discardTruncatedMsg;
273 	inst-&gt;bEmitMsgOnClose = loadModConf-&gt;bEmitMsgOnClose;
274 	inst-&gt;bPreserveCase = loadModConf-&gt;bPreserveCase;
275 	inst-&gt;iTCPLstnMax = loadModConf-&gt;iTCPLstnMax;
276 	inst-&gt;iTCPSessMax = loadModConf-&gt;iTCPSessMax;
277 	inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
278 	if(loadModConf-&gt;tail == NULL) {
279 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
280 	} else {
281 		loadModConf-&gt;tail-&gt;next = inst;
282 		loadModConf-&gt;tail = inst;
283 	}
284 	*pinst = inst;
285 finalize_it:
286 	if(iRet != RS_RET_OK) {
287 		free(inst-&gt;cnf_params);
288 		free(inst);
289 	}
290 	RETiRet;
291 }
292 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
293 {
294 	instanceConf_t *inst;
295 	DEFiRet;
296 	CHKiRet(createInstance(&amp;inst));
297 	CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
298 				 	       ? (uchar*) "10514" : pNewVal));
299 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
300 		inst-&gt;pszBindRuleset = NULL;
301 	} else {
302 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
303 	}
304 	if((cs.lstnIP == NULL) || (cs.lstnIP[0] == '\0')) {
305 		inst-&gt;cnf_params-&gt;pszAddr = NULL;
306 	} else {
307 		CHKmalloc(inst-&gt;cnf_params-&gt;pszAddr = ustrdup(cs.lstnIP));
308 	}
309 	if((cs.lstnPortFile == NULL) || (cs.lstnPortFile[0] == '\0')) {
310 		inst-&gt;cnf_params-&gt;pszLstnPortFileName = NULL;
311 	} else {
312 		CHKmalloc(inst-&gt;cnf_params-&gt;pszLstnPortFileName = ustrdup(cs.lstnPortFile));
313 	}
314 	if((cs.pszInputName == NULL) || (cs.pszInputName[0] == '\0')) {
315 		inst-&gt;pszInputName = NULL;
316 	} else {
317 		CHKmalloc(inst-&gt;pszInputName = ustrdup(cs.pszInputName));
318 	}
319 	inst-&gt;cnf_params-&gt;bSuppOctetFram = cs.bSuppOctetFram;
320 finalize_it:
321 	free(pNewVal);
322 	RETiRet;
323 }
324 static rsRetVal
325 addListner(modConfData_t *modConf, instanceConf_t *inst)
326 {
327 	DEFiRet;
328 	uchar *psz;		permittedPeers_t *peers;
329 	tcpsrv_t *pOurTcpsrv;
330 	CHKiRet(tcpsrv.Construct(&amp;pOurTcpsrv));
331 	CHKiRet(tcpsrv.SetCBIsPermittedHost(pOurTcpsrv, isPermittedHost));
332 	CHKiRet(tcpsrv.SetCBRcvData(pOurTcpsrv, doRcvData));
333 	CHKiRet(tcpsrv.SetCBOpenLstnSocks(pOurTcpsrv, doOpenLstnSocks));
334 	CHKiRet(tcpsrv.SetCBOnRegularClose(pOurTcpsrv, onRegularClose));
335 	CHKiRet(tcpsrv.SetCBOnErrClose(pOurTcpsrv, onErrClose));
336 	CHKiRet(tcpsrv.SetKeepAlive(pOurTcpsrv, inst-&gt;bKeepAlive));
337 	CHKiRet(tcpsrv.SetKeepAliveIntvl(pOurTcpsrv, inst-&gt;iKeepAliveIntvl));
338 	CHKiRet(tcpsrv.SetKeepAliveProbes(pOurTcpsrv, inst-&gt;iKeepAliveProbes));
339 	CHKiRet(tcpsrv.SetKeepAliveTime(pOurTcpsrv, inst-&gt;iKeepAliveTime));
340 	CHKiRet(tcpsrv.SetSessMax(pOurTcpsrv, inst-&gt;iTCPSessMax));
341 	CHKiRet(tcpsrv.SetLstnMax(pOurTcpsrv, inst-&gt;iTCPLstnMax));
342 	CHKiRet(tcpsrv.SetDrvrMode(pOurTcpsrv, inst-&gt;iStrmDrvrMode));
343 	CHKiRet(tcpsrv.SetDrvrCheckExtendedKeyUsage(pOurTcpsrv, inst-&gt;iStrmDrvrExtendedCertCheck));
344 	CHKiRet(tcpsrv.SetDrvrPrioritizeSAN(pOurTcpsrv, inst-&gt;iStrmDrvrSANPreference));
345 	CHKiRet(tcpsrv.SetDrvrTlsVerifyDepth(pOurTcpsrv, inst-&gt;iStrmTlsVerifyDepth));
346 	CHKiRet(tcpsrv.SetUseFlowControl(pOurTcpsrv, inst-&gt;bUseFlowControl));
347 	CHKiRet(tcpsrv.SetAddtlFrameDelim(pOurTcpsrv, inst-&gt;iAddtlFrameDelim));
348 	CHKiRet(tcpsrv.SetMaxFrameSize(pOurTcpsrv, inst-&gt;maxFrameSize));
349 	CHKiRet(tcpsrv.SetbDisableLFDelim(pOurTcpsrv, inst-&gt;bDisableLFDelim));
350 	CHKiRet(tcpsrv.SetDiscardTruncatedMsg(pOurTcpsrv, inst-&gt;discardTruncatedMsg));
351 	CHKiRet(tcpsrv.SetNotificationOnRemoteClose(pOurTcpsrv, inst-&gt;bEmitMsgOnClose));
352 	CHKiRet(tcpsrv.SetPreserveCase(pOurTcpsrv, inst-&gt;bPreserveCase));
353 	psz = (inst-&gt;pszStrmDrvrName == NULL) ? modConf-&gt;pszStrmDrvrName : inst-&gt;pszStrmDrvrName;
354 	if(psz != NULL) {
355 		CHKiRet(tcpsrv.SetDrvrName(pOurTcpsrv, psz));
356 	}
357 	psz = (inst-&gt;pszStrmDrvrAuthMode == NULL) ? modConf-&gt;pszStrmDrvrAuthMode : inst-&gt;pszStrmDrvrAuthMode;
358 	if(psz != NULL) {
359 		CHKiRet(tcpsrv.SetDrvrAuthMode(pOurTcpsrv, psz));
360 	}
361 	psz = (inst-&gt;gnutlsPriorityString == NULL)
362 			? modConf-&gt;gnutlsPriorityString : inst-&gt;gnutlsPriorityString;
363 	CHKiRet(tcpsrv.SetGnutlsPriorityString(pOurTcpsrv, psz));
364 	psz = (inst-&gt;pszStrmDrvrPermitExpiredCerts == NULL)
365 			? modConf-&gt;pszStrmDrvrPermitExpiredCerts : inst-&gt;pszStrmDrvrPermitExpiredCerts;
366 	CHKiRet(tcpsrv.SetDrvrPermitExpiredCerts(pOurTcpsrv, psz));
367 	psz = (inst-&gt;pszStrmDrvrCAFile == NULL)
368 			? modConf-&gt;pszStrmDrvrCAFile : inst-&gt;pszStrmDrvrCAFile;
369 	CHKiRet(tcpsrv.SetDrvrCAFile(pOurTcpsrv, psz));
370 	psz = (inst-&gt;pszStrmDrvrKeyFile == NULL)
371 			? modConf-&gt;pszStrmDrvrKeyFile : inst-&gt;pszStrmDrvrKeyFile;
372 	CHKiRet(tcpsrv.SetDrvrKeyFile(pOurTcpsrv, psz));
373 	psz = (inst-&gt;pszStrmDrvrCertFile == NULL)
374 			? modConf-&gt;pszStrmDrvrCertFile : inst-&gt;pszStrmDrvrCertFile;
375 	CHKiRet(tcpsrv.SetDrvrCertFile(pOurTcpsrv, psz));
376 	peers = (inst-&gt;pPermPeersRoot == NULL)
377 			? modConf-&gt;pPermPeersRoot : inst-&gt;pPermPeersRoot;
378 	if(peers != NULL) {
379 			CHKiRet(tcpsrv.SetDrvrPermPeers(pOurTcpsrv, peers));
380 	}
381 	DBGPRINTF("imtcp: trying to add port *:%s\n", inst-&gt;cnf_params-&gt;pszPort);
382 	inst-&gt;cnf_params-&gt;pRuleset = inst-&gt;pBindRuleset;
383 	CHKiRet(tcpsrv.SetInputName(pOurTcpsrv, inst-&gt;cnf_params, inst-&gt;pszInputName == NULL ?
384 						UCHAR_CONSTANT("imtcp") : inst-&gt;pszInputName));
385 	CHKiRet(tcpsrv.SetOrigin(pOurTcpsrv, (uchar*)"imtcp"));
386 	CHKiRet(tcpsrv.SetDfltTZ(pOurTcpsrv, (inst-&gt;dfltTZ == NULL) ? (uchar*)"" : inst-&gt;dfltTZ));
387 	CHKiRet(tcpsrv.SetbSPFramingFix(pOurTcpsrv, inst-&gt;bSPFramingFix));
388 	CHKiRet(tcpsrv.SetLinuxLikeRatelimiters(pOurTcpsrv, inst-&gt;ratelimitInterval, inst-&gt;ratelimitBurst));
389 	if((ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) == 0
390 		&amp;&amp; inst-&gt;cnf_params-&gt;pszLstnPortFileName == NULL)
391 			|| ustrcmp(inst-&gt;cnf_params-&gt;pszPort, UCHAR_CONSTANT("0")) &lt; 0) {
392 		LogMsg(0, RS_RET_OK, LOG_WARNING, "imtcp: port 0 and no port file set -&gt; using port 514 instead");
393 		CHKmalloc(inst-&gt;cnf_params-&gt;pszPort = (uchar*)strdup("514"));
394 	}
395 	tcpsrv.configureTCPListen(pOurTcpsrv, inst-&gt;cnf_params);
396 	tcpsrv_etry_t *etry;
397 	CHKmalloc(etry = (tcpsrv_etry_t*) calloc(1, sizeof(tcpsrv_etry_t)));
398 	etry-&gt;tcpsrv = pOurTcpsrv;
399 	etry-&gt;next = tcpsrv_root;
400 	tcpsrv_root = etry;
401 	++n_tcpsrv;
402 finalize_it:
403 	if(iRet != RS_RET_OK) {
404 		LogError(0, NO_ERRCODE, "imtcp: error %d trying to add listener", iRet);
405 	}
406 	RETiRet;
407 }
408 BEGINnewInpInst
409 	struct cnfparamvals *pvals;
410 	instanceConf_t *inst;
411 	int i;
412 CODESTARTnewInpInst
413 	DBGPRINTF("newInpInst (imtcp)\n");
414 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
415 	if(pvals == NULL) {
416 		LogError(0, RS_RET_MISSING_CNFPARAMS,
417 			        "imtcp: required parameter are missing\n");
418 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
419 	}
420 	if(Debug) {
421 		dbgprintf("input param blk in imtcp:\n");
422 		cnfparamsPrint(&amp;inppblk, pvals);
423 	}
424 	CHKiRet(createInstance(&amp;inst));
425 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
426 		if(!pvals[i].bUsed)
427 			continue;
428 		if(!strcmp(inppblk.descr[i].name, "port")) {
429 			inst-&gt;cnf_params-&gt;pszPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
430 		} else if(!strcmp(inppblk.descr[i].name, "address")) {
431 			inst-&gt;cnf_params-&gt;pszAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
432 		} else if(!strcmp(inppblk.descr[i].name, "name")) {
433 			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
434 		} else if(!strcmp(inppblk.descr[i].name, "defaulttz")) {
435 			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
436 		} else if(!strcmp(inppblk.descr[i].name, "framingfix.cisco.asa")) {
437 			inst-&gt;bSPFramingFix = (int) pvals[i].val.d.n;
438 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
439 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
440 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.mode")) {
441 			inst-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;
442 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
443 			inst-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
444 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
445 			inst-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
446 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
447 			if (pvals[i].val.d.n &gt;= 2) {
448 				inst-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
449 			} else {
450 				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
451 									(int) pvals[i].val.d.n);
452 			}
453 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.authmode")) {
454 			inst-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
456 			inst-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
457 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.cafile")) {
458 			inst-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
459 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.keyfile")) {
460 			inst-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
461 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.certfile")) {
462 			inst-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
463 		} else if(!strcmp(inppblk.descr[i].name, "streamdriver.name")) {
464 			inst-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
465 		} else if(!strcmp(inppblk.descr[i].name, "gnutlsprioritystring")) {
466 			inst-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
467 		} else if(!strcmp(inppblk.descr[i].name, "permittedpeer")) {
468 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
469 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
470 				CHKiRet(net.AddPermittedPeer(&amp;inst-&gt;pPermPeersRoot, peer));
471 				free(peer);
472 			}
473 		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
474 			inst-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
475 		} else if(!strcmp(inppblk.descr[i].name, "disablelfdelimiter")) {
476 			inst-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
477 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
478 			inst-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
479 		} else if(!strcmp(inppblk.descr[i].name, "notifyonconnectionclose")) {
480 			inst-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
481 		} else if(!strcmp(inppblk.descr[i].name, "addtlframedelimiter")) {
482 			inst-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
483 		} else if(!strcmp(inppblk.descr[i].name, "maxframesize")) {
484 			const int max = (int) pvals[i].val.d.n;
485 			if(max &lt;= 200000000) {
486 				inst-&gt;maxFrameSize = max;
487 			} else {
488 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
489 						"parameter given is %d, max is 200000000", max);
490 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
491 			}
492 		} else if(!strcmp(inppblk.descr[i].name, "maxsessions")) {
493 			inst-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
494 		} else if(!strcmp(inppblk.descr[i].name, "maxlisteners")) {
495 			inst-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
496 		} else if(!strcmp(inppblk.descr[i].name, "supportoctetcountedframing")) {
497 			inst-&gt;cnf_params-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
498 		} else if(!strcmp(inppblk.descr[i].name, "keepalive")) {
499 			inst-&gt;bKeepAlive = (int) pvals[i].val.d.n;
500 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.probes")) {
501 			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
502 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.time")) {
503 			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
504 		} else if(!strcmp(inppblk.descr[i].name, "keepalive.interval")) {
505 			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
506 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
507 			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
508 		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
509 			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
510 		} else if(!strcmp(inppblk.descr[i].name, "preservecase")) {
511 			inst-&gt;bPreserveCase = (int) pvals[i].val.d.n;
512 		} else if(!strcmp(inppblk.descr[i].name, "listenportfilename")) {
513 			inst-&gt;cnf_params-&gt;pszLstnPortFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
514 		} else {
515 			dbgprintf("imtcp: program error, non-handled "
516 			  "param '%s'\n", inppblk.descr[i].name);
517 		}
518 	}
519 finalize_it:
520 CODE_STD_FINALIZERnewInpInst
521 	cnfparamvalsDestruct(pvals, &amp;inppblk);
522 ENDnewInpInst
523 BEGINbeginCnfLoad
524 CODESTARTbeginCnfLoad
525 	loadModConf = pModConf;
526 	pModConf-&gt;pConf = pConf;
527 	loadModConf-&gt;iTCPSessMax = 200;
528 	loadModConf-&gt;iTCPLstnMax = 20;
529 	loadModConf-&gt;bSuppOctetFram = 1;
530 	loadModConf-&gt;iStrmDrvrMode = 0;
531 	loadModConf-&gt;iStrmDrvrExtendedCertCheck = 0;
532 	loadModConf-&gt;iStrmDrvrSANPreference = 0;
533 	loadModConf-&gt;iStrmTlsVerifyDepth = 0;
534 	loadModConf-&gt;bUseFlowControl = 1;
535 	loadModConf-&gt;bKeepAlive = 0;
536 	loadModConf-&gt;iKeepAliveIntvl = 0;
537 	loadModConf-&gt;iKeepAliveProbes = 0;
538 	loadModConf-&gt;iKeepAliveTime = 0;
539 	loadModConf-&gt;bEmitMsgOnClose = 0;
540 	loadModConf-&gt;iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
541 	loadModConf-&gt;maxFrameSize = 200000;
542 	loadModConf-&gt;bDisableLFDelim = 0;
543 	loadModConf-&gt;discardTruncatedMsg = 0;
544 	loadModConf-&gt;gnutlsPriorityString = NULL;
545 	loadModConf-&gt;pszStrmDrvrName = NULL;
546 	loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
547 	loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = NULL;
548 	loadModConf-&gt;pszStrmDrvrCAFile = NULL;
549 	loadModConf-&gt;pszStrmDrvrKeyFile = NULL;
550 	loadModConf-&gt;pszStrmDrvrCertFile = NULL;
551 	loadModConf-&gt;pPermPeersRoot = NULL;
552 	loadModConf-&gt;configSetViaV2Method = 0;
553 	loadModConf-&gt;bPreserveCase = 1; 	bLegacyCnfModGlobalsPermitted = 1;
554 	resetConfigVariables(NULL, NULL); ENDbeginCnfLoad
555 BEGINsetModCnf
556 	struct cnfparamvals *pvals = NULL;
557 	int i;
558 CODESTARTsetModCnf
559 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
560 	if(pvals == NULL) {
561 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imtcp: error processing module "
562 				"config parameters [module(...)]");
563 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
564 	}
565 	if(Debug) {
566 		dbgprintf("module (global) param blk for imtcp:\n");
567 		cnfparamsPrint(&amp;modpblk, pvals);
568 	}
569 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
570 		if(!pvals[i].bUsed)
571 			continue;
572 		if(!strcmp(modpblk.descr[i].name, "flowcontrol")) {
573 			loadModConf-&gt;bUseFlowControl = (int) pvals[i].val.d.n;
574 		} else if(!strcmp(modpblk.descr[i].name, "disablelfdelimiter")) {
575 			loadModConf-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
576 		} else if(!strcmp(modpblk.descr[i].name, "discardtruncatedmsg")) {
577 			loadModConf-&gt;discardTruncatedMsg = (int) pvals[i].val.d.n;
578 		} else if(!strcmp(modpblk.descr[i].name, "octetcountedframing")) {
579 			loadModConf-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
580 		} else if(!strcmp(modpblk.descr[i].name, "notifyonconnectionclose")) {
581 			loadModConf-&gt;bEmitMsgOnClose = (int) pvals[i].val.d.n;
582 		} else if(!strcmp(modpblk.descr[i].name, "addtlframedelimiter")) {
583 			loadModConf-&gt;iAddtlFrameDelim = (int) pvals[i].val.d.n;
584 		} else if(!strcmp(modpblk.descr[i].name, "maxframesize")) {
585 			const int max = (int) pvals[i].val.d.n;
586 			if(max &lt;= 200000000) {
587 				loadModConf-&gt;maxFrameSize = max;
588 			} else {
589 				LogError(0, RS_RET_PARAM_ERROR, "imtcp: invalid value for 'maxFrameSize' "
590 						"parameter given is %d, max is 200000000", max);
591 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
592 			}
593 		} else if(!strcmp(modpblk.descr[i].name, "maxsessions")) {
594 			loadModConf-&gt;iTCPSessMax = (int) pvals[i].val.d.n;
595 		} else if(!strcmp(modpblk.descr[i].name, "maxlisteners") ||
596 			  !strcmp(modpblk.descr[i].name, "maxlistners")) { 			loadModConf-&gt;iTCPLstnMax = (int) pvals[i].val.d.n;
597 		} else if(!strcmp(modpblk.descr[i].name, "keepalive")) {
598 			loadModConf-&gt;bKeepAlive = (int) pvals[i].val.d.n;
599 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.probes")) {
600 			loadModConf-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
601 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.time")) {
602 			loadModConf-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
603 		} else if(!strcmp(modpblk.descr[i].name, "keepalive.interval")) {
604 			loadModConf-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
605 		} else if(!strcmp(modpblk.descr[i].name, "gnutlsprioritystring")) {
606 			loadModConf-&gt;gnutlsPriorityString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
607 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.mode")) {
608 			loadModConf-&gt;iStrmDrvrMode = (int) pvals[i].val.d.n;
609 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.CheckExtendedKeyPurpose")) {
610 			loadModConf-&gt;iStrmDrvrExtendedCertCheck = (int) pvals[i].val.d.n;
611 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.PrioritizeSAN")) {
612 			loadModConf-&gt;iStrmDrvrSANPreference = (int) pvals[i].val.d.n;
613 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.TlsVerifyDepth")) {
614 			if (pvals[i].val.d.n &gt;= 2) {
615 				loadModConf-&gt;iStrmTlsVerifyDepth = (int) pvals[i].val.d.n;
616 			} else {
617 				parser_errmsg("streamdriver.TlsVerifyDepth must be 2 or higher but is %d",
618 									(int) pvals[i].val.d.n);
619 			}
620 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.authmode")) {
621 			loadModConf-&gt;pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
622 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.permitexpiredcerts")) {
623 			loadModConf-&gt;pszStrmDrvrPermitExpiredCerts = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
624 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.cafile")) {
625 			loadModConf-&gt;pszStrmDrvrCAFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
626 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.keyfile")) {
627 			loadModConf-&gt;pszStrmDrvrKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
628 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.certfile")) {
629 			loadModConf-&gt;pszStrmDrvrCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
630 		} else if(!strcmp(modpblk.descr[i].name, "streamdriver.name")) {
631 			loadModConf-&gt;pszStrmDrvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
632 		} else if(!strcmp(modpblk.descr[i].name, "permittedpeer")) {
633 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
634 				uchar *const peer = (uchar*) es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
635 				CHKiRet(net.AddPermittedPeer(&amp;loadModConf-&gt;pPermPeersRoot, peer));
636 				free(peer);
637 			}
638 		} else if(!strcmp(modpblk.descr[i].name, "preservecase")) {
639 			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
640 		} else {
641 			dbgprintf("imtcp: program error, non-handled "
642 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
643 		}
644 	}
645 	bLegacyCnfModGlobalsPermitted = 0;
646 	loadModConf-&gt;configSetViaV2Method = 1;
647 finalize_it:
648 	if(pvals != NULL)
649 		cnfparamvalsDestruct(pvals, &amp;modpblk);
650 ENDsetModCnf
651 BEGINendCnfLoad
652 CODESTARTendCnfLoad
653 	if(!loadModConf-&gt;configSetViaV2Method) {
654 		pModConf-&gt;iTCPSessMax = cs.iTCPSessMax;
655 		pModConf-&gt;iTCPLstnMax = cs.iTCPLstnMax;
656 		pModConf-&gt;iStrmDrvrMode = cs.iStrmDrvrMode;
657 		pModConf-&gt;bEmitMsgOnClose = cs.bEmitMsgOnClose;
658 		pModConf-&gt;bSuppOctetFram = cs.bSuppOctetFram;
659 		pModConf-&gt;iAddtlFrameDelim = cs.iAddtlFrameDelim;
660 		pModConf-&gt;maxFrameSize = cs.maxFrameSize;
661 		pModConf-&gt;bDisableLFDelim = cs.bDisableLFDelim;
662 		pModConf-&gt;bUseFlowControl = cs.bUseFlowControl;
663 		pModConf-&gt;bKeepAlive = cs.bKeepAlive;
664 		pModConf-&gt;iKeepAliveProbes = cs.iKeepAliveProbes;
665 		pModConf-&gt;iKeepAliveIntvl = cs.iKeepAliveIntvl;
666 		pModConf-&gt;iKeepAliveTime = cs.iKeepAliveTime;
667 		if(pPermPeersRoot != NULL) {
668 			assert(pModConf-&gt;pPermPeersRoot == NULL);
669 			pModConf-&gt;pPermPeersRoot = pPermPeersRoot;
670 			pPermPeersRoot = NULL; 		}
671 		if((cs.pszStrmDrvrAuthMode == NULL) || (cs.pszStrmDrvrAuthMode[0] == '\0')) {
672 			loadModConf-&gt;pszStrmDrvrAuthMode = NULL;
673 		} else {
674 			loadModConf-&gt;pszStrmDrvrAuthMode = cs.pszStrmDrvrAuthMode;
675 			cs.pszStrmDrvrAuthMode = NULL;
676 		}
677 		pModConf-&gt;bPreserveCase = cs.bPreserveCase;
678 	}
679 	free(cs.pszStrmDrvrAuthMode);
680 	cs.pszStrmDrvrAuthMode = NULL;
681 	loadModConf = NULL; ENDendCnfLoad
682 static inline void
683 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
684 {
685 	LogError(0, NO_ERRCODE, "imtcp: ruleset '%s' for port %s not found - "
686 			"using default ruleset instead", inst-&gt;pszBindRuleset,
687 			inst-&gt;cnf_params-&gt;pszPort);
688 }
689 BEGINcheckCnf
690 	instanceConf_t *inst;
691 CODESTARTcheckCnf
692 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
693 		std_checkRuleset(pModConf, inst);
694 		if(inst-&gt;cnf_params-&gt;bSuppOctetFram == FRAMING_UNSET)
695 			inst-&gt;cnf_params-&gt;bSuppOctetFram = pModConf-&gt;bSuppOctetFram;
696 	}
697 	if(pModConf-&gt;root == NULL) {
698 		LogError(0, RS_RET_NO_LISTNERS , "imtcp: module loaded, but "
699 				"no listeners defined - no input will be gathered");
700 		iRet = RS_RET_NO_LISTNERS;
701 	}
702 ENDcheckCnf
703 BEGINactivateCnfPrePrivDrop
704 	instanceConf_t *inst;
705 CODESTARTactivateCnfPrePrivDrop
706 	runModConf = pModConf;
707 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
708 		addListner(runModConf, inst);
709 	}
710 	if(tcpsrv_root == NULL)
711 		ABORT_FINALIZE(RS_RET_NO_RUN);
712 	tcpsrv_etry_t *etry = tcpsrv_root;
713 	while(etry != NULL) {
714 		CHKiRet(tcpsrv.ConstructFinalize(etry-&gt;tcpsrv));
715 		etry = etry-&gt;next;
716 	}
717 finalize_it:
718 ENDactivateCnfPrePrivDrop
719 BEGINactivateCnf
720 CODESTARTactivateCnf
721 ENDactivateCnf
722 BEGINfreeCnf
723 	instanceConf_t *inst, *del;
724 CODESTARTfreeCnf
725 	free(pModConf-&gt;gnutlsPriorityString);
726 	free(pModConf-&gt;pszStrmDrvrName);
727 	free(pModConf-&gt;pszStrmDrvrAuthMode);
728 	free(pModConf-&gt;pszStrmDrvrPermitExpiredCerts);
729 	free(pModConf-&gt;pszStrmDrvrCAFile);
730 	free(pModConf-&gt;pszStrmDrvrKeyFile);
731 	free(pModConf-&gt;pszStrmDrvrCertFile);
732 	if(pModConf-&gt;pPermPeersRoot != NULL) {
733 		net.DestructPermittedPeers(&amp;pModConf-&gt;pPermPeersRoot);
734 	}
735 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
736 		free((void*)inst-&gt;pszBindRuleset);
737 		free((void*)inst-&gt;pszStrmDrvrAuthMode);
738 		free((void*)inst-&gt;pszStrmDrvrName);
739 		free((void*)inst-&gt;pszStrmDrvrPermitExpiredCerts);
740 		free((void*)inst-&gt;pszStrmDrvrCAFile);
741 		free((void*)inst-&gt;pszStrmDrvrKeyFile);
742 		free((void*)inst-&gt;pszStrmDrvrCertFile);
743 		free((void*)inst-&gt;gnutlsPriorityString);
744 		free((void*)inst-&gt;pszInputName);
745 		free((void*)inst-&gt;dfltTZ);
746 		if(inst-&gt;pPermPeersRoot != NULL) {
747 			net.DestructPermittedPeers(&amp;inst-&gt;pPermPeersRoot);
748 		}
749 		del = inst;
750 		inst = inst-&gt;next;
751 		free(del);
752 	}
753 ENDfreeCnf
754 static void *
755 RunServerThread(void *myself)
756 {
757 	tcpsrv_etry_t *const etry = (tcpsrv_etry_t*) myself;
758 	rsRetVal iRet;
759 	dbgprintf("RGER: running ety %p\n", etry);
760 	iRet = tcpsrv.Run(etry-&gt;tcpsrv);
761 	if(iRet != RS_RET_OK) {
762 		LogError(0, iRet, "imtcp: error while terminating server; rsyslog may hang on shutdown");
763 	}
764 	return NULL;
765 }
766 static void
767 startSrvWrkr(tcpsrv_etry_t *const etry)
768 {
769 	int r;
770 	pthread_attr_t sessThrdAttr;
771 	sigset_t sigSet, sigSetSave;
772 	sigfillset(&amp;sigSet);
773 	sigdelset(&amp;sigSet, SIGTTIN);
774 	sigdelset(&amp;sigSet, SIGSEGV);
775 	pthread_sigmask(SIG_SETMASK, &amp;sigSet, &amp;sigSetSave);
776 	pthread_attr_init(&amp;sessThrdAttr);
777 	pthread_attr_setstacksize(&amp;sessThrdAttr, 4096*1024);
778 	r = pthread_create(&amp;etry-&gt;tid, &amp;sessThrdAttr, RunServerThread, etry);
779 	if(r != 0) {
780 		LogError(r, NO_ERRCODE, "imtcp error creating server thread");
781 	}
782 	pthread_attr_destroy(&amp;sessThrdAttr);
783 	pthread_sigmask(SIG_SETMASK, &amp;sigSetSave, NULL);
784 }
785 static void
786 stopSrvWrkr(tcpsrv_etry_t *const etry)
787 {
788 	DBGPRINTF("Wait for thread shutdown etry %p\n", etry);
789 	pthread_kill(etry-&gt;tid, SIGTTIN);
790 	pthread_join(etry-&gt;tid, NULL);
791 	DBGPRINTF("input %p terminated\n", etry);
792 }
793 BEGINrunInput
794 CODESTARTrunInput
795 	tcpsrv_etry_t *etry = tcpsrv_root-&gt;next;
796 	while(etry != NULL) {
797 		startSrvWrkr(etry);
798 		etry = etry-&gt;next;
799 	}
800 	iRet = tcpsrv.Run(tcpsrv_root-&gt;tcpsrv);
801 	etry = tcpsrv_root-&gt;next;
802 	while(etry != NULL) {
803 		stopSrvWrkr(etry);
804 		etry = etry-&gt;next;
805 	}
806 ENDrunInput
807 BEGINwillRun
808 CODESTARTwillRun
809 	net.PrintAllowedSenders(2); ENDwillRun
810 BEGINafterRun
811 CODESTARTafterRun
812 	tcpsrv_etry_t *etry = tcpsrv_root;
813 	tcpsrv_etry_t *del;
814 	while(etry != NULL) {
815 		iRet = tcpsrv.Destruct(&amp;etry-&gt;tcpsrv);
816 		del = etry;
817 		etry = etry-&gt;next;
818 		free(del);
819 	}
820 	net.clearAllowedSenders(UCHAR_CONSTANT("TCP"));
821 ENDafterRun
822 BEGINisCompatibleWithFeature
823 CODESTARTisCompatibleWithFeature
824 	if(eFeat == sFEATURENonCancelInputTermination)
825 		iRet = RS_RET_OK;
826 ENDisCompatibleWithFeature
827 BEGINmodExit
828 CODESTARTmodExit
829 	objRelease(net, LM_NET_FILENAME);
830 	objRelease(netstrm, LM_NETSTRMS_FILENAME);
831 	objRelease(tcps_sess, LM_TCPSRV_FILENAME);
832 	objRelease(tcpsrv, LM_TCPSRV_FILENAME);
833 	objRelease(ruleset, CORE_COMPONENT);
834 ENDmodExit
835 static rsRetVal
836 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
837 {
838 	cs.iTCPSessMax = 200;
839 	cs.iTCPLstnMax = 20;
840 	cs.bSuppOctetFram = 1;
841 	cs.iStrmDrvrMode = 0;
842 	cs.bUseFlowControl = 1;
843 	cs.bKeepAlive = 0;
844 	cs.iKeepAliveProbes = 0;
845 	cs.iKeepAliveTime = 0;
846 	cs.iKeepAliveIntvl = 0;
847 	cs.bEmitMsgOnClose = 0;
848 	cs.iAddtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
849 	cs.maxFrameSize = 200000;
850 	cs.bDisableLFDelim = 0;
851 	cs.bPreserveCase = 1;
852 	free(cs.pszStrmDrvrAuthMode);
853 	cs.pszStrmDrvrAuthMode = NULL;
854 	free(cs.pszInputName);
855 <a name="0"></a>	cs.pszInputName = NULL;
856 	free(cs.lstnPortFile);
857 	cs.lstnPortFile = NULL;
858 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return RS_RET_OK;
859 }
860 BEGINqueryEtryPt
861 CODESTARTqueryEtryPt
862 CODEqueryEtryPt_STD_IMOD_QUERIES
863 CODEqueryEtryPt_STD_CONF2_QUERIES
864 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
865 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
866 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
867 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
868 ENDqueryEtryPt
869 BEGINmodInit()
870 CODESTARTmodInit
871 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
872 	tcpsrv_root = NULL;
873 	CHKiRet(objUse(net, LM_NET_FILENAME));
874 	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
875 	CHKiRet(objUse(tcps_sess, LM_TCPSRV_FILENAME));
876 	CHKiRet(objUse(tcpsrv, LM_TCPSRV_FILENAME));
877 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
878 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverrun"), 0, eCmdHdlrGetWord,
879 				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
880 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverinputname"), 0, eCmdHdlrGetWord,
881 				   NULL, &amp;cs.pszInputName, STD_LOADABLE_MODULE_ID));
882 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("inputtcpserverbindruleset"), 0, eCmdHdlrGetWord,
883 				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
884 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverpermittedpeer"), 0, eCmdHdlrGetWord,
885 			   setPermittedPeer, NULL, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
886 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdriverauthmode"), 0, eCmdHdlrGetWord,
887 			   NULL, &amp;cs.pszStrmDrvrAuthMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
888 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive"), 0, eCmdHdlrBinary,
889 			   NULL, &amp;cs.bKeepAlive, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
890 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_probes"), 0, eCmdHdlrInt,
891 			   NULL, &amp;cs.iKeepAliveProbes, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));</b></font>
892 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_intvl"), 0, eCmdHdlrInt,
893 			   NULL, &amp;cs.iKeepAliveIntvl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
894 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverkeepalive_time"), 0, eCmdHdlrInt,
895 			   NULL, &amp;cs.iKeepAliveTime, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
896 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpflowcontrol"), 0, eCmdHdlrBinary,
897 			   NULL, &amp;cs.bUseFlowControl, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
898 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverdisablelfdelimiter"), 0, eCmdHdlrBinary,
899 			   NULL, &amp;cs.bDisableLFDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
900 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserveraddtlframedelimiter"), 0, eCmdHdlrInt,
901 			   NULL, &amp;cs.iAddtlFrameDelim, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
902 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserversupportoctetcountedframing"), 0, eCmdHdlrBinary,
903 			   NULL, &amp;cs.bSuppOctetFram, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
904 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxsessions"), 0, eCmdHdlrInt,
905 			   NULL, &amp;cs.iTCPSessMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
906 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpmaxlisteners"), 0, eCmdHdlrInt,
907 			   NULL, &amp;cs.iTCPLstnMax, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
908 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpservernotifyonconnectionclose"), 0, eCmdHdlrBinary,
909 			   NULL, &amp;cs.bEmitMsgOnClose, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
910 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverstreamdrivermode"), 0, eCmdHdlrInt,
911 			   NULL, &amp;cs.iStrmDrvrMode, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
912 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverpreservecase"), 1, eCmdHdlrBinary,
913 			   NULL, &amp;cs.bPreserveCase, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
914 	CHKiRet(regCfSysLineHdlr2(UCHAR_CONSTANT("inputtcpserverlistenportfile"), 1, eCmdHdlrGetWord,
915 			   NULL, &amp;cs.lstnPortFile, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
916 	CHKiRet(omsdRegCFSLineHdlr(UCHAR_CONSTANT("resetconfigvariables"), 1, eCmdHdlrCustomHandler,
917 				   resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
918 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
