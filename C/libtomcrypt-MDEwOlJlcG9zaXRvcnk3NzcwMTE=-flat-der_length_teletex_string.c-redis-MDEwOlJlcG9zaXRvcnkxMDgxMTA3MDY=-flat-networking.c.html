
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.0983524712930606%, Tokens: 11</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_length_teletex_string.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  static const struct {
4     int code, value;
5  } teletex_table[] = {
6  { '\0',  0 },
7  { '\a',  7 },
8  { '\b',  8 },
9  { '\t',  9 },
10  { '\n', 10 },
11  { '\v', 11 },
12  { '\f', 12 },
13  { '\r', 13 },
14  { ' ',  32 },
15  { '!',  33 },
16  { '"',  34 },
17  { '%',  37 },
18  { '&',  38 },
19  { '\'', 39 },
20  { '(',  40 },
21  { ')',  41 },
22  { '+',  43 },
23  { ',',  44 },
24  { '-',  45 },
25  { '.',  46 },
26  { '/',  47 },
27  { '0',  48 },
28  { '1',  49 },
29  { '2',  50 },
30  { '3',  51 },
31  { '4',  52 },
32  { '5',  53 },
33  { '6',  54 },
34  { '7',  55 },
35  { '8',  56 },
36  { '9',  57 },
37  { ':',  58 },
38  { ';',  59 },
39  { '<',  60 },
40  { '=',  61 },
41  { '>',  62 },
42  { '?',  63 },
43  { '@',  64 },
44  { 'A',  65 },
45  { 'B',  66 },
46  { 'C',  67 },
47  { 'D',  68 },
48  { 'E',  69 },
49  { 'F',  70 },
50  { 'G',  71 },
51  { 'H',  72 },
52  { 'I',  73 },
53  { 'J',  74 },
54  { 'K',  75 },
55  { 'L',  76 },
56  { 'M',  77 },
57  { 'N',  78 },
58  { 'O',  79 },
59  { 'P',  80 },
60  { 'Q',  81 },
61  { 'R',  82 },
62  { 'S',  83 },
63  { 'T',  84 },
64  { 'U',  85 },
65  { 'V',  86 },
66  { 'W',  87 },
67  { 'X',  88 },
68  { 'Y',  89 },
69  { 'Z',  90 },
70  { '[',  91 },
71  { ']',  93 },
72  { '_',  95 },
73  { 'a',  97 },
74  { 'b',  98 },
75  { 'c',  99 },
76  { 'd',  100 },
77  { 'e',  101 },
78  { 'f',  102 },
79  { 'g',  103 },
80  { 'h',  104 },
81  { 'i',  105 },
82  { 'j',  106 },
83  { 'k',  107 },
84  { 'l',  108 },
85  { 'm',  109 },
86  { 'n',  110 },
87  { 'o',  111 },
88  { 'p',  112 },
89  { 'q',  113 },
90  { 'r',  114 },
91  { 's',  115 },
92  { 't',  116 },
93  { 'u',  117 },
94  { 'v',  118 },
95  { 'w',  119 },
96  { 'x',  120 },
97  { 'y',  121 },
98  { 'z',  122 },
99  { '|',  124 },
100  { ' ',  160 },
101  { 0xa1, 161 },
102  { 0xa2, 162 },
103  { 0xa3, 163 },
104  { '$',  164 },
105  { 0xa5, 165 },
106  { '#',  166 },
107  { 0xa7, 167 },
108  { 0xa4, 168 },
109  { 0xab, 171 },
110  { 0xb0, 176 },
111  { 0xb1, 177 },
112  { 0xb2, 178 },
113  { 0xb3, 179 },
114  { 0xd7, 180 },
115  { 0xb5, 181 },
116  { 0xb6, 182 },
117  { 0xb7, 183 },
118  { 0xf7, 184 },
119  { 0xbb, 187 },
120  { 0xbc, 188 },
121  { 0xbd, 189 },
122  { 0xbe, 190 },
123  { 0xbf, 191 },
124  };
125  int der_teletex_char_encode(int c)
126  {
127     int x;
128     for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
129         if (teletex_table[x].code == c) {
130            return teletex_table[x].value;
131         }
132     }
133     return -1;
134  }
135  int der_teletex_value_decode(int v)
136  {
137     int x;
138     for (x = 0; x < (int)(sizeof(teletex_table)/sizeof(teletex_table[0])); x++) {
139         if (teletex_table[x].value == v) {
140            return teletex_table[x].code;
141         }
142     }
143     return -1;
144  }
145  int der_length_teletex_string(const unsigned char *octets, unsigned long noctets, unsigned long *outlen)
146  {
147     unsigned long x;
148     int err;
149     LTC_ARGCHK(outlen != NULL);
150     LTC_ARGCHK(octets != NULL);
<span onclick='openModal()' class='match'>151     for (x = 0; x < noctets; x++) {
152         if (der_teletex_char_encode(octets[x]) == -1) {
153            return CRYPT_INVALID_ARG;
154         }
155     }
156     if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
</span>157        return err;
158     }
159     *outlen = 1 + x + noctets;
160     return CRYPT_OK;
161  }
162  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "atomicvar.h"
7  #ifdef _WIN32
8  #include "Win32_Interop/Win32_QFork.h"
9  #else
10  #include <sys/uio.h>
11  #endif
12  #include <math.h>
13  #include <ctype.h>
14  WIN32_ONLY(extern int WSIOCP_QueueAccept(int listenfd);)
15  WIN32_ONLY(extern int WSIOCP_CloseSocketStateRFD(int listenfd);)
16  static void setProtocolError(const char *errstr, client *c);
17  size_t sdsZmallocSize(sds s) {
18      void *sh = sdsAllocPtr(s);
19      return zmalloc_size(sh);
20  }
21  size_t getStringObjectSdsUsedMemory(robj *o) {
22      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
23      switch(o->encoding) {
24      case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
25      case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
26      default: return 0; &bsol;* Just integer encoding for now. */
27      }
28  }
29  void *dupClientReplyValue(void *o) {
30      clientReplyBlock *old = o;
31      clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
32      memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
33      return buf;
34  }
35  void freeClientReplyValue(void *o) {
36      zfree(o);
37  }
38  int listMatchObjects(void *a, void *b) {
39      return equalStringObjects(a,b);
40  }
41  void linkClient(client *c) {
42      listAddNodeTail(server.clients,c);
43      c->client_list_node = listLast(server.clients);
44      uint64_t id = htonu64(c->id);
45      raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
46  }
47  client *createClient(int fd) {
48      client *c = zmalloc(sizeof(client));
49      if (fd != -1) {
50          anetNonBlock(NULL,fd);
51          anetEnableTcpNoDelay(NULL,fd);
52          if (server.tcpkeepalive)
53              anetKeepAlive(NULL,fd,server.tcpkeepalive);
54          if (aeCreateFileEvent(server.el,fd,AE_READABLE,
55              readQueryFromClient, c) == AE_ERR)
56          {
57              close(fd);
58              zfree(c);
59              return NULL;
60          }
61      }
62      selectDb(c,0);
63      uint64_t client_id;
64      atomicGetIncr(server.next_client_id,client_id,1);
65      c->id = client_id;
66      c->fd = fd;
67      c->name = NULL;
68      c->bufpos = 0;
69      c->qb_pos = 0;
70      c->querybuf = sdsempty();
71      c->pending_querybuf = sdsempty();
72      c->querybuf_peak = 0;
73      c->reqtype = 0;
74      c->argc = 0;
75      c->argv = NULL;
76      c->cmd = c->lastcmd = NULL;
77      c->multibulklen = 0;
78      c->bulklen = -1;
79      c->sentlen = 0;
80      c->flags = 0;
81      c->ctime = c->lastinteraction = server.unixtime;
82      c->authenticated = 0;
83      c->replstate = REPL_STATE_NONE;
84      c->repl_put_online_on_ack = 0;
85      c->reploff = 0;
86      c->read_reploff = 0;
87      c->repl_ack_off = 0;
88      c->repl_ack_time = 0;
89      c->slave_listening_port = 0;
90      c->slave_ip[0] = '\0';
91      c->slave_capa = SLAVE_CAPA_NONE;
92      c->reply = listCreate();
93      c->reply_bytes = 0;
94      c->obuf_soft_limit_reached_time = 0;
95      listSetFreeMethod(c->reply,freeClientReplyValue);
96      listSetDupMethod(c->reply,dupClientReplyValue);
97      c->btype = BLOCKED_NONE;
98      c->bpop.timeout = 0;
99      c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);
100      c->bpop.target = NULL;
101      c->bpop.xread_group = NULL;
102      c->bpop.xread_consumer = NULL;
103      c->bpop.xread_group_noack = 0;
104      c->bpop.numreplicas = 0;
105      c->bpop.reploffset = 0;
106      c->woff = 0;
107      c->watched_keys = listCreate();
108      c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
109      c->pubsub_patterns = listCreate();
110      c->peerid = NULL;
111      c->client_list_node = NULL;
112      listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
113      listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
114      if (fd != -1) linkClient(c);
115      initClientMultiState(c);
116      return c;
117  }
118  void clientInstallWriteHandler(client *c) {
119      if (!(c->flags & CLIENT_PENDING_WRITE) &&
120          (c->replstate == REPL_STATE_NONE ||
121           (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))
122      {
123          c->flags |= CLIENT_PENDING_WRITE;
124          listAddNodeHead(server.clients_pending_write,c);
125      }
126  }
127  int prepareClientToWrite(client *c) {
128      if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
129      if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
130      if ((c->flags & CLIENT_MASTER) &&
131          !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
132      if (c->fd <= 0) return C_ERR; &bsol;* Fake client for AOF loading. */
133      if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);
134      return C_OK;
135  }
136  int _addReplyToBuffer(client *c, const char *s, size_t len) {
137      size_t available = sizeof(c->buf)-c->bufpos;
138      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
139      if (listLength(c->reply) > 0) return C_ERR;
140      if (len > available) return C_ERR;
141      memcpy(c->buf+c->bufpos,s,len);
142      c->bufpos+=(int)len;                                                        WIN_PORT_FIX &bsol;* cast (int) */
143      return C_OK;
144  }
145  void _addReplyStringToList(client *c, const char *s, size_t len) {
146      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
147      listNode *ln = listLast(c->reply);
148      clientReplyBlock *tail = ln? listNodeValue(ln): NULL;
149      if (tail) {
150          size_t avail = tail->size - tail->used;
151          size_t copy = avail >= len? len: avail;
152          memcpy(tail->buf + tail->used, s, copy);
153          tail->used += copy;
154          s += copy;
155          len -= copy;
156      }
157      if (len) {
158          size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;
159          tail = zmalloc(size + sizeof(clientReplyBlock));
160          tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);
161          tail->used = len;
162          memcpy(tail->buf, s, len);
163          listAddNodeTail(c->reply, tail);
164          c->reply_bytes += tail->size;
165      }
166      asyncCloseClientOnOutputBufferLimitReached(c);
167  }
168  void addReply(client *c, robj *obj) {
169      if (prepareClientToWrite(c) != C_OK) return;
170      if (sdsEncodedObject(obj)) {
171          if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
172              _addReplyStringToList(c,obj->ptr,sdslen(obj->ptr));
173      } else if (obj->encoding == OBJ_ENCODING_INT) {
174          char buf[32];
175          size_t len = ll2string(buf,sizeof(buf),(PORT_LONG)obj->ptr);
176          if (_addReplyToBuffer(c,buf,len) != C_OK)
177              _addReplyStringToList(c,buf,len);
178      } else {
179          serverPanic("Wrong obj->encoding in addReply()");
180      }
181  }
182  void addReplySds(client *c, sds s) {
183      if (prepareClientToWrite(c) != C_OK) {
184          sdsfree(s);
185          return;
186      }
187      if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)
188          _addReplyStringToList(c,s,sdslen(s));
189      sdsfree(s);
190  }
191  void addReplyString(client *c, const char *s, size_t len) {
192      if (prepareClientToWrite(c) != C_OK) return;
193      if (_addReplyToBuffer(c,s,len) != C_OK)
194          _addReplyStringToList(c,s,len);
195  }
196  void addReplyErrorLength(client *c, const char *s, size_t len) {
197      if (!len || s[0] != '-') addReplyString(c,"-ERR ",5);
198      addReplyString(c,s,len);
199      addReplyString(c,"\r\n",2);
200      if (c->flags & (CLIENT_MASTER|CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
201          char* to = c->flags & CLIENT_MASTER? "master": "replica";
202          char* from = c->flags & CLIENT_MASTER? "replica": "master";
203          char *cmdname = c->lastcmd ? c->lastcmd->name : "<unknown>";
204          serverLog(LL_WARNING,"== CRITICAL == This %s is sending an error "
205                               "to its %s: '%s' after processing the command "
206                               "'%s'", from, to, s, cmdname);
207      }
208  }
209  void addReplyError(client *c, const char *err) {
210      addReplyErrorLength(c,err,strlen(err));
211  }
212  void addReplyErrorFormat(client *c, const char *fmt, ...) {
213      size_t l, j;
214      va_list ap;
215      va_start(ap,fmt);
216      sds s = sdscatvprintf(sdsempty(),fmt,ap);
217      va_end(ap);
218      l = sdslen(s);
219      for (j = 0; j < l; j++) {
220          if (s[j] == '\r' || s[j] == '\n') s[j] = ' ';
221      }
222      addReplyErrorLength(c,s,sdslen(s));
223      sdsfree(s);
224  }
225  void addReplyStatusLength(client *c, const char *s, size_t len) {
226      addReplyString(c,"+",1);
227      addReplyString(c,s,len);
228      addReplyString(c,"\r\n",2);
229  }
230  void addReplyStatus(client *c, const char *status) {
231      addReplyStatusLength(c,status,strlen(status));
232  }
233  void addReplyStatusFormat(client *c, const char *fmt, ...) {
234      va_list ap;
235      va_start(ap,fmt);
236      sds s = sdscatvprintf(sdsempty(),fmt,ap);
237      va_end(ap);
238      addReplyStatusLength(c,s,sdslen(s));
239      sdsfree(s);
240  }
241  void *addDeferredMultiBulkLength(client *c) {
242      if (prepareClientToWrite(c) != C_OK) return NULL;
243      listAddNodeTail(c->reply,NULL); &bsol;* NULL is our placeholder. */
244      return listLast(c->reply);
245  }
246  void setDeferredMultiBulkLength(client *c, void *node, PORT_LONG length) {
247      listNode *ln = (listNode*)node;
248      clientReplyBlock *next;
249      char lenstr[128];
250      size_t lenstr_len = sprintf(lenstr, "*%ld\r\n", length);
251      if (node == NULL) return;
252      serverAssert(!listNodeValue(ln));
253      if (ln->next != NULL && (next = listNodeValue(ln->next)) &&
254          next->size - next->used >= lenstr_len &&
255          next->used < PROTO_REPLY_CHUNK_BYTES * 4) {
256          memmove(next->buf + lenstr_len, next->buf, next->used);
257          memcpy(next->buf, lenstr, lenstr_len);
258          next->used += lenstr_len;
259          listDelNode(c->reply,ln);
260      } else {
261          clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));
262          buf->size = zmalloc_usable(buf) - sizeof(clientReplyBlock);
263          buf->used = lenstr_len;
264          memcpy(buf->buf, lenstr, lenstr_len);
265          listNodeValue(ln) = buf;
266          c->reply_bytes += buf->size;
267      }
268      asyncCloseClientOnOutputBufferLimitReached(c);
269  }
270  void addReplyDouble(client *c, double d) {
271      char dbuf[128], sbuf[128];
272      int dlen, slen;
273      if (isinf(d)) {
274          addReplyBulkCString(c, d > 0 ? "inf" : "-inf");
275      } else {
276          dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
277          slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
278          addReplyString(c,sbuf,slen);
279      }
280  }
281  void addReplyHumanLongDouble(client *c, PORT_LONGDOUBLE d) {
282      robj *o = createStringObjectFromLongDouble(d,1);
283      addReplyBulk(c,o);
284      decrRefCount(o);
285  }
286  void addReplyLongLongWithPrefix(client *c, PORT_LONGLONG ll, char prefix) {
287      char buf[128];
288      int len;
289      if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
290          addReply(c,shared.mbulkhdr[ll]);
291          return;
292      } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
293          addReply(c,shared.bulkhdr[ll]);
294          return;
295      }
296      buf[0] = prefix;
297      len = ll2string(buf+1,sizeof(buf)-1,ll);
298      buf[len+1] = '\r';
299      buf[len+2] = '\n';
300      addReplyString(c,buf,(size_t)len+3);  WIN_PORT_FIX &bsol;* cast (size_t) */
301  }
302  void addReplyLongLong(client *c, PORT_LONGLONG ll) {
303      if (ll == 0)
304          addReply(c,shared.czero);
305      else if (ll == 1)
306          addReply(c,shared.cone);
307      else
308          addReplyLongLongWithPrefix(c,ll,':');
309  }
310  void addReplyMultiBulkLen(client *c, PORT_LONG length) {
311      if (length < OBJ_SHARED_BULKHDR_LEN)
312          addReply(c,shared.mbulkhdr[length]);
313      else
314          addReplyLongLongWithPrefix(c,length,'*');
315  }
316  void addReplyBulkLen(client *c, robj *obj) {
317      size_t len;
318      if (sdsEncodedObject(obj)) {
319          len = sdslen(obj->ptr);
320      } else {
321          PORT_LONG n = (PORT_LONG)obj->ptr;
322          len = 1;
323          if (n < 0) {
324              len++;
325              n = -n;
326          }
327          while((n = n/10) != 0) {
328              len++;
329          }
330      }
331      if (len < OBJ_SHARED_BULKHDR_LEN)
332          addReply(c,shared.bulkhdr[len]);
333      else
334          addReplyLongLongWithPrefix(c,len,'$');
335  }
336  void addReplyBulk(client *c, robj *obj) {
337      addReplyBulkLen(c,obj);
338      addReply(c,obj);
339      addReply(c,shared.crlf);
340  }
341  void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
342      addReplyLongLongWithPrefix(c,len,'$');
343      addReplyString(c,p,len);
344      addReply(c,shared.crlf);
345  }
346  void addReplyBulkSds(client *c, sds s)  {
347      addReplyLongLongWithPrefix(c,sdslen(s),'$');
348      addReplySds(c,s);
349      addReply(c,shared.crlf);
350  }
351  void addReplyBulkCString(client *c, const char *s) {
352      if (s == NULL) {
353          addReply(c,shared.nullbulk);
354      } else {
355          addReplyBulkCBuffer(c,s,strlen(s));
356      }
357  }
358  void addReplyBulkLongLong(client *c, PORT_LONGLONG ll) {
359      char buf[64];
360      int len;
361      len = ll2string(buf,64,ll);
362      addReplyBulkCBuffer(c,buf,len);
363  }
364  void addReplyHelp(client *c, const char **help) {
365      sds cmd = sdsnew((char*) c->argv[0]->ptr);
366      void *blenp = addDeferredMultiBulkLength(c);
367      int blen = 0;
368      sdstoupper(cmd);
369      addReplyStatusFormat(c,
370          "%s <subcommand> arg arg ... arg. Subcommands are:",cmd);
371      sdsfree(cmd);
372      while (help[blen]) addReplyStatus(c,help[blen++]);
373      blen++;  &bsol;* Account for the header line(s). */
374      setDeferredMultiBulkLength(c,blenp,blen);
375  }
376  void addReplySubcommandSyntaxError(client *c) {
377      sds cmd = sdsnew((char*) c->argv[0]->ptr);
378      sdstoupper(cmd);
379      addReplyErrorFormat(c,
380          "Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.",
381          (char*)c->argv[1]->ptr,cmd);
382      sdsfree(cmd);
383  }
384  void AddReplyFromClient(client *dst, client *src) {
385      if (prepareClientToWrite(dst) != C_OK)
386          return;
387      addReplyString(dst,src->buf, src->bufpos);
388      if (listLength(src->reply))
389          listJoin(dst->reply,src->reply);
390      dst->reply_bytes += src->reply_bytes;
391      src->reply_bytes = 0;
392      src->bufpos = 0;
393  }
394  void copyClientOutputBuffer(client *dst, client *src) {
395      listRelease(dst->reply);
396      dst->sentlen = 0;
397      dst->reply = listDup(src->reply);
398      memcpy(dst->buf,src->buf,src->bufpos);
399      dst->bufpos = src->bufpos;
400      dst->reply_bytes = src->reply_bytes;
401  }
402  int clientHasPendingReplies(client *c) {
403      return c->bufpos || listLength(c->reply);
404  }
405  #define MAX_ACCEPTS_PER_CALL 1000
406  static void acceptCommonHandler(int fd, int flags, char *ip) {
407      client *c;
408      if ((c = createClient(fd)) == NULL) {
409          serverLog(LL_WARNING,
410              "Error registering fd event for the new client: %s (fd=%d)",
411              IF_WIN32(wsa_strerror(errno), strerror(errno)),fd);
412          close(fd); &bsol;* May be already closed, just ignore errors */
413          return;
414      }
415      if (listLength(server.clients) > (PORT_ULONG) server.maxclients) {
416          char *err = "-ERR max number of clients reached\r\n";
417          if (write(c->fd,err,strlen(err)) == -1) {
418          }
419          server.stat_rejected_conn++;
420  #ifdef _WIN32
421          freeClientAsync(c);
422  #else
423          freeClient(c);
424  #endif
425          return;
426      }
427      if (server.protected_mode &&
428          server.bindaddr_count == 0 &&
429          server.requirepass == NULL &&
430          !(flags & CLIENT_UNIX_SOCKET) &&
431          ip != NULL)
432      {
433          if (strcmp(ip,"127.0.0.1") && strcmp(ip,"::1")) {
434              char *err =
435                  "-DENIED Redis is running in protected mode because protected "
436                  "mode is enabled, no bind address was specified, no "
437                  "authentication password is requested to clients. In this mode "
438                  "connections are only accepted from the loopback interface. "
439                  "If you want to connect from external computers to Redis you "
440                  "may adopt one of the following solutions: "
441                  "1) Just disable protected mode sending the command "
442                  "'CONFIG SET protected-mode no' from the loopback interface "
443                  "by connecting to Redis from the same host the server is "
444                  "running, however MAKE SURE Redis is not publicly accessible "
445                  "from internet if you do so. Use CONFIG REWRITE to make this "
446                  "change permanent. "
447                  "2) Alternatively you can just disable the protected mode by "
448                  "editing the Redis configuration file, and setting the protected "
449                  "mode option to 'no', and then restarting the server. "
450                  "3) If you started the server manually just for testing, restart "
451                  "it with the '--protected-mode no' option. "
452                  "4) Setup a bind address or an authentication password. "
453                  "NOTE: You only need to do one of the above things in order for "
454                  "the server to start accepting connections from the outside.\r\n";
455              if (write(c->fd,err,strlen(err)) == -1) {
456              }
457              server.stat_rejected_conn++;
458              freeClient(c);
459              return;
460          }
461      }
462      server.stat_numconnections++;
463      c->flags |= flags;
464  }
465  void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
466      int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
467      char cip[NET_IP_STR_LEN];
468      UNUSED(el);
469      UNUSED(mask);
470      UNUSED(privdata);
471      while(max--) {
472          cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
473          if (cfd == ANET_ERR) {
474              if (errno != EWOULDBLOCK) {
475                  serverLog(LL_WARNING,
476                      "Accepting client connection: %s", server.neterr);
477  #ifdef _WIN32
478                  if (WSIOCP_QueueAccept(fd) == -1) {
479                      serverLog(LL_WARNING,
480                          "acceptTcpHandler: failed to queue another accept.");
481                  }
482  #endif
483              }
484              return;
485          }
486          serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
487          acceptCommonHandler(cfd,0,cip);
488      }
489  }
490  void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
491      int cfd, max = MAX_ACCEPTS_PER_CALL;
492      UNUSED(el);
493      UNUSED(mask);
494      UNUSED(privdata);
495      while(max--) {
496          cfd = anetUnixAccept(server.neterr, fd);
497          if (cfd == ANET_ERR) {
498              if (errno != EWOULDBLOCK)
499                  serverLog(LL_WARNING,
500                      "Accepting client connection: %s", server.neterr);
501              return;
502          }
503          serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
504          acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
505      }
506  }
507  static void freeClientArgv(client *c) {
508      int j;
509      for (j = 0; j < c->argc; j++)
510          decrRefCount(c->argv[j]);
511      c->argc = 0;
512      c->cmd = NULL;
513  }
514  void disconnectSlaves(void) {
515      while (listLength(server.slaves)) {
516          listNode *ln = listFirst(server.slaves);
517          freeClient((client*)ln->value);
518      }
519  }
520  void unlinkClient(client *c) {
521      listNode *ln;
522      if (server.current_client == c) server.current_client = NULL;
523      if (c->fd != -1) {
524          if (c->client_list_node) {
525              uint64_t id = htonu64(c->id);
526              raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
527              listDelNode(server.clients,c->client_list_node);
528              c->client_list_node = NULL;
529          }
530          if ((c->flags & CLIENT_SLAVE) &&
531              (c->replstate == SLAVE_STATE_WAIT_BGSAVE_END)) {
532  #ifdef _WIN32
533  			WSIOCP_CloseSocketStateRFD(c->fd); 
534  #else
535  			shutdown(c->fd, SHUT_RDWR);
536  #endif
537          }
538          aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
539          aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
540          close(c->fd);
541          c->fd = -1;
542      }
543      if (c->flags & CLIENT_PENDING_WRITE) {
544          ln = listSearchKey(server.clients_pending_write,c);
545          serverAssert(ln != NULL);
546          listDelNode(server.clients_pending_write,ln);
547          c->flags &= ~CLIENT_PENDING_WRITE;
548      }
549      if (c->flags & CLIENT_UNBLOCKED) {
550          ln = listSearchKey(server.unblocked_clients,c);
551          serverAssert(ln != NULL);
552          listDelNode(server.unblocked_clients,ln);
553          c->flags &= ~CLIENT_UNBLOCKED;
554      }
555  }
556  void freeClient(client *c) {
557      listNode *ln;
558      if (c->flags & CLIENT_PROTECTED) {
559          freeClientAsync(c);
560          return;
561      }
562      if (server.master && c->flags & CLIENT_MASTER) {
563          serverLog(LL_WARNING,"Connection with master lost.");
564          if (!(c->flags & (CLIENT_CLOSE_AFTER_REPLY|
565                            CLIENT_CLOSE_ASAP|
566                            CLIENT_BLOCKED)))
567          {
568              replicationCacheMaster(c);
569              return;
570          }
571      }
572      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
573          serverLog(LL_WARNING,"Connection with replica %s lost.",
574              replicationGetSlaveName(c));
575      }
576      sdsfree(c->querybuf);
577      sdsfree(c->pending_querybuf);
578      c->querybuf = NULL;
579      if (c->flags & CLIENT_BLOCKED) unblockClient(c);
580      dictRelease(c->bpop.keys);
581      unwatchAllKeys(c);
582      listRelease(c->watched_keys);
583      pubsubUnsubscribeAllChannels(c,0);
584      pubsubUnsubscribeAllPatterns(c,0);
585      dictRelease(c->pubsub_channels);
586      listRelease(c->pubsub_patterns);
587      listRelease(c->reply);
588      freeClientArgv(c);
589      unlinkClient(c);
590      if (c->flags & CLIENT_SLAVE) {
591          if (c->replstate == SLAVE_STATE_SEND_BULK) {
592  #ifdef _WIN32
593              if (c->repldbfd != -1) {
594                  DeleteFileA(c->replFileCopy);
595                  memset(c->replFileCopy, 0, MAX_PATH);
596              }
597  #endif
598              if (c->repldbfd != -1) close(c->repldbfd);
599              if (c->replpreamble) sdsfree(c->replpreamble);
600          }
601          list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;
602          ln = listSearchKey(l,c);
603          serverAssert(ln != NULL);
604          listDelNode(l,ln);
605          if (getClientType(c) == CLIENT_TYPE_SLAVE && listLength(server.slaves) == 0)
606              server.repl_no_slaves_since = server.unixtime;
607          refreshGoodSlavesCount();
608      }
609      if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();
610      if (c->flags & CLIENT_CLOSE_ASAP) {
611          ln = listSearchKey(server.clients_to_close,c);
612          serverAssert(ln != NULL);
613          listDelNode(server.clients_to_close,ln);
614      }
615      if (c->name) decrRefCount(c->name);
616      zfree(c->argv);
617      freeClientMultiState(c);
618      sdsfree(c->peerid);
619      zfree(c);
620  }
621  void freeClientAsync(client *c) {
622      if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
623      c->flags |= CLIENT_CLOSE_ASAP;
624      listAddNodeTail(server.clients_to_close,c);
625  }
626  void freeClientsInAsyncFreeQueue(void) {
627      while (listLength(server.clients_to_close)) {
628          listNode *ln = listFirst(server.clients_to_close);
629          client *c = listNodeValue(ln);
630          c->flags &= ~CLIENT_CLOSE_ASAP;
631          freeClient(c);
632          listDelNode(server.clients_to_close,ln);
633      }
634  }
635  client *lookupClientByID(uint64_t id) {
636      id = htonu64(id);
637      client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
638      return (c == raxNotFound) ? NULL : c;
639  }
640  int writeToClient(int fd, client *c, int handler_installed) {
641      ssize_t nwritten = 0, totwritten = 0;
642      size_t objlen;
643      clientReplyBlock *o;
644      while(clientHasPendingReplies(c)) {
645          if (c->bufpos > 0) {
646  #ifdef _WIN32
647              nwritten = c->bufpos - c->sentlen;
648              int result = WSIOCP_SocketSend(fd, c->buf + c->sentlen, nwritten,
649                  server.el, c, c->buf, NULL);
650              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
651                  nwritten = -1;
652                  if (errno == WSAEWOULDBLOCK) {
653                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
654                      errno = EAGAIN;
655                  }
656                  break;
657              }
658  #else
659              nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
660              if (nwritten <= 0) break;
661  #endif
662              c->sentlen += nwritten;
663              totwritten += nwritten;
664              if ((int)c->sentlen == c->bufpos) {
665                  c->bufpos = 0;
666                  c->sentlen = 0;
667              }
668          } else {
669              o = listNodeValue(listFirst(c->reply));
670              objlen = o->used;
671              if (objlen == 0) {
672                  c->reply_bytes -= o->size;
673                  listDelNode(c->reply,listFirst(c->reply));
674                  continue;
675              }
676  #ifdef _WIN32
677  			nwritten = objlen - c->sentlen;
678              int result = WSIOCP_SocketSend(fd, o->buf+c->sentlen, nwritten,
679                  server.el, c, o->buf, NULL);
680              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
681                  nwritten = -1;
682                  if (errno == WSAEWOULDBLOCK) {
683                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
684                      errno = EAGAIN;
685                  }
686                  break;
687              }
688  			if (nwritten <= 0) break;
689              c->sentlen += nwritten;
690              totwritten += nwritten;
691  #else
692              nwritten = write(fd, o->buf + c->sentlen, objlen - c->sentlen);
693              if (nwritten <= 0) break;
694              c->sentlen += nwritten;
695              totwritten += nwritten;
696  #endif
697              if (c->sentlen == objlen) {
698                  c->reply_bytes -= (PORT_ULONG)o->size;
699                  listDelNode(c->reply,listFirst(c->reply));
700                  c->sentlen = 0;
701                  if (listLength(c->reply) == 0)
702                      serverAssert(c->reply_bytes == 0);
703              }
704          }
705          if (totwritten > NET_MAX_WRITES_PER_EVENT &&
706              (server.maxmemory == 0 ||
707               zmalloc_used_memory() < server.maxmemory) &&
708              !(c->flags & CLIENT_SLAVE)) break;
709      }
710      server.stat_net_output_bytes += totwritten;
711      if (nwritten == -1) {
712          if (errno == EAGAIN) {
713              nwritten = 0;
714          } else {
715              serverLog(LL_VERBOSE,
716                  "Error writing to client: %s", IF_WIN32(wsa_strerror,strerror)(errno));
717              freeClient(c);
718              return C_ERR;
719          }
720      }
721      if (totwritten > 0) {
722          if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;
723      }
724      if (!clientHasPendingReplies(c)) {
725          c->sentlen = 0;
726          if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
727          if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
728  #ifdef _WIN32
729              freeClientAsync(c);
730  #else
731              freeClient(c);
732  #endif
733              return C_ERR;
734          }
735      }
736  #if _WIN32
737      else if (handler_installed) {
738          if (aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
739              sendReplyToClient, c) == AE_ERR)
740          {
741              serverLog(LL_WARNING, "writeToClient: aeCreateFileEvent failed");
742              freeClientAsync(c);
743              return C_ERR;
744          }
745          else {
746              serverLog(LL_DEBUG, "writeToClient: re-scheduling sendReplyToClient() for pending client replies");
747          }
748      }
749  #endif
750      return C_OK;
751  }
752  void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
753      UNUSED(el);
754      UNUSED(mask);
755      writeToClient(fd,privdata,1);
756  }
757  int handleClientsWithPendingWrites(void) {
758      listIter li;
759      listNode *ln;
760      int processed = listLength(server.clients_pending_write);
761      listRewind(server.clients_pending_write,&li);
762      while((ln = listNext(&li))) {
763          client *c = listNodeValue(ln);
764          c->flags &= ~CLIENT_PENDING_WRITE;
765          listDelNode(server.clients_pending_write,ln);
766          if (c->flags & CLIENT_PROTECTED) continue;
767          if (writeToClient(c->fd,c,0) == C_ERR) continue;
768          if (clientHasPendingReplies(c)) {
769              int ae_flags = AE_WRITABLE;
770              if (server.aof_state == AOF_ON &&
771                  server.aof_fsync == AOF_FSYNC_ALWAYS)
772              {
773                  ae_flags |= AE_BARRIER;
774              }
775              if (aeCreateFileEvent(server.el, c->fd, ae_flags,
776                  sendReplyToClient, c) == AE_ERR)
777              {
778                      freeClientAsync(c);
779              }
780          }
781      }
782      return processed;
783  }
784  void resetClient(client *c) {
785      redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
786      freeClientArgv(c);
787      c->reqtype = 0;
788      c->multibulklen = 0;
789      c->bulklen = -1;
790      if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)
791          c->flags &= ~CLIENT_ASKING;
792      c->flags &= ~CLIENT_REPLY_SKIP;
793      if (c->flags & CLIENT_REPLY_SKIP_NEXT) {
794          c->flags |= CLIENT_REPLY_SKIP;
795          c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
796      }
797  }
798  void protectClient(client *c) {
799      c->flags |= CLIENT_PROTECTED;
800      aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
801      aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
802  }
803  void unprotectClient(client *c) {
804      if (c->flags & CLIENT_PROTECTED) {
805          c->flags &= ~CLIENT_PROTECTED;
806          aeCreateFileEvent(server.el,c->fd,AE_READABLE,readQueryFromClient,c);
807          if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);
808      }
809  }
810  int processInlineBuffer(client *c) {
811      char *newline;
812      int argc, j, linefeed_chars = 1;
813      sds *argv, aux;
814      size_t querylen;
815      newline = strchr(c->querybuf+c->qb_pos,'\n');
816      if (newline == NULL) {
817          if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
818              addReplyError(c,"Protocol error: too big inline request");
819              setProtocolError("too big inline request",c);
820          }
821          return C_ERR;
822      }
823      if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
824          newline--, linefeed_chars++;
825      querylen = newline-(c->querybuf+c->qb_pos);
826      aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
827      argv = sdssplitargs(aux,&argc);
828      sdsfree(aux);
829      if (argv == NULL) {
830          addReplyError(c,"Protocol error: unbalanced quotes in request");
831          setProtocolError("unbalanced quotes in inline request",c);
832          return C_ERR;
833      }
834      if (querylen == 0 && getClientType(c) == CLIENT_TYPE_SLAVE)
835          c->repl_ack_time = server.unixtime;
836      c->qb_pos += querylen+linefeed_chars;
837      if (argc) {
838          if (c->argv) zfree(c->argv);
839          c->argv = zmalloc(sizeof(robj*)*argc);
840      }
841      for (c->argc = 0, j = 0; j < argc; j++) {
842          c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);
843          c->argc++;
844      }
845      zfree(argv);
846      return C_OK;
847  }
848  #define PROTO_DUMP_LEN 128
849  static void setProtocolError(const char *errstr, client *c) {
850      if (server.verbosity <= LL_VERBOSE) {
851          sds client = catClientInfoString(sdsempty(),c);
852          char buf[256];
853          if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
854              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%s'", c->querybuf+c->qb_pos);
855          } else {
856              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%.*s' (... more %Iu bytes ...) '%.*s'", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2); WIN_PORT_FIX &bsol;* %zu -> %Iu */
857          }
858          char *p = buf;
859          while (*p != '\0') {
860              if (!isprint(*p)) *p = '.';
861              p++;
862          }
863          serverLog(LL_VERBOSE,
864              "Protocol error (%s) from client: %s. %s", errstr, client, buf);
865          sdsfree(client);
866      }
867      c->flags |= CLIENT_CLOSE_AFTER_REPLY;
868  }
869  int processMultibulkBuffer(client *c) {
870      char *newline = NULL;
871      int ok;
872      PORT_LONGLONG ll;
873      if (c->multibulklen == 0) {
874          serverAssertWithInfo(c,NULL,c->argc == 0);
875          newline = strchr(c->querybuf+c->qb_pos,'\r');
876          if (newline == NULL) {
877              if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
878                  addReplyError(c,"Protocol error: too big mbulk count string");
879                  setProtocolError("too big mbulk count string",c);
880              }
881              return C_ERR;
882          }
883          if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
884              return C_ERR;
885          serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');
886          ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);
887          if (!ok || ll > 1024*1024) {
888              addReplyError(c,"Protocol error: invalid multibulk length");
889              setProtocolError("invalid mbulk count",c);
890              return C_ERR;
891          }
892          c->qb_pos = (newline-c->querybuf)+2;
893          if (ll <= 0) return C_OK;
894          c->multibulklen = (int)ll;
895          if (c->argv) zfree(c->argv);
896          c->argv = zmalloc(sizeof(robj*)*c->multibulklen);
897      }
898      serverAssertWithInfo(c,NULL,c->multibulklen > 0);
899      while(c->multibulklen) {
900          if (c->bulklen == -1) {
901              newline = strchr(c->querybuf+c->qb_pos,'\r');
902              if (newline == NULL) {
903                  if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
904                      addReplyError(c,
905                          "Protocol error: too big bulk count string");
906                      setProtocolError("too big bulk count string",c);
907                      return C_ERR;
908                  }
909                  break;
910              }
911              if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
912                  break;
913              if (c->querybuf[c->qb_pos] != '$') {
914                  addReplyErrorFormat(c,
915                      "Protocol error: expected '$', got '%c'",
916                      c->querybuf[c->qb_pos]);
917                  setProtocolError("expected $ but got something else",c);
918                  return C_ERR;
919              }
920              ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);
921              if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
922                  addReplyError(c,"Protocol error: invalid bulk length");
923                  setProtocolError("invalid bulk length",c);
924                  return C_ERR;
925              }
926              c->qb_pos = newline-c->querybuf+2;
927              if (ll >= PROTO_MBULK_BIG_ARG) {
928                  if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {
929                      sdsrange(c->querybuf,c->qb_pos,-1);
930                      c->qb_pos = 0;
931                      c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2);
932                  }
933              }
934              c->bulklen = (PORT_LONG)ll;                                        WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
935          }
936          if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {
937              break;
938          } else {
939              if (c->qb_pos == 0 &&
940                  c->bulklen >= PROTO_MBULK_BIG_ARG &&
941                  sdslen(c->querybuf) == (size_t)(c->bulklen+2))
942              {
943                  c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);
944                  sdsIncrLen(c->querybuf,-2); &bsol;* remove CRLF */
945                  c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);
946                  sdsclear(c->querybuf);
947              } else {
948                  c->argv[c->argc++] =
949                      createStringObject(c->querybuf+c->qb_pos,c->bulklen);
950                  c->qb_pos += c->bulklen+2;
951              }
952              c->bulklen = -1;
953              c->multibulklen--;
954          }
955      }
956      if (c->multibulklen == 0) return C_OK;
957      return C_ERR;
958  }
959  void processInputBuffer(client *c) {
960      server.current_client = c;
961      while(c->qb_pos < sdslen(c->querybuf)) {
962          if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;
963          if (c->flags & CLIENT_BLOCKED) break;
964          if (server.lua_timedout && c->flags & CLIENT_MASTER) break;
965          if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
966          if (!c->reqtype) {
967              if (c->querybuf[c->qb_pos] == '*') {
968                  c->reqtype = PROTO_REQ_MULTIBULK;
969              } else {
970                  c->reqtype = PROTO_REQ_INLINE;
971              }
972          }
973          if (c->reqtype == PROTO_REQ_INLINE) {
974              if (processInlineBuffer(c) != C_OK) break;
975          } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
976              if (processMultibulkBuffer(c) != C_OK) break;
977          } else {
978              serverPanic("Unknown request type");
979          }
980          if (c->argc == 0) {
981              resetClient(c);
982          } else {
983              if (processCommand(c) == C_OK) {
984                  if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
985                      c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
986                  }
987                  if (!(c->flags & CLIENT_BLOCKED) || c->btype != BLOCKED_MODULE)
988                      resetClient(c);
989              }
990              if (server.current_client == NULL) break;
991          }
992      }
993      if (server.current_client != NULL && c->qb_pos) {
994          sdsrange(c->querybuf,c->qb_pos,-1);
995          c->qb_pos = 0;
996      }
997      server.current_client = NULL;
998  }
999  void processInputBufferAndReplicate(client *c) {
1000      if (!(c->flags & CLIENT_MASTER)) {
1001          processInputBuffer(c);
1002      } else {
1003          size_t prev_offset = c->reploff;
1004          processInputBuffer(c);
1005          size_t applied = c->reploff - prev_offset;
1006          if (applied) {
1007              replicationFeedSlavesFromMasterStream(server.slaves,
1008                      c->pending_querybuf, applied);
1009              sdsrange(c->pending_querybuf,applied,-1);
1010          }
1011      }
1012  }
1013  void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
1014      client *c = (client*) privdata;
1015      int nread, readlen;
1016      size_t qblen;
1017      UNUSED(el);
1018      UNUSED(mask);
1019      readlen = PROTO_IOBUF_LEN;
1020      if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
1021          && c->bulklen >= PROTO_MBULK_BIG_ARG)
1022      {
1023          ssize_t remaining = (size_t)(c->bulklen+2)-sdslen(c->querybuf);
1024          if (remaining > 0 && remaining < readlen) readlen = remaining;
1025      }
1026      qblen = sdslen(c->querybuf);
1027      if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;
1028      c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
1029      nread = (int)read(fd, c->querybuf+qblen, readlen);                          WIN_PORT_FIX &bsol;* cast (int) */
1030      if (nread == -1) {
1031          if (errno == EAGAIN) {
1032              return;
1033          } else {
1034              serverLog(LL_VERBOSE, "Reading from client: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1035              freeClient(c);
1036              return;
1037          }
1038      } else if (nread == 0) {
1039          serverLog(LL_VERBOSE, "Client closed connection");
1040          freeClient(c);
1041          return;
1042      } else if (c->flags & CLIENT_MASTER) {
1043          c->pending_querybuf = sdscatlen(c->pending_querybuf,
1044                                          c->querybuf+qblen,nread);
1045      }
1046      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1047      sdsIncrLen(c->querybuf,nread);
1048      c->lastinteraction = server.unixtime;
1049      if (c->flags & CLIENT_MASTER) c->read_reploff += nread;
1050      server.stat_net_input_bytes += nread;
1051      if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
1052          sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
1053          bytes = sdscatrepr(bytes,c->querybuf,64);
1054          serverLog(LL_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
1055          sdsfree(ci);
1056          sdsfree(bytes);
1057          freeClient(c);
1058          return;
1059      }
1060      processInputBufferAndReplicate(c);
1061  }
1062  void getClientsMaxBuffers(PORT_ULONG *longest_output_list,
1063                            PORT_ULONG *biggest_input_buffer) {
1064      client *c;
1065      listNode *ln;
1066      listIter li;
1067      PORT_ULONG lol = 0, bib = 0;
1068      listRewind(server.clients,&li);
1069      while ((ln = listNext(&li)) != NULL) {
1070          c = listNodeValue(ln);
1071          if (listLength(c->reply) > lol) lol = listLength(c->reply);
1072          if (sdslen(c->querybuf) > bib) bib = (PORT_ULONG)sdslen(c->querybuf);   WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1073      }
1074      *longest_output_list = lol;
1075      *biggest_input_buffer = bib;
1076  }
1077  void genClientPeerId(client *client, char *peerid,
1078                              size_t peerid_len) {
1079      if (client->flags & CLIENT_UNIX_SOCKET) {
1080          snprintf(peerid,peerid_len,"%s:0",server.unixsocket);
1081      } else {
1082          anetFormatPeer(client->fd,peerid,peerid_len);
1083      }
1084  }
1085  char *getClientPeerId(client *c) {
1086      char peerid[NET_PEER_ID_LEN];
1087      if (c->peerid == NULL) {
1088          genClientPeerId(c,peerid,sizeof(peerid));
1089          c->peerid = sdsnew(peerid);
1090      }
1091      return c->peerid;
1092  }
1093  sds catClientInfoString(sds s, client *client) {
1094      char flags[16], events[3], *p;
1095      int emask;
1096      p = flags;
1097      if (client->flags & CLIENT_SLAVE) {
1098          if (client->flags & CLIENT_MONITOR)
1099              *p++ = 'O';
1100          else
1101              *p++ = 'S';
1102      }
1103      if (client->flags & CLIENT_MASTER) *p++ = 'M';
1104      if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
1105      if (client->flags & CLIENT_MULTI) *p++ = 'x';
1106      if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
1107      if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
1108      if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
1109      if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
1110      if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
1111      if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
1112      if (client->flags & CLIENT_READONLY) *p++ = 'r';
1113      if (p == flags) *p++ = 'N';
1114      *p++ = '\0';
1115      emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
1116      p = events;
1117      if (emask & AE_READABLE) *p++ = 'r';
1118      if (emask & AE_WRITABLE) *p++ = 'w';
1119      *p = '\0';
1120      return sdscatfmt(s,
1121          "id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s",
1122          (PORT_ULONGLONG) client->id,
1123          getClientPeerId(client),
1124          client->fd,
1125          client->name ? (char*)client->name->ptr : "",
1126          (PORT_LONGLONG)(server.unixtime - client->ctime),
1127          (PORT_LONGLONG)(server.unixtime - client->lastinteraction),
1128          flags,
1129          client->db->id,
1130          (int) dictSize(client->pubsub_channels),
1131          (int) listLength(client->pubsub_patterns),
1132          (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,
1133          (PORT_ULONGLONG) sdslen(client->querybuf),
1134          (PORT_ULONGLONG) sdsavail(client->querybuf),
1135          (PORT_ULONGLONG) client->bufpos,
1136          (PORT_ULONGLONG) listLength(client->reply),
1137          (PORT_ULONGLONG) getClientOutputBufferMemoryUsage(client),
1138          events,
1139          client->lastcmd ? client->lastcmd->name : "NULL");
1140  }
1141  sds getAllClientsInfoString(int type) {
1142      listNode *ln;
1143      listIter li;
1144      client *client;
1145      sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
1146      sdsclear(o);
1147      listRewind(server.clients,&li);
1148      while ((ln = listNext(&li)) != NULL) {
1149          client = listNodeValue(ln);
1150          if (type != -1 && getClientType(client) != type) continue;
1151          o = catClientInfoString(o,client);
1152          o = sdscatlen(o,"\n",1);
1153      }
1154      return o;
1155  }
1156  void clientCommand(client *c) {
1157      listNode *ln;
1158      listIter li;
1159      client *client;
1160      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
1161          const char *help[] = {
1162  "id                     -- Return the ID of the current connection.",
1163  "getname                -- Return the name of the current connection.",
1164  "kill <ip:port>         -- Kill connection made from <ip:port>.",
1165  "kill <option> <value> [option value ...] -- Kill connections. Options are:",
1166  "     addr <ip:port>                      -- Kill connection made from <ip:port>",
1167  "     type (normal|master|replica|pubsub) -- Kill connections by type.",
1168  "     skipme (yes|no)   -- Skip killing current connection (default: yes).",
1169  "list [options ...]     -- Return information about client connections. Options:",
1170  "     type (normal|master|replica|pubsub) -- Return clients of specified type.",
1171  "pause <timeout>        -- Suspend all Redis clients for <timout> milliseconds.",
1172  "reply (on|off|skip)    -- Control the replies sent to the current connection.",
1173  "setname <name>         -- Assign the name <name> to the current connection.",
1174  "unblock <clientid> [TIMEOUT|ERROR] -- Unblock the specified blocked client.",
1175  NULL
1176          };
1177          addReplyHelp(c, help);
1178      } else if (!strcasecmp(c->argv[1]->ptr,"id") && c->argc == 2) {
1179          addReplyLongLong(c,c->id);
1180      } else if (!strcasecmp(c->argv[1]->ptr,"list")) {
1181          int type = -1;
1182          if (c->argc == 4 && !strcasecmp(c->argv[2]->ptr,"type")) {
1183              type = getClientTypeByName(c->argv[3]->ptr);
1184              if (type == -1) {
1185                  addReplyErrorFormat(c,"Unknown client type '%s'",
1186                      (char*) c->argv[3]->ptr);
1187                  return;
1188               }
1189          } else if (c->argc != 2) {
1190              addReply(c,shared.syntaxerr);
1191              return;
1192          }
1193          sds o = getAllClientsInfoString(type);
1194          addReplyBulkCBuffer(c,o,sdslen(o));
1195          sdsfree(o);
1196      } else if (!strcasecmp(c->argv[1]->ptr,"reply") && c->argc == 3) {
1197          if (!strcasecmp(c->argv[2]->ptr,"on")) {
1198              c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);
1199              addReply(c,shared.ok);
1200          } else if (!strcasecmp(c->argv[2]->ptr,"off")) {
1201              c->flags |= CLIENT_REPLY_OFF;
1202          } else if (!strcasecmp(c->argv[2]->ptr,"skip")) {
1203              if (!(c->flags & CLIENT_REPLY_OFF))
1204                  c->flags |= CLIENT_REPLY_SKIP_NEXT;
1205          } else {
1206              addReply(c,shared.syntaxerr);
1207              return;
1208          }
1209      } else if (!strcasecmp(c->argv[1]->ptr,"kill")) {
1210          char *addr = NULL;
1211          int type = -1;
1212          uint64_t id = 0;
1213          int skipme = 1;
1214          int killed = 0, close_this_client = 0;
1215          if (c->argc == 3) {
1216              addr = c->argv[2]->ptr;
1217              skipme = 0; &bsol;* With the old form, you can kill yourself. */
1218          } else if (c->argc > 3) {
1219              int i = 2; &bsol;* Next option index. */
1220              while(i < c->argc) {
1221                  int moreargs = c->argc > i+1;
1222                  if (!strcasecmp(c->argv[i]->ptr,"id") && moreargs) {
1223                      PORT_LONGLONG tmp;
1224                      if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
1225                          != C_OK) return;
1226                      id = tmp;
1227                  } else if (!strcasecmp(c->argv[i]->ptr,"type") && moreargs) {
1228                      type = getClientTypeByName(c->argv[i+1]->ptr);
1229                      if (type == -1) {
1230                          addReplyErrorFormat(c,"Unknown client type '%s'",
1231                              (char*) c->argv[i+1]->ptr);
1232                          return;
1233                      }
1234                  } else if (!strcasecmp(c->argv[i]->ptr,"addr") && moreargs) {
1235                      addr = c->argv[i+1]->ptr;
1236                  } else if (!strcasecmp(c->argv[i]->ptr,"skipme") && moreargs) {
1237                      if (!strcasecmp(c->argv[i+1]->ptr,"yes")) {
1238                          skipme = 1;
1239                      } else if (!strcasecmp(c->argv[i+1]->ptr,"no")) {
1240                          skipme = 0;
1241                      } else {
1242                          addReply(c,shared.syntaxerr);
1243                          return;
1244                      }
1245                  } else {
1246                      addReply(c,shared.syntaxerr);
1247                      return;
1248                  }
1249                  i += 2;
1250              }
1251          } else {
1252              addReply(c,shared.syntaxerr);
1253              return;
1254          }
1255          listRewind(server.clients,&li);
1256          while ((ln = listNext(&li)) != NULL) {
1257              client = listNodeValue(ln);
1258              if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;
1259              if (type != -1 && getClientType(client) != type) continue;
1260              if (id != 0 && client->id != id) continue;
1261              if (c == client && skipme) continue;
1262              if (c == client) {
1263                  close_this_client = 1;
1264              } else {
1265                  freeClient(client);
1266              }
1267              killed++;
1268          }
1269          if (c->argc == 3) {
1270              if (killed == 0)
1271                  addReplyError(c,"No such client");
1272              else
1273                  addReply(c,shared.ok);
1274          } else {
1275              addReplyLongLong(c,killed);
1276          }
1277          if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1278      } else if (!strcasecmp(c->argv[1]->ptr,"unblock") && (c->argc == 3 ||
1279                                                            c->argc == 4))
1280      {
1281          PORT_LONGLONG id;
1282          int unblock_error = 0;
1283          if (c->argc == 4) {
1284              if (!strcasecmp(c->argv[3]->ptr,"timeout")) {
1285                  unblock_error = 0;
1286              } else if (!strcasecmp(c->argv[3]->ptr,"error")) {
1287                  unblock_error = 1;
1288              } else {
1289                  addReplyError(c,
1290                      "CLIENT UNBLOCK reason should be TIMEOUT or ERROR");
1291                  return;
1292              }
1293          }
1294          if (getLongLongFromObjectOrReply(c,c->argv[2],&id,NULL)
1295              != C_OK) return;
1296          struct client *target = lookupClientByID(id);
1297          if (target && target->flags & CLIENT_BLOCKED) {
1298              if (unblock_error)
1299                  addReplyError(target,
1300                      "-UNBLOCKED client unblocked via CLIENT UNBLOCK");
1301              else
1302                  replyToBlockedClientTimedOut(target);
1303              unblockClient(target);
1304              addReply(c,shared.cone);
1305          } else {
1306              addReply(c,shared.czero);
1307          }
1308      } else if (!strcasecmp(c->argv[1]->ptr,"setname") && c->argc == 3) {
1309          int j, len = (int)sdslen(c->argv[2]->ptr);                              WIN_PORT_FIX &bsol;* cast (int) */
1310          char *p = c->argv[2]->ptr;
1311          if (len == 0) {
1312              if (c->name) decrRefCount(c->name);
1313              c->name = NULL;
1314              addReply(c,shared.ok);
1315              return;
1316          }
<span onclick='openModal()' class='match'>1317          for (j = 0; j < len; j++) {
1318              if (p[j] < '!' || p[j] > '~') { &bsol;* ASCII is assumed. */
1319                  addReplyError(c,
1320                      "Client names cannot contain spaces, "
1321                      "newlines or special characters.");
1322                  return;
1323              }
1324          }
1325          if (c->name) decrRefCount(c->name);
1326          c->name = c->argv[2];
</span>1327          incrRefCount(c->name);
1328          addReply(c,shared.ok);
1329      } else if (!strcasecmp(c->argv[1]->ptr,"getname") && c->argc == 2) {
1330          if (c->name)
1331              addReplyBulk(c,c->name);
1332          else
1333              addReply(c,shared.nullbulk);
1334      } else if (!strcasecmp(c->argv[1]->ptr,"pause") && c->argc == 3) {
1335          PORT_LONGLONG duration;
1336          if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,UNIT_MILLISECONDS)
1337                                          != C_OK) return;
1338          pauseClients(duration);
1339          addReply(c,shared.ok);
1340      } else {
1341          addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP", (char*)c->argv[1]->ptr);
1342      }
1343  }
1344  void securityWarningCommand(client *c) {
1345      static time_t logged_time;
1346      time_t now = time(NULL);
1347      if (labs(now-logged_time) > 60) {
1348          serverLog(LL_WARNING,"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.");
1349          logged_time = now;
1350      }
1351      freeClientAsync(c);
1352  }
1353  void rewriteClientCommandVector(client *c, int argc, ...) {
1354      va_list ap;
1355      int j;
1356      robj **argv; &bsol;* The new argument vector */
1357      argv = zmalloc(sizeof(robj*)*argc);
1358      va_start(ap,argc);
1359      for (j = 0; j < argc; j++) {
1360          robj *a;
1361          a = va_arg(ap, robj*);
1362          argv[j] = a;
1363          incrRefCount(a);
1364      }
1365      for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);
1366      zfree(c->argv);
1367      c->argv = argv;
1368      c->argc = argc;
1369      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1370      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1371      va_end(ap);
1372  }
1373  void replaceClientCommandVector(client *c, int argc, robj **argv) {
1374      freeClientArgv(c);
1375      zfree(c->argv);
1376      c->argv = argv;
1377      c->argc = argc;
1378      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1379      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1380  }
1381  void rewriteClientCommandArgument(client *c, int i, robj *newval) {
1382      robj *oldval;
1383      if (i >= c->argc) {
1384          c->argv = zrealloc(c->argv,sizeof(robj*)*((PORT_ULONG)i+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1385          c->argc = i+1;
1386          c->argv[i] = NULL;
1387      }
1388      oldval = c->argv[i];
1389      c->argv[i] = newval;
1390      incrRefCount(newval);
1391      if (oldval) decrRefCount(oldval);
1392      if (i == 0) {
1393          c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1394          serverAssertWithInfo(c,NULL,c->cmd != NULL);
1395      }
1396  }
1397  PORT_ULONG getClientOutputBufferMemoryUsage(client *c) {
1398      PORT_ULONG list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
1399      return c->reply_bytes + (list_item_size*listLength(c->reply));
1400  }
1401  int getClientType(client *c) {
1402      if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
1403      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
1404          return CLIENT_TYPE_SLAVE;
1405      if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
1406      return CLIENT_TYPE_NORMAL;
1407  }
1408  int getClientTypeByName(char *name) {
1409      if (!strcasecmp(name,"normal")) return CLIENT_TYPE_NORMAL;
1410      else if (!strcasecmp(name,"slave")) return CLIENT_TYPE_SLAVE;
1411      else if (!strcasecmp(name,"replica")) return CLIENT_TYPE_SLAVE;
1412      else if (!strcasecmp(name,"pubsub")) return CLIENT_TYPE_PUBSUB;
1413      else if (!strcasecmp(name,"master")) return CLIENT_TYPE_MASTER;
1414      else return -1;
1415  }
1416  char *getClientTypeName(int class) {
1417      switch(class) {
1418      case CLIENT_TYPE_NORMAL: return "normal";
1419      case CLIENT_TYPE_SLAVE:  return "slave";
1420      case CLIENT_TYPE_PUBSUB: return "pubsub";
1421      case CLIENT_TYPE_MASTER: return "master";
1422      default:                       return NULL;
1423      }
1424  }
1425  int checkClientOutputBufferLimits(client *c) {
1426      int soft = 0, hard = 0, class;
1427      PORT_ULONG used_mem = getClientOutputBufferMemoryUsage(c);
1428      class = getClientType(c);
1429      if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;
1430      if (server.client_obuf_limits[class].hard_limit_bytes &&
1431          used_mem >= server.client_obuf_limits[class].hard_limit_bytes)
1432          hard = 1;
1433      if (server.client_obuf_limits[class].soft_limit_bytes &&
1434          used_mem >= server.client_obuf_limits[class].soft_limit_bytes)
1435          soft = 1;
1436      if (soft) {
1437          if (c->obuf_soft_limit_reached_time == 0) {
1438              c->obuf_soft_limit_reached_time = server.unixtime;
1439              soft = 0; &bsol;* First time we see the soft limit reached */
1440          } else {
1441              time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;
1442              if (elapsed <=
1443                  server.client_obuf_limits[class].soft_limit_seconds) {
1444                  soft = 0; &bsol;* The client still did not reached the max number of
1445                               seconds for the soft limit to be considered
1446                               reached. */
1447              }
1448          }
1449      } else {
1450          c->obuf_soft_limit_reached_time = 0;
1451      }
1452      return soft || hard;
1453  }
1454  void asyncCloseClientOnOutputBufferLimitReached(client *c) {
1455      if (c->fd == -1) return; &bsol;* It is unsafe to free fake clients. */
1456      POSIX_ONLY(serverAssert(c->reply_bytes < PORT_ULONG_MAX-(1024*64));)
1457      if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
1458      if (checkClientOutputBufferLimits(c)) {
1459          sds client = catClientInfoString(sdsempty(),c);
1460          freeClientAsync(c);
1461          serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
1462          sdsfree(client);
1463      }
1464  }
1465  void flushSlavesOutputBuffers(void) {
1466      listIter li;
1467      listNode *ln;
1468      listRewind(server.slaves,&li);
1469      while((ln = listNext(&li))) {
1470          client *slave = listNodeValue(ln);
1471          int events = aeGetFileEvents(server.el,slave->fd);
1472          int can_receive_writes = (events & AE_WRITABLE) ||
1473                                   (slave->flags & CLIENT_PENDING_WRITE);
1474          if (slave->replstate == SLAVE_STATE_ONLINE &&
1475              can_receive_writes &&
1476              !slave->repl_put_online_on_ack &&
1477              clientHasPendingReplies(slave))
1478          {
1479              writeToClient(slave->fd,slave,0);
1480          }
1481      }
1482  }
1483  void pauseClients(mstime_t end) {
1484      if (!server.clients_paused || end > server.clients_pause_end_time)
1485          server.clients_pause_end_time = end;
1486      server.clients_paused = 1;
1487  }
1488  int clientsArePaused(void) {
1489      if (server.clients_paused &&
1490          server.clients_pause_end_time < server.mstime)
1491      {
1492          listNode *ln;
1493          listIter li;
1494          client *c;
1495          server.clients_paused = 0;
1496          listRewind(server.clients,&li);
1497          while ((ln = listNext(&li)) != NULL) {
1498              c = listNodeValue(ln);
1499              if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;
1500              queueClientForReprocessing(c);
1501          }
1502      }
1503      return server.clients_paused;
1504  }
1505  int processEventsWhileBlocked(void) {
1506      int iterations = 4; &bsol;* See the function top-comment. */
1507      int count = 0;
1508      while (iterations--) {
1509          int events = 0;
1510          events += aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
1511          events += handleClientsWithPendingWrites();
1512          if (!events) break;
1513          count += events;
1514      }
1515      return count;
1516  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_length_teletex_string.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</div>
                <div class="column column_space"><pre><code>151     for (x = 0; x < noctets; x++) {
152         if (der_teletex_char_encode(octets[x]) == -1) {
153            return CRYPT_INVALID_ARG;
154         }
155     }
156     if ((err = der_length_asn1_length(noctets, &x)) != CRYPT_OK) {
</pre></code></div>
                <div class="column column_space"><pre><code>1317          for (j = 0; j < len; j++) {
1318              if (p[j] < '!' || p[j] > '~') { &bsol;* ASCII is assumed. */
1319                  addReplyError(c,
1320                      "Client names cannot contain spaces, "
1321                      "newlines or special characters.");
1322                  return;
1323              }
1324          }
1325          if (c->name) decrRefCount(c->name);
1326          c->name = c->argv[2];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    