
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pci-common.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "hwloc/plugins.h"
4  #include "private/private.h"
5  #include "private/debug.h"
6  #include "private/misc.h"
7  #include <fcntl.h>
8  #ifdef HAVE_UNISTD_H
9  #include <unistd.h>
10  #endif
11  #include <sys/stat.h>
12  #if defined(HWLOC_WIN_SYS) && !defined(__CYGWIN__)
13  #include <io.h>
14  #define open _open
15  #define read _read
16  #define close _close
17  #endif
18  static void
19  hwloc_pci_forced_locality_parse_one(struct hwloc_topology *topology,
20  				    const char *string &bsol;* must contain a ' ' */,
21  				    unsigned *allocated)
22  {
23    unsigned nr = topology->pci_forced_locality_nr;
24    unsigned domain, bus_first, bus_last, dummy;
25    hwloc_bitmap_t set;
26    char *tmp;
27    if (sscanf(string, "%x:%x-%x %x", &domain, &bus_first, &bus_last, &dummy) == 4) {
28    } else if (sscanf(string, "%x:%x %x", &domain, &bus_first, &dummy) == 3) {
29      bus_last = bus_first;
30    } else if (sscanf(string, "%x %x", &domain, &dummy) == 2) {
31      bus_first = 0;
32      bus_last = 255;
33    } else
34      return;
35    tmp = strchr(string, ' ');
36    if (!tmp)
37      return;
38    tmp++;
39    set = hwloc_bitmap_alloc();
40    hwloc_bitmap_sscanf(set, tmp);
41    if (!*allocated) {
42      topology->pci_forced_locality = malloc(sizeof(*topology->pci_forced_locality));
43      if (!topology->pci_forced_locality)
44        goto out_with_set; &bsol;* failed to allocate, ignore this forced locality */
45      *allocated = 1;
46    } else if (nr >= *allocated) {
47      struct hwloc_pci_forced_locality_s *tmplocs;
48      tmplocs = realloc(topology->pci_forced_locality,
49  		      2 * *allocated * sizeof(*topology->pci_forced_locality));
50      if (!tmplocs)
51        goto out_with_set; &bsol;* failed to allocate, ignore this forced locality */
52      topology->pci_forced_locality = tmplocs;
53      *allocated *= 2;
54    }
55    topology->pci_forced_locality[nr].domain = domain;
56    topology->pci_forced_locality[nr].bus_first = bus_first;
57    topology->pci_forced_locality[nr].bus_last = bus_last;
58    topology->pci_forced_locality[nr].cpuset = set;
59    topology->pci_forced_locality_nr++;
60    return;
61   out_with_set:
62    hwloc_bitmap_free(set);
63    return;
64  }
65  static void
66  hwloc_pci_forced_locality_parse(struct hwloc_topology *topology, const char *_env)
67  {
68    char *env = strdup(_env);
69    unsigned allocated = 0;
70    char *tmp = env;
71    while (1) {
72      size_t len = strcspn(tmp, ";\r\n");
73      char *next = NULL;
74      if (tmp[len] != '\0') {
75        tmp[len] = '\0';
76        if (tmp[len+1] != '\0')
77  	next = &tmp[len]+1;
78      }
79      hwloc_pci_forced_locality_parse_one(topology, tmp, &allocated);
80      if (next)
81        tmp = next;
82      else
83        break;
84    }
85    free(env);
86  }
87  void
88  hwloc_pci_discovery_init(struct hwloc_topology *topology)
89  {
90    topology->pci_has_forced_locality = 0;
91    topology->pci_forced_locality_nr = 0;
92    topology->pci_forced_locality = NULL;
93    topology->first_pci_locality = topology->last_pci_locality = NULL;
94  #define HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A (1ULL<<0)
95  #define HWLOC_PCI_LOCALITY_QUIRK_FAKE (1ULL<<62)
96    topology->pci_locality_quirks = (uint64_t) -1;
97  }
98  void
99  hwloc_pci_discovery_prepare(struct hwloc_topology *topology)
100  {
101    char *env;
102    env = getenv("HWLOC_PCI_LOCALITY");
103    if (env) {
104      int fd;
105      topology->pci_has_forced_locality = 1;
106      fd = open(env, O_RDONLY);
107      if (fd >= 0) {
108        struct stat st;
109        char *buffer;
110        int err = fstat(fd, &st);
111        if (!err) {
112  	if (st.st_size <= 64*1024) { &bsol;* random limit large enough to store multiple cpusets for thousands of PUs */
113  	  buffer = malloc(st.st_size+1);
114  	  if (buffer && read(fd, buffer, st.st_size) == st.st_size) {
115  	    buffer[st.st_size] = '\0';
116  	    hwloc_pci_forced_locality_parse(topology, buffer);
117  	  }
118  	  free(buffer);
119  	} else {
120            if (HWLOC_SHOW_CRITICAL_ERRORS())
<span onclick='openModal()' class='match'>121              fprintf(stderr, "hwloc/pci: Ignoring HWLOC_PCI_LOCALITY file `%s' too large (%lu bytes)\n",
122                      env, (unsigned long) st.st_size);
123  	}
</span>124        }
125        close(fd);
126      } else
127        hwloc_pci_forced_locality_parse(topology, env);
128    }
129  }
130  void
131  hwloc_pci_discovery_exit(struct hwloc_topology *topology)
132  {
133    struct hwloc_pci_locality_s *cur;
134    unsigned i;
135    for(i=0; i<topology->pci_forced_locality_nr; i++)
136      hwloc_bitmap_free(topology->pci_forced_locality[i].cpuset);
137    free(topology->pci_forced_locality);
138    cur = topology->first_pci_locality;
139    while (cur) {
140      struct hwloc_pci_locality_s *next = cur->next;
141      hwloc_bitmap_free(cur->cpuset);
142      free(cur);
143      cur = next;
144    }
145    hwloc_pci_discovery_init(topology);
146  }
147  #ifdef HWLOC_DEBUG
148  static void
149  hwloc_pci_traverse_print_cb(void * cbdata __hwloc_attribute_unused,
150  			    struct hwloc_obj *pcidev)
151  {
152    char busid[14];
153    hwloc_obj_t parent;
154    parent = pcidev->parent;
155    while (parent) {
156      hwloc_debug("%s", "  ");
157      parent = parent->parent;
158    }
159    snprintf(busid, sizeof(busid), "%04x:%02x:%02x.%01x",
160             pcidev->attr->pcidev.domain, pcidev->attr->pcidev.bus, pcidev->attr->pcidev.dev, pcidev->attr->pcidev.func);
161    if (pcidev->type == HWLOC_OBJ_BRIDGE) {
162      if (pcidev->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_HOST)
163        hwloc_debug("HostBridge");
164      else
165        hwloc_debug("%s Bridge [%04x:%04x]", busid,
166  		  pcidev->attr->pcidev.vendor_id, pcidev->attr->pcidev.device_id);
167      if (pcidev->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI)
168        hwloc_debug(" to %04x:[%02x:%02x]\n",
169                    pcidev->attr->bridge.downstream.pci.domain, pcidev->attr->bridge.downstream.pci.secondary_bus, pcidev->attr->bridge.downstream.pci.subordinate_bus);
170      else
171        assert(0);
172    } else
173      hwloc_debug("%s Device [%04x:%04x (%04x:%04x) rev=%02x class=%04x]\n", busid,
174  		pcidev->attr->pcidev.vendor_id, pcidev->attr->pcidev.device_id,
175  		pcidev->attr->pcidev.subvendor_id, pcidev->attr->pcidev.subdevice_id,
176  		pcidev->attr->pcidev.revision, pcidev->attr->pcidev.class_id);
177  }
178  static void
179  hwloc_pci_traverse(void * cbdata, struct hwloc_obj *tree,
180  		   void (*cb)(void * cbdata, struct hwloc_obj *))
181  {
182    hwloc_obj_t child;
183    cb(cbdata, tree);
184    for_each_io_child(child, tree) {
185      if (child->type == HWLOC_OBJ_BRIDGE)
186        hwloc_pci_traverse(cbdata, child, cb);
187    }
188  }
189  #endif &bsol;* HWLOC_DEBUG */
190  enum hwloc_pci_busid_comparison_e {
191    HWLOC_PCI_BUSID_LOWER,
192    HWLOC_PCI_BUSID_HIGHER,
193    HWLOC_PCI_BUSID_INCLUDED,
194    HWLOC_PCI_BUSID_SUPERSET,
195    HWLOC_PCI_BUSID_EQUAL
196  };
197  static enum hwloc_pci_busid_comparison_e
198  hwloc_pci_compare_busids(struct hwloc_obj *a, struct hwloc_obj *b)
199  {
200  #ifdef HWLOC_DEBUG
201    if (a->type == HWLOC_OBJ_BRIDGE)
202      assert(a->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI);
203    if (b->type == HWLOC_OBJ_BRIDGE)
204      assert(b->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI);
205  #endif
206    if (a->attr->pcidev.domain < b->attr->pcidev.domain)
207      return HWLOC_PCI_BUSID_LOWER;
208    if (a->attr->pcidev.domain > b->attr->pcidev.domain)
209      return HWLOC_PCI_BUSID_HIGHER;
210    if (a->type == HWLOC_OBJ_BRIDGE && a->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
211        && b->attr->pcidev.bus >= a->attr->bridge.downstream.pci.secondary_bus
212        && b->attr->pcidev.bus <= a->attr->bridge.downstream.pci.subordinate_bus)
213      return HWLOC_PCI_BUSID_SUPERSET;
214    if (b->type == HWLOC_OBJ_BRIDGE && b->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
215        && a->attr->pcidev.bus >= b->attr->bridge.downstream.pci.secondary_bus
216        && a->attr->pcidev.bus <= b->attr->bridge.downstream.pci.subordinate_bus)
217      return HWLOC_PCI_BUSID_INCLUDED;
218    if (a->attr->pcidev.bus < b->attr->pcidev.bus)
219      return HWLOC_PCI_BUSID_LOWER;
220    if (a->attr->pcidev.bus > b->attr->pcidev.bus)
221      return HWLOC_PCI_BUSID_HIGHER;
222    if (a->attr->pcidev.dev < b->attr->pcidev.dev)
223      return HWLOC_PCI_BUSID_LOWER;
224    if (a->attr->pcidev.dev > b->attr->pcidev.dev)
225      return HWLOC_PCI_BUSID_HIGHER;
226    if (a->attr->pcidev.func < b->attr->pcidev.func)
227      return HWLOC_PCI_BUSID_LOWER;
228    if (a->attr->pcidev.func > b->attr->pcidev.func)
229      return HWLOC_PCI_BUSID_HIGHER;
230    return HWLOC_PCI_BUSID_EQUAL;
231  }
232  static void
233  hwloc_pci_add_object(struct hwloc_obj *parent, struct hwloc_obj **parent_io_first_child_p, struct hwloc_obj *new)
234  {
235    struct hwloc_obj **curp, **childp;
236    curp = parent_io_first_child_p;
237    while (*curp) {
238      enum hwloc_pci_busid_comparison_e comp = hwloc_pci_compare_busids(new, *curp);
239      switch (comp) {
240      case HWLOC_PCI_BUSID_HIGHER:
241        curp = &(*curp)->next_sibling;
242        continue;
243      case HWLOC_PCI_BUSID_INCLUDED:
244        hwloc_pci_add_object(*curp, &(*curp)->io_first_child, new);
245        return;
246      case HWLOC_PCI_BUSID_LOWER:
247      case HWLOC_PCI_BUSID_SUPERSET: {
248        new->next_sibling = *curp;
249        *curp = new;
250        new->parent = parent;
251        if (new->type == HWLOC_OBJ_BRIDGE && new->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
252  	childp = &new->io_first_child;
253  	curp = &new->next_sibling;
254  	while (*curp) {
255  	  hwloc_obj_t cur = *curp;
256  	  if (hwloc_pci_compare_busids(new, cur) == HWLOC_PCI_BUSID_LOWER) {
257  	    if (cur->attr->pcidev.domain > new->attr->pcidev.domain
258  		|| cur->attr->pcidev.bus > new->attr->bridge.downstream.pci.subordinate_bus)
259  	      return;
260  	    curp = &cur->next_sibling;
261  	  } else {
262  	    *childp = cur;
263  	    *curp = cur->next_sibling;
264  	    (*childp)->parent = new;
265  	    (*childp)->next_sibling = NULL;
266  	    childp = &(*childp)->next_sibling;
267  	  }
268  	}
269        }
270        return;
271      }
272      case HWLOC_PCI_BUSID_EQUAL: {
273        static int reported = 0;
274        if (!reported && HWLOC_SHOW_CRITICAL_ERRORS()) {
275          fprintf(stderr, "*********************************************************\n");
276          fprintf(stderr, "* hwloc %s received invalid PCI information.\n", HWLOC_VERSION);
277          fprintf(stderr, "*\n");
278          fprintf(stderr, "* Trying to insert PCI object %04x:%02x:%02x.%01x at %04x:%02x:%02x.%01x\n",
279                  new->attr->pcidev.domain, new->attr->pcidev.bus, new->attr->pcidev.dev, new->attr->pcidev.func,
280                  (*curp)->attr->pcidev.domain, (*curp)->attr->pcidev.bus, (*curp)->attr->pcidev.dev, (*curp)->attr->pcidev.func);
281          fprintf(stderr, "*\n");
282          fprintf(stderr, "* hwloc will now ignore this object and continue.\n");
283          fprintf(stderr, "*********************************************************\n");
284          reported = 1;
285        }
286        hwloc_free_unlinked_object(new);
287        return;
288      }
289      }
290    }
291    new->parent = parent;
292    new->next_sibling = NULL;
293    *curp = new;
294  }
295  void
296  hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep,
297  				   struct hwloc_obj *obj)
298  {
299    hwloc_pci_add_object(NULL &bsol;* no parent on top of tree */, treep, obj);
300  }
301  static struct hwloc_obj *
302  hwloc_pcidisc_add_hostbridges(struct hwloc_topology *topology,
303  			      struct hwloc_obj *old_tree)
304  {
305    struct hwloc_obj * new = NULL, **newp = &new;
306    while (old_tree) {
307      struct hwloc_obj *hostbridge;
308      struct hwloc_obj **dstnextp;
309      struct hwloc_obj **srcnextp;
310      struct hwloc_obj *child;
311      unsigned current_domain;
312      unsigned char current_bus;
313      unsigned char current_subordinate;
314      hostbridge = hwloc_alloc_setup_object(topology, HWLOC_OBJ_BRIDGE, HWLOC_UNKNOWN_INDEX);
315      if (!hostbridge) {
316        *newp = old_tree;
317        return new;
318      }
319      dstnextp = &hostbridge->io_first_child;
320      srcnextp = &old_tree;
321      child = *srcnextp;
322      current_domain = child->attr->pcidev.domain;
323      current_bus = child->attr->pcidev.bus;
324      current_subordinate = current_bus;
325      hwloc_debug("Adding new PCI hostbridge %04x:%02x\n", current_domain, current_bus);
326    next_child:
327      *srcnextp = child->next_sibling;
328      *dstnextp = child;
329      child->parent = hostbridge;
330      child->next_sibling = NULL;
331      dstnextp = &child->next_sibling;
332      if (child->type == HWLOC_OBJ_BRIDGE && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
333  	&& child->attr->bridge.downstream.pci.subordinate_bus > current_subordinate)
334        current_subordinate = child->attr->bridge.downstream.pci.subordinate_bus;
335      child = *srcnextp;
336      if (child
337  	&& child->attr->pcidev.domain == current_domain
338  	&& child->attr->pcidev.bus == current_bus)
339        goto next_child;
340      hostbridge->attr->bridge.upstream_type = HWLOC_OBJ_BRIDGE_HOST;
341      hostbridge->attr->bridge.downstream_type = HWLOC_OBJ_BRIDGE_PCI;
342      hostbridge->attr->bridge.downstream.pci.domain = current_domain;
343      hostbridge->attr->bridge.downstream.pci.secondary_bus = current_bus;
344      hostbridge->attr->bridge.downstream.pci.subordinate_bus = current_subordinate;
345      hwloc_debug("  new PCI hostbridge covers %04x:[%02x-%02x]\n",
346  		current_domain, current_bus, current_subordinate);
347      *newp = hostbridge;
348      newp = &hostbridge->next_sibling;
349    }
350    return new;
351  }
352  static int
353  hwloc__pci_find_busid_parent_quirk(struct hwloc_topology *topology,
354                                     struct hwloc_pcidev_attr_s *busid,
355                                     hwloc_cpuset_t cpuset)
356  {
357    if (topology->pci_locality_quirks == (uint64_t)-1 &bsol;* unknown */) {
358      const char *dmi_board_name, *env;
359      topology->pci_locality_quirks = 0; &bsol;* no quirk yet */
360      dmi_board_name = hwloc_obj_get_info_by_name(hwloc_get_root_obj(topology), "DMIBoardName");
361      if (dmi_board_name && !strcmp(dmi_board_name, "HPE CRAY EX235A")) {
362        hwloc_debug("enabling for PCI locality quirk for HPE Cray EX235A\n");
363        topology->pci_locality_quirks |= HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A;
364      }
365      env = getenv("HWLOC_PCI_LOCALITY_QUIRK_FAKE");
366      if (env && atoi(env)) {
367        hwloc_debug("enabling for PCI locality fake quirk (attaching everything to last PU)\n");
368        topology->pci_locality_quirks |= HWLOC_PCI_LOCALITY_QUIRK_FAKE;
369      }
370    }
371    if (topology->pci_locality_quirks & HWLOC_PCI_LOCALITY_QUIRK_FAKE) {
372      unsigned last = hwloc_bitmap_last(hwloc_topology_get_topology_cpuset(topology));
373      hwloc_bitmap_set(cpuset, last);
374      return 1;
375    }
376    if (topology->pci_locality_quirks & HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A) {
377      if (busid->domain == 0) {
378        if (busid->bus >= 0xd0 && busid->bus <= 0xd1) {
379          hwloc_bitmap_set_range(cpuset, 0, 7);
380          hwloc_bitmap_set_range(cpuset, 64, 71);
381          return 1;
382        }
383        if (busid->bus >= 0xd4 && busid->bus <= 0xd6) {
384          hwloc_bitmap_set_range(cpuset, 8, 15);
385          hwloc_bitmap_set_range(cpuset, 72, 79);
386          return 1;
387        }
388        if (busid->bus >= 0xc8 && busid->bus <= 0xc9) {
389          hwloc_bitmap_set_range(cpuset, 16, 23);
390          hwloc_bitmap_set_range(cpuset, 80, 87);
391          return 1;
392        }
393        if (busid->bus >= 0xcc && busid->bus <= 0xce) {
394          hwloc_bitmap_set_range(cpuset, 24, 31);
395          hwloc_bitmap_set_range(cpuset, 88, 95);
396          return 1;
397        }
398        if (busid->bus >= 0xd8 && busid->bus <= 0xd9) {
399          hwloc_bitmap_set_range(cpuset, 32, 39);
400          hwloc_bitmap_set_range(cpuset, 96, 103);
401          return 1;
402        }
403        if (busid->bus >= 0xdc && busid->bus <= 0xde) {
404          hwloc_bitmap_set_range(cpuset, 40, 47);
405          hwloc_bitmap_set_range(cpuset, 104, 111);
406          return 1;
407        }
408        if (busid->bus >= 0xc0 && busid->bus <= 0xc1) {
409          hwloc_bitmap_set_range(cpuset, 48, 55);
410          hwloc_bitmap_set_range(cpuset, 112, 119);
411          return 1;
412        }
413        if (busid->bus >= 0xc4 && busid->bus <= 0xc6) {
414          hwloc_bitmap_set_range(cpuset, 56, 63);
415          hwloc_bitmap_set_range(cpuset, 120, 127);
416          return 1;
417        }
418      }
419    }
420    return 0;
421  }
422  static struct hwloc_obj *
423  hwloc__pci_find_busid_parent(struct hwloc_topology *topology, struct hwloc_pcidev_attr_s *busid)
424  {
425    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
426    hwloc_obj_t parent;
427    int forced = 0;
428    int noquirks = 0, got_quirked = 0;
429    unsigned i;
430    int err;
431    hwloc_debug("Looking for parent of PCI busid %04x:%02x:%02x.%01x\n",
432  	      busid->domain, busid->bus, busid->dev, busid->func);
433    if (topology->pci_has_forced_locality) {
434      for(i=0; i<topology->pci_forced_locality_nr; i++) {
435        if (busid->domain == topology->pci_forced_locality[i].domain
436  	  && busid->bus >= topology->pci_forced_locality[i].bus_first
437  	  && busid->bus <= topology->pci_forced_locality[i].bus_last) {
438  	hwloc_bitmap_copy(cpuset, topology->pci_forced_locality[i].cpuset);
439  	forced = 1;
440  	break;
441        }
442      }
443      noquirks = 1;
444    }
445    if (!forced) {
446      const char *env;
447      char envname[256];
448      snprintf(envname, sizeof(envname), "HWLOC_PCI_%04x_%02x_LOCALCPUS",
449  	     busid->domain, busid->bus);
450      env = getenv(envname);
451      if (env) {
452        static int reported = 0;
453        if (!topology->pci_has_forced_locality && !reported) {
454          if (HWLOC_SHOW_ALL_ERRORS())
455            fprintf(stderr, "hwloc/pci: Environment variable %s is deprecated, please use HWLOC_PCI_LOCALITY instead.\n", env);
456  	reported = 1;
457        }
458        if (*env) {
459  	hwloc_debug("Overriding PCI locality using %s in the environment\n", envname);
460  	hwloc_bitmap_sscanf(cpuset, env);
461  	forced = 1;
462        }
463        noquirks = 1;
464      }
465    }
466    if (!forced && !noquirks && topology->pci_locality_quirks &bsol;* either quirks are unknown yet, or some are enabled */) {
467      err = hwloc__pci_find_busid_parent_quirk(topology, busid, cpuset);
468      if (err > 0)
469        got_quirked = 1;
470    }
471    if (!forced && !got_quirked) {
472      struct hwloc_backend *backend = topology->get_pci_busid_cpuset_backend;
473      if (backend)
474        err = backend->get_pci_busid_cpuset(backend, busid, cpuset);
475      else
476        err = -1;
477      if (err < 0)
478        hwloc_bitmap_copy(cpuset, hwloc_topology_get_topology_cpuset(topology));
479    }
480    hwloc_debug_bitmap("  will attach PCI bus to cpuset %s\n", cpuset);
481    parent = hwloc_find_insert_io_parent_by_complete_cpuset(topology, cpuset);
482    if (!parent) {
483      parent = hwloc_get_root_obj(topology);
484    }
485    hwloc_bitmap_free(cpuset);
486    return parent;
487  }
488  int
489  hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree)
490  {
491    enum hwloc_type_filter_e bfilter;
492    if (!tree)
493      return 0;
494  #ifdef HWLOC_DEBUG
495    hwloc_debug("%s", "\nPCI hierarchy:\n");
496    hwloc_pci_traverse(NULL, tree, hwloc_pci_traverse_print_cb);
497    hwloc_debug("%s", "\n");
498  #endif
499    bfilter = topology->type_filter[HWLOC_OBJ_BRIDGE];
500    if (bfilter != HWLOC_TYPE_FILTER_KEEP_NONE) {
501      tree = hwloc_pcidisc_add_hostbridges(topology, tree);
502    }
503    while (tree) {
504      struct hwloc_obj *obj, *pciobj;
505      struct hwloc_obj *parent;
506      struct hwloc_pci_locality_s *loc;
507      unsigned domain, bus_min, bus_max;
508      obj = tree;
509      if (obj->type == HWLOC_OBJ_BRIDGE && obj->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_HOST)
510        pciobj = obj->io_first_child;
511      else
512        pciobj = obj;
513      assert(pciobj->type == HWLOC_OBJ_PCI_DEVICE
514  	   || (pciobj->type == HWLOC_OBJ_BRIDGE && pciobj->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI));
515      if (obj->type == HWLOC_OBJ_BRIDGE && obj->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
516        domain = obj->attr->bridge.downstream.pci.domain;
517        bus_min = obj->attr->bridge.downstream.pci.secondary_bus;
518        bus_max = obj->attr->bridge.downstream.pci.subordinate_bus;
519      } else {
520        domain = pciobj->attr->pcidev.domain;
521        bus_min = pciobj->attr->pcidev.bus;
522        bus_max = pciobj->attr->pcidev.bus;
523      }
524      parent = hwloc__pci_find_busid_parent(topology, &pciobj->attr->pcidev);
525      if (topology->last_pci_locality
526  	&& parent == topology->last_pci_locality->parent
527  	&& domain == topology->last_pci_locality->domain
528  	&& (bus_min == topology->last_pci_locality->bus_max
529  	    || bus_min == topology->last_pci_locality->bus_max+1)) {
530        hwloc_debug("  Reusing PCI locality up to bus %04x:%02x\n",
531  		  domain, bus_max);
532        topology->last_pci_locality->bus_max = bus_max;
533        goto done;
534      }
535      loc = malloc(sizeof(*loc));
536      if (!loc) {
537        parent = hwloc_get_root_obj(topology);
538        goto done;
539      }
540      loc->domain = domain;
541      loc->bus_min = bus_min;
542      loc->bus_max = bus_max;
543      loc->parent = parent;
544      loc->cpuset = hwloc_bitmap_dup(parent->cpuset);
545      if (!loc->cpuset) {
546        free(loc);
547        parent = hwloc_get_root_obj(topology);
548        goto done;
549      }
550      hwloc_debug("Adding PCI locality %s P#%u for bus %04x:[%02x:%02x]\n",
551  		hwloc_obj_type_string(parent->type), parent->os_index, loc->domain, loc->bus_min, loc->bus_max);
552      if (topology->last_pci_locality) {
553        loc->prev = topology->last_pci_locality;
554        loc->next = NULL;
555        topology->last_pci_locality->next = loc;
556        topology->last_pci_locality = loc;
557      } else {
558        loc->prev = NULL;
559        loc->next = NULL;
560        topology->first_pci_locality = loc;
561        topology->last_pci_locality = loc;
562      }
563    done:
564      tree = obj->next_sibling;
565      obj->next_sibling = NULL;
566      hwloc_insert_object_by_parent(topology, parent, obj);
567    }
568    return 0;
569  }
570  struct hwloc_obj *
571  hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology,
572  			       unsigned domain, unsigned bus, unsigned dev, unsigned func)
573  {
574    struct hwloc_pcidev_attr_s busid;
575    hwloc_obj_t parent;
576    parent = hwloc_pci_find_by_busid(topology, domain, bus, dev, func);
577    if (parent)
578      return parent;
579    busid.domain = domain;
580    busid.bus = bus;
581    busid.dev = dev;
582    busid.func = func;
583    return hwloc__pci_find_busid_parent(topology, &busid);
584  }
585  static struct hwloc_obj *
586  hwloc__pci_find_by_busid(hwloc_obj_t parent,
587  			 unsigned domain, unsigned bus, unsigned dev, unsigned func)
588  {
589    hwloc_obj_t child;
590    for_each_io_child(child, parent) {
591      if (child->type == HWLOC_OBJ_PCI_DEVICE
592  	|| (child->type == HWLOC_OBJ_BRIDGE
593  	    && child->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI)) {
594        if (child->attr->pcidev.domain == domain
595  	  && child->attr->pcidev.bus == bus
596  	  && child->attr->pcidev.dev == dev
597  	  && child->attr->pcidev.func == func)
598  	return child;
599        if (child->attr->pcidev.domain > domain
600  	  || (child->attr->pcidev.domain == domain
601  	      && child->attr->pcidev.bus > bus))
602  	return parent;
603        if (child->type == HWLOC_OBJ_BRIDGE
604  	  && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
605  	  && child->attr->bridge.downstream.pci.domain == domain
606  	  && child->attr->bridge.downstream.pci.secondary_bus <= bus
607  	  && child->attr->bridge.downstream.pci.subordinate_bus >= bus)
608  	return hwloc__pci_find_by_busid(child, domain, bus, dev, func);
609      } else if (child->type == HWLOC_OBJ_BRIDGE
610  	       && child->attr->bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI
611  	       && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
612  	       && child->attr->bridge.downstream.pci.domain == domain
613  	       && child->attr->bridge.downstream.pci.secondary_bus <= bus
614  	       && child->attr->bridge.downstream.pci.subordinate_bus >= bus) {
615        return hwloc__pci_find_by_busid(child, domain, bus, dev, func);
616      }
617    }
618    return parent;
619  }
620  struct hwloc_obj *
621  hwloc_pci_find_by_busid(struct hwloc_topology *topology,
622  			unsigned domain, unsigned bus, unsigned dev, unsigned func)
623  {
624    struct hwloc_pci_locality_s *loc;
625    hwloc_obj_t root = hwloc_get_root_obj(topology);
626    hwloc_obj_t parent = NULL;
627    hwloc_debug("pcidisc looking for bus id %04x:%02x:%02x.%01x\n", domain, bus, dev, func);
628    loc = topology->first_pci_locality;
629    while (loc) {
630      if (loc->domain == domain && loc->bus_min <= bus && loc->bus_max >= bus) {
631        parent = loc->parent;
632        assert(parent);
633        hwloc_debug("  found pci locality for %04x:[%02x:%02x]\n",
634  		  loc->domain, loc->bus_min, loc->bus_max);
635        break;
636      }
637      loc = loc->next;
638    }
639    if (!parent)
640      parent = root;
641    hwloc_debug("  looking for bus %04x:%02x:%02x.%01x below %s P#%u\n",
642  	      domain, bus, dev, func,
643  	      hwloc_obj_type_string(parent->type), parent->os_index);
644    parent = hwloc__pci_find_by_busid(parent, domain, bus, dev, func);
645    if (parent == root) {
646      hwloc_debug("  found nothing better than root object, ignoring\n");
647      return NULL;
648    } else {
649      if (parent->type == HWLOC_OBJ_PCI_DEVICE
650  	|| (parent->type == HWLOC_OBJ_BRIDGE && parent->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI))
651        hwloc_debug("  found busid %04x:%02x:%02x.%01x\n",
652  		  parent->attr->pcidev.domain, parent->attr->pcidev.bus,
653  		  parent->attr->pcidev.dev, parent->attr->pcidev.func);
654      else
655        hwloc_debug("  found parent %s P#%u\n",
656  		  hwloc_obj_type_string(parent->type), parent->os_index);
657      return parent;
658    }
659  }
660  #define HWLOC_PCI_STATUS 0x06
661  #define HWLOC_PCI_STATUS_CAP_LIST 0x10
662  #define HWLOC_PCI_CAPABILITY_LIST 0x34
663  #define HWLOC_PCI_CAP_LIST_ID 0
664  #define HWLOC_PCI_CAP_LIST_NEXT 1
665  unsigned
666  hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap)
667  {
668    unsigned char seen[256] = { 0 };
669    unsigned char ptr; &bsol;* unsigned char to make sure we stay within the 256-byte config space */
670    if (!(config[HWLOC_PCI_STATUS] & HWLOC_PCI_STATUS_CAP_LIST))
671      return 0;
672    for (ptr = config[HWLOC_PCI_CAPABILITY_LIST] & ~3;
673         ptr; &bsol;* exit if next is 0 */
674         ptr = config[ptr + HWLOC_PCI_CAP_LIST_NEXT] & ~3) {
675      unsigned char id;
676      if (seen[ptr])
677        break;
678      seen[ptr] = 1;
679      id = config[ptr + HWLOC_PCI_CAP_LIST_ID];
680      if (id == cap)
681        return ptr;
682      if (id == 0xff) &bsol;* exit if id is 0 or 0xff */
683        break;
684    }
685    return 0;
686  }
687  #define HWLOC_PCI_EXP_LNKSTA 0x12
688  #define HWLOC_PCI_EXP_LNKSTA_SPEED 0x000f
689  #define HWLOC_PCI_EXP_LNKSTA_WIDTH 0x03f0
690  int
691  hwloc_pcidisc_find_linkspeed(const unsigned char *config,
692  			     unsigned offset, float *linkspeed)
693  {
694    unsigned linksta, speed, width;
695    float lanespeed;
696    memcpy(&linksta, &config[offset + HWLOC_PCI_EXP_LNKSTA], 4);
697    speed = linksta & HWLOC_PCI_EXP_LNKSTA_SPEED; &bsol;* PCIe generation */
698    width = (linksta & HWLOC_PCI_EXP_LNKSTA_WIDTH) >> 4; &bsol;* how many lanes */
699    if (speed <= 2)
700      lanespeed = 2.5f * speed * 0.8f;
701    else if (speed <= 5)
702      lanespeed = 8.0f * (1<<(speed-3)) * 128/130;
703    else
704      lanespeed = 8.0f * (1<<(speed-3)) * 242/256; &bsol;* assume Gen8 will be 256 GT/s and so on */
705    *linkspeed = lanespeed * width / 8;
706    return 0;
707  }
708  #define HWLOC_PCI_HEADER_TYPE 0x0e
709  #define HWLOC_PCI_HEADER_TYPE_BRIDGE 1
710  #define HWLOC_PCI_CLASS_BRIDGE_PCI 0x0604
711  hwloc_obj_type_t
712  hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config)
713  {
714    unsigned char headertype;
715    if (device_class != HWLOC_PCI_CLASS_BRIDGE_PCI)
716      return HWLOC_OBJ_PCI_DEVICE;
717    headertype = config[HWLOC_PCI_HEADER_TYPE] & 0x7f;
718    return (headertype == HWLOC_PCI_HEADER_TYPE_BRIDGE)
719      ? HWLOC_OBJ_BRIDGE : HWLOC_OBJ_PCI_DEVICE;
720  }
721  #define HWLOC_PCI_PRIMARY_BUS 0x18
722  #define HWLOC_PCI_SECONDARY_BUS 0x19
723  #define HWLOC_PCI_SUBORDINATE_BUS 0x1a
724  int
725  hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,
726  				unsigned *secondary_busp, unsigned *subordinate_busp,
727  				const unsigned char *config)
728  {
729    unsigned secondary_bus, subordinate_bus;
730    if (config[HWLOC_PCI_PRIMARY_BUS] != bus) {
731      hwloc_debug("  %04x:%02x:%02x.%01x bridge with (ignored) invalid PCI_PRIMARY_BUS %02x\n",
732  		domain, bus, dev, func, config[HWLOC_PCI_PRIMARY_BUS]);
733    }
734    secondary_bus = config[HWLOC_PCI_SECONDARY_BUS];
735    subordinate_bus = config[HWLOC_PCI_SUBORDINATE_BUS];
736    if (secondary_bus <= bus
737        || subordinate_bus <= bus
738        || secondary_bus > subordinate_bus) {
739      hwloc_debug("  %04x:%02x:%02x.%01x bridge has invalid secondary-subordinate buses [%02x-%02x]\n",
740  		domain, bus, dev, func,
741  		secondary_bus, subordinate_bus);
742      return -1;
743    }
744    *secondary_busp = secondary_bus;
745    *subordinate_busp = subordinate_bus;
746    return 0;
747  }
748  const char *
749  hwloc_pci_class_string(unsigned short class_id)
750  {
751    switch ((class_id & 0xff00) >> 8) {
752      case 0x00:
753        switch (class_id) {
754  	case 0x0001: return "VGA";
755        }
756        break;
757      case 0x01:
758        switch (class_id) {
759  	case 0x0100: return "SCSI";
760  	case 0x0101: return "IDE";
761  	case 0x0102: return "Floppy";
762  	case 0x0103: return "IPI";
763  	case 0x0104: return "RAID";
764  	case 0x0105: return "ATA";
765  	case 0x0106: return "SATA";
766  	case 0x0107: return "SAS";
767  	case 0x0108: return "NVMExp";
768        }
769        return "Storage";
770      case 0x02:
771        switch (class_id) {
772  	case 0x0200: return "Ethernet";
773  	case 0x0201: return "TokenRing";
774  	case 0x0202: return "FDDI";
775  	case 0x0203: return "ATM";
776  	case 0x0204: return "ISDN";
777  	case 0x0205: return "WorldFip";
778  	case 0x0206: return "PICMG";
779  	case 0x0207: return "InfiniBand";
780  	case 0x0208: return "Fabric";
781        }
782        return "Network";
783      case 0x03:
784        switch (class_id) {
785  	case 0x0300: return "VGA";
786  	case 0x0301: return "XGA";
787  	case 0x0302: return "3D";
788        }
789        return "Display";
790      case 0x04:
791        switch (class_id) {
792  	case 0x0400: return "MultimediaVideo";
793  	case 0x0401: return "MultimediaAudio";
794  	case 0x0402: return "Telephony";
795  	case 0x0403: return "AudioDevice";
796        }
797        return "Multimedia";
798      case 0x05:
799        switch (class_id) {
800  	case 0x0500: return "RAM";
801  	case 0x0501: return "Flash";
802          case 0x0502: return "CXLMem";
803        }
804        return "Memory";
805      case 0x06:
806        switch (class_id) {
807  	case 0x0600: return "HostBridge";
808  	case 0x0601: return "ISABridge";
809  	case 0x0602: return "EISABridge";
810  	case 0x0603: return "MicroChannelBridge";
811  	case 0x0604: return "PCIBridge";
812  	case 0x0605: return "PCMCIABridge";
813  	case 0x0606: return "NubusBridge";
814  	case 0x0607: return "CardBusBridge";
815  	case 0x0608: return "RACEwayBridge";
816  	case 0x0609: return "SemiTransparentPCIBridge";
817  	case 0x060a: return "InfiniBandPCIHostBridge";
818        }
819        return "Bridge";
820      case 0x07:
821        switch (class_id) {
822  	case 0x0700: return "Serial";
823  	case 0x0701: return "Parallel";
824  	case 0x0702: return "MultiportSerial";
825  	case 0x0703: return "Model";
826  	case 0x0704: return "GPIB";
827  	case 0x0705: return "SmartCard";
828        }
829        return "Communication";
830      case 0x08:
831        switch (class_id) {
832  	case 0x0800: return "PIC";
833  	case 0x0801: return "DMA";
834  	case 0x0802: return "Timer";
835  	case 0x0803: return "RTC";
836  	case 0x0804: return "PCIHotPlug";
837  	case 0x0805: return "SDHost";
838  	case 0x0806: return "IOMMU";
839        }
840        return "SystemPeripheral";
841      case 0x09:
842        switch (class_id) {
843  	case 0x0900: return "Keyboard";
844  	case 0x0901: return "DigitizerPen";
845  	case 0x0902: return "Mouse";
846  	case 0x0903: return "Scanern";
847  	case 0x0904: return "Gameport";
848        }
849        return "Input";
850      case 0x0a:
851        return "DockingStation";
852      case 0x0b:
853        switch (class_id) {
854  	case 0x0b00: return "386";
855  	case 0x0b01: return "486";
856  	case 0x0b02: return "Pentium";
857  	case 0x0b10: return "Alpha";
858  	case 0x0b20: return "PowerPC";
859  	case 0x0b30: return "MIPS";
860  	case 0x0b40: return "Co-Processor";
861        }
862        return "Processor";
863      case 0x0c:
864        switch (class_id) {
865  	case 0x0c00: return "FireWire";
866  	case 0x0c01: return "ACCESS";
867  	case 0x0c02: return "SSA";
868  	case 0x0c03: return "USB";
869  	case 0x0c04: return "FibreChannel";
870  	case 0x0c05: return "SMBus";
871  	case 0x0c06: return "InfiniBand";
872  	case 0x0c07: return "IPMI-SMIC";
873  	case 0x0c08: return "SERCOS";
874  	case 0x0c09: return "CANBUS";
875        }
876        return "SerialBus";
877      case 0x0d:
878        switch (class_id) {
879  	case 0x0d00: return "IRDA";
880  	case 0x0d01: return "ConsumerIR";
881  	case 0x0d10: return "RF";
882  	case 0x0d11: return "Bluetooth";
883  	case 0x0d12: return "Broadband";
884  	case 0x0d20: return "802.1a";
885  	case 0x0d21: return "802.1b";
886        }
887        return "Wireless";
888      case 0x0e:
889        switch (class_id) {
890  	case 0x0e00: return "I2O";
891        }
892        return "Intelligent";
893      case 0x0f:
894        return "Satellite";
895      case 0x10:
896        return "Encryption";
897      case 0x11:
898        return "SignalProcessing";
899      case 0x12:
900        return "ProcessingAccelerator";
901      case 0x13:
902        return "Instrumentation";
903      case 0x40:
904        return "Co-Processor";
905    }
906    return "Other";
907  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pci-common.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "hwloc/plugins.h"
4  #include "private/private.h"
5  #include "private/debug.h"
6  #include "private/misc.h"
7  #include <fcntl.h>
8  #ifdef HAVE_UNISTD_H
9  #include <unistd.h>
10  #endif
11  #include <sys/stat.h>
12  #if defined(HWLOC_WIN_SYS) && !defined(__CYGWIN__)
13  #include <io.h>
14  #define open _open
15  #define read _read
16  #define close _close
17  #endif
18  static void
19  hwloc_pci_forced_locality_parse_one(struct hwloc_topology *topology,
20  				    const char *string &bsol;* must contain a ' ' */,
21  				    unsigned *allocated)
22  {
23    unsigned nr = topology->pci_forced_locality_nr;
24    unsigned domain, bus_first, bus_last, dummy;
25    hwloc_bitmap_t set;
26    char *tmp;
27    if (sscanf(string, "%x:%x-%x %x", &domain, &bus_first, &bus_last, &dummy) == 4) {
28    } else if (sscanf(string, "%x:%x %x", &domain, &bus_first, &dummy) == 3) {
29      bus_last = bus_first;
30    } else if (sscanf(string, "%x %x", &domain, &dummy) == 2) {
31      bus_first = 0;
32      bus_last = 255;
33    } else
34      return;
35    tmp = strchr(string, ' ');
36    if (!tmp)
37      return;
38    tmp++;
39    set = hwloc_bitmap_alloc();
40    hwloc_bitmap_sscanf(set, tmp);
41    if (!*allocated) {
42      topology->pci_forced_locality = malloc(sizeof(*topology->pci_forced_locality));
43      if (!topology->pci_forced_locality)
44        goto out_with_set; &bsol;* failed to allocate, ignore this forced locality */
45      *allocated = 1;
46    } else if (nr >= *allocated) {
47      struct hwloc_pci_forced_locality_s *tmplocs;
48      tmplocs = realloc(topology->pci_forced_locality,
49  		      2 * *allocated * sizeof(*topology->pci_forced_locality));
50      if (!tmplocs)
51        goto out_with_set; &bsol;* failed to allocate, ignore this forced locality */
52      topology->pci_forced_locality = tmplocs;
53      *allocated *= 2;
54    }
55    topology->pci_forced_locality[nr].domain = domain;
56    topology->pci_forced_locality[nr].bus_first = bus_first;
57    topology->pci_forced_locality[nr].bus_last = bus_last;
58    topology->pci_forced_locality[nr].cpuset = set;
59    topology->pci_forced_locality_nr++;
60    return;
61   out_with_set:
62    hwloc_bitmap_free(set);
63    return;
64  }
65  static void
66  hwloc_pci_forced_locality_parse(struct hwloc_topology *topology, const char *_env)
67  {
68    char *env = strdup(_env);
69    unsigned allocated = 0;
70    char *tmp = env;
71    while (1) {
72      size_t len = strcspn(tmp, ";\r\n");
73      char *next = NULL;
74      if (tmp[len] != '\0') {
75        tmp[len] = '\0';
76        if (tmp[len+1] != '\0')
77  	next = &tmp[len]+1;
78      }
79      hwloc_pci_forced_locality_parse_one(topology, tmp, &allocated);
80      if (next)
81        tmp = next;
82      else
83        break;
84    }
85    free(env);
86  }
87  void
88  hwloc_pci_discovery_init(struct hwloc_topology *topology)
89  {
90    topology->pci_has_forced_locality = 0;
91    topology->pci_forced_locality_nr = 0;
92    topology->pci_forced_locality = NULL;
93    topology->first_pci_locality = topology->last_pci_locality = NULL;
94  #define HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A (1ULL<<0)
95  #define HWLOC_PCI_LOCALITY_QUIRK_FAKE (1ULL<<62)
96    topology->pci_locality_quirks = (uint64_t) -1;
97  }
98  void
99  hwloc_pci_discovery_prepare(struct hwloc_topology *topology)
100  {
101    char *env;
102    env = getenv("HWLOC_PCI_LOCALITY");
103    if (env) {
104      int fd;
105      topology->pci_has_forced_locality = 1;
106      fd = open(env, O_RDONLY);
107      if (fd >= 0) {
108        struct stat st;
109        char *buffer;
110        int err = fstat(fd, &st);
111        if (!err) {
112  	if (st.st_size <= 64*1024) { &bsol;* random limit large enough to store multiple cpusets for thousands of PUs */
113  	  buffer = malloc(st.st_size+1);
114  	  if (buffer && read(fd, buffer, st.st_size) == st.st_size) {
115  	    buffer[st.st_size] = '\0';
116  	    hwloc_pci_forced_locality_parse(topology, buffer);
117  	  }
118  	  free(buffer);
119  	} else {
120            if (HWLOC_SHOW_CRITICAL_ERRORS())
<span onclick='openModal()' class='match'>121              fprintf(stderr, "hwloc/pci: Ignoring HWLOC_PCI_LOCALITY file `%s' too large (%lu bytes)\n",
122                      env, (unsigned long) st.st_size);
123  	}
</span>124        }
125        close(fd);
126      } else
127        hwloc_pci_forced_locality_parse(topology, env);
128    }
129  }
130  void
131  hwloc_pci_discovery_exit(struct hwloc_topology *topology)
132  {
133    struct hwloc_pci_locality_s *cur;
134    unsigned i;
135    for(i=0; i<topology->pci_forced_locality_nr; i++)
136      hwloc_bitmap_free(topology->pci_forced_locality[i].cpuset);
137    free(topology->pci_forced_locality);
138    cur = topology->first_pci_locality;
139    while (cur) {
140      struct hwloc_pci_locality_s *next = cur->next;
141      hwloc_bitmap_free(cur->cpuset);
142      free(cur);
143      cur = next;
144    }
145    hwloc_pci_discovery_init(topology);
146  }
147  #ifdef HWLOC_DEBUG
148  static void
149  hwloc_pci_traverse_print_cb(void * cbdata __hwloc_attribute_unused,
150  			    struct hwloc_obj *pcidev)
151  {
152    char busid[14];
153    hwloc_obj_t parent;
154    parent = pcidev->parent;
155    while (parent) {
156      hwloc_debug("%s", "  ");
157      parent = parent->parent;
158    }
159    snprintf(busid, sizeof(busid), "%04x:%02x:%02x.%01x",
160             pcidev->attr->pcidev.domain, pcidev->attr->pcidev.bus, pcidev->attr->pcidev.dev, pcidev->attr->pcidev.func);
161    if (pcidev->type == HWLOC_OBJ_BRIDGE) {
162      if (pcidev->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_HOST)
163        hwloc_debug("HostBridge");
164      else
165        hwloc_debug("%s Bridge [%04x:%04x]", busid,
166  		  pcidev->attr->pcidev.vendor_id, pcidev->attr->pcidev.device_id);
167      if (pcidev->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI)
168        hwloc_debug(" to %04x:[%02x:%02x]\n",
169                    pcidev->attr->bridge.downstream.pci.domain, pcidev->attr->bridge.downstream.pci.secondary_bus, pcidev->attr->bridge.downstream.pci.subordinate_bus);
170      else
171        assert(0);
172    } else
173      hwloc_debug("%s Device [%04x:%04x (%04x:%04x) rev=%02x class=%04x]\n", busid,
174  		pcidev->attr->pcidev.vendor_id, pcidev->attr->pcidev.device_id,
175  		pcidev->attr->pcidev.subvendor_id, pcidev->attr->pcidev.subdevice_id,
176  		pcidev->attr->pcidev.revision, pcidev->attr->pcidev.class_id);
177  }
178  static void
179  hwloc_pci_traverse(void * cbdata, struct hwloc_obj *tree,
180  		   void (*cb)(void * cbdata, struct hwloc_obj *))
181  {
182    hwloc_obj_t child;
183    cb(cbdata, tree);
184    for_each_io_child(child, tree) {
185      if (child->type == HWLOC_OBJ_BRIDGE)
186        hwloc_pci_traverse(cbdata, child, cb);
187    }
188  }
189  #endif &bsol;* HWLOC_DEBUG */
190  enum hwloc_pci_busid_comparison_e {
191    HWLOC_PCI_BUSID_LOWER,
192    HWLOC_PCI_BUSID_HIGHER,
193    HWLOC_PCI_BUSID_INCLUDED,
194    HWLOC_PCI_BUSID_SUPERSET,
195    HWLOC_PCI_BUSID_EQUAL
196  };
197  static enum hwloc_pci_busid_comparison_e
198  hwloc_pci_compare_busids(struct hwloc_obj *a, struct hwloc_obj *b)
199  {
200  #ifdef HWLOC_DEBUG
201    if (a->type == HWLOC_OBJ_BRIDGE)
202      assert(a->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI);
203    if (b->type == HWLOC_OBJ_BRIDGE)
204      assert(b->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI);
205  #endif
206    if (a->attr->pcidev.domain < b->attr->pcidev.domain)
207      return HWLOC_PCI_BUSID_LOWER;
208    if (a->attr->pcidev.domain > b->attr->pcidev.domain)
209      return HWLOC_PCI_BUSID_HIGHER;
210    if (a->type == HWLOC_OBJ_BRIDGE && a->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
211        && b->attr->pcidev.bus >= a->attr->bridge.downstream.pci.secondary_bus
212        && b->attr->pcidev.bus <= a->attr->bridge.downstream.pci.subordinate_bus)
213      return HWLOC_PCI_BUSID_SUPERSET;
214    if (b->type == HWLOC_OBJ_BRIDGE && b->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
215        && a->attr->pcidev.bus >= b->attr->bridge.downstream.pci.secondary_bus
216        && a->attr->pcidev.bus <= b->attr->bridge.downstream.pci.subordinate_bus)
217      return HWLOC_PCI_BUSID_INCLUDED;
218    if (a->attr->pcidev.bus < b->attr->pcidev.bus)
219      return HWLOC_PCI_BUSID_LOWER;
220    if (a->attr->pcidev.bus > b->attr->pcidev.bus)
221      return HWLOC_PCI_BUSID_HIGHER;
222    if (a->attr->pcidev.dev < b->attr->pcidev.dev)
223      return HWLOC_PCI_BUSID_LOWER;
224    if (a->attr->pcidev.dev > b->attr->pcidev.dev)
225      return HWLOC_PCI_BUSID_HIGHER;
226    if (a->attr->pcidev.func < b->attr->pcidev.func)
227      return HWLOC_PCI_BUSID_LOWER;
228    if (a->attr->pcidev.func > b->attr->pcidev.func)
229      return HWLOC_PCI_BUSID_HIGHER;
230    return HWLOC_PCI_BUSID_EQUAL;
231  }
232  static void
233  hwloc_pci_add_object(struct hwloc_obj *parent, struct hwloc_obj **parent_io_first_child_p, struct hwloc_obj *new)
234  {
235    struct hwloc_obj **curp, **childp;
236    curp = parent_io_first_child_p;
237    while (*curp) {
238      enum hwloc_pci_busid_comparison_e comp = hwloc_pci_compare_busids(new, *curp);
239      switch (comp) {
240      case HWLOC_PCI_BUSID_HIGHER:
241        curp = &(*curp)->next_sibling;
242        continue;
243      case HWLOC_PCI_BUSID_INCLUDED:
244        hwloc_pci_add_object(*curp, &(*curp)->io_first_child, new);
245        return;
246      case HWLOC_PCI_BUSID_LOWER:
247      case HWLOC_PCI_BUSID_SUPERSET: {
248        new->next_sibling = *curp;
249        *curp = new;
250        new->parent = parent;
251        if (new->type == HWLOC_OBJ_BRIDGE && new->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
252  	childp = &new->io_first_child;
253  	curp = &new->next_sibling;
254  	while (*curp) {
255  	  hwloc_obj_t cur = *curp;
256  	  if (hwloc_pci_compare_busids(new, cur) == HWLOC_PCI_BUSID_LOWER) {
257  	    if (cur->attr->pcidev.domain > new->attr->pcidev.domain
258  		|| cur->attr->pcidev.bus > new->attr->bridge.downstream.pci.subordinate_bus)
259  	      return;
260  	    curp = &cur->next_sibling;
261  	  } else {
262  	    *childp = cur;
263  	    *curp = cur->next_sibling;
264  	    (*childp)->parent = new;
265  	    (*childp)->next_sibling = NULL;
266  	    childp = &(*childp)->next_sibling;
267  	  }
268  	}
269        }
270        return;
271      }
272      case HWLOC_PCI_BUSID_EQUAL: {
273        static int reported = 0;
274        if (!reported && HWLOC_SHOW_CRITICAL_ERRORS()) {
275          fprintf(stderr, "*********************************************************\n");
276          fprintf(stderr, "* hwloc %s received invalid PCI information.\n", HWLOC_VERSION);
277          fprintf(stderr, "*\n");
278          fprintf(stderr, "* Trying to insert PCI object %04x:%02x:%02x.%01x at %04x:%02x:%02x.%01x\n",
279                  new->attr->pcidev.domain, new->attr->pcidev.bus, new->attr->pcidev.dev, new->attr->pcidev.func,
280                  (*curp)->attr->pcidev.domain, (*curp)->attr->pcidev.bus, (*curp)->attr->pcidev.dev, (*curp)->attr->pcidev.func);
281          fprintf(stderr, "*\n");
282          fprintf(stderr, "* hwloc will now ignore this object and continue.\n");
283          fprintf(stderr, "*********************************************************\n");
284          reported = 1;
285        }
286        hwloc_free_unlinked_object(new);
287        return;
288      }
289      }
290    }
291    new->parent = parent;
292    new->next_sibling = NULL;
293    *curp = new;
294  }
295  void
296  hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep,
297  				   struct hwloc_obj *obj)
298  {
299    hwloc_pci_add_object(NULL &bsol;* no parent on top of tree */, treep, obj);
300  }
301  static struct hwloc_obj *
302  hwloc_pcidisc_add_hostbridges(struct hwloc_topology *topology,
303  			      struct hwloc_obj *old_tree)
304  {
305    struct hwloc_obj * new = NULL, **newp = &new;
306    while (old_tree) {
307      struct hwloc_obj *hostbridge;
308      struct hwloc_obj **dstnextp;
309      struct hwloc_obj **srcnextp;
310      struct hwloc_obj *child;
311      unsigned current_domain;
312      unsigned char current_bus;
313      unsigned char current_subordinate;
314      hostbridge = hwloc_alloc_setup_object(topology, HWLOC_OBJ_BRIDGE, HWLOC_UNKNOWN_INDEX);
315      if (!hostbridge) {
316        *newp = old_tree;
317        return new;
318      }
319      dstnextp = &hostbridge->io_first_child;
320      srcnextp = &old_tree;
321      child = *srcnextp;
322      current_domain = child->attr->pcidev.domain;
323      current_bus = child->attr->pcidev.bus;
324      current_subordinate = current_bus;
325      hwloc_debug("Adding new PCI hostbridge %04x:%02x\n", current_domain, current_bus);
326    next_child:
327      *srcnextp = child->next_sibling;
328      *dstnextp = child;
329      child->parent = hostbridge;
330      child->next_sibling = NULL;
331      dstnextp = &child->next_sibling;
332      if (child->type == HWLOC_OBJ_BRIDGE && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
333  	&& child->attr->bridge.downstream.pci.subordinate_bus > current_subordinate)
334        current_subordinate = child->attr->bridge.downstream.pci.subordinate_bus;
335      child = *srcnextp;
336      if (child
337  	&& child->attr->pcidev.domain == current_domain
338  	&& child->attr->pcidev.bus == current_bus)
339        goto next_child;
340      hostbridge->attr->bridge.upstream_type = HWLOC_OBJ_BRIDGE_HOST;
341      hostbridge->attr->bridge.downstream_type = HWLOC_OBJ_BRIDGE_PCI;
342      hostbridge->attr->bridge.downstream.pci.domain = current_domain;
343      hostbridge->attr->bridge.downstream.pci.secondary_bus = current_bus;
344      hostbridge->attr->bridge.downstream.pci.subordinate_bus = current_subordinate;
345      hwloc_debug("  new PCI hostbridge covers %04x:[%02x-%02x]\n",
346  		current_domain, current_bus, current_subordinate);
347      *newp = hostbridge;
348      newp = &hostbridge->next_sibling;
349    }
350    return new;
351  }
352  static int
353  hwloc__pci_find_busid_parent_quirk(struct hwloc_topology *topology,
354                                     struct hwloc_pcidev_attr_s *busid,
355                                     hwloc_cpuset_t cpuset)
356  {
357    if (topology->pci_locality_quirks == (uint64_t)-1 &bsol;* unknown */) {
358      const char *dmi_board_name, *env;
359      topology->pci_locality_quirks = 0; &bsol;* no quirk yet */
360      dmi_board_name = hwloc_obj_get_info_by_name(hwloc_get_root_obj(topology), "DMIBoardName");
361      if (dmi_board_name && !strcmp(dmi_board_name, "HPE CRAY EX235A")) {
362        hwloc_debug("enabling for PCI locality quirk for HPE Cray EX235A\n");
363        topology->pci_locality_quirks |= HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A;
364      }
365      env = getenv("HWLOC_PCI_LOCALITY_QUIRK_FAKE");
366      if (env && atoi(env)) {
367        hwloc_debug("enabling for PCI locality fake quirk (attaching everything to last PU)\n");
368        topology->pci_locality_quirks |= HWLOC_PCI_LOCALITY_QUIRK_FAKE;
369      }
370    }
371    if (topology->pci_locality_quirks & HWLOC_PCI_LOCALITY_QUIRK_FAKE) {
372      unsigned last = hwloc_bitmap_last(hwloc_topology_get_topology_cpuset(topology));
373      hwloc_bitmap_set(cpuset, last);
374      return 1;
375    }
376    if (topology->pci_locality_quirks & HWLOC_PCI_LOCALITY_QUIRK_CRAY_EX235A) {
377      if (busid->domain == 0) {
378        if (busid->bus >= 0xd0 && busid->bus <= 0xd1) {
379          hwloc_bitmap_set_range(cpuset, 0, 7);
380          hwloc_bitmap_set_range(cpuset, 64, 71);
381          return 1;
382        }
383        if (busid->bus >= 0xd4 && busid->bus <= 0xd6) {
384          hwloc_bitmap_set_range(cpuset, 8, 15);
385          hwloc_bitmap_set_range(cpuset, 72, 79);
386          return 1;
387        }
388        if (busid->bus >= 0xc8 && busid->bus <= 0xc9) {
389          hwloc_bitmap_set_range(cpuset, 16, 23);
390          hwloc_bitmap_set_range(cpuset, 80, 87);
391          return 1;
392        }
393        if (busid->bus >= 0xcc && busid->bus <= 0xce) {
394          hwloc_bitmap_set_range(cpuset, 24, 31);
395          hwloc_bitmap_set_range(cpuset, 88, 95);
396          return 1;
397        }
398        if (busid->bus >= 0xd8 && busid->bus <= 0xd9) {
399          hwloc_bitmap_set_range(cpuset, 32, 39);
400          hwloc_bitmap_set_range(cpuset, 96, 103);
401          return 1;
402        }
403        if (busid->bus >= 0xdc && busid->bus <= 0xde) {
404          hwloc_bitmap_set_range(cpuset, 40, 47);
405          hwloc_bitmap_set_range(cpuset, 104, 111);
406          return 1;
407        }
408        if (busid->bus >= 0xc0 && busid->bus <= 0xc1) {
409          hwloc_bitmap_set_range(cpuset, 48, 55);
410          hwloc_bitmap_set_range(cpuset, 112, 119);
411          return 1;
412        }
413        if (busid->bus >= 0xc4 && busid->bus <= 0xc6) {
414          hwloc_bitmap_set_range(cpuset, 56, 63);
415          hwloc_bitmap_set_range(cpuset, 120, 127);
416          return 1;
417        }
418      }
419    }
420    return 0;
421  }
422  static struct hwloc_obj *
423  hwloc__pci_find_busid_parent(struct hwloc_topology *topology, struct hwloc_pcidev_attr_s *busid)
424  {
425    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
426    hwloc_obj_t parent;
427    int forced = 0;
428    int noquirks = 0, got_quirked = 0;
429    unsigned i;
430    int err;
431    hwloc_debug("Looking for parent of PCI busid %04x:%02x:%02x.%01x\n",
432  	      busid->domain, busid->bus, busid->dev, busid->func);
433    if (topology->pci_has_forced_locality) {
434      for(i=0; i<topology->pci_forced_locality_nr; i++) {
435        if (busid->domain == topology->pci_forced_locality[i].domain
436  	  && busid->bus >= topology->pci_forced_locality[i].bus_first
437  	  && busid->bus <= topology->pci_forced_locality[i].bus_last) {
438  	hwloc_bitmap_copy(cpuset, topology->pci_forced_locality[i].cpuset);
439  	forced = 1;
440  	break;
441        }
442      }
443      noquirks = 1;
444    }
445    if (!forced) {
446      const char *env;
447      char envname[256];
448      snprintf(envname, sizeof(envname), "HWLOC_PCI_%04x_%02x_LOCALCPUS",
449  	     busid->domain, busid->bus);
450      env = getenv(envname);
451      if (env) {
452        static int reported = 0;
453        if (!topology->pci_has_forced_locality && !reported) {
454          if (HWLOC_SHOW_ALL_ERRORS())
455            fprintf(stderr, "hwloc/pci: Environment variable %s is deprecated, please use HWLOC_PCI_LOCALITY instead.\n", env);
456  	reported = 1;
457        }
458        if (*env) {
459  	hwloc_debug("Overriding PCI locality using %s in the environment\n", envname);
460  	hwloc_bitmap_sscanf(cpuset, env);
461  	forced = 1;
462        }
463        noquirks = 1;
464      }
465    }
466    if (!forced && !noquirks && topology->pci_locality_quirks &bsol;* either quirks are unknown yet, or some are enabled */) {
467      err = hwloc__pci_find_busid_parent_quirk(topology, busid, cpuset);
468      if (err > 0)
469        got_quirked = 1;
470    }
471    if (!forced && !got_quirked) {
472      struct hwloc_backend *backend = topology->get_pci_busid_cpuset_backend;
473      if (backend)
474        err = backend->get_pci_busid_cpuset(backend, busid, cpuset);
475      else
476        err = -1;
477      if (err < 0)
478        hwloc_bitmap_copy(cpuset, hwloc_topology_get_topology_cpuset(topology));
479    }
480    hwloc_debug_bitmap("  will attach PCI bus to cpuset %s\n", cpuset);
481    parent = hwloc_find_insert_io_parent_by_complete_cpuset(topology, cpuset);
482    if (!parent) {
483      parent = hwloc_get_root_obj(topology);
484    }
485    hwloc_bitmap_free(cpuset);
486    return parent;
487  }
488  int
489  hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree)
490  {
491    enum hwloc_type_filter_e bfilter;
492    if (!tree)
493      return 0;
494  #ifdef HWLOC_DEBUG
495    hwloc_debug("%s", "\nPCI hierarchy:\n");
496    hwloc_pci_traverse(NULL, tree, hwloc_pci_traverse_print_cb);
497    hwloc_debug("%s", "\n");
498  #endif
499    bfilter = topology->type_filter[HWLOC_OBJ_BRIDGE];
500    if (bfilter != HWLOC_TYPE_FILTER_KEEP_NONE) {
501      tree = hwloc_pcidisc_add_hostbridges(topology, tree);
502    }
503    while (tree) {
504      struct hwloc_obj *obj, *pciobj;
505      struct hwloc_obj *parent;
506      struct hwloc_pci_locality_s *loc;
507      unsigned domain, bus_min, bus_max;
508      obj = tree;
509      if (obj->type == HWLOC_OBJ_BRIDGE && obj->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_HOST)
510        pciobj = obj->io_first_child;
511      else
512        pciobj = obj;
513      assert(pciobj->type == HWLOC_OBJ_PCI_DEVICE
514  	   || (pciobj->type == HWLOC_OBJ_BRIDGE && pciobj->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI));
515      if (obj->type == HWLOC_OBJ_BRIDGE && obj->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
516        domain = obj->attr->bridge.downstream.pci.domain;
517        bus_min = obj->attr->bridge.downstream.pci.secondary_bus;
518        bus_max = obj->attr->bridge.downstream.pci.subordinate_bus;
519      } else {
520        domain = pciobj->attr->pcidev.domain;
521        bus_min = pciobj->attr->pcidev.bus;
522        bus_max = pciobj->attr->pcidev.bus;
523      }
524      parent = hwloc__pci_find_busid_parent(topology, &pciobj->attr->pcidev);
525      if (topology->last_pci_locality
526  	&& parent == topology->last_pci_locality->parent
527  	&& domain == topology->last_pci_locality->domain
528  	&& (bus_min == topology->last_pci_locality->bus_max
529  	    || bus_min == topology->last_pci_locality->bus_max+1)) {
530        hwloc_debug("  Reusing PCI locality up to bus %04x:%02x\n",
531  		  domain, bus_max);
532        topology->last_pci_locality->bus_max = bus_max;
533        goto done;
534      }
535      loc = malloc(sizeof(*loc));
536      if (!loc) {
537        parent = hwloc_get_root_obj(topology);
538        goto done;
539      }
540      loc->domain = domain;
541      loc->bus_min = bus_min;
542      loc->bus_max = bus_max;
543      loc->parent = parent;
544      loc->cpuset = hwloc_bitmap_dup(parent->cpuset);
545      if (!loc->cpuset) {
546        free(loc);
547        parent = hwloc_get_root_obj(topology);
548        goto done;
549      }
550      hwloc_debug("Adding PCI locality %s P#%u for bus %04x:[%02x:%02x]\n",
551  		hwloc_obj_type_string(parent->type), parent->os_index, loc->domain, loc->bus_min, loc->bus_max);
552      if (topology->last_pci_locality) {
553        loc->prev = topology->last_pci_locality;
554        loc->next = NULL;
555        topology->last_pci_locality->next = loc;
556        topology->last_pci_locality = loc;
557      } else {
558        loc->prev = NULL;
559        loc->next = NULL;
560        topology->first_pci_locality = loc;
561        topology->last_pci_locality = loc;
562      }
563    done:
564      tree = obj->next_sibling;
565      obj->next_sibling = NULL;
566      hwloc_insert_object_by_parent(topology, parent, obj);
567    }
568    return 0;
569  }
570  struct hwloc_obj *
571  hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology,
572  			       unsigned domain, unsigned bus, unsigned dev, unsigned func)
573  {
574    struct hwloc_pcidev_attr_s busid;
575    hwloc_obj_t parent;
576    parent = hwloc_pci_find_by_busid(topology, domain, bus, dev, func);
577    if (parent)
578      return parent;
579    busid.domain = domain;
580    busid.bus = bus;
581    busid.dev = dev;
582    busid.func = func;
583    return hwloc__pci_find_busid_parent(topology, &busid);
584  }
585  static struct hwloc_obj *
586  hwloc__pci_find_by_busid(hwloc_obj_t parent,
587  			 unsigned domain, unsigned bus, unsigned dev, unsigned func)
588  {
589    hwloc_obj_t child;
590    for_each_io_child(child, parent) {
591      if (child->type == HWLOC_OBJ_PCI_DEVICE
592  	|| (child->type == HWLOC_OBJ_BRIDGE
593  	    && child->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI)) {
594        if (child->attr->pcidev.domain == domain
595  	  && child->attr->pcidev.bus == bus
596  	  && child->attr->pcidev.dev == dev
597  	  && child->attr->pcidev.func == func)
598  	return child;
599        if (child->attr->pcidev.domain > domain
600  	  || (child->attr->pcidev.domain == domain
601  	      && child->attr->pcidev.bus > bus))
602  	return parent;
603        if (child->type == HWLOC_OBJ_BRIDGE
604  	  && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
605  	  && child->attr->bridge.downstream.pci.domain == domain
606  	  && child->attr->bridge.downstream.pci.secondary_bus <= bus
607  	  && child->attr->bridge.downstream.pci.subordinate_bus >= bus)
608  	return hwloc__pci_find_by_busid(child, domain, bus, dev, func);
609      } else if (child->type == HWLOC_OBJ_BRIDGE
610  	       && child->attr->bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI
611  	       && child->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI
612  	       && child->attr->bridge.downstream.pci.domain == domain
613  	       && child->attr->bridge.downstream.pci.secondary_bus <= bus
614  	       && child->attr->bridge.downstream.pci.subordinate_bus >= bus) {
615        return hwloc__pci_find_by_busid(child, domain, bus, dev, func);
616      }
617    }
618    return parent;
619  }
620  struct hwloc_obj *
621  hwloc_pci_find_by_busid(struct hwloc_topology *topology,
622  			unsigned domain, unsigned bus, unsigned dev, unsigned func)
623  {
624    struct hwloc_pci_locality_s *loc;
625    hwloc_obj_t root = hwloc_get_root_obj(topology);
626    hwloc_obj_t parent = NULL;
627    hwloc_debug("pcidisc looking for bus id %04x:%02x:%02x.%01x\n", domain, bus, dev, func);
628    loc = topology->first_pci_locality;
629    while (loc) {
630      if (loc->domain == domain && loc->bus_min <= bus && loc->bus_max >= bus) {
631        parent = loc->parent;
632        assert(parent);
633        hwloc_debug("  found pci locality for %04x:[%02x:%02x]\n",
634  		  loc->domain, loc->bus_min, loc->bus_max);
635        break;
636      }
637      loc = loc->next;
638    }
639    if (!parent)
640      parent = root;
641    hwloc_debug("  looking for bus %04x:%02x:%02x.%01x below %s P#%u\n",
642  	      domain, bus, dev, func,
643  	      hwloc_obj_type_string(parent->type), parent->os_index);
644    parent = hwloc__pci_find_by_busid(parent, domain, bus, dev, func);
645    if (parent == root) {
646      hwloc_debug("  found nothing better than root object, ignoring\n");
647      return NULL;
648    } else {
649      if (parent->type == HWLOC_OBJ_PCI_DEVICE
650  	|| (parent->type == HWLOC_OBJ_BRIDGE && parent->attr->bridge.upstream_type == HWLOC_OBJ_BRIDGE_PCI))
651        hwloc_debug("  found busid %04x:%02x:%02x.%01x\n",
652  		  parent->attr->pcidev.domain, parent->attr->pcidev.bus,
653  		  parent->attr->pcidev.dev, parent->attr->pcidev.func);
654      else
655        hwloc_debug("  found parent %s P#%u\n",
656  		  hwloc_obj_type_string(parent->type), parent->os_index);
657      return parent;
658    }
659  }
660  #define HWLOC_PCI_STATUS 0x06
661  #define HWLOC_PCI_STATUS_CAP_LIST 0x10
662  #define HWLOC_PCI_CAPABILITY_LIST 0x34
663  #define HWLOC_PCI_CAP_LIST_ID 0
664  #define HWLOC_PCI_CAP_LIST_NEXT 1
665  unsigned
666  hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap)
667  {
668    unsigned char seen[256] = { 0 };
669    unsigned char ptr; &bsol;* unsigned char to make sure we stay within the 256-byte config space */
670    if (!(config[HWLOC_PCI_STATUS] & HWLOC_PCI_STATUS_CAP_LIST))
671      return 0;
672    for (ptr = config[HWLOC_PCI_CAPABILITY_LIST] & ~3;
673         ptr; &bsol;* exit if next is 0 */
674         ptr = config[ptr + HWLOC_PCI_CAP_LIST_NEXT] & ~3) {
675      unsigned char id;
676      if (seen[ptr])
677        break;
678      seen[ptr] = 1;
679      id = config[ptr + HWLOC_PCI_CAP_LIST_ID];
680      if (id == cap)
681        return ptr;
682      if (id == 0xff) &bsol;* exit if id is 0 or 0xff */
683        break;
684    }
685    return 0;
686  }
687  #define HWLOC_PCI_EXP_LNKSTA 0x12
688  #define HWLOC_PCI_EXP_LNKSTA_SPEED 0x000f
689  #define HWLOC_PCI_EXP_LNKSTA_WIDTH 0x03f0
690  int
691  hwloc_pcidisc_find_linkspeed(const unsigned char *config,
692  			     unsigned offset, float *linkspeed)
693  {
694    unsigned linksta, speed, width;
695    float lanespeed;
696    memcpy(&linksta, &config[offset + HWLOC_PCI_EXP_LNKSTA], 4);
697    speed = linksta & HWLOC_PCI_EXP_LNKSTA_SPEED; &bsol;* PCIe generation */
698    width = (linksta & HWLOC_PCI_EXP_LNKSTA_WIDTH) >> 4; &bsol;* how many lanes */
699    if (speed <= 2)
700      lanespeed = 2.5f * speed * 0.8f;
701    else if (speed <= 5)
702      lanespeed = 8.0f * (1<<(speed-3)) * 128/130;
703    else
704      lanespeed = 8.0f * (1<<(speed-3)) * 242/256; &bsol;* assume Gen8 will be 256 GT/s and so on */
705    *linkspeed = lanespeed * width / 8;
706    return 0;
707  }
708  #define HWLOC_PCI_HEADER_TYPE 0x0e
709  #define HWLOC_PCI_HEADER_TYPE_BRIDGE 1
710  #define HWLOC_PCI_CLASS_BRIDGE_PCI 0x0604
711  hwloc_obj_type_t
712  hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config)
713  {
714    unsigned char headertype;
715    if (device_class != HWLOC_PCI_CLASS_BRIDGE_PCI)
716      return HWLOC_OBJ_PCI_DEVICE;
717    headertype = config[HWLOC_PCI_HEADER_TYPE] & 0x7f;
718    return (headertype == HWLOC_PCI_HEADER_TYPE_BRIDGE)
719      ? HWLOC_OBJ_BRIDGE : HWLOC_OBJ_PCI_DEVICE;
720  }
721  #define HWLOC_PCI_PRIMARY_BUS 0x18
722  #define HWLOC_PCI_SECONDARY_BUS 0x19
723  #define HWLOC_PCI_SUBORDINATE_BUS 0x1a
724  int
725  hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,
726  				unsigned *secondary_busp, unsigned *subordinate_busp,
727  				const unsigned char *config)
728  {
729    unsigned secondary_bus, subordinate_bus;
730    if (config[HWLOC_PCI_PRIMARY_BUS] != bus) {
731      hwloc_debug("  %04x:%02x:%02x.%01x bridge with (ignored) invalid PCI_PRIMARY_BUS %02x\n",
732  		domain, bus, dev, func, config[HWLOC_PCI_PRIMARY_BUS]);
733    }
734    secondary_bus = config[HWLOC_PCI_SECONDARY_BUS];
735    subordinate_bus = config[HWLOC_PCI_SUBORDINATE_BUS];
736    if (secondary_bus <= bus
737        || subordinate_bus <= bus
738        || secondary_bus > subordinate_bus) {
739      hwloc_debug("  %04x:%02x:%02x.%01x bridge has invalid secondary-subordinate buses [%02x-%02x]\n",
740  		domain, bus, dev, func,
741  		secondary_bus, subordinate_bus);
742      return -1;
743    }
744    *secondary_busp = secondary_bus;
745    *subordinate_busp = subordinate_bus;
746    return 0;
747  }
748  const char *
749  hwloc_pci_class_string(unsigned short class_id)
750  {
751    switch ((class_id & 0xff00) >> 8) {
752      case 0x00:
753        switch (class_id) {
754  	case 0x0001: return "VGA";
755        }
756        break;
757      case 0x01:
758        switch (class_id) {
759  	case 0x0100: return "SCSI";
760  	case 0x0101: return "IDE";
761  	case 0x0102: return "Floppy";
762  	case 0x0103: return "IPI";
763  	case 0x0104: return "RAID";
764  	case 0x0105: return "ATA";
765  	case 0x0106: return "SATA";
766  	case 0x0107: return "SAS";
767  	case 0x0108: return "NVMExp";
768        }
769        return "Storage";
770      case 0x02:
771        switch (class_id) {
772  	case 0x0200: return "Ethernet";
773  	case 0x0201: return "TokenRing";
774  	case 0x0202: return "FDDI";
775  	case 0x0203: return "ATM";
776  	case 0x0204: return "ISDN";
777  	case 0x0205: return "WorldFip";
778  	case 0x0206: return "PICMG";
779  	case 0x0207: return "InfiniBand";
780  	case 0x0208: return "Fabric";
781        }
782        return "Network";
783      case 0x03:
784        switch (class_id) {
785  	case 0x0300: return "VGA";
786  	case 0x0301: return "XGA";
787  	case 0x0302: return "3D";
788        }
789        return "Display";
790      case 0x04:
791        switch (class_id) {
792  	case 0x0400: return "MultimediaVideo";
793  	case 0x0401: return "MultimediaAudio";
794  	case 0x0402: return "Telephony";
795  	case 0x0403: return "AudioDevice";
796        }
797        return "Multimedia";
798      case 0x05:
799        switch (class_id) {
800  	case 0x0500: return "RAM";
801  	case 0x0501: return "Flash";
802          case 0x0502: return "CXLMem";
803        }
804        return "Memory";
805      case 0x06:
806        switch (class_id) {
807  	case 0x0600: return "HostBridge";
808  	case 0x0601: return "ISABridge";
809  	case 0x0602: return "EISABridge";
810  	case 0x0603: return "MicroChannelBridge";
811  	case 0x0604: return "PCIBridge";
812  	case 0x0605: return "PCMCIABridge";
813  	case 0x0606: return "NubusBridge";
814  	case 0x0607: return "CardBusBridge";
815  	case 0x0608: return "RACEwayBridge";
816  	case 0x0609: return "SemiTransparentPCIBridge";
817  	case 0x060a: return "InfiniBandPCIHostBridge";
818        }
819        return "Bridge";
820      case 0x07:
821        switch (class_id) {
822  	case 0x0700: return "Serial";
823  	case 0x0701: return "Parallel";
824  	case 0x0702: return "MultiportSerial";
825  	case 0x0703: return "Model";
826  	case 0x0704: return "GPIB";
827  	case 0x0705: return "SmartCard";
828        }
829        return "Communication";
830      case 0x08:
831        switch (class_id) {
832  	case 0x0800: return "PIC";
833  	case 0x0801: return "DMA";
834  	case 0x0802: return "Timer";
835  	case 0x0803: return "RTC";
836  	case 0x0804: return "PCIHotPlug";
837  	case 0x0805: return "SDHost";
838  	case 0x0806: return "IOMMU";
839        }
840        return "SystemPeripheral";
841      case 0x09:
842        switch (class_id) {
843  	case 0x0900: return "Keyboard";
844  	case 0x0901: return "DigitizerPen";
845  	case 0x0902: return "Mouse";
846  	case 0x0903: return "Scanern";
847  	case 0x0904: return "Gameport";
848        }
849        return "Input";
850      case 0x0a:
851        return "DockingStation";
852      case 0x0b:
853        switch (class_id) {
854  	case 0x0b00: return "386";
855  	case 0x0b01: return "486";
856  	case 0x0b02: return "Pentium";
857  	case 0x0b10: return "Alpha";
858  	case 0x0b20: return "PowerPC";
859  	case 0x0b30: return "MIPS";
860  	case 0x0b40: return "Co-Processor";
861        }
862        return "Processor";
863      case 0x0c:
864        switch (class_id) {
865  	case 0x0c00: return "FireWire";
866  	case 0x0c01: return "ACCESS";
867  	case 0x0c02: return "SSA";
868  	case 0x0c03: return "USB";
869  	case 0x0c04: return "FibreChannel";
870  	case 0x0c05: return "SMBus";
871  	case 0x0c06: return "InfiniBand";
872  	case 0x0c07: return "IPMI-SMIC";
873  	case 0x0c08: return "SERCOS";
874  	case 0x0c09: return "CANBUS";
875        }
876        return "SerialBus";
877      case 0x0d:
878        switch (class_id) {
879  	case 0x0d00: return "IRDA";
880  	case 0x0d01: return "ConsumerIR";
881  	case 0x0d10: return "RF";
882  	case 0x0d11: return "Bluetooth";
883  	case 0x0d12: return "Broadband";
884  	case 0x0d20: return "802.1a";
885  	case 0x0d21: return "802.1b";
886        }
887        return "Wireless";
888      case 0x0e:
889        switch (class_id) {
890  	case 0x0e00: return "I2O";
891        }
892        return "Intelligent";
893      case 0x0f:
894        return "Satellite";
895      case 0x10:
896        return "Encryption";
897      case 0x11:
898        return "SignalProcessing";
899      case 0x12:
900        return "ProcessingAccelerator";
901      case 0x13:
902        return "Instrumentation";
903      case 0x40:
904        return "Co-Processor";
905    }
906    return "Other";
907  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pci-common.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pci-common.c</div>
                </div>
                <div class="column column_space"><pre><code>121              fprintf(stderr, "hwloc/pci: Ignoring HWLOC_PCI_LOCALITY file `%s' too large (%lu bytes)\n",
122                      env, (unsigned long) st.st_size);
123  	}
</pre></code></div>
                <div class="column column_space"><pre><code>121              fprintf(stderr, "hwloc/pci: Ignoring HWLOC_PCI_LOCALITY file `%s' too large (%lu bytes)\n",
122                      env, (unsigned long) st.st_size);
123  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    