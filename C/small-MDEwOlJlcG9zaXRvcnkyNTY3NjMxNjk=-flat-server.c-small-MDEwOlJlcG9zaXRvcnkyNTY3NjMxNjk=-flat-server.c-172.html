
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 37, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;config.h&quot;
3  #endif
4  #include &lt;sys/stat.h&gt;
5  #include &lt;sys/types.h&gt;
6  #include &lt;fcntl.h&gt;
7  #include &lt;locale.h&gt;
8  #include &lt;signal.h&gt;
9  #include &lt;string.h&gt;
10  #include &lt;strings.h&gt;
11  #include &lt;time.h&gt;
12  #include &lt;unistd.h&gt;
13  #include &lt;getopt.h&gt;
14  #include &lt;math.h&gt;
15  #ifndef __MINGW32__
16  #include &lt;netdb.h&gt;
17  #include &lt;errno.h&gt;
18  #include &lt;arpa/inet.h&gt;
19  #include &lt;netinet/in.h&gt;
20  #include &lt;pthread.h&gt;
21  #include &lt;sys/un.h&gt;
22  #endif
23  #include &lt;libcork/core.h&gt;
24  #include &lt;udns.h&gt;
25  #ifdef __MINGW32__
26  #include &quot;win32.h&quot;
27  #endif
28  #if defined(HAVE_SYS_IOCTL_H) &amp;&amp; defined(HAVE_NET_IF_H) &amp;&amp; defined(__linux__)
29  #include &lt;net/if.h&gt;
30  #include &lt;sys/ioctl.h&gt;
31  #define SET_INTERFACE
32  #endif
33  #include &quot;netutils.h&quot;
34  #include &quot;utils.h&quot;
35  #include &quot;acl.h&quot;
36  #include &quot;server.h&quot;
37  #include &quot;obfs.c&quot; 
38  #ifndef EAGAIN
39  #define EAGAIN EWOULDBLOCK
40  #endif
41  #ifndef EWOULDBLOCK
42  #define EWOULDBLOCK EAGAIN
43  #endif
44  #ifndef BUF_SIZE
45  #define BUF_SIZE 2048
46  #endif
47  #ifndef SSMAXCONN
48  #define SSMAXCONN 1024
49  #endif
50  #ifndef UPDATE_INTERVAL
51  #define UPDATE_INTERVAL 30
52  #endif
53  static void signal_cb(EV_P_ ev_signal *w, int revents);
54  static void accept_cb(EV_P_ ev_io *w, int revents);
55  static void server_send_cb(EV_P_ ev_io *w, int revents);
56  static void server_recv_cb(EV_P_ ev_io *w, int revents);
57  static void remote_recv_cb(EV_P_ ev_io *w, int revents);
58  static void remote_send_cb(EV_P_ ev_io *w, int revents);
59  static void server_timeout_cb(EV_P_ ev_timer *watcher, int revents);
60  static void block_list_clear_cb(EV_P_ ev_timer *watcher, int revents);
61  static remote_t *new_remote(int fd);
62  static server_t *new_server(int fd, listen_ctx_t *listener);
63  static remote_t *connect_to_remote(EV_P_ struct addrinfo *res,
64                                     server_t *server);
65  static void free_remote(remote_t *remote);
66  static void close_and_free_remote(EV_P_ remote_t *remote);
67  static void free_server(server_t *server);
68  static void close_and_free_server(EV_P_ server_t *server);
69  static void server_resolve_cb(struct sockaddr *addr, void *data);
70  static void query_free_cb(void *data);
71  static size_t parse_header_len(const char atyp, const char *data, size_t offset);
72  static int is_header_complete(const buffer_t *buf);
73  int verbose = 0;
74  static int acl       = 0;
75  static int mode      = TCP_ONLY;
76  static int auth      = 0;
77  static int ipv6first = 0;
78  static int protocol_compatible = 0;
79  static int obfs_compatible = 0;
80  static int fast_open = 0;
81  #ifdef HAVE_SETRLIMIT
82  static int nofile = 0;
83  #endif
84  static int remote_conn = 0;
85  static int server_conn = 0;
86  static char *bind_address    = NULL;
87  static char *server_port     = NULL;
88  static char *manager_address = NULL;
89  uint64_t tx                  = 0;
90  uint64_t rx                  = 0;
91  ev_timer stat_update_watcher;
92  ev_timer block_list_watcher;
93  static struct cork_dllist connections;
94  static void
95  stat_update_cb(EV_P_ ev_timer *watcher, int revents)
96  {
97      struct sockaddr_un svaddr, claddr;
98      int sfd = -1;
99      size_t msgLen;
100      char resp[BUF_SIZE];
101      if (verbose) {
102          LOGI(&quot;update traffic stat: tx: %&quot; PRIu64 &quot; rx: %&quot; PRIu64 &quot;&quot;, tx, rx);
103      }
104      snprintf(resp, BUF_SIZE, &quot;stat: {\&quot;%s\&quot;:%&quot; PRIu64 &quot;}&quot;, server_port, tx + rx);
105      msgLen = strlen(resp) + 1;
106      ss_addr_t ip_addr = { .host = NULL, .port = NULL };
107      parse_addr(manager_address, &amp;ip_addr);
108      if (ip_addr.host == NULL || ip_addr.port == NULL) {
109          sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
110          if (sfd == -1) {
111              ERROR(&quot;stat_socket&quot;);
112              return;
113          }
114          memset(&amp;claddr, 0, sizeof(struct sockaddr_un));
115          claddr.sun_family = AF_UNIX;
116          snprintf(claddr.sun_path, sizeof(claddr.sun_path), &quot;/tmp/shadowsocks.%s&quot;, server_port);
117          unlink(claddr.sun_path);
118          if (bind(sfd, (struct sockaddr *)&amp;claddr, sizeof(struct sockaddr_un)) == -1) {
119              ERROR(&quot;stat_bind&quot;);
120              close(sfd);
121              return;
122          }
123          memset(&amp;svaddr, 0, sizeof(struct sockaddr_un));
124          svaddr.sun_family = AF_UNIX;
125          strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);
126          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&amp;svaddr,
127                     sizeof(struct sockaddr_un)) != msgLen) {
128              ERROR(&quot;stat_sendto&quot;);
129              close(sfd);
130              return;
131          }
132          unlink(claddr.sun_path);
133      } else {
134          struct sockaddr_storage storage;
135          memset(&amp;storage, 0, sizeof(struct sockaddr_storage));
136          if (get_sockaddr(ip_addr.host, ip_addr.port, &amp;storage, 0, ipv6first) == -1) {
137              ERROR(&quot;failed to parse the manager addr&quot;);
138              return;
139          }
140          sfd = socket(storage.ss_family, SOCK_DGRAM, 0);
141          if (sfd == -1) {
142              ERROR(&quot;stat_socket&quot;);
143              return;
144          }
145          size_t addr_len = get_sockaddr_len((struct sockaddr *)&amp;storage);
146          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&amp;storage,
147                     addr_len) != msgLen) {
148              ERROR(&quot;stat_sendto&quot;);
149              close(sfd);
150              return;
151          }
152      }
153      close(sfd);
154  }
155  static void
156  free_connections(struct ev_loop *loop)
157  {
158      struct cork_dllist_item *curr, *next;
159      cork_dllist_foreach_void(&amp;connections, curr, next) {
160          server_t *server = cork_container_of(curr, server_t, entries);
161          remote_t *remote = server-&gt;remote;
162          close_and_free_server(loop, server);
163          close_and_free_remote(loop, remote);
164      }
165  }
166  static size_t
167  parse_header_len(const char atyp, const char *data, size_t offset)
168  {
169      size_t len = 0;
170      if ((atyp &amp; ADDRTYPE_MASK) == 1) {
171          len += sizeof(struct in_addr);
172      } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
173          uint8_t name_len = *(uint8_t *)(data + offset);
174          len += name_len + 1;
175      } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
176          len += sizeof(struct in6_addr);
177      } else {
178          return 0;
179      }
180      len += 2;
181      return len;
182  }
183  static int
184  is_header_complete(const buffer_t *buf)
185  {
186      size_t header_len = 0;
187      size_t buf_len    = buf-&gt;len;
188      char atyp = buf-&gt;array[header_len];
189      header_len++;
190      if ((atyp &amp; ADDRTYPE_MASK) == 1) {
191          header_len += sizeof(struct in_addr);
192      } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
193          if (buf_len &lt; header_len + 1)
194              return 0;
195          uint8_t name_len = *(uint8_t *)(buf-&gt;array + header_len);
196          header_len += name_len + 1;
197      } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
198          header_len += sizeof(struct in6_addr);
199      } else {
200          return -1;
201      }
202      header_len += 2;
203      if (auth || (atyp &amp; ONETIMEAUTH_FLAG)) {
204          header_len += ONETIMEAUTH_BYTES;
205      }
206      return buf_len &gt;= header_len ? 1 : 0;
207  }
208  static char *
209  get_peer_name(int fd)
210  {
211      static char peer_name[INET6_ADDRSTRLEN] = { 0 };
212      struct sockaddr_storage addr;
213      socklen_t len = sizeof(struct sockaddr_storage);
214      memset(&amp;addr, 0, len);
215      memset(peer_name, 0, INET6_ADDRSTRLEN);
216      int err = getpeername(fd, (struct sockaddr *)&amp;addr, &amp;len);
217      if (err == 0) {
218          if (addr.ss_family == AF_INET) {
219              struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;
220              dns_ntop(AF_INET, &amp;s-&gt;sin_addr, peer_name, INET_ADDRSTRLEN);
221          } else if (addr.ss_family == AF_INET6) {
222              struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;addr;
223              dns_ntop(AF_INET6, &amp;s-&gt;sin6_addr, peer_name, INET6_ADDRSTRLEN);
224          }
225      } else {
226          return NULL;
227      }
228      return peer_name;
229  }
230  #ifdef __linux__
231  static void
232  set_linger(int fd)
233  {
234      struct linger so_linger;
235      memset(&amp;so_linger, 0, sizeof(struct linger));
236      so_linger.l_onoff  = 1;
237      so_linger.l_linger = 0;
238      setsockopt(fd, SOL_SOCKET, SO_LINGER, &amp;so_linger, sizeof so_linger);
239  }
240  #endif
241  static void
242  reset_addr(int fd)
243  {
244      char *peer_name;
245      peer_name = get_peer_name(fd);
246      if (peer_name != NULL) {
247          remove_from_block_list(peer_name);
248      }
249  }
250  static void
251  report_addr(int fd, int err_level)
252  {
253  #ifdef __linux__
254      set_linger(fd);
255  #endif
256      char *peer_name;
257      peer_name = get_peer_name(fd);
258      if (peer_name != NULL) {
259          LOGE(&quot;failed to handshake with %s&quot;, peer_name);
260          update_block_list(peer_name, err_level);
261      }
262  }
263  int
264  setfastopen(int fd)
265  {
266      int s = 0;
267  #ifdef TCP_FASTOPEN
268      if (fast_open) {
269  #ifdef __APPLE__
270          int opt = 1;
271  #else
272          int opt = 5;
273  #endif
274          s = setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &amp;opt, sizeof(opt));
275          if (s == -1) {
276              if (errno == EPROTONOSUPPORT || errno == ENOPROTOOPT) {
277                  LOGE(&quot;fast open is not supported on this platform&quot;);
278                  fast_open = 0;
279              } else {
280                  ERROR(&quot;setsockopt&quot;);
281              }
282          }
283      }
284  #endif
285      return s;
286  }
287  #ifndef __MINGW32__
288  int
289  setnonblocking(int fd)
290  {
291      int flags;
292      if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
293          flags = 0;
294      }
295      return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
296  }
297  #endif
298  int
299  create_and_bind(const char *host, const char *port, int mptcp)
300  {
301      struct addrinfo hints;
302      struct addrinfo *result, *rp, *ipv4v6bindall;
303      int s, listen_sock;
304      memset(&amp;hints, 0, sizeof(struct addrinfo));
305      hints.ai_family   = AF_UNSPEC;               &amp;bsol;* Return IPv4 and IPv6 choices */
306      hints.ai_socktype = SOCK_STREAM;             &amp;bsol;* We want a TCP socket */
307      hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; &amp;bsol;* For wildcard IP address */
308      hints.ai_protocol = IPPROTO_TCP;
309      for (int i = 1; i &lt; 8; i++) {
310          s = getaddrinfo(host, port, &amp;hints, &amp;result);
311          if (s == 0) {
312              break;
313          } else {
314              sleep(pow(2, i));
315              LOGE(&quot;failed to resolve server name, wait %.0f seconds&quot;, pow(2, i));
316          }
317      }
318      if (s != 0) {
319          LOGE(&quot;getaddrinfo: %s&quot;, gai_strerror(s));
320          return -1;
321      }
322      rp = result;
323      if (!host) {
324          ipv4v6bindall = result;
325          while (ipv4v6bindall) {
326              if (ipv4v6bindall-&gt;ai_family == AF_INET6) {
327                  rp = ipv4v6bindall; &amp;bsol;* Take first IPV6 address available */
328                  break;
329              }
330              ipv4v6bindall = ipv4v6bindall-&gt;ai_next; &amp;bsol;* Get next address info, if any */
331          }
332      }
333      for (&amp;bsol;*rp = result*/; rp != NULL; rp = rp-&gt;ai_next) {
334          listen_sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
335          if (listen_sock == -1) {
336              continue;
337          }
338          if (rp-&gt;ai_family == AF_INET6) {
339              int ipv6only = host ? 1 : 0;
340              setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &amp;ipv6only, sizeof(ipv6only));
341          }
342          int opt = 1;
343          setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
344  #ifdef SO_NOSIGPIPE
345          setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
346  #endif
347          int err = set_reuseport(listen_sock);
348          if (err == 0) {
349              LOGI(&quot;tcp port reuse enabled&quot;);
350          }
351          if (mptcp == 1) {
352              int err = setsockopt(listen_sock, SOL_TCP, MPTCP_ENABLED, &amp;opt, sizeof(opt));
353              if (err == -1) {
354                  ERROR(&quot;failed to enable multipath TCP&quot;);
355              }
356          }
357          s = bind(listen_sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen);
358          if (s == 0) {
359              break;
360          } else {
361              ERROR(&quot;bind&quot;);
362          }
363          close(listen_sock);
364      }
365      if (rp == NULL) {
366          LOGE(&quot;Could not bind&quot;);
367          return -1;
368      }
369      freeaddrinfo(result);
370      return listen_sock;
371  }
372  static remote_t *
373  connect_to_remote(EV_P_ struct addrinfo *res,
374                    server_t *server)
375  {
376      int sockfd;
377  #ifdef SET_INTERFACE
378      const char *iface = server-&gt;listen_ctx-&gt;iface;
379  #endif
380      if (acl) {
381          char ipstr[INET6_ADDRSTRLEN];
382          memset(ipstr, 0, INET6_ADDRSTRLEN);
383          if (res-&gt;ai_addr-&gt;sa_family == AF_INET) {
384              struct sockaddr_in *s = (struct sockaddr_in *)res-&gt;ai_addr;
385              dns_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, INET_ADDRSTRLEN);
386          } else if (res-&gt;ai_addr-&gt;sa_family == AF_INET6) {
387              struct sockaddr_in6 *s = (struct sockaddr_in6 *)res-&gt;ai_addr;
388              dns_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, INET6_ADDRSTRLEN);
389          }
390          if (outbound_block_match_host(ipstr) == 1) {
391              if (verbose)
392                  LOGI(&quot;outbound blocked %s&quot;, ipstr);
393              return NULL;
394          }
395      }
396      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
397      if (sockfd == -1) {
398          ERROR(&quot;socket&quot;);
399          close(sockfd);
400          return NULL;
401      }
402      int opt = 1;
403      setsockopt(sockfd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
404  #ifdef SO_NOSIGPIPE
405      setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
406  #endif
407      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
408      if (setnonblocking(sockfd) == -1)
409          ERROR(&quot;setnonblocking&quot;);
410      if (bind_address != NULL)
411          if (bind_to_address(sockfd, bind_address) == -1) {
412              ERROR(&quot;bind_to_address&quot;);
413              close(sockfd);
414              return NULL;
415          }
416  #ifdef SET_INTERFACE
417      if (iface) {
418          if (setinterface(sockfd, iface) == -1) {
419              ERROR(&quot;setinterface&quot;);
420              close(sockfd);
421              return NULL;
422          }
423      }
424  #endif
425      remote_t *remote = new_remote(sockfd);
426  #ifdef TCP_FASTOPEN
427      if (fast_open) {
428  #ifdef __APPLE__
429          ((struct sockaddr_in *)(res-&gt;ai_addr))-&gt;sin_len = sizeof(struct sockaddr_in);
430          sa_endpoints_t endpoints;
431          memset((char *)&amp;endpoints, 0, sizeof(endpoints));
432          endpoints.sae_dstaddr    = res-&gt;ai_addr;
433          endpoints.sae_dstaddrlen = res-&gt;ai_addrlen;
434          struct iovec iov;
435          iov.iov_base = server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx;
436          iov.iov_len  = server-&gt;buf-&gt;len;
437          size_t len;
438          int s = connectx(sockfd, &amp;endpoints, SAE_ASSOCID_ANY, CONNECT_DATA_IDEMPOTENT,
439                           &amp;iov, 1, &amp;len, NULL);
440          if (s == 0) {
441              s = len;
442          }
443  #else
444          ssize_t s = sendto(sockfd, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
445                             server-&gt;buf-&gt;len, MSG_FASTOPEN, res-&gt;ai_addr,
446                             res-&gt;ai_addrlen);
447  #endif
448          if (s == -1) {
449              if (errno == CONNECT_IN_PROGRESS || errno == EAGAIN
450                  || errno == EWOULDBLOCK) {
451              } else if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
452                         errno == ENOPROTOOPT) {
453                  fast_open = 0;
454                  LOGE(&quot;fast open is not supported on this platform&quot;);
455              } else {
456                  ERROR(&quot;sendto&quot;);
457              }
458          } else if (s &lt;= server-&gt;buf-&gt;len) {
459              server-&gt;buf-&gt;idx += s;
460              server-&gt;buf-&gt;len -= s;
461          } else {
462              server-&gt;buf-&gt;idx = 0;
463              server-&gt;buf-&gt;len = 0;
464          }
465      }
466  #endif
467      if (!fast_open) {
468          int r = connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
469          if (r == -1 &amp;&amp; errno != CONNECT_IN_PROGRESS) {
470              ERROR(&quot;connect&quot;);
471              close_and_free_remote(EV_A_ remote);
472              return NULL;
473          }
474      }
475      return remote;
476  }
477  static void
478  server_recv_cb(EV_P_ ev_io *w, int revents)
479  {
480      server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
481      server_t *server              = server_recv_ctx-&gt;server;
482      remote_t *remote              = NULL;
483      int len       = server-&gt;buf-&gt;len;
484      buffer_t *buf = server-&gt;buf;
485      if (server-&gt;stage &gt; STAGE_PARSE) {
486          remote = server-&gt;remote;
487          buf    = remote-&gt;buf;
488          len    = 0;
489          ev_timer_again(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
490      }
491      if (len &gt; BUF_SIZE) {
492          ERROR(&quot;out of recv buffer&quot;);
493          close_and_free_remote(EV_A_ remote);
494          close_and_free_server(EV_A_ server);
495          return;
496      }
497      ssize_t r = recv(server-&gt;fd, buf-&gt;array + len, BUF_SIZE - len, 0);
498      if (r == 0) {
499          if (verbose) {
500              LOGI(&quot;server_recv close the connection&quot;);
501          }
502          close_and_free_remote(EV_A_ remote);
503          close_and_free_server(EV_A_ server);
504          return;
505      } else if (r == -1) {
506          if (errno == EAGAIN || errno == EWOULDBLOCK) {
507              return;
508          } else {
509              ERROR(&quot;server recv&quot;);
510              close_and_free_remote(EV_A_ remote);
511              close_and_free_server(EV_A_ server);
512              return;
513          }
514      }
515      tx += r;
516      if (server-&gt;stage == STAGE_ERROR) {
517          server-&gt;buf-&gt;len = 0;
518          server-&gt;buf-&gt;idx = 0;
519          return;
520      }
521      if (server-&gt;stage == STAGE_INIT) {
522          buf-&gt;len += r;
523          if (buf-&gt;len &lt;= enc_get_iv_len() + 1) {
524              return;
525          }
526      } else {
527          buf-&gt;len = r;
528      }
529      if (server-&gt;obfs_plugin) {
530          obfs_class *obfs_plugin = server-&gt;obfs_plugin;
531          if (obfs_plugin-&gt;server_decode) {
532              int needsendback = 0;
533              if(obfs_compatible == 1)
534              {
535                  char *back_buf = (char*)malloc(sizeof(buffer_t));
536                  memcpy(back_buf, buf, sizeof(buffer_t));
537                  buf-&gt;len = obfs_plugin-&gt;server_decode(server-&gt;obfs, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity, &amp;needsendback);
538                  if ((int)buf-&gt;len &lt; 0)
539                  {
540                      LOGE(&quot;obfs_compatible&quot;);
541                      memcpy(buf, back_buf, sizeof(buffer_t));
542                      free(back_buf);
543                      server-&gt;obfs_compatible_state = 1;
544                  }
545              }
546              else
547              {
548                  buf-&gt;len = obfs_plugin-&gt;server_decode(server-&gt;obfs, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity, &amp;needsendback);
549                  if ((int)buf-&gt;len &lt; 0) {
550                      LOGE(&quot;server_decode&quot;);
551                      close_and_free_remote(EV_A_ remote);
552                      close_and_free_server(EV_A_ server);
553                      return;
554                  }
555              }
556              if (needsendback) {
557                  size_t capacity = BUF_SIZE;
558                  char *sendback_buf = (char*)malloc(capacity);
559                  obfs_class *obfs_plugin = server-&gt;obfs_plugin;
560                  if (obfs_plugin-&gt;server_encode) {
561                      int len = obfs_plugin-&gt;server_encode(server-&gt;obfs, &amp;sendback_buf, 0, &amp;capacity);
562                      send(server-&gt;fd, sendback_buf, len, 0);
563                  }
564                  free(sendback_buf);
565                  return;
566              }
567          }
568      }
569      int err = ss_decrypt(buf, server-&gt;d_ctx, BUF_SIZE);
570      if (err) {
571          report_addr(server-&gt;fd, MALICIOUS);
572          close_and_free_remote(EV_A_ remote);
573          close_and_free_server(EV_A_ server);
574          return;
575      }
576      if (server-&gt;protocol_plugin) {
577          obfs_class *protocol_plugin = server-&gt;protocol_plugin;
578          if (protocol_plugin-&gt;server_post_decrypt) {
579              if(protocol_compatible == 1)
580              {
581                  char *back_buf = (char*)malloc(sizeof(buffer_t));
582                  memcpy(back_buf, buf, sizeof(buffer_t));
583                  buf-&gt;len = protocol_plugin-&gt;server_post_decrypt(server-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
584                  if ((int)buf-&gt;len &lt; 0) {
585                      LOGE(&quot;protocol_compatible&quot;);
586                      memcpy(buf, back_buf, sizeof(buffer_t));
587                      free(back_buf);
588                      server-&gt;protocol_compatible_state = 1;
589                  }
590                  if ( buf-&gt;len == 0 )
591                  {
592                      LOGE(&quot;protocol_compatible&quot;);
593                      memcpy(buf, back_buf, sizeof(buffer_t));
594                      free(back_buf);
595                      server-&gt;protocol_compatible_state = 1;
596                  }
597              }
598              else
599              {
600                  buf-&gt;len = protocol_plugin-&gt;server_post_decrypt(server-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
601                  if ((int)buf-&gt;len &lt; 0) {
602                      LOGE(&quot;server_post_decrypt&quot;);
603                      close_and_free_remote(EV_A_ remote);
604                      close_and_free_server(EV_A_ server);
605                      return;
606                  }
607                  if ( buf-&gt;len == 0 )
608                  {
609                      LOGE(&quot;server_post_decrypt&quot;);
610                      return;
611                  }
612              }
613          }
614      }
615      if (server-&gt;stage == STAGE_INIT) {
616          int ret = is_header_complete(server-&gt;buf);
617          if (ret == 1) {
618              bfree(server-&gt;header_buf);
619              ss_free(server-&gt;header_buf);
620              server-&gt;stage = STAGE_PARSE;
621          } else if (ret == -1) {
622              server-&gt;stage = STAGE_ERROR;
623              report_addr(server-&gt;fd, MALFORMED);
624              server-&gt;buf-&gt;len = 0;
625              server-&gt;buf-&gt;idx = 0;
626              return;
627          } else {
628              server-&gt;stage = STAGE_HANDSHAKE;
629          }
630      }
631      if (server-&gt;stage == STAGE_HANDSHAKE) {
632          size_t header_len = server-&gt;header_buf-&gt;len;
633          brealloc(server-&gt;header_buf, server-&gt;buf-&gt;len + header_len, BUF_SIZE);
634          memcpy(server-&gt;header_buf-&gt;array + header_len,
635                 server-&gt;buf-&gt;array, server-&gt;buf-&gt;len);
636          server-&gt;header_buf-&gt;len = server-&gt;buf-&gt;len + header_len;
637          int ret = is_header_complete(server-&gt;buf);
638          if (ret == 1) {
639              brealloc(server-&gt;buf, server-&gt;header_buf-&gt;len, BUF_SIZE);
640              memcpy(server-&gt;buf-&gt;array, server-&gt;header_buf-&gt;array, server-&gt;header_buf-&gt;len);
641              server-&gt;buf-&gt;len = server-&gt;header_buf-&gt;len;
642              bfree(server-&gt;header_buf);
643              ss_free(server-&gt;header_buf);
644              server-&gt;stage = STAGE_PARSE;
645          } else {
646              if (ret == -1)
647                  server-&gt;stage = STAGE_ERROR;
648              server-&gt;buf-&gt;len = 0;
649              server-&gt;buf-&gt;idx = 0;
650              return;
651          }
652      }
653      if (server-&gt;stage == STAGE_STREAM) {
654          if (server-&gt;auth &amp;&amp; !ss_check_hash(remote-&gt;buf, server-&gt;chunk, server-&gt;d_ctx, BUF_SIZE)) {
655              LOGE(&quot;hash error&quot;);
656              report_addr(server-&gt;fd, BAD);
657              close_and_free_server(EV_A_ server);
658              close_and_free_remote(EV_A_ remote);
659              return;
660          }
661          int s = send(remote-&gt;fd, remote-&gt;buf-&gt;array, remote-&gt;buf-&gt;len, 0);
662          if (s == -1) {
663              if (errno == EAGAIN || errno == EWOULDBLOCK) {
664                  remote-&gt;buf-&gt;idx = 0;
665                  ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
666                  ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
667              } else {
668                  ERROR(&quot;server_recv_send&quot;);
669                  close_and_free_remote(EV_A_ remote);
670                  close_and_free_server(EV_A_ server);
671              }
672          } else if (s &lt; remote-&gt;buf-&gt;len) {
<span onclick='openModal()' class='match'>673              remote-&gt;buf-&gt;len -= s;
674              remote-&gt;buf-&gt;idx  = s;
675              ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
676              ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
677          }
678          return;
</span>679      } else if (server-&gt;stage == STAGE_PARSE) {
680          int offset     = 0;
681          int need_query = 0;
682          char atyp      = server-&gt;buf-&gt;array[offset++];
683          char host[257] = { 0 };
684          uint16_t port  = 0;
685          struct addrinfo info;
686          struct sockaddr_storage storage;
687          memset(&amp;info, 0, sizeof(struct addrinfo));
688          memset(&amp;storage, 0, sizeof(struct sockaddr_storage));
689          if (auth || (atyp &amp; ONETIMEAUTH_FLAG)) {
690              size_t header_len = parse_header_len(atyp, server-&gt;buf-&gt;array, offset);
691              size_t len        = server-&gt;buf-&gt;len;
692              if (header_len == 0 || len &lt; offset + header_len + ONETIMEAUTH_BYTES) {
693                  report_addr(server-&gt;fd, MALFORMED);
694                  close_and_free_server(EV_A_ server);
695                  return;
696              }
697              server-&gt;buf-&gt;len = offset + header_len + ONETIMEAUTH_BYTES;
698              if (ss_onetimeauth_verify(server-&gt;buf, server-&gt;d_ctx-&gt;evp.iv)) {
699                  report_addr(server-&gt;fd, BAD);
700                  close_and_free_server(EV_A_ server);
701                  return;
702              }
703              server-&gt;buf-&gt;len = len;
704              server-&gt;auth     = 1;
705          }
706          if ((atyp &amp; ADDRTYPE_MASK) == 1) {
707              struct sockaddr_in *addr = (struct sockaddr_in *)&amp;storage;
708              size_t in_addr_len       = sizeof(struct in_addr);
709              addr-&gt;sin_family = AF_INET;
710              if (server-&gt;buf-&gt;len &gt;= in_addr_len + 3) {
711                  addr-&gt;sin_addr = *(struct in_addr *)(server-&gt;buf-&gt;array + offset);
712                  dns_ntop(AF_INET, (const void *)(server-&gt;buf-&gt;array + offset),
713                           host, INET_ADDRSTRLEN);
714                  offset += in_addr_len;
715              } else {
716                  LOGE(&quot;invalid header with addr type %d&quot;, atyp);
717                  report_addr(server-&gt;fd, MALFORMED);
718                  close_and_free_server(EV_A_ server);
719                  return;
720              }
721              addr-&gt;sin_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
722              info.ai_family   = AF_INET;
723              info.ai_socktype = SOCK_STREAM;
724              info.ai_protocol = IPPROTO_TCP;
725              info.ai_addrlen  = sizeof(struct sockaddr_in);
726              info.ai_addr     = (struct sockaddr *)addr;
727          } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
728              uint8_t name_len = *(uint8_t *)(server-&gt;buf-&gt;array + offset);
729              if (name_len + 4 &lt;= server-&gt;buf-&gt;len) {
730                  memcpy(host, server-&gt;buf-&gt;array + offset + 1, name_len);
731                  offset += name_len + 1;
732              } else {
733                  LOGE(&quot;invalid name length: %d&quot;, name_len);
734                  report_addr(server-&gt;fd, MALFORMED);
735                  close_and_free_server(EV_A_ server);
736                  return;
737              }
738              if (acl &amp;&amp; outbound_block_match_host(host) == 1) {
739                  if (verbose)
740                      LOGI(&quot;outbound blocked %s&quot;, host);
741                  close_and_free_server(EV_A_ server);
742                  return;
743              }
744              struct cork_ip ip;
745              if (cork_ip_init(&amp;ip, host) != -1) {
746                  info.ai_socktype = SOCK_STREAM;
747                  info.ai_protocol = IPPROTO_TCP;
748                  if (ip.version == 4) {
749                      struct sockaddr_in *addr = (struct sockaddr_in *)&amp;storage;
750                      dns_pton(AF_INET, host, &amp;(addr-&gt;sin_addr));
751                      addr-&gt;sin_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
752                      addr-&gt;sin_family = AF_INET;
753                      info.ai_family   = AF_INET;
754                      info.ai_addrlen  = sizeof(struct sockaddr_in);
755                      info.ai_addr     = (struct sockaddr *)addr;
756                  } else if (ip.version == 6) {
757                      struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&amp;storage;
758                      dns_pton(AF_INET6, host, &amp;(addr-&gt;sin6_addr));
759                      addr-&gt;sin6_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
760                      addr-&gt;sin6_family = AF_INET6;
761                      info.ai_family    = AF_INET6;
762                      info.ai_addrlen   = sizeof(struct sockaddr_in6);
763                      info.ai_addr      = (struct sockaddr *)addr;
764                  }
765              } else {
766                  if (!validate_hostname(host, name_len)) {
767                      LOGE(&quot;invalid host name&quot;);
768                      report_addr(server-&gt;fd, MALFORMED);
769                      close_and_free_server(EV_A_ server);
770                      return;
771                  }
772                  need_query = 1;
773              }
774          } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
775              struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&amp;storage;
776              size_t in6_addr_len       = sizeof(struct in6_addr);
777              addr-&gt;sin6_family = AF_INET6;
778              if (server-&gt;buf-&gt;len &gt;= in6_addr_len + 3) {
779                  addr-&gt;sin6_addr = *(struct in6_addr *)(server-&gt;buf-&gt;array + offset);
780                  dns_ntop(AF_INET6, (const void *)(server-&gt;buf-&gt;array + offset),
781                           host, INET6_ADDRSTRLEN);
782                  offset += in6_addr_len;
783              } else {
784                  LOGE(&quot;invalid header with addr type %d&quot;, atyp);
785                  report_addr(server-&gt;fd, MALFORMED);
786                  close_and_free_server(EV_A_ server);
787                  return;
788              }
789              addr-&gt;sin6_port  = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
790              info.ai_family   = AF_INET6;
791              info.ai_socktype = SOCK_STREAM;
792              info.ai_protocol = IPPROTO_TCP;
793              info.ai_addrlen  = sizeof(struct sockaddr_in6);
794              info.ai_addr     = (struct sockaddr *)addr;
795          }
796          if (offset == 1) {
797              LOGE(&quot;invalid header with addr type %d&quot;, atyp);
798              report_addr(server-&gt;fd, MALFORMED);
799              close_and_free_server(EV_A_ server);
800              return;
801          }
802          port = (*(uint16_t *)(server-&gt;buf-&gt;array + offset));
803          offset += 2;
804          if (server-&gt;auth) {
805              offset += ONETIMEAUTH_BYTES;
806          }
807          if (server-&gt;buf-&gt;len &lt; offset) {
808              report_addr(server-&gt;fd, MALFORMED);
809              close_and_free_server(EV_A_ server);
810              return;
811          } else {
812              server-&gt;buf-&gt;len -= offset;
813              memmove(server-&gt;buf-&gt;array, server-&gt;buf-&gt;array + offset, server-&gt;buf-&gt;len);
814          }
815          if (verbose) {
816              if ((atyp &amp; ADDRTYPE_MASK) == 4)
817                  LOGI(&quot;connect to [%s]:%d&quot;, host, ntohs(port));
818              else
819                  LOGI(&quot;connect to %s:%d&quot;, host, ntohs(port));
820          }
821          if (server-&gt;auth &amp;&amp; !ss_check_hash(server-&gt;buf, server-&gt;chunk, server-&gt;d_ctx, BUF_SIZE)) {
822              LOGE(&quot;hash error&quot;);
823              report_addr(server-&gt;fd, BAD);
824              close_and_free_server(EV_A_ server);
825              return;
826          }
827          if (!need_query) {
828              remote_t *remote = connect_to_remote(EV_A_ &amp;info, server);
829              if (remote == NULL) {
830                  LOGE(&quot;connect error&quot;);
831                  close_and_free_server(EV_A_ server);
832                  return;
833              } else {
834                  server-&gt;remote = remote;
835                  remote-&gt;server = server;
836                  if (server-&gt;buf-&gt;len &gt; 0) {
837                      memcpy(remote-&gt;buf-&gt;array, server-&gt;buf-&gt;array, server-&gt;buf-&gt;len);
838                      remote-&gt;buf-&gt;len = server-&gt;buf-&gt;len;
839                      remote-&gt;buf-&gt;idx = 0;
840                      server-&gt;buf-&gt;len = 0;
841                      server-&gt;buf-&gt;idx = 0;
842                  }
843                  ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
844                  ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
845              }
846          } else {
847              query_t *query = (query_t *)ss_malloc(sizeof(query_t));
848              query-&gt;server = server;
849              snprintf(query-&gt;hostname, 256, &quot;%s&quot;, host);
850              server-&gt;stage = STAGE_RESOLVE;
851              server-&gt;query = resolv_query(host, server_resolve_cb,
852                                           query_free_cb, query, port);
853              ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
854          }
855          return;
856      }
857      FATAL(&quot;server context error&quot;);
858  }
859  static void
860  server_send_cb(EV_P_ ev_io *w, int revents)
861  {
862      server_ctx_t *server_send_ctx = (server_ctx_t *)w;
863      server_t *server              = server_send_ctx-&gt;server;
864      remote_t *remote              = server-&gt;remote;
865      if (remote == NULL) {
866          LOGE(&quot;invalid server&quot;);
867          close_and_free_server(EV_A_ server);
868          return;
869      }
870      if (server-&gt;buf-&gt;len == 0) {
871          if (verbose) {
872              LOGI(&quot;server_send close the connection&quot;);
873          }
874          close_and_free_remote(EV_A_ remote);
875          close_and_free_server(EV_A_ server);
876          return;
877      } else {
878          ssize_t s = send(server-&gt;fd, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
879                           server-&gt;buf-&gt;len, 0);
880          if (s == -1) {
881              if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) {
882                  ERROR(&quot;server_send_send&quot;);
883                  close_and_free_remote(EV_A_ remote);
884                  close_and_free_server(EV_A_ server);
885              }
886              return;
887          } else if (s &lt; server-&gt;buf-&gt;len) {
888              server-&gt;buf-&gt;len -= s;
889              server-&gt;buf-&gt;idx += s;
890              return;
891          } else {
892              server-&gt;buf-&gt;len = 0;
893              server-&gt;buf-&gt;idx = 0;
894              ev_io_stop(EV_A_ &amp; server_send_ctx-&gt;io);
895              if (remote != NULL) {
896                  ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
897                  return;
898              } else {
899                  LOGE(&quot;invalid remote&quot;);
900                  close_and_free_remote(EV_A_ remote);
901                  close_and_free_server(EV_A_ server);
902                  return;
903              }
904          }
905      }
906  }
907  static void
908  block_list_clear_cb(EV_P_ ev_timer *watcher, int revents)
909  {
910      clear_block_list();
911  }
912  static void
913  server_timeout_cb(EV_P_ ev_timer *watcher, int revents)
914  {
915      server_ctx_t *server_ctx
916          = cork_container_of(watcher, server_ctx_t, watcher);
917      server_t *server = server_ctx-&gt;server;
918      remote_t *remote = server-&gt;remote;
919      if (verbose) {
920          LOGI(&quot;TCP connection timeout&quot;);
921      }
922      if (server-&gt;stage &lt; STAGE_PARSE) {
923          if (verbose) {
924              size_t len = server-&gt;stage ?
925                           server-&gt;header_buf-&gt;len : server-&gt;buf-&gt;len;
926  #ifdef __MINGW32__
927              LOGI(&quot;incomplete header: %u&quot;, len);
928  #else
929              LOGI(&quot;incomplete header: %zu&quot;, len);
930  #endif
931          }
932          report_addr(server-&gt;fd, SUSPICIOUS);
933      }
934      close_and_free_remote(EV_A_ remote);
935      close_and_free_server(EV_A_ server);
936  }
937  static void
938  query_free_cb(void *data)
939  {
940      if (data != NULL) {
941          ss_free(data);
942      }
943  }
944  static void
945  server_resolve_cb(struct sockaddr *addr, void *data)
946  {
947      query_t *query       = (query_t *)data;
948      server_t *server     = query-&gt;server;
949      struct ev_loop *loop = server-&gt;listen_ctx-&gt;loop;
950      server-&gt;query = NULL;
951      if (addr == NULL) {
952          LOGE(&quot;unable to resolve %s&quot;, query-&gt;hostname);
953          close_and_free_server(EV_A_ server);
954      } else {
955          if (verbose) {
956              LOGI(&quot;successfully resolved %s&quot;, query-&gt;hostname);
957          }
958          struct addrinfo info;
959          memset(&amp;info, 0, sizeof(struct addrinfo));
960          info.ai_socktype = SOCK_STREAM;
961          info.ai_protocol = IPPROTO_TCP;
962          info.ai_addr     = addr;
963          if (addr-&gt;sa_family == AF_INET) {
964              info.ai_family  = AF_INET;
965              info.ai_addrlen = sizeof(struct sockaddr_in);
966          } else if (addr-&gt;sa_family == AF_INET6) {
967              info.ai_family  = AF_INET6;
968              info.ai_addrlen = sizeof(struct sockaddr_in6);
969          }
970          remote_t *remote = connect_to_remote(EV_A_ &amp;info, server);
971          if (remote == NULL) {
972              close_and_free_server(EV_A_ server);
973          } else {
974              server-&gt;remote = remote;
975              remote-&gt;server = server;
976              if (server-&gt;buf-&gt;len &gt; 0) {
977                  memcpy(remote-&gt;buf-&gt;array, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
978                         server-&gt;buf-&gt;len);
979                  remote-&gt;buf-&gt;len = server-&gt;buf-&gt;len;
980                  remote-&gt;buf-&gt;idx = 0;
981                  server-&gt;buf-&gt;len = 0;
982                  server-&gt;buf-&gt;idx = 0;
983              }
984              ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
985          }
986      }
987  }
988  static void
989  remote_recv_cb(EV_P_ ev_io *w, int revents)
990  {
991      remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
992      remote_t *remote              = remote_recv_ctx-&gt;remote;
993      server_t *server              = remote-&gt;server;
994      if (server == NULL) {
995          LOGE(&quot;invalid server&quot;);
996          close_and_free_remote(EV_A_ remote);
997          return;
998      }
999      ev_timer_again(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1000      ssize_t r = recv(remote-&gt;fd, server-&gt;buf-&gt;array, BUF_SIZE, 0);
1001      if (r == 0) {
1002          if (verbose) {
1003              LOGI(&quot;remote_recv close the connection&quot;);
1004          }
1005          close_and_free_remote(EV_A_ remote);
1006          close_and_free_server(EV_A_ server);
1007          return;
1008      } else if (r == -1) {
1009          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1010              return;
1011          } else {
1012              ERROR(&quot;remote recv&quot;);
1013              close_and_free_remote(EV_A_ remote);
1014              close_and_free_server(EV_A_ server);
1015              return;
1016          }
1017      }
1018      rx += r;
1019      server-&gt;buf-&gt;len = r;
1020      server_info _server_info;
1021      if (server-&gt;obfs_plugin) {
1022          server-&gt;obfs_plugin-&gt;get_server_info(server-&gt;obfs, &amp;_server_info);
1023          _server_info.head_len = get_head_size(server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, 30);
1024          server-&gt;obfs_plugin-&gt;set_server_info(server-&gt;obfs, &amp;_server_info);
1025      }
1026      if (server-&gt;protocol_plugin &amp;&amp; server-&gt;obfs_compatible_state == 0) {
1027          obfs_class *protocol_plugin = server-&gt;protocol_plugin;
1028          if (protocol_plugin-&gt;server_pre_encrypt) {
1029              server-&gt;buf-&gt;len = protocol_plugin-&gt;server_pre_encrypt(server-&gt;protocol, &amp;server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, &amp;server-&gt;buf-&gt;capacity);
1030          }
1031      }
1032      int err = ss_encrypt(server-&gt;buf, server-&gt;e_ctx, BUF_SIZE);
1033      if (err) {
1034          LOGE(&quot;invalid password or cipher&quot;);
1035          close_and_free_remote(EV_A_ remote);
1036          close_and_free_server(EV_A_ server);
1037          return;
1038      }
1039      if (server-&gt;obfs_plugin &amp;&amp; server-&gt;obfs_compatible_state == 0) {
1040          obfs_class *obfs_plugin = server-&gt;obfs_plugin;
1041          if (obfs_plugin-&gt;server_encode) {
1042              server-&gt;buf-&gt;len = obfs_plugin-&gt;server_encode(server-&gt;obfs, &amp;server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, &amp;server-&gt;buf-&gt;capacity);
1043          }
1044      }
1045      int s = send(server-&gt;fd, server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, 0);
1046      if (s == -1) {
1047          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1048              server-&gt;buf-&gt;idx = 0;
1049              ev_io_stop(EV_A_ &amp; remote_recv_ctx-&gt;io);
1050              ev_io_start(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1051          } else {
1052              ERROR(&quot;remote_recv_send&quot;);
1053              close_and_free_remote(EV_A_ remote);
1054              close_and_free_server(EV_A_ server);
1055              return;
1056          }
1057      } else if (s &lt; server-&gt;buf-&gt;len) {
1058          server-&gt;buf-&gt;len -= s;
1059          server-&gt;buf-&gt;idx  = s;
1060          ev_io_stop(EV_A_ &amp; remote_recv_ctx-&gt;io);
1061          ev_io_start(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1062      }
1063      if (!remote-&gt;recv_ctx-&gt;connected) {
1064          int opt = 0;
1065          setsockopt(server-&gt;fd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1066          setsockopt(remote-&gt;fd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1067          remote-&gt;recv_ctx-&gt;connected = 1;
1068      }
1069  }
1070  static void
1071  remote_send_cb(EV_P_ ev_io *w, int revents)
1072  {
1073      remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
1074      remote_t *remote              = remote_send_ctx-&gt;remote;
1075      server_t *server              = remote-&gt;server;
1076      if (server == NULL) {
1077          LOGE(&quot;invalid server&quot;);
1078          close_and_free_remote(EV_A_ remote);
1079          return;
1080      }
1081      if (!remote_send_ctx-&gt;connected) {
1082          struct sockaddr_storage addr;
1083          socklen_t len = sizeof(struct sockaddr_storage);
1084          memset(&amp;addr, 0, len);
1085          int r = getpeername(remote-&gt;fd, (struct sockaddr *)&amp;addr, &amp;len);
1086          if (r == 0) {
1087              if (verbose) {
1088                  LOGI(&quot;remote connected&quot;);
1089              }
1090              remote_send_ctx-&gt;connected = 1;
1091              reset_addr(server-&gt;fd);
1092              if (remote-&gt;buf-&gt;len == 0) {
1093                  server-&gt;stage = STAGE_STREAM;
1094                  ev_io_stop(EV_A_ &amp; remote_send_ctx-&gt;io);
1095                  ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1096                  ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1097                  return;
1098              }
1099          } else {
1100              ERROR(&quot;getpeername&quot;);
1101              close_and_free_remote(EV_A_ remote);
1102              close_and_free_server(EV_A_ server);
1103              return;
1104          }
1105      }
1106      if (remote-&gt;buf-&gt;len == 0) {
1107          if (verbose) {
1108              LOGI(&quot;remote_send close the connection&quot;);
1109          }
1110          close_and_free_remote(EV_A_ remote);
1111          close_and_free_server(EV_A_ server);
1112          return;
1113      } else {
1114          ssize_t s = send(remote-&gt;fd, remote-&gt;buf-&gt;array + remote-&gt;buf-&gt;idx,
1115                           remote-&gt;buf-&gt;len, 0);
1116          if (s == -1) {
1117              if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) {
1118                  ERROR(&quot;remote_send_send&quot;);
1119                  close_and_free_remote(EV_A_ remote);
1120                  close_and_free_server(EV_A_ server);
1121              }
1122              return;
1123          } else if (s &lt; remote-&gt;buf-&gt;len) {
1124              remote-&gt;buf-&gt;len -= s;
1125              remote-&gt;buf-&gt;idx += s;
1126              return;
1127          } else {
1128              remote-&gt;buf-&gt;len = 0;
1129              remote-&gt;buf-&gt;idx = 0;
1130              ev_io_stop(EV_A_ &amp; remote_send_ctx-&gt;io);
1131              if (server != NULL) {
1132                  ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1133                  if (server-&gt;stage != STAGE_STREAM) {
1134                      server-&gt;stage = STAGE_STREAM;
1135                      ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1136                  }
1137              } else {
1138                  LOGE(&quot;invalid server&quot;);
1139                  close_and_free_remote(EV_A_ remote);
1140                  close_and_free_server(EV_A_ server);
1141              }
1142              return;
1143          }
1144      }
1145  }
1146  static remote_t *
1147  new_remote(int fd)
1148  {
1149      if (verbose) {
1150          remote_conn++;
1151      }
1152      remote_t *remote;
1153      remote                      = ss_malloc(sizeof(remote_t));
1154      remote-&gt;recv_ctx            = ss_malloc(sizeof(remote_ctx_t));
1155      remote-&gt;send_ctx            = ss_malloc(sizeof(remote_ctx_t));
1156      remote-&gt;buf                 = ss_malloc(sizeof(buffer_t));
1157      remote-&gt;fd                  = fd;
1158      remote-&gt;recv_ctx-&gt;remote    = remote;
1159      remote-&gt;recv_ctx-&gt;connected = 0;
1160      remote-&gt;send_ctx-&gt;remote    = remote;
1161      remote-&gt;send_ctx-&gt;connected = 0;
1162      remote-&gt;server              = NULL;
1163      ev_io_init(&amp;remote-&gt;recv_ctx-&gt;io, remote_recv_cb, fd, EV_READ);
1164      ev_io_init(&amp;remote-&gt;send_ctx-&gt;io, remote_send_cb, fd, EV_WRITE);
1165      balloc(remote-&gt;buf, BUF_SIZE);
1166      return remote;
1167  }
1168  static void
1169  free_remote(remote_t *remote)
1170  {
1171      if (remote-&gt;server != NULL) {
1172          remote-&gt;server-&gt;remote = NULL;
1173      }
1174      if (remote-&gt;buf != NULL) {
1175          bfree(remote-&gt;buf);
1176          ss_free(remote-&gt;buf);
1177      }
1178      ss_free(remote-&gt;recv_ctx);
1179      ss_free(remote-&gt;send_ctx);
1180      ss_free(remote);
1181  }
1182  static void
1183  close_and_free_remote(EV_P_ remote_t *remote)
1184  {
1185      if (remote != NULL) {
1186          ev_io_stop(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
1187          ev_io_stop(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1188          close(remote-&gt;fd);
1189          free_remote(remote);
1190          if (verbose) {
1191              remote_conn--;
1192              LOGI(&quot;current remote connection: %d&quot;, remote_conn);
1193          }
1194      }
1195  }
1196  static server_t *
1197  new_server(int fd, listen_ctx_t *listener)
1198  {
1199      if (verbose) {
1200          server_conn++;
1201      }
1202      server_t *server;
1203      server = ss_malloc(sizeof(server_t));
1204      memset(server, 0, sizeof(server_t));
1205      server-&gt;recv_ctx            = ss_malloc(sizeof(server_ctx_t));
1206      server-&gt;send_ctx            = ss_malloc(sizeof(server_ctx_t));
1207      server-&gt;buf                 = ss_malloc(sizeof(buffer_t));
1208      server-&gt;header_buf          = ss_malloc(sizeof(buffer_t));
1209      server-&gt;fd                  = fd;
1210      server-&gt;recv_ctx-&gt;server    = server;
1211      server-&gt;recv_ctx-&gt;connected = 0;
1212      server-&gt;send_ctx-&gt;server    = server;
1213      server-&gt;send_ctx-&gt;connected = 0;
1214      server-&gt;stage               = STAGE_INIT;
1215      server-&gt;query               = NULL;
1216      server-&gt;listen_ctx          = listener;
1217      server-&gt;remote              = NULL;
1218      if (listener-&gt;method) {
1219          server-&gt;e_ctx = ss_malloc(sizeof(enc_ctx_t));
1220          server-&gt;d_ctx = ss_malloc(sizeof(enc_ctx_t));
1221          enc_ctx_init(listener-&gt;method, server-&gt;e_ctx, 1);
1222          enc_ctx_init(listener-&gt;method, server-&gt;d_ctx, 0);
1223      } else {
1224          server-&gt;e_ctx = NULL;
1225          server-&gt;d_ctx = NULL;
1226      }
1227      int request_timeout = min(MAX_REQUEST_TIMEOUT, listener-&gt;timeout)
1228                            + rand() % MAX_REQUEST_TIMEOUT;
1229      ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);
1230      ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);
1231      ev_timer_init(&amp;server-&gt;recv_ctx-&gt;watcher, server_timeout_cb,
1232                    request_timeout, listener-&gt;timeout);
1233      balloc(server-&gt;buf, BUF_SIZE);
1234      balloc(server-&gt;header_buf, BUF_SIZE);
1235      server-&gt;chunk = (chunk_t *)malloc(sizeof(chunk_t));
1236      memset(server-&gt;chunk, 0, sizeof(chunk_t));
1237      server-&gt;chunk-&gt;buf = ss_malloc(sizeof(buffer_t));
1238      memset(server-&gt;chunk-&gt;buf, 0, sizeof(buffer_t));
1239      cork_dllist_add(&amp;connections, &amp;server-&gt;entries);
1240      return server;
1241  }
1242  static void
1243  free_server(server_t *server)
1244  {
1245      cork_dllist_remove(&amp;server-&gt;entries);
1246      if (server-&gt;chunk != NULL) {
1247          if (server-&gt;chunk-&gt;buf != NULL) {
1248              bfree(server-&gt;chunk-&gt;buf);
1249              ss_free(server-&gt;chunk-&gt;buf);
1250          }
1251          ss_free(server-&gt;chunk);
1252      }
1253      if (server-&gt;remote != NULL) {
1254          server-&gt;remote-&gt;server = NULL;
1255      }
1256      if (server-&gt;e_ctx != NULL) {
1257          cipher_context_release(&amp;server-&gt;e_ctx-&gt;evp);
1258          ss_free(server-&gt;e_ctx);
1259      }
1260      if (server-&gt;d_ctx != NULL) {
1261          cipher_context_release(&amp;server-&gt;d_ctx-&gt;evp);
1262          ss_free(server-&gt;d_ctx);
1263      }
1264      if (server-&gt;buf != NULL) {
1265          bfree(server-&gt;buf);
1266          ss_free(server-&gt;buf);
1267      }
1268      if (server-&gt;header_buf != NULL) {
1269          bfree(server-&gt;header_buf);
1270          ss_free(server-&gt;header_buf);
1271      }
1272      ss_free(server-&gt;recv_ctx);
1273      ss_free(server-&gt;send_ctx);
1274      ss_free(server);
1275  }
1276  static void
1277  close_and_free_server(EV_P_ server_t *server)
1278  {
1279      if (server != NULL) {
1280          if (server-&gt;query != NULL) {
1281              resolv_cancel(server-&gt;query);
1282              server-&gt;query = NULL;
1283          }
1284          ev_io_stop(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1285          ev_io_stop(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1286          ev_timer_stop(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1287          close(server-&gt;fd);
1288          free_server(server);
1289          if (verbose) {
1290              server_conn--;
1291              LOGI(&quot;current server connection: %d&quot;, server_conn);
1292          }
1293      }
1294  }
1295  static void
1296  signal_cb(EV_P_ ev_signal *w, int revents)
1297  {
1298      if (revents &amp; EV_SIGNAL) {
1299          switch (w-&gt;signum) {
1300          case SIGINT:
1301          case SIGTERM:
1302              ev_unloop(EV_A_ EVUNLOOP_ALL);
1303          }
1304      }
1305  }
1306  static void
1307  accept_cb(EV_P_ ev_io *w, int revents)
1308  {
1309      listen_ctx_t *listener = (listen_ctx_t *)w;
1310      int serverfd           = accept(listener-&gt;fd, NULL, NULL);
1311      if (serverfd == -1) {
1312          ERROR(&quot;accept&quot;);
1313          return;
1314      }
1315      char *peer_name = get_peer_name(serverfd);
1316      if (peer_name != NULL) {
1317          int in_white_list = 0;
1318          if (acl) {
1319              if ((get_acl_mode() == BLACK_LIST &amp;&amp; acl_match_host(peer_name) == 1)
1320                  || (get_acl_mode() == WHITE_LIST &amp;&amp; acl_match_host(peer_name) &gt;= 0)) {
1321                  LOGE(&quot;Access denied from %s&quot;, peer_name);
1322                  close(serverfd);
1323                  return;
1324              } else if (acl_match_host(peer_name) == -1) {
1325                  in_white_list = 1;
1326              }
1327          }
1328          if (!in_white_list &amp;&amp; check_block_list(peer_name)) {
1329              LOGE(&quot;block all requests from %s&quot;, peer_name);
1330  #ifdef __linux__
1331              set_linger(serverfd);
1332  #endif
1333              close(serverfd);
1334              return;
1335          }
1336      }
1337      int opt = 1;
1338      setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1339  #ifdef SO_NOSIGPIPE
1340      setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
1341  #endif
1342      setnonblocking(serverfd);
1343      if (verbose) {
1344          LOGI(&quot;accept a connection&quot;);
1345      }
1346      server_t *server = new_server(serverfd, listener);
1347      server-&gt;obfs_plugin = new_obfs_class(server-&gt;listen_ctx-&gt;obfs_name);
1348      if (server-&gt;obfs_plugin) {
1349          server-&gt;obfs = server-&gt;obfs_plugin-&gt;new_obfs();
1350          server-&gt;obfs_compatible_state = 0;
1351      }
1352      server-&gt;protocol_plugin = new_obfs_class(server-&gt;listen_ctx-&gt;protocol_name);
1353      if (server-&gt;protocol_plugin) {
1354          server-&gt;protocol = server-&gt;protocol_plugin-&gt;new_obfs();
1355          server-&gt;protocol_compatible_state = 0;
1356      }
1357      server_info _server_info;
1358      memset(&amp;_server_info, 0, sizeof(server_info));
1359      _server_info.param = server-&gt;listen_ctx-&gt;obfs_param;
1360      if(server-&gt;obfs_plugin)
1361          _server_info.g_data = server-&gt;obfs_plugin-&gt;init_data();
1362      _server_info.head_len = 7;
1363      _server_info.iv = server-&gt;e_ctx-&gt;evp.iv;
1364      _server_info.iv_len = enc_get_iv_len();
1365      _server_info.key = enc_get_key();
1366      _server_info.key_len = enc_get_key_len();
1367      _server_info.tcp_mss = 1460;
1368      if (server-&gt;obfs_plugin)
1369          server-&gt;obfs_plugin-&gt;set_server_info(server-&gt;obfs, &amp;_server_info);
1370      _server_info.param = server-&gt;listen_ctx-&gt;protocol_param;
1371      if (server-&gt;protocol_plugin)
1372          _server_info.g_data = server-&gt;protocol_plugin-&gt;init_data();
1373      if (server-&gt;protocol_plugin)
1374          server-&gt;protocol_plugin-&gt;set_server_info(server-&gt;protocol, &amp;_server_info);
1375      ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1376      ev_timer_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1377  }
1378  int
1379  main(int argc, char **argv)
1380  {
1381      int i, c;
1382      int pid_flags   = 0;
1383      int mptcp       = 0;
1384      int firewall    = 0;
1385      int mtu         = 0;
1386      char *user      = NULL;
1387      char *password  = NULL;
1388      char *timeout   = NULL;
1389      char *protocol = NULL; 
1390      char *protocol_param = NULL; 
1391      char *method = NULL;
1392      char *obfs = NULL; 
1393      char *obfs_param = NULL; 
1394      char *pid_path  = NULL;
1395      char *conf_path = NULL;
1396      char *iface     = NULL;
1397      int server_num = 0;
1398      const char *server_host[MAX_REMOTE_NUM];
1399      char *nameservers[MAX_DNS_NUM + 1];
1400      int nameserver_num = 0;
1401      int option_index                    = 0;
1402      static struct option long_options[] = {
1403          { &quot;fast-open&quot;,       no_argument,       0, 0 },
1404          { &quot;acl&quot;,             required_argument, 0, 0 },
1405          { &quot;manager-address&quot;, required_argument, 0, 0 },
1406          { &quot;mtu&quot;,             required_argument, 0, 0 },
1407          { &quot;help&quot;,            no_argument,       0, 0 },
1408  #ifdef __linux__
1409          { &quot;mptcp&quot;,           no_argument,       0, 0 },
1410          { &quot;firewall&quot;,        no_argument,       0, 0 },
1411  #endif
1412          {                 0,                 0, 0, 0 }
1413      };
1414      opterr = 0;
1415      USE_TTY();
1416      while ((c = getopt_long(argc, argv, &quot;f:s:p:l:k:t:m:b:c:i:d:a:n:O:o:G:g:huUvA6&quot;,
1417                              long_options, &amp;option_index)) != -1) {
1418          switch (c) {
1419          case 0:
1420              if (option_index == 0) {
1421                  fast_open = 1;
1422              } else if (option_index == 1) {
1423                  LOGI(&quot;initializing acl...&quot;);
1424                  acl = !init_acl(optarg);
1425              } else if (option_index == 2) {
1426                  manager_address = optarg;
1427              } else if (option_index == 3) {
1428                  mtu = atoi(optarg);
1429                  LOGI(&quot;set MTU to %d&quot;, mtu);
1430              } else if (option_index == 4) {
1431                  usage();
1432                  exit(EXIT_SUCCESS);
1433              } else if (option_index == 5) {
1434                  mptcp = 1;
1435                  LOGI(&quot;enable multipath TCP&quot;);
1436              } else if (option_index == 6) {
1437                  firewall = 1;
1438                  LOGI(&quot;enable firewall rules&quot;);
1439              }
1440              break;
1441          case &#x27;s&#x27;:
1442              if (server_num &lt; MAX_REMOTE_NUM) {
1443                  server_host[server_num++] = optarg;
1444              }
1445              break;
1446          case &#x27;b&#x27;:
1447              bind_address = optarg;
1448              break;
1449          case &#x27;p&#x27;:
1450              server_port = optarg;
1451              break;
1452          case &#x27;k&#x27;:
1453              password = optarg;
1454              break;
1455          case &#x27;f&#x27;:
1456              pid_flags = 1;
1457              pid_path  = optarg;
1458              break;
1459          case &#x27;t&#x27;:
1460              timeout = optarg;
1461              break;
1462          case &#x27;O&#x27;:
1463              protocol = optarg;
1464              break;
1465          case &#x27;m&#x27;:
1466              method = optarg;
1467              break;
1468          case &#x27;o&#x27;:
1469              obfs = optarg;
1470              break;
1471          case &#x27;G&#x27;:
1472              protocol_param = optarg;
1473              break;
1474          case &#x27;g&#x27;:
1475              obfs_param = optarg;
1476              break;
1477          case &#x27;c&#x27;:
1478              conf_path = optarg;
1479              break;
1480          case &#x27;i&#x27;:
1481              iface = optarg;
1482              break;
1483          case &#x27;d&#x27;:
1484              if (nameserver_num &lt; MAX_DNS_NUM) {
1485                  nameservers[nameserver_num++] = optarg;
1486              }
1487              break;
1488          case &#x27;a&#x27;:
1489              user = optarg;
1490              break;
1491  #ifdef HAVE_SETRLIMIT
1492          case &#x27;n&#x27;:
1493              nofile = atoi(optarg);
1494              break;
1495  #endif
1496          case &#x27;u&#x27;:
1497              mode = TCP_AND_UDP;
1498              break;
1499          case &#x27;U&#x27;:
1500              mode = UDP_ONLY;
1501              break;
1502          case &#x27;v&#x27;:
1503              verbose = 1;
1504              break;
1505          case &#x27;h&#x27;:
1506              usage();
1507              exit(EXIT_SUCCESS);
1508          case &#x27;A&#x27;:
1509              auth = 1;
1510              break;
1511          case &#x27;6&#x27;:
1512              ipv6first = 1;
1513              break;
1514          case &#x27;?&#x27;:
1515              LOGE(&quot;Unrecognized option: %s&quot;, optarg);
1516              opterr = 1;
1517              break;
1518          }
1519      }
1520      if (opterr) {
1521          usage();
1522          exit(EXIT_FAILURE);
1523      }
1524      if (argc == 1) {
1525          if (conf_path == NULL) {
1526              conf_path = DEFAULT_CONF_PATH;
1527          }
1528      }
1529      if (conf_path != NULL) {
1530          jconf_t *conf = read_jconf(conf_path);
1531          if (server_num == 0) {
1532              server_num = conf-&gt;remote_num;
1533              for (i = 0; i &lt; server_num; i++)
1534                  server_host[i] = conf-&gt;remote_addr[i].host;
1535          }
1536          if (server_port == NULL) {
1537              server_port = conf-&gt;remote_port;
1538          }
1539          if (password == NULL) {
1540              password = conf-&gt;password;
1541          }
1542          if (protocol == NULL) {
1543              protocol = conf-&gt;protocol;
1544              LOGI(&quot;protocol %s&quot;, protocol);
1545          }
1546          if (protocol_param == NULL) {
1547              protocol_param = conf-&gt;protocol_param;
1548              LOGI(&quot;protocol_param %s&quot;, obfs_param);
1549          }
1550          if (method == NULL) {
1551              method = conf-&gt;method;
1552              LOGI(&quot;method %s&quot;, method);
1553          }
1554          if (obfs == NULL) {
1555              obfs = conf-&gt;obfs;
1556              LOGI(&quot;obfs %s&quot;, obfs);
1557          }
1558          if (obfs_param == NULL) {
1559              obfs_param = conf-&gt;obfs_param;
1560              LOGI(&quot;obfs_param %s&quot;, obfs_param);
1561          }
1562          if (timeout == NULL) {
1563              timeout = conf-&gt;timeout;
1564          }
1565          if (user == NULL) {
1566              user = conf-&gt;user;
1567          }
1568          if (auth == 0) {
1569              auth = conf-&gt;auth;
1570          }
1571          if (mode == TCP_ONLY) {
1572              mode = conf-&gt;mode;
1573          }
1574          if (mtu == 0) {
1575              mtu = conf-&gt;mtu;
1576          }
1577          if (mptcp == 0) {
1578              mptcp = conf-&gt;mptcp;
1579          }
1580  #ifdef TCP_FASTOPEN
1581          if (fast_open == 0) {
1582              fast_open = conf-&gt;fast_open;
1583          }
1584  #endif
1585  #ifdef HAVE_SETRLIMIT
1586          if (nofile == 0) {
1587              nofile = conf-&gt;nofile;
1588          }
1589  #endif
1590          if (conf-&gt;nameserver != NULL) {
1591              nameservers[nameserver_num++] = conf-&gt;nameserver;
1592          }
1593          if (ipv6first == 0) {
1594              ipv6first = conf-&gt;ipv6_first;
1595          }
1596      }
1597      if(strlen(protocol)&gt;11)
1598      {
1599          char *text;
1600          text = (char*)malloc(12);
1601          memcpy(text, protocol + strlen(protocol) - 11, 12);
1602          if(strcmp(text, &quot;_compatible&quot;) == 0)
1603          {
1604              free(text);
1605              text = (char*)malloc(strlen(protocol) - 11);
1606              memcpy(text, protocol, strlen(protocol) - 11);
1607              int length = strlen(protocol) - 11;
1608              free(protocol);
1609              obfs = (char*)malloc(length);
1610              memset(protocol, 0x00, length);
1611              memcpy(protocol, text, length);
1612              LOGI(&quot;protocol compatible enable, %s&quot;, protocol);
1613              free(text);
1614              protocol_compatible = 1;
1615          }
1616      }
1617      if(strlen(obfs)&gt;11)
1618      {
1619          char *text;
1620          text = (char*)malloc(12);
1621          memcpy(text, obfs + strlen(obfs) - 11, 12);
1622          if(strcmp(text, &quot;_compatible&quot;) == 0)
1623          {
1624              free(text);
1625              text = (char*)malloc(strlen(obfs) - 11);
1626              memcpy(text, obfs, strlen(obfs) - 11);
1627              int length = strlen(obfs) - 11;
1628              free(obfs);
1629              obfs = (char*)malloc(length);
1630              memset(obfs, 0x00, length);
1631              memcpy(obfs, text, length);
1632              LOGI(&quot;obfs compatible enable, %s&quot;, obfs);
1633              free(text);
1634              obfs_compatible = 1;
1635          }
1636      }
1637      if (server_num == 0) {
1638          server_host[server_num++] = NULL;
1639      }
1640      if (server_num == 0 || server_port == NULL || password == NULL) {
1641          usage();
1642          exit(EXIT_FAILURE);
1643      }
1644      if (protocol &amp;&amp; strcmp(protocol, &quot;verify_sha1&quot;) == 0) {
1645          auth = 1;
1646          protocol = NULL;
1647      }
1648      if (method == NULL) {
1649          method = &quot;rc4-md5&quot;;
1650      }
1651      if (timeout == NULL) {
1652          timeout = &quot;60&quot;;
1653      }
1654  #ifdef HAVE_SETRLIMIT
1655      if (nofile &gt; 1024) {
1656          if (verbose) {
1657              LOGI(&quot;setting NOFILE to %d&quot;, nofile);
1658          }
1659          set_nofile(nofile);
1660      }
1661  #endif
1662      if (pid_flags) {
1663          USE_SYSLOG(argv[0]);
1664          daemonize(pid_path);
1665      }
1666      if (ipv6first) {
1667          LOGI(&quot;resolving hostname to IPv6 address first&quot;);
1668      }
1669      if (fast_open == 1) {
1670  #ifdef TCP_FASTOPEN
1671          LOGI(&quot;using tcp fast open&quot;);
1672  #else
1673          LOGE(&quot;tcp fast open is not supported by this environment&quot;);
1674          fast_open = 0;
1675  #endif
1676      }
1677      if (auth) {
1678          LOGI(&quot;onetime authentication enabled&quot;);
1679      }
1680      if (mode != TCP_ONLY) {
1681          LOGI(&quot;UDP relay enabled&quot;);
1682      }
1683      if (mode == UDP_ONLY) {
1684          LOGI(&quot;TCP relay disabled&quot;);
1685      }
1686  #ifdef __MINGW32__
1687      winsock_init();
1688  #else
1689      signal(SIGPIPE, SIG_IGN);
1690      signal(SIGCHLD, SIG_IGN);
1691      signal(SIGABRT, SIG_IGN);
1692  #endif
1693      struct ev_signal sigint_watcher;
1694      struct ev_signal sigterm_watcher;
1695      ev_signal_init(&amp;sigint_watcher, signal_cb, SIGINT);
1696      ev_signal_init(&amp;sigterm_watcher, signal_cb, SIGTERM);
1697      ev_signal_start(EV_DEFAULT, &amp;sigint_watcher);
1698      ev_signal_start(EV_DEFAULT, &amp;sigterm_watcher);
1699      LOGI(&quot;initializing ciphers... %s&quot;, method);
1700      int m = enc_init(password, method);
1701      struct ev_loop *loop = EV_DEFAULT;
1702      if (nameserver_num == 0) {
1703  #ifdef __MINGW32__
1704          nameservers[nameserver_num++] = &quot;8.8.8.8&quot;;
1705          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1706  #else
1707          resolv_init(loop, NULL, 0, ipv6first);
1708  #endif
1709      } else {
1710          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1711      }
1712      for (int i = 0; i &lt; nameserver_num; i++)
1713          LOGI(&quot;using nameserver: %s&quot;, nameservers[i]);
1714      listen_ctx_t listen_ctx_list[server_num];
1715      while (server_num &gt; 0) {
1716          int index        = --server_num;
1717          const char *host = server_host[index];
1718          if (mode != UDP_ONLY) {
1719              int listenfd;
1720              listenfd = create_and_bind(host, server_port, mptcp);
1721              if (listenfd == -1) {
1722                  FATAL(&quot;bind() error&quot;);
1723              }
1724              if (listen(listenfd, SSMAXCONN) == -1) {
1725                  FATAL(&quot;listen() error&quot;);
1726              }
1727              setfastopen(listenfd);
1728              setnonblocking(listenfd);
1729              listen_ctx_t *listen_ctx = &amp;listen_ctx_list[index];
1730              listen_ctx-&gt;timeout = atoi(timeout);
1731              listen_ctx-&gt;fd      = listenfd;
1732              listen_ctx-&gt;method  = m;
1733              listen_ctx-&gt;iface   = iface;
1734              listen_ctx-&gt;protocol_name = protocol;
1735              listen_ctx-&gt;protocol_param = protocol_param;
1736              listen_ctx-&gt;method = m;
1737              listen_ctx-&gt;obfs_name = obfs;
1738              listen_ctx-&gt;obfs_param = obfs_param;
1739              listen_ctx-&gt;list_protocol_global = malloc(sizeof(void *));
1740              listen_ctx-&gt;list_obfs_global = malloc(sizeof(void *));
1741              memset(listen_ctx-&gt;list_protocol_global, 0, sizeof(void *));
1742              memset(listen_ctx-&gt;list_obfs_global, 0, sizeof(void *));
1743              listen_ctx-&gt;loop    = loop;
1744              ev_io_init(&amp;listen_ctx-&gt;io, accept_cb, listenfd, EV_READ);
1745              ev_io_start(loop, &amp;listen_ctx-&gt;io);
1746          }
1747          if (mode != TCP_ONLY) {
1748              init_udprelay(server_host[index], server_port, mtu, m,
1749                            auth, atoi(timeout), iface, protocol, protocol_param);
1750          }
1751          if (host &amp;&amp; strcmp(host, &quot;:&quot;) &gt; 0)
1752              LOGI(&quot;listening at [%s]:%s&quot;, host, server_port);
1753          else
1754              LOGI(&quot;listening at %s:%s&quot;, host ? host : &quot;*&quot;, server_port);
1755      }
1756      if (manager_address != NULL) {
1757          ev_timer_init(&amp;stat_update_watcher, stat_update_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1758          ev_timer_start(EV_DEFAULT, &amp;stat_update_watcher);
1759      }
1760      ev_timer_init(&amp;block_list_watcher, block_list_clear_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1761      ev_timer_start(EV_DEFAULT, &amp;block_list_watcher);
1762      if (user != NULL &amp;&amp; ! run_as(user)) {
1763          FATAL(&quot;failed to switch user&quot;);
1764      }
1765  #ifndef __MINGW32__
1766      if (geteuid() == 0){
1767          LOGI(&quot;running from root user&quot;);
1768      } else if (firewall) {
1769          LOGE(&quot;firewall setup requires running from root user&quot;);
1770          exit(-1);
1771      }
1772  #endif
1773      init_block_list(firewall);
1774      cork_dllist_init(&amp;connections);
1775      ev_run(loop, 0);
1776      if (verbose) {
1777          LOGI(&quot;closed gracefully&quot;);
1778      }
1779      free_block_list();
1780      if (manager_address != NULL) {
1781          ev_timer_stop(EV_DEFAULT, &amp;stat_update_watcher);
1782      }
1783      ev_timer_stop(EV_DEFAULT, &amp;block_list_watcher);
1784      for (int i = 0; i &lt;= server_num; i++) {
1785          listen_ctx_t *listen_ctx = &amp;listen_ctx_list[i];
1786          if (mode != UDP_ONLY) {
1787              ev_io_stop(loop, &amp;listen_ctx-&gt;io);
1788              close(listen_ctx-&gt;fd);
1789          }
1790      }
1791      if (mode != UDP_ONLY) {
1792          free_connections(loop);
1793      }
1794      if (mode != TCP_ONLY) {
1795          free_udprelay();
1796      }
1797      resolv_shutdown(loop);
1798  #ifdef __MINGW32__
1799      winsock_cleanup();
1800  #endif
1801      ev_signal_stop(EV_DEFAULT, &amp;sigint_watcher);
1802      ev_signal_stop(EV_DEFAULT, &amp;sigterm_watcher);
1803      return 0;
1804  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &quot;config.h&quot;
3  #endif
4  #include &lt;sys/stat.h&gt;
5  #include &lt;sys/types.h&gt;
6  #include &lt;fcntl.h&gt;
7  #include &lt;locale.h&gt;
8  #include &lt;signal.h&gt;
9  #include &lt;string.h&gt;
10  #include &lt;strings.h&gt;
11  #include &lt;time.h&gt;
12  #include &lt;unistd.h&gt;
13  #include &lt;getopt.h&gt;
14  #include &lt;math.h&gt;
15  #ifndef __MINGW32__
16  #include &lt;netdb.h&gt;
17  #include &lt;errno.h&gt;
18  #include &lt;arpa/inet.h&gt;
19  #include &lt;netinet/in.h&gt;
20  #include &lt;pthread.h&gt;
21  #include &lt;sys/un.h&gt;
22  #endif
23  #include &lt;libcork/core.h&gt;
24  #include &lt;udns.h&gt;
25  #ifdef __MINGW32__
26  #include &quot;win32.h&quot;
27  #endif
28  #if defined(HAVE_SYS_IOCTL_H) &amp;&amp; defined(HAVE_NET_IF_H) &amp;&amp; defined(__linux__)
29  #include &lt;net/if.h&gt;
30  #include &lt;sys/ioctl.h&gt;
31  #define SET_INTERFACE
32  #endif
33  #include &quot;netutils.h&quot;
34  #include &quot;utils.h&quot;
35  #include &quot;acl.h&quot;
36  #include &quot;server.h&quot;
37  #include &quot;obfs.c&quot; 
38  #ifndef EAGAIN
39  #define EAGAIN EWOULDBLOCK
40  #endif
41  #ifndef EWOULDBLOCK
42  #define EWOULDBLOCK EAGAIN
43  #endif
44  #ifndef BUF_SIZE
45  #define BUF_SIZE 2048
46  #endif
47  #ifndef SSMAXCONN
48  #define SSMAXCONN 1024
49  #endif
50  #ifndef UPDATE_INTERVAL
51  #define UPDATE_INTERVAL 30
52  #endif
53  static void signal_cb(EV_P_ ev_signal *w, int revents);
54  static void accept_cb(EV_P_ ev_io *w, int revents);
55  static void server_send_cb(EV_P_ ev_io *w, int revents);
56  static void server_recv_cb(EV_P_ ev_io *w, int revents);
57  static void remote_recv_cb(EV_P_ ev_io *w, int revents);
58  static void remote_send_cb(EV_P_ ev_io *w, int revents);
59  static void server_timeout_cb(EV_P_ ev_timer *watcher, int revents);
60  static void block_list_clear_cb(EV_P_ ev_timer *watcher, int revents);
61  static remote_t *new_remote(int fd);
62  static server_t *new_server(int fd, listen_ctx_t *listener);
63  static remote_t *connect_to_remote(EV_P_ struct addrinfo *res,
64                                     server_t *server);
65  static void free_remote(remote_t *remote);
66  static void close_and_free_remote(EV_P_ remote_t *remote);
67  static void free_server(server_t *server);
68  static void close_and_free_server(EV_P_ server_t *server);
69  static void server_resolve_cb(struct sockaddr *addr, void *data);
70  static void query_free_cb(void *data);
71  static size_t parse_header_len(const char atyp, const char *data, size_t offset);
72  static int is_header_complete(const buffer_t *buf);
73  int verbose = 0;
74  static int acl       = 0;
75  static int mode      = TCP_ONLY;
76  static int auth      = 0;
77  static int ipv6first = 0;
78  static int protocol_compatible = 0;
79  static int obfs_compatible = 0;
80  static int fast_open = 0;
81  #ifdef HAVE_SETRLIMIT
82  static int nofile = 0;
83  #endif
84  static int remote_conn = 0;
85  static int server_conn = 0;
86  static char *bind_address    = NULL;
87  static char *server_port     = NULL;
88  static char *manager_address = NULL;
89  uint64_t tx                  = 0;
90  uint64_t rx                  = 0;
91  ev_timer stat_update_watcher;
92  ev_timer block_list_watcher;
93  static struct cork_dllist connections;
94  static void
95  stat_update_cb(EV_P_ ev_timer *watcher, int revents)
96  {
97      struct sockaddr_un svaddr, claddr;
98      int sfd = -1;
99      size_t msgLen;
100      char resp[BUF_SIZE];
101      if (verbose) {
102          LOGI(&quot;update traffic stat: tx: %&quot; PRIu64 &quot; rx: %&quot; PRIu64 &quot;&quot;, tx, rx);
103      }
104      snprintf(resp, BUF_SIZE, &quot;stat: {\&quot;%s\&quot;:%&quot; PRIu64 &quot;}&quot;, server_port, tx + rx);
105      msgLen = strlen(resp) + 1;
106      ss_addr_t ip_addr = { .host = NULL, .port = NULL };
107      parse_addr(manager_address, &amp;ip_addr);
108      if (ip_addr.host == NULL || ip_addr.port == NULL) {
109          sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
110          if (sfd == -1) {
111              ERROR(&quot;stat_socket&quot;);
112              return;
113          }
114          memset(&amp;claddr, 0, sizeof(struct sockaddr_un));
115          claddr.sun_family = AF_UNIX;
116          snprintf(claddr.sun_path, sizeof(claddr.sun_path), &quot;/tmp/shadowsocks.%s&quot;, server_port);
117          unlink(claddr.sun_path);
118          if (bind(sfd, (struct sockaddr *)&amp;claddr, sizeof(struct sockaddr_un)) == -1) {
119              ERROR(&quot;stat_bind&quot;);
120              close(sfd);
121              return;
122          }
123          memset(&amp;svaddr, 0, sizeof(struct sockaddr_un));
124          svaddr.sun_family = AF_UNIX;
125          strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);
126          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&amp;svaddr,
127                     sizeof(struct sockaddr_un)) != msgLen) {
128              ERROR(&quot;stat_sendto&quot;);
129              close(sfd);
130              return;
131          }
132          unlink(claddr.sun_path);
133      } else {
134          struct sockaddr_storage storage;
135          memset(&amp;storage, 0, sizeof(struct sockaddr_storage));
136          if (get_sockaddr(ip_addr.host, ip_addr.port, &amp;storage, 0, ipv6first) == -1) {
137              ERROR(&quot;failed to parse the manager addr&quot;);
138              return;
139          }
140          sfd = socket(storage.ss_family, SOCK_DGRAM, 0);
141          if (sfd == -1) {
142              ERROR(&quot;stat_socket&quot;);
143              return;
144          }
145          size_t addr_len = get_sockaddr_len((struct sockaddr *)&amp;storage);
146          if (sendto(sfd, resp, strlen(resp) + 1, 0, (struct sockaddr *)&amp;storage,
147                     addr_len) != msgLen) {
148              ERROR(&quot;stat_sendto&quot;);
149              close(sfd);
150              return;
151          }
152      }
153      close(sfd);
154  }
155  static void
156  free_connections(struct ev_loop *loop)
157  {
158      struct cork_dllist_item *curr, *next;
159      cork_dllist_foreach_void(&amp;connections, curr, next) {
160          server_t *server = cork_container_of(curr, server_t, entries);
161          remote_t *remote = server-&gt;remote;
162          close_and_free_server(loop, server);
163          close_and_free_remote(loop, remote);
164      }
165  }
166  static size_t
167  parse_header_len(const char atyp, const char *data, size_t offset)
168  {
169      size_t len = 0;
170      if ((atyp &amp; ADDRTYPE_MASK) == 1) {
171          len += sizeof(struct in_addr);
172      } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
173          uint8_t name_len = *(uint8_t *)(data + offset);
174          len += name_len + 1;
175      } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
176          len += sizeof(struct in6_addr);
177      } else {
178          return 0;
179      }
180      len += 2;
181      return len;
182  }
183  static int
184  is_header_complete(const buffer_t *buf)
185  {
186      size_t header_len = 0;
187      size_t buf_len    = buf-&gt;len;
188      char atyp = buf-&gt;array[header_len];
189      header_len++;
190      if ((atyp &amp; ADDRTYPE_MASK) == 1) {
191          header_len += sizeof(struct in_addr);
192      } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
193          if (buf_len &lt; header_len + 1)
194              return 0;
195          uint8_t name_len = *(uint8_t *)(buf-&gt;array + header_len);
196          header_len += name_len + 1;
197      } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
198          header_len += sizeof(struct in6_addr);
199      } else {
200          return -1;
201      }
202      header_len += 2;
203      if (auth || (atyp &amp; ONETIMEAUTH_FLAG)) {
204          header_len += ONETIMEAUTH_BYTES;
205      }
206      return buf_len &gt;= header_len ? 1 : 0;
207  }
208  static char *
209  get_peer_name(int fd)
210  {
211      static char peer_name[INET6_ADDRSTRLEN] = { 0 };
212      struct sockaddr_storage addr;
213      socklen_t len = sizeof(struct sockaddr_storage);
214      memset(&amp;addr, 0, len);
215      memset(peer_name, 0, INET6_ADDRSTRLEN);
216      int err = getpeername(fd, (struct sockaddr *)&amp;addr, &amp;len);
217      if (err == 0) {
218          if (addr.ss_family == AF_INET) {
219              struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;
220              dns_ntop(AF_INET, &amp;s-&gt;sin_addr, peer_name, INET_ADDRSTRLEN);
221          } else if (addr.ss_family == AF_INET6) {
222              struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;addr;
223              dns_ntop(AF_INET6, &amp;s-&gt;sin6_addr, peer_name, INET6_ADDRSTRLEN);
224          }
225      } else {
226          return NULL;
227      }
228      return peer_name;
229  }
230  #ifdef __linux__
231  static void
232  set_linger(int fd)
233  {
234      struct linger so_linger;
235      memset(&amp;so_linger, 0, sizeof(struct linger));
236      so_linger.l_onoff  = 1;
237      so_linger.l_linger = 0;
238      setsockopt(fd, SOL_SOCKET, SO_LINGER, &amp;so_linger, sizeof so_linger);
239  }
240  #endif
241  static void
242  reset_addr(int fd)
243  {
244      char *peer_name;
245      peer_name = get_peer_name(fd);
246      if (peer_name != NULL) {
247          remove_from_block_list(peer_name);
248      }
249  }
250  static void
251  report_addr(int fd, int err_level)
252  {
253  #ifdef __linux__
254      set_linger(fd);
255  #endif
256      char *peer_name;
257      peer_name = get_peer_name(fd);
258      if (peer_name != NULL) {
259          LOGE(&quot;failed to handshake with %s&quot;, peer_name);
260          update_block_list(peer_name, err_level);
261      }
262  }
263  int
264  setfastopen(int fd)
265  {
266      int s = 0;
267  #ifdef TCP_FASTOPEN
268      if (fast_open) {
269  #ifdef __APPLE__
270          int opt = 1;
271  #else
272          int opt = 5;
273  #endif
274          s = setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &amp;opt, sizeof(opt));
275          if (s == -1) {
276              if (errno == EPROTONOSUPPORT || errno == ENOPROTOOPT) {
277                  LOGE(&quot;fast open is not supported on this platform&quot;);
278                  fast_open = 0;
279              } else {
280                  ERROR(&quot;setsockopt&quot;);
281              }
282          }
283      }
284  #endif
285      return s;
286  }
287  #ifndef __MINGW32__
288  int
289  setnonblocking(int fd)
290  {
291      int flags;
292      if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
293          flags = 0;
294      }
295      return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
296  }
297  #endif
298  int
299  create_and_bind(const char *host, const char *port, int mptcp)
300  {
301      struct addrinfo hints;
302      struct addrinfo *result, *rp, *ipv4v6bindall;
303      int s, listen_sock;
304      memset(&amp;hints, 0, sizeof(struct addrinfo));
305      hints.ai_family   = AF_UNSPEC;               &amp;bsol;* Return IPv4 and IPv6 choices */
306      hints.ai_socktype = SOCK_STREAM;             &amp;bsol;* We want a TCP socket */
307      hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; &amp;bsol;* For wildcard IP address */
308      hints.ai_protocol = IPPROTO_TCP;
309      for (int i = 1; i &lt; 8; i++) {
310          s = getaddrinfo(host, port, &amp;hints, &amp;result);
311          if (s == 0) {
312              break;
313          } else {
314              sleep(pow(2, i));
315              LOGE(&quot;failed to resolve server name, wait %.0f seconds&quot;, pow(2, i));
316          }
317      }
318      if (s != 0) {
319          LOGE(&quot;getaddrinfo: %s&quot;, gai_strerror(s));
320          return -1;
321      }
322      rp = result;
323      if (!host) {
324          ipv4v6bindall = result;
325          while (ipv4v6bindall) {
326              if (ipv4v6bindall-&gt;ai_family == AF_INET6) {
327                  rp = ipv4v6bindall; &amp;bsol;* Take first IPV6 address available */
328                  break;
329              }
330              ipv4v6bindall = ipv4v6bindall-&gt;ai_next; &amp;bsol;* Get next address info, if any */
331          }
332      }
333      for (&amp;bsol;*rp = result*/; rp != NULL; rp = rp-&gt;ai_next) {
334          listen_sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
335          if (listen_sock == -1) {
336              continue;
337          }
338          if (rp-&gt;ai_family == AF_INET6) {
339              int ipv6only = host ? 1 : 0;
340              setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &amp;ipv6only, sizeof(ipv6only));
341          }
342          int opt = 1;
343          setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
344  #ifdef SO_NOSIGPIPE
345          setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
346  #endif
347          int err = set_reuseport(listen_sock);
348          if (err == 0) {
349              LOGI(&quot;tcp port reuse enabled&quot;);
350          }
351          if (mptcp == 1) {
352              int err = setsockopt(listen_sock, SOL_TCP, MPTCP_ENABLED, &amp;opt, sizeof(opt));
353              if (err == -1) {
354                  ERROR(&quot;failed to enable multipath TCP&quot;);
355              }
356          }
357          s = bind(listen_sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen);
358          if (s == 0) {
359              break;
360          } else {
361              ERROR(&quot;bind&quot;);
362          }
363          close(listen_sock);
364      }
365      if (rp == NULL) {
366          LOGE(&quot;Could not bind&quot;);
367          return -1;
368      }
369      freeaddrinfo(result);
370      return listen_sock;
371  }
372  static remote_t *
373  connect_to_remote(EV_P_ struct addrinfo *res,
374                    server_t *server)
375  {
376      int sockfd;
377  #ifdef SET_INTERFACE
378      const char *iface = server-&gt;listen_ctx-&gt;iface;
379  #endif
380      if (acl) {
381          char ipstr[INET6_ADDRSTRLEN];
382          memset(ipstr, 0, INET6_ADDRSTRLEN);
383          if (res-&gt;ai_addr-&gt;sa_family == AF_INET) {
384              struct sockaddr_in *s = (struct sockaddr_in *)res-&gt;ai_addr;
385              dns_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, INET_ADDRSTRLEN);
386          } else if (res-&gt;ai_addr-&gt;sa_family == AF_INET6) {
387              struct sockaddr_in6 *s = (struct sockaddr_in6 *)res-&gt;ai_addr;
388              dns_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, INET6_ADDRSTRLEN);
389          }
390          if (outbound_block_match_host(ipstr) == 1) {
391              if (verbose)
392                  LOGI(&quot;outbound blocked %s&quot;, ipstr);
393              return NULL;
394          }
395      }
396      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
397      if (sockfd == -1) {
398          ERROR(&quot;socket&quot;);
399          close(sockfd);
400          return NULL;
401      }
402      int opt = 1;
403      setsockopt(sockfd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
404  #ifdef SO_NOSIGPIPE
405      setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
406  #endif
407      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
408      if (setnonblocking(sockfd) == -1)
409          ERROR(&quot;setnonblocking&quot;);
410      if (bind_address != NULL)
411          if (bind_to_address(sockfd, bind_address) == -1) {
412              ERROR(&quot;bind_to_address&quot;);
413              close(sockfd);
414              return NULL;
415          }
416  #ifdef SET_INTERFACE
417      if (iface) {
418          if (setinterface(sockfd, iface) == -1) {
419              ERROR(&quot;setinterface&quot;);
420              close(sockfd);
421              return NULL;
422          }
423      }
424  #endif
425      remote_t *remote = new_remote(sockfd);
426  #ifdef TCP_FASTOPEN
427      if (fast_open) {
428  #ifdef __APPLE__
429          ((struct sockaddr_in *)(res-&gt;ai_addr))-&gt;sin_len = sizeof(struct sockaddr_in);
430          sa_endpoints_t endpoints;
431          memset((char *)&amp;endpoints, 0, sizeof(endpoints));
432          endpoints.sae_dstaddr    = res-&gt;ai_addr;
433          endpoints.sae_dstaddrlen = res-&gt;ai_addrlen;
434          struct iovec iov;
435          iov.iov_base = server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx;
436          iov.iov_len  = server-&gt;buf-&gt;len;
437          size_t len;
438          int s = connectx(sockfd, &amp;endpoints, SAE_ASSOCID_ANY, CONNECT_DATA_IDEMPOTENT,
439                           &amp;iov, 1, &amp;len, NULL);
440          if (s == 0) {
441              s = len;
442          }
443  #else
444          ssize_t s = sendto(sockfd, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
445                             server-&gt;buf-&gt;len, MSG_FASTOPEN, res-&gt;ai_addr,
446                             res-&gt;ai_addrlen);
447  #endif
448          if (s == -1) {
449              if (errno == CONNECT_IN_PROGRESS || errno == EAGAIN
450                  || errno == EWOULDBLOCK) {
451              } else if (errno == EOPNOTSUPP || errno == EPROTONOSUPPORT ||
452                         errno == ENOPROTOOPT) {
453                  fast_open = 0;
454                  LOGE(&quot;fast open is not supported on this platform&quot;);
455              } else {
456                  ERROR(&quot;sendto&quot;);
457              }
458          } else if (s &lt;= server-&gt;buf-&gt;len) {
459              server-&gt;buf-&gt;idx += s;
460              server-&gt;buf-&gt;len -= s;
461          } else {
462              server-&gt;buf-&gt;idx = 0;
463              server-&gt;buf-&gt;len = 0;
464          }
465      }
466  #endif
467      if (!fast_open) {
468          int r = connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
469          if (r == -1 &amp;&amp; errno != CONNECT_IN_PROGRESS) {
470              ERROR(&quot;connect&quot;);
471              close_and_free_remote(EV_A_ remote);
472              return NULL;
473          }
474      }
475      return remote;
476  }
477  static void
478  server_recv_cb(EV_P_ ev_io *w, int revents)
479  {
480      server_ctx_t *server_recv_ctx = (server_ctx_t *)w;
481      server_t *server              = server_recv_ctx-&gt;server;
482      remote_t *remote              = NULL;
483      int len       = server-&gt;buf-&gt;len;
484      buffer_t *buf = server-&gt;buf;
485      if (server-&gt;stage &gt; STAGE_PARSE) {
486          remote = server-&gt;remote;
487          buf    = remote-&gt;buf;
488          len    = 0;
489          ev_timer_again(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
490      }
491      if (len &gt; BUF_SIZE) {
492          ERROR(&quot;out of recv buffer&quot;);
493          close_and_free_remote(EV_A_ remote);
494          close_and_free_server(EV_A_ server);
495          return;
496      }
497      ssize_t r = recv(server-&gt;fd, buf-&gt;array + len, BUF_SIZE - len, 0);
498      if (r == 0) {
499          if (verbose) {
500              LOGI(&quot;server_recv close the connection&quot;);
501          }
502          close_and_free_remote(EV_A_ remote);
503          close_and_free_server(EV_A_ server);
504          return;
505      } else if (r == -1) {
506          if (errno == EAGAIN || errno == EWOULDBLOCK) {
507              return;
508          } else {
509              ERROR(&quot;server recv&quot;);
510              close_and_free_remote(EV_A_ remote);
511              close_and_free_server(EV_A_ server);
512              return;
513          }
514      }
515      tx += r;
516      if (server-&gt;stage == STAGE_ERROR) {
517          server-&gt;buf-&gt;len = 0;
518          server-&gt;buf-&gt;idx = 0;
519          return;
520      }
521      if (server-&gt;stage == STAGE_INIT) {
522          buf-&gt;len += r;
523          if (buf-&gt;len &lt;= enc_get_iv_len() + 1) {
524              return;
525          }
526      } else {
527          buf-&gt;len = r;
528      }
529      if (server-&gt;obfs_plugin) {
530          obfs_class *obfs_plugin = server-&gt;obfs_plugin;
531          if (obfs_plugin-&gt;server_decode) {
532              int needsendback = 0;
533              if(obfs_compatible == 1)
534              {
535                  char *back_buf = (char*)malloc(sizeof(buffer_t));
536                  memcpy(back_buf, buf, sizeof(buffer_t));
537                  buf-&gt;len = obfs_plugin-&gt;server_decode(server-&gt;obfs, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity, &amp;needsendback);
538                  if ((int)buf-&gt;len &lt; 0)
539                  {
540                      LOGE(&quot;obfs_compatible&quot;);
541                      memcpy(buf, back_buf, sizeof(buffer_t));
542                      free(back_buf);
543                      server-&gt;obfs_compatible_state = 1;
544                  }
545              }
546              else
547              {
548                  buf-&gt;len = obfs_plugin-&gt;server_decode(server-&gt;obfs, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity, &amp;needsendback);
549                  if ((int)buf-&gt;len &lt; 0) {
550                      LOGE(&quot;server_decode&quot;);
551                      close_and_free_remote(EV_A_ remote);
552                      close_and_free_server(EV_A_ server);
553                      return;
554                  }
555              }
556              if (needsendback) {
557                  size_t capacity = BUF_SIZE;
558                  char *sendback_buf = (char*)malloc(capacity);
559                  obfs_class *obfs_plugin = server-&gt;obfs_plugin;
560                  if (obfs_plugin-&gt;server_encode) {
561                      int len = obfs_plugin-&gt;server_encode(server-&gt;obfs, &amp;sendback_buf, 0, &amp;capacity);
562                      send(server-&gt;fd, sendback_buf, len, 0);
563                  }
564                  free(sendback_buf);
565                  return;
566              }
567          }
568      }
569      int err = ss_decrypt(buf, server-&gt;d_ctx, BUF_SIZE);
570      if (err) {
571          report_addr(server-&gt;fd, MALICIOUS);
572          close_and_free_remote(EV_A_ remote);
573          close_and_free_server(EV_A_ server);
574          return;
575      }
576      if (server-&gt;protocol_plugin) {
577          obfs_class *protocol_plugin = server-&gt;protocol_plugin;
578          if (protocol_plugin-&gt;server_post_decrypt) {
579              if(protocol_compatible == 1)
580              {
581                  char *back_buf = (char*)malloc(sizeof(buffer_t));
582                  memcpy(back_buf, buf, sizeof(buffer_t));
583                  buf-&gt;len = protocol_plugin-&gt;server_post_decrypt(server-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
584                  if ((int)buf-&gt;len &lt; 0) {
585                      LOGE(&quot;protocol_compatible&quot;);
586                      memcpy(buf, back_buf, sizeof(buffer_t));
587                      free(back_buf);
588                      server-&gt;protocol_compatible_state = 1;
589                  }
590                  if ( buf-&gt;len == 0 )
591                  {
592                      LOGE(&quot;protocol_compatible&quot;);
593                      memcpy(buf, back_buf, sizeof(buffer_t));
594                      free(back_buf);
595                      server-&gt;protocol_compatible_state = 1;
596                  }
597              }
598              else
599              {
600                  buf-&gt;len = protocol_plugin-&gt;server_post_decrypt(server-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
601                  if ((int)buf-&gt;len &lt; 0) {
602                      LOGE(&quot;server_post_decrypt&quot;);
603                      close_and_free_remote(EV_A_ remote);
604                      close_and_free_server(EV_A_ server);
605                      return;
606                  }
607                  if ( buf-&gt;len == 0 )
608                  {
609                      LOGE(&quot;server_post_decrypt&quot;);
610                      return;
611                  }
612              }
613          }
614      }
615      if (server-&gt;stage == STAGE_INIT) {
616          int ret = is_header_complete(server-&gt;buf);
617          if (ret == 1) {
618              bfree(server-&gt;header_buf);
619              ss_free(server-&gt;header_buf);
620              server-&gt;stage = STAGE_PARSE;
621          } else if (ret == -1) {
622              server-&gt;stage = STAGE_ERROR;
623              report_addr(server-&gt;fd, MALFORMED);
624              server-&gt;buf-&gt;len = 0;
625              server-&gt;buf-&gt;idx = 0;
626              return;
627          } else {
628              server-&gt;stage = STAGE_HANDSHAKE;
629          }
630      }
631      if (server-&gt;stage == STAGE_HANDSHAKE) {
632          size_t header_len = server-&gt;header_buf-&gt;len;
633          brealloc(server-&gt;header_buf, server-&gt;buf-&gt;len + header_len, BUF_SIZE);
634          memcpy(server-&gt;header_buf-&gt;array + header_len,
635                 server-&gt;buf-&gt;array, server-&gt;buf-&gt;len);
636          server-&gt;header_buf-&gt;len = server-&gt;buf-&gt;len + header_len;
637          int ret = is_header_complete(server-&gt;buf);
638          if (ret == 1) {
639              brealloc(server-&gt;buf, server-&gt;header_buf-&gt;len, BUF_SIZE);
640              memcpy(server-&gt;buf-&gt;array, server-&gt;header_buf-&gt;array, server-&gt;header_buf-&gt;len);
641              server-&gt;buf-&gt;len = server-&gt;header_buf-&gt;len;
642              bfree(server-&gt;header_buf);
643              ss_free(server-&gt;header_buf);
644              server-&gt;stage = STAGE_PARSE;
645          } else {
646              if (ret == -1)
647                  server-&gt;stage = STAGE_ERROR;
648              server-&gt;buf-&gt;len = 0;
649              server-&gt;buf-&gt;idx = 0;
650              return;
651          }
652      }
653      if (server-&gt;stage == STAGE_STREAM) {
654          if (server-&gt;auth &amp;&amp; !ss_check_hash(remote-&gt;buf, server-&gt;chunk, server-&gt;d_ctx, BUF_SIZE)) {
655              LOGE(&quot;hash error&quot;);
656              report_addr(server-&gt;fd, BAD);
657              close_and_free_server(EV_A_ server);
658              close_and_free_remote(EV_A_ remote);
659              return;
660          }
661          int s = send(remote-&gt;fd, remote-&gt;buf-&gt;array, remote-&gt;buf-&gt;len, 0);
662          if (s == -1) {
663              if (errno == EAGAIN || errno == EWOULDBLOCK) {
664                  remote-&gt;buf-&gt;idx = 0;
665                  ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
666                  ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
667              } else {
668                  ERROR(&quot;server_recv_send&quot;);
669                  close_and_free_remote(EV_A_ remote);
670                  close_and_free_server(EV_A_ server);
671              }
672          } else if (s &lt; remote-&gt;buf-&gt;len) {
673              remote-&gt;buf-&gt;len -= s;
674              remote-&gt;buf-&gt;idx  = s;
675              ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
676              ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
677          }
678          return;
679      } else if (server-&gt;stage == STAGE_PARSE) {
680          int offset     = 0;
681          int need_query = 0;
682          char atyp      = server-&gt;buf-&gt;array[offset++];
683          char host[257] = { 0 };
684          uint16_t port  = 0;
685          struct addrinfo info;
686          struct sockaddr_storage storage;
687          memset(&amp;info, 0, sizeof(struct addrinfo));
688          memset(&amp;storage, 0, sizeof(struct sockaddr_storage));
689          if (auth || (atyp &amp; ONETIMEAUTH_FLAG)) {
690              size_t header_len = parse_header_len(atyp, server-&gt;buf-&gt;array, offset);
691              size_t len        = server-&gt;buf-&gt;len;
692              if (header_len == 0 || len &lt; offset + header_len + ONETIMEAUTH_BYTES) {
693                  report_addr(server-&gt;fd, MALFORMED);
694                  close_and_free_server(EV_A_ server);
695                  return;
696              }
697              server-&gt;buf-&gt;len = offset + header_len + ONETIMEAUTH_BYTES;
698              if (ss_onetimeauth_verify(server-&gt;buf, server-&gt;d_ctx-&gt;evp.iv)) {
699                  report_addr(server-&gt;fd, BAD);
700                  close_and_free_server(EV_A_ server);
701                  return;
702              }
703              server-&gt;buf-&gt;len = len;
704              server-&gt;auth     = 1;
705          }
706          if ((atyp &amp; ADDRTYPE_MASK) == 1) {
707              struct sockaddr_in *addr = (struct sockaddr_in *)&amp;storage;
708              size_t in_addr_len       = sizeof(struct in_addr);
709              addr-&gt;sin_family = AF_INET;
710              if (server-&gt;buf-&gt;len &gt;= in_addr_len + 3) {
711                  addr-&gt;sin_addr = *(struct in_addr *)(server-&gt;buf-&gt;array + offset);
712                  dns_ntop(AF_INET, (const void *)(server-&gt;buf-&gt;array + offset),
713                           host, INET_ADDRSTRLEN);
714                  offset += in_addr_len;
715              } else {
716                  LOGE(&quot;invalid header with addr type %d&quot;, atyp);
717                  report_addr(server-&gt;fd, MALFORMED);
718                  close_and_free_server(EV_A_ server);
719                  return;
720              }
721              addr-&gt;sin_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
722              info.ai_family   = AF_INET;
723              info.ai_socktype = SOCK_STREAM;
724              info.ai_protocol = IPPROTO_TCP;
725              info.ai_addrlen  = sizeof(struct sockaddr_in);
726              info.ai_addr     = (struct sockaddr *)addr;
727          } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
728              uint8_t name_len = *(uint8_t *)(server-&gt;buf-&gt;array + offset);
729              if (name_len + 4 &lt;= server-&gt;buf-&gt;len) {
730                  memcpy(host, server-&gt;buf-&gt;array + offset + 1, name_len);
731                  offset += name_len + 1;
732              } else {
733                  LOGE(&quot;invalid name length: %d&quot;, name_len);
734                  report_addr(server-&gt;fd, MALFORMED);
735                  close_and_free_server(EV_A_ server);
736                  return;
737              }
738              if (acl &amp;&amp; outbound_block_match_host(host) == 1) {
739                  if (verbose)
740                      LOGI(&quot;outbound blocked %s&quot;, host);
741                  close_and_free_server(EV_A_ server);
742                  return;
743              }
744              struct cork_ip ip;
745              if (cork_ip_init(&amp;ip, host) != -1) {
746                  info.ai_socktype = SOCK_STREAM;
747                  info.ai_protocol = IPPROTO_TCP;
748                  if (ip.version == 4) {
749                      struct sockaddr_in *addr = (struct sockaddr_in *)&amp;storage;
750                      dns_pton(AF_INET, host, &amp;(addr-&gt;sin_addr));
751                      addr-&gt;sin_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
752                      addr-&gt;sin_family = AF_INET;
753                      info.ai_family   = AF_INET;
754                      info.ai_addrlen  = sizeof(struct sockaddr_in);
755                      info.ai_addr     = (struct sockaddr *)addr;
756                  } else if (ip.version == 6) {
757                      struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&amp;storage;
758                      dns_pton(AF_INET6, host, &amp;(addr-&gt;sin6_addr));
759                      addr-&gt;sin6_port   = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
760                      addr-&gt;sin6_family = AF_INET6;
761                      info.ai_family    = AF_INET6;
762                      info.ai_addrlen   = sizeof(struct sockaddr_in6);
763                      info.ai_addr      = (struct sockaddr *)addr;
764                  }
765              } else {
766                  if (!validate_hostname(host, name_len)) {
767                      LOGE(&quot;invalid host name&quot;);
768                      report_addr(server-&gt;fd, MALFORMED);
769                      close_and_free_server(EV_A_ server);
770                      return;
771                  }
772                  need_query = 1;
773              }
774          } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
775              struct sockaddr_in6 *addr = (struct sockaddr_in6 *)&amp;storage;
776              size_t in6_addr_len       = sizeof(struct in6_addr);
777              addr-&gt;sin6_family = AF_INET6;
778              if (server-&gt;buf-&gt;len &gt;= in6_addr_len + 3) {
779                  addr-&gt;sin6_addr = *(struct in6_addr *)(server-&gt;buf-&gt;array + offset);
780                  dns_ntop(AF_INET6, (const void *)(server-&gt;buf-&gt;array + offset),
781                           host, INET6_ADDRSTRLEN);
782                  offset += in6_addr_len;
783              } else {
784                  LOGE(&quot;invalid header with addr type %d&quot;, atyp);
785                  report_addr(server-&gt;fd, MALFORMED);
786                  close_and_free_server(EV_A_ server);
787                  return;
788              }
789              addr-&gt;sin6_port  = *(uint16_t *)(server-&gt;buf-&gt;array + offset);
790              info.ai_family   = AF_INET6;
791              info.ai_socktype = SOCK_STREAM;
792              info.ai_protocol = IPPROTO_TCP;
793              info.ai_addrlen  = sizeof(struct sockaddr_in6);
794              info.ai_addr     = (struct sockaddr *)addr;
795          }
796          if (offset == 1) {
797              LOGE(&quot;invalid header with addr type %d&quot;, atyp);
798              report_addr(server-&gt;fd, MALFORMED);
799              close_and_free_server(EV_A_ server);
800              return;
801          }
802          port = (*(uint16_t *)(server-&gt;buf-&gt;array + offset));
803          offset += 2;
804          if (server-&gt;auth) {
805              offset += ONETIMEAUTH_BYTES;
806          }
807          if (server-&gt;buf-&gt;len &lt; offset) {
808              report_addr(server-&gt;fd, MALFORMED);
809              close_and_free_server(EV_A_ server);
810              return;
811          } else {
812              server-&gt;buf-&gt;len -= offset;
813              memmove(server-&gt;buf-&gt;array, server-&gt;buf-&gt;array + offset, server-&gt;buf-&gt;len);
814          }
815          if (verbose) {
816              if ((atyp &amp; ADDRTYPE_MASK) == 4)
817                  LOGI(&quot;connect to [%s]:%d&quot;, host, ntohs(port));
818              else
819                  LOGI(&quot;connect to %s:%d&quot;, host, ntohs(port));
820          }
821          if (server-&gt;auth &amp;&amp; !ss_check_hash(server-&gt;buf, server-&gt;chunk, server-&gt;d_ctx, BUF_SIZE)) {
822              LOGE(&quot;hash error&quot;);
823              report_addr(server-&gt;fd, BAD);
824              close_and_free_server(EV_A_ server);
825              return;
826          }
827          if (!need_query) {
828              remote_t *remote = connect_to_remote(EV_A_ &amp;info, server);
829              if (remote == NULL) {
830                  LOGE(&quot;connect error&quot;);
831                  close_and_free_server(EV_A_ server);
832                  return;
833              } else {
834                  server-&gt;remote = remote;
835                  remote-&gt;server = server;
836                  if (server-&gt;buf-&gt;len &gt; 0) {
837                      memcpy(remote-&gt;buf-&gt;array, server-&gt;buf-&gt;array, server-&gt;buf-&gt;len);
838                      remote-&gt;buf-&gt;len = server-&gt;buf-&gt;len;
839                      remote-&gt;buf-&gt;idx = 0;
840                      server-&gt;buf-&gt;len = 0;
841                      server-&gt;buf-&gt;idx = 0;
842                  }
843                  ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
844                  ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
845              }
846          } else {
847              query_t *query = (query_t *)ss_malloc(sizeof(query_t));
848              query-&gt;server = server;
849              snprintf(query-&gt;hostname, 256, &quot;%s&quot;, host);
850              server-&gt;stage = STAGE_RESOLVE;
851              server-&gt;query = resolv_query(host, server_resolve_cb,
852                                           query_free_cb, query, port);
853              ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
854          }
855          return;
856      }
857      FATAL(&quot;server context error&quot;);
858  }
859  static void
860  server_send_cb(EV_P_ ev_io *w, int revents)
861  {
862      server_ctx_t *server_send_ctx = (server_ctx_t *)w;
863      server_t *server              = server_send_ctx-&gt;server;
864      remote_t *remote              = server-&gt;remote;
865      if (remote == NULL) {
866          LOGE(&quot;invalid server&quot;);
867          close_and_free_server(EV_A_ server);
868          return;
869      }
870      if (server-&gt;buf-&gt;len == 0) {
871          if (verbose) {
872              LOGI(&quot;server_send close the connection&quot;);
873          }
874          close_and_free_remote(EV_A_ remote);
875          close_and_free_server(EV_A_ server);
876          return;
877      } else {
878          ssize_t s = send(server-&gt;fd, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
879                           server-&gt;buf-&gt;len, 0);
880          if (s == -1) {
881              if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) {
882                  ERROR(&quot;server_send_send&quot;);
883                  close_and_free_remote(EV_A_ remote);
884                  close_and_free_server(EV_A_ server);
885              }
886              return;
887          } else if (s &lt; server-&gt;buf-&gt;len) {
888              server-&gt;buf-&gt;len -= s;
889              server-&gt;buf-&gt;idx += s;
890              return;
891          } else {
892              server-&gt;buf-&gt;len = 0;
893              server-&gt;buf-&gt;idx = 0;
894              ev_io_stop(EV_A_ &amp; server_send_ctx-&gt;io);
895              if (remote != NULL) {
896                  ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
897                  return;
898              } else {
899                  LOGE(&quot;invalid remote&quot;);
900                  close_and_free_remote(EV_A_ remote);
901                  close_and_free_server(EV_A_ server);
902                  return;
903              }
904          }
905      }
906  }
907  static void
908  block_list_clear_cb(EV_P_ ev_timer *watcher, int revents)
909  {
910      clear_block_list();
911  }
912  static void
913  server_timeout_cb(EV_P_ ev_timer *watcher, int revents)
914  {
915      server_ctx_t *server_ctx
916          = cork_container_of(watcher, server_ctx_t, watcher);
917      server_t *server = server_ctx-&gt;server;
918      remote_t *remote = server-&gt;remote;
919      if (verbose) {
920          LOGI(&quot;TCP connection timeout&quot;);
921      }
922      if (server-&gt;stage &lt; STAGE_PARSE) {
923          if (verbose) {
924              size_t len = server-&gt;stage ?
925                           server-&gt;header_buf-&gt;len : server-&gt;buf-&gt;len;
926  #ifdef __MINGW32__
927              LOGI(&quot;incomplete header: %u&quot;, len);
928  #else
929              LOGI(&quot;incomplete header: %zu&quot;, len);
930  #endif
931          }
932          report_addr(server-&gt;fd, SUSPICIOUS);
933      }
934      close_and_free_remote(EV_A_ remote);
935      close_and_free_server(EV_A_ server);
936  }
937  static void
938  query_free_cb(void *data)
939  {
940      if (data != NULL) {
941          ss_free(data);
942      }
943  }
944  static void
945  server_resolve_cb(struct sockaddr *addr, void *data)
946  {
947      query_t *query       = (query_t *)data;
948      server_t *server     = query-&gt;server;
949      struct ev_loop *loop = server-&gt;listen_ctx-&gt;loop;
950      server-&gt;query = NULL;
951      if (addr == NULL) {
952          LOGE(&quot;unable to resolve %s&quot;, query-&gt;hostname);
953          close_and_free_server(EV_A_ server);
954      } else {
955          if (verbose) {
956              LOGI(&quot;successfully resolved %s&quot;, query-&gt;hostname);
957          }
958          struct addrinfo info;
959          memset(&amp;info, 0, sizeof(struct addrinfo));
960          info.ai_socktype = SOCK_STREAM;
961          info.ai_protocol = IPPROTO_TCP;
962          info.ai_addr     = addr;
963          if (addr-&gt;sa_family == AF_INET) {
964              info.ai_family  = AF_INET;
965              info.ai_addrlen = sizeof(struct sockaddr_in);
966          } else if (addr-&gt;sa_family == AF_INET6) {
967              info.ai_family  = AF_INET6;
968              info.ai_addrlen = sizeof(struct sockaddr_in6);
969          }
970          remote_t *remote = connect_to_remote(EV_A_ &amp;info, server);
971          if (remote == NULL) {
972              close_and_free_server(EV_A_ server);
973          } else {
974              server-&gt;remote = remote;
975              remote-&gt;server = server;
976              if (server-&gt;buf-&gt;len &gt; 0) {
977                  memcpy(remote-&gt;buf-&gt;array, server-&gt;buf-&gt;array + server-&gt;buf-&gt;idx,
978                         server-&gt;buf-&gt;len);
979                  remote-&gt;buf-&gt;len = server-&gt;buf-&gt;len;
980                  remote-&gt;buf-&gt;idx = 0;
981                  server-&gt;buf-&gt;len = 0;
982                  server-&gt;buf-&gt;idx = 0;
983              }
984              ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
985          }
986      }
987  }
988  static void
989  remote_recv_cb(EV_P_ ev_io *w, int revents)
990  {
991      remote_ctx_t *remote_recv_ctx = (remote_ctx_t *)w;
992      remote_t *remote              = remote_recv_ctx-&gt;remote;
993      server_t *server              = remote-&gt;server;
994      if (server == NULL) {
995          LOGE(&quot;invalid server&quot;);
996          close_and_free_remote(EV_A_ remote);
997          return;
998      }
999      ev_timer_again(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1000      ssize_t r = recv(remote-&gt;fd, server-&gt;buf-&gt;array, BUF_SIZE, 0);
1001      if (r == 0) {
1002          if (verbose) {
1003              LOGI(&quot;remote_recv close the connection&quot;);
1004          }
1005          close_and_free_remote(EV_A_ remote);
1006          close_and_free_server(EV_A_ server);
1007          return;
1008      } else if (r == -1) {
1009          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1010              return;
1011          } else {
1012              ERROR(&quot;remote recv&quot;);
1013              close_and_free_remote(EV_A_ remote);
1014              close_and_free_server(EV_A_ server);
1015              return;
1016          }
1017      }
1018      rx += r;
1019      server-&gt;buf-&gt;len = r;
1020      server_info _server_info;
1021      if (server-&gt;obfs_plugin) {
1022          server-&gt;obfs_plugin-&gt;get_server_info(server-&gt;obfs, &amp;_server_info);
1023          _server_info.head_len = get_head_size(server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, 30);
1024          server-&gt;obfs_plugin-&gt;set_server_info(server-&gt;obfs, &amp;_server_info);
1025      }
1026      if (server-&gt;protocol_plugin &amp;&amp; server-&gt;obfs_compatible_state == 0) {
1027          obfs_class *protocol_plugin = server-&gt;protocol_plugin;
1028          if (protocol_plugin-&gt;server_pre_encrypt) {
1029              server-&gt;buf-&gt;len = protocol_plugin-&gt;server_pre_encrypt(server-&gt;protocol, &amp;server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, &amp;server-&gt;buf-&gt;capacity);
1030          }
1031      }
1032      int err = ss_encrypt(server-&gt;buf, server-&gt;e_ctx, BUF_SIZE);
1033      if (err) {
1034          LOGE(&quot;invalid password or cipher&quot;);
1035          close_and_free_remote(EV_A_ remote);
1036          close_and_free_server(EV_A_ server);
1037          return;
1038      }
1039      if (server-&gt;obfs_plugin &amp;&amp; server-&gt;obfs_compatible_state == 0) {
1040          obfs_class *obfs_plugin = server-&gt;obfs_plugin;
1041          if (obfs_plugin-&gt;server_encode) {
1042              server-&gt;buf-&gt;len = obfs_plugin-&gt;server_encode(server-&gt;obfs, &amp;server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, &amp;server-&gt;buf-&gt;capacity);
1043          }
1044      }
1045      int s = send(server-&gt;fd, server-&gt;buf-&gt;array, server-&gt;buf-&gt;len, 0);
1046      if (s == -1) {
1047          if (errno == EAGAIN || errno == EWOULDBLOCK) {
1048              server-&gt;buf-&gt;idx = 0;
1049              ev_io_stop(EV_A_ &amp; remote_recv_ctx-&gt;io);
1050              ev_io_start(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1051          } else {
1052              ERROR(&quot;remote_recv_send&quot;);
1053              close_and_free_remote(EV_A_ remote);
1054              close_and_free_server(EV_A_ server);
1055              return;
1056          }
1057      } else if (s &lt; server-&gt;buf-&gt;len) {
<span onclick='openModal()' class='match'>1058          server-&gt;buf-&gt;len -= s;
1059          server-&gt;buf-&gt;idx  = s;
1060          ev_io_stop(EV_A_ &amp; remote_recv_ctx-&gt;io);
1061          ev_io_start(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1062      }
1063      if (!remote-&gt;recv_ctx-&gt;connected) {
</span>1064          int opt = 0;
1065          setsockopt(server-&gt;fd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1066          setsockopt(remote-&gt;fd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1067          remote-&gt;recv_ctx-&gt;connected = 1;
1068      }
1069  }
1070  static void
1071  remote_send_cb(EV_P_ ev_io *w, int revents)
1072  {
1073      remote_ctx_t *remote_send_ctx = (remote_ctx_t *)w;
1074      remote_t *remote              = remote_send_ctx-&gt;remote;
1075      server_t *server              = remote-&gt;server;
1076      if (server == NULL) {
1077          LOGE(&quot;invalid server&quot;);
1078          close_and_free_remote(EV_A_ remote);
1079          return;
1080      }
1081      if (!remote_send_ctx-&gt;connected) {
1082          struct sockaddr_storage addr;
1083          socklen_t len = sizeof(struct sockaddr_storage);
1084          memset(&amp;addr, 0, len);
1085          int r = getpeername(remote-&gt;fd, (struct sockaddr *)&amp;addr, &amp;len);
1086          if (r == 0) {
1087              if (verbose) {
1088                  LOGI(&quot;remote connected&quot;);
1089              }
1090              remote_send_ctx-&gt;connected = 1;
1091              reset_addr(server-&gt;fd);
1092              if (remote-&gt;buf-&gt;len == 0) {
1093                  server-&gt;stage = STAGE_STREAM;
1094                  ev_io_stop(EV_A_ &amp; remote_send_ctx-&gt;io);
1095                  ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1096                  ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1097                  return;
1098              }
1099          } else {
1100              ERROR(&quot;getpeername&quot;);
1101              close_and_free_remote(EV_A_ remote);
1102              close_and_free_server(EV_A_ server);
1103              return;
1104          }
1105      }
1106      if (remote-&gt;buf-&gt;len == 0) {
1107          if (verbose) {
1108              LOGI(&quot;remote_send close the connection&quot;);
1109          }
1110          close_and_free_remote(EV_A_ remote);
1111          close_and_free_server(EV_A_ server);
1112          return;
1113      } else {
1114          ssize_t s = send(remote-&gt;fd, remote-&gt;buf-&gt;array + remote-&gt;buf-&gt;idx,
1115                           remote-&gt;buf-&gt;len, 0);
1116          if (s == -1) {
1117              if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) {
1118                  ERROR(&quot;remote_send_send&quot;);
1119                  close_and_free_remote(EV_A_ remote);
1120                  close_and_free_server(EV_A_ server);
1121              }
1122              return;
1123          } else if (s &lt; remote-&gt;buf-&gt;len) {
1124              remote-&gt;buf-&gt;len -= s;
1125              remote-&gt;buf-&gt;idx += s;
1126              return;
1127          } else {
1128              remote-&gt;buf-&gt;len = 0;
1129              remote-&gt;buf-&gt;idx = 0;
1130              ev_io_stop(EV_A_ &amp; remote_send_ctx-&gt;io);
1131              if (server != NULL) {
1132                  ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1133                  if (server-&gt;stage != STAGE_STREAM) {
1134                      server-&gt;stage = STAGE_STREAM;
1135                      ev_io_start(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1136                  }
1137              } else {
1138                  LOGE(&quot;invalid server&quot;);
1139                  close_and_free_remote(EV_A_ remote);
1140                  close_and_free_server(EV_A_ server);
1141              }
1142              return;
1143          }
1144      }
1145  }
1146  static remote_t *
1147  new_remote(int fd)
1148  {
1149      if (verbose) {
1150          remote_conn++;
1151      }
1152      remote_t *remote;
1153      remote                      = ss_malloc(sizeof(remote_t));
1154      remote-&gt;recv_ctx            = ss_malloc(sizeof(remote_ctx_t));
1155      remote-&gt;send_ctx            = ss_malloc(sizeof(remote_ctx_t));
1156      remote-&gt;buf                 = ss_malloc(sizeof(buffer_t));
1157      remote-&gt;fd                  = fd;
1158      remote-&gt;recv_ctx-&gt;remote    = remote;
1159      remote-&gt;recv_ctx-&gt;connected = 0;
1160      remote-&gt;send_ctx-&gt;remote    = remote;
1161      remote-&gt;send_ctx-&gt;connected = 0;
1162      remote-&gt;server              = NULL;
1163      ev_io_init(&amp;remote-&gt;recv_ctx-&gt;io, remote_recv_cb, fd, EV_READ);
1164      ev_io_init(&amp;remote-&gt;send_ctx-&gt;io, remote_send_cb, fd, EV_WRITE);
1165      balloc(remote-&gt;buf, BUF_SIZE);
1166      return remote;
1167  }
1168  static void
1169  free_remote(remote_t *remote)
1170  {
1171      if (remote-&gt;server != NULL) {
1172          remote-&gt;server-&gt;remote = NULL;
1173      }
1174      if (remote-&gt;buf != NULL) {
1175          bfree(remote-&gt;buf);
1176          ss_free(remote-&gt;buf);
1177      }
1178      ss_free(remote-&gt;recv_ctx);
1179      ss_free(remote-&gt;send_ctx);
1180      ss_free(remote);
1181  }
1182  static void
1183  close_and_free_remote(EV_P_ remote_t *remote)
1184  {
1185      if (remote != NULL) {
1186          ev_io_stop(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
1187          ev_io_stop(EV_A_ &amp; remote-&gt;recv_ctx-&gt;io);
1188          close(remote-&gt;fd);
1189          free_remote(remote);
1190          if (verbose) {
1191              remote_conn--;
1192              LOGI(&quot;current remote connection: %d&quot;, remote_conn);
1193          }
1194      }
1195  }
1196  static server_t *
1197  new_server(int fd, listen_ctx_t *listener)
1198  {
1199      if (verbose) {
1200          server_conn++;
1201      }
1202      server_t *server;
1203      server = ss_malloc(sizeof(server_t));
1204      memset(server, 0, sizeof(server_t));
1205      server-&gt;recv_ctx            = ss_malloc(sizeof(server_ctx_t));
1206      server-&gt;send_ctx            = ss_malloc(sizeof(server_ctx_t));
1207      server-&gt;buf                 = ss_malloc(sizeof(buffer_t));
1208      server-&gt;header_buf          = ss_malloc(sizeof(buffer_t));
1209      server-&gt;fd                  = fd;
1210      server-&gt;recv_ctx-&gt;server    = server;
1211      server-&gt;recv_ctx-&gt;connected = 0;
1212      server-&gt;send_ctx-&gt;server    = server;
1213      server-&gt;send_ctx-&gt;connected = 0;
1214      server-&gt;stage               = STAGE_INIT;
1215      server-&gt;query               = NULL;
1216      server-&gt;listen_ctx          = listener;
1217      server-&gt;remote              = NULL;
1218      if (listener-&gt;method) {
1219          server-&gt;e_ctx = ss_malloc(sizeof(enc_ctx_t));
1220          server-&gt;d_ctx = ss_malloc(sizeof(enc_ctx_t));
1221          enc_ctx_init(listener-&gt;method, server-&gt;e_ctx, 1);
1222          enc_ctx_init(listener-&gt;method, server-&gt;d_ctx, 0);
1223      } else {
1224          server-&gt;e_ctx = NULL;
1225          server-&gt;d_ctx = NULL;
1226      }
1227      int request_timeout = min(MAX_REQUEST_TIMEOUT, listener-&gt;timeout)
1228                            + rand() % MAX_REQUEST_TIMEOUT;
1229      ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);
1230      ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);
1231      ev_timer_init(&amp;server-&gt;recv_ctx-&gt;watcher, server_timeout_cb,
1232                    request_timeout, listener-&gt;timeout);
1233      balloc(server-&gt;buf, BUF_SIZE);
1234      balloc(server-&gt;header_buf, BUF_SIZE);
1235      server-&gt;chunk = (chunk_t *)malloc(sizeof(chunk_t));
1236      memset(server-&gt;chunk, 0, sizeof(chunk_t));
1237      server-&gt;chunk-&gt;buf = ss_malloc(sizeof(buffer_t));
1238      memset(server-&gt;chunk-&gt;buf, 0, sizeof(buffer_t));
1239      cork_dllist_add(&amp;connections, &amp;server-&gt;entries);
1240      return server;
1241  }
1242  static void
1243  free_server(server_t *server)
1244  {
1245      cork_dllist_remove(&amp;server-&gt;entries);
1246      if (server-&gt;chunk != NULL) {
1247          if (server-&gt;chunk-&gt;buf != NULL) {
1248              bfree(server-&gt;chunk-&gt;buf);
1249              ss_free(server-&gt;chunk-&gt;buf);
1250          }
1251          ss_free(server-&gt;chunk);
1252      }
1253      if (server-&gt;remote != NULL) {
1254          server-&gt;remote-&gt;server = NULL;
1255      }
1256      if (server-&gt;e_ctx != NULL) {
1257          cipher_context_release(&amp;server-&gt;e_ctx-&gt;evp);
1258          ss_free(server-&gt;e_ctx);
1259      }
1260      if (server-&gt;d_ctx != NULL) {
1261          cipher_context_release(&amp;server-&gt;d_ctx-&gt;evp);
1262          ss_free(server-&gt;d_ctx);
1263      }
1264      if (server-&gt;buf != NULL) {
1265          bfree(server-&gt;buf);
1266          ss_free(server-&gt;buf);
1267      }
1268      if (server-&gt;header_buf != NULL) {
1269          bfree(server-&gt;header_buf);
1270          ss_free(server-&gt;header_buf);
1271      }
1272      ss_free(server-&gt;recv_ctx);
1273      ss_free(server-&gt;send_ctx);
1274      ss_free(server);
1275  }
1276  static void
1277  close_and_free_server(EV_P_ server_t *server)
1278  {
1279      if (server != NULL) {
1280          if (server-&gt;query != NULL) {
1281              resolv_cancel(server-&gt;query);
1282              server-&gt;query = NULL;
1283          }
1284          ev_io_stop(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1285          ev_io_stop(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1286          ev_timer_stop(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1287          close(server-&gt;fd);
1288          free_server(server);
1289          if (verbose) {
1290              server_conn--;
1291              LOGI(&quot;current server connection: %d&quot;, server_conn);
1292          }
1293      }
1294  }
1295  static void
1296  signal_cb(EV_P_ ev_signal *w, int revents)
1297  {
1298      if (revents &amp; EV_SIGNAL) {
1299          switch (w-&gt;signum) {
1300          case SIGINT:
1301          case SIGTERM:
1302              ev_unloop(EV_A_ EVUNLOOP_ALL);
1303          }
1304      }
1305  }
1306  static void
1307  accept_cb(EV_P_ ev_io *w, int revents)
1308  {
1309      listen_ctx_t *listener = (listen_ctx_t *)w;
1310      int serverfd           = accept(listener-&gt;fd, NULL, NULL);
1311      if (serverfd == -1) {
1312          ERROR(&quot;accept&quot;);
1313          return;
1314      }
1315      char *peer_name = get_peer_name(serverfd);
1316      if (peer_name != NULL) {
1317          int in_white_list = 0;
1318          if (acl) {
1319              if ((get_acl_mode() == BLACK_LIST &amp;&amp; acl_match_host(peer_name) == 1)
1320                  || (get_acl_mode() == WHITE_LIST &amp;&amp; acl_match_host(peer_name) &gt;= 0)) {
1321                  LOGE(&quot;Access denied from %s&quot;, peer_name);
1322                  close(serverfd);
1323                  return;
1324              } else if (acl_match_host(peer_name) == -1) {
1325                  in_white_list = 1;
1326              }
1327          }
1328          if (!in_white_list &amp;&amp; check_block_list(peer_name)) {
1329              LOGE(&quot;block all requests from %s&quot;, peer_name);
1330  #ifdef __linux__
1331              set_linger(serverfd);
1332  #endif
1333              close(serverfd);
1334              return;
1335          }
1336      }
1337      int opt = 1;
1338      setsockopt(serverfd, SOL_TCP, TCP_NODELAY, &amp;opt, sizeof(opt));
1339  #ifdef SO_NOSIGPIPE
1340      setsockopt(serverfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
1341  #endif
1342      setnonblocking(serverfd);
1343      if (verbose) {
1344          LOGI(&quot;accept a connection&quot;);
1345      }
1346      server_t *server = new_server(serverfd, listener);
1347      server-&gt;obfs_plugin = new_obfs_class(server-&gt;listen_ctx-&gt;obfs_name);
1348      if (server-&gt;obfs_plugin) {
1349          server-&gt;obfs = server-&gt;obfs_plugin-&gt;new_obfs();
1350          server-&gt;obfs_compatible_state = 0;
1351      }
1352      server-&gt;protocol_plugin = new_obfs_class(server-&gt;listen_ctx-&gt;protocol_name);
1353      if (server-&gt;protocol_plugin) {
1354          server-&gt;protocol = server-&gt;protocol_plugin-&gt;new_obfs();
1355          server-&gt;protocol_compatible_state = 0;
1356      }
1357      server_info _server_info;
1358      memset(&amp;_server_info, 0, sizeof(server_info));
1359      _server_info.param = server-&gt;listen_ctx-&gt;obfs_param;
1360      if(server-&gt;obfs_plugin)
1361          _server_info.g_data = server-&gt;obfs_plugin-&gt;init_data();
1362      _server_info.head_len = 7;
1363      _server_info.iv = server-&gt;e_ctx-&gt;evp.iv;
1364      _server_info.iv_len = enc_get_iv_len();
1365      _server_info.key = enc_get_key();
1366      _server_info.key_len = enc_get_key_len();
1367      _server_info.tcp_mss = 1460;
1368      if (server-&gt;obfs_plugin)
1369          server-&gt;obfs_plugin-&gt;set_server_info(server-&gt;obfs, &amp;_server_info);
1370      _server_info.param = server-&gt;listen_ctx-&gt;protocol_param;
1371      if (server-&gt;protocol_plugin)
1372          _server_info.g_data = server-&gt;protocol_plugin-&gt;init_data();
1373      if (server-&gt;protocol_plugin)
1374          server-&gt;protocol_plugin-&gt;set_server_info(server-&gt;protocol, &amp;_server_info);
1375      ev_io_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;io);
1376      ev_timer_start(EV_A_ &amp; server-&gt;recv_ctx-&gt;watcher);
1377  }
1378  int
1379  main(int argc, char **argv)
1380  {
1381      int i, c;
1382      int pid_flags   = 0;
1383      int mptcp       = 0;
1384      int firewall    = 0;
1385      int mtu         = 0;
1386      char *user      = NULL;
1387      char *password  = NULL;
1388      char *timeout   = NULL;
1389      char *protocol = NULL; 
1390      char *protocol_param = NULL; 
1391      char *method = NULL;
1392      char *obfs = NULL; 
1393      char *obfs_param = NULL; 
1394      char *pid_path  = NULL;
1395      char *conf_path = NULL;
1396      char *iface     = NULL;
1397      int server_num = 0;
1398      const char *server_host[MAX_REMOTE_NUM];
1399      char *nameservers[MAX_DNS_NUM + 1];
1400      int nameserver_num = 0;
1401      int option_index                    = 0;
1402      static struct option long_options[] = {
1403          { &quot;fast-open&quot;,       no_argument,       0, 0 },
1404          { &quot;acl&quot;,             required_argument, 0, 0 },
1405          { &quot;manager-address&quot;, required_argument, 0, 0 },
1406          { &quot;mtu&quot;,             required_argument, 0, 0 },
1407          { &quot;help&quot;,            no_argument,       0, 0 },
1408  #ifdef __linux__
1409          { &quot;mptcp&quot;,           no_argument,       0, 0 },
1410          { &quot;firewall&quot;,        no_argument,       0, 0 },
1411  #endif
1412          {                 0,                 0, 0, 0 }
1413      };
1414      opterr = 0;
1415      USE_TTY();
1416      while ((c = getopt_long(argc, argv, &quot;f:s:p:l:k:t:m:b:c:i:d:a:n:O:o:G:g:huUvA6&quot;,
1417                              long_options, &amp;option_index)) != -1) {
1418          switch (c) {
1419          case 0:
1420              if (option_index == 0) {
1421                  fast_open = 1;
1422              } else if (option_index == 1) {
1423                  LOGI(&quot;initializing acl...&quot;);
1424                  acl = !init_acl(optarg);
1425              } else if (option_index == 2) {
1426                  manager_address = optarg;
1427              } else if (option_index == 3) {
1428                  mtu = atoi(optarg);
1429                  LOGI(&quot;set MTU to %d&quot;, mtu);
1430              } else if (option_index == 4) {
1431                  usage();
1432                  exit(EXIT_SUCCESS);
1433              } else if (option_index == 5) {
1434                  mptcp = 1;
1435                  LOGI(&quot;enable multipath TCP&quot;);
1436              } else if (option_index == 6) {
1437                  firewall = 1;
1438                  LOGI(&quot;enable firewall rules&quot;);
1439              }
1440              break;
1441          case &#x27;s&#x27;:
1442              if (server_num &lt; MAX_REMOTE_NUM) {
1443                  server_host[server_num++] = optarg;
1444              }
1445              break;
1446          case &#x27;b&#x27;:
1447              bind_address = optarg;
1448              break;
1449          case &#x27;p&#x27;:
1450              server_port = optarg;
1451              break;
1452          case &#x27;k&#x27;:
1453              password = optarg;
1454              break;
1455          case &#x27;f&#x27;:
1456              pid_flags = 1;
1457              pid_path  = optarg;
1458              break;
1459          case &#x27;t&#x27;:
1460              timeout = optarg;
1461              break;
1462          case &#x27;O&#x27;:
1463              protocol = optarg;
1464              break;
1465          case &#x27;m&#x27;:
1466              method = optarg;
1467              break;
1468          case &#x27;o&#x27;:
1469              obfs = optarg;
1470              break;
1471          case &#x27;G&#x27;:
1472              protocol_param = optarg;
1473              break;
1474          case &#x27;g&#x27;:
1475              obfs_param = optarg;
1476              break;
1477          case &#x27;c&#x27;:
1478              conf_path = optarg;
1479              break;
1480          case &#x27;i&#x27;:
1481              iface = optarg;
1482              break;
1483          case &#x27;d&#x27;:
1484              if (nameserver_num &lt; MAX_DNS_NUM) {
1485                  nameservers[nameserver_num++] = optarg;
1486              }
1487              break;
1488          case &#x27;a&#x27;:
1489              user = optarg;
1490              break;
1491  #ifdef HAVE_SETRLIMIT
1492          case &#x27;n&#x27;:
1493              nofile = atoi(optarg);
1494              break;
1495  #endif
1496          case &#x27;u&#x27;:
1497              mode = TCP_AND_UDP;
1498              break;
1499          case &#x27;U&#x27;:
1500              mode = UDP_ONLY;
1501              break;
1502          case &#x27;v&#x27;:
1503              verbose = 1;
1504              break;
1505          case &#x27;h&#x27;:
1506              usage();
1507              exit(EXIT_SUCCESS);
1508          case &#x27;A&#x27;:
1509              auth = 1;
1510              break;
1511          case &#x27;6&#x27;:
1512              ipv6first = 1;
1513              break;
1514          case &#x27;?&#x27;:
1515              LOGE(&quot;Unrecognized option: %s&quot;, optarg);
1516              opterr = 1;
1517              break;
1518          }
1519      }
1520      if (opterr) {
1521          usage();
1522          exit(EXIT_FAILURE);
1523      }
1524      if (argc == 1) {
1525          if (conf_path == NULL) {
1526              conf_path = DEFAULT_CONF_PATH;
1527          }
1528      }
1529      if (conf_path != NULL) {
1530          jconf_t *conf = read_jconf(conf_path);
1531          if (server_num == 0) {
1532              server_num = conf-&gt;remote_num;
1533              for (i = 0; i &lt; server_num; i++)
1534                  server_host[i] = conf-&gt;remote_addr[i].host;
1535          }
1536          if (server_port == NULL) {
1537              server_port = conf-&gt;remote_port;
1538          }
1539          if (password == NULL) {
1540              password = conf-&gt;password;
1541          }
1542          if (protocol == NULL) {
1543              protocol = conf-&gt;protocol;
1544              LOGI(&quot;protocol %s&quot;, protocol);
1545          }
1546          if (protocol_param == NULL) {
1547              protocol_param = conf-&gt;protocol_param;
1548              LOGI(&quot;protocol_param %s&quot;, obfs_param);
1549          }
1550          if (method == NULL) {
1551              method = conf-&gt;method;
1552              LOGI(&quot;method %s&quot;, method);
1553          }
1554          if (obfs == NULL) {
1555              obfs = conf-&gt;obfs;
1556              LOGI(&quot;obfs %s&quot;, obfs);
1557          }
1558          if (obfs_param == NULL) {
1559              obfs_param = conf-&gt;obfs_param;
1560              LOGI(&quot;obfs_param %s&quot;, obfs_param);
1561          }
1562          if (timeout == NULL) {
1563              timeout = conf-&gt;timeout;
1564          }
1565          if (user == NULL) {
1566              user = conf-&gt;user;
1567          }
1568          if (auth == 0) {
1569              auth = conf-&gt;auth;
1570          }
1571          if (mode == TCP_ONLY) {
1572              mode = conf-&gt;mode;
1573          }
1574          if (mtu == 0) {
1575              mtu = conf-&gt;mtu;
1576          }
1577          if (mptcp == 0) {
1578              mptcp = conf-&gt;mptcp;
1579          }
1580  #ifdef TCP_FASTOPEN
1581          if (fast_open == 0) {
1582              fast_open = conf-&gt;fast_open;
1583          }
1584  #endif
1585  #ifdef HAVE_SETRLIMIT
1586          if (nofile == 0) {
1587              nofile = conf-&gt;nofile;
1588          }
1589  #endif
1590          if (conf-&gt;nameserver != NULL) {
1591              nameservers[nameserver_num++] = conf-&gt;nameserver;
1592          }
1593          if (ipv6first == 0) {
1594              ipv6first = conf-&gt;ipv6_first;
1595          }
1596      }
1597      if(strlen(protocol)&gt;11)
1598      {
1599          char *text;
1600          text = (char*)malloc(12);
1601          memcpy(text, protocol + strlen(protocol) - 11, 12);
1602          if(strcmp(text, &quot;_compatible&quot;) == 0)
1603          {
1604              free(text);
1605              text = (char*)malloc(strlen(protocol) - 11);
1606              memcpy(text, protocol, strlen(protocol) - 11);
1607              int length = strlen(protocol) - 11;
1608              free(protocol);
1609              obfs = (char*)malloc(length);
1610              memset(protocol, 0x00, length);
1611              memcpy(protocol, text, length);
1612              LOGI(&quot;protocol compatible enable, %s&quot;, protocol);
1613              free(text);
1614              protocol_compatible = 1;
1615          }
1616      }
1617      if(strlen(obfs)&gt;11)
1618      {
1619          char *text;
1620          text = (char*)malloc(12);
1621          memcpy(text, obfs + strlen(obfs) - 11, 12);
1622          if(strcmp(text, &quot;_compatible&quot;) == 0)
1623          {
1624              free(text);
1625              text = (char*)malloc(strlen(obfs) - 11);
1626              memcpy(text, obfs, strlen(obfs) - 11);
1627              int length = strlen(obfs) - 11;
1628              free(obfs);
1629              obfs = (char*)malloc(length);
1630              memset(obfs, 0x00, length);
1631              memcpy(obfs, text, length);
1632              LOGI(&quot;obfs compatible enable, %s&quot;, obfs);
1633              free(text);
1634              obfs_compatible = 1;
1635          }
1636      }
1637      if (server_num == 0) {
1638          server_host[server_num++] = NULL;
1639      }
1640      if (server_num == 0 || server_port == NULL || password == NULL) {
1641          usage();
1642          exit(EXIT_FAILURE);
1643      }
1644      if (protocol &amp;&amp; strcmp(protocol, &quot;verify_sha1&quot;) == 0) {
1645          auth = 1;
1646          protocol = NULL;
1647      }
1648      if (method == NULL) {
1649          method = &quot;rc4-md5&quot;;
1650      }
1651      if (timeout == NULL) {
1652          timeout = &quot;60&quot;;
1653      }
1654  #ifdef HAVE_SETRLIMIT
1655      if (nofile &gt; 1024) {
1656          if (verbose) {
1657              LOGI(&quot;setting NOFILE to %d&quot;, nofile);
1658          }
1659          set_nofile(nofile);
1660      }
1661  #endif
1662      if (pid_flags) {
1663          USE_SYSLOG(argv[0]);
1664          daemonize(pid_path);
1665      }
1666      if (ipv6first) {
1667          LOGI(&quot;resolving hostname to IPv6 address first&quot;);
1668      }
1669      if (fast_open == 1) {
1670  #ifdef TCP_FASTOPEN
1671          LOGI(&quot;using tcp fast open&quot;);
1672  #else
1673          LOGE(&quot;tcp fast open is not supported by this environment&quot;);
1674          fast_open = 0;
1675  #endif
1676      }
1677      if (auth) {
1678          LOGI(&quot;onetime authentication enabled&quot;);
1679      }
1680      if (mode != TCP_ONLY) {
1681          LOGI(&quot;UDP relay enabled&quot;);
1682      }
1683      if (mode == UDP_ONLY) {
1684          LOGI(&quot;TCP relay disabled&quot;);
1685      }
1686  #ifdef __MINGW32__
1687      winsock_init();
1688  #else
1689      signal(SIGPIPE, SIG_IGN);
1690      signal(SIGCHLD, SIG_IGN);
1691      signal(SIGABRT, SIG_IGN);
1692  #endif
1693      struct ev_signal sigint_watcher;
1694      struct ev_signal sigterm_watcher;
1695      ev_signal_init(&amp;sigint_watcher, signal_cb, SIGINT);
1696      ev_signal_init(&amp;sigterm_watcher, signal_cb, SIGTERM);
1697      ev_signal_start(EV_DEFAULT, &amp;sigint_watcher);
1698      ev_signal_start(EV_DEFAULT, &amp;sigterm_watcher);
1699      LOGI(&quot;initializing ciphers... %s&quot;, method);
1700      int m = enc_init(password, method);
1701      struct ev_loop *loop = EV_DEFAULT;
1702      if (nameserver_num == 0) {
1703  #ifdef __MINGW32__
1704          nameservers[nameserver_num++] = &quot;8.8.8.8&quot;;
1705          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1706  #else
1707          resolv_init(loop, NULL, 0, ipv6first);
1708  #endif
1709      } else {
1710          resolv_init(loop, nameservers, nameserver_num, ipv6first);
1711      }
1712      for (int i = 0; i &lt; nameserver_num; i++)
1713          LOGI(&quot;using nameserver: %s&quot;, nameservers[i]);
1714      listen_ctx_t listen_ctx_list[server_num];
1715      while (server_num &gt; 0) {
1716          int index        = --server_num;
1717          const char *host = server_host[index];
1718          if (mode != UDP_ONLY) {
1719              int listenfd;
1720              listenfd = create_and_bind(host, server_port, mptcp);
1721              if (listenfd == -1) {
1722                  FATAL(&quot;bind() error&quot;);
1723              }
1724              if (listen(listenfd, SSMAXCONN) == -1) {
1725                  FATAL(&quot;listen() error&quot;);
1726              }
1727              setfastopen(listenfd);
1728              setnonblocking(listenfd);
1729              listen_ctx_t *listen_ctx = &amp;listen_ctx_list[index];
1730              listen_ctx-&gt;timeout = atoi(timeout);
1731              listen_ctx-&gt;fd      = listenfd;
1732              listen_ctx-&gt;method  = m;
1733              listen_ctx-&gt;iface   = iface;
1734              listen_ctx-&gt;protocol_name = protocol;
1735              listen_ctx-&gt;protocol_param = protocol_param;
1736              listen_ctx-&gt;method = m;
1737              listen_ctx-&gt;obfs_name = obfs;
1738              listen_ctx-&gt;obfs_param = obfs_param;
1739              listen_ctx-&gt;list_protocol_global = malloc(sizeof(void *));
1740              listen_ctx-&gt;list_obfs_global = malloc(sizeof(void *));
1741              memset(listen_ctx-&gt;list_protocol_global, 0, sizeof(void *));
1742              memset(listen_ctx-&gt;list_obfs_global, 0, sizeof(void *));
1743              listen_ctx-&gt;loop    = loop;
1744              ev_io_init(&amp;listen_ctx-&gt;io, accept_cb, listenfd, EV_READ);
1745              ev_io_start(loop, &amp;listen_ctx-&gt;io);
1746          }
1747          if (mode != TCP_ONLY) {
1748              init_udprelay(server_host[index], server_port, mtu, m,
1749                            auth, atoi(timeout), iface, protocol, protocol_param);
1750          }
1751          if (host &amp;&amp; strcmp(host, &quot;:&quot;) &gt; 0)
1752              LOGI(&quot;listening at [%s]:%s&quot;, host, server_port);
1753          else
1754              LOGI(&quot;listening at %s:%s&quot;, host ? host : &quot;*&quot;, server_port);
1755      }
1756      if (manager_address != NULL) {
1757          ev_timer_init(&amp;stat_update_watcher, stat_update_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1758          ev_timer_start(EV_DEFAULT, &amp;stat_update_watcher);
1759      }
1760      ev_timer_init(&amp;block_list_watcher, block_list_clear_cb, UPDATE_INTERVAL, UPDATE_INTERVAL);
1761      ev_timer_start(EV_DEFAULT, &amp;block_list_watcher);
1762      if (user != NULL &amp;&amp; ! run_as(user)) {
1763          FATAL(&quot;failed to switch user&quot;);
1764      }
1765  #ifndef __MINGW32__
1766      if (geteuid() == 0){
1767          LOGI(&quot;running from root user&quot;);
1768      } else if (firewall) {
1769          LOGE(&quot;firewall setup requires running from root user&quot;);
1770          exit(-1);
1771      }
1772  #endif
1773      init_block_list(firewall);
1774      cork_dllist_init(&amp;connections);
1775      ev_run(loop, 0);
1776      if (verbose) {
1777          LOGI(&quot;closed gracefully&quot;);
1778      }
1779      free_block_list();
1780      if (manager_address != NULL) {
1781          ev_timer_stop(EV_DEFAULT, &amp;stat_update_watcher);
1782      }
1783      ev_timer_stop(EV_DEFAULT, &amp;block_list_watcher);
1784      for (int i = 0; i &lt;= server_num; i++) {
1785          listen_ctx_t *listen_ctx = &amp;listen_ctx_list[i];
1786          if (mode != UDP_ONLY) {
1787              ev_io_stop(loop, &amp;listen_ctx-&gt;io);
1788              close(listen_ctx-&gt;fd);
1789          }
1790      }
1791      if (mode != UDP_ONLY) {
1792          free_connections(loop);
1793      }
1794      if (mode != TCP_ONLY) {
1795          free_udprelay();
1796      }
1797      resolv_shutdown(loop);
1798  #ifdef __MINGW32__
1799      winsock_cleanup();
1800  #endif
1801      ev_signal_stop(EV_DEFAULT, &amp;sigint_watcher);
1802      ev_signal_stop(EV_DEFAULT, &amp;sigterm_watcher);
1803      return 0;
1804  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-server.c</div>
                </div>
                <div class="column column_space"><pre><code>673              remote-&gt;buf-&gt;len -= s;
674              remote-&gt;buf-&gt;idx  = s;
675              ev_io_stop(EV_A_ &amp; server_recv_ctx-&gt;io);
676              ev_io_start(EV_A_ &amp; remote-&gt;send_ctx-&gt;io);
677          }
678          return;
</pre></code></div>
                <div class="column column_space"><pre><code>1058          server-&gt;buf-&gt;len -= s;
1059          server-&gt;buf-&gt;idx  = s;
1060          ev_io_stop(EV_A_ &amp; remote_recv_ctx-&gt;io);
1061          ev_io_start(EV_A_ &amp; server-&gt;send_ctx-&gt;io);
1062      }
1063      if (!remote-&gt;recv_ctx-&gt;connected) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    