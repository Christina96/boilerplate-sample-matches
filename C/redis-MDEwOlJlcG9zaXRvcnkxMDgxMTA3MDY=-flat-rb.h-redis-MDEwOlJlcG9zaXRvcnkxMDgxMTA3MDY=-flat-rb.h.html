
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.h</h3>
            <pre><code>1  #ifndef RB_H_
2  #define RB_H_
3  #ifndef __PGI
4  #define RB_COMPACT
5  #endif
6  #ifdef RB_COMPACT
7  #define rb_node(a_type)							\
8  struct {								\
9      a_type *rbn_left;							\
10      a_type *rbn_right_red;						\
11  }
12  #else
13  #define rb_node(a_type)							\
14  struct {								\
15      a_type *rbn_left;							\
16      a_type *rbn_right;							\
17      bool rbn_red;							\
18  }
19  #endif
20  #define rb_tree(a_type)							\
21  struct {								\
22      a_type *rbt_root;							\
23  }
24  #define rbtn_left_get(a_type, a_field, a_node)				\
25      ((a_node)->a_field.rbn_left)
26  #define rbtn_left_set(a_type, a_field, a_node, a_left) do {		\
27      (a_node)->a_field.rbn_left = a_left;				\
28  } while (0)
29  #ifdef RB_COMPACT
30  #define rbtn_right_get(a_type, a_field, a_node)				\
31      ((a_type *) (((intptr_t) (a_node)->a_field.rbn_right_red)		\
32        & ((ssize_t)-2)))
33  #define rbtn_right_set(a_type, a_field, a_node, a_right) do {		\
34      (a_node)->a_field.rbn_right_red = (a_type *) (((uintptr_t) a_right)	\
35        | (((uintptr_t) (a_node)->a_field.rbn_right_red) & ((size_t)1)));	\
36  } while (0)
37  #define rbtn_red_get(a_type, a_field, a_node)				\
38      ((bool) (((uintptr_t) (a_node)->a_field.rbn_right_red)		\
39        & ((size_t)1)))
40  #define rbtn_color_set(a_type, a_field, a_node, a_red) do {		\
41      (a_node)->a_field.rbn_right_red = (a_type *) ((((intptr_t)		\
42        (a_node)->a_field.rbn_right_red) & ((ssize_t)-2))			\
43        | ((ssize_t)a_red));						\
44  } while (0)
45  #define rbtn_red_set(a_type, a_field, a_node) do {			\
46      (a_node)->a_field.rbn_right_red = (a_type *) (((uintptr_t)		\
47        (a_node)->a_field.rbn_right_red) | ((size_t)1));			\
48  } while (0)
49  #define rbtn_black_set(a_type, a_field, a_node) do {			\
50      (a_node)->a_field.rbn_right_red = (a_type *) (((intptr_t)		\
51        (a_node)->a_field.rbn_right_red) & ((ssize_t)-2));		\
52  } while (0)
53  #define rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
54      		\
55      assert(((uintptr_t)(a_node) & 0x1) == 0);				\
56      rbtn_left_set(a_type, a_field, (a_node), NULL);	\
57      rbtn_right_set(a_type, a_field, (a_node), NULL);	\
58      rbtn_red_set(a_type, a_field, (a_node));				\
59  } while (0)
60  #else
61  #define rbtn_right_get(a_type, a_field, a_node)				\
62      ((a_node)->a_field.rbn_right)
63  #define rbtn_right_set(a_type, a_field, a_node, a_right) do {		\
64      (a_node)->a_field.rbn_right = a_right;				\
65  } while (0)
66  #define rbtn_red_get(a_type, a_field, a_node)				\
67      ((a_node)->a_field.rbn_red)
68  #define rbtn_color_set(a_type, a_field, a_node, a_red) do {		\
69      (a_node)->a_field.rbn_red = (a_red);				\
70  } while (0)
71  #define rbtn_red_set(a_type, a_field, a_node) do {			\
72      (a_node)->a_field.rbn_red = true;					\
73  } while (0)
74  #define rbtn_black_set(a_type, a_field, a_node) do {			\
75      (a_node)->a_field.rbn_red = false;					\
76  } while (0)
77  #define rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
78      rbtn_left_set(a_type, a_field, (a_node), NULL);	\
79      rbtn_right_set(a_type, a_field, (a_node), NULL);	\
80      rbtn_red_set(a_type, a_field, (a_node));				\
81  } while (0)
82  #endif
83  #define rb_new(a_type, a_field, a_rbt) do {				\
84      (a_rbt)->rbt_root = NULL;						\
85  } while (0)
86  #define rbtn_first(a_type, a_field, a_rbt, a_root, r_node) do {		\
87      (r_node) = (a_root);						\
88      if ((r_node) != NULL) {						\
89  	for (;								\
90  	  rbtn_left_get(a_type, a_field, (r_node)) != NULL;		\
91  	  (r_node) = rbtn_left_get(a_type, a_field, (r_node))) {	\
92  	}								\
93      }									\
94  } while (0)
95  #define rbtn_last(a_type, a_field, a_rbt, a_root, r_node) do {		\
96      (r_node) = (a_root);						\
97      if ((r_node) != NULL) {						\
98  	for (; rbtn_right_get(a_type, a_field, (r_node)) != NULL;	\
99  	  (r_node) = rbtn_right_get(a_type, a_field, (r_node))) {	\
100  	}								\
101      }									\
102  } while (0)
103  #define rbtn_rotate_left(a_type, a_field, a_node, r_node) do {		\
104      (r_node) = rbtn_right_get(a_type, a_field, (a_node));		\
105      rbtn_right_set(a_type, a_field, (a_node),				\
106        rbtn_left_get(a_type, a_field, (r_node)));			\
107      rbtn_left_set(a_type, a_field, (r_node), (a_node));			\
108  } while (0)
109  #define rbtn_rotate_right(a_type, a_field, a_node, r_node) do {		\
110      (r_node) = rbtn_left_get(a_type, a_field, (a_node));		\
111      rbtn_left_set(a_type, a_field, (a_node),				\
112        rbtn_right_get(a_type, a_field, (r_node)));			\
113      rbtn_right_set(a_type, a_field, (r_node), (a_node));		\
114  } while (0)
115  #define rb_proto(a_attr, a_prefix, a_rbt_type, a_type)			\
116  a_attr void								\
117  a_prefix##new(a_rbt_type *rbtree);					\
118  a_attr bool								\
119  a_prefix##empty(a_rbt_type *rbtree);					\
120  a_attr a_type *								\
121  a_prefix##first(a_rbt_type *rbtree);					\
122  a_attr a_type *								\
123  a_prefix##last(a_rbt_type *rbtree);					\
124  a_attr a_type *								\
125  a_prefix##next(a_rbt_type *rbtree, a_type *node);			\
126  a_attr a_type *								\
127  a_prefix##prev(a_rbt_type *rbtree, a_type *node);			\
128  a_attr a_type *								\
129  a_prefix##search(a_rbt_type *rbtree, const a_type *key);		\
130  a_attr a_type *								\
131  a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key);		\
132  a_attr a_type *								\
133  a_prefix##psearch(a_rbt_type *rbtree, const a_type *key);		\
134  a_attr void								\
135  a_prefix##insert(a_rbt_type *rbtree, a_type *node);			\
136  a_attr void								\
137  a_prefix##remove(a_rbt_type *rbtree, a_type *node);			\
138  a_attr a_type *								\
139  a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\
140    a_rbt_type *, a_type *, void *), void *arg);				\
141  a_attr a_type *								\
142  a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\
143    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);		\
144  a_attr void								\
145  a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
146    void *arg);
147  #define rb_gen(a_attr, a_prefix, a_rbt_type, a_type, a_field, a_cmp)	\
148  a_attr void								\
149  a_prefix##new(a_rbt_type *rbtree) {					\
150      rb_new(a_type, a_field, rbtree);					\
151  }									\
152  a_attr bool								\
153  a_prefix##empty(a_rbt_type *rbtree) {					\
154      return (rbtree->rbt_root == NULL);					\
155  }									\
156  a_attr a_type *								\
157  a_prefix##first(a_rbt_type *rbtree) {					\
158      a_type *ret;							\
159      rbtn_first(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
160      return ret;								\
161  }									\
162  a_attr a_type *								\
163  a_prefix##last(a_rbt_type *rbtree) {					\
164      a_type *ret;							\
165      rbtn_last(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
166      return ret;								\
167  }									\
168  a_attr a_type *								\
169  a_prefix##next(a_rbt_type *rbtree, a_type *node) {			\
170      a_type *ret;							\
171      if (rbtn_right_get(a_type, a_field, node) != NULL) {		\
172  	rbtn_first(a_type, a_field, rbtree, rbtn_right_get(a_type,	\
173  	  a_field, node), ret);						\
174      } else {								\
175  	a_type *tnode = rbtree->rbt_root;				\
176  	assert(tnode != NULL);						\
177  	ret = NULL;							\
178  	while (true) {							\
179  	    int cmp = (a_cmp)(node, tnode);				\
180  	    if (cmp < 0) {						\
181  		ret = tnode;						\
182  		tnode = rbtn_left_get(a_type, a_field, tnode);		\
183  	    } else if (cmp > 0) {					\
184  		tnode = rbtn_right_get(a_type, a_field, tnode);		\
185  	    } else {							\
186  		break;							\
187  	    }								\
188  	    assert(tnode != NULL);					\
189  	}								\
190      }									\
191      return ret;								\
192  }									\
193  a_attr a_type *								\
194  a_prefix##prev(a_rbt_type *rbtree, a_type *node) {			\
195      a_type *ret;							\
196      if (rbtn_left_get(a_type, a_field, node) != NULL) {			\
197  	rbtn_last(a_type, a_field, rbtree, rbtn_left_get(a_type,	\
198  	  a_field, node), ret);						\
199      } else {								\
200  	a_type *tnode = rbtree->rbt_root;				\
201  	assert(tnode != NULL);						\
202  	ret = NULL;							\
203  	while (true) {							\
204  	    int cmp = (a_cmp)(node, tnode);				\
205  	    if (cmp < 0) {						\
206  		tnode = rbtn_left_get(a_type, a_field, tnode);		\
207  	    } else if (cmp > 0) {					\
208  		ret = tnode;						\
209  		tnode = rbtn_right_get(a_type, a_field, tnode);		\
210  	    } else {							\
211  		break;							\
212  	    }								\
213  	    assert(tnode != NULL);					\
214  	}								\
215      }									\
216      return ret;								\
217  }									\
218  a_attr a_type *								\
219  a_prefix##search(a_rbt_type *rbtree, const a_type *key) {		\
220      a_type *ret;							\
221      int cmp;								\
222      ret = rbtree->rbt_root;						\
223      while (ret != NULL							\
224        && (cmp = (a_cmp)(key, ret)) != 0) {				\
225  	if (cmp < 0) {							\
226  	    ret = rbtn_left_get(a_type, a_field, ret);			\
227  	} else {							\
228  	    ret = rbtn_right_get(a_type, a_field, ret);			\
229  	}								\
230      }									\
231      return ret;								\
232  }									\
233  a_attr a_type *								\
234  a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key) {		\
235      a_type *ret;							\
236      a_type *tnode = rbtree->rbt_root;					\
237      ret = NULL;								\
238      while (tnode != NULL) {						\
239  	int cmp = (a_cmp)(key, tnode);					\
240  	if (cmp < 0) {							\
241  	    ret = tnode;						\
242  	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
243  	} else if (cmp > 0) {						\
244  	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
245  	} else {							\
246  	    ret = tnode;						\
247  	    break;							\
248  	}								\
249      }									\
250      return ret;								\
251  }									\
252  a_attr a_type *								\
253  a_prefix##psearch(a_rbt_type *rbtree, const a_type *key) {		\
254      a_type *ret;							\
255      a_type *tnode = rbtree->rbt_root;					\
256      ret = NULL;								\
257      while (tnode != NULL) {						\
258  	int cmp = (a_cmp)(key, tnode);					\
259  	if (cmp < 0) {							\
260  	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
261  	} else if (cmp > 0) {						\
262  	    ret = tnode;						\
263  	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
264  	} else {							\
265  	    ret = tnode;						\
266  	    break;							\
267  	}								\
268      }									\
269      return ret;								\
270  }									\
271  a_attr void								\
272  a_prefix##insert(a_rbt_type *rbtree, a_type *node) {			\
273      struct {								\
274  	a_type *node;							\
275  	int cmp;							\
276      } path[sizeof(void *) << 4], *pathp;				\
277      rbt_node_new(a_type, a_field, rbtree, node);			\
278      								\
279      path->node = rbtree->rbt_root;					\
280      for (pathp = path; pathp->node != NULL; pathp++) {			\
281  	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
282  	assert(cmp != 0);						\
283  	if (cmp < 0) {							\
284  	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
285  	      pathp->node);						\
286  	} else {							\
287  	    pathp[1].node = rbtn_right_get(a_type, a_field,		\
288  	      pathp->node);						\
289  	}								\
290      }									\
291      pathp->node = node;							\
292      							\
293      for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
294  	a_type *cnode = pathp->node;					\
295  	if (pathp->cmp < 0) {						\
296  	    a_type *left = pathp[1].node;				\
297  	    rbtn_left_set(a_type, a_field, cnode, left);		\
298  	    if (rbtn_red_get(a_type, a_field, left)) {			\
299  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
300  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
301  		  leftleft)) {						\
302  		    				\
303  		    a_type *tnode;					\
304  		    rbtn_black_set(a_type, a_field, leftleft);		\
305  		    rbtn_rotate_right(a_type, a_field, cnode, tnode);	\
306  		    cnode = tnode;					\
307  		}							\
308  	    } else {							\
309  		return;							\
310  	    }								\
311  	} else {							\
312  	    a_type *right = pathp[1].node;				\
313  	    rbtn_right_set(a_type, a_field, cnode, right);		\
314  	    if (rbtn_red_get(a_type, a_field, right)) {			\
315  		a_type *left = rbtn_left_get(a_type, a_field, cnode);	\
316  		if (left != NULL && rbtn_red_get(a_type, a_field,	\
317  		  left)) {						\
318  		    					\
319  		    rbtn_black_set(a_type, a_field, left);		\
320  		    rbtn_black_set(a_type, a_field, right);		\
321  		    rbtn_red_set(a_type, a_field, cnode);		\
322  		} else {						\
323  		    					\
324  		    a_type *tnode;					\
325  		    bool tred = rbtn_red_get(a_type, a_field, cnode);	\
326  		    rbtn_rotate_left(a_type, a_field, cnode, tnode);	\
327  		    rbtn_color_set(a_type, a_field, tnode, tred);	\
328  		    rbtn_red_set(a_type, a_field, cnode);		\
329  		    cnode = tnode;					\
330  		}							\
331  	    } else {							\
332  		return;							\
333  	    }								\
334  	}								\
335  	pathp->node = cnode;						\
336      }									\
337      					\
338      rbtree->rbt_root = path->node;					\
339      rbtn_black_set(a_type, a_field, rbtree->rbt_root);			\
340  }									\
341  a_attr void								\
342  a_prefix##remove(a_rbt_type *rbtree, a_type *node) {			\
343      struct {								\
344  	a_type *node;							\
345  	int cmp;							\
346      } *pathp, *nodep, path[sizeof(void *) << 4];			\
347      								\
348      nodep = NULL; &bsol;* Silence compiler warning. */			\
349      path->node = rbtree->rbt_root;					\
350      for (pathp = path; pathp->node != NULL; pathp++) {			\
351  	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
352  	if (cmp < 0) {							\
353  	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
354  	      pathp->node);						\
355  	} else {							\
356  	    pathp[1].node = rbtn_right_get(a_type, a_field,		\
357  	      pathp->node);						\
358  	    if (cmp == 0) {						\
359  	        	\
360  		pathp->cmp = 1;						\
361  		nodep = pathp;						\
362  		for (pathp++; pathp->node != NULL; pathp++) {		\
363  		    pathp->cmp = -1;					\
364  		    pathp[1].node = rbtn_left_get(a_type, a_field,	\
365  		      pathp->node);					\
366  		}							\
367  		break;							\
368  	    }								\
369  	}								\
370      }									\
371      assert(nodep->node == node);					\
372      pathp--;								\
373      if (pathp->node != node) {						\
374  					\
375  	bool tred = rbtn_red_get(a_type, a_field, pathp->node);		\
376  	rbtn_color_set(a_type, a_field, pathp->node,			\
377  	  rbtn_red_get(a_type, a_field, node));				\
378  	rbtn_left_set(a_type, a_field, pathp->node,			\
379  	  rbtn_left_get(a_type, a_field, node));			\
380  	\
381  	\
382  	\
383  	\
384  	rbtn_right_set(a_type, a_field, pathp->node,			\
385  	  rbtn_right_get(a_type, a_field, node));			\
386  	rbtn_color_set(a_type, a_field, node, tred);			\
387  	\
388  	\
389  	nodep->node = pathp->node;					\
390  	pathp->node = node;						\
391  	if (nodep == path) {						\
392  	    rbtree->rbt_root = nodep->node;				\
393  	} else {							\
394  	    if (nodep[-1].cmp < 0) {					\
395  		rbtn_left_set(a_type, a_field, nodep[-1].node,		\
396  		  nodep->node);						\
397  	    } else {							\
398  		rbtn_right_set(a_type, a_field, nodep[-1].node,		\
399  		  nodep->node);						\
400  	    }								\
401  	}								\
402      } else {								\
403  	a_type *left = rbtn_left_get(a_type, a_field, node);		\
404  	if (left != NULL) {						\
405  	    \
406  	    \
407  	    assert(!rbtn_red_get(a_type, a_field, node));		\
408  	    assert(rbtn_red_get(a_type, a_field, left));		\
409  	    rbtn_black_set(a_type, a_field, left);			\
410  	    if (pathp == path) {					\
411  		rbtree->rbt_root = left;				\
412  	    } else {							\
413  		if (pathp[-1].cmp < 0) {				\
414  		    rbtn_left_set(a_type, a_field, pathp[-1].node,	\
415  		      left);						\
416  		} else {						\
417  		    rbtn_right_set(a_type, a_field, pathp[-1].node,	\
418  		      left);						\
419  		}							\
420  	    }								\
421  	    return;							\
422  	} else if (pathp == path) {					\
423  	    			\
424  	    rbtree->rbt_root = NULL;					\
425  	    return;							\
426  	}								\
427      }									\
428      if (rbtn_red_get(a_type, a_field, pathp->node)) {			\
429  				\
430  	assert(pathp[-1].cmp < 0);					\
431  	rbtn_left_set(a_type, a_field, pathp[-1].node, NULL);		\
432  	return;								\
433      }									\
434      \
435      \
436      pathp->node = NULL;							\
437      for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
438  	assert(pathp->cmp != 0);					\
439  	if (pathp->cmp < 0) {						\
440  	    rbtn_left_set(a_type, a_field, pathp->node,			\
441  	      pathp[1].node);						\
442  	    if (rbtn_red_get(a_type, a_field, pathp->node)) {		\
443  		a_type *right = rbtn_right_get(a_type, a_field,		\
444  		  pathp->node);						\
445  		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
446  		  right);						\
447  		a_type *tnode;						\
448  		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
449  		  rightleft)) {						\
450  		    \
451  		    \
452  		    \
453  		    \
454  		    \
455  		    \
456  		    \
457  		    \
458  		    \
459  		    \
460  		    rbtn_black_set(a_type, a_field, pathp->node);	\
461  		    rbtn_rotate_right(a_type, a_field, right, tnode);	\
462  		    rbtn_right_set(a_type, a_field, pathp->node, tnode);\
463  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
464  		      tnode);						\
465  		} else {						\
466  		    \
467  		    \
468  		    \
469  		    \
470  		    \
471  		    \
472  		    \
473  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
474  		      tnode);						\
475  		}							\
476  		\
477  		\
478  		assert((uintptr_t)pathp > (uintptr_t)path);		\
479  		if (pathp[-1].cmp < 0) {				\
480  		    rbtn_left_set(a_type, a_field, pathp[-1].node,	\
481  		      tnode);						\
482  		} else {						\
483  		    rbtn_right_set(a_type, a_field, pathp[-1].node,	\
484  		      tnode);						\
485  		}							\
486  		return;							\
487  	    } else {							\
488  		a_type *right = rbtn_right_get(a_type, a_field,		\
489  		  pathp->node);						\
490  		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
491  		  right);						\
492  		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
493  		  rightleft)) {						\
494  		    \
495  		    \
496  		    \
497  		    \
498  		    \
499  		    \
500  		    a_type *tnode;					\
501  		    rbtn_black_set(a_type, a_field, rightleft);		\
502  		    rbtn_rotate_right(a_type, a_field, right, tnode);	\
503  		    rbtn_right_set(a_type, a_field, pathp->node, tnode);\
504  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
505  		      tnode);						\
506  		    \
507  		    \
508  		    \
509  		    if (pathp == path) {				\
510  								\
511  			rbtree->rbt_root = tnode;			\
512  		    } else {						\
513  			if (pathp[-1].cmp < 0) {			\
514  			    rbtn_left_set(a_type, a_field,		\
515  			      pathp[-1].node, tnode);			\
516  			} else {					\
517  			    rbtn_right_set(a_type, a_field,		\
518  			      pathp[-1].node, tnode);			\
519  			}						\
520  		    }							\
521  		    return;						\
522  		} else {						\
523  		    \
524  		    \
525  		    \
526  		    \
527  		    \
528  		    \
529  		    a_type *tnode;					\
530  		    rbtn_red_set(a_type, a_field, pathp->node);		\
531  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
532  		      tnode);						\
533  		    pathp->node = tnode;				\
534  		}							\
535  	    }								\
536  	} else {							\
537  	    a_type *left;						\
538  	    rbtn_right_set(a_type, a_field, pathp->node,		\
539  	      pathp[1].node);						\
540  	    left = rbtn_left_get(a_type, a_field, pathp->node);		\
541  	    if (rbtn_red_get(a_type, a_field, left)) {			\
542  		a_type *tnode;						\
543  		a_type *leftright = rbtn_right_get(a_type, a_field,	\
544  		  left);						\
545  		a_type *leftrightleft = rbtn_left_get(a_type, a_field,	\
546  		  leftright);						\
547  		if (leftrightleft != NULL && rbtn_red_get(a_type,	\
548  		  a_field, leftrightleft)) {				\
549  		    \
550  		    \
551  		    \
552  		    \
553  		    \
554  		    \
555  		    \
556  		    \
557  		    a_type *unode;					\
558  		    rbtn_black_set(a_type, a_field, leftrightleft);	\
559  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
560  		      unode);						\
561  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
562  		      tnode);						\
563  		    rbtn_right_set(a_type, a_field, unode, tnode);	\
564  		    rbtn_rotate_left(a_type, a_field, unode, tnode);	\
565  		} else {						\
566  		    \
567  		    \
568  		    \
569  		    \
570  		    \
571  		    \
572  		    \
573  		    \
574  		    assert(leftright != NULL);				\
575  		    rbtn_red_set(a_type, a_field, leftright);		\
576  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
577  		      tnode);						\
578  		    rbtn_black_set(a_type, a_field, tnode);		\
579  		}							\
580  		\
581  		\
582  		if (pathp == path) {					\
583  		    					\
584  		    rbtree->rbt_root = tnode;				\
585  		} else {						\
586  		    if (pathp[-1].cmp < 0) {				\
587  			rbtn_left_set(a_type, a_field, pathp[-1].node,	\
588  			  tnode);					\
589  		    } else {						\
590  			rbtn_right_set(a_type, a_field, pathp[-1].node,	\
591  			  tnode);					\
592  		    }							\
593  		}							\
594  		return;							\
595  	    } else if (rbtn_red_get(a_type, a_field, pathp->node)) {	\
596  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
597  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
598  		  leftleft)) {						\
599  		    \
600  		    \
601  		    \
602  		    \
603  		    \
604  		    \
605  		    a_type *tnode;					\
606  		    rbtn_black_set(a_type, a_field, pathp->node);	\
607  		    rbtn_red_set(a_type, a_field, left);		\
608  		    rbtn_black_set(a_type, a_field, leftleft);		\
609  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
610  		      tnode);						\
611  		    \
612  		    \
613  		    assert((uintptr_t)pathp > (uintptr_t)path);		\
614  		    if (pathp[-1].cmp < 0) {				\
615  			rbtn_left_set(a_type, a_field, pathp[-1].node,	\
616  			  tnode);					\
617  		    } else {						\
618  			rbtn_right_set(a_type, a_field, pathp[-1].node,	\
619  			  tnode);					\
620  		    }							\
621  		    return;						\
622  		} else {						\
623  		    \
624  		    \
625  		    \
626  		    \
627  		    \
628  		    \
629  		    rbtn_red_set(a_type, a_field, left);		\
630  		    rbtn_black_set(a_type, a_field, pathp->node);	\
631  		    				\
632  		    return;						\
633  		}							\
634  	    } else {							\
635  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
636  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
637  		  leftleft)) {						\
638  		    \
639  		    \
640  		    \
641  		    \
642  		    \
643  		    \
644  		    a_type *tnode;					\
645  		    rbtn_black_set(a_type, a_field, leftleft);		\
646  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
647  		      tnode);						\
648  		    \
649  		    \
650  		    \
651  		    if (pathp == path) {				\
652  								\
653  			rbtree->rbt_root = tnode;			\
654  		    } else {						\
655  			if (pathp[-1].cmp < 0) {			\
656  			    rbtn_left_set(a_type, a_field,		\
657  			      pathp[-1].node, tnode);			\
658  			} else {					\
659  			    rbtn_right_set(a_type, a_field,		\
660  			      pathp[-1].node, tnode);			\
661  			}						\
662  		    }							\
663  		    return;						\
664  		} else {						\
665  		    \
666  		    \
667  		    \
668  		    \
669  		    \
670  		    \
671  		    rbtn_red_set(a_type, a_field, left);		\
672  		}							\
673  	    }								\
674  	}								\
675      }									\
676      							\
677      rbtree->rbt_root = path->node;					\
678      assert(!rbtn_red_get(a_type, a_field, rbtree->rbt_root));		\
679  }									\
680  a_attr a_type *								\
681  a_prefix##iter_recurse(a_rbt_type *rbtree, a_type *node,		\
682    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
683      if (node == NULL) {							\
684  	return NULL;							\
685      } else {								\
686  	a_type *ret;							\
687  	if ((ret = a_prefix##iter_recurse(rbtree, rbtn_left_get(a_type,	\
688  	  a_field, node), cb, arg)) != NULL || (ret = cb(rbtree, node,	\
689  	  arg)) != NULL) {						\
690  	    return ret;							\
691  	}								\
692  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
693  	  a_field, node), cb, arg);					\
694      }									\
695  }									\
696  a_attr a_type *								\
697  a_prefix##iter_start(a_rbt_type *rbtree, a_type *start, a_type *node,	\
698    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
699      int cmp = a_cmp(start, node);					\
700      if (cmp < 0) {							\
701  	a_type *ret;							\
702  	if ((ret = a_prefix##iter_start(rbtree, start,			\
703  	  rbtn_left_get(a_type, a_field, node), cb, arg)) != NULL ||	\
704  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
705  	    return ret;							\
706  	}								\
707  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
708  	  a_field, node), cb, arg);					\
709      } else if (cmp > 0) {						\
710  	return a_prefix##iter_start(rbtree, start,			\
711  	  rbtn_right_get(a_type, a_field, node), cb, arg);		\
712      } else {								\
713  	a_type *ret;							\
714  	if ((ret = cb(rbtree, node, arg)) != NULL) {			\
715  	    return ret;							\
716  	}								\
717  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
718  	  a_field, node), cb, arg);					\
719      }									\
720  }									\
721  a_attr a_type *								\
722  a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\
723    a_rbt_type *, a_type *, void *), void *arg) {				\
724      a_type *ret;							\
725      if (start != NULL) {						\
726  	ret = a_prefix##iter_start(rbtree, start, rbtree->rbt_root,	\
727  	  cb, arg);							\
728      } else {								\
729  	ret = a_prefix##iter_recurse(rbtree, rbtree->rbt_root, cb, arg);\
730      }									\
731      return ret;								\
732  }									\
733  a_attr a_type *								\
734  a_prefix##reverse_iter_recurse(a_rbt_type *rbtree, a_type *node,	\
735    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
736      if (node == NULL) {							\
737  	return NULL;							\
738      } else {								\
739  	a_type *ret;							\
740  	if ((ret = a_prefix##reverse_iter_recurse(rbtree,		\
741  	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
742  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
743  	    return ret;							\
744  	}								\
745  	return a_prefix##reverse_iter_recurse(rbtree,			\
746  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
747      }									\
748  }									\
749  a_attr a_type *								\
750  a_prefix##reverse_iter_start(a_rbt_type *rbtree, a_type *start,		\
751    a_type *node, a_type *(*cb)(a_rbt_type *, a_type *, void *),		\
752    void *arg) {								\
753      int cmp = a_cmp(start, node);					\
754      if (cmp > 0) {							\
755  	a_type *ret;							\
756  	if ((ret = a_prefix##reverse_iter_start(rbtree, start,		\
757  	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
758  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
759  	    return ret;							\
760  	}								\
761  	return a_prefix##reverse_iter_recurse(rbtree,			\
762  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
763      } else if (cmp < 0) {						\
764  	return a_prefix##reverse_iter_start(rbtree, start,		\
765  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
766      } else {								\
767  	a_type *ret;							\
768  	if ((ret = cb(rbtree, node, arg)) != NULL) {			\
769  	    return ret;							\
770  	}								\
771  	return a_prefix##reverse_iter_recurse(rbtree,			\
772  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
773      }									\
774  }									\
775  a_attr a_type *								\
776  a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\
777    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
778      a_type *ret;							\
779      if (start != NULL) {						\
780  	ret = a_prefix##reverse_iter_start(rbtree, start,		\
781  	  rbtree->rbt_root, cb, arg);					\
782      } else {								\
783  	ret = a_prefix##reverse_iter_recurse(rbtree, rbtree->rbt_root,	\
784  	  cb, arg);							\
785      }									\
786      return ret;								\
787  }									\
788  a_attr void								\
789  a_prefix##destroy_recurse(a_rbt_type *rbtree, a_type *node, void (*cb)(	\
790    a_type *, void *), void *arg) {					\
791      if (node == NULL) {							\
792  	return;								\
793      }									\
794      a_prefix##destroy_recurse(rbtree, rbtn_left_get(a_type, a_field,	\
<span onclick='openModal()' class='match'>795        node), cb, arg);							\
796      rbtn_left_set(a_type, a_field, (node), NULL);			\
797      a_prefix##destroy_recurse(rbtree, rbtn_right_get(a_type, a_field,	\
</span>798        node), cb, arg);							\
799      rbtn_right_set(a_type, a_field, (node), NULL);			\
800      if (cb) {								\
801  	cb(node, arg);							\
802      }									\
803  }									\
804  a_attr void								\
805  a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
806    void *arg) {								\
807      a_prefix##destroy_recurse(rbtree, rbtree->rbt_root, cb, arg);	\
808      rbtree->rbt_root = NULL;						\
809  }
810  #endif &bsol;* RB_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.h</h3>
            <pre><code>1  #ifndef RB_H_
2  #define RB_H_
3  #ifndef __PGI
4  #define RB_COMPACT
5  #endif
6  #ifdef RB_COMPACT
7  #define rb_node(a_type)							\
8  struct {								\
9      a_type *rbn_left;							\
10      a_type *rbn_right_red;						\
11  }
12  #else
13  #define rb_node(a_type)							\
14  struct {								\
15      a_type *rbn_left;							\
16      a_type *rbn_right;							\
17      bool rbn_red;							\
18  }
19  #endif
20  #define rb_tree(a_type)							\
21  struct {								\
22      a_type *rbt_root;							\
23  }
24  #define rbtn_left_get(a_type, a_field, a_node)				\
25      ((a_node)->a_field.rbn_left)
26  #define rbtn_left_set(a_type, a_field, a_node, a_left) do {		\
27      (a_node)->a_field.rbn_left = a_left;				\
28  } while (0)
29  #ifdef RB_COMPACT
30  #define rbtn_right_get(a_type, a_field, a_node)				\
31      ((a_type *) (((intptr_t) (a_node)->a_field.rbn_right_red)		\
32        & ((ssize_t)-2)))
33  #define rbtn_right_set(a_type, a_field, a_node, a_right) do {		\
34      (a_node)->a_field.rbn_right_red = (a_type *) (((uintptr_t) a_right)	\
35        | (((uintptr_t) (a_node)->a_field.rbn_right_red) & ((size_t)1)));	\
36  } while (0)
37  #define rbtn_red_get(a_type, a_field, a_node)				\
38      ((bool) (((uintptr_t) (a_node)->a_field.rbn_right_red)		\
39        & ((size_t)1)))
40  #define rbtn_color_set(a_type, a_field, a_node, a_red) do {		\
41      (a_node)->a_field.rbn_right_red = (a_type *) ((((intptr_t)		\
42        (a_node)->a_field.rbn_right_red) & ((ssize_t)-2))			\
43        | ((ssize_t)a_red));						\
44  } while (0)
45  #define rbtn_red_set(a_type, a_field, a_node) do {			\
46      (a_node)->a_field.rbn_right_red = (a_type *) (((uintptr_t)		\
47        (a_node)->a_field.rbn_right_red) | ((size_t)1));			\
48  } while (0)
49  #define rbtn_black_set(a_type, a_field, a_node) do {			\
50      (a_node)->a_field.rbn_right_red = (a_type *) (((intptr_t)		\
51        (a_node)->a_field.rbn_right_red) & ((ssize_t)-2));		\
52  } while (0)
53  #define rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
54      		\
55      assert(((uintptr_t)(a_node) & 0x1) == 0);				\
56      rbtn_left_set(a_type, a_field, (a_node), NULL);	\
57      rbtn_right_set(a_type, a_field, (a_node), NULL);	\
58      rbtn_red_set(a_type, a_field, (a_node));				\
59  } while (0)
60  #else
61  #define rbtn_right_get(a_type, a_field, a_node)				\
62      ((a_node)->a_field.rbn_right)
63  #define rbtn_right_set(a_type, a_field, a_node, a_right) do {		\
64      (a_node)->a_field.rbn_right = a_right;				\
65  } while (0)
66  #define rbtn_red_get(a_type, a_field, a_node)				\
67      ((a_node)->a_field.rbn_red)
68  #define rbtn_color_set(a_type, a_field, a_node, a_red) do {		\
69      (a_node)->a_field.rbn_red = (a_red);				\
70  } while (0)
71  #define rbtn_red_set(a_type, a_field, a_node) do {			\
72      (a_node)->a_field.rbn_red = true;					\
73  } while (0)
74  #define rbtn_black_set(a_type, a_field, a_node) do {			\
75      (a_node)->a_field.rbn_red = false;					\
76  } while (0)
77  #define rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
78      rbtn_left_set(a_type, a_field, (a_node), NULL);	\
79      rbtn_right_set(a_type, a_field, (a_node), NULL);	\
80      rbtn_red_set(a_type, a_field, (a_node));				\
81  } while (0)
82  #endif
83  #define rb_new(a_type, a_field, a_rbt) do {				\
84      (a_rbt)->rbt_root = NULL;						\
85  } while (0)
86  #define rbtn_first(a_type, a_field, a_rbt, a_root, r_node) do {		\
87      (r_node) = (a_root);						\
88      if ((r_node) != NULL) {						\
89  	for (;								\
90  	  rbtn_left_get(a_type, a_field, (r_node)) != NULL;		\
91  	  (r_node) = rbtn_left_get(a_type, a_field, (r_node))) {	\
92  	}								\
93      }									\
94  } while (0)
95  #define rbtn_last(a_type, a_field, a_rbt, a_root, r_node) do {		\
96      (r_node) = (a_root);						\
97      if ((r_node) != NULL) {						\
98  	for (; rbtn_right_get(a_type, a_field, (r_node)) != NULL;	\
99  	  (r_node) = rbtn_right_get(a_type, a_field, (r_node))) {	\
100  	}								\
101      }									\
102  } while (0)
103  #define rbtn_rotate_left(a_type, a_field, a_node, r_node) do {		\
104      (r_node) = rbtn_right_get(a_type, a_field, (a_node));		\
105      rbtn_right_set(a_type, a_field, (a_node),				\
106        rbtn_left_get(a_type, a_field, (r_node)));			\
107      rbtn_left_set(a_type, a_field, (r_node), (a_node));			\
108  } while (0)
109  #define rbtn_rotate_right(a_type, a_field, a_node, r_node) do {		\
110      (r_node) = rbtn_left_get(a_type, a_field, (a_node));		\
111      rbtn_left_set(a_type, a_field, (a_node),				\
112        rbtn_right_get(a_type, a_field, (r_node)));			\
113      rbtn_right_set(a_type, a_field, (r_node), (a_node));		\
114  } while (0)
115  #define rb_proto(a_attr, a_prefix, a_rbt_type, a_type)			\
116  a_attr void								\
117  a_prefix##new(a_rbt_type *rbtree);					\
118  a_attr bool								\
119  a_prefix##empty(a_rbt_type *rbtree);					\
120  a_attr a_type *								\
121  a_prefix##first(a_rbt_type *rbtree);					\
122  a_attr a_type *								\
123  a_prefix##last(a_rbt_type *rbtree);					\
124  a_attr a_type *								\
125  a_prefix##next(a_rbt_type *rbtree, a_type *node);			\
126  a_attr a_type *								\
127  a_prefix##prev(a_rbt_type *rbtree, a_type *node);			\
128  a_attr a_type *								\
129  a_prefix##search(a_rbt_type *rbtree, const a_type *key);		\
130  a_attr a_type *								\
131  a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key);		\
132  a_attr a_type *								\
133  a_prefix##psearch(a_rbt_type *rbtree, const a_type *key);		\
134  a_attr void								\
135  a_prefix##insert(a_rbt_type *rbtree, a_type *node);			\
136  a_attr void								\
137  a_prefix##remove(a_rbt_type *rbtree, a_type *node);			\
138  a_attr a_type *								\
139  a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\
140    a_rbt_type *, a_type *, void *), void *arg);				\
141  a_attr a_type *								\
142  a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\
143    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);		\
144  a_attr void								\
145  a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
146    void *arg);
147  #define rb_gen(a_attr, a_prefix, a_rbt_type, a_type, a_field, a_cmp)	\
148  a_attr void								\
149  a_prefix##new(a_rbt_type *rbtree) {					\
150      rb_new(a_type, a_field, rbtree);					\
151  }									\
152  a_attr bool								\
153  a_prefix##empty(a_rbt_type *rbtree) {					\
154      return (rbtree->rbt_root == NULL);					\
155  }									\
156  a_attr a_type *								\
157  a_prefix##first(a_rbt_type *rbtree) {					\
158      a_type *ret;							\
159      rbtn_first(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
160      return ret;								\
161  }									\
162  a_attr a_type *								\
163  a_prefix##last(a_rbt_type *rbtree) {					\
164      a_type *ret;							\
165      rbtn_last(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
166      return ret;								\
167  }									\
168  a_attr a_type *								\
169  a_prefix##next(a_rbt_type *rbtree, a_type *node) {			\
170      a_type *ret;							\
171      if (rbtn_right_get(a_type, a_field, node) != NULL) {		\
172  	rbtn_first(a_type, a_field, rbtree, rbtn_right_get(a_type,	\
173  	  a_field, node), ret);						\
174      } else {								\
175  	a_type *tnode = rbtree->rbt_root;				\
176  	assert(tnode != NULL);						\
177  	ret = NULL;							\
178  	while (true) {							\
179  	    int cmp = (a_cmp)(node, tnode);				\
180  	    if (cmp < 0) {						\
181  		ret = tnode;						\
182  		tnode = rbtn_left_get(a_type, a_field, tnode);		\
183  	    } else if (cmp > 0) {					\
184  		tnode = rbtn_right_get(a_type, a_field, tnode);		\
185  	    } else {							\
186  		break;							\
187  	    }								\
188  	    assert(tnode != NULL);					\
189  	}								\
190      }									\
191      return ret;								\
192  }									\
193  a_attr a_type *								\
194  a_prefix##prev(a_rbt_type *rbtree, a_type *node) {			\
195      a_type *ret;							\
196      if (rbtn_left_get(a_type, a_field, node) != NULL) {			\
197  	rbtn_last(a_type, a_field, rbtree, rbtn_left_get(a_type,	\
198  	  a_field, node), ret);						\
199      } else {								\
200  	a_type *tnode = rbtree->rbt_root;				\
201  	assert(tnode != NULL);						\
202  	ret = NULL;							\
203  	while (true) {							\
204  	    int cmp = (a_cmp)(node, tnode);				\
205  	    if (cmp < 0) {						\
206  		tnode = rbtn_left_get(a_type, a_field, tnode);		\
207  	    } else if (cmp > 0) {					\
208  		ret = tnode;						\
209  		tnode = rbtn_right_get(a_type, a_field, tnode);		\
210  	    } else {							\
211  		break;							\
212  	    }								\
213  	    assert(tnode != NULL);					\
214  	}								\
215      }									\
216      return ret;								\
217  }									\
218  a_attr a_type *								\
219  a_prefix##search(a_rbt_type *rbtree, const a_type *key) {		\
220      a_type *ret;							\
221      int cmp;								\
222      ret = rbtree->rbt_root;						\
223      while (ret != NULL							\
224        && (cmp = (a_cmp)(key, ret)) != 0) {				\
225  	if (cmp < 0) {							\
226  	    ret = rbtn_left_get(a_type, a_field, ret);			\
227  	} else {							\
228  	    ret = rbtn_right_get(a_type, a_field, ret);			\
229  	}								\
230      }									\
231      return ret;								\
232  }									\
233  a_attr a_type *								\
234  a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key) {		\
235      a_type *ret;							\
236      a_type *tnode = rbtree->rbt_root;					\
237      ret = NULL;								\
238      while (tnode != NULL) {						\
239  	int cmp = (a_cmp)(key, tnode);					\
240  	if (cmp < 0) {							\
241  	    ret = tnode;						\
242  	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
243  	} else if (cmp > 0) {						\
244  	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
245  	} else {							\
246  	    ret = tnode;						\
247  	    break;							\
248  	}								\
249      }									\
250      return ret;								\
251  }									\
252  a_attr a_type *								\
253  a_prefix##psearch(a_rbt_type *rbtree, const a_type *key) {		\
254      a_type *ret;							\
255      a_type *tnode = rbtree->rbt_root;					\
256      ret = NULL;								\
257      while (tnode != NULL) {						\
258  	int cmp = (a_cmp)(key, tnode);					\
259  	if (cmp < 0) {							\
260  	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
261  	} else if (cmp > 0) {						\
262  	    ret = tnode;						\
263  	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
264  	} else {							\
265  	    ret = tnode;						\
266  	    break;							\
267  	}								\
268      }									\
269      return ret;								\
270  }									\
271  a_attr void								\
272  a_prefix##insert(a_rbt_type *rbtree, a_type *node) {			\
273      struct {								\
274  	a_type *node;							\
275  	int cmp;							\
276      } path[sizeof(void *) << 4], *pathp;				\
277      rbt_node_new(a_type, a_field, rbtree, node);			\
278      								\
279      path->node = rbtree->rbt_root;					\
280      for (pathp = path; pathp->node != NULL; pathp++) {			\
281  	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
282  	assert(cmp != 0);						\
283  	if (cmp < 0) {							\
284  	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
285  	      pathp->node);						\
286  	} else {							\
287  	    pathp[1].node = rbtn_right_get(a_type, a_field,		\
288  	      pathp->node);						\
289  	}								\
290      }									\
291      pathp->node = node;							\
292      							\
293      for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
294  	a_type *cnode = pathp->node;					\
295  	if (pathp->cmp < 0) {						\
296  	    a_type *left = pathp[1].node;				\
297  	    rbtn_left_set(a_type, a_field, cnode, left);		\
298  	    if (rbtn_red_get(a_type, a_field, left)) {			\
299  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
300  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
301  		  leftleft)) {						\
302  		    				\
303  		    a_type *tnode;					\
304  		    rbtn_black_set(a_type, a_field, leftleft);		\
305  		    rbtn_rotate_right(a_type, a_field, cnode, tnode);	\
306  		    cnode = tnode;					\
307  		}							\
308  	    } else {							\
309  		return;							\
310  	    }								\
311  	} else {							\
312  	    a_type *right = pathp[1].node;				\
313  	    rbtn_right_set(a_type, a_field, cnode, right);		\
314  	    if (rbtn_red_get(a_type, a_field, right)) {			\
315  		a_type *left = rbtn_left_get(a_type, a_field, cnode);	\
316  		if (left != NULL && rbtn_red_get(a_type, a_field,	\
317  		  left)) {						\
318  		    					\
319  		    rbtn_black_set(a_type, a_field, left);		\
320  		    rbtn_black_set(a_type, a_field, right);		\
321  		    rbtn_red_set(a_type, a_field, cnode);		\
322  		} else {						\
323  		    					\
324  		    a_type *tnode;					\
325  		    bool tred = rbtn_red_get(a_type, a_field, cnode);	\
326  		    rbtn_rotate_left(a_type, a_field, cnode, tnode);	\
327  		    rbtn_color_set(a_type, a_field, tnode, tred);	\
328  		    rbtn_red_set(a_type, a_field, cnode);		\
329  		    cnode = tnode;					\
330  		}							\
331  	    } else {							\
332  		return;							\
333  	    }								\
334  	}								\
335  	pathp->node = cnode;						\
336      }									\
337      					\
338      rbtree->rbt_root = path->node;					\
339      rbtn_black_set(a_type, a_field, rbtree->rbt_root);			\
340  }									\
341  a_attr void								\
342  a_prefix##remove(a_rbt_type *rbtree, a_type *node) {			\
343      struct {								\
344  	a_type *node;							\
345  	int cmp;							\
346      } *pathp, *nodep, path[sizeof(void *) << 4];			\
347      								\
348      nodep = NULL; &bsol;* Silence compiler warning. */			\
349      path->node = rbtree->rbt_root;					\
350      for (pathp = path; pathp->node != NULL; pathp++) {			\
351  	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
352  	if (cmp < 0) {							\
353  	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
354  	      pathp->node);						\
355  	} else {							\
356  	    pathp[1].node = rbtn_right_get(a_type, a_field,		\
357  	      pathp->node);						\
358  	    if (cmp == 0) {						\
359  	        	\
360  		pathp->cmp = 1;						\
361  		nodep = pathp;						\
362  		for (pathp++; pathp->node != NULL; pathp++) {		\
363  		    pathp->cmp = -1;					\
364  		    pathp[1].node = rbtn_left_get(a_type, a_field,	\
365  		      pathp->node);					\
366  		}							\
367  		break;							\
368  	    }								\
369  	}								\
370      }									\
371      assert(nodep->node == node);					\
372      pathp--;								\
373      if (pathp->node != node) {						\
374  					\
375  	bool tred = rbtn_red_get(a_type, a_field, pathp->node);		\
376  	rbtn_color_set(a_type, a_field, pathp->node,			\
377  	  rbtn_red_get(a_type, a_field, node));				\
378  	rbtn_left_set(a_type, a_field, pathp->node,			\
379  	  rbtn_left_get(a_type, a_field, node));			\
380  	\
381  	\
382  	\
383  	\
384  	rbtn_right_set(a_type, a_field, pathp->node,			\
385  	  rbtn_right_get(a_type, a_field, node));			\
386  	rbtn_color_set(a_type, a_field, node, tred);			\
387  	\
388  	\
389  	nodep->node = pathp->node;					\
390  	pathp->node = node;						\
391  	if (nodep == path) {						\
392  	    rbtree->rbt_root = nodep->node;				\
393  	} else {							\
394  	    if (nodep[-1].cmp < 0) {					\
395  		rbtn_left_set(a_type, a_field, nodep[-1].node,		\
396  		  nodep->node);						\
397  	    } else {							\
398  		rbtn_right_set(a_type, a_field, nodep[-1].node,		\
399  		  nodep->node);						\
400  	    }								\
401  	}								\
402      } else {								\
403  	a_type *left = rbtn_left_get(a_type, a_field, node);		\
404  	if (left != NULL) {						\
405  	    \
406  	    \
407  	    assert(!rbtn_red_get(a_type, a_field, node));		\
408  	    assert(rbtn_red_get(a_type, a_field, left));		\
409  	    rbtn_black_set(a_type, a_field, left);			\
410  	    if (pathp == path) {					\
411  		rbtree->rbt_root = left;				\
412  	    } else {							\
413  		if (pathp[-1].cmp < 0) {				\
414  		    rbtn_left_set(a_type, a_field, pathp[-1].node,	\
415  		      left);						\
416  		} else {						\
417  		    rbtn_right_set(a_type, a_field, pathp[-1].node,	\
418  		      left);						\
419  		}							\
420  	    }								\
421  	    return;							\
422  	} else if (pathp == path) {					\
423  	    			\
424  	    rbtree->rbt_root = NULL;					\
425  	    return;							\
426  	}								\
427      }									\
428      if (rbtn_red_get(a_type, a_field, pathp->node)) {			\
429  				\
430  	assert(pathp[-1].cmp < 0);					\
431  	rbtn_left_set(a_type, a_field, pathp[-1].node, NULL);		\
432  	return;								\
433      }									\
434      \
435      \
436      pathp->node = NULL;							\
437      for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
438  	assert(pathp->cmp != 0);					\
439  	if (pathp->cmp < 0) {						\
440  	    rbtn_left_set(a_type, a_field, pathp->node,			\
441  	      pathp[1].node);						\
442  	    if (rbtn_red_get(a_type, a_field, pathp->node)) {		\
443  		a_type *right = rbtn_right_get(a_type, a_field,		\
444  		  pathp->node);						\
445  		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
446  		  right);						\
447  		a_type *tnode;						\
448  		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
449  		  rightleft)) {						\
450  		    \
451  		    \
452  		    \
453  		    \
454  		    \
455  		    \
456  		    \
457  		    \
458  		    \
459  		    \
460  		    rbtn_black_set(a_type, a_field, pathp->node);	\
461  		    rbtn_rotate_right(a_type, a_field, right, tnode);	\
462  		    rbtn_right_set(a_type, a_field, pathp->node, tnode);\
463  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
464  		      tnode);						\
465  		} else {						\
466  		    \
467  		    \
468  		    \
469  		    \
470  		    \
471  		    \
472  		    \
473  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
474  		      tnode);						\
475  		}							\
476  		\
477  		\
478  		assert((uintptr_t)pathp > (uintptr_t)path);		\
479  		if (pathp[-1].cmp < 0) {				\
480  		    rbtn_left_set(a_type, a_field, pathp[-1].node,	\
481  		      tnode);						\
482  		} else {						\
483  		    rbtn_right_set(a_type, a_field, pathp[-1].node,	\
484  		      tnode);						\
485  		}							\
486  		return;							\
487  	    } else {							\
488  		a_type *right = rbtn_right_get(a_type, a_field,		\
489  		  pathp->node);						\
490  		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
491  		  right);						\
492  		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
493  		  rightleft)) {						\
494  		    \
495  		    \
496  		    \
497  		    \
498  		    \
499  		    \
500  		    a_type *tnode;					\
501  		    rbtn_black_set(a_type, a_field, rightleft);		\
502  		    rbtn_rotate_right(a_type, a_field, right, tnode);	\
503  		    rbtn_right_set(a_type, a_field, pathp->node, tnode);\
504  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
505  		      tnode);						\
506  		    \
507  		    \
508  		    \
509  		    if (pathp == path) {				\
510  								\
511  			rbtree->rbt_root = tnode;			\
512  		    } else {						\
513  			if (pathp[-1].cmp < 0) {			\
514  			    rbtn_left_set(a_type, a_field,		\
515  			      pathp[-1].node, tnode);			\
516  			} else {					\
517  			    rbtn_right_set(a_type, a_field,		\
518  			      pathp[-1].node, tnode);			\
519  			}						\
520  		    }							\
521  		    return;						\
522  		} else {						\
523  		    \
524  		    \
525  		    \
526  		    \
527  		    \
528  		    \
529  		    a_type *tnode;					\
530  		    rbtn_red_set(a_type, a_field, pathp->node);		\
531  		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
532  		      tnode);						\
533  		    pathp->node = tnode;				\
534  		}							\
535  	    }								\
536  	} else {							\
537  	    a_type *left;						\
538  	    rbtn_right_set(a_type, a_field, pathp->node,		\
539  	      pathp[1].node);						\
540  	    left = rbtn_left_get(a_type, a_field, pathp->node);		\
541  	    if (rbtn_red_get(a_type, a_field, left)) {			\
542  		a_type *tnode;						\
543  		a_type *leftright = rbtn_right_get(a_type, a_field,	\
544  		  left);						\
545  		a_type *leftrightleft = rbtn_left_get(a_type, a_field,	\
546  		  leftright);						\
547  		if (leftrightleft != NULL && rbtn_red_get(a_type,	\
548  		  a_field, leftrightleft)) {				\
549  		    \
550  		    \
551  		    \
552  		    \
553  		    \
554  		    \
555  		    \
556  		    \
557  		    a_type *unode;					\
558  		    rbtn_black_set(a_type, a_field, leftrightleft);	\
559  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
560  		      unode);						\
561  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
562  		      tnode);						\
563  		    rbtn_right_set(a_type, a_field, unode, tnode);	\
564  		    rbtn_rotate_left(a_type, a_field, unode, tnode);	\
565  		} else {						\
566  		    \
567  		    \
568  		    \
569  		    \
570  		    \
571  		    \
572  		    \
573  		    \
574  		    assert(leftright != NULL);				\
575  		    rbtn_red_set(a_type, a_field, leftright);		\
576  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
577  		      tnode);						\
578  		    rbtn_black_set(a_type, a_field, tnode);		\
579  		}							\
580  		\
581  		\
582  		if (pathp == path) {					\
583  		    					\
584  		    rbtree->rbt_root = tnode;				\
585  		} else {						\
586  		    if (pathp[-1].cmp < 0) {				\
587  			rbtn_left_set(a_type, a_field, pathp[-1].node,	\
588  			  tnode);					\
589  		    } else {						\
590  			rbtn_right_set(a_type, a_field, pathp[-1].node,	\
591  			  tnode);					\
592  		    }							\
593  		}							\
594  		return;							\
595  	    } else if (rbtn_red_get(a_type, a_field, pathp->node)) {	\
596  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
597  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
598  		  leftleft)) {						\
599  		    \
600  		    \
601  		    \
602  		    \
603  		    \
604  		    \
605  		    a_type *tnode;					\
606  		    rbtn_black_set(a_type, a_field, pathp->node);	\
607  		    rbtn_red_set(a_type, a_field, left);		\
608  		    rbtn_black_set(a_type, a_field, leftleft);		\
609  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
610  		      tnode);						\
611  		    \
612  		    \
613  		    assert((uintptr_t)pathp > (uintptr_t)path);		\
614  		    if (pathp[-1].cmp < 0) {				\
615  			rbtn_left_set(a_type, a_field, pathp[-1].node,	\
616  			  tnode);					\
617  		    } else {						\
618  			rbtn_right_set(a_type, a_field, pathp[-1].node,	\
619  			  tnode);					\
620  		    }							\
621  		    return;						\
622  		} else {						\
623  		    \
624  		    \
625  		    \
626  		    \
627  		    \
628  		    \
629  		    rbtn_red_set(a_type, a_field, left);		\
630  		    rbtn_black_set(a_type, a_field, pathp->node);	\
631  		    				\
632  		    return;						\
633  		}							\
634  	    } else {							\
635  		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
636  		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
637  		  leftleft)) {						\
638  		    \
639  		    \
640  		    \
641  		    \
642  		    \
643  		    \
644  		    a_type *tnode;					\
645  		    rbtn_black_set(a_type, a_field, leftleft);		\
646  		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
647  		      tnode);						\
648  		    \
649  		    \
650  		    \
651  		    if (pathp == path) {				\
652  								\
653  			rbtree->rbt_root = tnode;			\
654  		    } else {						\
655  			if (pathp[-1].cmp < 0) {			\
656  			    rbtn_left_set(a_type, a_field,		\
657  			      pathp[-1].node, tnode);			\
658  			} else {					\
659  			    rbtn_right_set(a_type, a_field,		\
660  			      pathp[-1].node, tnode);			\
661  			}						\
662  		    }							\
663  		    return;						\
664  		} else {						\
665  		    \
666  		    \
667  		    \
668  		    \
669  		    \
670  		    \
671  		    rbtn_red_set(a_type, a_field, left);		\
672  		}							\
673  	    }								\
674  	}								\
675      }									\
676      							\
677      rbtree->rbt_root = path->node;					\
678      assert(!rbtn_red_get(a_type, a_field, rbtree->rbt_root));		\
679  }									\
680  a_attr a_type *								\
681  a_prefix##iter_recurse(a_rbt_type *rbtree, a_type *node,		\
682    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
683      if (node == NULL) {							\
684  	return NULL;							\
685      } else {								\
686  	a_type *ret;							\
687  	if ((ret = a_prefix##iter_recurse(rbtree, rbtn_left_get(a_type,	\
688  	  a_field, node), cb, arg)) != NULL || (ret = cb(rbtree, node,	\
689  	  arg)) != NULL) {						\
690  	    return ret;							\
691  	}								\
692  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
693  	  a_field, node), cb, arg);					\
694      }									\
695  }									\
696  a_attr a_type *								\
697  a_prefix##iter_start(a_rbt_type *rbtree, a_type *start, a_type *node,	\
698    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
699      int cmp = a_cmp(start, node);					\
700      if (cmp < 0) {							\
701  	a_type *ret;							\
702  	if ((ret = a_prefix##iter_start(rbtree, start,			\
703  	  rbtn_left_get(a_type, a_field, node), cb, arg)) != NULL ||	\
704  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
705  	    return ret;							\
706  	}								\
707  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
708  	  a_field, node), cb, arg);					\
709      } else if (cmp > 0) {						\
710  	return a_prefix##iter_start(rbtree, start,			\
711  	  rbtn_right_get(a_type, a_field, node), cb, arg);		\
712      } else {								\
713  	a_type *ret;							\
714  	if ((ret = cb(rbtree, node, arg)) != NULL) {			\
715  	    return ret;							\
716  	}								\
717  	return a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
718  	  a_field, node), cb, arg);					\
719      }									\
720  }									\
721  a_attr a_type *								\
722  a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\
723    a_rbt_type *, a_type *, void *), void *arg) {				\
724      a_type *ret;							\
725      if (start != NULL) {						\
726  	ret = a_prefix##iter_start(rbtree, start, rbtree->rbt_root,	\
727  	  cb, arg);							\
728      } else {								\
729  	ret = a_prefix##iter_recurse(rbtree, rbtree->rbt_root, cb, arg);\
730      }									\
731      return ret;								\
732  }									\
733  a_attr a_type *								\
734  a_prefix##reverse_iter_recurse(a_rbt_type *rbtree, a_type *node,	\
735    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
736      if (node == NULL) {							\
737  	return NULL;							\
738      } else {								\
739  	a_type *ret;							\
740  	if ((ret = a_prefix##reverse_iter_recurse(rbtree,		\
741  	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
742  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
743  	    return ret;							\
744  	}								\
745  	return a_prefix##reverse_iter_recurse(rbtree,			\
746  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
747      }									\
748  }									\
749  a_attr a_type *								\
750  a_prefix##reverse_iter_start(a_rbt_type *rbtree, a_type *start,		\
751    a_type *node, a_type *(*cb)(a_rbt_type *, a_type *, void *),		\
752    void *arg) {								\
753      int cmp = a_cmp(start, node);					\
754      if (cmp > 0) {							\
755  	a_type *ret;							\
756  	if ((ret = a_prefix##reverse_iter_start(rbtree, start,		\
757  	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
758  	  (ret = cb(rbtree, node, arg)) != NULL) {			\
759  	    return ret;							\
760  	}								\
761  	return a_prefix##reverse_iter_recurse(rbtree,			\
762  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
763      } else if (cmp < 0) {						\
764  	return a_prefix##reverse_iter_start(rbtree, start,		\
765  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
766      } else {								\
767  	a_type *ret;							\
768  	if ((ret = cb(rbtree, node, arg)) != NULL) {			\
769  	    return ret;							\
770  	}								\
771  	return a_prefix##reverse_iter_recurse(rbtree,			\
772  	  rbtn_left_get(a_type, a_field, node), cb, arg);		\
773      }									\
774  }									\
775  a_attr a_type *								\
776  a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\
777    a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
778      a_type *ret;							\
779      if (start != NULL) {						\
780  	ret = a_prefix##reverse_iter_start(rbtree, start,		\
781  	  rbtree->rbt_root, cb, arg);					\
782      } else {								\
783  	ret = a_prefix##reverse_iter_recurse(rbtree, rbtree->rbt_root,	\
784  	  cb, arg);							\
785      }									\
786      return ret;								\
787  }									\
788  a_attr void								\
789  a_prefix##destroy_recurse(a_rbt_type *rbtree, a_type *node, void (*cb)(	\
790    a_type *, void *), void *arg) {					\
791      if (node == NULL) {							\
792  	return;								\
793      }									\
794      a_prefix##destroy_recurse(rbtree, rbtn_left_get(a_type, a_field,	\
795        node), cb, arg);							\
796      rbtn_left_set(a_type, a_field, (node), NULL);			\
797      a_prefix##destroy_recurse(rbtree, rbtn_right_get(a_type, a_field,	\
<span onclick='openModal()' class='match'>798        node), cb, arg);							\
799      rbtn_right_set(a_type, a_field, (node), NULL);			\
800      if (cb) {								\
</span>801  	cb(node, arg);							\
802      }									\
803  }									\
804  a_attr void								\
805  a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
806    void *arg) {								\
807      a_prefix##destroy_recurse(rbtree, rbtree->rbt_root, cb, arg);	\
808      rbtree->rbt_root = NULL;						\
809  }
810  #endif &bsol;* RB_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rb.h</div>
                </div>
                <div class="column column_space"><pre><code>795        node), cb, arg);							\
796      rbtn_left_set(a_type, a_field, (node), NULL);			\
797      a_prefix##destroy_recurse(rbtree, rbtn_right_get(a_type, a_field,	\
</pre></code></div>
                <div class="column column_space"><pre><code>798        node), cb, arg);							\
799      rbtn_right_set(a_type, a_field, (node), NULL);			\
800      if (cb) {								\
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    