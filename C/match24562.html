<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for flatten.c &amp; niftiload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for flatten.c &amp; niftiload.c
      </h3>
<h1 align="center">
        4.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>flatten.c (7.3469386%)<th>niftiload.c (3.314917%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(395-415)<td><a href="#" name="0">(755-775)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>flatten.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;vips/debug.h&gt;
11 #include "pconversion.h"
12 typedef struct _VipsFlatten {
13 	VipsConversion parent_instance;
14 	VipsImage *in;
15 	VipsArrayDouble *background;
16 	VipsPel *ink;
17 	double max_alpha;
18 } VipsFlatten;
19 typedef VipsConversionClass VipsFlattenClass;
20 G_DEFINE_TYPE( VipsFlatten, vips_flatten, VIPS_TYPE_CONVERSION );
21 #define VIPS_FLATTEN_BLACK_INT( TYPE ) { \
22 	TYPE * restrict p = (TYPE *) in; \
23 	TYPE * restrict q = (TYPE *) out; \
24 	\
25 	for( x = 0; x &lt; width; x++ ) { \
26 		TYPE alpha = p[bands - 1]; \
27 		int b; \
28 		\
29 		for( b = 0; b &lt; bands - 1; b++ ) \
30 			q[b] = (p[b] * alpha) / max_alpha; \
31 		\
32 		p += bands; \
33 		q += bands - 1; \
34 	} \
35 }
36 #define VIPS_FLATTEN_BLACK_FLOAT( TYPE ) { \
37 	TYPE * restrict p = (TYPE *) in; \
38 	TYPE * restrict q = (TYPE *) out; \
39 	\
40 	for( x = 0; x &lt; width; x++ ) { \
41 		TYPE alpha = p[bands - 1]; \
42 		int b; \
43 		\
44 		for( b = 0; b &lt; bands - 1; b++ ) \
45 			q[b] = ((double) p[b] * alpha) / max_alpha; \
46 		\
47 		p += bands; \
48 		q += bands - 1; \
49 	} \
50 }
51 #define VIPS_FLATTEN_INT( TYPE ) { \
52 	TYPE * restrict p = (TYPE *) in; \
53 	TYPE * restrict q = (TYPE *) out; \
54 	\
55 	for( x = 0; x &lt; width; x++ ) { \
56 		TYPE alpha = p[bands - 1]; \
57 		TYPE nalpha = max_alpha - alpha; \
58 		TYPE * restrict bg = (TYPE *) flatten-&gt;ink; \
59 		int b; \
60 		\
61 		for( b = 0; b &lt; bands - 1; b++ ) \
62 			q[b] = (p[b] * alpha + bg[b] * nalpha) / max_alpha; \
63 		\
64 		p += bands; \
65 		q += bands - 1; \
66 	} \
67 }
68 #define VIPS_FLATTEN_FLOAT( TYPE ) { \
69 	TYPE * restrict p = (TYPE *) in; \
70 	TYPE * restrict q = (TYPE *) out; \
71 	\
72 	for( x = 0; x &lt; width; x++ ) { \
73 		TYPE alpha = p[bands - 1]; \
74 		TYPE nalpha = max_alpha - alpha; \
75 		TYPE * restrict bg = (TYPE *) flatten-&gt;ink; \
76 		int b; \
77 		\
78 		for( b = 0; b &lt; bands - 1; b++ ) \
79 			q[b] = ((double) p[b] * alpha + \
80 				(double) bg[b] * nalpha) / max_alpha; \
81 		\
82 		p += bands; \
83 		q += bands - 1; \
84 	} \
85 }
86 static int
87 vips_flatten_black_gen( VipsRegion *or, void *vseq, void *a, void *b,
88 	gboolean *stop )
89 {
90 	VipsRegion *ir = (VipsRegion *) vseq;
91 	VipsFlatten *flatten = (VipsFlatten *) b;
92 	VipsRect *r = &amp;or-&gt;valid;
93 	int width = r-&gt;width;
94 	int bands = ir-&gt;im-&gt;Bands; 
95 	double max_alpha = flatten-&gt;max_alpha;
96 	int x, y;
97 	if( vips_region_prepare( ir, r ) )
98 		return( -1 );
99 	for( y = 0; y &lt; r-&gt;height; y++ ) {
100 		VipsPel *in = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); 
101 		VipsPel *out = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); 
102 		switch( ir-&gt;im-&gt;BandFmt ) { 
103 		case VIPS_FORMAT_UCHAR: 
104 			VIPS_FLATTEN_BLACK_INT( unsigned char ); 
105 			break; 
106 		case VIPS_FORMAT_CHAR: 
107 			VIPS_FLATTEN_BLACK_INT( signed char ); 
108 			break; 
109 		case VIPS_FORMAT_USHORT: 
110 			VIPS_FLATTEN_BLACK_FLOAT( unsigned short ); 
111 			break; 
112 		case VIPS_FORMAT_SHORT: 
113 			VIPS_FLATTEN_BLACK_FLOAT( signed short ); 
114 			break; 
115 		case VIPS_FORMAT_UINT: 
116 			VIPS_FLATTEN_BLACK_FLOAT( unsigned int ); 
117 			break; 
118 		case VIPS_FORMAT_INT: 
119 			VIPS_FLATTEN_BLACK_FLOAT( signed int ); 
120 			break; 
121 		case VIPS_FORMAT_FLOAT: 
122 			VIPS_FLATTEN_BLACK_FLOAT( float ); 
123 			break; 
124 		case VIPS_FORMAT_DOUBLE: 
125 			VIPS_FLATTEN_BLACK_FLOAT( double ); 
126 			break; 
127 		case VIPS_FORMAT_COMPLEX: 
128 		case VIPS_FORMAT_DPCOMPLEX: 
129 		default: 
130 			g_assert_not_reached(); 
131 		} 
132 	}
133 	return( 0 );
134 }
135 static int
136 vips_flatten_gen( VipsRegion *or, void *vseq, void *a, void *b,
137 	gboolean *stop )
138 {
139 	VipsRegion *ir = (VipsRegion *) vseq;
140 	VipsFlatten *flatten = (VipsFlatten *) b;
141 	VipsRect *r = &amp;or-&gt;valid;
142 	int width = r-&gt;width;
143 	int bands = ir-&gt;im-&gt;Bands; 
144 	double max_alpha = flatten-&gt;max_alpha;
145 	int x, y;
146 	if( vips_region_prepare( ir, r ) )
147 		return( -1 );
148 	for( y = 0; y &lt; r-&gt;height; y++ ) {
149 		VipsPel *in = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); 
150 		VipsPel *out = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); 
151 		switch( ir-&gt;im-&gt;BandFmt ) { 
152 		case VIPS_FORMAT_UCHAR: 
153 			VIPS_FLATTEN_INT( unsigned char ); 
154 			break; 
155 		case VIPS_FORMAT_CHAR: 
156 			VIPS_FLATTEN_INT( signed char ); 
157 			break; 
158 		case VIPS_FORMAT_USHORT: 
159 			VIPS_FLATTEN_FLOAT( unsigned short ); 
160 			break; 
161 		case VIPS_FORMAT_SHORT: 
162 			VIPS_FLATTEN_FLOAT( signed short ); 
163 			break; 
164 		case VIPS_FORMAT_UINT: 
165 			VIPS_FLATTEN_FLOAT( unsigned int ); 
166 			break; 
167 		case VIPS_FORMAT_INT: 
168 			VIPS_FLATTEN_FLOAT( signed int ); 
169 			break; 
170 		case VIPS_FORMAT_FLOAT: 
171 			VIPS_FLATTEN_FLOAT( float ); 
172 			break; 
173 		case VIPS_FORMAT_DOUBLE: 
174 			VIPS_FLATTEN_FLOAT( double ); 
175 			break; 
176 		case VIPS_FORMAT_COMPLEX: 
177 		case VIPS_FORMAT_DPCOMPLEX: 
178 		default: 
179 			g_assert_not_reached(); 
180 		} 
181 	}
182 	return( 0 );
183 }
184 static int
185 vips_flatten_build( VipsObject *object )
186 {
187 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
188 	VipsConversion *conversion = VIPS_CONVERSION( object );
189 	VipsFlatten *flatten = (VipsFlatten *) object;
190 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
191 	VipsImage *in;
192 	int i;
193 	gboolean black;
194 	VipsBandFormat original_format;
195 	if( VIPS_OBJECT_CLASS( vips_flatten_parent_class )-&gt;build( object ) )
196 		return( -1 );
197 	in = flatten-&gt;in; 
198 	if( vips_image_decode( in, &amp;t[0] ) )
199 		return( -1 );
200 	in = t[0]; 
201 	if( in-&gt;Bands == 1 ) 
202 		return( vips_image_write( in, conversion-&gt;out ) );
203 	if( vips_check_noncomplex( class-&gt;nickname, in ) )
204 		return( -1 );
205 	if( !vips_object_argument_isset( object, "max_alpha" ) ) 
206 		if( in-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
207 			in-&gt;Type == VIPS_INTERPRETATION_RGB16 )
208 			flatten-&gt;max_alpha = 65535;
209 	original_format = VIPS_FORMAT_NOTSET;
210 	if( vips_band_format_isint( in-&gt;BandFmt ) &amp;&amp;
211 		flatten-&gt;max_alpha &lt; 
212 			vips_image_get_format_max( in-&gt;BandFmt ) ) {
213 		original_format = in-&gt;BandFmt;
214 		if( vips_cast( in, &amp;t[1], VIPS_FORMAT_DOUBLE, NULL ) )
215 			return( -1 );
216 		in = t[1];
217 	}
218 	t[2] = vips_image_new();
219 	if( vips_image_pipelinev( t[2], 
220 		VIPS_DEMAND_STYLE_THINSTRIP, in, NULL ) )
221 		return( -1 );
222 	t[2]-&gt;Bands -= 1;
223 	black = TRUE;
224 	for( i = 0; i &lt; VIPS_AREA( flatten-&gt;background )-&gt;n; i++ ) {
225 		const double *background = 
226 			vips_array_double_get( flatten-&gt;background, NULL );
227 		if( background[i] != 0.0 ) {
228 			black = FALSE;
229 			break;
230 		}
231 	}
232 	if( black ) {
233 		if( vips_image_generate( t[2],
234 			vips_start_one, vips_flatten_black_gen, vips_stop_one, 
235 			in, flatten ) )
236 			return( -1 );
237 		in = t[2];
238 	}
239 	else {
240 		if( !(flatten-&gt;ink = vips__vector_to_ink( class-&gt;nickname, t[2],
241 			VIPS_AREA( flatten-&gt;background )-&gt;data, NULL, 
242 			VIPS_AREA( flatten-&gt;background )-&gt;n )) )
243 			return( -1 );
244 		if( vips_image_generate( t[2],
245 			vips_start_one, vips_flatten_gen, vips_stop_one, 
246 			in, flatten ) )
247 			return( -1 );
248 		in = t[2];
249 	}
250 	if( original_format != VIPS_FORMAT_NOTSET ) {
251 		if( vips_cast( in, &amp;t[3], original_format, NULL ) )
252 			return( -1 );
253 		in = t[3];
254 	}
255 	if( vips_image_write( in, conversion-&gt;out ) )
256 <a name="0"></a>		return( -1 );
257 	return( 0 );
258 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
259 static void
260 vips_flatten_class_init( VipsFlattenClass *class )
261 {
262 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
263 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
264 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
265 	VIPS_DEBUG_MSG( "vips_flatten_class_init\n" );
266 	gobject_class-&gt;set_property = vips_object_set_property;
267 	gobject_class-&gt;get_property = vips_object_get_property;
268 	vobject_class-&gt;nickname = "flatten";
269 	vobject_class-&gt;description = _( "flatten alpha out of an image" );
270 	vobject_class-&gt;build = vips_flatten_build;
271 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;
272 	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
273 		_( "Input" ), 
274 		_( "Input image" ),
275 		VIPS_ARGUMENT_REQUIRED_INPUT,
276 		G_STRUCT_OFFSET( VipsFlatten, in ) );
277 	VIPS_ARG_BOXED( class, "background", 2, 
278 		_( "Background" ), 
279 		_( "Background value" ),
280 		VIPS_ARGUMENT_OPTIONAL_INPUT,
281 		G_STRUCT_OFFSET( VipsFlatten, background ),
282 		VIPS_TYPE_ARRAY_DOUBLE );
283 	VIPS_ARG_DOUBLE( class, "max_alpha", 115, 
284 		_( "Maximum alpha" ), 
285 		_( "Maximum value of alpha channel" ),
286 		VIPS_ARGUMENT_OPTIONAL_INPUT,
287 		G_STRUCT_OFFSET( VipsFlatten, max_alpha ),
288 		0, 100000000, 255 );
289 }
290 static void
291 vips_flatten_init( VipsFlatten *flatten )
292 {
293 	flatten-&gt;background = vips_array_double_newv( 1, 0.0 );
294 	flatten-&gt;max_alpha= 255.0;
295 }
296 int
297 vips_flatten( VipsImage *in, VipsImage **out, ... )
298 {
299 	va_list ap;
300 	int result;
301 	va_start( ap, out );
302 	result = vips_call_split( "flatten", ap, in, out );
303 	va_end( ap );
304 	return( result );
305 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>niftiload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #ifdef HAVE_NIFTI
11 #include &lt;nifti1_io.h&gt;
12 #include "pforeign.h"
13 typedef struct _VipsForeignLoadNifti {
14 	VipsForeignLoad parent_object;
15 	VipsSource *source;
16 	const char *filename;
17 	nifti_image *nim;
18 	VipsImage *memory;
19 } VipsForeignLoadNifti;
20 typedef VipsForeignLoadClass VipsForeignLoadNiftiClass;
21 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadNifti, vips_foreign_load_nifti, 
22 	VIPS_TYPE_FOREIGN_LOAD );
23 static void
24 vips_foreign_load_nifti_dispose( GObject *gobject )
25 {
26 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) gobject;
27 	VIPS_UNREF( nifti-&gt;source );
28 	VIPS_UNREF( nifti-&gt;memory );
29 	VIPS_FREEF( nifti_image_free, nifti-&gt;nim );
30 	G_OBJECT_CLASS( vips_foreign_load_nifti_parent_class )-&gt;
31 		dispose( gobject );
32 }
33 static int
34 vips_foreign_load_nifti_build( VipsObject *object )
35 {
36 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
37 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
38 	if( nifti-&gt;source ) {
39 		nifti-&gt;filename = vips_connection_filename( VIPS_CONNECTION( 
40 			nifti-&gt;source ) );
41 		if( !nifti-&gt;filename ) {
42 			vips_error( class-&gt;nickname, "%s", 
43 				_( "no filename available" ) );
44 			return( -1 );
45 		}
46 	}
47 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nifti_parent_class )-&gt;
48 		build( object ) )
49 		return( -1 );
50 	return( 0 );
51 }
52 typedef struct _VipsForeignDT2Vips {
53 	int datatype;
54 	VipsBandFormat fmt;
55 } VipsForeignDT2Vips ;
56 static VipsForeignDT2Vips vips_foreign_nifti_DT2Vips[] = {
57 	{ DT_UINT8, VIPS_FORMAT_UCHAR },
58 	{ DT_INT8, VIPS_FORMAT_CHAR },
59 	{ DT_UINT16, VIPS_FORMAT_USHORT },
60 	{ DT_INT16, VIPS_FORMAT_SHORT },
61 	{ DT_UINT32, VIPS_FORMAT_UINT },
62 	{ DT_INT32, VIPS_FORMAT_INT },
63 	{ DT_FLOAT32, VIPS_FORMAT_FLOAT },
64 	{ DT_FLOAT64, VIPS_FORMAT_DOUBLE },
65 	{ DT_COMPLEX64, VIPS_FORMAT_COMPLEX },
66 	{ DT_COMPLEX128, VIPS_FORMAT_DPCOMPLEX },
67 	{ DT_RGB, VIPS_FORMAT_UCHAR },
68 	{ DT_RGBA32, VIPS_FORMAT_UCHAR }
69 };
70 VipsBandFormat
71 vips__foreign_nifti_datatype2BandFmt( int datatype )
72 {
73 	int i;
74 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_DT2Vips ); i++ )
75 		if( vips_foreign_nifti_DT2Vips[i].datatype == datatype )
76 			return( vips_foreign_nifti_DT2Vips[i].fmt );
77 	return( VIPS_FORMAT_NOTSET );
78 }
79 int
80 vips__foreign_nifti_BandFmt2datatype( VipsBandFormat fmt )
81 {
82 	int i;
83 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_DT2Vips ); i++ )
84 		if( vips_foreign_nifti_DT2Vips[i].fmt == fmt )
85 			return( vips_foreign_nifti_DT2Vips[i].datatype );
86 	return( -1 );
87 }
88 typedef struct _VipsForeignNiftiFields {
89 	char *name;
90 	GType type;
91 	glong offset;
92 } VipsForeignNiftiFields;
93 static VipsForeignNiftiFields vips_foreign_nifti_fields[] = {
94 	{ "ndim", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, ndim ) }, 
95 	{ "nx", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nx ) }, 
96 	{ "ny", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, ny ) }, 
97 	{ "nz", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nz ) }, 
98 	{ "nt", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nt ) }, 
99 	{ "nu", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nu ) }, 
100 	{ "nv", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nv ) }, 
101 	{ "nw", G_TYPE_INT, G_STRUCT_OFFSET( nifti_image, nw ) }, 
102 	{ "dx", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dx ) }, 
103 	{ "dy", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dy ) }, 
104 	{ "dz", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dz ) }, 
105 	{ "dt", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dt ) }, 
106 	{ "du", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, du ) }, 
107 	{ "dv", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dv ) }, 
108 	{ "dw", G_TYPE_DOUBLE, G_STRUCT_OFFSET( nifti_image, dw ) }, 
109 	{ "scl_slope", G_TYPE_DOUBLE, 
110 		G_STRUCT_OFFSET( nifti_image, scl_slope ) }, 
111 	{ "scl_inter", G_TYPE_DOUBLE, 
112 		G_STRUCT_OFFSET( nifti_image, scl_inter ) }, 
113 	{ "cal_min", G_TYPE_DOUBLE, 
114 		G_STRUCT_OFFSET( nifti_image, cal_min ) }, 
115 	{ "cal_max", G_TYPE_DOUBLE, 
116 		G_STRUCT_OFFSET( nifti_image, cal_max ) }, 
117 	{ "qform_code", G_TYPE_INT, 
118 		G_STRUCT_OFFSET( nifti_image, qform_code ) }, 
119 	{ "sform_code", G_TYPE_INT, 
120 		G_STRUCT_OFFSET( nifti_image, sform_code ) }, 
121 	{ "freq_dim", G_TYPE_INT, 
122 		G_STRUCT_OFFSET( nifti_image, freq_dim ) }, 
123 	{ "phase_dim", G_TYPE_INT, 
124 		G_STRUCT_OFFSET( nifti_image, phase_dim ) }, 
125 	{ "slice_dim", G_TYPE_INT, 
126 		G_STRUCT_OFFSET( nifti_image, slice_dim ) }, 
127 	{ "slice_code", G_TYPE_INT, 
128 		G_STRUCT_OFFSET( nifti_image, slice_code ) }, 
129 	{ "slice_start", G_TYPE_INT, 
130 		G_STRUCT_OFFSET( nifti_image, slice_start ) }, 
131 	{ "slice_end", G_TYPE_INT, 
132 		G_STRUCT_OFFSET( nifti_image, slice_end ) }, 
133 	{ "slice_duration", G_TYPE_DOUBLE, 
134 		G_STRUCT_OFFSET( nifti_image, slice_duration ) }, 
135 	{ "quatern_b", G_TYPE_DOUBLE, 
136 		G_STRUCT_OFFSET( nifti_image, quatern_b ) }, 
137 	{ "quatern_c", G_TYPE_DOUBLE, 
138 		G_STRUCT_OFFSET( nifti_image, quatern_c ) }, 
139 	{ "quatern_d", G_TYPE_DOUBLE, 
140 		G_STRUCT_OFFSET( nifti_image, quatern_d ) }, 
141 	{ "qoffset_x", G_TYPE_DOUBLE, 
142 		G_STRUCT_OFFSET( nifti_image, qoffset_x ) }, 
143 	{ "qoffset_y", G_TYPE_DOUBLE, 
144 		G_STRUCT_OFFSET( nifti_image, qoffset_y ) }, 
145 	{ "qoffset_z", G_TYPE_DOUBLE, 
146 		G_STRUCT_OFFSET( nifti_image, qoffset_z ) }, 
147 	{ "qfac", G_TYPE_DOUBLE, 
148 		G_STRUCT_OFFSET( nifti_image, qfac ) }, 
149 	{ "sto_xyz00", G_TYPE_DOUBLE, 
150 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][0] ) }, 
151 	{ "sto_xyz01", G_TYPE_DOUBLE, 
152 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][1] ) }, 
153 	{ "sto_xyz02", G_TYPE_DOUBLE, 
154 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][2] ) }, 
155 	{ "sto_xyz03", G_TYPE_DOUBLE, 
156 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[0][3] ) }, 
157 	{ "sto_xyz10", G_TYPE_DOUBLE, 
158 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][0] ) }, 
159 	{ "sto_xyz11", G_TYPE_DOUBLE, 
160 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][1] ) }, 
161 	{ "sto_xyz12", G_TYPE_DOUBLE, 
162 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][2] ) }, 
163 	{ "sto_xyz13", G_TYPE_DOUBLE, 
164 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[1][3] ) }, 
165 	{ "sto_xyz20", G_TYPE_DOUBLE, 
166 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][0] ) }, 
167 	{ "sto_xyz21", G_TYPE_DOUBLE, 
168 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][1] ) }, 
169 	{ "sto_xyz22", G_TYPE_DOUBLE, 
170 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][2] ) }, 
171 	{ "sto_xyz23", G_TYPE_DOUBLE, 
172 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[2][3] ) }, 
173 	{ "sto_xyz30", G_TYPE_DOUBLE, 
174 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][0] ) }, 
175 	{ "sto_xyz31", G_TYPE_DOUBLE, 
176 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][1] ) }, 
177 	{ "sto_xyz32", G_TYPE_DOUBLE, 
178 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][2] ) }, 
179 	{ "sto_xyz33", G_TYPE_DOUBLE, 
180 		G_STRUCT_OFFSET( nifti_image, sto_xyz.m[3][3] ) }, 
181 	{ "toffset", G_TYPE_DOUBLE, 
182 		G_STRUCT_OFFSET( nifti_image, toffset ) }, 
183 	{ "xyz_units", G_TYPE_INT, 
184 		G_STRUCT_OFFSET( nifti_image, xyz_units ) }, 
185 	{ "time_units", G_TYPE_INT, 
186 		G_STRUCT_OFFSET( nifti_image, time_units ) }, 
187 	{ "nifti_type", G_TYPE_INT, 
188 		G_STRUCT_OFFSET( nifti_image, nifti_type ) }, 
189 	{ "intent_code", G_TYPE_INT, 
190 		G_STRUCT_OFFSET( nifti_image, intent_code ) }, 
191 	{ "intent_p1", G_TYPE_DOUBLE, 
192 		G_STRUCT_OFFSET( nifti_image, intent_p1 ) }, 
193 	{ "intent_p2", G_TYPE_DOUBLE, 
194 		G_STRUCT_OFFSET( nifti_image, intent_p2 ) }, 
195 	{ "intent_p3", G_TYPE_DOUBLE, 
196 		G_STRUCT_OFFSET( nifti_image, intent_p3 ) }, 
197 };
198 void *
199 vips__foreign_nifti_map( VipsNiftiMapFn fn, void *a, void *b )
200 {
201 	int i;
202 	void *result;
203 	for( i = 0; i &lt; VIPS_NUMBER( vips_foreign_nifti_fields ); i++ ) {
204 		GValue value = { 0 };
205 		g_value_init( &amp;value, vips_foreign_nifti_fields[i].type );
206 		result = fn( vips_foreign_nifti_fields[i].name, &amp;value,
207 			vips_foreign_nifti_fields[i].offset, a, b );
208 		g_value_unset( &amp;value );
209 		if( result )
210 			return( result );
211 	}
212 	return( NULL );
213 }
214 static void
215 vips_gvalue_read( GValue *value, void *p )
216 {
217 	switch( G_VALUE_TYPE( value ) ) {
218 	case G_TYPE_INT:
219 		g_value_set_int( value, *((int *) p) );
220 		break;
221 	case G_TYPE_DOUBLE:
222 		g_value_set_double( value, *((float *) p) );
223 		break;
224 	default:
225 		g_warning( "vips_gvalue_read: unsupported GType %s", 
226 			g_type_name( G_VALUE_TYPE( value ) ) );
227 	}
228 }
229 static void *
230 vips_foreign_load_nifti_set( const char *name, GValue *value, glong offset,
231 	void *a, void *b )
232 {
233 	nifti_image *nim = (nifti_image *) a;
234 	VipsImage *out = VIPS_IMAGE( b );
235 	char vips_name[256];
236 	vips_gvalue_read( value, (gpointer) nim + offset );
237 	vips_snprintf( vips_name, 256, "nifti-%s", name );
238 	vips_image_set( out, vips_name, value );
239 	return( NULL );
240 }
241 static int
242 vips_foreign_load_nifti_set_header( VipsForeignLoadNifti *nifti,
243 	nifti_image *nim, VipsImage *out )
244 {
245 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( nifti );
246 	guint width;
247 	guint height;
248 	guint bands;
249 	VipsBandFormat fmt;
250 	double xres;
251 	double yres;
252 	int i;
253 	char txt[256];
254 	if( nim-&gt;ndim &lt; 1 ||
255 		nim-&gt;ndim &gt; 7 ) {
256 		vips_error( class-&gt;nickname, 
257 			_( "%d-dimensional images not supported" ), 
258 			nim-&gt;ndim ); 
259 		return( 0 );
260 	}
261 	for( i = 1; i &lt; 8 &amp;&amp; i &lt; nim-&gt;ndim + 1; i++ ) {
262 		if( nim-&gt;dim[i] &lt;= 0 ) {
263 			vips_error( class-&gt;nickname, 
264 				"%s", _( "invalid dimension" ) ); 
265 			return( 0 );
266 		}
267 		if( nim-&gt;dim[i] &gt; 1 &amp;&amp; 
268 			nim-&gt;pixdim[i] == 0 ) {
269 			vips_error( class-&gt;nickname, 
270 				"%s", _( "invalid resolution" ) ); 
271 			return( 0 );
272 		}
273 	}
274 	bands = 1;
275 	width = (guint) nim-&gt;nx;
276 	height = (guint) nim-&gt;ny;
277 	for( i = 3; i &lt; 8 &amp;&amp; i &lt; nim-&gt;ndim + 1; i++ )
278 		if( !g_uint_checked_mul( &amp;height, height, nim-&gt;dim[i] ) ) {
279 			vips_error( class-&gt;nickname, 
280 				"%s", _( "dimension overflow" ) ); 
281 			return( 0 );
282 		}
283 	if( height &gt; INT_MAX ) {
284 		vips_error( class-&gt;nickname, "%s", _( "dimension overflow" ) ); 
285 		return( 0 );
286 	}
287 	fmt = vips__foreign_nifti_datatype2BandFmt( nim-&gt;datatype );
288 	if( fmt == VIPS_FORMAT_NOTSET ) { 
289 		vips_error( class-&gt;nickname, 
290 			_( "datatype %d not supported" ), nim-&gt;datatype );
291 		return( -1 );
292 	}
293 	if( nim-&gt;datatype == DT_RGB )
294 		bands = 3;
295 	if( nim-&gt;datatype == DT_RGBA32 )
296 		bands = 4;
297 	xres = 1.0;
298 	yres = 1.0;
299 	if( nim-&gt;nz == 1 ||
300 		nim-&gt;dz == nim-&gt;dy ) 
301 		switch( nim-&gt;xyz_units ) {
302 		case NIFTI_UNITS_METER:
303 			xres = 1000.0 / nim-&gt;dx; 
304 			yres = 1000.0 / nim-&gt;dy; 
305 			break; 
306 		case NIFTI_UNITS_MM:
307 			xres = 1.0 / nim-&gt;dx; 
308 			yres = 1.0 / nim-&gt;dy; 
309 			break;
310 		case NIFTI_UNITS_MICRON:
311 			xres = 1.0 / (1000.0 * nim-&gt;dx); 
312 			yres = 1.0 / (1000.0 * nim-&gt;dy); 
313 			break;
314 		default:
315 			break;
316 		}
317 #ifdef DEBUG
318 	printf( "get_vips_properties: width = %d\n", width );
319 	printf( "get_vips_properties: height = %d\n", height );
320 	printf( "get_vips_properties: bands = %d\n", bands );
321 	printf( "get_vips_properties: fmt = %d\n", fmt );
322 	vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL );
323 	vips_image_init_fields( out,
324 		width, height, bands, fmt, 
325 		VIPS_CODING_NONE, 
326 		bands == 1 ? 
327 			VIPS_INTERPRETATION_B_W : VIPS_INTERPRETATION_sRGB, 
328 		xres, yres );
329 	if( vips__foreign_nifti_map( vips_foreign_load_nifti_set, nim, out ) )
330 		return( -1 ); 
331 	vips_strncpy( txt, nim-&gt;intent_name, 17 );
332 	vips_image_set_string( out, "nifti-intent_name", txt );
333 	vips_strncpy( txt, nim-&gt;descrip, 81 );
334 	vips_image_set_string( out, "nifti-descrip", txt );
335 	for( i = 0; i &lt; nim-&gt;num_ext; i++ ) {
336 		nifti1_extension *ext = &amp;nim-&gt;ext_list[i];
337 		vips_snprintf( txt, 256, "nifti-ext-%d-%d", i, ext-&gt;ecode );
338 		vips_image_set_blob_copy( out, txt, ext-&gt;edata, ext-&gt;esize );
339 	}
340 	vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, nim-&gt;ny );
341 	return( 0 );
342 }
343 static int
344 vips_foreign_load_nifti_header( VipsForeignLoad *load )
345 {
346 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
347 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) load;
348 	if( !(nifti-&gt;nim = nifti_image_read( nifti-&gt;filename, FALSE )) ) { 
349 		vips_error( class-&gt;nickname, 
350 			"%s", _( "unable to read NIFTI header" ) );
351 		return( 0 );
352 	}
353 	if( vips_foreign_load_nifti_set_header( nifti, 
354 		nifti-&gt;nim, load-&gt;out ) ) {
355 		return( -1 );
356 	}
357 	VIPS_SETSTR( load-&gt;out-&gt;filename, nifti-&gt;filename );
358 	return( 0 );
359 }
360 static int
361 vips_foreign_load_nifti_load( VipsForeignLoad *load )
362 {
363 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
364 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) load;
365 #ifdef DEBUG
366 	printf( "vips_foreign_load_nifti_load: loading image\n" );
367 	if( nifti_image_load( nifti-&gt;nim ) ) {
368 		vips_error( class-&gt;nickname, 
369 			"%s", _( "unable to load NIFTI file" ) );
370 		return( -1 );
371 	}
372 	if( !(nifti-&gt;memory = vips_image_new_from_memory( 
373 		nifti-&gt;nim-&gt;data, VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out ),
374 		load-&gt;out-&gt;Xsize, load-&gt;out-&gt;Ysize, 
375 		load-&gt;out-&gt;Bands, load-&gt;out-&gt;BandFmt )) ) 
376 		return( -1 );
377 	if( vips_image_write( nifti-&gt;memory, load-&gt;real ) )
378 		return( -1 );
379 	return( 0 );
380 }
381 static void
382 vips_foreign_load_nifti_class_init( VipsForeignLoadNiftiClass *class )
383 {
384 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
385 	VipsObjectClass *object_class = (VipsObjectClass *) class;
386 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
387 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
388 	gobject_class-&gt;dispose = vips_foreign_load_nifti_dispose;
389 	gobject_class-&gt;set_property = vips_object_set_property;
390 	gobject_class-&gt;get_property = vips_object_get_property;
391 	object_class-&gt;nickname = "niftiload_base";
392 	object_class-&gt;description = _( "load a NIFTI image" );
393 	object_class-&gt;build = vips_foreign_load_nifti_build;
394 	foreign_class-&gt;priority = -50;
395 	load_class-&gt;header = vips_foreign_load_nifti_header;
396 	load_class-&gt;load = vips_foreign_load_nifti_load;
397 }
398 static void
399 vips_foreign_load_nifti_init( VipsForeignLoadNifti *nifti )
400 {
401 }
402 typedef struct _VipsForeignLoadNiftiFile {
403 	VipsForeignLoadNifti parent_object;
404 	char *filename; 
405 } VipsForeignLoadNiftiFile;
406 typedef VipsForeignLoadNiftiClass VipsForeignLoadNiftiFileClass;
407 G_DEFINE_TYPE( VipsForeignLoadNiftiFile, vips_foreign_load_nifti_file, 
408 	vips_foreign_load_nifti_get_type() );
409 static int
410 vips_foreign_load_nifti_file_build( VipsObject *object )
411 {
412 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
413 	VipsForeignLoadNiftiFile *file = (VipsForeignLoadNiftiFile *) object;
414 	if( file-&gt;filename &amp;&amp;
415 		!(nifti-&gt;source = 
416 			vips_source_new_from_file( file-&gt;filename )) )
417 		return( -1 );
418 	if( VIPS_OBJECT_CLASS( vips_foreign_load_nifti_file_parent_class )-&gt;
419 		build( object ) )
420 		return( -1 );
421 	return( 0 );
422 }
423 const char *vips_foreign_nifti_suffs[] = { 
424 	".nii", ".nii.gz", 
425 	".hdr", ".hdr.gz", 
426 	".img", ".img.gz", 
427 	".nia", ".nia.gz", 
428 	NULL 
429 };
430 static int
431 vips_foreign_load_nifti_is_a( const char *filename )
432 {
433 	char *hfile;
434 	znzFile fp;
435 	nifti_1_header nhdr;
436 	if( !(hfile = nifti_findhdrname( filename )) )
437 		return( 0 );
438 	fp = znzopen( hfile, "rb", nifti_is_gzfile( hfile ));
439 	if( znz_isnull( fp ) ) { 
440 		free( hfile );
441 		return( 0 );
442 	}
443 	free( hfile );
444 	(void) znzread( &amp;nhdr, 1, sizeof( nhdr ), fp );
445 	znzclose( fp );
446 	if( nifti_hdr_looks_good( &amp;nhdr ) ) 
447 		return( 1 );
448 	swap_nifti_header( &amp;nhdr, FALSE );
449 	if( nifti_hdr_looks_good( &amp;nhdr ) ) 
450 		return( 1 );
451 	return( 0 );
452 }
453 static void
454 vips_foreign_load_nifti_file_class_init( 
455 	VipsForeignLoadNiftiFileClass *class )
456 {
457 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
458 	VipsObjectClass *object_class = (VipsObjectClass *) class;
459 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
460 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
461 	gobject_class-&gt;set_property = vips_object_set_property;
462 	gobject_class-&gt;get_property = vips_object_get_property;
463 	object_class-&gt;nickname = "niftiload";
464 	object_class-&gt;description = _( "load NIfTI volume" );
465 	object_class-&gt;build = vips_foreign_load_nifti_file_build;
466 	foreign_class-&gt;suffs = vips_foreign_nifti_suffs;
467 	load_class-&gt;is_a = vips_foreign_load_nifti_is_a;
468 	VIPS_ARG_STRING( class, "filename", 1, 
469 		_( "Filename" ),
470 		_( "Filename to load from" ),
471 		VIPS_ARGUMENT_REQUIRED_INPUT, 
472 		G_STRUCT_OFFSET( VipsForeignLoadNiftiFile, filename ),
473 		NULL );
474 }
475 static void
476 vips_foreign_load_nifti_file_init( VipsForeignLoadNiftiFile *nifti )
477 {
478 }
479 typedef struct _VipsForeignLoadNiftiSource {
480 	VipsForeignLoadNifti parent_object;
481 	VipsSource *source;
482 } VipsForeignLoadNiftiSource;
483 typedef VipsForeignLoadNiftiClass VipsForeignLoadNiftiSourceClass;
484 G_DEFINE_TYPE( VipsForeignLoadNiftiSource, vips_foreign_load_nifti_source, 
485 	vips_foreign_load_nifti_get_type() );
486 static int
487 vips_foreign_load_nifti_source_build( VipsObject *object )
488 {
489 	VipsForeignLoadNifti *nifti = (VipsForeignLoadNifti *) object;
490 	VipsForeignLoadNiftiSource *source = 
491 		(VipsForeignLoadNiftiSource *) object;
492 	if( source-&gt;source ) {
493 		nifti-&gt;source = source-&gt;source;
494 		g_object_ref( nifti-&gt;source );
495 	}
496 	if( VIPS_OBJECT_CLASS( 
497 		vips_foreign_load_nifti_source_parent_class )-&gt;
498 			build( object ) )
499 		return( -1 );
500 	return( 0 );
501 }
502 static gboolean
503 vips_foreign_load_nifti_source_is_a_source( VipsSource *source )
504 {
505 	const char *filename;
506 <a name="0"></a>	return( (filename = 
507 		vips_connection_filename( VIPS_CONNECTION( source ) )) &amp;&amp;
508 		vips_foreign_load_nifti_is_a( filename ) );
509 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
510 static void
511 vips_foreign_load_nifti_source_class_init( 
512 	VipsForeignLoadNiftiSourceClass *class )
513 {
514 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
515 	VipsObjectClass *object_class = (VipsObjectClass *) class;
516 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
517 	gobject_class-&gt;set_property = vips_object_set_property;
518 	gobject_class-&gt;get_property = vips_object_get_property;
519 	object_class-&gt;nickname = "niftiload_source";
520 	object_class-&gt;description = _( "load NIfTI volumes" );
521 	object_class-&gt;build = vips_foreign_load_nifti_source_build;
522 	load_class-&gt;is_a_source = 
523 		vips_foreign_load_nifti_source_is_a_source;
524 	VIPS_ARG_OBJECT( class, "source", 1,</b></font>
525 		_( "Source" ),
526 		_( "Source to load from" ),
527 		VIPS_ARGUMENT_REQUIRED_INPUT, 
528 		G_STRUCT_OFFSET( VipsForeignLoadNiftiSource, source ),
529 		VIPS_TYPE_SOURCE );
530 }
531 static void
532 vips_foreign_load_nifti_source_init( 
533 	VipsForeignLoadNiftiSource *nifti )
534 {
535 }
536 int
537 vips_niftiload( const char *filename, VipsImage **out, ... )
538 {
539 	va_list ap;
540 	int result;
541 	va_start( ap, out );
542 	result = vips_call_split( "niftiload", ap, filename, out );
543 	va_end( ap );
544 	return( result );
545 }
546 int
547 vips_niftiload_source( VipsSource *source, VipsImage **out, ... )
548 {
549 	va_list ap;
550 	int result;
551 	va_start( ap, out );
552 	result = vips_call_split( "niftiload_source", ap, source, out );
553 	va_end( ap );
554 	return( result );
555 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
