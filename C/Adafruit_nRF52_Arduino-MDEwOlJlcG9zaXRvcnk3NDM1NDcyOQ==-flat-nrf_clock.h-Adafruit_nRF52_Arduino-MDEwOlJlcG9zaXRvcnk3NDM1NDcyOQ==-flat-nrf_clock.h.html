
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_clock.h</h3>
            <pre><code>1  #ifndef NRF_CLOCK_H__
2  #define NRF_CLOCK_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(CLOCK_LFCLKSRC_BYPASS_Msk) && defined(CLOCK_LFCLKSRC_EXTERNAL_Msk)
8  #define NRF_CLOCK_USE_EXTERNAL_LFCLK_SOURCES
9  #endif
10  #if defined(CLOCK_INTENSET_DONE_Msk) || defined(__NRFX_DOXYGEN__)
11  #define NRF_CLOCK_HAS_CALIBRATION 1
12  #else
13  #define NRF_CLOCK_HAS_CALIBRATION 0
14  #endif
15  #if defined(CLOCK_CTIV_CTIV_Msk) || defined(__NRFX_DOXYGEN__)
16  #define NRF_CLOCK_HAS_CALIBRATION_TIMER 1
17  #else
18  #define NRF_CLOCK_HAS_CALIBRATION_TIMER 0
19  #endif
20  #if (defined(CLOCK_INTENSET_HFCLK192MSTARTED_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
21      || defined(__NRFX_DOXYGEN__)
22  #define NRF_CLOCK_HAS_HFCLK192M 1
23  #else
24  #define NRF_CLOCK_HAS_HFCLK192M 0
25  #endif
26  #if (defined(CLOCK_INTENSET_HFCLKAUDIOSTARTED_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
27      || defined(__NRFX_DOXYGEN__)
28  #define NRF_CLOCK_HAS_HFCLKAUDIO 1
29  #else
30  #define NRF_CLOCK_HAS_HFCLKAUDIO 0
31  #endif
32  #if (defined(CLOCK_HFCLKCTRL_HCLK_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
33      || defined(__NRFX_DOXYGEN__)
34  #define NRF_CLOCK_HAS_HFCLK_DIV 1
35  #else
36  #define NRF_CLOCK_HAS_HFCLK_DIV 0
37  #endif
38  #if defined(CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk) || defined(__NRFX_DOXYGEN__)
39  #define NRF_CLOCK_HAS_ALWAYSRUN 1
40  #else
41  #define NRF_CLOCK_HAS_ALWAYSRUN 0
42  #endif
43  #if defined(CLOCK_HFCLKSRC_SRC_Msk) || defined(__NRFX_DOXYGEN__)
44  #define NRF_CLOCK_HAS_HFCLKSRC 1
45  #else
46  #define NRF_CLOCK_HAS_HFCLKSRC 0
47  #endif
48  typedef enum
49  {
50  #if defined(CLOCK_LFCLKSRC_SRC_LFULP) || defined(__NRFX_DOXYGEN__)
51      NRF_CLOCK_LFCLK_LFULP = CLOCK_LFCLKSRC_SRC_LFULP, &bsol;**< Internal 32 kHz Ultra-low power oscillator. */
52  #endif
53  #if defined(CLOCK_LFCLKSRC_SRC_RC) || defined(__NRFX_DOXYGEN__)
54      NRF_CLOCK_LFCLK_RC    = CLOCK_LFCLKSRC_SRC_RC,    &bsol;**< Internal 32 kHz RC oscillator. */
55  #else
56      NRF_CLOCK_LFCLK_RC    = CLOCK_LFCLKSRC_SRC_LFRC,  &bsol;**< Internal 32 kHz RC oscillator. */
57  #endif
58  #if defined(CLOCK_LFCLKSRC_SRC_Xtal) || defined(__NRFX_DOXYGEN__)
59      NRF_CLOCK_LFCLK_Xtal  = CLOCK_LFCLKSRC_SRC_Xtal,  &bsol;**< External 32 kHz crystal. */
60  #else
61      NRF_CLOCK_LFCLK_Xtal  = CLOCK_LFCLKSRC_SRC_LFXO,  &bsol;**< External 32 kHz crystal. */
62  #endif
63  #if defined(CLOCK_LFCLKSRC_SRC_Synth) || defined(__NRFX_DOXYGEN__)
64      NRF_CLOCK_LFCLK_Synth = CLOCK_LFCLKSRC_SRC_Synth, &bsol;**< Internal 32 kHz synthesizer from HFCLK system clock. */
65  #endif
66  #if defined(NRF_CLOCK_USE_EXTERNAL_LFCLK_SOURCES) || defined(__NRFX_DOXYGEN__)
67      NRF_CLOCK_LFCLK_Xtal_Low_Swing = (CLOCK_LFCLKSRC_SRC_Xtal |
68          (CLOCK_LFCLKSRC_EXTERNAL_Enabled << CLOCK_LFCLKSRC_EXTERNAL_Pos)),
69      NRF_CLOCK_LFCLK_Xtal_Full_Swing = (CLOCK_LFCLKSRC_SRC_Xtal |
70          (CLOCK_LFCLKSRC_BYPASS_Enabled   << CLOCK_LFCLKSRC_BYPASS_Pos) |
71          (CLOCK_LFCLKSRC_EXTERNAL_Enabled << CLOCK_LFCLKSRC_EXTERNAL_Pos)),
72  #endif 
73  } nrf_clock_lfclk_t;
74  typedef enum
75  {
76  #if defined(CLOCK_HFCLKSTAT_SRC_RC) || defined(__NRFX_DOXYGEN__)
77      NRF_CLOCK_HFCLK_LOW_ACCURACY  = CLOCK_HFCLKSTAT_SRC_RC,  &bsol;**< Internal 16 MHz RC oscillator. */
78  #elif defined(CLOCK_HFCLKSTAT_SRC_HFINT)
<span onclick='openModal()' class='match'>79      NRF_CLOCK_HFCLK_LOW_ACCURACY  = CLOCK_HFCLKSTAT_SRC_HFINT,  &bsol;**< Internal 16 MHz RC oscillator. */
80  #endif
</span>81  #if defined(CLOCK_HFCLKSTAT_SRC_Xtal) || defined(__NRFX_DOXYGEN__)
82      NRF_CLOCK_HFCLK_HIGH_ACCURACY = CLOCK_HFCLKSTAT_SRC_Xtal &bsol;**< External 16 MHz/32 MHz crystal oscillator. */
83  #else
84      NRF_CLOCK_HFCLK_HIGH_ACCURACY = CLOCK_HFCLKSTAT_SRC_HFXO &bsol;**< External 32 MHz crystal oscillator. */
85  #endif
86  } nrf_clock_hfclk_t;
87  typedef enum
88  {
89      NRF_CLOCK_DOMAIN_LFCLK,
90      NRF_CLOCK_DOMAIN_HFCLK,
91  #if NRF_CLOCK_HAS_HFCLK192M
92      NRF_CLOCK_DOMAIN_HFCLK192M,
93  #endif
94  #if NRF_CLOCK_HAS_HFCLKAUDIO
95      NRF_CLOCK_DOMAIN_HFCLKAUDIO,
96  #endif
97  } nrf_clock_domain_t;
98  #if NRF_CLOCK_HAS_HFCLK_DIV || NRF_CLOCK_HAS_HFCLK192M
99  typedef enum
100  {
101      NRF_CLOCK_HFCLK_DIV_1 = CLOCK_HFCLKCTRL_HCLK_Div1,         &bsol;**< Divide HFCLK/HFCLK192M by 1 */
102      NRF_CLOCK_HFCLK_DIV_2 = CLOCK_HFCLKCTRL_HCLK_Div2,         &bsol;**< Divide HFCLK/HFCLK192M by 2 */
103  #if NRF_CLOCK_HAS_HFCLK192M
104      NRF_CLOCK_HFCLK_DIV_4 = CLOCK_HFCLK192MCTRL_HCLK192M_Div4, &bsol;**< Divide HFCLK192M by 4 */
105  #endif
106  } nrf_clock_hfclk_div_t;
107  #endif 
108  typedef enum
109  {
110      NRF_CLOCK_START_TASK_NOT_TRIGGERED = CLOCK_LFCLKRUN_STATUS_NotTriggered, &bsol;**< Task LFCLKSTART/HFCLKSTART has not been triggered. */
111      NRF_CLOCK_START_TASK_TRIGGERED     = CLOCK_LFCLKRUN_STATUS_Triggered     &bsol;**< Task LFCLKSTART/HFCLKSTART has been triggered. */
112  } nrf_clock_start_task_status_t;
113  typedef enum
114  {
115      NRF_CLOCK_INT_HF_STARTED_MASK      = CLOCK_INTENSET_HFCLKSTARTED_Msk,      &bsol;**< Interrupt on HFCLKSTARTED event. */
116      NRF_CLOCK_INT_LF_STARTED_MASK      = CLOCK_INTENSET_LFCLKSTARTED_Msk,      &bsol;**< Interrupt on LFCLKSTARTED event. */
117  #if NRF_CLOCK_HAS_CALIBRATION
118      NRF_CLOCK_INT_DONE_MASK            = CLOCK_INTENSET_DONE_Msk,              &bsol;**< Interrupt on DONE event. */
119  #endif
120  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
121      NRF_CLOCK_INT_CTTO_MASK            = CLOCK_INTENSET_CTTO_Msk,              &bsol;**< Interrupt on CTTO event. */
122  #endif
123  #if defined(CLOCK_INTENSET_CTSTARTED_Msk) || defined(__NRFX_DOXYGEN__)
124      NRF_CLOCK_INT_CTSTARTED_MASK       = CLOCK_INTENSET_CTSTARTED_Msk,         &bsol;**< Interrupt on CTSTARTED event. */
125      NRF_CLOCK_INT_CTSTOPPED_MASK       = CLOCK_INTENSET_CTSTOPPED_Msk          &bsol;**< Interrupt on CTSTOPPED event. */
126  #endif
127  #if NRF_CLOCK_HAS_HFCLKAUDIO
128      NRF_CLOCK_INT_HFAUDIO_STARTED_MASK = CLOCK_INTENSET_HFCLKAUDIOSTARTED_Msk, &bsol;**< Interrupt on HFCLKAUDIOSTARTED event. */
129  #endif
130  #if NRF_CLOCK_HAS_HFCLK192M
131      NRF_CLOCK_INT_HF192M_STARTED_MASK  = CLOCK_INTENSET_HFCLK192MSTARTED_Msk,  &bsol;**< Interrupt on HFCLK192MSTARTED event. */
132  #endif
133  } nrf_clock_int_mask_t;
134  typedef enum
135  {
136      NRF_CLOCK_TASK_HFCLKSTART      = offsetof(NRF_CLOCK_Type, TASKS_HFCLKSTART),      &bsol;**< Start HFCLK clock source. */
137      NRF_CLOCK_TASK_HFCLKSTOP       = offsetof(NRF_CLOCK_Type, TASKS_HFCLKSTOP),       &bsol;**< Stop HFCLK clock source. */
138      NRF_CLOCK_TASK_LFCLKSTART      = offsetof(NRF_CLOCK_Type, TASKS_LFCLKSTART),      &bsol;**< Start LFCLK clock source. */
139      NRF_CLOCK_TASK_LFCLKSTOP       = offsetof(NRF_CLOCK_Type, TASKS_LFCLKSTOP),       &bsol;**< Stop LFCLK clock source. */
140  #if NRF_CLOCK_HAS_CALIBRATION
141      NRF_CLOCK_TASK_CAL             = offsetof(NRF_CLOCK_Type, TASKS_CAL),             &bsol;**< Start calibration of LFCLK RC oscillator. */
142  #endif
143  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
144      NRF_CLOCK_TASK_CTSTART         = offsetof(NRF_CLOCK_Type, TASKS_CTSTART),         &bsol;**< Start calibration timer. */
145      NRF_CLOCK_TASK_CTSTOP          = offsetof(NRF_CLOCK_Type, TASKS_CTSTOP)           &bsol;**< Stop calibration timer. */
146  #endif
147  #if NRF_CLOCK_HAS_HFCLKAUDIO
148      NRF_CLOCK_TASK_HFCLKAUDIOSTART = offsetof(NRF_CLOCK_Type, TASKS_HFCLKAUDIOSTART), &bsol;**< Start HFCLKAUDIO clock source. */
149      NRF_CLOCK_TASK_HFCLKAUDIOSTOP  = offsetof(NRF_CLOCK_Type, TASKS_HFCLKAUDIOSTOP),  &bsol;**< Stop HFCLKAUDIO clock source. */
150  #endif
151  #if NRF_CLOCK_HAS_HFCLK192M
152      NRF_CLOCK_TASK_HFCLK192MSTART  = offsetof(NRF_CLOCK_Type, TASKS_HFCLK192MSTART),  &bsol;**< Start HFCLK192M clock source. */
153      NRF_CLOCK_TASK_HFCLK192MSTOP   = offsetof(NRF_CLOCK_Type, TASKS_HFCLK192MSTOP),   &bsol;**< Stop HFCLK192M clock source. */
154  #endif
155  } nrf_clock_task_t;
156  typedef enum
157  {
158      NRF_CLOCK_EVENT_HFCLKSTARTED      = offsetof(NRF_CLOCK_Type, EVENTS_HFCLKSTARTED),      &bsol;**< HFCLK oscillator started. */
159      NRF_CLOCK_EVENT_LFCLKSTARTED      = offsetof(NRF_CLOCK_Type, EVENTS_LFCLKSTARTED),      &bsol;**< LFCLK oscillator started. */
160  #if NRF_CLOCK_HAS_CALIBRATION
161      NRF_CLOCK_EVENT_DONE              = offsetof(NRF_CLOCK_Type, EVENTS_DONE),              &bsol;**< Calibration of LFCLK RC oscillator completed. */
162  #endif
163  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
164      NRF_CLOCK_EVENT_CTTO              = offsetof(NRF_CLOCK_Type, EVENTS_CTTO),              &bsol;**< Calibration timer time-out. */
165  #endif
166  #if defined(CLOCK_INTENSET_CTSTARTED_Msk) || defined(__NRFX_DOXYGEN__)
167      NRF_CLOCK_EVENT_CTSTARTED         = offsetof(NRF_CLOCK_Type, EVENTS_CTSTARTED),         &bsol;**< Calibration timer started. */
168      NRF_CLOCK_EVENT_CTSTOPPED         = offsetof(NRF_CLOCK_Type, EVENTS_CTSTOPPED)          &bsol;**< Calibration timer stopped. */
169  #endif
170  #if NRF_CLOCK_HAS_HFCLKAUDIO
171      NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED = offsetof(NRF_CLOCK_Type, EVENTS_HFCLKAUDIOSTARTED), &bsol;**< HFCLKAUDIO oscillator started. */
172  #endif
173  #if NRF_CLOCK_HAS_HFCLK192M
174      NRF_CLOCK_EVENT_HFCLK192MSTARTED  = offsetof(NRF_CLOCK_Type, EVENTS_HFCLK192MSTARTED),  &bsol;**< HFCLK192M oscillator started. */
175  #endif
176  } nrf_clock_event_t;
177  NRF_STATIC_INLINE void nrf_clock_int_enable(NRF_CLOCK_Type * p_reg, uint32_t mask);
178  NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask);
179  NRF_STATIC_INLINE uint32_t nrf_clock_int_enable_check(NRF_CLOCK_Type const * p_reg, uint32_t mask);
180  NRF_STATIC_INLINE uint32_t nrf_clock_task_address_get(NRF_CLOCK_Type const * p_reg,
181                                                        nrf_clock_task_t       task);
182  NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task);
183  NRF_STATIC_INLINE uint32_t nrf_clock_event_address_get(NRF_CLOCK_Type const * p_reg,
184                                                         nrf_clock_event_t      event);
185  NRF_STATIC_INLINE void nrf_clock_event_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event);
186  NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event);
187  NRF_STATIC_INLINE bool nrf_clock_start_task_check(NRF_CLOCK_Type const * p_reg,
188                                                    nrf_clock_domain_t     domain);
189  NRF_STATIC_INLINE bool nrf_clock_is_running(NRF_CLOCK_Type const * p_reg,
190                                              nrf_clock_domain_t     domain,
191                                              void *                 clk_src);
192  NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source);
193  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_src_get(NRF_CLOCK_Type const * p_reg);
194  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_actv_src_get(NRF_CLOCK_Type const * p_reg);
195  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg);
196  NRF_STATIC_INLINE bool nrf_clock_lf_is_running(NRF_CLOCK_Type const * p_reg);
197  NRF_STATIC_INLINE
198  nrf_clock_start_task_status_t nrf_clock_lf_start_task_status_get(NRF_CLOCK_Type const * p_reg);
199  #if NRF_CLOCK_HAS_HFCLKSRC
200  NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source);
201  #endif
202  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hf_src_get(NRF_CLOCK_Type const * p_reg);
203  NRF_STATIC_INLINE bool nrf_clock_hf_is_running(NRF_CLOCK_Type const * p_reg,
204                                                 nrf_clock_hfclk_t      clk_src);
205  NRF_STATIC_INLINE
206  nrf_clock_start_task_status_t nrf_clock_hf_start_task_status_get(NRF_CLOCK_Type const * p_reg);
207  #if NRF_CLOCK_HAS_HFCLKAUDIO
208  NRF_STATIC_INLINE
209  void nrf_clock_hfclkaudio_config_set(NRF_CLOCK_Type * p_reg, uint16_t freq_value);
210  NRF_STATIC_INLINE
211  uint16_t nrf_clock_hfclkaudio_config_get(NRF_CLOCK_Type const * p_reg);
212  #endif
213  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
214  NRF_STATIC_INLINE void nrf_clock_cal_timer_timeout_set(NRF_CLOCK_Type * p_reg, uint32_t interval);
215  #endif
216  #if NRF_CLOCK_HAS_HFCLK_DIV
217  NRF_STATIC_INLINE void nrf_clock_hfclk_div_set(NRF_CLOCK_Type *      p_reg,
218                                                 nrf_clock_hfclk_div_t divider);
219  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg);
220  #endif
221  #if NRF_CLOCK_HAS_HFCLK192M
222  NRF_STATIC_INLINE void nrf_clock_hfclk192m_div_set(NRF_CLOCK_Type *      p_reg,
223                                                     nrf_clock_hfclk_div_t divider);
224  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk192m_div_get(NRF_CLOCK_Type const * p_reg);
225  NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type *  p_reg,
226                                                     nrf_clock_hfclk_t source);
227  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hfclk192m_src_get(NRF_CLOCK_Type const * p_reg);
228  #endif 
229  #if NRF_CLOCK_HAS_ALWAYSRUN
230  NRF_STATIC_INLINE void nrf_clock_alwaysrun_set(NRF_CLOCK_Type const * p_reg,
231                                                 nrf_clock_domain_t     domain,
232                                                 bool                   alwaysrun);
233  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_get(NRF_CLOCK_Type const * p_reg,
234                                                 nrf_clock_domain_t     domain);
235  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_active_get(NRF_CLOCK_Type const * p_reg,
236                                                        nrf_clock_domain_t     domain);
237  #endif
238  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
239  NRF_STATIC_INLINE void nrf_clock_subscribe_set(NRF_CLOCK_Type * p_reg,
240                                                 nrf_clock_task_t task,
241                                                 uint8_t          channel);
242  NRF_STATIC_INLINE void nrf_clock_subscribe_clear(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task);
243  NRF_STATIC_INLINE void nrf_clock_publish_set(NRF_CLOCK_Type *  p_reg,
244                                               nrf_clock_event_t event,
245                                               uint8_t           channel);
246  NRF_STATIC_INLINE void nrf_clock_publish_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event);
247  #endif 
248  #ifndef NRF_DECLARE_ONLY
249  NRF_STATIC_INLINE void nrf_clock_int_enable(NRF_CLOCK_Type * p_reg, uint32_t mask)
250  {
251      p_reg->INTENSET = mask;
252  }
253  NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
254  {
255      p_reg->INTENCLR = mask;
256  }
257  NRF_STATIC_INLINE uint32_t nrf_clock_int_enable_check(NRF_CLOCK_Type const * p_reg, uint32_t mask)
258  {
259      return p_reg->INTENSET & mask;
260  }
261  NRF_STATIC_INLINE uint32_t nrf_clock_task_address_get(NRF_CLOCK_Type const * p_reg,
262                                                        nrf_clock_task_t       task)
263  {
264      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
265  }
266  NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
267  {
268      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
269  }
270  NRF_STATIC_INLINE uint32_t nrf_clock_event_address_get(NRF_CLOCK_Type const * p_reg,
271                                                         nrf_clock_event_t      event)
272  {
273      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
274  }
275  NRF_STATIC_INLINE void nrf_clock_event_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event)
276  {
277      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
278  #if __CORTEX_M == 0x04
279      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
280      (void)dummy;
281  #endif
282  }
283  NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
284  {
285      return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
286  }
287  NRF_STATIC_INLINE bool nrf_clock_start_task_check(NRF_CLOCK_Type const * p_reg,
288                                                    nrf_clock_domain_t     domain)
289  {
290      switch (domain)
291      {
292          case NRF_CLOCK_DOMAIN_LFCLK:
293              return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
294                      >> CLOCK_LFCLKRUN_STATUS_Pos);
295          case NRF_CLOCK_DOMAIN_HFCLK:
296              return ((p_reg->HFCLKRUN & CLOCK_HFCLKRUN_STATUS_Msk)
297                      >> CLOCK_HFCLKRUN_STATUS_Pos);
298  #if NRF_CLOCK_HAS_HFCLK192M
299          case NRF_CLOCK_DOMAIN_HFCLK192M:
300              return ((p_reg->HFCLK192MRUN & CLOCK_HFCLK192MRUN_STATUS_Msk)
301                      >> CLOCK_HFCLK192MRUN_STATUS_Pos);
302  #endif
303  #if NRF_CLOCK_HAS_HFCLKAUDIO
304          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
305              return ((p_reg->HFCLKAUDIORUN & CLOCK_HFCLKAUDIORUN_STATUS_Msk)
306                      >> CLOCK_HFCLKAUDIORUN_STATUS_Pos);
307  #endif
308          default:
309              NRFX_ASSERT(0);
310              return false;
311      }
312  }
313  NRF_STATIC_INLINE bool nrf_clock_is_running(NRF_CLOCK_Type const * p_reg,
314                                              nrf_clock_domain_t     domain,
315                                              void *                 clk_src)
316  {
317      switch (domain)
318      {
319          case NRF_CLOCK_DOMAIN_LFCLK:
320              if (clk_src != NULL)
321              {
322                  (*(uint32_t *)clk_src) = ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
323                                            >> CLOCK_LFCLKSTAT_SRC_Pos);
324              }
325              if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
326                  >> CLOCK_LFCLKSTAT_STATE_Pos)
327              {
328                  return true;
329              }
330              break;
331          case NRF_CLOCK_DOMAIN_HFCLK:
332              if (clk_src != NULL)
333              {
334                  (*(uint32_t *)clk_src) = ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
335                                            >> CLOCK_HFCLKSTAT_SRC_Pos);
336              }
337              if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
338                  >> CLOCK_HFCLKSTAT_STATE_Pos)
339              {
340                  return true;
341              }
342              break;
343  #if NRF_CLOCK_HAS_HFCLK192M
344          case NRF_CLOCK_DOMAIN_HFCLK192M:
345              if (clk_src != NULL)
346              {
347                  (*(uint32_t *)clk_src) = ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
348                                            >> CLOCK_HFCLK192MSTAT_SRC_Pos);
349              }
350              if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
351                  >> CLOCK_HFCLK192MSTAT_STATE_Pos)
352              {
353                  return true;
354              }
355              break;
356  #endif
357  #if NRF_CLOCK_HAS_HFCLKAUDIO
358          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
359              return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
360                     CLOCK_HFCLKAUDIOSTAT_STATE_Msk;
361  #endif
362          default:
363              NRFX_ASSERT(0);
364              return false;
365      }
366      return false;
367  }
368  NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
369  {
370      p_reg->LFCLKSRC = (uint32_t)(source);
371  }
372  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_src_get(NRF_CLOCK_Type const * p_reg)
373  {
374      return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
375  }
376  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_actv_src_get(NRF_CLOCK_Type const * p_reg)
377  {
378      nrf_clock_lfclk_t clk_src;
379      (void)nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_LFCLK, &clk_src);
380      return clk_src;
381  }
382  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
383  {
384      return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
385                                  >> CLOCK_LFCLKSRCCOPY_SRC_Pos);
386  }
387  NRF_STATIC_INLINE bool nrf_clock_lf_is_running(NRF_CLOCK_Type const * p_reg)
388  {
389      return nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_LFCLK, NULL);
390  }
391  NRF_STATIC_INLINE
392  nrf_clock_start_task_status_t nrf_clock_lf_start_task_status_get(NRF_CLOCK_Type const * p_reg)
393  {
394      return (nrf_clock_start_task_status_t)nrf_clock_start_task_check(p_reg,
395                                                                       NRF_CLOCK_DOMAIN_LFCLK);
396  }
397  #if NRF_CLOCK_HAS_HFCLKSRC
398  NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
399  {
400      p_reg->HFCLKSRC = (uint32_t)(source);
401  }
402  #endif
403  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hf_src_get(NRF_CLOCK_Type const * p_reg)
404  {
405  #if NRF_CLOCK_HAS_HFCLKSRC
406      return (nrf_clock_hfclk_t)(p_reg->HFCLKSRC);
407  #else
408      return (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
409                                  >> CLOCK_HFCLKSTAT_SRC_Pos);
410  #endif
411  }
412  NRF_STATIC_INLINE bool nrf_clock_hf_is_running(NRF_CLOCK_Type const * p_reg,
413                                                 nrf_clock_hfclk_t      clk_src)
414  {
415      nrf_clock_hfclk_t active_clk_src;
416      bool ret = nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_HFCLK, &active_clk_src);
417      return (ret && (active_clk_src == clk_src));
418  }
419  NRF_STATIC_INLINE
420  nrf_clock_start_task_status_t nrf_clock_hf_start_task_status_get(NRF_CLOCK_Type const * p_reg)
421  {
422      return (nrf_clock_start_task_status_t)nrf_clock_start_task_check(p_reg,
423                                                                       NRF_CLOCK_DOMAIN_HFCLK);
424  }
425  #if NRF_CLOCK_HAS_HFCLKAUDIO
426  NRF_STATIC_INLINE
427  void nrf_clock_hfclkaudio_config_set(NRF_CLOCK_Type * p_reg, uint16_t freq_value)
428  {
429      p_reg->HFCLKAUDIO.FREQUENCY = freq_value;
430  }
431  NRF_STATIC_INLINE
432  uint16_t nrf_clock_hfclkaudio_config_get(NRF_CLOCK_Type const * p_reg)
433  {
434      return (uint16_t)(p_reg->HFCLKAUDIO.FREQUENCY);
435  }
436  #endif
437  #if NRF_CLOCK_HAS_HFCLK_DIV
438  NRF_STATIC_INLINE
439  void nrf_clock_hfclk_div_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_div_t divider)
440  {
441      p_reg->HFCLKCTRL = (((uint8_t)(divider) << CLOCK_HFCLKCTRL_HCLK_Pos) &
442                          CLOCK_HFCLKCTRL_HCLK_Msk);
443  }
444  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
445  {
446      return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
447                                     >> CLOCK_HFCLKCTRL_HCLK_Pos);
448  }
449  #endif
450  #if NRF_CLOCK_HAS_HFCLK192M
451  NRF_STATIC_INLINE
452  void nrf_clock_hfclk192m_div_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_div_t divider)
453  {
454      p_reg->HFCLK192MCTRL = (((uint8_t)(divider) << CLOCK_HFCLK192MCTRL_HCLK192M_Pos) &
455                              CLOCK_HFCLK192MCTRL_HCLK192M_Msk);
456  }
457  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk192m_div_get(NRF_CLOCK_Type const * p_reg)
458  {
459      return (nrf_clock_hfclk_div_t)((p_reg->HFCLK192MCTRL & CLOCK_HFCLK192MCTRL_HCLK192M_Msk)
460                                     >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
461  }
462  NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
463  {
464      p_reg->HFCLK192MSRC = (uint32_t)(source);
465  }
466  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hfclk192m_src_get(NRF_CLOCK_Type const * p_reg)
467  {
468      return (nrf_clock_hfclk_t)(p_reg->HFCLK192MSRC);
469  }
470  #endif
471  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
472  NRF_STATIC_INLINE void nrf_clock_cal_timer_timeout_set(NRF_CLOCK_Type * p_reg, uint32_t interval)
473  {
474      p_reg->CTIV = ((interval << CLOCK_CTIV_CTIV_Pos) & CLOCK_CTIV_CTIV_Msk);
475  }
476  #endif
477  #if NRF_CLOCK_HAS_ALWAYSRUN
478  NRF_STATIC_INLINE void nrf_clock_alwaysrun_set(NRF_CLOCK_Type const * p_reg,
479                                                 nrf_clock_domain_t     domain,
480                                                 bool                   alwaysrun)
481  {
482      switch (domain)
483      {
484          case NRF_CLOCK_DOMAIN_LFCLK:
485              *(volatile uint32_t *)(&p_reg->LFCLKALWAYSRUN) =
486                  ((alwaysrun << CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Pos)
487                   & CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk);
488              break;
489          case NRF_CLOCK_DOMAIN_HFCLK:
490              *(volatile uint32_t *)(&p_reg->HFCLKALWAYSRUN) =
491                  ((alwaysrun << CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Pos)
492                   & CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Msk);
493              break;
494  #if NRF_CLOCK_HAS_HFCLK192M
495          case NRF_CLOCK_DOMAIN_HFCLK192M:
496              *(volatile uint32_t *)(&p_reg->HFCLK192MALWAYSRUN) =
497                  ((alwaysrun << CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Pos)
498                   & CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Msk);
499              break;
500  #endif
501  #if NRF_CLOCK_HAS_HFCLKAUDIO
502          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
503              *(volatile uint32_t *)(&p_reg->HFCLKAUDIOALWAYSRUN) =
504                  ((alwaysrun << CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Pos)
505                   & CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Msk);
506              break;
507  #endif
508          default:
509              NRFX_ASSERT(0);
510              break;
511      }
512  }
513  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_get(NRF_CLOCK_Type const * p_reg,
514                                                 nrf_clock_domain_t     domain)
515  {
516      switch (domain)
517      {
518          case NRF_CLOCK_DOMAIN_LFCLK:
519              return ((p_reg->LFCLKALWAYSRUN & CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk)
520                      >> CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Pos);
521          case NRF_CLOCK_DOMAIN_HFCLK:
522              return ((p_reg->HFCLKALWAYSRUN & CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Msk)
523                      >> CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Pos);
524  #if NRF_CLOCK_HAS_HFCLK192M
525          case NRF_CLOCK_DOMAIN_HFCLK192M:
526              return ((p_reg->HFCLK192MALWAYSRUN & CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Msk)
527                      >> CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Pos);
528  #endif
529  #if NRF_CLOCK_HAS_HFCLKAUDIO
530          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
531              return ((p_reg->HFCLKAUDIOALWAYSRUN & CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Msk)
532                      >> CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Pos);
533  #endif
534          default:
535              NRFX_ASSERT(0);
536              return false;
537      }
538  }
539  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_active_get(NRF_CLOCK_Type const * p_reg,
540                                                        nrf_clock_domain_t     domain)
541  {
542      switch (domain)
543      {
544          case NRF_CLOCK_DOMAIN_LFCLK:
545              return ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_ALWAYSRUNNING_Msk)
546                      >> CLOCK_LFCLKSTAT_ALWAYSRUNNING_Pos);
547          case NRF_CLOCK_DOMAIN_HFCLK:
548              return ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_ALWAYSRUNNING_Msk)
549                      >> CLOCK_HFCLKSTAT_ALWAYSRUNNING_Pos);
550  #if NRF_CLOCK_HAS_HFCLK192M
551          case NRF_CLOCK_DOMAIN_HFCLK192M:
552              return ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Msk)
553                      >> CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Pos);
554  #endif
555  #if NRF_CLOCK_HAS_HFCLKAUDIO
556          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
557              return ((p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Msk)
558                      >> CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Pos);
559  #endif
560          default:
561              NRFX_ASSERT(0);
562              return false;
563      }
564  }
565  #endif 
566  #if defined(DPPI_PRESENT)
567  NRF_STATIC_INLINE void nrf_clock_subscribe_set(NRF_CLOCK_Type * p_reg,
568                                                 nrf_clock_task_t task,
569                                                 uint8_t          channel)
570  {
571      *((volatile uint32_t *) ((uint8_t *)p_reg+ (uint32_t)task + 0x80uL)) =
572              ((uint32_t)channel | CLOCK_SUBSCRIBE_HFCLKSTART_EN_Msk);
573  }
574  NRF_STATIC_INLINE void nrf_clock_subscribe_clear(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
575  {
576      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)task + 0x80uL)) = 0;
577  }
578  NRF_STATIC_INLINE void nrf_clock_publish_set(NRF_CLOCK_Type *  p_reg,
579                                               nrf_clock_event_t event,
580                                               uint8_t           channel)
581  {
582      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)event + 0x80uL)) =
583              ((uint32_t)channel | CLOCK_PUBLISH_HFCLKSTARTED_EN_Msk);
584  }
585  NRF_STATIC_INLINE void nrf_clock_publish_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event)
586  {
587      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)event + 0x80uL)) = 0;
588  }
589  #endif 
590  #endif 
591  #ifdef __cplusplus
592  }
593  #endif
594  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_clock.h</h3>
            <pre><code>1  #ifndef NRF_CLOCK_H__
2  #define NRF_CLOCK_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(CLOCK_LFCLKSRC_BYPASS_Msk) && defined(CLOCK_LFCLKSRC_EXTERNAL_Msk)
8  #define NRF_CLOCK_USE_EXTERNAL_LFCLK_SOURCES
9  #endif
10  #if defined(CLOCK_INTENSET_DONE_Msk) || defined(__NRFX_DOXYGEN__)
11  #define NRF_CLOCK_HAS_CALIBRATION 1
12  #else
13  #define NRF_CLOCK_HAS_CALIBRATION 0
14  #endif
15  #if defined(CLOCK_CTIV_CTIV_Msk) || defined(__NRFX_DOXYGEN__)
16  #define NRF_CLOCK_HAS_CALIBRATION_TIMER 1
17  #else
18  #define NRF_CLOCK_HAS_CALIBRATION_TIMER 0
19  #endif
20  #if (defined(CLOCK_INTENSET_HFCLK192MSTARTED_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
21      || defined(__NRFX_DOXYGEN__)
22  #define NRF_CLOCK_HAS_HFCLK192M 1
23  #else
24  #define NRF_CLOCK_HAS_HFCLK192M 0
25  #endif
26  #if (defined(CLOCK_INTENSET_HFCLKAUDIOSTARTED_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
27      || defined(__NRFX_DOXYGEN__)
28  #define NRF_CLOCK_HAS_HFCLKAUDIO 1
29  #else
30  #define NRF_CLOCK_HAS_HFCLKAUDIO 0
31  #endif
32  #if (defined(CLOCK_HFCLKCTRL_HCLK_Msk) && !defined(NRF5340_XXAA_NETWORK)) \
33      || defined(__NRFX_DOXYGEN__)
34  #define NRF_CLOCK_HAS_HFCLK_DIV 1
35  #else
36  #define NRF_CLOCK_HAS_HFCLK_DIV 0
37  #endif
38  #if defined(CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk) || defined(__NRFX_DOXYGEN__)
39  #define NRF_CLOCK_HAS_ALWAYSRUN 1
40  #else
41  #define NRF_CLOCK_HAS_ALWAYSRUN 0
42  #endif
43  #if defined(CLOCK_HFCLKSRC_SRC_Msk) || defined(__NRFX_DOXYGEN__)
44  #define NRF_CLOCK_HAS_HFCLKSRC 1
45  #else
46  #define NRF_CLOCK_HAS_HFCLKSRC 0
47  #endif
48  typedef enum
49  {
50  #if defined(CLOCK_LFCLKSRC_SRC_LFULP) || defined(__NRFX_DOXYGEN__)
51      NRF_CLOCK_LFCLK_LFULP = CLOCK_LFCLKSRC_SRC_LFULP, &bsol;**< Internal 32 kHz Ultra-low power oscillator. */
52  #endif
53  #if defined(CLOCK_LFCLKSRC_SRC_RC) || defined(__NRFX_DOXYGEN__)
<span onclick='openModal()' class='match'>54      NRF_CLOCK_LFCLK_RC    = CLOCK_LFCLKSRC_SRC_RC,    &bsol;**< Internal 32 kHz RC oscillator. */
55  #else
</span>56      NRF_CLOCK_LFCLK_RC    = CLOCK_LFCLKSRC_SRC_LFRC,  &bsol;**< Internal 32 kHz RC oscillator. */
57  #endif
58  #if defined(CLOCK_LFCLKSRC_SRC_Xtal) || defined(__NRFX_DOXYGEN__)
59      NRF_CLOCK_LFCLK_Xtal  = CLOCK_LFCLKSRC_SRC_Xtal,  &bsol;**< External 32 kHz crystal. */
60  #else
61      NRF_CLOCK_LFCLK_Xtal  = CLOCK_LFCLKSRC_SRC_LFXO,  &bsol;**< External 32 kHz crystal. */
62  #endif
63  #if defined(CLOCK_LFCLKSRC_SRC_Synth) || defined(__NRFX_DOXYGEN__)
64      NRF_CLOCK_LFCLK_Synth = CLOCK_LFCLKSRC_SRC_Synth, &bsol;**< Internal 32 kHz synthesizer from HFCLK system clock. */
65  #endif
66  #if defined(NRF_CLOCK_USE_EXTERNAL_LFCLK_SOURCES) || defined(__NRFX_DOXYGEN__)
67      NRF_CLOCK_LFCLK_Xtal_Low_Swing = (CLOCK_LFCLKSRC_SRC_Xtal |
68          (CLOCK_LFCLKSRC_EXTERNAL_Enabled << CLOCK_LFCLKSRC_EXTERNAL_Pos)),
69      NRF_CLOCK_LFCLK_Xtal_Full_Swing = (CLOCK_LFCLKSRC_SRC_Xtal |
70          (CLOCK_LFCLKSRC_BYPASS_Enabled   << CLOCK_LFCLKSRC_BYPASS_Pos) |
71          (CLOCK_LFCLKSRC_EXTERNAL_Enabled << CLOCK_LFCLKSRC_EXTERNAL_Pos)),
72  #endif 
73  } nrf_clock_lfclk_t;
74  typedef enum
75  {
76  #if defined(CLOCK_HFCLKSTAT_SRC_RC) || defined(__NRFX_DOXYGEN__)
77      NRF_CLOCK_HFCLK_LOW_ACCURACY  = CLOCK_HFCLKSTAT_SRC_RC,  &bsol;**< Internal 16 MHz RC oscillator. */
78  #elif defined(CLOCK_HFCLKSTAT_SRC_HFINT)
79      NRF_CLOCK_HFCLK_LOW_ACCURACY  = CLOCK_HFCLKSTAT_SRC_HFINT,  &bsol;**< Internal 16 MHz RC oscillator. */
80  #endif
81  #if defined(CLOCK_HFCLKSTAT_SRC_Xtal) || defined(__NRFX_DOXYGEN__)
82      NRF_CLOCK_HFCLK_HIGH_ACCURACY = CLOCK_HFCLKSTAT_SRC_Xtal &bsol;**< External 16 MHz/32 MHz crystal oscillator. */
83  #else
84      NRF_CLOCK_HFCLK_HIGH_ACCURACY = CLOCK_HFCLKSTAT_SRC_HFXO &bsol;**< External 32 MHz crystal oscillator. */
85  #endif
86  } nrf_clock_hfclk_t;
87  typedef enum
88  {
89      NRF_CLOCK_DOMAIN_LFCLK,
90      NRF_CLOCK_DOMAIN_HFCLK,
91  #if NRF_CLOCK_HAS_HFCLK192M
92      NRF_CLOCK_DOMAIN_HFCLK192M,
93  #endif
94  #if NRF_CLOCK_HAS_HFCLKAUDIO
95      NRF_CLOCK_DOMAIN_HFCLKAUDIO,
96  #endif
97  } nrf_clock_domain_t;
98  #if NRF_CLOCK_HAS_HFCLK_DIV || NRF_CLOCK_HAS_HFCLK192M
99  typedef enum
100  {
101      NRF_CLOCK_HFCLK_DIV_1 = CLOCK_HFCLKCTRL_HCLK_Div1,         &bsol;**< Divide HFCLK/HFCLK192M by 1 */
102      NRF_CLOCK_HFCLK_DIV_2 = CLOCK_HFCLKCTRL_HCLK_Div2,         &bsol;**< Divide HFCLK/HFCLK192M by 2 */
103  #if NRF_CLOCK_HAS_HFCLK192M
104      NRF_CLOCK_HFCLK_DIV_4 = CLOCK_HFCLK192MCTRL_HCLK192M_Div4, &bsol;**< Divide HFCLK192M by 4 */
105  #endif
106  } nrf_clock_hfclk_div_t;
107  #endif 
108  typedef enum
109  {
110      NRF_CLOCK_START_TASK_NOT_TRIGGERED = CLOCK_LFCLKRUN_STATUS_NotTriggered, &bsol;**< Task LFCLKSTART/HFCLKSTART has not been triggered. */
111      NRF_CLOCK_START_TASK_TRIGGERED     = CLOCK_LFCLKRUN_STATUS_Triggered     &bsol;**< Task LFCLKSTART/HFCLKSTART has been triggered. */
112  } nrf_clock_start_task_status_t;
113  typedef enum
114  {
115      NRF_CLOCK_INT_HF_STARTED_MASK      = CLOCK_INTENSET_HFCLKSTARTED_Msk,      &bsol;**< Interrupt on HFCLKSTARTED event. */
116      NRF_CLOCK_INT_LF_STARTED_MASK      = CLOCK_INTENSET_LFCLKSTARTED_Msk,      &bsol;**< Interrupt on LFCLKSTARTED event. */
117  #if NRF_CLOCK_HAS_CALIBRATION
118      NRF_CLOCK_INT_DONE_MASK            = CLOCK_INTENSET_DONE_Msk,              &bsol;**< Interrupt on DONE event. */
119  #endif
120  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
121      NRF_CLOCK_INT_CTTO_MASK            = CLOCK_INTENSET_CTTO_Msk,              &bsol;**< Interrupt on CTTO event. */
122  #endif
123  #if defined(CLOCK_INTENSET_CTSTARTED_Msk) || defined(__NRFX_DOXYGEN__)
124      NRF_CLOCK_INT_CTSTARTED_MASK       = CLOCK_INTENSET_CTSTARTED_Msk,         &bsol;**< Interrupt on CTSTARTED event. */
125      NRF_CLOCK_INT_CTSTOPPED_MASK       = CLOCK_INTENSET_CTSTOPPED_Msk          &bsol;**< Interrupt on CTSTOPPED event. */
126  #endif
127  #if NRF_CLOCK_HAS_HFCLKAUDIO
128      NRF_CLOCK_INT_HFAUDIO_STARTED_MASK = CLOCK_INTENSET_HFCLKAUDIOSTARTED_Msk, &bsol;**< Interrupt on HFCLKAUDIOSTARTED event. */
129  #endif
130  #if NRF_CLOCK_HAS_HFCLK192M
131      NRF_CLOCK_INT_HF192M_STARTED_MASK  = CLOCK_INTENSET_HFCLK192MSTARTED_Msk,  &bsol;**< Interrupt on HFCLK192MSTARTED event. */
132  #endif
133  } nrf_clock_int_mask_t;
134  typedef enum
135  {
136      NRF_CLOCK_TASK_HFCLKSTART      = offsetof(NRF_CLOCK_Type, TASKS_HFCLKSTART),      &bsol;**< Start HFCLK clock source. */
137      NRF_CLOCK_TASK_HFCLKSTOP       = offsetof(NRF_CLOCK_Type, TASKS_HFCLKSTOP),       &bsol;**< Stop HFCLK clock source. */
138      NRF_CLOCK_TASK_LFCLKSTART      = offsetof(NRF_CLOCK_Type, TASKS_LFCLKSTART),      &bsol;**< Start LFCLK clock source. */
139      NRF_CLOCK_TASK_LFCLKSTOP       = offsetof(NRF_CLOCK_Type, TASKS_LFCLKSTOP),       &bsol;**< Stop LFCLK clock source. */
140  #if NRF_CLOCK_HAS_CALIBRATION
141      NRF_CLOCK_TASK_CAL             = offsetof(NRF_CLOCK_Type, TASKS_CAL),             &bsol;**< Start calibration of LFCLK RC oscillator. */
142  #endif
143  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
144      NRF_CLOCK_TASK_CTSTART         = offsetof(NRF_CLOCK_Type, TASKS_CTSTART),         &bsol;**< Start calibration timer. */
145      NRF_CLOCK_TASK_CTSTOP          = offsetof(NRF_CLOCK_Type, TASKS_CTSTOP)           &bsol;**< Stop calibration timer. */
146  #endif
147  #if NRF_CLOCK_HAS_HFCLKAUDIO
148      NRF_CLOCK_TASK_HFCLKAUDIOSTART = offsetof(NRF_CLOCK_Type, TASKS_HFCLKAUDIOSTART), &bsol;**< Start HFCLKAUDIO clock source. */
149      NRF_CLOCK_TASK_HFCLKAUDIOSTOP  = offsetof(NRF_CLOCK_Type, TASKS_HFCLKAUDIOSTOP),  &bsol;**< Stop HFCLKAUDIO clock source. */
150  #endif
151  #if NRF_CLOCK_HAS_HFCLK192M
152      NRF_CLOCK_TASK_HFCLK192MSTART  = offsetof(NRF_CLOCK_Type, TASKS_HFCLK192MSTART),  &bsol;**< Start HFCLK192M clock source. */
153      NRF_CLOCK_TASK_HFCLK192MSTOP   = offsetof(NRF_CLOCK_Type, TASKS_HFCLK192MSTOP),   &bsol;**< Stop HFCLK192M clock source. */
154  #endif
155  } nrf_clock_task_t;
156  typedef enum
157  {
158      NRF_CLOCK_EVENT_HFCLKSTARTED      = offsetof(NRF_CLOCK_Type, EVENTS_HFCLKSTARTED),      &bsol;**< HFCLK oscillator started. */
159      NRF_CLOCK_EVENT_LFCLKSTARTED      = offsetof(NRF_CLOCK_Type, EVENTS_LFCLKSTARTED),      &bsol;**< LFCLK oscillator started. */
160  #if NRF_CLOCK_HAS_CALIBRATION
161      NRF_CLOCK_EVENT_DONE              = offsetof(NRF_CLOCK_Type, EVENTS_DONE),              &bsol;**< Calibration of LFCLK RC oscillator completed. */
162  #endif
163  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
164      NRF_CLOCK_EVENT_CTTO              = offsetof(NRF_CLOCK_Type, EVENTS_CTTO),              &bsol;**< Calibration timer time-out. */
165  #endif
166  #if defined(CLOCK_INTENSET_CTSTARTED_Msk) || defined(__NRFX_DOXYGEN__)
167      NRF_CLOCK_EVENT_CTSTARTED         = offsetof(NRF_CLOCK_Type, EVENTS_CTSTARTED),         &bsol;**< Calibration timer started. */
168      NRF_CLOCK_EVENT_CTSTOPPED         = offsetof(NRF_CLOCK_Type, EVENTS_CTSTOPPED)          &bsol;**< Calibration timer stopped. */
169  #endif
170  #if NRF_CLOCK_HAS_HFCLKAUDIO
171      NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED = offsetof(NRF_CLOCK_Type, EVENTS_HFCLKAUDIOSTARTED), &bsol;**< HFCLKAUDIO oscillator started. */
172  #endif
173  #if NRF_CLOCK_HAS_HFCLK192M
174      NRF_CLOCK_EVENT_HFCLK192MSTARTED  = offsetof(NRF_CLOCK_Type, EVENTS_HFCLK192MSTARTED),  &bsol;**< HFCLK192M oscillator started. */
175  #endif
176  } nrf_clock_event_t;
177  NRF_STATIC_INLINE void nrf_clock_int_enable(NRF_CLOCK_Type * p_reg, uint32_t mask);
178  NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask);
179  NRF_STATIC_INLINE uint32_t nrf_clock_int_enable_check(NRF_CLOCK_Type const * p_reg, uint32_t mask);
180  NRF_STATIC_INLINE uint32_t nrf_clock_task_address_get(NRF_CLOCK_Type const * p_reg,
181                                                        nrf_clock_task_t       task);
182  NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task);
183  NRF_STATIC_INLINE uint32_t nrf_clock_event_address_get(NRF_CLOCK_Type const * p_reg,
184                                                         nrf_clock_event_t      event);
185  NRF_STATIC_INLINE void nrf_clock_event_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event);
186  NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event);
187  NRF_STATIC_INLINE bool nrf_clock_start_task_check(NRF_CLOCK_Type const * p_reg,
188                                                    nrf_clock_domain_t     domain);
189  NRF_STATIC_INLINE bool nrf_clock_is_running(NRF_CLOCK_Type const * p_reg,
190                                              nrf_clock_domain_t     domain,
191                                              void *                 clk_src);
192  NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source);
193  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_src_get(NRF_CLOCK_Type const * p_reg);
194  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_actv_src_get(NRF_CLOCK_Type const * p_reg);
195  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg);
196  NRF_STATIC_INLINE bool nrf_clock_lf_is_running(NRF_CLOCK_Type const * p_reg);
197  NRF_STATIC_INLINE
198  nrf_clock_start_task_status_t nrf_clock_lf_start_task_status_get(NRF_CLOCK_Type const * p_reg);
199  #if NRF_CLOCK_HAS_HFCLKSRC
200  NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source);
201  #endif
202  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hf_src_get(NRF_CLOCK_Type const * p_reg);
203  NRF_STATIC_INLINE bool nrf_clock_hf_is_running(NRF_CLOCK_Type const * p_reg,
204                                                 nrf_clock_hfclk_t      clk_src);
205  NRF_STATIC_INLINE
206  nrf_clock_start_task_status_t nrf_clock_hf_start_task_status_get(NRF_CLOCK_Type const * p_reg);
207  #if NRF_CLOCK_HAS_HFCLKAUDIO
208  NRF_STATIC_INLINE
209  void nrf_clock_hfclkaudio_config_set(NRF_CLOCK_Type * p_reg, uint16_t freq_value);
210  NRF_STATIC_INLINE
211  uint16_t nrf_clock_hfclkaudio_config_get(NRF_CLOCK_Type const * p_reg);
212  #endif
213  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
214  NRF_STATIC_INLINE void nrf_clock_cal_timer_timeout_set(NRF_CLOCK_Type * p_reg, uint32_t interval);
215  #endif
216  #if NRF_CLOCK_HAS_HFCLK_DIV
217  NRF_STATIC_INLINE void nrf_clock_hfclk_div_set(NRF_CLOCK_Type *      p_reg,
218                                                 nrf_clock_hfclk_div_t divider);
219  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg);
220  #endif
221  #if NRF_CLOCK_HAS_HFCLK192M
222  NRF_STATIC_INLINE void nrf_clock_hfclk192m_div_set(NRF_CLOCK_Type *      p_reg,
223                                                     nrf_clock_hfclk_div_t divider);
224  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk192m_div_get(NRF_CLOCK_Type const * p_reg);
225  NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type *  p_reg,
226                                                     nrf_clock_hfclk_t source);
227  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hfclk192m_src_get(NRF_CLOCK_Type const * p_reg);
228  #endif 
229  #if NRF_CLOCK_HAS_ALWAYSRUN
230  NRF_STATIC_INLINE void nrf_clock_alwaysrun_set(NRF_CLOCK_Type const * p_reg,
231                                                 nrf_clock_domain_t     domain,
232                                                 bool                   alwaysrun);
233  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_get(NRF_CLOCK_Type const * p_reg,
234                                                 nrf_clock_domain_t     domain);
235  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_active_get(NRF_CLOCK_Type const * p_reg,
236                                                        nrf_clock_domain_t     domain);
237  #endif
238  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
239  NRF_STATIC_INLINE void nrf_clock_subscribe_set(NRF_CLOCK_Type * p_reg,
240                                                 nrf_clock_task_t task,
241                                                 uint8_t          channel);
242  NRF_STATIC_INLINE void nrf_clock_subscribe_clear(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task);
243  NRF_STATIC_INLINE void nrf_clock_publish_set(NRF_CLOCK_Type *  p_reg,
244                                               nrf_clock_event_t event,
245                                               uint8_t           channel);
246  NRF_STATIC_INLINE void nrf_clock_publish_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event);
247  #endif 
248  #ifndef NRF_DECLARE_ONLY
249  NRF_STATIC_INLINE void nrf_clock_int_enable(NRF_CLOCK_Type * p_reg, uint32_t mask)
250  {
251      p_reg->INTENSET = mask;
252  }
253  NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
254  {
255      p_reg->INTENCLR = mask;
256  }
257  NRF_STATIC_INLINE uint32_t nrf_clock_int_enable_check(NRF_CLOCK_Type const * p_reg, uint32_t mask)
258  {
259      return p_reg->INTENSET & mask;
260  }
261  NRF_STATIC_INLINE uint32_t nrf_clock_task_address_get(NRF_CLOCK_Type const * p_reg,
262                                                        nrf_clock_task_t       task)
263  {
264      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
265  }
266  NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
267  {
268      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
269  }
270  NRF_STATIC_INLINE uint32_t nrf_clock_event_address_get(NRF_CLOCK_Type const * p_reg,
271                                                         nrf_clock_event_t      event)
272  {
273      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
274  }
275  NRF_STATIC_INLINE void nrf_clock_event_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event)
276  {
277      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
278  #if __CORTEX_M == 0x04
279      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
280      (void)dummy;
281  #endif
282  }
283  NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
284  {
285      return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
286  }
287  NRF_STATIC_INLINE bool nrf_clock_start_task_check(NRF_CLOCK_Type const * p_reg,
288                                                    nrf_clock_domain_t     domain)
289  {
290      switch (domain)
291      {
292          case NRF_CLOCK_DOMAIN_LFCLK:
293              return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
294                      >> CLOCK_LFCLKRUN_STATUS_Pos);
295          case NRF_CLOCK_DOMAIN_HFCLK:
296              return ((p_reg->HFCLKRUN & CLOCK_HFCLKRUN_STATUS_Msk)
297                      >> CLOCK_HFCLKRUN_STATUS_Pos);
298  #if NRF_CLOCK_HAS_HFCLK192M
299          case NRF_CLOCK_DOMAIN_HFCLK192M:
300              return ((p_reg->HFCLK192MRUN & CLOCK_HFCLK192MRUN_STATUS_Msk)
301                      >> CLOCK_HFCLK192MRUN_STATUS_Pos);
302  #endif
303  #if NRF_CLOCK_HAS_HFCLKAUDIO
304          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
305              return ((p_reg->HFCLKAUDIORUN & CLOCK_HFCLKAUDIORUN_STATUS_Msk)
306                      >> CLOCK_HFCLKAUDIORUN_STATUS_Pos);
307  #endif
308          default:
309              NRFX_ASSERT(0);
310              return false;
311      }
312  }
313  NRF_STATIC_INLINE bool nrf_clock_is_running(NRF_CLOCK_Type const * p_reg,
314                                              nrf_clock_domain_t     domain,
315                                              void *                 clk_src)
316  {
317      switch (domain)
318      {
319          case NRF_CLOCK_DOMAIN_LFCLK:
320              if (clk_src != NULL)
321              {
322                  (*(uint32_t *)clk_src) = ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
323                                            >> CLOCK_LFCLKSTAT_SRC_Pos);
324              }
325              if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
326                  >> CLOCK_LFCLKSTAT_STATE_Pos)
327              {
328                  return true;
329              }
330              break;
331          case NRF_CLOCK_DOMAIN_HFCLK:
332              if (clk_src != NULL)
333              {
334                  (*(uint32_t *)clk_src) = ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
335                                            >> CLOCK_HFCLKSTAT_SRC_Pos);
336              }
337              if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
338                  >> CLOCK_HFCLKSTAT_STATE_Pos)
339              {
340                  return true;
341              }
342              break;
343  #if NRF_CLOCK_HAS_HFCLK192M
344          case NRF_CLOCK_DOMAIN_HFCLK192M:
345              if (clk_src != NULL)
346              {
347                  (*(uint32_t *)clk_src) = ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
348                                            >> CLOCK_HFCLK192MSTAT_SRC_Pos);
349              }
350              if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
351                  >> CLOCK_HFCLK192MSTAT_STATE_Pos)
352              {
353                  return true;
354              }
355              break;
356  #endif
357  #if NRF_CLOCK_HAS_HFCLKAUDIO
358          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
359              return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
360                     CLOCK_HFCLKAUDIOSTAT_STATE_Msk;
361  #endif
362          default:
363              NRFX_ASSERT(0);
364              return false;
365      }
366      return false;
367  }
368  NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
369  {
370      p_reg->LFCLKSRC = (uint32_t)(source);
371  }
372  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_src_get(NRF_CLOCK_Type const * p_reg)
373  {
374      return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
375  }
376  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_actv_src_get(NRF_CLOCK_Type const * p_reg)
377  {
378      nrf_clock_lfclk_t clk_src;
379      (void)nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_LFCLK, &clk_src);
380      return clk_src;
381  }
382  NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
383  {
384      return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
385                                  >> CLOCK_LFCLKSRCCOPY_SRC_Pos);
386  }
387  NRF_STATIC_INLINE bool nrf_clock_lf_is_running(NRF_CLOCK_Type const * p_reg)
388  {
389      return nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_LFCLK, NULL);
390  }
391  NRF_STATIC_INLINE
392  nrf_clock_start_task_status_t nrf_clock_lf_start_task_status_get(NRF_CLOCK_Type const * p_reg)
393  {
394      return (nrf_clock_start_task_status_t)nrf_clock_start_task_check(p_reg,
395                                                                       NRF_CLOCK_DOMAIN_LFCLK);
396  }
397  #if NRF_CLOCK_HAS_HFCLKSRC
398  NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
399  {
400      p_reg->HFCLKSRC = (uint32_t)(source);
401  }
402  #endif
403  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hf_src_get(NRF_CLOCK_Type const * p_reg)
404  {
405  #if NRF_CLOCK_HAS_HFCLKSRC
406      return (nrf_clock_hfclk_t)(p_reg->HFCLKSRC);
407  #else
408      return (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
409                                  >> CLOCK_HFCLKSTAT_SRC_Pos);
410  #endif
411  }
412  NRF_STATIC_INLINE bool nrf_clock_hf_is_running(NRF_CLOCK_Type const * p_reg,
413                                                 nrf_clock_hfclk_t      clk_src)
414  {
415      nrf_clock_hfclk_t active_clk_src;
416      bool ret = nrf_clock_is_running(p_reg, NRF_CLOCK_DOMAIN_HFCLK, &active_clk_src);
417      return (ret && (active_clk_src == clk_src));
418  }
419  NRF_STATIC_INLINE
420  nrf_clock_start_task_status_t nrf_clock_hf_start_task_status_get(NRF_CLOCK_Type const * p_reg)
421  {
422      return (nrf_clock_start_task_status_t)nrf_clock_start_task_check(p_reg,
423                                                                       NRF_CLOCK_DOMAIN_HFCLK);
424  }
425  #if NRF_CLOCK_HAS_HFCLKAUDIO
426  NRF_STATIC_INLINE
427  void nrf_clock_hfclkaudio_config_set(NRF_CLOCK_Type * p_reg, uint16_t freq_value)
428  {
429      p_reg->HFCLKAUDIO.FREQUENCY = freq_value;
430  }
431  NRF_STATIC_INLINE
432  uint16_t nrf_clock_hfclkaudio_config_get(NRF_CLOCK_Type const * p_reg)
433  {
434      return (uint16_t)(p_reg->HFCLKAUDIO.FREQUENCY);
435  }
436  #endif
437  #if NRF_CLOCK_HAS_HFCLK_DIV
438  NRF_STATIC_INLINE
439  void nrf_clock_hfclk_div_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_div_t divider)
440  {
441      p_reg->HFCLKCTRL = (((uint8_t)(divider) << CLOCK_HFCLKCTRL_HCLK_Pos) &
442                          CLOCK_HFCLKCTRL_HCLK_Msk);
443  }
444  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
445  {
446      return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
447                                     >> CLOCK_HFCLKCTRL_HCLK_Pos);
448  }
449  #endif
450  #if NRF_CLOCK_HAS_HFCLK192M
451  NRF_STATIC_INLINE
452  void nrf_clock_hfclk192m_div_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_div_t divider)
453  {
454      p_reg->HFCLK192MCTRL = (((uint8_t)(divider) << CLOCK_HFCLK192MCTRL_HCLK192M_Pos) &
455                              CLOCK_HFCLK192MCTRL_HCLK192M_Msk);
456  }
457  NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk192m_div_get(NRF_CLOCK_Type const * p_reg)
458  {
459      return (nrf_clock_hfclk_div_t)((p_reg->HFCLK192MCTRL & CLOCK_HFCLK192MCTRL_HCLK192M_Msk)
460                                     >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
461  }
462  NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
463  {
464      p_reg->HFCLK192MSRC = (uint32_t)(source);
465  }
466  NRF_STATIC_INLINE nrf_clock_hfclk_t nrf_clock_hfclk192m_src_get(NRF_CLOCK_Type const * p_reg)
467  {
468      return (nrf_clock_hfclk_t)(p_reg->HFCLK192MSRC);
469  }
470  #endif
471  #if NRF_CLOCK_HAS_CALIBRATION_TIMER
472  NRF_STATIC_INLINE void nrf_clock_cal_timer_timeout_set(NRF_CLOCK_Type * p_reg, uint32_t interval)
473  {
474      p_reg->CTIV = ((interval << CLOCK_CTIV_CTIV_Pos) & CLOCK_CTIV_CTIV_Msk);
475  }
476  #endif
477  #if NRF_CLOCK_HAS_ALWAYSRUN
478  NRF_STATIC_INLINE void nrf_clock_alwaysrun_set(NRF_CLOCK_Type const * p_reg,
479                                                 nrf_clock_domain_t     domain,
480                                                 bool                   alwaysrun)
481  {
482      switch (domain)
483      {
484          case NRF_CLOCK_DOMAIN_LFCLK:
485              *(volatile uint32_t *)(&p_reg->LFCLKALWAYSRUN) =
486                  ((alwaysrun << CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Pos)
487                   & CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk);
488              break;
489          case NRF_CLOCK_DOMAIN_HFCLK:
490              *(volatile uint32_t *)(&p_reg->HFCLKALWAYSRUN) =
491                  ((alwaysrun << CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Pos)
492                   & CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Msk);
493              break;
494  #if NRF_CLOCK_HAS_HFCLK192M
495          case NRF_CLOCK_DOMAIN_HFCLK192M:
496              *(volatile uint32_t *)(&p_reg->HFCLK192MALWAYSRUN) =
497                  ((alwaysrun << CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Pos)
498                   & CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Msk);
499              break;
500  #endif
501  #if NRF_CLOCK_HAS_HFCLKAUDIO
502          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
503              *(volatile uint32_t *)(&p_reg->HFCLKAUDIOALWAYSRUN) =
504                  ((alwaysrun << CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Pos)
505                   & CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Msk);
506              break;
507  #endif
508          default:
509              NRFX_ASSERT(0);
510              break;
511      }
512  }
513  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_get(NRF_CLOCK_Type const * p_reg,
514                                                 nrf_clock_domain_t     domain)
515  {
516      switch (domain)
517      {
518          case NRF_CLOCK_DOMAIN_LFCLK:
519              return ((p_reg->LFCLKALWAYSRUN & CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Msk)
520                      >> CLOCK_LFCLKALWAYSRUN_ALWAYSRUN_Pos);
521          case NRF_CLOCK_DOMAIN_HFCLK:
522              return ((p_reg->HFCLKALWAYSRUN & CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Msk)
523                      >> CLOCK_HFCLKALWAYSRUN_ALWAYSRUN_Pos);
524  #if NRF_CLOCK_HAS_HFCLK192M
525          case NRF_CLOCK_DOMAIN_HFCLK192M:
526              return ((p_reg->HFCLK192MALWAYSRUN & CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Msk)
527                      >> CLOCK_HFCLK192MALWAYSRUN_ALWAYSRUN_Pos);
528  #endif
529  #if NRF_CLOCK_HAS_HFCLKAUDIO
530          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
531              return ((p_reg->HFCLKAUDIOALWAYSRUN & CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Msk)
532                      >> CLOCK_HFCLKAUDIOALWAYSRUN_ALWAYSRUN_Pos);
533  #endif
534          default:
535              NRFX_ASSERT(0);
536              return false;
537      }
538  }
539  NRF_STATIC_INLINE bool nrf_clock_alwaysrun_active_get(NRF_CLOCK_Type const * p_reg,
540                                                        nrf_clock_domain_t     domain)
541  {
542      switch (domain)
543      {
544          case NRF_CLOCK_DOMAIN_LFCLK:
545              return ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_ALWAYSRUNNING_Msk)
546                      >> CLOCK_LFCLKSTAT_ALWAYSRUNNING_Pos);
547          case NRF_CLOCK_DOMAIN_HFCLK:
548              return ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_ALWAYSRUNNING_Msk)
549                      >> CLOCK_HFCLKSTAT_ALWAYSRUNNING_Pos);
550  #if NRF_CLOCK_HAS_HFCLK192M
551          case NRF_CLOCK_DOMAIN_HFCLK192M:
552              return ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Msk)
553                      >> CLOCK_HFCLK192MSTAT_ALWAYSRUNNING_Pos);
554  #endif
555  #if NRF_CLOCK_HAS_HFCLKAUDIO
556          case NRF_CLOCK_DOMAIN_HFCLKAUDIO:
557              return ((p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Msk)
558                      >> CLOCK_HFCLKAUDIOSTAT_ALWAYSRUNNING_Pos);
559  #endif
560          default:
561              NRFX_ASSERT(0);
562              return false;
563      }
564  }
565  #endif 
566  #if defined(DPPI_PRESENT)
567  NRF_STATIC_INLINE void nrf_clock_subscribe_set(NRF_CLOCK_Type * p_reg,
568                                                 nrf_clock_task_t task,
569                                                 uint8_t          channel)
570  {
571      *((volatile uint32_t *) ((uint8_t *)p_reg+ (uint32_t)task + 0x80uL)) =
572              ((uint32_t)channel | CLOCK_SUBSCRIBE_HFCLKSTART_EN_Msk);
573  }
574  NRF_STATIC_INLINE void nrf_clock_subscribe_clear(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
575  {
576      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)task + 0x80uL)) = 0;
577  }
578  NRF_STATIC_INLINE void nrf_clock_publish_set(NRF_CLOCK_Type *  p_reg,
579                                               nrf_clock_event_t event,
580                                               uint8_t           channel)
581  {
582      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)event + 0x80uL)) =
583              ((uint32_t)channel | CLOCK_PUBLISH_HFCLKSTARTED_EN_Msk);
584  }
585  NRF_STATIC_INLINE void nrf_clock_publish_clear(NRF_CLOCK_Type * p_reg, nrf_clock_event_t event)
586  {
587      *((volatile uint32_t *) ((uint8_t *)p_reg + (uint32_t)event + 0x80uL)) = 0;
588  }
589  #endif 
590  #endif 
591  #ifdef __cplusplus
592  }
593  #endif
594  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_clock.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_clock.h</div>
                </div>
                <div class="column column_space"><pre><code>79      NRF_CLOCK_HFCLK_LOW_ACCURACY  = CLOCK_HFCLKSTAT_SRC_HFINT,  &bsol;**< Internal 16 MHz RC oscillator. */
80  #endif
</pre></code></div>
                <div class="column column_space"><pre><code>54      NRF_CLOCK_LFCLK_RC    = CLOCK_LFCLKSRC_SRC_RC,    &bsol;**< Internal 32 kHz RC oscillator. */
55  #else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    