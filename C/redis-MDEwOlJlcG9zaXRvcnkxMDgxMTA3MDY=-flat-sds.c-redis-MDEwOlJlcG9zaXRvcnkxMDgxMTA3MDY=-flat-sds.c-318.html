
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 64, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #include &lt;ctype.h&gt;
5  #include &lt;assert.h&gt;
6  #include &quot;sds.h&quot;
7  #include &quot;sdsalloc.h&quot;
8  static inline int sdsHdrSize(char type) {
9  	switch (type&amp;SDS_TYPE_MASK) {
10  	case SDS_TYPE_5:
11  		return sizeof(struct sdshdr5);
12  	case SDS_TYPE_8:
13  		return sizeof(struct sdshdr8);
14  	case SDS_TYPE_16:
15  		return sizeof(struct sdshdr16);
16  	case SDS_TYPE_32:
17  		return sizeof(struct sdshdr32);
18  	case SDS_TYPE_64:
19  		return sizeof(struct sdshdr64);
20  	}
21  	return 0;
22  }
23  static inline char sdsReqType(size_t string_size) {
24  	if (string_size &lt; 32)
25  		return SDS_TYPE_5;
26  	if (string_size &lt; 0xff)
27  		return SDS_TYPE_8;
28  	if (string_size &lt; 0xffff)
29  		return SDS_TYPE_16;
30  	if (string_size &lt; 0xffffffff)
31  		return SDS_TYPE_32;
32  	return SDS_TYPE_64;
33  }
34  sds sdsnewlen(const void *init, size_t initlen) {
35  	void *sh;
36  	sds s;
37  	char type = sdsReqType(initlen);
38  	if (type == SDS_TYPE_5 &amp;&amp; initlen == 0) type = SDS_TYPE_8;
39  	int hdrlen = sdsHdrSize(type);
40  	unsigned char *fp; &amp;bsol;* flags pointer. */
41  	sh = s_malloc(hdrlen + initlen + 1);
42  	if (sh == NULL) return NULL;
43  	if (!init)
44  		memset(sh, 0, hdrlen + initlen + 1);
45  	s = (char*)sh + hdrlen;
46  	fp = ((unsigned char*)s) - 1;
47  	switch (type) {
48  	case SDS_TYPE_5: {
49  		*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);
50  		break;
51  	}
52  	case SDS_TYPE_8: {
53  		SDS_HDR_VAR(8, s);
54  		sh-&gt;len = initlen;
55  		sh-&gt;alloc = initlen;
56  		*fp = type;
57  		break;
58  	}
59  	case SDS_TYPE_16: {
60  		SDS_HDR_VAR(16, s);
61  		sh-&gt;len = initlen;
62  		sh-&gt;alloc = initlen;
63  		*fp = type;
64  		break;
65  	}
66  	case SDS_TYPE_32: {
67  		SDS_HDR_VAR(32, s);
68  		sh-&gt;len = initlen;
69  		sh-&gt;alloc = initlen;
70  		*fp = type;
71  		break;
72  	}
73  	case SDS_TYPE_64: {
74  		SDS_HDR_VAR(64, s);
75  		sh-&gt;len = initlen;
76  		sh-&gt;alloc = initlen;
77  		*fp = type;
78  		break;
79  	}
80  	}
81  	if (initlen &amp;&amp; init)
82  		memcpy(s, init, initlen);
83  	s[initlen] = &#x27;\0&#x27;;
84  	return s;
85  }
86  sds sdsempty(void) {
87  	return sdsnewlen(&quot;&quot;, 0);
88  }
89  sds sdsnew(const char *init) {
90  	size_t initlen = (init == NULL) ? 0 : strlen(init);
91  	return sdsnewlen(init, initlen);
92  }
93  sds sdsdup(const sds s) {
94  	return sdsnewlen(s, sdslen(s));
95  }
96  void sdsfree(sds s) {
97  	if (s == NULL) return;
98  	s_free((char*)s - sdsHdrSize(s[-1]));
99  }
100  void sdsupdatelen(sds s) {
101  	int reallen = strlen(s);
102  	sdssetlen(s, reallen);
103  }
104  void sdsclear(sds s) {
105  	sdssetlen(s, 0);
106  	s[0] = &#x27;\0&#x27;;
107  }
108  sds sdsMakeRoomFor(sds s, size_t addlen) {
109  	void *sh, *newsh;
110  	size_t avail = sdsavail(s);
111  	size_t len, newlen;
112  	char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
113  	int hdrlen;
114  	if (avail &gt;= addlen) return s;
115  	len = sdslen(s);
116  	sh = (char*)s - sdsHdrSize(oldtype);
117  	newlen = (len + addlen);
118  	if (newlen &lt; SDS_MAX_PREALLOC)
119  		newlen *= 2;
120  	else
121  		newlen += SDS_MAX_PREALLOC;
122  	type = sdsReqType(newlen);
123  	if (type == SDS_TYPE_5) type = SDS_TYPE_8;
124  	hdrlen = sdsHdrSize(type);
125  	if (oldtype == type) {
126  		newsh = s_realloc(sh, hdrlen + newlen + 1);
127  		if (newsh == NULL) return NULL;
128  		s = (char*)newsh + hdrlen;
129  	}
130  	else {
131  		newsh = s_malloc(hdrlen + newlen + 1);
132  		if (newsh == NULL) return NULL;
133  		memcpy((char*)newsh + hdrlen, s, len + 1);
134  		s_free(sh);
135  		s = (char*)newsh + hdrlen;
136  		s[-1] = type;
137  		sdssetlen(s, len);
138  	}
139  	sdssetalloc(s, newlen);
140  	return s;
141  }
142  sds sdsRemoveFreeSpace(sds s) {
143  	void *sh, *newsh;
144  	char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
145  	int hdrlen;
146  	size_t len = sdslen(s);
147  	sh = (char*)s - sdsHdrSize(oldtype);
148  	type = sdsReqType(len);
149  	hdrlen = sdsHdrSize(type);
150  	if (oldtype == type) {
151  		newsh = s_realloc(sh, hdrlen + len + 1);
152  		if (newsh == NULL) return NULL;
153  		s = (char*)newsh + hdrlen;
154  	}
155  	else {
156  		newsh = s_malloc(hdrlen + len + 1);
157  		if (newsh == NULL) return NULL;
158  		memcpy((char*)newsh + hdrlen, s, len + 1);
159  		s_free(sh);
160  		s = (char*)newsh + hdrlen;
161  		s[-1] = type;
162  		sdssetlen(s, len);
163  	}
164  	sdssetalloc(s, len);
165  	return s;
166  }
167  size_t sdsAllocSize(sds s) {
168  	size_t alloc = sdsalloc(s);
169  	return sdsHdrSize(s[-1]) + alloc + 1;
170  }
171  void *sdsAllocPtr(sds s) {
172  	return (void*)(s - sdsHdrSize(s[-1]));
173  }
174  void sdsIncrLen(sds s, int incr) {
175  	unsigned char flags = s[-1];
176  	size_t len;
177  	switch (flags&amp;SDS_TYPE_MASK) {
178  	case SDS_TYPE_5: {
179  		unsigned char *fp = ((unsigned char*)s) - 1;
180  		unsigned char oldlen = SDS_TYPE_5_LEN(flags);
181  		assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr)));
182  		*fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS);
183  		len = oldlen + incr;
184  		break;
185  	}
186  	case SDS_TYPE_8: {
187  		SDS_HDR_VAR(8, s);
188  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
189  		len = (sh-&gt;len += incr);
190  		break;
191  	}
192  	case SDS_TYPE_16: {
193  		SDS_HDR_VAR(16, s);
194  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
195  		len = (sh-&gt;len += incr);
196  		break;
197  	}
198  	case SDS_TYPE_32: {
199  		SDS_HDR_VAR(32, s);
200  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= (unsigned int)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
201  		len = (sh-&gt;len += incr);
202  		break;
203  	}
204  	case SDS_TYPE_64: {
205  		SDS_HDR_VAR(64, s);
206  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= (uint64_t)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (uint64_t)(-incr)));
207  		len = (sh-&gt;len += incr);
208  		break;
209  	}
210  	default: len = 0; &amp;bsol;* Just to avoid compilation warnings. */
211  	}
212  	s[len] = &#x27;\0&#x27;;
213  }
214  sds sdsgrowzero(sds s, size_t len) {
215  	size_t curlen = sdslen(s);
216  	if (len &lt;= curlen) return s;
217  	s = sdsMakeRoomFor(s, len - curlen);
218  	if (s == NULL) return NULL;
219  	memset(s + curlen, 0, (len - curlen + 1)); &amp;bsol;* also set trailing \0 byte */
220  	sdssetlen(s, len);
221  	return s;
222  }
223  sds sdscatlen(sds s, const void *t, size_t len) {
224  	size_t curlen = sdslen(s);
225  	s = sdsMakeRoomFor(s, len);
226  	if (s == NULL) return NULL;
227  	memcpy(s + curlen, t, len);
228  	sdssetlen(s, curlen + len);
229  	s[curlen + len] = &#x27;\0&#x27;;
230  	return s;
231  }
232  sds sdscat(sds s, const char *t) {
233  	return sdscatlen(s, t, strlen(t));
234  }
235  sds sdscatsds(sds s, const sds t) {
236  	return sdscatlen(s, t, sdslen(t));
237  }
238  sds sdscpylen(sds s, const char *t, size_t len) {
239  	if (sdsalloc(s) &lt; len) {
240  		s = sdsMakeRoomFor(s, len - sdslen(s));
241  		if (s == NULL) return NULL;
242  	}
243  	memcpy(s, t, len);
244  	s[len] = &#x27;\0&#x27;;
245  	sdssetlen(s, len);
246  	return s;
247  }
248  sds sdscpy(sds s, const char *t) {
249  	return sdscpylen(s, t, strlen(t));
250  }
251  #define SDS_LLSTR_SIZE 21
252  int sdsll2str(char *s, PORT_LONGLONG value) {
253  	char *p, aux;
254  	PORT_ULONGLONG v;
255  	size_t l;
256  	v = (value &lt; 0) ? -value : value;
257  	p = s;
258  	do {
259  		*p++ = &#x27;0&#x27; + (v % 10);
260  		v /= 10;
261  	} while (v);
262  	if (value &lt; 0) *p++ = &#x27;-&#x27;;
263  	l = p - s;
264  	*p = &#x27;\0&#x27;;
265  	p--;
266  	while (s &lt; p) {
267  		aux = *s;
268  		*s = *p;
269  		*p = aux;
270  		s++;
271  		p--;
272  	}
273  	return (int)l;                                                              WIN_PORT_FIX &amp;bsol;* cast (int) */
274  }
275  int sdsull2str(char *s, PORT_ULONGLONG v) {
276  	char *p, aux;
277  	size_t l;
278  	p = s;
279  	do {
280  		*p++ = &#x27;0&#x27; + (v % 10);
281  		v /= 10;
282  	} while (v);
283  	l = p - s;
284  	*p = &#x27;\0&#x27;;
285  	p--;
286  	while (s &lt; p) {
287  		aux = *s;
288  		*s = *p;
289  		*p = aux;
290  		s++;
291  		p--;
292  	}
293  	return (int)l;
294  }
295  sds sdsfromlonglong(PORT_LONGLONG value) {
296  	char buf[SDS_LLSTR_SIZE];
297  	int len = sdsll2str(buf, value);
298  	return sdsnewlen(buf, len);
299  }
300  sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
301  	va_list cpy;
302  	char staticbuf[1024], *buf = staticbuf, *t;
303  	size_t buflen = strlen(fmt) * 2;
304  	if (buflen &gt; sizeof(staticbuf)) {
305  		buf = s_malloc(buflen);
306  		if (buf == NULL) return NULL;
307  	}
308  	else {
309  		buflen = sizeof(staticbuf);
310  	}
311  	while (1) {
312  		buf[buflen - 2] = &#x27;\0&#x27;;
313  		va_copy(cpy, ap);
314  		vsnprintf(buf, buflen WIN32_ONLY(-1), fmt, cpy);    
315  		va_end(cpy);
316  		if (buf[buflen - 2] != &#x27;\0&#x27;) {
317  			if (buf != staticbuf) s_free(buf);
318  			buflen *= 2;
319  			buf = s_malloc(buflen);
320  			if (buf == NULL) return NULL;
321  			continue;
322  		}
323  		break;
324  	}
325  	t = sdscat(s, buf);
326  	if (buf != staticbuf) s_free(buf);
327  	return t;
328  }
329  sds sdscatprintf(sds s, const char *fmt, ...) {
330  	va_list ap;
331  	char *t;
332  	va_start(ap, fmt);
333  	t = sdscatvprintf(s, fmt, ap);
334  	va_end(ap);
335  	return t;
336  }
337  sds sdscatfmt(sds s, char const *fmt, ...) {
338  	const char *f = fmt;
339  	int i;
340  	va_list ap;
341  	va_start(ap, fmt);
342  	i = sdslen(s); &amp;bsol;* Position of the next byte to write to dest str. */
343  	while (*f) {
344  		char next, *str;
345  		size_t l;
346  		PORT_LONGLONG num;
347  		PORT_ULONGLONG unum;
348  		if (sdsavail(s) == 0) {
349  			s = sdsMakeRoomFor(s, 1);
350  		}
351  		switch (*f) {
352  		case &#x27;%&#x27;:
353  			next = *(f + 1);
354  			f++;
355  			switch (next) {
356  			case &#x27;s&#x27;:
357  			case &#x27;S&#x27;:
358  				str = va_arg(ap, char*);
359  				l = (int)((next == &#x27;s&#x27;) ? strlen(str) : sdslen(str));           WIN_PORT_FIX &amp;bsol;* cast (int) */
360  					if (sdsavail(s) &lt; l) {
361  						s = sdsMakeRoomFor(s, l);
362  					}
363  				memcpy(s + i, str, l);
364  				sdsinclen(s, l);
365  				i += l;
366  				break;
367  			case &#x27;i&#x27;:
368  			case &#x27;I&#x27;:
369  				if (next == &#x27;i&#x27;)
370  					num = va_arg(ap, int);
371  				else
372  					num = va_arg(ap, PORT_LONGLONG);
373  				{
374  					char buf[SDS_LLSTR_SIZE];
375  					l = sdsll2str(buf, num);
376  					if (sdsavail(s) &lt; l) {
377  						s = sdsMakeRoomFor(s, l);
378  					}
379  					memcpy(s + i, buf, l);
380  					sdsinclen(s, l);
381  					i += l;
382  				}
383  				break;
384  			case &#x27;u&#x27;:
385  			case &#x27;U&#x27;:
386  				if (next == &#x27;u&#x27;)
387  					unum = va_arg(ap, unsigned int);
388  				else
389  					unum = va_arg(ap, PORT_ULONGLONG);
390  				{
391  					char buf[SDS_LLSTR_SIZE];
392  					l = sdsull2str(buf, unum);
393  					if (sdsavail(s) &lt; l) {
394  						s = sdsMakeRoomFor(s, l);
395  					}
396  					memcpy(s + i, buf, l);
397  					sdsinclen(s, l);
398  					i += l;
399  				}
400  				break;
401  			default: &amp;bsol;* Handle %% and generally %&lt;unknown&gt;. */
402  				s[i++] = next;
403  				sdsinclen(s, 1);
404  				break;
405  			}
406  			break;
407  		default:
408  			s[i++] = *f;
409  			sdsinclen(s, 1);
410  			break;
411  		}
412  		f++;
413  	}
414  	va_end(ap);
415  	s[i] = &#x27;\0&#x27;;
416  	return s;
417  }
418  sds sdstrim(sds s, const char *cset) {
419  	char *start, *end, *sp, *ep;
420  	size_t len;
421  	sp = start = s;
422  	ep = end = s + sdslen(s) - 1;
423  	while (sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++;
424  	while (ep &gt; sp &amp;&amp; strchr(cset, *ep)) ep--;
425  	len = (sp &gt; ep) ? 0 : ((ep - sp) + 1);
426  	if (s != sp) memmove(s, sp, len);
427  	s[len] = &#x27;\0&#x27;;
428  	sdssetlen(s, len);
429  	return s;
430  }
431  void sdsrange(sds s, int start, int end) {
432  	size_t newlen, len = sdslen(s);
433  	if (len == 0) return;
434  	if (start &lt; 0) {
435  		start = (int)len + start;                                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
436  			if (start &lt; 0) start = 0;
437  	}
438  	if (end &lt; 0) {
439  		end = (int)len + end;                                                     WIN_PORT_FIX &amp;bsol;* cast (int) */
440  			if (end &lt; 0) end = 0;
441  	}
442  	newlen = (start &gt; end) ? 0 : (end - start) + 1;
443  	if (newlen != 0) {
444  		if (start &gt;= (signed)len) {
445  			newlen = 0;
446  		}
447  		else if (end &gt;= (signed)len) {
448  			end = (int)len - 1;                                                   WIN_PORT_FIX &amp;bsol;* cast (int) */
449  				newlen = (start &gt; end) ? 0 : (end - start) + 1;
450  		}
451  	}
452  	else {
453  		start = 0;
454  	}
455  	if (start &amp;&amp; newlen) memmove(s, s + start, newlen);
456  	s[newlen] = 0;
457  	sdssetlen(s, newlen);
458  }
459  void sdstolower(sds s) {
460  	int len = (int)sdslen(s), j;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
461  		for (j = 0; j &lt; len; j++) s[j] = tolower(s[j]);
462  }
463  void sdstoupper(sds s) {
464  	int len = (int)sdslen(s), j;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
465  		for (j = 0; j &lt; len; j++) s[j] = toupper(s[j]);
466  }
467  int sdscmp(const sds s1, const sds s2) {
468  	size_t l1, l2, minlen;
469  	int cmp;
470  	l1 = sdslen(s1);
471  	l2 = sdslen(s2);
472  	minlen = (l1 &lt; l2) ? l1 : l2;
473  	cmp = memcmp(s1, s2, minlen);
474  	if (cmp == 0) return (int)(l1 - l2);                                          WIN_PORT_FIX &amp;bsol;* cast (int) */
475  		return cmp;
476  }
477  sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
478  	int elements = 0, slots = 5, start = 0, j;
479  	sds *tokens;
480  	if (seplen &lt; 1 || len &lt; 0) return NULL;
481  	tokens = s_malloc(sizeof(sds)*slots);
482  	if (tokens == NULL) return NULL;
483  	if (len == 0) {
484  		*count = 0;
485  		return tokens;
486  	}
487  	for (j = 0; j &lt; (len - (seplen - 1)); j++) {
488  		if (slots &lt; elements + 2) {
489  			sds *newtokens;
490  			slots *= 2;
491  			newtokens = s_realloc(tokens, sizeof(sds)*slots);
492  			if (newtokens == NULL) goto cleanup;
493  			tokens = newtokens;
494  		}
495  		if ((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {
496  			tokens[elements] = sdsnewlen(s + start, j - start);
497  			if (tokens[elements] == NULL) goto cleanup;
498  			elements++;
499  			start = j + seplen;
500  			j = j + seplen - 1; &amp;bsol;* skip the separator */
501  		}
502  	}
503  	tokens[elements] = sdsnewlen(s + start, len - start);
504  	if (tokens[elements] == NULL) goto cleanup;
505  	elements++;
506  	*count = elements;
507  	return tokens;
508  cleanup:
509  	{
510  		int i;
511  		for (i = 0; i &lt; elements; i++) sdsfree(tokens[i]);
512  		s_free(tokens);
513  		*count = 0;
514  		return NULL;
515  	}
516  }
517  void sdsfreesplitres(sds *tokens, int count) {
518  	if (!tokens) return;
519  	while (count--)
520  		sdsfree(tokens[count]);
521  	s_free(tokens);
522  }
523  sds sdscatrepr(sds s, const char *p, size_t len) {
524  	s = sdscatlen(s, &quot;\&quot;&quot;, 1);
525  	while (len--) {
526  		switch (*p) {
527  		case &#x27;\\&#x27;:
528  		case &#x27;&quot;&#x27;:
529  			s = sdscatprintf(s, &quot;\\%c&quot;, *p);
530  			break;
531  		case &#x27;\n&#x27;: s = sdscatlen(s, &quot;\\n&quot;, 2); break;
532  		case &#x27;\r&#x27;: s = sdscatlen(s, &quot;\\r&quot;, 2); break;
533  		case &#x27;\t&#x27;: s = sdscatlen(s, &quot;\\t&quot;, 2); break;
534  		case &#x27;\a&#x27;: s = sdscatlen(s, &quot;\\a&quot;, 2); break;
535  		case &#x27;\b&#x27;: s = sdscatlen(s, &quot;\\b&quot;, 2); break;
536  		default:
537  			if (isprint((unsigned char)*p))                                     WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
538  				s = sdscatprintf(s, &quot;%c&quot;, *p);
539  			else
540  				s = sdscatprintf(s, &quot;\\x%02x&quot;, (unsigned char)*p);
541  			break;
542  		}
543  		p++;
544  	}
545  	return sdscatlen(s, &quot;\&quot;&quot;, 1);
546  }
547  int is_hex_digit(char c) {
548  	return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;) ||
549  		(c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;);
550  }
551  int hex_digit_to_int(char c) {
552  	switch (c) {
553  	case &#x27;0&#x27;: return 0;
554  	case &#x27;1&#x27;: return 1;
555  	case &#x27;2&#x27;: return 2;
556  	case &#x27;3&#x27;: return 3;
557  	case &#x27;4&#x27;: return 4;
558  	case &#x27;5&#x27;: return 5;
559  	case &#x27;6&#x27;: return 6;
560  	case &#x27;7&#x27;: return 7;
561  	case &#x27;8&#x27;: return 8;
562  	case &#x27;9&#x27;: return 9;
563  	case &#x27;a&#x27;: case &#x27;A&#x27;: return 10;
564  	case &#x27;b&#x27;: case &#x27;B&#x27;: return 11;
565  	case &#x27;c&#x27;: case &#x27;C&#x27;: return 12;
566  	case &#x27;d&#x27;: case &#x27;D&#x27;: return 13;
567  	case &#x27;e&#x27;: case &#x27;E&#x27;: return 14;
568  	case &#x27;f&#x27;: case &#x27;F&#x27;: return 15;
569  	default: return 0;
570  	}
571  }
572  sds *sdssplitargs(const char *line, int *argc) {
573  	const char *p = line;
574  	char *current = NULL;
575  	char **vector = NULL;
576  	*argc = 0;
577  	while (1) {
578  		while (*p &amp;&amp; isspace(*p)) p++;
579  		if (*p) {
580  			int inq = 0;  &amp;bsol;* set to 1 if we are in &quot;quotes&quot; */
581  			int insq = 0; &amp;bsol;* set to 1 if we are in &#x27;single quotes&#x27; */
582  			int done = 0;
583  			if (current == NULL) current = sdsempty();
584  			while (!done) {
585  				if (inq) {
586  					if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1) == &#x27;x&#x27; &amp;&amp;
587  						is_hex_digit(*(p + 2)) &amp;&amp;
588  						is_hex_digit(*(p + 3)))
589  					{
590  						unsigned char byte;
591  						byte = (hex_digit_to_int(*(p + 2)) * 16) +
592  							hex_digit_to_int(*(p + 3));
593  						current = sdscatlen(current, (char*)&amp;byte, 1);
594  						p += 3;
595  					}
596  					else if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1)) {
597  						char c;
598  						p++;
599  						switch (*p) {
600  						case &#x27;n&#x27;: c = &#x27;\n&#x27;; break;
601  						case &#x27;r&#x27;: c = &#x27;\r&#x27;; break;
602  						case &#x27;t&#x27;: c = &#x27;\t&#x27;; break;
603  						case &#x27;b&#x27;: c = &#x27;\b&#x27;; break;
604  						case &#x27;a&#x27;: c = &#x27;\a&#x27;; break;
605  						default: c = *p; break;
606  						}
607  						current = sdscatlen(current, &amp;c, 1);
608  					}
<span onclick='openModal()' class='match'>609  					else if (*p == &#x27;&quot;&#x27;) {
610  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
611  						done = 1;
612  					}
613  					else if (!*p) {
614  						goto err;
615  					}
616  					else {
617  						current = sdscatlen(current, p, 1);
618  					}
619  				}
620  				else if (insq) {
</span>621  					if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1) == &#x27;\&#x27;&#x27;) {
622  						p++;
623  						current = sdscatlen(current, &quot;&#x27;&quot;, 1);
624  					}
625  					else if (*p == &#x27;\&#x27;&#x27;) {
626  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
627  						done = 1;
628  					}
629  					else if (!*p) {
630  						goto err;
631  					}
632  					else {
633  						current = sdscatlen(current, p, 1);
634  					}
635  				}
636  				else {
637  					switch (*p) {
638  					case &#x27; &#x27;:
639  					case &#x27;\n&#x27;:
640  					case &#x27;\r&#x27;:
641  					case &#x27;\t&#x27;:
642  					case &#x27;\0&#x27;:
643  						done = 1;
644  						break;
645  					case &#x27;&quot;&#x27;:
646  						inq = 1;
647  						break;
648  					case &#x27;\&#x27;&#x27;:
649  						insq = 1;
650  						break;
651  					default:
652  						current = sdscatlen(current, p, 1);
653  						break;
654  					}
655  				}
656  				if (*p) p++;
657  			}
658  			vector = s_realloc(vector, ((*argc) + 1) * sizeof(char*));
659  			vector[*argc] = current;
660  			(*argc)++;
661  			current = NULL;
662  		}
663  		else {
664  			if (vector == NULL) vector = s_malloc(sizeof(void*));
665  			return vector;
666  		}
667  	}
668  err:
669  	while ((*argc)--)
670  		sdsfree(vector[*argc]);
671  	s_free(vector);
672  	if (current) sdsfree(current);
673  	*argc = 0;
674  	return NULL;
675  }
676  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
677  	size_t j, i, l = sdslen(s);
678  	for (j = 0; j &lt; l; j++) {
679  		for (i = 0; i &lt; setlen; i++) {
680  			if (s[j] == from[i]) {
681  				s[j] = to[i];
682  				break;
683  			}
684  		}
685  	}
686  	return s;
687  }
688  sds sdsjoin(char **argv, int argc, char *sep) {
689  	sds join = sdsempty();
690  	int j;
691  	for (j = 0; j &lt; argc; j++) {
692  		join = sdscat(join, argv[j]);
693  		if (j != argc - 1) join = sdscat(join, sep);
694  	}
695  	return join;
696  }
697  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
698  	sds join = sdsempty();
699  	int j;
700  	for (j = 0; j &lt; argc; j++) {
701  		join = sdscatsds(join, argv[j]);
702  		if (j != argc - 1) join = sdscatlen(join, sep, seplen);
703  	}
704  	return join;
705  }
706  void *sds_malloc(size_t size) { return s_malloc(size); }
707  void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr, size); }
708  void sds_free(void *ptr) { s_free(ptr); }
709  #if defined(SDS_TEST_MAIN)
710  #include &lt;stdio.h&gt;
711  #include &quot;testhelp.h&quot;
712  #include &quot;limits.h&quot;
713  #define UNUSED(x) (void)(x)
714  int sdsTest(void) {
715  	{
716  		sds x = sdsnew(&quot;foo&quot;), y;
717  		test_cond(&quot;Create a string and obtain the length&quot;,
718  			sdslen(x) == 3 &amp;&amp; memcmp(x, &quot;foo\0&quot;, 4) == 0)
719  			sdsfree(x);
720  		x = sdsnewlen(&quot;foo&quot;, 2);
721  		test_cond(&quot;Create a string with specified length&quot;,
722  			sdslen(x) == 2 &amp;&amp; memcmp(x, &quot;fo\0&quot;, 3) == 0)
723  			x = sdscat(x, &quot;bar&quot;);
724  		test_cond(&quot;Strings concatenation&quot;,
725  			sdslen(x) == 5 &amp;&amp; memcmp(x, &quot;fobar\0&quot;, 6) == 0);
726  		x = sdscpy(x, &quot;a&quot;);
727  		test_cond(&quot;sdscpy() against an originally longer string&quot;,
728  			sdslen(x) == 1 &amp;&amp; memcmp(x, &quot;a\0&quot;, 2) == 0)
729  			x = sdscpy(x, &quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk&quot;);
730  		test_cond(&quot;sdscpy() against an originally shorter string&quot;,
731  			sdslen(x) == 33 &amp;&amp;
732  			memcmp(x, &quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0&quot;, 33) == 0)
733  			sdsfree(x);
734  		x = sdscatprintf(sdsempty(), &quot;%d&quot;, 123);
735  		test_cond(&quot;sdscatprintf() seems working in the base case&quot;,
736  			sdslen(x) == 3 &amp;&amp; memcmp(x, &quot;123\0&quot;, 4) == 0)
737  			sdsfree(x);
738  		x = sdsnew(&quot;--&quot;);
739  		x = sdscatfmt(x, &quot;Hello %s World %I,%I--&quot;, &quot;Hi!&quot;, LLONG_MIN, LLONG_MAX);
740  		test_cond(&quot;sdscatfmt() seems working in the base case&quot;,
741  			sdslen(x) == 60 &amp;&amp;
742  			memcmp(x, &quot;--Hello Hi! World -9223372036854775808,&quot;
743  				&quot;9223372036854775807--&quot;, 60) == 0)
744  			printf(&quot;[%s]\n&quot;, x);
745  		sdsfree(x);
746  		x = sdsnew(&quot;--&quot;);
747  		x = sdscatfmt(x, &quot;%u,%U--&quot;, UINT_MAX, ULLONG_MAX);
748  		test_cond(&quot;sdscatfmt() seems working with unsigned numbers&quot;,
749  			sdslen(x) == 35 &amp;&amp;
750  			memcmp(x, &quot;--4294967295,18446744073709551615--&quot;, 35) == 0)
751  			sdsfree(x);
752  		x = sdsnew(&quot; x &quot;);
753  		sdstrim(x, &quot; x&quot;);
754  		test_cond(&quot;sdstrim() works when all chars match&quot;,
755  			sdslen(x) == 0)
756  			sdsfree(x);
757  		x = sdsnew(&quot; x &quot;);
758  		sdstrim(x, &quot; &quot;);
759  		test_cond(&quot;sdstrim() works when a single char remains&quot;,
760  			sdslen(x) == 1 &amp;&amp; x[0] == &#x27;x&#x27;)
761  			sdsfree(x);
762  		x = sdsnew(&quot;xxciaoyyy&quot;);
763  		sdstrim(x, &quot;xy&quot;);
764  		test_cond(&quot;sdstrim() correctly trims characters&quot;,
765  			sdslen(x) == 4 &amp;&amp; memcmp(x, &quot;ciao\0&quot;, 5) == 0)
766  			y = sdsdup(x);
767  		sdsrange(y, 1, 1);
768  		test_cond(&quot;sdsrange(...,1,1)&quot;,
769  			sdslen(y) == 1 &amp;&amp; memcmp(y, &quot;i\0&quot;, 2) == 0)
770  			sdsfree(y);
771  		y = sdsdup(x);
772  		sdsrange(y, 1, -1);
773  		test_cond(&quot;sdsrange(...,1,-1)&quot;,
774  			sdslen(y) == 3 &amp;&amp; memcmp(y, &quot;iao\0&quot;, 4) == 0)
775  			sdsfree(y);
776  		y = sdsdup(x);
777  		sdsrange(y, -2, -1);
778  		test_cond(&quot;sdsrange(...,-2,-1)&quot;,
779  			sdslen(y) == 2 &amp;&amp; memcmp(y, &quot;ao\0&quot;, 3) == 0)
780  			sdsfree(y);
781  		y = sdsdup(x);
782  		sdsrange(y, 2, 1);
783  		test_cond(&quot;sdsrange(...,2,1)&quot;,
784  			sdslen(y) == 0 &amp;&amp; memcmp(y, &quot;\0&quot;, 1) == 0)
785  			sdsfree(y);
786  		y = sdsdup(x);
787  		sdsrange(y, 1, 100);
788  		test_cond(&quot;sdsrange(...,1,100)&quot;,
789  			sdslen(y) == 3 &amp;&amp; memcmp(y, &quot;iao\0&quot;, 4) == 0)
790  			sdsfree(y);
791  		y = sdsdup(x);
792  		sdsrange(y, 100, 100);
793  		test_cond(&quot;sdsrange(...,100,100)&quot;,
794  			sdslen(y) == 0 &amp;&amp; memcmp(y, &quot;\0&quot;, 1) == 0)
795  			sdsfree(y);
796  		sdsfree(x);
797  		x = sdsnew(&quot;foo&quot;);
798  		y = sdsnew(&quot;foa&quot;);
799  		test_cond(&quot;sdscmp(foo,foa)&quot;, sdscmp(x, y) &gt; 0)
800  			sdsfree(y);
801  		sdsfree(x);
802  		x = sdsnew(&quot;bar&quot;);
803  		y = sdsnew(&quot;bar&quot;);
804  		test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x, y) == 0)
805  			sdsfree(y);
806  		sdsfree(x);
807  		x = sdsnew(&quot;aar&quot;);
808  		y = sdsnew(&quot;bar&quot;);
809  		test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x, y) &lt; 0)
810  			sdsfree(y);
811  		sdsfree(x);
812  		x = sdsnewlen(&quot;\a\n\0foo\r&quot;, 7);
813  		y = sdscatrepr(sdsempty(), x, sdslen(x));
814  		test_cond(&quot;sdscatrepr(...data...)&quot;,
815  			memcmp(y, &quot;\&quot;\\a\\n\\x00foo\\r\&quot;&quot;, 15) == 0)
816  		{
817  			unsigned int oldfree;
818  			char *p;
819  			int step = 10, j, i;
820  			sdsfree(x);
821  			sdsfree(y);
822  			x = sdsnew(&quot;0&quot;);
823  			test_cond(&quot;sdsnew() free/len buffers&quot;, sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0);
824  			for (i = 0; i &lt; 10; i++) {
825  				int oldlen = sdslen(x);
826  				x = sdsMakeRoomFor(x, step);
827  				int type = x[-1] &amp; SDS_TYPE_MASK;
828  				test_cond(&quot;sdsMakeRoomFor() len&quot;, sdslen(x) == oldlen);
829  				if (type != SDS_TYPE_5) {
830  					test_cond(&quot;sdsMakeRoomFor() free&quot;, sdsavail(x) &gt;= step);
831  					oldfree = sdsavail(x);
832  				}
833  				p = x + oldlen;
834  				for (j = 0; j &lt; step; j++) {
835  					p[j] = &#x27;A&#x27; + j;
836  				}
837  				sdsIncrLen(x, step);
838  			}
839  			test_cond(&quot;sdsMakeRoomFor() content&quot;,
840  				memcmp(&quot;0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ&quot;, x, 101) == 0);
841  			test_cond(&quot;sdsMakeRoomFor() final length&quot;, sdslen(x) == 101);
842  			sdsfree(x);
843  		}
844  	}
845  	test_report()
846  		return 0;
847  }
848  #endif
849  #ifdef SDS_TEST_MAIN
850  int main(void) {
851  	return sdsTest();
852  }
853  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #include &lt;ctype.h&gt;
5  #include &lt;assert.h&gt;
6  #include &quot;sds.h&quot;
7  #include &quot;sdsalloc.h&quot;
8  static inline int sdsHdrSize(char type) {
9  	switch (type&amp;SDS_TYPE_MASK) {
10  	case SDS_TYPE_5:
11  		return sizeof(struct sdshdr5);
12  	case SDS_TYPE_8:
13  		return sizeof(struct sdshdr8);
14  	case SDS_TYPE_16:
15  		return sizeof(struct sdshdr16);
16  	case SDS_TYPE_32:
17  		return sizeof(struct sdshdr32);
18  	case SDS_TYPE_64:
19  		return sizeof(struct sdshdr64);
20  	}
21  	return 0;
22  }
23  static inline char sdsReqType(size_t string_size) {
24  	if (string_size &lt; 32)
25  		return SDS_TYPE_5;
26  	if (string_size &lt; 0xff)
27  		return SDS_TYPE_8;
28  	if (string_size &lt; 0xffff)
29  		return SDS_TYPE_16;
30  	if (string_size &lt; 0xffffffff)
31  		return SDS_TYPE_32;
32  	return SDS_TYPE_64;
33  }
34  sds sdsnewlen(const void *init, size_t initlen) {
35  	void *sh;
36  	sds s;
37  	char type = sdsReqType(initlen);
38  	if (type == SDS_TYPE_5 &amp;&amp; initlen == 0) type = SDS_TYPE_8;
39  	int hdrlen = sdsHdrSize(type);
40  	unsigned char *fp; &amp;bsol;* flags pointer. */
41  	sh = s_malloc(hdrlen + initlen + 1);
42  	if (sh == NULL) return NULL;
43  	if (!init)
44  		memset(sh, 0, hdrlen + initlen + 1);
45  	s = (char*)sh + hdrlen;
46  	fp = ((unsigned char*)s) - 1;
47  	switch (type) {
48  	case SDS_TYPE_5: {
49  		*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);
50  		break;
51  	}
52  	case SDS_TYPE_8: {
53  		SDS_HDR_VAR(8, s);
54  		sh-&gt;len = initlen;
55  		sh-&gt;alloc = initlen;
56  		*fp = type;
57  		break;
58  	}
59  	case SDS_TYPE_16: {
60  		SDS_HDR_VAR(16, s);
61  		sh-&gt;len = initlen;
62  		sh-&gt;alloc = initlen;
63  		*fp = type;
64  		break;
65  	}
66  	case SDS_TYPE_32: {
67  		SDS_HDR_VAR(32, s);
68  		sh-&gt;len = initlen;
69  		sh-&gt;alloc = initlen;
70  		*fp = type;
71  		break;
72  	}
73  	case SDS_TYPE_64: {
74  		SDS_HDR_VAR(64, s);
75  		sh-&gt;len = initlen;
76  		sh-&gt;alloc = initlen;
77  		*fp = type;
78  		break;
79  	}
80  	}
81  	if (initlen &amp;&amp; init)
82  		memcpy(s, init, initlen);
83  	s[initlen] = &#x27;\0&#x27;;
84  	return s;
85  }
86  sds sdsempty(void) {
87  	return sdsnewlen(&quot;&quot;, 0);
88  }
89  sds sdsnew(const char *init) {
90  	size_t initlen = (init == NULL) ? 0 : strlen(init);
91  	return sdsnewlen(init, initlen);
92  }
93  sds sdsdup(const sds s) {
94  	return sdsnewlen(s, sdslen(s));
95  }
96  void sdsfree(sds s) {
97  	if (s == NULL) return;
98  	s_free((char*)s - sdsHdrSize(s[-1]));
99  }
100  void sdsupdatelen(sds s) {
101  	int reallen = strlen(s);
102  	sdssetlen(s, reallen);
103  }
104  void sdsclear(sds s) {
105  	sdssetlen(s, 0);
106  	s[0] = &#x27;\0&#x27;;
107  }
108  sds sdsMakeRoomFor(sds s, size_t addlen) {
109  	void *sh, *newsh;
110  	size_t avail = sdsavail(s);
111  	size_t len, newlen;
112  	char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
113  	int hdrlen;
114  	if (avail &gt;= addlen) return s;
115  	len = sdslen(s);
116  	sh = (char*)s - sdsHdrSize(oldtype);
117  	newlen = (len + addlen);
118  	if (newlen &lt; SDS_MAX_PREALLOC)
119  		newlen *= 2;
120  	else
121  		newlen += SDS_MAX_PREALLOC;
122  	type = sdsReqType(newlen);
123  	if (type == SDS_TYPE_5) type = SDS_TYPE_8;
124  	hdrlen = sdsHdrSize(type);
125  	if (oldtype == type) {
126  		newsh = s_realloc(sh, hdrlen + newlen + 1);
127  		if (newsh == NULL) return NULL;
128  		s = (char*)newsh + hdrlen;
129  	}
130  	else {
131  		newsh = s_malloc(hdrlen + newlen + 1);
132  		if (newsh == NULL) return NULL;
133  		memcpy((char*)newsh + hdrlen, s, len + 1);
134  		s_free(sh);
135  		s = (char*)newsh + hdrlen;
136  		s[-1] = type;
137  		sdssetlen(s, len);
138  	}
139  	sdssetalloc(s, newlen);
140  	return s;
141  }
142  sds sdsRemoveFreeSpace(sds s) {
143  	void *sh, *newsh;
144  	char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
145  	int hdrlen;
146  	size_t len = sdslen(s);
147  	sh = (char*)s - sdsHdrSize(oldtype);
148  	type = sdsReqType(len);
149  	hdrlen = sdsHdrSize(type);
150  	if (oldtype == type) {
151  		newsh = s_realloc(sh, hdrlen + len + 1);
152  		if (newsh == NULL) return NULL;
153  		s = (char*)newsh + hdrlen;
154  	}
155  	else {
156  		newsh = s_malloc(hdrlen + len + 1);
157  		if (newsh == NULL) return NULL;
158  		memcpy((char*)newsh + hdrlen, s, len + 1);
159  		s_free(sh);
160  		s = (char*)newsh + hdrlen;
161  		s[-1] = type;
162  		sdssetlen(s, len);
163  	}
164  	sdssetalloc(s, len);
165  	return s;
166  }
167  size_t sdsAllocSize(sds s) {
168  	size_t alloc = sdsalloc(s);
169  	return sdsHdrSize(s[-1]) + alloc + 1;
170  }
171  void *sdsAllocPtr(sds s) {
172  	return (void*)(s - sdsHdrSize(s[-1]));
173  }
174  void sdsIncrLen(sds s, int incr) {
175  	unsigned char flags = s[-1];
176  	size_t len;
177  	switch (flags&amp;SDS_TYPE_MASK) {
178  	case SDS_TYPE_5: {
179  		unsigned char *fp = ((unsigned char*)s) - 1;
180  		unsigned char oldlen = SDS_TYPE_5_LEN(flags);
181  		assert((incr &gt; 0 &amp;&amp; oldlen + incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr)));
182  		*fp = SDS_TYPE_5 | ((oldlen + incr) &lt;&lt; SDS_TYPE_BITS);
183  		len = oldlen + incr;
184  		break;
185  	}
186  	case SDS_TYPE_8: {
187  		SDS_HDR_VAR(8, s);
188  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
189  		len = (sh-&gt;len += incr);
190  		break;
191  	}
192  	case SDS_TYPE_16: {
193  		SDS_HDR_VAR(16, s);
194  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
195  		len = (sh-&gt;len += incr);
196  		break;
197  	}
198  	case SDS_TYPE_32: {
199  		SDS_HDR_VAR(32, s);
200  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= (unsigned int)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
201  		len = (sh-&gt;len += incr);
202  		break;
203  	}
204  	case SDS_TYPE_64: {
205  		SDS_HDR_VAR(64, s);
206  		assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc - sh-&gt;len &gt;= (uint64_t)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (uint64_t)(-incr)));
207  		len = (sh-&gt;len += incr);
208  		break;
209  	}
210  	default: len = 0; &amp;bsol;* Just to avoid compilation warnings. */
211  	}
212  	s[len] = &#x27;\0&#x27;;
213  }
214  sds sdsgrowzero(sds s, size_t len) {
215  	size_t curlen = sdslen(s);
216  	if (len &lt;= curlen) return s;
217  	s = sdsMakeRoomFor(s, len - curlen);
218  	if (s == NULL) return NULL;
219  	memset(s + curlen, 0, (len - curlen + 1)); &amp;bsol;* also set trailing \0 byte */
220  	sdssetlen(s, len);
221  	return s;
222  }
223  sds sdscatlen(sds s, const void *t, size_t len) {
224  	size_t curlen = sdslen(s);
225  	s = sdsMakeRoomFor(s, len);
226  	if (s == NULL) return NULL;
227  	memcpy(s + curlen, t, len);
228  	sdssetlen(s, curlen + len);
229  	s[curlen + len] = &#x27;\0&#x27;;
230  	return s;
231  }
232  sds sdscat(sds s, const char *t) {
233  	return sdscatlen(s, t, strlen(t));
234  }
235  sds sdscatsds(sds s, const sds t) {
236  	return sdscatlen(s, t, sdslen(t));
237  }
238  sds sdscpylen(sds s, const char *t, size_t len) {
239  	if (sdsalloc(s) &lt; len) {
240  		s = sdsMakeRoomFor(s, len - sdslen(s));
241  		if (s == NULL) return NULL;
242  	}
243  	memcpy(s, t, len);
244  	s[len] = &#x27;\0&#x27;;
245  	sdssetlen(s, len);
246  	return s;
247  }
248  sds sdscpy(sds s, const char *t) {
249  	return sdscpylen(s, t, strlen(t));
250  }
251  #define SDS_LLSTR_SIZE 21
252  int sdsll2str(char *s, PORT_LONGLONG value) {
253  	char *p, aux;
254  	PORT_ULONGLONG v;
255  	size_t l;
256  	v = (value &lt; 0) ? -value : value;
257  	p = s;
258  	do {
259  		*p++ = &#x27;0&#x27; + (v % 10);
260  		v /= 10;
261  	} while (v);
262  	if (value &lt; 0) *p++ = &#x27;-&#x27;;
263  	l = p - s;
264  	*p = &#x27;\0&#x27;;
265  	p--;
266  	while (s &lt; p) {
267  		aux = *s;
268  		*s = *p;
269  		*p = aux;
270  		s++;
271  		p--;
272  	}
273  	return (int)l;                                                              WIN_PORT_FIX &amp;bsol;* cast (int) */
274  }
275  int sdsull2str(char *s, PORT_ULONGLONG v) {
276  	char *p, aux;
277  	size_t l;
278  	p = s;
279  	do {
280  		*p++ = &#x27;0&#x27; + (v % 10);
281  		v /= 10;
282  	} while (v);
283  	l = p - s;
284  	*p = &#x27;\0&#x27;;
285  	p--;
286  	while (s &lt; p) {
287  		aux = *s;
288  		*s = *p;
289  		*p = aux;
290  		s++;
291  		p--;
292  	}
293  	return (int)l;
294  }
295  sds sdsfromlonglong(PORT_LONGLONG value) {
296  	char buf[SDS_LLSTR_SIZE];
297  	int len = sdsll2str(buf, value);
298  	return sdsnewlen(buf, len);
299  }
300  sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
301  	va_list cpy;
302  	char staticbuf[1024], *buf = staticbuf, *t;
303  	size_t buflen = strlen(fmt) * 2;
304  	if (buflen &gt; sizeof(staticbuf)) {
305  		buf = s_malloc(buflen);
306  		if (buf == NULL) return NULL;
307  	}
308  	else {
309  		buflen = sizeof(staticbuf);
310  	}
311  	while (1) {
312  		buf[buflen - 2] = &#x27;\0&#x27;;
313  		va_copy(cpy, ap);
314  		vsnprintf(buf, buflen WIN32_ONLY(-1), fmt, cpy);    
315  		va_end(cpy);
316  		if (buf[buflen - 2] != &#x27;\0&#x27;) {
317  			if (buf != staticbuf) s_free(buf);
318  			buflen *= 2;
319  			buf = s_malloc(buflen);
320  			if (buf == NULL) return NULL;
321  			continue;
322  		}
323  		break;
324  	}
325  	t = sdscat(s, buf);
326  	if (buf != staticbuf) s_free(buf);
327  	return t;
328  }
329  sds sdscatprintf(sds s, const char *fmt, ...) {
330  	va_list ap;
331  	char *t;
332  	va_start(ap, fmt);
333  	t = sdscatvprintf(s, fmt, ap);
334  	va_end(ap);
335  	return t;
336  }
337  sds sdscatfmt(sds s, char const *fmt, ...) {
338  	const char *f = fmt;
339  	int i;
340  	va_list ap;
341  	va_start(ap, fmt);
342  	i = sdslen(s); &amp;bsol;* Position of the next byte to write to dest str. */
343  	while (*f) {
344  		char next, *str;
345  		size_t l;
346  		PORT_LONGLONG num;
347  		PORT_ULONGLONG unum;
348  		if (sdsavail(s) == 0) {
349  			s = sdsMakeRoomFor(s, 1);
350  		}
351  		switch (*f) {
352  		case &#x27;%&#x27;:
353  			next = *(f + 1);
354  			f++;
355  			switch (next) {
356  			case &#x27;s&#x27;:
357  			case &#x27;S&#x27;:
358  				str = va_arg(ap, char*);
359  				l = (int)((next == &#x27;s&#x27;) ? strlen(str) : sdslen(str));           WIN_PORT_FIX &amp;bsol;* cast (int) */
360  					if (sdsavail(s) &lt; l) {
361  						s = sdsMakeRoomFor(s, l);
362  					}
363  				memcpy(s + i, str, l);
364  				sdsinclen(s, l);
365  				i += l;
366  				break;
367  			case &#x27;i&#x27;:
368  			case &#x27;I&#x27;:
369  				if (next == &#x27;i&#x27;)
370  					num = va_arg(ap, int);
371  				else
372  					num = va_arg(ap, PORT_LONGLONG);
373  				{
374  					char buf[SDS_LLSTR_SIZE];
375  					l = sdsll2str(buf, num);
376  					if (sdsavail(s) &lt; l) {
377  						s = sdsMakeRoomFor(s, l);
378  					}
379  					memcpy(s + i, buf, l);
380  					sdsinclen(s, l);
381  					i += l;
382  				}
383  				break;
384  			case &#x27;u&#x27;:
385  			case &#x27;U&#x27;:
386  				if (next == &#x27;u&#x27;)
387  					unum = va_arg(ap, unsigned int);
388  				else
389  					unum = va_arg(ap, PORT_ULONGLONG);
390  				{
391  					char buf[SDS_LLSTR_SIZE];
392  					l = sdsull2str(buf, unum);
393  					if (sdsavail(s) &lt; l) {
394  						s = sdsMakeRoomFor(s, l);
395  					}
396  					memcpy(s + i, buf, l);
397  					sdsinclen(s, l);
398  					i += l;
399  				}
400  				break;
401  			default: &amp;bsol;* Handle %% and generally %&lt;unknown&gt;. */
402  				s[i++] = next;
403  				sdsinclen(s, 1);
404  				break;
405  			}
406  			break;
407  		default:
408  			s[i++] = *f;
409  			sdsinclen(s, 1);
410  			break;
411  		}
412  		f++;
413  	}
414  	va_end(ap);
415  	s[i] = &#x27;\0&#x27;;
416  	return s;
417  }
418  sds sdstrim(sds s, const char *cset) {
419  	char *start, *end, *sp, *ep;
420  	size_t len;
421  	sp = start = s;
422  	ep = end = s + sdslen(s) - 1;
423  	while (sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++;
424  	while (ep &gt; sp &amp;&amp; strchr(cset, *ep)) ep--;
425  	len = (sp &gt; ep) ? 0 : ((ep - sp) + 1);
426  	if (s != sp) memmove(s, sp, len);
427  	s[len] = &#x27;\0&#x27;;
428  	sdssetlen(s, len);
429  	return s;
430  }
431  void sdsrange(sds s, int start, int end) {
432  	size_t newlen, len = sdslen(s);
433  	if (len == 0) return;
434  	if (start &lt; 0) {
435  		start = (int)len + start;                                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
436  			if (start &lt; 0) start = 0;
437  	}
438  	if (end &lt; 0) {
439  		end = (int)len + end;                                                     WIN_PORT_FIX &amp;bsol;* cast (int) */
440  			if (end &lt; 0) end = 0;
441  	}
442  	newlen = (start &gt; end) ? 0 : (end - start) + 1;
443  	if (newlen != 0) {
444  		if (start &gt;= (signed)len) {
445  			newlen = 0;
446  		}
447  		else if (end &gt;= (signed)len) {
448  			end = (int)len - 1;                                                   WIN_PORT_FIX &amp;bsol;* cast (int) */
449  				newlen = (start &gt; end) ? 0 : (end - start) + 1;
450  		}
451  	}
452  	else {
453  		start = 0;
454  	}
455  	if (start &amp;&amp; newlen) memmove(s, s + start, newlen);
456  	s[newlen] = 0;
457  	sdssetlen(s, newlen);
458  }
459  void sdstolower(sds s) {
460  	int len = (int)sdslen(s), j;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
461  		for (j = 0; j &lt; len; j++) s[j] = tolower(s[j]);
462  }
463  void sdstoupper(sds s) {
464  	int len = (int)sdslen(s), j;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
465  		for (j = 0; j &lt; len; j++) s[j] = toupper(s[j]);
466  }
467  int sdscmp(const sds s1, const sds s2) {
468  	size_t l1, l2, minlen;
469  	int cmp;
470  	l1 = sdslen(s1);
471  	l2 = sdslen(s2);
472  	minlen = (l1 &lt; l2) ? l1 : l2;
473  	cmp = memcmp(s1, s2, minlen);
474  	if (cmp == 0) return (int)(l1 - l2);                                          WIN_PORT_FIX &amp;bsol;* cast (int) */
475  		return cmp;
476  }
477  sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
478  	int elements = 0, slots = 5, start = 0, j;
479  	sds *tokens;
480  	if (seplen &lt; 1 || len &lt; 0) return NULL;
481  	tokens = s_malloc(sizeof(sds)*slots);
482  	if (tokens == NULL) return NULL;
483  	if (len == 0) {
484  		*count = 0;
485  		return tokens;
486  	}
487  	for (j = 0; j &lt; (len - (seplen - 1)); j++) {
488  		if (slots &lt; elements + 2) {
489  			sds *newtokens;
490  			slots *= 2;
491  			newtokens = s_realloc(tokens, sizeof(sds)*slots);
492  			if (newtokens == NULL) goto cleanup;
493  			tokens = newtokens;
494  		}
495  		if ((seplen == 1 &amp;&amp; *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {
496  			tokens[elements] = sdsnewlen(s + start, j - start);
497  			if (tokens[elements] == NULL) goto cleanup;
498  			elements++;
499  			start = j + seplen;
500  			j = j + seplen - 1; &amp;bsol;* skip the separator */
501  		}
502  	}
503  	tokens[elements] = sdsnewlen(s + start, len - start);
504  	if (tokens[elements] == NULL) goto cleanup;
505  	elements++;
506  	*count = elements;
507  	return tokens;
508  cleanup:
509  	{
510  		int i;
511  		for (i = 0; i &lt; elements; i++) sdsfree(tokens[i]);
512  		s_free(tokens);
513  		*count = 0;
514  		return NULL;
515  	}
516  }
517  void sdsfreesplitres(sds *tokens, int count) {
518  	if (!tokens) return;
519  	while (count--)
520  		sdsfree(tokens[count]);
521  	s_free(tokens);
522  }
523  sds sdscatrepr(sds s, const char *p, size_t len) {
524  	s = sdscatlen(s, &quot;\&quot;&quot;, 1);
525  	while (len--) {
526  		switch (*p) {
527  		case &#x27;\\&#x27;:
528  		case &#x27;&quot;&#x27;:
529  			s = sdscatprintf(s, &quot;\\%c&quot;, *p);
530  			break;
531  		case &#x27;\n&#x27;: s = sdscatlen(s, &quot;\\n&quot;, 2); break;
532  		case &#x27;\r&#x27;: s = sdscatlen(s, &quot;\\r&quot;, 2); break;
533  		case &#x27;\t&#x27;: s = sdscatlen(s, &quot;\\t&quot;, 2); break;
534  		case &#x27;\a&#x27;: s = sdscatlen(s, &quot;\\a&quot;, 2); break;
535  		case &#x27;\b&#x27;: s = sdscatlen(s, &quot;\\b&quot;, 2); break;
536  		default:
537  			if (isprint((unsigned char)*p))                                     WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
538  				s = sdscatprintf(s, &quot;%c&quot;, *p);
539  			else
540  				s = sdscatprintf(s, &quot;\\x%02x&quot;, (unsigned char)*p);
541  			break;
542  		}
543  		p++;
544  	}
545  	return sdscatlen(s, &quot;\&quot;&quot;, 1);
546  }
547  int is_hex_digit(char c) {
548  	return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;) ||
549  		(c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;);
550  }
551  int hex_digit_to_int(char c) {
552  	switch (c) {
553  	case &#x27;0&#x27;: return 0;
554  	case &#x27;1&#x27;: return 1;
555  	case &#x27;2&#x27;: return 2;
556  	case &#x27;3&#x27;: return 3;
557  	case &#x27;4&#x27;: return 4;
558  	case &#x27;5&#x27;: return 5;
559  	case &#x27;6&#x27;: return 6;
560  	case &#x27;7&#x27;: return 7;
561  	case &#x27;8&#x27;: return 8;
562  	case &#x27;9&#x27;: return 9;
563  	case &#x27;a&#x27;: case &#x27;A&#x27;: return 10;
564  	case &#x27;b&#x27;: case &#x27;B&#x27;: return 11;
565  	case &#x27;c&#x27;: case &#x27;C&#x27;: return 12;
566  	case &#x27;d&#x27;: case &#x27;D&#x27;: return 13;
567  	case &#x27;e&#x27;: case &#x27;E&#x27;: return 14;
568  	case &#x27;f&#x27;: case &#x27;F&#x27;: return 15;
569  	default: return 0;
570  	}
571  }
572  sds *sdssplitargs(const char *line, int *argc) {
573  	const char *p = line;
574  	char *current = NULL;
575  	char **vector = NULL;
576  	*argc = 0;
577  	while (1) {
578  		while (*p &amp;&amp; isspace(*p)) p++;
579  		if (*p) {
580  			int inq = 0;  &amp;bsol;* set to 1 if we are in &quot;quotes&quot; */
581  			int insq = 0; &amp;bsol;* set to 1 if we are in &#x27;single quotes&#x27; */
582  			int done = 0;
583  			if (current == NULL) current = sdsempty();
584  			while (!done) {
585  				if (inq) {
586  					if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1) == &#x27;x&#x27; &amp;&amp;
587  						is_hex_digit(*(p + 2)) &amp;&amp;
588  						is_hex_digit(*(p + 3)))
589  					{
590  						unsigned char byte;
591  						byte = (hex_digit_to_int(*(p + 2)) * 16) +
592  							hex_digit_to_int(*(p + 3));
593  						current = sdscatlen(current, (char*)&amp;byte, 1);
594  						p += 3;
595  					}
596  					else if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1)) {
597  						char c;
598  						p++;
599  						switch (*p) {
600  						case &#x27;n&#x27;: c = &#x27;\n&#x27;; break;
601  						case &#x27;r&#x27;: c = &#x27;\r&#x27;; break;
602  						case &#x27;t&#x27;: c = &#x27;\t&#x27;; break;
603  						case &#x27;b&#x27;: c = &#x27;\b&#x27;; break;
604  						case &#x27;a&#x27;: c = &#x27;\a&#x27;; break;
605  						default: c = *p; break;
606  						}
607  						current = sdscatlen(current, &amp;c, 1);
608  					}
609  					else if (*p == &#x27;&quot;&#x27;) {
610  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
611  						done = 1;
612  					}
613  					else if (!*p) {
614  						goto err;
615  					}
616  					else {
617  						current = sdscatlen(current, p, 1);
618  					}
619  				}
620  				else if (insq) {
621  					if (*p == &#x27;\\&#x27; &amp;&amp; *(p + 1) == &#x27;\&#x27;&#x27;) {
622  						p++;
623  						current = sdscatlen(current, &quot;&#x27;&quot;, 1);
624  					}
<span onclick='openModal()' class='match'>625  					else if (*p == &#x27;\&#x27;&#x27;) {
626  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
627  						done = 1;
628  					}
629  					else if (!*p) {
630  						goto err;
631  					}
632  					else {
633  						current = sdscatlen(current, p, 1);
634  					}
635  				}
636  				else {
</span>637  					switch (*p) {
638  					case &#x27; &#x27;:
639  					case &#x27;\n&#x27;:
640  					case &#x27;\r&#x27;:
641  					case &#x27;\t&#x27;:
642  					case &#x27;\0&#x27;:
643  						done = 1;
644  						break;
645  					case &#x27;&quot;&#x27;:
646  						inq = 1;
647  						break;
648  					case &#x27;\&#x27;&#x27;:
649  						insq = 1;
650  						break;
651  					default:
652  						current = sdscatlen(current, p, 1);
653  						break;
654  					}
655  				}
656  				if (*p) p++;
657  			}
658  			vector = s_realloc(vector, ((*argc) + 1) * sizeof(char*));
659  			vector[*argc] = current;
660  			(*argc)++;
661  			current = NULL;
662  		}
663  		else {
664  			if (vector == NULL) vector = s_malloc(sizeof(void*));
665  			return vector;
666  		}
667  	}
668  err:
669  	while ((*argc)--)
670  		sdsfree(vector[*argc]);
671  	s_free(vector);
672  	if (current) sdsfree(current);
673  	*argc = 0;
674  	return NULL;
675  }
676  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
677  	size_t j, i, l = sdslen(s);
678  	for (j = 0; j &lt; l; j++) {
679  		for (i = 0; i &lt; setlen; i++) {
680  			if (s[j] == from[i]) {
681  				s[j] = to[i];
682  				break;
683  			}
684  		}
685  	}
686  	return s;
687  }
688  sds sdsjoin(char **argv, int argc, char *sep) {
689  	sds join = sdsempty();
690  	int j;
691  	for (j = 0; j &lt; argc; j++) {
692  		join = sdscat(join, argv[j]);
693  		if (j != argc - 1) join = sdscat(join, sep);
694  	}
695  	return join;
696  }
697  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
698  	sds join = sdsempty();
699  	int j;
700  	for (j = 0; j &lt; argc; j++) {
701  		join = sdscatsds(join, argv[j]);
702  		if (j != argc - 1) join = sdscatlen(join, sep, seplen);
703  	}
704  	return join;
705  }
706  void *sds_malloc(size_t size) { return s_malloc(size); }
707  void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr, size); }
708  void sds_free(void *ptr) { s_free(ptr); }
709  #if defined(SDS_TEST_MAIN)
710  #include &lt;stdio.h&gt;
711  #include &quot;testhelp.h&quot;
712  #include &quot;limits.h&quot;
713  #define UNUSED(x) (void)(x)
714  int sdsTest(void) {
715  	{
716  		sds x = sdsnew(&quot;foo&quot;), y;
717  		test_cond(&quot;Create a string and obtain the length&quot;,
718  			sdslen(x) == 3 &amp;&amp; memcmp(x, &quot;foo\0&quot;, 4) == 0)
719  			sdsfree(x);
720  		x = sdsnewlen(&quot;foo&quot;, 2);
721  		test_cond(&quot;Create a string with specified length&quot;,
722  			sdslen(x) == 2 &amp;&amp; memcmp(x, &quot;fo\0&quot;, 3) == 0)
723  			x = sdscat(x, &quot;bar&quot;);
724  		test_cond(&quot;Strings concatenation&quot;,
725  			sdslen(x) == 5 &amp;&amp; memcmp(x, &quot;fobar\0&quot;, 6) == 0);
726  		x = sdscpy(x, &quot;a&quot;);
727  		test_cond(&quot;sdscpy() against an originally longer string&quot;,
728  			sdslen(x) == 1 &amp;&amp; memcmp(x, &quot;a\0&quot;, 2) == 0)
729  			x = sdscpy(x, &quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk&quot;);
730  		test_cond(&quot;sdscpy() against an originally shorter string&quot;,
731  			sdslen(x) == 33 &amp;&amp;
732  			memcmp(x, &quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0&quot;, 33) == 0)
733  			sdsfree(x);
734  		x = sdscatprintf(sdsempty(), &quot;%d&quot;, 123);
735  		test_cond(&quot;sdscatprintf() seems working in the base case&quot;,
736  			sdslen(x) == 3 &amp;&amp; memcmp(x, &quot;123\0&quot;, 4) == 0)
737  			sdsfree(x);
738  		x = sdsnew(&quot;--&quot;);
739  		x = sdscatfmt(x, &quot;Hello %s World %I,%I--&quot;, &quot;Hi!&quot;, LLONG_MIN, LLONG_MAX);
740  		test_cond(&quot;sdscatfmt() seems working in the base case&quot;,
741  			sdslen(x) == 60 &amp;&amp;
742  			memcmp(x, &quot;--Hello Hi! World -9223372036854775808,&quot;
743  				&quot;9223372036854775807--&quot;, 60) == 0)
744  			printf(&quot;[%s]\n&quot;, x);
745  		sdsfree(x);
746  		x = sdsnew(&quot;--&quot;);
747  		x = sdscatfmt(x, &quot;%u,%U--&quot;, UINT_MAX, ULLONG_MAX);
748  		test_cond(&quot;sdscatfmt() seems working with unsigned numbers&quot;,
749  			sdslen(x) == 35 &amp;&amp;
750  			memcmp(x, &quot;--4294967295,18446744073709551615--&quot;, 35) == 0)
751  			sdsfree(x);
752  		x = sdsnew(&quot; x &quot;);
753  		sdstrim(x, &quot; x&quot;);
754  		test_cond(&quot;sdstrim() works when all chars match&quot;,
755  			sdslen(x) == 0)
756  			sdsfree(x);
757  		x = sdsnew(&quot; x &quot;);
758  		sdstrim(x, &quot; &quot;);
759  		test_cond(&quot;sdstrim() works when a single char remains&quot;,
760  			sdslen(x) == 1 &amp;&amp; x[0] == &#x27;x&#x27;)
761  			sdsfree(x);
762  		x = sdsnew(&quot;xxciaoyyy&quot;);
763  		sdstrim(x, &quot;xy&quot;);
764  		test_cond(&quot;sdstrim() correctly trims characters&quot;,
765  			sdslen(x) == 4 &amp;&amp; memcmp(x, &quot;ciao\0&quot;, 5) == 0)
766  			y = sdsdup(x);
767  		sdsrange(y, 1, 1);
768  		test_cond(&quot;sdsrange(...,1,1)&quot;,
769  			sdslen(y) == 1 &amp;&amp; memcmp(y, &quot;i\0&quot;, 2) == 0)
770  			sdsfree(y);
771  		y = sdsdup(x);
772  		sdsrange(y, 1, -1);
773  		test_cond(&quot;sdsrange(...,1,-1)&quot;,
774  			sdslen(y) == 3 &amp;&amp; memcmp(y, &quot;iao\0&quot;, 4) == 0)
775  			sdsfree(y);
776  		y = sdsdup(x);
777  		sdsrange(y, -2, -1);
778  		test_cond(&quot;sdsrange(...,-2,-1)&quot;,
779  			sdslen(y) == 2 &amp;&amp; memcmp(y, &quot;ao\0&quot;, 3) == 0)
780  			sdsfree(y);
781  		y = sdsdup(x);
782  		sdsrange(y, 2, 1);
783  		test_cond(&quot;sdsrange(...,2,1)&quot;,
784  			sdslen(y) == 0 &amp;&amp; memcmp(y, &quot;\0&quot;, 1) == 0)
785  			sdsfree(y);
786  		y = sdsdup(x);
787  		sdsrange(y, 1, 100);
788  		test_cond(&quot;sdsrange(...,1,100)&quot;,
789  			sdslen(y) == 3 &amp;&amp; memcmp(y, &quot;iao\0&quot;, 4) == 0)
790  			sdsfree(y);
791  		y = sdsdup(x);
792  		sdsrange(y, 100, 100);
793  		test_cond(&quot;sdsrange(...,100,100)&quot;,
794  			sdslen(y) == 0 &amp;&amp; memcmp(y, &quot;\0&quot;, 1) == 0)
795  			sdsfree(y);
796  		sdsfree(x);
797  		x = sdsnew(&quot;foo&quot;);
798  		y = sdsnew(&quot;foa&quot;);
799  		test_cond(&quot;sdscmp(foo,foa)&quot;, sdscmp(x, y) &gt; 0)
800  			sdsfree(y);
801  		sdsfree(x);
802  		x = sdsnew(&quot;bar&quot;);
803  		y = sdsnew(&quot;bar&quot;);
804  		test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x, y) == 0)
805  			sdsfree(y);
806  		sdsfree(x);
807  		x = sdsnew(&quot;aar&quot;);
808  		y = sdsnew(&quot;bar&quot;);
809  		test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x, y) &lt; 0)
810  			sdsfree(y);
811  		sdsfree(x);
812  		x = sdsnewlen(&quot;\a\n\0foo\r&quot;, 7);
813  		y = sdscatrepr(sdsempty(), x, sdslen(x));
814  		test_cond(&quot;sdscatrepr(...data...)&quot;,
815  			memcmp(y, &quot;\&quot;\\a\\n\\x00foo\\r\&quot;&quot;, 15) == 0)
816  		{
817  			unsigned int oldfree;
818  			char *p;
819  			int step = 10, j, i;
820  			sdsfree(x);
821  			sdsfree(y);
822  			x = sdsnew(&quot;0&quot;);
823  			test_cond(&quot;sdsnew() free/len buffers&quot;, sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0);
824  			for (i = 0; i &lt; 10; i++) {
825  				int oldlen = sdslen(x);
826  				x = sdsMakeRoomFor(x, step);
827  				int type = x[-1] &amp; SDS_TYPE_MASK;
828  				test_cond(&quot;sdsMakeRoomFor() len&quot;, sdslen(x) == oldlen);
829  				if (type != SDS_TYPE_5) {
830  					test_cond(&quot;sdsMakeRoomFor() free&quot;, sdsavail(x) &gt;= step);
831  					oldfree = sdsavail(x);
832  				}
833  				p = x + oldlen;
834  				for (j = 0; j &lt; step; j++) {
835  					p[j] = &#x27;A&#x27; + j;
836  				}
837  				sdsIncrLen(x, step);
838  			}
839  			test_cond(&quot;sdsMakeRoomFor() content&quot;,
840  				memcmp(&quot;0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ&quot;, x, 101) == 0);
841  			test_cond(&quot;sdsMakeRoomFor() final length&quot;, sdslen(x) == 101);
842  			sdsfree(x);
843  		}
844  	}
845  	test_report()
846  		return 0;
847  }
848  #endif
849  #ifdef SDS_TEST_MAIN
850  int main(void) {
851  	return sdsTest();
852  }
853  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds.c</div>
                </div>
                <div class="column column_space"><pre><code>609  					else if (*p == &#x27;&quot;&#x27;) {
610  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
611  						done = 1;
612  					}
613  					else if (!*p) {
614  						goto err;
615  					}
616  					else {
617  						current = sdscatlen(current, p, 1);
618  					}
619  				}
620  				else if (insq) {
</pre></code></div>
                <div class="column column_space"><pre><code>625  					else if (*p == &#x27;\&#x27;&#x27;) {
626  						if (*(p + 1) &amp;&amp; !isspace(*(p + 1))) goto err;
627  						done = 1;
628  					}
629  					else if (!*p) {
630  						goto err;
631  					}
632  					else {
633  						current = sdscatlen(current, p, 1);
634  					}
635  				}
636  				else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    