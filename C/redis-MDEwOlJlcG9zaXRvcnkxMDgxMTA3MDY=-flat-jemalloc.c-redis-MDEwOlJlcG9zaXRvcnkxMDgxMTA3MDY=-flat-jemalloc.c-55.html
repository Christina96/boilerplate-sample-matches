
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</h3>
            <pre><code>1  #define JEMALLOC_C_
2  #include &quot;jemalloc/internal/jemalloc_preamble.h&quot;
3  #include &quot;jemalloc/internal/jemalloc_internal_includes.h&quot;
4  #include &quot;jemalloc/internal/assert.h&quot;
5  #include &quot;jemalloc/internal/atomic.h&quot;
6  #include &quot;jemalloc/internal/ctl.h&quot;
7  #include &quot;jemalloc/internal/extent_dss.h&quot;
8  #include &quot;jemalloc/internal/extent_mmap.h&quot;
9  #include &quot;jemalloc/internal/hook.h&quot;
10  #include &quot;jemalloc/internal/jemalloc_internal_types.h&quot;
11  #include &quot;jemalloc/internal/log.h&quot;
12  #include &quot;jemalloc/internal/malloc_io.h&quot;
13  #include &quot;jemalloc/internal/mutex.h&quot;
14  #include &quot;jemalloc/internal/rtree.h&quot;
15  #include &quot;jemalloc/internal/safety_check.h&quot;
16  #include &quot;jemalloc/internal/sc.h&quot;
17  #include &quot;jemalloc/internal/spin.h&quot;
18  #include &quot;jemalloc/internal/sz.h&quot;
19  #include &quot;jemalloc/internal/ticker.h&quot;
20  #include &quot;jemalloc/internal/util.h&quot;
21  const char	*je_malloc_conf
22  #ifndef _WIN32
23      JEMALLOC_ATTR(weak)
24  #endif
25      ;
26  bool	opt_abort =
27  #ifdef JEMALLOC_DEBUG
28      true
29  #else
30      false
31  #endif
32      ;
33  bool	opt_abort_conf =
34  #ifdef JEMALLOC_DEBUG
35      true
36  #else
37      false
38  #endif
39      ;
40  bool	opt_confirm_conf = false;
41  const char	*opt_junk =
42  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
43      &quot;true&quot;
44  #else
45      &quot;false&quot;
46  #endif
47      ;
48  bool	opt_junk_alloc =
49  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
50      true
51  #else
52      false
53  #endif
54      ;
55  bool	opt_junk_free =
56  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
57      true
58  #else
59      false
60  #endif
61      ;
62  bool	opt_utrace = false;
63  bool	opt_xmalloc = false;
64  bool	opt_zero = false;
65  unsigned	opt_narenas = 0;
66  unsigned	ncpus;
67  malloc_mutex_t arenas_lock;
68  JEMALLOC_ALIGNED(CACHELINE)
69  atomic_p_t		arenas[MALLOCX_ARENA_LIMIT];
70  static atomic_u_t	narenas_total; &amp;bsol;* Use narenas_total_*(). */
71  static arena_t		*a0; &amp;bsol;* arenas[0]. */
72  unsigned		narenas_auto;
73  unsigned		manual_arena_base;
74  typedef enum {
75  	malloc_init_uninitialized	= 3,
76  	malloc_init_a0_initialized	= 2,
77  	malloc_init_recursible		= 1,
78  	malloc_init_initialized		= 0 &amp;bsol;* Common case --&gt; jnz. */
79  } malloc_init_t;
80  static malloc_init_t	malloc_init_state = malloc_init_uninitialized;
81  bool			malloc_slow = true;
82  enum {
83  	flag_opt_junk_alloc	= (1U),
84  	flag_opt_junk_free	= (1U &lt;&lt; 1),
85  	flag_opt_zero		= (1U &lt;&lt; 2),
86  	flag_opt_utrace		= (1U &lt;&lt; 3),
87  	flag_opt_xmalloc	= (1U &lt;&lt; 4)
88  };
89  static uint8_t	malloc_slow_flags;
90  #ifdef JEMALLOC_THREADED_INIT
91  #  define NO_INITIALIZER	((unsigned long)0)
92  #  define INITIALIZER		pthread_self()
93  #  define IS_INITIALIZER	(malloc_initializer == pthread_self())
94  static pthread_t		malloc_initializer = NO_INITIALIZER;
95  #else
96  #  define NO_INITIALIZER	false
97  #  define INITIALIZER		true
98  #  define IS_INITIALIZER	malloc_initializer
99  static bool			malloc_initializer = NO_INITIALIZER;
100  #endif
101  #ifdef _WIN32
102  #if _WIN32_WINNT &gt;= 0x0600
103  static malloc_mutex_t	init_lock = SRWLOCK_INIT;
104  #else
105  static malloc_mutex_t	init_lock;
106  static bool init_lock_initialized = false;
107  JEMALLOC_ATTR(constructor)
108  static void WINAPI
109  _init_init_lock(void) {
110  	if (!init_lock_initialized) {
111  		malloc_mutex_init(&amp;init_lock, &quot;init&quot;, WITNESS_RANK_INIT,
112  		    malloc_mutex_rank_exclusive);
113  	}
114  	init_lock_initialized = true;
115  }
116  #ifdef _MSC_VER
117  #  pragma section(&quot;.CRT$XCU&quot;, read)
118  JEMALLOC_SECTION(&quot;.CRT$XCU&quot;) JEMALLOC_ATTR(used)
119  static const void (WINAPI *init_init_lock)(void) = _init_init_lock;
120  #endif
121  #endif
122  #else
123  static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
124  #endif
125  typedef struct {
126  	void	*p;	&amp;bsol;* Input pointer (as in realloc(p, s)). */
127  	size_t	s;	&amp;bsol;* Request size. */
128  	void	*r;	&amp;bsol;* Result pointer. */
129  } malloc_utrace_t;
130  #ifdef JEMALLOC_UTRACE
131  #  define UTRACE(a, b, c) do {						\
132  	if (unlikely(opt_utrace)) {					\
133  		int utrace_serrno = errno;				\
134  		malloc_utrace_t ut;					\
135  		ut.p = (a);						\
136  		ut.s = (b);						\
137  		ut.r = (c);						\
138  		utrace(&amp;ut, sizeof(ut));				\
139  		errno = utrace_serrno;					\
140  	}								\
141  } while (0)
142  #else
143  #  define UTRACE(a, b, c)
144  #endif
145  static bool had_conf_error = false;
146  static bool	malloc_init_hard_a0(void);
147  static bool	malloc_init_hard(void);
148  bool
149  malloc_initialized(void) {
150  	return (malloc_init_state == malloc_init_initialized);
151  }
152  JEMALLOC_ALWAYS_INLINE bool
153  malloc_init_a0(void) {
154  	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
155  		return malloc_init_hard_a0();
156  	}
157  	return false;
158  }
159  JEMALLOC_ALWAYS_INLINE bool
160  malloc_init(void) {
161  	if (unlikely(!malloc_initialized()) &amp;&amp; malloc_init_hard()) {
162  		return true;
163  	}
164  	return false;
165  }
166  static void *
167  a0ialloc(size_t size, bool zero, bool is_internal) {
168  	if (unlikely(malloc_init_a0())) {
169  		return NULL;
170  	}
171  	return iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,
172  	    is_internal, arena_get(TSDN_NULL, 0, true), true);
173  }
174  static void
175  a0idalloc(void *ptr, bool is_internal) {
176  	idalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);
177  }
178  void *
179  a0malloc(size_t size) {
180  	return a0ialloc(size, false, true);
181  }
182  void
183  a0dalloc(void *ptr) {
184  	a0idalloc(ptr, true);
185  }
186  void *
187  bootstrap_malloc(size_t size) {
188  	if (unlikely(size == 0)) {
189  		size = 1;
190  	}
191  	return a0ialloc(size, false, false);
192  }
193  void *
194  bootstrap_calloc(size_t num, size_t size) {
195  	size_t num_size;
196  	num_size = num * size;
197  	if (unlikely(num_size == 0)) {
198  		assert(num == 0 || size == 0);
199  		num_size = 1;
200  	}
201  	return a0ialloc(num_size, true, false);
202  }
203  void
204  bootstrap_free(void *ptr) {
205  	if (unlikely(ptr == NULL)) {
206  		return;
207  	}
208  	a0idalloc(ptr, false);
209  }
210  void
211  arena_set(unsigned ind, arena_t *arena) {
212  	atomic_store_p(&amp;arenas[ind], arena, ATOMIC_RELEASE);
213  }
214  static void
215  narenas_total_set(unsigned narenas) {
216  	atomic_store_u(&amp;narenas_total, narenas, ATOMIC_RELEASE);
217  }
218  static void
219  narenas_total_inc(void) {
220  	atomic_fetch_add_u(&amp;narenas_total, 1, ATOMIC_RELEASE);
221  }
222  unsigned
223  narenas_total_get(void) {
224  	return atomic_load_u(&amp;narenas_total, ATOMIC_ACQUIRE);
225  }
226  static arena_t *
227  arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
228  	arena_t *arena;
229  	assert(ind &lt;= narenas_total_get());
230  	if (ind &gt;= MALLOCX_ARENA_LIMIT) {
231  		return NULL;
232  	}
233  	if (ind == narenas_total_get()) {
234  		narenas_total_inc();
235  	}
236  	arena = arena_get(tsdn, ind, false);
237  	if (arena != NULL) {
238  		assert(arena_is_auto(arena));
239  		return arena;
240  	}
241  	arena = arena_new(tsdn, ind, extent_hooks);
242  	return arena;
243  }
244  static void
245  arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
246  	if (ind == 0) {
247  		return;
248  	}
249  	if (have_background_thread &amp;&amp; !arena_is_huge(ind)) {
250  		if (background_thread_create(tsdn_tsd(tsdn), ind)) {
251  			malloc_printf(&quot;&lt;jemalloc&gt;: error in background thread &quot;
252  				      &quot;creation for arena %u. Abort.\n&quot;, ind);
253  			abort();
254  		}
255  	}
256  }
257  arena_t *
258  arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
259  	arena_t *arena;
260  	malloc_mutex_lock(tsdn, &amp;arenas_lock);
261  	arena = arena_init_locked(tsdn, ind, extent_hooks);
262  	malloc_mutex_unlock(tsdn, &amp;arenas_lock);
263  	arena_new_create_background_thread(tsdn, ind);
264  	return arena;
265  }
266  static void
267  arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
268  	arena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);
269  	arena_nthreads_inc(arena, internal);
270  	if (internal) {
271  		tsd_iarena_set(tsd, arena);
272  	} else {
273  		tsd_arena_set(tsd, arena);
274  		unsigned shard = atomic_fetch_add_u(&amp;arena-&gt;binshard_next, 1,
275  		    ATOMIC_RELAXED);
276  		tsd_binshards_t *bins = tsd_binshardsp_get(tsd);
277  		for (unsigned i = 0; i &lt; SC_NBINS; i++) {
278  			assert(bin_infos[i].n_shards &gt; 0 &amp;&amp;
279  			    bin_infos[i].n_shards &lt;= BIN_SHARDS_MAX);
280  			bins-&gt;binshard[i] = shard % bin_infos[i].n_shards;
281  		}
282  	}
283  }
284  void
285  arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
286  	arena_t *oldarena, *newarena;
287  	oldarena = arena_get(tsd_tsdn(tsd), oldind, false);
288  	newarena = arena_get(tsd_tsdn(tsd), newind, false);
289  	arena_nthreads_dec(oldarena, false);
290  	arena_nthreads_inc(newarena, false);
291  	tsd_arena_set(tsd, newarena);
292  }
293  static void
294  arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
295  	arena_t *arena;
296  	arena = arena_get(tsd_tsdn(tsd), ind, false);
297  	arena_nthreads_dec(arena, internal);
298  	if (internal) {
299  		tsd_iarena_set(tsd, NULL);
300  	} else {
301  		tsd_arena_set(tsd, NULL);
302  	}
303  }
304  arena_tdata_t *
305  arena_tdata_get_hard(tsd_t *tsd, unsigned ind) {
306  	arena_tdata_t *tdata, *arenas_tdata_old;
307  	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
308  	unsigned narenas_tdata_old, i;
309  	unsigned narenas_tdata = tsd_narenas_tdata_get(tsd);
310  	unsigned narenas_actual = narenas_total_get();
311  	if (arenas_tdata != NULL &amp;&amp; narenas_tdata &lt; narenas_actual) {
312  		arenas_tdata_old = arenas_tdata;
313  		narenas_tdata_old = narenas_tdata;
314  		arenas_tdata = NULL;
315  		narenas_tdata = 0;
316  		tsd_arenas_tdata_set(tsd, arenas_tdata);
317  		tsd_narenas_tdata_set(tsd, narenas_tdata);
318  	} else {
319  		arenas_tdata_old = NULL;
320  		narenas_tdata_old = 0;
321  	}
322  	if (arenas_tdata == NULL) {
323  		bool *arenas_tdata_bypassp = tsd_arenas_tdata_bypassp_get(tsd);
324  		narenas_tdata = (ind &lt; narenas_actual) ? narenas_actual : ind+1;
325  		if (tsd_nominal(tsd) &amp;&amp; !*arenas_tdata_bypassp) {
326  			*arenas_tdata_bypassp = true;
327  			arenas_tdata = (arena_tdata_t *)a0malloc(
328  			    sizeof(arena_tdata_t) * narenas_tdata);
329  			*arenas_tdata_bypassp = false;
330  		}
331  		if (arenas_tdata == NULL) {
332  			tdata = NULL;
333  			goto label_return;
334  		}
335  		assert(tsd_nominal(tsd) &amp;&amp; !*arenas_tdata_bypassp);
336  		tsd_arenas_tdata_set(tsd, arenas_tdata);
337  		tsd_narenas_tdata_set(tsd, narenas_tdata);
338  	}
339  	for (i = 0; i &lt; narenas_actual; i++) {
340  		if (i &lt; narenas_tdata_old) {
341  			ticker_copy(&amp;arenas_tdata[i].decay_ticker,
342  			    &amp;arenas_tdata_old[i].decay_ticker);
343  		} else {
344  			ticker_init(&amp;arenas_tdata[i].decay_ticker,
345  			    DECAY_NTICKS_PER_UPDATE);
346  		}
347  	}
348  	if (narenas_tdata &gt; narenas_actual) {
349  		memset(&amp;arenas_tdata[narenas_actual], 0, sizeof(arena_tdata_t)
350  		    * (narenas_tdata - narenas_actual));
351  	}
352  	tdata = &amp;arenas_tdata[ind];
353  label_return:
354  	if (arenas_tdata_old != NULL) {
355  		a0dalloc(arenas_tdata_old);
356  	}
357  	return tdata;
358  }
359  arena_t *
360  arena_choose_hard(tsd_t *tsd, bool internal) {
361  	arena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);
362  	if (have_percpu_arena &amp;&amp; PERCPU_ARENA_ENABLED(opt_percpu_arena)) {
363  		unsigned choose = percpu_arena_choose();
364  		ret = arena_get(tsd_tsdn(tsd), choose, true);
365  		assert(ret != NULL);
366  		arena_bind(tsd, arena_ind_get(ret), false);
367  		arena_bind(tsd, arena_ind_get(ret), true);
368  		return ret;
369  	}
370  	if (narenas_auto &gt; 1) {
371  		unsigned i, j, choose[2], first_null;
372  		bool is_new_arena[2];
373  		for (j = 0; j &lt; 2; j++) {
374  			choose[j] = 0;
375  			is_new_arena[j] = false;
376  		}
377  		first_null = narenas_auto;
378  		malloc_mutex_lock(tsd_tsdn(tsd), &amp;arenas_lock);
379  		assert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);
380  		for (i = 1; i &lt; narenas_auto; i++) {
381  			if (arena_get(tsd_tsdn(tsd), i, false) != NULL) {
382  				for (j = 0; j &lt; 2; j++) {
383  					if (arena_nthreads_get(arena_get(
384  					    tsd_tsdn(tsd), i, false), !!j) &lt;
385  					    arena_nthreads_get(arena_get(
386  					    tsd_tsdn(tsd), choose[j], false),
387  					    !!j)) {
388  						choose[j] = i;
389  					}
390  				}
391  			} else if (first_null == narenas_auto) {
392  				first_null = i;
393  			}
394  		}
395  		for (j = 0; j &lt; 2; j++) {
396  			if (arena_nthreads_get(arena_get(tsd_tsdn(tsd),
397  			    choose[j], false), !!j) == 0 || first_null ==
398  			    narenas_auto) {
399  				if (!!j == internal) {
400  					ret = arena_get(tsd_tsdn(tsd),
401  					    choose[j], false);
402  				}
403  			} else {
404  				arena_t *arena;
405  				choose[j] = first_null;
406  				arena = arena_init_locked(tsd_tsdn(tsd),
407  				    choose[j],
408  				    (extent_hooks_t *)&amp;extent_hooks_default);
409  				if (arena == NULL) {
410  					malloc_mutex_unlock(tsd_tsdn(tsd),
411  					    &amp;arenas_lock);
412  					return NULL;
413  				}
414  				is_new_arena[j] = true;
415  				if (!!j == internal) {
416  					ret = arena;
417  				}
418  			}
419  			arena_bind(tsd, choose[j], !!j);
420  		}
421  		malloc_mutex_unlock(tsd_tsdn(tsd), &amp;arenas_lock);
422  		for (j = 0; j &lt; 2; j++) {
423  			if (is_new_arena[j]) {
424  				assert(choose[j] &gt; 0);
425  				arena_new_create_background_thread(
426  				    tsd_tsdn(tsd), choose[j]);
427  			}
428  		}
429  	} else {
430  		ret = arena_get(tsd_tsdn(tsd), 0, false);
431  		arena_bind(tsd, 0, false);
432  		arena_bind(tsd, 0, true);
433  	}
434  	return ret;
435  }
436  void
437  iarena_cleanup(tsd_t *tsd) {
438  	arena_t *iarena;
439  	iarena = tsd_iarena_get(tsd);
440  	if (iarena != NULL) {
441  		arena_unbind(tsd, arena_ind_get(iarena), true);
442  	}
443  }
444  void
445  arena_cleanup(tsd_t *tsd) {
446  	arena_t *arena;
447  	arena = tsd_arena_get(tsd);
448  	if (arena != NULL) {
449  		arena_unbind(tsd, arena_ind_get(arena), false);
450  	}
451  }
452  void
453  arenas_tdata_cleanup(tsd_t *tsd) {
454  	arena_tdata_t *arenas_tdata;
455  	*tsd_arenas_tdata_bypassp_get(tsd) = true;
456  	arenas_tdata = tsd_arenas_tdata_get(tsd);
457  	if (arenas_tdata != NULL) {
458  		tsd_arenas_tdata_set(tsd, NULL);
459  		a0dalloc(arenas_tdata);
460  	}
461  }
462  static void
463  stats_print_atexit(void) {
464  	if (config_stats) {
465  		tsdn_t *tsdn;
466  		unsigned narenas, i;
467  		tsdn = tsdn_fetch();
468  		for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
469  			arena_t *arena = arena_get(tsdn, i, false);
470  			if (arena != NULL) {
471  				tcache_t *tcache;
472  				malloc_mutex_lock(tsdn, &amp;arena-&gt;tcache_ql_mtx);
473  				ql_foreach(tcache, &amp;arena-&gt;tcache_ql, link) {
474  					tcache_stats_merge(tsdn, tcache, arena);
475  				}
476  				malloc_mutex_unlock(tsdn,
477  				    &amp;arena-&gt;tcache_ql_mtx);
478  			}
479  		}
480  	}
481  	je_malloc_stats_print(NULL, NULL, opt_stats_print_opts);
482  }
483  JEMALLOC_ALWAYS_INLINE void
484  check_entry_exit_locking(tsdn_t *tsdn) {
485  	if (!config_debug) {
486  		return;
487  	}
488  	if (tsdn_null(tsdn)) {
489  		return;
490  	}
491  	tsd_t *tsd = tsdn_tsd(tsdn);
492  	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
493  	if (reentrancy_level != 0) {
494  		return;
495  	}
496  	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
497  }
498  static char *
499  jemalloc_secure_getenv(const char *name) {
500  #ifdef JEMALLOC_HAVE_SECURE_GETENV
501  	return secure_getenv(name);
502  #else
503  #  ifdef JEMALLOC_HAVE_ISSETUGID
504  	if (issetugid() != 0) {
505  		return NULL;
506  	}
507  #  endif
508  	return getenv(name);
509  #endif
510  }
511  static unsigned
512  malloc_ncpus(void) {
513  	long result;
514  #ifdef _WIN32
515  	SYSTEM_INFO si;
516  	GetSystemInfo(&amp;si);
517  	result = si.dwNumberOfProcessors;
518  #elif defined(JEMALLOC_GLIBC_MALLOC_HOOK) &amp;&amp; defined(CPU_COUNT)
519  	{
520  		cpu_set_t set;
521  		pthread_getaffinity_np(pthread_self(), sizeof(set), &amp;set);
522  		result = CPU_COUNT(&amp;set);
523  	}
524  #else
525  	result = sysconf(_SC_NPROCESSORS_ONLN);
526  #endif
527  	return ((result == -1) ? 1 : (unsigned)result);
528  }
529  static void
530  init_opt_stats_print_opts(const char *v, size_t vlen) {
531  	size_t opts_len = strlen(opt_stats_print_opts);
532  	assert(opts_len &lt;= stats_print_tot_num_options);
533  	for (size_t i = 0; i &lt; vlen; i++) {
534  		switch (v[i]) {
535  #define OPTION(o, v, d, s) case o: break;
536  			STATS_PRINT_OPTIONS
537  #undef OPTION
538  		default: continue;
539  		}
540  		if (strchr(opt_stats_print_opts, v[i]) != NULL) {
541  			continue;
542  		}
543  		opt_stats_print_opts[opts_len++] = v[i];
544  		opt_stats_print_opts[opts_len] = &#x27;\0&#x27;;
545  		assert(opts_len &lt;= stats_print_tot_num_options);
546  	}
547  	assert(opts_len == strlen(opt_stats_print_opts));
548  }
549  static bool
550  malloc_conf_multi_sizes_next(const char **slab_size_segment_cur,
551      size_t *vlen_left, size_t *slab_start, size_t *slab_end, size_t *new_size) {
552  	const char *cur = *slab_size_segment_cur;
553  	char *end;
554  	uintmax_t um;
555  	set_errno(0);
556  	um = malloc_strtoumax(cur, &amp;end, 0);
557  	if (get_errno() != 0 || *end != &#x27;-&#x27;) {
558  		return true;
559  	}
560  	*slab_start = (size_t)um;
561  	cur = end + 1;
562  	um = malloc_strtoumax(cur, &amp;end, 0);
563  	if (get_errno() != 0 || *end != &#x27;:&#x27;) {
564  		return true;
565  	}
566  	*slab_end = (size_t)um;
567  	cur = end + 1;
568  	um = malloc_strtoumax(cur, &amp;end, 0);
569  	if (get_errno() != 0) {
570  		return true;
571  	}
572  	*new_size = (size_t)um;
573  	if (*end == &#x27;|&#x27;) {
574  		end++;
575  	}
576  	*vlen_left -= end - *slab_size_segment_cur;
577  	*slab_size_segment_cur = end;
578  	return false;
579  }
580  static bool
581  malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
582      char const **v_p, size_t *vlen_p) {
583  	bool accept;
584  	const char *opts = *opts_p;
585  	*k_p = opts;
586  	for (accept = false; !accept;) {
587  		switch (*opts) {
588  		case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;: case &#x27;F&#x27;:
589  		case &#x27;G&#x27;: case &#x27;H&#x27;: case &#x27;I&#x27;: case &#x27;J&#x27;: case &#x27;K&#x27;: case &#x27;L&#x27;:
590  		case &#x27;M&#x27;: case &#x27;N&#x27;: case &#x27;O&#x27;: case &#x27;P&#x27;: case &#x27;Q&#x27;: case &#x27;R&#x27;:
591  		case &#x27;S&#x27;: case &#x27;T&#x27;: case &#x27;U&#x27;: case &#x27;V&#x27;: case &#x27;W&#x27;: case &#x27;X&#x27;:
592  		case &#x27;Y&#x27;: case &#x27;Z&#x27;:
593  		case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;: case &#x27;f&#x27;:
594  		case &#x27;g&#x27;: case &#x27;h&#x27;: case &#x27;i&#x27;: case &#x27;j&#x27;: case &#x27;k&#x27;: case &#x27;l&#x27;:
595  		case &#x27;m&#x27;: case &#x27;n&#x27;: case &#x27;o&#x27;: case &#x27;p&#x27;: case &#x27;q&#x27;: case &#x27;r&#x27;:
596  		case &#x27;s&#x27;: case &#x27;t&#x27;: case &#x27;u&#x27;: case &#x27;v&#x27;: case &#x27;w&#x27;: case &#x27;x&#x27;:
597  		case &#x27;y&#x27;: case &#x27;z&#x27;:
598  		case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;:
599  		case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
600  		case &#x27;_&#x27;:
601  			opts++;
602  			break;
603  		case &#x27;:&#x27;:
604  			opts++;
605  			*klen_p = (uintptr_t)opts - 1 - (uintptr_t)*k_p;
606  			*v_p = opts;
607  			accept = true;
608  			break;
609  		case &#x27;\0&#x27;:
610  			if (opts != *opts_p) {
611  				malloc_write(&quot;&lt;jemalloc&gt;: Conf string ends &quot;
612  				    &quot;with key\n&quot;);
613  			}
614  			return true;
615  		default:
616  			malloc_write(&quot;&lt;jemalloc&gt;: Malformed conf string\n&quot;);
617  			return true;
618  		}
619  	}
620  	for (accept = false; !accept;) {
621  		switch (*opts) {
622  		case &#x27;,&#x27;:
623  			opts++;
624  			if (*opts == &#x27;\0&#x27;) {
625  				malloc_write(&quot;&lt;jemalloc&gt;: Conf string ends &quot;
626  				    &quot;with comma\n&quot;);
627  			}
628  			*vlen_p = (uintptr_t)opts - 1 - (uintptr_t)*v_p;
629  			accept = true;
630  			break;
631  		case &#x27;\0&#x27;:
632  			*vlen_p = (uintptr_t)opts - (uintptr_t)*v_p;
633  			accept = true;
634  			break;
635  		default:
636  			opts++;
637  			break;
638  		}
639  	}
640  	*opts_p = opts;
641  	return false;
642  }
643  static void
644  malloc_abort_invalid_conf(void) {
645  	assert(opt_abort_conf);
646  	malloc_printf(&quot;&lt;jemalloc&gt;: Abort (abort_conf:true) on invalid conf &quot;
647  	    &quot;value (see above).\n&quot;);
648  	abort();
649  }
650  static void
651  malloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,
652      size_t vlen) {
653  	malloc_printf(&quot;&lt;jemalloc&gt;: %s: %.*s:%.*s\n&quot;, msg, (int)klen, k,
654  	    (int)vlen, v);
655  	const char *experimental = &quot;experimental_&quot;;
656  	if (strncmp(k, experimental, strlen(experimental)) == 0) {
657  		return;
658  	}
659  	had_conf_error = true;
660  }
661  static void
662  malloc_slow_flag_init(void) {
663  	malloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)
664  	    | (opt_junk_free ? flag_opt_junk_free : 0)
665  	    | (opt_zero ? flag_opt_zero : 0)
666  	    | (opt_utrace ? flag_opt_utrace : 0)
667  	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
668  	malloc_slow = (malloc_slow_flags != 0);
669  }
670  #define MALLOC_CONF_NSOURCES 4
671  static const char *
672  obtain_malloc_conf(unsigned which_source, char buf[PATH_MAX + 1]) {
673  	if (config_debug) {
674  		static unsigned read_source = 0;
675  		assert(read_source++ == which_source);
676  	}
677  	assert(which_source &lt; MALLOC_CONF_NSOURCES);
678  	const char *ret;
679  	switch (which_source) {
680  	case 0:
681  		ret = config_malloc_conf;
682  		break;
683  	case 1:
684  		if (je_malloc_conf != NULL) {
685  			ret = je_malloc_conf;
686  		} else {
687  			ret = NULL;
688  		}
689  		break;
690  	case 2: {
691  		ssize_t linklen = 0;
692  #ifndef _WIN32
693  		int saved_errno = errno;
694  		const char *linkname =
695  #  ifdef JEMALLOC_PREFIX
696  		    &quot;/etc/&quot;JEMALLOC_PREFIX&quot;malloc.conf&quot;
697  #  else
698  		    &quot;/etc/malloc.conf&quot;
699  #  endif
700  		    ;
701  #ifndef JEMALLOC_READLINKAT
702  		linklen = readlink(linkname, buf, PATH_MAX);
703  #else
704  		linklen = readlinkat(AT_FDCWD, linkname, buf, PATH_MAX);
705  #endif
706  		if (linklen == -1) {
707  			linklen = 0;
708  			set_errno(saved_errno);
709  		}
710  #endif
711  		buf[linklen] = &#x27;\0&#x27;;
712  		ret = buf;
713  		break;
714  	} case 3: {
715  		const char *envname =
716  #ifdef JEMALLOC_PREFIX
717  		    JEMALLOC_CPREFIX&quot;MALLOC_CONF&quot;
718  #else
719  		    &quot;MALLOC_CONF&quot;
720  #endif
721  		    ;
722  		if ((ret = jemalloc_secure_getenv(envname)) != NULL) {
723  		} else {
724  			ret = NULL;
725  		}
726  		break;
727  	} default:
728  		not_reached();
729  		ret = NULL;
730  	}
731  	return ret;
732  }
733  static void
734  malloc_conf_init_helper(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS],
735      bool initial_call, const char *opts_cache[MALLOC_CONF_NSOURCES],
736      char buf[PATH_MAX + 1]) {
737  	static const char *opts_explain[MALLOC_CONF_NSOURCES] = {
738  		&quot;string specified via --with-malloc-conf&quot;,
739  		&quot;string pointed to by the global variable malloc_conf&quot;,
740  		&quot;\&quot;name\&quot; of the file referenced by the symbolic link named &quot;
741  		    &quot;/etc/malloc.conf&quot;,
742  		&quot;value of the environment variable MALLOC_CONF&quot;
743  	};
744  	unsigned i;
745  	const char *opts, *k, *v;
746  	size_t klen, vlen;
747  	for (i = 0; i &lt; MALLOC_CONF_NSOURCES; i++) {
748  		if (initial_call) {
749  			opts_cache[i] = obtain_malloc_conf(i, buf);
750  		}
751  		opts = opts_cache[i];
752  		if (!initial_call &amp;&amp; opt_confirm_conf) {
753  			malloc_printf(
754  			    &quot;&lt;jemalloc&gt;: malloc_conf #%u (%s): \&quot;%s\&quot;\n&quot;,
755  			    i + 1, opts_explain[i], opts != NULL ? opts : &quot;&quot;);
756  		}
757  		if (opts == NULL) {
758  			continue;
759  		}
760  		while (*opts != &#x27;\0&#x27; &amp;&amp; !malloc_conf_next(&amp;opts, &amp;k, &amp;klen, &amp;v,
761  		    &amp;vlen)) {
762  #define CONF_ERROR(msg, k, klen, v, vlen)				\
763  			if (!initial_call) {				\
764  				malloc_conf_error(			\
765  				    msg, k, klen, v, vlen);		\
766  				cur_opt_valid = false;			\
767  			}
768  #define CONF_CONTINUE	{						\
769  				if (!initial_call &amp;&amp; opt_confirm_conf	\
770  				    &amp;&amp; cur_opt_valid) {			\
771  					malloc_printf(&quot;&lt;jemalloc&gt;: -- &quot;	\
772  					    &quot;Set conf value: %.*s:%.*s&quot;	\
773  					    &quot;\n&quot;, (int)klen, k,		\
774  					    (int)vlen, v);		\
775  				}					\
776  				continue;				\
777  			}
778  #define CONF_MATCH(n)							\
779  	(sizeof(n)-1 == klen &amp;&amp; strncmp(n, k, klen) == 0)
780  #define CONF_MATCH_VALUE(n)						\
781  	(sizeof(n)-1 == vlen &amp;&amp; strncmp(n, v, vlen) == 0)
782  #define CONF_HANDLE_BOOL(o, n)						\
783  			if (CONF_MATCH(n)) {				\
784  				if (CONF_MATCH_VALUE(&quot;true&quot;)) {		\
785  					o = true;			\
786  				} else if (CONF_MATCH_VALUE(&quot;false&quot;)) {	\
787  					o = false;			\
788  				} else {				\
789  					CONF_ERROR(&quot;Invalid conf value&quot;,\
790  					    k, klen, v, vlen);		\
791  				}					\
792  				CONF_CONTINUE;				\
793  			}
794        JEMALLOC_DIAGNOSTIC_PUSH
795        JEMALLOC_DIAGNOSTIC_IGNORE_TYPE_LIMITS
796  #define CONF_DONT_CHECK_MIN(um, min)	false
797  #define CONF_CHECK_MIN(um, min)	((um) &lt; (min))
798  #define CONF_DONT_CHECK_MAX(um, max)	false
799  #define CONF_CHECK_MAX(um, max)	((um) &gt; (max))
800  #define CONF_HANDLE_T_U(t, o, n, min, max, check_min, check_max, clip)	\
801  			if (CONF_MATCH(n)) {				\
802  				uintmax_t um;				\
803  				char *end;				\
804  									\
805  				set_errno(0);				\
806  				um = malloc_strtoumax(v, &amp;end, 0);	\
807  				if (get_errno() != 0 || (uintptr_t)end -\
808  				    (uintptr_t)v != vlen) {		\
809  					CONF_ERROR(&quot;Invalid conf value&quot;,\
810  					    k, klen, v, vlen);		\
811  				} else if (clip) {			\
812  					if (check_min(um, (t)(min))) {	\
813  						o = (t)(min);		\
814  					} else if (			\
815  					    check_max(um, (t)(max))) {	\
816  						o = (t)(max);		\
817  					} else {			\
818  						o = (t)um;		\
819  					}				\
820  				} else {				\
821  					if (check_min(um, (t)(min)) ||	\
822  					    check_max(um, (t)(max))) {	\
823  						CONF_ERROR(		\
824  						    &quot;Out-of-range &quot;	\
825  						    &quot;conf value&quot;,	\
826  						    k, klen, v, vlen);	\
827  					} else {			\
828  						o = (t)um;		\
829  					}				\
830  				}					\
831  				CONF_CONTINUE;				\
832  			}
833  #define CONF_HANDLE_UNSIGNED(o, n, min, max, check_min, check_max,	\
834      clip)								\
835  			CONF_HANDLE_T_U(unsigned, o, n, min, max,	\
836  			    check_min, check_max, clip)
837  #define CONF_HANDLE_SIZE_T(o, n, min, max, check_min, check_max, clip)	\
838  			CONF_HANDLE_T_U(size_t, o, n, min, max,		\
839  			    check_min, check_max, clip)
840  #define CONF_HANDLE_SSIZE_T(o, n, min, max)				\
841  			if (CONF_MATCH(n)) {				\
842  				long l;					\
843  				char *end;				\
844  									\
845  				set_errno(0);				\
846  				l = strtol(v, &amp;end, 0);			\
847  				if (get_errno() != 0 || (uintptr_t)end -\
848  				    (uintptr_t)v != vlen) {		\
849  					CONF_ERROR(&quot;Invalid conf value&quot;,\
850  					    k, klen, v, vlen);		\
851  				} else if (l &lt; (ssize_t)(min) || l &gt;	\
852  				    (ssize_t)(max)) {			\
853  					CONF_ERROR(			\
854  					    &quot;Out-of-range conf value&quot;,	\
855  					    k, klen, v, vlen);		\
856  				} else {				\
857  					o = l;				\
858  				}					\
859  				CONF_CONTINUE;				\
860  			}
861  #define CONF_HANDLE_CHAR_P(o, n, d)					\
862  			if (CONF_MATCH(n)) {				\
863  				size_t cpylen = (vlen &lt;=		\
864  				    sizeof(o)-1) ? vlen :		\
865  				    sizeof(o)-1;			\
866  				strncpy(o, v, cpylen);			\
867  				o[cpylen] = &#x27;\0&#x27;;			\
868  				CONF_CONTINUE;				\
869  			}
870  			bool cur_opt_valid = true;
871  			CONF_HANDLE_BOOL(opt_confirm_conf, &quot;confirm_conf&quot;)
872  			if (initial_call) {
873  				continue;
874  			}
875  			CONF_HANDLE_BOOL(opt_abort, &quot;abort&quot;)
876  			CONF_HANDLE_BOOL(opt_abort_conf, &quot;abort_conf&quot;)
877  			if (strncmp(&quot;metadata_thp&quot;, k, klen) == 0) {
878  				int i;
879  				bool match = false;
880  				for (i = 0; i &lt; metadata_thp_mode_limit; i++) {
881  					if (strncmp(metadata_thp_mode_names[i],
882  					    v, vlen) == 0) {
883  						opt_metadata_thp = i;
884  						match = true;
885  						break;
886  					}
887  				}
888  				if (!match) {
889  					CONF_ERROR(&quot;Invalid conf value&quot;,
890  					    k, klen, v, vlen);
891  				}
892  				CONF_CONTINUE;
893  			}
894  			CONF_HANDLE_BOOL(opt_retain, &quot;retain&quot;)
895  			if (strncmp(&quot;dss&quot;, k, klen) == 0) {
896  				int i;
897  				bool match = false;
898  				for (i = 0; i &lt; dss_prec_limit; i++) {
899  					if (strncmp(dss_prec_names[i], v, vlen)
900  					    == 0) {
901  						if (extent_dss_prec_set(i)) {
902  							CONF_ERROR(
903  							    &quot;Error setting dss&quot;,
904  							    k, klen, v, vlen);
905  						} else {
906  							opt_dss =
907  							    dss_prec_names[i];
908  							match = true;
909  							break;
910  						}
911  					}
912  				}
913  				if (!match) {
914  					CONF_ERROR(&quot;Invalid conf value&quot;,
915  					    k, klen, v, vlen);
916  				}
917  				CONF_CONTINUE;
918  			}
919  			CONF_HANDLE_UNSIGNED(opt_narenas, &quot;narenas&quot;, 1,
920  			    UINT_MAX, CONF_CHECK_MIN, CONF_DONT_CHECK_MAX,
921  			    false)
922  			if (CONF_MATCH(&quot;bin_shards&quot;)) {
923  				const char *bin_shards_segment_cur = v;
924  				size_t vlen_left = vlen;
925  				do {
926  					size_t size_start;
927  					size_t size_end;
928  					size_t nshards;
929  					bool err = malloc_conf_multi_sizes_next(
930  					    &amp;bin_shards_segment_cur, &amp;vlen_left,
931  					    &amp;size_start, &amp;size_end, &amp;nshards);
932  					if (err || bin_update_shard_size(
933  					    bin_shard_sizes, size_start,
934  					    size_end, nshards)) {
935  						CONF_ERROR(
936  						    &quot;Invalid settings for &quot;
937  						    &quot;bin_shards&quot;, k, klen, v,
938  						    vlen);
939  						break;
940  					}
941  				} while (vlen_left &gt; 0);
942  				CONF_CONTINUE;
943  			}
944  			CONF_HANDLE_SSIZE_T(opt_dirty_decay_ms,
945  			    &quot;dirty_decay_ms&quot;, -1, NSTIME_SEC_MAX * KQU(1000) &lt;
946  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
947  			    SSIZE_MAX);
948  			CONF_HANDLE_SSIZE_T(opt_muzzy_decay_ms,
949  			    &quot;muzzy_decay_ms&quot;, -1, NSTIME_SEC_MAX * KQU(1000) &lt;
950  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
951  			    SSIZE_MAX);
952  			CONF_HANDLE_BOOL(opt_stats_print, &quot;stats_print&quot;)
953  			if (CONF_MATCH(&quot;stats_print_opts&quot;)) {
954  				init_opt_stats_print_opts(v, vlen);
955  				CONF_CONTINUE;
956  			}
957  			if (config_fill) {
958  				if (CONF_MATCH(&quot;junk&quot;)) {
959  					if (CONF_MATCH_VALUE(&quot;true&quot;)) {
960  						opt_junk = &quot;true&quot;;
961  						opt_junk_alloc = opt_junk_free =
962  						    true;
963  					} else if (CONF_MATCH_VALUE(&quot;false&quot;)) {
964  						opt_junk = &quot;false&quot;;
965  						opt_junk_alloc = opt_junk_free =
966  						    false;
967  					} else if (CONF_MATCH_VALUE(&quot;alloc&quot;)) {
968  						opt_junk = &quot;alloc&quot;;
969  						opt_junk_alloc = true;
970  						opt_junk_free = false;
971  					} else if (CONF_MATCH_VALUE(&quot;free&quot;)) {
972  						opt_junk = &quot;free&quot;;
973  						opt_junk_alloc = false;
974  						opt_junk_free = true;
975  					} else {
976  						CONF_ERROR(
977  						    &quot;Invalid conf value&quot;,
978  						    k, klen, v, vlen);
979  					}
980  					CONF_CONTINUE;
981  				}
982  				CONF_HANDLE_BOOL(opt_zero, &quot;zero&quot;)
983  			}
984  			if (config_utrace) {
985  				CONF_HANDLE_BOOL(opt_utrace, &quot;utrace&quot;)
986  			}
987  			if (config_xmalloc) {
988  				CONF_HANDLE_BOOL(opt_xmalloc, &quot;xmalloc&quot;)
989  			}
990  			CONF_HANDLE_BOOL(opt_tcache, &quot;tcache&quot;)
991  			CONF_HANDLE_SSIZE_T(opt_lg_tcache_max, &quot;lg_tcache_max&quot;,
992  			    -1, (sizeof(size_t) &lt;&lt; 3) - 1)
993  			CONF_HANDLE_SIZE_T(opt_oversize_threshold,
994  			    &quot;oversize_threshold&quot;, 0, SC_LARGE_MAXCLASS,
995  			    CONF_DONT_CHECK_MIN, CONF_CHECK_MAX, false)
996  			CONF_HANDLE_SIZE_T(opt_lg_extent_max_active_fit,
997  			    &quot;lg_extent_max_active_fit&quot;, 0,
998  			    (sizeof(size_t) &lt;&lt; 3), CONF_DONT_CHECK_MIN,
999  			    CONF_CHECK_MAX, false)
1000  			if (strncmp(&quot;percpu_arena&quot;, k, klen) == 0) {
1001  				bool match = false;
1002  				for (int i = percpu_arena_mode_names_base; i &lt;
1003  				    percpu_arena_mode_names_limit; i++) {
1004  					if (strncmp(percpu_arena_mode_names[i],
1005  					    v, vlen) == 0) {
1006  						if (!have_percpu_arena) {
1007  							CONF_ERROR(
1008  							    &quot;No getcpu support&quot;,
1009  							    k, klen, v, vlen);
1010  						}
1011  						opt_percpu_arena = i;
1012  						match = true;
1013  						break;
1014  					}
1015  				}
1016  				if (!match) {
1017  					CONF_ERROR(&quot;Invalid conf value&quot;,
1018  					    k, klen, v, vlen);
1019  				}
1020  				CONF_CONTINUE;
1021  			}
1022  			CONF_HANDLE_BOOL(opt_background_thread,
1023  			    &quot;background_thread&quot;);
1024  			CONF_HANDLE_SIZE_T(opt_max_background_threads,
1025  					   &quot;max_background_threads&quot;, 1,
1026  					   opt_max_background_threads,
1027  					   CONF_CHECK_MIN, CONF_CHECK_MAX,
1028  					   true);
1029  			if (CONF_MATCH(&quot;slab_sizes&quot;)) {
1030  				bool err;
1031  				const char *slab_size_segment_cur = v;
1032  				size_t vlen_left = vlen;
1033  				do {
1034  					size_t slab_start;
1035  					size_t slab_end;
1036  					size_t pgs;
1037  					err = malloc_conf_multi_sizes_next(
1038  					    &amp;slab_size_segment_cur,
1039  					    &amp;vlen_left, &amp;slab_start, &amp;slab_end,
1040  					    &amp;pgs);
1041  					if (!err) {
1042  						sc_data_update_slab_size(
1043  						    sc_data, slab_start,
1044  						    slab_end, (int)pgs);
1045  					} else {
1046  						CONF_ERROR(&quot;Invalid settings &quot;
1047  						    &quot;for slab_sizes&quot;,
1048  						    k, klen, v, vlen);
1049  					}
1050  				} while (!err &amp;&amp; vlen_left &gt; 0);
1051  				CONF_CONTINUE;
1052  			}
1053  			if (config_prof) {
1054  				CONF_HANDLE_BOOL(opt_prof, &quot;prof&quot;)
1055  				CONF_HANDLE_CHAR_P(opt_prof_prefix,
1056  				    &quot;prof_prefix&quot;, &quot;jeprof&quot;)
1057  				CONF_HANDLE_BOOL(opt_prof_active, &quot;prof_active&quot;)
1058  				CONF_HANDLE_BOOL(opt_prof_thread_active_init,
1059  				    &quot;prof_thread_active_init&quot;)
1060  				CONF_HANDLE_SIZE_T(opt_lg_prof_sample,
1061  				    &quot;lg_prof_sample&quot;, 0, (sizeof(uint64_t) &lt;&lt; 3)
1062  				    - 1, CONF_DONT_CHECK_MIN, CONF_CHECK_MAX,
1063  				    true)
1064  				CONF_HANDLE_BOOL(opt_prof_accum, &quot;prof_accum&quot;)
1065  				CONF_HANDLE_SSIZE_T(opt_lg_prof_interval,
1066  				    &quot;lg_prof_interval&quot;, -1,
1067  				    (sizeof(uint64_t) &lt;&lt; 3) - 1)
1068  				CONF_HANDLE_BOOL(opt_prof_gdump, &quot;prof_gdump&quot;)
1069  				CONF_HANDLE_BOOL(opt_prof_final, &quot;prof_final&quot;)
1070  				CONF_HANDLE_BOOL(opt_prof_leak, &quot;prof_leak&quot;)
1071  				CONF_HANDLE_BOOL(opt_prof_log, &quot;prof_log&quot;)
1072  			}
1073  			if (config_log) {
1074  				if (CONF_MATCH(&quot;log&quot;)) {
1075  					size_t cpylen = (
1076  					    vlen &lt;= sizeof(log_var_names) ?
1077  					    vlen : sizeof(log_var_names) - 1);
1078  					strncpy(log_var_names, v, cpylen);
1079  					log_var_names[cpylen] = &#x27;\0&#x27;;
1080  					CONF_CONTINUE;
1081  				}
1082  			}
1083  			if (CONF_MATCH(&quot;thp&quot;)) {
1084  				bool match = false;
1085  				for (int i = 0; i &lt; thp_mode_names_limit; i++) {
1086  					if (strncmp(thp_mode_names[i],v, vlen)
1087  					    == 0) {
1088  						if (!have_madvise_huge) {
1089  							CONF_ERROR(
1090  							    &quot;No THP support&quot;,
1091  							    k, klen, v, vlen);
1092  						}
1093  						opt_thp = i;
1094  						match = true;
1095  						break;
1096  					}
1097  				}
1098  				if (!match) {
1099  					CONF_ERROR(&quot;Invalid conf value&quot;,
1100  					    k, klen, v, vlen);
1101  				}
1102  				CONF_CONTINUE;
1103  			}
1104  			CONF_ERROR(&quot;Invalid conf pair&quot;, k, klen, v, vlen);
1105  #undef CONF_ERROR
1106  #undef CONF_CONTINUE
1107  #undef CONF_MATCH
1108  #undef CONF_MATCH_VALUE
1109  #undef CONF_HANDLE_BOOL
1110  #undef CONF_DONT_CHECK_MIN
1111  #undef CONF_CHECK_MIN
1112  #undef CONF_DONT_CHECK_MAX
1113  #undef CONF_CHECK_MAX
1114  #undef CONF_HANDLE_T_U
1115  #undef CONF_HANDLE_UNSIGNED
1116  #undef CONF_HANDLE_SIZE_T
1117  #undef CONF_HANDLE_SSIZE_T
1118  #undef CONF_HANDLE_CHAR_P
1119      JEMALLOC_DIAGNOSTIC_POP
1120  		}
1121  		if (opt_abort_conf &amp;&amp; had_conf_error) {
1122  			malloc_abort_invalid_conf();
1123  		}
1124  	}
1125  	atomic_store_b(&amp;log_init_done, true, ATOMIC_RELEASE);
1126  }
1127  static void
1128  malloc_conf_init(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS]) {
1129  	const char *opts_cache[MALLOC_CONF_NSOURCES] = {NULL, NULL, NULL, NULL};
1130  	char buf[PATH_MAX + 1];
1131  	malloc_conf_init_helper(NULL, NULL, true, opts_cache, buf);
1132  	malloc_conf_init_helper(sc_data, bin_shard_sizes, false, opts_cache,
1133  	    NULL);
1134  }
1135  #undef MALLOC_CONF_NSOURCES
1136  static bool
1137  malloc_init_hard_needed(void) {
1138  	if (malloc_initialized() || (IS_INITIALIZER &amp;&amp; malloc_init_state ==
1139  	    malloc_init_recursible)) {
1140  		return false;
1141  	}
1142  #ifdef JEMALLOC_THREADED_INIT
1143  	if (malloc_initializer != NO_INITIALIZER &amp;&amp; !IS_INITIALIZER) {
1144  		spin_t spinner = SPIN_INITIALIZER;
1145  		do {
1146  			malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1147  			spin_adaptive(&amp;spinner);
1148  			malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1149  		} while (!malloc_initialized());
1150  		return false;
1151  	}
1152  #endif
1153  	return true;
1154  }
1155  static bool
1156  malloc_init_hard_a0_locked() {
1157  	malloc_initializer = INITIALIZER;
1158  	JEMALLOC_DIAGNOSTIC_PUSH
1159  	JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS
1160  	sc_data_t sc_data = {0};
1161  	JEMALLOC_DIAGNOSTIC_POP
1162  	sc_boot(&amp;sc_data);
1163  	unsigned bin_shard_sizes[SC_NBINS];
1164  	bin_shard_sizes_boot(bin_shard_sizes);
1165  	if (config_prof) {
1166  		prof_boot0();
1167  	}
1168  	malloc_conf_init(&amp;sc_data, bin_shard_sizes);
1169  	sz_boot(&amp;sc_data);
1170  	bin_boot(&amp;sc_data, bin_shard_sizes);
1171  	if (opt_stats_print) {
1172  		if (atexit(stats_print_atexit) != 0) {
1173  			malloc_write(&quot;&lt;jemalloc&gt;: Error in atexit()\n&quot;);
1174  			if (opt_abort) {
1175  				abort();
1176  			}
1177  		}
1178  	}
1179  	if (pages_boot()) {
1180  		return true;
1181  	}
1182  	if (base_boot(TSDN_NULL)) {
1183  		return true;
1184  	}
1185  	if (extent_boot()) {
1186  		return true;
1187  	}
1188  	if (ctl_boot()) {
1189  		return true;
1190  	}
1191  	if (config_prof) {
1192  		prof_boot1();
1193  	}
1194  	arena_boot(&amp;sc_data);
1195  	if (tcache_boot(TSDN_NULL)) {
1196  		return true;
1197  	}
1198  	if (malloc_mutex_init(&amp;arenas_lock, &quot;arenas&quot;, WITNESS_RANK_ARENAS,
1199  	    malloc_mutex_rank_exclusive)) {
1200  		return true;
1201  	}
1202  	hook_boot();
1203  	narenas_auto = 1;
1204  	manual_arena_base = narenas_auto + 1;
1205  	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
1206  	if (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&amp;extent_hooks_default)
1207  	    == NULL) {
1208  		return true;
1209  	}
1210  	a0 = arena_get(TSDN_NULL, 0, false);
1211  	malloc_init_state = malloc_init_a0_initialized;
1212  	return false;
1213  }
1214  static bool
1215  malloc_init_hard_a0(void) {
1216  	bool ret;
1217  	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1218  	ret = malloc_init_hard_a0_locked();
1219  	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1220  	return ret;
1221  }
1222  static bool
1223  malloc_init_hard_recursible(void) {
1224  	malloc_init_state = malloc_init_recursible;
1225  	ncpus = malloc_ncpus();
1226  #if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) &amp;&amp; !defined(JEMALLOC_MUTEX_INIT_CB) \
1227      &amp;&amp; !defined(JEMALLOC_ZONE) &amp;&amp; !defined(_WIN32) &amp;&amp; \
1228      !defined(__native_client__))
1229  	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
1230  	    jemalloc_postfork_child) != 0) {
1231  		malloc_write(&quot;&lt;jemalloc&gt;: Error in pthread_atfork()\n&quot;);
1232  		if (opt_abort) {
1233  			abort();
1234  		}
1235  		return true;
1236  	}
1237  #endif
1238  	if (background_thread_boot0()) {
1239  		return true;
1240  	}
1241  	return false;
1242  }
1243  static unsigned
1244  malloc_narenas_default(void) {
1245  	assert(ncpus &gt; 0);
1246  	if (ncpus &gt; 1) {
1247  		return ncpus &lt;&lt; 2;
1248  	} else {
1249  		return 1;
1250  	}
1251  }
1252  static percpu_arena_mode_t
1253  percpu_arena_as_initialized(percpu_arena_mode_t mode) {
1254  	assert(!malloc_initialized());
1255  	assert(mode &lt;= percpu_arena_disabled);
1256  	if (mode != percpu_arena_disabled) {
1257  		mode += percpu_arena_mode_enabled_base;
1258  	}
1259  	return mode;
1260  }
1261  static bool
1262  malloc_init_narenas(void) {
1263  	assert(ncpus &gt; 0);
1264  	if (opt_percpu_arena != percpu_arena_disabled) {
1265  		if (!have_percpu_arena || malloc_getcpu() &lt; 0) {
1266  			opt_percpu_arena = percpu_arena_disabled;
1267  			malloc_printf(&quot;&lt;jemalloc&gt;: perCPU arena getcpu() not &quot;
1268  			    &quot;available. Setting narenas to %u.\n&quot;, opt_narenas ?
1269  			    opt_narenas : malloc_narenas_default());
1270  			if (opt_abort) {
1271  				abort();
1272  			}
1273  		} else {
1274  			if (ncpus &gt;= MALLOCX_ARENA_LIMIT) {
1275  				malloc_printf(&quot;&lt;jemalloc&gt;: narenas w/ percpu&quot;
1276  				    &quot;arena beyond limit (%d)\n&quot;, ncpus);
1277  				if (opt_abort) {
1278  					abort();
1279  				}
1280  				return true;
1281  			}
1282  			if (percpu_arena_as_initialized(opt_percpu_arena) ==
1283  			    per_phycpu_arena &amp;&amp; ncpus % 2 != 0) {
1284  				malloc_printf(&quot;&lt;jemalloc&gt;: invalid &quot;
1285  				    &quot;configuration -- per physical CPU arena &quot;
1286  				    &quot;with odd number (%u) of CPUs (no hyper &quot;
1287  				    &quot;threading?).\n&quot;, ncpus);
1288  				if (opt_abort)
1289  					abort();
1290  			}
1291  			unsigned n = percpu_arena_ind_limit(
1292  			    percpu_arena_as_initialized(opt_percpu_arena));
1293  			if (opt_narenas &lt; n) {
1294  				opt_narenas = n;
1295  			}
1296  		}
1297  	}
1298  	if (opt_narenas == 0) {
1299  		opt_narenas = malloc_narenas_default();
1300  	}
1301  	assert(opt_narenas &gt; 0);
1302  	narenas_auto = opt_narenas;
1303  	if (narenas_auto &gt;= MALLOCX_ARENA_LIMIT) {
1304  		narenas_auto = MALLOCX_ARENA_LIMIT - 1;
1305  		malloc_printf(&quot;&lt;jemalloc&gt;: Reducing narenas to limit (%d)\n&quot;,
1306  		    narenas_auto);
1307  	}
1308  	narenas_total_set(narenas_auto);
1309  	if (arena_init_huge()) {
1310  		narenas_total_inc();
1311  	}
1312  	manual_arena_base = narenas_total_get();
1313  	return false;
1314  }
1315  static void
1316  malloc_init_percpu(void) {
1317  	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
1318  }
1319  static bool
1320  malloc_init_hard_finish(void) {
1321  	if (malloc_mutex_boot()) {
1322  		return true;
1323  	}
1324  	malloc_init_state = malloc_init_initialized;
1325  	malloc_slow_flag_init();
1326  	return false;
1327  }
1328  static void
1329  malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
1330  	malloc_mutex_assert_owner(tsdn, &amp;init_lock);
1331  	malloc_mutex_unlock(tsdn, &amp;init_lock);
1332  	if (reentrancy_set) {
1333  		assert(!tsdn_null(tsdn));
1334  		tsd_t *tsd = tsdn_tsd(tsdn);
1335  		assert(tsd_reentrancy_level_get(tsd) &gt; 0);
1336  		post_reentrancy(tsd);
1337  	}
1338  }
1339  static bool
1340  malloc_init_hard(void) {
1341  	tsd_t *tsd;
1342  #if defined(_WIN32) &amp;&amp; _WIN32_WINNT &lt; 0x0600
1343  	_init_init_lock();
1344  #endif
1345  	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1346  #define UNLOCK_RETURN(tsdn, ret, reentrancy)		\
1347  	malloc_init_hard_cleanup(tsdn, reentrancy);	\
1348  	return ret;
1349  	if (!malloc_init_hard_needed()) {
1350  		UNLOCK_RETURN(TSDN_NULL, false, false)
1351  	}
1352  	if (malloc_init_state != malloc_init_a0_initialized &amp;&amp;
1353  	    malloc_init_hard_a0_locked()) {
1354  		UNLOCK_RETURN(TSDN_NULL, true, false)
1355  	}
1356  	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1357  	tsd = malloc_tsd_boot0();
1358  	if (tsd == NULL) {
1359  		return true;
1360  	}
1361  	if (malloc_init_hard_recursible()) {
1362  		return true;
1363  	}
1364  	malloc_mutex_lock(tsd_tsdn(tsd), &amp;init_lock);
1365  	pre_reentrancy(tsd, NULL);
1366  	if (malloc_init_narenas() || background_thread_boot1(tsd_tsdn(tsd))) {
1367  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1368  	}
1369  	if (config_prof &amp;&amp; prof_boot2(tsd)) {
1370  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1371  	}
1372  	malloc_init_percpu();
1373  	if (malloc_init_hard_finish()) {
1374  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1375  	}
1376  	post_reentrancy(tsd);
1377  	malloc_mutex_unlock(tsd_tsdn(tsd), &amp;init_lock);
1378  	witness_assert_lockless(witness_tsd_tsdn(
1379  	    tsd_witness_tsdp_get_unsafe(tsd)));
1380  	malloc_tsd_boot1();
1381  	tsd = tsd_fetch();
1382  	if (opt_background_thread) {
1383  		assert(have_background_thread);
1384  		background_thread_ctl_init(tsd_tsdn(tsd));
1385  		if (background_thread_create(tsd, 0)) {
1386  			return true;
1387  		}
1388  	}
1389  #undef UNLOCK_RETURN
1390  	return false;
1391  }
1392  typedef struct static_opts_s static_opts_t;
1393  struct static_opts_s {
1394  	bool may_overflow;
1395  	bool bump_empty_aligned_alloc;
1396  	bool assert_nonempty_alloc;
1397  	bool null_out_result_on_error;
1398  	bool set_errno_on_error;
1399  	size_t min_alignment;
1400  	const char *oom_string;
1401  	const char *invalid_alignment_string;
1402  	bool slow;
1403  	bool usize;
1404  };
1405  JEMALLOC_ALWAYS_INLINE void
1406  static_opts_init(static_opts_t *static_opts) {
1407  	static_opts-&gt;may_overflow = false;
1408  	static_opts-&gt;bump_empty_aligned_alloc = false;
1409  	static_opts-&gt;assert_nonempty_alloc = false;
1410  	static_opts-&gt;null_out_result_on_error = false;
1411  	static_opts-&gt;set_errno_on_error = false;
1412  	static_opts-&gt;min_alignment = 0;
1413  	static_opts-&gt;oom_string = &quot;&quot;;
1414  	static_opts-&gt;invalid_alignment_string = &quot;&quot;;
1415  	static_opts-&gt;slow = false;
1416  	static_opts-&gt;usize = false;
1417  }
1418  #define TCACHE_IND_NONE ((unsigned)-1)
1419  #define TCACHE_IND_AUTOMATIC ((unsigned)-2)
1420  #define ARENA_IND_AUTOMATIC ((unsigned)-1)
1421  typedef struct dynamic_opts_s dynamic_opts_t;
1422  struct dynamic_opts_s {
1423  	void **result;
1424  	size_t usize;
1425  	size_t num_items;
1426  	size_t item_size;
1427  	size_t alignment;
1428  	bool zero;
1429  	unsigned tcache_ind;
1430  	unsigned arena_ind;
1431  };
1432  JEMALLOC_ALWAYS_INLINE void
1433  dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
1434  	dynamic_opts-&gt;result = NULL;
1435  	dynamic_opts-&gt;usize = 0;
1436  	dynamic_opts-&gt;num_items = 0;
1437  	dynamic_opts-&gt;item_size = 0;
1438  	dynamic_opts-&gt;alignment = 0;
1439  	dynamic_opts-&gt;zero = false;
1440  	dynamic_opts-&gt;tcache_ind = TCACHE_IND_AUTOMATIC;
1441  	dynamic_opts-&gt;arena_ind = ARENA_IND_AUTOMATIC;
1442  }
1443  JEMALLOC_ALWAYS_INLINE void *
1444  imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1445      size_t size, size_t usize, szind_t ind) {
1446  	tcache_t *tcache;
1447  	arena_t *arena;
1448  	if (dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC) {
1449  		if (likely(!sopts-&gt;slow)) {
1450  			tcache = tsd_tcachep_get(tsd);
1451  			assert(tcache == tcache_get(tsd));
1452  		} else {
1453  			tcache = tcache_get(tsd);
1454  		}
1455  	} else if (dopts-&gt;tcache_ind == TCACHE_IND_NONE) {
1456  		tcache = NULL;
1457  	} else {
1458  		tcache = tcaches_get(tsd, dopts-&gt;tcache_ind);
1459  	}
1460  	if (dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC) {
1461  		arena = NULL;
1462  	} else {
1463  		arena = arena_get(tsd_tsdn(tsd), dopts-&gt;arena_ind, true);
1464  	}
1465  	if (unlikely(dopts-&gt;alignment != 0)) {
1466  		return ipalloct(tsd_tsdn(tsd), usize, dopts-&gt;alignment,
1467  		    dopts-&gt;zero, tcache, arena);
1468  	}
1469  	return iallocztm(tsd_tsdn(tsd), size, ind, dopts-&gt;zero, tcache, false,
1470  	    arena, sopts-&gt;slow);
1471  }
1472  JEMALLOC_ALWAYS_INLINE void *
1473  imalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1474      size_t usize, szind_t ind) {
1475  	void *ret;
1476  	szind_t ind_large;
1477  	size_t bumped_usize = usize;
1478  	if (usize &lt;= SC_SMALL_MAXCLASS) {
1479  		assert(((dopts-&gt;alignment == 0) ?
1480  		    sz_s2u(SC_LARGE_MINCLASS) :
1481  		    sz_sa2u(SC_LARGE_MINCLASS, dopts-&gt;alignment))
1482  			== SC_LARGE_MINCLASS);
1483  		ind_large = sz_size2index(SC_LARGE_MINCLASS);
1484  		bumped_usize = sz_s2u(SC_LARGE_MINCLASS);
1485  		ret = imalloc_no_sample(sopts, dopts, tsd, bumped_usize,
1486  		    bumped_usize, ind_large);
1487  		if (unlikely(ret == NULL)) {
1488  			return NULL;
1489  		}
1490  		arena_prof_promote(tsd_tsdn(tsd), ret, usize);
1491  	} else {
1492  		ret = imalloc_no_sample(sopts, dopts, tsd, usize, usize, ind);
1493  	}
1494  	return ret;
1495  }
1496  JEMALLOC_ALWAYS_INLINE bool
1497  compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
1498      size_t *size) {
1499  	if (!may_overflow) {
1500  		assert(dopts-&gt;num_items == 1);
1501  		*size = dopts-&gt;item_size;
1502  		return false;
1503  	}
1504  	static const size_t high_bits = SIZE_T_MAX &lt;&lt; (sizeof(size_t) * 8 / 2);
1505  	*size = dopts-&gt;item_size * dopts-&gt;num_items;
1506  	if (unlikely(*size == 0)) {
1507  		return (dopts-&gt;num_items != 0 &amp;&amp; dopts-&gt;item_size != 0);
1508  	}
1509  	if (likely((high_bits &amp; (dopts-&gt;num_items | dopts-&gt;item_size)) == 0)) {
1510  		return false;
1511  	}
1512  	if (likely(*size / dopts-&gt;item_size == dopts-&gt;num_items)) {
1513  		return false;
1514  	}
1515  	return true;
1516  }
1517  JEMALLOC_ALWAYS_INLINE int
1518  imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
1519  	void *allocation = NULL;
1520  	size_t size = 0;
1521  	szind_t ind = 0;
1522  	size_t usize = 0;
1523  	int8_t reentrancy_level;
1524  	if (unlikely(compute_size_with_overflow(sopts-&gt;may_overflow, dopts,
1525  	    &amp;size))) {
1526  		goto label_oom;
1527  	}
1528  	if (unlikely(dopts-&gt;alignment &lt; sopts-&gt;min_alignment
1529  	    || (dopts-&gt;alignment &amp; (dopts-&gt;alignment - 1)) != 0)) {
1530  		goto label_invalid_alignment;
1531  	}
1532  	if (dopts-&gt;alignment == 0) {
1533  		ind = sz_size2index(size);
1534  		if (unlikely(ind &gt;= SC_NSIZES)) {
1535  			goto label_oom;
1536  		}
1537  		if (config_stats || (config_prof &amp;&amp; opt_prof) || sopts-&gt;usize) {
1538  			usize = sz_index2size(ind);
1539  			dopts-&gt;usize = usize;
1540  			assert(usize &gt; 0 &amp;&amp; usize
1541  			    &lt;= SC_LARGE_MAXCLASS);
1542  		}
1543  	} else {
1544  		if (sopts-&gt;bump_empty_aligned_alloc) {
1545  			if (unlikely(size == 0)) {
1546  				size = 1;
1547  			}
1548  		}
1549  		usize = sz_sa2u(size, dopts-&gt;alignment);
1550  		dopts-&gt;usize = usize;
1551  		if (unlikely(usize == 0
1552  		    || usize &gt; SC_LARGE_MAXCLASS)) {
1553  			goto label_oom;
1554  		}
1555  	}
1556  	if (sopts-&gt;assert_nonempty_alloc) {
1557  		assert (size != 0);
1558  	}
1559  	check_entry_exit_locking(tsd_tsdn(tsd));
1560  	reentrancy_level = tsd_reentrancy_level_get(tsd);
1561  	if (sopts-&gt;slow &amp;&amp; unlikely(reentrancy_level &gt; 0)) {
1562  		assert(dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC ||
1563  		    dopts-&gt;tcache_ind == TCACHE_IND_NONE);
1564  		assert(dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC);
1565  		dopts-&gt;tcache_ind = TCACHE_IND_NONE;
1566  		dopts-&gt;arena_ind = 0;
1567  	}
1568  	if (config_prof &amp;&amp; opt_prof) {
1569  		prof_tctx_t *tctx = prof_alloc_prep(
1570  		    tsd, usize, prof_active_get_unlocked(), true);
1571  		alloc_ctx_t alloc_ctx;
1572  		if (likely((uintptr_t)tctx == (uintptr_t)1U)) {
1573  			alloc_ctx.slab = (usize
1574  			    &lt;= SC_SMALL_MAXCLASS);
1575  			allocation = imalloc_no_sample(
1576  			    sopts, dopts, tsd, usize, usize, ind);
1577  		} else if ((uintptr_t)tctx &gt; (uintptr_t)1U) {
1578  			allocation = imalloc_sample(
1579  			    sopts, dopts, tsd, usize, ind);
1580  			alloc_ctx.slab = false;
1581  		} else {
1582  			allocation = NULL;
1583  		}
1584  		if (unlikely(allocation == NULL)) {
1585  			prof_alloc_rollback(tsd, tctx, true);
1586  			goto label_oom;
1587  		}
1588  		prof_malloc(tsd_tsdn(tsd), allocation, usize, &amp;alloc_ctx, tctx);
1589  	} else {
1590  		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,
1591  		    ind);
1592  		if (unlikely(allocation == NULL)) {
1593  			goto label_oom;
1594  		}
1595  	}
1596  	assert(dopts-&gt;alignment == 0
1597  	    || ((uintptr_t)allocation &amp; (dopts-&gt;alignment - 1)) == ZU(0));
1598  	if (config_stats) {
1599  		assert(usize == isalloc(tsd_tsdn(tsd), allocation));
1600  		*tsd_thread_allocatedp_get(tsd) += usize;
1601  	}
1602  	if (sopts-&gt;slow) {
1603  		UTRACE(0, size, allocation);
1604  	}
1605  	check_entry_exit_locking(tsd_tsdn(tsd));
1606  	*dopts-&gt;result = allocation;
1607  	return 0;
1608  label_oom:
1609  	if (unlikely(sopts-&gt;slow) &amp;&amp; config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1610  		malloc_write(sopts-&gt;oom_string);
1611  		abort();
1612  	}
1613  	if (sopts-&gt;slow) {
1614  		UTRACE(NULL, size, NULL);
1615  	}
1616  	check_entry_exit_locking(tsd_tsdn(tsd));
1617  	if (sopts-&gt;set_errno_on_error) {
1618  		set_errno(ENOMEM);
1619  	}
1620  	if (sopts-&gt;null_out_result_on_error) {
1621  		*dopts-&gt;result = NULL;
1622  	}
1623  	return ENOMEM;
1624  label_invalid_alignment:
1625  	if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1626  		malloc_write(sopts-&gt;invalid_alignment_string);
1627  		abort();
1628  	}
1629  	if (sopts-&gt;set_errno_on_error) {
1630  		set_errno(EINVAL);
1631  	}
1632  	if (sopts-&gt;slow) {
1633  		UTRACE(NULL, size, NULL);
1634  	}
1635  	check_entry_exit_locking(tsd_tsdn(tsd));
1636  	if (sopts-&gt;null_out_result_on_error) {
1637  		*dopts-&gt;result = NULL;
1638  	}
1639  	return EINVAL;
1640  }
1641  JEMALLOC_ALWAYS_INLINE bool
1642  imalloc_init_check(static_opts_t *sopts, dynamic_opts_t *dopts) {
1643  	if (unlikely(!malloc_initialized()) &amp;&amp; unlikely(malloc_init())) {
1644  		if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1645  			malloc_write(sopts-&gt;oom_string);
1646  			abort();
1647  		}
1648  		UTRACE(NULL, dopts-&gt;num_items * dopts-&gt;item_size, NULL);
1649  		set_errno(ENOMEM);
1650  		*dopts-&gt;result = NULL;
1651  		return false;
1652  	}
1653  	return true;
1654  }
1655  JEMALLOC_ALWAYS_INLINE int
1656  imalloc(static_opts_t *sopts, dynamic_opts_t *dopts) {
1657  	if (tsd_get_allocates() &amp;&amp; !imalloc_init_check(sopts, dopts)) {
1658  		return ENOMEM;
1659  	}
1660  	tsd_t *tsd = tsd_fetch();
1661  	assert(tsd);
1662  	if (likely(tsd_fast(tsd))) {
1663  		tsd_assert_fast(tsd);
1664  		sopts-&gt;slow = false;
1665  		return imalloc_body(sopts, dopts, tsd);
1666  	} else {
1667  		if (!tsd_get_allocates() &amp;&amp; !imalloc_init_check(sopts, dopts)) {
1668  			return ENOMEM;
1669  		}
1670  		sopts-&gt;slow = true;
1671  		return imalloc_body(sopts, dopts, tsd);
1672  	}
1673  }
1674  JEMALLOC_NOINLINE
1675  void *
1676  malloc_default(size_t size) {
1677  	void *ret;
1678  	static_opts_t sopts;
1679  	dynamic_opts_t dopts;
1680  	LOG(&quot;core.malloc.entry&quot;, &quot;size: %zu&quot;, size);
1681  	static_opts_init(&amp;sopts);
1682  	dynamic_opts_init(&amp;dopts);
1683  	sopts.null_out_result_on_error = true;
1684  	sopts.set_errno_on_error = true;
1685  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in malloc(): out of memory\n&quot;;
1686  	dopts.result = &amp;ret;
1687  	dopts.num_items = 1;
1688  	dopts.item_size = size;
1689  	imalloc(&amp;sopts, &amp;dopts);
1690  	if (sopts.slow) {
1691  		uintptr_t args[3] = {size};
1692  		hook_invoke_alloc(hook_alloc_malloc, ret, (uintptr_t)ret, args);
1693  	}
1694  	LOG(&quot;core.malloc.exit&quot;, &quot;result: %p&quot;, ret);
1695  	return ret;
1696  }
1697  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1698  void JEMALLOC_NOTHROW *
1699  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
1700  je_malloc(size_t size) {
1701  	LOG(&quot;core.malloc.entry&quot;, &quot;size: %zu&quot;, size);
1702  	if (tsd_get_allocates() &amp;&amp; unlikely(!malloc_initialized())) {
1703  		return malloc_default(size);
1704  	}
1705  	tsd_t *tsd = tsd_get(false);
1706  	if (unlikely(!tsd || !tsd_fast(tsd) || (size &gt; SC_LOOKUP_MAXCLASS))) {
1707  		return malloc_default(size);
1708  	}
1709  	tcache_t *tcache = tsd_tcachep_get(tsd);
1710  	if (unlikely(ticker_trytick(&amp;tcache-&gt;gc_ticker))) {
1711  		return malloc_default(size);
1712  	}
1713  	szind_t ind = sz_size2index_lookup(size);
1714  	size_t usize;
1715  	if (config_stats || config_prof) {
1716  		usize = sz_index2size(ind);
1717  	}
1718  	assert(ind &lt; SC_NBINS);
1719  	assert(size &lt;= SC_SMALL_MAXCLASS);
1720  	if (config_prof) {
1721  		int64_t bytes_until_sample = tsd_bytes_until_sample_get(tsd);
1722  		bytes_until_sample -= usize;
1723  		tsd_bytes_until_sample_set(tsd, bytes_until_sample);
1724  		if (unlikely(bytes_until_sample &lt; 0)) {
1725  			if (!prof_active) {
1726  				tsd_bytes_until_sample_set(tsd, SSIZE_MAX);
1727  			}
1728  			return malloc_default(size);
1729  		}
1730  	}
1731  	cache_bin_t *bin = tcache_small_bin_get(tcache, ind);
1732  	bool tcache_success;
1733  	void* ret = cache_bin_alloc_easy(bin, &amp;tcache_success);
1734  	if (tcache_success) {
1735  		if (config_stats) {
1736  			*tsd_thread_allocatedp_get(tsd) += usize;
1737  			bin-&gt;tstats.nrequests++;
1738  		}
1739  		if (config_prof) {
1740  			tcache-&gt;prof_accumbytes += usize;
1741  		}
1742  		LOG(&quot;core.malloc.exit&quot;, &quot;result: %p&quot;, ret);
1743  		return ret;
1744  	}
1745  	return malloc_default(size);
1746  }
1747  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
1748  JEMALLOC_ATTR(nonnull(1))
1749  je_posix_memalign(void **memptr, size_t alignment, size_t size) {
1750  	int ret;
1751  	static_opts_t sopts;
1752  	dynamic_opts_t dopts;
1753  	LOG(&quot;core.posix_memalign.entry&quot;, &quot;mem ptr: %p, alignment: %zu, &quot;
1754  	    &quot;size: %zu&quot;, memptr, alignment, size);
1755  	static_opts_init(&amp;sopts);
1756  	dynamic_opts_init(&amp;dopts);
1757  	sopts.bump_empty_aligned_alloc = true;
1758  	sopts.min_alignment = sizeof(void *);
1759  	sopts.oom_string =
1760  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
1761  	sopts.invalid_alignment_string =
1762  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
1763  	dopts.result = memptr;
1764  	dopts.num_items = 1;
1765  	dopts.item_size = size;
1766  	dopts.alignment = alignment;
1767  	ret = imalloc(&amp;sopts, &amp;dopts);
1768  	if (sopts.slow) {
1769  		uintptr_t args[3] = {(uintptr_t)memptr, (uintptr_t)alignment,
1770  			(uintptr_t)size};
1771  		hook_invoke_alloc(hook_alloc_posix_memalign, *memptr,
1772  		    (uintptr_t)ret, args);
1773  	}
1774  	LOG(&quot;core.posix_memalign.exit&quot;, &quot;result: %d, alloc ptr: %p&quot;, ret,
1775  	    *memptr);
1776  	return ret;
1777  }
1778  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1779  void JEMALLOC_NOTHROW *
1780  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)
1781  je_aligned_alloc(size_t alignment, size_t size) {
1782  	void *ret;
1783  	static_opts_t sopts;
1784  	dynamic_opts_t dopts;
1785  	LOG(&quot;core.aligned_alloc.entry&quot;, &quot;alignment: %zu, size: %zu\n&quot;,
1786  	    alignment, size);
1787  	static_opts_init(&amp;sopts);
1788  	dynamic_opts_init(&amp;dopts);
1789  	sopts.bump_empty_aligned_alloc = true;
1790  	sopts.null_out_result_on_error = true;
1791  	sopts.set_errno_on_error = true;
1792  	sopts.min_alignment = 1;
1793  	sopts.oom_string =
1794  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
1795  	sopts.invalid_alignment_string =
1796  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
1797  	dopts.result = &amp;ret;
1798  	dopts.num_items = 1;
1799  	dopts.item_size = size;
1800  	dopts.alignment = alignment;
1801  	imalloc(&amp;sopts, &amp;dopts);
1802  	if (sopts.slow) {
1803  		uintptr_t args[3] = {(uintptr_t)alignment, (uintptr_t)size};
1804  		hook_invoke_alloc(hook_alloc_aligned_alloc, ret,
1805  		    (uintptr_t)ret, args);
1806  	}
1807  	LOG(&quot;core.aligned_alloc.exit&quot;, &quot;result: %p&quot;, ret);
1808  	return ret;
1809  }
1810  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1811  void JEMALLOC_NOTHROW *
1812  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)
1813  je_calloc(size_t num, size_t size) {
1814  	void *ret;
1815  	static_opts_t sopts;
1816  	dynamic_opts_t dopts;
1817  	LOG(&quot;core.calloc.entry&quot;, &quot;num: %zu, size: %zu\n&quot;, num, size);
1818  	static_opts_init(&amp;sopts);
1819  	dynamic_opts_init(&amp;dopts);
1820  	sopts.may_overflow = true;
1821  	sopts.null_out_result_on_error = true;
1822  	sopts.set_errno_on_error = true;
1823  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in calloc(): out of memory\n&quot;;
1824  	dopts.result = &amp;ret;
1825  	dopts.num_items = num;
1826  	dopts.item_size = size;
1827  	dopts.zero = true;
1828  	imalloc(&amp;sopts, &amp;dopts);
1829  	if (sopts.slow) {
1830  		uintptr_t args[3] = {(uintptr_t)num, (uintptr_t)size};
1831  		hook_invoke_alloc(hook_alloc_calloc, ret, (uintptr_t)ret, args);
1832  	}
1833  	LOG(&quot;core.calloc.exit&quot;, &quot;result: %p&quot;, ret);
1834  	return ret;
1835  }
1836  static void *
1837  irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1838      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
1839  	void *p;
1840  	if (tctx == NULL) {
1841  		return NULL;
1842  	}
1843  	if (usize &lt;= SC_SMALL_MAXCLASS) {
1844  		p = iralloc(tsd, old_ptr, old_usize,
1845  		    SC_LARGE_MINCLASS, 0, false, hook_args);
1846  		if (p == NULL) {
1847  			return NULL;
1848  		}
1849  		arena_prof_promote(tsd_tsdn(tsd), p, usize);
1850  	} else {
1851  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1852  		    hook_args);
1853  	}
1854  	return p;
1855  }
1856  JEMALLOC_ALWAYS_INLINE void *
1857  irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1858     alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
1859  	void *p;
1860  	bool prof_active;
1861  	prof_tctx_t *old_tctx, *tctx;
1862  	prof_active = prof_active_get_unlocked();
1863  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
1864  	tctx = prof_alloc_prep(tsd, usize, prof_active, true);
1865  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
1866  		p = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx,
1867  		    hook_args);
1868  	} else {
1869  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1870  		    hook_args);
1871  	}
1872  	if (unlikely(p == NULL)) {
1873  		prof_alloc_rollback(tsd, tctx, true);
1874  		return NULL;
1875  	}
1876  	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
1877  	    old_tctx);
1878  	return p;
1879  }
1880  JEMALLOC_ALWAYS_INLINE void
1881  ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
1882  	if (!slow_path) {
1883  		tsd_assert_fast(tsd);
1884  	}
1885  	check_entry_exit_locking(tsd_tsdn(tsd));
1886  	if (tsd_reentrancy_level_get(tsd) != 0) {
1887  		assert(slow_path);
1888  	}
1889  	assert(ptr != NULL);
1890  	assert(malloc_initialized() || IS_INITIALIZER);
1891  	alloc_ctx_t alloc_ctx;
1892  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1893  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1894  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1895  	assert(alloc_ctx.szind != SC_NSIZES);
1896  	size_t usize;
1897  	if (config_prof &amp;&amp; opt_prof) {
1898  		usize = sz_index2size(alloc_ctx.szind);
1899  		prof_free(tsd, ptr, usize, &amp;alloc_ctx);
1900  	} else if (config_stats) {
1901  		usize = sz_index2size(alloc_ctx.szind);
1902  	}
1903  	if (config_stats) {
1904  		*tsd_thread_deallocatedp_get(tsd) += usize;
1905  	}
1906  	if (likely(!slow_path)) {
1907  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, false,
1908  		    false);
1909  	} else {
1910  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, false,
1911  		    true);
1912  	}
1913  }
1914  JEMALLOC_ALWAYS_INLINE void
1915  isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
1916  	if (!slow_path) {
1917  		tsd_assert_fast(tsd);
1918  	}
1919  	check_entry_exit_locking(tsd_tsdn(tsd));
1920  	if (tsd_reentrancy_level_get(tsd) != 0) {
1921  		assert(slow_path);
1922  	}
1923  	assert(ptr != NULL);
1924  	assert(malloc_initialized() || IS_INITIALIZER);
1925  	alloc_ctx_t alloc_ctx, *ctx;
1926  	if (!config_cache_oblivious &amp;&amp; ((uintptr_t)ptr &amp; PAGE_MASK) != 0) {
1927  		alloc_ctx.szind = sz_size2index(usize);
1928  		alloc_ctx.slab = true;
1929  		ctx = &amp;alloc_ctx;
1930  		if (config_debug) {
1931  			alloc_ctx_t dbg_ctx;
1932  			rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1933  			rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree,
1934  			    rtree_ctx, (uintptr_t)ptr, true, &amp;dbg_ctx.szind,
1935  			    &amp;dbg_ctx.slab);
1936  			assert(dbg_ctx.szind == alloc_ctx.szind);
1937  			assert(dbg_ctx.slab == alloc_ctx.slab);
1938  		}
1939  	} else if (config_prof &amp;&amp; opt_prof) {
1940  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1941  		rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1942  		    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1943  		assert(alloc_ctx.szind == sz_size2index(usize));
1944  		ctx = &amp;alloc_ctx;
1945  	} else {
1946  		ctx = NULL;
1947  	}
1948  	if (config_prof &amp;&amp; opt_prof) {
1949  		prof_free(tsd, ptr, usize, ctx);
1950  	}
1951  	if (config_stats) {
1952  		*tsd_thread_deallocatedp_get(tsd) += usize;
1953  	}
1954  	if (likely(!slow_path)) {
1955  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, false);
1956  	} else {
1957  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);
1958  	}
1959  }
1960  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1961  void JEMALLOC_NOTHROW *
1962  JEMALLOC_ALLOC_SIZE(2)
1963  je_realloc(void *ptr, size_t arg_size) {
1964  	void *ret;
1965  	tsdn_t *tsdn JEMALLOC_CC_SILENCE_INIT(NULL);
1966  	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
1967  	size_t old_usize = 0;
1968  	size_t size = arg_size;
1969  	LOG(&quot;core.realloc.entry&quot;, &quot;ptr: %p, size: %zu\n&quot;, ptr, size);
1970  	if (unlikely(size == 0)) {
1971  		if (ptr != NULL) {
1972  			UTRACE(ptr, 0, 0);
1973  			tcache_t *tcache;
1974  			tsd_t *tsd = tsd_fetch();
1975  			if (tsd_reentrancy_level_get(tsd) == 0) {
1976  				tcache = tcache_get(tsd);
1977  			} else {
1978  				tcache = NULL;
1979  			}
1980  			uintptr_t args[3] = {(uintptr_t)ptr, size};
1981  			hook_invoke_dalloc(hook_dalloc_realloc, ptr, args);
1982  			ifree(tsd, ptr, tcache, true);
1983  			LOG(&quot;core.realloc.exit&quot;, &quot;result: %p&quot;, NULL);
1984  			return NULL;
1985  		}
1986  		size = 1;
1987  	}
1988  	if (likely(ptr != NULL)) {
1989  		assert(malloc_initialized() || IS_INITIALIZER);
1990  		tsd_t *tsd = tsd_fetch();
1991  		check_entry_exit_locking(tsd_tsdn(tsd));
1992  		hook_ralloc_args_t hook_args = {true, {(uintptr_t)ptr,
1993  			(uintptr_t)arg_size, 0, 0}};
1994  		alloc_ctx_t alloc_ctx;
1995  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1996  		rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1997  		    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1998  		assert(alloc_ctx.szind != SC_NSIZES);
1999  		old_usize = sz_index2size(alloc_ctx.szind);
2000  		assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2001  		if (config_prof &amp;&amp; opt_prof) {
2002  			usize = sz_s2u(size);
2003  			if (unlikely(usize == 0
2004  			    || usize &gt; SC_LARGE_MAXCLASS)) {
2005  				ret = NULL;
2006  			} else {
2007  				ret = irealloc_prof(tsd, ptr, old_usize, usize,
2008  				    &amp;alloc_ctx, &amp;hook_args);
2009  			}
2010  		} else {
2011  			if (config_stats) {
2012  				usize = sz_s2u(size);
2013  			}
2014  			ret = iralloc(tsd, ptr, old_usize, size, 0, false,
2015  			    &amp;hook_args);
2016  		}
2017  		tsdn = tsd_tsdn(tsd);
2018  	} else {
2019  		static_opts_t sopts;
2020  		dynamic_opts_t dopts;
2021  		static_opts_init(&amp;sopts);
2022  		dynamic_opts_init(&amp;dopts);
2023  		sopts.null_out_result_on_error = true;
2024  		sopts.set_errno_on_error = true;
2025  		sopts.oom_string =
2026  		    &quot;&lt;jemalloc&gt;: Error in realloc(): out of memory\n&quot;;
2027  		dopts.result = &amp;ret;
2028  		dopts.num_items = 1;
2029  		dopts.item_size = size;
2030  		imalloc(&amp;sopts, &amp;dopts);
2031  		if (sopts.slow) {
2032  			uintptr_t args[3] = {(uintptr_t)ptr, arg_size};
2033  			hook_invoke_alloc(hook_alloc_realloc, ret,
2034  			    (uintptr_t)ret, args);
2035  		}
2036  		return ret;
2037  	}
2038  	if (unlikely(ret == NULL)) {
2039  		if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
2040  			malloc_write(&quot;&lt;jemalloc&gt;: Error in realloc(): &quot;
2041  			    &quot;out of memory\n&quot;);
2042  			abort();
2043  		}
2044  		set_errno(ENOMEM);
2045  	}
2046  	if (config_stats &amp;&amp; likely(ret != NULL)) {
2047  		tsd_t *tsd;
2048  		assert(usize == isalloc(tsdn, ret));
2049  		tsd = tsdn_tsd(tsdn);
2050  		*tsd_thread_allocatedp_get(tsd) += usize;
2051  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2052  	}
2053  	UTRACE(ptr, size, ret);
2054  	check_entry_exit_locking(tsdn);
2055  	LOG(&quot;core.realloc.exit&quot;, &quot;result: %p&quot;, ret);
2056  	return ret;
2057  }
2058  JEMALLOC_NOINLINE
2059  void
2060  free_default(void *ptr) {
2061  	UTRACE(ptr, 0, 0);
2062  	if (likely(ptr != NULL)) {
2063  		tsd_t *tsd = tsd_fetch_min();
2064  		check_entry_exit_locking(tsd_tsdn(tsd));
2065  		tcache_t *tcache;
2066  		if (likely(tsd_fast(tsd))) {
2067  			tsd_assert_fast(tsd);
2068  			tcache = tsd_tcachep_get(tsd);
2069  			ifree(tsd, ptr, tcache, false);
2070  		} else {
2071  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2072  				tcache = tcache_get(tsd);
2073  			} else {
2074  				tcache = NULL;
2075  			}
2076  			uintptr_t args_raw[3] = {(uintptr_t)ptr};
2077  			hook_invoke_dalloc(hook_dalloc_free, ptr, args_raw);
2078  			ifree(tsd, ptr, tcache, true);
2079  		}
2080  		check_entry_exit_locking(tsd_tsdn(tsd));
2081  	}
2082  }
2083  JEMALLOC_ALWAYS_INLINE
2084  bool free_fastpath(void *ptr, size_t size, bool size_hint) {
2085  	tsd_t *tsd = tsd_get(false);
2086  	if (unlikely(!tsd || !tsd_fast(tsd))) {
2087  		return false;
2088  	}
2089  	tcache_t *tcache = tsd_tcachep_get(tsd);
2090  	alloc_ctx_t alloc_ctx;
2091  	if (!size_hint || config_cache_oblivious) {
2092  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2093  		bool res = rtree_szind_slab_read_fast(tsd_tsdn(tsd), &amp;extents_rtree,
2094  						      rtree_ctx, (uintptr_t)ptr,
2095  						      &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2096  		if (!res || !alloc_ctx.slab) {
2097  			return false;
2098  		}
2099  		assert(alloc_ctx.szind != SC_NSIZES);
2100  	} else {
2101  		if (size &gt; SC_LOOKUP_MAXCLASS || (((uintptr_t)ptr &amp; PAGE_MASK) == 0)) {
2102  			return false;
2103  		}
2104  		alloc_ctx.szind = sz_size2index_lookup(size);
2105  	}
2106  	if (unlikely(ticker_trytick(&amp;tcache-&gt;gc_ticker))) {
2107  		return false;
2108  	}
2109  	cache_bin_t *bin = tcache_small_bin_get(tcache, alloc_ctx.szind);
2110  	cache_bin_info_t *bin_info = &amp;tcache_bin_info[alloc_ctx.szind];
2111  	if (!cache_bin_dalloc_easy(bin, bin_info, ptr)) {
2112  		return false;
2113  	}
2114  	if (config_stats) {
2115  		size_t usize = sz_index2size(alloc_ctx.szind);
2116  		*tsd_thread_deallocatedp_get(tsd) += usize;
2117  	}
2118  	return true;
2119  }
2120  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2121  je_free(void *ptr) {
2122  	LOG(&quot;core.free.entry&quot;, &quot;ptr: %p&quot;, ptr);
2123  	if (!free_fastpath(ptr, 0, false)) {
2124  		free_default(ptr);
2125  	}
2126  	LOG(&quot;core.free.exit&quot;, &quot;&quot;);
2127  }
2128  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
2129  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2130  void JEMALLOC_NOTHROW *
2131  JEMALLOC_ATTR(malloc)
2132  je_memalign(size_t alignment, size_t size) {
2133  	void *ret;
2134  	static_opts_t sopts;
2135  	dynamic_opts_t dopts;
2136  	LOG(&quot;core.memalign.entry&quot;, &quot;alignment: %zu, size: %zu\n&quot;, alignment,
2137  	    size);
2138  	static_opts_init(&amp;sopts);
2139  	dynamic_opts_init(&amp;dopts);
2140  	sopts.min_alignment = 1;
2141  	sopts.oom_string =
2142  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
2143  	sopts.invalid_alignment_string =
2144  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
2145  	sopts.null_out_result_on_error = true;
2146  	dopts.result = &amp;ret;
2147  	dopts.num_items = 1;
2148  	dopts.item_size = size;
2149  	dopts.alignment = alignment;
2150  	imalloc(&amp;sopts, &amp;dopts);
2151  	if (sopts.slow) {
2152  		uintptr_t args[3] = {alignment, size};
2153  		hook_invoke_alloc(hook_alloc_memalign, ret, (uintptr_t)ret,
2154  		    args);
2155  	}
2156  	LOG(&quot;core.memalign.exit&quot;, &quot;result: %p&quot;, ret);
2157  	return ret;
2158  }
2159  #endif
2160  #ifdef JEMALLOC_OVERRIDE_VALLOC
2161  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2162  void JEMALLOC_NOTHROW *
2163  JEMALLOC_ATTR(malloc)
2164  je_valloc(size_t size) {
2165  	void *ret;
2166  	static_opts_t sopts;
2167  	dynamic_opts_t dopts;
2168  	LOG(&quot;core.valloc.entry&quot;, &quot;size: %zu\n&quot;, size);
2169  	static_opts_init(&amp;sopts);
2170  	dynamic_opts_init(&amp;dopts);
2171  	sopts.null_out_result_on_error = true;
2172  	sopts.min_alignment = PAGE;
2173  	sopts.oom_string =
2174  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
2175  	sopts.invalid_alignment_string =
2176  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
2177  	dopts.result = &amp;ret;
2178  	dopts.num_items = 1;
2179  	dopts.item_size = size;
2180  	dopts.alignment = PAGE;
2181  	imalloc(&amp;sopts, &amp;dopts);
2182  	if (sopts.slow) {
2183  		uintptr_t args[3] = {size};
2184  		hook_invoke_alloc(hook_alloc_valloc, ret, (uintptr_t)ret, args);
2185  	}
2186  	LOG(&quot;core.valloc.exit&quot;, &quot;result: %p\n&quot;, ret);
2187  	return ret;
2188  }
2189  #endif
2190  #if defined(JEMALLOC_IS_MALLOC) &amp;&amp; defined(JEMALLOC_GLIBC_MALLOC_HOOK)
2191  JEMALLOC_EXPORT void (*__free_hook)(void *ptr) = je_free;
2192  JEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;
2193  JEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;
2194  #  ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
2195  JEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =
2196      je_memalign;
2197  #  endif
2198  #  ifdef CPU_COUNT
2199  #    define ALIAS(je_fn)	__attribute__((alias (#je_fn), used))
2200  #    define PREALIAS(je_fn)	ALIAS(je_fn)
2201  #    ifdef JEMALLOC_OVERRIDE___LIBC_CALLOC
2202  void *__libc_calloc(size_t n, size_t size) PREALIAS(je_calloc);
2203  #    endif
2204  #    ifdef JEMALLOC_OVERRIDE___LIBC_FREE
2205  void __libc_free(void* ptr) PREALIAS(je_free);
2206  #    endif
2207  #    ifdef JEMALLOC_OVERRIDE___LIBC_MALLOC
2208  void *__libc_malloc(size_t size) PREALIAS(je_malloc);
2209  #    endif
2210  #    ifdef JEMALLOC_OVERRIDE___LIBC_MEMALIGN
2211  void *__libc_memalign(size_t align, size_t s) PREALIAS(je_memalign);
2212  #    endif
2213  #    ifdef JEMALLOC_OVERRIDE___LIBC_REALLOC
2214  void *__libc_realloc(void* ptr, size_t size) PREALIAS(je_realloc);
2215  #    endif
2216  #    ifdef JEMALLOC_OVERRIDE___LIBC_VALLOC
2217  void *__libc_valloc(size_t size) PREALIAS(je_valloc);
2218  #    endif
2219  #    ifdef JEMALLOC_OVERRIDE___POSIX_MEMALIGN
2220  int __posix_memalign(void** r, size_t a, size_t s) PREALIAS(je_posix_memalign);
2221  #    endif
2222  #    undef PREALIAS
2223  #    undef ALIAS
2224  #  endif
2225  #endif
2226  #ifdef JEMALLOC_EXPERIMENTAL_SMALLOCX_API
2227  #define JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y) x ## y
2228  #define JEMALLOC_SMALLOCX_CONCAT_HELPER2(x, y)  \
2229    JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y)
2230  typedef struct {
2231  	void *ptr;
2232  	size_t size;
2233  } smallocx_return_t;
2234  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2235  smallocx_return_t JEMALLOC_NOTHROW
2236  JEMALLOC_SMALLOCX_CONCAT_HELPER2(je_smallocx_, JEMALLOC_VERSION_GID_IDENT)
2237    (size_t size, int flags) {
2238  	smallocx_return_t ret;
2239  	static_opts_t sopts;
2240  	dynamic_opts_t dopts;
2241  	LOG(&quot;core.smallocx.entry&quot;, &quot;size: %zu, flags: %d&quot;, size, flags);
2242  	static_opts_init(&amp;sopts);
2243  	dynamic_opts_init(&amp;dopts);
2244  	sopts.assert_nonempty_alloc = true;
2245  	sopts.null_out_result_on_error = true;
2246  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in mallocx(): out of memory\n&quot;;
2247  	sopts.usize = true;
2248  	dopts.result = &amp;ret.ptr;
2249  	dopts.num_items = 1;
2250  	dopts.item_size = size;
2251  	if (unlikely(flags != 0)) {
2252  		if ((flags &amp; MALLOCX_LG_ALIGN_MASK) != 0) {
2253  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2254  		}
2255  		dopts.zero = MALLOCX_ZERO_GET(flags);
2256  		if ((flags &amp; MALLOCX_TCACHE_MASK) != 0) {
2257  			if ((flags &amp; MALLOCX_TCACHE_MASK)
2258  			    == MALLOCX_TCACHE_NONE) {
2259  				dopts.tcache_ind = TCACHE_IND_NONE;
2260  			} else {
2261  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2262  			}
2263  		} else {
2264  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2265  		}
2266  		if ((flags &amp; MALLOCX_ARENA_MASK) != 0)
2267  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2268  	}
2269  	imalloc(&amp;sopts, &amp;dopts);
2270  	assert(dopts.usize == je_nallocx(size, flags));
2271  	ret.size = dopts.usize;
2272  	LOG(&quot;core.smallocx.exit&quot;, &quot;result: %p, size: %zu&quot;, ret.ptr, ret.size);
2273  	return ret;
2274  }
2275  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER
2276  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER2
2277  #endif
2278  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2279  void JEMALLOC_NOTHROW *
2280  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
2281  je_mallocx(size_t size, int flags) {
2282  	void *ret;
2283  	static_opts_t sopts;
2284  	dynamic_opts_t dopts;
2285  	LOG(&quot;core.mallocx.entry&quot;, &quot;size: %zu, flags: %d&quot;, size, flags);
2286  	static_opts_init(&amp;sopts);
2287  	dynamic_opts_init(&amp;dopts);
2288  	sopts.assert_nonempty_alloc = true;
2289  	sopts.null_out_result_on_error = true;
2290  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in mallocx(): out of memory\n&quot;;
2291  	dopts.result = &amp;ret;
2292  	dopts.num_items = 1;
2293  	dopts.item_size = size;
2294  	if (unlikely(flags != 0)) {
2295  		if ((flags &amp; MALLOCX_LG_ALIGN_MASK) != 0) {
2296  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2297  		}
2298  		dopts.zero = MALLOCX_ZERO_GET(flags);
2299  		if ((flags &amp; MALLOCX_TCACHE_MASK) != 0) {
2300  			if ((flags &amp; MALLOCX_TCACHE_MASK)
2301  			    == MALLOCX_TCACHE_NONE) {
2302  				dopts.tcache_ind = TCACHE_IND_NONE;
2303  			} else {
2304  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2305  			}
2306  		} else {
2307  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2308  		}
2309  		if ((flags &amp; MALLOCX_ARENA_MASK) != 0)
2310  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2311  	}
2312  	imalloc(&amp;sopts, &amp;dopts);
2313  	if (sopts.slow) {
2314  		uintptr_t args[3] = {size, flags};
2315  		hook_invoke_alloc(hook_alloc_mallocx, ret, (uintptr_t)ret,
2316  		    args);
2317  	}
2318  	LOG(&quot;core.mallocx.exit&quot;, &quot;result: %p&quot;, ret);
2319  	return ret;
2320  }
2321  static void *
2322  irallocx_prof_sample(tsdn_t *tsdn, void *old_ptr, size_t old_usize,
2323      size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
2324      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
2325  	void *p;
2326  	if (tctx == NULL) {
2327  		return NULL;
2328  	}
2329  	if (usize &lt;= SC_SMALL_MAXCLASS) {
2330  		p = iralloct(tsdn, old_ptr, old_usize,
2331  		    SC_LARGE_MINCLASS, alignment, zero, tcache,
2332  		    arena, hook_args);
2333  		if (p == NULL) {
2334  			return NULL;
2335  		}
2336  		arena_prof_promote(tsdn, p, usize);
2337  	} else {
2338  		p = iralloct(tsdn, old_ptr, old_usize, usize, alignment, zero,
2339  		    tcache, arena, hook_args);
2340  	}
2341  	return p;
2342  }
2343  JEMALLOC_ALWAYS_INLINE void *
2344  irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
2345      size_t alignment, size_t *usize, bool zero, tcache_t *tcache,
2346      arena_t *arena, alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
2347  	void *p;
2348  	bool prof_active;
2349  	prof_tctx_t *old_tctx, *tctx;
2350  	prof_active = prof_active_get_unlocked();
2351  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
2352  	tctx = prof_alloc_prep(tsd, *usize, prof_active, false);
2353  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2354  		p = irallocx_prof_sample(tsd_tsdn(tsd), old_ptr, old_usize,
2355  		    *usize, alignment, zero, tcache, arena, tctx, hook_args);
2356  	} else {
2357  		p = iralloct(tsd_tsdn(tsd), old_ptr, old_usize, size, alignment,
2358  		    zero, tcache, arena, hook_args);
2359  	}
2360  	if (unlikely(p == NULL)) {
2361  		prof_alloc_rollback(tsd, tctx, false);
2362  		return NULL;
2363  	}
2364  	if (p == old_ptr &amp;&amp; alignment != 0) {
2365  		*usize = isalloc(tsd_tsdn(tsd), p);
2366  	}
2367  	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
2368  	    old_usize, old_tctx);
2369  	return p;
2370  }
2371  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2372  void JEMALLOC_NOTHROW *
2373  JEMALLOC_ALLOC_SIZE(2)
2374  je_rallocx(void *ptr, size_t size, int flags) {
2375  	void *p;
2376  	tsd_t *tsd;
2377  	size_t usize;
2378  	size_t old_usize;
2379  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2380  	bool zero = flags &amp; MALLOCX_ZERO;
2381  	arena_t *arena;
2382  	tcache_t *tcache;
2383  	LOG(&quot;core.rallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: %d&quot;, ptr,
2384  	    size, flags);
2385  	assert(ptr != NULL);
2386  	assert(size != 0);
2387  	assert(malloc_initialized() || IS_INITIALIZER);
2388  	tsd = tsd_fetch();
2389  	check_entry_exit_locking(tsd_tsdn(tsd));
2390  	if (unlikely((flags &amp; MALLOCX_ARENA_MASK) != 0)) {
2391  		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
2392  		arena = arena_get(tsd_tsdn(tsd), arena_ind, true);
2393  		if (unlikely(arena == NULL)) {
2394  			goto label_oom;
2395  		}
2396  	} else {
2397  		arena = NULL;
2398  	}
2399  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2400  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2401  			tcache = NULL;
2402  		} else {
2403  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2404  		}
2405  	} else {
2406  		tcache = tcache_get(tsd);
2407  	}
2408  	alloc_ctx_t alloc_ctx;
2409  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2410  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
2411  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2412  	assert(alloc_ctx.szind != SC_NSIZES);
2413  	old_usize = sz_index2size(alloc_ctx.szind);
2414  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2415  	hook_ralloc_args_t hook_args = {false, {(uintptr_t)ptr, size, flags,
2416  		0}};
2417  	if (config_prof &amp;&amp; opt_prof) {
2418  		usize = (alignment == 0) ?
2419  		    sz_s2u(size) : sz_sa2u(size, alignment);
2420  		if (unlikely(usize == 0
2421  		    || usize &gt; SC_LARGE_MAXCLASS)) {
2422  			goto label_oom;
2423  		}
2424  		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, &amp;usize,
2425  		    zero, tcache, arena, &amp;alloc_ctx, &amp;hook_args);
2426  		if (unlikely(p == NULL)) {
2427  			goto label_oom;
2428  		}
2429  	} else {
2430  		p = iralloct(tsd_tsdn(tsd), ptr, old_usize, size, alignment,
2431  		    zero, tcache, arena, &amp;hook_args);
2432  		if (unlikely(p == NULL)) {
2433  			goto label_oom;
2434  		}
2435  		if (config_stats) {
2436  			usize = isalloc(tsd_tsdn(tsd), p);
2437  		}
2438  	}
2439  	assert(alignment == 0 || ((uintptr_t)p &amp; (alignment - 1)) == ZU(0));
2440  	if (config_stats) {
2441  		*tsd_thread_allocatedp_get(tsd) += usize;
2442  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2443  	}
2444  	UTRACE(ptr, size, p);
2445  	check_entry_exit_locking(tsd_tsdn(tsd));
2446  	LOG(&quot;core.rallocx.exit&quot;, &quot;result: %p&quot;, p);
2447  	return p;
2448  label_oom:
2449  	if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
2450  		malloc_write(&quot;&lt;jemalloc&gt;: Error in rallocx(): out of memory\n&quot;);
2451  		abort();
2452  	}
2453  	UTRACE(ptr, size, 0);
2454  	check_entry_exit_locking(tsd_tsdn(tsd));
2455  	LOG(&quot;core.rallocx.exit&quot;, &quot;result: %p&quot;, NULL);
2456  	return NULL;
2457  }
2458  JEMALLOC_ALWAYS_INLINE size_t
2459  ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2460      size_t extra, size_t alignment, bool zero) {
2461  	size_t newsize;
2462  	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero,
2463  	    &amp;newsize)) {
2464  		return old_usize;
2465  	}
2466  	return newsize;
2467  }
2468  static size_t
2469  ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2470      size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx) {
2471  	size_t usize;
2472  	if (tctx == NULL) {
2473  		return old_usize;
2474  	}
2475  	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
2476  	    zero);
2477  	return usize;
2478  }
2479  JEMALLOC_ALWAYS_INLINE size_t
2480  ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
2481      size_t extra, size_t alignment, bool zero, alloc_ctx_t *alloc_ctx) {
2482  	size_t usize_max, usize;
2483  	bool prof_active;
2484  	prof_tctx_t *old_tctx, *tctx;
2485  	prof_active = prof_active_get_unlocked();
2486  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), ptr, alloc_ctx);
2487  	if (alignment == 0) {
2488  		usize_max = sz_s2u(size+extra);
2489  		assert(usize_max &gt; 0
2490  		    &amp;&amp; usize_max &lt;= SC_LARGE_MAXCLASS);
2491  	} else {
2492  		usize_max = sz_sa2u(size+extra, alignment);
2493  		if (unlikely(usize_max == 0
2494  		    || usize_max &gt; SC_LARGE_MAXCLASS)) {
2495  			usize_max = SC_LARGE_MAXCLASS;
2496  		}
2497  	}
2498  	tctx = prof_alloc_prep(tsd, usize_max, prof_active, false);
2499  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2500  		usize = ixallocx_prof_sample(tsd_tsdn(tsd), ptr, old_usize,
2501  		    size, extra, alignment, zero, tctx);
2502  	} else {
2503  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2504  		    extra, alignment, zero);
2505  	}
2506  	if (usize == old_usize) {
2507  		prof_alloc_rollback(tsd, tctx, false);
2508  		return usize;
2509  	}
2510  	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
2511  	    old_tctx);
2512  	return usize;
2513  }
2514  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2515  je_xallocx(void *ptr, size_t size, size_t extra, int flags) {
2516  	tsd_t *tsd;
2517  	size_t usize, old_usize;
2518  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2519  	bool zero = flags &amp; MALLOCX_ZERO;
2520  	LOG(&quot;core.xallocx.entry&quot;, &quot;ptr: %p, size: %zu, extra: %zu, &quot;
2521  	    &quot;flags: %d&quot;, ptr, size, extra, flags);
2522  	assert(ptr != NULL);
2523  	assert(size != 0);
2524  	assert(SIZE_T_MAX - size &gt;= extra);
2525  	assert(malloc_initialized() || IS_INITIALIZER);
2526  	tsd = tsd_fetch();
2527  	check_entry_exit_locking(tsd_tsdn(tsd));
2528  	alloc_ctx_t alloc_ctx;
2529  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2530  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
2531  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2532  	assert(alloc_ctx.szind != SC_NSIZES);
2533  	old_usize = sz_index2size(alloc_ctx.szind);
2534  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2535  	if (unlikely(size &gt; SC_LARGE_MAXCLASS)) {
2536  		usize = old_usize;
2537  		goto label_not_resized;
2538  	}
2539  	if (unlikely(SC_LARGE_MAXCLASS - size &lt; extra)) {
2540  		extra = SC_LARGE_MAXCLASS - size;
2541  	}
2542  	if (config_prof &amp;&amp; opt_prof) {
2543  		usize = ixallocx_prof(tsd, ptr, old_usize, size, extra,
2544  		    alignment, zero, &amp;alloc_ctx);
2545  	} else {
2546  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2547  		    extra, alignment, zero);
2548  	}
2549  	if (unlikely(usize == old_usize)) {
2550  		goto label_not_resized;
2551  	}
2552  	if (config_stats) {
2553  		*tsd_thread_allocatedp_get(tsd) += usize;
2554  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2555  	}
2556  label_not_resized:
2557  	if (unlikely(!tsd_fast(tsd))) {
2558  		uintptr_t args[4] = {(uintptr_t)ptr, size, extra, flags};
2559  		hook_invoke_expand(hook_expand_xallocx, ptr, old_usize,
2560  		    usize, (uintptr_t)usize, args);
2561  	}
2562  	UTRACE(ptr, size, ptr);
2563  	check_entry_exit_locking(tsd_tsdn(tsd));
2564  	LOG(&quot;core.xallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2565  	return usize;
2566  }
2567  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2568  JEMALLOC_ATTR(pure)
2569  je_sallocx(const void *ptr, int flags) {
2570  	size_t usize;
2571  	tsdn_t *tsdn;
2572  	LOG(&quot;core.sallocx.entry&quot;, &quot;ptr: %p, flags: %d&quot;, ptr, flags);
2573  	assert(malloc_initialized() || IS_INITIALIZER);
2574  	assert(ptr != NULL);
2575  	tsdn = tsdn_fetch();
2576  	check_entry_exit_locking(tsdn);
<span onclick='openModal()' class='match'>2577  	if (config_debug || force_ivsalloc) {
2578  		usize = ivsalloc(tsdn, ptr);
2579  		assert(force_ivsalloc || usize != 0);
2580  	} else {
2581  		usize = isalloc(tsdn, ptr);
2582  	}
2583  	check_entry_exit_locking(tsdn);
</span>2584  	LOG(&quot;core.sallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2585  	return usize;
2586  }
2587  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2588  je_dallocx(void *ptr, int flags) {
2589  	LOG(&quot;core.dallocx.entry&quot;, &quot;ptr: %p, flags: %d&quot;, ptr, flags);
2590  	assert(ptr != NULL);
2591  	assert(malloc_initialized() || IS_INITIALIZER);
2592  	tsd_t *tsd = tsd_fetch();
2593  	bool fast = tsd_fast(tsd);
2594  	check_entry_exit_locking(tsd_tsdn(tsd));
2595  	tcache_t *tcache;
2596  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2597  		assert(tsd_reentrancy_level_get(tsd) == 0);
2598  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2599  			tcache = NULL;
2600  		} else {
2601  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2602  		}
2603  	} else {
2604  		if (likely(fast)) {
2605  			tcache = tsd_tcachep_get(tsd);
2606  			assert(tcache == tcache_get(tsd));
2607  		} else {
2608  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2609  				tcache = tcache_get(tsd);
2610  			}  else {
2611  				tcache = NULL;
2612  			}
2613  		}
2614  	}
2615  	UTRACE(ptr, 0, 0);
2616  	if (likely(fast)) {
2617  		tsd_assert_fast(tsd);
2618  		ifree(tsd, ptr, tcache, false);
2619  	} else {
2620  		uintptr_t args_raw[3] = {(uintptr_t)ptr, flags};
2621  		hook_invoke_dalloc(hook_dalloc_dallocx, ptr, args_raw);
2622  		ifree(tsd, ptr, tcache, true);
2623  	}
2624  	check_entry_exit_locking(tsd_tsdn(tsd));
2625  	LOG(&quot;core.dallocx.exit&quot;, &quot;&quot;);
2626  }
2627  JEMALLOC_ALWAYS_INLINE size_t
2628  inallocx(tsdn_t *tsdn, size_t size, int flags) {
2629  	check_entry_exit_locking(tsdn);
2630  	size_t usize;
2631  	if (likely((flags &amp; MALLOCX_LG_ALIGN_MASK) == 0)) {
2632  		usize = sz_s2u(size);
2633  	} else {
2634  		usize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
2635  	}
2636  	check_entry_exit_locking(tsdn);
2637  	return usize;
2638  }
2639  JEMALLOC_NOINLINE void
2640  sdallocx_default(void *ptr, size_t size, int flags) {
2641  	assert(ptr != NULL);
2642  	assert(malloc_initialized() || IS_INITIALIZER);
2643  	tsd_t *tsd = tsd_fetch();
2644  	bool fast = tsd_fast(tsd);
2645  	size_t usize = inallocx(tsd_tsdn(tsd), size, flags);
2646  	assert(usize == isalloc(tsd_tsdn(tsd), ptr));
2647  	check_entry_exit_locking(tsd_tsdn(tsd));
2648  	tcache_t *tcache;
2649  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2650  		assert(tsd_reentrancy_level_get(tsd) == 0);
2651  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2652  			tcache = NULL;
2653  		} else {
2654  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2655  		}
2656  	} else {
2657  		if (likely(fast)) {
2658  			tcache = tsd_tcachep_get(tsd);
2659  			assert(tcache == tcache_get(tsd));
2660  		} else {
2661  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2662  				tcache = tcache_get(tsd);
2663  			} else {
2664  				tcache = NULL;
2665  			}
2666  		}
2667  	}
2668  	UTRACE(ptr, 0, 0);
2669  	if (likely(fast)) {
2670  		tsd_assert_fast(tsd);
2671  		isfree(tsd, ptr, usize, tcache, false);
2672  	} else {
2673  		uintptr_t args_raw[3] = {(uintptr_t)ptr, size, flags};
2674  		hook_invoke_dalloc(hook_dalloc_sdallocx, ptr, args_raw);
2675  		isfree(tsd, ptr, usize, tcache, true);
2676  	}
2677  	check_entry_exit_locking(tsd_tsdn(tsd));
2678  }
2679  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2680  je_sdallocx(void *ptr, size_t size, int flags) {
2681  	LOG(&quot;core.sdallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: %d&quot;, ptr,
2682  		size, flags);
2683  	if (flags !=0 || !free_fastpath(ptr, size, true)) {
2684  		sdallocx_default(ptr, size, flags);
2685  	}
2686  	LOG(&quot;core.sdallocx.exit&quot;, &quot;&quot;);
2687  }
2688  void JEMALLOC_NOTHROW
2689  je_sdallocx_noflags(void *ptr, size_t size) {
2690  	LOG(&quot;core.sdallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: 0&quot;, ptr,
2691  		size);
2692  	if (!free_fastpath(ptr, size, true)) {
2693  		sdallocx_default(ptr, size, 0);
2694  	}
2695  	LOG(&quot;core.sdallocx.exit&quot;, &quot;&quot;);
2696  }
2697  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2698  JEMALLOC_ATTR(pure)
2699  je_nallocx(size_t size, int flags) {
2700  	size_t usize;
2701  	tsdn_t *tsdn;
2702  	assert(size != 0);
2703  	if (unlikely(malloc_init())) {
2704  		LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, ZU(0));
2705  		return 0;
2706  	}
2707  	tsdn = tsdn_fetch();
2708  	check_entry_exit_locking(tsdn);
2709  	usize = inallocx(tsdn, size, flags);
2710  	if (unlikely(usize &gt; SC_LARGE_MAXCLASS)) {
2711  		LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, ZU(0));
2712  		return 0;
2713  	}
2714  	check_entry_exit_locking(tsdn);
2715  	LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2716  	return usize;
2717  }
2718  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2719  je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
2720      size_t newlen) {
2721  	int ret;
2722  	tsd_t *tsd;
2723  	LOG(&quot;core.mallctl.entry&quot;, &quot;name: %s&quot;, name);
2724  	if (unlikely(malloc_init())) {
2725  		LOG(&quot;core.mallctl.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2726  		return EAGAIN;
2727  	}
2728  	tsd = tsd_fetch();
2729  	check_entry_exit_locking(tsd_tsdn(tsd));
2730  	ret = ctl_byname(tsd, name, oldp, oldlenp, newp, newlen);
2731  	check_entry_exit_locking(tsd_tsdn(tsd));
2732  	LOG(&quot;core.mallctl.exit&quot;, &quot;result: %d&quot;, ret);
2733  	return ret;
2734  }
2735  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2736  je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
2737  	int ret;
2738  	LOG(&quot;core.mallctlnametomib.entry&quot;, &quot;name: %s&quot;, name);
2739  	if (unlikely(malloc_init())) {
2740  		LOG(&quot;core.mallctlnametomib.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2741  		return EAGAIN;
2742  	}
2743  	tsd_t *tsd = tsd_fetch();
2744  	check_entry_exit_locking(tsd_tsdn(tsd));
2745  	ret = ctl_nametomib(tsd, name, mibp, miblenp);
2746  	check_entry_exit_locking(tsd_tsdn(tsd));
2747  	LOG(&quot;core.mallctlnametomib.exit&quot;, &quot;result: %d&quot;, ret);
2748  	return ret;
2749  }
2750  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2751  je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
2752    void *newp, size_t newlen) {
2753  	int ret;
2754  	tsd_t *tsd;
2755  	LOG(&quot;core.mallctlbymib.entry&quot;, &quot;&quot;);
2756  	if (unlikely(malloc_init())) {
2757  		LOG(&quot;core.mallctlbymib.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2758  		return EAGAIN;
2759  	}
2760  	tsd = tsd_fetch();
2761  	check_entry_exit_locking(tsd_tsdn(tsd));
2762  	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
2763  	check_entry_exit_locking(tsd_tsdn(tsd));
2764  	LOG(&quot;core.mallctlbymib.exit&quot;, &quot;result: %d&quot;, ret);
2765  	return ret;
2766  }
2767  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2768  je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
2769      const char *opts) {
2770  	tsdn_t *tsdn;
2771  	LOG(&quot;core.malloc_stats_print.entry&quot;, &quot;&quot;);
2772  	tsdn = tsdn_fetch();
2773  	check_entry_exit_locking(tsdn);
2774  	stats_print(write_cb, cbopaque, opts);
2775  	check_entry_exit_locking(tsdn);
2776  	LOG(&quot;core.malloc_stats_print.exit&quot;, &quot;&quot;);
2777  }
2778  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2779  je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
2780  	size_t ret;
2781  	tsdn_t *tsdn;
2782  	LOG(&quot;core.malloc_usable_size.entry&quot;, &quot;ptr: %p&quot;, ptr);
2783  	assert(malloc_initialized() || IS_INITIALIZER);
2784  	tsdn = tsdn_fetch();
2785  	check_entry_exit_locking(tsdn);
2786  	if (unlikely(ptr == NULL)) {
2787  		ret = 0;
2788  	} else {
2789  		if (config_debug || force_ivsalloc) {
2790  			ret = ivsalloc(tsdn, ptr);
2791  			assert(force_ivsalloc || ret != 0);
2792  		} else {
2793  			ret = isalloc(tsdn, ptr);
2794  		}
2795  	}
2796  	check_entry_exit_locking(tsdn);
2797  	LOG(&quot;core.malloc_usable_size.exit&quot;, &quot;result: %zu&quot;, ret);
2798  	return ret;
2799  }
2800  #ifndef JEMALLOC_JET
2801  JEMALLOC_ATTR(constructor)
2802  static void
2803  jemalloc_constructor(void) {
2804  	malloc_init();
2805  }
2806  #endif
2807  #ifndef JEMALLOC_MUTEX_INIT_CB
2808  void
2809  jemalloc_prefork(void)
2810  #else
2811  JEMALLOC_EXPORT void
2812  _malloc_prefork(void)
2813  #endif
2814  {
2815  	tsd_t *tsd;
2816  	unsigned i, j, narenas;
2817  	arena_t *arena;
2818  #ifdef JEMALLOC_MUTEX_INIT_CB
2819  	if (!malloc_initialized()) {
2820  		return;
2821  	}
2822  #endif
2823  	assert(malloc_initialized());
2824  	tsd = tsd_fetch();
2825  	narenas = narenas_total_get();
2826  	witness_prefork(tsd_witness_tsdp_get(tsd));
2827  	ctl_prefork(tsd_tsdn(tsd));
2828  	tcache_prefork(tsd_tsdn(tsd));
2829  	malloc_mutex_prefork(tsd_tsdn(tsd), &amp;arenas_lock);
2830  	if (have_background_thread) {
2831  		background_thread_prefork0(tsd_tsdn(tsd));
2832  	}
2833  	prof_prefork0(tsd_tsdn(tsd));
2834  	if (have_background_thread) {
2835  		background_thread_prefork1(tsd_tsdn(tsd));
2836  	}
2837  	for (i = 0; i &lt; 8; i++) {
2838  		for (j = 0; j &lt; narenas; j++) {
2839  			if ((arena = arena_get(tsd_tsdn(tsd), j, false)) !=
2840  			    NULL) {
2841  				switch (i) {
2842  				case 0:
2843  					arena_prefork0(tsd_tsdn(tsd), arena);
2844  					break;
2845  				case 1:
2846  					arena_prefork1(tsd_tsdn(tsd), arena);
2847  					break;
2848  				case 2:
2849  					arena_prefork2(tsd_tsdn(tsd), arena);
2850  					break;
2851  				case 3:
2852  					arena_prefork3(tsd_tsdn(tsd), arena);
2853  					break;
2854  				case 4:
2855  					arena_prefork4(tsd_tsdn(tsd), arena);
2856  					break;
2857  				case 5:
2858  					arena_prefork5(tsd_tsdn(tsd), arena);
2859  					break;
2860  				case 6:
2861  					arena_prefork6(tsd_tsdn(tsd), arena);
2862  					break;
2863  				case 7:
2864  					arena_prefork7(tsd_tsdn(tsd), arena);
2865  					break;
2866  				default: not_reached();
2867  				}
2868  			}
2869  		}
2870  	}
2871  	prof_prefork1(tsd_tsdn(tsd));
2872  	tsd_prefork(tsd);
2873  }
2874  #ifndef JEMALLOC_MUTEX_INIT_CB
2875  void
2876  jemalloc_postfork_parent(void)
2877  #else
2878  JEMALLOC_EXPORT void
2879  _malloc_postfork(void)
2880  #endif
2881  {
2882  	tsd_t *tsd;
2883  	unsigned i, narenas;
2884  #ifdef JEMALLOC_MUTEX_INIT_CB
2885  	if (!malloc_initialized()) {
2886  		return;
2887  	}
2888  #endif
2889  	assert(malloc_initialized());
2890  	tsd = tsd_fetch();
2891  	tsd_postfork_parent(tsd);
2892  	witness_postfork_parent(tsd_witness_tsdp_get(tsd));
2893  	for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
2894  		arena_t *arena;
2895  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2896  			arena_postfork_parent(tsd_tsdn(tsd), arena);
2897  		}
2898  	}
2899  	prof_postfork_parent(tsd_tsdn(tsd));
2900  	if (have_background_thread) {
2901  		background_thread_postfork_parent(tsd_tsdn(tsd));
2902  	}
2903  	malloc_mutex_postfork_parent(tsd_tsdn(tsd), &amp;arenas_lock);
2904  	tcache_postfork_parent(tsd_tsdn(tsd));
2905  	ctl_postfork_parent(tsd_tsdn(tsd));
2906  }
2907  void
2908  jemalloc_postfork_child(void) {
2909  	tsd_t *tsd;
2910  	unsigned i, narenas;
2911  	assert(malloc_initialized());
2912  	tsd = tsd_fetch();
2913  	tsd_postfork_child(tsd);
2914  	witness_postfork_child(tsd_witness_tsdp_get(tsd));
2915  	for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
2916  		arena_t *arena;
2917  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2918  			arena_postfork_child(tsd_tsdn(tsd), arena);
2919  		}
2920  	}
2921  	prof_postfork_child(tsd_tsdn(tsd));
2922  	if (have_background_thread) {
2923  		background_thread_postfork_child(tsd_tsdn(tsd));
2924  	}
2925  	malloc_mutex_postfork_child(tsd_tsdn(tsd), &amp;arenas_lock);
2926  	tcache_postfork_child(tsd_tsdn(tsd));
2927  	ctl_postfork_child(tsd_tsdn(tsd));
2928  }
2929  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2930  je_get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
2931  	assert(ptr != NULL);
2932  	return iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);
2933  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</h3>
            <pre><code>1  #define JEMALLOC_C_
2  #include &quot;jemalloc/internal/jemalloc_preamble.h&quot;
3  #include &quot;jemalloc/internal/jemalloc_internal_includes.h&quot;
4  #include &quot;jemalloc/internal/assert.h&quot;
5  #include &quot;jemalloc/internal/atomic.h&quot;
6  #include &quot;jemalloc/internal/ctl.h&quot;
7  #include &quot;jemalloc/internal/extent_dss.h&quot;
8  #include &quot;jemalloc/internal/extent_mmap.h&quot;
9  #include &quot;jemalloc/internal/hook.h&quot;
10  #include &quot;jemalloc/internal/jemalloc_internal_types.h&quot;
11  #include &quot;jemalloc/internal/log.h&quot;
12  #include &quot;jemalloc/internal/malloc_io.h&quot;
13  #include &quot;jemalloc/internal/mutex.h&quot;
14  #include &quot;jemalloc/internal/rtree.h&quot;
15  #include &quot;jemalloc/internal/safety_check.h&quot;
16  #include &quot;jemalloc/internal/sc.h&quot;
17  #include &quot;jemalloc/internal/spin.h&quot;
18  #include &quot;jemalloc/internal/sz.h&quot;
19  #include &quot;jemalloc/internal/ticker.h&quot;
20  #include &quot;jemalloc/internal/util.h&quot;
21  const char	*je_malloc_conf
22  #ifndef _WIN32
23      JEMALLOC_ATTR(weak)
24  #endif
25      ;
26  bool	opt_abort =
27  #ifdef JEMALLOC_DEBUG
28      true
29  #else
30      false
31  #endif
32      ;
33  bool	opt_abort_conf =
34  #ifdef JEMALLOC_DEBUG
35      true
36  #else
37      false
38  #endif
39      ;
40  bool	opt_confirm_conf = false;
41  const char	*opt_junk =
42  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
43      &quot;true&quot;
44  #else
45      &quot;false&quot;
46  #endif
47      ;
48  bool	opt_junk_alloc =
49  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
50      true
51  #else
52      false
53  #endif
54      ;
55  bool	opt_junk_free =
56  #if (defined(JEMALLOC_DEBUG) &amp;&amp; defined(JEMALLOC_FILL))
57      true
58  #else
59      false
60  #endif
61      ;
62  bool	opt_utrace = false;
63  bool	opt_xmalloc = false;
64  bool	opt_zero = false;
65  unsigned	opt_narenas = 0;
66  unsigned	ncpus;
67  malloc_mutex_t arenas_lock;
68  JEMALLOC_ALIGNED(CACHELINE)
69  atomic_p_t		arenas[MALLOCX_ARENA_LIMIT];
70  static atomic_u_t	narenas_total; &amp;bsol;* Use narenas_total_*(). */
71  static arena_t		*a0; &amp;bsol;* arenas[0]. */
72  unsigned		narenas_auto;
73  unsigned		manual_arena_base;
74  typedef enum {
75  	malloc_init_uninitialized	= 3,
76  	malloc_init_a0_initialized	= 2,
77  	malloc_init_recursible		= 1,
78  	malloc_init_initialized		= 0 &amp;bsol;* Common case --&gt; jnz. */
79  } malloc_init_t;
80  static malloc_init_t	malloc_init_state = malloc_init_uninitialized;
81  bool			malloc_slow = true;
82  enum {
83  	flag_opt_junk_alloc	= (1U),
84  	flag_opt_junk_free	= (1U &lt;&lt; 1),
85  	flag_opt_zero		= (1U &lt;&lt; 2),
86  	flag_opt_utrace		= (1U &lt;&lt; 3),
87  	flag_opt_xmalloc	= (1U &lt;&lt; 4)
88  };
89  static uint8_t	malloc_slow_flags;
90  #ifdef JEMALLOC_THREADED_INIT
91  #  define NO_INITIALIZER	((unsigned long)0)
92  #  define INITIALIZER		pthread_self()
93  #  define IS_INITIALIZER	(malloc_initializer == pthread_self())
94  static pthread_t		malloc_initializer = NO_INITIALIZER;
95  #else
96  #  define NO_INITIALIZER	false
97  #  define INITIALIZER		true
98  #  define IS_INITIALIZER	malloc_initializer
99  static bool			malloc_initializer = NO_INITIALIZER;
100  #endif
101  #ifdef _WIN32
102  #if _WIN32_WINNT &gt;= 0x0600
103  static malloc_mutex_t	init_lock = SRWLOCK_INIT;
104  #else
105  static malloc_mutex_t	init_lock;
106  static bool init_lock_initialized = false;
107  JEMALLOC_ATTR(constructor)
108  static void WINAPI
109  _init_init_lock(void) {
110  	if (!init_lock_initialized) {
111  		malloc_mutex_init(&amp;init_lock, &quot;init&quot;, WITNESS_RANK_INIT,
112  		    malloc_mutex_rank_exclusive);
113  	}
114  	init_lock_initialized = true;
115  }
116  #ifdef _MSC_VER
117  #  pragma section(&quot;.CRT$XCU&quot;, read)
118  JEMALLOC_SECTION(&quot;.CRT$XCU&quot;) JEMALLOC_ATTR(used)
119  static const void (WINAPI *init_init_lock)(void) = _init_init_lock;
120  #endif
121  #endif
122  #else
123  static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
124  #endif
125  typedef struct {
126  	void	*p;	&amp;bsol;* Input pointer (as in realloc(p, s)). */
127  	size_t	s;	&amp;bsol;* Request size. */
128  	void	*r;	&amp;bsol;* Result pointer. */
129  } malloc_utrace_t;
130  #ifdef JEMALLOC_UTRACE
131  #  define UTRACE(a, b, c) do {						\
132  	if (unlikely(opt_utrace)) {					\
133  		int utrace_serrno = errno;				\
134  		malloc_utrace_t ut;					\
135  		ut.p = (a);						\
136  		ut.s = (b);						\
137  		ut.r = (c);						\
138  		utrace(&amp;ut, sizeof(ut));				\
139  		errno = utrace_serrno;					\
140  	}								\
141  } while (0)
142  #else
143  #  define UTRACE(a, b, c)
144  #endif
145  static bool had_conf_error = false;
146  static bool	malloc_init_hard_a0(void);
147  static bool	malloc_init_hard(void);
148  bool
149  malloc_initialized(void) {
150  	return (malloc_init_state == malloc_init_initialized);
151  }
152  JEMALLOC_ALWAYS_INLINE bool
153  malloc_init_a0(void) {
154  	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
155  		return malloc_init_hard_a0();
156  	}
157  	return false;
158  }
159  JEMALLOC_ALWAYS_INLINE bool
160  malloc_init(void) {
161  	if (unlikely(!malloc_initialized()) &amp;&amp; malloc_init_hard()) {
162  		return true;
163  	}
164  	return false;
165  }
166  static void *
167  a0ialloc(size_t size, bool zero, bool is_internal) {
168  	if (unlikely(malloc_init_a0())) {
169  		return NULL;
170  	}
171  	return iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,
172  	    is_internal, arena_get(TSDN_NULL, 0, true), true);
173  }
174  static void
175  a0idalloc(void *ptr, bool is_internal) {
176  	idalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);
177  }
178  void *
179  a0malloc(size_t size) {
180  	return a0ialloc(size, false, true);
181  }
182  void
183  a0dalloc(void *ptr) {
184  	a0idalloc(ptr, true);
185  }
186  void *
187  bootstrap_malloc(size_t size) {
188  	if (unlikely(size == 0)) {
189  		size = 1;
190  	}
191  	return a0ialloc(size, false, false);
192  }
193  void *
194  bootstrap_calloc(size_t num, size_t size) {
195  	size_t num_size;
196  	num_size = num * size;
197  	if (unlikely(num_size == 0)) {
198  		assert(num == 0 || size == 0);
199  		num_size = 1;
200  	}
201  	return a0ialloc(num_size, true, false);
202  }
203  void
204  bootstrap_free(void *ptr) {
205  	if (unlikely(ptr == NULL)) {
206  		return;
207  	}
208  	a0idalloc(ptr, false);
209  }
210  void
211  arena_set(unsigned ind, arena_t *arena) {
212  	atomic_store_p(&amp;arenas[ind], arena, ATOMIC_RELEASE);
213  }
214  static void
215  narenas_total_set(unsigned narenas) {
216  	atomic_store_u(&amp;narenas_total, narenas, ATOMIC_RELEASE);
217  }
218  static void
219  narenas_total_inc(void) {
220  	atomic_fetch_add_u(&amp;narenas_total, 1, ATOMIC_RELEASE);
221  }
222  unsigned
223  narenas_total_get(void) {
224  	return atomic_load_u(&amp;narenas_total, ATOMIC_ACQUIRE);
225  }
226  static arena_t *
227  arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
228  	arena_t *arena;
229  	assert(ind &lt;= narenas_total_get());
230  	if (ind &gt;= MALLOCX_ARENA_LIMIT) {
231  		return NULL;
232  	}
233  	if (ind == narenas_total_get()) {
234  		narenas_total_inc();
235  	}
236  	arena = arena_get(tsdn, ind, false);
237  	if (arena != NULL) {
238  		assert(arena_is_auto(arena));
239  		return arena;
240  	}
241  	arena = arena_new(tsdn, ind, extent_hooks);
242  	return arena;
243  }
244  static void
245  arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
246  	if (ind == 0) {
247  		return;
248  	}
249  	if (have_background_thread &amp;&amp; !arena_is_huge(ind)) {
250  		if (background_thread_create(tsdn_tsd(tsdn), ind)) {
251  			malloc_printf(&quot;&lt;jemalloc&gt;: error in background thread &quot;
252  				      &quot;creation for arena %u. Abort.\n&quot;, ind);
253  			abort();
254  		}
255  	}
256  }
257  arena_t *
258  arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
259  	arena_t *arena;
260  	malloc_mutex_lock(tsdn, &amp;arenas_lock);
261  	arena = arena_init_locked(tsdn, ind, extent_hooks);
262  	malloc_mutex_unlock(tsdn, &amp;arenas_lock);
263  	arena_new_create_background_thread(tsdn, ind);
264  	return arena;
265  }
266  static void
267  arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
268  	arena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);
269  	arena_nthreads_inc(arena, internal);
270  	if (internal) {
271  		tsd_iarena_set(tsd, arena);
272  	} else {
273  		tsd_arena_set(tsd, arena);
274  		unsigned shard = atomic_fetch_add_u(&amp;arena-&gt;binshard_next, 1,
275  		    ATOMIC_RELAXED);
276  		tsd_binshards_t *bins = tsd_binshardsp_get(tsd);
277  		for (unsigned i = 0; i &lt; SC_NBINS; i++) {
278  			assert(bin_infos[i].n_shards &gt; 0 &amp;&amp;
279  			    bin_infos[i].n_shards &lt;= BIN_SHARDS_MAX);
280  			bins-&gt;binshard[i] = shard % bin_infos[i].n_shards;
281  		}
282  	}
283  }
284  void
285  arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
286  	arena_t *oldarena, *newarena;
287  	oldarena = arena_get(tsd_tsdn(tsd), oldind, false);
288  	newarena = arena_get(tsd_tsdn(tsd), newind, false);
289  	arena_nthreads_dec(oldarena, false);
290  	arena_nthreads_inc(newarena, false);
291  	tsd_arena_set(tsd, newarena);
292  }
293  static void
294  arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
295  	arena_t *arena;
296  	arena = arena_get(tsd_tsdn(tsd), ind, false);
297  	arena_nthreads_dec(arena, internal);
298  	if (internal) {
299  		tsd_iarena_set(tsd, NULL);
300  	} else {
301  		tsd_arena_set(tsd, NULL);
302  	}
303  }
304  arena_tdata_t *
305  arena_tdata_get_hard(tsd_t *tsd, unsigned ind) {
306  	arena_tdata_t *tdata, *arenas_tdata_old;
307  	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
308  	unsigned narenas_tdata_old, i;
309  	unsigned narenas_tdata = tsd_narenas_tdata_get(tsd);
310  	unsigned narenas_actual = narenas_total_get();
311  	if (arenas_tdata != NULL &amp;&amp; narenas_tdata &lt; narenas_actual) {
312  		arenas_tdata_old = arenas_tdata;
313  		narenas_tdata_old = narenas_tdata;
314  		arenas_tdata = NULL;
315  		narenas_tdata = 0;
316  		tsd_arenas_tdata_set(tsd, arenas_tdata);
317  		tsd_narenas_tdata_set(tsd, narenas_tdata);
318  	} else {
319  		arenas_tdata_old = NULL;
320  		narenas_tdata_old = 0;
321  	}
322  	if (arenas_tdata == NULL) {
323  		bool *arenas_tdata_bypassp = tsd_arenas_tdata_bypassp_get(tsd);
324  		narenas_tdata = (ind &lt; narenas_actual) ? narenas_actual : ind+1;
325  		if (tsd_nominal(tsd) &amp;&amp; !*arenas_tdata_bypassp) {
326  			*arenas_tdata_bypassp = true;
327  			arenas_tdata = (arena_tdata_t *)a0malloc(
328  			    sizeof(arena_tdata_t) * narenas_tdata);
329  			*arenas_tdata_bypassp = false;
330  		}
331  		if (arenas_tdata == NULL) {
332  			tdata = NULL;
333  			goto label_return;
334  		}
335  		assert(tsd_nominal(tsd) &amp;&amp; !*arenas_tdata_bypassp);
336  		tsd_arenas_tdata_set(tsd, arenas_tdata);
337  		tsd_narenas_tdata_set(tsd, narenas_tdata);
338  	}
339  	for (i = 0; i &lt; narenas_actual; i++) {
340  		if (i &lt; narenas_tdata_old) {
341  			ticker_copy(&amp;arenas_tdata[i].decay_ticker,
342  			    &amp;arenas_tdata_old[i].decay_ticker);
343  		} else {
344  			ticker_init(&amp;arenas_tdata[i].decay_ticker,
345  			    DECAY_NTICKS_PER_UPDATE);
346  		}
347  	}
348  	if (narenas_tdata &gt; narenas_actual) {
349  		memset(&amp;arenas_tdata[narenas_actual], 0, sizeof(arena_tdata_t)
350  		    * (narenas_tdata - narenas_actual));
351  	}
352  	tdata = &amp;arenas_tdata[ind];
353  label_return:
354  	if (arenas_tdata_old != NULL) {
355  		a0dalloc(arenas_tdata_old);
356  	}
357  	return tdata;
358  }
359  arena_t *
360  arena_choose_hard(tsd_t *tsd, bool internal) {
361  	arena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);
362  	if (have_percpu_arena &amp;&amp; PERCPU_ARENA_ENABLED(opt_percpu_arena)) {
363  		unsigned choose = percpu_arena_choose();
364  		ret = arena_get(tsd_tsdn(tsd), choose, true);
365  		assert(ret != NULL);
366  		arena_bind(tsd, arena_ind_get(ret), false);
367  		arena_bind(tsd, arena_ind_get(ret), true);
368  		return ret;
369  	}
370  	if (narenas_auto &gt; 1) {
371  		unsigned i, j, choose[2], first_null;
372  		bool is_new_arena[2];
373  		for (j = 0; j &lt; 2; j++) {
374  			choose[j] = 0;
375  			is_new_arena[j] = false;
376  		}
377  		first_null = narenas_auto;
378  		malloc_mutex_lock(tsd_tsdn(tsd), &amp;arenas_lock);
379  		assert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);
380  		for (i = 1; i &lt; narenas_auto; i++) {
381  			if (arena_get(tsd_tsdn(tsd), i, false) != NULL) {
382  				for (j = 0; j &lt; 2; j++) {
383  					if (arena_nthreads_get(arena_get(
384  					    tsd_tsdn(tsd), i, false), !!j) &lt;
385  					    arena_nthreads_get(arena_get(
386  					    tsd_tsdn(tsd), choose[j], false),
387  					    !!j)) {
388  						choose[j] = i;
389  					}
390  				}
391  			} else if (first_null == narenas_auto) {
392  				first_null = i;
393  			}
394  		}
395  		for (j = 0; j &lt; 2; j++) {
396  			if (arena_nthreads_get(arena_get(tsd_tsdn(tsd),
397  			    choose[j], false), !!j) == 0 || first_null ==
398  			    narenas_auto) {
399  				if (!!j == internal) {
400  					ret = arena_get(tsd_tsdn(tsd),
401  					    choose[j], false);
402  				}
403  			} else {
404  				arena_t *arena;
405  				choose[j] = first_null;
406  				arena = arena_init_locked(tsd_tsdn(tsd),
407  				    choose[j],
408  				    (extent_hooks_t *)&amp;extent_hooks_default);
409  				if (arena == NULL) {
410  					malloc_mutex_unlock(tsd_tsdn(tsd),
411  					    &amp;arenas_lock);
412  					return NULL;
413  				}
414  				is_new_arena[j] = true;
415  				if (!!j == internal) {
416  					ret = arena;
417  				}
418  			}
419  			arena_bind(tsd, choose[j], !!j);
420  		}
421  		malloc_mutex_unlock(tsd_tsdn(tsd), &amp;arenas_lock);
422  		for (j = 0; j &lt; 2; j++) {
423  			if (is_new_arena[j]) {
424  				assert(choose[j] &gt; 0);
425  				arena_new_create_background_thread(
426  				    tsd_tsdn(tsd), choose[j]);
427  			}
428  		}
429  	} else {
430  		ret = arena_get(tsd_tsdn(tsd), 0, false);
431  		arena_bind(tsd, 0, false);
432  		arena_bind(tsd, 0, true);
433  	}
434  	return ret;
435  }
436  void
437  iarena_cleanup(tsd_t *tsd) {
438  	arena_t *iarena;
439  	iarena = tsd_iarena_get(tsd);
440  	if (iarena != NULL) {
441  		arena_unbind(tsd, arena_ind_get(iarena), true);
442  	}
443  }
444  void
445  arena_cleanup(tsd_t *tsd) {
446  	arena_t *arena;
447  	arena = tsd_arena_get(tsd);
448  	if (arena != NULL) {
449  		arena_unbind(tsd, arena_ind_get(arena), false);
450  	}
451  }
452  void
453  arenas_tdata_cleanup(tsd_t *tsd) {
454  	arena_tdata_t *arenas_tdata;
455  	*tsd_arenas_tdata_bypassp_get(tsd) = true;
456  	arenas_tdata = tsd_arenas_tdata_get(tsd);
457  	if (arenas_tdata != NULL) {
458  		tsd_arenas_tdata_set(tsd, NULL);
459  		a0dalloc(arenas_tdata);
460  	}
461  }
462  static void
463  stats_print_atexit(void) {
464  	if (config_stats) {
465  		tsdn_t *tsdn;
466  		unsigned narenas, i;
467  		tsdn = tsdn_fetch();
468  		for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
469  			arena_t *arena = arena_get(tsdn, i, false);
470  			if (arena != NULL) {
471  				tcache_t *tcache;
472  				malloc_mutex_lock(tsdn, &amp;arena-&gt;tcache_ql_mtx);
473  				ql_foreach(tcache, &amp;arena-&gt;tcache_ql, link) {
474  					tcache_stats_merge(tsdn, tcache, arena);
475  				}
476  				malloc_mutex_unlock(tsdn,
477  				    &amp;arena-&gt;tcache_ql_mtx);
478  			}
479  		}
480  	}
481  	je_malloc_stats_print(NULL, NULL, opt_stats_print_opts);
482  }
483  JEMALLOC_ALWAYS_INLINE void
484  check_entry_exit_locking(tsdn_t *tsdn) {
485  	if (!config_debug) {
486  		return;
487  	}
488  	if (tsdn_null(tsdn)) {
489  		return;
490  	}
491  	tsd_t *tsd = tsdn_tsd(tsdn);
492  	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
493  	if (reentrancy_level != 0) {
494  		return;
495  	}
496  	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
497  }
498  static char *
499  jemalloc_secure_getenv(const char *name) {
500  #ifdef JEMALLOC_HAVE_SECURE_GETENV
501  	return secure_getenv(name);
502  #else
503  #  ifdef JEMALLOC_HAVE_ISSETUGID
504  	if (issetugid() != 0) {
505  		return NULL;
506  	}
507  #  endif
508  	return getenv(name);
509  #endif
510  }
511  static unsigned
512  malloc_ncpus(void) {
513  	long result;
514  #ifdef _WIN32
515  	SYSTEM_INFO si;
516  	GetSystemInfo(&amp;si);
517  	result = si.dwNumberOfProcessors;
518  #elif defined(JEMALLOC_GLIBC_MALLOC_HOOK) &amp;&amp; defined(CPU_COUNT)
519  	{
520  		cpu_set_t set;
521  		pthread_getaffinity_np(pthread_self(), sizeof(set), &amp;set);
522  		result = CPU_COUNT(&amp;set);
523  	}
524  #else
525  	result = sysconf(_SC_NPROCESSORS_ONLN);
526  #endif
527  	return ((result == -1) ? 1 : (unsigned)result);
528  }
529  static void
530  init_opt_stats_print_opts(const char *v, size_t vlen) {
531  	size_t opts_len = strlen(opt_stats_print_opts);
532  	assert(opts_len &lt;= stats_print_tot_num_options);
533  	for (size_t i = 0; i &lt; vlen; i++) {
534  		switch (v[i]) {
535  #define OPTION(o, v, d, s) case o: break;
536  			STATS_PRINT_OPTIONS
537  #undef OPTION
538  		default: continue;
539  		}
540  		if (strchr(opt_stats_print_opts, v[i]) != NULL) {
541  			continue;
542  		}
543  		opt_stats_print_opts[opts_len++] = v[i];
544  		opt_stats_print_opts[opts_len] = &#x27;\0&#x27;;
545  		assert(opts_len &lt;= stats_print_tot_num_options);
546  	}
547  	assert(opts_len == strlen(opt_stats_print_opts));
548  }
549  static bool
550  malloc_conf_multi_sizes_next(const char **slab_size_segment_cur,
551      size_t *vlen_left, size_t *slab_start, size_t *slab_end, size_t *new_size) {
552  	const char *cur = *slab_size_segment_cur;
553  	char *end;
554  	uintmax_t um;
555  	set_errno(0);
556  	um = malloc_strtoumax(cur, &amp;end, 0);
557  	if (get_errno() != 0 || *end != &#x27;-&#x27;) {
558  		return true;
559  	}
560  	*slab_start = (size_t)um;
561  	cur = end + 1;
562  	um = malloc_strtoumax(cur, &amp;end, 0);
563  	if (get_errno() != 0 || *end != &#x27;:&#x27;) {
564  		return true;
565  	}
566  	*slab_end = (size_t)um;
567  	cur = end + 1;
568  	um = malloc_strtoumax(cur, &amp;end, 0);
569  	if (get_errno() != 0) {
570  		return true;
571  	}
572  	*new_size = (size_t)um;
573  	if (*end == &#x27;|&#x27;) {
574  		end++;
575  	}
576  	*vlen_left -= end - *slab_size_segment_cur;
577  	*slab_size_segment_cur = end;
578  	return false;
579  }
580  static bool
581  malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
582      char const **v_p, size_t *vlen_p) {
583  	bool accept;
584  	const char *opts = *opts_p;
585  	*k_p = opts;
586  	for (accept = false; !accept;) {
587  		switch (*opts) {
588  		case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;: case &#x27;F&#x27;:
589  		case &#x27;G&#x27;: case &#x27;H&#x27;: case &#x27;I&#x27;: case &#x27;J&#x27;: case &#x27;K&#x27;: case &#x27;L&#x27;:
590  		case &#x27;M&#x27;: case &#x27;N&#x27;: case &#x27;O&#x27;: case &#x27;P&#x27;: case &#x27;Q&#x27;: case &#x27;R&#x27;:
591  		case &#x27;S&#x27;: case &#x27;T&#x27;: case &#x27;U&#x27;: case &#x27;V&#x27;: case &#x27;W&#x27;: case &#x27;X&#x27;:
592  		case &#x27;Y&#x27;: case &#x27;Z&#x27;:
593  		case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;: case &#x27;f&#x27;:
594  		case &#x27;g&#x27;: case &#x27;h&#x27;: case &#x27;i&#x27;: case &#x27;j&#x27;: case &#x27;k&#x27;: case &#x27;l&#x27;:
595  		case &#x27;m&#x27;: case &#x27;n&#x27;: case &#x27;o&#x27;: case &#x27;p&#x27;: case &#x27;q&#x27;: case &#x27;r&#x27;:
596  		case &#x27;s&#x27;: case &#x27;t&#x27;: case &#x27;u&#x27;: case &#x27;v&#x27;: case &#x27;w&#x27;: case &#x27;x&#x27;:
597  		case &#x27;y&#x27;: case &#x27;z&#x27;:
598  		case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;:
599  		case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
600  		case &#x27;_&#x27;:
601  			opts++;
602  			break;
603  		case &#x27;:&#x27;:
604  			opts++;
605  			*klen_p = (uintptr_t)opts - 1 - (uintptr_t)*k_p;
606  			*v_p = opts;
607  			accept = true;
608  			break;
609  		case &#x27;\0&#x27;:
610  			if (opts != *opts_p) {
611  				malloc_write(&quot;&lt;jemalloc&gt;: Conf string ends &quot;
612  				    &quot;with key\n&quot;);
613  			}
614  			return true;
615  		default:
616  			malloc_write(&quot;&lt;jemalloc&gt;: Malformed conf string\n&quot;);
617  			return true;
618  		}
619  	}
620  	for (accept = false; !accept;) {
621  		switch (*opts) {
622  		case &#x27;,&#x27;:
623  			opts++;
624  			if (*opts == &#x27;\0&#x27;) {
625  				malloc_write(&quot;&lt;jemalloc&gt;: Conf string ends &quot;
626  				    &quot;with comma\n&quot;);
627  			}
628  			*vlen_p = (uintptr_t)opts - 1 - (uintptr_t)*v_p;
629  			accept = true;
630  			break;
631  		case &#x27;\0&#x27;:
632  			*vlen_p = (uintptr_t)opts - (uintptr_t)*v_p;
633  			accept = true;
634  			break;
635  		default:
636  			opts++;
637  			break;
638  		}
639  	}
640  	*opts_p = opts;
641  	return false;
642  }
643  static void
644  malloc_abort_invalid_conf(void) {
645  	assert(opt_abort_conf);
646  	malloc_printf(&quot;&lt;jemalloc&gt;: Abort (abort_conf:true) on invalid conf &quot;
647  	    &quot;value (see above).\n&quot;);
648  	abort();
649  }
650  static void
651  malloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,
652      size_t vlen) {
653  	malloc_printf(&quot;&lt;jemalloc&gt;: %s: %.*s:%.*s\n&quot;, msg, (int)klen, k,
654  	    (int)vlen, v);
655  	const char *experimental = &quot;experimental_&quot;;
656  	if (strncmp(k, experimental, strlen(experimental)) == 0) {
657  		return;
658  	}
659  	had_conf_error = true;
660  }
661  static void
662  malloc_slow_flag_init(void) {
663  	malloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)
664  	    | (opt_junk_free ? flag_opt_junk_free : 0)
665  	    | (opt_zero ? flag_opt_zero : 0)
666  	    | (opt_utrace ? flag_opt_utrace : 0)
667  	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
668  	malloc_slow = (malloc_slow_flags != 0);
669  }
670  #define MALLOC_CONF_NSOURCES 4
671  static const char *
672  obtain_malloc_conf(unsigned which_source, char buf[PATH_MAX + 1]) {
673  	if (config_debug) {
674  		static unsigned read_source = 0;
675  		assert(read_source++ == which_source);
676  	}
677  	assert(which_source &lt; MALLOC_CONF_NSOURCES);
678  	const char *ret;
679  	switch (which_source) {
680  	case 0:
681  		ret = config_malloc_conf;
682  		break;
683  	case 1:
684  		if (je_malloc_conf != NULL) {
685  			ret = je_malloc_conf;
686  		} else {
687  			ret = NULL;
688  		}
689  		break;
690  	case 2: {
691  		ssize_t linklen = 0;
692  #ifndef _WIN32
693  		int saved_errno = errno;
694  		const char *linkname =
695  #  ifdef JEMALLOC_PREFIX
696  		    &quot;/etc/&quot;JEMALLOC_PREFIX&quot;malloc.conf&quot;
697  #  else
698  		    &quot;/etc/malloc.conf&quot;
699  #  endif
700  		    ;
701  #ifndef JEMALLOC_READLINKAT
702  		linklen = readlink(linkname, buf, PATH_MAX);
703  #else
704  		linklen = readlinkat(AT_FDCWD, linkname, buf, PATH_MAX);
705  #endif
706  		if (linklen == -1) {
707  			linklen = 0;
708  			set_errno(saved_errno);
709  		}
710  #endif
711  		buf[linklen] = &#x27;\0&#x27;;
712  		ret = buf;
713  		break;
714  	} case 3: {
715  		const char *envname =
716  #ifdef JEMALLOC_PREFIX
717  		    JEMALLOC_CPREFIX&quot;MALLOC_CONF&quot;
718  #else
719  		    &quot;MALLOC_CONF&quot;
720  #endif
721  		    ;
722  		if ((ret = jemalloc_secure_getenv(envname)) != NULL) {
723  		} else {
724  			ret = NULL;
725  		}
726  		break;
727  	} default:
728  		not_reached();
729  		ret = NULL;
730  	}
731  	return ret;
732  }
733  static void
734  malloc_conf_init_helper(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS],
735      bool initial_call, const char *opts_cache[MALLOC_CONF_NSOURCES],
736      char buf[PATH_MAX + 1]) {
737  	static const char *opts_explain[MALLOC_CONF_NSOURCES] = {
738  		&quot;string specified via --with-malloc-conf&quot;,
739  		&quot;string pointed to by the global variable malloc_conf&quot;,
740  		&quot;\&quot;name\&quot; of the file referenced by the symbolic link named &quot;
741  		    &quot;/etc/malloc.conf&quot;,
742  		&quot;value of the environment variable MALLOC_CONF&quot;
743  	};
744  	unsigned i;
745  	const char *opts, *k, *v;
746  	size_t klen, vlen;
747  	for (i = 0; i &lt; MALLOC_CONF_NSOURCES; i++) {
748  		if (initial_call) {
749  			opts_cache[i] = obtain_malloc_conf(i, buf);
750  		}
751  		opts = opts_cache[i];
752  		if (!initial_call &amp;&amp; opt_confirm_conf) {
753  			malloc_printf(
754  			    &quot;&lt;jemalloc&gt;: malloc_conf #%u (%s): \&quot;%s\&quot;\n&quot;,
755  			    i + 1, opts_explain[i], opts != NULL ? opts : &quot;&quot;);
756  		}
757  		if (opts == NULL) {
758  			continue;
759  		}
760  		while (*opts != &#x27;\0&#x27; &amp;&amp; !malloc_conf_next(&amp;opts, &amp;k, &amp;klen, &amp;v,
761  		    &amp;vlen)) {
762  #define CONF_ERROR(msg, k, klen, v, vlen)				\
763  			if (!initial_call) {				\
764  				malloc_conf_error(			\
765  				    msg, k, klen, v, vlen);		\
766  				cur_opt_valid = false;			\
767  			}
768  #define CONF_CONTINUE	{						\
769  				if (!initial_call &amp;&amp; opt_confirm_conf	\
770  				    &amp;&amp; cur_opt_valid) {			\
771  					malloc_printf(&quot;&lt;jemalloc&gt;: -- &quot;	\
772  					    &quot;Set conf value: %.*s:%.*s&quot;	\
773  					    &quot;\n&quot;, (int)klen, k,		\
774  					    (int)vlen, v);		\
775  				}					\
776  				continue;				\
777  			}
778  #define CONF_MATCH(n)							\
779  	(sizeof(n)-1 == klen &amp;&amp; strncmp(n, k, klen) == 0)
780  #define CONF_MATCH_VALUE(n)						\
781  	(sizeof(n)-1 == vlen &amp;&amp; strncmp(n, v, vlen) == 0)
782  #define CONF_HANDLE_BOOL(o, n)						\
783  			if (CONF_MATCH(n)) {				\
784  				if (CONF_MATCH_VALUE(&quot;true&quot;)) {		\
785  					o = true;			\
786  				} else if (CONF_MATCH_VALUE(&quot;false&quot;)) {	\
787  					o = false;			\
788  				} else {				\
789  					CONF_ERROR(&quot;Invalid conf value&quot;,\
790  					    k, klen, v, vlen);		\
791  				}					\
792  				CONF_CONTINUE;				\
793  			}
794        JEMALLOC_DIAGNOSTIC_PUSH
795        JEMALLOC_DIAGNOSTIC_IGNORE_TYPE_LIMITS
796  #define CONF_DONT_CHECK_MIN(um, min)	false
797  #define CONF_CHECK_MIN(um, min)	((um) &lt; (min))
798  #define CONF_DONT_CHECK_MAX(um, max)	false
799  #define CONF_CHECK_MAX(um, max)	((um) &gt; (max))
800  #define CONF_HANDLE_T_U(t, o, n, min, max, check_min, check_max, clip)	\
801  			if (CONF_MATCH(n)) {				\
802  				uintmax_t um;				\
803  				char *end;				\
804  									\
805  				set_errno(0);				\
806  				um = malloc_strtoumax(v, &amp;end, 0);	\
807  				if (get_errno() != 0 || (uintptr_t)end -\
808  				    (uintptr_t)v != vlen) {		\
809  					CONF_ERROR(&quot;Invalid conf value&quot;,\
810  					    k, klen, v, vlen);		\
811  				} else if (clip) {			\
812  					if (check_min(um, (t)(min))) {	\
813  						o = (t)(min);		\
814  					} else if (			\
815  					    check_max(um, (t)(max))) {	\
816  						o = (t)(max);		\
817  					} else {			\
818  						o = (t)um;		\
819  					}				\
820  				} else {				\
821  					if (check_min(um, (t)(min)) ||	\
822  					    check_max(um, (t)(max))) {	\
823  						CONF_ERROR(		\
824  						    &quot;Out-of-range &quot;	\
825  						    &quot;conf value&quot;,	\
826  						    k, klen, v, vlen);	\
827  					} else {			\
828  						o = (t)um;		\
829  					}				\
830  				}					\
831  				CONF_CONTINUE;				\
832  			}
833  #define CONF_HANDLE_UNSIGNED(o, n, min, max, check_min, check_max,	\
834      clip)								\
835  			CONF_HANDLE_T_U(unsigned, o, n, min, max,	\
836  			    check_min, check_max, clip)
837  #define CONF_HANDLE_SIZE_T(o, n, min, max, check_min, check_max, clip)	\
838  			CONF_HANDLE_T_U(size_t, o, n, min, max,		\
839  			    check_min, check_max, clip)
840  #define CONF_HANDLE_SSIZE_T(o, n, min, max)				\
841  			if (CONF_MATCH(n)) {				\
842  				long l;					\
843  				char *end;				\
844  									\
845  				set_errno(0);				\
846  				l = strtol(v, &amp;end, 0);			\
847  				if (get_errno() != 0 || (uintptr_t)end -\
848  				    (uintptr_t)v != vlen) {		\
849  					CONF_ERROR(&quot;Invalid conf value&quot;,\
850  					    k, klen, v, vlen);		\
851  				} else if (l &lt; (ssize_t)(min) || l &gt;	\
852  				    (ssize_t)(max)) {			\
853  					CONF_ERROR(			\
854  					    &quot;Out-of-range conf value&quot;,	\
855  					    k, klen, v, vlen);		\
856  				} else {				\
857  					o = l;				\
858  				}					\
859  				CONF_CONTINUE;				\
860  			}
861  #define CONF_HANDLE_CHAR_P(o, n, d)					\
862  			if (CONF_MATCH(n)) {				\
863  				size_t cpylen = (vlen &lt;=		\
864  				    sizeof(o)-1) ? vlen :		\
865  				    sizeof(o)-1;			\
866  				strncpy(o, v, cpylen);			\
867  				o[cpylen] = &#x27;\0&#x27;;			\
868  				CONF_CONTINUE;				\
869  			}
870  			bool cur_opt_valid = true;
871  			CONF_HANDLE_BOOL(opt_confirm_conf, &quot;confirm_conf&quot;)
872  			if (initial_call) {
873  				continue;
874  			}
875  			CONF_HANDLE_BOOL(opt_abort, &quot;abort&quot;)
876  			CONF_HANDLE_BOOL(opt_abort_conf, &quot;abort_conf&quot;)
877  			if (strncmp(&quot;metadata_thp&quot;, k, klen) == 0) {
878  				int i;
879  				bool match = false;
880  				for (i = 0; i &lt; metadata_thp_mode_limit; i++) {
881  					if (strncmp(metadata_thp_mode_names[i],
882  					    v, vlen) == 0) {
883  						opt_metadata_thp = i;
884  						match = true;
885  						break;
886  					}
887  				}
888  				if (!match) {
889  					CONF_ERROR(&quot;Invalid conf value&quot;,
890  					    k, klen, v, vlen);
891  				}
892  				CONF_CONTINUE;
893  			}
894  			CONF_HANDLE_BOOL(opt_retain, &quot;retain&quot;)
895  			if (strncmp(&quot;dss&quot;, k, klen) == 0) {
896  				int i;
897  				bool match = false;
898  				for (i = 0; i &lt; dss_prec_limit; i++) {
899  					if (strncmp(dss_prec_names[i], v, vlen)
900  					    == 0) {
901  						if (extent_dss_prec_set(i)) {
902  							CONF_ERROR(
903  							    &quot;Error setting dss&quot;,
904  							    k, klen, v, vlen);
905  						} else {
906  							opt_dss =
907  							    dss_prec_names[i];
908  							match = true;
909  							break;
910  						}
911  					}
912  				}
913  				if (!match) {
914  					CONF_ERROR(&quot;Invalid conf value&quot;,
915  					    k, klen, v, vlen);
916  				}
917  				CONF_CONTINUE;
918  			}
919  			CONF_HANDLE_UNSIGNED(opt_narenas, &quot;narenas&quot;, 1,
920  			    UINT_MAX, CONF_CHECK_MIN, CONF_DONT_CHECK_MAX,
921  			    false)
922  			if (CONF_MATCH(&quot;bin_shards&quot;)) {
923  				const char *bin_shards_segment_cur = v;
924  				size_t vlen_left = vlen;
925  				do {
926  					size_t size_start;
927  					size_t size_end;
928  					size_t nshards;
929  					bool err = malloc_conf_multi_sizes_next(
930  					    &amp;bin_shards_segment_cur, &amp;vlen_left,
931  					    &amp;size_start, &amp;size_end, &amp;nshards);
932  					if (err || bin_update_shard_size(
933  					    bin_shard_sizes, size_start,
934  					    size_end, nshards)) {
935  						CONF_ERROR(
936  						    &quot;Invalid settings for &quot;
937  						    &quot;bin_shards&quot;, k, klen, v,
938  						    vlen);
939  						break;
940  					}
941  				} while (vlen_left &gt; 0);
942  				CONF_CONTINUE;
943  			}
944  			CONF_HANDLE_SSIZE_T(opt_dirty_decay_ms,
945  			    &quot;dirty_decay_ms&quot;, -1, NSTIME_SEC_MAX * KQU(1000) &lt;
946  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
947  			    SSIZE_MAX);
948  			CONF_HANDLE_SSIZE_T(opt_muzzy_decay_ms,
949  			    &quot;muzzy_decay_ms&quot;, -1, NSTIME_SEC_MAX * KQU(1000) &lt;
950  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
951  			    SSIZE_MAX);
952  			CONF_HANDLE_BOOL(opt_stats_print, &quot;stats_print&quot;)
953  			if (CONF_MATCH(&quot;stats_print_opts&quot;)) {
954  				init_opt_stats_print_opts(v, vlen);
955  				CONF_CONTINUE;
956  			}
957  			if (config_fill) {
958  				if (CONF_MATCH(&quot;junk&quot;)) {
959  					if (CONF_MATCH_VALUE(&quot;true&quot;)) {
960  						opt_junk = &quot;true&quot;;
961  						opt_junk_alloc = opt_junk_free =
962  						    true;
963  					} else if (CONF_MATCH_VALUE(&quot;false&quot;)) {
964  						opt_junk = &quot;false&quot;;
965  						opt_junk_alloc = opt_junk_free =
966  						    false;
967  					} else if (CONF_MATCH_VALUE(&quot;alloc&quot;)) {
968  						opt_junk = &quot;alloc&quot;;
969  						opt_junk_alloc = true;
970  						opt_junk_free = false;
971  					} else if (CONF_MATCH_VALUE(&quot;free&quot;)) {
972  						opt_junk = &quot;free&quot;;
973  						opt_junk_alloc = false;
974  						opt_junk_free = true;
975  					} else {
976  						CONF_ERROR(
977  						    &quot;Invalid conf value&quot;,
978  						    k, klen, v, vlen);
979  					}
980  					CONF_CONTINUE;
981  				}
982  				CONF_HANDLE_BOOL(opt_zero, &quot;zero&quot;)
983  			}
984  			if (config_utrace) {
985  				CONF_HANDLE_BOOL(opt_utrace, &quot;utrace&quot;)
986  			}
987  			if (config_xmalloc) {
988  				CONF_HANDLE_BOOL(opt_xmalloc, &quot;xmalloc&quot;)
989  			}
990  			CONF_HANDLE_BOOL(opt_tcache, &quot;tcache&quot;)
991  			CONF_HANDLE_SSIZE_T(opt_lg_tcache_max, &quot;lg_tcache_max&quot;,
992  			    -1, (sizeof(size_t) &lt;&lt; 3) - 1)
993  			CONF_HANDLE_SIZE_T(opt_oversize_threshold,
994  			    &quot;oversize_threshold&quot;, 0, SC_LARGE_MAXCLASS,
995  			    CONF_DONT_CHECK_MIN, CONF_CHECK_MAX, false)
996  			CONF_HANDLE_SIZE_T(opt_lg_extent_max_active_fit,
997  			    &quot;lg_extent_max_active_fit&quot;, 0,
998  			    (sizeof(size_t) &lt;&lt; 3), CONF_DONT_CHECK_MIN,
999  			    CONF_CHECK_MAX, false)
1000  			if (strncmp(&quot;percpu_arena&quot;, k, klen) == 0) {
1001  				bool match = false;
1002  				for (int i = percpu_arena_mode_names_base; i &lt;
1003  				    percpu_arena_mode_names_limit; i++) {
1004  					if (strncmp(percpu_arena_mode_names[i],
1005  					    v, vlen) == 0) {
1006  						if (!have_percpu_arena) {
1007  							CONF_ERROR(
1008  							    &quot;No getcpu support&quot;,
1009  							    k, klen, v, vlen);
1010  						}
1011  						opt_percpu_arena = i;
1012  						match = true;
1013  						break;
1014  					}
1015  				}
1016  				if (!match) {
1017  					CONF_ERROR(&quot;Invalid conf value&quot;,
1018  					    k, klen, v, vlen);
1019  				}
1020  				CONF_CONTINUE;
1021  			}
1022  			CONF_HANDLE_BOOL(opt_background_thread,
1023  			    &quot;background_thread&quot;);
1024  			CONF_HANDLE_SIZE_T(opt_max_background_threads,
1025  					   &quot;max_background_threads&quot;, 1,
1026  					   opt_max_background_threads,
1027  					   CONF_CHECK_MIN, CONF_CHECK_MAX,
1028  					   true);
1029  			if (CONF_MATCH(&quot;slab_sizes&quot;)) {
1030  				bool err;
1031  				const char *slab_size_segment_cur = v;
1032  				size_t vlen_left = vlen;
1033  				do {
1034  					size_t slab_start;
1035  					size_t slab_end;
1036  					size_t pgs;
1037  					err = malloc_conf_multi_sizes_next(
1038  					    &amp;slab_size_segment_cur,
1039  					    &amp;vlen_left, &amp;slab_start, &amp;slab_end,
1040  					    &amp;pgs);
1041  					if (!err) {
1042  						sc_data_update_slab_size(
1043  						    sc_data, slab_start,
1044  						    slab_end, (int)pgs);
1045  					} else {
1046  						CONF_ERROR(&quot;Invalid settings &quot;
1047  						    &quot;for slab_sizes&quot;,
1048  						    k, klen, v, vlen);
1049  					}
1050  				} while (!err &amp;&amp; vlen_left &gt; 0);
1051  				CONF_CONTINUE;
1052  			}
1053  			if (config_prof) {
1054  				CONF_HANDLE_BOOL(opt_prof, &quot;prof&quot;)
1055  				CONF_HANDLE_CHAR_P(opt_prof_prefix,
1056  				    &quot;prof_prefix&quot;, &quot;jeprof&quot;)
1057  				CONF_HANDLE_BOOL(opt_prof_active, &quot;prof_active&quot;)
1058  				CONF_HANDLE_BOOL(opt_prof_thread_active_init,
1059  				    &quot;prof_thread_active_init&quot;)
1060  				CONF_HANDLE_SIZE_T(opt_lg_prof_sample,
1061  				    &quot;lg_prof_sample&quot;, 0, (sizeof(uint64_t) &lt;&lt; 3)
1062  				    - 1, CONF_DONT_CHECK_MIN, CONF_CHECK_MAX,
1063  				    true)
1064  				CONF_HANDLE_BOOL(opt_prof_accum, &quot;prof_accum&quot;)
1065  				CONF_HANDLE_SSIZE_T(opt_lg_prof_interval,
1066  				    &quot;lg_prof_interval&quot;, -1,
1067  				    (sizeof(uint64_t) &lt;&lt; 3) - 1)
1068  				CONF_HANDLE_BOOL(opt_prof_gdump, &quot;prof_gdump&quot;)
1069  				CONF_HANDLE_BOOL(opt_prof_final, &quot;prof_final&quot;)
1070  				CONF_HANDLE_BOOL(opt_prof_leak, &quot;prof_leak&quot;)
1071  				CONF_HANDLE_BOOL(opt_prof_log, &quot;prof_log&quot;)
1072  			}
1073  			if (config_log) {
1074  				if (CONF_MATCH(&quot;log&quot;)) {
1075  					size_t cpylen = (
1076  					    vlen &lt;= sizeof(log_var_names) ?
1077  					    vlen : sizeof(log_var_names) - 1);
1078  					strncpy(log_var_names, v, cpylen);
1079  					log_var_names[cpylen] = &#x27;\0&#x27;;
1080  					CONF_CONTINUE;
1081  				}
1082  			}
1083  			if (CONF_MATCH(&quot;thp&quot;)) {
1084  				bool match = false;
1085  				for (int i = 0; i &lt; thp_mode_names_limit; i++) {
1086  					if (strncmp(thp_mode_names[i],v, vlen)
1087  					    == 0) {
1088  						if (!have_madvise_huge) {
1089  							CONF_ERROR(
1090  							    &quot;No THP support&quot;,
1091  							    k, klen, v, vlen);
1092  						}
1093  						opt_thp = i;
1094  						match = true;
1095  						break;
1096  					}
1097  				}
1098  				if (!match) {
1099  					CONF_ERROR(&quot;Invalid conf value&quot;,
1100  					    k, klen, v, vlen);
1101  				}
1102  				CONF_CONTINUE;
1103  			}
1104  			CONF_ERROR(&quot;Invalid conf pair&quot;, k, klen, v, vlen);
1105  #undef CONF_ERROR
1106  #undef CONF_CONTINUE
1107  #undef CONF_MATCH
1108  #undef CONF_MATCH_VALUE
1109  #undef CONF_HANDLE_BOOL
1110  #undef CONF_DONT_CHECK_MIN
1111  #undef CONF_CHECK_MIN
1112  #undef CONF_DONT_CHECK_MAX
1113  #undef CONF_CHECK_MAX
1114  #undef CONF_HANDLE_T_U
1115  #undef CONF_HANDLE_UNSIGNED
1116  #undef CONF_HANDLE_SIZE_T
1117  #undef CONF_HANDLE_SSIZE_T
1118  #undef CONF_HANDLE_CHAR_P
1119      JEMALLOC_DIAGNOSTIC_POP
1120  		}
1121  		if (opt_abort_conf &amp;&amp; had_conf_error) {
1122  			malloc_abort_invalid_conf();
1123  		}
1124  	}
1125  	atomic_store_b(&amp;log_init_done, true, ATOMIC_RELEASE);
1126  }
1127  static void
1128  malloc_conf_init(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS]) {
1129  	const char *opts_cache[MALLOC_CONF_NSOURCES] = {NULL, NULL, NULL, NULL};
1130  	char buf[PATH_MAX + 1];
1131  	malloc_conf_init_helper(NULL, NULL, true, opts_cache, buf);
1132  	malloc_conf_init_helper(sc_data, bin_shard_sizes, false, opts_cache,
1133  	    NULL);
1134  }
1135  #undef MALLOC_CONF_NSOURCES
1136  static bool
1137  malloc_init_hard_needed(void) {
1138  	if (malloc_initialized() || (IS_INITIALIZER &amp;&amp; malloc_init_state ==
1139  	    malloc_init_recursible)) {
1140  		return false;
1141  	}
1142  #ifdef JEMALLOC_THREADED_INIT
1143  	if (malloc_initializer != NO_INITIALIZER &amp;&amp; !IS_INITIALIZER) {
1144  		spin_t spinner = SPIN_INITIALIZER;
1145  		do {
1146  			malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1147  			spin_adaptive(&amp;spinner);
1148  			malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1149  		} while (!malloc_initialized());
1150  		return false;
1151  	}
1152  #endif
1153  	return true;
1154  }
1155  static bool
1156  malloc_init_hard_a0_locked() {
1157  	malloc_initializer = INITIALIZER;
1158  	JEMALLOC_DIAGNOSTIC_PUSH
1159  	JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS
1160  	sc_data_t sc_data = {0};
1161  	JEMALLOC_DIAGNOSTIC_POP
1162  	sc_boot(&amp;sc_data);
1163  	unsigned bin_shard_sizes[SC_NBINS];
1164  	bin_shard_sizes_boot(bin_shard_sizes);
1165  	if (config_prof) {
1166  		prof_boot0();
1167  	}
1168  	malloc_conf_init(&amp;sc_data, bin_shard_sizes);
1169  	sz_boot(&amp;sc_data);
1170  	bin_boot(&amp;sc_data, bin_shard_sizes);
1171  	if (opt_stats_print) {
1172  		if (atexit(stats_print_atexit) != 0) {
1173  			malloc_write(&quot;&lt;jemalloc&gt;: Error in atexit()\n&quot;);
1174  			if (opt_abort) {
1175  				abort();
1176  			}
1177  		}
1178  	}
1179  	if (pages_boot()) {
1180  		return true;
1181  	}
1182  	if (base_boot(TSDN_NULL)) {
1183  		return true;
1184  	}
1185  	if (extent_boot()) {
1186  		return true;
1187  	}
1188  	if (ctl_boot()) {
1189  		return true;
1190  	}
1191  	if (config_prof) {
1192  		prof_boot1();
1193  	}
1194  	arena_boot(&amp;sc_data);
1195  	if (tcache_boot(TSDN_NULL)) {
1196  		return true;
1197  	}
1198  	if (malloc_mutex_init(&amp;arenas_lock, &quot;arenas&quot;, WITNESS_RANK_ARENAS,
1199  	    malloc_mutex_rank_exclusive)) {
1200  		return true;
1201  	}
1202  	hook_boot();
1203  	narenas_auto = 1;
1204  	manual_arena_base = narenas_auto + 1;
1205  	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
1206  	if (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&amp;extent_hooks_default)
1207  	    == NULL) {
1208  		return true;
1209  	}
1210  	a0 = arena_get(TSDN_NULL, 0, false);
1211  	malloc_init_state = malloc_init_a0_initialized;
1212  	return false;
1213  }
1214  static bool
1215  malloc_init_hard_a0(void) {
1216  	bool ret;
1217  	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1218  	ret = malloc_init_hard_a0_locked();
1219  	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1220  	return ret;
1221  }
1222  static bool
1223  malloc_init_hard_recursible(void) {
1224  	malloc_init_state = malloc_init_recursible;
1225  	ncpus = malloc_ncpus();
1226  #if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) &amp;&amp; !defined(JEMALLOC_MUTEX_INIT_CB) \
1227      &amp;&amp; !defined(JEMALLOC_ZONE) &amp;&amp; !defined(_WIN32) &amp;&amp; \
1228      !defined(__native_client__))
1229  	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
1230  	    jemalloc_postfork_child) != 0) {
1231  		malloc_write(&quot;&lt;jemalloc&gt;: Error in pthread_atfork()\n&quot;);
1232  		if (opt_abort) {
1233  			abort();
1234  		}
1235  		return true;
1236  	}
1237  #endif
1238  	if (background_thread_boot0()) {
1239  		return true;
1240  	}
1241  	return false;
1242  }
1243  static unsigned
1244  malloc_narenas_default(void) {
1245  	assert(ncpus &gt; 0);
1246  	if (ncpus &gt; 1) {
1247  		return ncpus &lt;&lt; 2;
1248  	} else {
1249  		return 1;
1250  	}
1251  }
1252  static percpu_arena_mode_t
1253  percpu_arena_as_initialized(percpu_arena_mode_t mode) {
1254  	assert(!malloc_initialized());
1255  	assert(mode &lt;= percpu_arena_disabled);
1256  	if (mode != percpu_arena_disabled) {
1257  		mode += percpu_arena_mode_enabled_base;
1258  	}
1259  	return mode;
1260  }
1261  static bool
1262  malloc_init_narenas(void) {
1263  	assert(ncpus &gt; 0);
1264  	if (opt_percpu_arena != percpu_arena_disabled) {
1265  		if (!have_percpu_arena || malloc_getcpu() &lt; 0) {
1266  			opt_percpu_arena = percpu_arena_disabled;
1267  			malloc_printf(&quot;&lt;jemalloc&gt;: perCPU arena getcpu() not &quot;
1268  			    &quot;available. Setting narenas to %u.\n&quot;, opt_narenas ?
1269  			    opt_narenas : malloc_narenas_default());
1270  			if (opt_abort) {
1271  				abort();
1272  			}
1273  		} else {
1274  			if (ncpus &gt;= MALLOCX_ARENA_LIMIT) {
1275  				malloc_printf(&quot;&lt;jemalloc&gt;: narenas w/ percpu&quot;
1276  				    &quot;arena beyond limit (%d)\n&quot;, ncpus);
1277  				if (opt_abort) {
1278  					abort();
1279  				}
1280  				return true;
1281  			}
1282  			if (percpu_arena_as_initialized(opt_percpu_arena) ==
1283  			    per_phycpu_arena &amp;&amp; ncpus % 2 != 0) {
1284  				malloc_printf(&quot;&lt;jemalloc&gt;: invalid &quot;
1285  				    &quot;configuration -- per physical CPU arena &quot;
1286  				    &quot;with odd number (%u) of CPUs (no hyper &quot;
1287  				    &quot;threading?).\n&quot;, ncpus);
1288  				if (opt_abort)
1289  					abort();
1290  			}
1291  			unsigned n = percpu_arena_ind_limit(
1292  			    percpu_arena_as_initialized(opt_percpu_arena));
1293  			if (opt_narenas &lt; n) {
1294  				opt_narenas = n;
1295  			}
1296  		}
1297  	}
1298  	if (opt_narenas == 0) {
1299  		opt_narenas = malloc_narenas_default();
1300  	}
1301  	assert(opt_narenas &gt; 0);
1302  	narenas_auto = opt_narenas;
1303  	if (narenas_auto &gt;= MALLOCX_ARENA_LIMIT) {
1304  		narenas_auto = MALLOCX_ARENA_LIMIT - 1;
1305  		malloc_printf(&quot;&lt;jemalloc&gt;: Reducing narenas to limit (%d)\n&quot;,
1306  		    narenas_auto);
1307  	}
1308  	narenas_total_set(narenas_auto);
1309  	if (arena_init_huge()) {
1310  		narenas_total_inc();
1311  	}
1312  	manual_arena_base = narenas_total_get();
1313  	return false;
1314  }
1315  static void
1316  malloc_init_percpu(void) {
1317  	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
1318  }
1319  static bool
1320  malloc_init_hard_finish(void) {
1321  	if (malloc_mutex_boot()) {
1322  		return true;
1323  	}
1324  	malloc_init_state = malloc_init_initialized;
1325  	malloc_slow_flag_init();
1326  	return false;
1327  }
1328  static void
1329  malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
1330  	malloc_mutex_assert_owner(tsdn, &amp;init_lock);
1331  	malloc_mutex_unlock(tsdn, &amp;init_lock);
1332  	if (reentrancy_set) {
1333  		assert(!tsdn_null(tsdn));
1334  		tsd_t *tsd = tsdn_tsd(tsdn);
1335  		assert(tsd_reentrancy_level_get(tsd) &gt; 0);
1336  		post_reentrancy(tsd);
1337  	}
1338  }
1339  static bool
1340  malloc_init_hard(void) {
1341  	tsd_t *tsd;
1342  #if defined(_WIN32) &amp;&amp; _WIN32_WINNT &lt; 0x0600
1343  	_init_init_lock();
1344  #endif
1345  	malloc_mutex_lock(TSDN_NULL, &amp;init_lock);
1346  #define UNLOCK_RETURN(tsdn, ret, reentrancy)		\
1347  	malloc_init_hard_cleanup(tsdn, reentrancy);	\
1348  	return ret;
1349  	if (!malloc_init_hard_needed()) {
1350  		UNLOCK_RETURN(TSDN_NULL, false, false)
1351  	}
1352  	if (malloc_init_state != malloc_init_a0_initialized &amp;&amp;
1353  	    malloc_init_hard_a0_locked()) {
1354  		UNLOCK_RETURN(TSDN_NULL, true, false)
1355  	}
1356  	malloc_mutex_unlock(TSDN_NULL, &amp;init_lock);
1357  	tsd = malloc_tsd_boot0();
1358  	if (tsd == NULL) {
1359  		return true;
1360  	}
1361  	if (malloc_init_hard_recursible()) {
1362  		return true;
1363  	}
1364  	malloc_mutex_lock(tsd_tsdn(tsd), &amp;init_lock);
1365  	pre_reentrancy(tsd, NULL);
1366  	if (malloc_init_narenas() || background_thread_boot1(tsd_tsdn(tsd))) {
1367  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1368  	}
1369  	if (config_prof &amp;&amp; prof_boot2(tsd)) {
1370  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1371  	}
1372  	malloc_init_percpu();
1373  	if (malloc_init_hard_finish()) {
1374  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1375  	}
1376  	post_reentrancy(tsd);
1377  	malloc_mutex_unlock(tsd_tsdn(tsd), &amp;init_lock);
1378  	witness_assert_lockless(witness_tsd_tsdn(
1379  	    tsd_witness_tsdp_get_unsafe(tsd)));
1380  	malloc_tsd_boot1();
1381  	tsd = tsd_fetch();
1382  	if (opt_background_thread) {
1383  		assert(have_background_thread);
1384  		background_thread_ctl_init(tsd_tsdn(tsd));
1385  		if (background_thread_create(tsd, 0)) {
1386  			return true;
1387  		}
1388  	}
1389  #undef UNLOCK_RETURN
1390  	return false;
1391  }
1392  typedef struct static_opts_s static_opts_t;
1393  struct static_opts_s {
1394  	bool may_overflow;
1395  	bool bump_empty_aligned_alloc;
1396  	bool assert_nonempty_alloc;
1397  	bool null_out_result_on_error;
1398  	bool set_errno_on_error;
1399  	size_t min_alignment;
1400  	const char *oom_string;
1401  	const char *invalid_alignment_string;
1402  	bool slow;
1403  	bool usize;
1404  };
1405  JEMALLOC_ALWAYS_INLINE void
1406  static_opts_init(static_opts_t *static_opts) {
1407  	static_opts-&gt;may_overflow = false;
1408  	static_opts-&gt;bump_empty_aligned_alloc = false;
1409  	static_opts-&gt;assert_nonempty_alloc = false;
1410  	static_opts-&gt;null_out_result_on_error = false;
1411  	static_opts-&gt;set_errno_on_error = false;
1412  	static_opts-&gt;min_alignment = 0;
1413  	static_opts-&gt;oom_string = &quot;&quot;;
1414  	static_opts-&gt;invalid_alignment_string = &quot;&quot;;
1415  	static_opts-&gt;slow = false;
1416  	static_opts-&gt;usize = false;
1417  }
1418  #define TCACHE_IND_NONE ((unsigned)-1)
1419  #define TCACHE_IND_AUTOMATIC ((unsigned)-2)
1420  #define ARENA_IND_AUTOMATIC ((unsigned)-1)
1421  typedef struct dynamic_opts_s dynamic_opts_t;
1422  struct dynamic_opts_s {
1423  	void **result;
1424  	size_t usize;
1425  	size_t num_items;
1426  	size_t item_size;
1427  	size_t alignment;
1428  	bool zero;
1429  	unsigned tcache_ind;
1430  	unsigned arena_ind;
1431  };
1432  JEMALLOC_ALWAYS_INLINE void
1433  dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
1434  	dynamic_opts-&gt;result = NULL;
1435  	dynamic_opts-&gt;usize = 0;
1436  	dynamic_opts-&gt;num_items = 0;
1437  	dynamic_opts-&gt;item_size = 0;
1438  	dynamic_opts-&gt;alignment = 0;
1439  	dynamic_opts-&gt;zero = false;
1440  	dynamic_opts-&gt;tcache_ind = TCACHE_IND_AUTOMATIC;
1441  	dynamic_opts-&gt;arena_ind = ARENA_IND_AUTOMATIC;
1442  }
1443  JEMALLOC_ALWAYS_INLINE void *
1444  imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1445      size_t size, size_t usize, szind_t ind) {
1446  	tcache_t *tcache;
1447  	arena_t *arena;
1448  	if (dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC) {
1449  		if (likely(!sopts-&gt;slow)) {
1450  			tcache = tsd_tcachep_get(tsd);
1451  			assert(tcache == tcache_get(tsd));
1452  		} else {
1453  			tcache = tcache_get(tsd);
1454  		}
1455  	} else if (dopts-&gt;tcache_ind == TCACHE_IND_NONE) {
1456  		tcache = NULL;
1457  	} else {
1458  		tcache = tcaches_get(tsd, dopts-&gt;tcache_ind);
1459  	}
1460  	if (dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC) {
1461  		arena = NULL;
1462  	} else {
1463  		arena = arena_get(tsd_tsdn(tsd), dopts-&gt;arena_ind, true);
1464  	}
1465  	if (unlikely(dopts-&gt;alignment != 0)) {
1466  		return ipalloct(tsd_tsdn(tsd), usize, dopts-&gt;alignment,
1467  		    dopts-&gt;zero, tcache, arena);
1468  	}
1469  	return iallocztm(tsd_tsdn(tsd), size, ind, dopts-&gt;zero, tcache, false,
1470  	    arena, sopts-&gt;slow);
1471  }
1472  JEMALLOC_ALWAYS_INLINE void *
1473  imalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1474      size_t usize, szind_t ind) {
1475  	void *ret;
1476  	szind_t ind_large;
1477  	size_t bumped_usize = usize;
1478  	if (usize &lt;= SC_SMALL_MAXCLASS) {
1479  		assert(((dopts-&gt;alignment == 0) ?
1480  		    sz_s2u(SC_LARGE_MINCLASS) :
1481  		    sz_sa2u(SC_LARGE_MINCLASS, dopts-&gt;alignment))
1482  			== SC_LARGE_MINCLASS);
1483  		ind_large = sz_size2index(SC_LARGE_MINCLASS);
1484  		bumped_usize = sz_s2u(SC_LARGE_MINCLASS);
1485  		ret = imalloc_no_sample(sopts, dopts, tsd, bumped_usize,
1486  		    bumped_usize, ind_large);
1487  		if (unlikely(ret == NULL)) {
1488  			return NULL;
1489  		}
1490  		arena_prof_promote(tsd_tsdn(tsd), ret, usize);
1491  	} else {
1492  		ret = imalloc_no_sample(sopts, dopts, tsd, usize, usize, ind);
1493  	}
1494  	return ret;
1495  }
1496  JEMALLOC_ALWAYS_INLINE bool
1497  compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
1498      size_t *size) {
1499  	if (!may_overflow) {
1500  		assert(dopts-&gt;num_items == 1);
1501  		*size = dopts-&gt;item_size;
1502  		return false;
1503  	}
1504  	static const size_t high_bits = SIZE_T_MAX &lt;&lt; (sizeof(size_t) * 8 / 2);
1505  	*size = dopts-&gt;item_size * dopts-&gt;num_items;
1506  	if (unlikely(*size == 0)) {
1507  		return (dopts-&gt;num_items != 0 &amp;&amp; dopts-&gt;item_size != 0);
1508  	}
1509  	if (likely((high_bits &amp; (dopts-&gt;num_items | dopts-&gt;item_size)) == 0)) {
1510  		return false;
1511  	}
1512  	if (likely(*size / dopts-&gt;item_size == dopts-&gt;num_items)) {
1513  		return false;
1514  	}
1515  	return true;
1516  }
1517  JEMALLOC_ALWAYS_INLINE int
1518  imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
1519  	void *allocation = NULL;
1520  	size_t size = 0;
1521  	szind_t ind = 0;
1522  	size_t usize = 0;
1523  	int8_t reentrancy_level;
1524  	if (unlikely(compute_size_with_overflow(sopts-&gt;may_overflow, dopts,
1525  	    &amp;size))) {
1526  		goto label_oom;
1527  	}
1528  	if (unlikely(dopts-&gt;alignment &lt; sopts-&gt;min_alignment
1529  	    || (dopts-&gt;alignment &amp; (dopts-&gt;alignment - 1)) != 0)) {
1530  		goto label_invalid_alignment;
1531  	}
1532  	if (dopts-&gt;alignment == 0) {
1533  		ind = sz_size2index(size);
1534  		if (unlikely(ind &gt;= SC_NSIZES)) {
1535  			goto label_oom;
1536  		}
1537  		if (config_stats || (config_prof &amp;&amp; opt_prof) || sopts-&gt;usize) {
1538  			usize = sz_index2size(ind);
1539  			dopts-&gt;usize = usize;
1540  			assert(usize &gt; 0 &amp;&amp; usize
1541  			    &lt;= SC_LARGE_MAXCLASS);
1542  		}
1543  	} else {
1544  		if (sopts-&gt;bump_empty_aligned_alloc) {
1545  			if (unlikely(size == 0)) {
1546  				size = 1;
1547  			}
1548  		}
1549  		usize = sz_sa2u(size, dopts-&gt;alignment);
1550  		dopts-&gt;usize = usize;
1551  		if (unlikely(usize == 0
1552  		    || usize &gt; SC_LARGE_MAXCLASS)) {
1553  			goto label_oom;
1554  		}
1555  	}
1556  	if (sopts-&gt;assert_nonempty_alloc) {
1557  		assert (size != 0);
1558  	}
1559  	check_entry_exit_locking(tsd_tsdn(tsd));
1560  	reentrancy_level = tsd_reentrancy_level_get(tsd);
1561  	if (sopts-&gt;slow &amp;&amp; unlikely(reentrancy_level &gt; 0)) {
1562  		assert(dopts-&gt;tcache_ind == TCACHE_IND_AUTOMATIC ||
1563  		    dopts-&gt;tcache_ind == TCACHE_IND_NONE);
1564  		assert(dopts-&gt;arena_ind == ARENA_IND_AUTOMATIC);
1565  		dopts-&gt;tcache_ind = TCACHE_IND_NONE;
1566  		dopts-&gt;arena_ind = 0;
1567  	}
1568  	if (config_prof &amp;&amp; opt_prof) {
1569  		prof_tctx_t *tctx = prof_alloc_prep(
1570  		    tsd, usize, prof_active_get_unlocked(), true);
1571  		alloc_ctx_t alloc_ctx;
1572  		if (likely((uintptr_t)tctx == (uintptr_t)1U)) {
1573  			alloc_ctx.slab = (usize
1574  			    &lt;= SC_SMALL_MAXCLASS);
1575  			allocation = imalloc_no_sample(
1576  			    sopts, dopts, tsd, usize, usize, ind);
1577  		} else if ((uintptr_t)tctx &gt; (uintptr_t)1U) {
1578  			allocation = imalloc_sample(
1579  			    sopts, dopts, tsd, usize, ind);
1580  			alloc_ctx.slab = false;
1581  		} else {
1582  			allocation = NULL;
1583  		}
1584  		if (unlikely(allocation == NULL)) {
1585  			prof_alloc_rollback(tsd, tctx, true);
1586  			goto label_oom;
1587  		}
1588  		prof_malloc(tsd_tsdn(tsd), allocation, usize, &amp;alloc_ctx, tctx);
1589  	} else {
1590  		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,
1591  		    ind);
1592  		if (unlikely(allocation == NULL)) {
1593  			goto label_oom;
1594  		}
1595  	}
1596  	assert(dopts-&gt;alignment == 0
1597  	    || ((uintptr_t)allocation &amp; (dopts-&gt;alignment - 1)) == ZU(0));
1598  	if (config_stats) {
1599  		assert(usize == isalloc(tsd_tsdn(tsd), allocation));
1600  		*tsd_thread_allocatedp_get(tsd) += usize;
1601  	}
1602  	if (sopts-&gt;slow) {
1603  		UTRACE(0, size, allocation);
1604  	}
1605  	check_entry_exit_locking(tsd_tsdn(tsd));
1606  	*dopts-&gt;result = allocation;
1607  	return 0;
1608  label_oom:
1609  	if (unlikely(sopts-&gt;slow) &amp;&amp; config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1610  		malloc_write(sopts-&gt;oom_string);
1611  		abort();
1612  	}
1613  	if (sopts-&gt;slow) {
1614  		UTRACE(NULL, size, NULL);
1615  	}
1616  	check_entry_exit_locking(tsd_tsdn(tsd));
1617  	if (sopts-&gt;set_errno_on_error) {
1618  		set_errno(ENOMEM);
1619  	}
1620  	if (sopts-&gt;null_out_result_on_error) {
1621  		*dopts-&gt;result = NULL;
1622  	}
1623  	return ENOMEM;
1624  label_invalid_alignment:
1625  	if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1626  		malloc_write(sopts-&gt;invalid_alignment_string);
1627  		abort();
1628  	}
1629  	if (sopts-&gt;set_errno_on_error) {
1630  		set_errno(EINVAL);
1631  	}
1632  	if (sopts-&gt;slow) {
1633  		UTRACE(NULL, size, NULL);
1634  	}
1635  	check_entry_exit_locking(tsd_tsdn(tsd));
1636  	if (sopts-&gt;null_out_result_on_error) {
1637  		*dopts-&gt;result = NULL;
1638  	}
1639  	return EINVAL;
1640  }
1641  JEMALLOC_ALWAYS_INLINE bool
1642  imalloc_init_check(static_opts_t *sopts, dynamic_opts_t *dopts) {
1643  	if (unlikely(!malloc_initialized()) &amp;&amp; unlikely(malloc_init())) {
1644  		if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
1645  			malloc_write(sopts-&gt;oom_string);
1646  			abort();
1647  		}
1648  		UTRACE(NULL, dopts-&gt;num_items * dopts-&gt;item_size, NULL);
1649  		set_errno(ENOMEM);
1650  		*dopts-&gt;result = NULL;
1651  		return false;
1652  	}
1653  	return true;
1654  }
1655  JEMALLOC_ALWAYS_INLINE int
1656  imalloc(static_opts_t *sopts, dynamic_opts_t *dopts) {
1657  	if (tsd_get_allocates() &amp;&amp; !imalloc_init_check(sopts, dopts)) {
1658  		return ENOMEM;
1659  	}
1660  	tsd_t *tsd = tsd_fetch();
1661  	assert(tsd);
1662  	if (likely(tsd_fast(tsd))) {
1663  		tsd_assert_fast(tsd);
1664  		sopts-&gt;slow = false;
1665  		return imalloc_body(sopts, dopts, tsd);
1666  	} else {
1667  		if (!tsd_get_allocates() &amp;&amp; !imalloc_init_check(sopts, dopts)) {
1668  			return ENOMEM;
1669  		}
1670  		sopts-&gt;slow = true;
1671  		return imalloc_body(sopts, dopts, tsd);
1672  	}
1673  }
1674  JEMALLOC_NOINLINE
1675  void *
1676  malloc_default(size_t size) {
1677  	void *ret;
1678  	static_opts_t sopts;
1679  	dynamic_opts_t dopts;
1680  	LOG(&quot;core.malloc.entry&quot;, &quot;size: %zu&quot;, size);
1681  	static_opts_init(&amp;sopts);
1682  	dynamic_opts_init(&amp;dopts);
1683  	sopts.null_out_result_on_error = true;
1684  	sopts.set_errno_on_error = true;
1685  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in malloc(): out of memory\n&quot;;
1686  	dopts.result = &amp;ret;
1687  	dopts.num_items = 1;
1688  	dopts.item_size = size;
1689  	imalloc(&amp;sopts, &amp;dopts);
1690  	if (sopts.slow) {
1691  		uintptr_t args[3] = {size};
1692  		hook_invoke_alloc(hook_alloc_malloc, ret, (uintptr_t)ret, args);
1693  	}
1694  	LOG(&quot;core.malloc.exit&quot;, &quot;result: %p&quot;, ret);
1695  	return ret;
1696  }
1697  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1698  void JEMALLOC_NOTHROW *
1699  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
1700  je_malloc(size_t size) {
1701  	LOG(&quot;core.malloc.entry&quot;, &quot;size: %zu&quot;, size);
1702  	if (tsd_get_allocates() &amp;&amp; unlikely(!malloc_initialized())) {
1703  		return malloc_default(size);
1704  	}
1705  	tsd_t *tsd = tsd_get(false);
1706  	if (unlikely(!tsd || !tsd_fast(tsd) || (size &gt; SC_LOOKUP_MAXCLASS))) {
1707  		return malloc_default(size);
1708  	}
1709  	tcache_t *tcache = tsd_tcachep_get(tsd);
1710  	if (unlikely(ticker_trytick(&amp;tcache-&gt;gc_ticker))) {
1711  		return malloc_default(size);
1712  	}
1713  	szind_t ind = sz_size2index_lookup(size);
1714  	size_t usize;
1715  	if (config_stats || config_prof) {
1716  		usize = sz_index2size(ind);
1717  	}
1718  	assert(ind &lt; SC_NBINS);
1719  	assert(size &lt;= SC_SMALL_MAXCLASS);
1720  	if (config_prof) {
1721  		int64_t bytes_until_sample = tsd_bytes_until_sample_get(tsd);
1722  		bytes_until_sample -= usize;
1723  		tsd_bytes_until_sample_set(tsd, bytes_until_sample);
1724  		if (unlikely(bytes_until_sample &lt; 0)) {
1725  			if (!prof_active) {
1726  				tsd_bytes_until_sample_set(tsd, SSIZE_MAX);
1727  			}
1728  			return malloc_default(size);
1729  		}
1730  	}
1731  	cache_bin_t *bin = tcache_small_bin_get(tcache, ind);
1732  	bool tcache_success;
1733  	void* ret = cache_bin_alloc_easy(bin, &amp;tcache_success);
1734  	if (tcache_success) {
1735  		if (config_stats) {
1736  			*tsd_thread_allocatedp_get(tsd) += usize;
1737  			bin-&gt;tstats.nrequests++;
1738  		}
1739  		if (config_prof) {
1740  			tcache-&gt;prof_accumbytes += usize;
1741  		}
1742  		LOG(&quot;core.malloc.exit&quot;, &quot;result: %p&quot;, ret);
1743  		return ret;
1744  	}
1745  	return malloc_default(size);
1746  }
1747  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
1748  JEMALLOC_ATTR(nonnull(1))
1749  je_posix_memalign(void **memptr, size_t alignment, size_t size) {
1750  	int ret;
1751  	static_opts_t sopts;
1752  	dynamic_opts_t dopts;
1753  	LOG(&quot;core.posix_memalign.entry&quot;, &quot;mem ptr: %p, alignment: %zu, &quot;
1754  	    &quot;size: %zu&quot;, memptr, alignment, size);
1755  	static_opts_init(&amp;sopts);
1756  	dynamic_opts_init(&amp;dopts);
1757  	sopts.bump_empty_aligned_alloc = true;
1758  	sopts.min_alignment = sizeof(void *);
1759  	sopts.oom_string =
1760  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
1761  	sopts.invalid_alignment_string =
1762  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
1763  	dopts.result = memptr;
1764  	dopts.num_items = 1;
1765  	dopts.item_size = size;
1766  	dopts.alignment = alignment;
1767  	ret = imalloc(&amp;sopts, &amp;dopts);
1768  	if (sopts.slow) {
1769  		uintptr_t args[3] = {(uintptr_t)memptr, (uintptr_t)alignment,
1770  			(uintptr_t)size};
1771  		hook_invoke_alloc(hook_alloc_posix_memalign, *memptr,
1772  		    (uintptr_t)ret, args);
1773  	}
1774  	LOG(&quot;core.posix_memalign.exit&quot;, &quot;result: %d, alloc ptr: %p&quot;, ret,
1775  	    *memptr);
1776  	return ret;
1777  }
1778  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1779  void JEMALLOC_NOTHROW *
1780  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)
1781  je_aligned_alloc(size_t alignment, size_t size) {
1782  	void *ret;
1783  	static_opts_t sopts;
1784  	dynamic_opts_t dopts;
1785  	LOG(&quot;core.aligned_alloc.entry&quot;, &quot;alignment: %zu, size: %zu\n&quot;,
1786  	    alignment, size);
1787  	static_opts_init(&amp;sopts);
1788  	dynamic_opts_init(&amp;dopts);
1789  	sopts.bump_empty_aligned_alloc = true;
1790  	sopts.null_out_result_on_error = true;
1791  	sopts.set_errno_on_error = true;
1792  	sopts.min_alignment = 1;
1793  	sopts.oom_string =
1794  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
1795  	sopts.invalid_alignment_string =
1796  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
1797  	dopts.result = &amp;ret;
1798  	dopts.num_items = 1;
1799  	dopts.item_size = size;
1800  	dopts.alignment = alignment;
1801  	imalloc(&amp;sopts, &amp;dopts);
1802  	if (sopts.slow) {
1803  		uintptr_t args[3] = {(uintptr_t)alignment, (uintptr_t)size};
1804  		hook_invoke_alloc(hook_alloc_aligned_alloc, ret,
1805  		    (uintptr_t)ret, args);
1806  	}
1807  	LOG(&quot;core.aligned_alloc.exit&quot;, &quot;result: %p&quot;, ret);
1808  	return ret;
1809  }
1810  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1811  void JEMALLOC_NOTHROW *
1812  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)
1813  je_calloc(size_t num, size_t size) {
1814  	void *ret;
1815  	static_opts_t sopts;
1816  	dynamic_opts_t dopts;
1817  	LOG(&quot;core.calloc.entry&quot;, &quot;num: %zu, size: %zu\n&quot;, num, size);
1818  	static_opts_init(&amp;sopts);
1819  	dynamic_opts_init(&amp;dopts);
1820  	sopts.may_overflow = true;
1821  	sopts.null_out_result_on_error = true;
1822  	sopts.set_errno_on_error = true;
1823  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in calloc(): out of memory\n&quot;;
1824  	dopts.result = &amp;ret;
1825  	dopts.num_items = num;
1826  	dopts.item_size = size;
1827  	dopts.zero = true;
1828  	imalloc(&amp;sopts, &amp;dopts);
1829  	if (sopts.slow) {
1830  		uintptr_t args[3] = {(uintptr_t)num, (uintptr_t)size};
1831  		hook_invoke_alloc(hook_alloc_calloc, ret, (uintptr_t)ret, args);
1832  	}
1833  	LOG(&quot;core.calloc.exit&quot;, &quot;result: %p&quot;, ret);
1834  	return ret;
1835  }
1836  static void *
1837  irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1838      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
1839  	void *p;
1840  	if (tctx == NULL) {
1841  		return NULL;
1842  	}
1843  	if (usize &lt;= SC_SMALL_MAXCLASS) {
1844  		p = iralloc(tsd, old_ptr, old_usize,
1845  		    SC_LARGE_MINCLASS, 0, false, hook_args);
1846  		if (p == NULL) {
1847  			return NULL;
1848  		}
1849  		arena_prof_promote(tsd_tsdn(tsd), p, usize);
1850  	} else {
1851  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1852  		    hook_args);
1853  	}
1854  	return p;
1855  }
1856  JEMALLOC_ALWAYS_INLINE void *
1857  irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1858     alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
1859  	void *p;
1860  	bool prof_active;
1861  	prof_tctx_t *old_tctx, *tctx;
1862  	prof_active = prof_active_get_unlocked();
1863  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
1864  	tctx = prof_alloc_prep(tsd, usize, prof_active, true);
1865  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
1866  		p = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx,
1867  		    hook_args);
1868  	} else {
1869  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1870  		    hook_args);
1871  	}
1872  	if (unlikely(p == NULL)) {
1873  		prof_alloc_rollback(tsd, tctx, true);
1874  		return NULL;
1875  	}
1876  	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
1877  	    old_tctx);
1878  	return p;
1879  }
1880  JEMALLOC_ALWAYS_INLINE void
1881  ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
1882  	if (!slow_path) {
1883  		tsd_assert_fast(tsd);
1884  	}
1885  	check_entry_exit_locking(tsd_tsdn(tsd));
1886  	if (tsd_reentrancy_level_get(tsd) != 0) {
1887  		assert(slow_path);
1888  	}
1889  	assert(ptr != NULL);
1890  	assert(malloc_initialized() || IS_INITIALIZER);
1891  	alloc_ctx_t alloc_ctx;
1892  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1893  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1894  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1895  	assert(alloc_ctx.szind != SC_NSIZES);
1896  	size_t usize;
1897  	if (config_prof &amp;&amp; opt_prof) {
1898  		usize = sz_index2size(alloc_ctx.szind);
1899  		prof_free(tsd, ptr, usize, &amp;alloc_ctx);
1900  	} else if (config_stats) {
1901  		usize = sz_index2size(alloc_ctx.szind);
1902  	}
1903  	if (config_stats) {
1904  		*tsd_thread_deallocatedp_get(tsd) += usize;
1905  	}
1906  	if (likely(!slow_path)) {
1907  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, false,
1908  		    false);
1909  	} else {
1910  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, false,
1911  		    true);
1912  	}
1913  }
1914  JEMALLOC_ALWAYS_INLINE void
1915  isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
1916  	if (!slow_path) {
1917  		tsd_assert_fast(tsd);
1918  	}
1919  	check_entry_exit_locking(tsd_tsdn(tsd));
1920  	if (tsd_reentrancy_level_get(tsd) != 0) {
1921  		assert(slow_path);
1922  	}
1923  	assert(ptr != NULL);
1924  	assert(malloc_initialized() || IS_INITIALIZER);
1925  	alloc_ctx_t alloc_ctx, *ctx;
1926  	if (!config_cache_oblivious &amp;&amp; ((uintptr_t)ptr &amp; PAGE_MASK) != 0) {
1927  		alloc_ctx.szind = sz_size2index(usize);
1928  		alloc_ctx.slab = true;
1929  		ctx = &amp;alloc_ctx;
1930  		if (config_debug) {
1931  			alloc_ctx_t dbg_ctx;
1932  			rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1933  			rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree,
1934  			    rtree_ctx, (uintptr_t)ptr, true, &amp;dbg_ctx.szind,
1935  			    &amp;dbg_ctx.slab);
1936  			assert(dbg_ctx.szind == alloc_ctx.szind);
1937  			assert(dbg_ctx.slab == alloc_ctx.slab);
1938  		}
1939  	} else if (config_prof &amp;&amp; opt_prof) {
1940  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1941  		rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1942  		    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1943  		assert(alloc_ctx.szind == sz_size2index(usize));
1944  		ctx = &amp;alloc_ctx;
1945  	} else {
1946  		ctx = NULL;
1947  	}
1948  	if (config_prof &amp;&amp; opt_prof) {
1949  		prof_free(tsd, ptr, usize, ctx);
1950  	}
1951  	if (config_stats) {
1952  		*tsd_thread_deallocatedp_get(tsd) += usize;
1953  	}
1954  	if (likely(!slow_path)) {
1955  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, false);
1956  	} else {
1957  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);
1958  	}
1959  }
1960  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1961  void JEMALLOC_NOTHROW *
1962  JEMALLOC_ALLOC_SIZE(2)
1963  je_realloc(void *ptr, size_t arg_size) {
1964  	void *ret;
1965  	tsdn_t *tsdn JEMALLOC_CC_SILENCE_INIT(NULL);
1966  	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
1967  	size_t old_usize = 0;
1968  	size_t size = arg_size;
1969  	LOG(&quot;core.realloc.entry&quot;, &quot;ptr: %p, size: %zu\n&quot;, ptr, size);
1970  	if (unlikely(size == 0)) {
1971  		if (ptr != NULL) {
1972  			UTRACE(ptr, 0, 0);
1973  			tcache_t *tcache;
1974  			tsd_t *tsd = tsd_fetch();
1975  			if (tsd_reentrancy_level_get(tsd) == 0) {
1976  				tcache = tcache_get(tsd);
1977  			} else {
1978  				tcache = NULL;
1979  			}
1980  			uintptr_t args[3] = {(uintptr_t)ptr, size};
1981  			hook_invoke_dalloc(hook_dalloc_realloc, ptr, args);
1982  			ifree(tsd, ptr, tcache, true);
1983  			LOG(&quot;core.realloc.exit&quot;, &quot;result: %p&quot;, NULL);
1984  			return NULL;
1985  		}
1986  		size = 1;
1987  	}
1988  	if (likely(ptr != NULL)) {
1989  		assert(malloc_initialized() || IS_INITIALIZER);
1990  		tsd_t *tsd = tsd_fetch();
1991  		check_entry_exit_locking(tsd_tsdn(tsd));
1992  		hook_ralloc_args_t hook_args = {true, {(uintptr_t)ptr,
1993  			(uintptr_t)arg_size, 0, 0}};
1994  		alloc_ctx_t alloc_ctx;
1995  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1996  		rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
1997  		    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
1998  		assert(alloc_ctx.szind != SC_NSIZES);
1999  		old_usize = sz_index2size(alloc_ctx.szind);
2000  		assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2001  		if (config_prof &amp;&amp; opt_prof) {
2002  			usize = sz_s2u(size);
2003  			if (unlikely(usize == 0
2004  			    || usize &gt; SC_LARGE_MAXCLASS)) {
2005  				ret = NULL;
2006  			} else {
2007  				ret = irealloc_prof(tsd, ptr, old_usize, usize,
2008  				    &amp;alloc_ctx, &amp;hook_args);
2009  			}
2010  		} else {
2011  			if (config_stats) {
2012  				usize = sz_s2u(size);
2013  			}
2014  			ret = iralloc(tsd, ptr, old_usize, size, 0, false,
2015  			    &amp;hook_args);
2016  		}
2017  		tsdn = tsd_tsdn(tsd);
2018  	} else {
2019  		static_opts_t sopts;
2020  		dynamic_opts_t dopts;
2021  		static_opts_init(&amp;sopts);
2022  		dynamic_opts_init(&amp;dopts);
2023  		sopts.null_out_result_on_error = true;
2024  		sopts.set_errno_on_error = true;
2025  		sopts.oom_string =
2026  		    &quot;&lt;jemalloc&gt;: Error in realloc(): out of memory\n&quot;;
2027  		dopts.result = &amp;ret;
2028  		dopts.num_items = 1;
2029  		dopts.item_size = size;
2030  		imalloc(&amp;sopts, &amp;dopts);
2031  		if (sopts.slow) {
2032  			uintptr_t args[3] = {(uintptr_t)ptr, arg_size};
2033  			hook_invoke_alloc(hook_alloc_realloc, ret,
2034  			    (uintptr_t)ret, args);
2035  		}
2036  		return ret;
2037  	}
2038  	if (unlikely(ret == NULL)) {
2039  		if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
2040  			malloc_write(&quot;&lt;jemalloc&gt;: Error in realloc(): &quot;
2041  			    &quot;out of memory\n&quot;);
2042  			abort();
2043  		}
2044  		set_errno(ENOMEM);
2045  	}
2046  	if (config_stats &amp;&amp; likely(ret != NULL)) {
2047  		tsd_t *tsd;
2048  		assert(usize == isalloc(tsdn, ret));
2049  		tsd = tsdn_tsd(tsdn);
2050  		*tsd_thread_allocatedp_get(tsd) += usize;
2051  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2052  	}
2053  	UTRACE(ptr, size, ret);
2054  	check_entry_exit_locking(tsdn);
2055  	LOG(&quot;core.realloc.exit&quot;, &quot;result: %p&quot;, ret);
2056  	return ret;
2057  }
2058  JEMALLOC_NOINLINE
2059  void
2060  free_default(void *ptr) {
2061  	UTRACE(ptr, 0, 0);
2062  	if (likely(ptr != NULL)) {
2063  		tsd_t *tsd = tsd_fetch_min();
2064  		check_entry_exit_locking(tsd_tsdn(tsd));
2065  		tcache_t *tcache;
2066  		if (likely(tsd_fast(tsd))) {
2067  			tsd_assert_fast(tsd);
2068  			tcache = tsd_tcachep_get(tsd);
2069  			ifree(tsd, ptr, tcache, false);
2070  		} else {
2071  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2072  				tcache = tcache_get(tsd);
2073  			} else {
2074  				tcache = NULL;
2075  			}
2076  			uintptr_t args_raw[3] = {(uintptr_t)ptr};
2077  			hook_invoke_dalloc(hook_dalloc_free, ptr, args_raw);
2078  			ifree(tsd, ptr, tcache, true);
2079  		}
2080  		check_entry_exit_locking(tsd_tsdn(tsd));
2081  	}
2082  }
2083  JEMALLOC_ALWAYS_INLINE
2084  bool free_fastpath(void *ptr, size_t size, bool size_hint) {
2085  	tsd_t *tsd = tsd_get(false);
2086  	if (unlikely(!tsd || !tsd_fast(tsd))) {
2087  		return false;
2088  	}
2089  	tcache_t *tcache = tsd_tcachep_get(tsd);
2090  	alloc_ctx_t alloc_ctx;
2091  	if (!size_hint || config_cache_oblivious) {
2092  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2093  		bool res = rtree_szind_slab_read_fast(tsd_tsdn(tsd), &amp;extents_rtree,
2094  						      rtree_ctx, (uintptr_t)ptr,
2095  						      &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2096  		if (!res || !alloc_ctx.slab) {
2097  			return false;
2098  		}
2099  		assert(alloc_ctx.szind != SC_NSIZES);
2100  	} else {
2101  		if (size &gt; SC_LOOKUP_MAXCLASS || (((uintptr_t)ptr &amp; PAGE_MASK) == 0)) {
2102  			return false;
2103  		}
2104  		alloc_ctx.szind = sz_size2index_lookup(size);
2105  	}
2106  	if (unlikely(ticker_trytick(&amp;tcache-&gt;gc_ticker))) {
2107  		return false;
2108  	}
2109  	cache_bin_t *bin = tcache_small_bin_get(tcache, alloc_ctx.szind);
2110  	cache_bin_info_t *bin_info = &amp;tcache_bin_info[alloc_ctx.szind];
2111  	if (!cache_bin_dalloc_easy(bin, bin_info, ptr)) {
2112  		return false;
2113  	}
2114  	if (config_stats) {
2115  		size_t usize = sz_index2size(alloc_ctx.szind);
2116  		*tsd_thread_deallocatedp_get(tsd) += usize;
2117  	}
2118  	return true;
2119  }
2120  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2121  je_free(void *ptr) {
2122  	LOG(&quot;core.free.entry&quot;, &quot;ptr: %p&quot;, ptr);
2123  	if (!free_fastpath(ptr, 0, false)) {
2124  		free_default(ptr);
2125  	}
2126  	LOG(&quot;core.free.exit&quot;, &quot;&quot;);
2127  }
2128  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
2129  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2130  void JEMALLOC_NOTHROW *
2131  JEMALLOC_ATTR(malloc)
2132  je_memalign(size_t alignment, size_t size) {
2133  	void *ret;
2134  	static_opts_t sopts;
2135  	dynamic_opts_t dopts;
2136  	LOG(&quot;core.memalign.entry&quot;, &quot;alignment: %zu, size: %zu\n&quot;, alignment,
2137  	    size);
2138  	static_opts_init(&amp;sopts);
2139  	dynamic_opts_init(&amp;dopts);
2140  	sopts.min_alignment = 1;
2141  	sopts.oom_string =
2142  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
2143  	sopts.invalid_alignment_string =
2144  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
2145  	sopts.null_out_result_on_error = true;
2146  	dopts.result = &amp;ret;
2147  	dopts.num_items = 1;
2148  	dopts.item_size = size;
2149  	dopts.alignment = alignment;
2150  	imalloc(&amp;sopts, &amp;dopts);
2151  	if (sopts.slow) {
2152  		uintptr_t args[3] = {alignment, size};
2153  		hook_invoke_alloc(hook_alloc_memalign, ret, (uintptr_t)ret,
2154  		    args);
2155  	}
2156  	LOG(&quot;core.memalign.exit&quot;, &quot;result: %p&quot;, ret);
2157  	return ret;
2158  }
2159  #endif
2160  #ifdef JEMALLOC_OVERRIDE_VALLOC
2161  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2162  void JEMALLOC_NOTHROW *
2163  JEMALLOC_ATTR(malloc)
2164  je_valloc(size_t size) {
2165  	void *ret;
2166  	static_opts_t sopts;
2167  	dynamic_opts_t dopts;
2168  	LOG(&quot;core.valloc.entry&quot;, &quot;size: %zu\n&quot;, size);
2169  	static_opts_init(&amp;sopts);
2170  	dynamic_opts_init(&amp;dopts);
2171  	sopts.null_out_result_on_error = true;
2172  	sopts.min_alignment = PAGE;
2173  	sopts.oom_string =
2174  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: out of memory\n&quot;;
2175  	sopts.invalid_alignment_string =
2176  	    &quot;&lt;jemalloc&gt;: Error allocating aligned memory: invalid alignment\n&quot;;
2177  	dopts.result = &amp;ret;
2178  	dopts.num_items = 1;
2179  	dopts.item_size = size;
2180  	dopts.alignment = PAGE;
2181  	imalloc(&amp;sopts, &amp;dopts);
2182  	if (sopts.slow) {
2183  		uintptr_t args[3] = {size};
2184  		hook_invoke_alloc(hook_alloc_valloc, ret, (uintptr_t)ret, args);
2185  	}
2186  	LOG(&quot;core.valloc.exit&quot;, &quot;result: %p\n&quot;, ret);
2187  	return ret;
2188  }
2189  #endif
2190  #if defined(JEMALLOC_IS_MALLOC) &amp;&amp; defined(JEMALLOC_GLIBC_MALLOC_HOOK)
2191  JEMALLOC_EXPORT void (*__free_hook)(void *ptr) = je_free;
2192  JEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;
2193  JEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;
2194  #  ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
2195  JEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =
2196      je_memalign;
2197  #  endif
2198  #  ifdef CPU_COUNT
2199  #    define ALIAS(je_fn)	__attribute__((alias (#je_fn), used))
2200  #    define PREALIAS(je_fn)	ALIAS(je_fn)
2201  #    ifdef JEMALLOC_OVERRIDE___LIBC_CALLOC
2202  void *__libc_calloc(size_t n, size_t size) PREALIAS(je_calloc);
2203  #    endif
2204  #    ifdef JEMALLOC_OVERRIDE___LIBC_FREE
2205  void __libc_free(void* ptr) PREALIAS(je_free);
2206  #    endif
2207  #    ifdef JEMALLOC_OVERRIDE___LIBC_MALLOC
2208  void *__libc_malloc(size_t size) PREALIAS(je_malloc);
2209  #    endif
2210  #    ifdef JEMALLOC_OVERRIDE___LIBC_MEMALIGN
2211  void *__libc_memalign(size_t align, size_t s) PREALIAS(je_memalign);
2212  #    endif
2213  #    ifdef JEMALLOC_OVERRIDE___LIBC_REALLOC
2214  void *__libc_realloc(void* ptr, size_t size) PREALIAS(je_realloc);
2215  #    endif
2216  #    ifdef JEMALLOC_OVERRIDE___LIBC_VALLOC
2217  void *__libc_valloc(size_t size) PREALIAS(je_valloc);
2218  #    endif
2219  #    ifdef JEMALLOC_OVERRIDE___POSIX_MEMALIGN
2220  int __posix_memalign(void** r, size_t a, size_t s) PREALIAS(je_posix_memalign);
2221  #    endif
2222  #    undef PREALIAS
2223  #    undef ALIAS
2224  #  endif
2225  #endif
2226  #ifdef JEMALLOC_EXPERIMENTAL_SMALLOCX_API
2227  #define JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y) x ## y
2228  #define JEMALLOC_SMALLOCX_CONCAT_HELPER2(x, y)  \
2229    JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y)
2230  typedef struct {
2231  	void *ptr;
2232  	size_t size;
2233  } smallocx_return_t;
2234  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2235  smallocx_return_t JEMALLOC_NOTHROW
2236  JEMALLOC_SMALLOCX_CONCAT_HELPER2(je_smallocx_, JEMALLOC_VERSION_GID_IDENT)
2237    (size_t size, int flags) {
2238  	smallocx_return_t ret;
2239  	static_opts_t sopts;
2240  	dynamic_opts_t dopts;
2241  	LOG(&quot;core.smallocx.entry&quot;, &quot;size: %zu, flags: %d&quot;, size, flags);
2242  	static_opts_init(&amp;sopts);
2243  	dynamic_opts_init(&amp;dopts);
2244  	sopts.assert_nonempty_alloc = true;
2245  	sopts.null_out_result_on_error = true;
2246  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in mallocx(): out of memory\n&quot;;
2247  	sopts.usize = true;
2248  	dopts.result = &amp;ret.ptr;
2249  	dopts.num_items = 1;
2250  	dopts.item_size = size;
2251  	if (unlikely(flags != 0)) {
2252  		if ((flags &amp; MALLOCX_LG_ALIGN_MASK) != 0) {
2253  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2254  		}
2255  		dopts.zero = MALLOCX_ZERO_GET(flags);
2256  		if ((flags &amp; MALLOCX_TCACHE_MASK) != 0) {
2257  			if ((flags &amp; MALLOCX_TCACHE_MASK)
2258  			    == MALLOCX_TCACHE_NONE) {
2259  				dopts.tcache_ind = TCACHE_IND_NONE;
2260  			} else {
2261  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2262  			}
2263  		} else {
2264  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2265  		}
2266  		if ((flags &amp; MALLOCX_ARENA_MASK) != 0)
2267  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2268  	}
2269  	imalloc(&amp;sopts, &amp;dopts);
2270  	assert(dopts.usize == je_nallocx(size, flags));
2271  	ret.size = dopts.usize;
2272  	LOG(&quot;core.smallocx.exit&quot;, &quot;result: %p, size: %zu&quot;, ret.ptr, ret.size);
2273  	return ret;
2274  }
2275  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER
2276  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER2
2277  #endif
2278  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2279  void JEMALLOC_NOTHROW *
2280  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
2281  je_mallocx(size_t size, int flags) {
2282  	void *ret;
2283  	static_opts_t sopts;
2284  	dynamic_opts_t dopts;
2285  	LOG(&quot;core.mallocx.entry&quot;, &quot;size: %zu, flags: %d&quot;, size, flags);
2286  	static_opts_init(&amp;sopts);
2287  	dynamic_opts_init(&amp;dopts);
2288  	sopts.assert_nonempty_alloc = true;
2289  	sopts.null_out_result_on_error = true;
2290  	sopts.oom_string = &quot;&lt;jemalloc&gt;: Error in mallocx(): out of memory\n&quot;;
2291  	dopts.result = &amp;ret;
2292  	dopts.num_items = 1;
2293  	dopts.item_size = size;
2294  	if (unlikely(flags != 0)) {
2295  		if ((flags &amp; MALLOCX_LG_ALIGN_MASK) != 0) {
2296  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2297  		}
2298  		dopts.zero = MALLOCX_ZERO_GET(flags);
2299  		if ((flags &amp; MALLOCX_TCACHE_MASK) != 0) {
2300  			if ((flags &amp; MALLOCX_TCACHE_MASK)
2301  			    == MALLOCX_TCACHE_NONE) {
2302  				dopts.tcache_ind = TCACHE_IND_NONE;
2303  			} else {
2304  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2305  			}
2306  		} else {
2307  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2308  		}
2309  		if ((flags &amp; MALLOCX_ARENA_MASK) != 0)
2310  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2311  	}
2312  	imalloc(&amp;sopts, &amp;dopts);
2313  	if (sopts.slow) {
2314  		uintptr_t args[3] = {size, flags};
2315  		hook_invoke_alloc(hook_alloc_mallocx, ret, (uintptr_t)ret,
2316  		    args);
2317  	}
2318  	LOG(&quot;core.mallocx.exit&quot;, &quot;result: %p&quot;, ret);
2319  	return ret;
2320  }
2321  static void *
2322  irallocx_prof_sample(tsdn_t *tsdn, void *old_ptr, size_t old_usize,
2323      size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
2324      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
2325  	void *p;
2326  	if (tctx == NULL) {
2327  		return NULL;
2328  	}
2329  	if (usize &lt;= SC_SMALL_MAXCLASS) {
2330  		p = iralloct(tsdn, old_ptr, old_usize,
2331  		    SC_LARGE_MINCLASS, alignment, zero, tcache,
2332  		    arena, hook_args);
2333  		if (p == NULL) {
2334  			return NULL;
2335  		}
2336  		arena_prof_promote(tsdn, p, usize);
2337  	} else {
2338  		p = iralloct(tsdn, old_ptr, old_usize, usize, alignment, zero,
2339  		    tcache, arena, hook_args);
2340  	}
2341  	return p;
2342  }
2343  JEMALLOC_ALWAYS_INLINE void *
2344  irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
2345      size_t alignment, size_t *usize, bool zero, tcache_t *tcache,
2346      arena_t *arena, alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
2347  	void *p;
2348  	bool prof_active;
2349  	prof_tctx_t *old_tctx, *tctx;
2350  	prof_active = prof_active_get_unlocked();
2351  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
2352  	tctx = prof_alloc_prep(tsd, *usize, prof_active, false);
2353  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2354  		p = irallocx_prof_sample(tsd_tsdn(tsd), old_ptr, old_usize,
2355  		    *usize, alignment, zero, tcache, arena, tctx, hook_args);
2356  	} else {
2357  		p = iralloct(tsd_tsdn(tsd), old_ptr, old_usize, size, alignment,
2358  		    zero, tcache, arena, hook_args);
2359  	}
2360  	if (unlikely(p == NULL)) {
2361  		prof_alloc_rollback(tsd, tctx, false);
2362  		return NULL;
2363  	}
2364  	if (p == old_ptr &amp;&amp; alignment != 0) {
2365  		*usize = isalloc(tsd_tsdn(tsd), p);
2366  	}
2367  	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
2368  	    old_usize, old_tctx);
2369  	return p;
2370  }
2371  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2372  void JEMALLOC_NOTHROW *
2373  JEMALLOC_ALLOC_SIZE(2)
2374  je_rallocx(void *ptr, size_t size, int flags) {
2375  	void *p;
2376  	tsd_t *tsd;
2377  	size_t usize;
2378  	size_t old_usize;
2379  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2380  	bool zero = flags &amp; MALLOCX_ZERO;
2381  	arena_t *arena;
2382  	tcache_t *tcache;
2383  	LOG(&quot;core.rallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: %d&quot;, ptr,
2384  	    size, flags);
2385  	assert(ptr != NULL);
2386  	assert(size != 0);
2387  	assert(malloc_initialized() || IS_INITIALIZER);
2388  	tsd = tsd_fetch();
2389  	check_entry_exit_locking(tsd_tsdn(tsd));
2390  	if (unlikely((flags &amp; MALLOCX_ARENA_MASK) != 0)) {
2391  		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
2392  		arena = arena_get(tsd_tsdn(tsd), arena_ind, true);
2393  		if (unlikely(arena == NULL)) {
2394  			goto label_oom;
2395  		}
2396  	} else {
2397  		arena = NULL;
2398  	}
2399  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2400  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2401  			tcache = NULL;
2402  		} else {
2403  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2404  		}
2405  	} else {
2406  		tcache = tcache_get(tsd);
2407  	}
2408  	alloc_ctx_t alloc_ctx;
2409  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2410  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
2411  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2412  	assert(alloc_ctx.szind != SC_NSIZES);
2413  	old_usize = sz_index2size(alloc_ctx.szind);
2414  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2415  	hook_ralloc_args_t hook_args = {false, {(uintptr_t)ptr, size, flags,
2416  		0}};
2417  	if (config_prof &amp;&amp; opt_prof) {
2418  		usize = (alignment == 0) ?
2419  		    sz_s2u(size) : sz_sa2u(size, alignment);
2420  		if (unlikely(usize == 0
2421  		    || usize &gt; SC_LARGE_MAXCLASS)) {
2422  			goto label_oom;
2423  		}
2424  		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, &amp;usize,
2425  		    zero, tcache, arena, &amp;alloc_ctx, &amp;hook_args);
2426  		if (unlikely(p == NULL)) {
2427  			goto label_oom;
2428  		}
2429  	} else {
2430  		p = iralloct(tsd_tsdn(tsd), ptr, old_usize, size, alignment,
2431  		    zero, tcache, arena, &amp;hook_args);
2432  		if (unlikely(p == NULL)) {
2433  			goto label_oom;
2434  		}
2435  		if (config_stats) {
2436  			usize = isalloc(tsd_tsdn(tsd), p);
2437  		}
2438  	}
2439  	assert(alignment == 0 || ((uintptr_t)p &amp; (alignment - 1)) == ZU(0));
2440  	if (config_stats) {
2441  		*tsd_thread_allocatedp_get(tsd) += usize;
2442  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2443  	}
2444  	UTRACE(ptr, size, p);
2445  	check_entry_exit_locking(tsd_tsdn(tsd));
2446  	LOG(&quot;core.rallocx.exit&quot;, &quot;result: %p&quot;, p);
2447  	return p;
2448  label_oom:
2449  	if (config_xmalloc &amp;&amp; unlikely(opt_xmalloc)) {
2450  		malloc_write(&quot;&lt;jemalloc&gt;: Error in rallocx(): out of memory\n&quot;);
2451  		abort();
2452  	}
2453  	UTRACE(ptr, size, 0);
2454  	check_entry_exit_locking(tsd_tsdn(tsd));
2455  	LOG(&quot;core.rallocx.exit&quot;, &quot;result: %p&quot;, NULL);
2456  	return NULL;
2457  }
2458  JEMALLOC_ALWAYS_INLINE size_t
2459  ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2460      size_t extra, size_t alignment, bool zero) {
2461  	size_t newsize;
2462  	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero,
2463  	    &amp;newsize)) {
2464  		return old_usize;
2465  	}
2466  	return newsize;
2467  }
2468  static size_t
2469  ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2470      size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx) {
2471  	size_t usize;
2472  	if (tctx == NULL) {
2473  		return old_usize;
2474  	}
2475  	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
2476  	    zero);
2477  	return usize;
2478  }
2479  JEMALLOC_ALWAYS_INLINE size_t
2480  ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
2481      size_t extra, size_t alignment, bool zero, alloc_ctx_t *alloc_ctx) {
2482  	size_t usize_max, usize;
2483  	bool prof_active;
2484  	prof_tctx_t *old_tctx, *tctx;
2485  	prof_active = prof_active_get_unlocked();
2486  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), ptr, alloc_ctx);
2487  	if (alignment == 0) {
2488  		usize_max = sz_s2u(size+extra);
2489  		assert(usize_max &gt; 0
2490  		    &amp;&amp; usize_max &lt;= SC_LARGE_MAXCLASS);
2491  	} else {
2492  		usize_max = sz_sa2u(size+extra, alignment);
2493  		if (unlikely(usize_max == 0
2494  		    || usize_max &gt; SC_LARGE_MAXCLASS)) {
2495  			usize_max = SC_LARGE_MAXCLASS;
2496  		}
2497  	}
2498  	tctx = prof_alloc_prep(tsd, usize_max, prof_active, false);
2499  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2500  		usize = ixallocx_prof_sample(tsd_tsdn(tsd), ptr, old_usize,
2501  		    size, extra, alignment, zero, tctx);
2502  	} else {
2503  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2504  		    extra, alignment, zero);
2505  	}
2506  	if (usize == old_usize) {
2507  		prof_alloc_rollback(tsd, tctx, false);
2508  		return usize;
2509  	}
2510  	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
2511  	    old_tctx);
2512  	return usize;
2513  }
2514  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2515  je_xallocx(void *ptr, size_t size, size_t extra, int flags) {
2516  	tsd_t *tsd;
2517  	size_t usize, old_usize;
2518  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2519  	bool zero = flags &amp; MALLOCX_ZERO;
2520  	LOG(&quot;core.xallocx.entry&quot;, &quot;ptr: %p, size: %zu, extra: %zu, &quot;
2521  	    &quot;flags: %d&quot;, ptr, size, extra, flags);
2522  	assert(ptr != NULL);
2523  	assert(size != 0);
2524  	assert(SIZE_T_MAX - size &gt;= extra);
2525  	assert(malloc_initialized() || IS_INITIALIZER);
2526  	tsd = tsd_fetch();
2527  	check_entry_exit_locking(tsd_tsdn(tsd));
2528  	alloc_ctx_t alloc_ctx;
2529  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2530  	rtree_szind_slab_read(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,
2531  	    (uintptr_t)ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab);
2532  	assert(alloc_ctx.szind != SC_NSIZES);
2533  	old_usize = sz_index2size(alloc_ctx.szind);
2534  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2535  	if (unlikely(size &gt; SC_LARGE_MAXCLASS)) {
2536  		usize = old_usize;
2537  		goto label_not_resized;
2538  	}
2539  	if (unlikely(SC_LARGE_MAXCLASS - size &lt; extra)) {
2540  		extra = SC_LARGE_MAXCLASS - size;
2541  	}
2542  	if (config_prof &amp;&amp; opt_prof) {
2543  		usize = ixallocx_prof(tsd, ptr, old_usize, size, extra,
2544  		    alignment, zero, &amp;alloc_ctx);
2545  	} else {
2546  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2547  		    extra, alignment, zero);
2548  	}
2549  	if (unlikely(usize == old_usize)) {
2550  		goto label_not_resized;
2551  	}
2552  	if (config_stats) {
2553  		*tsd_thread_allocatedp_get(tsd) += usize;
2554  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2555  	}
2556  label_not_resized:
2557  	if (unlikely(!tsd_fast(tsd))) {
2558  		uintptr_t args[4] = {(uintptr_t)ptr, size, extra, flags};
2559  		hook_invoke_expand(hook_expand_xallocx, ptr, old_usize,
2560  		    usize, (uintptr_t)usize, args);
2561  	}
2562  	UTRACE(ptr, size, ptr);
2563  	check_entry_exit_locking(tsd_tsdn(tsd));
2564  	LOG(&quot;core.xallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2565  	return usize;
2566  }
2567  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2568  JEMALLOC_ATTR(pure)
2569  je_sallocx(const void *ptr, int flags) {
2570  	size_t usize;
2571  	tsdn_t *tsdn;
2572  	LOG(&quot;core.sallocx.entry&quot;, &quot;ptr: %p, flags: %d&quot;, ptr, flags);
2573  	assert(malloc_initialized() || IS_INITIALIZER);
2574  	assert(ptr != NULL);
2575  	tsdn = tsdn_fetch();
2576  	check_entry_exit_locking(tsdn);
2577  	if (config_debug || force_ivsalloc) {
2578  		usize = ivsalloc(tsdn, ptr);
2579  		assert(force_ivsalloc || usize != 0);
2580  	} else {
2581  		usize = isalloc(tsdn, ptr);
2582  	}
2583  	check_entry_exit_locking(tsdn);
2584  	LOG(&quot;core.sallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2585  	return usize;
2586  }
2587  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2588  je_dallocx(void *ptr, int flags) {
2589  	LOG(&quot;core.dallocx.entry&quot;, &quot;ptr: %p, flags: %d&quot;, ptr, flags);
2590  	assert(ptr != NULL);
2591  	assert(malloc_initialized() || IS_INITIALIZER);
2592  	tsd_t *tsd = tsd_fetch();
2593  	bool fast = tsd_fast(tsd);
2594  	check_entry_exit_locking(tsd_tsdn(tsd));
2595  	tcache_t *tcache;
2596  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2597  		assert(tsd_reentrancy_level_get(tsd) == 0);
2598  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2599  			tcache = NULL;
2600  		} else {
2601  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2602  		}
2603  	} else {
2604  		if (likely(fast)) {
2605  			tcache = tsd_tcachep_get(tsd);
2606  			assert(tcache == tcache_get(tsd));
2607  		} else {
2608  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2609  				tcache = tcache_get(tsd);
2610  			}  else {
2611  				tcache = NULL;
2612  			}
2613  		}
2614  	}
2615  	UTRACE(ptr, 0, 0);
2616  	if (likely(fast)) {
2617  		tsd_assert_fast(tsd);
2618  		ifree(tsd, ptr, tcache, false);
2619  	} else {
2620  		uintptr_t args_raw[3] = {(uintptr_t)ptr, flags};
2621  		hook_invoke_dalloc(hook_dalloc_dallocx, ptr, args_raw);
2622  		ifree(tsd, ptr, tcache, true);
2623  	}
2624  	check_entry_exit_locking(tsd_tsdn(tsd));
2625  	LOG(&quot;core.dallocx.exit&quot;, &quot;&quot;);
2626  }
2627  JEMALLOC_ALWAYS_INLINE size_t
2628  inallocx(tsdn_t *tsdn, size_t size, int flags) {
2629  	check_entry_exit_locking(tsdn);
2630  	size_t usize;
2631  	if (likely((flags &amp; MALLOCX_LG_ALIGN_MASK) == 0)) {
2632  		usize = sz_s2u(size);
2633  	} else {
2634  		usize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
2635  	}
2636  	check_entry_exit_locking(tsdn);
2637  	return usize;
2638  }
2639  JEMALLOC_NOINLINE void
2640  sdallocx_default(void *ptr, size_t size, int flags) {
2641  	assert(ptr != NULL);
2642  	assert(malloc_initialized() || IS_INITIALIZER);
2643  	tsd_t *tsd = tsd_fetch();
2644  	bool fast = tsd_fast(tsd);
2645  	size_t usize = inallocx(tsd_tsdn(tsd), size, flags);
2646  	assert(usize == isalloc(tsd_tsdn(tsd), ptr));
2647  	check_entry_exit_locking(tsd_tsdn(tsd));
2648  	tcache_t *tcache;
2649  	if (unlikely((flags &amp; MALLOCX_TCACHE_MASK) != 0)) {
2650  		assert(tsd_reentrancy_level_get(tsd) == 0);
2651  		if ((flags &amp; MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2652  			tcache = NULL;
2653  		} else {
2654  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2655  		}
2656  	} else {
2657  		if (likely(fast)) {
2658  			tcache = tsd_tcachep_get(tsd);
2659  			assert(tcache == tcache_get(tsd));
2660  		} else {
2661  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2662  				tcache = tcache_get(tsd);
2663  			} else {
2664  				tcache = NULL;
2665  			}
2666  		}
2667  	}
2668  	UTRACE(ptr, 0, 0);
2669  	if (likely(fast)) {
2670  		tsd_assert_fast(tsd);
2671  		isfree(tsd, ptr, usize, tcache, false);
2672  	} else {
2673  		uintptr_t args_raw[3] = {(uintptr_t)ptr, size, flags};
2674  		hook_invoke_dalloc(hook_dalloc_sdallocx, ptr, args_raw);
2675  		isfree(tsd, ptr, usize, tcache, true);
2676  	}
2677  	check_entry_exit_locking(tsd_tsdn(tsd));
2678  }
2679  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2680  je_sdallocx(void *ptr, size_t size, int flags) {
2681  	LOG(&quot;core.sdallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: %d&quot;, ptr,
2682  		size, flags);
2683  	if (flags !=0 || !free_fastpath(ptr, size, true)) {
2684  		sdallocx_default(ptr, size, flags);
2685  	}
2686  	LOG(&quot;core.sdallocx.exit&quot;, &quot;&quot;);
2687  }
2688  void JEMALLOC_NOTHROW
2689  je_sdallocx_noflags(void *ptr, size_t size) {
2690  	LOG(&quot;core.sdallocx.entry&quot;, &quot;ptr: %p, size: %zu, flags: 0&quot;, ptr,
2691  		size);
2692  	if (!free_fastpath(ptr, size, true)) {
2693  		sdallocx_default(ptr, size, 0);
2694  	}
2695  	LOG(&quot;core.sdallocx.exit&quot;, &quot;&quot;);
2696  }
2697  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2698  JEMALLOC_ATTR(pure)
2699  je_nallocx(size_t size, int flags) {
2700  	size_t usize;
2701  	tsdn_t *tsdn;
2702  	assert(size != 0);
2703  	if (unlikely(malloc_init())) {
2704  		LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, ZU(0));
2705  		return 0;
2706  	}
2707  	tsdn = tsdn_fetch();
2708  	check_entry_exit_locking(tsdn);
2709  	usize = inallocx(tsdn, size, flags);
2710  	if (unlikely(usize &gt; SC_LARGE_MAXCLASS)) {
2711  		LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, ZU(0));
2712  		return 0;
2713  	}
2714  	check_entry_exit_locking(tsdn);
2715  	LOG(&quot;core.nallocx.exit&quot;, &quot;result: %zu&quot;, usize);
2716  	return usize;
2717  }
2718  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2719  je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
2720      size_t newlen) {
2721  	int ret;
2722  	tsd_t *tsd;
2723  	LOG(&quot;core.mallctl.entry&quot;, &quot;name: %s&quot;, name);
2724  	if (unlikely(malloc_init())) {
2725  		LOG(&quot;core.mallctl.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2726  		return EAGAIN;
2727  	}
2728  	tsd = tsd_fetch();
2729  	check_entry_exit_locking(tsd_tsdn(tsd));
2730  	ret = ctl_byname(tsd, name, oldp, oldlenp, newp, newlen);
2731  	check_entry_exit_locking(tsd_tsdn(tsd));
2732  	LOG(&quot;core.mallctl.exit&quot;, &quot;result: %d&quot;, ret);
2733  	return ret;
2734  }
2735  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2736  je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
2737  	int ret;
2738  	LOG(&quot;core.mallctlnametomib.entry&quot;, &quot;name: %s&quot;, name);
2739  	if (unlikely(malloc_init())) {
2740  		LOG(&quot;core.mallctlnametomib.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2741  		return EAGAIN;
2742  	}
2743  	tsd_t *tsd = tsd_fetch();
2744  	check_entry_exit_locking(tsd_tsdn(tsd));
2745  	ret = ctl_nametomib(tsd, name, mibp, miblenp);
2746  	check_entry_exit_locking(tsd_tsdn(tsd));
2747  	LOG(&quot;core.mallctlnametomib.exit&quot;, &quot;result: %d&quot;, ret);
2748  	return ret;
2749  }
2750  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2751  je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
2752    void *newp, size_t newlen) {
2753  	int ret;
2754  	tsd_t *tsd;
2755  	LOG(&quot;core.mallctlbymib.entry&quot;, &quot;&quot;);
2756  	if (unlikely(malloc_init())) {
2757  		LOG(&quot;core.mallctlbymib.exit&quot;, &quot;result: %d&quot;, EAGAIN);
2758  		return EAGAIN;
2759  	}
2760  	tsd = tsd_fetch();
2761  	check_entry_exit_locking(tsd_tsdn(tsd));
2762  	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
2763  	check_entry_exit_locking(tsd_tsdn(tsd));
2764  	LOG(&quot;core.mallctlbymib.exit&quot;, &quot;result: %d&quot;, ret);
2765  	return ret;
2766  }
2767  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2768  je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
2769      const char *opts) {
2770  	tsdn_t *tsdn;
2771  	LOG(&quot;core.malloc_stats_print.entry&quot;, &quot;&quot;);
2772  	tsdn = tsdn_fetch();
2773  	check_entry_exit_locking(tsdn);
2774  	stats_print(write_cb, cbopaque, opts);
2775  	check_entry_exit_locking(tsdn);
2776  	LOG(&quot;core.malloc_stats_print.exit&quot;, &quot;&quot;);
2777  }
2778  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2779  je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
2780  	size_t ret;
2781  	tsdn_t *tsdn;
2782  	LOG(&quot;core.malloc_usable_size.entry&quot;, &quot;ptr: %p&quot;, ptr);
2783  	assert(malloc_initialized() || IS_INITIALIZER);
2784  	tsdn = tsdn_fetch();
2785  	check_entry_exit_locking(tsdn);
2786  	if (unlikely(ptr == NULL)) {
2787  		ret = 0;
2788  	} else {
<span onclick='openModal()' class='match'>2789  		if (config_debug || force_ivsalloc) {
2790  			ret = ivsalloc(tsdn, ptr);
2791  			assert(force_ivsalloc || ret != 0);
2792  		} else {
2793  			ret = isalloc(tsdn, ptr);
2794  		}
2795  	}
</span>2796  	check_entry_exit_locking(tsdn);
2797  	LOG(&quot;core.malloc_usable_size.exit&quot;, &quot;result: %zu&quot;, ret);
2798  	return ret;
2799  }
2800  #ifndef JEMALLOC_JET
2801  JEMALLOC_ATTR(constructor)
2802  static void
2803  jemalloc_constructor(void) {
2804  	malloc_init();
2805  }
2806  #endif
2807  #ifndef JEMALLOC_MUTEX_INIT_CB
2808  void
2809  jemalloc_prefork(void)
2810  #else
2811  JEMALLOC_EXPORT void
2812  _malloc_prefork(void)
2813  #endif
2814  {
2815  	tsd_t *tsd;
2816  	unsigned i, j, narenas;
2817  	arena_t *arena;
2818  #ifdef JEMALLOC_MUTEX_INIT_CB
2819  	if (!malloc_initialized()) {
2820  		return;
2821  	}
2822  #endif
2823  	assert(malloc_initialized());
2824  	tsd = tsd_fetch();
2825  	narenas = narenas_total_get();
2826  	witness_prefork(tsd_witness_tsdp_get(tsd));
2827  	ctl_prefork(tsd_tsdn(tsd));
2828  	tcache_prefork(tsd_tsdn(tsd));
2829  	malloc_mutex_prefork(tsd_tsdn(tsd), &amp;arenas_lock);
2830  	if (have_background_thread) {
2831  		background_thread_prefork0(tsd_tsdn(tsd));
2832  	}
2833  	prof_prefork0(tsd_tsdn(tsd));
2834  	if (have_background_thread) {
2835  		background_thread_prefork1(tsd_tsdn(tsd));
2836  	}
2837  	for (i = 0; i &lt; 8; i++) {
2838  		for (j = 0; j &lt; narenas; j++) {
2839  			if ((arena = arena_get(tsd_tsdn(tsd), j, false)) !=
2840  			    NULL) {
2841  				switch (i) {
2842  				case 0:
2843  					arena_prefork0(tsd_tsdn(tsd), arena);
2844  					break;
2845  				case 1:
2846  					arena_prefork1(tsd_tsdn(tsd), arena);
2847  					break;
2848  				case 2:
2849  					arena_prefork2(tsd_tsdn(tsd), arena);
2850  					break;
2851  				case 3:
2852  					arena_prefork3(tsd_tsdn(tsd), arena);
2853  					break;
2854  				case 4:
2855  					arena_prefork4(tsd_tsdn(tsd), arena);
2856  					break;
2857  				case 5:
2858  					arena_prefork5(tsd_tsdn(tsd), arena);
2859  					break;
2860  				case 6:
2861  					arena_prefork6(tsd_tsdn(tsd), arena);
2862  					break;
2863  				case 7:
2864  					arena_prefork7(tsd_tsdn(tsd), arena);
2865  					break;
2866  				default: not_reached();
2867  				}
2868  			}
2869  		}
2870  	}
2871  	prof_prefork1(tsd_tsdn(tsd));
2872  	tsd_prefork(tsd);
2873  }
2874  #ifndef JEMALLOC_MUTEX_INIT_CB
2875  void
2876  jemalloc_postfork_parent(void)
2877  #else
2878  JEMALLOC_EXPORT void
2879  _malloc_postfork(void)
2880  #endif
2881  {
2882  	tsd_t *tsd;
2883  	unsigned i, narenas;
2884  #ifdef JEMALLOC_MUTEX_INIT_CB
2885  	if (!malloc_initialized()) {
2886  		return;
2887  	}
2888  #endif
2889  	assert(malloc_initialized());
2890  	tsd = tsd_fetch();
2891  	tsd_postfork_parent(tsd);
2892  	witness_postfork_parent(tsd_witness_tsdp_get(tsd));
2893  	for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
2894  		arena_t *arena;
2895  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2896  			arena_postfork_parent(tsd_tsdn(tsd), arena);
2897  		}
2898  	}
2899  	prof_postfork_parent(tsd_tsdn(tsd));
2900  	if (have_background_thread) {
2901  		background_thread_postfork_parent(tsd_tsdn(tsd));
2902  	}
2903  	malloc_mutex_postfork_parent(tsd_tsdn(tsd), &amp;arenas_lock);
2904  	tcache_postfork_parent(tsd_tsdn(tsd));
2905  	ctl_postfork_parent(tsd_tsdn(tsd));
2906  }
2907  void
2908  jemalloc_postfork_child(void) {
2909  	tsd_t *tsd;
2910  	unsigned i, narenas;
2911  	assert(malloc_initialized());
2912  	tsd = tsd_fetch();
2913  	tsd_postfork_child(tsd);
2914  	witness_postfork_child(tsd_witness_tsdp_get(tsd));
2915  	for (i = 0, narenas = narenas_total_get(); i &lt; narenas; i++) {
2916  		arena_t *arena;
2917  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2918  			arena_postfork_child(tsd_tsdn(tsd), arena);
2919  		}
2920  	}
2921  	prof_postfork_child(tsd_tsdn(tsd));
2922  	if (have_background_thread) {
2923  		background_thread_postfork_child(tsd_tsdn(tsd));
2924  	}
2925  	malloc_mutex_postfork_child(tsd_tsdn(tsd), &amp;arenas_lock);
2926  	tcache_postfork_child(tsd_tsdn(tsd));
2927  	ctl_postfork_child(tsd_tsdn(tsd));
2928  }
2929  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2930  je_get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
2931  	assert(ptr != NULL);
2932  	return iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);
2933  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</div>
                </div>
                <div class="column column_space"><pre><code>2577  	if (config_debug || force_ivsalloc) {
2578  		usize = ivsalloc(tsdn, ptr);
2579  		assert(force_ivsalloc || usize != 0);
2580  	} else {
2581  		usize = isalloc(tsdn, ptr);
2582  	}
2583  	check_entry_exit_locking(tsdn);
</pre></code></div>
                <div class="column column_space"><pre><code>2789  		if (config_debug || force_ivsalloc) {
2790  			ret = ivsalloc(tsdn, ptr);
2791  			assert(force_ivsalloc || ret != 0);
2792  		} else {
2793  			ret = isalloc(tsdn, ptr);
2794  		}
2795  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    