
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.648068669527897%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</h3>
            <pre><code>1  #include <math.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #ifndef USE_PARI
5  #define USE_PARI 1
6  #endif
7  typedef double trigreal;
8  #  define COS cos
9  #  define SIN sin
10  #  define TAN tan
11  #  define KTRIG(x) (x)
12  static const trigreal MYK2PI =
13      KTRIG(6.2831853071795864769252867665590057683943388);
14  #ifdef REALLY_ACCURATE
15  extern double fma (double X, double Y, double Z);
16  static void dbmul(double a, double b, double *x, double *dx)
17  {
18       *x = a * b; 
19       *dx = fma(a, b, -*x);
20  }
21  static void dbdiv(double a, double b, double *x, double *dx)
22  {
23       *x = a / b;
24       *dx = fma(-*x, b, a) / b;
25  }
26  static double by2pi(double m, double n)
27  {
28       static const double rpi2 =
29  	  6.28318530717958623199592693708837032318115234375;
30       static const double rpi2r = 
31  	  2.44929359829470635445213186455000211641949889184e-16;
32       double x, y, z, dx, dy, dz;
33       dbmul(rpi2, m, &x, &dx);      &bsol;* x + dx = rpi2 * m, exactly */
34       dbmul(rpi2r, m, &y, &dy);     &bsol;* x + dx = rpi2r * m, exactly */
35       y += dx;
36       dx = y + dy;
37       dbdiv(x, n, &y, &dy);      &bsol;* y + dy = x / n */
38       dbdiv(dx, n, &z, &dz);     &bsol;* z + dz = dx / n */
39       return ((z + dy) + dz) + y;
40  }
41  #else
42  static const trigreal K2PI =
43      KTRIG(6.2831853071795864769252867665590057683943388);
44  #define by2pi(m, n) ((K2PI * (m)) / (n))
45  #endif
46  static trigreal sin2pi0(trigreal m, trigreal n);
47  static trigreal cos2pi0(trigreal m, trigreal n)
48  {
49       if (m < 0) return cos2pi0(-m, n);
50       if (m > n * 0.5) return cos2pi0(n - m, n);
51       if (m > n * 0.25) return -sin2pi0(m - n * 0.25, n);
52       if (m > n * 0.125) return sin2pi0(n * 0.25 - m, n);
53       return COS(by2pi(m, n));
54  }
55  static trigreal sin2pi0(trigreal m, trigreal n)
56  {
57       if (m < 0) return -sin2pi0(-m, n);
58       if (m > n * 0.5) return -sin2pi0(n - m, n);
59       if (m > n * 0.25) return cos2pi0(m - n * 0.25, n);
60       if (m > n * 0.125) return cos2pi0(n * 0.25 - m, n);
61       return SIN(by2pi(m, n));
62  }
63  trigreal cos2pi(int m, int n)
64  {
65       return cos2pi0((trigreal)m, (trigreal)n);
66  }
67  trigreal sin2pi(int m, int n)
68  {
69       return sin2pi0((trigreal)m, (trigreal)n);
70  }
71  trigreal tan2pi(int m, int n)
72  {
73       trigreal dm = m, dn = n;
74       return TAN(by2pi(dm, dn));
75  }
76  trigreal naive_sin2pi(int m, int n)
77  {
78       return SIN(MYK2PI * ((trigreal) m / (trigreal) n));
79  }
80  trigreal naive_cos2pi(int m, int n)
81  {
82       return COS(MYK2PI * ((trigreal) m / (trigreal) n));
83  }
84  #if USE_PARI
85  #include <pari/pari.h>
86  long prec = 25;
87  double ck(long m, long n, double (*cf) (int, int), GEN(*gf) (GEN, long))
88  {
89       GEN gv, gcval, err, arg;
90       double cerr, cval;
<span onclick='openModal()' class='match'>91       long ltop = avma;
92       arg = mulsr(2L * m, divrs(gpi, n));
93       setlg(arg, prec);
94       gv = gf(arg, prec);
95       cval = cf(m, n);
96       gcval = dbltor(cval);
97       err = gsub(gcval, gv);
98       cerr = rtodbl(err);
99       avma = ltop;
</span>100       return cerr;
101  }
102  #else
103  double ck(long m, long n, double (*cf) (int, int), 
104  	  long double(*gf) (long double))
105  {
106       long double l2pi = 6.2831853071795864769252867665590057683943388L;
107       return cf(m, n) - gf(l2pi * (long double)m / (long double)n);
108  }
109  #define gsin sinl
110  #define gcos cosl
111  #endif
112  int main(int argc, char *argv[])
113  {
114       long nmin, nmax;
115       long n, m;
116  #if USE_PARI
117       pari_init(500000, 2);
118       mppi(prec);
119  #endif
120       if (argc > 1)
121  	  nmin = atoi(argv[1]);
122       else
123  	  nmin = 1024;
124       if (argc > 2)
125  	  nmax = atoi(argv[2]);
126       else
127  	  nmax = nmin;
128       for (n = nmin; n <= nmax; ++n) {
129  	  double maxe = 0.0, nmaxe = 0.0;;
130  	  for (m = 0; m < n; ++m) {
131  	       double e;
132  	       e = ck(m, n, sin2pi, gsin); if (e > maxe) maxe = e;
133  	       e = ck(m, n, cos2pi, gcos); if (e > maxe) maxe = e;
134  	       e = ck(m, n, naive_sin2pi, gsin); if (e > nmaxe) nmaxe = e;
135  	       e = ck(m, n, naive_cos2pi, gcos); if (e > nmaxe) nmaxe = e;
136  	  }
137  	  printf("%ld %g %g\n", n, maxe, nmaxe);
138       }
139       return 0;
140  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dpdk.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <errno.h>
5  #include <netdb.h>
6  #include <stdio.h>
7  #include <stdlib.h>
8  #include <string.h>
9  #include <unistd.h>
10  #include <limits.h> &bsol;* for INT_MAX */
11  #include <time.h>
12  #include <sys/time.h>
13  #include <rte_config.h>
14  #include <rte_common.h>
15  #include <rte_errno.h>
16  #include <rte_log.h>
17  #include <rte_malloc.h>
18  #include <rte_memory.h>
19  #include <rte_eal.h>
20  #include <rte_launch.h>
21  #include <rte_atomic.h>
22  #include <rte_cycles.h>
23  #include <rte_lcore.h>
24  #include <rte_per_lcore.h>
25  #include <rte_branch_prediction.h>
26  #include <rte_interrupts.h>
27  #include <rte_random.h>
28  #include <rte_debug.h>
29  #include <rte_ether.h>
30  #include <rte_ethdev.h>
31  #include <rte_mempool.h>
32  #include <rte_mbuf.h>
33  #include <rte_bus.h>
34  #include "pcap-int.h"
35  #include "pcap-dpdk.h"
36  #ifdef HAVE_STRUCT_RTE_ETHER_ADDR
37  #define ETHER_ADDR_TYPE	struct rte_ether_addr
38  #else
39  #define ETHER_ADDR_TYPE	struct ether_addr
40  #endif
41  #define DPDK_DEF_LOG_LEV RTE_LOG_ERR
42  static int is_dpdk_pre_inited=0;
43  #define DPDK_LIB_NAME "libpcap_dpdk"
44  #define DPDK_DESC "Data Plane Development Kit (DPDK) Interface"
45  #define DPDK_ERR_PERM_MSG "permission denied, DPDK needs root permission"
46  #define DPDK_ARGC_MAX 64
47  #define DPDK_CFG_MAX_LEN 1024
48  #define DPDK_DEV_NAME_MAX 32
49  #define DPDK_DEV_DESC_MAX 512
50  #define DPDK_CFG_ENV_NAME "DPDK_CFG"
51  #define DPDK_DEF_MIN_SLEEP_MS 1
52  static char dpdk_cfg_buf[DPDK_CFG_MAX_LEN];
53  #define DPDK_MAC_ADDR_SIZE 32
54  #define DPDK_DEF_MAC_ADDR "00:00:00:00:00:00"
55  #define DPDK_PCI_ADDR_SIZE 16
56  #define DPDK_DEF_CFG "--log-level=error -l0 -dlibrte_pmd_e1000.so -dlibrte_pmd_ixgbe.so -dlibrte_mempool_ring.so"
57  #define DPDK_PREFIX "dpdk:"
58  #define DPDK_PORTID_MAX 65535U
59  #define MBUF_POOL_NAME "mbuf_pool"
60  #define DPDK_TX_BUF_NAME "tx_buffer"
61  #define DPDK_NB_MBUFS 8192U
62  #define MEMPOOL_CACHE_SIZE 256
63  #define MAX_PKT_BURST 32
64  #define RTE_TEST_RX_DESC_DEFAULT 1024
65  #define RTE_TEST_TX_DESC_DEFAULT 1024
66  static uint16_t nb_rxd = RTE_TEST_RX_DESC_DEFAULT;
67  static uint16_t nb_txd = RTE_TEST_TX_DESC_DEFAULT;
68  #ifdef RTE_ETHER_MAX_JUMBO_FRAME_LEN
69  #define RTE_ETH_PCAP_SNAPLEN RTE_ETHER_MAX_JUMBO_FRAME_LEN
70  #else
71  #define RTE_ETH_PCAP_SNAPLEN ETHER_MAX_JUMBO_FRAME_LEN
72  #endif
73  static struct rte_eth_dev_tx_buffer *tx_buffer;
74  struct dpdk_ts_helper{
75  	struct timeval start_time;
76  	uint64_t start_cycles;
77  	uint64_t hz;
78  };
79  struct pcap_dpdk{
80  	pcap_t * orig;
81  	uint16_t portid; 
82  	int must_clear_promisc;
83  	uint64_t bpf_drop;
84  	int nonblock;
85  	struct timeval required_select_timeout;
86  	struct timeval prev_ts;
87  	struct rte_eth_stats prev_stats;
88  	struct timeval curr_ts;
89  	struct rte_eth_stats curr_stats;
90  	uint64_t pps;
91  	uint64_t bps;
92  	struct rte_mempool * pktmbuf_pool;
93  	struct dpdk_ts_helper ts_helper;
94  	ETHER_ADDR_TYPE eth_addr;
95  	char mac_addr[DPDK_MAC_ADDR_SIZE];
96  	char pci_addr[DPDK_PCI_ADDR_SIZE];
97  	unsigned char pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN];
98  };
99  static struct rte_eth_conf port_conf = {
100  	.rxmode = {
101  		.split_hdr_size = 0,
102  	},
103  	.txmode = {
104  		.mq_mode = ETH_MQ_TX_NONE,
105  	},
106  };
107  static void	dpdk_fmt_errmsg_for_rte_errno(char *, size_t, int,
108      PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(4, 5);
109  static void dpdk_fmt_errmsg_for_rte_errno(char *errbuf, size_t errbuflen,
110      int errnum, const char *fmt, ...)
111  {
112  	va_list ap;
113  	size_t msglen;
114  	char *p;
115  	size_t errbuflen_remaining;
116  	va_start(ap, fmt);
117  	vsnprintf(errbuf, errbuflen, fmt, ap);
118  	va_end(ap);
119  	msglen = strlen(errbuf);
120  	if (msglen + 3 > errbuflen) {
121  		return;
122  	}
<span onclick='openModal()' class='match'>123  	p = errbuf + msglen;
124  	errbuflen_remaining = errbuflen - msglen;
125  	*p++ = ':';
126  	*p++ = ' ';
127  	*p = '\0';
128  	msglen += 2;
</span>129  	errbuflen_remaining -= 2;
130  	snprintf(p, errbuflen_remaining, "%s", rte_strerror(errnum));
131  }
132  static int dpdk_init_timer(struct pcap_dpdk *pd){
133  	gettimeofday(&(pd->ts_helper.start_time),NULL);
134  	pd->ts_helper.start_cycles = rte_get_timer_cycles();
135  	pd->ts_helper.hz = rte_get_timer_hz();
136  	if (pd->ts_helper.hz == 0){
137  		return -1;
138  	}
139  	return 0;
140  }
141  static inline void calculate_timestamp(struct dpdk_ts_helper *helper,struct timeval *ts)
142  {
143  	uint64_t cycles;
144  	struct timeval cur_time;
145  	cycles = rte_get_timer_cycles() - helper->start_cycles;
146  	cur_time.tv_sec = (time_t)(cycles/helper->hz);
147  	cur_time.tv_usec = (suseconds_t)((cycles%helper->hz)*1e6/helper->hz);
148  	timeradd(&(helper->start_time), &cur_time, ts);
149  }
150  static uint32_t dpdk_gather_data(unsigned char *data, uint32_t len, struct rte_mbuf *mbuf)
151  {
152  	uint32_t total_len = 0;
153  	while (mbuf && (total_len+mbuf->data_len) < len ){
154  		rte_memcpy(data+total_len, rte_pktmbuf_mtod(mbuf,void *),mbuf->data_len);
155  		total_len+=mbuf->data_len;
156  		mbuf=mbuf->next;
157  	}
158  	return total_len;
159  }
160  static int dpdk_read_with_timeout(pcap_t *p, struct rte_mbuf **pkts_burst, const uint16_t burst_cnt){
161  	struct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);
162  	int nb_rx = 0;
163  	int timeout_ms = p->opt.timeout;
164  	int sleep_ms = 0;
165  	if (pd->nonblock){
166  		nb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);
167  	}else{
168  		while (timeout_ms == 0 || sleep_ms < timeout_ms){
169  			nb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);
170  			if (nb_rx){ 
171  				break;
172  			}else{ 
173  				if (p->break_loop){
174  					break;
175  				}
176  				rte_delay_us_block(DPDK_DEF_MIN_SLEEP_MS*1000);
177  				sleep_ms += DPDK_DEF_MIN_SLEEP_MS;
178  			}
179  		}
180  	}
181  	return nb_rx;
182  }
183  static int pcap_dpdk_dispatch(pcap_t *p, int max_cnt, pcap_handler cb, u_char *cb_arg)
184  {
185  	struct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);
186  	int burst_cnt = 0;
187  	int nb_rx = 0;
188  	struct rte_mbuf *pkts_burst[MAX_PKT_BURST];
189  	struct rte_mbuf *m;
190  	struct pcap_pkthdr pcap_header;
191  	uint32_t pkt_len = 0;
192  	uint32_t caplen = 0;
193  	u_char *bp = NULL;
194  	int i=0;
195  	unsigned int gather_len =0;
196  	int pkt_cnt = 0;
197  	u_char *large_buffer=NULL;
198  	int timeout_ms = p->opt.timeout;
199  	if (PACKET_COUNT_IS_UNLIMITED(max_cnt))
200  		max_cnt = INT_MAX;
201  	if (max_cnt < MAX_PKT_BURST){
202  		burst_cnt = max_cnt;
203  	}else{
204  		burst_cnt = MAX_PKT_BURST;
205  	}
206  	while( pkt_cnt < max_cnt){
207  		if (p->break_loop){
208  			p->break_loop = 0;
209  			return PCAP_ERROR_BREAK;
210  		}
211  		nb_rx = dpdk_read_with_timeout(p, pkts_burst, burst_cnt);
212  		if (nb_rx == 0){
213  			if (pd->nonblock){
214  				RTE_LOG(DEBUG, USER1, "dpdk: no packets available in non-blocking mode.\n");
215  			}else{
216  				if (p->break_loop){
217  					RTE_LOG(DEBUG, USER1, "dpdk: no packets available and break_loop is set in blocking mode.\n");
218  					p->break_loop = 0;
219  					return PCAP_ERROR_BREAK;
220  				}
221  				RTE_LOG(DEBUG, USER1, "dpdk: no packets available for timeout %d ms in blocking mode.\n", timeout_ms);
222  			}
223  			break;
224  		}
225  		pkt_cnt += nb_rx;
226  		for ( i = 0; i < nb_rx; i++) {
227  			m = pkts_burst[i];
228  			calculate_timestamp(&(pd->ts_helper),&(pcap_header.ts));
229  			pkt_len = rte_pktmbuf_pkt_len(m);
230  			caplen = pkt_len < (uint32_t)p->snapshot ? pkt_len: (uint32_t)p->snapshot;
231  			pcap_header.caplen = caplen;
232  			pcap_header.len = pkt_len;
233  			rte_prefetch0(rte_pktmbuf_mtod(m, void *));
234  			bp = NULL;
235  			if (m->nb_segs == 1)
236  			{
237  				bp = rte_pktmbuf_mtod(m, u_char *);
238  			}else{
239  				if ( pkt_len <= RTE_ETH_PCAP_SNAPLEN)
240  				{
241  					gather_len = dpdk_gather_data(pd->pcap_tmp_buf, RTE_ETH_PCAP_SNAPLEN, m);
242  					bp = pd->pcap_tmp_buf;
243  				}else{
244  					large_buffer = (u_char *)malloc(caplen*sizeof(u_char));
245  					gather_len = dpdk_gather_data(large_buffer, caplen, m);
246  					bp = large_buffer;
247  				}
248  			}
249  			if (bp){
250  				if (p->fcode.bf_insns==NULL || pcap_filter(p->fcode.bf_insns, bp, pcap_header.len, pcap_header.caplen)){
251  					cb(cb_arg, &pcap_header, bp);
252  				}else{
253  					pd->bpf_drop++;
254  				}
255  			}
256  			rte_pktmbuf_free(m);
257  			if (large_buffer){
258  				free(large_buffer);
259  				large_buffer=NULL;
260  			}
261  		}
262  	}
263  	return pkt_cnt;
264  }
265  static int pcap_dpdk_inject(pcap_t *p, const void *buf _U_, int size _U_)
266  {
267  	pcap_strlcpy(p->errbuf,
268  	    "dpdk error: Inject function has not been implemented yet",
269  	    PCAP_ERRBUF_SIZE);
270  	return PCAP_ERROR;
271  }
272  static void pcap_dpdk_close(pcap_t *p)
273  {
274  	struct pcap_dpdk *pd = p->priv;
275  	if (pd==NULL)
276  	{
277  		return;
278  	}
279  	if (pd->must_clear_promisc)
280  	{
281  		rte_eth_promiscuous_disable(pd->portid);
282  	}
283  	rte_eth_dev_stop(pd->portid);
284  	rte_eth_dev_close(pd->portid);
285  	pcap_cleanup_live_common(p);
286  }
287  static void nic_stats_display(struct pcap_dpdk *pd)
288  {
289  	uint16_t portid = pd->portid;
290  	struct rte_eth_stats stats;
291  	rte_eth_stats_get(portid, &stats);
292  	RTE_LOG(INFO,USER1, "portid:%d, RX-packets: %-10"PRIu64"  RX-errors:  %-10"PRIu64
293  	       "  RX-bytes:  %-10"PRIu64"  RX-Imissed:  %-10"PRIu64"\n", portid, stats.ipackets, stats.ierrors,
294  	       stats.ibytes,stats.imissed);
295  	RTE_LOG(INFO,USER1, "portid:%d, RX-PPS: %-10"PRIu64" RX-Mbps: %.2lf\n", portid, pd->pps, pd->bps/1e6f );
296  }
297  static int pcap_dpdk_stats(pcap_t *p, struct pcap_stat *ps)
298  {
299  	struct pcap_dpdk *pd = p->priv;
300  	calculate_timestamp(&(pd->ts_helper), &(pd->curr_ts));
301  	rte_eth_stats_get(pd->portid,&(pd->curr_stats));
302  	if (ps){
303  		ps->ps_recv = pd->curr_stats.ipackets;
304  		ps->ps_drop = pd->curr_stats.ierrors;
305  		ps->ps_drop += pd->bpf_drop;
306  		ps->ps_ifdrop = pd->curr_stats.imissed;
307  	}
308  	uint64_t delta_pkt = pd->curr_stats.ipackets - pd->prev_stats.ipackets;
309  	struct timeval delta_tm;
310  	timersub(&(pd->curr_ts),&(pd->prev_ts), &delta_tm);
311  	uint64_t delta_usec = delta_tm.tv_sec*1e6+delta_tm.tv_usec;
312  	uint64_t delta_bit = (pd->curr_stats.ibytes-pd->prev_stats.ibytes)*8;
313  	RTE_LOG(DEBUG, USER1, "delta_usec: %-10"PRIu64" delta_pkt: %-10"PRIu64" delta_bit: %-10"PRIu64"\n", delta_usec, delta_pkt, delta_bit);
314  	pd->pps = (uint64_t)(delta_pkt*1e6f/delta_usec);
315  	pd->bps = (uint64_t)(delta_bit*1e6f/delta_usec);
316  	nic_stats_display(pd);
317  	pd->prev_stats = pd->curr_stats;
318  	pd->prev_ts = pd->curr_ts;
319  	return 0;
320  }
321  static int pcap_dpdk_setnonblock(pcap_t *p, int nonblock){
322  	struct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);
323  	pd->nonblock = nonblock;
324  	return 0;
325  }
326  static int pcap_dpdk_getnonblock(pcap_t *p){
327  	struct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);
328  	return pd->nonblock;
329  }
330  static int check_link_status(uint16_t portid, struct rte_eth_link *plink)
331  {
332  	rte_eth_link_get(portid, plink);
333  	return plink->link_status == ETH_LINK_UP;
334  }
335  static void eth_addr_str(ETHER_ADDR_TYPE *addrp, char* mac_str, int len)
336  {
337  	int offset=0;
338  	if (addrp == NULL){
339  		snprintf(mac_str, len-1, DPDK_DEF_MAC_ADDR);
340  		return;
341  	}
342  	for (int i=0; i<6; i++)
343  	{
344  		if (offset >= len)
345  		{ 
346  			return;
347  		}
348  		if (i==0)
349  		{
350  			snprintf(mac_str+offset, len-1-offset, "%02X",addrp->addr_bytes[i]);
351  			offset+=2; 
352  		}else{
353  			snprintf(mac_str+offset, len-1-offset, ":%02X", addrp->addr_bytes[i]);
354  			offset+=3; 
355  		}
356  	}
357  	return;
358  }
359  static uint16_t portid_by_device(char * device)
360  {
361  	uint16_t ret = DPDK_PORTID_MAX;
362  	size_t len = strlen(device);
363  	size_t prefix_len = strlen(DPDK_PREFIX);
364  	unsigned long ret_ul = 0L;
365  	char *pEnd;
366  	if (len<=prefix_len || strncmp(device, DPDK_PREFIX, prefix_len)) 
367  	{
368  		return ret;
369  	}
370  	for (int i=prefix_len; device[i]; i++){
371  		if (device[i]<'0' || device[i]>'9'){
372  			return ret;
373  		}
374  	}
375  	ret_ul = strtoul(&(device[prefix_len]), &pEnd, 10);
376  	if (pEnd == &(device[prefix_len]) || *pEnd != '\0'){
377  		return ret;
378  	}
379  	if (ret_ul >= DPDK_PORTID_MAX){
380  		return ret;
381  	}
382  	ret = (uint16_t)ret_ul;
383  	return ret;
384  }
385  static int parse_dpdk_cfg(char* dpdk_cfg,char** dargv)
386  {
387  	int cnt=0;
388  	memset(dargv,0,sizeof(dargv[0])*DPDK_ARGC_MAX);
389  	int skip_space = 1;
390  	int i=0;
391  	RTE_LOG(INFO, USER1,"dpdk cfg: %s\n",dpdk_cfg);
392  	for (i=0;dpdk_cfg[i] && cnt<DPDK_ARGC_MAX-1;i++){
393  		if (skip_space && dpdk_cfg[i]!=' '){ 
394  			skip_space=!skip_space; 
395  			dargv[cnt++] = dpdk_cfg+i;
396  		}
397  		if (!skip_space && dpdk_cfg[i]==' '){ 
398  			dpdk_cfg[i]=0x00; 
399  			skip_space=!skip_space; 
400  		}
401  	}
402  	dargv[cnt]=NULL;
403  	return cnt;
404  }
405  static int dpdk_pre_init(char * ebuf, int eaccess_not_fatal)
406  {
407  	int dargv_cnt=0;
408  	char *dargv[DPDK_ARGC_MAX];
409  	char *ptr_dpdk_cfg = NULL;
410  	int ret;
411  	if (is_dpdk_pre_inited != 0)
412  	{
413  		if (is_dpdk_pre_inited < 0)
414  		{
415  			goto error;
416  		}
417  		else
418  		{
419  			return 1;
420  		}
421  	}
422  	ptr_dpdk_cfg = getenv(DPDK_CFG_ENV_NAME);
423  	rte_log_set_global_level(DPDK_DEF_LOG_LEV);
424  	if (ptr_dpdk_cfg == NULL)
425  	{
426  		RTE_LOG(INFO,USER1,"env $DPDK_CFG is unset, so using default: %s\n",DPDK_DEF_CFG);
427  		ptr_dpdk_cfg = DPDK_DEF_CFG;
428  	}
429  	memset(dpdk_cfg_buf,0,sizeof(dpdk_cfg_buf));
430  	snprintf(dpdk_cfg_buf,DPDK_CFG_MAX_LEN-1,"%s %s",DPDK_LIB_NAME,ptr_dpdk_cfg);
431  	dargv_cnt = parse_dpdk_cfg(dpdk_cfg_buf,dargv);
432  	ret = rte_eal_init(dargv_cnt,dargv);
433  	if (ret == -1)
434  	{
435  		is_dpdk_pre_inited = -rte_errno;
436  		goto error;
437  	}
438  	is_dpdk_pre_inited = 1;
439  	return 1;
440  error:
441  	switch (-is_dpdk_pre_inited)
442  	{
443  		case EACCES:
444  			RTE_LOG(ERR, USER1, "%s\n", DPDK_ERR_PERM_MSG);
445  			if (eaccess_not_fatal)
446  				return 0;
447  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
448  			    "DPDK requires that it run as root");
449  			return PCAP_ERROR_PERM_DENIED;
450  		case EAGAIN:
451  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
452  			    "Bus or system resource was not available");
453  			break;
454  		case EALREADY:
455  			is_dpdk_pre_inited = 1;
456  			return 1;
457  		case EFAULT:
458  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
459  			    "The tailq configuration name was not found in the memory configuration");
460  			return PCAP_ERROR;
461  		case EINVAL:
462  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
463  			    "The configuration file has invalid parameters");
464  			break;
465  		case ENOMEM:
466  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
467  			    "Out of memory");
468  			break;
469  		case ENODEV:
470  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
471  			    "An error occurred setting up memory");
472  			break;
473  		case ENOTSUP:
474  			return 0;
475  		case EPROTO:
476  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
477  			    "PCI bus is not present or not readable by the EAL");
478  			break;
479  		case ENOEXEC:
480  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
481  			    "A service core failed to launch successfully");
482  			break;
483  		default:
484  			dpdk_fmt_errmsg_for_rte_errno(ebuf,
485  			    PCAP_ERRBUF_SIZE, -is_dpdk_pre_inited,
486  			    "dpdk error: dpdk_pre_init failed");
487  			break;
488  	}
489  	return PCAP_ERROR;
490  }
491  static int pcap_dpdk_activate(pcap_t *p)
492  {
493  	struct pcap_dpdk *pd = p->priv;
494  	pd->orig = p;
495  	int ret = PCAP_ERROR;
496  	uint16_t nb_ports=0;
497  	uint16_t portid= DPDK_PORTID_MAX;
498  	unsigned nb_mbufs = DPDK_NB_MBUFS;
499  	struct rte_eth_rxconf rxq_conf;
500  	struct rte_eth_txconf txq_conf;
501  	struct rte_eth_conf local_port_conf = port_conf;
502  	struct rte_eth_dev_info dev_info;
503  	int is_port_up = 0;
504  	struct rte_eth_link link;
505  	do{
506  		char dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];
507  		ret = dpdk_pre_init(dpdk_pre_init_errbuf, 0);
508  		if (ret < 0)
509  		{
510  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
511  			    "Can't open device %s: %s",
512  			    p->opt.device, dpdk_pre_init_errbuf);
513  			break;
514  		}
515  		if (ret == 0)
516  		{
517  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
518  			    "Can't open device %s: DPDK is not available on this machine",
519  			    p->opt.device);
520  			return PCAP_ERROR_NO_SUCH_DEVICE;
521  		}
522  		ret = dpdk_init_timer(pd);
523  		if (ret<0)
524  		{
525  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
526  				"dpdk error: Init timer is zero with device %s",
527  				p->opt.device);
528  			ret = PCAP_ERROR;
529  			break;
530  		}
531  		nb_ports = rte_eth_dev_count_avail();
532  		if (nb_ports == 0)
533  		{
534  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
535  			    "dpdk error: No Ethernet ports");
536  			ret = PCAP_ERROR;
537  			break;
538  		}
539  		portid = portid_by_device(p->opt.device);
540  		if (portid == DPDK_PORTID_MAX){
541  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
542  			    "dpdk error: portid is invalid. device %s",
543  			    p->opt.device);
544  			ret = PCAP_ERROR_NO_SUCH_DEVICE;
545  			break;
546  		}
547  		pd->portid = portid;
548  		if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
549  		{
550  			p->snapshot = MAXIMUM_SNAPLEN;
551  		}
552  		pd->pktmbuf_pool = rte_pktmbuf_pool_create(MBUF_POOL_NAME, nb_mbufs,
553  			MEMPOOL_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE,
554  			rte_socket_id());
555  		if (pd->pktmbuf_pool == NULL)
556  		{
557  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
558  			    PCAP_ERRBUF_SIZE, rte_errno,
559  			    "dpdk error: Cannot init mbuf pool");
560  			ret = PCAP_ERROR;
561  			break;
562  		}
563  		rte_eth_dev_info_get(portid, &dev_info);
564  		if (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MBUF_FAST_FREE)
565  		{
566  			local_port_conf.txmode.offloads |=DEV_TX_OFFLOAD_MBUF_FAST_FREE;
567  		}
568  		ret = rte_eth_dev_configure(portid, 1, 1, &local_port_conf);
569  		if (ret < 0)
570  		{
571  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
572  			    PCAP_ERRBUF_SIZE, -ret,
573  			    "dpdk error: Cannot configure device: port=%u",
574  			    portid);
575  			ret = PCAP_ERROR;
576  			break;
577  		}
578  		ret = rte_eth_dev_adjust_nb_rx_tx_desc(portid, &nb_rxd, &nb_txd);
579  		if (ret < 0)
580  		{
581  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
582  			    PCAP_ERRBUF_SIZE, -ret,
583  			    "dpdk error: Cannot adjust number of descriptors: port=%u",
584  			    portid);
585  			ret = PCAP_ERROR;
586  			break;
587  		}
588  		rte_eth_macaddr_get(portid, &(pd->eth_addr));
589  		eth_addr_str(&(pd->eth_addr), pd->mac_addr, DPDK_MAC_ADDR_SIZE-1);
590  		rxq_conf = dev_info.default_rxconf;
591  		rxq_conf.offloads = local_port_conf.rxmode.offloads;
592  		ret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,
593  					     rte_eth_dev_socket_id(portid),
594  					     &rxq_conf,
595  					     pd->pktmbuf_pool);
596  		if (ret < 0)
597  		{
598  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
599  			    PCAP_ERRBUF_SIZE, -ret,
600  			    "dpdk error: rte_eth_rx_queue_setup:port=%u",
601  			    portid);
602  			ret = PCAP_ERROR;
603  			break;
604  		}
605  		txq_conf = dev_info.default_txconf;
606  		txq_conf.offloads = local_port_conf.txmode.offloads;
607  		ret = rte_eth_tx_queue_setup(portid, 0, nb_txd,
608  				rte_eth_dev_socket_id(portid),
609  				&txq_conf);
610  		if (ret < 0)
611  		{
612  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
613  			    PCAP_ERRBUF_SIZE, -ret,
614  			    "dpdk error: rte_eth_tx_queue_setup:port=%u",
615  			    portid);
616  			ret = PCAP_ERROR;
617  			break;
618  		}
619  		tx_buffer = rte_zmalloc_socket(DPDK_TX_BUF_NAME,
620  				RTE_ETH_TX_BUFFER_SIZE(MAX_PKT_BURST), 0,
621  				rte_eth_dev_socket_id(portid));
622  		if (tx_buffer == NULL)
623  		{
624  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
625  			    "dpdk error: Cannot allocate buffer for tx on port %u", portid);
626  			ret = PCAP_ERROR;
627  			break;
628  		}
629  		rte_eth_tx_buffer_init(tx_buffer, MAX_PKT_BURST);
630  		ret = rte_eth_dev_start(portid);
631  		if (ret < 0)
632  		{
633  			dpdk_fmt_errmsg_for_rte_errno(p->errbuf,
634  			    PCAP_ERRBUF_SIZE, -ret,
635  			    "dpdk error: rte_eth_dev_start:port=%u",
636  			    portid);
637  			ret = PCAP_ERROR;
638  			break;
639  		}
640  		if (p->opt.promisc){
641  			pd->must_clear_promisc=1;
642  			rte_eth_promiscuous_enable(portid);
643  		}
644  		is_port_up = check_link_status(portid, &link);
645  		if (!is_port_up){
646  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
647  			    "dpdk error: link is down, port=%u",portid);
648  			ret = PCAP_ERROR_IFACE_NOT_UP;
649  			break;
650  		}
651  		rte_eth_stats_reset(pd->portid);
652  		calculate_timestamp(&(pd->ts_helper), &(pd->prev_ts));
653  		rte_eth_stats_get(pd->portid,&(pd->prev_stats));
654  		pd->portid = portid;
655  		p->fd = pd->portid;
656  		if (p->snapshot <=0 || p->snapshot> MAXIMUM_SNAPLEN)
657  		{
658  			p->snapshot = MAXIMUM_SNAPLEN;
659  		}
660  		p->linktype = DLT_EN10MB; 
661  		p->selectable_fd = p->fd;
662  		p->read_op = pcap_dpdk_dispatch;
663  		p->inject_op = pcap_dpdk_inject;
664  		p->setfilter_op = pcap_install_bpf_program;
665  		p->setdirection_op = NULL;
666  		p->set_datalink_op = NULL;
667  		p->getnonblock_op = pcap_dpdk_getnonblock;
668  		p->setnonblock_op = pcap_dpdk_setnonblock;
669  		p->stats_op = pcap_dpdk_stats;
670  		p->cleanup_op = pcap_dpdk_close;
671  		p->breakloop_op = pcap_breakloop_common;
672  		pd->required_select_timeout.tv_sec = 0;
673  		pd->required_select_timeout.tv_usec = DPDK_DEF_MIN_SLEEP_MS*1000;
674  		p->required_select_timeout = &pd->required_select_timeout;
675  		ret = 0; 
676  	}while(0);
677  	if (ret <= PCAP_ERROR) 
678  	{
679  		pcap_cleanup_live_common(p);
680  	}else{
681  		rte_eth_dev_get_name_by_port(portid,pd->pci_addr);
682  		RTE_LOG(INFO, USER1,"Port %d device: %s, MAC:%s, PCI:%s\n", portid, p->opt.device, pd->mac_addr, pd->pci_addr);
683  		RTE_LOG(INFO, USER1,"Port %d Link Up. Speed %u Mbps - %s\n",
684  							portid, link.link_speed,
685  					(link.link_duplex == ETH_LINK_FULL_DUPLEX) ?
686  						("full-duplex") : ("half-duplex\n"));
687  	}
688  	return ret;
689  }
690  pcap_t * pcap_dpdk_create(const char *device, char *ebuf, int *is_ours)
691  {
692  	pcap_t *p=NULL;
693  	*is_ours = 0;
694  	*is_ours = !strncmp(device, "dpdk:", 5);
695  	if (! *is_ours)
696  		return NULL;
697  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_dpdk);
698  	if (p == NULL)
699  		return NULL;
700  	p->activate_op = pcap_dpdk_activate;
701  	return p;
702  }
703  int pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *ebuf)
704  {
705  	int ret=0;
706  	unsigned int nb_ports = 0;
707  	char dpdk_name[DPDK_DEV_NAME_MAX];
708  	char dpdk_desc[DPDK_DEV_DESC_MAX];
709  	ETHER_ADDR_TYPE eth_addr;
710  	char mac_addr[DPDK_MAC_ADDR_SIZE];
711  	char pci_addr[DPDK_PCI_ADDR_SIZE];
712  	do{
713  		char dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];
714  		ret = dpdk_pre_init(dpdk_pre_init_errbuf, 1);
715  		if (ret < 0)
716  		{
717  			snprintf(ebuf, PCAP_ERRBUF_SIZE,
718  			    "Can't look for DPDK devices: %s",
719  			    dpdk_pre_init_errbuf);
720  			ret = PCAP_ERROR;
721  			break;
722  		}
723  		if (ret == 0)
724  		{
725  			break;
726  		}
727  		nb_ports = rte_eth_dev_count_avail();
728  		if (nb_ports == 0)
729  		{
730  			ret = 0;
731  			break;
732  		}
733  		for (unsigned int i=0; i<nb_ports; i++){
734  			snprintf(dpdk_name, DPDK_DEV_NAME_MAX-1,
735  			    "%s%u", DPDK_PREFIX, i);
736  			rte_eth_macaddr_get(i, &eth_addr);
737  			eth_addr_str(&eth_addr,mac_addr,DPDK_MAC_ADDR_SIZE);
738  			rte_eth_dev_get_name_by_port(i,pci_addr);
739  			snprintf(dpdk_desc,DPDK_DEV_DESC_MAX-1,"%s %s, MAC:%s, PCI:%s", DPDK_DESC, dpdk_name, mac_addr, pci_addr);
740  			if (pcap_add_dev(devlistp, dpdk_name, 0, dpdk_desc, ebuf)==NULL){
741  				ret = PCAP_ERROR;
742  				break;
743  			}
744  		}
745  	}while(0);
746  	return ret;
747  }
748  #ifdef DPDK_ONLY
749  int
750  pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
751  {
752  	return (0);
753  }
754  pcap_t *
755  pcap_create_interface(const char *device, char *errbuf)
756  {
757  	snprintf(errbuf, PCAP_ERRBUF_SIZE,
758  	    "This version of libpcap only supports DPDK");
759  	return NULL;
760  }
761  const char *
762  pcap_lib_version(void)
763  {
764  	return (PCAP_VERSION_STRING " (DPDK-only)");
765  }
766  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-trigtest.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dpdk.c</div>
                <div class="column column_space"><pre><code>91       long ltop = avma;
92       arg = mulsr(2L * m, divrs(gpi, n));
93       setlg(arg, prec);
94       gv = gf(arg, prec);
95       cval = cf(m, n);
96       gcval = dbltor(cval);
97       err = gsub(gcval, gv);
98       cerr = rtodbl(err);
99       avma = ltop;
</pre></code></div>
                <div class="column column_space"><pre><code>123  	p = errbuf + msglen;
124  	errbuflen_remaining = errbuflen - msglen;
125  	*p++ = ':';
126  	*p++ = ' ';
127  	*p = '\0';
128  	msglen += 2;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    