
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.111245465538089%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <limits.h>
3  #include <math.h>    
4  #include <stdio.h>
5  #include <stdlib.h>  
6  #include "src/mux/animi.h"
7  #include "src/utils/utils.h"
8  #include "src/webp/decode.h"
9  #include "src/webp/encode.h"
10  #include "src/webp/format_constants.h"
11  #include "src/webp/mux.h"
12  #if defined(_MSC_VER) && _MSC_VER < 1900
13  #define snprintf _snprintf
14  #endif
15  #define ERROR_STR_MAX_LENGTH 100
16  typedef struct {
17    int x_offset_, y_offset_, width_, height_;
18  } FrameRectangle;
19  typedef struct {
20    WebPMuxFrameInfo sub_frame_;  
21    WebPMuxFrameInfo key_frame_;  
22    int is_key_frame_;            
23  } EncodedFrame;
24  struct WebPAnimEncoder {
25    const int canvas_width_;                  
26    const int canvas_height_;                 
27    const WebPAnimEncoderOptions options_;    
28    FrameRectangle prev_rect_;          
29    WebPConfig last_config_;            
30    WebPConfig last_config_reversed_;   
31    WebPPicture* curr_canvas_;          
32    WebPPicture curr_canvas_copy_;      
33    int curr_canvas_copy_modified_;     
34    WebPPicture prev_canvas_;           
35    WebPPicture prev_canvas_disposed_;  
36    EncodedFrame* encoded_frames_;      
37    size_t size_;             
38    size_t start_;            
39    size_t count_;            
40    size_t flush_count_;      
41    int64_t best_delta_;      
42    int keyframe_;            
43    int count_since_key_frame_;     
44    int first_timestamp_;           
45    int prev_timestamp_;            
46    int prev_candidate_undecided_;  
47    int is_first_frame_;  
48    int got_null_frame_;  
49    size_t in_frame_count_;   
50    size_t out_frame_count_;  
51    WebPMux* mux_;        
52    char error_str_[ERROR_STR_MAX_LENGTH];  
53  };
54  #define DELTA_INFINITY      (1ULL << 32)
55  #define KEYFRAME_NONE       (-1)
56  static void ResetCounters(WebPAnimEncoder* const enc) {
57    enc->start_ = 0;
58    enc->count_ = 0;
59    enc->flush_count_ = 0;
60    enc->best_delta_ = DELTA_INFINITY;
61    enc->keyframe_ = KEYFRAME_NONE;
62  }
63  static void DisableKeyframes(WebPAnimEncoderOptions* const enc_options) {
64    enc_options->kmax = INT_MAX;
65    enc_options->kmin = enc_options->kmax - 1;
66  }
67  #define MAX_CACHED_FRAMES 30
68  static void SanitizeEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
69    int print_warning = enc_options->verbose;
70    if (enc_options->minimize_size) {
71      DisableKeyframes(enc_options);
72    }
73    if (enc_options->kmax == 1) {  
74      enc_options->kmin = 0;
75      enc_options->kmax = 0;
76      return;
77    } else if (enc_options->kmax <= 0) {
78      DisableKeyframes(enc_options);
79      print_warning = 0;
80    }
81    if (enc_options->kmin >= enc_options->kmax) {
82      enc_options->kmin = enc_options->kmax - 1;
83      if (print_warning) {
84        fprintf(stderr, "WARNING: Setting kmin = %d, so that kmin < kmax.\n",
85                enc_options->kmin);
86      }
87    } else {
88      const int kmin_limit = enc_options->kmax / 2 + 1;
89      if (enc_options->kmin < kmin_limit && kmin_limit < enc_options->kmax) {
90        enc_options->kmin = kmin_limit;
91        if (print_warning) {
92          fprintf(stderr,
93                  "WARNING: Setting kmin = %d, so that kmin >= kmax / 2 + 1.\n",
94                  enc_options->kmin);
95        }
96      }
97    }
98    if (enc_options->kmax - enc_options->kmin > MAX_CACHED_FRAMES) {
99      enc_options->kmin = enc_options->kmax - MAX_CACHED_FRAMES;
100      if (print_warning) {
101        fprintf(stderr,
102                "WARNING: Setting kmin = %d, so that kmax - kmin <= %d.\n",
103                enc_options->kmin, MAX_CACHED_FRAMES);
104      }
105    }
106    assert(enc_options->kmin < enc_options->kmax);
107  }
108  #undef MAX_CACHED_FRAMES
109  static void DefaultEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
110    enc_options->anim_params.loop_count = 0;
111    enc_options->anim_params.bgcolor = 0xffffffff;  
112    enc_options->minimize_size = 0;
113    DisableKeyframes(enc_options);
114    enc_options->allow_mixed = 0;
115    enc_options->verbose = 0;
116  }
117  int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions* enc_options,
118                                         int abi_version) {
119    if (enc_options == NULL ||
120        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
121      return 0;
122    }
123    DefaultEncoderOptions(enc_options);
124    return 1;
125  }
126  #define TRANSPARENT_COLOR   0x00000000
127  static void ClearRectangle(WebPPicture* const picture,
128                             int left, int top, int width, int height) {
129    int j;
130    for (j = top; j < top + height; ++j) {
131      uint32_t* const dst = picture->argb + j * picture->argb_stride;
132      int i;
133      for (i = left; i < left + width; ++i) {
134        dst[i] = TRANSPARENT_COLOR;
135      }
136    }
137  }
138  static void WebPUtilClearPic(WebPPicture* const picture,
139                               const FrameRectangle* const rect) {
140    if (rect != NULL) {
141      ClearRectangle(picture, rect->x_offset_, rect->y_offset_,
142                     rect->width_, rect->height_);
143    } else {
144      ClearRectangle(picture, 0, 0, picture->width, picture->height);
145    }
146  }
147  static void MarkNoError(WebPAnimEncoder* const enc) {
148    enc->error_str_[0] = '\0';  
149  }
150  static void MarkError(WebPAnimEncoder* const enc, const char* str) {
151    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s.", str) < 0) {
152      assert(0);  
153    }
154  }
155  static void MarkError2(WebPAnimEncoder* const enc,
156                         const char* str, int error_code) {
157    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s: %d.", str,
158                 error_code) < 0) {
159      assert(0);  
160    }
161  }
162  WebPAnimEncoder* WebPAnimEncoderNewInternal(
163      int width, int height, const WebPAnimEncoderOptions* enc_options,
164      int abi_version) {
165    WebPAnimEncoder* enc;
166    if (WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
167      return NULL;
168    }
169    if (width <= 0 || height <= 0 ||
170        (width * (uint64_t)height) >= MAX_IMAGE_AREA) {
171      return NULL;
172    }
173    enc = (WebPAnimEncoder*)WebPSafeCalloc(1, sizeof(*enc));
174    if (enc == NULL) return NULL;
175    enc->encoded_frames_ = NULL;
176    enc->mux_ = NULL;
177    MarkNoError(enc);
178    *(int*)&enc->canvas_width_ = width;
179    *(int*)&enc->canvas_height_ = height;
180    if (enc_options != NULL) {
181      *(WebPAnimEncoderOptions*)&enc->options_ = *enc_options;
182      SanitizeEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
183    } else {
184      DefaultEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
185    }
186    if (!WebPPictureInit(&enc->curr_canvas_copy_) ||
187        !WebPPictureInit(&enc->prev_canvas_) ||
188        !WebPPictureInit(&enc->prev_canvas_disposed_)) {
189      goto Err;
190    }
191    enc->curr_canvas_copy_.width = width;
192    enc->curr_canvas_copy_.height = height;
193    enc->curr_canvas_copy_.use_argb = 1;
194    if (!WebPPictureAlloc(&enc->curr_canvas_copy_) ||
195        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_) ||
196        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_disposed_)) {
197      goto Err;
198    }
199    WebPUtilClearPic(&enc->prev_canvas_, NULL);
200    enc->curr_canvas_copy_modified_ = 1;
201    ResetCounters(enc);
202    enc->size_ = enc->options_.kmax - enc->options_.kmin + 1;
203    if (enc->size_ < 2) enc->size_ = 2;
204    enc->encoded_frames_ =
205        (EncodedFrame*)WebPSafeCalloc(enc->size_, sizeof(*enc->encoded_frames_));
206    if (enc->encoded_frames_ == NULL) goto Err;
207    enc->mux_ = WebPMuxNew();
208    if (enc->mux_ == NULL) goto Err;
209    enc->count_since_key_frame_ = 0;
210    enc->first_timestamp_ = 0;
211    enc->prev_timestamp_ = 0;
212    enc->prev_candidate_undecided_ = 0;
213    enc->is_first_frame_ = 1;
214    enc->got_null_frame_ = 0;
215    return enc;  
216   Err:
217    WebPAnimEncoderDelete(enc);
218    return NULL;
219  }
220  static void FrameRelease(EncodedFrame* const encoded_frame) {
221    if (encoded_frame != NULL) {
222      WebPDataClear(&encoded_frame->sub_frame_.bitstream);
223      WebPDataClear(&encoded_frame->key_frame_.bitstream);
224      memset(encoded_frame, 0, sizeof(*encoded_frame));
225    }
226  }
227  void WebPAnimEncoderDelete(WebPAnimEncoder* enc) {
228    if (enc != NULL) {
229      WebPPictureFree(&enc->curr_canvas_copy_);
230      WebPPictureFree(&enc->prev_canvas_);
231      WebPPictureFree(&enc->prev_canvas_disposed_);
232      if (enc->encoded_frames_ != NULL) {
233        size_t i;
234        for (i = 0; i < enc->size_; ++i) {
235          FrameRelease(&enc->encoded_frames_[i]);
236        }
237        WebPSafeFree(enc->encoded_frames_);
238      }
239      WebPMuxDelete(enc->mux_);
240      WebPSafeFree(enc);
241    }
242  }
243  static EncodedFrame* GetFrame(const WebPAnimEncoder* const enc,
244                                size_t position) {
245    assert(enc->start_ + position < enc->size_);
246    return &enc->encoded_frames_[enc->start_ + position];
247  }
248  typedef int (*ComparePixelsFunc)(const uint32_t*, int, const uint32_t*, int,
249                                   int, int);
250  static WEBP_INLINE int ComparePixelsLossless(const uint32_t* src, int src_step,
251                                               const uint32_t* dst, int dst_step,
252                                               int length, int max_allowed_diff) {
253    (void)max_allowed_diff;
254    assert(length > 0);
255    while (length-- > 0) {
256      if (*src != *dst) {
257        return 0;
258      }
259      src += src_step;
260      dst += dst_step;
261    }
262    return 1;
263  }
264  static WEBP_INLINE int PixelsAreSimilar(uint32_t src, uint32_t dst,
265                                          int max_allowed_diff) {
266    const int src_a = (src >> 24) & 0xff;
267    const int src_r = (src >> 16) & 0xff;
268    const int src_g = (src >> 8) & 0xff;
269    const int src_b = (src >> 0) & 0xff;
270    const int dst_a = (dst >> 24) & 0xff;
271    const int dst_r = (dst >> 16) & 0xff;
272    const int dst_g = (dst >> 8) & 0xff;
273    const int dst_b = (dst >> 0) & 0xff;
274    return (src_a == dst_a) &&
275           (abs(src_r - dst_r) * dst_a <= (max_allowed_diff * 255)) &&
276           (abs(src_g - dst_g) * dst_a <= (max_allowed_diff * 255)) &&
277           (abs(src_b - dst_b) * dst_a <= (max_allowed_diff * 255));
278  }
279  static WEBP_INLINE int ComparePixelsLossy(const uint32_t* src, int src_step,
280                                            const uint32_t* dst, int dst_step,
281                                            int length, int max_allowed_diff) {
282    assert(length > 0);
283    while (length-- > 0) {
284      if (!PixelsAreSimilar(*src, *dst, max_allowed_diff)) {
285        return 0;
286      }
287      src += src_step;
288      dst += dst_step;
289    }
290    return 1;
291  }
292  static int IsEmptyRect(const FrameRectangle* const rect) {
293    return (rect->width_ == 0) || (rect->height_ == 0);
294  }
295  static int QualityToMaxDiff(float quality) {
296    const double val = pow(quality / 100., 0.5);
297    const double max_diff = 31 * (1 - val) + 1 * val;
298    return (int)(max_diff + 0.5);
299  }
300  static void MinimizeChangeRectangle(const WebPPicture* const src,
301                                      const WebPPicture* const dst,
302                                      FrameRectangle* const rect,
303                                      int is_lossless, float quality) {
304    int i, j;
305    const ComparePixelsFunc compare_pixels =
306        is_lossless ? ComparePixelsLossless : ComparePixelsLossy;
307    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
308    const int max_allowed_diff = is_lossless ? 0 : max_allowed_diff_lossy;
309    assert(src->width == dst->width && src->height == dst->height);
310    assert(rect->x_offset_ + rect->width_ <= dst->width);
311    assert(rect->y_offset_ + rect->height_ <= dst->height);
312    for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
313      const uint32_t* const src_argb =
314          &src->argb[rect->y_offset_ * src->argb_stride + i];
315      const uint32_t* const dst_argb =
316          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
317      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
318                         rect->height_, max_allowed_diff)) {
319        --rect->width_;  
320        ++rect->x_offset_;
321      } else {
322        break;
323      }
324    }
325    if (rect->width_ == 0) goto NoChange;
326    for (i = rect->x_offset_ + rect->width_ - 1; i >= rect->x_offset_; --i) {
327      const uint32_t* const src_argb =
328          &src->argb[rect->y_offset_ * src->argb_stride + i];
329      const uint32_t* const dst_argb =
330          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
331      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
332                         rect->height_, max_allowed_diff)) {
333        --rect->width_;  
334      } else {
335        break;
336      }
337    }
338    if (rect->width_ == 0) goto NoChange;
339    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
340      const uint32_t* const src_argb =
341          &src->argb[j * src->argb_stride + rect->x_offset_];
342      const uint32_t* const dst_argb =
343          &dst->argb[j * dst->argb_stride + rect->x_offset_];
344      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
345                         max_allowed_diff)) {
346        --rect->height_;  
347        ++rect->y_offset_;
348      } else {
349        break;
350      }
351    }
352    if (rect->height_ == 0) goto NoChange;
353    for (j = rect->y_offset_ + rect->height_ - 1; j >= rect->y_offset_; --j) {
354      const uint32_t* const src_argb =
355          &src->argb[j * src->argb_stride + rect->x_offset_];
356      const uint32_t* const dst_argb =
357          &dst->argb[j * dst->argb_stride + rect->x_offset_];
358      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
359                         max_allowed_diff)) {
360        --rect->height_;  
361      } else {
362        break;
363      }
364    }
365    if (rect->height_ == 0) goto NoChange;
366    if (IsEmptyRect(rect)) {
367   NoChange:
368      rect->x_offset_ = 0;
369      rect->y_offset_ = 0;
370      rect->width_ = 0;
371      rect->height_ = 0;
372    }
373  }
374  static WEBP_INLINE void SnapToEvenOffsets(FrameRectangle* const rect) {
375    rect->width_ += (rect->x_offset_ & 1);
376    rect->height_ += (rect->y_offset_ & 1);
377    rect->x_offset_ &= ~1;
378    rect->y_offset_ &= ~1;
379  }
380  typedef struct {
381    int should_try_;               
382    int empty_rect_allowed_;       
383    FrameRectangle rect_ll_;       
384    WebPPicture sub_frame_ll_;     
385    FrameRectangle rect_lossy_;    
386    WebPPicture sub_frame_lossy_;  
387  } SubFrameParams;
388  static int SubFrameParamsInit(SubFrameParams* const params,
389                                int should_try, int empty_rect_allowed) {
390    params->should_try_ = should_try;
391    params->empty_rect_allowed_ = empty_rect_allowed;
392    if (!WebPPictureInit(&params->sub_frame_ll_) ||
393        !WebPPictureInit(&params->sub_frame_lossy_)) {
394      return 0;
395    }
396    return 1;
397  }
398  static void SubFrameParamsFree(SubFrameParams* const params) {
399    WebPPictureFree(&params->sub_frame_ll_);
400    WebPPictureFree(&params->sub_frame_lossy_);
401  }
402  static int GetSubRect(const WebPPicture* const prev_canvas,
403                        const WebPPicture* const curr_canvas, int is_key_frame,
404                        int is_first_frame, int empty_rect_allowed,
405                        int is_lossless, float quality,
406                        FrameRectangle* const rect,
407                        WebPPicture* const sub_frame) {
408    if (!is_key_frame || is_first_frame) {  
409      MinimizeChangeRectangle(prev_canvas, curr_canvas, rect,
410                              is_lossless, quality);
411    }
412    if (IsEmptyRect(rect)) {
413      if (empty_rect_allowed) {  
414        return 1;
415      } else {                   
416        rect->width_ = 1;
417        rect->height_ = 1;
418        assert(rect->x_offset_ == 0);
419        assert(rect->y_offset_ == 0);
420      }
421    }
422    SnapToEvenOffsets(rect);
423    return WebPPictureView(curr_canvas, rect->x_offset_, rect->y_offset_,
424                           rect->width_, rect->height_, sub_frame);
425  }
426  static int GetSubRects(const WebPPicture* const prev_canvas,
427                         const WebPPicture* const curr_canvas, int is_key_frame,
428                         int is_first_frame, float quality,
429                         SubFrameParams* const params) {
430    params->rect_ll_.x_offset_ = 0;
431    params->rect_ll_.y_offset_ = 0;
432    params->rect_ll_.width_ = curr_canvas->width;
433    params->rect_ll_.height_ = curr_canvas->height;
434    if (!GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
435                    params->empty_rect_allowed_, 1, quality,
436                    &params->rect_ll_, &params->sub_frame_ll_)) {
437      return 0;
438    }
439    params->rect_lossy_ = params->rect_ll_;  
440    return GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
441                      params->empty_rect_allowed_, 0, quality,
442                      &params->rect_lossy_, &params->sub_frame_lossy_);
443  }
444  static WEBP_INLINE int clip(int v, int min_v, int max_v) {
445    return (v < min_v) ? min_v : (v > max_v) ? max_v : v;
446  }
447  int WebPAnimEncoderRefineRect(
448      const WebPPicture* const prev_canvas, const WebPPicture* const curr_canvas,
449      int is_lossless, float quality, int* const x_offset, int* const y_offset,
450      int* const width, int* const height) {
451    FrameRectangle rect;
452    const int right = clip(*x_offset + *width, 0, curr_canvas->width);
453    const int left = clip(*x_offset, 0, curr_canvas->width - 1);
454    const int bottom = clip(*y_offset + *height, 0, curr_canvas->height);
455    const int top = clip(*y_offset, 0, curr_canvas->height - 1);
456    if (prev_canvas == NULL || curr_canvas == NULL ||
457        prev_canvas->width != curr_canvas->width ||
458        prev_canvas->height != curr_canvas->height ||
459        !prev_canvas->use_argb || !curr_canvas->use_argb) {
460      return 0;
461    }
462    rect.x_offset_ = left;
463    rect.y_offset_ = top;
464    rect.width_ = clip(right - left, 0, curr_canvas->width - rect.x_offset_);
465    rect.height_ = clip(bottom - top, 0, curr_canvas->height - rect.y_offset_);
466    MinimizeChangeRectangle(prev_canvas, curr_canvas, &rect, is_lossless,
467                            quality);
468    SnapToEvenOffsets(&rect);
469    *x_offset = rect.x_offset_;
470    *y_offset = rect.y_offset_;
471    *width = rect.width_;
472    *height = rect.height_;
473    return 1;
474  }
475  static void DisposeFrameRectangle(int dispose_method,
476                                    const FrameRectangle* const rect,
477                                    WebPPicture* const curr_canvas) {
478    assert(rect != NULL);
479    if (dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
480      WebPUtilClearPic(curr_canvas, rect);
481    }
482  }
483  static uint32_t RectArea(const FrameRectangle* const rect) {
484    return (uint32_t)rect->width_ * rect->height_;
485  }
486  static int IsLosslessBlendingPossible(const WebPPicture* const src,
487                                        const WebPPicture* const dst,
488                                        const FrameRectangle* const rect) {
489    int i, j;
490    assert(src->width == dst->width && src->height == dst->height);
491    assert(rect->x_offset_ + rect->width_ <= dst->width);
492    assert(rect->y_offset_ + rect->height_ <= dst->height);
493    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
494      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
495        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
496        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
497        const uint32_t dst_alpha = dst_pixel >> 24;
498        if (dst_alpha != 0xff && src_pixel != dst_pixel) {
499          return 0;
500        }
501      }
502    }
503    return 1;
504  }
505  static int IsLossyBlendingPossible(const WebPPicture* const src,
506                                     const WebPPicture* const dst,
507                                     const FrameRectangle* const rect,
508                                     float quality) {
509    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
510    int i, j;
511    assert(src->width == dst->width && src->height == dst->height);
512    assert(rect->x_offset_ + rect->width_ <= dst->width);
513    assert(rect->y_offset_ + rect->height_ <= dst->height);
514    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
515      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
516        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
517        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
518        const uint32_t dst_alpha = dst_pixel >> 24;
519        if (dst_alpha != 0xff &&
520            !PixelsAreSimilar(src_pixel, dst_pixel, max_allowed_diff_lossy)) {
521          return 0;
522        }
523      }
524    }
525    return 1;
526  }
527  static int IncreaseTransparency(const WebPPicture* const src,
528                                  const FrameRectangle* const rect,
529                                  WebPPicture* const dst) {
530    int i, j;
531    int modified = 0;
532    assert(src != NULL && dst != NULL && rect != NULL);
533    assert(src->width == dst->width && src->height == dst->height);
534    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
535      const uint32_t* const psrc = src->argb + j * src->argb_stride;
536      uint32_t* const pdst = dst->argb + j * dst->argb_stride;
537      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
538        if (psrc[i] == pdst[i] && pdst[i] != TRANSPARENT_COLOR) {
539          pdst[i] = TRANSPARENT_COLOR;
540          modified = 1;
541        }
542      }
543    }
544    return modified;
545  }
546  #undef TRANSPARENT_COLOR
547  static int FlattenSimilarBlocks(const WebPPicture* const src,
548                                  const FrameRectangle* const rect,
549                                  WebPPicture* const dst, float quality) {
550    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
551    int i, j;
552    int modified = 0;
553    const int block_size = 8;
554    const int y_start = (rect->y_offset_ + block_size) & ~(block_size - 1);
555    const int y_end = (rect->y_offset_ + rect->height_) & ~(block_size - 1);
556    const int x_start = (rect->x_offset_ + block_size) & ~(block_size - 1);
557    const int x_end = (rect->x_offset_ + rect->width_) & ~(block_size - 1);
558    assert(src != NULL && dst != NULL && rect != NULL);
559    assert(src->width == dst->width && src->height == dst->height);
560    assert((block_size & (block_size - 1)) == 0);  
561    for (j = y_start; j < y_end; j += block_size) {
562      for (i = x_start; i < x_end; i += block_size) {
563        int cnt = 0;
564        int avg_r = 0, avg_g = 0, avg_b = 0;
565        int x, y;
566        const uint32_t* const psrc = src->argb + j * src->argb_stride + i;
567        uint32_t* const pdst = dst->argb + j * dst->argb_stride + i;
568        for (y = 0; y < block_size; ++y) {
569          for (x = 0; x < block_size; ++x) {
570            const uint32_t src_pixel = psrc[x + y * src->argb_stride];
571            const int alpha = src_pixel >> 24;
572            if (alpha == 0xff &&
573                PixelsAreSimilar(src_pixel, pdst[x + y * dst->argb_stride],
574                                 max_allowed_diff_lossy)) {
575              ++cnt;
576              avg_r += (src_pixel >> 16) & 0xff;
577              avg_g += (src_pixel >> 8) & 0xff;
578              avg_b += (src_pixel >> 0) & 0xff;
579            }
580          }
581        }
582        if (cnt == block_size * block_size) {
583          const uint32_t color = (0x00          << 24) |
584                                 ((avg_r / cnt) << 16) |
585                                 ((avg_g / cnt) <<  8) |
586                                 ((avg_b / cnt) <<  0);
587          for (y = 0; y < block_size; ++y) {
588            for (x = 0; x < block_size; ++x) {
589              pdst[x + y * dst->argb_stride] = color;
590            }
591          }
592          modified = 1;
593        }
594      }
595    }
596    return modified;
597  }
598  static int EncodeFrame(const WebPConfig* const config, WebPPicture* const pic,
599                         WebPMemoryWriter* const memory) {
600    pic->use_argb = 1;
601    pic->writer = WebPMemoryWrite;
602    pic->custom_ptr = memory;
603    if (!WebPEncode(config, pic)) {
604      return 0;
605    }
606    return 1;
607  }
608  typedef struct {
609    WebPMemoryWriter  mem_;
610    WebPMuxFrameInfo  info_;
611    FrameRectangle    rect_;
612    int               evaluate_;  
613  } Candidate;
614  static WebPEncodingError EncodeCandidate(WebPPicture* const sub_frame,
615                                           const FrameRectangle* const rect,
616                                           const WebPConfig* const encoder_config,
617                                           int use_blending,
618                                           Candidate* const candidate) {
619    WebPConfig config = *encoder_config;
620    WebPEncodingError error_code = VP8_ENC_OK;
621    assert(candidate != NULL);
622    memset(candidate, 0, sizeof(*candidate));
623    candidate->rect_ = *rect;
<span onclick='openModal()' class='match'>624    candidate->info_.id = WEBP_CHUNK_ANMF;
625    candidate->info_.x_offset = rect->x_offset_;
626    candidate->info_.y_offset = rect->y_offset_;
627    candidate->info_.dispose_method = WEBP_MUX_DISPOSE_NONE;  
628    candidate->info_.blend_method =
629        use_blending ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
630    candidate->info_.duration = 0;  
631    WebPMemoryWriterInit(&candidate->mem_);
632    if (!config.lossless && use_blending) {
</span>633      config.autofilter = 0;
634      config.filter_strength = 0;
635    }
636    if (!EncodeFrame(&config, sub_frame, &candidate->mem_)) {
637      error_code = sub_frame->error_code;
638      goto Err;
639    }
640    candidate->evaluate_ = 1;
641    return error_code;
642   Err:
643    WebPMemoryWriterClear(&candidate->mem_);
644    return error_code;
645  }
646  static void CopyCurrentCanvas(WebPAnimEncoder* const enc) {
647    if (enc->curr_canvas_copy_modified_) {
648      WebPCopyPixels(enc->curr_canvas_, &enc->curr_canvas_copy_);
649      enc->curr_canvas_copy_.progress_hook = enc->curr_canvas_->progress_hook;
650      enc->curr_canvas_copy_.user_data = enc->curr_canvas_->user_data;
651      enc->curr_canvas_copy_modified_ = 0;
652    }
653  }
654  enum {
655    LL_DISP_NONE = 0,
656    LL_DISP_BG,
657    LOSSY_DISP_NONE,
658    LOSSY_DISP_BG,
659    CANDIDATE_COUNT
660  };
661  #define MIN_COLORS_LOSSY     31  
662  #define MAX_COLORS_LOSSLESS 194  
663  static WebPEncodingError GenerateCandidates(
664      WebPAnimEncoder* const enc, Candidate candidates[CANDIDATE_COUNT],
665      WebPMuxAnimDispose dispose_method, int is_lossless, int is_key_frame,
666      SubFrameParams* const params,
667      const WebPConfig* const config_ll, const WebPConfig* const config_lossy) {
668    WebPEncodingError error_code = VP8_ENC_OK;
669    const int is_dispose_none = (dispose_method == WEBP_MUX_DISPOSE_NONE);
670    Candidate* const candidate_ll =
671        is_dispose_none ? &candidates[LL_DISP_NONE] : &candidates[LL_DISP_BG];
672    Candidate* const candidate_lossy = is_dispose_none
673                                       ? &candidates[LOSSY_DISP_NONE]
674                                       : &candidates[LOSSY_DISP_BG];
675    WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
676    const WebPPicture* const prev_canvas =
677        is_dispose_none ? &enc->prev_canvas_ : &enc->prev_canvas_disposed_;
678    int use_blending_ll, use_blending_lossy;
679    int evaluate_ll, evaluate_lossy;
680    CopyCurrentCanvas(enc);
681    use_blending_ll =
682        !is_key_frame &&
683        IsLosslessBlendingPossible(prev_canvas, curr_canvas, &params->rect_ll_);
684    use_blending_lossy =
685        !is_key_frame &&
686        IsLossyBlendingPossible(prev_canvas, curr_canvas, &params->rect_lossy_,
687                                config_lossy->quality);
688    if (!enc->options_.allow_mixed) {
689      evaluate_ll = is_lossless;
690      evaluate_lossy = !is_lossless;
691    } else if (enc->options_.minimize_size) {
692      evaluate_ll = 1;
693      evaluate_lossy = 1;
694    } else {  
695      const int num_colors = WebPGetColorPalette(&params->sub_frame_ll_, NULL);
696      evaluate_ll = (num_colors < MAX_COLORS_LOSSLESS);
697      evaluate_lossy = (num_colors >= MIN_COLORS_LOSSY);
698    }
699    if (evaluate_ll) {
700      CopyCurrentCanvas(enc);
701      if (use_blending_ll) {
702        enc->curr_canvas_copy_modified_ =
703            IncreaseTransparency(prev_canvas, &params->rect_ll_, curr_canvas);
704      }
705      error_code = EncodeCandidate(&params->sub_frame_ll_, &params->rect_ll_,
706                                   config_ll, use_blending_ll, candidate_ll);
707      if (error_code != VP8_ENC_OK) return error_code;
708    }
709    if (evaluate_lossy) {
710      CopyCurrentCanvas(enc);
711      if (use_blending_lossy) {
712        enc->curr_canvas_copy_modified_ =
713            FlattenSimilarBlocks(prev_canvas, &params->rect_lossy_, curr_canvas,
714                                 config_lossy->quality);
715      }
716      error_code =
717          EncodeCandidate(&params->sub_frame_lossy_, &params->rect_lossy_,
718                          config_lossy, use_blending_lossy, candidate_lossy);
719      if (error_code != VP8_ENC_OK) return error_code;
720      enc->curr_canvas_copy_modified_ = 1;
721    }
722    return error_code;
723  }
724  #undef MIN_COLORS_LOSSY
725  #undef MAX_COLORS_LOSSLESS
726  static void GetEncodedData(const WebPMemoryWriter* const memory,
727                             WebPData* const encoded_data) {
728    encoded_data->bytes = memory->mem;
729    encoded_data->size  = memory->size;
730  }
731  static void SetPreviousDisposeMethod(WebPAnimEncoder* const enc,
732                                       WebPMuxAnimDispose dispose_method) {
733    const size_t position = enc->count_ - 2;
734    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
735    assert(enc->count_ >= 2);  
736    if (enc->prev_candidate_undecided_) {
737      assert(dispose_method == WEBP_MUX_DISPOSE_NONE);
738      prev_enc_frame->sub_frame_.dispose_method = dispose_method;
739      prev_enc_frame->key_frame_.dispose_method = dispose_method;
740    } else {
741      WebPMuxFrameInfo* const prev_info = prev_enc_frame->is_key_frame_
742                                          ? &prev_enc_frame->key_frame_
743                                          : &prev_enc_frame->sub_frame_;
744      prev_info->dispose_method = dispose_method;
745    }
746  }
747  static int IncreasePreviousDuration(WebPAnimEncoder* const enc, int duration) {
748    const size_t position = enc->count_ - 1;
749    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
750    int new_duration;
751    assert(enc->count_ >= 1);
752    assert(prev_enc_frame->sub_frame_.duration ==
753           prev_enc_frame->key_frame_.duration);
754    assert(prev_enc_frame->sub_frame_.duration ==
755           (prev_enc_frame->sub_frame_.duration & (MAX_DURATION - 1)));
756    assert(duration == (duration & (MAX_DURATION - 1)));
757    new_duration = prev_enc_frame->sub_frame_.duration + duration;
758    if (new_duration >= MAX_DURATION) {  
759      const FrameRectangle rect = { 0, 0, 1, 1 };
760      const uint8_t lossless_1x1_bytes[] = {
761        0x52, 0x49, 0x46, 0x46, 0x14, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
762        0x56, 0x50, 0x38, 0x4c, 0x08, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
763        0x10, 0x88, 0x88, 0x08
764      };
765      const WebPData lossless_1x1 = {
766          lossless_1x1_bytes, sizeof(lossless_1x1_bytes)
767      };
768      const uint8_t lossy_1x1_bytes[] = {
769        0x52, 0x49, 0x46, 0x46, 0x40, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
770        0x56, 0x50, 0x38, 0x58, 0x0a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
771        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x4c, 0x50, 0x48, 0x02, 0x00,
772        0x00, 0x00, 0x00, 0x00, 0x56, 0x50, 0x38, 0x20, 0x18, 0x00, 0x00, 0x00,
773        0x30, 0x01, 0x00, 0x9d, 0x01, 0x2a, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00,
774        0x34, 0x25, 0xa4, 0x00, 0x03, 0x70, 0x00, 0xfe, 0xfb, 0xfd, 0x50, 0x00
775      };
776      const WebPData lossy_1x1 = { lossy_1x1_bytes, sizeof(lossy_1x1_bytes) };
777      const int can_use_lossless =
778          (enc->last_config_.lossless || enc->options_.allow_mixed);
779      EncodedFrame* const curr_enc_frame = GetFrame(enc, enc->count_);
780      curr_enc_frame->is_key_frame_ = 0;
781      curr_enc_frame->sub_frame_.id = WEBP_CHUNK_ANMF;
782      curr_enc_frame->sub_frame_.x_offset = 0;
783      curr_enc_frame->sub_frame_.y_offset = 0;
784      curr_enc_frame->sub_frame_.dispose_method = WEBP_MUX_DISPOSE_NONE;
785      curr_enc_frame->sub_frame_.blend_method = WEBP_MUX_BLEND;
786      curr_enc_frame->sub_frame_.duration = duration;
787      if (!WebPDataCopy(can_use_lossless ? &lossless_1x1 : &lossy_1x1,
788                        &curr_enc_frame->sub_frame_.bitstream)) {
789        return 0;
790      }
791      ++enc->count_;
792      ++enc->count_since_key_frame_;
793      enc->flush_count_ = enc->count_ - 1;
794      enc->prev_candidate_undecided_ = 0;
795      enc->prev_rect_ = rect;
796    } else {                           
797      prev_enc_frame->sub_frame_.duration = new_duration;
798      prev_enc_frame->key_frame_.duration = new_duration;
799    }
800    return 1;
801  }
802  static void PickBestCandidate(WebPAnimEncoder* const enc,
803                                Candidate* const candidates, int is_key_frame,
804                                EncodedFrame* const encoded_frame) {
805    int i;
806    int best_idx = -1;
807    size_t best_size = ~0;
808    for (i = 0; i < CANDIDATE_COUNT; ++i) {
809      if (candidates[i].evaluate_) {
810        const size_t candidate_size = candidates[i].mem_.size;
811        if (candidate_size < best_size) {
812          best_idx = i;
813          best_size = candidate_size;
814        }
815      }
816    }
817    assert(best_idx != -1);
818    for (i = 0; i < CANDIDATE_COUNT; ++i) {
819      if (candidates[i].evaluate_) {
820        if (i == best_idx) {
821          WebPMuxFrameInfo* const dst = is_key_frame
822                                        ? &encoded_frame->key_frame_
823                                        : &encoded_frame->sub_frame_;
824          *dst = candidates[i].info_;
825          GetEncodedData(&candidates[i].mem_, &dst->bitstream);
826          if (!is_key_frame) {
827            const WebPMuxAnimDispose prev_dispose_method =
828                (best_idx == LL_DISP_NONE || best_idx == LOSSY_DISP_NONE)
829                    ? WEBP_MUX_DISPOSE_NONE
830                    : WEBP_MUX_DISPOSE_BACKGROUND;
831            SetPreviousDisposeMethod(enc, prev_dispose_method);
832          }
833          enc->prev_rect_ = candidates[i].rect_;  
834        } else {
835          WebPMemoryWriterClear(&candidates[i].mem_);
836          candidates[i].evaluate_ = 0;
837        }
838      }
839    }
840  }
841  static WebPEncodingError SetFrame(WebPAnimEncoder* const enc,
842                                    const WebPConfig* const config,
843                                    int is_key_frame,
844                                    EncodedFrame* const encoded_frame,
845                                    int* const frame_skipped) {
846    int i;
847    WebPEncodingError error_code = VP8_ENC_OK;
848    const WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
849    const WebPPicture* const prev_canvas = &enc->prev_canvas_;
850    Candidate candidates[CANDIDATE_COUNT];
851    const int is_lossless = config->lossless;
852    const int consider_lossless = is_lossless || enc->options_.allow_mixed;
853    const int consider_lossy = !is_lossless || enc->options_.allow_mixed;
854    const int is_first_frame = enc->is_first_frame_;
855    const int empty_rect_allowed_none = !is_first_frame;
856    const int empty_rect_allowed_bg = 0;
857    const int dispose_bg_possible =
858        !is_key_frame && !enc->prev_candidate_undecided_;
859    SubFrameParams dispose_none_params;
860    SubFrameParams dispose_bg_params;
861    WebPConfig config_ll = *config;
862    WebPConfig config_lossy = *config;
863    config_ll.lossless = 1;
864    config_lossy.lossless = 0;
865    enc->last_config_ = *config;
866    enc->last_config_reversed_ = config->lossless ? config_lossy : config_ll;
867    *frame_skipped = 0;
868    if (!SubFrameParamsInit(&dispose_none_params, 1, empty_rect_allowed_none) ||
869        !SubFrameParamsInit(&dispose_bg_params, 0, empty_rect_allowed_bg)) {
870      return VP8_ENC_ERROR_INVALID_CONFIGURATION;
871    }
872    memset(candidates, 0, sizeof(candidates));
873    if (!GetSubRects(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
874                     config_lossy.quality, &dispose_none_params)) {
875      error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
876      goto Err;
877    }
878    if ((consider_lossless && IsEmptyRect(&dispose_none_params.rect_ll_)) ||
879        (consider_lossy && IsEmptyRect(&dispose_none_params.rect_lossy_))) {
880      assert(empty_rect_allowed_none);
881      *frame_skipped = 1;
882      goto End;
883    }
884    if (dispose_bg_possible) {
885      WebPPicture* const prev_canvas_disposed = &enc->prev_canvas_disposed_;
886      WebPCopyPixels(prev_canvas, prev_canvas_disposed);
887      DisposeFrameRectangle(WEBP_MUX_DISPOSE_BACKGROUND, &enc->prev_rect_,
888                            prev_canvas_disposed);
889      if (!GetSubRects(prev_canvas_disposed, curr_canvas, is_key_frame,
890                       is_first_frame, config_lossy.quality,
891                       &dispose_bg_params)) {
892        error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
893        goto Err;
894      }
895      assert(!IsEmptyRect(&dispose_bg_params.rect_ll_));
896      assert(!IsEmptyRect(&dispose_bg_params.rect_lossy_));
897      if (enc->options_.minimize_size) {  
898        dispose_bg_params.should_try_ = 1;
899        dispose_none_params.should_try_ = 1;
900      } else if ((is_lossless &&
901                  RectArea(&dispose_bg_params.rect_ll_) <
902                      RectArea(&dispose_none_params.rect_ll_)) ||
903                 (!is_lossless &&
904                  RectArea(&dispose_bg_params.rect_lossy_) <
905                      RectArea(&dispose_none_params.rect_lossy_))) {
906        dispose_bg_params.should_try_ = 1;  
907        dispose_none_params.should_try_ = 0;
908      }
909    }
910    if (dispose_none_params.should_try_) {
911      error_code = GenerateCandidates(
912          enc, candidates, WEBP_MUX_DISPOSE_NONE, is_lossless, is_key_frame,
913          &dispose_none_params, &config_ll, &config_lossy);
914      if (error_code != VP8_ENC_OK) goto Err;
915    }
916    if (dispose_bg_params.should_try_) {
917      assert(!enc->is_first_frame_);
918      assert(dispose_bg_possible);
919      error_code = GenerateCandidates(
920          enc, candidates, WEBP_MUX_DISPOSE_BACKGROUND, is_lossless, is_key_frame,
921          &dispose_bg_params, &config_ll, &config_lossy);
922      if (error_code != VP8_ENC_OK) goto Err;
923    }
924    PickBestCandidate(enc, candidates, is_key_frame, encoded_frame);
925    goto End;
926   Err:
927    for (i = 0; i < CANDIDATE_COUNT; ++i) {
928      if (candidates[i].evaluate_) {
929        WebPMemoryWriterClear(&candidates[i].mem_);
930      }
931    }
932   End:
933    SubFrameParamsFree(&dispose_none_params);
934    SubFrameParamsFree(&dispose_bg_params);
935    return error_code;
936  }
937  static int64_t KeyFramePenalty(const EncodedFrame* const encoded_frame) {
938    return ((int64_t)encoded_frame->key_frame_.bitstream.size -
939            encoded_frame->sub_frame_.bitstream.size);
940  }
941  static int CacheFrame(WebPAnimEncoder* const enc,
942                        const WebPConfig* const config) {
943    int ok = 0;
944    int frame_skipped = 0;
945    WebPEncodingError error_code = VP8_ENC_OK;
946    const size_t position = enc->count_;
947    EncodedFrame* const encoded_frame = GetFrame(enc, position);
948    ++enc->count_;
949    if (enc->is_first_frame_) {  
950      error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
951      if (error_code != VP8_ENC_OK) goto End;
952      assert(frame_skipped == 0);  
953      assert(position == 0 && enc->count_ == 1);
954      encoded_frame->is_key_frame_ = 1;
955      enc->flush_count_ = 0;
956      enc->count_since_key_frame_ = 0;
957      enc->prev_candidate_undecided_ = 0;
958    } else {
959      ++enc->count_since_key_frame_;
960      if (enc->count_since_key_frame_ <= enc->options_.kmin) {
961        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
962        if (error_code != VP8_ENC_OK) goto End;
963        if (frame_skipped) goto Skip;
964        encoded_frame->is_key_frame_ = 0;
965        enc->flush_count_ = enc->count_ - 1;
966        enc->prev_candidate_undecided_ = 0;
967      } else {
968        int64_t curr_delta;
969        FrameRectangle prev_rect_key, prev_rect_sub;
970        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
971        if (error_code != VP8_ENC_OK) goto End;
972        if (frame_skipped) goto Skip;
973        prev_rect_sub = enc->prev_rect_;
974        error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
975        if (error_code != VP8_ENC_OK) goto End;
976        assert(frame_skipped == 0);  
977        prev_rect_key = enc->prev_rect_;
978        curr_delta = KeyFramePenalty(encoded_frame);
979        if (curr_delta <= enc->best_delta_) {  
980          if (enc->keyframe_ != KEYFRAME_NONE) {
981            EncodedFrame* const old_keyframe = GetFrame(enc, enc->keyframe_);
982            assert(old_keyframe->is_key_frame_);
983            old_keyframe->is_key_frame_ = 0;
984          }
985          encoded_frame->is_key_frame_ = 1;
986          enc->prev_candidate_undecided_ = 1;
987          enc->keyframe_ = (int)position;
988          enc->best_delta_ = curr_delta;
989          enc->flush_count_ = enc->count_ - 1;  
990        } else {
991          encoded_frame->is_key_frame_ = 0;
992          enc->prev_candidate_undecided_ = 0;
993        }
994        if (enc->count_since_key_frame_ >= enc->options_.kmax) {
995          enc->flush_count_ = enc->count_ - 1;
996          enc->count_since_key_frame_ = 0;
997          enc->keyframe_ = KEYFRAME_NONE;
998          enc->best_delta_ = DELTA_INFINITY;
999        }
1000        if (!enc->prev_candidate_undecided_) {
1001          enc->prev_rect_ =
1002              encoded_frame->is_key_frame_ ? prev_rect_key : prev_rect_sub;
1003        }
1004      }
1005    }
1006    WebPCopyPixels(enc->curr_canvas_, &enc->prev_canvas_);
1007    enc->is_first_frame_ = 0;
1008   Skip:
1009    ok = 1;
1010    ++enc->in_frame_count_;
1011   End:
1012    if (!ok || frame_skipped) {
1013      FrameRelease(encoded_frame);
1014      --enc->count_;
1015      if (!enc->is_first_frame_) --enc->count_since_key_frame_;
1016      if (!ok) {
1017        MarkError2(enc, "ERROR adding frame. WebPEncodingError", error_code);
1018      }
1019    }
1020    enc->curr_canvas_->error_code = error_code;   
1021    assert(ok || error_code != VP8_ENC_OK);
1022    return ok;
1023  }
1024  static int FlushFrames(WebPAnimEncoder* const enc) {
1025    while (enc->flush_count_ > 0) {
1026      WebPMuxError err;
1027      EncodedFrame* const curr = GetFrame(enc, 0);
1028      const WebPMuxFrameInfo* const info =
1029          curr->is_key_frame_ ? &curr->key_frame_ : &curr->sub_frame_;
1030      assert(enc->mux_ != NULL);
1031      err = WebPMuxPushFrame(enc->mux_, info, 1);
1032      if (err != WEBP_MUX_OK) {
1033        MarkError2(enc, "ERROR adding frame. WebPMuxError", err);
1034        return 0;
1035      }
1036      if (enc->options_.verbose) {
1037        fprintf(stderr, "INFO: Added frame. offset:%d,%d dispose:%d blend:%d\n",
1038                info->x_offset, info->y_offset, info->dispose_method,
1039                info->blend_method);
1040      }
1041      ++enc->out_frame_count_;
1042      FrameRelease(curr);
1043      ++enc->start_;
1044      --enc->flush_count_;
1045      --enc->count_;
1046      if (enc->keyframe_ != KEYFRAME_NONE) --enc->keyframe_;
1047    }
1048    if (enc->count_ == 1 && enc->start_ != 0) {
1049      const int enc_start_tmp = (int)enc->start_;
1050      EncodedFrame temp = enc->encoded_frames_[0];
1051      enc->encoded_frames_[0] = enc->encoded_frames_[enc_start_tmp];
1052      enc->encoded_frames_[enc_start_tmp] = temp;
1053      FrameRelease(&enc->encoded_frames_[enc_start_tmp]);
1054      enc->start_ = 0;
1055    }
1056    return 1;
1057  }
1058  #undef DELTA_INFINITY
1059  #undef KEYFRAME_NONE
1060  int WebPAnimEncoderAdd(WebPAnimEncoder* enc, WebPPicture* frame, int timestamp,
1061                         const WebPConfig* encoder_config) {
1062    WebPConfig config;
1063    int ok;
1064    if (enc == NULL) {
1065      return 0;
1066    }
1067    MarkNoError(enc);
1068    if (!enc->is_first_frame_) {
1069      const uint32_t prev_frame_duration =
1070          (uint32_t)timestamp - enc->prev_timestamp_;
1071      if (prev_frame_duration >= MAX_DURATION) {
1072        if (frame != NULL) {
1073          frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1074        }
1075        MarkError(enc, "ERROR adding frame: timestamps must be non-decreasing");
1076        return 0;
1077      }
1078      if (!IncreasePreviousDuration(enc, (int)prev_frame_duration)) {
1079        return 0;
1080      }
1081    } else {
1082      enc->first_timestamp_ = timestamp;
1083    }
1084    if (frame == NULL) {  
1085      enc->got_null_frame_ = 1;
1086      enc->prev_timestamp_ = timestamp;
1087      return 1;
1088    }
1089    if (frame->width != enc->canvas_width_ ||
1090        frame->height != enc->canvas_height_) {
1091      frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1092      MarkError(enc, "ERROR adding frame: Invalid frame dimensions");
1093      return 0;
1094    }
1095    if (!frame->use_argb) {  
1096      if (enc->options_.verbose) {
1097        fprintf(stderr, "WARNING: Converting frame from YUV(A) to ARGB format; "
1098                "this incurs a small loss.\n");
1099      }
1100      if (!WebPPictureYUVAToARGB(frame)) {
1101        MarkError(enc, "ERROR converting frame from YUV(A) to ARGB");
1102        return 0;
1103      }
1104    }
1105    if (encoder_config != NULL) {
1106      if (!WebPValidateConfig(encoder_config)) {
1107        MarkError(enc, "ERROR adding frame: Invalid WebPConfig");
1108        return 0;
1109      }
1110      config = *encoder_config;
1111    } else {
1112      WebPConfigInit(&config);
1113      config.lossless = 1;
1114    }
1115    assert(enc->curr_canvas_ == NULL);
1116    enc->curr_canvas_ = frame;  
1117    assert(enc->curr_canvas_copy_modified_ == 1);
1118    CopyCurrentCanvas(enc);
1119    ok = CacheFrame(enc, &config) && FlushFrames(enc);
1120    enc->curr_canvas_ = NULL;
1121    enc->curr_canvas_copy_modified_ = 1;
1122    if (ok) {
1123      enc->prev_timestamp_ = timestamp;
1124    }
1125    return ok;
1126  }
1127  static int DecodeFrameOntoCanvas(const WebPMuxFrameInfo* const frame,
1128                                   WebPPicture* const canvas) {
1129    const WebPData* const image = &frame->bitstream;
1130    WebPPicture sub_image;
1131    WebPDecoderConfig config;
1132    WebPInitDecoderConfig(&config);
1133    WebPUtilClearPic(canvas, NULL);
1134    if (WebPGetFeatures(image->bytes, image->size, &config.input) !=
1135        VP8_STATUS_OK) {
1136      return 0;
1137    }
1138    if (!WebPPictureView(canvas, frame->x_offset, frame->y_offset,
1139                         config.input.width, config.input.height, &sub_image)) {
1140      return 0;
1141    }
1142    config.output.is_external_memory = 1;
1143    config.output.colorspace = MODE_BGRA;
1144    config.output.u.RGBA.rgba = (uint8_t*)sub_image.argb;
1145    config.output.u.RGBA.stride = sub_image.argb_stride * 4;
1146    config.output.u.RGBA.size = config.output.u.RGBA.stride * sub_image.height;
1147    if (WebPDecode(image->bytes, image->size, &config) != VP8_STATUS_OK) {
1148      return 0;
1149    }
1150    return 1;
1151  }
1152  static int FrameToFullCanvas(WebPAnimEncoder* const enc,
1153                               const WebPMuxFrameInfo* const frame,
1154                               WebPData* const full_image) {
1155    WebPPicture* const canvas_buf = &enc->curr_canvas_copy_;
1156    WebPMemoryWriter mem1, mem2;
1157    WebPMemoryWriterInit(&mem1);
1158    WebPMemoryWriterInit(&mem2);
1159    if (!DecodeFrameOntoCanvas(frame, canvas_buf)) goto Err;
1160    if (!EncodeFrame(&enc->last_config_, canvas_buf, &mem1)) goto Err;
1161    GetEncodedData(&mem1, full_image);
1162    if (enc->options_.allow_mixed) {
1163      if (!EncodeFrame(&enc->last_config_reversed_, canvas_buf, &mem2)) goto Err;
1164      if (mem2.size < mem1.size) {
1165        GetEncodedData(&mem2, full_image);
1166        WebPMemoryWriterClear(&mem1);
1167      } else {
1168        WebPMemoryWriterClear(&mem2);
1169      }
1170    }
1171    return 1;
1172   Err:
1173    WebPMemoryWriterClear(&mem1);
1174    WebPMemoryWriterClear(&mem2);
1175    return 0;
1176  }
1177  static WebPMuxError OptimizeSingleFrame(WebPAnimEncoder* const enc,
1178                                          WebPData* const webp_data) {
1179    WebPMuxError err = WEBP_MUX_OK;
1180    int canvas_width, canvas_height;
1181    WebPMuxFrameInfo frame;
1182    WebPData full_image;
1183    WebPData webp_data2;
1184    WebPMux* const mux = WebPMuxCreate(webp_data, 0);
1185    if (mux == NULL) return WEBP_MUX_BAD_DATA;
1186    assert(enc->out_frame_count_ == 1);
1187    WebPDataInit(&frame.bitstream);
1188    WebPDataInit(&full_image);
1189    WebPDataInit(&webp_data2);
1190    err = WebPMuxGetFrame(mux, 1, &frame);
1191    if (err != WEBP_MUX_OK) goto End;
1192    if (frame.id != WEBP_CHUNK_ANMF) goto End;  
1193    err = WebPMuxGetCanvasSize(mux, &canvas_width, &canvas_height);
1194    if (err != WEBP_MUX_OK) goto End;
1195    if (!FrameToFullCanvas(enc, &frame, &full_image)) {
1196      err = WEBP_MUX_BAD_DATA;
1197      goto End;
1198    }
1199    err = WebPMuxSetImage(mux, &full_image, 1);
1200    if (err != WEBP_MUX_OK) goto End;
1201    err = WebPMuxAssemble(mux, &webp_data2);
1202    if (err != WEBP_MUX_OK) goto End;
1203    if (webp_data2.size < webp_data->size) {  
1204      WebPDataClear(webp_data);
1205      *webp_data = webp_data2;
1206      WebPDataInit(&webp_data2);
1207    }
1208   End:
1209    WebPDataClear(&frame.bitstream);
1210    WebPDataClear(&full_image);
1211    WebPMuxDelete(mux);
1212    WebPDataClear(&webp_data2);
1213    return err;
1214  }
1215  int WebPAnimEncoderAssemble(WebPAnimEncoder* enc, WebPData* webp_data) {
1216    WebPMux* mux;
1217    WebPMuxError err;
1218    if (enc == NULL) {
1219      return 0;
1220    }
1221    MarkNoError(enc);
1222    if (webp_data == NULL) {
1223      MarkError(enc, "ERROR assembling: NULL input");
1224      return 0;
1225    }
1226    if (enc->in_frame_count_ == 0) {
1227      MarkError(enc, "ERROR: No frames to assemble");
1228      return 0;
1229    }
1230    if (!enc->got_null_frame_ && enc->in_frame_count_ > 1 && enc->count_ > 0) {
1231      const double delta_time =
1232          (uint32_t)enc->prev_timestamp_ - enc->first_timestamp_;
1233      const int average_duration = (int)(delta_time / (enc->in_frame_count_ - 1));
1234      if (!IncreasePreviousDuration(enc, average_duration)) {
1235        return 0;
1236      }
1237    }
1238    enc->flush_count_ = enc->count_;
1239    if (!FlushFrames(enc)) {
1240      return 0;
1241    }
1242    mux = enc->mux_;
1243    err = WebPMuxSetCanvasSize(mux, enc->canvas_width_, enc->canvas_height_);
1244    if (err != WEBP_MUX_OK) goto Err;
1245    err = WebPMuxSetAnimationParams(mux, &enc->options_.anim_params);
1246    if (err != WEBP_MUX_OK) goto Err;
1247    err = WebPMuxAssemble(mux, webp_data);
1248    if (err != WEBP_MUX_OK) goto Err;
1249    if (enc->out_frame_count_ == 1) {
1250      err = OptimizeSingleFrame(enc, webp_data);
1251      if (err != WEBP_MUX_OK) goto Err;
1252    }
1253    return 1;
1254   Err:
1255    MarkError2(enc, "ERROR assembling WebP", err);
1256    return 0;
1257  }
1258  const char* WebPAnimEncoderGetError(WebPAnimEncoder* enc) {
1259    if (enc == NULL) return NULL;
1260    return enc->error_str_;
1261  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "atomicvar.h"
7  #ifdef _WIN32
8  #include "Win32_Interop/Win32_QFork.h"
9  #else
10  #include <sys/uio.h>
11  #endif
12  #include <math.h>
13  #include <ctype.h>
14  WIN32_ONLY(extern int WSIOCP_QueueAccept(int listenfd);)
15  WIN32_ONLY(extern int WSIOCP_CloseSocketStateRFD(int listenfd);)
16  static void setProtocolError(const char *errstr, client *c);
17  size_t sdsZmallocSize(sds s) {
18      void *sh = sdsAllocPtr(s);
19      return zmalloc_size(sh);
20  }
21  size_t getStringObjectSdsUsedMemory(robj *o) {
22      serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
23      switch(o->encoding) {
24      case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
25      case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
26      default: return 0; &bsol;* Just integer encoding for now. */
27      }
28  }
29  void *dupClientReplyValue(void *o) {
30      clientReplyBlock *old = o;
31      clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
32      memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
33      return buf;
34  }
35  void freeClientReplyValue(void *o) {
36      zfree(o);
37  }
38  int listMatchObjects(void *a, void *b) {
39      return equalStringObjects(a,b);
40  }
41  void linkClient(client *c) {
42      listAddNodeTail(server.clients,c);
43      c->client_list_node = listLast(server.clients);
44      uint64_t id = htonu64(c->id);
45      raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
46  }
47  client *createClient(int fd) {
48      client *c = zmalloc(sizeof(client));
49      if (fd != -1) {
50          anetNonBlock(NULL,fd);
51          anetEnableTcpNoDelay(NULL,fd);
52          if (server.tcpkeepalive)
53              anetKeepAlive(NULL,fd,server.tcpkeepalive);
54          if (aeCreateFileEvent(server.el,fd,AE_READABLE,
55              readQueryFromClient, c) == AE_ERR)
56          {
57              close(fd);
58              zfree(c);
59              return NULL;
60          }
61      }
62      selectDb(c,0);
63      uint64_t client_id;
64      atomicGetIncr(server.next_client_id,client_id,1);
65      c->id = client_id;
66      c->fd = fd;
67      c->name = NULL;
68      c->bufpos = 0;
69      c->qb_pos = 0;
70      c->querybuf = sdsempty();
71      c->pending_querybuf = sdsempty();
72      c->querybuf_peak = 0;
73      c->reqtype = 0;
74      c->argc = 0;
75      c->argv = NULL;
76      c->cmd = c->lastcmd = NULL;
77      c->multibulklen = 0;
78      c->bulklen = -1;
79      c->sentlen = 0;
80      c->flags = 0;
81      c->ctime = c->lastinteraction = server.unixtime;
82      c->authenticated = 0;
83      c->replstate = REPL_STATE_NONE;
84      c->repl_put_online_on_ack = 0;
85      c->reploff = 0;
86      c->read_reploff = 0;
87      c->repl_ack_off = 0;
88      c->repl_ack_time = 0;
89      c->slave_listening_port = 0;
90      c->slave_ip[0] = '\0';
91      c->slave_capa = SLAVE_CAPA_NONE;
92      c->reply = listCreate();
93      c->reply_bytes = 0;
94      c->obuf_soft_limit_reached_time = 0;
95      listSetFreeMethod(c->reply,freeClientReplyValue);
96      listSetDupMethod(c->reply,dupClientReplyValue);
97      c->btype = BLOCKED_NONE;
98      c->bpop.timeout = 0;
99      c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);
100      c->bpop.target = NULL;
101      c->bpop.xread_group = NULL;
102      c->bpop.xread_consumer = NULL;
103      c->bpop.xread_group_noack = 0;
104      c->bpop.numreplicas = 0;
105      c->bpop.reploffset = 0;
106      c->woff = 0;
107      c->watched_keys = listCreate();
108      c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
109      c->pubsub_patterns = listCreate();
110      c->peerid = NULL;
111      c->client_list_node = NULL;
112      listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
113      listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
114      if (fd != -1) linkClient(c);
115      initClientMultiState(c);
116      return c;
117  }
118  void clientInstallWriteHandler(client *c) {
119      if (!(c->flags & CLIENT_PENDING_WRITE) &&
120          (c->replstate == REPL_STATE_NONE ||
121           (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))
122      {
123          c->flags |= CLIENT_PENDING_WRITE;
124          listAddNodeHead(server.clients_pending_write,c);
125      }
126  }
127  int prepareClientToWrite(client *c) {
128      if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
129      if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
130      if ((c->flags & CLIENT_MASTER) &&
131          !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
132      if (c->fd <= 0) return C_ERR; &bsol;* Fake client for AOF loading. */
133      if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);
134      return C_OK;
135  }
136  int _addReplyToBuffer(client *c, const char *s, size_t len) {
137      size_t available = sizeof(c->buf)-c->bufpos;
138      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
139      if (listLength(c->reply) > 0) return C_ERR;
140      if (len > available) return C_ERR;
141      memcpy(c->buf+c->bufpos,s,len);
142      c->bufpos+=(int)len;                                                        WIN_PORT_FIX &bsol;* cast (int) */
143      return C_OK;
144  }
145  void _addReplyStringToList(client *c, const char *s, size_t len) {
146      if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
147      listNode *ln = listLast(c->reply);
148      clientReplyBlock *tail = ln? listNodeValue(ln): NULL;
149      if (tail) {
150          size_t avail = tail->size - tail->used;
151          size_t copy = avail >= len? len: avail;
152          memcpy(tail->buf + tail->used, s, copy);
153          tail->used += copy;
154          s += copy;
155          len -= copy;
156      }
157      if (len) {
158          size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;
159          tail = zmalloc(size + sizeof(clientReplyBlock));
160          tail->size = zmalloc_usable(tail) - sizeof(clientReplyBlock);
161          tail->used = len;
162          memcpy(tail->buf, s, len);
163          listAddNodeTail(c->reply, tail);
164          c->reply_bytes += tail->size;
165      }
166      asyncCloseClientOnOutputBufferLimitReached(c);
167  }
168  void addReply(client *c, robj *obj) {
169      if (prepareClientToWrite(c) != C_OK) return;
170      if (sdsEncodedObject(obj)) {
171          if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
172              _addReplyStringToList(c,obj->ptr,sdslen(obj->ptr));
173      } else if (obj->encoding == OBJ_ENCODING_INT) {
174          char buf[32];
175          size_t len = ll2string(buf,sizeof(buf),(PORT_LONG)obj->ptr);
176          if (_addReplyToBuffer(c,buf,len) != C_OK)
177              _addReplyStringToList(c,buf,len);
178      } else {
179          serverPanic("Wrong obj->encoding in addReply()");
180      }
181  }
182  void addReplySds(client *c, sds s) {
183      if (prepareClientToWrite(c) != C_OK) {
184          sdsfree(s);
185          return;
186      }
187      if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)
188          _addReplyStringToList(c,s,sdslen(s));
189      sdsfree(s);
190  }
191  void addReplyString(client *c, const char *s, size_t len) {
192      if (prepareClientToWrite(c) != C_OK) return;
193      if (_addReplyToBuffer(c,s,len) != C_OK)
194          _addReplyStringToList(c,s,len);
195  }
196  void addReplyErrorLength(client *c, const char *s, size_t len) {
197      if (!len || s[0] != '-') addReplyString(c,"-ERR ",5);
198      addReplyString(c,s,len);
199      addReplyString(c,"\r\n",2);
200      if (c->flags & (CLIENT_MASTER|CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
201          char* to = c->flags & CLIENT_MASTER? "master": "replica";
202          char* from = c->flags & CLIENT_MASTER? "replica": "master";
203          char *cmdname = c->lastcmd ? c->lastcmd->name : "<unknown>";
204          serverLog(LL_WARNING,"== CRITICAL == This %s is sending an error "
205                               "to its %s: '%s' after processing the command "
206                               "'%s'", from, to, s, cmdname);
207      }
208  }
209  void addReplyError(client *c, const char *err) {
210      addReplyErrorLength(c,err,strlen(err));
211  }
212  void addReplyErrorFormat(client *c, const char *fmt, ...) {
213      size_t l, j;
214      va_list ap;
215      va_start(ap,fmt);
216      sds s = sdscatvprintf(sdsempty(),fmt,ap);
217      va_end(ap);
218      l = sdslen(s);
219      for (j = 0; j < l; j++) {
220          if (s[j] == '\r' || s[j] == '\n') s[j] = ' ';
221      }
222      addReplyErrorLength(c,s,sdslen(s));
223      sdsfree(s);
224  }
225  void addReplyStatusLength(client *c, const char *s, size_t len) {
226      addReplyString(c,"+",1);
227      addReplyString(c,s,len);
228      addReplyString(c,"\r\n",2);
229  }
230  void addReplyStatus(client *c, const char *status) {
231      addReplyStatusLength(c,status,strlen(status));
232  }
233  void addReplyStatusFormat(client *c, const char *fmt, ...) {
234      va_list ap;
235      va_start(ap,fmt);
236      sds s = sdscatvprintf(sdsempty(),fmt,ap);
237      va_end(ap);
238      addReplyStatusLength(c,s,sdslen(s));
239      sdsfree(s);
240  }
241  void *addDeferredMultiBulkLength(client *c) {
242      if (prepareClientToWrite(c) != C_OK) return NULL;
243      listAddNodeTail(c->reply,NULL); &bsol;* NULL is our placeholder. */
244      return listLast(c->reply);
245  }
246  void setDeferredMultiBulkLength(client *c, void *node, PORT_LONG length) {
247      listNode *ln = (listNode*)node;
248      clientReplyBlock *next;
249      char lenstr[128];
250      size_t lenstr_len = sprintf(lenstr, "*%ld\r\n", length);
251      if (node == NULL) return;
252      serverAssert(!listNodeValue(ln));
253      if (ln->next != NULL && (next = listNodeValue(ln->next)) &&
254          next->size - next->used >= lenstr_len &&
255          next->used < PROTO_REPLY_CHUNK_BYTES * 4) {
256          memmove(next->buf + lenstr_len, next->buf, next->used);
257          memcpy(next->buf, lenstr, lenstr_len);
258          next->used += lenstr_len;
259          listDelNode(c->reply,ln);
260      } else {
261          clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));
262          buf->size = zmalloc_usable(buf) - sizeof(clientReplyBlock);
263          buf->used = lenstr_len;
264          memcpy(buf->buf, lenstr, lenstr_len);
265          listNodeValue(ln) = buf;
266          c->reply_bytes += buf->size;
267      }
268      asyncCloseClientOnOutputBufferLimitReached(c);
269  }
270  void addReplyDouble(client *c, double d) {
271      char dbuf[128], sbuf[128];
272      int dlen, slen;
273      if (isinf(d)) {
274          addReplyBulkCString(c, d > 0 ? "inf" : "-inf");
275      } else {
276          dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
277          slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
278          addReplyString(c,sbuf,slen);
279      }
280  }
281  void addReplyHumanLongDouble(client *c, PORT_LONGDOUBLE d) {
282      robj *o = createStringObjectFromLongDouble(d,1);
283      addReplyBulk(c,o);
284      decrRefCount(o);
285  }
286  void addReplyLongLongWithPrefix(client *c, PORT_LONGLONG ll, char prefix) {
287      char buf[128];
288      int len;
289      if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
290          addReply(c,shared.mbulkhdr[ll]);
291          return;
292      } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
293          addReply(c,shared.bulkhdr[ll]);
294          return;
295      }
296      buf[0] = prefix;
297      len = ll2string(buf+1,sizeof(buf)-1,ll);
298      buf[len+1] = '\r';
299      buf[len+2] = '\n';
300      addReplyString(c,buf,(size_t)len+3);  WIN_PORT_FIX &bsol;* cast (size_t) */
301  }
302  void addReplyLongLong(client *c, PORT_LONGLONG ll) {
303      if (ll == 0)
304          addReply(c,shared.czero);
305      else if (ll == 1)
306          addReply(c,shared.cone);
307      else
308          addReplyLongLongWithPrefix(c,ll,':');
309  }
310  void addReplyMultiBulkLen(client *c, PORT_LONG length) {
311      if (length < OBJ_SHARED_BULKHDR_LEN)
312          addReply(c,shared.mbulkhdr[length]);
313      else
314          addReplyLongLongWithPrefix(c,length,'*');
315  }
316  void addReplyBulkLen(client *c, robj *obj) {
317      size_t len;
318      if (sdsEncodedObject(obj)) {
319          len = sdslen(obj->ptr);
320      } else {
321          PORT_LONG n = (PORT_LONG)obj->ptr;
322          len = 1;
323          if (n < 0) {
324              len++;
325              n = -n;
326          }
327          while((n = n/10) != 0) {
328              len++;
329          }
330      }
331      if (len < OBJ_SHARED_BULKHDR_LEN)
332          addReply(c,shared.bulkhdr[len]);
333      else
334          addReplyLongLongWithPrefix(c,len,'$');
335  }
336  void addReplyBulk(client *c, robj *obj) {
337      addReplyBulkLen(c,obj);
338      addReply(c,obj);
339      addReply(c,shared.crlf);
340  }
341  void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
342      addReplyLongLongWithPrefix(c,len,'$');
343      addReplyString(c,p,len);
344      addReply(c,shared.crlf);
345  }
346  void addReplyBulkSds(client *c, sds s)  {
347      addReplyLongLongWithPrefix(c,sdslen(s),'$');
348      addReplySds(c,s);
349      addReply(c,shared.crlf);
350  }
351  void addReplyBulkCString(client *c, const char *s) {
352      if (s == NULL) {
353          addReply(c,shared.nullbulk);
354      } else {
355          addReplyBulkCBuffer(c,s,strlen(s));
356      }
357  }
358  void addReplyBulkLongLong(client *c, PORT_LONGLONG ll) {
359      char buf[64];
360      int len;
361      len = ll2string(buf,64,ll);
362      addReplyBulkCBuffer(c,buf,len);
363  }
364  void addReplyHelp(client *c, const char **help) {
365      sds cmd = sdsnew((char*) c->argv[0]->ptr);
366      void *blenp = addDeferredMultiBulkLength(c);
367      int blen = 0;
368      sdstoupper(cmd);
369      addReplyStatusFormat(c,
370          "%s <subcommand> arg arg ... arg. Subcommands are:",cmd);
371      sdsfree(cmd);
372      while (help[blen]) addReplyStatus(c,help[blen++]);
373      blen++;  &bsol;* Account for the header line(s). */
374      setDeferredMultiBulkLength(c,blenp,blen);
375  }
376  void addReplySubcommandSyntaxError(client *c) {
377      sds cmd = sdsnew((char*) c->argv[0]->ptr);
378      sdstoupper(cmd);
379      addReplyErrorFormat(c,
380          "Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.",
381          (char*)c->argv[1]->ptr,cmd);
382      sdsfree(cmd);
383  }
384  void AddReplyFromClient(client *dst, client *src) {
385      if (prepareClientToWrite(dst) != C_OK)
386          return;
387      addReplyString(dst,src->buf, src->bufpos);
388      if (listLength(src->reply))
389          listJoin(dst->reply,src->reply);
390      dst->reply_bytes += src->reply_bytes;
391      src->reply_bytes = 0;
392      src->bufpos = 0;
393  }
394  void copyClientOutputBuffer(client *dst, client *src) {
395      listRelease(dst->reply);
396      dst->sentlen = 0;
397      dst->reply = listDup(src->reply);
398      memcpy(dst->buf,src->buf,src->bufpos);
399      dst->bufpos = src->bufpos;
400      dst->reply_bytes = src->reply_bytes;
401  }
402  int clientHasPendingReplies(client *c) {
403      return c->bufpos || listLength(c->reply);
404  }
405  #define MAX_ACCEPTS_PER_CALL 1000
406  static void acceptCommonHandler(int fd, int flags, char *ip) {
407      client *c;
408      if ((c = createClient(fd)) == NULL) {
409          serverLog(LL_WARNING,
410              "Error registering fd event for the new client: %s (fd=%d)",
411              IF_WIN32(wsa_strerror(errno), strerror(errno)),fd);
412          close(fd); &bsol;* May be already closed, just ignore errors */
413          return;
414      }
415      if (listLength(server.clients) > (PORT_ULONG) server.maxclients) {
416          char *err = "-ERR max number of clients reached\r\n";
417          if (write(c->fd,err,strlen(err)) == -1) {
418          }
419          server.stat_rejected_conn++;
420  #ifdef _WIN32
421          freeClientAsync(c);
422  #else
423          freeClient(c);
424  #endif
425          return;
426      }
427      if (server.protected_mode &&
428          server.bindaddr_count == 0 &&
429          server.requirepass == NULL &&
430          !(flags & CLIENT_UNIX_SOCKET) &&
431          ip != NULL)
432      {
433          if (strcmp(ip,"127.0.0.1") && strcmp(ip,"::1")) {
434              char *err =
435                  "-DENIED Redis is running in protected mode because protected "
436                  "mode is enabled, no bind address was specified, no "
437                  "authentication password is requested to clients. In this mode "
438                  "connections are only accepted from the loopback interface. "
439                  "If you want to connect from external computers to Redis you "
440                  "may adopt one of the following solutions: "
441                  "1) Just disable protected mode sending the command "
442                  "'CONFIG SET protected-mode no' from the loopback interface "
443                  "by connecting to Redis from the same host the server is "
444                  "running, however MAKE SURE Redis is not publicly accessible "
445                  "from internet if you do so. Use CONFIG REWRITE to make this "
446                  "change permanent. "
447                  "2) Alternatively you can just disable the protected mode by "
448                  "editing the Redis configuration file, and setting the protected "
449                  "mode option to 'no', and then restarting the server. "
450                  "3) If you started the server manually just for testing, restart "
451                  "it with the '--protected-mode no' option. "
452                  "4) Setup a bind address or an authentication password. "
453                  "NOTE: You only need to do one of the above things in order for "
454                  "the server to start accepting connections from the outside.\r\n";
455              if (write(c->fd,err,strlen(err)) == -1) {
456              }
457              server.stat_rejected_conn++;
458              freeClient(c);
459              return;
460          }
461      }
462      server.stat_numconnections++;
463      c->flags |= flags;
464  }
465  void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
466      int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
467      char cip[NET_IP_STR_LEN];
468      UNUSED(el);
469      UNUSED(mask);
470      UNUSED(privdata);
471      while(max--) {
472          cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
473          if (cfd == ANET_ERR) {
474              if (errno != EWOULDBLOCK) {
475                  serverLog(LL_WARNING,
476                      "Accepting client connection: %s", server.neterr);
477  #ifdef _WIN32
478                  if (WSIOCP_QueueAccept(fd) == -1) {
479                      serverLog(LL_WARNING,
480                          "acceptTcpHandler: failed to queue another accept.");
481                  }
482  #endif
483              }
484              return;
485          }
486          serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
487          acceptCommonHandler(cfd,0,cip);
488      }
489  }
490  void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
491      int cfd, max = MAX_ACCEPTS_PER_CALL;
492      UNUSED(el);
493      UNUSED(mask);
494      UNUSED(privdata);
495      while(max--) {
496          cfd = anetUnixAccept(server.neterr, fd);
497          if (cfd == ANET_ERR) {
498              if (errno != EWOULDBLOCK)
499                  serverLog(LL_WARNING,
500                      "Accepting client connection: %s", server.neterr);
501              return;
502          }
503          serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
504          acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
505      }
506  }
507  static void freeClientArgv(client *c) {
508      int j;
509      for (j = 0; j < c->argc; j++)
510          decrRefCount(c->argv[j]);
511      c->argc = 0;
512      c->cmd = NULL;
513  }
514  void disconnectSlaves(void) {
515      while (listLength(server.slaves)) {
516          listNode *ln = listFirst(server.slaves);
517          freeClient((client*)ln->value);
518      }
519  }
520  void unlinkClient(client *c) {
521      listNode *ln;
522      if (server.current_client == c) server.current_client = NULL;
523      if (c->fd != -1) {
524          if (c->client_list_node) {
525              uint64_t id = htonu64(c->id);
526              raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
527              listDelNode(server.clients,c->client_list_node);
528              c->client_list_node = NULL;
529          }
530          if ((c->flags & CLIENT_SLAVE) &&
531              (c->replstate == SLAVE_STATE_WAIT_BGSAVE_END)) {
532  #ifdef _WIN32
533  			WSIOCP_CloseSocketStateRFD(c->fd); 
534  #else
535  			shutdown(c->fd, SHUT_RDWR);
536  #endif
537          }
538          aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
539          aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
540          close(c->fd);
541          c->fd = -1;
542      }
543      if (c->flags & CLIENT_PENDING_WRITE) {
544          ln = listSearchKey(server.clients_pending_write,c);
545          serverAssert(ln != NULL);
546          listDelNode(server.clients_pending_write,ln);
547          c->flags &= ~CLIENT_PENDING_WRITE;
548      }
549      if (c->flags & CLIENT_UNBLOCKED) {
550          ln = listSearchKey(server.unblocked_clients,c);
551          serverAssert(ln != NULL);
552          listDelNode(server.unblocked_clients,ln);
553          c->flags &= ~CLIENT_UNBLOCKED;
554      }
555  }
556  void freeClient(client *c) {
557      listNode *ln;
558      if (c->flags & CLIENT_PROTECTED) {
559          freeClientAsync(c);
560          return;
561      }
562      if (server.master && c->flags & CLIENT_MASTER) {
563          serverLog(LL_WARNING,"Connection with master lost.");
564          if (!(c->flags & (CLIENT_CLOSE_AFTER_REPLY|
565                            CLIENT_CLOSE_ASAP|
566                            CLIENT_BLOCKED)))
567          {
568              replicationCacheMaster(c);
569              return;
570          }
571      }
572      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
573          serverLog(LL_WARNING,"Connection with replica %s lost.",
574              replicationGetSlaveName(c));
575      }
576      sdsfree(c->querybuf);
577      sdsfree(c->pending_querybuf);
578      c->querybuf = NULL;
579      if (c->flags & CLIENT_BLOCKED) unblockClient(c);
580      dictRelease(c->bpop.keys);
581      unwatchAllKeys(c);
582      listRelease(c->watched_keys);
583      pubsubUnsubscribeAllChannels(c,0);
584      pubsubUnsubscribeAllPatterns(c,0);
585      dictRelease(c->pubsub_channels);
586      listRelease(c->pubsub_patterns);
587      listRelease(c->reply);
588      freeClientArgv(c);
589      unlinkClient(c);
590      if (c->flags & CLIENT_SLAVE) {
591          if (c->replstate == SLAVE_STATE_SEND_BULK) {
592  #ifdef _WIN32
593              if (c->repldbfd != -1) {
594                  DeleteFileA(c->replFileCopy);
595                  memset(c->replFileCopy, 0, MAX_PATH);
596              }
597  #endif
598              if (c->repldbfd != -1) close(c->repldbfd);
599              if (c->replpreamble) sdsfree(c->replpreamble);
600          }
601          list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;
602          ln = listSearchKey(l,c);
603          serverAssert(ln != NULL);
604          listDelNode(l,ln);
605          if (getClientType(c) == CLIENT_TYPE_SLAVE && listLength(server.slaves) == 0)
606              server.repl_no_slaves_since = server.unixtime;
607          refreshGoodSlavesCount();
608      }
609      if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();
610      if (c->flags & CLIENT_CLOSE_ASAP) {
611          ln = listSearchKey(server.clients_to_close,c);
612          serverAssert(ln != NULL);
613          listDelNode(server.clients_to_close,ln);
614      }
615      if (c->name) decrRefCount(c->name);
616      zfree(c->argv);
617      freeClientMultiState(c);
618      sdsfree(c->peerid);
619      zfree(c);
620  }
621  void freeClientAsync(client *c) {
622      if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
623      c->flags |= CLIENT_CLOSE_ASAP;
624      listAddNodeTail(server.clients_to_close,c);
625  }
626  void freeClientsInAsyncFreeQueue(void) {
627      while (listLength(server.clients_to_close)) {
628          listNode *ln = listFirst(server.clients_to_close);
629          client *c = listNodeValue(ln);
630          c->flags &= ~CLIENT_CLOSE_ASAP;
631          freeClient(c);
632          listDelNode(server.clients_to_close,ln);
633      }
634  }
635  client *lookupClientByID(uint64_t id) {
636      id = htonu64(id);
637      client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
638      return (c == raxNotFound) ? NULL : c;
639  }
640  int writeToClient(int fd, client *c, int handler_installed) {
641      ssize_t nwritten = 0, totwritten = 0;
642      size_t objlen;
643      clientReplyBlock *o;
644      while(clientHasPendingReplies(c)) {
645          if (c->bufpos > 0) {
646  #ifdef _WIN32
647              nwritten = c->bufpos - c->sentlen;
648              int result = WSIOCP_SocketSend(fd, c->buf + c->sentlen, nwritten,
649                  server.el, c, c->buf, NULL);
650              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
651                  nwritten = -1;
652                  if (errno == WSAEWOULDBLOCK) {
653                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
654                      errno = EAGAIN;
655                  }
656                  break;
657              }
658  #else
659              nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
660              if (nwritten <= 0) break;
661  #endif
662              c->sentlen += nwritten;
663              totwritten += nwritten;
664              if ((int)c->sentlen == c->bufpos) {
665                  c->bufpos = 0;
666                  c->sentlen = 0;
667              }
668          } else {
669              o = listNodeValue(listFirst(c->reply));
670              objlen = o->used;
671              if (objlen == 0) {
672                  c->reply_bytes -= o->size;
673                  listDelNode(c->reply,listFirst(c->reply));
674                  continue;
675              }
676  #ifdef _WIN32
677  			nwritten = objlen - c->sentlen;
678              int result = WSIOCP_SocketSend(fd, o->buf+c->sentlen, nwritten,
679                  server.el, c, o->buf, NULL);
680              if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
681                  nwritten = -1;
682                  if (errno == WSAEWOULDBLOCK) {
683                      serverLog(LL_DEBUG, "writeToClient: will try again (EAGAIN) due to WSAEWOULDBLOCK");
684                      errno = EAGAIN;
685                  }
686                  break;
687              }
688  			if (nwritten <= 0) break;
689              c->sentlen += nwritten;
690              totwritten += nwritten;
691  #else
692              nwritten = write(fd, o->buf + c->sentlen, objlen - c->sentlen);
693              if (nwritten <= 0) break;
694              c->sentlen += nwritten;
695              totwritten += nwritten;
696  #endif
697              if (c->sentlen == objlen) {
698                  c->reply_bytes -= (PORT_ULONG)o->size;
699                  listDelNode(c->reply,listFirst(c->reply));
700                  c->sentlen = 0;
701                  if (listLength(c->reply) == 0)
702                      serverAssert(c->reply_bytes == 0);
703              }
704          }
705          if (totwritten > NET_MAX_WRITES_PER_EVENT &&
706              (server.maxmemory == 0 ||
707               zmalloc_used_memory() < server.maxmemory) &&
708              !(c->flags & CLIENT_SLAVE)) break;
709      }
710      server.stat_net_output_bytes += totwritten;
711      if (nwritten == -1) {
712          if (errno == EAGAIN) {
713              nwritten = 0;
714          } else {
715              serverLog(LL_VERBOSE,
716                  "Error writing to client: %s", IF_WIN32(wsa_strerror,strerror)(errno));
717              freeClient(c);
718              return C_ERR;
719          }
720      }
721      if (totwritten > 0) {
722          if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;
723      }
724      if (!clientHasPendingReplies(c)) {
725          c->sentlen = 0;
726          if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
727          if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
728  #ifdef _WIN32
729              freeClientAsync(c);
730  #else
731              freeClient(c);
732  #endif
733              return C_ERR;
734          }
735      }
736  #if _WIN32
737      else if (handler_installed) {
738          if (aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
739              sendReplyToClient, c) == AE_ERR)
740          {
741              serverLog(LL_WARNING, "writeToClient: aeCreateFileEvent failed");
742              freeClientAsync(c);
743              return C_ERR;
744          }
745          else {
746              serverLog(LL_DEBUG, "writeToClient: re-scheduling sendReplyToClient() for pending client replies");
747          }
748      }
749  #endif
750      return C_OK;
751  }
752  void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
753      UNUSED(el);
754      UNUSED(mask);
755      writeToClient(fd,privdata,1);
756  }
757  int handleClientsWithPendingWrites(void) {
758      listIter li;
759      listNode *ln;
760      int processed = listLength(server.clients_pending_write);
761      listRewind(server.clients_pending_write,&li);
762      while((ln = listNext(&li))) {
763          client *c = listNodeValue(ln);
764          c->flags &= ~CLIENT_PENDING_WRITE;
765          listDelNode(server.clients_pending_write,ln);
766          if (c->flags & CLIENT_PROTECTED) continue;
767          if (writeToClient(c->fd,c,0) == C_ERR) continue;
768          if (clientHasPendingReplies(c)) {
769              int ae_flags = AE_WRITABLE;
770              if (server.aof_state == AOF_ON &&
771                  server.aof_fsync == AOF_FSYNC_ALWAYS)
772              {
773                  ae_flags |= AE_BARRIER;
774              }
775              if (aeCreateFileEvent(server.el, c->fd, ae_flags,
776                  sendReplyToClient, c) == AE_ERR)
777              {
778                      freeClientAsync(c);
779              }
780          }
781      }
782      return processed;
783  }
784  void resetClient(client *c) {
785      redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
786      freeClientArgv(c);
787      c->reqtype = 0;
788      c->multibulklen = 0;
789      c->bulklen = -1;
790      if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)
791          c->flags &= ~CLIENT_ASKING;
792      c->flags &= ~CLIENT_REPLY_SKIP;
793      if (c->flags & CLIENT_REPLY_SKIP_NEXT) {
794          c->flags |= CLIENT_REPLY_SKIP;
795          c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
796      }
797  }
798  void protectClient(client *c) {
799      c->flags |= CLIENT_PROTECTED;
800      aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
801      aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
802  }
803  void unprotectClient(client *c) {
804      if (c->flags & CLIENT_PROTECTED) {
805          c->flags &= ~CLIENT_PROTECTED;
806          aeCreateFileEvent(server.el,c->fd,AE_READABLE,readQueryFromClient,c);
807          if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);
808      }
809  }
810  int processInlineBuffer(client *c) {
811      char *newline;
812      int argc, j, linefeed_chars = 1;
813      sds *argv, aux;
814      size_t querylen;
815      newline = strchr(c->querybuf+c->qb_pos,'\n');
816      if (newline == NULL) {
817          if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
818              addReplyError(c,"Protocol error: too big inline request");
819              setProtocolError("too big inline request",c);
820          }
821          return C_ERR;
822      }
823      if (newline && newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
824          newline--, linefeed_chars++;
825      querylen = newline-(c->querybuf+c->qb_pos);
826      aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
827      argv = sdssplitargs(aux,&argc);
828      sdsfree(aux);
829      if (argv == NULL) {
830          addReplyError(c,"Protocol error: unbalanced quotes in request");
831          setProtocolError("unbalanced quotes in inline request",c);
832          return C_ERR;
833      }
834      if (querylen == 0 && getClientType(c) == CLIENT_TYPE_SLAVE)
835          c->repl_ack_time = server.unixtime;
836      c->qb_pos += querylen+linefeed_chars;
837      if (argc) {
838          if (c->argv) zfree(c->argv);
839          c->argv = zmalloc(sizeof(robj*)*argc);
840      }
841      for (c->argc = 0, j = 0; j < argc; j++) {
842          c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);
843          c->argc++;
844      }
845      zfree(argv);
846      return C_OK;
847  }
848  #define PROTO_DUMP_LEN 128
849  static void setProtocolError(const char *errstr, client *c) {
850      if (server.verbosity <= LL_VERBOSE) {
851          sds client = catClientInfoString(sdsempty(),c);
852          char buf[256];
853          if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
854              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%s'", c->querybuf+c->qb_pos);
855          } else {
856              snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%.*s' (... more %Iu bytes ...) '%.*s'", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2); WIN_PORT_FIX &bsol;* %zu -> %Iu */
857          }
858          char *p = buf;
859          while (*p != '\0') {
860              if (!isprint(*p)) *p = '.';
861              p++;
862          }
863          serverLog(LL_VERBOSE,
864              "Protocol error (%s) from client: %s. %s", errstr, client, buf);
865          sdsfree(client);
866      }
867      c->flags |= CLIENT_CLOSE_AFTER_REPLY;
868  }
869  int processMultibulkBuffer(client *c) {
870      char *newline = NULL;
871      int ok;
872      PORT_LONGLONG ll;
873      if (c->multibulklen == 0) {
874          serverAssertWithInfo(c,NULL,c->argc == 0);
875          newline = strchr(c->querybuf+c->qb_pos,'\r');
876          if (newline == NULL) {
877              if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
878                  addReplyError(c,"Protocol error: too big mbulk count string");
879                  setProtocolError("too big mbulk count string",c);
880              }
881              return C_ERR;
882          }
883          if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
884              return C_ERR;
885          serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');
886          ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);
887          if (!ok || ll > 1024*1024) {
888              addReplyError(c,"Protocol error: invalid multibulk length");
889              setProtocolError("invalid mbulk count",c);
890              return C_ERR;
891          }
892          c->qb_pos = (newline-c->querybuf)+2;
893          if (ll <= 0) return C_OK;
894          c->multibulklen = (int)ll;
895          if (c->argv) zfree(c->argv);
896          c->argv = zmalloc(sizeof(robj*)*c->multibulklen);
897      }
898      serverAssertWithInfo(c,NULL,c->multibulklen > 0);
899      while(c->multibulklen) {
900          if (c->bulklen == -1) {
901              newline = strchr(c->querybuf+c->qb_pos,'\r');
902              if (newline == NULL) {
903                  if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
904                      addReplyError(c,
905                          "Protocol error: too big bulk count string");
906                      setProtocolError("too big bulk count string",c);
907                      return C_ERR;
908                  }
909                  break;
910              }
911              if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
912                  break;
913              if (c->querybuf[c->qb_pos] != '$') {
914                  addReplyErrorFormat(c,
915                      "Protocol error: expected '$', got '%c'",
916                      c->querybuf[c->qb_pos]);
917                  setProtocolError("expected $ but got something else",c);
918                  return C_ERR;
919              }
920              ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);
921              if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
922                  addReplyError(c,"Protocol error: invalid bulk length");
923                  setProtocolError("invalid bulk length",c);
924                  return C_ERR;
925              }
926              c->qb_pos = newline-c->querybuf+2;
927              if (ll >= PROTO_MBULK_BIG_ARG) {
928                  if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {
929                      sdsrange(c->querybuf,c->qb_pos,-1);
930                      c->qb_pos = 0;
931                      c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2);
932                  }
933              }
934              c->bulklen = (PORT_LONG)ll;                                        WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
935          }
936          if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {
937              break;
938          } else {
939              if (c->qb_pos == 0 &&
940                  c->bulklen >= PROTO_MBULK_BIG_ARG &&
941                  sdslen(c->querybuf) == (size_t)(c->bulklen+2))
942              {
943                  c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);
944                  sdsIncrLen(c->querybuf,-2); &bsol;* remove CRLF */
945                  c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);
946                  sdsclear(c->querybuf);
947              } else {
948                  c->argv[c->argc++] =
949                      createStringObject(c->querybuf+c->qb_pos,c->bulklen);
950                  c->qb_pos += c->bulklen+2;
951              }
952              c->bulklen = -1;
953              c->multibulklen--;
954          }
955      }
956      if (c->multibulklen == 0) return C_OK;
957      return C_ERR;
958  }
959  void processInputBuffer(client *c) {
960      server.current_client = c;
961      while(c->qb_pos < sdslen(c->querybuf)) {
962          if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;
963          if (c->flags & CLIENT_BLOCKED) break;
964          if (server.lua_timedout && c->flags & CLIENT_MASTER) break;
965          if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
966          if (!c->reqtype) {
967              if (c->querybuf[c->qb_pos] == '*') {
968                  c->reqtype = PROTO_REQ_MULTIBULK;
969              } else {
970                  c->reqtype = PROTO_REQ_INLINE;
971              }
972          }
973          if (c->reqtype == PROTO_REQ_INLINE) {
974              if (processInlineBuffer(c) != C_OK) break;
975          } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
976              if (processMultibulkBuffer(c) != C_OK) break;
977          } else {
978              serverPanic("Unknown request type");
979          }
980          if (c->argc == 0) {
981              resetClient(c);
982          } else {
983              if (processCommand(c) == C_OK) {
984                  if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
985                      c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
986                  }
987                  if (!(c->flags & CLIENT_BLOCKED) || c->btype != BLOCKED_MODULE)
988                      resetClient(c);
989              }
990              if (server.current_client == NULL) break;
991          }
992      }
993      if (server.current_client != NULL && c->qb_pos) {
994          sdsrange(c->querybuf,c->qb_pos,-1);
995          c->qb_pos = 0;
996      }
997      server.current_client = NULL;
998  }
999  void processInputBufferAndReplicate(client *c) {
1000      if (!(c->flags & CLIENT_MASTER)) {
1001          processInputBuffer(c);
1002      } else {
1003          size_t prev_offset = c->reploff;
1004          processInputBuffer(c);
1005          size_t applied = c->reploff - prev_offset;
1006          if (applied) {
1007              replicationFeedSlavesFromMasterStream(server.slaves,
1008                      c->pending_querybuf, applied);
1009              sdsrange(c->pending_querybuf,applied,-1);
1010          }
1011      }
1012  }
1013  void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
1014      client *c = (client*) privdata;
1015      int nread, readlen;
1016      size_t qblen;
1017      UNUSED(el);
1018      UNUSED(mask);
1019      readlen = PROTO_IOBUF_LEN;
1020      if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
1021          && c->bulklen >= PROTO_MBULK_BIG_ARG)
1022      {
1023          ssize_t remaining = (size_t)(c->bulklen+2)-sdslen(c->querybuf);
1024          if (remaining > 0 && remaining < readlen) readlen = remaining;
1025      }
1026      qblen = sdslen(c->querybuf);
1027      if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;
1028      c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
1029      nread = (int)read(fd, c->querybuf+qblen, readlen);                          WIN_PORT_FIX &bsol;* cast (int) */
1030      if (nread == -1) {
1031          if (errno == EAGAIN) {
1032              return;
1033          } else {
1034              serverLog(LL_VERBOSE, "Reading from client: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1035              freeClient(c);
1036              return;
1037          }
1038      } else if (nread == 0) {
1039          serverLog(LL_VERBOSE, "Client closed connection");
1040          freeClient(c);
1041          return;
1042      } else if (c->flags & CLIENT_MASTER) {
1043          c->pending_querybuf = sdscatlen(c->pending_querybuf,
1044                                          c->querybuf+qblen,nread);
1045      }
1046      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1047      sdsIncrLen(c->querybuf,nread);
1048      c->lastinteraction = server.unixtime;
1049      if (c->flags & CLIENT_MASTER) c->read_reploff += nread;
1050      server.stat_net_input_bytes += nread;
1051      if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
1052          sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
1053          bytes = sdscatrepr(bytes,c->querybuf,64);
1054          serverLog(LL_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
1055          sdsfree(ci);
1056          sdsfree(bytes);
1057          freeClient(c);
1058          return;
1059      }
1060      processInputBufferAndReplicate(c);
1061  }
1062  void getClientsMaxBuffers(PORT_ULONG *longest_output_list,
1063                            PORT_ULONG *biggest_input_buffer) {
1064      client *c;
1065      listNode *ln;
1066      listIter li;
1067      PORT_ULONG lol = 0, bib = 0;
1068      listRewind(server.clients,&li);
1069      while ((ln = listNext(&li)) != NULL) {
1070          c = listNodeValue(ln);
1071          if (listLength(c->reply) > lol) lol = listLength(c->reply);
1072          if (sdslen(c->querybuf) > bib) bib = (PORT_ULONG)sdslen(c->querybuf);   WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1073      }
1074      *longest_output_list = lol;
1075      *biggest_input_buffer = bib;
1076  }
1077  void genClientPeerId(client *client, char *peerid,
1078                              size_t peerid_len) {
1079      if (client->flags & CLIENT_UNIX_SOCKET) {
1080          snprintf(peerid,peerid_len,"%s:0",server.unixsocket);
1081      } else {
1082          anetFormatPeer(client->fd,peerid,peerid_len);
1083      }
1084  }
1085  char *getClientPeerId(client *c) {
1086      char peerid[NET_PEER_ID_LEN];
1087      if (c->peerid == NULL) {
1088          genClientPeerId(c,peerid,sizeof(peerid));
1089          c->peerid = sdsnew(peerid);
1090      }
1091      return c->peerid;
1092  }
1093  sds catClientInfoString(sds s, client *client) {
1094      char flags[16], events[3], *p;
1095      int emask;
1096      p = flags;
1097      if (client->flags & CLIENT_SLAVE) {
1098          if (client->flags & CLIENT_MONITOR)
1099              *p++ = 'O';
1100          else
1101              *p++ = 'S';
1102      }
1103      if (client->flags & CLIENT_MASTER) *p++ = 'M';
1104      if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
1105      if (client->flags & CLIENT_MULTI) *p++ = 'x';
1106      if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
1107      if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
1108      if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
1109      if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
1110      if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
1111      if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
1112      if (client->flags & CLIENT_READONLY) *p++ = 'r';
<span onclick='openModal()' class='match'>1113      if (p == flags) *p++ = 'N';
1114      *p++ = '\0';
1115      emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
1116      p = events;
1117      if (emask & AE_READABLE) *p++ = 'r';
</span>1118      if (emask & AE_WRITABLE) *p++ = 'w';
1119      *p = '\0';
1120      return sdscatfmt(s,
1121          "id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s",
1122          (PORT_ULONGLONG) client->id,
1123          getClientPeerId(client),
1124          client->fd,
1125          client->name ? (char*)client->name->ptr : "",
1126          (PORT_LONGLONG)(server.unixtime - client->ctime),
1127          (PORT_LONGLONG)(server.unixtime - client->lastinteraction),
1128          flags,
1129          client->db->id,
1130          (int) dictSize(client->pubsub_channels),
1131          (int) listLength(client->pubsub_patterns),
1132          (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,
1133          (PORT_ULONGLONG) sdslen(client->querybuf),
1134          (PORT_ULONGLONG) sdsavail(client->querybuf),
1135          (PORT_ULONGLONG) client->bufpos,
1136          (PORT_ULONGLONG) listLength(client->reply),
1137          (PORT_ULONGLONG) getClientOutputBufferMemoryUsage(client),
1138          events,
1139          client->lastcmd ? client->lastcmd->name : "NULL");
1140  }
1141  sds getAllClientsInfoString(int type) {
1142      listNode *ln;
1143      listIter li;
1144      client *client;
1145      sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
1146      sdsclear(o);
1147      listRewind(server.clients,&li);
1148      while ((ln = listNext(&li)) != NULL) {
1149          client = listNodeValue(ln);
1150          if (type != -1 && getClientType(client) != type) continue;
1151          o = catClientInfoString(o,client);
1152          o = sdscatlen(o,"\n",1);
1153      }
1154      return o;
1155  }
1156  void clientCommand(client *c) {
1157      listNode *ln;
1158      listIter li;
1159      client *client;
1160      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
1161          const char *help[] = {
1162  "id                     -- Return the ID of the current connection.",
1163  "getname                -- Return the name of the current connection.",
1164  "kill <ip:port>         -- Kill connection made from <ip:port>.",
1165  "kill <option> <value> [option value ...] -- Kill connections. Options are:",
1166  "     addr <ip:port>                      -- Kill connection made from <ip:port>",
1167  "     type (normal|master|replica|pubsub) -- Kill connections by type.",
1168  "     skipme (yes|no)   -- Skip killing current connection (default: yes).",
1169  "list [options ...]     -- Return information about client connections. Options:",
1170  "     type (normal|master|replica|pubsub) -- Return clients of specified type.",
1171  "pause <timeout>        -- Suspend all Redis clients for <timout> milliseconds.",
1172  "reply (on|off|skip)    -- Control the replies sent to the current connection.",
1173  "setname <name>         -- Assign the name <name> to the current connection.",
1174  "unblock <clientid> [TIMEOUT|ERROR] -- Unblock the specified blocked client.",
1175  NULL
1176          };
1177          addReplyHelp(c, help);
1178      } else if (!strcasecmp(c->argv[1]->ptr,"id") && c->argc == 2) {
1179          addReplyLongLong(c,c->id);
1180      } else if (!strcasecmp(c->argv[1]->ptr,"list")) {
1181          int type = -1;
1182          if (c->argc == 4 && !strcasecmp(c->argv[2]->ptr,"type")) {
1183              type = getClientTypeByName(c->argv[3]->ptr);
1184              if (type == -1) {
1185                  addReplyErrorFormat(c,"Unknown client type '%s'",
1186                      (char*) c->argv[3]->ptr);
1187                  return;
1188               }
1189          } else if (c->argc != 2) {
1190              addReply(c,shared.syntaxerr);
1191              return;
1192          }
1193          sds o = getAllClientsInfoString(type);
1194          addReplyBulkCBuffer(c,o,sdslen(o));
1195          sdsfree(o);
1196      } else if (!strcasecmp(c->argv[1]->ptr,"reply") && c->argc == 3) {
1197          if (!strcasecmp(c->argv[2]->ptr,"on")) {
1198              c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);
1199              addReply(c,shared.ok);
1200          } else if (!strcasecmp(c->argv[2]->ptr,"off")) {
1201              c->flags |= CLIENT_REPLY_OFF;
1202          } else if (!strcasecmp(c->argv[2]->ptr,"skip")) {
1203              if (!(c->flags & CLIENT_REPLY_OFF))
1204                  c->flags |= CLIENT_REPLY_SKIP_NEXT;
1205          } else {
1206              addReply(c,shared.syntaxerr);
1207              return;
1208          }
1209      } else if (!strcasecmp(c->argv[1]->ptr,"kill")) {
1210          char *addr = NULL;
1211          int type = -1;
1212          uint64_t id = 0;
1213          int skipme = 1;
1214          int killed = 0, close_this_client = 0;
1215          if (c->argc == 3) {
1216              addr = c->argv[2]->ptr;
1217              skipme = 0; &bsol;* With the old form, you can kill yourself. */
1218          } else if (c->argc > 3) {
1219              int i = 2; &bsol;* Next option index. */
1220              while(i < c->argc) {
1221                  int moreargs = c->argc > i+1;
1222                  if (!strcasecmp(c->argv[i]->ptr,"id") && moreargs) {
1223                      PORT_LONGLONG tmp;
1224                      if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
1225                          != C_OK) return;
1226                      id = tmp;
1227                  } else if (!strcasecmp(c->argv[i]->ptr,"type") && moreargs) {
1228                      type = getClientTypeByName(c->argv[i+1]->ptr);
1229                      if (type == -1) {
1230                          addReplyErrorFormat(c,"Unknown client type '%s'",
1231                              (char*) c->argv[i+1]->ptr);
1232                          return;
1233                      }
1234                  } else if (!strcasecmp(c->argv[i]->ptr,"addr") && moreargs) {
1235                      addr = c->argv[i+1]->ptr;
1236                  } else if (!strcasecmp(c->argv[i]->ptr,"skipme") && moreargs) {
1237                      if (!strcasecmp(c->argv[i+1]->ptr,"yes")) {
1238                          skipme = 1;
1239                      } else if (!strcasecmp(c->argv[i+1]->ptr,"no")) {
1240                          skipme = 0;
1241                      } else {
1242                          addReply(c,shared.syntaxerr);
1243                          return;
1244                      }
1245                  } else {
1246                      addReply(c,shared.syntaxerr);
1247                      return;
1248                  }
1249                  i += 2;
1250              }
1251          } else {
1252              addReply(c,shared.syntaxerr);
1253              return;
1254          }
1255          listRewind(server.clients,&li);
1256          while ((ln = listNext(&li)) != NULL) {
1257              client = listNodeValue(ln);
1258              if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;
1259              if (type != -1 && getClientType(client) != type) continue;
1260              if (id != 0 && client->id != id) continue;
1261              if (c == client && skipme) continue;
1262              if (c == client) {
1263                  close_this_client = 1;
1264              } else {
1265                  freeClient(client);
1266              }
1267              killed++;
1268          }
1269          if (c->argc == 3) {
1270              if (killed == 0)
1271                  addReplyError(c,"No such client");
1272              else
1273                  addReply(c,shared.ok);
1274          } else {
1275              addReplyLongLong(c,killed);
1276          }
1277          if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1278      } else if (!strcasecmp(c->argv[1]->ptr,"unblock") && (c->argc == 3 ||
1279                                                            c->argc == 4))
1280      {
1281          PORT_LONGLONG id;
1282          int unblock_error = 0;
1283          if (c->argc == 4) {
1284              if (!strcasecmp(c->argv[3]->ptr,"timeout")) {
1285                  unblock_error = 0;
1286              } else if (!strcasecmp(c->argv[3]->ptr,"error")) {
1287                  unblock_error = 1;
1288              } else {
1289                  addReplyError(c,
1290                      "CLIENT UNBLOCK reason should be TIMEOUT or ERROR");
1291                  return;
1292              }
1293          }
1294          if (getLongLongFromObjectOrReply(c,c->argv[2],&id,NULL)
1295              != C_OK) return;
1296          struct client *target = lookupClientByID(id);
1297          if (target && target->flags & CLIENT_BLOCKED) {
1298              if (unblock_error)
1299                  addReplyError(target,
1300                      "-UNBLOCKED client unblocked via CLIENT UNBLOCK");
1301              else
1302                  replyToBlockedClientTimedOut(target);
1303              unblockClient(target);
1304              addReply(c,shared.cone);
1305          } else {
1306              addReply(c,shared.czero);
1307          }
1308      } else if (!strcasecmp(c->argv[1]->ptr,"setname") && c->argc == 3) {
1309          int j, len = (int)sdslen(c->argv[2]->ptr);                              WIN_PORT_FIX &bsol;* cast (int) */
1310          char *p = c->argv[2]->ptr;
1311          if (len == 0) {
1312              if (c->name) decrRefCount(c->name);
1313              c->name = NULL;
1314              addReply(c,shared.ok);
1315              return;
1316          }
1317          for (j = 0; j < len; j++) {
1318              if (p[j] < '!' || p[j] > '~') { &bsol;* ASCII is assumed. */
1319                  addReplyError(c,
1320                      "Client names cannot contain spaces, "
1321                      "newlines or special characters.");
1322                  return;
1323              }
1324          }
1325          if (c->name) decrRefCount(c->name);
1326          c->name = c->argv[2];
1327          incrRefCount(c->name);
1328          addReply(c,shared.ok);
1329      } else if (!strcasecmp(c->argv[1]->ptr,"getname") && c->argc == 2) {
1330          if (c->name)
1331              addReplyBulk(c,c->name);
1332          else
1333              addReply(c,shared.nullbulk);
1334      } else if (!strcasecmp(c->argv[1]->ptr,"pause") && c->argc == 3) {
1335          PORT_LONGLONG duration;
1336          if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,UNIT_MILLISECONDS)
1337                                          != C_OK) return;
1338          pauseClients(duration);
1339          addReply(c,shared.ok);
1340      } else {
1341          addReplyErrorFormat(c, "Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP", (char*)c->argv[1]->ptr);
1342      }
1343  }
1344  void securityWarningCommand(client *c) {
1345      static time_t logged_time;
1346      time_t now = time(NULL);
1347      if (labs(now-logged_time) > 60) {
1348          serverLog(LL_WARNING,"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.");
1349          logged_time = now;
1350      }
1351      freeClientAsync(c);
1352  }
1353  void rewriteClientCommandVector(client *c, int argc, ...) {
1354      va_list ap;
1355      int j;
1356      robj **argv; &bsol;* The new argument vector */
1357      argv = zmalloc(sizeof(robj*)*argc);
1358      va_start(ap,argc);
1359      for (j = 0; j < argc; j++) {
1360          robj *a;
1361          a = va_arg(ap, robj*);
1362          argv[j] = a;
1363          incrRefCount(a);
1364      }
1365      for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);
1366      zfree(c->argv);
1367      c->argv = argv;
1368      c->argc = argc;
1369      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1370      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1371      va_end(ap);
1372  }
1373  void replaceClientCommandVector(client *c, int argc, robj **argv) {
1374      freeClientArgv(c);
1375      zfree(c->argv);
1376      c->argv = argv;
1377      c->argc = argc;
1378      c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1379      serverAssertWithInfo(c,NULL,c->cmd != NULL);
1380  }
1381  void rewriteClientCommandArgument(client *c, int i, robj *newval) {
1382      robj *oldval;
1383      if (i >= c->argc) {
1384          c->argv = zrealloc(c->argv,sizeof(robj*)*((PORT_ULONG)i+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1385          c->argc = i+1;
1386          c->argv[i] = NULL;
1387      }
1388      oldval = c->argv[i];
1389      c->argv[i] = newval;
1390      incrRefCount(newval);
1391      if (oldval) decrRefCount(oldval);
1392      if (i == 0) {
1393          c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
1394          serverAssertWithInfo(c,NULL,c->cmd != NULL);
1395      }
1396  }
1397  PORT_ULONG getClientOutputBufferMemoryUsage(client *c) {
1398      PORT_ULONG list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
1399      return c->reply_bytes + (list_item_size*listLength(c->reply));
1400  }
1401  int getClientType(client *c) {
1402      if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
1403      if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
1404          return CLIENT_TYPE_SLAVE;
1405      if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
1406      return CLIENT_TYPE_NORMAL;
1407  }
1408  int getClientTypeByName(char *name) {
1409      if (!strcasecmp(name,"normal")) return CLIENT_TYPE_NORMAL;
1410      else if (!strcasecmp(name,"slave")) return CLIENT_TYPE_SLAVE;
1411      else if (!strcasecmp(name,"replica")) return CLIENT_TYPE_SLAVE;
1412      else if (!strcasecmp(name,"pubsub")) return CLIENT_TYPE_PUBSUB;
1413      else if (!strcasecmp(name,"master")) return CLIENT_TYPE_MASTER;
1414      else return -1;
1415  }
1416  char *getClientTypeName(int class) {
1417      switch(class) {
1418      case CLIENT_TYPE_NORMAL: return "normal";
1419      case CLIENT_TYPE_SLAVE:  return "slave";
1420      case CLIENT_TYPE_PUBSUB: return "pubsub";
1421      case CLIENT_TYPE_MASTER: return "master";
1422      default:                       return NULL;
1423      }
1424  }
1425  int checkClientOutputBufferLimits(client *c) {
1426      int soft = 0, hard = 0, class;
1427      PORT_ULONG used_mem = getClientOutputBufferMemoryUsage(c);
1428      class = getClientType(c);
1429      if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;
1430      if (server.client_obuf_limits[class].hard_limit_bytes &&
1431          used_mem >= server.client_obuf_limits[class].hard_limit_bytes)
1432          hard = 1;
1433      if (server.client_obuf_limits[class].soft_limit_bytes &&
1434          used_mem >= server.client_obuf_limits[class].soft_limit_bytes)
1435          soft = 1;
1436      if (soft) {
1437          if (c->obuf_soft_limit_reached_time == 0) {
1438              c->obuf_soft_limit_reached_time = server.unixtime;
1439              soft = 0; &bsol;* First time we see the soft limit reached */
1440          } else {
1441              time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;
1442              if (elapsed <=
1443                  server.client_obuf_limits[class].soft_limit_seconds) {
1444                  soft = 0; &bsol;* The client still did not reached the max number of
1445                               seconds for the soft limit to be considered
1446                               reached. */
1447              }
1448          }
1449      } else {
1450          c->obuf_soft_limit_reached_time = 0;
1451      }
1452      return soft || hard;
1453  }
1454  void asyncCloseClientOnOutputBufferLimitReached(client *c) {
1455      if (c->fd == -1) return; &bsol;* It is unsafe to free fake clients. */
1456      POSIX_ONLY(serverAssert(c->reply_bytes < PORT_ULONG_MAX-(1024*64));)
1457      if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
1458      if (checkClientOutputBufferLimits(c)) {
1459          sds client = catClientInfoString(sdsempty(),c);
1460          freeClientAsync(c);
1461          serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
1462          sdsfree(client);
1463      }
1464  }
1465  void flushSlavesOutputBuffers(void) {
1466      listIter li;
1467      listNode *ln;
1468      listRewind(server.slaves,&li);
1469      while((ln = listNext(&li))) {
1470          client *slave = listNodeValue(ln);
1471          int events = aeGetFileEvents(server.el,slave->fd);
1472          int can_receive_writes = (events & AE_WRITABLE) ||
1473                                   (slave->flags & CLIENT_PENDING_WRITE);
1474          if (slave->replstate == SLAVE_STATE_ONLINE &&
1475              can_receive_writes &&
1476              !slave->repl_put_online_on_ack &&
1477              clientHasPendingReplies(slave))
1478          {
1479              writeToClient(slave->fd,slave,0);
1480          }
1481      }
1482  }
1483  void pauseClients(mstime_t end) {
1484      if (!server.clients_paused || end > server.clients_pause_end_time)
1485          server.clients_pause_end_time = end;
1486      server.clients_paused = 1;
1487  }
1488  int clientsArePaused(void) {
1489      if (server.clients_paused &&
1490          server.clients_pause_end_time < server.mstime)
1491      {
1492          listNode *ln;
1493          listIter li;
1494          client *c;
1495          server.clients_paused = 0;
1496          listRewind(server.clients,&li);
1497          while ((ln = listNext(&li)) != NULL) {
1498              c = listNodeValue(ln);
1499              if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;
1500              queueClientForReprocessing(c);
1501          }
1502      }
1503      return server.clients_paused;
1504  }
1505  int processEventsWhileBlocked(void) {
1506      int iterations = 4; &bsol;* See the function top-comment. */
1507      int count = 0;
1508      while (iterations--) {
1509          int events = 0;
1510          events += aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
1511          events += handleClientsWithPendingWrites();
1512          if (!events) break;
1513          count += events;
1514      }
1515      return count;
1516  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-networking.c</div>
                </div>
                <div class="column column_space"><pre><code>624    candidate->info_.id = WEBP_CHUNK_ANMF;
625    candidate->info_.x_offset = rect->x_offset_;
626    candidate->info_.y_offset = rect->y_offset_;
627    candidate->info_.dispose_method = WEBP_MUX_DISPOSE_NONE;  
628    candidate->info_.blend_method =
629        use_blending ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
630    candidate->info_.duration = 0;  
631    WebPMemoryWriterInit(&candidate->mem_);
632    if (!config.lossless && use_blending) {
</pre></code></div>
                <div class="column column_space"><pre><code>1113      if (p == flags) *p++ = 'N';
1114      *p++ = '\0';
1115      emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
1116      p = events;
1117      if (emask & AE_READABLE) *p++ = 'r';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    