
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_7.c</h3>
            <pre><code>1  #define JEMALLOC_STATS_C_
2  #include &quot;jemalloc/internal/jemalloc_preamble.h&quot;
3  #include &quot;jemalloc/internal/jemalloc_internal_includes.h&quot;
4  #include &quot;jemalloc/internal/assert.h&quot;
5  #include &quot;jemalloc/internal/ctl.h&quot;
6  #include &quot;jemalloc/internal/emitter.h&quot;
7  #include &quot;jemalloc/internal/mutex.h&quot;
8  #include &quot;jemalloc/internal/mutex_prof.h&quot;
9  const char *global_mutex_names[mutex_prof_num_global_mutexes] = {
10  #define OP(mtx) #mtx,
11  	MUTEX_PROF_GLOBAL_MUTEXES
12  #undef OP
13  };
14  const char *arena_mutex_names[mutex_prof_num_arena_mutexes] = {
15  #define OP(mtx) #mtx,
16  	MUTEX_PROF_ARENA_MUTEXES
17  #undef OP
18  };
19  #define CTL_GET(n, v, t) do {						\
20  	size_t sz = sizeof(t);						\
21  	xmallctl(n, (void *)v, &amp;sz, NULL, 0);				\
22  } while (0)
23  #define CTL_M2_GET(n, i, v, t) do {					\
24  	size_t mib[CTL_MAX_DEPTH];					\
25  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
26  	size_t sz = sizeof(t);						\
27  	xmallctlnametomib(n, mib, &amp;miblen);				\
28  	mib[2] = (i);							\
29  	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
30  } while (0)
31  #define CTL_M2_M4_GET(n, i, j, v, t) do {				\
32  	size_t mib[CTL_MAX_DEPTH];					\
33  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
34  	size_t sz = sizeof(t);						\
35  	xmallctlnametomib(n, mib, &amp;miblen);				\
36  	mib[2] = (i);							\
37  	mib[4] = (j);							\
38  	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
39  } while (0)
40  bool opt_stats_print = false;
41  char opt_stats_print_opts[stats_print_tot_num_options+1] = &quot;&quot;;
42  static uint64_t
43  rate_per_second(uint64_t value, uint64_t uptime_ns) {
44  	uint64_t billion = 1000000000;
45  	if (uptime_ns == 0 || value == 0) {
46  		return 0;
47  	}
48  	if (uptime_ns &lt; billion) {
49  		return value;
50  	} else {
51  		uint64_t uptime_s = uptime_ns / billion;
52  		return value / uptime_s;
53  	}
54  }
55  static bool
56  get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
57  	if (divisor == 0 || dividend &gt; divisor) {
58  		return true;
59  	}
60  	if (dividend &gt; 0) {
61  		assert(UINT64_MAX / dividend &gt;= 1000);
62  	}
63  	unsigned n = (unsigned)((dividend * 1000) / divisor);
64  	if (n &lt; 10) {
65  		malloc_snprintf(str, 6, &quot;0.00%u&quot;, n);
66  	} else if (n &lt; 100) {
67  		malloc_snprintf(str, 6, &quot;0.0%u&quot;, n);
68  	} else if (n &lt; 1000) {
69  		malloc_snprintf(str, 6, &quot;0.%u&quot;, n);
70  	} else {
71  		malloc_snprintf(str, 6, &quot;1&quot;);
72  	}
73  	return false;
74  }
75  #define MUTEX_CTL_STR_MAX_LENGTH 128
76  static void
77  gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
78      const char *mutex, const char *counter) {
79  	malloc_snprintf(str, buf_len, &quot;stats.%s.%s.%s&quot;, prefix, mutex, counter);
80  }
81  static void
82  mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
83      emitter_col_t *name,
84      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
85      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
86  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
87  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
88  	emitter_col_t *col;
89  	if (name != NULL) {
90  		emitter_col_init(name, row);
91  		name-&gt;justify = emitter_justify_left;
92  		name-&gt;width = 21;
93  		name-&gt;type = emitter_type_title;
94  		name-&gt;str_val = table_name;
95  	}
96  #define WIDTH_uint32_t 12
97  #define WIDTH_uint64_t 16
98  #define OP(counter, counter_type, human, derived, base_counter)	\
99  	col = &amp;col_##counter_type[k_##counter_type];			\
100  	++k_##counter_type;						\
101  	emitter_col_init(col, row);					\
102  	col-&gt;justify = emitter_justify_right;				\
103  	col-&gt;width = derived ? 8 : WIDTH_##counter_type;		\
104  	col-&gt;type = emitter_type_title;					\
105  	col-&gt;str_val = human;
106  	MUTEX_PROF_COUNTERS
107  #undef OP
108  #undef WIDTH_uint32_t
109  #undef WIDTH_uint64_t
110  	col_uint64_t[mutex_counter_total_wait_time_ps].width = 10;
111  }
112  static void
113  mutex_stats_read_global(const char *name, emitter_col_t *col_name,
114      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
115      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
116      uint64_t uptime) {
117  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
118  	col_name-&gt;str_val = name;
119  	emitter_col_t *dst;
120  #define EMITTER_TYPE_uint32_t emitter_type_uint32
121  #define EMITTER_TYPE_uint64_t emitter_type_uint64
122  #define OP(counter, counter_type, human, derived, base_counter)	\
123  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
124  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
125  	if (!derived) {							\
126  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,	\
127  		    &quot;mutexes&quot;, name, #counter);				\
128  		CTL_GET(cmd, (counter_type *)&amp;dst-&gt;bool_val, counter_type);	\
129  	} else { \
130  	    emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
131  	    dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
132  	}
133  	MUTEX_PROF_COUNTERS
134  #undef OP
135  #undef EMITTER_TYPE_uint32_t
136  #undef EMITTER_TYPE_uint64_t
137  }
138  static void
139  mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
140      const char *name, emitter_col_t *col_name,
141      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
142      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
143      uint64_t uptime) {
144  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
145  	col_name-&gt;str_val = name;
146  	emitter_col_t *dst;
147  #define EMITTER_TYPE_uint32_t emitter_type_uint32
148  #define EMITTER_TYPE_uint64_t emitter_type_uint64
149  #define OP(counter, counter_type, human, derived, base_counter)	\
150  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
151  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
152  	if (!derived) {                                   \
153  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
154  		    &quot;arenas.0.mutexes&quot;, arena_mutex_names[mutex_ind], #counter);\
155  		CTL_M2_GET(cmd, arena_ind, (counter_type *)&amp;dst-&gt;bool_val, counter_type); \
156  	} else {                      \
157  		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
158  		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
159  	}
160  	MUTEX_PROF_COUNTERS
161  #undef OP
162  #undef EMITTER_TYPE_uint32_t
163  #undef EMITTER_TYPE_uint64_t
164  }
165  static void
166  mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
167      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
168      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
169      uint64_t uptime) {
170  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
171  	emitter_col_t *dst;
172  #define EMITTER_TYPE_uint32_t emitter_type_uint32
173  #define EMITTER_TYPE_uint64_t emitter_type_uint64
174  #define OP(counter, counter_type, human, derived, base_counter)	\
175  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
176  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
177  	if (!derived) {                                   \
178  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
179  		    &quot;arenas.0.bins.0&quot;,&quot;mutex&quot;, #counter);            \
180  		CTL_M2_M4_GET(cmd, arena_ind, bin_ind,                \
181  		    (counter_type *)&amp;dst-&gt;bool_val, counter_type);  \
182  	} else {                      \
183  		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter]; \
184  		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
185  	}
186  	MUTEX_PROF_COUNTERS
187  #undef OP
188  #undef EMITTER_TYPE_uint32_t
189  #undef EMITTER_TYPE_uint64_t
190  }
191  static void
192  mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
193      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
194      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
195  	if (row != NULL) {
196  		emitter_table_row(emitter, row);
197  	}
198  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
199  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
200  	emitter_col_t *col;
201  #define EMITTER_TYPE_uint32_t emitter_type_uint32
202  #define EMITTER_TYPE_uint64_t emitter_type_uint64
203  #define OP(counter, type, human, derived, base_counter)		\
204  	if (!derived) {                    \
205  		col = &amp;col_##type[k_##type];                        \
206  		++k_##type;                            \
207  		emitter_json_kv(emitter, #counter, EMITTER_TYPE_##type,        \
208  		    (const void *)&amp;col-&gt;bool_val); \
209  	}
210  	MUTEX_PROF_COUNTERS;
211  #undef OP
212  #undef EMITTER_TYPE_uint32_t
213  #undef EMITTER_TYPE_uint64_t
214  }
215  #define COL(row_name, column_name, left_or_right, col_width, etype)      \
216  	emitter_col_t col_##column_name;                                     \
217  	emitter_col_init(&amp;col_##column_name, &amp;row_name);                     \
218  	col_##column_name.justify = emitter_justify_##left_or_right;         \
219  	col_##column_name.width = col_width;                                 \
220  	col_##column_name.type = emitter_type_##etype;
221  #define COL_HDR(row_name, column_name, human, left_or_right, col_width, etype)  \
222  	COL(row_name, column_name, left_or_right, col_width, etype)	         \
223  	emitter_col_t header_##column_name;                                  \
224  	emitter_col_init(&amp;header_##column_name, &amp;header_##row_name);         \
225  	header_##column_name.justify = emitter_justify_##left_or_right;      \
226  	header_##column_name.width = col_width;                              \
227  	header_##column_name.type = emitter_type_title;                      \
228  	header_##column_name.str_val = human ? human : #column_name;
229  static void
230  stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i, uint64_t uptime) {
231  	size_t page;
232  	bool in_gap, in_gap_prev;
233  	unsigned nbins, j;
234  	CTL_GET(&quot;arenas.page&quot;, &amp;page, size_t);
235  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
236  	emitter_row_t header_row;
237  	emitter_row_init(&amp;header_row);
238  	emitter_row_t row;
239  	emitter_row_init(&amp;row);
240  	COL_HDR(row, size, NULL, right, 20, size)
241  	COL_HDR(row, ind, NULL, right, 4, unsigned)
242  	COL_HDR(row, allocated, NULL, right, 13, uint64)
243  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
244  	COL_HDR(row, nmalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
245  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
246  	COL_HDR(row, ndalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
247  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
248  	COL_HDR(row, nrequests_ps, &quot;(#/sec)&quot;, right, 10, uint64)
249  	COL_HDR(row, nshards, NULL, right, 9, unsigned)
250  	COL_HDR(row, curregs, NULL, right, 13, size)
251  	COL_HDR(row, curslabs, NULL, right, 13, size)
252  	COL_HDR(row, nonfull_slabs, NULL, right, 15, size)
253  	COL_HDR(row, regs, NULL, right, 5, unsigned)
254  	COL_HDR(row, pgs, NULL, right, 4, size)
255  	COL_HDR(row, justify_spacer, NULL, right, 1, title)
256  	COL_HDR(row, util, NULL, right, 6, title)
257  	COL_HDR(row, nfills, NULL, right, 13, uint64)
258  	COL_HDR(row, nfills_ps, &quot;(#/sec)&quot;, right, 8, uint64)
259  	COL_HDR(row, nflushes, NULL, right, 13, uint64)
260  	COL_HDR(row, nflushes_ps, &quot;(#/sec)&quot;, right, 8, uint64)
261  	COL_HDR(row, nslabs, NULL, right, 13, uint64)
262  	COL_HDR(row, nreslabs, NULL, right, 13, uint64)
263  	COL_HDR(row, nreslabs_ps, &quot;(#/sec)&quot;, right, 8, uint64)
264  	header_justify_spacer.str_val = &quot; &quot;;
265  	col_justify_spacer.str_val = &quot; &quot;;
266  	emitter_col_t col_mutex64[mutex_prof_num_uint64_t_counters];
267  	emitter_col_t col_mutex32[mutex_prof_num_uint32_t_counters];
268  	emitter_col_t header_mutex64[mutex_prof_num_uint64_t_counters];
269  	emitter_col_t header_mutex32[mutex_prof_num_uint32_t_counters];
270  	if (mutex) {
271  		mutex_stats_init_cols(&amp;row, NULL, NULL, col_mutex64,
272  		    col_mutex32);
273  		mutex_stats_init_cols(&amp;header_row, NULL, NULL, header_mutex64,
274  		    header_mutex32);
275  	}
276  	header_size.width -=5;
277  	emitter_table_printf(emitter, &quot;bins:&quot;);
278  	emitter_table_row(emitter, &amp;header_row);
279  	emitter_json_array_kv_begin(emitter, &quot;bins&quot;);
280  	for (j = 0, in_gap = false; j &lt; nbins; j++) {
281  		uint64_t nslabs;
282  		size_t reg_size, slab_size, curregs;
283  		size_t curslabs;
284  		size_t nonfull_slabs;
285  		uint32_t nregs, nshards;
286  		uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
287  		uint64_t nreslabs;
288  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nslabs&quot;, i, j, &amp;nslabs,
289  		    uint64_t);
290  		in_gap_prev = in_gap;
291  		in_gap = (nslabs == 0);
292  		if (in_gap_prev &amp;&amp; !in_gap) {
293  			emitter_table_printf(emitter,
294  			    &quot;                     ---\n&quot;);
295  		}
296  		CTL_M2_GET(&quot;arenas.bin.0.size&quot;, j, &amp;reg_size, size_t);
297  		CTL_M2_GET(&quot;arenas.bin.0.nregs&quot;, j, &amp;nregs, uint32_t);
298  		CTL_M2_GET(&quot;arenas.bin.0.slab_size&quot;, j, &amp;slab_size, size_t);
299  		CTL_M2_GET(&quot;arenas.bin.0.nshards&quot;, j, &amp;nshards, uint32_t);
300  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nmalloc&quot;, i, j, &amp;nmalloc,
301  		    uint64_t);
302  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.ndalloc&quot;, i, j, &amp;ndalloc,
303  		    uint64_t);
304  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.curregs&quot;, i, j, &amp;curregs,
305  		    size_t);
306  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nrequests&quot;, i, j,
307  		    &amp;nrequests, uint64_t);
308  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nfills&quot;, i, j, &amp;nfills,
309  		    uint64_t);
310  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nflushes&quot;, i, j, &amp;nflushes,
311  		    uint64_t);
312  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nreslabs&quot;, i, j, &amp;nreslabs,
313  		    uint64_t);
314  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.curslabs&quot;, i, j, &amp;curslabs,
315  		    size_t);
316  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nonfull_slabs&quot;, i, j, &amp;nonfull_slabs,
317  		    size_t);
318  		if (mutex) {
319  			mutex_stats_read_arena_bin(i, j, col_mutex64,
320  			    col_mutex32, uptime);
321  		}
322  		emitter_json_object_begin(emitter);
323  		emitter_json_kv(emitter, &quot;nmalloc&quot;, emitter_type_uint64,
324  		    &amp;nmalloc);
325  		emitter_json_kv(emitter, &quot;ndalloc&quot;, emitter_type_uint64,
326  		    &amp;ndalloc);
327  		emitter_json_kv(emitter, &quot;curregs&quot;, emitter_type_size,
328  		    &amp;curregs);
329  		emitter_json_kv(emitter, &quot;nrequests&quot;, emitter_type_uint64,
330  		    &amp;nrequests);
331  		emitter_json_kv(emitter, &quot;nfills&quot;, emitter_type_uint64,
332  		    &amp;nfills);
333  		emitter_json_kv(emitter, &quot;nflushes&quot;, emitter_type_uint64,
334  		    &amp;nflushes);
335  		emitter_json_kv(emitter, &quot;nreslabs&quot;, emitter_type_uint64,
336  		    &amp;nreslabs);
337  		emitter_json_kv(emitter, &quot;curslabs&quot;, emitter_type_size,
338  		    &amp;curslabs);
339  		emitter_json_kv(emitter, &quot;nonfull_slabs&quot;, emitter_type_size,
340  		    &amp;nonfull_slabs);
341  		if (mutex) {
342  			emitter_json_object_kv_begin(emitter, &quot;mutex&quot;);
343  			mutex_stats_emit(emitter, NULL, col_mutex64,
344  			    col_mutex32);
345  			emitter_json_object_end(emitter);
346  		}
347  		emitter_json_object_end(emitter);
348  		size_t availregs = nregs * curslabs;
349  		char util[6];
350  		if (get_rate_str((uint64_t)curregs, (uint64_t)availregs, util))
351  		{
352  			if (availregs == 0) {
353  				malloc_snprintf(util, sizeof(util), &quot;1&quot;);
354  			} else if (curregs &gt; availregs) {
355  				malloc_snprintf(util, sizeof(util), &quot; race&quot;);
356  			} else {
357  				not_reached();
358  			}
359  		}
360  		col_size.size_val = reg_size;
361  		col_ind.unsigned_val = j;
362  		col_allocated.size_val = curregs * reg_size;
363  		col_nmalloc.uint64_val = nmalloc;
364  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
365  		col_ndalloc.uint64_val = ndalloc;
366  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
367  		col_nrequests.uint64_val = nrequests;
368  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
369  		col_nshards.unsigned_val = nshards;
370  		col_curregs.size_val = curregs;
371  		col_curslabs.size_val = curslabs;
372  		col_nonfull_slabs.size_val = nonfull_slabs;
373  		col_regs.unsigned_val = nregs;
374  		col_pgs.size_val = slab_size / page;
375  		col_util.str_val = util;
376  		col_nfills.uint64_val = nfills;
377  		col_nfills_ps.uint64_val = rate_per_second(nfills, uptime);
378  		col_nflushes.uint64_val = nflushes;
379  		col_nflushes_ps.uint64_val = rate_per_second(nflushes, uptime);
380  		col_nslabs.uint64_val = nslabs;
381  		col_nreslabs.uint64_val = nreslabs;
382  		col_nreslabs_ps.uint64_val = rate_per_second(nreslabs, uptime);
383  		emitter_table_row(emitter, &amp;row);
384  	}
385  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;bins&quot;. */
386  	if (in_gap) {
387  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
388  	}
389  }
390  static void
391  stats_arena_lextents_print(emitter_t *emitter, unsigned i, uint64_t uptime) {
392  	unsigned nbins, nlextents, j;
393  	bool in_gap, in_gap_prev;
394  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
395  	CTL_GET(&quot;arenas.nlextents&quot;, &amp;nlextents, unsigned);
396  	emitter_row_t header_row;
397  	emitter_row_init(&amp;header_row);
398  	emitter_row_t row;
399  	emitter_row_init(&amp;row);
400  	COL_HDR(row, size, NULL, right, 20, size)
401  	COL_HDR(row, ind, NULL, right, 4, unsigned)
402  	COL_HDR(row, allocated, NULL, right, 13, size)
403  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
404  	COL_HDR(row, nmalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
405  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
406  	COL_HDR(row, ndalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
407  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
408  	COL_HDR(row, nrequests_ps, &quot;(#/sec)&quot;, right, 8, uint64)
409  	COL_HDR(row, curlextents, NULL, right, 13, size)
410  	header_size.width -= 6;
411  	emitter_table_printf(emitter, &quot;large:&quot;);
412  	emitter_table_row(emitter, &amp;header_row);
413  	emitter_json_array_kv_begin(emitter, &quot;lextents&quot;);
414  	for (j = 0, in_gap = false; j &lt; nlextents; j++) {
415  		uint64_t nmalloc, ndalloc, nrequests;
416  		size_t lextent_size, curlextents;
417  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.nmalloc&quot;, i, j,
418  		    &amp;nmalloc, uint64_t);
419  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.ndalloc&quot;, i, j,
420  		    &amp;ndalloc, uint64_t);
421  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.nrequests&quot;, i, j,
422  		    &amp;nrequests, uint64_t);
423  		in_gap_prev = in_gap;
424  		in_gap = (nrequests == 0);
425  		if (in_gap_prev &amp;&amp; !in_gap) {
426  			emitter_table_printf(emitter,
427  			    &quot;                     ---\n&quot;);
428  		}
429  		CTL_M2_GET(&quot;arenas.lextent.0.size&quot;, j, &amp;lextent_size, size_t);
430  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.curlextents&quot;, i, j,
431  		    &amp;curlextents, size_t);
432  		emitter_json_object_begin(emitter);
433  		emitter_json_kv(emitter, &quot;curlextents&quot;, emitter_type_size,
434  		    &amp;curlextents);
435  		emitter_json_object_end(emitter);
436  		col_size.size_val = lextent_size;
437  		col_ind.unsigned_val = nbins + j;
438  		col_allocated.size_val = curlextents * lextent_size;
439  		col_nmalloc.uint64_val = nmalloc;
440  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
441  		col_ndalloc.uint64_val = ndalloc;
442  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
443  		col_nrequests.uint64_val = nrequests;
444  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
445  		col_curlextents.size_val = curlextents;
446  		if (!in_gap) {
447  			emitter_table_row(emitter, &amp;row);
448  		}
449  	}
450  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;lextents&quot;. */
451  	if (in_gap) {
452  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
453  	}
454  }
455  static void
456  stats_arena_extents_print(emitter_t *emitter, unsigned i) {
457  	unsigned j;
458  	bool in_gap, in_gap_prev;
459  	emitter_row_t header_row;
460  	emitter_row_init(&amp;header_row);
461  	emitter_row_t row;
462  	emitter_row_init(&amp;row);
463  	COL_HDR(row, size, NULL, right, 20, size)
464  	COL_HDR(row, ind, NULL, right, 4, unsigned)
465  	COL_HDR(row, ndirty, NULL, right, 13, size)
466  	COL_HDR(row, dirty, NULL, right, 13, size)
467  	COL_HDR(row, nmuzzy, NULL, right, 13, size)
468  	COL_HDR(row, muzzy, NULL, right, 13, size)
469  	COL_HDR(row, nretained, NULL, right, 13, size)
470  	COL_HDR(row, retained, NULL, right, 13, size)
471  	COL_HDR(row, ntotal, NULL, right, 13, size)
472  	COL_HDR(row, total, NULL, right, 13, size)
473  	header_size.width -= 8;
474  	emitter_table_printf(emitter, &quot;extents:&quot;);
475  	emitter_table_row(emitter, &amp;header_row);
476  	emitter_json_array_kv_begin(emitter, &quot;extents&quot;);
477  	in_gap = false;
478  	for (j = 0; j &lt; SC_NPSIZES; j++) {
479  		size_t ndirty, nmuzzy, nretained, total, dirty_bytes,
480  		    muzzy_bytes, retained_bytes, total_bytes;
481  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.ndirty&quot;, i, j,
482  		    &amp;ndirty, size_t);
483  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.nmuzzy&quot;, i, j,
484  		    &amp;nmuzzy, size_t);
485  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.nretained&quot;, i, j,
486  		    &amp;nretained, size_t);
487  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.dirty_bytes&quot;, i, j,
488  		    &amp;dirty_bytes, size_t);
489  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.muzzy_bytes&quot;, i, j,
490  		    &amp;muzzy_bytes, size_t);
491  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.retained_bytes&quot;, i, j,
492  		    &amp;retained_bytes, size_t);
493  		total = ndirty + nmuzzy + nretained;
494  		total_bytes = dirty_bytes + muzzy_bytes + retained_bytes;
495  		in_gap_prev = in_gap;
496  		in_gap = (total == 0);
497  		if (in_gap_prev &amp;&amp; !in_gap) {
498  			emitter_table_printf(emitter,
499  			    &quot;                     ---\n&quot;);
500  		}
501  		emitter_json_object_begin(emitter);
502  		emitter_json_kv(emitter, &quot;ndirty&quot;, emitter_type_size, &amp;ndirty);
503  		emitter_json_kv(emitter, &quot;nmuzzy&quot;, emitter_type_size, &amp;nmuzzy);
504  		emitter_json_kv(emitter, &quot;nretained&quot;, emitter_type_size,
505  		    &amp;nretained);
506  		emitter_json_kv(emitter, &quot;dirty_bytes&quot;, emitter_type_size,
507  		    &amp;dirty_bytes);
508  		emitter_json_kv(emitter, &quot;muzzy_bytes&quot;, emitter_type_size,
509  		    &amp;muzzy_bytes);
510  		emitter_json_kv(emitter, &quot;retained_bytes&quot;, emitter_type_size,
511  		    &amp;retained_bytes);
512  		emitter_json_object_end(emitter);
513  		col_size.size_val = sz_pind2sz(j);
514  		col_ind.size_val = j;
515  		col_ndirty.size_val = ndirty;
516  		col_dirty.size_val = dirty_bytes;
517  		col_nmuzzy.size_val = nmuzzy;
518  		col_muzzy.size_val = muzzy_bytes;
519  		col_nretained.size_val = nretained;
520  		col_retained.size_val = retained_bytes;
521  		col_ntotal.size_val = total;
522  		col_total.size_val = total_bytes;
523  		if (!in_gap) {
524  			emitter_table_row(emitter, &amp;row);
525  		}
526  	}
527  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;extents&quot;. */
528  	if (in_gap) {
529  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
530  	}
531  }
532  static void
533  stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind, uint64_t uptime) {
534  	emitter_row_t row;
535  	emitter_col_t col_name;
536  	emitter_col_t col64[mutex_prof_num_uint64_t_counters];
537  	emitter_col_t col32[mutex_prof_num_uint32_t_counters];
538  	emitter_row_init(&amp;row);
539  	mutex_stats_init_cols(&amp;row, &quot;&quot;, &amp;col_name, col64, col32);
540  	emitter_json_object_kv_begin(emitter, &quot;mutexes&quot;);
541  	emitter_table_row(emitter, &amp;row);
542  	for (mutex_prof_arena_ind_t i = 0; i &lt; mutex_prof_num_arena_mutexes;
543  	    i++) {
544  		const char *name = arena_mutex_names[i];
545  		emitter_json_object_kv_begin(emitter, name);
546  		mutex_stats_read_arena(arena_ind, i, name, &amp;col_name, col64,
547  		    col32, uptime);
548  		mutex_stats_emit(emitter, &amp;row, col64, col32);
549  		emitter_json_object_end(emitter); &amp;bsol;* Close the mutex dict. */
550  	}
551  	emitter_json_object_end(emitter); &amp;bsol;* End &quot;mutexes&quot;. */
552  }
553  static void
554  stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
555      bool mutex, bool extents) {
556  	unsigned nthreads;
557  	const char *dss;
558  	ssize_t dirty_decay_ms, muzzy_decay_ms;
559  	size_t page, pactive, pdirty, pmuzzy, mapped, retained;
560  	size_t base, internal, resident, metadata_thp, extent_avail;
561  	uint64_t dirty_npurge, dirty_nmadvise, dirty_purged;
562  	uint64_t muzzy_npurge, muzzy_nmadvise, muzzy_purged;
563  	size_t small_allocated;
564  	uint64_t small_nmalloc, small_ndalloc, small_nrequests, small_nfills,
565  	    small_nflushes;
566  	size_t large_allocated;
567  	uint64_t large_nmalloc, large_ndalloc, large_nrequests, large_nfills,
568  	    large_nflushes;
569  	size_t tcache_bytes, abandoned_vm;
570  	uint64_t uptime;
571  	CTL_GET(&quot;arenas.page&quot;, &amp;page, size_t);
572  	CTL_M2_GET(&quot;stats.arenas.0.nthreads&quot;, i, &amp;nthreads, unsigned);
573  	emitter_kv(emitter, &quot;nthreads&quot;, &quot;assigned threads&quot;,
574  	    emitter_type_unsigned, &amp;nthreads);
575  	CTL_M2_GET(&quot;stats.arenas.0.uptime&quot;, i, &amp;uptime, uint64_t);
576  	emitter_kv(emitter, &quot;uptime_ns&quot;, &quot;uptime&quot;, emitter_type_uint64,
577  	    &amp;uptime);
578  	CTL_M2_GET(&quot;stats.arenas.0.dss&quot;, i, &amp;dss, const char *);
579  	emitter_kv(emitter, &quot;dss&quot;, &quot;dss allocation precedence&quot;,
580  	    emitter_type_string, &amp;dss);
581  	CTL_M2_GET(&quot;stats.arenas.0.dirty_decay_ms&quot;, i, &amp;dirty_decay_ms,
582  	    ssize_t);
583  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_decay_ms&quot;, i, &amp;muzzy_decay_ms,
584  	    ssize_t);
585  	CTL_M2_GET(&quot;stats.arenas.0.pactive&quot;, i, &amp;pactive, size_t);
586  	CTL_M2_GET(&quot;stats.arenas.0.pdirty&quot;, i, &amp;pdirty, size_t);
587  	CTL_M2_GET(&quot;stats.arenas.0.pmuzzy&quot;, i, &amp;pmuzzy, size_t);
588  	CTL_M2_GET(&quot;stats.arenas.0.dirty_npurge&quot;, i, &amp;dirty_npurge, uint64_t);
589  	CTL_M2_GET(&quot;stats.arenas.0.dirty_nmadvise&quot;, i, &amp;dirty_nmadvise,
590  	    uint64_t);
591  	CTL_M2_GET(&quot;stats.arenas.0.dirty_purged&quot;, i, &amp;dirty_purged, uint64_t);
592  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_npurge&quot;, i, &amp;muzzy_npurge, uint64_t);
593  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_nmadvise&quot;, i, &amp;muzzy_nmadvise,
594  	    uint64_t);
595  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_purged&quot;, i, &amp;muzzy_purged, uint64_t);
596  	emitter_row_t decay_row;
597  	emitter_row_init(&amp;decay_row);
598  	emitter_json_kv(emitter, &quot;dirty_decay_ms&quot;, emitter_type_ssize,
599  	    &amp;dirty_decay_ms);
600  	emitter_json_kv(emitter, &quot;muzzy_decay_ms&quot;, emitter_type_ssize,
601  	    &amp;muzzy_decay_ms);
602  	emitter_json_kv(emitter, &quot;pactive&quot;, emitter_type_size, &amp;pactive);
603  	emitter_json_kv(emitter, &quot;pdirty&quot;, emitter_type_size, &amp;pdirty);
604  	emitter_json_kv(emitter, &quot;pmuzzy&quot;, emitter_type_size, &amp;pmuzzy);
605  	emitter_json_kv(emitter, &quot;dirty_npurge&quot;, emitter_type_uint64,
606  	    &amp;dirty_npurge);
607  	emitter_json_kv(emitter, &quot;dirty_nmadvise&quot;, emitter_type_uint64,
608  	    &amp;dirty_nmadvise);
609  	emitter_json_kv(emitter, &quot;dirty_purged&quot;, emitter_type_uint64,
610  	    &amp;dirty_purged);
611  	emitter_json_kv(emitter, &quot;muzzy_npurge&quot;, emitter_type_uint64,
612  	    &amp;muzzy_npurge);
613  	emitter_json_kv(emitter, &quot;muzzy_nmadvise&quot;, emitter_type_uint64,
614  	    &amp;muzzy_nmadvise);
615  	emitter_json_kv(emitter, &quot;muzzy_purged&quot;, emitter_type_uint64,
616  	    &amp;muzzy_purged);
617  	COL(decay_row, decay_type, right, 9, title);
618  	col_decay_type.str_val = &quot;decaying:&quot;;
619  	COL(decay_row, decay_time, right, 6, title);
620  	col_decay_time.str_val = &quot;time&quot;;
621  	COL(decay_row, decay_npages, right, 13, title);
622  	col_decay_npages.str_val = &quot;npages&quot;;
623  	COL(decay_row, decay_sweeps, right, 13, title);
624  	col_decay_sweeps.str_val = &quot;sweeps&quot;;
625  	COL(decay_row, decay_madvises, right, 13, title);
626  	col_decay_madvises.str_val = &quot;madvises&quot;;
627  	COL(decay_row, decay_purged, right, 13, title);
628  	col_decay_purged.str_val = &quot;purged&quot;;
629  	emitter_table_row(emitter, &amp;decay_row);
630  	col_decay_type.str_val = &quot;dirty:&quot;;
631  	if (dirty_decay_ms &gt;= 0) {
632  		col_decay_time.type = emitter_type_ssize;
633  		col_decay_time.ssize_val = dirty_decay_ms;
634  	} else {
635  		col_decay_time.type = emitter_type_title;
636  		col_decay_time.str_val = &quot;N/A&quot;;
637  	}
638  	col_decay_npages.type = emitter_type_size;
639  	col_decay_npages.size_val = pdirty;
640  	col_decay_sweeps.type = emitter_type_uint64;
641  	col_decay_sweeps.uint64_val = dirty_npurge;
642  	col_decay_madvises.type = emitter_type_uint64;
643  	col_decay_madvises.uint64_val = dirty_nmadvise;
644  	col_decay_purged.type = emitter_type_uint64;
645  	col_decay_purged.uint64_val = dirty_purged;
646  	emitter_table_row(emitter, &amp;decay_row);
647  	col_decay_type.str_val = &quot;muzzy:&quot;;
648  	if (muzzy_decay_ms &gt;= 0) {
649  		col_decay_time.type = emitter_type_ssize;
650  		col_decay_time.ssize_val = muzzy_decay_ms;
651  	} else {
652  		col_decay_time.type = emitter_type_title;
653  		col_decay_time.str_val = &quot;N/A&quot;;
654  	}
655  	col_decay_npages.type = emitter_type_size;
656  	col_decay_npages.size_val = pmuzzy;
657  	col_decay_sweeps.type = emitter_type_uint64;
658  	col_decay_sweeps.uint64_val = muzzy_npurge;
659  	col_decay_madvises.type = emitter_type_uint64;
660  	col_decay_madvises.uint64_val = muzzy_nmadvise;
661  	col_decay_purged.type = emitter_type_uint64;
662  	col_decay_purged.uint64_val = muzzy_purged;
663  	emitter_table_row(emitter, &amp;decay_row);
664  	emitter_row_t alloc_count_row;
665  	emitter_row_init(&amp;alloc_count_row);
666  	COL(alloc_count_row, count_title, left, 21, title);
667  	col_count_title.str_val = &quot;&quot;;
668  	COL(alloc_count_row, count_allocated, right, 16, title);
669  	col_count_allocated.str_val = &quot;allocated&quot;;
670  	COL(alloc_count_row, count_nmalloc, right, 16, title);
671  	col_count_nmalloc.str_val = &quot;nmalloc&quot;;
672  	COL(alloc_count_row, count_nmalloc_ps, right, 8, title);
673  	col_count_nmalloc_ps.str_val = &quot;(#/sec)&quot;;
674  	COL(alloc_count_row, count_ndalloc, right, 16, title);
675  	col_count_ndalloc.str_val = &quot;ndalloc&quot;;
676  	COL(alloc_count_row, count_ndalloc_ps, right, 8, title);
677  	col_count_ndalloc_ps.str_val = &quot;(#/sec)&quot;;
678  	COL(alloc_count_row, count_nrequests, right, 16, title);
679  	col_count_nrequests.str_val = &quot;nrequests&quot;;
680  	COL(alloc_count_row, count_nrequests_ps, right, 10, title);
681  	col_count_nrequests_ps.str_val = &quot;(#/sec)&quot;;
682  	COL(alloc_count_row, count_nfills, right, 16, title);
683  	col_count_nfills.str_val = &quot;nfill&quot;;
684  	COL(alloc_count_row, count_nfills_ps, right, 10, title);
685  	col_count_nfills_ps.str_val = &quot;(#/sec)&quot;;
686  	COL(alloc_count_row, count_nflushes, right, 16, title);
687  	col_count_nflushes.str_val = &quot;nflush&quot;;
688  	COL(alloc_count_row, count_nflushes_ps, right, 10, title);
689  	col_count_nflushes_ps.str_val = &quot;(#/sec)&quot;;
690  	emitter_table_row(emitter, &amp;alloc_count_row);
691  	col_count_nmalloc_ps.type = emitter_type_uint64;
692  	col_count_ndalloc_ps.type = emitter_type_uint64;
693  	col_count_nrequests_ps.type = emitter_type_uint64;
694  	col_count_nfills_ps.type = emitter_type_uint64;
695  	col_count_nflushes_ps.type = emitter_type_uint64;
696  #define GET_AND_EMIT_ALLOC_STAT(small_or_large, name, valtype)		\
697  	CTL_M2_GET(&quot;stats.arenas.0.&quot; #small_or_large &quot;.&quot; #name, i,	\
698  	    &amp;small_or_large##_##name, valtype##_t);			\
699  	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
700  	    &amp;small_or_large##_##name);					\
701  	col_count_##name.type = emitter_type_##valtype;		\
702  	col_count_##name.valtype##_val = small_or_large##_##name;
703  	emitter_json_object_kv_begin(emitter, &quot;small&quot;);
704  	col_count_title.str_val = &quot;small:&quot;;
705  	GET_AND_EMIT_ALLOC_STAT(small, allocated, size)
706  	GET_AND_EMIT_ALLOC_STAT(small, nmalloc, uint64)
707  	col_count_nmalloc_ps.uint64_val =
708  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
709  	GET_AND_EMIT_ALLOC_STAT(small, ndalloc, uint64)
710  	col_count_ndalloc_ps.uint64_val =
711  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
712  	GET_AND_EMIT_ALLOC_STAT(small, nrequests, uint64)
713  	col_count_nrequests_ps.uint64_val =
714  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
715  	GET_AND_EMIT_ALLOC_STAT(small, nfills, uint64)
716  	col_count_nfills_ps.uint64_val =
717  	    rate_per_second(col_count_nfills.uint64_val, uptime);
718  	GET_AND_EMIT_ALLOC_STAT(small, nflushes, uint64)
719  	col_count_nflushes_ps.uint64_val =
720  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
<span onclick='openModal()' class='match'>721  	emitter_table_row(emitter, &amp;alloc_count_row);
722  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;small&quot;. */
723  	emitter_json_object_kv_begin(emitter, &quot;large&quot;);
</span>724  	col_count_title.str_val = &quot;large:&quot;;
725  	GET_AND_EMIT_ALLOC_STAT(large, allocated, size)
726  	GET_AND_EMIT_ALLOC_STAT(large, nmalloc, uint64)
727  	col_count_nmalloc_ps.uint64_val =
728  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
729  	GET_AND_EMIT_ALLOC_STAT(large, ndalloc, uint64)
730  	col_count_ndalloc_ps.uint64_val =
731  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
732  	GET_AND_EMIT_ALLOC_STAT(large, nrequests, uint64)
733  	col_count_nrequests_ps.uint64_val =
734  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
735  	GET_AND_EMIT_ALLOC_STAT(large, nfills, uint64)
736  	col_count_nfills_ps.uint64_val =
737  	    rate_per_second(col_count_nfills.uint64_val, uptime);
738  	GET_AND_EMIT_ALLOC_STAT(large, nflushes, uint64)
739  	col_count_nflushes_ps.uint64_val =
740  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
741  	emitter_table_row(emitter, &amp;alloc_count_row);
742  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;large&quot;. */
743  #undef GET_AND_EMIT_ALLOC_STAT
744  	col_count_title.str_val = &quot;total:&quot;;
745  	col_count_allocated.size_val = small_allocated + large_allocated;
746  	col_count_nmalloc.uint64_val = small_nmalloc + large_nmalloc;
747  	col_count_ndalloc.uint64_val = small_ndalloc + large_ndalloc;
748  	col_count_nrequests.uint64_val = small_nrequests + large_nrequests;
749  	col_count_nfills.uint64_val = small_nfills + large_nfills;
750  	col_count_nflushes.uint64_val = small_nflushes + large_nflushes;
751  	col_count_nmalloc_ps.uint64_val =
752  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
753  	col_count_ndalloc_ps.uint64_val =
754  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
755  	col_count_nrequests_ps.uint64_val =
756  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
757  	col_count_nfills_ps.uint64_val =
758  	    rate_per_second(col_count_nfills.uint64_val, uptime);
759  	col_count_nflushes_ps.uint64_val =
760  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
761  	emitter_table_row(emitter, &amp;alloc_count_row);
762  	emitter_row_t mem_count_row;
763  	emitter_row_init(&amp;mem_count_row);
764  	emitter_col_t mem_count_title;
765  	emitter_col_init(&amp;mem_count_title, &amp;mem_count_row);
766  	mem_count_title.justify = emitter_justify_left;
767  	mem_count_title.width = 21;
768  	mem_count_title.type = emitter_type_title;
769  	mem_count_title.str_val = &quot;&quot;;
770  	emitter_col_t mem_count_val;
771  	emitter_col_init(&amp;mem_count_val, &amp;mem_count_row);
772  	mem_count_val.justify = emitter_justify_right;
773  	mem_count_val.width = 16;
774  	mem_count_val.type = emitter_type_title;
775  	mem_count_val.str_val = &quot;&quot;;
776  	emitter_table_row(emitter, &amp;mem_count_row);
777  	mem_count_val.type = emitter_type_size;
778  	mem_count_title.str_val = &quot;active:&quot;;
779  	mem_count_val.size_val = pactive * page;
780  	emitter_table_row(emitter, &amp;mem_count_row);
781  #define GET_AND_EMIT_MEM_STAT(stat)					\
782  	CTL_M2_GET(&quot;stats.arenas.0.&quot;#stat, i, &amp;stat, size_t);		\
783  	emitter_json_kv(emitter, #stat, emitter_type_size, &amp;stat);	\
784  	mem_count_title.str_val = #stat&quot;:&quot;;				\
785  	mem_count_val.size_val = stat;					\
786  	emitter_table_row(emitter, &amp;mem_count_row);
787  	GET_AND_EMIT_MEM_STAT(mapped)
788  	GET_AND_EMIT_MEM_STAT(retained)
789  	GET_AND_EMIT_MEM_STAT(base)
790  	GET_AND_EMIT_MEM_STAT(internal)
791  	GET_AND_EMIT_MEM_STAT(metadata_thp)
792  	GET_AND_EMIT_MEM_STAT(tcache_bytes)
793  	GET_AND_EMIT_MEM_STAT(resident)
794  	GET_AND_EMIT_MEM_STAT(abandoned_vm)
795  	GET_AND_EMIT_MEM_STAT(extent_avail)
796  #undef GET_AND_EMIT_MEM_STAT
797  	if (mutex) {
798  		stats_arena_mutexes_print(emitter, i, uptime);
799  	}
800  	if (bins) {
801  		stats_arena_bins_print(emitter, mutex, i, uptime);
802  	}
803  	if (large) {
804  		stats_arena_lextents_print(emitter, i, uptime);
805  	}
806  	if (extents) {
807  		stats_arena_extents_print(emitter, i);
808  	}
809  }
810  static void
811  stats_general_print(emitter_t *emitter) {
812  	const char *cpv;
813  	bool bv, bv2;
814  	unsigned uv;
815  	uint32_t u32v;
816  	uint64_t u64v;
817  	ssize_t ssv, ssv2;
818  	size_t sv, bsz, usz, ssz, sssz, cpsz;
819  	bsz = sizeof(bool);
820  	usz = sizeof(unsigned);
821  	ssz = sizeof(size_t);
822  	sssz = sizeof(ssize_t);
823  	cpsz = sizeof(const char *);
824  	CTL_GET(&quot;version&quot;, &amp;cpv, const char *);
825  	emitter_kv(emitter, &quot;version&quot;, &quot;Version&quot;, emitter_type_string, &amp;cpv);
826  	emitter_dict_begin(emitter, &quot;config&quot;, &quot;Build-time option settings&quot;);
827  #define CONFIG_WRITE_BOOL(name)						\
828  	do {								\
829  		CTL_GET(&quot;config.&quot;#name, &amp;bv, bool);			\
830  		emitter_kv(emitter, #name, &quot;config.&quot;#name,		\
831  		    emitter_type_bool, &amp;bv);				\
832  	} while (0)
833  	CONFIG_WRITE_BOOL(cache_oblivious);
834  	CONFIG_WRITE_BOOL(debug);
835  	CONFIG_WRITE_BOOL(fill);
836  	CONFIG_WRITE_BOOL(lazy_lock);
837  	emitter_kv(emitter, &quot;malloc_conf&quot;, &quot;config.malloc_conf&quot;,
838  	    emitter_type_string, &amp;config_malloc_conf);
839  	CONFIG_WRITE_BOOL(opt_safety_checks);
840  	CONFIG_WRITE_BOOL(prof);
841  	CONFIG_WRITE_BOOL(prof_libgcc);
842  	CONFIG_WRITE_BOOL(prof_libunwind);
843  	CONFIG_WRITE_BOOL(stats);
844  	CONFIG_WRITE_BOOL(utrace);
845  	CONFIG_WRITE_BOOL(xmalloc);
846  #undef CONFIG_WRITE_BOOL
847  	emitter_dict_end(emitter); &amp;bsol;* Close &quot;config&quot; dict. */
848  #define OPT_WRITE(name, var, size, emitter_type)			\
849  	if (je_mallctl(&quot;opt.&quot;name, (void *)&amp;var, &amp;size, NULL, 0) ==	\
850  	    0) {							\
851  		emitter_kv(emitter, name, &quot;opt.&quot;name, emitter_type,	\
852  		    &amp;var);						\
853  	}
854  #define OPT_WRITE_MUTABLE(name, var1, var2, size, emitter_type,		\
855      altname)								\
856  	if (je_mallctl(&quot;opt.&quot;name, (void *)&amp;var1, &amp;size, NULL, 0) ==	\
857  	    0 &amp;&amp; je_mallctl(altname, (void *)&amp;var2, &amp;size, NULL, 0)	\
858  	    == 0) {							\
859  		emitter_kv_note(emitter, name, &quot;opt.&quot;name,		\
860  		    emitter_type, &amp;var1, altname, emitter_type,		\
861  		    &amp;var2);						\
862  	}
863  #define OPT_WRITE_BOOL(name) OPT_WRITE(name, bv, bsz, emitter_type_bool)
864  #define OPT_WRITE_BOOL_MUTABLE(name, altname)				\
865  	OPT_WRITE_MUTABLE(name, bv, bv2, bsz, emitter_type_bool, altname)
866  #define OPT_WRITE_UNSIGNED(name)					\
867  	OPT_WRITE(name, uv, usz, emitter_type_unsigned)
868  #define OPT_WRITE_SIZE_T(name)						\
869  	OPT_WRITE(name, sv, ssz, emitter_type_size)
870  #define OPT_WRITE_SSIZE_T(name)						\
871  	OPT_WRITE(name, ssv, sssz, emitter_type_ssize)
872  #define OPT_WRITE_SSIZE_T_MUTABLE(name, altname)			\
873  	OPT_WRITE_MUTABLE(name, ssv, ssv2, sssz, emitter_type_ssize,	\
874  	    altname)
875  #define OPT_WRITE_CHAR_P(name)						\
876  	OPT_WRITE(name, cpv, cpsz, emitter_type_string)
877  	emitter_dict_begin(emitter, &quot;opt&quot;, &quot;Run-time option settings&quot;);
878  	OPT_WRITE_BOOL(&quot;abort&quot;)
879  	OPT_WRITE_BOOL(&quot;abort_conf&quot;)
880  	OPT_WRITE_BOOL(&quot;confirm_conf&quot;)
881  	OPT_WRITE_BOOL(&quot;retain&quot;)
882  	OPT_WRITE_CHAR_P(&quot;dss&quot;)
883  	OPT_WRITE_UNSIGNED(&quot;narenas&quot;)
884  	OPT_WRITE_CHAR_P(&quot;percpu_arena&quot;)
885  	OPT_WRITE_SIZE_T(&quot;oversize_threshold&quot;)
886  	OPT_WRITE_CHAR_P(&quot;metadata_thp&quot;)
887  	OPT_WRITE_BOOL_MUTABLE(&quot;background_thread&quot;, &quot;background_thread&quot;)
888  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;dirty_decay_ms&quot;, &quot;arenas.dirty_decay_ms&quot;)
889  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;muzzy_decay_ms&quot;, &quot;arenas.muzzy_decay_ms&quot;)
890  	OPT_WRITE_SIZE_T(&quot;lg_extent_max_active_fit&quot;)
891  	OPT_WRITE_CHAR_P(&quot;junk&quot;)
892  	OPT_WRITE_BOOL(&quot;zero&quot;)
893  	OPT_WRITE_BOOL(&quot;utrace&quot;)
894  	OPT_WRITE_BOOL(&quot;xmalloc&quot;)
895  	OPT_WRITE_BOOL(&quot;tcache&quot;)
896  	OPT_WRITE_SSIZE_T(&quot;lg_tcache_max&quot;)
897  	OPT_WRITE_CHAR_P(&quot;thp&quot;)
898  	OPT_WRITE_BOOL(&quot;prof&quot;)
899  	OPT_WRITE_CHAR_P(&quot;prof_prefix&quot;)
900  	OPT_WRITE_BOOL_MUTABLE(&quot;prof_active&quot;, &quot;prof.active&quot;)
901  	OPT_WRITE_BOOL_MUTABLE(&quot;prof_thread_active_init&quot;,
902  	    &quot;prof.thread_active_init&quot;)
903  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;lg_prof_sample&quot;, &quot;prof.lg_sample&quot;)
904  	OPT_WRITE_BOOL(&quot;prof_accum&quot;)
905  	OPT_WRITE_SSIZE_T(&quot;lg_prof_interval&quot;)
906  	OPT_WRITE_BOOL(&quot;prof_gdump&quot;)
907  	OPT_WRITE_BOOL(&quot;prof_final&quot;)
908  	OPT_WRITE_BOOL(&quot;prof_leak&quot;)
909  	OPT_WRITE_BOOL(&quot;stats_print&quot;)
910  	OPT_WRITE_CHAR_P(&quot;stats_print_opts&quot;)
911  	emitter_dict_end(emitter);
912  #undef OPT_WRITE
913  #undef OPT_WRITE_MUTABLE
914  #undef OPT_WRITE_BOOL
915  #undef OPT_WRITE_BOOL_MUTABLE
916  #undef OPT_WRITE_UNSIGNED
917  #undef OPT_WRITE_SSIZE_T
918  #undef OPT_WRITE_SSIZE_T_MUTABLE
919  #undef OPT_WRITE_CHAR_P
920  	if (config_prof) {
921  		emitter_dict_begin(emitter, &quot;prof&quot;, &quot;Profiling settings&quot;);
922  		CTL_GET(&quot;prof.thread_active_init&quot;, &amp;bv, bool);
923  		emitter_kv(emitter, &quot;thread_active_init&quot;,
924  		    &quot;prof.thread_active_init&quot;, emitter_type_bool, &amp;bv);
925  		CTL_GET(&quot;prof.active&quot;, &amp;bv, bool);
926  		emitter_kv(emitter, &quot;active&quot;, &quot;prof.active&quot;, emitter_type_bool,
927  		    &amp;bv);
928  		CTL_GET(&quot;prof.gdump&quot;, &amp;bv, bool);
929  		emitter_kv(emitter, &quot;gdump&quot;, &quot;prof.gdump&quot;, emitter_type_bool,
930  		    &amp;bv);
931  		CTL_GET(&quot;prof.interval&quot;, &amp;u64v, uint64_t);
932  		emitter_kv(emitter, &quot;interval&quot;, &quot;prof.interval&quot;,
933  		    emitter_type_uint64, &amp;u64v);
934  		CTL_GET(&quot;prof.lg_sample&quot;, &amp;ssv, ssize_t);
935  		emitter_kv(emitter, &quot;lg_sample&quot;, &quot;prof.lg_sample&quot;,
936  		    emitter_type_ssize, &amp;ssv);
937  		emitter_dict_end(emitter); &amp;bsol;* Close &quot;prof&quot;. */
938  	}
939  	emitter_json_object_kv_begin(emitter, &quot;arenas&quot;);
940  	CTL_GET(&quot;arenas.narenas&quot;, &amp;uv, unsigned);
941  	emitter_kv(emitter, &quot;narenas&quot;, &quot;Arenas&quot;, emitter_type_unsigned, &amp;uv);
942  	CTL_GET(&quot;arenas.dirty_decay_ms&quot;, &amp;ssv, ssize_t);
943  	emitter_json_kv(emitter, &quot;dirty_decay_ms&quot;, emitter_type_ssize, &amp;ssv);
944  	CTL_GET(&quot;arenas.muzzy_decay_ms&quot;, &amp;ssv, ssize_t);
945  	emitter_json_kv(emitter, &quot;muzzy_decay_ms&quot;, emitter_type_ssize, &amp;ssv);
946  	CTL_GET(&quot;arenas.quantum&quot;, &amp;sv, size_t);
947  	emitter_kv(emitter, &quot;quantum&quot;, &quot;Quantum size&quot;, emitter_type_size, &amp;sv);
948  	CTL_GET(&quot;arenas.page&quot;, &amp;sv, size_t);
949  	emitter_kv(emitter, &quot;page&quot;, &quot;Page size&quot;, emitter_type_size, &amp;sv);
950  	if (je_mallctl(&quot;arenas.tcache_max&quot;, (void *)&amp;sv, &amp;ssz, NULL, 0) == 0) {
951  		emitter_kv(emitter, &quot;tcache_max&quot;,
952  		    &quot;Maximum thread-cached size class&quot;, emitter_type_size, &amp;sv);
953  	}
954  	unsigned nbins;
955  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
956  	emitter_kv(emitter, &quot;nbins&quot;, &quot;Number of bin size classes&quot;,
957  	    emitter_type_unsigned, &amp;nbins);
958  	unsigned nhbins;
959  	CTL_GET(&quot;arenas.nhbins&quot;, &amp;nhbins, unsigned);
960  	emitter_kv(emitter, &quot;nhbins&quot;, &quot;Number of thread-cache bin size classes&quot;,
961  	    emitter_type_unsigned, &amp;nhbins);
962  	if (emitter-&gt;output == emitter_output_json) {
963  		emitter_json_array_kv_begin(emitter, &quot;bin&quot;);
964  		for (unsigned i = 0; i &lt; nbins; i++) {
965  			emitter_json_object_begin(emitter);
966  			CTL_M2_GET(&quot;arenas.bin.0.size&quot;, i, &amp;sv, size_t);
967  			emitter_json_kv(emitter, &quot;size&quot;, emitter_type_size,
968  			    &amp;sv);
969  			CTL_M2_GET(&quot;arenas.bin.0.nregs&quot;, i, &amp;u32v, uint32_t);
970  			emitter_json_kv(emitter, &quot;nregs&quot;, emitter_type_uint32,
971  			    &amp;u32v);
972  			CTL_M2_GET(&quot;arenas.bin.0.slab_size&quot;, i, &amp;sv, size_t);
973  			emitter_json_kv(emitter, &quot;slab_size&quot;, emitter_type_size,
974  			    &amp;sv);
975  			CTL_M2_GET(&quot;arenas.bin.0.nshards&quot;, i, &amp;u32v, uint32_t);
976  			emitter_json_kv(emitter, &quot;nshards&quot;, emitter_type_uint32,
977  			    &amp;u32v);
978  			emitter_json_object_end(emitter);
979  		}
980  		emitter_json_array_end(emitter); &amp;bsol;* Close &quot;bin&quot;. */
981  	}
982  	unsigned nlextents;
983  	CTL_GET(&quot;arenas.nlextents&quot;, &amp;nlextents, unsigned);
984  	emitter_kv(emitter, &quot;nlextents&quot;, &quot;Number of large size classes&quot;,
985  	    emitter_type_unsigned, &amp;nlextents);
986  	if (emitter-&gt;output == emitter_output_json) {
987  		emitter_json_array_kv_begin(emitter, &quot;lextent&quot;);
988  		for (unsigned i = 0; i &lt; nlextents; i++) {
989  			emitter_json_object_begin(emitter);
990  			CTL_M2_GET(&quot;arenas.lextent.0.size&quot;, i, &amp;sv, size_t);
991  			emitter_json_kv(emitter, &quot;size&quot;, emitter_type_size,
992  			    &amp;sv);
993  			emitter_json_object_end(emitter);
994  		}
995  		emitter_json_array_end(emitter); &amp;bsol;* Close &quot;lextent&quot;. */
996  	}
997  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;arenas&quot; */
998  }
999  static void
1000  stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
1001      bool unmerged, bool bins, bool large, bool mutex, bool extents) {
1002  	size_t allocated, active, metadata, metadata_thp, resident, mapped,
1003  	    retained;
1004  	size_t num_background_threads;
1005  	uint64_t background_thread_num_runs, background_thread_run_interval;
1006  	CTL_GET(&quot;stats.allocated&quot;, &amp;allocated, size_t);
1007  	CTL_GET(&quot;stats.active&quot;, &amp;active, size_t);
1008  	CTL_GET(&quot;stats.metadata&quot;, &amp;metadata, size_t);
1009  	CTL_GET(&quot;stats.metadata_thp&quot;, &amp;metadata_thp, size_t);
1010  	CTL_GET(&quot;stats.resident&quot;, &amp;resident, size_t);
1011  	CTL_GET(&quot;stats.mapped&quot;, &amp;mapped, size_t);
1012  	CTL_GET(&quot;stats.retained&quot;, &amp;retained, size_t);
1013  	if (have_background_thread) {
1014  		CTL_GET(&quot;stats.background_thread.num_threads&quot;,
1015  		    &amp;num_background_threads, size_t);
1016  		CTL_GET(&quot;stats.background_thread.num_runs&quot;,
1017  		    &amp;background_thread_num_runs, uint64_t);
1018  		CTL_GET(&quot;stats.background_thread.run_interval&quot;,
1019  		    &amp;background_thread_run_interval, uint64_t);
1020  	} else {
1021  		num_background_threads = 0;
1022  		background_thread_num_runs = 0;
1023  		background_thread_run_interval = 0;
1024  	}
1025  	emitter_json_object_kv_begin(emitter, &quot;stats&quot;);
1026  	emitter_json_kv(emitter, &quot;allocated&quot;, emitter_type_size, &amp;allocated);
1027  	emitter_json_kv(emitter, &quot;active&quot;, emitter_type_size, &amp;active);
1028  	emitter_json_kv(emitter, &quot;metadata&quot;, emitter_type_size, &amp;metadata);
1029  	emitter_json_kv(emitter, &quot;metadata_thp&quot;, emitter_type_size,
1030  	    &amp;metadata_thp);
1031  	emitter_json_kv(emitter, &quot;resident&quot;, emitter_type_size, &amp;resident);
1032  	emitter_json_kv(emitter, &quot;mapped&quot;, emitter_type_size, &amp;mapped);
1033  	emitter_json_kv(emitter, &quot;retained&quot;, emitter_type_size, &amp;retained);
1034  	emitter_table_printf(emitter, &quot;Allocated: %zu, active: %zu, &quot;
1035  	    &quot;metadata: %zu (n_thp %zu), resident: %zu, mapped: %zu, &quot;
1036  	    &quot;retained: %zu\n&quot;, allocated, active, metadata, metadata_thp,
1037  	    resident, mapped, retained);
1038  	emitter_json_object_kv_begin(emitter, &quot;background_thread&quot;);
1039  	emitter_json_kv(emitter, &quot;num_threads&quot;, emitter_type_size,
1040  	    &amp;num_background_threads);
1041  	emitter_json_kv(emitter, &quot;num_runs&quot;, emitter_type_uint64,
1042  	    &amp;background_thread_num_runs);
1043  	emitter_json_kv(emitter, &quot;run_interval&quot;, emitter_type_uint64,
1044  	    &amp;background_thread_run_interval);
1045  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;background_thread&quot;. */
1046  	emitter_table_printf(emitter, &quot;Background threads: %zu, &quot;
1047  	    &quot;num_runs: %&quot;FMTu64&quot;, run_interval: %&quot;FMTu64&quot; ns\n&quot;,
1048  	    num_background_threads, background_thread_num_runs,
1049  	    background_thread_run_interval);
1050  	if (mutex) {
1051  		emitter_row_t row;
1052  		emitter_col_t name;
1053  		emitter_col_t col64[mutex_prof_num_uint64_t_counters];
1054  		emitter_col_t col32[mutex_prof_num_uint32_t_counters];
1055  		uint64_t uptime;
1056  		emitter_row_init(&amp;row);
1057  		mutex_stats_init_cols(&amp;row, &quot;&quot;, &amp;name, col64, col32);
1058  		emitter_table_row(emitter, &amp;row);
1059  		emitter_json_object_kv_begin(emitter, &quot;mutexes&quot;);
1060  		CTL_M2_GET(&quot;stats.arenas.0.uptime&quot;, 0, &amp;uptime, uint64_t);
1061  		for (int i = 0; i &lt; mutex_prof_num_global_mutexes; i++) {
1062  			mutex_stats_read_global(global_mutex_names[i], &amp;name,
1063  			    col64, col32, uptime);
1064  			emitter_json_object_kv_begin(emitter, global_mutex_names[i]);
1065  			mutex_stats_emit(emitter, &amp;row, col64, col32);
1066  			emitter_json_object_end(emitter);
1067  		}
1068  		emitter_json_object_end(emitter); &amp;bsol;* Close &quot;mutexes&quot;. */
1069  	}
1070  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;stats&quot;. */
1071  	if (merged || destroyed || unmerged) {
1072  		unsigned narenas;
1073  		emitter_json_object_kv_begin(emitter, &quot;stats.arenas&quot;);
1074  		CTL_GET(&quot;arenas.narenas&quot;, &amp;narenas, unsigned);
1075  		size_t mib[3];
1076  		size_t miblen = sizeof(mib) / sizeof(size_t);
1077  		size_t sz;
1078  		VARIABLE_ARRAY(bool, initialized, narenas);
1079  		bool destroyed_initialized;
1080  		unsigned i, j, ninitialized;
1081  		xmallctlnametomib(&quot;arena.0.initialized&quot;, mib, &amp;miblen);
1082  		for (i = ninitialized = 0; i &lt; narenas; i++) {
1083  			mib[1] = i;
1084  			sz = sizeof(bool);
1085  			xmallctlbymib(mib, miblen, &amp;initialized[i], &amp;sz,
1086  			    NULL, 0);
1087  			if (initialized[i]) {
1088  				ninitialized++;
1089  			}
1090  		}
1091  		mib[1] = MALLCTL_ARENAS_DESTROYED;
1092  		sz = sizeof(bool);
1093  		xmallctlbymib(mib, miblen, &amp;destroyed_initialized, &amp;sz,
1094  		    NULL, 0);
1095  		if (merged &amp;&amp; (ninitialized &gt; 1 || !unmerged)) {
1096  			emitter_table_printf(emitter, &quot;Merged arenas stats:\n&quot;);
1097  			emitter_json_object_kv_begin(emitter, &quot;merged&quot;);
1098  			stats_arena_print(emitter, MALLCTL_ARENAS_ALL, bins,
1099  			    large, mutex, extents);
1100  			emitter_json_object_end(emitter); &amp;bsol;* Close &quot;merged&quot;. */
1101  		}
1102  		if (destroyed_initialized &amp;&amp; destroyed) {
1103  			emitter_table_printf(emitter,
1104  			    &quot;Destroyed arenas stats:\n&quot;);
1105  			emitter_json_object_kv_begin(emitter, &quot;destroyed&quot;);
1106  			stats_arena_print(emitter, MALLCTL_ARENAS_DESTROYED,
1107  			    bins, large, mutex, extents);
1108  			emitter_json_object_end(emitter); &amp;bsol;* Close &quot;destroyed&quot;. */
1109  		}
1110  		if (unmerged) {
1111  			for (i = j = 0; i &lt; narenas; i++) {
1112  				if (initialized[i]) {
1113  					char arena_ind_str[20];
1114  					malloc_snprintf(arena_ind_str,
1115  					    sizeof(arena_ind_str), &quot;%u&quot;, i);
1116  					emitter_json_object_kv_begin(emitter,
1117  					    arena_ind_str);
1118  					emitter_table_printf(emitter,
1119  					    &quot;arenas[%s]:\n&quot;, arena_ind_str);
1120  					stats_arena_print(emitter, i, bins,
1121  					    large, mutex, extents);
1122  					emitter_json_object_end(emitter);
1123  				}
1124  			}
1125  		}
1126  		emitter_json_object_end(emitter); &amp;bsol;* Close &quot;stats.arenas&quot;. */
1127  	}
1128  }
1129  void
1130  stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
1131      const char *opts) {
1132  	int err;
1133  	uint64_t epoch;
1134  	size_t u64sz;
1135  #define OPTION(o, v, d, s) bool v = d;
1136  	STATS_PRINT_OPTIONS
1137  #undef OPTION
1138  	epoch = 1;
1139  	u64sz = sizeof(uint64_t);
1140  	err = je_mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;u64sz, (void *)&amp;epoch,
1141  	    sizeof(uint64_t));
1142  	if (err != 0) {
1143  		if (err == EAGAIN) {
1144  			malloc_write(&quot;&lt;jemalloc&gt;: Memory allocation failure in &quot;
1145  			    &quot;mallctl(\&quot;epoch\&quot;, ...)\n&quot;);
1146  			return;
1147  		}
1148  		malloc_write(&quot;&lt;jemalloc&gt;: Failure in mallctl(\&quot;epoch\&quot;, &quot;
1149  		    &quot;...)\n&quot;);
1150  		abort();
1151  	}
1152  	if (opts != NULL) {
1153  		for (unsigned i = 0; opts[i] != &#x27;\0&#x27;; i++) {
1154  			switch (opts[i]) {
1155  #define OPTION(o, v, d, s) case o: v = s; break;
1156  				STATS_PRINT_OPTIONS
1157  #undef OPTION
1158  			default:;
1159  			}
1160  		}
1161  	}
1162  	emitter_t emitter;
1163  	emitter_init(&amp;emitter,
1164  	    json ? emitter_output_json : emitter_output_table, write_cb,
1165  	    cbopaque);
1166  	emitter_begin(&amp;emitter);
1167  	emitter_table_printf(&amp;emitter, &quot;___ Begin jemalloc statistics ___\n&quot;);
1168  	emitter_json_object_kv_begin(&amp;emitter, &quot;jemalloc&quot;);
1169  	if (general) {
1170  		stats_general_print(&amp;emitter);
1171  	}
1172  	if (config_stats) {
1173  		stats_print_helper(&amp;emitter, merged, destroyed, unmerged,
1174  		    bins, large, mutex, extents);
1175  	}
1176  	emitter_json_object_end(&amp;emitter); &amp;bsol;* Closes the &quot;jemalloc&quot; dict. */
1177  	emitter_table_printf(&amp;emitter, &quot;--- End jemalloc statistics ---\n&quot;);
1178  	emitter_end(&amp;emitter);
1179  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_7.c</h3>
            <pre><code>1  #define JEMALLOC_STATS_C_
2  #include &quot;jemalloc/internal/jemalloc_preamble.h&quot;
3  #include &quot;jemalloc/internal/jemalloc_internal_includes.h&quot;
4  #include &quot;jemalloc/internal/assert.h&quot;
5  #include &quot;jemalloc/internal/ctl.h&quot;
6  #include &quot;jemalloc/internal/emitter.h&quot;
7  #include &quot;jemalloc/internal/mutex.h&quot;
8  #include &quot;jemalloc/internal/mutex_prof.h&quot;
9  const char *global_mutex_names[mutex_prof_num_global_mutexes] = {
10  #define OP(mtx) #mtx,
11  	MUTEX_PROF_GLOBAL_MUTEXES
12  #undef OP
13  };
14  const char *arena_mutex_names[mutex_prof_num_arena_mutexes] = {
15  #define OP(mtx) #mtx,
16  	MUTEX_PROF_ARENA_MUTEXES
17  #undef OP
18  };
19  #define CTL_GET(n, v, t) do {						\
20  	size_t sz = sizeof(t);						\
21  	xmallctl(n, (void *)v, &amp;sz, NULL, 0);				\
22  } while (0)
23  #define CTL_M2_GET(n, i, v, t) do {					\
24  	size_t mib[CTL_MAX_DEPTH];					\
25  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
26  	size_t sz = sizeof(t);						\
27  	xmallctlnametomib(n, mib, &amp;miblen);				\
28  	mib[2] = (i);							\
29  	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
30  } while (0)
31  #define CTL_M2_M4_GET(n, i, j, v, t) do {				\
32  	size_t mib[CTL_MAX_DEPTH];					\
33  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
34  	size_t sz = sizeof(t);						\
35  	xmallctlnametomib(n, mib, &amp;miblen);				\
36  	mib[2] = (i);							\
37  	mib[4] = (j);							\
38  	xmallctlbymib(mib, miblen, (void *)v, &amp;sz, NULL, 0);		\
39  } while (0)
40  bool opt_stats_print = false;
41  char opt_stats_print_opts[stats_print_tot_num_options+1] = &quot;&quot;;
42  static uint64_t
43  rate_per_second(uint64_t value, uint64_t uptime_ns) {
44  	uint64_t billion = 1000000000;
45  	if (uptime_ns == 0 || value == 0) {
46  		return 0;
47  	}
48  	if (uptime_ns &lt; billion) {
49  		return value;
50  	} else {
51  		uint64_t uptime_s = uptime_ns / billion;
52  		return value / uptime_s;
53  	}
54  }
55  static bool
56  get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
57  	if (divisor == 0 || dividend &gt; divisor) {
58  		return true;
59  	}
60  	if (dividend &gt; 0) {
61  		assert(UINT64_MAX / dividend &gt;= 1000);
62  	}
63  	unsigned n = (unsigned)((dividend * 1000) / divisor);
64  	if (n &lt; 10) {
65  		malloc_snprintf(str, 6, &quot;0.00%u&quot;, n);
66  	} else if (n &lt; 100) {
67  		malloc_snprintf(str, 6, &quot;0.0%u&quot;, n);
68  	} else if (n &lt; 1000) {
69  		malloc_snprintf(str, 6, &quot;0.%u&quot;, n);
70  	} else {
71  		malloc_snprintf(str, 6, &quot;1&quot;);
72  	}
73  	return false;
74  }
75  #define MUTEX_CTL_STR_MAX_LENGTH 128
76  static void
77  gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
78      const char *mutex, const char *counter) {
79  	malloc_snprintf(str, buf_len, &quot;stats.%s.%s.%s&quot;, prefix, mutex, counter);
80  }
81  static void
82  mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
83      emitter_col_t *name,
84      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
85      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
86  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
87  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
88  	emitter_col_t *col;
89  	if (name != NULL) {
90  		emitter_col_init(name, row);
91  		name-&gt;justify = emitter_justify_left;
92  		name-&gt;width = 21;
93  		name-&gt;type = emitter_type_title;
94  		name-&gt;str_val = table_name;
95  	}
96  #define WIDTH_uint32_t 12
97  #define WIDTH_uint64_t 16
98  #define OP(counter, counter_type, human, derived, base_counter)	\
99  	col = &amp;col_##counter_type[k_##counter_type];			\
100  	++k_##counter_type;						\
101  	emitter_col_init(col, row);					\
102  	col-&gt;justify = emitter_justify_right;				\
103  	col-&gt;width = derived ? 8 : WIDTH_##counter_type;		\
104  	col-&gt;type = emitter_type_title;					\
105  	col-&gt;str_val = human;
106  	MUTEX_PROF_COUNTERS
107  #undef OP
108  #undef WIDTH_uint32_t
109  #undef WIDTH_uint64_t
110  	col_uint64_t[mutex_counter_total_wait_time_ps].width = 10;
111  }
112  static void
113  mutex_stats_read_global(const char *name, emitter_col_t *col_name,
114      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
115      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
116      uint64_t uptime) {
117  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
118  	col_name-&gt;str_val = name;
119  	emitter_col_t *dst;
120  #define EMITTER_TYPE_uint32_t emitter_type_uint32
121  #define EMITTER_TYPE_uint64_t emitter_type_uint64
122  #define OP(counter, counter_type, human, derived, base_counter)	\
123  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
124  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
125  	if (!derived) {							\
126  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,	\
127  		    &quot;mutexes&quot;, name, #counter);				\
128  		CTL_GET(cmd, (counter_type *)&amp;dst-&gt;bool_val, counter_type);	\
129  	} else { \
130  	    emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
131  	    dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
132  	}
133  	MUTEX_PROF_COUNTERS
134  #undef OP
135  #undef EMITTER_TYPE_uint32_t
136  #undef EMITTER_TYPE_uint64_t
137  }
138  static void
139  mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
140      const char *name, emitter_col_t *col_name,
141      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
142      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
143      uint64_t uptime) {
144  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
145  	col_name-&gt;str_val = name;
146  	emitter_col_t *dst;
147  #define EMITTER_TYPE_uint32_t emitter_type_uint32
148  #define EMITTER_TYPE_uint64_t emitter_type_uint64
149  #define OP(counter, counter_type, human, derived, base_counter)	\
150  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
151  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
152  	if (!derived) {                                   \
153  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
154  		    &quot;arenas.0.mutexes&quot;, arena_mutex_names[mutex_ind], #counter);\
155  		CTL_M2_GET(cmd, arena_ind, (counter_type *)&amp;dst-&gt;bool_val, counter_type); \
156  	} else {                      \
157  		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter];	\
158  		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
159  	}
160  	MUTEX_PROF_COUNTERS
161  #undef OP
162  #undef EMITTER_TYPE_uint32_t
163  #undef EMITTER_TYPE_uint64_t
164  }
165  static void
166  mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
167      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
168      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
169      uint64_t uptime) {
170  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
171  	emitter_col_t *dst;
172  #define EMITTER_TYPE_uint32_t emitter_type_uint32
173  #define EMITTER_TYPE_uint64_t emitter_type_uint64
174  #define OP(counter, counter_type, human, derived, base_counter)	\
175  	dst = &amp;col_##counter_type[mutex_counter_##counter];		\
176  	dst-&gt;type = EMITTER_TYPE_##counter_type;			\
177  	if (!derived) {                                   \
178  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
179  		    &quot;arenas.0.bins.0&quot;,&quot;mutex&quot;, #counter);            \
180  		CTL_M2_M4_GET(cmd, arena_ind, bin_ind,                \
181  		    (counter_type *)&amp;dst-&gt;bool_val, counter_type);  \
182  	} else {                      \
183  		emitter_col_t *base = &amp;col_##counter_type[mutex_counter_##base_counter]; \
184  		dst-&gt;counter_type##_val = rate_per_second(base-&gt;counter_type##_val, uptime); \
185  	}
186  	MUTEX_PROF_COUNTERS
187  #undef OP
188  #undef EMITTER_TYPE_uint32_t
189  #undef EMITTER_TYPE_uint64_t
190  }
191  static void
192  mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
193      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
194      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
195  	if (row != NULL) {
196  		emitter_table_row(emitter, row);
197  	}
198  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
199  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
200  	emitter_col_t *col;
201  #define EMITTER_TYPE_uint32_t emitter_type_uint32
202  #define EMITTER_TYPE_uint64_t emitter_type_uint64
203  #define OP(counter, type, human, derived, base_counter)		\
204  	if (!derived) {                    \
205  		col = &amp;col_##type[k_##type];                        \
206  		++k_##type;                            \
207  		emitter_json_kv(emitter, #counter, EMITTER_TYPE_##type,        \
208  		    (const void *)&amp;col-&gt;bool_val); \
209  	}
210  	MUTEX_PROF_COUNTERS;
211  #undef OP
212  #undef EMITTER_TYPE_uint32_t
213  #undef EMITTER_TYPE_uint64_t
214  }
215  #define COL(row_name, column_name, left_or_right, col_width, etype)      \
216  	emitter_col_t col_##column_name;                                     \
217  	emitter_col_init(&amp;col_##column_name, &amp;row_name);                     \
218  	col_##column_name.justify = emitter_justify_##left_or_right;         \
219  	col_##column_name.width = col_width;                                 \
220  	col_##column_name.type = emitter_type_##etype;
221  #define COL_HDR(row_name, column_name, human, left_or_right, col_width, etype)  \
222  	COL(row_name, column_name, left_or_right, col_width, etype)	         \
223  	emitter_col_t header_##column_name;                                  \
224  	emitter_col_init(&amp;header_##column_name, &amp;header_##row_name);         \
225  	header_##column_name.justify = emitter_justify_##left_or_right;      \
226  	header_##column_name.width = col_width;                              \
227  	header_##column_name.type = emitter_type_title;                      \
228  	header_##column_name.str_val = human ? human : #column_name;
229  static void
230  stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i, uint64_t uptime) {
231  	size_t page;
232  	bool in_gap, in_gap_prev;
233  	unsigned nbins, j;
234  	CTL_GET(&quot;arenas.page&quot;, &amp;page, size_t);
235  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
236  	emitter_row_t header_row;
237  	emitter_row_init(&amp;header_row);
238  	emitter_row_t row;
239  	emitter_row_init(&amp;row);
240  	COL_HDR(row, size, NULL, right, 20, size)
241  	COL_HDR(row, ind, NULL, right, 4, unsigned)
242  	COL_HDR(row, allocated, NULL, right, 13, uint64)
243  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
244  	COL_HDR(row, nmalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
245  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
246  	COL_HDR(row, ndalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
247  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
248  	COL_HDR(row, nrequests_ps, &quot;(#/sec)&quot;, right, 10, uint64)
249  	COL_HDR(row, nshards, NULL, right, 9, unsigned)
250  	COL_HDR(row, curregs, NULL, right, 13, size)
251  	COL_HDR(row, curslabs, NULL, right, 13, size)
252  	COL_HDR(row, nonfull_slabs, NULL, right, 15, size)
253  	COL_HDR(row, regs, NULL, right, 5, unsigned)
254  	COL_HDR(row, pgs, NULL, right, 4, size)
255  	COL_HDR(row, justify_spacer, NULL, right, 1, title)
256  	COL_HDR(row, util, NULL, right, 6, title)
257  	COL_HDR(row, nfills, NULL, right, 13, uint64)
258  	COL_HDR(row, nfills_ps, &quot;(#/sec)&quot;, right, 8, uint64)
259  	COL_HDR(row, nflushes, NULL, right, 13, uint64)
260  	COL_HDR(row, nflushes_ps, &quot;(#/sec)&quot;, right, 8, uint64)
261  	COL_HDR(row, nslabs, NULL, right, 13, uint64)
262  	COL_HDR(row, nreslabs, NULL, right, 13, uint64)
263  	COL_HDR(row, nreslabs_ps, &quot;(#/sec)&quot;, right, 8, uint64)
264  	header_justify_spacer.str_val = &quot; &quot;;
265  	col_justify_spacer.str_val = &quot; &quot;;
266  	emitter_col_t col_mutex64[mutex_prof_num_uint64_t_counters];
267  	emitter_col_t col_mutex32[mutex_prof_num_uint32_t_counters];
268  	emitter_col_t header_mutex64[mutex_prof_num_uint64_t_counters];
269  	emitter_col_t header_mutex32[mutex_prof_num_uint32_t_counters];
270  	if (mutex) {
271  		mutex_stats_init_cols(&amp;row, NULL, NULL, col_mutex64,
272  		    col_mutex32);
273  		mutex_stats_init_cols(&amp;header_row, NULL, NULL, header_mutex64,
274  		    header_mutex32);
275  	}
276  	header_size.width -=5;
277  	emitter_table_printf(emitter, &quot;bins:&quot;);
278  	emitter_table_row(emitter, &amp;header_row);
279  	emitter_json_array_kv_begin(emitter, &quot;bins&quot;);
280  	for (j = 0, in_gap = false; j &lt; nbins; j++) {
281  		uint64_t nslabs;
282  		size_t reg_size, slab_size, curregs;
283  		size_t curslabs;
284  		size_t nonfull_slabs;
285  		uint32_t nregs, nshards;
286  		uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
287  		uint64_t nreslabs;
288  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nslabs&quot;, i, j, &amp;nslabs,
289  		    uint64_t);
290  		in_gap_prev = in_gap;
291  		in_gap = (nslabs == 0);
292  		if (in_gap_prev &amp;&amp; !in_gap) {
293  			emitter_table_printf(emitter,
294  			    &quot;                     ---\n&quot;);
295  		}
296  		CTL_M2_GET(&quot;arenas.bin.0.size&quot;, j, &amp;reg_size, size_t);
297  		CTL_M2_GET(&quot;arenas.bin.0.nregs&quot;, j, &amp;nregs, uint32_t);
298  		CTL_M2_GET(&quot;arenas.bin.0.slab_size&quot;, j, &amp;slab_size, size_t);
299  		CTL_M2_GET(&quot;arenas.bin.0.nshards&quot;, j, &amp;nshards, uint32_t);
300  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nmalloc&quot;, i, j, &amp;nmalloc,
301  		    uint64_t);
302  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.ndalloc&quot;, i, j, &amp;ndalloc,
303  		    uint64_t);
304  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.curregs&quot;, i, j, &amp;curregs,
305  		    size_t);
306  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nrequests&quot;, i, j,
307  		    &amp;nrequests, uint64_t);
308  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nfills&quot;, i, j, &amp;nfills,
309  		    uint64_t);
310  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nflushes&quot;, i, j, &amp;nflushes,
311  		    uint64_t);
312  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nreslabs&quot;, i, j, &amp;nreslabs,
313  		    uint64_t);
314  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.curslabs&quot;, i, j, &amp;curslabs,
315  		    size_t);
316  		CTL_M2_M4_GET(&quot;stats.arenas.0.bins.0.nonfull_slabs&quot;, i, j, &amp;nonfull_slabs,
317  		    size_t);
318  		if (mutex) {
319  			mutex_stats_read_arena_bin(i, j, col_mutex64,
320  			    col_mutex32, uptime);
321  		}
322  		emitter_json_object_begin(emitter);
323  		emitter_json_kv(emitter, &quot;nmalloc&quot;, emitter_type_uint64,
324  		    &amp;nmalloc);
325  		emitter_json_kv(emitter, &quot;ndalloc&quot;, emitter_type_uint64,
326  		    &amp;ndalloc);
327  		emitter_json_kv(emitter, &quot;curregs&quot;, emitter_type_size,
328  		    &amp;curregs);
329  		emitter_json_kv(emitter, &quot;nrequests&quot;, emitter_type_uint64,
330  		    &amp;nrequests);
331  		emitter_json_kv(emitter, &quot;nfills&quot;, emitter_type_uint64,
332  		    &amp;nfills);
333  		emitter_json_kv(emitter, &quot;nflushes&quot;, emitter_type_uint64,
334  		    &amp;nflushes);
335  		emitter_json_kv(emitter, &quot;nreslabs&quot;, emitter_type_uint64,
336  		    &amp;nreslabs);
337  		emitter_json_kv(emitter, &quot;curslabs&quot;, emitter_type_size,
338  		    &amp;curslabs);
339  		emitter_json_kv(emitter, &quot;nonfull_slabs&quot;, emitter_type_size,
340  		    &amp;nonfull_slabs);
341  		if (mutex) {
342  			emitter_json_object_kv_begin(emitter, &quot;mutex&quot;);
343  			mutex_stats_emit(emitter, NULL, col_mutex64,
344  			    col_mutex32);
345  			emitter_json_object_end(emitter);
346  		}
347  		emitter_json_object_end(emitter);
348  		size_t availregs = nregs * curslabs;
349  		char util[6];
350  		if (get_rate_str((uint64_t)curregs, (uint64_t)availregs, util))
351  		{
352  			if (availregs == 0) {
353  				malloc_snprintf(util, sizeof(util), &quot;1&quot;);
354  			} else if (curregs &gt; availregs) {
355  				malloc_snprintf(util, sizeof(util), &quot; race&quot;);
356  			} else {
357  				not_reached();
358  			}
359  		}
360  		col_size.size_val = reg_size;
361  		col_ind.unsigned_val = j;
362  		col_allocated.size_val = curregs * reg_size;
363  		col_nmalloc.uint64_val = nmalloc;
364  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
365  		col_ndalloc.uint64_val = ndalloc;
366  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
367  		col_nrequests.uint64_val = nrequests;
368  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
369  		col_nshards.unsigned_val = nshards;
370  		col_curregs.size_val = curregs;
371  		col_curslabs.size_val = curslabs;
372  		col_nonfull_slabs.size_val = nonfull_slabs;
373  		col_regs.unsigned_val = nregs;
374  		col_pgs.size_val = slab_size / page;
375  		col_util.str_val = util;
376  		col_nfills.uint64_val = nfills;
377  		col_nfills_ps.uint64_val = rate_per_second(nfills, uptime);
378  		col_nflushes.uint64_val = nflushes;
379  		col_nflushes_ps.uint64_val = rate_per_second(nflushes, uptime);
380  		col_nslabs.uint64_val = nslabs;
381  		col_nreslabs.uint64_val = nreslabs;
382  		col_nreslabs_ps.uint64_val = rate_per_second(nreslabs, uptime);
383  		emitter_table_row(emitter, &amp;row);
384  	}
385  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;bins&quot;. */
386  	if (in_gap) {
387  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
388  	}
389  }
390  static void
391  stats_arena_lextents_print(emitter_t *emitter, unsigned i, uint64_t uptime) {
392  	unsigned nbins, nlextents, j;
393  	bool in_gap, in_gap_prev;
394  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
395  	CTL_GET(&quot;arenas.nlextents&quot;, &amp;nlextents, unsigned);
396  	emitter_row_t header_row;
397  	emitter_row_init(&amp;header_row);
398  	emitter_row_t row;
399  	emitter_row_init(&amp;row);
400  	COL_HDR(row, size, NULL, right, 20, size)
401  	COL_HDR(row, ind, NULL, right, 4, unsigned)
402  	COL_HDR(row, allocated, NULL, right, 13, size)
403  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
404  	COL_HDR(row, nmalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
405  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
406  	COL_HDR(row, ndalloc_ps, &quot;(#/sec)&quot;, right, 8, uint64)
407  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
408  	COL_HDR(row, nrequests_ps, &quot;(#/sec)&quot;, right, 8, uint64)
409  	COL_HDR(row, curlextents, NULL, right, 13, size)
410  	header_size.width -= 6;
411  	emitter_table_printf(emitter, &quot;large:&quot;);
412  	emitter_table_row(emitter, &amp;header_row);
413  	emitter_json_array_kv_begin(emitter, &quot;lextents&quot;);
414  	for (j = 0, in_gap = false; j &lt; nlextents; j++) {
415  		uint64_t nmalloc, ndalloc, nrequests;
416  		size_t lextent_size, curlextents;
417  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.nmalloc&quot;, i, j,
418  		    &amp;nmalloc, uint64_t);
419  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.ndalloc&quot;, i, j,
420  		    &amp;ndalloc, uint64_t);
421  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.nrequests&quot;, i, j,
422  		    &amp;nrequests, uint64_t);
423  		in_gap_prev = in_gap;
424  		in_gap = (nrequests == 0);
425  		if (in_gap_prev &amp;&amp; !in_gap) {
426  			emitter_table_printf(emitter,
427  			    &quot;                     ---\n&quot;);
428  		}
429  		CTL_M2_GET(&quot;arenas.lextent.0.size&quot;, j, &amp;lextent_size, size_t);
430  		CTL_M2_M4_GET(&quot;stats.arenas.0.lextents.0.curlextents&quot;, i, j,
431  		    &amp;curlextents, size_t);
432  		emitter_json_object_begin(emitter);
433  		emitter_json_kv(emitter, &quot;curlextents&quot;, emitter_type_size,
434  		    &amp;curlextents);
435  		emitter_json_object_end(emitter);
436  		col_size.size_val = lextent_size;
437  		col_ind.unsigned_val = nbins + j;
438  		col_allocated.size_val = curlextents * lextent_size;
439  		col_nmalloc.uint64_val = nmalloc;
440  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
441  		col_ndalloc.uint64_val = ndalloc;
442  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
443  		col_nrequests.uint64_val = nrequests;
444  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
445  		col_curlextents.size_val = curlextents;
446  		if (!in_gap) {
447  			emitter_table_row(emitter, &amp;row);
448  		}
449  	}
450  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;lextents&quot;. */
451  	if (in_gap) {
452  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
453  	}
454  }
455  static void
456  stats_arena_extents_print(emitter_t *emitter, unsigned i) {
457  	unsigned j;
458  	bool in_gap, in_gap_prev;
459  	emitter_row_t header_row;
460  	emitter_row_init(&amp;header_row);
461  	emitter_row_t row;
462  	emitter_row_init(&amp;row);
463  	COL_HDR(row, size, NULL, right, 20, size)
464  	COL_HDR(row, ind, NULL, right, 4, unsigned)
465  	COL_HDR(row, ndirty, NULL, right, 13, size)
466  	COL_HDR(row, dirty, NULL, right, 13, size)
467  	COL_HDR(row, nmuzzy, NULL, right, 13, size)
468  	COL_HDR(row, muzzy, NULL, right, 13, size)
469  	COL_HDR(row, nretained, NULL, right, 13, size)
470  	COL_HDR(row, retained, NULL, right, 13, size)
471  	COL_HDR(row, ntotal, NULL, right, 13, size)
472  	COL_HDR(row, total, NULL, right, 13, size)
473  	header_size.width -= 8;
474  	emitter_table_printf(emitter, &quot;extents:&quot;);
475  	emitter_table_row(emitter, &amp;header_row);
476  	emitter_json_array_kv_begin(emitter, &quot;extents&quot;);
477  	in_gap = false;
478  	for (j = 0; j &lt; SC_NPSIZES; j++) {
479  		size_t ndirty, nmuzzy, nretained, total, dirty_bytes,
480  		    muzzy_bytes, retained_bytes, total_bytes;
481  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.ndirty&quot;, i, j,
482  		    &amp;ndirty, size_t);
483  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.nmuzzy&quot;, i, j,
484  		    &amp;nmuzzy, size_t);
485  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.nretained&quot;, i, j,
486  		    &amp;nretained, size_t);
487  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.dirty_bytes&quot;, i, j,
488  		    &amp;dirty_bytes, size_t);
489  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.muzzy_bytes&quot;, i, j,
490  		    &amp;muzzy_bytes, size_t);
491  		CTL_M2_M4_GET(&quot;stats.arenas.0.extents.0.retained_bytes&quot;, i, j,
492  		    &amp;retained_bytes, size_t);
493  		total = ndirty + nmuzzy + nretained;
494  		total_bytes = dirty_bytes + muzzy_bytes + retained_bytes;
495  		in_gap_prev = in_gap;
496  		in_gap = (total == 0);
497  		if (in_gap_prev &amp;&amp; !in_gap) {
498  			emitter_table_printf(emitter,
499  			    &quot;                     ---\n&quot;);
500  		}
501  		emitter_json_object_begin(emitter);
502  		emitter_json_kv(emitter, &quot;ndirty&quot;, emitter_type_size, &amp;ndirty);
503  		emitter_json_kv(emitter, &quot;nmuzzy&quot;, emitter_type_size, &amp;nmuzzy);
504  		emitter_json_kv(emitter, &quot;nretained&quot;, emitter_type_size,
505  		    &amp;nretained);
506  		emitter_json_kv(emitter, &quot;dirty_bytes&quot;, emitter_type_size,
507  		    &amp;dirty_bytes);
508  		emitter_json_kv(emitter, &quot;muzzy_bytes&quot;, emitter_type_size,
509  		    &amp;muzzy_bytes);
510  		emitter_json_kv(emitter, &quot;retained_bytes&quot;, emitter_type_size,
511  		    &amp;retained_bytes);
512  		emitter_json_object_end(emitter);
513  		col_size.size_val = sz_pind2sz(j);
514  		col_ind.size_val = j;
515  		col_ndirty.size_val = ndirty;
516  		col_dirty.size_val = dirty_bytes;
517  		col_nmuzzy.size_val = nmuzzy;
518  		col_muzzy.size_val = muzzy_bytes;
519  		col_nretained.size_val = nretained;
520  		col_retained.size_val = retained_bytes;
521  		col_ntotal.size_val = total;
522  		col_total.size_val = total_bytes;
523  		if (!in_gap) {
524  			emitter_table_row(emitter, &amp;row);
525  		}
526  	}
527  	emitter_json_array_end(emitter); &amp;bsol;* Close &quot;extents&quot;. */
528  	if (in_gap) {
529  		emitter_table_printf(emitter, &quot;                     ---\n&quot;);
530  	}
531  }
532  static void
533  stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind, uint64_t uptime) {
534  	emitter_row_t row;
535  	emitter_col_t col_name;
536  	emitter_col_t col64[mutex_prof_num_uint64_t_counters];
537  	emitter_col_t col32[mutex_prof_num_uint32_t_counters];
538  	emitter_row_init(&amp;row);
539  	mutex_stats_init_cols(&amp;row, &quot;&quot;, &amp;col_name, col64, col32);
540  	emitter_json_object_kv_begin(emitter, &quot;mutexes&quot;);
541  	emitter_table_row(emitter, &amp;row);
542  	for (mutex_prof_arena_ind_t i = 0; i &lt; mutex_prof_num_arena_mutexes;
543  	    i++) {
544  		const char *name = arena_mutex_names[i];
545  		emitter_json_object_kv_begin(emitter, name);
546  		mutex_stats_read_arena(arena_ind, i, name, &amp;col_name, col64,
547  		    col32, uptime);
548  		mutex_stats_emit(emitter, &amp;row, col64, col32);
549  		emitter_json_object_end(emitter); &amp;bsol;* Close the mutex dict. */
550  	}
551  	emitter_json_object_end(emitter); &amp;bsol;* End &quot;mutexes&quot;. */
552  }
553  static void
554  stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
555      bool mutex, bool extents) {
556  	unsigned nthreads;
557  	const char *dss;
558  	ssize_t dirty_decay_ms, muzzy_decay_ms;
559  	size_t page, pactive, pdirty, pmuzzy, mapped, retained;
560  	size_t base, internal, resident, metadata_thp, extent_avail;
561  	uint64_t dirty_npurge, dirty_nmadvise, dirty_purged;
562  	uint64_t muzzy_npurge, muzzy_nmadvise, muzzy_purged;
563  	size_t small_allocated;
564  	uint64_t small_nmalloc, small_ndalloc, small_nrequests, small_nfills,
565  	    small_nflushes;
566  	size_t large_allocated;
567  	uint64_t large_nmalloc, large_ndalloc, large_nrequests, large_nfills,
568  	    large_nflushes;
569  	size_t tcache_bytes, abandoned_vm;
570  	uint64_t uptime;
571  	CTL_GET(&quot;arenas.page&quot;, &amp;page, size_t);
572  	CTL_M2_GET(&quot;stats.arenas.0.nthreads&quot;, i, &amp;nthreads, unsigned);
573  	emitter_kv(emitter, &quot;nthreads&quot;, &quot;assigned threads&quot;,
574  	    emitter_type_unsigned, &amp;nthreads);
575  	CTL_M2_GET(&quot;stats.arenas.0.uptime&quot;, i, &amp;uptime, uint64_t);
576  	emitter_kv(emitter, &quot;uptime_ns&quot;, &quot;uptime&quot;, emitter_type_uint64,
577  	    &amp;uptime);
578  	CTL_M2_GET(&quot;stats.arenas.0.dss&quot;, i, &amp;dss, const char *);
579  	emitter_kv(emitter, &quot;dss&quot;, &quot;dss allocation precedence&quot;,
580  	    emitter_type_string, &amp;dss);
581  	CTL_M2_GET(&quot;stats.arenas.0.dirty_decay_ms&quot;, i, &amp;dirty_decay_ms,
582  	    ssize_t);
583  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_decay_ms&quot;, i, &amp;muzzy_decay_ms,
584  	    ssize_t);
585  	CTL_M2_GET(&quot;stats.arenas.0.pactive&quot;, i, &amp;pactive, size_t);
586  	CTL_M2_GET(&quot;stats.arenas.0.pdirty&quot;, i, &amp;pdirty, size_t);
587  	CTL_M2_GET(&quot;stats.arenas.0.pmuzzy&quot;, i, &amp;pmuzzy, size_t);
588  	CTL_M2_GET(&quot;stats.arenas.0.dirty_npurge&quot;, i, &amp;dirty_npurge, uint64_t);
589  	CTL_M2_GET(&quot;stats.arenas.0.dirty_nmadvise&quot;, i, &amp;dirty_nmadvise,
590  	    uint64_t);
591  	CTL_M2_GET(&quot;stats.arenas.0.dirty_purged&quot;, i, &amp;dirty_purged, uint64_t);
592  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_npurge&quot;, i, &amp;muzzy_npurge, uint64_t);
593  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_nmadvise&quot;, i, &amp;muzzy_nmadvise,
594  	    uint64_t);
595  	CTL_M2_GET(&quot;stats.arenas.0.muzzy_purged&quot;, i, &amp;muzzy_purged, uint64_t);
596  	emitter_row_t decay_row;
597  	emitter_row_init(&amp;decay_row);
598  	emitter_json_kv(emitter, &quot;dirty_decay_ms&quot;, emitter_type_ssize,
599  	    &amp;dirty_decay_ms);
600  	emitter_json_kv(emitter, &quot;muzzy_decay_ms&quot;, emitter_type_ssize,
601  	    &amp;muzzy_decay_ms);
602  	emitter_json_kv(emitter, &quot;pactive&quot;, emitter_type_size, &amp;pactive);
603  	emitter_json_kv(emitter, &quot;pdirty&quot;, emitter_type_size, &amp;pdirty);
604  	emitter_json_kv(emitter, &quot;pmuzzy&quot;, emitter_type_size, &amp;pmuzzy);
605  	emitter_json_kv(emitter, &quot;dirty_npurge&quot;, emitter_type_uint64,
606  	    &amp;dirty_npurge);
607  	emitter_json_kv(emitter, &quot;dirty_nmadvise&quot;, emitter_type_uint64,
608  	    &amp;dirty_nmadvise);
609  	emitter_json_kv(emitter, &quot;dirty_purged&quot;, emitter_type_uint64,
610  	    &amp;dirty_purged);
611  	emitter_json_kv(emitter, &quot;muzzy_npurge&quot;, emitter_type_uint64,
612  	    &amp;muzzy_npurge);
613  	emitter_json_kv(emitter, &quot;muzzy_nmadvise&quot;, emitter_type_uint64,
614  	    &amp;muzzy_nmadvise);
615  	emitter_json_kv(emitter, &quot;muzzy_purged&quot;, emitter_type_uint64,
616  	    &amp;muzzy_purged);
617  	COL(decay_row, decay_type, right, 9, title);
618  	col_decay_type.str_val = &quot;decaying:&quot;;
619  	COL(decay_row, decay_time, right, 6, title);
620  	col_decay_time.str_val = &quot;time&quot;;
621  	COL(decay_row, decay_npages, right, 13, title);
622  	col_decay_npages.str_val = &quot;npages&quot;;
623  	COL(decay_row, decay_sweeps, right, 13, title);
624  	col_decay_sweeps.str_val = &quot;sweeps&quot;;
625  	COL(decay_row, decay_madvises, right, 13, title);
626  	col_decay_madvises.str_val = &quot;madvises&quot;;
627  	COL(decay_row, decay_purged, right, 13, title);
628  	col_decay_purged.str_val = &quot;purged&quot;;
629  	emitter_table_row(emitter, &amp;decay_row);
630  	col_decay_type.str_val = &quot;dirty:&quot;;
631  	if (dirty_decay_ms &gt;= 0) {
632  		col_decay_time.type = emitter_type_ssize;
633  		col_decay_time.ssize_val = dirty_decay_ms;
634  	} else {
635  		col_decay_time.type = emitter_type_title;
636  		col_decay_time.str_val = &quot;N/A&quot;;
637  	}
638  	col_decay_npages.type = emitter_type_size;
639  	col_decay_npages.size_val = pdirty;
640  	col_decay_sweeps.type = emitter_type_uint64;
641  	col_decay_sweeps.uint64_val = dirty_npurge;
642  	col_decay_madvises.type = emitter_type_uint64;
643  	col_decay_madvises.uint64_val = dirty_nmadvise;
644  	col_decay_purged.type = emitter_type_uint64;
645  	col_decay_purged.uint64_val = dirty_purged;
646  	emitter_table_row(emitter, &amp;decay_row);
647  	col_decay_type.str_val = &quot;muzzy:&quot;;
648  	if (muzzy_decay_ms &gt;= 0) {
649  		col_decay_time.type = emitter_type_ssize;
650  		col_decay_time.ssize_val = muzzy_decay_ms;
651  	} else {
652  		col_decay_time.type = emitter_type_title;
653  		col_decay_time.str_val = &quot;N/A&quot;;
654  	}
655  	col_decay_npages.type = emitter_type_size;
656  	col_decay_npages.size_val = pmuzzy;
657  	col_decay_sweeps.type = emitter_type_uint64;
658  	col_decay_sweeps.uint64_val = muzzy_npurge;
659  	col_decay_madvises.type = emitter_type_uint64;
660  	col_decay_madvises.uint64_val = muzzy_nmadvise;
661  	col_decay_purged.type = emitter_type_uint64;
662  	col_decay_purged.uint64_val = muzzy_purged;
663  	emitter_table_row(emitter, &amp;decay_row);
664  	emitter_row_t alloc_count_row;
665  	emitter_row_init(&amp;alloc_count_row);
666  	COL(alloc_count_row, count_title, left, 21, title);
667  	col_count_title.str_val = &quot;&quot;;
668  	COL(alloc_count_row, count_allocated, right, 16, title);
669  	col_count_allocated.str_val = &quot;allocated&quot;;
670  	COL(alloc_count_row, count_nmalloc, right, 16, title);
671  	col_count_nmalloc.str_val = &quot;nmalloc&quot;;
672  	COL(alloc_count_row, count_nmalloc_ps, right, 8, title);
673  	col_count_nmalloc_ps.str_val = &quot;(#/sec)&quot;;
674  	COL(alloc_count_row, count_ndalloc, right, 16, title);
675  	col_count_ndalloc.str_val = &quot;ndalloc&quot;;
676  	COL(alloc_count_row, count_ndalloc_ps, right, 8, title);
677  	col_count_ndalloc_ps.str_val = &quot;(#/sec)&quot;;
678  	COL(alloc_count_row, count_nrequests, right, 16, title);
679  	col_count_nrequests.str_val = &quot;nrequests&quot;;
680  	COL(alloc_count_row, count_nrequests_ps, right, 10, title);
681  	col_count_nrequests_ps.str_val = &quot;(#/sec)&quot;;
682  	COL(alloc_count_row, count_nfills, right, 16, title);
683  	col_count_nfills.str_val = &quot;nfill&quot;;
684  	COL(alloc_count_row, count_nfills_ps, right, 10, title);
685  	col_count_nfills_ps.str_val = &quot;(#/sec)&quot;;
686  	COL(alloc_count_row, count_nflushes, right, 16, title);
687  	col_count_nflushes.str_val = &quot;nflush&quot;;
688  	COL(alloc_count_row, count_nflushes_ps, right, 10, title);
689  	col_count_nflushes_ps.str_val = &quot;(#/sec)&quot;;
690  	emitter_table_row(emitter, &amp;alloc_count_row);
691  	col_count_nmalloc_ps.type = emitter_type_uint64;
692  	col_count_ndalloc_ps.type = emitter_type_uint64;
693  	col_count_nrequests_ps.type = emitter_type_uint64;
694  	col_count_nfills_ps.type = emitter_type_uint64;
695  	col_count_nflushes_ps.type = emitter_type_uint64;
696  #define GET_AND_EMIT_ALLOC_STAT(small_or_large, name, valtype)		\
697  	CTL_M2_GET(&quot;stats.arenas.0.&quot; #small_or_large &quot;.&quot; #name, i,	\
698  	    &amp;small_or_large##_##name, valtype##_t);			\
699  	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
700  	    &amp;small_or_large##_##name);					\
701  	col_count_##name.type = emitter_type_##valtype;		\
702  	col_count_##name.valtype##_val = small_or_large##_##name;
703  	emitter_json_object_kv_begin(emitter, &quot;small&quot;);
704  	col_count_title.str_val = &quot;small:&quot;;
705  	GET_AND_EMIT_ALLOC_STAT(small, allocated, size)
706  	GET_AND_EMIT_ALLOC_STAT(small, nmalloc, uint64)
707  	col_count_nmalloc_ps.uint64_val =
708  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
709  	GET_AND_EMIT_ALLOC_STAT(small, ndalloc, uint64)
710  	col_count_ndalloc_ps.uint64_val =
711  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
712  	GET_AND_EMIT_ALLOC_STAT(small, nrequests, uint64)
713  	col_count_nrequests_ps.uint64_val =
714  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
715  	GET_AND_EMIT_ALLOC_STAT(small, nfills, uint64)
716  	col_count_nfills_ps.uint64_val =
717  	    rate_per_second(col_count_nfills.uint64_val, uptime);
718  	GET_AND_EMIT_ALLOC_STAT(small, nflushes, uint64)
719  	col_count_nflushes_ps.uint64_val =
720  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
721  	emitter_table_row(emitter, &amp;alloc_count_row);
722  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;small&quot;. */
723  	emitter_json_object_kv_begin(emitter, &quot;large&quot;);
724  	col_count_title.str_val = &quot;large:&quot;;
725  	GET_AND_EMIT_ALLOC_STAT(large, allocated, size)
726  	GET_AND_EMIT_ALLOC_STAT(large, nmalloc, uint64)
727  	col_count_nmalloc_ps.uint64_val =
728  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
729  	GET_AND_EMIT_ALLOC_STAT(large, ndalloc, uint64)
730  	col_count_ndalloc_ps.uint64_val =
731  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
732  	GET_AND_EMIT_ALLOC_STAT(large, nrequests, uint64)
733  	col_count_nrequests_ps.uint64_val =
734  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
735  	GET_AND_EMIT_ALLOC_STAT(large, nfills, uint64)
736  	col_count_nfills_ps.uint64_val =
737  	    rate_per_second(col_count_nfills.uint64_val, uptime);
738  	GET_AND_EMIT_ALLOC_STAT(large, nflushes, uint64)
739  	col_count_nflushes_ps.uint64_val =
740  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
<span onclick='openModal()' class='match'>741  	emitter_table_row(emitter, &amp;alloc_count_row);
742  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;large&quot;. */
743  #undef GET_AND_EMIT_ALLOC_STAT
</span>744  	col_count_title.str_val = &quot;total:&quot;;
745  	col_count_allocated.size_val = small_allocated + large_allocated;
746  	col_count_nmalloc.uint64_val = small_nmalloc + large_nmalloc;
747  	col_count_ndalloc.uint64_val = small_ndalloc + large_ndalloc;
748  	col_count_nrequests.uint64_val = small_nrequests + large_nrequests;
749  	col_count_nfills.uint64_val = small_nfills + large_nfills;
750  	col_count_nflushes.uint64_val = small_nflushes + large_nflushes;
751  	col_count_nmalloc_ps.uint64_val =
752  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
753  	col_count_ndalloc_ps.uint64_val =
754  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
755  	col_count_nrequests_ps.uint64_val =
756  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
757  	col_count_nfills_ps.uint64_val =
758  	    rate_per_second(col_count_nfills.uint64_val, uptime);
759  	col_count_nflushes_ps.uint64_val =
760  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
761  	emitter_table_row(emitter, &amp;alloc_count_row);
762  	emitter_row_t mem_count_row;
763  	emitter_row_init(&amp;mem_count_row);
764  	emitter_col_t mem_count_title;
765  	emitter_col_init(&amp;mem_count_title, &amp;mem_count_row);
766  	mem_count_title.justify = emitter_justify_left;
767  	mem_count_title.width = 21;
768  	mem_count_title.type = emitter_type_title;
769  	mem_count_title.str_val = &quot;&quot;;
770  	emitter_col_t mem_count_val;
771  	emitter_col_init(&amp;mem_count_val, &amp;mem_count_row);
772  	mem_count_val.justify = emitter_justify_right;
773  	mem_count_val.width = 16;
774  	mem_count_val.type = emitter_type_title;
775  	mem_count_val.str_val = &quot;&quot;;
776  	emitter_table_row(emitter, &amp;mem_count_row);
777  	mem_count_val.type = emitter_type_size;
778  	mem_count_title.str_val = &quot;active:&quot;;
779  	mem_count_val.size_val = pactive * page;
780  	emitter_table_row(emitter, &amp;mem_count_row);
781  #define GET_AND_EMIT_MEM_STAT(stat)					\
782  	CTL_M2_GET(&quot;stats.arenas.0.&quot;#stat, i, &amp;stat, size_t);		\
783  	emitter_json_kv(emitter, #stat, emitter_type_size, &amp;stat);	\
784  	mem_count_title.str_val = #stat&quot;:&quot;;				\
785  	mem_count_val.size_val = stat;					\
786  	emitter_table_row(emitter, &amp;mem_count_row);
787  	GET_AND_EMIT_MEM_STAT(mapped)
788  	GET_AND_EMIT_MEM_STAT(retained)
789  	GET_AND_EMIT_MEM_STAT(base)
790  	GET_AND_EMIT_MEM_STAT(internal)
791  	GET_AND_EMIT_MEM_STAT(metadata_thp)
792  	GET_AND_EMIT_MEM_STAT(tcache_bytes)
793  	GET_AND_EMIT_MEM_STAT(resident)
794  	GET_AND_EMIT_MEM_STAT(abandoned_vm)
795  	GET_AND_EMIT_MEM_STAT(extent_avail)
796  #undef GET_AND_EMIT_MEM_STAT
797  	if (mutex) {
798  		stats_arena_mutexes_print(emitter, i, uptime);
799  	}
800  	if (bins) {
801  		stats_arena_bins_print(emitter, mutex, i, uptime);
802  	}
803  	if (large) {
804  		stats_arena_lextents_print(emitter, i, uptime);
805  	}
806  	if (extents) {
807  		stats_arena_extents_print(emitter, i);
808  	}
809  }
810  static void
811  stats_general_print(emitter_t *emitter) {
812  	const char *cpv;
813  	bool bv, bv2;
814  	unsigned uv;
815  	uint32_t u32v;
816  	uint64_t u64v;
817  	ssize_t ssv, ssv2;
818  	size_t sv, bsz, usz, ssz, sssz, cpsz;
819  	bsz = sizeof(bool);
820  	usz = sizeof(unsigned);
821  	ssz = sizeof(size_t);
822  	sssz = sizeof(ssize_t);
823  	cpsz = sizeof(const char *);
824  	CTL_GET(&quot;version&quot;, &amp;cpv, const char *);
825  	emitter_kv(emitter, &quot;version&quot;, &quot;Version&quot;, emitter_type_string, &amp;cpv);
826  	emitter_dict_begin(emitter, &quot;config&quot;, &quot;Build-time option settings&quot;);
827  #define CONFIG_WRITE_BOOL(name)						\
828  	do {								\
829  		CTL_GET(&quot;config.&quot;#name, &amp;bv, bool);			\
830  		emitter_kv(emitter, #name, &quot;config.&quot;#name,		\
831  		    emitter_type_bool, &amp;bv);				\
832  	} while (0)
833  	CONFIG_WRITE_BOOL(cache_oblivious);
834  	CONFIG_WRITE_BOOL(debug);
835  	CONFIG_WRITE_BOOL(fill);
836  	CONFIG_WRITE_BOOL(lazy_lock);
837  	emitter_kv(emitter, &quot;malloc_conf&quot;, &quot;config.malloc_conf&quot;,
838  	    emitter_type_string, &amp;config_malloc_conf);
839  	CONFIG_WRITE_BOOL(opt_safety_checks);
840  	CONFIG_WRITE_BOOL(prof);
841  	CONFIG_WRITE_BOOL(prof_libgcc);
842  	CONFIG_WRITE_BOOL(prof_libunwind);
843  	CONFIG_WRITE_BOOL(stats);
844  	CONFIG_WRITE_BOOL(utrace);
845  	CONFIG_WRITE_BOOL(xmalloc);
846  #undef CONFIG_WRITE_BOOL
847  	emitter_dict_end(emitter); &amp;bsol;* Close &quot;config&quot; dict. */
848  #define OPT_WRITE(name, var, size, emitter_type)			\
849  	if (je_mallctl(&quot;opt.&quot;name, (void *)&amp;var, &amp;size, NULL, 0) ==	\
850  	    0) {							\
851  		emitter_kv(emitter, name, &quot;opt.&quot;name, emitter_type,	\
852  		    &amp;var);						\
853  	}
854  #define OPT_WRITE_MUTABLE(name, var1, var2, size, emitter_type,		\
855      altname)								\
856  	if (je_mallctl(&quot;opt.&quot;name, (void *)&amp;var1, &amp;size, NULL, 0) ==	\
857  	    0 &amp;&amp; je_mallctl(altname, (void *)&amp;var2, &amp;size, NULL, 0)	\
858  	    == 0) {							\
859  		emitter_kv_note(emitter, name, &quot;opt.&quot;name,		\
860  		    emitter_type, &amp;var1, altname, emitter_type,		\
861  		    &amp;var2);						\
862  	}
863  #define OPT_WRITE_BOOL(name) OPT_WRITE(name, bv, bsz, emitter_type_bool)
864  #define OPT_WRITE_BOOL_MUTABLE(name, altname)				\
865  	OPT_WRITE_MUTABLE(name, bv, bv2, bsz, emitter_type_bool, altname)
866  #define OPT_WRITE_UNSIGNED(name)					\
867  	OPT_WRITE(name, uv, usz, emitter_type_unsigned)
868  #define OPT_WRITE_SIZE_T(name)						\
869  	OPT_WRITE(name, sv, ssz, emitter_type_size)
870  #define OPT_WRITE_SSIZE_T(name)						\
871  	OPT_WRITE(name, ssv, sssz, emitter_type_ssize)
872  #define OPT_WRITE_SSIZE_T_MUTABLE(name, altname)			\
873  	OPT_WRITE_MUTABLE(name, ssv, ssv2, sssz, emitter_type_ssize,	\
874  	    altname)
875  #define OPT_WRITE_CHAR_P(name)						\
876  	OPT_WRITE(name, cpv, cpsz, emitter_type_string)
877  	emitter_dict_begin(emitter, &quot;opt&quot;, &quot;Run-time option settings&quot;);
878  	OPT_WRITE_BOOL(&quot;abort&quot;)
879  	OPT_WRITE_BOOL(&quot;abort_conf&quot;)
880  	OPT_WRITE_BOOL(&quot;confirm_conf&quot;)
881  	OPT_WRITE_BOOL(&quot;retain&quot;)
882  	OPT_WRITE_CHAR_P(&quot;dss&quot;)
883  	OPT_WRITE_UNSIGNED(&quot;narenas&quot;)
884  	OPT_WRITE_CHAR_P(&quot;percpu_arena&quot;)
885  	OPT_WRITE_SIZE_T(&quot;oversize_threshold&quot;)
886  	OPT_WRITE_CHAR_P(&quot;metadata_thp&quot;)
887  	OPT_WRITE_BOOL_MUTABLE(&quot;background_thread&quot;, &quot;background_thread&quot;)
888  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;dirty_decay_ms&quot;, &quot;arenas.dirty_decay_ms&quot;)
889  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;muzzy_decay_ms&quot;, &quot;arenas.muzzy_decay_ms&quot;)
890  	OPT_WRITE_SIZE_T(&quot;lg_extent_max_active_fit&quot;)
891  	OPT_WRITE_CHAR_P(&quot;junk&quot;)
892  	OPT_WRITE_BOOL(&quot;zero&quot;)
893  	OPT_WRITE_BOOL(&quot;utrace&quot;)
894  	OPT_WRITE_BOOL(&quot;xmalloc&quot;)
895  	OPT_WRITE_BOOL(&quot;tcache&quot;)
896  	OPT_WRITE_SSIZE_T(&quot;lg_tcache_max&quot;)
897  	OPT_WRITE_CHAR_P(&quot;thp&quot;)
898  	OPT_WRITE_BOOL(&quot;prof&quot;)
899  	OPT_WRITE_CHAR_P(&quot;prof_prefix&quot;)
900  	OPT_WRITE_BOOL_MUTABLE(&quot;prof_active&quot;, &quot;prof.active&quot;)
901  	OPT_WRITE_BOOL_MUTABLE(&quot;prof_thread_active_init&quot;,
902  	    &quot;prof.thread_active_init&quot;)
903  	OPT_WRITE_SSIZE_T_MUTABLE(&quot;lg_prof_sample&quot;, &quot;prof.lg_sample&quot;)
904  	OPT_WRITE_BOOL(&quot;prof_accum&quot;)
905  	OPT_WRITE_SSIZE_T(&quot;lg_prof_interval&quot;)
906  	OPT_WRITE_BOOL(&quot;prof_gdump&quot;)
907  	OPT_WRITE_BOOL(&quot;prof_final&quot;)
908  	OPT_WRITE_BOOL(&quot;prof_leak&quot;)
909  	OPT_WRITE_BOOL(&quot;stats_print&quot;)
910  	OPT_WRITE_CHAR_P(&quot;stats_print_opts&quot;)
911  	emitter_dict_end(emitter);
912  #undef OPT_WRITE
913  #undef OPT_WRITE_MUTABLE
914  #undef OPT_WRITE_BOOL
915  #undef OPT_WRITE_BOOL_MUTABLE
916  #undef OPT_WRITE_UNSIGNED
917  #undef OPT_WRITE_SSIZE_T
918  #undef OPT_WRITE_SSIZE_T_MUTABLE
919  #undef OPT_WRITE_CHAR_P
920  	if (config_prof) {
921  		emitter_dict_begin(emitter, &quot;prof&quot;, &quot;Profiling settings&quot;);
922  		CTL_GET(&quot;prof.thread_active_init&quot;, &amp;bv, bool);
923  		emitter_kv(emitter, &quot;thread_active_init&quot;,
924  		    &quot;prof.thread_active_init&quot;, emitter_type_bool, &amp;bv);
925  		CTL_GET(&quot;prof.active&quot;, &amp;bv, bool);
926  		emitter_kv(emitter, &quot;active&quot;, &quot;prof.active&quot;, emitter_type_bool,
927  		    &amp;bv);
928  		CTL_GET(&quot;prof.gdump&quot;, &amp;bv, bool);
929  		emitter_kv(emitter, &quot;gdump&quot;, &quot;prof.gdump&quot;, emitter_type_bool,
930  		    &amp;bv);
931  		CTL_GET(&quot;prof.interval&quot;, &amp;u64v, uint64_t);
932  		emitter_kv(emitter, &quot;interval&quot;, &quot;prof.interval&quot;,
933  		    emitter_type_uint64, &amp;u64v);
934  		CTL_GET(&quot;prof.lg_sample&quot;, &amp;ssv, ssize_t);
935  		emitter_kv(emitter, &quot;lg_sample&quot;, &quot;prof.lg_sample&quot;,
936  		    emitter_type_ssize, &amp;ssv);
937  		emitter_dict_end(emitter); &amp;bsol;* Close &quot;prof&quot;. */
938  	}
939  	emitter_json_object_kv_begin(emitter, &quot;arenas&quot;);
940  	CTL_GET(&quot;arenas.narenas&quot;, &amp;uv, unsigned);
941  	emitter_kv(emitter, &quot;narenas&quot;, &quot;Arenas&quot;, emitter_type_unsigned, &amp;uv);
942  	CTL_GET(&quot;arenas.dirty_decay_ms&quot;, &amp;ssv, ssize_t);
943  	emitter_json_kv(emitter, &quot;dirty_decay_ms&quot;, emitter_type_ssize, &amp;ssv);
944  	CTL_GET(&quot;arenas.muzzy_decay_ms&quot;, &amp;ssv, ssize_t);
945  	emitter_json_kv(emitter, &quot;muzzy_decay_ms&quot;, emitter_type_ssize, &amp;ssv);
946  	CTL_GET(&quot;arenas.quantum&quot;, &amp;sv, size_t);
947  	emitter_kv(emitter, &quot;quantum&quot;, &quot;Quantum size&quot;, emitter_type_size, &amp;sv);
948  	CTL_GET(&quot;arenas.page&quot;, &amp;sv, size_t);
949  	emitter_kv(emitter, &quot;page&quot;, &quot;Page size&quot;, emitter_type_size, &amp;sv);
950  	if (je_mallctl(&quot;arenas.tcache_max&quot;, (void *)&amp;sv, &amp;ssz, NULL, 0) == 0) {
951  		emitter_kv(emitter, &quot;tcache_max&quot;,
952  		    &quot;Maximum thread-cached size class&quot;, emitter_type_size, &amp;sv);
953  	}
954  	unsigned nbins;
955  	CTL_GET(&quot;arenas.nbins&quot;, &amp;nbins, unsigned);
956  	emitter_kv(emitter, &quot;nbins&quot;, &quot;Number of bin size classes&quot;,
957  	    emitter_type_unsigned, &amp;nbins);
958  	unsigned nhbins;
959  	CTL_GET(&quot;arenas.nhbins&quot;, &amp;nhbins, unsigned);
960  	emitter_kv(emitter, &quot;nhbins&quot;, &quot;Number of thread-cache bin size classes&quot;,
961  	    emitter_type_unsigned, &amp;nhbins);
962  	if (emitter-&gt;output == emitter_output_json) {
963  		emitter_json_array_kv_begin(emitter, &quot;bin&quot;);
964  		for (unsigned i = 0; i &lt; nbins; i++) {
965  			emitter_json_object_begin(emitter);
966  			CTL_M2_GET(&quot;arenas.bin.0.size&quot;, i, &amp;sv, size_t);
967  			emitter_json_kv(emitter, &quot;size&quot;, emitter_type_size,
968  			    &amp;sv);
969  			CTL_M2_GET(&quot;arenas.bin.0.nregs&quot;, i, &amp;u32v, uint32_t);
970  			emitter_json_kv(emitter, &quot;nregs&quot;, emitter_type_uint32,
971  			    &amp;u32v);
972  			CTL_M2_GET(&quot;arenas.bin.0.slab_size&quot;, i, &amp;sv, size_t);
973  			emitter_json_kv(emitter, &quot;slab_size&quot;, emitter_type_size,
974  			    &amp;sv);
975  			CTL_M2_GET(&quot;arenas.bin.0.nshards&quot;, i, &amp;u32v, uint32_t);
976  			emitter_json_kv(emitter, &quot;nshards&quot;, emitter_type_uint32,
977  			    &amp;u32v);
978  			emitter_json_object_end(emitter);
979  		}
980  		emitter_json_array_end(emitter); &amp;bsol;* Close &quot;bin&quot;. */
981  	}
982  	unsigned nlextents;
983  	CTL_GET(&quot;arenas.nlextents&quot;, &amp;nlextents, unsigned);
984  	emitter_kv(emitter, &quot;nlextents&quot;, &quot;Number of large size classes&quot;,
985  	    emitter_type_unsigned, &amp;nlextents);
986  	if (emitter-&gt;output == emitter_output_json) {
987  		emitter_json_array_kv_begin(emitter, &quot;lextent&quot;);
988  		for (unsigned i = 0; i &lt; nlextents; i++) {
989  			emitter_json_object_begin(emitter);
990  			CTL_M2_GET(&quot;arenas.lextent.0.size&quot;, i, &amp;sv, size_t);
991  			emitter_json_kv(emitter, &quot;size&quot;, emitter_type_size,
992  			    &amp;sv);
993  			emitter_json_object_end(emitter);
994  		}
995  		emitter_json_array_end(emitter); &amp;bsol;* Close &quot;lextent&quot;. */
996  	}
997  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;arenas&quot; */
998  }
999  static void
1000  stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
1001      bool unmerged, bool bins, bool large, bool mutex, bool extents) {
1002  	size_t allocated, active, metadata, metadata_thp, resident, mapped,
1003  	    retained;
1004  	size_t num_background_threads;
1005  	uint64_t background_thread_num_runs, background_thread_run_interval;
1006  	CTL_GET(&quot;stats.allocated&quot;, &amp;allocated, size_t);
1007  	CTL_GET(&quot;stats.active&quot;, &amp;active, size_t);
1008  	CTL_GET(&quot;stats.metadata&quot;, &amp;metadata, size_t);
1009  	CTL_GET(&quot;stats.metadata_thp&quot;, &amp;metadata_thp, size_t);
1010  	CTL_GET(&quot;stats.resident&quot;, &amp;resident, size_t);
1011  	CTL_GET(&quot;stats.mapped&quot;, &amp;mapped, size_t);
1012  	CTL_GET(&quot;stats.retained&quot;, &amp;retained, size_t);
1013  	if (have_background_thread) {
1014  		CTL_GET(&quot;stats.background_thread.num_threads&quot;,
1015  		    &amp;num_background_threads, size_t);
1016  		CTL_GET(&quot;stats.background_thread.num_runs&quot;,
1017  		    &amp;background_thread_num_runs, uint64_t);
1018  		CTL_GET(&quot;stats.background_thread.run_interval&quot;,
1019  		    &amp;background_thread_run_interval, uint64_t);
1020  	} else {
1021  		num_background_threads = 0;
1022  		background_thread_num_runs = 0;
1023  		background_thread_run_interval = 0;
1024  	}
1025  	emitter_json_object_kv_begin(emitter, &quot;stats&quot;);
1026  	emitter_json_kv(emitter, &quot;allocated&quot;, emitter_type_size, &amp;allocated);
1027  	emitter_json_kv(emitter, &quot;active&quot;, emitter_type_size, &amp;active);
1028  	emitter_json_kv(emitter, &quot;metadata&quot;, emitter_type_size, &amp;metadata);
1029  	emitter_json_kv(emitter, &quot;metadata_thp&quot;, emitter_type_size,
1030  	    &amp;metadata_thp);
1031  	emitter_json_kv(emitter, &quot;resident&quot;, emitter_type_size, &amp;resident);
1032  	emitter_json_kv(emitter, &quot;mapped&quot;, emitter_type_size, &amp;mapped);
1033  	emitter_json_kv(emitter, &quot;retained&quot;, emitter_type_size, &amp;retained);
1034  	emitter_table_printf(emitter, &quot;Allocated: %zu, active: %zu, &quot;
1035  	    &quot;metadata: %zu (n_thp %zu), resident: %zu, mapped: %zu, &quot;
1036  	    &quot;retained: %zu\n&quot;, allocated, active, metadata, metadata_thp,
1037  	    resident, mapped, retained);
1038  	emitter_json_object_kv_begin(emitter, &quot;background_thread&quot;);
1039  	emitter_json_kv(emitter, &quot;num_threads&quot;, emitter_type_size,
1040  	    &amp;num_background_threads);
1041  	emitter_json_kv(emitter, &quot;num_runs&quot;, emitter_type_uint64,
1042  	    &amp;background_thread_num_runs);
1043  	emitter_json_kv(emitter, &quot;run_interval&quot;, emitter_type_uint64,
1044  	    &amp;background_thread_run_interval);
1045  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;background_thread&quot;. */
1046  	emitter_table_printf(emitter, &quot;Background threads: %zu, &quot;
1047  	    &quot;num_runs: %&quot;FMTu64&quot;, run_interval: %&quot;FMTu64&quot; ns\n&quot;,
1048  	    num_background_threads, background_thread_num_runs,
1049  	    background_thread_run_interval);
1050  	if (mutex) {
1051  		emitter_row_t row;
1052  		emitter_col_t name;
1053  		emitter_col_t col64[mutex_prof_num_uint64_t_counters];
1054  		emitter_col_t col32[mutex_prof_num_uint32_t_counters];
1055  		uint64_t uptime;
1056  		emitter_row_init(&amp;row);
1057  		mutex_stats_init_cols(&amp;row, &quot;&quot;, &amp;name, col64, col32);
1058  		emitter_table_row(emitter, &amp;row);
1059  		emitter_json_object_kv_begin(emitter, &quot;mutexes&quot;);
1060  		CTL_M2_GET(&quot;stats.arenas.0.uptime&quot;, 0, &amp;uptime, uint64_t);
1061  		for (int i = 0; i &lt; mutex_prof_num_global_mutexes; i++) {
1062  			mutex_stats_read_global(global_mutex_names[i], &amp;name,
1063  			    col64, col32, uptime);
1064  			emitter_json_object_kv_begin(emitter, global_mutex_names[i]);
1065  			mutex_stats_emit(emitter, &amp;row, col64, col32);
1066  			emitter_json_object_end(emitter);
1067  		}
1068  		emitter_json_object_end(emitter); &amp;bsol;* Close &quot;mutexes&quot;. */
1069  	}
1070  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;stats&quot;. */
1071  	if (merged || destroyed || unmerged) {
1072  		unsigned narenas;
1073  		emitter_json_object_kv_begin(emitter, &quot;stats.arenas&quot;);
1074  		CTL_GET(&quot;arenas.narenas&quot;, &amp;narenas, unsigned);
1075  		size_t mib[3];
1076  		size_t miblen = sizeof(mib) / sizeof(size_t);
1077  		size_t sz;
1078  		VARIABLE_ARRAY(bool, initialized, narenas);
1079  		bool destroyed_initialized;
1080  		unsigned i, j, ninitialized;
1081  		xmallctlnametomib(&quot;arena.0.initialized&quot;, mib, &amp;miblen);
1082  		for (i = ninitialized = 0; i &lt; narenas; i++) {
1083  			mib[1] = i;
1084  			sz = sizeof(bool);
1085  			xmallctlbymib(mib, miblen, &amp;initialized[i], &amp;sz,
1086  			    NULL, 0);
1087  			if (initialized[i]) {
1088  				ninitialized++;
1089  			}
1090  		}
1091  		mib[1] = MALLCTL_ARENAS_DESTROYED;
1092  		sz = sizeof(bool);
1093  		xmallctlbymib(mib, miblen, &amp;destroyed_initialized, &amp;sz,
1094  		    NULL, 0);
1095  		if (merged &amp;&amp; (ninitialized &gt; 1 || !unmerged)) {
1096  			emitter_table_printf(emitter, &quot;Merged arenas stats:\n&quot;);
1097  			emitter_json_object_kv_begin(emitter, &quot;merged&quot;);
1098  			stats_arena_print(emitter, MALLCTL_ARENAS_ALL, bins,
1099  			    large, mutex, extents);
1100  			emitter_json_object_end(emitter); &amp;bsol;* Close &quot;merged&quot;. */
1101  		}
1102  		if (destroyed_initialized &amp;&amp; destroyed) {
1103  			emitter_table_printf(emitter,
1104  			    &quot;Destroyed arenas stats:\n&quot;);
1105  			emitter_json_object_kv_begin(emitter, &quot;destroyed&quot;);
1106  			stats_arena_print(emitter, MALLCTL_ARENAS_DESTROYED,
1107  			    bins, large, mutex, extents);
1108  			emitter_json_object_end(emitter); &amp;bsol;* Close &quot;destroyed&quot;. */
1109  		}
1110  		if (unmerged) {
1111  			for (i = j = 0; i &lt; narenas; i++) {
1112  				if (initialized[i]) {
1113  					char arena_ind_str[20];
1114  					malloc_snprintf(arena_ind_str,
1115  					    sizeof(arena_ind_str), &quot;%u&quot;, i);
1116  					emitter_json_object_kv_begin(emitter,
1117  					    arena_ind_str);
1118  					emitter_table_printf(emitter,
1119  					    &quot;arenas[%s]:\n&quot;, arena_ind_str);
1120  					stats_arena_print(emitter, i, bins,
1121  					    large, mutex, extents);
1122  					emitter_json_object_end(emitter);
1123  				}
1124  			}
1125  		}
1126  		emitter_json_object_end(emitter); &amp;bsol;* Close &quot;stats.arenas&quot;. */
1127  	}
1128  }
1129  void
1130  stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
1131      const char *opts) {
1132  	int err;
1133  	uint64_t epoch;
1134  	size_t u64sz;
1135  #define OPTION(o, v, d, s) bool v = d;
1136  	STATS_PRINT_OPTIONS
1137  #undef OPTION
1138  	epoch = 1;
1139  	u64sz = sizeof(uint64_t);
1140  	err = je_mallctl(&quot;epoch&quot;, (void *)&amp;epoch, &amp;u64sz, (void *)&amp;epoch,
1141  	    sizeof(uint64_t));
1142  	if (err != 0) {
1143  		if (err == EAGAIN) {
1144  			malloc_write(&quot;&lt;jemalloc&gt;: Memory allocation failure in &quot;
1145  			    &quot;mallctl(\&quot;epoch\&quot;, ...)\n&quot;);
1146  			return;
1147  		}
1148  		malloc_write(&quot;&lt;jemalloc&gt;: Failure in mallctl(\&quot;epoch\&quot;, &quot;
1149  		    &quot;...)\n&quot;);
1150  		abort();
1151  	}
1152  	if (opts != NULL) {
1153  		for (unsigned i = 0; opts[i] != &#x27;\0&#x27;; i++) {
1154  			switch (opts[i]) {
1155  #define OPTION(o, v, d, s) case o: v = s; break;
1156  				STATS_PRINT_OPTIONS
1157  #undef OPTION
1158  			default:;
1159  			}
1160  		}
1161  	}
1162  	emitter_t emitter;
1163  	emitter_init(&amp;emitter,
1164  	    json ? emitter_output_json : emitter_output_table, write_cb,
1165  	    cbopaque);
1166  	emitter_begin(&amp;emitter);
1167  	emitter_table_printf(&amp;emitter, &quot;___ Begin jemalloc statistics ___\n&quot;);
1168  	emitter_json_object_kv_begin(&amp;emitter, &quot;jemalloc&quot;);
1169  	if (general) {
1170  		stats_general_print(&amp;emitter);
1171  	}
1172  	if (config_stats) {
1173  		stats_print_helper(&amp;emitter, merged, destroyed, unmerged,
1174  		    bins, large, mutex, extents);
1175  	}
1176  	emitter_json_object_end(&amp;emitter); &amp;bsol;* Closes the &quot;jemalloc&quot; dict. */
1177  	emitter_table_printf(&amp;emitter, &quot;--- End jemalloc statistics ---\n&quot;);
1178  	emitter_end(&amp;emitter);
1179  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_7.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_7.c</div>
                </div>
                <div class="column column_space"><pre><code>721  	emitter_table_row(emitter, &amp;alloc_count_row);
722  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;small&quot;. */
723  	emitter_json_object_kv_begin(emitter, &quot;large&quot;);
</pre></code></div>
                <div class="column column_space"><pre><code>741  	emitter_table_row(emitter, &amp;alloc_count_row);
742  	emitter_json_object_end(emitter); &amp;bsol;* Close &quot;large&quot;. */
743  #undef GET_AND_EMIT_ALLOC_STAT
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    