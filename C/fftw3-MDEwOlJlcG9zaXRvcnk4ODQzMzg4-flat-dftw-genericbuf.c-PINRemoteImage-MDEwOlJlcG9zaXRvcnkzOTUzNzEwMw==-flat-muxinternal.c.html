
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.099737532808399%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-genericbuf.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       INT batchsz;
5  } S;
6  typedef struct {
7       plan_dftw super;
8       INT r, rs, m, ms, v, vs, mb, me;
9       INT batchsz;
10       plan *cld;
11       triggen *t;
12       const S *slv;
13  } P;
14  #define BATCHDIST(r) ((r) + 16)
15  static void bytwiddle(const P *ego, INT mb, INT me, R *buf, R *rio, R *iio)
16  {
17       INT j, k;
18       INT r = ego->r, rs = ego->rs, ms = ego->ms;
19       triggen *t = ego->t;
20       for (j = 0; j < r; ++j) {
21  	  for (k = mb; k < me; ++k)
22  	       t->rotate(t, j * k,
23  			 rio[j * rs + k * ms],
24  			 iio[j * rs + k * ms],
25  			 &buf[j * 2 + 2 * BATCHDIST(r) * (k - mb) + 0]);
26       }
27  }
28  static int applicable0(const S *ego,
29  		       INT r, INT irs, INT ors,
30  		       INT m, INT v,
31  		       INT mcount)
32  {
33       return (1
34  	     && v == 1
35  	     && irs == ors
36  	     && mcount >= ego->batchsz
37  	     && mcount % ego->batchsz == 0
38  	     && r >= 64 
39  	     && m >= r
40  	  );
41  }
42  static int applicable(const S *ego,
43  		      INT r, INT irs, INT ors,
44  		      INT m, INT v,
45  		      INT mcount,
46  		      const planner *plnr)
47  {
48       if (!applicable0(ego, r, irs, ors, m, v, mcount))
49  	  return 0;
50       if (NO_UGLYP(plnr) && m * r < 65536)
51  	  return 0;
52       return 1;
53  }
54  static void dobatch(const P *ego, INT mb, INT me, R *buf, R *rio, R *iio)
55  {
56       plan_dft *cld;
57       INT ms = ego->ms;
58       bytwiddle(ego, mb, me, buf, rio, iio);
59       cld = (plan_dft *) ego->cld;
60       cld->apply(ego->cld, buf, buf + 1, buf, buf + 1);
61       X(cpy2d_pair_co)(buf, buf + 1,
62  		      rio + ms * mb, iio + ms * mb,
63  		      me-mb, 2 * BATCHDIST(ego->r), ms,
64  		      ego->r, 2, ego->rs);
65  }
66  static void apply(const plan *ego_, R *rio, R *iio)
67  {
68       const P *ego = (const P *) ego_;
69       R *buf = (R *) MALLOC(sizeof(R) * 2 * BATCHDIST(ego->r) * ego->batchsz,
70  			   BUFFERS);
71       INT m;
72       for (m = ego->mb; m < ego->me; m += ego->batchsz)
73  	  dobatch(ego, m, m + ego->batchsz, buf, rio, iio);
74       A(m == ego->me);
75       X(ifree)(buf);
76  }
77  static void awake(plan *ego_, enum wakefulness wakefulness)
78  {
79       P *ego = (P *) ego_;
80       X(plan_awake)(ego->cld, wakefulness);
81       switch (wakefulness) {
82  	 case SLEEPY:
83  	      X(triggen_destroy)(ego->t); ego->t = 0;
84  	      break;
85  	 default:
86  	      ego->t = X(mktriggen)(AWAKE_SQRTN_TABLE, ego->r * ego->m);
87  	      break;
88       }
89  }
90  static void destroy(plan *ego_)
91  {
92       P *ego = (P *) ego_;
93       X(plan_destroy_internal)(ego->cld);
94  }
95  static void print(const plan *ego_, printer *p)
96  {
97       const P *ego = (const P *) ego_;
98       p->print(p, "(dftw-genericbuf/%D-%D-%D%(%p%))",
99  	      ego->batchsz, ego->r, ego->m, ego->cld);
100  }
101  static plan *mkcldw(const ct_solver *ego_,
<span onclick='openModal()' class='match'>102  		    INT r, INT irs, INT ors,
103  		    INT m, INT ms,
104  		    INT v, INT ivs, INT ovs,
</span>105  		    INT mstart, INT mcount,
106  		    R *rio, R *iio,
107  		    planner *plnr)
108  {
109       const S *ego = (const S *)ego_;
110       P *pln;
111       plan *cld = 0;
112       R *buf;
113       static const plan_adt padt = {
114  	  0, awake, print, destroy
115       };
116       UNUSED(ivs); UNUSED(ovs); UNUSED(rio); UNUSED(iio);
117       A(mstart >= 0 && mstart + mcount <= m);
118       if (!applicable(ego, r, irs, ors, m, v, mcount, plnr))
119            return (plan *)0;
120       buf = (R *) MALLOC(sizeof(R) * 2 * BATCHDIST(r) * ego->batchsz, BUFFERS);
121       cld = X(mkplan_d)(plnr,
122  			X(mkproblem_dft_d)(
123  			     X(mktensor_1d)(r, 2, 2),
124  			     X(mktensor_1d)(ego->batchsz,
125  					    2 * BATCHDIST(r),
126  					    2 * BATCHDIST(r)),
127  			     buf, buf + 1, buf, buf + 1
128  			     )
129  			);
130       X(ifree)(buf);
131       if (!cld) goto nada;
132       pln = MKPLAN_DFTW(P, &padt, apply);
133       pln->slv = ego;
134       pln->cld = cld;
135       pln->r = r;
136       pln->m = m;
137       pln->ms = ms;
138       pln->rs = irs;
139       pln->batchsz = ego->batchsz;
140       pln->mb = mstart;
141       pln->me = mstart + mcount;
142       {
143  	  double n0 = (r - 1) * (mcount - 1);
144  	  pln->super.super.ops = cld->ops;
145  	  pln->super.super.ops.mul += 8 * n0;
146  	  pln->super.super.ops.add += 4 * n0;
147  	  pln->super.super.ops.other += 8 * n0;
148       }
149       return &(pln->super.super);
150   nada:
151       X(plan_destroy_internal)(cld);
152       return (plan *) 0;
153  }
154  static void regsolver(planner *plnr, INT r, INT batchsz)
155  {
156       S *slv = (S *)X(mksolver_ct)(sizeof(S), r, DECDIT, mkcldw, 0);
157       slv->batchsz = batchsz;
158       REGISTER_SOLVER(plnr, &(slv->super.super));
159       if (X(mksolver_ct_hook)) {
160  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), r, DECDIT, mkcldw, 0);
161  	  slv->batchsz = batchsz;
162  	  REGISTER_SOLVER(plnr, &(slv->super.super));
163       }
164  }
165  void X(ct_genericbuf_register)(planner *p)
166  {
167       static const INT radices[] = { -1, -2, -4, -8, -16, -32, -64 };
168       static const INT batchsizes[] = { 4, 8, 16, 32, 64 };
169       unsigned i, j;
170       for (i = 0; i < sizeof(radices) / sizeof(radices[0]); ++i)
171  	  for (j = 0; j < sizeof(batchsizes) / sizeof(batchsizes[0]); ++j)
172  	       regsolver(p, radices[i], batchsizes[j]);
173  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxinternal.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/mux/muxi.h"
3  #include "src/utils/utils.h"
4  #define UNDEFINED_CHUNK_SIZE ((uint32_t)(-1))
5  const ChunkInfo kChunks[] = {
6    { MKFOURCC('V', 'P', '8', 'X'),  WEBP_CHUNK_VP8X,    VP8X_CHUNK_SIZE },
7    { MKFOURCC('I', 'C', 'C', 'P'),  WEBP_CHUNK_ICCP,    UNDEFINED_CHUNK_SIZE },
8    { MKFOURCC('A', 'N', 'I', 'M'),  WEBP_CHUNK_ANIM,    ANIM_CHUNK_SIZE },
9    { MKFOURCC('A', 'N', 'M', 'F'),  WEBP_CHUNK_ANMF,    ANMF_CHUNK_SIZE },
10    { MKFOURCC('A', 'L', 'P', 'H'),  WEBP_CHUNK_ALPHA,   UNDEFINED_CHUNK_SIZE },
11    { MKFOURCC('V', 'P', '8', ' '),  WEBP_CHUNK_IMAGE,   UNDEFINED_CHUNK_SIZE },
12    { MKFOURCC('V', 'P', '8', 'L'),  WEBP_CHUNK_IMAGE,   UNDEFINED_CHUNK_SIZE },
13    { MKFOURCC('E', 'X', 'I', 'F'),  WEBP_CHUNK_EXIF,    UNDEFINED_CHUNK_SIZE },
14    { MKFOURCC('X', 'M', 'P', ' '),  WEBP_CHUNK_XMP,     UNDEFINED_CHUNK_SIZE },
15    { NIL_TAG,                       WEBP_CHUNK_UNKNOWN, UNDEFINED_CHUNK_SIZE },
16    { NIL_TAG,                       WEBP_CHUNK_NIL,     UNDEFINED_CHUNK_SIZE }
17  };
18  int WebPGetMuxVersion(void) {
19    return (MUX_MAJ_VERSION << 16) | (MUX_MIN_VERSION << 8) | MUX_REV_VERSION;
20  }
21  void ChunkInit(WebPChunk* const chunk) {
22    assert(chunk);
23    memset(chunk, 0, sizeof(*chunk));
24    chunk->tag_ = NIL_TAG;
25  }
26  WebPChunk* ChunkRelease(WebPChunk* const chunk) {
27    WebPChunk* next;
28    if (chunk == NULL) return NULL;
29    if (chunk->owner_) {
30      WebPDataClear(&chunk->data_);
31    }
32    next = chunk->next_;
33    ChunkInit(chunk);
34    return next;
35  }
36  CHUNK_INDEX ChunkGetIndexFromTag(uint32_t tag) {
37    int i;
38    for (i = 0; kChunks[i].tag != NIL_TAG; ++i) {
39      if (tag == kChunks[i].tag) return (CHUNK_INDEX)i;
40    }
41    return IDX_UNKNOWN;
42  }
43  WebPChunkId ChunkGetIdFromTag(uint32_t tag) {
44    int i;
45    for (i = 0; kChunks[i].tag != NIL_TAG; ++i) {
46      if (tag == kChunks[i].tag) return kChunks[i].id;
47    }
48    return WEBP_CHUNK_UNKNOWN;
49  }
50  uint32_t ChunkGetTagFromFourCC(const char fourcc[4]) {
51    return MKFOURCC(fourcc[0], fourcc[1], fourcc[2], fourcc[3]);
52  }
53  CHUNK_INDEX ChunkGetIndexFromFourCC(const char fourcc[4]) {
54    const uint32_t tag = ChunkGetTagFromFourCC(fourcc);
55    return ChunkGetIndexFromTag(tag);
56  }
57  static WebPChunk* ChunkSearchNextInList(WebPChunk* chunk, uint32_t tag) {
58    while (chunk != NULL && chunk->tag_ != tag) {
59      chunk = chunk->next_;
60    }
61    return chunk;
62  }
63  WebPChunk* ChunkSearchList(WebPChunk* first, uint32_t nth, uint32_t tag) {
64    uint32_t iter = nth;
65    first = ChunkSearchNextInList(first, tag);
66    if (first == NULL) return NULL;
67    while (--iter != 0) {
68      WebPChunk* next_chunk = ChunkSearchNextInList(first->next_, tag);
69      if (next_chunk == NULL) break;
70      first = next_chunk;
71    }
72    return ((nth > 0) && (iter > 0)) ? NULL : first;
73  }
74  WebPMuxError ChunkAssignData(WebPChunk* chunk, const WebPData* const data,
75                               int copy_data, uint32_t tag) {
76    if (tag == kChunks[IDX_VP8X].tag || tag == kChunks[IDX_ANIM].tag) {
77      copy_data = 1;
78    }
79    ChunkRelease(chunk);
80    if (data != NULL) {
81      if (copy_data) {        
82        if (!WebPDataCopy(data, &chunk->data_)) return WEBP_MUX_MEMORY_ERROR;
83        chunk->owner_ = 1;    
84      } else {                
85        chunk->data_ = *data;
86      }
87    }
88    chunk->tag_ = tag;
89    return WEBP_MUX_OK;
90  }
91  WebPMuxError ChunkSetHead(WebPChunk* const chunk,
92                            WebPChunk** const chunk_list) {
93    WebPChunk* new_chunk;
94    assert(chunk_list != NULL);
95    if (*chunk_list != NULL) {
96      return WEBP_MUX_NOT_FOUND;
97    }
98    new_chunk = (WebPChunk*)WebPSafeMalloc(1ULL, sizeof(*new_chunk));
99    if (new_chunk == NULL) return WEBP_MUX_MEMORY_ERROR;
100    *new_chunk = *chunk;
101    chunk->owner_ = 0;
102    new_chunk->next_ = NULL;
103    *chunk_list = new_chunk;
104    return WEBP_MUX_OK;
105  }
106  WebPMuxError ChunkAppend(WebPChunk* const chunk,
107                           WebPChunk*** const chunk_list) {
108    assert(chunk_list != NULL && *chunk_list != NULL);
109    if (**chunk_list == NULL) {
110      ChunkSetHead(chunk, *chunk_list);
111    } else {
112      WebPChunk* last_chunk = **chunk_list;
113      while (last_chunk->next_ != NULL) last_chunk = last_chunk->next_;
114      ChunkSetHead(chunk, &last_chunk->next_);
115      *chunk_list = &last_chunk->next_;
116    }
117    return WEBP_MUX_OK;
118  }
119  WebPChunk* ChunkDelete(WebPChunk* const chunk) {
120    WebPChunk* const next = ChunkRelease(chunk);
121    WebPSafeFree(chunk);
122    return next;
123  }
124  void ChunkListDelete(WebPChunk** const chunk_list) {
125    while (*chunk_list != NULL) {
126      *chunk_list = ChunkDelete(*chunk_list);
127    }
128  }
129  static uint8_t* ChunkEmit(const WebPChunk* const chunk, uint8_t* dst) {
130    const size_t chunk_size = chunk->data_.size;
131    assert(chunk);
132    assert(chunk->tag_ != NIL_TAG);
133    PutLE32(dst + 0, chunk->tag_);
134    PutLE32(dst + TAG_SIZE, (uint32_t)chunk_size);
135    assert(chunk_size == (uint32_t)chunk_size);
136    memcpy(dst + CHUNK_HEADER_SIZE, chunk->data_.bytes, chunk_size);
137    if (chunk_size & 1)
138      dst[CHUNK_HEADER_SIZE + chunk_size] = 0;  
139    return dst + ChunkDiskSize(chunk);
140  }
141  uint8_t* ChunkListEmit(const WebPChunk* chunk_list, uint8_t* dst) {
142    while (chunk_list != NULL) {
143      dst = ChunkEmit(chunk_list, dst);
144      chunk_list = chunk_list->next_;
145    }
146    return dst;
147  }
148  size_t ChunkListDiskSize(const WebPChunk* chunk_list) {
149    size_t size = 0;
150    while (chunk_list != NULL) {
151      size += ChunkDiskSize(chunk_list);
152      chunk_list = chunk_list->next_;
153    }
154    return size;
155  }
156  void MuxImageInit(WebPMuxImage* const wpi) {
157    assert(wpi);
158    memset(wpi, 0, sizeof(*wpi));
159  }
160  WebPMuxImage* MuxImageRelease(WebPMuxImage* const wpi) {
161    WebPMuxImage* next;
162    if (wpi == NULL) return NULL;
163    ChunkListDelete(&wpi->header_);
164    ChunkListDelete(&wpi->alpha_);
165    ChunkListDelete(&wpi->img_);
166    ChunkListDelete(&wpi->unknown_);
167    next = wpi->next_;
168    MuxImageInit(wpi);
169    return next;
170  }
171  static WebPChunk** GetChunkListFromId(const WebPMuxImage* const wpi,
172                                        WebPChunkId id) {
173    assert(wpi != NULL);
174    switch (id) {
175      case WEBP_CHUNK_ANMF:  return (WebPChunk**)&wpi->header_;
176      case WEBP_CHUNK_ALPHA: return (WebPChunk**)&wpi->alpha_;
177      case WEBP_CHUNK_IMAGE: return (WebPChunk**)&wpi->img_;
178      default: return NULL;
179    }
180  }
181  int MuxImageCount(const WebPMuxImage* wpi_list, WebPChunkId id) {
182    int count = 0;
183    const WebPMuxImage* current;
184    for (current = wpi_list; current != NULL; current = current->next_) {
185      if (id == WEBP_CHUNK_NIL) {
186        ++count;  
187      } else {
188        const WebPChunk* const wpi_chunk = *GetChunkListFromId(current, id);
189        if (wpi_chunk != NULL) {
190          const WebPChunkId wpi_chunk_id = ChunkGetIdFromTag(wpi_chunk->tag_);
191          if (wpi_chunk_id == id) ++count;  
192        }
193      }
194    }
195    return count;
196  }
197  static int SearchImageToGetOrDelete(WebPMuxImage** wpi_list, uint32_t nth,
198                                      WebPMuxImage*** const location) {
199    uint32_t count = 0;
200    assert(wpi_list);
201    *location = wpi_list;
202    if (nth == 0) {
203      nth = MuxImageCount(*wpi_list, WEBP_CHUNK_NIL);
204      if (nth == 0) return 0;  
205    }
206    while (*wpi_list != NULL) {
207      WebPMuxImage* const cur_wpi = *wpi_list;
208      ++count;
209      if (count == nth) return 1;  
210      wpi_list = &cur_wpi->next_;
211      *location = wpi_list;
212    }
213    return 0;  
214  }
215  WebPMuxError MuxImagePush(const WebPMuxImage* wpi, WebPMuxImage** wpi_list) {
216    WebPMuxImage* new_wpi;
217    while (*wpi_list != NULL) {
218      WebPMuxImage* const cur_wpi = *wpi_list;
219      if (cur_wpi->next_ == NULL) break;
220      wpi_list = &cur_wpi->next_;
221    }
222    new_wpi = (WebPMuxImage*)WebPSafeMalloc(1ULL, sizeof(*new_wpi));
223    if (new_wpi == NULL) return WEBP_MUX_MEMORY_ERROR;
224    *new_wpi = *wpi;
225    new_wpi->next_ = NULL;
226    if (*wpi_list != NULL) {
227      (*wpi_list)->next_ = new_wpi;
228    } else {
229      *wpi_list = new_wpi;
230    }
231    return WEBP_MUX_OK;
232  }
233  WebPMuxImage* MuxImageDelete(WebPMuxImage* const wpi) {
234    WebPMuxImage* const next = MuxImageRelease(wpi);
235    WebPSafeFree(wpi);
236    return next;
237  }
238  WebPMuxError MuxImageDeleteNth(WebPMuxImage** wpi_list, uint32_t nth) {
239    assert(wpi_list);
240    if (!SearchImageToGetOrDelete(wpi_list, nth, &wpi_list)) {
241      return WEBP_MUX_NOT_FOUND;
242    }
243    *wpi_list = MuxImageDelete(*wpi_list);
244    return WEBP_MUX_OK;
245  }
246  WebPMuxError MuxImageGetNth(const WebPMuxImage** wpi_list, uint32_t nth,
247                              WebPMuxImage** wpi) {
248    assert(wpi_list);
249    assert(wpi);
250    if (!SearchImageToGetOrDelete((WebPMuxImage**)wpi_list, nth,
251                                  (WebPMuxImage***)&wpi_list)) {
252      return WEBP_MUX_NOT_FOUND;
253    }
254    *wpi = (WebPMuxImage*)*wpi_list;
255    return WEBP_MUX_OK;
256  }
257  size_t MuxImageDiskSize(const WebPMuxImage* const wpi) {
258    size_t size = 0;
259    if (wpi->header_ != NULL) size += ChunkDiskSize(wpi->header_);
260    if (wpi->alpha_ != NULL) size += ChunkDiskSize(wpi->alpha_);
261    if (wpi->img_ != NULL) size += ChunkDiskSize(wpi->img_);
262    if (wpi->unknown_ != NULL) size += ChunkListDiskSize(wpi->unknown_);
263    return size;
264  }
265  static uint8_t* ChunkEmitSpecial(const WebPChunk* const header,
266                                   size_t total_size, uint8_t* dst) {
267    const size_t header_size = header->data_.size;
268    const size_t offset_to_next = total_size - CHUNK_HEADER_SIZE;
269    assert(header->tag_ == kChunks[IDX_ANMF].tag);
270    PutLE32(dst + 0, header->tag_);
271    PutLE32(dst + TAG_SIZE, (uint32_t)offset_to_next);
272    assert(header_size == (uint32_t)header_size);
273    memcpy(dst + CHUNK_HEADER_SIZE, header->data_.bytes, header_size);
274    if (header_size & 1) {
275      dst[CHUNK_HEADER_SIZE + header_size] = 0;  
276    }
277    return dst + ChunkDiskSize(header);
278  }
279  uint8_t* MuxImageEmit(const WebPMuxImage* const wpi, uint8_t* dst) {
280    assert(wpi);
281    if (wpi->header_ != NULL) {
282      dst = ChunkEmitSpecial(wpi->header_, MuxImageDiskSize(wpi), dst);
283    }
284    if (wpi->alpha_ != NULL) dst = ChunkEmit(wpi->alpha_, dst);
285    if (wpi->img_ != NULL) dst = ChunkEmit(wpi->img_, dst);
286    if (wpi->unknown_ != NULL) dst = ChunkListEmit(wpi->unknown_, dst);
287    return dst;
288  }
289  int MuxHasAlpha(const WebPMuxImage* images) {
290    while (images != NULL) {
291      if (images->has_alpha_) return 1;
292      images = images->next_;
293    }
294    return 0;
295  }
296  uint8_t* MuxEmitRiffHeader(uint8_t* const data, size_t size) {
297    PutLE32(data + 0, MKFOURCC('R', 'I', 'F', 'F'));
298    PutLE32(data + TAG_SIZE, (uint32_t)size - CHUNK_HEADER_SIZE);
299    assert(size == (uint32_t)size);
300    PutLE32(data + TAG_SIZE + CHUNK_SIZE_BYTES, MKFOURCC('W', 'E', 'B', 'P'));
301    return data + RIFF_HEADER_SIZE;
302  }
303  WebPChunk** MuxGetChunkListFromId(const WebPMux* mux, WebPChunkId id) {
304    assert(mux != NULL);
305    switch (id) {
306      case WEBP_CHUNK_VP8X:    return (WebPChunk**)&mux->vp8x_;
307      case WEBP_CHUNK_ICCP:    return (WebPChunk**)&mux->iccp_;
308      case WEBP_CHUNK_ANIM:    return (WebPChunk**)&mux->anim_;
309      case WEBP_CHUNK_EXIF:    return (WebPChunk**)&mux->exif_;
310      case WEBP_CHUNK_XMP:     return (WebPChunk**)&mux->xmp_;
311      default:                 return (WebPChunk**)&mux->unknown_;
312    }
313  }
314  static int IsNotCompatible(int feature, int num_items) {
315    return (feature != 0) != (num_items > 0);
316  }
317  #define NO_FLAG ((WebPFeatureFlags)0)
318  static WebPMuxError ValidateChunk(const WebPMux* const mux, CHUNK_INDEX idx,
319                                    WebPFeatureFlags feature,
320                                    uint32_t vp8x_flags,
321                                    int max, int* num) {
322    const WebPMuxError err =
323        WebPMuxNumChunks(mux, kChunks[idx].id, num);
324    if (err != WEBP_MUX_OK) return err;
325    if (max > -1 && *num > max) return WEBP_MUX_INVALID_ARGUMENT;
326    if (feature != NO_FLAG && IsNotCompatible(vp8x_flags & feature, *num)) {
327      return WEBP_MUX_INVALID_ARGUMENT;
328    }
329    return WEBP_MUX_OK;
330  }
331  WebPMuxError MuxValidate(const WebPMux* const mux) {
<span onclick='openModal()' class='match'>332    int num_iccp;
333    int num_exif;
334    int num_xmp;
335    int num_anim;
336    int num_frames;
337    int num_vp8x;
338    int num_images;
339    int num_alpha;
</span>340    uint32_t flags;
341    WebPMuxError err;
342    if (mux == NULL) return WEBP_MUX_INVALID_ARGUMENT;
343    if (mux->images_ == NULL) return WEBP_MUX_INVALID_ARGUMENT;
344    err = WebPMuxGetFeatures(mux, &flags);
345    if (err != WEBP_MUX_OK) return err;
346    err = ValidateChunk(mux, IDX_ICCP, ICCP_FLAG, flags, 1, &num_iccp);
347    if (err != WEBP_MUX_OK) return err;
348    err = ValidateChunk(mux, IDX_EXIF, EXIF_FLAG, flags, 1, &num_exif);
349    if (err != WEBP_MUX_OK) return err;
350    err = ValidateChunk(mux, IDX_XMP, XMP_FLAG, flags, 1, &num_xmp);
351    if (err != WEBP_MUX_OK) return err;
352    err = ValidateChunk(mux, IDX_ANIM, NO_FLAG, flags, 1, &num_anim);
353    if (err != WEBP_MUX_OK) return err;
354    err = ValidateChunk(mux, IDX_ANMF, NO_FLAG, flags, -1, &num_frames);
355    if (err != WEBP_MUX_OK) return err;
356    {
357      const int has_animation = !!(flags & ANIMATION_FLAG);
358      if (has_animation && (num_anim == 0 || num_frames == 0)) {
359        return WEBP_MUX_INVALID_ARGUMENT;
360      }
361      if (!has_animation && (num_anim == 1 || num_frames > 0)) {
362        return WEBP_MUX_INVALID_ARGUMENT;
363      }
364      if (!has_animation) {
365        const WebPMuxImage* images = mux->images_;
366        if (images == NULL || images->next_ != NULL) {
367          return WEBP_MUX_INVALID_ARGUMENT;
368        }
369        if (mux->canvas_width_ > 0) {
370          if (images->width_ != mux->canvas_width_ ||
371              images->height_ != mux->canvas_height_) {
372            return WEBP_MUX_INVALID_ARGUMENT;
373          }
374        }
375      }
376    }
377    err = ValidateChunk(mux, IDX_VP8X, NO_FLAG, flags, 1, &num_vp8x);
378    if (err != WEBP_MUX_OK) return err;
379    err = ValidateChunk(mux, IDX_VP8, NO_FLAG, flags, -1, &num_images);
380    if (err != WEBP_MUX_OK) return err;
381    if (num_vp8x == 0 && num_images != 1) return WEBP_MUX_INVALID_ARGUMENT;
382    if (MuxHasAlpha(mux->images_)) {
383      if (num_vp8x > 0) {
384        if (!(flags & ALPHA_FLAG)) return WEBP_MUX_INVALID_ARGUMENT;
385      } else {
386        err = WebPMuxNumChunks(mux, WEBP_CHUNK_ALPHA, &num_alpha);
387        if (err != WEBP_MUX_OK) return err;
388        if (num_alpha > 0) return WEBP_MUX_INVALID_ARGUMENT;
389      }
390    }
391    return WEBP_MUX_OK;
392  }
393  #undef NO_FLAG
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-genericbuf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-muxinternal.c</div>
                </div>
                <div class="column column_space"><pre><code>102  		    INT r, INT irs, INT ors,
103  		    INT m, INT ms,
104  		    INT v, INT ivs, INT ovs,
</pre></code></div>
                <div class="column column_space"><pre><code>332    int num_iccp;
333    int num_exif;
334    int num_xmp;
335    int num_anim;
336    int num_frames;
337    int num_vp8x;
338    int num_images;
339    int num_alpha;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    