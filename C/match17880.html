<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for draw_smudge.c &amp; sink.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for draw_smudge.c &amp; sink.c
      </h3>
<h1 align="center">
        7.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>draw_smudge.c (11.570248%)<th>sink.c (5.9322033%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(180-193)<td><a href="#" name="0">(338-352)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>draw_smudge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include "pdraw.h"
9 typedef struct _VipsDrawSmudge {
10 	VipsDraw parent_object;
11 	int left;
12 	int top;
13 	int width;
14 	int height;
15 } VipsDrawSmudge;
16 typedef struct _VipsDrawSmudgeClass {
17 	VipsDrawClass parent_class;
18 } VipsDrawSmudgeClass; 
19 G_DEFINE_TYPE( VipsDrawSmudge, vips_draw_smudge, VIPS_TYPE_DRAW );
20 static int
21 vips_draw_smudge_build( VipsObject *object )
22 {
23 	VipsDraw *draw = VIPS_DRAW( object );
24 	VipsImage *im = draw-&gt;image; 
25 	VipsDrawSmudge *smudge = (VipsDrawSmudge *) object;
26 	int left = smudge-&gt;left;
27 	int top = smudge-&gt;top;
28 	int width = smudge-&gt;width;
29 	int height = smudge-&gt;height;
30 	int bands = vips_image_get_bands( draw-&gt;image ) * 
31 		(vips_band_format_iscomplex( vips_image_get_format( im ) ) ? 
32 		 	2 : 1);
33 	int elements = bands * vips_image_get_width( im );
34 	VipsRect area, image, clipped;
35 	double *total;
36 	int x, y, i, j, b;
37 	if( VIPS_OBJECT_CLASS( vips_draw_smudge_parent_class )-&gt;
38 		build( object ) )
39 		return( -1 );
40 	area.left = left;
41 	area.top = top;
42 	area.width = width;
43 	area.height = height;
44 	image.left = 0;
45 	image.top = 0;
46 	image.width = im-&gt;Xsize;
47 	image.height = im-&gt;Ysize;
48 	vips_rect_marginadjust( &amp;image, -1 );
49 	vips_rect_intersectrect( &amp;area, &amp;image, &amp;clipped );
50 	if( vips_rect_isempty( &amp;clipped ) )
51 		return( 0 );
52 	if( !(total = VIPS_ARRAY( im, bands, double )) )
53 		return( -1 );
54 #define SMUDGE( TYPE ) \
55 	for( y = 0; y &lt; clipped.height; y++ ) { \
56 		TYPE *q; \
57 		TYPE *p; \
58 		\
59 		q = (TYPE *) VIPS_IMAGE_ADDR( im, \
60 			clipped.left, clipped.top + y ); \
61 		p = q - elements - bands; \
62 		for( x = 0; x &lt; clipped.width; x++ ) { \
63 			TYPE *p1, *p2; \
64  			\
65 			for( b = 0; b &lt; bands; b++ ) \
66 				total[b] = 0.0; \
67 			\
68 			p1 = p; \
69 			for( i = 0; i &lt; 3; i++ ) { \
70 				p2 = p1; \
71 				for( j = 0; j &lt; 3; j++ ) \
72 					for( b = 0; b &lt; bands; b++ ) \
73 						total[b] += *p2++; \
74 				\
75 				p1 += elements; \
76 			} \
77  			\
78 			for( b = 0; b &lt; bands; b++ ) \
79 				q[b] = (16 * (double) q[b] + total[b]) / 25.0; \
80 			\
81 			p += bands; \
82 			q += bands; \
83 		} \
84 	}
85 	switch( vips_image_get_format( im ) ) { 
86 	case VIPS_FORMAT_UCHAR: 	SMUDGE( unsigned char ); break; 
87 	case VIPS_FORMAT_CHAR: 		SMUDGE( char ); break; 
88 	case VIPS_FORMAT_USHORT: 	SMUDGE( unsigned short ); break; 
89 	case VIPS_FORMAT_SHORT: 	SMUDGE( short ); break; 
90 	case VIPS_FORMAT_UINT: 		SMUDGE( unsigned int ); break; 
91 	case VIPS_FORMAT_INT: 		SMUDGE( int ); break; 
92 	case VIPS_FORMAT_FLOAT: 	SMUDGE( float ); break; 
93 	case VIPS_FORMAT_DOUBLE: 	SMUDGE( double ); break; 
94 	case VIPS_FORMAT_COMPLEX: 	SMUDGE( float ); break;
95 	case VIPS_FORMAT_DPCOMPLEX: 	SMUDGE( double ); break;
96 	default:
97 <a name="0"></a>		g_assert_not_reached();
98 	}
99 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
100 }
101 static void
102 vips_draw_smudge_class_init( VipsDrawSmudgeClass *class )
103 {
104 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
105 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
106 	gobject_class-&gt;set_property = vips_object_set_property;
107 	gobject_class-&gt;get_property = vips_object_get_property;
108 	vobject_class-&gt;nickname = "draw_smudge";
109 	vobject_class-&gt;description = _( "blur a rectangle on an image" );</b></font>
110 	vobject_class-&gt;build = vips_draw_smudge_build;
111 	VIPS_ARG_INT( class, "left", 6, 
112 		_( "Left" ), 
113 		_( "Rect to fill" ),
114 		VIPS_ARGUMENT_REQUIRED_INPUT,
115 		G_STRUCT_OFFSET( VipsDrawSmudge, left ),
116 		-1000000000, 1000000000, 0 );
117 	VIPS_ARG_INT( class, "top", 7, 
118 		_( "top" ), 
119 		_( "Rect to fill" ),
120 		VIPS_ARGUMENT_REQUIRED_INPUT,
121 		G_STRUCT_OFFSET( VipsDrawSmudge, top ),
122 		-1000000000, 1000000000, 0 );
123 	VIPS_ARG_INT( class, "width", 8, 
124 		_( "width" ), 
125 		_( "Rect to fill" ),
126 		VIPS_ARGUMENT_REQUIRED_INPUT,
127 		G_STRUCT_OFFSET( VipsDrawSmudge, width ),
128 		-1000000000, 1000000000, 0 );
129 	VIPS_ARG_INT( class, "height", 9, 
130 		_( "height" ), 
131 		_( "Rect to fill" ),
132 		VIPS_ARGUMENT_REQUIRED_INPUT,
133 		G_STRUCT_OFFSET( VipsDrawSmudge, height ),
134 		-1000000000, 1000000000, 0 );
135 }
136 static void
137 vips_draw_smudge_init( VipsDrawSmudge *draw_smudge )
138 {
139 }
140 int
141 vips_draw_smudge( VipsImage *image, 
142 	int left, int top, int width, int height, ... ) 
143 {
144 	va_list ap;
145 	int result;
146 	va_start( ap, height );
147 	result = vips_call_split( "draw_smudge", ap, 
148 		image, left, top, width, height ); 
149 	va_end( ap );
150 	return( result );
151 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>sink.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/thread.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include &lt;vips/debug.h&gt;
10 #include "sink.h"
11 typedef struct _SinkArea {
12 	struct _Sink *sink;
13 	VipsRect rect;		        VipsSemaphore n_thread;	} SinkArea;
14 typedef struct _Sink {
15 	SinkBase sink_base;
16 	VipsImage *t;
17 	GMutex *sslock;
18 	VipsStartFn start_fn;
19 	VipsGenerateFn generate_fn;
20 	VipsStopFn stop_fn;
21 	void *a;
22 	void *b;
23 	SinkArea *area;
24 	SinkArea *old_area;
25 } Sink;
26 typedef struct _SinkThreadState {
27 	VipsThreadState parent_object;
28         void *seq;
29 	VipsRegion *reg;
30         SinkArea *area;
31 } SinkThreadState;
32 typedef struct _SinkThreadStateClass {
33 	VipsThreadStateClass parent_class;
34 } SinkThreadStateClass;
35 G_DEFINE_TYPE( SinkThreadState, sink_thread_state, VIPS_TYPE_THREAD_STATE );
36 static void
37 sink_area_free( SinkArea *area )
38 {
39 	vips_semaphore_destroy( &amp;area-&gt;n_thread );
40 	g_free( area );
41 }
42 static SinkArea *
43 sink_area_new( Sink *sink )
44 {
45 	SinkArea *area;
46 	if( !(area = VIPS_NEW( NULL, SinkArea )) )
47 		return( NULL );
48 	area-&gt;sink = sink;
49 	vips_semaphore_init( &amp;area-&gt;n_thread, 0, "n_thread" );
50 	return( area );
51 }
52 static void 
53 sink_area_position( SinkArea *area, int top, int height )
54 {
55 	Sink *sink = area-&gt;sink;
56 	VipsRect all, rect;
57 	all.left = 0;
58 	all.top = 0;
59 	all.width = sink-&gt;sink_base.im-&gt;Xsize;
60 	all.height = sink-&gt;sink_base.im-&gt;Ysize;
61 	rect.left = 0;
62 	rect.top = top;
63 	rect.width = sink-&gt;sink_base.im-&gt;Xsize;
64 	rect.height = height;
65 	vips_rect_intersectrect( &amp;all, &amp;rect, &amp;area-&gt;rect );
66 }
67 static gboolean
68 sink_area_allocate_fn( VipsThreadState *state, void *a, gboolean *stop )
69 {
70 	SinkThreadState *sstate = (SinkThreadState *) state;
71 	Sink *sink = (Sink *) a;
72 	SinkBase *sink_base = (SinkBase *) sink;
73 	VipsRect image;
74 	VipsRect tile;
75 	VIPS_DEBUG_MSG( "sink_area_allocate_fn: %p\n", g_thread_self() );
76 	if( sink_base-&gt;x &gt;= sink-&gt;area-&gt;rect.width ) {
77 		sink_base-&gt;x = 0;
78 		sink_base-&gt;y += sink_base-&gt;tile_height;
79 		if( sink_base-&gt;y &gt;= VIPS_RECT_BOTTOM( &amp;sink-&gt;area-&gt;rect ) ) {
80 			if( sink-&gt;area-&gt;rect.top &gt; 0 ) 
81 				vips_semaphore_downn( 
82 					&amp;sink-&gt;old_area-&gt;n_thread, 0 );
83 			if( sink_base-&gt;y &gt;= sink_base-&gt;im-&gt;Ysize ) {
84 				*stop = TRUE;
85 				return( 0 );
86 			}
87 			VIPS_SWAP( SinkArea *, 
88 				sink-&gt;area, sink-&gt;old_area );
89 			sink_area_position( sink-&gt;area, 
90 				sink_base-&gt;y, sink_base-&gt;n_lines );
91 		}
92 	}
93 	image.left = 0;
94 	image.top = 0;
95 	image.width = sink_base-&gt;im-&gt;Xsize;
96 	image.height = sink_base-&gt;im-&gt;Ysize;
97 	tile.left = sink_base-&gt;x;
98 	tile.top = sink_base-&gt;y;
99 	tile.width = sink_base-&gt;tile_width;
100 	tile.height = sink_base-&gt;tile_height;
101 	vips_rect_intersectrect( &amp;image, &amp;tile, &amp;state-&gt;pos );
102 	sstate-&gt;area = sink-&gt;area;
103 	VIPS_DEBUG_MSG( "  %p allocated %d x %d:\n", 
104 		g_thread_self(), state-&gt;pos.left, state-&gt;pos.top );
105 	vips_semaphore_upn( &amp;sink-&gt;area-&gt;n_thread, -1 );
106 	sink_base-&gt;x += sink_base-&gt;tile_width;
107 	sink_base-&gt;processed += state-&gt;pos.width * state-&gt;pos.height;
108 	return( 0 );
109 }
110 static int
111 sink_call_stop( Sink *sink, SinkThreadState *state )
112 {
113 	if( state-&gt;seq &amp;&amp; sink-&gt;stop_fn ) {
114 		int result;
115 		VIPS_DEBUG_MSG( "sink_call_stop: state = %p\n", state );
116 		VIPS_GATE_START( "sink_call_stop: wait" );
117 		g_mutex_lock( sink-&gt;sslock );
118 		VIPS_GATE_STOP( "sink_call_stop: wait" );
119 		result = sink-&gt;stop_fn( state-&gt;seq, sink-&gt;a, sink-&gt;b );
120 		g_mutex_unlock( sink-&gt;sslock );
121 		if( result ) {
122 			SinkBase *sink_base = (SinkBase *) sink;
123 			vips_error( "vips_sink", 
124 				_( "stop function failed for image \"%s\"" ), 
125 				sink_base-&gt;im-&gt;filename );
126 			return( -1 );
127 		}
128 		state-&gt;seq = NULL;
129 	}
130 	return( 0 );
131 }
132 static void
133 sink_thread_state_dispose( GObject *gobject )
134 {
135 	SinkThreadState *state = (SinkThreadState *) gobject;
136 	Sink *sink = (Sink *) ((VipsThreadState *) state)-&gt;a;
137 	sink_call_stop( sink, state );
138 	VIPS_UNREF( state-&gt;reg );
139 	G_OBJECT_CLASS( sink_thread_state_parent_class )-&gt;dispose( gobject );
140 }
141 static int
142 sink_call_start( Sink *sink, SinkThreadState *state )
143 {
144 	if( !state-&gt;seq &amp;&amp; sink-&gt;start_fn ) {
145 		VIPS_DEBUG_MSG( "sink_call_start: state = %p\n", state );
146 		VIPS_GATE_START( "sink_call_start: wait" );
147 		g_mutex_lock( sink-&gt;sslock );
148 		VIPS_GATE_STOP( "sink_call_start: wait" );
149 		state-&gt;seq = sink-&gt;start_fn( sink-&gt;t, sink-&gt;a, sink-&gt;b );
150 		g_mutex_unlock( sink-&gt;sslock );
151 		if( !state-&gt;seq ) {
152 			SinkBase *sink_base = (SinkBase *) sink;
153 			vips_error( "vips_sink", 
154 				_( "start function failed for image \"%s\"" ), 
155 				sink_base-&gt;im-&gt;filename );
156 			return( -1 );
157 		}
158 	}
159 	return( 0 );
160 }
161 static int
162 sink_thread_state_build( VipsObject *object )
163 {
164 	SinkThreadState *state = (SinkThreadState *) object;
165 	Sink *sink = (Sink *) ((VipsThreadState *) state)-&gt;a;
166 	if( !(state-&gt;reg = vips_region_new( sink-&gt;t )) ||
167 <a name="0"></a>		sink_call_start( sink, state ) )
168 		return( -1 );
169 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( VIPS_OBJECT_CLASS( 
170 		sink_thread_state_parent_class )-&gt;build( object ) );
171 }
172 static void
173 sink_thread_state_class_init( SinkThreadStateClass *class )
174 {
175 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
176 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
177 	gobject_class-&gt;dispose = sink_thread_state_dispose;
178 	object_class-&gt;build = sink_thread_state_build;
179 	object_class-&gt;nickname = "sinkthreadstate";
180 	object_class-&gt;description = _( "per-thread state for sink" );</b></font>
181 }
182 static void
183 sink_thread_state_init( SinkThreadState *state )
184 {
185 	state-&gt;seq = NULL;
186 	state-&gt;reg = NULL;
187 }
188 VipsThreadState *
189 vips_sink_thread_state_new( VipsImage *im, void *a )
190 {
191 	return( VIPS_THREAD_STATE( vips_object_new( 
192 		sink_thread_state_get_type(), 
193 		vips_thread_state_set, im, a ) ) );
194 }
195 static void
196 sink_free( Sink *sink )
197 {
198 	VIPS_FREEF( vips_g_mutex_free, sink-&gt;sslock );
199 	VIPS_FREEF( sink_area_free, sink-&gt;area );
200 	VIPS_FREEF( sink_area_free, sink-&gt;old_area );
201 	VIPS_FREEF( g_object_unref, sink-&gt;t );
202 }
203 void
204 vips_sink_base_init( SinkBase *sink_base, VipsImage *image )
205 {
206 	vips_image_set_kill( image, FALSE );
207 	sink_base-&gt;im = image;
208 	sink_base-&gt;x = 0;
209 	sink_base-&gt;y = 0;
210 	vips_get_tile_size( image, 
211 		&amp;sink_base-&gt;tile_width, &amp;sink_base-&gt;tile_height, 
212 		&amp;sink_base-&gt;n_lines );
213 	sink_base-&gt;processed = 0;
214 }
215 static int
216 sink_init( Sink *sink, 
217 	VipsImage *image, 
218 	VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn,
219 	void *a, void *b )
220 {
221 	g_assert( generate_fn );
222 	vips_sink_base_init( &amp;sink-&gt;sink_base, image );
223 	sink-&gt;t = NULL;
224 	sink-&gt;sslock = vips_g_mutex_new();
225 	sink-&gt;start_fn = start_fn;
226 	sink-&gt;generate_fn = generate_fn;
227 	sink-&gt;stop_fn = stop_fn;
228 	sink-&gt;a = a;
229 	sink-&gt;b = b;
230 	sink-&gt;area = NULL;
231 	sink-&gt;old_area = NULL;
232 	if( !(sink-&gt;t = vips_image_new()) ||
233 		!(sink-&gt;area = sink_area_new( sink )) ||
234 		!(sink-&gt;old_area = sink_area_new( sink )) ||
235 		vips_image_write( sink-&gt;sink_base.im, sink-&gt;t ) ) {
236 		sink_free( sink );
237 		return( -1 );
238 	}
239 	return( 0 );
240 }
241 static int 
242 sink_work( VipsThreadState *state, void *a )
243 {
244 	SinkThreadState *sstate = (SinkThreadState *) state;
245 	Sink *sink = (Sink *) a;
246 	SinkArea *area = sstate-&gt;area;
247 	int result;
248 	result = vips_region_prepare( sstate-&gt;reg, &amp;state-&gt;pos );
249 	if( !result )
250 		result = sink-&gt;generate_fn( sstate-&gt;reg, sstate-&gt;seq,
251 			sink-&gt;a, sink-&gt;b, &amp;state-&gt;stop );
252 	vips_semaphore_upn( &amp;area-&gt;n_thread, 1 );
253 	return( result );
254 }
255 int 
256 vips_sink_base_progress( void *a )
257 {
258 	SinkBase *sink_base = (SinkBase *) a;
259 	VIPS_DEBUG_MSG( "vips_sink_base_progress:\n" ); 
260 	vips_image_eval( sink_base-&gt;im, sink_base-&gt;processed );
261 	if( vips_image_iskilled( sink_base-&gt;im ) )
262 		return( -1 );
263 	return( 0 );
264 }
265 int
266 vips_sink_tile( VipsImage *im, 
267 	int tile_width, int tile_height,
268 	VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn,
269 	void *a, void *b )
270 {
271 	Sink sink;
272 	int result;
273 	g_assert( vips_object_sanity( VIPS_OBJECT( im ) ) );
274 	im-&gt;Bbits = vips_format_sizeof( im-&gt;BandFmt ) &lt;&lt; 3;
275 	if( sink_init( &amp;sink, im, start_fn, generate_fn, stop_fn, a, b ) )
276 		return( -1 );
277 	if( tile_width &gt; 0 ) {
278 		sink.sink_base.tile_width = tile_width;
279 		sink.sink_base.tile_height = tile_height;
280 	}
281 	vips_image_preeval( im );
282 	sink_area_position( sink.area, 0, sink.sink_base.n_lines );
283 	result = vips_threadpool_run( im, 
284 		vips_sink_thread_state_new,
285 		sink_area_allocate_fn, 
286 		sink_work, 
287 		vips_sink_base_progress, 
288 		&amp;sink );
289 	vips_image_posteval( im );
290 	sink_free( &amp;sink );
291 	return( result );
292 }
293 int
294 vips_sink( VipsImage *im, 
295 	VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn,
296 	void *a, void *b )
297 {
298 	return( vips_sink_tile( im, -1, -1, 
299 		start_fn, generate_fn, stop_fn, a, b ) );
300 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
