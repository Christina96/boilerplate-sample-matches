<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttpfs.c &amp; template.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttpfs.c &amp; template.c
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttpfs.c (12.529551%)<th>template.c (1.9717262%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(130-151)<td><a href="#" name="0">(61-75)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(743-755)<td><a href="#" name="1">(1489-1500)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(771-784)<td><a href="#" name="2">(1970-1986)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;json_object.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "datetime.h"
#include "statsobj.h"
#include "unicode-helper.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omhttpfs")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)
#define OMHTTPFS_VERSION "1.0"
#define OMHTTPFS_DEFAULT_PORT 14000
#define OMHTTPFS_DEFAULT_USER "hdfs"
#define OMHTTPFS_DEFAULT_HOST "127.0.0.1"
#define HTTPFS_URL_PREFIX_V1     "/webhdfs/v1"
#define HTTPFS_URL_PREFIX_V1_SSL "/swebhdfs/v1"
#define HTTPFS_CONTENT_TYPE      "Content-Type: application/octet-stream"
#define HTTPFS_USER_AGENT        "omhttpfs by sskaje/" OMHTTPFS_VERSION
#define HTTPFS_CONTENT_TYPE_JSON "application/json"
#define HTTPFS_JSON_BOOLEAN_TRUE "{\"boolean\":true}"
#define HTTPFS_FILEALREADYEXISTSEXCEPTION "FileAlreadyExistsException"
#define HTTPFS_URL_BUFFER_LENGTH 2048
#define DPP(x) DBGPRINTF("OMHTTPFS: %s:%d %s(): %s\n", __FILE__, __LINE__, __FUNCTION__, x)
typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
	char message[1024];
	char exception[256];
	char class[256];
} httpfs_json_remote_exception;
typedef struct _instanceData {
	sbool https;
	uchar* host;
	uchar* ip;
	int  port;
	uchar* user;
	int timeout;
	uchar* file;
	sbool isDynFile;
	uchar* tplName;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	CURL* curl;
	uchar* file;
	int replyLen;
	char* reply;
} wrkrInstanceData_t;
<a name="0"></a>static struct cnfparamdescr actpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "host", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "user", eCmdHdlrGetWord, 0 },
	{ "https", eCmdHdlrBinary, 0 },
	{ "file", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "isdynfile", eCmdHdlrBinary, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};
static rsRetVal</b></font>
httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
{
	CURL *curl = NULL;
	curl = curl_easy_init();
	if (curl) {
		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
		if (pData-&gt;https) {
			DBGPRINTF("%s(): Enable HTTPS\n", __FUNCTION__);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
		}
	} else {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, "omhttpfs: failed to init cURL\n");
		return RS_RET_OBJ_CREATION_FAILED;
	}
	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);
	pWrkrData-&gt;curl = curl;
	return RS_RET_OK;
}
static rsRetVal
httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
{
	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);
	if (pWrkrData-&gt;pData-&gt;https) {
	    es_addBuf(url_buf, "https://", sizeof("https://")-1);
	} else {
	    es_addBuf(url_buf, "http://", sizeof("http://")-1);
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));
	es_addChar(url_buf, ':');
	char portBuf[6];
	snprintf(portBuf, sizeof(portBuf), "%d", pWrkrData-&gt;pData-&gt;port);
	es_addBuf(url_buf, portBuf, strlen(portBuf));
	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);
	if (pWrkrData-&gt;file[0] != '/') {
	    es_addChar(url_buf, '/');
	}
	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));
	es_addBuf(url_buf, "?user.name=", sizeof("?user.name=")-1);
	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));
	es_addBuf(url_buf, op, strlen(op));
	return RS_RET_OK;
}
static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
{
	es_str_t* url;
	char* url_cstr;
	httpfs_build_url(pWrkrData, op, &amp;url);
	url_cstr = es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
	free(url_cstr);
}
static void httpfs_curl_set_put(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
}
static void httpfs_curl_set_post(CURL* curl)
{
	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
	curl_easy_setopt(curl, CURLOPT_POST, 1L);
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
}
static struct curl_slist*
httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
{
	const char* hdr;
	va_list ar;
	va_start(ar, hdr_count);
	for (; hdr_count &gt; 0; hdr_count--) {
	    hdr = va_arg(ar, const char*);
	    if (hdr != NULL
	            &amp;&amp; hdr[0] != 0) {
	        headers = curl_slist_append(headers, hdr);
	    } else {
	        break;
	    }
	}
	va_end(ar);
	headers = curl_slist_append(headers, "Expect:");
	headers = curl_slist_append(headers, "Transfer-Encoding:");
	return headers;
}
static size_t
httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
{
	size_t realsize = size * nmemb;
	char *newreply = NULL;
	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;
	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
	if (newreply == NULL) {
	    dbgprintf("not enough memory (realloc returned NULL)\n");
	    if (mem-&gt;reply != NULL)
	        free(mem-&gt;reply);
	    mem-&gt;reply = NULL;
	    mem-&gt;replyLen = 0;
	    return 0;
	}
	mem-&gt;reply = newreply;
	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
	mem-&gt;replyLen += realsize;
	mem-&gt;reply[mem-&gt;replyLen] = 0;
	return realsize;
}
#define HTTPFS_CURL_VARS_INIT \
	struct curl_slist* headers = NULL; \
	long response_code; \
	CURLcode res; \
	char* content_type;
#define HTTPFS_CURL_VARS_RELEASE \
	curl_slist_free_all(headers);
#define HTTPFS_CURL_EXEC \
	pWrkrData-&gt;reply = NULL; \
	pWrkrData-&gt;replyLen = 0; \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
	res = curl_easy_perform(pWrkrData-&gt;curl); \
	if (res == CURLE_OK) { \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
	    } \
	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
	    if (pWrkrData-&gt;reply != NULL) { \
	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
	    } \
	} else { \
	LogError(0, RS_RET_ERR, "CURL request fail, code=%d, error string=%s\n", res, curl_easy_strerror(res)); \
	    return -1; \
	}
static rsRetVal
httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
{
	DEFiRet;
	if (!length) {
	    return RS_RET_JSON_PARSE_ERR;
	}
	struct json_tokener* jt = json_tokener_new();
	json_tokener_reset(jt);
	struct json_object *json;
	json = json_tokener_parse_ex(jt, buf, length);
	if (!json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	if (!json_object_object_get_ex(json, "RemoteException", &amp;json)) {
	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	struct json_object *jobj;
	memset(jre, 0, sizeof(*jre));
	const char *str;
	json_object_object_get_ex(json, "javaClassName", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';
	json_object_object_get_ex(json, "exception", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';
	json_object_object_get_ex(json, "message", &amp;jobj);
	str = json_object_get_string(jobj);
	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';
finalize_it:
	if(jt != NULL)
		json_tokener_free(jt);
	if(json != NULL)
		json_object_put(json);
	RETiRet;
}
static rsRetVal
httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
HTTPFS_CURL_VARS_INIT
	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_put(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, "&amp;op=create&amp;overwrite=false&amp;data=true");
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
HTTPFS_CURL_EXEC
	int success = 0;
	if (response_code == 201) {
	    success = 1;
	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}
static rsRetVal
httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
HTTPFS_CURL_VARS_INIT
	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
	httpfs_curl_set_post(pWrkrData-&gt;curl);
	httpfs_set_url(pWrkrData, "&amp;op=append&amp;data=true");
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
HTTPFS_CURL_EXEC
	int success = 0;
	if (response_code == 200) {
	    success = 1;
	} else if (response_code == 404) {
	}
HTTPFS_CURL_VARS_RELEASE
	if (success) {
	    return RS_RET_OK;
	} else {
	    return RS_RET_FALSE;
	}
}
static rsRetVal
httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
{
	DEFiRet;
	long response_code;
	httpfs_json_remote_exception jre;
	iRet = httpfs_append_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF("omhttpfs: Append success: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code != 404) {
	    DBGPRINTF("omhttpfs: Append fail HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
	    return RS_RET_FALSE;
	}
	iRet = httpfs_create_file(pWrkrData, buf);
	if (iRet == RS_RET_OK) {
	    DBGPRINTF("omhttpfs: Create file success: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
	if (response_code == 201) {
	    DBGPRINTF("omhttpfs: Create file success HTTP 201: %s\n", pWrkrData-&gt;file);
	    return RS_RET_OK;
	}
	if (response_code == 500) {
	    DBGPRINTF("omhttpfs: Create file failed HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
	        DBGPRINTF("omhttpfs: File already exists, append again: %s\n", pWrkrData-&gt;file);
	        iRet = httpfs_append_file(pWrkrData, buf);
	        if (iRet == RS_RET_OK) {
	            DBGPRINTF("omhttpfs: Re-Append success: %s\n", pWrkrData-&gt;file);
	            return RS_RET_OK;
	        } else {
	            DBGPRINTF("omhttpfs: Re-Append failed: %s\n", pWrkrData-&gt;file);
	        }
	    } else {
	        DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
	    }
	} else {
	    DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
	}
	return RS_RET_FALSE;
}
BEGINinitConfVars
	CODESTARTinitConfVars
ENDinitConfVars
BEGINcreateInstance
CODESTARTcreateInstance
	DBGPRINTF("omhttpfs: createInstance\n");
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	DBGPRINTF("omhttpfs: createWrkrInstance\n");
	pWrkrData-&gt;curl = NULL;
	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
	DBGPRINTF("omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n",
	pData, pWrkrData-&gt;pData, pWrkrData);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
	    iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;file);
	free(pData-&gt;tplName);
	free(pData-&gt;host);
	free(pData-&gt;user);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	free(pWrkrData-&gt;file);
	if(pWrkrData-&gt;curl) {
	    curl_easy_cleanup(pWrkrData-&gt;curl);
	    pWrkrData-&gt;curl = NULL;
	}
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF("OmHTTPFS\n");
	DBGPRINTF("Version: %s\n", OMHTTPFS_VERSION);
	DBGPRINTF("\tHost: %s\n", pData-&gt;host);
	DBGPRINTF("\tPort: %d\n", pData-&gt;port);
	DBGPRINTF("\tUser: %s\n", pData-&gt;user);
	DBGPRINTF("\tFile: %s\n", pData-&gt;file);
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
	DBGPRINTF("omhttpfs: tryResume called\n");
	iRet = RS_RET_OK;
ENDtryResume
BEGINdoAction
CODESTARTdoAction
	DBGPRINTF("omhttpfs: doAction\n");
	if (pWrkrData-&gt;pData-&gt;isDynFile) {
	    pWrkrData-&gt;file = ustrdup(ppString[1]);
	} else {
	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
	}
	iRet = httpfs_log(pWrkrData, ppString[0]);
	if(iRet != RS_RET_OK) {
	    DBGPRINTF("omhttpfs: error writing httpfs, suspending\n");
	    iRet = RS_RET_SUSPENDED;
	}
ENDdoAction
static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
	pData-&gt;https = 0;
	pData-&gt;file = NULL;
	pData-&gt;isDynFile = 0;
	pData-&gt;tplName = NULL;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
<a name="1"></a>	int i;
	uchar *tplToUse;
CODESTARTnewActInst
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
	    if(!pvals[i].bUsed)
	        continue;
	    if(!strcmp(actpblk.descr[i].name, "host")) {
	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "port")) {</b></font>
	        pData-&gt;port = (int) pvals[i].val.d.n;
	    } else if(!strcmp(actpblk.descr[i].name, "user")) {
	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "https")) {
	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;
	    } else if(!strcmp(actpblk.descr[i].name, "file")) {
	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
	    } else if(!strcmp(actpblk.descr[i].name, "isdynfile")) {
	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;
<a name="2"></a>
	    } else if(!strcmp(actpblk.descr[i].name, "template")) {
	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	    } else {
	        DBGPRINTF("omhttpfs: program error, non-handled param '%s'\n", actpblk.descr[i].name);
	    }
	}
	if(pData-&gt;file == NULL) {
	    LogError(0, RS_RET_INTERNAL_ERROR, "omhttpfs: file is not set "
		"[this should not be possible]\n");
	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}
	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {</b></font>
	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
	}
	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
	}
	if (pData-&gt;isDynFile) {
	    CODE_STD_STRING_REQUESTparseSelectorAct(2)
	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
	} else {
	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
	}
	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) "RSYSLOG_FileFormat" : pData-&gt;tplName);
	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
NO_LEGACY_CONF_parseSelectorAct
BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();
	objRelease(datetime, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
	    LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -httpfs module init failed");
	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}
	DBGPRINTF("omhttpfs version %s is initializing\n", OMHTTPFS_VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>template.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &lt;json.h&gt;
#include "stringbuf.h"
#include "syslogd-types.h"
#include "template.h"
#include "msg.h"
#include "dirty.h"
#include "obj.h"
#include "errmsg.h"
#include "strgen.h"
#include "rsconf.h"
#include "msg.h"
#include "parserif.h"
#include "unicode-helper.h"
PRAGMA_INGORE_Wswitch_enum
DEFobjCurrIf(obj)
DEFobjCurrIf(strgen)
static struct cnfparamdescr cnfparamdescr[] = {
<a name="0"></a>	{ "name", eCmdHdlrString, 1 },
	{ "type", eCmdHdlrString, 1 },
	{ "string", eCmdHdlrString, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "plugin", eCmdHdlrString, 0 },
	{ "subtree", eCmdHdlrString, 0 },
	{ "option.stdsql", eCmdHdlrBinary, 0 },
	{ "option.sql", eCmdHdlrBinary, 0 },
	{ "option.json", eCmdHdlrBinary, 0 },
	{ "option.jsonf", eCmdHdlrBinary, 0 },
	{ "option.casesensitive", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk pblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
	  cnfparamdescr
	};
static struct cnfparamdescr cnfparamdescrProperty[] = {</b></font>
	{ "name", eCmdHdlrString, 1 },
	{ "outname", eCmdHdlrString, 0 },
	{ "dateformat", eCmdHdlrString, 0 },
	{ "date.inutc", eCmdHdlrBinary, 0 },
	{ "compressspace", eCmdHdlrBinary, 0 },
	{ "caseconversion", eCmdHdlrString, 0 },
	{ "controlcharacters", eCmdHdlrString, 0 },
	{ "securepath", eCmdHdlrString, 0 },
	{ "format", eCmdHdlrString, 0 },
	{ "position.from", eCmdHdlrInt, 0 },
	{ "position.to", eCmdHdlrInt, 0 },
	{ "position.relativetoend", eCmdHdlrBinary, 0 },
	{ "field.number", eCmdHdlrInt, 0 },
	{ "field.delimiter", eCmdHdlrInt, 0 },
	{ "regex.expression", eCmdHdlrString, 0 },
	{ "regex.type", eCmdHdlrString, 0 },
	{ "regex.nomatchmode", eCmdHdlrString, 0 },
	{ "regex.match", eCmdHdlrInt, 0 },
	{ "regex.submatch", eCmdHdlrInt, 0 },
	{ "droplastlf", eCmdHdlrBinary, 0 },
	{ "fixedwidth", eCmdHdlrBinary, 0 },
	{ "datatype", eCmdHdlrString, 0 },
	{ "onempty", eCmdHdlrString, 0 },
	{ "mandatory", eCmdHdlrBinary, 0 },
	{ "spifno1stsp", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk pblkProperty =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescrProperty)/sizeof(struct cnfparamdescr),
	  cnfparamdescrProperty
	};
static struct cnfparamdescr cnfparamdescrConstant[] = {
	{ "value", eCmdHdlrString, 1 },
	{ "format", eCmdHdlrString, 0 },
	{ "outname", eCmdHdlrString, 0 }
};
static struct cnfparamblk pblkConstant =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescrConstant)/sizeof(struct cnfparamdescr),
	  cnfparamdescrConstant
	};
#ifdef FEATURE_REGEXP
DEFobjCurrIf(regexp)
#endif
#define ALLOC_INC 128
rsRetVal
ExtendBuf(actWrkrIParams_t *__restrict__ const iparam, const size_t iMinSize)
{
	uchar *pNewBuf;
	size_t iNewSize;
	DEFiRet;
	iNewSize = (iMinSize / ALLOC_INC + 1) * ALLOC_INC;
	CHKmalloc(pNewBuf = (uchar*) realloc(iparam-&gt;param, iNewSize));
	iparam-&gt;param = pNewBuf;
	iparam-&gt;lenBuf = iNewSize;
finalize_it:
	RETiRet;
}
rsRetVal
tplToString(struct template *__restrict__ const pTpl,
	    smsg_t *__restrict__ const pMsg,
	    actWrkrIParams_t *__restrict__ const iparam,
	    struct syslogTime *const ttNow)
{
	DEFiRet;
	struct templateEntry *__restrict__ pTpe;
	size_t iBuf;
	unsigned short bMustBeFreed = 0;
	uchar *pVal;
	rs_size_t iLenVal = 0;
	if(pTpl-&gt;pStrgen != NULL) {
		CHKiRet(pTpl-&gt;pStrgen(pMsg, iparam));
		FINALIZE;
	}
	if(pTpl-&gt;bHaveSubtree) {
		getJSONPropVal(pMsg, &amp;pTpl-&gt;subtree, &amp;pVal, &amp;iLenVal, &amp;bMustBeFreed);
		if(iLenVal &gt;= (rs_size_t)iparam-&gt;lenBuf) 			CHKiRet(ExtendBuf(iparam, iLenVal + 1));
		memcpy(iparam-&gt;param, pVal, iLenVal+1);
		FINALIZE;
	}
	pTpe = pTpl-&gt;pEntryRoot;
	iBuf = 0;
	const int extra_space = (pTpl-&gt;optFormatEscape == JSONF) ? 1 : 3;
	if(pTpl-&gt;optFormatEscape == JSONF) {
		if(iparam-&gt;lenBuf &lt; 2) 			CHKiRet(ExtendBuf(iparam, 2));
		iBuf = 1;
		*iparam-&gt;param = '{';
	}
	while(pTpe != NULL) {
		if(pTpe-&gt;eEntryType == CONSTANT) {
			pVal = (uchar*) pTpe-&gt;data.constant.pConstant;
			iLenVal = pTpe-&gt;data.constant.iLenConstant;
			bMustBeFreed = 0;
		} else 	if(pTpe-&gt;eEntryType == FIELD) {
			pVal = (uchar*) MsgGetProp(pMsg, pTpe, &amp;pTpe-&gt;data.field.msgProp,
						   &amp;iLenVal, &amp;bMustBeFreed, ttNow);
			if(pTpl-&gt;optFormatEscape == SQL_ESCAPE)
				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, SQL_ESCAPE);
			else if(pTpl-&gt;optFormatEscape == JSON_ESCAPE)
				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, JSON_ESCAPE);
			else if(pTpl-&gt;optFormatEscape == STDSQL_ESCAPE)
				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, STDSQL_ESCAPE);
		} else {
			DBGPRINTF("TplToString: invalid entry type %d\n", pTpe-&gt;eEntryType);
			pVal = (uchar*) "*LOGIC ERROR*";
			iLenVal = sizeof("*LOGIC ERROR*") - 1;
			bMustBeFreed = 0;
		}
		if(iLenVal &gt; 0) { 			if(iBuf + iLenVal + extra_space &gt;= iparam-&gt;lenBuf) 				CHKiRet(ExtendBuf(iparam, iBuf + iLenVal + 1));
			memcpy(iparam-&gt;param + iBuf, pVal, iLenVal);
			iBuf += iLenVal;
			if(pTpl-&gt;optFormatEscape == JSONF) {
				memcpy(iparam-&gt;param + iBuf,
					(pTpe-&gt;pNext == NULL) ? "}\n" : ", ", 2);
				iBuf += 2;
			}
		}
		if(bMustBeFreed) {
			free(pVal);
			bMustBeFreed = 0;
		}
		pTpe = pTpe-&gt;pNext;
	}
	if(iBuf == iparam-&gt;lenBuf) {
		CHKiRet(ExtendBuf(iparam, iBuf + 1));
	}
	iparam-&gt;param[iBuf] = '\0';
	iparam-&gt;lenStr = iBuf;
finalize_it:
	if(bMustBeFreed) {
		free(pVal);
		bMustBeFreed = 0;
	}
	RETiRet;
}
rsRetVal
tplToJSON(struct template *pTpl, smsg_t *pMsg, struct json_object **pjson, struct syslogTime *ttNow)
{
	struct templateEntry *pTpe;
	rs_size_t propLen;
	unsigned short bMustBeFreed;
	uchar *pVal;
	struct json_object *json, *jsonf;
	rsRetVal localRet;
	DEFiRet;
	if(pTpl-&gt;bHaveSubtree){
		if(jsonFind(pMsg, &amp;pTpl-&gt;subtree, pjson) != RS_RET_OK)
			*pjson = NULL;
		if(*pjson == NULL) {
			*pjson = json_object_new_object();
		} else {
			json_object_get(*pjson); 		}
		FINALIZE;
	}
	json = json_object_new_object();
	for(pTpe = pTpl-&gt;pEntryRoot ; pTpe != NULL ; pTpe = pTpe-&gt;pNext) {
		if(pTpe-&gt;eEntryType == CONSTANT) {
			if(pTpe-&gt;fieldName == NULL)
				continue;
			jsonf = json_object_new_string((char*) pTpe-&gt;data.constant.pConstant);
			json_object_object_add(json, (char*)pTpe-&gt;fieldName, jsonf);
		} else 	if(pTpe-&gt;eEntryType == FIELD) {
			if(pTpe-&gt;data.field.msgProp.id == PROP_CEE        ||
			   pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR  ||
			   pTpe-&gt;data.field.msgProp.id == PROP_GLOBAL_VAR   ) {
				localRet = msgGetJSONPropJSON(pMsg, &amp;pTpe-&gt;data.field.msgProp, &amp;jsonf);
				if(localRet == RS_RET_OK) {
					json_object_object_add(json, (char*)pTpe-&gt;fieldName, json_object_get(jsonf));
				} else {
					DBGPRINTF("tplToJSON: error %d looking up property %s\n",
						  localRet, pTpe-&gt;fieldName);
					if(pTpe-&gt;data.field.options.bMandatory) {
						json_object_object_add(json, (char*)pTpe-&gt;fieldName, NULL);
					}
				}
			} else  {
				pVal = (uchar*) MsgGetProp(pMsg, pTpe, &amp;pTpe-&gt;data.field.msgProp,
							   &amp;propLen, &amp;bMustBeFreed, ttNow);
				if(pTpe-&gt;data.field.options.bMandatory || propLen &gt; 0) {
					jsonf = json_object_new_string_len((char*)pVal, propLen+1);
					json_object_object_add(json, (char*)pTpe-&gt;fieldName, jsonf);
				}
				if(bMustBeFreed) { 					free(pVal);
				}
			}
		}
	}
	assert(iRet == RS_RET_OK);
	*pjson = json;
finalize_it:
	RETiRet;
}
static void doEmergencyEscape(register uchar *p, int mode)
{
	while(*p) {
		if((mode == SQL_ESCAPE||mode == STDSQL_ESCAPE) &amp;&amp; *p == '\'') {
			*p = '"';
		} else if(mode == JSON_ESCAPE) {
			if(*p == '"') {
				*p = '\'';
			} else if(*p == '\\' ) {
				*p = '/';
			}
		} else if((mode == SQL_ESCAPE) &amp;&amp; *p == '\\') {
			*p = '/';
		}
		++p;
	}
}
rsRetVal
doEscape(uchar **pp, rs_size_t *pLen, unsigned short *pbMustBeFreed, int mode)
{
	DEFiRet;
	uchar *p = NULL;
	int iLen;
	cstr_t *pStrB = NULL;
	uchar *pszGenerated;
	assert(pp != NULL);
	assert(*pp != NULL);
	assert(pLen != NULL);
	assert(pbMustBeFreed != NULL);
	if(mode == STDSQL_ESCAPE)
		for(p = *pp ; *p &amp;&amp; *p != '\'' ; ++p)
			;
	else if(mode == SQL_ESCAPE)
		for(p = *pp ; *p &amp;&amp; *p != '\'' &amp;&amp; *p != '\\' ; ++p)
			;
	else if(mode == JSON_ESCAPE)
		for(p = *pp ; *p &amp;&amp;  (*p == '"' || *p == '\\' ) ; ++p)
			;
	if(p &amp;&amp; *p == '\0')
		FINALIZE; 
	p = *pp;
	iLen = *pLen;
	CHKiRet(cstrConstruct(&amp;pStrB));
	while(*p) {
		if((mode == SQL_ESCAPE || mode == STDSQL_ESCAPE) &amp;&amp; *p == '\'') {
			CHKiRet(cstrAppendChar(pStrB, (mode == STDSQL_ESCAPE) ? '\'' : '\\'));
			iLen++;			} else if((mode == SQL_ESCAPE) &amp;&amp; *p == '\\') {
			CHKiRet(cstrAppendChar(pStrB, '\\'));
			iLen++;			} else if((mode == JSON_ESCAPE) &amp;&amp;  (*p == '"' || *p == '\\' )) {
			CHKiRet(cstrAppendChar(pStrB, '\\'));
			iLen++;			}
		CHKiRet(cstrAppendChar(pStrB, *p));
		++p;
	}
	cstrFinalize(pStrB);
	CHKiRet(cstrConvSzStrAndDestruct(&amp;pStrB, &amp;pszGenerated, 0));
	if(*pbMustBeFreed)
		free(*pp); 
	*pp = pszGenerated;
	*pLen = iLen;
	*pbMustBeFreed = 1;
finalize_it:
	if(iRet != RS_RET_OK) {
		doEmergencyEscape(*pp, mode);
		if(pStrB != NULL)
			cstrDestruct(&amp;pStrB);
	}
	RETiRet;
}
static struct templateEntry* tpeConstruct(struct template *pTpl)
{
	struct templateEntry *pTpe;
	assert(pTpl != NULL);
	if((pTpe = calloc(1, sizeof(struct templateEntry))) == NULL)
		return NULL;
	if(pTpl-&gt;pEntryLast == NULL){
		pTpl-&gt;pEntryRoot = pTpl-&gt;pEntryLast  = pTpe;
	} else {
		pTpl-&gt;pEntryLast-&gt;pNext = pTpe;
		pTpl-&gt;pEntryLast  = pTpe;
	}
	pTpl-&gt;tpenElements++;
	return(pTpe);
}
static void
apply_case_sensitivity(struct template *pTpl)
{
	if(pTpl-&gt;optCaseSensitive) return;
	struct templateEntry *pTpe;
	for(pTpe = pTpl-&gt;pEntryRoot ; pTpe != NULL ; pTpe = pTpe-&gt;pNext) {
		if(pTpe-&gt;eEntryType == FIELD) {
			if(pTpe-&gt;data.field.msgProp.id == PROP_CEE        ||
			   pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR  ||
			   pTpe-&gt;data.field.msgProp.id == PROP_GLOBAL_VAR   ) {
				uchar* p;
				p = pTpe-&gt;fieldName;
				for ( ; *p; ++p) *p = tolower(*p);
				p = pTpe-&gt;data.field.msgProp.name;
				for ( ; *p; ++p) *p = tolower(*p);
			}
		}
	}
}
static struct template*
tplConstruct(rsconf_t *conf)
{
	struct template *pTpl;
	if((pTpl = calloc(1, sizeof(struct template))) == NULL)
		return NULL;
	if(conf-&gt;templates.last == NULL)	{
		conf-&gt;templates.root = conf-&gt;templates.last = pTpl;
	} else {
		conf-&gt;templates.last-&gt;pNext = pTpl;
		conf-&gt;templates.last = pTpl;
	}
	return(pTpl);
}
static rsRetVal
do_Constant(unsigned char **pp, struct template *pTpl, int bDoEscapes)
{
	register unsigned char *p;
	cstr_t *pStrB;
	struct templateEntry *pTpe;
	int i;
	DEFiRet;
	assert(pp != NULL);
	assert(*pp != NULL);
	assert(pTpl != NULL);
	p = *pp;
	CHKiRet(cstrConstruct(&amp;pStrB));
	while(*p &amp;&amp; *p != '%' &amp;&amp; !(bDoEscapes &amp;&amp; *p == '\"')) {
		if(bDoEscapes &amp;&amp; *p == '\\') {
			switch(*++p) {
				case '\0':
					cstrAppendChar(pStrB, *p);
					break;
				case 'n':
					cstrAppendChar(pStrB, '\n');
					++p;
					break;
				case 'r':
					cstrAppendChar(pStrB, '\r');
					++p;
					break;
				case '\\':
					cstrAppendChar(pStrB, '\\');
					++p;
					break;
				case '%':
					cstrAppendChar(pStrB, '%');
					++p;
					break;
				case '0': 				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					i = 0;
					while(*p &amp;&amp; isdigit((int)*p)) {
						i = i * 10 + *p++ - '0';
					}
					cstrAppendChar(pStrB, i);
					break;
				default:
					cstrAppendChar(pStrB, *p++);
					break;
			}
		}
		else
			cstrAppendChar(pStrB, *p++);
	}
	if((pTpe = tpeConstruct(pTpl)) == NULL) {
		rsCStrDestruct(&amp;pStrB);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pTpe-&gt;eEntryType = CONSTANT;
	cstrFinalize(pStrB);
	pTpe-&gt;data.constant.iLenConstant = rsCStrLen(pStrB);
	CHKiRet(cstrConvSzStrAndDestruct(&amp;pStrB, &amp;pTpe-&gt;data.constant.pConstant, 0));
	*pp = p;
finalize_it:
	RETiRet;
}
static int hasFormat(struct templateEntry *pTpe) {
	return (
		pTpe-&gt;data.field.options.bCSV ||
		pTpe-&gt;data.field.options.bJSON ||
		pTpe-&gt;data.field.options.bJSONf ||
		pTpe-&gt;data.field.options.bJSONr
	);
}
static void doOptions(unsigned char **pp, struct templateEntry *pTpe)
{
	register unsigned char *p;
	unsigned char Buf[64];
	size_t i;
	assert(pp != NULL);
	assert(*pp != NULL);
	assert(pTpe != NULL);
	p = *pp;
	while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
		memset(Buf, 0, sizeof(Buf)); 		i = 0;
		while((i &lt; sizeof(Buf)-1) &amp;&amp;
		      *p &amp;&amp; *p != '%' &amp;&amp; *p != ':' &amp;&amp; *p != ',') {
			Buf[i++] = tolower((int)*p);
			++p;
		}
		Buf[i] = '\0'; 		while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':' &amp;&amp; *p != ',')
			++p;			if(*p == ',')
		if(!strcmp((char*)Buf, "date-mysql")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtMySQLDate;
		} else if(!strcmp((char*)Buf, "date-pgsql")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtPgSQLDate;
		} else if(!strcmp((char*)Buf, "date-rfc3164")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3164Date;
		} else if(!strcmp((char*)Buf, "date-rfc3164-buggyday")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3164BuggyDate;
		} else if(!strcmp((char*)Buf, "date-rfc3339")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3339Date;
		} else if(!strcmp((char*)Buf, "date-unixtimestamp")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtUnixDate;
		} else if(!strcmp((char*)Buf, "date-subseconds")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtSecFrac;
		} else if(!strcmp((char*)Buf, "date-wdayname")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtWDayName;
		} else if(!strcmp((char*)Buf, "date-wday")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtWDay;
		} else if(!strcmp((char*)Buf, "date-year")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtYear;
		} else if(!strcmp((char*)Buf, "date-month")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtMonth;
		} else if(!strcmp((char*)Buf, "date-day")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtDay;
		} else if(!strcmp((char*)Buf, "date-hour")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtHour;
		} else if(!strcmp((char*)Buf, "date-minute")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtMinute;
		} else if(!strcmp((char*)Buf, "date-second")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtSecond;
		} else if(!strcmp((char*)Buf, "date-tzoffshour")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsHour;
		} else if(!strcmp((char*)Buf, "date-tzoffsmin")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsMin;
		} else if(!strcmp((char*)Buf, "date-tzoffsdirection")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsDirection;
		} else if (!strcmp((char*)Buf, "date-ordinal")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtOrdinal;
		} else if (!strcmp((char*)Buf, "date-week")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtWeek;
		} else if (!strcmp((char*)Buf, "date-iso-week")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtISOWeek;
		} else if (!strcmp((char*)Buf, "date-iso-week-year")) {
			pTpe-&gt;data.field.eDateFormat = tplFmtISOWeekYear;
		} else if(!strcmp((char*)Buf, "date-utc")) {
			pTpe-&gt;data.field.options.bDateInUTC = 1;
		} else if(!strcmp((char*)Buf, "lowercase")) {
			pTpe-&gt;data.field.eCaseConv = tplCaseConvLower;
		} else if(!strcmp((char*)Buf, "uppercase")) {
			pTpe-&gt;data.field.eCaseConv = tplCaseConvUpper;
		} else if(!strcmp((char*)Buf, "sp-if-no-1st-sp")) {
			pTpe-&gt;data.field.options.bSPIffNo1stSP = 1;
		} else if(!strcmp((char*)Buf, "compressspace")) {
			pTpe-&gt;data.field.options.bCompressSP = 1;
		} else if(!strcmp((char*)Buf, "escape-cc")) {
			pTpe-&gt;data.field.options.bEscapeCC = 1;
		} else if(!strcmp((char*)Buf, "drop-cc")) {
			pTpe-&gt;data.field.options.bDropCC = 1;
		} else if(!strcmp((char*)Buf, "space-cc")) {
			pTpe-&gt;data.field.options.bSpaceCC = 1;
		} else if(!strcmp((char*)Buf, "drop-last-lf")) {
			pTpe-&gt;data.field.options.bDropLastLF = 1;
		} else if(!strcmp((char*)Buf, "secpath-drop")) {
			pTpe-&gt;data.field.options.bSecPathDrop = 1;
		} else if(!strcmp((char*)Buf, "secpath-replace")) {
			pTpe-&gt;data.field.options.bSecPathReplace = 1;
		} else if(!strcmp((char*)Buf, "pos-end-relative")) {
			pTpe-&gt;data.field.options.bFromPosEndRelative = 1;
		} else if(!strcmp((char*)Buf, "fixed-width")) {
			pTpe-&gt;data.field.options.bFixedWidth = 1;
		} else if(!strcmp((char*)Buf, "csv")) {
			if(hasFormat(pTpe)) {
				LogError(0, NO_ERRCODE, "error: can only specify "
					"one option out of (json, jsonf, jsonr, jsonfr, csv) - csv ignored");
			} else {
				pTpe-&gt;data.field.options.bCSV = 1;
			}
		} else if(!strcmp((char*)Buf, "json")) {
			if(hasFormat(pTpe)) {
				LogError(0, NO_ERRCODE, "error: can only specify "
					"one option out of (json, jsonf, jsonr, jsonfr, csv) - json ignored");
			} else {
				pTpe-&gt;data.field.options.bJSON = 1;
			}
		} else if(!strcmp((char*)Buf, "jsonf")) {
			if(hasFormat(pTpe)) {
				LogError(0, NO_ERRCODE, "error: can only specify "
					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonf ignored");
			} else {
				pTpe-&gt;data.field.options.bJSONf = 1;
			}
		} else if(!strcmp((char*)Buf, "jsonr")) {
			if(hasFormat(pTpe)) {
				LogError(0, NO_ERRCODE, "error: can only specify "
					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonr ignored");
			} else {
				pTpe-&gt;data.field.options.bJSONr = 1;
			}
		} else if(!strcmp((char*)Buf, "jsonfr")) {
			if(hasFormat(pTpe)) {
				LogError(0, NO_ERRCODE, "error: can only specify "
					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonfr ignored");
			} else {
				pTpe-&gt;data.field.options.bJSONfr = 1;
			}
		} else if(!strcmp((char*)Buf, "mandatory-field")) {
			 pTpe-&gt;data.field.options.bMandatory = 1;
		} else {
			LogError(0, NO_ERRCODE, "template error: invalid field option '%s' "
				"specified - ignored", Buf);
		 }
	}
	*pp = p;
}
static rsRetVal
do_Parameter(uchar **pp, struct template *pTpl)
{
	uchar *p;
	cstr_t *pStrProp = NULL;
	cstr_t *pStrField = NULL;
	struct templateEntry *pTpe;
	int iNum;	#ifdef FEATURE_REGEXP
	rsRetVal iRetLocal;
	int longitud;
	unsigned char *regex_char;
	unsigned char *regex_end;
#endif
	DEFiRet;
	assert(pp != NULL);
	assert(*pp != NULL);
	assert(pTpl != NULL);
	p = (uchar*) *pp;
	CHKiRet(cstrConstruct(&amp;pStrProp));
	CHKmalloc(pTpe = tpeConstruct(pTpl));
	pTpe-&gt;eEntryType = FIELD;
	while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
		cstrAppendChar(pStrProp, *p);
		++p;
	}
	cstrFinalize(pStrProp);
	CHKiRet(msgPropDescrFill(&amp;pTpe-&gt;data.field.msgProp, cstrGetSzStrNoNULL(pStrProp),
		cstrLen(pStrProp)));
	if(*p == ':') {
		pTpe-&gt;bComplexProcessing = 1;
		++p; #ifdef FEATURE_REGEXP
		if(*p == 'R') {
			++p;	
			if(*p == ',') {
				++p; 				if(p[0] == 'B' &amp;&amp; p[1] == 'R' &amp;&amp; p[2] == 'E' &amp;&amp; (p[3] == ',' || p[3] == ':')) {
					pTpe-&gt;data.field.typeRegex = TPL_REGEX_BRE;
					p += 3; 				} else if(p[0] == 'E' &amp;&amp; p[1] == 'R' &amp;&amp; p[2] == 'E' &amp;&amp; (p[3] == ',' || p[3] == ':')) {
					pTpe-&gt;data.field.typeRegex = TPL_REGEX_ERE;
					p += 3; 				} else {
					LogError(0, NO_ERRCODE, "error: invalid regular expression "
							"type, rest of line %s", (char*) p);
				}
			}
			pTpe-&gt;data.field.iSubMatchToUse = 0;
			if(*p == ',') {
				++p; 				if(isdigit((int) *p)) {
					pTpe-&gt;data.field.iSubMatchToUse = *p - '0';
					++p; 				}
			}
			if(*p == ',') {
				++p; 				if(p[0] == 'D' &amp;&amp; p[1] == 'F' &amp;&amp; p[2] == 'L' &amp;&amp; p[3] == 'T'
				   &amp;&amp; (p[4] == ',' || p[4] == ':')) {
					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_DFLTSTR;
					p += 4; 				} else if(p[0] == 'B' &amp;&amp; p[1] == 'L' &amp;&amp; p[2] == 'A' &amp;&amp; p[3] == 'N' &amp;&amp; p[4] == 'K'
				          &amp;&amp; (p[5] == ',' || p[5] == ':')) {
					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_BLANK;
					p += 5; 				} else if(p[0] == 'F' &amp;&amp; p[1] == 'I' &amp;&amp; p[2] == 'E' &amp;&amp; p[3] == 'L' &amp;&amp; p[4] == 'D'
				          &amp;&amp; (p[5] == ',' || p[5] == ':')) {
					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_WHOLE_FIELD;
					p += 5; 				} else if(p[0] == 'Z' &amp;&amp; p[1] == 'E' &amp;&amp; p[2] == 'R' &amp;&amp; p[3] == 'O'
				          &amp;&amp; (p[4] == ',' || p[4] == ':')) {
					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_ZERO;
					p += 4; 				} else if(p[0] == ',') { 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_DFLTSTR;
				} else {
					LogError(0, NO_ERRCODE, "template %s error: invalid regular "
						"expression type, rest of line %s",
						pTpl-&gt;pszName, (char*) p);
				}
			}
			pTpe-&gt;data.field.iMatchToUse = 0;
			if(*p == ',') {
				++p; 				if(isdigit((int) *p)) {
					pTpe-&gt;data.field.iMatchToUse = *p - '0';
					++p; 				}
			}
			if(*p != ':') {
				LogError(0, NO_ERRCODE, "error: invalid character in frompos "
						"after \"R\", property: '%%%s'", (char*) *pp);
			} else {
				pTpe-&gt;data.field.has_regex = 1;
				dbgprintf("we have a regexp and use match #%d, submatch #%d\n",
					  pTpe-&gt;data.field.iMatchToUse, pTpe-&gt;data.field.iSubMatchToUse);
			}
		} else {
#endif 			if(*p == 'F') {
#ifdef STRICT_GPLV3
				pTpe-&gt;data.field.field_expand = 0;
#endif
				++p; 				if (*p == ':') {
					pTpe-&gt;data.field.has_fields = 1;
					pTpe-&gt;data.field.field_delim = 9;
				} else if (*p == ',') {
					pTpe-&gt;data.field.has_fields = 1;
					if(!isdigit((int)*p)) {
						LogError(0, NO_ERRCODE, "error: invalid character in "
"frompos after \"F,\", property: '%%%s' - using 9 (HT) as field delimiter",
						    (char*) *pp);
						pTpe-&gt;data.field.field_delim = 9;
					} else {
						iNum = 0;
						while(isdigit((int)*p))
							iNum = iNum * 10 + *p++ - '0';
						if(iNum &lt; 0 || iNum &gt; 255) {
							LogError(0, NO_ERRCODE, "error: non-USASCII delimiter "
"character value %d in template - using 9 (HT) as substitute", iNum);
							pTpe-&gt;data.field.field_delim = 9;
						} else {
							pTpe-&gt;data.field.field_delim = iNum;
#							ifdef STRICT_GPLV3
							if (*p == '+') {
								pTpe-&gt;data.field.field_expand = 1;
								p ++;
							}
#							endif
							if(*p == ',') { 								++p;
								iNum = 0;
								while(isdigit((int)*p))
									iNum = iNum * 10 + *p++ - '0';
								pTpe-&gt;data.field.iFromPos = iNum;
							} else if(*p != ':') {
								parser_errmsg("error: invalid character "
								"'%c' in frompos after \"F,\", property: '%s' "
								"be sure to use DECIMAL character "
								"codes!", *p, (char*) *pp);
								ABORT_FINALIZE(RS_RET_SYNTAX_ERROR);
							}
						}
					}
				} else {
					LogError(0, NO_ERRCODE, "error: invalid character in frompos "
						"after \"F\", property: '%%%s'", (char*) *pp);
				}
			} else {
				iNum = 0;
				while(isdigit((int)*p))
					iNum = iNum * 10 + *p++ - '0';
				pTpe-&gt;data.field.iFromPos = iNum;
				while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
					dbgprintf("error: extra character in frompos: '%s'\n", p);
					++p;
				}
			}
#ifdef FEATURE_REGEXP
		}
#endif 	}
	if(*p == ':') {
		++p; 
#ifdef FEATURE_REGEXP
		if (pTpe-&gt;data.field.has_regex) {
			dbgprintf("debug: has regex \n");
			regex_end = (unsigned char*) strstr((char*)p, "--end");
			if (regex_end == NULL) {
				dbgprintf("error: can not find regex end in: '%s'\n", p);
				pTpe-&gt;data.field.has_regex = 0;
			} else {
				longitud = regex_end - p;
				regex_char = (unsigned char *) malloc(longitud + 1);
				if(regex_char == NULL) {
					dbgprintf("Could not allocate memory for template parameter!\n");
					pTpe-&gt;data.field.has_regex = 0;
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
				memcpy(regex_char, p, longitud);
				regex_char[longitud] = '\0';
				dbgprintf("debug: regex detected: '%s'\n", regex_char);
				if((iRetLocal = objUse(regexp, LM_REGEXP_FILENAME)) == RS_RET_OK) {
					int iOptions;
					iOptions = (pTpe-&gt;data.field.typeRegex == TPL_REGEX_ERE) ? REG_EXTENDED : 0;
					int errcode;
					if((errcode = regexp.regcomp(&amp;(pTpe-&gt;data.field.re),
						(char*) regex_char, iOptions) != 0)) {
						char errbuff[512];
						regexp.regerror(errcode, &amp;(pTpe-&gt;data.field.re),
							errbuff, sizeof(errbuff));
						DBGPRINTF("Template.c: Error in regular expression: %s\n", errbuff);
						pTpe-&gt;data.field.has_regex = 2;
					}
				} else {
					dbgprintf("error %d trying to load regexp library - this may be desired "
					"and thus OK", iRetLocal);
					if(bFirstRegexpErrmsg) {
						bFirstRegexpErrmsg = 0;
						LogError(0, NO_ERRCODE, "regexp library could not be loaded "
							"(error %d), regexp ignored", iRetLocal);
					}
					pTpe-&gt;data.field.has_regex = 2;
				}
				free(regex_char);
			}
		} else if(*p == '$') {
			pTpe-&gt;data.field.iToPos = 9999999;
		} else {
#endif 
			if(pTpe-&gt;data.field.has_fields == 1) {
				iNum = 0;
				while(isdigit((int)*p))
					iNum = iNum * 10 + *p++ - '0';
				pTpe-&gt;data.field.iFieldNr = iNum;
				if(*p == ',') { 					++p;
					iNum = 0;
					while(isdigit((int)*p))
						iNum = iNum * 10 + *p++ - '0';
					pTpe-&gt;data.field.iToPos = iNum;
				}
			} else {
				iNum = 0;
				while(isdigit((int)*p))
					iNum = iNum * 10 + *p++ - '0';
				pTpe-&gt;data.field.iToPos = iNum;
			}
			while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
				dbgprintf("error: extra character in frompos: '%s'\n", p);
				++p;
			}
#ifdef FEATURE_REGEXP
		}
#endif 	}
	if(*p == ':') {
		++p; 		doOptions(&amp;p, pTpe);
	}
	if(pTpe-&gt;data.field.options.bFromPosEndRelative) {
		if(pTpe-&gt;data.field.iToPos &gt; pTpe-&gt;data.field.iFromPos) {
			iNum = pTpe-&gt;data.field.iToPos;
			pTpe-&gt;data.field.iToPos = pTpe-&gt;data.field.iFromPos;
			pTpe-&gt;data.field.iFromPos = iNum;
		}
	} else {
		if(pTpe-&gt;data.field.iToPos &lt; pTpe-&gt;data.field.iFromPos) {
			iNum = pTpe-&gt;data.field.iToPos;
			pTpe-&gt;data.field.iToPos = pTpe-&gt;data.field.iFromPos;
			pTpe-&gt;data.field.iFromPos = iNum;
		}
	}
	if(*p == ':') {
		++p; 		CHKiRet(cstrConstruct(&amp;pStrField));
		while(*p != ':' &amp;&amp; *p != '%' &amp;&amp; *p != '\0') {
			cstrAppendChar(pStrField, *p);
			++p;
		}
		cstrFinalize(pStrField);
	}
	if(pStrField == NULL) {
		if(pTpe-&gt;data.field.msgProp.id == PROP_CEE || pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR) {
			pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrProp)+2);
			pTpe-&gt;lenFieldName = cstrLen(pStrProp)-2;
		} else {
			pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrProp));
			pTpe-&gt;lenFieldName = cstrLen(pStrProp);
		}
	} else {
		pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrField));
		pTpe-&gt;lenFieldName = ustrlen(pTpe-&gt;fieldName);
		cstrDestruct(&amp;pStrField);
	}
	if(pTpe-&gt;fieldName == NULL) {
		DBGPRINTF("template/do_Parameter: fieldName is NULL!\n");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	if(*p) ++p; 	*pp = p;
finalize_it:
	if(pStrProp != NULL)
		cstrDestruct(&amp;pStrProp);
	RETiRet;
}
static rsRetVal
tplAddTplMod(struct template *pTpl, uchar** ppRestOfConfLine)
{
	uchar *pSrc;
	uchar szMod[2048];
	unsigned lenMod;
	strgen_t *pStrgen;
	DEFiRet;
	pSrc = *ppRestOfConfLine;
	lenMod = 0;
	while(*pSrc &amp;&amp; !isspace(*pSrc) &amp;&amp; lenMod &lt; sizeof(szMod) - 1) {
		szMod[lenMod] = *pSrc++;
		lenMod++;
	}
	szMod[lenMod] = '\0';
	*ppRestOfConfLine = pSrc;
	CHKiRet(strgen.FindStrgen(&amp;pStrgen, szMod));
	pTpl-&gt;pStrgen = pStrgen-&gt;pModule-&gt;mod.sm.strgen;
	DBGPRINTF("template bound to strgen '%s'\n", szMod);
	if(lenMod &gt; 6 &amp;&amp; !strcasecmp((char*) szMod + lenMod - 7, ",stdsql")) {
		pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
		DBGPRINTF("strgen supports the stdsql option\n");
	} else if(lenMod &gt; 3 &amp;&amp; !strcasecmp((char*) szMod+ lenMod - 4, ",sql")) {
		pTpl-&gt;optFormatEscape = SQL_ESCAPE;
		DBGPRINTF("strgen supports the sql option\n");
	} else if(lenMod &gt; 4 &amp;&amp; !strcasecmp((char*) szMod+ lenMod - 4, ",json")) {
		pTpl-&gt;optFormatEscape = JSON_ESCAPE;
		DBGPRINTF("strgen supports the json option\n");
	}
finalize_it:
	RETiRet;
}
struct template *tplAddLine(rsconf_t *conf, const char* pName, uchar** ppRestOfConfLine)
{
	struct template *pTpl;
	unsigned char *p;
	int bDone;
	size_t i;
	rsRetVal localRet;
	assert(pName != NULL);
	assert(ppRestOfConfLine != NULL);
	if((pTpl = tplConstruct(conf)) == NULL)
		return NULL;
	DBGPRINTF("tplAddLine processing template '%s'\n", pName);
	pTpl-&gt;iLenName = strlen(pName);
	pTpl-&gt;pszName = (char*) malloc(pTpl-&gt;iLenName + 1);
	if(pTpl-&gt;pszName == NULL) {
		dbgprintf("tplAddLine could not alloc memory for template name!");
		pTpl-&gt;iLenName = 0;
		return NULL;
	}
	memcpy(pTpl-&gt;pszName, pName, pTpl-&gt;iLenName + 1);
	p = *ppRestOfConfLine;
	assert(p != NULL);
	while(isspace((int)*p))		++p;
	switch(*p) {
	case '"': 		break;
	case '=':
		*ppRestOfConfLine = p + 1;
		localRet = tplAddTplMod(pTpl, ppRestOfConfLine);
		if(localRet != RS_RET_OK) {
			LogError(0, localRet, "Template '%s': error %d defining template via strgen module",
					pTpl-&gt;pszName, localRet);
			*pTpl-&gt;pszName = '\0';
		}
		return NULL;
	default:
		dbgprintf("Template '%s' invalid, does not start with '\"'!\n", pTpl-&gt;pszName);
		*pTpl-&gt;pszName = '\0';
		return NULL;
	}
	++p;
	bDone = *p ? 0 : 1;
	while(!bDone) {
		switch(*p) {
			case '\0':
				bDone = 1;
				break;
			case '%': 				++p; 				if(do_Parameter(&amp;p, pTpl) != RS_RET_OK) {
					dbgprintf("tplAddLine error: parameter invalid");
					return NULL;
				};
				break;
			default: 				do_Constant(&amp;p, pTpl, 1);
				break;
		}
		if(*p == '"') {			++p;				bDone = 1;
		}
	}
	while(*p) {
		while(isspace((int)*p))			++p;
		if(*p != ',')
			break;
		++p; 
		while(isspace((int)*p))			++p;
		char optBuf[128] = { '\0' }; 		i = 0;
		while((i &lt; (sizeof(optBuf) - 1))
		      &amp;&amp; *p &amp;&amp; *p != '=' &amp;&amp; *p !=',' &amp;&amp; *p != '\n') {
			optBuf[i++] = tolower((int)*p);
			++p;
		}
		optBuf[i] = '\0';
		if(*p == '\n')
			++p;
		if(!strcmp(optBuf, "stdsql")) {
			pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
		} else if(!strcmp(optBuf, "json")) {
			pTpl-&gt;optFormatEscape = JSON_ESCAPE;
		} else if(!strcmp(optBuf, "sql")) {
			pTpl-&gt;optFormatEscape = SQL_ESCAPE;
		} else if(!strcmp(optBuf, "nosql")) {
			pTpl-&gt;optFormatEscape = NO_ESCAPE;
		} else if(!strcmp(optBuf, "casesensitive")) {
			pTpl-&gt;optCaseSensitive = 1;
		} else {
			dbgprintf("Invalid option '%s' ignored.\n", optBuf);
		}
	}
	*ppRestOfConfLine = p;
	apply_case_sensitivity(pTpl);
	return(pTpl);
}
static rsRetVal
createConstantTpe(struct template *pTpl, struct cnfobj *o)
{
	struct templateEntry *pTpe;
	es_str_t *value = NULL; 	int i;
	int is_jsonf = 0;
	struct cnfparamvals *pvals = NULL;
	struct json_object *json = NULL;
	struct json_object *jval = NULL;
	uchar *outname = NULL;
	DEFiRet;
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblkConstant, NULL);
	if(pvals == NULL) {
		parser_errmsg("error processing template parameters");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	cnfparamsPrint(&amp;pblkConstant, pvals);
	for(i = 0 ; i &lt; pblkConstant.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblkConstant.descr[i].name, "value")) {
			value = pvals[i].val.d.estr;
		} else if(!strcmp(pblkConstant.descr[i].name, "outname")) {
			outname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblkConstant.descr[i].name, "format")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonf", sizeof("jsonf")-1)) {
				is_jsonf = 1;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid format type '%s' for constant",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR,
				"template:constantTpe: program error, non-handled "
				"param '%s'\n", pblkConstant.descr[i].name);
		}
	}
	if(is_jsonf &amp;&amp; outname == NULL) {
		parser_errmsg("constant set to format jsonf, but outname not specified - aborting");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	assert(value != NULL);
	CHKmalloc(pTpe = tpeConstruct(pTpl));
	es_unescapeStr(value);
	pTpe-&gt;eEntryType = CONSTANT;
	pTpe-&gt;fieldName = outname;
	if(outname != NULL)
		pTpe-&gt;lenFieldName = ustrlen(outname);
	if(is_jsonf) {
		CHKmalloc(json = json_object_new_object());
		const char *sz = es_str2cstr(value, NULL);
		CHKmalloc(sz);
		CHKmalloc(jval = json_object_new_string(sz));
		free((void*)sz);
		json_object_object_add(json, (char*)outname, jval);
		CHKmalloc(sz = json_object_get_string(json));
		const size_t len_json = strlen(sz) - 4;
		CHKmalloc(pTpe-&gt;data.constant.pConstant = (uchar*) strndup(sz+2, len_json));
		pTpe-&gt;data.constant.iLenConstant = ustrlen(pTpe-&gt;data.constant.pConstant);
		json_object_put(json);
	} else {
		pTpe-&gt;data.constant.iLenConstant = es_strlen(value);
		pTpe-&gt;data.constant.pConstant = (uchar*)es_str2cstr(value, NULL);
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;pblkConstant);
	RETiRet;
}
static rsRetVal
createPropertyTpe(struct template *pTpl, struct cnfobj *o)
{
	struct templateEntry *pTpe;
	uchar *name = NULL;
	uchar *outname = NULL;
	int i;
	int droplastlf = 0;
	int spifno1stsp = 0;
	int mandatory = 0;
	int frompos = -1;
	int topos = -1;
	int fieldnum = -1;
	int fielddelim = 9; 	int fixedwidth = 0;
	int re_matchToUse = 0;
	int re_submatchToUse = 0;
	int bComplexProcessing = 0;
	int bPosRelativeToEnd = 0;
	int bDateInUTC = 0;
	int bCompressSP = 0;
	unsigned dataType = TPE_DATATYPE_STRING;
	unsigned onEmpty = TPE_DATAEMPTY_KEEP;
	char *re_expr = NULL;
	struct cnfparamvals *pvals = NULL;
	enum {F_NONE, F_CSV, F_JSON, F_JSONF, F_JSONR, F_JSONFR} formatType = F_NONE;
	enum {CC_NONE, CC_ESCAPE, CC_SPACE, CC_DROP} controlchr = CC_NONE;
	enum {SP_NONE, SP_DROP, SP_REPLACE} secpath = SP_NONE;
	enum tplFormatCaseConvTypes caseconv = tplCaseConvNo;
	enum tplFormatTypes datefmt = tplFmtDefault;
	enum tplRegexType re_type = TPL_REGEX_BRE;
	enum tlpRegexNoMatchType re_nomatchType = TPL_REGEX_NOMATCH_USE_DFLTSTR;
	DEFiRet;
<a name="1"></a>
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblkProperty, NULL);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
		parser_errmsg("error processing template entry config parameters");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	cnfparamsPrint(&amp;pblkProperty, pvals);
	for(i = 0 ; i &lt; pblkProperty.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblkProperty.descr[i].name, "name")) {
			name = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblkProperty.descr[i].name, "datatype")) {</b></font>
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"string", sizeof("string")-1)) {
				dataType = TPE_DATATYPE_STRING;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"number", sizeof("number")-1)) {
				dataType = TPE_DATATYPE_NUMBER;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"bool", sizeof("bool")-1)) {
				dataType = TPE_DATATYPE_BOOL;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"auto", sizeof("auto")-1)) {
				dataType = TPE_DATATYPE_AUTO;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid dataType '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "onempty")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"keep", sizeof("keep")-1)) {
				onEmpty = TPE_DATAEMPTY_KEEP;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"skip", sizeof("skip")-1)) {
				onEmpty = TPE_DATAEMPTY_SKIP;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"null", sizeof("null")-1)) {
				onEmpty = TPE_DATAEMPTY_NULL;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid onEmpty value '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "droplastlf")) {
			droplastlf = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "fixedwidth")) {
			fixedwidth = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "mandatory")) {
			mandatory = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "spifno1stsp")) {
			spifno1stsp = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "outname")) {
			outname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblkProperty.descr[i].name, "position.from")) {
			frompos = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "position.to")) {
			topos = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "position.relativetoend")) {
			bPosRelativeToEnd = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "field.number")) {
			fieldnum = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "field.delimiter")) {
			fielddelim = pvals[i].val.d.n;
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "regex.expression")) {
			re_expr = es_str2cstr(pvals[i].val.d.estr, NULL);
			bComplexProcessing = 1;
		} else if(!strcmp(pblkProperty.descr[i].name, "regex.type")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"BRE", sizeof("BRE")-1)) {
				re_type = TPL_REGEX_BRE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ERE", sizeof("ERE")-1)) {
				re_type = TPL_REGEX_ERE;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid regex.type '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "regex.nomatchmode")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"DFLT", sizeof("DFLT")-1)) {
				re_nomatchType = TPL_REGEX_NOMATCH_USE_DFLTSTR;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"BLANK", sizeof("BLANK")-1)) {
				re_nomatchType = TPL_REGEX_NOMATCH_USE_BLANK;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"FIELD", sizeof("FIELD")-1)) {
				re_nomatchType = TPL_REGEX_NOMATCH_USE_WHOLE_FIELD;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ZERO", sizeof("ZERO")-1)) {
				re_nomatchType = TPL_REGEX_NOMATCH_USE_ZERO;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid format type '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "regex.match")) {
			bComplexProcessing = 1;
			re_matchToUse = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "regex.submatch")) {
			bComplexProcessing = 1;
			re_submatchToUse = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "format")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"csv", sizeof("csv")-1)) {
				formatType = F_CSV;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"json", sizeof("json")-1)) {
				formatType = F_JSON;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonf", sizeof("jsonf")-1)) {
				formatType = F_JSONF;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonr", sizeof("jsonr")-1)) {
				formatType = F_JSONR;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonfr", sizeof("jsonfr")-1)) {
				formatType = F_JSONFR;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid format type '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "controlcharacters")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"escape", sizeof("escape")-1)) {
				controlchr = CC_ESCAPE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"space", sizeof("space")-1)) {
				controlchr = CC_SPACE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"drop", sizeof("drop")-1)) {
				controlchr = CC_DROP;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid controlcharacter mode '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "securepath")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"drop", sizeof("drop")-1)) {
				secpath = SP_DROP;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"replace", sizeof("replace")-1)) {
				secpath = SP_REPLACE;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid securepath mode '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "caseconversion")) {
			bComplexProcessing = 1;
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"lower", sizeof("lower")-1)) {
				caseconv = tplCaseConvLower;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"upper", sizeof("upper")-1)) {
				caseconv = tplCaseConvUpper;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid caseconversion type '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblkProperty.descr[i].name, "compressspace")) {
			bComplexProcessing = 1;
			bCompressSP = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "date.inutc")) {
			bDateInUTC = pvals[i].val.d.n;
		} else if(!strcmp(pblkProperty.descr[i].name, "dateformat")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"mysql", sizeof("mysql")-1)) {
				datefmt = tplFmtMySQLDate;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"pgsql", sizeof("pgsql")-1)) {
				datefmt = tplFmtPgSQLDate;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3164", sizeof("rfc3164")-1)) {
				datefmt = tplFmtRFC3164Date;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3164-buggyday",
				sizeof("rfc3164-buggyday")-1)) {
				datefmt = tplFmtRFC3164BuggyDate;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3339", sizeof("rfc3339")-1)) {
				datefmt = tplFmtRFC3339Date;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"unixtimestamp",
				sizeof("unixtimestamp")-1)) {
				datefmt = tplFmtUnixDate;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"subseconds", sizeof("subseconds")-1)) {
				datefmt = tplFmtSecFrac;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"wdayname", sizeof("wdayname")-1)) {
				datefmt = tplFmtWDayName;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"wday", sizeof("wday")-1)) {
				datefmt = tplFmtWDay;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"year", sizeof("year")-1)) {
				datefmt = tplFmtYear;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"month", sizeof("month")-1)) {
				datefmt = tplFmtMonth;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"day", sizeof("day")-1)) {
				datefmt = tplFmtDay;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"hour", sizeof("hour")-1)) {
				datefmt = tplFmtHour;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"minute", sizeof("minute")-1)) {
				datefmt = tplFmtMinute;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"second", sizeof("second")-1)) {
				datefmt = tplFmtSecond;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffshour", sizeof("tzoffshour")-1)) {
				datefmt = tplFmtTZOffsHour;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffsmin", sizeof("tzoffsmin")-1)) {
				datefmt = tplFmtTZOffsMin;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffsdirection",
				sizeof("tzoffsdirection")-1)) {
				datefmt = tplFmtTZOffsDirection;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ordinal", sizeof("ordinal")-1)) {
				datefmt = tplFmtOrdinal;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"week", sizeof("week")-1)) {
				datefmt = tplFmtWeek;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid date format '%s' for property",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else {
			dbgprintf("template:propertyTpe: program error, non-handled "
			  "param '%s'\n", pblkProperty.descr[i].name);
		}
	}
	if (name == NULL) {
		CHKmalloc(name = (uchar*)strdup(""));
	}
	if(outname == NULL) {
		if(ustrlen(name) &gt;= 2 &amp;&amp; !strncmp((char*)name, "$!", 2))
			outname = ustrdup(name + 2);
		else
			outname = ustrdup(name);
	}
	if(topos == -1 &amp;&amp; frompos != -1)
		topos = 2000000000; 	if(frompos == -1 &amp;&amp; topos != -1)
		frompos = 0;
	if(bPosRelativeToEnd) {
		if(topos &gt; frompos) {
			LogError(0, RS_RET_ERR, "position.to=%d is higher than postion.from=%d "
					"in 'relativeToEnd' mode\n", topos, frompos);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	} else {
		if(topos &lt; frompos) {
			LogError(0, RS_RET_ERR, "position.to=%d is lower than postion.from=%d\n",
				topos, frompos);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(fieldnum != -1 &amp;&amp; re_expr != NULL) {
		LogError(0, RS_RET_ERR, "both field extraction and regex extraction "
				"specified - this is not possible, remove one");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	CHKmalloc(pTpe = tpeConstruct(pTpl));
	pTpe-&gt;eEntryType = FIELD;
	CHKiRet(msgPropDescrFill(&amp;pTpe-&gt;data.field.msgProp, name, strlen((char*)name)));
	pTpe-&gt;data.field.options.bDropLastLF = droplastlf;
	pTpe-&gt;data.field.options.bSPIffNo1stSP = spifno1stsp;
	pTpe-&gt;data.field.options.bMandatory = mandatory;
	pTpe-&gt;data.field.options.bFixedWidth = fixedwidth;
	pTpe-&gt;data.field.options.dataType = dataType;
	pTpe-&gt;data.field.options.onEmpty = onEmpty;
	pTpe-&gt;data.field.eCaseConv = caseconv;
	switch(formatType) {
	case F_NONE:
		break;
	case F_CSV:
		pTpe-&gt;data.field.options.bCSV = 1;
		break;
	case F_JSON:
		pTpe-&gt;data.field.options.bJSON = 1;
		break;
	case F_JSONF:
		pTpe-&gt;data.field.options.bJSONf = 1;
		break;
	case F_JSONR:
		pTpe-&gt;data.field.options.bJSONr = 1;
		break;
	case F_JSONFR:
		pTpe-&gt;data.field.options.bJSONfr = 1;
		break;
	}
	switch(controlchr) {
	case CC_NONE:
		break;
	case CC_ESCAPE:
		pTpe-&gt;data.field.options.bEscapeCC = 1;
		break;
	case CC_SPACE:
		pTpe-&gt;data.field.options.bSpaceCC = 1;
		break;
	case CC_DROP:
		pTpe-&gt;data.field.options.bDropCC = 1;
		break;
	}
	switch(secpath) {
	case SP_NONE:
		break;
	case SP_DROP:
		pTpe-&gt;data.field.options.bSecPathDrop = 1;
		break;
	case SP_REPLACE:
		pTpe-&gt;data.field.options.bSecPathReplace = 1;
		break;
	}
	pTpe-&gt;fieldName = outname;
	if(outname != NULL)
		pTpe-&gt;lenFieldName = ustrlen(outname);
	outname = NULL;
	pTpe-&gt;bComplexProcessing = bComplexProcessing;
	pTpe-&gt;data.field.eDateFormat = datefmt;
	pTpe-&gt;data.field.options.bDateInUTC = bDateInUTC;
	pTpe-&gt;data.field.options.bCompressSP = bCompressSP;
	if(fieldnum != -1) {
		pTpe-&gt;data.field.has_fields = 1;
		pTpe-&gt;data.field.iFieldNr = fieldnum;
		pTpe-&gt;data.field.field_delim = fielddelim;
	}
	if(frompos != -1) {
		pTpe-&gt;data.field.iFromPos = frompos;
		pTpe-&gt;data.field.iToPos = topos;
		pTpe-&gt;data.field.options.bFromPosEndRelative = bPosRelativeToEnd;
	}
	if(re_expr != NULL) {
		rsRetVal iRetLocal;
		pTpe-&gt;data.field.typeRegex = re_type;
		pTpe-&gt;data.field.nomatchAction = re_nomatchType;
		pTpe-&gt;data.field.iMatchToUse = re_matchToUse;
		pTpe-&gt;data.field.iSubMatchToUse = re_submatchToUse;
		pTpe-&gt;data.field.has_regex = 1;
		if((iRetLocal = objUse(regexp, LM_REGEXP_FILENAME)) == RS_RET_OK) {
			int iOptions;
			iOptions = (pTpe-&gt;data.field.typeRegex == TPL_REGEX_ERE) ? REG_EXTENDED : 0;
			if(regexp.regcomp(&amp;(pTpe-&gt;data.field.re), (char*) re_expr, iOptions) != 0) {
				LogError(0, NO_ERRCODE, "error compiling regex '%s'", re_expr);
				pTpe-&gt;data.field.has_regex = 2;
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else {
			if(bFirstRegexpErrmsg) { 				bFirstRegexpErrmsg = 0;
				LogError(0, NO_ERRCODE, "regexp library could not be loaded (error %d), "
						"regexp ignored", iRetLocal);
			}
			pTpe-&gt;data.field.has_regex = 2;
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;pblkProperty);
	free(name);
	free(outname);
	RETiRet;
}
static rsRetVal
createListTpl(struct template *pTpl, struct cnfobj *o)
{
	struct objlst *lst;
	DEFiRet;
	dbgprintf("create template from subobjs\n");
	objlstPrint(o-&gt;subobjs);
	for(lst = o-&gt;subobjs ; lst != NULL ; lst = lst-&gt;next) {
		switch(lst-&gt;obj-&gt;objType) {
		case CNFOBJ_PROPERTY:
			CHKiRet(createPropertyTpe(pTpl, lst-&gt;obj));
			break;
		case CNFOBJ_CONSTANT:
			CHKiRet(createConstantTpe(pTpl, lst-&gt;obj));
			break;
		default:dbgprintf("program error: invalid object type %d "
				  "in createLstTpl\n", lst-&gt;obj-&gt;objType);
			break;
		}
		nvlstChkUnused(lst-&gt;obj-&gt;nvlst);
	}
finalize_it:
	RETiRet;
}
rsRetVal ATTR_NONNULL()
tplProcessCnf(struct cnfobj *o)
{
	struct template *pTpl = NULL;
	struct cnfparamvals *pvals = NULL;
	int lenName = 0; 	char *name = NULL;
	uchar *tplStr = NULL;
	uchar *plugin = NULL;
	uchar *p;
	msgPropDescr_t subtree;
	sbool bHaveSubtree = 0;
	enum { T_STRING, T_PLUGIN, T_LIST, T_SUBTREE }
		tplType = T_STRING; 	int i;
	int o_sql=0, o_stdsql=0, o_jsonf=0, o_json=0, o_casesensitive=0; 	int numopts;
	rsRetVal localRet;
	DEFiRet;
	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblk, NULL);
	if(pvals == NULL) {
		parser_errmsg("error processing template config parameters");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	cnfparamsPrint(&amp;pblk, pvals);
	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk.descr[i].name, "name")) {
			lenName = es_strlen(pvals[i].val.d.estr);
			name = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "type")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"string", sizeof("string")-1)) {
				tplType = T_STRING;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"plugin", sizeof("plugin")-1)) {
				tplType = T_PLUGIN;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"list", sizeof("list")-1)) {
				tplType = T_LIST;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"subtree", sizeof("subtree")-1)) {
				tplType = T_SUBTREE;
			} else {
				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid template type '%s'",
					typeStr);
				free(typeStr);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if(!strcmp(pblk.descr[i].name, "string")) {
			tplStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "subtree")) {
			uchar *st_str = es_getBufAddr(pvals[i].val.d.estr);
			if(st_str[0] != '$' || st_str[1] != '!') {
				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_ERR, "invalid subtree "
					"parameter, variable must start with '$!' but "
					"var name is '%s'", cstr);
				free(cstr);
				free(name); 				ABORT_FINALIZE(RS_RET_ERR);
			} else {
				uchar *cstr;
				cstr  = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
				CHKiRet(msgPropDescrFill(&amp;subtree, cstr, ustrlen(cstr)));
				free(cstr);
				bHaveSubtree = 1;
			}
		} else if(!strcmp(pblk.descr[i].name, "plugin")) {
			plugin = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, "option.stdsql")) {
			o_stdsql = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "option.sql")) {
			o_sql = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "option.json")) {
			o_json = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "option.jsonf")) {
<a name="2"></a>			o_jsonf = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, "option.casesensitive")) {
			o_casesensitive = pvals[i].val.d.n;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else {
			dbgprintf("template: program error, non-handled "
			  "param '%s'\n", pblk.descr[i].name);
		}
	}
	if(name == NULL) {
		DBGPRINTF("template/tplProcessConf: logic error name == NULL - pblk wrong?\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(tplStr  == NULL) {</b></font>
		if(tplType == T_STRING) {
			LogError(0, RS_RET_ERR, "template '%s' of type string needs "
				"string parameter", name);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	} else {
		if(tplType != T_STRING) {
			LogError(0, RS_RET_ERR, "template '%s' is not a string "
				"template but has a string specified - ignored", name);
		}
	}
	if(plugin  == NULL) {
		if(tplType == T_PLUGIN) {
			LogError(0, RS_RET_ERR, "template '%s' of type plugin needs "
				"plugin parameter", name);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	} else {
		if(tplType != T_PLUGIN) {
			LogError(0, RS_RET_ERR, "template '%s' is not a plugin "
				"template but has a plugin specified - ignored", name);
		}
	}
	if(!bHaveSubtree) {
		if(tplType == T_SUBTREE) {
			LogError(0, RS_RET_ERR, "template '%s' of type subtree needs "
				"subtree parameter", name);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	} else {
		if(tplType != T_SUBTREE) {
			LogError(0, RS_RET_ERR, "template '%s' is not a subtree "
				"template but has a subtree specified - ignored", name);
		}
	}
	if(o-&gt;subobjs  == NULL) {
		if(tplType == T_LIST) {
			LogError(0, RS_RET_ERR, "template '%s' of type list has "
				"no parameters specified", name);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	} else {
		if(tplType != T_LIST) {
			LogError(0, RS_RET_ERR, "template '%s' is not a list "
				"template but has parameters specified - ignored", name);
		}
	}
	numopts = 0;
	if(o_sql) ++numopts;
	if(o_stdsql) ++numopts;
	if(o_json) ++numopts;
	if(o_jsonf) ++numopts;
	if(numopts &gt; 1) {
		LogError(0, RS_RET_ERR, "template '%s' has multiple incompatible "
			"options of sql, stdsql or json specified", name);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if((pTpl = tplConstruct(loadConf)) == NULL) {
		DBGPRINTF("template.c: tplConstruct failed!\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pTpl-&gt;pszName = name;
	pTpl-&gt;iLenName = lenName;
	switch(tplType) {
	case T_STRING:	p = tplStr;
			while(*p) {
				switch(*p) {
					case '%': 						++p; 						CHKiRet(do_Parameter(&amp;p, pTpl));
						break;
					default: 						do_Constant(&amp;p, pTpl, 0);
						break;
				}
			}
			break;
	case T_PLUGIN:	p = plugin;
			localRet = tplAddTplMod(pTpl, &amp;p);
			if(localRet != RS_RET_OK) {
				LogError(0, localRet, "template '%s': error %d "
						"defining template via plugin (strgen) module",
						pTpl-&gt;pszName, localRet);
				ABORT_FINALIZE(localRet);
			}
			break;
	case T_LIST:	createListTpl(pTpl, o);
			break;
	case T_SUBTREE:	memcpy(&amp;pTpl-&gt;subtree, &amp;subtree, sizeof(msgPropDescr_t));
			pTpl-&gt;bHaveSubtree = 1;
			break;
	}
	pTpl-&gt;optFormatEscape = NO_ESCAPE;
	if(o_stdsql)
		pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
	else if(o_sql)
		pTpl-&gt;optFormatEscape = SQL_ESCAPE;
	else if(o_json)
		pTpl-&gt;optFormatEscape = JSON_ESCAPE;
	else if(o_jsonf)
		pTpl-&gt;optFormatEscape = JSONF;
	if(o_casesensitive)
		pTpl-&gt;optCaseSensitive = 1;
	apply_case_sensitivity(pTpl);
finalize_it:
	free(tplStr);
	free(plugin);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;pblk);
	if(iRet != RS_RET_OK) {
		if(pTpl != NULL) {
			*pTpl-&gt;pszName = '\0';
		}
	}
	RETiRet;
}
struct template *tplFind(rsconf_t *conf, char *pName, int iLenName)
{
	struct template *pTpl;
	assert(pName != NULL);
	pTpl = conf-&gt;templates.root;
	while(pTpl != NULL &amp;&amp;
	      !(pTpl-&gt;iLenName == iLenName &amp;&amp;
	        !strcmp(pTpl-&gt;pszName, pName)
	        ))
		{
			pTpl = pTpl-&gt;pNext;
		}
	return(pTpl);
}
void tplDeleteAll(rsconf_t *conf)
{
	struct template *pTpl, *pTplDel;
	struct templateEntry *pTpe, *pTpeDel;
	pTpl = conf-&gt;templates.root;
	while(pTpl != NULL) {
		pTpe = pTpl-&gt;pEntryRoot;
		while(pTpe != NULL) {
			pTpeDel = pTpe;
			pTpe = pTpe-&gt;pNext;
			switch(pTpeDel-&gt;eEntryType) {
			case UNDEFINED:
				break;
			case CONSTANT:
				free(pTpeDel-&gt;data.constant.pConstant);
				break;
			case FIELD:
#ifdef FEATURE_REGEXP
				if(pTpeDel-&gt;data.field.has_regex != 0) {
					if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
						regexp.regfree(&amp;(pTpeDel-&gt;data.field.re));
					}
				}
#endif
				msgPropDescrDestruct(&amp;pTpeDel-&gt;data.field.msgProp);
				break;
			}
			free(pTpeDel-&gt;fieldName);
			free(pTpeDel);
		}
		pTplDel = pTpl;
		pTpl = pTpl-&gt;pNext;
		free(pTplDel-&gt;pszName);
		if(pTplDel-&gt;bHaveSubtree)
			msgPropDescrDestruct(&amp;pTplDel-&gt;subtree);
		free(pTplDel);
	}
}
void tplDeleteNew(rsconf_t *conf)
{
	struct template *pTpl, *pTplDel;
	struct templateEntry *pTpe, *pTpeDel;
	if(conf-&gt;templates.root == NULL || conf-&gt;templates.lastStatic == NULL)
		return;
	pTpl = conf-&gt;templates.lastStatic-&gt;pNext;
	conf-&gt;templates.lastStatic-&gt;pNext = NULL;
	conf-&gt;templates.last = conf-&gt;templates.lastStatic;
	while(pTpl != NULL) {
		pTpe = pTpl-&gt;pEntryRoot;
		while(pTpe != NULL) {
			pTpeDel = pTpe;
			pTpe = pTpe-&gt;pNext;
			switch(pTpeDel-&gt;eEntryType) {
			case UNDEFINED:
				break;
			case CONSTANT:
				free(pTpeDel-&gt;data.constant.pConstant);
				break;
			case FIELD:
#ifdef FEATURE_REGEXP
				if(pTpeDel-&gt;data.field.has_regex != 0) {
					if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
						regexp.regfree(&amp;(pTpeDel-&gt;data.field.re));
					}
				}
#endif
				msgPropDescrDestruct(&amp;pTpeDel-&gt;data.field.msgProp);
				break;
			}
			free(pTpeDel);
		}
		pTplDel = pTpl;
		pTpl = pTpl-&gt;pNext;
		free(pTplDel-&gt;pszName);
		if(pTplDel-&gt;bHaveSubtree)
			msgPropDescrDestruct(&amp;pTplDel-&gt;subtree);
		free(pTplDel);
	}
}
void tplLastStaticInit(rsconf_t *conf, struct template *tpl)
{
	conf-&gt;templates.lastStatic = tpl;
}
void tplPrintList(rsconf_t *conf)
{
	struct template *pTpl;
	struct templateEntry *pTpe;
	pTpl = conf-&gt;templates.root;
	while(pTpl != NULL) {
		dbgprintf("Template: Name='%s' ", pTpl-&gt;pszName == NULL? "NULL" : pTpl-&gt;pszName);
		if(pTpl-&gt;optFormatEscape == SQL_ESCAPE)
			dbgprintf("[SQL-Format (MySQL)] ");
		else if(pTpl-&gt;optFormatEscape == JSON_ESCAPE)
			dbgprintf("[JSON-Escaped Format] ");
		else if(pTpl-&gt;optFormatEscape == STDSQL_ESCAPE)
			dbgprintf("[SQL-Format (standard SQL)] ");
		else if(pTpl-&gt;optFormatEscape == JSONF)
			dbgprintf("[JSON fields] ");
		if(pTpl-&gt;optCaseSensitive)
			dbgprintf("[Case Sensitive Vars] ");
		dbgprintf("\n");
		pTpe = pTpl-&gt;pEntryRoot;
		while(pTpe != NULL) {
			dbgprintf("\tEntry(%lx): type %d, ", (unsigned long) pTpe, pTpe-&gt;eEntryType);
			switch(pTpe-&gt;eEntryType) {
			case UNDEFINED:
				dbgprintf("(UNDEFINED)");
				break;
			case CONSTANT:
				dbgprintf("(CONSTANT), value: '%s'",
					pTpe-&gt;data.constant.pConstant);
				break;
			case FIELD:
				dbgprintf("(FIELD), value: '%d' ", pTpe-&gt;data.field.msgProp.id);
				if(pTpe-&gt;data.field.msgProp.id == PROP_CEE) {
					dbgprintf("[EE-Property: '%s'] ", pTpe-&gt;data.field.msgProp.name);
				} else if(pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR) {
					dbgprintf("[Local Var: '%s'] ", pTpe-&gt;data.field.msgProp.name);
				}
				switch(pTpe-&gt;data.field.eDateFormat) {
				case tplFmtDefault:
					break;
				case tplFmtMySQLDate:
					dbgprintf("[Format as MySQL-Date] ");
					break;
				case tplFmtPgSQLDate:
					dbgprintf("[Format as PgSQL-Date] ");
					break;
				case tplFmtRFC3164Date:
					dbgprintf("[Format as RFC3164-Date] ");
					break;
				case tplFmtRFC3339Date:
					dbgprintf("[Format as RFC3339-Date] ");
					break;
				case tplFmtUnixDate:
					dbgprintf("[Format as Unix timestamp] ");
					break;
				case tplFmtSecFrac:
					dbgprintf("[fractional seconds, only] ");
					break;
				case tplFmtRFC3164BuggyDate:
					dbgprintf("[Format as buggy RFC3164-Date] ");
					break;
				case tplFmtWDayName:
					dbgprintf("[Format as weekday name] ");
					break;
				case tplFmtYear:
					dbgprintf("[Format as year] ");
					break;
				case tplFmtMonth:
					dbgprintf("[Format as month] ");
					break;
				case tplFmtDay:
					dbgprintf("[Format as day] ");
					break;
				case tplFmtHour:
					dbgprintf("[Format as hour] ");
					break;
				case tplFmtMinute:
					dbgprintf("[Format as minute] ");
					break;
				case tplFmtSecond:
					dbgprintf("[Format as second] ");
					break;
				case tplFmtTZOffsHour:
					dbgprintf("[Format as offset hour] ");
					break;
				case tplFmtTZOffsMin:
					dbgprintf("[Format as offset minute] ");
					break;
				case tplFmtTZOffsDirection:
					dbgprintf("[Format as offset direction] ");
					break;
				case tplFmtWDay:
					dbgprintf("[Format as weekday] ");
					break;
				case tplFmtOrdinal:
					dbgprintf("[Format as ordinal] ");
					break;
				case tplFmtWeek:
					dbgprintf("[Format as week] ");
					break;
				default:
					dbgprintf("[UNKNOWN eDateFormat %d] ", pTpe-&gt;data.field.eDateFormat);
				}
				switch(pTpe-&gt;data.field.eCaseConv) {
				case tplCaseConvNo:
					break;
				case tplCaseConvLower:
					dbgprintf("[Converted to Lower Case] ");
					break;
				case tplCaseConvUpper:
					dbgprintf("[Converted to Upper Case] ");
					break;
				}
				if(pTpe-&gt;data.field.options.bEscapeCC) {
				  	dbgprintf("[escape control-characters] ");
				}
				if(pTpe-&gt;data.field.options.bDropCC) {
				  	dbgprintf("[drop control-characters] ");
				}
				if(pTpe-&gt;data.field.options.bSpaceCC) {
				  	dbgprintf("[replace control-characters with space] ");
				}
				if(pTpe-&gt;data.field.options.bSecPathDrop) {
				  	dbgprintf("[slashes are dropped] ");
				}
				if(pTpe-&gt;data.field.options.bSecPathReplace) {
				  	dbgprintf("[slashes are replaced by '_'] ");
				}
				if(pTpe-&gt;data.field.options.bSPIffNo1stSP) {
				  	dbgprintf("[SP iff no first SP] ");
				}
				if(pTpe-&gt;data.field.options.bCSV) {
				  	dbgprintf("[format as CSV (RFC4180)]");
				}
				if(pTpe-&gt;data.field.options.bJSON) {
					dbgprintf("[format as JSON] ");
				}
				if(pTpe-&gt;data.field.options.bJSONf) {
					dbgprintf("[format as JSON field] ");
				}
				if(pTpe-&gt;data.field.options.bJSONr) {
					dbgprintf("[format as JSON without re-escaping] ");
				}
				if(pTpe-&gt;data.field.options.bJSONfr) {
					dbgprintf("[format as JSON field without re-escaping] ");
				}
				if(pTpe-&gt;data.field.options.bMandatory) {
					dbgprintf("[mandatory field] ");
				}
				if(pTpe-&gt;data.field.options.bDropLastLF) {
				  	dbgprintf("[drop last LF in msg] ");
				}
				if(pTpe-&gt;data.field.has_fields == 1) {
				  	dbgprintf("[substring, field #%d only (delimiter %d)] ",
						pTpe-&gt;data.field.iFieldNr, pTpe-&gt;data.field.field_delim);
				}
				if(pTpe-&gt;data.field.iFromPos != 0 || pTpe-&gt;data.field.iToPos != 0) {
				  	dbgprintf("[substring, from character %d to %d] ",
						pTpe-&gt;data.field.iFromPos,
						pTpe-&gt;data.field.iToPos);
				}
				break;
			}
			if(pTpe-&gt;bComplexProcessing)
				dbgprintf("[COMPLEX]");
			dbgprintf("\n");
			pTpe = pTpe-&gt;pNext;
		}
		pTpl = pTpl-&gt;pNext; 	}
}
int tplGetEntryCount(struct template *pTpl)
{
	assert(pTpl != NULL);
	return(pTpl-&gt;tpenElements);
}
rsRetVal templateInit(void)
{
	DEFiRet;
	CHKiRet(objGetObjInterface(&amp;obj));
	CHKiRet(objUse(strgen, CORE_COMPONENT));
finalize_it:
	RETiRet;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
