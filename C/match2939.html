<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttpfs.c &amp; template.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttpfs.c &amp; template.c
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttpfs.c (12.529551%)<th>template.c (1.9717262%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(130-151)<td><a href="#" name="0">(61-75)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(743-755)<td><a href="#" name="1">(1489-1500)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(771-784)<td><a href="#" name="2">(1970-1986)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttpfs.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;curl/curl.h&gt;
12 #include &lt;json.h&gt;
13 #include &lt;json_object.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "srUtils.h"
17 #include "template.h"
18 #include "module-template.h"
19 #include "errmsg.h"
20 #include "cfsysline.h"
21 #include "datetime.h"
22 #include "statsobj.h"
23 #include "unicode-helper.h"
24 MODULE_TYPE_OUTPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("omhttpfs")
27 DEF_OMOD_STATIC_DATA
28 DEFobjCurrIf(glbl)
29 DEFobjCurrIf(datetime)
30 #define OMHTTPFS_VERSION "1.0"
31 #define OMHTTPFS_DEFAULT_PORT 14000
32 #define OMHTTPFS_DEFAULT_USER "hdfs"
33 #define OMHTTPFS_DEFAULT_HOST "127.0.0.1"
34 #define HTTPFS_URL_PREFIX_V1     "/webhdfs/v1"
35 #define HTTPFS_URL_PREFIX_V1_SSL "/swebhdfs/v1"
36 #define HTTPFS_CONTENT_TYPE      "Content-Type: application/octet-stream"
37 #define HTTPFS_USER_AGENT        "omhttpfs by sskaje/" OMHTTPFS_VERSION
38 #define HTTPFS_CONTENT_TYPE_JSON "application/json"
39 #define HTTPFS_JSON_BOOLEAN_TRUE "{\"boolean\":true}"
40 #define HTTPFS_FILEALREADYEXISTSEXCEPTION "FileAlreadyExistsException"
41 #define HTTPFS_URL_BUFFER_LENGTH 2048
42 #define DPP(x) DBGPRINTF("OMHTTPFS: %s:%d %s(): %s\n", __FILE__, __LINE__, __FUNCTION__, x)
43 typedef struct _HTTPFS_JSON_REMOTE_EXCEPTION {
44 	char message[1024];
45 	char exception[256];
46 	char class[256];
47 } httpfs_json_remote_exception;
48 typedef struct _instanceData {
49 	sbool https;
50 	uchar* host;
51 	uchar* ip;
52 	int  port;
53 	uchar* user;
54 	int timeout;
55 	uchar* file;
56 	sbool isDynFile;
57 	uchar* tplName;
58 } instanceData;
59 typedef struct wrkrInstanceData {
60 	instanceData *pData;
61 	CURL* curl;
62 	uchar* file;
63 	int replyLen;
64 	char* reply;
65 } wrkrInstanceData_t;
66 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
67 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "host", eCmdHdlrGetWord, 0 },
68 	{ "port", eCmdHdlrInt, 0 },
69 	{ "user", eCmdHdlrGetWord, 0 },
70 	{ "https", eCmdHdlrBinary, 0 },
71 	{ "file", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
72 	{ "isdynfile", eCmdHdlrBinary, 0 },
73 	{ "template", eCmdHdlrGetWord, 0 },
74 };
75 static struct cnfparamblk actpblk = {
76 	CNFPARAMBLK_VERSION,
77 	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
78 	actpdescr
79 };
80 static rsRetVal</b></font>
81 httpfs_init_curl(wrkrInstanceData_t *pWrkrData, instanceData *pData)
82 {
83 	CURL *curl = NULL;
84 	curl = curl_easy_init();
85 	if (curl) {
86 		curl_easy_setopt(curl, CURLOPT_VERBOSE, 0L);
87 		curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
88 		if (pData-&gt;https) {
89 			DBGPRINTF("%s(): Enable HTTPS\n", __FUNCTION__);
90 			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
91 			curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
92 		}
93 	} else {
94 		LogError(0, RS_RET_OBJ_CREATION_FAILED, "omhttpfs: failed to init cURL\n");
95 		return RS_RET_OBJ_CREATION_FAILED;
96 	}
97 	curl_easy_setopt(curl, CURLOPT_USERAGENT, HTTPFS_USER_AGENT);
98 	pWrkrData-&gt;curl = curl;
99 	return RS_RET_OK;
100 }
101 static rsRetVal
102 httpfs_build_url(wrkrInstanceData_t *pWrkrData, const char* op, es_str_t** url_buf)
103 {
104 	*url_buf = es_newStr(HTTPFS_URL_BUFFER_LENGTH);
105 	if (pWrkrData-&gt;pData-&gt;https) {
106 	    es_addBuf(url_buf, "https://", sizeof("https://")-1);
107 	} else {
108 	    es_addBuf(url_buf, "http://", sizeof("http://")-1);
109 	}
110 	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;host, strlen((char*)pWrkrData-&gt;pData-&gt;host));
111 	es_addChar(url_buf, ':');
112 	char portBuf[6];
113 	snprintf(portBuf, sizeof(portBuf), "%d", pWrkrData-&gt;pData-&gt;port);
114 	es_addBuf(url_buf, portBuf, strlen(portBuf));
115 	es_addBuf(url_buf, HTTPFS_URL_PREFIX_V1, sizeof(HTTPFS_URL_PREFIX_V1)-1);
116 	if (pWrkrData-&gt;file[0] != '/') {
117 	    es_addChar(url_buf, '/');
118 	}
119 	es_addBuf(url_buf, (char* )pWrkrData-&gt;file, strlen((char* )pWrkrData-&gt;file));
120 	es_addBuf(url_buf, "?user.name=", sizeof("?user.name=")-1);
121 	es_addBuf(url_buf, (char* )pWrkrData-&gt;pData-&gt;user, strlen((char* )pWrkrData-&gt;pData-&gt;user));
122 	es_addBuf(url_buf, op, strlen(op));
123 	return RS_RET_OK;
124 }
125 static void httpfs_set_url(wrkrInstanceData_t *pWrkrData, const char* op)
126 {
127 	es_str_t* url;
128 	char* url_cstr;
129 	httpfs_build_url(pWrkrData, op, &amp;url);
130 	url_cstr = es_str2cstr(url, NULL);
131 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_URL, url_cstr);
132 	free(url_cstr);
133 }
134 static void httpfs_curl_set_put(CURL* curl)
135 {
136 	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
137 	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
138 	curl_easy_setopt(curl, CURLOPT_POST, 0L);
139 	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
140 	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
141 	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PUT");
142 }
143 static void httpfs_curl_set_post(CURL* curl)
144 {
145 	curl_easy_setopt(curl, CURLOPT_HTTPGET, 0L);
146 	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
147 	curl_easy_setopt(curl, CURLOPT_PUT, 0L);
148 	curl_easy_setopt(curl, CURLOPT_UPLOAD, 0L);
149 	curl_easy_setopt(curl, CURLOPT_POST, 1L);
150 	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
151 }
152 static struct curl_slist*
153 httpfs_curl_add_header(struct curl_slist* headers, int hdr_count, ...)
154 {
155 	const char* hdr;
156 	va_list ar;
157 	va_start(ar, hdr_count);
158 	for (; hdr_count &gt; 0; hdr_count--) {
159 	    hdr = va_arg(ar, const char*);
160 	    if (hdr != NULL
161 	            &amp;&amp; hdr[0] != 0) {
162 	        headers = curl_slist_append(headers, hdr);
163 	    } else {
164 	        break;
165 	    }
166 	}
167 	va_end(ar);
168 	headers = curl_slist_append(headers, "Expect:");
169 	headers = curl_slist_append(headers, "Transfer-Encoding:");
170 	return headers;
171 }
172 static size_t
173 httpfs_curl_result_callback(void *contents, size_t size, size_t nmemb, void *userp)
174 {
175 	size_t realsize = size * nmemb;
176 	char *newreply = NULL;
177 	wrkrInstanceData_t *mem = (wrkrInstanceData_t *)userp;
178 	newreply = realloc(mem-&gt;reply, mem-&gt;replyLen + realsize + 1);
179 	if (newreply == NULL) {
180 	    dbgprintf("not enough memory (realloc returned NULL)\n");
181 	    if (mem-&gt;reply != NULL)
182 	        free(mem-&gt;reply);
183 	    mem-&gt;reply = NULL;
184 	    mem-&gt;replyLen = 0;
185 	    return 0;
186 	}
187 	mem-&gt;reply = newreply;
188 	memcpy(&amp;(mem-&gt;reply[mem-&gt;replyLen]), contents, realsize);
189 	mem-&gt;replyLen += realsize;
190 	mem-&gt;reply[mem-&gt;replyLen] = 0;
191 	return realsize;
192 }
193 #define HTTPFS_CURL_VARS_INIT \
194 	struct curl_slist* headers = NULL; \
195 	long response_code; \
196 	CURLcode res; \
197 	char* content_type;
198 #define HTTPFS_CURL_VARS_RELEASE \
199 	curl_slist_free_all(headers);
200 #define HTTPFS_CURL_EXEC \
201 	pWrkrData-&gt;reply = NULL; \
202 	pWrkrData-&gt;replyLen = 0; \
203 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEDATA, pWrkrData); \
204 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_WRITEFUNCTION, httpfs_curl_result_callback); \
205 	res = curl_easy_perform(pWrkrData-&gt;curl); \
206 	if (res == CURLE_OK) { \
207 	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;content_type); \
208 	    if (strncmp(content_type, HTTPFS_CONTENT_TYPE_JSON, strlen(HTTPFS_CONTENT_TYPE_JSON))) { \
209 	    } \
210 	    curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code); \
211 	    if (pWrkrData-&gt;reply != NULL) { \
212 	        pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0'; \
213 	    } \
214 	} else { \
215 	LogError(0, RS_RET_ERR, "CURL request fail, code=%d, error string=%s\n", res, curl_easy_strerror(res)); \
216 	    return -1; \
217 	}
218 static rsRetVal
219 httpfs_parse_exception(char* buf, int length, httpfs_json_remote_exception* jre)
220 {
221 	DEFiRet;
222 	if (!length) {
223 	    return RS_RET_JSON_PARSE_ERR;
224 	}
225 	struct json_tokener* jt = json_tokener_new();
226 	json_tokener_reset(jt);
227 	struct json_object *json;
228 	json = json_tokener_parse_ex(jt, buf, length);
229 	if (!json_object_is_type(json, json_type_object)) {
230 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
231 	}
232 	if (!json_object_object_get_ex(json, "RemoteException", &amp;json)) {
233 	ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
234 	}
235 	struct json_object *jobj;
236 	memset(jre, 0, sizeof(*jre));
237 	const char *str;
238 	json_object_object_get_ex(json, "javaClassName", &amp;jobj);
239 	str = json_object_get_string(jobj);
240 	strncpy(jre-&gt;class, str, sizeof(jre-&gt;class));
241 	jre-&gt;class[sizeof(jre-&gt;class)-1] = '\0';
242 	json_object_object_get_ex(json, "exception", &amp;jobj);
243 	str = json_object_get_string(jobj);
244 	strncpy(jre-&gt;exception, str, sizeof(jre-&gt;exception));
245 	jre-&gt;exception[sizeof(jre-&gt;exception)-1] = '\0';
246 	json_object_object_get_ex(json, "message", &amp;jobj);
247 	str = json_object_get_string(jobj);
248 	strncpy(jre-&gt;message, str, sizeof(jre-&gt;message));
249 	jre-&gt;message[sizeof(jre-&gt;message)-1] = '\0';
250 finalize_it:
251 	if(jt != NULL)
252 		json_tokener_free(jt);
253 	if(json != NULL)
254 		json_object_put(json);
255 	RETiRet;
256 }
257 static rsRetVal
258 httpfs_create_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
259 {
260 HTTPFS_CURL_VARS_INIT
261 	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
262 	httpfs_curl_set_put(pWrkrData-&gt;curl);
263 	httpfs_set_url(pWrkrData, "&amp;op=create&amp;overwrite=false&amp;data=true");
264 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
265 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
266 	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
267 	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
268 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
269 HTTPFS_CURL_EXEC
270 	int success = 0;
271 	if (response_code == 201) {
272 	    success = 1;
273 	}
274 HTTPFS_CURL_VARS_RELEASE
275 	if (success) {
276 	    return RS_RET_OK;
277 	} else {
278 	    return RS_RET_FALSE;
279 	}
280 }
281 static rsRetVal
282 httpfs_append_file(wrkrInstanceData_t *pWrkrData, uchar* buf)
283 {
284 HTTPFS_CURL_VARS_INIT
285 	DBGPRINTF("%s(): file=%s\n", __FUNCTION__, pWrkrData-&gt;file);
286 	httpfs_curl_set_post(pWrkrData-&gt;curl);
287 	httpfs_set_url(pWrkrData, "&amp;op=append&amp;data=true");
288 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDS, (char*)buf);
289 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_POSTFIELDSIZE, strlen((char*) buf));
290 	headers = httpfs_curl_add_header(headers, 1, HTTPFS_CONTENT_TYPE);
291 	curl_easy_setopt(pWrkrData-&gt;curl, CURLOPT_HTTPHEADER, headers);
292 	DBGPRINTF("%s(): msg=%s\n", __FUNCTION__, buf);
293 HTTPFS_CURL_EXEC
294 	int success = 0;
295 	if (response_code == 200) {
296 	    success = 1;
297 	} else if (response_code == 404) {
298 	}
299 HTTPFS_CURL_VARS_RELEASE
300 	if (success) {
301 	    return RS_RET_OK;
302 	} else {
303 	    return RS_RET_FALSE;
304 	}
305 }
306 static rsRetVal
307 httpfs_log(wrkrInstanceData_t *pWrkrData, uchar* buf)
308 {
309 	DEFiRet;
310 	long response_code;
311 	httpfs_json_remote_exception jre;
312 	iRet = httpfs_append_file(pWrkrData, buf);
313 	if (iRet == RS_RET_OK) {
314 	    DBGPRINTF("omhttpfs: Append success: %s\n", pWrkrData-&gt;file);
315 	    return RS_RET_OK;
316 	}
317 	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
318 	if (response_code != 404) {
319 	    DBGPRINTF("omhttpfs: Append fail HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
320 	    return RS_RET_FALSE;
321 	}
322 	iRet = httpfs_create_file(pWrkrData, buf);
323 	if (iRet == RS_RET_OK) {
324 	    DBGPRINTF("omhttpfs: Create file success: %s\n", pWrkrData-&gt;file);
325 	    return RS_RET_OK;
326 	}
327 	curl_easy_getinfo(pWrkrData-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
328 	if (response_code == 201) {
329 	    DBGPRINTF("omhttpfs: Create file success HTTP 201: %s\n", pWrkrData-&gt;file);
330 	    return RS_RET_OK;
331 	}
332 	if (response_code == 500) {
333 	    DBGPRINTF("omhttpfs: Create file failed HTTP %ld: %s\n", response_code, pWrkrData-&gt;file);
334 	    httpfs_parse_exception(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen, &amp;jre);
335 	    if (!strncmp(jre.exception, HTTPFS_FILEALREADYEXISTSEXCEPTION, strlen(HTTPFS_FILEALREADYEXISTSEXCEPTION))) {
336 	        DBGPRINTF("omhttpfs: File already exists, append again: %s\n", pWrkrData-&gt;file);
337 	        iRet = httpfs_append_file(pWrkrData, buf);
338 	        if (iRet == RS_RET_OK) {
339 	            DBGPRINTF("omhttpfs: Re-Append success: %s\n", pWrkrData-&gt;file);
340 	            return RS_RET_OK;
341 	        } else {
342 	            DBGPRINTF("omhttpfs: Re-Append failed: %s\n", pWrkrData-&gt;file);
343 	        }
344 	    } else {
345 	        DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
346 	    }
347 	} else {
348 	    DBGPRINTF("omhttpfs: Create file failed: %s %s\n", pWrkrData-&gt;file, pWrkrData-&gt;reply);
349 	}
350 	return RS_RET_FALSE;
351 }
352 BEGINinitConfVars
353 	CODESTARTinitConfVars
354 ENDinitConfVars
355 BEGINcreateInstance
356 CODESTARTcreateInstance
357 	DBGPRINTF("omhttpfs: createInstance\n");
358 ENDcreateInstance
359 BEGINcreateWrkrInstance
360 CODESTARTcreateWrkrInstance
361 	DBGPRINTF("omhttpfs: createWrkrInstance\n");
362 	pWrkrData-&gt;curl = NULL;
363 	iRet = httpfs_init_curl(pWrkrData, pWrkrData-&gt;pData);
364 	DBGPRINTF("omhttpfs: createWrkrInstance,pData %p/%p, pWrkrData %p\n",
365 	pData, pWrkrData-&gt;pData, pWrkrData);
366 ENDcreateWrkrInstance
367 BEGINisCompatibleWithFeature
368 CODESTARTisCompatibleWithFeature
369 	if(eFeat == sFEATURERepeatedMsgReduction)
370 	    iRet = RS_RET_OK;
371 ENDisCompatibleWithFeature
372 BEGINfreeInstance
373 CODESTARTfreeInstance
374 	free(pData-&gt;file);
375 	free(pData-&gt;tplName);
376 	free(pData-&gt;host);
377 	free(pData-&gt;user);
378 ENDfreeInstance
379 BEGINfreeWrkrInstance
380 CODESTARTfreeWrkrInstance
381 	free(pWrkrData-&gt;file);
382 	if(pWrkrData-&gt;curl) {
383 	    curl_easy_cleanup(pWrkrData-&gt;curl);
384 	    pWrkrData-&gt;curl = NULL;
385 	}
386 ENDfreeWrkrInstance
387 BEGINdbgPrintInstInfo
388 CODESTARTdbgPrintInstInfo
389 	DBGPRINTF("OmHTTPFS\n");
390 	DBGPRINTF("Version: %s\n", OMHTTPFS_VERSION);
391 	DBGPRINTF("\tHost: %s\n", pData-&gt;host);
392 	DBGPRINTF("\tPort: %d\n", pData-&gt;port);
393 	DBGPRINTF("\tUser: %s\n", pData-&gt;user);
394 	DBGPRINTF("\tFile: %s\n", pData-&gt;file);
395 ENDdbgPrintInstInfo
396 BEGINtryResume
397 CODESTARTtryResume
398 	DBGPRINTF("omhttpfs: tryResume called\n");
399 	iRet = RS_RET_OK;
400 ENDtryResume
401 BEGINdoAction
402 CODESTARTdoAction
403 	DBGPRINTF("omhttpfs: doAction\n");
404 	if (pWrkrData-&gt;pData-&gt;isDynFile) {
405 	    pWrkrData-&gt;file = ustrdup(ppString[1]);
406 	} else {
407 	    pWrkrData-&gt;file = ustrdup(pWrkrData-&gt;pData-&gt;file);
408 	}
409 	iRet = httpfs_log(pWrkrData, ppString[0]);
410 	if(iRet != RS_RET_OK) {
411 	    DBGPRINTF("omhttpfs: error writing httpfs, suspending\n");
412 	    iRet = RS_RET_SUSPENDED;
413 	}
414 ENDdoAction
415 static void
416 setInstParamDefaults(instanceData *pData)
417 {
418 	pData-&gt;host = (uchar*) strdup(OMHTTPFS_DEFAULT_HOST);
419 	pData-&gt;port = OMHTTPFS_DEFAULT_PORT;
420 	pData-&gt;user = (uchar*) strdup(OMHTTPFS_DEFAULT_USER);
421 	pData-&gt;https = 0;
422 	pData-&gt;file = NULL;
423 	pData-&gt;isDynFile = 0;
424 	pData-&gt;tplName = NULL;
425 }
426 BEGINnewActInst
427 	struct cnfparamvals *pvals;
428 <a name="1"></a>	int i;
429 	uchar *tplToUse;
430 CODESTARTnewActInst
431 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
432 	    ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
433 	}
434 	CHKiRet(createInstance(&amp;pData));
435 	setInstParamDefaults(pData);
436 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
437 	    if(!pvals[i].bUsed)
438 	        continue;
439 	    if(!strcmp(actpblk.descr[i].name, "host")) {
440 	        pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
441 	    } else if(!strcmp(actpblk.descr[i].name, "port")) {</b></font>
442 	        pData-&gt;port = (int) pvals[i].val.d.n;
443 	    } else if(!strcmp(actpblk.descr[i].name, "user")) {
444 	        pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
445 	    } else if(!strcmp(actpblk.descr[i].name, "https")) {
446 	        pData-&gt;https = pvals[i].val.d.n ? 1 : 0;
447 	    } else if(!strcmp(actpblk.descr[i].name, "file")) {
448 	        pData-&gt;file = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
449 	    } else if(!strcmp(actpblk.descr[i].name, "isdynfile")) {
450 	        pData-&gt;isDynFile = pvals[i].val.d.n ? 1 : 0;
451 <a name="2"></a>
452 	    } else if(!strcmp(actpblk.descr[i].name, "template")) {
453 	        pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
454 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	    } else {
455 	        DBGPRINTF("omhttpfs: program error, non-handled param '%s'\n", actpblk.descr[i].name);
456 	    }
457 	}
458 	if(pData-&gt;file == NULL) {
459 	    LogError(0, RS_RET_INTERNAL_ERROR, "omhttpfs: file is not set "
460 		"[this should not be possible]\n");
461 	ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
462 	}
463 	if(pData-&gt;user == NULL || pData-&gt;user[0] == '\0') {</b></font>
464 	    pData-&gt;user = ustrdup((uchar*) OMHTTPFS_DEFAULT_USER);
465 	}
466 	if(pData-&gt;host == NULL || pData-&gt;host[0] == '\0') {
467 	    pData-&gt;host = ustrdup((uchar*) OMHTTPFS_DEFAULT_HOST);
468 	}
469 	if (pData-&gt;isDynFile) {
470 	    CODE_STD_STRING_REQUESTparseSelectorAct(2)
471 	    CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;file), OMSR_NO_RQD_TPL_OPTS));
472 	} else {
473 	    CODE_STD_STRING_REQUESTparseSelectorAct(1)
474 	}
475 	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? (uchar* ) "RSYSLOG_FileFormat" : pData-&gt;tplName);
476 	iRet = OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS);
477 CODE_STD_FINALIZERnewActInst
478 	cnfparamvalsDestruct(pvals, &amp;actpblk);
479 ENDnewActInst
480 NO_LEGACY_CONF_parseSelectorAct
481 BEGINmodExit
482 CODESTARTmodExit
483 	curl_global_cleanup();
484 	objRelease(datetime, CORE_COMPONENT);
485 	objRelease(glbl, CORE_COMPONENT);
486 ENDmodExit
487 BEGINqueryEtryPt
488 CODESTARTqueryEtryPt
489 	CODEqueryEtryPt_STD_OMOD_QUERIES
490 	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
491 	CODEqueryEtryPt_STD_OMOD8_QUERIES
492 	CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
493 ENDqueryEtryPt
494 BEGINmodInit()
495 CODESTARTmodInit
496 INITLegCnfVars
497 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
498 	CHKiRet(objUse(glbl, CORE_COMPONENT));
499 	CHKiRet(objUse(datetime, CORE_COMPONENT));
500 	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
501 	    LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -httpfs module init failed");
502 	    ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
503 	}
504 	DBGPRINTF("omhttpfs version %s is initializing\n", OMHTTPFS_VERSION);
505 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>template.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;ctype.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;json.h&gt;
9 #include "stringbuf.h"
10 #include "syslogd-types.h"
11 #include "template.h"
12 #include "msg.h"
13 #include "dirty.h"
14 #include "obj.h"
15 #include "errmsg.h"
16 #include "strgen.h"
17 #include "rsconf.h"
18 #include "msg.h"
19 #include "parserif.h"
20 #include "unicode-helper.h"
21 PRAGMA_INGORE_Wswitch_enum
22 DEFobjCurrIf(obj)
23 DEFobjCurrIf(strgen)
24 static struct cnfparamdescr cnfparamdescr[] = {
25 <a name="0"></a>	{ "name", eCmdHdlrString, 1 },
26 	{ "type", eCmdHdlrString, 1 },
27 	{ "string", eCmdHdlrString, 0 },
28 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "plugin", eCmdHdlrString, 0 },
29 	{ "subtree", eCmdHdlrString, 0 },
30 	{ "option.stdsql", eCmdHdlrBinary, 0 },
31 	{ "option.sql", eCmdHdlrBinary, 0 },
32 	{ "option.json", eCmdHdlrBinary, 0 },
33 	{ "option.jsonf", eCmdHdlrBinary, 0 },
34 	{ "option.casesensitive", eCmdHdlrBinary, 0 }
35 };
36 static struct cnfparamblk pblk =
37 	{ CNFPARAMBLK_VERSION,
38 	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
39 	  cnfparamdescr
40 	};
41 static struct cnfparamdescr cnfparamdescrProperty[] = {</b></font>
42 	{ "name", eCmdHdlrString, 1 },
43 	{ "outname", eCmdHdlrString, 0 },
44 	{ "dateformat", eCmdHdlrString, 0 },
45 	{ "date.inutc", eCmdHdlrBinary, 0 },
46 	{ "compressspace", eCmdHdlrBinary, 0 },
47 	{ "caseconversion", eCmdHdlrString, 0 },
48 	{ "controlcharacters", eCmdHdlrString, 0 },
49 	{ "securepath", eCmdHdlrString, 0 },
50 	{ "format", eCmdHdlrString, 0 },
51 	{ "position.from", eCmdHdlrInt, 0 },
52 	{ "position.to", eCmdHdlrInt, 0 },
53 	{ "position.relativetoend", eCmdHdlrBinary, 0 },
54 	{ "field.number", eCmdHdlrInt, 0 },
55 	{ "field.delimiter", eCmdHdlrInt, 0 },
56 	{ "regex.expression", eCmdHdlrString, 0 },
57 	{ "regex.type", eCmdHdlrString, 0 },
58 	{ "regex.nomatchmode", eCmdHdlrString, 0 },
59 	{ "regex.match", eCmdHdlrInt, 0 },
60 	{ "regex.submatch", eCmdHdlrInt, 0 },
61 	{ "droplastlf", eCmdHdlrBinary, 0 },
62 	{ "fixedwidth", eCmdHdlrBinary, 0 },
63 	{ "datatype", eCmdHdlrString, 0 },
64 	{ "onempty", eCmdHdlrString, 0 },
65 	{ "mandatory", eCmdHdlrBinary, 0 },
66 	{ "spifno1stsp", eCmdHdlrBinary, 0 }
67 };
68 static struct cnfparamblk pblkProperty =
69 	{ CNFPARAMBLK_VERSION,
70 	  sizeof(cnfparamdescrProperty)/sizeof(struct cnfparamdescr),
71 	  cnfparamdescrProperty
72 	};
73 static struct cnfparamdescr cnfparamdescrConstant[] = {
74 	{ "value", eCmdHdlrString, 1 },
75 	{ "format", eCmdHdlrString, 0 },
76 	{ "outname", eCmdHdlrString, 0 }
77 };
78 static struct cnfparamblk pblkConstant =
79 	{ CNFPARAMBLK_VERSION,
80 	  sizeof(cnfparamdescrConstant)/sizeof(struct cnfparamdescr),
81 	  cnfparamdescrConstant
82 	};
83 #ifdef FEATURE_REGEXP
84 DEFobjCurrIf(regexp)
85 #endif
86 #define ALLOC_INC 128
87 rsRetVal
88 ExtendBuf(actWrkrIParams_t *__restrict__ const iparam, const size_t iMinSize)
89 {
90 	uchar *pNewBuf;
91 	size_t iNewSize;
92 	DEFiRet;
93 	iNewSize = (iMinSize / ALLOC_INC + 1) * ALLOC_INC;
94 	CHKmalloc(pNewBuf = (uchar*) realloc(iparam-&gt;param, iNewSize));
95 	iparam-&gt;param = pNewBuf;
96 	iparam-&gt;lenBuf = iNewSize;
97 finalize_it:
98 	RETiRet;
99 }
100 rsRetVal
101 tplToString(struct template *__restrict__ const pTpl,
102 	    smsg_t *__restrict__ const pMsg,
103 	    actWrkrIParams_t *__restrict__ const iparam,
104 	    struct syslogTime *const ttNow)
105 {
106 	DEFiRet;
107 	struct templateEntry *__restrict__ pTpe;
108 	size_t iBuf;
109 	unsigned short bMustBeFreed = 0;
110 	uchar *pVal;
111 	rs_size_t iLenVal = 0;
112 	if(pTpl-&gt;pStrgen != NULL) {
113 		CHKiRet(pTpl-&gt;pStrgen(pMsg, iparam));
114 		FINALIZE;
115 	}
116 	if(pTpl-&gt;bHaveSubtree) {
117 		getJSONPropVal(pMsg, &amp;pTpl-&gt;subtree, &amp;pVal, &amp;iLenVal, &amp;bMustBeFreed);
118 		if(iLenVal &gt;= (rs_size_t)iparam-&gt;lenBuf) 			CHKiRet(ExtendBuf(iparam, iLenVal + 1));
119 		memcpy(iparam-&gt;param, pVal, iLenVal+1);
120 		FINALIZE;
121 	}
122 	pTpe = pTpl-&gt;pEntryRoot;
123 	iBuf = 0;
124 	const int extra_space = (pTpl-&gt;optFormatEscape == JSONF) ? 1 : 3;
125 	if(pTpl-&gt;optFormatEscape == JSONF) {
126 		if(iparam-&gt;lenBuf &lt; 2) 			CHKiRet(ExtendBuf(iparam, 2));
127 		iBuf = 1;
128 		*iparam-&gt;param = '{';
129 	}
130 	while(pTpe != NULL) {
131 		if(pTpe-&gt;eEntryType == CONSTANT) {
132 			pVal = (uchar*) pTpe-&gt;data.constant.pConstant;
133 			iLenVal = pTpe-&gt;data.constant.iLenConstant;
134 			bMustBeFreed = 0;
135 		} else 	if(pTpe-&gt;eEntryType == FIELD) {
136 			pVal = (uchar*) MsgGetProp(pMsg, pTpe, &amp;pTpe-&gt;data.field.msgProp,
137 						   &amp;iLenVal, &amp;bMustBeFreed, ttNow);
138 			if(pTpl-&gt;optFormatEscape == SQL_ESCAPE)
139 				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, SQL_ESCAPE);
140 			else if(pTpl-&gt;optFormatEscape == JSON_ESCAPE)
141 				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, JSON_ESCAPE);
142 			else if(pTpl-&gt;optFormatEscape == STDSQL_ESCAPE)
143 				doEscape(&amp;pVal, &amp;iLenVal, &amp;bMustBeFreed, STDSQL_ESCAPE);
144 		} else {
145 			DBGPRINTF("TplToString: invalid entry type %d\n", pTpe-&gt;eEntryType);
146 			pVal = (uchar*) "*LOGIC ERROR*";
147 			iLenVal = sizeof("*LOGIC ERROR*") - 1;
148 			bMustBeFreed = 0;
149 		}
150 		if(iLenVal &gt; 0) { 			if(iBuf + iLenVal + extra_space &gt;= iparam-&gt;lenBuf) 				CHKiRet(ExtendBuf(iparam, iBuf + iLenVal + 1));
151 			memcpy(iparam-&gt;param + iBuf, pVal, iLenVal);
152 			iBuf += iLenVal;
153 			if(pTpl-&gt;optFormatEscape == JSONF) {
154 				memcpy(iparam-&gt;param + iBuf,
155 					(pTpe-&gt;pNext == NULL) ? "}\n" : ", ", 2);
156 				iBuf += 2;
157 			}
158 		}
159 		if(bMustBeFreed) {
160 			free(pVal);
161 			bMustBeFreed = 0;
162 		}
163 		pTpe = pTpe-&gt;pNext;
164 	}
165 	if(iBuf == iparam-&gt;lenBuf) {
166 		CHKiRet(ExtendBuf(iparam, iBuf + 1));
167 	}
168 	iparam-&gt;param[iBuf] = '\0';
169 	iparam-&gt;lenStr = iBuf;
170 finalize_it:
171 	if(bMustBeFreed) {
172 		free(pVal);
173 		bMustBeFreed = 0;
174 	}
175 	RETiRet;
176 }
177 rsRetVal
178 tplToJSON(struct template *pTpl, smsg_t *pMsg, struct json_object **pjson, struct syslogTime *ttNow)
179 {
180 	struct templateEntry *pTpe;
181 	rs_size_t propLen;
182 	unsigned short bMustBeFreed;
183 	uchar *pVal;
184 	struct json_object *json, *jsonf;
185 	rsRetVal localRet;
186 	DEFiRet;
187 	if(pTpl-&gt;bHaveSubtree){
188 		if(jsonFind(pMsg, &amp;pTpl-&gt;subtree, pjson) != RS_RET_OK)
189 			*pjson = NULL;
190 		if(*pjson == NULL) {
191 			*pjson = json_object_new_object();
192 		} else {
193 			json_object_get(*pjson); 		}
194 		FINALIZE;
195 	}
196 	json = json_object_new_object();
197 	for(pTpe = pTpl-&gt;pEntryRoot ; pTpe != NULL ; pTpe = pTpe-&gt;pNext) {
198 		if(pTpe-&gt;eEntryType == CONSTANT) {
199 			if(pTpe-&gt;fieldName == NULL)
200 				continue;
201 			jsonf = json_object_new_string((char*) pTpe-&gt;data.constant.pConstant);
202 			json_object_object_add(json, (char*)pTpe-&gt;fieldName, jsonf);
203 		} else 	if(pTpe-&gt;eEntryType == FIELD) {
204 			if(pTpe-&gt;data.field.msgProp.id == PROP_CEE        ||
205 			   pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR  ||
206 			   pTpe-&gt;data.field.msgProp.id == PROP_GLOBAL_VAR   ) {
207 				localRet = msgGetJSONPropJSON(pMsg, &amp;pTpe-&gt;data.field.msgProp, &amp;jsonf);
208 				if(localRet == RS_RET_OK) {
209 					json_object_object_add(json, (char*)pTpe-&gt;fieldName, json_object_get(jsonf));
210 				} else {
211 					DBGPRINTF("tplToJSON: error %d looking up property %s\n",
212 						  localRet, pTpe-&gt;fieldName);
213 					if(pTpe-&gt;data.field.options.bMandatory) {
214 						json_object_object_add(json, (char*)pTpe-&gt;fieldName, NULL);
215 					}
216 				}
217 			} else  {
218 				pVal = (uchar*) MsgGetProp(pMsg, pTpe, &amp;pTpe-&gt;data.field.msgProp,
219 							   &amp;propLen, &amp;bMustBeFreed, ttNow);
220 				if(pTpe-&gt;data.field.options.bMandatory || propLen &gt; 0) {
221 					jsonf = json_object_new_string_len((char*)pVal, propLen+1);
222 					json_object_object_add(json, (char*)pTpe-&gt;fieldName, jsonf);
223 				}
224 				if(bMustBeFreed) { 					free(pVal);
225 				}
226 			}
227 		}
228 	}
229 	assert(iRet == RS_RET_OK);
230 	*pjson = json;
231 finalize_it:
232 	RETiRet;
233 }
234 static void doEmergencyEscape(register uchar *p, int mode)
235 {
236 	while(*p) {
237 		if((mode == SQL_ESCAPE||mode == STDSQL_ESCAPE) &amp;&amp; *p == '\'') {
238 			*p = '"';
239 		} else if(mode == JSON_ESCAPE) {
240 			if(*p == '"') {
241 				*p = '\'';
242 			} else if(*p == '\\' ) {
243 				*p = '/';
244 			}
245 		} else if((mode == SQL_ESCAPE) &amp;&amp; *p == '\\') {
246 			*p = '/';
247 		}
248 		++p;
249 	}
250 }
251 rsRetVal
252 doEscape(uchar **pp, rs_size_t *pLen, unsigned short *pbMustBeFreed, int mode)
253 {
254 	DEFiRet;
255 	uchar *p = NULL;
256 	int iLen;
257 	cstr_t *pStrB = NULL;
258 	uchar *pszGenerated;
259 	assert(pp != NULL);
260 	assert(*pp != NULL);
261 	assert(pLen != NULL);
262 	assert(pbMustBeFreed != NULL);
263 	if(mode == STDSQL_ESCAPE)
264 		for(p = *pp ; *p &amp;&amp; *p != '\'' ; ++p)
265 			;
266 	else if(mode == SQL_ESCAPE)
267 		for(p = *pp ; *p &amp;&amp; *p != '\'' &amp;&amp; *p != '\\' ; ++p)
268 			;
269 	else if(mode == JSON_ESCAPE)
270 		for(p = *pp ; *p &amp;&amp;  (*p == '"' || *p == '\\' ) ; ++p)
271 			;
272 	if(p &amp;&amp; *p == '\0')
273 		FINALIZE; 
274 	p = *pp;
275 	iLen = *pLen;
276 	CHKiRet(cstrConstruct(&amp;pStrB));
277 	while(*p) {
278 		if((mode == SQL_ESCAPE || mode == STDSQL_ESCAPE) &amp;&amp; *p == '\'') {
279 			CHKiRet(cstrAppendChar(pStrB, (mode == STDSQL_ESCAPE) ? '\'' : '\\'));
280 			iLen++;			} else if((mode == SQL_ESCAPE) &amp;&amp; *p == '\\') {
281 			CHKiRet(cstrAppendChar(pStrB, '\\'));
282 			iLen++;			} else if((mode == JSON_ESCAPE) &amp;&amp;  (*p == '"' || *p == '\\' )) {
283 			CHKiRet(cstrAppendChar(pStrB, '\\'));
284 			iLen++;			}
285 		CHKiRet(cstrAppendChar(pStrB, *p));
286 		++p;
287 	}
288 	cstrFinalize(pStrB);
289 	CHKiRet(cstrConvSzStrAndDestruct(&amp;pStrB, &amp;pszGenerated, 0));
290 	if(*pbMustBeFreed)
291 		free(*pp); 
292 	*pp = pszGenerated;
293 	*pLen = iLen;
294 	*pbMustBeFreed = 1;
295 finalize_it:
296 	if(iRet != RS_RET_OK) {
297 		doEmergencyEscape(*pp, mode);
298 		if(pStrB != NULL)
299 			cstrDestruct(&amp;pStrB);
300 	}
301 	RETiRet;
302 }
303 static struct templateEntry* tpeConstruct(struct template *pTpl)
304 {
305 	struct templateEntry *pTpe;
306 	assert(pTpl != NULL);
307 	if((pTpe = calloc(1, sizeof(struct templateEntry))) == NULL)
308 		return NULL;
309 	if(pTpl-&gt;pEntryLast == NULL){
310 		pTpl-&gt;pEntryRoot = pTpl-&gt;pEntryLast  = pTpe;
311 	} else {
312 		pTpl-&gt;pEntryLast-&gt;pNext = pTpe;
313 		pTpl-&gt;pEntryLast  = pTpe;
314 	}
315 	pTpl-&gt;tpenElements++;
316 	return(pTpe);
317 }
318 static void
319 apply_case_sensitivity(struct template *pTpl)
320 {
321 	if(pTpl-&gt;optCaseSensitive) return;
322 	struct templateEntry *pTpe;
323 	for(pTpe = pTpl-&gt;pEntryRoot ; pTpe != NULL ; pTpe = pTpe-&gt;pNext) {
324 		if(pTpe-&gt;eEntryType == FIELD) {
325 			if(pTpe-&gt;data.field.msgProp.id == PROP_CEE        ||
326 			   pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR  ||
327 			   pTpe-&gt;data.field.msgProp.id == PROP_GLOBAL_VAR   ) {
328 				uchar* p;
329 				p = pTpe-&gt;fieldName;
330 				for ( ; *p; ++p) *p = tolower(*p);
331 				p = pTpe-&gt;data.field.msgProp.name;
332 				for ( ; *p; ++p) *p = tolower(*p);
333 			}
334 		}
335 	}
336 }
337 static struct template*
338 tplConstruct(rsconf_t *conf)
339 {
340 	struct template *pTpl;
341 	if((pTpl = calloc(1, sizeof(struct template))) == NULL)
342 		return NULL;
343 	if(conf-&gt;templates.last == NULL)	{
344 		conf-&gt;templates.root = conf-&gt;templates.last = pTpl;
345 	} else {
346 		conf-&gt;templates.last-&gt;pNext = pTpl;
347 		conf-&gt;templates.last = pTpl;
348 	}
349 	return(pTpl);
350 }
351 static rsRetVal
352 do_Constant(unsigned char **pp, struct template *pTpl, int bDoEscapes)
353 {
354 	register unsigned char *p;
355 	cstr_t *pStrB;
356 	struct templateEntry *pTpe;
357 	int i;
358 	DEFiRet;
359 	assert(pp != NULL);
360 	assert(*pp != NULL);
361 	assert(pTpl != NULL);
362 	p = *pp;
363 	CHKiRet(cstrConstruct(&amp;pStrB));
364 	while(*p &amp;&amp; *p != '%' &amp;&amp; !(bDoEscapes &amp;&amp; *p == '\"')) {
365 		if(bDoEscapes &amp;&amp; *p == '\\') {
366 			switch(*++p) {
367 				case '\0':
368 					cstrAppendChar(pStrB, *p);
369 					break;
370 				case 'n':
371 					cstrAppendChar(pStrB, '\n');
372 					++p;
373 					break;
374 				case 'r':
375 					cstrAppendChar(pStrB, '\r');
376 					++p;
377 					break;
378 				case '\\':
379 					cstrAppendChar(pStrB, '\\');
380 					++p;
381 					break;
382 				case '%':
383 					cstrAppendChar(pStrB, '%');
384 					++p;
385 					break;
386 				case '0': 				case '1':
387 				case '2':
388 				case '3':
389 				case '4':
390 				case '5':
391 				case '6':
392 				case '7':
393 				case '8':
394 				case '9':
395 					i = 0;
396 					while(*p &amp;&amp; isdigit((int)*p)) {
397 						i = i * 10 + *p++ - '0';
398 					}
399 					cstrAppendChar(pStrB, i);
400 					break;
401 				default:
402 					cstrAppendChar(pStrB, *p++);
403 					break;
404 			}
405 		}
406 		else
407 			cstrAppendChar(pStrB, *p++);
408 	}
409 	if((pTpe = tpeConstruct(pTpl)) == NULL) {
410 		rsCStrDestruct(&amp;pStrB);
411 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
412 	}
413 	pTpe-&gt;eEntryType = CONSTANT;
414 	cstrFinalize(pStrB);
415 	pTpe-&gt;data.constant.iLenConstant = rsCStrLen(pStrB);
416 	CHKiRet(cstrConvSzStrAndDestruct(&amp;pStrB, &amp;pTpe-&gt;data.constant.pConstant, 0));
417 	*pp = p;
418 finalize_it:
419 	RETiRet;
420 }
421 static int hasFormat(struct templateEntry *pTpe) {
422 	return (
423 		pTpe-&gt;data.field.options.bCSV ||
424 		pTpe-&gt;data.field.options.bJSON ||
425 		pTpe-&gt;data.field.options.bJSONf ||
426 		pTpe-&gt;data.field.options.bJSONr
427 	);
428 }
429 static void doOptions(unsigned char **pp, struct templateEntry *pTpe)
430 {
431 	register unsigned char *p;
432 	unsigned char Buf[64];
433 	size_t i;
434 	assert(pp != NULL);
435 	assert(*pp != NULL);
436 	assert(pTpe != NULL);
437 	p = *pp;
438 	while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
439 		memset(Buf, 0, sizeof(Buf)); 		i = 0;
440 		while((i &lt; sizeof(Buf)-1) &amp;&amp;
441 		      *p &amp;&amp; *p != '%' &amp;&amp; *p != ':' &amp;&amp; *p != ',') {
442 			Buf[i++] = tolower((int)*p);
443 			++p;
444 		}
445 		Buf[i] = '\0'; 		while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':' &amp;&amp; *p != ',')
446 			++p;			if(*p == ',')
447 		if(!strcmp((char*)Buf, "date-mysql")) {
448 			pTpe-&gt;data.field.eDateFormat = tplFmtMySQLDate;
449 		} else if(!strcmp((char*)Buf, "date-pgsql")) {
450 			pTpe-&gt;data.field.eDateFormat = tplFmtPgSQLDate;
451 		} else if(!strcmp((char*)Buf, "date-rfc3164")) {
452 			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3164Date;
453 		} else if(!strcmp((char*)Buf, "date-rfc3164-buggyday")) {
454 			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3164BuggyDate;
455 		} else if(!strcmp((char*)Buf, "date-rfc3339")) {
456 			pTpe-&gt;data.field.eDateFormat = tplFmtRFC3339Date;
457 		} else if(!strcmp((char*)Buf, "date-unixtimestamp")) {
458 			pTpe-&gt;data.field.eDateFormat = tplFmtUnixDate;
459 		} else if(!strcmp((char*)Buf, "date-subseconds")) {
460 			pTpe-&gt;data.field.eDateFormat = tplFmtSecFrac;
461 		} else if(!strcmp((char*)Buf, "date-wdayname")) {
462 			pTpe-&gt;data.field.eDateFormat = tplFmtWDayName;
463 		} else if(!strcmp((char*)Buf, "date-wday")) {
464 			pTpe-&gt;data.field.eDateFormat = tplFmtWDay;
465 		} else if(!strcmp((char*)Buf, "date-year")) {
466 			pTpe-&gt;data.field.eDateFormat = tplFmtYear;
467 		} else if(!strcmp((char*)Buf, "date-month")) {
468 			pTpe-&gt;data.field.eDateFormat = tplFmtMonth;
469 		} else if(!strcmp((char*)Buf, "date-day")) {
470 			pTpe-&gt;data.field.eDateFormat = tplFmtDay;
471 		} else if(!strcmp((char*)Buf, "date-hour")) {
472 			pTpe-&gt;data.field.eDateFormat = tplFmtHour;
473 		} else if(!strcmp((char*)Buf, "date-minute")) {
474 			pTpe-&gt;data.field.eDateFormat = tplFmtMinute;
475 		} else if(!strcmp((char*)Buf, "date-second")) {
476 			pTpe-&gt;data.field.eDateFormat = tplFmtSecond;
477 		} else if(!strcmp((char*)Buf, "date-tzoffshour")) {
478 			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsHour;
479 		} else if(!strcmp((char*)Buf, "date-tzoffsmin")) {
480 			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsMin;
481 		} else if(!strcmp((char*)Buf, "date-tzoffsdirection")) {
482 			pTpe-&gt;data.field.eDateFormat = tplFmtTZOffsDirection;
483 		} else if (!strcmp((char*)Buf, "date-ordinal")) {
484 			pTpe-&gt;data.field.eDateFormat = tplFmtOrdinal;
485 		} else if (!strcmp((char*)Buf, "date-week")) {
486 			pTpe-&gt;data.field.eDateFormat = tplFmtWeek;
487 		} else if (!strcmp((char*)Buf, "date-iso-week")) {
488 			pTpe-&gt;data.field.eDateFormat = tplFmtISOWeek;
489 		} else if (!strcmp((char*)Buf, "date-iso-week-year")) {
490 			pTpe-&gt;data.field.eDateFormat = tplFmtISOWeekYear;
491 		} else if(!strcmp((char*)Buf, "date-utc")) {
492 			pTpe-&gt;data.field.options.bDateInUTC = 1;
493 		} else if(!strcmp((char*)Buf, "lowercase")) {
494 			pTpe-&gt;data.field.eCaseConv = tplCaseConvLower;
495 		} else if(!strcmp((char*)Buf, "uppercase")) {
496 			pTpe-&gt;data.field.eCaseConv = tplCaseConvUpper;
497 		} else if(!strcmp((char*)Buf, "sp-if-no-1st-sp")) {
498 			pTpe-&gt;data.field.options.bSPIffNo1stSP = 1;
499 		} else if(!strcmp((char*)Buf, "compressspace")) {
500 			pTpe-&gt;data.field.options.bCompressSP = 1;
501 		} else if(!strcmp((char*)Buf, "escape-cc")) {
502 			pTpe-&gt;data.field.options.bEscapeCC = 1;
503 		} else if(!strcmp((char*)Buf, "drop-cc")) {
504 			pTpe-&gt;data.field.options.bDropCC = 1;
505 		} else if(!strcmp((char*)Buf, "space-cc")) {
506 			pTpe-&gt;data.field.options.bSpaceCC = 1;
507 		} else if(!strcmp((char*)Buf, "drop-last-lf")) {
508 			pTpe-&gt;data.field.options.bDropLastLF = 1;
509 		} else if(!strcmp((char*)Buf, "secpath-drop")) {
510 			pTpe-&gt;data.field.options.bSecPathDrop = 1;
511 		} else if(!strcmp((char*)Buf, "secpath-replace")) {
512 			pTpe-&gt;data.field.options.bSecPathReplace = 1;
513 		} else if(!strcmp((char*)Buf, "pos-end-relative")) {
514 			pTpe-&gt;data.field.options.bFromPosEndRelative = 1;
515 		} else if(!strcmp((char*)Buf, "fixed-width")) {
516 			pTpe-&gt;data.field.options.bFixedWidth = 1;
517 		} else if(!strcmp((char*)Buf, "csv")) {
518 			if(hasFormat(pTpe)) {
519 				LogError(0, NO_ERRCODE, "error: can only specify "
520 					"one option out of (json, jsonf, jsonr, jsonfr, csv) - csv ignored");
521 			} else {
522 				pTpe-&gt;data.field.options.bCSV = 1;
523 			}
524 		} else if(!strcmp((char*)Buf, "json")) {
525 			if(hasFormat(pTpe)) {
526 				LogError(0, NO_ERRCODE, "error: can only specify "
527 					"one option out of (json, jsonf, jsonr, jsonfr, csv) - json ignored");
528 			} else {
529 				pTpe-&gt;data.field.options.bJSON = 1;
530 			}
531 		} else if(!strcmp((char*)Buf, "jsonf")) {
532 			if(hasFormat(pTpe)) {
533 				LogError(0, NO_ERRCODE, "error: can only specify "
534 					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonf ignored");
535 			} else {
536 				pTpe-&gt;data.field.options.bJSONf = 1;
537 			}
538 		} else if(!strcmp((char*)Buf, "jsonr")) {
539 			if(hasFormat(pTpe)) {
540 				LogError(0, NO_ERRCODE, "error: can only specify "
541 					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonr ignored");
542 			} else {
543 				pTpe-&gt;data.field.options.bJSONr = 1;
544 			}
545 		} else if(!strcmp((char*)Buf, "jsonfr")) {
546 			if(hasFormat(pTpe)) {
547 				LogError(0, NO_ERRCODE, "error: can only specify "
548 					"one option out of (json, jsonf, jsonr, jsonfr, csv) - jsonfr ignored");
549 			} else {
550 				pTpe-&gt;data.field.options.bJSONfr = 1;
551 			}
552 		} else if(!strcmp((char*)Buf, "mandatory-field")) {
553 			 pTpe-&gt;data.field.options.bMandatory = 1;
554 		} else {
555 			LogError(0, NO_ERRCODE, "template error: invalid field option '%s' "
556 				"specified - ignored", Buf);
557 		 }
558 	}
559 	*pp = p;
560 }
561 static rsRetVal
562 do_Parameter(uchar **pp, struct template *pTpl)
563 {
564 	uchar *p;
565 	cstr_t *pStrProp = NULL;
566 	cstr_t *pStrField = NULL;
567 	struct templateEntry *pTpe;
568 	int iNum;	#ifdef FEATURE_REGEXP
569 	rsRetVal iRetLocal;
570 	int longitud;
571 	unsigned char *regex_char;
572 	unsigned char *regex_end;
573 #endif
574 	DEFiRet;
575 	assert(pp != NULL);
576 	assert(*pp != NULL);
577 	assert(pTpl != NULL);
578 	p = (uchar*) *pp;
579 	CHKiRet(cstrConstruct(&amp;pStrProp));
580 	CHKmalloc(pTpe = tpeConstruct(pTpl));
581 	pTpe-&gt;eEntryType = FIELD;
582 	while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
583 		cstrAppendChar(pStrProp, *p);
584 		++p;
585 	}
586 	cstrFinalize(pStrProp);
587 	CHKiRet(msgPropDescrFill(&amp;pTpe-&gt;data.field.msgProp, cstrGetSzStrNoNULL(pStrProp),
588 		cstrLen(pStrProp)));
589 	if(*p == ':') {
590 		pTpe-&gt;bComplexProcessing = 1;
591 		++p; #ifdef FEATURE_REGEXP
592 		if(*p == 'R') {
593 			++p;	
594 			if(*p == ',') {
595 				++p; 				if(p[0] == 'B' &amp;&amp; p[1] == 'R' &amp;&amp; p[2] == 'E' &amp;&amp; (p[3] == ',' || p[3] == ':')) {
596 					pTpe-&gt;data.field.typeRegex = TPL_REGEX_BRE;
597 					p += 3; 				} else if(p[0] == 'E' &amp;&amp; p[1] == 'R' &amp;&amp; p[2] == 'E' &amp;&amp; (p[3] == ',' || p[3] == ':')) {
598 					pTpe-&gt;data.field.typeRegex = TPL_REGEX_ERE;
599 					p += 3; 				} else {
600 					LogError(0, NO_ERRCODE, "error: invalid regular expression "
601 							"type, rest of line %s", (char*) p);
602 				}
603 			}
604 			pTpe-&gt;data.field.iSubMatchToUse = 0;
605 			if(*p == ',') {
606 				++p; 				if(isdigit((int) *p)) {
607 					pTpe-&gt;data.field.iSubMatchToUse = *p - '0';
608 					++p; 				}
609 			}
610 			if(*p == ',') {
611 				++p; 				if(p[0] == 'D' &amp;&amp; p[1] == 'F' &amp;&amp; p[2] == 'L' &amp;&amp; p[3] == 'T'
612 				   &amp;&amp; (p[4] == ',' || p[4] == ':')) {
613 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_DFLTSTR;
614 					p += 4; 				} else if(p[0] == 'B' &amp;&amp; p[1] == 'L' &amp;&amp; p[2] == 'A' &amp;&amp; p[3] == 'N' &amp;&amp; p[4] == 'K'
615 				          &amp;&amp; (p[5] == ',' || p[5] == ':')) {
616 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_BLANK;
617 					p += 5; 				} else if(p[0] == 'F' &amp;&amp; p[1] == 'I' &amp;&amp; p[2] == 'E' &amp;&amp; p[3] == 'L' &amp;&amp; p[4] == 'D'
618 				          &amp;&amp; (p[5] == ',' || p[5] == ':')) {
619 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_WHOLE_FIELD;
620 					p += 5; 				} else if(p[0] == 'Z' &amp;&amp; p[1] == 'E' &amp;&amp; p[2] == 'R' &amp;&amp; p[3] == 'O'
621 				          &amp;&amp; (p[4] == ',' || p[4] == ':')) {
622 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_ZERO;
623 					p += 4; 				} else if(p[0] == ',') { 					pTpe-&gt;data.field.nomatchAction = TPL_REGEX_NOMATCH_USE_DFLTSTR;
624 				} else {
625 					LogError(0, NO_ERRCODE, "template %s error: invalid regular "
626 						"expression type, rest of line %s",
627 						pTpl-&gt;pszName, (char*) p);
628 				}
629 			}
630 			pTpe-&gt;data.field.iMatchToUse = 0;
631 			if(*p == ',') {
632 				++p; 				if(isdigit((int) *p)) {
633 					pTpe-&gt;data.field.iMatchToUse = *p - '0';
634 					++p; 				}
635 			}
636 			if(*p != ':') {
637 				LogError(0, NO_ERRCODE, "error: invalid character in frompos "
638 						"after \"R\", property: '%%%s'", (char*) *pp);
639 			} else {
640 				pTpe-&gt;data.field.has_regex = 1;
641 				dbgprintf("we have a regexp and use match #%d, submatch #%d\n",
642 					  pTpe-&gt;data.field.iMatchToUse, pTpe-&gt;data.field.iSubMatchToUse);
643 			}
644 		} else {
645 #endif 			if(*p == 'F') {
646 #ifdef STRICT_GPLV3
647 				pTpe-&gt;data.field.field_expand = 0;
648 #endif
649 				++p; 				if (*p == ':') {
650 					pTpe-&gt;data.field.has_fields = 1;
651 					pTpe-&gt;data.field.field_delim = 9;
652 				} else if (*p == ',') {
653 					pTpe-&gt;data.field.has_fields = 1;
654 					if(!isdigit((int)*p)) {
655 						LogError(0, NO_ERRCODE, "error: invalid character in "
656 "frompos after \"F,\", property: '%%%s' - using 9 (HT) as field delimiter",
657 						    (char*) *pp);
658 						pTpe-&gt;data.field.field_delim = 9;
659 					} else {
660 						iNum = 0;
661 						while(isdigit((int)*p))
662 							iNum = iNum * 10 + *p++ - '0';
663 						if(iNum &lt; 0 || iNum &gt; 255) {
664 							LogError(0, NO_ERRCODE, "error: non-USASCII delimiter "
665 "character value %d in template - using 9 (HT) as substitute", iNum);
666 							pTpe-&gt;data.field.field_delim = 9;
667 						} else {
668 							pTpe-&gt;data.field.field_delim = iNum;
669 #							ifdef STRICT_GPLV3
670 							if (*p == '+') {
671 								pTpe-&gt;data.field.field_expand = 1;
672 								p ++;
673 							}
674 #							endif
675 							if(*p == ',') { 								++p;
676 								iNum = 0;
677 								while(isdigit((int)*p))
678 									iNum = iNum * 10 + *p++ - '0';
679 								pTpe-&gt;data.field.iFromPos = iNum;
680 							} else if(*p != ':') {
681 								parser_errmsg("error: invalid character "
682 								"'%c' in frompos after \"F,\", property: '%s' "
683 								"be sure to use DECIMAL character "
684 								"codes!", *p, (char*) *pp);
685 								ABORT_FINALIZE(RS_RET_SYNTAX_ERROR);
686 							}
687 						}
688 					}
689 				} else {
690 					LogError(0, NO_ERRCODE, "error: invalid character in frompos "
691 						"after \"F\", property: '%%%s'", (char*) *pp);
692 				}
693 			} else {
694 				iNum = 0;
695 				while(isdigit((int)*p))
696 					iNum = iNum * 10 + *p++ - '0';
697 				pTpe-&gt;data.field.iFromPos = iNum;
698 				while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
699 					dbgprintf("error: extra character in frompos: '%s'\n", p);
700 					++p;
701 				}
702 			}
703 #ifdef FEATURE_REGEXP
704 		}
705 #endif 	}
706 	if(*p == ':') {
707 		++p; 
708 #ifdef FEATURE_REGEXP
709 		if (pTpe-&gt;data.field.has_regex) {
710 			dbgprintf("debug: has regex \n");
711 			regex_end = (unsigned char*) strstr((char*)p, "--end");
712 			if (regex_end == NULL) {
713 				dbgprintf("error: can not find regex end in: '%s'\n", p);
714 				pTpe-&gt;data.field.has_regex = 0;
715 			} else {
716 				longitud = regex_end - p;
717 				regex_char = (unsigned char *) malloc(longitud + 1);
718 				if(regex_char == NULL) {
719 					dbgprintf("Could not allocate memory for template parameter!\n");
720 					pTpe-&gt;data.field.has_regex = 0;
721 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
722 				}
723 				memcpy(regex_char, p, longitud);
724 				regex_char[longitud] = '\0';
725 				dbgprintf("debug: regex detected: '%s'\n", regex_char);
726 				if((iRetLocal = objUse(regexp, LM_REGEXP_FILENAME)) == RS_RET_OK) {
727 					int iOptions;
728 					iOptions = (pTpe-&gt;data.field.typeRegex == TPL_REGEX_ERE) ? REG_EXTENDED : 0;
729 					int errcode;
730 					if((errcode = regexp.regcomp(&amp;(pTpe-&gt;data.field.re),
731 						(char*) regex_char, iOptions) != 0)) {
732 						char errbuff[512];
733 						regexp.regerror(errcode, &amp;(pTpe-&gt;data.field.re),
734 							errbuff, sizeof(errbuff));
735 						DBGPRINTF("Template.c: Error in regular expression: %s\n", errbuff);
736 						pTpe-&gt;data.field.has_regex = 2;
737 					}
738 				} else {
739 					dbgprintf("error %d trying to load regexp library - this may be desired "
740 					"and thus OK", iRetLocal);
741 					if(bFirstRegexpErrmsg) {
742 						bFirstRegexpErrmsg = 0;
743 						LogError(0, NO_ERRCODE, "regexp library could not be loaded "
744 							"(error %d), regexp ignored", iRetLocal);
745 					}
746 					pTpe-&gt;data.field.has_regex = 2;
747 				}
748 				free(regex_char);
749 			}
750 		} else if(*p == '$') {
751 			pTpe-&gt;data.field.iToPos = 9999999;
752 		} else {
753 #endif 
754 			if(pTpe-&gt;data.field.has_fields == 1) {
755 				iNum = 0;
756 				while(isdigit((int)*p))
757 					iNum = iNum * 10 + *p++ - '0';
758 				pTpe-&gt;data.field.iFieldNr = iNum;
759 				if(*p == ',') { 					++p;
760 					iNum = 0;
761 					while(isdigit((int)*p))
762 						iNum = iNum * 10 + *p++ - '0';
763 					pTpe-&gt;data.field.iToPos = iNum;
764 				}
765 			} else {
766 				iNum = 0;
767 				while(isdigit((int)*p))
768 					iNum = iNum * 10 + *p++ - '0';
769 				pTpe-&gt;data.field.iToPos = iNum;
770 			}
771 			while(*p &amp;&amp; *p != '%' &amp;&amp; *p != ':') {
772 				dbgprintf("error: extra character in frompos: '%s'\n", p);
773 				++p;
774 			}
775 #ifdef FEATURE_REGEXP
776 		}
777 #endif 	}
778 	if(*p == ':') {
779 		++p; 		doOptions(&amp;p, pTpe);
780 	}
781 	if(pTpe-&gt;data.field.options.bFromPosEndRelative) {
782 		if(pTpe-&gt;data.field.iToPos &gt; pTpe-&gt;data.field.iFromPos) {
783 			iNum = pTpe-&gt;data.field.iToPos;
784 			pTpe-&gt;data.field.iToPos = pTpe-&gt;data.field.iFromPos;
785 			pTpe-&gt;data.field.iFromPos = iNum;
786 		}
787 	} else {
788 		if(pTpe-&gt;data.field.iToPos &lt; pTpe-&gt;data.field.iFromPos) {
789 			iNum = pTpe-&gt;data.field.iToPos;
790 			pTpe-&gt;data.field.iToPos = pTpe-&gt;data.field.iFromPos;
791 			pTpe-&gt;data.field.iFromPos = iNum;
792 		}
793 	}
794 	if(*p == ':') {
795 		++p; 		CHKiRet(cstrConstruct(&amp;pStrField));
796 		while(*p != ':' &amp;&amp; *p != '%' &amp;&amp; *p != '\0') {
797 			cstrAppendChar(pStrField, *p);
798 			++p;
799 		}
800 		cstrFinalize(pStrField);
801 	}
802 	if(pStrField == NULL) {
803 		if(pTpe-&gt;data.field.msgProp.id == PROP_CEE || pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR) {
804 			pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrProp)+2);
805 			pTpe-&gt;lenFieldName = cstrLen(pStrProp)-2;
806 		} else {
807 			pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrProp));
808 			pTpe-&gt;lenFieldName = cstrLen(pStrProp);
809 		}
810 	} else {
811 		pTpe-&gt;fieldName = ustrdup(cstrGetSzStrNoNULL(pStrField));
812 		pTpe-&gt;lenFieldName = ustrlen(pTpe-&gt;fieldName);
813 		cstrDestruct(&amp;pStrField);
814 	}
815 	if(pTpe-&gt;fieldName == NULL) {
816 		DBGPRINTF("template/do_Parameter: fieldName is NULL!\n");
817 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
818 	}
819 	if(*p) ++p; 	*pp = p;
820 finalize_it:
821 	if(pStrProp != NULL)
822 		cstrDestruct(&amp;pStrProp);
823 	RETiRet;
824 }
825 static rsRetVal
826 tplAddTplMod(struct template *pTpl, uchar** ppRestOfConfLine)
827 {
828 	uchar *pSrc;
829 	uchar szMod[2048];
830 	unsigned lenMod;
831 	strgen_t *pStrgen;
832 	DEFiRet;
833 	pSrc = *ppRestOfConfLine;
834 	lenMod = 0;
835 	while(*pSrc &amp;&amp; !isspace(*pSrc) &amp;&amp; lenMod &lt; sizeof(szMod) - 1) {
836 		szMod[lenMod] = *pSrc++;
837 		lenMod++;
838 	}
839 	szMod[lenMod] = '\0';
840 	*ppRestOfConfLine = pSrc;
841 	CHKiRet(strgen.FindStrgen(&amp;pStrgen, szMod));
842 	pTpl-&gt;pStrgen = pStrgen-&gt;pModule-&gt;mod.sm.strgen;
843 	DBGPRINTF("template bound to strgen '%s'\n", szMod);
844 	if(lenMod &gt; 6 &amp;&amp; !strcasecmp((char*) szMod + lenMod - 7, ",stdsql")) {
845 		pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
846 		DBGPRINTF("strgen supports the stdsql option\n");
847 	} else if(lenMod &gt; 3 &amp;&amp; !strcasecmp((char*) szMod+ lenMod - 4, ",sql")) {
848 		pTpl-&gt;optFormatEscape = SQL_ESCAPE;
849 		DBGPRINTF("strgen supports the sql option\n");
850 	} else if(lenMod &gt; 4 &amp;&amp; !strcasecmp((char*) szMod+ lenMod - 4, ",json")) {
851 		pTpl-&gt;optFormatEscape = JSON_ESCAPE;
852 		DBGPRINTF("strgen supports the json option\n");
853 	}
854 finalize_it:
855 	RETiRet;
856 }
857 struct template *tplAddLine(rsconf_t *conf, const char* pName, uchar** ppRestOfConfLine)
858 {
859 	struct template *pTpl;
860 	unsigned char *p;
861 	int bDone;
862 	size_t i;
863 	rsRetVal localRet;
864 	assert(pName != NULL);
865 	assert(ppRestOfConfLine != NULL);
866 	if((pTpl = tplConstruct(conf)) == NULL)
867 		return NULL;
868 	DBGPRINTF("tplAddLine processing template '%s'\n", pName);
869 	pTpl-&gt;iLenName = strlen(pName);
870 	pTpl-&gt;pszName = (char*) malloc(pTpl-&gt;iLenName + 1);
871 	if(pTpl-&gt;pszName == NULL) {
872 		dbgprintf("tplAddLine could not alloc memory for template name!");
873 		pTpl-&gt;iLenName = 0;
874 		return NULL;
875 	}
876 	memcpy(pTpl-&gt;pszName, pName, pTpl-&gt;iLenName + 1);
877 	p = *ppRestOfConfLine;
878 	assert(p != NULL);
879 	while(isspace((int)*p))		++p;
880 	switch(*p) {
881 	case '"': 		break;
882 	case '=':
883 		*ppRestOfConfLine = p + 1;
884 		localRet = tplAddTplMod(pTpl, ppRestOfConfLine);
885 		if(localRet != RS_RET_OK) {
886 			LogError(0, localRet, "Template '%s': error %d defining template via strgen module",
887 					pTpl-&gt;pszName, localRet);
888 			*pTpl-&gt;pszName = '\0';
889 		}
890 		return NULL;
891 	default:
892 		dbgprintf("Template '%s' invalid, does not start with '\"'!\n", pTpl-&gt;pszName);
893 		*pTpl-&gt;pszName = '\0';
894 		return NULL;
895 	}
896 	++p;
897 	bDone = *p ? 0 : 1;
898 	while(!bDone) {
899 		switch(*p) {
900 			case '\0':
901 				bDone = 1;
902 				break;
903 			case '%': 				++p; 				if(do_Parameter(&amp;p, pTpl) != RS_RET_OK) {
904 					dbgprintf("tplAddLine error: parameter invalid");
905 					return NULL;
906 				};
907 				break;
908 			default: 				do_Constant(&amp;p, pTpl, 1);
909 				break;
910 		}
911 		if(*p == '"') {			++p;				bDone = 1;
912 		}
913 	}
914 	while(*p) {
915 		while(isspace((int)*p))			++p;
916 		if(*p != ',')
917 			break;
918 		++p; 
919 		while(isspace((int)*p))			++p;
920 		char optBuf[128] = { '\0' }; 		i = 0;
921 		while((i &lt; (sizeof(optBuf) - 1))
922 		      &amp;&amp; *p &amp;&amp; *p != '=' &amp;&amp; *p !=',' &amp;&amp; *p != '\n') {
923 			optBuf[i++] = tolower((int)*p);
924 			++p;
925 		}
926 		optBuf[i] = '\0';
927 		if(*p == '\n')
928 			++p;
929 		if(!strcmp(optBuf, "stdsql")) {
930 			pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
931 		} else if(!strcmp(optBuf, "json")) {
932 			pTpl-&gt;optFormatEscape = JSON_ESCAPE;
933 		} else if(!strcmp(optBuf, "sql")) {
934 			pTpl-&gt;optFormatEscape = SQL_ESCAPE;
935 		} else if(!strcmp(optBuf, "nosql")) {
936 			pTpl-&gt;optFormatEscape = NO_ESCAPE;
937 		} else if(!strcmp(optBuf, "casesensitive")) {
938 			pTpl-&gt;optCaseSensitive = 1;
939 		} else {
940 			dbgprintf("Invalid option '%s' ignored.\n", optBuf);
941 		}
942 	}
943 	*ppRestOfConfLine = p;
944 	apply_case_sensitivity(pTpl);
945 	return(pTpl);
946 }
947 static rsRetVal
948 createConstantTpe(struct template *pTpl, struct cnfobj *o)
949 {
950 	struct templateEntry *pTpe;
951 	es_str_t *value = NULL; 	int i;
952 	int is_jsonf = 0;
953 	struct cnfparamvals *pvals = NULL;
954 	struct json_object *json = NULL;
955 	struct json_object *jval = NULL;
956 	uchar *outname = NULL;
957 	DEFiRet;
958 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblkConstant, NULL);
959 	if(pvals == NULL) {
960 		parser_errmsg("error processing template parameters");
961 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
962 	}
963 	cnfparamsPrint(&amp;pblkConstant, pvals);
964 	for(i = 0 ; i &lt; pblkConstant.nParams ; ++i) {
965 		if(!pvals[i].bUsed)
966 			continue;
967 		if(!strcmp(pblkConstant.descr[i].name, "value")) {
968 			value = pvals[i].val.d.estr;
969 		} else if(!strcmp(pblkConstant.descr[i].name, "outname")) {
970 			outname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
971 		} else if(!strcmp(pblkConstant.descr[i].name, "format")) {
972 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonf", sizeof("jsonf")-1)) {
973 				is_jsonf = 1;
974 			} else {
975 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
976 				LogError(0, RS_RET_ERR, "invalid format type '%s' for constant",
977 					typeStr);
978 				free(typeStr);
979 				ABORT_FINALIZE(RS_RET_ERR);
980 			}
981 		} else {
982 			LogError(0, RS_RET_INTERNAL_ERROR,
983 				"template:constantTpe: program error, non-handled "
984 				"param '%s'\n", pblkConstant.descr[i].name);
985 		}
986 	}
987 	if(is_jsonf &amp;&amp; outname == NULL) {
988 		parser_errmsg("constant set to format jsonf, but outname not specified - aborting");
989 		ABORT_FINALIZE(RS_RET_ERR);
990 	}
991 	assert(value != NULL);
992 	CHKmalloc(pTpe = tpeConstruct(pTpl));
993 	es_unescapeStr(value);
994 	pTpe-&gt;eEntryType = CONSTANT;
995 	pTpe-&gt;fieldName = outname;
996 	if(outname != NULL)
997 		pTpe-&gt;lenFieldName = ustrlen(outname);
998 	if(is_jsonf) {
999 		CHKmalloc(json = json_object_new_object());
1000 		const char *sz = es_str2cstr(value, NULL);
1001 		CHKmalloc(sz);
1002 		CHKmalloc(jval = json_object_new_string(sz));
1003 		free((void*)sz);
1004 		json_object_object_add(json, (char*)outname, jval);
1005 		CHKmalloc(sz = json_object_get_string(json));
1006 		const size_t len_json = strlen(sz) - 4;
1007 		CHKmalloc(pTpe-&gt;data.constant.pConstant = (uchar*) strndup(sz+2, len_json));
1008 		pTpe-&gt;data.constant.iLenConstant = ustrlen(pTpe-&gt;data.constant.pConstant);
1009 		json_object_put(json);
1010 	} else {
1011 		pTpe-&gt;data.constant.iLenConstant = es_strlen(value);
1012 		pTpe-&gt;data.constant.pConstant = (uchar*)es_str2cstr(value, NULL);
1013 	}
1014 finalize_it:
1015 	if(pvals != NULL)
1016 		cnfparamvalsDestruct(pvals, &amp;pblkConstant);
1017 	RETiRet;
1018 }
1019 static rsRetVal
1020 createPropertyTpe(struct template *pTpl, struct cnfobj *o)
1021 {
1022 	struct templateEntry *pTpe;
1023 	uchar *name = NULL;
1024 	uchar *outname = NULL;
1025 	int i;
1026 	int droplastlf = 0;
1027 	int spifno1stsp = 0;
1028 	int mandatory = 0;
1029 	int frompos = -1;
1030 	int topos = -1;
1031 	int fieldnum = -1;
1032 	int fielddelim = 9; 	int fixedwidth = 0;
1033 	int re_matchToUse = 0;
1034 	int re_submatchToUse = 0;
1035 	int bComplexProcessing = 0;
1036 	int bPosRelativeToEnd = 0;
1037 	int bDateInUTC = 0;
1038 	int bCompressSP = 0;
1039 	unsigned dataType = TPE_DATATYPE_STRING;
1040 	unsigned onEmpty = TPE_DATAEMPTY_KEEP;
1041 	char *re_expr = NULL;
1042 	struct cnfparamvals *pvals = NULL;
1043 	enum {F_NONE, F_CSV, F_JSON, F_JSONF, F_JSONR, F_JSONFR} formatType = F_NONE;
1044 	enum {CC_NONE, CC_ESCAPE, CC_SPACE, CC_DROP} controlchr = CC_NONE;
1045 	enum {SP_NONE, SP_DROP, SP_REPLACE} secpath = SP_NONE;
1046 	enum tplFormatCaseConvTypes caseconv = tplCaseConvNo;
1047 	enum tplFormatTypes datefmt = tplFmtDefault;
1048 	enum tplRegexType re_type = TPL_REGEX_BRE;
1049 	enum tlpRegexNoMatchType re_nomatchType = TPL_REGEX_NOMATCH_USE_DFLTSTR;
1050 	DEFiRet;
1051 <a name="1"></a>
1052 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblkProperty, NULL);
1053 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(pvals == NULL) {
1054 		parser_errmsg("error processing template entry config parameters");
1055 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1056 	}
1057 	cnfparamsPrint(&amp;pblkProperty, pvals);
1058 	for(i = 0 ; i &lt; pblkProperty.nParams ; ++i) {
1059 		if(!pvals[i].bUsed)
1060 			continue;
1061 		if(!strcmp(pblkProperty.descr[i].name, "name")) {
1062 			name = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1063 		} else if(!strcmp(pblkProperty.descr[i].name, "datatype")) {</b></font>
1064 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"string", sizeof("string")-1)) {
1065 				dataType = TPE_DATATYPE_STRING;
1066 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"number", sizeof("number")-1)) {
1067 				dataType = TPE_DATATYPE_NUMBER;
1068 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"bool", sizeof("bool")-1)) {
1069 				dataType = TPE_DATATYPE_BOOL;
1070 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"auto", sizeof("auto")-1)) {
1071 				dataType = TPE_DATATYPE_AUTO;
1072 			} else {
1073 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1074 				LogError(0, RS_RET_ERR, "invalid dataType '%s' for property",
1075 					typeStr);
1076 				free(typeStr);
1077 				ABORT_FINALIZE(RS_RET_ERR);
1078 			}
1079 		} else if(!strcmp(pblkProperty.descr[i].name, "onempty")) {
1080 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"keep", sizeof("keep")-1)) {
1081 				onEmpty = TPE_DATAEMPTY_KEEP;
1082 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"skip", sizeof("skip")-1)) {
1083 				onEmpty = TPE_DATAEMPTY_SKIP;
1084 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"null", sizeof("null")-1)) {
1085 				onEmpty = TPE_DATAEMPTY_NULL;
1086 			} else {
1087 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1088 				LogError(0, RS_RET_ERR, "invalid onEmpty value '%s' for property",
1089 					typeStr);
1090 				free(typeStr);
1091 				ABORT_FINALIZE(RS_RET_ERR);
1092 			}
1093 		} else if(!strcmp(pblkProperty.descr[i].name, "droplastlf")) {
1094 			droplastlf = pvals[i].val.d.n;
1095 			bComplexProcessing = 1;
1096 		} else if(!strcmp(pblkProperty.descr[i].name, "fixedwidth")) {
1097 			fixedwidth = pvals[i].val.d.n;
1098 			bComplexProcessing = 1;
1099 		} else if(!strcmp(pblkProperty.descr[i].name, "mandatory")) {
1100 			mandatory = pvals[i].val.d.n;
1101 		} else if(!strcmp(pblkProperty.descr[i].name, "spifno1stsp")) {
1102 			spifno1stsp = pvals[i].val.d.n;
1103 			bComplexProcessing = 1;
1104 		} else if(!strcmp(pblkProperty.descr[i].name, "outname")) {
1105 			outname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1106 		} else if(!strcmp(pblkProperty.descr[i].name, "position.from")) {
1107 			frompos = pvals[i].val.d.n;
1108 			bComplexProcessing = 1;
1109 		} else if(!strcmp(pblkProperty.descr[i].name, "position.to")) {
1110 			topos = pvals[i].val.d.n;
1111 			bComplexProcessing = 1;
1112 		} else if(!strcmp(pblkProperty.descr[i].name, "position.relativetoend")) {
1113 			bPosRelativeToEnd = pvals[i].val.d.n;
1114 		} else if(!strcmp(pblkProperty.descr[i].name, "field.number")) {
1115 			fieldnum = pvals[i].val.d.n;
1116 			bComplexProcessing = 1;
1117 		} else if(!strcmp(pblkProperty.descr[i].name, "field.delimiter")) {
1118 			fielddelim = pvals[i].val.d.n;
1119 			bComplexProcessing = 1;
1120 		} else if(!strcmp(pblkProperty.descr[i].name, "regex.expression")) {
1121 			re_expr = es_str2cstr(pvals[i].val.d.estr, NULL);
1122 			bComplexProcessing = 1;
1123 		} else if(!strcmp(pblkProperty.descr[i].name, "regex.type")) {
1124 			bComplexProcessing = 1;
1125 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"BRE", sizeof("BRE")-1)) {
1126 				re_type = TPL_REGEX_BRE;
1127 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ERE", sizeof("ERE")-1)) {
1128 				re_type = TPL_REGEX_ERE;
1129 			} else {
1130 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1131 				LogError(0, RS_RET_ERR, "invalid regex.type '%s' for property",
1132 					typeStr);
1133 				free(typeStr);
1134 				ABORT_FINALIZE(RS_RET_ERR);
1135 			}
1136 		} else if(!strcmp(pblkProperty.descr[i].name, "regex.nomatchmode")) {
1137 			bComplexProcessing = 1;
1138 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"DFLT", sizeof("DFLT")-1)) {
1139 				re_nomatchType = TPL_REGEX_NOMATCH_USE_DFLTSTR;
1140 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"BLANK", sizeof("BLANK")-1)) {
1141 				re_nomatchType = TPL_REGEX_NOMATCH_USE_BLANK;
1142 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"FIELD", sizeof("FIELD")-1)) {
1143 				re_nomatchType = TPL_REGEX_NOMATCH_USE_WHOLE_FIELD;
1144 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ZERO", sizeof("ZERO")-1)) {
1145 				re_nomatchType = TPL_REGEX_NOMATCH_USE_ZERO;
1146 			} else {
1147 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1148 				LogError(0, RS_RET_ERR, "invalid format type '%s' for property",
1149 					typeStr);
1150 				free(typeStr);
1151 				ABORT_FINALIZE(RS_RET_ERR);
1152 			}
1153 		} else if(!strcmp(pblkProperty.descr[i].name, "regex.match")) {
1154 			bComplexProcessing = 1;
1155 			re_matchToUse = pvals[i].val.d.n;
1156 		} else if(!strcmp(pblkProperty.descr[i].name, "regex.submatch")) {
1157 			bComplexProcessing = 1;
1158 			re_submatchToUse = pvals[i].val.d.n;
1159 		} else if(!strcmp(pblkProperty.descr[i].name, "format")) {
1160 			bComplexProcessing = 1;
1161 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"csv", sizeof("csv")-1)) {
1162 				formatType = F_CSV;
1163 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"json", sizeof("json")-1)) {
1164 				formatType = F_JSON;
1165 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonf", sizeof("jsonf")-1)) {
1166 				formatType = F_JSONF;
1167 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonr", sizeof("jsonr")-1)) {
1168 				formatType = F_JSONR;
1169 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"jsonfr", sizeof("jsonfr")-1)) {
1170 				formatType = F_JSONFR;
1171 			} else {
1172 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1173 				LogError(0, RS_RET_ERR, "invalid format type '%s' for property",
1174 					typeStr);
1175 				free(typeStr);
1176 				ABORT_FINALIZE(RS_RET_ERR);
1177 			}
1178 		} else if(!strcmp(pblkProperty.descr[i].name, "controlcharacters")) {
1179 			bComplexProcessing = 1;
1180 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"escape", sizeof("escape")-1)) {
1181 				controlchr = CC_ESCAPE;
1182 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"space", sizeof("space")-1)) {
1183 				controlchr = CC_SPACE;
1184 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"drop", sizeof("drop")-1)) {
1185 				controlchr = CC_DROP;
1186 			} else {
1187 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1188 				LogError(0, RS_RET_ERR, "invalid controlcharacter mode '%s' for property",
1189 					typeStr);
1190 				free(typeStr);
1191 				ABORT_FINALIZE(RS_RET_ERR);
1192 			}
1193 		} else if(!strcmp(pblkProperty.descr[i].name, "securepath")) {
1194 			bComplexProcessing = 1;
1195 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"drop", sizeof("drop")-1)) {
1196 				secpath = SP_DROP;
1197 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"replace", sizeof("replace")-1)) {
1198 				secpath = SP_REPLACE;
1199 			} else {
1200 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1201 				LogError(0, RS_RET_ERR, "invalid securepath mode '%s' for property",
1202 					typeStr);
1203 				free(typeStr);
1204 				ABORT_FINALIZE(RS_RET_ERR);
1205 			}
1206 		} else if(!strcmp(pblkProperty.descr[i].name, "caseconversion")) {
1207 			bComplexProcessing = 1;
1208 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"lower", sizeof("lower")-1)) {
1209 				caseconv = tplCaseConvLower;
1210 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"upper", sizeof("upper")-1)) {
1211 				caseconv = tplCaseConvUpper;
1212 			} else {
1213 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1214 				LogError(0, RS_RET_ERR, "invalid caseconversion type '%s' for property",
1215 					typeStr);
1216 				free(typeStr);
1217 				ABORT_FINALIZE(RS_RET_ERR);
1218 			}
1219 		} else if(!strcmp(pblkProperty.descr[i].name, "compressspace")) {
1220 			bComplexProcessing = 1;
1221 			bCompressSP = pvals[i].val.d.n;
1222 		} else if(!strcmp(pblkProperty.descr[i].name, "date.inutc")) {
1223 			bDateInUTC = pvals[i].val.d.n;
1224 		} else if(!strcmp(pblkProperty.descr[i].name, "dateformat")) {
1225 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"mysql", sizeof("mysql")-1)) {
1226 				datefmt = tplFmtMySQLDate;
1227 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"pgsql", sizeof("pgsql")-1)) {
1228 				datefmt = tplFmtPgSQLDate;
1229 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3164", sizeof("rfc3164")-1)) {
1230 				datefmt = tplFmtRFC3164Date;
1231 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3164-buggyday",
1232 				sizeof("rfc3164-buggyday")-1)) {
1233 				datefmt = tplFmtRFC3164BuggyDate;
1234 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rfc3339", sizeof("rfc3339")-1)) {
1235 				datefmt = tplFmtRFC3339Date;
1236 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"unixtimestamp",
1237 				sizeof("unixtimestamp")-1)) {
1238 				datefmt = tplFmtUnixDate;
1239 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"subseconds", sizeof("subseconds")-1)) {
1240 				datefmt = tplFmtSecFrac;
1241 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"wdayname", sizeof("wdayname")-1)) {
1242 				datefmt = tplFmtWDayName;
1243 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"wday", sizeof("wday")-1)) {
1244 				datefmt = tplFmtWDay;
1245 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"year", sizeof("year")-1)) {
1246 				datefmt = tplFmtYear;
1247 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"month", sizeof("month")-1)) {
1248 				datefmt = tplFmtMonth;
1249 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"day", sizeof("day")-1)) {
1250 				datefmt = tplFmtDay;
1251 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"hour", sizeof("hour")-1)) {
1252 				datefmt = tplFmtHour;
1253 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"minute", sizeof("minute")-1)) {
1254 				datefmt = tplFmtMinute;
1255 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"second", sizeof("second")-1)) {
1256 				datefmt = tplFmtSecond;
1257 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffshour", sizeof("tzoffshour")-1)) {
1258 				datefmt = tplFmtTZOffsHour;
1259 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffsmin", sizeof("tzoffsmin")-1)) {
1260 				datefmt = tplFmtTZOffsMin;
1261 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"tzoffsdirection",
1262 				sizeof("tzoffsdirection")-1)) {
1263 				datefmt = tplFmtTZOffsDirection;
1264 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"ordinal", sizeof("ordinal")-1)) {
1265 				datefmt = tplFmtOrdinal;
1266 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"week", sizeof("week")-1)) {
1267 				datefmt = tplFmtWeek;
1268 			} else {
1269 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1270 				LogError(0, RS_RET_ERR, "invalid date format '%s' for property",
1271 					typeStr);
1272 				free(typeStr);
1273 				ABORT_FINALIZE(RS_RET_ERR);
1274 			}
1275 		} else {
1276 			dbgprintf("template:propertyTpe: program error, non-handled "
1277 			  "param '%s'\n", pblkProperty.descr[i].name);
1278 		}
1279 	}
1280 	if (name == NULL) {
1281 		CHKmalloc(name = (uchar*)strdup(""));
1282 	}
1283 	if(outname == NULL) {
1284 		if(ustrlen(name) &gt;= 2 &amp;&amp; !strncmp((char*)name, "$!", 2))
1285 			outname = ustrdup(name + 2);
1286 		else
1287 			outname = ustrdup(name);
1288 	}
1289 	if(topos == -1 &amp;&amp; frompos != -1)
1290 		topos = 2000000000; 	if(frompos == -1 &amp;&amp; topos != -1)
1291 		frompos = 0;
1292 	if(bPosRelativeToEnd) {
1293 		if(topos &gt; frompos) {
1294 			LogError(0, RS_RET_ERR, "position.to=%d is higher than postion.from=%d "
1295 					"in 'relativeToEnd' mode\n", topos, frompos);
1296 			ABORT_FINALIZE(RS_RET_ERR);
1297 		}
1298 	} else {
1299 		if(topos &lt; frompos) {
1300 			LogError(0, RS_RET_ERR, "position.to=%d is lower than postion.from=%d\n",
1301 				topos, frompos);
1302 			ABORT_FINALIZE(RS_RET_ERR);
1303 		}
1304 	}
1305 	if(fieldnum != -1 &amp;&amp; re_expr != NULL) {
1306 		LogError(0, RS_RET_ERR, "both field extraction and regex extraction "
1307 				"specified - this is not possible, remove one");
1308 		ABORT_FINALIZE(RS_RET_ERR);
1309 	}
1310 	CHKmalloc(pTpe = tpeConstruct(pTpl));
1311 	pTpe-&gt;eEntryType = FIELD;
1312 	CHKiRet(msgPropDescrFill(&amp;pTpe-&gt;data.field.msgProp, name, strlen((char*)name)));
1313 	pTpe-&gt;data.field.options.bDropLastLF = droplastlf;
1314 	pTpe-&gt;data.field.options.bSPIffNo1stSP = spifno1stsp;
1315 	pTpe-&gt;data.field.options.bMandatory = mandatory;
1316 	pTpe-&gt;data.field.options.bFixedWidth = fixedwidth;
1317 	pTpe-&gt;data.field.options.dataType = dataType;
1318 	pTpe-&gt;data.field.options.onEmpty = onEmpty;
1319 	pTpe-&gt;data.field.eCaseConv = caseconv;
1320 	switch(formatType) {
1321 	case F_NONE:
1322 		break;
1323 	case F_CSV:
1324 		pTpe-&gt;data.field.options.bCSV = 1;
1325 		break;
1326 	case F_JSON:
1327 		pTpe-&gt;data.field.options.bJSON = 1;
1328 		break;
1329 	case F_JSONF:
1330 		pTpe-&gt;data.field.options.bJSONf = 1;
1331 		break;
1332 	case F_JSONR:
1333 		pTpe-&gt;data.field.options.bJSONr = 1;
1334 		break;
1335 	case F_JSONFR:
1336 		pTpe-&gt;data.field.options.bJSONfr = 1;
1337 		break;
1338 	}
1339 	switch(controlchr) {
1340 	case CC_NONE:
1341 		break;
1342 	case CC_ESCAPE:
1343 		pTpe-&gt;data.field.options.bEscapeCC = 1;
1344 		break;
1345 	case CC_SPACE:
1346 		pTpe-&gt;data.field.options.bSpaceCC = 1;
1347 		break;
1348 	case CC_DROP:
1349 		pTpe-&gt;data.field.options.bDropCC = 1;
1350 		break;
1351 	}
1352 	switch(secpath) {
1353 	case SP_NONE:
1354 		break;
1355 	case SP_DROP:
1356 		pTpe-&gt;data.field.options.bSecPathDrop = 1;
1357 		break;
1358 	case SP_REPLACE:
1359 		pTpe-&gt;data.field.options.bSecPathReplace = 1;
1360 		break;
1361 	}
1362 	pTpe-&gt;fieldName = outname;
1363 	if(outname != NULL)
1364 		pTpe-&gt;lenFieldName = ustrlen(outname);
1365 	outname = NULL;
1366 	pTpe-&gt;bComplexProcessing = bComplexProcessing;
1367 	pTpe-&gt;data.field.eDateFormat = datefmt;
1368 	pTpe-&gt;data.field.options.bDateInUTC = bDateInUTC;
1369 	pTpe-&gt;data.field.options.bCompressSP = bCompressSP;
1370 	if(fieldnum != -1) {
1371 		pTpe-&gt;data.field.has_fields = 1;
1372 		pTpe-&gt;data.field.iFieldNr = fieldnum;
1373 		pTpe-&gt;data.field.field_delim = fielddelim;
1374 	}
1375 	if(frompos != -1) {
1376 		pTpe-&gt;data.field.iFromPos = frompos;
1377 		pTpe-&gt;data.field.iToPos = topos;
1378 		pTpe-&gt;data.field.options.bFromPosEndRelative = bPosRelativeToEnd;
1379 	}
1380 	if(re_expr != NULL) {
1381 		rsRetVal iRetLocal;
1382 		pTpe-&gt;data.field.typeRegex = re_type;
1383 		pTpe-&gt;data.field.nomatchAction = re_nomatchType;
1384 		pTpe-&gt;data.field.iMatchToUse = re_matchToUse;
1385 		pTpe-&gt;data.field.iSubMatchToUse = re_submatchToUse;
1386 		pTpe-&gt;data.field.has_regex = 1;
1387 		if((iRetLocal = objUse(regexp, LM_REGEXP_FILENAME)) == RS_RET_OK) {
1388 			int iOptions;
1389 			iOptions = (pTpe-&gt;data.field.typeRegex == TPL_REGEX_ERE) ? REG_EXTENDED : 0;
1390 			if(regexp.regcomp(&amp;(pTpe-&gt;data.field.re), (char*) re_expr, iOptions) != 0) {
1391 				LogError(0, NO_ERRCODE, "error compiling regex '%s'", re_expr);
1392 				pTpe-&gt;data.field.has_regex = 2;
1393 				ABORT_FINALIZE(RS_RET_ERR);
1394 			}
1395 		} else {
1396 			if(bFirstRegexpErrmsg) { 				bFirstRegexpErrmsg = 0;
1397 				LogError(0, NO_ERRCODE, "regexp library could not be loaded (error %d), "
1398 						"regexp ignored", iRetLocal);
1399 			}
1400 			pTpe-&gt;data.field.has_regex = 2;
1401 			ABORT_FINALIZE(RS_RET_ERR);
1402 		}
1403 	}
1404 finalize_it:
1405 	if(pvals != NULL)
1406 		cnfparamvalsDestruct(pvals, &amp;pblkProperty);
1407 	free(name);
1408 	free(outname);
1409 	RETiRet;
1410 }
1411 static rsRetVal
1412 createListTpl(struct template *pTpl, struct cnfobj *o)
1413 {
1414 	struct objlst *lst;
1415 	DEFiRet;
1416 	dbgprintf("create template from subobjs\n");
1417 	objlstPrint(o-&gt;subobjs);
1418 	for(lst = o-&gt;subobjs ; lst != NULL ; lst = lst-&gt;next) {
1419 		switch(lst-&gt;obj-&gt;objType) {
1420 		case CNFOBJ_PROPERTY:
1421 			CHKiRet(createPropertyTpe(pTpl, lst-&gt;obj));
1422 			break;
1423 		case CNFOBJ_CONSTANT:
1424 			CHKiRet(createConstantTpe(pTpl, lst-&gt;obj));
1425 			break;
1426 		default:dbgprintf("program error: invalid object type %d "
1427 				  "in createLstTpl\n", lst-&gt;obj-&gt;objType);
1428 			break;
1429 		}
1430 		nvlstChkUnused(lst-&gt;obj-&gt;nvlst);
1431 	}
1432 finalize_it:
1433 	RETiRet;
1434 }
1435 rsRetVal ATTR_NONNULL()
1436 tplProcessCnf(struct cnfobj *o)
1437 {
1438 	struct template *pTpl = NULL;
1439 	struct cnfparamvals *pvals = NULL;
1440 	int lenName = 0; 	char *name = NULL;
1441 	uchar *tplStr = NULL;
1442 	uchar *plugin = NULL;
1443 	uchar *p;
1444 	msgPropDescr_t subtree;
1445 	sbool bHaveSubtree = 0;
1446 	enum { T_STRING, T_PLUGIN, T_LIST, T_SUBTREE }
1447 		tplType = T_STRING; 	int i;
1448 	int o_sql=0, o_stdsql=0, o_jsonf=0, o_json=0, o_casesensitive=0; 	int numopts;
1449 	rsRetVal localRet;
1450 	DEFiRet;
1451 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;pblk, NULL);
1452 	if(pvals == NULL) {
1453 		parser_errmsg("error processing template config parameters");
1454 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1455 	}
1456 	cnfparamsPrint(&amp;pblk, pvals);
1457 	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
1458 		if(!pvals[i].bUsed)
1459 			continue;
1460 		if(!strcmp(pblk.descr[i].name, "name")) {
1461 			lenName = es_strlen(pvals[i].val.d.estr);
1462 			name = es_str2cstr(pvals[i].val.d.estr, NULL);
1463 		} else if(!strcmp(pblk.descr[i].name, "type")) {
1464 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"string", sizeof("string")-1)) {
1465 				tplType = T_STRING;
1466 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"plugin", sizeof("plugin")-1)) {
1467 				tplType = T_PLUGIN;
1468 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"list", sizeof("list")-1)) {
1469 				tplType = T_LIST;
1470 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"subtree", sizeof("subtree")-1)) {
1471 				tplType = T_SUBTREE;
1472 			} else {
1473 				uchar *typeStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1474 				LogError(0, RS_RET_ERR, "invalid template type '%s'",
1475 					typeStr);
1476 				free(typeStr);
1477 				ABORT_FINALIZE(RS_RET_ERR);
1478 			}
1479 		} else if(!strcmp(pblk.descr[i].name, "string")) {
1480 			tplStr = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1481 		} else if(!strcmp(pblk.descr[i].name, "subtree")) {
1482 			uchar *st_str = es_getBufAddr(pvals[i].val.d.estr);
1483 			if(st_str[0] != '$' || st_str[1] != '!') {
1484 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
1485 				LogError(0, RS_RET_ERR, "invalid subtree "
1486 					"parameter, variable must start with '$!' but "
1487 					"var name is '%s'", cstr);
1488 				free(cstr);
1489 				free(name); 				ABORT_FINALIZE(RS_RET_ERR);
1490 			} else {
1491 				uchar *cstr;
1492 				cstr  = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1493 				CHKiRet(msgPropDescrFill(&amp;subtree, cstr, ustrlen(cstr)));
1494 				free(cstr);
1495 				bHaveSubtree = 1;
1496 			}
1497 		} else if(!strcmp(pblk.descr[i].name, "plugin")) {
1498 			plugin = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1499 		} else if(!strcmp(pblk.descr[i].name, "option.stdsql")) {
1500 			o_stdsql = pvals[i].val.d.n;
1501 		} else if(!strcmp(pblk.descr[i].name, "option.sql")) {
1502 			o_sql = pvals[i].val.d.n;
1503 		} else if(!strcmp(pblk.descr[i].name, "option.json")) {
1504 			o_json = pvals[i].val.d.n;
1505 		} else if(!strcmp(pblk.descr[i].name, "option.jsonf")) {
1506 <a name="2"></a>			o_jsonf = pvals[i].val.d.n;
1507 		} else if(!strcmp(pblk.descr[i].name, "option.casesensitive")) {
1508 			o_casesensitive = pvals[i].val.d.n;
1509 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else {
1510 			dbgprintf("template: program error, non-handled "
1511 			  "param '%s'\n", pblk.descr[i].name);
1512 		}
1513 	}
1514 	if(name == NULL) {
1515 		DBGPRINTF("template/tplProcessConf: logic error name == NULL - pblk wrong?\n");
1516 		ABORT_FINALIZE(RS_RET_ERR);
1517 	}
1518 	if(tplStr  == NULL) {</b></font>
1519 		if(tplType == T_STRING) {
1520 			LogError(0, RS_RET_ERR, "template '%s' of type string needs "
1521 				"string parameter", name);
1522 			ABORT_FINALIZE(RS_RET_ERR);
1523 		}
1524 	} else {
1525 		if(tplType != T_STRING) {
1526 			LogError(0, RS_RET_ERR, "template '%s' is not a string "
1527 				"template but has a string specified - ignored", name);
1528 		}
1529 	}
1530 	if(plugin  == NULL) {
1531 		if(tplType == T_PLUGIN) {
1532 			LogError(0, RS_RET_ERR, "template '%s' of type plugin needs "
1533 				"plugin parameter", name);
1534 			ABORT_FINALIZE(RS_RET_ERR);
1535 		}
1536 	} else {
1537 		if(tplType != T_PLUGIN) {
1538 			LogError(0, RS_RET_ERR, "template '%s' is not a plugin "
1539 				"template but has a plugin specified - ignored", name);
1540 		}
1541 	}
1542 	if(!bHaveSubtree) {
1543 		if(tplType == T_SUBTREE) {
1544 			LogError(0, RS_RET_ERR, "template '%s' of type subtree needs "
1545 				"subtree parameter", name);
1546 			ABORT_FINALIZE(RS_RET_ERR);
1547 		}
1548 	} else {
1549 		if(tplType != T_SUBTREE) {
1550 			LogError(0, RS_RET_ERR, "template '%s' is not a subtree "
1551 				"template but has a subtree specified - ignored", name);
1552 		}
1553 	}
1554 	if(o-&gt;subobjs  == NULL) {
1555 		if(tplType == T_LIST) {
1556 			LogError(0, RS_RET_ERR, "template '%s' of type list has "
1557 				"no parameters specified", name);
1558 			ABORT_FINALIZE(RS_RET_ERR);
1559 		}
1560 	} else {
1561 		if(tplType != T_LIST) {
1562 			LogError(0, RS_RET_ERR, "template '%s' is not a list "
1563 				"template but has parameters specified - ignored", name);
1564 		}
1565 	}
1566 	numopts = 0;
1567 	if(o_sql) ++numopts;
1568 	if(o_stdsql) ++numopts;
1569 	if(o_json) ++numopts;
1570 	if(o_jsonf) ++numopts;
1571 	if(numopts &gt; 1) {
1572 		LogError(0, RS_RET_ERR, "template '%s' has multiple incompatible "
1573 			"options of sql, stdsql or json specified", name);
1574 		ABORT_FINALIZE(RS_RET_ERR);
1575 	}
1576 	if((pTpl = tplConstruct(loadConf)) == NULL) {
1577 		DBGPRINTF("template.c: tplConstruct failed!\n");
1578 		ABORT_FINALIZE(RS_RET_ERR);
1579 	}
1580 	pTpl-&gt;pszName = name;
1581 	pTpl-&gt;iLenName = lenName;
1582 	switch(tplType) {
1583 	case T_STRING:	p = tplStr;
1584 			while(*p) {
1585 				switch(*p) {
1586 					case '%': 						++p; 						CHKiRet(do_Parameter(&amp;p, pTpl));
1587 						break;
1588 					default: 						do_Constant(&amp;p, pTpl, 0);
1589 						break;
1590 				}
1591 			}
1592 			break;
1593 	case T_PLUGIN:	p = plugin;
1594 			localRet = tplAddTplMod(pTpl, &amp;p);
1595 			if(localRet != RS_RET_OK) {
1596 				LogError(0, localRet, "template '%s': error %d "
1597 						"defining template via plugin (strgen) module",
1598 						pTpl-&gt;pszName, localRet);
1599 				ABORT_FINALIZE(localRet);
1600 			}
1601 			break;
1602 	case T_LIST:	createListTpl(pTpl, o);
1603 			break;
1604 	case T_SUBTREE:	memcpy(&amp;pTpl-&gt;subtree, &amp;subtree, sizeof(msgPropDescr_t));
1605 			pTpl-&gt;bHaveSubtree = 1;
1606 			break;
1607 	}
1608 	pTpl-&gt;optFormatEscape = NO_ESCAPE;
1609 	if(o_stdsql)
1610 		pTpl-&gt;optFormatEscape = STDSQL_ESCAPE;
1611 	else if(o_sql)
1612 		pTpl-&gt;optFormatEscape = SQL_ESCAPE;
1613 	else if(o_json)
1614 		pTpl-&gt;optFormatEscape = JSON_ESCAPE;
1615 	else if(o_jsonf)
1616 		pTpl-&gt;optFormatEscape = JSONF;
1617 	if(o_casesensitive)
1618 		pTpl-&gt;optCaseSensitive = 1;
1619 	apply_case_sensitivity(pTpl);
1620 finalize_it:
1621 	free(tplStr);
1622 	free(plugin);
1623 	if(pvals != NULL)
1624 		cnfparamvalsDestruct(pvals, &amp;pblk);
1625 	if(iRet != RS_RET_OK) {
1626 		if(pTpl != NULL) {
1627 			*pTpl-&gt;pszName = '\0';
1628 		}
1629 	}
1630 	RETiRet;
1631 }
1632 struct template *tplFind(rsconf_t *conf, char *pName, int iLenName)
1633 {
1634 	struct template *pTpl;
1635 	assert(pName != NULL);
1636 	pTpl = conf-&gt;templates.root;
1637 	while(pTpl != NULL &amp;&amp;
1638 	      !(pTpl-&gt;iLenName == iLenName &amp;&amp;
1639 	        !strcmp(pTpl-&gt;pszName, pName)
1640 	        ))
1641 		{
1642 			pTpl = pTpl-&gt;pNext;
1643 		}
1644 	return(pTpl);
1645 }
1646 void tplDeleteAll(rsconf_t *conf)
1647 {
1648 	struct template *pTpl, *pTplDel;
1649 	struct templateEntry *pTpe, *pTpeDel;
1650 	pTpl = conf-&gt;templates.root;
1651 	while(pTpl != NULL) {
1652 		pTpe = pTpl-&gt;pEntryRoot;
1653 		while(pTpe != NULL) {
1654 			pTpeDel = pTpe;
1655 			pTpe = pTpe-&gt;pNext;
1656 			switch(pTpeDel-&gt;eEntryType) {
1657 			case UNDEFINED:
1658 				break;
1659 			case CONSTANT:
1660 				free(pTpeDel-&gt;data.constant.pConstant);
1661 				break;
1662 			case FIELD:
1663 #ifdef FEATURE_REGEXP
1664 				if(pTpeDel-&gt;data.field.has_regex != 0) {
1665 					if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
1666 						regexp.regfree(&amp;(pTpeDel-&gt;data.field.re));
1667 					}
1668 				}
1669 #endif
1670 				msgPropDescrDestruct(&amp;pTpeDel-&gt;data.field.msgProp);
1671 				break;
1672 			}
1673 			free(pTpeDel-&gt;fieldName);
1674 			free(pTpeDel);
1675 		}
1676 		pTplDel = pTpl;
1677 		pTpl = pTpl-&gt;pNext;
1678 		free(pTplDel-&gt;pszName);
1679 		if(pTplDel-&gt;bHaveSubtree)
1680 			msgPropDescrDestruct(&amp;pTplDel-&gt;subtree);
1681 		free(pTplDel);
1682 	}
1683 }
1684 void tplDeleteNew(rsconf_t *conf)
1685 {
1686 	struct template *pTpl, *pTplDel;
1687 	struct templateEntry *pTpe, *pTpeDel;
1688 	if(conf-&gt;templates.root == NULL || conf-&gt;templates.lastStatic == NULL)
1689 		return;
1690 	pTpl = conf-&gt;templates.lastStatic-&gt;pNext;
1691 	conf-&gt;templates.lastStatic-&gt;pNext = NULL;
1692 	conf-&gt;templates.last = conf-&gt;templates.lastStatic;
1693 	while(pTpl != NULL) {
1694 		pTpe = pTpl-&gt;pEntryRoot;
1695 		while(pTpe != NULL) {
1696 			pTpeDel = pTpe;
1697 			pTpe = pTpe-&gt;pNext;
1698 			switch(pTpeDel-&gt;eEntryType) {
1699 			case UNDEFINED:
1700 				break;
1701 			case CONSTANT:
1702 				free(pTpeDel-&gt;data.constant.pConstant);
1703 				break;
1704 			case FIELD:
1705 #ifdef FEATURE_REGEXP
1706 				if(pTpeDel-&gt;data.field.has_regex != 0) {
1707 					if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
1708 						regexp.regfree(&amp;(pTpeDel-&gt;data.field.re));
1709 					}
1710 				}
1711 #endif
1712 				msgPropDescrDestruct(&amp;pTpeDel-&gt;data.field.msgProp);
1713 				break;
1714 			}
1715 			free(pTpeDel);
1716 		}
1717 		pTplDel = pTpl;
1718 		pTpl = pTpl-&gt;pNext;
1719 		free(pTplDel-&gt;pszName);
1720 		if(pTplDel-&gt;bHaveSubtree)
1721 			msgPropDescrDestruct(&amp;pTplDel-&gt;subtree);
1722 		free(pTplDel);
1723 	}
1724 }
1725 void tplLastStaticInit(rsconf_t *conf, struct template *tpl)
1726 {
1727 	conf-&gt;templates.lastStatic = tpl;
1728 }
1729 void tplPrintList(rsconf_t *conf)
1730 {
1731 	struct template *pTpl;
1732 	struct templateEntry *pTpe;
1733 	pTpl = conf-&gt;templates.root;
1734 	while(pTpl != NULL) {
1735 		dbgprintf("Template: Name='%s' ", pTpl-&gt;pszName == NULL? "NULL" : pTpl-&gt;pszName);
1736 		if(pTpl-&gt;optFormatEscape == SQL_ESCAPE)
1737 			dbgprintf("[SQL-Format (MySQL)] ");
1738 		else if(pTpl-&gt;optFormatEscape == JSON_ESCAPE)
1739 			dbgprintf("[JSON-Escaped Format] ");
1740 		else if(pTpl-&gt;optFormatEscape == STDSQL_ESCAPE)
1741 			dbgprintf("[SQL-Format (standard SQL)] ");
1742 		else if(pTpl-&gt;optFormatEscape == JSONF)
1743 			dbgprintf("[JSON fields] ");
1744 		if(pTpl-&gt;optCaseSensitive)
1745 			dbgprintf("[Case Sensitive Vars] ");
1746 		dbgprintf("\n");
1747 		pTpe = pTpl-&gt;pEntryRoot;
1748 		while(pTpe != NULL) {
1749 			dbgprintf("\tEntry(%lx): type %d, ", (unsigned long) pTpe, pTpe-&gt;eEntryType);
1750 			switch(pTpe-&gt;eEntryType) {
1751 			case UNDEFINED:
1752 				dbgprintf("(UNDEFINED)");
1753 				break;
1754 			case CONSTANT:
1755 				dbgprintf("(CONSTANT), value: '%s'",
1756 					pTpe-&gt;data.constant.pConstant);
1757 				break;
1758 			case FIELD:
1759 				dbgprintf("(FIELD), value: '%d' ", pTpe-&gt;data.field.msgProp.id);
1760 				if(pTpe-&gt;data.field.msgProp.id == PROP_CEE) {
1761 					dbgprintf("[EE-Property: '%s'] ", pTpe-&gt;data.field.msgProp.name);
1762 				} else if(pTpe-&gt;data.field.msgProp.id == PROP_LOCAL_VAR) {
1763 					dbgprintf("[Local Var: '%s'] ", pTpe-&gt;data.field.msgProp.name);
1764 				}
1765 				switch(pTpe-&gt;data.field.eDateFormat) {
1766 				case tplFmtDefault:
1767 					break;
1768 				case tplFmtMySQLDate:
1769 					dbgprintf("[Format as MySQL-Date] ");
1770 					break;
1771 				case tplFmtPgSQLDate:
1772 					dbgprintf("[Format as PgSQL-Date] ");
1773 					break;
1774 				case tplFmtRFC3164Date:
1775 					dbgprintf("[Format as RFC3164-Date] ");
1776 					break;
1777 				case tplFmtRFC3339Date:
1778 					dbgprintf("[Format as RFC3339-Date] ");
1779 					break;
1780 				case tplFmtUnixDate:
1781 					dbgprintf("[Format as Unix timestamp] ");
1782 					break;
1783 				case tplFmtSecFrac:
1784 					dbgprintf("[fractional seconds, only] ");
1785 					break;
1786 				case tplFmtRFC3164BuggyDate:
1787 					dbgprintf("[Format as buggy RFC3164-Date] ");
1788 					break;
1789 				case tplFmtWDayName:
1790 					dbgprintf("[Format as weekday name] ");
1791 					break;
1792 				case tplFmtYear:
1793 					dbgprintf("[Format as year] ");
1794 					break;
1795 				case tplFmtMonth:
1796 					dbgprintf("[Format as month] ");
1797 					break;
1798 				case tplFmtDay:
1799 					dbgprintf("[Format as day] ");
1800 					break;
1801 				case tplFmtHour:
1802 					dbgprintf("[Format as hour] ");
1803 					break;
1804 				case tplFmtMinute:
1805 					dbgprintf("[Format as minute] ");
1806 					break;
1807 				case tplFmtSecond:
1808 					dbgprintf("[Format as second] ");
1809 					break;
1810 				case tplFmtTZOffsHour:
1811 					dbgprintf("[Format as offset hour] ");
1812 					break;
1813 				case tplFmtTZOffsMin:
1814 					dbgprintf("[Format as offset minute] ");
1815 					break;
1816 				case tplFmtTZOffsDirection:
1817 					dbgprintf("[Format as offset direction] ");
1818 					break;
1819 				case tplFmtWDay:
1820 					dbgprintf("[Format as weekday] ");
1821 					break;
1822 				case tplFmtOrdinal:
1823 					dbgprintf("[Format as ordinal] ");
1824 					break;
1825 				case tplFmtWeek:
1826 					dbgprintf("[Format as week] ");
1827 					break;
1828 				default:
1829 					dbgprintf("[UNKNOWN eDateFormat %d] ", pTpe-&gt;data.field.eDateFormat);
1830 				}
1831 				switch(pTpe-&gt;data.field.eCaseConv) {
1832 				case tplCaseConvNo:
1833 					break;
1834 				case tplCaseConvLower:
1835 					dbgprintf("[Converted to Lower Case] ");
1836 					break;
1837 				case tplCaseConvUpper:
1838 					dbgprintf("[Converted to Upper Case] ");
1839 					break;
1840 				}
1841 				if(pTpe-&gt;data.field.options.bEscapeCC) {
1842 				  	dbgprintf("[escape control-characters] ");
1843 				}
1844 				if(pTpe-&gt;data.field.options.bDropCC) {
1845 				  	dbgprintf("[drop control-characters] ");
1846 				}
1847 				if(pTpe-&gt;data.field.options.bSpaceCC) {
1848 				  	dbgprintf("[replace control-characters with space] ");
1849 				}
1850 				if(pTpe-&gt;data.field.options.bSecPathDrop) {
1851 				  	dbgprintf("[slashes are dropped] ");
1852 				}
1853 				if(pTpe-&gt;data.field.options.bSecPathReplace) {
1854 				  	dbgprintf("[slashes are replaced by '_'] ");
1855 				}
1856 				if(pTpe-&gt;data.field.options.bSPIffNo1stSP) {
1857 				  	dbgprintf("[SP iff no first SP] ");
1858 				}
1859 				if(pTpe-&gt;data.field.options.bCSV) {
1860 				  	dbgprintf("[format as CSV (RFC4180)]");
1861 				}
1862 				if(pTpe-&gt;data.field.options.bJSON) {
1863 					dbgprintf("[format as JSON] ");
1864 				}
1865 				if(pTpe-&gt;data.field.options.bJSONf) {
1866 					dbgprintf("[format as JSON field] ");
1867 				}
1868 				if(pTpe-&gt;data.field.options.bJSONr) {
1869 					dbgprintf("[format as JSON without re-escaping] ");
1870 				}
1871 				if(pTpe-&gt;data.field.options.bJSONfr) {
1872 					dbgprintf("[format as JSON field without re-escaping] ");
1873 				}
1874 				if(pTpe-&gt;data.field.options.bMandatory) {
1875 					dbgprintf("[mandatory field] ");
1876 				}
1877 				if(pTpe-&gt;data.field.options.bDropLastLF) {
1878 				  	dbgprintf("[drop last LF in msg] ");
1879 				}
1880 				if(pTpe-&gt;data.field.has_fields == 1) {
1881 				  	dbgprintf("[substring, field #%d only (delimiter %d)] ",
1882 						pTpe-&gt;data.field.iFieldNr, pTpe-&gt;data.field.field_delim);
1883 				}
1884 				if(pTpe-&gt;data.field.iFromPos != 0 || pTpe-&gt;data.field.iToPos != 0) {
1885 				  	dbgprintf("[substring, from character %d to %d] ",
1886 						pTpe-&gt;data.field.iFromPos,
1887 						pTpe-&gt;data.field.iToPos);
1888 				}
1889 				break;
1890 			}
1891 			if(pTpe-&gt;bComplexProcessing)
1892 				dbgprintf("[COMPLEX]");
1893 			dbgprintf("\n");
1894 			pTpe = pTpe-&gt;pNext;
1895 		}
1896 		pTpl = pTpl-&gt;pNext; 	}
1897 }
1898 int tplGetEntryCount(struct template *pTpl)
1899 {
1900 	assert(pTpl != NULL);
1901 	return(pTpl-&gt;tpenElements);
1902 }
1903 rsRetVal templateInit(void)
1904 {
1905 	DEFiRet;
1906 	CHKiRet(objGetObjInterface(&amp;obj));
1907 	CHKiRet(objUse(strgen, CORE_COMPONENT));
1908 finalize_it:
1909 	RETiRet;
1910 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
