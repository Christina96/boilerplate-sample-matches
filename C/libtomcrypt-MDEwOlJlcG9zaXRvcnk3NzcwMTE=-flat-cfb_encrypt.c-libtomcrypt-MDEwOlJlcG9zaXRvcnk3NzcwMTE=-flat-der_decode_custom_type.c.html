
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.807017543859649%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-cfb_encrypt.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CFB_MODE
<span onclick='openModal()' class='match'>3  int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb)
3  int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb)
</span>4  {
5     int err;
6     LTC_ARGCHK(pt != NULL);
7     LTC_ARGCHK(ct != NULL);
8     LTC_ARGCHK(cfb != NULL);
9     if ((err = cipher_is_valid(cfb->cipher)) != CRYPT_OK) {
10         return err;
11     }
12     if (cfb->blocklen < 0 || cfb->blocklen > (int)sizeof(cfb->IV) ||
13         cfb->padlen   < 0 || cfb->padlen   > (int)sizeof(cfb->pad)) {
14        return CRYPT_INVALID_ARG;
15     }
16     while (len-- > 0) {
17         if (cfb->padlen == cfb->blocklen) {
18            if ((err = cipher_descriptor[cfb->cipher].ecb_encrypt(cfb->pad, cfb->IV, &cfb->key)) != CRYPT_OK) {
19               return err;
20            }
21            cfb->padlen = 0;
22         }
23         cfb->pad[cfb->padlen] = (*ct = *pt ^ cfb->IV[cfb->padlen]);
24         ++pt;
25         ++ct;
26         ++(cfb->padlen);
27     }
28     return CRYPT_OK;
29  }
30  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_custom_type.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  int der_decode_custom_type(const unsigned char *in, unsigned long  inlen,
4                             ltc_asn1_list *root)
5  {
6     LTC_ARGCHK(root != NULL);
7     return der_decode_custom_type_ex(in, inlen, root, NULL, 0, LTC_DER_SEQ_ORDERED | LTC_DER_SEQ_RELAXED);
8  }
<span onclick='openModal()' class='match'>9  int der_decode_custom_type_ex(const unsigned char *in,   unsigned long  inlen,
10                                      ltc_asn1_list *root,
11                                      ltc_asn1_list *list, unsigned long  outlen,
</span>12                                      unsigned int   flags)
13  {
14     int           err, seq_err, i, ordered;
15     ltc_asn1_type type;
16     ltc_asn1_list ident;
17     unsigned long size, x, y, z, blksize;
18     unsigned char* in_new = NULL;
19     void          *data;
20     LTC_ARGCHK(in   != NULL);
21     if (inlen < 2) {
22        return CRYPT_INVALID_PACKET;
23     }
24     x = 0;
25     if (root == NULL) {
26        LTC_ARGCHK(list != NULL);
27        if (in[x] != 0x30 && in[x] != 0x31) {
28           return CRYPT_INVALID_PACKET;
29        }
30        ++x;
31     } else {
32        if (root->type != LTC_ASN1_CUSTOM_TYPE) {
33           return CRYPT_INVALID_PACKET;
34        }
35        if (root->pc == LTC_ASN1_PC_PRIMITIVE) {
36           in_new = XMALLOC(inlen);
37           if (in_new == NULL) {
38              return CRYPT_MEM;
39           }
40           XMEMCPY(in_new, in, inlen);
41           in = in_new;
42        }
43        y = inlen;
44        if ((err = der_decode_asn1_identifier(in, &y, &ident)) != CRYPT_OK) {
45           goto LBL_ERR;
46        }
47        if ((ident.type != root->type) ||
48              (ident.klass != root->klass) ||
49              (ident.pc != root->pc) ||
50              (ident.tag != root->tag)) {
51           err = CRYPT_INVALID_PACKET;
52           goto LBL_ERR;
53        }
54        x += y;
55        list = root->data;
56        outlen = root->size;
57     }
58     if (root != NULL && root->pc == LTC_ASN1_PC_PRIMITIVE) {
59        if (((unsigned long)root->used >= der_asn1_type_to_identifier_map_sz) ||
60              (der_asn1_type_to_identifier_map[root->used] == -1)) {
61           err = CRYPT_INVALID_PACKET;
62           goto LBL_ERR;
63        }
64        root->type = (ltc_asn1_type)root->used;
65        list = root;
66        outlen = 1;
67        x -= 1;
68        in_new[x] = (unsigned char)der_asn1_type_to_identifier_map[list[0].type];
69        blksize = inlen - x;
70     } else {
71        y = inlen - x;
72        if ((err = der_decode_asn1_length(&in[x], &y, &blksize)) != CRYPT_OK) {
73           goto LBL_ERR;
74        }
75        x += y;
76     }
77     if (blksize > (inlen - x)) {
78        err = CRYPT_INVALID_PACKET;
79        goto LBL_ERR;
80     }
81     for (i = 0; i < (int)outlen; i++) {
82         list[i].used = 0;
83     }
84     ordered = flags & LTC_DER_SEQ_ORDERED;
85     seq_err  = CRYPT_OK;
86     blksize += x;
87     inlen   -= x;
88     for (i = 0; i < (int)outlen; i++) {
89         z    = 0;
90         type = list[i].type;
91         size = list[i].size;
92         data = list[i].data;
93         if (!ordered && list[i].used == 1) { continue; }
94         if (type == LTC_ASN1_EOL) {
95            break;
96         }
97         if (root != NULL && root->pc == LTC_ASN1_PC_PRIMITIVE && i != 0) {
98            err = CRYPT_PK_ASN1_ERROR;
99            goto LBL_ERR;
100         }
101         switch (type) {
102            case LTC_ASN1_CUSTOM_TYPE:
103            case LTC_ASN1_SET:
104            case LTC_ASN1_SETOF:
105            case LTC_ASN1_SEQUENCE:
106               break;
107            default:
108               if (((flags & LTC_DER_SEQ_STRICT) == LTC_DER_SEQ_STRICT) && (inlen > 0)) {
109                  if (in[x] & 0xE0u) {
110                     err = CRYPT_PK_ASN1_ERROR;
111                     goto LBL_ERR;
112                  }
113               }
114         }
115         switch (type) {
116             case LTC_ASN1_BOOLEAN:
117                 z = inlen;
118                 if ((err = der_decode_boolean(in + x, z, ((int *)data))) != CRYPT_OK) {
119                    if (!ordered || list[i].optional) { continue; }
120                    goto LBL_ERR;
121                 }
122                 if ((err = der_length_boolean(&z)) != CRYPT_OK) {
123                    goto LBL_ERR;
124                 }
125                 break;
126             case LTC_ASN1_INTEGER:
127                 z = inlen;
128                 if ((err = der_decode_integer(in + x, z, data)) != CRYPT_OK) {
129                    if (!ordered || list[i].optional) { continue; }
130                    goto LBL_ERR;
131                 }
132                 if ((err = der_length_integer(data, &z)) != CRYPT_OK) {
133                    goto LBL_ERR;
134                 }
135                 break;
136             case LTC_ASN1_SHORT_INTEGER:
137                 z = inlen;
138                 if ((err = der_decode_short_integer(in + x, z, data)) != CRYPT_OK) {
139                    if (!ordered || list[i].optional) { continue; }
140                    goto LBL_ERR;
141                 }
142                 if ((err = der_length_short_integer(((unsigned long*)data)[0], &z)) != CRYPT_OK) {
143                    goto LBL_ERR;
144                 }
145                 break;
146             case LTC_ASN1_BIT_STRING:
147                 z = inlen;
148                 if ((err = der_decode_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
149                    if (!ordered || list[i].optional) { continue; }
150                    goto LBL_ERR;
151                 }
152                 list[i].size = size;
153                 if ((err = der_length_bit_string(size, &z)) != CRYPT_OK) {
154                    goto LBL_ERR;
155                 }
156                 break;
157             case LTC_ASN1_RAW_BIT_STRING:
158                 z = inlen;
159                 if ((err = der_decode_raw_bit_string(in + x, z, data, &size)) != CRYPT_OK) {
160                    if (!ordered || list[i].optional) { continue; }
161                    goto LBL_ERR;
162                 }
163                 list[i].size = size;
164                 if ((err = der_length_bit_string(size, &z)) != CRYPT_OK) {
165                    goto LBL_ERR;
166                 }
167                 break;
168             case LTC_ASN1_OCTET_STRING:
169                 z = inlen;
170                 if ((err = der_decode_octet_string(in + x, z, data, &size)) != CRYPT_OK) {
171                    if (!ordered || list[i].optional) { continue; }
172                    goto LBL_ERR;
173                 }
174                 list[i].size = size;
175                 if ((err = der_length_octet_string(size, &z)) != CRYPT_OK) {
176                    goto LBL_ERR;
177                 }
178                 break;
179             case LTC_ASN1_NULL:
180                 if (inlen < 2 || in[x] != 0x05 || in[x+1] != 0x00) {
181                    if (!ordered || list[i].optional) { continue; }
182                    err = CRYPT_INVALID_PACKET;
183                    goto LBL_ERR;
184                 }
185                 z = 2;
186                 break;
187             case LTC_ASN1_OBJECT_IDENTIFIER:
188                 z = inlen;
189                 if ((err = der_decode_object_identifier(in + x, z, data, &size)) != CRYPT_OK) {
190                    if (!ordered || list[i].optional) { continue; }
191                    goto LBL_ERR;
192                 }
193                 list[i].size = size;
194                 if ((err = der_length_object_identifier(data, size, &z)) != CRYPT_OK) {
195                    goto LBL_ERR;
196                 }
197                 break;
198             case LTC_ASN1_TELETEX_STRING:
199                 z = inlen;
200                 if ((err = der_decode_teletex_string(in + x, z, data, &size)) != CRYPT_OK) {
201                    if (!ordered || list[i].optional) { continue; }
202                    goto LBL_ERR;
203                 }
204                 list[i].size = size;
205                 if ((err = der_length_teletex_string(data, size, &z)) != CRYPT_OK) {
206                    goto LBL_ERR;
207                 }
208                 break;
209             case LTC_ASN1_IA5_STRING:
210                 z = inlen;
211                 if ((err = der_decode_ia5_string(in + x, z, data, &size)) != CRYPT_OK) {
212                    if (!ordered || list[i].optional) { continue; }
213                    goto LBL_ERR;
214                 }
215                 list[i].size = size;
216                 if ((err = der_length_ia5_string(data, size, &z)) != CRYPT_OK) {
217                    goto LBL_ERR;
218                 }
219                 break;
220             case LTC_ASN1_PRINTABLE_STRING:
221                 z = inlen;
222                 if ((err = der_decode_printable_string(in + x, z, data, &size)) != CRYPT_OK) {
223                    if (!ordered || list[i].optional) { continue; }
224                    goto LBL_ERR;
225                 }
226                 list[i].size = size;
227                 if ((err = der_length_printable_string(data, size, &z)) != CRYPT_OK) {
228                    goto LBL_ERR;
229                 }
230                 break;
231             case LTC_ASN1_UTF8_STRING:
232                 z = inlen;
233                 if ((err = der_decode_utf8_string(in + x, z, data, &size)) != CRYPT_OK) {
234                    if (!ordered || list[i].optional) { continue; }
235                    goto LBL_ERR;
236                 }
237                 list[i].size = size;
238                 if ((err = der_length_utf8_string(data, size, &z)) != CRYPT_OK) {
239                    goto LBL_ERR;
240                 }
241                 break;
242             case LTC_ASN1_UTCTIME:
243                 z = inlen;
244                 if ((err = der_decode_utctime(in + x, &z, data)) != CRYPT_OK) {
245                    if (!ordered || list[i].optional) { continue; }
246                    goto LBL_ERR;
247                 }
248                 break;
249             case LTC_ASN1_GENERALIZEDTIME:
250                 z = inlen;
251                 if ((err = der_decode_generalizedtime(in + x, &z, data)) != CRYPT_OK) {
252                    if (!ordered || list[i].optional) { continue; }
253                    goto LBL_ERR;
254                 }
255                 break;
256             case LTC_ASN1_SET:
257                 z = inlen;
258                 if ((err = der_decode_set(in + x, z, data, size)) != CRYPT_OK) {
259                    if (!ordered || list[i].optional) { continue; }
260                    goto LBL_ERR;
261                 }
262                 if ((err = der_length_sequence(data, size, &z)) != CRYPT_OK) {
263                    goto LBL_ERR;
264                 }
265                 break;
266             case LTC_ASN1_SETOF:
267             case LTC_ASN1_SEQUENCE:
268                 if ((type == LTC_ASN1_SETOF && (in[x] & 0x3F) != 0x31) || (type == LTC_ASN1_SEQUENCE && (in[x] & 0x3F) != 0x30)) {
269                    err = CRYPT_INVALID_PACKET;
270                    goto LBL_ERR;
271                 }
272                 z = inlen;
273                 err = der_decode_sequence_ex(in + x, z, data, size, flags);
274                 if (err == CRYPT_INPUT_TOO_LONG) {
275                    seq_err = CRYPT_INPUT_TOO_LONG;
276                    err = CRYPT_OK;
277                 }
278                 if (err != CRYPT_OK) {
279                    if (!ordered || list[i].optional) { continue; }
280                    goto LBL_ERR;
281                 }
282                 if ((err = der_length_sequence(data, size, &z)) != CRYPT_OK) {
283                    goto LBL_ERR;
284                 }
285                 break;
286             case LTC_ASN1_CUSTOM_TYPE:
287                 z = inlen;
288                 err = der_decode_custom_type(in + x, z, &list[i]);
289                 if (err == CRYPT_INPUT_TOO_LONG) {
290                    seq_err = CRYPT_INPUT_TOO_LONG;
291                    err = CRYPT_OK;
292                 }
293                 if (err != CRYPT_OK) {
294                    if (!ordered || list[i].optional) { continue; }
295                    goto LBL_ERR;
296                 }
297                 if ((err = der_length_custom_type(&list[i], &z, NULL)) != CRYPT_OK) {
298                    goto LBL_ERR;
299                 }
300                 break;
301             case LTC_ASN1_CHOICE:
302                 z = inlen;
303                 if ((err = der_decode_choice(in + x, &z, data, size)) != CRYPT_OK) {
304                    if (!ordered || list[i].optional) { continue; }
305                    goto LBL_ERR;
306                 }
307                 break;
308             case LTC_ASN1_EOL:
309                 err = CRYPT_INVALID_ARG;
310                 goto LBL_ERR;
311         }
312         x           += z;
313         inlen       -= z;
314         list[i].used = 1;
315         if (!ordered) {
316            i = -1;
317         }
318     }
319     for (i = 0; i < (int)outlen; i++) {
320        if (list[i].used == 0 && list[i].optional == 0) {
321            err = CRYPT_INVALID_PACKET;
322            goto LBL_ERR;
323        }
324     }
325     if (blksize == x && seq_err == CRYPT_OK && inlen == 0) {
326        err = CRYPT_OK;
327     } else if (blksize == x && seq_err == CRYPT_INPUT_TOO_LONG && inlen == 0) {
328        err = CRYPT_OK;
329     } else if (blksize != x && ((flags & LTC_DER_SEQ_STRICT) == LTC_DER_SEQ_STRICT)) {
330        err = CRYPT_INVALID_PACKET;
331     } else {
332        err = CRYPT_INPUT_TOO_LONG;
333     }
334  LBL_ERR:
335     if (in_new != NULL) {
336        XFREE(in_new);
337     }
338     return err;
339  }
340  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-cfb_encrypt.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_custom_type.c</div>
                </div>
                <div class="column column_space"><pre><code>3  int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb)
3  int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb)
</pre></code></div>
                <div class="column column_space"><pre><code>9  int der_decode_custom_type_ex(const unsigned char *in,   unsigned long  inlen,
10                                      ltc_asn1_list *root,
11                                      ltc_asn1_list *list, unsigned long  outlen,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    