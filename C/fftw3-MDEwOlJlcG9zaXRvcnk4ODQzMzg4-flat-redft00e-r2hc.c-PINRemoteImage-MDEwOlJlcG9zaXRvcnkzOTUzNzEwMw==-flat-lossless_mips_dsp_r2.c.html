
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.713896457765669%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       INT is = ego->is, os = ego->os;
18       INT i, n = ego->n;
19       INT iv, vl = ego->vl;
20       INT ivs = ego->ivs, ovs = ego->ovs;
21       R *W = ego->td->W;
22       R *buf;
23       E csum;
24       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
25       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
26  	  buf[0] = I[0] + I[is * n];
27  	  csum = I[0] - I[is * n];
28  	  for (i = 1; i < n - i; ++i) {
29  	       E a, b, apb, amb;
30  	       a = I[is * i];
31  	       b = I[is * (n - i)];
32  	       csum += W[2*i] * (amb = K(2.0)*(a - b));
33  	       amb = W[2*i+1] * amb;
34  	       apb = (a + b);
35  	       buf[i] = apb - amb;
36  	       buf[n - i] = apb + amb;
37  	  }
38  	  if (i == n - i) {
39  	       buf[i] = K(2.0) * I[is * i];
40  	  }
41  	  {
42  	       plan_rdft *cld = (plan_rdft *) ego->cld;
43  	       cld->apply((plan *) cld, buf, buf);
44  	  }
45  	  O[0] = buf[0];
46  	  O[os] = csum;
47  	  for (i = 1; i + i < n; ++i) {
48  	       INT k = i + i;
49  	       O[os * k] = buf[i];
50  	       O[os * (k + 1)] = O[os * (k - 1)] - buf[n - i];
51  	  }
52  	  if (i + i == n) {
53  	       O[os * n] = buf[i];
54  	  }
55       }
56       X(ifree)(buf);
57  }
58  static void awake(plan *ego_, enum wakefulness wakefulness)
59  {
60       P *ego = (P *) ego_;
61       static const tw_instr redft00e_tw[] = {
62            { TW_COS, 0, 1 },
63            { TW_SIN, 0, 1 },
64            { TW_NEXT, 1, 0 }
65       };
66       X(plan_awake)(ego->cld, wakefulness);
67       X(twiddle_awake)(wakefulness,
68  		      &ego->td, redft00e_tw, 2*ego->n, 1, (ego->n+1)/2);
69  }
70  static void destroy(plan *ego_)
71  {
72       P *ego = (P *) ego_;
73       X(plan_destroy_internal)(ego->cld);
74  }
75  static void print(const plan *ego_, printer *p)
76  {
77       const P *ego = (const P *) ego_;
78       p->print(p, "(redft00e-r2hc-%D%v%(%p%))", ego->n + 1, ego->vl, ego->cld);
79  }
80  static int applicable0(const solver *ego_, const problem *p_)
81  {
82       const problem_rdft *p = (const problem_rdft *) p_;
83       UNUSED(ego_);
84       return (1
85  	     && p->sz->rnk == 1
86  	     && p->vecsz->rnk <= 1
87  	     && p->kind[0] == REDFT00
88  	     && p->sz->dims[0].n > 1  &bsol;* n == 1 is not well-defined */
89  	  );
90  }
<span onclick='openModal()' class='match'>91  static int applicable(const solver *ego, const problem *p, const planner *plnr)
92  {
93       return (!NO_SLOWP(plnr) && applicable0(ego, p));
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
</span>97       P *pln;
98       const problem_rdft *p;
99       plan *cld;
100       R *buf;
101       INT n;
102       opcnt ops;
103       static const plan_adt padt = {
104  	  X(rdft_solve), awake, print, destroy
105       };
106       if (!applicable(ego_, p_, plnr))
107            return (plan *)0;
108       p = (const problem_rdft *) p_;
109       n = p->sz->dims[0].n - 1;
110       A(n > 0);
111       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
112       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n, 1, 1), 
113  						   X(mktensor_0d)(), 
114  						   buf, buf, R2HC));
115       X(ifree)(buf);
116       if (!cld)
117            return (plan *)0;
118       pln = MKPLAN_RDFT(P, &padt, apply);
119       pln->n = n;
120       pln->is = p->sz->dims[0].is;
121       pln->os = p->sz->dims[0].os;
122       pln->cld = cld;
123       pln->td = 0;
124       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
125       X(ops_zero)(&ops);
126       ops.other = 8 + (n-1)/2 * 11 + (1 - n % 2) * 5;
127       ops.add = 2 + (n-1)/2 * 5;
128       ops.mul = (n-1)/2 * 3 + (1 - n % 2) * 1;
129       X(ops_zero)(&pln->super.super.ops);
130       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
131       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
132       return &(pln->super.super);
133  }
134  static solver *mksolver(void)
135  {
136       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
137       S *slv = MKSOLVER(S, &sadt);
138       return &(slv->super);
139  }
140  void X(redft00e_r2hc_register)(planner *p)
141  {
142       REGISTER_SOLVER(p, mksolver());
143  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include "src/dsp/lossless.h"
4  #include "src/dsp/lossless_common.h"
5  #define MAP_COLOR_FUNCS(FUNC_NAME, TYPE, GET_INDEX, GET_VALUE)                 \
6  static void FUNC_NAME(const TYPE* src,                                         \
7                        const uint32_t* const color_map,                         \
8                        TYPE* dst, int y_start, int y_end,                       \
9                        int width) {                                             \
10    int y;                                                                       \
11    for (y = y_start; y < y_end; ++y) {                                          \
12      int x;                                                                     \
13      for (x = 0; x < (width >> 2); ++x) {                                       \
14        int tmp1, tmp2, tmp3, tmp4;                                              \
15        __asm__ volatile (                                                       \
16        ".ifc        " #TYPE ",  uint8_t                  \n\t"                  \
17          "lbu       %[tmp1],  0(%[src])                  \n\t"                  \
18          "lbu       %[tmp2],  1(%[src])                  \n\t"                  \
19          "lbu       %[tmp3],  2(%[src])                  \n\t"                  \
20          "lbu       %[tmp4],  3(%[src])                  \n\t"                  \
21          "addiu     %[src],   %[src],      4             \n\t"                  \
22        ".endif                                           \n\t"                  \
23        ".ifc        " #TYPE ",  uint32_t                 \n\t"                  \
24          "lw        %[tmp1],  0(%[src])                  \n\t"                  \
25          "lw        %[tmp2],  4(%[src])                  \n\t"                  \
26          "lw        %[tmp3],  8(%[src])                  \n\t"                  \
27          "lw        %[tmp4],  12(%[src])                 \n\t"                  \
28          "ext       %[tmp1],  %[tmp1],     8,        8   \n\t"                  \
29          "ext       %[tmp2],  %[tmp2],     8,        8   \n\t"                  \
30          "ext       %[tmp3],  %[tmp3],     8,        8   \n\t"                  \
31          "ext       %[tmp4],  %[tmp4],     8,        8   \n\t"                  \
32          "addiu     %[src],   %[src],      16            \n\t"                  \
33        ".endif                                           \n\t"                  \
34          "sll       %[tmp1],  %[tmp1],     2             \n\t"                  \
35          "sll       %[tmp2],  %[tmp2],     2             \n\t"                  \
36          "sll       %[tmp3],  %[tmp3],     2             \n\t"                  \
37          "sll       %[tmp4],  %[tmp4],     2             \n\t"                  \
38          "lwx       %[tmp1],  %[tmp1](%[color_map])      \n\t"                  \
39          "lwx       %[tmp2],  %[tmp2](%[color_map])      \n\t"                  \
40          "lwx       %[tmp3],  %[tmp3](%[color_map])      \n\t"                  \
41          "lwx       %[tmp4],  %[tmp4](%[color_map])      \n\t"                  \
42        ".ifc        " #TYPE ",  uint8_t                  \n\t"                  \
43          "ext       %[tmp1],  %[tmp1],     8,        8   \n\t"                  \
44          "ext       %[tmp2],  %[tmp2],     8,        8   \n\t"                  \
45          "ext       %[tmp3],  %[tmp3],     8,        8   \n\t"                  \
46          "ext       %[tmp4],  %[tmp4],     8,        8   \n\t"                  \
47          "sb        %[tmp1],  0(%[dst])                  \n\t"                  \
48          "sb        %[tmp2],  1(%[dst])                  \n\t"                  \
49          "sb        %[tmp3],  2(%[dst])                  \n\t"                  \
50          "sb        %[tmp4],  3(%[dst])                  \n\t"                  \
51          "addiu     %[dst],   %[dst],      4             \n\t"                  \
52        ".endif                                           \n\t"                  \
53        ".ifc        " #TYPE ",  uint32_t                 \n\t"                  \
54          "sw        %[tmp1],  0(%[dst])                  \n\t"                  \
55          "sw        %[tmp2],  4(%[dst])                  \n\t"                  \
56          "sw        %[tmp3],  8(%[dst])                  \n\t"                  \
57          "sw        %[tmp4],  12(%[dst])                 \n\t"                  \
58          "addiu     %[dst],   %[dst],      16            \n\t"                  \
59        ".endif                                           \n\t"                  \
60          : [tmp1]"=&r"(tmp1), [tmp2]"=&r"(tmp2), [tmp3]"=&r"(tmp3),             \
61            [tmp4]"=&r"(tmp4), [src]"+&r"(src), [dst]"+r"(dst)                   \
62          : [color_map]"r"(color_map)                                            \
63          : "memory"                                                             \
64        );                                                                       \
65      }                                                                          \
66      for (x = 0; x < (width & 3); ++x) {                                        \
67        *dst++ = GET_VALUE(color_map[GET_INDEX(*src++)]);                        \
68      }                                                                          \
69    }                                                                            \
70  }
71  MAP_COLOR_FUNCS(MapARGB_MIPSdspR2, uint32_t, VP8GetARGBIndex, VP8GetARGBValue)
72  MAP_COLOR_FUNCS(MapAlpha_MIPSdspR2, uint8_t, VP8GetAlphaIndex, VP8GetAlphaValue)
73  #undef MAP_COLOR_FUNCS
74  static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
75                                                     uint32_t c2) {
76    int temp0, temp1, temp2, temp3, temp4, temp5;
77    __asm__ volatile (
78      "preceu.ph.qbr   %[temp1],   %[c0]                 \n\t"
79      "preceu.ph.qbl   %[temp2],   %[c0]                 \n\t"
80      "preceu.ph.qbr   %[temp3],   %[c1]                 \n\t"
81      "preceu.ph.qbl   %[temp4],   %[c1]                 \n\t"
82      "preceu.ph.qbr   %[temp5],   %[c2]                 \n\t"
83      "preceu.ph.qbl   %[temp0],   %[c2]                 \n\t"
84      "subq.ph         %[temp3],   %[temp3],   %[temp5]  \n\t"
85      "subq.ph         %[temp4],   %[temp4],   %[temp0]  \n\t"
86      "addq.ph         %[temp1],   %[temp1],   %[temp3]  \n\t"
87      "addq.ph         %[temp2],   %[temp2],   %[temp4]  \n\t"
88      "shll_s.ph       %[temp1],   %[temp1],   7         \n\t"
89      "shll_s.ph       %[temp2],   %[temp2],   7         \n\t"
90      "precrqu_s.qb.ph %[temp2],   %[temp2],   %[temp1]  \n\t"
91      : [temp0]"=r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
92        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5)
93      : [c0]"r"(c0), [c1]"r"(c1), [c2]"r"(c2)
94      : "memory"
95    );
96    return temp2;
97  }
98  static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
99                                                     uint32_t c2) {
100    int temp0, temp1, temp2, temp3, temp4, temp5;
101    __asm__ volatile (
102      "adduh.qb         %[temp5],   %[c0],      %[c1]       \n\t"
103      "preceu.ph.qbr    %[temp3],   %[c2]                   \n\t"
104      "preceu.ph.qbr    %[temp1],   %[temp5]                \n\t"
105      "preceu.ph.qbl    %[temp2],   %[temp5]                \n\t"
106      "preceu.ph.qbl    %[temp4],   %[c2]                   \n\t"
107      "subq.ph          %[temp3],   %[temp1],   %[temp3]    \n\t"
108      "subq.ph          %[temp4],   %[temp2],   %[temp4]    \n\t"
109      "shrl.ph          %[temp5],   %[temp3],   15          \n\t"
110      "shrl.ph          %[temp0],   %[temp4],   15          \n\t"
111      "addq.ph          %[temp3],   %[temp3],   %[temp5]    \n\t"
112      "addq.ph          %[temp4],   %[temp0],   %[temp4]    \n\t"
113      "shra.ph          %[temp3],   %[temp3],   1           \n\t"
114      "shra.ph          %[temp4],   %[temp4],   1           \n\t"
115      "addq.ph          %[temp1],   %[temp1],   %[temp3]    \n\t"
116      "addq.ph          %[temp2],   %[temp2],   %[temp4]    \n\t"
117      "shll_s.ph        %[temp1],   %[temp1],   7           \n\t"
118      "shll_s.ph        %[temp2],   %[temp2],   7           \n\t"
119      "precrqu_s.qb.ph  %[temp1],   %[temp2],   %[temp1]    \n\t"
120      : [temp0]"=r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
121        [temp3]"=&r"(temp3), [temp4]"=r"(temp4), [temp5]"=&r"(temp5)
122      : [c0]"r"(c0), [c1]"r"(c1), [c2]"r"(c2)
123      : "memory"
124    );
125    return temp1;
126  }
127  static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
128    int temp0, temp1, temp2, temp3, temp4, temp5;
129    __asm__ volatile (
130      "cmpgdu.lt.qb %[temp1], %[c],     %[b]             \n\t"
131      "pick.qb      %[temp1], %[b],     %[c]             \n\t"
132      "pick.qb      %[temp2], %[c],     %[b]             \n\t"
133      "cmpgdu.lt.qb %[temp4], %[c],     %[a]             \n\t"
134      "pick.qb      %[temp4], %[a],     %[c]             \n\t"
135      "pick.qb      %[temp5], %[c],     %[a]             \n\t"
136      "subu.qb      %[temp3], %[temp1], %[temp2]         \n\t"
137      "subu.qb      %[temp0], %[temp4], %[temp5]         \n\t"
138      "raddu.w.qb   %[temp3], %[temp3]                   \n\t"
139      "raddu.w.qb   %[temp0], %[temp0]                   \n\t"
140      "subu         %[temp3], %[temp3], %[temp0]         \n\t"
141      "slti         %[temp0], %[temp3], 0x1              \n\t"
142      "movz         %[a],     %[b],     %[temp0]         \n\t"
143      : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
144        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [temp0]"=&r"(temp0),
145        [a]"+&r"(a)
146      : [b]"r"(b), [c]"r"(c)
147    );
148    return a;
149  }
150  static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
151    __asm__ volatile (
152      "adduh.qb    %[a0], %[a0], %[a1]       \n\t"
153      : [a0]"+r"(a0)
154      : [a1]"r"(a1)
155    );
156    return a0;
157  }
158  static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
159    return Average2(Average2(a0, a2), a1);
160  }
161  static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
162                                       uint32_t a2, uint32_t a3) {
163    return Average2(Average2(a0, a1), Average2(a2, a3));
164  }
<span onclick='openModal()' class='match'>165  static uint32_t Predictor5_MIPSdspR2(uint32_t left, const uint32_t* const top) {
166    return Average3(left, top[0], top[1]);
167  }
168  static uint32_t Predictor6_MIPSdspR2(uint32_t left, const uint32_t* const top) {
</span>169    return Average2(left, top[-1]);
170  }
171  static uint32_t Predictor7_MIPSdspR2(uint32_t left, const uint32_t* const top) {
172    return Average2(left, top[0]);
173  }
174  static uint32_t Predictor8_MIPSdspR2(uint32_t left, const uint32_t* const top) {
175    (void)left;
176    return Average2(top[-1], top[0]);
177  }
178  static uint32_t Predictor9_MIPSdspR2(uint32_t left, const uint32_t* const top) {
179    (void)left;
180    return Average2(top[0], top[1]);
181  }
182  static uint32_t Predictor10_MIPSdspR2(uint32_t left,
183                                        const uint32_t* const top) {
184    return Average4(left, top[-1], top[0], top[1]);
185  }
186  static uint32_t Predictor11_MIPSdspR2(uint32_t left,
187                                        const uint32_t* const top) {
188    return Select(top[0], left, top[-1]);
189  }
190  static uint32_t Predictor12_MIPSdspR2(uint32_t left,
191                                        const uint32_t* const top) {
192    return ClampedAddSubtractFull(left, top[0], top[-1]);
193  }
194  static uint32_t Predictor13_MIPSdspR2(uint32_t left,
195                                        const uint32_t* const top) {
196    return ClampedAddSubtractHalf(left, top[0], top[-1]);
197  }
198  static void AddGreenToBlueAndRed_MIPSdspR2(const uint32_t* src, int num_pixels,
199                                             uint32_t* dst) {
200    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
201    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
202    const uint32_t* const p_loop2_end = src + num_pixels;
203    __asm__ volatile (
204      ".set       push                                          \n\t"
205      ".set       noreorder                                     \n\t"
206      "beq        %[src],          %[p_loop1_end],     3f       \n\t"
207      " nop                                                     \n\t"
208    "0:                                                         \n\t"
209      "lw         %[temp0],        0(%[src])                    \n\t"
210      "lw         %[temp1],        4(%[src])                    \n\t"
211      "lw         %[temp2],        8(%[src])                    \n\t"
212      "lw         %[temp3],        12(%[src])                   \n\t"
213      "ext        %[temp4],        %[temp0],           8,    8  \n\t"
214      "ext        %[temp5],        %[temp1],           8,    8  \n\t"
215      "ext        %[temp6],        %[temp2],           8,    8  \n\t"
216      "ext        %[temp7],        %[temp3],           8,    8  \n\t"
217      "addiu      %[src],          %[src],             16       \n\t"
218      "addiu      %[dst],          %[dst],             16       \n\t"
219      "replv.ph   %[temp4],        %[temp4]                     \n\t"
220      "replv.ph   %[temp5],        %[temp5]                     \n\t"
221      "replv.ph   %[temp6],        %[temp6]                     \n\t"
222      "replv.ph   %[temp7],        %[temp7]                     \n\t"
223      "addu.qb    %[temp0],        %[temp0],           %[temp4] \n\t"
224      "addu.qb    %[temp1],        %[temp1],           %[temp5] \n\t"
225      "addu.qb    %[temp2],        %[temp2],           %[temp6] \n\t"
226      "addu.qb    %[temp3],        %[temp3],           %[temp7] \n\t"
227      "sw         %[temp0],        -16(%[dst])                  \n\t"
228      "sw         %[temp1],        -12(%[dst])                  \n\t"
229      "sw         %[temp2],        -8(%[dst])                   \n\t"
230      "bne        %[src],          %[p_loop1_end],     0b       \n\t"
231      " sw        %[temp3],        -4(%[dst])                   \n\t"
232    "3:                                                         \n\t"
233      "beq        %[src],          %[p_loop2_end],     2f       \n\t"
234      " nop                                                     \n\t"
235    "1:                                                         \n\t"
236      "lw         %[temp0],        0(%[src])                    \n\t"
237      "addiu      %[src],          %[src],             4        \n\t"
238      "addiu      %[dst],          %[dst],             4        \n\t"
239      "ext        %[temp4],        %[temp0],           8,    8  \n\t"
240      "replv.ph   %[temp4],        %[temp4]                     \n\t"
241      "addu.qb    %[temp0],        %[temp0],           %[temp4] \n\t"
242      "bne        %[src],          %[p_loop2_end],     1b       \n\t"
243      " sw        %[temp0],        -4(%[dst])                   \n\t"
244    "2:                                                         \n\t"
245      ".set       pop                                           \n\t"
246      : [dst]"+&r"(dst), [src]"+&r"(src), [temp0]"=&r"(temp0),
247        [temp1]"=&r"(temp1), [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
248        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [temp6]"=&r"(temp6),
249        [temp7]"=&r"(temp7)
250      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
251      : "memory"
252    );
253  }
254  static void TransformColorInverse_MIPSdspR2(const VP8LMultipliers* const m,
255                                              const uint32_t* src, int num_pixels,
256                                              uint32_t* dst) {
257    int temp0, temp1, temp2, temp3, temp4, temp5;
258    uint32_t argb, argb1, new_red;
259    const uint32_t G_to_R = m->green_to_red_;
260    const uint32_t G_to_B = m->green_to_blue_;
261    const uint32_t R_to_B = m->red_to_blue_;
262    const uint32_t* const p_loop_end = src + (num_pixels & ~1);
263    __asm__ volatile (
264      ".set            push                                    \n\t"
265      ".set            noreorder                               \n\t"
266      "beq             %[src],       %[p_loop_end],  1f        \n\t"
267      " nop                                                    \n\t"
268      "replv.ph        %[temp0],     %[G_to_R]                 \n\t"
269      "replv.ph        %[temp1],     %[G_to_B]                 \n\t"
270      "replv.ph        %[temp2],     %[R_to_B]                 \n\t"
271      "shll.ph         %[temp0],     %[temp0],       8         \n\t"
272      "shll.ph         %[temp1],     %[temp1],       8         \n\t"
273      "shll.ph         %[temp2],     %[temp2],       8         \n\t"
274      "shra.ph         %[temp0],     %[temp0],       8         \n\t"
275      "shra.ph         %[temp1],     %[temp1],       8         \n\t"
276      "shra.ph         %[temp2],     %[temp2],       8         \n\t"
277    "0:                                                        \n\t"
278      "lw              %[argb],      0(%[src])                 \n\t"
279      "lw              %[argb1],     4(%[src])                 \n\t"
280      "sw              %[argb],      0(%[dst])                 \n\t"
281      "sw              %[argb1],     4(%[dst])                 \n\t"
282      "addiu           %[src],       %[src],         8         \n\t"
283      "addiu           %[dst],       %[dst],         8         \n\t"
284      "precrq.qb.ph    %[temp3],     %[argb],        %[argb1]  \n\t"
285      "preceu.ph.qbra  %[temp3],     %[temp3]                  \n\t"
286      "shll.ph         %[temp3],     %[temp3],       8         \n\t"
287      "shra.ph         %[temp3],     %[temp3],       8         \n\t"
288      "mul.ph          %[temp5],     %[temp3],       %[temp0]  \n\t"
289      "mul.ph          %[temp3],     %[temp3],       %[temp1]  \n\t"
290      "precrq.ph.w     %[new_red],   %[argb],        %[argb1]  \n\t"
291      "ins             %[argb1],     %[argb],        16,   16  \n\t"
292      "shra.ph         %[temp5],     %[temp5],       5         \n\t"
293      "shra.ph         %[temp3],     %[temp3],       5         \n\t"
294      "addu.ph         %[new_red],   %[new_red],     %[temp5]  \n\t"
295      "addu.ph         %[argb1],     %[argb1],       %[temp3]  \n\t"
296      "preceu.ph.qbra  %[temp5],     %[new_red]                \n\t"
297      "shll.ph         %[temp4],     %[temp5],       8         \n\t"
298      "shra.ph         %[temp4],     %[temp4],       8         \n\t"
299      "mul.ph          %[temp4],     %[temp4],       %[temp2]  \n\t"
300      "sb              %[temp5],     -2(%[dst])                \n\t"
301      "sra             %[temp5],     %[temp5],       16        \n\t"
302      "shra.ph         %[temp4],     %[temp4],       5         \n\t"
303      "addu.ph         %[argb1],     %[argb1],       %[temp4]  \n\t"
304      "preceu.ph.qbra  %[temp3],     %[argb1]                  \n\t"
305      "sb              %[temp5],     -6(%[dst])                \n\t"
306      "sb              %[temp3],     -4(%[dst])                \n\t"
307      "sra             %[temp3],     %[temp3],       16        \n\t"
308      "bne             %[src],       %[p_loop_end],  0b        \n\t"
309      " sb             %[temp3],     -8(%[dst])                \n\t"
310    "1:                                                        \n\t"
311      ".set            pop                                     \n\t"
312      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
313        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
314        [new_red]"=&r"(new_red), [argb]"=&r"(argb),
315        [argb1]"=&r"(argb1), [dst]"+&r"(dst), [src]"+&r"(src)
316      : [G_to_R]"r"(G_to_R), [R_to_B]"r"(R_to_B),
317        [G_to_B]"r"(G_to_B), [p_loop_end]"r"(p_loop_end)
318      : "memory", "hi", "lo"
319    );
320    if (num_pixels & 1) VP8LTransformColorInverse_C(m, src, 1, dst);
321  }
322  static void ConvertBGRAToRGB_MIPSdspR2(const uint32_t* src,
323                                         int num_pixels, uint8_t* dst) {
324    int temp0, temp1, temp2, temp3;
325    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
326    const uint32_t* const p_loop2_end = src + num_pixels;
327    __asm__ volatile (
328      ".set       push                                       \n\t"
329      ".set       noreorder                                  \n\t"
330      "beq        %[src],      %[p_loop1_end],    3f         \n\t"
331      " nop                                                  \n\t"
332    "0:                                                      \n\t"
333      "lw         %[temp3],    12(%[src])                    \n\t"
334      "lw         %[temp2],    8(%[src])                     \n\t"
335      "lw         %[temp1],    4(%[src])                     \n\t"
336      "lw         %[temp0],    0(%[src])                     \n\t"
337      "ins        %[temp3],    %[temp2],          24,   8    \n\t"
338      "sll        %[temp2],    %[temp2],          8          \n\t"
339      "rotr       %[temp3],    %[temp3],          16         \n\t"
340      "ins        %[temp2],    %[temp1],          0,    16   \n\t"
341      "sll        %[temp1],    %[temp1],          8          \n\t"
342      "wsbh       %[temp3],    %[temp3]                      \n\t"
343      "balign     %[temp0],    %[temp1],          1          \n\t"
344      "wsbh       %[temp2],    %[temp2]                      \n\t"
345      "wsbh       %[temp0],    %[temp0]                      \n\t"
346      "usw        %[temp3],    8(%[dst])                     \n\t"
347      "rotr       %[temp0],    %[temp0],          16         \n\t"
348      "usw        %[temp2],    4(%[dst])                     \n\t"
349      "addiu      %[src],      %[src],            16         \n\t"
350      "usw        %[temp0],    0(%[dst])                     \n\t"
351      "bne        %[src],      %[p_loop1_end],    0b         \n\t"
352      " addiu     %[dst],      %[dst],            12         \n\t"
353    "3:                                                      \n\t"
354      "beq        %[src],      %[p_loop2_end],    2f         \n\t"
355      " nop                                                  \n\t"
356    "1:                                                      \n\t"
357      "lw         %[temp0],    0(%[src])                     \n\t"
358      "addiu      %[src],      %[src],            4          \n\t"
359      "wsbh       %[temp1],    %[temp0]                      \n\t"
360      "addiu      %[dst],      %[dst],            3          \n\t"
361      "ush        %[temp1],    -2(%[dst])                    \n\t"
362      "sra        %[temp0],    %[temp0],          16         \n\t"
363      "bne        %[src],      %[p_loop2_end],    1b         \n\t"
364      " sb        %[temp0],    -3(%[dst])                    \n\t"
365    "2:                                                      \n\t"
366      ".set       pop                                        \n\t"
367      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
368        [temp3]"=&r"(temp3), [dst]"+&r"(dst), [src]"+&r"(src)
369      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
370      : "memory"
371    );
372  }
373  static void ConvertBGRAToRGBA_MIPSdspR2(const uint32_t* src,
374                                          int num_pixels, uint8_t* dst) {
375    int temp0, temp1, temp2, temp3;
376    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
377    const uint32_t* const p_loop2_end = src + num_pixels;
378    __asm__ volatile (
379      ".set       push                                       \n\t"
380      ".set       noreorder                                  \n\t"
381      "beq        %[src],      %[p_loop1_end],    3f         \n\t"
382      " nop                                                  \n\t"
383    "0:                                                      \n\t"
384      "lw         %[temp0],    0(%[src])                     \n\t"
385      "lw         %[temp1],    4(%[src])                     \n\t"
386      "lw         %[temp2],    8(%[src])                     \n\t"
387      "lw         %[temp3],    12(%[src])                    \n\t"
388      "wsbh       %[temp0],    %[temp0]                      \n\t"
389      "wsbh       %[temp1],    %[temp1]                      \n\t"
390      "wsbh       %[temp2],    %[temp2]                      \n\t"
391      "wsbh       %[temp3],    %[temp3]                      \n\t"
392      "addiu      %[src],      %[src],            16         \n\t"
393      "balign     %[temp0],    %[temp0],          1          \n\t"
394      "balign     %[temp1],    %[temp1],          1          \n\t"
395      "balign     %[temp2],    %[temp2],          1          \n\t"
396      "balign     %[temp3],    %[temp3],          1          \n\t"
397      "usw        %[temp0],    0(%[dst])                     \n\t"
398      "usw        %[temp1],    4(%[dst])                     \n\t"
399      "usw        %[temp2],    8(%[dst])                     \n\t"
400      "usw        %[temp3],    12(%[dst])                    \n\t"
401      "bne        %[src],      %[p_loop1_end],    0b         \n\t"
402      " addiu     %[dst],      %[dst],            16         \n\t"
403    "3:                                                      \n\t"
404      "beq        %[src],      %[p_loop2_end],    2f         \n\t"
405      " nop                                                  \n\t"
406    "1:                                                      \n\t"
407      "lw         %[temp0],    0(%[src])                     \n\t"
408      "wsbh       %[temp0],    %[temp0]                      \n\t"
409      "addiu      %[src],      %[src],            4          \n\t"
410      "balign     %[temp0],    %[temp0],          1          \n\t"
411      "usw        %[temp0],    0(%[dst])                     \n\t"
412      "bne        %[src],      %[p_loop2_end],    1b         \n\t"
413      " addiu     %[dst],      %[dst],            4          \n\t"
414    "2:                                                      \n\t"
415      ".set       pop                                        \n\t"
416      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
417        [temp3]"=&r"(temp3), [dst]"+&r"(dst), [src]"+&r"(src)
418      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
419      : "memory"
420    );
421  }
422  static void ConvertBGRAToRGBA4444_MIPSdspR2(const uint32_t* src,
423                                              int num_pixels, uint8_t* dst) {
424    int temp0, temp1, temp2, temp3, temp4, temp5;
425    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
426    const uint32_t* const p_loop2_end = src + num_pixels;
427    __asm__ volatile (
428      ".set           push                                       \n\t"
429      ".set           noreorder                                  \n\t"
430      "beq            %[src],      %[p_loop1_end],    3f         \n\t"
431      " nop                                                      \n\t"
432    "0:                                                          \n\t"
433      "lw             %[temp0],    0(%[src])                     \n\t"
434      "lw             %[temp1],    4(%[src])                     \n\t"
435      "lw             %[temp2],    8(%[src])                     \n\t"
436      "lw             %[temp3],    12(%[src])                    \n\t"
437      "ext            %[temp4],    %[temp0],          28,   4    \n\t"
438      "ext            %[temp5],    %[temp0],          12,   4    \n\t"
439      "ins            %[temp0],    %[temp4],          0,    4    \n\t"
440      "ext            %[temp4],    %[temp1],          28,   4    \n\t"
441      "ins            %[temp0],    %[temp5],          16,   4    \n\t"
442      "ext            %[temp5],    %[temp1],          12,   4    \n\t"
443      "ins            %[temp1],    %[temp4],          0,    4    \n\t"
444      "ext            %[temp4],    %[temp2],          28,   4    \n\t"
445      "ins            %[temp1],    %[temp5],          16,   4    \n\t"
446      "ext            %[temp5],    %[temp2],          12,   4    \n\t"
447      "ins            %[temp2],    %[temp4],          0,    4    \n\t"
448      "ext            %[temp4],    %[temp3],          28,   4    \n\t"
449      "ins            %[temp2],    %[temp5],          16,   4    \n\t"
450      "ext            %[temp5],    %[temp3],          12,   4    \n\t"
451      "ins            %[temp3],    %[temp4],          0,    4    \n\t"
452      "precr.qb.ph    %[temp1],    %[temp1],          %[temp0]   \n\t"
453      "ins            %[temp3],    %[temp5],          16,   4    \n\t"
454      "addiu          %[src],      %[src],            16         \n\t"
455      "precr.qb.ph    %[temp3],    %[temp3],          %[temp2]   \n\t"
456  #if (WEBP_SWAP_16BIT_CSP == 1)
457      "usw            %[temp1],    0(%[dst])                     \n\t"
458      "usw            %[temp3],    4(%[dst])                     \n\t"
459  #else
460      "wsbh           %[temp1],    %[temp1]                      \n\t"
461      "wsbh           %[temp3],    %[temp3]                      \n\t"
462      "usw            %[temp1],    0(%[dst])                     \n\t"
463      "usw            %[temp3],    4(%[dst])                     \n\t"
464  #endif
465      "bne            %[src],      %[p_loop1_end],    0b         \n\t"
466      " addiu         %[dst],      %[dst],            8          \n\t"
467    "3:                                                          \n\t"
468      "beq            %[src],      %[p_loop2_end],    2f         \n\t"
469      " nop                                                      \n\t"
470    "1:                                                          \n\t"
471      "lw             %[temp0],    0(%[src])                     \n\t"
472      "ext            %[temp4],    %[temp0],          28,   4    \n\t"
473      "ext            %[temp5],    %[temp0],          12,   4    \n\t"
474      "ins            %[temp0],    %[temp4],          0,    4    \n\t"
475      "ins            %[temp0],    %[temp5],          16,   4    \n\t"
476      "addiu          %[src],      %[src],            4          \n\t"
477      "precr.qb.ph    %[temp0],    %[temp0],          %[temp0]   \n\t"
478  #if (WEBP_SWAP_16BIT_CSP == 1)
479      "ush            %[temp0],    0(%[dst])                     \n\t"
480  #else
481      "wsbh           %[temp0],    %[temp0]                      \n\t"
482      "ush            %[temp0],    0(%[dst])                     \n\t"
483  #endif
484      "bne            %[src],      %[p_loop2_end],    1b         \n\t"
485      " addiu         %[dst],      %[dst],            2          \n\t"
486    "2:                                                          \n\t"
487      ".set           pop                                        \n\t"
488      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
489        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
490        [dst]"+&r"(dst), [src]"+&r"(src)
491      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
492      : "memory"
493    );
494  }
495  static void ConvertBGRAToRGB565_MIPSdspR2(const uint32_t* src,
496                                            int num_pixels, uint8_t* dst) {
497    int temp0, temp1, temp2, temp3, temp4, temp5;
498    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
499    const uint32_t* const p_loop2_end = src + num_pixels;
500    __asm__ volatile (
501      ".set           push                                       \n\t"
502      ".set           noreorder                                  \n\t"
503      "beq            %[src],      %[p_loop1_end],    3f         \n\t"
504      " nop                                                      \n\t"
505    "0:                                                          \n\t"
506      "lw             %[temp0],    0(%[src])                     \n\t"
507      "lw             %[temp1],    4(%[src])                     \n\t"
508      "lw             %[temp2],    8(%[src])                     \n\t"
509      "lw             %[temp3],    12(%[src])                    \n\t"
510      "ext            %[temp4],    %[temp0],          8,    16   \n\t"
511      "ext            %[temp5],    %[temp0],          5,    11   \n\t"
512      "ext            %[temp0],    %[temp0],          3,    5    \n\t"
513      "ins            %[temp4],    %[temp5],          0,    11   \n\t"
514      "ext            %[temp5],    %[temp1],          5,    11   \n\t"
515      "ins            %[temp4],    %[temp0],          0,    5    \n\t"
516      "ext            %[temp0],    %[temp1],          8,    16   \n\t"
517      "ext            %[temp1],    %[temp1],          3,    5    \n\t"
518      "ins            %[temp0],    %[temp5],          0,    11   \n\t"
519      "ext            %[temp5],    %[temp2],          5,    11   \n\t"
520      "ins            %[temp0],    %[temp1],          0,    5    \n\t"
521      "ext            %[temp1],    %[temp2],          8,    16   \n\t"
522      "ext            %[temp2],    %[temp2],          3,    5    \n\t"
523      "ins            %[temp1],    %[temp5],          0,    11   \n\t"
524      "ext            %[temp5],    %[temp3],          5,    11   \n\t"
525      "ins            %[temp1],    %[temp2],          0,    5    \n\t"
526      "ext            %[temp2],    %[temp3],          8,    16   \n\t"
527      "ext            %[temp3],    %[temp3],          3,    5    \n\t"
528      "ins            %[temp2],    %[temp5],          0,    11   \n\t"
529      "append         %[temp0],    %[temp4],          16         \n\t"
530      "ins            %[temp2],    %[temp3],          0,    5    \n\t"
531      "addiu          %[src],      %[src],            16         \n\t"
532      "append         %[temp2],    %[temp1],          16         \n\t"
533  #if (WEBP_SWAP_16BIT_CSP == 1)
534      "usw            %[temp0],    0(%[dst])                     \n\t"
535      "usw            %[temp2],    4(%[dst])                     \n\t"
536  #else
537      "wsbh           %[temp0],    %[temp0]                      \n\t"
538      "wsbh           %[temp2],    %[temp2]                      \n\t"
539      "usw            %[temp0],    0(%[dst])                     \n\t"
540      "usw            %[temp2],    4(%[dst])                     \n\t"
541  #endif
542      "bne            %[src],      %[p_loop1_end],    0b         \n\t"
543      " addiu         %[dst],      %[dst],            8          \n\t"
544    "3:                                                          \n\t"
545      "beq            %[src],      %[p_loop2_end],    2f         \n\t"
546      " nop                                                      \n\t"
547    "1:                                                          \n\t"
548      "lw             %[temp0],    0(%[src])                     \n\t"
549      "ext            %[temp4],    %[temp0],          8,    16   \n\t"
550      "ext            %[temp5],    %[temp0],          5,    11   \n\t"
551      "ext            %[temp0],    %[temp0],          3,    5    \n\t"
552      "ins            %[temp4],    %[temp5],          0,    11   \n\t"
553      "addiu          %[src],      %[src],            4          \n\t"
554      "ins            %[temp4],    %[temp0],          0,    5    \n\t"
555  #if (WEBP_SWAP_16BIT_CSP == 1)
556      "ush            %[temp4],    0(%[dst])                     \n\t"
557  #else
558      "wsbh           %[temp4],    %[temp4]                      \n\t"
559      "ush            %[temp4],    0(%[dst])                     \n\t"
560  #endif
561      "bne            %[src],      %[p_loop2_end],    1b         \n\t"
562      " addiu         %[dst],      %[dst],            2          \n\t"
563    "2:                                                          \n\t"
564      ".set           pop                                        \n\t"
565      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
566        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
567        [dst]"+&r"(dst), [src]"+&r"(src)
568      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
569      : "memory"
570    );
571  }
572  static void ConvertBGRAToBGR_MIPSdspR2(const uint32_t* src,
573                                         int num_pixels, uint8_t* dst) {
574    int temp0, temp1, temp2, temp3;
575    const uint32_t* const p_loop1_end = src + (num_pixels & ~3);
576    const uint32_t* const p_loop2_end = src + num_pixels;
577    __asm__ volatile (
578      ".set       push                                         \n\t"
579      ".set       noreorder                                    \n\t"
580      "beq        %[src],      %[p_loop1_end],    3f           \n\t"
581      " nop                                                    \n\t"
582    "0:                                                        \n\t"
583      "lw         %[temp0],    0(%[src])                       \n\t"
584      "lw         %[temp1],    4(%[src])                       \n\t"
585      "lw         %[temp2],    8(%[src])                       \n\t"
586      "lw         %[temp3],    12(%[src])                      \n\t"
587      "ins        %[temp0],    %[temp1],          24,    8     \n\t"
588      "sra        %[temp1],    %[temp1],          8            \n\t"
589      "ins        %[temp1],    %[temp2],          16,    16    \n\t"
590      "sll        %[temp2],    %[temp2],          8            \n\t"
591      "balign     %[temp3],    %[temp2],          1            \n\t"
592      "addiu      %[src],      %[src],            16           \n\t"
593      "usw        %[temp0],    0(%[dst])                       \n\t"
594      "usw        %[temp1],    4(%[dst])                       \n\t"
595      "usw        %[temp3],    8(%[dst])                       \n\t"
596      "bne        %[src],      %[p_loop1_end],    0b           \n\t"
597      " addiu     %[dst],      %[dst],            12           \n\t"
598    "3:                                                        \n\t"
599      "beq        %[src],      %[p_loop2_end],    2f           \n\t"
600      " nop                                                    \n\t"
601    "1:                                                        \n\t"
602      "lw         %[temp0],    0(%[src])                       \n\t"
603      "addiu      %[src],      %[src],            4            \n\t"
604      "addiu      %[dst],      %[dst],            3            \n\t"
605      "ush        %[temp0],    -3(%[dst])                      \n\t"
606      "sra        %[temp0],    %[temp0],          16           \n\t"
607      "bne        %[src],      %[p_loop2_end],    1b           \n\t"
608      " sb        %[temp0],    -1(%[dst])                      \n\t"
609    "2:                                                        \n\t"
610      ".set       pop                                          \n\t"
611      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
612        [temp3]"=&r"(temp3), [dst]"+&r"(dst), [src]"+&r"(src)
613      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
614      : "memory"
615    );
616  }
617  extern void VP8LDspInitMIPSdspR2(void);
618  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitMIPSdspR2(void) {
619    VP8LMapColor32b = MapARGB_MIPSdspR2;
620    VP8LMapColor8b = MapAlpha_MIPSdspR2;
621    VP8LPredictors[5] = Predictor5_MIPSdspR2;
622    VP8LPredictors[6] = Predictor6_MIPSdspR2;
623    VP8LPredictors[7] = Predictor7_MIPSdspR2;
624    VP8LPredictors[8] = Predictor8_MIPSdspR2;
625    VP8LPredictors[9] = Predictor9_MIPSdspR2;
626    VP8LPredictors[10] = Predictor10_MIPSdspR2;
627    VP8LPredictors[11] = Predictor11_MIPSdspR2;
628    VP8LPredictors[12] = Predictor12_MIPSdspR2;
629    VP8LPredictors[13] = Predictor13_MIPSdspR2;
630    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_MIPSdspR2;
631    VP8LTransformColorInverse = TransformColorInverse_MIPSdspR2;
632    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_MIPSdspR2;
633    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_MIPSdspR2;
634    VP8LConvertBGRAToRGBA4444 = ConvertBGRAToRGBA4444_MIPSdspR2;
635    VP8LConvertBGRAToRGB565 = ConvertBGRAToRGB565_MIPSdspR2;
636    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_MIPSdspR2;
637  }
638  #else  
639  WEBP_DSP_INIT_STUB(VP8LDspInitMIPSdspR2)
640  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-redft00e-r2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_mips_dsp_r2.c</div>
                </div>
                <div class="column column_space"><pre><code>91  static int applicable(const solver *ego, const problem *p, const planner *plnr)
92  {
93       return (!NO_SLOWP(plnr) && applicable0(ego, p));
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
</pre></code></div>
                <div class="column column_space"><pre><code>165  static uint32_t Predictor5_MIPSdspR2(uint32_t left, const uint32_t* const top) {
166    return Average3(left, top[0], top[1]);
167  }
168  static uint32_t Predictor6_MIPSdspR2(uint32_t left, const uint32_t* const top) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    