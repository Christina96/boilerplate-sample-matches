<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmjsonparse.c &amp; mmsnmptrapd.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmjsonparse.c &amp; mmsnmptrapd.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmjsonparse.c (9.813084%)<th>mmsnmptrapd.c (8.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(365-395)<td><a href="#" name="0">(392-422)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmjsonparse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;signal.h&gt;
8 #include &lt;errno.h&gt;
9 #include &lt;unistd.h&gt;
10 #include &lt;ctype.h&gt;
11 #include &lt;json.h&gt;
12 #include "rsyslog.h"
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "template.h"
16 #include "module-template.h"
17 #include "errmsg.h"
18 #include "cfsysline.h"
19 #include "parserif.h"
20 #include "dirty.h"
21 MODULE_TYPE_OUTPUT
22 MODULE_TYPE_NOKEEP
23 MODULE_CNFNAME("mmjsonparse")
24 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
25 DEF_OMOD_STATIC_DATA
26 typedef struct _instanceData {
27 	char *cookie;
28 	uchar *container;
29 	int lenCookie;
30 } instanceData;
31 typedef struct wrkrInstanceData {
32 	instanceData *pData;
33 	struct json_tokener *tokener;
34 } wrkrInstanceData_t;
35 struct modConfData_s {
36 	rsconf_t *pConf;	};
37 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
38 static struct cnfparamdescr actpdescr[] = {
39 	{ "cookie", eCmdHdlrString, 0 },
40 	{ "container", eCmdHdlrString, 0 },
41 	{ "userawmsg", eCmdHdlrBinary, 0 }
42 };
43 static struct cnfparamblk actpblk =
44 	{ CNFPARAMBLK_VERSION,
45 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
46 	  actpdescr
47 	};
48 BEGINbeginCnfLoad
49 CODESTARTbeginCnfLoad
50 	loadModConf = pModConf;
51 	pModConf-&gt;pConf = pConf;
52 ENDbeginCnfLoad
53 BEGINendCnfLoad
54 CODESTARTendCnfLoad
55 ENDendCnfLoad
56 BEGINcheckCnf
57 CODESTARTcheckCnf
58 ENDcheckCnf
59 BEGINactivateCnf
60 CODESTARTactivateCnf
61 	runModConf = pModConf;
62 ENDactivateCnf
63 BEGINfreeCnf
64 CODESTARTfreeCnf
65 ENDfreeCnf
66 BEGINcreateInstance
67 CODESTARTcreateInstance
68 	CHKmalloc(pData-&gt;container = (uchar*)strdup("!"));
69 	CHKmalloc(pData-&gt;cookie = strdup(CONST_CEE_COOKIE));
70 	pData-&gt;lenCookie = CONST_LEN_CEE_COOKIE;
71 finalize_it:
72 ENDcreateInstance
73 BEGINcreateWrkrInstance
74 CODESTARTcreateWrkrInstance
75 	pWrkrData-&gt;tokener = json_tokener_new();
76 	if(pWrkrData-&gt;tokener == NULL) {
77 		LogError(0, RS_RET_ERR, "error: could not create json "
78 				"tokener, cannot activate instance");
79 		ABORT_FINALIZE(RS_RET_ERR);
80 	}
81 finalize_it:
82 ENDcreateWrkrInstance
83 BEGINisCompatibleWithFeature
84 CODESTARTisCompatibleWithFeature
85 ENDisCompatibleWithFeature
86 BEGINfreeInstance
87 CODESTARTfreeInstance
88 	free(pData-&gt;cookie);
89 	free(pData-&gt;container);
90 ENDfreeInstance
91 BEGINfreeWrkrInstance
92 CODESTARTfreeWrkrInstance
93 	if(pWrkrData-&gt;tokener != NULL)
94 		json_tokener_free(pWrkrData-&gt;tokener);
95 ENDfreeWrkrInstance
96 BEGINdbgPrintInstInfo
97 CODESTARTdbgPrintInstInfo
98 	DBGPRINTF("mmjsonparse\n");
99 ENDdbgPrintInstInfo
100 BEGINtryResume
101 CODESTARTtryResume
102 ENDtryResume
103 static rsRetVal
104 processJSON(wrkrInstanceData_t *pWrkrData, smsg_t *pMsg, char *buf, size_t lenBuf)
105 {
106 	struct json_object *json;
107 	const char *errMsg;
108 	DEFiRet;
109 	assert(pWrkrData-&gt;tokener != NULL);
110 	DBGPRINTF("mmjsonparse: toParse: '%s'\n", buf);
111 	json_tokener_reset(pWrkrData-&gt;tokener);
112 	json = json_tokener_parse_ex(pWrkrData-&gt;tokener, buf, lenBuf);
113 	if(Debug) {
114 		errMsg = NULL;
115 		if(json == NULL) {
116 			enum json_tokener_error err;
117 			err = pWrkrData-&gt;tokener-&gt;err;
118 			if(err != json_tokener_continue)
119 				errMsg = json_tokener_error_desc(err);
120 			else
121 				errMsg = "Unterminated input";
122 		} else if((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
123 			errMsg = "Extra characters after JSON object";
124 		else if(!json_object_is_type(json, json_type_object))
125 			errMsg = "JSON value is not an object";
126 		if(errMsg != NULL) {
127 			DBGPRINTF("mmjsonparse: Error parsing JSON '%s': %s\n",
128 					buf, errMsg);
129 		}
130 	}
131 	if(json == NULL
132 	   || ((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
133 	   || (!json_object_is_type(json, json_type_object))) {
134 		if(json != NULL) {
135 			json_object_put(json);
136 		}
137 		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
138 	}
139 	msgAddJSON(pMsg, pWrkrData-&gt;pData-&gt;container, json, 0, 0);
140 finalize_it:
141 	RETiRet;
142 }
143 BEGINdoAction_NoStrings
144 	smsg_t **ppMsg = (smsg_t **) pMsgData;
145 	smsg_t *pMsg = ppMsg[0];
146 	uchar *buf;
147 	rs_size_t len;
148 	int bSuccess = 0;
149 	struct json_object *jval;
150 	struct json_object *json;
151 	instanceData *pData;
152 CODESTARTdoAction
153 	pData = pWrkrData-&gt;pData;
154 	if(pWrkrData-&gt;pData-&gt;bUseRawMsg)
155 		getRawMsg(pMsg, &amp;buf, &amp;len);
156 	else
157 		buf = getMSG(pMsg);
158 	while(*buf &amp;&amp; isspace(*buf)) {
159 		++buf;
160 	}
161 	if(*buf == '\0' || strncmp((char*)buf, pData-&gt;cookie, pData-&gt;lenCookie)) {
162 		DBGPRINTF("mmjsonparse: no JSON cookie: '%s'\n", buf);
163 		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
164 	}
165 	buf += pData-&gt;lenCookie;
166 	CHKiRet(processJSON(pWrkrData, pMsg, (char*) buf, strlen((char*)buf)));
167 	bSuccess = 1;
168 finalize_it:
169 	if(iRet == RS_RET_NO_CEE_MSG) {
170 		json = json_object_new_object();
171 		jval = json_object_new_string((char*)buf);
172 		json_object_object_add(json, "msg", jval);
173 		msgAddJSON(pMsg, pData-&gt;container, json, 0, 0);
174 		iRet = RS_RET_OK;
175 	}
176 	MsgSetParseSuccess(pMsg, bSuccess);
177 ENDdoAction
178 static inline void
179 setInstParamDefaults(instanceData *pData)
180 {
181 	pData-&gt;bUseRawMsg = 0;
182 }
183 BEGINnewActInst
184 	struct cnfparamvals *pvals;
185 	int i;
186 CODESTARTnewActInst
187 	DBGPRINTF("newActInst (mmjsonparse)\n");
188 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
189 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
190 	}
191 	CODE_STD_STRING_REQUESTnewActInst(1)
192 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
193 	CHKiRet(createInstance(&amp;pData));
194 	setInstParamDefaults(pData);
195 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
196 		if(!pvals[i].bUsed)
197 			continue;
198 		if(!strcmp(actpblk.descr[i].name, "cookie")) {
199 			free(pData-&gt;cookie);
200 			pData-&gt;cookie = es_str2cstr(pvals[i].val.d.estr, NULL);
201 		} else if(!strcmp(actpblk.descr[i].name, "container")) {
202 			free(pData-&gt;container);
203 			size_t lenvar = es_strlen(pvals[i].val.d.estr);
204 			pData-&gt;container = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
205 			if(pData-&gt;container[0] == '$') {
206 				memmove(pData-&gt;container, pData-&gt;container+1,  lenvar);
207 				--lenvar;
208 			}
209 			if(   (lenvar == 0)
210 			   || (  !(   pData-&gt;container[0] == '!'
211 			           || pData-&gt;container[0] == '.'
212 			           || pData-&gt;container[0] == '/' ) )
213 			   ) {
214 			parser_errmsg("mmjsonparse: invalid container name '%s', name must "
215 				"start with either '$!', '$.', or '$/'", pData-&gt;container);
216 			ABORT_FINALIZE(RS_RET_INVALID_VAR);
217 		}
218 		} else if(!strcmp(actpblk.descr[i].name, "userawmsg")) {
219 			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
220 		} else {
221 			dbgprintf("mmjsonparse: program error, non-handled param '%s'\n", actpblk.descr[i].name);
222 		}
223 	}
224 	if(pData-&gt;container == NULL)
225 		CHKmalloc(pData-&gt;container = (uchar*) strdup("!"));
226 	pData-&gt;lenCookie = strlen(pData-&gt;cookie);
227 CODE_STD_FINALIZERnewActInst
228 	cnfparamvalsDestruct(pvals, &amp;actpblk);
229 ENDnewActInst
230 BEGINparseSelectorAct
231 CODESTARTparseSelectorAct
232 CODE_STD_STRING_REQUESTparseSelectorAct(1)
233 	if(strncmp((char*) p, ":mmjsonparse:", sizeof(":mmjsonparse:") - 1)) {
234 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
235 	}
236 	p += sizeof(":mmjsonparse:") - 1; 	CHKiRet(createInstance(&amp;pData));
237 	if(*(p-1) == ';')
238 		--p;
239 	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat");
240 CODE_STD_FINALIZERparseSelectorAct
241 ENDparseSelectorAct
242 BEGINmodExit
243 CODESTARTmodExit
244 ENDmodExit
245 BEGINqueryEtryPt
246 CODESTARTqueryEtryPt
247 CODEqueryEtryPt_STD_OMOD_QUERIES
248 CODEqueryEtryPt_STD_OMOD8_QUERIES
249 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
250 CODEqueryEtryPt_STD_CONF2_QUERIES
251 ENDqueryEtryPt
252 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
253 <a name="0"></a>{
254 	DEFiRet;
255 	RETiRet;
256 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
257 BEGINmodInit()
258 	rsRetVal localRet;
259 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
260 	unsigned long opts;
261 	int bMsgPassingSupported;
262 CODESTARTmodInit
263 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
264 CODEmodInit_QueryRegCFSLineHdlr
265 	DBGPRINTF("mmjsonparse: module compiled with rsyslog version %s.\n", VERSION);
266 	bMsgPassingSupported = 0;
267 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
268 			&amp;pomsrGetSupportedTplOpts);
269 	if(localRet == RS_RET_OK) {
270 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
271 		if(opts &amp; OMSR_TPL_AS_MSG)
272 			bMsgPassingSupported = 1;
273 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
274 		ABORT_FINALIZE(localRet); 	}
275 	if(!bMsgPassingSupported) {
276 		DBGPRINTF("mmjsonparse: msg-passing is not supported by rsyslog core, "
277 			  "can not continue.\n");
278 		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
279 	}</b></font>
280 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
281 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
282 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmsnmptrapd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;ctype.h&gt;
12 #include "conf.h"
13 #include "msg.h"
14 #include "syslogd-types.h"
15 #include "template.h"
16 #include "module-template.h"
17 #include "errmsg.h"
18 #include "cfsysline.h"
19 #include "unicode-helper.h"
20 #include "dirty.h"
21 MODULE_TYPE_OUTPUT
22 MODULE_TYPE_NOKEEP
23 MODULE_CNFNAME("mmsnmptrapd")
24 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
25 DEF_OMOD_STATIC_DATA
26 struct severMap_s {
27 	uchar *name;
28 	int code;
29 	struct severMap_s *next;
30 };
31 typedef struct _instanceData {
32 	uchar *pszTagName;
33 	uchar *pszTagID;		int lenTagID;			struct severMap_s *severMap;
34 } instanceData;
35 typedef struct wrkrInstanceData {
36 	instanceData *pData;
37 } wrkrInstanceData_t;
38 typedef struct configSettings_s {
39 } configSettings_t;
40 static configSettings_t cs;
41 BEGINinitConfVars		CODESTARTinitConfVars
42 	cs.pszTagName = NULL;
43 	cs.pszSeverityMapping = NULL;
44 	resetConfigVariables(NULL, NULL);
45 ENDinitConfVars
46 BEGINcreateInstance
47 CODESTARTcreateInstance
48 ENDcreateInstance
49 BEGINcreateWrkrInstance
50 CODESTARTcreateWrkrInstance
51 ENDcreateWrkrInstance
52 BEGINisCompatibleWithFeature
53 CODESTARTisCompatibleWithFeature
54 ENDisCompatibleWithFeature
55 BEGINfreeInstance
56 	struct severMap_s *node, *nodeDel;
57 CODESTARTfreeInstance
58 	for(node = pData-&gt;severMap ; node != NULL ; ) {
59 		nodeDel = node;
60 		node = node-&gt;next;
61 		free(nodeDel-&gt;name);
62 		free(nodeDel);
63 	}
64 	free(pData-&gt;pszTagName);
65 	free(pData-&gt;pszTagID);
66 ENDfreeInstance
67 BEGINfreeWrkrInstance
68 CODESTARTfreeWrkrInstance
69 ENDfreeWrkrInstance
70 BEGINdbgPrintInstInfo
71 CODESTARTdbgPrintInstInfo
72 	dbgprintf("mmsnmptrapd\n");
73 ENDdbgPrintInstInfo
74 BEGINtryResume
75 CODESTARTtryResume
76 ENDtryResume
77 static int
78 isNumeric(uchar *str)
79 {
80 	int r = 1;
81 	if(*str == '-' || *str == '+')
82 		++str;
83 	while(*str) {
84 		if(!isdigit(*str)) {
85 			r = 0;
86 			goto done;
87 		}
88 		++str;
89 	}
90 done:
91 	return r;
92 }
93 static int
94 getSubstring(uchar **psrc, uchar delim, uchar *dst, int lenDst)
95 {
96 	uchar *dstwrk = dst;
97 	uchar *src = *psrc;
98 	while(*src &amp;&amp; isspace(*src)) {
99 		++src;		}
100 	while(*src &amp;&amp; *src != delim &amp;&amp; --lenDst &gt; 0) {
101 		*dstwrk++ = *src++;
102 	}
103 	dstwrk--;
104 	while(dstwrk &gt; dst &amp;&amp; isspace(*dst))
105 		--dstwrk; 	*++dstwrk = '\0';
106 	if(*src == delim)
107 		++src;
108 	*psrc = src;
109 	return(dstwrk - dst);
110 }
111 static int ATTR_NONNULL()
112 getTagComponent(uchar *tag, uchar *const dst, int *const lenDst)
113 {
114 	int end = *lenDst - 1; 	int i;
115 	i = 0;
116 	if(tag[i] == '/') {
117 		++tag;
118 		while(i &lt; end &amp;&amp; tag[i] != '\0' &amp;&amp; tag[i] != ' ' &amp;&amp; tag[i] != '/') {
119 			dst[i] = tag[i];
120 			++i;
121 		}
122 	}
123 	dst[i] = '\0';
124 	*lenDst = i;
125 	return i;
126 }
127 static int
128 lookupSeverityCode(instanceData *pData, uchar *sever)
129 {
130 	struct severMap_s *node;
131 	int sevCode = -1;
132 	for(node = pData-&gt;severMap ; node != NULL ; node = node-&gt;next) {
133 		if(!ustrcmp(node-&gt;name, sever)) {
134 			sevCode = node-&gt;code;
135 			break;
136 		}
137 	}
138 	return sevCode;
139 }
140 BEGINdoAction_NoStrings
141 	smsg_t **ppMsg = (smsg_t **) pMsgData;
142 	smsg_t *pMsg = ppMsg[0];
143 	int lenTAG;
144 	int lenSever;
145 	int lenHost;
146 	int sevCode;
147 	uchar *pszTag;
148 	uchar pszSever[512];
149 	uchar pszHost[512];
150 	instanceData *pData;
151 CODESTARTdoAction
152 	pData = pWrkrData-&gt;pData;
153 	getTAG(pMsg, &amp;pszTag, &amp;lenTAG, LOCK_MUTEX);
154 	if(strncmp((char*)pszTag, (char*)pData-&gt;pszTagID, pData-&gt;lenTagID)) {
155 		DBGPRINTF("tag '%s' not matching, mmsnmptrapd ignoring this message\n",
156 			  pszTag);
157 		FINALIZE;
158 	}
159 	lenSever = sizeof(pszSever);
160 	getTagComponent(pszTag+pData-&gt;lenTagID-1, pszSever, &amp;lenSever);
161 	lenHost = sizeof(pszHost);
162 	getTagComponent(pszTag+pData-&gt;lenTagID+lenSever, pszHost, &amp;lenHost);
163 	DBGPRINTF("mmsnmptrapd: sever '%s'(%d), host '%s'(%d)\n", pszSever, lenSever, pszHost,lenHost);
164 	if(lenHost &gt; 0 &amp;&amp; pszHost[lenHost-1] == ':') {
165 		pszHost[lenHost-1] = '\0';
166 		--lenHost;
167 	}
168 	sevCode = lookupSeverityCode(pData, pszSever);
169 	MsgSetTAG(pMsg, pData-&gt;pszTagName, pData-&gt;lenTagID);
170 	MsgSetHOSTNAME(pMsg, pszHost, lenHost);
171 	if(sevCode != -1)
172 		pMsg-&gt;iSeverity = sevCode; finalize_it:
173 ENDdoAction
174 static rsRetVal ATTR_NONNULL()
175 buildSeverityMapping(instanceData *const pData)
176 {
177 	uchar pszSev[512];
178 	uchar pszSevCode[512];
179 	int sevCode;
180 	uchar *mapping;
181 	struct severMap_s *node = NULL;
182 	DEFiRet;
183 	mapping = cs.pszSeverityMapping;
184 	while(1) {			if(getSubstring(&amp;mapping, '/', pszSev, sizeof(pszSev)) == 0) {
185 			FINALIZE;
186 		}
187 		if(getSubstring(&amp;mapping, ',', pszSevCode, sizeof(pszSevCode)) == 0) {
188 			LogError(0, RS_RET_ERR, "error: invalid severity mapping, cannot "
189 					"extract code. given: '%s'\n", cs.pszSeverityMapping);
190 			ABORT_FINALIZE(RS_RET_ERR);
191 		}
192 		sevCode = atoi((char*) pszSevCode);
193 		if(!isNumeric(pszSevCode))
194 			sevCode = -1;
195 		if(sevCode &lt; 0 || sevCode &gt; 7) {
196 			LogError(0, RS_RET_ERR, "error: severity code %d outside of valid "
197 					"range 0..7 (was string '%s')\n", sevCode, pszSevCode);
198 			ABORT_FINALIZE(RS_RET_ERR);
199 		}
200 		CHKmalloc(node = malloc(sizeof(struct severMap_s)));
201 		CHKmalloc(node-&gt;name = ustrdup(pszSev));
202 		node-&gt;code = sevCode;
203 		node-&gt;next = pData-&gt;severMap;
204 		pData-&gt;severMap = node;
205 		node = NULL;
206 		DBGPRINTF("mmsnmptrapd: severity string '%s' mapped to code %d\n",
207 			  pszSev, sevCode);
208 	}
209 finalize_it:
210 	if(iRet != RS_RET_OK) {
211 		free(node);
212 	}
213 	RETiRet;
214 }
215 BEGINparseSelectorAct
216 CODESTARTparseSelectorAct
217 CODE_STD_STRING_REQUESTparseSelectorAct(1)
218 	if(strncmp((char*) p, ":mmsnmptrapd:", sizeof(":mmsnmptrapd:") - 1)) {
219 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
220 	}
221 	p += sizeof(":mmsnmptrapd:") - 1; 	CHKiRet(createInstance(&amp;pData));
222 	if(*(p-1) == ';')
223 		--p;
224 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat"));
225 	if(cs.pszTagName == NULL) {
226 		CHKmalloc(pData-&gt;pszTagName = (uchar*) strdup("snmptrapd:"));
227 		CHKmalloc(pData-&gt;pszTagID = (uchar*) strdup("snmptrapd/"));
228 	} else {
229 		int lenTag = ustrlen(cs.pszTagName);
230 		CHKmalloc(pData-&gt;pszTagName = malloc(lenTag + 2));
231 		memcpy(pData-&gt;pszTagName, cs.pszTagName, lenTag);
232 		memcpy(pData-&gt;pszTagName+lenTag, ":", 2);
233 		CHKmalloc(pData-&gt;pszTagID = malloc(lenTag + 2));
234 		memcpy(pData-&gt;pszTagID, cs.pszTagName, lenTag);
235 		memcpy(pData-&gt;pszTagID+lenTag, "/", 2);
236 		free(cs.pszTagName); 	}
237 	pData-&gt;lenTagID = ustrlen(pData-&gt;pszTagID);
238 	if(cs.pszSeverityMapping != NULL) {
239 		CHKiRet(buildSeverityMapping(pData));
240 	}
241 	cs.pszTagName = NULL;
242 	free(cs.pszSeverityMapping);
243 	cs.pszSeverityMapping = NULL;
244 CODE_STD_FINALIZERparseSelectorAct
245 ENDparseSelectorAct
246 BEGINmodExit
247 CODESTARTmodExit
248 ENDmodExit
249 BEGINqueryEtryPt
250 CODESTARTqueryEtryPt
251 CODEqueryEtryPt_STD_OMOD_QUERIES
252 CODEqueryEtryPt_STD_OMOD8_QUERIES
253 CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
254 ENDqueryEtryPt
255 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
256 {
257 	DEFiRet;
258 	free(cs.pszTagName);
259 	cs.pszTagName = NULL;
260 <a name="0"></a>	free(cs.pszSeverityMapping);
261 	cs.pszSeverityMapping = NULL;
262 	RETiRet;
263 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
264 BEGINmodInit()
265 	rsRetVal localRet;
266 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
267 	unsigned long opts;
268 	int bMsgPassingSupported;
269 CODESTARTmodInit
270 INITLegCnfVars
271 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
272 CODEmodInit_QueryRegCFSLineHdlr
273 	bMsgPassingSupported = 0;
274 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
275 			&amp;pomsrGetSupportedTplOpts);
276 	if(localRet == RS_RET_OK) {
277 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
278 		if(opts &amp; OMSR_TPL_AS_MSG)
279 			bMsgPassingSupported = 1;
280 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
281 		ABORT_FINALIZE(localRet); 	}
282 	if(!bMsgPassingSupported) {
283 		DBGPRINTF("mmsnmptrapd: msg-passing is not supported by rsyslog core, "
284 			  "can not continue.\n");
285 		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
286 	}</b></font>
287 	cs.pszTagName = NULL;
288 	cs.pszSeverityMapping = NULL;
289 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdtag", 0, eCmdHdlrGetWord,
290 				    NULL, &amp;cs.pszTagName, STD_LOADABLE_MODULE_ID));
291 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdseveritymapping", 0, eCmdHdlrGetWord,
292 				    NULL, &amp;cs.pszSeverityMapping, STD_LOADABLE_MODULE_ID));
293 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
294 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
295 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
