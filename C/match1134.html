<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for mmjsonparse.c &amp; mmsnmptrapd.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmjsonparse.c &amp; mmsnmptrapd.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmjsonparse.c (9.813084%)<th>mmsnmptrapd.c (8.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(365-395)<td><a href="#" name="0">(392-422)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmjsonparse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* mmjsonparse.c
 * This is a message modification module. If give, it extracts JSON data
 * and populates the EE event structure with it.
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * File begun on 2012-02-20 by RGerhards
 *
 * Copyright 2012-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &lt;json.h&gt;

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "parserif.h"
#include "dirty.h"

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmjsonparse")

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	sbool bUseRawMsg;     /**&lt; use %rawmsg% instead of %msg% */
	char *cookie;
	uchar *container;
	int lenCookie;
	/* REMOVE dummy when real data items are to be added! */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	struct json_tokener *tokener;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "cookie", eCmdHdlrString, 0 },
	{ "container", eCmdHdlrString, 0 },
	{ "userawmsg", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};



BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
	CHKmalloc(pData-&gt;container = (uchar*)strdup("!"));
	CHKmalloc(pData-&gt;cookie = strdup(CONST_CEE_COOKIE));
	pData-&gt;lenCookie = CONST_LEN_CEE_COOKIE;
finalize_it:
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;tokener = json_tokener_new();
	if(pWrkrData-&gt;tokener == NULL) {
		LogError(0, RS_RET_ERR, "error: could not create json "
				"tokener, cannot activate instance");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;cookie);
	free(pData-&gt;container);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;tokener != NULL)
		json_tokener_free(pWrkrData-&gt;tokener);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF("mmjsonparse\n");
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static rsRetVal
processJSON(wrkrInstanceData_t *pWrkrData, smsg_t *pMsg, char *buf, size_t lenBuf)
{
	struct json_object *json;
	const char *errMsg;
	DEFiRet;

	assert(pWrkrData-&gt;tokener != NULL);
	DBGPRINTF("mmjsonparse: toParse: '%s'\n", buf);
	json_tokener_reset(pWrkrData-&gt;tokener);

	json = json_tokener_parse_ex(pWrkrData-&gt;tokener, buf, lenBuf);
	if(Debug) {
		errMsg = NULL;
		if(json == NULL) {
			enum json_tokener_error err;

			err = pWrkrData-&gt;tokener-&gt;err;
			if(err != json_tokener_continue)
				errMsg = json_tokener_error_desc(err);
			else
				errMsg = "Unterminated input";
		} else if((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
			errMsg = "Extra characters after JSON object";
		else if(!json_object_is_type(json, json_type_object))
			errMsg = "JSON value is not an object";
		if(errMsg != NULL) {
			DBGPRINTF("mmjsonparse: Error parsing JSON '%s': %s\n",
					buf, errMsg);
		}
	}
	if(json == NULL
	   || ((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
	   || (!json_object_is_type(json, json_type_object))) {
		if(json != NULL) {
			/* Release json object as we are not going to add it to pMsg */
			json_object_put(json);
		}
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}

	msgAddJSON(pMsg, pWrkrData-&gt;pData-&gt;container, json, 0, 0);
finalize_it:
	RETiRet;
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *buf;
	rs_size_t len;
	int bSuccess = 0;
	struct json_object *jval;
	struct json_object *json;
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	/* note that we can performance-optimize the interface, but this also
	 * requires changes to the libraries. For now, we accept message
	 * duplication. -- rgerhards, 2010-12-01
	 */
	if(pWrkrData-&gt;pData-&gt;bUseRawMsg)
		getRawMsg(pMsg, &amp;buf, &amp;len);
	else
		buf = getMSG(pMsg);

	while(*buf &amp;&amp; isspace(*buf)) {
		++buf;
	}

	if(*buf == '\0' || strncmp((char*)buf, pData-&gt;cookie, pData-&gt;lenCookie)) {
		DBGPRINTF("mmjsonparse: no JSON cookie: '%s'\n", buf);
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}
	buf += pData-&gt;lenCookie;
	CHKiRet(processJSON(pWrkrData, pMsg, (char*) buf, strlen((char*)buf)));
	bSuccess = 1;
finalize_it:
	if(iRet == RS_RET_NO_CEE_MSG) {
		/* add buf as msg */
		json = json_object_new_object();
		jval = json_object_new_string((char*)buf);
		json_object_object_add(json, "msg", jval);
		msgAddJSON(pMsg, pData-&gt;container, json, 0, 0);
		iRet = RS_RET_OK;
	}
	MsgSetParseSuccess(pMsg, bSuccess);
ENDdoAction

static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;bUseRawMsg = 0;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmjsonparse)\n");
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}


	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "cookie")) {
			free(pData-&gt;cookie);
			pData-&gt;cookie = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "container")) {
			free(pData-&gt;container);
			size_t lenvar = es_strlen(pvals[i].val.d.estr);
			pData-&gt;container = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pData-&gt;container[0] == '$') {
				/* pre 8.35, the container name needed to be specified without
				 * the leading $. This was confusing, so we now require a full
				 * variable name. Nevertheless, we still need to support the
				 * version without $. -- rgerhards, 2018-05-16
				 */
				/* copy lenvar size because of \0 string terminator */
				memmove(pData-&gt;container, pData-&gt;container+1,  lenvar);
				--lenvar;
			}
			if(   (lenvar == 0)
			   || (  !(   pData-&gt;container[0] == '!'
			           || pData-&gt;container[0] == '.'
			           || pData-&gt;container[0] == '/' ) )
			   ) {
			parser_errmsg("mmjsonparse: invalid container name '%s', name must "
				"start with either '$!', '$.', or '$/'", pData-&gt;container);
			ABORT_FINALIZE(RS_RET_INVALID_VAR);
		}
		} else if(!strcmp(actpblk.descr[i].name, "userawmsg")) {
			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("mmjsonparse: program error, non-handled param '%s'\n", actpblk.descr[i].name);
		}
	}

	if(pData-&gt;container == NULL)
		CHKmalloc(pData-&gt;container = (uchar*) strdup("!"));
	pData-&gt;lenCookie = strlen(pData-&gt;cookie);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, ":mmjsonparse:", sizeof(":mmjsonparse:") - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(":mmjsonparse:") - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	/* we call the function below because we need to call it via our interface definition. However,
	 * the format specified (if any) is always ignored.
	 */
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat");
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
<a name="0"></a>{
	DEFiRet;
	RETiRet;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}


BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
		/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmjsonparse: module compiled with rsyslog version %s.\n", VERSION);
	/* check if the rsyslog core supports parameter passing code */
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports msg passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, not acceptable */
	}
	
	if(!bMsgPassingSupported) {
		DBGPRINTF("mmjsonparse: msg-passing is not supported by rsyslog core, "
			  "can not continue.\n");
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</b></font>

	
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmsnmptrapd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* mmsnmptrapd.c
 * This is a message modification module. It takes messages generated
 * from snmptrapd and modifies them so that the look like they
 * originated from the real originator.
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * File begun on 2011-05-05 by RGerhards
 *
 * Copyright 2011-2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file "COPYING" in this distribution.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include "conf.h"
#include "msg.h"
#include "syslogd-types.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "dirty.h"

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmsnmptrapd")

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

struct severMap_s {
	uchar *name;
	int code;
	struct severMap_s *next;
};

typedef struct _instanceData {
	uchar *pszTagName;
	uchar *pszTagID;	/* cached: name plus trailing shlash (for compares) */
	int lenTagID;		/* cached: length of tag ID, for performance reasons */
	struct severMap_s *severMap;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *pszTagName;	/**&lt; name of tag start value that indicates snmptrapd initiated message */
	uchar *pszSeverityMapping; /**&lt; severitystring to numerical code mapping for snmptrapd string */
} configSettings_t;
static configSettings_t cs;

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	resetConfigVariables(NULL, NULL);
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
	struct severMap_s *node, *nodeDel;
CODESTARTfreeInstance
	for(node = pData-&gt;severMap ; node != NULL ; ) {
		nodeDel = node;
		node = node-&gt;next;
		free(nodeDel-&gt;name);
		free(nodeDel);
	}
	free(pData-&gt;pszTagName);
	free(pData-&gt;pszTagID);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("mmsnmptrapd\n");
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


/* check if a string is numeric (int) */
static int
isNumeric(uchar *str)
{
	int r = 1;
	if(*str == '-' || *str == '+')
		++str;
	while(*str) {
		if(!isdigit(*str)) {
			r = 0;
			goto done;
		}
		++str;
	}
done:
	return r;
}

/* get a substring delimited by a character (or end of string). The
 * string is trimmed, that is leading and trailing spaces are removed.
 * The caller must provide a buffer which shall receive the substring.
 * String length is returned as result. The input string is updated
 * on exit, so that it may be used for another query starting at that
 * position.
 */
static int
getSubstring(uchar **psrc, uchar delim, uchar *dst, int lenDst)
{
	uchar *dstwrk = dst;
	uchar *src = *psrc;
	while(*src &amp;&amp; isspace(*src)) {
		++src;	/* trim leading spaces */
	}
	while(*src &amp;&amp; *src != delim &amp;&amp; --lenDst &gt; 0) {
		*dstwrk++ = *src++;
	}
	dstwrk--;
	while(dstwrk &gt; dst &amp;&amp; isspace(*dst))
		--dstwrk; /* trim trailing spaces */
	*++dstwrk = '\0';
	
	/* final results */
	if(*src == delim)
		++src;
	*psrc = src;
	return(dstwrk - dst);
}


/* get string up to the next SP or '/'. Stops at max size.
 * dst, lenDst (receive buffer) must be given. lenDst is
 * max length on entry and actual length on exit.
 */
static int ATTR_NONNULL()
getTagComponent(uchar *tag, uchar *const dst, int *const lenDst)
{
	int end = *lenDst - 1; /* -1 for NUL-char! */
	int i;

	i = 0;
	if(tag[i] == '/') {
		++tag;
		while(i &lt; end &amp;&amp; tag[i] != '\0' &amp;&amp; tag[i] != ' ' &amp;&amp; tag[i] != '/') {
			dst[i] = tag[i];
			++i;
		}
	}
	dst[i] = '\0';
	*lenDst = i;
	return i;
}


/* lookup severity code based on provided severity
 * returns -1 if severity could not be found.
 */
static int
lookupSeverityCode(instanceData *pData, uchar *sever)
{
	struct severMap_s *node;
	int sevCode = -1;

	for(node = pData-&gt;severMap ; node != NULL ; node = node-&gt;next) {
		if(!ustrcmp(node-&gt;name, sever)) {
			sevCode = node-&gt;code;
			break;
		}
	}
	return sevCode;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	int lenTAG;
	int lenSever;
	int lenHost;
	int sevCode;
	uchar *pszTag;
	uchar pszSever[512];
	uchar pszHost[512];
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	getTAG(pMsg, &amp;pszTag, &amp;lenTAG, LOCK_MUTEX);
	if(strncmp((char*)pszTag, (char*)pData-&gt;pszTagID, pData-&gt;lenTagID)) {
		DBGPRINTF("tag '%s' not matching, mmsnmptrapd ignoring this message\n",
			  pszTag);
		FINALIZE;
	}

	lenSever = sizeof(pszSever);
	getTagComponent(pszTag+pData-&gt;lenTagID-1, pszSever, &amp;lenSever);
	lenHost = sizeof(pszHost);
	getTagComponent(pszTag+pData-&gt;lenTagID+lenSever, pszHost, &amp;lenHost);
	DBGPRINTF("mmsnmptrapd: sever '%s'(%d), host '%s'(%d)\n", pszSever, lenSever, pszHost,lenHost);

	if(lenHost &gt; 0 &amp;&amp; pszHost[lenHost-1] == ':') {
		pszHost[lenHost-1] = '\0';
		--lenHost;
	}
	sevCode = lookupSeverityCode(pData, pszSever);
	/* now apply new settings */
	MsgSetTAG(pMsg, pData-&gt;pszTagName, pData-&gt;lenTagID);
	MsgSetHOSTNAME(pMsg, pszHost, lenHost);
	if(sevCode != -1)
		pMsg-&gt;iSeverity = sevCode; /* we update like the parser does! */
finalize_it:
ENDdoAction


/* Build the severity mapping table based on user-provided configuration
 * settings.
 */
static rsRetVal ATTR_NONNULL()
buildSeverityMapping(instanceData *const pData)
{
	uchar pszSev[512];
	uchar pszSevCode[512];
	int sevCode;
	uchar *mapping;
	struct severMap_s *node = NULL;
	DEFiRet;

	mapping = cs.pszSeverityMapping;

	while(1) {	/* broken inside when all entries are processed */
		if(getSubstring(&amp;mapping, '/', pszSev, sizeof(pszSev)) == 0) {
			FINALIZE;
		}
		if(getSubstring(&amp;mapping, ',', pszSevCode, sizeof(pszSevCode)) == 0) {
			LogError(0, RS_RET_ERR, "error: invalid severity mapping, cannot "
					"extract code. given: '%s'\n", cs.pszSeverityMapping);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		sevCode = atoi((char*) pszSevCode);
		if(!isNumeric(pszSevCode))
			sevCode = -1;
		if(sevCode &lt; 0 || sevCode &gt; 7) {
			LogError(0, RS_RET_ERR, "error: severity code %d outside of valid "
					"range 0..7 (was string '%s')\n", sevCode, pszSevCode);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		CHKmalloc(node = malloc(sizeof(struct severMap_s)));
		CHKmalloc(node-&gt;name = ustrdup(pszSev));
		node-&gt;code = sevCode;
		/* we enqueue at the top, so the two lines below do all we need! */
		node-&gt;next = pData-&gt;severMap;
		pData-&gt;severMap = node;
		node = NULL;
		DBGPRINTF("mmsnmptrapd: severity string '%s' mapped to code %d\n",
			  pszSev, sevCode);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		free(node);
	}
	RETiRet;
}


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, ":mmsnmptrapd:", sizeof(":mmsnmptrapd:") - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(":mmsnmptrapd:") - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	/* we call the function below because we need to call it via our interface definition. However,
	 * the format specified (if any) is always ignored.
	 */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat"));

	/* finally build the instance */
	if(cs.pszTagName == NULL) {
		CHKmalloc(pData-&gt;pszTagName = (uchar*) strdup("snmptrapd:"));
		CHKmalloc(pData-&gt;pszTagID = (uchar*) strdup("snmptrapd/"));
	} else {
		int lenTag = ustrlen(cs.pszTagName);
		/* new tag value (with colon at the end) */
		CHKmalloc(pData-&gt;pszTagName = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagName, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagName+lenTag, ":", 2);
		/* tag ID for comparisions */
		CHKmalloc(pData-&gt;pszTagID = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagID, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagID+lenTag, "/", 2);
		free(cs.pszTagName); /* no longer needed */
	}
	pData-&gt;lenTagID = ustrlen(pData-&gt;pszTagID);
	if(cs.pszSeverityMapping != NULL) {
		CHKiRet(buildSeverityMapping(pData));
	}

	/* all config vars auto-reset! */
	cs.pszTagName = NULL;
	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.pszTagName);
	cs.pszTagName = NULL;
<a name="0"></a>	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
	RETiRet;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}


BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
		/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* check if the rsyslog core supports parameter passing code */
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports msg passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, not acceptable */
	}
	
	if(!bMsgPassingSupported) {
		DBGPRINTF("mmsnmptrapd: msg-passing is not supported by rsyslog core, "
			  "can not continue.\n");
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</b></font>


	/* TODO: config vars ininit can be replaced by commented-out code above in v6 */
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdtag", 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszTagName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdseveritymapping", 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszSeverityMapping, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
