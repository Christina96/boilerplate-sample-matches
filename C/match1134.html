<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmjsonparse.c & mmsnmptrapd.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmjsonparse.c & mmsnmptrapd.c
      </h3>
      <h1 align="center">
        9.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmjsonparse.c (9.813084%)<TH>mmsnmptrapd.c (8.333333%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1134-0.html#0',2,'match1134-1.html#0',3)" NAME="0">(365-395)<TD><A HREF="javascript:ZweiFrames('match1134-0.html#0',2,'match1134-1.html#0',3)" NAME="0">(392-422)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmjsonparse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmjsonparse.c
 * This is a message modification module. If give, it extracts JSON data
 * and populates the EE event structure with it.
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * File begun on 2012-02-20 by RGerhards
 *
 * Copyright 2012-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &lt;json.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;parserif.h&quot;
#include &quot;dirty.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmjsonparse&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	sbool bUseRawMsg;     /**&lt; use %rawmsg% instead of %msg% */
	char *cookie;
	uchar *container;
	int lenCookie;
	/* REMOVE dummy when real data items are to be added! */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	struct json_tokener *tokener;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;cookie&quot;, eCmdHdlrString, 0 },
	{ &quot;container&quot;, eCmdHdlrString, 0 },
	{ &quot;userawmsg&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};



BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
	CHKmalloc(pData-&gt;container = (uchar*)strdup(&quot;!&quot;));
	CHKmalloc(pData-&gt;cookie = strdup(CONST_CEE_COOKIE));
	pData-&gt;lenCookie = CONST_LEN_CEE_COOKIE;
finalize_it:
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;tokener = json_tokener_new();
	if(pWrkrData-&gt;tokener == NULL) {
		LogError(0, RS_RET_ERR, &quot;error: could not create json &quot;
				&quot;tokener, cannot activate instance&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;cookie);
	free(pData-&gt;container);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;tokener != NULL)
		json_tokener_free(pWrkrData-&gt;tokener);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF(&quot;mmjsonparse\n&quot;);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static rsRetVal
processJSON(wrkrInstanceData_t *pWrkrData, smsg_t *pMsg, char *buf, size_t lenBuf)
{
	struct json_object *json;
	const char *errMsg;
	DEFiRet;

	assert(pWrkrData-&gt;tokener != NULL);
	DBGPRINTF(&quot;mmjsonparse: toParse: '%s'\n&quot;, buf);
	json_tokener_reset(pWrkrData-&gt;tokener);

	json = json_tokener_parse_ex(pWrkrData-&gt;tokener, buf, lenBuf);
	if(Debug) {
		errMsg = NULL;
		if(json == NULL) {
			enum json_tokener_error err;

			err = pWrkrData-&gt;tokener-&gt;err;
			if(err != json_tokener_continue)
				errMsg = json_tokener_error_desc(err);
			else
				errMsg = &quot;Unterminated input&quot;;
		} else if((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
			errMsg = &quot;Extra characters after JSON object&quot;;
		else if(!json_object_is_type(json, json_type_object))
			errMsg = &quot;JSON value is not an object&quot;;
		if(errMsg != NULL) {
			DBGPRINTF(&quot;mmjsonparse: Error parsing JSON '%s': %s\n&quot;,
					buf, errMsg);
		}
	}
	if(json == NULL
	   || ((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
	   || (!json_object_is_type(json, json_type_object))) {
		if(json != NULL) {
			/* Release json object as we are not going to add it to pMsg */
			json_object_put(json);
		}
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}

	msgAddJSON(pMsg, pWrkrData-&gt;pData-&gt;container, json, 0, 0);
finalize_it:
	RETiRet;
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *buf;
	rs_size_t len;
	int bSuccess = 0;
	struct json_object *jval;
	struct json_object *json;
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	/* note that we can performance-optimize the interface, but this also
	 * requires changes to the libraries. For now, we accept message
	 * duplication. -- rgerhards, 2010-12-01
	 */
	if(pWrkrData-&gt;pData-&gt;bUseRawMsg)
		getRawMsg(pMsg, &amp;buf, &amp;len);
	else
		buf = getMSG(pMsg);

	while(*buf &amp;&amp; isspace(*buf)) {
		++buf;
	}

	if(*buf == '\0' || strncmp((char*)buf, pData-&gt;cookie, pData-&gt;lenCookie)) {
		DBGPRINTF(&quot;mmjsonparse: no JSON cookie: '%s'\n&quot;, buf);
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}
	buf += pData-&gt;lenCookie;
	CHKiRet(processJSON(pWrkrData, pMsg, (char*) buf, strlen((char*)buf)));
	bSuccess = 1;
finalize_it:
	if(iRet == RS_RET_NO_CEE_MSG) {
		/* add buf as msg */
		json = json_object_new_object();
		jval = json_object_new_string((char*)buf);
		json_object_object_add(json, &quot;msg&quot;, jval);
		msgAddJSON(pMsg, pData-&gt;container, json, 0, 0);
		iRet = RS_RET_OK;
	}
	MsgSetParseSuccess(pMsg, bSuccess);
ENDdoAction

static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;bUseRawMsg = 0;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmjsonparse)\n&quot;);
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}


	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;cookie&quot;)) {
			free(pData-&gt;cookie);
			pData-&gt;cookie = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;container&quot;)) {
			free(pData-&gt;container);
			size_t lenvar = es_strlen(pvals[i].val.d.estr);
			pData-&gt;container = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pData-&gt;container[0] == '$') {
				/* pre 8.35, the container name needed to be specified without
				 * the leading $. This was confusing, so we now require a full
				 * variable name. Nevertheless, we still need to support the
				 * version without $. -- rgerhards, 2018-05-16
				 */
				/* copy lenvar size because of \0 string terminator */
				memmove(pData-&gt;container, pData-&gt;container+1,  lenvar);
				--lenvar;
			}
			if(   (lenvar == 0)
			   || (  !(   pData-&gt;container[0] == '!'
			           || pData-&gt;container[0] == '.'
			           || pData-&gt;container[0] == '/' ) )
			   ) {
			parser_errmsg(&quot;mmjsonparse: invalid container name '%s', name must &quot;
				&quot;start with either '$!', '$.', or '$/'&quot;, pData-&gt;container);
			ABORT_FINALIZE(RS_RET_INVALID_VAR);
		}
		} else if(!strcmp(actpblk.descr[i].name, &quot;userawmsg&quot;)) {
			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;mmjsonparse: program error, non-handled param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;container == NULL)
		CHKmalloc(pData-&gt;container = (uchar*) strdup(&quot;!&quot;));
	pData-&gt;lenCookie = strlen(pData-&gt;cookie);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, &quot;:mmjsonparse:&quot;, sizeof(&quot;:mmjsonparse:&quot;) - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(&quot;:mmjsonparse:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	/* we call the function below because we need to call it via our interface definition. However,
	 * the format specified (if any) is always ignored.
	 */
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) &quot;RSYSLOG_FileFormat&quot;);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
<A NAME="0"></A>{
	DEFiRet;
	RETiRet;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1134-1.html#0',3,'match1134-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}


BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
		/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmjsonparse: module compiled with rsyslog version %s.\n&quot;, VERSION);
	/* check if the rsyslog core supports parameter passing code */
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)&quot;OMSRgetSupportedTplOpts&quot;,
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports msg passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, not acceptable */
	}
	
	if(!bMsgPassingSupported) {
		DBGPRINTF(&quot;mmjsonparse: msg-passing is not supported by rsyslog core, &quot;
			  &quot;can not continue.\n&quot;);
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</B></FONT>

	
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmsnmptrapd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmsnmptrapd.c
 * This is a message modification module. It takes messages generated
 * from snmptrapd and modifies them so that the look like they
 * originated from the real originator.
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * File begun on 2011-05-05 by RGerhards
 *
 * Copyright 2011-2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &quot;conf.h&quot;
#include &quot;msg.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;dirty.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmsnmptrapd&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

struct severMap_s {
	uchar *name;
	int code;
	struct severMap_s *next;
};

typedef struct _instanceData {
	uchar *pszTagName;
	uchar *pszTagID;	/* cached: name plus trailing shlash (for compares) */
	int lenTagID;		/* cached: length of tag ID, for performance reasons */
	struct severMap_s *severMap;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *pszTagName;	/**&lt; name of tag start value that indicates snmptrapd initiated message */
	uchar *pszSeverityMapping; /**&lt; severitystring to numerical code mapping for snmptrapd string */
} configSettings_t;
static configSettings_t cs;

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	resetConfigVariables(NULL, NULL);
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
	struct severMap_s *node, *nodeDel;
CODESTARTfreeInstance
	for(node = pData-&gt;severMap ; node != NULL ; ) {
		nodeDel = node;
		node = node-&gt;next;
		free(nodeDel-&gt;name);
		free(nodeDel);
	}
	free(pData-&gt;pszTagName);
	free(pData-&gt;pszTagID);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;mmsnmptrapd\n&quot;);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


/* check if a string is numeric (int) */
static int
isNumeric(uchar *str)
{
	int r = 1;
	if(*str == '-' || *str == '+')
		++str;
	while(*str) {
		if(!isdigit(*str)) {
			r = 0;
			goto done;
		}
		++str;
	}
done:
	return r;
}

/* get a substring delimited by a character (or end of string). The
 * string is trimmed, that is leading and trailing spaces are removed.
 * The caller must provide a buffer which shall receive the substring.
 * String length is returned as result. The input string is updated
 * on exit, so that it may be used for another query starting at that
 * position.
 */
static int
getSubstring(uchar **psrc, uchar delim, uchar *dst, int lenDst)
{
	uchar *dstwrk = dst;
	uchar *src = *psrc;
	while(*src &amp;&amp; isspace(*src)) {
		++src;	/* trim leading spaces */
	}
	while(*src &amp;&amp; *src != delim &amp;&amp; --lenDst &gt; 0) {
		*dstwrk++ = *src++;
	}
	dstwrk--;
	while(dstwrk &gt; dst &amp;&amp; isspace(*dst))
		--dstwrk; /* trim trailing spaces */
	*++dstwrk = '\0';
	
	/* final results */
	if(*src == delim)
		++src;
	*psrc = src;
	return(dstwrk - dst);
}


/* get string up to the next SP or '/'. Stops at max size.
 * dst, lenDst (receive buffer) must be given. lenDst is
 * max length on entry and actual length on exit.
 */
static int ATTR_NONNULL()
getTagComponent(uchar *tag, uchar *const dst, int *const lenDst)
{
	int end = *lenDst - 1; /* -1 for NUL-char! */
	int i;

	i = 0;
	if(tag[i] == '/') {
		++tag;
		while(i &lt; end &amp;&amp; tag[i] != '\0' &amp;&amp; tag[i] != ' ' &amp;&amp; tag[i] != '/') {
			dst[i] = tag[i];
			++i;
		}
	}
	dst[i] = '\0';
	*lenDst = i;
	return i;
}


/* lookup severity code based on provided severity
 * returns -1 if severity could not be found.
 */
static int
lookupSeverityCode(instanceData *pData, uchar *sever)
{
	struct severMap_s *node;
	int sevCode = -1;

	for(node = pData-&gt;severMap ; node != NULL ; node = node-&gt;next) {
		if(!ustrcmp(node-&gt;name, sever)) {
			sevCode = node-&gt;code;
			break;
		}
	}
	return sevCode;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	int lenTAG;
	int lenSever;
	int lenHost;
	int sevCode;
	uchar *pszTag;
	uchar pszSever[512];
	uchar pszHost[512];
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	getTAG(pMsg, &amp;pszTag, &amp;lenTAG, LOCK_MUTEX);
	if(strncmp((char*)pszTag, (char*)pData-&gt;pszTagID, pData-&gt;lenTagID)) {
		DBGPRINTF(&quot;tag '%s' not matching, mmsnmptrapd ignoring this message\n&quot;,
			  pszTag);
		FINALIZE;
	}

	lenSever = sizeof(pszSever);
	getTagComponent(pszTag+pData-&gt;lenTagID-1, pszSever, &amp;lenSever);
	lenHost = sizeof(pszHost);
	getTagComponent(pszTag+pData-&gt;lenTagID+lenSever, pszHost, &amp;lenHost);
	DBGPRINTF(&quot;mmsnmptrapd: sever '%s'(%d), host '%s'(%d)\n&quot;, pszSever, lenSever, pszHost,lenHost);

	if(lenHost &gt; 0 &amp;&amp; pszHost[lenHost-1] == ':') {
		pszHost[lenHost-1] = '\0';
		--lenHost;
	}
	sevCode = lookupSeverityCode(pData, pszSever);
	/* now apply new settings */
	MsgSetTAG(pMsg, pData-&gt;pszTagName, pData-&gt;lenTagID);
	MsgSetHOSTNAME(pMsg, pszHost, lenHost);
	if(sevCode != -1)
		pMsg-&gt;iSeverity = sevCode; /* we update like the parser does! */
finalize_it:
ENDdoAction


/* Build the severity mapping table based on user-provided configuration
 * settings.
 */
static rsRetVal ATTR_NONNULL()
buildSeverityMapping(instanceData *const pData)
{
	uchar pszSev[512];
	uchar pszSevCode[512];
	int sevCode;
	uchar *mapping;
	struct severMap_s *node = NULL;
	DEFiRet;

	mapping = cs.pszSeverityMapping;

	while(1) {	/* broken inside when all entries are processed */
		if(getSubstring(&amp;mapping, '/', pszSev, sizeof(pszSev)) == 0) {
			FINALIZE;
		}
		if(getSubstring(&amp;mapping, ',', pszSevCode, sizeof(pszSevCode)) == 0) {
			LogError(0, RS_RET_ERR, &quot;error: invalid severity mapping, cannot &quot;
					&quot;extract code. given: '%s'\n&quot;, cs.pszSeverityMapping);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		sevCode = atoi((char*) pszSevCode);
		if(!isNumeric(pszSevCode))
			sevCode = -1;
		if(sevCode &lt; 0 || sevCode &gt; 7) {
			LogError(0, RS_RET_ERR, &quot;error: severity code %d outside of valid &quot;
					&quot;range 0..7 (was string '%s')\n&quot;, sevCode, pszSevCode);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		CHKmalloc(node = malloc(sizeof(struct severMap_s)));
		CHKmalloc(node-&gt;name = ustrdup(pszSev));
		node-&gt;code = sevCode;
		/* we enqueue at the top, so the two lines below do all we need! */
		node-&gt;next = pData-&gt;severMap;
		pData-&gt;severMap = node;
		node = NULL;
		DBGPRINTF(&quot;mmsnmptrapd: severity string '%s' mapped to code %d\n&quot;,
			  pszSev, sevCode);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		free(node);
	}
	RETiRet;
}


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, &quot;:mmsnmptrapd:&quot;, sizeof(&quot;:mmsnmptrapd:&quot;) - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(&quot;:mmsnmptrapd:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	/* we call the function below because we need to call it via our interface definition. However,
	 * the format specified (if any) is always ignored.
	 */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) &quot;RSYSLOG_FileFormat&quot;));

	/* finally build the instance */
	if(cs.pszTagName == NULL) {
		CHKmalloc(pData-&gt;pszTagName = (uchar*) strdup(&quot;snmptrapd:&quot;));
		CHKmalloc(pData-&gt;pszTagID = (uchar*) strdup(&quot;snmptrapd/&quot;));
	} else {
		int lenTag = ustrlen(cs.pszTagName);
		/* new tag value (with colon at the end) */
		CHKmalloc(pData-&gt;pszTagName = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagName, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagName+lenTag, &quot;:&quot;, 2);
		/* tag ID for comparisions */
		CHKmalloc(pData-&gt;pszTagID = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagID, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagID+lenTag, &quot;/&quot;, 2);
		free(cs.pszTagName); /* no longer needed */
	}
	pData-&gt;lenTagID = ustrlen(pData-&gt;pszTagID);
	if(cs.pszSeverityMapping != NULL) {
		CHKiRet(buildSeverityMapping(pData));
	}

	/* all config vars auto-reset! */
	cs.pszTagName = NULL;
	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.pszTagName);
	cs.pszTagName = NULL;
<A NAME="0"></A>	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
	RETiRet;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1134-0.html#0',2,'match1134-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
		/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* check if the rsyslog core supports parameter passing code */
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)&quot;OMSRgetSupportedTplOpts&quot;,
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports msg passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, not acceptable */
	}
	
	if(!bMsgPassingSupported) {
		DBGPRINTF(&quot;mmsnmptrapd: msg-passing is not supported by rsyslog core, &quot;
			  &quot;can not continue.\n&quot;);
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</B></FONT>


	/* TODO: config vars ininit can be replaced by commented-out code above in v6 */
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;mmsnmptrapdtag&quot;, 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszTagName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;mmsnmptrapdseveritymapping&quot;, 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszSeverityMapping, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
