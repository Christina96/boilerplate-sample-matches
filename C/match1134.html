<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmjsonparse.c &amp; mmsnmptrapd.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmjsonparse.c &amp; mmsnmptrapd.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmjsonparse.c (9.813084%)<th>mmsnmptrapd.c (8.333333%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(365-395)<td><a href="#" name="0">(392-422)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmjsonparse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &lt;json.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "parserif.h"
#include "dirty.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmjsonparse")
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
DEF_OMOD_STATIC_DATA
typedef struct _instanceData {
	char *cookie;
	uchar *container;
	int lenCookie;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	struct json_tokener *tokener;
} wrkrInstanceData_t;
struct modConfData_s {
	rsconf_t *pConf;	};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static struct cnfparamdescr actpdescr[] = {
	{ "cookie", eCmdHdlrString, 0 },
	{ "container", eCmdHdlrString, 0 },
	{ "userawmsg", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
BEGINcreateInstance
CODESTARTcreateInstance
	CHKmalloc(pData-&gt;container = (uchar*)strdup("!"));
	CHKmalloc(pData-&gt;cookie = strdup(CONST_CEE_COOKIE));
	pData-&gt;lenCookie = CONST_LEN_CEE_COOKIE;
finalize_it:
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;tokener = json_tokener_new();
	if(pWrkrData-&gt;tokener == NULL) {
		LogError(0, RS_RET_ERR, "error: could not create json "
				"tokener, cannot activate instance");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;cookie);
	free(pData-&gt;container);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;tokener != NULL)
		json_tokener_free(pWrkrData-&gt;tokener);
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	DBGPRINTF("mmjsonparse\n");
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
ENDtryResume
static rsRetVal
processJSON(wrkrInstanceData_t *pWrkrData, smsg_t *pMsg, char *buf, size_t lenBuf)
{
	struct json_object *json;
	const char *errMsg;
	DEFiRet;
	assert(pWrkrData-&gt;tokener != NULL);
	DBGPRINTF("mmjsonparse: toParse: '%s'\n", buf);
	json_tokener_reset(pWrkrData-&gt;tokener);
	json = json_tokener_parse_ex(pWrkrData-&gt;tokener, buf, lenBuf);
	if(Debug) {
		errMsg = NULL;
		if(json == NULL) {
			enum json_tokener_error err;
			err = pWrkrData-&gt;tokener-&gt;err;
			if(err != json_tokener_continue)
				errMsg = json_tokener_error_desc(err);
			else
				errMsg = "Unterminated input";
		} else if((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
			errMsg = "Extra characters after JSON object";
		else if(!json_object_is_type(json, json_type_object))
			errMsg = "JSON value is not an object";
		if(errMsg != NULL) {
			DBGPRINTF("mmjsonparse: Error parsing JSON '%s': %s\n",
					buf, errMsg);
		}
	}
	if(json == NULL
	   || ((size_t)pWrkrData-&gt;tokener-&gt;char_offset &lt; lenBuf)
	   || (!json_object_is_type(json, json_type_object))) {
		if(json != NULL) {
			json_object_put(json);
		}
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}
	msgAddJSON(pMsg, pWrkrData-&gt;pData-&gt;container, json, 0, 0);
finalize_it:
	RETiRet;
}
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *buf;
	rs_size_t len;
	int bSuccess = 0;
	struct json_object *jval;
	struct json_object *json;
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	if(pWrkrData-&gt;pData-&gt;bUseRawMsg)
		getRawMsg(pMsg, &amp;buf, &amp;len);
	else
		buf = getMSG(pMsg);
	while(*buf &amp;&amp; isspace(*buf)) {
		++buf;
	}
	if(*buf == '\0' || strncmp((char*)buf, pData-&gt;cookie, pData-&gt;lenCookie)) {
		DBGPRINTF("mmjsonparse: no JSON cookie: '%s'\n", buf);
		ABORT_FINALIZE(RS_RET_NO_CEE_MSG);
	}
	buf += pData-&gt;lenCookie;
	CHKiRet(processJSON(pWrkrData, pMsg, (char*) buf, strlen((char*)buf)));
	bSuccess = 1;
finalize_it:
	if(iRet == RS_RET_NO_CEE_MSG) {
		json = json_object_new_object();
		jval = json_object_new_string((char*)buf);
		json_object_object_add(json, "msg", jval);
		msgAddJSON(pMsg, pData-&gt;container, json, 0, 0);
		iRet = RS_RET_OK;
	}
	MsgSetParseSuccess(pMsg, bSuccess);
ENDdoAction
static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;bUseRawMsg = 0;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmjsonparse)\n");
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "cookie")) {
			free(pData-&gt;cookie);
			pData-&gt;cookie = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "container")) {
			free(pData-&gt;container);
			size_t lenvar = es_strlen(pvals[i].val.d.estr);
			pData-&gt;container = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pData-&gt;container[0] == '$') {
				memmove(pData-&gt;container, pData-&gt;container+1,  lenvar);
				--lenvar;
			}
			if(   (lenvar == 0)
			   || (  !(   pData-&gt;container[0] == '!'
			           || pData-&gt;container[0] == '.'
			           || pData-&gt;container[0] == '/' ) )
			   ) {
			parser_errmsg("mmjsonparse: invalid container name '%s', name must "
				"start with either '$!', '$.', or '$/'", pData-&gt;container);
			ABORT_FINALIZE(RS_RET_INVALID_VAR);
		}
		} else if(!strcmp(actpblk.descr[i].name, "userawmsg")) {
			pData-&gt;bUseRawMsg = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("mmjsonparse: program error, non-handled param '%s'\n", actpblk.descr[i].name);
		}
	}
	if(pData-&gt;container == NULL)
		CHKmalloc(pData-&gt;container = (uchar*) strdup("!"));
	pData-&gt;lenCookie = strlen(pData-&gt;cookie);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char*) p, ":mmjsonparse:", sizeof(":mmjsonparse:") - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	p += sizeof(":mmjsonparse:") - 1; 	CHKiRet(createInstance(&amp;pData));
	if(*(p-1) == ';')
		--p;
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat");
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINmodExit
CODESTARTmodExit
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
<a name="0"></a>{
	DEFiRet;
	RETiRet;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmjsonparse: module compiled with rsyslog version %s.\n", VERSION);
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); 	}
	if(!bMsgPassingSupported) {
		DBGPRINTF("mmjsonparse: msg-passing is not supported by rsyslog core, "
			  "can not continue.\n");
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</b></font>
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmsnmptrapd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include "conf.h"
#include "msg.h"
#include "syslogd-types.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "dirty.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmsnmptrapd")
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
DEF_OMOD_STATIC_DATA
struct severMap_s {
	uchar *name;
	int code;
	struct severMap_s *next;
};
typedef struct _instanceData {
	uchar *pszTagName;
	uchar *pszTagID;		int lenTagID;			struct severMap_s *severMap;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;
typedef struct configSettings_s {
} configSettings_t;
static configSettings_t cs;
BEGINinitConfVars		CODESTARTinitConfVars
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	resetConfigVariables(NULL, NULL);
ENDinitConfVars
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
BEGINfreeInstance
	struct severMap_s *node, *nodeDel;
CODESTARTfreeInstance
	for(node = pData-&gt;severMap ; node != NULL ; ) {
		nodeDel = node;
		node = node-&gt;next;
		free(nodeDel-&gt;name);
		free(nodeDel);
	}
	free(pData-&gt;pszTagName);
	free(pData-&gt;pszTagID);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("mmsnmptrapd\n");
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
ENDtryResume
static int
isNumeric(uchar *str)
{
	int r = 1;
	if(*str == '-' || *str == '+')
		++str;
	while(*str) {
		if(!isdigit(*str)) {
			r = 0;
			goto done;
		}
		++str;
	}
done:
	return r;
}
static int
getSubstring(uchar **psrc, uchar delim, uchar *dst, int lenDst)
{
	uchar *dstwrk = dst;
	uchar *src = *psrc;
	while(*src &amp;&amp; isspace(*src)) {
		++src;		}
	while(*src &amp;&amp; *src != delim &amp;&amp; --lenDst &gt; 0) {
		*dstwrk++ = *src++;
	}
	dstwrk--;
	while(dstwrk &gt; dst &amp;&amp; isspace(*dst))
		--dstwrk; 	*++dstwrk = '\0';
	if(*src == delim)
		++src;
	*psrc = src;
	return(dstwrk - dst);
}
static int ATTR_NONNULL()
getTagComponent(uchar *tag, uchar *const dst, int *const lenDst)
{
	int end = *lenDst - 1; 	int i;
	i = 0;
	if(tag[i] == '/') {
		++tag;
		while(i &lt; end &amp;&amp; tag[i] != '\0' &amp;&amp; tag[i] != ' ' &amp;&amp; tag[i] != '/') {
			dst[i] = tag[i];
			++i;
		}
	}
	dst[i] = '\0';
	*lenDst = i;
	return i;
}
static int
lookupSeverityCode(instanceData *pData, uchar *sever)
{
	struct severMap_s *node;
	int sevCode = -1;
	for(node = pData-&gt;severMap ; node != NULL ; node = node-&gt;next) {
		if(!ustrcmp(node-&gt;name, sever)) {
			sevCode = node-&gt;code;
			break;
		}
	}
	return sevCode;
}
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	int lenTAG;
	int lenSever;
	int lenHost;
	int sevCode;
	uchar *pszTag;
	uchar pszSever[512];
	uchar pszHost[512];
	instanceData *pData;
CODESTARTdoAction
	pData = pWrkrData-&gt;pData;
	getTAG(pMsg, &amp;pszTag, &amp;lenTAG, LOCK_MUTEX);
	if(strncmp((char*)pszTag, (char*)pData-&gt;pszTagID, pData-&gt;lenTagID)) {
		DBGPRINTF("tag '%s' not matching, mmsnmptrapd ignoring this message\n",
			  pszTag);
		FINALIZE;
	}
	lenSever = sizeof(pszSever);
	getTagComponent(pszTag+pData-&gt;lenTagID-1, pszSever, &amp;lenSever);
	lenHost = sizeof(pszHost);
	getTagComponent(pszTag+pData-&gt;lenTagID+lenSever, pszHost, &amp;lenHost);
	DBGPRINTF("mmsnmptrapd: sever '%s'(%d), host '%s'(%d)\n", pszSever, lenSever, pszHost,lenHost);
	if(lenHost &gt; 0 &amp;&amp; pszHost[lenHost-1] == ':') {
		pszHost[lenHost-1] = '\0';
		--lenHost;
	}
	sevCode = lookupSeverityCode(pData, pszSever);
	MsgSetTAG(pMsg, pData-&gt;pszTagName, pData-&gt;lenTagID);
	MsgSetHOSTNAME(pMsg, pszHost, lenHost);
	if(sevCode != -1)
		pMsg-&gt;iSeverity = sevCode; finalize_it:
ENDdoAction
static rsRetVal ATTR_NONNULL()
buildSeverityMapping(instanceData *const pData)
{
	uchar pszSev[512];
	uchar pszSevCode[512];
	int sevCode;
	uchar *mapping;
	struct severMap_s *node = NULL;
	DEFiRet;
	mapping = cs.pszSeverityMapping;
	while(1) {			if(getSubstring(&amp;mapping, '/', pszSev, sizeof(pszSev)) == 0) {
			FINALIZE;
		}
		if(getSubstring(&amp;mapping, ',', pszSevCode, sizeof(pszSevCode)) == 0) {
			LogError(0, RS_RET_ERR, "error: invalid severity mapping, cannot "
					"extract code. given: '%s'\n", cs.pszSeverityMapping);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		sevCode = atoi((char*) pszSevCode);
		if(!isNumeric(pszSevCode))
			sevCode = -1;
		if(sevCode &lt; 0 || sevCode &gt; 7) {
			LogError(0, RS_RET_ERR, "error: severity code %d outside of valid "
					"range 0..7 (was string '%s')\n", sevCode, pszSevCode);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		CHKmalloc(node = malloc(sizeof(struct severMap_s)));
		CHKmalloc(node-&gt;name = ustrdup(pszSev));
		node-&gt;code = sevCode;
		node-&gt;next = pData-&gt;severMap;
		pData-&gt;severMap = node;
		node = NULL;
		DBGPRINTF("mmsnmptrapd: severity string '%s' mapped to code %d\n",
			  pszSev, sevCode);
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		free(node);
	}
	RETiRet;
}
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char*) p, ":mmsnmptrapd:", sizeof(":mmsnmptrapd:") - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	p += sizeof(":mmsnmptrapd:") - 1; 	CHKiRet(createInstance(&amp;pData));
	if(*(p-1) == ';')
		--p;
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_TPL_AS_MSG, (uchar*) "RSYSLOG_FileFormat"));
	if(cs.pszTagName == NULL) {
		CHKmalloc(pData-&gt;pszTagName = (uchar*) strdup("snmptrapd:"));
		CHKmalloc(pData-&gt;pszTagID = (uchar*) strdup("snmptrapd/"));
	} else {
		int lenTag = ustrlen(cs.pszTagName);
		CHKmalloc(pData-&gt;pszTagName = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagName, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagName+lenTag, ":", 2);
		CHKmalloc(pData-&gt;pszTagID = malloc(lenTag + 2));
		memcpy(pData-&gt;pszTagID, cs.pszTagName, lenTag);
		memcpy(pData-&gt;pszTagID+lenTag, "/", 2);
		free(cs.pszTagName); 	}
	pData-&gt;lenTagID = ustrlen(pData-&gt;pszTagID);
	if(cs.pszSeverityMapping != NULL) {
		CHKiRet(buildSeverityMapping(pData));
	}
	cs.pszTagName = NULL;
	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINmodExit
CODESTARTmodExit
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.pszTagName);
	cs.pszTagName = NULL;
<a name="0"></a>	free(cs.pszSeverityMapping);
	cs.pszSeverityMapping = NULL;
	RETiRet;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bMsgPassingSupported;
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	bMsgPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts",
			&amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_MSG)
			bMsgPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); 	}
	if(!bMsgPassingSupported) {
		DBGPRINTF("mmsnmptrapd: msg-passing is not supported by rsyslog core, "
			  "can not continue.\n");
		ABORT_FINALIZE(RS_RET_NO_MSG_PASSING);
	}</b></font>
	cs.pszTagName = NULL;
	cs.pszSeverityMapping = NULL;
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdtag", 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszTagName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"mmsnmptrapdseveritymapping", 0, eCmdHdlrGetWord,
				    NULL, &amp;cs.pszSeverityMapping, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
