
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_jh.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_jh.h"
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_JH
8  #define SPH_SMALL_FOOTPRINT_JH 1
9  #endif
10  #if !defined SPH_JH_64 && SPH_64_TRUE
11  #define SPH_JH_64 1
12  #endif
13  #if !SPH_64
14  #undef SPH_JH_64
15  #endif
16  #ifdef _MSC_VER
17  #pragma warning(disable : 4146)
18  #endif
19  #if SPH_LITTLE_ENDIAN
20  #define C32e(x)                                                                \
21    ((SPH_C32(x) >> 24) | ((SPH_C32(x) >> 8) & SPH_C32(0x0000FF00)) |            \
22     ((SPH_C32(x) << 8) & SPH_C32(0x00FF0000)) |                                 \
23     ((SPH_C32(x) << 24) & SPH_C32(0xFF000000)))
24  #define dec32e_aligned sph_dec32le_aligned
25  #define enc32e sph_enc32le
26  #if SPH_64
27  #define C64e(x)                                                                \
28    ((SPH_C64(x) >> 56) | ((SPH_C64(x) >> 40) & SPH_C64(0x000000000000FF00)) |   \
29     ((SPH_C64(x) >> 24) & SPH_C64(0x0000000000FF0000)) |                        \
30     ((SPH_C64(x) >> 8) & SPH_C64(0x00000000FF000000)) |                         \
31     ((SPH_C64(x) << 8) & SPH_C64(0x000000FF00000000)) |                         \
32     ((SPH_C64(x) << 24) & SPH_C64(0x0000FF0000000000)) |                        \
33     ((SPH_C64(x) << 40) & SPH_C64(0x00FF000000000000)) |                        \
34     ((SPH_C64(x) << 56) & SPH_C64(0xFF00000000000000)))
35  #define dec64e_aligned sph_dec64le_aligned
36  #define enc64e sph_enc64le
37  #endif
38  #else
39  #define C32e(x) SPH_C32(x)
40  #define dec32e_aligned sph_dec32be_aligned
41  #define enc32e sph_enc32be
42  #if SPH_64
43  #define C64e(x) SPH_C64(x)
44  #define dec64e_aligned sph_dec64be_aligned
45  #define enc64e sph_enc64be
46  #endif
47  #endif
48  #define Sb(x0, x1, x2, x3, c)                                                  \
49    do {                                                                         \
50      x3 = ~x3;                                                                  \
51      x0 ^= (c) & ~x2;                                                           \
52      tmp = (c) ^ (x0 & x1);                                                     \
53      x0 ^= x2 & x3;                                                             \
54      x3 ^= ~x1 & x2;                                                            \
55      x1 ^= x0 & x2;                                                             \
56      x2 ^= x0 & ~x3;                                                            \
57      x0 ^= x1 | x3;                                                             \
58      x3 ^= x1 & x2;                                                             \
59      x1 ^= tmp & x0;                                                            \
60      x2 ^= tmp;                                                                 \
61    } while (0)
62  #define Lb(x0, x1, x2, x3, x4, x5, x6, x7)                                     \
63    do {                                                                         \
64      x4 ^= x1;                                                                  \
65      x5 ^= x2;                                                                  \
66      x6 ^= x3 ^ x0;                                                             \
67      x7 ^= x0;                                                                  \
68      x0 ^= x5;                                                                  \
69      x1 ^= x6;                                                                  \
70      x2 ^= x7 ^ x4;                                                             \
71      x3 ^= x4;                                                                  \
72    } while (0)
73  #if SPH_JH_64
74  static const sph_u64 C[] = {C64e(0x72d5dea2df15f867), C64e(0x7b84150ab7231557),
75                              C64e(0x81abd6904d5a87f6), C64e(0x4e9f4fc5c3d12b40),
76                              C64e(0xea983ae05c45fa9c), C64e(0x03c5d29966b2999a),
77                              C64e(0x660296b4f2bb538a), C64e(0xb556141a88dba231),
78                              C64e(0x03a35a5c9a190edb), C64e(0x403fb20a87c14410),
79                              C64e(0x1c051980849e951d), C64e(0x6f33ebad5ee7cddc),
80                              C64e(0x10ba139202bf6b41), C64e(0xdc786515f7bb27d0),
81                              C64e(0x0a2c813937aa7850), C64e(0x3f1abfd2410091d3),
82                              C64e(0x422d5a0df6cc7e90), C64e(0xdd629f9c92c097ce),
83                              C64e(0x185ca70bc72b44ac), C64e(0xd1df65d663c6fc23),
84                              C64e(0x976e6c039ee0b81a), C64e(0x2105457e446ceca8),
85                              C64e(0xeef103bb5d8e61fa), C64e(0xfd9697b294838197),
86                              C64e(0x4a8e8537db03302f), C64e(0x2a678d2dfb9f6a95),
87                              C64e(0x8afe7381f8b8696c), C64e(0x8ac77246c07f4214),
88                              C64e(0xc5f4158fbdc75ec4), C64e(0x75446fa78f11bb80),
89                              C64e(0x52de75b7aee488bc), C64e(0x82b8001e98a6a3f4),
90                              C64e(0x8ef48f33a9a36315), C64e(0xaa5f5624d5b7f989),
91                              C64e(0xb6f1ed207c5ae0fd), C64e(0x36cae95a06422c36),
92                              C64e(0xce2935434efe983d), C64e(0x533af974739a4ba7),
93                              C64e(0xd0f51f596f4e8186), C64e(0x0e9dad81afd85a9f),
94                              C64e(0xa7050667ee34626a), C64e(0x8b0b28be6eb91727),
95                              C64e(0x47740726c680103f), C64e(0xe0a07e6fc67e487b),
96                              C64e(0x0d550aa54af8a4c0), C64e(0x91e3e79f978ef19e),
97                              C64e(0x8676728150608dd4), C64e(0x7e9e5a41f3e5b062),
98                              C64e(0xfc9f1fec4054207a), C64e(0xe3e41a00cef4c984),
99                              C64e(0x4fd794f59dfa95d8), C64e(0x552e7e1124c354a5),
100                              C64e(0x5bdf7228bdfe6e28), C64e(0x78f57fe20fa5c4b2),
101                              C64e(0x05897cefee49d32e), C64e(0x447e9385eb28597f),
102                              C64e(0x705f6937b324314a), C64e(0x5e8628f11dd6e465),
103                              C64e(0xc71b770451b920e7), C64e(0x74fe43e823d4878a),
104                              C64e(0x7d29e8a3927694f2), C64e(0xddcb7a099b30d9c1),
105                              C64e(0x1d1b30fb5bdc1be0), C64e(0xda24494ff29c82bf),
106                              C64e(0xa4e7ba31b470bfff), C64e(0x0d324405def8bc48),
107                              C64e(0x3baefc3253bbd339), C64e(0x459fc3c1e0298ba0),
108                              C64e(0xe5c905fdf7ae090f), C64e(0x947034124290f134),
109                              C64e(0xa271b701e344ed95), C64e(0xe93b8e364f2f984a),
110                              C64e(0x88401d63a06cf615), C64e(0x47c1444b8752afff),
111                              C64e(0x7ebb4af1e20ac630), C64e(0x4670b6c5cc6e8ce6),
112                              C64e(0xa4d5a456bd4fca00), C64e(0xda9d844bc83e18ae),
113                              C64e(0x7357ce453064d1ad), C64e(0xe8a6ce68145c2567),
114                              C64e(0xa3da8cf2cb0ee116), C64e(0x33e906589a94999a),
115                              C64e(0x1f60b220c26f847b), C64e(0xd1ceac7fa0d18518),
116                              C64e(0x32595ba18ddd19d3), C64e(0x509a1cc0aaa5b446),
117                              C64e(0x9f3d6367e4046bba), C64e(0xf6ca19ab0b56ee7e),
118                              C64e(0x1fb179eaa9282174), C64e(0xe9bdf7353b3651ee),
119                              C64e(0x1d57ac5a7550d376), C64e(0x3a46c2fea37d7001),
120                              C64e(0xf735c1af98a4d842), C64e(0x78edec209e6b6779),
121                              C64e(0x41836315ea3adba8), C64e(0xfac33b4d32832c83),
122                              C64e(0xa7403b1f1c2747f3), C64e(0x5940f034b72d769a),
123                              C64e(0xe73e4e6cd2214ffd), C64e(0xb8fd8d39dc5759ef),
124                              C64e(0x8d9b0c492b49ebda), C64e(0x5ba2d74968f3700d),
125                              C64e(0x7d3baed07a8d5584), C64e(0xf5a5e9f0e4f88e65),
126                              C64e(0xa0b8a2f436103b53), C64e(0x0ca8079e753eec5a),
127                              C64e(0x9168949256e8884f), C64e(0x5bb05c55f8babc4c),
128                              C64e(0xe3bb3b99f387947b), C64e(0x75daf4d6726b1c5d),
129                              C64e(0x64aeac28dc34b36d), C64e(0x6c34a550b828db71),
130                              C64e(0xf861e2f2108d512a), C64e(0xe3db643359dd75fc),
131                              C64e(0x1cacbcf143ce3fa2), C64e(0x67bbd13c02e843b0),
132                              C64e(0x330a5bca8829a175), C64e(0x7f34194db416535c),
133                              C64e(0x923b94c30e794d1e), C64e(0x797475d7b6eeaf3f),
134                              C64e(0xeaa8d4f7be1a3921), C64e(0x5cf47e094c232751),
135                              C64e(0x26a32453ba323cd2), C64e(0x44a3174a6da6d5ad),
136                              C64e(0xb51d3ea6aff2c908), C64e(0x83593d98916b3c56),
137                              C64e(0x4cf87ca17286604d), C64e(0x46e23ecc086ec7f6),
138                              C64e(0x2f9833b3b1bc765e), C64e(0x2bd666a5efc4e62a),
139                              C64e(0x06f4b6e8bec1d436), C64e(0x74ee8215bcef2163),
140                              C64e(0xfdc14e0df453c969), C64e(0xa77d5ac406585826),
141                              C64e(0x7ec1141606e0fa16), C64e(0x7e90af3d28639d3f),
142                              C64e(0xd2c9f2e3009bd20c), C64e(0x5faace30b7d40c30),
143                              C64e(0x742a5116f2e03298), C64e(0x0deb30d8e3cef89a),
144                              C64e(0x4bc59e7bb5f17992), C64e(0xff51e66e048668d3),
145                              C64e(0x9b234d57e6966731), C64e(0xcce6a6f3170a7505),
146                              C64e(0xb17681d913326cce), C64e(0x3c175284f805a262),
147                              C64e(0xf42bcbb378471547), C64e(0xff46548223936a48),
148                              C64e(0x38df58074e5e6565), C64e(0xf2fc7c89fc86508e),
149                              C64e(0x31702e44d00bca86), C64e(0xf04009a23078474e),
150                              C64e(0x65a0ee39d1f73883), C64e(0xf75ee937e42c3abd),
151                              C64e(0x2197b2260113f86f), C64e(0xa344edd1ef9fdee7),
152                              C64e(0x8ba0df15762592d9), C64e(0x3c85f7f612dc42be),
153                              C64e(0xd8a7ec7cab27b07e), C64e(0x538d7ddaaa3ea8de),
154                              C64e(0xaa25ce93bd0269d8), C64e(0x5af643fd1a7308f9),
155                              C64e(0xc05fefda174a19a5), C64e(0x974d66334cfd216a),
156                              C64e(0x35b49831db411570), C64e(0xea1e0fbbedcd549b),
157                              C64e(0x9ad063a151974072), C64e(0xf6759dbf91476fe2)};
158  #define Ceven_hi(r) (C[((r) << 2) + 0])
159  #define Ceven_lo(r) (C[((r) << 2) + 1])
160  #define Codd_hi(r) (C[((r) << 2) + 2])
161  #define Codd_lo(r) (C[((r) << 2) + 3])
162  #define S(x0, x1, x2, x3, cb, r)                                               \
163    do {                                                                         \
164      Sb(x0##h, x1##h, x2##h, x3##h, cb##hi(r));                                 \
165      Sb(x0##l, x1##l, x2##l, x3##l, cb##lo(r));                                 \
166    } while (0)
167  #define L(x0, x1, x2, x3, x4, x5, x6, x7)                                      \
168    do {                                                                         \
169      Lb(x0##h, x1##h, x2##h, x3##h, x4##h, x5##h, x6##h, x7##h);                \
170      Lb(x0##l, x1##l, x2##l, x3##l, x4##l, x5##l, x6##l, x7##l);                \
171    } while (0)
172  #define Wz(x, c, n)                                                            \
173    do {                                                                         \
174      sph_u64 t = (x##h & (c)) << (n);                                           \
175      x##h = ((x##h >> (n)) & (c)) | t;                                          \
176      t = (x##l & (c)) << (n);                                                   \
177      x##l = ((x##l >> (n)) & (c)) | t;                                          \
178    } while (0)
179  #define W0(x) Wz(x, SPH_C64(0x5555555555555555), 1)
180  #define W1(x) Wz(x, SPH_C64(0x3333333333333333), 2)
181  #define W2(x) Wz(x, SPH_C64(0x0F0F0F0F0F0F0F0F), 4)
182  #define W3(x) Wz(x, SPH_C64(0x00FF00FF00FF00FF), 8)
183  #define W4(x) Wz(x, SPH_C64(0x0000FFFF0000FFFF), 16)
184  #define W5(x) Wz(x, SPH_C64(0x00000000FFFFFFFF), 32)
185  #define W6(x)                                                                  \
186    do {                                                                         \
187      sph_u64 t = x##h;                                                          \
188      x##h = x##l;                                                               \
189      x##l = t;                                                                  \
190    } while (0)
191  #define DECL_STATE                                                             \
192    sph_u64 h0h, h1h, h2h, h3h, h4h, h5h, h6h, h7h;                              \
193    sph_u64 h0l, h1l, h2l, h3l, h4l, h5l, h6l, h7l;                              \
194    sph_u64 tmp;
195  #define READ_STATE(state)                                                      \
196    do {                                                                         \
197      h0h = (state)->H.wide[0];                                                  \
198      h0l = (state)->H.wide[1];                                                  \
199      h1h = (state)->H.wide[2];                                                  \
200      h1l = (state)->H.wide[3];                                                  \
201      h2h = (state)->H.wide[4];                                                  \
202      h2l = (state)->H.wide[5];                                                  \
203      h3h = (state)->H.wide[6];                                                  \
204      h3l = (state)->H.wide[7];                                                  \
205      h4h = (state)->H.wide[8];                                                  \
206      h4l = (state)->H.wide[9];                                                  \
207      h5h = (state)->H.wide[10];                                                 \
208      h5l = (state)->H.wide[11];                                                 \
209      h6h = (state)->H.wide[12];                                                 \
210      h6l = (state)->H.wide[13];                                                 \
211      h7h = (state)->H.wide[14];                                                 \
212      h7l = (state)->H.wide[15];                                                 \
213    } while (0)
214  #define WRITE_STATE(state)                                                     \
215    do {                                                                         \
216      (state)->H.wide[0] = h0h;                                                  \
217      (state)->H.wide[1] = h0l;                                                  \
218      (state)->H.wide[2] = h1h;                                                  \
219      (state)->H.wide[3] = h1l;                                                  \
220      (state)->H.wide[4] = h2h;                                                  \
221      (state)->H.wide[5] = h2l;                                                  \
222      (state)->H.wide[6] = h3h;                                                  \
223      (state)->H.wide[7] = h3l;                                                  \
224      (state)->H.wide[8] = h4h;                                                  \
225      (state)->H.wide[9] = h4l;                                                  \
226      (state)->H.wide[10] = h5h;                                                 \
227      (state)->H.wide[11] = h5l;                                                 \
228      (state)->H.wide[12] = h6h;                                                 \
229      (state)->H.wide[13] = h6l;                                                 \
230      (state)->H.wide[14] = h7h;                                                 \
231      (state)->H.wide[15] = h7l;                                                 \
232    } while (0)
233  #define INPUT_BUF1                                                             \
234    sph_u64 m0h = dec64e_aligned(buf + 0);                                       \
235    sph_u64 m0l = dec64e_aligned(buf + 8);                                       \
236    sph_u64 m1h = dec64e_aligned(buf + 16);                                      \
237    sph_u64 m1l = dec64e_aligned(buf + 24);                                      \
238    sph_u64 m2h = dec64e_aligned(buf + 32);                                      \
239    sph_u64 m2l = dec64e_aligned(buf + 40);                                      \
240    sph_u64 m3h = dec64e_aligned(buf + 48);                                      \
241    sph_u64 m3l = dec64e_aligned(buf + 56);                                      \
242    h0h ^= m0h;                                                                  \
243    h0l ^= m0l;                                                                  \
244    h1h ^= m1h;                                                                  \
245    h1l ^= m1l;                                                                  \
246    h2h ^= m2h;                                                                  \
247    h2l ^= m2l;                                                                  \
248    h3h ^= m3h;                                                                  \
249    h3l ^= m3l;
250  #define INPUT_BUF2                                                             \
251    h4h ^= m0h;                                                                  \
252    h4l ^= m0l;                                                                  \
253    h5h ^= m1h;                                                                  \
254    h5l ^= m1l;                                                                  \
255    h6h ^= m2h;                                                                  \
256    h6l ^= m2l;                                                                  \
257    h7h ^= m3h;                                                                  \
258    h7l ^= m3l;
259  static const sph_u64 IV224[] = {
260      C64e(0x2dfedd62f99a98ac), C64e(0xae7cacd619d634e7),
261      C64e(0xa4831005bc301216), C64e(0xb86038c6c9661494),
262      C64e(0x66d9899f2580706f), C64e(0xce9ea31b1d9b1adc),
263      C64e(0x11e8325f7b366e10), C64e(0xf994857f02fa06c1),
264      C64e(0x1b4f1b5cd8c840b3), C64e(0x97f6a17f6e738099),
265      C64e(0xdcdf93a5adeaa3d3), C64e(0xa431e8dec9539a68),
266      C64e(0x22b4a98aec86a1e4), C64e(0xd574ac959ce56cf0),
267      C64e(0x15960deab5ab2bbf), C64e(0x9611dcf0dd64ea6e)};
268  static const sph_u64 IV256[] = {
269      C64e(0xeb98a3412c20d3eb), C64e(0x92cdbe7b9cb245c1),
270      C64e(0x1c93519160d4c7fa), C64e(0x260082d67e508a03),
271      C64e(0xa4239e267726b945), C64e(0xe0fb1a48d41a9477),
272      C64e(0xcdb5ab26026b177a), C64e(0x56f024420fff2fa8),
273      C64e(0x71a396897f2e4d75), C64e(0x1d144908f77de262),
274      C64e(0x277695f776248f94), C64e(0x87d5b6574780296c),
275      C64e(0x5c5e272dac8e0d6c), C64e(0x518450c657057a0f),
276      C64e(0x7be4d367702412ea), C64e(0x89e3ab13d31cd769)};
277  static const sph_u64 IV384[] = {
278      C64e(0x481e3bc6d813398a), C64e(0x6d3b5e894ade879b),
279      C64e(0x63faea68d480ad2e), C64e(0x332ccb21480f8267),
280      C64e(0x98aec84d9082b928), C64e(0xd455ea3041114249),
281      C64e(0x36f555b2924847ec), C64e(0xc7250a93baf43ce1),
282      C64e(0x569b7f8a27db454c), C64e(0x9efcbd496397af0e),
283      C64e(0x589fc27d26aa80cd), C64e(0x80c08b8c9deb2eda),
284      C64e(0x8a7981e8f8d5373a), C64e(0xf43967adddd17a71),
285      C64e(0xa9b4d3bda475d394), C64e(0x976c3fba9842737f)};
286  static const sph_u64 IV512[] = {
287      C64e(0x6fd14b963e00aa17), C64e(0x636a2e057a15d543),
288      C64e(0x8a225e8d0c97ef0b), C64e(0xe9341259f2b3c361),
289      C64e(0x891da0c1536f801e), C64e(0x2aa9056bea2b6d80),
290      C64e(0x588eccdb2075baa6), C64e(0xa90f3a76baf83bf7),
291      C64e(0x0169e60541e34a69), C64e(0x46b58a8e2e6fe65a),
292      C64e(0x1047a7d0c1843c24), C64e(0x3b6e71b12d5ac199),
293      C64e(0xcf57f6ec9db1f856), C64e(0xa706887c5716b156),
294      C64e(0xe3c2fcdfe68517fb), C64e(0x545a4678cc8cdd4b)};
295  #else
296  static const sph_u32 C[] = {
297      C32e(0x72d5dea2), C32e(0xdf15f867), C32e(0x7b84150a), C32e(0xb7231557),
298      C32e(0x81abd690), C32e(0x4d5a87f6), C32e(0x4e9f4fc5), C32e(0xc3d12b40),
299      C32e(0xea983ae0), C32e(0x5c45fa9c), C32e(0x03c5d299), C32e(0x66b2999a),
300      C32e(0x660296b4), C32e(0xf2bb538a), C32e(0xb556141a), C32e(0x88dba231),
301      C32e(0x03a35a5c), C32e(0x9a190edb), C32e(0x403fb20a), C32e(0x87c14410),
302      C32e(0x1c051980), C32e(0x849e951d), C32e(0x6f33ebad), C32e(0x5ee7cddc),
303      C32e(0x10ba1392), C32e(0x02bf6b41), C32e(0xdc786515), C32e(0xf7bb27d0),
304      C32e(0x0a2c8139), C32e(0x37aa7850), C32e(0x3f1abfd2), C32e(0x410091d3),
305      C32e(0x422d5a0d), C32e(0xf6cc7e90), C32e(0xdd629f9c), C32e(0x92c097ce),
306      C32e(0x185ca70b), C32e(0xc72b44ac), C32e(0xd1df65d6), C32e(0x63c6fc23),
307      C32e(0x976e6c03), C32e(0x9ee0b81a), C32e(0x2105457e), C32e(0x446ceca8),
308      C32e(0xeef103bb), C32e(0x5d8e61fa), C32e(0xfd9697b2), C32e(0x94838197),
309      C32e(0x4a8e8537), C32e(0xdb03302f), C32e(0x2a678d2d), C32e(0xfb9f6a95),
310      C32e(0x8afe7381), C32e(0xf8b8696c), C32e(0x8ac77246), C32e(0xc07f4214),
311      C32e(0xc5f4158f), C32e(0xbdc75ec4), C32e(0x75446fa7), C32e(0x8f11bb80),
312      C32e(0x52de75b7), C32e(0xaee488bc), C32e(0x82b8001e), C32e(0x98a6a3f4),
313      C32e(0x8ef48f33), C32e(0xa9a36315), C32e(0xaa5f5624), C32e(0xd5b7f989),
314      C32e(0xb6f1ed20), C32e(0x7c5ae0fd), C32e(0x36cae95a), C32e(0x06422c36),
315      C32e(0xce293543), C32e(0x4efe983d), C32e(0x533af974), C32e(0x739a4ba7),
316      C32e(0xd0f51f59), C32e(0x6f4e8186), C32e(0x0e9dad81), C32e(0xafd85a9f),
317      C32e(0xa7050667), C32e(0xee34626a), C32e(0x8b0b28be), C32e(0x6eb91727),
318      C32e(0x47740726), C32e(0xc680103f), C32e(0xe0a07e6f), C32e(0xc67e487b),
319      C32e(0x0d550aa5), C32e(0x4af8a4c0), C32e(0x91e3e79f), C32e(0x978ef19e),
320      C32e(0x86767281), C32e(0x50608dd4), C32e(0x7e9e5a41), C32e(0xf3e5b062),
321      C32e(0xfc9f1fec), C32e(0x4054207a), C32e(0xe3e41a00), C32e(0xcef4c984),
322      C32e(0x4fd794f5), C32e(0x9dfa95d8), C32e(0x552e7e11), C32e(0x24c354a5),
323      C32e(0x5bdf7228), C32e(0xbdfe6e28), C32e(0x78f57fe2), C32e(0x0fa5c4b2),
324      C32e(0x05897cef), C32e(0xee49d32e), C32e(0x447e9385), C32e(0xeb28597f),
325      C32e(0x705f6937), C32e(0xb324314a), C32e(0x5e8628f1), C32e(0x1dd6e465),
326      C32e(0xc71b7704), C32e(0x51b920e7), C32e(0x74fe43e8), C32e(0x23d4878a),
327      C32e(0x7d29e8a3), C32e(0x927694f2), C32e(0xddcb7a09), C32e(0x9b30d9c1),
328      C32e(0x1d1b30fb), C32e(0x5bdc1be0), C32e(0xda24494f), C32e(0xf29c82bf),
329      C32e(0xa4e7ba31), C32e(0xb470bfff), C32e(0x0d324405), C32e(0xdef8bc48),
330      C32e(0x3baefc32), C32e(0x53bbd339), C32e(0x459fc3c1), C32e(0xe0298ba0),
331      C32e(0xe5c905fd), C32e(0xf7ae090f), C32e(0x94703412), C32e(0x4290f134),
332      C32e(0xa271b701), C32e(0xe344ed95), C32e(0xe93b8e36), C32e(0x4f2f984a),
333      C32e(0x88401d63), C32e(0xa06cf615), C32e(0x47c1444b), C32e(0x8752afff),
334      C32e(0x7ebb4af1), C32e(0xe20ac630), C32e(0x4670b6c5), C32e(0xcc6e8ce6),
335      C32e(0xa4d5a456), C32e(0xbd4fca00), C32e(0xda9d844b), C32e(0xc83e18ae),
336      C32e(0x7357ce45), C32e(0x3064d1ad), C32e(0xe8a6ce68), C32e(0x145c2567),
337      C32e(0xa3da8cf2), C32e(0xcb0ee116), C32e(0x33e90658), C32e(0x9a94999a),
338      C32e(0x1f60b220), C32e(0xc26f847b), C32e(0xd1ceac7f), C32e(0xa0d18518),
339      C32e(0x32595ba1), C32e(0x8ddd19d3), C32e(0x509a1cc0), C32e(0xaaa5b446),
340      C32e(0x9f3d6367), C32e(0xe4046bba), C32e(0xf6ca19ab), C32e(0x0b56ee7e),
341      C32e(0x1fb179ea), C32e(0xa9282174), C32e(0xe9bdf735), C32e(0x3b3651ee),
342      C32e(0x1d57ac5a), C32e(0x7550d376), C32e(0x3a46c2fe), C32e(0xa37d7001),
343      C32e(0xf735c1af), C32e(0x98a4d842), C32e(0x78edec20), C32e(0x9e6b6779),
344      C32e(0x41836315), C32e(0xea3adba8), C32e(0xfac33b4d), C32e(0x32832c83),
345      C32e(0xa7403b1f), C32e(0x1c2747f3), C32e(0x5940f034), C32e(0xb72d769a),
346      C32e(0xe73e4e6c), C32e(0xd2214ffd), C32e(0xb8fd8d39), C32e(0xdc5759ef),
347      C32e(0x8d9b0c49), C32e(0x2b49ebda), C32e(0x5ba2d749), C32e(0x68f3700d),
348      C32e(0x7d3baed0), C32e(0x7a8d5584), C32e(0xf5a5e9f0), C32e(0xe4f88e65),
349      C32e(0xa0b8a2f4), C32e(0x36103b53), C32e(0x0ca8079e), C32e(0x753eec5a),
350      C32e(0x91689492), C32e(0x56e8884f), C32e(0x5bb05c55), C32e(0xf8babc4c),
351      C32e(0xe3bb3b99), C32e(0xf387947b), C32e(0x75daf4d6), C32e(0x726b1c5d),
352      C32e(0x64aeac28), C32e(0xdc34b36d), C32e(0x6c34a550), C32e(0xb828db71),
353      C32e(0xf861e2f2), C32e(0x108d512a), C32e(0xe3db6433), C32e(0x59dd75fc),
354      C32e(0x1cacbcf1), C32e(0x43ce3fa2), C32e(0x67bbd13c), C32e(0x02e843b0),
355      C32e(0x330a5bca), C32e(0x8829a175), C32e(0x7f34194d), C32e(0xb416535c),
356      C32e(0x923b94c3), C32e(0x0e794d1e), C32e(0x797475d7), C32e(0xb6eeaf3f),
357      C32e(0xeaa8d4f7), C32e(0xbe1a3921), C32e(0x5cf47e09), C32e(0x4c232751),
358      C32e(0x26a32453), C32e(0xba323cd2), C32e(0x44a3174a), C32e(0x6da6d5ad),
359      C32e(0xb51d3ea6), C32e(0xaff2c908), C32e(0x83593d98), C32e(0x916b3c56),
360      C32e(0x4cf87ca1), C32e(0x7286604d), C32e(0x46e23ecc), C32e(0x086ec7f6),
361      C32e(0x2f9833b3), C32e(0xb1bc765e), C32e(0x2bd666a5), C32e(0xefc4e62a),
362      C32e(0x06f4b6e8), C32e(0xbec1d436), C32e(0x74ee8215), C32e(0xbcef2163),
363      C32e(0xfdc14e0d), C32e(0xf453c969), C32e(0xa77d5ac4), C32e(0x06585826),
364      C32e(0x7ec11416), C32e(0x06e0fa16), C32e(0x7e90af3d), C32e(0x28639d3f),
365      C32e(0xd2c9f2e3), C32e(0x009bd20c), C32e(0x5faace30), C32e(0xb7d40c30),
366      C32e(0x742a5116), C32e(0xf2e03298), C32e(0x0deb30d8), C32e(0xe3cef89a),
367      C32e(0x4bc59e7b), C32e(0xb5f17992), C32e(0xff51e66e), C32e(0x048668d3),
368      C32e(0x9b234d57), C32e(0xe6966731), C32e(0xcce6a6f3), C32e(0x170a7505),
369      C32e(0xb17681d9), C32e(0x13326cce), C32e(0x3c175284), C32e(0xf805a262),
370      C32e(0xf42bcbb3), C32e(0x78471547), C32e(0xff465482), C32e(0x23936a48),
371      C32e(0x38df5807), C32e(0x4e5e6565), C32e(0xf2fc7c89), C32e(0xfc86508e),
372      C32e(0x31702e44), C32e(0xd00bca86), C32e(0xf04009a2), C32e(0x3078474e),
373      C32e(0x65a0ee39), C32e(0xd1f73883), C32e(0xf75ee937), C32e(0xe42c3abd),
374      C32e(0x2197b226), C32e(0x0113f86f), C32e(0xa344edd1), C32e(0xef9fdee7),
375      C32e(0x8ba0df15), C32e(0x762592d9), C32e(0x3c85f7f6), C32e(0x12dc42be),
376      C32e(0xd8a7ec7c), C32e(0xab27b07e), C32e(0x538d7dda), C32e(0xaa3ea8de),
377      C32e(0xaa25ce93), C32e(0xbd0269d8), C32e(0x5af643fd), C32e(0x1a7308f9),
378      C32e(0xc05fefda), C32e(0x174a19a5), C32e(0x974d6633), C32e(0x4cfd216a),
379      C32e(0x35b49831), C32e(0xdb411570), C32e(0xea1e0fbb), C32e(0xedcd549b),
380      C32e(0x9ad063a1), C32e(0x51974072), C32e(0xf6759dbf), C32e(0x91476fe2)};
381  #define Ceven_w3(r) (C[((r) << 3) + 0])
382  #define Ceven_w2(r) (C[((r) << 3) + 1])
383  #define Ceven_w1(r) (C[((r) << 3) + 2])
384  #define Ceven_w0(r) (C[((r) << 3) + 3])
385  #define Codd_w3(r) (C[((r) << 3) + 4])
386  #define Codd_w2(r) (C[((r) << 3) + 5])
387  #define Codd_w1(r) (C[((r) << 3) + 6])
388  #define Codd_w0(r) (C[((r) << 3) + 7])
389  #define S(x0, x1, x2, x3, cb, r)                                               \
390    do {                                                                         \
391      Sb(x0##3, x1##3, x2##3, x3##3, cb##w3(r));                                 \
392      Sb(x0##2, x1##2, x2##2, x3##2, cb##w2(r));                                 \
393      Sb(x0##1, x1##1, x2##1, x3##1, cb##w1(r));                                 \
394      Sb(x0##0, x1##0, x2##0, x3##0, cb##w0(r));                                 \
395    } while (0)
396  #define L(x0, x1, x2, x3, x4, x5, x6, x7)                                      \
397    do {                                                                         \
398      Lb(x0##3, x1##3, x2##3, x3##3, x4##3, x5##3, x6##3, x7##3);                \
399      Lb(x0##2, x1##2, x2##2, x3##2, x4##2, x5##2, x6##2, x7##2);                \
400      Lb(x0##1, x1##1, x2##1, x3##1, x4##1, x5##1, x6##1, x7##1);                \
401      Lb(x0##0, x1##0, x2##0, x3##0, x4##0, x5##0, x6##0, x7##0);                \
402    } while (0)
403  #define Wz(x, c, n)                                                            \
404    do {                                                                         \
405      sph_u32 t = (x##3 & (c)) << (n);                                           \
406      x##3 = ((x##3 >> (n)) & (c)) | t;                                          \
407      t = (x##2 & (c)) << (n);                                                   \
408      x##2 = ((x##2 >> (n)) & (c)) | t;                                          \
409      t = (x##1 & (c)) << (n);                                                   \
410      x##1 = ((x##1 >> (n)) & (c)) | t;                                          \
411      t = (x##0 & (c)) << (n);                                                   \
412      x##0 = ((x##0 >> (n)) & (c)) | t;                                          \
413    } while (0)
414  #define W0(x) Wz(x, SPH_C32(0x55555555), 1)
415  #define W1(x) Wz(x, SPH_C32(0x33333333), 2)
416  #define W2(x) Wz(x, SPH_C32(0x0F0F0F0F), 4)
417  #define W3(x) Wz(x, SPH_C32(0x00FF00FF), 8)
418  #define W4(x) Wz(x, SPH_C32(0x0000FFFF), 16)
419  #define W5(x)                                                                  \
420    do {                                                                         \
421      sph_u32 t = x##3;                                                          \
422      x##3 = x##2;                                                               \
423      x##2 = t;                                                                  \
424      t = x##1;                                                                  \
425      x##1 = x##0;                                                               \
426      x##0 = t;                                                                  \
427    } while (0)
428  #define W6(x)                                                                  \
429    do {                                                                         \
430      sph_u32 t = x##3;                                                          \
431      x##3 = x##1;                                                               \
432      x##1 = t;                                                                  \
433      t = x##2;                                                                  \
434      x##2 = x##0;                                                               \
435      x##0 = t;                                                                  \
436    } while (0)
437  #define DECL_STATE                                                             \
438    sph_u32 h03, h02, h01, h00, h13, h12, h11, h10;                              \
439    sph_u32 h23, h22, h21, h20, h33, h32, h31, h30;                              \
440    sph_u32 h43, h42, h41, h40, h53, h52, h51, h50;                              \
441    sph_u32 h63, h62, h61, h60, h73, h72, h71, h70;                              \
442    sph_u32 tmp;
443  #define READ_STATE(state)                                                      \
444    do {                                                                         \
445      h03 = (state)->H.narrow[0];                                                \
446      h02 = (state)->H.narrow[1];                                                \
447      h01 = (state)->H.narrow[2];                                                \
448      h00 = (state)->H.narrow[3];                                                \
449      h13 = (state)->H.narrow[4];                                                \
450      h12 = (state)->H.narrow[5];                                                \
451      h11 = (state)->H.narrow[6];                                                \
452      h10 = (state)->H.narrow[7];                                                \
453      h23 = (state)->H.narrow[8];                                                \
454      h22 = (state)->H.narrow[9];                                                \
455      h21 = (state)->H.narrow[10];                                               \
456      h20 = (state)->H.narrow[11];                                               \
457      h33 = (state)->H.narrow[12];                                               \
458      h32 = (state)->H.narrow[13];                                               \
459      h31 = (state)->H.narrow[14];                                               \
460      h30 = (state)->H.narrow[15];                                               \
461      h43 = (state)->H.narrow[16];                                               \
462      h42 = (state)->H.narrow[17];                                               \
463      h41 = (state)->H.narrow[18];                                               \
464      h40 = (state)->H.narrow[19];                                               \
465      h53 = (state)->H.narrow[20];                                               \
466      h52 = (state)->H.narrow[21];                                               \
467      h51 = (state)->H.narrow[22];                                               \
468      h50 = (state)->H.narrow[23];                                               \
469      h63 = (state)->H.narrow[24];                                               \
470      h62 = (state)->H.narrow[25];                                               \
471      h61 = (state)->H.narrow[26];                                               \
472      h60 = (state)->H.narrow[27];                                               \
473      h73 = (state)->H.narrow[28];                                               \
474      h72 = (state)->H.narrow[29];                                               \
475      h71 = (state)->H.narrow[30];                                               \
476      h70 = (state)->H.narrow[31];                                               \
477    } while (0)
478  #define WRITE_STATE(state)                                                     \
479    do {                                                                         \
480      (state)->H.narrow[0] = h03;                                                \
481      (state)->H.narrow[1] = h02;                                                \
482      (state)->H.narrow[2] = h01;                                                \
483      (state)->H.narrow[3] = h00;                                                \
484      (state)->H.narrow[4] = h13;                                                \
485      (state)->H.narrow[5] = h12;                                                \
486      (state)->H.narrow[6] = h11;                                                \
487      (state)->H.narrow[7] = h10;                                                \
488      (state)->H.narrow[8] = h23;                                                \
489      (state)->H.narrow[9] = h22;                                                \
490      (state)->H.narrow[10] = h21;                                               \
491      (state)->H.narrow[11] = h20;                                               \
492      (state)->H.narrow[12] = h33;                                               \
493      (state)->H.narrow[13] = h32;                                               \
494      (state)->H.narrow[14] = h31;                                               \
495      (state)->H.narrow[15] = h30;                                               \
496      (state)->H.narrow[16] = h43;                                               \
497      (state)->H.narrow[17] = h42;                                               \
498      (state)->H.narrow[18] = h41;                                               \
499      (state)->H.narrow[19] = h40;                                               \
500      (state)->H.narrow[20] = h53;                                               \
501      (state)->H.narrow[21] = h52;                                               \
502      (state)->H.narrow[22] = h51;                                               \
503      (state)->H.narrow[23] = h50;                                               \
504      (state)->H.narrow[24] = h63;                                               \
505      (state)->H.narrow[25] = h62;                                               \
506      (state)->H.narrow[26] = h61;                                               \
507      (state)->H.narrow[27] = h60;                                               \
508      (state)->H.narrow[28] = h73;                                               \
509      (state)->H.narrow[29] = h72;                                               \
510      (state)->H.narrow[30] = h71;                                               \
511      (state)->H.narrow[31] = h70;                                               \
512    } while (0)
513  #define INPUT_BUF1                                                             \
514    sph_u32 m03 = dec32e_aligned(buf + 0);                                       \
515    sph_u32 m02 = dec32e_aligned(buf + 4);                                       \
516    sph_u32 m01 = dec32e_aligned(buf + 8);                                       \
517    sph_u32 m00 = dec32e_aligned(buf + 12);                                      \
518    sph_u32 m13 = dec32e_aligned(buf + 16);                                      \
519    sph_u32 m12 = dec32e_aligned(buf + 20);                                      \
520    sph_u32 m11 = dec32e_aligned(buf + 24);                                      \
521    sph_u32 m10 = dec32e_aligned(buf + 28);                                      \
522    sph_u32 m23 = dec32e_aligned(buf + 32);                                      \
523    sph_u32 m22 = dec32e_aligned(buf + 36);                                      \
524    sph_u32 m21 = dec32e_aligned(buf + 40);                                      \
525    sph_u32 m20 = dec32e_aligned(buf + 44);                                      \
526    sph_u32 m33 = dec32e_aligned(buf + 48);                                      \
527    sph_u32 m32 = dec32e_aligned(buf + 52);                                      \
528    sph_u32 m31 = dec32e_aligned(buf + 56);                                      \
529    sph_u32 m30 = dec32e_aligned(buf + 60);                                      \
530    h03 ^= m03;                                                                  \
531    h02 ^= m02;                                                                  \
532    h01 ^= m01;                                                                  \
533    h00 ^= m00;                                                                  \
534    h13 ^= m13;                                                                  \
535    h12 ^= m12;                                                                  \
536    h11 ^= m11;                                                                  \
537    h10 ^= m10;                                                                  \
538    h23 ^= m23;                                                                  \
539    h22 ^= m22;                                                                  \
540    h21 ^= m21;                                                                  \
541    h20 ^= m20;                                                                  \
542    h33 ^= m33;                                                                  \
543    h32 ^= m32;                                                                  \
544    h31 ^= m31;                                                                  \
545    h30 ^= m30;
546  #define INPUT_BUF2                                                             \
547    h43 ^= m03;                                                                  \
548    h42 ^= m02;                                                                  \
549    h41 ^= m01;                                                                  \
550    h40 ^= m00;                                                                  \
551    h53 ^= m13;                                                                  \
552    h52 ^= m12;                                                                  \
553    h51 ^= m11;                                                                  \
554    h50 ^= m10;                                                                  \
555    h63 ^= m23;                                                                  \
556    h62 ^= m22;                                                                  \
557    h61 ^= m21;                                                                  \
558    h60 ^= m20;                                                                  \
559    h73 ^= m33;                                                                  \
560    h72 ^= m32;                                                                  \
561    h71 ^= m31;                                                                  \
562    h70 ^= m30;
563  static const sph_u32 IV224[] = {
564      C32e(0x2dfedd62), C32e(0xf99a98ac), C32e(0xae7cacd6), C32e(0x19d634e7),
565      C32e(0xa4831005), C32e(0xbc301216), C32e(0xb86038c6), C32e(0xc9661494),
566      C32e(0x66d9899f), C32e(0x2580706f), C32e(0xce9ea31b), C32e(0x1d9b1adc),
567      C32e(0x11e8325f), C32e(0x7b366e10), C32e(0xf994857f), C32e(0x02fa06c1),
568      C32e(0x1b4f1b5c), C32e(0xd8c840b3), C32e(0x97f6a17f), C32e(0x6e738099),
569      C32e(0xdcdf93a5), C32e(0xadeaa3d3), C32e(0xa431e8de), C32e(0xc9539a68),
570      C32e(0x22b4a98a), C32e(0xec86a1e4), C32e(0xd574ac95), C32e(0x9ce56cf0),
571      C32e(0x15960dea), C32e(0xb5ab2bbf), C32e(0x9611dcf0), C32e(0xdd64ea6e)};
572  static const sph_u32 IV256[] = {
573      C32e(0xeb98a341), C32e(0x2c20d3eb), C32e(0x92cdbe7b), C32e(0x9cb245c1),
574      C32e(0x1c935191), C32e(0x60d4c7fa), C32e(0x260082d6), C32e(0x7e508a03),
575      C32e(0xa4239e26), C32e(0x7726b945), C32e(0xe0fb1a48), C32e(0xd41a9477),
576      C32e(0xcdb5ab26), C32e(0x026b177a), C32e(0x56f02442), C32e(0x0fff2fa8),
577      C32e(0x71a39689), C32e(0x7f2e4d75), C32e(0x1d144908), C32e(0xf77de262),
578      C32e(0x277695f7), C32e(0x76248f94), C32e(0x87d5b657), C32e(0x4780296c),
579      C32e(0x5c5e272d), C32e(0xac8e0d6c), C32e(0x518450c6), C32e(0x57057a0f),
580      C32e(0x7be4d367), C32e(0x702412ea), C32e(0x89e3ab13), C32e(0xd31cd769)};
581  static const sph_u32 IV384[] = {
582      C32e(0x481e3bc6), C32e(0xd813398a), C32e(0x6d3b5e89), C32e(0x4ade879b),
583      C32e(0x63faea68), C32e(0xd480ad2e), C32e(0x332ccb21), C32e(0x480f8267),
584      C32e(0x98aec84d), C32e(0x9082b928), C32e(0xd455ea30), C32e(0x41114249),
585      C32e(0x36f555b2), C32e(0x924847ec), C32e(0xc7250a93), C32e(0xbaf43ce1),
586      C32e(0x569b7f8a), C32e(0x27db454c), C32e(0x9efcbd49), C32e(0x6397af0e),
587      C32e(0x589fc27d), C32e(0x26aa80cd), C32e(0x80c08b8c), C32e(0x9deb2eda),
588      C32e(0x8a7981e8), C32e(0xf8d5373a), C32e(0xf43967ad), C32e(0xddd17a71),
589      C32e(0xa9b4d3bd), C32e(0xa475d394), C32e(0x976c3fba), C32e(0x9842737f)};
590  static const sph_u32 IV512[] = {
591      C32e(0x6fd14b96), C32e(0x3e00aa17), C32e(0x636a2e05), C32e(0x7a15d543),
592      C32e(0x8a225e8d), C32e(0x0c97ef0b), C32e(0xe9341259), C32e(0xf2b3c361),
593      C32e(0x891da0c1), C32e(0x536f801e), C32e(0x2aa9056b), C32e(0xea2b6d80),
594      C32e(0x588eccdb), C32e(0x2075baa6), C32e(0xa90f3a76), C32e(0xbaf83bf7),
595      C32e(0x0169e605), C32e(0x41e34a69), C32e(0x46b58a8e), C32e(0x2e6fe65a),
596      C32e(0x1047a7d0), C32e(0xc1843c24), C32e(0x3b6e71b1), C32e(0x2d5ac199),
597      C32e(0xcf57f6ec), C32e(0x9db1f856), C32e(0xa706887c), C32e(0x5716b156),
598      C32e(0xe3c2fcdf), C32e(0xe68517fb), C32e(0x545a4678), C32e(0xcc8cdd4b)};
599  #endif
600  #define SL(ro) SLu(r + ro, ro)
601  #define SLu(r, ro)                                                             \
602    do {                                                                         \
603      S(h0, h2, h4, h6, Ceven_, r);                                              \
604      S(h1, h3, h5, h7, Codd_, r);                                               \
605      L(h0, h2, h4, h6, h1, h3, h5, h7);                                         \
606      W##ro(h1);                                                                 \
607      W##ro(h3);                                                                 \
608      W##ro(h5);                                                                 \
609      W##ro(h7);                                                                 \
610    } while (0)
611  #if SPH_SMALL_FOOTPRINT_JH
612  #if SPH_JH_64
613  #define E8                                                                     \
614    do {                                                                         \
615      unsigned r;                                                                \
616      for (r = 0; r < 42; r += 7) {                                              \
617        SL(0);                                                                   \
618        SL(1);                                                                   \
619        SL(2);                                                                   \
620        SL(3);                                                                   \
621        SL(4);                                                                   \
622        SL(5);                                                                   \
623        SL(6);                                                                   \
624      }                                                                          \
625    } while (0)
626  #else
627  #define E8                                                                     \
628    do {                                                                         \
629      unsigned r, g;                                                             \
630      for (r = g = 0; r < 42; r++) {                                             \
631        S(h0, h2, h4, h6, Ceven_, r);                                            \
632        S(h1, h3, h5, h7, Codd_, r);                                             \
633        L(h0, h2, h4, h6, h1, h3, h5, h7);                                       \
634        switch (g) {                                                             \
635        case 0:                                                                  \
636          W0(h1);                                                                \
637          W0(h3);                                                                \
638          W0(h5);                                                                \
639          W0(h7);                                                                \
640          break;                                                                 \
641        case 1:                                                                  \
642          W1(h1);                                                                \
643          W1(h3);                                                                \
644          W1(h5);                                                                \
645          W1(h7);                                                                \
646          break;                                                                 \
647        case 2:                                                                  \
648          W2(h1);                                                                \
649          W2(h3);                                                                \
650          W2(h5);                                                                \
651          W2(h7);                                                                \
652          break;                                                                 \
653        case 3:                                                                  \
654          W3(h1);                                                                \
655          W3(h3);                                                                \
656          W3(h5);                                                                \
657          W3(h7);                                                                \
658          break;                                                                 \
659        case 4:                                                                  \
660          W4(h1);                                                                \
661          W4(h3);                                                                \
662          W4(h5);                                                                \
663          W4(h7);                                                                \
664          break;                                                                 \
665        case 5:                                                                  \
666          W5(h1);                                                                \
667          W5(h3);                                                                \
668          W5(h5);                                                                \
669          W5(h7);                                                                \
670          break;                                                                 \
671        case 6:                                                                  \
672          W6(h1);                                                                \
673          W6(h3);                                                                \
674          W6(h5);                                                                \
675          W6(h7);                                                                \
676          break;                                                                 \
677        }                                                                        \
678        if (++g == 7)                                                            \
679          g = 0;                                                                 \
680      }                                                                          \
681    } while (0)
682  #endif
683  #else
684  #if SPH_JH_64
685  #define E8                                                                     \
686    do {                                                                         \
687      SLu(0, 0);                                                                 \
688      SLu(1, 1);                                                                 \
689      SLu(2, 2);                                                                 \
690      SLu(3, 3);                                                                 \
691      SLu(4, 4);                                                                 \
692      SLu(5, 5);                                                                 \
693      SLu(6, 6);                                                                 \
694      SLu(7, 0);                                                                 \
695      SLu(8, 1);                                                                 \
696      SLu(9, 2);                                                                 \
697      SLu(10, 3);                                                                \
698      SLu(11, 4);                                                                \
699      SLu(12, 5);                                                                \
700      SLu(13, 6);                                                                \
701      SLu(14, 0);                                                                \
702      SLu(15, 1);                                                                \
703      SLu(16, 2);                                                                \
704      SLu(17, 3);                                                                \
705      SLu(18, 4);                                                                \
706      SLu(19, 5);                                                                \
707      SLu(20, 6);                                                                \
708      SLu(21, 0);                                                                \
709      SLu(22, 1);                                                                \
710      SLu(23, 2);                                                                \
711      SLu(24, 3);                                                                \
712      SLu(25, 4);                                                                \
713      SLu(26, 5);                                                                \
714      SLu(27, 6);                                                                \
715      SLu(28, 0);                                                                \
716      SLu(29, 1);                                                                \
717      SLu(30, 2);                                                                \
718      SLu(31, 3);                                                                \
719      SLu(32, 4);                                                                \
720      SLu(33, 5);                                                                \
721      SLu(34, 6);                                                                \
722      SLu(35, 0);                                                                \
723      SLu(36, 1);                                                                \
724      SLu(37, 2);                                                                \
725      SLu(38, 3);                                                                \
726      SLu(39, 4);                                                                \
727      SLu(40, 5);                                                                \
728      SLu(41, 6);                                                                \
729    } while (0)
730  #else
731  #define E8                                                                     \
732    do {                                                                         \
733      unsigned r;                                                                \
734      for (r = 0; r < 42; r += 7) {                                              \
735        SL(0);                                                                   \
736        SL(1);                                                                   \
737        SL(2);                                                                   \
738        SL(3);                                                                   \
739        SL(4);                                                                   \
740        SL(5);                                                                   \
741        SL(6);                                                                   \
742      }                                                                          \
743    } while (0)
744  #endif
745  #endif
746  static void jh_init(sph_jh_context *sc, const void *iv) {
747    sc->ptr = 0;
748  #if SPH_JH_64
749    memcpy(sc->H.wide, iv, sizeof sc->H.wide);
750  #else
751    memcpy(sc->H.narrow, iv, sizeof sc->H.narrow);
752  #endif
753  #if SPH_64
754    sc->block_count = 0;
755  #else
<span onclick='openModal()' class='match'>756    sc->block_count_high = 0;
757    sc->block_count_low = 0;
758  #endif
759  }
760  static void jh_core(sph_jh_context *sc, const void *data, size_t len) {
</span>761    unsigned char *buf;
762    size_t ptr;
763    DECL_STATE
764    buf = sc->buf;
765    ptr = sc->ptr;
766    if (len < (sizeof sc->buf) - ptr) {
767      memcpy(buf + ptr, data, len);
768      ptr += len;
769      sc->ptr = ptr;
770      return;
771    }
772    READ_STATE(sc);
773    while (len > 0) {
774      size_t clen;
775      clen = (sizeof sc->buf) - ptr;
776      if (clen > len)
777        clen = len;
778      memcpy(buf + ptr, data, clen);
779      ptr += clen;
780      data = (const unsigned char *)data + clen;
781      len -= clen;
782      if (ptr == sizeof sc->buf) {
783        INPUT_BUF1;
784        E8;
785        INPUT_BUF2;
786  #if SPH_64
787        sc->block_count++;
788  #else
789        if ((sc->block_count_low = SPH_T32(sc->block_count_low + 1)) == 0)
790          sc->block_count_high++;
791  #endif
792        ptr = 0;
793      }
794    }
795    WRITE_STATE(sc);
796    sc->ptr = ptr;
797  }
798  static void jh_close(sph_jh_context *sc, unsigned ub, unsigned n, void *dst,
799                       size_t out_size_w32,
800                       const void * iv) {
801    unsigned z;
802    unsigned char buf[128];
803    size_t numz, u;
804  #if SPH_64
805    sph_u64 l0, l1;
806  #else
807    sph_u32 l0, l1, l2, l3;
808  #endif
809    z = 0x80 >> n;
810    buf[0] = ((ub & -z) | z) & 0xFF;
811    if (sc->ptr == 0 && n == 0) {
812      numz = 47;
813    } else {
814      numz = 111 - sc->ptr;
815    }
816    memset(buf + 1, 0, numz);
817  #if SPH_64
818    l0 = SPH_T64(sc->block_count << 9) + (sc->ptr << 3) + n;
819    l1 = SPH_T64(sc->block_count >> 55);
820    sph_enc64be(buf + numz + 1, l1);
821    sph_enc64be(buf + numz + 9, l0);
822  #else
823    l0 = SPH_T32(sc->block_count_low << 9) + (sc->ptr << 3) + n;
824    l1 = SPH_T32(sc->block_count_low >> 23) + SPH_T32(sc->block_count_high << 9);
825    l2 = SPH_T32(sc->block_count_high >> 23);
826    l3 = 0;
827    sph_enc32be(buf + numz + 1, l3);
828    sph_enc32be(buf + numz + 5, l2);
829    sph_enc32be(buf + numz + 9, l1);
830    sph_enc32be(buf + numz + 13, l0);
831  #endif
832    jh_core(sc, buf, numz + 17);
833  #if SPH_JH_64
834    for (u = 0; u < 8; u++)
835      enc64e(buf + (u << 3), sc->H.wide[u + 8]);
836  #else
837    for (u = 0; u < 16; u++)
838      enc32e(buf + (u << 2), sc->H.narrow[u + 16]);
839  #endif
840    memcpy(dst, buf + ((16 - out_size_w32) << 2), out_size_w32 << 2);
841  }
842  void sph_jh224_init(void *cc) { jh_init(cc, IV224); }
843  void sph_jh224(void *cc, const void *data, size_t len) {
844    jh_core(cc, data, len);
845  }
846  void sph_jh224_close(void *cc, void *dst) { jh_close(cc, 0, 0, dst, 7, IV224); }
847  void sph_jh224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst) {
848    jh_close(cc, ub, n, dst, 7, IV224);
849  }
850  void sph_jh256_init(void *cc) { jh_init(cc, IV256); }
851  void sph_jh256(void *cc, const void *data, size_t len) {
852    jh_core(cc, data, len);
853  }
854  void sph_jh256_close(void *cc, void *dst) { jh_close(cc, 0, 0, dst, 8, IV256); }
855  void sph_jh256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst) {
856    jh_close(cc, ub, n, dst, 8, IV256);
857  }
858  void sph_jh384_init(void *cc) { jh_init(cc, IV384); }
859  void sph_jh384(void *cc, const void *data, size_t len) {
860    jh_core(cc, data, len);
861  }
862  void sph_jh384_close(void *cc, void *dst) {
863    jh_close(cc, 0, 0, dst, 12, IV384);
864  }
865  void sph_jh384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst) {
866    jh_close(cc, ub, n, dst, 12, IV384);
867  }
868  void sph_jh512_init(void *cc) { jh_init(cc, IV512); }
869  void sph_jh512(void *cc, const void *data, size_t len) {
870    jh_core(cc, data, len);
871  }
872  void sph_jh512_close(void *cc, void *dst) {
873    jh_close(cc, 0, 0, dst, 16, IV512);
874  }
875  void sph_jh512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst) {
876    jh_close(cc, ub, n, dst, 16, IV512);
877  }
878  #ifdef __cplusplus
879  }
880  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_fugue.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_fugue.h"
4  #ifdef __cplusplus
5  extern "C"{
6  #endif
7  #ifdef _MSC_VER
8  #pragma warning (disable: 4146)
9  #endif
10  #define SPH_FUGUE_NOCOPY 1
11  static const sph_u32 IV224[] = {
12  	SPH_C32(0xf4c9120d), SPH_C32(0x6286f757), SPH_C32(0xee39e01c),
13  	SPH_C32(0xe074e3cb), SPH_C32(0xa1127c62), SPH_C32(0x9a43d215),
14  	SPH_C32(0xbd8d679a)
15  };
16  static const sph_u32 IV256[] = {
17  	SPH_C32(0xe952bdde), SPH_C32(0x6671135f), SPH_C32(0xe0d4f668),
18  	SPH_C32(0xd2b0b594), SPH_C32(0xf96c621d), SPH_C32(0xfbf929de),
19  	SPH_C32(0x9149e899), SPH_C32(0x34f8c248)
20  };
21  static const sph_u32 IV384[] = {
22  	SPH_C32(0xaa61ec0d), SPH_C32(0x31252e1f), SPH_C32(0xa01db4c7),
23  	SPH_C32(0x00600985), SPH_C32(0x215ef44a), SPH_C32(0x741b5e9c),
24  	SPH_C32(0xfa693e9a), SPH_C32(0x473eb040), SPH_C32(0xe502ae8a),
25  	SPH_C32(0xa99c25e0), SPH_C32(0xbc95517c), SPH_C32(0x5c1095a1)
26  };
27  static const sph_u32 IV512[] = {
28  	SPH_C32(0x8807a57e), SPH_C32(0xe616af75), SPH_C32(0xc5d3e4db),
29  	SPH_C32(0xac9ab027), SPH_C32(0xd915f117), SPH_C32(0xb6eecc54),
30  	SPH_C32(0x06e8020b), SPH_C32(0x4a92efd1), SPH_C32(0xaac6e2c9),
31  	SPH_C32(0xddb21398), SPH_C32(0xcae65838), SPH_C32(0x437f203f),
32  	SPH_C32(0x25ea78e7), SPH_C32(0x951fddd6), SPH_C32(0xda6ed11d),
33  	SPH_C32(0xe13e3567)
34  };
35  static const sph_u32 mixtab0[] = {
36  	SPH_C32(0x63633297), SPH_C32(0x7c7c6feb), SPH_C32(0x77775ec7),
37  	SPH_C32(0x7b7b7af7), SPH_C32(0xf2f2e8e5), SPH_C32(0x6b6b0ab7),
38  	SPH_C32(0x6f6f16a7), SPH_C32(0xc5c56d39), SPH_C32(0x303090c0),
39  	SPH_C32(0x01010704), SPH_C32(0x67672e87), SPH_C32(0x2b2bd1ac),
40  	SPH_C32(0xfefeccd5), SPH_C32(0xd7d71371), SPH_C32(0xabab7c9a),
41  	SPH_C32(0x767659c3), SPH_C32(0xcaca4005), SPH_C32(0x8282a33e),
42  	SPH_C32(0xc9c94909), SPH_C32(0x7d7d68ef), SPH_C32(0xfafad0c5),
43  	SPH_C32(0x5959947f), SPH_C32(0x4747ce07), SPH_C32(0xf0f0e6ed),
44  	SPH_C32(0xadad6e82), SPH_C32(0xd4d41a7d), SPH_C32(0xa2a243be),
45  	SPH_C32(0xafaf608a), SPH_C32(0x9c9cf946), SPH_C32(0xa4a451a6),
46  	SPH_C32(0x727245d3), SPH_C32(0xc0c0762d), SPH_C32(0xb7b728ea),
47  	SPH_C32(0xfdfdc5d9), SPH_C32(0x9393d47a), SPH_C32(0x2626f298),
48  	SPH_C32(0x363682d8), SPH_C32(0x3f3fbdfc), SPH_C32(0xf7f7f3f1),
49  	SPH_C32(0xcccc521d), SPH_C32(0x34348cd0), SPH_C32(0xa5a556a2),
50  	SPH_C32(0xe5e58db9), SPH_C32(0xf1f1e1e9), SPH_C32(0x71714cdf),
51  	SPH_C32(0xd8d83e4d), SPH_C32(0x313197c4), SPH_C32(0x15156b54),
52  	SPH_C32(0x04041c10), SPH_C32(0xc7c76331), SPH_C32(0x2323e98c),
53  	SPH_C32(0xc3c37f21), SPH_C32(0x18184860), SPH_C32(0x9696cf6e),
54  	SPH_C32(0x05051b14), SPH_C32(0x9a9aeb5e), SPH_C32(0x0707151c),
55  	SPH_C32(0x12127e48), SPH_C32(0x8080ad36), SPH_C32(0xe2e298a5),
56  	SPH_C32(0xebeba781), SPH_C32(0x2727f59c), SPH_C32(0xb2b233fe),
57  	SPH_C32(0x757550cf), SPH_C32(0x09093f24), SPH_C32(0x8383a43a),
58  	SPH_C32(0x2c2cc4b0), SPH_C32(0x1a1a4668), SPH_C32(0x1b1b416c),
59  	SPH_C32(0x6e6e11a3), SPH_C32(0x5a5a9d73), SPH_C32(0xa0a04db6),
60  	SPH_C32(0x5252a553), SPH_C32(0x3b3ba1ec), SPH_C32(0xd6d61475),
61  	SPH_C32(0xb3b334fa), SPH_C32(0x2929dfa4), SPH_C32(0xe3e39fa1),
62  	SPH_C32(0x2f2fcdbc), SPH_C32(0x8484b126), SPH_C32(0x5353a257),
63  	SPH_C32(0xd1d10169), SPH_C32(0x00000000), SPH_C32(0xededb599),
64  	SPH_C32(0x2020e080), SPH_C32(0xfcfcc2dd), SPH_C32(0xb1b13af2),
65  	SPH_C32(0x5b5b9a77), SPH_C32(0x6a6a0db3), SPH_C32(0xcbcb4701),
66  	SPH_C32(0xbebe17ce), SPH_C32(0x3939afe4), SPH_C32(0x4a4aed33),
67  	SPH_C32(0x4c4cff2b), SPH_C32(0x5858937b), SPH_C32(0xcfcf5b11),
68  	SPH_C32(0xd0d0066d), SPH_C32(0xefefbb91), SPH_C32(0xaaaa7b9e),
69  	SPH_C32(0xfbfbd7c1), SPH_C32(0x4343d217), SPH_C32(0x4d4df82f),
70  	SPH_C32(0x333399cc), SPH_C32(0x8585b622), SPH_C32(0x4545c00f),
71  	SPH_C32(0xf9f9d9c9), SPH_C32(0x02020e08), SPH_C32(0x7f7f66e7),
72  	SPH_C32(0x5050ab5b), SPH_C32(0x3c3cb4f0), SPH_C32(0x9f9ff04a),
73  	SPH_C32(0xa8a87596), SPH_C32(0x5151ac5f), SPH_C32(0xa3a344ba),
74  	SPH_C32(0x4040db1b), SPH_C32(0x8f8f800a), SPH_C32(0x9292d37e),
75  	SPH_C32(0x9d9dfe42), SPH_C32(0x3838a8e0), SPH_C32(0xf5f5fdf9),
76  	SPH_C32(0xbcbc19c6), SPH_C32(0xb6b62fee), SPH_C32(0xdada3045),
77  	SPH_C32(0x2121e784), SPH_C32(0x10107040), SPH_C32(0xffffcbd1),
78  	SPH_C32(0xf3f3efe1), SPH_C32(0xd2d20865), SPH_C32(0xcdcd5519),
79  	SPH_C32(0x0c0c2430), SPH_C32(0x1313794c), SPH_C32(0xececb29d),
80  	SPH_C32(0x5f5f8667), SPH_C32(0x9797c86a), SPH_C32(0x4444c70b),
81  	SPH_C32(0x1717655c), SPH_C32(0xc4c46a3d), SPH_C32(0xa7a758aa),
82  	SPH_C32(0x7e7e61e3), SPH_C32(0x3d3db3f4), SPH_C32(0x6464278b),
83  	SPH_C32(0x5d5d886f), SPH_C32(0x19194f64), SPH_C32(0x737342d7),
84  	SPH_C32(0x60603b9b), SPH_C32(0x8181aa32), SPH_C32(0x4f4ff627),
85  	SPH_C32(0xdcdc225d), SPH_C32(0x2222ee88), SPH_C32(0x2a2ad6a8),
86  	SPH_C32(0x9090dd76), SPH_C32(0x88889516), SPH_C32(0x4646c903),
87  	SPH_C32(0xeeeebc95), SPH_C32(0xb8b805d6), SPH_C32(0x14146c50),
88  	SPH_C32(0xdede2c55), SPH_C32(0x5e5e8163), SPH_C32(0x0b0b312c),
89  	SPH_C32(0xdbdb3741), SPH_C32(0xe0e096ad), SPH_C32(0x32329ec8),
90  	SPH_C32(0x3a3aa6e8), SPH_C32(0x0a0a3628), SPH_C32(0x4949e43f),
91  	SPH_C32(0x06061218), SPH_C32(0x2424fc90), SPH_C32(0x5c5c8f6b),
92  	SPH_C32(0xc2c27825), SPH_C32(0xd3d30f61), SPH_C32(0xacac6986),
93  	SPH_C32(0x62623593), SPH_C32(0x9191da72), SPH_C32(0x9595c662),
94  	SPH_C32(0xe4e48abd), SPH_C32(0x797974ff), SPH_C32(0xe7e783b1),
95  	SPH_C32(0xc8c84e0d), SPH_C32(0x373785dc), SPH_C32(0x6d6d18af),
96  	SPH_C32(0x8d8d8e02), SPH_C32(0xd5d51d79), SPH_C32(0x4e4ef123),
97  	SPH_C32(0xa9a97292), SPH_C32(0x6c6c1fab), SPH_C32(0x5656b943),
98  	SPH_C32(0xf4f4fafd), SPH_C32(0xeaeaa085), SPH_C32(0x6565208f),
99  	SPH_C32(0x7a7a7df3), SPH_C32(0xaeae678e), SPH_C32(0x08083820),
100  	SPH_C32(0xbaba0bde), SPH_C32(0x787873fb), SPH_C32(0x2525fb94),
101  	SPH_C32(0x2e2ecab8), SPH_C32(0x1c1c5470), SPH_C32(0xa6a65fae),
102  	SPH_C32(0xb4b421e6), SPH_C32(0xc6c66435), SPH_C32(0xe8e8ae8d),
103  	SPH_C32(0xdddd2559), SPH_C32(0x747457cb), SPH_C32(0x1f1f5d7c),
104  	SPH_C32(0x4b4bea37), SPH_C32(0xbdbd1ec2), SPH_C32(0x8b8b9c1a),
105  	SPH_C32(0x8a8a9b1e), SPH_C32(0x70704bdb), SPH_C32(0x3e3ebaf8),
106  	SPH_C32(0xb5b526e2), SPH_C32(0x66662983), SPH_C32(0x4848e33b),
107  	SPH_C32(0x0303090c), SPH_C32(0xf6f6f4f5), SPH_C32(0x0e0e2a38),
108  	SPH_C32(0x61613c9f), SPH_C32(0x35358bd4), SPH_C32(0x5757be47),
109  	SPH_C32(0xb9b902d2), SPH_C32(0x8686bf2e), SPH_C32(0xc1c17129),
110  	SPH_C32(0x1d1d5374), SPH_C32(0x9e9ef74e), SPH_C32(0xe1e191a9),
111  	SPH_C32(0xf8f8decd), SPH_C32(0x9898e556), SPH_C32(0x11117744),
112  	SPH_C32(0x696904bf), SPH_C32(0xd9d93949), SPH_C32(0x8e8e870e),
113  	SPH_C32(0x9494c166), SPH_C32(0x9b9bec5a), SPH_C32(0x1e1e5a78),
114  	SPH_C32(0x8787b82a), SPH_C32(0xe9e9a989), SPH_C32(0xcece5c15),
115  	SPH_C32(0x5555b04f), SPH_C32(0x2828d8a0), SPH_C32(0xdfdf2b51),
116  	SPH_C32(0x8c8c8906), SPH_C32(0xa1a14ab2), SPH_C32(0x89899212),
117  	SPH_C32(0x0d0d2334), SPH_C32(0xbfbf10ca), SPH_C32(0xe6e684b5),
118  	SPH_C32(0x4242d513), SPH_C32(0x686803bb), SPH_C32(0x4141dc1f),
119  	SPH_C32(0x9999e252), SPH_C32(0x2d2dc3b4), SPH_C32(0x0f0f2d3c),
120  	SPH_C32(0xb0b03df6), SPH_C32(0x5454b74b), SPH_C32(0xbbbb0cda),
121  	SPH_C32(0x16166258)
122  };
123  static const sph_u32 mixtab1[] = {
124  	SPH_C32(0x97636332), SPH_C32(0xeb7c7c6f), SPH_C32(0xc777775e),
125  	SPH_C32(0xf77b7b7a), SPH_C32(0xe5f2f2e8), SPH_C32(0xb76b6b0a),
126  	SPH_C32(0xa76f6f16), SPH_C32(0x39c5c56d), SPH_C32(0xc0303090),
127  	SPH_C32(0x04010107), SPH_C32(0x8767672e), SPH_C32(0xac2b2bd1),
128  	SPH_C32(0xd5fefecc), SPH_C32(0x71d7d713), SPH_C32(0x9aabab7c),
129  	SPH_C32(0xc3767659), SPH_C32(0x05caca40), SPH_C32(0x3e8282a3),
130  	SPH_C32(0x09c9c949), SPH_C32(0xef7d7d68), SPH_C32(0xc5fafad0),
131  	SPH_C32(0x7f595994), SPH_C32(0x074747ce), SPH_C32(0xedf0f0e6),
132  	SPH_C32(0x82adad6e), SPH_C32(0x7dd4d41a), SPH_C32(0xbea2a243),
133  	SPH_C32(0x8aafaf60), SPH_C32(0x469c9cf9), SPH_C32(0xa6a4a451),
134  	SPH_C32(0xd3727245), SPH_C32(0x2dc0c076), SPH_C32(0xeab7b728),
135  	SPH_C32(0xd9fdfdc5), SPH_C32(0x7a9393d4), SPH_C32(0x982626f2),
136  	SPH_C32(0xd8363682), SPH_C32(0xfc3f3fbd), SPH_C32(0xf1f7f7f3),
137  	SPH_C32(0x1dcccc52), SPH_C32(0xd034348c), SPH_C32(0xa2a5a556),
138  	SPH_C32(0xb9e5e58d), SPH_C32(0xe9f1f1e1), SPH_C32(0xdf71714c),
139  	SPH_C32(0x4dd8d83e), SPH_C32(0xc4313197), SPH_C32(0x5415156b),
140  	SPH_C32(0x1004041c), SPH_C32(0x31c7c763), SPH_C32(0x8c2323e9),
141  	SPH_C32(0x21c3c37f), SPH_C32(0x60181848), SPH_C32(0x6e9696cf),
142  	SPH_C32(0x1405051b), SPH_C32(0x5e9a9aeb), SPH_C32(0x1c070715),
143  	SPH_C32(0x4812127e), SPH_C32(0x368080ad), SPH_C32(0xa5e2e298),
144  	SPH_C32(0x81ebeba7), SPH_C32(0x9c2727f5), SPH_C32(0xfeb2b233),
145  	SPH_C32(0xcf757550), SPH_C32(0x2409093f), SPH_C32(0x3a8383a4),
146  	SPH_C32(0xb02c2cc4), SPH_C32(0x681a1a46), SPH_C32(0x6c1b1b41),
147  	SPH_C32(0xa36e6e11), SPH_C32(0x735a5a9d), SPH_C32(0xb6a0a04d),
148  	SPH_C32(0x535252a5), SPH_C32(0xec3b3ba1), SPH_C32(0x75d6d614),
149  	SPH_C32(0xfab3b334), SPH_C32(0xa42929df), SPH_C32(0xa1e3e39f),
150  	SPH_C32(0xbc2f2fcd), SPH_C32(0x268484b1), SPH_C32(0x575353a2),
151  	SPH_C32(0x69d1d101), SPH_C32(0x00000000), SPH_C32(0x99ededb5),
152  	SPH_C32(0x802020e0), SPH_C32(0xddfcfcc2), SPH_C32(0xf2b1b13a),
153  	SPH_C32(0x775b5b9a), SPH_C32(0xb36a6a0d), SPH_C32(0x01cbcb47),
154  	SPH_C32(0xcebebe17), SPH_C32(0xe43939af), SPH_C32(0x334a4aed),
155  	SPH_C32(0x2b4c4cff), SPH_C32(0x7b585893), SPH_C32(0x11cfcf5b),
156  	SPH_C32(0x6dd0d006), SPH_C32(0x91efefbb), SPH_C32(0x9eaaaa7b),
157  	SPH_C32(0xc1fbfbd7), SPH_C32(0x174343d2), SPH_C32(0x2f4d4df8),
158  	SPH_C32(0xcc333399), SPH_C32(0x228585b6), SPH_C32(0x0f4545c0),
159  	SPH_C32(0xc9f9f9d9), SPH_C32(0x0802020e), SPH_C32(0xe77f7f66),
160  	SPH_C32(0x5b5050ab), SPH_C32(0xf03c3cb4), SPH_C32(0x4a9f9ff0),
161  	SPH_C32(0x96a8a875), SPH_C32(0x5f5151ac), SPH_C32(0xbaa3a344),
162  	SPH_C32(0x1b4040db), SPH_C32(0x0a8f8f80), SPH_C32(0x7e9292d3),
163  	SPH_C32(0x429d9dfe), SPH_C32(0xe03838a8), SPH_C32(0xf9f5f5fd),
164  	SPH_C32(0xc6bcbc19), SPH_C32(0xeeb6b62f), SPH_C32(0x45dada30),
165  	SPH_C32(0x842121e7), SPH_C32(0x40101070), SPH_C32(0xd1ffffcb),
166  	SPH_C32(0xe1f3f3ef), SPH_C32(0x65d2d208), SPH_C32(0x19cdcd55),
167  	SPH_C32(0x300c0c24), SPH_C32(0x4c131379), SPH_C32(0x9dececb2),
168  	SPH_C32(0x675f5f86), SPH_C32(0x6a9797c8), SPH_C32(0x0b4444c7),
169  	SPH_C32(0x5c171765), SPH_C32(0x3dc4c46a), SPH_C32(0xaaa7a758),
170  	SPH_C32(0xe37e7e61), SPH_C32(0xf43d3db3), SPH_C32(0x8b646427),
171  	SPH_C32(0x6f5d5d88), SPH_C32(0x6419194f), SPH_C32(0xd7737342),
172  	SPH_C32(0x9b60603b), SPH_C32(0x328181aa), SPH_C32(0x274f4ff6),
173  	SPH_C32(0x5ddcdc22), SPH_C32(0x882222ee), SPH_C32(0xa82a2ad6),
174  	SPH_C32(0x769090dd), SPH_C32(0x16888895), SPH_C32(0x034646c9),
175  	SPH_C32(0x95eeeebc), SPH_C32(0xd6b8b805), SPH_C32(0x5014146c),
176  	SPH_C32(0x55dede2c), SPH_C32(0x635e5e81), SPH_C32(0x2c0b0b31),
177  	SPH_C32(0x41dbdb37), SPH_C32(0xade0e096), SPH_C32(0xc832329e),
178  	SPH_C32(0xe83a3aa6), SPH_C32(0x280a0a36), SPH_C32(0x3f4949e4),
179  	SPH_C32(0x18060612), SPH_C32(0x902424fc), SPH_C32(0x6b5c5c8f),
180  	SPH_C32(0x25c2c278), SPH_C32(0x61d3d30f), SPH_C32(0x86acac69),
181  	SPH_C32(0x93626235), SPH_C32(0x729191da), SPH_C32(0x629595c6),
182  	SPH_C32(0xbde4e48a), SPH_C32(0xff797974), SPH_C32(0xb1e7e783),
183  	SPH_C32(0x0dc8c84e), SPH_C32(0xdc373785), SPH_C32(0xaf6d6d18),
184  	SPH_C32(0x028d8d8e), SPH_C32(0x79d5d51d), SPH_C32(0x234e4ef1),
185  	SPH_C32(0x92a9a972), SPH_C32(0xab6c6c1f), SPH_C32(0x435656b9),
186  	SPH_C32(0xfdf4f4fa), SPH_C32(0x85eaeaa0), SPH_C32(0x8f656520),
187  	SPH_C32(0xf37a7a7d), SPH_C32(0x8eaeae67), SPH_C32(0x20080838),
188  	SPH_C32(0xdebaba0b), SPH_C32(0xfb787873), SPH_C32(0x942525fb),
189  	SPH_C32(0xb82e2eca), SPH_C32(0x701c1c54), SPH_C32(0xaea6a65f),
190  	SPH_C32(0xe6b4b421), SPH_C32(0x35c6c664), SPH_C32(0x8de8e8ae),
191  	SPH_C32(0x59dddd25), SPH_C32(0xcb747457), SPH_C32(0x7c1f1f5d),
192  	SPH_C32(0x374b4bea), SPH_C32(0xc2bdbd1e), SPH_C32(0x1a8b8b9c),
193  	SPH_C32(0x1e8a8a9b), SPH_C32(0xdb70704b), SPH_C32(0xf83e3eba),
194  	SPH_C32(0xe2b5b526), SPH_C32(0x83666629), SPH_C32(0x3b4848e3),
195  	SPH_C32(0x0c030309), SPH_C32(0xf5f6f6f4), SPH_C32(0x380e0e2a),
196  	SPH_C32(0x9f61613c), SPH_C32(0xd435358b), SPH_C32(0x475757be),
197  	SPH_C32(0xd2b9b902), SPH_C32(0x2e8686bf), SPH_C32(0x29c1c171),
198  	SPH_C32(0x741d1d53), SPH_C32(0x4e9e9ef7), SPH_C32(0xa9e1e191),
199  	SPH_C32(0xcdf8f8de), SPH_C32(0x569898e5), SPH_C32(0x44111177),
200  	SPH_C32(0xbf696904), SPH_C32(0x49d9d939), SPH_C32(0x0e8e8e87),
201  	SPH_C32(0x669494c1), SPH_C32(0x5a9b9bec), SPH_C32(0x781e1e5a),
202  	SPH_C32(0x2a8787b8), SPH_C32(0x89e9e9a9), SPH_C32(0x15cece5c),
203  	SPH_C32(0x4f5555b0), SPH_C32(0xa02828d8), SPH_C32(0x51dfdf2b),
204  	SPH_C32(0x068c8c89), SPH_C32(0xb2a1a14a), SPH_C32(0x12898992),
205  	SPH_C32(0x340d0d23), SPH_C32(0xcabfbf10), SPH_C32(0xb5e6e684),
206  	SPH_C32(0x134242d5), SPH_C32(0xbb686803), SPH_C32(0x1f4141dc),
207  	SPH_C32(0x529999e2), SPH_C32(0xb42d2dc3), SPH_C32(0x3c0f0f2d),
208  	SPH_C32(0xf6b0b03d), SPH_C32(0x4b5454b7), SPH_C32(0xdabbbb0c),
209  	SPH_C32(0x58161662)
210  };
211  static const sph_u32 mixtab2[] = {
212  	SPH_C32(0x32976363), SPH_C32(0x6feb7c7c), SPH_C32(0x5ec77777),
213  	SPH_C32(0x7af77b7b), SPH_C32(0xe8e5f2f2), SPH_C32(0x0ab76b6b),
214  	SPH_C32(0x16a76f6f), SPH_C32(0x6d39c5c5), SPH_C32(0x90c03030),
215  	SPH_C32(0x07040101), SPH_C32(0x2e876767), SPH_C32(0xd1ac2b2b),
216  	SPH_C32(0xccd5fefe), SPH_C32(0x1371d7d7), SPH_C32(0x7c9aabab),
217  	SPH_C32(0x59c37676), SPH_C32(0x4005caca), SPH_C32(0xa33e8282),
218  	SPH_C32(0x4909c9c9), SPH_C32(0x68ef7d7d), SPH_C32(0xd0c5fafa),
219  	SPH_C32(0x947f5959), SPH_C32(0xce074747), SPH_C32(0xe6edf0f0),
220  	SPH_C32(0x6e82adad), SPH_C32(0x1a7dd4d4), SPH_C32(0x43bea2a2),
221  	SPH_C32(0x608aafaf), SPH_C32(0xf9469c9c), SPH_C32(0x51a6a4a4),
222  	SPH_C32(0x45d37272), SPH_C32(0x762dc0c0), SPH_C32(0x28eab7b7),
223  	SPH_C32(0xc5d9fdfd), SPH_C32(0xd47a9393), SPH_C32(0xf2982626),
224  	SPH_C32(0x82d83636), SPH_C32(0xbdfc3f3f), SPH_C32(0xf3f1f7f7),
225  	SPH_C32(0x521dcccc), SPH_C32(0x8cd03434), SPH_C32(0x56a2a5a5),
226  	SPH_C32(0x8db9e5e5), SPH_C32(0xe1e9f1f1), SPH_C32(0x4cdf7171),
227  	SPH_C32(0x3e4dd8d8), SPH_C32(0x97c43131), SPH_C32(0x6b541515),
228  	SPH_C32(0x1c100404), SPH_C32(0x6331c7c7), SPH_C32(0xe98c2323),
229  	SPH_C32(0x7f21c3c3), SPH_C32(0x48601818), SPH_C32(0xcf6e9696),
230  	SPH_C32(0x1b140505), SPH_C32(0xeb5e9a9a), SPH_C32(0x151c0707),
231  	SPH_C32(0x7e481212), SPH_C32(0xad368080), SPH_C32(0x98a5e2e2),
232  	SPH_C32(0xa781ebeb), SPH_C32(0xf59c2727), SPH_C32(0x33feb2b2),
233  	SPH_C32(0x50cf7575), SPH_C32(0x3f240909), SPH_C32(0xa43a8383),
234  	SPH_C32(0xc4b02c2c), SPH_C32(0x46681a1a), SPH_C32(0x416c1b1b),
235  	SPH_C32(0x11a36e6e), SPH_C32(0x9d735a5a), SPH_C32(0x4db6a0a0),
236  	SPH_C32(0xa5535252), SPH_C32(0xa1ec3b3b), SPH_C32(0x1475d6d6),
237  	SPH_C32(0x34fab3b3), SPH_C32(0xdfa42929), SPH_C32(0x9fa1e3e3),
238  	SPH_C32(0xcdbc2f2f), SPH_C32(0xb1268484), SPH_C32(0xa2575353),
239  	SPH_C32(0x0169d1d1), SPH_C32(0x00000000), SPH_C32(0xb599eded),
240  	SPH_C32(0xe0802020), SPH_C32(0xc2ddfcfc), SPH_C32(0x3af2b1b1),
241  	SPH_C32(0x9a775b5b), SPH_C32(0x0db36a6a), SPH_C32(0x4701cbcb),
242  	SPH_C32(0x17cebebe), SPH_C32(0xafe43939), SPH_C32(0xed334a4a),
243  	SPH_C32(0xff2b4c4c), SPH_C32(0x937b5858), SPH_C32(0x5b11cfcf),
244  	SPH_C32(0x066dd0d0), SPH_C32(0xbb91efef), SPH_C32(0x7b9eaaaa),
245  	SPH_C32(0xd7c1fbfb), SPH_C32(0xd2174343), SPH_C32(0xf82f4d4d),
246  	SPH_C32(0x99cc3333), SPH_C32(0xb6228585), SPH_C32(0xc00f4545),
247  	SPH_C32(0xd9c9f9f9), SPH_C32(0x0e080202), SPH_C32(0x66e77f7f),
248  	SPH_C32(0xab5b5050), SPH_C32(0xb4f03c3c), SPH_C32(0xf04a9f9f),
249  	SPH_C32(0x7596a8a8), SPH_C32(0xac5f5151), SPH_C32(0x44baa3a3),
250  	SPH_C32(0xdb1b4040), SPH_C32(0x800a8f8f), SPH_C32(0xd37e9292),
251  	SPH_C32(0xfe429d9d), SPH_C32(0xa8e03838), SPH_C32(0xfdf9f5f5),
252  	SPH_C32(0x19c6bcbc), SPH_C32(0x2feeb6b6), SPH_C32(0x3045dada),
253  	SPH_C32(0xe7842121), SPH_C32(0x70401010), SPH_C32(0xcbd1ffff),
254  	SPH_C32(0xefe1f3f3), SPH_C32(0x0865d2d2), SPH_C32(0x5519cdcd),
255  	SPH_C32(0x24300c0c), SPH_C32(0x794c1313), SPH_C32(0xb29decec),
256  	SPH_C32(0x86675f5f), SPH_C32(0xc86a9797), SPH_C32(0xc70b4444),
257  	SPH_C32(0x655c1717), SPH_C32(0x6a3dc4c4), SPH_C32(0x58aaa7a7),
258  	SPH_C32(0x61e37e7e), SPH_C32(0xb3f43d3d), SPH_C32(0x278b6464),
259  	SPH_C32(0x886f5d5d), SPH_C32(0x4f641919), SPH_C32(0x42d77373),
260  	SPH_C32(0x3b9b6060), SPH_C32(0xaa328181), SPH_C32(0xf6274f4f),
261  	SPH_C32(0x225ddcdc), SPH_C32(0xee882222), SPH_C32(0xd6a82a2a),
262  	SPH_C32(0xdd769090), SPH_C32(0x95168888), SPH_C32(0xc9034646),
263  	SPH_C32(0xbc95eeee), SPH_C32(0x05d6b8b8), SPH_C32(0x6c501414),
264  	SPH_C32(0x2c55dede), SPH_C32(0x81635e5e), SPH_C32(0x312c0b0b),
265  	SPH_C32(0x3741dbdb), SPH_C32(0x96ade0e0), SPH_C32(0x9ec83232),
266  	SPH_C32(0xa6e83a3a), SPH_C32(0x36280a0a), SPH_C32(0xe43f4949),
267  	SPH_C32(0x12180606), SPH_C32(0xfc902424), SPH_C32(0x8f6b5c5c),
268  	SPH_C32(0x7825c2c2), SPH_C32(0x0f61d3d3), SPH_C32(0x6986acac),
269  	SPH_C32(0x35936262), SPH_C32(0xda729191), SPH_C32(0xc6629595),
270  	SPH_C32(0x8abde4e4), SPH_C32(0x74ff7979), SPH_C32(0x83b1e7e7),
271  	SPH_C32(0x4e0dc8c8), SPH_C32(0x85dc3737), SPH_C32(0x18af6d6d),
272  	SPH_C32(0x8e028d8d), SPH_C32(0x1d79d5d5), SPH_C32(0xf1234e4e),
273  	SPH_C32(0x7292a9a9), SPH_C32(0x1fab6c6c), SPH_C32(0xb9435656),
274  	SPH_C32(0xfafdf4f4), SPH_C32(0xa085eaea), SPH_C32(0x208f6565),
275  	SPH_C32(0x7df37a7a), SPH_C32(0x678eaeae), SPH_C32(0x38200808),
276  	SPH_C32(0x0bdebaba), SPH_C32(0x73fb7878), SPH_C32(0xfb942525),
277  	SPH_C32(0xcab82e2e), SPH_C32(0x54701c1c), SPH_C32(0x5faea6a6),
278  	SPH_C32(0x21e6b4b4), SPH_C32(0x6435c6c6), SPH_C32(0xae8de8e8),
279  	SPH_C32(0x2559dddd), SPH_C32(0x57cb7474), SPH_C32(0x5d7c1f1f),
280  	SPH_C32(0xea374b4b), SPH_C32(0x1ec2bdbd), SPH_C32(0x9c1a8b8b),
281  	SPH_C32(0x9b1e8a8a), SPH_C32(0x4bdb7070), SPH_C32(0xbaf83e3e),
282  	SPH_C32(0x26e2b5b5), SPH_C32(0x29836666), SPH_C32(0xe33b4848),
283  	SPH_C32(0x090c0303), SPH_C32(0xf4f5f6f6), SPH_C32(0x2a380e0e),
284  	SPH_C32(0x3c9f6161), SPH_C32(0x8bd43535), SPH_C32(0xbe475757),
285  	SPH_C32(0x02d2b9b9), SPH_C32(0xbf2e8686), SPH_C32(0x7129c1c1),
286  	SPH_C32(0x53741d1d), SPH_C32(0xf74e9e9e), SPH_C32(0x91a9e1e1),
287  	SPH_C32(0xdecdf8f8), SPH_C32(0xe5569898), SPH_C32(0x77441111),
288  	SPH_C32(0x04bf6969), SPH_C32(0x3949d9d9), SPH_C32(0x870e8e8e),
289  	SPH_C32(0xc1669494), SPH_C32(0xec5a9b9b), SPH_C32(0x5a781e1e),
290  	SPH_C32(0xb82a8787), SPH_C32(0xa989e9e9), SPH_C32(0x5c15cece),
291  	SPH_C32(0xb04f5555), SPH_C32(0xd8a02828), SPH_C32(0x2b51dfdf),
292  	SPH_C32(0x89068c8c), SPH_C32(0x4ab2a1a1), SPH_C32(0x92128989),
293  	SPH_C32(0x23340d0d), SPH_C32(0x10cabfbf), SPH_C32(0x84b5e6e6),
294  	SPH_C32(0xd5134242), SPH_C32(0x03bb6868), SPH_C32(0xdc1f4141),
295  	SPH_C32(0xe2529999), SPH_C32(0xc3b42d2d), SPH_C32(0x2d3c0f0f),
296  	SPH_C32(0x3df6b0b0), SPH_C32(0xb74b5454), SPH_C32(0x0cdabbbb),
297  	SPH_C32(0x62581616)
298  };
299  static const sph_u32 mixtab3[] = {
300  	SPH_C32(0x63329763), SPH_C32(0x7c6feb7c), SPH_C32(0x775ec777),
301  	SPH_C32(0x7b7af77b), SPH_C32(0xf2e8e5f2), SPH_C32(0x6b0ab76b),
302  	SPH_C32(0x6f16a76f), SPH_C32(0xc56d39c5), SPH_C32(0x3090c030),
303  	SPH_C32(0x01070401), SPH_C32(0x672e8767), SPH_C32(0x2bd1ac2b),
304  	SPH_C32(0xfeccd5fe), SPH_C32(0xd71371d7), SPH_C32(0xab7c9aab),
305  	SPH_C32(0x7659c376), SPH_C32(0xca4005ca), SPH_C32(0x82a33e82),
306  	SPH_C32(0xc94909c9), SPH_C32(0x7d68ef7d), SPH_C32(0xfad0c5fa),
307  	SPH_C32(0x59947f59), SPH_C32(0x47ce0747), SPH_C32(0xf0e6edf0),
308  	SPH_C32(0xad6e82ad), SPH_C32(0xd41a7dd4), SPH_C32(0xa243bea2),
309  	SPH_C32(0xaf608aaf), SPH_C32(0x9cf9469c), SPH_C32(0xa451a6a4),
310  	SPH_C32(0x7245d372), SPH_C32(0xc0762dc0), SPH_C32(0xb728eab7),
311  	SPH_C32(0xfdc5d9fd), SPH_C32(0x93d47a93), SPH_C32(0x26f29826),
312  	SPH_C32(0x3682d836), SPH_C32(0x3fbdfc3f), SPH_C32(0xf7f3f1f7),
313  	SPH_C32(0xcc521dcc), SPH_C32(0x348cd034), SPH_C32(0xa556a2a5),
314  	SPH_C32(0xe58db9e5), SPH_C32(0xf1e1e9f1), SPH_C32(0x714cdf71),
315  	SPH_C32(0xd83e4dd8), SPH_C32(0x3197c431), SPH_C32(0x156b5415),
316  	SPH_C32(0x041c1004), SPH_C32(0xc76331c7), SPH_C32(0x23e98c23),
317  	SPH_C32(0xc37f21c3), SPH_C32(0x18486018), SPH_C32(0x96cf6e96),
318  	SPH_C32(0x051b1405), SPH_C32(0x9aeb5e9a), SPH_C32(0x07151c07),
319  	SPH_C32(0x127e4812), SPH_C32(0x80ad3680), SPH_C32(0xe298a5e2),
320  	SPH_C32(0xeba781eb), SPH_C32(0x27f59c27), SPH_C32(0xb233feb2),
321  	SPH_C32(0x7550cf75), SPH_C32(0x093f2409), SPH_C32(0x83a43a83),
322  	SPH_C32(0x2cc4b02c), SPH_C32(0x1a46681a), SPH_C32(0x1b416c1b),
323  	SPH_C32(0x6e11a36e), SPH_C32(0x5a9d735a), SPH_C32(0xa04db6a0),
324  	SPH_C32(0x52a55352), SPH_C32(0x3ba1ec3b), SPH_C32(0xd61475d6),
325  	SPH_C32(0xb334fab3), SPH_C32(0x29dfa429), SPH_C32(0xe39fa1e3),
326  	SPH_C32(0x2fcdbc2f), SPH_C32(0x84b12684), SPH_C32(0x53a25753),
327  	SPH_C32(0xd10169d1), SPH_C32(0x00000000), SPH_C32(0xedb599ed),
328  	SPH_C32(0x20e08020), SPH_C32(0xfcc2ddfc), SPH_C32(0xb13af2b1),
329  	SPH_C32(0x5b9a775b), SPH_C32(0x6a0db36a), SPH_C32(0xcb4701cb),
330  	SPH_C32(0xbe17cebe), SPH_C32(0x39afe439), SPH_C32(0x4aed334a),
331  	SPH_C32(0x4cff2b4c), SPH_C32(0x58937b58), SPH_C32(0xcf5b11cf),
332  	SPH_C32(0xd0066dd0), SPH_C32(0xefbb91ef), SPH_C32(0xaa7b9eaa),
333  	SPH_C32(0xfbd7c1fb), SPH_C32(0x43d21743), SPH_C32(0x4df82f4d),
334  	SPH_C32(0x3399cc33), SPH_C32(0x85b62285), SPH_C32(0x45c00f45),
335  	SPH_C32(0xf9d9c9f9), SPH_C32(0x020e0802), SPH_C32(0x7f66e77f),
336  	SPH_C32(0x50ab5b50), SPH_C32(0x3cb4f03c), SPH_C32(0x9ff04a9f),
337  	SPH_C32(0xa87596a8), SPH_C32(0x51ac5f51), SPH_C32(0xa344baa3),
338  	SPH_C32(0x40db1b40), SPH_C32(0x8f800a8f), SPH_C32(0x92d37e92),
339  	SPH_C32(0x9dfe429d), SPH_C32(0x38a8e038), SPH_C32(0xf5fdf9f5),
340  	SPH_C32(0xbc19c6bc), SPH_C32(0xb62feeb6), SPH_C32(0xda3045da),
341  	SPH_C32(0x21e78421), SPH_C32(0x10704010), SPH_C32(0xffcbd1ff),
342  	SPH_C32(0xf3efe1f3), SPH_C32(0xd20865d2), SPH_C32(0xcd5519cd),
343  	SPH_C32(0x0c24300c), SPH_C32(0x13794c13), SPH_C32(0xecb29dec),
344  	SPH_C32(0x5f86675f), SPH_C32(0x97c86a97), SPH_C32(0x44c70b44),
345  	SPH_C32(0x17655c17), SPH_C32(0xc46a3dc4), SPH_C32(0xa758aaa7),
346  	SPH_C32(0x7e61e37e), SPH_C32(0x3db3f43d), SPH_C32(0x64278b64),
347  	SPH_C32(0x5d886f5d), SPH_C32(0x194f6419), SPH_C32(0x7342d773),
348  	SPH_C32(0x603b9b60), SPH_C32(0x81aa3281), SPH_C32(0x4ff6274f),
349  	SPH_C32(0xdc225ddc), SPH_C32(0x22ee8822), SPH_C32(0x2ad6a82a),
350  	SPH_C32(0x90dd7690), SPH_C32(0x88951688), SPH_C32(0x46c90346),
351  	SPH_C32(0xeebc95ee), SPH_C32(0xb805d6b8), SPH_C32(0x146c5014),
352  	SPH_C32(0xde2c55de), SPH_C32(0x5e81635e), SPH_C32(0x0b312c0b),
353  	SPH_C32(0xdb3741db), SPH_C32(0xe096ade0), SPH_C32(0x329ec832),
354  	SPH_C32(0x3aa6e83a), SPH_C32(0x0a36280a), SPH_C32(0x49e43f49),
355  	SPH_C32(0x06121806), SPH_C32(0x24fc9024), SPH_C32(0x5c8f6b5c),
356  	SPH_C32(0xc27825c2), SPH_C32(0xd30f61d3), SPH_C32(0xac6986ac),
357  	SPH_C32(0x62359362), SPH_C32(0x91da7291), SPH_C32(0x95c66295),
358  	SPH_C32(0xe48abde4), SPH_C32(0x7974ff79), SPH_C32(0xe783b1e7),
359  	SPH_C32(0xc84e0dc8), SPH_C32(0x3785dc37), SPH_C32(0x6d18af6d),
360  	SPH_C32(0x8d8e028d), SPH_C32(0xd51d79d5), SPH_C32(0x4ef1234e),
361  	SPH_C32(0xa97292a9), SPH_C32(0x6c1fab6c), SPH_C32(0x56b94356),
362  	SPH_C32(0xf4fafdf4), SPH_C32(0xeaa085ea), SPH_C32(0x65208f65),
363  	SPH_C32(0x7a7df37a), SPH_C32(0xae678eae), SPH_C32(0x08382008),
364  	SPH_C32(0xba0bdeba), SPH_C32(0x7873fb78), SPH_C32(0x25fb9425),
365  	SPH_C32(0x2ecab82e), SPH_C32(0x1c54701c), SPH_C32(0xa65faea6),
366  	SPH_C32(0xb421e6b4), SPH_C32(0xc66435c6), SPH_C32(0xe8ae8de8),
367  	SPH_C32(0xdd2559dd), SPH_C32(0x7457cb74), SPH_C32(0x1f5d7c1f),
368  	SPH_C32(0x4bea374b), SPH_C32(0xbd1ec2bd), SPH_C32(0x8b9c1a8b),
369  	SPH_C32(0x8a9b1e8a), SPH_C32(0x704bdb70), SPH_C32(0x3ebaf83e),
370  	SPH_C32(0xb526e2b5), SPH_C32(0x66298366), SPH_C32(0x48e33b48),
371  	SPH_C32(0x03090c03), SPH_C32(0xf6f4f5f6), SPH_C32(0x0e2a380e),
372  	SPH_C32(0x613c9f61), SPH_C32(0x358bd435), SPH_C32(0x57be4757),
373  	SPH_C32(0xb902d2b9), SPH_C32(0x86bf2e86), SPH_C32(0xc17129c1),
374  	SPH_C32(0x1d53741d), SPH_C32(0x9ef74e9e), SPH_C32(0xe191a9e1),
375  	SPH_C32(0xf8decdf8), SPH_C32(0x98e55698), SPH_C32(0x11774411),
376  	SPH_C32(0x6904bf69), SPH_C32(0xd93949d9), SPH_C32(0x8e870e8e),
377  	SPH_C32(0x94c16694), SPH_C32(0x9bec5a9b), SPH_C32(0x1e5a781e),
378  	SPH_C32(0x87b82a87), SPH_C32(0xe9a989e9), SPH_C32(0xce5c15ce),
379  	SPH_C32(0x55b04f55), SPH_C32(0x28d8a028), SPH_C32(0xdf2b51df),
380  	SPH_C32(0x8c89068c), SPH_C32(0xa14ab2a1), SPH_C32(0x89921289),
381  	SPH_C32(0x0d23340d), SPH_C32(0xbf10cabf), SPH_C32(0xe684b5e6),
382  	SPH_C32(0x42d51342), SPH_C32(0x6803bb68), SPH_C32(0x41dc1f41),
383  	SPH_C32(0x99e25299), SPH_C32(0x2dc3b42d), SPH_C32(0x0f2d3c0f),
384  	SPH_C32(0xb03df6b0), SPH_C32(0x54b74b54), SPH_C32(0xbb0cdabb),
385  	SPH_C32(0x16625816)
386  };
387  #define TIX2(q, x00, x01, x08, x10, x24)   do { \
388  		x10 ^= x00; \
389  		x00 = (q); \
390  		x08 ^= x00; \
391  		x01 ^= x24; \
392  	} while (0)
393  #define TIX3(q, x00, x01, x04, x08, x16, x27, x30)   do { \
394  		x16 ^= x00; \
395  		x00 = (q); \
396  		x08 ^= x00; \
397  		x01 ^= x27; \
398  		x04 ^= x30; \
399  	} while (0)
400  #define TIX4(q, x00, x01, x04, x07, x08, x22, x24, x27, x30)   do { \
401  		x22 ^= x00; \
402  		x00 = (q); \
403  		x08 ^= x00; \
404  		x01 ^= x24; \
405  		x04 ^= x27; \
406  		x07 ^= x30; \
407  	} while (0)
408  #define CMIX30(x00, x01, x02, x04, x05, x06, x15, x16, x17)   do { \
409  		x00 ^= x04; \
410  		x01 ^= x05; \
411  		x02 ^= x06; \
412  		x15 ^= x04; \
413  		x16 ^= x05; \
414  		x17 ^= x06; \
415  	} while (0)
416  #define CMIX36(x00, x01, x02, x04, x05, x06, x18, x19, x20)   do { \
417  		x00 ^= x04; \
418  		x01 ^= x05; \
419  		x02 ^= x06; \
420  		x18 ^= x04; \
421  		x19 ^= x05; \
422  		x20 ^= x06; \
423  	} while (0)
424  #define SMIX(x0, x1, x2, x3)   do { \
425  		sph_u32 c0 = 0; \
426  		sph_u32 c1 = 0; \
427  		sph_u32 c2 = 0; \
428  		sph_u32 c3 = 0; \
429  		sph_u32 r0 = 0; \
430  		sph_u32 r1 = 0; \
431  		sph_u32 r2 = 0; \
432  		sph_u32 r3 = 0; \
433  		sph_u32 tmp; \
434  		tmp = mixtab0[x0 >> 24]; \
435  		c0 ^= tmp; \
436  		tmp = mixtab1[(x0 >> 16) & 0xFF]; \
437  		c0 ^= tmp; \
438  		r1 ^= tmp; \
439  		tmp = mixtab2[(x0 >>  8) & 0xFF]; \
440  		c0 ^= tmp; \
441  		r2 ^= tmp; \
442  		tmp = mixtab3[x0 & 0xFF]; \
443  		c0 ^= tmp; \
444  		r3 ^= tmp; \
445  		tmp = mixtab0[x1 >> 24]; \
446  		c1 ^= tmp; \
447  		r0 ^= tmp; \
448  		tmp = mixtab1[(x1 >> 16) & 0xFF]; \
449  		c1 ^= tmp; \
450  		tmp = mixtab2[(x1 >>  8) & 0xFF]; \
451  		c1 ^= tmp; \
452  		r2 ^= tmp; \
453  		tmp = mixtab3[x1 & 0xFF]; \
454  		c1 ^= tmp; \
455  		r3 ^= tmp; \
456  		tmp = mixtab0[x2 >> 24]; \
457  		c2 ^= tmp; \
458  		r0 ^= tmp; \
459  		tmp = mixtab1[(x2 >> 16) & 0xFF]; \
460  		c2 ^= tmp; \
461  		r1 ^= tmp; \
462  		tmp = mixtab2[(x2 >>  8) & 0xFF]; \
463  		c2 ^= tmp; \
464  		tmp = mixtab3[x2 & 0xFF]; \
465  		c2 ^= tmp; \
466  		r3 ^= tmp; \
467  		tmp = mixtab0[x3 >> 24]; \
468  		c3 ^= tmp; \
469  		r0 ^= tmp; \
470  		tmp = mixtab1[(x3 >> 16) & 0xFF]; \
471  		c3 ^= tmp; \
472  		r1 ^= tmp; \
473  		tmp = mixtab2[(x3 >>  8) & 0xFF]; \
474  		c3 ^= tmp; \
475  		r2 ^= tmp; \
476  		tmp = mixtab3[x3 & 0xFF]; \
477  		c3 ^= tmp; \
478  		x0 = ((c0 ^ r0) & SPH_C32(0xFF000000)) \
479  			| ((c1 ^ r1) & SPH_C32(0x00FF0000)) \
480  			| ((c2 ^ r2) & SPH_C32(0x0000FF00)) \
481  			| ((c3 ^ r3) & SPH_C32(0x000000FF)); \
482  		x1 = ((c1 ^ (r0 << 8)) & SPH_C32(0xFF000000)) \
483  			| ((c2 ^ (r1 << 8)) & SPH_C32(0x00FF0000)) \
484  			| ((c3 ^ (r2 << 8)) & SPH_C32(0x0000FF00)) \
485  			| ((c0 ^ (r3 >> 24)) & SPH_C32(0x000000FF)); \
486  		x2 = ((c2 ^ (r0 << 16)) & SPH_C32(0xFF000000)) \
487  			| ((c3 ^ (r1 << 16)) & SPH_C32(0x00FF0000)) \
488  			| ((c0 ^ (r2 >> 16)) & SPH_C32(0x0000FF00)) \
489  			| ((c1 ^ (r3 >> 16)) & SPH_C32(0x000000FF)); \
490  		x3 = ((c3 ^ (r0 << 24)) & SPH_C32(0xFF000000)) \
491  			| ((c0 ^ (r1 >> 8)) & SPH_C32(0x00FF0000)) \
492  			| ((c1 ^ (r2 >> 8)) & SPH_C32(0x0000FF00)) \
493  			| ((c2 ^ (r3 >> 8)) & SPH_C32(0x000000FF)); \
494  		 \
495  	} while (0)
496  #if SPH_FUGUE_NOCOPY
497  #define DECL_STATE_SMALL
498  #define READ_STATE_SMALL(state)
499  #define WRITE_STATE_SMALL(state)
500  #define DECL_STATE_BIG
501  #define READ_STATE_BIG(state)
502  #define WRITE_STATE_BIG(state)
503  #define S00   ((sc)->S[ 0])
504  #define S01   ((sc)->S[ 1])
505  #define S02   ((sc)->S[ 2])
506  #define S03   ((sc)->S[ 3])
507  #define S04   ((sc)->S[ 4])
508  #define S05   ((sc)->S[ 5])
509  #define S06   ((sc)->S[ 6])
510  #define S07   ((sc)->S[ 7])
511  #define S08   ((sc)->S[ 8])
512  #define S09   ((sc)->S[ 9])
513  #define S10   ((sc)->S[10])
514  #define S11   ((sc)->S[11])
515  #define S12   ((sc)->S[12])
516  #define S13   ((sc)->S[13])
517  #define S14   ((sc)->S[14])
518  #define S15   ((sc)->S[15])
519  #define S16   ((sc)->S[16])
520  #define S17   ((sc)->S[17])
521  #define S18   ((sc)->S[18])
522  #define S19   ((sc)->S[19])
523  #define S20   ((sc)->S[20])
524  #define S21   ((sc)->S[21])
525  #define S22   ((sc)->S[22])
526  #define S23   ((sc)->S[23])
527  #define S24   ((sc)->S[24])
528  #define S25   ((sc)->S[25])
529  #define S26   ((sc)->S[26])
530  #define S27   ((sc)->S[27])
531  #define S28   ((sc)->S[28])
532  #define S29   ((sc)->S[29])
533  #define S30   ((sc)->S[30])
534  #define S31   ((sc)->S[31])
535  #define S32   ((sc)->S[32])
536  #define S33   ((sc)->S[33])
537  #define S34   ((sc)->S[34])
538  #define S35   ((sc)->S[35])
539  #else
540  #define DECL_STATE_SMALL \
541  	sph_u32 S00, S01, S02, S03, S04, S05, S06, S07, S08, S09; \
542  	sph_u32 S10, S11, S12, S13, S14, S15, S16, S17, S18, S19; \
543  	sph_u32 S20, S21, S22, S23, S24, S25, S26, S27, S28, S29;
544  #define DECL_STATE_BIG \
545  	DECL_STATE_SMALL \
546  	sph_u32 S30, S31, S32, S33, S34, S35;
547  #define READ_STATE_SMALL(state)   do { \
548  		S00 = (state)->S[ 0]; \
549  		S01 = (state)->S[ 1]; \
550  		S02 = (state)->S[ 2]; \
551  		S03 = (state)->S[ 3]; \
552  		S04 = (state)->S[ 4]; \
553  		S05 = (state)->S[ 5]; \
554  		S06 = (state)->S[ 6]; \
555  		S07 = (state)->S[ 7]; \
556  		S08 = (state)->S[ 8]; \
557  		S09 = (state)->S[ 9]; \
558  		S10 = (state)->S[10]; \
559  		S11 = (state)->S[11]; \
560  		S12 = (state)->S[12]; \
561  		S13 = (state)->S[13]; \
562  		S14 = (state)->S[14]; \
563  		S15 = (state)->S[15]; \
564  		S16 = (state)->S[16]; \
565  		S17 = (state)->S[17]; \
566  		S18 = (state)->S[18]; \
567  		S19 = (state)->S[19]; \
568  		S20 = (state)->S[20]; \
569  		S21 = (state)->S[21]; \
570  		S22 = (state)->S[22]; \
571  		S23 = (state)->S[23]; \
572  		S24 = (state)->S[24]; \
573  		S25 = (state)->S[25]; \
574  		S26 = (state)->S[26]; \
575  		S27 = (state)->S[27]; \
576  		S28 = (state)->S[28]; \
577  		S29 = (state)->S[29]; \
578  	} while (0)
579  #define READ_STATE_BIG(state)   do { \
580  		READ_STATE_SMALL(state); \
581  		S30 = (state)->S[30]; \
582  		S31 = (state)->S[31]; \
583  		S32 = (state)->S[32]; \
584  		S33 = (state)->S[33]; \
585  		S34 = (state)->S[34]; \
586  		S35 = (state)->S[35]; \
587  	} while (0)
588  #define WRITE_STATE_SMALL(state)   do { \
589  		(state)->S[ 0] = S00; \
590  		(state)->S[ 1] = S01; \
591  		(state)->S[ 2] = S02; \
592  		(state)->S[ 3] = S03; \
593  		(state)->S[ 4] = S04; \
594  		(state)->S[ 5] = S05; \
595  		(state)->S[ 6] = S06; \
596  		(state)->S[ 7] = S07; \
597  		(state)->S[ 8] = S08; \
598  		(state)->S[ 9] = S09; \
599  		(state)->S[10] = S10; \
600  		(state)->S[11] = S11; \
601  		(state)->S[12] = S12; \
602  		(state)->S[13] = S13; \
603  		(state)->S[14] = S14; \
604  		(state)->S[15] = S15; \
605  		(state)->S[16] = S16; \
606  		(state)->S[17] = S17; \
607  		(state)->S[18] = S18; \
608  		(state)->S[19] = S19; \
609  		(state)->S[20] = S20; \
610  		(state)->S[21] = S21; \
611  		(state)->S[22] = S22; \
612  		(state)->S[23] = S23; \
613  		(state)->S[24] = S24; \
614  		(state)->S[25] = S25; \
615  		(state)->S[26] = S26; \
616  		(state)->S[27] = S27; \
617  		(state)->S[28] = S28; \
618  		(state)->S[29] = S29; \
619  	} while (0)
620  #define WRITE_STATE_BIG(state)   do { \
621  		WRITE_STATE_SMALL(state); \
622  		(state)->S[30] = S30; \
623  		(state)->S[31] = S31; \
624  		(state)->S[32] = S32; \
625  		(state)->S[33] = S33; \
626  		(state)->S[34] = S34; \
627  		(state)->S[35] = S35; \
628  	} while (0)
629  #endif
630  static void
631  fugue_init(sph_fugue_context *sc, size_t z_len,
632  	const sph_u32 *iv, size_t iv_len)
633  {
634  	size_t u;
635  	for (u = 0; u < z_len; u ++)
636  		sc->S[u] = 0;
637  	memcpy(&sc->S[z_len], iv, iv_len * sizeof *iv);
638  	sc->partial = 0;
639  	sc->partial_len = 0;
640  	sc->round_shift = 0;
641  #if SPH_64
642  	sc->bit_count = 0;
643  #else
<span onclick='openModal()' class='match'>644  	sc->bit_count_high = 0;
645  	sc->bit_count_low = 0;
646  #endif
647  }
648  #if SPH_64
</span>649  #define INCR_COUNTER   do { \
650  		sc->bit_count += (sph_u64)len << 3; \
651  	} while (0)
652  #else
653  #define INCR_COUNTER   do { \
654  		sph_u32 tmp = SPH_T32((sph_u32)len << 3); \
655  		sc->bit_count_low = SPH_T32(sc->bit_count_low + tmp); \
656  		if (sc->bit_count_low < tmp) \
657  			sc->bit_count_high ++; \
658  		sc->bit_count_high = SPH_T32(sc->bit_count_high \
659  			+ ((sph_u32)len >> 29)); \
660  	} while (0)
661  #endif
662  #define CORE_ENTRY \
663  	sph_u32 p; \
664  	unsigned plen, rshift; \
665  	INCR_COUNTER; \
666  	p = sc->partial; \
667  	plen = sc->partial_len; \
668  	if (plen < 4) { \
669  		unsigned count = 4 - plen; \
670  		if (len < count) \
671  			count = len; \
672  		plen += count; \
673  		while (count -- > 0) { \
674  			p = (p << 8) | *(const unsigned char *)data; \
675  			data = (const unsigned char *)data + 1; \
676  			len --; \
677  		} \
678  		if (len == 0) { \
679  			sc->partial = p; \
680  			sc->partial_len = plen; \
681  			return; \
682  		} \
683  	}
684  #define CORE_EXIT \
685  	p = 0; \
686  	sc->partial_len = (unsigned)len; \
687  	while (len -- > 0) { \
688  		p = (p << 8) | *(const unsigned char *)data; \
689  		data = (const unsigned char *)data + 1; \
690  	} \
691  	sc->partial = p; \
692  	sc->round_shift = rshift;
693  #define NEXT(rc) \
694  	if (len <= 4) { \
695  		rshift = (rc); \
696  		break; \
697  	} \
698  	p = sph_dec32be(data); \
699  	data = (const unsigned char *)data + 4; \
700  	len -= 4
701  static void
702  fugue2_core(sph_fugue_context *sc, const void *data, size_t len)
703  {
704  	DECL_STATE_SMALL
705  	CORE_ENTRY
706  	READ_STATE_SMALL(sc);
707  	rshift = sc->round_shift;
708  	switch (rshift) {
709  		for (;;) {
710  			sph_u32 q;
711  		case 0:
712  			q = p;
713  			TIX2(q, S00, S01, S08, S10, S24);
714  			CMIX30(S27, S28, S29, S01, S02, S03, S12, S13, S14);
715  			SMIX(S27, S28, S29, S00);
716  			CMIX30(S24, S25, S26, S28, S29, S00, S09, S10, S11);
717  			SMIX(S24, S25, S26, S27);
718  			NEXT(1);
719  		case 1:
720  			q = p;
721  			TIX2(q, S24, S25, S02, S04, S18);
722  			CMIX30(S21, S22, S23, S25, S26, S27, S06, S07, S08);
723  			SMIX(S21, S22, S23, S24);
724  			CMIX30(S18, S19, S20, S22, S23, S24, S03, S04, S05);
725  			SMIX(S18, S19, S20, S21);
726  			NEXT(2);
727  		case 2:
728  			q = p;
729  			TIX2(q, S18, S19, S26, S28, S12);
730  			CMIX30(S15, S16, S17, S19, S20, S21, S00, S01, S02);
731  			SMIX(S15, S16, S17, S18);
732  			CMIX30(S12, S13, S14, S16, S17, S18, S27, S28, S29);
733  			SMIX(S12, S13, S14, S15);
734  			NEXT(3);
735  		case 3:
736  			q = p;
737  			TIX2(q, S12, S13, S20, S22, S06);
738  			CMIX30(S09, S10, S11, S13, S14, S15, S24, S25, S26);
739  			SMIX(S09, S10, S11, S12);
740  			CMIX30(S06, S07, S08, S10, S11, S12, S21, S22, S23);
741  			SMIX(S06, S07, S08, S09);
742  			NEXT(4);
743  		case 4:
744  			q = p;
745  			TIX2(q, S06, S07, S14, S16, S00);
746  			CMIX30(S03, S04, S05, S07, S08, S09, S18, S19, S20);
747  			SMIX(S03, S04, S05, S06);
748  			CMIX30(S00, S01, S02, S04, S05, S06, S15, S16, S17);
749  			SMIX(S00, S01, S02, S03);
750  			NEXT(0);
751  		}
752  	}
753  	CORE_EXIT
754  	WRITE_STATE_SMALL(sc);
755  }
756  static void
757  fugue3_core(sph_fugue_context *sc, const void *data, size_t len)
758  {
759  	DECL_STATE_BIG
760  	CORE_ENTRY
761  	READ_STATE_BIG(sc);
762  	rshift = sc->round_shift;
763  	switch (rshift) {
764  		for (;;) {
765  			sph_u32 q;
766  		case 0:
767  			q = p;
768  			TIX3(q, S00, S01, S04, S08, S16, S27, S30);
769  			CMIX36(S33, S34, S35, S01, S02, S03, S15, S16, S17);
770  			SMIX(S33, S34, S35, S00);
771  			CMIX36(S30, S31, S32, S34, S35, S00, S12, S13, S14);
772  			SMIX(S30, S31, S32, S33);
773  			CMIX36(S27, S28, S29, S31, S32, S33, S09, S10, S11);
774  			SMIX(S27, S28, S29, S30);
775  			NEXT(1);
776  		case 1:
777  			q = p;
778  			TIX3(q, S27, S28, S31, S35, S07, S18, S21);
779  			CMIX36(S24, S25, S26, S28, S29, S30, S06, S07, S08);
780  			SMIX(S24, S25, S26, S27);
781  			CMIX36(S21, S22, S23, S25, S26, S27, S03, S04, S05);
782  			SMIX(S21, S22, S23, S24);
783  			CMIX36(S18, S19, S20, S22, S23, S24, S00, S01, S02);
784  			SMIX(S18, S19, S20, S21);
785  			NEXT(2);
786  		case 2:
787  			q = p;
788  			TIX3(q, S18, S19, S22, S26, S34, S09, S12);
789  			CMIX36(S15, S16, S17, S19, S20, S21, S33, S34, S35);
790  			SMIX(S15, S16, S17, S18);
791  			CMIX36(S12, S13, S14, S16, S17, S18, S30, S31, S32);
792  			SMIX(S12, S13, S14, S15);
793  			CMIX36(S09, S10, S11, S13, S14, S15, S27, S28, S29);
794  			SMIX(S09, S10, S11, S12);
795  			NEXT(3);
796  		case 3:
797  			q = p;
798  			TIX3(q, S09, S10, S13, S17, S25, S00, S03);
799  			CMIX36(S06, S07, S08, S10, S11, S12, S24, S25, S26);
800  			SMIX(S06, S07, S08, S09);
801  			CMIX36(S03, S04, S05, S07, S08, S09, S21, S22, S23);
802  			SMIX(S03, S04, S05, S06);
803  			CMIX36(S00, S01, S02, S04, S05, S06, S18, S19, S20);
804  			SMIX(S00, S01, S02, S03);
805  			NEXT(0);
806  		}
807  	}
808  	CORE_EXIT
809  	WRITE_STATE_BIG(sc);
810  }
811  static void
812  fugue4_core(sph_fugue_context *sc, const void *data, size_t len)
813  {
814  	DECL_STATE_BIG
815  	CORE_ENTRY
816  	READ_STATE_BIG(sc);
817  	rshift = sc->round_shift;
818  	switch (rshift) {
819  		for (;;) {
820  			sph_u32 q;
821  		case 0:
822  			q = p;
823  			TIX4(q, S00, S01, S04, S07, S08, S22, S24, S27, S30);
824  			CMIX36(S33, S34, S35, S01, S02, S03, S15, S16, S17);
825  			SMIX(S33, S34, S35, S00);
826  			CMIX36(S30, S31, S32, S34, S35, S00, S12, S13, S14);
827  			SMIX(S30, S31, S32, S33);
828  			CMIX36(S27, S28, S29, S31, S32, S33, S09, S10, S11);
829  			SMIX(S27, S28, S29, S30);
830  			CMIX36(S24, S25, S26, S28, S29, S30, S06, S07, S08);
831  			SMIX(S24, S25, S26, S27);
832  			NEXT(1);
833  		case 1:
834  			q = p;
835  			TIX4(q, S24, S25, S28, S31, S32, S10, S12, S15, S18);
836  			CMIX36(S21, S22, S23, S25, S26, S27, S03, S04, S05);
837  			SMIX(S21, S22, S23, S24);
838  			CMIX36(S18, S19, S20, S22, S23, S24, S00, S01, S02);
839  			SMIX(S18, S19, S20, S21);
840  			CMIX36(S15, S16, S17, S19, S20, S21, S33, S34, S35);
841  			SMIX(S15, S16, S17, S18);
842  			CMIX36(S12, S13, S14, S16, S17, S18, S30, S31, S32);
843  			SMIX(S12, S13, S14, S15);
844  			NEXT(2);
845  		case 2:
846  			q = p;
847  			TIX4(q, S12, S13, S16, S19, S20, S34, S00, S03, S06);
848  			CMIX36(S09, S10, S11, S13, S14, S15, S27, S28, S29);
849  			SMIX(S09, S10, S11, S12);
850  			CMIX36(S06, S07, S08, S10, S11, S12, S24, S25, S26);
851  			SMIX(S06, S07, S08, S09);
852  			CMIX36(S03, S04, S05, S07, S08, S09, S21, S22, S23);
853  			SMIX(S03, S04, S05, S06);
854  			CMIX36(S00, S01, S02, S04, S05, S06, S18, S19, S20);
855  			SMIX(S00, S01, S02, S03);
856  			NEXT(0);
857  		}
858  	}
859  	CORE_EXIT
860  	WRITE_STATE_BIG(sc);
861  }
862  #if SPH_64
863  #define WRITE_COUNTER   do { \
864  		sph_enc64be(buf + 4, sc->bit_count + n); \
865  	} while (0)
866  #else
867  #define WRITE_COUNTER   do { \
868  		sph_enc32be(buf + 4, sc->bit_count_high); \
869  		sph_enc32be(buf + 8, sc->bit_count_low + n); \
870  	} while (0)
871  #endif
872  #define CLOSE_ENTRY(s, rcm, core) \
873  	unsigned char buf[16]; \
874  	unsigned plen, rms; \
875  	unsigned char *out; \
876  	sph_u32 S[s]; \
877  	plen = sc->partial_len; \
878  	WRITE_COUNTER; \
879  	if (plen == 0 && n == 0) { \
880  		plen = 4; \
881  	} else if (plen < 4 || n != 0) { \
882  		unsigned u; \
883   \
884  		if (plen == 4) \
885  			plen = 0; \
886  		buf[plen] = ub & ~(0xFFU >> n); \
887  		for (u = plen + 1; u < 4; u ++) \
888  			buf[u] = 0; \
889  	} \
890  	core(sc, buf + plen, (sizeof buf) - plen); \
891  	rms = sc->round_shift * (rcm); \
892  	memcpy(S, sc->S + (s) - rms, rms * sizeof(sph_u32)); \
893  	memcpy(S + rms, sc->S, ((s) - rms) * sizeof(sph_u32));
894  #define ROR(n, s)   do { \
895  		sph_u32 tmp[n]; \
896  		memcpy(tmp, S + ((s) - (n)), (n) * sizeof(sph_u32)); \
897  		memmove(S + (n), S, ((s) - (n)) * sizeof(sph_u32)); \
898  		memcpy(S, tmp, (n) * sizeof(sph_u32)); \
899  	} while (0)
900  static void
901  fugue2_close(sph_fugue_context *sc, unsigned ub, unsigned n,
902  	void *dst, size_t out_size_w32)
903  {
904  	int i;
905  	CLOSE_ENTRY(30, 6, fugue2_core)
906  	for (i = 0; i < 10; i ++) {
907  		ROR(3, 30);
908  		CMIX30(S[0], S[1], S[2], S[4], S[5], S[6], S[15], S[16], S[17]);
909  		SMIX(S[0], S[1], S[2], S[3]);
910  	}
911  	for (i = 0; i < 13; i ++) {
912  		S[4] ^= S[0];
913  		S[15] ^= S[0];
914  		ROR(15, 30);
915  		SMIX(S[0], S[1], S[2], S[3]);
916  		S[4] ^= S[0];
917  		S[16] ^= S[0];
918  		ROR(14, 30);
919  		SMIX(S[0], S[1], S[2], S[3]);
920  	}
921  	S[4] ^= S[0];
922  	S[15] ^= S[0];
923  	out = dst;
924  	sph_enc32be(out +  0, S[ 1]);
925  	sph_enc32be(out +  4, S[ 2]);
926  	sph_enc32be(out +  8, S[ 3]);
927  	sph_enc32be(out + 12, S[ 4]);
928  	sph_enc32be(out + 16, S[15]);
929  	sph_enc32be(out + 20, S[16]);
930  	sph_enc32be(out + 24, S[17]);
931  	if (out_size_w32 == 8) {
932  		sph_enc32be(out + 28, S[18]);
933  		sph_fugue256_init(sc);
934  	} else {
935  		sph_fugue224_init(sc);
936  	}
937  }
938  static void
939  fugue3_close(sph_fugue_context *sc, unsigned ub, unsigned n, void *dst)
940  {
941  	int i;
942  	CLOSE_ENTRY(36, 9, fugue3_core)
943  	for (i = 0; i < 18; i ++) {
944  		ROR(3, 36);
945  		CMIX36(S[0], S[1], S[2], S[4], S[5], S[6], S[18], S[19], S[20]);
946  		SMIX(S[0], S[1], S[2], S[3]);
947  	}
948  	for (i = 0; i < 13; i ++) {
949  		S[4] ^= S[0];
950  		S[12] ^= S[0];
951  		S[24] ^= S[0];
952  		ROR(12, 36);
953  		SMIX(S[0], S[1], S[2], S[3]);
954  		S[4] ^= S[0];
955  		S[13] ^= S[0];
956  		S[24] ^= S[0];
957  		ROR(12, 36);
958  		SMIX(S[0], S[1], S[2], S[3]);
959  		S[4] ^= S[0];
960  		S[13] ^= S[0];
961  		S[25] ^= S[0];
962  		ROR(11, 36);
963  		SMIX(S[0], S[1], S[2], S[3]);
964  	}
965  	S[4] ^= S[0];
966  	S[12] ^= S[0];
967  	S[24] ^= S[0];
968  	out = dst;
969  	sph_enc32be(out +  0, S[ 1]);
970  	sph_enc32be(out +  4, S[ 2]);
971  	sph_enc32be(out +  8, S[ 3]);
972  	sph_enc32be(out + 12, S[ 4]);
973  	sph_enc32be(out + 16, S[12]);
974  	sph_enc32be(out + 20, S[13]);
975  	sph_enc32be(out + 24, S[14]);
976  	sph_enc32be(out + 28, S[15]);
977  	sph_enc32be(out + 32, S[24]);
978  	sph_enc32be(out + 36, S[25]);
979  	sph_enc32be(out + 40, S[26]);
980  	sph_enc32be(out + 44, S[27]);
981  	sph_fugue384_init(sc);
982  }
983  static void
984  fugue4_close(sph_fugue_context *sc, unsigned ub, unsigned n, void *dst)
985  {
986  	int i;
987  	CLOSE_ENTRY(36, 12, fugue4_core)
988  	for (i = 0; i < 32; i ++) {
989  		ROR(3, 36);
990  		CMIX36(S[0], S[1], S[2], S[4], S[5], S[6], S[18], S[19], S[20]);
991  		SMIX(S[0], S[1], S[2], S[3]);
992  	}
993  	for (i = 0; i < 13; i ++) {
994  		S[4] ^= S[0];
995  		S[9] ^= S[0];
996  		S[18] ^= S[0];
997  		S[27] ^= S[0];
998  		ROR(9, 36);
999  		SMIX(S[0], S[1], S[2], S[3]);
1000  		S[4] ^= S[0];
1001  		S[10] ^= S[0];
1002  		S[18] ^= S[0];
1003  		S[27] ^= S[0];
1004  		ROR(9, 36);
1005  		SMIX(S[0], S[1], S[2], S[3]);
1006  		S[4] ^= S[0];
1007  		S[10] ^= S[0];
1008  		S[19] ^= S[0];
1009  		S[27] ^= S[0];
1010  		ROR(9, 36);
1011  		SMIX(S[0], S[1], S[2], S[3]);
1012  		S[4] ^= S[0];
1013  		S[10] ^= S[0];
1014  		S[19] ^= S[0];
1015  		S[28] ^= S[0];
1016  		ROR(8, 36);
1017  		SMIX(S[0], S[1], S[2], S[3]);
1018  	}
1019  	S[4] ^= S[0];
1020  	S[9] ^= S[0];
1021  	S[18] ^= S[0];
1022  	S[27] ^= S[0];
1023  	out = dst;
1024  	sph_enc32be(out +  0, S[ 1]);
1025  	sph_enc32be(out +  4, S[ 2]);
1026  	sph_enc32be(out +  8, S[ 3]);
1027  	sph_enc32be(out + 12, S[ 4]);
1028  	sph_enc32be(out + 16, S[ 9]);
1029  	sph_enc32be(out + 20, S[10]);
1030  	sph_enc32be(out + 24, S[11]);
1031  	sph_enc32be(out + 28, S[12]);
1032  	sph_enc32be(out + 32, S[18]);
1033  	sph_enc32be(out + 36, S[19]);
1034  	sph_enc32be(out + 40, S[20]);
1035  	sph_enc32be(out + 44, S[21]);
1036  	sph_enc32be(out + 48, S[27]);
1037  	sph_enc32be(out + 52, S[28]);
1038  	sph_enc32be(out + 56, S[29]);
1039  	sph_enc32be(out + 60, S[30]);
1040  }
1041  void
1042  sph_fugue224_init(void *cc)
1043  {
1044  	fugue_init(cc, 23, IV224, 7);
1045  }
1046  void
1047  sph_fugue224(void *cc, const void *data, size_t len)
1048  {
1049  	fugue2_core(cc, data, len);
1050  }
1051  void
1052  sph_fugue224_close(void *cc, void *dst)
1053  {
1054  	fugue2_close(cc, 0, 0, dst, 7);
1055  }
1056  void
1057  sph_fugue224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1058  {
1059  	fugue2_close(cc, ub, n, dst, 7);
1060  }
1061  void
1062  sph_fugue256_init(void *cc)
1063  {
1064  	fugue_init(cc, 22, IV256, 8);
1065  }
1066  void
1067  sph_fugue256(void *cc, const void *data, size_t len)
1068  {
1069  	fugue2_core(cc, data, len);
1070  }
1071  void
1072  sph_fugue256_close(void *cc, void *dst)
1073  {
1074  	fugue2_close(cc, 0, 0, dst, 8);
1075  }
1076  void
1077  sph_fugue256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1078  {
1079  	fugue2_close(cc, ub, n, dst, 8);
1080  }
1081  void
1082  sph_fugue384_init(void *cc)
1083  {
1084  	fugue_init(cc, 24, IV384, 12);
1085  }
1086  void
1087  sph_fugue384(void *cc, const void *data, size_t len)
1088  {
1089  	fugue3_core(cc, data, len);
1090  }
1091  void
1092  sph_fugue384_close(void *cc, void *dst)
1093  {
1094  	fugue3_close(cc, 0, 0, dst);
1095  }
1096  void
1097  sph_fugue384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1098  {
1099  	fugue3_close(cc, ub, n, dst);
1100  }
1101  void
1102  sph_fugue512_init(void *cc)
1103  {
1104  	fugue_init(cc, 20, IV512, 16);
1105  }
1106  void
1107  sph_fugue512(void *cc, const void *data, size_t len)
1108  {
1109  	fugue4_core(cc, data, len);
1110  }
1111  void
1112  sph_fugue512_close(void *cc, void *dst)
1113  {
1114  	fugue4_close(cc, 0, 0, dst);
1115  }
1116  void
1117  sph_fugue512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
1118  {
1119  	fugue4_close(cc, ub, n, dst);
1120  }
1121  #ifdef __cplusplus
1122  }
1123  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_jh.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_fugue.c</div>
                </div>
                <div class="column column_space"><pre><code>756    sc->block_count_high = 0;
757    sc->block_count_low = 0;
758  #endif
759  }
760  static void jh_core(sph_jh_context *sc, const void *data, size_t len) {
</pre></code></div>
                <div class="column column_space"><pre><code>644  	sc->bit_count_high = 0;
645  	sc->bit_count_low = 0;
646  #endif
647  }
648  #if SPH_64
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    