<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imklog.c &amp; immark.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imklog.c &amp; immark.c
      </h3>
<h1 align="center">
        31.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imklog.c (24.107143%)<th>immark.c (45.251396%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(103-117)<td><a href="#" name="0">(79-93)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(356-375)<td><a href="#" name="1">(147-166)</a><td align="center"><font color="#f30000">22</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(390-413)<td><a href="#" name="2">(173-194)</a><td align="center"><font color="#c70000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(377-383)<td><a href="#" name="3">(166-172)</a><td align="center"><font color="#c70000">18</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imklog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdarg.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;sys/socket.h&gt;
10 #include "dirty.h"
11 #include "cfsysline.h"
12 #include "parserif.h"
13 #include "obj.h"
14 #include "msg.h"
15 #include "module-template.h"
16 #include "datetime.h"
17 #include "imklog.h"
18 #include "net.h"
19 #include "glbl.h"
20 #include "prop.h"
21 #include "errmsg.h"
22 #include "unicode-helper.h"
23 #include "ruleset.h"
24 MODULE_TYPE_INPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("imklog")
27 DEF_IMOD_STATIC_DATA
28 DEFobjCurrIf(datetime)
29 DEFobjCurrIf(ruleset)
30 DEFobjCurrIf(glbl)
31 DEFobjCurrIf(prop)
32 DEFobjCurrIf(net)
33 typedef struct configSettings_s {
34 	int bPermitNonKernel; 	int bParseKernelStamp; 	int bKeepKernelStamp; 	int iFacilIntMsg; 	uchar *pszPath;
35 	int console_log_level; 	unsigned int ratelimitInterval;
36 	unsigned int ratelimitBurst;
37 } configSettings_t;
38 static configSettings_t cs;
39 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static int bLegacyCnfModGlobalsPermitted;
40 static struct cnfparamdescr modpdescr[] = {
41 	{ "ruleset", eCmdHdlrString, 0 },
42 <a name="0"></a>	{ "logpath", eCmdHdlrGetWord, 0 },
43 	{ "permitnonkernelfacility", eCmdHdlrBinary, 0 },
44 	{ "consoleloglevel", eCmdHdlrInt, 0 },
45 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "parsekerneltimestamp", eCmdHdlrBinary, 0 },
46 	{ "keepkerneltimestamp", eCmdHdlrBinary, 0 },
47 	{ "internalmsgfacility", eCmdHdlrFacility, 0 },
48 	{ "ratelimitinterval", eCmdHdlrInt, 0 },
49 	{ "ratelimitburst", eCmdHdlrInt, 0 }
50 };
51 static struct cnfparamblk modpblk =
52 	{ CNFPARAMBLK_VERSION,
53 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
54 	  modpdescr
55 	};
56 static prop_t *pInputName = NULL;
57 static prop_t *pLocalHostIP = NULL;</b></font>
58 static inline void std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf);
59 static inline rsRetVal
60 std_mod_checkRuleset(modConfData_t *const modConf)
61 {
62 	ruleset_t *pRuleset;
63 	rsRetVal localRet;
64 	DEFiRet;
65 	modConf-&gt;pBindRuleset = NULL;	
66 	if(modConf-&gt;pszBindRuleset == NULL)
67 		FINALIZE;
68 	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
69 	if(localRet == RS_RET_NOT_FOUND) {
70 		std_mod_checkRuleset_genErrMsg(modConf);
71 	}
72 	CHKiRet(localRet);
73 	modConf-&gt;pBindRuleset = pRuleset;
74 finalize_it:
75 	RETiRet;
76 }
77 static inline void
78 std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf)
79 {
80 	LogError(0, NO_ERRCODE, "imklog: ruleset '%s' not found - "
81 			"using default ruleset instead", modConf-&gt;pszBindRuleset);
82 }
83 static void
84 initConfigSettings(void)
85 {
86 	cs.bPermitNonKernel = 0;
87 	cs.bParseKernelStamp = 0;
88 	cs.bKeepKernelStamp = 0;
89 	cs.console_log_level = -1;
90 	cs.pszPath = NULL;
91 	cs.iFacilIntMsg = klogFacilIntMsg();
92 }
93 static rsRetVal
94 enqMsg(uchar *const __restrict__ msg,
95 	uchar* pszTag,
96 	const syslog_pri_t pri,
97 	struct timeval *tp,
98 	ratelimit_t *ratelimiter)
99 {
100 	struct syslogTime st;
101 	smsg_t *pMsg;
102 	DEFiRet;
103 	assert(msg != NULL);
104 	assert(pszTag != NULL);
105 	if(tp == NULL) {
106 		CHKiRet(msgConstruct(&amp;pMsg));
107 	} else {
108 		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
109 		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
110 	}
111 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
112 	MsgSetInputName(pMsg, pInputName);
113 	MsgSetRawMsgWOSize(pMsg, (char*)msg);
114 	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
115 	MsgSetMSGoffs(pMsg, 0);		MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
116 	MsgSetRcvFromIP(pMsg, pLocalHostIP);
117 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
118 	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
119 	msgSetPRI(pMsg, pri);
120 	ratelimitAddMsg(ratelimiter, NULL, pMsg);
121 finalize_it:
122 	RETiRet;
123 }
124 static rsRetVal
125 parsePRI(uchar **ppSz, syslog_pri_t *piPri)
126 {
127 	DEFiRet;
128 	syslog_pri_t i;
129 	uchar *pSz;
130 	assert(ppSz != NULL);
131 	pSz = *ppSz;
132 	assert(pSz != NULL);
133 	assert(piPri != NULL);
134 	if(*pSz != '&lt;' || !isdigit(*(pSz+1)))
135 		ABORT_FINALIZE(RS_RET_INVALID_PRI);
136 	++pSz;
137 	i = 0;
138 	while(isdigit(*pSz) &amp;&amp; i &lt;= LOG_MAXPRI) {
139 		i = i * 10 + *pSz++ - '0';
140 	}
141 	if(*pSz != '&gt;' || i &gt; LOG_MAXPRI)
142 		ABORT_FINALIZE(RS_RET_INVALID_PRI);
143 	*piPri = i;
144 	*ppSz = pSz + 1; 
145 finalize_it:
146 	RETiRet;
147 }
148 rsRetVal imklogLogIntMsg(syslog_pri_t priority, const char *fmt, ...)
149 {
150 	DEFiRet;
151 	va_list ap;
152 	uchar msgBuf[2048]; 
153 	va_start(ap, fmt);
154 	vsnprintf((char*)msgBuf, sizeof(msgBuf), fmt, ap);
155 	va_end(ap);
156 	logmsgInternal(NO_ERRCODE, priority, msgBuf, 0);
157 	RETiRet;
158 }
159 rsRetVal Syslog(modConfData_t *pModConf, syslog_pri_t priority, uchar *pMsg, struct timeval *tp)
160 {
161 	syslog_pri_t pri;
162 	int bPRISet = 0;
163 	rsRetVal localRet;
164 	DEFiRet;
165 	if(pMsg[3] == '&lt;' || (pMsg[3] == ' ' &amp;&amp; pMsg[4] == '&lt;')) { 		uchar *pMsgTmp = pMsg + ((pMsg[3] == '&lt;') ? 3 : 4);
166 		localRet = parsePRI(&amp;pMsgTmp, &amp;pri);
167 		if(localRet == RS_RET_OK &amp;&amp; pri &gt;= 8 &amp;&amp; pri &lt;= LOG_MAXPRI) {
168 			DBGPRINTF("imklog detected secondary PRI(%d) in klog msg\n", pri);
169 			pMsg = pMsgTmp;
170 			priority = pri;
171 			bPRISet = 1;
172 		}
173 	}
174 	if(!bPRISet) {
175 		localRet = parsePRI(&amp;pMsg, &amp;priority);
176 		if(localRet != RS_RET_INVALID_PRI &amp;&amp; localRet != RS_RET_OK)
177 			FINALIZE;
178 	}
179 	if(pModConf-&gt;bPermitNonKernel == 0 &amp;&amp; pri2fac(priority) != LOG_KERN)
180 		FINALIZE; 
181 	iRet = enqMsg((uchar*)pMsg, (uchar*) "kernel:", priority, tp, pModConf-&gt;ratelimiter);
182 finalize_it:
183 	RETiRet;
184 }
185 int klog_getMaxLine(void)
186 {
187 	return glbl.GetMaxLine(runConf);
188 }
189 BEGINrunInput
190 CODESTARTrunInput
191 	while(!pThrd-&gt;bShallStop) {
192 		CHKiRet(klogLogKMsg(runModConf));
193 	}
194 finalize_it:
195 ENDrunInput
196 BEGINbeginCnfLoad
197 CODESTARTbeginCnfLoad
198 	loadModConf = pModConf;
199 	pModConf-&gt;pConf = pConf;
200 	pModConf-&gt;pszPath = NULL;
201 	pModConf-&gt;bPermitNonKernel = 0;
202 	pModConf-&gt;bParseKernelStamp = 0;
203 	pModConf-&gt;bKeepKernelStamp = 0;
204 	pModConf-&gt;console_log_level = -1;
205 	pModConf-&gt;bKeepKernelStamp = 0;
206 	pModConf-&gt;iFacilIntMsg = klogFacilIntMsg();
207 	loadModConf-&gt;configSetViaV2Method = 0;
208 	pModConf-&gt;ratelimiter = NULL;
209 	pModConf-&gt;ratelimitBurst = 10000; 	pModConf-&gt;ratelimitInterval = 0; 	bLegacyCnfModGlobalsPermitted = 1;
210 	initConfigSettings();
211 ENDbeginCnfLoad
212 <a name="1"></a>
213 BEGINsetModCnf
214 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	struct cnfparamvals *pvals = NULL;
215 	int i;
216 CODESTARTsetModCnf
217 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
218 	if(pvals == NULL) {
219 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
220 				"config parameters [module(...)]");
221 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
222 	}
223 	if(Debug) {
224 		dbgprintf("module (global) param blk for imklog:\n");
225 		cnfparamsPrint(&amp;modpblk, pvals);
226 	}
227 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
228 		if(!pvals[i].bUsed)
229 			continue;
230 <a name="3"></a>		if(!strcmp(modpblk.descr[i].name, "logpath")) {
231 			loadModConf-&gt;pszPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
232 		} else if(!strcmp(modpblk.descr[i].name, "permitnonkernelfacility")) {
233 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			loadModConf-&gt;bPermitNonKernel = (int) pvals[i].val.d.n;
234 		} else if(!strcmp(modpblk.descr[i].name, "parsekerneltimestamp")) {
235 			loadModConf-&gt;bParseKernelStamp = (int) pvals[i].val.d.n;
236 		} else if(!strcmp(modpblk.descr[i].name, "keepkerneltimestamp")) {
237 			loadModConf-&gt;bKeepKernelStamp = (int) pvals[i].val.d.n;
238 		} else if(!strcmp(modpblk.descr[i].name, "consoleloglevel")) {
239 			loadModConf-&gt;console_log_level= (int) pvals[i].val.d.n;</b></font>
240 		} else if(!strcmp(modpblk.descr[i].name, "internalmsgfacility")) {
241 			loadModConf-&gt;iFacilIntMsg = (int) pvals[i].val.d.n;
242 		} else if(!strcmp(modpblk.descr[i].name, "ratelimitburst")) {
243 <a name="2"></a>			loadModConf-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
244 		} else if(!strcmp(modpblk.descr[i].name, "ratelimitinterval")) {
245 			loadModConf-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
246 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
247 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
248 		} else {
249 			LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING,
250 				"imklog: RSYSLOG BUG, non-handled param '%s' in "
251 				"beginCnfLoad\n", modpblk.descr[i].name);
252 		}
253 	}
254 	bLegacyCnfModGlobalsPermitted = 0;
255 	loadModConf-&gt;configSetViaV2Method = 1;
256 finalize_it:
257 	if(pvals != NULL)
258 		cnfparamvalsDestruct(pvals, &amp;modpblk);
259 ENDsetModCnf
260 BEGINendCnfLoad
261 CODESTARTendCnfLoad
262 	if(!loadModConf-&gt;configSetViaV2Method) {
263 		loadModConf-&gt;bPermitNonKernel = cs.bPermitNonKernel;</b></font>
264 		loadModConf-&gt;bParseKernelStamp = cs.bParseKernelStamp;
265 		loadModConf-&gt;bKeepKernelStamp = cs.bKeepKernelStamp;
266 		loadModConf-&gt;iFacilIntMsg = cs.iFacilIntMsg;
267 		loadModConf-&gt;console_log_level = cs.console_log_level;
268 		if((cs.pszPath == NULL) || (cs.pszPath[0] == '\0')) {
269 			loadModConf-&gt;pszPath = NULL;
270 			if(cs.pszPath != NULL)
271 				free(cs.pszPath);
272 		} else {
273 			loadModConf-&gt;pszPath = cs.pszPath;
274 		}
275 		cs.pszPath = NULL;
276 	}
277 	loadModConf = NULL; ENDendCnfLoad
278 BEGINcheckCnf
279 CODESTARTcheckCnf
280 	std_mod_checkRuleset(pModConf);
281 ENDcheckCnf
282 BEGINactivateCnfPrePrivDrop
283 CODESTARTactivateCnfPrePrivDrop
284 	runModConf = pModConf;
285 	iRet = klogWillRunPrePrivDrop(runModConf);
286 ENDactivateCnfPrePrivDrop
287 BEGINactivateCnf
288 CODESTARTactivateCnf
289 	CHKiRet(ratelimitNew(&amp;runModConf-&gt;ratelimiter, "imklog", NULL));
290 	ratelimitSetLinuxLike(runModConf-&gt;ratelimiter,
291 			      runModConf-&gt;ratelimitInterval,
292 			      runModConf-&gt;ratelimitBurst);
293 finalize_it:
294 ENDactivateCnf
295 BEGINfreeCnf
296 CODESTARTfreeCnf
297 	free(pModConf-&gt;pszBindRuleset);
298 ENDfreeCnf
299 BEGINwillRun
300 CODESTARTwillRun
301 	pLocalHostIP = glbl.GetLocalHostIP();
302 	iRet = klogWillRunPostPrivDrop(runModConf);
303 ENDwillRun
304 BEGINafterRun
305 CODESTARTafterRun
306 	ratelimitDestruct(runModConf-&gt;ratelimiter);
307 	iRet = klogAfterRun(runModConf);
308 ENDafterRun
309 BEGINmodExit
310 CODESTARTmodExit
311 	if(pInputName != NULL)
312 		prop.Destruct(&amp;pInputName);
313 	objRelease(glbl, CORE_COMPONENT);
314 	objRelease(net, CORE_COMPONENT);
315 	objRelease(datetime, CORE_COMPONENT);
316 	objRelease(ruleset, CORE_COMPONENT);
317 	objRelease(prop, CORE_COMPONENT);
318 ENDmodExit
319 BEGINqueryEtryPt
320 CODESTARTqueryEtryPt
321 CODEqueryEtryPt_STD_IMOD_QUERIES
322 CODEqueryEtryPt_STD_CONF2_QUERIES
323 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
324 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
325 ENDqueryEtryPt
326 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
327 {
328 	cs.bPermitNonKernel = 0;
329 	cs.bParseKernelStamp = 0;
330 	cs.bKeepKernelStamp = 0;
331 	if(cs.pszPath != NULL) {
332 		free(cs.pszPath);
333 		cs.pszPath = NULL;
334 	}
335 	cs.iFacilIntMsg = klogFacilIntMsg();
336 	return RS_RET_OK;
337 }
338 BEGINmodInit()
339 CODESTARTmodInit
340 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
341 	CHKiRet(objUse(datetime, CORE_COMPONENT));
342 	CHKiRet(objUse(glbl, CORE_COMPONENT));
343 	CHKiRet(objUse(prop, CORE_COMPONENT));
344 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
345 	CHKiRet(objUse(net, CORE_COMPONENT));
346 	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT("imklog"), sizeof("imklog") - 1));
347 	initConfigSettings();
348 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogLocalipif", 0, eCmdHdlrGoneAway,
349 			NULL, NULL, STD_LOADABLE_MODULE_ID));
350 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"debugprintkernelsymbols", 0, eCmdHdlrGoneAway,
351 			NULL, NULL, STD_LOADABLE_MODULE_ID));
352 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpath", 0, eCmdHdlrGetWord,
353 			NULL, &amp;cs.pszPath, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
354 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbollookup", 0, eCmdHdlrGoneAway,
355 			NULL, NULL, STD_LOADABLE_MODULE_ID));
356 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbolstwice", 0, eCmdHdlrGoneAway,
357 			NULL, NULL, STD_LOADABLE_MODULE_ID));
358 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogusesyscallinterface", 0, eCmdHdlrGoneAway,
359 			NULL, NULL, STD_LOADABLE_MODULE_ID));
360 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpermitnonkernelfacility", 0, eCmdHdlrBinary,
361 			NULL, &amp;cs.bPermitNonKernel, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
362 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogconsoleloglevel", 0, eCmdHdlrInt,
363 			NULL, &amp;cs.console_log_level, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
364 	CHKiRet(regCfSysLineHdlr2((uchar *)"kloginternalmsgfacility", 0, eCmdHdlrFacility,
365 			NULL, &amp;cs.iFacilIntMsg, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
366 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogparsekerneltimestamp", 0, eCmdHdlrBinary,
367 			NULL, &amp;cs.bParseKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
368 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogkeepkerneltimestamp", 0, eCmdHdlrBinary,
369 			NULL, &amp;cs.bKeepKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
370 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
371 			resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
372 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>immark.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdlib.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;signal.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;pthread.h&gt;
9 #include "dirty.h"
10 #include "cfsysline.h"
11 #include "module-template.h"
12 #include "errmsg.h"
13 #include "msg.h"
14 #include "srUtils.h"
15 #include "glbl.h"
16 #include "unicode-helper.h"
17 #include "ruleset.h"
18 #include "prop.h"
19 MODULE_TYPE_INPUT
20 MODULE_TYPE_NOKEEP
21 MODULE_CNFNAME("immark")
22 #define DEFAULT_MARK_PERIOD (20 * 60)
23 DEF_IMOD_STATIC_DATA
24 DEFobjCurrIf(glbl)
25 DEFobjCurrIf(prop)
26 DEFobjCurrIf(ruleset)
27 static int iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
28 struct modConfData_s {
29 	rsconf_t *pConf;		const char *pszMarkMsgText;
30 	size_t lenMarkMsgText;
31 	uchar *pszBindRuleset;
32 	ruleset_t *pBindRuleset;
33 	int flags;
34 	int bUseMarkFlag;
35 	int bUseSyslogAPI;
36 	int iMarkMessagePeriod;
37 	sbool configSetViaV2Method;
38 };
39 <a name="0"></a>
40 static struct cnfparamdescr modpdescr[] = {
41 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ruleset", eCmdHdlrString, 0 },
42 	{ "markmessagetext", eCmdHdlrString, 0 },
43 	{ "use.syslogcall", eCmdHdlrBinary, 0 },
44 	{ "use.markflag", eCmdHdlrBinary, 0 },
45 	{ "interval", eCmdHdlrInt, 0 }
46 };
47 static struct cnfparamblk modpblk =
48 	{ CNFPARAMBLK_VERSION,
49 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
50 	  modpdescr
51 	};
52 static modConfData_t *loadModConf = NULL;static int bLegacyCnfModGlobalsPermitted;static prop_t *pInternalInputName = NULL;
53 BEGINisCompatibleWithFeature
54 CODESTARTisCompatibleWithFeature
55 	if(eFeat == sFEATURENonCancelInputTermination)
56 		iRet = RS_RET_OK;
57 ENDisCompatibleWithFeature
58 BEGINafterRun
59 CODESTARTafterRun
60 ENDafterRun
61 BEGINbeginCnfLoad
62 CODESTARTbeginCnfLoad
63 	loadModConf = pModConf;
64 	pModConf-&gt;pConf = pConf;
65 	pModConf-&gt;pszMarkMsgText = NULL;
66 	pModConf-&gt;iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
67 	pModConf-&gt;bUseSyslogAPI = 1;
68 	pModConf-&gt;bUseMarkFlag = 1;
69 	pModConf-&gt;pszBindRuleset = NULL;
70 	pModConf-&gt;pBindRuleset = NULL;
71 	loadModConf-&gt;configSetViaV2Method = 0;
72 	bLegacyCnfModGlobalsPermitted = 1;
73 ENDbeginCnfLoad
74 static rsRetVal
75 checkRuleset(modConfData_t *modConf)
76 {
77 	ruleset_t *pRuleset;
78 	rsRetVal localRet;
79 	DEFiRet;
80 	if(modConf-&gt;pszBindRuleset == NULL)
81 		FINALIZE;
82 	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
83 	if(localRet == RS_RET_NOT_FOUND) {
84 		LogError(0, NO_ERRCODE, "immark: ruleset '%s' not found - "
85 				"using default ruleset instead", modConf-&gt;pszBindRuleset);
86 	}
87 	CHKiRet(localRet);
88 	modConf-&gt;pBindRuleset = pRuleset;
89 finalize_it:
90 	RETiRet;
91 <a name="1"></a>}
92 BEGINsetModCnf
93 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	struct cnfparamvals *pvals = NULL;
94 	int i;
95 CODESTARTsetModCnf
96 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
97 	if(pvals == NULL) {
98 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
99 				"config parameters [module(...)]");
100 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
101 	}
102 	if(Debug) {
103 		dbgprintf("module (global) param blk for immark:\n");
104 		cnfparamsPrint(&amp;modpblk, pvals);
105 	}
106 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
107 <a name="3"></a>		if(!pvals[i].bUsed)
108 			continue;
109 		if(!strcmp(modpblk.descr[i].name, "interval")) {
110 			loadModConf-&gt;iMarkMessagePeriod = (int) pvals[i].val.d.n;</b></font><font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
111 		} else if(!strcmp(modpblk.descr[i].name, "use.syslogcall")) {
112 			loadModConf-&gt;bUseSyslogAPI = (int) pvals[i].val.d.n;
113 		} else if(!strcmp(modpblk.descr[i].name, "use.markflag")) {
114 <a name="2"></a>			loadModConf-&gt;bUseMarkFlag = (int) pvals[i].val.d.n;
115 		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
116 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
117 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "markmessagetext")) {
118 			loadModConf-&gt;pszMarkMsgText = es_str2cstr(pvals[i].val.d.estr, NULL);
119 		} else {
120 			dbgprintf("immark: program error, non-handled "
121 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
122 		}
123 	}
124 	bLegacyCnfModGlobalsPermitted = 0;
125 	loadModConf-&gt;configSetViaV2Method = 1;
126 finalize_it:
127 	if(pvals != NULL)
128 		cnfparamvalsDestruct(pvals, &amp;modpblk);
129 ENDsetModCnf
130 BEGINendCnfLoad
131 CODESTARTendCnfLoad
132 	if(!loadModConf-&gt;configSetViaV2Method) {
133 		pModConf-&gt;iMarkMessagePeriod = iMarkMessagePeriod;</b></font>
134 	}
135 ENDendCnfLoad
136 BEGINcheckCnf
137 CODESTARTcheckCnf
138 	pModConf-&gt;flags = (pModConf-&gt;bUseMarkFlag) ? MARK : 0;
139 	if(pModConf-&gt;pszMarkMsgText == NULL) {
140 		pModConf-&gt;pszMarkMsgText = strdup("-- MARK --");
141 	}
142 	pModConf-&gt;lenMarkMsgText = strlen(pModConf-&gt;pszMarkMsgText);
143 	if(pModConf-&gt;pszBindRuleset != NULL) {
144 		checkRuleset(pModConf);
145 		if(pModConf-&gt;bUseSyslogAPI) {
146 			LogError(0, NO_ERRCODE, "immark: ruleset specified, but configured to log "
147 				"via syslog call - switching to rsyslog-internal logging");
148 			pModConf-&gt;bUseSyslogAPI = 0;
149 		}
150 	}
151 	if(pModConf-&gt;iMarkMessagePeriod == 0) {
152 		LogError(0, NO_ERRCODE, "immark: mark message period must not be 0, can not run");
153 		ABORT_FINALIZE(RS_RET_NO_RUN);		}
154 finalize_it:
155 ENDcheckCnf
156 BEGINactivateCnf
157 CODESTARTactivateCnf
158 	MarkInterval = pModConf-&gt;iMarkMessagePeriod;
159 	DBGPRINTF("immark set MarkInterval to %d\n", MarkInterval);
160 ENDactivateCnf
161 BEGINfreeCnf
162 CODESTARTfreeCnf
163 ENDfreeCnf
164 static rsRetVal
165 injectMarkMessage(const int pri)
166 {
167 	smsg_t *pMsg;
168 	DEFiRet;
169 	CHKiRet(msgConstruct(&amp;pMsg));
170 	pMsg-&gt;msgFlags  = loadModConf-&gt;flags;
171 	MsgSetInputName(pMsg, pInternalInputName);
172 	MsgSetRawMsg(pMsg, loadModConf-&gt;pszMarkMsgText,loadModConf-&gt;lenMarkMsgText);
173 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
174 	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
175 	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
176 	MsgSetMSGoffs(pMsg, 0);
177 	MsgSetTAG(pMsg, (const uchar*)"rsyslogd:", sizeof("rsyslogd:")-1);
178 	msgSetPRI(pMsg, pri);
179 	MsgSetRuleset(pMsg, loadModConf-&gt;pBindRuleset);
180 	submitMsg2(pMsg);
181 finalize_it:
182 	RETiRet;
183 }
184 BEGINrunInput
185 CODESTARTrunInput
186 	while(1) {
187 		srSleep(MarkInterval, 0); 
188 		if(glbl.GetGlobalInputTermState() == 1)
189 			break; 
190 		dbgprintf("immark: injecting mark message\n");
191 		if(loadModConf-&gt;bUseSyslogAPI) {
192 			logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO,
193 				(uchar*)loadModConf-&gt;pszMarkMsgText, loadModConf-&gt;flags);
194 		} else {
195 			injectMarkMessage(LOG_SYSLOG|LOG_INFO);
196 		}
197 	}
198 ENDrunInput
199 BEGINwillRun
200 CODESTARTwillRun
201 ENDwillRun
202 BEGINmodExit
203 CODESTARTmodExit
204 	if(pInternalInputName != NULL)
205 		prop.Destruct(&amp;pInternalInputName);
206 	objRelease(ruleset, CORE_COMPONENT);
207 	objRelease(prop, CORE_COMPONENT);
208 ENDmodExit
209 BEGINqueryEtryPt
210 CODESTARTqueryEtryPt
211 CODEqueryEtryPt_STD_IMOD_QUERIES
212 CODEqueryEtryPt_STD_CONF2_QUERIES
213 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
214 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
215 ENDqueryEtryPt
216 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
217 {
218 	iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
219 	return RS_RET_OK;
220 }
221 BEGINmodInit()
222 CODESTARTmodInit
223 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
224 	CHKiRet(objUse(glbl, CORE_COMPONENT));
225 	CHKiRet(objUse(prop, CORE_COMPONENT));
226 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
227 	CHKiRet(prop.Construct(&amp;pInternalInputName));
228 	CHKiRet(prop.SetString(pInternalInputName, UCHAR_CONSTANT("immark"), sizeof("immark") - 1));
229 	CHKiRet(prop.ConstructFinalize(pInternalInputName));
230 	CHKiRet(regCfSysLineHdlr2((uchar *)"markmessageperiod", 0, eCmdHdlrInt, NULL,
231 		&amp;iMarkMessagePeriod, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
232 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
233 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
234 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
