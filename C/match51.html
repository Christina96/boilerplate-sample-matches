<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imklog.c & immark.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imklog.c & immark.c
      </h3>
      <h1 align="center">
        31.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imklog.c (24.107143%)<TH>immark.c (45.251396%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match51-0.html#0',2,'match51-1.html#0',3)" NAME="0">(103-117)<TD><A HREF="javascript:ZweiFrames('match51-0.html#0',2,'match51-1.html#0',3)" NAME="0">(79-93)</A><TD ALIGN=center><FONT COLOR="#ff0000">23</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match51-0.html#1',2,'match51-1.html#1',3)" NAME="1">(356-375)<TD><A HREF="javascript:ZweiFrames('match51-0.html#1',2,'match51-1.html#1',3)" NAME="1">(147-166)</A><TD ALIGN=center><FONT COLOR="#f30000">22</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match51-0.html#2',2,'match51-1.html#2',3)" NAME="2">(390-413)<TD><A HREF="javascript:ZweiFrames('match51-0.html#2',2,'match51-1.html#2',3)" NAME="2">(173-194)</A><TD ALIGN=center><FONT COLOR="#c70000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match51-0.html#3',2,'match51-1.html#3',3)" NAME="3">(377-383)<TD><A HREF="javascript:ZweiFrames('match51-0.html#3',2,'match51-1.html#3',3)" NAME="3">(166-172)</A><TD ALIGN=center><FONT COLOR="#c70000">18</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imklog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* The kernel log module.
 *
 * This is an abstracted module. As Linux and BSD kernel log is conceptually the
 * same, we do not do different input plugins for them but use
 * imklog in both cases, just with different &quot;backend drivers&quot; for
 * the different platforms. This also enables a rsyslog.conf to
 * be used on multiple platforms without the need to take care of
 * what the kernel log is coming from.
 *
 * See platform-specific files (e.g. linux.c, bsd.c) in the plugin's
 * working directory. For other systems with similar kernel logging
 * functionality, no new input plugin shall be written but rather a
 * driver be developed for imklog. Please note that imklog itself is
 * mostly concerned with handling the interface. Any real action happens
 * in the drivers, as things may be pretty different on different
 * platforms.
 *
 * Please note that this file replaces the klogd daemon that was
 * also present in pre-v3 versions of rsyslog.
 *
 * To test under Linux:
 * echo test1 &gt; /dev/kmsg
 *
 * Copyright (C) 2008-2020 Adiscon GmbH
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;

#include &quot;dirty.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;parserif.h&quot;
#include &quot;obj.h&quot;
#include &quot;msg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;datetime.h&quot;
#include &quot;imklog.h&quot;
#include &quot;net.h&quot;
#include &quot;glbl.h&quot;
#include &quot;prop.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;ruleset.h&quot;


MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imklog&quot;)

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(datetime)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)

/* config settings */
typedef struct configSettings_s {
	int bPermitNonKernel; /* permit logging of messages not having LOG_KERN facility */
	int bParseKernelStamp; /* if try to parse kernel timestamps for message time */
	int bKeepKernelStamp; /* keep the kernel timestamp in the message */
	int iFacilIntMsg; /* the facility to use for internal messages (set by driver) */
	uchar *pszPath;
	int console_log_level; /* still used for BSD */
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
} configSettings_t;
static configSettings_t cs;

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
<A NAME="0"></A>	{ &quot;logpath&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;permitnonkernelfacility&quot;, eCmdHdlrBinary, 0 },
	{ &quot;consoleloglevel&quot;, eCmdHdlrInt, 0 },
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match51-1.html#0',3,'match51-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;parsekerneltimestamp&quot;, eCmdHdlrBinary, 0 },
	{ &quot;keepkerneltimestamp&quot;, eCmdHdlrBinary, 0 },
	{ &quot;internalmsgfacility&quot;, eCmdHdlrFacility, 0 },
	{ &quot;ratelimitinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ratelimitburst&quot;, eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this module */
static prop_t *pLocalHostIP = NULL;</B></FONT>

/** POTENTIAL COMMON CODE FOR RULESET CHECK **/
static inline void std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf);
static inline rsRetVal
std_mod_checkRuleset(modConfData_t *const modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	modConf-&gt;pBindRuleset = NULL;	/* assume default ruleset */

	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;

	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		std_mod_checkRuleset_genErrMsg(modConf);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;

finalize_it:
	RETiRet;
}
/** END POTENTIAL COMMON CODE FOR RULESET CHECK **/
static inline void
std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf)
{
	LogError(0, NO_ERRCODE, &quot;imklog: ruleset '%s' not found - &quot;
			&quot;using default ruleset instead&quot;, modConf-&gt;pszBindRuleset);
}

static void
initConfigSettings(void)
{
	cs.bPermitNonKernel = 0;
	cs.bParseKernelStamp = 0;
	cs.bKeepKernelStamp = 0;
	cs.console_log_level = -1;
	cs.pszPath = NULL;
	cs.iFacilIntMsg = klogFacilIntMsg();
}


/* enqueue the the kernel message into the message queue.
 * The provided msg string is not freed - thus must be done
 * by the caller.
 * rgerhards, 2008-04-12
 */
static rsRetVal
enqMsg(uchar *const __restrict__ msg,
	uchar* pszTag,
	const syslog_pri_t pri,
	struct timeval *tp,
	ratelimit_t *ratelimiter)
{
	struct syslogTime st;
	smsg_t *pMsg;
	DEFiRet;

	assert(msg != NULL);
	assert(pszTag != NULL);

	if(tp == NULL) {
		CHKiRet(msgConstruct(&amp;pMsg));
	} else {
		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
	}
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsgWOSize(pMsg, (char*)msg);
	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, pLocalHostIP);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
	msgSetPRI(pMsg, pri);
	ratelimitAddMsg(ratelimiter, NULL, pMsg);
finalize_it:
	RETiRet;
}

/* parse the PRI from a kernel message. At least BSD seems to have
 * non-kernel messages inside the kernel log...
 * Expected format: &quot;&lt;pri&gt;&quot;. piPri is only valid if the function
 * successfully returns. If there was a proper pri ppSz is advanced to the
 * position right after &quot;&gt;&quot;.
 * rgerhards, 2008-04-14
 */
static rsRetVal
parsePRI(uchar **ppSz, syslog_pri_t *piPri)
{
	DEFiRet;
	syslog_pri_t i;
	uchar *pSz;

	assert(ppSz != NULL);
	pSz = *ppSz;
	assert(pSz != NULL);
	assert(piPri != NULL);

	if(*pSz != '&lt;' || !isdigit(*(pSz+1)))
		ABORT_FINALIZE(RS_RET_INVALID_PRI);

	++pSz;
	i = 0;
	while(isdigit(*pSz) &amp;&amp; i &lt;= LOG_MAXPRI) {
		i = i * 10 + *pSz++ - '0';
	}

	if(*pSz != '&gt;' || i &gt; LOG_MAXPRI)
		ABORT_FINALIZE(RS_RET_INVALID_PRI);

	/* OK, we have a valid PRI */
	*piPri = i;
	*ppSz = pSz + 1; /* update msg ptr to position after PRI */

finalize_it:
	RETiRet;
}


/* log an imklog-internal message
 * rgerhards, 2008-04-14
 */
rsRetVal imklogLogIntMsg(syslog_pri_t priority, const char *fmt, ...)
{
	DEFiRet;
	va_list ap;
	uchar msgBuf[2048]; /* we use the same size as sysklogd to remain compatible */

	va_start(ap, fmt);
	vsnprintf((char*)msgBuf, sizeof(msgBuf), fmt, ap);
	va_end(ap);

	logmsgInternal(NO_ERRCODE, priority, msgBuf, 0);

	RETiRet;
}


/* log a kernel message. If tp is non-NULL, it contains the message creation
 * time to use.
 * rgerhards, 2008-04-14
 */
rsRetVal Syslog(modConfData_t *pModConf, syslog_pri_t priority, uchar *pMsg, struct timeval *tp)
{
	syslog_pri_t pri;
	int bPRISet = 0;
	rsRetVal localRet;
	DEFiRet;

	/* then check if we have two PRIs. This can happen in case of systemd,
	 * in which case the second PRI is the right one.
	 */
	if(pMsg[3] == '&lt;' || (pMsg[3] == ' ' &amp;&amp; pMsg[4] == '&lt;')) { /* could be a pri... */
		uchar *pMsgTmp = pMsg + ((pMsg[3] == '&lt;') ? 3 : 4);
		localRet = parsePRI(&amp;pMsgTmp, &amp;pri);
		if(localRet == RS_RET_OK &amp;&amp; pri &gt;= 8 &amp;&amp; pri &lt;= LOG_MAXPRI) {
			/* *this* is our PRI */
			DBGPRINTF(&quot;imklog detected secondary PRI(%d) in klog msg\n&quot;, pri);
			pMsg = pMsgTmp;
			priority = pri;
			bPRISet = 1;
		}
	}
	if(!bPRISet) {
		localRet = parsePRI(&amp;pMsg, &amp;priority);
		if(localRet != RS_RET_INVALID_PRI &amp;&amp; localRet != RS_RET_OK)
			FINALIZE;
	}
	/* if we don't get the pri, we use whatever we were supplied */

	/* ignore non-kernel messages if not permitted */
	if(pModConf-&gt;bPermitNonKernel == 0 &amp;&amp; pri2fac(priority) != LOG_KERN)
		FINALIZE; /* silently ignore */

	iRet = enqMsg((uchar*)pMsg, (uchar*) &quot;kernel:&quot;, priority, tp, pModConf-&gt;ratelimiter);

finalize_it:
	RETiRet;
}


/* helper for some klog drivers which need to know the MaxLine global setting. They can
 * not obtain it themselfs, because they are no modules and can not query the object hander.
 * It would probably be a good idea to extend the interface to support it, but so far
 * we create a (sufficiently valid) work-around. -- rgerhards, 2008-11-24
 */
int klog_getMaxLine(void)
{
	return glbl.GetMaxLine(runConf);
}


BEGINrunInput
CODESTARTrunInput
	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so. This, however, is handled by the framework,
	 * right into the sleep below.
	 */
	while(!pThrd-&gt;bShallStop) {
		/* klogLogKMsg() waits for the next kernel message, obtains it
		 * and then submits it to the rsyslog main queue.
	   	 * rgerhards, 2008-04-09
	   	 */
		CHKiRet(klogLogKMsg(runModConf));
	}
finalize_it:
ENDrunInput


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	pModConf-&gt;pszPath = NULL;
	pModConf-&gt;bPermitNonKernel = 0;
	pModConf-&gt;bParseKernelStamp = 0;
	pModConf-&gt;bKeepKernelStamp = 0;
	pModConf-&gt;console_log_level = -1;
	pModConf-&gt;bKeepKernelStamp = 0;
	pModConf-&gt;iFacilIntMsg = klogFacilIntMsg();
	loadModConf-&gt;configSetViaV2Method = 0;
	pModConf-&gt;ratelimiter = NULL;
	pModConf-&gt;ratelimitBurst = 10000; /* arbitrary high limit */
	pModConf-&gt;ratelimitInterval = 0; /* off */
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	initConfigSettings();
ENDbeginCnfLoad
<A NAME="1"></A>

BEGINsetModCnf
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match51-1.html#1',3,'match51-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for imklog:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
<A NAME="3"></A>		if(!strcmp(modpblk.descr[i].name, &quot;logpath&quot;)) {
			loadModConf-&gt;pszPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else if(!strcmp(modpblk.descr[i].name, &quot;permitnonkernelfacility&quot;)) {
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match51-1.html#3',3,'match51-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			loadModConf-&gt;bPermitNonKernel = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;parsekerneltimestamp&quot;)) {
			loadModConf-&gt;bParseKernelStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;keepkerneltimestamp&quot;)) {
			loadModConf-&gt;bKeepKernelStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;consoleloglevel&quot;)) {
			loadModConf-&gt;console_log_level= (int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(modpblk.descr[i].name, &quot;internalmsgfacility&quot;)) {
			loadModConf-&gt;iFacilIntMsg = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;ratelimitburst&quot;)) {
<A NAME="2"></A>			loadModConf-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;ratelimitinterval&quot;)) {
			loadModConf-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match51-1.html#2',3,'match51-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING,
				&quot;imklog: RSYSLOG BUG, non-handled param '%s' in &quot;
				&quot;beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

	/* disable legacy module-global config directives */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;bPermitNonKernel = cs.bPermitNonKernel;</B></FONT>
		loadModConf-&gt;bParseKernelStamp = cs.bParseKernelStamp;
		loadModConf-&gt;bKeepKernelStamp = cs.bKeepKernelStamp;
		loadModConf-&gt;iFacilIntMsg = cs.iFacilIntMsg;
		loadModConf-&gt;console_log_level = cs.console_log_level;
		if((cs.pszPath == NULL) || (cs.pszPath[0] == '\0')) {
			loadModConf-&gt;pszPath = NULL;
			if(cs.pszPath != NULL)
				free(cs.pszPath);
		} else {
			loadModConf-&gt;pszPath = cs.pszPath;
		}
		cs.pszPath = NULL;
	}

	loadModConf = NULL; /* done loading */
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
	std_mod_checkRuleset(pModConf);
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	iRet = klogWillRunPrePrivDrop(runModConf);
ENDactivateCnfPrePrivDrop


BEGINactivateCnf
CODESTARTactivateCnf
	CHKiRet(ratelimitNew(&amp;runModConf-&gt;ratelimiter, &quot;imklog&quot;, NULL));
	ratelimitSetLinuxLike(runModConf-&gt;ratelimiter,
			      runModConf-&gt;ratelimitInterval,
			      runModConf-&gt;ratelimitBurst);
finalize_it:
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf


BEGINwillRun
CODESTARTwillRun
	pLocalHostIP = glbl.GetLocalHostIP();
	iRet = klogWillRunPostPrivDrop(runModConf);
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	ratelimitDestruct(runModConf-&gt;ratelimiter);
	iRet = klogAfterRun(runModConf);
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

	/* release objects we used */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(net, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.bPermitNonKernel = 0;
	cs.bParseKernelStamp = 0;
	cs.bKeepKernelStamp = 0;
	if(cs.pszPath != NULL) {
		free(cs.pszPath);
		cs.pszPath = NULL;
	}
	cs.iFacilIntMsg = klogFacilIntMsg();
	return RS_RET_OK;
}

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(net, CORE_COMPONENT));

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT(&quot;imklog&quot;), sizeof(&quot;imklog&quot;) - 1));

	/* init legacy config settings */
	initConfigSettings();

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;klogLocalipif&quot;, 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;debugprintkernelsymbols&quot;, 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;klogpath&quot;, 0, eCmdHdlrGetWord,
			NULL, &amp;cs.pszPath, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;klogsymbollookup&quot;, 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;klogsymbolstwice&quot;, 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;klogusesyscallinterface&quot;, 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;klogpermitnonkernelfacility&quot;, 0, eCmdHdlrBinary,
			NULL, &amp;cs.bPermitNonKernel, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;klogconsoleloglevel&quot;, 0, eCmdHdlrInt,
			NULL, &amp;cs.console_log_level, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;kloginternalmsgfacility&quot;, 0, eCmdHdlrFacility,
			NULL, &amp;cs.iFacilIntMsg, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;klogparsekerneltimestamp&quot;, 0, eCmdHdlrBinary,
			NULL, &amp;cs.bParseKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;klogkeepkerneltimestamp&quot;, 0, eCmdHdlrBinary,
			NULL, &amp;cs.bKeepKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
			resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>immark.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* immark.c
 * This is the implementation of the build-in mark message input module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-07-20 by RGerhards (extracted from syslogd.c)
 * This file is under development and has not yet arrived at being fully
 * self-contained and a real object. So far, it is mostly an excerpt
 * of the &quot;old&quot; message code without any modifications. However, it
 * helps to have things at the right place one we go to the meat of it.
 *
 * Copyright 2007-2020 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &quot;dirty.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;msg.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;glbl.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;prop.h&quot;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;immark&quot;)

/* defines */
#define DEFAULT_MARK_PERIOD (20 * 60)

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)

static int iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	const char *pszMarkMsgText;
	size_t lenMarkMsgText;
	uchar *pszBindRuleset;
	ruleset_t *pBindRuleset;
	int flags;
	int bUseMarkFlag;
	int bUseSyslogAPI;
	int iMarkMessagePeriod;
	sbool configSetViaV2Method;
};
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#0',2,'match51-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;markmessagetext&quot;, eCmdHdlrString, 0 },
	{ &quot;use.syslogcall&quot;, eCmdHdlrBinary, 0 },
	{ &quot;use.markflag&quot;, eCmdHdlrBinary, 0 },
	{ &quot;interval&quot;, eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};


static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */</B></FONT>
static prop_t *pInternalInputName = NULL;


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINafterRun
CODESTARTafterRun
ENDafterRun


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	pModConf-&gt;pszMarkMsgText = NULL;
	pModConf-&gt;iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	pModConf-&gt;bUseSyslogAPI = 1;
	pModConf-&gt;bUseMarkFlag = 1;
	pModConf-&gt;pszBindRuleset = NULL;
	pModConf-&gt;pBindRuleset = NULL;
	loadModConf-&gt;configSetViaV2Method = 0;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad

static rsRetVal
checkRuleset(modConfData_t *modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;

	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;

	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		LogError(0, NO_ERRCODE, &quot;immark: ruleset '%s' not found - &quot;
				&quot;using default ruleset instead&quot;, modConf-&gt;pszBindRuleset);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;

finalize_it:
	RETiRet;
<A NAME="1"></A>}

BEGINsetModCnf
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#1',2,'match51-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for immark:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
<A NAME="3"></A>		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;interval&quot;)) {
			loadModConf-&gt;iMarkMessagePeriod = (int) pvals[i].val.d.n;</B></FONT><FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#3',2,'match51-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>
		} else if(!strcmp(modpblk.descr[i].name, &quot;use.syslogcall&quot;)) {
			loadModConf-&gt;bUseSyslogAPI = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;use.markflag&quot;)) {
<A NAME="2"></A>			loadModConf-&gt;bUseMarkFlag = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#2',2,'match51-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;markmessagetext&quot;)) {
			loadModConf-&gt;pszMarkMsgText = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;immark: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

	/* disable legacy module-global config directives */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		pModConf-&gt;iMarkMessagePeriod = iMarkMessagePeriod;</B></FONT>
	}
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
	pModConf-&gt;flags = (pModConf-&gt;bUseMarkFlag) ? MARK : 0;
	if(pModConf-&gt;pszMarkMsgText == NULL) {
		pModConf-&gt;pszMarkMsgText = strdup(&quot;-- MARK --&quot;);
	}
	pModConf-&gt;lenMarkMsgText = strlen(pModConf-&gt;pszMarkMsgText);
	if(pModConf-&gt;pszBindRuleset != NULL) {
		checkRuleset(pModConf);
		if(pModConf-&gt;bUseSyslogAPI) {
			LogError(0, NO_ERRCODE, &quot;immark: ruleset specified, but configured to log &quot;
				&quot;via syslog call - switching to rsyslog-internal logging&quot;);
			pModConf-&gt;bUseSyslogAPI = 0;
		}
	}
	if(pModConf-&gt;iMarkMessagePeriod == 0) {
		LogError(0, NO_ERRCODE, &quot;immark: mark message period must not be 0, can not run&quot;);
		ABORT_FINALIZE(RS_RET_NO_RUN);	/* we can not run with this error */
	}
finalize_it:
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	MarkInterval = pModConf-&gt;iMarkMessagePeriod;
	DBGPRINTF(&quot;immark set MarkInterval to %d\n&quot;, MarkInterval);
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


static rsRetVal
injectMarkMessage(const int pri)
{
	smsg_t *pMsg;
	DEFiRet;

	CHKiRet(msgConstruct(&amp;pMsg));
	pMsg-&gt;msgFlags  = loadModConf-&gt;flags;
	MsgSetInputName(pMsg, pInternalInputName);
	MsgSetRawMsg(pMsg, loadModConf-&gt;pszMarkMsgText,loadModConf-&gt;lenMarkMsgText);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
	MsgSetMSGoffs(pMsg, 0);
	MsgSetTAG(pMsg, (const uchar*)&quot;rsyslogd:&quot;, sizeof(&quot;rsyslogd:&quot;)-1);
	msgSetPRI(pMsg, pri);
	MsgSetRuleset(pMsg, loadModConf-&gt;pBindRuleset);
	submitMsg2(pMsg);
finalize_it:
	RETiRet;
}

/* This function is called to gather input. It must terminate only
 * a) on failure (iRet set accordingly)
 * b) on termination of the input module (as part of the unload process)
 * Code begun 2007-12-12 rgerhards
 *
 * This code must simply spawn emit a mark message at each mark interval.
 * We are running on our own thread, so this is extremely easy: we just
 * sleep MarkInterval seconds and each time we awake, we inject the message.
 * Please note that we do not do the other fancy things that sysklogd
 * (and pre 1.20.2 releases of rsyslog) did in mark procesing. They simply
 * do not belong here.
 */
BEGINrunInput
CODESTARTrunInput
	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so. This, however, is handled by the framework,
	 * right into the sleep below.
	 */
	while(1) {
		srSleep(MarkInterval, 0); /* seconds, micro seconds */

		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		dbgprintf(&quot;immark: injecting mark message\n&quot;);
		if(loadModConf-&gt;bUseSyslogAPI) {
			logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO,
				(uchar*)loadModConf-&gt;pszMarkMsgText, loadModConf-&gt;flags);
		} else {
			injectMarkMessage(LOG_SYSLOG|LOG_INFO);
		}
	}
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINmodExit
CODESTARTmodExit
	if(pInternalInputName != NULL)
		prop.Destruct(&amp;pInternalInputName);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	return RS_RET_OK;
}

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInternalInputName));
	CHKiRet(prop.SetString(pInternalInputName, UCHAR_CONSTANT(&quot;immark&quot;), sizeof(&quot;immark&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInternalInputName));

	/* legacy config handlers */
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;markmessageperiod&quot;, 0, eCmdHdlrInt, NULL,
		&amp;iMarkMessagePeriod, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
