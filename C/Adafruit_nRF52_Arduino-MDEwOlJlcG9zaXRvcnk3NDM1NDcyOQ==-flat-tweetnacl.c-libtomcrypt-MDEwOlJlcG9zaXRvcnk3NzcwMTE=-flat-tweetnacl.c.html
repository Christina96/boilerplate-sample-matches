
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 194, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tweetnacl.c</h3>
            <pre><code>1  #include <string.h>
2  #include <stdint.h>
3  #include "../crypto.h"
4  #define FOR(i,n) for (i = 0;i < n;++i)
5  typedef unsigned char u8;
6  typedef unsigned short u16;
7  typedef short i16;
8  typedef unsigned long u32;
9  typedef unsigned long long u64;
10  typedef long i32;
11  typedef long long i64;
12  typedef i64 gf[16];
13  extern void randombytes(u8 *,u64);
14  static const u8
15    _0[16],
16    _9[32] = {9};
17  static const gf
18    gf0,
<span onclick='openModal()' class='match'>19    gf1 = {1},
20    _121665 = {0xDB41,1},
21    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
22    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
23    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
24    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
25    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
26  static inline u32 L32(u32 x,int c) { return (x << c) | ((x&0xffffffff) >> (32 - c)); }
</span>27  static u32 ld32(const u8 *x)
28  {
29    u32 u = x[3];
30    u = (u<<8)|x[2];
31    u = (u<<8)|x[1];
32    return (u<<8)|x[0];
33  }
34  static u64 dl64(const u8 *x)
35  {
36    u64 i,u=0;
37    FOR(i,8) u=(u<<8)|x[i];
38    return u;
39  }
40  static void st32(u8 *x,u32 u)
41  {
42    int i;
43    FOR(i,4) { x[i] = u; u >>= 8; }
44  }
45  static void ts64(u8 *x,u64 u)
46  {
47    int i;
48    for (i = 7;i >= 0;--i) { x[i] = u; u >>= 8; }
49  }
50  static inline int vn(const u8 *x,const u8 *y,int n)
51  {
52    return memcmp(x,y,n);
53  }
54  int inline crypto_verify_16(const u8 *x,const u8 *y)
55  {
56    return vn(x,y,16);
57  }
58  int inline crypto_verify_32(const u8 *x,const u8 *y)
59  {
60    return vn(x,y,32);
61  }
62  static void crypto_core_chacha20(u8 *out,const u8 *in,const u8 *k,const u8 *c)
63  {
64    u32 x[16],y[16],t[4];
65    int i,j,m;
66    FOR(i,4) {
67      x[i] = ld32(c+4*i);
68      x[4+i] = ld32(k+4*i);
69      x[8+i] = ld32(k+16+4*i);
70      x[12+(2+i)%4] = ld32(in+4*i);
71    }
72    FOR(i,16) y[i] = x[i];
73    FOR(i,10) {
74      FOR(j,4) {
75        FOR(m,4) t[m] = x[(j+4*m)%16];
76        t[3] = L32(t[3] ^ (t[0] += t[1]), 16);
77        t[1] = L32(t[1] ^ (t[2] += t[3]), 12);
78        t[3] = L32(t[3] ^ (t[0] += t[1]),  8);
79        t[1] = L32(t[1] ^ (t[2] += t[3]),  7);
80        FOR(m,4) x[(j+4*m)%16] = t[m];
81      }
82      FOR(j,4) {
83        FOR(m,4) t[m] = x[(4*m+(j+m)%4)%16];
84        t[3] = L32(t[3] ^ (t[0] += t[1]), 16);
85        t[1] = L32(t[1] ^ (t[2] += t[3]), 12);
86        t[3] = L32(t[3] ^ (t[0] += t[1]),  8);
87        t[1] = L32(t[1] ^ (t[2] += t[3]),  7);
88        FOR(m,4) x[(4*m+(j+m)%4)%16] = t[m];
89      }
90    }
91    FOR(i,16) st32(out + 4 * i,x[i] + y[i]);
92  }
93  static const u8 sigma[16] = "expand 32-byte k";
94  int crypto_stream_chacha20_xor(u8 *c,const u8 *m,u64 b,const u8 *n,const u8 *k,const u8 v)
95  {
96    u8 z[16],x[64];
97    u32 u,i;
98    if (!b) return 0;
99    FOR(i,16) z[i] = 0;
100    FOR(i,8) z[i] = n[i];
101    z[8] = v;
102    while (b >= 64) {
103      crypto_core_chacha20(x,z,k,sigma);
104      FOR(i,64) c[i] = (m?m[i]:0) ^ x[i];
105      u = 1;
106      for (i = 8;i < 16;++i) {
107        u += (u32) z[i];
108        z[i] = u;
109        u >>= 8;
110      }
111      b -= 64;
112      c += 64;
113      if (m) m += 64;
114    }
115    if (b) {
116      crypto_core_chacha20(x,z,k,sigma);
117      FOR(i,b) c[i] = (m?m[i]:0) ^ x[i];
118    }
119    return 0;
120  }
121  static void add1305(u32 *h,const u32 *c)
122  {
123    u32 j,u = 0;
124    FOR(j,17) {
125      u += h[j] + c[j];
126      h[j] = u & 255;
127      u >>= 8;
128    }
129  }
130  static const u32 minusp[17] = {
131    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252
132  } ;
133  int crypto_onetimeauth_poly1305(u8 *out,const u8 *m,u32 n,const u8 *k)
134  {
135    u32 s,i,j,u,x[17],r[17],h[17],c[17],g[17];
136    FOR(j,17) r[j]=h[j]=0;
137    FOR(j,16) r[j]=k[j];
138    r[3]&=15;
139    r[4]&=252;
140    r[7]&=15;
141    r[8]&=252;
142    r[11]&=15;
143    r[12]&=252;
144    r[15]&=15;
145    while (n > 0) {
146      FOR(j,17) c[j] = 0;
147      for (j = 0;(j < 16) && (j < n);++j) c[j] = m[j];
148      c[j] = 1;
149      m += j; n -= j;
150      add1305(h,c);
151      FOR(i,17) {
152        x[i] = 0;
153        for(j=0;j<=i;j++) x[i] += h[j] * r[i - j];
154        for(;j<17;j++) x[i] += h[j] * 320 * r[i + 17 - j];
155      }
156      FOR(i,17) h[i] = x[i];
157      u = 0;
158      FOR(j,16) {
159        u += h[j];
160        h[j] = u & 255;
161        u >>= 8;
162      }
163      u += h[16]; h[16] = u & 3;
164      u = 5 * (u >> 2);
165      FOR(j,16) {
166        u += h[j];
167        h[j] = u & 255;
168        u >>= 8;
169      }
170      u += h[16]; h[16] = u;
171    }
172    FOR(j,17) g[j] = h[j];
173    add1305(h,minusp);
174    s = -(h[16] >> 7);
175    FOR(j,17) h[j] ^= s & (g[j] ^ h[j]);
176    FOR(j,16) c[j] = k[j + 16];
177    c[16] = 0;
178    add1305(h,c);
179    FOR(j,16) out[j] = h[j];
180    return 0;
181  }
182  int crypto_onetimeauth_poly1305_verify(const u8 *h,const u8 *m,u32 n,const u8 *k)
183  {
184    u8 x[16];
185    crypto_onetimeauth_poly1305(x,m,n,k);
186    return crypto_verify_16(h,x);
187  }
188  static inline void set25519(gf r, const gf a)
189  {
190    int i;
191    FOR(i,16) r[i]=a[i];
192  }
193  #define MUL38(V) ((((((V) << 3) + (V)) << 1) + (V)) << 1)
194  static void car25519(gf o)
195  {
196    i64 c=0;
197    unsigned i;
198    FOR(i,16) {
199      i64 v=o[i]+c;
200      o[i]=v&0xFFFF;
201      c=v>>16;
202    }
203    while (c) {
204      c=MUL38(c);
205      for(i = 0; c && i < 16; i++) {
206        i64 v=o[i]+c;
207        o[i]=v&0xFFFF;
208        c=v>>16;
209      }
210    }
211  }
212  static inline void sel25519(gf p,gf q)
213  {
214     gf t;
215     memcpy(t,p,sizeof(t));
216     memcpy(p,q,sizeof(t));
217     memcpy(q,t,sizeof(t));
218  }
219  static void pack25519(u8 *o,const gf n)
220  {
221    int i,j,b;
222    gf m,t;
223    FOR(i,16) t[i]=n[i];
224    car25519(t);
225    FOR(j,2) {
226      m[0]=t[0]-0xffed;
227      for(i=1;i<15;i++) {
228        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
229        m[i-1]&=0xffff;
230      }
231      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
232      b=(m[15]>>16)&1;
233      m[14]&=0xffff;
234      if (!b) sel25519(t,m);
235    }
236    FOR(i,16) {
237      o[2*i]=t[i]&0xff;
238      o[2*i+1]=t[i]>>8;
239    }
240  }
241  static int neq25519(const gf a, const gf b)
242  {
243    u8 c[32],d[32];
244    pack25519(c,a);
245    pack25519(d,b);
246    return crypto_verify_32(c,d);
247  }
248  static u8 par25519(const gf a)
249  {
250    u8 d[32];
251    pack25519(d,a);
252    return d[0]&1;
253  }
254  static void unpack25519(gf o, const u8 *n)
255  {
256    unsigned i;
257    FOR(i,16) o[i]=(i64)(n[2*i]|((u32)n[2*i+1]<<8));
258    o[15]&=0x7fff;
259  }
260  static inline void A(gf o,const gf a,const gf b)
261  {
262    unsigned i;
263    FOR(i,16) o[i]=a[i]+b[i];
264  }
265  static inline void Z(gf o,const gf a,const gf b)
266  {
267    unsigned i;
268    FOR(i,16) o[i]=a[i]-b[i];
269  }
270  static inline void CS(u16 s[16], const gf o)
271  {
272    i64 c=0;
273    unsigned i;
274    FOR(i,16) {
275      i64 v=o[i]+c;
276      s[i]=(u16)v;
277      c=v>>16;
278    }
279    while (c) {
280      c=MUL38(c);
281      for(i = 0; c && i < 16; i++) {
282        i64 v=s[i]+c;
283        s[i]=(u16)v;
284        c=v>>16;
285      }
286    }
287  }
288  #if defined(USE_UNACL_SCALARMULT)
289  extern void fe25519_mul(u16 o[16], u16 x[16], u16 y[16]);
290  extern void fe25519_square(u16 o[16], u16 x[16]);
291  static void M(gf o, const gf a, const gf b)
292  {
293    unsigned i;
294    u16 as[16];
295    u16 bs[16];
296    u16 os[16];
297    CS(as, a);
298    CS(bs, b);
299    fe25519_mul(os, as, bs);
300    FOR(i,16) o[i] = os[i];
301  }
302  static void S(gf o, const gf a)
303  {
304    unsigned i;
305    u16 as[16];
306    u16 os[16];
307    CS(as, a);
308    fe25519_square(os, as);
309    FOR(i,16) o[i] = os[i];
310  }
311  #else
312  static void M(gf o,const gf a,const gf b)
313  {
314    unsigned i,j;
315    u16 as[16];
316    u16 bs[16];
317    CS(as, a);
318    CS(bs, b);
319    i64 t[31],v;
320    FOR(i,31) t[i]=0;
321    i64* pt = &t[15];
322    for (u16* asp = &as[15]; asp >= as; asp--, pt--) {
323      u32 asi = *asp;
324      i64* ppt = pt + 15;
325      for (u16* bsp = &bs[15]; bsp >= bs; bsp--, ppt--) {
326        v=*ppt;
327        v+=(i64)(asi * (u32)*bsp);
328        *ppt=v;
329      }
330    }
331    FOR(i,15) { v=t[i+16]; v=MUL38(v); o[i]=t[i]+v; }
332    o[15]=t[15];
333  }
334  static void S(gf o,const gf a)
335  {
336    unsigned i,j;
337    u16 as[16];
338    CS(as, a);
339    i64 t[31],v;
340    FOR(i,31) t[i]=0;
341    FOR(i,16) {
342      u32 ai = (u32)as[i];
343      t[i<<1]+=(u32)(ai*ai);
344      for(j=i+1;j<16;j++) {
345        v=t[i+j];
346        v+=((i64)(ai*(u32)as[j]))<<1;
347        t[i+j]=v;
348      }
349    }
350    FOR(i,15) { v=t[i+16]; v=MUL38(v); o[i]=t[i]+v; }
351    o[15]=t[15];
352  }
353  #endif
354  static void inv25519(gf o,const gf i)
355  {
356    gf c;
357    int a;
358    FOR(a,16) c[a]=i[a];
359    for(a=249;a;a--) {
360      S(c,c);
361      M(c,c,i);
362    }
363    S(c,c);
364    S(c,c);
365    M(c,c,i);
366    S(c,c);
367    S(c,c);
368    M(c,c,i);
369    S(c,c);
370    M(c,c,i);
371    FOR(a,16) o[a]=c[a];
372  }
373  static void pow2523(gf o,const gf i)
374  {
375    gf c;
376    int a;
377    FOR(a,16) c[a]=i[a];
378    for(a=249;a;a--) {
379      S(c,c);
380      M(c,c,i);
381    }
382    S(c,c);
383    S(c,c);
384    M(c,c,i);
385    FOR(a,16) o[a]=c[a];
386  }
387  #if defined(USE_TWEETNACL_SCALARMULT)
388  int crypto_scalarmult_curve25519(u8 *q,const u8 *n,const u8 *p)
389  {
390    u8 z[32],r;
391    i64 x[80];
392    int i,j;
393    gf a,b,c,d,e,f;
394    FOR(i,31) z[i]=n[i];
395    z[31]=(n[31]&127)|64;
396    z[0]&=248;
397    unpack25519(x,p);
398    FOR(i,16) {
399      b[i]=x[i];
400      d[i]=a[i]=c[i]=0;
401    }
402    a[0]=d[0]=1;
403    for(i=254;i>=0;--i) {
404      r=(z[i>>3]>>(i&7))&1;
405      if(r) {
406        sel25519(a,b);
407        sel25519(c,d);
408      }
409      A(e,a,c);
410      Z(a,a,c);
411      A(c,b,d);
412      Z(b,b,d);
413      S(d,e);
414      S(f,a);
415      M(a,c,a);
416      M(c,b,e);
417      A(e,a,c);
418      Z(a,a,c);
419      S(b,a);
420      Z(c,d,f);
421      M(a,c,_121665);
422      A(a,a,d);
423      M(c,c,a);
424      M(a,d,f);
425      M(d,b,x);
426      S(b,e);
427      if(r) {
428        sel25519(a,b);
429        sel25519(c,d);
430      }
431    }
432    FOR(i,16) {
433      x[i+16]=a[i];
434      x[i+32]=c[i];
435      x[i+48]=b[i];
436      x[i+64]=d[i];
437    }
438    inv25519(x+32,x+32);
439    M(x+16,x+16,x+32);
440    pack25519(q,x+16);
441    return 0;
442  }
443  int crypto_scalarmult_curve25519_base(u8 *q,const u8 *n)
444  {
445    return crypto_scalarmult_curve25519(q,n,_9);
446  }
447  #endif
448  static u64 R(u64 x,int c) { return (x >> c) | (x << (64 - c)); }
449  static u64 Ch(u64 x,u64 y,u64 z) { return (x & y) ^ (~x & z); }
450  static u64 Maj(u64 x,u64 y,u64 z) { return (x & y) ^ (x & z) ^ (y & z); }
451  static u64 Sigma0(u64 x) { return R(x,28) ^ R(x,34) ^ R(x,39); }
452  static u64 Sigma1(u64 x) { return R(x,14) ^ R(x,18) ^ R(x,41); }
453  static u64 sigma0(u64 x) { return R(x, 1) ^ R(x, 8) ^ (x >> 7); }
454  static u64 sigma1(u64 x) { return R(x,19) ^ R(x,61) ^ (x >> 6); }
455  static const u64 K[80] =
456  {
457    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
458    0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
459    0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
460    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
461    0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
462    0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
463    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
464    0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
465    0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
466    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
467    0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
468    0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
469    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
470    0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
471    0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
472    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
473    0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
474    0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
475    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
476    0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
477  };
478  int crypto_hashblocks_sha512(u8 *x,const u8 *m,u64 n)
479  {
480    u64 z[8],b[8],a[8],w[16],t;
481    int i,j;
482    FOR(i,8) z[i] = a[i] = dl64(x + 8 * i);
483    while (n >= 128) {
484      FOR(i,16) w[i] = dl64(m + 8 * i);
485      FOR(i,80) {
486        FOR(j,8) b[j] = a[j];
487        t = a[7] + Sigma1(a[4]) + Ch(a[4],a[5],a[6]) + K[i] + w[i%16];
488        b[7] = t + Sigma0(a[0]) + Maj(a[0],a[1],a[2]);
489        b[3] += t;
490        FOR(j,8) a[(j+1)%8] = b[j];
491        if (i%16 == 15)
492          FOR(j,16)
493            w[j] += w[(j+9)%16] + sigma0(w[(j+1)%16]) + sigma1(w[(j+14)%16]);
494      }
495      FOR(i,8) { a[i] += z[i]; z[i] = a[i]; }
496      m += 128;
497      n -= 128;
498    }
499    FOR(i,8) ts64(x+8*i,z[i]);
500    return n;
501  }
502  static const u8 iv[64] = {
503    0x6a,0x09,0xe6,0x67,0xf3,0xbc,0xc9,0x08,
504    0xbb,0x67,0xae,0x85,0x84,0xca,0xa7,0x3b,
505    0x3c,0x6e,0xf3,0x72,0xfe,0x94,0xf8,0x2b,
506    0xa5,0x4f,0xf5,0x3a,0x5f,0x1d,0x36,0xf1,
507    0x51,0x0e,0x52,0x7f,0xad,0xe6,0x82,0xd1,
508    0x9b,0x05,0x68,0x8c,0x2b,0x3e,0x6c,0x1f,
509    0x1f,0x83,0xd9,0xab,0xfb,0x41,0xbd,0x6b,
510    0x5b,0xe0,0xcd,0x19,0x13,0x7e,0x21,0x79
511  } ;
512  int crypto_hash_sha512(u8 *out,const u8 *m,u64 n)
513  {
514    u8 h[64],x[256];
515    u64 i,b = n;
516    FOR(i,64) h[i] = iv[i];
517    crypto_hashblocks_sha512(h,m,n);
518    m += n;
519    n &= 127;
520    m -= n;
521    FOR(i,256) x[i] = 0;
522    FOR(i,n) x[i] = m[i];
523    x[n] = 128;
524    n = 256-128*(n<112);
525    x[n-9] = b >> 61;
526    ts64(x+n-8,b<<3);
527    crypto_hashblocks_sha512(h,x,n);
528    FOR(i,64) out[i] = h[i];
529    return 0;
530  }
531  static void add(gf p[4],gf q[4])
532  {
533    gf a,b,c,d,t,e,f,g,h;
534    Z(a, p[1], p[0]);
535    Z(t, q[1], q[0]);
536    M(a, a, t);
537    A(b, p[0], p[1]);
538    A(t, q[0], q[1]);
539    M(b, b, t);
540    M(c, p[3], q[3]);
541    M(c, c, D2);
542    M(d, p[2], q[2]);
543    A(d, d, d);
544    Z(e, b, a);
545    Z(f, d, c);
546    A(g, d, c);
547    A(h, b, a);
548    M(p[0], e, f);
549    M(p[1], h, g);
550    M(p[2], g, f);
551    M(p[3], e, h);
552  }
553  static void pack(u8 *r,gf p[4])
554  {
555    gf tx, ty, zi;
556    inv25519(zi, p[2]);
557    M(tx, p[0], zi);
558    M(ty, p[1], zi);
559    pack25519(r, ty);
560    r[31] ^= par25519(tx) << 7;
561  }
562  static void scalarmult(gf p[4],gf q[4],const u8 *s)
563  {
564    set25519(p[0],gf0);
565    set25519(p[1],gf1);
566    set25519(p[2],gf1);
567    set25519(p[3],gf0);
568    for (const u8* sp = &s[31]; sp >= s; --sp) {
569      const u8 si = *sp;
570      for (u8 j = 0x80; j; j>>=1) {
571        if (si & j) {
572          add(p,q);
573          add(q,q);
574        } else {
575          add(q,p);
576          add(p,p);
577        }
578      }
579    }
580  }
581  static void scalarbase(gf p[4],const u8 *s)
582  {
583    gf q[4];
584    set25519(q[0],X);
585    set25519(q[1],Y);
586    set25519(q[2],gf1);
587    M(q[3],X,Y);
588    scalarmult(p,q,s);
589  }
590  int crypto_sign_ed25519_keypair(u8 *pk, u8 *sk)
591  {
592    u8 d[64];
593    gf p[4];
594    int i;
595    randombytes(sk, 32);
596    crypto_hash_sha512(d, sk, 32);
597    d[0] &= 248;
598    d[31] &= 127;
599    d[31] |= 64;
600    scalarbase(p,d);
601    pack(pk,p);
602    FOR(i,32) sk[32 + i] = pk[i];
603    return 0;
604  }
605  static const u64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};
606  static void modL(u8 *r,i64 x[64])
607  {
608    i64 carry,i,j;
609    for (i = 63;i >= 32;--i) {
610      carry = 0;
611      for (j = i - 32;j < i - 12;++j) {
612        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
613        carry = (x[j] + 128) >> 8;
614        x[j] -= carry << 8;
615      }
616      x[j] += carry;
617      x[i] = 0;
618    }
619    carry = 0;
620    FOR(j,32) {
621      x[j] += carry - (x[31] >> 4) * L[j];
622      carry = x[j] >> 8;
623      x[j] &= 255;
624    }
625    FOR(j,32) x[j] -= carry * L[j];
626    FOR(i,32) {
627      x[i+1] += x[i] >> 8;
628      r[i] = x[i] & 255;
629    }
630  }
631  static void reduce(u8 *r)
632  {
633    i64 x[64],i;
634    FOR(i,64) x[i] = (u64) r[i];
635    FOR(i,64) r[i] = 0;
636    modL(r,x);
637  }
638  int crypto_sign_ed25519(u8 *sm,u64 *smlen,const u8 *m,u64 n,const u8 *sk)
639  {
640    u8 d[64],h[64],r[64];
641    i64 i,j,x[64];
642    gf p[4];
643    crypto_hash_sha512(d, sk, 32);
644    d[0] &= 248;
645    d[31] &= 127;
646    d[31] |= 64;
647    *smlen = n+64;
648    FOR(i,n) sm[64 + i] = m[i];
649    FOR(i,32) sm[32 + i] = d[32 + i];
650    crypto_hash_sha512(r, sm+32, n+32);
651    reduce(r);
652    scalarbase(p,r);
653    pack(sm,p);
654    FOR(i,32) sm[i+32] = sk[i+32];
655    crypto_hash_sha512(h,sm,n + 64);
656    reduce(h);
657    FOR(i,64) x[i] = 0;
658    FOR(i,32) x[i] = (u64) r[i];
659    FOR(i,32) FOR(j,32) x[i+j] += h[i] * (u64) d[j];
660    modL(sm + 32,x);
661    return 0;
662  }
663  static int unpackneg(gf r[4],const u8 p[32])
664  {
665    gf t, chk, num, den, den2, den4, den6;
666    set25519(r[2],gf1);
667    unpack25519(r[1],p);
668    S(num,r[1]);
669    M(den,num,D);
670    Z(num,num,r[2]);
671    A(den,r[2],den);
672    S(den2,den);
673    S(den4,den2);
674    M(den6,den4,den2);
675    M(t,den6,num);
676    M(t,t,den);
677    pow2523(t,t);
678    M(t,t,num);
679    M(t,t,den);
680    M(t,t,den);
681    M(r[0],t,den);
682    S(chk,r[0]);
683    M(chk,chk,den);
684    if (neq25519(chk, num)) M(r[0],r[0],I);
685    S(chk,r[0]);
686    M(chk,chk,den);
687    if (neq25519(chk, num)) return -1;
688    if (par25519(r[0]) == (p[31]>>7)) Z(r[0],gf0,r[0]);
689    M(r[3],r[0],r[1]);
690    return 0;
691  }
692  int crypto_sign_ed25519_open(u8 *m,u64 *mlen,const u8 *sm,u64 n,const u8 *pk)
693  {
694    int i;
695    u8 t[32],h[64];
696    gf p[4],q[4];
697    *mlen = -1;
698    if (n < 64) return -1;
699    if (unpackneg(q,pk)) return -1;
700    FOR(i,n) m[i] = sm[i];
701    FOR(i,32) m[i+32] = pk[i];
702    crypto_hash_sha512(h,m,n);
703    reduce(h);
704    scalarmult(p,q,h);
705    scalarbase(q,sm + 32);
706    add(p,q);
707    pack(t,p);
708    n -= 64;
709    if (crypto_verify_32(sm, t)) {
710      FOR(i,n) m[i] = 0;
711      return -1;
712    }
713    FOR(i,n) m[i] = sm[i + 64];
714    *mlen = n;
715    return 0;
716  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #define FOR(i,n) for (i = 0;i < n;++i)
3  #define sv static void
4  typedef unsigned char u8;
5  typedef ulong32 u32;
6  typedef ulong64 u64;
7  typedef long64 i64;
8  typedef i64 gf[16];
9  static const u8
10    nine[32] = {9};
11  static const gf
12    gf0,
<span onclick='openModal()' class='match'>13    gf1 = {1},
14    gf121665 = {0xDB41,1},
15    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
16    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
17    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
18    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
19    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
20  static int vn(const u8 *x,const u8 *y,int n)
</span>21  {
22    int i;
23    u32 d = 0;
24    FOR(i,n) d |= x[i]^y[i];
25    return (1 & ((d - 1) >> 8)) - 1;
26  }
27  static int tweetnacl_crypto_verify_32(const u8 *x,const u8 *y)
28  {
29    return vn(x,y,32);
30  }
31  sv set25519(gf r, const gf a)
32  {
33    int i;
34    FOR(i,16) r[i]=a[i];
35  }
36  sv car25519(gf o)
37  {
38    int i;
39    i64 c;
40    FOR(i,16) {
41      o[i]+=(1LL<<16);
42      c=o[i]>>16;
43      o[(i+1)*(i<15)]+=c-1+37*(c-1)*(i==15);
44      o[i]-=c<<16;
45    }
46  }
47  sv sel25519(gf p,gf q,int b)
48  {
49    i64 t,i,c=~(b-1);
50    FOR(i,16) {
51      t= c&(p[i]^q[i]);
52      p[i]^=t;
53      q[i]^=t;
54    }
55  }
56  sv pack25519(u8 *o,const gf n)
57  {
58    int i,j,b;
59    gf m,t;
60    FOR(i,16) t[i]=n[i];
61    car25519(t);
62    car25519(t);
63    car25519(t);
64    FOR(j,2) {
65      m[0]=t[0]-0xffed;
66      for(i=1;i<15;i++) {
67        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
68        m[i-1]&=0xffff;
69      }
70      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
71      b=(m[15]>>16)&1;
72      m[14]&=0xffff;
73      sel25519(t,m,1-b);
74    }
75    FOR(i,16) {
76      o[2*i]=t[i]&0xff;
77      o[2*i+1]=t[i]>>8;
78    }
79  }
80  static int neq25519(const gf a, const gf b)
81  {
82    u8 c[32],d[32];
83    pack25519(c,a);
84    pack25519(d,b);
85    return tweetnacl_crypto_verify_32(c,d);
86  }
87  static u8 par25519(const gf a)
88  {
89    u8 d[32];
90    pack25519(d,a);
91    return d[0]&1;
92  }
93  sv unpack25519(gf o, const u8 *n)
94  {
95    int i;
96    FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
97    o[15]&=0x7fff;
98  }
99  sv A(gf o,const gf a,const gf b)
100  {
101    int i;
102    FOR(i,16) o[i]=a[i]+b[i];
103  }
104  sv Z(gf o,const gf a,const gf b)
105  {
106    int i;
107    FOR(i,16) o[i]=a[i]-b[i];
108  }
109  sv M(gf o,const gf a,const gf b)
110  {
111    i64 i,j,t[31];
112    FOR(i,31) t[i]=0;
113    FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
114    FOR(i,15) t[i]+=38*t[i+16];
115    FOR(i,16) o[i]=t[i];
116    car25519(o);
117    car25519(o);
118  }
119  sv S(gf o,const gf a)
120  {
121    M(o,a,a);
122  }
123  sv inv25519(gf o,const gf i)
124  {
125    gf c;
126    int a;
127    FOR(a,16) c[a]=i[a];
128    for(a=253;a>=0;a--) {
129      S(c,c);
130      if(a!=2&&a!=4) M(c,c,i);
131    }
132    FOR(a,16) o[a]=c[a];
133  }
134  sv pow2523(gf o,const gf i)
135  {
136    gf c;
137    int a;
138    FOR(a,16) c[a]=i[a];
139    for(a=250;a>=0;a--) {
140      S(c,c);
141      if(a!=1) M(c,c,i);
142    }
143    FOR(a,16) o[a]=c[a];
144  }
145  int tweetnacl_crypto_scalarmult(u8 *q,const u8 *n,const u8 *p)
146  {
147    u8 z[32];
148    i64 x[80],r,i;
149    gf a,b,c,d,e,f;
150    FOR(i,31) z[i]=n[i];
151    z[31]=(n[31]&127)|64;
152    z[0]&=248;
153    unpack25519(x,p);
154    FOR(i,16) {
155      b[i]=x[i];
156      d[i]=a[i]=c[i]=0;
157    }
158    a[0]=d[0]=1;
159    for(i=254;i>=0;--i) {
160      r=(z[i>>3]>>(i&7))&1;
161      sel25519(a,b,r);
162      sel25519(c,d,r);
163      A(e,a,c);
164      Z(a,a,c);
165      A(c,b,d);
166      Z(b,b,d);
167      S(d,e);
168      S(f,a);
169      M(a,c,a);
170      M(c,b,e);
171      A(e,a,c);
172      Z(a,a,c);
173      S(b,a);
174      Z(c,d,f);
175      M(a,c,gf121665);
176      A(a,a,d);
177      M(c,c,a);
178      M(a,d,f);
179      M(d,b,x);
180      S(b,e);
181      sel25519(a,b,r);
182      sel25519(c,d,r);
183    }
184    FOR(i,16) {
185      x[i+16]=a[i];
186      x[i+32]=c[i];
187      x[i+48]=b[i];
188      x[i+64]=d[i];
189    }
190    inv25519(x+32,x+32);
191    M(x+16,x+16,x+32);
192    pack25519(q,x+16);
193    return 0;
194  }
195  int tweetnacl_crypto_scalarmult_base(u8 *q,const u8 *n)
196  {
197    return tweetnacl_crypto_scalarmult(q,n,nine);
198  }
199  static LTC_INLINE int tweetnacl_crypto_hash_ctx(u8 *out,const u8 *m,u64 n,const u8 *ctx,u32 cs)
200  {
201    unsigned long len = 64;
202    int hash_idx = find_hash("sha512");
203    if (n > ULONG_MAX) return CRYPT_OVERFLOW;
204    if(cs == 0)
205      return hash_memory(hash_idx, m, n, out, &len);
206    return hash_memory_multi(hash_idx, out, &len, ctx, cs, m, n, LTC_NULL);
207  }
208  static LTC_INLINE int tweetnacl_crypto_hash(u8 *out,const u8 *m,u64 n)
209  {
210    return tweetnacl_crypto_hash_ctx(out, m, n, NULL, 0);
211  }
212  sv add(gf p[4],gf q[4])
213  {
214    gf a,b,c,d,t,e,f,g,h;
215    Z(a, p[1], p[0]);
216    Z(t, q[1], q[0]);
217    M(a, a, t);
218    A(b, p[0], p[1]);
219    A(t, q[0], q[1]);
220    M(b, b, t);
221    M(c, p[3], q[3]);
222    M(c, c, D2);
223    M(d, p[2], q[2]);
224    A(d, d, d);
225    Z(e, b, a);
226    Z(f, d, c);
227    A(g, d, c);
228    A(h, b, a);
229    M(p[0], e, f);
230    M(p[1], h, g);
231    M(p[2], g, f);
232    M(p[3], e, h);
233  }
234  sv cswap(gf p[4],gf q[4],u8 b)
235  {
236    int i;
237    FOR(i,4)
238      sel25519(p[i],q[i],b);
239  }
240  sv pack(u8 *r,gf p[4])
241  {
242    gf tx, ty, zi;
243    inv25519(zi, p[2]);
244    M(tx, p[0], zi);
245    M(ty, p[1], zi);
246    pack25519(r, ty);
247    r[31] ^= par25519(tx) << 7;
248  }
249  sv scalarmult(gf p[4],gf q[4],const u8 *s)
250  {
251    int i;
252    set25519(p[0],gf0);
253    set25519(p[1],gf1);
254    set25519(p[2],gf1);
255    set25519(p[3],gf0);
256    for (i = 255;i >= 0;--i) {
257      u8 b = (s[i/8]>>(i&7))&1;
258      cswap(p,q,b);
259      add(q,p);
260      add(p,p);
261      cswap(p,q,b);
262    }
263  }
264  sv scalarbase(gf p[4],const u8 *s)
265  {
266    gf q[4];
267    set25519(q[0],X);
268    set25519(q[1],Y);
269    set25519(q[2],gf1);
270    M(q[3],X,Y);
271    scalarmult(p,q,s);
272  }
273  int tweetnacl_crypto_sk_to_pk(u8 *pk, const u8 *sk)
274  {
275    u8 d[64];
276    gf p[4];
277    tweetnacl_crypto_hash(d, sk, 32);
278    d[0] &= 248;
279    d[31] &= 127;
280    d[31] |= 64;
281    scalarbase(p,d);
282    pack(pk,p);
283    return 0;
284  }
285  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, u8 *pk, u8 *sk)
286  {
287    int err;
288    if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
289       return err;
290    }
291    if (prng_descriptor[wprng].read(sk,32, prng) != 32) {
292       return CRYPT_ERROR_READPRNG;
293    }
294    if ((err = tweetnacl_crypto_sk_to_pk(pk, sk)) != CRYPT_OK) {
295       return err;
296    }
297    return CRYPT_OK;
298  }
299  static const u64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};
300  sv modL(u8 *r,i64 x[64])
301  {
302    i64 carry,i,j;
303    for (i = 63;i >= 32;--i) {
304      carry = 0;
305      for (j = i - 32;j < i - 12;++j) {
306        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
307        carry = (x[j] + 128) >> 8;
308        x[j] -= carry << 8;
309      }
310      x[j] += carry;
311      x[i] = 0;
312    }
313    carry = 0;
314    FOR(j,32) {
315      x[j] += carry - (x[31] >> 4) * L[j];
316      carry = x[j] >> 8;
317      x[j] &= 255;
318    }
319    FOR(j,32) x[j] -= carry * L[j];
320    FOR(i,32) {
321      x[i+1] += x[i] >> 8;
322      r[i] = x[i] & 255;
323    }
324  }
325  sv reduce(u8 *r)
326  {
327    i64 x[64],i;
328    FOR(i,64) x[i] = (u64) r[i];
329    FOR(i,64) r[i] = 0;
330    modL(r,x);
331  }
332  int tweetnacl_crypto_sign(u8 *sm,u64 *smlen,const u8 *m,u64 mlen,const u8 *sk,const u8 *pk, const u8 *ctx, u64 cs)
333  {
334    u8 d[64],h[64],r[64];
335    i64 i,j,x[64];
336    gf p[4];
337    tweetnacl_crypto_hash(d, sk, 32);
338    d[0] &= 248;
339    d[31] &= 127;
340    d[31] |= 64;
341    *smlen = mlen+64;
342    FOR(i,(i64)mlen) sm[64 + i] = m[i];
343    FOR(i,32) sm[32 + i] = d[32 + i];
344    tweetnacl_crypto_hash_ctx(r, sm+32, mlen+32,ctx,cs);
345    reduce(r);
346    scalarbase(p,r);
347    pack(sm,p);
348    FOR(i,32) sm[i+32] = pk[i];
349    tweetnacl_crypto_hash_ctx(h,sm,mlen + 64,ctx,cs);
350    reduce(h);
351    FOR(i,64) x[i] = 0;
352    FOR(i,32) x[i] = (u64) r[i];
353    FOR(i,32) FOR(j,32) x[i+j] += h[i] * (u64) d[j];
354    modL(sm + 32,x);
355    return 0;
356  }
357  static int unpackneg(gf r[4],const u8 p[32])
358  {
359    gf t, chk, num, den, den2, den4, den6;
360    set25519(r[2],gf1);
361    unpack25519(r[1],p);
362    S(num,r[1]);
363    M(den,num,D);
364    Z(num,num,r[2]);
365    A(den,r[2],den);
366    S(den2,den);
367    S(den4,den2);
368    M(den6,den4,den2);
369    M(t,den6,num);
370    M(t,t,den);
371    pow2523(t,t);
372    M(t,t,num);
373    M(t,t,den);
374    M(t,t,den);
375    M(r[0],t,den);
376    S(chk,r[0]);
377    M(chk,chk,den);
378    if (neq25519(chk, num)) M(r[0],r[0],I);
379    S(chk,r[0]);
380    M(chk,chk,den);
381    if (neq25519(chk, num)) return -1;
382    if (par25519(r[0]) == (p[31]>>7)) Z(r[0],gf0,r[0]);
383    M(r[3],r[0],r[1]);
384    return 0;
385  }
386  int tweetnacl_crypto_sign_open(int *stat, u8 *m,u64 *mlen,const u8 *sm,u64 smlen,const u8 *ctx,u64 cs,const u8 *pk)
387  {
388    u64 i;
389    u8 s[32],t[32],h[64];
390    gf p[4],q[4];
391    *stat = 0;
392    if (*mlen < smlen) return CRYPT_BUFFER_OVERFLOW;
393    *mlen = -1;
394    if (smlen < 64) return CRYPT_INVALID_ARG;
395    if (unpackneg(q,pk)) return CRYPT_ERROR;
396    XMEMMOVE(m,sm,smlen);
397    XMEMMOVE(s,m + 32,32);
398    XMEMMOVE(m + 32,pk,32);
399    tweetnacl_crypto_hash_ctx(h,m,smlen,ctx,cs);
400    reduce(h);
401    scalarmult(p,q,h);
402    scalarbase(q,s);
403    add(p,q);
404    pack(t,p);
405    smlen -= 64;
406    if (tweetnacl_crypto_verify_32(sm, t)) {
407      FOR(i,smlen) m[i] = 0;
408      zeromem(m, smlen);
409      return CRYPT_OK;
410    }
411    *stat = 1;
412    XMEMMOVE(m,m + 64,smlen);
413    *mlen = smlen;
414    return CRYPT_OK;
415  }
416  int tweetnacl_crypto_ph(u8 *out,const u8 *msg,u64 msglen)
417  {
418    return tweetnacl_crypto_hash(out, msg, msglen);
419  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-tweetnacl.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</div>
                </div>
                <div class="column column_space"><pre><code>19    gf1 = {1},
20    _121665 = {0xDB41,1},
21    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
22    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
23    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
24    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
25    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
26  static inline u32 L32(u32 x,int c) { return (x << c) | ((x&0xffffffff) >> (32 - c)); }
</pre></code></div>
                <div class="column column_space"><pre><code>13    gf1 = {1},
14    gf121665 = {0xDB41,1},
15    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
16    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
17    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
18    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
19    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
20  static int vn(const u8 *x,const u8 *y,int n)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    