
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.587443946188341%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft.h</h3>
            <pre><code>1  #ifndef __RDFT_H__
2  #define __RDFT_H__
3  #include "kernel/ifftw.h"
4  #include "rdft/codelet-rdft.h"
5  #ifdef __cplusplus
6  extern "C"
7  {
8  #endif &bsol;* __cplusplus */
9  typedef struct {
10       problem super;
11       tensor *sz, *vecsz;
12       R *I, *O;
13  #if defined(STRUCT_HACK_KR)
14       rdft_kind kind[1];
15  #elif defined(STRUCT_HACK_C99)
16       rdft_kind kind[];
17  #else
18       rdft_kind *kind;
19  #endif
<span onclick='openModal()' class='match'>20  } problem_rdft;
21  void X(rdft_zerotens)(tensor *sz, R *I);
22  problem *X(mkproblem_rdft)(const tensor *sz, const tensor *vecsz,
23  			   R *I, R *O, const rdft_kind *kind);
24  problem *X(mkproblem_rdft_d)(tensor *sz, tensor *vecsz,
25  			     R *I, R *O, const rdft_kind *kind);
26  problem *X(mkproblem_rdft_0_d)(tensor *vecsz, R *I, R *O);
27  problem *X(mkproblem_rdft_1)(const tensor *sz, const tensor *vecsz,
28  			     R *I, R *O, rdft_kind kind);
29  problem *X(mkproblem_rdft_1_d)(tensor *sz, tensor *vecsz,
30  			       R *I, R *O, rdft_kind kind);
31  const char *X(rdft_kind_str)(rdft_kind kind);
</span>32  void X(rdft_solve)(const plan *ego_, const problem *p_);
33  typedef void (*rdftapply) (const plan *ego, R *I, R *O);
34  typedef struct {
35       plan super;
36       rdftapply apply;
37  } plan_rdft;
38  plan *X(mkplan_rdft)(size_t size, const plan_adt *adt, rdftapply apply);
39  #define MKPLAN_RDFT(type, adt, apply) \
40    (type *)X(mkplan_rdft)(sizeof(type), adt, apply)
41  solver *X(mksolver_rdft_r2c_direct)(kr2c k, const kr2c_desc *desc);
42  solver *X(mksolver_rdft_r2c_directbuf)(kr2c k, const kr2c_desc *desc);
43  solver *X(mksolver_rdft_r2r_direct)(kr2r k, const kr2r_desc *desc);
44  void X(rdft_rank0_register)(planner *p);
45  void X(rdft_vrank3_transpose_register)(planner *p);
46  void X(rdft_rank_geq2_register)(planner *p);
47  void X(rdft_indirect_register)(planner *p);
48  void X(rdft_vrank_geq1_register)(planner *p);
49  void X(rdft_buffered_register)(planner *p);
50  void X(rdft_generic_register)(planner *p);
51  void X(rdft_rader_hc2hc_register)(planner *p);
52  void X(rdft_dht_register)(planner *p);
53  void X(dht_r2hc_register)(planner *p);
54  void X(dht_rader_register)(planner *p);
55  void X(dft_r2hc_register)(planner *p);
56  void X(rdft_nop_register)(planner *p);
57  void X(hc2hc_generic_register)(planner *p);
58  typedef struct {
59       problem super;
60       tensor *sz;
61       tensor *vecsz;
62       R *r0, *r1;
63       R *cr, *ci;
64       rdft_kind kind; &bsol;* assert(kind < DHT) */
65  } problem_rdft2;
66  problem *X(mkproblem_rdft2)(const tensor *sz, const tensor *vecsz,
67  			    R *r0, R *r1, R *cr, R *ci, rdft_kind kind);
68  problem *X(mkproblem_rdft2_d)(tensor *sz, tensor *vecsz,
69  			      R *r0, R *r1, R *cr, R *ci, rdft_kind kind);
70  problem *X(mkproblem_rdft2_d_3pointers)(tensor *sz, tensor *vecsz,
71  					R *r, R *cr, R *ci, rdft_kind kind);
72  int X(rdft2_inplace_strides)(const problem_rdft2 *p, int vdim);
73  INT X(rdft2_tensor_max_index)(const tensor *sz, rdft_kind k);
74  void X(rdft2_strides)(rdft_kind kind, const iodim *d, INT *rs, INT *cs);
75  INT X(rdft2_complex_n)(INT real_n, rdft_kind kind);
76  void X(rdft2_verify)(plan *pln, const problem_rdft2 *p, int rounds);
77  void X(rdft2_solve)(const plan *ego_, const problem *p_);
78  typedef void (*rdft2apply) (const plan *ego, R *r0, R *r1, R *cr, R *ci);
79  typedef struct {
80       plan super;
81       rdft2apply apply;
82  } plan_rdft2;
83  plan *X(mkplan_rdft2)(size_t size, const plan_adt *adt, rdft2apply apply);
84  #define MKPLAN_RDFT2(type, adt, apply) \
85    (type *)X(mkplan_rdft2)(sizeof(type), adt, apply)
86  solver *X(mksolver_rdft2_direct)(kr2c k, const kr2c_desc *desc);
87  void X(rdft2_vrank_geq1_register)(planner *p);
88  void X(rdft2_buffered_register)(planner *p);
89  void X(rdft2_rdft_register)(planner *p);
90  void X(rdft2_nop_register)(planner *p);
91  void X(rdft2_rank0_register)(planner *p);
92  void X(rdft2_rank_geq2_register)(planner *p);
93  void X(rdft_conf_standard)(planner *p);
94  #ifdef __cplusplus
95  }  &bsol;* extern "C" */
96  #endif &bsol;* __cplusplus */
97  #endif &bsol;* __RDFT_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</h3>
            <pre><code>1  #ifndef NRF_POWER_H__
2  #define NRF_POWER_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(POWER_INTENSET_SLEEPENTER_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_POWER_HAS_SLEEPEVT 1
9  #else
10  #define NRF_POWER_HAS_SLEEPEVT 0
11  #endif
12  #if defined(POWER_USBREGSTATUS_VBUSDETECT_Msk) || defined(__NRFX_DOXYGEN__)
13  #define NRF_POWER_HAS_USBREG 1
14  #else
15  #define NRF_POWER_HAS_USBREG 0
16  #endif
17  #if defined(POWER_DCDCEN0_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
18  #define NRF_POWER_HAS_DCDCEN_VDDH 1
19  #else
20  #define NRF_POWER_HAS_DCDCEN_VDDH 0
21  #endif
22  #if defined(POWER_DCDCEN_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
23  #define NRF_POWER_HAS_DCDCEN 1
24  #else
25  #define NRF_POWER_HAS_DCDCEN 0
26  #endif
27  #if defined(POWER_INTENSET_POFWARN_Msk) || defined(__NRFX_DOXYGEN__)
28  #define NRF_POWER_HAS_POFWARN 1
29  #else
30  #define NRF_POWER_HAS_POFWARN 0
31  #endif
32  #if defined(POWER_POFCON_THRESHOLD_Msk) || defined(__NRFX_DOXYGEN__)
33  #define NRF_POWER_HAS_POFCON 1
34  #else
35  #define NRF_POWER_HAS_POFCON 0
36  #endif
37  #if defined(POWER_POFCON_THRESHOLDVDDH_Msk) || defined(__NRFX_DOXYGEN__)
38  #define NRF_POWER_HAS_POFCON_VDDH 1
39  #else
40  #define NRF_POWER_HAS_POFCON_VDDH 0
41  #endif
42  #if defined(POWER_RESETREAS_RESETPIN_Msk) || defined(__NRFX_DOXYGEN__)
43  #define NRF_POWER_HAS_RESETREAS 1
44  #else
45  #define NRF_POWER_HAS_RESETREAS 0
46  #endif
47  #if defined(POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) || defined(__NRFX_DOXYGEN__)
48  #define NRF_POWER_HAS_MAINREGSTATUS 1
49  #else
50  #define NRF_POWER_HAS_MAINREGSTATUS 0
51  #endif
52  typedef enum
53  {
54      NRF_POWER_TASK_CONSTLAT  = offsetof(NRF_POWER_Type, TASKS_CONSTLAT), &bsol;**< Enable constant latency mode. */
55      NRF_POWER_TASK_LOWPWR    = offsetof(NRF_POWER_Type, TASKS_LOWPWR  ), &bsol;**< Enable low-power mode (variable latency). */
56  } nrf_power_task_t;
57  typedef enum
58  {
59  #if NRF_POWER_HAS_POFWARN
60      NRF_POWER_EVENT_POFWARN      = offsetof(NRF_POWER_Type, EVENTS_POFWARN    ), &bsol;**< Power failure warning. */
61  #endif
62  #if NRF_POWER_HAS_SLEEPEVT
63      NRF_POWER_EVENT_SLEEPENTER   = offsetof(NRF_POWER_Type, EVENTS_SLEEPENTER ), &bsol;**< CPU entered WFI/WFE sleep. */
64      NRF_POWER_EVENT_SLEEPEXIT    = offsetof(NRF_POWER_Type, EVENTS_SLEEPEXIT  ), &bsol;**< CPU exited WFI/WFE sleep. */
65  #endif
66  #if NRF_POWER_HAS_USBREG
67      NRF_POWER_EVENT_USBDETECTED  = offsetof(NRF_POWER_Type, EVENTS_USBDETECTED), &bsol;**< Voltage supply detected on VBUS. */
68      NRF_POWER_EVENT_USBREMOVED   = offsetof(NRF_POWER_Type, EVENTS_USBREMOVED ), &bsol;**< Voltage supply removed from VBUS. */
69      NRF_POWER_EVENT_USBPWRRDY    = offsetof(NRF_POWER_Type, EVENTS_USBPWRRDY  ), &bsol;**< USB 3.3&nbsp;V supply ready. */
70  #endif
71  } nrf_power_event_t;
72  typedef enum
73  {
74  #if NRF_POWER_HAS_POFWARN
75      NRF_POWER_INT_POFWARN_MASK     = POWER_INTENSET_POFWARN_Msk    , &bsol;**< Write '1' to Enable interrupt for POFWARN event. */
76  #endif
77  #if NRF_POWER_HAS_SLEEPEVT
78      NRF_POWER_INT_SLEEPENTER_MASK  = POWER_INTENSET_SLEEPENTER_Msk , &bsol;**< Write '1' to Enable interrupt for SLEEPENTER event. */
79      NRF_POWER_INT_SLEEPEXIT_MASK   = POWER_INTENSET_SLEEPEXIT_Msk  , &bsol;**< Write '1' to Enable interrupt for SLEEPEXIT event. */
80  #endif
81  #if NRF_POWER_HAS_USBREG
82      NRF_POWER_INT_USBDETECTED_MASK = POWER_INTENSET_USBDETECTED_Msk, &bsol;**< Write '1' to Enable interrupt for USBDETECTED event. */
83      NRF_POWER_INT_USBREMOVED_MASK  = POWER_INTENSET_USBREMOVED_Msk , &bsol;**< Write '1' to Enable interrupt for USBREMOVED event. */
84      NRF_POWER_INT_USBPWRRDY_MASK   = POWER_INTENSET_USBPWRRDY_Msk  , &bsol;**< Write '1' to Enable interrupt for USBPWRRDY event. */
85  #endif
86  } nrf_power_int_mask_t;
87  #if NRF_POWER_HAS_RESETREAS
88  typedef enum
89  {
90      NRF_POWER_RESETREAS_RESETPIN_MASK = POWER_RESETREAS_RESETPIN_Msk, &bsol;**< Bit mask of RESETPIN field. */
91      NRF_POWER_RESETREAS_DOG_MASK      = POWER_RESETREAS_DOG_Msk     , &bsol;**< Bit mask of DOG field. */
92      NRF_POWER_RESETREAS_SREQ_MASK     = POWER_RESETREAS_SREQ_Msk    , &bsol;**< Bit mask of SREQ field. */
93      NRF_POWER_RESETREAS_LOCKUP_MASK   = POWER_RESETREAS_LOCKUP_Msk  , &bsol;**< Bit mask of LOCKUP field. */
94      NRF_POWER_RESETREAS_OFF_MASK      = POWER_RESETREAS_OFF_Msk     , &bsol;**< Bit mask of OFF field. */
95  #if defined(POWER_RESETREAS_LPCOMP_Msk) || defined(__NRFX_DOXYGEN__)
96      NRF_POWER_RESETREAS_LPCOMP_MASK   = POWER_RESETREAS_LPCOMP_Msk  , &bsol;**< Bit mask of LPCOMP field. */
97  #endif
98      NRF_POWER_RESETREAS_DIF_MASK      = POWER_RESETREAS_DIF_Msk     , &bsol;**< Bit mask of DIF field. */
99  #if defined(POWER_RESETREAS_NFC_Msk) || defined(__NRFX_DOXYGEN__)
100      NRF_POWER_RESETREAS_NFC_MASK      = POWER_RESETREAS_NFC_Msk     , &bsol;**< Bit mask of NFC field. */
101  #endif
102  #if defined(POWER_RESETREAS_VBUS_Msk) || defined(__NRFX_DOXYGEN__)
103      NRF_POWER_RESETREAS_VBUS_MASK     = POWER_RESETREAS_VBUS_Msk    , &bsol;**< Bit mask of VBUS field. */
104  #endif
105  } nrf_power_resetreas_mask_t;
106  #endif 
107  #if NRF_POWER_HAS_USBREG
108  typedef enum
109  {
110      NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK = POWER_USBREGSTATUS_VBUSDETECT_Msk, &bsol;**< USB detected or removed.     */
111      NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK  = POWER_USBREGSTATUS_OUTPUTRDY_Msk   &bsol;**< USB 3.3&nbsp;V supply ready. */
112  } nrf_power_usbregstatus_mask_t;
113  #endif 
114  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
115  typedef enum
116  {
117      NRF_POWER_RAMBLOCK0 = POWER_RAMSTATUS_RAMBLOCK0_Pos,
118      NRF_POWER_RAMBLOCK1 = POWER_RAMSTATUS_RAMBLOCK1_Pos,
119      NRF_POWER_RAMBLOCK2 = POWER_RAMSTATUS_RAMBLOCK2_Pos,
120      NRF_POWER_RAMBLOCK3 = POWER_RAMSTATUS_RAMBLOCK3_Pos
121  } nrf_power_ramblock_t;
122  typedef enum
123  {
124      NRF_POWER_RAMBLOCK0_MASK = POWER_RAMSTATUS_RAMBLOCK0_Msk,
125      NRF_POWER_RAMBLOCK1_MASK = POWER_RAMSTATUS_RAMBLOCK1_Msk,
126      NRF_POWER_RAMBLOCK2_MASK = POWER_RAMSTATUS_RAMBLOCK2_Msk,
127      NRF_POWER_RAMBLOCK3_MASK = POWER_RAMSTATUS_RAMBLOCK3_Msk
128  } nrf_power_ramblock_mask_t;
129  #endif 
130  typedef enum
131  {
132      NRF_POWER_ONRAM0,  &bsol;**< Keep RAM block 0 ON or OFF in System ON mode.                 */
133      NRF_POWER_OFFRAM0, &bsol;**< Keep retention on RAM block 0 when RAM block is switched OFF. */
134      NRF_POWER_ONRAM1,  &bsol;**< Keep RAM block 1 ON or OFF in System ON mode.                 */
135      NRF_POWER_OFFRAM1, &bsol;**< Keep retention on RAM block 1 when RAM block is switched OFF. */
136      NRF_POWER_ONRAM2,  &bsol;**< Keep RAM block 2 ON or OFF in System ON mode.                 */
137      NRF_POWER_OFFRAM2, &bsol;**< Keep retention on RAM block 2 when RAM block is switched OFF. */
138      NRF_POWER_ONRAM3,  &bsol;**< Keep RAM block 3 ON or OFF in System ON mode.                 */
139      NRF_POWER_OFFRAM3, &bsol;**< Keep retention on RAM block 3 when RAM block is switched OFF. */
140  }nrf_power_onoffram_t;
141  typedef enum
142  {
143      NRF_POWER_ONRAM0_MASK  = 1U << NRF_POWER_ONRAM0,  &bsol;**< Keep RAM block 0 ON or OFF in System ON mode.                 */
144      NRF_POWER_OFFRAM0_MASK = 1U << NRF_POWER_OFFRAM0, &bsol;**< Keep retention on RAM block 0 when RAM block is switched OFF. */
145      NRF_POWER_ONRAM1_MASK  = 1U << NRF_POWER_ONRAM1,  &bsol;**< Keep RAM block 1 ON or OFF in System ON mode.                 */
146      NRF_POWER_OFFRAM1_MASK = 1U << NRF_POWER_OFFRAM1, &bsol;**< Keep retention on RAM block 1 when RAM block is switched OFF. */
147      NRF_POWER_ONRAM2_MASK  = 1U << NRF_POWER_ONRAM2,  &bsol;**< Keep RAM block 2 ON or OFF in System ON mode.                 */
148      NRF_POWER_OFFRAM2_MASK = 1U << NRF_POWER_OFFRAM2, &bsol;**< Keep retention on RAM block 2 when RAM block is switched OFF. */
149      NRF_POWER_ONRAM3_MASK  = 1U << NRF_POWER_ONRAM3,  &bsol;**< Keep RAM block 3 ON or OFF in System ON mode.                 */
150      NRF_POWER_OFFRAM3_MASK = 1U << NRF_POWER_OFFRAM3, &bsol;**< Keep retention on RAM block 3 when RAM block is switched OFF. */
151  }nrf_power_onoffram_mask_t;
152  #if NRF_POWER_HAS_POFCON
153  typedef enum
154  {
155      NRF_POWER_POFTHR_V21 = POWER_POFCON_THRESHOLD_V21, &bsol;**< Set threshold to 2.1&nbsp;V. */
156      NRF_POWER_POFTHR_V23 = POWER_POFCON_THRESHOLD_V23, &bsol;**< Set threshold to 2.3&nbsp;V. */
157      NRF_POWER_POFTHR_V25 = POWER_POFCON_THRESHOLD_V25, &bsol;**< Set threshold to 2.5&nbsp;V. */
158      NRF_POWER_POFTHR_V27 = POWER_POFCON_THRESHOLD_V27, &bsol;**< Set threshold to 2.7&nbsp;V. */
159  #if defined(POWER_POFCON_THRESHOLD_V17) || defined(__NRFX_DOXYGEN__)
160      NRF_POWER_POFTHR_V17 = POWER_POFCON_THRESHOLD_V17, &bsol;**< Set threshold to 1.7&nbsp;V. */
161      NRF_POWER_POFTHR_V18 = POWER_POFCON_THRESHOLD_V18, &bsol;**< Set threshold to 1.8&nbsp;V. */
162      NRF_POWER_POFTHR_V19 = POWER_POFCON_THRESHOLD_V19, &bsol;**< Set threshold to 1.9&nbsp;V. */
163      NRF_POWER_POFTHR_V20 = POWER_POFCON_THRESHOLD_V20, &bsol;**< Set threshold to 2.0&nbsp;V. */
164      NRF_POWER_POFTHR_V22 = POWER_POFCON_THRESHOLD_V22, &bsol;**< Set threshold to 2.2&nbsp;V. */
165      NRF_POWER_POFTHR_V24 = POWER_POFCON_THRESHOLD_V24, &bsol;**< Set threshold to 2.4&nbsp;V. */
166      NRF_POWER_POFTHR_V26 = POWER_POFCON_THRESHOLD_V26, &bsol;**< Set threshold to 2.6&nbsp;V. */
167      NRF_POWER_POFTHR_V28 = POWER_POFCON_THRESHOLD_V28, &bsol;**< Set threshold to 2.8&nbsp;V. */
168  #endif 
169  } nrf_power_pof_thr_t;
170  #endif 
171  #if NRF_POWER_HAS_POFCON_VDDH
172  typedef enum
173  {
174      NRF_POWER_POFTHRVDDH_V27 = POWER_POFCON_THRESHOLDVDDH_V27, &bsol;**< Set threshold to 2.7&nbsp;V. */
175      NRF_POWER_POFTHRVDDH_V28 = POWER_POFCON_THRESHOLDVDDH_V28, &bsol;**< Set threshold to 2.8&nbsp;V. */
176      NRF_POWER_POFTHRVDDH_V29 = POWER_POFCON_THRESHOLDVDDH_V29, &bsol;**< Set threshold to 2.9&nbsp;V. */
177      NRF_POWER_POFTHRVDDH_V30 = POWER_POFCON_THRESHOLDVDDH_V30, &bsol;**< Set threshold to 3.0&nbsp;V. */
178      NRF_POWER_POFTHRVDDH_V31 = POWER_POFCON_THRESHOLDVDDH_V31, &bsol;**< Set threshold to 3.1&nbsp;V. */
179      NRF_POWER_POFTHRVDDH_V32 = POWER_POFCON_THRESHOLDVDDH_V32, &bsol;**< Set threshold to 3.2&nbsp;V. */
180      NRF_POWER_POFTHRVDDH_V33 = POWER_POFCON_THRESHOLDVDDH_V33, &bsol;**< Set threshold to 3.3&nbsp;V. */
181      NRF_POWER_POFTHRVDDH_V34 = POWER_POFCON_THRESHOLDVDDH_V34, &bsol;**< Set threshold to 3.4&nbsp;V. */
182      NRF_POWER_POFTHRVDDH_V35 = POWER_POFCON_THRESHOLDVDDH_V35, &bsol;**< Set threshold to 3.5&nbsp;V. */
183      NRF_POWER_POFTHRVDDH_V36 = POWER_POFCON_THRESHOLDVDDH_V36, &bsol;**< Set threshold to 3.6&nbsp;V. */
184      NRF_POWER_POFTHRVDDH_V37 = POWER_POFCON_THRESHOLDVDDH_V37, &bsol;**< Set threshold to 3.7&nbsp;V. */
185      NRF_POWER_POFTHRVDDH_V38 = POWER_POFCON_THRESHOLDVDDH_V38, &bsol;**< Set threshold to 3.8&nbsp;V. */
186      NRF_POWER_POFTHRVDDH_V39 = POWER_POFCON_THRESHOLDVDDH_V39, &bsol;**< Set threshold to 3.9&nbsp;V. */
187      NRF_POWER_POFTHRVDDH_V40 = POWER_POFCON_THRESHOLDVDDH_V40, &bsol;**< Set threshold to 4.0&nbsp;V. */
188      NRF_POWER_POFTHRVDDH_V41 = POWER_POFCON_THRESHOLDVDDH_V41, &bsol;**< Set threshold to 4.1&nbsp;V. */
189      NRF_POWER_POFTHRVDDH_V42 = POWER_POFCON_THRESHOLDVDDH_V42, &bsol;**< Set threshold to 4.2&nbsp;V. */
190  } nrf_power_pof_thrvddh_t;
191  #endif 
192  #if NRF_POWER_HAS_MAINREGSTATUS
193  typedef enum
194  {
195      NRF_POWER_MAINREGSTATUS_NORMAL = POWER_MAINREGSTATUS_MAINREGSTATUS_Normal, &bsol;**< Normal voltage mode. Voltage supplied on VDD. */
196      NRF_POWER_MAINREGSTATUS_HIGH   = POWER_MAINREGSTATUS_MAINREGSTATUS_High    &bsol;**< High voltage mode. Voltage supplied on VDDH.  */
197  } nrf_power_mainregstatus_t;
198  #endif
199  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
200  typedef enum
201  {
202      NRF_POWER_RAMPOWER_S0POWER = POWER_RAM_POWER_S0POWER_Pos,
203      NRF_POWER_RAMPOWER_S1POWER,  &bsol;**< Keep RAM section S1 ON in System ON mode. */
204      NRF_POWER_RAMPOWER_S2POWER,  &bsol;**< Keep RAM section S2 ON in System ON mode. */
205      NRF_POWER_RAMPOWER_S3POWER,  &bsol;**< Keep RAM section S3 ON in System ON mode. */
206      NRF_POWER_RAMPOWER_S4POWER,  &bsol;**< Keep RAM section S4 ON in System ON mode. */
207      NRF_POWER_RAMPOWER_S5POWER,  &bsol;**< Keep RAM section S5 ON in System ON mode. */
208      NRF_POWER_RAMPOWER_S6POWER,  &bsol;**< Keep RAM section S6 ON in System ON mode. */
209      NRF_POWER_RAMPOWER_S7POWER,  &bsol;**< Keep RAM section S7 ON in System ON mode. */
210      NRF_POWER_RAMPOWER_S8POWER,  &bsol;**< Keep RAM section S8 ON in System ON mode. */
211      NRF_POWER_RAMPOWER_S9POWER,  &bsol;**< Keep RAM section S9 ON in System ON mode. */
212      NRF_POWER_RAMPOWER_S10POWER, &bsol;**< Keep RAM section S10 ON in System ON mode. */
213      NRF_POWER_RAMPOWER_S11POWER, &bsol;**< Keep RAM section S11 ON in System ON mode. */
214      NRF_POWER_RAMPOWER_S12POWER, &bsol;**< Keep RAM section S12 ON in System ON mode. */
215      NRF_POWER_RAMPOWER_S13POWER, &bsol;**< Keep RAM section S13 ON in System ON mode. */
216      NRF_POWER_RAMPOWER_S14POWER, &bsol;**< Keep RAM section S14 ON in System ON mode. */
217      NRF_POWER_RAMPOWER_S15POWER, &bsol;**< Keep RAM section S15 ON in System ON mode. */
218      NRF_POWER_RAMPOWER_S0RETENTION = POWER_RAM_POWER_S0RETENTION_Pos,
219      NRF_POWER_RAMPOWER_S1RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
220      NRF_POWER_RAMPOWER_S2RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
221      NRF_POWER_RAMPOWER_S3RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
222      NRF_POWER_RAMPOWER_S4RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
223      NRF_POWER_RAMPOWER_S5RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
224      NRF_POWER_RAMPOWER_S6RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
225      NRF_POWER_RAMPOWER_S7RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
226      NRF_POWER_RAMPOWER_S8RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
227      NRF_POWER_RAMPOWER_S9RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
228      NRF_POWER_RAMPOWER_S10RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
229      NRF_POWER_RAMPOWER_S11RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
230      NRF_POWER_RAMPOWER_S12RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
231      NRF_POWER_RAMPOWER_S13RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
232      NRF_POWER_RAMPOWER_S14RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
233      NRF_POWER_RAMPOWER_S15RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
234  } nrf_power_rampower_t;
235  typedef enum
236  {
237      NRF_POWER_RAMPOWER_S0POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S0POWER ,
238      NRF_POWER_RAMPOWER_S1POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S1POWER ,
239      NRF_POWER_RAMPOWER_S2POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S2POWER ,
240      NRF_POWER_RAMPOWER_S3POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S3POWER ,
241      NRF_POWER_RAMPOWER_S4POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S4POWER ,
242      NRF_POWER_RAMPOWER_S5POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S5POWER ,
243      NRF_POWER_RAMPOWER_S7POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S7POWER ,
244      NRF_POWER_RAMPOWER_S8POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S8POWER ,
245      NRF_POWER_RAMPOWER_S9POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S9POWER ,
246      NRF_POWER_RAMPOWER_S10POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S10POWER,
247      NRF_POWER_RAMPOWER_S11POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S11POWER,
248      NRF_POWER_RAMPOWER_S12POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S12POWER,
249      NRF_POWER_RAMPOWER_S13POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S13POWER,
250      NRF_POWER_RAMPOWER_S14POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S14POWER,
251      NRF_POWER_RAMPOWER_S15POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S15POWER,
252      NRF_POWER_RAMPOWER_S0RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S0RETENTION ,
253      NRF_POWER_RAMPOWER_S1RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S1RETENTION ,
254      NRF_POWER_RAMPOWER_S2RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S2RETENTION ,
255      NRF_POWER_RAMPOWER_S3RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S3RETENTION ,
256      NRF_POWER_RAMPOWER_S4RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S4RETENTION ,
257      NRF_POWER_RAMPOWER_S5RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S5RETENTION ,
258      NRF_POWER_RAMPOWER_S7RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S7RETENTION ,
259      NRF_POWER_RAMPOWER_S8RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S8RETENTION ,
260      NRF_POWER_RAMPOWER_S9RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S9RETENTION ,
261      NRF_POWER_RAMPOWER_S10RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S10RETENTION,
262      NRF_POWER_RAMPOWER_S11RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S11RETENTION,
263      NRF_POWER_RAMPOWER_S12RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S12RETENTION,
264      NRF_POWER_RAMPOWER_S13RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S13RETENTION,
265      NRF_POWER_RAMPOWER_S14RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S14RETENTION,
266      NRF_POWER_RAMPOWER_S15RETENTION_MASK = (int)(1UL << NRF_POWER_RAMPOWER_S15RETENTION),
<span onclick='openModal()' class='match'>267  } nrf_power_rampower_mask_t;
268  #endif 
269  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task);
270  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
271                                                        nrf_power_task_t       task);
272  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
273  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event);
274  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
275                                                       nrf_power_event_t event);
276  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
277                                                         nrf_power_event_t      event);
278  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask);
279  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask);
280  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg);
281  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask);
282  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
283  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
284                                                 nrf_power_task_t task,
285                                                 uint8_t          channel);
286  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task);
287  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
288                                               nrf_power_event_t event,
289                                               uint8_t           channel);
290  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
291  #endif 
292  #if NRF_POWER_HAS_RESETREAS
293  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg);
294  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask);
295  #endif 
296  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk) || defined(__NRFX_DOXYGEN__)
297  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg);
</span>298  #endif
299  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
300  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg);
301  #endif 
302  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
303  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg);
304  #endif 
305  #if NRF_POWER_HAS_POFCON
306  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
307                                              bool                enable,
308                                              nrf_power_pof_thr_t thr);
309  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
310                                                             bool *                 p_enabled);
311  #endif 
312  #if NRF_POWER_HAS_POFCON_VDDH
313  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
314                                                   nrf_power_pof_thrvddh_t thr);
315  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg);
316  #endif 
317  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val);
318  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg);
319  #if defined(POWER_GPREGRET2_GPREGRET_Msk) || defined(__NRFX_DOXYGEN__)
320  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val);
321  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg);
322  #endif 
323  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num);
324  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
325                                                    uint8_t          reg_num,
326                                                    uint8_t          val);
327  #if NRF_POWER_HAS_DCDCEN
328  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable);
329  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg);
330  #endif 
331  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
332  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
333                                                    uint8_t          block,
334                                                    uint32_t         section_mask);
335  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
336                                                     uint8_t          block,
337                                                     uint32_t         section_mask);
338  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block);
339  #endif &bsol;* defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__) */
340  #if NRF_POWER_HAS_DCDCEN_VDDH
341  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable);
342  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg);
343  #endif 
344  #if NRF_POWER_HAS_MAINREGSTATUS
345  NRF_STATIC_INLINE
346  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg);
347  #endif 
348  #if NRF_POWER_HAS_USBREG
349  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg);
350  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg);
351  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg);
352  #endif 
353  #ifndef NRF_DECLARE_ONLY
354  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task)
355  {
356      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
357  }
358  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
359                                                        nrf_power_task_t       task)
360  {
361      return ((uint32_t)p_reg + (uint32_t)task);
362  }
363  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
364  {
365      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
366  #if __CORTEX_M == 0x04
367      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
368      (void)dummy;
369  #endif
370  }
371  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
372  {
373      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
374  }
375  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
376                                                       nrf_power_event_t event)
377  {
378      bool ret = nrf_power_event_check(p_reg, event);
379      if (ret)
380      {
381          nrf_power_event_clear(p_reg, event);
382      }
383      return ret;
384  }
385  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
386                                                         nrf_power_event_t      event)
387  {
388      return ((uint32_t)p_reg + (uint32_t)event);
389  }
390  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask)
391  {
392      p_reg->INTENSET = mask;
393  }
394  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask)
395  {
396      return p_reg->INTENSET & mask;
397  }
398  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
399  {
400      return p_reg->INTENSET;
401  }
402  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask)
403  {
404      p_reg->INTENCLR = mask;
405  }
406  #if defined(DPPI_PRESENT)
407  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
408                                                 nrf_power_task_t task,
409                                                 uint8_t          channel)
410  {
411      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
412              ((uint32_t)channel | POWER_SUBSCRIBE_CONSTLAT_EN_Msk);
413  }
414  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task)
415  {
416      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
417  }
418  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
419                                               nrf_power_event_t event,
420                                               uint8_t           channel)
421  {
422      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
423              ((uint32_t)channel | POWER_PUBLISH_SLEEPENTER_EN_Msk);
424  }
425  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
426  {
427      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
428  }
429  #endif 
430  #if NRF_POWER_HAS_RESETREAS
431  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg)
432  {
433      return p_reg->RESETREAS;
434  }
435  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask)
436  {
437      p_reg->RESETREAS = mask;
438  }
439  #endif 
440  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk)
441  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg)
442  {
443      return (p_reg->POWERSTATUS & POWER_POWERSTATUS_LTEMODEM_Msk) ==
444             (POWER_POWERSTATUS_LTEMODEM_ON << POWER_POWERSTATUS_LTEMODEM_Pos);
445  }
446  #endif 
447  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)
448  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg)
449  {
450      return p_reg->RAMSTATUS;
451  }
452  #endif 
453  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
454  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
455  {
456      p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
457      __DSB();
458      while (true)
459      {
460          __WFE();
461      }
462  }
463  #endif 
464  #if NRF_POWER_HAS_POFCON
465  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
466                                              bool                enable,
467                                              nrf_power_pof_thr_t thr)
468  {
469      NRFX_ASSERT(thr == (thr & (POWER_POFCON_THRESHOLD_Msk >> POWER_POFCON_THRESHOLD_Pos)));
470  #if NRF_POWER_HAS_POFCON_VDDH
471      uint32_t pofcon = p_reg->POFCON;
472      pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
473      pofcon |=
474  #else 
475      p_reg->POFCON =
476  #endif
477          (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
478          (enable ?
479          (POWER_POFCON_POF_Enabled << POWER_POFCON_POF_Pos)
480          :
481          (POWER_POFCON_POF_Disabled << POWER_POFCON_POF_Pos));
482  #if NRF_POWER_HAS_POFCON_VDDH
483      p_reg->POFCON = pofcon;
484  #endif
485  }
486  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
487                                                             bool *                 p_enabled)
488  {
489      uint32_t pofcon = p_reg->POFCON;
490      if (NULL != p_enabled)
491      {
492          (*p_enabled) = ((pofcon & POWER_POFCON_POF_Msk) >> POWER_POFCON_POF_Pos)
493              == POWER_POFCON_POF_Enabled;
494      }
495      return (nrf_power_pof_thr_t)((pofcon & POWER_POFCON_THRESHOLD_Msk) >>
496          POWER_POFCON_THRESHOLD_Pos);
497  }
498  #endif 
499  #if NRF_POWER_HAS_POFCON_VDDH
500  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
501                                                   nrf_power_pof_thrvddh_t thr)
502  {
503      NRFX_ASSERT(thr == (thr & (POWER_POFCON_THRESHOLDVDDH_Msk >> POWER_POFCON_THRESHOLDVDDH_Pos)));
504      uint32_t pofcon = p_reg->POFCON;
505      pofcon &= ~POWER_POFCON_THRESHOLDVDDH_Msk;
506      pofcon |= (((uint32_t)thr) << POWER_POFCON_THRESHOLDVDDH_Pos);
507      p_reg->POFCON = pofcon;
508  }
509  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg)
510  {
511      return (nrf_power_pof_thrvddh_t)((p_reg->POFCON & POWER_POFCON_THRESHOLDVDDH_Msk) >>
512                                       POWER_POFCON_THRESHOLDVDDH_Pos);
513  }
514  #endif 
515  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val)
516  {
517      volatile uint32_t * p_gpregret;
518      if (sizeof(p_reg->GPREGRET) > sizeof(uint32_t))
519      {
520          p_gpregret = &((volatile uint32_t *)p_reg->GPREGRET)[0];
521      }
522      else
523      {
524          p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
525      }
526      *p_gpregret = val;
527  }
528  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg)
529  {
530      volatile uint32_t * p_gpregret;
531      if (sizeof(p_reg->GPREGRET) > sizeof(uint32_t))
532      {
533          p_gpregret = &((volatile uint32_t *)p_reg->GPREGRET)[0];
534      }
535      else
536      {
537          p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
538      }
539      return *p_gpregret;
540  }
541  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
542                                                    uint8_t          reg_num,
543                                                    uint8_t          val)
544  {
545  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
546      p_reg->GPREGRET[reg_num] = val;
547  #else
548      NRFX_ASSERT(reg_num < 1);
549      p_reg->GPREGRET = val;
550  #endif
551  }
552  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num)
553  {
554  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
555      return p_reg->GPREGRET[reg_num];
556  #else
557      NRFX_ASSERT(reg_num < 1);
558      return p_reg->GPREGRET;
559  #endif
560  }
561  #if defined(POWER_GPREGRET2_GPREGRET_Msk)
562  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val)
563  {
564      p_reg->GPREGRET2 = val;
565  }
566  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg)
567  {
568      return p_reg->GPREGRET2;
569  }
570  #endif
571  #if NRF_POWER_HAS_DCDCEN
572  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
573  {
574      p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
575                      POWER_DCDCEN_DCDCEN_Pos;
576  }
577  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg)
578  {
579      return (p_reg->DCDCEN & POWER_DCDCEN_DCDCEN_Msk)
580              ==
581             (POWER_DCDCEN_DCDCEN_Enabled << POWER_DCDCEN_DCDCEN_Pos);
582  }
583  #endif 
584  #if defined(POWER_RAM_POWER_S0POWER_Msk)
585  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
586                                                    uint8_t          block,
587                                                    uint32_t         section_mask)
588  {
589      p_reg->RAM[block].POWERSET = section_mask;
590  }
591  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
592                                                     uint8_t          block,
593                                                     uint32_t         section_mask)
594  {
595      p_reg->RAM[block].POWERCLR = section_mask;
596  }
597  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block)
598  {
599      return p_reg->RAM[block].POWER;
600  }
601  #endif 
602  #if NRF_POWER_HAS_DCDCEN_VDDH
603  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
604  {
605      p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
606                       POWER_DCDCEN0_DCDCEN_Pos;
607  }
608  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg)
609  {
610      return (p_reg->DCDCEN0 & POWER_DCDCEN0_DCDCEN_Msk)
611              ==
612             (POWER_DCDCEN0_DCDCEN_Enabled << POWER_DCDCEN0_DCDCEN_Pos);
613  }
614  #endif 
615  #if NRF_POWER_HAS_MAINREGSTATUS
616  NRF_STATIC_INLINE
617  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg)
618  {
619      return (nrf_power_mainregstatus_t)(((p_reg->MAINREGSTATUS) &
620          POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) >>
621          POWER_MAINREGSTATUS_MAINREGSTATUS_Pos);
622  }
623  #endif 
624  #if NRF_POWER_HAS_USBREG
625  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
626  {
627      return p_reg->USBREGSTATUS;
628  }
629  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg)
630  {
631      return (nrf_power_usbregstatus_get(p_reg) & NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK) != 0;
632  }
633  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg)
634  {
635      return (nrf_power_usbregstatus_get(p_reg) & NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK) != 0;
636  }
637  #endif 
638  #endif 
639  #ifdef __cplusplus
640  }
641  #endif
642  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</div>
                </div>
                <div class="column column_space"><pre><code>20  } problem_rdft;
21  void X(rdft_zerotens)(tensor *sz, R *I);
22  problem *X(mkproblem_rdft)(const tensor *sz, const tensor *vecsz,
23  			   R *I, R *O, const rdft_kind *kind);
24  problem *X(mkproblem_rdft_d)(tensor *sz, tensor *vecsz,
25  			     R *I, R *O, const rdft_kind *kind);
26  problem *X(mkproblem_rdft_0_d)(tensor *vecsz, R *I, R *O);
27  problem *X(mkproblem_rdft_1)(const tensor *sz, const tensor *vecsz,
28  			     R *I, R *O, rdft_kind kind);
29  problem *X(mkproblem_rdft_1_d)(tensor *sz, tensor *vecsz,
30  			       R *I, R *O, rdft_kind kind);
31  const char *X(rdft_kind_str)(rdft_kind kind);
</pre></code></div>
                <div class="column column_space"><pre><code>267  } nrf_power_rampower_mask_t;
268  #endif 
269  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task);
270  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
271                                                        nrf_power_task_t       task);
272  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
273  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event);
274  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
275                                                       nrf_power_event_t event);
276  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
277                                                         nrf_power_event_t      event);
278  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask);
279  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask);
280  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg);
281  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask);
282  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
283  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
284                                                 nrf_power_task_t task,
285                                                 uint8_t          channel);
286  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task);
287  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
288                                               nrf_power_event_t event,
289                                               uint8_t           channel);
290  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
291  #endif 
292  #if NRF_POWER_HAS_RESETREAS
293  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg);
294  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask);
295  #endif 
296  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk) || defined(__NRFX_DOXYGEN__)
297  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    