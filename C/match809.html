<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imklog.c &amp; omprog.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imklog.c &amp; omprog.c
      </h3>
<h1 align="center">
        10.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imklog.c (19.642857%)<th>omprog.c (7.3008847%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(99-115)<td><a href="#" name="0">(134-153)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(374-381)<td><a href="#" name="1">(1123-1130)</a><td align="center"><font color="#bf0000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(382-387)<td><a href="#" name="2">(1117-1122)</a><td align="center"><font color="#9a0000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imklog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdarg.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;sys/socket.h&gt;
10 #include "dirty.h"
11 #include "cfsysline.h"
12 #include "parserif.h"
13 #include "obj.h"
14 #include "msg.h"
15 #include "module-template.h"
16 #include "datetime.h"
17 #include "imklog.h"
18 #include "net.h"
19 #include "glbl.h"
20 #include "prop.h"
21 #include "errmsg.h"
22 #include "unicode-helper.h"
23 #include "ruleset.h"
24 MODULE_TYPE_INPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("imklog")
27 DEF_IMOD_STATIC_DATA
28 DEFobjCurrIf(datetime)
29 DEFobjCurrIf(ruleset)
30 DEFobjCurrIf(glbl)
31 DEFobjCurrIf(prop)
32 DEFobjCurrIf(net)
33 typedef struct configSettings_s {
34 	int bPermitNonKernel; 	int bParseKernelStamp; 	int bKeepKernelStamp; 	int iFacilIntMsg; 	uchar *pszPath;
35 	int console_log_level; 	unsigned int ratelimitInterval;
36 	unsigned int ratelimitBurst;
37 } configSettings_t;
38 static configSettings_t cs;
39 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static int bLegacyCnfModGlobalsPermitted;<a name="0"></a>
40 static struct cnfparamdescr modpdescr[] = {
41 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "ruleset", eCmdHdlrString, 0 },
42 	{ "logpath", eCmdHdlrGetWord, 0 },
43 	{ "permitnonkernelfacility", eCmdHdlrBinary, 0 },
44 	{ "consoleloglevel", eCmdHdlrInt, 0 },
45 	{ "parsekerneltimestamp", eCmdHdlrBinary, 0 },
46 	{ "keepkerneltimestamp", eCmdHdlrBinary, 0 },
47 	{ "internalmsgfacility", eCmdHdlrFacility, 0 },
48 	{ "ratelimitinterval", eCmdHdlrInt, 0 },
49 	{ "ratelimitburst", eCmdHdlrInt, 0 }
50 };
51 static struct cnfparamblk modpblk =
52 	{ CNFPARAMBLK_VERSION,
53 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
54 	  modpdescr
55 	};
56 static prop_t *pInputName = NULL;</b></font>
57 static prop_t *pLocalHostIP = NULL;
58 static inline void std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf);
59 static inline rsRetVal
60 std_mod_checkRuleset(modConfData_t *const modConf)
61 {
62 	ruleset_t *pRuleset;
63 	rsRetVal localRet;
64 	DEFiRet;
65 	modConf-&gt;pBindRuleset = NULL;	
66 	if(modConf-&gt;pszBindRuleset == NULL)
67 		FINALIZE;
68 	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
69 	if(localRet == RS_RET_NOT_FOUND) {
70 		std_mod_checkRuleset_genErrMsg(modConf);
71 	}
72 	CHKiRet(localRet);
73 	modConf-&gt;pBindRuleset = pRuleset;
74 finalize_it:
75 	RETiRet;
76 }
77 static inline void
78 std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf)
79 {
80 	LogError(0, NO_ERRCODE, "imklog: ruleset '%s' not found - "
81 			"using default ruleset instead", modConf-&gt;pszBindRuleset);
82 }
83 static void
84 initConfigSettings(void)
85 {
86 	cs.bPermitNonKernel = 0;
87 	cs.bParseKernelStamp = 0;
88 	cs.bKeepKernelStamp = 0;
89 	cs.console_log_level = -1;
90 	cs.pszPath = NULL;
91 	cs.iFacilIntMsg = klogFacilIntMsg();
92 }
93 static rsRetVal
94 enqMsg(uchar *const __restrict__ msg,
95 	uchar* pszTag,
96 	const syslog_pri_t pri,
97 	struct timeval *tp,
98 	ratelimit_t *ratelimiter)
99 {
100 	struct syslogTime st;
101 	smsg_t *pMsg;
102 	DEFiRet;
103 	assert(msg != NULL);
104 	assert(pszTag != NULL);
105 	if(tp == NULL) {
106 		CHKiRet(msgConstruct(&amp;pMsg));
107 	} else {
108 		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
109 		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
110 	}
111 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
112 	MsgSetInputName(pMsg, pInputName);
113 	MsgSetRawMsgWOSize(pMsg, (char*)msg);
114 	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
115 	MsgSetMSGoffs(pMsg, 0);		MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
116 	MsgSetRcvFromIP(pMsg, pLocalHostIP);
117 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
118 	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
119 	msgSetPRI(pMsg, pri);
120 	ratelimitAddMsg(ratelimiter, NULL, pMsg);
121 finalize_it:
122 	RETiRet;
123 }
124 static rsRetVal
125 parsePRI(uchar **ppSz, syslog_pri_t *piPri)
126 {
127 	DEFiRet;
128 	syslog_pri_t i;
129 	uchar *pSz;
130 	assert(ppSz != NULL);
131 	pSz = *ppSz;
132 	assert(pSz != NULL);
133 	assert(piPri != NULL);
134 	if(*pSz != '&lt;' || !isdigit(*(pSz+1)))
135 		ABORT_FINALIZE(RS_RET_INVALID_PRI);
136 	++pSz;
137 	i = 0;
138 	while(isdigit(*pSz) &amp;&amp; i &lt;= LOG_MAXPRI) {
139 		i = i * 10 + *pSz++ - '0';
140 	}
141 	if(*pSz != '&gt;' || i &gt; LOG_MAXPRI)
142 		ABORT_FINALIZE(RS_RET_INVALID_PRI);
143 	*piPri = i;
144 	*ppSz = pSz + 1; 
145 finalize_it:
146 	RETiRet;
147 }
148 rsRetVal imklogLogIntMsg(syslog_pri_t priority, const char *fmt, ...)
149 {
150 	DEFiRet;
151 	va_list ap;
152 	uchar msgBuf[2048]; 
153 	va_start(ap, fmt);
154 	vsnprintf((char*)msgBuf, sizeof(msgBuf), fmt, ap);
155 	va_end(ap);
156 	logmsgInternal(NO_ERRCODE, priority, msgBuf, 0);
157 	RETiRet;
158 }
159 rsRetVal Syslog(modConfData_t *pModConf, syslog_pri_t priority, uchar *pMsg, struct timeval *tp)
160 {
161 	syslog_pri_t pri;
162 	int bPRISet = 0;
163 	rsRetVal localRet;
164 	DEFiRet;
165 	if(pMsg[3] == '&lt;' || (pMsg[3] == ' ' &amp;&amp; pMsg[4] == '&lt;')) { 		uchar *pMsgTmp = pMsg + ((pMsg[3] == '&lt;') ? 3 : 4);
166 		localRet = parsePRI(&amp;pMsgTmp, &amp;pri);
167 		if(localRet == RS_RET_OK &amp;&amp; pri &gt;= 8 &amp;&amp; pri &lt;= LOG_MAXPRI) {
168 			DBGPRINTF("imklog detected secondary PRI(%d) in klog msg\n", pri);
169 			pMsg = pMsgTmp;
170 			priority = pri;
171 			bPRISet = 1;
172 		}
173 	}
174 	if(!bPRISet) {
175 		localRet = parsePRI(&amp;pMsg, &amp;priority);
176 		if(localRet != RS_RET_INVALID_PRI &amp;&amp; localRet != RS_RET_OK)
177 			FINALIZE;
178 	}
179 	if(pModConf-&gt;bPermitNonKernel == 0 &amp;&amp; pri2fac(priority) != LOG_KERN)
180 		FINALIZE; 
181 	iRet = enqMsg((uchar*)pMsg, (uchar*) "kernel:", priority, tp, pModConf-&gt;ratelimiter);
182 finalize_it:
183 	RETiRet;
184 }
185 int klog_getMaxLine(void)
186 {
187 	return glbl.GetMaxLine(runConf);
188 }
189 BEGINrunInput
190 CODESTARTrunInput
191 	while(!pThrd-&gt;bShallStop) {
192 		CHKiRet(klogLogKMsg(runModConf));
193 	}
194 finalize_it:
195 ENDrunInput
196 BEGINbeginCnfLoad
197 CODESTARTbeginCnfLoad
198 	loadModConf = pModConf;
199 	pModConf-&gt;pConf = pConf;
200 	pModConf-&gt;pszPath = NULL;
201 	pModConf-&gt;bPermitNonKernel = 0;
202 	pModConf-&gt;bParseKernelStamp = 0;
203 	pModConf-&gt;bKeepKernelStamp = 0;
204 	pModConf-&gt;console_log_level = -1;
205 	pModConf-&gt;bKeepKernelStamp = 0;
206 	pModConf-&gt;iFacilIntMsg = klogFacilIntMsg();
207 	loadModConf-&gt;configSetViaV2Method = 0;
208 	pModConf-&gt;ratelimiter = NULL;
209 	pModConf-&gt;ratelimitBurst = 10000; 	pModConf-&gt;ratelimitInterval = 0; 	bLegacyCnfModGlobalsPermitted = 1;
210 	initConfigSettings();
211 ENDbeginCnfLoad
212 BEGINsetModCnf
213 	struct cnfparamvals *pvals = NULL;
214 	int i;
215 CODESTARTsetModCnf
216 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
217 	if(pvals == NULL) {
218 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
219 				"config parameters [module(...)]");
220 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
221 	}
222 	if(Debug) {
223 		dbgprintf("module (global) param blk for imklog:\n");
224 		cnfparamsPrint(&amp;modpblk, pvals);
225 	}
226 <a name="1"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
227 		if(!pvals[i].bUsed)
228 			continue;
229 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if(!strcmp(modpblk.descr[i].name, "logpath")) {
230 			loadModConf-&gt;pszPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
231 		} else if(!strcmp(modpblk.descr[i].name, "permitnonkernelfacility")) {
232 			loadModConf-&gt;bPermitNonKernel = (int) pvals[i].val.d.n;
233 		} else if(!strcmp(modpblk.descr[i].name, "parsekerneltimestamp")) {
234 <a name="2"></a>			loadModConf-&gt;bParseKernelStamp = (int) pvals[i].val.d.n;
235 		} else if(!strcmp(modpblk.descr[i].name, "keepkerneltimestamp")) {
236 			loadModConf-&gt;bKeepKernelStamp = (int) pvals[i].val.d.n;</b></font>
237 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "consoleloglevel")) {
238 			loadModConf-&gt;console_log_level= (int) pvals[i].val.d.n;
239 		} else if(!strcmp(modpblk.descr[i].name, "internalmsgfacility")) {
240 			loadModConf-&gt;iFacilIntMsg = (int) pvals[i].val.d.n;
241 		} else if(!strcmp(modpblk.descr[i].name, "ratelimitburst")) {
242 			loadModConf-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</b></font>
243 		} else if(!strcmp(modpblk.descr[i].name, "ratelimitinterval")) {
244 			loadModConf-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
245 		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
246 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
247 		} else {
248 			LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING,
249 				"imklog: RSYSLOG BUG, non-handled param '%s' in "
250 				"beginCnfLoad\n", modpblk.descr[i].name);
251 		}
252 	}
253 	bLegacyCnfModGlobalsPermitted = 0;
254 	loadModConf-&gt;configSetViaV2Method = 1;
255 finalize_it:
256 	if(pvals != NULL)
257 		cnfparamvalsDestruct(pvals, &amp;modpblk);
258 ENDsetModCnf
259 BEGINendCnfLoad
260 CODESTARTendCnfLoad
261 	if(!loadModConf-&gt;configSetViaV2Method) {
262 		loadModConf-&gt;bPermitNonKernel = cs.bPermitNonKernel;
263 		loadModConf-&gt;bParseKernelStamp = cs.bParseKernelStamp;
264 		loadModConf-&gt;bKeepKernelStamp = cs.bKeepKernelStamp;
265 		loadModConf-&gt;iFacilIntMsg = cs.iFacilIntMsg;
266 		loadModConf-&gt;console_log_level = cs.console_log_level;
267 		if((cs.pszPath == NULL) || (cs.pszPath[0] == '\0')) {
268 			loadModConf-&gt;pszPath = NULL;
269 			if(cs.pszPath != NULL)
270 				free(cs.pszPath);
271 		} else {
272 			loadModConf-&gt;pszPath = cs.pszPath;
273 		}
274 		cs.pszPath = NULL;
275 	}
276 	loadModConf = NULL; ENDendCnfLoad
277 BEGINcheckCnf
278 CODESTARTcheckCnf
279 	std_mod_checkRuleset(pModConf);
280 ENDcheckCnf
281 BEGINactivateCnfPrePrivDrop
282 CODESTARTactivateCnfPrePrivDrop
283 	runModConf = pModConf;
284 	iRet = klogWillRunPrePrivDrop(runModConf);
285 ENDactivateCnfPrePrivDrop
286 BEGINactivateCnf
287 CODESTARTactivateCnf
288 	CHKiRet(ratelimitNew(&amp;runModConf-&gt;ratelimiter, "imklog", NULL));
289 	ratelimitSetLinuxLike(runModConf-&gt;ratelimiter,
290 			      runModConf-&gt;ratelimitInterval,
291 			      runModConf-&gt;ratelimitBurst);
292 finalize_it:
293 ENDactivateCnf
294 BEGINfreeCnf
295 CODESTARTfreeCnf
296 	free(pModConf-&gt;pszBindRuleset);
297 ENDfreeCnf
298 BEGINwillRun
299 CODESTARTwillRun
300 	pLocalHostIP = glbl.GetLocalHostIP();
301 	iRet = klogWillRunPostPrivDrop(runModConf);
302 ENDwillRun
303 BEGINafterRun
304 CODESTARTafterRun
305 	ratelimitDestruct(runModConf-&gt;ratelimiter);
306 	iRet = klogAfterRun(runModConf);
307 ENDafterRun
308 BEGINmodExit
309 CODESTARTmodExit
310 	if(pInputName != NULL)
311 		prop.Destruct(&amp;pInputName);
312 	objRelease(glbl, CORE_COMPONENT);
313 	objRelease(net, CORE_COMPONENT);
314 	objRelease(datetime, CORE_COMPONENT);
315 	objRelease(ruleset, CORE_COMPONENT);
316 	objRelease(prop, CORE_COMPONENT);
317 ENDmodExit
318 BEGINqueryEtryPt
319 CODESTARTqueryEtryPt
320 CODEqueryEtryPt_STD_IMOD_QUERIES
321 CODEqueryEtryPt_STD_CONF2_QUERIES
322 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
323 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
324 ENDqueryEtryPt
325 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
326 {
327 	cs.bPermitNonKernel = 0;
328 	cs.bParseKernelStamp = 0;
329 	cs.bKeepKernelStamp = 0;
330 	if(cs.pszPath != NULL) {
331 		free(cs.pszPath);
332 		cs.pszPath = NULL;
333 	}
334 	cs.iFacilIntMsg = klogFacilIntMsg();
335 	return RS_RET_OK;
336 }
337 BEGINmodInit()
338 CODESTARTmodInit
339 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
340 	CHKiRet(objUse(datetime, CORE_COMPONENT));
341 	CHKiRet(objUse(glbl, CORE_COMPONENT));
342 	CHKiRet(objUse(prop, CORE_COMPONENT));
343 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
344 	CHKiRet(objUse(net, CORE_COMPONENT));
345 	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT("imklog"), sizeof("imklog") - 1));
346 	initConfigSettings();
347 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogLocalipif", 0, eCmdHdlrGoneAway,
348 			NULL, NULL, STD_LOADABLE_MODULE_ID));
349 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"debugprintkernelsymbols", 0, eCmdHdlrGoneAway,
350 			NULL, NULL, STD_LOADABLE_MODULE_ID));
351 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpath", 0, eCmdHdlrGetWord,
352 			NULL, &amp;cs.pszPath, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
353 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbollookup", 0, eCmdHdlrGoneAway,
354 			NULL, NULL, STD_LOADABLE_MODULE_ID));
355 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbolstwice", 0, eCmdHdlrGoneAway,
356 			NULL, NULL, STD_LOADABLE_MODULE_ID));
357 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogusesyscallinterface", 0, eCmdHdlrGoneAway,
358 			NULL, NULL, STD_LOADABLE_MODULE_ID));
359 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpermitnonkernelfacility", 0, eCmdHdlrBinary,
360 			NULL, &amp;cs.bPermitNonKernel, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
361 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogconsoleloglevel", 0, eCmdHdlrInt,
362 			NULL, &amp;cs.console_log_level, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
363 	CHKiRet(regCfSysLineHdlr2((uchar *)"kloginternalmsgfacility", 0, eCmdHdlrFacility,
364 			NULL, &amp;cs.iFacilIntMsg, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
365 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogparsekerneltimestamp", 0, eCmdHdlrBinary,
366 			NULL, &amp;cs.bParseKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
367 	CHKiRet(regCfSysLineHdlr2((uchar *)"klogkeepkerneltimestamp", 0, eCmdHdlrBinary,
368 			NULL, &amp;cs.bKeepKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
369 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
370 			resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
371 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omprog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;syslog.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;fcntl.h&gt;
12 #include &lt;sys/wait.h&gt;
13 #include &lt;pthread.h&gt;
14 #include &lt;poll.h&gt;
15 #include "rsyslog.h"
16 #include "conf.h"
17 #include "syslogd-types.h"
18 #include "srUtils.h"
19 #include "template.h"
20 #include "module-template.h"
21 #include "errmsg.h"
22 #include "cfsysline.h"
23 #include "glbl.h"
24 #include "rsconf.h"
25 MODULE_TYPE_OUTPUT
26 MODULE_TYPE_NOKEEP
27 MODULE_CNFNAME("omprog")
28 extern char **environ; 
29 DEF_OMOD_STATIC_DATA
30 #define NO_HUP_FORWARD -1	#define DEFAULT_CONFIRM_TIMEOUT_MS 10000
31 #define DEFAULT_CLOSE_TIMEOUT_MS 5000
32 #define RESPONSE_LINE_BUFFER_SIZE 4096
33 #define OUTPUT_CAPTURE_BUFFER_SIZE 4096
34 #define MAX_FD_TO_CLOSE 65535
35 typedef struct childProcessCtx {
36 	int bIsRunning;			pid_t pid;				int fdPipeOut;			int fdPipeIn;		} childProcessCtx_t;
37 typedef struct outputCaptureCtx {
38 	uchar *szFileName;			mode_t fCreateMode;			pthread_mutex_t mutStart;		pthread_mutex_t mutWrite;		pthread_mutex_t mutTerm;		pthread_cond_t condTerm;		int bIsRunning;				pthread_t thrdID;			int fdPipe[2];				int fdFile;					int bFileErr;				int bReadErr;				int bWriteErr;			} outputCaptureCtx_t;
39 typedef struct _instanceData {
40 	uchar *szBinary;			char **aParams;				int iParams;				uchar *szTemplateName;		int bConfirmMessages;		long lConfirmTimeout;		int bReportFailures;		int bUseTransactions;		uchar *szBeginTransactionMark;		uchar *szCommitTransactionMark;		int iHUPForward;			int bSignalOnClose;			long lCloseTimeout;			int bKillUnresponsive;		int bForceSingleInst;		childProcessCtx_t *pSingleChildCtx;			pthread_mutex_t *pSingleChildMut;			outputCaptureCtx_t *pOutputCaptureCtx;		time_t block_if_err;			} instanceData;
41 typedef struct wrkrInstanceData {
42 	instanceData *pData;
43 	childProcessCtx_t *pChildCtx;	} wrkrInstanceData_t;
44 typedef struct configSettings_s {
45 	uchar *szBinary;	} configSettings_t;
46 static configSettings_t cs;
47 static struct cnfparamdescr actpdescr[] = {
48 	{ "binary", eCmdHdlrString, CNFPARAM_REQUIRED },
49 	{ "confirmMessages", eCmdHdlrBinary, 0 },
50 	{ "confirmTimeout", eCmdHdlrInt, 0 },
51 <a name="0"></a>	{ "reportFailures", eCmdHdlrBinary, 0 },
52 	{ "useTransactions", eCmdHdlrBinary, 0 },
53 	{ "beginTransactionMark", eCmdHdlrString, 0 },
54 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "commitTransactionMark", eCmdHdlrString, 0 },
55 	{ "forceSingleInstance", eCmdHdlrBinary, 0 },
56 	{ "hup.signal", eCmdHdlrGetWord, 0 },
57 	{ "template", eCmdHdlrGetWord, 0 },
58 	{ "signalOnClose", eCmdHdlrBinary, 0 },
59 	{ "closeTimeout", eCmdHdlrInt, 0 },
60 	{ "killUnresponsive", eCmdHdlrBinary, 0 },
61 	{ "output", eCmdHdlrString, 0 },
62 	{ "fileCreateMode", eCmdHdlrFileCreateMode, 0 }
63 };
64 static struct cnfparamblk actpblk =
65 	{ CNFPARAMBLK_VERSION,
66 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
67 	  actpdescr
68 	};
69 static __attribute__((noreturn)) void</b></font>
70 execBinary(const instanceData *pData, int fdStdin, int fdStdout)
71 {
72 	int fdOutput, maxFd, fd, sigNum;
73 	struct sigaction sigAct;
74 	sigset_t sigSet;
75 	char errStr[1024];
76 	if(dup2(fdStdin, STDIN_FILENO) == -1) {
77 		goto failed;
78 	}
79 	if(pData-&gt;pOutputCaptureCtx != NULL) {
80 		fdOutput = pData-&gt;pOutputCaptureCtx-&gt;fdPipe[1];
81 	} else {
82 		fdOutput = open("/dev/null", O_WRONLY);
83 		if(fdOutput == -1) {
84 			goto failed;
85 		}
86 	}
87 	if(fdStdout != -1) {
88 		if(dup2(fdStdout, STDOUT_FILENO) == -1) {
89 			goto failed;
90 		}
91 	} else {
92 		if(dup2(fdOutput, STDOUT_FILENO) == -1) {
93 			goto failed;
94 		}
95 	}
96 	if(dup2(fdOutput, STDERR_FILENO) == -1) {
97 		goto failed;
98 	}
99 	maxFd = sysconf(_SC_OPEN_MAX);
100 	if(maxFd &lt; 0 || maxFd &gt; MAX_FD_TO_CLOSE) {
101 		maxFd = MAX_FD_TO_CLOSE;
102 	}
103 #	ifdef VALGRIND
104 	else {  		maxFd -= 10;
105 	}
106 #	endif
107 	for(fd = STDERR_FILENO + 1 ; fd &lt;= maxFd ; ++fd) {
108 		close(fd);
109 	}
110 	memset(&amp;sigAct, 0, sizeof(sigAct));
111 	sigemptyset(&amp;sigAct.sa_mask);
112 	sigAct.sa_handler = SIG_DFL;
113 	for(sigNum = 1 ; sigNum &lt; NSIG ; ++sigNum) {
114 		sigaction(sigNum, &amp;sigAct, NULL);
115 	}
116 	sigAct.sa_handler = SIG_IGN;
117 	sigaction(SIGINT, &amp;sigAct, NULL);
118 	sigemptyset(&amp;sigSet);
119 	sigprocmask(SIG_SETMASK, &amp;sigSet, NULL);
120 	alarm(0);
121 	execve((char*)pData-&gt;szBinary, pData-&gt;aParams, environ);
122 failed:
123 	rs_strerror_r(errno, errStr, sizeof(errStr));
124 	DBGPRINTF("omprog: failed to execute program '%s': %s\n",
125 			pData-&gt;szBinary, errStr);
126 	openlog("rsyslogd", 0, LOG_SYSLOG);
127 	syslog(LOG_ERR, "omprog: failed to execute program '%s': %s\n",
128 			pData-&gt;szBinary, errStr);
129 	exit(1);
130 }
131 static rsRetVal
132 openPipe(instanceData *pData, childProcessCtx_t *pChildCtx)
133 {
134 	int pipeStdin[2] = { -1, -1 };
135 	int pipeStdout[2] = { -1, -1 };
136 	pid_t cpid;
137 	DEFiRet;
138 	if(pipe(pipeStdin) == -1) {
139 		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
140 	}
141 	if(pData-&gt;bConfirmMessages &amp;&amp; pipe(pipeStdout) == -1) {
142 		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
143 	}
144 	DBGPRINTF("omprog: executing program '%s' with '%d' parameters\n", pData-&gt;szBinary,
145 			pData-&gt;iParams);
146 	cpid = fork();
147 	if(cpid == -1) {
148 		ABORT_FINALIZE(RS_RET_ERR_FORK);
149 	}
150 	if(cpid == 0) {  		close(pipeStdin[1]);
151 		if(pipeStdout[0] != -1) {
152 			close(pipeStdout[0]);
153 		}
154 		execBinary(pData, pipeStdin[0], pipeStdout[1]);
155 	}
156 	DBGPRINTF("omprog: child has pid %d\n", (int) cpid);
157 	close(pipeStdin[0]);
158 	if(pipeStdout[1] != -1) {
159 		close(pipeStdout[1]);
160 	}
161 	pChildCtx-&gt;fdPipeOut = pipeStdin[1];  	pChildCtx-&gt;fdPipeIn = pipeStdout[0];  	pChildCtx-&gt;pid = cpid;
162 	pChildCtx-&gt;bIsRunning = 1;
163 finalize_it:
164 	if(iRet != RS_RET_OK) {
165 		if(pipeStdin[0] != -1) {
166 			close(pipeStdin[0]);
167 			close(pipeStdin[1]);
168 		}
169 		if(pipeStdout[0] != -1) {
170 			close(pipeStdout[0]);
171 			close(pipeStdout[1]);
172 		}
173 	}
174 	RETiRet;
175 }
176 static void
177 waitForChild(instanceData *pData, childProcessCtx_t *pChildCtx)
178 {
179 	int status;
180 	int ret;
181 	long counter;
182 	counter = pData-&gt;lCloseTimeout / 10;
183 	while ((ret = waitpid(pChildCtx-&gt;pid, &amp;status, WNOHANG)) == 0 &amp;&amp; counter &gt; 0) {
184 		srSleep(0, 10000);  		--counter;
185 	}
186 	if (ret == 0) {  		if (!pData-&gt;bKillUnresponsive) {
187 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' (pid %ld) did not terminate "
188 					"within timeout (%ld ms); ignoring it", pData-&gt;szBinary,
189 					(long) pChildCtx-&gt;pid, pData-&gt;lCloseTimeout);
190 			return;
191 		}
192 		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' (pid %ld) did not terminate "
193 				"within timeout (%ld ms); killing it", pData-&gt;szBinary, (long) pChildCtx-&gt;pid,
194 				pData-&gt;lCloseTimeout);
195 		if (kill(pChildCtx-&gt;pid, SIGKILL) == -1) {
196 			LogError(errno, RS_RET_SYS_ERR, "omprog: could not send SIGKILL to child process");
197 			return;
198 		}
199 		ret = waitpid(pChildCtx-&gt;pid, &amp;status, 0);
200 	}
201 	if(ret == pChildCtx-&gt;pid) {
202 		glblReportChildProcessExit(runConf, pData-&gt;szBinary, pChildCtx-&gt;pid, status);
203 	}
204 }
205 static void
206 cleanupChild(instanceData *pData, childProcessCtx_t *pChildCtx)
207 {
208 	assert(pChildCtx-&gt;bIsRunning);
209 	if(pChildCtx-&gt;fdPipeIn != -1) {
210 		close(pChildCtx-&gt;fdPipeIn);
211 		pChildCtx-&gt;fdPipeIn = -1;
212 	}
213 	if(pChildCtx-&gt;fdPipeOut != -1) {
214 		close(pChildCtx-&gt;fdPipeOut);
215 		pChildCtx-&gt;fdPipeOut = -1;
216 	}
217 	waitForChild(pData, pChildCtx);
218 	pChildCtx-&gt;bIsRunning = 0;
219 }
220 static void
221 terminateChild(instanceData *pData, childProcessCtx_t *pChildCtx)
222 {
223 	assert(pChildCtx-&gt;bIsRunning);
224 	if (pData-&gt;bSignalOnClose) {
225 		kill(pChildCtx-&gt;pid, SIGTERM);
226 	}
227 	cleanupChild(pData, pChildCtx);
228 }
229 static rsRetVal
230 sendMessage(instanceData *pData, childProcessCtx_t *pChildCtx, const uchar *szMsg)
231 {
232 	ssize_t written;
233 	size_t offset = 0;
234 	DEFiRet;
235 	const size_t len = strlen((char*)szMsg);
236 	do {
237 		written = write(pChildCtx-&gt;fdPipeOut, ((char*)szMsg) + offset, len - offset);
238 		if(written == -1) {
239 			if(errno == EINTR) {
240 				continue;  			}
241 			if(errno == EPIPE) {
242 				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
243 						"omprog: program '%s' (pid %ld) terminated; will be restarted",
244 						pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
245 				cleanupChild(pData, pChildCtx);  				ABORT_FINALIZE(RS_RET_SUSPENDED);
246 			}
247 			LogError(errno, RS_RET_ERR_WRITE_PIPE, "omprog: error sending message to program");
248 			ABORT_FINALIZE(RS_RET_SUSPENDED);
249 		}
250 		offset += written;
251 	} while(offset &lt; len);
252 finalize_it:
253 	RETiRet;
254 }
255 static rsRetVal
256 lineToStatusCode(instanceData *pData, const char* line)
257 {
258 	DEFiRet;
259 	while(line[0] == '.') {
260 		++line;
261 	}
262 	if(strcmp(line, "OK") == 0) {
263 		iRet = RS_RET_OK;
264 	} else if(strcmp(line, "DEFER_COMMIT") == 0) {
265 		iRet = RS_RET_DEFER_COMMIT;
266 	} else if(strcmp(line, "PREVIOUS_COMMITTED") == 0) {
267 		iRet = RS_RET_PREVIOUS_COMMITTED;
268 	} else {
269 		DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, line);
270 		if(pData-&gt;bReportFailures) {
271 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
272 					pData-&gt;szBinary, line);
273 		}
274 		iRet = RS_RET_SUSPENDED;
275 	}
276 	RETiRet;
277 }
278 static rsRetVal
279 readStatus(instanceData *pData, childProcessCtx_t *pChildCtx)
280 {
281 	struct pollfd fdToPoll[1];
282 	int numReady;
283 	char lineBuf[RESPONSE_LINE_BUFFER_SIZE];
284 	ssize_t lenRead;
285 	size_t offset = 0;
286 	int lineEnded = 0;
287 	DEFiRet;
288 	fdToPoll[0].fd = pChildCtx-&gt;fdPipeIn;
289 	fdToPoll[0].events = POLLIN;
290 	do {
291 		numReady = poll(fdToPoll, 1, pData-&gt;lConfirmTimeout);
292 		if(numReady == -1) {
293 			if(errno == EINTR) {
294 				continue;  			}
295 			LogError(errno, RS_RET_SYS_ERR, "omprog: error polling for response from program");
296 			ABORT_FINALIZE(RS_RET_SUSPENDED);
297 		}
298 		if(numReady == 0) {  			LogMsg(0, RS_RET_TIMED_OUT, LOG_WARNING, "omprog: program '%s' (pid %ld) did not respond "
299 					"within timeout (%ld ms); will be restarted", pData-&gt;szBinary,
300 					(long) pChildCtx-&gt;pid, pData-&gt;lConfirmTimeout);
301 			terminateChild(pData, pChildCtx);
302 			ABORT_FINALIZE(RS_RET_SUSPENDED);
303 		}
304 		lenRead = read(pChildCtx-&gt;fdPipeIn, lineBuf + offset, sizeof(lineBuf) - offset - 1);
305 		if(lenRead == -1) {
306 			if(errno == EINTR) {
307 				continue;  			}
308 			LogError(errno, RS_RET_READ_ERR, "omprog: error reading response from program");
309 			ABORT_FINALIZE(RS_RET_SUSPENDED);
310 		}
311 		if(lenRead == 0) {
312 			LogMsg(0, RS_RET_READ_ERR, LOG_WARNING, "omprog: program '%s' (pid %ld) terminated; "
313 					"will be restarted", pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
314 			cleanupChild(pData, pChildCtx);
315 			ABORT_FINALIZE(RS_RET_SUSPENDED);
316 		}
317 		offset += lenRead;
318 		lineBuf[offset] = '\0';
319 		lineEnded = (lineBuf[offset-1] == '\n');
320 		if(!lineEnded &amp;&amp; strchr(lineBuf + offset - lenRead, '\n') != NULL) {
321 			DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, lineBuf);
322 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned a multiline response; "
323 					"will be restarted", pData-&gt;szBinary);
324 			if(pData-&gt;bReportFailures) {
325 				LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
326 						pData-&gt;szBinary, lineBuf);
327 			}
328 			terminateChild(pData, pChildCtx);
329 			ABORT_FINALIZE(RS_RET_SUSPENDED);
330 		}
331 	} while(!lineEnded &amp;&amp; offset &lt; sizeof(lineBuf) - 1);
332 	if(!lineEnded) {
333 		DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, lineBuf);
334 		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned a too long response; "
335 				"will be restarted", pData-&gt;szBinary);
336 		if(pData-&gt;bReportFailures) {
337 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
338 					pData-&gt;szBinary, lineBuf);
339 		}
340 		terminateChild(pData, pChildCtx);
341 		ABORT_FINALIZE(RS_RET_SUSPENDED);
342 	}
343 	lineBuf[offset-1] = '\0';  
344 	iRet = lineToStatusCode(pData, lineBuf);
345 finalize_it:
346 	RETiRet;
347 }
348 static rsRetVal
349 allocChildCtx(childProcessCtx_t **ppChildCtx)
350 {
351 	childProcessCtx_t *pChildCtx;
352 	DEFiRet;
353 	CHKmalloc(pChildCtx = calloc(1, sizeof(childProcessCtx_t)));
354 	*ppChildCtx = pChildCtx;
355 	pChildCtx-&gt;bIsRunning = 0;
356 	pChildCtx-&gt;pid = -1;
357 	pChildCtx-&gt;fdPipeOut = -1;
358 	pChildCtx-&gt;fdPipeIn = -1;
359 finalize_it:
360 	RETiRet;
361 }
362 static rsRetVal
363 startChild(instanceData *pData, childProcessCtx_t *pChildCtx)
364 {
365 	DEFiRet;
366 	assert(!pChildCtx-&gt;bIsRunning);
367 	CHKiRet(openPipe(pData, pChildCtx));
368 	if(pData-&gt;bConfirmMessages) {
369 		CHKiRet(readStatus(pData, pChildCtx));
370 	}
371 finalize_it:
372 	if(iRet != RS_RET_OK &amp;&amp; pChildCtx-&gt;bIsRunning) {
373 		terminateChild(pData, pChildCtx);
374 	}
375 	RETiRet;
376 }
377 static rsRetVal
378 startSingleChildOnce(instanceData *pData)
379 {
380 	DEFiRet;
381 	assert(pData-&gt;bForceSingleInst);
382 	CHKiConcCtrl(pthread_mutex_lock(pData-&gt;pSingleChildMut));
383 	if(pData-&gt;pSingleChildCtx-&gt;bIsRunning)
384 		goto finalize_it;  
385 	iRet = startChild(pData, pData-&gt;pSingleChildCtx);
386 finalize_it:
387 	pthread_mutex_unlock(pData-&gt;pSingleChildMut);
388 	RETiRet;
389 }
390 static void
391 writeOutputToFile(outputCaptureCtx_t *pCtx, char *buf, ssize_t len)
392 {
393 	ssize_t written;
394 	ssize_t offset = 0;
395 	assert(pCtx-&gt;bIsRunning);
396 	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);
397 	if(pCtx-&gt;fdFile == -1) {
398 		if(pCtx-&gt;bFileErr) {  			goto done;
399 		}
400 		pCtx-&gt;fdFile = open((char*)pCtx-&gt;szFileName, O_WRONLY | O_APPEND | O_CREAT,
401 				pCtx-&gt;fCreateMode);
402 		if(pCtx-&gt;fdFile == -1) {
403 			LogError(errno, RS_RET_NO_FILE_ACCESS, "omprog: error opening output file %s; "
404 					"output from program will be discarded", pCtx-&gt;szFileName);
405 			pCtx-&gt;bFileErr = 1;  			goto done;
406 		}
407 	}
408 	do {
409 		written = write(pCtx-&gt;fdFile, buf + offset, len - offset);
410 		if(written == -1) {
411 			if(errno == EINTR) {
412 				continue;  			}
413 			if(!pCtx-&gt;bWriteErr) {
414 				LogError(errno, RS_RET_SYS_ERR, "omprog: error writing to output file "
415 						"(subsequent errors will not be reported)");
416 				pCtx-&gt;bWriteErr = 1;  			}
417 			break;
418 		}
419 		if(pCtx-&gt;bWriteErr) {
420 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: resumed writing to output file");
421 			pCtx-&gt;bWriteErr = 0;
422 		}
423 		offset += written;
424 	} while(offset &lt; len);
425 done:
426 	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
427 }
428 static void
429 closeOutputFile(outputCaptureCtx_t *pCtx)
430 {
431 	DBGPRINTF("omprog: reopening output file upon reception of HUP signal\n");
432 	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);
433 	if(pCtx-&gt;fdFile != -1) {
434 		close(pCtx-&gt;fdFile);
435 		pCtx-&gt;fdFile = -1;
436 	}
437 	pCtx-&gt;bFileErr = 0;  
438 	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
439 }
440 static void *
441 captureOutput(void *_pCtx) {
442 	outputCaptureCtx_t *pCtx = (outputCaptureCtx_t *)_pCtx;
443 	sigset_t sigSet;
444 	char readBuf[OUTPUT_CAPTURE_BUFFER_SIZE];
445 	ssize_t lenRead;
446 	DBGPRINTF("omprog: starting output capture thread\n");
447 	sigfillset(&amp;sigSet);
448 	pthread_sigmask(SIG_SETMASK, &amp;sigSet, NULL);
449 	for(;;) {
450 		lenRead = read(pCtx-&gt;fdPipe[0], readBuf, sizeof(readBuf));
451 		if(lenRead == -1) {
452 			if(errno == EINTR) {
453 				continue;  			}
454 			if(!pCtx-&gt;bReadErr) {
455 				LogError(errno, RS_RET_SYS_ERR, "omprog: error capturing output from program "
456 						"(subsequent errors will not be reported)");
457 				pCtx-&gt;bReadErr = 1;  			}
458 			continue;  		}
459 		if(lenRead == 0) {
460 			break;  		}
461 		if(pCtx-&gt;bReadErr) {
462 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: resumed capturing output from program");
463 			pCtx-&gt;bReadErr = 0;
464 		}
465 		writeOutputToFile(pCtx, readBuf, lenRead);
466 	}
467 	DBGPRINTF("omprog: all output-capture pipe ends closed, terminating output capture thread\n");
468 	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
469 	pCtx-&gt;bIsRunning = 0;
470 	pthread_cond_signal(&amp;pCtx-&gt;condTerm);
471 	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);
472 	return NULL;
473 }
474 static rsRetVal
475 allocOutputCaptureCtx(outputCaptureCtx_t **ppCtx)
476 {
477 	outputCaptureCtx_t *pCtx;
478 	DEFiRet;
479 	CHKmalloc(pCtx = calloc(1, sizeof(outputCaptureCtx_t)));
480 	*ppCtx = pCtx;
481 	pCtx-&gt;szFileName = NULL;
482 	pCtx-&gt;fCreateMode = 0600;
483 	pCtx-&gt;bIsRunning = 0;
484 	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutStart, NULL));
485 	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutWrite, NULL));
486 	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutTerm, NULL));
487 	CHKiConcCtrl(pthread_cond_init(&amp;pCtx-&gt;condTerm, NULL));
488 finalize_it:
489 	RETiRet;
490 }
491 static void
492 freeOutputCaptureCtx(outputCaptureCtx_t *pCtx) {
493 	if(pCtx-&gt;szFileName != NULL) {
494 		free(pCtx-&gt;szFileName);
495 	}
496 	pthread_cond_destroy(&amp;pCtx-&gt;condTerm);
497 	pthread_mutex_destroy(&amp;pCtx-&gt;mutTerm);
498 	pthread_mutex_destroy(&amp;pCtx-&gt;mutWrite);
499 	pthread_mutex_destroy(&amp;pCtx-&gt;mutStart);
500 	free(pCtx);
501 }
502 static rsRetVal
503 startOutputCaptureOnce(outputCaptureCtx_t *pCtx)
504 {
505 	int pip[2] = { -1, -1 };
506 	DEFiRet;
507 	CHKiConcCtrl(pthread_mutex_lock(&amp;pCtx-&gt;mutStart));
508 	if(pCtx-&gt;bIsRunning)
509 		goto finalize_it;  
510 	if(pipe(pip) == -1) {
511 		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
512 	}
513 	pCtx-&gt;fdPipe[0] = pip[0];
514 	pCtx-&gt;fdPipe[1] = pip[1];
515 	pCtx-&gt;fdFile = -1;
516 	pCtx-&gt;bFileErr = 0;
517 	pCtx-&gt;bReadErr = 0;
518 	pCtx-&gt;bWriteErr = 0;
519 	CHKiConcCtrl(pthread_create(&amp;pCtx-&gt;thrdID, NULL, captureOutput, (void *)pCtx));
520 	pCtx-&gt;bIsRunning = 1;
521 finalize_it:
522 	if(iRet != RS_RET_OK &amp;&amp; pip[0] != -1) {
523 		close(pip[0]);
524 		close(pip[1]);
525 	}
526 	pthread_mutex_unlock(&amp;pCtx-&gt;mutStart);
527 	RETiRet;
528 }
529 static void
530 endOutputCapture(outputCaptureCtx_t *pCtx, long timeoutMs)
531 {
532 	struct timespec ts;
533 	int bTimedOut;
534 	assert(pCtx-&gt;bIsRunning);
535 	close(pCtx-&gt;fdPipe[1]);
536 	timeoutComp(&amp;ts, timeoutMs);
537 	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
538 	bTimedOut = 0;
539 	while(pCtx-&gt;bIsRunning &amp;&amp; !bTimedOut) {
540 		if(pthread_cond_timedwait(&amp;pCtx-&gt;condTerm, &amp;pCtx-&gt;mutTerm, &amp;ts) == ETIMEDOUT) {
541 			bTimedOut = 1;
542 		}
543 	}
544 	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);
545 	if(bTimedOut) {
546 		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: forcing termination of output capture "
547 				"thread because of unresponsive child process");
548 		pthread_cancel(pCtx-&gt;thrdID);
549 		pCtx-&gt;bIsRunning = 0;
550 	}
551 	pthread_join(pCtx-&gt;thrdID, NULL);
552 	close(pCtx-&gt;fdPipe[0]);
553 	if(pCtx-&gt;fdFile != -1) {
554 		close(pCtx-&gt;fdFile);
555 	}
556 }
557 BEGINinitConfVars		CODESTARTinitConfVars
558 	cs.szBinary = NULL;	ENDinitConfVars
559 BEGINcreateInstance
560 CODESTARTcreateInstance
561 	pData-&gt;szBinary = NULL;
562 	pData-&gt;szTemplateName = NULL;
563 	pData-&gt;aParams = NULL;
564 	pData-&gt;iParams = 0;
565 	pData-&gt;bConfirmMessages = 0;
566 	pData-&gt;block_if_err = 0;
567 	pData-&gt;lConfirmTimeout = DEFAULT_CONFIRM_TIMEOUT_MS;
568 	pData-&gt;bReportFailures = 0;
569 	pData-&gt;bUseTransactions = 0;
570 	pData-&gt;szBeginTransactionMark = NULL;
571 	pData-&gt;szCommitTransactionMark = NULL;
572 	pData-&gt;iHUPForward = NO_HUP_FORWARD;
573 	pData-&gt;bSignalOnClose = 0;
574 	pData-&gt;lCloseTimeout = DEFAULT_CLOSE_TIMEOUT_MS;
575 	pData-&gt;bKillUnresponsive = -1;
576 	pData-&gt;bForceSingleInst = 0;
577 	pData-&gt;pSingleChildCtx = NULL;
578 	pData-&gt;pSingleChildMut = NULL;
579 	pData-&gt;pOutputCaptureCtx = NULL;
580 ENDcreateInstance
581 static rsRetVal
582 postInitInstance(instanceData *pData)
583 {
584 	DEFiRet;
585 	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szBeginTransactionMark == NULL) {
586 		pData-&gt;szBeginTransactionMark = (uchar*)strdup("BEGIN TRANSACTION");
587 	}
588 	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szCommitTransactionMark == NULL) {
589 		pData-&gt;szCommitTransactionMark = (uchar*)strdup("COMMIT TRANSACTION");
590 	}
591 	if(pData-&gt;bKillUnresponsive == -1) {  		pData-&gt;bKillUnresponsive = pData-&gt;bSignalOnClose;
592 	}
593 	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;szFileName == NULL) {
594 		LogError(0, RS_RET_CONF_PARAM_INVLD, "omprog: the 'fileCreateMode' parameter requires "
595 				"specifying the 'output' parameter also");
596 		ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
597 	}
598 	if(pData-&gt;bForceSingleInst) {
599 		CHKmalloc(pData-&gt;pSingleChildMut = calloc(1, sizeof(pthread_mutex_t)));
600 		CHKiConcCtrl(pthread_mutex_init(pData-&gt;pSingleChildMut, NULL));
601 		CHKiRet(allocChildCtx(&amp;pData-&gt;pSingleChildCtx));
602 	}
603 finalize_it:
604 	RETiRet;
605 }
606 BEGINcreateWrkrInstance
607 CODESTARTcreateWrkrInstance
608 	pWrkrData-&gt;pChildCtx = NULL;
609 	if(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx != NULL) {
610 		CHKiRet(startOutputCaptureOnce(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx));
611 	}
612 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
613 		CHKiRet(startSingleChildOnce(pWrkrData-&gt;pData));
614 		pWrkrData-&gt;pChildCtx = pData-&gt;pSingleChildCtx;
615 	} else {
616 		CHKiRet(allocChildCtx(&amp;pWrkrData-&gt;pChildCtx));
617 		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
618 	}
619 finalize_it:
620 	if(iRet != RS_RET_OK &amp;&amp; !pWrkrData-&gt;pData-&gt;bForceSingleInst) {
621 		free(pWrkrData-&gt;pChildCtx);
622 	}
623 ENDcreateWrkrInstance
624 BEGINisCompatibleWithFeature
625 CODESTARTisCompatibleWithFeature
626 	if(eFeat == sFEATURERepeatedMsgReduction) {
627 		iRet = RS_RET_OK;
628 	}
629 ENDisCompatibleWithFeature
630 BEGINdbgPrintInstInfo
631 CODESTARTdbgPrintInstInfo
632 ENDdbgPrintInstInfo
633 BEGINtryResume
634 CODESTARTtryResume
635 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
636 		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
637 	}
638 	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
639 		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
640 	}
641 finalize_it:
642 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
643 		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
644 	}
645 ENDtryResume
646 BEGINbeginTransaction
647 CODESTARTbeginTransaction
648 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
649 		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
650 	}
651 	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
652 		FINALIZE;
653 	}
654 	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
655 			pWrkrData-&gt;pData-&gt;szBeginTransactionMark));
656 	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
657 	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
658 		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
659 	}
660 finalize_it:
661 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
662 		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
663 	}
664 ENDbeginTransaction
665 BEGINdoAction
666 CODESTARTdoAction
667 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
668 		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
669 	}
670 	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {  		ABORT_FINALIZE(RS_RET_SUSPENDED);
671 	}
672 	const uchar *const szMsg = ppString[0];
673 	const size_t len = strlen((char*)szMsg);
674 	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, szMsg));
675 	if(szMsg[len-1] != '\n') {
676 		const time_t tt = time(NULL);
677 		if(tt &gt; pWrkrData-&gt;pData-&gt;block_if_err) {
678 			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: messages must be terminated with \\n "
679 				"at end of message, but this message is not: '%s'\n", ppString[0]);
680 			pWrkrData-&gt;pData-&gt;block_if_err = tt + 30;
681 		}
682 		CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
683 	}
684 	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
685 		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
686 	} else if(pWrkrData-&gt;pData-&gt;bUseTransactions) {
687 		iRet = RS_RET_DEFER_COMMIT;
688 	}
689 finalize_it:
690 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
691 		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
692 	}
693 ENDdoAction
694 BEGINendTransaction
695 CODESTARTendTransaction
696 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
697 		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
698 	}
699 	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
700 		FINALIZE;
701 	}
702 	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
703 			pWrkrData-&gt;pData-&gt;szCommitTransactionMark));
704 	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
705 	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
706 		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
707 	}
708 finalize_it:
709 	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
710 		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
711 	}
712 ENDendTransaction
713 BEGINfreeWrkrInstance
714 CODESTARTfreeWrkrInstance
715 	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst) {
716 		if(pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
717 			terminateChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx);
718 		}
719 		free(pWrkrData-&gt;pChildCtx);
720 	}
721 ENDfreeWrkrInstance
722 BEGINfreeInstance
723 	int i;
724 CODESTARTfreeInstance
725 	if(pData-&gt;pSingleChildCtx != NULL) {
726 		if(pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
727 			terminateChild(pData, pData-&gt;pSingleChildCtx);
728 		}
729 		free(pData-&gt;pSingleChildCtx);
730 	}
731 	if(pData-&gt;pSingleChildMut != NULL) {
732 		pthread_mutex_destroy(pData-&gt;pSingleChildMut);
733 		free(pData-&gt;pSingleChildMut);
734 	}
735 	if(pData-&gt;pOutputCaptureCtx != NULL) {
736 		if(pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
737 			endOutputCapture(pData-&gt;pOutputCaptureCtx, pData-&gt;lCloseTimeout);
738 		}
739 		freeOutputCaptureCtx(pData-&gt;pOutputCaptureCtx);
740 	}
741 	free(pData-&gt;szBinary);
742 	free(pData-&gt;szTemplateName);
743 	free(pData-&gt;szBeginTransactionMark);
744 	free(pData-&gt;szCommitTransactionMark);
745 	if(pData-&gt;aParams != NULL) {
746 		for (i = 0; i &lt; pData-&gt;iParams; i++) {
747 			free(pData-&gt;aParams[i]);
748 		}
749 		free(pData-&gt;aParams);
750 	}
751 ENDfreeInstance
752 BEGINnewActInst
753 	struct cnfparamvals *pvals;
754 	int i;
755 CODESTARTnewActInst
756 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
757 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
758 	}
759 	CHKiRet(createInstance(&amp;pData));
760 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
761 		if(!pvals[i].bUsed)
762 			continue;
763 		if(!strcmp(actpblk.descr[i].name, "binary")) {
764 			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
765 				pvals[i].val.d.estr));
766 		} else if(!strcmp(actpblk.descr[i].name, "confirmMessages")) {
767 <a name="2"></a>			pData-&gt;bConfirmMessages = (int) pvals[i].val.d.n;
768 		} else if(!strcmp(actpblk.descr[i].name, "confirmTimeout")) {
769 			pData-&gt;lConfirmTimeout = (long) pvals[i].val.d.n;
770 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "reportFailures")) {
771 			pData-&gt;bReportFailures = (int) pvals[i].val.d.n;
772 		} else if(!strcmp(actpblk.descr[i].name, "useTransactions")) {
773 <a name="1"></a>			pData-&gt;bUseTransactions = (int) pvals[i].val.d.n;
774 		} else if(!strcmp(actpblk.descr[i].name, "beginTransactionMark")) {
775 			pData-&gt;szBeginTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
776 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "commitTransactionMark")) {
777 			pData-&gt;szCommitTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
778 		} else if(!strcmp(actpblk.descr[i].name, "forceSingleInstance")) {
779 			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
780 		} else if(!strcmp(actpblk.descr[i].name, "signalOnClose")) {
781 			pData-&gt;bSignalOnClose = (int) pvals[i].val.d.n;
782 		} else if(!strcmp(actpblk.descr[i].name, "closeTimeout")) {
783 			pData-&gt;lCloseTimeout = (long) pvals[i].val.d.n;</b></font>
784 		} else if(!strcmp(actpblk.descr[i].name, "killUnresponsive")) {
785 			pData-&gt;bKillUnresponsive = (int) pvals[i].val.d.n;
786 		} else if(!strcmp(actpblk.descr[i].name, "hup.signal")) {
787 			const char *const sig = es_str2cstr(pvals[i].val.d.estr, NULL);
788 			if(!strcmp(sig, "HUP"))
789 				pData-&gt;iHUPForward = SIGHUP;
790 			else if(!strcmp(sig, "USR1"))
791 				pData-&gt;iHUPForward = SIGUSR1;
792 			else if(!strcmp(sig, "USR2"))
793 				pData-&gt;iHUPForward = SIGUSR2;
794 			else if(!strcmp(sig, "INT"))
795 				pData-&gt;iHUPForward = SIGINT;
796 			else if(!strcmp(sig, "TERM"))
797 				pData-&gt;iHUPForward = SIGTERM;
798 			else {
799 				LogError(0, RS_RET_CONF_PARAM_INVLD,
800 					"omprog: hup.signal '%s' in hup.signal parameter", sig);
801 				ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
802 			}
803 			free((void*)sig);
804 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
805 			pData-&gt;szTemplateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
806 		} else if(!strcmp(actpblk.descr[i].name, "output")) {
807 			if(pData-&gt;pOutputCaptureCtx == NULL) {
808 				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
809 			}
810 			pData-&gt;pOutputCaptureCtx-&gt;szFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
811 		} else if(!strcmp(actpblk.descr[i].name, "fileCreateMode")) {
812 			if(pData-&gt;pOutputCaptureCtx == NULL) {
813 				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
814 			}
815 			pData-&gt;pOutputCaptureCtx-&gt;fCreateMode = (mode_t) pvals[i].val.d.n;
816 		} else {
817 			DBGPRINTF("omprog: program error, non-handled param '%s'\n", actpblk.descr[i].name);
818 		}
819 	}
820 	CODE_STD_STRING_REQUESTnewActInst(1)
821 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup(pData-&gt;szTemplateName == NULL ?
822 			"RSYSLOG_FileFormat" : (char*)pData-&gt;szTemplateName), OMSR_NO_RQD_TPL_OPTS));
823 	iRet = postInitInstance(pData);
824 CODE_STD_FINALIZERnewActInst
825 	cnfparamvalsDestruct(pvals, &amp;actpblk);
826 ENDnewActInst
827 BEGINparseSelectorAct
828 CODESTARTparseSelectorAct
829 CODE_STD_STRING_REQUESTparseSelectorAct(1)
830 	if(strncmp((char*) p, ":omprog:", sizeof(":omprog:") - 1)) {
831 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
832 	}
833 	p += sizeof(":omprog:") - 1; 	if(cs.szBinary == NULL) {
834 		LogError(0, RS_RET_CONF_RQRD_PARAM_MISSING, "no binary to execute specified");
835 		ABORT_FINALIZE(RS_RET_CONF_RQRD_PARAM_MISSING);
836 	}
837 	CHKiRet(createInstance(&amp;pData));
838 	CHKmalloc(pData-&gt;szBinary = (uchar*) strdup((char*)cs.szBinary));
839 	if(*(p-1) == ';')
840 		--p;
841 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, 0, (uchar*) "RSYSLOG_FileFormat"));
842 	iRet = postInitInstance(pData);
843 CODE_STD_FINALIZERparseSelectorAct
844 ENDparseSelectorAct
845 BEGINdoHUP
846 CODESTARTdoHUP
847 	if(pData-&gt;bForceSingleInst &amp;&amp; pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
848 			pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
849 		DBGPRINTF("omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n",
850 				pData-&gt;szBinary, (long) pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
851 		kill(pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
852 	}
853 	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
854 		closeOutputFile(pData-&gt;pOutputCaptureCtx);
855 	}
856 ENDdoHUP
857 BEGINdoHUPWrkr
858 CODESTARTdoHUPWrkr
859 	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst &amp;&amp; pWrkrData-&gt;pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
860 	 		pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
861 		DBGPRINTF("omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n",
862 				pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pChildCtx-&gt;pid,
863 				pWrkrData-&gt;pData-&gt;iHUPForward);
864 		kill(pWrkrData-&gt;pChildCtx-&gt;pid, pWrkrData-&gt;pData-&gt;iHUPForward);
865 	}
866 ENDdoHUPWrkr
867 BEGINmodExit
868 CODESTARTmodExit
869 	free(cs.szBinary);
870 	cs.szBinary = NULL;
871 ENDmodExit
872 BEGINqueryEtryPt
873 CODESTARTqueryEtryPt
874 CODEqueryEtryPt_STD_OMOD_QUERIES
875 CODEqueryEtryPt_STD_OMOD8_QUERIES
876 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
877 CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_doHUP
878 CODEqueryEtryPt_doHUPWrkr
879 ENDqueryEtryPt
880 static rsRetVal
881 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
882 {
883 	DEFiRet;
884 	free(cs.szBinary);
885 	cs.szBinary = NULL;
886 	RETiRet;
887 }
888 BEGINmodInit()
889 CODESTARTmodInit
890 INITLegCnfVars
891 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
892 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
893 	if (!bCoreSupportsBatching) {
894 		LogError(0, NO_ERRCODE, "omprog: rsyslog core too old (does not support batching)");
895 		ABORT_FINALIZE(RS_RET_ERR);
896 	}
897 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomprogbinary", 0, eCmdHdlrGetWord, NULL, &amp;cs.szBinary,
898 		STD_LOADABLE_MODULE_ID));
899 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
900 		NULL, STD_LOADABLE_MODULE_ID));
901 CODEmodInit_QueryRegCFSLineHdlr
902 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
