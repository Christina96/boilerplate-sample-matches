
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qdec.h</h3>
            <pre><code>1  #ifndef NRF_QDEC_H__
2  #define NRF_QDEC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_QDEC_LED_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_QDEC_TASK_START      = offsetof(NRF_QDEC_Type, TASKS_START),     &bsol;**< Starting the quadrature decoder. */
11      NRF_QDEC_TASK_STOP       = offsetof(NRF_QDEC_Type, TASKS_STOP),      &bsol;**< Stopping the quadrature decoder. */
12      NRF_QDEC_TASK_READCLRACC = offsetof(NRF_QDEC_Type, TASKS_READCLRACC) &bsol;**< Reading and clearing ACC and ACCDBL registers. */
13  } nrf_qdec_task_t;
14  typedef enum
15  {
16      NRF_QDEC_EVENT_SAMPLERDY = offsetof(NRF_QDEC_Type, EVENTS_SAMPLERDY), &bsol;**< Event generated for every new sample.  */
17      NRF_QDEC_EVENT_REPORTRDY = offsetof(NRF_QDEC_Type, EVENTS_REPORTRDY), &bsol;**< Event generated for every new report.  */
18      NRF_QDEC_EVENT_ACCOF     = offsetof(NRF_QDEC_Type, EVENTS_ACCOF)      &bsol;**< Event generated for every accumulator overflow. */
19  } nrf_qdec_event_t;
20  typedef enum
21  {
22      NRF_QDEC_SHORT_REPORTRDY_READCLRACC_MASK = QDEC_SHORTS_REPORTRDY_READCLRACC_Msk, &bsol;**< Shortcut between REPORTRDY event and READCLRACC task.  */
23      NRF_QDEC_SHORT_SAMPLERDY_STOP_MASK       = QDEC_SHORTS_SAMPLERDY_STOP_Msk        &bsol;**< Shortcut between SAMPLERDY event and STOP task.  */
24  } nrf_qdec_short_mask_t;
25  typedef enum
26  {
27      NRF_QDEC_INT_SAMPLERDY_MASK = QDEC_INTENSET_SAMPLERDY_Msk, &bsol;**< Mask for enabling or disabling an interrupt on SAMPLERDY event.  */
28      NRF_QDEC_INT_REPORTRDY_MASK = QDEC_INTENSET_REPORTRDY_Msk, &bsol;**< Mask for enabling or disabling an interrupt on REPORTRDY event.  */
29      NRF_QDEC_INT_ACCOF_MASK     = QDEC_INTENSET_ACCOF_Msk      &bsol;**< Mask for enabling or disabling an interrupt on ACCOF event.  */
30  } nrf_qdec_int_mask_t;
31  typedef enum
32  {
33      NRF_QDEC_DISABLE = QDEC_ENABLE_ENABLE_Disabled, &bsol;**< Mask for disabling the QDEC periperal. When disabled, the QDEC decoder pins are not active.  */
34      NRF_QDEC_ENABLE  = QDEC_ENABLE_ENABLE_Enabled   &bsol;**< Mask for enabling the QDEC periperal. When enabled, the QDEC pins are active. */
35  } nrf_qdec_enable_t;
36  typedef enum
37  {
38      NRF_QDEC_DBFEN_DISABLE = QDEC_DBFEN_DBFEN_Disabled, &bsol;**< Mask for disabling the debounce filter.  */
39      NRF_QDEC_DBFEN_ENABLE  = QDEC_DBFEN_DBFEN_Enabled   &bsol;**< Mask for enabling the debounce filter.  */
40  } nrf_qdec_dbfen_t;
41  typedef enum
42  {
43      NRF_QDEC_LEPOL_ACTIVE_LOW  = QDEC_LEDPOL_LEDPOL_ActiveLow, &bsol;**< QDEC LED active on output pin low.  */
44      NRF_QDEC_LEPOL_ACTIVE_HIGH = QDEC_LEDPOL_LEDPOL_ActiveHigh &bsol;**< QDEC LED active on output pin high.  */
45  } nrf_qdec_ledpol_t;
46  typedef enum
47  {
48      NRF_QDEC_SAMPLEPER_128us   = QDEC_SAMPLEPER_SAMPLEPER_128us,  &bsol;**< QDEC sampling period 128 microseconds.  */
49      NRF_QDEC_SAMPLEPER_256us   = QDEC_SAMPLEPER_SAMPLEPER_256us,  &bsol;**< QDEC sampling period 256 microseconds.  */
50      NRF_QDEC_SAMPLEPER_512us   = QDEC_SAMPLEPER_SAMPLEPER_512us,  &bsol;**< QDEC sampling period 512 microseconds.  */
51      NRF_QDEC_SAMPLEPER_1024us  = QDEC_SAMPLEPER_SAMPLEPER_1024us, &bsol;**< QDEC sampling period 1024 microseconds.  */
52      NRF_QDEC_SAMPLEPER_2048us  = QDEC_SAMPLEPER_SAMPLEPER_2048us, &bsol;**< QDEC sampling period 2048 microseconds.  */
53      NRF_QDEC_SAMPLEPER_4096us  = QDEC_SAMPLEPER_SAMPLEPER_4096us, &bsol;**< QDEC sampling period 4096 microseconds.  */
54      NRF_QDEC_SAMPLEPER_8192us  = QDEC_SAMPLEPER_SAMPLEPER_8192us, &bsol;**< QDEC sampling period 8192 microseconds.  */
55      NRF_QDEC_SAMPLEPER_16384us = QDEC_SAMPLEPER_SAMPLEPER_16384us &bsol;**< QDEC sampling period 16384 microseconds.  */
56  } nrf_qdec_sampleper_t;
57  typedef enum
58  {
59      NRF_QDEC_REPORTPER_10  = QDEC_REPORTPER_REPORTPER_10Smpl,  &bsol;**< QDEC report period 10 samples.  */
60      NRF_QDEC_REPORTPER_40  = QDEC_REPORTPER_REPORTPER_40Smpl,  &bsol;**< QDEC report period 40 samples.  */
61      NRF_QDEC_REPORTPER_80  = QDEC_REPORTPER_REPORTPER_80Smpl,  &bsol;**< QDEC report period 80 samples.  */
62      NRF_QDEC_REPORTPER_120 = QDEC_REPORTPER_REPORTPER_120Smpl, &bsol;**< QDEC report period 120 samples. */
63      NRF_QDEC_REPORTPER_160 = QDEC_REPORTPER_REPORTPER_160Smpl, &bsol;**< QDEC report period 160 samples. */
64      NRF_QDEC_REPORTPER_200 = QDEC_REPORTPER_REPORTPER_200Smpl, &bsol;**< QDEC report period 200 samples. */
65      NRF_QDEC_REPORTPER_240 = QDEC_REPORTPER_REPORTPER_240Smpl, &bsol;**< QDEC report period 240 samples. */
66      NRF_QDEC_REPORTPER_280 = QDEC_REPORTPER_REPORTPER_280Smpl, &bsol;**< QDEC report period 280 samples. */
67      NRF_QDEC_REPORTPER_DISABLED                                &bsol;**< QDEC reporting disabled.        */
68  } nrf_qdec_reportper_t;
69  NRF_STATIC_INLINE void nrf_qdec_enable(NRF_QDEC_Type * p_reg);
70  NRF_STATIC_INLINE void nrf_qdec_disable(NRF_QDEC_Type * p_reg);
71  NRF_STATIC_INLINE uint32_t nrf_qdec_enable_get(NRF_QDEC_Type const * p_reg);
72  NRF_STATIC_INLINE void nrf_qdec_int_enable(NRF_QDEC_Type * p_reg, uint32_t mask);
73  NRF_STATIC_INLINE void nrf_qdec_int_disable(NRF_QDEC_Type * p_reg, uint32_t mask);
74  NRF_STATIC_INLINE uint32_t nrf_qdec_int_enable_check(NRF_QDEC_Type const * p_reg, uint32_t mask);
75  NRF_STATIC_INLINE void nrf_qdec_dbfen_enable(NRF_QDEC_Type * p_reg);
76  NRF_STATIC_INLINE void nrf_qdec_dbfen_disable(NRF_QDEC_Type * p_reg);
77  NRF_STATIC_INLINE uint32_t nrf_qdec_dbfen_get(NRF_QDEC_Type const * p_reg);
78  NRF_STATIC_INLINE void nrf_qdec_pio_assign(NRF_QDEC_Type * p_reg,
79                                             uint32_t        psela,
80                                             uint32_t        pselb,
81                                             uint32_t        pselled);
82  NRF_STATIC_INLINE void nrf_qdec_task_trigger(NRF_QDEC_Type * p_reg, nrf_qdec_task_t task);
83  NRF_STATIC_INLINE uint32_t nrf_qdec_task_address_get(NRF_QDEC_Type const * p_reg,
84                                                       nrf_qdec_task_t       task);
85  NRF_STATIC_INLINE void nrf_qdec_event_clear(NRF_QDEC_Type * p_reg, nrf_qdec_event_t event);
86  NRF_STATIC_INLINE bool nrf_qdec_event_check(NRF_QDEC_Type const * p_reg, nrf_qdec_event_t event);
87  NRF_STATIC_INLINE uint32_t nrf_qdec_event_address_get(NRF_QDEC_Type const * p_reg,
88                                                        nrf_qdec_event_t      event);
89  NRF_STATIC_INLINE void nrf_qdec_shorts_enable(NRF_QDEC_Type * p_reg, uint32_t mask);
90  NRF_STATIC_INLINE void nrf_qdec_shorts_disable(NRF_QDEC_Type * p_reg, uint32_t mask);
91  NRF_STATIC_INLINE uint32_t nrf_qdec_sampleper_to_value(nrf_qdec_sampleper_t sampleper);
92  NRF_STATIC_INLINE void nrf_qdec_sampleper_set(NRF_QDEC_Type *      p_reg,
93                                                nrf_qdec_sampleper_t sampleper);
94  NRF_STATIC_INLINE nrf_qdec_sampleper_t nrf_qdec_sampleper_get(NRF_QDEC_Type const * p_reg);
95  NRF_STATIC_INLINE int32_t nrf_qdec_sample_get(NRF_QDEC_Type const * p_reg);
96  NRF_STATIC_INLINE int32_t nrf_qdec_acc_get(NRF_QDEC_Type const * p_reg);
97  NRF_STATIC_INLINE int32_t nrf_qdec_accread_get(NRF_QDEC_Type const * p_reg);
98  NRF_STATIC_INLINE uint32_t nrf_qdec_accdbl_get(NRF_QDEC_Type const * p_reg);
99  NRF_STATIC_INLINE uint32_t nrf_qdec_accdblread_get(NRF_QDEC_Type const * p_reg);
100  NRF_STATIC_INLINE void nrf_qdec_ledpre_set(NRF_QDEC_Type * p_reg, uint32_t time_us);
101  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpre_get(NRF_QDEC_Type const * p_reg);
102  NRF_STATIC_INLINE void nrf_qdec_reportper_set(NRF_QDEC_Type *      p_reg,
103                                                nrf_qdec_reportper_t reportper);
104  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_get(NRF_QDEC_Type const * p_reg);
105  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_to_value(uint32_t reportper);
106  NRF_STATIC_INLINE void nrf_qdec_ledpol_set(NRF_QDEC_Type * p_reg, nrf_qdec_ledpol_t pol);
107  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpol_get(NRF_QDEC_Type const * p_reg);
108  #ifndef NRF_DECLARE_ONLY
109  NRF_STATIC_INLINE void nrf_qdec_enable(NRF_QDEC_Type * p_reg)
110  {
111      p_reg->ENABLE = NRF_QDEC_ENABLE;
112  }
113  NRF_STATIC_INLINE void nrf_qdec_disable(NRF_QDEC_Type * p_reg)
114  {
115      p_reg->ENABLE = NRF_QDEC_DISABLE;
116  }
117  NRF_STATIC_INLINE uint32_t nrf_qdec_enable_get(NRF_QDEC_Type const * p_reg)
118  {
119      return p_reg->ENABLE;
120  }
121  NRF_STATIC_INLINE void nrf_qdec_int_enable(NRF_QDEC_Type * p_reg, uint32_t mask)
122  {
123      p_reg->INTENSET = mask; 
124  }
125  NRF_STATIC_INLINE void nrf_qdec_int_disable(NRF_QDEC_Type * p_reg, uint32_t mask)
126  {
127      p_reg->INTENCLR = mask; 
128  }
129  NRF_STATIC_INLINE uint32_t nrf_qdec_int_enable_check(NRF_QDEC_Type const * p_reg, uint32_t mask)
130  {
131      return p_reg->INTENSET & mask; 
132  }
133  NRF_STATIC_INLINE void nrf_qdec_dbfen_enable(NRF_QDEC_Type * p_reg)
134  {
135      p_reg->DBFEN = NRF_QDEC_DBFEN_ENABLE;
136  }
137  NRF_STATIC_INLINE void nrf_qdec_dbfen_disable(NRF_QDEC_Type * p_reg)
138  {
139      p_reg->DBFEN = NRF_QDEC_DBFEN_DISABLE;
140  }
141  NRF_STATIC_INLINE uint32_t nrf_qdec_dbfen_get(NRF_QDEC_Type const * p_reg)
142  {
143      return p_reg->DBFEN;
144  }
145  NRF_STATIC_INLINE void nrf_qdec_pio_assign(NRF_QDEC_Type * p_reg,
146                                             uint32_t        psela,
147                                             uint32_t        pselb,
148                                             uint32_t        pselled)
149  {
150  #if defined(QDEC_PSEL_A_CONNECT_Pos)
151      p_reg->PSEL.A = psela;
152  #else
153      p_reg->PSELA = psela;
154  #endif
155  #if defined(QDEC_PSEL_B_CONNECT_Pos)
156      p_reg->PSEL.B = pselb;
157  #else
158      p_reg->PSELB = pselb;
159  #endif
160  #if defined(QDEC_PSEL_LED_CONNECT_Pos)
161      p_reg->PSEL.LED = pselled;
162  #else
<span onclick='openModal()' class='match'>163      p_reg->PSELLED = pselled;
164  #endif
165  }
166  NRF_STATIC_INLINE void nrf_qdec_task_trigger(NRF_QDEC_Type * p_reg, nrf_qdec_task_t task)
167  {
168      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)task) ) = 1;
</span>169  }
170  NRF_STATIC_INLINE uint32_t nrf_qdec_task_address_get(NRF_QDEC_Type const * p_reg,
171                                                       nrf_qdec_task_t       task)
172  {
173      return (uint32_t)( (uint8_t *)p_reg + (uint32_t)task);
174  }
175  NRF_STATIC_INLINE void nrf_qdec_event_clear(NRF_QDEC_Type * p_reg, nrf_qdec_event_t event)
176  {
177      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event) ) = 0;
178  #if __CORTEX_M == 0x04
179      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + event));
180      (void)dummy;
181  #endif
182  }
183  NRF_STATIC_INLINE bool nrf_qdec_event_check(NRF_QDEC_Type const * p_reg, nrf_qdec_event_t event)
184  {
185      return (bool)*(volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event);
186  }
187  NRF_STATIC_INLINE uint32_t nrf_qdec_event_address_get(NRF_QDEC_Type const * p_reg,
188                                                        nrf_qdec_event_t      event)
189  {
190      return (uint32_t)( (uint8_t *)p_reg + (uint32_t)event);
191  }
192  NRF_STATIC_INLINE void nrf_qdec_shorts_enable(NRF_QDEC_Type * p_reg, uint32_t mask)
193  {
194      p_reg->SHORTS |= mask;
195  }
196  NRF_STATIC_INLINE void nrf_qdec_shorts_disable(NRF_QDEC_Type * p_reg, uint32_t mask)
197  {
198      p_reg->SHORTS &= ~mask;
199  }
200  NRF_STATIC_INLINE uint32_t nrf_qdec_sampleper_to_value(nrf_qdec_sampleper_t sampleper)
201  {
202      return (1 << (7 + sampleper));
203  }
204  NRF_STATIC_INLINE void nrf_qdec_sampleper_set(NRF_QDEC_Type *      p_reg,
205                                                nrf_qdec_sampleper_t sampleper)
206  {
207      p_reg->SAMPLEPER = sampleper;
208  }
209  NRF_STATIC_INLINE nrf_qdec_sampleper_t nrf_qdec_sampleper_get(NRF_QDEC_Type const * p_reg)
210  {
211      return (nrf_qdec_sampleper_t)(p_reg->SAMPLEPER);
212  }
213  NRF_STATIC_INLINE int32_t nrf_qdec_sample_get(NRF_QDEC_Type const * p_reg)
214  {
215      return p_reg->SAMPLE;
216  }
217  NRF_STATIC_INLINE int32_t nrf_qdec_acc_get(NRF_QDEC_Type const * p_reg)
218  {
219      return p_reg->ACC;
220  }
221  NRF_STATIC_INLINE int32_t nrf_qdec_accread_get(NRF_QDEC_Type const * p_reg)
222  {
223      return p_reg->ACCREAD;
224  }
225  NRF_STATIC_INLINE uint32_t nrf_qdec_accdbl_get(NRF_QDEC_Type const * p_reg)
226  {
227      return p_reg->ACCDBL;
228  }
229  NRF_STATIC_INLINE uint32_t nrf_qdec_accdblread_get(NRF_QDEC_Type const * p_reg)
230  {
231      return p_reg->ACCDBLREAD;
232  }
233  NRF_STATIC_INLINE void nrf_qdec_ledpre_set(NRF_QDEC_Type * p_reg, uint32_t time_us)
234  {
235      p_reg->LEDPRE = time_us;
236  }
237  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpre_get(NRF_QDEC_Type const * p_reg)
238  {
239      return p_reg->LEDPRE;
240  }
241  NRF_STATIC_INLINE void nrf_qdec_reportper_set(NRF_QDEC_Type *      p_reg,
242                                                nrf_qdec_reportper_t reportper)
243  {
244      p_reg->REPORTPER = reportper;
245  }
246  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_get(NRF_QDEC_Type const * p_reg)
247  {
248      return p_reg->REPORTPER;
249  }
250  NRF_STATIC_INLINE uint32_t nrf_qdec_reportper_to_value(uint32_t reportper)
251  {
252      return (reportper == NRF_QDEC_REPORTPER_10) ? 10 : reportper * 40;
253  }
254  NRF_STATIC_INLINE void nrf_qdec_ledpol_set(NRF_QDEC_Type * p_reg, nrf_qdec_ledpol_t pol)
255  {
256      p_reg->LEDPOL = pol;
257  }
258  NRF_STATIC_INLINE uint32_t nrf_qdec_ledpol_get(NRF_QDEC_Type const * p_reg)
259  {
260      return p_reg->LEDPOL;
261  }
262  #endif 
263  #ifdef __cplusplus
264  }
265  #endif
266  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spi.h</h3>
            <pre><code>1  #ifndef NRF_SPI_H__
2  #define NRF_SPI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_SPI_PIN_NOT_CONNECTED  0xFFFFFFFF
8  typedef enum
9  {
10      NRF_SPI_EVENT_READY = offsetof(NRF_SPI_Type, EVENTS_READY) 
11  } nrf_spi_event_t;
12  typedef enum
13  {
14      NRF_SPI_INT_READY_MASK = SPI_INTENSET_READY_Msk, 
15      NRF_SPI_ALL_INTS_MASK  = SPI_INTENSET_READY_Msk  
16  } nrf_spi_int_mask_t;
17  typedef enum
18  {
19      NRF_SPI_FREQ_125K = SPI_FREQUENCY_FREQUENCY_K125,   
20      NRF_SPI_FREQ_250K = SPI_FREQUENCY_FREQUENCY_K250,   
21      NRF_SPI_FREQ_500K = SPI_FREQUENCY_FREQUENCY_K500,   
22      NRF_SPI_FREQ_1M   = SPI_FREQUENCY_FREQUENCY_M1,     
23      NRF_SPI_FREQ_2M   = SPI_FREQUENCY_FREQUENCY_M2,     
24      NRF_SPI_FREQ_4M   = SPI_FREQUENCY_FREQUENCY_M4,     
25      NRF_SPI_FREQ_8M   = (int)SPI_FREQUENCY_FREQUENCY_M8 
26  } nrf_spi_frequency_t;
27  typedef enum
28  {
29      NRF_SPI_MODE_0, 
30      NRF_SPI_MODE_1, 
31      NRF_SPI_MODE_2, 
32      NRF_SPI_MODE_3  
33  } nrf_spi_mode_t;
34  typedef enum
35  {
36      NRF_SPI_BIT_ORDER_MSB_FIRST = SPI_CONFIG_ORDER_MsbFirst, 
37      NRF_SPI_BIT_ORDER_LSB_FIRST = SPI_CONFIG_ORDER_LsbFirst  
38  } nrf_spi_bit_order_t;
39  NRF_STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type *  p_reg,
40                                             nrf_spi_event_t event);
41  NRF_STATIC_INLINE bool nrf_spi_event_check(NRF_SPI_Type const * p_reg,
42                                             nrf_spi_event_t      event);
43  NRF_STATIC_INLINE uint32_t nrf_spi_event_address_get(NRF_SPI_Type const * p_reg,
44                                                       nrf_spi_event_t      event);
45  NRF_STATIC_INLINE void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
46                                            uint32_t       mask);
47  NRF_STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
48                                             uint32_t       mask);
49  NRF_STATIC_INLINE uint32_t nrf_spi_int_enable_check(NRF_SPI_Type const * p_reg, uint32_t mask);
50  NRF_STATIC_INLINE void nrf_spi_enable(NRF_SPI_Type * p_reg);
51  NRF_STATIC_INLINE void nrf_spi_disable(NRF_SPI_Type * p_reg);
52  NRF_STATIC_INLINE void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
53                                          uint32_t       sck_pin,
54                                          uint32_t       mosi_pin,
55                                          uint32_t       miso_pin);
56  NRF_STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data);
57  NRF_STATIC_INLINE uint8_t nrf_spi_rxd_get(NRF_SPI_Type const * p_reg);
58  NRF_STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type *      p_reg,
59                                               nrf_spi_frequency_t frequency);
60  NRF_STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type *      p_reg,
61                                           nrf_spi_mode_t      spi_mode,
62                                           nrf_spi_bit_order_t spi_bit_order);
63  #ifndef NRF_DECLARE_ONLY
64  NRF_STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type *  p_reg,
65                                             nrf_spi_event_t event)
66  {
67      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
68  #if __CORTEX_M == 0x04
69      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
70      (void)dummy;
71  #endif
72  }
73  NRF_STATIC_INLINE bool nrf_spi_event_check(NRF_SPI_Type const * p_reg,
74                                             nrf_spi_event_t      event)
75  {
76      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
77  }
78  NRF_STATIC_INLINE uint32_t nrf_spi_event_address_get(NRF_SPI_Type const * p_reg,
79                                                       nrf_spi_event_t      event)
80  {
81      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
82  }
83  NRF_STATIC_INLINE void nrf_spi_int_enable(NRF_SPI_Type * p_reg,
84                                            uint32_t       mask)
85  {
86      p_reg->INTENSET = mask;
87  }
88  NRF_STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
89                                             uint32_t       mask)
90  {
91      p_reg->INTENCLR = mask;
92  }
93  NRF_STATIC_INLINE uint32_t nrf_spi_int_enable_check(NRF_SPI_Type const * p_reg, uint32_t mask)
94  {
95      return p_reg->INTENSET & mask;
96  }
97  NRF_STATIC_INLINE void nrf_spi_enable(NRF_SPI_Type * p_reg)
98  {
99      p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
100  }
101  NRF_STATIC_INLINE void nrf_spi_disable(NRF_SPI_Type * p_reg)
102  {
103      p_reg->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
104  }
105  NRF_STATIC_INLINE void nrf_spi_pins_set(NRF_SPI_Type * p_reg,
106                                          uint32_t       sck_pin,
107                                          uint32_t       mosi_pin,
108                                          uint32_t       miso_pin)
109  {
110  #if defined(SPI_PSEL_SCK_CONNECT_Pos)
111      p_reg->PSEL.SCK = sck_pin;
112  #else
113      p_reg->PSELSCK  = sck_pin;
114  #endif
115  #if defined(SPI_PSEL_MOSI_CONNECT_Pos)
116      p_reg->PSEL.MOSI = mosi_pin;
117  #else
118      p_reg->PSELMOSI = mosi_pin;
119  #endif
120  #if defined(SPI_PSEL_MISO_CONNECT_Pos)
121      p_reg->PSEL.MISO = miso_pin;
122  #else
<span onclick='openModal()' class='match'>123      p_reg->PSELMISO = miso_pin;
124  #endif
125  }
126  NRF_STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
127  {
128      p_reg->TXD = data;
</span>129  }
130  NRF_STATIC_INLINE uint8_t nrf_spi_rxd_get(NRF_SPI_Type const * p_reg)
131  {
132      return p_reg->RXD;
133  }
134  NRF_STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type *      p_reg,
135                                               nrf_spi_frequency_t frequency)
136  {
137      p_reg->FREQUENCY = (uint32_t)frequency;
138  }
139  NRF_STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type *      p_reg,
140                                           nrf_spi_mode_t      spi_mode,
141                                           nrf_spi_bit_order_t spi_bit_order)
142  {
143      uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
144          SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
145      switch (spi_mode)
146      {
147      default:
148      case NRF_SPI_MODE_0:
149          config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
150                    (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
151          break;
152      case NRF_SPI_MODE_1:
153          config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
154                    (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
155          break;
156      case NRF_SPI_MODE_2:
157          config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
158                    (SPI_CONFIG_CPHA_Leading    << SPI_CONFIG_CPHA_Pos);
159          break;
160      case NRF_SPI_MODE_3:
161          config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
162                    (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
163          break;
164      }
165      p_reg->CONFIG = config;
166  }
167  #endif 
168  #ifdef __cplusplus
169  }
170  #endif
171  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qdec.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_spi.h</div>
                </div>
                <div class="column column_space"><pre><code>163      p_reg->PSELLED = pselled;
164  #endif
165  }
166  NRF_STATIC_INLINE void nrf_qdec_task_trigger(NRF_QDEC_Type * p_reg, nrf_qdec_task_t task)
167  {
168      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)task) ) = 1;
</pre></code></div>
                <div class="column column_space"><pre><code>123      p_reg->PSELMISO = miso_pin;
124  #endif
125  }
126  NRF_STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
127  {
128      p_reg->TXD = data;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    