
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.929577464788732%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.h</h3>
            <pre><code>1  #ifndef LFS_H
2  #define LFS_H
3  #include <stdint.h>
4  #include <stdbool.h>
5  #ifdef __cplusplus
6  extern "C"
7  {
8  #endif
9  #define LFS_VERSION 0x00010006
10  #define LFS_VERSION_MAJOR (0xffff & (LFS_VERSION >> 16))
11  #define LFS_VERSION_MINOR (0xffff & (LFS_VERSION >>  0))
12  #define LFS_DISK_VERSION 0x00010001
13  #define LFS_DISK_VERSION_MAJOR (0xffff & (LFS_DISK_VERSION >> 16))
14  #define LFS_DISK_VERSION_MINOR (0xffff & (LFS_DISK_VERSION >>  0))
15  typedef uint32_t lfs_size_t;
16  typedef uint32_t lfs_off_t;
17  typedef int32_t  lfs_ssize_t;
18  typedef int32_t  lfs_soff_t;
19  typedef uint32_t lfs_block_t;
20  #ifndef LFS_NAME_MAX
21  #define LFS_NAME_MAX 255
22  #endif
23  enum lfs_error {
24      LFS_ERR_OK       = 0,    
25      LFS_ERR_IO       = -5,   
26      LFS_ERR_CORRUPT  = -52,  
27      LFS_ERR_NOENT    = -2,   
28      LFS_ERR_EXIST    = -17,  
29      LFS_ERR_NOTDIR   = -20,  
30      LFS_ERR_ISDIR    = -21,  
31      LFS_ERR_NOTEMPTY = -39,  
32      LFS_ERR_BADF     = -9,   
33      LFS_ERR_INVAL    = -22,  
34      LFS_ERR_NOSPC    = -28,  
35      LFS_ERR_NOMEM    = -12,  
36  };
37  enum lfs_type {
38      LFS_TYPE_REG        = 0x11,
39      LFS_TYPE_DIR        = 0x22,
40      LFS_TYPE_SUPERBLOCK = 0x2e,
41  };
<span onclick='openModal()' class='match'>42  enum lfs_open_flags {
43      LFS_O_RDONLY = 1,        
44      LFS_O_WRONLY = 2,        
45      LFS_O_RDWR   = 3,        
46      LFS_O_CREAT  = 0x0100,   
47      LFS_O_EXCL   = 0x0200,   
48      LFS_O_TRUNC  = 0x0400,   
49      LFS_O_APPEND = 0x0800,   
50      LFS_F_DIRTY   = 0x10000, 
51      LFS_F_WRITING = 0x20000, 
52      LFS_F_READING = 0x40000, 
53      LFS_F_ERRED   = 0x80000, 
54  };
</span>55  enum lfs_whence_flags {
56      LFS_SEEK_SET = 0,   
57      LFS_SEEK_CUR = 1,   
58      LFS_SEEK_END = 2,   
59  };
60  struct lfs_config {
61      void *context;
62      int (*read)(const struct lfs_config *c, lfs_block_t block,
63              lfs_off_t off, void *buffer, lfs_size_t size);
64      int (*prog)(const struct lfs_config *c, lfs_block_t block,
65              lfs_off_t off, const void *buffer, lfs_size_t size);
66      int (*erase)(const struct lfs_config *c, lfs_block_t block);
67      int (*sync)(const struct lfs_config *c);
68      lfs_size_t read_size;
69      lfs_size_t prog_size;
70      lfs_size_t block_size;
71      lfs_size_t block_count;
72      lfs_size_t lookahead;
73      void *read_buffer;
74      void *prog_buffer;
75      void *lookahead_buffer;
76      void *file_buffer;
77  };
78  struct lfs_file_config {
79      void *buffer;
80  };
81  struct lfs_info {
82      uint8_t type;
83      lfs_size_t size;
84      char name[LFS_NAME_MAX+1];
85  };
86  typedef struct lfs_entry {
87      lfs_off_t off;
88      struct lfs_disk_entry {
89          uint8_t type;
90          uint8_t elen;
91          uint8_t alen;
92          uint8_t nlen;
93          union {
94              struct {
95                  lfs_block_t head;
96                  lfs_size_t size;
97              } file;
98              lfs_block_t dir[2];
99          } u;
100      } d;
101  } lfs_entry_t;
102  typedef struct lfs_cache {
103      lfs_block_t block;
104      lfs_off_t off;
105      uint8_t *buffer;
106  } lfs_cache_t;
107  typedef struct lfs_file {
108      struct lfs_file *next;
109      lfs_block_t pair[2];
110      lfs_off_t poff;
111      lfs_block_t head;
112      lfs_size_t size;
113      const struct lfs_file_config *cfg;
114      uint32_t flags;
115      lfs_off_t pos;
116      lfs_block_t block;
117      lfs_off_t off;
118      lfs_cache_t cache;
119  } lfs_file_t;
120  typedef struct lfs_dir {
121      struct lfs_dir *next;
122      lfs_block_t pair[2];
123      lfs_off_t off;
124      lfs_block_t head[2];
125      lfs_off_t pos;
126      struct lfs_disk_dir {
127          uint32_t rev;
128          lfs_size_t size;
129          lfs_block_t tail[2];
130      } d;
131  } lfs_dir_t;
132  typedef struct lfs_superblock {
133      lfs_off_t off;
134      struct lfs_disk_superblock {
135          uint8_t type;
136          uint8_t elen;
137          uint8_t alen;
138          uint8_t nlen;
139          lfs_block_t root[2];
140          uint32_t block_size;
141          uint32_t block_count;
142          uint32_t version;
143          char magic[8];
144      } d;
145  } lfs_superblock_t;
146  typedef struct lfs_free {
147      lfs_block_t off;
148      lfs_block_t size;
149      lfs_block_t i;
150      lfs_block_t ack;
151      uint32_t *buffer;
152  } lfs_free_t;
153  typedef struct lfs {
154      const struct lfs_config *cfg;
155      lfs_block_t root[2];
156      lfs_file_t *files;
157      lfs_dir_t *dirs;
158      lfs_cache_t rcache;
159      lfs_cache_t pcache;
160      lfs_free_t free;
161      bool deorphaned;
162  } lfs_t;
163  int lfs_format(lfs_t *lfs, const struct lfs_config *config);
164  int lfs_mount(lfs_t *lfs, const struct lfs_config *config);
165  int lfs_unmount(lfs_t *lfs);
166  int lfs_remove(lfs_t *lfs, const char *path);
167  int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath);
168  int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info);
169  int lfs_file_open(lfs_t *lfs, lfs_file_t *file,
170          const char *path, int flags);
171  int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
172          const char *path, int flags,
173          const struct lfs_file_config *config);
174  int lfs_file_close(lfs_t *lfs, lfs_file_t *file);
175  int lfs_file_sync(lfs_t *lfs, lfs_file_t *file);
176  lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
177          void *buffer, lfs_size_t size);
178  lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
179          const void *buffer, lfs_size_t size);
180  lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
181          lfs_soff_t off, int whence);
182  int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size);
183  lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file);
184  int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file);
185  lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file);
186  int lfs_mkdir(lfs_t *lfs, const char *path);
187  int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path);
188  int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir);
189  int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info);
190  int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off);
191  lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir);
192  int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir);
193  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data);
194  int lfs_deorphan(lfs_t *lfs);
195  #ifdef __cplusplus
196  } &bsol;* extern "C" */
197  #endif
198  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-listpack.c</h3>
            <pre><code>1  #include <stdint.h>
2  #include <limits.h>
3  #include <sys/types.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <stdio.h>
7  #include "listpack.h"
8  #include "listpack_malloc.h"
9  #define LP_HDR_SIZE 6       &bsol;* 32 bit total len + 16 bit number of elements. */
10  #define LP_HDR_NUMELE_UNKNOWN UINT16_MAX
11  #define LP_MAX_INT_ENCODING_LEN 9
12  #define LP_MAX_BACKLEN_SIZE 5
13  #define LP_MAX_ENTRY_BACKLEN 34359738367ULL
14  #define LP_ENCODING_INT 0
15  #define LP_ENCODING_STRING 1
16  #define LP_ENCODING_7BIT_UINT 0
17  #define LP_ENCODING_7BIT_UINT_MASK 0x80
18  #define LP_ENCODING_IS_7BIT_UINT(byte) (((byte)&LP_ENCODING_7BIT_UINT_MASK)==LP_ENCODING_7BIT_UINT)
19  #define LP_ENCODING_6BIT_STR 0x80
20  #define LP_ENCODING_6BIT_STR_MASK 0xC0
21  #define LP_ENCODING_IS_6BIT_STR(byte) (((byte)&LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR)
22  #define LP_ENCODING_13BIT_INT 0xC0
23  #define LP_ENCODING_13BIT_INT_MASK 0xE0
24  #define LP_ENCODING_IS_13BIT_INT(byte) (((byte)&LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT)
25  #define LP_ENCODING_12BIT_STR 0xE0
26  #define LP_ENCODING_12BIT_STR_MASK 0xF0
27  #define LP_ENCODING_IS_12BIT_STR(byte) (((byte)&LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR)
28  #define LP_ENCODING_16BIT_INT 0xF1
29  #define LP_ENCODING_16BIT_INT_MASK 0xFF
30  #define LP_ENCODING_IS_16BIT_INT(byte) (((byte)&LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT)
31  #define LP_ENCODING_24BIT_INT 0xF2
32  #define LP_ENCODING_24BIT_INT_MASK 0xFF
33  #define LP_ENCODING_IS_24BIT_INT(byte) (((byte)&LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT)
34  #define LP_ENCODING_32BIT_INT 0xF3
35  #define LP_ENCODING_32BIT_INT_MASK 0xFF
36  #define LP_ENCODING_IS_32BIT_INT(byte) (((byte)&LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT)
37  #define LP_ENCODING_64BIT_INT 0xF4
38  #define LP_ENCODING_64BIT_INT_MASK 0xFF
39  #define LP_ENCODING_IS_64BIT_INT(byte) (((byte)&LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT)
40  #define LP_ENCODING_32BIT_STR 0xF0
41  #define LP_ENCODING_32BIT_STR_MASK 0xFF
42  #define LP_ENCODING_IS_32BIT_STR(byte) (((byte)&LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR)
43  #define LP_EOF 0xFF
44  #define LP_ENCODING_6BIT_STR_LEN(p) ((p)[0] & 0x3F)
45  #define LP_ENCODING_12BIT_STR_LEN(p) ((((p)[0] & 0xF) << 8) | (p)[1])
46  #define LP_ENCODING_32BIT_STR_LEN(p) (((uint32_t)(p)[1]<<0) | \
47                                        ((uint32_t)(p)[2]<<8) | \
48                                        ((uint32_t)(p)[3]<<16) | \
49                                        ((uint32_t)(p)[4]<<24))
50  #define lpGetTotalBytes(p)           (((uint32_t)(p)[0]<<0) | \
51                                        ((uint32_t)(p)[1]<<8) | \
52                                        ((uint32_t)(p)[2]<<16) | \
53                                        ((uint32_t)(p)[3]<<24))
54  #define lpGetNumElements(p)          (((uint32_t)(p)[4]<<0) | \
55                                        ((uint32_t)(p)[5]<<8))
56  #define lpSetTotalBytes(p,v) do { \
57      (p)[0] = (v)&0xff; \
58      (p)[1] = ((v)>>8)&0xff; \
59      (p)[2] = ((v)>>16)&0xff; \
60      (p)[3] = ((v)>>24)&0xff; \
61  } while(0)
62  #define lpSetNumElements(p,v) do { \
63      (p)[4] = (v)&0xff; \
64      (p)[5] = ((v)>>8)&0xff; \
65  } while(0)
66  int lpStringToInt64(const char *s, PORT_ULONG slen, int64_t *value) {
67      const char *p = s;
68      PORT_ULONG plen = 0;
69      int negative = 0;
70      uint64_t v;
71      if (plen == slen)
72          return 0;
73      if (slen == 1 && p[0] == '0') {
74          if (value != NULL) *value = 0;
75          return 1;
76      }
77      if (p[0] == '-') {
78          negative = 1;
79          p++; plen++;
80          if (plen == slen)
81              return 0;
82      }
83      if (p[0] >= '1' && p[0] <= '9') {
84          v = p[0]-'0';
85          p++; plen++;
86      } else if (p[0] == '0' && slen == 1) {
87          *value = 0;
88          return 1;
89      } else {
90          return 0;
91      }
92      while (plen < slen && p[0] >= '0' && p[0] <= '9') {
93          if (v > (UINT64_MAX / 10)) &bsol;* Overflow. */
94              return 0;
95          v *= 10;
96          if (v > (UINT64_MAX - (p[0]-'0'))) &bsol;* Overflow. */
97              return 0;
98          v += p[0]-'0';
99          p++; plen++;
100      }
101      if (plen < slen)
102          return 0;
103      if (negative) {
104          if (v > ((uint64_t)(-(INT64_MIN+1))+1)) &bsol;* Overflow. */
105              return 0;
106          if (value != NULL) *value = -v;
107      } else {
108          if (v > INT64_MAX) &bsol;* Overflow. */
109              return 0;
110          if (value != NULL) *value = v;
111      }
112      return 1;
113  }
114  unsigned char *lpNew(void) {
115      unsigned char *lp = lp_malloc(LP_HDR_SIZE+1);
116      if (lp == NULL) return NULL;
117      lpSetTotalBytes(lp,LP_HDR_SIZE+1);
118      lpSetNumElements(lp,0);
119      lp[LP_HDR_SIZE] = LP_EOF;
120      return lp;
121  }
122  void lpFree(unsigned char *lp) {
123      lp_free(lp);
124  }
125  int lpEncodeGetType(unsigned char *ele, uint32_t size, unsigned char *intenc, uint64_t *enclen) {
126      int64_t v;
127      if (lpStringToInt64((const char*)ele, size, &v)) {
128          if (v >= 0 && v <= 127) {
129              intenc[0] = v;
130              *enclen = 1;
131          } else if (v >= -4096 && v <= 4095) {
132              if (v < 0) v = ((int64_t)1<<13)+v;
133              intenc[0] = (v>>8)|LP_ENCODING_13BIT_INT;
134              intenc[1] = v&0xff;
135              *enclen = 2;
136          } else if (v >= -32768 && v <= 32767) {
137              if (v < 0) v = ((int64_t)1<<16)+v;
138              intenc[0] = LP_ENCODING_16BIT_INT;
139              intenc[1] = v&0xff;
140              intenc[2] = v>>8;
141              *enclen = 3;
142          } else if (v >= -8388608 && v <= 8388607) {
143              if (v < 0) v = ((int64_t)1<<24)+v;
144              intenc[0] = LP_ENCODING_24BIT_INT;
145              intenc[1] = v&0xff;
146              intenc[2] = (v>>8)&0xff;
147              intenc[3] = v>>16;
148              *enclen = 4;
149          } else if (v >= -2147483648 && v <= 2147483647) {
150              if (v < 0) v = ((int64_t)1<<32)+v;
151              intenc[0] = LP_ENCODING_32BIT_INT;
152              intenc[1] = v&0xff;
153              intenc[2] = (v>>8)&0xff;
154              intenc[3] = (v>>16)&0xff;
155              intenc[4] = v>>24;
156              *enclen = 5;
<span onclick='openModal()' class='match'>157          } else {
158              uint64_t uv = v;
159              intenc[0] = LP_ENCODING_64BIT_INT;
160              intenc[1] = uv&0xff;
161              intenc[2] = (uv>>8)&0xff;
162              intenc[3] = (uv>>16)&0xff;
163              intenc[4] = (uv>>24)&0xff;
164              intenc[5] = (uv>>32)&0xff;
165              intenc[6] = (uv>>40)&0xff;
166              intenc[7] = (uv>>48)&0xff;
167              intenc[8] = uv>>56;
168              *enclen = 9;
169          }
</span>170          return LP_ENCODING_INT;
171      } else {
172          if (size < 64) *enclen = 1+size;
173          else if (size < 4096) *enclen = 2+size;
174          else *enclen = 5+size;
175          return LP_ENCODING_STRING;
176      }
177  }
178  PORT_ULONG lpEncodeBacklen(unsigned char *buf, uint64_t l) {
179      if (l <= 127) {
180          if (buf) buf[0] = l;
181          return 1;
182      } else if (l < 16383) {
183          if (buf) {
184              buf[0] = l>>7;
185              buf[1] = (l&127)|128;
186          }
187          return 2;
188      } else if (l < 2097151) {
189          if (buf) {
190              buf[0] = l>>14;
191              buf[1] = ((l>>7)&127)|128;
192              buf[2] = (l&127)|128;
193          }
194          return 3;
195      } else if (l < 268435455) {
196          if (buf) {
197              buf[0] = l>>21;
198              buf[1] = ((l>>14)&127)|128;
199              buf[2] = ((l>>7)&127)|128;
200              buf[3] = (l&127)|128;
201          }
202          return 4;
203      } else {
204          if (buf) {
205              buf[0] = l>>28;
206              buf[1] = ((l>>21)&127)|128;
207              buf[2] = ((l>>14)&127)|128;
208              buf[3] = ((l>>7)&127)|128;
209              buf[4] = (l&127)|128;
210          }
211          return 5;
212      }
213  }
214  uint64_t lpDecodeBacklen(unsigned char *p) {
215      uint64_t val = 0;
216      uint64_t shift = 0;
217      do {
218          val |= (uint64_t)(p[0] & 127) << shift;
219          if (!(p[0] & 128)) break;
220          shift += 7;
221          p--;
222          if (shift > 28) return UINT64_MAX;
223      } while(1);
224      return val;
225  }
226  void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
227      if (len < 64) {
228          buf[0] = len | LP_ENCODING_6BIT_STR;
229          memcpy(buf+1,s,len);
230      } else if (len < 4096) {
231          buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
232          buf[1] = len & 0xff;
233          memcpy(buf+2,s,len);
234      } else {
235          buf[0] = LP_ENCODING_32BIT_STR;
236          buf[1] = len & 0xff;
237          buf[2] = (len >> 8) & 0xff;
238          buf[3] = (len >> 16) & 0xff;
239          buf[4] = (len >> 24) & 0xff;
240          memcpy(buf+5,s,len);
241      }
242  }
243  uint32_t lpCurrentEncodedSize(unsigned char *p) {
244      if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
245      if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
246      if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
247      if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
248      if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
249      if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
250      if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
251      if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
252      if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
253      if (p[0] == LP_EOF) return 1;
254      return 0;
255  }
256  unsigned char *lpSkip(unsigned char *p) {
257      PORT_ULONG entrylen = lpCurrentEncodedSize(p);
258      entrylen += lpEncodeBacklen(NULL,entrylen);
259      p += entrylen;
260      return p;
261  }
262  unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
263      ((void) lp); &bsol;* lp is not used for now. However lpPrev() uses it. */
264      p = lpSkip(p);
265      if (p[0] == LP_EOF) return NULL;
266      return p;
267  }
268  unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
269      if (p-lp == LP_HDR_SIZE) return NULL;
270      p--; &bsol;* Seek the first backlen byte of the last element. */
271      uint64_t prevlen = lpDecodeBacklen(p);
272      prevlen += lpEncodeBacklen(NULL,prevlen);
273      return p-prevlen+1; &bsol;* Seek the first byte of the previous entry. */
274  }
275  unsigned char *lpFirst(unsigned char *lp) {
276      lp += LP_HDR_SIZE; &bsol;* Skip the header. */
277      if (lp[0] == LP_EOF) return NULL;
278      return lp;
279  }
280  unsigned char *lpLast(unsigned char *lp) {
281      unsigned char *p = lp+lpGetTotalBytes(lp)-1; &bsol;* Seek EOF element. */
282      return lpPrev(lp,p); &bsol;* Will return NULL if EOF is the only element. */
283  }
284  uint32_t lpLength(unsigned char *lp) {
285      uint32_t numele = lpGetNumElements(lp);
286      if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;
287      uint32_t count = 0;
288      unsigned char *p = lpFirst(lp);
289      while(p) {
290          count++;
291          p = lpNext(lp,p);
292      }
293      if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
294      return count;
295  }
296  unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
297      int64_t val;
298      uint64_t uval, negstart, negmax;
299      if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
300          negstart = UINT64_MAX; &bsol;* 7 bit ints are always positive. */
301          negmax = 0;
302          uval = p[0] & 0x7f;
303      } else if (LP_ENCODING_IS_6BIT_STR(p[0])) {
304          *count = LP_ENCODING_6BIT_STR_LEN(p);
305          return p+1;
306      } else if (LP_ENCODING_IS_13BIT_INT(p[0])) {
307          uval = ((p[0]&0x1f)<<8) | p[1];
308          negstart = (uint64_t)1<<12;
309          negmax = 8191;
310      } else if (LP_ENCODING_IS_16BIT_INT(p[0])) {
311          uval = (uint64_t)p[1] |
312                 (uint64_t)p[2]<<8;
313          negstart = (uint64_t)1<<15;
314          negmax = UINT16_MAX;
315      } else if (LP_ENCODING_IS_24BIT_INT(p[0])) {
316          uval = (uint64_t)p[1] |
317                 (uint64_t)p[2]<<8 |
318                 (uint64_t)p[3]<<16;
319          negstart = (uint64_t)1<<23;
320          negmax = UINT32_MAX>>8;
321      } else if (LP_ENCODING_IS_32BIT_INT(p[0])) {
322          uval = (uint64_t)p[1] |
323                 (uint64_t)p[2]<<8 |
324                 (uint64_t)p[3]<<16 |
325                 (uint64_t)p[4]<<24;
326          negstart = (uint64_t)1<<31;
327          negmax = UINT32_MAX;
328      } else if (LP_ENCODING_IS_64BIT_INT(p[0])) {
329          uval = (uint64_t)p[1] |
330                 (uint64_t)p[2]<<8 |
331                 (uint64_t)p[3]<<16 |
332                 (uint64_t)p[4]<<24 |
333                 (uint64_t)p[5]<<32 |
334                 (uint64_t)p[6]<<40 |
335                 (uint64_t)p[7]<<48 |
336                 (uint64_t)p[8]<<56;
337          negstart = (uint64_t)1<<63;
338          negmax = UINT64_MAX;
339      } else if (LP_ENCODING_IS_12BIT_STR(p[0])) {
340          *count = LP_ENCODING_12BIT_STR_LEN(p);
341          return p+2;
342      } else if (LP_ENCODING_IS_32BIT_STR(p[0])) {
343          *count = LP_ENCODING_32BIT_STR_LEN(p);
344          return p+5;
345      } else {
346          uval = 12345678900000000ULL + p[0];
347          negstart = UINT64_MAX;
348          negmax = 0;
349      }
350      if (uval >= negstart) {
351          uval = negmax-uval;
352          val = uval;
353          val = -val-1;
354      } else {
355          val = uval;
356      }
357      if (intbuf) {
358          *count = snprintf((char*)intbuf,LP_INTBUF_SIZE,"%lld",(PORT_LONGLONG)val);
359          return intbuf;
360      } else {
361          *count = val;
362          return NULL;
363      }
364  }
365  unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, unsigned char *p, int where, unsigned char **newp) {
366      unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
367      unsigned char backlen[LP_MAX_BACKLEN_SIZE];
368      uint64_t enclen; &bsol;* The length of the encoded element. */
369      if (ele == NULL) where = LP_REPLACE;
370      if (where == LP_AFTER) {
371          p = lpSkip(p);
372          where = LP_BEFORE;
373      }
374      PORT_ULONG poff = p-lp;
375      int enctype;
376      if (ele) {
377          enctype = lpEncodeGetType(ele,size,intenc,&enclen);
378      } else {
379          enctype = -1;
380          enclen = 0;
381      }
382      PORT_ULONG backlen_size = ele ? lpEncodeBacklen(backlen,enclen) : 0;
383      uint64_t old_listpack_bytes = lpGetTotalBytes(lp);
384      uint32_t replaced_len  = 0;
385      if (where == LP_REPLACE) {
386          replaced_len = lpCurrentEncodedSize(p);
387          replaced_len += lpEncodeBacklen(NULL,replaced_len);
388      }
389      uint64_t new_listpack_bytes = old_listpack_bytes + enclen + backlen_size
390                                    - replaced_len;
391      if (new_listpack_bytes > UINT32_MAX) return NULL;
392      unsigned char *dst = lp + poff; &bsol;* May be updated after reallocation. */
393      if (new_listpack_bytes > old_listpack_bytes) {
394          if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
395          dst = lp + poff;
396      }
397      if (where == LP_BEFORE) {
398          memmove(dst+enclen+backlen_size,dst,old_listpack_bytes-poff);
399      } else { &bsol;* LP_REPLACE. */
400          PORT_LONG lendiff = (enclen+backlen_size)-replaced_len;
401          memmove(dst+replaced_len+lendiff,
402                  dst+replaced_len,
403                  old_listpack_bytes-poff-replaced_len);
404      }
405      if (new_listpack_bytes < old_listpack_bytes) {
406          if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
407          dst = lp + poff;
408      }
409      if (newp) {
410          *newp = dst;
411          if (!ele && dst[0] == LP_EOF) *newp = NULL;
412      }
413      if (ele) {
414          if (enctype == LP_ENCODING_INT) {
415              memcpy(dst,intenc,enclen);
416          } else {
417              lpEncodeString(dst,ele,size);
418          }
419          dst += enclen;
420          memcpy(dst,backlen,backlen_size);
421          dst += backlen_size;
422      }
423      if (where != LP_REPLACE || ele == NULL) {
424          uint32_t num_elements = lpGetNumElements(lp);
425          if (num_elements != LP_HDR_NUMELE_UNKNOWN) {
426              if (ele)
427                  lpSetNumElements(lp,num_elements+1);
428              else
429                  lpSetNumElements(lp,num_elements-1);
430          }
431      }
432      lpSetTotalBytes(lp,new_listpack_bytes);
433  #if 0
434      unsigned char *oldlp = lp;
435      lp = lp_malloc(new_listpack_bytes);
436      memcpy(lp,oldlp,new_listpack_bytes);
437      if (newp) {
438          unsigned long offset = (*newp)-oldlp;
439          *newp = lp + offset;
440      }
441      memset(oldlp,'A',new_listpack_bytes);
442      lp_free(oldlp);
443  #endif
444      return lp;
445  }
446  unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
447      uint64_t listpack_bytes = lpGetTotalBytes(lp);
448      unsigned char *eofptr = lp + listpack_bytes - 1;
449      return lpInsert(lp,ele,size,eofptr,LP_BEFORE,NULL);
450  }
451  unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
452      return lpInsert(lp,NULL,0,p,LP_REPLACE,newp);
453  }
454  uint32_t lpBytes(unsigned char *lp) {
455      return lpGetTotalBytes(lp);
456  }
457  unsigned char *lpSeek(unsigned char *lp, PORT_LONG index) {
458      int forward = 1; &bsol;* Seek forward by default. */
459      uint32_t numele = lpGetNumElements(lp);
460      if (numele != LP_HDR_NUMELE_UNKNOWN) {
461          if (index < 0) index = (PORT_LONG)numele+index;
462          if (index < 0) return NULL; &bsol;* Index still < 0 means out of range. */
463          if (index >= numele) return NULL; &bsol;* Out of range the other side. */
464          if (index > numele/2) {
465              forward = 0;
466              index -= numele;
467          }
468      } else {
469          if (index < 0) forward = 0;
470      }
471      if (forward) {
472          unsigned char *ele = lpFirst(lp);
473          while (index > 0 && ele) {
474              ele = lpNext(lp,ele);
475              index--;
476          }
477          return ele;
478      } else {
479          unsigned char *ele = lpLast(lp);
480          while (index < -1 && ele) {
481              ele = lpPrev(lp,ele);
482              index++;
483          }
484          return ele;
485      }
486  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-listpack.c</div>
                </div>
                <div class="column column_space"><pre><code>42  enum lfs_open_flags {
43      LFS_O_RDONLY = 1,        
44      LFS_O_WRONLY = 2,        
45      LFS_O_RDWR   = 3,        
46      LFS_O_CREAT  = 0x0100,   
47      LFS_O_EXCL   = 0x0200,   
48      LFS_O_TRUNC  = 0x0400,   
49      LFS_O_APPEND = 0x0800,   
50      LFS_F_DIRTY   = 0x10000, 
51      LFS_F_WRITING = 0x20000, 
52      LFS_F_READING = 0x40000, 
53      LFS_F_ERRED   = 0x80000, 
54  };
</pre></code></div>
                <div class="column column_space"><pre><code>157          } else {
158              uint64_t uv = v;
159              intenc[0] = LP_ENCODING_64BIT_INT;
160              intenc[1] = uv&0xff;
161              intenc[2] = (uv>>8)&0xff;
162              intenc[3] = (uv>>16)&0xff;
163              intenc[4] = (uv>>24)&0xff;
164              intenc[5] = (uv>>32)&0xff;
165              intenc[6] = (uv>>40)&0xff;
166              intenc[7] = (uv>>48)&0xff;
167              intenc[8] = uv>>56;
168              *enclen = 9;
169          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    