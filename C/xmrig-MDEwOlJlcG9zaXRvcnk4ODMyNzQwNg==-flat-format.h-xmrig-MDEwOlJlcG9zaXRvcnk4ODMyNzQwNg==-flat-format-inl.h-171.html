
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format.h</h3>
            <pre><code>1  #ifndef FMT_FORMAT_H_
2  #define FMT_FORMAT_H_
3  #include &lt;algorithm&gt;
4  #include &lt;cerrno&gt;
5  #include &lt;cmath&gt;
6  #include &lt;cstdint&gt;
7  #include &lt;limits&gt;
8  #include &lt;memory&gt;
9  #include &lt;stdexcept&gt;
10  #include &quot;core.h&quot;
11  #ifdef __INTEL_COMPILER
12  #  define FMT_ICC_VERSION __INTEL_COMPILER
13  #elif defined(__ICL)
14  #  define FMT_ICC_VERSION __ICL
15  #else
16  #  define FMT_ICC_VERSION 0
17  #endif
18  #ifdef __NVCC__
19  #  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
20  #else
21  #  define FMT_CUDA_VERSION 0
22  #endif
23  #ifdef __has_builtin
24  #  define FMT_HAS_BUILTIN(x) __has_builtin(x)
25  #else
26  #  define FMT_HAS_BUILTIN(x) 0
27  #endif
28  #if FMT_GCC_VERSION || FMT_CLANG_VERSION
29  #  define FMT_NOINLINE __attribute__((noinline))
30  #else
31  #  define FMT_NOINLINE
32  #endif
33  #if __cplusplus == 201103L || __cplusplus == 201402L
34  #  if defined(__INTEL_COMPILER) || defined(__PGI)
35  #    define FMT_FALLTHROUGH
36  #  elif defined(__clang__)
37  #    define FMT_FALLTHROUGH [[clang::fallthrough]]
38  #  elif FMT_GCC_VERSION &gt;= 700 &amp;&amp; \
39        (!defined(__EDG_VERSION__) || __EDG_VERSION__ &gt;= 520)
40  #    define FMT_FALLTHROUGH [[gnu::fallthrough]]
41  #  else
42  #    define FMT_FALLTHROUGH
43  #  endif
44  #elif FMT_HAS_CPP17_ATTRIBUTE(fallthrough) || \
45      (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)
46  #  define FMT_FALLTHROUGH [[fallthrough]]
47  #else
48  #  define FMT_FALLTHROUGH
49  #endif
50  #ifndef FMT_MAYBE_UNUSED
51  #  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
52  #    define FMT_MAYBE_UNUSED [[maybe_unused]]
53  #  else
54  #    define FMT_MAYBE_UNUSED
55  #  endif
56  #endif
57  #ifndef FMT_THROW
58  #  if FMT_EXCEPTIONS
59  #    if FMT_MSC_VER || FMT_NVCC
60  FMT_BEGIN_NAMESPACE
61  namespace detail {
62  template &lt;typename Exception&gt; inline void do_throw(const Exception&amp; x) {
63    volatile bool b = true;
64    if (b) throw x;
65  }
66  }  
67  FMT_END_NAMESPACE
68  #      define FMT_THROW(x) detail::do_throw(x)
69  #    else
70  #      define FMT_THROW(x) throw x
71  #    endif
72  #  else
73  #    define FMT_THROW(x)              \
74        do {                            \
75          static_cast&lt;void&gt;(sizeof(x)); \
76          FMT_ASSERT(false, &quot;&quot;);        \
77        } while (false)
78  #  endif
79  #endif
80  #if FMT_EXCEPTIONS
81  #  define FMT_TRY try
82  #  define FMT_CATCH(x) catch (x)
83  #else
84  #  define FMT_TRY if (true)
85  #  define FMT_CATCH(x) if (false)
86  #endif
87  #ifndef FMT_USE_USER_DEFINED_LITERALS
88  #  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION &gt;= 407 || \
89         FMT_MSC_VER &gt;= 1900) &amp;&amp;                                         \
90        (!defined(__EDG_VERSION__) || __EDG_VERSION__ &gt;= &amp;bsol;* UDL feature */ 480)
91  #    define FMT_USE_USER_DEFINED_LITERALS 1
92  #  else
93  #    define FMT_USE_USER_DEFINED_LITERALS 0
94  #  endif
95  #endif
96  #ifndef FMT_USE_UDL_TEMPLATE
97  #  if FMT_USE_USER_DEFINED_LITERALS &amp;&amp;                         \
98        (!defined(__EDG_VERSION__) || __EDG_VERSION__ &gt;= 501) &amp;&amp; \
99        ((FMT_GCC_VERSION &gt;= 604 &amp;&amp; __cplusplus &gt;= 201402L) ||   \
100         FMT_CLANG_VERSION &gt;= 304) &amp;&amp;                            \
101        !defined(__PGI) &amp;&amp; !defined(__NVCC__)
102  #    define FMT_USE_UDL_TEMPLATE 1
103  #  else
104  #    define FMT_USE_UDL_TEMPLATE 0
105  #  endif
106  #endif
107  #ifndef FMT_USE_FLOAT
108  #  define FMT_USE_FLOAT 1
109  #endif
110  #ifndef FMT_USE_DOUBLE
111  #  define FMT_USE_DOUBLE 1
112  #endif
113  #ifndef FMT_USE_LONG_DOUBLE
114  #  define FMT_USE_LONG_DOUBLE 1
115  #endif
116  #if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
117  #  define FMT_REDUCE_INT_INSTANTIATIONS 0
118  #endif
119  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clz)) &amp;&amp; !FMT_MSC_VER
120  #  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
121  #endif
122  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_clzll)) &amp;&amp; !FMT_MSC_VER
123  #  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
124  #endif
125  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctz))
126  #  define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
127  #endif
128  #if (FMT_GCC_VERSION || FMT_HAS_BUILTIN(__builtin_ctzll))
129  #  define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
130  #endif
131  #if FMT_MSC_VER
132  #  include &lt;intrin.h&gt;  
133  #endif
134  #if FMT_MSC_VER &amp;&amp; !defined(FMT_BUILTIN_CLZLL) &amp;&amp; \
135      !defined(FMT_BUILTIN_CTZLL) &amp;&amp; !defined(_MANAGED)
136  FMT_BEGIN_NAMESPACE
137  namespace detail {
138  #  ifndef __clang__
139  #    pragma intrinsic(_BitScanForward)
140  #    pragma intrinsic(_BitScanReverse)
141  #  endif
142  #  if defined(_WIN64) &amp;&amp; !defined(__clang__)
143  #    pragma intrinsic(_BitScanForward64)
144  #    pragma intrinsic(_BitScanReverse64)
145  #  endif
146  inline int clz(uint32_t x) {
147    unsigned long r = 0;
148    _BitScanReverse(&amp;r, x);
149    FMT_ASSERT(x != 0, &quot;&quot;);
150    FMT_SUPPRESS_MSC_WARNING(6102)
151    return 31 ^ static_cast&lt;int&gt;(r);
152  }
153  #  define FMT_BUILTIN_CLZ(n) detail::clz(n)
154  inline int clzll(uint64_t x) {
155    unsigned long r = 0;
156  #  ifdef _WIN64
157    _BitScanReverse64(&amp;r, x);
158  #  else
159    if (_BitScanReverse(&amp;r, static_cast&lt;uint32_t&gt;(x &gt;&gt; 32))) return 63 ^ (r + 32);
160    _BitScanReverse(&amp;r, static_cast&lt;uint32_t&gt;(x));
161  #  endif
162    FMT_ASSERT(x != 0, &quot;&quot;);
163    FMT_SUPPRESS_MSC_WARNING(6102)  
164    return 63 ^ static_cast&lt;int&gt;(r);
165  }
166  #  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
167  inline int ctz(uint32_t x) {
168    unsigned long r = 0;
169    _BitScanForward(&amp;r, x);
170    FMT_ASSERT(x != 0, &quot;&quot;);
171    FMT_SUPPRESS_MSC_WARNING(6102)  
172    return static_cast&lt;int&gt;(r);
173  }
174  #  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
175  inline int ctzll(uint64_t x) {
176    unsigned long r = 0;
177    FMT_ASSERT(x != 0, &quot;&quot;);
178    FMT_SUPPRESS_MSC_WARNING(6102)  
179  #  ifdef _WIN64
180    _BitScanForward64(&amp;r, x);
181  #  else
182    if (_BitScanForward(&amp;r, static_cast&lt;uint32_t&gt;(x))) return static_cast&lt;int&gt;(r);
183    _BitScanForward(&amp;r, static_cast&lt;uint32_t&gt;(x &gt;&gt; 32));
184    r += 32;
185  #  endif
186    return static_cast&lt;int&gt;(r);
187  }
188  #  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
189  }  
190  FMT_END_NAMESPACE
191  #endif
192  #ifndef FMT_DEPRECATED_NUMERIC_ALIGN
193  #  define FMT_DEPRECATED_NUMERIC_ALIGN 0
194  #endif
195  FMT_BEGIN_NAMESPACE
196  namespace detail {
197  template &lt;typename Dest, typename Source&gt;
198  inline Dest bit_cast(const Source&amp; source) {
199    static_assert(sizeof(Dest) == sizeof(Source), &quot;size mismatch&quot;);
200    Dest dest;
201    std::memcpy(&amp;dest, &amp;source, sizeof(dest));
202    return dest;
203  }
204  inline bool is_big_endian() {
205    const auto u = 1u;
206    struct bytes {
207      char data[sizeof(u)];
208    };
209    return bit_cast&lt;bytes&gt;(u).data[0] == 0;
210  }
211  struct fallback_uintptr {
212    unsigned char value[sizeof(void*)];
213    fallback_uintptr() = default;
214    explicit fallback_uintptr(const void* p) {
215      *this = bit_cast&lt;fallback_uintptr&gt;(p);
216      if (is_big_endian()) {
217        for (size_t i = 0, j = sizeof(void*) - 1; i &lt; j; ++i, --j)
218          std::swap(value[i], value[j]);
219      }
220    }
221  };
222  #ifdef UINTPTR_MAX
223  using uintptr_t = ::uintptr_t;
224  inline uintptr_t to_uintptr(const void* p) { return bit_cast&lt;uintptr_t&gt;(p); }
225  #else
226  using uintptr_t = fallback_uintptr;
227  inline fallback_uintptr to_uintptr(const void* p) {
228    return fallback_uintptr(p);
229  }
230  #endif
231  template &lt;typename T&gt; constexpr T max_value() {
232    return (std::numeric_limits&lt;T&gt;::max)();
233  }
234  template &lt;typename T&gt; constexpr int num_bits() {
235    return std::numeric_limits&lt;T&gt;::digits;
236  }
237  template &lt;&gt; constexpr int num_bits&lt;int128_t&gt;() { return 128; }
238  template &lt;&gt; constexpr int num_bits&lt;uint128_t&gt;() { return 128; }
239  template &lt;&gt; constexpr int num_bits&lt;fallback_uintptr&gt;() {
240    return static_cast&lt;int&gt;(sizeof(void*) *
241                            std::numeric_limits&lt;unsigned char&gt;::digits);
242  }
243  FMT_INLINE void assume(bool condition) {
244    (void)condition;
245  #if FMT_HAS_BUILTIN(__builtin_assume)
246    __builtin_assume(condition);
247  #endif
248  }
249  template &lt;typename T&gt;
250  using iterator_t = decltype(std::begin(std::declval&lt;T&amp;&gt;()));
251  template &lt;typename T&gt; using sentinel_t = decltype(std::end(std::declval&lt;T&amp;&gt;()));
252  template &lt;typename Char&gt; inline Char* get_data(std::basic_string&lt;Char&gt;&amp; s) {
253    return &amp;s[0];
254  }
255  template &lt;typename Container&gt;
256  inline typename Container::value_type* get_data(Container&amp; c) {
257    return c.data();
258  }
259  #if defined(_SECURE_SCL) &amp;&amp; _SECURE_SCL
260  template &lt;typename T&gt; using checked_ptr = stdext::checked_array_iterator&lt;T*&gt;;
261  template &lt;typename T&gt; checked_ptr&lt;T&gt; make_checked(T* p, size_t size) {
262    return {p, size};
263  }
264  #else
265  template &lt;typename T&gt; using checked_ptr = T*;
266  template &lt;typename T&gt; inline T* make_checked(T* p, size_t) { return p; }
267  #endif
268  template &lt;typename Container, FMT_ENABLE_IF(is_contiguous&lt;Container&gt;::value)&gt;
269  #if FMT_CLANG_VERSION
270  __attribute__((no_sanitize(&quot;undefined&quot;)))
271  #endif
272  inline checked_ptr&lt;typename Container::value_type&gt;
273  reserve(std::back_insert_iterator&lt;Container&gt; it, size_t n) {
274    Container&amp; c = get_container(it);
275    size_t size = c.size();
276    c.resize(size + n);
277    return make_checked(get_data(c) + size, n);
278  }
279  template &lt;typename T&gt;
280  inline buffer_appender&lt;T&gt; reserve(buffer_appender&lt;T&gt; it, size_t n) {
281    buffer&lt;T&gt;&amp; buf = get_container(it);
282    buf.try_reserve(buf.size() + n);
283    return it;
284  }
285  template &lt;typename Iterator&gt; inline Iterator&amp; reserve(Iterator&amp; it, size_t) {
286    return it;
287  }
288  template &lt;typename T, typename OutputIt&gt;
289  constexpr T* to_pointer(OutputIt, size_t) {
290    return nullptr;
291  }
292  template &lt;typename T&gt; T* to_pointer(buffer_appender&lt;T&gt; it, size_t n) {
293    buffer&lt;T&gt;&amp; buf = get_container(it);
294    auto size = buf.size();
295    if (buf.capacity() &lt; size + n) return nullptr;
296    buf.try_resize(size + n);
297    return buf.data() + size;
298  }
299  template &lt;typename Container, FMT_ENABLE_IF(is_contiguous&lt;Container&gt;::value)&gt;
300  inline std::back_insert_iterator&lt;Container&gt; base_iterator(
301      std::back_insert_iterator&lt;Container&gt;&amp; it,
302      checked_ptr&lt;typename Container::value_type&gt;) {
303    return it;
304  }
305  template &lt;typename Iterator&gt;
306  inline Iterator base_iterator(Iterator, Iterator it) {
307    return it;
308  }
309  class counting_iterator {
310   private:
311    size_t count_;
312   public:
313    using iterator_category = std::output_iterator_tag;
314    using difference_type = std::ptrdiff_t;
315    using pointer = void;
316    using reference = void;
317    using _Unchecked_type = counting_iterator;  
318    struct value_type {
319      template &lt;typename T&gt; void operator=(const T&amp;) {}
320    };
321    counting_iterator() : count_(0) {}
322    size_t count() const { return count_; }
323    counting_iterator&amp; operator++() {
324      ++count_;
325      return *this;
326    }
327    counting_iterator operator++(int) {
328      auto it = *this;
329      ++*this;
330      return it;
331    }
332    friend counting_iterator operator+(counting_iterator it, difference_type n) {
333      it.count_ += static_cast&lt;size_t&gt;(n);
334      return it;
335    }
336    value_type operator*() const { return {}; }
337  };
338  template &lt;typename OutputIt&gt; class truncating_iterator_base {
339   protected:
340    OutputIt out_;
341    size_t limit_;
342    size_t count_;
343    truncating_iterator_base(OutputIt out, size_t limit)
344        : out_(out), limit_(limit), count_(0) {}
345   public:
346    using iterator_category = std::output_iterator_tag;
347    using value_type = typename std::iterator_traits&lt;OutputIt&gt;::value_type;
348    using difference_type = void;
349    using pointer = void;
350    using reference = void;
351    using _Unchecked_type =
352        truncating_iterator_base;  
353    OutputIt base() const { return out_; }
354    size_t count() const { return count_; }
355  };
356  template &lt;typename OutputIt,
357            typename Enable = typename std::is_void&lt;
358                typename std::iterator_traits&lt;OutputIt&gt;::value_type&gt;::type&gt;
359  class truncating_iterator;
360  template &lt;typename OutputIt&gt;
361  class truncating_iterator&lt;OutputIt, std::false_type&gt;
362      : public truncating_iterator_base&lt;OutputIt&gt; {
363    mutable typename truncating_iterator_base&lt;OutputIt&gt;::value_type blackhole_;
364   public:
365    using value_type = typename truncating_iterator_base&lt;OutputIt&gt;::value_type;
366    truncating_iterator(OutputIt out, size_t limit)
367        : truncating_iterator_base&lt;OutputIt&gt;(out, limit) {}
368    truncating_iterator&amp; operator++() {
369      if (this-&gt;count_++ &lt; this-&gt;limit_) ++this-&gt;out_;
370      return *this;
371    }
372    truncating_iterator operator++(int) {
373      auto it = *this;
374      ++*this;
375      return it;
376    }
377    value_type&amp; operator*() const {
378      return this-&gt;count_ &lt; this-&gt;limit_ ? *this-&gt;out_ : blackhole_;
379    }
380  };
381  template &lt;typename OutputIt&gt;
382  class truncating_iterator&lt;OutputIt, std::true_type&gt;
383      : public truncating_iterator_base&lt;OutputIt&gt; {
384   public:
385    truncating_iterator(OutputIt out, size_t limit)
386        : truncating_iterator_base&lt;OutputIt&gt;(out, limit) {}
387    template &lt;typename T&gt; truncating_iterator&amp; operator=(T val) {
388      if (this-&gt;count_++ &lt; this-&gt;limit_) *this-&gt;out_++ = val;
389      return *this;
390    }
391    truncating_iterator&amp; operator++() { return *this; }
392    truncating_iterator&amp; operator++(int) { return *this; }
393    truncating_iterator&amp; operator*() { return *this; }
394  };
395  template &lt;typename Char&gt;
396  inline size_t count_code_points(basic_string_view&lt;Char&gt; s) {
397    return s.size();
398  }
399  inline size_t count_code_points(basic_string_view&lt;char&gt; s) {
400    const char* data = s.data();
401    size_t num_code_points = 0;
402    for (size_t i = 0, size = s.size(); i != size; ++i) {
403      if ((data[i] &amp; 0xc0) != 0x80) ++num_code_points;
404    }
405    return num_code_points;
406  }
407  inline size_t count_code_points(basic_string_view&lt;char8_type&gt; s) {
408    return count_code_points(basic_string_view&lt;char&gt;(
409        reinterpret_cast&lt;const char*&gt;(s.data()), s.size()));
410  }
411  template &lt;typename Char&gt;
412  inline size_t code_point_index(basic_string_view&lt;Char&gt; s, size_t n) {
413    size_t size = s.size();
414    return n &lt; size ? n : size;
415  }
416  inline size_t code_point_index(basic_string_view&lt;char8_type&gt; s, size_t n) {
417    const char8_type* data = s.data();
418    size_t num_code_points = 0;
419    for (size_t i = 0, size = s.size(); i != size; ++i) {
420      if ((data[i] &amp; 0xc0) != 0x80 &amp;&amp; ++num_code_points &gt; n) {
421        return i;
422      }
423    }
424    return s.size();
425  }
426  template &lt;typename InputIt, typename OutChar&gt;
427  using needs_conversion = bool_constant&lt;
428      std::is_same&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type,
429                   char&gt;::value &amp;&amp;
430      std::is_same&lt;OutChar, char8_type&gt;::value&gt;;
431  template &lt;typename OutChar, typename InputIt, typename OutputIt,
432            FMT_ENABLE_IF(!needs_conversion&lt;InputIt, OutChar&gt;::value)&gt;
433  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
434    return std::copy(begin, end, it);
435  }
436  template &lt;typename OutChar, typename InputIt, typename OutputIt,
437            FMT_ENABLE_IF(needs_conversion&lt;InputIt, OutChar&gt;::value)&gt;
438  OutputIt copy_str(InputIt begin, InputIt end, OutputIt it) {
439    return std::transform(begin, end, it,
440                          [](char c) { return static_cast&lt;char8_type&gt;(c); });
441  }
442  template &lt;typename Char, typename InputIt&gt;
443  inline counting_iterator copy_str(InputIt begin, InputIt end,
444                                    counting_iterator it) {
445    return it + (end - begin);
446  }
447  template &lt;typename T&gt;
448  using is_fast_float = bool_constant&lt;std::numeric_limits&lt;T&gt;::is_iec559 &amp;&amp;
449                                      sizeof(T) &lt;= sizeof(double)&gt;;
450  #ifndef FMT_USE_FULL_CACHE_DRAGONBOX
451  #  define FMT_USE_FULL_CACHE_DRAGONBOX 0
452  #endif
453  template &lt;typename T&gt;
454  template &lt;typename U&gt;
455  void buffer&lt;T&gt;::append(const U* begin, const U* end) {
456    do {
457      auto count = to_unsigned(end - begin);
458      try_reserve(size_ + count);
459      auto free_cap = capacity_ - size_;
460      if (free_cap &lt; count) count = free_cap;
461      std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
462      size_ += count;
463      begin += count;
464    } while (begin != end);
465  }
466  template &lt;typename OutputIt, typename T, typename Traits&gt;
467  void iterator_buffer&lt;OutputIt, T, Traits&gt;::flush() {
468    out_ = std::copy_n(data_, this-&gt;limit(this-&gt;size()), out_);
469    this-&gt;clear();
470  }
471  }  
472  enum { inline_buffer_size = 500 };
473  template &lt;typename T, size_t SIZE = inline_buffer_size,
474            typename Allocator = std::allocator&lt;T&gt;&gt;
475  class basic_memory_buffer : public detail::buffer&lt;T&gt; {
476   private:
477    T store_[SIZE];
478    Allocator alloc_;
479    void deallocate() {
480      T* data = this-&gt;data();
481      if (data != store_) alloc_.deallocate(data, this-&gt;capacity());
482    }
483   protected:
484    void grow(size_t size) final FMT_OVERRIDE;
485   public:
486    using value_type = T;
487    using const_reference = const T&amp;;
488    explicit basic_memory_buffer(const Allocator&amp; alloc = Allocator())
489        : alloc_(alloc) {
490      this-&gt;set(store_, SIZE);
491    }
492    ~basic_memory_buffer() { deallocate(); }
493   private:
494    void move(basic_memory_buffer&amp; other) {
495      alloc_ = std::move(other.alloc_);
496      T* data = other.data();
497      size_t size = other.size(), capacity = other.capacity();
498      if (data == other.store_) {
499        this-&gt;set(store_, capacity);
500        std::uninitialized_copy(other.store_, other.store_ + size,
501                                detail::make_checked(store_, capacity));
502      } else {
503        this-&gt;set(data, capacity);
504        other.set(other.store_, 0);
505      }
506      this-&gt;resize(size);
507    }
508   public:
509    basic_memory_buffer(basic_memory_buffer&amp;&amp; other) FMT_NOEXCEPT { move(other); }
510    basic_memory_buffer&amp; operator=(basic_memory_buffer&amp;&amp; other) FMT_NOEXCEPT {
511      FMT_ASSERT(this != &amp;other, &quot;&quot;);
512      deallocate();
513      move(other);
514      return *this;
515    }
516    Allocator get_allocator() const { return alloc_; }
517    void resize(size_t count) { this-&gt;try_resize(count); }
518    void reserve(size_t new_capacity) { this-&gt;try_reserve(new_capacity); }
519    using detail::buffer&lt;T&gt;::append;
520    template &lt;typename ContiguousRange&gt;
521    void append(const ContiguousRange&amp; range) {
522      append(range.data(), range.data() + range.size());
523    }
524  };
525  template &lt;typename T, size_t SIZE, typename Allocator&gt;
526  void basic_memory_buffer&lt;T, SIZE, Allocator&gt;::grow(size_t size) {
527  #ifdef FMT_FUZZ
528    if (size &gt; 5000) throw std::runtime_error(&quot;fuzz mode - won&#x27;t grow that much&quot;);
529  #endif
530    size_t old_capacity = this-&gt;capacity();
531    size_t new_capacity = old_capacity + old_capacity / 2;
532    if (size &gt; new_capacity) new_capacity = size;
533    T* old_data = this-&gt;data();
534    T* new_data =
535        std::allocator_traits&lt;Allocator&gt;::allocate(alloc_, new_capacity);
536    std::uninitialized_copy(old_data, old_data + this-&gt;size(),
537                            detail::make_checked(new_data, new_capacity));
538    this-&gt;set(new_data, new_capacity);
539    if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
540  }
541  using memory_buffer = basic_memory_buffer&lt;char&gt;;
542  using wmemory_buffer = basic_memory_buffer&lt;wchar_t&gt;;
543  template &lt;typename T, size_t SIZE, typename Allocator&gt;
544  struct is_contiguous&lt;basic_memory_buffer&lt;T, SIZE, Allocator&gt;&gt; : std::true_type {
545  };
546  FMT_CLASS_API
547  class FMT_API format_error : public std::runtime_error {
548   public:
549    explicit format_error(const char* message) : std::runtime_error(message) {}
550    explicit format_error(const std::string&amp; message)
551        : std::runtime_error(message) {}
552    format_error(const format_error&amp;) = default;
553    format_error&amp; operator=(const format_error&amp;) = default;
554    format_error(format_error&amp;&amp;) = default;
555    format_error&amp; operator=(format_error&amp;&amp;) = default;
556    ~format_error() FMT_NOEXCEPT FMT_OVERRIDE;
557  };
558  namespace detail {
559  template &lt;typename T&gt;
560  using is_signed =
561      std::integral_constant&lt;bool, std::numeric_limits&lt;T&gt;::is_signed ||
562                                       std::is_same&lt;T, int128_t&gt;::value&gt;;
563  template &lt;typename T, FMT_ENABLE_IF(is_signed&lt;T&gt;::value)&gt;
564  FMT_CONSTEXPR bool is_negative(T value) {
565    return value &lt; 0;
566  }
<span onclick='openModal()' class='match'>567  template &lt;typename T, FMT_ENABLE_IF(!is_signed&lt;T&gt;::value)&gt;
568  FMT_CONSTEXPR bool is_negative(T) {
</span>569    return false;
570  }
571  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
572  FMT_CONSTEXPR bool is_supported_floating_point(T) {
573    return (std::is_same&lt;T, float&gt;::value &amp;&amp; FMT_USE_FLOAT) ||
574           (std::is_same&lt;T, double&gt;::value &amp;&amp; FMT_USE_DOUBLE) ||
575           (std::is_same&lt;T, long double&gt;::value &amp;&amp; FMT_USE_LONG_DOUBLE);
576  }
577  template &lt;typename T&gt;
578  using uint32_or_64_or_128_t =
579      conditional_t&lt;num_bits&lt;T&gt;() &lt;= 32 &amp;&amp; !FMT_REDUCE_INT_INSTANTIATIONS,
580                    uint32_t,
581                    conditional_t&lt;num_bits&lt;T&gt;() &lt;= 64, uint64_t, uint128_t&gt;&gt;;
582  struct FMT_EXTERN_TEMPLATE_API uint128_wrapper {
583    uint128_wrapper() = default;
584  #if FMT_USE_INT128
585    uint128_t internal_;
586    uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT
587        : internal_{static_cast&lt;uint128_t&gt;(low) |
588                    (static_cast&lt;uint128_t&gt;(high) &lt;&lt; 64)} {}
589    uint128_wrapper(uint128_t u) : internal_{u} {}
590    uint64_t high() const FMT_NOEXCEPT { return uint64_t(internal_ &gt;&gt; 64); }
591    uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }
592    uint128_wrapper&amp; operator+=(uint64_t n) &amp; FMT_NOEXCEPT {
593      internal_ += n;
594      return *this;
595    }
596  #else
597    uint64_t high_;
598    uint64_t low_;
599    uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT : high_{high},
600                                                                low_{low} {}
601    uint64_t high() const FMT_NOEXCEPT { return high_; }
602    uint64_t low() const FMT_NOEXCEPT { return low_; }
603    uint128_wrapper&amp; operator+=(uint64_t n) &amp; FMT_NOEXCEPT {
604  #  if defined(_MSC_VER) &amp;&amp; defined(_M_X64)
605      unsigned char carry = _addcarry_u64(0, low_, n, &amp;low_);
606      _addcarry_u64(carry, high_, 0, &amp;high_);
607      return *this;
608  #  else
609      uint64_t sum = low_ + n;
610      high_ += (sum &lt; low_ ? 1 : 0);
611      low_ = sum;
612      return *this;
613  #  endif
614    }
615  #endif
616  };
617  template &lt;typename T&gt; struct FMT_EXTERN_TEMPLATE_API divtest_table_entry {
618    T mod_inv;
619    T max_quotient;
620  };
621  template &lt;typename T = void&gt; struct FMT_EXTERN_TEMPLATE_API basic_data {
622    static const uint64_t powers_of_10_64[];
623    static const uint32_t zero_or_powers_of_10_32[];
624    static const uint64_t zero_or_powers_of_10_64[];
625    static const uint64_t grisu_pow10_significands[];
626    static const int16_t grisu_pow10_exponents[];
627    static const divtest_table_entry&lt;uint32_t&gt; divtest_table_for_pow5_32[];
628    static const divtest_table_entry&lt;uint64_t&gt; divtest_table_for_pow5_64[];
629    static const uint64_t dragonbox_pow10_significands_64[];
630    static const uint128_wrapper dragonbox_pow10_significands_128[];
631    static const uint64_t log10_2_significand = 0x4d104d427de7fbcc;
632  #if !FMT_USE_FULL_CACHE_DRAGONBOX
633    static const uint64_t powers_of_5_64[];
634    static const uint32_t dragonbox_pow10_recovery_errors[];
635  #endif
636    using digit_pair = char[2];
637    static const digit_pair digits[];
638    static const char hex_digits[];
639    static const char foreground_color[];
640    static const char background_color[];
641    static const char reset_color[5];
642    static const wchar_t wreset_color[5];
643    static const char signs[];
644    static const char left_padding_shifts[5];
645    static const char right_padding_shifts[5];
646  };
647  FMT_INLINE uint16_t bsr2log10(int bsr) {
648    static constexpr uint16_t data[] = {
649        1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
650        6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
651        10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
652        15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
653    return data[bsr];
654  }
655  #ifndef FMT_EXPORTED
656  FMT_EXTERN template struct basic_data&lt;void&gt;;
657  #endif
658  struct data : basic_data&lt;&gt; {};
659  #ifdef FMT_BUILTIN_CLZLL
660  inline int count_digits(uint64_t n) {
661    auto t = bsr2log10(FMT_BUILTIN_CLZLL(n | 1) ^ 63);
662    return t - (n &lt; data::zero_or_powers_of_10_64[t]);
663  }
664  #else
665  inline int count_digits(uint64_t n) {
666    int count = 1;
667    for (;;) {
668      if (n &lt; 10) return count;
669      if (n &lt; 100) return count + 1;
670      if (n &lt; 1000) return count + 2;
671      if (n &lt; 10000) return count + 3;
672      n /= 10000u;
673      count += 4;
674    }
675  }
676  #endif
677  #if FMT_USE_INT128
678  inline int count_digits(uint128_t n) {
679    int count = 1;
680    for (;;) {
681      if (n &lt; 10) return count;
682      if (n &lt; 100) return count + 1;
683      if (n &lt; 1000) return count + 2;
684      if (n &lt; 10000) return count + 3;
685      n /= 10000U;
686      count += 4;
687    }
688  }
689  #endif
690  template &lt;unsigned BITS, typename UInt&gt; inline int count_digits(UInt n) {
691    int num_digits = 0;
692    do {
693      ++num_digits;
694    } while ((n &gt;&gt;= BITS) != 0);
695    return num_digits;
696  }
697  template &lt;&gt; int count_digits&lt;4&gt;(detail::fallback_uintptr n);
698  #if FMT_GCC_VERSION || FMT_CLANG_VERSION
699  #  define FMT_ALWAYS_INLINE inline __attribute__((always_inline))
700  #elif FMT_MSC_VER
701  #  define FMT_ALWAYS_INLINE __forceinline
702  #else
703  #  define FMT_ALWAYS_INLINE inline
704  #endif
705  #if FMT_MSC_VER &amp;&amp; !FMT_CLANG_VERSION
706  #  define FMT_SAFEBUFFERS __declspec(safebuffers)
707  #else
708  #  define FMT_SAFEBUFFERS
709  #endif
710  #ifdef FMT_BUILTIN_CLZ
711  inline int count_digits(uint32_t n) {
712    auto t = bsr2log10(FMT_BUILTIN_CLZ(n | 1) ^ 31);
713    return t - (n &lt; data::zero_or_powers_of_10_32[t]);
714  }
715  #endif
716  template &lt;typename Int&gt; constexpr int digits10() FMT_NOEXCEPT {
717    return std::numeric_limits&lt;Int&gt;::digits10;
718  }
719  template &lt;&gt; constexpr int digits10&lt;int128_t&gt;() FMT_NOEXCEPT { return 38; }
720  template &lt;&gt; constexpr int digits10&lt;uint128_t&gt;() FMT_NOEXCEPT { return 38; }
721  template &lt;typename Char&gt; FMT_API std::string grouping_impl(locale_ref loc);
722  template &lt;typename Char&gt; inline std::string grouping(locale_ref loc) {
723    return grouping_impl&lt;char&gt;(loc);
724  }
725  template &lt;&gt; inline std::string grouping&lt;wchar_t&gt;(locale_ref loc) {
726    return grouping_impl&lt;wchar_t&gt;(loc);
727  }
728  template &lt;typename Char&gt; FMT_API Char thousands_sep_impl(locale_ref loc);
729  template &lt;typename Char&gt; inline Char thousands_sep(locale_ref loc) {
730    return Char(thousands_sep_impl&lt;char&gt;(loc));
731  }
732  template &lt;&gt; inline wchar_t thousands_sep(locale_ref loc) {
733    return thousands_sep_impl&lt;wchar_t&gt;(loc);
734  }
735  template &lt;typename Char&gt; FMT_API Char decimal_point_impl(locale_ref loc);
736  template &lt;typename Char&gt; inline Char decimal_point(locale_ref loc) {
737    return Char(decimal_point_impl&lt;char&gt;(loc));
738  }
739  template &lt;&gt; inline wchar_t decimal_point(locale_ref loc) {
740    return decimal_point_impl&lt;wchar_t&gt;(loc);
741  }
742  template &lt;typename Char&gt; bool equal2(const Char* lhs, const char* rhs) {
743    return lhs[0] == rhs[0] &amp;&amp; lhs[1] == rhs[1];
744  }
745  inline bool equal2(const char* lhs, const char* rhs) {
746    return memcmp(lhs, rhs, 2) == 0;
747  }
748  template &lt;typename Char&gt; void copy2(Char* dst, const char* src) {
749    *dst++ = static_cast&lt;Char&gt;(*src++);
750    *dst = static_cast&lt;Char&gt;(*src);
751  }
752  inline void copy2(char* dst, const char* src) { memcpy(dst, src, 2); }
753  template &lt;typename Iterator&gt; struct format_decimal_result {
754    Iterator begin;
755    Iterator end;
756  };
757  template &lt;typename Char, typename UInt&gt;
758  inline format_decimal_result&lt;Char*&gt; format_decimal(Char* out, UInt value,
759                                                     int size) {
760    FMT_ASSERT(size &gt;= count_digits(value), &quot;invalid digit count&quot;);
761    out += size;
762    Char* end = out;
763    while (value &gt;= 100) {
764      out -= 2;
765      copy2(out, data::digits[value % 100]);
766      value /= 100;
767    }
768    if (value &lt; 10) {
769      *--out = static_cast&lt;Char&gt;(&#x27;0&#x27; + value);
770      return {out, end};
771    }
772    out -= 2;
773    copy2(out, data::digits[value]);
774    return {out, end};
775  }
776  template &lt;typename Char, typename UInt, typename Iterator,
777            FMT_ENABLE_IF(!std::is_pointer&lt;remove_cvref_t&lt;Iterator&gt;&gt;::value)&gt;
778  inline format_decimal_result&lt;Iterator&gt; format_decimal(Iterator out, UInt value,
779                                                        int num_digits) {
780    enum { max_size = digits10&lt;UInt&gt;() + 1 };
781    Char buffer[2 * max_size];
782    auto end = format_decimal(buffer, value, num_digits).end;
783    return {out, detail::copy_str&lt;Char&gt;(buffer, end, out)};
784  }
785  template &lt;unsigned BASE_BITS, typename Char, typename UInt&gt;
786  inline Char* format_uint(Char* buffer, UInt value, int num_digits,
787                           bool upper = false) {
788    buffer += num_digits;
789    Char* end = buffer;
790    do {
791      const char* digits = upper ? &quot;0123456789ABCDEF&quot; : data::hex_digits;
792      unsigned digit = (value &amp; ((1 &lt;&lt; BASE_BITS) - 1));
793      *--buffer = static_cast&lt;Char&gt;(BASE_BITS &lt; 4 ? static_cast&lt;char&gt;(&#x27;0&#x27; + digit)
794                                                  : digits[digit]);
795    } while ((value &gt;&gt;= BASE_BITS) != 0);
796    return end;
797  }
798  template &lt;unsigned BASE_BITS, typename Char&gt;
799  Char* format_uint(Char* buffer, detail::fallback_uintptr n, int num_digits,
800                    bool = false) {
801    auto char_digits = std::numeric_limits&lt;unsigned char&gt;::digits / 4;
802    int start = (num_digits + char_digits - 1) / char_digits - 1;
803    if (int start_digits = num_digits % char_digits) {
804      unsigned value = n.value[start--];
805      buffer = format_uint&lt;BASE_BITS&gt;(buffer, value, start_digits);
806    }
807    for (; start &gt;= 0; --start) {
808      unsigned value = n.value[start];
809      buffer += char_digits;
810      auto p = buffer;
811      for (int i = 0; i &lt; char_digits; ++i) {
812        unsigned digit = (value &amp; ((1 &lt;&lt; BASE_BITS) - 1));
813        *--p = static_cast&lt;Char&gt;(data::hex_digits[digit]);
814        value &gt;&gt;= BASE_BITS;
815      }
816    }
817    return buffer;
818  }
819  template &lt;unsigned BASE_BITS, typename Char, typename It, typename UInt&gt;
820  inline It format_uint(It out, UInt value, int num_digits, bool upper = false) {
821    char buffer[num_bits&lt;UInt&gt;() / BASE_BITS + 1];
822    format_uint&lt;BASE_BITS&gt;(buffer, value, num_digits, upper);
823    return detail::copy_str&lt;Char&gt;(buffer, buffer + num_digits, out);
824  }
825  class utf8_to_utf16 {
826   private:
827    wmemory_buffer buffer_;
828   public:
829    FMT_API explicit utf8_to_utf16(string_view s);
830    operator wstring_view() const { return {&amp;buffer_[0], size()}; }
831    size_t size() const { return buffer_.size() - 1; }
832    const wchar_t* c_str() const { return &amp;buffer_[0]; }
833    std::wstring str() const { return {&amp;buffer_[0], size()}; }
834  };
835  template &lt;typename T = void&gt; struct null {};
836  template &lt;typename Char&gt; struct fill_t {
837   private:
838    enum { max_size = 4 };
839    Char data_[max_size];
840    unsigned char size_;
841   public:
842    FMT_CONSTEXPR void operator=(basic_string_view&lt;Char&gt; s) {
843      auto size = s.size();
844      if (size &gt; max_size) {
845        FMT_THROW(format_error(&quot;invalid fill&quot;));
846        return;
847      }
848      for (size_t i = 0; i &lt; size; ++i) data_[i] = s[i];
849      size_ = static_cast&lt;unsigned char&gt;(size);
850    }
851    size_t size() const { return size_; }
852    const Char* data() const { return data_; }
853    FMT_CONSTEXPR Char&amp; operator[](size_t index) { return data_[index]; }
854    FMT_CONSTEXPR const Char&amp; operator[](size_t index) const {
855      return data_[index];
856    }
857    static FMT_CONSTEXPR fill_t&lt;Char&gt; make() {
858      auto fill = fill_t&lt;Char&gt;();
859      fill[0] = Char(&#x27; &#x27;);
860      fill.size_ = 1;
861      return fill;
862    }
863  };
864  }  
865  namespace align {
866  enum type { none, left, right, center, numeric };
867  }
868  using align_t = align::type;
869  namespace sign {
870  enum type { none, minus, plus, space };
871  }
872  using sign_t = sign::type;
873  template &lt;typename Char&gt; struct basic_format_specs {
874    int width;
875    int precision;
876    char type;
877    align_t align : 4;
878    sign_t sign : 3;
879    bool alt : 1;  
880    detail::fill_t&lt;Char&gt; fill;
881    constexpr basic_format_specs()
882        : width(0),
883          precision(-1),
884          type(0),
885          align(align::none),
886          sign(sign::none),
887          alt(false),
888          fill(detail::fill_t&lt;Char&gt;::make()) {}
889  };
890  using format_specs = basic_format_specs&lt;char&gt;;
891  namespace detail {
892  namespace dragonbox {
893  template &lt;class T&gt; struct float_info;
894  template &lt;&gt; struct float_info&lt;float&gt; {
895    using carrier_uint = uint32_t;
896    static const int significand_bits = 23;
897    static const int exponent_bits = 8;
898    static const int min_exponent = -126;
899    static const int max_exponent = 127;
900    static const int exponent_bias = -127;
901    static const int decimal_digits = 9;
902    static const int kappa = 1;
903    static const int big_divisor = 100;
904    static const int small_divisor = 10;
905    static const int min_k = -31;
906    static const int max_k = 46;
907    static const int cache_bits = 64;
908    static const int divisibility_check_by_5_threshold = 39;
909    static const int case_fc_pm_half_lower_threshold = -1;
910    static const int case_fc_pm_half_upper_threshold = 6;
911    static const int case_fc_lower_threshold = -2;
912    static const int case_fc_upper_threshold = 6;
913    static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
914    static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
915    static const int shorter_interval_tie_lower_threshold = -35;
916    static const int shorter_interval_tie_upper_threshold = -35;
917    static const int max_trailing_zeros = 7;
918  };
919  template &lt;&gt; struct float_info&lt;double&gt; {
920    using carrier_uint = uint64_t;
921    static const int significand_bits = 52;
922    static const int exponent_bits = 11;
923    static const int min_exponent = -1022;
924    static const int max_exponent = 1023;
925    static const int exponent_bias = -1023;
926    static const int decimal_digits = 17;
927    static const int kappa = 2;
928    static const int big_divisor = 1000;
929    static const int small_divisor = 100;
930    static const int min_k = -292;
931    static const int max_k = 326;
932    static const int cache_bits = 128;
933    static const int divisibility_check_by_5_threshold = 86;
934    static const int case_fc_pm_half_lower_threshold = -2;
935    static const int case_fc_pm_half_upper_threshold = 9;
936    static const int case_fc_lower_threshold = -4;
937    static const int case_fc_upper_threshold = 9;
938    static const int case_shorter_interval_left_endpoint_lower_threshold = 2;
939    static const int case_shorter_interval_left_endpoint_upper_threshold = 3;
940    static const int shorter_interval_tie_lower_threshold = -77;
941    static const int shorter_interval_tie_upper_threshold = -77;
942    static const int max_trailing_zeros = 16;
943  };
944  template &lt;typename T&gt; struct decimal_fp {
945    using significand_type = typename float_info&lt;T&gt;::carrier_uint;
946    significand_type significand;
947    int exponent;
948  };
949  template &lt;typename T&gt; decimal_fp&lt;T&gt; to_decimal(T x) FMT_NOEXCEPT;
950  }  
951  enum class float_format : unsigned char {
952    general,  
953    exp,      
954    fixed,    
955    hex
956  };
957  struct float_specs {
958    int precision;
959    float_format format : 8;
960    sign_t sign : 8;
961    bool upper : 1;
962    bool locale : 1;
963    bool binary32 : 1;
964    bool use_grisu : 1;
965    bool showpoint : 1;
966  };
967  template &lt;typename Char, typename It&gt; It write_exponent(int exp, It it) {
968    FMT_ASSERT(-10000 &lt; exp &amp;&amp; exp &lt; 10000, &quot;exponent out of range&quot;);
969    if (exp &lt; 0) {
970      *it++ = static_cast&lt;Char&gt;(&#x27;-&#x27;);
971      exp = -exp;
972    } else {
973      *it++ = static_cast&lt;Char&gt;(&#x27;+&#x27;);
974    }
975    if (exp &gt;= 100) {
976      const char* top = data::digits[exp / 100];
977      if (exp &gt;= 1000) *it++ = static_cast&lt;Char&gt;(top[0]);
978      *it++ = static_cast&lt;Char&gt;(top[1]);
979      exp %= 100;
980    }
981    const char* d = data::digits[exp];
982    *it++ = static_cast&lt;Char&gt;(d[0]);
983    *it++ = static_cast&lt;Char&gt;(d[1]);
984    return it;
985  }
986  template &lt;typename T&gt;
987  int format_float(T value, int precision, float_specs specs, buffer&lt;char&gt;&amp; buf);
988  template &lt;typename T&gt;
989  int snprintf_float(T value, int precision, float_specs specs,
990                     buffer&lt;char&gt;&amp; buf);
991  template &lt;typename T&gt; T promote_float(T value) { return value; }
992  inline double promote_float(float value) { return static_cast&lt;double&gt;(value); }
993  template &lt;typename Handler&gt;
994  FMT_CONSTEXPR void handle_int_type_spec(char spec, Handler&amp;&amp; handler) {
995    switch (spec) {
996    case 0:
997    case &#x27;d&#x27;:
998      handler.on_dec();
999      break;
1000    case &#x27;x&#x27;:
1001    case &#x27;X&#x27;:
1002      handler.on_hex();
1003      break;
1004    case &#x27;b&#x27;:
1005    case &#x27;B&#x27;:
1006      handler.on_bin();
1007      break;
1008    case &#x27;o&#x27;:
1009      handler.on_oct();
1010      break;
1011  #ifdef FMT_DEPRECATED_N_SPECIFIER
1012    case &#x27;n&#x27;:
1013  #endif
1014    case &#x27;L&#x27;:
1015      handler.on_num();
1016      break;
1017    case &#x27;c&#x27;:
1018      handler.on_chr();
1019      break;
1020    default:
1021      handler.on_error();
1022    }
1023  }
1024  template &lt;typename ErrorHandler = error_handler, typename Char&gt;
1025  FMT_CONSTEXPR float_specs parse_float_type_spec(
1026      const basic_format_specs&lt;Char&gt;&amp; specs, ErrorHandler&amp;&amp; eh = {}) {
1027    auto result = float_specs();
1028    result.showpoint = specs.alt;
1029    switch (specs.type) {
1030    case 0:
1031      result.format = float_format::general;
1032      result.showpoint |= specs.precision &gt; 0;
1033      break;
1034    case &#x27;G&#x27;:
1035      result.upper = true;
1036      FMT_FALLTHROUGH;
1037    case &#x27;g&#x27;:
1038      result.format = float_format::general;
1039      break;
1040    case &#x27;E&#x27;:
1041      result.upper = true;
1042      FMT_FALLTHROUGH;
1043    case &#x27;e&#x27;:
1044      result.format = float_format::exp;
1045      result.showpoint |= specs.precision != 0;
1046      break;
1047    case &#x27;F&#x27;:
1048      result.upper = true;
1049      FMT_FALLTHROUGH;
1050    case &#x27;f&#x27;:
1051      result.format = float_format::fixed;
1052      result.showpoint |= specs.precision != 0;
1053      break;
1054    case &#x27;A&#x27;:
1055      result.upper = true;
1056      FMT_FALLTHROUGH;
1057    case &#x27;a&#x27;:
1058      result.format = float_format::hex;
1059      break;
1060  #ifdef FMT_DEPRECATED_N_SPECIFIER
1061    case &#x27;n&#x27;:
1062  #endif
1063    case &#x27;L&#x27;:
1064      result.locale = true;
1065      break;
1066    default:
1067      eh.on_error(&quot;invalid type specifier&quot;);
1068      break;
1069    }
1070    return result;
1071  }
1072  template &lt;typename Char, typename Handler&gt;
1073  FMT_CONSTEXPR void handle_char_specs(const basic_format_specs&lt;Char&gt;* specs,
1074                                       Handler&amp;&amp; handler) {
1075    if (!specs) return handler.on_char();
1076    if (specs-&gt;type &amp;&amp; specs-&gt;type != &#x27;c&#x27;) return handler.on_int();
1077    if (specs-&gt;align == align::numeric || specs-&gt;sign != sign::none || specs-&gt;alt)
1078      handler.on_error(&quot;invalid format specifier for char&quot;);
1079    handler.on_char();
1080  }
1081  template &lt;typename Char, typename Handler&gt;
1082  FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler&amp;&amp; handler) {
1083    if (spec == 0 || spec == &#x27;s&#x27;)
1084      handler.on_string();
1085    else if (spec == &#x27;p&#x27;)
1086      handler.on_pointer();
1087    else
1088      handler.on_error(&quot;invalid type specifier&quot;);
1089  }
1090  template &lt;typename Char, typename ErrorHandler&gt;
1091  FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler&amp;&amp; eh) {
1092    if (spec != 0 &amp;&amp; spec != &#x27;s&#x27;) eh.on_error(&quot;invalid type specifier&quot;);
1093  }
1094  template &lt;typename Char, typename ErrorHandler&gt;
1095  FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler&amp;&amp; eh) {
1096    if (spec != 0 &amp;&amp; spec != &#x27;p&#x27;) eh.on_error(&quot;invalid type specifier&quot;);
1097  }
1098  template &lt;typename ErrorHandler&gt; class int_type_checker : private ErrorHandler {
1099   public:
1100    FMT_CONSTEXPR explicit int_type_checker(ErrorHandler eh) : ErrorHandler(eh) {}
1101    FMT_CONSTEXPR void on_dec() {}
1102    FMT_CONSTEXPR void on_hex() {}
1103    FMT_CONSTEXPR void on_bin() {}
1104    FMT_CONSTEXPR void on_oct() {}
1105    FMT_CONSTEXPR void on_num() {}
1106    FMT_CONSTEXPR void on_chr() {}
1107    FMT_CONSTEXPR void on_error() {
1108      ErrorHandler::on_error(&quot;invalid type specifier&quot;);
1109    }
1110  };
1111  template &lt;typename ErrorHandler&gt;
1112  class char_specs_checker : public ErrorHandler {
1113   private:
1114    char type_;
1115   public:
1116    FMT_CONSTEXPR char_specs_checker(char type, ErrorHandler eh)
1117        : ErrorHandler(eh), type_(type) {}
1118    FMT_CONSTEXPR void on_int() {
1119      handle_int_type_spec(type_, int_type_checker&lt;ErrorHandler&gt;(*this));
1120    }
1121    FMT_CONSTEXPR void on_char() {}
1122  };
1123  template &lt;typename ErrorHandler&gt;
1124  class cstring_type_checker : public ErrorHandler {
1125   public:
1126    FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)
1127        : ErrorHandler(eh) {}
1128    FMT_CONSTEXPR void on_string() {}
1129    FMT_CONSTEXPR void on_pointer() {}
1130  };
1131  template &lt;typename OutputIt, typename Char&gt;
1132  FMT_NOINLINE OutputIt fill(OutputIt it, size_t n, const fill_t&lt;Char&gt;&amp; fill) {
1133    auto fill_size = fill.size();
1134    if (fill_size == 1) return std::fill_n(it, n, fill[0]);
1135    for (size_t i = 0; i &lt; n; ++i) it = std::copy_n(fill.data(), fill_size, it);
1136    return it;
1137  }
1138  template &lt;align::type align = align::left, typename OutputIt, typename Char,
1139            typename F&gt;
1140  inline OutputIt write_padded(OutputIt out,
1141                               const basic_format_specs&lt;Char&gt;&amp; specs, size_t size,
1142                               size_t width, const F&amp; f) {
1143    static_assert(align == align::left || align == align::right, &quot;&quot;);
1144    unsigned spec_width = to_unsigned(specs.width);
1145    size_t padding = spec_width &gt; width ? spec_width - width : 0;
1146    auto* shifts = align == align::left ? data::left_padding_shifts
1147                                        : data::right_padding_shifts;
1148    size_t left_padding = padding &gt;&gt; shifts[specs.align];
1149    auto it = reserve(out, size + padding * specs.fill.size());
1150    it = fill(it, left_padding, specs.fill);
1151    it = f(it);
1152    it = fill(it, padding - left_padding, specs.fill);
1153    return base_iterator(out, it);
1154  }
1155  template &lt;align::type align = align::left, typename OutputIt, typename Char,
1156            typename F&gt;
1157  inline OutputIt write_padded(OutputIt out,
1158                               const basic_format_specs&lt;Char&gt;&amp; specs, size_t size,
1159                               const F&amp; f) {
1160    return write_padded&lt;align&gt;(out, specs, size, size, f);
1161  }
1162  template &lt;typename Char, typename OutputIt&gt;
1163  OutputIt write_bytes(OutputIt out, string_view bytes,
1164                       const basic_format_specs&lt;Char&gt;&amp; specs) {
1165    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1166    return write_padded(out, specs, bytes.size(), [bytes](iterator it) {
1167      const char* data = bytes.data();
1168      return copy_str&lt;Char&gt;(data, data + bytes.size(), it);
1169    });
1170  }
1171  template &lt;typename Char&gt; struct write_int_data {
1172    size_t size;
1173    size_t padding;
1174    write_int_data(int num_digits, string_view prefix,
1175                   const basic_format_specs&lt;Char&gt;&amp; specs)
1176        : size(prefix.size() + to_unsigned(num_digits)), padding(0) {
1177      if (specs.align == align::numeric) {
1178        auto width = to_unsigned(specs.width);
1179        if (width &gt; size) {
1180          padding = width - size;
1181          size = width;
1182        }
1183      } else if (specs.precision &gt; num_digits) {
1184        size = prefix.size() + to_unsigned(specs.precision);
1185        padding = to_unsigned(specs.precision - num_digits);
1186      }
1187    }
1188  };
1189  template &lt;typename OutputIt, typename Char, typename F&gt;
1190  OutputIt write_int(OutputIt out, int num_digits, string_view prefix,
1191                     const basic_format_specs&lt;Char&gt;&amp; specs, F f) {
1192    auto data = write_int_data&lt;Char&gt;(num_digits, prefix, specs);
1193    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1194    return write_padded&lt;align::right&gt;(out, specs, data.size, [=](iterator it) {
1195      if (prefix.size() != 0)
1196        it = copy_str&lt;Char&gt;(prefix.begin(), prefix.end(), it);
1197      it = std::fill_n(it, data.padding, static_cast&lt;Char&gt;(&#x27;0&#x27;));
1198      return f(it);
1199    });
1200  }
1201  template &lt;typename StrChar, typename Char, typename OutputIt&gt;
1202  OutputIt write(OutputIt out, basic_string_view&lt;StrChar&gt; s,
1203                 const basic_format_specs&lt;Char&gt;&amp; specs) {
1204    auto data = s.data();
1205    auto size = s.size();
1206    if (specs.precision &gt;= 0 &amp;&amp; to_unsigned(specs.precision) &lt; size)
1207      size = code_point_index(s, to_unsigned(specs.precision));
1208    auto width = specs.width != 0
1209                     ? count_code_points(basic_string_view&lt;StrChar&gt;(data, size))
1210                     : 0;
1211    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1212    return write_padded(out, specs, size, width, [=](iterator it) {
1213      return copy_str&lt;Char&gt;(data, data + size, it);
1214    });
1215  }
1216  template &lt;typename OutputIt, typename Char, typename UInt&gt; struct int_writer {
1217    OutputIt out;
1218    locale_ref locale;
1219    const basic_format_specs&lt;Char&gt;&amp; specs;
1220    UInt abs_value;
1221    char prefix[4];
1222    unsigned prefix_size;
1223    using iterator =
1224        remove_reference_t&lt;decltype(reserve(std::declval&lt;OutputIt&amp;&gt;(), 0))&gt;;
1225    string_view get_prefix() const { return string_view(prefix, prefix_size); }
1226    template &lt;typename Int&gt;
1227    int_writer(OutputIt output, locale_ref loc, Int value,
1228               const basic_format_specs&lt;Char&gt;&amp; s)
1229        : out(output),
1230          locale(loc),
1231          specs(s),
1232          abs_value(static_cast&lt;UInt&gt;(value)),
1233          prefix_size(0) {
1234      static_assert(std::is_same&lt;uint32_or_64_or_128_t&lt;Int&gt;, UInt&gt;::value, &quot;&quot;);
1235      if (is_negative(value)) {
1236        prefix[0] = &#x27;-&#x27;;
1237        ++prefix_size;
1238        abs_value = 0 - abs_value;
1239      } else if (specs.sign != sign::none &amp;&amp; specs.sign != sign::minus) {
1240        prefix[0] = specs.sign == sign::plus ? &#x27;+&#x27; : &#x27; &#x27;;
1241        ++prefix_size;
1242      }
1243    }
1244    void on_dec() {
1245      auto num_digits = count_digits(abs_value);
1246      out = write_int(
1247          out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {
1248            return format_decimal&lt;Char&gt;(it, abs_value, num_digits).end;
1249          });
1250    }
1251    void on_hex() {
1252      if (specs.alt) {
1253        prefix[prefix_size++] = &#x27;0&#x27;;
1254        prefix[prefix_size++] = specs.type;
1255      }
1256      int num_digits = count_digits&lt;4&gt;(abs_value);
1257      out = write_int(out, num_digits, get_prefix(), specs,
1258                      [this, num_digits](iterator it) {
1259                        return format_uint&lt;4, Char&gt;(it, abs_value, num_digits,
1260                                                    specs.type != &#x27;x&#x27;);
1261                      });
1262    }
1263    void on_bin() {
1264      if (specs.alt) {
1265        prefix[prefix_size++] = &#x27;0&#x27;;
1266        prefix[prefix_size++] = static_cast&lt;char&gt;(specs.type);
1267      }
1268      int num_digits = count_digits&lt;1&gt;(abs_value);
1269      out = write_int(out, num_digits, get_prefix(), specs,
1270                      [this, num_digits](iterator it) {
1271                        return format_uint&lt;1, Char&gt;(it, abs_value, num_digits);
1272                      });
1273    }
1274    void on_oct() {
1275      int num_digits = count_digits&lt;3&gt;(abs_value);
1276      if (specs.alt &amp;&amp; specs.precision &lt;= num_digits &amp;&amp; abs_value != 0) {
1277        prefix[prefix_size++] = &#x27;0&#x27;;
1278      }
1279      out = write_int(out, num_digits, get_prefix(), specs,
1280                      [this, num_digits](iterator it) {
1281                        return format_uint&lt;3, Char&gt;(it, abs_value, num_digits);
1282                      });
1283    }
1284    enum { sep_size = 1 };
1285    void on_num() {
1286      std::string groups = grouping&lt;Char&gt;(locale);
1287      if (groups.empty()) return on_dec();
1288      auto sep = thousands_sep&lt;Char&gt;(locale);
1289      if (!sep) return on_dec();
1290      int num_digits = count_digits(abs_value);
1291      int size = num_digits, n = num_digits;
1292      std::string::const_iterator group = groups.cbegin();
1293      while (group != groups.cend() &amp;&amp; n &gt; *group &amp;&amp; *group &gt; 0 &amp;&amp;
1294             *group != max_value&lt;char&gt;()) {
1295        size += sep_size;
1296        n -= *group;
1297        ++group;
1298      }
1299      if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());
1300      char digits[40];
1301      format_decimal(digits, abs_value, num_digits);
1302      basic_memory_buffer&lt;Char&gt; buffer;
1303      size += static_cast&lt;int&gt;(prefix_size);
1304      const auto usize = to_unsigned(size);
1305      buffer.resize(usize);
1306      basic_string_view&lt;Char&gt; s(&amp;sep, sep_size);
1307      int digit_index = 0;
1308      group = groups.cbegin();
1309      auto p = buffer.data() + size;
1310      for (int i = num_digits - 1; i &gt;= 0; --i) {
1311        *--p = static_cast&lt;Char&gt;(digits[i]);
1312        if (*group &lt;= 0 || ++digit_index % *group != 0 ||
1313            *group == max_value&lt;char&gt;())
1314          continue;
1315        if (group + 1 != groups.cend()) {
1316          digit_index = 0;
1317          ++group;
1318        }
1319        p -= s.size();
1320        std::uninitialized_copy(s.data(), s.data() + s.size(),
1321                                make_checked(p, s.size()));
1322      }
1323      if (prefix_size != 0) p[-1] = static_cast&lt;Char&gt;(&#x27;-&#x27;);
1324      auto data = buffer.data();
1325      out = write_padded&lt;align::right&gt;(
1326          out, specs, usize, usize,
1327          [=](iterator it) { return copy_str&lt;Char&gt;(data, data + size, it); });
1328    }
1329    void on_chr() { *out++ = static_cast&lt;Char&gt;(abs_value); }
1330    FMT_NORETURN void on_error() {
1331      FMT_THROW(format_error(&quot;invalid type specifier&quot;));
1332    }
1333  };
1334  template &lt;typename Char, typename OutputIt&gt;
1335  OutputIt write_nonfinite(OutputIt out, bool isinf,
1336                           const basic_format_specs&lt;Char&gt;&amp; specs,
1337                           const float_specs&amp; fspecs) {
1338    auto str =
1339        isinf ? (fspecs.upper ? &quot;INF&quot; : &quot;inf&quot;) : (fspecs.upper ? &quot;NAN&quot; : &quot;nan&quot;);
1340    constexpr size_t str_size = 3;
1341    auto sign = fspecs.sign;
1342    auto size = str_size + (sign ? 1 : 0);
1343    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1344    return write_padded(out, specs, size, [=](iterator it) {
1345      if (sign) *it++ = static_cast&lt;Char&gt;(data::signs[sign]);
1346      return copy_str&lt;Char&gt;(str, str + str_size, it);
1347    });
1348  }
1349  struct big_decimal_fp {
1350    const char* significand;
1351    int significand_size;
1352    int exp;
1353  };
1354  template &lt;typename OutputIt, typename Char&gt;
1355  OutputIt write_float(OutputIt out, const big_decimal_fp&amp; fp, float_specs specs,
1356                       Char decimal_point) {
1357    const char* digits = fp.significand;
1358    const Char zero = static_cast&lt;Char&gt;(&#x27;0&#x27;);
1359    int output_exp = fp.exp + fp.significand_size - 1;
1360    auto use_exp_format = [=]() {
1361      if (specs.format == float_format::exp) return true;
1362      if (specs.format != float_format::general) return false;
1363      const int exp_lower = -4, exp_upper = 16;
1364      return output_exp &lt; exp_lower ||
1365             output_exp &gt;= (specs.precision &gt; 0 ? specs.precision : exp_upper);
1366    };
1367    if (use_exp_format()) {
1368      *out++ = static_cast&lt;Char&gt;(*digits);
1369      int num_zeros = specs.precision - fp.significand_size;
1370      if (fp.significand_size &gt; 1 || specs.showpoint) *out++ = decimal_point;
1371      out = copy_str&lt;Char&gt;(digits + 1, digits + fp.significand_size, out);
1372      if (num_zeros &gt; 0 &amp;&amp; specs.showpoint)
1373        out = std::fill_n(out, num_zeros, zero);
1374      *out++ = static_cast&lt;Char&gt;(specs.upper ? &#x27;E&#x27; : &#x27;e&#x27;);
1375      return write_exponent&lt;Char&gt;(output_exp, out);
1376    }
1377    int exp = fp.exp + fp.significand_size;
1378    if (fp.significand_size &lt;= exp) {
1379      out = copy_str&lt;Char&gt;(digits, digits + fp.significand_size, out);
1380      out = std::fill_n(out, exp - fp.significand_size, zero);
1381      if (specs.showpoint) {
1382        *out++ = decimal_point;
1383        int num_zeros = specs.precision - exp;
1384        if (num_zeros &lt;= 0) {
1385          if (specs.format != float_format::fixed) *out++ = zero;
1386          return out;
1387        }
1388  #ifdef FMT_FUZZ
1389        if (num_zeros &gt; 5000)
1390          throw std::runtime_error(&quot;fuzz mode - avoiding excessive cpu use&quot;);
1391  #endif
1392        out = std::fill_n(out, num_zeros, zero);
1393      }
1394    } else if (exp &gt; 0) {
1395      out = copy_str&lt;Char&gt;(digits, digits + exp, out);
1396      if (!specs.showpoint) {
1397        if (fp.significand_size != exp) *out++ = decimal_point;
1398        return copy_str&lt;Char&gt;(digits + exp, digits + fp.significand_size, out);
1399      }
1400      *out++ = decimal_point;
1401      out = copy_str&lt;Char&gt;(digits + exp, digits + fp.significand_size, out);
1402      if (specs.precision &gt; fp.significand_size)
1403        out = std::fill_n(out, specs.precision - fp.significand_size, zero);
1404    } else {
1405      *out++ = zero;
1406      int num_zeros = -exp;
1407      if (fp.significand_size == 0 &amp;&amp; specs.precision &gt;= 0 &amp;&amp;
1408          specs.precision &lt; num_zeros) {
1409        num_zeros = specs.precision;
1410      }
1411      if (num_zeros != 0 || fp.significand_size != 0 || specs.showpoint) {
1412        *out++ = decimal_point;
1413        out = std::fill_n(out, num_zeros, zero);
1414        out = copy_str&lt;Char&gt;(digits, digits + fp.significand_size, out);
1415      }
1416    }
1417    return out;
1418  }
1419  template &lt;typename OutputIt, typename Char&gt;
1420  OutputIt write_float(OutputIt out, const buffer&lt;char&gt;&amp; significand, int exp,
1421                       const basic_format_specs&lt;Char&gt;&amp; specs, float_specs fspecs,
1422                       Char decimal_point) {
1423    auto fp = big_decimal_fp{significand.data(),
1424                             static_cast&lt;int&gt;(significand.size()), exp};
1425    auto size =
1426        write_float(counting_iterator(), fp, fspecs, decimal_point).count();
1427    size += fspecs.sign ? 1 : 0;
1428    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1429    return write_padded&lt;align::right&gt;(out, specs, size, [&amp;](iterator it) {
1430      if (fspecs.sign) *it++ = static_cast&lt;Char&gt;(data::signs[fspecs.sign]);
1431      return write_float(it, fp, fspecs, decimal_point);
1432    });
1433  }
1434  template &lt;typename Char, typename OutputIt, typename T,
1435            FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
1436  OutputIt write(OutputIt out, T value, basic_format_specs&lt;Char&gt; specs,
1437                 locale_ref loc = {}) {
1438    if (const_check(!is_supported_floating_point(value))) return out;
1439    float_specs fspecs = parse_float_type_spec(specs);
1440    fspecs.sign = specs.sign;
1441    if (std::signbit(value)) {  
1442      fspecs.sign = sign::minus;
1443      value = -value;
1444    } else if (fspecs.sign == sign::minus) {
1445      fspecs.sign = sign::none;
1446    }
1447    if (!std::isfinite(value))
1448      return write_nonfinite(out, std::isinf(value), specs, fspecs);
1449    if (specs.align == align::numeric &amp;&amp; fspecs.sign) {
1450      auto it = reserve(out, 1);
1451      *it++ = static_cast&lt;Char&gt;(data::signs[fspecs.sign]);
1452      out = base_iterator(out, it);
1453      fspecs.sign = sign::none;
1454      if (specs.width != 0) --specs.width;
1455    }
1456    memory_buffer buffer;
1457    if (fspecs.format == float_format::hex) {
1458      if (fspecs.sign) buffer.push_back(data::signs[fspecs.sign]);
1459      snprintf_float(promote_float(value), specs.precision, fspecs, buffer);
1460      return write_bytes(out, {buffer.data(), buffer.size()}, specs);
1461    }
1462    int precision = specs.precision &gt;= 0 || !specs.type ? specs.precision : 6;
1463    if (fspecs.format == float_format::exp) {
1464      if (precision == max_value&lt;int&gt;())
1465        FMT_THROW(format_error(&quot;number is too big&quot;));
1466      else
1467        ++precision;
1468    }
1469    if (const_check(std::is_same&lt;T, float&gt;())) fspecs.binary32 = true;
1470    fspecs.use_grisu = is_fast_float&lt;T&gt;();
1471    int exp = format_float(promote_float(value), precision, fspecs, buffer);
1472    fspecs.precision = precision;
1473    Char point =
1474        fspecs.locale ? decimal_point&lt;Char&gt;(loc) : static_cast&lt;Char&gt;(&#x27;.&#x27;);
1475    return write_float(out, buffer, exp, specs, fspecs, point);
1476  }
1477  template &lt;
1478      typename Char, typename OutputIt, typename T,
1479      FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value&amp;&amp; is_fast_float&lt;T&gt;::value)&gt;
1480  OutputIt write(OutputIt out, T value) {
1481    if (const_check(!is_supported_floating_point(value))) return out;
1482    auto fspecs = float_specs();
1483    if (std::signbit(value)) {  
1484      fspecs.sign = sign::minus;
1485      value = -value;
1486    }
1487    auto specs = basic_format_specs&lt;Char&gt;();
1488    if (!std::isfinite(value))
1489      return write_nonfinite(out, std::isinf(value), specs, fspecs);
1490    using type = conditional_t&lt;std::is_same&lt;T, long double&gt;::value, double, T&gt;;
1491    auto dec = dragonbox::to_decimal(static_cast&lt;type&gt;(value));
1492    memory_buffer buf;
1493    write&lt;char&gt;(buffer_appender&lt;char&gt;(buf), dec.significand);
1494    return write_float(out, buf, dec.exponent, specs, fspecs,
1495                       static_cast&lt;Char&gt;(&#x27;.&#x27;));
1496  }
1497  template &lt;typename Char, typename OutputIt, typename T,
1498            FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value &amp;&amp;
1499                          !is_fast_float&lt;T&gt;::value)&gt;
1500  inline OutputIt write(OutputIt out, T value) {
1501    return write(out, value, basic_format_specs&lt;Char&gt;());
1502  }
1503  template &lt;typename Char, typename OutputIt&gt;
1504  OutputIt write_char(OutputIt out, Char value,
1505                      const basic_format_specs&lt;Char&gt;&amp; specs) {
1506    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1507    return write_padded(out, specs, 1, [=](iterator it) {
1508      *it++ = value;
1509      return it;
1510    });
1511  }
1512  template &lt;typename Char, typename OutputIt, typename UIntPtr&gt;
1513  OutputIt write_ptr(OutputIt out, UIntPtr value,
1514                     const basic_format_specs&lt;Char&gt;* specs) {
1515    int num_digits = count_digits&lt;4&gt;(value);
1516    auto size = to_unsigned(num_digits) + size_t(2);
1517    using iterator = remove_reference_t&lt;decltype(reserve(out, 0))&gt;;
1518    auto write = [=](iterator it) {
1519      *it++ = static_cast&lt;Char&gt;(&#x27;0&#x27;);
1520      *it++ = static_cast&lt;Char&gt;(&#x27;x&#x27;);
1521      return format_uint&lt;4, Char&gt;(it, value, num_digits);
1522    };
1523    return specs ? write_padded&lt;align::right&gt;(out, *specs, size, write)
1524                 : base_iterator(out, write(reserve(out, size)));
1525  }
1526  template &lt;typename T&gt; struct is_integral : std::is_integral&lt;T&gt; {};
1527  template &lt;&gt; struct is_integral&lt;int128_t&gt; : std::true_type {};
1528  template &lt;&gt; struct is_integral&lt;uint128_t&gt; : std::true_type {};
1529  template &lt;typename Char, typename OutputIt&gt;
1530  OutputIt write(OutputIt out, monostate) {
1531    FMT_ASSERT(false, &quot;&quot;);
1532    return out;
1533  }
1534  template &lt;typename Char, typename OutputIt,
1535            FMT_ENABLE_IF(!std::is_same&lt;Char, char&gt;::value)&gt;
1536  OutputIt write(OutputIt out, string_view value) {
1537    auto it = reserve(out, value.size());
1538    it = copy_str&lt;Char&gt;(value.begin(), value.end(), it);
1539    return base_iterator(out, it);
1540  }
1541  template &lt;typename Char, typename OutputIt&gt;
1542  OutputIt write(OutputIt out, basic_string_view&lt;Char&gt; value) {
1543    auto it = reserve(out, value.size());
1544    it = std::copy(value.begin(), value.end(), it);
1545    return base_iterator(out, it);
1546  }
1547  template &lt;typename Char&gt;
1548  buffer_appender&lt;Char&gt; write(buffer_appender&lt;Char&gt; out,
1549                              basic_string_view&lt;Char&gt; value) {
1550    get_container(out).append(value.begin(), value.end());
1551    return out;
1552  }
1553  template &lt;typename Char, typename OutputIt, typename T,
1554            FMT_ENABLE_IF(is_integral&lt;T&gt;::value &amp;&amp;
1555                          !std::is_same&lt;T, bool&gt;::value &amp;&amp;
1556                          !std::is_same&lt;T, Char&gt;::value)&gt;
1557  OutputIt write(OutputIt out, T value) {
1558    auto abs_value = static_cast&lt;uint32_or_64_or_128_t&lt;T&gt;&gt;(value);
1559    bool negative = is_negative(value);
1560    if (negative) abs_value = ~abs_value + 1;
1561    int num_digits = count_digits(abs_value);
1562    auto size = (negative ? 1 : 0) + static_cast&lt;size_t&gt;(num_digits);
1563    auto it = reserve(out, size);
1564    if (auto ptr = to_pointer&lt;Char&gt;(it, size)) {
1565      if (negative) *ptr++ = static_cast&lt;Char&gt;(&#x27;-&#x27;);
1566      format_decimal&lt;Char&gt;(ptr, abs_value, num_digits);
1567      return out;
1568    }
1569    if (negative) *it++ = static_cast&lt;Char&gt;(&#x27;-&#x27;);
1570    it = format_decimal&lt;Char&gt;(it, abs_value, num_digits).end;
1571    return base_iterator(out, it);
1572  }
1573  template &lt;typename Char, typename OutputIt&gt;
1574  OutputIt write(OutputIt out, bool value) {
1575    return write&lt;Char&gt;(out, string_view(value ? &quot;true&quot; : &quot;false&quot;));
1576  }
1577  template &lt;typename Char, typename OutputIt&gt;
1578  OutputIt write(OutputIt out, Char value) {
1579    auto it = reserve(out, 1);
1580    *it++ = value;
1581    return base_iterator(out, it);
1582  }
1583  template &lt;typename Char, typename OutputIt&gt;
1584  OutputIt write(OutputIt out, const Char* value) {
1585    if (!value) {
1586      FMT_THROW(format_error(&quot;string pointer is null&quot;));
1587    } else {
1588      auto length = std::char_traits&lt;Char&gt;::length(value);
1589      out = write(out, basic_string_view&lt;Char&gt;(value, length));
1590    }
1591    return out;
1592  }
1593  template &lt;typename Char, typename OutputIt&gt;
1594  OutputIt write(OutputIt out, const void* value) {
1595    return write_ptr&lt;Char&gt;(out, to_uintptr(value), nullptr);
1596  }
1597  template &lt;typename Char, typename OutputIt, typename T&gt;
1598  auto write(OutputIt out, const T&amp; value) -&gt; typename std::enable_if&lt;
1599      mapped_type_constant&lt;T, basic_format_context&lt;OutputIt, Char&gt;&gt;::value ==
1600          type::custom_type,
1601      OutputIt&gt;::type {
1602    using context_type = basic_format_context&lt;OutputIt, Char&gt;;
1603    using formatter_type =
1604        conditional_t&lt;has_formatter&lt;T, context_type&gt;::value,
1605                      typename context_type::template formatter_type&lt;T&gt;,
1606                      fallback_formatter&lt;T, Char&gt;&gt;;
1607    context_type ctx(out, {}, {});
1608    return formatter_type().format(value, ctx);
1609  }
1610  template &lt;typename OutputIt, typename Char&gt; struct default_arg_formatter {
1611    using context = basic_format_context&lt;OutputIt, Char&gt;;
1612    OutputIt out;
1613    basic_format_args&lt;context&gt; args;
1614    locale_ref loc;
1615    template &lt;typename T&gt; OutputIt operator()(T value) {
1616      return write&lt;Char&gt;(out, value);
1617    }
1618    OutputIt operator()(typename basic_format_arg&lt;context&gt;::handle handle) {
1619      basic_format_parse_context&lt;Char&gt; parse_ctx({});
1620      basic_format_context&lt;OutputIt, Char&gt; format_ctx(out, args, loc);
1621      handle.format(parse_ctx, format_ctx);
1622      return format_ctx.out();
1623    }
1624  };
1625  template &lt;typename OutputIt, typename Char,
1626            typename ErrorHandler = error_handler&gt;
1627  class arg_formatter_base {
1628   public:
1629    using iterator = OutputIt;
1630    using char_type = Char;
1631    using format_specs = basic_format_specs&lt;Char&gt;;
1632   private:
1633    iterator out_;
1634    locale_ref locale_;
1635    format_specs* specs_;
1636    auto reserve(size_t n) -&gt; decltype(detail::reserve(out_, n)) {
1637      return detail::reserve(out_, n);
1638    }
1639    using reserve_iterator = remove_reference_t&lt;decltype(
1640        detail::reserve(std::declval&lt;iterator&amp;&gt;(), 0))&gt;;
1641    template &lt;typename T&gt; void write_int(T value, const format_specs&amp; spec) {
1642      using uint_type = uint32_or_64_or_128_t&lt;T&gt;;
1643      int_writer&lt;iterator, Char, uint_type&gt; w(out_, locale_, value, spec);
1644      handle_int_type_spec(spec.type, w);
1645      out_ = w.out;
1646    }
1647    void write(char value) {
1648      auto&amp;&amp; it = reserve(1);
1649      *it++ = value;
1650    }
1651    template &lt;typename Ch, FMT_ENABLE_IF(std::is_same&lt;Ch, Char&gt;::value)&gt;
1652    void write(Ch value) {
1653      out_ = detail::write&lt;Char&gt;(out_, value);
1654    }
1655    void write(string_view value) {
1656      auto&amp;&amp; it = reserve(value.size());
1657      it = copy_str&lt;Char&gt;(value.begin(), value.end(), it);
1658    }
1659    void write(wstring_view value) {
1660      static_assert(std::is_same&lt;Char, wchar_t&gt;::value, &quot;&quot;);
1661      auto&amp;&amp; it = reserve(value.size());
1662      it = std::copy(value.begin(), value.end(), it);
1663    }
1664    template &lt;typename Ch&gt;
1665    void write(const Ch* s, size_t size, const format_specs&amp; specs) {
1666      auto width = specs.width != 0
1667                       ? count_code_points(basic_string_view&lt;Ch&gt;(s, size))
1668                       : 0;
1669      out_ = write_padded(out_, specs, size, width, [=](reserve_iterator it) {
1670        return copy_str&lt;Char&gt;(s, s + size, it);
1671      });
1672    }
1673    template &lt;typename Ch&gt;
1674    void write(basic_string_view&lt;Ch&gt; s, const format_specs&amp; specs = {}) {
1675      out_ = detail::write(out_, s, specs);
1676    }
1677    void write_pointer(const void* p) {
1678      out_ = write_ptr&lt;char_type&gt;(out_, to_uintptr(p), specs_);
1679    }
1680    struct char_spec_handler : ErrorHandler {
1681      arg_formatter_base&amp; formatter;
1682      Char value;
1683      char_spec_handler(arg_formatter_base&amp; f, Char val)
1684          : formatter(f), value(val) {}
1685      void on_int() {
1686        formatter.write_int(static_cast&lt;int&gt;(value), *formatter.specs_);
1687      }
1688      void on_char() {
1689        if (formatter.specs_)
1690          formatter.out_ = write_char(formatter.out_, value, *formatter.specs_);
1691        else
1692          formatter.write(value);
1693      }
1694    };
1695    struct cstring_spec_handler : error_handler {
1696      arg_formatter_base&amp; formatter;
1697      const Char* value;
1698      cstring_spec_handler(arg_formatter_base&amp; f, const Char* val)
1699          : formatter(f), value(val) {}
1700      void on_string() { formatter.write(value); }
1701      void on_pointer() { formatter.write_pointer(value); }
1702    };
1703   protected:
1704    iterator out() { return out_; }
1705    format_specs* specs() { return specs_; }
1706    void write(bool value) {
1707      if (specs_)
1708        write(string_view(value ? &quot;true&quot; : &quot;false&quot;), *specs_);
1709      else
1710        out_ = detail::write&lt;Char&gt;(out_, value);
1711    }
1712    void write(const Char* value) {
1713      if (!value) {
1714        FMT_THROW(format_error(&quot;string pointer is null&quot;));
1715      } else {
1716        auto length = std::char_traits&lt;char_type&gt;::length(value);
1717        basic_string_view&lt;char_type&gt; sv(value, length);
1718        specs_ ? write(sv, *specs_) : write(sv);
1719      }
1720    }
1721   public:
1722    arg_formatter_base(OutputIt out, format_specs* s, locale_ref loc)
1723        : out_(out), locale_(loc), specs_(s) {}
1724    iterator operator()(monostate) {
1725      FMT_ASSERT(false, &quot;invalid argument type&quot;);
1726      return out_;
1727    }
1728    template &lt;typename T, FMT_ENABLE_IF(is_integral&lt;T&gt;::value)&gt;
1729    FMT_INLINE iterator operator()(T value) {
1730      if (specs_)
1731        write_int(value, *specs_);
1732      else
1733        out_ = detail::write&lt;Char&gt;(out_, value);
1734      return out_;
1735    }
1736    iterator operator()(Char value) {
1737      handle_char_specs(specs_,
1738                        char_spec_handler(*this, static_cast&lt;Char&gt;(value)));
1739      return out_;
1740    }
1741    iterator operator()(bool value) {
1742      if (specs_ &amp;&amp; specs_-&gt;type) return (*this)(value ? 1 : 0);
1743      write(value != 0);
1744      return out_;
1745    }
1746    template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
1747    iterator operator()(T value) {
1748      auto specs = specs_ ? *specs_ : format_specs();
1749      if (const_check(is_supported_floating_point(value)))
1750        out_ = detail::write(out_, value, specs, locale_);
1751      else
1752        FMT_ASSERT(false, &quot;unsupported float argument type&quot;);
1753      return out_;
1754    }
1755    iterator operator()(const Char* value) {
1756      if (!specs_) return write(value), out_;
1757      handle_cstring_type_spec(specs_-&gt;type, cstring_spec_handler(*this, value));
1758      return out_;
1759    }
1760    iterator operator()(basic_string_view&lt;Char&gt; value) {
1761      if (specs_) {
1762        check_string_type_spec(specs_-&gt;type, error_handler());
1763        write(value, *specs_);
1764      } else {
1765        write(value);
1766      }
1767      return out_;
1768    }
1769    iterator operator()(const void* value) {
1770      if (specs_) check_pointer_type_spec(specs_-&gt;type, error_handler());
1771      write_pointer(value);
1772      return out_;
1773    }
1774  };
1775  template &lt;typename Char&gt; FMT_CONSTEXPR bool is_name_start(Char c) {
1776    return (&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;z&#x27;) || (&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;Z&#x27;) || &#x27;_&#x27; == c;
1777  }
1778  template &lt;typename Char, typename ErrorHandler&gt;
1779  FMT_CONSTEXPR int parse_nonnegative_int(const Char*&amp; begin, const Char* end,
1780                                          ErrorHandler&amp;&amp; eh) {
1781    FMT_ASSERT(begin != end &amp;&amp; &#x27;0&#x27; &lt;= *begin &amp;&amp; *begin &lt;= &#x27;9&#x27;, &quot;&quot;);
1782    unsigned value = 0;
1783    constexpr unsigned max_int = max_value&lt;int&gt;();
1784    unsigned big = max_int / 10;
1785    do {
1786      if (value &gt; big) {
1787        value = max_int + 1;
1788        break;
1789      }
1790      value = value * 10 + unsigned(*begin - &#x27;0&#x27;);
1791      ++begin;
1792    } while (begin != end &amp;&amp; &#x27;0&#x27; &lt;= *begin &amp;&amp; *begin &lt;= &#x27;9&#x27;);
1793    if (value &gt; max_int) eh.on_error(&quot;number is too big&quot;);
1794    return static_cast&lt;int&gt;(value);
1795  }
1796  template &lt;typename Context&gt; class custom_formatter {
1797   private:
1798    using char_type = typename Context::char_type;
1799    basic_format_parse_context&lt;char_type&gt;&amp; parse_ctx_;
1800    Context&amp; ctx_;
1801   public:
1802    explicit custom_formatter(basic_format_parse_context&lt;char_type&gt;&amp; parse_ctx,
1803                              Context&amp; ctx)
1804        : parse_ctx_(parse_ctx), ctx_(ctx) {}
1805    bool operator()(typename basic_format_arg&lt;Context&gt;::handle h) const {
1806      h.format(parse_ctx_, ctx_);
1807      return true;
1808    }
1809    template &lt;typename T&gt; bool operator()(T) const { return false; }
1810  };
1811  template &lt;typename T&gt;
1812  using is_integer =
1813      bool_constant&lt;is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp;
1814                    !std::is_same&lt;T, char&gt;::value &amp;&amp;
1815                    !std::is_same&lt;T, wchar_t&gt;::value&gt;;
1816  template &lt;typename ErrorHandler&gt; class width_checker {
1817   public:
1818    explicit FMT_CONSTEXPR width_checker(ErrorHandler&amp; eh) : handler_(eh) {}
1819    template &lt;typename T, FMT_ENABLE_IF(is_integer&lt;T&gt;::value)&gt;
1820    FMT_CONSTEXPR unsigned long long operator()(T value) {
1821      if (is_negative(value)) handler_.on_error(&quot;negative width&quot;);
1822      return static_cast&lt;unsigned long long&gt;(value);
1823    }
1824    template &lt;typename T, FMT_ENABLE_IF(!is_integer&lt;T&gt;::value)&gt;
1825    FMT_CONSTEXPR unsigned long long operator()(T) {
1826      handler_.on_error(&quot;width is not integer&quot;);
1827      return 0;
1828    }
1829   private:
1830    ErrorHandler&amp; handler_;
1831  };
1832  template &lt;typename ErrorHandler&gt; class precision_checker {
1833   public:
1834    explicit FMT_CONSTEXPR precision_checker(ErrorHandler&amp; eh) : handler_(eh) {}
1835    template &lt;typename T, FMT_ENABLE_IF(is_integer&lt;T&gt;::value)&gt;
1836    FMT_CONSTEXPR unsigned long long operator()(T value) {
1837      if (is_negative(value)) handler_.on_error(&quot;negative precision&quot;);
1838      return static_cast&lt;unsigned long long&gt;(value);
1839    }
1840    template &lt;typename T, FMT_ENABLE_IF(!is_integer&lt;T&gt;::value)&gt;
1841    FMT_CONSTEXPR unsigned long long operator()(T) {
1842      handler_.on_error(&quot;precision is not integer&quot;);
1843      return 0;
1844    }
1845   private:
1846    ErrorHandler&amp; handler_;
1847  };
1848  template &lt;typename Char&gt; class specs_setter {
1849   public:
1850    explicit FMT_CONSTEXPR specs_setter(basic_format_specs&lt;Char&gt;&amp; specs)
1851        : specs_(specs) {}
1852    FMT_CONSTEXPR specs_setter(const specs_setter&amp; other)
1853        : specs_(other.specs_) {}
1854    FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
1855    FMT_CONSTEXPR void on_fill(basic_string_view&lt;Char&gt; fill) {
1856      specs_.fill = fill;
1857    }
1858    FMT_CONSTEXPR void on_plus() { specs_.sign = sign::plus; }
1859    FMT_CONSTEXPR void on_minus() { specs_.sign = sign::minus; }
1860    FMT_CONSTEXPR void on_space() { specs_.sign = sign::space; }
1861    FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
1862    FMT_CONSTEXPR void on_zero() {
1863      specs_.align = align::numeric;
1864      specs_.fill[0] = Char(&#x27;0&#x27;);
1865    }
1866    FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
1867    FMT_CONSTEXPR void on_precision(int precision) {
1868      specs_.precision = precision;
1869    }
1870    FMT_CONSTEXPR void end_precision() {}
1871    FMT_CONSTEXPR void on_type(Char type) {
1872      specs_.type = static_cast&lt;char&gt;(type);
1873    }
1874   protected:
1875    basic_format_specs&lt;Char&gt;&amp; specs_;
1876  };
1877  template &lt;typename ErrorHandler&gt; class numeric_specs_checker {
1878   public:
1879    FMT_CONSTEXPR numeric_specs_checker(ErrorHandler&amp; eh, detail::type arg_type)
1880        : error_handler_(eh), arg_type_(arg_type) {}
1881    FMT_CONSTEXPR void require_numeric_argument() {
1882      if (!is_arithmetic_type(arg_type_))
1883        error_handler_.on_error(&quot;format specifier requires numeric argument&quot;);
1884    }
1885    FMT_CONSTEXPR void check_sign() {
1886      require_numeric_argument();
1887      if (is_integral_type(arg_type_) &amp;&amp; arg_type_ != type::int_type &amp;&amp;
1888          arg_type_ != type::long_long_type &amp;&amp; arg_type_ != type::char_type) {
1889        error_handler_.on_error(&quot;format specifier requires signed argument&quot;);
1890      }
1891    }
1892    FMT_CONSTEXPR void check_precision() {
1893      if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
1894        error_handler_.on_error(&quot;precision not allowed for this argument type&quot;);
1895    }
1896   private:
1897    ErrorHandler&amp; error_handler_;
1898    detail::type arg_type_;
1899  };
1900  template &lt;typename Handler&gt; class specs_checker : public Handler {
1901   private:
1902    numeric_specs_checker&lt;Handler&gt; checker_;
1903    FMT_CONSTEXPR Handler&amp; error_handler() { return *this; }
1904   public:
1905    FMT_CONSTEXPR specs_checker(const Handler&amp; handler, detail::type arg_type)
1906        : Handler(handler), checker_(error_handler(), arg_type) {}
1907    FMT_CONSTEXPR specs_checker(const specs_checker&amp; other)
1908        : Handler(other), checker_(error_handler(), other.arg_type_) {}
1909    FMT_CONSTEXPR void on_align(align_t align) {
1910      if (align == align::numeric) checker_.require_numeric_argument();
1911      Handler::on_align(align);
1912    }
1913    FMT_CONSTEXPR void on_plus() {
1914      checker_.check_sign();
1915      Handler::on_plus();
1916    }
1917    FMT_CONSTEXPR void on_minus() {
1918      checker_.check_sign();
1919      Handler::on_minus();
1920    }
1921    FMT_CONSTEXPR void on_space() {
1922      checker_.check_sign();
1923      Handler::on_space();
1924    }
1925    FMT_CONSTEXPR void on_hash() {
1926      checker_.require_numeric_argument();
1927      Handler::on_hash();
1928    }
1929    FMT_CONSTEXPR void on_zero() {
1930      checker_.require_numeric_argument();
1931      Handler::on_zero();
1932    }
1933    FMT_CONSTEXPR void end_precision() { checker_.check_precision(); }
1934  };
1935  template &lt;template &lt;typename&gt; class Handler, typename FormatArg,
1936            typename ErrorHandler&gt;
1937  FMT_CONSTEXPR int get_dynamic_spec(FormatArg arg, ErrorHandler eh) {
1938    unsigned long long value = visit_format_arg(Handler&lt;ErrorHandler&gt;(eh), arg);
1939    if (value &gt; to_unsigned(max_value&lt;int&gt;())) eh.on_error(&quot;number is too big&quot;);
1940    return static_cast&lt;int&gt;(value);
1941  }
1942  struct auto_id {};
1943  template &lt;typename Context, typename ID&gt;
1944  FMT_CONSTEXPR typename Context::format_arg get_arg(Context&amp; ctx, ID id) {
1945    auto arg = ctx.arg(id);
1946    if (!arg) ctx.on_error(&quot;argument not found&quot;);
1947    return arg;
1948  }
1949  template &lt;typename ParseContext, typename Context&gt;
1950  class specs_handler : public specs_setter&lt;typename Context::char_type&gt; {
1951   public:
1952    using char_type = typename Context::char_type;
1953    FMT_CONSTEXPR specs_handler(basic_format_specs&lt;char_type&gt;&amp; specs,
1954                                ParseContext&amp; parse_ctx, Context&amp; ctx)
1955        : specs_setter&lt;char_type&gt;(specs),
1956          parse_context_(parse_ctx),
1957          context_(ctx) {}
1958    template &lt;typename Id&gt; FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
1959      this-&gt;specs_.width = get_dynamic_spec&lt;width_checker&gt;(
1960          get_arg(arg_id), context_.error_handler());
1961    }
1962    template &lt;typename Id&gt; FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
1963      this-&gt;specs_.precision = get_dynamic_spec&lt;precision_checker&gt;(
1964          get_arg(arg_id), context_.error_handler());
1965    }
1966    void on_error(const char* message) { context_.on_error(message); }
1967   private:
1968    using format_arg = typename Context::format_arg;
1969    FMT_CONSTEXPR format_arg get_arg(auto_id) {
1970      return detail::get_arg(context_, parse_context_.next_arg_id());
1971    }
1972    FMT_CONSTEXPR format_arg get_arg(int arg_id) {
1973      parse_context_.check_arg_id(arg_id);
1974      return detail::get_arg(context_, arg_id);
1975    }
1976    FMT_CONSTEXPR format_arg get_arg(basic_string_view&lt;char_type&gt; arg_id) {
1977      parse_context_.check_arg_id(arg_id);
1978      return detail::get_arg(context_, arg_id);
1979    }
1980    ParseContext&amp; parse_context_;
1981    Context&amp; context_;
1982  };
1983  enum class arg_id_kind { none, index, name };
1984  template &lt;typename Char&gt; struct arg_ref {
1985    FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
1986    FMT_CONSTEXPR explicit arg_ref(int index)
1987        : kind(arg_id_kind::index), val(index) {}
1988    FMT_CONSTEXPR explicit arg_ref(basic_string_view&lt;Char&gt; name)
1989        : kind(arg_id_kind::name), val(name) {}
1990    FMT_CONSTEXPR arg_ref&amp; operator=(int idx) {
1991      kind = arg_id_kind::index;
1992      val.index = idx;
1993      return *this;
1994    }
1995    arg_id_kind kind;
1996    union value {
1997      FMT_CONSTEXPR value(int id = 0) : index{id} {}
1998      FMT_CONSTEXPR value(basic_string_view&lt;Char&gt; n) : name(n) {}
1999      int index;
2000      basic_string_view&lt;Char&gt; name;
2001    } val;
2002  };
2003  template &lt;typename Char&gt;
2004  struct dynamic_format_specs : basic_format_specs&lt;Char&gt; {
2005    arg_ref&lt;Char&gt; width_ref;
2006    arg_ref&lt;Char&gt; precision_ref;
2007  };
2008  template &lt;typename ParseContext&gt;
2009  class dynamic_specs_handler
2010      : public specs_setter&lt;typename ParseContext::char_type&gt; {
2011   public:
2012    using char_type = typename ParseContext::char_type;
2013    FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs&lt;char_type&gt;&amp; specs,
2014                                        ParseContext&amp; ctx)
2015        : specs_setter&lt;char_type&gt;(specs), specs_(specs), context_(ctx) {}
2016    FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler&amp; other)
2017        : specs_setter&lt;char_type&gt;(other),
2018          specs_(other.specs_),
2019          context_(other.context_) {}
2020    template &lt;typename Id&gt; FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
2021      specs_.width_ref = make_arg_ref(arg_id);
2022    }
2023    template &lt;typename Id&gt; FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
2024      specs_.precision_ref = make_arg_ref(arg_id);
2025    }
2026    FMT_CONSTEXPR void on_error(const char* message) {
2027      context_.on_error(message);
2028    }
2029   private:
2030    using arg_ref_type = arg_ref&lt;char_type&gt;;
2031    FMT_CONSTEXPR arg_ref_type make_arg_ref(int arg_id) {
2032      context_.check_arg_id(arg_id);
2033      return arg_ref_type(arg_id);
2034    }
2035    FMT_CONSTEXPR arg_ref_type make_arg_ref(auto_id) {
2036      return arg_ref_type(context_.next_arg_id());
2037    }
2038    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view&lt;char_type&gt; arg_id) {
2039      context_.check_arg_id(arg_id);
2040      basic_string_view&lt;char_type&gt; format_str(
2041          context_.begin(), to_unsigned(context_.end() - context_.begin()));
2042      return arg_ref_type(arg_id);
2043    }
2044    dynamic_format_specs&lt;char_type&gt;&amp; specs_;
2045    ParseContext&amp; context_;
2046  };
2047  template &lt;typename Char, typename IDHandler&gt;
2048  FMT_CONSTEXPR const Char* parse_arg_id(const Char* begin, const Char* end,
2049                                         IDHandler&amp;&amp; handler) {
2050    FMT_ASSERT(begin != end, &quot;&quot;);
2051    Char c = *begin;
2052    if (c == &#x27;}&#x27; || c == &#x27;:&#x27;) {
2053      handler();
2054      return begin;
2055    }
2056    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) {
2057      int index = 0;
2058      if (c != &#x27;0&#x27;)
2059        index = parse_nonnegative_int(begin, end, handler);
2060      else
2061        ++begin;
2062      if (begin == end || (*begin != &#x27;}&#x27; &amp;&amp; *begin != &#x27;:&#x27;))
2063        handler.on_error(&quot;invalid format string&quot;);
2064      else
2065        handler(index);
2066      return begin;
2067    }
2068    if (!is_name_start(c)) {
2069      handler.on_error(&quot;invalid format string&quot;);
2070      return begin;
2071    }
2072    auto it = begin;
2073    do {
2074      ++it;
2075    } while (it != end &amp;&amp; (is_name_start(c = *it) || (&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;)));
2076    handler(basic_string_view&lt;Char&gt;(begin, to_unsigned(it - begin)));
2077    return it;
2078  }
2079  template &lt;typename SpecHandler, typename Char&gt; struct width_adapter {
2080    explicit FMT_CONSTEXPR width_adapter(SpecHandler&amp; h) : handler(h) {}
2081    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
2082    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
2083    FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
2084      handler.on_dynamic_width(id);
2085    }
2086    FMT_CONSTEXPR void on_error(const char* message) {
2087      handler.on_error(message);
2088    }
2089    SpecHandler&amp; handler;
2090  };
2091  template &lt;typename SpecHandler, typename Char&gt; struct precision_adapter {
2092    explicit FMT_CONSTEXPR precision_adapter(SpecHandler&amp; h) : handler(h) {}
2093    FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
2094    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
2095    FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
2096      handler.on_dynamic_precision(id);
2097    }
2098    FMT_CONSTEXPR void on_error(const char* message) {
2099      handler.on_error(message);
2100    }
2101    SpecHandler&amp; handler;
2102  };
2103  template &lt;typename Char&gt;
2104  FMT_CONSTEXPR const Char* next_code_point(const Char* begin, const Char* end) {
2105    if (const_check(sizeof(Char) != 1) || (*begin &amp; 0x80) == 0) return begin + 1;
2106    do {
2107      ++begin;
2108    } while (begin != end &amp;&amp; (*begin &amp; 0xc0) == 0x80);
2109    return begin;
2110  }
2111  template &lt;typename Char, typename Handler&gt;
2112  FMT_CONSTEXPR const Char* parse_align(const Char* begin, const Char* end,
2113                                        Handler&amp;&amp; handler) {
2114    FMT_ASSERT(begin != end, &quot;&quot;);
2115    auto align = align::none;
2116    auto p = next_code_point(begin, end);
2117    if (p == end) p = begin;
2118    for (;;) {
2119      switch (static_cast&lt;int&gt;(*p)) {
2120      case &#x27;&lt;&#x27;:
2121        align = align::left;
2122        break;
2123      case &#x27;&gt;&#x27;:
2124        align = align::right;
2125        break;
2126  #if FMT_DEPRECATED_NUMERIC_ALIGN
2127      case &#x27;=&#x27;:
2128        align = align::numeric;
2129        break;
2130  #endif
2131      case &#x27;^&#x27;:
2132        align = align::center;
2133        break;
2134      }
2135      if (align != align::none) {
2136        if (p != begin) {
2137          auto c = *begin;
2138          if (c == &#x27;{&#x27;)
2139            return handler.on_error(&quot;invalid fill character &#x27;{&#x27;&quot;), begin;
2140          handler.on_fill(basic_string_view&lt;Char&gt;(begin, to_unsigned(p - begin)));
2141          begin = p + 1;
2142        } else
2143          ++begin;
2144        handler.on_align(align);
2145        break;
2146      } else if (p == begin) {
2147        break;
2148      }
2149      p = begin;
2150    }
2151    return begin;
2152  }
2153  template &lt;typename Char, typename Handler&gt;
2154  FMT_CONSTEXPR const Char* parse_width(const Char* begin, const Char* end,
2155                                        Handler&amp;&amp; handler) {
2156    FMT_ASSERT(begin != end, &quot;&quot;);
2157    if (&#x27;0&#x27; &lt;= *begin &amp;&amp; *begin &lt;= &#x27;9&#x27;) {
2158      handler.on_width(parse_nonnegative_int(begin, end, handler));
2159    } else if (*begin == &#x27;{&#x27;) {
2160      ++begin;
2161      if (begin != end)
2162        begin = parse_arg_id(begin, end, width_adapter&lt;Handler, Char&gt;(handler));
2163      if (begin == end || *begin != &#x27;}&#x27;)
2164        return handler.on_error(&quot;invalid format string&quot;), begin;
2165      ++begin;
2166    }
2167    return begin;
2168  }
2169  template &lt;typename Char, typename Handler&gt;
2170  FMT_CONSTEXPR const Char* parse_precision(const Char* begin, const Char* end,
2171                                            Handler&amp;&amp; handler) {
2172    ++begin;
2173    auto c = begin != end ? *begin : Char();
2174    if (&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;) {
2175      handler.on_precision(parse_nonnegative_int(begin, end, handler));
2176    } else if (c == &#x27;{&#x27;) {
2177      ++begin;
2178      if (begin != end) {
2179        begin =
2180            parse_arg_id(begin, end, precision_adapter&lt;Handler, Char&gt;(handler));
2181      }
2182      if (begin == end || *begin++ != &#x27;}&#x27;)
2183        return handler.on_error(&quot;invalid format string&quot;), begin;
2184    } else {
2185      return handler.on_error(&quot;missing precision specifier&quot;), begin;
2186    }
2187    handler.end_precision();
2188    return begin;
2189  }
2190  template &lt;typename Char, typename SpecHandler&gt;
2191  FMT_CONSTEXPR const Char* parse_format_specs(const Char* begin, const Char* end,
2192                                               SpecHandler&amp;&amp; handler) {
2193    if (begin == end || *begin == &#x27;}&#x27;) return begin;
2194    begin = parse_align(begin, end, handler);
2195    if (begin == end) return begin;
2196    switch (static_cast&lt;char&gt;(*begin)) {
2197    case &#x27;+&#x27;:
2198      handler.on_plus();
2199      ++begin;
2200      break;
2201    case &#x27;-&#x27;:
2202      handler.on_minus();
2203      ++begin;
2204      break;
2205    case &#x27; &#x27;:
2206      handler.on_space();
2207      ++begin;
2208      break;
2209    }
2210    if (begin == end) return begin;
2211    if (*begin == &#x27;#&#x27;) {
2212      handler.on_hash();
2213      if (++begin == end) return begin;
2214    }
2215    if (*begin == &#x27;0&#x27;) {
2216      handler.on_zero();
2217      if (++begin == end) return begin;
2218    }
2219    begin = parse_width(begin, end, handler);
2220    if (begin == end) return begin;
2221    if (*begin == &#x27;.&#x27;) {
2222      begin = parse_precision(begin, end, handler);
2223    }
2224    if (begin != end &amp;&amp; *begin != &#x27;}&#x27;) handler.on_type(*begin++);
2225    return begin;
2226  }
2227  template &lt;bool IS_CONSTEXPR, typename T, typename Ptr = const T*&gt;
2228  FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr&amp; out) {
2229    for (out = first; out != last; ++out) {
2230      if (*out == value) return true;
2231    }
2232    return false;
2233  }
2234  template &lt;&gt;
2235  inline bool find&lt;false, char&gt;(const char* first, const char* last, char value,
2236                                const char*&amp; out) {
2237    out = static_cast&lt;const char*&gt;(
2238        std::memchr(first, value, detail::to_unsigned(last - first)));
2239    return out != nullptr;
2240  }
2241  template &lt;typename Handler, typename Char&gt; struct id_adapter {
2242    Handler&amp; handler;
2243    int arg_id;
2244    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
2245    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
2246    FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
2247      arg_id = handler.on_arg_id(id);
2248    }
2249    FMT_CONSTEXPR void on_error(const char* message) {
2250      handler.on_error(message);
2251    }
2252  };
2253  template &lt;typename Char, typename Handler&gt;
2254  FMT_CONSTEXPR const Char* parse_replacement_field(const Char* begin,
2255                                                    const Char* end,
2256                                                    Handler&amp;&amp; handler) {
2257    ++begin;
2258    if (begin == end) return handler.on_error(&quot;invalid format string&quot;), end;
2259    if (static_cast&lt;char&gt;(*begin) == &#x27;}&#x27;) {
2260      handler.on_replacement_field(handler.on_arg_id(), begin);
2261    } else if (*begin == &#x27;{&#x27;) {
2262      handler.on_text(begin, begin + 1);
2263    } else {
2264      auto adapter = id_adapter&lt;Handler, Char&gt;{handler, 0};
2265      begin = parse_arg_id(begin, end, adapter);
2266      Char c = begin != end ? *begin : Char();
2267      if (c == &#x27;}&#x27;) {
2268        handler.on_replacement_field(adapter.arg_id, begin);
2269      } else if (c == &#x27;:&#x27;) {
2270        begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
2271        if (begin == end || *begin != &#x27;}&#x27;)
2272          return handler.on_error(&quot;unknown format specifier&quot;), end;
2273      } else {
2274        return handler.on_error(&quot;missing &#x27;}&#x27; in format string&quot;), end;
2275      }
2276    }
2277    return begin + 1;
2278  }
2279  template &lt;bool IS_CONSTEXPR, typename Char, typename Handler&gt;
2280  FMT_CONSTEXPR_DECL FMT_INLINE void parse_format_string(
2281      basic_string_view&lt;Char&gt; format_str, Handler&amp;&amp; handler) {
2282    auto begin = format_str.data();
2283    auto end = begin + format_str.size();
2284    if (end - begin &lt; 32) {
2285      const Char* p = begin;
2286      while (p != end) {
2287        auto c = *p++;
2288        if (c == &#x27;{&#x27;) {
2289          handler.on_text(begin, p - 1);
2290          begin = p = parse_replacement_field(p - 1, end, handler);
2291        } else if (c == &#x27;}&#x27;) {
2292          if (p == end || *p != &#x27;}&#x27;)
2293            return handler.on_error(&quot;unmatched &#x27;}&#x27; in format string&quot;);
2294          handler.on_text(begin, p);
2295          begin = ++p;
2296        }
2297      }
2298      handler.on_text(begin, end);
2299      return;
2300    }
2301    struct writer {
2302      FMT_CONSTEXPR void operator()(const Char* pbegin, const Char* pend) {
2303        if (pbegin == pend) return;
2304        for (;;) {
2305          const Char* p = nullptr;
2306          if (!find&lt;IS_CONSTEXPR&gt;(pbegin, pend, &#x27;}&#x27;, p))
2307            return handler_.on_text(pbegin, pend);
2308          ++p;
2309          if (p == pend || *p != &#x27;}&#x27;)
2310            return handler_.on_error(&quot;unmatched &#x27;}&#x27; in format string&quot;);
2311          handler_.on_text(pbegin, p);
2312          pbegin = p + 1;
2313        }
2314      }
2315      Handler&amp; handler_;
2316    } write{handler};
2317    while (begin != end) {
2318      const Char* p = begin;
2319      if (*begin != &#x27;{&#x27; &amp;&amp; !find&lt;IS_CONSTEXPR&gt;(begin + 1, end, &#x27;{&#x27;, p))
2320        return write(begin, end);
2321      write(begin, p);
2322      begin = parse_replacement_field(p, end, handler);
2323    }
2324  }
2325  template &lt;typename T, typename ParseContext&gt;
2326  FMT_CONSTEXPR const typename ParseContext::char_type* parse_format_specs(
2327      ParseContext&amp; ctx) {
2328    using char_type = typename ParseContext::char_type;
2329    using context = buffer_context&lt;char_type&gt;;
2330    using mapped_type =
2331        conditional_t&lt;detail::mapped_type_constant&lt;T, context&gt;::value !=
2332                          type::custom_type,
2333                      decltype(arg_mapper&lt;context&gt;().map(std::declval&lt;T&gt;())), T&gt;;
2334    auto f = conditional_t&lt;has_formatter&lt;mapped_type, context&gt;::value,
2335                           formatter&lt;mapped_type, char_type&gt;,
2336                           detail::fallback_formatter&lt;T, char_type&gt;&gt;();
2337    return f.parse(ctx);
2338  }
2339  template &lt;typename ArgFormatter, typename Char, typename Context&gt;
2340  struct format_handler : detail::error_handler {
2341    basic_format_parse_context&lt;Char&gt; parse_context;
2342    Context context;
2343    format_handler(typename ArgFormatter::iterator out,
2344                   basic_string_view&lt;Char&gt; str,
2345                   basic_format_args&lt;Context&gt; format_args, detail::locale_ref loc)
2346        : parse_context(str), context(out, format_args, loc) {}
2347    void on_text(const Char* begin, const Char* end) {
2348      auto size = to_unsigned(end - begin);
2349      auto out = context.out();
2350      auto&amp;&amp; it = reserve(out, size);
2351      it = std::copy_n(begin, size, it);
2352      context.advance_to(out);
2353    }
2354    int on_arg_id() { return parse_context.next_arg_id(); }
2355    int on_arg_id(int id) { return parse_context.check_arg_id(id), id; }
2356    int on_arg_id(basic_string_view&lt;Char&gt; id) {
2357      int arg_id = context.arg_id(id);
2358      if (arg_id &lt; 0) on_error(&quot;argument not found&quot;);
2359      return arg_id;
2360    }
2361    FMT_INLINE void on_replacement_field(int id, const Char*) {
2362      auto arg = get_arg(context, id);
2363      context.advance_to(visit_format_arg(
2364          default_arg_formatter&lt;typename ArgFormatter::iterator, Char&gt;{
2365              context.out(), context.args(), context.locale()},
2366          arg));
2367    }
2368    const Char* on_format_specs(int id, const Char* begin, const Char* end) {
2369      advance_to(parse_context, begin);
2370      auto arg = get_arg(context, id);
2371      custom_formatter&lt;Context&gt; f(parse_context, context);
2372      if (visit_format_arg(f, arg)) return parse_context.begin();
2373      basic_format_specs&lt;Char&gt; specs;
2374      using parse_context_t = basic_format_parse_context&lt;Char&gt;;
2375      specs_checker&lt;specs_handler&lt;parse_context_t, Context&gt;&gt; handler(
2376          specs_handler&lt;parse_context_t, Context&gt;(specs, parse_context, context),
2377          arg.type());
2378      begin = parse_format_specs(begin, end, handler);
2379      if (begin == end || *begin != &#x27;}&#x27;) on_error(&quot;missing &#x27;}&#x27; in format string&quot;);
2380      advance_to(parse_context, begin);
2381      context.advance_to(
2382          visit_format_arg(ArgFormatter(context, &amp;parse_context, &amp;specs), arg));
2383      return begin;
2384    }
2385  };
2386  template &lt;typename Char, typename ErrorHandler = error_handler&gt;
2387  class compile_parse_context
2388      : public basic_format_parse_context&lt;Char, ErrorHandler&gt; {
2389   private:
2390    int num_args_;
2391    using base = basic_format_parse_context&lt;Char, ErrorHandler&gt;;
2392   public:
2393    explicit FMT_CONSTEXPR compile_parse_context(
2394        basic_string_view&lt;Char&gt; format_str, int num_args = max_value&lt;int&gt;(),
2395        ErrorHandler eh = {})
2396        : base(format_str, eh), num_args_(num_args) {}
2397    FMT_CONSTEXPR int next_arg_id() {
2398      int id = base::next_arg_id();
2399      if (id &gt;= num_args_) this-&gt;on_error(&quot;argument not found&quot;);
2400      return id;
2401    }
2402    FMT_CONSTEXPR void check_arg_id(int id) {
2403      base::check_arg_id(id);
2404      if (id &gt;= num_args_) this-&gt;on_error(&quot;argument not found&quot;);
2405    }
2406    using base::check_arg_id;
2407  };
2408  template &lt;typename Char, typename ErrorHandler, typename... Args&gt;
2409  class format_string_checker {
2410   public:
2411    explicit FMT_CONSTEXPR format_string_checker(
2412        basic_string_view&lt;Char&gt; format_str, ErrorHandler eh)
2413        : context_(format_str, num_args, eh),
2414          parse_funcs_{&amp;parse_format_specs&lt;Args, parse_context_type&gt;...} {}
2415    FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
2416    FMT_CONSTEXPR int on_arg_id() { return context_.next_arg_id(); }
2417    FMT_CONSTEXPR int on_arg_id(int id) { return context_.check_arg_id(id), id; }
2418    FMT_CONSTEXPR int on_arg_id(basic_string_view&lt;Char&gt;) {
2419      on_error(&quot;compile-time checks don&#x27;t support named arguments&quot;);
2420      return 0;
2421    }
2422    FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
2423    FMT_CONSTEXPR const Char* on_format_specs(int id, const Char* begin,
2424                                              const Char*) {
2425      advance_to(context_, begin);
2426      return id &lt; num_args ? parse_funcs_[id](context_) : begin;
2427    }
2428    FMT_CONSTEXPR void on_error(const char* message) {
2429      context_.on_error(message);
2430    }
2431   private:
2432    using parse_context_type = compile_parse_context&lt;Char, ErrorHandler&gt;;
2433    enum { num_args = sizeof...(Args) };
2434    using parse_func = const Char* (*)(parse_context_type&amp;);
2435    parse_context_type context_;
2436    parse_func parse_funcs_[num_args &gt; 0 ? num_args : 1];
2437  };
2438  template &lt;typename Char, size_t N&gt;
2439  FMT_CONSTEXPR basic_string_view&lt;Char&gt; compile_string_to_view(
2440      const Char (&amp;s)[N]) {
2441    return {s,
2442            N - ((std::char_traits&lt;Char&gt;::to_int_type(s[N - 1]) == 0) ? 1 : 0)};
2443  }
2444  template &lt;typename Char&gt;
2445  FMT_CONSTEXPR basic_string_view&lt;Char&gt; compile_string_to_view(
2446      const std_string_view&lt;Char&gt;&amp; s) {
2447    return {s.data(), s.size()};
2448  }
2449  #define FMT_STRING_IMPL(s, base)                                  \
2450    [] {                                                            \
2451            \
2452      struct FMT_COMPILE_STRING : base {                            \
2453        using char_type = fmt::remove_cvref_t&lt;decltype(s[0])&gt;;      \
2454        FMT_MAYBE_UNUSED FMT_CONSTEXPR                              \
2455        operator fmt::basic_string_view&lt;char_type&gt;() const {        \
2456          return fmt::detail::compile_string_to_view&lt;char_type&gt;(s); \
2457        }                                                           \
2458      };                                                            \
2459      return FMT_COMPILE_STRING();                                  \
2460    }()
2461  #define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::compile_string)
2462  template &lt;typename... Args, typename S,
2463            enable_if_t&lt;(is_compile_string&lt;S&gt;::value), int&gt;&gt;
2464  void check_format_string(S format_str) {
2465    FMT_CONSTEXPR_DECL auto s = to_string_view(format_str);
2466    using checker = format_string_checker&lt;typename S::char_type, error_handler,
2467                                          remove_cvref_t&lt;Args&gt;...&gt;;
2468    FMT_CONSTEXPR_DECL bool invalid_format =
2469        (parse_format_string&lt;true&gt;(s, checker(s, {})), true);
2470    (void)invalid_format;
2471  }
2472  template &lt;template &lt;typename&gt; class Handler, typename Context&gt;
2473  void handle_dynamic_spec(int&amp; value, arg_ref&lt;typename Context::char_type&gt; ref,
2474                           Context&amp; ctx) {
2475    switch (ref.kind) {
2476    case arg_id_kind::none:
2477      break;
2478    case arg_id_kind::index:
2479      value = detail::get_dynamic_spec&lt;Handler&gt;(ctx.arg(ref.val.index),
2480                                                ctx.error_handler());
2481      break;
2482    case arg_id_kind::name:
2483      value = detail::get_dynamic_spec&lt;Handler&gt;(ctx.arg(ref.val.name),
2484                                                ctx.error_handler());
2485      break;
2486    }
2487  }
2488  using format_func = void (*)(detail::buffer&lt;char&gt;&amp;, int, string_view);
2489  FMT_API void format_error_code(buffer&lt;char&gt;&amp; out, int error_code,
2490                                 string_view message) FMT_NOEXCEPT;
2491  FMT_API void report_error(format_func func, int error_code,
2492                            string_view message) FMT_NOEXCEPT;
2493  template &lt;typename OutputIt, typename Char&gt;
2494  class arg_formatter : public arg_formatter_base&lt;OutputIt, Char&gt; {
2495   private:
2496    using char_type = Char;
2497    using base = arg_formatter_base&lt;OutputIt, Char&gt;;
2498    using context_type = basic_format_context&lt;OutputIt, Char&gt;;
2499    context_type&amp; ctx_;
2500    basic_format_parse_context&lt;char_type&gt;* parse_ctx_;
2501    const Char* ptr_;
2502   public:
2503    using iterator = typename base::iterator;
2504    using format_specs = typename base::format_specs;
2505    explicit arg_formatter(
2506        context_type&amp; ctx,
2507        basic_format_parse_context&lt;char_type&gt;* parse_ctx = nullptr,
2508        format_specs* specs = nullptr, const Char* ptr = nullptr)
2509        : base(ctx.out(), specs, ctx.locale()),
2510          ctx_(ctx),
2511          parse_ctx_(parse_ctx),
2512          ptr_(ptr) {}
2513    using base::operator();
2514    iterator operator()(typename basic_format_arg&lt;context_type&gt;::handle handle) {
2515      if (ptr_) advance_to(*parse_ctx_, ptr_);
2516      handle.format(*parse_ctx_, ctx_);
2517      return ctx_.out();
2518    }
2519  };
2520  }  
2521  template &lt;typename OutputIt, typename Char&gt;
2522  using arg_formatter FMT_DEPRECATED_ALIAS =
2523      detail::arg_formatter&lt;OutputIt, Char&gt;;
2524  FMT_CLASS_API
2525  class FMT_API system_error : public std::runtime_error {
2526   private:
2527    void init(int err_code, string_view format_str, format_args args);
2528   protected:
2529    int error_code_;
2530    system_error() : std::runtime_error(&quot;&quot;), error_code_(0) {}
2531   public:
2532    template &lt;typename... Args&gt;
2533    system_error(int error_code, string_view message, const Args&amp;... args)
2534        : std::runtime_error(&quot;&quot;) {
2535      init(error_code, message, make_format_args(args...));
2536    }
2537    system_error(const system_error&amp;) = default;
2538    system_error&amp; operator=(const system_error&amp;) = default;
2539    system_error(system_error&amp;&amp;) = default;
2540    system_error&amp; operator=(system_error&amp;&amp;) = default;
2541    ~system_error() FMT_NOEXCEPT FMT_OVERRIDE;
2542    int error_code() const { return error_code_; }
2543  };
2544  FMT_API void format_system_error(detail::buffer&lt;char&gt;&amp; out, int error_code,
2545                                   string_view message) FMT_NOEXCEPT;
2546  FMT_API void report_system_error(int error_code,
2547                                   string_view message) FMT_NOEXCEPT;
2548  class format_int {
2549   private:
2550    enum { buffer_size = std::numeric_limits&lt;unsigned long long&gt;::digits10 + 3 };
2551    mutable char buffer_[buffer_size];
2552    char* str_;
2553    template &lt;typename UInt&gt; char* format_unsigned(UInt value) {
2554      auto n = static_cast&lt;detail::uint32_or_64_or_128_t&lt;UInt&gt;&gt;(value);
2555      return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
2556    }
2557    template &lt;typename Int&gt; char* format_signed(Int value) {
2558      auto abs_value = static_cast&lt;detail::uint32_or_64_or_128_t&lt;Int&gt;&gt;(value);
2559      bool negative = value &lt; 0;
2560      if (negative) abs_value = 0 - abs_value;
2561      auto begin = format_unsigned(abs_value);
2562      if (negative) *--begin = &#x27;-&#x27;;
2563      return begin;
2564    }
2565   public:
2566    explicit format_int(int value) : str_(format_signed(value)) {}
2567    explicit format_int(long value) : str_(format_signed(value)) {}
2568    explicit format_int(long long value) : str_(format_signed(value)) {}
2569    explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
2570    explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
2571    explicit format_int(unsigned long long value)
2572        : str_(format_unsigned(value)) {}
2573    size_t size() const {
2574      return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
2575    }
2576    const char* data() const { return str_; }
2577    const char* c_str() const {
2578      buffer_[buffer_size - 1] = &#x27;\0&#x27;;
2579      return str_;
2580    }
2581    std::string str() const { return std::string(str_, size()); }
2582  };
2583  template &lt;typename T, typename Char&gt;
2584  struct formatter&lt;T, Char,
2585                   enable_if_t&lt;detail::type_constant&lt;T, Char&gt;::value !=
2586                               detail::type::custom_type&gt;&gt; {
2587    FMT_CONSTEXPR formatter() = default;
2588    template &lt;typename ParseContext&gt;
2589    FMT_CONSTEXPR auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
2590      using handler_type = detail::dynamic_specs_handler&lt;ParseContext&gt;;
2591      auto type = detail::type_constant&lt;T, Char&gt;::value;
2592      detail::specs_checker&lt;handler_type&gt; handler(handler_type(specs_, ctx),
2593                                                  type);
2594      auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
2595      auto eh = ctx.error_handler();
2596      switch (type) {
2597      case detail::type::none_type:
2598        FMT_ASSERT(false, &quot;invalid argument type&quot;);
2599        break;
2600      case detail::type::int_type:
2601      case detail::type::uint_type:
2602      case detail::type::long_long_type:
2603      case detail::type::ulong_long_type:
2604      case detail::type::int128_type:
2605      case detail::type::uint128_type:
2606      case detail::type::bool_type:
2607        handle_int_type_spec(specs_.type,
2608                             detail::int_type_checker&lt;decltype(eh)&gt;(eh));
2609        break;
2610      case detail::type::char_type:
2611        handle_char_specs(
2612            &amp;specs_, detail::char_specs_checker&lt;decltype(eh)&gt;(specs_.type, eh));
2613        break;
2614      case detail::type::float_type:
2615        if (detail::const_check(FMT_USE_FLOAT))
2616          detail::parse_float_type_spec(specs_, eh);
2617        else
2618          FMT_ASSERT(false, &quot;float support disabled&quot;);
2619        break;
2620      case detail::type::double_type:
2621        if (detail::const_check(FMT_USE_DOUBLE))
2622          detail::parse_float_type_spec(specs_, eh);
2623        else
2624          FMT_ASSERT(false, &quot;double support disabled&quot;);
2625        break;
2626      case detail::type::long_double_type:
2627        if (detail::const_check(FMT_USE_LONG_DOUBLE))
2628          detail::parse_float_type_spec(specs_, eh);
2629        else
2630          FMT_ASSERT(false, &quot;long double support disabled&quot;);
2631        break;
2632      case detail::type::cstring_type:
2633        detail::handle_cstring_type_spec(
2634            specs_.type, detail::cstring_type_checker&lt;decltype(eh)&gt;(eh));
2635        break;
2636      case detail::type::string_type:
2637        detail::check_string_type_spec(specs_.type, eh);
2638        break;
2639      case detail::type::pointer_type:
2640        detail::check_pointer_type_spec(specs_.type, eh);
2641        break;
2642      case detail::type::custom_type:
2643        break;
2644      }
2645      return it;
2646    }
2647    template &lt;typename FormatContext&gt;
2648    auto format(const T&amp; val, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
2649      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs_.width,
2650                                                         specs_.width_ref, ctx);
2651      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(
2652          specs_.precision, specs_.precision_ref, ctx);
2653      using af = detail::arg_formatter&lt;typename FormatContext::iterator,
2654                                       typename FormatContext::char_type&gt;;
2655      return visit_format_arg(af(ctx, nullptr, &amp;specs_),
2656                              detail::make_arg&lt;FormatContext&gt;(val));
2657    }
2658   private:
2659    detail::dynamic_format_specs&lt;Char&gt; specs_;
2660  };
2661  #define FMT_FORMAT_AS(Type, Base)                                             \
2662    template &lt;typename Char&gt;                                                    \
2663    struct formatter&lt;Type, Char&gt; : formatter&lt;Base, Char&gt; {                      \
2664      template &lt;typename FormatContext&gt;                                         \
2665      auto format(Type const&amp; val, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) { \
2666        return formatter&lt;Base, Char&gt;::format(val, ctx);                         \
2667      }                                                                         \
2668    }
2669  FMT_FORMAT_AS(signed char, int);
2670  FMT_FORMAT_AS(unsigned char, unsigned);
2671  FMT_FORMAT_AS(short, int);
2672  FMT_FORMAT_AS(unsigned short, unsigned);
2673  FMT_FORMAT_AS(long, long long);
2674  FMT_FORMAT_AS(unsigned long, unsigned long long);
2675  FMT_FORMAT_AS(Char*, const Char*);
2676  FMT_FORMAT_AS(std::basic_string&lt;Char&gt;, basic_string_view&lt;Char&gt;);
2677  FMT_FORMAT_AS(std::nullptr_t, const void*);
2678  FMT_FORMAT_AS(detail::std_string_view&lt;Char&gt;, basic_string_view&lt;Char&gt;);
2679  template &lt;typename Char&gt;
2680  struct formatter&lt;void*, Char&gt; : formatter&lt;const void*, Char&gt; {
2681    template &lt;typename FormatContext&gt;
2682    auto format(void* val, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
2683      return formatter&lt;const void*, Char&gt;::format(val, ctx);
2684    }
2685  };
2686  template &lt;typename Char, size_t N&gt;
2687  struct formatter&lt;Char[N], Char&gt; : formatter&lt;basic_string_view&lt;Char&gt;, Char&gt; {
2688    template &lt;typename FormatContext&gt;
2689    auto format(const Char* val, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
2690      return formatter&lt;basic_string_view&lt;Char&gt;, Char&gt;::format(val, ctx);
2691    }
2692  };
2693  template &lt;typename Char = char&gt; class dynamic_formatter {
2694   private:
2695    struct null_handler : detail::error_handler {
2696      void on_align(align_t) {}
2697      void on_plus() {}
2698      void on_minus() {}
2699      void on_space() {}
2700      void on_hash() {}
2701    };
2702   public:
2703    template &lt;typename ParseContext&gt;
2704    auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
2705      format_str_ = ctx.begin();
2706      detail::dynamic_specs_handler&lt;ParseContext&gt; handler(specs_, ctx);
2707      return parse_format_specs(ctx.begin(), ctx.end(), handler);
2708    }
2709    template &lt;typename T, typename FormatContext&gt;
2710    auto format(const T&amp; val, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
2711      handle_specs(ctx);
2712      detail::specs_checker&lt;null_handler&gt; checker(
2713          null_handler(), detail::mapped_type_constant&lt;T, FormatContext&gt;::value);
2714      checker.on_align(specs_.align);
2715      switch (specs_.sign) {
2716      case sign::none:
2717        break;
2718      case sign::plus:
2719        checker.on_plus();
2720        break;
2721      case sign::minus:
2722        checker.on_minus();
2723        break;
2724      case sign::space:
2725        checker.on_space();
2726        break;
2727      }
2728      if (specs_.alt) checker.on_hash();
2729      if (specs_.precision &gt;= 0) checker.end_precision();
2730      using af = detail::arg_formatter&lt;typename FormatContext::iterator,
2731                                       typename FormatContext::char_type&gt;;
2732      visit_format_arg(af(ctx, nullptr, &amp;specs_),
2733                       detail::make_arg&lt;FormatContext&gt;(val));
2734      return ctx.out();
2735    }
2736   private:
2737    template &lt;typename Context&gt; void handle_specs(Context&amp; ctx) {
2738      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs_.width,
2739                                                         specs_.width_ref, ctx);
2740      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(
2741          specs_.precision, specs_.precision_ref, ctx);
2742    }
2743    detail::dynamic_format_specs&lt;Char&gt; specs_;
2744    const Char* format_str_;
2745  };
2746  template &lt;typename Char, typename ErrorHandler&gt;
2747  FMT_CONSTEXPR void advance_to(
2748      basic_format_parse_context&lt;Char, ErrorHandler&gt;&amp; ctx, const Char* p) {
2749    ctx.advance_to(ctx.begin() + (p - &amp;*ctx.begin()));
2750  }
2751  template &lt;typename ArgFormatter, typename Char, typename Context&gt;
2752  typename Context::iterator vformat_to(
2753      typename ArgFormatter::iterator out, basic_string_view&lt;Char&gt; format_str,
2754      basic_format_args&lt;Context&gt; args,
2755      detail::locale_ref loc = detail::locale_ref()) {
2756    if (format_str.size() == 2 &amp;&amp; detail::equal2(format_str.data(), &quot;{}&quot;)) {
2757      auto arg = args.get(0);
2758      if (!arg) detail::error_handler().on_error(&quot;argument not found&quot;);
2759      using iterator = typename ArgFormatter::iterator;
2760      return visit_format_arg(
2761          detail::default_arg_formatter&lt;iterator, Char&gt;{out, args, loc}, arg);
2762    }
2763    detail::format_handler&lt;ArgFormatter, Char, Context&gt; h(out, format_str, args,
2764                                                          loc);
2765    detail::parse_format_string&lt;false&gt;(format_str, h);
2766    return h.context.out();
2767  }
2768  template &lt;typename T&gt; inline const void* ptr(const T* p) { return p; }
2769  template &lt;typename T&gt; inline const void* ptr(const std::unique_ptr&lt;T&gt;&amp; p) {
2770    return p.get();
2771  }
2772  template &lt;typename T&gt; inline const void* ptr(const std::shared_ptr&lt;T&gt;&amp; p) {
2773    return p.get();
2774  }
2775  class bytes {
2776   private:
2777    string_view data_;
2778    friend struct formatter&lt;bytes&gt;;
2779   public:
2780    explicit bytes(string_view data) : data_(data) {}
2781  };
2782  template &lt;&gt; struct formatter&lt;bytes&gt; {
2783   private:
2784    detail::dynamic_format_specs&lt;char&gt; specs_;
2785   public:
2786    template &lt;typename ParseContext&gt;
2787    FMT_CONSTEXPR auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
2788      using handler_type = detail::dynamic_specs_handler&lt;ParseContext&gt;;
2789      detail::specs_checker&lt;handler_type&gt; handler(handler_type(specs_, ctx),
2790                                                  detail::type::string_type);
2791      auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
2792      detail::check_string_type_spec(specs_.type, ctx.error_handler());
2793      return it;
2794    }
2795    template &lt;typename FormatContext&gt;
2796    auto format(bytes b, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
2797      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs_.width,
2798                                                         specs_.width_ref, ctx);
2799      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(
2800          specs_.precision, specs_.precision_ref, ctx);
2801      return detail::write_bytes(ctx.out(), b.data_, specs_);
2802    }
2803  };
2804  template &lt;typename It, typename Sentinel, typename Char&gt;
2805  struct arg_join : detail::view {
2806    It begin;
2807    Sentinel end;
2808    basic_string_view&lt;Char&gt; sep;
2809    arg_join(It b, Sentinel e, basic_string_view&lt;Char&gt; s)
2810        : begin(b), end(e), sep(s) {}
2811  };
2812  template &lt;typename It, typename Sentinel, typename Char&gt;
2813  struct formatter&lt;arg_join&lt;It, Sentinel, Char&gt;, Char&gt;
2814      : formatter&lt;typename std::iterator_traits&lt;It&gt;::value_type, Char&gt; {
2815    template &lt;typename FormatContext&gt;
2816    auto format(const arg_join&lt;It, Sentinel, Char&gt;&amp; value, FormatContext&amp; ctx)
2817        -&gt; decltype(ctx.out()) {
2818      using base = formatter&lt;typename std::iterator_traits&lt;It&gt;::value_type, Char&gt;;
2819      auto it = value.begin;
2820      auto out = ctx.out();
2821      if (it != value.end) {
2822        out = base::format(*it++, ctx);
2823        while (it != value.end) {
2824          out = std::copy(value.sep.begin(), value.sep.end(), out);
2825          ctx.advance_to(out);
2826          out = base::format(*it++, ctx);
2827        }
2828      }
2829      return out;
2830    }
2831  };
2832  template &lt;typename It, typename Sentinel&gt;
2833  arg_join&lt;It, Sentinel, char&gt; join(It begin, Sentinel end, string_view sep) {
2834    return {begin, end, sep};
2835  }
2836  template &lt;typename It, typename Sentinel&gt;
2837  arg_join&lt;It, Sentinel, wchar_t&gt; join(It begin, Sentinel end, wstring_view sep) {
2838    return {begin, end, sep};
2839  }
2840  template &lt;typename Range&gt;
2841  arg_join&lt;detail::iterator_t&lt;Range&gt;, detail::sentinel_t&lt;Range&gt;, char&gt; join(
2842      Range&amp;&amp; range, string_view sep) {
2843    return join(std::begin(range), std::end(range), sep);
2844  }
2845  template &lt;typename Range&gt;
2846  arg_join&lt;detail::iterator_t&lt;Range&gt;, detail::sentinel_t&lt;Range&gt;, wchar_t&gt; join(
2847      Range&amp;&amp; range, wstring_view sep) {
2848    return join(std::begin(range), std::end(range), sep);
2849  }
2850  template &lt;typename T, FMT_ENABLE_IF(!std::is_integral&lt;T&gt;::value)&gt;
2851  inline std::string to_string(const T&amp; value) {
2852    std::string result;
2853    detail::write&lt;char&gt;(std::back_inserter(result), value);
2854    return result;
2855  }
2856  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
2857  inline std::string to_string(T value) {
2858    constexpr int max_size = detail::digits10&lt;T&gt;() + 2;
2859    char buffer[max_size &gt; 5 ? static_cast&lt;unsigned&gt;(max_size) : 5];
2860    char* begin = buffer;
2861    return std::string(begin, detail::write&lt;char&gt;(begin, value));
2862  }
2863  template &lt;typename T&gt; inline std::wstring to_wstring(const T&amp; value) {
2864    return format(L&quot;{}&quot;, value);
2865  }
2866  template &lt;typename Char, size_t SIZE&gt;
2867  std::basic_string&lt;Char&gt; to_string(const basic_memory_buffer&lt;Char, SIZE&gt;&amp; buf) {
2868    auto size = buf.size();
2869    detail::assume(size &lt; std::basic_string&lt;Char&gt;().max_size());
2870    return std::basic_string&lt;Char&gt;(buf.data(), size);
2871  }
2872  template &lt;typename Char&gt;
2873  detail::buffer_appender&lt;Char&gt; detail::vformat_to(
2874      detail::buffer&lt;Char&gt;&amp; buf, basic_string_view&lt;Char&gt; format_str,
2875      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args) {
2876    using af = arg_formatter&lt;typename buffer_context&lt;Char&gt;::iterator, Char&gt;;
2877    return vformat_to&lt;af&gt;(buffer_appender&lt;Char&gt;(buf), format_str, args);
2878  }
2879  #ifndef FMT_HEADER_ONLY
2880  extern template format_context::iterator detail::vformat_to(
2881      detail::buffer&lt;char&gt;&amp;, string_view, basic_format_args&lt;format_context&gt;);
2882  namespace detail {
2883  extern template FMT_API std::string grouping_impl&lt;char&gt;(locale_ref loc);
2884  extern template FMT_API std::string grouping_impl&lt;wchar_t&gt;(locale_ref loc);
2885  extern template FMT_API char thousands_sep_impl&lt;char&gt;(locale_ref loc);
2886  extern template FMT_API wchar_t thousands_sep_impl&lt;wchar_t&gt;(locale_ref loc);
2887  extern template FMT_API char decimal_point_impl(locale_ref loc);
2888  extern template FMT_API wchar_t decimal_point_impl(locale_ref loc);
2889  extern template int format_float&lt;double&gt;(double value, int precision,
2890                                           float_specs specs, buffer&lt;char&gt;&amp; buf);
2891  extern template int format_float&lt;long double&gt;(long double value, int precision,
2892                                                float_specs specs,
2893                                                buffer&lt;char&gt;&amp; buf);
2894  int snprintf_float(float value, int precision, float_specs specs,
2895                     buffer&lt;char&gt;&amp; buf) = delete;
2896  extern template int snprintf_float&lt;double&gt;(double value, int precision,
2897                                             float_specs specs,
2898                                             buffer&lt;char&gt;&amp; buf);
2899  extern template int snprintf_float&lt;long double&gt;(long double value,
2900                                                  int precision,
2901                                                  float_specs specs,
2902                                                  buffer&lt;char&gt;&amp; buf);
2903  }  
2904  #endif
2905  template &lt;typename S, typename Char = char_t&lt;S&gt;,
2906            FMT_ENABLE_IF(detail::is_string&lt;S&gt;::value)&gt;
2907  inline typename FMT_BUFFER_CONTEXT(Char)::iterator vformat_to(
2908      detail::buffer&lt;Char&gt;&amp; buf, const S&amp; format_str,
2909      basic_format_args&lt;FMT_BUFFER_CONTEXT(type_identity_t&lt;Char&gt;)&gt; args) {
2910    return detail::vformat_to(buf, to_string_view(format_str), args);
2911  }
2912  template &lt;typename S, typename... Args, size_t SIZE = inline_buffer_size,
2913            typename Char = enable_if_t&lt;detail::is_string&lt;S&gt;::value, char_t&lt;S&gt;&gt;&gt;
2914  inline typename buffer_context&lt;Char&gt;::iterator format_to(
2915      basic_memory_buffer&lt;Char, SIZE&gt;&amp; buf, const S&amp; format_str, Args&amp;&amp;... args) {
2916    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
2917    return detail::vformat_to(buf, to_string_view(format_str), vargs);
2918  }
2919  template &lt;typename OutputIt, typename Char = char&gt;
2920  using format_context_t = basic_format_context&lt;OutputIt, Char&gt;;
2921  template &lt;typename OutputIt, typename Char = char&gt;
2922  using format_args_t = basic_format_args&lt;format_context_t&lt;OutputIt, Char&gt;&gt;;
2923  template &lt;typename OutputIt, typename Char = typename OutputIt::value_type&gt;
2924  using format_to_n_context FMT_DEPRECATED_ALIAS = buffer_context&lt;Char&gt;;
2925  template &lt;typename OutputIt, typename Char = typename OutputIt::value_type&gt;
2926  using format_to_n_args FMT_DEPRECATED_ALIAS =
2927      basic_format_args&lt;buffer_context&lt;Char&gt;&gt;;
2928  template &lt;typename OutputIt, typename Char, typename... Args&gt;
2929  FMT_DEPRECATED format_arg_store&lt;buffer_context&lt;Char&gt;, Args...&gt;
2930  make_format_to_n_args(const Args&amp;... args) {
2931    return format_arg_store&lt;buffer_context&lt;Char&gt;, Args...&gt;(args...);
2932  }
2933  template &lt;typename Char, enable_if_t&lt;(!std::is_same&lt;Char, char&gt;::value), int&gt;&gt;
2934  std::basic_string&lt;Char&gt; detail::vformat(
2935      basic_string_view&lt;Char&gt; format_str,
2936      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args) {
2937    basic_memory_buffer&lt;Char&gt; buffer;
2938    detail::vformat_to(buffer, format_str, args);
2939    return to_string(buffer);
2940  }
2941  template &lt;typename Char, FMT_ENABLE_IF(std::is_same&lt;Char, wchar_t&gt;::value)&gt;
2942  void vprint(std::FILE* f, basic_string_view&lt;Char&gt; format_str,
2943              wformat_args args) {
2944    wmemory_buffer buffer;
2945    detail::vformat_to(buffer, format_str, args);
2946    buffer.push_back(L&#x27;\0&#x27;);
2947    if (std::fputws(buffer.data(), f) == -1)
2948      FMT_THROW(system_error(errno, &quot;cannot write to file&quot;));
2949  }
2950  template &lt;typename Char, FMT_ENABLE_IF(std::is_same&lt;Char, wchar_t&gt;::value)&gt;
2951  void vprint(basic_string_view&lt;Char&gt; format_str, wformat_args args) {
2952    vprint(stdout, format_str, args);
2953  }
2954  #if FMT_USE_USER_DEFINED_LITERALS
2955  namespace detail {
2956  #  if FMT_USE_UDL_TEMPLATE
2957  template &lt;typename Char, Char... CHARS&gt; class udl_formatter {
2958   public:
2959    template &lt;typename... Args&gt;
2960    std::basic_string&lt;Char&gt; operator()(Args&amp;&amp;... args) const {
2961      static FMT_CONSTEXPR_DECL Char s[] = {CHARS..., &#x27;\0&#x27;};
2962      return format(FMT_STRING(s), std::forward&lt;Args&gt;(args)...);
2963    }
2964  };
2965  #  else
2966  template &lt;typename Char&gt; struct udl_formatter {
2967    basic_string_view&lt;Char&gt; str;
2968    template &lt;typename... Args&gt;
2969    std::basic_string&lt;Char&gt; operator()(Args&amp;&amp;... args) const {
2970      return format(str, std::forward&lt;Args&gt;(args)...);
2971    }
2972  };
2973  #  endif  
2974  template &lt;typename Char&gt; struct udl_arg {
2975    const Char* str;
2976    template &lt;typename T&gt; named_arg&lt;Char, T&gt; operator=(T&amp;&amp; value) const {
2977      return {str, std::forward&lt;T&gt;(value)};
2978    }
2979  };
2980  }  
2981  inline namespace literals {
2982  #  if FMT_USE_UDL_TEMPLATE
2983  #    pragma GCC diagnostic push
2984  #    pragma GCC diagnostic ignored &quot;-Wpedantic&quot;
2985  #    if FMT_CLANG_VERSION
2986  #      pragma GCC diagnostic ignored &quot;-Wgnu-string-literal-operator-template&quot;
2987  #    endif
2988  template &lt;typename Char, Char... CHARS&gt;
2989  FMT_CONSTEXPR detail::udl_formatter&lt;Char, CHARS...&gt; operator&quot;&quot;_format() {
2990    return {};
2991  }
2992  #    pragma GCC diagnostic pop
2993  #  else
2994  FMT_CONSTEXPR detail::udl_formatter&lt;char&gt; operator&quot;&quot; _format(const char* s,
2995                                                               size_t n) {
2996    return {{s, n}};
2997  }
2998  FMT_CONSTEXPR detail::udl_formatter&lt;wchar_t&gt; operator&quot;&quot; _format(
2999      const wchar_t* s, size_t n) {
3000    return {{s, n}};
3001  }
3002  #  endif  
3003  FMT_CONSTEXPR detail::udl_arg&lt;char&gt; operator&quot;&quot; _a(const char* s, size_t) {
3004    return {s};
3005  }
3006  FMT_CONSTEXPR detail::udl_arg&lt;wchar_t&gt; operator&quot;&quot; _a(const wchar_t* s, size_t) {
3007    return {s};
3008  }
3009  }  
3010  #endif  
3011  FMT_END_NAMESPACE
3012  #ifdef FMT_HEADER_ONLY
3013  #  define FMT_FUNC inline
3014  #  include &quot;format-inl.h&quot;
3015  #else
3016  #  define FMT_FUNC
3017  #endif
3018  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</h3>
            <pre><code>1  #ifndef FMT_FORMAT_INL_H_
2  #define FMT_FORMAT_INL_H_
3  #include &lt;cassert&gt;
4  #include &lt;cctype&gt;
5  #include &lt;climits&gt;
6  #include &lt;cmath&gt;
7  #include &lt;cstdarg&gt;
8  #include &lt;cstring&gt;  
9  #include &lt;cwchar&gt;
10  #include &lt;exception&gt;
11  #ifndef FMT_STATIC_THOUSANDS_SEPARATOR
12  #  include &lt;locale&gt;
13  #endif
14  #ifdef _WIN32
15  #  include &lt;io.h&gt;  
16  #endif
17  #include &quot;format.h&quot;
18  inline fmt::detail::null&lt;&gt; strerror_r(int, char*, ...) { return {}; }
19  inline fmt::detail::null&lt;&gt; strerror_s(char*, size_t, ...) { return {}; }
20  FMT_BEGIN_NAMESPACE
21  namespace detail {
22  FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
23    std::fprintf(stderr, &quot;%s:%d: assertion failed: %s&quot;, file, line, message);
24    std::terminate();
25  }
26  #ifndef _MSC_VER
27  #  define FMT_SNPRINTF snprintf
28  #else  
29  inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
30    va_list args;
31    va_start(args, format);
32    int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
33    va_end(args);
34    return result;
35  }
36  #  define FMT_SNPRINTF fmt_snprintf
37  #endif  
38  inline int safe_strerror(int error_code, char*&amp; buffer,
39                           size_t buffer_size) FMT_NOEXCEPT {
40    FMT_ASSERT(buffer != nullptr &amp;&amp; buffer_size != 0, &quot;invalid buffer&quot;);
41    class dispatcher {
42     private:
43      int error_code_;
44      char*&amp; buffer_;
45      size_t buffer_size_;
46      void operator=(const dispatcher&amp;) {}
47      int handle(int result) {
48        return result == -1 ? errno : result;
49      }
50      FMT_MAYBE_UNUSED
51      int handle(char* message) {
52        if (message == buffer_ &amp;&amp; strlen(buffer_) == buffer_size_ - 1)
53          return ERANGE;
54        buffer_ = message;
55        return 0;
56      }
57      FMT_MAYBE_UNUSED
58      int handle(detail::null&lt;&gt;) {
59        return fallback(strerror_s(buffer_, buffer_size_, error_code_));
60      }
61      FMT_MAYBE_UNUSED
62      int fallback(int result) {
63        return result == 0 &amp;&amp; strlen(buffer_) == buffer_size_ - 1 ? ERANGE
64                                                                  : result;
65      }
66  #if !FMT_MSC_VER
67      int fallback(detail::null&lt;&gt;) {
68        errno = 0;
69        buffer_ = strerror(error_code_);
70        return errno;
71      }
72  #endif
73     public:
74      dispatcher(int err_code, char*&amp; buf, size_t buf_size)
75          : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}
76      int run() { return handle(strerror_r(error_code_, buffer_, buffer_size_)); }
77    };
78    return dispatcher(error_code, buffer, buffer_size).run();
79  }
80  FMT_FUNC void format_error_code(detail::buffer&lt;char&gt;&amp; out, int error_code,
81                                  string_view message) FMT_NOEXCEPT {
82    out.try_resize(0);
83    static const char SEP[] = &quot;: &quot;;
84    static const char ERROR_STR[] = &quot;error &quot;;
85    size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
86    auto abs_value = static_cast&lt;uint32_or_64_or_128_t&lt;int&gt;&gt;(error_code);
87    if (detail::is_negative(error_code)) {
88      abs_value = 0 - abs_value;
89      ++error_code_size;
90    }
91    error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
92    auto it = buffer_appender&lt;char&gt;(out);
93    if (message.size() &lt;= inline_buffer_size - error_code_size)
94      format_to(it, &quot;{}{}&quot;, message, SEP);
95    format_to(it, &quot;{}{}&quot;, ERROR_STR, error_code);
96    assert(out.size() &lt;= inline_buffer_size);
97  }
98  FMT_FUNC void report_error(format_func func, int error_code,
99                             string_view message) FMT_NOEXCEPT {
100    memory_buffer full_message;
101    func(full_message, error_code, message);
102    (void)std::fwrite(full_message.data(), full_message.size(), 1, stderr);
103    std::fputc(&#x27;\n&#x27;, stderr);
104  }
105  inline void fwrite_fully(const void* ptr, size_t size, size_t count,
106                           FILE* stream) {
107    size_t written = std::fwrite(ptr, size, count, stream);
108    if (written &lt; count) FMT_THROW(system_error(errno, &quot;cannot write to file&quot;));
109  }
110  }  
111  #if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
112  namespace detail {
113  template &lt;typename Locale&gt;
114  locale_ref::locale_ref(const Locale&amp; loc) : locale_(&amp;loc) {
115    static_assert(std::is_same&lt;Locale, std::locale&gt;::value, &quot;&quot;);
116  }
117  template &lt;typename Locale&gt; Locale locale_ref::get() const {
118    static_assert(std::is_same&lt;Locale, std::locale&gt;::value, &quot;&quot;);
119    return locale_ ? *static_cast&lt;const std::locale*&gt;(locale_) : std::locale();
120  }
121  template &lt;typename Char&gt; FMT_FUNC std::string grouping_impl(locale_ref loc) {
122    return std::use_facet&lt;std::numpunct&lt;Char&gt;&gt;(loc.get&lt;std::locale&gt;()).grouping();
123  }
124  template &lt;typename Char&gt; FMT_FUNC Char thousands_sep_impl(locale_ref loc) {
125    return std::use_facet&lt;std::numpunct&lt;Char&gt;&gt;(loc.get&lt;std::locale&gt;())
126        .thousands_sep();
127  }
128  template &lt;typename Char&gt; FMT_FUNC Char decimal_point_impl(locale_ref loc) {
129    return std::use_facet&lt;std::numpunct&lt;Char&gt;&gt;(loc.get&lt;std::locale&gt;())
130        .decimal_point();
131  }
132  }  
133  #else
134  template &lt;typename Char&gt;
135  FMT_FUNC std::string detail::grouping_impl(locale_ref) {
136    return &quot;\03&quot;;
137  }
138  template &lt;typename Char&gt; FMT_FUNC Char detail::thousands_sep_impl(locale_ref) {
139    return FMT_STATIC_THOUSANDS_SEPARATOR;
140  }
141  template &lt;typename Char&gt; FMT_FUNC Char detail::decimal_point_impl(locale_ref) {
142    return &#x27;.&#x27;;
143  }
144  #endif
145  FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
146  FMT_API FMT_FUNC system_error::~system_error() FMT_NOEXCEPT = default;
147  FMT_FUNC void system_error::init(int err_code, string_view format_str,
148                                   format_args args) {
149    error_code_ = err_code;
150    memory_buffer buffer;
151    format_system_error(buffer, err_code, vformat(format_str, args));
152    std::runtime_error&amp; base = *this;
153    base = std::runtime_error(to_string(buffer));
154  }
155  namespace detail {
156  template &lt;&gt; FMT_FUNC int count_digits&lt;4&gt;(detail::fallback_uintptr n) {
157    int i = static_cast&lt;int&gt;(sizeof(void*)) - 1;
158    while (i &gt; 0 &amp;&amp; n.value[i] == 0) --i;
159    auto char_digits = std::numeric_limits&lt;unsigned char&gt;::digits / 4;
160    return i &gt;= 0 ? i * char_digits + count_digits&lt;4, unsigned&gt;(n.value[i]) : 1;
161  }
162  template &lt;typename T&gt;
163  const typename basic_data&lt;T&gt;::digit_pair basic_data&lt;T&gt;::digits[] = {
164      {&#x27;0&#x27;, &#x27;0&#x27;}, {&#x27;0&#x27;, &#x27;1&#x27;}, {&#x27;0&#x27;, &#x27;2&#x27;}, {&#x27;0&#x27;, &#x27;3&#x27;}, {&#x27;0&#x27;, &#x27;4&#x27;}, {&#x27;0&#x27;, &#x27;5&#x27;},
165      {&#x27;0&#x27;, &#x27;6&#x27;}, {&#x27;0&#x27;, &#x27;7&#x27;}, {&#x27;0&#x27;, &#x27;8&#x27;}, {&#x27;0&#x27;, &#x27;9&#x27;}, {&#x27;1&#x27;, &#x27;0&#x27;}, {&#x27;1&#x27;, &#x27;1&#x27;},
166      {&#x27;1&#x27;, &#x27;2&#x27;}, {&#x27;1&#x27;, &#x27;3&#x27;}, {&#x27;1&#x27;, &#x27;4&#x27;}, {&#x27;1&#x27;, &#x27;5&#x27;}, {&#x27;1&#x27;, &#x27;6&#x27;}, {&#x27;1&#x27;, &#x27;7&#x27;},
167      {&#x27;1&#x27;, &#x27;8&#x27;}, {&#x27;1&#x27;, &#x27;9&#x27;}, {&#x27;2&#x27;, &#x27;0&#x27;}, {&#x27;2&#x27;, &#x27;1&#x27;}, {&#x27;2&#x27;, &#x27;2&#x27;}, {&#x27;2&#x27;, &#x27;3&#x27;},
168      {&#x27;2&#x27;, &#x27;4&#x27;}, {&#x27;2&#x27;, &#x27;5&#x27;}, {&#x27;2&#x27;, &#x27;6&#x27;}, {&#x27;2&#x27;, &#x27;7&#x27;}, {&#x27;2&#x27;, &#x27;8&#x27;}, {&#x27;2&#x27;, &#x27;9&#x27;},
169      {&#x27;3&#x27;, &#x27;0&#x27;}, {&#x27;3&#x27;, &#x27;1&#x27;}, {&#x27;3&#x27;, &#x27;2&#x27;}, {&#x27;3&#x27;, &#x27;3&#x27;}, {&#x27;3&#x27;, &#x27;4&#x27;}, {&#x27;3&#x27;, &#x27;5&#x27;},
170      {&#x27;3&#x27;, &#x27;6&#x27;}, {&#x27;3&#x27;, &#x27;7&#x27;}, {&#x27;3&#x27;, &#x27;8&#x27;}, {&#x27;3&#x27;, &#x27;9&#x27;}, {&#x27;4&#x27;, &#x27;0&#x27;}, {&#x27;4&#x27;, &#x27;1&#x27;},
171      {&#x27;4&#x27;, &#x27;2&#x27;}, {&#x27;4&#x27;, &#x27;3&#x27;}, {&#x27;4&#x27;, &#x27;4&#x27;}, {&#x27;4&#x27;, &#x27;5&#x27;}, {&#x27;4&#x27;, &#x27;6&#x27;}, {&#x27;4&#x27;, &#x27;7&#x27;},
172      {&#x27;4&#x27;, &#x27;8&#x27;}, {&#x27;4&#x27;, &#x27;9&#x27;}, {&#x27;5&#x27;, &#x27;0&#x27;}, {&#x27;5&#x27;, &#x27;1&#x27;}, {&#x27;5&#x27;, &#x27;2&#x27;}, {&#x27;5&#x27;, &#x27;3&#x27;},
173      {&#x27;5&#x27;, &#x27;4&#x27;}, {&#x27;5&#x27;, &#x27;5&#x27;}, {&#x27;5&#x27;, &#x27;6&#x27;}, {&#x27;5&#x27;, &#x27;7&#x27;}, {&#x27;5&#x27;, &#x27;8&#x27;}, {&#x27;5&#x27;, &#x27;9&#x27;},
174      {&#x27;6&#x27;, &#x27;0&#x27;}, {&#x27;6&#x27;, &#x27;1&#x27;}, {&#x27;6&#x27;, &#x27;2&#x27;}, {&#x27;6&#x27;, &#x27;3&#x27;}, {&#x27;6&#x27;, &#x27;4&#x27;}, {&#x27;6&#x27;, &#x27;5&#x27;},
175      {&#x27;6&#x27;, &#x27;6&#x27;}, {&#x27;6&#x27;, &#x27;7&#x27;}, {&#x27;6&#x27;, &#x27;8&#x27;}, {&#x27;6&#x27;, &#x27;9&#x27;}, {&#x27;7&#x27;, &#x27;0&#x27;}, {&#x27;7&#x27;, &#x27;1&#x27;},
176      {&#x27;7&#x27;, &#x27;2&#x27;}, {&#x27;7&#x27;, &#x27;3&#x27;}, {&#x27;7&#x27;, &#x27;4&#x27;}, {&#x27;7&#x27;, &#x27;5&#x27;}, {&#x27;7&#x27;, &#x27;6&#x27;}, {&#x27;7&#x27;, &#x27;7&#x27;},
177      {&#x27;7&#x27;, &#x27;8&#x27;}, {&#x27;7&#x27;, &#x27;9&#x27;}, {&#x27;8&#x27;, &#x27;0&#x27;}, {&#x27;8&#x27;, &#x27;1&#x27;}, {&#x27;8&#x27;, &#x27;2&#x27;}, {&#x27;8&#x27;, &#x27;3&#x27;},
178      {&#x27;8&#x27;, &#x27;4&#x27;}, {&#x27;8&#x27;, &#x27;5&#x27;}, {&#x27;8&#x27;, &#x27;6&#x27;}, {&#x27;8&#x27;, &#x27;7&#x27;}, {&#x27;8&#x27;, &#x27;8&#x27;}, {&#x27;8&#x27;, &#x27;9&#x27;},
179      {&#x27;9&#x27;, &#x27;0&#x27;}, {&#x27;9&#x27;, &#x27;1&#x27;}, {&#x27;9&#x27;, &#x27;2&#x27;}, {&#x27;9&#x27;, &#x27;3&#x27;}, {&#x27;9&#x27;, &#x27;4&#x27;}, {&#x27;9&#x27;, &#x27;5&#x27;},
180      {&#x27;9&#x27;, &#x27;6&#x27;}, {&#x27;9&#x27;, &#x27;7&#x27;}, {&#x27;9&#x27;, &#x27;8&#x27;}, {&#x27;9&#x27;, &#x27;9&#x27;}};
181  template &lt;typename T&gt;
182  const char basic_data&lt;T&gt;::hex_digits[] = &quot;0123456789abcdef&quot;;
183  #define FMT_POWERS_OF_10(factor)                                             \
184    factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
185        (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
186        (factor)*1000000000
187  template &lt;typename T&gt;
188  const uint64_t basic_data&lt;T&gt;::powers_of_10_64[] = {
189      1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
190      10000000000000000000ULL};
191  template &lt;typename T&gt;
192  const uint32_t basic_data&lt;T&gt;::zero_or_powers_of_10_32[] = {0, 0,
193                                                             FMT_POWERS_OF_10(1)};
194  template &lt;typename T&gt;
195  const uint64_t basic_data&lt;T&gt;::zero_or_powers_of_10_64[] = {
196      0, 0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
197      10000000000000000000ULL};
198  template &lt;typename T&gt;
199  const uint64_t basic_data&lt;T&gt;::grisu_pow10_significands[] = {
200      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
201      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
202      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
203      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
204      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
205      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
206      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
207      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
208      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
209      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
210      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
211      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
212      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
213      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
214      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
215      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
216      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
217      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
218      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
219      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
220      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
221      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
222      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
223      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
224      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
225      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
226      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
227      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
228      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
229  };
230  template &lt;typename T&gt;
231  const int16_t basic_data&lt;T&gt;::grisu_pow10_exponents[] = {
232      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
233      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
234      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
235      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
236      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
237      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
238      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
239      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
240  template &lt;typename T&gt;
241  const divtest_table_entry&lt;uint32_t&gt; basic_data&lt;T&gt;::divtest_table_for_pow5_32[] =
242      {{0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},
243       {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},
244       {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},
245       {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},
246       {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},
247       {0x3ed61f49, 0x000001b7}};
248  template &lt;typename T&gt;
249  const divtest_table_entry&lt;uint64_t&gt; basic_data&lt;T&gt;::divtest_table_for_pow5_64[] =
250      {{0x0000000000000001, 0xffffffffffffffff},
251       {0xcccccccccccccccd, 0x3333333333333333},
252       {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},
253       {0x1cac083126e978d5, 0x020c49ba5e353f7c},
254       {0xd288ce703afb7e91, 0x0068db8bac710cb2},
255       {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},
256       {0x790fb65668c26139, 0x000431bde82d7b63},
257       {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},
258       {0xc767074b22e90e21, 0x00002af31dc46118},
259       {0x8e47ce423a2e9c6d, 0x0000089705f4136b},
260       {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},
261       {0x0fee64690c913975, 0x00000057f5ff85e5},
262       {0x3662e0e1cf503eb1, 0x000000119799812d},
263       {0xa47a2cf9f6433fbd, 0x0000000384b84d09},
264       {0x54186f653140a659, 0x00000000b424dc35},
265       {0x7738164770402145, 0x0000000024075f3d},
266       {0xe4a4d1417cd9a041, 0x000000000734aca5},
267       {0xc75429d9e5c5200d, 0x000000000170ef54},
268       {0xc1773b91fac10669, 0x000000000049c977},
269       {0x26b172506559ce15, 0x00000000000ec1e4},
270       {0xd489e3a9addec2d1, 0x000000000002f394},
271       {0x90e860bb892c8d5d, 0x000000000000971d},
272       {0x502e79bf1b6f4f79, 0x0000000000001e39},
273       {0xdcd618596be30fe5, 0x000000000000060b}};
274  template &lt;typename T&gt;
275  const uint64_t basic_data&lt;T&gt;::dragonbox_pow10_significands_64[] = {
276      0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
277      0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
278      0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
279      0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
280      0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
281      0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
282      0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
283      0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
284      0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
285      0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
286      0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
287      0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
288      0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
289      0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
290      0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
291      0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
292      0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
293      0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
294      0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
295      0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,
296      0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,
297      0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,
298      0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,
299      0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,
300      0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,
301      0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};
302  template &lt;typename T&gt;
303  const uint128_wrapper basic_data&lt;T&gt;::dragonbox_pow10_significands_128[] = {
304  #if FMT_USE_FULL_CACHE_DRAGONBOX
305      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
306      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
307      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
308      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
309      {0x9becce62836ac577, 0x4ee367f9430aec33},
310      {0xc2e801fb244576d5, 0x229c41f793cda740},
311      {0xf3a20279ed56d48a, 0x6b43527578c11110},
312      {0x9845418c345644d6, 0x830a13896b78aaaa},
313      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
314      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
315      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
316      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
317      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
318      {0x91376c36d99995be, 0x23100809b9c21fa2},
319      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
320      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
321      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
322      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
323      {0xdd95317f31c7fa1d, 0x40405643d711d584},
324      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
325      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
326      {0xd863b256369d4a40, 0x90bed43e40076a83},
327      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
328      {0xa90de3535aaae202, 0x711515d0a205cb37},
329      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
330      {0x8412d9991ed58091, 0xe858790afe9486c3},
331      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
332      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
333      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
334      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
335      {0xc987434744ac874e, 0xa327ffb266b56221},
336      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
337      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
338      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
339      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
340      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
341      {0xc0314325637a1939, 0xfa911155fefb5309},
342      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
343      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
344      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
345      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
346      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
347      {0xb749faed14125d36, 0xcef980ec671f667c},
348      {0xe51c79a85916f484, 0x82b7e12780e7401b},
349      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
350      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
351      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
352      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
353      {0xaecc49914078536d, 0x58fae9f773886e19},
354      {0xda7f5bf590966848, 0xaf39a475506a899f},
355      {0x888f99797a5e012d, 0x6d8406c952429604},
356      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
357      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
358      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
359      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
360      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
361      {0x823c12795db6ce57, 0x76c53d08d6b70859},
362      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
363      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
364      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
365      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
366      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
367      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
368      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
369      {0xc21094364dfb5636, 0x985915fc12f542e5},
370      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
371      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
372      {0xbd8430bd08277231, 0x50c6ff782a838354},
373      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
374      {0x940f4613ae5ed136, 0x871b7795e136be9a},
375      {0xb913179899f68584, 0x28e2557b59846e40},
376      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
377      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
378      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
379      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
380      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
381      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
382      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
383      {0x89e42caaf9491b60, 0xf41686c49db57245},
384      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
385      {0xd77485cb25823ac7, 0x7d633293366b828c},
386      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
387      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
388      {0xd267caa862a12d66, 0xd072df63c324fd7c},
389      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
390      {0xa46116538d0deb78, 0x52d9be85f074e609},
391      {0xcd795be870516656, 0x67902e276c921f8c},
392      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
393      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
394      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
395      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
396      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
397      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
398      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
399      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
400      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
401      {0xef340a98172aace4, 0x86fb897116c87c35},
402      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
403      {0xbae0a846d2195712, 0x8974836059cca10a},
404      {0xe998d258869facd7, 0x2bd1a438703fc94c},
405      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
406      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
407      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
408      {0x8e938662882af53e, 0x547eb47b7282ee9d},
409      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
410      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
411      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
412      {0xae0b158b4738705e, 0x9624ab50b148d446},
413      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
414      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
415      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
416      {0xd47487cc8470652b, 0x7647c32000696720},
417      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
418      {0xa5fb0a17c777cf09, 0xf468107100525891},
419      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
420      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
421      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
422      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
423      {0xfd442e4688bd304a, 0x908f4a166d1da664},
424      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
425      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
426      {0xf7549530e188c128, 0xd12bee59e68ef47d},
427      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
428      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
429      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
430      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
431      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
432      {0xebdf661791d60f56, 0x111b495b3464ad22},
433      {0x936b9fcebb25c995, 0xcab10dd900beec35},
434      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
435      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
436      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
437      {0xb3f4e093db73a093, 0x59ed216765690f57},
438      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
439      {0x8c974f7383725573, 0x1e414218c73a13fc},
440      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
441      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
442      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
443      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
444      {0xd686619ba27255a2, 0xc80a537b0efefebe},
445      {0x8613fd0145877585, 0xbd06742ce95f5f37},
446      {0xa798fc4196e952e7, 0x2c48113823b73705},
447      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
448      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
449      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
450      {0xcc963fee10b7d1b3, 0x318df905079926a9},
451      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
452      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
453      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
454      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
455      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
456      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
457      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
458      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
459      {0xbe89523386091465, 0xf6bbb397f1135824},
460      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
461      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
462      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
463      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
464      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
465      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
466      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
467      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
468      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
469      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
470      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
471      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
472      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
473      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
474      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
475      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
476      {0x843610cb4bf160cb, 0xcedf722a585139bb},
477      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
478      {0xce947a3da6a9273e, 0x733d226229feea33},
479      {0x811ccc668829b887, 0x0806357d5a3f5260},
480      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
481      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
482      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
483      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
484      {0xc5029163f384a931, 0x0a9e795e65d4df12},
485      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
486      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
487      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
488      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
489      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
490      {0xbbe226efb628afea, 0x890489f70a55368c},
491      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
492      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
493      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
494      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
495      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
496      {0xb32df8e9f3546564, 0x47939822dc96abfa},
497      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
498      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
499      {0xaefae51477a06b03, 0xede622920b6b23f2},
500      {0xdab99e59958885c4, 0xe95fab368e45ecee},
501      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
502      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
503      {0xd59944a37c0752a2, 0x4be76d3346f04960},
504      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
505      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
506      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
507      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
508      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
509      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
510      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
511      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
512      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
513      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
514      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
515      {0xc24452da229b021b, 0xfbe85badce996169},
516      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
517      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
518      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
519      {0xed246723473e3813, 0x290123e9aab23b69},
520      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
521      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
522      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
523      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
524      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
525      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
526      {0x8d590723948a535f, 0x579c487e5a38ad0f},
527      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
528      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
529      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
530      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
531      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
532      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
533      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
534      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
535      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
536      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
537      {0xcdb02555653131b6, 0x3792f412cb06794e},
538      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
539      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
540      {0xc8de047564d20a8b, 0xf245825a5a445276},
541      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
542      {0x9ced737bb6c4183d, 0x55464dd69685606c},
543      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
544      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
545      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
546      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
547      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
548      {0x95a8637627989aad, 0xdde7001379a44aa9},
549      {0xbb127c53b17ec159, 0x5560c018580d5d53},
550      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
551      {0x9226712162ab070d, 0xcab3961304ca70e9},
552      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
553      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
554      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
555      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
556      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
557      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
558      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
559      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
560      {0x881cea14545c7575, 0x7e50d64177da2e55},
561      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
562      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
563      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
564      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
565      {0xcfb11ead453994ba, 0x67de18eda5814af3},
566      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
567      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
568      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
569      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
570      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
571      {0xc612062576589dda, 0x95364afe032a819e},
572      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
573      {0x9abe14cd44753b52, 0xc4926a9672793543},
574      {0xc16d9a0095928a27, 0x75b7053c0f178294},
575      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
576      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
577      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
578      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
579      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
580      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
581      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
582      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
583      {0xb424dc35095cd80f, 0x538484c19ef38c95},
584      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
585      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
586      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
587      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
588      {0x89705f4136b4a597, 0x31680a88f8953031},
589      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
590      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
591      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
592      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
593      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
594      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
595      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
596      {0xcccccccccccccccc, 0xcccccccccccccccd},
597      {0x8000000000000000, 0x0000000000000000},
598      {0xa000000000000000, 0x0000000000000000},
599      {0xc800000000000000, 0x0000000000000000},
600      {0xfa00000000000000, 0x0000000000000000},
601      {0x9c40000000000000, 0x0000000000000000},
602      {0xc350000000000000, 0x0000000000000000},
603      {0xf424000000000000, 0x0000000000000000},
604      {0x9896800000000000, 0x0000000000000000},
605      {0xbebc200000000000, 0x0000000000000000},
606      {0xee6b280000000000, 0x0000000000000000},
607      {0x9502f90000000000, 0x0000000000000000},
608      {0xba43b74000000000, 0x0000000000000000},
609      {0xe8d4a51000000000, 0x0000000000000000},
610      {0x9184e72a00000000, 0x0000000000000000},
611      {0xb5e620f480000000, 0x0000000000000000},
612      {0xe35fa931a0000000, 0x0000000000000000},
613      {0x8e1bc9bf04000000, 0x0000000000000000},
614      {0xb1a2bc2ec5000000, 0x0000000000000000},
615      {0xde0b6b3a76400000, 0x0000000000000000},
616      {0x8ac7230489e80000, 0x0000000000000000},
617      {0xad78ebc5ac620000, 0x0000000000000000},
618      {0xd8d726b7177a8000, 0x0000000000000000},
619      {0x878678326eac9000, 0x0000000000000000},
620      {0xa968163f0a57b400, 0x0000000000000000},
621      {0xd3c21bcecceda100, 0x0000000000000000},
622      {0x84595161401484a0, 0x0000000000000000},
623      {0xa56fa5b99019a5c8, 0x0000000000000000},
624      {0xcecb8f27f4200f3a, 0x0000000000000000},
625      {0x813f3978f8940984, 0x4000000000000000},
626      {0xa18f07d736b90be5, 0x5000000000000000},
627      {0xc9f2c9cd04674ede, 0xa400000000000000},
628      {0xfc6f7c4045812296, 0x4d00000000000000},
629      {0x9dc5ada82b70b59d, 0xf020000000000000},
630      {0xc5371912364ce305, 0x6c28000000000000},
631      {0xf684df56c3e01bc6, 0xc732000000000000},
632      {0x9a130b963a6c115c, 0x3c7f400000000000},
633      {0xc097ce7bc90715b3, 0x4b9f100000000000},
634      {0xf0bdc21abb48db20, 0x1e86d40000000000},
635      {0x96769950b50d88f4, 0x1314448000000000},
636      {0xbc143fa4e250eb31, 0x17d955a000000000},
637      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
638      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
639      {0xb7abc627050305ad, 0xf14a3d9e40000000},
640      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
641      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
642      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
643      {0xe0352f62a19e306e, 0xd50b2037ad200000},
644      {0x8c213d9da502de45, 0x4526f422cc340000},
645      {0xaf298d050e4395d6, 0x9670b12b7f410000},
646      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
647      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
648      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
649      {0xd5d238a4abe98068, 0x72a4904598d6d880},
650      {0x85a36366eb71f041, 0x47a6da2b7f864750},
651      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
652      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
653      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},
654      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},
655      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},
656      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
657      {0x9f4f2726179a2245, 0x01d762422c946590},
658      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},
659      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},
660      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},
661      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},
662      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},
663      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},
664      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},
665      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},
666      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},
667      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},
668      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},
669      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},
670      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},
671      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},
672      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},
673      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},
674      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},
675      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},
676      {0xacb92ed9397bf996, 0x49c2c37f07965404},
677      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},
678      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},
679      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},
680      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},
681      {0x83c7088e1aab65db, 0x792667c6da79e0fa},
682      {0xa4b8cab1a1563f52, 0x577001b891185938},
683      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
684      {0x80b05e5ac60b6178, 0x544f8158315b05b4},
685      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},
686      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},
687      {0xfb5878494ace3a5f, 0x04ab48a04065c723},
688      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},
689      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},
690      {0xf5746577930d6500, 0xca8f44ec7ee36479},
691      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},
692      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},
693      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},
694      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},
695      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},
696      {0xea1575143cf97226, 0xf52d09d71a3293bd},
697      {0x924d692ca61be758, 0x593c2626705f9c56},
698      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},
699      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},
700      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},
701      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},
702      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},
703      {0x8b865b215899f46c, 0xbd79e0d20082ee74},
704      {0xae67f1e9aec07187, 0xecd8590680a3aa11},
705      {0xda01ee641a708de9, 0xe80e6f4820cc9495},
706      {0x884134fe908658b2, 0x3109058d147fdcdd},
707      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},
708      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},
709      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},
710      {0xa6539930bf6bff45, 0x84db8346b786151c},
711      {0xcfe87f7cef46ff16, 0xe612641865679a63},
712      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},
713      {0xa26da3999aef7749, 0xe3be5e330f38f09d},
714      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},
715      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},
716      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},
717      {0xc646d63501a1511d, 0xb281e1fd541501b8},
718      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},
719      {0x9ae757596946075f, 0x3375788de9b06958},
720      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},
721      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},
722      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},
723      {0xbd176620a501fbff, 0xb650e5a93bc3d898},
724      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},
725      {0x93ba47c980e98cdf, 0xc66f336c36b10137},
726      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},
727      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},
728      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},
729      {0xb454e4a179dd1877, 0x29babe4598c311fb},
730      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},
731      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},
732      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},
733      {0xdc21a1171d42645d, 0x76707543f4fa1f73},
734      {0x899504ae72497eba, 0x6a06494a791c53a8},
735      {0xabfa45da0edbde69, 0x0487db9d17636892},
736      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},
737      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
738      {0xa7f26836f282b732, 0x8e6cac7768d7141e},
739      {0xd1ef0244af2364ff, 0x3207d795430cd926},
740      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},
741      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},
742      {0xcd036837130890a1, 0x36dba887c37a8c0f},
743      {0x802221226be55a64, 0xc2494954da2c9789},
744      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},
745      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},
746      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},
747      {0x9c69a97284b578d7, 0xff2a760414536efb},
748      {0xc38413cf25e2d70d, 0xfef5138519684aba},
749      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},
750      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},
751      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},
752      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},
753      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},
754      {0xba756174393d88df, 0x94f971119aeef9e4},
755      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},
756      {0x91abb422ccb812ee, 0xac62e055c10ab33a},
757      {0xb616a12b7fe617aa, 0x577b986b314d6009},
758      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},
759      {0x8e41ade9fbebc27d, 0x14588f13be847307},
760      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},
761      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},
762      {0x8aec23d680043bee, 0x25de7bb9480d5854},
763      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},
764      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
765      {0x87aa9aff79042286, 0x90fb44d2f05d0842},
766      {0xa99541bf57452b28, 0x353a1607ac744a53},
767      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},
768      {0x847c9b5d7c2e09b7, 0x69956135febada11},
769      {0xa59bc234db398c25, 0x43fab9837e699095},
770      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},
771      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},
772      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},
773      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},
774      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},
775      {0x9defbf01b061adab, 0x3a0888136afa64a7},
776      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},
777      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},
778      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},
779      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},
780      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},
781      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},
782      {0xbc4665b596706114, 0x873d5d9f0dde1fee},
783      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},
784      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},
785      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},
786      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},
787      {0x8fa475791a569d10, 0xf96e017d694487bc},
788      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},
789      {0xe070f78d3927556a, 0x85bbe253f47b1417},
790      {0x8c469ab843b89562, 0x93956d7478ccec8e},
791      {0xaf58416654a6babb, 0x387ac8d1970027b2},
792      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},
793      {0x88fcf317f22241e2, 0x441fece3bdf81f03},
794      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},
795      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},
796      {0x85c7056562757456, 0xf6872d5667844e49},
797      {0xa738c6bebb12d16c, 0xb428f8ac016561db},
798      {0xd106f86e69d785c7, 0xe13336d701beba52},
799      {0x82a45b450226b39c, 0xecc0024661173473},
800      {0xa34d721642b06084, 0x27f002d7f95d0190},
801      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},
802      {0xff290242c83396ce, 0x7e67047175a15271},
803      {0x9f79a169bd203e41, 0x0f0062c6e984d386},
804      {0xc75809c42c684dd1, 0x52c07b78a3e60868},
805      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},
806      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},
807      {0xc2abf989935ddbfe, 0x6acff893d00ea435},
808      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},
809      {0x98165af37b2153de, 0xc3727a337a8b704a},
810      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},
811      {0xeda2ee1c7064130c, 0x1162def06f79df73},
812      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},
813      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},
814      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},
815      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},
816      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},
817      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},
818      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
819      {0xb10d8e1456105dad, 0x7425a83e872c5f47},
820      {0xdd50f1996b947518, 0xd12f124e28f77719},
821      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},
822      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},
823      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},
824      {0x8714a775e3e95c78, 0x65acfaec34810a71},
825      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},
826      {0xd31045a8341ca07c, 0x1ede48111209a050},
827      {0x83ea2b892091e44d, 0x934aed0aab460432},
828      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},
829      {0xce1de40642e3f4b9, 0x36251260ab9d668e},
830      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},
831      {0xa1075a24e4421730, 0xb24cf65b8612f81f},
832      {0xc94930ae1d529cfc, 0xdee033f26797b627},
833      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},
834      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},
835      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},
836      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},
837      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},
838      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},
839      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},
840      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},
841      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},
842      {0xea53df5fd18d5513, 0x84c86189216dc5ed},
843      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},
844      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},
845      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
846      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},
847      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},
848      {0xdf78e4b2bd342cf6, 0x914da9246b255416},
849      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},
850      {0xae9672aba3d0c320, 0xa184ac2473b529b1},
851      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},
852      {0x8865899617fb1871, 0x7e2fa67c7a658892},
853      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},
854      {0xd51ea6fa85785631, 0x552a74227f3ea565},
855      {0x8533285c936b35de, 0xd53a88958f87275f},
856      {0xa67ff273b8460356, 0x8a892abaf368f137},
857      {0xd01fef10a657842c, 0x2d2b7569b0432d85},
858      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},
859      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},
860      {0xcb3f2f7642717713, 0x241c70a936219a73},
861      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},
862      {0x9ec95d1463e8a506, 0xf4363804324a40aa},
863      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},
864      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},
865      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},
866      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},
867      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},
868      {0x976e41088617ca01, 0xd5be0503e085d813},
869      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},
870      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},
871      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},
872      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
873      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},
874      {0x906a617d450187e2, 0x27fb2b80668b24c5},
875      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},
876      {0xe1a63853bbd26451, 0x5e7873f8a0396973},
877      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},
878      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},
879      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},
880      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},
881      {0xac2820d9623bf429, 0x546345fa9fbdcd44},
882      {0xd732290fbacaf133, 0xa97c177947ad4095},
883      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},
884      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},
885      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},
886      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},
887      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},
888      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},
889      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},
890      {0xa0555e361951c366, 0xd7e105bcc332621f},
891      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},
892      {0xfa856334878fc150, 0xb14f98f6f0feb951},
893      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},
894      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},
895      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},
896      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},
897      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},
898      {0xeeea5d5004981478, 0x1858ccfce06cac74},
899      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},
900      {0xbaa718e68396cffd, 0xd30560258f54e6ba},
901      {0xe950df20247c83fd, 0x47c6b82ef32a2069},
902      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},
903      {0xb6472e511c81471d, 0xe0133fe4adf8e952},
904      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},
905      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},
906      {0xb201833b35d63f73, 0x2cd2cc6551e513da},
907      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},
908      {0x8b112e86420f6191, 0xfb04afaf27faf782},
909      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},
910      {0xd94ad8b1c7380874, 0x18375281ae7822bc},
911      {0x87cec76f1c830548, 0x8f2293910d0b15b5},
912      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},
913      {0xd433179d9c8cb841, 0x5fa60692a46151eb},
914      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},
915      {0xa5c7ea73224deff3, 0x12b9b522906c0800},
916      {0xcf39e50feae16bef, 0xd768226b34870a00},
917      {0x81842f29f2cce375, 0xe6a1158300d46640},
918      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},
919      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},
920      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},
921      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},
922      {0xc5a05277621be293, 0xc7098b7305241885},
923      {0xf70867153aa2db38, 0xb8cbee4fc66d1ea7}
924  #else
925      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
926      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
927      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
928      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
929      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
930      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
931      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
932      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
933      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
934      {0x95a8637627989aad, 0xdde7001379a44aa9},
935      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
936      {0xc350000000000000, 0x0000000000000000},
937      {0x9dc5ada82b70b59d, 0xf020000000000000},
938      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
939      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
940      {0xa6539930bf6bff45, 0x84db8346b786151c},
941      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
942      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
943      {0xaf58416654a6babb, 0x387ac8d1970027b2},
944      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
945      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
946      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
947      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8}
948  #endif
949  };
950  #if !FMT_USE_FULL_CACHE_DRAGONBOX
951  template &lt;typename T&gt;
952  const uint64_t basic_data&lt;T&gt;::powers_of_5_64[] = {
953      0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
954      0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
955      0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
956      0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
957      0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
958      0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
959      0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
960      0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
961      0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};
962  template &lt;typename T&gt;
963  const uint32_t basic_data&lt;T&gt;::dragonbox_pow10_recovery_errors[] = {
964      0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,
965      0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,
966      0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,
967      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,
968      0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,
969      0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,
970      0x69514555, 0x05151109, 0x00155555};
971  #endif
972  template &lt;typename T&gt;
973  const char basic_data&lt;T&gt;::foreground_color[] = &quot;\x1b[38;2;&quot;;
974  template &lt;typename T&gt;
975  const char basic_data&lt;T&gt;::background_color[] = &quot;\x1b[48;2;&quot;;
976  template &lt;typename T&gt; const char basic_data&lt;T&gt;::reset_color[] = &quot;\x1b[0m&quot;;
977  template &lt;typename T&gt; const wchar_t basic_data&lt;T&gt;::wreset_color[] = L&quot;\x1b[0m&quot;;
978  template &lt;typename T&gt; const char basic_data&lt;T&gt;::signs[] = {0, &#x27;-&#x27;, &#x27;+&#x27;, &#x27; &#x27;};
979  template &lt;typename T&gt;
980  const char basic_data&lt;T&gt;::left_padding_shifts[] = {31, 31, 0, 1, 0};
981  template &lt;typename T&gt;
982  const char basic_data&lt;T&gt;::right_padding_shifts[] = {0, 31, 0, 1, 0};
983  template &lt;typename T&gt; struct bits {
984    static FMT_CONSTEXPR_DECL const int value =
985        static_cast&lt;int&gt;(sizeof(T) * std::numeric_limits&lt;unsigned char&gt;::digits);
986  };
987  class fp;
988  template &lt;int SHIFT = 0&gt; fp normalize(fp value);
989  struct boundaries {
990    uint64_t lower;
991    uint64_t upper;
992  };
993  class fp {
994   private:
995    using significand_type = uint64_t;
996    template &lt;typename Float&gt;
997    using is_supported_float = bool_constant&lt;sizeof(Float) == sizeof(uint64_t) ||
998                                             sizeof(Float) == sizeof(uint32_t)&gt;;
999   public:
1000    significand_type f;
1001    int e;
1002    static FMT_CONSTEXPR_DECL const int double_significand_size =
1003        std::numeric_limits&lt;double&gt;::digits - 1;
1004    static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
1005        1ULL &lt;&lt; double_significand_size;
1006    static FMT_CONSTEXPR_DECL const int significand_size =
1007        bits&lt;significand_type&gt;::value;
1008    fp() : f(0), e(0) {}
1009    fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
1010    template &lt;typename Double&gt; explicit fp(Double d) { assign(d); }
1011    template &lt;typename Float, FMT_ENABLE_IF(is_supported_float&lt;Float&gt;::value)&gt;
1012    bool assign(Float d) {
1013      using limits = std::numeric_limits&lt;Float&gt;;
1014      const int float_significand_size = limits::digits - 1;
1015      const int exponent_size =
1016          bits&lt;Float&gt;::value - float_significand_size - 1;  
1017      const uint64_t float_implicit_bit = 1ULL &lt;&lt; float_significand_size;
1018      const uint64_t significand_mask = float_implicit_bit - 1;
1019      const uint64_t exponent_mask = (~0ULL &gt;&gt; 1) &amp; ~significand_mask;
1020      const int exponent_bias = (1 &lt;&lt; exponent_size) - limits::max_exponent - 1;
1021      constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);
1022      auto u = bit_cast&lt;conditional_t&lt;is_double, uint64_t, uint32_t&gt;&gt;(d);
1023      f = u &amp; significand_mask;
1024      int biased_e =
1025          static_cast&lt;int&gt;((u &amp; exponent_mask) &gt;&gt; float_significand_size);
1026      bool is_predecessor_closer = f == 0 &amp;&amp; biased_e &gt; 1;
1027      if (biased_e != 0)
1028        f += float_implicit_bit;
1029      else
1030        biased_e = 1;  
1031      e = biased_e - exponent_bias - float_significand_size;
1032      return is_predecessor_closer;
1033    }
<span onclick='openModal()' class='match'>1034    template &lt;typename Float, FMT_ENABLE_IF(!is_supported_float&lt;Float&gt;::value)&gt;
1035    bool assign(Float) {
</span>1036      *this = fp();
1037      return false;
1038    }
1039  };
1040  template &lt;int SHIFT&gt; fp normalize(fp value) {
1041    const auto shifted_implicit_bit = fp::implicit_bit &lt;&lt; SHIFT;
1042    while ((value.f &amp; shifted_implicit_bit) == 0) {
1043      value.f &lt;&lt;= 1;
1044      --value.e;
1045    }
1046    const auto offset =
1047        fp::significand_size - fp::double_significand_size - SHIFT - 1;
1048    value.f &lt;&lt;= offset;
1049    value.e -= offset;
1050    return value;
1051  }
1052  inline bool operator==(fp x, fp y) { return x.f == y.f &amp;&amp; x.e == y.e; }
1053  inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
1054  #if FMT_USE_INT128
1055    auto product = static_cast&lt;__uint128_t&gt;(lhs) * rhs;
1056    auto f = static_cast&lt;uint64_t&gt;(product &gt;&gt; 64);
1057    return (static_cast&lt;uint64_t&gt;(product) &amp; (1ULL &lt;&lt; 63)) != 0 ? f + 1 : f;
1058  #else
1059    uint64_t mask = (1ULL &lt;&lt; 32) - 1;
1060    uint64_t a = lhs &gt;&gt; 32, b = lhs &amp; mask;
1061    uint64_t c = rhs &gt;&gt; 32, d = rhs &amp; mask;
1062    uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
1063    uint64_t mid = (bd &gt;&gt; 32) + (ad &amp; mask) + (bc &amp; mask) + (1U &lt;&lt; 31);
1064    return ac + (ad &gt;&gt; 32) + (bc &gt;&gt; 32) + (mid &gt;&gt; 32);
1065  #endif
1066  }
1067  inline fp operator*(fp x, fp y) { return {multiply(x.f, y.f), x.e + y.e + 64}; }
1068  inline fp get_cached_power(int min_exponent, int&amp; pow10_exponent) {
1069    const int shift = 32;
1070    const auto significand = static_cast&lt;int64_t&gt;(data::log10_2_significand);
1071    int index = static_cast&lt;int&gt;(
1072        ((min_exponent + fp::significand_size - 1) * (significand &gt;&gt; shift) +
1073         ((int64_t(1) &lt;&lt; shift) - 1))  
1074        &gt;&gt; 32                          
1075    );
1076    const int first_dec_exp = -348;
1077    const int dec_exp_step = 8;
1078    index = (index - first_dec_exp - 1) / dec_exp_step + 1;
1079    pow10_exponent = first_dec_exp + index * dec_exp_step;
1080    return {data::grisu_pow10_significands[index],
1081            data::grisu_pow10_exponents[index]};
1082  }
1083  struct accumulator {
1084    uint64_t lower;
1085    uint64_t upper;
1086    accumulator() : lower(0), upper(0) {}
1087    explicit operator uint32_t() const { return static_cast&lt;uint32_t&gt;(lower); }
1088    void operator+=(uint64_t n) {
1089      lower += n;
1090      if (lower &lt; n) ++upper;
1091    }
1092    void operator&gt;&gt;=(int shift) {
1093      assert(shift == 32);
1094      (void)shift;
1095      lower = (upper &lt;&lt; 32) | (lower &gt;&gt; 32);
1096      upper &gt;&gt;= 32;
1097    }
1098  };
1099  class bigint {
1100   private:
1101    using bigit = uint32_t;
1102    using double_bigit = uint64_t;
1103    enum { bigits_capacity = 32 };
1104    basic_memory_buffer&lt;bigit, bigits_capacity&gt; bigits_;
1105    int exp_;
1106    bigit operator[](int index) const { return bigits_[to_unsigned(index)]; }
1107    bigit&amp; operator[](int index) { return bigits_[to_unsigned(index)]; }
1108    static FMT_CONSTEXPR_DECL const int bigit_bits = bits&lt;bigit&gt;::value;
1109    friend struct formatter&lt;bigint&gt;;
1110    void subtract_bigits(int index, bigit other, bigit&amp; borrow) {
1111      auto result = static_cast&lt;double_bigit&gt;((*this)[index]) - other - borrow;
1112      (*this)[index] = static_cast&lt;bigit&gt;(result);
1113      borrow = static_cast&lt;bigit&gt;(result &gt;&gt; (bigit_bits * 2 - 1));
1114    }
1115    void remove_leading_zeros() {
1116      int num_bigits = static_cast&lt;int&gt;(bigits_.size()) - 1;
1117      while (num_bigits &gt; 0 &amp;&amp; (*this)[num_bigits] == 0) --num_bigits;
1118      bigits_.resize(to_unsigned(num_bigits + 1));
1119    }
1120    void subtract_aligned(const bigint&amp; other) {
1121      FMT_ASSERT(other.exp_ &gt;= exp_, &quot;unaligned bigints&quot;);
1122      FMT_ASSERT(compare(*this, other) &gt;= 0, &quot;&quot;);
1123      bigit borrow = 0;
1124      int i = other.exp_ - exp_;
1125      for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
1126        subtract_bigits(i, other.bigits_[j], borrow);
1127      while (borrow &gt; 0) subtract_bigits(i, 0, borrow);
1128      remove_leading_zeros();
1129    }
1130    void multiply(uint32_t value) {
1131      const double_bigit wide_value = value;
1132      bigit carry = 0;
1133      for (size_t i = 0, n = bigits_.size(); i &lt; n; ++i) {
1134        double_bigit result = bigits_[i] * wide_value + carry;
1135        bigits_[i] = static_cast&lt;bigit&gt;(result);
1136        carry = static_cast&lt;bigit&gt;(result &gt;&gt; bigit_bits);
1137      }
1138      if (carry != 0) bigits_.push_back(carry);
1139    }
1140    void multiply(uint64_t value) {
1141      const bigit mask = ~bigit(0);
1142      const double_bigit lower = value &amp; mask;
1143      const double_bigit upper = value &gt;&gt; bigit_bits;
1144      double_bigit carry = 0;
1145      for (size_t i = 0, n = bigits_.size(); i &lt; n; ++i) {
1146        double_bigit result = bigits_[i] * lower + (carry &amp; mask);
1147        carry =
1148            bigits_[i] * upper + (result &gt;&gt; bigit_bits) + (carry &gt;&gt; bigit_bits);
1149        bigits_[i] = static_cast&lt;bigit&gt;(result);
1150      }
1151      while (carry != 0) {
1152        bigits_.push_back(carry &amp; mask);
1153        carry &gt;&gt;= bigit_bits;
1154      }
1155    }
1156   public:
1157    bigint() : exp_(0) {}
1158    explicit bigint(uint64_t n) { assign(n); }
1159    ~bigint() { assert(bigits_.capacity() &lt;= bigits_capacity); }
1160    bigint(const bigint&amp;) = delete;
1161    void operator=(const bigint&amp;) = delete;
1162    void assign(const bigint&amp; other) {
1163      auto size = other.bigits_.size();
1164      bigits_.resize(size);
1165      auto data = other.bigits_.data();
1166      std::copy(data, data + size, make_checked(bigits_.data(), size));
1167      exp_ = other.exp_;
1168    }
1169    void assign(uint64_t n) {
1170      size_t num_bigits = 0;
1171      do {
1172        bigits_[num_bigits++] = n &amp; ~bigit(0);
1173        n &gt;&gt;= bigit_bits;
1174      } while (n != 0);
1175      bigits_.resize(num_bigits);
1176      exp_ = 0;
1177    }
1178    int num_bigits() const { return static_cast&lt;int&gt;(bigits_.size()) + exp_; }
1179    FMT_NOINLINE bigint&amp; operator&lt;&lt;=(int shift) {
1180      assert(shift &gt;= 0);
1181      exp_ += shift / bigit_bits;
1182      shift %= bigit_bits;
1183      if (shift == 0) return *this;
1184      bigit carry = 0;
1185      for (size_t i = 0, n = bigits_.size(); i &lt; n; ++i) {
1186        bigit c = bigits_[i] &gt;&gt; (bigit_bits - shift);
1187        bigits_[i] = (bigits_[i] &lt;&lt; shift) + carry;
1188        carry = c;
1189      }
1190      if (carry != 0) bigits_.push_back(carry);
1191      return *this;
1192    }
1193    template &lt;typename Int&gt; bigint&amp; operator*=(Int value) {
1194      FMT_ASSERT(value &gt; 0, &quot;&quot;);
1195      multiply(uint32_or_64_or_128_t&lt;Int&gt;(value));
1196      return *this;
1197    }
1198    friend int compare(const bigint&amp; lhs, const bigint&amp; rhs) {
1199      int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
1200      if (num_lhs_bigits != num_rhs_bigits)
1201        return num_lhs_bigits &gt; num_rhs_bigits ? 1 : -1;
1202      int i = static_cast&lt;int&gt;(lhs.bigits_.size()) - 1;
1203      int j = static_cast&lt;int&gt;(rhs.bigits_.size()) - 1;
1204      int end = i - j;
1205      if (end &lt; 0) end = 0;
1206      for (; i &gt;= end; --i, --j) {
1207        bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
1208        if (lhs_bigit != rhs_bigit) return lhs_bigit &gt; rhs_bigit ? 1 : -1;
1209      }
1210      if (i != j) return i &gt; j ? 1 : -1;
1211      return 0;
1212    }
1213    friend int add_compare(const bigint&amp; lhs1, const bigint&amp; lhs2,
1214                           const bigint&amp; rhs) {
1215      int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());
1216      int num_rhs_bigits = rhs.num_bigits();
1217      if (max_lhs_bigits + 1 &lt; num_rhs_bigits) return -1;
1218      if (max_lhs_bigits &gt; num_rhs_bigits) return 1;
1219      auto get_bigit = [](const bigint&amp; n, int i) -&gt; bigit {
1220        return i &gt;= n.exp_ &amp;&amp; i &lt; n.num_bigits() ? n[i - n.exp_] : 0;
1221      };
1222      double_bigit borrow = 0;
1223      int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
1224      for (int i = num_rhs_bigits - 1; i &gt;= min_exp; --i) {
1225        double_bigit sum =
1226            static_cast&lt;double_bigit&gt;(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
1227        bigit rhs_bigit = get_bigit(rhs, i);
1228        if (sum &gt; rhs_bigit + borrow) return 1;
1229        borrow = rhs_bigit + borrow - sum;
1230        if (borrow &gt; 1) return -1;
1231        borrow &lt;&lt;= bigit_bits;
1232      }
1233      return borrow != 0 ? -1 : 0;
1234    }
1235    void assign_pow10(int exp) {
1236      assert(exp &gt;= 0);
1237      if (exp == 0) return assign(1);
1238      int bitmask = 1;
1239      while (exp &gt;= bitmask) bitmask &lt;&lt;= 1;
1240      bitmask &gt;&gt;= 1;
1241      assign(5);
1242      bitmask &gt;&gt;= 1;
1243      while (bitmask != 0) {
1244        square();
1245        if ((exp &amp; bitmask) != 0) *this *= 5;
1246        bitmask &gt;&gt;= 1;
1247      }
1248      *this &lt;&lt;= exp;  
1249    }
1250    void square() {
1251      basic_memory_buffer&lt;bigit, bigits_capacity&gt; n(std::move(bigits_));
1252      int num_bigits = static_cast&lt;int&gt;(bigits_.size());
1253      int num_result_bigits = 2 * num_bigits;
1254      bigits_.resize(to_unsigned(num_result_bigits));
1255      using accumulator_t = conditional_t&lt;FMT_USE_INT128, uint128_t, accumulator&gt;;
1256      auto sum = accumulator_t();
1257      for (int bigit_index = 0; bigit_index &lt; num_bigits; ++bigit_index) {
1258        for (int i = 0, j = bigit_index; j &gt;= 0; ++i, --j) {
1259          sum += static_cast&lt;double_bigit&gt;(n[i]) * n[j];
1260        }
1261        (*this)[bigit_index] = static_cast&lt;bigit&gt;(sum);
1262        sum &gt;&gt;= bits&lt;bigit&gt;::value;  
1263      }
1264      for (int bigit_index = num_bigits; bigit_index &lt; num_result_bigits;
1265           ++bigit_index) {
1266        for (int j = num_bigits - 1, i = bigit_index - j; i &lt; num_bigits;)
1267          sum += static_cast&lt;double_bigit&gt;(n[i++]) * n[j--];
1268        (*this)[bigit_index] = static_cast&lt;bigit&gt;(sum);
1269        sum &gt;&gt;= bits&lt;bigit&gt;::value;
1270      }
1271      --num_result_bigits;
1272      remove_leading_zeros();
1273      exp_ *= 2;
1274    }
1275    void align(const bigint&amp; other) {
1276      int exp_difference = exp_ - other.exp_;
1277      if (exp_difference &lt;= 0) return;
1278      int num_bigits = static_cast&lt;int&gt;(bigits_.size());
1279      bigits_.resize(to_unsigned(num_bigits + exp_difference));
1280      for (int i = num_bigits - 1, j = i + exp_difference; i &gt;= 0; --i, --j)
1281        bigits_[j] = bigits_[i];
1282      std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
1283      exp_ -= exp_difference;
1284    }
1285    int divmod_assign(const bigint&amp; divisor) {
1286      FMT_ASSERT(this != &amp;divisor, &quot;&quot;);
1287      if (compare(*this, divisor) &lt; 0) return 0;
1288      FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, &quot;&quot;);
1289      align(divisor);
1290      int quotient = 0;
1291      do {
1292        subtract_aligned(divisor);
1293        ++quotient;
1294      } while (compare(*this, divisor) &gt;= 0);
1295      return quotient;
1296    }
1297  };
1298  enum class round_direction { unknown, up, down };
1299  inline round_direction get_round_direction(uint64_t divisor, uint64_t remainder,
1300                                             uint64_t error) {
1301    FMT_ASSERT(remainder &lt; divisor, &quot;&quot;);  
1302    FMT_ASSERT(error &lt; divisor, &quot;&quot;);      
1303    FMT_ASSERT(error &lt; divisor - error, &quot;&quot;);  
1304    if (remainder &lt;= divisor - remainder &amp;&amp; error * 2 &lt;= divisor - remainder * 2)
1305      return round_direction::down;
1306    if (remainder &gt;= error &amp;&amp;
1307        remainder - error &gt;= divisor - (remainder - error)) {
1308      return round_direction::up;
1309    }
1310    return round_direction::unknown;
1311  }
1312  namespace digits {
1313  enum result {
1314    more,  
1315    done,  
1316    error  
1317  };
1318  }
1319  template &lt;typename Handler&gt;
1320  FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
1321                                                    int&amp; exp, Handler&amp; handler) {
1322    const fp one(1ULL &lt;&lt; -value.e, value.e);
1323    auto integral = static_cast&lt;uint32_t&gt;(value.f &gt;&gt; -one.e);
1324    FMT_ASSERT(integral != 0, &quot;&quot;);
1325    FMT_ASSERT(integral == value.f &gt;&gt; -one.e, &quot;&quot;);
1326    uint64_t fractional = value.f &amp; (one.f - 1);
1327    exp = count_digits(integral);  
1328    auto result = handler.on_start(data::powers_of_10_64[exp - 1] &lt;&lt; -one.e,
1329                                   value.f / 10, error * 10, exp);
1330    if (result != digits::more) return result;
1331    do {
1332      uint32_t digit = 0;
1333      auto divmod_integral = [&amp;](uint32_t divisor) {
1334        digit = integral / divisor;
1335        integral %= divisor;
1336      };
1337      switch (exp) {
1338      case 10:
1339        divmod_integral(1000000000);
1340        break;
1341      case 9:
1342        divmod_integral(100000000);
1343        break;
1344      case 8:
1345        divmod_integral(10000000);
1346        break;
1347      case 7:
1348        divmod_integral(1000000);
1349        break;
1350      case 6:
1351        divmod_integral(100000);
1352        break;
1353      case 5:
1354        divmod_integral(10000);
1355        break;
1356      case 4:
1357        divmod_integral(1000);
1358        break;
1359      case 3:
1360        divmod_integral(100);
1361        break;
1362      case 2:
1363        divmod_integral(10);
1364        break;
1365      case 1:
1366        digit = integral;
1367        integral = 0;
1368        break;
1369      default:
1370        FMT_ASSERT(false, &quot;invalid number of digits&quot;);
1371      }
1372      --exp;
1373      auto remainder = (static_cast&lt;uint64_t&gt;(integral) &lt;&lt; -one.e) + fractional;
1374      result = handler.on_digit(static_cast&lt;char&gt;(&#x27;0&#x27; + digit),
1375                                data::powers_of_10_64[exp] &lt;&lt; -one.e, remainder,
1376                                error, exp, true);
1377      if (result != digits::more) return result;
1378    } while (exp &gt; 0);
1379    for (;;) {
1380      fractional *= 10;
1381      error *= 10;
1382      char digit = static_cast&lt;char&gt;(&#x27;0&#x27; + (fractional &gt;&gt; -one.e));
1383      fractional &amp;= one.f - 1;
1384      --exp;
1385      result = handler.on_digit(digit, one.f, fractional, error, exp, false);
1386      if (result != digits::more) return result;
1387    }
1388  }
1389  struct fixed_handler {
1390    char* buf;
1391    int size;
1392    int precision;
1393    int exp10;
1394    bool fixed;
1395    digits::result on_start(uint64_t divisor, uint64_t remainder, uint64_t error,
1396                            int&amp; exp) {
1397      if (!fixed) return digits::more;
1398      precision += exp + exp10;
1399      if (precision &gt; 0) return digits::more;
1400      if (precision &lt; 0) return digits::done;
1401      auto dir = get_round_direction(divisor, remainder, error);
1402      if (dir == round_direction::unknown) return digits::error;
1403      buf[size++] = dir == round_direction::up ? &#x27;1&#x27; : &#x27;0&#x27;;
1404      return digits::done;
1405    }
1406    digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,
1407                            uint64_t error, int, bool integral) {
1408      FMT_ASSERT(remainder &lt; divisor, &quot;&quot;);
1409      buf[size++] = digit;
1410      if (!integral &amp;&amp; error &gt;= remainder) return digits::error;
1411      if (size &lt; precision) return digits::more;
1412      if (!integral) {
1413        if (error &gt;= divisor || error &gt;= divisor - error) return digits::error;
1414      } else {
1415        FMT_ASSERT(error == 1 &amp;&amp; divisor &gt; 2, &quot;&quot;);
1416      }
1417      auto dir = get_round_direction(divisor, remainder, error);
1418      if (dir != round_direction::up)
1419        return dir == round_direction::down ? digits::done : digits::error;
1420      ++buf[size - 1];
1421      for (int i = size - 1; i &gt; 0 &amp;&amp; buf[i] &gt; &#x27;9&#x27;; --i) {
1422        buf[i] = &#x27;0&#x27;;
1423        ++buf[i - 1];
1424      }
1425      if (buf[0] &gt; &#x27;9&#x27;) {
1426        buf[0] = &#x27;1&#x27;;
1427        if (fixed) buf[size++] = &#x27;0&#x27;;
1428        else ++exp10;
1429      }
1430      return digits::done;
1431    }
1432  };
1433  namespace dragonbox {
1434  FMT_SAFEBUFFERS inline uint128_wrapper umul128(uint64_t x,
1435                                                 uint64_t y) FMT_NOEXCEPT {
1436  #if FMT_USE_INT128
1437    return static_cast&lt;uint128_t&gt;(x) * static_cast&lt;uint128_t&gt;(y);
1438  #elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
1439    uint128_wrapper result;
1440    result.low_ = _umul128(x, y, &amp;result.high_);
1441    return result;
1442  #else
1443    const uint64_t mask = (uint64_t(1) &lt;&lt; 32) - uint64_t(1);
1444    uint64_t a = x &gt;&gt; 32;
1445    uint64_t b = x &amp; mask;
1446    uint64_t c = y &gt;&gt; 32;
1447    uint64_t d = y &amp; mask;
1448    uint64_t ac = a * c;
1449    uint64_t bc = b * c;
1450    uint64_t ad = a * d;
1451    uint64_t bd = b * d;
1452    uint64_t intermediate = (bd &gt;&gt; 32) + (ad &amp; mask) + (bc &amp; mask);
1453    return {ac + (intermediate &gt;&gt; 32) + (ad &gt;&gt; 32) + (bc &gt;&gt; 32),
1454            (intermediate &lt;&lt; 32) + (bd &amp; mask)};
1455  #endif
1456  }
1457  FMT_SAFEBUFFERS inline uint64_t umul128_upper64(uint64_t x,
1458                                                  uint64_t y) FMT_NOEXCEPT {
1459  #if FMT_USE_INT128
1460    auto p = static_cast&lt;uint128_t&gt;(x) * static_cast&lt;uint128_t&gt;(y);
1461    return static_cast&lt;uint64_t&gt;(p &gt;&gt; 64);
1462  #elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
1463    return __umulh(x, y);
1464  #else
1465    return umul128(x, y).high();
1466  #endif
1467  }
1468  FMT_SAFEBUFFERS inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y)
1469      FMT_NOEXCEPT {
1470    uint128_wrapper g0 = umul128(x, y.high());
1471    g0 += umul128_upper64(x, y.low());
1472    return g0.high();
1473  }
1474  inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1475    return static_cast&lt;uint32_t&gt;(umul128_upper64(x, y));
1476  }
1477  FMT_SAFEBUFFERS inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y)
1478      FMT_NOEXCEPT {
1479    uint64_t g01 = x * y.high();
1480    uint64_t g10 = umul128_upper64(x, y.low());
1481    return g01 + g10;
1482  }
1483  inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1484    return x * y;
1485  }
1486  inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
1487    FMT_ASSERT(e &lt;= 1700 &amp;&amp; e &gt;= -1700, &quot;too large exponent&quot;);
1488    const int shift = 22;
1489    return (e * static_cast&lt;int&gt;(data::log10_2_significand &gt;&gt; (64 - shift))) &gt;&gt;
1490           shift;
1491  }
1492  inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
1493    FMT_ASSERT(e &lt;= 1233 &amp;&amp; e &gt;= -1233, &quot;too large exponent&quot;);
1494    const uint64_t log2_10_integer_part = 3;
1495    const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
1496    const int shift_amount = 19;
1497    return (e * static_cast&lt;int&gt;(
1498                    (log2_10_integer_part &lt;&lt; shift_amount) |
1499                    (log2_10_fractional_digits &gt;&gt; (64 - shift_amount)))) &gt;&gt;
1500           shift_amount;
1501  }
1502  inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
1503    FMT_ASSERT(e &lt;= 1700 &amp;&amp; e &gt;= -1700, &quot;too large exponent&quot;);
1504    const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
1505    const int shift_amount = 22;
1506    return (e * static_cast&lt;int&gt;(data::log10_2_significand &gt;&gt;
1507                                 (64 - shift_amount)) -
1508            static_cast&lt;int&gt;(log10_4_over_3_fractional_digits &gt;&gt;
1509                             (64 - shift_amount))) &gt;&gt;
1510           shift_amount;
1511  }
1512  inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
1513    FMT_ASSERT(exp &gt;= 1, &quot;&quot;);
1514    FMT_ASSERT(x != 0, &quot;&quot;);
1515  #ifdef FMT_BUILTIN_CTZ
1516    return FMT_BUILTIN_CTZ(x) &gt;= exp;
1517  #else
1518    return exp &lt; num_bits&lt;uint32_t&gt;() &amp;&amp; x == ((x &gt;&gt; exp) &lt;&lt; exp);
1519  #endif
1520  }
1521  inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
1522    FMT_ASSERT(exp &gt;= 1, &quot;&quot;);
1523    FMT_ASSERT(x != 0, &quot;&quot;);
1524  #ifdef FMT_BUILTIN_CTZLL
1525    return FMT_BUILTIN_CTZLL(x) &gt;= exp;
1526  #else
1527    return (exp &lt; num_bits&lt;uint64_t&gt;()) &amp;&amp; x == ((x &gt;&gt; exp) &lt;&lt; exp);
1528  #endif
1529  }
1530  inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
1531    FMT_ASSERT(exp &lt;= 10, &quot;too large exponent&quot;);
1532    return x * data::divtest_table_for_pow5_32[exp].mod_inv &lt;=
1533           data::divtest_table_for_pow5_32[exp].max_quotient;
1534  }
1535  inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
1536    FMT_ASSERT(exp &lt;= 23, &quot;too large exponent&quot;);
1537    return x * data::divtest_table_for_pow5_64[exp].mod_inv &lt;=
1538           data::divtest_table_for_pow5_64[exp].max_quotient;
1539  }
1540  template &lt;int N&gt;
1541  bool check_divisibility_and_divide_by_pow5(uint32_t&amp; n) FMT_NOEXCEPT {
1542    static constexpr struct {
1543      uint32_t magic_number;
1544      int bits_for_comparison;
1545      uint32_t threshold;
1546      int shift_amount;
1547    } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};
1548    constexpr auto info = infos[N - 1];
1549    n *= info.magic_number;
1550    const uint32_t comparison_mask = (1u &lt;&lt; info.bits_for_comparison) - 1;
1551    bool result = (n &amp; comparison_mask) &lt;= info.threshold;
1552    n &gt;&gt;= info.shift_amount;
1553    return result;
1554  }
1555  template &lt;int N&gt; uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
1556    static constexpr struct {
1557      uint32_t magic_number;
1558      int shift_amount;
1559      uint32_t divisor_times_10;
1560    } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
1561    constexpr auto info = infos[N - 1];
1562    FMT_ASSERT(n &lt;= info.divisor_times_10, &quot;n is too large&quot;);
1563    return n * info.magic_number &gt;&gt; info.shift_amount;
1564  }
1565  inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
1566    return n / float_info&lt;float&gt;::big_divisor;
1567  }
1568  inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
1569    return umul128_upper64(n, 0x83126e978d4fdf3c) &gt;&gt; 9;
1570  }
1571  template &lt;class T&gt; struct cache_accessor;
1572  template &lt;&gt; struct cache_accessor&lt;float&gt; {
1573    using carrier_uint = float_info&lt;float&gt;::carrier_uint;
1574    using cache_entry_type = uint64_t;
1575    static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
1576      FMT_ASSERT(k &gt;= float_info&lt;float&gt;::min_k &amp;&amp; k &lt;= float_info&lt;float&gt;::max_k,
1577                 &quot;k is out of range&quot;);
1578      return data::dragonbox_pow10_significands_64[k - float_info&lt;float&gt;::min_k];
1579    }
1580    static carrier_uint compute_mul(carrier_uint u,
1581                                    const cache_entry_type&amp; cache) FMT_NOEXCEPT {
1582      return umul96_upper32(u, cache);
1583    }
1584    static uint32_t compute_delta(const cache_entry_type&amp; cache,
1585                                  int beta_minus_1) FMT_NOEXCEPT {
1586      return static_cast&lt;uint32_t&gt;(cache &gt;&gt; (64 - 1 - beta_minus_1));
1587    }
1588    static bool compute_mul_parity(carrier_uint two_f,
1589                                   const cache_entry_type&amp; cache,
1590                                   int beta_minus_1) FMT_NOEXCEPT {
1591      FMT_ASSERT(beta_minus_1 &gt;= 1, &quot;&quot;);
1592      FMT_ASSERT(beta_minus_1 &lt; 64, &quot;&quot;);
1593      return ((umul96_lower64(two_f, cache) &gt;&gt; (64 - beta_minus_1)) &amp; 1) != 0;
1594    }
1595    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1596        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1597      return static_cast&lt;carrier_uint&gt;(
1598          (cache - (cache &gt;&gt; (float_info&lt;float&gt;::significand_bits + 2))) &gt;&gt;
1599          (64 - float_info&lt;float&gt;::significand_bits - 1 - beta_minus_1));
1600    }
1601    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1602        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1603      return static_cast&lt;carrier_uint&gt;(
1604          (cache + (cache &gt;&gt; (float_info&lt;float&gt;::significand_bits + 1))) &gt;&gt;
1605          (64 - float_info&lt;float&gt;::significand_bits - 1 - beta_minus_1));
1606    }
1607    static carrier_uint compute_round_up_for_shorter_interval_case(
1608        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1609      return (static_cast&lt;carrier_uint&gt;(
1610                  cache &gt;&gt;
1611                  (64 - float_info&lt;float&gt;::significand_bits - 2 - beta_minus_1)) +
1612              1) /
1613             2;
1614    }
1615  };
1616  template &lt;&gt; struct cache_accessor&lt;double&gt; {
1617    using carrier_uint = float_info&lt;double&gt;::carrier_uint;
1618    using cache_entry_type = uint128_wrapper;
1619    static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
1620      FMT_ASSERT(k &gt;= float_info&lt;double&gt;::min_k &amp;&amp; k &lt;= float_info&lt;double&gt;::max_k,
1621                 &quot;k is out of range&quot;);
1622  #if FMT_USE_FULL_CACHE_DRAGONBOX
1623      return data::dragonbox_pow10_significands_128[k -
1624                                                    float_info&lt;double&gt;::min_k];
1625  #else
1626      static const int compression_ratio = 27;
1627      int cache_index = (k - float_info&lt;double&gt;::min_k) / compression_ratio;
1628      int kb = cache_index * compression_ratio + float_info&lt;double&gt;::min_k;
1629      int offset = k - kb;
1630      uint128_wrapper base_cache =
1631          data::dragonbox_pow10_significands_128[cache_index];
1632      if (offset == 0) return base_cache;
1633      int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
1634      FMT_ASSERT(alpha &gt; 0 &amp;&amp; alpha &lt; 64, &quot;shifting error detected&quot;);
1635      uint64_t pow5 = data::powers_of_5_64[offset];
1636      uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);
1637      uint128_wrapper middle_low =
1638          umul128(base_cache.low() - (kb &lt; 0 ? 1 : 0), pow5);
1639      recovered_cache += middle_low.high();
1640      uint64_t high_to_middle = recovered_cache.high() &lt;&lt; (64 - alpha);
1641      uint64_t middle_to_low = recovered_cache.low() &lt;&lt; (64 - alpha);
1642      recovered_cache =
1643          uint128_wrapper{(recovered_cache.low() &gt;&gt; alpha) | high_to_middle,
1644                          ((middle_low.low() &gt;&gt; alpha) | middle_to_low)};
1645      if (kb &lt; 0) recovered_cache += 1;
1646      int error_idx = (k - float_info&lt;double&gt;::min_k) / 16;
1647      uint32_t error = (data::dragonbox_pow10_recovery_errors[error_idx] &gt;&gt;
1648                        ((k - float_info&lt;double&gt;::min_k) % 16) * 2) &amp;
1649                       0x3;
1650      FMT_ASSERT(recovered_cache.low() + error &gt;= recovered_cache.low(), &quot;&quot;);
1651      return {recovered_cache.high(), recovered_cache.low() + error};
1652  #endif
1653    }
1654    static carrier_uint compute_mul(carrier_uint u,
1655                                    const cache_entry_type&amp; cache) FMT_NOEXCEPT {
1656      return umul192_upper64(u, cache);
1657    }
1658    static uint32_t compute_delta(cache_entry_type const&amp; cache,
1659                                  int beta_minus_1) FMT_NOEXCEPT {
1660      return static_cast&lt;uint32_t&gt;(cache.high() &gt;&gt; (64 - 1 - beta_minus_1));
1661    }
1662    static bool compute_mul_parity(carrier_uint two_f,
1663                                   const cache_entry_type&amp; cache,
1664                                   int beta_minus_1) FMT_NOEXCEPT {
1665      FMT_ASSERT(beta_minus_1 &gt;= 1, &quot;&quot;);
1666      FMT_ASSERT(beta_minus_1 &lt; 64, &quot;&quot;);
1667      return ((umul192_middle64(two_f, cache) &gt;&gt; (64 - beta_minus_1)) &amp; 1) != 0;
1668    }
1669    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1670        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1671      return (cache.high() -
1672              (cache.high() &gt;&gt; (float_info&lt;double&gt;::significand_bits + 2))) &gt;&gt;
1673             (64 - float_info&lt;double&gt;::significand_bits - 1 - beta_minus_1);
1674    }
1675    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1676        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1677      return (cache.high() +
1678              (cache.high() &gt;&gt; (float_info&lt;double&gt;::significand_bits + 1))) &gt;&gt;
1679             (64 - float_info&lt;double&gt;::significand_bits - 1 - beta_minus_1);
1680    }
1681    static carrier_uint compute_round_up_for_shorter_interval_case(
1682        const cache_entry_type&amp; cache, int beta_minus_1) FMT_NOEXCEPT {
1683      return ((cache.high() &gt;&gt;
1684               (64 - float_info&lt;double&gt;::significand_bits - 2 - beta_minus_1)) +
1685              1) /
1686             2;
1687    }
1688  };
1689  template &lt;class T&gt;
1690  bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
1691    return exponent &gt;=
1692               float_info&lt;
1693                   T&gt;::case_shorter_interval_left_endpoint_lower_threshold &amp;&amp;
1694           exponent &lt;=
1695               float_info&lt;T&gt;::case_shorter_interval_left_endpoint_upper_threshold;
1696  }
1697  template &lt;class T&gt;
1698  bool is_endpoint_integer(typename float_info&lt;T&gt;::carrier_uint two_f,
1699                           int exponent, int minus_k) FMT_NOEXCEPT {
1700    if (exponent &lt; float_info&lt;T&gt;::case_fc_pm_half_lower_threshold) return false;
1701    if (exponent &lt;= float_info&lt;T&gt;::case_fc_pm_half_upper_threshold) return true;
1702    if (exponent &gt; float_info&lt;T&gt;::divisibility_check_by_5_threshold) return false;
1703    return divisible_by_power_of_5(two_f, minus_k);
1704  }
1705  template &lt;class T&gt;
1706  bool is_center_integer(typename float_info&lt;T&gt;::carrier_uint two_f, int exponent,
1707                         int minus_k) FMT_NOEXCEPT {
1708    if (exponent &gt; float_info&lt;T&gt;::divisibility_check_by_5_threshold) return false;
1709    if (exponent &gt; float_info&lt;T&gt;::case_fc_upper_threshold)
1710      return divisible_by_power_of_5(two_f, minus_k);
1711    if (exponent &gt;= float_info&lt;T&gt;::case_fc_lower_threshold) return true;
1712    return divisible_by_power_of_2(two_f, minus_k - exponent + 1);
1713  }
1714  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t&amp; n) FMT_NOEXCEPT {
1715  #ifdef FMT_BUILTIN_CTZ
1716    int t = FMT_BUILTIN_CTZ(n);
1717  #else
1718    int t = ctz(n);
1719  #endif
1720    if (t &gt; float_info&lt;float&gt;::max_trailing_zeros)
1721      t = float_info&lt;float&gt;::max_trailing_zeros;
1722    const uint32_t mod_inv1 = 0xcccccccd;
1723    const uint32_t max_quotient1 = 0x33333333;
1724    const uint32_t mod_inv2 = 0xc28f5c29;
1725    const uint32_t max_quotient2 = 0x0a3d70a3;
1726    int s = 0;
1727    for (; s &lt; t - 1; s += 2) {
1728      if (n * mod_inv2 &gt; max_quotient2) break;
1729      n *= mod_inv2;
1730    }
1731    if (s &lt; t &amp;&amp; n * mod_inv1 &lt;= max_quotient1) {
1732      n *= mod_inv1;
1733      ++s;
1734    }
1735    n &gt;&gt;= s;
1736    return s;
1737  }
1738  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t&amp; n) FMT_NOEXCEPT {
1739  #ifdef FMT_BUILTIN_CTZLL
1740    int t = FMT_BUILTIN_CTZLL(n);
1741  #else
1742    int t = ctzll(n);
1743  #endif
1744    if (t &gt; float_info&lt;double&gt;::max_trailing_zeros)
1745      t = float_info&lt;double&gt;::max_trailing_zeros;
1746    const uint32_t mod_inv1 = 0xcccccccd;
1747    const uint32_t max_quotient1 = 0x33333333;
1748    const uint64_t mod_inv8 = 0xc767074b22e90e21;
1749    const uint64_t max_quotient8 = 0x00002af31dc46118;
1750    if (t &gt;= 8) {
1751      auto quotient_candidate = n * mod_inv8;
1752      if (quotient_candidate &lt;= max_quotient8) {
1753        auto quotient = static_cast&lt;uint32_t&gt;(quotient_candidate &gt;&gt; 8);
1754        int s = 8;
1755        for (; s &lt; t; ++s) {
1756          if (quotient * mod_inv1 &gt; max_quotient1) break;
1757          quotient *= mod_inv1;
1758        }
1759        quotient &gt;&gt;= (s - 8);
1760        n = quotient;
1761        return s;
1762      }
1763    }
1764    auto quotient = static_cast&lt;uint32_t&gt;(n / 100000000);
1765    auto remainder = static_cast&lt;uint32_t&gt;(n - 100000000 * quotient);
1766    if (t == 0 || remainder * mod_inv1 &gt; max_quotient1) {
1767      return 0;
1768    }
1769    remainder *= mod_inv1;
1770    if (t == 1 || remainder * mod_inv1 &gt; max_quotient1) {
1771      n = (remainder &gt;&gt; 1) + quotient * 10000000ull;
1772      return 1;
1773    }
1774    remainder *= mod_inv1;
1775    if (t == 2 || remainder * mod_inv1 &gt; max_quotient1) {
1776      n = (remainder &gt;&gt; 2) + quotient * 1000000ull;
1777      return 2;
1778    }
1779    remainder *= mod_inv1;
1780    if (t == 3 || remainder * mod_inv1 &gt; max_quotient1) {
1781      n = (remainder &gt;&gt; 3) + quotient * 100000ull;
1782      return 3;
1783    }
1784    remainder *= mod_inv1;
1785    if (t == 4 || remainder * mod_inv1 &gt; max_quotient1) {
1786      n = (remainder &gt;&gt; 4) + quotient * 10000ull;
1787      return 4;
1788    }
1789    remainder *= mod_inv1;
1790    if (t == 5 || remainder * mod_inv1 &gt; max_quotient1) {
1791      n = (remainder &gt;&gt; 5) + quotient * 1000ull;
1792      return 5;
1793    }
1794    remainder *= mod_inv1;
1795    if (t == 6 || remainder * mod_inv1 &gt; max_quotient1) {
1796      n = (remainder &gt;&gt; 6) + quotient * 100ull;
1797      return 6;
1798    }
1799    remainder *= mod_inv1;
1800    n = (remainder &gt;&gt; 7) + quotient * 10ull;
1801    return 7;
1802  }
1803  template &lt;class T&gt;
1804  FMT_ALWAYS_INLINE FMT_SAFEBUFFERS decimal_fp&lt;T&gt; shorter_interval_case(
1805      int exponent) FMT_NOEXCEPT {
1806    decimal_fp&lt;T&gt; ret_value;
1807    const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
1808    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1809    using cache_entry_type = typename cache_accessor&lt;T&gt;::cache_entry_type;
1810    const cache_entry_type cache = cache_accessor&lt;T&gt;::get_cached_power(-minus_k);
1811    auto xi = cache_accessor&lt;T&gt;::compute_left_endpoint_for_shorter_interval_case(
1812        cache, beta_minus_1);
1813    auto zi = cache_accessor&lt;T&gt;::compute_right_endpoint_for_shorter_interval_case(
1814        cache, beta_minus_1);
1815    if (!is_left_endpoint_integer_shorter_interval&lt;T&gt;(exponent)) ++xi;
1816    ret_value.significand = zi / 10;
1817    if (ret_value.significand * 10 &gt;= xi) {
1818      ret_value.exponent = minus_k + 1;
1819      ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1820      return ret_value;
1821    }
1822    ret_value.significand =
1823        cache_accessor&lt;T&gt;::compute_round_up_for_shorter_interval_case(
1824            cache, beta_minus_1);
1825    ret_value.exponent = minus_k;
1826    if (exponent &gt;= float_info&lt;T&gt;::shorter_interval_tie_lower_threshold &amp;&amp;
1827        exponent &lt;= float_info&lt;T&gt;::shorter_interval_tie_upper_threshold) {
1828      ret_value.significand = ret_value.significand % 2 == 0
1829                                  ? ret_value.significand
1830                                  : ret_value.significand - 1;
1831    } else if (ret_value.significand &lt; xi) {
1832      ++ret_value.significand;
1833    }
1834    return ret_value;
1835  }
1836  template &lt;typename T&gt;
1837  FMT_SAFEBUFFERS decimal_fp&lt;T&gt; to_decimal(T x) FMT_NOEXCEPT {
1838    using carrier_uint = typename float_info&lt;T&gt;::carrier_uint;
1839    using cache_entry_type = typename cache_accessor&lt;T&gt;::cache_entry_type;
1840    auto br = bit_cast&lt;carrier_uint&gt;(x);
1841    const carrier_uint significand_mask =
1842        (static_cast&lt;carrier_uint&gt;(1) &lt;&lt; float_info&lt;T&gt;::significand_bits) - 1;
1843    carrier_uint significand = (br &amp; significand_mask);
1844    const carrier_uint exponent_mask =
1845        ((static_cast&lt;carrier_uint&gt;(1) &lt;&lt; float_info&lt;T&gt;::exponent_bits) - 1)
1846        &lt;&lt; float_info&lt;T&gt;::significand_bits;
1847    int exponent =
1848        static_cast&lt;int&gt;((br &amp; exponent_mask) &gt;&gt; float_info&lt;T&gt;::significand_bits);
1849    if (exponent != 0) {  
1850      exponent += float_info&lt;T&gt;::exponent_bias - float_info&lt;T&gt;::significand_bits;
1851      if (significand == 0) return shorter_interval_case&lt;T&gt;(exponent);
1852      significand |=
1853          (static_cast&lt;carrier_uint&gt;(1) &lt;&lt; float_info&lt;T&gt;::significand_bits);
1854    } else {
1855      if (significand == 0) return {0, 0};
1856      exponent = float_info&lt;T&gt;::min_exponent - float_info&lt;T&gt;::significand_bits;
1857    }
1858    const bool include_left_endpoint = (significand % 2 == 0);
1859    const bool include_right_endpoint = include_left_endpoint;
1860    const int minus_k = floor_log10_pow2(exponent) - float_info&lt;T&gt;::kappa;
1861    const cache_entry_type cache = cache_accessor&lt;T&gt;::get_cached_power(-minus_k);
1862    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1863    const uint32_t deltai = cache_accessor&lt;T&gt;::compute_delta(cache, beta_minus_1);
1864    const carrier_uint two_fc = significand &lt;&lt; 1;
1865    const carrier_uint two_fr = two_fc | 1;
1866    const carrier_uint zi =
1867        cache_accessor&lt;T&gt;::compute_mul(two_fr &lt;&lt; beta_minus_1, cache);
1868    decimal_fp&lt;T&gt; ret_value;
1869    ret_value.significand = divide_by_10_to_kappa_plus_1(zi);
1870    uint32_t r = static_cast&lt;uint32_t&gt;(zi - float_info&lt;T&gt;::big_divisor *
1871                                                ret_value.significand);
1872    if (r &gt; deltai) {
1873      goto small_divisor_case_label;
1874    } else if (r &lt; deltai) {
1875      if (r == 0 &amp;&amp; !include_right_endpoint &amp;&amp;
1876          is_endpoint_integer&lt;T&gt;(two_fr, exponent, minus_k)) {
1877        --ret_value.significand;
1878        r = float_info&lt;T&gt;::big_divisor;
1879        goto small_divisor_case_label;
1880      }
1881    } else {
1882      const carrier_uint two_fl = two_fc - 1;
1883      if ((!include_left_endpoint ||
1884           !is_endpoint_integer&lt;T&gt;(two_fl, exponent, minus_k)) &amp;&amp;
1885          !cache_accessor&lt;T&gt;::compute_mul_parity(two_fl, cache, beta_minus_1)) {
1886        goto small_divisor_case_label;
1887      }
1888    }
1889    ret_value.exponent = minus_k + float_info&lt;T&gt;::kappa + 1;
1890    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1891    return ret_value;
1892  small_divisor_case_label:
1893    ret_value.significand *= 10;
1894    ret_value.exponent = minus_k + float_info&lt;T&gt;::kappa;
1895    const uint32_t mask = (1u &lt;&lt; float_info&lt;T&gt;::kappa) - 1;
1896    auto dist = r - (deltai / 2) + (float_info&lt;T&gt;::small_divisor / 2);
1897    if ((dist &amp; mask) == 0) {
1898      const bool approx_y_parity =
1899          ((dist ^ (float_info&lt;T&gt;::small_divisor / 2)) &amp; 1) != 0;
1900      dist &gt;&gt;= float_info&lt;T&gt;::kappa;
1901      if (check_divisibility_and_divide_by_pow5&lt;float_info&lt;T&gt;::kappa&gt;(dist)) {
1902        ret_value.significand += dist;
1903        if (cache_accessor&lt;T&gt;::compute_mul_parity(two_fc, cache, beta_minus_1) !=
1904            approx_y_parity) {
1905          --ret_value.significand;
1906        } else {
1907          if (is_center_integer&lt;T&gt;(two_fc, exponent, minus_k)) {
1908            ret_value.significand = ret_value.significand % 2 == 0
1909                                        ? ret_value.significand
1910                                        : ret_value.significand - 1;
1911          }
1912        }
1913      }
1914      else {
1915        ret_value.significand += dist;
1916      }
1917    }
1918    else {
1919      ret_value.significand +=
1920          small_division_by_pow10&lt;float_info&lt;T&gt;::kappa&gt;(dist);
1921    }
1922    return ret_value;
1923  }
1924  }  
1925  template &lt;typename Double&gt;
1926  void fallback_format(Double d, int num_digits, bool binary32, buffer&lt;char&gt;&amp; buf,
1927                       int&amp; exp10) {
1928    bigint numerator;    
1929    bigint denominator;  
1930    bigint lower;             
1931    bigint upper_store;       
1932    bigint* upper = nullptr;  
1933    fp value;
1934    const bool is_predecessor_closer =
1935        binary32 ? value.assign(static_cast&lt;float&gt;(d)) : value.assign(d);
1936    int shift = is_predecessor_closer ? 2 : 1;
1937    uint64_t significand = value.f &lt;&lt; shift;
1938    if (value.e &gt;= 0) {
1939      numerator.assign(significand);
1940      numerator &lt;&lt;= value.e;
1941      lower.assign(1);
1942      lower &lt;&lt;= value.e;
1943      if (shift != 1) {
1944        upper_store.assign(1);
1945        upper_store &lt;&lt;= value.e + 1;
1946        upper = &amp;upper_store;
1947      }
1948      denominator.assign_pow10(exp10);
1949      denominator &lt;&lt;= 1;
1950    } else if (exp10 &lt; 0) {
1951      numerator.assign_pow10(-exp10);
1952      lower.assign(numerator);
1953      if (shift != 1) {
1954        upper_store.assign(numerator);
1955        upper_store &lt;&lt;= 1;
1956        upper = &amp;upper_store;
1957      }
1958      numerator *= significand;
1959      denominator.assign(1);
1960      denominator &lt;&lt;= shift - value.e;
1961    } else {
1962      numerator.assign(significand);
1963      denominator.assign_pow10(exp10);
1964      denominator &lt;&lt;= shift - value.e;
1965      lower.assign(1);
1966      if (shift != 1) {
1967        upper_store.assign(1ULL &lt;&lt; 1);
1968        upper = &amp;upper_store;
1969      }
1970    }
1971    if (num_digits &lt; 0) {
1972      if (!upper) upper = &amp;lower;
1973      bool even = (value.f &amp; 1) == 0;
1974      num_digits = 0;
1975      char* data = buf.data();
1976      for (;;) {
1977        int digit = numerator.divmod_assign(denominator);
1978        bool low = compare(numerator, lower) - even &lt; 0;  
1979        bool high = add_compare(numerator, *upper, denominator) + even &gt; 0;
1980        data[num_digits++] = static_cast&lt;char&gt;(&#x27;0&#x27; + digit);
1981        if (low || high) {
1982          if (!low) {
1983            ++data[num_digits - 1];
1984          } else if (high) {
1985            int result = add_compare(numerator, numerator, denominator);
1986            if (result &gt; 0 || (result == 0 &amp;&amp; (digit % 2) != 0))
1987              ++data[num_digits - 1];
1988          }
1989          buf.try_resize(to_unsigned(num_digits));
1990          exp10 -= num_digits - 1;
1991          return;
1992        }
1993        numerator *= 10;
1994        lower *= 10;
1995        if (upper != &amp;lower) *upper *= 10;
1996      }
1997    }
1998    exp10 -= num_digits - 1;
1999    if (num_digits == 0) {
2000      buf.try_resize(1);
2001      denominator *= 10;
2002      buf[0] = add_compare(numerator, numerator, denominator) &gt; 0 ? &#x27;1&#x27; : &#x27;0&#x27;;
2003      return;
2004    }
2005    buf.try_resize(to_unsigned(num_digits));
2006    for (int i = 0; i &lt; num_digits - 1; ++i) {
2007      int digit = numerator.divmod_assign(denominator);
2008      buf[i] = static_cast&lt;char&gt;(&#x27;0&#x27; + digit);
2009      numerator *= 10;
2010    }
2011    int digit = numerator.divmod_assign(denominator);
2012    auto result = add_compare(numerator, numerator, denominator);
2013    if (result &gt; 0 || (result == 0 &amp;&amp; (digit % 2) != 0)) {
2014      if (digit == 9) {
2015        const auto overflow = &#x27;0&#x27; + 10;
2016        buf[num_digits - 1] = overflow;
2017        for (int i = num_digits - 1; i &gt; 0 &amp;&amp; buf[i] == overflow; --i) {
2018          buf[i] = &#x27;0&#x27;;
2019          ++buf[i - 1];
2020        }
2021        if (buf[0] == overflow) {
2022          buf[0] = &#x27;1&#x27;;
2023          ++exp10;
2024        }
2025        return;
2026      }
2027      ++digit;
2028    }
2029    buf[num_digits - 1] = static_cast&lt;char&gt;(&#x27;0&#x27; + digit);
2030  }
2031  template &lt;typename T&gt;
2032  int format_float(T value, int precision, float_specs specs, buffer&lt;char&gt;&amp; buf) {
2033    static_assert(!std::is_same&lt;T, float&gt;::value, &quot;&quot;);
2034    FMT_ASSERT(value &gt;= 0, &quot;value is negative&quot;);
2035    const bool fixed = specs.format == float_format::fixed;
2036    if (value &lt;= 0) {  
2037      if (precision &lt;= 0 || !fixed) {
2038        buf.push_back(&#x27;0&#x27;);
2039        return 0;
2040      }
2041      buf.try_resize(to_unsigned(precision));
2042      std::uninitialized_fill_n(buf.data(), precision, &#x27;0&#x27;);
2043      return -precision;
2044    }
2045    if (!specs.use_grisu) return snprintf_float(value, precision, specs, buf);
2046    if (precision &lt; 0) {
2047      if (specs.binary32) {
2048        auto dec = dragonbox::to_decimal(static_cast&lt;float&gt;(value));
2049        write&lt;char&gt;(buffer_appender&lt;char&gt;(buf), dec.significand);
2050        return dec.exponent;
2051      }
2052      auto dec = dragonbox::to_decimal(static_cast&lt;double&gt;(value));
2053      write&lt;char&gt;(buffer_appender&lt;char&gt;(buf), dec.significand);
2054      return dec.exponent;
2055    }
2056    int exp = 0;
2057    const int min_exp = -60;  
2058    int cached_exp10 = 0;     
2059    fp normalized = normalize(fp(value));
2060    const auto cached_pow = get_cached_power(
2061        min_exp - (normalized.e + fp::significand_size), cached_exp10);
2062    normalized = normalized * cached_pow;
2063    const int max_double_digits = 767;
2064    if (precision &gt; max_double_digits) precision = max_double_digits;
2065    fixed_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
2066    if (grisu_gen_digits(normalized, 1, exp, handler) == digits::error) {
2067      exp += handler.size - cached_exp10 - 1;
2068      fallback_format(value, handler.precision, specs.binary32, buf, exp);
2069    } else {
2070      exp += handler.exp10;
2071      buf.try_resize(to_unsigned(handler.size));
2072    }
2073    if (!fixed &amp;&amp; !specs.showpoint) {
2074      auto num_digits = buf.size();
2075      while (num_digits &gt; 0 &amp;&amp; buf[num_digits - 1] == &#x27;0&#x27;) {
2076        --num_digits;
2077        ++exp;
2078      }
2079      buf.try_resize(num_digits);
2080    }
2081    return exp;
2082  }  
2083  template &lt;typename T&gt;
2084  int snprintf_float(T value, int precision, float_specs specs,
2085                     buffer&lt;char&gt;&amp; buf) {
2086    FMT_ASSERT(buf.capacity() &gt; buf.size(), &quot;empty buffer&quot;);
2087    static_assert(!std::is_same&lt;T, float&gt;::value, &quot;&quot;);
2088    if (specs.format == float_format::general ||
2089        specs.format == float_format::exp)
2090      precision = (precision &gt;= 0 ? precision : 6) - 1;
2091    enum { max_format_size = 7 };  
2092    char format[max_format_size];
2093    char* format_ptr = format;
2094    *format_ptr++ = &#x27;%&#x27;;
2095    if (specs.showpoint &amp;&amp; specs.format == float_format::hex) *format_ptr++ = &#x27;#&#x27;;
2096    if (precision &gt;= 0) {
2097      *format_ptr++ = &#x27;.&#x27;;
2098      *format_ptr++ = &#x27;*&#x27;;
2099    }
2100    if (std::is_same&lt;T, long double&gt;()) *format_ptr++ = &#x27;L&#x27;;
2101    *format_ptr++ = specs.format != float_format::hex
2102                        ? (specs.format == float_format::fixed ? &#x27;f&#x27; : &#x27;e&#x27;)
2103                        : (specs.upper ? &#x27;A&#x27; : &#x27;a&#x27;);
2104    *format_ptr = &#x27;\0&#x27;;
2105    auto offset = buf.size();
2106    for (;;) {
2107      auto begin = buf.data() + offset;
2108      auto capacity = buf.capacity() - offset;
2109  #ifdef FMT_FUZZ
2110      if (precision &gt; 100000)
2111        throw std::runtime_error(
2112            &quot;fuzz mode - avoid large allocation inside snprintf&quot;);
2113  #endif
2114      int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
2115      int result = precision &gt;= 0
2116                       ? snprintf_ptr(begin, capacity, format, precision, value)
2117                       : snprintf_ptr(begin, capacity, format, value);
2118      if (result &lt; 0) {
2119        buf.try_reserve(buf.capacity() + 1);
2120        continue;
2121      }
2122      auto size = to_unsigned(result);
2123      if (size &gt;= capacity) {
2124        buf.try_reserve(size + offset + 1);  
2125        continue;
2126      }
2127      auto is_digit = [](char c) { return c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; };
2128      if (specs.format == float_format::fixed) {
2129        if (precision == 0) {
2130          buf.try_resize(size);
2131          return 0;
2132        }
2133        auto end = begin + size, p = end;
2134        do {
2135          --p;
2136        } while (is_digit(*p));
2137        int fraction_size = static_cast&lt;int&gt;(end - p - 1);
2138        std::memmove(p, p + 1, to_unsigned(fraction_size));
2139        buf.try_resize(size - 1);
2140        return -fraction_size;
2141      }
2142      if (specs.format == float_format::hex) {
2143        buf.try_resize(size + offset);
2144        return 0;
2145      }
2146      auto end = begin + size, exp_pos = end;
2147      do {
2148        --exp_pos;
2149      } while (*exp_pos != &#x27;e&#x27;);
2150      char sign = exp_pos[1];
2151      assert(sign == &#x27;+&#x27; || sign == &#x27;-&#x27;);
2152      int exp = 0;
2153      auto p = exp_pos + 2;  
2154      do {
2155        assert(is_digit(*p));
2156        exp = exp * 10 + (*p++ - &#x27;0&#x27;);
2157      } while (p != end);
2158      if (sign == &#x27;-&#x27;) exp = -exp;
2159      int fraction_size = 0;
2160      if (exp_pos != begin + 1) {
2161        auto fraction_end = exp_pos - 1;
2162        while (*fraction_end == &#x27;0&#x27;) --fraction_end;
2163        fraction_size = static_cast&lt;int&gt;(fraction_end - begin - 1);
2164        std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));
2165      }
2166      buf.try_resize(to_unsigned(fraction_size) + offset + 1);
2167      return exp - fraction_size;
2168    }
2169  }
2170  inline const char* utf8_decode(const char* buf, uint32_t* c, int* e) {
2171    static const char lengths[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
2172                                   1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
2173                                   0, 0, 2, 2, 2, 2, 3, 3, 4, 0};
2174    static const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
2175    static const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
2176    static const int shiftc[] = {0, 18, 12, 6, 0};
2177    static const int shifte[] = {0, 6, 4, 2, 0};
2178    auto s = reinterpret_cast&lt;const unsigned char*&gt;(buf);
2179    int len = lengths[s[0] &gt;&gt; 3];
2180    const char* next = buf + len + !len;
2181    *c = uint32_t(s[0] &amp; masks[len]) &lt;&lt; 18;
2182    *c |= uint32_t(s[1] &amp; 0x3f) &lt;&lt; 12;
2183    *c |= uint32_t(s[2] &amp; 0x3f) &lt;&lt; 6;
2184    *c |= uint32_t(s[3] &amp; 0x3f) &lt;&lt; 0;
2185    *c &gt;&gt;= shiftc[len];
2186    *e = (*c &lt; mins[len]) &lt;&lt; 6;       
2187    *e |= ((*c &gt;&gt; 11) == 0x1b) &lt;&lt; 7;  
2188    *e |= (*c &gt; 0x10FFFF) &lt;&lt; 8;       
2189    *e |= (s[1] &amp; 0xc0) &gt;&gt; 2;
2190    *e |= (s[2] &amp; 0xc0) &gt;&gt; 4;
2191    *e |= (s[3]) &gt;&gt; 6;
2192    *e ^= 0x2a;  
2193    *e &gt;&gt;= shifte[len];
2194    return next;
2195  }
2196  struct stringifier {
2197    template &lt;typename T&gt; FMT_INLINE std::string operator()(T value) const {
2198      return to_string(value);
2199    }
2200    std::string operator()(basic_format_arg&lt;format_context&gt;::handle h) const {
2201      memory_buffer buf;
2202      format_parse_context parse_ctx({});
2203      format_context format_ctx(buffer_appender&lt;char&gt;(buf), {}, {});
2204      h.format(parse_ctx, format_ctx);
2205      return to_string(buf);
2206    }
2207  };
2208  }  
2209  template &lt;&gt; struct formatter&lt;detail::bigint&gt; {
2210    format_parse_context::iterator parse(format_parse_context&amp; ctx) {
2211      return ctx.begin();
2212    }
2213    format_context::iterator format(const detail::bigint&amp; n,
2214                                    format_context&amp; ctx) {
2215      auto out = ctx.out();
2216      bool first = true;
2217      for (auto i = n.bigits_.size(); i &gt; 0; --i) {
2218        auto value = n.bigits_[i - 1u];
2219        if (first) {
2220          out = format_to(out, &quot;{:x}&quot;, value);
2221          first = false;
2222          continue;
2223        }
2224        out = format_to(out, &quot;{:08x}&quot;, value);
2225      }
2226      if (n.exp_ &gt; 0)
2227        out = format_to(out, &quot;p{}&quot;, n.exp_ * detail::bigint::bigit_bits);
2228      return out;
2229    }
2230  };
2231  FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
2232    auto transcode = [this](const char* p) {
2233      auto cp = uint32_t();
2234      auto error = 0;
2235      p = utf8_decode(p, &amp;cp, &amp;error);
2236      if (error != 0) FMT_THROW(std::runtime_error(&quot;invalid utf8&quot;));
2237      if (cp &lt;= 0xFFFF) {
2238        buffer_.push_back(static_cast&lt;wchar_t&gt;(cp));
2239      } else {
2240        cp -= 0x10000;
2241        buffer_.push_back(static_cast&lt;wchar_t&gt;(0xD800 + (cp &gt;&gt; 10)));
2242        buffer_.push_back(static_cast&lt;wchar_t&gt;(0xDC00 + (cp &amp; 0x3FF)));
2243      }
2244      return p;
2245    };
2246    auto p = s.data();
2247    const size_t block_size = 4;  
2248    if (s.size() &gt;= block_size) {
2249      for (auto end = p + s.size() - block_size + 1; p &lt; end;) p = transcode(p);
2250    }
2251    if (auto num_chars_left = s.data() + s.size() - p) {
2252      char buf[2 * block_size - 1] = {};
2253      memcpy(buf, p, to_unsigned(num_chars_left));
2254      p = buf;
2255      do {
2256        p = transcode(p);
2257      } while (p - buf &lt; num_chars_left);
2258    }
2259    buffer_.push_back(0);
2260  }
2261  FMT_FUNC void format_system_error(detail::buffer&lt;char&gt;&amp; out, int error_code,
2262                                    string_view message) FMT_NOEXCEPT {
2263    FMT_TRY {
2264      memory_buffer buf;
2265      buf.resize(inline_buffer_size);
2266      for (;;) {
2267        char* system_message = &amp;buf[0];
2268        int result =
2269            detail::safe_strerror(error_code, system_message, buf.size());
2270        if (result == 0) {
2271          format_to(detail::buffer_appender&lt;char&gt;(out), &quot;{}: {}&quot;, message,
2272                    system_message);
2273          return;
2274        }
2275        if (result != ERANGE)
2276          break;  
2277        buf.resize(buf.size() * 2);
2278      }
2279    }
2280    FMT_CATCH(...) {}
2281    format_error_code(out, error_code, message);
2282  }
2283  FMT_FUNC void detail::error_handler::on_error(const char* message) {
2284    FMT_THROW(format_error(message));
2285  }
2286  FMT_FUNC void report_system_error(int error_code,
2287                                    fmt::string_view message) FMT_NOEXCEPT {
2288    report_error(format_system_error, error_code, message);
2289  }
2290  FMT_FUNC std::string detail::vformat(string_view format_str, format_args args) {
2291    if (format_str.size() == 2 &amp;&amp; equal2(format_str.data(), &quot;{}&quot;)) {
2292      auto arg = args.get(0);
2293      if (!arg) error_handler().on_error(&quot;argument not found&quot;);
2294      return visit_format_arg(stringifier(), arg);
2295    }
2296    memory_buffer buffer;
2297    detail::vformat_to(buffer, format_str, args);
2298    return to_string(buffer);
2299  }
2300  #ifdef _WIN32
2301  namespace detail {
2302  using dword = conditional_t&lt;sizeof(long) == 4, unsigned long, unsigned&gt;;
2303  extern &quot;C&quot; __declspec(dllimport) int __stdcall WriteConsoleW(  
2304      void*, const void*, dword, dword*, void*);
2305  }  
2306  #endif
2307  FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
2308    memory_buffer buffer;
2309    detail::vformat_to(buffer, format_str,
2310                       basic_format_args&lt;buffer_context&lt;char&gt;&gt;(args));
2311  #ifdef _WIN32
2312    auto fd = _fileno(f);
2313    if (_isatty(fd)) {
2314      detail::utf8_to_utf16 u16(string_view(buffer.data(), buffer.size()));
2315      auto written = detail::dword();
2316      if (!detail::WriteConsoleW(reinterpret_cast&lt;void*&gt;(_get_osfhandle(fd)),
2317                                 u16.c_str(), static_cast&lt;uint32_t&gt;(u16.size()),
2318                                 &amp;written, nullptr)) {
2319        FMT_THROW(format_error(&quot;failed to write to console&quot;));
2320      }
2321      return;
2322    }
2323  #endif
2324    detail::fwrite_fully(buffer.data(), 1, buffer.size(), f);
2325  }
2326  #ifdef _WIN32
2327  FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
2328                                        format_args args) {
2329    memory_buffer buffer;
2330    detail::vformat_to(buffer, format_str,
2331                       basic_format_args&lt;buffer_context&lt;char&gt;&gt;(args));
2332    fwrite_fully(buffer.data(), 1, buffer.size(), f);
2333  }
2334  #endif
2335  FMT_FUNC void vprint(string_view format_str, format_args args) {
2336    vprint(stdout, format_str, args);
2337  }
2338  FMT_END_NAMESPACE
2339  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</div>
                </div>
                <div class="column column_space"><pre><code>567  template &lt;typename T, FMT_ENABLE_IF(!is_signed&lt;T&gt;::value)&gt;
568  FMT_CONSTEXPR bool is_negative(T) {
</pre></code></div>
                <div class="column column_space"><pre><code>1034    template &lt;typename Float, FMT_ENABLE_IF(!is_supported_float&lt;Float&gt;::value)&gt;
1035    bool assign(Float) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    