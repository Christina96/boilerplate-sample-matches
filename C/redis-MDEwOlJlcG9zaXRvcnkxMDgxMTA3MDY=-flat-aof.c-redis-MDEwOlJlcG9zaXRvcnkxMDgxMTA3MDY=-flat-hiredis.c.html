
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "bio.h"
7  #include "rio.h"
8  #include <signal.h>
9  #include <fcntl.h>
10  #include <sys/stat.h>
11  #include <sys/types.h>
12  #ifndef _WIN32
13  #include <sys/time.h>
14  #include <sys/resource.h>
15  #include <sys/wait.h>
16  #include <sys/param.h>
17  #else
18  #include "Win32_Interop/Win32_QFork.h"
19  #include <direct.h>
20  #define MAXPATHLEN 1024
21  #endif
22  void aofUpdateCurrentSize(void);
23  void aofClosePipes(void);
24  #define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    &bsol;* 10 MB per block */
25  typedef struct aofrwblock {
26      PORT_ULONG used, free;
27      char buf[AOF_RW_BUF_BLOCK_SIZE];
28  } aofrwblock;
29  void aofRewriteBufferReset(void) {
30      if (server.aof_rewrite_buf_blocks)
31          listRelease(server.aof_rewrite_buf_blocks);
32      server.aof_rewrite_buf_blocks = listCreate();
33      listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
34  }
35  PORT_ULONG aofRewriteBufferSize(void) {
36      listNode *ln;
37      listIter li;
38      PORT_ULONG size = 0;
39      listRewind(server.aof_rewrite_buf_blocks,&li);
40      while((ln = listNext(&li))) {
41          aofrwblock *block = listNodeValue(ln);
42          size += block->used;
43      }
44      return size;
45  }
46  void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
47      listNode *ln;
48      aofrwblock *block;
49      ssize_t nwritten;
50      UNUSED(el);
51      UNUSED(fd);
52      UNUSED(privdata);
53      UNUSED(mask);
54      while(1) {
55          ln = listFirst(server.aof_rewrite_buf_blocks);
56          block = ln ? ln->value : NULL;
57          if (server.aof_stop_sending_diff || !block) {
58  #ifndef _WIN32
59              aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
60                                AE_WRITABLE);
61  #endif
62              return;
63          }
64          if (block->used > 0) {
65              nwritten = write(server.aof_pipe_write_data_to_child,
66                               block->buf,block->used);
67              if (nwritten <= 0) return;
68              memmove(block->buf,block->buf+nwritten,block->used-nwritten);
69              block->used -= nwritten;
70              block->free += nwritten;
71          }
72          if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
73      }
74  }
75  void aofRewriteBufferAppend(unsigned char *s, PORT_ULONG len) {
76      listNode *ln = listLast(server.aof_rewrite_buf_blocks);
77      aofrwblock *block = ln ? ln->value : NULL;
78      while(len) {
79          if (block) {
80              PORT_ULONG thislen = (block->free < len) ? block->free : len;
81              if (thislen) {  &bsol;* The current block is not already full. */
82                  memcpy(block->buf+block->used, s, thislen);
83                  block->used += thislen;
84                  block->free -= thislen;
85                  s += thislen;
86                  len -= thislen;
87              }
88          }
89          if (len) { &bsol;* First block to allocate, or need another block. */
90              int numblocks;
91              block = zmalloc(sizeof(*block));
92  #ifdef _WIN32
93              if (block) {
94  #endif
95                  block->free = AOF_RW_BUF_BLOCK_SIZE;
96                  block->used = 0;
97  #ifdef _WIN32
98              }
99  #endif
100              listAddNodeTail(server.aof_rewrite_buf_blocks,block);
101              numblocks = (int) listLength(server.aof_rewrite_buf_blocks);         WIN_PORT_FIX &bsol;* cast (int) */
102              if (((numblocks+1) % 10) == 0) {
103                  int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
104                                                           LL_NOTICE;
105                  serverLog(level,"Background AOF buffer size: %Iu MB", WIN_PORT_FIX &bsol;* %lu -> %Iu */
106                      aofRewriteBufferSize()/(1024*1024));
107              }
108          }
109      }
110  #ifndef _WIN32
111      if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
112          aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
113              AE_WRITABLE, aofChildWriteDiffData, NULL);
114      }
115  #endif
116  }
117  ssize_t aofRewriteBufferWrite(int fd) {
118      listNode *ln;
119      listIter li;
120      ssize_t count = 0;
121      listRewind(server.aof_rewrite_buf_blocks,&li);
122      while((ln = listNext(&li))) {
123          aofrwblock *block = listNodeValue(ln);
124          ssize_t nwritten;
125          if (block->used) {
126              nwritten = write(fd,block->buf,block->used);
127              if (nwritten != (ssize_t)block->used) {
128                  if (nwritten == 0) errno = EIO;
129                  return -1;
130              }
131              count += nwritten;
132          }
133      }
134      return count;
135  }
136  int aofFsyncInProgress(void) {
137      return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
138  }
139  void aof_background_fsync(int fd) {
140      bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(PORT_LONG)fd,NULL,NULL);
141  }
142  static void killAppendOnlyChild(void) {
143      POSIX_ONLY(int statloc;)
144      if (server.aof_child_pid == -1) return;
145      serverLog(LL_NOTICE,"Killing running AOF rewrite child: %Id", WIN_PORT_FIX &bsol;* %ld -> %Id */
146          (PORT_LONG) server.aof_child_pid);
147  #ifdef _WIN32
148          AbortForkOperation();
149  #else
150      if (kill(server.aof_child_pid,SIGUSR1) != -1) {
151          while(wait3(&statloc,0,NULL) != server.aof_child_pid);
152      }
153  #endif
154      aofRewriteBufferReset();
155      aofRemoveTempFile(server.aof_child_pid);
156      server.aof_child_pid = -1;
157      server.aof_rewrite_time_start = -1;
158      aofClosePipes();
159  }
160  void stopAppendOnly(void) {
161      serverAssert(server.aof_state != AOF_OFF);
162      flushAppendOnlyFile(1);
163      redis_fsync(server.aof_fd);
164      close(server.aof_fd);
165      server.aof_fd = -1;
166      server.aof_selected_db = -1;
167      server.aof_state = AOF_OFF;
168      killAppendOnlyChild();
169  }
170  int startAppendOnly(void) {
171      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
172      int newfd;
173      newfd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT WIN32_ONLY(|_O_BINARY), IF_WIN32(_S_IREAD|_S_IWRITE, 0644));
174      serverAssert(server.aof_state == AOF_OFF);
175      if (newfd == -1) {
176          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
177          serverLog(LL_WARNING,
178              "Redis needs to enable the AOF but can't open the "
179              "append only file %s (in server root dir %s): %s",
180              server.aof_filename,
181              cwdp ? cwdp : "unknown",
182              IF_WIN32(wsa_strerror(errno), strerror(errno)));
183          return C_ERR;
184      }
185      if (server.rdb_child_pid != -1) {
186          server.aof_rewrite_scheduled = 1;
187          serverLog(LL_WARNING,"AOF was enabled but there is already a child process saving an RDB file on disk. An AOF background was scheduled to start when possible.");
188      } else {
189          if (server.aof_child_pid != -1) {
190              serverLog(LL_WARNING,"AOF was enabled but there is already an AOF rewriting in background. Stopping background AOF and starting a rewrite now.");
191              killAppendOnlyChild();
192          }
193          if (rewriteAppendOnlyFileBackground() == C_ERR) {
194              close(newfd);
195              serverLog(LL_WARNING,"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.");
196              return C_ERR;
197          }
198      }
199      server.aof_state = AOF_WAIT_REWRITE;
200      server.aof_last_fsync = server.unixtime;
201      server.aof_fd = newfd;
202      return C_OK;
203  }
204  ssize_t aofWrite(int fd, const char *buf, size_t len) {
205      ssize_t nwritten = 0, totwritten = 0;
206      while(len) {
207          nwritten = write(fd, buf, len);
208          if (nwritten < 0) {
209              if (errno == EINTR) {
210                  continue;
211              }
212              return totwritten ? totwritten : -1;
213          }
214          len -= nwritten;
215          buf += nwritten;
216          totwritten += nwritten;
217      }
218      return totwritten;
219  }
220  #define AOF_WRITE_LOG_ERROR_RATE 30 &bsol;* Seconds between errors logging. */
221  void flushAppendOnlyFile(int force) {
222      ssize_t nwritten;
223      int sync_in_progress = 0;
224      mstime_t latency;
225      if (sdslen(server.aof_buf) == 0) {
226          if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
227              server.aof_fsync_offset != server.aof_current_size &&
228              server.unixtime > server.aof_last_fsync &&
229              !(sync_in_progress = aofFsyncInProgress())) {
230              goto try_fsync;
231          } else {
232              return;
233          }
234      }
235      if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
236          sync_in_progress = aofFsyncInProgress();
237      if (server.aof_fsync == AOF_FSYNC_EVERYSEC && !force) {
238          if (sync_in_progress) {
239              if (server.aof_flush_postponed_start == 0) {
240                  server.aof_flush_postponed_start = server.unixtime;
241                  return;
242              } else if (server.unixtime - server.aof_flush_postponed_start < 2) {
243                  return;
244              }
245              server.aof_delayed_fsync++;
246              serverLog(LL_NOTICE,"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.");
247          }
248      }
249      latencyStartMonitor(latency);
250      nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));
251      latencyEndMonitor(latency);
252      if (sync_in_progress) {
253          latencyAddSampleIfNeeded("aof-write-pending-fsync",latency);
254      } else if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
255          latencyAddSampleIfNeeded("aof-write-active-child",latency);
256      } else {
257          latencyAddSampleIfNeeded("aof-write-alone",latency);
258      }
259      latencyAddSampleIfNeeded("aof-write",latency);
260      server.aof_flush_postponed_start = 0;
261      if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
262          static time_t last_write_error_log = 0;
263          int can_log = 0;
264          if ((server.unixtime - last_write_error_log) > AOF_WRITE_LOG_ERROR_RATE) {
265              can_log = 1;
266              last_write_error_log = server.unixtime;
267          }
268          if (nwritten == -1) {
269              if (can_log) {
270                  serverLog(LL_WARNING,"Error writing to the AOF file: %s",
271                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
272                  server.aof_last_write_errno = errno;
273              }
274          } else {
275              if (can_log) {
276                  serverLog(LL_WARNING,"Short write while writing to "
277                                         "the AOF file: (nwritten=%lld, "
278                                         "expected=%lld)",
279                                         (PORT_LONGLONG)nwritten,
280                                         (PORT_LONGLONG)sdslen(server.aof_buf));
281              }
282              if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
283                  if (can_log) {
284                      serverLog(LL_WARNING, "Could not remove short write "
285                               "from the append-only file.  Redis may refuse "
286                               "to load the AOF the next time it starts.  "
287                               "ftruncate: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
288                  }
289              } else {
290                  nwritten = -1;
291              }
292              server.aof_last_write_errno = ENOSPC;
293          }
294          if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
295              serverLog(LL_WARNING,"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...");
296              exit(1);
297          } else {
298              server.aof_last_write_status = C_ERR;
299              if (nwritten > 0) {
300                  server.aof_current_size += nwritten;
301                  sdsrange(server.aof_buf,(int)nwritten,-1);                      WIN_PORT_FIX &bsol;* cast (int) */
302              }
303              return; &bsol;* We'll try again on the next call... */
304          }
305      } else {
306          if (server.aof_last_write_status == C_ERR) {
307              serverLog(LL_WARNING,
308                  "AOF write error looks solved, Redis can write again.");
309              server.aof_last_write_status = C_OK;
310          }
311      }
312      server.aof_current_size += nwritten;
313      if ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) < 4000) {
314          sdsclear(server.aof_buf);
315      } else {
316          sdsfree(server.aof_buf);
317          server.aof_buf = sdsempty();
318      }
319  try_fsync:
320      if (server.aof_no_fsync_on_rewrite &&
321          (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
322              return;
323      if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
324          latencyStartMonitor(latency);
325          redis_fsync(server.aof_fd); &bsol;* Let's try to get this data on the disk */
326          latencyEndMonitor(latency);
327          latencyAddSampleIfNeeded("aof-fsync-always",latency);
328          server.aof_fsync_offset = server.aof_current_size;
329          server.aof_last_fsync = server.unixtime;
330      } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &&
331                  server.unixtime > server.aof_last_fsync)) {
332          if (!sync_in_progress) {
333              aof_background_fsync(server.aof_fd);
334              server.aof_fsync_offset = server.aof_current_size;
335          }
336          server.aof_last_fsync = server.unixtime;
337      }
338  }
339  sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
340      char buf[32];
341      int len, j;
342      robj *o;
343      buf[0] = '*';
344      len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
<span onclick='openModal()' class='match'>345      buf[len++] = '\r';
346      buf[len++] = '\n';
347      dst = sdscatlen(dst,buf,len);
</span>348      for (j = 0; j < argc; j++) {
349          o = getDecodedObject(argv[j]);
350          buf[0] = '$';
351          len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
352          buf[len++] = '\r';
353          buf[len++] = '\n';
354          dst = sdscatlen(dst,buf,len);
355          dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
356          dst = sdscatlen(dst,"\r\n",2);
357          decrRefCount(o);
358      }
359      return dst;
360  }
361  sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {
362      PORT_LONGLONG when;
363      robj *argv[3];
364      seconds = getDecodedObject(seconds);
365      when = strtoll(seconds->ptr,NULL,10);
366      if (cmd->proc == expireCommand || cmd->proc == setexCommand ||
367          cmd->proc == expireatCommand)
368      {
369          when *= 1000;
370      }
371      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
372          cmd->proc == setexCommand || cmd->proc == psetexCommand)
373      {
374          when += mstime();
375      }
376      decrRefCount(seconds);
377      argv[0] = createStringObject("PEXPIREAT",9);
378      argv[1] = key;
379      argv[2] = createStringObjectFromLongLong(when);
380      buf = catAppendOnlyGenericCommand(buf, 3, argv);
381      decrRefCount(argv[0]);
382      decrRefCount(argv[2]);
383      return buf;
384  }
385  void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
386      sds buf = sdsempty();
387      robj *tmpargv[3];
388      if (dictid != server.aof_selected_db) {
389          char seldb[64];
390          snprintf(seldb,sizeof(seldb),"%d",dictid);
391          WIN32_ONLY(seldb[sizeof(seldb)-1] = 0;) &bsol;*get rid of C6053 warning*/
392          buf = sdscatprintf(buf,"*2\r\n$6\r\nSELECT\r\n$%Iu\r\n%s\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
393              (PORT_ULONG)strlen(seldb),seldb);
394          server.aof_selected_db = dictid;
395      }
396      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
397          cmd->proc == expireatCommand) {
398          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
399      } else if (cmd->proc == setexCommand || cmd->proc == psetexCommand) {
400          tmpargv[0] = createStringObject("SET",3);
401          tmpargv[1] = argv[1];
402          tmpargv[2] = argv[3];
403          buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
404          decrRefCount(tmpargv[0]);
405          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
406      } else if (cmd->proc == setCommand && argc > 3) {
407          int i;
408          robj *exarg = NULL, *pxarg = NULL;
409          buf = catAppendOnlyGenericCommand(buf,3,argv);
410          for (i = 3; i < argc; i ++) {
411              if (!strcasecmp(argv[i]->ptr, "ex")) exarg = argv[i+1];
412              if (!strcasecmp(argv[i]->ptr, "px")) pxarg = argv[i+1];
413          }
414          serverAssert(!(exarg && pxarg));
415          if (exarg)
416              buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
417                                                 exarg);
418          if (pxarg)
419              buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
420                                                 pxarg);
421      } else {
422          buf = catAppendOnlyGenericCommand(buf,argc,argv);
423      }
424      if (server.aof_state == AOF_ON)
425          server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
426      if (server.aof_child_pid != -1)
427          aofRewriteBufferAppend((unsigned char*)buf,(PORT_ULONG)sdslen(buf));    WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
428      sdsfree(buf);
429  }
430  struct client *createFakeClient(void) {
431      struct client *c = zmalloc(sizeof(*c));
432      selectDb(c,0);
433      c->fd = -1;
434      c->name = NULL;
435      c->querybuf = sdsempty();
436      c->querybuf_peak = 0;
437      c->argc = 0;
438      c->argv = NULL;
439      c->bufpos = 0;
440      c->flags = 0;
441      c->btype = BLOCKED_NONE;
442      c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
443      c->reply = listCreate();
444      c->reply_bytes = 0;
445      c->obuf_soft_limit_reached_time = 0;
446      c->watched_keys = listCreate();
447      c->peerid = NULL;
448      listSetFreeMethod(c->reply,freeClientReplyValue);
449      listSetDupMethod(c->reply,dupClientReplyValue);
450      initClientMultiState(c);
451      return c;
452  }
453  void freeFakeClientArgv(struct client *c) {
454      int j;
455      for (j = 0; j < c->argc; j++)
456          decrRefCount(c->argv[j]);
457      zfree(c->argv);
458  }
459  void freeFakeClient(struct client *c) {
460      sdsfree(c->querybuf);
461      listRelease(c->reply);
462      listRelease(c->watched_keys);
463      freeClientMultiState(c);
464      zfree(c);
465  }
466  int loadAppendOnlyFile(char *filename) {
467      struct client *fakeClient;
468      FILE *fp = fopen(filename, IF_WIN32("rb", "r"));
469      struct redis_stat sb;
470      int old_aof_state = server.aof_state;
471      PORT_LONG loops = 0;
472      off_t valid_up_to = 0; &bsol;* Offset of latest well-formed command loaded. */
473      off_t valid_before_multi = 0; &bsol;* Offset before MULTI command loaded. */
474      if (fp == NULL) {
475          serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
476          exit(1);
477      }
478      if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
479          server.aof_current_size = 0;
480          server.aof_fsync_offset = server.aof_current_size;
481          fclose(fp);
482          return C_ERR;
483      }
484      server.aof_state = AOF_OFF;
485      fakeClient = createFakeClient();
486      startLoading(fp);
487      char sig[5]; &bsol;* "REDIS" */
488      if (fread(sig,1,5,fp) != 5 || memcmp(sig,"REDIS",5) != 0) {
489          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
490      } else {
491          rio rdb;
492          serverLog(LL_NOTICE,"Reading RDB preamble from AOF file...");
493          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
494          rioInitWithFile(&rdb,fp);
495          if (rdbLoadRio(&rdb,NULL,1) != C_OK) {
496              serverLog(LL_WARNING,"Error reading the RDB preamble of the AOF file, AOF loading aborted");
497              goto readerr;
498          } else {
499              serverLog(LL_NOTICE,"Reading the remaining AOF tail...");
500          }
501      }
502      while(1) {
503          int argc, j;
504          PORT_ULONG len;
505          robj **argv;
506          char buf[128];
507          sds argsds;
508          struct redisCommand *cmd;
509          if (!(loops++ % 1000)) {
510              loadingProgress((off_t) ftello(fp));                                 WIN_PORT_FIX &bsol;* cast (off_t) */
511              processEventsWhileBlocked();
512          }
513          if (fgets(buf,sizeof(buf),fp) == NULL) {
514              if (feof(fp))
515                  break;
516              else
517                  goto readerr;
518          }
519          if (buf[0] != '*') goto fmterr;
520          if (buf[1] == '\0') goto readerr;
521          argc = atoi(buf+1);
522          if (argc < 1) goto fmterr;
523          argv = zmalloc(sizeof(robj*)*argc);
524          fakeClient->argc = argc;
525          fakeClient->argv = argv;
526          for (j = 0; j < argc; j++) {
527              char *readres = fgets(buf,sizeof(buf),fp);
528              if (readres == NULL || buf[0] != '$') {
529                  fakeClient->argc = j; &bsol;* Free up to j-1. */
530                  freeFakeClientArgv(fakeClient);
531                  if (readres == NULL)
532                      goto readerr;
533                  else
534                      goto fmterr;
535              }
536              len = strtol(buf+1,NULL,10);
537              argsds = sdsnewlen(SDS_NOINIT,len);
538              if (len && fread(argsds,len,1,fp) == 0) {
539                  sdsfree(argsds);
540                  fakeClient->argc = j; &bsol;* Free up to j-1. */
541                  freeFakeClientArgv(fakeClient);
542                  goto readerr;
543              }
544              argv[j] = createObject(OBJ_STRING,argsds);
545              if (fread(buf,2,1,fp) == 0) {
546                  fakeClient->argc = j+1; &bsol;* Free up to j. */
547                  freeFakeClientArgv(fakeClient);
548                  goto readerr;
549              }
550          }
551          cmd = lookupCommand(argv[0]->ptr);
552          if (!cmd) {
553              serverLog(LL_WARNING,
554                  "Unknown command '%s' reading the append only file",
555                  (char*)argv[0]->ptr);
556              exit(1);
557          }
558          if (cmd == server.multiCommand) valid_before_multi = valid_up_to;
559          fakeClient->cmd = cmd;
560          if (fakeClient->flags & CLIENT_MULTI &&
561              fakeClient->cmd->proc != execCommand)
562          {
563              queueMultiCommand(fakeClient);
564          } else {
565              cmd->proc(fakeClient);
566          }
567          serverAssert(fakeClient->bufpos == 0 &&
568                       listLength(fakeClient->reply) == 0);
569          serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);
570          freeFakeClientArgv(fakeClient);
571          fakeClient->cmd = NULL;
572          if (server.aof_load_truncated) valid_up_to = ftello(fp);
573      }
574      if (fakeClient->flags & CLIENT_MULTI) {
575          serverLog(LL_WARNING,
576              "Revert incomplete MULTI/EXEC transaction in AOF file");
577          valid_up_to = valid_before_multi;
578          goto uxeof;
579      }
580  loaded_ok: &bsol;* DB loaded, cleanup and return C_OK to the caller. */
581      fclose(fp);
582      freeFakeClient(fakeClient);
583      server.aof_state = old_aof_state;
584      stopLoading();
585      aofUpdateCurrentSize();
586      server.aof_rewrite_base_size = server.aof_current_size;
587      server.aof_fsync_offset = server.aof_current_size;
588      return C_OK;
589  readerr: &bsol;* Read error. If feof(fp) is true, fall through to unexpected EOF. */
590      if (!feof(fp)) {
591          if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
592          serverLog(LL_WARNING,"Unrecoverable error reading the append only file: %s", strerror(errno));
593          exit(1);
594      }
595  uxeof: &bsol;* Unexpected AOF end of file. */
596      if (server.aof_load_truncated) {
597          serverLog(LL_WARNING,"!!! Warning: short read while loading the AOF file !!!");
598          serverLog(LL_WARNING,"!!! Truncating the AOF at offset %llu !!!",
599              (PORT_ULONGLONG) valid_up_to);
600          if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
601              if (valid_up_to == -1) {
602                  serverLog(LL_WARNING,"Last valid command offset is invalid");
603              } else {
604                  serverLog(LL_WARNING,"Error truncating the AOF file: %s",
605                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
606              }
607          } else {
608              if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {
609                  serverLog(LL_WARNING,"Can't seek the end of the AOF file: %s",
610                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
611              } else {
612                  serverLog(LL_WARNING,
613                      "AOF loaded anyway because aof-load-truncated is enabled");
614                  goto loaded_ok;
615              }
616          }
617      }
618      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
619      serverLog(LL_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
620      exit(1);
621  fmterr: &bsol;* Format error. */
622      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
623      serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
624      exit(1);
625  }
626  int rioWriteBulkObject(rio *r, robj *obj) {
627      if (obj->encoding == OBJ_ENCODING_INT) {
628          return (int)rioWriteBulkLongLong(r,(PORT_LONG)obj->ptr);               WIN_PORT_FIX &bsol;* cast (int) */
629      } else if (sdsEncodedObject(obj)) {
630          return (int)rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));           WIN_PORT_FIX &bsol;* cast (int) */
631      } else {
632          serverPanic("Unknown string encoding");
633      }
634  }
635  int rewriteListObject(rio *r, robj *key, robj *o) {
636      PORT_LONGLONG count = 0, items = listTypeLength(o);
637      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
638          quicklist *list = o->ptr;
639          quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);
640          quicklistEntry entry;
641          while (quicklistNext(li,&entry)) {
642              if (count == 0) {
643                  PORT_LONGLONG cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?  WIN_PORT_FIX &bsol;* int -> PORT_LONGLONG */
644                      AOF_REWRITE_ITEMS_PER_CMD : items;
645                  if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
646                  if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
647                  if (rioWriteBulkObject(r,key) == 0) return 0;
648              }
649              if (entry.value) {
650                  if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
651              } else {
652                  if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
653              }
654              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
655              items--;
656          }
657          quicklistReleaseIterator(li);
658      } else {
659          serverPanic("Unknown list encoding");
660      }
661      return 1;
662  }
663  int rewriteSetObject(rio *r, robj *key, robj *o) {
664      PORT_LONGLONG count = 0, items = setTypeSize(o);
665      if (o->encoding == OBJ_ENCODING_INTSET) {
666          int ii = 0;
667          int64_t llval;
668          while(intsetGet(o->ptr,ii++,&llval)) {
669              if (count == 0) {
670                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
671                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
672                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
673                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
674                  if (rioWriteBulkObject(r,key) == 0) return 0;
675              }
676              if (rioWriteBulkLongLong(r,llval) == 0) return 0;
677              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
678              items--;
679          }
680      } else if (o->encoding == OBJ_ENCODING_HT) {
681          dictIterator *di = dictGetIterator(o->ptr);
682          dictEntry *de;
683          while((de = dictNext(di)) != NULL) {
684              sds ele = dictGetKey(de);
685              if (count == 0) {
686                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
687                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
688                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
689                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
690                  if (rioWriteBulkObject(r,key) == 0) return 0;
691              }
692              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
693              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
694              items--;
695          }
696          dictReleaseIterator(di);
697      } else {
698          serverPanic("Unknown set encoding");
699      }
700      return 1;
701  }
702  int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
703      PORT_LONGLONG count = 0, items = zsetLength(o);
704      if (o->encoding == OBJ_ENCODING_ZIPLIST) {
705          unsigned char *zl = o->ptr;
706          unsigned char *eptr, *sptr;
707          unsigned char *vstr;
708          unsigned int vlen;
709          PORT_LONGLONG vll;
710          double score;
711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
719                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
720                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
721                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
722                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
723                  if (rioWriteBulkObject(r,key) == 0) return 0;
724              }
725              if (rioWriteBulkDouble(r,score) == 0) return 0;
726              if (vstr != NULL) {
727                  if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
728              } else {
729                  if (rioWriteBulkLongLong(r,vll) == 0) return 0;
730              }
731              zzlNext(zl,&eptr,&sptr);
732              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
733              items--;
734          }
735      } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
736          zset *zs = o->ptr;
737          dictIterator *di = dictGetIterator(zs->dict);
738          dictEntry *de;
739          while((de = dictNext(di)) != NULL) {
740              sds ele = dictGetKey(de);
741              double *score = dictGetVal(de);
742              if (count == 0) {
743                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
744                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
745                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
746                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
747                  if (rioWriteBulkObject(r,key) == 0) return 0;
748              }
749              if (rioWriteBulkDouble(r,*score) == 0) return 0;
750              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
751              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
752              items--;
753          }
754          dictReleaseIterator(di);
755      } else {
756          serverPanic("Unknown sorted zset encoding");
757      }
758      return 1;
759  }
760  static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
761      if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
762          unsigned char *vstr = NULL;
763          unsigned int vlen = UINT_MAX;
764          PORT_LONGLONG vll = LLONG_MAX;
765          hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
766          if (vstr)
767              return (int)rioWriteBulkString(r, (char*)vstr, vlen);       WIN_PORT_FIX &bsol;* cast (int) */
768          else
769              return (int)rioWriteBulkLongLong(r, vll);                   WIN_PORT_FIX &bsol;* cast (int) */
770      } else if (hi->encoding == OBJ_ENCODING_HT) {
771          sds value = hashTypeCurrentFromHashTable(hi, what);
772          return (int)rioWriteBulkString(r, value, sdslen(value));        WIN_PORT_FIX &bsol;* cast (int) */
773      }
774      serverPanic("Unknown hash encoding");
775      return 0;
776  }
777  int rewriteHashObject(rio *r, robj *key, robj *o) {
778      hashTypeIterator *hi;
779      PORT_LONGLONG count = 0, items = hashTypeLength(o);
780      hi = hashTypeInitIterator(o);
781      while (hashTypeNext(hi) != C_ERR) {
782          if (count == 0) {
783              int cmd_items = (int) ((items > AOF_REWRITE_ITEMS_PER_CMD) ? WIN_PORT_FIX &bsol;* cast (int) */
784                  AOF_REWRITE_ITEMS_PER_CMD : items);
785              if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
786              if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
787              if (rioWriteBulkObject(r,key) == 0) return 0;
788          }
789          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
790          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
791          if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
792          items--;
793      }
794      hashTypeReleaseIterator(hi);
795      return 1;
796  }
797  int rioWriteBulkStreamID(rio *r,streamID *id) {
798      int retval;
799      sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
800      retval = rioWriteBulkString(r,replyid,sdslen(replyid));
801      sdsfree(replyid);
802      return retval;
803  }
804  int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
805      streamID id;
806      streamDecodeID(rawid,&id);
807      if (rioWriteBulkCount(r,'*',12) == 0) return 0;
808      if (rioWriteBulkString(r,"XCLAIM",6) == 0) return 0;
809      if (rioWriteBulkObject(r,key) == 0) return 0;
810      if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
811      if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
812      if (rioWriteBulkString(r,"0",1) == 0) return 0;
813      if (rioWriteBulkStreamID(r,&id) == 0) return 0;
814      if (rioWriteBulkString(r,"TIME",4) == 0) return 0;
815      if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
816      if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
817      if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) return 0;
818      if (rioWriteBulkString(r,"JUSTID",6) == 0) return 0;
819      if (rioWriteBulkString(r,"FORCE",5) == 0) return 0;
820      return 1;
821  }
822  int rewriteStreamObject(rio *r, robj *key, robj *o) {
823      stream *s = o->ptr;
824      streamIterator si;
825      streamIteratorStart(&si,s,NULL,NULL,0);
826      streamID id;
827      int64_t numfields;
828      if (s->length) {
829          while(streamIteratorGetID(&si,&id,&numfields)) {
830              if (rioWriteBulkCount(r,'*',3+numfields*2) == 0) return 0;
831              if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
832              if (rioWriteBulkObject(r,key) == 0) return 0;
833              if (rioWriteBulkStreamID(r,&id) == 0) return 0;
834              while(numfields--) {
835                  unsigned char *field, *value;
836                  int64_t field_len, value_len;
837                  streamIteratorGetField(&si,&field,&value,&field_len,&value_len);
838                  if (rioWriteBulkString(r,(char*)field,field_len) == 0) return 0;
839                  if (rioWriteBulkString(r,(char*)value,value_len) == 0) return 0;
840              }
841          }
842      } else {
843          if (rioWriteBulkCount(r,'*',7) == 0) return 0;
844          if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
845          if (rioWriteBulkObject(r,key) == 0) return 0;
846          if (rioWriteBulkString(r,"MAXLEN",6) == 0) return 0;
847          if (rioWriteBulkString(r,"0",1) == 0) return 0;
848          if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
849          if (rioWriteBulkString(r,"x",1) == 0) return 0;
850          if (rioWriteBulkString(r,"y",1) == 0) return 0;
851      }
852      if (rioWriteBulkCount(r,'*',3) == 0) return 0;
853      if (rioWriteBulkString(r,"XSETID",6) == 0) return 0;
854      if (rioWriteBulkObject(r,key) == 0) return 0;
855      if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
856      if (s->cgroups) {
857          raxIterator ri;
858          raxStart(&ri,s->cgroups);
859          raxSeek(&ri,"^",NULL,0);
860          while(raxNext(&ri)) {
861              streamCG *group = ri.data;
862              if (rioWriteBulkCount(r,'*',5) == 0) return 0;
863              if (rioWriteBulkString(r,"XGROUP",6) == 0) return 0;
864              if (rioWriteBulkString(r,"CREATE",6) == 0) return 0;
865              if (rioWriteBulkObject(r,key) == 0) return 0;
866              if (rioWriteBulkString(r,(char*)ri.key,ri.key_len) == 0) return 0;
867              if (rioWriteBulkStreamID(r,&group->last_id) == 0) return 0;
868              raxIterator ri_cons;
869              raxStart(&ri_cons,group->consumers);
870              raxSeek(&ri_cons,"^",NULL,0);
871              while(raxNext(&ri_cons)) {
872                  streamConsumer *consumer = ri_cons.data;
873                  raxIterator ri_pel;
874                  raxStart(&ri_pel,consumer->pel);
875                  raxSeek(&ri_pel,"^",NULL,0);
876                  while(raxNext(&ri_pel)) {
877                      streamNACK *nack = ri_pel.data;
878                      if (rioWriteStreamPendingEntry(r,key,(char*)ri.key,
879                                                     ri.key_len,consumer,
880                                                     ri_pel.key,nack) == 0)
881                      {
882                          return 0;
883                      }
884                  }
885                  raxStop(&ri_pel);
886              }
887              raxStop(&ri_cons);
888          }
889          raxStop(&ri);
890      }
891      streamIteratorStop(&si);
892      return 1;
893  }
894  int rewriteModuleObject(rio *r, robj *key, robj *o) {
895      RedisModuleIO io;
896      moduleValue *mv = o->ptr;
897      moduleType *mt = mv->type;
898      moduleInitIOContext(io,mt,r,key);
899      mt->aof_rewrite(&io,key,mv->value);
900      if (io.ctx) {
901          moduleFreeContext(io.ctx);
902          zfree(io.ctx);
903      }
904      return io.error ? 0 : 1;
905  }
906  ssize_t aofReadDiffFromParent(void) {
907  #ifndef _WIN32
908      char buf[65536]; &bsol;* Default pipe buffer size on most Linux systems. */
909  #else
910      char* buf = zmalloc(65536); 
911  #endif
912      ssize_t nread, total = 0;
913      while ((nread =
914              read(server.aof_pipe_read_data_from_parent,buf,IF_WIN32(65536,sizeof(buf)))) > 0) {
915          server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
916          total += nread;
917      }
918  #ifdef _WIN32
919      zfree(buf);
920  #endif
921      return total;
922  }
923  int rewriteAppendOnlyFileRio(rio *aof) {
924      dictIterator *di = NULL;
925      dictEntry *de;
926      size_t processed = 0;
927      int j;
928      for (j = 0; j < server.dbnum; j++) {
929          char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
930          redisDb *db = server.db+j;
931          dict *d = db->dict;
932          if (dictSize(d) == 0) continue;
933          di = dictGetSafeIterator(d);
934          if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
935          if (rioWriteBulkLongLong(aof,j) == 0) goto werr;
936          while((de = dictNext(di)) != NULL) {
937              sds keystr;
938              robj key, *o;
939              PORT_LONGLONG expiretime;
940              keystr = dictGetKey(de);
941              o = dictGetVal(de);
942              initStaticStringObject(key,keystr);
943              expiretime = getExpire(db,&key);
944              if (o->type == OBJ_STRING) {
945                  char cmd[]="*3\r\n$3\r\nSET\r\n";
946                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
947                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
948                  if (rioWriteBulkObject(aof,o) == 0) goto werr;
949              } else if (o->type == OBJ_LIST) {
950                  if (rewriteListObject(aof,&key,o) == 0) goto werr;
951              } else if (o->type == OBJ_SET) {
952                  if (rewriteSetObject(aof,&key,o) == 0) goto werr;
953              } else if (o->type == OBJ_ZSET) {
954                  if (rewriteSortedSetObject(aof,&key,o) == 0) goto werr;
955              } else if (o->type == OBJ_HASH) {
956                  if (rewriteHashObject(aof,&key,o) == 0) goto werr;
957              } else if (o->type == OBJ_STREAM) {
958                  if (rewriteStreamObject(aof,&key,o) == 0) goto werr;
959              } else if (o->type == OBJ_MODULE) {
960                  if (rewriteModuleObject(aof,&key,o) == 0) goto werr;
961              } else {
962                  serverPanic("Unknown object type");
963              }
964              if (expiretime != -1) {
965                  char cmd[]="*3\r\n$9\r\nPEXPIREAT\r\n";
966                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
967                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
968                  if (rioWriteBulkLongLong(aof,expiretime) == 0) goto werr;
969              }
970              if (aof->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES) {
971                  processed = aof->processed_bytes;
972                  aofReadDiffFromParent();
973              }
974          }
975          dictReleaseIterator(di);
976          di = NULL;
977      }
978      return C_OK;
979  werr:
980      if (di) dictReleaseIterator(di);
981      return C_ERR;
982  }
983  int rewriteAppendOnlyFile(char *filename) {
984      rio aof;
985      FILE *fp;
986      char tmpfile[256];
987      char byte;
988      snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
989      fp = fopen(tmpfile, IF_WIN32("wb", "w"));
990      if (!fp) {
991          serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
992          return C_ERR;
993      }
994      server.aof_child_diff = sdsempty();
995      rioInitWithFile(&aof,fp);
996      if (server.aof_rewrite_incremental_fsync)
997          rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
998      if (server.aof_use_rdb_preamble) {
999          int error;
1000          if (rdbSaveRio(&aof,&error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
1001              errno = error;
1002              goto werr;
1003          }
1004      } else {
1005          if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto werr;
1006      }
1007      if (fflush(fp) == EOF) goto werr;
1008      if (fsync(fileno(fp)) == -1) goto werr;
1009      int nodata = 0;
1010      mstime_t start = mstime();
1011      while(mstime()-start < 1000 && nodata < 20) {
1012          if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) <= 0)
1013          {
1014              nodata++;
1015              continue;
1016          }
1017          nodata = 0; &bsol;* Start counting from zero, we stop on N *contiguous*
1018                         timeouts. */
1019          aofReadDiffFromParent();
1020      }
1021      if (write(server.aof_pipe_write_ack_to_parent,"!",1) != 1) goto werr;
1022  #ifndef _WIN32
1023      if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK)
1024          goto werr;
1025  #endif
1026      if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||
1027          byte != '!') goto werr;
1028      serverLog(LL_NOTICE,"Parent agreed to stop sending diffs. Finalizing AOF...");
1029      aofReadDiffFromParent();
1030      serverLog(LL_NOTICE,
1031          "Concatenating %.2f MB of AOF diff received from parent.",
1032          (double) (sdslen(server.aof_child_diff) / (1024*1024)));  WIN_PORT_FIX
1033      if (rioWrite(&aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
1034          goto werr;
1035      if (fflush(fp) == EOF) goto werr;
1036      if (fsync(fileno(fp)) == -1) goto werr;
1037      if (fclose(fp) == EOF) goto werr;
1038      if (rename(tmpfile,filename) == -1) {
1039          serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1040          unlink(tmpfile);
1041          return C_ERR;
1042      }
1043      serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
1044      return C_OK;
1045  werr:
1046      serverLog(LL_WARNING,"Write error writing append only file on disk: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1047      fclose(fp);
1048      unlink(tmpfile);
1049      return C_ERR;
1050  }
1051  void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1052      char byte;
1053      UNUSED(el);
1054      UNUSED(privdata);
1055      UNUSED(mask);
1056      if (read(fd,&byte,1) == 1 && byte == '!') {
1057          serverLog(LL_NOTICE,"AOF rewrite child asks to stop sending diffs.");
1058          server.aof_stop_sending_diff = 1;
1059          if (write(server.aof_pipe_write_ack_to_child,"!",1) != 1) {
1060              serverLog(LL_WARNING,"Can't send ACK to AOF child: %s",
1061                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1062          }
1063      }
1064  #ifndef _WIN32
1065      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1066  #endif
1067  }
1068  int aofCreatePipes(void) {
1069      int fds[6] = {-1, -1, -1, -1, -1, -1};
1070      int j;
1071      if (pipe(fds) == -1) goto error; &bsol;* parent -> children data. */
1072      if (pipe(fds+2) == -1) goto error; &bsol;* children -> parent ack. */
1073      if (pipe(fds+4) == -1) goto error; &bsol;* parent -> children ack. */
1074  #ifndef WIN32
1075      if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
1076      if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
1077      if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;
1078  #else
1079      if (FDAPI_PipeSetNonBlock(fds[0], 1) != 0) goto error;
1080      if (FDAPI_PipeSetNonBlock(fds[1], 1) != 0) goto error;
1081      if (FDAPI_PipeSetNonBlock(fds[2], 1) != 0) goto error;
1082  #endif
1083      server.aof_pipe_write_data_to_child = fds[1];
1084      server.aof_pipe_read_data_from_parent = fds[0];
1085      server.aof_pipe_write_ack_to_parent = fds[3];
1086      server.aof_pipe_read_ack_from_child = fds[2];
1087      server.aof_pipe_write_ack_to_child = fds[5];
1088      server.aof_pipe_read_ack_from_parent = fds[4];
1089      server.aof_stop_sending_diff = 0;
1090      return C_OK;
1091  error:
1092      serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
1093          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1094      for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
1095      return C_ERR;
1096  }
1097  void aofClosePipes(void) {
1098      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1099      aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
1100      close(server.aof_pipe_write_data_to_child);
1101      close(server.aof_pipe_read_data_from_parent);
1102      close(server.aof_pipe_write_ack_to_parent);
1103      close(server.aof_pipe_read_ack_from_child);
1104      close(server.aof_pipe_write_ack_to_child);
1105      close(server.aof_pipe_read_ack_from_parent);
1106  }
1107  int rewriteAppendOnlyFileBackground(void) {
1108      pid_t childpid;
1109      PORT_LONGLONG start;
1110      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1111      if (aofCreatePipes() != C_OK) return C_ERR;
1112      openChildInfoPipe();
1113      start = ustime();
1114  #ifndef _WIN32
1115      if ((childpid = fork()) == 0) {
1116  #endif
1117          char tmpfile[256];
1118  #ifndef _WIN32
1119          closeListeningSockets(0);
1120          redisSetProcTitle("redis-aof-rewrite");
1121  #endif
1122          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
1123  #ifdef _WIN32
1124          childpid = BeginForkOperation_Aof(server.aof_pipe_write_ack_to_parent,
1125              server.aof_pipe_read_ack_from_parent,
1126              server.aof_pipe_read_data_from_parent,
1127              tmpfile,
1128              &server,
1129              sizeof(server),
1130              dictGetHashFunctionSeed(),
1131              modules);
1132  #else
1133          if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
1134              size_t private_dirty = zmalloc_get_private_dirty(-1);
1135              if (private_dirty) {
1136                  serverLog(LL_NOTICE,
1137                      "AOF rewrite: %Iu MB of memory used by copy-on-write", WIN_PORT_FIX &bsol;* %zu -> %Iu */
1138                      private_dirty/(1024*1024));
1139              }
1140              server.child_info_data.cow_size = private_dirty;
1141              sendChildInfo(CHILD_INFO_TYPE_AOF);
1142              exitFromChild(0);
1143          } else {
1144              exitFromChild(1);
1145          }
1146      } else {
1147  #endif
1148          server.stat_fork_time = ustime()-start;
1149  #ifdef _WIN32
1150          if (server.stat_fork_time == 0) {
1151              server.stat_fork_time = 100000; 
1152          }
1153  #endif
1154          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1155          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1156          if (childpid == -1) {
1157              closeChildInfoPipe();
1158              serverLog(LL_WARNING,
1159                  "Can't rewrite append only file in background: fork: %s",
1160                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1161              aofClosePipes();
1162              return C_ERR;
1163          }
1164          serverLog(LL_NOTICE,
1165              "Background append only file rewriting started by pid %d",childpid);
1166          server.aof_rewrite_scheduled = 0;
1167          server.aof_rewrite_time_start = time(NULL);
1168          server.aof_child_pid = childpid;
1169          updateDictResizePolicy();
1170          server.aof_selected_db = -1;
1171          replicationScriptCacheFlush();
1172          return C_OK;
1173  #ifndef _WIN32
1174      }
1175  #endif
1176      return C_OK; &bsol;* unreached */
1177  }
1178  void bgrewriteaofCommand(client *c) {
1179      if (server.aof_child_pid != -1) {
1180          addReplyError(c,"Background append only file rewriting already in progress");
1181      } else if (server.rdb_child_pid != -1) {
1182          server.aof_rewrite_scheduled = 1;
1183          addReplyStatus(c,"Background append only file rewriting scheduled");
1184      } else if (rewriteAppendOnlyFileBackground() == C_OK) {
1185          addReplyStatus(c,"Background append only file rewriting started");
1186      } else {
1187          addReply(c,shared.err);
1188      }
1189  }
1190  void aofRemoveTempFile(pid_t childpid) {
1191      char tmpfile[256];
1192      snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) childpid);
1193      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1194      unlink(tmpfile);
1195  }
1196  void aofUpdateCurrentSize(void) {
1197      struct redis_stat sb;
1198      mstime_t latency;
1199  #ifdef _WIN32
1200      if (server.aof_fd == -1) {
1201          serverLog(LL_NOTICE, "Unable to check the AOF length: %s", "appendfd is -1");
1202          return;
1203      }
1204  #endif
1205      latencyStartMonitor(latency);
1206      if (redis_fstat(server.aof_fd,&sb) == -1) {
1207          serverLog(LL_WARNING,"Unable to obtain the AOF file length. stat: %s",
1208              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1209      } else {
1210          server.aof_current_size = sb.st_size;
1211      }
1212      latencyEndMonitor(latency);
1213      latencyAddSampleIfNeeded("aof-fstat",latency);
1214  }
1215  void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
1216      if (!bysignal && exitcode == 0) {
1217          int newfd, oldfd;
1218          char tmpfile[256];
1219          PORT_LONGLONG now = ustime();
1220          mstime_t latency;
1221          serverLog(LL_NOTICE,
1222              "Background AOF rewrite terminated with success");
1223          latencyStartMonitor(latency);
1224  #ifdef _WIN32
1225          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1226              getpid());
1227          newfd = open(tmpfile,O_WRONLY|O_APPEND|O_CREAT|_O_BINARY,_S_IREAD|_S_IWRITE);
1228  #else
1229          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1230              (int)server.aof_child_pid);
1231          newfd = open(tmpfile,O_WRONLY|O_APPEND);
1232  #endif
1233          if (newfd == -1) {
1234              serverLog(LL_WARNING,
1235                  "Unable to open the temporary AOF produced by the child: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1236              goto cleanup;
1237          }
1238          if (aofRewriteBufferWrite(newfd) == -1) {
1239              serverLog(LL_WARNING,
1240                  "Error trying to flush the parent diff to the rewritten AOF: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1241              close(newfd);
1242              goto cleanup;
1243          }
1244          latencyEndMonitor(latency);
1245          latencyAddSampleIfNeeded("aof-rewrite-diff-write",latency);
1246          serverLog(LL_NOTICE,
1247              "Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)", (double) (aofRewriteBufferSize() / (1024*1024)));  WIN_PORT_FIX
1248  #ifdef _WIN32
1249          oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1250          char tmpfile_win_old[256];
1251          snprintf(tmpfile_win_old, 256, "temp-rewriteaof-old-%d.aof",
1252              (int) server.aof_child_pid);
1253          if (server.aof_fd != -1) {
1254              close(server.aof_fd);
1255              if (rename(server.aof_filename, tmpfile_win_old) == -1) {
1256                  serverLog(LL_WARNING,
1257                      "Error trying to rename the existing AOF to old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1258                  unlink(tmpfile_win_old);
1259                  goto cleanup;
1260              }
1261          }
1262          latencyStartMonitor(latency);
1263          close(newfd);
1264          if (rename(tmpfile, server.aof_filename) == -1) {
1265              serverLog(LL_WARNING,
1266                  "Error trying to rename the temporary AOF file %s into %s: %s",
1267                  tmpfile,
1268                  server.aof_filename,
1269                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1270              if (server.aof_fd != -1) {
1271                  if (rename(tmpfile_win_old, server.aof_filename) == -1) {
1272                      serverLog(LL_WARNING,
1273                          "Error trying to rename the old tempfile %s into the existing AOF file %s: %s",
1274                          tmpfile,
1275                          server.aof_filename,
1276                          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1277                      serverLog(LL_WARNING,
1278                          "Error trying to rename the existing AOF from old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1279                  }
1280              }
1281              goto cleanup;
1282          }
1283          newfd = open(server.aof_filename, O_WRONLY | O_APPEND | _O_BINARY, 0);
1284          if (newfd == -1) {
1285              serverLog(LL_WARNING, "Not able to reopen the temporary AOF file after rename");
1286              goto cleanup;
1287          }
1288          if (server.aof_fd != -1) {
1289              server.aof_fd = open(
1290                  tmpfile_win_old,
1291                  O_WRONLY | O_APPEND | O_CREAT | _O_BINARY | _O_TEMPORARY,     
1292                  0644);
1293          }
1294  #else
1295          if (server.aof_fd == -1) {
1296              oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
1297          } else {
1298              oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1299          }
1300          latencyStartMonitor(latency);
1301          if (rename(tmpfile,server.aof_filename) == -1) {
1302              serverLog(LL_WARNING,
1303                  "Error trying to rename the temporary AOF file %s into %s: %s",
1304                  tmpfile,
1305                  server.aof_filename,
1306                  strerror(errno));
1307              close(newfd);
1308              if (oldfd != -1) close(oldfd);
1309              goto cleanup;
1310          }
1311  #endif
1312          latencyEndMonitor(latency);
1313          latencyAddSampleIfNeeded("aof-rename",latency);
1314          if (server.aof_fd == -1) {
1315              close(newfd);
1316          } else {
1317              oldfd = server.aof_fd;
1318              server.aof_fd = newfd;
1319              if (server.aof_fsync == AOF_FSYNC_ALWAYS)
1320                  redis_fsync(newfd);
1321              else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
1322                  aof_background_fsync(newfd);
1323              server.aof_selected_db = -1; &bsol;* Make sure SELECT is re-issued */
1324              aofUpdateCurrentSize();
1325              server.aof_rewrite_base_size = server.aof_current_size;
1326              server.aof_fsync_offset = server.aof_current_size;
1327              sdsfree(server.aof_buf);
1328              server.aof_buf = sdsempty();
1329          }
1330          server.aof_lastbgrewrite_status = C_OK;
1331          serverLog(LL_NOTICE, "Background AOF rewrite finished successfully");
1332          if (server.aof_state == AOF_WAIT_REWRITE)
1333              server.aof_state = AOF_ON;
1334          if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
1335          serverLog(LL_VERBOSE,
1336              "Background AOF rewrite signal handler took %lldus", ustime()-now);
1337      } else if (!bysignal && exitcode != 0) {
1338          server.aof_lastbgrewrite_status = C_ERR;
1339          serverLog(LL_WARNING,
1340              "Background AOF rewrite terminated with error");
1341      } else {
1342          if (bysignal != SIGUSR1)
1343              server.aof_lastbgrewrite_status = C_ERR;
1344          serverLog(LL_WARNING,
1345              "Background AOF rewrite terminated by signal %d", bysignal);
1346      }
1347  cleanup:
1348      aofClosePipes();
1349      aofRewriteBufferReset();
1350      aofRemoveTempFile(IF_WIN32(getpid(), server.aof_child_pid));
1351      server.aof_child_pid = -1;
1352      server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
1353      server.aof_rewrite_time_start = -1;
1354      if (server.aof_state == AOF_WAIT_REWRITE)
1355          server.aof_rewrite_scheduled = 1;
1356  }
1357  #ifdef _WIN32
1358  void aofProcessDiffRewriteEvents(aeEventLoop* eventLoop)
1359  {
1360      if (server.aof_child_pid != -1 && server.aof_pipe_read_ack_from_child != -1) {
1361          if (server.aof_stop_sending_diff == 0) {
1362              aofChildWriteDiffData(eventLoop,server.aof_pipe_write_data_to_child,NULL,0);
1363          }
1364          if (server.aof_stop_sending_diff == 0) {
1365              aofChildPipeReadable(eventLoop,server.aof_pipe_read_ack_from_child,NULL,0);
1366          }
1367      }
1368  }
1369  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <string.h>
3  #include <stdlib.h>
4  #ifndef _WIN32
5  #include <unistd.h>
6  #endif
7  #include <assert.h>
8  #include <errno.h>
9  #include <ctype.h>
10  #include "hiredis.h"
11  #include "net.h"
12  #include "sds.h"
13  #ifdef _WIN32
14  #include "win32_hiredis.h"
15  #endif
16  static redisReply *createReplyObject(int type);
17  static void *createStringObject(const redisReadTask *task, char *str, size_t len);
18  static void *createArrayObject(const redisReadTask *task, int elements);
19  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value);
20  static void *createNilObject(const redisReadTask *task);
21  static redisReplyObjectFunctions defaultFunctions = {
22  	createStringObject,
23  	createArrayObject,
24  	createIntegerObject,
25  	createNilObject,
26  	freeReplyObject
27  };
28  static redisReply *createReplyObject(int type) {
29  	redisReply *r = calloc(1, sizeof(*r));
30  	if (r == NULL)
31  		return NULL;
32  	r->type = type;
33  	return r;
34  }
35  void freeReplyObject(void *reply) {
36  	redisReply *r = reply;
37  	size_t j;
38  	if (r == NULL)
39  		return;
40  	switch (r->type) {
41  	case REDIS_REPLY_INTEGER:
42  		break; &bsol;* Nothing to free */
43  	case REDIS_REPLY_ARRAY:
44  		if (r->element != NULL) {
45  			for (j = 0; j < r->elements; j++)
46  				if (r->element[j] != NULL)
47  					freeReplyObject(r->element[j]);
48  			free(r->element);
49  		}
50  		break;
51  	case REDIS_REPLY_ERROR:
52  	case REDIS_REPLY_STATUS:
53  	case REDIS_REPLY_STRING:
54  		if (r->str != NULL)
55  			free(r->str);
56  		break;
57  	}
58  	free(r);
59  }
60  static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
61  	redisReply *r, *parent;
62  	char *buf;
63  	r = createReplyObject(task->type);
64  	if (r == NULL)
65  		return NULL;
66  	buf = malloc(len + 1);
67  	if (buf == NULL) {
68  		freeReplyObject(r);
69  		return NULL;
70  	}
71  	assert(task->type == REDIS_REPLY_ERROR ||
72  		task->type == REDIS_REPLY_STATUS ||
73  		task->type == REDIS_REPLY_STRING);
74  	memcpy(buf, str, len);
75  	buf[len] = '\0';
76  	r->str = buf;
77  	r->len = (int)len;
78  	if (task->parent) {
79  		parent = task->parent->obj;
80  		assert(parent->type == REDIS_REPLY_ARRAY);
81  		parent->element[task->idx] = r;
82  	}
83  	return r;
84  }
85  static void *createArrayObject(const redisReadTask *task, int elements) {
86  	redisReply *r, *parent;
87  	r = createReplyObject(REDIS_REPLY_ARRAY);
88  	if (r == NULL)
89  		return NULL;
90  	if (elements > 0) {
91  		r->element = calloc(elements, sizeof(redisReply*));
92  		if (r->element == NULL) {
93  			freeReplyObject(r);
94  			return NULL;
95  		}
96  	}
97  	r->elements = elements;
98  	if (task->parent) {
99  		parent = task->parent->obj;
100  		assert(parent->type == REDIS_REPLY_ARRAY);
101  		parent->element[task->idx] = r;
102  	}
103  	return r;
104  }
105  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value) {
106  	redisReply *r, *parent;
107  	r = createReplyObject(REDIS_REPLY_INTEGER);
108  	if (r == NULL)
109  		return NULL;
110  	r->integer = value;
111  	if (task->parent) {
112  		parent = task->parent->obj;
113  		assert(parent->type == REDIS_REPLY_ARRAY);
114  		parent->element[task->idx] = r;
115  	}
116  	return r;
117  }
118  static void *createNilObject(const redisReadTask *task) {
119  	redisReply *r, *parent;
120  	r = createReplyObject(REDIS_REPLY_NIL);
121  	if (r == NULL)
122  		return NULL;
123  	if (task->parent) {
124  		parent = task->parent->obj;
125  		assert(parent->type == REDIS_REPLY_ARRAY);
126  		parent->element[task->idx] = r;
127  	}
128  	return r;
129  }
130  static uint32_t countDigits(uint64_t v) {
131  	uint32_t result = 1;
132  	for (;;) {
133  		if (v < 10) return result;
134  		if (v < 100) return result + 1;
135  		if (v < 1000) return result + 2;
136  		if (v < 10000) return result + 3;
137  		v /= 10000U;
138  		result += 4;
139  	}
140  }
141  static size_t bulklen(size_t len) {
142  	return (size_t)(1 + countDigits(len) + 2 + len + 2);
143  }
144  int redisvFormatCommand(char **target, const char *format, va_list ap) {
145  	const char *c = format;
146  	char *cmd = NULL; &bsol;* final command */
147  	int pos; &bsol;* position in final command */
148  	sds curarg, newarg; &bsol;* current argument */
149  	int touched = 0; &bsol;* was the current argument touched? */
150  	char **curargv = NULL, **newargv = NULL;
151  	int argc = 0;
152  	int totlen = 0;
153  	int error_type = 0; &bsol;* 0 = no error; -1 = memory error; -2 = format error */
154  	int j;
155  	if (target == NULL)
156  		return -1;
157  	curarg = sdsempty();
158  	if (curarg == NULL)
159  		return -1;
160  	while (*c != '\0') {
161  		if (*c != '%' || c[1] == '\0') {
162  			if (*c == ' ') {
163  				if (touched) {
164  					newargv = realloc(curargv, sizeof(char*)*(argc + 1));
165  					if (newargv == NULL) goto memory_err;
166  					curargv = newargv;
167  					curargv[argc++] = curarg;
168  					totlen += (int)bulklen(sdslen(curarg));
169  					curarg = sdsempty();
170  					if (curarg == NULL) goto memory_err;
171  					touched = 0;
172  				}
173  			}
174  			else {
175  				newarg = sdscatlen(curarg, c, 1);
176  				if (newarg == NULL) goto memory_err;
177  				curarg = newarg;
178  				touched = 1;
179  			}
180  		}
181  		else {
182  			char *arg;
183  			size_t size;
184  			newarg = curarg;
185  			switch (c[1]) {
186  			case 's':
187  				arg = va_arg(ap, char*);
188  				size = strlen(arg);
189  				if (size > 0)
190  					newarg = sdscatlen(curarg, arg, size);
191  				break;
192  			case 'b':
193  				arg = va_arg(ap, char*);
194  				size = va_arg(ap, size_t);
195  				if (size > 0)
196  					newarg = sdscatlen(curarg, arg, size);
197  				break;
198  			case '%':
199  				newarg = sdscat(curarg, "%");
200  				break;
201  			default:
202  			{
203  				static const char intfmts[] = "diouxX";
204  				static const char flags[] = "#0-+ ";
205  				char _format[16];
206  				const char *_p = c + 1;
207  				size_t _l = 0;
208  				va_list _cpy;
209  				while (*_p != '\0' && strchr(flags, *_p) != NULL) _p++;
210  				while (*_p != '\0' && isdigit(*_p)) _p++;
211  				if (*_p == '.') {
212  					_p++;
213  					while (*_p != '\0' && isdigit(*_p)) _p++;
214  				}
215  				va_copy(_cpy, ap);
216  				if (strchr(intfmts, *_p) != NULL) {
217  					va_arg(ap, int);
218  					goto fmt_valid;
219  				}
220  				if (strchr("eEfFgGaA", *_p) != NULL) {
221  					va_arg(ap, double);
222  					goto fmt_valid;
223  				}
224  				if (_p[0] == 'h' && _p[1] == 'h') {
225  					_p += 2;
226  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
227  						va_arg(ap, int); &bsol;* char gets promoted to int */
228  						goto fmt_valid;
229  					}
230  					goto fmt_invalid;
231  				}
232  				if (_p[0] == 'h') {
233  					_p += 1;
234  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
235  						va_arg(ap, int); &bsol;* short gets promoted to int */
236  						goto fmt_valid;
237  					}
238  					goto fmt_invalid;
239  				}
240  				if (_p[0] == 'l' && _p[1] == 'l') {
241  					_p += 2;
242  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
243  						va_arg(ap, PORT_LONGLONG);
244  						goto fmt_valid;
245  					}
246  					goto fmt_invalid;
247  				}
248  				if (_p[0] == 'l') {
249  					_p += 1;
250  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
251  						va_arg(ap, PORT_LONG);
252  						goto fmt_valid;
253  					}
254  					goto fmt_invalid;
255  				}
256  			fmt_invalid:
257  				va_end(_cpy);
258  				goto format_err;
259  			fmt_valid:
260  				_l = (_p + 1) - c;
261  				if (_l < sizeof(_format) - 2) {
262  					memcpy(_format, c, _l);
263  					_format[_l] = '\0';
264  					newarg = sdscatvprintf(curarg, _format, _cpy);
265  					c = _p - 1;
266  				}
267  				va_end(_cpy);
268  				break;
269  			}
270  			}
271  			if (newarg == NULL) goto memory_err;
272  			curarg = newarg;
273  			touched = 1;
274  			c++;
275  		}
276  		c++;
277  	}
278  	if (touched) {
279  		newargv = realloc(curargv, sizeof(char*)*(argc + 1));
280  		if (newargv == NULL) goto memory_err;
281  		curargv = newargv;
282  		curargv[argc++] = curarg;
283  		totlen += (int)bulklen(sdslen(curarg));
284  	}	else {
285  		sdsfree(curarg);
286  	}
287  	curarg = NULL;
288  	totlen += 1 + countDigits(argc) + 2;
289  	cmd = malloc(totlen + 1);
290  	if (cmd == NULL) goto memory_err;
291  	pos = sprintf(cmd, "*%d\r\n", argc);
292  	for (j = 0; j < argc; j++) {
293  		pos += sprintf(cmd + pos, "$%Iu\r\n", sdslen(curargv[j]));                  WIN_PORT_FIX &bsol;* %zu -> %Iu */
294  			memcpy(cmd + pos, curargv[j], sdslen(curargv[j]));
295  		pos += (int)sdslen(curargv[j]);
296  		sdsfree(curargv[j]);
<span onclick='openModal()' class='match'>297  		cmd[pos++] = '\r';
298  		cmd[pos++] = '\n';
299  	}
</span>300  	assert(pos == totlen);
301  	cmd[pos] = '\0';
302  	free(curargv);
303  	*target = cmd;
304  	return totlen;
305  format_err:
306  	error_type = -2;
307  	goto cleanup;
308  memory_err:
309  	error_type = -1;
310  	goto cleanup;
311  cleanup:
312  	if (curargv) {
313  		while (argc--)
314  			sdsfree(curargv[argc]);
315  		free(curargv);
316  	}
317  	sdsfree(curarg);
318  	if (cmd != NULL)
319  		free(cmd);
320  	return error_type;
321  }
322  int redisFormatCommand(char **target, const char *format, ...) {
323  	va_list ap;
324  	int len;
325  	va_start(ap, format);
326  	len = redisvFormatCommand(target, format, ap);
327  	va_end(ap);
328  	if (len < 0)
329  		len = -1;
330  	return len;
331  }
332  int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
333  	const size_t *argvlen)
334  {
335  	sds cmd;
336  	PORT_ULONGLONG totlen;
337  	int j;
338  	size_t len;
339  	if (target == NULL)
340  		return -1;
341  	totlen = 1 + countDigits(argc) + 2;
342  	for (j = 0; j < argc; j++) {
343  		len = argvlen ? argvlen[j] : strlen(argv[j]);
344  		totlen += bulklen(len);
345  	}
346  	cmd = sdsempty();
347  	if (cmd == NULL)
348  		return -1;
349  	cmd = sdsMakeRoomFor(cmd, totlen);
350  	if (cmd == NULL)
351  		return -1;
352  	cmd = sdscatfmt(cmd, "*%i\r\n", argc);
353  	for (j = 0; j < argc; j++) {
354  		len = argvlen ? argvlen[j] : strlen(argv[j]);
355  		cmd = sdscatfmt(cmd, "$%u\r\n", len);
356  		cmd = sdscatlen(cmd, argv[j], len);
357  		cmd = sdscatlen(cmd, "\r\n", sizeof("\r\n") - 1);
358  	}
359  	assert(sdslen(cmd) == totlen);
360  	*target = cmd;
361  	return totlen;
362  }
363  void redisFreeSdsCommand(sds cmd) {
364  	sdsfree(cmd);
365  }
366  int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
367  	char *cmd = NULL; &bsol;* final command */
368  	int pos; &bsol;* position in final command */
369  	size_t len;
370  	int totlen, j;
371  	if (target == NULL)
372  		return -1;
373  	totlen = 1 + countDigits(argc) + 2;
374  	for (j = 0; j < argc; j++) {
375  		len = argvlen ? argvlen[j] : strlen(argv[j]);
376  		totlen += bulklen(len);
377  	}
378  	cmd = malloc(totlen + 1);
379  	if (cmd == NULL)
380  		return -1;
381  	pos = sprintf(cmd, "*%d\r\n", argc);
382  	for (j = 0; j < argc; j++) {
383  		len = argvlen ? argvlen[j] : strlen(argv[j]);
384  		pos += sprintf(cmd + pos, "$%Iu\r\n", len);                                 WIN_PORT_FIX &bsol;* %zu -> %Iu */
385  			memcpy(cmd + pos, argv[j], len);
386  		pos += (int)len;
387  		cmd[pos++] = '\r';
388  		cmd[pos++] = '\n';
389  	}
390  	assert(pos == totlen);
391  	cmd[pos] = '\0';
392  	*target = cmd;
393  	return totlen;
394  }
395  void redisFreeCommand(char *cmd) {
396  	free(cmd);
397  }
398  void __redisSetError(redisContext *c, int type, const char *str) {
399  	size_t len;
400  	c->err = type;
401  	if (str != NULL) {
402  		len = strlen(str);
403  		len = len < (sizeof(c->errstr) - 1) ? len : (sizeof(c->errstr) - 1);
404  		memcpy(c->errstr, str, len);
405  		c->errstr[len] = '\0';
406      } else {
407  		assert(type == REDIS_ERR_IO);
408  		__redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
409  	}
410  }
411  redisReader *redisReaderCreate(void) {
412  	return redisReaderCreateWithFunctions(&defaultFunctions);
413  }
414  static redisContext *redisContextInit(void) {
415  	redisContext *c;
416  	c = calloc(1, sizeof(redisContext));
417  	if (c == NULL)
418  		return NULL;
419  	c->err = 0;
420  	c->errstr[0] = '\0';
421  	c->obuf = sdsempty();
422  	c->reader = redisReaderCreate();
423  	c->tcp.host = NULL;
424  	c->tcp.source_addr = NULL;
425  	c->unix_sock.path = NULL;
426  	c->timeout = NULL;
427  	if (c->obuf == NULL || c->reader == NULL) {
428  		redisFree(c);
429  		return NULL;
430  	}
431  	return c;
432  }
433  void redisFree(redisContext *c) {
434  	if (c == NULL)
435  		return;
436  	if (c->fd > 0)
437  		close(c->fd);
438  	if (c->obuf != NULL)
439  		sdsfree(c->obuf);
440  	if (c->reader != NULL)
441  		redisReaderFree(c->reader);
442  	if (c->tcp.host)
443  		free(c->tcp.host);
444  	if (c->tcp.source_addr)
445  		free(c->tcp.source_addr);
446  	if (c->unix_sock.path)
447  		free(c->unix_sock.path);
448  	if (c->timeout)
449  		free(c->timeout);
450  	free(c);
451  }
452  int redisFreeKeepFd(redisContext *c) {
453  	int fd = c->fd;
454  	c->fd = -1;
455  	redisFree(c);
456  	return fd;
457  }
458  int redisReconnect(redisContext *c) {
459  	c->err = 0;
460  	memset(c->errstr, '\0', strlen(c->errstr));
461  	if (c->fd > 0) {
462  		close(c->fd);
463  	}
464  	sdsfree(c->obuf);
465  	redisReaderFree(c->reader);
466  	c->obuf = sdsempty();
467  	c->reader = redisReaderCreate();
468  	if (c->connection_type == REDIS_CONN_TCP) {
469  		return redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
470  			c->timeout, c->tcp.source_addr);
471      } else if (c->connection_type == REDIS_CONN_UNIX) {
472  		return redisContextConnectUnix(c, c->unix_sock.path, c->timeout);
473      } else {
474  		__redisSetError(c, REDIS_ERR_OTHER, "Not enough information to reconnect");
475  	}
476  	return REDIS_ERR;
477  }
478  redisContext *redisConnect(const char *ip, int port) {
479  	redisContext *c;
480  	c = redisContextInit();
481  	if (c == NULL)
482  		return NULL;
483  	c->flags |= REDIS_BLOCK;
484  	redisContextConnectTcp(c, ip, port, NULL);
485  	return c;
486  }
487  redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
488  	redisContext *c;
489  	c = redisContextInit();
490  	if (c == NULL)
491  		return NULL;
492  	c->flags |= REDIS_BLOCK;
493  	redisContextConnectTcp(c, ip, port, &tv);
494  	return c;
495  }
496  redisContext *redisConnectNonBlock(const char *ip, int port) {
497  	redisContext *c;
498  	c = redisContextInit();
499  	if (c == NULL)
500  		return NULL;
501  	c->flags &= ~REDIS_BLOCK;
502  	redisContextConnectTcp(c, ip, port, NULL);
503  	return c;
504  }
505  redisContext *redisConnectBindNonBlock(const char *ip, int port,
506  	const char *source_addr) {
507  	redisContext *c = redisContextInit();
508  	c->flags &= ~REDIS_BLOCK;
509  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
510  	return c;
511  }
512  redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
513  	const char *source_addr) {
514  	redisContext *c = redisContextInit();
515  	c->flags &= ~REDIS_BLOCK;
516  	c->flags |= REDIS_REUSEADDR;
517  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
518  	return c;
519  }
520  redisContext *redisConnectUnix(const char *path) {
521  	redisContext *c;
522  	c = redisContextInit();
523  	if (c == NULL)
524  		return NULL;
525  	c->flags |= REDIS_BLOCK;
526  	redisContextConnectUnix(c, path, NULL);
527  	return c;
528  }
529  redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {
530  	redisContext *c;
531  	c = redisContextInit();
532  	if (c == NULL)
533  		return NULL;
534  	c->flags |= REDIS_BLOCK;
535  	redisContextConnectUnix(c, path, &tv);
536  	return c;
537  }
538  redisContext *redisConnectUnixNonBlock(const char *path) {
539  	redisContext *c;
540  	c = redisContextInit();
541  	if (c == NULL)
542  		return NULL;
543  	c->flags &= ~REDIS_BLOCK;
544  	redisContextConnectUnix(c, path, NULL);
545  	return c;
546  }
547  redisContext *redisConnectFd(int fd) {
548  	redisContext *c;
549  	c = redisContextInit();
550  	if (c == NULL)
551  		return NULL;
552  	c->fd = fd;
553  	c->flags |= REDIS_BLOCK | REDIS_CONNECTED;
554  	return c;
555  }
556  #ifdef _WIN32
557  redisContext *redisPreConnectNonBlock(const char *ip, int port, SOCKADDR_STORAGE *ss) {
558  	redisContext *c = redisContextInit();
559  	c->fd = -1;
560  	c->flags &= ~REDIS_BLOCK;
561  	redisContextPreConnectTcp(c, ip, port, NULL, ss);
562  	return c;
563  }
564  #endif
565  int redisSetTimeout(redisContext *c, const struct timeval tv) {
566  	if (c->flags & REDIS_BLOCK)
567  		return redisContextSetTimeout(c, tv);
568  	return REDIS_ERR;
569  }
570  int redisEnableKeepAlive(redisContext *c) {
571  	if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)
572  		return REDIS_ERR;
573  	return REDIS_OK;
574  }
575  int redisBufferRead(redisContext *c) {
576  	char buf[1024 * 16];
577  	int nread;
578  	if (c->err)
579  		return REDIS_ERR;
580  	nread = (int)read(c->fd, buf, sizeof(buf));                                   WIN_PORT_FIX &bsol;* cast (int) */
581  		if (nread == -1) {
582  			if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
583  			}
584  			else {
585  				__redisSetError(c, REDIS_ERR_IO, NULL);
586  				return REDIS_ERR;
587  			}
588  		}
589  		else if (nread == 0) {
590  			__redisSetError(c, REDIS_ERR_EOF, "Server closed the connection");
591  			return REDIS_ERR;
592  		}
593  		else {
594  			if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
595  				__redisSetError(c, c->reader->err, c->reader->errstr);
596  				return REDIS_ERR;
597  			}
598  		}
599  		return REDIS_OK;
600  }
601  #ifdef _WIN32
602  int redisBufferReadDone(redisContext *c, char *buf, ssize_t nread) {
603  	if (nread == -1) {
604  		if (errno == EAGAIN && !(c->flags & REDIS_BLOCK)) {
605  		}
606  		else {
607  			__redisSetError(c, REDIS_ERR_IO, NULL);
608  			return REDIS_ERR;
609  		}
610  	}
611  	else if (nread == 0) {
612  		__redisSetError(c, REDIS_ERR_EOF, sdsnew("Server closed the connection"));
613  		return REDIS_ERR;
614  	}
615  	else {
616  		if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
617  			__redisSetError(c, c->reader->err, c->reader->errstr);
618  			return REDIS_ERR;
619  		}
620  	}
621  	return REDIS_OK;
622  }
623  #endif
624  int redisBufferWrite(redisContext *c, int *done) {
625  	int nwritten;
626  	if (c->err)
627  		return REDIS_ERR;
628  	if (sdslen(c->obuf) > 0) {
629  		nwritten = (int)write(c->fd, c->obuf, sdslen(c->obuf));                   WIN_PORT_FIX &bsol;* cast (int) */
630  			if (nwritten == -1) {
631  				if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
632  				}
633  				else {
634  					__redisSetError(c, REDIS_ERR_IO, NULL);
635  					return REDIS_ERR;
636  				}
637  			}
638  			else if (nwritten > 0) {
639  				if (nwritten == (signed)sdslen(c->obuf)) {
640  					sdsfree(c->obuf);
641  					c->obuf = sdsempty();
642  				}
643  				else {
644  					sdsrange(c->obuf, nwritten, -1);
645  				}
646  			}
647  	}
648  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
649  	return REDIS_OK;
650  }
651  #ifdef _WIN32
652  int redisBufferWriteDone(redisContext *c, int nwritten, int *done) {
653  	if (nwritten > 0) {
654  		if (nwritten == (signed)sdslen(c->obuf)) {
655  			sdsfree(c->obuf);
656  			c->obuf = sdsempty();
657  		}
658  		else {
659  			sdsrange(c->obuf, nwritten, -1);
660  		}
661  	}
662  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
663  	return REDIS_OK;
664  }
665  #endif
666  int redisGetReplyFromReader(redisContext *c, void **reply) {
667  	if (redisReaderGetReply(c->reader, reply) == REDIS_ERR) {
668  		__redisSetError(c, c->reader->err, c->reader->errstr);
669  		return REDIS_ERR;
670  	}
671  	return REDIS_OK;
672  }
673  int redisGetReply(redisContext *c, void **reply) {
674  	int wdone = 0;
675  	void *aux = NULL;
676  	if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
677  		return REDIS_ERR;
678  	if (aux == NULL && c->flags & REDIS_BLOCK) {
679  		do {
680  			if (redisBufferWrite(c, &wdone) == REDIS_ERR)
681  				return REDIS_ERR;
682  		} while (!wdone);
683  		do {
684  			if (redisBufferRead(c) == REDIS_ERR)
685  				return REDIS_ERR;
686  			if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
687  				return REDIS_ERR;
688  		} while (aux == NULL);
689  	}
690  	if (reply != NULL) *reply = aux;
691  	return REDIS_OK;
692  }
693  int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
694  	sds newbuf;
695  	newbuf = sdscatlen(c->obuf, cmd, len);
696  	if (newbuf == NULL) {
697  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
698  		return REDIS_ERR;
699  	}
700  	c->obuf = newbuf;
701  	return REDIS_OK;
702  }
703  int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
704  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
705  		return REDIS_ERR;
706  	}
707  	return REDIS_OK;
708  }
709  int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {
710  	char *cmd;
711  	int len;
712  	len = redisvFormatCommand(&cmd, format, ap);
713  	if (len == -1) {
714  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
715  		return REDIS_ERR;
716  	}
717  	else if (len == -2) {
718  		__redisSetError(c, REDIS_ERR_OTHER, "Invalid format string");
719  		return REDIS_ERR;
720  	}
721  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
722  		free(cmd);
723  		return REDIS_ERR;
724  	}
725  	free(cmd);
726  	return REDIS_OK;
727  }
728  int redisAppendCommand(redisContext *c, const char *format, ...) {
729  	va_list ap;
730  	int ret;
731  	va_start(ap, format);
732  	ret = redisvAppendCommand(c, format, ap);
733  	va_end(ap);
734  	return ret;
735  }
736  int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
737  	sds cmd;
738  	int len;
739  	len = redisFormatSdsCommandArgv(&cmd, argc, argv, argvlen);
740  	if (len == -1) {
741  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
742  		return REDIS_ERR;
743  	}
744  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
745  		sdsfree(cmd);
746  		return REDIS_ERR;
747  	}
748  	sdsfree(cmd);
749  	return REDIS_OK;
750  }
751  static void *__redisBlockForReply(redisContext *c) {
752  	void *reply;
753  	if (c->flags & REDIS_BLOCK) {
754  		if (redisGetReply(c, &reply) != REDIS_OK)
755  			return NULL;
756  		return reply;
757  	}
758  	return NULL;
759  }
760  void *redisvCommand(redisContext *c, const char *format, va_list ap) {
761  	if (redisvAppendCommand(c, format, ap) != REDIS_OK)
762  		return NULL;
763  	return __redisBlockForReply(c);
764  }
765  void *redisCommand(redisContext *c, const char *format, ...) {
766  	va_list ap;
767  	void *reply = NULL;
768  	va_start(ap, format);
769  	reply = redisvCommand(c, format, ap);
770  	va_end(ap);
771  	return reply;
772  }
773  void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
774  	if (redisAppendCommandArgv(c, argc, argv, argvlen) != REDIS_OK)
775  		return NULL;
776  	return __redisBlockForReply(c);
777  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</div>
                </div>
                <div class="column column_space"><pre><code>345      buf[len++] = '\r';
346      buf[len++] = '\n';
347      dst = sdscatlen(dst,buf,len);
</pre></code></div>
                <div class="column column_space"><pre><code>297  		cmd[pos++] = '\r';
298  		cmd[pos++] = '\n';
299  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    