<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for unpremultiply.c &amp; pdfiumload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for unpremultiply.c &amp; pdfiumload.c
      </h3>
<h1 align="center">
        6.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>unpremultiply.c (13.513514%)<th>pdfiumload.c (3.9840639%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(245-268)<td><a href="#" name="0">(838-861)</a><td align="center"><font color="#ff0000">20</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>unpremultiply.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* unpremultiply alpha
 *
 * Author: John Cupitt
 * Written on: 7/5/15
 *
 * 25/5/16
 * 	- max_alpha defaults to 65535 for RGB16/GREY16
 * 24/11/17 lovell
 * 	- match normalised alpha to output type
 * 27/2/21 jjonesrs
 * 	- revise range clipping and 1/x, again
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

#include "pconversion.h"

typedef struct _VipsUnpremultiply {
	VipsConversion parent_instance;

	VipsImage *in;

	double max_alpha;
	int alpha_band;

} VipsUnpremultiply;

typedef VipsConversionClass VipsUnpremultiplyClass;

G_DEFINE_TYPE( VipsUnpremultiply, vips_unpremultiply, VIPS_TYPE_CONVERSION );

/* Unpremultiply an N-band image. Don't use clip_alpha to calculate factor: we
 * want over and undershoots on alpha and RGB to cancel.
 */
#define UNPRE_MANY( IN, OUT ) { \
	IN * restrict p = (IN *) in; \
	OUT * restrict q = (OUT *) out; \
	\
	for( x = 0; x &lt; width; x++ ) { \
		IN alpha = p[alpha_band]; \
		OUT factor = alpha == 0 ? 0 : max_alpha / alpha; \
		\
		for( i = 0; i &lt; alpha_band; i++ ) \
			q[i] = factor * p[i]; \
		q[alpha_band] = VIPS_CLIP( 0, alpha, max_alpha ); \
		for( i = alpha_band + 1; i &lt; bands; i++ ) \
			q[i] = p[i]; \
		\
		p += bands; \
		q += bands; \
	} \
}

/* Unpremultiply an RGB (four band) image.
 */
#define UNPRE_RGBA( IN, OUT ) { \
	IN * restrict p = (IN *) in; \
	OUT * restrict q = (OUT *) out; \
	\
	for( x = 0; x &lt; width; x++ ) { \
		IN alpha = p[3]; \
		OUT factor = alpha == 0 ? 0 : max_alpha / alpha; \
		\
		q[0] = factor * p[0]; \
		q[1] = factor * p[1]; \
		q[2] = factor * p[2]; \
		q[3] = VIPS_CLIP( 0, alpha, max_alpha ); \
		\
		p += 4; \
		q += 4; \
	} \
}

#define UNPRE( IN, OUT ) { \
	if( bands == 4 ) { \
		UNPRE_RGBA( IN, OUT ); \
	} \
	else { \
		UNPRE_MANY( IN, OUT ); \
	} \
}

static int
vips_unpremultiply_gen( VipsRegion *or, void *vseq, void *a, void *b,
	gboolean *stop )
{
	VipsUnpremultiply *unpremultiply = (VipsUnpremultiply *) b;
	VipsRegion *ir = (VipsRegion *) vseq;
	VipsImage *im = ir-&gt;im;
	VipsRect *r = &amp;or-&gt;valid;
	int width = r-&gt;width;
	int bands = im-&gt;Bands; 
	double max_alpha = unpremultiply-&gt;max_alpha;
	int alpha_band = unpremultiply-&gt;alpha_band;

	int x, y, i;

	if( vips_region_prepare( ir, r ) )
		return( -1 );

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		VipsPel *in = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); 
		VipsPel *out = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); 

		switch( im-&gt;BandFmt ) { 
		case VIPS_FORMAT_UCHAR: 
			UNPRE( unsigned char, float ); 
			break; 

		case VIPS_FORMAT_CHAR: 
			UNPRE( signed char, float ); 
			break; 

		case VIPS_FORMAT_USHORT: 
			UNPRE( unsigned short, float ); 
			break; 

		case VIPS_FORMAT_SHORT: 
			UNPRE( signed short, float ); 
			break; 

		case VIPS_FORMAT_UINT: 
			UNPRE( unsigned int, float ); 
			break; 

		case VIPS_FORMAT_INT: 
			UNPRE( signed int, float ); 
			break; 

		case VIPS_FORMAT_FLOAT: 
			UNPRE( float, float ); 
			break; 

		case VIPS_FORMAT_DOUBLE: 
			UNPRE( double, double ); 
			break; 

		case VIPS_FORMAT_COMPLEX: 
		case VIPS_FORMAT_DPCOMPLEX: 
		default: 
			g_assert_not_reached(); 
		} 
	}

	return( 0 );
}


static int
vips_unpremultiply_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsUnpremultiply *unpremultiply = (VipsUnpremultiply *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 1 );

	VipsImage *in;

	if( VIPS_OBJECT_CLASS( vips_unpremultiply_parent_class )-&gt;
		build( object ) )
		return( -1 );

	in = unpremultiply-&gt;in; 

	if( vips_image_decode( in, &amp;t[0] ) )
		return( -1 );
	in = t[0]; 

	/* Trivial case: fall back to copy().
	 */
	if( in-&gt;Bands == 1 )
		return( vips_image_write( in, conversion-&gt;out ) );

	if( vips_check_noncomplex( class-&gt;nickname, in ) )
		return( -1 );

	if( vips_image_pipelinev( conversion-&gt;out, 
		VIPS_DEMAND_STYLE_THINSTRIP, in, NULL ) )
		return( -1 );

	/* Is max-alpha unset? Default to the correct value for this
	 * interpretation.
	 */
	if( !vips_object_argument_isset( object, "max_alpha" ) ) 
		if( in-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
			in-&gt;Type == VIPS_INTERPRETATION_RGB16 )
			unpremultiply-&gt;max_alpha = 65535;

	/* Is alpha-band unset? Default to the final band for this image. 
	 */
	if( !vips_object_argument_isset( object, "alpha_band" ) ) 
		unpremultiply-&gt;alpha_band = in-&gt;Bands - 1;

	if( in-&gt;BandFmt == VIPS_FORMAT_DOUBLE )
		conversion-&gt;out-&gt;BandFmt = VIPS_FORMAT_DOUBLE;
	else
		conversion-&gt;out-&gt;BandFmt = VIPS_FORMAT_FLOAT;

<a name="0"></a>	if( vips_image_generate( conversion-&gt;out,
		vips_start_one, vips_unpremultiply_gen, vips_stop_one, 
		in, unpremultiply ) )
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );

	return( 0 );
}

static void
vips_unpremultiply_class_init( VipsUnpremultiplyClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );

	VIPS_DEBUG_MSG( "vips_unpremultiply_class_init\n" );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = "unpremultiply";
	vobject_class-&gt;description = _( "unpremultiply image alpha" );
	vobject_class-&gt;build = vips_unpremultiply_build;

	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;

	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
		_( "Input" ), 
		_( "Input image" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsUnpremultiply, in ) );

	VIPS_ARG_DOUBLE( class, "max_alpha", 115, 
		_( "Maximum alpha" ), 
		_( "Maximum value of alpha channel" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsUnpremultiply, max_alpha ),
		0, 100000000, 255 );

	VIPS_ARG_INT( class, "alpha_band", 116, 
		_( "Alpha band" ), 
		_( "Unpremultiply with this alpha" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsUnpremultiply, alpha_band ),
		0, 100000000, 3 );

}

static void
vips_unpremultiply_init( VipsUnpremultiply *unpremultiply )
{
	unpremultiply-&gt;max_alpha = 255.0;
}

/**
 * vips_unpremultiply: (method)
 * @in: input image
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @max_alpha: %gdouble, maximum value for alpha
 * * @alpha_band: %gint, band containing alpha data
 *
 * Unpremultiplies any alpha channel. 
 * Band @alpha_band (by default the final band) contains the alpha and all 
 * other bands are transformed as:
 *
 * |[
 *   alpha = (int) clip( 0, in[in.bands - 1], @max_alpha ); 
 *   norm = (double) alpha / @max_alpha; 
 *   if( alpha == 0 )
 *   	out = [0, ..., 0, alpha];
 *   else
 *   	out = [in[0] / norm, ..., in[in.bands - 1] / norm, alpha];
 * ]|
 *
 * So for an N-band image, the first N - 1 bands are divided by the clipped 
 * and normalised final band, the final band is clipped. 
 * If there is only a single band, the image is passed through unaltered.
 *
 * The result is
 * #VIPS_FORMAT_FLOAT unless the input format is #VIPS_FORMAT_DOUBLE, in which
 * case the output is double as well.
 *
 * @max_alpha has the default value 255, or 65535 for images tagged as
 * #VIPS_INTERPRETATION_RGB16 or
 * #VIPS_INTERPRETATION_GREY16. 
 *
 * Non-complex images only.
 *
 * See also: vips_premultiply(), vips_flatten().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_unpremultiply( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( "unpremultiply", ap, in, out );
	va_end( ap );

	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pdfiumload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* load PDF with PDFium
 *
 * 5/4/18
 * 	- from pdfload.c
 * 8/6/18
 * 	- add background param
 * 16/8/18
 * 	- shut down the input file as soon as we can [kleisauke]
 * 8/8/19
 * 	- add locks, since pdfium is not threadsafe in any way
 * 13/10/20
 * 	- have a lock just for pdfium [DarthSim]
 * 	- update for current pdfium
 * 	- add _source input
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/* TODO 
 *
 * - what about filename encodings?
 * - need to test on Windows
 */

/* How to build against PDFium:
 *
 * Download the prebuilt binary from: 
 *
 * 	https://github.com/bblanchon/pdfium-binaries
 *
 * Untar to the libvips install prefix, for example:
 *
 * 	cd ~/vips
 * 	tar xf ~/pdfium-linux.tgz
 *
 * Create a pdfium.pc like this (update the version number):
 *

VIPSHOME=/home/john/vips
cat &gt; $VIPSHOME/lib/pkgconfig/pdfium.pc &lt;&lt; EOF
     prefix=$VIPSHOME
     exec_prefix=\${prefix}
     libdir=\${exec_prefix}/lib
     includedir=\${prefix}/include
     Name: pdfium
     Description: pdfium
     Version: 4290
     Requires:
     Libs: -L\${libdir} -lpdfium
     Cflags: -I\${includedir}
EOF

 * 
 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/buf.h&gt;
#include &lt;vips/internal.h&gt;

#include "pforeign.h"

#ifdef HAVE_PDFIUM

#include &lt;fpdfview.h&gt;
#include &lt;fpdf_doc.h&gt;

typedef struct _VipsForeignLoadPdf {
	VipsForeignLoad parent_object;

	/* Set by subclasses.
	 */
	VipsSource *source;

	/* Load this page.
	 */
	int page_no;

	/* Load this many pages.
	 */
	int n; 

	/* Render at this DPI.
	 */
	double dpi;

	/* Calculate this from DPI. At 72 DPI, we render 1:1.
	 */
	double scale;

	/* Background colour.
	 */
	VipsArrayDouble *background;

	FPDF_FILEACCESS file_access;
	FPDF_DOCUMENT doc;
	FPDF_PAGE page;
	int current_page;

	/* Doc has this many pages. 
	 */
	int n_pages;

	/* We need to read out the size of each page we will render, and lay
	 * them out in the final image.
	 */
	VipsRect image;
	VipsRect *pages;

	/* The [double] background converted to the image format.
	 */
	VipsPel *ink;

} VipsForeignLoadPdf;

typedef VipsForeignLoadClass VipsForeignLoadPdfClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPdf, vips_foreign_load_pdf, 
	VIPS_TYPE_FOREIGN_LOAD );

static char *vips_pdfium_errors[] = {
	"no error",
	"unknown error",
	"file not found or could not be opened",
	"file not in PDF format or corrupted",
	"password required or incorrect password",
	"unsupported security scheme",
	"page not found or content error"
};

static GMutex *vips_pdfium_mutex = NULL;

static void
vips_pdfium_error( void )
{
	int err = FPDF_GetLastError();

	if( err &gt;= 0 &amp;&amp; 
		err &lt; VIPS_NUMBER( vips_pdfium_errors ) )
		vips_error( "pdfload", "%s", _( vips_pdfium_errors[err] ) );
	else
		vips_error( "pdfload", "%s", _( "unknown error" ) ); 
}

static void
vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
{
	g_mutex_lock( vips_pdfium_mutex );

	VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
	VIPS_FREEF( FPDF_CloseDocument, pdf-&gt;doc ); 
	VIPS_UNREF( pdf-&gt;source );

	g_mutex_unlock( vips_pdfium_mutex );
}

static void
vips_foreign_load_pdf_dispose( GObject *gobject )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) gobject;

	vips_foreign_load_pdf_close( pdf ); 

	G_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
		dispose( gobject );
}

static void *
vips_pdfium_init_cb( void *dummy )
{
	FPDF_LIBRARY_CONFIG config;

	config.version = 2;
	config.m_pUserFontPaths = NULL;
	config.m_pIsolate = NULL;
	config.m_v8EmbedderSlot = 0;

	FPDF_InitLibraryWithConfig( &amp;config );

	return( NULL );
}

/* This is the m_GetBlock function for FPDF_FILEACCESS.
 */
static gboolean
vips_pdfium_GetBlock( void *param, 
	unsigned long position, unsigned char *pBuf, unsigned long size )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) param;

	/* PDFium guarantees these.
	 */
	g_assert( size &gt; 0 );
	g_assert( position &gt;= 0 );
	g_assert( position + size &lt;= pdf-&gt;file_access.m_FileLen );

	if( vips_source_seek( pdf-&gt;source, position, SEEK_SET ) &lt; 0 )
		return( FALSE );

	while( size &gt; 0 ) {
		size_t n_read;

		if( (n_read = vips_source_read( pdf-&gt;source, pBuf, size )) &lt; 0 )
			return( FALSE );
		pBuf += n_read;
		size -= n_read;
	}

	return( TRUE );
}

static int
vips_foreign_load_pdf_build( VipsObject *object )
{
	static GOnce once = G_ONCE_INIT;

	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );

	gint64 length;

	VIPS_ONCE( &amp;once, vips_pdfium_init_cb, NULL );

	if( !vips_object_argument_isset( object, "scale" ) )
		pdf-&gt;scale = pdf-&gt;dpi / 72.0;

	/* pdfium must know the file length, unfortunately.
	 */
	if( pdf-&gt;source ) { 
		if( (length = vips_source_length( pdf-&gt;source )) &lt;= 0 )
			return( -1 );
		if( length &gt; 1 &lt;&lt; 30 ) {
			vips_error( class-&gt;nickname, 
				_( "%s: too large for pdfium" ),
				vips_connection_nick( 
					VIPS_CONNECTION( pdf-&gt;source ) ) );
			return( -1 );
		}
		pdf-&gt;file_access.m_FileLen = length;
		pdf-&gt;file_access.m_GetBlock = vips_pdfium_GetBlock;
		pdf-&gt;file_access.m_Param = pdf;

		g_mutex_lock( vips_pdfium_mutex );

		if( !(pdf-&gt;doc = FPDF_LoadCustomDocument( &amp;pdf-&gt;file_access, 
			NULL )) ) {
			g_mutex_unlock( vips_pdfium_mutex );
			vips_pdfium_error();
			vips_error( "pdfload", 
				_( "%s: unable to load" ), 
				vips_connection_nick( 
					VIPS_CONNECTION( pdf-&gt;source ) ) );
			return( -1 ); 
		}

		g_mutex_unlock( vips_pdfium_mutex );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_pdf_get_flags_filename( const char *filename )
{
	/* We can't render any part of the page on demand, but we can render
	 * separate pages. Might as well call ourselves partial.
	 */
	return( VIPS_FOREIGN_PARTIAL );
}

static VipsForeignFlags
vips_foreign_load_pdf_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_PARTIAL );
}

static int
vips_foreign_load_pdf_get_page( VipsForeignLoadPdf *pdf, int page_no )
{
	if( pdf-&gt;current_page != page_no ) { 
		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );

		g_mutex_lock( vips_pdfium_mutex );

		VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
		pdf-&gt;current_page = -1;

#ifdef DEBUG
		printf( "vips_foreign_load_pdf_get_page: %d\n", page_no );
#endif /*DEBUG*/

		if( !(pdf-&gt;page = FPDF_LoadPage( pdf-&gt;doc, page_no )) ) {
			g_mutex_unlock( vips_pdfium_mutex );
			vips_pdfium_error();
			vips_error( class-&gt;nickname, 
				_( "unable to load page %d" ), page_no );
			return( -1 ); 
		}
		pdf-&gt;current_page = page_no;

		g_mutex_unlock( vips_pdfium_mutex );
	}

	return( 0 );
}

/* String-based metadata fields we extract.
 */
typedef struct _VipsForeignLoadPdfMetadata {
	char *tag;		/* as understood by PDFium */
	char *field;		/* as understood by libvips */
} VipsForeignLoadPdfMetadata;

static VipsForeignLoadPdfMetadata vips_foreign_load_pdf_metadata[] = {
	{ "Title", "pdf-title" },
	{ "Author", "pdf-author" },
	{ "Subject", "pdf-subject" },
	{ "Keywords", "pdf-keywords" },
	{ "Creator", "pdf-creator" },
	{ "Producer", "pdf-producer" },
	/* poppler has "metadata" as well, but pdfium does not support this */
};
static int n_metadata = VIPS_NUMBER( vips_foreign_load_pdf_metadata );

static int
vips_foreign_load_pdf_set_image( VipsForeignLoadPdf *pdf, VipsImage *out )
{
	int i;
	double res;

#ifdef DEBUG
	printf( "vips_foreign_load_pdf_set_image: %p\n", pdf );
#endif /*DEBUG*/

	/* We render to a linecache, so fat strips work well.
	 */
        if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_FATSTRIP, NULL ) )
		return( -1 );

	/* Extract and attach metadata. Set the old name too for compat.
	 */
	vips_image_set_int( out, "pdf-n_pages", pdf-&gt;n_pages ); 
	vips_image_set_int( out, VIPS_META_N_PAGES, pdf-&gt;n_pages ); 

	g_mutex_lock( vips_pdfium_mutex );

	for( i = 0; i &lt; n_metadata; i++ ) {
		VipsForeignLoadPdfMetadata *metadata = 
			&amp;vips_foreign_load_pdf_metadata[i];

		char text[1024];
		int len;

		len = FPDF_GetMetaText( pdf-&gt;doc, metadata-&gt;tag, text, 1024 );
		if( len &gt; 0 ) { 
			char *str;

			/* Silently ignore coding errors.
			 */
			if( (str = g_utf16_to_utf8( (gunichar2 *) text, len, 
				NULL, NULL, NULL )) ) {
				vips_image_set_string( out, 
					metadata-&gt;field, str ); 
				g_free( str );
			}
		}
	}

	g_mutex_unlock( vips_pdfium_mutex );

	/* We need pixels/mm for vips.
	 */
	res = pdf-&gt;dpi / 25.4;

	vips_image_init_fields( out, 
		pdf-&gt;image.width, pdf-&gt;image.height, 
		4, VIPS_FORMAT_UCHAR,
		VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, res, res );

	return( 0 );
}

static int
vips_foreign_load_pdf_header( VipsForeignLoad *load )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;

	int top;
	int i;

#ifdef DEBUG
	printf( "vips_foreign_load_pdf_header: %p\n", pdf );
#endif /*DEBUG*/

	g_mutex_lock( vips_pdfium_mutex );
	pdf-&gt;n_pages = FPDF_GetPageCount( pdf-&gt;doc );
	g_mutex_unlock( vips_pdfium_mutex );

	/* @n == -1 means until the end of the doc.
	 */
	if( pdf-&gt;n == -1 )
		pdf-&gt;n = pdf-&gt;n_pages - pdf-&gt;page_no;

	if( pdf-&gt;page_no + pdf-&gt;n &gt; pdf-&gt;n_pages ||
		pdf-&gt;page_no &lt; 0 ||
		pdf-&gt;n &lt;= 0 ) {
		vips_error( class-&gt;nickname, "%s", _( "pages out of range" ) );
		return( -1 ); 
	}

	/* Lay out the pages in our output image.
	 */
	if( !(pdf-&gt;pages = VIPS_ARRAY( pdf, pdf-&gt;n, VipsRect )) )
		return( -1 ); 

	top = 0;
	pdf-&gt;image.left = 0;
	pdf-&gt;image.top = 0;
	pdf-&gt;image.width = 0;
	pdf-&gt;image.height = 0;
	for( i = 0; i &lt; pdf-&gt;n; i++ ) {
		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
			return( -1 );
		pdf-&gt;pages[i].left = 0;
		pdf-&gt;pages[i].top = top;
		/* We do round to nearest, in the same way that vips_resize()
		 * does round to nearest. Without this, things like
		 * shrink-on-load will break.
		 */
		pdf-&gt;pages[i].width = VIPS_RINT( 
			FPDF_GetPageWidth( pdf-&gt;page ) * pdf-&gt;scale );
		pdf-&gt;pages[i].height = VIPS_RINT( 
			FPDF_GetPageHeight( pdf-&gt;page ) * pdf-&gt;scale );

		if( pdf-&gt;pages[i].width &gt; pdf-&gt;image.width )
			pdf-&gt;image.width = pdf-&gt;pages[i].width;
		pdf-&gt;image.height += pdf-&gt;pages[i].height;

		top += pdf-&gt;pages[i].height;
	}

	/* If all pages are the same height, we can tag this as a toilet roll
	 * image.
	 */
	for( i = 1; i &lt; pdf-&gt;n; i++ ) 
		if( pdf-&gt;pages[i].height != pdf-&gt;pages[0].height )
			break;
	if( vips_object_argument_isset( VIPS_OBJECT( pdf ), "n" ) )
		vips_image_set_int( load-&gt;out, 
			VIPS_META_PAGE_HEIGHT, pdf-&gt;pages[0].height );

	vips_foreign_load_pdf_set_image( pdf, load-&gt;out ); 

	/* Convert the background to the image format.
	 */
	if( !(pdf-&gt;ink = vips__vector_to_ink( class-&gt;nickname, 
		load-&gt;out, 
		VIPS_AREA( pdf-&gt;background )-&gt;data, NULL, 
		VIPS_AREA( pdf-&gt;background )-&gt;n )) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
{
	vips_source_minimise( pdf-&gt;source );
}

static int
vips_foreign_load_pdf_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
	VipsRect *r = &amp;or-&gt;valid;

	int top;
	int i;
	int y;

	/*
	printf( "vips_foreign_load_pdf_generate: "
		"left = %d, top = %d, width = %d, height = %d\n", 
		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height ); 
	 */

	/* PDFium won't always paint the background. 
	 */
	vips_region_paint_pel( or, r, pdf-&gt;ink ); 

	/* Search through the pages we are drawing for the first containing
	 * this rect. This could be quicker, perhaps a binary search, but who 
	 * cares.
	 */
	for( i = 0; i &lt; pdf-&gt;n; i++ )
		if( VIPS_RECT_BOTTOM( &amp;pdf-&gt;pages[i] ) &gt; r-&gt;top )
			break;

	top = r-&gt;top; 
	while( top &lt; VIPS_RECT_BOTTOM( r ) ) {
		VipsRect rect;
		FPDF_BITMAP bitmap;

		vips_rect_intersectrect( r, &amp;pdf-&gt;pages[i], &amp;rect );

		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
			return( -1 ); 

		/* 4 means RGBA.
		 */
		g_mutex_lock( vips_pdfium_mutex );

		bitmap = FPDFBitmap_CreateEx( rect.width, rect.height, 4, 
			VIPS_REGION_ADDR( or, rect.left, rect.top ), 
			VIPS_REGION_LSKIP( or ) );  

		FPDF_RenderPageBitmap( bitmap, pdf-&gt;page, 
			0, 0, rect.width, rect.height,
			0, 0 ); 

		FPDFBitmap_Destroy( bitmap ); 

		g_mutex_unlock( vips_pdfium_mutex );

		top += rect.height;
		i += 1;
	}

	/* PDFium writes BGRA, we must swap.
	 */
	for( y = 0; y &lt; r-&gt;height; y++ )
		vips__bgra2rgba( 
			(guint32 *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ),
			r-&gt;width );

	return( 0 ); 
}

static int
vips_foreign_load_pdf_load( VipsForeignLoad *load )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( (VipsObject *) load, 2 );

#ifdef DEBUG
	printf( "vips_foreign_load_pdf_load: %p\n", pdf );
#endif /*DEBUG*/

	/* Read to this image, then cache to out, see below.
	 */
	t[0] = vips_image_new(); 

	/* Close input immediately at end of read.
	 */
	g_signal_connect( t[0], "minimise", 
		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 

	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
	if( vips_image_generate( t[0], 
		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
		return( -1 );

	/* PDFium does not like rendering parts of pages :-( always render
	 * complete ones. 
	 */
	if( vips_linecache( t[0], &amp;t[1],
		"tile_height", pdf-&gt;pages[0].height, 
		NULL ) ) 
		return( -1 );
	if( vips_image_write( t[1], load-&gt;real ) ) 
		return( -1 );

	return( 0 );
}

static void *
vips_foreign_load_pdf_once_init( void *client )
{
	/* We must make the mutex on class init (not _build) since we
	 * can lock ebven if build is not called.
	 */
	vips_pdfium_mutex = vips_g_mutex_new();

	return( NULL );
}

static void
vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
{
	static GOnce once = G_ONCE_INIT;

	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	VIPS_ONCE( &amp;once, vips_foreign_load_pdf_once_init, NULL );

	gobject_class-&gt;dispose = vips_foreign_load_pdf_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "pdfload_base";
	object_class-&gt;description = _( "load PDF with PDFium" );
	object_class-&gt;build = vips_foreign_load_pdf_build;

	load_class-&gt;get_flags_filename = 
		vips_foreign_load_pdf_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_pdf_get_flags;
	load_class-&gt;header = vips_foreign_load_pdf_header;
	load_class-&gt;load = vips_foreign_load_pdf_load;

	VIPS_ARG_INT( class, "page", 10,
		_( "Page" ),
		_( "Load this page from the file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, page_no ),
		0, 100000, 0 );

	VIPS_ARG_INT( class, "n", 11,
		_( "n" ),
		_( "Load this many pages" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, n ),
		-1, 100000, 1 );

	VIPS_ARG_DOUBLE( class, "dpi", 12,
		_( "DPI" ),
		_( "Render at this DPI" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, dpi ),
		0.001, 100000.0, 72.0 );

	VIPS_ARG_DOUBLE( class, "scale", 13,
		_( "Scale" ),
		_( "Scale output by this factor" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, scale ),
		0.001, 100000.0, 1.0 );

	VIPS_ARG_BOXED( class, "background", 14, 
		_( "Background" ), 
		_( "Background value" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadPdf, background ),
		VIPS_TYPE_ARRAY_DOUBLE );

}

static void
vips_foreign_load_pdf_init( VipsForeignLoadPdf *pdf )
{
	pdf-&gt;dpi = 72.0;
	pdf-&gt;scale = 1.0;
	pdf-&gt;n = 1;
	pdf-&gt;current_page = -1;
	pdf-&gt;background = vips_array_double_newv( 1, 255.0 );
}

typedef struct _VipsForeignLoadPdfFile {
	VipsForeignLoadPdf parent_object;

	/* Filename for load.
	 */
	char *filename; 

} VipsForeignLoadPdfFile;

typedef VipsForeignLoadPdfClass VipsForeignLoadPdfFileClass;

G_DEFINE_TYPE( VipsForeignLoadPdfFile, vips_foreign_load_pdf_file, 
	vips_foreign_load_pdf_get_type() );

static int
vips_foreign_load_pdf_file_header( VipsForeignLoad *load )
{
	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) load;

	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );

	return( VIPS_FOREIGN_LOAD_CLASS(
		vips_foreign_load_pdf_file_parent_class )-&gt;header( load ) );
}

static const char *vips_foreign_pdf_suffs[] = {
	".pdf",
	NULL
};

static int
vips_foreign_load_pdf_file_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) pdf;

#ifdef DEBUG
	printf( "vips_foreign_load_pdf_file_build: %s\n", file-&gt;filename );
#endif /*DEBUG*/

	if( file-&gt;filename &amp;&amp;
		!(pdf-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_file_parent_class )-&gt;
		build( object ) );
}

static gboolean
vips_foreign_load_pdf_is_a_buffer( const void *buf, size_t len )
{
	const guchar *str = (const guchar *) buf;

	if( len &gt;= 4 &amp;&amp;
		str[0] == '%' &amp;&amp; 
		str[1] == 'P' &amp;&amp;
		str[2] == 'D' &amp;&amp;
		str[3] == 'F' )
		return( 1 );

	return( 0 );
}

static gboolean
vips_foreign_load_pdf_is_a( const char *filename )
{
	unsigned char buf[4];

	if( vips__get_bytes( filename, buf, 4 ) == 4 &amp;&amp;
		vips_foreign_load_pdf_is_a_buffer( buf, 4 ) )
		return( 1 );

	return( 0 );
}

static void
vips_foreign_load_pdf_file_class_init( 
	VipsForeignLoadPdfFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "pdfload";
	object_class-&gt;description = _( "load PDF from file" );
	object_class-&gt;build = vips_foreign_load_pdf_file_build;

	foreign_class-&gt;suffs = vips_foreign_pdf_suffs;

	load_class-&gt;is_a = vips_foreign_load_pdf_is_a;
	load_class-&gt;header = vips_foreign_load_pdf_file_header;

	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfFile, filename ),
		NULL );

}

static void
vips_foreign_load_pdf_file_init( VipsForeignLoadPdfFile *file )
{
}

typedef struct _VipsForeignLoadPdfBuffer {
	VipsForeignLoadPdf parent_object;

	/* Load from a buffer.
	 */
	VipsArea *buf;

} VipsForeignLoadPdfBuffer;

typedef VipsForeignLoadPdfClass VipsForeignLoadPdfBufferClass;

G_DEFINE_TYPE( VipsForeignLoadPdfBuffer, vips_foreign_load_pdf_buffer, 
	vips_foreign_load_pdf_get_type() );

static int
vips_foreign_load_pdf_buffer_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfBuffer *buffer = (VipsForeignLoadPdfBuffer *) pdf;

	if( buffer-&gt;buf &amp;&amp;
<a name="0"></a>		!(pdf-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );

	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_buffer_parent_class )-&gt;
		build( object ) );
}

static void
vips_foreign_load_pdf_buffer_class_init( 
	VipsForeignLoadPdfBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "pdfload_buffer";
	object_class-&gt;description = _( "load PDF from buffer" );
	object_class-&gt;build = vips_foreign_load_pdf_buffer_build;

	load_class-&gt;is_a_buffer = vips_foreign_load_pdf_is_a_buffer;

	VIPS_ARG_BOXED( class, "buffer", 1, </b></font>
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfBuffer, buf ),
		VIPS_TYPE_BLOB );

}

static void
vips_foreign_load_pdf_buffer_init( VipsForeignLoadPdfBuffer *buffer )
{
}

typedef struct _VipsForeignLoadPdfSource {
	VipsForeignLoadPdf parent_object;

	VipsSource *source;

} VipsForeignLoadPdfSource;

typedef VipsForeignLoadPdfClass VipsForeignLoadPdfSourceClass;

G_DEFINE_TYPE( VipsForeignLoadPdfSource, vips_foreign_load_pdf_source, 
	vips_foreign_load_pdf_get_type() );

static int
vips_foreign_load_pdf_source_build( VipsObject *object )
{
	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
	VipsForeignLoadPdfSource *source = (VipsForeignLoadPdfSource *) pdf;

	if( source-&gt;source ) {
		pdf-&gt;source = source-&gt;source;
		g_object_ref( pdf-&gt;source );
	}

	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_source_parent_class )-&gt;
		build( object ) );
}

static gboolean
vips_foreign_load_pdf_source_is_a_source( VipsSource *source )
{
	const unsigned char *p;

	return( (p = vips_source_sniff( source, 4 )) &amp;&amp;
		p[0] == '%' &amp;&amp; 
		p[1] == 'P' &amp;&amp;
		p[2] == 'D' &amp;&amp;
		p[3] == 'F' );
}

static void
vips_foreign_load_pdf_source_class_init( 
	VipsForeignLoadPdfSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "pdfload_source";
	object_class-&gt;description = _( "load PDF from source" );
	object_class-&gt;build = vips_foreign_load_pdf_source_build;

	load_class-&gt;is_a_source = vips_foreign_load_pdf_source_is_a_source;

	VIPS_ARG_OBJECT( class, "source", 1,
		_( "Source" ),
		_( "Source to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadPdfSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_pdf_source_init( VipsForeignLoadPdfSource *source )
{
}

#endif /*HAVE_PDFIUM*/
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
