
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hyperloglog.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &lt;stdint.h&gt;
3  #include &lt;math.h&gt;
4  struct hllhdr {
5      char magic[4];      &amp;bsol;* &quot;HYLL&quot; */
6      uint8_t encoding;   &amp;bsol;* HLL_DENSE or HLL_SPARSE. */
7      uint8_t notused[3]; &amp;bsol;* Reserved for future use, must be zero. */
8      uint8_t card[8];    &amp;bsol;* Cached cardinality, little endian. */
9      uint8_t registers[]; &amp;bsol;* Data bytes. */
10  };
11  #define HLL_INVALIDATE_CACHE(hdr) (hdr)-&gt;card[7] |= (1&lt;&lt;7)
12  #define HLL_VALID_CACHE(hdr) (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)
13  #define HLL_P 14 &amp;bsol;* The greater is P, the smaller the error. */
14  #define HLL_Q (64-HLL_P) &amp;bsol;* The number of bits of the hash value used for
15                              determining the number of leading zeros. */
16  #define HLL_REGISTERS (1&lt;&lt;HLL_P) &amp;bsol;* With P=14, 16384 registers. */
17  #define HLL_P_MASK (HLL_REGISTERS-1) &amp;bsol;* Mask to index register. */
18  #define HLL_BITS 6 &amp;bsol;* Enough to count up to 63 leading zeroes. */
19  #define HLL_REGISTER_MAX ((1&lt;&lt;HLL_BITS)-1)
20  #define HLL_HDR_SIZE sizeof(struct hllhdr)
21  #define HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))
22  #define HLL_DENSE 0 &amp;bsol;* Dense encoding. */
23  #define HLL_SPARSE 1 &amp;bsol;* Sparse encoding. */
24  #define HLL_RAW 255 &amp;bsol;* Only used internally, never exposed. */
25  #define HLL_MAX_ENCODING 1
26  static char *invalid_hll_err = &quot;-INVALIDOBJ Corrupted HLL object detected\r\n&quot;;
27  #define HLL_DENSE_GET_REGISTER(target,p,regnum) do { \
28      uint8_t *_p = (uint8_t*) p; \
29      PORT_ULONG _byte = regnum*HLL_BITS/8; \
30      PORT_ULONG _fb = regnum*HLL_BITS&amp;7; \
31      PORT_ULONG _fb8 = 8 - _fb; \
32      PORT_ULONG b0 = _p[_byte]; \
33      PORT_ULONG b1 = _p[_byte+1]; \
34      target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \
35  } while(0)
36  #define HLL_DENSE_SET_REGISTER(p,regnum,val) do { \
37      uint8_t *_p = (uint8_t*) p; \
38      PORT_ULONG _byte = regnum*HLL_BITS/8; \
39      PORT_ULONG _fb = regnum*HLL_BITS&amp;7; \
40      PORT_ULONG _fb8 = 8 - _fb; \
41      PORT_ULONG _v = val; \
42      _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \
43      _p[_byte] |= _v &lt;&lt; _fb; \
44      _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); \
45      _p[_byte+1] |= _v &gt;&gt; _fb8; \
46  } while(0)
47  #define HLL_SPARSE_XZERO_BIT 0x40 &amp;bsol;* 01xxxxxx */
48  #define HLL_SPARSE_VAL_BIT 0x80 &amp;bsol;* 1vvvvvxx */
49  #define HLL_SPARSE_IS_ZERO(p) (((*(p)) &amp; 0xc0) == 0) &amp;bsol;* 00xxxxxx */
50  #define HLL_SPARSE_IS_XZERO(p) (((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)
51  #define HLL_SPARSE_IS_VAL(p) ((*(p)) &amp; HLL_SPARSE_VAL_BIT)
52  #define HLL_SPARSE_ZERO_LEN(p) (((*(p)) &amp; 0x3f)+1)
53  #define HLL_SPARSE_XZERO_LEN(p) (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)
54  #define HLL_SPARSE_VAL_VALUE(p) ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)
55  #define HLL_SPARSE_VAL_LEN(p) (((*(p)) &amp; 0x3)+1)
56  #define HLL_SPARSE_VAL_MAX_VALUE 32
57  #define HLL_SPARSE_VAL_MAX_LEN 4
58  #define HLL_SPARSE_ZERO_MAX_LEN 64
59  #define HLL_SPARSE_XZERO_MAX_LEN 16384
60  #define HLL_SPARSE_VAL_SET(p,val,len) do { \
61      *(p) = (((val)-1)&lt;&lt;2|((len)-1))|HLL_SPARSE_VAL_BIT; \
62  } while(0)
63  #define HLL_SPARSE_ZERO_SET(p,len) do { \
64      *(p) = (len)-1; \
65  } while(0)
66  #define HLL_SPARSE_XZERO_SET(p,len) do { \
67      int _l = (len)-1; \
68      *(p) = (_l&gt;&gt;8) | HLL_SPARSE_XZERO_BIT; \
69      *((p)+1) = (_l&amp;0xff); \
70  } while(0)
71  #define HLL_ALPHA_INF 0.721347520444481703680 &amp;bsol;* constant for 0.5/ln(2) */
72  uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
73      const uint64_t m = 0xc6a4a7935bd1e995;
74      const int r = 47;
75      uint64_t h = seed ^ (len * m);
76      const uint8_t *data = (const uint8_t *)key;
77      const uint8_t *end = data + (len-(len&amp;7));
78      while(data != end) {
79          uint64_t k;
80  #if (BYTE_ORDER == LITTLE_ENDIAN)
81      #ifdef USE_ALIGNED_ACCESS
82          memcpy(&amp;k,data,sizeof(uint64_t));
83      #else
84          k = *((uint64_t*)data);
85      #endif
86  #else
87          k = (uint64_t) data[0];
88          k |= (uint64_t) data[1] &lt;&lt; 8;
89          k |= (uint64_t) data[2] &lt;&lt; 16;
90          k |= (uint64_t) data[3] &lt;&lt; 24;
91          k |= (uint64_t) data[4] &lt;&lt; 32;
92          k |= (uint64_t) data[5] &lt;&lt; 40;
93          k |= (uint64_t) data[6] &lt;&lt; 48;
94          k |= (uint64_t) data[7] &lt;&lt; 56;
95  #endif
96          k *= m;
97          k ^= k &gt;&gt; r;
98          k *= m;
99          h ^= k;
100          h *= m;
101          data += 8;
102      }
103      switch(len &amp; 7) {
104      case 7: h ^= (uint64_t)data[6] &lt;&lt; 48; &amp;bsol;* fall-thru */
105      case 6: h ^= (uint64_t)data[5] &lt;&lt; 40; &amp;bsol;* fall-thru */
106      case 5: h ^= (uint64_t)data[4] &lt;&lt; 32; &amp;bsol;* fall-thru */
107      case 4: h ^= (uint64_t)data[3] &lt;&lt; 24; &amp;bsol;* fall-thru */
108      case 3: h ^= (uint64_t)data[2] &lt;&lt; 16; &amp;bsol;* fall-thru */
109      case 2: h ^= (uint64_t)data[1] &lt;&lt; 8; &amp;bsol;* fall-thru */
110      case 1: h ^= (uint64_t)data[0];
111              h *= m; &amp;bsol;* fall-thru */
112      };
113      h ^= h &gt;&gt; r;
114      h *= m;
115      h ^= h &gt;&gt; r;
116      return h;
117  }
118  int hllPatLen(unsigned char *ele, size_t elesize, PORT_LONG *regp) {
119      uint64_t hash, bit, index;
120      int count;
121      hash = MurmurHash64A(ele,(int)elesize,0xadc83b19ULL);                       WIN_PORT_FIX &amp;bsol;* cast (int) */
122      index = hash &amp; HLL_P_MASK; &amp;bsol;* Register index. */
123      hash &gt;&gt;= HLL_P; &amp;bsol;* Remove bits used to address the register. */
124      hash |= ((uint64_t)1&lt;&lt;HLL_Q); &amp;bsol;* Make sure the loop terminates
125                                       and count will be &lt;= Q+1. */
126      bit = 1;
127      count = 1; &amp;bsol;* Initialized to 1 since we count the &quot;00000...1&quot; pattern. */
128      while((hash &amp; bit) == 0) {
129          count++;
130          bit &lt;&lt;= 1;
131      }
132      *regp = (int) index;
133      return count;
134  }
135  int hllDenseSet(uint8_t *registers, PORT_LONG index, uint8_t count) {
136      uint8_t oldcount;
137      HLL_DENSE_GET_REGISTER(oldcount,registers,index);
138      if (count &gt; oldcount) {
139          HLL_DENSE_SET_REGISTER(registers,index,count);
140          return 1;
141      } else {
142          return 0;
143      }
144  }
145  int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
146      PORT_LONG index;
147      uint8_t count = hllPatLen(ele,elesize,&amp;index);
148      return hllDenseSet(registers,index,count);
149  }
150  void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
151      int j;
152      if (HLL_REGISTERS == 16384 &amp;&amp; HLL_BITS == 6) {
153          uint8_t *r = registers;
154          PORT_ULONG r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
155                        r10, r11, r12, r13, r14, r15;
156          for (j = 0; j &lt; 1024; j++) {
157              r0 = r[0] &amp; 63;
158              r1 = (r[0] &gt;&gt; 6 | r[1] &lt;&lt; 2) &amp; 63;
159              r2 = (r[1] &gt;&gt; 4 | r[2] &lt;&lt; 4) &amp; 63;
160              r3 = (r[2] &gt;&gt; 2) &amp; 63;
161              r4 = r[3] &amp; 63;
162              r5 = (r[3] &gt;&gt; 6 | r[4] &lt;&lt; 2) &amp; 63;
163              r6 = (r[4] &gt;&gt; 4 | r[5] &lt;&lt; 4) &amp; 63;
164              r7 = (r[5] &gt;&gt; 2) &amp; 63;
165              r8 = r[6] &amp; 63;
166              r9 = (r[6] &gt;&gt; 6 | r[7] &lt;&lt; 2) &amp; 63;
167              r10 = (r[7] &gt;&gt; 4 | r[8] &lt;&lt; 4) &amp; 63;
168              r11 = (r[8] &gt;&gt; 2) &amp; 63;
169              r12 = r[9] &amp; 63;
170              r13 = (r[9] &gt;&gt; 6 | r[10] &lt;&lt; 2) &amp; 63;
171              r14 = (r[10] &gt;&gt; 4 | r[11] &lt;&lt; 4) &amp; 63;
172              r15 = (r[11] &gt;&gt; 2) &amp; 63;
173              reghisto[r0]++;
174              reghisto[r1]++;
175              reghisto[r2]++;
176              reghisto[r3]++;
177              reghisto[r4]++;
178              reghisto[r5]++;
179              reghisto[r6]++;
180              reghisto[r7]++;
181              reghisto[r8]++;
182              reghisto[r9]++;
183              reghisto[r10]++;
184              reghisto[r11]++;
185              reghisto[r12]++;
186              reghisto[r13]++;
187              reghisto[r14]++;
188              reghisto[r15]++;
189              r += 12;
190          }
191      } else {
192          for(j = 0; j &lt; HLL_REGISTERS; j++) {
193              PORT_ULONG reg;
194              HLL_DENSE_GET_REGISTER(reg,registers,j);
195              reghisto[reg]++;
196          }
197      }
198  }
199  int hllSparseToDense(robj *o) {
200      sds sparse = o-&gt;ptr, dense;
201      struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
202      int idx = 0, runlen, regval;
203      uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);
204      hdr = (struct hllhdr*) sparse;
205      if (hdr-&gt;encoding == HLL_DENSE) return C_OK;
206      dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
207      hdr = (struct hllhdr*) dense;
208      *hdr = *oldhdr; &amp;bsol;* This will copy the magic and cached cardinality. */
209      hdr-&gt;encoding = HLL_DENSE;
210      p += HLL_HDR_SIZE;
211      while(p &lt; end) {
212          if (HLL_SPARSE_IS_ZERO(p)) {
213              runlen = HLL_SPARSE_ZERO_LEN(p);
214              idx += runlen;
215              p++;
216          } else if (HLL_SPARSE_IS_XZERO(p)) {
217              runlen = HLL_SPARSE_XZERO_LEN(p);
218              idx += runlen;
219              p += 2;
220          } else {
221              runlen = HLL_SPARSE_VAL_LEN(p);
222              regval = HLL_SPARSE_VAL_VALUE(p);
223              if ((runlen + idx) &gt; HLL_REGISTERS) break; &amp;bsol;* Overflow. */
224              while(runlen--) {
225                  HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval);
226                  idx++;
227              }
228              p++;
229          }
230      }
231      if (idx != HLL_REGISTERS) {
232          sdsfree(dense);
233          return C_ERR;
234      }
235      sdsfree(o-&gt;ptr);
236      o-&gt;ptr = dense;
237      return C_OK;
238  }
239  int hllSparseSet(robj *o, PORT_LONG index, uint8_t count) {
240      struct hllhdr *hdr;
241      uint8_t oldcount, *sparse, *end, *p, *prev, *next;
242      PORT_LONG first, span;
243      PORT_LONG is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;
244      if (count &gt; HLL_SPARSE_VAL_MAX_VALUE) goto promote;
245      o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,3);
246      sparse = p = ((uint8_t*)o-&gt;ptr) + HLL_HDR_SIZE;
247      end = p + sdslen(o-&gt;ptr) - HLL_HDR_SIZE;
248      first = 0;
249      prev = NULL; &amp;bsol;* Points to previous opcode at the end of the loop. */
250      next = NULL; &amp;bsol;* Points to the next opcode at the end of the loop. */
251      span = 0;
252      while(p &lt; end) {
253          PORT_LONG oplen;
254          oplen = 1;
255          if (HLL_SPARSE_IS_ZERO(p)) {
256              span = HLL_SPARSE_ZERO_LEN(p);
257          } else if (HLL_SPARSE_IS_VAL(p)) {
258              span = HLL_SPARSE_VAL_LEN(p);
259          } else { &amp;bsol;* XZERO. */
260              span = HLL_SPARSE_XZERO_LEN(p);
261              oplen = 2;
262          }
263          if (index &lt;= first+span-1) break;
264          prev = p;
265          p += oplen;
266          first += span;
267      }
268      if (span == 0 || p &gt;= end) return -1; &amp;bsol;* Invalid format. */
269      next = HLL_SPARSE_IS_XZERO(p) ? p+2 : p+1;
270      if (next &gt;= end) next = NULL;
271      if (HLL_SPARSE_IS_ZERO(p)) {
272          is_zero = 1;
273          runlen = HLL_SPARSE_ZERO_LEN(p);
274      } else if (HLL_SPARSE_IS_XZERO(p)) {
275          is_xzero = 1;
276          runlen = HLL_SPARSE_XZERO_LEN(p);
277      } else {
278          is_val = 1;
279          runlen = HLL_SPARSE_VAL_LEN(p);
280      }
281      if (is_val) {
282          oldcount = HLL_SPARSE_VAL_VALUE(p);
283          if (oldcount &gt;= count) return 0;
284          if (runlen == 1) {
285              HLL_SPARSE_VAL_SET(p,count,1);
286              goto updated;
287          }
288      }
289      if (is_zero &amp;&amp; runlen == 1) {
290          HLL_SPARSE_VAL_SET(p,count,1);
291          goto updated;
292      }
293      uint8_t seq[5], *n = seq;
294      int last = (int)(first+span-1); &amp;bsol;* Last register covered by the sequence. */  WIN_PORT_FIX &amp;bsol;* cast (int) */
295      int len;
296      if (is_zero || is_xzero) {
297          if (index != first) {
298              len = (int)(index-first);                                           WIN_PORT_FIX &amp;bsol;* cast (int) */
299              if (len &gt; HLL_SPARSE_ZERO_MAX_LEN) {
300                  HLL_SPARSE_XZERO_SET(n,len);
301                  n += 2;
302              } else {
303                  HLL_SPARSE_ZERO_SET(n,len);
304                  n++;
305              }
306          }
307          HLL_SPARSE_VAL_SET(n,count,1);
308          n++;
309          if (index != last) {
310              len = (int)(last-index);                                            WIN_PORT_FIX &amp;bsol;* cast (int) */
311              if (len &gt; HLL_SPARSE_ZERO_MAX_LEN) {
312                  HLL_SPARSE_XZERO_SET(n,len);
313                  n += 2;
314              } else {
315                  HLL_SPARSE_ZERO_SET(n,len);
316                  n++;
317              }
318          }
319      } else {
320          int curval = HLL_SPARSE_VAL_VALUE(p);
321          if (index != first) {
322              len = (int)(index-first);                                           WIN_PORT_FIX &amp;bsol;* cast (int) */
323              HLL_SPARSE_VAL_SET(n,curval,len);
324              n++;
325          }
326          HLL_SPARSE_VAL_SET(n,count,1);
327          n++;
328          if (index != last) {
329              len = (int)(last-index);                                            WIN_PORT_FIX &amp;bsol;* cast (int) */
330              HLL_SPARSE_VAL_SET(n,curval,len);
331              n++;
332          }
333      }
334       int seqlen = (int)(n-seq);                                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
335       int oldlen = is_xzero ? 2 : 1;
336       int deltalen = seqlen-oldlen;
337       if (deltalen &gt; 0 &amp;&amp;
338           sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) goto promote;
339       if (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);
340       sdsIncrLen(o-&gt;ptr,deltalen);
341       memcpy(p,seq,seqlen);
342       end += deltalen;
343  updated:
344      p = prev ? prev : sparse;
345      int scanlen = 5; &amp;bsol;* Scan up to 5 upcodes starting from prev. */
346      while (p &lt; end &amp;&amp; scanlen--) {
347          if (HLL_SPARSE_IS_XZERO(p)) {
348              p += 2;
349              continue;
350          } else if (HLL_SPARSE_IS_ZERO(p)) {
351              p++;
352              continue;
353          }
354          if (p+1 &lt; end &amp;&amp; HLL_SPARSE_IS_VAL(p+1)) {
355              int v1 = HLL_SPARSE_VAL_VALUE(p);
356              int v2 = HLL_SPARSE_VAL_VALUE(p+1);
357              if (v1 == v2) {
358                  int len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+1);
359                  if (len &lt;= HLL_SPARSE_VAL_MAX_LEN) {
360                      HLL_SPARSE_VAL_SET(p+1,v1,len);
361                      memmove(p,p+1,end-p);
362                      sdsIncrLen(o-&gt;ptr,-1);
363                      end--;
364                      continue;
365                  }
366              }
367          }
368          p++;
369      }
370      hdr = o-&gt;ptr;
371      HLL_INVALIDATE_CACHE(hdr);
372      return 1;
373  promote: &amp;bsol;* Promote to dense representation. */
374      if (hllSparseToDense(o) == C_ERR) return -1; &amp;bsol;* Corrupted HLL. */
375      hdr = o-&gt;ptr;
376      int dense_retval = hllDenseSet(hdr-&gt;registers,index,count);
377      serverAssert(dense_retval == 1);
378      return dense_retval;
379  }
380  int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
381      PORT_LONG index;
382      uint8_t count = hllPatLen(ele,elesize,&amp;index);
383      return hllSparseSet(o,index,count);
384  }
385  void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {
386      int idx = 0, runlen, regval;
387      uint8_t *end = sparse+sparselen, *p = sparse;
388      while(p &lt; end) {
389          if (HLL_SPARSE_IS_ZERO(p)) {
390              runlen = HLL_SPARSE_ZERO_LEN(p);
391              idx += runlen;
392              reghisto[0] += runlen;
393              p++;
394          } else if (HLL_SPARSE_IS_XZERO(p)) {
395              runlen = HLL_SPARSE_XZERO_LEN(p);
396              idx += runlen;
397              reghisto[0] += runlen;
398              p += 2;
399          } else {
400              runlen = HLL_SPARSE_VAL_LEN(p);
401              regval = HLL_SPARSE_VAL_VALUE(p);
402              idx += runlen;
403              reghisto[regval] += runlen;
404              p++;
405          }
406      }
407      if (idx != HLL_REGISTERS &amp;&amp; invalid) *invalid = 1;
408  }
409  void hllRawRegHisto(uint8_t *registers, int* reghisto) {
410      uint64_t *word = (uint64_t*) registers;
411      uint8_t *bytes;
412      int j;
413      for (j = 0; j &lt; HLL_REGISTERS/8; j++) {
414          if (*word == 0) {
415              reghisto[0] += 8;
416          } else {
417              bytes = (uint8_t*) word;
418              reghisto[bytes[0]]++;
419              reghisto[bytes[1]]++;
420              reghisto[bytes[2]]++;
421              reghisto[bytes[3]]++;
422              reghisto[bytes[4]]++;
423              reghisto[bytes[5]]++;
424              reghisto[bytes[6]]++;
425              reghisto[bytes[7]]++;
426          }
427          word++;
428      }
429  }
430  double hllSigma(double x) {
431      if (x == 1.) return INFINITY;
432      double zPrime;
433      double y = 1;
434      double z = x;
435      do {
436          x *= x;
437          zPrime = z;
438          z += x * y;
439          y += y;
440      } while(zPrime != z);
441      return z;
442  }
443  double hllTau(double x) {
444      if (x == 0. || x == 1.) return 0.;
445      double zPrime;
446      double y = 1.0;
447      double z = 1 - x;
448      do {
449          x = sqrt(x);
450          zPrime = z;
451          y *= 0.5;
452          z -= pow(1 - x, 2)*y;
453      } while(zPrime != z);
454      return z / 3;
455  }
456  uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
457      double m = HLL_REGISTERS;
458      double E;
459      int j;
460      int reghisto[64] = {0};
461      if (hdr-&gt;encoding == HLL_DENSE) {
462          hllDenseRegHisto(hdr-&gt;registers,reghisto);
463      } else if (hdr-&gt;encoding == HLL_SPARSE) {
464          hllSparseRegHisto(hdr-&gt;registers,
465                           sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);
466      } else if (hdr-&gt;encoding == HLL_RAW) {
467          hllRawRegHisto(hdr-&gt;registers,reghisto);
468      } else {
469          serverPanic(&quot;Unknown HyperLogLog encoding in hllCount()&quot;);
470      }
471      double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);
472      for (j = HLL_Q; j &gt;= 1; --j) {
473          z += reghisto[j];
474          z *= 0.5;
475      }
476      z += m * hllSigma(reghisto[0]/(double)m);
477      E = llroundl(HLL_ALPHA_INF*m*m/z);
478      return (uint64_t) E;
479  }
480  int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
481      struct hllhdr *hdr = o-&gt;ptr;
482      switch(hdr-&gt;encoding) {
483      case HLL_DENSE: return hllDenseAdd(hdr-&gt;registers,ele,elesize);
484      case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
485      default: return -1; &amp;bsol;* Invalid representation. */
486      }
487  }
488  int hllMerge(uint8_t *max, robj *hll) {
489      struct hllhdr *hdr = hll-&gt;ptr;
490      int i;
491      if (hdr-&gt;encoding == HLL_DENSE) {
492          uint8_t val;
493          for (i = 0; i &lt; HLL_REGISTERS; i++) {
494              HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,i);
495              if (val &gt; max[i]) max[i] = val;
496          }
497      } else {
498          uint8_t *p = hll-&gt;ptr, *end = p + sdslen(hll-&gt;ptr);
499          PORT_LONG runlen, regval;
500          p += HLL_HDR_SIZE;
501          i = 0;
502          while(p &lt; end) {
503              if (HLL_SPARSE_IS_ZERO(p)) {
504                  runlen = HLL_SPARSE_ZERO_LEN(p);
<span onclick='openModal()' class='match'>505                  i += (int)runlen;                                               WIN_PORT_FIX &amp;bsol;* cast (int) */
506                  p++;
</span>507              } else if (HLL_SPARSE_IS_XZERO(p)) {
508                  runlen = HLL_SPARSE_XZERO_LEN(p);
509                  i += (int)runlen;                                               WIN_PORT_FIX &amp;bsol;* cast (int) */
510                  p += 2;
511              } else {
512                  runlen = HLL_SPARSE_VAL_LEN(p);
513                  regval = HLL_SPARSE_VAL_VALUE(p);
514                  if ((runlen + i) &gt; HLL_REGISTERS) break; &amp;bsol;* Overflow. */
515                  while(runlen--) {
516                      if (regval &gt; max[i]) max[i] = (uint8_t)regval;              WIN_PORT_FIX &amp;bsol;* cast (uint8_t) */
517                      i++;
518                  }
519                  p++;
520              }
521          }
522          if (i != HLL_REGISTERS) return C_ERR;
523      }
524      return C_OK;
525  }
526  robj *createHLLObject(void) {
527      robj *o;
528      struct hllhdr *hdr;
529      sds s;
530      uint8_t *p;
531      int sparselen = HLL_HDR_SIZE +
532                      (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
533                       HLL_SPARSE_XZERO_MAX_LEN)*2);
534      int aux;
535      aux = HLL_REGISTERS;
536      s = sdsnewlen(NULL,sparselen);
537      p = (uint8_t*)s + HLL_HDR_SIZE;
538      while(aux) {
539          int xzero = HLL_SPARSE_XZERO_MAX_LEN;
540          if (xzero &gt; aux) xzero = aux;
541          HLL_SPARSE_XZERO_SET(p,xzero);
542          p += 2;
543          aux -= xzero;
544      }
545      serverAssert((p-(uint8_t*)s) == sparselen);
546      o = createObject(OBJ_STRING,s);
547      hdr = o-&gt;ptr;
548      memcpy(hdr-&gt;magic,&quot;HYLL&quot;,4);
549      hdr-&gt;encoding = HLL_SPARSE;
550      return o;
551  }
552  int isHLLObjectOrReply(client *c, robj *o) {
553      struct hllhdr *hdr;
554      if (checkType(c,o,OBJ_STRING))
555          return C_ERR; &amp;bsol;* Error already sent. */
556      if (!sdsEncodedObject(o)) goto invalid;
557      if (stringObjectLen(o) &lt; sizeof(*hdr)) goto invalid;
558      hdr = o-&gt;ptr;
559      if (hdr-&gt;magic[0] != &#x27;H&#x27; || hdr-&gt;magic[1] != &#x27;Y&#x27; ||
560          hdr-&gt;magic[2] != &#x27;L&#x27; || hdr-&gt;magic[3] != &#x27;L&#x27;) goto invalid;
561      if (hdr-&gt;encoding &gt; HLL_MAX_ENCODING) goto invalid;
562      if (hdr-&gt;encoding == HLL_DENSE &amp;&amp;
563          stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
564      return C_OK;
565  invalid:
566      addReplySds(c,
567          sdsnew(&quot;-WRONGTYPE Key is not a valid &quot;
568                 &quot;HyperLogLog string value.\r\n&quot;));
569      return C_ERR;
570  }
571  void pfaddCommand(client *c) {
572      robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);
573      struct hllhdr *hdr;
574      int updated = 0, j;
575      if (o == NULL) {
576          o = createHLLObject();
577          dbAdd(c-&gt;db,c-&gt;argv[1],o);
578          updated++;
579      } else {
580          if (isHLLObjectOrReply(c,o) != C_OK) return;
581          o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);
582      }
583      for (j = 2; j &lt; c-&gt;argc; j++) {
584          int retval = hllAdd(o, (unsigned char*)c-&gt;argv[j]-&gt;ptr,
585                                 sdslen(c-&gt;argv[j]-&gt;ptr));
586          switch(retval) {
587          case 1:
588              updated++;
589              break;
590          case -1:
591              addReplySds(c,sdsnew(invalid_hll_err));
592              return;
593          }
594      }
595      hdr = o-&gt;ptr;
596      if (updated) {
597          signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
598          notifyKeyspaceEvent(NOTIFY_STRING,&quot;pfadd&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
599          server.dirty++;
600          HLL_INVALIDATE_CACHE(hdr);
601      }
602      addReply(c, updated ? shared.cone : shared.czero);
603  }
604  void pfcountCommand(client *c) {
605      robj *o;
606      struct hllhdr *hdr;
607      uint64_t card;
608      if (c-&gt;argc &gt; 2) {
609          uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
610          int j;
611          memset(max,0,sizeof(max));
612          hdr = (struct hllhdr*) max;
613          hdr-&gt;encoding = HLL_RAW; &amp;bsol;* Special internal-only encoding. */
614          registers = max + HLL_HDR_SIZE;
615          for (j = 1; j &lt; c-&gt;argc; j++) {
616              robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);
617              if (o == NULL) continue; &amp;bsol;* Assume empty HLL for non existing var.*/
618              if (isHLLObjectOrReply(c,o) != C_OK) return;
619              if (hllMerge(registers,o) == C_ERR) {
620                  addReplySds(c,sdsnew(invalid_hll_err));
621                  return;
622              }
623          }
624          addReplyLongLong(c,hllCount(hdr,NULL));
625          return;
626      }
627      o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);
628      if (o == NULL) {
629          addReply(c,shared.czero);
630      } else {
631          if (isHLLObjectOrReply(c,o) != C_OK) return;
632          o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);
633          hdr = o-&gt;ptr;
634          if (HLL_VALID_CACHE(hdr)) {
635              card = (uint64_t)hdr-&gt;card[0];
636              card |= (uint64_t)hdr-&gt;card[1] &lt;&lt; 8;
637              card |= (uint64_t)hdr-&gt;card[2] &lt;&lt; 16;
638              card |= (uint64_t)hdr-&gt;card[3] &lt;&lt; 24;
639              card |= (uint64_t)hdr-&gt;card[4] &lt;&lt; 32;
640              card |= (uint64_t)hdr-&gt;card[5] &lt;&lt; 40;
641              card |= (uint64_t)hdr-&gt;card[6] &lt;&lt; 48;
642              card |= (uint64_t)hdr-&gt;card[7] &lt;&lt; 56;
643          } else {
644              int invalid = 0;
645              card = hllCount(hdr,&amp;invalid);
646              if (invalid) {
647                  addReplySds(c,sdsnew(invalid_hll_err));
648                  return;
649              }
650              hdr-&gt;card[0] = card &amp; 0xff;
651              hdr-&gt;card[1] = (card &gt;&gt; 8) &amp; 0xff;
652              hdr-&gt;card[2] = (card &gt;&gt; 16) &amp; 0xff;
653              hdr-&gt;card[3] = (card &gt;&gt; 24) &amp; 0xff;
654              hdr-&gt;card[4] = (card &gt;&gt; 32) &amp; 0xff;
655              hdr-&gt;card[5] = (card &gt;&gt; 40) &amp; 0xff;
656              hdr-&gt;card[6] = (card &gt;&gt; 48) &amp; 0xff;
657              hdr-&gt;card[7] = (card &gt;&gt; 56) &amp; 0xff;
658              signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
659              server.dirty++;
660          }
661          addReplyLongLong(c,card);
662      }
663  }
664  void pfmergeCommand(client *c) {
665      uint8_t max[HLL_REGISTERS];
666      struct hllhdr *hdr;
667      int j;
668      int use_dense = 0; &amp;bsol;* Use dense representation as target? */
669      memset(max,0,sizeof(max));
670      for (j = 1; j &lt; c-&gt;argc; j++) {
671          robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);
672          if (o == NULL) continue; &amp;bsol;* Assume empty HLL for non existing var. */
673          if (isHLLObjectOrReply(c,o) != C_OK) return;
674          hdr = o-&gt;ptr;
675          if (hdr-&gt;encoding == HLL_DENSE) use_dense = 1;
676          if (hllMerge(max,o) == C_ERR) {
677              addReplySds(c,sdsnew(invalid_hll_err));
678              return;
679          }
680      }
681      robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);
682      if (o == NULL) {
683          o = createHLLObject();
684          dbAdd(c-&gt;db,c-&gt;argv[1],o);
685      } else {
686          o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);
687      }
688      if (use_dense &amp;&amp; hllSparseToDense(o) == C_ERR) {
689          addReplySds(c,sdsnew(invalid_hll_err));
690          return;
691      }
692      for (j = 0; j &lt; HLL_REGISTERS; j++) {
693          if (max[j] == 0) continue;
694          hdr = o-&gt;ptr;
695          switch(hdr-&gt;encoding) {
696          case HLL_DENSE: hllDenseSet(hdr-&gt;registers,j,max[j]); break;
697          case HLL_SPARSE: hllSparseSet(o,j,max[j]); break;
698          }
699      }
700      hdr = o-&gt;ptr; &amp;bsol;* o-&gt;ptr may be different now, as a side effect of
701                       last hllSparseSet() call. */
702      HLL_INVALIDATE_CACHE(hdr);
703      signalModifiedKey(c-&gt;db,c-&gt;argv[1]);
704      notifyKeyspaceEvent(NOTIFY_STRING,&quot;pfadd&quot;,c-&gt;argv[1],c-&gt;db-&gt;id);
705      server.dirty++;
706      addReply(c,shared.ok);
707  }
708  #define HLL_TEST_CYCLES 1000
709  void pfselftestCommand(client *c) {
710      unsigned int j, i;
711      sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
712      struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
713      robj *o = NULL;
714      uint8_t bytecounters[HLL_REGISTERS];
715      for (j = 0; j &lt; HLL_TEST_CYCLES; j++) {
716          for (i = 0; i &lt; HLL_REGISTERS; i++) {
717              unsigned int r = rand() &amp; HLL_REGISTER_MAX;
718              bytecounters[i] = r;
719              HLL_DENSE_SET_REGISTER(hdr-&gt;registers,i,r);
720          }
721          for (i = 0; i &lt; HLL_REGISTERS; i++) {
722              unsigned int val;
723              HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,i);
724              if (val != bytecounters[i]) {
725                  addReplyErrorFormat(c,
726                      &quot;TESTFAILED Register %d should be %d but is %d&quot;,
727                      i, (int) bytecounters[i], (int) val);
728                  goto cleanup;
729              }
730          }
731      }
732      memset(hdr-&gt;registers,0,HLL_DENSE_SIZE-HLL_HDR_SIZE);
733      o = createHLLObject();
734      double relerr = 1.04/sqrt(HLL_REGISTERS);
735      int64_t checkpoint = 1;
736      uint64_t seed = (uint64_t)rand() | (uint64_t)rand() &lt;&lt; 32;
737      uint64_t ele;
738      for (j = 1; j &lt;= 10000000; j++) {
739          ele = j ^ seed;
740          hllDenseAdd(hdr-&gt;registers,(unsigned char*)&amp;ele,sizeof(ele));
741          hllAdd(o,(unsigned char*)&amp;ele,sizeof(ele));
742          if (j == checkpoint &amp;&amp; j &lt; server.hll_sparse_max_bytes/2) {
743              hdr2 = o-&gt;ptr;
744              if (hdr2-&gt;encoding != HLL_SPARSE) {
745                  addReplyError(c, &quot;TESTFAILED sparse encoding not used&quot;);
746                  goto cleanup;
747              }
748          }
749          if (j == checkpoint &amp;&amp; hllCount(hdr,NULL) != hllCount(o-&gt;ptr,NULL)) {
750                  addReplyError(c, &quot;TESTFAILED dense/sparse disagree&quot;);
751                  goto cleanup;
752          }
753          if (j == checkpoint) {
754              int64_t abserr = checkpoint - (int64_t)hllCount(hdr,NULL);
755              uint64_t maxerr = (uint64_t)ceil(relerr*6*checkpoint);              WIN_PORT_FIX &amp;bsol;* cast (uint64_t) */
756              if (j == 10) maxerr = 1;
757              if (abserr &lt; 0) abserr = -abserr;
758              if (abserr &gt; (int64_t)maxerr) {
759                  addReplyErrorFormat(c,
760                      &quot;TESTFAILED Too big error. card:%llu abserr:%llu&quot;,
761                      (PORT_ULONGLONG) checkpoint,
762                      (PORT_ULONGLONG) abserr);
763                  goto cleanup;
764              }
765              checkpoint *= 10;
766          }
767      }
768      addReply(c,shared.ok);
769  cleanup:
770      sdsfree(bitcounters);
771      if (o) decrRefCount(o);
772  }
773  void pfdebugCommand(client *c) {
774      char *cmd = c-&gt;argv[1]-&gt;ptr;
775      struct hllhdr *hdr;
776      robj *o;
777      int j;
778      o = lookupKeyWrite(c-&gt;db,c-&gt;argv[2]);
779      if (o == NULL) {
780          addReplyError(c,&quot;The specified key does not exist&quot;);
781          return;
782      }
783      if (isHLLObjectOrReply(c,o) != C_OK) return;
784      o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[2],o);
785      hdr = o-&gt;ptr;
786      if (!strcasecmp(cmd,&quot;getreg&quot;)) {
787          if (c-&gt;argc != 3) goto arityerr;
788          if (hdr-&gt;encoding == HLL_SPARSE) {
789              if (hllSparseToDense(o) == C_ERR) {
790                  addReplySds(c,sdsnew(invalid_hll_err));
791                  return;
792              }
793              server.dirty++; &amp;bsol;* Force propagation on encoding change. */
794          }
795          hdr = o-&gt;ptr;
796          addReplyMultiBulkLen(c,HLL_REGISTERS);
797          for (j = 0; j &lt; HLL_REGISTERS; j++) {
798              uint8_t val;
799              HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,j);
800              addReplyLongLong(c,val);
801          }
802      }
803      else if (!strcasecmp(cmd,&quot;decode&quot;)) {
804          if (c-&gt;argc != 3) goto arityerr;
805          uint8_t *p = o-&gt;ptr, *end = p+sdslen(o-&gt;ptr);
806          sds decoded = sdsempty();
807          if (hdr-&gt;encoding != HLL_SPARSE) {
808              sdsfree(decoded);
809              addReplyError(c,&quot;HLL encoding is not sparse&quot;);
810              return;
811          }
812          p += HLL_HDR_SIZE;
813          while(p &lt; end) {
814              int runlen, regval;
815              if (HLL_SPARSE_IS_ZERO(p)) {
816                  runlen = HLL_SPARSE_ZERO_LEN(p);
817                  p++;
818                  decoded = sdscatprintf(decoded,&quot;z:%d &quot;,runlen);
819              } else if (HLL_SPARSE_IS_XZERO(p)) {
820                  runlen = HLL_SPARSE_XZERO_LEN(p);
821                  p += 2;
822                  decoded = sdscatprintf(decoded,&quot;Z:%d &quot;,runlen);
823              } else {
824                  runlen = HLL_SPARSE_VAL_LEN(p);
825                  regval = HLL_SPARSE_VAL_VALUE(p);
826                  p++;
827                  decoded = sdscatprintf(decoded,&quot;v:%d,%d &quot;,regval,runlen);
828              }
829          }
830          decoded = sdstrim(decoded,&quot; &quot;);
831          addReplyBulkCBuffer(c,decoded,sdslen(decoded));
832          sdsfree(decoded);
833      }
834      else if (!strcasecmp(cmd,&quot;encoding&quot;)) {
835          char *encodingstr[2] = {&quot;dense&quot;,&quot;sparse&quot;};
836          if (c-&gt;argc != 3) goto arityerr;
837          addReplyStatus(c,encodingstr[hdr-&gt;encoding]);
838      }
839      else if (!strcasecmp(cmd,&quot;todense&quot;)) {
840          int conv = 0;
841          if (c-&gt;argc != 3) goto arityerr;
842          if (hdr-&gt;encoding == HLL_SPARSE) {
843              if (hllSparseToDense(o) == C_ERR) {
844                  addReplySds(c,sdsnew(invalid_hll_err));
845                  return;
846              }
847              conv = 1;
848              server.dirty++; &amp;bsol;* Force propagation on encoding change. */
849          }
850          addReply(c,conv ? shared.cone : shared.czero);
851      } else {
852          addReplyErrorFormat(c,&quot;Unknown PFDEBUG subcommand &#x27;%s&#x27;&quot;, cmd);
853      }
854      return;
855  arityerr:
856      addReplyErrorFormat(c,
857          &quot;Wrong number of arguments for the &#x27;%s&#x27; subcommand&quot;,cmd);
858  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds_35.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Portability.h&quot;
3  #include &quot;Win32_Interop/win32fixes.h&quot;
4  #endif
5  #include &lt;stdio.h&gt;
6  #include &lt;stdlib.h&gt;
7  #include &lt;string.h&gt;
8  #include &lt;ctype.h&gt;
9  #include &lt;assert.h&gt;
10  #include &lt;limits.h&gt;
11  #include &quot;sds.h&quot;
12  #include &quot;sdsalloc.h&quot;
13  const char *SDS_NOINIT = &quot;SDS_NOINIT&quot;;
14  static inline int sdsHdrSize(char type) {
15      switch(type&amp;SDS_TYPE_MASK) {
16          case SDS_TYPE_5:
17              return sizeof(struct sdshdr5);
18          case SDS_TYPE_8:
19              return sizeof(struct sdshdr8);
20          case SDS_TYPE_16:
21              return sizeof(struct sdshdr16);
22          case SDS_TYPE_32:
23              return sizeof(struct sdshdr32);
24          case SDS_TYPE_64:
25              return sizeof(struct sdshdr64);
26      }
27      return 0;
28  }
29  static inline char sdsReqType(size_t string_size) {
30      if (string_size &lt; 1&lt;&lt;5)
31          return SDS_TYPE_5;
32      if (string_size &lt; 1&lt;&lt;8)
33          return SDS_TYPE_8;
34      if (string_size &lt; 1&lt;&lt;16)
35          return SDS_TYPE_16;
36  #if (PORT_LONG_MAX == LLONG_MAX)
37      if (string_size &lt; 1ll&lt;&lt;32)
38          return SDS_TYPE_32;
39      return SDS_TYPE_64;
40  #else
41      return SDS_TYPE_32;
42  #endif
43  }
44  sds sdsnewlen(const void *init, size_t initlen) {
45      void *sh;
46      sds s;
47      char type = sdsReqType(initlen);
48      if (type == SDS_TYPE_5 &amp;&amp; initlen == 0) type = SDS_TYPE_8;
49      int hdrlen = sdsHdrSize(type);
50      unsigned char *fp; &amp;bsol;* flags pointer. */
51      sh = s_malloc(hdrlen+initlen+1);
52      if (init==SDS_NOINIT)
53          init = NULL;
54      else if (!init)
55          memset(sh, 0, hdrlen+initlen+1);
56      if (sh == NULL) return NULL;
57      s = (char*)sh+hdrlen;
58      fp = ((unsigned char*)s)-1;
59      switch(type) {
60          case SDS_TYPE_5: {
61              *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);
62              break;
63          }
64          case SDS_TYPE_8: {
65              SDS_HDR_VAR(8,s);
66              sh-&gt;len = (uint8_t)initlen;                                         WIN_PORT_FIX &amp;bsol;* cast (uint8_t) */
67              sh-&gt;alloc = (uint8_t)initlen;                                       WIN_PORT_FIX &amp;bsol;* cast (uint8_t) */
68              *fp = type;
69              break;
70          }
71          case SDS_TYPE_16: {
72              SDS_HDR_VAR(16,s);
73              sh-&gt;len = (uint16_t)initlen;                                        WIN_PORT_FIX &amp;bsol;* cast (uint16_t) */
74              sh-&gt;alloc = (uint16_t)initlen;                                      WIN_PORT_FIX &amp;bsol;* cast (uint16_t) */
75              *fp = type;
76              break;
77          }
78          case SDS_TYPE_32: {
79              SDS_HDR_VAR(32,s);
80              sh-&gt;len = (uint32_t)initlen;                                        WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
81              sh-&gt;alloc = (uint32_t)initlen;                                      WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
82              *fp = type;
83              break;
84          }
85          case SDS_TYPE_64: {
86              SDS_HDR_VAR(64,s);
87              sh-&gt;len = initlen;
88              sh-&gt;alloc = initlen;
89              *fp = type;
90              break;
91          }
92      }
93      if (initlen &amp;&amp; init)
94          memcpy(s, init, initlen);
95      s[initlen] = &#x27;\0&#x27;;
96      return s;
97  }
98  sds sdsempty(void) {
99      return sdsnewlen(&quot;&quot;,0);
100  }
101  sds sdsnew(const char *init) {
102      size_t initlen = (init == NULL) ? 0 : strlen(init);
103      return sdsnewlen(init, initlen);
104  }
105  sds sdsdup(const sds s) {
106      return sdsnewlen(s, sdslen(s));
107  }
108  void sdsfree(sds s) {
109      if (s == NULL) return;
110      s_free((char*)s-sdsHdrSize(s[-1]));
111  }
112  void sdsupdatelen(sds s) {
113      size_t reallen = strlen(s);
114      sdssetlen(s, reallen);
115  }
116  void sdsclear(sds s) {
117      sdssetlen(s, 0);
118      s[0] = &#x27;\0&#x27;;
119  }
120  sds sdsMakeRoomFor(sds s, size_t addlen) {
121      void *sh, *newsh;
122      size_t avail = sdsavail(s);
123      size_t len, newlen;
124      char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
125      int hdrlen;
126      if (avail &gt;= addlen) return s;
127      len = sdslen(s);
128      sh = (char*)s-sdsHdrSize(oldtype);
129      newlen = (len+addlen);
130      if (newlen &lt; SDS_MAX_PREALLOC)
131          newlen *= 2;
132      else
133          newlen += SDS_MAX_PREALLOC;
134      type = sdsReqType(newlen);
135      if (type == SDS_TYPE_5) type = SDS_TYPE_8;
136      hdrlen = sdsHdrSize(type);
137      if (oldtype==type) {
138          newsh = s_realloc(sh, hdrlen+newlen+1);
139          if (newsh == NULL) return NULL;
140          s = (char*)newsh+hdrlen;
141      } else {
142          newsh = s_malloc(hdrlen+newlen+1);
143          if (newsh == NULL) return NULL;
144          memcpy((char*)newsh+hdrlen, s, len+1);
145          s_free(sh);
146          s = (char*)newsh+hdrlen;
147          s[-1] = type;
148          sdssetlen(s, len);
149      }
150      sdssetalloc(s, newlen);
151      return s;
152  }
153  sds sdsRemoveFreeSpace(sds s) {
154      void *sh, *newsh;
155      char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;
156      int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
157      size_t len = sdslen(s);
158      size_t avail = sdsavail(s);
159      sh = (char*)s-oldhdrlen;
160      if (avail == 0) return s;
161      type = sdsReqType(len);
162      hdrlen = sdsHdrSize(type);
163      if (oldtype==type || type &gt; SDS_TYPE_8) {
164          newsh = s_realloc(sh, oldhdrlen+len+1);
165          if (newsh == NULL) return NULL;
166          s = (char*)newsh+oldhdrlen;
167      } else {
168          newsh = s_malloc(hdrlen+len+1);
169          if (newsh == NULL) return NULL;
170          memcpy((char*)newsh+hdrlen, s, len+1);
171          s_free(sh);
172          s = (char*)newsh+hdrlen;
173          s[-1] = type;
174          sdssetlen(s, len);
175      }
176      sdssetalloc(s, len);
177      return s;
178  }
179  size_t sdsAllocSize(sds s) {
180      size_t alloc = sdsalloc(s);
181      return sdsHdrSize(s[-1])+alloc+1;
182  }
183  void *sdsAllocPtr(sds s) {
184      return (void*) (s-sdsHdrSize(s[-1]));
185  }
186  void sdsIncrLen(sds s, ssize_t incr) {
187      unsigned char flags = s[-1];
188      size_t len;
189      switch(flags&amp;SDS_TYPE_MASK) {
190          case SDS_TYPE_5: {
191              unsigned char *fp = ((unsigned char*)s)-1;
192              unsigned char oldlen = SDS_TYPE_5_LEN(flags);
193              assert((incr &gt; 0 &amp;&amp; oldlen+incr &lt; 32) || (incr &lt; 0 &amp;&amp; oldlen &gt;= (unsigned int)(-incr)));
194              *fp = SDS_TYPE_5 | (unsigned char)((oldlen+incr) &lt;&lt; SDS_TYPE_BITS);  WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
195              len = oldlen+incr;
196              break;
197          }
198          case SDS_TYPE_8: {
199              SDS_HDR_VAR(8,s);
200              assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
201  #ifdef _WIN32
202              sh-&gt;len += (uint8_t)incr;
203              len = sh-&gt;len;
204  #else
205              len = (sh-&gt;len += incr);
206  #endif
207              break;
208          }
209          case SDS_TYPE_16: {
210              SDS_HDR_VAR(16,s);
211              assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
212  #ifdef _WIN32
213              sh-&gt;len += (uint16_t)incr;
214              len = sh-&gt;len;
215  #else
216              len = (sh-&gt;len += incr);
217  #endif
218              break;
219          }
220          case SDS_TYPE_32: {
221              SDS_HDR_VAR(32,s);
222              assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (unsigned int)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (unsigned int)(-incr)));
223  #ifdef _WIN32
224              sh-&gt;len += (uint32_t)incr;
225              len = sh-&gt;len;
226  #else
227              len = (sh-&gt;len += incr);
228  #endif
229              break;
230          }
231          case SDS_TYPE_64: {
232              SDS_HDR_VAR(64,s);
233              assert((incr &gt;= 0 &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (uint64_t)incr) || (incr &lt; 0 &amp;&amp; sh-&gt;len &gt;= (uint64_t)(-incr)));
234              len = (sh-&gt;len += incr);
235              break;
236          }
237          default: len = 0; &amp;bsol;* Just to avoid compilation warnings. */
238      }
239      s[len] = &#x27;\0&#x27;;
240  }
241  sds sdsgrowzero(sds s, size_t len) {
242      size_t curlen = sdslen(s);
243      if (len &lt;= curlen) return s;
244      s = sdsMakeRoomFor(s,len-curlen);
245      if (s == NULL) return NULL;
246      memset(s+curlen,0,(len-curlen+1)); &amp;bsol;* also set trailing \0 byte */
247      sdssetlen(s, len);
248      return s;
249  }
250  sds sdscatlen(sds s, const void *t, size_t len) {
251      size_t curlen = sdslen(s);
252      s = sdsMakeRoomFor(s,len);
253      if (s == NULL) return NULL;
254      memcpy(s+curlen, t, len);
255      sdssetlen(s, curlen+len);
256      s[curlen+len] = &#x27;\0&#x27;;
257      return s;
258  }
259  sds sdscat(sds s, const char *t) {
260      return sdscatlen(s, t, strlen(t));
261  }
262  sds sdscatsds(sds s, const sds t) {
263      return sdscatlen(s, t, sdslen(t));
264  }
265  sds sdscpylen(sds s, const char *t, size_t len) {
266      if (sdsalloc(s) &lt; len) {
267          s = sdsMakeRoomFor(s,len-sdslen(s));
268          if (s == NULL) return NULL;
269      }
270      memcpy(s, t, len);
271      s[len] = &#x27;\0&#x27;;
272      sdssetlen(s, len);
273      return s;
274  }
275  sds sdscpy(sds s, const char *t) {
276      return sdscpylen(s, t, strlen(t));
277  }
278  #define SDS_LLSTR_SIZE 21
279  int sdsll2str(char *s, PORT_LONGLONG value) {
280      char *p, aux;
281      PORT_ULONGLONG v;
282      size_t l;
283      v = (value &lt; 0) ? -value : value;
284      p = s;
285      do {
286          *p++ = &#x27;0&#x27;+(v%10);
287          v /= 10;
288      } while(v);
289      if (value &lt; 0) *p++ = &#x27;-&#x27;;
290      l = p-s;
291      *p = &#x27;\0&#x27;;
292      p--;
293      while(s &lt; p) {
294          aux = *s;
295          *s = *p;
296          *p = aux;
297          s++;
298          p--;
299      }
300      return (int)l;                                                              WIN_PORT_FIX &amp;bsol;* cast (int) */
301  }
302  int sdsull2str(char *s, PORT_ULONGLONG v) {
303      char *p, aux;
304      size_t l;
305      p = s;
306      do {
307          *p++ = &#x27;0&#x27;+(v%10);
308          v /= 10;
309      } while(v);
310      l = p-s;
311      *p = &#x27;\0&#x27;;
312      p--;
313      while(s &lt; p) {
314          aux = *s;
315          *s = *p;
316          *p = aux;
317          s++;
318          p--;
319      }
320      return (int)l;
321  }
322  sds sdsfromlonglong(PORT_LONGLONG value) {
323      char buf[SDS_LLSTR_SIZE];
324      int len = sdsll2str(buf,value);
325      return sdsnewlen(buf,len);
326  }
327  sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
328      va_list cpy;
329      char staticbuf[1024], *buf = staticbuf, *t;
330      size_t buflen = strlen(fmt)*2;
331      if (buflen &gt; sizeof(staticbuf)) {
332          buf = s_malloc(buflen);
333          if (buf == NULL) return NULL;
334      } else {
335          buflen = sizeof(staticbuf);
336          WIN32_ONLY(memset(staticbuf, 0, sizeof(staticbuf));)
337      }
338      while(1) {
339          buf[buflen-2] = &#x27;\0&#x27;;
340          va_copy(cpy,ap);
341          vsnprintf(buf, buflen, fmt, cpy);
342          va_end(cpy);
343          if (buf[buflen-2] != &#x27;\0&#x27;) {
344              if (buf != staticbuf) s_free(buf);
345              buflen *= 2;
346              buf = s_malloc(buflen);
347              if (buf == NULL) return NULL;
348              continue;
349          }
350          break;
351      }
352      t = sdscat(s, buf);
353      if (buf != staticbuf) s_free(buf);
354      return t;
355  }
356  sds sdscatprintf(sds s, const char *fmt, ...) {
357      va_list ap;
358      char *t;
359      va_start(ap, fmt);
360      t = sdscatvprintf(s,fmt,ap);
361      va_end(ap);
362      return t;
363  }
364  sds sdscatfmt(sds s, char const *fmt, ...) {
365      size_t initlen = sdslen(s);
366      const char *f = fmt;
367      PORT_LONG i;
368      va_list ap;
369      va_start(ap,fmt);
370      f = fmt;    &amp;bsol;* Next format specifier byte to process. */
371      i = initlen; &amp;bsol;* Position of the next byte to write to dest str. */
372      while(*f) {
373          char next, *str;
374          size_t l;
375          PORT_LONGLONG num;
376          PORT_ULONGLONG unum;
377          if (sdsavail(s)==0) {
378              s = sdsMakeRoomFor(s,1);
379          }
380          switch(*f) {
381          case &#x27;%&#x27;:
382              next = *(f+1);
383              f++;
384              switch(next) {
385              case &#x27;s&#x27;:
386              case &#x27;S&#x27;:
387                  str = va_arg(ap,char*);
388                  l = (int)((next == &#x27;s&#x27;) ? strlen(str) : sdslen(str));           WIN_PORT_FIX &amp;bsol;* cast (int) */
389                  if (sdsavail(s) &lt; l) {
390                      s = sdsMakeRoomFor(s,l);
391                  }
392                  memcpy(s+i,str,l);
393                  sdsinclen(s,l);
394                  i += (int)l;                                                    WIN_PORT_FIX &amp;bsol;* cast (int) */
395                  break;
396              case &#x27;i&#x27;:
397              case &#x27;I&#x27;:
398                  if (next == &#x27;i&#x27;)
399                      num = va_arg(ap,int);
400                  else
401                      num = va_arg(ap,PORT_LONGLONG);
402                  {
403                      char buf[SDS_LLSTR_SIZE];
404                      l = sdsll2str(buf,num);
405                      if (sdsavail(s) &lt; l) {
406                          s = sdsMakeRoomFor(s,l);
407                      }
408                      memcpy(s+i,buf,l);
409                      sdsinclen(s,l);
<span onclick='openModal()' class='match'>410                      i += (int)l;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
411                  }
</span>412                  break;
413              case &#x27;u&#x27;:
414              case &#x27;U&#x27;:
415                  if (next == &#x27;u&#x27;)
416                      unum = va_arg(ap,unsigned int);
417                  else
418                      unum = va_arg(ap,PORT_ULONGLONG);
419                  {
420                      char buf[SDS_LLSTR_SIZE];
421                      l = sdsull2str(buf,unum);
422                      if (sdsavail(s) &lt; l) {
423                          s = sdsMakeRoomFor(s,l);
424                      }
425                      memcpy(s+i,buf,l);
426                      sdsinclen(s,l);
427                      i += (int)l;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
428                  }
429                  break;
430              default: &amp;bsol;* Handle %% and generally %&lt;unknown&gt;. */
431                  s[i++] = next;
432                  sdsinclen(s,1);
433                  break;
434              }
435              break;
436          default:
437              s[i++] = *f;
438              sdsinclen(s,1);
439              break;
440          }
441          f++;
442      }
443      va_end(ap);
444      s[i] = &#x27;\0&#x27;;
445      return s;
446  }
447  sds sdstrim(sds s, const char *cset) {
448      char *start, *end, *sp, *ep;
449      size_t len;
450      sp = start = s;
451      ep = end = s+sdslen(s)-1;
452      while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++;
453      while(ep &gt; sp &amp;&amp; strchr(cset, *ep)) ep--;
454      len = (sp &gt; ep) ? 0 : ((ep-sp)+1);
455      if (s != sp) memmove(s, sp, len);
456      s[len] = &#x27;\0&#x27;;
457      sdssetlen(s,len);
458      return s;
459  }
460  void sdsrange(sds s, ssize_t start, ssize_t end) {
461      size_t newlen, len = sdslen(s);
462      if (len == 0) return;
463      if (start &lt; 0) {
464          start = (int)len+start;                                                 WIN_PORT_FIX &amp;bsol;* cast (int) */
465          if (start &lt; 0) start = 0;
466      }
467      if (end &lt; 0) {
468          end = (int)len+end;                                                     WIN_PORT_FIX &amp;bsol;* cast (int) */
469          if (end &lt; 0) end = 0;
470      }
471      newlen = (start &gt; end) ? 0 : (end-start)+1;
472      if (newlen != 0) {
473          if (start &gt;= (ssize_t)len) {
474              newlen = 0;
475          } else if (end &gt;= (ssize_t)len) {
476              end = (int)len-1;                                                   WIN_PORT_FIX &amp;bsol;* cast (int) */
477              newlen = (start &gt; end) ? 0 : (end-start)+1;
478          }
479      } else {
480          start = 0;
481      }
482      if (start &amp;&amp; newlen) memmove(s, s+start, newlen);
483      s[newlen] = 0;
484      sdssetlen(s,newlen);
485  }
486  void sdstolower(sds s) {
487      size_t len = sdslen(s), j;
488      for (j = 0; j &lt; len; j++) s[j] = tolower(s[j]);
489  }
490  void sdstoupper(sds s) {
491      size_t len = sdslen(s), j;
492      for (j = 0; j &lt; len; j++) s[j] = toupper(s[j]);
493  }
494  int sdscmp(const sds s1, const sds s2) {
495      size_t l1, l2, minlen;
496      int cmp;
497      l1 = sdslen(s1);
498      l2 = sdslen(s2);
499      minlen = (l1 &lt; l2) ? l1 : l2;
500      cmp = memcmp(s1,s2,minlen);
501      if (cmp == 0) return l1&gt;l2? 1: (l1&lt;l2? -1: 0);
502      return cmp;
503  }
504  sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {
505      int elements = 0, slots = 5;
506      PORT_LONG start = 0, j;
507      sds *tokens;
508      if (seplen &lt; 1 || len &lt; 0) return NULL;
509      tokens = s_malloc(sizeof(sds)*slots);
510      if (tokens == NULL) return NULL;
511      if (len == 0) {
512          *count = 0;
513          return tokens;
514      }
515      for (j = 0; j &lt; (len-((ssize_t)seplen-1)); j++) {  WIN_PORT_FIX &amp;bsol;* cast (ssize_t) */
516          if (slots &lt; elements+2) {
517              sds *newtokens;
518              slots *= 2;
519              newtokens = s_realloc(tokens,sizeof(sds)*slots);
520              if (newtokens == NULL) goto cleanup;
521              tokens = newtokens;
522          }
523          if ((seplen == 1 &amp;&amp; *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
524              tokens[elements] = sdsnewlen(s+start,j-start);
525              if (tokens[elements] == NULL) goto cleanup;
526              elements++;
527              start = j+seplen;
528              j = j+seplen-1; &amp;bsol;* skip the separator */
529          }
530      }
531      tokens[elements] = sdsnewlen(s+start,len-start);
532      if (tokens[elements] == NULL) goto cleanup;
533      elements++;
534      *count = elements;
535      return tokens;
536  cleanup:
537      {
538          int i;
539          for (i = 0; i &lt; elements; i++) sdsfree(tokens[i]);
540          s_free(tokens);
541          *count = 0;
542          return NULL;
543      }
544  }
545  void sdsfreesplitres(sds *tokens, int count) {
546      if (!tokens) return;
547      while(count--)
548          sdsfree(tokens[count]);
549      s_free(tokens);
550  }
551  sds sdscatrepr(sds s, const char *p, size_t len) {
552      s = sdscatlen(s,&quot;\&quot;&quot;,1);
553      while(len--) {
554          switch(*p) {
555          case &#x27;\\&#x27;:
556          case &#x27;&quot;&#x27;:
557              s = sdscatprintf(s,&quot;\\%c&quot;,*p);
558              break;
559          case &#x27;\n&#x27;: s = sdscatlen(s,&quot;\\n&quot;,2); break;
560          case &#x27;\r&#x27;: s = sdscatlen(s,&quot;\\r&quot;,2); break;
561          case &#x27;\t&#x27;: s = sdscatlen(s,&quot;\\t&quot;,2); break;
562          case &#x27;\a&#x27;: s = sdscatlen(s,&quot;\\a&quot;,2); break;
563          case &#x27;\b&#x27;: s = sdscatlen(s,&quot;\\b&quot;,2); break;
564          default:
565              if (isprint((unsigned char)*p))                                     WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
566                  s = sdscatprintf(s,&quot;%c&quot;,*p);
567              else
568                  s = sdscatprintf(s,&quot;\\x%02x&quot;,(unsigned char)*p);
569              break;
570          }
571          p++;
572      }
573      return sdscatlen(s,&quot;\&quot;&quot;,1);
574  }
575  int is_hex_digit(char c) {
576      return (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;) ||
577             (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;);
578  }
579  int hex_digit_to_int(char c) {
580      switch(c) {
581      case &#x27;0&#x27;: return 0;
582      case &#x27;1&#x27;: return 1;
583      case &#x27;2&#x27;: return 2;
584      case &#x27;3&#x27;: return 3;
585      case &#x27;4&#x27;: return 4;
586      case &#x27;5&#x27;: return 5;
587      case &#x27;6&#x27;: return 6;
588      case &#x27;7&#x27;: return 7;
589      case &#x27;8&#x27;: return 8;
590      case &#x27;9&#x27;: return 9;
591      case &#x27;a&#x27;: case &#x27;A&#x27;: return 10;
592      case &#x27;b&#x27;: case &#x27;B&#x27;: return 11;
593      case &#x27;c&#x27;: case &#x27;C&#x27;: return 12;
594      case &#x27;d&#x27;: case &#x27;D&#x27;: return 13;
595      case &#x27;e&#x27;: case &#x27;E&#x27;: return 14;
596      case &#x27;f&#x27;: case &#x27;F&#x27;: return 15;
597      default: return 0;
598      }
599  }
600  sds *sdssplitargs(const char *line, int *argc) {
601      const char *p = line;
602      char *current = NULL;
603      char **vector = NULL;
604      *argc = 0;
605      while(1) {
606          while(*p &amp;&amp; isspace(*p)) p++;
607          if (*p) {
608              int inq=0;  &amp;bsol;* set to 1 if we are in &quot;quotes&quot; */
609              int insq=0; &amp;bsol;* set to 1 if we are in &#x27;single quotes&#x27; */
610              int done=0;
611              if (current == NULL) current = sdsempty();
612              while(!done) {
613                  if (inq) {
614                      if (*p == &#x27;\\&#x27; &amp;&amp; *(p+1) == &#x27;x&#x27; &amp;&amp;
615                                               is_hex_digit(*(p+2)) &amp;&amp;
616                                               is_hex_digit(*(p+3)))
617                      {
618                          unsigned char byte;
619                          byte = (hex_digit_to_int(*(p+2))*16)+
620                                  hex_digit_to_int(*(p+3));
621                          current = sdscatlen(current,(char*)&amp;byte,1);
622                          p += 3;
623                      } else if (*p == &#x27;\\&#x27; &amp;&amp; *(p+1)) {
624                          char c;
625                          p++;
626                          switch(*p) {
627                          case &#x27;n&#x27;: c = &#x27;\n&#x27;; break;
628                          case &#x27;r&#x27;: c = &#x27;\r&#x27;; break;
629                          case &#x27;t&#x27;: c = &#x27;\t&#x27;; break;
630                          case &#x27;b&#x27;: c = &#x27;\b&#x27;; break;
631                          case &#x27;a&#x27;: c = &#x27;\a&#x27;; break;
632                          default: c = *p; break;
633                          }
634                          current = sdscatlen(current,&amp;c,1);
635                      } else if (*p == &#x27;&quot;&#x27;) {
636                          if (*(p+1) &amp;&amp; !isspace(*(p+1))) goto err;
637                          done=1;
638                      } else if (!*p) {
639                          goto err;
640                      } else {
641                          current = sdscatlen(current,p,1);
642                      }
643                  } else if (insq) {
644                      if (*p == &#x27;\\&#x27; &amp;&amp; *(p+1) == &#x27;\&#x27;&#x27;) {
645                          p++;
646                          current = sdscatlen(current,&quot;&#x27;&quot;,1);
647                      } else if (*p == &#x27;\&#x27;&#x27;) {
648                          if (*(p+1) &amp;&amp; !isspace(*(p+1))) goto err;
649                          done=1;
650                      } else if (!*p) {
651                          goto err;
652                      } else {
653                          current = sdscatlen(current,p,1);
654                      }
655                  } else {
656                      switch(*p) {
657                      case &#x27; &#x27;:
658                      case &#x27;\n&#x27;:
659                      case &#x27;\r&#x27;:
660                      case &#x27;\t&#x27;:
661                      case &#x27;\0&#x27;:
662                          done=1;
663                          break;
664                      case &#x27;&quot;&#x27;:
665                          inq=1;
666                          break;
667                      case &#x27;\&#x27;&#x27;:
668                          insq=1;
669                          break;
670                      default:
671                          current = sdscatlen(current,p,1);
672                          break;
673                      }
674                  }
675                  if (*p) p++;
676              }
677              vector = s_realloc(vector,((size_t)(*argc)+1)*sizeof(char*));  WIN_PORT_FIX &amp;bsol;* cast (size_t) */
678              vector[*argc] = current;
679              (*argc)++;
680              current = NULL;
681          } else {
682              if (vector == NULL) vector = s_malloc(sizeof(void*));
683              return vector;
684          }
685      }
686  err:
687      while((*argc)--)
688          sdsfree(vector[*argc]);
689      s_free(vector);
690      if (current) sdsfree(current);
691      *argc = 0;
692      return NULL;
693  }
694  sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
695      size_t j, i, l = sdslen(s);
696      for (j = 0; j &lt; l; j++) {
697          for (i = 0; i &lt; setlen; i++) {
698              if (s[j] == from[i]) {
699                  s[j] = to[i];
700                  break;
701              }
702          }
703      }
704      return s;
705  }
706  sds sdsjoin(char **argv, int argc, char *sep) {
707      sds join = sdsempty();
708      int j;
709      for (j = 0; j &lt; argc; j++) {
710          join = sdscat(join, argv[j]);
711          if (j != argc-1) join = sdscat(join,sep);
712      }
713      return join;
714  }
715  sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
716      sds join = sdsempty();
717      int j;
718      for (j = 0; j &lt; argc; j++) {
719          join = sdscatsds(join, argv[j]);
720          if (j != argc-1) join = sdscatlen(join,sep,seplen);
721      }
722      return join;
723  }
724  void *sds_malloc(size_t size) { return s_malloc(size); }
725  void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
726  void sds_free(void *ptr) { s_free(ptr); }
727  #if defined(SDS_TEST_MAIN)
728  #include &lt;stdio.h&gt;
729  #include &quot;testhelp.h&quot;
730  #include &quot;limits.h&quot;
731  #define UNUSED(x) (void)(x)
732  int sdsTest(void) {
733      {
734          sds x = sdsnew(&quot;foo&quot;), y;
735          test_cond(&quot;Create a string and obtain the length&quot;,
736              sdslen(x) == 3 &amp;&amp; memcmp(x,&quot;foo\0&quot;,4) == 0)
737          sdsfree(x);
738          x = sdsnewlen(&quot;foo&quot;,2);
739          test_cond(&quot;Create a string with specified length&quot;,
740              sdslen(x) == 2 &amp;&amp; memcmp(x,&quot;fo\0&quot;,3) == 0)
741          x = sdscat(x,&quot;bar&quot;);
742          test_cond(&quot;Strings concatenation&quot;,
743              sdslen(x) == 5 &amp;&amp; memcmp(x,&quot;fobar\0&quot;,6) == 0);
744          x = sdscpy(x,&quot;a&quot;);
745          test_cond(&quot;sdscpy() against an originally longer string&quot;,
746              sdslen(x) == 1 &amp;&amp; memcmp(x,&quot;a\0&quot;,2) == 0)
747          x = sdscpy(x,&quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk&quot;);
748          test_cond(&quot;sdscpy() against an originally shorter string&quot;,
749              sdslen(x) == 33 &amp;&amp;
750              memcmp(x,&quot;xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0&quot;,33) == 0)
751          sdsfree(x);
752          x = sdscatprintf(sdsempty(),&quot;%d&quot;,123);
753          test_cond(&quot;sdscatprintf() seems working in the base case&quot;,
754              sdslen(x) == 3 &amp;&amp; memcmp(x,&quot;123\0&quot;,4) == 0)
755          sdsfree(x);
756          x = sdsnew(&quot;--&quot;);
757          x = sdscatfmt(x, &quot;Hello %s World %I,%I--&quot;, &quot;Hi!&quot;, LLONG_MIN,LLONG_MAX);
758          test_cond(&quot;sdscatfmt() seems working in the base case&quot;,
759              sdslen(x) == 60 &amp;&amp;
760              memcmp(x,&quot;--Hello Hi! World -9223372036854775808,&quot;
761                       &quot;9223372036854775807--&quot;,60) == 0)
762          printf(&quot;[%s]\n&quot;,x);
763          sdsfree(x);
764          x = sdsnew(&quot;--&quot;);
765          x = sdscatfmt(x, &quot;%u,%U--&quot;, UINT_MAX, ULLONG_MAX);
766          test_cond(&quot;sdscatfmt() seems working with unsigned numbers&quot;,
767              sdslen(x) == 35 &amp;&amp;
768              memcmp(x,&quot;--4294967295,18446744073709551615--&quot;,35) == 0)
769          sdsfree(x);
770          x = sdsnew(&quot; x &quot;);
771          sdstrim(x,&quot; x&quot;);
772          test_cond(&quot;sdstrim() works when all chars match&quot;,
773              sdslen(x) == 0)
774          sdsfree(x);
775          x = sdsnew(&quot; x &quot;);
776          sdstrim(x,&quot; &quot;);
777          test_cond(&quot;sdstrim() works when a single char remains&quot;,
778              sdslen(x) == 1 &amp;&amp; x[0] == &#x27;x&#x27;)
779          sdsfree(x);
780          x = sdsnew(&quot;xxciaoyyy&quot;);
781          sdstrim(x,&quot;xy&quot;);
782          test_cond(&quot;sdstrim() correctly trims characters&quot;,
783              sdslen(x) == 4 &amp;&amp; memcmp(x,&quot;ciao\0&quot;,5) == 0)
784          y = sdsdup(x);
785          sdsrange(y,1,1);
786          test_cond(&quot;sdsrange(...,1,1)&quot;,
787              sdslen(y) == 1 &amp;&amp; memcmp(y,&quot;i\0&quot;,2) == 0)
788          sdsfree(y);
789          y = sdsdup(x);
790          sdsrange(y,1,-1);
791          test_cond(&quot;sdsrange(...,1,-1)&quot;,
792              sdslen(y) == 3 &amp;&amp; memcmp(y,&quot;iao\0&quot;,4) == 0)
793          sdsfree(y);
794          y = sdsdup(x);
795          sdsrange(y,-2,-1);
796          test_cond(&quot;sdsrange(...,-2,-1)&quot;,
797              sdslen(y) == 2 &amp;&amp; memcmp(y,&quot;ao\0&quot;,3) == 0)
798          sdsfree(y);
799          y = sdsdup(x);
800          sdsrange(y,2,1);
801          test_cond(&quot;sdsrange(...,2,1)&quot;,
802              sdslen(y) == 0 &amp;&amp; memcmp(y,&quot;\0&quot;,1) == 0)
803          sdsfree(y);
804          y = sdsdup(x);
805          sdsrange(y,1,100);
806          test_cond(&quot;sdsrange(...,1,100)&quot;,
807              sdslen(y) == 3 &amp;&amp; memcmp(y,&quot;iao\0&quot;,4) == 0)
808          sdsfree(y);
809          y = sdsdup(x);
810          sdsrange(y,100,100);
811          test_cond(&quot;sdsrange(...,100,100)&quot;,
812              sdslen(y) == 0 &amp;&amp; memcmp(y,&quot;\0&quot;,1) == 0)
813          sdsfree(y);
814          sdsfree(x);
815          x = sdsnew(&quot;foo&quot;);
816          y = sdsnew(&quot;foa&quot;);
817          test_cond(&quot;sdscmp(foo,foa)&quot;, sdscmp(x,y) &gt; 0)
818          sdsfree(y);
819          sdsfree(x);
820          x = sdsnew(&quot;bar&quot;);
821          y = sdsnew(&quot;bar&quot;);
822          test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x,y) == 0)
823          sdsfree(y);
824          sdsfree(x);
825          x = sdsnew(&quot;aar&quot;);
826          y = sdsnew(&quot;bar&quot;);
827          test_cond(&quot;sdscmp(bar,bar)&quot;, sdscmp(x,y) &lt; 0)
828          sdsfree(y);
829          sdsfree(x);
830          x = sdsnewlen(&quot;\a\n\0foo\r&quot;,7);
831          y = sdscatrepr(sdsempty(),x,sdslen(x));
832          test_cond(&quot;sdscatrepr(...data...)&quot;,
833              memcmp(y,&quot;\&quot;\\a\\n\\x00foo\\r\&quot;&quot;,15) == 0)
834          {
835              unsigned int oldfree;
836              char *p;
837              int step = 10, j, i;
838              sdsfree(x);
839              sdsfree(y);
840              x = sdsnew(&quot;0&quot;);
841              test_cond(&quot;sdsnew() free/len buffers&quot;, sdslen(x) == 1 &amp;&amp; sdsavail(x) == 0);
842              for (i = 0; i &lt; 10; i++) {
843                  int oldlen = sdslen(x);
844                  x = sdsMakeRoomFor(x,step);
845                  int type = x[-1]&amp;SDS_TYPE_MASK;
846                  test_cond(&quot;sdsMakeRoomFor() len&quot;, sdslen(x) == oldlen);
847                  if (type != SDS_TYPE_5) {
848                      test_cond(&quot;sdsMakeRoomFor() free&quot;, sdsavail(x) &gt;= step);
849                      oldfree = sdsavail(x);
850                  }
851                  p = x+oldlen;
852                  for (j = 0; j &lt; step; j++) {
853                      p[j] = &#x27;A&#x27;+j;
854                  }
855                  sdsIncrLen(x,step);
856              }
857              test_cond(&quot;sdsMakeRoomFor() content&quot;,
858                  memcmp(&quot;0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ&quot;,x,101) == 0);
859              test_cond(&quot;sdsMakeRoomFor() final length&quot;,sdslen(x)==101);
860              sdsfree(x);
861          }
862      }
863      test_report()
864      return 0;
865  }
866  #endif
867  #ifdef SDS_TEST_MAIN
868  int main(void) {
869      return sdsTest();
870  }
871  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hyperloglog.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sds_35.c</div>
                </div>
                <div class="column column_space"><pre><code>505                  i += (int)runlen;                                               WIN_PORT_FIX &amp;bsol;* cast (int) */
506                  p++;
</pre></code></div>
                <div class="column column_space"><pre><code>410                      i += (int)l;                                                WIN_PORT_FIX &amp;bsol;* cast (int) */
411                  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    