<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imjournal.c &amp; imfile.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imjournal.c &amp; imfile.c
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imjournal.c (10.493827%)<th>imfile.c (3.492194%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(94-118)<td><a href="#" name="0">(339-369)</a><td align="center"><font color="#ff0000">36</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1019-1037)<td><a href="#" name="1">(2094-2112)</a><td align="center"><font color="#aa0000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(892-904)<td><a href="#" name="2">(1891-1902)</a><td align="center"><font color="#5c0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1041-1045)<td><a href="#" name="3">(2112-2117)</a><td align="center"><font color="#550000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imjournal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;dirent.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;stdlib.h&gt;
10 #include &lt;time.h&gt;
11 #include &lt;sys/poll.h&gt;
12 #include &lt;sys/socket.h&gt;
13 #include &lt;errno.h&gt;
14 #include &lt;systemd/sd-journal.h&gt;
15 #include "dirty.h"
16 #include "cfsysline.h"
17 #include "obj.h"
18 #include "msg.h"
19 #include "module-template.h"
20 #include "datetime.h"
21 #include "net.h"
22 #include "glbl.h"
23 #include "statsobj.h"
24 #include "parser.h"
25 #include "prop.h"
26 #include "errmsg.h"
27 #include "srUtils.h"
28 #include "unicode-helper.h"
29 #include "ratelimit.h"
30 MODULE_TYPE_INPUT
31 MODULE_TYPE_NOKEEP
32 MODULE_CNFNAME("imjournal")
33 DEF_IMOD_STATIC_DATA
34 DEFobjCurrIf(datetime)
35 DEFobjCurrIf(glbl)
36 DEFobjCurrIf(parser)
37 DEFobjCurrIf(prop)
38 DEFobjCurrIf(net)
39 DEFobjCurrIf(statsobj)
40 struct modConfData_s {
41 	rsconf_t *pConf;
42 	int bIgnPrevMsg;
43 };
44 static struct configSettings_s {
45 	char *stateFile;
46 	int iPersistStateInterval;
47 	unsigned int ratelimitInterval;
48 	unsigned int ratelimitBurst;
49 	int bIgnorePrevious;
50 	int bIgnoreNonValidStatefile;
51 	int iDfltSeverity;
52 	int iDfltFacility;
53 	int bUseJnlPID;
54 	char *usePid;
55 	int bWorkAroundJournalBug; 	int bFsync;
56 	int bRemote;
57 } cs;
58 static rsRetVal facilityHdlr(uchar **pp, void *pVal);
59 <a name="0"></a>
60 static struct cnfparamdescr modpdescr[] = {
61 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "statefile", eCmdHdlrGetWord, 0 },
62 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
63 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
64 	{ "persiststateinterval", eCmdHdlrInt, 0 },
65 	{ "ignorepreviousmessages", eCmdHdlrBinary, 0 },
66 	{ "ignorenonvalidstatefile", eCmdHdlrBinary, 0 },
67 	{ "defaultseverity", eCmdHdlrSeverity, 0 },
68 	{ "defaultfacility", eCmdHdlrString, 0 },
69 	{ "usepidfromsystem", eCmdHdlrBinary, 0 },
70 	{ "usepid", eCmdHdlrString, 0 },
71 	{ "workaroundjournalbug", eCmdHdlrBinary, 0 },
72 	{ "fsync", eCmdHdlrBinary, 0 },
73 	{ "remote", eCmdHdlrBinary, 0 }
74 };
75 static struct cnfparamblk modpblk =
76 	{ CNFPARAMBLK_VERSION,
77 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
78 	  modpdescr
79 	};
80 #define DFLT_persiststateinterval 10
81 #define DFLT_SEVERITY pri2sev(LOG_NOTICE)
82 #define DFLT_FACILITY pri2fac(LOG_USER)
83 static int bLegacyCnfModGlobalsPermitted = 1;
84 static prop_t *pInputName = NULL;
85 static prop_t *pLocalHostIP = NULL;	static const char *pidFieldName;	static int bPidFallBack;
86 static ratelimit_t *ratelimiter = NULL;
87 static struct {
88 	statsobj_t *stats;
89 	STATSCOUNTER_DEF(ctrSubmitted, mutCtrSubmitted)
90 	STATSCOUNTER_DEF(ctrRead, mutCtrRead);
91 	STATSCOUNTER_DEF(ctrDiscarded, mutCtrDiscarded);
92 	STATSCOUNTER_DEF(ctrFailed, mutCtrFailed);
93 	STATSCOUNTER_DEF(ctrPollFailed, mutCtrPollFailed);
94 	STATSCOUNTER_DEF(ctrRotations, mutCtrRotations);
95 	STATSCOUNTER_DEF(ctrRecoveryAttempts, mutCtrRecoveryAttempts);
96 	uint64 ratelimitDiscardedInInterval;
97 	uint64 diskUsageBytes;
98 } statsCounter;
99 struct journalContext_s { 	sd_journal *j; 	sbool reloaded; 	sbool atHead; 	char *cursor; };
100 static struct journalContext_s journalContext = {NULL, 0, 1, NULL};
101 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
102 #define J_PROCESS_PERIOD 1024  
103 static rsRetVal persistJournalState(void);
104 static rsRetVal loadJournalState(void);
105 static rsRetVal openJournal(void) {
106 	int r;
107 	DEFiRet;
108 	if (journalContext.j) {
109 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imjournal: opening journal when already opened.\n");
110 	}
111 	if ((r = sd_journal_open(&amp;journalContext.j, cs.bRemote? 0 : SD_JOURNAL_LOCAL_ONLY)) &lt; 0) {
112 		LogError(-r, RS_RET_IO_ERROR, "imjournal: sd_journal_open() failed");
113 		iRet = RS_RET_IO_ERROR;
114 	}
115 	if ((r = sd_journal_set_data_threshold(journalContext.j, glbl.GetMaxLine(runModConf-&gt;pConf))) &lt; 0) {
116 		LogError(-r, RS_RET_IO_ERROR, "imjournal: sd_journal_set_data_threshold() failed");
117 		iRet = RS_RET_IO_ERROR;
118 	}
119 	journalContext.atHead = 1;
120 	RETiRet;
121 }
122 static void closeJournal(void) {
123 	if (!journalContext.j) {
124 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imjournal: closing NULL journal.\n");
125 	}
126 	sd_journal_close(journalContext.j);
127 	journalContext.j = NULL; }
128 static int journalGetData(const char *field, const void **data, size_t *length)
129 {
130 	int ret;
131 	ret = sd_journal_get_data(journalContext.j, field, data, length);
132 	if (ret == -EADDRNOTAVAIL) {
133 		LogError(-ret, RS_RET_ERR, "imjournal: Tried to get data without a 'next' call.\n");
134 		if ((ret = sd_journal_next(journalContext.j)) &lt; 0) {
135 			LogError(-ret, RS_RET_ERR, "imjournal: sd_journal_next() failed\n");
136 		} else {
137 			ret = sd_journal_get_data(journalContext.j, field, data, length);
138 		}
139 	}
140 	return ret;
141 }
142 static rsRetVal facilityHdlr(uchar **pp, void *pVal)
143 {
144 	DEFiRet;
145 	char *p;
146 	skipWhiteSpace(pp);
147 	p = (char *) *pp;
148 	if (isdigit((int) *p)) {
149 		*((int *) pVal) = (int) strtol(p, (char **) pp, 10);
150 	} else {
151 		int len;
152 		syslogName_t *c;
153 		for (len = 0; p[len] &amp;&amp; !isspace((int) p[len]); len++)
154 		for (c = syslogFacNames; c-&gt;c_name; c++) {
155 			if (!strncasecmp(p, (char *) c-&gt;c_name, len)) {
156 				*((int *) pVal) = pri2fac(c-&gt;c_val);
157 				break;
158 			}
159 		}
160 		*pp += len;
161 	}
162 	RETiRet;
163 }
164 static rsRetVal
165 sanitizeValue(const char *in, size_t len, char **out)
166 {
167 	char *buf, *p;
168 	DEFiRet;
169 	CHKmalloc(p = buf = malloc(len + 1));
170 	memcpy(buf, in, len);
171 	buf[len] = '\0';
172 	while ((p = memchr(p, '\0', len + buf - p)) != NULL) {
173 		*p++ = ' ';
174 	}
175 	*out = buf;
176 finalize_it:
177 	RETiRet;
178 }
179 static rsRetVal
180 readJSONfromJournalMsg(struct fjson_object **json)
181 {
182 	DEFiRet;
183 	const void *get;
184 	const void *equal_sign;
185 	struct fjson_object *jval;
186 	size_t l;
187 	long prefixlen = 0;
188 	CHKmalloc(*json = fjson_object_new_object());
189 	SD_JOURNAL_FOREACH_DATA(journalContext.j, get, l) {
190 		char *data;
191 		char *name;
192 		equal_sign = memchr(get, '=', l);
193 		if (equal_sign == NULL) {
194 			LogError(0, RS_RET_ERR, "SD_JOURNAL_FOREACH_DATA()"
195 				"returned a malformed field (has no '='): '%s'", (char*)get);
196 			continue; 		}
197 		prefixlen = ((char *)equal_sign - (char *)get);
198 		CHKmalloc(name = strndup(get, prefixlen));
199 		prefixlen++; 
200 		CHKiRet_Hdlr(sanitizeValue(((const char *)get) + prefixlen, l - prefixlen, &amp;data)) {
201 			free (name);
202 			FINALIZE;
203 		}
204 		jval = fjson_object_new_string((char *)data);
205 		fjson_object_object_add(*json, name, jval);
206 		free (data);
207 		free (name);
208 	}
209 finalize_it:
210 	RETiRet;
211 }
212 static rsRetVal
213 updateJournalCursor(void)
214 {
215 	DEFiRet;
216 	char *c = NULL;
217 	int r;
218 	if ((r = sd_journal_get_cursor(journalContext.j, &amp;c)) &lt; 0) {
219 		LogError(-r, RS_RET_ERR, "imjournal: Could not get journald cursor!\n");
220 		ABORT_FINALIZE(RS_RET_ERR);
221 	}
222 	free(journalContext.cursor);
223 	journalContext.cursor = c;
224 finalize_it:
225 	RETiRet;
226 }
227 static rsRetVal
228 enqMsg(uchar *msg, uchar *pszTag, int iFacility, int iSeverity, struct timeval *tp, struct fjson_object *json,
229 int sharedJsonProperties)
230 {
231 	struct syslogTime st;
232 	smsg_t *pMsg;
233 	size_t len;
234 	DEFiRet;
235 	assert(msg != NULL);
236 	assert(pszTag != NULL);
237 	if(tp == NULL) {
238 		CHKiRet(msgConstruct(&amp;pMsg));
239 	} else {
240 		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
241 		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
242 	}
243 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
244 	MsgSetInputName(pMsg, pInputName);
245 	len = strlen((char*)msg);
246 	MsgSetRawMsg(pMsg, (char*)msg, len);
247 	if(len &gt; 0)
248 		parser.SanitizeMsg(pMsg);
249 	MsgSetMSGoffs(pMsg, 0);		MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
250 	MsgSetRcvFromIP(pMsg, pLocalHostIP);
251 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
252 	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
253 	pMsg-&gt;iFacility = iFacility;
254 	pMsg-&gt;iSeverity = iSeverity;
255 	if(json != NULL) {
256 		msgAddJSON(pMsg, (uchar*)"!", json, 0, sharedJsonProperties);
257 	}
258 	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
259 	STATSCOUNTER_INC(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
260 finalize_it:
261 	if (iRet == RS_RET_DISCARDMSG) {
262 		STATSCOUNTER_INC(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
263 	} else if (iRet != RS_RET_OK) {
264 		LogError(0, RS_RET_ERR, "imjournal: error during enqMsg().\n");
265 	}
266 	RETiRet;
267 }
268 static rsRetVal
269 readjournal(void)
270 {
271 	DEFiRet;
272 	struct timeval tv;
273 	uint64_t timestamp;
274 	struct fjson_object *json = NULL;
275 	int r;
276 	char *message = NULL;
277 	char *sys_iden;
278 	char *sys_iden_help = NULL;
279 	const void *get;
280 	const void *pidget;
281 	size_t length;
282 	size_t pidlength;
283 	int severity = cs.iDfltSeverity;
284 	int facility = cs.iDfltFacility;
285 	if (journalGetData("MESSAGE", &amp;get, &amp;length) &lt; 0) {
286 		CHKmalloc(message = strdup(""));
287 	} else {
288 		CHKiRet(sanitizeValue(((const char *)get) + 8, length - 8, &amp;message));
289 	}
290 	STATSCOUNTER_INC(statsCounter.ctrRead, statsCounter.mutCtrRead);
291 	if (journalGetData("PRIORITY", &amp;get, &amp;length) &gt;= 0) {
292 		if (length == 10) {
293 			severity = ((char *)get)[9] - '0';
294 			if (severity &lt; 0 || 7 &lt; severity) {
295 				LogError(0, RS_RET_ERR, "imjournal: the value of the 'PRIORITY' field is "
296 					"out of bounds: %d, resetting", severity);
297 				severity = cs.iDfltSeverity;
298 			}
299 		} else {
300 			LogError(0, RS_RET_ERR, "The value of the 'PRIORITY' field has an "
301 				"unexpected length: %zu\n", length);
302 		}
303 	}
304 	if (journalGetData("SYSLOG_FACILITY", &amp;get, &amp;length) &gt;= 0) {
305 		if (length == 17 || length == 18) {
306 			facility = ((char *)get)[16] - '0';
307 			if (length == 18) {
308 				facility *= 10;
309 				facility += ((char *)get)[17] - '0';
310 			}
311 			if (facility &lt; 0 || 23 &lt; facility) {
312 				DBGPRINTF("The value of the 'FACILITY' field is "
313 					"out of bounds: %d, resetting\n", facility);
314 				facility = cs.iDfltFacility;
315 			}
316 		} else {
317 			DBGPRINTF("The value of the 'FACILITY' field has an "
318 				"unexpected length: %zu value: '%s'\n", length, (const char*)get);
319 		}
320 	}
321 	if (journalGetData("SYSLOG_IDENTIFIER", &amp;get, &amp;length) &gt;= 0) {
322 		CHKiRet(sanitizeValue(((const char *)get) + 18, length - 18, &amp;sys_iden));
323 	} else {
324 		CHKmalloc(sys_iden = strdup("journal"));
325 	}
326 	if (journalGetData(pidFieldName, &amp;pidget, &amp;pidlength) &gt;= 0) {
327 		char *sys_pid;
328 		int val_ofs;
329 		val_ofs = strlen(pidFieldName) + 1; 		CHKiRet_Hdlr(sanitizeValue(((const char *)pidget) + val_ofs, pidlength - val_ofs, &amp;sys_pid)) {
330 			free (sys_iden);
331 			FINALIZE;
332 		}
333 		r = asprintf(&amp;sys_iden_help, "%s[%s]:", sys_iden, sys_pid);
334 		free (sys_pid);
335 	} else {
336 		if (bPidFallBack &amp;&amp; journalGetData("_PID", &amp;pidget, &amp;pidlength) &gt;= 0) {
337 			char *sys_pid;
338 			int val_ofs;
339 			val_ofs = strlen("_PID") + 1; 			CHKiRet_Hdlr(sanitizeValue(((const char *)pidget) + val_ofs, pidlength - val_ofs, &amp;sys_pid)) {
340 				free (sys_iden);
341 				FINALIZE;
342 			}
343 			r = asprintf(&amp;sys_iden_help, "%s[%s]:", sys_iden, sys_pid);
344 			free (sys_pid);
345 		} else {
346 			r = asprintf(&amp;sys_iden_help, "%s:", sys_iden);
347 		}
348 	}
349 	free (sys_iden);
350 	if (-1 == r) {
351 		STATSCOUNTER_INC(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
352 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
353 	}
354 	CHKiRet(readJSONfromJournalMsg(&amp;json));
355 	if (sd_journal_get_realtime_usec(journalContext.j, &amp;timestamp) &gt;= 0) {
356 		tv.tv_sec = timestamp / 1000000;
357 		tv.tv_usec = timestamp % 1000000;
358 	}
359 	iRet = updateJournalCursor();
360 	enqMsg((uchar *)message, (uchar *) sys_iden_help, facility, severity, &amp;tv, json, 0);
361 finalize_it:
362 	free(sys_iden_help);
363 	free(message);
364 	RETiRet;
365 }
366 static rsRetVal
367 persistJournalState(void)
368 {
369 	DEFiRet;
370 	FILE *sf = NULL; 	char tmp_sf[MAXFNAME];
371 	DBGPRINTF("Persisting journal position, cursor: %s, at head? %d\n",
372 			  journalContext.cursor, journalContext.atHead);
373 	if (!journalContext.cursor) {
374 		DBGPRINTF("Journal cursor is not valid, ok...\n");
375 		ABORT_FINALIZE(RS_RET_OK);
376 	}
377 #define IM_SF_TMP_SUFFIX ".tmp"
378 	snprintf(tmp_sf, sizeof(tmp_sf), "%.*s%s",
379 			(int)(sizeof(tmp_sf) - sizeof(IM_SF_TMP_SUFFIX)),
380 			cs.stateFile, IM_SF_TMP_SUFFIX);
381 	sf = fopen(tmp_sf, "wb");
382 	if (sf == NULL) {
383 		LogError(errno, RS_RET_FOPEN_FAILURE, "imjournal: fopen() failed for path: '%s'", tmp_sf);
384 		ABORT_FINALIZE(RS_RET_FOPEN_FAILURE);
385 	}
386 	if(fputs(journalContext.cursor, sf) == EOF) {
387 		LogError(errno, RS_RET_IO_ERROR, "imjournal: failed to save cursor to: '%s'", tmp_sf);
388 		ABORT_FINALIZE(RS_RET_IO_ERROR);
389 	}
390 	fflush(sf);
391 	if (rename(tmp_sf, cs.stateFile) &lt; 0) {
392 		LogError(errno, iRet, "imjournal: rename() failed for new path: '%s'", cs.stateFile);
393 		ABORT_FINALIZE(RS_RET_IO_ERROR);
394 	}
395 	if (cs.bFsync) {
396 		if (fsync(fileno(sf)) != 0) {
397 			LogError(errno, RS_RET_IO_ERROR, "imjournal: fsync on '%s' failed", cs.stateFile);
398 			ABORT_FINALIZE(RS_RET_IO_ERROR);
399 		}
400 		DIR *wd;
401 		if (!(wd = opendir((char *)glbl.GetWorkDir(runModConf-&gt;pConf)))) {
402 			LogError(errno, RS_RET_IO_ERROR, "imjournal: failed to open '%s' directory",
403 				glbl.GetWorkDir(runModConf-&gt;pConf));
404 			ABORT_FINALIZE(RS_RET_IO_ERROR);
405 		}
406 		if (fsync(dirfd(wd)) != 0) {
407 			LogError(errno, RS_RET_IO_ERROR, "imjournal: fsync on '%s' failed",
408 				glbl.GetWorkDir(runModConf-&gt;pConf));
409 			ABORT_FINALIZE(RS_RET_IO_ERROR);
410 		}
411 		closedir(wd);
412 	}
413 	DBGPRINTF("Persisted journal to '%s'\n", cs.stateFile);
414 finalize_it:
415 	if (sf != NULL) {
416 		if (fclose(sf) == EOF) {
417 			LogError(errno, RS_RET_IO_ERROR, "imjournal: fclose() failed for path: '%s'", tmp_sf);
418 			iRet = RS_RET_IO_ERROR;
419 		}
420 	}
421 	RETiRet;
422 }
423 static rsRetVal skipOldMessages(void);
424 static rsRetVal
425 handleRotation(void)
426 {
427 	DEFiRet;
428 	int r;
429 	LogMsg(0, RS_RET_OK, LOG_NOTICE, "imjournal: journal files changed, reloading...\n");
430 	STATSCOUNTER_INC(statsCounter.ctrRotations, statsCounter.mutCtrRotations);
431 	closeJournal();
432 	iRet = openJournal();
433 	if (iRet != RS_RET_OK) {
434 		ABORT_FINALIZE(RS_RET_ERR);
435 	}
436 	if (!journalContext.cursor)
437 	{
438 		if (cs.stateFile) {
439 			iRet = loadJournalState();
440 		}
441 		else if (cs.bIgnorePrevious) {
442 			iRet = skipOldMessages();
443 		}
444 		FINALIZE;
445 	}
446 	if (sd_journal_seek_cursor(journalContext.j, journalContext.cursor) != 0) {
447 		LogError(0, RS_RET_ERR, "imjournal: "
448 			"couldn't seek to cursor `%s'\n", journalContext.cursor);
449 		iRet = RS_RET_ERR;
450 	}
451 	journalContext.atHead = 0;
452 	if ((r = sd_journal_next(journalContext.j)) &lt; 0) {
453 		LogError(-r, RS_RET_ERR, "imjournal: sd_journal_next() failed");
454 		iRet = RS_RET_ERR;
455 	}
456 finalize_it:
457 	journalContext.reloaded = 1;
458 	RETiRet;
459 }
460 #define POLL_TIMEOUT 900000 
461 static rsRetVal
462 pollJournal(void)
463 {
464 	DEFiRet;
465 	int err;
466 	err = sd_journal_wait(journalContext.j, POLL_TIMEOUT);
467 	if (err == SD_JOURNAL_INVALIDATE &amp;&amp; !journalContext.reloaded) {
468 		CHKiRet(handleRotation());
469 	}
470 	else {
471 		journalContext.reloaded = 0;
472 	}
473 finalize_it:
474 	RETiRet;
475 }
476 static rsRetVal
477 skipOldMessages(void)
478 {
479 	int r;
480 	DEFiRet;
481 	if ((r = sd_journal_seek_tail(journalContext.j)) &lt; 0) {
482 		LogError(-r, RS_RET_ERR,
483 			"imjournal: sd_journal_seek_tail() failed");
484 		ABORT_FINALIZE(RS_RET_ERR);
485 	}
486 	journalContext.atHead = 0;
487 	if ((r = sd_journal_previous(journalContext.j)) &lt; 0) {
488 		LogError(-r, RS_RET_ERR,
489 			"imjournal: sd_journal_previous() failed");
490 		ABORT_FINALIZE(RS_RET_ERR);
491 	}
492 finalize_it:
493 	RETiRet;
494 }
495 static rsRetVal
496 loadJournalState(void)
497 {
498 	DEFiRet;
499 	int r;
500 	FILE *r_sf;
501 	DBGPRINTF("Loading journal position, at head? %d, reloaded? %d\n",
502 			  journalContext.atHead, journalContext.reloaded);
503 	if (access(cs.stateFile, F_OK|R_OK) == -1 &amp;&amp; errno == ENOENT) {
504 		if (cs.bIgnorePrevious) {
505 			skipOldMessages();
506 		}
507 		LogMsg(errno, RS_RET_FILE_NOT_FOUND, LOG_NOTICE, "imjournal: No statefile exists, "
508 				"%s will be created (ignore if this is first run)", cs.stateFile);
509 		FINALIZE;
510 	}
511 	if ((r_sf = fopen(cs.stateFile, "rb")) != NULL) {
512 		char readCursor[128 + 1];
513 		if (fscanf(r_sf, "%128s\n", readCursor) != EOF) {
514 			if (sd_journal_seek_cursor(journalContext.j, readCursor) != 0) {
515 				LogError(0, RS_RET_ERR, "imjournal: "
516 					"couldn't seek to cursor `%s'\n", readCursor);
517 				iRet = RS_RET_ERR;
518 			} else {
519 				journalContext.atHead = 0;
520 				char * tmp_cursor = NULL;
521 				sd_journal_next(journalContext.j);
522 				if ((r = sd_journal_get_cursor(journalContext.j, &amp;tmp_cursor)) &lt; 0) {
523 					LogError(-r, RS_RET_IO_ERROR, "imjournal: "
524 					"loaded invalid cursor, seeking to the head of journal\n");
525 					if ((r = sd_journal_seek_head(journalContext.j)) &lt; 0) {
526 						LogError(-r, RS_RET_ERR, "imjournal: "
527 						"sd_journal_seek_head() failed, when cursor is invalid\n");
528 						iRet = RS_RET_ERR;
529 					}
530 					journalContext.atHead = 1;
531 				}
532 				free(tmp_cursor);
533 			}
534 		} else {
535 			LogError(0, RS_RET_IO_ERROR, "imjournal: "
536 				"fscanf on state file `%s' failed\n", cs.stateFile);
537 			iRet = RS_RET_IO_ERROR;
538 		}
539 		fclose(r_sf);
540 		if (iRet != RS_RET_OK &amp;&amp; cs.bIgnoreNonValidStatefile) {
541 			iRet = RS_RET_OK;
542 			LogError(0, NO_ERRCODE, "imjournal: ignoring invalid state file %s", cs.stateFile);
543 			if (cs.bIgnorePrevious) {
544 				skipOldMessages();
545 			}
546 		}
547 	} else {
548 		LogError(0, RS_RET_FOPEN_FAILURE, "imjournal: open on state file `%s' failed\n", cs.stateFile);
549 		if (cs.bIgnorePrevious) {
550 			skipOldMessages();
551 		}
552 	}
553 finalize_it:
554 	RETiRet;
555 }
556 static void
557 tryRecover(void) {
558 	LogMsg(0, RS_RET_OK, LOG_INFO, "imjournal: trying to recover from journal error");
559 	STATSCOUNTER_INC(statsCounter.ctrRecoveryAttempts, statsCounter.mutCtrRecoveryAttempts);
560 	closeJournal();
561 	srSleep(0, 200000);		openJournal();
562 }
563 BEGINrunInput
564 	uint64_t count = 0;
565 CODESTARTrunInput
566 	CHKiRet(ratelimitNew(&amp;ratelimiter, "imjournal", NULL));
567 	dbgprintf("imjournal: ratelimiting burst %u, interval %u\n", cs.ratelimitBurst,
568 		  cs.ratelimitInterval);
569 	ratelimitSetLinuxLike(ratelimiter, cs.ratelimitInterval, cs.ratelimitBurst);
570 	ratelimitSetNoTimeCache(ratelimiter);
571 	if (cs.stateFile) {
572 		CHKiRet(loadJournalState());
573 	} else if (cs.bIgnorePrevious) {
574 		skipOldMessages();
575 	}
576 	if (cs.bUseJnlPID != -1) {
577 		free(cs.usePid);
578 		cs.usePid = strdup("system");
579 		LogError(0, RS_RET_DEPRECATED,
580 			"\"usepidfromsystem\" is deprecated, use \"usepid\" instead");
581 	}
582 	if (cs.usePid &amp;&amp; (strcmp(cs.usePid, "system") == 0)) {
583 		pidFieldName = "_PID";
584 		bPidFallBack = 0;
585 	} else if (cs.usePid &amp;&amp; (strcmp(cs.usePid, "syslog") == 0)) {
586 		pidFieldName = "SYSLOG_PID";
587 		bPidFallBack = 0;
588 	} else  {
589 		pidFieldName = "SYSLOG_PID";
590 		bPidFallBack = 1;
591 		if (cs.usePid &amp;&amp; (strcmp(cs.usePid, "both") != 0)) {
592 			LogError(0, RS_RET_OK, "option \"usepid\""
593 				" should contain one of system|syslog|both and no '%s'",cs.usePid);
594 		}
595 	}
596 	while (glbl.GetGlobalInputTermState() == 0) {
597 		int r;
598 		r = sd_journal_next(journalContext.j);
599 		if (r &lt; 0) {
600 			LogError(-r, RS_RET_ERR, "imjournal: sd_journal_next() failed");
601 			tryRecover();
602 			continue;
603 		}
604 		if (r == 0) {
605 			if (journalContext.atHead) {
606 				LogMsg(0, RS_RET_OK, LOG_WARNING, "imjournal: "
607 						"Journal indicates no msgs when positioned at head.\n");
608 			}
609 			if (pollJournal() != RS_RET_OK &amp;&amp; !journalContext.reloaded) {
610 				tryRecover();
611 			}
612 			continue;
613 		}
614 		const int e = sd_journal_get_usage(journalContext.j, (uint64_t *)&amp;statsCounter.diskUsageBytes);
615 		if (e &lt; 0) {
616 			LogError(-e, RS_RET_ERR, "imjournal: sd_get_usage() failed");
617 		}
618 		if (readjournal() != RS_RET_OK) {
619 			tryRecover();
620 			continue;
621 		}
622 		count++;
623 		journalContext.atHead = 0;
624 		if (cs.stateFile) { 			if ((count % cs.iPersistStateInterval) == 0) {
625 				persistJournalState();
626 			}
627 		}
628 	}
629 finalize_it:
630 ENDrunInput
631 <a name="2"></a>
632 BEGINbeginCnfLoad
633 CODESTARTbeginCnfLoad
634 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	loadModConf = pModConf;
635 	pModConf-&gt;pConf = pConf;
636 	bLegacyCnfModGlobalsPermitted = 1;
637 	cs.bIgnoreNonValidStatefile = 1;
638 	cs.iPersistStateInterval = DFLT_persiststateinterval;
639 	cs.stateFile = NULL;
640 	cs.ratelimitBurst = 20000;
641 	cs.ratelimitInterval = 600;
642 	cs.iDfltSeverity = DFLT_SEVERITY;
643 	cs.iDfltFacility = DFLT_FACILITY;
644 	cs.bUseJnlPID = -1;
645 	cs.usePid = NULL;</b></font>
646 	cs.bWorkAroundJournalBug = 1;
647 	cs.bFsync = 0;
648 	cs.bRemote = 0;
649 ENDbeginCnfLoad
650 BEGINendCnfLoad
651 CODESTARTendCnfLoad
652 	if(cs.stateFile != NULL &amp;&amp; cs.stateFile[0] != '/') {
653 		char *new_stateFile;
654 		if (-1 == asprintf(&amp;new_stateFile, "%s/%s",
655 			(char *)glbl.GetWorkDir(loadModConf-&gt;pConf), cs.stateFile)) {
656 				LogError(0, RS_RET_OUT_OF_MEMORY, "imjournal: asprintf failed\n");
657 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
658 		}
659 		free (cs.stateFile);
660 		cs.stateFile = new_stateFile;
661 	}
662 finalize_it:
663 ENDendCnfLoad
664 BEGINcheckCnf
665 CODESTARTcheckCnf
666 ENDcheckCnf
667 BEGINactivateCnf
668 CODESTARTactivateCnf
669 	runModConf = pModConf;
670 	CHKiRet(statsobj.Construct(&amp;(statsCounter.stats)));
671 	CHKiRet(statsobj.SetName(statsCounter.stats, (uchar*)"imjournal"));
672 	CHKiRet(statsobj.SetOrigin(statsCounter.stats, (uchar*)"imjournal"));
673 	STATSCOUNTER_INIT(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
674 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("submitted"),
675 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrSubmitted)));
676 	STATSCOUNTER_INIT(statsCounter.ctrRead, statsCounter.mutCtrRead);
677 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("read"),
678 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRead)));
679 	STATSCOUNTER_INIT(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
680 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("discarded"),
681 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrDiscarded)));
682 	STATSCOUNTER_INIT(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
683 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("failed"),
684 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrFailed)));
685 	STATSCOUNTER_INIT(statsCounter.ctrPollFailed, statsCounter.mutCtrPollFailed);
686 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("poll_failed"),
687 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrPollFailed)));
688 	STATSCOUNTER_INIT(statsCounter.ctrRotations, statsCounter.mutCtrRotations);
689 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("rotations"),
690 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRotations)));
691 	STATSCOUNTER_INIT(statsCounter.ctrRecoveryAttempts, statsCounter.mutCtrRecoveryAttempts);
692 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("recovery_attempts"),
693 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRecoveryAttempts)));
694 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("ratelimit_discarded_in_interval"),
695 	                ctrType_Int, CTR_FLAG_NONE, &amp;(statsCounter.ratelimitDiscardedInInterval)));
696 	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("disk_usage_bytes"),
697 	                ctrType_Int, CTR_FLAG_NONE, &amp;(statsCounter.diskUsageBytes)));
698 	CHKiRet(statsobj.ConstructFinalize(statsCounter.stats));
699 finalize_it:
700 ENDactivateCnf
701 BEGINfreeCnf
702 CODESTARTfreeCnf
703 	free(cs.stateFile);
704 	free(cs.usePid);
705 	free(journalContext.cursor);
706 	statsobj.Destruct(&amp;(statsCounter.stats));
707 ENDfreeCnf
708 BEGINwillRun
709 CODESTARTwillRun
710 	iRet = openJournal();
711 ENDwillRun
712 BEGINafterRun
713 CODESTARTafterRun
714 	if (cs.stateFile) { 		persistJournalState();
715 	}
716 	closeJournal();
717 	ratelimitDestruct(ratelimiter);
718 ENDafterRun
719 BEGINmodExit
720 CODESTARTmodExit
721 	if(pInputName != NULL)
722 		prop.Destruct(&amp;pInputName);
723 	if(pLocalHostIP != NULL)
724 		prop.Destruct(&amp;pLocalHostIP);
725 	objRelease(statsobj, CORE_COMPONENT);
726 	objRelease(glbl, CORE_COMPONENT);
727 	objRelease(net, CORE_COMPONENT);
728 	objRelease(datetime, CORE_COMPONENT);
729 	objRelease(parser, CORE_COMPONENT);
730 	objRelease(prop, CORE_COMPONENT);
731 ENDmodExit
732 BEGINsetModCnf
733 <a name="1"></a>	struct cnfparamvals *pvals = NULL;
734 	int i;
735 CODESTARTsetModCnf
736 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
737 	if (pvals == NULL) {
738 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
739 				"config parameters [module(...)]");
740 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
741 	}
742 	if (Debug) {
743 		dbgprintf("module (global) param blk for imjournal:\n");
744 		cnfparamsPrint(&amp;modpblk, pvals);
745 	}
746 	for (i = 0 ; i &lt; modpblk.nParams ; ++i) {
747 		if (!pvals[i].bUsed)
748 			continue;
749 		if (!strcmp(modpblk.descr[i].name, "persiststateinterval")) {
750 			cs.iPersistStateInterval = (int) pvals[i].val.d.n;
751 		} else if (!strcmp(modpblk.descr[i].name, "statefile")) {
752 			cs.stateFile = (char *)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
753 <a name="3"></a>		} else if(!strcmp(modpblk.descr[i].name, "ratelimit.burst")) {
754 			cs.ratelimitBurst = (unsigned int) pvals[i].val.d.n;
755 		} else if(!strcmp(modpblk.descr[i].name, "ratelimit.interval")) {
756 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			cs.ratelimitInterval = (unsigned int) pvals[i].val.d.n;
757 		} else if (!strcmp(modpblk.descr[i].name, "ignorepreviousmessages")) {
758 			cs.bIgnorePrevious = (int) pvals[i].val.d.n;
759 		} else if (!strcmp(modpblk.descr[i].name, "ignorenonvalidstatefile")) {
760 			cs.bIgnoreNonValidStatefile = (int) pvals[i].val.d.n;</b></font>
761 		} else if (!strcmp(modpblk.descr[i].name, "defaultseverity")) {
762 			cs.iDfltSeverity = (int) pvals[i].val.d.n;
763 		} else if (!strcmp(modpblk.descr[i].name, "defaultfacility")) {
764 			char *fac, *p;
765 			fac = p = es_str2cstr(pvals[i].val.d.estr, NULL);
766 			facilityHdlr((uchar **) &amp;p, (void *) &amp;cs.iDfltFacility);
767 			free(fac);
768 		} else if (!strcmp(modpblk.descr[i].name, "usepidfromsystem")) {
769 			cs.bUseJnlPID = (int) pvals[i].val.d.n;
770 		} else if (!strcmp(modpblk.descr[i].name, "usepid")) {
771 			cs.usePid = (char *)es_str2cstr(pvals[i].val.d.estr, NULL);
772 		} else if (!strcmp(modpblk.descr[i].name, "workaroundjournalbug")) {
773 			cs.bWorkAroundJournalBug = (int) pvals[i].val.d.n;
774 		} else if (!strcmp(modpblk.descr[i].name, "fsync")) {
775 			cs.bFsync = (int) pvals[i].val.d.n;
776 		} else if (!strcmp(modpblk.descr[i].name, "remote")) {
777 			cs.bRemote = (int) pvals[i].val.d.n;
778 		} else {
779 			dbgprintf("imjournal: program error, non-handled "
780 				"param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
781 		}
782 	}
783 finalize_it:
784 	if (pvals != NULL)
785 		cnfparamvalsDestruct(pvals, &amp;modpblk);
786 ENDsetModCnf
787 BEGINisCompatibleWithFeature
788 CODESTARTisCompatibleWithFeature
789 	if(eFeat == sFEATURENonCancelInputTermination)
790 		iRet = RS_RET_OK;
791 ENDisCompatibleWithFeature
792 BEGINqueryEtryPt
793 CODESTARTqueryEtryPt
794 CODEqueryEtryPt_STD_IMOD_QUERIES
795 CODEqueryEtryPt_STD_CONF2_QUERIES
796 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
797 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
798 ENDqueryEtryPt
799 BEGINmodInit()
800 CODESTARTmodInit
801 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
802 	CHKiRet(objUse(datetime, CORE_COMPONENT));
803 	CHKiRet(objUse(glbl, CORE_COMPONENT));
804 	CHKiRet(objUse(parser, CORE_COMPONENT));
805 	CHKiRet(objUse(prop, CORE_COMPONENT));
806 	CHKiRet(objUse(net, CORE_COMPONENT));
807 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
808 	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT("imjournal"), sizeof("imjournal") - 1));
809 	CHKiRet(prop.CreateStringProp(&amp;pLocalHostIP, UCHAR_CONSTANT("127.0.0.1"), sizeof("127.0.0.1") - 1));
810 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalpersiststateinterval", 0, eCmdHdlrInt,
811 		NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
812 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalratelimitinterval", 0, eCmdHdlrInt,
813 		NULL, &amp;cs.ratelimitInterval, STD_LOADABLE_MODULE_ID));
814 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalratelimitburst", 0, eCmdHdlrInt,
815 		NULL, &amp;cs.ratelimitBurst, STD_LOADABLE_MODULE_ID));
816 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalstatefile", 0, eCmdHdlrGetWord,
817 		NULL, &amp;cs.stateFile, STD_LOADABLE_MODULE_ID));
818 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalignorepreviousmessages", 0, eCmdHdlrBinary,
819 		NULL, &amp;cs.bIgnorePrevious, STD_LOADABLE_MODULE_ID));
820 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournaldefaultseverity", 0, eCmdHdlrSeverity,
821 		NULL, &amp;cs.iDfltSeverity, STD_LOADABLE_MODULE_ID));
822 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournaldefaultfacility", 0, eCmdHdlrCustomHandler,
823 		facilityHdlr, &amp;cs.iDfltFacility, STD_LOADABLE_MODULE_ID));
824 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"imjournalusepidfromsystem", 0, eCmdHdlrBinary,
825 		NULL, &amp;cs.bUseJnlPID, STD_LOADABLE_MODULE_ID));
826 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;pthread.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;time.h&gt;
12 #include &lt;glob.h&gt;
13 #include &lt;poll.h&gt;
14 #include &lt;json.h&gt;
15 #include &lt;fnmatch.h&gt;
16 #ifdef HAVE_SYS_INOTIFY_H
17 #include &lt;sys/inotify.h&gt;
18 #include &lt;linux/types.h&gt;
19 #endif
20 #ifdef HAVE_SYS_STAT_H
21 #	include &lt;sys/stat.h&gt;
22 #endif
23 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
24 #include &lt;port.h&gt;
25 #include &lt;sys/port.h&gt;
26 #endif
27 #include "rsyslog.h"		#include "dirty.h"
28 #include "cfsysline.h"		#include "module-template.h"	#include "srUtils.h"		#include "msg.h"
29 #include "stream.h"
30 #include "errmsg.h"
31 #include "glbl.h"
32 #include "unicode-helper.h"
33 #include "prop.h"
34 #include "stringbuf.h"
35 #include "ruleset.h"
36 #include "ratelimit.h"
37 #include "srUtils.h"
38 #include "parserif.h"
39 #include "datetime.h"
40 #include &lt;regex.h&gt;
41 #ifndef O_LARGEFILE
42 #  define O_LARGEFILE 0
43 #endif
44 #ifndef HAVE_LSEEK64
45 #  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
46 #endif
47 MODULE_TYPE_INPUT
48 MODULE_TYPE_NOKEEP
49 MODULE_CNFNAME("imfile")
50 #define FILE_ID_HASH_SIZE 20	#define FILE_ID_SIZE	512	
51 DEF_IMOD_STATIC_DATA	DEFobjCurrIf(glbl)
52 DEFobjCurrIf(strm)
53 DEFobjCurrIf(prop)
54 DEFobjCurrIf(ruleset)
55 DEFobjCurrIf(datetime)
56 extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
57 	uint8_t *out, const size_t outlen); 
58 static int bLegacyCnfModGlobalsPermitted;
59 #define NUM_MULTISUB 1024 #define DFLT_PollInterval 10
60 #define INIT_WDMAP_TAB_SIZE 1 #define ADD_METADATA_UNSPECIFIED -1
61 #define ULTRA_DEBUG 0
62 #ifndef GLOB_BRACE
63 	#define GLOB_BRACE 0
64 #endif
65 typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;
66 struct per_minute_rate_limit_s {
67 	uint64_t maxBytesPerMinute;
68 	uint32_t maxLinesPerMinute;
69 	uint64_t bytesThisMinute; 	uint32_t linesThisMinute; 	time_t rateLimitingMinute; };
70 static struct configSettings_s {
71 	uchar *pszFileName;
72 	uchar *pszFileTag;
73 	uchar *pszStateFile;
74 	uchar *pszBindRuleset;
75 	int iPollInterval;
76 	int iPersistStateInterval;		int bPersistStateAfterSubmission;	int iFacility; 	int iSeverity;  	int readMode;  	int64 maxLinesAtOnce;		uint64_t maxBytesPerMinute; 	uint64_t maxLinesPerMinute; 	uint32_t trimLineOverBytes;  } cs;
77 struct instanceConf_s {
78 	uchar *pszFileName;
79 	uchar *pszFileName_forOldStateFile; 	uchar *pszDirName;
80 	uchar *pszFileBaseName;
81 	uchar *pszTag;
82 	size_t lenTag;
83 	uchar *pszStateFile;
84 	uchar *pszBindRuleset;
85 	int nMultiSub;
86 	per_minute_rate_limit_t perMinuteRateLimits;
87 	int iPersistStateInterval;
88 	int bPersistStateAfterSubmission;
89 	int iFacility;
90 	int iSeverity;
91 	int readTimeout;
92 	unsigned delay_perMsg;
93 	sbool bRMStateOnDel;
94 	uint8_t readMode;
95 	uchar *startRegex;
96 	uchar *endRegex;
97 	regex_t start_preg;		regex_t end_preg;		sbool discardTruncatedMsg;
98 	sbool msgDiscardingError;
99 	sbool escapeLF;
100 	sbool reopenOnTruncate;
101 	sbool addCeeTag;
102 	sbool addMetadata;
103 	sbool freshStartTail;
104 	sbool fileNotFoundError;
105 	int maxLinesAtOnce;
106 	uint32_t trimLineOverBytes;
107 	uint32_t ignoreOlderThan;
108 	int msgFlag;
109 	uchar *escapeLFString;
110 	ruleset_t *pBindRuleset;		struct instanceConf_s *next;
111 };
112 typedef struct fs_edge_s fs_edge_t;
113 typedef struct fs_node_s fs_node_t;
114 typedef struct act_obj_s act_obj_t;
115 struct act_obj_s {
116 	act_obj_t *prev;
117 	act_obj_t *next;
118 	fs_edge_t *edge;		char *name;			char *basename;			char *source_name;		int wd;
119 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
120 	struct fileinfo *pfinf;
121 	sbool bPortAssociated;
122 	int is_deleted;	#endif
123 	ratelimit_t *ratelimiter;
124 	multi_submit_t multiSub;
125 	int is_symlink;
126 };
127 struct fs_edge_s {
128 	fs_node_t *parent;		fs_node_t *node;		fs_edge_t *next;
129 	uchar *name;
130 	uchar *path;
131 	act_obj_t *active;
132 	int is_file;
133 	int ninst;			instanceConf_t **instarr;
134 };
135 struct fs_node_s {
136 	fs_edge_t *edges;		fs_node_t *root;	};
137 static rsRetVal persistStrmState(act_obj_t *);
138 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
139 static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
140 static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
141 static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
142 static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
143 static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
144 	uchar *const pszout, const size_t ilenout);
145 #define OPMODE_POLLING 0
146 #define OPMODE_INOTIFY 1
147 #define OPMODE_FEN 2
148 struct modConfData_s {
149 	rsconf_t *pConf;		int iPollInterval;		int readTimeout;
150 	int timeoutGranularity;			instanceConf_t *root, *tail;
151 	fs_node_t *conf_tree;
152 	uint8_t opMode;
153 	sbool configSetViaV2Method;
154 	uchar *stateFileDirectory;
155 	sbool sortFiles;
156 };
157 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static modConfData_t *currModConf = NULL;
158 #ifdef HAVE_INOTIFY_INIT
159 struct wd_map_s {
160 	int wd;			act_obj_t *act; };
161 typedef struct wd_map_s wd_map_t;
162 static wd_map_t *wdmap = NULL;
163 static int nWdmap;
164 static int allocMaxWdmap;
165 static int ino_fd;	#endif 
166 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
167 struct fileinfo {
168 	struct file_obj fobj;
169 	int events;
170 	int port;
171 };
172 #endif 
173 static prop_t *pInputName = NULL;
174 static struct cnfparamdescr modpdescr[] = {
175 	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
176 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
177 	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
178 	{ "sortfiles", eCmdHdlrBinary, 0 },
179 	{ "statefile.directory", eCmdHdlrString, 0 },
180 	{ "normalizepath", eCmdHdlrBinary, 0 },
181 	{ "mode", eCmdHdlrGetWord, 0 }
182 };
183 static struct cnfparamblk modpblk =
184 	{ CNFPARAMBLK_VERSION,
185 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
186 	  modpdescr
187 	};
188 static struct cnfparamdescr inppdescr[] = {
189 	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
190 	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
191 	{ "severity", eCmdHdlrSeverity, 0 },
192 	{ "facility", eCmdHdlrFacility, 0 },
193 	{ "ruleset", eCmdHdlrString, 0 },
194 	{ "readmode", eCmdHdlrInt, 0 },
195 	{ "startmsg.regex", eCmdHdlrString, 0 },
196 	{ "endmsg.regex", eCmdHdlrString, 0 },
197 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
198 	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
199 	{ "escapelf", eCmdHdlrBinary, 0 },
200 	{ "escapelf.replacement", eCmdHdlrString, 0 },
201 	{ "reopenontruncate", eCmdHdlrBinary, 0 },
202 	{ "maxlinesatonce", eCmdHdlrInt, 0 },
203 	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
204 <a name="0"></a>	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
205 	{ "removestateondelete", eCmdHdlrBinary, 0 },
206 	{ "persiststateinterval", eCmdHdlrInt, 0 },
207 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
208 	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
209 	{ "delay.message", eCmdHdlrNonNegInt, 0 },
210 	{ "addmetadata", eCmdHdlrBinary, 0 },
211 	{ "addceetag", eCmdHdlrBinary, 0 },
212 	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
213 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
214 	{ "freshstarttail", eCmdHdlrBinary, 0},
215 	{ "filenotfounderror", eCmdHdlrBinary, 0},
216 	{ "needparse", eCmdHdlrBinary, 0},
217 	{ "ignoreolderthan", eCmdHdlrInt, 0},
218 	{ "maxbytesperminute", eCmdHdlrInt, 0},
219 	{ "maxlinesperminute", eCmdHdlrInt, 0}
220 };
221 static struct cnfparamblk inppblk =
222 	{ CNFPARAMBLK_VERSION,
223 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
224 	  inppdescr
225 	};
226 #include "im-helper.h" 
227 #define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
228 #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
229 static uchar * ATTR_NONNULL(1, 2)</b></font>
230 OLD_getStateFileName(const instanceConf_t *const inst,
231 	 uchar *const __restrict__ buf,
232 	 const size_t lenbuf)
233 {
234 	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
235 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
236 	buf[lenbuf-1] = '\0'; 	uchar *p = buf;
237 	for( ; *p ; ++p) {
238 		if(*p == '/')
239 			*p = '-';
240 	}
241 	return buf;
242 }
243 static const uchar *
244 getStateFileDir(void)
245 {
246 	const uchar *wrkdir;
247 	assert(currModConf != NULL);
248 	if(currModConf-&gt;stateFileDirectory == NULL) {
249 		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
250 	} else {
251 		wrkdir = currModConf-&gt;stateFileDirectory;
252 	}
253 	return(wrkdir);
254 }
255 static rsRetVal ATTR_NONNULL(1)
256 OLD_openFileWithStateFile(act_obj_t *const act)
257 {
258 	DEFiRet;
259 	strm_t *psSF = NULL;
260 	uchar pszSFNam[MAXFNAME];
261 	size_t lenSFNam;
262 	struct stat stat_buf;
263 	uchar statefile[MAXFNAME];
264 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
265 	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
266 	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
267 		  act-&gt;name, statefn);
268 	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
269 	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
270 		if(errno == ENOENT) {
271 			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
272 				pszSFNam, act-&gt;name);
273 			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
274 		} else {
275 			char errStr[1024];
276 			rs_strerror_r(errno, errStr, sizeof(errStr));
277 			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
278 				"file for '%s':%s\n", act-&gt;name, errStr);
279 			ABORT_FINALIZE(RS_RET_IO_ERROR);
280 		}
281 	}
282 	DBGPRINTF("old state file found - instantiating from it\n");
283 	CHKiRet(strm.Construct(&amp;psSF));
284 	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
285 	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
286 	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
287 	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
288 	CHKiRet(strm.ConstructFinalize(psSF));
289 	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
290 	free(act-&gt;pStrm-&gt;pszFName);
291 	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));
292 	strm.CheckFileChange(act-&gt;pStrm);
293 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
294 	persistStrmState(act);
295 	unlink((char*)pszSFNam);
296 finalize_it:
297 	if(psSF != NULL)
298 		strm.Destruct(&amp;psSF);
299 	RETiRet;
300 }
301 #endif 
302 #if 0 static const char * ATTR_NONNULL()
303 gen_full_name(const char *const dirname, const char *const name)
304 {
305 	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
306 	char *const full_name = malloc(len_full_name);
307 	if(full_name == NULL)
308 		return NULL;
309 	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
310 	return full_name;
311 }
312 #endif
313 #ifdef HAVE_INOTIFY_INIT
314 #if ULTRA_DEBUG == 1
315 static void
316 dbg_wdmapPrint(const char *msg)
317 {
318 	int i;
319 	DBGPRINTF("%s\n", msg);
320 	for(i = 0 ; i &lt; nWdmap ; ++i)
321 		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
322 			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
323 }
324 #endif
325 static rsRetVal
326 wdmapInit(void)
327 {
328 	DEFiRet;
329 	free(wdmap);
330 	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
331 	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
332 	nWdmap = 0;
333 finalize_it:
334 	RETiRet;
335 }
336 static rsRetVal
337 wdmapAdd(int wd, act_obj_t *const act)
338 {
339 	wd_map_t *newmap;
340 	int newmapsize;
341 	int i;
342 	DEFiRet;
343 	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
344 		; 		if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
345 		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
346 		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
347 	}
348 	++i;
349 	if(nWdmap == allocMaxWdmap) {
350 		newmapsize = 2 * allocMaxWdmap;
351 		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
352 		wdmap = newmap;
353 		allocMaxWdmap = newmapsize;
354 	}
355 	if(i &lt; nWdmap) {
356 		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
357 	}
358 	wdmap[i].wd = wd;
359 	wdmap[i].act = act;
360 	++nWdmap;
361 	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);
362 finalize_it:
363 	RETiRet;
364 }
365 static int
366 in_setupWatch(act_obj_t *const act, const int is_file)
367 {
368 	int wd = -1;
369 	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
370 		goto done;
371 	wd = inotify_add_watch(ino_fd, act-&gt;name,
372 		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
373 	if(wd &lt; 0) {
374 		if (errno == EACCES) { 			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
375 		} else {
376 			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
377 		}
378 		goto done;
379 	}
380 	wdmapAdd(wd, act);
381 	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
382 done:	return wd;
383 }
384 static int
385 wdmap_cmp(const void *k, const void *a)
386 {
387 	int key = *((int*) k);
388 	wd_map_t *etry = (wd_map_t*) a;
389 	if(key &lt; etry-&gt;wd)
390 		return -1;
391 	else if(key &gt; etry-&gt;wd)
392 		return 1;
393 	else
394 		return 0;
395 }
396 static wd_map_t *
397 wdmapLookup(int wd)
398 {
399 	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
400 }
401 static rsRetVal
402 wdmapDel(const int wd)
403 {
404 	int i;
405 	DEFiRet;
406 	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
407 		; 		if(i == nWdmap ||  wdmap[i].wd != wd) {
408 		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
409 		FINALIZE;
410 	}
411 	if(i &lt; nWdmap-1) {
412 		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
413 	}
414 	--nWdmap;
415 	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);
416 finalize_it:
417 	RETiRet;
418 }
419 #endif 
420 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
421 static void ATTR_NONNULL()
422 fen_setupWatch(act_obj_t *const act)
423 {
424 	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
425 	if(runModConf-&gt;opMode != OPMODE_FEN)
426 		goto done;
427 	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
428 	if(act-&gt;pfinf == NULL) {
429 		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
430 		if (act-&gt;pfinf == NULL) {
431 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
432 				"for fileinfo failed ");
433 			goto done;
434 		}
435 		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
436 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
437 				"for strdup failed ");
438 			free(act-&gt;pfinf);
439 			act-&gt;pfinf = NULL;
440 			goto done;
441 		}
442 		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
443 		act-&gt;pfinf-&gt;port = glport;
444 		act-&gt;bPortAssociated = 0;
445 	}
446 	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
447 	if(act-&gt;bPortAssociated) {
448 		goto done;
449 	}
450 	struct stat fileInfo;
451 	const int r = stat(act-&gt;name, &amp;fileInfo);
452 	if(r == -1) { 		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
453 		goto done;
454 	}
455 	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
456 	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
457 	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
458 	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
459 				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
460 		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
461 			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
462 		goto done;
463 	} else {
464 		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
465 		act-&gt;bPortAssociated = 1;
466 	}
467 	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
468 done:	return;
469 }
470 #else
471 static void ATTR_NONNULL()
472 fen_setupWatch(act_obj_t *const act __attribute__((unused)))
473 {
474 	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
475 }
476 #endif 
477 static void
478 fs_node_print(const fs_node_t *const node, const int level)
479 {
480 	fs_edge_t *chld;
481 	act_obj_t *act;
482 	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);
483 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
484 		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
485 			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
486 		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
487 			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
488 		}
489 		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
490 			dbgprintf("\tact : %p\n", act);
491 			dbgprintf("\tact : %p: name '%s', wd: %d\n",
492 				act, act-&gt;name, act-&gt;wd);
493 		}
494 	}
495 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
496 		fs_node_print(chld-&gt;node, level+1);
497 	}
498 }
499 static sbool
500 isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
501 {
502 	if (inst-&gt;ignoreOlderThan)
503 	{
504 		struct stat stat_buf;
505 		time_t tt;
506 		datetime.GetTime(&amp;tt);
507 		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
508 			return 1;
509 		}
510 	}
511 	return 0;
512 }
513 static rsRetVal ATTR_NONNULL(1,2)
514 act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
515 	const ino_t ino, const int is_symlink, const char *const source)
516 {
517 	act_obj_t *act = NULL;
518 	char basename[MAXFNAME];
519 	DEFiRet;
520 	int fd = -1;
521 	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");
522 	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
523 		ABORT_FINALIZE(RS_RET_ERR);
524 	}
525 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
526 		if(!strcmp(act-&gt;name, name)) {
527 			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
528 				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
529 					name, edge-&gt;path);
530 				FINALIZE;
531 			}
532 		}
533 	}
534 	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
535 	fd = open(name, O_RDONLY | O_CLOEXEC);
536 	if(fd &lt; 0) {
537 		if (is_file) {
538 			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
539 		} else { 			DBGPRINTF("imfile: error accessing directory '%s'", name);
540 		}
541 		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
542 	}
543 	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
544 	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
545 	CHKmalloc(act-&gt;name = strdup(name));
546 	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
547 		CHKmalloc(act-&gt;basename = strdup(name)); 	} else {
548 		CHKmalloc(act-&gt;basename = strdup(basename));
549 	}
550 	act-&gt;edge = edge;
551 	act-&gt;ino = ino;
552 	act-&gt;fd = fd;
553 	act-&gt;file_id[0] = '\0';
554 	act-&gt;file_id_prev[0] = '\0';
555 	act-&gt;is_symlink = is_symlink;
556 	act-&gt;ratelimiter = NULL;
557 	if (source) { 		CHKmalloc(act-&gt;source_name = strdup(source));
558 	} else {
559 		act-&gt;source_name = NULL;
560 	}
561 	#ifdef HAVE_INOTIFY_INIT
562 	act-&gt;wd = in_setupWatch(act, is_file);
563 	#endif
564 	fen_setupWatch(act);
565 	if(is_file &amp;&amp; !is_symlink) {
566 		const instanceConf_t *const inst = edge-&gt;instarr[0];		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
567 		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
568 		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
569 		act-&gt;multiSub.nElem = 0;
570 		pollFile(act);
571 	}
572 	if(edge-&gt;active != NULL) {
573 		edge-&gt;active-&gt;prev = act;
574 	}
575 	act-&gt;next = edge-&gt;active;
576 	edge-&gt;active = act;
577 finalize_it:
578 	if(iRet != RS_RET_OK) {
579 		if(act != NULL) {
580 			if (act-&gt;ratelimiter != NULL)
581 				ratelimitDestruct(act-&gt;ratelimiter);
582 			free(act-&gt;name);
583 			free(act);
584 		}
585 		if(fd != -1) {
586 			close(fd);
587 		}
588 	}
589 	RETiRet;
590 }
591 static void
592 detect_updates(fs_edge_t *const edge)
593 {
594 	act_obj_t *act;
595 	struct stat fileInfo;
596 	int restart = 0;
597 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
598 		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
599 		const int r = lstat(act-&gt;name, &amp;fileInfo);
600 		if(r == -1) { 			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
601 			act_obj_unlink(act);
602 			restart = 1;
603 			break;
604 		} else if(fileInfo.st_ino != act-&gt;ino) {
605 			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
606 				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
607 				(long long unsigned) fileInfo.st_ino);
608 			if(act-&gt;pStrm != NULL) {
609 				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
610 			}
611 			act_obj_unlink(act);
612 			restart = 1;
613 			break;
614 		}
615 	}
616 	if (restart) {
617 		detect_updates(edge);
618 	}
619 }
620 static void ATTR_NONNULL()
621 poll_active_files(fs_edge_t *const edge)
622 {
623 	if(   runModConf-&gt;opMode != OPMODE_POLLING
624 	   || !edge-&gt;is_file
625 	   || glbl.GetGlobalInputTermState() != 0) {
626 		return;
627 	}
628 	act_obj_t *act;
629 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
630 		fen_setupWatch(act);
631 		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
632 		pollFile(act);
633 	}
634 }
635 static rsRetVal ATTR_NONNULL()
636 process_symlink(fs_edge_t *const chld, const char *symlink)
637 {
638 	DEFiRet;
639 	char *target;
640 	CHKmalloc(target = realpath(symlink, NULL));
641 	struct stat fileInfo;
642 	if(lstat(target, &amp;fileInfo) != 0) {
643 		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
644 		FINALIZE;
645 	}
646 	const int is_file = (S_ISREG(fileInfo.st_mode));
647 	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
648 		target, is_file, chld-&gt;is_file, 0);
649 	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
650 		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
651 		if (idx) { 			char parent[MAXFNAME];
652 			idx--; 			memcpy(parent, chld-&gt;active-&gt;name, idx);
653 			parent[idx] = '\0';
654 			if(lstat(parent, &amp;fileInfo) != 0) {
655 				LogError(errno, RS_RET_ERR,
656 					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
657 				FINALIZE;
658 			}
659 			if (chld-&gt;parent-&gt;root-&gt;edges) {
660 				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
661 				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
662 			}
663 		}
664 	}
665 finalize_it:
666 	free(target);
667 	RETiRet;
668 }
669 static void ATTR_NONNULL()
670 poll_tree(fs_edge_t *const chld)
671 {
672 	struct stat fileInfo;
673 	glob_t files;
674 	int need_globfree = 0;
675 	int issymlink;
676 	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
677 	detect_updates(chld);
678 	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
679 	need_globfree = 1;
680 	DBGPRINTF("poll_tree: glob returned %d\n", ret);
681 	if(ret == 0) {
682 		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
683 		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
684 			if(glbl.GetGlobalInputTermState() != 0) {
685 				goto done;
686 			}
687 			char *const file = files.gl_pathv[i];
688 			if(lstat(file, &amp;fileInfo) != 0) {
689 				LogError(errno, RS_RET_ERR,
690 					"imfile: poll_tree cannot stat file '%s' - ignored", file);
691 				continue;
692 			}
693 			if (S_ISLNK(fileInfo.st_mode)) {
694 				rsRetVal slink_ret = process_symlink(chld, file);
695 				if (slink_ret != RS_RET_OK) {
696 					continue;
697 				}
698 				issymlink = 1;
699 			} else {
700 				issymlink = 0;
701 			}
702 			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
703 			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
704 				file, is_file, chld-&gt;is_file, issymlink);
705 			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
706 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
707 					"imfile: '%s' is neither a regular file, symlink, nor a "
708 					"directory - ignored", file);
709 				continue;
710 			}
711 			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
712 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
713 					"imfile: '%s' is %s but %s expected - ignored",
714 					file, (is_file) ? "FILE" : "DIRECTORY",
715 					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
716 				continue;
717 			}
718 			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
719 		}
720 	}
721 	poll_active_files(chld);
722 done:
723 	if(need_globfree) {
724 		globfree(&amp;files);
725 	}
726 	return;
727 }
728 #ifdef HAVE_INOTIFY_INIT static void ATTR_NONNULL()
729 poll_timeouts(fs_edge_t *const edge)
730 {
731 	if(edge-&gt;is_file) {
732 		act_obj_t *act;
733 		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
734 			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
735 				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
736 				pollFile(act);
737 			}
738 		}
739 	}
740 }
741 #endif
742 static void
743 act_obj_destroy(act_obj_t *const act, const int is_deleted)
744 {
745 	uchar *statefn;
746 	uchar statefile[MAXFNAME];
747 	uchar toDel[MAXFNAME];
748 	if(act == NULL)
749 		return;
750 	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
751 		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
752 		act-&gt;in_move);
753 	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
754 		act_obj_t *target_act;
755 		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
756 			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
757 				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
758 						"symlink\n", target_act-&gt;name, act-&gt;name);
759 				act_obj_unlink(target_act);
760 				break;
761 			}
762 		}
763 	}
764 	if(act-&gt;pStrm != NULL) {
765 		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];		pollFile(act); 		if(inst-&gt;bRMStateOnDel) {
766 			statefn = getStateFileName(act, statefile, sizeof(statefile));
767 			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); 			statefn = toDel;
768 		}
769 		persistStrmState(act);
770 		strm.Destruct(&amp;act-&gt;pStrm);
771 		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
772 			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
773 			unlink((char*)statefn);
774 		}
775 	}
776 	if(act-&gt;ratelimiter != NULL) {
777 		ratelimitDestruct(act-&gt;ratelimiter);
778 	}
779 	#ifdef HAVE_INOTIFY_INIT
780 	if(act-&gt;wd != -1) {
781 		inotify_rm_watch(ino_fd, act-&gt;wd);
782 		wdmapDel(act-&gt;wd);
783 	}
784 	#endif
785 	if(act-&gt;fd &gt;= 0) {
786 		close(act-&gt;fd);
787 	}
788 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
789 	if(act-&gt;pfinf != NULL) {
790 		free(act-&gt;pfinf-&gt;fobj.fo_name);
791 		free(act-&gt;pfinf);
792 	}
793 	#endif
794 	free(act-&gt;basename);
795 	free(act-&gt;source_name);
796 	free(act-&gt;multiSub.ppMsgs);
797 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
798 		act-&gt;is_deleted = 1;
799 	#else
800 		free(act-&gt;name);
801 		free(act);
802 	#endif
803 }
804 static void
805 act_obj_destroy_all(act_obj_t *act)
806 {
807 	if(act == NULL)
808 		return;
809 	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
810 	while(act != NULL) {
811 		act_obj_t *const toDel = act;
812 		act = act-&gt;next;
813 		act_obj_destroy(toDel, 0);
814 	}
815 }
816 #if 0
817 static void
818 chk_active(const act_obj_t *act, const act_obj_t *const deleted)
819 {
820 	while(act != NULL) {
821 		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
822 		if(act-&gt;prev == deleted)
823 			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
824 		if(act-&gt;next == deleted)
825 			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
826 		act = act-&gt;next;
827 		DBGPRINTF("chk_active next %p\n", act);
828 	}
829 }
830 #endif
831 static void ATTR_NONNULL()
832 act_obj_unlink(act_obj_t *act)
833 {
834 	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
835 	if(act-&gt;prev == NULL) {
836 		act-&gt;edge-&gt;active = act-&gt;next;
837 	} else {
838 		act-&gt;prev-&gt;next = act-&gt;next;
839 	}
840 	if(act-&gt;next != NULL) {
841 		act-&gt;next-&gt;prev = act-&gt;prev;
842 	}
843 	act_obj_destroy(act, 1);
844 	act = NULL;
845 }
846 static void
847 fs_node_destroy(fs_node_t *const node)
848 {
849 	fs_edge_t *edge;
850 	DBGPRINTF("node destroy: %p edges:\n", node);
851 	for(edge = node-&gt;edges ; edge != NULL ; ) {
852 		fs_node_destroy(edge-&gt;node);
853 		fs_edge_t *const toDel = edge;
854 		edge = edge-&gt;next;
855 		act_obj_destroy_all(toDel-&gt;active);
856 		free(toDel-&gt;name);
857 		free(toDel-&gt;path);
858 		free(toDel-&gt;instarr);
859 		free(toDel);
860 	}
861 	free(node);
862 }
863 static void ATTR_NONNULL(1, 2)
864 fs_node_walk(fs_node_t *const node,
865 	void (*f_usr)(fs_edge_t*const))
866 {
867 	DBGPRINTF("node walk: %p edges:\n", node);
868 	fs_edge_t *edge;
869 	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
870 		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
871 		f_usr(edge);
872 		fs_node_walk(edge-&gt;node, f_usr);
873 	}
874 }
875 static rsRetVal
876 fs_node_add(fs_node_t *const node,
877 	fs_node_t *const source,
878 	const uchar *const toFind,
879 	const size_t pathIdx,
880 	instanceConf_t *const inst)
881 {
882 	DEFiRet;
883 	fs_edge_t *newchld = NULL;
884 	int i;
885 	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
886 		node, toFind+pathIdx, pathIdx);
887 	assert(toFind[0] != '\0');
888 	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
889 	const int isFile = (toFind[i] == '\0') ? 1 : 0;
890 	uchar ourPath[PATH_MAX];
891 	if(i == 0) {
892 		ourPath[0] = '/';
893 		ourPath[1] = '\0';
894 	} else {
895 		memcpy(ourPath, toFind, i);
896 		ourPath[i] = '\0';
897 	}
898 	const size_t nextPathIdx = i+1;
899 	const size_t len = i - pathIdx;
900 	uchar name[PATH_MAX];
901 	memcpy(name, toFind+pathIdx, len);
902 	name[len] = '\0';
903 	DBGPRINTF("fs_node_add: name '%s'\n", name);
904 	node-&gt;root = source;
905 	fs_edge_t *chld;
906 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
907 		if(!ustrcmp(chld-&gt;name, name)) {
908 			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
909 			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
910 							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
911 			CHKmalloc(instarr_new);
912 			chld-&gt;instarr = instarr_new;
913 			chld-&gt;ninst++;
914 			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
915 			if(!isFile) {
916 				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
917 			}
918 			FINALIZE;
919 		}
920 	}
921 	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
922 		node, toFind, name);
923 	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
924 	CHKmalloc(newchld-&gt;name = ustrdup(name));
925 	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
926 	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
927 	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
928 	newchld-&gt;instarr[0] = inst;
929 	newchld-&gt;is_file = isFile;
930 	newchld-&gt;ninst = 1;
931 	newchld-&gt;parent = node;
932 	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);
933 	if(!isFile) {
934 		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
935 	}
936 	newchld-&gt;next = node-&gt;edges;
937 	node-&gt;edges = newchld;
938 finalize_it:
939 	if(iRet != RS_RET_OK) {
940 		if(newchld != NULL) {
941 		free(newchld-&gt;name);
942 		free(newchld-&gt;node);
943 		free(newchld-&gt;path);
944 		free(newchld-&gt;instarr);
945 		free(newchld);
946 		}
947 	}
948 	RETiRet;
949 }
950 static int ATTR_NONNULL()
951 getFullStateFileName(const uchar *const pszstatefile,
952 	const char *const file_id,
953 	uchar *const pszout,
954 	const size_t ilenout)
955 {
956 	int lenout;
957 	const uchar* pszstatedir;
958 	pszstatedir = getStateFileDir();
959 	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
960 		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
961 		(*file_id == '\0') ? "" : ":", file_id);
962 	return lenout;
963 }
964 #if defined(__clang__)
965 #pragma GCC diagnostic ignored "-Wunknown-attributes"
966 #endif
967 static void __attribute__((nonnull(1,3)))
968 #if defined(__clang__)
969 __attribute__((no_sanitize("unsigned-integer-overflow")))
970 #endif
971 get_file_id_hash(const char *data, size_t lendata,
972 	char *const hash_str, const size_t len_hash_str)
973 {
974 	assert(len_hash_str &gt;= 17); 
975 	size_t i;
976 	uint8_t out[8], k[16];
977 	for (i = 0; i &lt; 16; ++i)
978 		k[i] = i;
979 	memset(out, 0, sizeof(out));
980 	rs_siphash((const uint8_t *)data, lendata, k, out, 8);
981 	for(i = 0 ; i &lt; 8 ; ++i) {
982 		if(2 * i+1 &gt;= len_hash_str)
983 			break;
984 		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
985 	}
986 }
987 static void ATTR_NONNULL(1)
988 getFileID(act_obj_t *const act)
989 {
990 	char tmp_id[FILE_ID_HASH_SIZE];
991 	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
992 	act-&gt;file_id[0] = '\0';
993 	assert(act-&gt;fd &gt;= 0); 	char filedata[FILE_ID_SIZE];
994 	lseek(act-&gt;fd, 0, SEEK_SET); 	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
995 	if(r == FILE_ID_SIZE) {
996 		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
997 	} else {
998 		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
999 	}
1000 	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
1001 	}
1002 	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
1003 }
1004 static uchar * ATTR_NONNULL(1, 2)
1005 getStateFileName(const act_obj_t *const act,
1006 	 	 uchar *const __restrict__ buf,
1007 		 const size_t lenbuf)
1008 {
1009 	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
1010 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
1011 	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
1012 	return buf;
1013 }
1014 static rsRetVal
1015 checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
1016 			     const size_t msgLen)
1017 {
1018 	DEFiRet;
1019 	time_t current_minute = time(NULL)/60;
1020 	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
1021 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1022 			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
1023 			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
1024 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1025 			}
1026 		} else {
1027 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1028 			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; 		}
1029 	}
1030 	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
1031 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1032 			per_minute_rate_limits-&gt;linesThisMinute++;
1033 			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
1034 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1035 			}
1036 		} else {
1037 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1038 			per_minute_rate_limits-&gt;linesThisMinute = 1; 		}
1039 	}
1040 finalize_it:
1041 	RETiRet;
1042 }
1043 #define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
1044 static rsRetVal ATTR_NONNULL(1,2)
1045 enqLine(act_obj_t *const act,
1046 	cstr_t *const __restrict__ cstrLine,
1047 	const int64 strtOffs)
1048 {
1049 	DEFiRet;
1050 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];	smsg_t *pMsg;
1051 	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
1052 	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
1053 	const uchar *metadata_values[2] ;
1054 	const size_t msgLen = cstrLen(cstrLine);
1055 	if(msgLen == 0) {
1056 		FINALIZE;
1057 	}
1058 	CHKiRet(msgConstruct(&amp;pMsg));
1059 	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
1060 	MsgSetInputName(pMsg, pInputName);
1061 	if(inst-&gt;addCeeTag) {
1062 		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
1063 		char *ceeMsg;
1064 		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
1065 		strcpy(ceeMsg, CONST_CEE_COOKIE);
1066 		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
1067 		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
1068 		free(ceeMsg);
1069 	} else {
1070 		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
1071 	}
1072 	MsgSetMSGoffs(pMsg, 0);		MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
1073 	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
1074 	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
1075 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
1076 	if(inst-&gt;addMetadata) {
1077 		if (act-&gt;source_name) {
1078 			metadata_values[0] = (const uchar*)act-&gt;source_name;
1079 		} else {
1080 			metadata_values[0] = (const uchar*)act-&gt;name;
1081 		}
1082 		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
1083 		metadata_values[1] = file_offset;
1084 		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
1085 	}
1086 	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
1087 		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
1088 	}
1089 	if(inst-&gt;delay_perMsg) {
1090 		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
1091 	}
1092 	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;
1093 	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
1094 finalize_it:
1095 	RETiRet;
1096 }
1097 static rsRetVal ATTR_NONNULL(1)
1098 openFileWithStateFile(act_obj_t *const act)
1099 {
1100 	DEFiRet;
1101 	uchar pszSFNam[MAXFNAME];
1102 	uchar statefile[MAXFNAME];
1103 	int fd = -1;
1104 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1105 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
1106 	getFileID(act);
1107 	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
1108 	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);
1109 	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1110 	if(fd &lt; 0) {
1111 		if(errno == ENOENT) {
1112 			if(act-&gt;file_id[0] != '\0') {
1113 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1114 					"inode-only file exists\n", pszSFNam, act-&gt;name);
1115 				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
1116 				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1117 				if(fd &gt;= 0) {
1118 					dbgprintf("found inode-only state file, will be renamed at next persist\n");
1119 				}
1120 			}
1121 			if(fd &lt; 0) {
1122 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1123 					"old-style file exists\n", pszSFNam, act-&gt;name);
1124 				CHKiRet(OLD_openFileWithStateFile(act));
1125 				FINALIZE;
1126 			}
1127 		} else {
1128 			LogError(errno, RS_RET_IO_ERROR,
1129 				"imfile error trying to access state file for '%s'",
1130 			        act-&gt;name);
1131 			ABORT_FINALIZE(RS_RET_IO_ERROR);
1132 		}
1133 	}
1134 	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
1135 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1136 	struct json_object *jval;
1137 	struct json_object *json = fjson_object_from_fd(fd);
1138 	if(json == NULL) {
1139 		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
1140 	}
1141 	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
1142 	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);
1143 	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
1144 	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);
1145 	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
1146 	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);
1147 	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
1148 	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
1149 	if(jval != NULL) {
1150 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
1151 		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
1152 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
1153 		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
1154 	}
1155 	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
1156 	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
1157 	if(jval != NULL) {
1158 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
1159 		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
1160 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
1161 		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
1162 	}
1163 	fjson_object_put(json);
1164 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1165 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1166 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1167 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1168 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1169 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1170 finalize_it:
1171 	if(fd &gt;= 0) {
1172 		close(fd);
1173 	}
1174 	RETiRet;
1175 }
1176 static rsRetVal
1177 openFileWithoutStateFile(act_obj_t *const act)
1178 {
1179 	DEFiRet;
1180 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1181 	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
1182 	if(act-&gt;pStrm != NULL)
1183 		strm.Destruct(&amp;act-&gt;pStrm);
1184 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1185 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1186 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1187 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1188 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1189 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1190 	if(inst-&gt;freshStartTail) {
1191 		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
1192 		if(fd &gt;= 0) {
1193 			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
1194 			close(fd);
1195 			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
1196 				act-&gt;pStrm-&gt;iCurrOffs = 0;
1197 				LogError(errno, RS_RET_ERR, "imfile: could not query current "
1198 					"file size for %s - 'freshStartTail' option will "
1199 					"be ignored, starting at begin of file", inst-&gt;pszFileName);
1200 			}
1201 			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1202 		}
1203 	}
1204 finalize_it:
1205 	RETiRet;
1206 }
1207 static rsRetVal
1208 openFile(act_obj_t *const act)
1209 {
1210 	DEFiRet;
1211 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1212 	CHKiRet_Hdlr(openFileWithStateFile(act)) {
1213 		CHKiRet(openFileWithoutStateFile(act));
1214 	}
1215 	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
1216 	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
1217 	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);
1218 finalize_it:
1219 	RETiRet;
1220 }
1221 static void pollFileCancelCleanup(void *pArg)
1222 {
1223 	cstr_t **ppCStr = (cstr_t**) pArg;
1224 	if(*ppCStr != NULL)
1225 		rsCStrDestruct(ppCStr);
1226 }
1227 static rsRetVal ATTR_NONNULL()
1228 pollFileReal(act_obj_t *act, cstr_t **pCStr)
1229 {
1230 	int64 strtOffs;
1231 	DEFiRet;
1232 	int64_t startOffs = 0;
1233 	int nProcessed = 0;
1234 	regex_t *start_preg = NULL, *end_preg = NULL;
1235 	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
1236 	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
1237 	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);
1238 	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1239 	if(act-&gt;pStrm == NULL) {
1240 		CHKiRet(openFile(act)); 	}
1241 	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
1242 	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;
1243 	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
1244 	while(glbl.GetGlobalInputTermState() == 0) {
1245 		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
1246 			break;
1247 		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
1248 			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
1249 				inst-&gt;trimLineOverBytes, &amp;strtOffs));
1250 		} else {
1251 			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
1252 				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
1253 				inst-&gt;msgDiscardingError, &amp;strtOffs));
1254 		}
1255 		++nProcessed;
1256 		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
1257 			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
1258 				act-&gt;name);
1259 			persistStrmState(act);
1260 			startOffs = act-&gt;pStrm-&gt;iCurrOffs; 		}
1261 		runModConf-&gt;bHadFileData = 1; 		CHKiRet(enqLine(act, *pCStr, strtOffs)); 		rsCStrDestruct(pCStr); 		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
1262 			persistStrmState(act);
1263 			act-&gt;nRecords = 0;
1264 		}
1265 	}
1266 finalize_it:
1267 	multiSubmitFlush(&amp;act-&gt;multiSub);
1268 	if(inst-&gt;bPersistStateAfterSubmission) {
1269 		persistStrmState(act);
1270 	}
1271 	if(*pCStr != NULL) {
1272 		rsCStrDestruct(pCStr);
1273 	}
1274 	RETiRet;
1275 }
1276 static rsRetVal ATTR_NONNULL(1)
1277 pollFile(act_obj_t *const act)
1278 {
1279 	cstr_t *pCStr = NULL;
1280 	DEFiRet;
1281 	if (act-&gt;is_symlink) {
1282 		FINALIZE;    	}
1283 	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
1284 	iRet = pollFileReal(act, &amp;pCStr);
1285 	pthread_cleanup_pop(0);
1286 finalize_it: RETiRet;
1287 }
1288 static rsRetVal ATTR_NONNULL(1)
1289 createInstance(instanceConf_t **const pinst)
1290 {
1291 	instanceConf_t *inst;
1292 	DEFiRet;
1293 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
1294 	inst-&gt;next = NULL;
1295 	inst-&gt;pBindRuleset = NULL;
1296 	inst-&gt;pszBindRuleset = NULL;
1297 	inst-&gt;pszFileName = NULL;
1298 	inst-&gt;pszTag = NULL;
1299 	inst-&gt;pszStateFile = NULL;
1300 	inst-&gt;nMultiSub = NUM_MULTISUB;
1301 	inst-&gt;iSeverity = 5;
1302 	inst-&gt;iFacility = 128;
1303 	inst-&gt;maxLinesAtOnce = 0;
1304 	inst-&gt;trimLineOverBytes = 0;
1305 	inst-&gt;iPersistStateInterval = 0;
1306 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
1307 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
1308 	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
1309 	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
1310 	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
1311 	inst-&gt;bPersistStateAfterSubmission = 0;
1312 	inst-&gt;readMode = 0;
1313 	inst-&gt;startRegex = NULL;
1314 	inst-&gt;endRegex = NULL;
1315 	inst-&gt;discardTruncatedMsg = 0;
1316 	inst-&gt;msgDiscardingError = 1;
1317 	inst-&gt;bRMStateOnDel = 1;
1318 	inst-&gt;escapeLF = 1;
1319 	inst-&gt;escapeLFString = NULL;
1320 	inst-&gt;reopenOnTruncate = 0;
1321 	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
1322 	inst-&gt;addCeeTag = 0;
1323 	inst-&gt;freshStartTail = 0;
1324 	inst-&gt;fileNotFoundError = 1;
1325 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1326 	inst-&gt;delay_perMsg = 0;
1327 	inst-&gt;msgFlag = 0;
1328 	inst-&gt;ignoreOlderThan = 0;
1329 	if(loadModConf-&gt;tail == NULL) {
1330 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
1331 	} else {
1332 		loadModConf-&gt;tail-&gt;next = inst;
1333 		loadModConf-&gt;tail = inst;
1334 	}
1335 	*pinst = inst;
1336 finalize_it:
1337 	RETiRet;
1338 }
1339 static int ATTR_NONNULL()
1340 getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
1341 {
1342 	int i;
1343 	int found = 0;
1344 	const int lenName = ustrlen(path);
1345 	for(i = lenName ; i &gt;= 0 ; --i) {
1346 		if(path[i] == '/') {
1347 			found = 1;
1348 			if(i == lenName)
1349 				basen[0] = '\0';
1350 			else {
1351 				memcpy(basen, path+i+1, lenName-i);
1352 			}
1353 			break;
1354 		}
1355 	}
1356 	if (found == 1)
1357 		return i;
1358 	else {
1359 		return -1;
1360 	}
1361 }
1362 static rsRetVal ATTR_NONNULL()
1363 checkInstance(instanceConf_t *const inst)
1364 {
1365 	uchar curr_wd[MAXFNAME];
1366 	DEFiRet;
1367 	if(inst-&gt;pszFileName == NULL)
1368 		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
1369 	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
1370 	if(loadModConf-&gt;normalizePath) {
1371 		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
1372 			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
1373 			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
1374 		}
1375 		if(inst-&gt;pszFileName[0] != '/') {
1376 			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
1377 				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
1378 					"directory - can not continue with %s", inst-&gt;pszFileName);
1379 				ABORT_FINALIZE(RS_RET_ERR);
1380 			}
1381 			const size_t len_curr_wd = ustrlen(curr_wd);
1382 			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
1383 				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
1384 					"working directory exceeds permitted size - ignoring %s",
1385 					inst-&gt;pszFileName);
1386 				ABORT_FINALIZE(RS_RET_ERR);
1387 			}
1388 			curr_wd[len_curr_wd] = '/';
1389 			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
1390 			free(inst-&gt;pszFileName);
1391 			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
1392 		}
1393 	}
1394 	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);
1395 	if(inst-&gt;pszTag != NULL) {
1396 		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
1397 	}
1398 finalize_it:
1399 	RETiRet;
1400 }
1401 static rsRetVal
1402 addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
1403 {
1404 	instanceConf_t *inst;
1405 	DEFiRet;
1406 	if(cs.pszFileName == NULL) {
1407 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
1408 					"not be created");
1409 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1410 	}
1411 	if(cs.pszFileTag == NULL) {
1412 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
1413 					"not be created");
1414 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1415 	}
1416 	CHKiRet(createInstance(&amp;inst));
1417 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
1418 		inst-&gt;pszBindRuleset = NULL;
1419 	} else {
1420 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
1421 	}
1422 	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
1423 	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
1424 	if(cs.pszStateFile == NULL) {
1425 		inst-&gt;pszStateFile = NULL;
1426 	} else {
1427 		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
1428 	}
1429 	inst-&gt;iSeverity = cs.iSeverity;
1430 	inst-&gt;iFacility = cs.iFacility;
1431 	if(cs.maxLinesAtOnce) {
1432 		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
1433 			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1434 				"parameter \"maxLinesAtOnce\" not "
1435 				"permited in inotify mode - ignored");
1436 		} else {
1437 			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
1438 		}
1439 	}
1440 <a name="2"></a>	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
1441 	inst-&gt;ignoreOlderThan = 0;
1442 	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
1443 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
1444 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
1445 	inst-&gt;bPersistStateAfterSubmission = 0;
1446 	inst-&gt;readMode = cs.readMode;
1447 	inst-&gt;escapeLF = 0;
1448 	inst-&gt;escapeLFString = NULL;
1449 	inst-&gt;reopenOnTruncate = 0;
1450 	inst-&gt;addMetadata = 0;
1451 	inst-&gt;addCeeTag = 0;
1452 	inst-&gt;bRMStateOnDel = 0;
1453 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1454 	inst-&gt;msgFlag = 0;</b></font>
1455 	CHKiRet(checkInstance(inst));
1456 	cs.iPersistStateInterval = 0;
1457 	resetConfigVariables(NULL, NULL); 
1458 finalize_it:
1459 	free(pNewVal); 	RETiRet;
1460 }
1461 BEGINnewInpInst
1462 	struct cnfparamvals *pvals;
1463 	instanceConf_t *inst;
1464 	int i;
1465 CODESTARTnewInpInst
1466 	DBGPRINTF("newInpInst (imfile)\n");
1467 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
1468 	if(pvals == NULL) {
1469 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1470 	}
1471 	if(Debug) {
1472 		DBGPRINTF("input param blk in imfile:\n");
1473 		cnfparamsPrint(&amp;inppblk, pvals);
1474 	}
1475 	CHKiRet(createInstance(&amp;inst));
1476 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
1477 		if(!pvals[i].bUsed)
1478 			continue;
1479 		if(!strcmp(inppblk.descr[i].name, "file")) {
1480 			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1481 		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
1482 			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1483 		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
1484 			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
1485 			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1486 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
1487 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1488 		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
1489 			inst-&gt;iSeverity = pvals[i].val.d.n;
1490 		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
1491 			inst-&gt;iFacility = pvals[i].val.d.n;
1492 		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
1493 			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
1494 		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
1495 			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1496 		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
1497 			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1498 		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
1499 			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
1500 		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
1501 			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
1502 		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
1503 			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
1504 			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
1505 		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {
1506 			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
1507 		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
1508 			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
1509 		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
1510 			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
1511 		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
1512 			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
1513 		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
1514 			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
1515 		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
1516 			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1517 		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
1518 			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
1519 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
1520 			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
1521 			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
1522 				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1523 					"parameter \"maxLinesAtOnce\" not "
1524 					"permited in inotify mode - ignored");
1525 			} else {
1526 				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
1527 			}
1528 		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
1529 			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
1530 		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
1531 			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
1532 		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
1533 			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
1534 		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
1535 			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
1536 			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
1537 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
1538 			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
1539 			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
1540 		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
1541 			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
1542 		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
1543 			inst-&gt;nMultiSub = pvals[i].val.d.n;
1544 		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
1545 			inst-&gt;readTimeout = pvals[i].val.d.n;
1546 		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
1547 			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
1548 		} else {
1549 			DBGPRINTF("program error, non-handled "
1550 			  "param '%s'\n", inppblk.descr[i].name);
1551 		}
1552 	}
1553 	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
1554 	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
1555 	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
1556 	if(i &gt; 1) {
1557 		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1558 			"only one of readMode or startmsg.regex or endmsg.regex can be set "
1559 			"at the same time");
1560 			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
1561 	}
1562 	if(inst-&gt;startRegex != NULL) {
1563 		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
1564 		if(errcode != 0) {
1565 			char errbuff[512];
1566 			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
1567 			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
1568 			ABORT_FINALIZE(RS_RET_ERR);
1569 		}
1570 	}
1571 	if(inst-&gt;endRegex != NULL) {
1572 		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
1573 		if(errcode != 0) {
1574 			char errbuff[512];
1575 			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
1576 			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
1577 			ABORT_FINALIZE(RS_RET_ERR);
1578 		}
1579 	}
1580 	if(inst-&gt;readTimeout != 0)
1581 		loadModConf-&gt;haveReadTimeouts = 1;
1582 	iRet = checkInstance(inst);
1583 finalize_it:
1584 CODE_STD_FINALIZERnewInpInst
1585 	cnfparamvalsDestruct(pvals, &amp;inppblk);
1586 ENDnewInpInst
1587 BEGINbeginCnfLoad
1588 CODESTARTbeginCnfLoad
1589 	loadModConf = pModConf;
1590 	currModConf = pModConf;
1591 	pModConf-&gt;pConf = pConf;
1592 	loadModConf-&gt;opMode = OPMODE_POLLING;
1593 	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
1594 	loadModConf-&gt;configSetViaV2Method = 0;
1595 	loadModConf-&gt;readTimeout = 0; 	loadModConf-&gt;timeoutGranularity = 1000; 	loadModConf-&gt;haveReadTimeouts = 0; 	loadModConf-&gt;normalizePath = 1;
1596 	loadModConf-&gt;sortFiles = GLOB_NOSORT;
1597 	loadModConf-&gt;stateFileDirectory = NULL;
1598 	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
1599 	loadModConf-&gt;conf_tree-&gt;edges = NULL;
1600 	bLegacyCnfModGlobalsPermitted = 1;
1601 	cs.pszFileName = NULL;
1602 	cs.pszFileTag = NULL;
1603 	cs.pszStateFile = NULL;
1604 	cs.iPollInterval = DFLT_PollInterval;
1605 	cs.iPersistStateInterval = 0;
1606 	cs.iFacility = 128;
1607 	cs.iSeverity = 5;
1608 	cs.readMode = 0;
1609 	cs.maxLinesAtOnce = 10240;
1610 	cs.trimLineOverBytes = 0;
1611 ENDbeginCnfLoad
1612 BEGINsetModCnf
1613 	struct cnfparamvals *pvals = NULL;
1614 	int i;
1615 CODESTARTsetModCnf
1616 	#if defined(HAVE_PORT_SOURCE_FILE)
1617 		loadModConf-&gt;opMode = OPMODE_FEN;
1618 	#elif defined(HAVE_INOTIFY_INIT)
1619 		loadModConf-&gt;opMode = OPMODE_INOTIFY;
1620 <a name="1"></a>	#else
1621 		loadModConf-&gt;opMode = OPMODE_POLLING;
1622 	#endif
1623 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
1624 	if(pvals == NULL) {
1625 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
1626 				"config parameters [module(...)]");
1627 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1628 	}
1629 	if(Debug) {
1630 		DBGPRINTF("module (global) param blk for imfile:\n");
1631 		cnfparamsPrint(&amp;modpblk, pvals);
1632 	}
1633 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
1634 		if(!pvals[i].bUsed)
1635 			continue;
1636 <a name="3"></a>		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
1637 			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
1638 		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
1639 			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;</b></font><font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
1640 		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
1641 			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
1642 		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
1643 			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;</b></font>
1644 		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
1645 			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1646 		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
1647 			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
1648 		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
1649 			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
1650 				loadModConf-&gt;opMode = OPMODE_POLLING;
1651 			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
1652 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 				loadModConf-&gt;opMode = OPMODE_FEN;
1653 				DBGPRINTF("inotify mode configured, but only FEN "
1654 					"is available on OS SOLARIS. Switching to FEN "
1655 					"Mode automatically\n");
1656 #else
1657 				#if defined(HAVE_INOTIFY_INIT)
1658 					loadModConf-&gt;opMode = OPMODE_INOTIFY;
1659 				#else
1660 					loadModConf-&gt;opMode = OPMODE_POLLING;
1661 				#endif
1662 #endif
1663 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
1664 				loadModConf-&gt;opMode = OPMODE_FEN;
1665 			else {
1666 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
1667 				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
1668 					"mode '%s'", cstr);
1669 				free(cstr);
1670 			}
1671 		} else {
1672 			DBGPRINTF("program error, non-handled "
1673 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
1674 		}
1675 	}
1676 	bLegacyCnfModGlobalsPermitted = 0;
1677 	loadModConf-&gt;configSetViaV2Method = 1;
1678 finalize_it:
1679 	if(pvals != NULL)
1680 		cnfparamvalsDestruct(pvals, &amp;modpblk);
1681 ENDsetModCnf
1682 BEGINendCnfLoad
1683 CODESTARTendCnfLoad
1684 	if(!loadModConf-&gt;configSetViaV2Method) {
1685 		loadModConf-&gt;iPollInterval = cs.iPollInterval;
1686 	}
1687 	DBGPRINTF("opmode is %d, polling interval is %d\n",
1688 		  loadModConf-&gt;opMode,
1689 		  loadModConf-&gt;iPollInterval);
1690 	loadModConf = NULL; 	free(cs.pszFileName);
1691 	free(cs.pszFileTag);
1692 	free(cs.pszStateFile);
1693 ENDendCnfLoad
1694 BEGINcheckCnf
1695 	instanceConf_t *inst;
1696 CODESTARTcheckCnf
1697 	if(getStateFileDir() == NULL) {
1698 		LogError(0, RS_RET_NO_WRKDIR_SET,
1699 			"imfile: no working or state file directory set, imfile will create "
1700 			"state files in the current working directory (probably "
1701 			"the root dir). Use global(workDirectory=\"/some/path\") "
1702 			"to set the working directory");
1703 	}
1704 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1705 		std_checkRuleset(pModConf, inst);
1706 	}
1707 	if(pModConf-&gt;root == NULL) {
1708 		LogError(0, RS_RET_NO_LISTNERS,
1709 				"imfile: no files configured to be monitored - "
1710 				"no input will be gathered");
1711 		iRet = RS_RET_NO_LISTNERS;
1712 	}
1713 ENDcheckCnf
1714 BEGINactivateCnf
1715 	instanceConf_t *inst;
1716 CODESTARTactivateCnf
1717 	runModConf = pModConf;
1718 	currModConf = pModConf;
1719 	if(runModConf-&gt;root == NULL) {
1720 		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
1721 				"input not activated.\n");
1722 		ABORT_FINALIZE(RS_RET_NO_RUN);
1723 	}
1724 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1725 		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
1726 			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
1727 				LogError(errno, RS_RET_ERR,
1728 					"imfile: on startup file '%s' does not exist "
1729 					"but is configured in static file monitor - this "
1730 					"may indicate a misconfiguration. If the file "
1731 					"appears at a later time, it will automatically "
1732 					"be processed. Reason", inst-&gt;pszFileName);
1733 			}
1734 		}
1735 		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
1736 	}
1737 	if(Debug) {
1738 		fs_node_print(runModConf-&gt;conf_tree, 0);
1739 	}
1740 finalize_it:
1741 ENDactivateCnf
1742 BEGINfreeCnf
1743 	instanceConf_t *inst, *del;
1744 CODESTARTfreeCnf
1745 	fs_node_destroy(pModConf-&gt;conf_tree);
1746 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
1747 		free(inst-&gt;pszBindRuleset);
1748 		free(inst-&gt;pszFileName);
1749 		free(inst-&gt;pszTag);
1750 		free(inst-&gt;pszStateFile);
1751 		free(inst-&gt;pszFileName_forOldStateFile);
1752 		if(inst-&gt;startRegex != NULL) {
1753 			regfree(&amp;inst-&gt;start_preg);
1754 			free(inst-&gt;startRegex);
1755 		}
1756 		if(inst-&gt;endRegex != NULL) {
1757 			regfree(&amp;inst-&gt;end_preg);
1758 			free(inst-&gt;endRegex);
1759 		}
1760 		del = inst;
1761 		inst = inst-&gt;next;
1762 		free(del);
1763 	}
1764 ENDfreeCnf
1765 static void
1766 do_initial_poll_run(void)
1767 {
1768 	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1769 	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1770 		inst-&gt;freshStartTail = 0;
1771 	}
1772 }
1773 static rsRetVal
1774 doPolling(void)
1775 {
1776 	DEFiRet;
1777 	do_initial_poll_run();
1778 	while(glbl.GetGlobalInputTermState() == 0) {
1779 		DBGPRINTF("doPolling: new poll run\n");
1780 		do {
1781 			runModConf-&gt;bHadFileData = 0;
1782 			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1783 			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
1784 		} while(runModConf-&gt;bHadFileData); 
1785 		DBGPRINTF("doPolling: poll going to sleep\n");
1786 		if(glbl.GetGlobalInputTermState() == 0)
1787 			srSleep(runModConf-&gt;iPollInterval, 10);
1788 	}
1789 	RETiRet;
1790 }
1791 #if defined(HAVE_INOTIFY_INIT)
1792 static void ATTR_NONNULL(1)
1793 in_dbg_showEv(const struct inotify_event *ev)
1794 {
1795 	if(!Debug)
1796 		return;
1797 	if(ev-&gt;mask &amp; IN_IGNORED) {
1798 		dbgprintf("INOTIFY event: watch was REMOVED\n");
1799 	}
1800 	if(ev-&gt;mask &amp; IN_MODIFY) {
1801 		dbgprintf("INOTIFY event: watch was MODIFID\n");
1802 	}
1803 	if(ev-&gt;mask &amp; IN_ACCESS) {
1804 		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
1805 	}
1806 	if(ev-&gt;mask &amp; IN_ATTRIB) {
1807 		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
1808 	}
1809 	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
1810 		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
1811 	}
1812 	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
1813 		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
1814 	}
1815 	if(ev-&gt;mask &amp; IN_CREATE) {
1816 		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
1817 	}
1818 	if(ev-&gt;mask &amp; IN_DELETE) {
1819 		dbgprintf("INOTIFY event: watch IN_DELETE\n");
1820 	}
1821 	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
1822 		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
1823 	}
1824 	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
1825 		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
1826 	}
1827 	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
1828 		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1829 	}
1830 	if(ev-&gt;mask &amp; IN_MOVED_TO) {
1831 		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1832 	}
1833 	if(ev-&gt;mask &amp; IN_OPEN) {
1834 		dbgprintf("INOTIFY event: watch IN_OPEN\n");
1835 	}
1836 	if(ev-&gt;mask &amp; IN_ISDIR) {
1837 		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
1838 	}
1839 }
1840 static void ATTR_NONNULL(1, 2)
1841 in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
1842 {
1843 	if(ev-&gt;mask &amp; IN_MODIFY) {
1844 		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
1845 		pollFile(etry-&gt;act);
1846 	} else {
1847 		DBGPRINTF("got non-expected inotify event:\n");
1848 		in_dbg_showEv(ev);
1849 	}
1850 }
1851 static void
1852 flag_in_move(fs_edge_t *const edge, const char *name_moved)
1853 {
1854 	act_obj_t *act;
1855 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
1856 		DBGPRINTF("checking active object %s\n", act-&gt;basename);
1857 		if(!strcmp(act-&gt;basename, name_moved)){
1858 			DBGPRINTF("found file\n");
1859 			act-&gt;in_move = 1;
1860 			break;
1861 		} else {
1862 			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
1863 		}
1864 	}
1865 	if (!act &amp;&amp; edge-&gt;next) {
1866 		flag_in_move(edge-&gt;next, name_moved);
1867 	}
1868 }
1869 static void ATTR_NONNULL(1)
1870 in_processEvent(struct inotify_event *ev)
1871 {
1872 	if(ev-&gt;mask &amp; IN_IGNORED) {
1873 		DBGPRINTF("imfile: got IN_IGNORED event\n");
1874 		goto done;
1875 	}
1876 	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
1877 	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
1878 	if(etry == NULL) {
1879 		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
1880 			"inotify provided watch descriptor %d which we could not find "
1881 			"in our tables - ignored", ev-&gt;wd);
1882 		goto done;
1883 	}
1884 	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
1885 		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);
1886 	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
1887 		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
1888 	}
1889 	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
1890 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1891 	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
1892 		in_handleFileEvent(ev, etry); 	} else {
1893 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1894 	}
1895 done:	return;
1896 }
1897 static rsRetVal
1898 do_inotify(void)
1899 {
1900 	char iobuf[8192];
1901 	int rd;
1902 	int currev;
1903 	static int last_timeout = 0;
1904 	struct pollfd pollfd;
1905 	DEFiRet;
1906 	CHKiRet(wdmapInit());
1907 	ino_fd = inotify_init1(IN_NONBLOCK);
1908 	if(ino_fd &lt; 0) {
1909 		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
1910 			"instance failed ");
1911 		return RS_RET_INOTIFY_INIT_FAILED;
1912 	}
1913 	DBGPRINTF("inotify fd %d\n", ino_fd);
1914 	do_initial_poll_run();
1915 	while(glbl.GetGlobalInputTermState() == 0) {
1916 		int r;
1917 		pollfd.fd = ino_fd;
1918 		pollfd.events = POLLIN;
1919 		if (runModConf-&gt;haveReadTimeouts)
1920 			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
1921 		else
1922 			r = poll(&amp;pollfd, 1, -1);
1923 		if (r  == -1 &amp;&amp; errno == EINTR) {
1924 			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
1925 			continue;
1926 		}
1927 		if(r == 0) {
1928 			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
1929 			if (runModConf-&gt;haveReadTimeouts) {
1930 				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1931 				last_timeout = time(NULL);
1932 			}
1933 			continue;
1934 		} else if (r == -1) {
1935 			LogError(errno, RS_RET_INTERNAL_ERROR,
1936 					"%s:%d: unexpected error during poll timeout wait",
1937 					__FILE__, __LINE__);
1938 			continue;
1939 		} else if(r != 1) {
1940 			LogError(errno, RS_RET_INTERNAL_ERROR,
1941 					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
1942 					__FILE__, __LINE__, r);
1943 			continue;
1944 		}
1945 		else {
1946 			if(runModConf-&gt;haveReadTimeouts) {
1947 				int now = time(NULL);
1948 				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
1949 					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1950 					last_timeout = time(NULL);
1951 				}
1952 			}
1953 			rd = read(ino_fd, iobuf, sizeof(iobuf));
1954 			if(rd == -1 &amp;&amp; errno == EINTR) {
1955 				DBGPRINTF("EINTR received during inotify, restarting poll\n");
1956 				continue;
1957 			}
1958 			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
1959 				continue;
1960 			}
1961 			if(rd &lt; 0) {
1962 				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
1963 				continue;
1964 			}
1965 			currev = 0;
1966 			while(currev &lt; rd) {
1967 				union {
1968 					char *buf;
1969 					struct inotify_event *ev;
1970 				} savecast;
1971 				savecast.buf = iobuf+currev;
1972 				in_dbg_showEv(savecast.ev);
1973 				in_processEvent(savecast.ev);
1974 				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
1975 			}
1976 		}
1977 	}
1978 finalize_it:
1979 	close(ino_fd);
1980 	RETiRet;
1981 }
1982 #else static rsRetVal
1983 do_inotify(void)
1984 {
1985 	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
1986 			"platform does not support inotify");
1987 	return RS_RET_NOT_IMPLEMENTED;
1988 }
1989 #endif 
1990 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) static void
1991 fen_printevent(int event)
1992 {
1993 	if (event &amp; FILE_ACCESS) {
1994 		DBGPRINTF(" FILE_ACCESS");
1995 	}
1996 	if (event &amp; FILE_MODIFIED) {
1997 		DBGPRINTF(" FILE_MODIFIED");
1998 	}
1999 	if (event &amp; FILE_ATTRIB) {
2000 		DBGPRINTF(" FILE_ATTRIB");
2001 	}
2002 	if (event &amp; FILE_DELETE) {
2003 		DBGPRINTF(" FILE_DELETE");
2004 	}
2005 	if (event &amp; FILE_RENAME_TO) {
2006 		DBGPRINTF(" FILE_RENAME_TO");
2007 	}
2008 	if (event &amp; FILE_RENAME_FROM) {
2009 		DBGPRINTF(" FILE_RENAME_FROM");
2010 	}
2011 	if (event &amp; UNMOUNTED) {
2012 		DBGPRINTF(" UNMOUNTED");
2013 	}
2014 	if (event &amp; MOUNTEDOVER) {
2015 		DBGPRINTF(" MOUNTEDOVER");
2016 	}
2017 }
2018 static rsRetVal
2019 do_fen(void)
2020 {
2021 	port_event_t portEvent;
2022 	struct timespec timeout;
2023 	DEFiRet;
2024 	timeout.tv_sec = 300;
2025 	timeout.tv_nsec = 0;
2026 	if((glport = port_create()) == -1) {
2027 		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
2028 		return RS_RET_FEN_INIT_FAILED;
2029 	}
2030 	do_initial_poll_run();
2031 	DBGPRINTF("do_fen ENTER monitoring loop \n");
2032 	while(glbl.GetGlobalInputTermState() == 0) {
2033 		DBGPRINTF("do_fen loop begin... \n");
2034 		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { 			DBGPRINTF("do_fen: received port event with ");
2035 			fen_printevent((int) portEvent.portev_events);
2036 			DBGPRINTF("\n");
2037 			if(portEvent.portev_source != PORT_SOURCE_FILE) {
2038 				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
2039 					": %d\n", portEvent.portev_source);
2040 				continue;
2041 			}
2042 			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
2043 			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
2044 				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
2045 				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
2046 			if(act-&gt;is_deleted) {
2047 				free(act-&gt;name);
2048 				free(act);
2049 				continue;
2050 			}
2051 			act-&gt;bPortAssociated = 0;
2052 			fen_setupWatch(act);
2053 			if(act-&gt;edge-&gt;is_file) {
2054 				pollFile(act);
2055 			} else {
2056 				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
2057 			}
2058 		}
2059 	}
2060 	close(glport);
2061 	RETiRet;
2062 }
2063 #else static rsRetVal
2064 do_fen(void)
2065 {
2066 	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
2067 			"platform does not support fen");
2068 	return RS_RET_NOT_IMPLEMENTED;
2069 }
2070 #endif 
2071 BEGINrunInput
2072 CODESTARTrunInput
2073 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
2074 		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
2075 		runModConf-&gt;opMode = OPMODE_FEN;
2076 	}
2077 	#endif
2078 	DBGPRINTF("working in %s mode\n",
2079 		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
2080 			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
2081 	if(runModConf-&gt;opMode == OPMODE_POLLING)
2082 		iRet = doPolling();
2083 	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
2084 		iRet = do_inotify();
2085 	else if(runModConf-&gt;opMode == OPMODE_FEN)
2086 		iRet = do_fen();
2087 	else {
2088 		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
2089 			runModConf-&gt;opMode);
2090 		return RS_RET_NOT_IMPLEMENTED;
2091 	}
2092 	DBGPRINTF("terminating upon request of rsyslog core\n");
2093 ENDrunInput
2094 BEGINwillRun
2095 CODESTARTwillRun
2096 	CHKiRet(prop.Construct(&amp;pInputName));
2097 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
2098 	CHKiRet(prop.ConstructFinalize(pInputName));
2099 finalize_it:
2100 ENDwillRun
2101 static rsRetVal ATTR_NONNULL()
2102 atomicWriteStateFile(const char *fn, const char *content)
2103 {
2104 	DEFiRet;
2105 	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
2106 	if(fd &lt; 0) {
2107 		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
2108 			"persisting file state - some data will probably be duplicated "
2109 			"on next startup", fn);
2110 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2111 	}
2112 	const size_t toWrite = strlen(content);
2113 	const ssize_t w = write(fd, content, toWrite);
2114 	if(w != (ssize_t) toWrite) {
2115 		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
2116 			"this may cause trouble in the future. We will try to delete the "
2117 			"state file, as this provides most consistent state", fn);
2118 		unlink(fn);
2119 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2120 	}
2121 finalize_it:
2122 	if(fd &gt;= 0) {
2123 		close(fd);
2124 	}
2125 	RETiRet;
2126 }
2127 static void
2128 removeOldStatefile(const uchar *statefn, const char *hashToDelete)
2129 {
2130 	int ret;
2131 	uchar statefname[MAXFNAME];
2132 	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
2133 	DBGPRINTF("removing old state file: '%s'\n", statefname);
2134 	ret = unlink((const char*)statefname);
2135 	if(ret != 0) {
2136 		if (errno != ENOENT) {
2137 			LogError(errno, RS_RET_IO_ERROR,
2138 				"imfile error trying to delete old state file: '%s' - ignoring this "
2139 				"error, usually this means a file no longer file is left over, but "
2140 				"this may also cause some real trouble. Still the best we can do ",
2141 				statefname);
2142 		} else {
2143 			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
2144 					  "longer exists (probably already deleted)\n", statefname);
2145 		}
2146 	}
2147 }
2148 static rsRetVal ATTR_NONNULL()
2149 persistStrmState(act_obj_t *const act)
2150 {
2151 	DEFiRet;
2152 	uchar statefile[MAXFNAME];
2153 	uchar statefname[MAXFNAME];
2154 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
2155 	getFileID(act);
2156 	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
2157 	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);
2158 	struct json_object *jval = NULL;
2159 	struct json_object *json = NULL;
2160 	CHKmalloc(json = json_object_new_object());
2161 	jval = json_object_new_string((char*) act-&gt;name);
2162 	json_object_object_add(json, "filename", jval);
2163 	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
2164 	json_object_object_add(json, "prev_was_nl", jval);
2165 	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
2166 	json_object_object_add(json, "curr_offs", jval);
2167 	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
2168 	json_object_object_add(json, "strt_offs", jval);
2169 	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
2170 	if(prevLineSegment != NULL) {
2171 		jval = json_object_new_string((const char*) prevLineSegment);
2172 		json_object_object_add(json, "prev_line_segment", jval);
2173 	}
2174 	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
2175 	if(prevMsgSegment != NULL) {
2176 		jval = json_object_new_string((const char*) prevMsgSegment);
2177 		json_object_object_add(json, "prev_msg_segment", jval);
2178 	}
2179 	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);
2180 	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
2181 	json_object_put(json);
2182 	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
2183 		removeOldStatefile(statefn, act-&gt;file_id_prev);
2184 	}
2185 finalize_it:
2186 	if(iRet != RS_RET_OK) {
2187 		LogError(0, iRet, "imfile: could not persist state "
2188 				"file %s - data may be repeated on next "
2189 				"startup. Is WorkDirectory set?",
2190 				statefname);
2191 	}
2192 	RETiRet;
2193 }
2194 BEGINafterRun
2195 CODESTARTafterRun
2196 	if(pInputName != NULL)
2197 		prop.Destruct(&amp;pInputName);
2198 ENDafterRun
2199 BEGINisCompatibleWithFeature
2200 CODESTARTisCompatibleWithFeature
2201 	if(eFeat == sFEATURENonCancelInputTermination)
2202 		iRet = RS_RET_OK;
2203 ENDisCompatibleWithFeature
2204 BEGINmodExit
2205 CODESTARTmodExit
2206 	objRelease(strm, CORE_COMPONENT);
2207 	objRelease(glbl, CORE_COMPONENT);
2208 	objRelease(prop, CORE_COMPONENT);
2209 	objRelease(ruleset, CORE_COMPONENT);
2210 	objRelease(datetime, CORE_COMPONENT);
2211 	#ifdef HAVE_INOTIFY_INIT
2212 	free(wdmap);
2213 	#endif
2214 ENDmodExit
2215 BEGINqueryEtryPt
2216 CODESTARTqueryEtryPt
2217 CODEqueryEtryPt_STD_IMOD_QUERIES
2218 CODEqueryEtryPt_STD_CONF2_QUERIES
2219 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
2220 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
2221 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
2222 ENDqueryEtryPt
2223 static rsRetVal
2224 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
2225 {
2226 	DEFiRet;
2227 	free(cs.pszFileName);
2228 	cs.pszFileName = NULL;
2229 	free(cs.pszFileTag);
2230 	cs.pszFileTag = NULL;
2231 	free(cs.pszStateFile);
2232 	cs.pszStateFile = NULL;
2233 	cs.iPollInterval = DFLT_PollInterval;
2234 	cs.iFacility = 128; 	cs.iSeverity = 5;  	cs.readMode = 0;
2235 	cs.maxLinesAtOnce = 10240;
2236 	cs.trimLineOverBytes = 0;
2237 	RETiRet;
2238 }
2239 static inline void
2240 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
2241 {
2242 	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
2243 			"using default ruleset instead", inst-&gt;pszBindRuleset,
2244 			inst-&gt;pszFileName);
2245 }
2246 BEGINmodInit()
2247 CODESTARTmodInit
2248 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
2249 	CHKiRet(objUse(glbl, CORE_COMPONENT));
2250 	CHKiRet(objUse(strm, CORE_COMPONENT));
2251 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
2252 	CHKiRet(objUse(prop, CORE_COMPONENT));
2253 	CHKiRet(objUse(datetime, CORE_COMPONENT));
2254 	DBGPRINTF("version %s initializing\n", VERSION);
2255 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
2256 	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
2257 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
2258 	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
2259 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
2260 	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
2261 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
2262 	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
2263 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
2264 	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
2265 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
2266 	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
2267 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
2268 	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
2269 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
2270 	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
2271 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
2272 	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
2273 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
2274 		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
2275 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
2276 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
2277 	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
2278 	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
2279 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
2280 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
2281 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
