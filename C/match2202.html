<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imjournal.c & imfile.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imjournal.c & imfile.c
      </h3>
      <h1 align="center">
        5.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imjournal.c (10.493827%)<TH>imfile.c (3.492194%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2202-0.html#0',2,'match2202-1.html#0',3)" NAME="0">(94-118)<TD><A HREF="javascript:ZweiFrames('match2202-0.html#0',2,'match2202-1.html#0',3)" NAME="0">(339-369)</A><TD ALIGN=center><FONT COLOR="#ff0000">36</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2202-0.html#1',2,'match2202-1.html#1',3)" NAME="1">(1019-1037)<TD><A HREF="javascript:ZweiFrames('match2202-0.html#1',2,'match2202-1.html#1',3)" NAME="1">(2094-2112)</A><TD ALIGN=center><FONT COLOR="#aa0000">24</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2202-0.html#2',2,'match2202-1.html#2',3)" NAME="2">(892-904)<TD><A HREF="javascript:ZweiFrames('match2202-0.html#2',2,'match2202-1.html#2',3)" NAME="2">(1891-1902)</A><TD ALIGN=center><FONT COLOR="#5c0000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2202-0.html#3',2,'match2202-1.html#3',3)" NAME="3">(1041-1045)<TD><A HREF="javascript:ZweiFrames('match2202-0.html#3',2,'match2202-1.html#3',3)" NAME="3">(2112-2117)</A><TD ALIGN=center><FONT COLOR="#550000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imjournal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* The systemd journal import module
 *
 * To test under Linux:
 * emmit log message into systemd journal
 *
 * Copyright (C) 2008-2019 Adiscon GmbH
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/poll.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;errno.h&gt;
#include &lt;systemd/sd-journal.h&gt;

#include &quot;dirty.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;obj.h&quot;
#include &quot;msg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;datetime.h&quot;
#include &quot;net.h&quot;
#include &quot;glbl.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;parser.h&quot;
#include &quot;prop.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;ratelimit.h&quot;


MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imjournal&quot;)

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(datetime)
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
DEFobjCurrIf(statsobj)

struct modConfData_s {
	rsconf_t *pConf;
	int bIgnPrevMsg;
};

static struct configSettings_s {
	char *stateFile;
	int iPersistStateInterval;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	int bIgnorePrevious;
	int bIgnoreNonValidStatefile;
	int iDfltSeverity;
	int iDfltFacility;
	int bUseJnlPID;
	char *usePid;
	int bWorkAroundJournalBug; /* deprecated, left for backwards compatibility only */
	int bFsync;
	int bRemote;
} cs;

static rsRetVal facilityHdlr(uchar **pp, void *pVal);
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2202-1.html#0',3,'match2202-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;statefile&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;ratelimit.interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ratelimit.burst&quot;, eCmdHdlrInt, 0 },
	{ &quot;persiststateinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ignorepreviousmessages&quot;, eCmdHdlrBinary, 0 },
	{ &quot;ignorenonvalidstatefile&quot;, eCmdHdlrBinary, 0 },
	{ &quot;defaultseverity&quot;, eCmdHdlrSeverity, 0 },
	{ &quot;defaultfacility&quot;, eCmdHdlrString, 0 },
	{ &quot;usepidfromsystem&quot;, eCmdHdlrBinary, 0 },
	{ &quot;usepid&quot;, eCmdHdlrString, 0 },
	{ &quot;workaroundjournalbug&quot;, eCmdHdlrBinary, 0 },
	{ &quot;fsync&quot;, eCmdHdlrBinary, 0 },
	{ &quot;remote&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

#define DFLT_persiststateinterval 10
#define DFLT_SEVERITY pri2sev(LOG_NOTICE)
#define DFLT_FACILITY pri2fac(LOG_USER)

static int bLegacyCnfModGlobalsPermitted = 1;/* are legacy module-global config parameters permitted? */</B></FONT>

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this module */
static prop_t *pLocalHostIP = NULL;	/* a pseudo-constant propterty for 127.0.0.1 */
static const char *pidFieldName;	/* read-only after startup */
static int bPidFallBack;
static ratelimit_t *ratelimiter = NULL;
static struct {
	statsobj_t *stats;
	STATSCOUNTER_DEF(ctrSubmitted, mutCtrSubmitted)
	STATSCOUNTER_DEF(ctrRead, mutCtrRead);
	STATSCOUNTER_DEF(ctrDiscarded, mutCtrDiscarded);
	STATSCOUNTER_DEF(ctrFailed, mutCtrFailed);
	STATSCOUNTER_DEF(ctrPollFailed, mutCtrPollFailed);
	STATSCOUNTER_DEF(ctrRotations, mutCtrRotations);
	STATSCOUNTER_DEF(ctrRecoveryAttempts, mutCtrRecoveryAttempts);
	uint64 ratelimitDiscardedInInterval;
	uint64 diskUsageBytes;
} statsCounter;
struct journalContext_s { /* structure encapsulating all the journald_API-related stuff  */
	sd_journal *j; /* main object encapsulating journal for us, has to be used in every sd_journal*() call */
	sbool reloaded; /* we have reloaded journal after detecting rotation */
	sbool atHead; /* true if we are at start of journal (no seek was done) */
	char *cursor; /* should point to last valid journald entry we processed */
};
static struct journalContext_s journalContext = {NULL, 0, 1, NULL};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for run process */

#define J_PROCESS_PERIOD 1024  /* Call sd_journal_process() every 1,024 records */

static rsRetVal persistJournalState(void);
static rsRetVal loadJournalState(void);

static rsRetVal openJournal(void) {
	int r;
	DEFiRet;

	if (journalContext.j) {
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, &quot;imjournal: opening journal when already opened.\n&quot;);
	}
	if ((r = sd_journal_open(&amp;journalContext.j, cs.bRemote? 0 : SD_JOURNAL_LOCAL_ONLY)) &lt; 0) {
		LogError(-r, RS_RET_IO_ERROR, &quot;imjournal: sd_journal_open() failed&quot;);
		iRet = RS_RET_IO_ERROR;
	}
	if ((r = sd_journal_set_data_threshold(journalContext.j, glbl.GetMaxLine(runModConf-&gt;pConf))) &lt; 0) {
		LogError(-r, RS_RET_IO_ERROR, &quot;imjournal: sd_journal_set_data_threshold() failed&quot;);
		iRet = RS_RET_IO_ERROR;
	}
	journalContext.atHead = 1;
	RETiRet;
}

/* trySave shoulod only be true if there is no journald error preceeding this call */
static void closeJournal(void) {
	if (!journalContext.j) {
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, &quot;imjournal: closing NULL journal.\n&quot;);
	}
	sd_journal_close(journalContext.j);
	journalContext.j = NULL; /* setting to NULL here as journald API will not do that for us... */
}

static int journalGetData(const char *field, const void **data, size_t *length)
{
	int ret;

	ret = sd_journal_get_data(journalContext.j, field, data, length);
	if (ret == -EADDRNOTAVAIL) {
		LogError(-ret, RS_RET_ERR, &quot;imjournal: Tried to get data without a 'next' call.\n&quot;);
		if ((ret = sd_journal_next(journalContext.j)) &lt; 0) {
			LogError(-ret, RS_RET_ERR, &quot;imjournal: sd_journal_next() failed\n&quot;);
		} else {
			ret = sd_journal_get_data(journalContext.j, field, data, length);
		}
	}

	return ret;
}


/* ugly workaround to handle facility numbers; values
 * derived from names need to be eight times smaller,
 * i.e.: 0..23
 */
static rsRetVal facilityHdlr(uchar **pp, void *pVal)
{
	DEFiRet;
	char *p;

	skipWhiteSpace(pp);
	p = (char *) *pp;

	if (isdigit((int) *p)) {
		*((int *) pVal) = (int) strtol(p, (char **) pp, 10);
	} else {
		int len;
		syslogName_t *c;

		for (len = 0; p[len] &amp;&amp; !isspace((int) p[len]); len++)
			/* noop */;
		for (c = syslogFacNames; c-&gt;c_name; c++) {
			if (!strncasecmp(p, (char *) c-&gt;c_name, len)) {
				*((int *) pVal) = pri2fac(c-&gt;c_val);
				break;
			}
		}
		*pp += len;
	}

	RETiRet;
}


/* Currently just replaces '\0' with ' '. Not doing so would cause
 * the value to be truncated. New space is allocated for the resulting
 * string.
 */
static rsRetVal
sanitizeValue(const char *in, size_t len, char **out)
{
	char *buf, *p;
	DEFiRet;

	CHKmalloc(p = buf = malloc(len + 1));
	memcpy(buf, in, len);
	buf[len] = '\0';

	while ((p = memchr(p, '\0', len + buf - p)) != NULL) {
		*p++ = ' ';
	}

	*out = buf;

finalize_it:
	RETiRet;
}


/* Read JSON part of single journald message and return it as JSON object
 */
static rsRetVal
readJSONfromJournalMsg(struct fjson_object **json)
{
	DEFiRet;
	const void *get;
	const void *equal_sign;
	struct fjson_object *jval;
	size_t l;
	long prefixlen = 0;

	CHKmalloc(*json = fjson_object_new_object());

	SD_JOURNAL_FOREACH_DATA(journalContext.j, get, l) {
		char *data;
		char *name;

		/* locate equal sign, this is always present */
		equal_sign = memchr(get, '=', l);

		/* ... but we know better than to trust the specs */
		if (equal_sign == NULL) {
			LogError(0, RS_RET_ERR, &quot;SD_JOURNAL_FOREACH_DATA()&quot;
				&quot;returned a malformed field (has no '='): '%s'&quot;, (char*)get);
			continue; /* skip the entry */
		}

		/* get length of journal data prefix */
		prefixlen = ((char *)equal_sign - (char *)get);

		CHKmalloc(name = strndup(get, prefixlen));

		prefixlen++; /* remove '=' */

		CHKiRet_Hdlr(sanitizeValue(((const char *)get) + prefixlen, l - prefixlen, &amp;data)) {
			free (name);
			FINALIZE;
		}

		/* and save them to json object */
		jval = fjson_object_new_string((char *)data);
		fjson_object_object_add(*json, name, jval);
		free (data);
		free (name);
	}
finalize_it:
	RETiRet;
}


/* Try to obtain current journald cursor and save it to journalContext struct.
 */
static rsRetVal
updateJournalCursor(void)
{
	DEFiRet;
	char *c = NULL;
	int r;

	if ((r = sd_journal_get_cursor(journalContext.j, &amp;c)) &lt; 0) {
		LogError(-r, RS_RET_ERR, &quot;imjournal: Could not get journald cursor!\n&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	/* save journal cursor (at this point we can be sure it is valid) */
	free(journalContext.cursor);
	journalContext.cursor = c;
finalize_it:
	RETiRet;
}


/* enqueue the the journal message into the message queue.
 * The provided msg string is not freed - thus must be done
 * by the caller.
 */
static rsRetVal
enqMsg(uchar *msg, uchar *pszTag, int iFacility, int iSeverity, struct timeval *tp, struct fjson_object *json,
int sharedJsonProperties)
{
	struct syslogTime st;
	smsg_t *pMsg;
	size_t len;
	DEFiRet;

	assert(msg != NULL);
	assert(pszTag != NULL);

	if(tp == NULL) {
		CHKiRet(msgConstruct(&amp;pMsg));
	} else {
		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
	}
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetInputName(pMsg, pInputName);
	len = strlen((char*)msg);
	MsgSetRawMsg(pMsg, (char*)msg, len);
	if(len &gt; 0)
		parser.SanitizeMsg(pMsg);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, pLocalHostIP);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
	pMsg-&gt;iFacility = iFacility;
	pMsg-&gt;iSeverity = iSeverity;

	if(json != NULL) {
		msgAddJSON(pMsg, (uchar*)&quot;!&quot;, json, 0, sharedJsonProperties);
	}

	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
	STATSCOUNTER_INC(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);

finalize_it:
	if (iRet == RS_RET_DISCARDMSG) {
		STATSCOUNTER_INC(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	} else if (iRet != RS_RET_OK) {
		LogError(0, RS_RET_ERR, &quot;imjournal: error during enqMsg().\n&quot;);
	}

	RETiRet;
}


/* Read journal log while data are available, each read() reads one journald record.
 */
static rsRetVal
readjournal(void)
{
	DEFiRet;

	struct timeval tv;
	uint64_t timestamp;

	struct fjson_object *json = NULL;
	int r;

	/* Information from messages */
	char *message = NULL;
	char *sys_iden;
	char *sys_iden_help = NULL;

	const void *get;
	const void *pidget;
	size_t length;
	size_t pidlength;

	int severity = cs.iDfltSeverity;
	int facility = cs.iDfltFacility;

	/* Get message text */
	if (journalGetData(&quot;MESSAGE&quot;, &amp;get, &amp;length) &lt; 0) {
		CHKmalloc(message = strdup(&quot;&quot;));
	} else {
		CHKiRet(sanitizeValue(((const char *)get) + 8, length - 8, &amp;message));
	}
	STATSCOUNTER_INC(statsCounter.ctrRead, statsCounter.mutCtrRead);

	/* Get message severity (&quot;priority&quot; in journald's terminology) */
	if (journalGetData(&quot;PRIORITY&quot;, &amp;get, &amp;length) &gt;= 0) {
		if (length == 10) {
			severity = ((char *)get)[9] - '0';
			if (severity &lt; 0 || 7 &lt; severity) {
				LogError(0, RS_RET_ERR, &quot;imjournal: the value of the 'PRIORITY' field is &quot;
					&quot;out of bounds: %d, resetting&quot;, severity);
				severity = cs.iDfltSeverity;
			}
		} else {
			LogError(0, RS_RET_ERR, &quot;The value of the 'PRIORITY' field has an &quot;
				&quot;unexpected length: %zu\n&quot;, length);
		}
	}

	/* Get syslog facility */
	if (journalGetData(&quot;SYSLOG_FACILITY&quot;, &amp;get, &amp;length) &gt;= 0) {
		// Note: the journal frequently contains invalid facilities!
		if (length == 17 || length == 18) {
			facility = ((char *)get)[16] - '0';
			if (length == 18) {
				facility *= 10;
				facility += ((char *)get)[17] - '0';
			}
			if (facility &lt; 0 || 23 &lt; facility) {
				DBGPRINTF(&quot;The value of the 'FACILITY' field is &quot;
					&quot;out of bounds: %d, resetting\n&quot;, facility);
				facility = cs.iDfltFacility;
			}
		} else {
			DBGPRINTF(&quot;The value of the 'FACILITY' field has an &quot;
				&quot;unexpected length: %zu value: '%s'\n&quot;, length, (const char*)get);
		}
	}

	/* Get message identifier, client pid and add ':' */
	if (journalGetData(&quot;SYSLOG_IDENTIFIER&quot;, &amp;get, &amp;length) &gt;= 0) {
		CHKiRet(sanitizeValue(((const char *)get) + 18, length - 18, &amp;sys_iden));
	} else {
		CHKmalloc(sys_iden = strdup(&quot;journal&quot;));
	}

	/* trying to get PID, default is &quot;SYSLOG_PID&quot; property */
	if (journalGetData(pidFieldName, &amp;pidget, &amp;pidlength) &gt;= 0) {
		char *sys_pid;
		int val_ofs;

		val_ofs = strlen(pidFieldName) + 1; /* name + '=' */
		CHKiRet_Hdlr(sanitizeValue(((const char *)pidget) + val_ofs, pidlength - val_ofs, &amp;sys_pid)) {
			free (sys_iden);
			FINALIZE;
		}
		r = asprintf(&amp;sys_iden_help, &quot;%s[%s]:&quot;, sys_iden, sys_pid);
		free (sys_pid);
	} else {
		/* this is fallback, &quot;SYSLOG_PID&quot; doesn't exist so trying to get &quot;_PID&quot; property */
		if (bPidFallBack &amp;&amp; journalGetData(&quot;_PID&quot;, &amp;pidget, &amp;pidlength) &gt;= 0) {
			char *sys_pid;
			int val_ofs;

			val_ofs = strlen(&quot;_PID&quot;) + 1; /* name + '=' */
			CHKiRet_Hdlr(sanitizeValue(((const char *)pidget) + val_ofs, pidlength - val_ofs, &amp;sys_pid)) {
				free (sys_iden);
				FINALIZE;
			}
			r = asprintf(&amp;sys_iden_help, &quot;%s[%s]:&quot;, sys_iden, sys_pid);
			free (sys_pid);
		} else {
			/* there is no PID property available */
			r = asprintf(&amp;sys_iden_help, &quot;%s:&quot;, sys_iden);
		}
	}

	free (sys_iden);

	if (-1 == r) {
		STATSCOUNTER_INC(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	CHKiRet(readJSONfromJournalMsg(&amp;json));

	/* calculate timestamp */
	if (sd_journal_get_realtime_usec(journalContext.j, &amp;timestamp) &gt;= 0) {
		tv.tv_sec = timestamp / 1000000;
		tv.tv_usec = timestamp % 1000000;
	}

	iRet = updateJournalCursor();

	/* submit message */
	enqMsg((uchar *)message, (uchar *) sys_iden_help, facility, severity, &amp;tv, json, 0);

finalize_it:
	free(sys_iden_help);
	free(message);
	RETiRet;
}


/* This function saves journal cursor into state file.
 * It must be checked that stateFile is configured prior to calling this.
 */
static rsRetVal
persistJournalState(void)
{
	DEFiRet;
	FILE *sf = NULL; /* state file */
	char tmp_sf[MAXFNAME];

	DBGPRINTF(&quot;Persisting journal position, cursor: %s, at head? %d\n&quot;,
			  journalContext.cursor, journalContext.atHead);

	/* first check that we have valid cursor */
	if (!journalContext.cursor) {
		DBGPRINTF(&quot;Journal cursor is not valid, ok...\n&quot;);
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* we create a temporary name by adding a &quot;.tmp&quot;
	 * suffix to the end of our state file's name
	 *
	 * we use snprintf() to safely honor the boundaries
	 * of the temporary state file name buffer by using
	 * a precision specifier, which will limit the number
	 * of bytes taken from cs.stateFile to what will fit
	 *
	 * TODO: figure out a better way to avoid the PATH_MAX
	 * problem. The truncated cs.stateFile with .tmp at the
	 * end is not optimal
	 */
#define IM_SF_TMP_SUFFIX &quot;.tmp&quot;
	snprintf(tmp_sf, sizeof(tmp_sf), &quot;%.*s%s&quot;,
			/* this calculates the max size for state file name, note that
			 * sizeof() NOT -1 is intentional - it reserves spaces for the
			 * NUL terminator.
			 */
			(int)(sizeof(tmp_sf) - sizeof(IM_SF_TMP_SUFFIX)),
			cs.stateFile, IM_SF_TMP_SUFFIX);

	sf = fopen(tmp_sf, &quot;wb&quot;);
	if (sf == NULL) {
		LogError(errno, RS_RET_FOPEN_FAILURE, &quot;imjournal: fopen() failed for path: '%s'&quot;, tmp_sf);
		ABORT_FINALIZE(RS_RET_FOPEN_FAILURE);
	}

	if(fputs(journalContext.cursor, sf) == EOF) {
		LogError(errno, RS_RET_IO_ERROR, &quot;imjournal: failed to save cursor to: '%s'&quot;, tmp_sf);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	fflush(sf);

	/* change the name of the file to the configured one */
	if (rename(tmp_sf, cs.stateFile) &lt; 0) {
		LogError(errno, iRet, &quot;imjournal: rename() failed for new path: '%s'&quot;, cs.stateFile);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	if (cs.bFsync) {
		if (fsync(fileno(sf)) != 0) {
			LogError(errno, RS_RET_IO_ERROR, &quot;imjournal: fsync on '%s' failed&quot;, cs.stateFile);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		/* In order to guarantee physical write we need to force parent sync as well */
		DIR *wd;
		if (!(wd = opendir((char *)glbl.GetWorkDir(runModConf-&gt;pConf)))) {
			LogError(errno, RS_RET_IO_ERROR, &quot;imjournal: failed to open '%s' directory&quot;,
				glbl.GetWorkDir(runModConf-&gt;pConf));
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		if (fsync(dirfd(wd)) != 0) {
			LogError(errno, RS_RET_IO_ERROR, &quot;imjournal: fsync on '%s' failed&quot;,
				glbl.GetWorkDir(runModConf-&gt;pConf));
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}

		closedir(wd);
	}

	DBGPRINTF(&quot;Persisted journal to '%s'\n&quot;, cs.stateFile);

finalize_it:
	if (sf != NULL) {
		if (fclose(sf) == EOF) {
			LogError(errno, RS_RET_IO_ERROR, &quot;imjournal: fclose() failed for path: '%s'&quot;, tmp_sf);
			iRet = RS_RET_IO_ERROR;
		}
	}
	RETiRet;
}


static rsRetVal skipOldMessages(void);

static rsRetVal
handleRotation(void)
{
	DEFiRet;
	int r;

	LogMsg(0, RS_RET_OK, LOG_NOTICE, &quot;imjournal: journal files changed, reloading...\n&quot;);
	STATSCOUNTER_INC(statsCounter.ctrRotations, statsCounter.mutCtrRotations);
	closeJournal();

	iRet = openJournal();
	if (iRet != RS_RET_OK) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* outside error scenarios we should always have a cursor available at this point */
	if (!journalContext.cursor)
	{
		if (cs.stateFile) {
			iRet = loadJournalState();
		}
		else if (cs.bIgnorePrevious) {
			/* Seek to the very end of the journal and ignore all older messages. */
			iRet = skipOldMessages();
		}
		FINALIZE;
	}

	if (sd_journal_seek_cursor(journalContext.j, journalContext.cursor) != 0) {
		LogError(0, RS_RET_ERR, &quot;imjournal: &quot;
			&quot;couldn't seek to cursor `%s'\n&quot;, journalContext.cursor);
		iRet = RS_RET_ERR;
	}
	journalContext.atHead = 0;
	/* Need to advance because cursor points at last processed message */
	if ((r = sd_journal_next(journalContext.j)) &lt; 0) {
		LogError(-r, RS_RET_ERR, &quot;imjournal: sd_journal_next() failed&quot;);
		iRet = RS_RET_ERR;
	}

finalize_it:
	journalContext.reloaded = 1;
	RETiRet;
}

#define POLL_TIMEOUT 900000 /* timeout for poll is 900ms */

static rsRetVal
pollJournal(void)
{
	DEFiRet;
	int err;

	err = sd_journal_wait(journalContext.j, POLL_TIMEOUT);
	if (err == SD_JOURNAL_INVALIDATE &amp;&amp; !journalContext.reloaded) {
		CHKiRet(handleRotation());
	}
	else {
		journalContext.reloaded = 0;
	}

finalize_it:
	RETiRet;
}


static rsRetVal
skipOldMessages(void)
{
	int r;
	DEFiRet;

	if ((r = sd_journal_seek_tail(journalContext.j)) &lt; 0) {
		LogError(-r, RS_RET_ERR,
			&quot;imjournal: sd_journal_seek_tail() failed&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	journalContext.atHead = 0;
	if ((r = sd_journal_previous(journalContext.j)) &lt; 0) {
		LogError(-r, RS_RET_ERR,
			&quot;imjournal: sd_journal_previous() failed&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	RETiRet;
}

/* This function loads a journal cursor from the state file.
 */
static rsRetVal
loadJournalState(void)
{
	DEFiRet;
	int r;
	FILE *r_sf;

	DBGPRINTF(&quot;Loading journal position, at head? %d, reloaded? %d\n&quot;,
			  journalContext.atHead, journalContext.reloaded);

	/* if state file not exists (on very first run), skip */
	if (access(cs.stateFile, F_OK|R_OK) == -1 &amp;&amp; errno == ENOENT) {
		if (cs.bIgnorePrevious) {
			/* Seek to the very end of the journal and ignore all older messages. */
			skipOldMessages();
		}
		LogMsg(errno, RS_RET_FILE_NOT_FOUND, LOG_NOTICE, &quot;imjournal: No statefile exists, &quot;
				&quot;%s will be created (ignore if this is first run)&quot;, cs.stateFile);
		FINALIZE;
	}

	if ((r_sf = fopen(cs.stateFile, &quot;rb&quot;)) != NULL) {
		char readCursor[128 + 1];
		if (fscanf(r_sf, &quot;%128s\n&quot;, readCursor) != EOF) {
			if (sd_journal_seek_cursor(journalContext.j, readCursor) != 0) {
				LogError(0, RS_RET_ERR, &quot;imjournal: &quot;
					&quot;couldn't seek to cursor `%s'\n&quot;, readCursor);
				iRet = RS_RET_ERR;
			} else {
				journalContext.atHead = 0;
				char * tmp_cursor = NULL;
				sd_journal_next(journalContext.j);
				/*
				* This is resolving the situation when system is after reboot and boot_id
				* doesn't match so cursor pointing into &quot;future&quot;.
				* Usually sd_journal_next jump to head of journal due to journal aproximation,
				* but when system time goes backwards and cursor is still
				  invalid, rsyslog stops logging.
				* We use sd_journal_get_cursor to validate our cursor.
				* When cursor is invalid we are trying to jump to the head of journal
				* This problem with time should not affect persistent journal,
				* but if cursor has been intentionally compromised it could stop logging even
				* with persistent journal.
				* */
				if ((r = sd_journal_get_cursor(journalContext.j, &amp;tmp_cursor)) &lt; 0) {
					LogError(-r, RS_RET_IO_ERROR, &quot;imjournal: &quot;
					&quot;loaded invalid cursor, seeking to the head of journal\n&quot;);
					if ((r = sd_journal_seek_head(journalContext.j)) &lt; 0) {
						LogError(-r, RS_RET_ERR, &quot;imjournal: &quot;
						&quot;sd_journal_seek_head() failed, when cursor is invalid\n&quot;);
						iRet = RS_RET_ERR;
					}
					journalContext.atHead = 1;
				}
				free(tmp_cursor);
			}
		} else {
			LogError(0, RS_RET_IO_ERROR, &quot;imjournal: &quot;
				&quot;fscanf on state file `%s' failed\n&quot;, cs.stateFile);
			iRet = RS_RET_IO_ERROR;
		}

		fclose(r_sf);

		if (iRet != RS_RET_OK &amp;&amp; cs.bIgnoreNonValidStatefile) {
			/* ignore state file errors */
			iRet = RS_RET_OK;
			LogError(0, NO_ERRCODE, &quot;imjournal: ignoring invalid state file %s&quot;, cs.stateFile);
			if (cs.bIgnorePrevious) {
				skipOldMessages();
			}
		}
	} else {
		LogError(0, RS_RET_FOPEN_FAILURE, &quot;imjournal: open on state file `%s' failed\n&quot;, cs.stateFile);
		if (cs.bIgnorePrevious) {
			/* Seek to the very end of the journal and ignore all older messages. */
			skipOldMessages();
		}
	}

finalize_it:
	RETiRet;
}

static void
tryRecover(void) {
	LogMsg(0, RS_RET_OK, LOG_INFO, &quot;imjournal: trying to recover from journal error&quot;);
	STATSCOUNTER_INC(statsCounter.ctrRecoveryAttempts, statsCounter.mutCtrRecoveryAttempts);
	closeJournal();
	srSleep(0, 200000);	// do not hammer machine with too-frequent retries
	openJournal();
}


BEGINrunInput
	uint64_t count = 0;
CODESTARTrunInput
	CHKiRet(ratelimitNew(&amp;ratelimiter, &quot;imjournal&quot;, NULL));
	dbgprintf(&quot;imjournal: ratelimiting burst %u, interval %u\n&quot;, cs.ratelimitBurst,
		  cs.ratelimitInterval);
	ratelimitSetLinuxLike(ratelimiter, cs.ratelimitInterval, cs.ratelimitBurst);
	ratelimitSetNoTimeCache(ratelimiter);

	if (cs.stateFile) {
		/* Load our position in the journal from the state file. */
		CHKiRet(loadJournalState());
	} else if (cs.bIgnorePrevious) {
		/* Seek to the very end of the journal and ignore all older messages. */
		skipOldMessages();
	}

	/* handling old &quot;usepidfromsystem&quot; option */
	if (cs.bUseJnlPID != -1) {
		free(cs.usePid);
		cs.usePid = strdup(&quot;system&quot;);
		LogError(0, RS_RET_DEPRECATED,
			&quot;\&quot;usepidfromsystem\&quot; is deprecated, use \&quot;usepid\&quot; instead&quot;);
	}

	if (cs.usePid &amp;&amp; (strcmp(cs.usePid, &quot;system&quot;) == 0)) {
		pidFieldName = &quot;_PID&quot;;
		bPidFallBack = 0;
	} else if (cs.usePid &amp;&amp; (strcmp(cs.usePid, &quot;syslog&quot;) == 0)) {
		pidFieldName = &quot;SYSLOG_PID&quot;;
		bPidFallBack = 0;
	} else  {
		pidFieldName = &quot;SYSLOG_PID&quot;;
		bPidFallBack = 1;
		if (cs.usePid &amp;&amp; (strcmp(cs.usePid, &quot;both&quot;) != 0)) {
			LogError(0, RS_RET_OK, &quot;option \&quot;usepid\&quot;&quot;
				&quot; should contain one of system|syslog|both and no '%s'&quot;,cs.usePid);
		}
	}


	/* this is an endless loop - it is terminated when the thread is
	 * signalled to do so. This, however, is handled by the framework.
	 */
	while (glbl.GetGlobalInputTermState() == 0) {
		int r;

		r = sd_journal_next(journalContext.j);
		if (r &lt; 0) {
			LogError(-r, RS_RET_ERR, &quot;imjournal: sd_journal_next() failed&quot;);
			tryRecover();
			continue;
		}

		if (r == 0) {
			if (journalContext.atHead) {
				LogMsg(0, RS_RET_OK, LOG_WARNING, &quot;imjournal: &quot;
						&quot;Journal indicates no msgs when positioned at head.\n&quot;);
			}
			/* No new messages, wait for activity. */
			if (pollJournal() != RS_RET_OK &amp;&amp; !journalContext.reloaded) {
				tryRecover();
			}
			continue;
		}

		/*
		 * update journal disk usage before reading the new message.
		 */
		const int e = sd_journal_get_usage(journalContext.j, (uint64_t *)&amp;statsCounter.diskUsageBytes);
		if (e &lt; 0) {
			LogError(-e, RS_RET_ERR, &quot;imjournal: sd_get_usage() failed&quot;);
		}

		if (readjournal() != RS_RET_OK) {
			tryRecover();
			continue;
		}

		count++;
		journalContext.atHead = 0;

		if (cs.stateFile) { /* can't persist without a state file */
			/* TODO: This could use some finer metric. */
			if ((count % cs.iPersistStateInterval) == 0) {
				persistJournalState();
			}
		}
	}

finalize_it:
ENDrunInput

<A NAME="2"></A>
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2202-1.html#2',3,'match2202-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	bLegacyCnfModGlobalsPermitted = 1;

	cs.bIgnoreNonValidStatefile = 1;
	cs.iPersistStateInterval = DFLT_persiststateinterval;
	cs.stateFile = NULL;
	cs.ratelimitBurst = 20000;
	cs.ratelimitInterval = 600;
	cs.iDfltSeverity = DFLT_SEVERITY;
	cs.iDfltFacility = DFLT_FACILITY;
	cs.bUseJnlPID = -1;
	cs.usePid = NULL;</B></FONT>
	cs.bWorkAroundJournalBug = 1;
	cs.bFsync = 0;
	cs.bRemote = 0;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	/* bad trick to handle old and new style config all in old-style var */
	if(cs.stateFile != NULL &amp;&amp; cs.stateFile[0] != '/') {
		char *new_stateFile;
		if (-1 == asprintf(&amp;new_stateFile, &quot;%s/%s&quot;,
			(char *)glbl.GetWorkDir(loadModConf-&gt;pConf), cs.stateFile)) {
				LogError(0, RS_RET_OUT_OF_MEMORY, &quot;imjournal: asprintf failed\n&quot;);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		free (cs.stateFile);
		cs.stateFile = new_stateFile;
	}
finalize_it:
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;

	/* support statistic gathering */
	CHKiRet(statsobj.Construct(&amp;(statsCounter.stats)));
	CHKiRet(statsobj.SetName(statsCounter.stats, (uchar*)&quot;imjournal&quot;));
	CHKiRet(statsobj.SetOrigin(statsCounter.stats, (uchar*)&quot;imjournal&quot;));
	STATSCOUNTER_INIT(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;submitted&quot;),
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrSubmitted)));
	STATSCOUNTER_INIT(statsCounter.ctrRead, statsCounter.mutCtrRead);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;read&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRead)));
	STATSCOUNTER_INIT(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;discarded&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrDiscarded)));
	STATSCOUNTER_INIT(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;failed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrFailed)));
	STATSCOUNTER_INIT(statsCounter.ctrPollFailed, statsCounter.mutCtrPollFailed);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;poll_failed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrPollFailed)));
	STATSCOUNTER_INIT(statsCounter.ctrRotations, statsCounter.mutCtrRotations);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;rotations&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRotations)));
	STATSCOUNTER_INIT(statsCounter.ctrRecoveryAttempts, statsCounter.mutCtrRecoveryAttempts);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;recovery_attempts&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrRecoveryAttempts)));
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;ratelimit_discarded_in_interval&quot;),
	                ctrType_Int, CTR_FLAG_NONE, &amp;(statsCounter.ratelimitDiscardedInInterval)));
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;disk_usage_bytes&quot;),
	                ctrType_Int, CTR_FLAG_NONE, &amp;(statsCounter.diskUsageBytes)));
	CHKiRet(statsobj.ConstructFinalize(statsCounter.stats));
	/* end stats counter */

finalize_it:
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	free(cs.stateFile);
	free(cs.usePid);
	free(journalContext.cursor);
	statsobj.Destruct(&amp;(statsCounter.stats));
ENDfreeCnf

/* open journal */
BEGINwillRun
CODESTARTwillRun
	iRet = openJournal();
ENDwillRun

/* close journal */
BEGINafterRun
CODESTARTafterRun
	if (cs.stateFile) { /* can't persist without a state file */
		persistJournalState();
	}
	closeJournal();
	ratelimitDestruct(ratelimiter);
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	if(pLocalHostIP != NULL)
		prop.Destruct(&amp;pLocalHostIP);

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(net, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINsetModCnf
<A NAME="1"></A>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2202-1.html#1',3,'match2202-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if (Debug) {
		dbgprintf(&quot;module (global) param blk for imjournal:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for (i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(modpblk.descr[i].name, &quot;persiststateinterval&quot;)) {
			cs.iPersistStateInterval = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;statefile&quot;)) {
			cs.stateFile = (char *)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<A NAME="3"></A>		} else if(!strcmp(modpblk.descr[i].name, &quot;ratelimit.burst&quot;)) {
			cs.ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;ratelimit.interval&quot;)) {
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2202-1.html#3',3,'match2202-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			cs.ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;ignorepreviousmessages&quot;)) {
			cs.bIgnorePrevious = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;ignorenonvalidstatefile&quot;)) {
			cs.bIgnoreNonValidStatefile = (int) pvals[i].val.d.n;</B></FONT>
		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultseverity&quot;)) {
			cs.iDfltSeverity = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultfacility&quot;)) {
			/* ugly workaround to handle facility numbers; values
			   derived from names need to be eight times smaller */

			char *fac, *p;

			fac = p = es_str2cstr(pvals[i].val.d.estr, NULL);
			facilityHdlr((uchar **) &amp;p, (void *) &amp;cs.iDfltFacility);
			free(fac);
		} else if (!strcmp(modpblk.descr[i].name, &quot;usepidfromsystem&quot;)) {
			cs.bUseJnlPID = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;usepid&quot;)) {
			cs.usePid = (char *)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(modpblk.descr[i].name, &quot;workaroundjournalbug&quot;)) {
			cs.bWorkAroundJournalBug = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;fsync&quot;)) {
			cs.bFsync = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;remote&quot;)) {
			cs.bRemote = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;imjournal: program error, non-handled &quot;
				&quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

finalize_it:
	if (pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(net, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT(&quot;imjournal&quot;), sizeof(&quot;imjournal&quot;) - 1));
	CHKiRet(prop.CreateStringProp(&amp;pLocalHostIP, UCHAR_CONSTANT(&quot;127.0.0.1&quot;), sizeof(&quot;127.0.0.1&quot;) - 1));

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalpersiststateinterval&quot;, 0, eCmdHdlrInt,
		NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalratelimitinterval&quot;, 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalratelimitburst&quot;, 0, eCmdHdlrInt,
		NULL, &amp;cs.ratelimitBurst, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalstatefile&quot;, 0, eCmdHdlrGetWord,
		NULL, &amp;cs.stateFile, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalignorepreviousmessages&quot;, 0, eCmdHdlrBinary,
		NULL, &amp;cs.bIgnorePrevious, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournaldefaultseverity&quot;, 0, eCmdHdlrSeverity,
		NULL, &amp;cs.iDfltSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournaldefaultfacility&quot;, 0, eCmdHdlrCustomHandler,
		facilityHdlr, &amp;cs.iDfltFacility, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;imjournalusepidfromsystem&quot;, 0, eCmdHdlrBinary,
		NULL, &amp;cs.bUseJnlPID, STD_LOADABLE_MODULE_ID));
ENDmodInit
/* vim:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imfile.c
 *
 * This is the input module for reading text file data. A text file is a
 * non-binary file who's lines are delemited by the \n character.
 *
 * Work originally begun on 2008-02-01 by Rainer Gerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;glob.h&gt;
#include &lt;poll.h&gt;
#include &lt;json.h&gt;
#include &lt;fnmatch.h&gt;
#ifdef HAVE_SYS_INOTIFY_H
#include &lt;sys/inotify.h&gt;
#include &lt;linux/types.h&gt;
#endif
#ifdef HAVE_SYS_STAT_H
#	include &lt;sys/stat.h&gt;
#endif
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
#include &lt;port.h&gt;
#include &lt;sys/port.h&gt;
#endif
#include &quot;rsyslog.h&quot;		/* error codes etc... */
#include &quot;dirty.h&quot;
#include &quot;cfsysline.h&quot;		/* access to config file objects */
#include &quot;module-template.h&quot;	/* generic module interface code - very important, read it! */
#include &quot;srUtils.h&quot;		/* some utility functions */
#include &quot;msg.h&quot;
#include &quot;stream.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;glbl.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;prop.h&quot;
#include &quot;stringbuf.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;parserif.h&quot;
#include &quot;datetime.h&quot;

#include &lt;regex.h&gt;

/* some platforms do not have large file support :( */
#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif
#ifndef HAVE_LSEEK64
#  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
#endif

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imfile&quot;)

/* defines */
#define FILE_ID_HASH_SIZE 20	/* max size of a file_id hash */
#define FILE_ID_SIZE	512	/* how many bytes are used for file-id? */

/* Module static data */
DEF_IMOD_STATIC_DATA	/* must be present, starts static data */
DEFobjCurrIf(glbl)
DEFobjCurrIf(strm)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(datetime)

extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
	uint8_t *out, const size_t outlen); /* see siphash.c */

static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

#define NUM_MULTISUB 1024 /* default max number of submits */
#define DFLT_PollInterval 10
#define INIT_WDMAP_TAB_SIZE 1 /* default wdMap table size - is extended as needed, use 2^x value */
#define ADD_METADATA_UNSPECIFIED -1

/* If set to 1, fileTableDisplay will be compiled and used for debugging */
#define ULTRA_DEBUG 0

/* Setting GLOB_BRACE to ZERO which disables support for GLOB_BRACE if not available on current platform */
#ifndef GLOB_BRACE
	#define GLOB_BRACE 0
#endif

typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;

struct per_minute_rate_limit_s {
	uint64_t maxBytesPerMinute;
	uint32_t maxLinesPerMinute;
	uint64_t bytesThisMinute; /* bytes sent so far this minute */
	uint32_t linesThisMinute; /* lines sent to far this minute */
	time_t rateLimitingMinute; /* minute we are currently rate limiting for */
};

static struct configSettings_s {
	uchar *pszFileName;
	uchar *pszFileTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int iPollInterval;
	int iPersistStateInterval;	/* how often if state file to be persisted? (default 0-&gt;never) */
	int bPersistStateAfterSubmission;/* persist state file after messages have been submitted */
	int iFacility; /* local0 */
	int iSeverity;  /* notice, as of rfc 3164 */
	int readMode;  /* mode to use for ReadMultiLine call */
	int64 maxLinesAtOnce;	/* how many lines to process in a row? */
	uint64_t maxBytesPerMinute; /* maximum bytes per minute to send before rate limiting */
	uint64_t maxLinesPerMinute; /* maximum lines per minute to send before rate limiting */
	uint32_t trimLineOverBytes;  /* 0: never trim line, positive number: trim line if over bytes */
} cs;

struct instanceConf_s {
	uchar *pszFileName;
	uchar *pszFileName_forOldStateFile; /* we unfortunately needs this to read old state files */
	uchar *pszDirName;
	uchar *pszFileBaseName;
	uchar *pszTag;
	size_t lenTag;
	uchar *pszStateFile;
	uchar *pszBindRuleset;
	int nMultiSub;
	per_minute_rate_limit_t perMinuteRateLimits;
	int iPersistStateInterval;
	int bPersistStateAfterSubmission;
	int iFacility;
	int iSeverity;
	int readTimeout;
	unsigned delay_perMsg;
	sbool bRMStateOnDel;
	uint8_t readMode;
	uchar *startRegex;
	uchar *endRegex;
	regex_t start_preg;	/* compiled version of startRegex */
	regex_t end_preg;	/* compiled version of endRegex */
	sbool discardTruncatedMsg;
	sbool msgDiscardingError;
	sbool escapeLF;
	sbool reopenOnTruncate;
	sbool addCeeTag;
	sbool addMetadata;
	sbool freshStartTail;
	sbool fileNotFoundError;
	int maxLinesAtOnce;
	uint32_t trimLineOverBytes;
	uint32_t ignoreOlderThan;
	int msgFlag;
	uchar *escapeLFString;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	struct instanceConf_s *next;
};


/* file system objects */
typedef struct fs_edge_s fs_edge_t;
typedef struct fs_node_s fs_node_t;
typedef struct act_obj_s act_obj_t;
struct act_obj_s {
	act_obj_t *prev;
	act_obj_t *next;
	fs_edge_t *edge;	/* edge which this object belongs to */
	char *name;		/* full path name of active object */
	char *basename;		/* only basename */ //TODO: remove when refactoring rename support
	char *source_name;	/* if this object is target of a symlink, source_name is its name (else NULL) */
	//char *statefile;	/* base name of state file (for move operations) */
	int wd;
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	struct fileinfo *pfinf;
	sbool bPortAssociated;
	int is_deleted;	/* debugging: entry deleted? */
#endif
	time_t timeoutBase; /* what time to calculate the timeout against? */
	/* file dynamic data */
	char file_id[FILE_ID_HASH_SIZE]; /* file id for this entry, once we could obtain it */
	char file_id_prev[FILE_ID_HASH_SIZE]; /* previous file id for this entry, set if changed */
	int in_move;	/* workaround for inotify move: if set, state file must not be deleted */
	ino_t ino;	/* current inode nbr */
	int fd;		/* fd to file in order to obtain file_id (needs to be preserved across move) */
	strm_t *pStrm;	/* its stream (NULL if not assigned) */
	int nRecords; /**&lt; How many records did we process before persisting the stream? */
	ratelimit_t *ratelimiter;
	multi_submit_t multiSub;
	int is_symlink;
};
struct fs_edge_s {
	fs_node_t *parent;	/* node pointing to this edge */
	fs_node_t *node;	/* node this edge points to */
	fs_edge_t *next;
	uchar *name;
	uchar *path;
	act_obj_t *active;
	int is_file;
	int ninst;		/* nbr of instances in instarr */
	instanceConf_t **instarr;
};
struct fs_node_s {
	fs_edge_t *edges;	/* NULL in leaf nodes */
	fs_node_t *root;	/* node one level up (NULL for file system root) */
};


/* forward definitions */
static rsRetVal persistStrmState(act_obj_t *);
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
	uchar *const pszout, const size_t ilenout);


#define OPMODE_POLLING 0
#define OPMODE_INOTIFY 1
#define OPMODE_FEN 2

/* config variables */
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	int iPollInterval;	/* number of seconds to sleep when there was no file activity */
	int readTimeout;
	int timeoutGranularity;		/* value in ms */
	instanceConf_t *root, *tail;
	fs_node_t *conf_tree;
	uint8_t opMode;
	sbool configSetViaV2Method;
	uchar *stateFileDirectory;
	sbool sortFiles;
	sbool normalizePath;	/* normalize file system pathes (all start with root dir) */
	sbool haveReadTimeouts;	/* use special processing if read timeouts exist */
	sbool bHadFileData;	/* actually a global variable:
				   1 - last call to pollFile() had data
				   0 - last call to pollFile() had NO data
				   Must be manually reset to 0 if desired. Helper for
				   polling mode.
				 */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for run process */
static modConfData_t *currModConf = NULL;/* modConf ptr to CURRENT mod conf (run or load) */


#ifdef HAVE_INOTIFY_INIT
/* We need to map watch descriptors to our actual objects. Unfortunately, the
 * inotify API does not provide us with any cookie, so a simple O(1) algorithm
 * cannot be done (what a shame...). We assume that maintaining the array is much
 * less often done than looking it up, so we keep the array sorted by watch descriptor
 * and do a binary search on the wd we get back. This is at least O(log n), which
 * is not too bad for the anticipated use case.
 */
struct wd_map_s {
	int wd;		/* ascending sort key */
	act_obj_t *act; /* point to related active object */
};
typedef struct wd_map_s wd_map_t;
static wd_map_t *wdmap = NULL;
static int nWdmap;
static int allocMaxWdmap;
static int ino_fd;	/* fd for inotify calls */
#endif /* #if HAVE_INOTIFY_INIT -------------------------------------------------- */

#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
struct fileinfo {
	struct file_obj fobj;
	int events;
	int port;
};

static int glport; /* Static port handle for FEN api*/
#endif /* #if OS_SOLARIS -------------------------------------------------- */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;pollinginterval&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;readtimeout&quot;, eCmdHdlrNonNegInt, 0 },
	{ &quot;timeoutgranularity&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;sortfiles&quot;, eCmdHdlrBinary, 0 },
	{ &quot;statefile.directory&quot;, eCmdHdlrString, 0 },
	{ &quot;normalizepath&quot;, eCmdHdlrBinary, 0 },
	{ &quot;mode&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ &quot;file&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;tag&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;severity&quot;, eCmdHdlrSeverity, 0 },
	{ &quot;facility&quot;, eCmdHdlrFacility, 0 },
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;readmode&quot;, eCmdHdlrInt, 0 },
	{ &quot;startmsg.regex&quot;, eCmdHdlrString, 0 },
	{ &quot;endmsg.regex&quot;, eCmdHdlrString, 0 },
	{ &quot;discardtruncatedmsg&quot;, eCmdHdlrBinary, 0 },
	{ &quot;msgdiscardingerror&quot;, eCmdHdlrBinary, 0 },
	{ &quot;escapelf&quot;, eCmdHdlrBinary, 0 },
	{ &quot;escapelf.replacement&quot;, eCmdHdlrString, 0 },
	{ &quot;reopenontruncate&quot;, eCmdHdlrBinary, 0 },
	{ &quot;maxlinesatonce&quot;, eCmdHdlrInt, 0 },
	{ &quot;trimlineoverbytes&quot;, eCmdHdlrInt, 0 },
<A NAME="0"></A>	{ &quot;maxsubmitatonce&quot;, eCmdHdlrInt, 0 },
	{ &quot;removestateondelete&quot;, eCmdHdlrBinary, 0 },
	{ &quot;persiststateinterval&quot;, eCmdHdlrInt, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2202-0.html#0',2,'match2202-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;persiststateaftersubmission&quot;, eCmdHdlrBinary, 0 },
	{ &quot;deletestateonfiledelete&quot;, eCmdHdlrBinary, 0 },
	{ &quot;delay.message&quot;, eCmdHdlrNonNegInt, 0 },
	{ &quot;addmetadata&quot;, eCmdHdlrBinary, 0 },
	{ &quot;addceetag&quot;, eCmdHdlrBinary, 0 },
	{ &quot;statefile&quot;, eCmdHdlrString, CNFPARAM_DEPRECATED },
	{ &quot;readtimeout&quot;, eCmdHdlrNonNegInt, 0 },
	{ &quot;freshstarttail&quot;, eCmdHdlrBinary, 0},
	{ &quot;filenotfounderror&quot;, eCmdHdlrBinary, 0},
	{ &quot;needparse&quot;, eCmdHdlrBinary, 0},
	{ &quot;ignoreolderthan&quot;, eCmdHdlrInt, 0},
	{ &quot;maxbytesperminute&quot;, eCmdHdlrInt, 0},
	{ &quot;maxlinesperminute&quot;, eCmdHdlrInt, 0}
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */


/* Support for &quot;old cruft&quot; state files will potentially become optional in the
 * future (hopefully). To prepare so, we use conditional compilation with a
 * fixed-true condition ;-) -- rgerhards, 2018-03-28
 * reason: https://github.com/rsyslog/rsyslog/issues/2231#issuecomment-376862280
 */
#define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
#ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
static uchar * ATTR_NONNULL(1, 2)</B></FONT>
OLD_getStateFileName(const instanceConf_t *const inst,
	 uchar *const __restrict__ buf,
	 const size_t lenbuf)
{
	DBGPRINTF(&quot;OLD_getStateFileName trying '%s'\n&quot;, inst-&gt;pszFileName_forOldStateFile);
	snprintf((char*)buf, lenbuf - 1, &quot;imfile-state:%s&quot;, inst-&gt;pszFileName_forOldStateFile);
	buf[lenbuf-1] = '\0'; /* be on the safe side... */
	uchar *p = buf;
	for( ; *p ; ++p) {
		if(*p == '/')
			*p = '-';
	}
	return buf;
}


static const uchar *
getStateFileDir(void)
{
	const uchar *wrkdir;
	assert(currModConf != NULL);
	if(currModConf-&gt;stateFileDirectory == NULL) {
		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
	} else {
		wrkdir = currModConf-&gt;stateFileDirectory;
	}
	return(wrkdir);
}


/* try to open an old-style state file for given file. If the state file does not
 * exist or cannot be read, an error is returned.
 */
static rsRetVal ATTR_NONNULL(1)
OLD_openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	strm_t *psSF = NULL;
	uchar pszSFNam[MAXFNAME];
	size_t lenSFNam;
	struct stat stat_buf;
	uchar statefile[MAXFNAME];
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
	DBGPRINTF(&quot;OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n&quot;,
		  act-&gt;name, statefn);

	/* Get full path and file name */
	lenSFNam = getFullStateFileName(statefn, &quot;&quot;, pszSFNam, sizeof(pszSFNam));

	/* check if the file exists */
	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
		if(errno == ENOENT) {
			DBGPRINTF(&quot;OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n&quot;,
				pszSFNam, act-&gt;name);
			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
		} else {
			char errStr[1024];
			rs_strerror_r(errno, errStr, sizeof(errStr));
			DBGPRINTF(&quot;OLD_openFileWithStateFile: error trying to access state &quot;
				&quot;file for '%s':%s\n&quot;, act-&gt;name, errStr);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}

	/* If we reach this point, we have a state file */

	DBGPRINTF(&quot;old state file found - instantiating from it\n&quot;);
	CHKiRet(strm.Construct(&amp;psSF));
	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(psSF));

	/* read back in the object */
	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) &quot;strm&quot;, psSF, NULL, act));
	free(act-&gt;pStrm-&gt;pszFName);
	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));

	strm.CheckFileChange(act-&gt;pStrm);
	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));

	/* we now persist the new state file and delete the old one, so we will
	 * never have to deal with the old one. */
	persistStrmState(act);
	unlink((char*)pszSFNam);

finalize_it:
	if(psSF != NULL)
		strm.Destruct(&amp;psSF);
	RETiRet;
}
#endif /* #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT */



#if 0 // Code we can potentially use for new functionality // TODO: use or remove
//TODO add a kind of portable asprintf:
static const char * ATTR_NONNULL()
gen_full_name(const char *const dirname, const char *const name)
{
	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
	char *const full_name = malloc(len_full_name);
	if(full_name == NULL)
		return NULL;

	snprintf(full_name, len_full_name, &quot;%s/%s&quot;, dirname, name);
	return full_name;
}
#endif


#ifdef HAVE_INOTIFY_INIT
#if ULTRA_DEBUG == 1
static void
dbg_wdmapPrint(const char *msg)
{
	int i;
	DBGPRINTF(&quot;%s\n&quot;, msg);
	for(i = 0 ; i &lt; nWdmap ; ++i)
		DBGPRINTF(&quot;wdmap[%d]: wd: %d, act %p, name: %s\n&quot;,
			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
}
#endif

static rsRetVal
wdmapInit(void)
{
	DEFiRet;
	free(wdmap);
	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
	nWdmap = 0;
finalize_it:
	RETiRet;
}


/* note: we search backwards, as inotify tends to return increasing wd's */
static rsRetVal
wdmapAdd(int wd, act_obj_t *const act)
{
	wd_map_t *newmap;
	int newmapsize;
	int i;
	DEFiRet;

	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
		; 	/* just scan */
	if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;imfile: wd %d already in wdmap!&quot;, wd);
		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
	}
	++i;
	/* i now points to the entry that is to be moved upwards (or end of map) */
	if(nWdmap == allocMaxWdmap) {
		newmapsize = 2 * allocMaxWdmap;
		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
		// TODO: handle the error more intelligently? At all possible? -- 2013-10-15
		wdmap = newmap;
		allocMaxWdmap = newmapsize;
	}
	if(i &lt; nWdmap) {
		/* we need to shift to make room for new entry */
		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
	}
	wdmap[i].wd = wd;
	wdmap[i].act = act;
	++nWdmap;
	DBGPRINTF(&quot;add wdmap[%d]: wd %d, act obj %p, path %s\n&quot;, i, wd, act, act-&gt;name);

finalize_it:
	RETiRet;
}

/* return wd or -1 on error */
static int
in_setupWatch(act_obj_t *const act, const int is_file)
{
	int wd = -1;
	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
		goto done;

	wd = inotify_add_watch(ino_fd, act-&gt;name,
		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
	if(wd &lt; 0) {
		if (errno == EACCES) { /* There is high probability of selinux denial on top-level paths */
			DBGPRINTF(&quot;imfile: permission denied when adding watch for '%s'\n&quot;, act-&gt;name);
		} else {
			LogError(errno, RS_RET_IO_ERROR, &quot;imfile: cannot watch object '%s'&quot;, act-&gt;name);
		}
		goto done;
	}
	wdmapAdd(wd, act);
	DBGPRINTF(&quot;in_setupWatch: watch %d added for %s(object %p)\n&quot;, wd, act-&gt;name, act);
done:	return wd;
}

/* compare function for bsearch() */
static int
wdmap_cmp(const void *k, const void *a)
{
	int key = *((int*) k);
	wd_map_t *etry = (wd_map_t*) a;
	if(key &lt; etry-&gt;wd)
		return -1;
	else if(key &gt; etry-&gt;wd)
		return 1;
	else
		return 0;
}
/* looks up a wdmap entry and returns it's index if found
 * or -1 if not found.
 */
static wd_map_t *
wdmapLookup(int wd)
{
	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
}


static rsRetVal
wdmapDel(const int wd)
{
	int i;
	DEFiRet;

	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
		; 	/* just scan */
	if(i == nWdmap ||  wdmap[i].wd != wd) {
		DBGPRINTF(&quot;wd %d shall be deleted but not in wdmap!\n&quot;, wd);
		FINALIZE;
	}

	if(i &lt; nWdmap-1) {
		/* we need to shift to delete it (see comment at wdmap definition) */
		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
	}
	--nWdmap;
	DBGPRINTF(&quot;wd %d deleted, was idx %d\n&quot;, wd, i);

finalize_it:
	RETiRet;
}

#endif // #ifdef HAVE_INOTIFY_INIT

#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act)
{
	DBGPRINTF(&quot;fen_setupWatch: enter, opMode %d\n&quot;, runModConf-&gt;opMode);
	if(runModConf-&gt;opMode != OPMODE_FEN)
		goto done;

	DBGPRINTF(&quot;fen_setupWatch: %s\n&quot;, act-&gt;name);
	if(act-&gt;pfinf == NULL) {
		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
		if (act-&gt;pfinf == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, &quot;imfile: fen_setupWatch alloc memory &quot;
				&quot;for fileinfo failed &quot;);
			goto done;
		}
		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
			LogError(errno, RS_RET_OUT_OF_MEMORY, &quot;imfile: fen_setupWatch alloc memory &quot;
				&quot;for strdup failed &quot;);
			free(act-&gt;pfinf);
			act-&gt;pfinf = NULL;
			goto done;
		}
		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
		act-&gt;pfinf-&gt;port = glport;
		act-&gt;bPortAssociated = 0;
	}

	DBGPRINTF(&quot;fen_setupWatch: bPortAssociated %d\n&quot;, act-&gt;bPortAssociated);
	if(act-&gt;bPortAssociated) {
		goto done;
	}

	struct stat fileInfo;
	const int r = stat(act-&gt;name, &amp;fileInfo);
	if(r == -1) { /* object gone away? */
		DBGPRINTF(&quot;fen_setupWatch: file gone away, no watch: '%s'\n&quot;, act-&gt;name);
		goto done;
	}

	/* note: FEN watch must be re-registered each time - this is what we do now */
	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
		LogError(errno, RS_RET_SYS_ERR, &quot;fen_setupWatch: Failed to associate port for file &quot;
			&quot;: %s\n&quot;, act-&gt;pfinf-&gt;fobj.fo_name);
		goto done;
	} else {
		/* Port successfull listening now*/
		DBGPRINTF(&quot;fen_setupWatch: associated port for file %s\n&quot;, act-&gt;name);
		act-&gt;bPortAssociated = 1;
	}

	DBGPRINTF(&quot;in_setupWatch: fen association added for %s\n&quot;, act-&gt;name);
done:	return;
}
#else
static void ATTR_NONNULL()
fen_setupWatch(act_obj_t *const act __attribute__((unused)))
{
	DBGPRINTF(&quot;fen_setupWatch: DUMMY CALLED - not on Solaris?\n&quot;);
}
#endif /* FEN */

static void
fs_node_print(const fs_node_t *const node, const int level)
{
	fs_edge_t *chld;
	act_obj_t *act;
	dbgprintf(&quot;node print[%2.2d]: %p edges:\n&quot;, level, node);

	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		dbgprintf(&quot;node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n&quot;,
			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
			dbgprintf(&quot;\tinst: %p\n&quot;, chld-&gt;instarr[i]);
		}
		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
			dbgprintf(&quot;\tact : %p\n&quot;, act);
			dbgprintf(&quot;\tact : %p: name '%s', wd: %d\n&quot;,
				act, act-&gt;name, act-&gt;wd);
		}
	}
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		fs_node_print(chld-&gt;node, level+1);
	}
}

static sbool
isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
{
	if (inst-&gt;ignoreOlderThan)
	{
		struct stat stat_buf;
		time_t tt;
		/* skip old files */
		datetime.GetTime(&amp;tt);
		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
			return 1;
		}
	}
	return 0;
}

/* add a new file system object if it not yet exists, ignore call
 * if it already does.
 */
static rsRetVal ATTR_NONNULL(1,2)
act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
	const ino_t ino, const int is_symlink, const char *const source)
{
	act_obj_t *act = NULL;
	char basename[MAXFNAME];
	DEFiRet;
	int fd = -1;

	DBGPRINTF(&quot;act_obj_add: edge %p, name '%s' (source '%s')\n&quot;, edge, name, source? source : &quot;---&quot;);

	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		if(!strcmp(act-&gt;name, name)) {
			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
				DBGPRINTF(&quot;active object '%s' already exists in '%s' - no need to add\n&quot;,
					name, edge-&gt;path);
				FINALIZE;
			}
		}
	}
	DBGPRINTF(&quot;need to add new active object '%s' in '%s' - checking if accessible\n&quot;, name, edge-&gt;path);
	fd = open(name, O_RDONLY | O_CLOEXEC);
	if(fd &lt; 0) {
		if (is_file) {
			LogError(errno, RS_RET_ERR, &quot;imfile: error accessing file '%s'&quot;, name);
		} else { /* reporting only in debug for dirs as higher lvl paths are likely blocked by selinux */
			DBGPRINTF(&quot;imfile: error accessing directory '%s'&quot;, name);
		}
		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
	}
	DBGPRINTF(&quot;add new active object '%s' in '%s'\n&quot;, name, edge-&gt;path);
	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
	CHKmalloc(act-&gt;name = strdup(name));
	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
		CHKmalloc(act-&gt;basename = strdup(name)); /* assume basename is same as name */
	} else {
		CHKmalloc(act-&gt;basename = strdup(basename));
	}
	act-&gt;edge = edge;
	act-&gt;ino = ino;
	act-&gt;fd = fd;
	act-&gt;file_id[0] = '\0';
	act-&gt;file_id_prev[0] = '\0';
	act-&gt;is_symlink = is_symlink;
	act-&gt;ratelimiter = NULL;
	if (source) { /* we are target of symlink */
		CHKmalloc(act-&gt;source_name = strdup(source));
	} else {
		act-&gt;source_name = NULL;
	}
	#ifdef HAVE_INOTIFY_INIT
	act-&gt;wd = in_setupWatch(act, is_file);
	#endif
	fen_setupWatch(act);
	if(is_file &amp;&amp; !is_symlink) {
		const instanceConf_t *const inst = edge-&gt;instarr[0];// TODO: same file, multiple instances?
		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, &quot;imfile&quot;, name));
		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
		act-&gt;multiSub.nElem = 0;
		pollFile(act);
	}

	/* all well, add to active list */
	if(edge-&gt;active != NULL) {
		edge-&gt;active-&gt;prev = act;
	}
	act-&gt;next = edge-&gt;active;
	edge-&gt;active = act;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(act != NULL) {
			if (act-&gt;ratelimiter != NULL)
				ratelimitDestruct(act-&gt;ratelimiter);
			free(act-&gt;name);
			free(act);
		}
		if(fd != -1) {
			close(fd);
		}
	}
	RETiRet;
}


/* this walks an edges active list and detects and acts on any changes
 * seen there. It does NOT detect newly appeared files, as they are not
 * inside the active list!
 */
static void
detect_updates(fs_edge_t *const edge)
{
	act_obj_t *act;
	struct stat fileInfo;
	int restart = 0;

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF(&quot;detect_updates checking active obj '%s'\n&quot;, act-&gt;name);
		const int r = lstat(act-&gt;name, &amp;fileInfo);
		if(r == -1) { /* object gone away? */
			DBGPRINTF(&quot;object gone away, unlinking: '%s'\n&quot;, act-&gt;name);
			act_obj_unlink(act);
			restart = 1;
			break;
		} else if(fileInfo.st_ino != act-&gt;ino) {
			DBGPRINTF(&quot;file '%s' inode changed from %llu to %llu, unlinking from &quot;
				&quot;internal lists\n&quot;, act-&gt;name, (long long unsigned) act-&gt;ino,
				(long long unsigned) fileInfo.st_ino);
			if(act-&gt;pStrm != NULL) {
				/* we do no need to re-set later, as act_obj_unlink
				 * will destroy the strm obj */
				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
			}
			act_obj_unlink(act);
			restart = 1;
			break;
		}

	}

	if (restart) {
		detect_updates(edge);
	}
}


/* check if active files need to be processed. This is only needed in
 * polling mode.
 */
static void ATTR_NONNULL()
poll_active_files(fs_edge_t *const edge)
{
	if(   runModConf-&gt;opMode != OPMODE_POLLING
	   || !edge-&gt;is_file
	   || glbl.GetGlobalInputTermState() != 0) {
		return;
	}

	act_obj_t *act;
	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		fen_setupWatch(act);
		DBGPRINTF(&quot;poll_active_files: polling '%s'\n&quot;, act-&gt;name);
		pollFile(act);
	}
}

static rsRetVal ATTR_NONNULL()
process_symlink(fs_edge_t *const chld, const char *symlink)
{
	DEFiRet;
	char *target;
	CHKmalloc(target = realpath(symlink, NULL));
	struct stat fileInfo;
	if(lstat(target, &amp;fileInfo) != 0) {
		LogError(errno, RS_RET_ERR,	&quot;imfile: process_symlink: cannot stat file '%s' - ignored&quot;, target);
		FINALIZE;
	}
	const int is_file = (S_ISREG(fileInfo.st_mode));
	DBGPRINTF(&quot;process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n&quot;,
		target, is_file, chld-&gt;is_file, 0);
	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
		/* need to watch parent target as well for proper rotation support */
		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
		if (idx) { /* basename is different from name */
			char parent[MAXFNAME];
			idx--; /* move past trailing slash */
			memcpy(parent, chld-&gt;active-&gt;name, idx);
			parent[idx] = '\0';
			if(lstat(parent, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					&quot;imfile: process_symlink: cannot stat directory '%s' - ignored&quot;, parent);
				FINALIZE;
			}
			if (chld-&gt;parent-&gt;root-&gt;edges) {
				DBGPRINTF(&quot;process_symlink: adding parent '%s' of target '%s'\n&quot;, parent, target);
				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
			}
		}
	}

finalize_it:
	free(target);
	RETiRet;
}

static void ATTR_NONNULL()
poll_tree(fs_edge_t *const chld)
{
	struct stat fileInfo;
	glob_t files;
	int need_globfree = 0;
	int issymlink;
	DBGPRINTF(&quot;poll_tree: chld %p, name '%s', path: %s\n&quot;, chld, chld-&gt;name, chld-&gt;path);
	detect_updates(chld);
	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
	need_globfree = 1;
	DBGPRINTF(&quot;poll_tree: glob returned %d\n&quot;, ret);
	if(ret == 0) {
		DBGPRINTF(&quot;poll_tree: processing %d files\n&quot;, (int) files.gl_pathc);
		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
			if(glbl.GetGlobalInputTermState() != 0) {
				goto done;
			}
			char *const file = files.gl_pathv[i];
			if(lstat(file, &amp;fileInfo) != 0) {
				LogError(errno, RS_RET_ERR,
					&quot;imfile: poll_tree cannot stat file '%s' - ignored&quot;, file);
				continue;
			}

			if (S_ISLNK(fileInfo.st_mode)) {
				rsRetVal slink_ret = process_symlink(chld, file);
				if (slink_ret != RS_RET_OK) {
					continue;
				}
				issymlink = 1;
			} else {
				issymlink = 0;
			}
			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
			DBGPRINTF(&quot;poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n&quot;,
				file, is_file, chld-&gt;is_file, issymlink);
			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					&quot;imfile: '%s' is neither a regular file, symlink, nor a &quot;
					&quot;directory - ignored&quot;, file);
				continue;
			}
			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
				LogMsg(0, RS_RET_ERR, LOG_WARNING,
					&quot;imfile: '%s' is %s but %s expected - ignored&quot;,
					file, (is_file) ? &quot;FILE&quot; : &quot;DIRECTORY&quot;,
					(chld-&gt;is_file) ? &quot;FILE&quot; : &quot;DIRECTORY&quot;);
				continue;
			}
			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
		}
	}

	poll_active_files(chld);

done:
	if(need_globfree) {
		globfree(&amp;files);
	}
	return;
}

#ifdef HAVE_INOTIFY_INIT // TODO: shouldn't we use that in polling as well?
static void ATTR_NONNULL()
poll_timeouts(fs_edge_t *const edge)
{
	if(edge-&gt;is_file) {
		act_obj_t *act;
		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
				DBGPRINTF(&quot;timeout occurred on %s\n&quot;, act-&gt;name);
				pollFile(act);
			}
		}
	}
}
#endif


/* destruct a single act_obj object */
static void
act_obj_destroy(act_obj_t *const act, const int is_deleted)
{
	uchar *statefn;
	uchar statefile[MAXFNAME];
	uchar toDel[MAXFNAME];

	if(act == NULL)
		return;

	DBGPRINTF(&quot;act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n&quot;,
		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : &quot;---&quot;, act-&gt;wd, act-&gt;pStrm, is_deleted,
		act-&gt;in_move);
	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
		act_obj_t *target_act;
		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
				DBGPRINTF(&quot;act_obj_destroy: unlinking slink target %s of %s &quot;
						&quot;symlink\n&quot;, target_act-&gt;name, act-&gt;name);
				act_obj_unlink(target_act);
				break;
			}
		}
	}
	if(act-&gt;pStrm != NULL) {
		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?
		pollFile(act); /* get any left-over data */
		if(inst-&gt;bRMStateOnDel) {
			statefn = getStateFileName(act, statefile, sizeof(statefile));
			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); // TODO: check!
			statefn = toDel;
		}
		persistStrmState(act);
		strm.Destruct(&amp;act-&gt;pStrm);
		/* we delete state file after destruct in case strm obj initiated a write */
		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
			DBGPRINTF(&quot;act_obj_destroy: deleting state file %s\n&quot;, statefn);
			unlink((char*)statefn);
		}
	}
	if(act-&gt;ratelimiter != NULL) {
		ratelimitDestruct(act-&gt;ratelimiter);
	}
	#ifdef HAVE_INOTIFY_INIT
	if(act-&gt;wd != -1) {
		inotify_rm_watch(ino_fd, act-&gt;wd);
		wdmapDel(act-&gt;wd);
	}
	#endif
	if(act-&gt;fd &gt;= 0) {
		close(act-&gt;fd);
	}
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
	if(act-&gt;pfinf != NULL) {
		free(act-&gt;pfinf-&gt;fobj.fo_name);
		free(act-&gt;pfinf);
	}
	#endif
	free(act-&gt;basename);
	free(act-&gt;source_name);
	free(act-&gt;multiSub.ppMsgs);
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
		act-&gt;is_deleted = 1;
	#else
		free(act-&gt;name);
		free(act);
	#endif
}


/* destroy complete act list starting at given node */
static void
act_obj_destroy_all(act_obj_t *act)
{
	if(act == NULL)
		return;

	DBGPRINTF(&quot;act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n&quot;, act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
	while(act != NULL) {
		act_obj_t *const toDel = act;
		act = act-&gt;next;
		act_obj_destroy(toDel, 0);
	}
}

#if 0
/* debug: find if ptr is still present in list */
static void
chk_active(const act_obj_t *act, const act_obj_t *const deleted)
{
	while(act != NULL) {
		DBGPRINTF(&quot;chk_active %p vs %p\n&quot;, act, deleted);
		if(act-&gt;prev == deleted)
			DBGPRINTF(&quot;chk_active %p prev points to %p\n&quot;, act, deleted);
		if(act-&gt;next == deleted)
			DBGPRINTF(&quot;chk_active %p next points to %p\n&quot;, act, deleted);
		act = act-&gt;next;
		DBGPRINTF(&quot;chk_active next %p\n&quot;, act);
	}
}
#endif

/* unlink act object from linked list and then
 * destruct it.
 */
static void ATTR_NONNULL()
act_obj_unlink(act_obj_t *act)
{
	DBGPRINTF(&quot;act_obj_unlink %p: %s, pStrm %p\n&quot;, act, act-&gt;name, act-&gt;pStrm);
	if(act-&gt;prev == NULL) {
		act-&gt;edge-&gt;active = act-&gt;next;
	} else {
		act-&gt;prev-&gt;next = act-&gt;next;
	}
	if(act-&gt;next != NULL) {
		act-&gt;next-&gt;prev = act-&gt;prev;
	}
	act_obj_destroy(act, 1);
	act = NULL;
}

static void
fs_node_destroy(fs_node_t *const node)
{
	fs_edge_t *edge;
	DBGPRINTF(&quot;node destroy: %p edges:\n&quot;, node);

	for(edge = node-&gt;edges ; edge != NULL ; ) {
		fs_node_destroy(edge-&gt;node);
		fs_edge_t *const toDel = edge;
		edge = edge-&gt;next;
		act_obj_destroy_all(toDel-&gt;active);
		free(toDel-&gt;name);
		free(toDel-&gt;path);
		free(toDel-&gt;instarr);
		free(toDel);
	}
	free(node);
}

static void ATTR_NONNULL(1, 2)
fs_node_walk(fs_node_t *const node,
	void (*f_usr)(fs_edge_t*const))
{
	DBGPRINTF(&quot;node walk: %p edges:\n&quot;, node);

	fs_edge_t *edge;
	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
		DBGPRINTF(&quot;node walk: child %p '%s'\n&quot;, edge-&gt;node, edge-&gt;name);
		f_usr(edge);
		fs_node_walk(edge-&gt;node, f_usr);
	}
}



/* add a file system object to config tree (or update existing node with new monitor)
 */
static rsRetVal
fs_node_add(fs_node_t *const node,
	fs_node_t *const source,
	const uchar *const toFind,
	const size_t pathIdx,
	instanceConf_t *const inst)
{
	DEFiRet;
	fs_edge_t *newchld = NULL;
	int i;

	DBGPRINTF(&quot;fs_node_add(%p, '%s') enter, idx %zd\n&quot;,
		node, toFind+pathIdx, pathIdx);
	assert(toFind[0] != '\0');
	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
		/*JUST SKIP*/;
	const int isFile = (toFind[i] == '\0') ? 1 : 0;
	uchar ourPath[PATH_MAX];
	if(i == 0) {
		ourPath[0] = '/';
		ourPath[1] = '\0';
	} else {
		memcpy(ourPath, toFind, i);
		ourPath[i] = '\0';
	}
	const size_t nextPathIdx = i+1;
	const size_t len = i - pathIdx;
	uchar name[PATH_MAX];
	memcpy(name, toFind+pathIdx, len);
	name[len] = '\0';
	DBGPRINTF(&quot;fs_node_add: name '%s'\n&quot;, name);
	node-&gt;root = source;

	fs_edge_t *chld;
	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
		if(!ustrcmp(chld-&gt;name, name)) {
			DBGPRINTF(&quot;fs_node_add(%p, '%s') found '%s'\n&quot;, chld-&gt;node, toFind, name);
			/* add new instance */
			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
			CHKmalloc(instarr_new);
			chld-&gt;instarr = instarr_new;
			chld-&gt;ninst++;
			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
			/* recurse */
			if(!isFile) {
				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
			}
			FINALIZE;
		}
	}

	/* could not find node --&gt; add it */
	DBGPRINTF(&quot;fs_node_add(%p, '%s') did not find '%s' - adding it\n&quot;,
		node, toFind, name);
	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
	CHKmalloc(newchld-&gt;name = ustrdup(name));
	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
	newchld-&gt;instarr[0] = inst;
	newchld-&gt;is_file = isFile;
	newchld-&gt;ninst = 1;
	newchld-&gt;parent = node;

	DBGPRINTF(&quot;fs_node_add(%p, '%s') returns %p\n&quot;, node, toFind, newchld-&gt;node);

	if(!isFile) {
		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
	}

	/* link to list */
	newchld-&gt;next = node-&gt;edges;
	node-&gt;edges = newchld;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(newchld != NULL) {
		free(newchld-&gt;name);
		free(newchld-&gt;node);
		free(newchld-&gt;path);
		free(newchld-&gt;instarr);
		free(newchld);
		}
	}
	RETiRet;
}


/* Helper function to combine statefile and state file directory
 * This function is guranteed to work only on config data and DOES NOT
 * open or otherwise modify disk file state.
 */
static int ATTR_NONNULL()
getFullStateFileName(const uchar *const pszstatefile,
	const char *const file_id,
	uchar *const pszout,
	const size_t ilenout)
{
	int lenout;
	const uchar* pszstatedir;

	/* Get Raw Workdir, if it is NULL we need to propper handle it */
	pszstatedir = getStateFileDir();

	/* Construct file name */
	lenout = snprintf((char*)pszout, ilenout, &quot;%s/%s%s%s&quot;,
		(char*) (pszstatedir == NULL ? &quot;.&quot; : (char*) pszstatedir), (char*)pszstatefile,
		(*file_id == '\0') ? &quot;&quot; : &quot;:&quot;, file_id);

	/* return out length */
	return lenout;
}


/* hash function for file-id
 * Takes a block of data and returns a string with the hash value.
 *
 * Currently one provided by Aaaron Wiebe based on perl's hashing algorithm
 * (so probably pretty generic). Not for excessively large strings!
 * TODO: re-think the hash function!
 */
#if defined(__clang__)
#pragma GCC diagnostic ignored &quot;-Wunknown-attributes&quot;
#endif
static void __attribute__((nonnull(1,3)))
#if defined(__clang__)
__attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))
#endif
get_file_id_hash(const char *data, size_t lendata,
	char *const hash_str, const size_t len_hash_str)
{
	assert(len_hash_str &gt;= 17); /* we always generate 8-byte strings */

	size_t i;
	uint8_t out[8], k[16];
	for (i = 0; i &lt; 16; ++i)
		k[i] = i;
	memset(out, 0, sizeof(out));
	rs_siphash((const uint8_t *)data, lendata, k, out, 8);

	for(i = 0 ; i &lt; 8 ; ++i) {
		if(2 * i+1 &gt;= len_hash_str)
			break;
		snprintf(hash_str+(2*i), 3, &quot;%2.2x&quot;, out[i]);
	}
}


/* this returns the file-id for a given file
 */
static void ATTR_NONNULL(1)
getFileID(act_obj_t *const act)
{
	char tmp_id[FILE_ID_HASH_SIZE];
	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
	act-&gt;file_id[0] = '\0';
	assert(act-&gt;fd &gt;= 0); /* fd must have been opened at act_obj_t creation! */
	char filedata[FILE_ID_SIZE];
	lseek(act-&gt;fd, 0, SEEK_SET); /* Seek to beginning of file so we have correct id */
	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
	if(r == FILE_ID_SIZE) {
		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
	} else {
		DBGPRINTF(&quot;getFileID partial or error read, ret %d\n&quot;, r);
	}
	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {/* save the old id for cleaning purposes */
		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
	}
	DBGPRINTF(&quot;getFileID for '%s', file_id_hash '%s'\n&quot;, act-&gt;name, act-&gt;file_id);
}

/* this generates a state file name suitable for the given file. To avoid
 * malloc calls, it must be passed a buffer which should be MAXFNAME large.
 * Note: the buffer is not necessarily populated ... always ONLY use the
 * RETURN VALUE!
 * This function is guranteed to work only on config data and DOES NOT
 * open or otherwise modify disk file state.
 */
static uchar * ATTR_NONNULL(1, 2)
getStateFileName(const act_obj_t *const act,
	 	 uchar *const __restrict__ buf,
		 const size_t lenbuf)
{
	DBGPRINTF(&quot;getStateFileName for '%s'\n&quot;, act-&gt;name);
	snprintf((char*)buf, lenbuf - 1, &quot;imfile-state:%lld&quot;, (long long) act-&gt;ino);
	DBGPRINTF(&quot;getStateFileName:  state file name now is %s\n&quot;, buf);
	return buf;
}

static rsRetVal
checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
			     const size_t msgLen)
{
	DEFiRet;
	time_t current_minute = time(NULL)/60;
	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
			/* if we would breach our rate limit then do not send the message. */
			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; /* Update count as message will be sent */
		}
	}
	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
			per_minute_rate_limits-&gt;linesThisMinute++;
			/* if we would breach our rate limit then do not send the message. */
			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
			}
		} else {
			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
			per_minute_rate_limits-&gt;linesThisMinute = 1; /* Update count as message will be sent */
		}
	}
finalize_it:
	RETiRet;
}

/* enqueue the read file line as a message. The provided string is
 * not freed - this must be done by the caller.
 */
#define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
static rsRetVal ATTR_NONNULL(1,2)
enqLine(act_obj_t *const act,
	cstr_t *const __restrict__ cstrLine,
	const int64 strtOffs)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?
	smsg_t *pMsg;
	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
	const uchar *metadata_names[2] = {(uchar *)&quot;filename&quot;,(uchar *)&quot;fileoffset&quot;} ;
	const uchar *metadata_values[2] ;
	const size_t msgLen = cstrLen(cstrLine);

	if(msgLen == 0) {
		/* we do not process empty lines */
		FINALIZE;
	}

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
	MsgSetInputName(pMsg, pInputName);
	if(inst-&gt;addCeeTag) {
		/* Make sure we account for terminating null byte */
		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
		char *ceeMsg;
		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
		strcpy(ceeMsg, CONST_CEE_COOKIE);
		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
		free(ceeMsg);
	} else {
		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
	}
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	if(inst-&gt;addMetadata) {
		if (act-&gt;source_name) {
			metadata_values[0] = (const uchar*)act-&gt;source_name;
		} else {
			metadata_values[0] = (const uchar*)act-&gt;name;
		}
		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, &quot;%lld&quot;, strtOffs);
		metadata_values[1] = file_offset;
		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
	}

	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
	}

	if(inst-&gt;delay_perMsg) {
		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
	}

	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;

	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
finalize_it:
	RETiRet;
}
/* try to open a file which has a state file. If the state file does not
 * exist or cannot be read, an error is returned.
 */
static rsRetVal ATTR_NONNULL(1)
openFileWithStateFile(act_obj_t *const act)
{
	DEFiRet;
	uchar pszSFNam[MAXFNAME];
	uchar statefile[MAXFNAME];
	int fd = -1;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);

	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
	DBGPRINTF(&quot;trying to open state for '%s', state file '%s'\n&quot;, act-&gt;name, pszSFNam);

	/* check if the file exists */
	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
	if(fd &lt; 0) {
		if(errno == ENOENT) {
			if(act-&gt;file_id[0] != '\0') {
				DBGPRINTF(&quot;state file %s for %s does not exist - trying to see if &quot;
					&quot;inode-only file exists\n&quot;, pszSFNam, act-&gt;name);
				getFullStateFileName(statefn, &quot;&quot;, pszSFNam, sizeof(pszSFNam));
				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
				if(fd &gt;= 0) {
					dbgprintf(&quot;found inode-only state file, will be renamed at next persist\n&quot;);
				}
			}
			if(fd &lt; 0) {
				DBGPRINTF(&quot;state file %s for %s does not exist - trying to see if &quot;
					&quot;old-style file exists\n&quot;, pszSFNam, act-&gt;name);
				CHKiRet(OLD_openFileWithStateFile(act));
				FINALIZE;
			}
		} else {
			LogError(errno, RS_RET_IO_ERROR,
				&quot;imfile error trying to access state file for '%s'&quot;,
			        act-&gt;name);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
	}

	DBGPRINTF(&quot;opened state file %s for %s\n&quot;, pszSFNam, act-&gt;name);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));

	struct json_object *jval;
	struct json_object *json = fjson_object_from_fd(fd);
	if(json == NULL) {
		LogError(0, RS_RET_ERR, &quot;imfile: error reading state file for '%s'&quot;, act-&gt;name);
	}

	/* we access some data items a bit dirty, as we need to refactor the whole
	 * thing in any case - TODO
	 */
	/* Note: we ignore filname property - it is just an aid to the user. Most
	 * importantly it *is wrong* after a file move!
	 */
	fjson_object_object_get_ex(json, &quot;prev_was_nl&quot;, &amp;jval);
	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);

	fjson_object_object_get_ex(json, &quot;curr_offs&quot;, &amp;jval);
	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);

	fjson_object_object_get_ex(json, &quot;strt_offs&quot;, &amp;jval);
	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);

	fjson_object_object_get_ex(json, &quot;prev_line_segment&quot;, &amp;jval);
	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
		DBGPRINTF(&quot;prev_line_segment present in state file 2, is: %s\n&quot;, ret);
	}

	fjson_object_object_get_ex(json, &quot;prev_msg_segment&quot;, &amp;jval);
	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
	if(jval != NULL) {
		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
		DBGPRINTF(&quot;prev_msg_segment present in state file 2, is: %s\n&quot;, ret);
	}
	fjson_object_put(json);

	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));

	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));

finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}

/* try to open a file for which no state file exists. This function does NOT
 * check if a state file actually exists or not -- this must have been
 * checked before calling it.
 */
static rsRetVal
openFileWithoutStateFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	DBGPRINTF(&quot;clean startup withOUT state file for '%s'\n&quot;, act-&gt;name);
	if(act-&gt;pStrm != NULL)
		strm.Destruct(&amp;act-&gt;pStrm);
	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));

	/* As a state file not exist, this is a fresh start. seek to file end
	 * when freshStartTail is on.
	 */
	if(inst-&gt;freshStartTail) {
		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
		if(fd &gt;= 0) {
			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
			close(fd);
			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
				act-&gt;pStrm-&gt;iCurrOffs = 0;
				LogError(errno, RS_RET_ERR, &quot;imfile: could not query current &quot;
					&quot;file size for %s - 'freshStartTail' option will &quot;
					&quot;be ignored, starting at begin of file&quot;, inst-&gt;pszFileName);
			}
			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
		}
	}

finalize_it:
	RETiRet;
}

/* try to open a file. This involves checking if there is a status file and,
 * if so, reading it in. Processing continues from the last known location.
 */
static rsRetVal
openFile(act_obj_t *const act)
{
	DEFiRet;
	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	CHKiRet_Hdlr(openFileWithStateFile(act)) {
		CHKiRet(openFileWithoutStateFile(act));
	}

	DBGPRINTF(&quot;breopenOnTruncate %d for '%s'\n&quot;, inst-&gt;reopenOnTruncate, act-&gt;name);
	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);

finalize_it:
	RETiRet;
}


/* The following is a cancel cleanup handler for strmReadLine(). It is necessary in case
 * strmReadLine() is cancelled while processing the stream. -- rgerhards, 2008-03-27
 */
static void pollFileCancelCleanup(void *pArg)
{
	cstr_t **ppCStr = (cstr_t**) pArg;
	if(*ppCStr != NULL)
		rsCStrDestruct(ppCStr);
}


/* pollFile needs to be split due to the unfortunate pthread_cancel_push() macros. */
static rsRetVal ATTR_NONNULL()
pollFileReal(act_obj_t *act, cstr_t **pCStr)
{
	int64 strtOffs;
	DEFiRet;
	int64_t startOffs = 0;
	int nProcessed = 0;
	regex_t *start_preg = NULL, *end_preg = NULL;

	DBGPRINTF(&quot;pollFileReal enter, act %p, pStrm %p, name '%s'\n&quot;, act, act-&gt;pStrm, act-&gt;name);
	DBGPRINTF(&quot;pollFileReal enter, edge %p\n&quot;, act-&gt;edge);
	DBGPRINTF(&quot;pollFileReal enter, edge-&gt;instarr %p\n&quot;, act-&gt;edge-&gt;instarr);

	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];// TODO: same file, multiple instances?

	if(act-&gt;pStrm == NULL) {
		CHKiRet(openFile(act)); /* open file */
	}

	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;

	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
	/* loop below will be exited when strmReadLine() returns EOF */
	while(glbl.GetGlobalInputTermState() == 0) {
		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
			break;
		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
				inst-&gt;trimLineOverBytes, &amp;strtOffs));
		} else {
			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
				inst-&gt;msgDiscardingError, &amp;strtOffs));
		}
		++nProcessed;
		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
			dbgprintf(&quot;initiating state file write as sufficient data is now present; file=%s\n&quot;,
				act-&gt;name);
			persistStrmState(act);
			startOffs = act-&gt;pStrm-&gt;iCurrOffs; /* disable check */
		}
		runModConf-&gt;bHadFileData = 1; /* this is just a flag, so set it and forget it */
		CHKiRet(enqLine(act, *pCStr, strtOffs)); /* process line */
		rsCStrDestruct(pCStr); /* discard string (must be done by us!) */
		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
			persistStrmState(act);
			act-&gt;nRecords = 0;
		}
	}

finalize_it:
	multiSubmitFlush(&amp;act-&gt;multiSub);
	if(inst-&gt;bPersistStateAfterSubmission) {
		persistStrmState(act);
	}

	if(*pCStr != NULL) {
		rsCStrDestruct(pCStr);
	}

	RETiRet;
}

/* poll a file, need to check file rollover etc. open file if not open */
static rsRetVal ATTR_NONNULL(1)
pollFile(act_obj_t *const act)
{
	cstr_t *pCStr = NULL;
	DEFiRet;
	if (act-&gt;is_symlink) {
		FINALIZE;    /* no reason to poll symlink file */
	}
	/* Note: we must do pthread_cleanup_push() immediately, because the POSIX macros
	 * otherwise do not work if I include the _cleanup_pop() inside an if... -- rgerhards, 2008-08-14
	 */
	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
	iRet = pollFileReal(act, &amp;pCStr);
	pthread_cleanup_pop(0);
finalize_it: RETiRet;
}


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal ATTR_NONNULL(1)
createInstance(instanceConf_t **const pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pszFileName = NULL;
	inst-&gt;pszTag = NULL;
	inst-&gt;pszStateFile = NULL;
	inst-&gt;nMultiSub = NUM_MULTISUB;
	inst-&gt;iSeverity = 5;
	inst-&gt;iFacility = 128;
	inst-&gt;maxLinesAtOnce = 0;
	inst-&gt;trimLineOverBytes = 0;
	inst-&gt;iPersistStateInterval = 0;
	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = 0;
	inst-&gt;startRegex = NULL;
	inst-&gt;endRegex = NULL;
	inst-&gt;discardTruncatedMsg = 0;
	inst-&gt;msgDiscardingError = 1;
	inst-&gt;bRMStateOnDel = 1;
	inst-&gt;escapeLF = 1;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
	inst-&gt;addCeeTag = 0;
	inst-&gt;freshStartTail = 0;
	inst-&gt;fileNotFoundError = 1;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;delay_perMsg = 0;
	inst-&gt;msgFlag = 0;
	inst-&gt;ignoreOlderThan = 0;

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}


/* the basen(ame) buffer must be of size MAXFNAME
 * returns the index of the slash in front of basename
 */
static int ATTR_NONNULL()
getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
{
	int i;
	int found = 0;
	const int lenName = ustrlen(path);
	for(i = lenName ; i &gt;= 0 ; --i) {
		if(path[i] == '/') {
			/* found basename component */
			found = 1;
			if(i == lenName)
				basen[0] = '\0';
			else {
				memcpy(basen, path+i+1, lenName-i);
			}
			break;
		}
	}
	if (found == 1)
		return i;
	else {
		return -1;
	}
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	uchar curr_wd[MAXFNAME];
	DEFiRet;

	/* this is primarily for the clang static analyzer, but also
	 * guards against logic errors in the config handler.
	 */
	if(inst-&gt;pszFileName == NULL)
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);

	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
	if(loadModConf-&gt;normalizePath) {
		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
			DBGPRINTF(&quot;imfile: removing heading './' from name '%s'\n&quot;, inst-&gt;pszFileName);
			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
		}

		if(inst-&gt;pszFileName[0] != '/') {
			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
				LogError(errno, RS_RET_ERR, &quot;imfile: error querying current working &quot;
					&quot;directory - can not continue with %s&quot;, inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const size_t len_curr_wd = ustrlen(curr_wd);
			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
				LogError(0, RS_RET_ERR, &quot;imfile: length of configured file and current &quot;
					&quot;working directory exceeds permitted size - ignoring %s&quot;,
					inst-&gt;pszFileName);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			curr_wd[len_curr_wd] = '/';
			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
			free(inst-&gt;pszFileName);
			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
		}
	}
	dbgprintf(&quot;imfile: adding file monitor for '%s'\n&quot;, inst-&gt;pszFileName);

	if(inst-&gt;pszTag != NULL) {
		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
	}
finalize_it:
	RETiRet;
}


/* add a new monitor */
static rsRetVal
addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	if(cs.pszFileName == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, &quot;imfile error: no file name given, file monitor can &quot;
					&quot;not be created&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if(cs.pszFileTag == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR, &quot;imfile error: no tag value given, file monitor can &quot;
					&quot;not be created&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	CHKiRet(createInstance(&amp;inst));
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}
	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
	if(cs.pszStateFile == NULL) {
		inst-&gt;pszStateFile = NULL;
	} else {
		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
	}
	inst-&gt;iSeverity = cs.iSeverity;
	inst-&gt;iFacility = cs.iFacility;
	if(cs.maxLinesAtOnce) {
		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
				&quot;parameter \&quot;maxLinesAtOnce\&quot; not &quot;
				&quot;permited in inotify mode - ignored&quot;);
		} else {
			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
		}
	}
<A NAME="2"></A>	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
	inst-&gt;ignoreOlderThan = 0;
	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2202-0.html#2',2,'match2202-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
	inst-&gt;bPersistStateAfterSubmission = 0;
	inst-&gt;readMode = cs.readMode;
	inst-&gt;escapeLF = 0;
	inst-&gt;escapeLFString = NULL;
	inst-&gt;reopenOnTruncate = 0;
	inst-&gt;addMetadata = 0;
	inst-&gt;addCeeTag = 0;
	inst-&gt;bRMStateOnDel = 0;
	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
	inst-&gt;msgFlag = 0;</B></FONT>

	CHKiRet(checkInstance(inst));

	/* reset legacy system */
	cs.iPersistStateInterval = 0;
	resetConfigVariables(NULL, NULL); /* values are both dummies */

finalize_it:
	free(pNewVal); /* we do not need it, but we must free it! */
	RETiRet;
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF(&quot;newInpInst (imfile)\n&quot;);

	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
	if(pvals == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		DBGPRINTF(&quot;input param blk in imfile:\n&quot;);
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, &quot;file&quot;)) {
			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;statefile&quot;)) {
			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;removestateondelete&quot;)) {
			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; // TODO: duplicate!
		} else if(!strcmp(inppblk.descr[i].name, &quot;tag&quot;)) {
			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;severity&quot;)) {
			inst-&gt;iSeverity = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;facility&quot;)) {
			inst-&gt;iFacility = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;readmode&quot;)) {
			inst-&gt;readMode = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;startmsg.regex&quot;)) {
			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;endmsg.regex&quot;)) {
			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;discardtruncatedmsg&quot;)) {
			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;msgdiscardingerror&quot;)) {
			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;deletestateonfiledelete&quot;)) {
			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; // TODO: duplicate!
		} else if(!strcmp(inppblk.descr[i].name, &quot;addmetadata&quot;)) {
			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;delay.message&quot;)) {
			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, &quot;addceetag&quot;)) {
			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;freshstarttail&quot;)) {
			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;filenotfounderror&quot;)) {
			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;escapelf&quot;)) {
			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;escapelf.replacement&quot;)) {
			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;reopenontruncate&quot;)) {
			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;maxlinesatonce&quot;)) {
			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
					&quot;parameter \&quot;maxLinesAtOnce\&quot; not &quot;
					&quot;permited in inotify mode - ignored&quot;);
			} else {
				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;trimlineoverbytes&quot;)) {
			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;ignoreolderthan&quot;)) {
			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;persiststateinterval&quot;)) {
			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;maxbytesperminute&quot;)) {
			DBGPRINTF(&quot;imfile: enabling maxbytesperminute ratelimiting\n&quot;);
			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;maxlinesperminute&quot;)) {
			DBGPRINTF(&quot;imfile: enabling maxlinesperminute ratelimiting\n&quot;);
			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;persiststateaftersubmission&quot;)) {
			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;maxsubmitatonce&quot;)) {
			inst-&gt;nMultiSub = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;readtimeout&quot;)) {
			inst-&gt;readTimeout = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;needparse&quot;)) {
			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
		} else {
			DBGPRINTF(&quot;program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
		}
	}
	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
	if(i &gt; 1) {
		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
			&quot;only one of readMode or startmsg.regex or endmsg.regex can be set &quot;
			&quot;at the same time&quot;);
			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
	}

	if(inst-&gt;startRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
			parser_errmsg(&quot;imfile: error in startmsg.regex expansion: %s&quot;, errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;endRegex != NULL) {
		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
		if(errcode != 0) {
			char errbuff[512];
			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
			parser_errmsg(&quot;imfile: error in endmsg.regex expansion: %s&quot;, errbuff);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	if(inst-&gt;readTimeout != 0)
		loadModConf-&gt;haveReadTimeouts = 1;
	iRet = checkInstance(inst);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	currModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;opMode = OPMODE_POLLING;
	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;readTimeout = 0; /* default: no timeout */
	loadModConf-&gt;timeoutGranularity = 1000; /* default: 1 second */
	loadModConf-&gt;haveReadTimeouts = 0; /* default: no timeout */
	loadModConf-&gt;normalizePath = 1;
	loadModConf-&gt;sortFiles = GLOB_NOSORT;
	loadModConf-&gt;stateFileDirectory = NULL;
	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
	loadModConf-&gt;conf_tree-&gt;edges = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	cs.pszFileName = NULL;
	cs.pszFileTag = NULL;
	cs.pszStateFile = NULL;
	cs.iPollInterval = DFLT_PollInterval;
	cs.iPersistStateInterval = 0;
	cs.iFacility = 128;
	cs.iSeverity = 5;
	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	#if defined(HAVE_PORT_SOURCE_FILE)
		/* this means we are on Solaris, so inotify is not there */
		loadModConf-&gt;opMode = OPMODE_FEN;
	#elif defined(HAVE_INOTIFY_INIT)
		loadModConf-&gt;opMode = OPMODE_INOTIFY;
<A NAME="1"></A>	#else
		loadModConf-&gt;opMode = OPMODE_POLLING;
	#endif
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2202-0.html#1',2,'match2202-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;imfile: error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		DBGPRINTF(&quot;module (global) param blk for imfile:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
<A NAME="3"></A>		if(!strcmp(modpblk.descr[i].name, &quot;pollinginterval&quot;)) {
			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;readtimeout&quot;)) {
			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;</B></FONT><FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2202-0.html#3',2,'match2202-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>
		} else if(!strcmp(modpblk.descr[i].name, &quot;timeoutgranularity&quot;)) {
			/* note: we need ms, thus &quot;* 1000&quot; */
			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
		} else if(!strcmp(modpblk.descr[i].name, &quot;sortfiles&quot;)) {
			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;</B></FONT>
		} else if(!strcmp(modpblk.descr[i].name, &quot;statefile.directory&quot;)) {
			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;normalizepath&quot;)) {
			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;mode&quot;)) {
			if(!es_strconstcmp(pvals[i].val.d.estr, &quot;polling&quot;))
				loadModConf-&gt;opMode = OPMODE_POLLING;
			else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;inotify&quot;)) {
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
				loadModConf-&gt;opMode = OPMODE_FEN;
				DBGPRINTF(&quot;inotify mode configured, but only FEN &quot;
					&quot;is available on OS SOLARIS. Switching to FEN &quot;
					&quot;Mode automatically\n&quot;);
#else
				#if defined(HAVE_INOTIFY_INIT)
					loadModConf-&gt;opMode = OPMODE_INOTIFY;
				#else
					loadModConf-&gt;opMode = OPMODE_POLLING;
				#endif
#endif
			} else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;fen&quot;))
				loadModConf-&gt;opMode = OPMODE_FEN;
			else {
				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
				LogError(0, RS_RET_PARAM_ERROR, &quot;imfile: unknown &quot;
					&quot;mode '%s'&quot;, cstr);
				free(cstr);
			}
		} else {
			DBGPRINTF(&quot;program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

	/* remove all of our legacy handlers, as they can not used in addition
	 * the the new-style config method.
	 */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iPollInterval = cs.iPollInterval;
	}
	DBGPRINTF(&quot;opmode is %d, polling interval is %d\n&quot;,
		  loadModConf-&gt;opMode,
		  loadModConf-&gt;iPollInterval);

	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.pszFileName);
	free(cs.pszFileTag);
	free(cs.pszStateFile);
ENDendCnfLoad


BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	if(getStateFileDir() == NULL) {
		/* this intentionally is an error message */
		LogError(0, RS_RET_NO_WRKDIR_SET,
			&quot;imfile: no working or state file directory set, imfile will create &quot;
			&quot;state files in the current working directory (probably &quot;
			&quot;the root dir). Use global(workDirectory=\&quot;/some/path\&quot;) &quot;
			&quot;to set the working directory&quot;);
	}
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	if(pModConf-&gt;root == NULL) {
		LogError(0, RS_RET_NO_LISTNERS,
				&quot;imfile: no files configured to be monitored - &quot;
				&quot;no input will be gathered&quot;);
		iRet = RS_RET_NO_LISTNERS;
	}
ENDcheckCnf


/* note: we do access files AFTER we have dropped privileges. This is
 * intentional, user must make sure the files have the right permissions.
 */
BEGINactivateCnf
	instanceConf_t *inst;
CODESTARTactivateCnf
	runModConf = pModConf;
	currModConf = pModConf;
	if(runModConf-&gt;root == NULL) {
		LogError(0, NO_ERRCODE, &quot;imfile: no file monitors configured, &quot;
				&quot;input not activated.\n&quot;);
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		// TODO: provide switch to turn off this warning?
		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
				LogError(errno, RS_RET_ERR,
					&quot;imfile: on startup file '%s' does not exist &quot;
					&quot;but is configured in static file monitor - this &quot;
					&quot;may indicate a misconfiguration. If the file &quot;
					&quot;appears at a later time, it will automatically &quot;
					&quot;be processed. Reason&quot;, inst-&gt;pszFileName);
			}
		}
		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
	}

	if(Debug) {
		fs_node_print(runModConf-&gt;conf_tree, 0);
	}

finalize_it:
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	fs_node_destroy(pModConf-&gt;conf_tree);
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszFileName);
		free(inst-&gt;pszTag);
		free(inst-&gt;pszStateFile);
		free(inst-&gt;pszFileName_forOldStateFile);
		if(inst-&gt;startRegex != NULL) {
			regfree(&amp;inst-&gt;start_preg);
			free(inst-&gt;startRegex);
		}
		if(inst-&gt;endRegex != NULL) {
			regfree(&amp;inst-&gt;end_preg);
			free(inst-&gt;endRegex);
		}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


/* initial poll run, to be used for all modes. Depending on mode, it does some
 * further initializations (e.g. watches in inotify mode). Most importantly,
 * it processes already-existing files, which would not otherwise be picked
 * up in notifcation modes (inotfiy, FEN). Also, when freshStartTail is set,
 * this run assumes that all previous existing data exists and needs not
 * to be considered.
 * Note: there is a race on files created *during* the run, but that race is
 * inevitable (and thus freshStartTail is actually broken, but users still seem
 * to want it...).
 * rgerhards, 2018-05-17
 */
static void
do_initial_poll_run(void)
{
	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);

	/* fresh start done, so disable freshStartTail for files that now will be created */
	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		inst-&gt;freshStartTail = 0;
	}
}


/* Monitor files in polling mode. */
static rsRetVal
doPolling(void)
{
	DEFiRet;
	do_initial_poll_run();
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF(&quot;doPolling: new poll run\n&quot;);
		do {
			runModConf-&gt;bHadFileData = 0;
			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
			DBGPRINTF(&quot;doPolling: end poll walk, hadData %d\n&quot;, runModConf-&gt;bHadFileData);
		} while(runModConf-&gt;bHadFileData); /* warning: do...while()! */

		/* Note: the additional 10ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 * rgerhards, 2008-02-14
		 */
		DBGPRINTF(&quot;doPolling: poll going to sleep\n&quot;);
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(runModConf-&gt;iPollInterval, 10);
	}

	RETiRet;
}

#if defined(HAVE_INOTIFY_INIT)

static void ATTR_NONNULL(1)
in_dbg_showEv(const struct inotify_event *ev)
{
	if(!Debug)
		return;
	if(ev-&gt;mask &amp; IN_IGNORED) {
		dbgprintf(&quot;INOTIFY event: watch was REMOVED\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_MODIFY) {
		dbgprintf(&quot;INOTIFY event: watch was MODIFID\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_ACCESS) {
		dbgprintf(&quot;INOTIFY event: watch IN_ACCESS\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_ATTRIB) {
		dbgprintf(&quot;INOTIFY event: watch IN_ATTRIB\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
		dbgprintf(&quot;INOTIFY event: watch IN_CLOSE_WRITE\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
		dbgprintf(&quot;INOTIFY event: watch IN_CLOSE_NOWRITE\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_CREATE) {
		dbgprintf(&quot;INOTIFY event: file was CREATED: %s\n&quot;, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_DELETE) {
		dbgprintf(&quot;INOTIFY event: watch IN_DELETE\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
		dbgprintf(&quot;INOTIFY event: watch IN_DELETE_SELF\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
		dbgprintf(&quot;INOTIFY event: watch IN_MOVE_SELF\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
		dbgprintf(&quot;INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n&quot;, ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_MOVED_TO) {
		dbgprintf(&quot;INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n&quot;, ev-&gt;cookie, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; IN_OPEN) {
		dbgprintf(&quot;INOTIFY event: watch IN_OPEN\n&quot;);
	}
	if(ev-&gt;mask &amp; IN_ISDIR) {
		dbgprintf(&quot;INOTIFY event: watch IN_ISDIR\n&quot;);
	}
}


static void ATTR_NONNULL(1, 2)
in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
{
	if(ev-&gt;mask &amp; IN_MODIFY) {
		DBGPRINTF(&quot;fs_node_notify_file_update: act-&gt;name '%s'\n&quot;, etry-&gt;act-&gt;name);
		pollFile(etry-&gt;act);
	} else {
		DBGPRINTF(&quot;got non-expected inotify event:\n&quot;);
		in_dbg_showEv(ev);
	}
}


/* workaround for IN_MOVED: walk active list and prevent state file deletion of
 * IN_MOVED_IN active object
 * TODO: replace by a more generic solution.
 */
static void
flag_in_move(fs_edge_t *const edge, const char *name_moved)
{
	act_obj_t *act;

	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
		DBGPRINTF(&quot;checking active object %s\n&quot;, act-&gt;basename);
		if(!strcmp(act-&gt;basename, name_moved)){
			DBGPRINTF(&quot;found file\n&quot;);
			act-&gt;in_move = 1;
			break;
		} else {
			DBGPRINTF(&quot;name check fails, '%s' != '%s'\n&quot;, act-&gt;basename, name_moved);
		}
	}
	if (!act &amp;&amp; edge-&gt;next) {
		flag_in_move(edge-&gt;next, name_moved);
	}
}

static void ATTR_NONNULL(1)
in_processEvent(struct inotify_event *ev)
{
	if(ev-&gt;mask &amp; IN_IGNORED) {
		DBGPRINTF(&quot;imfile: got IN_IGNORED event\n&quot;);
		goto done;
	}

	DBGPRINTF(&quot;in_processEvent process Event %x for %s\n&quot;, ev-&gt;mask, ev-&gt;name);
	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
	if(etry == NULL) {
		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, &quot;imfile: internal error? &quot;
			&quot;inotify provided watch descriptor %d which we could not find &quot;
			&quot;in our tables - ignored&quot;, ev-&gt;wd);
		goto done;
	}
	DBGPRINTF(&quot;in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n&quot;,
		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);

	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
	}
	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
		in_handleFileEvent(ev, etry); // esentially poll_file()!
	} else {
		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
	}
done:	return;
}


/* Monitor files in inotify mode */
static rsRetVal
do_inotify(void)
{
	char iobuf[8192];
	int rd;
	int currev;
	static int last_timeout = 0;
	struct pollfd pollfd;
	DEFiRet;

	CHKiRet(wdmapInit());
	ino_fd = inotify_init1(IN_NONBLOCK);
	if(ino_fd &lt; 0) {
		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, &quot;imfile: Init inotify &quot;
			&quot;instance failed &quot;);
		return RS_RET_INOTIFY_INIT_FAILED;
	}
	DBGPRINTF(&quot;inotify fd %d\n&quot;, ino_fd);

	do_initial_poll_run();

	while(glbl.GetGlobalInputTermState() == 0) {
		int r;

		pollfd.fd = ino_fd;
		pollfd.events = POLLIN;

		if (runModConf-&gt;haveReadTimeouts)
			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
		else
			r = poll(&amp;pollfd, 1, -1);

		if (r  == -1 &amp;&amp; errno == EINTR) {
			DBGPRINTF(&quot;do_inotify interrupted while polling on ino_fd\n&quot;);
			continue;
		}
		if(r == 0) {
			DBGPRINTF(&quot;readTimeouts are configured, checking if some apply\n&quot;);
			if (runModConf-&gt;haveReadTimeouts) {
				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
				last_timeout = time(NULL);
			}
			continue;
		} else if (r == -1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					&quot;%s:%d: unexpected error during poll timeout wait&quot;,
					__FILE__, __LINE__);
			/* we do not abort, as this would render the whole input defunct */
			continue;
		} else if(r != 1) {
			LogError(errno, RS_RET_INTERNAL_ERROR,
					&quot;%s:%d: ERROR: poll returned more fds (%d) than given to it (1)&quot;,
					__FILE__, __LINE__, r);
			/* we do not abort, as this would render the whole input defunct */
			continue;
		}
		else {
			// process timeouts always, ino_fd may be too busy to ever have timeout occur from poll
			if(runModConf-&gt;haveReadTimeouts) {
				int now = time(NULL);
				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
					last_timeout = time(NULL);
				}
			}
			rd = read(ino_fd, iobuf, sizeof(iobuf));
			if(rd == -1 &amp;&amp; errno == EINTR) {
				/* This might have been our termination signal! */
				DBGPRINTF(&quot;EINTR received during inotify, restarting poll\n&quot;);
				continue;
			}
			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
				continue;
			}
			if(rd &lt; 0) {
				LogError(errno, RS_RET_IO_ERROR, &quot;imfile: error during inotify - ignored&quot;);
				continue;
			}
			currev = 0;
			while(currev &lt; rd) {
				union {
					char *buf;
					struct inotify_event *ev;
				} savecast;
				savecast.buf = iobuf+currev;
				in_dbg_showEv(savecast.ev);
				in_processEvent(savecast.ev);
				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
			}
		}
	}

finalize_it:
	close(ino_fd);
	RETiRet;
}

#else /* #if HAVE_INOTIFY_INIT */
static rsRetVal
do_inotify(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, &quot;imfile: mode set to inotify, but the &quot;
			&quot;platform does not support inotify&quot;);
	return RS_RET_NOT_IMPLEMENTED;
}
#endif /* #if HAVE_INOTIFY_INIT */


/* --- Monitor files in FEN mode (OS_SOLARIS)*/
#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
static void
fen_printevent(int event)
{
	if (event &amp; FILE_ACCESS) {
		DBGPRINTF(&quot; FILE_ACCESS&quot;);
	}
	if (event &amp; FILE_MODIFIED) {
		DBGPRINTF(&quot; FILE_MODIFIED&quot;);
	}
	if (event &amp; FILE_ATTRIB) {
		DBGPRINTF(&quot; FILE_ATTRIB&quot;);
	}
	if (event &amp; FILE_DELETE) {
		DBGPRINTF(&quot; FILE_DELETE&quot;);
	}
	if (event &amp; FILE_RENAME_TO) {
		DBGPRINTF(&quot; FILE_RENAME_TO&quot;);
	}
	if (event &amp; FILE_RENAME_FROM) {
		DBGPRINTF(&quot; FILE_RENAME_FROM&quot;);
	}
	if (event &amp; UNMOUNTED) {
		DBGPRINTF(&quot; UNMOUNTED&quot;);
	}
	if (event &amp; MOUNTEDOVER) {
		DBGPRINTF(&quot; MOUNTEDOVER&quot;);
	}
}


/* https://docs.oracle.com/cd/E19253-01/816-5168/port-get-3c/index.html */
static rsRetVal
do_fen(void)
{
	port_event_t portEvent;
	struct timespec timeout;
	DEFiRet;

	/* Set port timeout to 1 second. We need to check for unmonitored files during meantime */
	// TODO: do we need this timeout at all for equality to old code?
	// TODO: do we need it to support the timeout feature!
	timeout.tv_sec = 300;
	timeout.tv_nsec = 0;

	/* create port instance */
	if((glport = port_create()) == -1) {
		LogError(errno, RS_RET_FEN_INIT_FAILED, &quot;do_fen INIT Port failed &quot;);
		return RS_RET_FEN_INIT_FAILED;
	}

	do_initial_poll_run();

	DBGPRINTF(&quot;do_fen ENTER monitoring loop \n&quot;);
	while(glbl.GetGlobalInputTermState() == 0) {
		DBGPRINTF(&quot;do_fen loop begin... \n&quot;);
		/* Loop through events, if there are any */
		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { // wie inotify-wait
			DBGPRINTF(&quot;do_fen: received port event with &quot;);
			fen_printevent((int) portEvent.portev_events);
			DBGPRINTF(&quot;\n&quot;);
			if(portEvent.portev_source != PORT_SOURCE_FILE) {
				LogError(errno, RS_RET_SYS_ERR, &quot;do_fen: Event from unexpected source &quot;
					&quot;: %d\n&quot;, portEvent.portev_source);
				continue;
			}
			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
			DBGPRINTF(&quot;do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n&quot;,
				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
			if(act-&gt;is_deleted) {
				free(act-&gt;name);
				free(act);
				continue;
			}

			/* we need to re-associate the object */
			act-&gt;bPortAssociated = 0;
			fen_setupWatch(act);

			if(act-&gt;edge-&gt;is_file) {
				pollFile(act);
			} else {
				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
			}
		}
	}

	/* close port, will de-activate all file events watches associated
	 * with the port.
	 */
	close(glport);
	RETiRet;
}
#else /* #if OS_SOLARIS */
static rsRetVal
do_fen(void)
{
	LogError(0, RS_RET_NOT_IMPLEMENTED, &quot;do_fen: mode set to fen, but the &quot;
			&quot;platform does not support fen&quot;);
	return RS_RET_NOT_IMPLEMENTED;
}
#endif /* #if OS_SOLARIS */


/* This function is called by the framework to gather the input. The module stays
 * most of its lifetime inside this function. It MUST NEVER exit this function. Doing
 * so would end module processing and rsyslog would NOT reschedule the module. If
 * you exit from this function, you violate the interface specification!
 */
BEGINrunInput
CODESTARTrunInput
	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) /* use FEN on Solaris! */
	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
		DBGPRINTF(&quot;auto-adjusting 'inotify' mode to 'fen' on Solaris\n&quot;);
		runModConf-&gt;opMode = OPMODE_FEN;
	}
	#endif
	DBGPRINTF(&quot;working in %s mode\n&quot;,
		 (runModConf-&gt;opMode == OPMODE_POLLING) ? &quot;polling&quot; :
			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?&quot;inotify&quot; : &quot;fen&quot;));
	if(runModConf-&gt;opMode == OPMODE_POLLING)
		iRet = doPolling();
	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
		iRet = do_inotify();
	else if(runModConf-&gt;opMode == OPMODE_FEN)
		iRet = do_fen();
	else {
		LogError(0, RS_RET_NOT_IMPLEMENTED, &quot;imfile: unknown mode %d set&quot;,
			runModConf-&gt;opMode);
		return RS_RET_NOT_IMPLEMENTED;
	}
	DBGPRINTF(&quot;terminating upon request of rsyslog core\n&quot;);
ENDrunInput


/* The function is called by rsyslog before runInput() is called. It is a last chance
 * to set up anything specific. Most importantly, it can be used to tell rsyslog if the
 * input shall run or not. The idea is that if some config settings (or similiar things)
 * are not OK, the input can tell rsyslog it will not execute. To do so, return
 * RS_RET_NO_RUN or a specific error code. If RS_RET_OK is returned, rsyslog will
 * proceed and call the runInput() entry point.
 */
BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imfile&quot;), sizeof(&quot;imfile&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun

// TODO: refactor this into a generically-usable &quot;atomic file creation&quot; utility for
// all kinds of &quot;state files&quot;
static rsRetVal ATTR_NONNULL()
atomicWriteStateFile(const char *fn, const char *content)
{
	DEFiRet;
	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if(fd &lt; 0) {
		LogError(errno, RS_RET_IO_ERROR, &quot;imfile: cannot open state file '%s' for &quot;
			&quot;persisting file state - some data will probably be duplicated &quot;
			&quot;on next startup&quot;, fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	const size_t toWrite = strlen(content);
	const ssize_t w = write(fd, content, toWrite);
	if(w != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR, &quot;imfile: partial write to state file '%s' &quot;
			&quot;this may cause trouble in the future. We will try to delete the &quot;
			&quot;state file, as this provides most consistent state&quot;, fn);
		unlink(fn);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

finalize_it:
	if(fd &gt;= 0) {
		close(fd);
	}
	RETiRet;
}

/* This function should be called after any file ID change - that is if
 * file grown from hash-only statefile, or was truncated, this will ensure
 * we delete the old file so we do not make garbage in our working dir and
 * there are no leftover statefiles which can in theory later bind to something
 * and cause data loss.
 * jvymazal 2019-11-27
 */
static void
removeOldStatefile(const uchar *statefn, const char *hashToDelete)
{
	int ret;
	uchar statefname[MAXFNAME];

	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
	DBGPRINTF(&quot;removing old state file: '%s'\n&quot;, statefname);
	ret = unlink((const char*)statefname);
	if(ret != 0) {
		if (errno != ENOENT) {
			LogError(errno, RS_RET_IO_ERROR,
				&quot;imfile error trying to delete old state file: '%s' - ignoring this &quot;
				&quot;error, usually this means a file no longer file is left over, but &quot;
				&quot;this may also cause some real trouble. Still the best we can do &quot;,
				statefname);
		} else {
			DBGPRINTF(&quot;trying to delete no longer valid statefile '%s' which no &quot;
					  &quot;longer exists (probably already deleted)\n&quot;, statefname);
		}
	}
}


/* This function persists information for a specific file being monitored.
 * To do so, it simply persists the stream object. We do NOT abort on error
 * iRet as that makes matters worse (at least we can try persisting the others...).
 * rgerhards, 2008-02-13
 */
static rsRetVal ATTR_NONNULL()
persistStrmState(act_obj_t *const act)
{
	DEFiRet;
	uchar statefile[MAXFNAME];
	uchar statefname[MAXFNAME];

	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
	getFileID(act);
	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
	DBGPRINTF(&quot;persisting state for '%s', state file '%s'\n&quot;, act-&gt;name, statefname);

	struct json_object *jval = NULL;
	struct json_object *json = NULL;
	CHKmalloc(json = json_object_new_object());
	jval = json_object_new_string((char*) act-&gt;name);
	json_object_object_add(json, &quot;filename&quot;, jval);
	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
	json_object_object_add(json, &quot;prev_was_nl&quot;, jval);

	/* we access some data items a bit dirty, as we need to refactor the whole
	 * thing in any case - TODO
	 */
	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
	json_object_object_add(json, &quot;curr_offs&quot;, jval);
	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
	json_object_object_add(json, &quot;strt_offs&quot;, jval);

	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
	if(prevLineSegment != NULL) {
		jval = json_object_new_string((const char*) prevLineSegment);
		json_object_object_add(json, &quot;prev_line_segment&quot;, jval);
	}

	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
	if(prevMsgSegment != NULL) {
		jval = json_object_new_string((const char*) prevMsgSegment);
		json_object_object_add(json, &quot;prev_msg_segment&quot;, jval);
	}

	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);

	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
	json_object_put(json);

	/* file-id changed remove the old statefile */
	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
		removeOldStatefile(statefn, act-&gt;file_id_prev);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, &quot;imfile: could not persist state &quot;
				&quot;file %s - data may be repeated on next &quot;
				&quot;startup. Is WorkDirectory set?&quot;,
				statefname);
	}

	RETiRet;
}

/* This function is called by the framework after runInput() has been terminated. It
 * shall free any resources and prepare the module for unload.
 */
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* The following entry points are defined in module-template.h.
 * In general, they need to be present, but you do NOT need to provide
 * any code here.
 */
BEGINmodExit
CODESTARTmodExit
	/* release objects we used */
	objRelease(strm, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);

	#ifdef HAVE_INOTIFY_INIT
	free(wdmap);
	#endif
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


/* The following function shall reset all configuration variables to their
 * default values. The code provided in modInit() below registers it to be
 * called on &quot;$ResetConfigVariables&quot;. You may also call it from other places,
 * but in general this is not necessary. Once runInput() has been called, this
 * function here is never again called.
 */
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;

	free(cs.pszFileName);
	cs.pszFileName = NULL;
	free(cs.pszFileTag);
	cs.pszFileTag = NULL;
	free(cs.pszStateFile);
	cs.pszStateFile = NULL;

	/* set defaults... */
	cs.iPollInterval = DFLT_PollInterval;
	cs.iFacility = 128; /* local0 */
	cs.iSeverity = 5;  /* notice, as of rfc 3164 */
	cs.readMode = 0;
	cs.maxLinesAtOnce = 10240;
	cs.trimLineOverBytes = 0;

	RETiRet;
}

static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, &quot;imfile: ruleset '%s' for %s not found - &quot;
			&quot;using default ruleset instead&quot;, inst-&gt;pszBindRuleset,
			inst-&gt;pszFileName);
}

/* modInit() is called once the module is loaded. It must perform all module-wide
 * initialization tasks. There are also a number of housekeeping tasks that the
 * framework requires. These are handled by the macros. Please note that the
 * complexity of processing is depending on the actual module. However, only
 * thing absolutely necessary should be done here. Actual app-level processing
 * is to be performed in runInput(). A good sample of what to do here may be to
 * set some variable defaults.
 */
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(strm, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF(&quot;version %s initializing\n&quot;, VERSION);
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilename&quot;, 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfiletag&quot;, 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilestatefile&quot;, 0, eCmdHdlrGetWord,
	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfileseverity&quot;, 0, eCmdHdlrSeverity,
	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilefacility&quot;, 0, eCmdHdlrFacility,
	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilereadmode&quot;, 0, eCmdHdlrInt,
	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilemaxlinesatonce&quot;, 0, eCmdHdlrSize,
	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfiletrimlineoverbytes&quot;, 0, eCmdHdlrSize,
	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilepersiststateinterval&quot;, 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputfilebindruleset&quot;, 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
	/* that command ads a new file! */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputrunfilemonitor&quot;, 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	/* module-global config params - will be disabled in configs that are loaded
	 * via module(...).
	 */
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;inputfilepollinterval&quot;, 0, eCmdHdlrInt,
	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
