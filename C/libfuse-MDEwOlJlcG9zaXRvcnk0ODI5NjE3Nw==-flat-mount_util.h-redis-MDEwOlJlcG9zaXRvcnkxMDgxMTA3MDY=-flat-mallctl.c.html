
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8169014084507045%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount_util.h</h3>
            <pre><code>1  #include <sys/types.h>
<span onclick='openModal()' class='match'>2  int fuse_mnt_add_mount(const char *progname, const char *fsname,
3  		       const char *mnt, const char *type, const char *opts);
</span>4  int fuse_mnt_remove_mount(const char *progname, const char *mnt);
5  int fuse_mnt_umount(const char *progname, const char *abs_mnt,
6  		    const char *rel_mnt, int lazy);
7  char *fuse_mnt_resolve_path(const char *progname, const char *orig);
8  int fuse_mnt_check_fuseblk(void);
9  int fuse_mnt_parse_fuse_fd(const char *mountpoint);
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/hook.h"
3  #include "jemalloc/internal/util.h"
4  TEST_BEGIN(test_mallctl_errors) {
5  	uint64_t epoch;
6  	size_t sz;
7  	assert_d_eq(mallctl("no_such_name", NULL, NULL, NULL, 0), ENOENT,
8  	    "mallctl() should return ENOENT for non-existent names");
9  	assert_d_eq(mallctl("version", NULL, NULL, "0.0.0", strlen("0.0.0")),
10  	    EPERM, "mallctl() should return EPERM on attempt to write "
11  	    "read-only value");
12  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
13  	    sizeof(epoch)-1), EINVAL,
14  	    "mallctl() should return EINVAL for input size mismatch");
15  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
16  	    sizeof(epoch)+1), EINVAL,
17  	    "mallctl() should return EINVAL for input size mismatch");
18  	sz = sizeof(epoch)-1;
19  	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
20  	    "mallctl() should return EINVAL for output size mismatch");
21  	sz = sizeof(epoch)+1;
22  	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
23  	    "mallctl() should return EINVAL for output size mismatch");
24  }
25  TEST_END
26  TEST_BEGIN(test_mallctlnametomib_errors) {
27  	size_t mib[1];
28  	size_t miblen;
29  	miblen = sizeof(mib)/sizeof(size_t);
30  	assert_d_eq(mallctlnametomib("no_such_name", mib, &miblen), ENOENT,
31  	    "mallctlnametomib() should return ENOENT for non-existent names");
32  }
33  TEST_END
34  TEST_BEGIN(test_mallctlbymib_errors) {
35  	uint64_t epoch;
36  	size_t sz;
37  	size_t mib[1];
38  	size_t miblen;
39  	miblen = sizeof(mib)/sizeof(size_t);
40  	assert_d_eq(mallctlnametomib("version", mib, &miblen), 0,
41  	    "Unexpected mallctlnametomib() failure");
42  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, "0.0.0",
43  	    strlen("0.0.0")), EPERM, "mallctl() should return EPERM on "
44  	    "attempt to write read-only value");
45  	miblen = sizeof(mib)/sizeof(size_t);
46  	assert_d_eq(mallctlnametomib("epoch", mib, &miblen), 0,
47  	    "Unexpected mallctlnametomib() failure");
48  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&epoch,
49  	    sizeof(epoch)-1), EINVAL,
50  	    "mallctlbymib() should return EINVAL for input size mismatch");
51  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&epoch,
52  	    sizeof(epoch)+1), EINVAL,
53  	    "mallctlbymib() should return EINVAL for input size mismatch");
54  	sz = sizeof(epoch)-1;
55  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
56  	    EINVAL,
57  	    "mallctlbymib() should return EINVAL for output size mismatch");
58  	sz = sizeof(epoch)+1;
59  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
60  	    EINVAL,
61  	    "mallctlbymib() should return EINVAL for output size mismatch");
62  }
63  TEST_END
64  TEST_BEGIN(test_mallctl_read_write) {
65  	uint64_t old_epoch, new_epoch;
66  	size_t sz = sizeof(old_epoch);
67  	assert_d_eq(mallctl("epoch", NULL, NULL, NULL, 0), 0,
68  	    "Unexpected mallctl() failure");
69  	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
70  	assert_d_eq(mallctl("epoch", (void *)&old_epoch, &sz, NULL, 0), 0,
71  	    "Unexpected mallctl() failure");
72  	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
73  	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&new_epoch,
74  	    sizeof(new_epoch)), 0, "Unexpected mallctl() failure");
75  	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
76  	assert_d_eq(mallctl("epoch", (void *)&old_epoch, &sz,
77  	    (void *)&new_epoch, sizeof(new_epoch)), 0,
78  	    "Unexpected mallctl() failure");
79  	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
80  }
81  TEST_END
82  TEST_BEGIN(test_mallctlnametomib_short_mib) {
83  	size_t mib[4];
84  	size_t miblen;
85  	miblen = 3;
86  	mib[3] = 42;
87  	assert_d_eq(mallctlnametomib("arenas.bin.0.nregs", mib, &miblen), 0,
88  	    "Unexpected mallctlnametomib() failure");
89  	assert_zu_eq(miblen, 3, "Unexpected mib output length");
90  	assert_zu_eq(mib[3], 42,
91  	    "mallctlnametomib() wrote past the end of the input mib");
92  }
93  TEST_END
94  TEST_BEGIN(test_mallctl_config) {
95  #define TEST_MALLCTL_CONFIG(config, t) do {				\
96  	t oldval;							\
97  	size_t sz = sizeof(oldval);					\
98  	assert_d_eq(mallctl("config."#config, (void *)&oldval, &sz,	\
99  	    NULL, 0), 0, "Unexpected mallctl() failure");		\
100  	assert_b_eq(oldval, config_##config, "Incorrect config value");	\
101  	assert_zu_eq(sz, sizeof(oldval), "Unexpected output size");	\
102  } while (0)
103  	TEST_MALLCTL_CONFIG(cache_oblivious, bool);
104  	TEST_MALLCTL_CONFIG(debug, bool);
105  	TEST_MALLCTL_CONFIG(fill, bool);
106  	TEST_MALLCTL_CONFIG(lazy_lock, bool);
107  	TEST_MALLCTL_CONFIG(malloc_conf, const char *);
108  	TEST_MALLCTL_CONFIG(prof, bool);
109  	TEST_MALLCTL_CONFIG(prof_libgcc, bool);
110  	TEST_MALLCTL_CONFIG(prof_libunwind, bool);
111  	TEST_MALLCTL_CONFIG(stats, bool);
112  	TEST_MALLCTL_CONFIG(utrace, bool);
113  	TEST_MALLCTL_CONFIG(xmalloc, bool);
114  #undef TEST_MALLCTL_CONFIG
115  }
116  TEST_END
117  TEST_BEGIN(test_mallctl_opt) {
118  	bool config_always = true;
119  #define TEST_MALLCTL_OPT(t, opt, config) do {				\
120  	t oldval;							\
121  	size_t sz = sizeof(oldval);					\
122  	int expected = config_##config ? 0 : ENOENT;			\
123  	int result = mallctl("opt."#opt, (void *)&oldval, &sz, NULL,	\
124  	    0);								\
125  	assert_d_eq(result, expected,					\
126  	    "Unexpected mallctl() result for opt."#opt);		\
127  	assert_zu_eq(sz, sizeof(oldval), "Unexpected output size");	\
128  } while (0)
129  	TEST_MALLCTL_OPT(bool, abort, always);
130  	TEST_MALLCTL_OPT(bool, abort_conf, always);
131  	TEST_MALLCTL_OPT(bool, confirm_conf, always);
132  	TEST_MALLCTL_OPT(const char *, metadata_thp, always);
133  	TEST_MALLCTL_OPT(bool, retain, always);
134  	TEST_MALLCTL_OPT(const char *, dss, always);
135  	TEST_MALLCTL_OPT(unsigned, narenas, always);
<span onclick='openModal()' class='match'>136  	TEST_MALLCTL_OPT(const char *, percpu_arena, always);
137  	TEST_MALLCTL_OPT(size_t, oversize_threshold, always);
138  	TEST_MALLCTL_OPT(bool, background_thread, always);
139  	TEST_MALLCTL_OPT(ssize_t, dirty_decay_ms, always);
140  	TEST_MALLCTL_OPT(ssize_t, muzzy_decay_ms, always);
141  	TEST_MALLCTL_OPT(bool, stats_print, always);
142  	TEST_MALLCTL_OPT(const char *, junk, fill);
143  	TEST_MALLCTL_OPT(bool, zero, fill);
144  	TEST_MALLCTL_OPT(bool, utrace, utrace);
145  	TEST_MALLCTL_OPT(bool, xmalloc, xmalloc);
146  	TEST_MALLCTL_OPT(bool, tcache, always);
147  	TEST_MALLCTL_OPT(size_t, lg_extent_max_active_fit, always);
148  	TEST_MALLCTL_OPT(size_t, lg_tcache_max, always);
149  	TEST_MALLCTL_OPT(const char *, thp, always);
150  	TEST_MALLCTL_OPT(bool, prof, prof);
151  	TEST_MALLCTL_OPT(const char *, prof_prefix, prof);
</span>152  	TEST_MALLCTL_OPT(bool, prof_active, prof);
153  	TEST_MALLCTL_OPT(ssize_t, lg_prof_sample, prof);
154  	TEST_MALLCTL_OPT(bool, prof_accum, prof);
155  	TEST_MALLCTL_OPT(ssize_t, lg_prof_interval, prof);
156  	TEST_MALLCTL_OPT(bool, prof_gdump, prof);
157  	TEST_MALLCTL_OPT(bool, prof_final, prof);
158  	TEST_MALLCTL_OPT(bool, prof_leak, prof);
159  #undef TEST_MALLCTL_OPT
160  }
161  TEST_END
162  TEST_BEGIN(test_manpage_example) {
163  	unsigned nbins, i;
164  	size_t mib[4];
165  	size_t len, miblen;
166  	len = sizeof(nbins);
167  	assert_d_eq(mallctl("arenas.nbins", (void *)&nbins, &len, NULL, 0), 0,
168  	    "Unexpected mallctl() failure");
169  	miblen = 4;
170  	assert_d_eq(mallctlnametomib("arenas.bin.0.size", mib, &miblen), 0,
171  	    "Unexpected mallctlnametomib() failure");
172  	for (i = 0; i < nbins; i++) {
173  		size_t bin_size;
174  		mib[2] = i;
175  		len = sizeof(bin_size);
176  		assert_d_eq(mallctlbymib(mib, miblen, (void *)&bin_size, &len,
177  		    NULL, 0), 0, "Unexpected mallctlbymib() failure");
178  	}
179  }
180  TEST_END
181  TEST_BEGIN(test_tcache_none) {
182  	test_skip_if(!opt_tcache);
183  	void *p0 = mallocx(42, 0);
184  	assert_ptr_not_null(p0, "Unexpected mallocx() failure");
185  	void *q = mallocx(42, 0);
186  	assert_ptr_not_null(q, "Unexpected mallocx() failure");
187  	dallocx(p0, 0);
188  	dallocx(q, MALLOCX_TCACHE_NONE);
189  	void *p1 = mallocx(42, 0);
190  	assert_ptr_not_null(p1, "Unexpected mallocx() failure");
191  	assert_ptr_eq(p0, p1, "Expected tcache to allocate cached region");
192  	dallocx(p1, MALLOCX_TCACHE_NONE);
193  }
194  TEST_END
195  TEST_BEGIN(test_tcache) {
196  #define NTCACHES	10
197  	unsigned tis[NTCACHES];
198  	void *ps[NTCACHES];
199  	void *qs[NTCACHES];
200  	unsigned i;
201  	size_t sz, psz, qsz;
202  	psz = 42;
203  	qsz = nallocx(psz, 0) + 1;
204  	for (i = 0; i < NTCACHES; i++) {
205  		sz = sizeof(unsigned);
206  		assert_d_eq(mallctl("tcache.create", (void *)&tis[i], &sz, NULL,
207  		    0), 0, "Unexpected mallctl() failure, i=%u", i);
208  	}
209  	for (i = 0; i < NTCACHES; i++) {
210  		assert_d_eq(mallctl("tcache.destroy", NULL, NULL,
211  		    (void *)&tis[i], sizeof(unsigned)), 0,
212  		    "Unexpected mallctl() failure, i=%u", i);
213  	}
214  	for (i = 0; i < NTCACHES; i++) {
215  		sz = sizeof(unsigned);
216  		assert_d_eq(mallctl("tcache.create", (void *)&tis[i], &sz, NULL,
217  		    0), 0, "Unexpected mallctl() failure, i=%u", i);
218  	}
219  	for (i = 0; i < NTCACHES; i++) {
220  		assert_d_eq(mallctl("tcache.flush", NULL, NULL, (void *)&tis[i],
221  		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
222  		    i);
223  	}
224  	for (i = 0; i < NTCACHES; i++) {
225  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
226  		assert_ptr_not_null(ps[i], "Unexpected mallocx() failure, i=%u",
227  		    i);
228  		dallocx(ps[i], MALLOCX_TCACHE(tis[i]));
229  		qs[i] = mallocx(qsz, MALLOCX_TCACHE(tis[i]));
230  		assert_ptr_not_null(qs[i], "Unexpected mallocx() failure, i=%u",
231  		    i);
232  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
233  	}
234  	for (i = 0; i < NTCACHES; i++) {
235  		void *p0 = ps[i];
236  		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
237  		assert_ptr_not_null(ps[i], "Unexpected mallocx() failure, i=%u",
238  		    i);
239  		assert_ptr_eq(ps[i], p0,
240  		    "Expected mallocx() to allocate cached region, i=%u", i);
241  	}
242  	for (i = 0; i < NTCACHES; i++) {
243  		void *q0 = qs[i];
244  		qs[i] = rallocx(ps[i], qsz, MALLOCX_TCACHE(tis[i]));
245  		assert_ptr_not_null(qs[i], "Unexpected rallocx() failure, i=%u",
246  		    i);
247  		assert_ptr_eq(qs[i], q0,
248  		    "Expected rallocx() to allocate cached region, i=%u", i);
249  		if (qs[i] == NULL) {
250  			qs[i] = ps[i];
251  		}
252  	}
253  	for (i = 0; i < NTCACHES; i++) {
254  		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
255  	}
256  	for (i = 0; i < NTCACHES/2; i++) {
257  		assert_d_eq(mallctl("tcache.flush", NULL, NULL, (void *)&tis[i],
258  		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
259  		    i);
260  	}
261  	for (i = 0; i < NTCACHES; i++) {
262  		assert_d_eq(mallctl("tcache.destroy", NULL, NULL,
263  		    (void *)&tis[i], sizeof(unsigned)), 0,
264  		    "Unexpected mallctl() failure, i=%u", i);
265  	}
266  }
267  TEST_END
268  TEST_BEGIN(test_thread_arena) {
269  	unsigned old_arena_ind, new_arena_ind, narenas;
270  	const char *opa;
271  	size_t sz = sizeof(opa);
272  	assert_d_eq(mallctl("opt.percpu_arena", (void *)&opa, &sz, NULL, 0), 0,
273  	    "Unexpected mallctl() failure");
274  	sz = sizeof(unsigned);
275  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
276  	    0, "Unexpected mallctl() failure");
277  	if (opt_oversize_threshold != 0) {
278  		narenas--;
279  	}
280  	assert_u_eq(narenas, opt_narenas, "Number of arenas incorrect");
281  	if (strcmp(opa, "disabled") == 0) {
282  		new_arena_ind = narenas - 1;
283  		assert_d_eq(mallctl("thread.arena", (void *)&old_arena_ind, &sz,
284  		    (void *)&new_arena_ind, sizeof(unsigned)), 0,
285  		    "Unexpected mallctl() failure");
286  		new_arena_ind = 0;
287  		assert_d_eq(mallctl("thread.arena", (void *)&old_arena_ind, &sz,
288  		    (void *)&new_arena_ind, sizeof(unsigned)), 0,
289  		    "Unexpected mallctl() failure");
290  	} else {
291  		assert_d_eq(mallctl("thread.arena", (void *)&old_arena_ind, &sz,
292  		    NULL, 0), 0, "Unexpected mallctl() failure");
293  		new_arena_ind = percpu_arena_ind_limit(opt_percpu_arena) - 1;
294  		if (old_arena_ind != new_arena_ind) {
295  			assert_d_eq(mallctl("thread.arena",
296  			    (void *)&old_arena_ind, &sz, (void *)&new_arena_ind,
297  			    sizeof(unsigned)), EPERM, "thread.arena ctl "
298  			    "should not be allowed with percpu arena");
299  		}
300  	}
301  }
302  TEST_END
303  TEST_BEGIN(test_arena_i_initialized) {
304  	unsigned narenas, i;
305  	size_t sz;
306  	size_t mib[3];
307  	size_t miblen = sizeof(mib) / sizeof(size_t);
308  	bool initialized;
309  	sz = sizeof(narenas);
310  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
311  	    0, "Unexpected mallctl() failure");
312  	assert_d_eq(mallctlnametomib("arena.0.initialized", mib, &miblen), 0,
313  	    "Unexpected mallctlnametomib() failure");
314  	for (i = 0; i < narenas; i++) {
315  		mib[1] = i;
316  		sz = sizeof(initialized);
317  		assert_d_eq(mallctlbymib(mib, miblen, &initialized, &sz, NULL,
318  		    0), 0, "Unexpected mallctl() failure");
319  	}
320  	mib[1] = MALLCTL_ARENAS_ALL;
321  	sz = sizeof(initialized);
322  	assert_d_eq(mallctlbymib(mib, miblen, &initialized, &sz, NULL, 0), 0,
323  	    "Unexpected mallctl() failure");
324  	assert_true(initialized,
325  	    "Merged arena statistics should always be initialized");
326  	sz = sizeof(initialized);
327  	assert_d_eq(mallctl(
328  	    "arena." STRINGIFY(MALLCTL_ARENAS_ALL) ".initialized",
329  	    (void *)&initialized, &sz, NULL, 0), 0,
330  	    "Unexpected mallctl() failure");
331  	assert_true(initialized,
332  	    "Merged arena statistics should always be initialized");
333  }
334  TEST_END
335  TEST_BEGIN(test_arena_i_dirty_decay_ms) {
336  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
337  	size_t sz = sizeof(ssize_t);
338  	assert_d_eq(mallctl("arena.0.dirty_decay_ms",
339  	    (void *)&orig_dirty_decay_ms, &sz, NULL, 0), 0,
340  	    "Unexpected mallctl() failure");
341  	dirty_decay_ms = -2;
342  	assert_d_eq(mallctl("arena.0.dirty_decay_ms", NULL, NULL,
343  	    (void *)&dirty_decay_ms, sizeof(ssize_t)), EFAULT,
344  	    "Unexpected mallctl() success");
345  	dirty_decay_ms = 0x7fffffff;
346  	assert_d_eq(mallctl("arena.0.dirty_decay_ms", NULL, NULL,
347  	    (void *)&dirty_decay_ms, sizeof(ssize_t)), 0,
348  	    "Unexpected mallctl() failure");
349  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
350  	    dirty_decay_ms < 20; prev_dirty_decay_ms = dirty_decay_ms,
351  	    dirty_decay_ms++) {
352  		ssize_t old_dirty_decay_ms;
353  		assert_d_eq(mallctl("arena.0.dirty_decay_ms",
354  		    (void *)&old_dirty_decay_ms, &sz, (void *)&dirty_decay_ms,
355  		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
356  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
357  		    "Unexpected old arena.0.dirty_decay_ms");
358  	}
359  }
360  TEST_END
361  TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
362  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
363  	size_t sz = sizeof(ssize_t);
364  	assert_d_eq(mallctl("arena.0.muzzy_decay_ms",
365  	    (void *)&orig_muzzy_decay_ms, &sz, NULL, 0), 0,
366  	    "Unexpected mallctl() failure");
367  	muzzy_decay_ms = -2;
368  	assert_d_eq(mallctl("arena.0.muzzy_decay_ms", NULL, NULL,
369  	    (void *)&muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
370  	    "Unexpected mallctl() success");
371  	muzzy_decay_ms = 0x7fffffff;
372  	assert_d_eq(mallctl("arena.0.muzzy_decay_ms", NULL, NULL,
373  	    (void *)&muzzy_decay_ms, sizeof(ssize_t)), 0,
374  	    "Unexpected mallctl() failure");
375  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
376  	    muzzy_decay_ms < 20; prev_muzzy_decay_ms = muzzy_decay_ms,
377  	    muzzy_decay_ms++) {
378  		ssize_t old_muzzy_decay_ms;
379  		assert_d_eq(mallctl("arena.0.muzzy_decay_ms",
380  		    (void *)&old_muzzy_decay_ms, &sz, (void *)&muzzy_decay_ms,
381  		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
382  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
383  		    "Unexpected old arena.0.muzzy_decay_ms");
384  	}
385  }
386  TEST_END
387  TEST_BEGIN(test_arena_i_purge) {
388  	unsigned narenas;
389  	size_t sz = sizeof(unsigned);
390  	size_t mib[3];
391  	size_t miblen = 3;
392  	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
393  	    "Unexpected mallctl() failure");
394  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
395  	    0, "Unexpected mallctl() failure");
396  	assert_d_eq(mallctlnametomib("arena.0.purge", mib, &miblen), 0,
397  	    "Unexpected mallctlnametomib() failure");
398  	mib[1] = narenas;
399  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
400  	    "Unexpected mallctlbymib() failure");
401  	mib[1] = MALLCTL_ARENAS_ALL;
402  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
403  	    "Unexpected mallctlbymib() failure");
404  }
405  TEST_END
406  TEST_BEGIN(test_arena_i_decay) {
407  	unsigned narenas;
408  	size_t sz = sizeof(unsigned);
409  	size_t mib[3];
410  	size_t miblen = 3;
411  	assert_d_eq(mallctl("arena.0.decay", NULL, NULL, NULL, 0), 0,
412  	    "Unexpected mallctl() failure");
413  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
414  	    0, "Unexpected mallctl() failure");
415  	assert_d_eq(mallctlnametomib("arena.0.decay", mib, &miblen), 0,
416  	    "Unexpected mallctlnametomib() failure");
417  	mib[1] = narenas;
418  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
419  	    "Unexpected mallctlbymib() failure");
420  	mib[1] = MALLCTL_ARENAS_ALL;
421  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
422  	    "Unexpected mallctlbymib() failure");
423  }
424  TEST_END
425  TEST_BEGIN(test_arena_i_dss) {
426  	const char *dss_prec_old, *dss_prec_new;
427  	size_t sz = sizeof(dss_prec_old);
428  	size_t mib[3];
429  	size_t miblen;
430  	miblen = sizeof(mib)/sizeof(size_t);
431  	assert_d_eq(mallctlnametomib("arena.0.dss", mib, &miblen), 0,
432  	    "Unexpected mallctlnametomib() error");
433  	dss_prec_new = "disabled";
434  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz,
435  	    (void *)&dss_prec_new, sizeof(dss_prec_new)), 0,
436  	    "Unexpected mallctl() failure");
437  	assert_str_ne(dss_prec_old, "primary",
438  	    "Unexpected default for dss precedence");
439  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_new, &sz,
440  	    (void *)&dss_prec_old, sizeof(dss_prec_old)), 0,
441  	    "Unexpected mallctl() failure");
442  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz, NULL,
443  	    0), 0, "Unexpected mallctl() failure");
444  	assert_str_ne(dss_prec_old, "primary",
445  	    "Unexpected value for dss precedence");
446  	mib[1] = narenas_total_get();
447  	dss_prec_new = "disabled";
448  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz,
449  	    (void *)&dss_prec_new, sizeof(dss_prec_new)), 0,
450  	    "Unexpected mallctl() failure");
451  	assert_str_ne(dss_prec_old, "primary",
452  	    "Unexpected default for dss precedence");
453  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_new, &sz,
454  	    (void *)&dss_prec_old, sizeof(dss_prec_new)), 0,
455  	    "Unexpected mallctl() failure");
456  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz, NULL,
457  	    0), 0, "Unexpected mallctl() failure");
458  	assert_str_ne(dss_prec_old, "primary",
459  	    "Unexpected value for dss precedence");
460  }
461  TEST_END
462  TEST_BEGIN(test_arena_i_retain_grow_limit) {
463  	size_t old_limit, new_limit, default_limit;
464  	size_t mib[3];
465  	size_t miblen;
466  	bool retain_enabled;
467  	size_t sz = sizeof(retain_enabled);
468  	assert_d_eq(mallctl("opt.retain", &retain_enabled, &sz, NULL, 0),
469  	    0, "Unexpected mallctl() failure");
470  	test_skip_if(!retain_enabled);
471  	sz = sizeof(default_limit);
472  	miblen = sizeof(mib)/sizeof(size_t);
473  	assert_d_eq(mallctlnametomib("arena.0.retain_grow_limit", mib, &miblen),
474  	    0, "Unexpected mallctlnametomib() error");
475  	assert_d_eq(mallctlbymib(mib, miblen, &default_limit, &sz, NULL, 0), 0,
476  	    "Unexpected mallctl() failure");
477  	assert_zu_eq(default_limit, SC_LARGE_MAXCLASS,
478  	    "Unexpected default for retain_grow_limit");
479  	new_limit = PAGE - 1;
480  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &new_limit,
481  	    sizeof(new_limit)), EFAULT, "Unexpected mallctl() success");
482  	new_limit = PAGE + 1;
483  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &new_limit,
484  	    sizeof(new_limit)), 0, "Unexpected mallctl() failure");
485  	assert_d_eq(mallctlbymib(mib, miblen, &old_limit, &sz, NULL, 0), 0,
486  	    "Unexpected mallctl() failure");
487  	assert_zu_eq(old_limit, PAGE,
488  	    "Unexpected value for retain_grow_limit");
489  	new_limit = sz_pind2sz(10) - 1;
490  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &new_limit,
491  	    sizeof(new_limit)), 0, "Unexpected mallctl() failure");
492  	assert_d_eq(mallctlbymib(mib, miblen, &old_limit, &sz, NULL, 0), 0,
493  	    "Unexpected mallctl() failure");
494  	assert_zu_eq(old_limit, sz_pind2sz(9),
495  	    "Unexpected value for retain_grow_limit");
496  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &default_limit,
497  	    sizeof(default_limit)), 0, "Unexpected mallctl() failure");
498  }
499  TEST_END
500  TEST_BEGIN(test_arenas_dirty_decay_ms) {
501  	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
502  	size_t sz = sizeof(ssize_t);
503  	assert_d_eq(mallctl("arenas.dirty_decay_ms",
504  	    (void *)&orig_dirty_decay_ms, &sz, NULL, 0), 0,
505  	    "Unexpected mallctl() failure");
506  	dirty_decay_ms = -2;
507  	assert_d_eq(mallctl("arenas.dirty_decay_ms", NULL, NULL,
508  	    (void *)&dirty_decay_ms, sizeof(ssize_t)), EFAULT,
509  	    "Unexpected mallctl() success");
510  	dirty_decay_ms = 0x7fffffff;
511  	assert_d_eq(mallctl("arenas.dirty_decay_ms", NULL, NULL,
512  	    (void *)&dirty_decay_ms, sizeof(ssize_t)), 0,
513  	    "Expected mallctl() failure");
514  	for (prev_dirty_decay_ms = dirty_decay_ms, dirty_decay_ms = -1;
515  	    dirty_decay_ms < 20; prev_dirty_decay_ms = dirty_decay_ms,
516  	    dirty_decay_ms++) {
517  		ssize_t old_dirty_decay_ms;
518  		assert_d_eq(mallctl("arenas.dirty_decay_ms",
519  		    (void *)&old_dirty_decay_ms, &sz, (void *)&dirty_decay_ms,
520  		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
521  		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
522  		    "Unexpected old arenas.dirty_decay_ms");
523  	}
524  }
525  TEST_END
526  TEST_BEGIN(test_arenas_muzzy_decay_ms) {
527  	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
528  	size_t sz = sizeof(ssize_t);
529  	assert_d_eq(mallctl("arenas.muzzy_decay_ms",
530  	    (void *)&orig_muzzy_decay_ms, &sz, NULL, 0), 0,
531  	    "Unexpected mallctl() failure");
532  	muzzy_decay_ms = -2;
533  	assert_d_eq(mallctl("arenas.muzzy_decay_ms", NULL, NULL,
534  	    (void *)&muzzy_decay_ms, sizeof(ssize_t)), EFAULT,
535  	    "Unexpected mallctl() success");
536  	muzzy_decay_ms = 0x7fffffff;
537  	assert_d_eq(mallctl("arenas.muzzy_decay_ms", NULL, NULL,
538  	    (void *)&muzzy_decay_ms, sizeof(ssize_t)), 0,
539  	    "Expected mallctl() failure");
540  	for (prev_muzzy_decay_ms = muzzy_decay_ms, muzzy_decay_ms = -1;
541  	    muzzy_decay_ms < 20; prev_muzzy_decay_ms = muzzy_decay_ms,
542  	    muzzy_decay_ms++) {
543  		ssize_t old_muzzy_decay_ms;
544  		assert_d_eq(mallctl("arenas.muzzy_decay_ms",
545  		    (void *)&old_muzzy_decay_ms, &sz, (void *)&muzzy_decay_ms,
546  		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
547  		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
548  		    "Unexpected old arenas.muzzy_decay_ms");
549  	}
550  }
551  TEST_END
552  TEST_BEGIN(test_arenas_constants) {
553  #define TEST_ARENAS_CONSTANT(t, name, expected) do {			\
554  	t name;								\
555  	size_t sz = sizeof(t);						\
556  	assert_d_eq(mallctl("arenas."#name, (void *)&name, &sz, NULL,	\
557  	    0), 0, "Unexpected mallctl() failure");			\
558  	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
559  } while (0)
560  	TEST_ARENAS_CONSTANT(size_t, quantum, QUANTUM);
561  	TEST_ARENAS_CONSTANT(size_t, page, PAGE);
562  	TEST_ARENAS_CONSTANT(unsigned, nbins, SC_NBINS);
563  	TEST_ARENAS_CONSTANT(unsigned, nlextents, SC_NSIZES - SC_NBINS);
564  #undef TEST_ARENAS_CONSTANT
565  }
566  TEST_END
567  TEST_BEGIN(test_arenas_bin_constants) {
568  #define TEST_ARENAS_BIN_CONSTANT(t, name, expected) do {		\
569  	t name;								\
570  	size_t sz = sizeof(t);						\
571  	assert_d_eq(mallctl("arenas.bin.0."#name, (void *)&name, &sz,	\
572  	    NULL, 0), 0, "Unexpected mallctl() failure");		\
573  	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
574  } while (0)
575  	TEST_ARENAS_BIN_CONSTANT(size_t, size, bin_infos[0].reg_size);
576  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nregs, bin_infos[0].nregs);
577  	TEST_ARENAS_BIN_CONSTANT(size_t, slab_size,
578  	    bin_infos[0].slab_size);
579  	TEST_ARENAS_BIN_CONSTANT(uint32_t, nshards, bin_infos[0].n_shards);
580  #undef TEST_ARENAS_BIN_CONSTANT
581  }
582  TEST_END
583  TEST_BEGIN(test_arenas_lextent_constants) {
584  #define TEST_ARENAS_LEXTENT_CONSTANT(t, name, expected) do {		\
585  	t name;								\
586  	size_t sz = sizeof(t);						\
587  	assert_d_eq(mallctl("arenas.lextent.0."#name, (void *)&name,	\
588  	    &sz, NULL, 0), 0, "Unexpected mallctl() failure");		\
589  	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
590  } while (0)
591  	TEST_ARENAS_LEXTENT_CONSTANT(size_t, size,
592  	    SC_LARGE_MINCLASS);
593  #undef TEST_ARENAS_LEXTENT_CONSTANT
594  }
595  TEST_END
596  TEST_BEGIN(test_arenas_create) {
597  	unsigned narenas_before, arena, narenas_after;
598  	size_t sz = sizeof(unsigned);
599  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas_before, &sz,
600  	    NULL, 0), 0, "Unexpected mallctl() failure");
601  	assert_d_eq(mallctl("arenas.create", (void *)&arena, &sz, NULL, 0), 0,
602  	    "Unexpected mallctl() failure");
603  	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas_after, &sz, NULL,
604  	    0), 0, "Unexpected mallctl() failure");
605  	assert_u_eq(narenas_before+1, narenas_after,
606  	    "Unexpected number of arenas before versus after extension");
607  	assert_u_eq(arena, narenas_after-1, "Unexpected arena index");
608  }
609  TEST_END
610  TEST_BEGIN(test_arenas_lookup) {
611  	unsigned arena, arena1;
612  	void *ptr;
613  	size_t sz = sizeof(unsigned);
614  	assert_d_eq(mallctl("arenas.create", (void *)&arena, &sz, NULL, 0), 0,
615  	    "Unexpected mallctl() failure");
616  	ptr = mallocx(42, MALLOCX_ARENA(arena) | MALLOCX_TCACHE_NONE);
617  	assert_ptr_not_null(ptr, "Unexpected mallocx() failure");
618  	assert_d_eq(mallctl("arenas.lookup", &arena1, &sz, &ptr, sizeof(ptr)),
619  	    0, "Unexpected mallctl() failure");
620  	assert_u_eq(arena, arena1, "Unexpected arena index");
621  	dallocx(ptr, 0);
622  }
623  TEST_END
624  TEST_BEGIN(test_stats_arenas) {
625  #define TEST_STATS_ARENAS(t, name) do {					\
626  	t name;								\
627  	size_t sz = sizeof(t);						\
628  	assert_d_eq(mallctl("stats.arenas.0."#name, (void *)&name, &sz,	\
629  	    NULL, 0), 0, "Unexpected mallctl() failure");		\
630  } while (0)
631  	TEST_STATS_ARENAS(unsigned, nthreads);
632  	TEST_STATS_ARENAS(const char *, dss);
633  	TEST_STATS_ARENAS(ssize_t, dirty_decay_ms);
634  	TEST_STATS_ARENAS(ssize_t, muzzy_decay_ms);
635  	TEST_STATS_ARENAS(size_t, pactive);
636  	TEST_STATS_ARENAS(size_t, pdirty);
637  #undef TEST_STATS_ARENAS
638  }
639  TEST_END
640  static void
641  alloc_hook(void *extra, UNUSED hook_alloc_t type, UNUSED void *result,
642      UNUSED uintptr_t result_raw, UNUSED uintptr_t args_raw[3]) {
643  	*(bool *)extra = true;
644  }
645  static void
646  dalloc_hook(void *extra, UNUSED hook_dalloc_t type,
647      UNUSED void *address, UNUSED uintptr_t args_raw[3]) {
648  	*(bool *)extra = true;
649  }
650  TEST_BEGIN(test_hooks) {
651  	bool hook_called = false;
652  	hooks_t hooks = {&alloc_hook, &dalloc_hook, NULL, &hook_called};
653  	void *handle = NULL;
654  	size_t sz = sizeof(handle);
655  	int err = mallctl("experimental.hooks.install", &handle, &sz, &hooks,
656  	    sizeof(hooks));
657  	assert_d_eq(err, 0, "Hook installation failed");
658  	assert_ptr_ne(handle, NULL, "Hook installation gave null handle");
659  	void *ptr = mallocx(1, 0);
660  	assert_true(hook_called, "Alloc hook not called");
661  	hook_called = false;
662  	free(ptr);
663  	assert_true(hook_called, "Free hook not called");
664  	err = mallctl("experimental.hooks.remove", NULL, NULL, &handle,
665  	    sizeof(handle));
666  	assert_d_eq(err, 0, "Hook removal failed");
667  	hook_called = false;
668  	ptr = mallocx(1, 0);
669  	free(ptr);
670  	assert_false(hook_called, "Hook called after removal");
671  }
672  TEST_END
673  TEST_BEGIN(test_hooks_exhaustion) {
674  	bool hook_called = false;
675  	hooks_t hooks = {&alloc_hook, &dalloc_hook, NULL, &hook_called};
676  	void *handle;
677  	void *handles[HOOK_MAX];
678  	size_t sz = sizeof(handle);
679  	int err;
680  	for (int i = 0; i < HOOK_MAX; i++) {
681  		handle = NULL;
682  		err = mallctl("experimental.hooks.install", &handle, &sz,
683  		    &hooks, sizeof(hooks));
684  		assert_d_eq(err, 0, "Error installation hooks");
685  		assert_ptr_ne(handle, NULL, "Got NULL handle");
686  		handles[i] = handle;
687  	}
688  	err = mallctl("experimental.hooks.install", &handle, &sz, &hooks,
689  	    sizeof(hooks));
690  	assert_d_eq(err, EAGAIN, "Should have failed hook installation");
691  	for (int i = 0; i < HOOK_MAX; i++) {
692  		err = mallctl("experimental.hooks.remove", NULL, NULL,
693  		    &handles[i], sizeof(handles[i]));
694  		assert_d_eq(err, 0, "Hook removal failed");
695  	}
696  	handle = NULL;
697  	err = mallctl("experimental.hooks.install", &handle, &sz, &hooks,
698  	    sizeof(hooks));
699  	assert_d_eq(err, 0, "Hook insertion failed");
700  	assert_ptr_ne(handle, NULL, "Got NULL handle");
701  	err = mallctl("experimental.hooks.remove", NULL, NULL, &handle,
702  	    sizeof(handle));
703  	assert_d_eq(err, 0, "Hook removal failed");
704  }
705  TEST_END
706  int
707  main(void) {
708  	return test(
709  	    test_mallctl_errors,
710  	    test_mallctlnametomib_errors,
711  	    test_mallctlbymib_errors,
712  	    test_mallctl_read_write,
713  	    test_mallctlnametomib_short_mib,
714  	    test_mallctl_config,
715  	    test_mallctl_opt,
716  	    test_manpage_example,
717  	    test_tcache_none,
718  	    test_tcache,
719  	    test_thread_arena,
720  	    test_arena_i_initialized,
721  	    test_arena_i_dirty_decay_ms,
722  	    test_arena_i_muzzy_decay_ms,
723  	    test_arena_i_purge,
724  	    test_arena_i_decay,
725  	    test_arena_i_dss,
726  	    test_arena_i_retain_grow_limit,
727  	    test_arenas_dirty_decay_ms,
728  	    test_arenas_muzzy_decay_ms,
729  	    test_arenas_constants,
730  	    test_arenas_bin_constants,
731  	    test_arenas_lextent_constants,
732  	    test_arenas_create,
733  	    test_arenas_lookup,
734  	    test_stats_arenas,
735  	    test_hooks,
736  	    test_hooks_exhaustion);
737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount_util.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallctl.c</div>
                </div>
                <div class="column column_space"><pre><code>2  int fuse_mnt_add_mount(const char *progname, const char *fsname,
3  		       const char *mnt, const char *type, const char *opts);
</pre></code></div>
                <div class="column column_space"><pre><code>136  	TEST_MALLCTL_OPT(const char *, percpu_arena, always);
137  	TEST_MALLCTL_OPT(size_t, oversize_threshold, always);
138  	TEST_MALLCTL_OPT(bool, background_thread, always);
139  	TEST_MALLCTL_OPT(ssize_t, dirty_decay_ms, always);
140  	TEST_MALLCTL_OPT(ssize_t, muzzy_decay_ms, always);
141  	TEST_MALLCTL_OPT(bool, stats_print, always);
142  	TEST_MALLCTL_OPT(const char *, junk, fill);
143  	TEST_MALLCTL_OPT(bool, zero, fill);
144  	TEST_MALLCTL_OPT(bool, utrace, utrace);
145  	TEST_MALLCTL_OPT(bool, xmalloc, xmalloc);
146  	TEST_MALLCTL_OPT(bool, tcache, always);
147  	TEST_MALLCTL_OPT(size_t, lg_extent_max_active_fit, always);
148  	TEST_MALLCTL_OPT(size_t, lg_tcache_max, always);
149  	TEST_MALLCTL_OPT(const char *, thp, always);
150  	TEST_MALLCTL_OPT(bool, prof, prof);
151  	TEST_MALLCTL_OPT(const char *, prof_prefix, prof);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    