<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for dns_parser.c &amp; msg.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for dns_parser.c &amp; msg.c
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>dns_parser.c (11.063829%)<th>msg.c (0.5110063%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(194-205)<td><a href="#" name="0">(699-710)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(173-181)<td><a href="#" name="1">(3104-3110)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dns_parser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "parsers.h"
static const char *dns_rcodes[] = {
		"NoError",  		"FormErr",  		"ServFail", 		"NXDomain", 		"NotImp",   		"Refused",  		"YXDomain", 		"YXRRSet",  		"NXRRSet",  		"NotAuth",  		"NotZone",  		"",         		"",         		"",         		"",         		"",         		"BADVERS|BADSIG", 		"BADKEY",   		"BADTIME",  		"BADMODE",  		"BADNAME",  		"BADALG",   		"BADTRUNC",  		NULL
};
static const char *dns_types[] = {
		0,
		"A",        		"NS",       		"MD",       		"MF",       		"CNAME",    		"SOA",      		"MB",       		"MG",       		"MR",       		"NULL",     		"WKS",      		"PTR",      		"HINFO",    		"MINFO",    		"MX",       		"TXT",      		"RP",       		"AFSDB",    		"X25",      		"ISDN",     		"RT",       		"NSAP",     		"NSAP-PTR", 		"SIG",      		"KEY",      		"PX",       		"GPOS",     		"AAAA",     		"LOC",      		"NXT",      		"EID",      		"NIMLOC",   		"SRV",      		"ATMA",     		"NAPTR",    		"KX",       		"CERT",     		"A6",       		"DNAME",    		"SINK",     		"OPT",      		"APL",      		"DS",       		"SSHFP",    		"IPSECKEY", 		"RRSIG",    		"NSEC",     		"DNSKEY",   		"DHCID",    		"NSEC3",    		"NSEC3PARAM",   		"TLSA",     		"SMIMEA",   		"Unassigned",   		"HIP",      		"NINFO",    		"RKEY",     		"TALINK",   		"CDS",      		"CDNSKEY",  		"OPENPGPKEY",   		"CSYNC",    		"ZONEMD",   		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		"SPF",      		"UINFO",    		"UID",      		"GID",      		"UNSPEC",   		"NID",      		"L32",      		"L64",      		"LP",       		"EUI48",    		"EUI64",    		NULL
};
static const char *dns_types2[] = {
		"TKEY",
		"TSIG",
		"IXFR",
		"AXFR",
		"MAILB",
		"MAILA",
		"*",
		"URI",
		"CAA",
		"AVC",
		"DOA",
		"AMTRELAY",
		NULL
};
static const char *dns_types3[] = {
		"TA",
		"DLV",
		NULL
};
static const char *get_type(uint16_t x) {
	const char **types = NULL;
<a name="1"></a>	uint16_t len_types3 = (sizeof(dns_types3) / sizeof(char *)) - 1;
	uint16_t len_types2 = (sizeof(dns_types2) / sizeof(char *)) - 1;
	uint16_t len_types = (sizeof(dns_types) / sizeof(char *)) - 1;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if (x &gt;= 32768 &amp;&amp; x &lt; 32768 + len_types3) {
		types = dns_types3;
		x -= 32768;
	}
	else if (x &gt;= 249 &amp;&amp; x &lt; 249 + len_types2) {
		types = dns_types2;
		x -= 249;
	}
	else if (x &gt; 0 &amp;&amp; x &lt; len_types)</b></font>
		types = dns_types;
	else
		return "UNKNOWN";
	if (types[x] != NULL)
		return types[x];
	return "UNKNOWN";
}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const char *get_class(uint16_t x) {
	switch (x) {
		case 1:
			return "IN";
		case 3:
			return "CH";
		case 4:
			return "HS";
		case 254:
			return "QCLASS NONE";
		case 255:
			return "QCLASS *";</b></font>
	}
	return "UNKNOWN";
}
data_ret_t *dns_parse(const uchar *packet, int pktSize, struct json_object *jparent) {
	const uchar *packet_ptr = packet;
	const uchar *end_packet = packet + pktSize;
	DBGPRINTF("dns_parse\n");
	DBGPRINTF("packet size %d\n", pktSize);
	union {
		unsigned short int *two_bytes;
		const uchar *pckt;
	} union_short_int;
	union_short_int.pckt = packet_ptr;
	unsigned short int transaction_id = ntohs(*(union_short_int.two_bytes));
	union_short_int.pckt += 2;
	unsigned short int flags = ntohs(*(union_short_int.two_bytes));
	unsigned short int response_flag = (flags &gt;&gt; 15) &amp; 0b1; 
	unsigned short int opcode = (flags &gt;&gt; 11) &amp; 0b1111;
	unsigned short int reserved = (flags &gt;&gt; 6) &amp; 0b1;
	if (reserved != 0) {
		DBGPRINTF("DNS packet reserved bit (Z) is not 0, aborting message. \n");
		RETURN_DATA_AFTER(0)
	}
	unsigned short int reply_code = flags &amp; 0b1111;
	union_short_int.pckt += 2;
	unsigned short int query_count = ntohs(*(union_short_int.two_bytes));
	union_short_int.pckt += 2;
	unsigned short int answer_count = ntohs(*(union_short_int.two_bytes));
	union_short_int.pckt += 2;
	unsigned short int authority_count = ntohs(*(union_short_int.two_bytes));
	union_short_int.pckt += 2;
	unsigned short int additionnal_count = ntohs(*(union_short_int.two_bytes));
	union_short_int.pckt += 2;
	packet_ptr = union_short_int.pckt;
	fjson_object *queries = NULL;
	if ((queries = json_object_new_array()) == NULL) {
		DBGPRINTF("impcap::dns_parser: Cannot create new json array. Stopping.\n");
		RETURN_DATA_AFTER(0)
	}
	int query_cpt = 0;
	while (query_cpt &lt; query_count &amp;&amp; packet_ptr &lt; end_packet) {
		size_t query_size = strnlen((const char *)packet_ptr, (size_t)(end_packet - packet_ptr));
		if (query_size &gt;= 256) {
			DBGPRINTF("impcap::dns_parser: Length of domain queried is &gt; 255. Stopping.\n");
			break;
		}
		if (query_size + 5 &gt; (size_t)(end_packet - packet_ptr)) {
			DBGPRINTF("impcap::dns_parser: packet size too small to parse query. Stopping.\n");
			break;
		}
		fjson_object *query = NULL;
		if ((query = json_object_new_object()) == NULL) {
			DBGPRINTF("impcap::dns_parser: Cannot create new json object. Stopping.\n");
			break;
		}
		char domain_query[256] = {0};
		uchar nb_char = *packet_ptr;
		packet_ptr++;
		size_t cpt = 0;
		while (cpt + 1 &lt; query_size) {
			if (nb_char == 0) {
				nb_char = *packet_ptr;
				domain_query[cpt] = '.';
			} else {
				domain_query[cpt] = (char)*packet_ptr;
				nb_char--;
			}
			cpt++;
			packet_ptr++;
		}
		domain_query[cpt] = '\0';
		if (cpt)
			packet_ptr++; 
		json_object_object_add(query, "qname", json_object_new_string(domain_query));
		union_short_int.pckt = packet_ptr;
		unsigned short int qtype = ntohs(*(union_short_int.two_bytes));
		json_object_object_add(query, "qtype", json_object_new_int((int)qtype));
		json_object_object_add(query, "type", json_object_new_string(get_type(qtype)));
		union_short_int.pckt += 2;
		unsigned short int qclass = ntohs(*(union_short_int.two_bytes));
		json_object_object_add(query, "qclass", json_object_new_int((int)qclass));
		json_object_object_add(query, "class", json_object_new_string(get_class(qclass)));
		packet_ptr = union_short_int.pckt + 2;
		json_object_array_add(queries, query);
		query_cpt++;
	}
	json_object_object_add(jparent, "DNS_transaction_id", json_object_new_int((int)transaction_id));
	json_bool is_reponse = FALSE;
	if (response_flag)
		is_reponse = TRUE;
	json_object_object_add(jparent, "DNS_response_flag", json_object_new_boolean(is_reponse));
	json_object_object_add(jparent, "DNS_opcode", json_object_new_int(opcode));
	json_object_object_add(jparent, "DNS_rcode", json_object_new_int((int)reply_code));
	json_object_object_add(jparent, "DNS_error", json_object_new_string(dns_rcodes[reply_code]));
	json_object_object_add(jparent, "DNS_QDCOUNT", json_object_new_int((int)query_count));
	json_object_object_add(jparent, "DNS_ANCOUNT", json_object_new_int((int)answer_count));
	json_object_object_add(jparent, "DNS_NSCOUNT", json_object_new_int((int)authority_count));
	json_object_object_add(jparent, "DNS_ARCOUNT", json_object_new_int((int)additionnal_count));
	json_object_object_add(jparent, "DNS_Names", queries);
	RETURN_DATA_AFTER(0);
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>msg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#define SYSLOG_NAMES
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/socket.h&gt;
#ifdef HAVE_SYSINFO_UPTIME
#include &lt;sys/sysinfo.h&gt;
#endif
#include &lt;netdb.h&gt;
#include &lt;libestr.h&gt;
#include &lt;json.h&gt;
#ifdef HAVE_MALLOC_H
#  include &lt;malloc.h&gt;
#endif
#ifdef USE_LIBUUID
#  include &lt;uuid/uuid.h&gt;
#endif
#include &lt;errno.h&gt;
#include "rsyslog.h"
#include "srUtils.h"
#include "stringbuf.h"
#include "template.h"
#include "msg.h"
#include "datetime.h"
#include "glbl.h"
#include "regexp.h"
#include "atomic.h"
#include "unicode-helper.h"
#include "ruleset.h"
#include "prop.h"
#include "net.h"
#include "var.h"
#include "rsconf.h"
#include "parserif.h"
#include "errmsg.h"
#define DEV_DEBUG 0	
extern void msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri);
static pthread_mutex_t glblVars_lock;
struct json_object *global_var_root = NULL;
DEFobjStaticHelpers
DEFobjCurrIf(datetime)
DEFobjCurrIf(glbl)
DEFobjCurrIf(regexp)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
DEFobjCurrIf(var)
static const char *one_digit[10] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };
static const char *two_digits[100] = {
	"00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
	"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
	"20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
	"30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
	"40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
	"50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
	"60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
	"70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
	"80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
	"90", "91", "92", "93", "94", "95", "96", "97", "98", "99"};
static const char *wdayNames[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
static const char *daysInYear[366] = {
	       "001", "002", "003", "004", "005", "006", "007", "008", "009",
	"010", "011", "012", "013", "014", "015", "016", "017", "018", "019",
	"020", "021", "022", "023", "024", "025", "026", "027", "028", "029",
	"030", "031", "032", "033", "034", "035", "036", "037", "038", "039",
	"040", "041", "042", "043", "044", "045", "046", "047", "048", "049",
	"050", "051", "052", "053", "054", "055", "056", "057", "058", "059",
	"060", "061", "062", "063", "064", "065", "066", "067", "068", "069",
	"070", "071", "072", "073", "074", "075", "076", "077", "078", "079",
	"080", "081", "082", "083", "084", "085", "086", "087", "088", "089",
	"090", "091", "092", "093", "094", "095", "096", "097", "098", "099",
	"100", "101", "102", "103", "104", "105", "106", "107", "108", "109",
	"110", "111", "112", "113", "114", "115", "116", "117", "118", "119",
	"120", "121", "122", "123", "124", "125", "126", "127", "128", "129",
	"130", "131", "132", "133", "134", "135", "136", "137", "138", "139",
	"140", "141", "142", "143", "144", "145", "146", "147", "148", "149",
	"150", "151", "152", "153", "154", "155", "156", "157", "158", "159",
	"160", "161", "162", "163", "164", "165", "166", "167", "168", "169",
	"170", "171", "172", "173", "174", "175", "176", "177", "178", "179",
	"180", "181", "182", "183", "184", "185", "186", "187", "188", "189",
	"190", "191", "192", "193", "194", "195", "196", "197", "198", "199",
	"200", "201", "202", "203", "204", "205", "206", "207", "208", "209",
	"210", "211", "212", "213", "214", "215", "216", "217", "218", "219",
	"220", "221", "222", "223", "224", "225", "226", "227", "228", "229",
	"230", "231", "232", "233", "234", "235", "236", "237", "238", "239",
	"240", "241", "242", "243", "244", "245", "246", "247", "248", "249",
	"250", "251", "252", "253", "254", "255", "256", "257", "258", "259",
	"260", "261", "262", "263", "264", "265", "266", "267", "268", "269",
	"270", "271", "272", "273", "274", "275", "276", "277", "278", "279",
	"280", "281", "282", "283", "284", "285", "286", "287", "288", "289",
	"290", "291", "292", "293", "294", "295", "296", "297", "298", "299",
	"300", "301", "302", "303", "304", "305", "306", "307", "308", "309",
	"310", "311", "312", "313", "314", "315", "316", "317", "318", "319",
	"320", "321", "322", "323", "324", "325", "326", "327", "328", "329",
	"330", "331", "332", "333", "334", "335", "336", "337", "338", "339",
	"340", "341", "342", "343", "344", "345", "346", "347", "348", "349",
	"350", "351", "352", "353", "354", "355", "356", "357", "358", "359",
	"360", "361", "362", "363", "364", "365", "366"};
static const char *years[] = {
	"1967", "1968", "1969", "1970", "1971", "1972", "1973", "1974",
	"1975", "1976", "1977", "1978", "1979", "1980", "1981", "1982",
	"1983", "1984", "1985", "1986", "1987", "1988", "1989", "1990",
	"1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998",
	"1999", "2000", "2001", "2002", "2003", "2004", "2005", "2006",
	"2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014",
	"2015", "2016", "2017", "2018", "2019", "2020", "2021", "2022",
	"2023", "2024", "2025", "2026", "2027", "2028", "2029", "2030",
	"2031", "2032", "2033", "2034", "2035", "2036", "2037", "2038",
	"2039", "2040", "2041", "2042", "2043", "2044", "2045", "2046",
	"2047", "2048", "2049", "2050", "2051", "2052", "2053", "2054",
	"2055", "2056", "2057", "2058", "2059", "2060", "2061", "2062",
	"2063", "2064", "2065", "2066", "2067", "2068", "2069", "2070",
	"2071", "2072", "2073", "2074", "2075", "2076", "2077", "2078",
	"2079", "2080", "2081", "2082", "2083", "2084", "2085", "2086",
	"2087", "2088", "2089", "2090", "2091", "2092", "2093", "2094",
	"2095", "2096", "2097", "2098", "2099" };
static struct {
	uchar *pszName;
} syslog_pri_names[200] = {
	{ UCHAR_CONSTANT("0") },
	{ UCHAR_CONSTANT("1") },
	{ UCHAR_CONSTANT("2") },
	{ UCHAR_CONSTANT("3") },
	{ UCHAR_CONSTANT("4") },
	{ UCHAR_CONSTANT("5") },
	{ UCHAR_CONSTANT("6") },
	{ UCHAR_CONSTANT("7") },
	{ UCHAR_CONSTANT("8") },
	{ UCHAR_CONSTANT("9") },
	{ UCHAR_CONSTANT("10") },
	{ UCHAR_CONSTANT("11") },
	{ UCHAR_CONSTANT("12") },
	{ UCHAR_CONSTANT("13") },
	{ UCHAR_CONSTANT("14") },
	{ UCHAR_CONSTANT("15") },
	{ UCHAR_CONSTANT("16") },
	{ UCHAR_CONSTANT("17") },
	{ UCHAR_CONSTANT("18") },
	{ UCHAR_CONSTANT("19") },
	{ UCHAR_CONSTANT("20") },
	{ UCHAR_CONSTANT("21") },
	{ UCHAR_CONSTANT("22") },
	{ UCHAR_CONSTANT("23") },
	{ UCHAR_CONSTANT("24") },
	{ UCHAR_CONSTANT("25") },
	{ UCHAR_CONSTANT("26") },
	{ UCHAR_CONSTANT("27") },
	{ UCHAR_CONSTANT("28") },
	{ UCHAR_CONSTANT("29") },
	{ UCHAR_CONSTANT("30") },
	{ UCHAR_CONSTANT("31") },
	{ UCHAR_CONSTANT("32") },
	{ UCHAR_CONSTANT("33") },
	{ UCHAR_CONSTANT("34") },
	{ UCHAR_CONSTANT("35") },
	{ UCHAR_CONSTANT("36") },
	{ UCHAR_CONSTANT("37") },
	{ UCHAR_CONSTANT("38") },
	{ UCHAR_CONSTANT("39") },
	{ UCHAR_CONSTANT("40") },
	{ UCHAR_CONSTANT("41") },
	{ UCHAR_CONSTANT("42") },
	{ UCHAR_CONSTANT("43") },
	{ UCHAR_CONSTANT("44") },
	{ UCHAR_CONSTANT("45") },
	{ UCHAR_CONSTANT("46") },
	{ UCHAR_CONSTANT("47") },
	{ UCHAR_CONSTANT("48") },
	{ UCHAR_CONSTANT("49") },
	{ UCHAR_CONSTANT("50") },
	{ UCHAR_CONSTANT("51") },
	{ UCHAR_CONSTANT("52") },
	{ UCHAR_CONSTANT("53") },
	{ UCHAR_CONSTANT("54") },
	{ UCHAR_CONSTANT("55") },
	{ UCHAR_CONSTANT("56") },
	{ UCHAR_CONSTANT("57") },
	{ UCHAR_CONSTANT("58") },
	{ UCHAR_CONSTANT("59") },
	{ UCHAR_CONSTANT("60") },
	{ UCHAR_CONSTANT("61") },
	{ UCHAR_CONSTANT("62") },
	{ UCHAR_CONSTANT("63") },
	{ UCHAR_CONSTANT("64") },
	{ UCHAR_CONSTANT("65") },
	{ UCHAR_CONSTANT("66") },
	{ UCHAR_CONSTANT("67") },
	{ UCHAR_CONSTANT("68") },
	{ UCHAR_CONSTANT("69") },
	{ UCHAR_CONSTANT("70") },
	{ UCHAR_CONSTANT("71") },
	{ UCHAR_CONSTANT("72") },
	{ UCHAR_CONSTANT("73") },
	{ UCHAR_CONSTANT("74") },
	{ UCHAR_CONSTANT("75") },
	{ UCHAR_CONSTANT("76") },
	{ UCHAR_CONSTANT("77") },
	{ UCHAR_CONSTANT("78") },
	{ UCHAR_CONSTANT("79") },
	{ UCHAR_CONSTANT("80") },
	{ UCHAR_CONSTANT("81") },
	{ UCHAR_CONSTANT("82") },
	{ UCHAR_CONSTANT("83") },
	{ UCHAR_CONSTANT("84") },
	{ UCHAR_CONSTANT("85") },
	{ UCHAR_CONSTANT("86") },
	{ UCHAR_CONSTANT("87") },
	{ UCHAR_CONSTANT("88") },
	{ UCHAR_CONSTANT("89") },
	{ UCHAR_CONSTANT("90") },
	{ UCHAR_CONSTANT("91") },
	{ UCHAR_CONSTANT("92") },
	{ UCHAR_CONSTANT("93") },
	{ UCHAR_CONSTANT("94") },
	{ UCHAR_CONSTANT("95") },
	{ UCHAR_CONSTANT("96") },
	{ UCHAR_CONSTANT("97") },
	{ UCHAR_CONSTANT("98") },
	{ UCHAR_CONSTANT("99") },
	{ UCHAR_CONSTANT("100") },
	{ UCHAR_CONSTANT("101") },
	{ UCHAR_CONSTANT("102") },
	{ UCHAR_CONSTANT("103") },
	{ UCHAR_CONSTANT("104") },
	{ UCHAR_CONSTANT("105") },
	{ UCHAR_CONSTANT("106") },
	{ UCHAR_CONSTANT("107") },
	{ UCHAR_CONSTANT("108") },
	{ UCHAR_CONSTANT("109") },
	{ UCHAR_CONSTANT("110") },
	{ UCHAR_CONSTANT("111") },
	{ UCHAR_CONSTANT("112") },
	{ UCHAR_CONSTANT("113") },
	{ UCHAR_CONSTANT("114") },
	{ UCHAR_CONSTANT("115") },
	{ UCHAR_CONSTANT("116") },
	{ UCHAR_CONSTANT("117") },
	{ UCHAR_CONSTANT("118") },
	{ UCHAR_CONSTANT("119") },
	{ UCHAR_CONSTANT("120") },
	{ UCHAR_CONSTANT("121") },
	{ UCHAR_CONSTANT("122") },
	{ UCHAR_CONSTANT("123") },
	{ UCHAR_CONSTANT("124") },
	{ UCHAR_CONSTANT("125") },
	{ UCHAR_CONSTANT("126") },
	{ UCHAR_CONSTANT("127") },
	{ UCHAR_CONSTANT("128") },
	{ UCHAR_CONSTANT("129") },
	{ UCHAR_CONSTANT("130") },
	{ UCHAR_CONSTANT("131") },
	{ UCHAR_CONSTANT("132") },
	{ UCHAR_CONSTANT("133") },
	{ UCHAR_CONSTANT("134") },
	{ UCHAR_CONSTANT("135") },
	{ UCHAR_CONSTANT("136") },
	{ UCHAR_CONSTANT("137") },
	{ UCHAR_CONSTANT("138") },
	{ UCHAR_CONSTANT("139") },
	{ UCHAR_CONSTANT("140") },
	{ UCHAR_CONSTANT("141") },
	{ UCHAR_CONSTANT("142") },
	{ UCHAR_CONSTANT("143") },
	{ UCHAR_CONSTANT("144") },
	{ UCHAR_CONSTANT("145") },
	{ UCHAR_CONSTANT("146") },
	{ UCHAR_CONSTANT("147") },
	{ UCHAR_CONSTANT("148") },
	{ UCHAR_CONSTANT("149") },
	{ UCHAR_CONSTANT("150") },
	{ UCHAR_CONSTANT("151") },
	{ UCHAR_CONSTANT("152") },
	{ UCHAR_CONSTANT("153") },
	{ UCHAR_CONSTANT("154") },
	{ UCHAR_CONSTANT("155") },
	{ UCHAR_CONSTANT("156") },
	{ UCHAR_CONSTANT("157") },
	{ UCHAR_CONSTANT("158") },
	{ UCHAR_CONSTANT("159") },
	{ UCHAR_CONSTANT("160") },
	{ UCHAR_CONSTANT("161") },
	{ UCHAR_CONSTANT("162") },
	{ UCHAR_CONSTANT("163") },
	{ UCHAR_CONSTANT("164") },
	{ UCHAR_CONSTANT("165") },
	{ UCHAR_CONSTANT("166") },
	{ UCHAR_CONSTANT("167") },
	{ UCHAR_CONSTANT("168") },
	{ UCHAR_CONSTANT("169") },
	{ UCHAR_CONSTANT("170") },
	{ UCHAR_CONSTANT("171") },
	{ UCHAR_CONSTANT("172") },
	{ UCHAR_CONSTANT("173") },
	{ UCHAR_CONSTANT("174") },
	{ UCHAR_CONSTANT("175") },
	{ UCHAR_CONSTANT("176") },
	{ UCHAR_CONSTANT("177") },
	{ UCHAR_CONSTANT("178") },
	{ UCHAR_CONSTANT("179") },
	{ UCHAR_CONSTANT("180") },
	{ UCHAR_CONSTANT("181") },
	{ UCHAR_CONSTANT("182") },
	{ UCHAR_CONSTANT("183") },
	{ UCHAR_CONSTANT("184") },
	{ UCHAR_CONSTANT("185") },
	{ UCHAR_CONSTANT("186") },
	{ UCHAR_CONSTANT("187") },
	{ UCHAR_CONSTANT("188") },
	{ UCHAR_CONSTANT("189") },
	{ UCHAR_CONSTANT("190") },
	{ UCHAR_CONSTANT("191") },
	{ UCHAR_CONSTANT("192") },
	{ UCHAR_CONSTANT("193") },
	{ UCHAR_CONSTANT("194") },
	{ UCHAR_CONSTANT("195") },
	{ UCHAR_CONSTANT("196") },
	{ UCHAR_CONSTANT("197") },
	{ UCHAR_CONSTANT("198") },
	{ UCHAR_CONSTANT("199") }
	};
static char hexdigit[16] =
	{'0', '1', '2', '3', '4', '5', '6', '7', '8',
	 '9', 'A', 'B', 'C', 'D', 'E', 'F' };
#if defined(_AIX)
static const char *syslog_fac_names[LOG_NFACILITIES] = { "kern", "user", "mail", "daemon", "auth", "syslog", "lpr",
							"news", "uucp", "cron", "authpriv", "ftp", "aso", "audit",
							"alert", "caa", "local0", "local1", "local2", "local3",
							"local4", "local5", "local6", "local7", "invld"    };
static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
							4, 4, 4, 8, 3, 3, 5,
							5, 3, 6, 6, 6, 6,
							6, 6, 6, 6, 5 };
#else
static const char *syslog_fac_names[LOG_NFACILITIES] = { "kern", "user", "mail", "daemon", "auth", "syslog", "lpr",
							"news", "uucp", "cron", "authpriv", "ftp", "ntp", "audit",
							"alert", "clock", "local0", "local1", "local2", "local3",
							"local4", "local5", "local6", "local7", "invld" };
static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
							4, 4, 4, 8, 3, 3, 5,
							5, 5, 6, 6, 6, 6,
							6, 6, 6, 6, 5 };
#endif
static const char *syslog_severity_names[8] = { "emerg", "alert", "crit", "err", "warning", "notice", "info",
	"debug" };
static short len_syslog_severity_names[8] = { 5, 5, 4, 3, 7, 6, 4, 5 };
static const char *syslog_number_names[LOG_NFACILITIES] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
	"10", "11", "12", "13", "14",
	"15", "16", "17", "18", "19", "20", "21", "22", "23", "24" };
#if defined(HAVE_MALLOC_TRIM) &amp;&amp; !defined(HAVE_ATOMIC_BUILTINS)
static pthread_mutex_t mutTrimCtr;	 #endif
static int getAPPNAMELen(smsg_t * const pM, sbool bLockMutex);
static rsRetVal jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf,
	struct json_object **parent, int bCreate);
static uchar * jsonPathGetLeaf(uchar *name, int lenName);
struct json_object *jsonDeepCopy(struct json_object *src);
static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value);
void getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen);
static inline void
MsgLock(smsg_t *pThis)
{
	#if DEV_DEBUG == 1
	dbgprintf("MsgLock(0x%lx)\n", (unsigned long) pThis);
	#endif
	pthread_mutex_lock(&amp;pThis-&gt;mut);
}
static inline void
MsgUnlock(smsg_t *pThis)
{
	#if DEV_DEBUG == 1
	dbgprintf("MsgUnlock(0x%lx)\n", (unsigned long) pThis);
	#endif
	pthread_mutex_unlock(&amp;pThis-&gt;mut);
}
static inline void
MsgSetRcvFromIPWithoutAddRef(smsg_t *pThis, prop_t *new)
{
	if(pThis-&gt;pRcvFromIP != NULL)
		prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
	pThis-&gt;pRcvFromIP = new;
}
static void MsgSetRcvFromWithoutAddRef(smsg_t *pThis, prop_t *new)
{
	assert(pThis != NULL);
	if(pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
		if(pThis-&gt;rcvFrom.pfrominet != NULL)
			free(pThis-&gt;rcvFrom.pfrominet);
		pThis-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
	} else {
		if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
			prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
	}
	pThis-&gt;rcvFrom.pRcvFrom = new;
}
static void ATTR_NONNULL()
MsgSetRulesetByName(smsg_t * const pMsg, cstr_t *const rulesetName)
{
	uchar *const rs_name = rsCStrGetSzStrNoNULL(rulesetName);
	const rsRetVal localRet =
		 rulesetGetRuleset(runConf, &amp;(pMsg-&gt;pRuleset), rs_name);
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, "msg: ruleset '%s' could not be found and could not "
			"be assigned to message object. This possibly leads to the message "
			"being processed incorrectly. We cannot do anything against this, but "
			"wanted to let you know.", rs_name);
	}
}
static rsRetVal
resolveDNS(smsg_t * const pMsg) {
	rsRetVal localRet;
	prop_t *propFromHost = NULL;
	prop_t *ip;
	prop_t *localName;
	DEFiRet;
	MsgLock(pMsg);
	CHKiRet(objUse(net, CORE_COMPONENT));
	if(pMsg-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
		if (pMsg-&gt;msgFlags &amp; PRESERVE_CASE) {
			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, NULL, &amp;localName, &amp;ip);
		} else {
			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, &amp;localName, NULL, &amp;ip);
		}
		if(localRet == RS_RET_OK) {
			MsgSetRcvFromWithoutAddRef(pMsg, localName);
			MsgSetRcvFromIPWithoutAddRef(pMsg, ip);
		}
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		MsgSetRcvFromStr(pMsg, UCHAR_CONSTANT(""), 0, &amp;propFromHost);
		prop.Destruct(&amp;propFromHost);
	}
	MsgUnlock(pMsg);
	if(propFromHost != NULL)
		prop.Destruct(&amp;propFromHost);
	RETiRet;
}
void
getInputName(const smsg_t * const pM, uchar **ppsz, int *const plen)
{
	if(pM == NULL || pM-&gt;pInputName == NULL) {
		*ppsz = UCHAR_CONSTANT("");
		*plen = 0;
	} else {
		prop.GetString(pM-&gt;pInputName, ppsz, plen);
	}
}
static uchar*
getRcvFromIP(smsg_t * const pM)
{
	uchar *psz;
	int len;
	if(pM == NULL) {
		psz = UCHAR_CONSTANT("");
	} else {
		resolveDNS(pM); 		if(pM-&gt;pRcvFromIP == NULL)
			psz = UCHAR_CONSTANT("");
		else
			prop.GetString(pM-&gt;pRcvFromIP, &amp;psz, &amp;len);
	}
	return psz;
}
rsRetVal
propNameToID(const uchar *const pName, propid_t *const pPropID)
{
	DEFiRet;
	if(!strcasecmp((char*) pName, "msg")) {
		*pPropID = PROP_MSG;
	} else if(!strcasecmp((char*) pName, "timestamp")
		  || !strcasecmp((char*) pName, "timereported")) {
		*pPropID = PROP_TIMESTAMP;
	} else if(!strcasecmp((char*) pName, "hostname") || !strcasecmp((char*) pName, "source")) {
		*pPropID = PROP_HOSTNAME;
	} else if(!strcasecmp((char*) pName, "syslogtag")) {
		*pPropID = PROP_SYSLOGTAG;
	} else if(!strcasecmp((char*) pName, "rawmsg")) {
		*pPropID = PROP_RAWMSG;
	} else if(!strcasecmp((char*) pName, "rawmsg-after-pri")) {
		*pPropID = PROP_RAWMSG_AFTER_PRI;
	} else if(!strcasecmp((char*) pName, "inputname")) {
		*pPropID = PROP_INPUTNAME;
	} else if(!strcasecmp((char*) pName, "fromhost")) {
		*pPropID = PROP_FROMHOST;
	} else if(!strcasecmp((char*) pName, "fromhost-ip")) {
		*pPropID = PROP_FROMHOST_IP;
	} else if(!strcasecmp((char*) pName, "pri")) {
		*pPropID = PROP_PRI;
	} else if(!strcasecmp((char*) pName, "pri-text")) {
		*pPropID = PROP_PRI_TEXT;
	} else if(!strcasecmp((char*) pName, "iut")) {
		*pPropID = PROP_IUT;
	} else if(!strcasecmp((char*) pName, "syslogfacility")) {
		*pPropID = PROP_SYSLOGFACILITY;
	} else if(!strcasecmp((char*) pName, "syslogfacility-text")) {
		*pPropID = PROP_SYSLOGFACILITY_TEXT;
	} else if(!strcasecmp((char*) pName, "syslogseverity") || !strcasecmp((char*) pName, "syslogpriority")) {
		*pPropID = PROP_SYSLOGSEVERITY;
	} else if(!strcasecmp((char*) pName, "syslogseverity-text") ||
	!strcasecmp((char*) pName, "syslogpriority-text")) {
		*pPropID = PROP_SYSLOGSEVERITY_TEXT;
	} else if(!strcasecmp((char*) pName, "timegenerated")) {
		*pPropID = PROP_TIMEGENERATED;
	} else if(!strcasecmp((char*) pName, "programname")) {
		*pPropID = PROP_PROGRAMNAME;
	} else if(!strcasecmp((char*) pName, "protocol-version")) {
		*pPropID = PROP_PROTOCOL_VERSION;
	} else if(!strcasecmp((char*) pName, "structured-data")) {
		*pPropID = PROP_STRUCTURED_DATA;
	} else if(!strcasecmp((char*) pName, "app-name")) {
		*pPropID = PROP_APP_NAME;
	} else if(!strcasecmp((char*) pName, "procid")) {
		*pPropID = PROP_PROCID;
	} else if(!strcasecmp((char*) pName, "msgid")) {
		*pPropID = PROP_MSGID;
	} else if(!strcasecmp((char*) pName, "jsonmesg")) {
		*pPropID = PROP_JSONMESG;
	} else if(!strcasecmp((char*) pName, "parsesuccess")) {
		*pPropID = PROP_PARSESUCCESS;
#ifdef USE_LIBUUID
	} else if(!strcasecmp((char*) pName, "uuid")) {
		*pPropID = PROP_UUID;
#endif
	} else if(!strcasecmp((char*) pName, "$NOW")) {
		*pPropID = PROP_SYS_NOW;
	} else if(!strcasecmp((char*) pName, "$YEAR")) {
		*pPropID = PROP_SYS_YEAR;
	} else if(!strcasecmp((char*) pName, "$MONTH")) {
		*pPropID = PROP_SYS_MONTH;
	} else if(!strcasecmp((char*) pName, "$DAY")) {
		*pPropID = PROP_SYS_DAY;
	} else if(!strcasecmp((char*) pName, "$HOUR")) {
		*pPropID = PROP_SYS_HOUR;
	} else if(!strcasecmp((char*) pName, "$HHOUR")) {
		*pPropID = PROP_SYS_HHOUR;
	} else if(!strcasecmp((char*) pName, "$QHOUR")) {
		*pPropID = PROP_SYS_QHOUR;
	} else if(!strcasecmp((char*) pName, "$MINUTE")) {
		*pPropID = PROP_SYS_MINUTE;
	} else if(!strcasecmp((char*) pName, "$WDAY")) {
		*pPropID = PROP_SYS_WDAY;
	} else if(!strcasecmp((char*) pName, "$now-utc")) {
		*pPropID = PROP_SYS_NOW_UTC;
	} else if(!strcasecmp((char*) pName, "$year-utc")) {
		*pPropID = PROP_SYS_YEAR_UTC;
	} else if(!strcasecmp((char*) pName, "$month-utc")) {
		*pPropID = PROP_SYS_MONTH_UTC;
	} else if(!strcasecmp((char*) pName, "$day-utc")) {
		*pPropID = PROP_SYS_DAY_UTC;
	} else if(!strcasecmp((char*) pName, "$hour-utc")) {
		*pPropID = PROP_SYS_HOUR_UTC;
	} else if(!strcasecmp((char*) pName, "$hhour-utc")) {
		*pPropID = PROP_SYS_HHOUR_UTC;
	} else if(!strcasecmp((char*) pName, "$qhour-utc")) {
		*pPropID = PROP_SYS_QHOUR_UTC;
	} else if(!strcasecmp((char*) pName, "$minute-utc")) {
		*pPropID = PROP_SYS_MINUTE_UTC;
	} else if(!strcasecmp((char*) pName, "$wday-utc")) {
		*pPropID = PROP_SYS_WDAY_UTC;
	} else if(!strcasecmp((char*) pName, "$now-unixtimestamp")) {
		*pPropID = PROP_SYS_NOW_UXTIMESTAMP;
	} else if(!strcasecmp((char*) pName, "$MYHOSTNAME")) {
		*pPropID = PROP_SYS_MYHOSTNAME;
	} else if(!strcasecmp((char*) pName, "$!all-json")) {
		*pPropID = PROP_CEE_ALL_JSON;
	} else if(!strcasecmp((char*) pName, "$!all-json-plain")) {
		*pPropID = PROP_CEE_ALL_JSON_PLAIN;
	} else if(!strcasecmp((char*) pName, "$BOM")) {
		*pPropID = PROP_SYS_BOM;
	} else if(!strcasecmp((char*) pName, "$UPTIME")) {
		*pPropID = PROP_SYS_UPTIME;
	} else if(!strncmp((char*) pName, "$!", 2) || pName[0] == '!') {
		*pPropID = PROP_CEE;
	} else if(!strncmp((char*) pName, "$.", 2) || pName[0] == '.') {
		*pPropID = PROP_LOCAL_VAR;
	} else if(!strncmp((char*) pName, "$/", 2) || pName[0] == '/') {
		*pPropID = PROP_GLOBAL_VAR;
	} else {
		DBGPRINTF("PROP_INVALID for name '%s'\n", pName);
		*pPropID = PROP_INVALID;
		iRet = RS_RET_VAR_NOT_FOUND;
	}
	RETiRet;
}
<a name="0"></a>
uchar *propIDToName(propid_t propID)
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
	switch(propID) {
		case PROP_MSG:
			return UCHAR_CONSTANT("msg");
		case PROP_TIMESTAMP:
			return UCHAR_CONSTANT("timestamp");
		case PROP_HOSTNAME:
			return UCHAR_CONSTANT("hostname");
		case PROP_SYSLOGTAG:
			return UCHAR_CONSTANT("syslogtag");
		case PROP_RAWMSG:
			return UCHAR_CONSTANT("rawmsg");</b></font>
		case PROP_RAWMSG_AFTER_PRI:
			return UCHAR_CONSTANT("rawmsg-after-pri");
		case PROP_INPUTNAME:
			return UCHAR_CONSTANT("inputname");
		case PROP_FROMHOST:
			return UCHAR_CONSTANT("fromhost");
		case PROP_FROMHOST_IP:
			return UCHAR_CONSTANT("fromhost-ip");
		case PROP_PRI:
			return UCHAR_CONSTANT("pri");
		case PROP_PRI_TEXT:
			return UCHAR_CONSTANT("pri-text");
		case PROP_IUT:
			return UCHAR_CONSTANT("iut");
		case PROP_SYSLOGFACILITY:
			return UCHAR_CONSTANT("syslogfacility");
		case PROP_SYSLOGFACILITY_TEXT:
			return UCHAR_CONSTANT("syslogfacility-text");
		case PROP_SYSLOGSEVERITY:
			return UCHAR_CONSTANT("syslogseverity");
		case PROP_SYSLOGSEVERITY_TEXT:
			return UCHAR_CONSTANT("syslogseverity-text");
		case PROP_TIMEGENERATED:
			return UCHAR_CONSTANT("timegenerated");
		case PROP_PROGRAMNAME:
			return UCHAR_CONSTANT("programname");
		case PROP_PROTOCOL_VERSION:
			return UCHAR_CONSTANT("protocol-version");
		case PROP_STRUCTURED_DATA:
			return UCHAR_CONSTANT("structured-data");
		case PROP_APP_NAME:
			return UCHAR_CONSTANT("app-name");
		case PROP_PROCID:
			return UCHAR_CONSTANT("procid");
		case PROP_MSGID:
			return UCHAR_CONSTANT("msgid");
		case PROP_JSONMESG:
			return UCHAR_CONSTANT("jsonmesg");
		case PROP_PARSESUCCESS:
			return UCHAR_CONSTANT("parsesuccess");
#ifdef USE_LIBUUID
		case PROP_UUID:
			return UCHAR_CONSTANT("uuid");
#endif
		case PROP_SYS_NOW:
			return UCHAR_CONSTANT("$NOW");
		case PROP_SYS_YEAR:
			return UCHAR_CONSTANT("$YEAR");
		case PROP_SYS_MONTH:
			return UCHAR_CONSTANT("$MONTH");
		case PROP_SYS_DAY:
			return UCHAR_CONSTANT("$DAY");
		case PROP_SYS_HOUR:
			return UCHAR_CONSTANT("$HOUR");
		case PROP_SYS_HHOUR:
			return UCHAR_CONSTANT("$HHOUR");
		case PROP_SYS_QHOUR:
			return UCHAR_CONSTANT("$QHOUR");
		case PROP_SYS_MINUTE:
			return UCHAR_CONSTANT("$MINUTE");
		case PROP_SYS_NOW_UTC:
			return UCHAR_CONSTANT("$NOW-UTC");
		case PROP_SYS_YEAR_UTC:
			return UCHAR_CONSTANT("$YEAR-UTC");
		case PROP_SYS_MONTH_UTC:
			return UCHAR_CONSTANT("$MONTH-UTC");
		case PROP_SYS_DAY_UTC:
			return UCHAR_CONSTANT("$DAY-UTC");
		case PROP_SYS_HOUR_UTC:
			return UCHAR_CONSTANT("$HOUR-UTC");
		case PROP_SYS_HHOUR_UTC:
			return UCHAR_CONSTANT("$HHOUR-UTC");
		case PROP_SYS_QHOUR_UTC:
			return UCHAR_CONSTANT("$QHOUR-UTC");
		case PROP_SYS_MINUTE_UTC:
			return UCHAR_CONSTANT("$MINUTE-UTC");
		case PROP_SYS_WDAY:
			return UCHAR_CONSTANT("$WDAY");
		case PROP_SYS_WDAY_UTC:
			return UCHAR_CONSTANT("$WDAY-UTC");
		case PROP_SYS_NOW_UXTIMESTAMP:
			return UCHAR_CONSTANT("$NOW-UNIXTIMESTAMP");
		case PROP_SYS_MYHOSTNAME:
			return UCHAR_CONSTANT("$MYHOSTNAME");
		case PROP_CEE_ALL_JSON:
			return UCHAR_CONSTANT("$!all-json");
		case PROP_CEE_ALL_JSON_PLAIN:
			return UCHAR_CONSTANT("$!all-json-plain");
		case PROP_SYS_BOM:
			return UCHAR_CONSTANT("$BOM");
		case PROP_SYS_UPTIME:
			return UCHAR_CONSTANT("$UPTIME");
		case PROP_CEE:
			return UCHAR_CONSTANT("*CEE-based property*");
		case PROP_LOCAL_VAR:
			return UCHAR_CONSTANT("*LOCAL_VARIABLE*");
		case PROP_GLOBAL_VAR:
			return UCHAR_CONSTANT("*GLOBAL_VARIABLE*");
		default:
			return UCHAR_CONSTANT("*invalid property id*");
	}
}
static rsRetVal
msgBaseConstruct(smsg_t **ppThis)
{
	DEFiRet;
	smsg_t *pM;
	assert(ppThis != NULL);
	CHKmalloc(pM = malloc(sizeof(smsg_t)));
	objConstructSetObjInfo(pM); 
	pM-&gt;flowCtlType = 0;
	pM-&gt;bParseSuccess = 0;
	pM-&gt;iRefCount = 1;
	pM-&gt;iSeverity = LOG_DEBUG;
	pM-&gt;iFacility = LOG_INVLD;
	pM-&gt;iLenPROGNAME = -1;
	pM-&gt;offAfterPRI = 0;
	pM-&gt;offMSG = -1;
	pM-&gt;iProtocolVersion = 0;
	pM-&gt;msgFlags = 0;
	pM-&gt;iLenRawMsg = 0;
	pM-&gt;iLenMSG = 0;
	pM-&gt;iLenTAG = 0;
	pM-&gt;iLenHOSTNAME = 0;
	pM-&gt;pszRawMsg = NULL;
	pM-&gt;pszHOSTNAME = NULL;
	pM-&gt;pszRcvdAt3164 = NULL;
	pM-&gt;pszRcvdAt3339 = NULL;
	pM-&gt;pszRcvdAt_MySQL = NULL;
	pM-&gt;pszRcvdAt_PgSQL = NULL;
	pM-&gt;pszTIMESTAMP3164 = NULL;
	pM-&gt;pszTIMESTAMP3339 = NULL;
	pM-&gt;pszTIMESTAMP_MySQL = NULL;
	pM-&gt;pszTIMESTAMP_PgSQL = NULL;
	pM-&gt;pszStrucData = NULL;
	pM-&gt;lenStrucData = 0;
	pM-&gt;pCSAPPNAME = NULL;
	pM-&gt;pCSPROCID = NULL;
	pM-&gt;pCSMSGID = NULL;
	pM-&gt;pInputName = NULL;
	pM-&gt;pRcvFromIP = NULL;
	pM-&gt;rcvFrom.pRcvFrom = NULL;
	pM-&gt;pRuleset = NULL;
	pM-&gt;json = NULL;
	pM-&gt;localvars = NULL;
	pM-&gt;dfltTZ[0] = '\0';
	memset(&amp;pM-&gt;tRcvdAt, 0, sizeof(pM-&gt;tRcvdAt));
	memset(&amp;pM-&gt;tTIMESTAMP, 0, sizeof(pM-&gt;tTIMESTAMP));
	pM-&gt;TAG.pszTAG = NULL;
	pM-&gt;pszTimestamp3164[0] = '\0';
	pM-&gt;pszTimestamp3339[0] = '\0';
	pM-&gt;pszTIMESTAMP_SecFrac[0] = '\0';
	pM-&gt;pszRcvdAt_SecFrac[0] = '\0';
	pM-&gt;pszTIMESTAMP_Unix[0] = '\0';
	pM-&gt;pszRcvdAt_Unix[0] = '\0';
	pM-&gt;pszUUID = NULL;
	pthread_mutex_init(&amp;pM-&gt;mut, NULL);
	#if DEV_DEBUG == 1
	dbgprintf("msgConstruct\t0x%x, ref 1\n", (int)pM);
	#endif
	*ppThis = pM;
finalize_it:
	RETiRet;
}
rsRetVal msgConstructWithTime(smsg_t **ppThis, const struct syslogTime *stTime, const time_t ttGenTime)
{
	DEFiRet;
	CHKiRet(msgBaseConstruct(ppThis));
	(*ppThis)-&gt;ttGenTime = ttGenTime;
	memcpy(&amp;(*ppThis)-&gt;tRcvdAt, stTime, sizeof(struct syslogTime));
	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, stTime, sizeof(struct syslogTime));
finalize_it:
	RETiRet;
}
rsRetVal msgConstruct(smsg_t **ppThis)
{
	DEFiRet;
	CHKiRet(msgBaseConstruct(ppThis));
	datetime.getCurrTime(&amp;((*ppThis)-&gt;tRcvdAt), &amp;((*ppThis)-&gt;ttGenTime), TIME_IN_LOCALTIME);
	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, &amp;(*ppThis)-&gt;tRcvdAt, sizeof(struct syslogTime));
finalize_it:
	RETiRet;
}
rsRetVal
msgConstructForDeserializer(smsg_t **ppThis)
{
	return msgBaseConstruct(ppThis);
}
static inline void freeTAG(smsg_t *pThis)
{
	if(pThis-&gt;iLenTAG &gt;= CONF_TAG_BUFSIZE)
		free(pThis-&gt;TAG.pszTAG);
}
static inline void freeHOSTNAME(smsg_t *pThis)
{
	if(pThis-&gt;iLenHOSTNAME &gt;= CONF_HOSTNAME_BUFSIZE)
		free(pThis-&gt;pszHOSTNAME);
}
rsRetVal msgDestruct(smsg_t **ppThis)
{
	DEFiRet;
	smsg_t *pThis;
	int currRefCount;
#	ifdef HAVE_MALLOC_TRIM
	int currCnt;
#	endif
CODESTARTobjDestruct(msg)
	#if DEV_DEBUG == 1
	dbgprintf("msgDestruct\t0x%lx, "
		"Ref now: %d\n", (unsigned long)pThis, pThis-&gt;iRefCount - 1);
	#endif
#	ifdef HAVE_ATOMIC_BUILTINS
		currRefCount = ATOMIC_DEC_AND_FETCH(&amp;pThis-&gt;iRefCount, NULL);
#	else
		MsgLock(pThis);
		currRefCount = --pThis-&gt;iRefCount;
# 	endif
	if(currRefCount == 0)
	{
		#if DEV_DEBUG == 1
		dbgprintf("msgDestruct\t0x%lx, RefCount now 0, doing DESTROY\n",
			(unsigned long)pThis);
		#endif
		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
			free(pThis-&gt;pszRawMsg);
		freeTAG(pThis);
		freeHOSTNAME(pThis);
		if(pThis-&gt;pInputName != NULL)
			prop.Destruct(&amp;pThis-&gt;pInputName);
		if((pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) == 0) {
			if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
				prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
		} else {
			free(pThis-&gt;rcvFrom.pfrominet);
		}
		if(pThis-&gt;pRcvFromIP != NULL)
			prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
		free(pThis-&gt;pszRcvdAt3164);
		free(pThis-&gt;pszRcvdAt3339);
		free(pThis-&gt;pszRcvdAt_MySQL);
		free(pThis-&gt;pszRcvdAt_PgSQL);
		free(pThis-&gt;pszTIMESTAMP_MySQL);
		free(pThis-&gt;pszTIMESTAMP_PgSQL);
		free(pThis-&gt;pszStrucData);
		if(pThis-&gt;iLenPROGNAME &gt;= CONF_PROGNAME_BUFSIZE)
			free(pThis-&gt;PROGNAME.ptr);
		if(pThis-&gt;pCSAPPNAME != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSAPPNAME);
		if(pThis-&gt;pCSPROCID != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSPROCID);
		if(pThis-&gt;pCSMSGID != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSMSGID);
		if(pThis-&gt;json != NULL)
			json_object_put(pThis-&gt;json);
		if(pThis-&gt;localvars != NULL)
			json_object_put(pThis-&gt;localvars);
		if(pThis-&gt;pszUUID != NULL)
			free(pThis-&gt;pszUUID);
#	ifndef HAVE_ATOMIC_BUILTINS
		MsgUnlock(pThis);
# 	endif
		pthread_mutex_destroy(&amp;pThis-&gt;mut);
#		ifdef HAVE_MALLOC_TRIM
			static unsigned iTrimCtr = 1;
			currCnt = ATOMIC_INC_AND_FETCH_unsigned(&amp;iTrimCtr, &amp;mutTrimCtr);
			if(currCnt % 100000 == 0) {
				malloc_trim(128*1024);
			}
		}
#		endif
	} else {
#	ifndef HAVE_ATOMIC_BUILTINS
		MsgUnlock(pThis);
# 	endif
		pThis = NULL; 	}
ENDobjDestruct(msg)
#define tmpCOPYSZ(name) \
	if(pOld-&gt;psz##name != NULL) { \
		if((pNew-&gt;psz##name = srUtilStrDup(pOld-&gt;psz##name, pOld-&gt;iLen##name)) == NULL) {\
			msgDestruct(&amp;pNew);\
			return NULL;\
		}\
		pNew-&gt;iLen##name = pOld-&gt;iLen##name;\
	}
#define tmpCOPYCSTR(name) \
	if(pOld-&gt;pCS##name != NULL) {\
		if(rsCStrConstructFromCStr(&amp;(pNew-&gt;pCS##name), pOld-&gt;pCS##name) != RS_RET_OK) {\
			msgDestruct(&amp;pNew);\
			return NULL;\
		}\
		cstrFinalize(pNew-&gt;pCS##name); \
	}
smsg_t* MsgDup(smsg_t* pOld)
{
	smsg_t* pNew;
	rsRetVal localRet;
	assert(pOld != NULL);
	if(msgConstructWithTime(&amp;pNew, &amp;pOld-&gt;tTIMESTAMP, pOld-&gt;ttGenTime) != RS_RET_OK) {
		return NULL;
	}
	pNew-&gt;iRefCount = 1;
	pNew-&gt;iSeverity = pOld-&gt;iSeverity;
	pNew-&gt;iFacility = pOld-&gt;iFacility;
	pNew-&gt;msgFlags = pOld-&gt;msgFlags;
	pNew-&gt;iProtocolVersion = pOld-&gt;iProtocolVersion;
	pNew-&gt;tRcvdAt = pOld-&gt;tRcvdAt;
	pNew-&gt;offMSG = pOld-&gt;offMSG;
	pNew-&gt;iLenRawMsg = pOld-&gt;iLenRawMsg;
	pNew-&gt;iLenMSG = pOld-&gt;iLenMSG;
	pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
	pNew-&gt;iLenHOSTNAME = pOld-&gt;iLenHOSTNAME;
	if((pOld-&gt;msgFlags &amp; NEEDS_DNSRESOL)) {
			localRet = msgSetFromSockinfo(pNew, pOld-&gt;rcvFrom.pfrominet);
			if(localRet != RS_RET_OK) {
				pNew-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
				pNew-&gt;rcvFrom.pRcvFrom = NULL; 			}
	} else {
		if(pOld-&gt;rcvFrom.pRcvFrom != NULL) {
			pNew-&gt;rcvFrom.pRcvFrom = pOld-&gt;rcvFrom.pRcvFrom;
			prop.AddRef(pNew-&gt;rcvFrom.pRcvFrom);
		}
	}
	if(pOld-&gt;pRcvFromIP != NULL) {
		pNew-&gt;pRcvFromIP = pOld-&gt;pRcvFromIP;
		prop.AddRef(pNew-&gt;pRcvFromIP);
	}
	if(pOld-&gt;pInputName != NULL) {
		pNew-&gt;pInputName = pOld-&gt;pInputName;
		prop.AddRef(pNew-&gt;pInputName);
	}
	if(pOld-&gt;iLenTAG &gt; 0) {
		if(pOld-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
			memcpy(pNew-&gt;TAG.szBuf, pOld-&gt;TAG.szBuf, pOld-&gt;iLenTAG + 1);
		} else {
			if((pNew-&gt;TAG.pszTAG = srUtilStrDup(pOld-&gt;TAG.pszTAG, pOld-&gt;iLenTAG)) == NULL) {
				msgDestruct(&amp;pNew);
				return NULL;
			}
			pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
		}
	}
	if(pOld-&gt;pszRawMsg == pOld-&gt;szRawMsg) {
		memcpy(pNew-&gt;szRawMsg, pOld-&gt;szRawMsg, pOld-&gt;iLenRawMsg + 1);
		pNew-&gt;pszRawMsg = pNew-&gt;szRawMsg;
	} else {
		tmpCOPYSZ(RawMsg);
	}
	if(pOld-&gt;pszHOSTNAME == NULL) {
		pNew-&gt;pszHOSTNAME = NULL;
	} else {
		if(pOld-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
			memcpy(pNew-&gt;szHOSTNAME, pOld-&gt;szHOSTNAME, pOld-&gt;iLenHOSTNAME + 1);
			pNew-&gt;pszHOSTNAME = pNew-&gt;szHOSTNAME;
		} else {
			tmpCOPYSZ(HOSTNAME);
		}
	}
	if(pOld-&gt;pszStrucData == NULL) {
		pNew-&gt;pszStrucData = NULL;
	} else {
		pNew-&gt;pszStrucData = (uchar*)strdup((char*)pOld-&gt;pszStrucData);
		pNew-&gt;lenStrucData = pOld-&gt;lenStrucData;
	}
	tmpCOPYCSTR(APPNAME);
	tmpCOPYCSTR(PROCID);
	tmpCOPYCSTR(MSGID);
	if(pOld-&gt;json != NULL)
		pNew-&gt;json = jsonDeepCopy(pOld-&gt;json);
	if(pOld-&gt;localvars != NULL)
		pNew-&gt;localvars = jsonDeepCopy(pOld-&gt;localvars);
	return pNew;
}
#undef tmpCOPYSZ
#undef tmpCOPYCSTR
static rsRetVal MsgSerialize(smsg_t *pThis, strm_t *pStrm)
{
	uchar *psz;
	int len;
	DEFiRet;
	assert(pThis != NULL);
	assert(pStrm != NULL);
	CHKiRet(obj.BeginSerialize(pStrm, (obj_t*) pThis));
	objSerializeSCALAR(pStrm, iProtocolVersion, SHORT);
	objSerializeSCALAR(pStrm, iSeverity, SHORT);
	objSerializeSCALAR(pStrm, iFacility, SHORT);
	objSerializeSCALAR(pStrm, msgFlags, INT);
	objSerializeSCALAR(pStrm, ttGenTime, INT);
	objSerializeSCALAR(pStrm, tRcvdAt, SYSLOGTIME);
	objSerializeSCALAR(pStrm, tTIMESTAMP, SYSLOGTIME);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszTAG"), PROPTYPE_PSZ, (void*)
		((pThis-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pThis-&gt;TAG.szBuf : pThis-&gt;TAG.pszTAG)));
	objSerializePTR(pStrm, pszRawMsg, PSZ);
	objSerializePTR(pStrm, pszHOSTNAME, PSZ);
	getInputName(pThis, &amp;psz, &amp;len);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszInputName"), PROPTYPE_PSZ, (void*) psz));
	psz = getRcvFrom(pThis);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRcvFrom"), PROPTYPE_PSZ, (void*) psz));
	psz = getRcvFromIP(pThis);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRcvFromIP"), PROPTYPE_PSZ, (void*) psz));
	psz = pThis-&gt;pszStrucData;
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszStrucData"), PROPTYPE_PSZ, (void*) psz));
	if(pThis-&gt;json != NULL) {
		MsgLock(pThis);
		psz = (uchar*) json_object_get_string(pThis-&gt;json);
		MsgUnlock(pThis);
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("json"), PROPTYPE_PSZ, (void*) psz));
	}
	if(pThis-&gt;localvars != NULL) {
		MsgLock(pThis);
		psz = (uchar*) json_object_get_string(pThis-&gt;localvars);
		MsgUnlock(pThis);
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("localvars"), PROPTYPE_PSZ, (void*) psz));
	}
	objSerializePTR(pStrm, pCSAPPNAME, CSTR);
	objSerializePTR(pStrm, pCSPROCID, CSTR);
	objSerializePTR(pStrm, pCSMSGID, CSTR);
	objSerializePTR(pStrm, pszUUID, PSZ);
	if(pThis-&gt;pRuleset != NULL) {
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRuleset"), PROPTYPE_PSZ,
			rulesetGetName(pThis-&gt;pRuleset)));
	}
	objSerializeSCALAR(pStrm, offMSG, INT);
	CHKiRet(obj.EndSerialize(pStrm));
finalize_it:
	RETiRet;
}
static void
reinitVar(var_t *pVar)
{
	rsCStrDestruct(&amp;pVar-&gt;pcsName); 	if(pVar-&gt;varType == VARTYPE_STR) {
		if(pVar-&gt;val.pStr != NULL)
			rsCStrDestruct(&amp;pVar-&gt;val.pStr);
	}
}
#define isProp(name) !rsCStrSzStrCmp(pVar-&gt;pcsName, (uchar*) name, sizeof(name) - 1)
rsRetVal
MsgDeserialize(smsg_t * const pMsg, strm_t *pStrm)
{
	prop_t *myProp;
	prop_t *propRcvFrom = NULL;
	prop_t *propRcvFromIP = NULL;
	struct json_tokener *tokener;
	var_t *pVar = NULL;
	DEFiRet;
	ISOBJ_TYPE_assert(pStrm, strm);
	CHKiRet(var.Construct(&amp;pVar));
	CHKiRet(var.ConstructFinalize(pVar));
	CHKiRet(objDeserializeProperty(pVar, pStrm));
	if(isProp("iProtocolVersion")) {
		setProtocolVersion(pMsg, pVar-&gt;val.num);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("iSeverity")) {
		pMsg-&gt;iSeverity = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("iFacility")) {
		pMsg-&gt;iFacility = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("msgFlags")) {
		pMsg-&gt;msgFlags = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("ttGenTime")) {
		pMsg-&gt;ttGenTime = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("tRcvdAt")) {
		memcpy(&amp;pMsg-&gt;tRcvdAt, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("tTIMESTAMP")) {
		memcpy(&amp;pMsg-&gt;tTIMESTAMP, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszTAG")) {
		MsgSetTAG(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszRawMsg")) {
		MsgSetRawMsg(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszHOSTNAME")) {
		MsgSetHOSTNAME(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszInputName")) {
		CHKiRet(prop.Construct(&amp;myProp));
		CHKiRet(prop.SetString(myProp, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr)));
		CHKiRet(prop.ConstructFinalize(myProp));
		MsgSetInputName(pMsg, myProp);
		prop.Destruct(&amp;myProp);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszRcvFrom")) {
		MsgSetRcvFromStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr), &amp;propRcvFrom);
		prop.Destruct(&amp;propRcvFrom);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszRcvFromIP")) {
		MsgSetRcvFromIPStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr),
			&amp;propRcvFromIP);
		prop.Destruct(&amp;propRcvFromIP);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszStrucData")) {
		MsgSetStructuredData(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("json")) {
		tokener = json_tokener_new();
		pMsg-&gt;json = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
					     cstrLen(pVar-&gt;val.pStr));
		json_tokener_free(tokener);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("localvars")) {
		tokener = json_tokener_new();
		pMsg-&gt;localvars = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
						        cstrLen(pVar-&gt;val.pStr));
		json_tokener_free(tokener);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pCSAPPNAME")) {
		MsgSetAPPNAME(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pCSPROCID")) {
		MsgSetPROCID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pCSMSGID")) {
		MsgSetMSGID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszUUID")) {
		pMsg-&gt;pszUUID = ustrdup(rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp("pszRuleset")) {
		MsgSetRulesetByName(pMsg, pVar-&gt;val.pStr);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(!isProp("offMSG")) {
		DBGPRINTF("error property: %s\n", rsCStrGetSzStrNoNULL(pVar-&gt;pcsName));
		ABORT_FINALIZE(RS_RET_DS_PROP_SEQ_ERR);
	}
	MsgSetMSGoffs(pMsg, pVar-&gt;val.num);
finalize_it:
	if(pVar != NULL)
		var.Destruct(&amp;pVar);
	if(Debug &amp;&amp; iRet != RS_RET_OK) {
		dbgprintf("MsgDeserialize error %d\n", iRet);
	}
	RETiRet;
}
#undef isProp
smsg_t *MsgAddRef(smsg_t * const pM)
{
	assert(pM != NULL);
#	ifdef HAVE_ATOMIC_BUILTINS
		ATOMIC_INC(&amp;pM-&gt;iRefCount, NULL);
#	else
		MsgLock(pM);
		pM-&gt;iRefCount++;
		MsgUnlock(pM);
#	endif
	#if DEV_DEBUG == 1
	dbgprintf("MsgAddRef\t0x%x done, Ref now: %d\n", (int)pM, pM-&gt;iRefCount);
	#endif
	return(pM);
}
static rsRetVal acquirePROCIDFromTAG(smsg_t * const pM)
{
	register int i;
	uchar *pszTag;
	DEFiRet;
	assert(pM != NULL);
	if(pM-&gt;pCSPROCID != NULL)
		return RS_RET_OK; 
	if(msgGetProtocolVersion(pM) != 0)
		return RS_RET_OK; 
	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);
	i = 0;
	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != '['))
		++i;
	if(!(i &lt; pM-&gt;iLenTAG))
		return RS_RET_OK;	
	++i; 
	CHKiRet(cstrConstruct(&amp;pM-&gt;pCSPROCID));
	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != ']')) {
		CHKiRet(cstrAppendChar(pM-&gt;pCSPROCID, pszTag[i]));
		++i;
	}
	if(!(i &lt; pM-&gt;iLenTAG)) {
		cstrDestruct(&amp;pM-&gt;pCSPROCID);
		FINALIZE;
	}
	cstrFinalize(pM-&gt;pCSPROCID);
finalize_it:
	RETiRet;
}
static rsRetVal
acquireProgramName(smsg_t * const pM)
{
	int i;
	uchar *pszTag, *pszProgName;
	DEFiRet;
	assert(pM != NULL);
	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);
	for(  i = 0
	    ; (i &lt; pM-&gt;iLenTAG) &amp;&amp; isprint((int) pszTag[i])
	      &amp;&amp; (pszTag[i] != '\0') &amp;&amp; (pszTag[i] != ':')
	      &amp;&amp; (pszTag[i] != '[')
	      &amp;&amp; (runConf-&gt;globals.parser.bPermitSlashInProgramname || (pszTag[i] != '/'))
	    ; ++i)
		; 	if(i &lt; CONF_PROGNAME_BUFSIZE) {
		pszProgName = pM-&gt;PROGNAME.szBuf;
	} else {
		CHKmalloc(pM-&gt;PROGNAME.ptr = malloc(i+1));
		pszProgName = pM-&gt;PROGNAME.ptr;
	}
	memcpy((char*)pszProgName, (char*)pszTag, i);
	pszProgName[i] = '\0';
	pM-&gt;iLenPROGNAME = i;
finalize_it:
	RETiRet;
}
void setProtocolVersion(smsg_t * const pM, int iNewVersion)
{
	assert(pM != NULL);
	if(iNewVersion != 0 &amp;&amp; iNewVersion != 1) {
		dbgprintf("Tried to set unsupported protocol version %d - changed to 0.\n", iNewVersion);
		iNewVersion = 0;
	}
	pM-&gt;iProtocolVersion = iNewVersion;
}
static const char *getProtocolVersionString(smsg_t * const pM)
{
	assert(pM != NULL);
	return(pM-&gt;iProtocolVersion ? "1" : "0");
}
void
msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri)
{
	if(pri &gt; LOG_MAXPRI)
		pri = LOG_PRI_INVLD;
	pMsg-&gt;iFacility = pri2fac(pri),
	pMsg-&gt;iSeverity = pri2sev(pri);
}
#ifdef USE_LIBUUID
static void msgSetUUID(smsg_t * const pM)
{
	size_t lenRes = sizeof(uuid_t) * 2 + 1;
	char hex_char [] = "0123456789ABCDEF";
	unsigned int byte_nbr;
	uuid_t uuid;
	static pthread_mutex_t mutUUID = PTHREAD_MUTEX_INITIALIZER;
	dbgprintf("[MsgSetUUID] START, lenRes %llu\n", (long long unsigned) lenRes);
	assert(pM != NULL);
	if((pM-&gt;pszUUID = (uchar*) malloc(lenRes)) == NULL) {
		pM-&gt;pszUUID = (uchar *)"";
	} else {
		pthread_mutex_lock(&amp;mutUUID);
		uuid_generate(uuid);
		pthread_mutex_unlock(&amp;mutUUID);
		for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
			pM-&gt;pszUUID[byte_nbr * 2 + 0] = hex_char[uuid [byte_nbr] &gt;&gt; 4];
			pM-&gt;pszUUID[byte_nbr * 2 + 1] = hex_char[uuid [byte_nbr] &amp; 15];
		}
		pM-&gt;pszUUID[lenRes-1] = '\0';
		dbgprintf("[MsgSetUUID] UUID : %s LEN: %d \n", pM-&gt;pszUUID, (int)lenRes);
	}
	dbgprintf("[MsgSetUUID] END\n");
}
static void getUUID(smsg_t * const pM, uchar **pBuf, int *piLen)
{
	dbgprintf("[getUUID] START\n");
	if(pM == NULL) {
		dbgprintf("[getUUID] pM is NULL\n");
		*pBuf=	UCHAR_CONSTANT("");
		*piLen = 0;
	} else {
		if(pM-&gt;pszUUID == NULL) {
			dbgprintf("[getUUID] pM-&gt;pszUUID is NULL\n");
			MsgLock(pM);
			if(pM-&gt;pszUUID == NULL)
				msgSetUUID(pM);
			MsgUnlock(pM);
		} else { 			dbgprintf("[getUUID] pM-&gt;pszUUID already exists\n");
		}
		*pBuf = pM-&gt;pszUUID;
		*piLen = sizeof(uuid_t) * 2;
	}
	dbgprintf("[getUUID] END\n");
}
#endif
int ATTR_NONNULL()
getRawMsgLen(const smsg_t *const pMsg)
{
	return (pMsg-&gt;pszRawMsg == NULL) ?  0 : pMsg-&gt;iLenRawMsg;
}
void
getRawMsg(const smsg_t * const pM, uchar **pBuf, int *piLen)
{
	if(pM == NULL) {
		*pBuf=  UCHAR_CONSTANT("");
		*piLen = 0;
	} else {
		if(pM-&gt;pszRawMsg == NULL) {
			*pBuf=  UCHAR_CONSTANT("");
			*piLen = 0;
		} else {
			*pBuf = pM-&gt;pszRawMsg;
			*piLen = pM-&gt;iLenRawMsg;
		}
	}
}
void
getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen)
{
	if(pM == NULL) {
		*pBuf=  UCHAR_CONSTANT("");
		*piLen = 0;
	} else {
		if(pM-&gt;pszRawMsg == NULL) {
			*pBuf=  UCHAR_CONSTANT("");
			*piLen = 0;
		} else {
			size_t offAfterPRI = 0;
			if(pM-&gt;pszRawMsg[0] == '&lt;') { 				if(pM-&gt;pszRawMsg[2] == '&gt;')
					offAfterPRI = 3;
				else if(pM-&gt;pszRawMsg[3] == '&gt;')
					offAfterPRI = 4;
				else if(pM-&gt;pszRawMsg[4] == '&gt;')
					offAfterPRI = 5;
			}
			*pBuf = pM-&gt;pszRawMsg + offAfterPRI;
			*piLen = pM-&gt;iLenRawMsg - offAfterPRI;
		}
	}
}
void setMSGLen(smsg_t * const pM, int lenMsg)
{
	pM-&gt;iLenMSG = lenMsg;
}
int getMSGLen(smsg_t * const pM)
{
	return((pM == NULL) ? 0 : pM-&gt;iLenMSG);
}
uchar *getMSG(smsg_t * const pM)
{
	uchar *ret;
	if(pM == NULL)
		ret = UCHAR_CONSTANT("");
	else {
		if(pM-&gt;iLenMSG == 0)
			ret = UCHAR_CONSTANT("");
		else
			ret = pM-&gt;pszRawMsg + pM-&gt;offMSG;
	}
	return ret;
}
int
getPRIi(const smsg_t * const pM)
{
	syslog_pri_t pri = (pM-&gt;iFacility &lt;&lt; 3) + (pM-&gt;iSeverity);
	if(pri &gt; 191)
		pri = LOG_PRI_INVLD;
	return pri;
}
const char *
getPRI(smsg_t * const pM)
{
	int iPRI;
	if(pM == NULL)
		return "";
	iPRI = getPRIi(pM);
	return (iPRI &gt; 191) ? "invld" : (char*)syslog_pri_names[iPRI].pszName;
}
static const char *
formatISOWeekOrYear(enum tplFormatTypes eFmt, struct syslogTime *pTm)
{
	if(pTm-&gt;year &gt;= 1970 &amp;&amp; pTm-&gt;year &lt;= 2099) {
		int isoWeekYear;
		int isoWeek;
		isoWeek = getISOWeek(pTm, &amp;isoWeekYear);
		if (eFmt == tplFmtISOWeek) {
			return two_digits[isoWeek];
		} else {
			return years[isoWeekYear - 1967];
		}
	} else {
		return "YEAR OUT OF RANGE(1970-2099)";
	}
}
const char *
getTimeReported(smsg_t * const pM, enum tplFormatTypes eFmt)
{
	if(pM == NULL)
		return "";
	switch(eFmt) {
	case tplFmtDefault:
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP3164 == NULL) {
			pM-&gt;pszTIMESTAMP3164 = pM-&gt;pszTimestamp3164;
			datetime.formatTimestamp3164(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3164,
						     (eFmt == tplFmtRFC3164BuggyDate));
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP3164);
	case tplFmtMySQLDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_MySQL == NULL) {
			if((pM-&gt;pszTIMESTAMP_MySQL = malloc(15)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestampToMySQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_MySQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_MySQL);
	case tplFmtPgSQLDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_PgSQL == NULL) {
			if((pM-&gt;pszTIMESTAMP_PgSQL = malloc(21)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestampToPgSQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_PgSQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_PgSQL);
	case tplFmtRFC3339Date:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP3339 == NULL) {
			pM-&gt;pszTIMESTAMP3339 = pM-&gt;pszTimestamp3339;
			datetime.formatTimestamp3339(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3339);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP3339);
	case tplFmtUnixDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_Unix[0] == '\0') {
			datetime.formatTimestampUnix(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_Unix);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_Unix);
	case tplFmtSecFrac:
		if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
			MsgLock(pM);
			if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
				datetime.formatTimestampSecFrac(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_SecFrac);
			}
			MsgUnlock(pM);
		}
		return(pM-&gt;pszTIMESTAMP_SecFrac);
	case tplFmtWDayName:
		return wdayNames[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtWDay:
		return one_digit[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtMonth:
		return two_digits[(int)pM-&gt;tTIMESTAMP.month];
	case tplFmtYear:
		if(pM-&gt;tTIMESTAMP.year &gt;= 1967 &amp;&amp; pM-&gt;tTIMESTAMP.year &lt;= 2099)
			return years[pM-&gt;tTIMESTAMP.year - 1967];
		else
			return "YEAR OUT OF RANGE(1967-2099)";
	case tplFmtDay:
		return two_digits[(int)pM-&gt;tTIMESTAMP.day];
	case tplFmtHour:
		return two_digits[(int)pM-&gt;tTIMESTAMP.hour];
	case tplFmtMinute:
		return two_digits[(int)pM-&gt;tTIMESTAMP.minute];
	case tplFmtSecond:
		return two_digits[(int)pM-&gt;tTIMESTAMP.second];
	case tplFmtTZOffsHour:
		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetHour];
	case tplFmtTZOffsMin:
		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetMinute];
	case tplFmtTZOffsDirection:
		return (pM-&gt;tTIMESTAMP.OffsetMode == '+')? "+" : "-";
	case tplFmtOrdinal:
		return daysInYear[getOrdinal(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtWeek:
		return two_digits[getWeek(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		return formatISOWeekOrYear(eFmt, &amp;pM-&gt;tTIMESTAMP);
	}
	return "INVALID eFmt OPTION!";
}
static const char *getTimeUTC(struct syslogTime *const __restrict__ pTmIn,
	const enum tplFormatTypes eFmt,
	unsigned short *const __restrict__ pbMustBeFreed)
{
	struct syslogTime tUTC;
	char *retbuf = NULL;
	timeConvertToUTC(pTmIn, &amp;tUTC);
	struct syslogTime *const pTm = &amp;tUTC;
	switch(eFmt) {
	case tplFmtDefault:
		if((retbuf = malloc(16)) != NULL) {
			datetime.formatTimestamp3164(pTm, retbuf, 0);
		}
		break;
	case tplFmtMySQLDate:
		if((retbuf = malloc(15)) != NULL) {
			datetime.formatTimestampToMySQL(pTm, retbuf);
		}
		break;
	case tplFmtPgSQLDate:
		if((retbuf = malloc(21)) != NULL) {
			datetime.formatTimestampToPgSQL(pTm, retbuf);
		}
		break;
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		if((retbuf = malloc(16)) != NULL) {
			datetime.formatTimestamp3164(pTm, retbuf, (eFmt == tplFmtRFC3164BuggyDate));
		}
		break;
	case tplFmtRFC3339Date:
		if((retbuf = malloc(33)) != NULL) {
			datetime.formatTimestamp3339(pTm, retbuf);
		}
		break;
	case tplFmtUnixDate:
		if((retbuf = malloc(12)) != NULL) {
			datetime.formatTimestampUnix(pTm, retbuf);
		}
		break;
	case tplFmtSecFrac:
		if((retbuf = malloc(7)) != NULL) {
			datetime.formatTimestampSecFrac(pTm, retbuf);
		}
		break;
	case tplFmtWDayName:
		retbuf = strdup(wdayNames[getWeekdayNbr(pTm)]);
		break;
	case tplFmtWDay:
		retbuf = strdup(one_digit[getWeekdayNbr(pTm)]);
		break;
	case tplFmtMonth:
		retbuf = strdup(two_digits[(int)pTm-&gt;month]);
		break;
	case tplFmtYear:
		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
			retbuf = strdup(years[pTm-&gt;year - 1967]);
		else
			retbuf = strdup("YEAR OUT OF RANGE(1967-2099)");
		break;
	case tplFmtDay:
		retbuf = strdup(two_digits[(int)pTm-&gt;day]);
		break;
	case tplFmtHour:
		retbuf = strdup(two_digits[(int)pTm-&gt;hour]);
		break;
	case tplFmtMinute:
		retbuf = strdup(two_digits[(int)pTm-&gt;minute]);
		break;
	case tplFmtSecond:
		retbuf = strdup(two_digits[(int)pTm-&gt;second]);
		break;
	case tplFmtTZOffsHour:
		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetHour]);
		break;
	case tplFmtTZOffsMin:
		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetMinute]);
		break;
	case tplFmtTZOffsDirection:
		retbuf = strdup((pTm-&gt;OffsetMode == '+')? "+" : "-");
		break;
	case tplFmtOrdinal:
		retbuf = strdup(daysInYear[getOrdinal(pTm)]);
		break;
	case tplFmtWeek:
		retbuf = strdup(two_digits[getWeek(pTm)]);
		break;
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		retbuf = strdup(formatISOWeekOrYear(eFmt, pTm));
		break;
	}
	if(retbuf == NULL) {
		retbuf = (char*)"internal error: invalid eFmt option or malloc problem";
		*pbMustBeFreed = 0;
	} else {
		*pbMustBeFreed = 1;
	}
	return retbuf;
}
static const char *
getTimeGenerated(smsg_t *const __restrict__ pM,
	const enum tplFormatTypes eFmt)
{
	struct syslogTime *const pTm = &amp;pM-&gt;tRcvdAt;
	if(pM == NULL)
		return "";
	switch(eFmt) {
	case tplFmtDefault:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3164 == NULL) {
			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164, 0);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3164);
	case tplFmtMySQLDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_MySQL == NULL) {
			if((pM-&gt;pszRcvdAt_MySQL = malloc(15)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestampToMySQL(pTm, pM-&gt;pszRcvdAt_MySQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_MySQL);
	case tplFmtPgSQLDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_PgSQL == NULL) {
			if((pM-&gt;pszRcvdAt_PgSQL = malloc(21)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestampToPgSQL(pTm, pM-&gt;pszRcvdAt_PgSQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_PgSQL);
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3164 == NULL) {
			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
					MsgUnlock(pM);
					return "";
				}
			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164,
						     (eFmt == tplFmtRFC3164BuggyDate));
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3164);
	case tplFmtRFC3339Date:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3339 == NULL) {
			if((pM-&gt;pszRcvdAt3339 = malloc(33)) == NULL) {
				MsgUnlock(pM);
				return "";
			}
			datetime.formatTimestamp3339(pTm, pM-&gt;pszRcvdAt3339);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3339);
	case tplFmtUnixDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_Unix[0] == '\0') {
			datetime.formatTimestampUnix(pTm, pM-&gt;pszRcvdAt_Unix);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_Unix);
	case tplFmtSecFrac:
		if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
			MsgLock(pM);
			if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
				datetime.formatTimestampSecFrac(pTm, pM-&gt;pszRcvdAt_SecFrac);
			}
			MsgUnlock(pM);
		}
		return(pM-&gt;pszRcvdAt_SecFrac);
	case tplFmtWDayName:
		return wdayNames[getWeekdayNbr(pTm)];
	case tplFmtWDay:
		return one_digit[getWeekdayNbr(pTm)];
	case tplFmtMonth:
		return two_digits[(int)pTm-&gt;month];
	case tplFmtYear:
		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
			return years[pTm-&gt;year - 1967];
		else
			return "YEAR OUT OF RANGE(1967-2099)";
	case tplFmtDay:
		return two_digits[(int)pTm-&gt;day];
	case tplFmtHour:
		return two_digits[(int)pTm-&gt;hour];
	case tplFmtMinute:
		return two_digits[(int)pTm-&gt;minute];
	case tplFmtSecond:
		return two_digits[(int)pTm-&gt;second];
	case tplFmtTZOffsHour:
		return two_digits[(int)pTm-&gt;OffsetHour];
	case tplFmtTZOffsMin:
		return two_digits[(int)pTm-&gt;OffsetMinute];
	case tplFmtTZOffsDirection:
		return (pTm-&gt;OffsetMode == '+')? "+" : "-";
	case tplFmtOrdinal:
		return daysInYear[getOrdinal(pTm)];
	case tplFmtWeek:
		return two_digits[getWeek(pTm)];
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		return formatISOWeekOrYear(eFmt, pTm);
	}
	return "INVALID eFmt OPTION!";
}
static const char *getSeverity(smsg_t * const pM)
{
	const char *name = NULL;
	if(pM == NULL)
		return "";
	if(pM-&gt;iSeverity &gt; 7) {
		name = "invld";
	} else {
		name = syslog_number_names[pM-&gt;iSeverity];
	}
	return name;
}
static const char *getSeverityStr(smsg_t * const pM)
{
	const char *name = NULL;
	if(pM == NULL)
		return "";
	if(pM-&gt;iSeverity &gt; 7) {
		name = "invld";
	} else {
		name = syslog_severity_names[pM-&gt;iSeverity];
	}
	return name;
}
static const char *getFacility(smsg_t * const pM)
{
	const char *name = NULL;
	if(pM == NULL)
		return "";
	if(pM-&gt;iFacility &gt; 23) {
		name = "invld";
	} else {
		name = syslog_number_names[pM-&gt;iFacility];
	}
	return name;
}
static const char *getFacilityStr(smsg_t * const pM)
{
	const char *name = NULL;
	if(pM == NULL)
		return "";
	if(pM-&gt;iFacility &gt; 23) {
		name = "invld";
	} else {
		name = syslog_fac_names[pM-&gt;iFacility];
	}
	return name;
}
rsRetVal
MsgSetFlowControlType(smsg_t * const pMsg, flowControl_t eFlowCtl)
{
	DEFiRet;
	assert(pMsg != NULL);
	assert(eFlowCtl == eFLOWCTL_NO_DELAY || eFlowCtl == eFLOWCTL_LIGHT_DELAY || eFlowCtl == eFLOWCTL_FULL_DELAY);
	pMsg-&gt;flowCtlType = eFlowCtl;
	RETiRet;
}
rsRetVal
MsgSetAfterPRIOffs(smsg_t * const pMsg, int offs)
{
	assert(pMsg != NULL);
	pMsg-&gt;offAfterPRI = offs;
	return RS_RET_OK;
}
rsRetVal ATTR_NONNULL(1,2)
MsgSetAPPNAME(smsg_t *__restrict__ const pMsg, const char *pszAPPNAME)
{
	DEFiRet;
	assert(pMsg != NULL);
	if(pszAPPNAME[0] == '\0') {
		pszAPPNAME = "-"; 	}
	if(pMsg-&gt;pCSAPPNAME == NULL) {
		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSAPPNAME));
	}
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSAPPNAME, (uchar*) pszAPPNAME));
	cstrFinalize(pMsg-&gt;pCSAPPNAME);
finalize_it:
	RETiRet;
}
rsRetVal MsgSetPROCID(smsg_t *__restrict__ const pMsg, const char* pszPROCID)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	if(pMsg-&gt;pCSPROCID == NULL) {
		CHKiRet(cstrConstruct(&amp;pMsg-&gt;pCSPROCID));
	}
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSPROCID, (uchar*) pszPROCID));
	cstrFinalize(pMsg-&gt;pCSPROCID);
finalize_it:
	RETiRet;
}
static void preparePROCID(smsg_t * const pM, sbool bLockMutex)
{
	if(pM-&gt;pCSPROCID == NULL) {
		if(bLockMutex == LOCK_MUTEX)
			MsgLock(pM);
		if(pM-&gt;pCSPROCID == NULL)
			acquirePROCIDFromTAG(pM);
		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
	}
}
#if 0
static int getPROCIDLen(smsg_t *pM, sbool bLockMutex)
{
	assert(pM != NULL);
	preparePROCID(pM, bLockMutex);
	return (pM-&gt;pCSPROCID == NULL) ? 1 : rsCStrLen(pM-&gt;pCSPROCID);
}
#endif
char *getPROCID(smsg_t * const pM, sbool bLockMutex)
{
	uchar *pszRet;
	ISOBJ_TYPE_assert(pM, msg);
	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	preparePROCID(pM, MUTEX_ALREADY_LOCKED);
	if(pM-&gt;pCSPROCID == NULL)
		pszRet = UCHAR_CONSTANT("-");
	else
		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSPROCID);
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
	return (char*) pszRet;
}
rsRetVal MsgSetMSGID(smsg_t * const pMsg, const char* pszMSGID)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	if(pMsg-&gt;pCSMSGID == NULL) {
		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSMSGID));
	}
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSMSGID, (uchar*) pszMSGID));
	cstrFinalize(pMsg-&gt;pCSMSGID);
finalize_it:
	RETiRet;
}
static const char *getParseSuccess(smsg_t * const pM)
{
	return (pM-&gt;bParseSuccess) ? "OK" : "FAIL";
}
static const char *getMSGID(smsg_t * const pM)
{
	if (pM-&gt;pCSMSGID == NULL) {
		return "-";
	}
	else {
		MsgLock(pM);
		char* pszreturn = (char*) rsCStrGetSzStrNoNULL(pM-&gt;pCSMSGID);
		MsgUnlock(pM);
		return pszreturn;
	}
}
void MsgSetParseSuccess(smsg_t * const pMsg, int bSuccess)
{
	assert(pMsg != NULL);
	pMsg-&gt;bParseSuccess = bSuccess;
}
const uchar*
msgGetJSONMESG(smsg_t *__restrict__ const pMsg)
{
	struct json_object *json;
	struct json_object *jval;
	uchar *pRes; 	rs_size_t bufLen = -1; 
	json = json_object_new_object();
	jval = json_object_new_string((char*)getMSG(pMsg));
	json_object_object_add(json, "msg", jval);
	getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "rawmsg", jval);
	pRes = (uchar*)getTimeReported(pMsg, tplFmtRFC3339Date);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "timereported", jval);
	jval = json_object_new_string(getHOSTNAME(pMsg));
	json_object_object_add(json, "hostname", jval);
	getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "syslogtag", jval);
	getInputName(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "inputname", jval);
	jval = json_object_new_string((char*)getRcvFrom(pMsg));
	json_object_object_add(json, "fromhost", jval);
	jval = json_object_new_string((char*)getRcvFromIP(pMsg));
	json_object_object_add(json, "fromhost-ip", jval);
	jval = json_object_new_string(getPRI(pMsg));
	json_object_object_add(json, "pri", jval);
	jval = json_object_new_string(getFacility(pMsg));
	json_object_object_add(json, "syslogfacility", jval);
	jval = json_object_new_string(getSeverity(pMsg));
	json_object_object_add(json, "syslogseverity", jval);
	pRes = (uchar*)getTimeGenerated(pMsg, tplFmtRFC3339Date);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "timegenerated", jval);
	jval = json_object_new_string((char*)getProgramName(pMsg, LOCK_MUTEX));
	json_object_object_add(json, "programname", jval);
	jval = json_object_new_string(getProtocolVersionString(pMsg));
	json_object_object_add(json, "protocol-version", jval);
	MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, "structured-data", jval);
	jval = json_object_new_string(getAPPNAME(pMsg, LOCK_MUTEX));
	json_object_object_add(json, "app-name", jval);
	jval = json_object_new_string(getPROCID(pMsg, LOCK_MUTEX));
	json_object_object_add(json, "procid", jval);
	jval = json_object_new_string(getMSGID(pMsg));
	json_object_object_add(json, "msgid", jval);
#ifdef USE_LIBUUID
	if(pMsg-&gt;pszUUID == NULL) {
		jval = NULL;
	} else {
		getUUID(pMsg, &amp;pRes, &amp;bufLen);
		jval = json_object_new_string((char*)pRes);
	}
	json_object_object_add(json, "uuid", jval);
#endif
	json_object_object_add(json, "$!", json_object_get(pMsg-&gt;json));
	pRes = (uchar*) strdup(json_object_get_string(json));
	json_object_put(json);
	return pRes;
}
void MsgSetRuleset(smsg_t * const pMsg, ruleset_t *pRuleset)
{
	assert(pMsg != NULL);
	pMsg-&gt;pRuleset = pRuleset;
}
void MsgSetTAG(smsg_t *__restrict__ const pMsg, const uchar* pszBuf, const size_t lenBuf)
{
	uchar *pBuf;
	assert(pMsg != NULL);
	freeTAG(pMsg);
	pMsg-&gt;iLenTAG = lenBuf;
	if(pMsg-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
		pBuf = pMsg-&gt;TAG.szBuf;
	} else {
		if((pBuf = (uchar*) malloc(pMsg-&gt;iLenTAG + 1)) == NULL) {
			pBuf = pMsg-&gt;TAG.szBuf;
			pMsg-&gt;iLenTAG = CONF_TAG_BUFSIZE - 1;
		} else {
			pMsg-&gt;TAG.pszTAG = pBuf;
		}
	}
	memcpy(pBuf, pszBuf, pMsg-&gt;iLenTAG);
	pBuf[pMsg-&gt;iLenTAG] = '\0'; }
static void ATTR_NONNULL(1)
tryEmulateTAG(smsg_t *const pM, const sbool bLockMutex)
{
	size_t lenTAG;
	uchar bufTAG[CONF_TAG_MAXSIZE];
	assert(pM != NULL);
	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	if(pM-&gt;iLenTAG &gt; 0) {
		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
		return; 	}
	if(msgGetProtocolVersion(pM) == 1) {
		if(!strcmp(getPROCID(pM, MUTEX_ALREADY_LOCKED), "-")) {
			MsgSetTAG(pM, (uchar*) getAPPNAME(pM, MUTEX_ALREADY_LOCKED),
					getAPPNAMELen(pM, MUTEX_ALREADY_LOCKED));
		} else {
			lenTAG = snprintf((char*)bufTAG, CONF_TAG_MAXSIZE, "%s[%s]",
					  getAPPNAME(pM, MUTEX_ALREADY_LOCKED), getPROCID(pM, MUTEX_ALREADY_LOCKED));
			bufTAG[sizeof(bufTAG)-1] = '\0'; 			MsgSetTAG(pM, bufTAG, lenTAG);
		}
		pM-&gt;iLenPROGNAME = -1;
	}
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
}
void ATTR_NONNULL(2,3)
getTAG(smsg_t * const pM, uchar **const ppBuf, int *const piLen, const sbool bLockMutex)
{
	if(pM == NULL) {
		*ppBuf = UCHAR_CONSTANT("");
		*piLen = 0;
	} else {
		if(pM-&gt;iLenTAG == 0)
			tryEmulateTAG(pM, bLockMutex);
		if(pM-&gt;iLenTAG == 0) {
			*ppBuf = UCHAR_CONSTANT("");
			*piLen = 0;
		} else {
			*ppBuf = (pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG;
			*piLen = pM-&gt;iLenTAG;
		}
	}
}
int getHOSTNAMELen(smsg_t * const pM)
{
	if(pM == NULL)
		return 0;
	else
		if(pM-&gt;pszHOSTNAME == NULL) {
			resolveDNS(pM);
			if(pM-&gt;rcvFrom.pRcvFrom == NULL)
				return 0;
			else
				return prop.GetStringLen(pM-&gt;rcvFrom.pRcvFrom);
		} else
			return pM-&gt;iLenHOSTNAME;
}
const char *getHOSTNAME(smsg_t * const pM)
{
	if(pM == NULL)
		return "";
	else
		if(pM-&gt;pszHOSTNAME == NULL) {
			resolveDNS(pM);
			if(pM-&gt;rcvFrom.pRcvFrom == NULL) {
				return "";
			} else {
				uchar *psz;
				int len;
				prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
				return (char*) psz;
			}
		} else {
			return (char*) pM-&gt;pszHOSTNAME;
		}
}
uchar *getRcvFrom(smsg_t * const pM)
{
	uchar *psz;
	int len;
	if(pM == NULL) {
		psz = UCHAR_CONSTANT("");
	} else {
		resolveDNS(pM);
		if(pM-&gt;rcvFrom.pRcvFrom == NULL)
			psz = UCHAR_CONSTANT("");
		else
			prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
	}
	return psz;
}
rsRetVal MsgSetStructuredData(smsg_t * const pMsg, const char* pszStrucData)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	free(pMsg-&gt;pszStrucData);
	CHKmalloc(pMsg-&gt;pszStrucData = (uchar*)strdup(pszStrucData));
	pMsg-&gt;lenStrucData = strlen(pszStrucData);
finalize_it:
	RETiRet;
}
void
MsgGetStructuredData(smsg_t * const pM, uchar **pBuf, rs_size_t *len)
{
	MsgLock(pM);
	if(pM-&gt;pszStrucData == NULL) {
		*pBuf = UCHAR_CONSTANT("-"),
		*len = 1;
	} else  {
		*pBuf = pM-&gt;pszStrucData,
		*len = pM-&gt;lenStrucData;
	}
	MsgUnlock(pM);
}
uchar * ATTR_NONNULL(1)
getProgramName(smsg_t *const pM, const sbool bLockMutex)
{
	if(bLockMutex == LOCK_MUTEX) {
		MsgLock(pM);
	}
	if(pM-&gt;iLenPROGNAME == -1) {
		if(pM-&gt;iLenTAG == 0) {
			uchar *pRes;
			rs_size_t bufLen = -1;
			getTAG(pM, &amp;pRes, &amp;bufLen, MUTEX_ALREADY_LOCKED);
		}
		acquireProgramName(pM);
	}
	if(bLockMutex == LOCK_MUTEX) {
		MsgUnlock(pM);
	}
	return (pM-&gt;iLenPROGNAME &lt; CONF_PROGNAME_BUFSIZE) ? pM-&gt;PROGNAME.szBuf
						       : pM-&gt;PROGNAME.ptr;
}
static void ATTR_NONNULL(1)
prepareAPPNAME(smsg_t *const pM, const sbool bLockMutex)
{
	if(pM-&gt;pCSAPPNAME == NULL) {
		if(bLockMutex == LOCK_MUTEX)
			MsgLock(pM);
		if(pM-&gt;pCSAPPNAME == NULL) {
			if(msgGetProtocolVersion(pM) == 0) {
				MsgSetAPPNAME(pM, (char*)getProgramName(pM, MUTEX_ALREADY_LOCKED));
			}
		}
		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
	}
}
char *getAPPNAME(smsg_t * const pM, const sbool bLockMutex)
{
	uchar *pszRet;
	assert(pM != NULL);
	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	prepareAPPNAME(pM, MUTEX_ALREADY_LOCKED);
	if(pM-&gt;pCSAPPNAME == NULL)
		pszRet = UCHAR_CONSTANT("");
	else
		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSAPPNAME);
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
	return (char*)pszRet;
}
static int getAPPNAMELen(smsg_t * const pM, const sbool bLockMutex)
{
	assert(pM != NULL);
	prepareAPPNAME(pM, bLockMutex);
	return (pM-&gt;pCSAPPNAME == NULL) ? 0 : rsCStrLen(pM-&gt;pCSAPPNAME);
}
void MsgSetInputName(smsg_t *pThis, prop_t *inputName)
{
	assert(pThis != NULL);
	prop.AddRef(inputName);
	if(pThis-&gt;pInputName != NULL)
		prop.Destruct(&amp;pThis-&gt;pInputName);
	pThis-&gt;pInputName = inputName;
}
void MsgSetDfltTZ(smsg_t *pThis, char *tz)
{
	strncpy(pThis-&gt;dfltTZ, tz, 7);
	pThis-&gt;dfltTZ[7] = '\0'; }
rsRetVal
msgSetFromSockinfo(smsg_t *pThis, struct sockaddr_storage *sa){
	DEFiRet;
	assert(pThis-&gt;rcvFrom.pRcvFrom == NULL);
	CHKmalloc(pThis-&gt;rcvFrom.pfrominet = malloc(sizeof(struct sockaddr_storage)));
	memcpy(pThis-&gt;rcvFrom.pfrominet, sa, sizeof(struct sockaddr_storage));
finalize_it:
	RETiRet;
}
void MsgSetRcvFrom(smsg_t *pThis, prop_t *new)
{
	prop.AddRef(new);
	MsgSetRcvFromWithoutAddRef(pThis, new);
}
void MsgSetRcvFromStr(smsg_t * const pThis, const uchar *psz, const int len, prop_t **ppProp)
{
	assert(pThis != NULL);
	assert(ppProp != NULL);
	prop.CreateOrReuseStringProp(ppProp, psz, len);
	MsgSetRcvFrom(pThis, *ppProp);
}
rsRetVal MsgSetRcvFromIP(smsg_t *pThis, prop_t *new)
{
	assert(pThis != NULL);
	prop.AddRef(new);
	MsgSetRcvFromIPWithoutAddRef(pThis, new);
	return RS_RET_OK;
}
rsRetVal MsgSetRcvFromIPStr(smsg_t *const pThis, const uchar *psz, const int len, prop_t **ppProp)
{
	DEFiRet;
	assert(pThis != NULL);
	CHKiRet(prop.CreateOrReuseStringProp(ppProp, psz, len));
	MsgSetRcvFromIP(pThis, *ppProp);
finalize_it:
	RETiRet;
}
void MsgSetHOSTNAME(smsg_t *pThis, const uchar* pszHOSTNAME, const int lenHOSTNAME)
{
	assert(pThis != NULL);
	freeHOSTNAME(pThis);
	pThis-&gt;iLenHOSTNAME = lenHOSTNAME;
	if(pThis-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
	} else if((pThis-&gt;pszHOSTNAME = (uchar*) malloc(pThis-&gt;iLenHOSTNAME + 1)) == NULL) {
		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
		pThis-&gt;iLenHOSTNAME = CONF_HOSTNAME_BUFSIZE - 1;
	}
	memcpy(pThis-&gt;pszHOSTNAME, pszHOSTNAME, pThis-&gt;iLenHOSTNAME);
	pThis-&gt;pszHOSTNAME[pThis-&gt;iLenHOSTNAME] = '\0'; }
void MsgSetMSGoffs(smsg_t * const pMsg, int offs)
{
	ISOBJ_TYPE_assert(pMsg, msg);
	pMsg-&gt;offMSG = offs;
	if(offs &gt; pMsg-&gt;iLenRawMsg) {
		assert((int)offs - 1 == pMsg-&gt;iLenRawMsg);
		pMsg-&gt;iLenMSG = 0;
	} else {
		pMsg-&gt;iLenMSG = pMsg-&gt;iLenRawMsg - offs;
	}
}
rsRetVal MsgReplaceMSG(smsg_t *pThis, const uchar* pszMSG, int lenMSG)
{
	int lenNew;
	uchar *bufNew;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, msg);
	assert(pszMSG != NULL);
	lenNew = pThis-&gt;iLenRawMsg + lenMSG - pThis-&gt;iLenMSG;
	if(lenMSG &gt; pThis-&gt;iLenMSG &amp;&amp; lenNew &gt;= CONF_RAWMSG_BUFSIZE) {
		CHKmalloc(bufNew = malloc(lenNew + 1));
		memcpy(bufNew, pThis-&gt;pszRawMsg, pThis-&gt;offMSG);
		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
			free(pThis-&gt;pszRawMsg);
		pThis-&gt;pszRawMsg = bufNew;
	}
	if(lenMSG &gt; 0)
		memcpy(pThis-&gt;pszRawMsg + pThis-&gt;offMSG, pszMSG, lenMSG);
	pThis-&gt;pszRawMsg[lenNew] = '\0'; 	pThis-&gt;iLenRawMsg = lenNew;
	pThis-&gt;iLenMSG = lenMSG;
finalize_it:
	RETiRet;
}
void ATTR_NONNULL()
MsgTruncateToMaxSize(smsg_t *const pThis)
{
	ISOBJ_TYPE_assert(pThis, msg);
	const int maxMsgSize = glblGetMaxLine(runConf);
	assert(pThis-&gt;iLenRawMsg &gt; maxMsgSize);
	const int deltaSize = pThis-&gt;iLenRawMsg - maxMsgSize;
	pThis-&gt;pszRawMsg[maxMsgSize] = '\0';
	pThis-&gt;iLenRawMsg = maxMsgSize;
	if(pThis-&gt;iLenMSG &lt; deltaSize) {
		pThis-&gt;iLenMSG = 0;
	} else {
		pThis-&gt;iLenMSG -= deltaSize;
	}
}
void ATTR_NONNULL()
MsgSetRawMsg(smsg_t *const pThis, const char*const pszRawMsg, const size_t lenMsg)
{
	ISOBJ_TYPE_assert(pThis, msg);
	int deltaSize;
	if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
		free(pThis-&gt;pszRawMsg);
	deltaSize = (int) lenMsg - pThis-&gt;iLenRawMsg; 	pThis-&gt;iLenRawMsg = lenMsg;
	if(pThis-&gt;iLenRawMsg &lt; CONF_RAWMSG_BUFSIZE) {
		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
	} else if((pThis-&gt;pszRawMsg = (uchar*) malloc(pThis-&gt;iLenRawMsg + 1)) == NULL) {
		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
		pThis-&gt;iLenRawMsg = CONF_RAWMSG_BUFSIZE - 1;
	}
	memcpy(pThis-&gt;pszRawMsg, pszRawMsg, pThis-&gt;iLenRawMsg);
	pThis-&gt;pszRawMsg[pThis-&gt;iLenRawMsg] = '\0'; 	if(pThis-&gt;iLenRawMsg &gt; pThis-&gt;offMSG)
		pThis-&gt;iLenMSG += deltaSize;
	else
		pThis-&gt;iLenMSG = 0;
}
void MsgSetRawMsgWOSize(smsg_t * const pMsg, char* pszRawMsg)
{
	MsgSetRawMsg(pMsg, pszRawMsg, strlen(pszRawMsg));
}
static uchar *
textpri(const smsg_t *const __restrict__ pMsg)
{
	int lenfac = len_syslog_fac_names[pMsg-&gt;iFacility];
	int lensev = len_syslog_severity_names[pMsg-&gt;iSeverity];
	int totlen = lenfac + 1 + lensev + 1;
	char *pRes = malloc(totlen);
	if(pRes != NULL) {
		memcpy(pRes, syslog_fac_names[pMsg-&gt;iFacility], lenfac);
		pRes[lenfac] = '.';
		memcpy(pRes+lenfac+1, syslog_severity_names[pMsg-&gt;iSeverity], lensev+1 	}
	return (uchar*)pRes;
}
typedef enum ENOWType { NOW_NOW, NOW_YEAR, NOW_MONTH, NOW_DAY, NOW_HOUR,
		NOW_HHOUR, NOW_QHOUR, NOW_MINUTE, NOW_WDAY } eNOWType;
#define tmpBUFSIZE 16	static uchar *getNOW(eNOWType eNow, struct syslogTime *t, const int inUTC)
{
	uchar *pBuf;
	struct syslogTime tt;
	if((pBuf = (uchar*) malloc(tmpBUFSIZE)) == NULL) {
		return NULL;
	}
	if(t == NULL) { 		datetime.getCurrTime(&amp;tt, NULL, inUTC);
		t = &amp;tt;
	}
	if(t-&gt;year == 0 || t-&gt;inUTC != inUTC) { 		datetime.getCurrTime(t, NULL, inUTC);
	}
	switch(eNow) {
	case NOW_NOW:
		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
		memcpy(pBuf+2, two_digits[t-&gt;year%100], 2);
		pBuf[4] = '-';
		memcpy(pBuf+5, two_digits[(int)t-&gt;month], 2);
		pBuf[7] = '-';
		memcpy(pBuf+8, two_digits[(int)t-&gt;day], 3);
		break;
	case NOW_YEAR:
		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
		memcpy(pBuf+2, two_digits[t-&gt;year%100], 3);
		break;
	case NOW_MONTH:
		memcpy(pBuf, two_digits[(int)t-&gt;month], 3);
		break;
	case NOW_DAY:
		memcpy(pBuf, two_digits[(int)t-&gt;day], 3);
		break;
	case NOW_HOUR:
		memcpy(pBuf, two_digits[(int)t-&gt;hour], 3);
		break;
	case NOW_HHOUR:
		memcpy(pBuf, two_digits[t-&gt;minute/30], 3);
		break;
	case NOW_QHOUR:
		memcpy(pBuf, two_digits[t-&gt;minute/15], 3);
		break;
	case NOW_MINUTE:
		memcpy(pBuf, two_digits[(int)t-&gt;minute], 3);
		break;
	case NOW_WDAY:
		memcpy(pBuf, one_digit[(int)t-&gt;wday], 2);
		break;
	}
	return(pBuf);
}
#undef tmpBUFSIZE 
static rsRetVal ATTR_NONNULL()
getJSONRootAndMutex(smsg_t *const pMsg, const propid_t id,
	struct json_object ***const jroot, pthread_mutex_t **const mut)
{
	DEFiRet;
	assert(jroot != NULL); 	assert(mut != NULL);
<a name="1"></a>	assert(*mut == NULL); 	assert(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(id == PROP_CEE) {
		*mut = &amp;pMsg-&gt;mut;
		*jroot = &amp;pMsg-&gt;json;
	} else if(id == PROP_LOCAL_VAR) {
		*mut = &amp;pMsg-&gt;mut;
		*jroot = &amp;pMsg-&gt;localvars;
	} else if(id == PROP_GLOBAL_VAR) {</b></font>
		*mut = &amp;glblVars_lock;
		*jroot = &amp;global_var_root;
	} else {
		LogError(0, RS_RET_NON_JSON_PROP, "internal error:  "
			"getJSONRootAndMutex; invalid property id %d", id);
		iRet = RS_RET_NON_JSON_PROP;
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
getJSONRootAndMutexByVarChar(smsg_t *const pMsg, const char c,
	struct json_object ***const jroot, pthread_mutex_t **const mut)
{
	DEFiRet;
	propid_t id;
	assert(c == '!' || c == '.' || c == '/');
	switch(c) {
		case '!':
			id = PROP_CEE;
			break;
		case '.':
			id = PROP_LOCAL_VAR;
			break;
		case '/':
			id = PROP_GLOBAL_VAR;
			break;
		default:
			LogError(0, RS_RET_NON_JSON_PROP, "internal error:  "
				"getJSONRootAndMutex; invalid indicator char %c(%2.2x)", c, c);
			ABORT_FINALIZE(RS_RET_NON_JSON_PROP);
			break;
	}
	iRet = getJSONRootAndMutex(pMsg, id, jroot, mut);
finalize_it:
	RETiRet;
}
rsRetVal
getJSONPropVal(smsg_t * const pMsg, msgPropDescr_t *pProp, uchar **pRes, rs_size_t *buflen,
	unsigned short *pbMustBeFreed)
{
	uchar *leaf;
	struct json_object **jroot;
	struct json_object *parent;
	struct json_object *field;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	*pRes = NULL;
	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(*jroot == NULL) FINALIZE;
	if(!strcmp((char*)pProp-&gt;name, "!")) {
		field = *jroot;
	} else {
		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
			field = NULL;
	}
	if(field != NULL) {
		*pRes = (uchar*) strdup(json_object_get_string(field));
		*buflen = (int) ustrlen(*pRes);
		*pbMustBeFreed = 1;
	}
finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	if(*pRes == NULL) {
		*pRes = (unsigned char*)"";
		*pbMustBeFreed = 0;
	}
	RETiRet;
}
rsRetVal
msgGetJSONPropJSONorString(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson,
	uchar **pcstr)
{
	struct json_object **jroot;
	uchar *leaf;
	struct json_object *parent;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	*pjson = NULL, *pcstr = NULL;
	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(!strcmp((char*)pProp-&gt;name, "!")) {
		*pjson = *jroot;
		FINALIZE;
	}
	if(*jroot == NULL) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(*pjson == NULL) {
		*pcstr = (uchar*) strdup("");
	} else {
		if(json_object_get_type(*pjson) == json_type_string) {
			*pcstr = (uchar*) strdup(json_object_get_string(*pjson));
			*pjson = NULL;
		}
	}
finalize_it:
	if(*pjson != NULL)
		*pjson = jsonDeepCopy(*pjson);
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}
rsRetVal
msgGetJSONPropJSON(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson)
{
	struct json_object **jroot;
	uchar *leaf;
	struct json_object *parent;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	*pjson = NULL;
	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(!strcmp((char*)pProp-&gt;name, "!")) {
		*pjson = *jroot;
		FINALIZE;
	}
	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
finalize_it:
	if(*pjson != NULL)
		*pjson = jsonDeepCopy(*pjson);
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}
static rsRetVal
jsonAddVal(uchar *pSrc, unsigned buflen, es_str_t **dst, int escapeAll)
{
	unsigned char c;
	es_size_t i;
	char numbuf[4];
	unsigned ni;
	unsigned char nc;
	int j;
	DEFiRet;
	for(i = 0 ; i &lt; buflen ; ++i) {
		c = pSrc[i];
		if(   (c &gt;= 0x23 &amp;&amp; c &lt;= 0x2e)
		   || (c &gt;= 0x30 &amp;&amp; c &lt;= 0x5b)
		   || c == 0x20 || c == 0x21) {
			if(*dst != NULL)
				es_addChar(dst, c);
		} else {
			if(*dst == NULL) {
				if(i == 0) {
					*dst = es_newStr(buflen+10);
				} else {
					*dst = es_newStrFromBuf((char*)pSrc, i);
				}
				if(*dst == NULL) {
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
			}
			switch(c) {
			case '\0':
				es_addBuf(dst, "\\u0000", 6);
				break;
			case '\"':
				es_addBuf(dst, "\\\"", 2);
				break;
			case '/':
				es_addBuf(dst, "\\/", 2);
				break;
			case '\\':
				if (escapeAll == RSFALSE) {
					ni = i + 1;
					if (ni &lt;= buflen) {
						nc = pSrc[ni];
						if (   nc == '"' || nc == '/' || nc == '\\' || nc == 'b' || nc == 'f'
							|| nc == 'n' || nc == 'r' || nc == 't' || nc == 'u') {
							es_addChar(dst, c);
							es_addChar(dst, nc);
							i = ni;
							break;
						}
					}
				}
				es_addBuf(dst, "\\\\", 2);
				break;
			case '\010':
				es_addBuf(dst, "\\b", 2);
				break;
			case '\014':
				es_addBuf(dst, "\\f", 2);
				break;
			case '\n':
				es_addBuf(dst, "\\n", 2);
				break;
			case '\r':
				es_addBuf(dst, "\\r", 2);
				break;
			case '\t':
				es_addBuf(dst, "\\t", 2);
				break;
			default:
				for(j = 0 ; j &lt; 4 ; ++j) {
					numbuf[3-j] = hexdigit[c % 16];
					c = c / 16;
				}
				es_addBuf(dst, "\\u", 2);
				es_addBuf(dst, numbuf, 4);
				break;
			}
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
jsonEncode(uchar **ppRes, unsigned short *pbMustBeFreed, int *pBufLen, int escapeAll)
{
	unsigned buflen;
	uchar *pSrc;
	es_str_t *dst = NULL;
	DEFiRet;
	pSrc = *ppRes;
	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
	CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
	if(dst != NULL) {
		if(*pbMustBeFreed)
			free(*ppRes);
		*ppRes = (uchar*)es_str2cstr(dst, NULL);
		*pbMustBeFreed = 1;
		*pBufLen = -1;
		es_deleteStr(dst);
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
jsonField(const struct templateEntry *const pTpe,
	uchar **const ppRes,
	unsigned short *const pbMustBeFreed,
	int *const pBufLen,
	int escapeAll)
{
	unsigned buflen;
	uchar *pSrc;
	es_str_t *dst = NULL;
	int is_numeric = 1;
	DEFiRet;
	pSrc = *ppRes;
	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
dbgprintf("jsonEncode: datatype: %u, onEmpty: %u val %*s\n", (unsigned) pTpe-&gt;data.field.options.dataType,
(unsigned) pTpe-&gt;data.field.options.onEmpty, buflen, pSrc);
	if(buflen == 0) {
		if(pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_SKIP) {
			FINALIZE;
		}
		is_numeric = 0;
	}
	dst = es_newStr(buflen+pTpe-&gt;lenFieldName+15);
	es_addChar(&amp;dst, '"');
	es_addBuf(&amp;dst, (char*)pTpe-&gt;fieldName, pTpe-&gt;lenFieldName);
	es_addBufConstcstr(&amp;dst, "\":");
	if(buflen == 0 &amp;&amp; pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_NULL) {
		es_addBufConstcstr(&amp;dst, "null");
	} else {
		if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_AUTO) {
			for(unsigned i = 0 ; i &lt; buflen ; ++i) {
				if(pSrc[i] &lt; '0' || pSrc[i] &gt; '9') {
					is_numeric = 0;
					break;
				}
			}
			if(!is_numeric) {
				es_addChar(&amp;dst, '"');
			}
			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			if(!is_numeric) {
				es_addChar(&amp;dst, '"');
			}
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_STRING) {
			es_addChar(&amp;dst, '"');
			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			es_addChar(&amp;dst, '"');
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_NUMBER) {
			if(buflen == 0) {
				es_addChar(&amp;dst, '0');
			} else {
				CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			}
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_BOOL) {
			if(buflen == 1 &amp;&amp; *pSrc == '0') {
				es_addBufConstcstr(&amp;dst, "false");
			} else {
				es_addBufConstcstr(&amp;dst, "true");
			}
		}
	}
	if(*pbMustBeFreed)
		free(*ppRes);
	*pBufLen = es_strlen(dst);
	*ppRes = (uchar*)es_str2cstr(dst, NULL);
	*pbMustBeFreed = 1;
	es_deleteStr(dst);
finalize_it:
	RETiRet;
}
#define RET_OUT_OF_MEMORY { *pbMustBeFreed = 0;\
	*pPropLen = sizeof("**OUT OF MEMORY**") - 1; \
	return(UCHAR_CONSTANT("**OUT OF MEMORY**"));}
uchar *MsgGetProp(smsg_t *__restrict__ const pMsg, struct templateEntry *__restrict__ const pTpe,
			msgPropDescr_t *pProp, rs_size_t *__restrict__ const pPropLen,
			unsigned short *__restrict__ const pbMustBeFreed, struct syslogTime * const ttNow)
{
	uchar *pRes; 	rs_size_t bufLen = -1; 	uchar *pBufStart;
	uchar *pBuf;
	int iLen;
	short iOffs;
	enum tplFormatTypes datefmt;
	int bDateInUTC;
	assert(pMsg != NULL);
	assert(pbMustBeFreed != NULL);
#ifdef	FEATURE_REGEXP
	size_t nmatch = 10;
	regmatch_t pmatch[10];
#endif
	*pbMustBeFreed = 0;
	switch(pProp-&gt;id) {
		case PROP_MSG:
			pRes = getMSG(pMsg);
			bufLen = getMSGLen(pMsg);
			break;
		case PROP_TIMESTAMP:
			if(pTpe != NULL) {
				datefmt = pTpe-&gt;data.field.eDateFormat;
				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
			} else {
				datefmt = tplFmtDefault;
				bDateInUTC = 0;
			}
			if(bDateInUTC) {
				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tTIMESTAMP, datefmt, pbMustBeFreed);
			} else {
				pRes = (uchar*)getTimeReported(pMsg, datefmt);
			}
			break;
		case PROP_HOSTNAME:
			pRes = (uchar*)getHOSTNAME(pMsg);
			bufLen = getHOSTNAMELen(pMsg);
			break;
		case PROP_SYSLOGTAG:
			getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
			break;
		case PROP_RAWMSG:
			getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_RAWMSG_AFTER_PRI:
			getRawMsgAfterPRI(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_INPUTNAME:
			getInputName(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_FROMHOST:
			pRes = getRcvFrom(pMsg);
			break;
		case PROP_FROMHOST_IP:
			pRes = getRcvFromIP(pMsg);
			break;
		case PROP_PRI:
			pRes = (uchar*)getPRI(pMsg);
			break;
		case PROP_PRI_TEXT:
			pRes = textpri(pMsg);
			if(pRes == NULL)
				RET_OUT_OF_MEMORY;
			*pbMustBeFreed = 1;
			break;
		case PROP_IUT:
			pRes = UCHAR_CONSTANT("1"); 			bufLen = 1;
			break;
		case PROP_SYSLOGFACILITY:
			pRes = (uchar*)getFacility(pMsg);
			break;
		case PROP_SYSLOGFACILITY_TEXT:
			pRes = (uchar*)getFacilityStr(pMsg);
			break;
		case PROP_SYSLOGSEVERITY:
			pRes = (uchar*)getSeverity(pMsg);
			break;
		case PROP_SYSLOGSEVERITY_TEXT:
			pRes = (uchar*)getSeverityStr(pMsg);
			break;
		case PROP_TIMEGENERATED:
			if(pTpe != NULL) {
				datefmt = pTpe-&gt;data.field.eDateFormat;
				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
			} else {
				datefmt = tplFmtDefault;
				bDateInUTC = 0;
			}
			if(bDateInUTC) {
				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tRcvdAt, datefmt, pbMustBeFreed);
			} else {
				pRes = (uchar*)getTimeGenerated(pMsg, datefmt);
			}
			break;
		case PROP_PROGRAMNAME:
			pRes = getProgramName(pMsg, LOCK_MUTEX);
			break;
		case PROP_PROTOCOL_VERSION:
			pRes = (uchar*)getProtocolVersionString(pMsg);
			break;
		case PROP_STRUCTURED_DATA:
			MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_APP_NAME:
			pRes = (uchar*)getAPPNAME(pMsg, LOCK_MUTEX);
			break;
		case PROP_PROCID:
			pRes = (uchar*)getPROCID(pMsg, LOCK_MUTEX);
			break;
		case PROP_MSGID:
			pRes = (uchar*)getMSGID(pMsg);
			break;
		case PROP_JSONMESG:
			pRes = (uchar*)msgGetJSONMESG(pMsg);
			*pbMustBeFreed = 1;
			break;
#ifdef USE_LIBUUID
		case PROP_UUID:
			getUUID(pMsg, &amp;pRes, &amp;bufLen);
			break;
#endif
		case PROP_PARSESUCCESS:
			pRes = (uchar*)getParseSuccess(pMsg);
			break;
		case PROP_SYS_NOW:
			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 10;
			}
			break;
		case PROP_SYS_YEAR:
			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 4;
			}
			break;
		case PROP_SYS_MONTH:
			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_DAY:
			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HOUR:
			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HHOUR:
			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_QHOUR:
			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_MINUTE:
			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_NOW_UTC:
			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 10;
			}
			break;
		case PROP_SYS_YEAR_UTC:
			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 4;
			}
			break;
		case PROP_SYS_MONTH_UTC:
			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_DAY_UTC:
			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HOUR_UTC:
			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HHOUR_UTC:
			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_QHOUR_UTC:
			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_MINUTE_UTC:
			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_WDAY:
			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 1;
			}
			break;
		case PROP_SYS_WDAY_UTC:
			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 1;
			}
			break;
		case PROP_SYS_NOW_UXTIMESTAMP:
			if((pRes = malloc(16)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				snprintf((char*) pRes, 16-1, "%lld", (long long) getTime(NULL));
				pRes[16-1] = '\0';
				*pbMustBeFreed = 1;
				bufLen = -1;
			}
			break;
		case PROP_SYS_MYHOSTNAME:
			pRes = glbl.GetLocalHostName();
			break;
		case PROP_CEE_ALL_JSON:
		case PROP_CEE_ALL_JSON_PLAIN:
			if(pMsg-&gt;json == NULL) {
				pRes = (uchar*) "{}";
				bufLen = 2;
				*pbMustBeFreed = 0;
			} else {
				const char *jstr;
				MsgLock(pMsg);
				int jflag = 0;
				if(pProp-&gt;id == PROP_CEE_ALL_JSON) {
					jflag = JSON_C_TO_STRING_SPACED;
				} else if(pProp-&gt;id == PROP_CEE_ALL_JSON_PLAIN) {
					jflag = JSON_C_TO_STRING_PLAIN;
				}
				jstr = json_object_to_json_string_ext(pMsg-&gt;json, jflag);
				MsgUnlock(pMsg);
				if(jstr == NULL) {
					RET_OUT_OF_MEMORY;
				}
				pRes = (uchar*)strdup(jstr);
				if(pRes == NULL) {
					RET_OUT_OF_MEMORY;
				}
				*pbMustBeFreed = 1;
			}
			break;
		case PROP_CEE:
		case PROP_LOCAL_VAR:
		case PROP_GLOBAL_VAR:
			getJSONPropVal(pMsg, pProp, &amp;pRes, &amp;bufLen, pbMustBeFreed);
			break;
		case PROP_SYS_BOM:
			pRes = (uchar*) "\xEF\xBB\xBF";
			*pbMustBeFreed = 0;
			break;
		case PROP_SYS_UPTIME:
#			ifndef HAVE_SYSINFO_UPTIME
			pRes = (uchar*) "UPTIME NOT available on this system";
			*pbMustBeFreed = 0;
#			elif defined(__FreeBSD__)
			{
			struct timespec tp;
			if((pRes = (uchar*) malloc(32)) == NULL) {
				RET_OUT_OF_MEMORY;
			}
			if(clock_gettime(CLOCK_UPTIME, &amp;tp) == -1) {
				free(pRes);
				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
			}
			*pbMustBeFreed = 1;
			snprintf((char*) pRes, 32, "%ld", tp.tv_sec);
			}
#			else
			{
			struct sysinfo s_info;
			if((pRes = (uchar*) malloc(32)) == NULL) {
				RET_OUT_OF_MEMORY;
			}
			if(sysinfo(&amp;s_info) &lt; 0) {
				free(pRes);
				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
			}
			*pbMustBeFreed = 1;
			snprintf((char*) pRes, 32, "%ld", s_info.uptime);
			}
#			endif
		break;
		default:
			dbgprintf("invalid property id: '%d'\n", pProp-&gt;id);
			*pbMustBeFreed = 0;
			*pPropLen = sizeof("**INVALID PROPERTY NAME**") - 1;
			return UCHAR_CONSTANT("**INVALID PROPERTY NAME**");
	}
	if(pTpe == NULL || !pTpe-&gt;bComplexProcessing) {
		*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;
		return pRes;
	}
	if(pTpe-&gt;data.field.has_fields == 1) {
		size_t iCurrFld;
		uchar *pFld;
		uchar *pFldEnd;
		iCurrFld = 1;
		pFld = pRes;
		while(*pFld &amp;&amp; iCurrFld &lt; pTpe-&gt;data.field.iFieldNr) {
			while(*pFld &amp;&amp; (uchar) *pFld != pTpe-&gt;data.field.field_delim)
				++pFld; 			if(*pFld == pTpe-&gt;data.field.field_delim) {
				++pFld; #ifdef STRICT_GPLV3
				if (pTpe-&gt;data.field.field_expand != 0) {
					while (*pFld == pTpe-&gt;data.field.field_delim) {
						++pFld;
					}
				}
#endif
				++iCurrFld;
			}
		}
		dbgprintf("field requested %d, field found %d\n", pTpe-&gt;data.field.iFieldNr, (int) iCurrFld);
		if(iCurrFld == pTpe-&gt;data.field.iFieldNr) {
			pFldEnd = pFld;
			while(*pFldEnd &amp;&amp; *pFldEnd != pTpe-&gt;data.field.field_delim)
				++pFldEnd;
			iLen = pFldEnd - pFld + 1; 			pBufStart = pBuf = malloc(iLen + 1);
			if(pBuf == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			memcpy(pBuf, pFld, iLen);
			bufLen = iLen;
			pBuf[iLen] = '\0'; 			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBufStart;
			*pbMustBeFreed = 1;
		} else {
			if(*pbMustBeFreed == 1)
				free(pRes);
			*pbMustBeFreed = 0;
			*pPropLen = sizeof("**FIELD NOT FOUND**") - 1;
			return UCHAR_CONSTANT("**FIELD NOT FOUND**");
		}
#ifdef FEATURE_REGEXP
	} else {
		if (pTpe-&gt;data.field.has_regex != 0) {
			if (pTpe-&gt;data.field.has_regex == 2) {
				if (*pbMustBeFreed == 1) {
					free(pRes);
					*pbMustBeFreed = 0;
				}
				*pPropLen = sizeof("**NO MATCH** **BAD REGULAR EXPRESSION**") - 1;
				return UCHAR_CONSTANT("**NO MATCH** **BAD REGULAR EXPRESSION**");
			}
			dbgprintf("string to match for regex is: %s\n", pRes);
			if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
				short iTry = 0;
				uchar bFound = 0;
				iOffs = 0;
				while(!bFound) {
					int iREstat;
					iREstat = regexp.regexec(&amp;pTpe-&gt;data.field.re, (char*)(pRes + iOffs),
								nmatch, pmatch, 0);
					dbgprintf("regexec return is %d\n", iREstat);
					if(iREstat == 0) {
						if(pmatch[0].rm_so == -1) {
							dbgprintf("oops ... start offset of successful "
								"regexec is -1\n");
							break;
						}
						if(iTry == pTpe-&gt;data.field.iMatchToUse) {
							bFound = 1;
						} else {
							dbgprintf("regex found at offset %d, new offset %d, "
								"tries %d\n", iOffs,
								(int) (iOffs + pmatch[0].rm_eo), iTry);
							iOffs += pmatch[0].rm_eo;
							++iTry;
						}
					} else {
						break;
					}
				}
				dbgprintf("regex: end search, found %d\n", bFound);
				if(!bFound) {
					if(pTpe-&gt;data.field.nomatchAction != TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
						if (*pbMustBeFreed == 1) {
							free(pRes);
							*pbMustBeFreed = 0;
						}
						if(pTpe-&gt;data.field.nomatchAction == TPL_REGEX_NOMATCH_USE_DFLTSTR) {
							bufLen = sizeof("**NO MATCH**") - 1;
							pRes = UCHAR_CONSTANT("**NO MATCH**");
						} else if(pTpe-&gt;data.field.nomatchAction ==
						TPL_REGEX_NOMATCH_USE_ZERO) {
							bufLen = 1;
							pRes = UCHAR_CONSTANT("0");
						} else {
							bufLen = 0;
							pRes = UCHAR_CONSTANT("");
						}
					}
				} else {
					if(pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so == -1) {
						if(pTpe-&gt;data.field.nomatchAction !=
						TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
							if (*pbMustBeFreed == 1) {
								free(pRes);
								*pbMustBeFreed = 0;
							}
							if(pTpe-&gt;data.field.nomatchAction ==
							TPL_REGEX_NOMATCH_USE_DFLTSTR) {
								bufLen = sizeof("**NO MATCH**") - 1;
								pRes = UCHAR_CONSTANT("**NO MATCH**");
							} else if(pTpe-&gt;data.field.nomatchAction ==
								TPL_REGEX_NOMATCH_USE_ZERO) {
								bufLen = 1;
								pRes = UCHAR_CONSTANT("0");
							} else {
								bufLen = 0;
								pRes = UCHAR_CONSTANT("");
							}
						}
					}
					int iLenBuf;
					uchar *pB;
					iLenBuf = pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_eo
						  - pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so;
					pB = malloc(iLenBuf + 1);
					if (pB == NULL) {
						if (*pbMustBeFreed == 1)
							free(pRes);
						RET_OUT_OF_MEMORY;
					}
					memcpy(pB, pRes + iOffs +  pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so,
						iLenBuf);
					bufLen = iLenBuf;
					pB[iLenBuf] = '\0';
					if (*pbMustBeFreed == 1)
						free(pRes);
					pRes = pB;
					*pbMustBeFreed = 1;
				}
			} else {
				dbgprintf("could not get regexp object pointer, so regexp can not be evaluated\n");
				if (*pbMustBeFreed == 1) {
					free(pRes);
					*pbMustBeFreed = 0;
				}
				*pPropLen = sizeof("***REGEXP NOT AVAILABLE***") - 1;
				return UCHAR_CONSTANT("***REGEXP NOT AVAILABLE***");
			}
		}
#endif 	}
	if(pTpe-&gt;data.field.iFromPos != 0 || pTpe-&gt;data.field.iToPos != 0) {
		int iFrom, iTo;
		uchar *pSb;
		iFrom = pTpe-&gt;data.field.iFromPos;
		iTo = pTpe-&gt;data.field.iToPos;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		if(pTpe-&gt;data.field.options.bFromPosEndRelative) {
			iFrom = (bufLen &lt; iFrom) ? 0 : bufLen - iFrom;
			iTo = (bufLen &lt; iTo)? 0 : bufLen - iTo;
		} else {
			if(iFrom &gt; 0)
				--iFrom;
			if(iTo &gt; 0)
				--iTo;
		}
		if(iFrom &gt;= bufLen) {
			DBGPRINTF("msgGetProp: iFrom %d &gt;= buflen %d, returning empty string\n",
				iFrom, bufLen);
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = (uchar*) "";
			*pbMustBeFreed = 0;
			bufLen = 0;
		} else if(iFrom == 0 &amp;&amp; iTo &gt;= bufLen &amp;&amp; pTpe-&gt;data.field.options.bFixedWidth == 0) {
		} else {
			if(iTo &gt;= bufLen)  				if (pTpe-&gt;data.field.options.bFixedWidth == 0)
					iTo = bufLen - 1;
			iLen = iTo - iFrom + 1; 			pBufStart = pBuf = malloc(iLen + 1);
			if(pBuf == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			pSb = pRes;
			if(iFrom) {
				while(*pSb &amp;&amp; iFrom) {
					--iFrom;
					++pSb;
				}
			}
			bufLen = iLen;
			while(iLen) {
				if (*pSb) {
					*pBuf++ = *pSb;
					++pSb;
				} else {
					*pBuf++ = ' ';
				}
				--iLen;
			}
			*pBuf = '\0';
			bufLen -= iLen; 			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBufStart;
			*pbMustBeFreed = 1;
		}
	}
	if(*pRes &amp;&amp; pTpe-&gt;data.field.options.bSPIffNo1stSP) {
		uchar cFirst = *pRes; 		if(*pbMustBeFreed == 1)
			free(pRes);
		pRes = (cFirst == ' ') ? UCHAR_CONSTANT("") : UCHAR_CONSTANT(" ");
		bufLen = (cFirst == ' ') ? 0 : 1;
		*pbMustBeFreed = 0;
	}
	if(*pRes) {
		if(pTpe-&gt;data.field.eCaseConv != tplCaseConvNo) {
			if(bufLen == -1)
				bufLen = ustrlen(pRes);
			uchar *pBStart;
			uchar *pB;
			uchar *pSrc;
			pBStart = pB = malloc(bufLen + 1);
			if(pB == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			pSrc = pRes;
			while(*pSrc) {
				*pB++ = (pTpe-&gt;data.field.eCaseConv == tplCaseConvUpper) ?
					(uchar)toupper((int)*pSrc) : (uchar)tolower((int)*pSrc);
				++pSrc;
			}
			*pB = '\0';
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBStart;
			*pbMustBeFreed = 1;
		}
		if(pTpe-&gt;data.field.options.bDropCC) {
			int iLenBuf = 0;
			uchar *pSrc = pRes;
			uchar *pDstStart;
			uchar *pDst;
			uchar bDropped = 0;
			while(*pSrc) {
				if(!iscntrl((int) *pSrc++))
					iLenBuf++;
				else
					bDropped = 1;
			}
			if(bDropped) {
				pDst = pDstStart = malloc(iLenBuf + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(!iscntrl((int) *pSrc))
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pDstStart;
				bufLen = iLenBuf;
				*pbMustBeFreed = 1;
			}
		} else if(pTpe-&gt;data.field.options.bSpaceCC) {
			uchar *pSrc;
			uchar *pDstStart;
			uchar *pDst;
			if(*pbMustBeFreed == 1) {
				for(pDst = pRes; *pDst; pDst++) {
					if(iscntrl((int) *pDst))
						*pDst = ' ';
				}
			} else {
				if(bufLen == -1)
					bufLen = ustrlen(pRes);
				pDst = pDstStart = malloc(bufLen + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(iscntrl((int) *pSrc))
						*pDst++ = ' ';
					else
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				pRes = pDstStart;
				*pbMustBeFreed = 1;
			}
		} else if(pTpe-&gt;data.field.options.bEscapeCC) {
			int iNumCC = 0;
			int iLenBuf = 0;
			uchar *pSrc;
			uchar *pB;
			for(pB = pRes ; *pB ; ++pB) {
				++iLenBuf;
				if(iscntrl((int) *pB))
					++iNumCC;
			}
			if(iNumCC &gt; 0) { 				uchar *pBStart;
				uchar szCCEsc[8]; 				int i;
				iLenBuf += iNumCC * 4;
				pBStart = pB = malloc(iLenBuf + 1);
				if(pB == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(iscntrl((int) *pSrc)) {
						snprintf((char*)szCCEsc, sizeof(szCCEsc), "#%3.3d", *pSrc);
						for(i = 0 ; i &lt; 4 ; ++i)
							*pB++ = szCCEsc[i];
					} else {
						*pB++ = *pSrc;
					}
				}
				*pB = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pBStart;
				bufLen = -1;
				*pbMustBeFreed = 1;
			}
		}
	}
	if(pTpe-&gt;data.field.options.bSecPathDrop || pTpe-&gt;data.field.options.bSecPathReplace) {
		if(pTpe-&gt;data.field.options.bSecPathDrop) {
			int iLenBuf = 0;
			uchar *pSrc = pRes;
			uchar *pDstStart;
			uchar *pDst;
			uchar bDropped = 0;
			while(*pSrc) {
				if(*pSrc++ != '/')
					iLenBuf++;
				else
					bDropped = 1;
			}
			if(bDropped) {
				pDst = pDstStart = malloc(iLenBuf + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(*pSrc != '/')
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pDstStart;
				bufLen = -1; 				*pbMustBeFreed = 1;
			}
		} else {
			uchar *pSrc;
			uchar *pDstStart;
			uchar *pDst;
			if(*pbMustBeFreed == 1) {
				for(pDst = pRes; *pDst; pDst++) {
					if(*pDst == '/')
						*pDst++ = '_';
				}
			} else {
				if(bufLen == -1)
					bufLen = ustrlen(pRes);
				pDst = pDstStart = malloc(bufLen + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(*pSrc == '/')
						*pDst++ = '_';
					else
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				pRes = pDstStart;
				*pbMustBeFreed = 1;
			}
		}
		if(*pRes == '\0') {
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = UCHAR_CONSTANT("_");
			bufLen = 1;
			*pbMustBeFreed = 0;
		} else if((*pRes == '.') &amp;&amp; (*(pRes + 1) == '\0' || (*(pRes + 1) == '.' &amp;&amp; *(pRes + 2) == '\0'))) {
			uchar *pTmp = pRes;
			if(*(pRes + 1) == '\0')
				pRes = UCHAR_CONSTANT("_");
			else
				pRes = UCHAR_CONSTANT("_.");;
			if(*pbMustBeFreed == 1)
				free(pTmp);
			*pbMustBeFreed = 0;
		}
	}
	if(pTpe-&gt;data.field.options.bDropLastLF &amp;&amp; !pTpe-&gt;data.field.options.bEscapeCC) {
		int iLn;
		uchar *pB;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		iLn = bufLen;
		if(iLn &gt; 0 &amp;&amp; *(pRes + iLn - 1) == '\n') {
			if(*pbMustBeFreed == 0) {
				pB = malloc(iLn + 1);
				if(pB == NULL) {
					RET_OUT_OF_MEMORY;
				}
				memcpy(pB, pRes, iLn - 1);
				pRes = pB;
				*pbMustBeFreed = 1;
			}
			*(pRes + iLn - 1) = '\0'; 			--bufLen;
		}
	}
	if(pTpe-&gt;data.field.options.bCompressSP) {
		int needCompress = 0;
		int hadSP = 0;
		uchar *pB;
		if(*pbMustBeFreed == 0) {
			for(pB = pRes ; *pB &amp;&amp; needCompress == 0 ; ++pB) {
				if(*pB == ' ') {
					if(hadSP) {
						uchar *const tmp = ustrdup(pRes);
						if(tmp == NULL)
							break;
						*pbMustBeFreed = 1;
						pRes = tmp;
						needCompress = 1;
					} else {
						hadSP = 1;
					}
				}
			}
		} else {
			needCompress = 1;
		}
		if(needCompress) {
			hadSP = 0;
			uchar *pDst = pRes;
			int needCopy = 0;
			for(pB = pRes ; *pB ; ++pB) {
				if(*pB == ' ') {
					if(hadSP) {
						needCopy = 1;
					}  else {
						hadSP = 1;
						if(needCopy)
							*pDst = *pB;
						++pDst;
					}
				} else {
					hadSP = 0;
					if(needCopy)
						*pDst = *pB;
					++pDst;
				}
			}
			*pDst = '\0';
			bufLen = pDst - pRes;
		}
	}
	if(pTpe-&gt;data.field.options.bCSV) {
		int iBufLen;
		uchar *pBStart;
		uchar *pDst;
		uchar *pSrc;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		iBufLen = bufLen;
		pBStart = pDst = malloc(2 * iBufLen + 3);
		if(pDst == NULL) {
			if(*pbMustBeFreed == 1)
				free(pRes);
			RET_OUT_OF_MEMORY;
		}
		pSrc = pRes;
		*pDst++ = '"'; 		while(*pSrc) {
			if(*pSrc == '"')
				*pDst++ = '"'; 			*pDst++ = *pSrc++;
		}
		*pDst++ = '"';			*pDst = '\0';
		if(*pbMustBeFreed == 1)
			free(pRes);
		pRes = pBStart;
		bufLen = -1;
		*pbMustBeFreed = 1;
	} else if(pTpe-&gt;data.field.options.bJSON) {
		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
	} else if(pTpe-&gt;data.field.options.bJSONf) {
		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
	} else if(pTpe-&gt;data.field.options.bJSONr) {
		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
	} else if(pTpe-&gt;data.field.options.bJSONfr) {
		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
	}
	*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;
	return(pRes);
}
static rsRetVal
msgSetPropViaJSON(smsg_t *__restrict__ const pMsg, const char *name, struct json_object *json, int sharedReference)
{
	const char *psz;
	int val;
	prop_t *propFromHost = NULL;
	prop_t *propRcvFromIP = NULL;
	int bNeedFree = 1;
	DEFiRet;
	dbgprintf("DDDD: msgSetPropViaJSON key: '%s'\n", name);
	if(!strcmp(name, "rawmsg")) {
		psz = json_object_get_string(json);
		MsgSetRawMsg(pMsg, psz, strlen(psz));
	} else if(!strcmp(name, "msg")) {
		psz = json_object_get_string(json);
		MsgReplaceMSG(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, "syslogtag")) {
		psz = json_object_get_string(json);
		MsgSetTAG(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, "pri")) {
		val = json_object_get_int(json);
		msgSetPRI(pMsg, val);
	} else if(!strcmp(name, "syslogfacility")) {
		val = json_object_get_int(json);
		if(val &gt;= 0 &amp;&amp; val &lt;= 24)
			pMsg-&gt;iFacility = val;
		else
			DBGPRINTF("mmexternal: invalid fac %d requested -- ignored\n", val);
	} else if(!strcmp(name, "syslogseverity")) {
		val = json_object_get_int(json);
		if(val &gt;= 0 &amp;&amp; val &lt;= 7)
			pMsg-&gt;iSeverity = val;
		else
			DBGPRINTF("mmexternal: invalid fac %d requested -- ignored\n", val);
	} else if(!strcmp(name, "procid")) {
		psz = json_object_get_string(json);
		MsgSetPROCID(pMsg, psz);
	} else if(!strcmp(name, "msgid")) {
		psz = json_object_get_string(json);
		MsgSetMSGID(pMsg, psz);
	} else if(!strcmp(name, "structured-data")) {
		psz = json_object_get_string(json);
		MsgSetStructuredData(pMsg, psz);
	} else if(!strcmp(name, "hostname") || !strcmp(name, "source")) {
		psz = json_object_get_string(json);
		MsgSetHOSTNAME(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, "fromhost")) {
		psz = json_object_get_string(json);
		MsgSetRcvFromStr(pMsg, (const uchar*) psz, strlen(psz), &amp;propFromHost);
		prop.Destruct(&amp;propFromHost);
	} else if(!strcmp(name, "fromhost-ip")) {
		psz = json_object_get_string(json);
		MsgSetRcvFromIPStr(pMsg, (const uchar*)psz, strlen(psz), &amp;propRcvFromIP);
		prop.Destruct(&amp;propRcvFromIP);
	} else if(!strcmp(name, "$!")) {
		bNeedFree = 0;
		msgAddJSON(pMsg, (uchar*)"!", json, 0, sharedReference);
	} else {
		DBGPRINTF("msgSetPropViaJSON: unkonwn property ignored: %s\n",
			  name);
	}
	if(bNeedFree) {
		json_object_put(json);
	}
	RETiRet;
}
rsRetVal
MsgSetPropsViaJSON(smsg_t *__restrict__ const pMsg, const uchar *__restrict__ const jsonstr)
{
	struct json_tokener *tokener = NULL;
	struct json_object *json;
	const char *errMsg;
	DEFiRet;
	DBGPRINTF("DDDDDD: JSON string for message mod: '%s'\n", jsonstr);
	if(!strcmp((char*)jsonstr, "{}")) 		FINALIZE;
	tokener = json_tokener_new();
	json = json_tokener_parse_ex(tokener, (char*)jsonstr, ustrlen(jsonstr));
	if(Debug) {
		errMsg = NULL;
		if(json == NULL) {
			enum json_tokener_error err;
			err = tokener-&gt;err;
			if(err != json_tokener_continue)
				errMsg = json_tokener_error_desc(err);
			else
				errMsg = "Unterminated input";
		} else if(!json_object_is_type(json, json_type_object))
			errMsg = "JSON value is not an object";
		if(errMsg != NULL) {
			DBGPRINTF("MsgSetPropsViaJSON: Error parsing JSON '%s': %s\n",
					jsonstr, errMsg);
		}
	}
	if(json == NULL || !json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
	}
	MsgSetPropsViaJSON_Object(pMsg, json);
finalize_it:
	if(tokener != NULL)
		json_tokener_free(tokener);
	RETiRet;
}
rsRetVal
MsgSetPropsViaJSON_Object(smsg_t *__restrict__ const pMsg, struct json_object *json)
{
	DEFiRet;
	if(json == NULL || !json_object_is_type(json, json_type_object)) {
		DBGPRINTF("MsgSetPropsViaJSON_Object: json NULL or not object type\n");
		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
	}
	struct json_object_iterator it = json_object_iter_begin(json);
	struct json_object_iterator itEnd = json_object_iter_end(json);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		struct json_object *child = json_object_iter_peek_value(&amp;it);
		json_object_get(child);
		msgSetPropViaJSON(pMsg, json_object_iter_peek_name(&amp;it),
			child, 0);
		json_object_iter_next(&amp;it);
	}
	json_object_put(json);
finalize_it:
	RETiRet;
}
rsRetVal
MsgGetSeverity(smsg_t * const pMsg, int *piSeverity)
{
	*piSeverity = pMsg-&gt;iSeverity;
	return RS_RET_OK;
}
static uchar *
jsonPathGetLeaf(uchar *name, int lenName)
{
	int i;
	for(i = lenName ; i &gt;= 0 ; --i)
		if(i == 0) {
			if(name[0] == '!'  || name[0] == '.' || name[0] == '/')
				break;
		} else {
			if(name[i] == '!')
				break;
		}
	if(name[i] == '!' || name[i] == '.' || name[i] == '/')
		++i;
	return name + i;
}
static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value) {
	char namebuf[MAX_VARIABLE_NAME_LEN];
	int key_len = strlen(key);
	char *array_idx_start = strstr(key, "[");
	char *array_idx_end = NULL;
	char *array_idx_num_end_discovered = NULL;
	struct json_object *arr = NULL;
	if (array_idx_start != NULL) {
		array_idx_end = strstr(array_idx_start, "]");
	}
	if (array_idx_end != NULL &amp;&amp; (array_idx_end - key + 1) == key_len) {
		errno = 0;
		int idx = (int) strtol(array_idx_start + 1, &amp;array_idx_num_end_discovered, 10);
		if (errno == 0 &amp;&amp; array_idx_num_end_discovered == array_idx_end) {
			memcpy(namebuf, key, array_idx_start - key);
			namebuf[array_idx_start - key] = '\0';
			json_bool found_obj = json_object_object_get_ex(root, namebuf, &amp;arr);
			if (found_obj &amp;&amp; json_object_is_type(arr, json_type_array)) {
				int len = json_object_array_length(arr);
				if (len &gt; idx) {
					*value = json_object_array_get_idx(arr, idx);
					if (*value != NULL) return TRUE;
				}
				return FALSE;
			}
		}
	}
	return json_object_object_get_ex(root, key, value);
}
static rsRetVal
jsonPathFindNext(struct json_object *root, uchar *namestart, uchar **name, uchar *leaf,
		 struct json_object **found, int bCreate)
{
	uchar namebuf[MAX_VARIABLE_NAME_LEN];
	struct json_object *json;
	size_t i;
	uchar *p = *name;
	DEFiRet;
	if(*p == '!' || (*name == namestart &amp;&amp; (*p == '.' || *p == '/')))
		++p;
	for(i = 0 ; *p &amp;&amp; !(p == namestart &amp;&amp; (*p == '.' || *p == '/')) &amp;&amp; *p != '!'
		&amp;&amp; p != leaf &amp;&amp; i &lt; sizeof(namebuf)-1 ; ++i, ++p)
		namebuf[i] = *p;
	if(i &gt; 0) {
		namebuf[i] = '\0';
		if(jsonVarExtract(root, (char*)namebuf, &amp;json) == FALSE) {
			json = NULL;
		}
	} else
		json = root;
	if(json == NULL) {
		if(!bCreate) {
			ABORT_FINALIZE(RS_RET_JNAME_INVALID);
		} else {
			if (json_object_get_type(root) != json_type_object) {
				DBGPRINTF("jsonPathFindNext with bCreate: not a container in json path, "
					"name is '%s'\n", namestart);
				ABORT_FINALIZE(RS_RET_INVLD_SETOP);
			}
			json = json_object_new_object();
			json_object_object_add(root, (char*)namebuf, json);
		}
	}
	*name = p;
	*found = json;
finalize_it:
	RETiRet;
}
static rsRetVal
jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf, struct json_object **parent,
	const int bCreate)
{
	uchar *namestart;
	DEFiRet;
	namestart = name;
	*parent = jroot;
	while(name &lt; leaf-1) {
		CHKiRet(jsonPathFindNext(*parent, namestart, &amp;name, leaf, parent, bCreate));
	}
	if(*parent == NULL)
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
finalize_it:
	RETiRet;
}
static rsRetVal
jsonMerge(struct json_object *existing, struct json_object *json)
{
	DEFiRet;
	struct json_object_iterator it = json_object_iter_begin(json);
	struct json_object_iterator itEnd = json_object_iter_end(json);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		json_object_object_add(existing, json_object_iter_peek_name(&amp;it),
			json_object_get(json_object_iter_peek_value(&amp;it)));
		json_object_iter_next(&amp;it);
	}
	json_object_put(json);
	RETiRet;
}
rsRetVal
jsonFind(smsg_t *const pMsg, msgPropDescr_t *pProp, struct json_object **jsonres)
{
	uchar *leaf;
	struct json_object *parent;
	struct json_object *field;
	struct json_object **jroot = NULL;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(*jroot == NULL) {
		field = NULL;
		goto finalize_it;
	}
	if(!strcmp((char*)pProp-&gt;name, "!")) {
		field = *jroot;
	} else if(!strcmp((char*)pProp-&gt;name, ".")) {
		field = *jroot;
	} else {
		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
			field = NULL;
	}
	*jsonres = field;
finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}
rsRetVal ATTR_NONNULL()
msgCheckVarExists(smsg_t *const pMsg, msgPropDescr_t *pProp)
{
	struct json_object *jsonres = NULL;
	DEFiRet;
	CHKiRet(jsonFind(pMsg, pProp, &amp;jsonres));
	if(jsonres == NULL) {
		iRet = RS_RET_NOT_FOUND;
	}
finalize_it:
	RETiRet;
}
rsRetVal
msgAddJSON(smsg_t * const pM, uchar *name, struct json_object *json, int force_reset, int sharedReference)
{
	struct json_object **jroot;
	struct json_object *parent, *leafnode;
	struct json_object *given = NULL;
	uchar *leaf;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(name[0] == '/') { 		if (sharedReference) {
			given = json;
			json = jsonDeepCopy(json);
			json_object_put(given);
		}
	}
	if(name[1] == '\0') { 		if(*jroot == NULL)
			*jroot = json;
		else
			CHKiRet(jsonMerge(*jroot, json));
	} else {
		if(*jroot == NULL) {
			*jroot = json_object_new_object();
		}
		leaf = jsonPathGetLeaf(name, ustrlen(name));
		iRet = jsonPathFindParent(*jroot, name, leaf, &amp;parent, 1);
		if (unlikely(iRet != RS_RET_OK)) {
			json_object_put(json);
			FINALIZE;
		}
		if (json_object_get_type(parent) != json_type_object) {
			DBGPRINTF("msgAddJSON: not a container in json path,"
				"name is '%s'\n", name);
			json_object_put(json);
			ABORT_FINALIZE(RS_RET_INVLD_SETOP);
		}
		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
			leafnode = NULL;
		if (force_reset || (leafnode == NULL)) {
			json_object_object_add(parent, (char*)leaf, json);
		} else {
			if(json_object_get_type(json) == json_type_object) {
				CHKiRet(jsonMerge(*jroot, json));
			} else {
				if(json_object_get_type(leafnode) == json_type_object) {
					DBGPRINTF("msgAddJSON: trying to update a container "
							  "node with a leaf, name is %s - "
							  "forbidden", name);
					json_object_put(json);
					ABORT_FINALIZE(RS_RET_INVLD_SETOP);
				}
				json_object_object_add(parent, (char*)leaf, json);
			}
		}
	}
finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}
rsRetVal
msgDelJSON(smsg_t * const pM, uchar *name)
{
	struct json_object **jroot;
	struct json_object *parent, *leafnode;
	uchar *leaf;
	pthread_mutex_t *mut = NULL;
	DEFiRet;
	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(*jroot == NULL) {
		DBGPRINTF("msgDelJSONVar; jroot empty in unset for property %s\n",
			  name);
		FINALIZE;
	}
	if(name[1] == '\0') {
		DBGPRINTF("unsetting JSON root object\n");
		json_object_put(*jroot);
		*jroot = NULL;
	} else {
		leaf = jsonPathGetLeaf(name, ustrlen(name));
		CHKiRet(jsonPathFindParent(*jroot, name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
			leafnode = NULL;
		if(leafnode == NULL) {
			DBGPRINTF("unset JSON: could not find '%s'\n", name);
			ABORT_FINALIZE(RS_RET_JNAME_NOTFOUND);
		} else {
			DBGPRINTF("deleting JSON value path '%s', "
				  "leaf '%s', type %d\n",
				  name, leaf, json_object_get_type(leafnode));
			json_object_object_del(parent, (char*)leaf);
		}
	}
finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}
rsRetVal
msgAddMetadata(smsg_t *const __restrict__ pMsg,
	       uchar *const __restrict__ metaname,
	       uchar *const __restrict__ metaval)
{
	DEFiRet;
	struct json_object *const json = json_object_new_object();
	CHKmalloc(json);
	struct json_object *const jval = json_object_new_string((char*)metaval);
	if(jval == NULL) {
		json_object_put(json);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	json_object_object_add(json, (const char *const)metaname, jval);
	iRet = msgAddJSON(pMsg, (uchar*)"!metadata", json, 0, 0);
finalize_it:
	RETiRet;
}
rsRetVal
msgAddMultiMetadata(smsg_t *const __restrict__ pMsg,
	       const uchar ** __restrict__ metaname,
	       const uchar ** __restrict__ metaval,
	       const int count)
{
	DEFiRet;
	int i = 0 ;
	struct json_object *const json = json_object_new_object();
	CHKmalloc(json);
	for ( i = 0 ; i &lt; count ; i++ ) {
		struct json_object *const jval = json_object_new_string((char*)metaval[i]);
		if(jval == NULL) {
			json_object_put(json);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		json_object_object_add(json, (const char *const)metaname[i], jval);
	}
	iRet = msgAddJSON(pMsg, (uchar*)"!metadata", json, 0, 0);
finalize_it:
	RETiRet;
}
struct json_object *
jsonDeepCopy(struct json_object *src)
{
	struct json_object *dst = NULL, *json;
	int arrayLen, i;
	if(src == NULL) goto done;
	switch(json_object_get_type(src)) {
	case json_type_boolean:
		dst = json_object_new_boolean(json_object_get_boolean(src));
		break;
	case json_type_double:
		dst = json_object_new_double(json_object_get_double(src));
		break;
	case json_type_int:
		dst = json_object_new_int64(json_object_get_int64(src));
		break;
	case json_type_string:
		dst = json_object_new_string(json_object_get_string(src));
		break;
	case json_type_object:
		dst = json_object_new_object();
		struct json_object_iterator it = json_object_iter_begin(src);
		struct json_object_iterator itEnd = json_object_iter_end(src);
		while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
			json = jsonDeepCopy(json_object_iter_peek_value(&amp;it));
			json_object_object_add(dst, json_object_iter_peek_name(&amp;it), json);
			json_object_iter_next(&amp;it);
		}
		break;
	case json_type_array:
		arrayLen = json_object_array_length(src);
		dst = json_object_new_array();
		for(i = 0 ; i &lt; arrayLen ; ++i) {
			json = json_object_array_get_idx(src, i);
			json = jsonDeepCopy(json);
			json_object_array_add(dst, json);
		}
		break;
	case json_type_null:
	default:DBGPRINTF("jsonDeepCopy(): error unknown type %d\n",
			 json_object_get_type(src));
		dst = NULL;
		break;
	}
done:	return dst;
}
rsRetVal
msgSetJSONFromVar(smsg_t * const pMsg, uchar *varname, struct svar *v, int force_reset)
{
	struct json_object *json = NULL;
	char *cstr;
	DEFiRet;
	switch(v-&gt;datatype) {
	case 'S':		cstr = es_str2cstr(v-&gt;d.estr, NULL);
		json = json_object_new_string(cstr);
		free(cstr);
		break;
	case 'N':		json = json_object_new_int64(v-&gt;d.n);
		break;
	case 'J':		json = jsonDeepCopy(v-&gt;d.json);
		break;
	default:DBGPRINTF("msgSetJSONFromVar: unsupported datatype %c\n",
		v-&gt;datatype);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	msgAddJSON(pMsg, varname, json, force_reset, 0);
finalize_it:
	RETiRet;
}
rsRetVal
MsgAddToStructuredData(smsg_t * const pMsg, uchar *toadd, rs_size_t len)
{
	uchar *newptr;
	rs_size_t newlen;
	int empty;
	DEFiRet;
	empty = pMsg-&gt;pszStrucData == NULL || pMsg-&gt;pszStrucData[0] == '-';
	newlen = (empty) ? len : pMsg-&gt;lenStrucData + len;
	CHKmalloc(newptr = (uchar*) realloc(pMsg-&gt;pszStrucData, newlen+1));
	if(empty) {
		memcpy(newptr, toadd, len);
	} else {
		memcpy(newptr+pMsg-&gt;lenStrucData, toadd, len);
	}
	pMsg-&gt;pszStrucData = newptr;
	pMsg-&gt;pszStrucData[newlen] = '\0';
	pMsg-&gt;lenStrucData = newlen;
finalize_it:
	RETiRet;
}
rsRetVal
msgPropDescrFill(msgPropDescr_t *pProp, uchar *name, int nameLen)
{
	propid_t id;
	int offs;
	DEFiRet;
	if(propNameToID(name, &amp;id) != RS_RET_OK) {
		parser_errmsg("invalid property '%s'", name);
		if(!strcasecmp((char*)name, "myhostname"))
			parser_errmsg("did you mean '$myhostname' instead of '%s'? "
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "bom"))
			parser_errmsg("did you mean '$bom' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "now"))
			parser_errmsg("did you mean '$now' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "year"))
			parser_errmsg("did you mean '$year' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "month"))
			parser_errmsg("did you mean '$month' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "day"))
			parser_errmsg("did you mean '$day' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "hour"))
			parser_errmsg("did you mean '$hour' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "hhour"))
			parser_errmsg("did you mean '$hhour' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "qhour"))
			parser_errmsg("did you mean '$qhour' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "minute"))
			parser_errmsg("did you mean '$minute' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "now-utc"))
			parser_errmsg("did you mean '$now-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "year-utc"))
			parser_errmsg("did you mean '$year-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "month-utc"))
			parser_errmsg("did you mean '$month-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "day-utc"))
			parser_errmsg("did you mean '$day-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "hour-utc"))
			parser_errmsg("did you mean '$hour-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "hhour-utc"))
			parser_errmsg("did you mean '$hhour-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "qhour-utc"))
			parser_errmsg("did you mean '$qhour-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		else if(!strcasecmp((char*)name, "minute-utc"))
			parser_errmsg("did you mean '$minute-utc' instead of '%s'?"
				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
		ABORT_FINALIZE(RS_RET_INVLD_PROP);
	}
	if(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR) {
		offs = (name[0] == '$') ? 1 : 0;
		pProp-&gt;name = ustrdup(name + offs);
		pProp-&gt;nameLen = nameLen - offs;
		pProp-&gt;name[0] = '!';
	}
	pProp-&gt;id = id;
finalize_it:
	RETiRet;
}
void
msgPropDescrDestruct(msgPropDescr_t *pProp)
{
	if(pProp != NULL) {
		if(pProp-&gt;id == PROP_CEE ||
		   pProp-&gt;id == PROP_LOCAL_VAR ||
		   pProp-&gt;id == PROP_GLOBAL_VAR)
			free(pProp-&gt;name);
	}
}
static rsRetVal msgQueryInterface(interface_t __attribute__((unused)) *i) { return RS_RET_NOT_IMPLEMENTED; }
BEGINObjClassInit(msg, 1, OBJ_IS_CORE_MODULE)
	pthread_mutex_init(&amp;glblVars_lock, NULL);
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(var, CORE_COMPONENT));
	OBJSetMethodHandler(objMethod_SERIALIZE, MsgSerialize);
#	ifdef HAVE_MALLOC_TRIM
	INIT_ATOMIC_HELPER_MUT(mutTrimCtr);
#	endif
ENDObjClassInit(msg)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
