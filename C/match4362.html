<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for dns_parser.c & msg.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for dns_parser.c & msg.c
      </h3>
      <h1 align="center">
        0.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>dns_parser.c (11.063829%)<TH>msg.c (0.5110063%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4362-0.html#0',2,'match4362-1.html#0',3)" NAME="0">(194-205)<TD><A HREF="javascript:ZweiFrames('match4362-0.html#0',2,'match4362-1.html#0',3)" NAME="0">(699-710)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match4362-0.html#1',2,'match4362-1.html#1',3)" NAME="1">(173-181)<TD><A HREF="javascript:ZweiFrames('match4362-0.html#1',2,'match4362-1.html#1',3)" NAME="1">(3104-3110)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dns_parser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* dns_parser.c
 *
 * This file contains functions to parse DNS headers.
 *
 * File begun on 2018-11-13
 *
 * Created by:
 *  - Kevin Guillemot (kevin.guillemot@advens.fr)
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include &quot;config.h&quot;
#include &quot;parsers.h&quot;


/* List of RCodes defined in RFC6895 : https://tools.ietf.org/html/rfc6895 */
static const char *dns_rcodes[] = {
		&quot;NoError&quot;,  // 0
		&quot;FormErr&quot;,  // 1
		&quot;ServFail&quot;, // 2
		&quot;NXDomain&quot;, // 3
		&quot;NotImp&quot;,   // 4
		&quot;Refused&quot;,  // 5
		&quot;YXDomain&quot;, // 6
		&quot;YXRRSet&quot;,  // 7
		&quot;NXRRSet&quot;,  // 8
		&quot;NotAuth&quot;,  // 9
		&quot;NotZone&quot;,  // 10
		&quot;&quot;,         // 11 - Reserved
		&quot;&quot;,         // 12 - Reserved
		&quot;&quot;,         // 13 - Reserved
		&quot;&quot;,         // 14 - Reserved
		&quot;&quot;,         // 15 - Reserved
		&quot;BADVERS|BADSIG&quot;, // 16
		&quot;BADKEY&quot;,   // 17
		&quot;BADTIME&quot;,  // 18
		&quot;BADMODE&quot;,  // 19
		&quot;BADNAME&quot;,  // 20
		&quot;BADALG&quot;,   // 21
		&quot;BADTRUNC&quot;,  // 22
		/* Reserved for private use */
		NULL
};

/* List of record types (maybe not complete) */
static const char *dns_types[] = {
		0,
		&quot;A&quot;,        // 1
		&quot;NS&quot;,       // 2
		&quot;MD&quot;,       // 3
		&quot;MF&quot;,       // 4
		&quot;CNAME&quot;,    // 5
		&quot;SOA&quot;,      // 6
		&quot;MB&quot;,       // 7
		&quot;MG&quot;,       // 8
		&quot;MR&quot;,       // 9
		&quot;NULL&quot;,     // 10
		&quot;WKS&quot;,      // 11
		&quot;PTR&quot;,      // 12
		&quot;HINFO&quot;,    // 13
		&quot;MINFO&quot;,    // 14
		&quot;MX&quot;,       // 15
		&quot;TXT&quot;,      // 16
		&quot;RP&quot;,       // 17
		&quot;AFSDB&quot;,    // 18
		&quot;X25&quot;,      // 19
		&quot;ISDN&quot;,     // 20
		&quot;RT&quot;,       // 21
		&quot;NSAP&quot;,     // 22
		&quot;NSAP-PTR&quot;, // 23
		&quot;SIG&quot;,      // 24
		&quot;KEY&quot;,      // 25
		&quot;PX&quot;,       // 26
		&quot;GPOS&quot;,     // 27
		&quot;AAAA&quot;,     // 28
		&quot;LOC&quot;,      // 29
		&quot;NXT&quot;,      // 30
		&quot;EID&quot;,      // 31
		&quot;NIMLOC&quot;,   // 32
		&quot;SRV&quot;,      // 33
		&quot;ATMA&quot;,     // 34
		&quot;NAPTR&quot;,    // 35
		&quot;KX&quot;,       // 36
		&quot;CERT&quot;,     // 37
		&quot;A6&quot;,       // 38
		&quot;DNAME&quot;,    // 39
		&quot;SINK&quot;,     // 40
		&quot;OPT&quot;,      // 41
		&quot;APL&quot;,      // 42
		&quot;DS&quot;,       // 43
		&quot;SSHFP&quot;,    // 44
		&quot;IPSECKEY&quot;, // 45
		&quot;RRSIG&quot;,    // 46
		&quot;NSEC&quot;,     // 47
		&quot;DNSKEY&quot;,   // 48
		&quot;DHCID&quot;,    // 49
		&quot;NSEC3&quot;,    // 50
		&quot;NSEC3PARAM&quot;,   // 51
		&quot;TLSA&quot;,     // 51
		&quot;SMIMEA&quot;,   // 52
		&quot;Unassigned&quot;,   // 53
		&quot;HIP&quot;,      // 53
		&quot;NINFO&quot;,    // 54
		&quot;RKEY&quot;,     // 55
		&quot;TALINK&quot;,   // 56
		&quot;CDS&quot;,      // 57
		&quot;CDNSKEY&quot;,  // 58
		&quot;OPENPGPKEY&quot;,   // 59
		&quot;CSYNC&quot;,    // 60
		&quot;ZONEMD&quot;,   // 61
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		&quot;SPF&quot;,      // 99
		&quot;UINFO&quot;,    // 100
		&quot;UID&quot;,      // 101
		&quot;GID&quot;,      // 102
		&quot;UNSPEC&quot;,   // 103
		&quot;NID&quot;,      // 104
		&quot;L32&quot;,      // 105
		&quot;L64&quot;,      // 106
		&quot;LP&quot;,       // 107
		&quot;EUI48&quot;,    // 108
		&quot;EUI64&quot;,    // 109
		/* Reserved for private use */
		NULL
};
/* Part 2, since 249. To prevent useless large buffer in memory */
static const char *dns_types2[] = {
		&quot;TKEY&quot;,
		&quot;TSIG&quot;,
		&quot;IXFR&quot;,
		&quot;AXFR&quot;,
		&quot;MAILB&quot;,
		&quot;MAILA&quot;,
		&quot;*&quot;,
		&quot;URI&quot;,
		&quot;CAA&quot;,
		&quot;AVC&quot;,
		&quot;DOA&quot;,
		&quot;AMTRELAY&quot;,
		NULL
};
/* Part 3, since 32768. To prevent useless large buffer in memory */
static const char *dns_types3[] = {
		&quot;TA&quot;,
		&quot;DLV&quot;,
		NULL
};


/* This function takes an integer as parameter
 *  and returns the corresponding string type of DNS query
 */
static const char *get_type(uint16_t x) {
	const char **types = NULL;
<A NAME="1"></A>	uint16_t len_types3 = (sizeof(dns_types3) / sizeof(char *)) - 1;
	uint16_t len_types2 = (sizeof(dns_types2) / sizeof(char *)) - 1;
	uint16_t len_types = (sizeof(dns_types) / sizeof(char *)) - 1;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match4362-1.html#1',3,'match4362-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if (x &gt;= 32768 &amp;&amp; x &lt; 32768 + len_types3) {
		types = dns_types3;
		x -= 32768;
	}
	else if (x &gt;= 249 &amp;&amp; x &lt; 249 + len_types2) {
		types = dns_types2;
		x -= 249;
	}
	else if (x &gt; 0 &amp;&amp; x &lt; len_types)</B></FONT>
		types = dns_types;
	else
		return &quot;UNKNOWN&quot;;
	if (types[x] != NULL)
		return types[x];
	return &quot;UNKNOWN&quot;;
}


<A NAME="0"></A>/* This function takes an integer as parameter
 *  and returns the corresponding string class of DNS query
 */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4362-1.html#0',3,'match4362-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static const char *get_class(uint16_t x) {
	switch (x) {
		case 1:
			return &quot;IN&quot;;
		case 3:
			return &quot;CH&quot;;
		case 4:
			return &quot;HS&quot;;
		case 254:
			return &quot;QCLASS NONE&quot;;
		case 255:
			return &quot;QCLASS *&quot;;</B></FONT>
	}
	return &quot;UNKNOWN&quot;;
}


/*
 *  This function parses the bytes in the received packet to extract DNS metadata.
 *
 *  its parameters are:
 *    - a pointer on the list of bytes representing the packet
 *    - the size of the list passed as first parameter
 *    - a pointer on a json_object, containing all the metadata recovered so far
 *      this is also where DNS metadata will be added
 *
 *  This function returns a structure containing the data unprocessed by this parser
 *  or the ones after (as a list of bytes), and the length of this data.
*/
data_ret_t *dns_parse(const uchar *packet, int pktSize, struct json_object *jparent) {
	const uchar *packet_ptr = packet;
	const uchar *end_packet = packet + pktSize;
	DBGPRINTF(&quot;dns_parse\n&quot;);
	DBGPRINTF(&quot;packet size %d\n&quot;, pktSize);

	/* Union to prevent cast from uchar to smb_header_t */
	union {
		unsigned short int *two_bytes;
		const uchar *pckt;
	} union_short_int;

	/* Get transaction id */
	union_short_int.pckt = packet_ptr;
	unsigned short int transaction_id = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;transaction_id = %02x \n&quot;, transaction_id);
	union_short_int.pckt += 2;

	/* Get flags */
	unsigned short int flags = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;flags = %02x \n&quot;, flags);

	/* Get response flag */
	unsigned short int response_flag = (flags &gt;&gt; 15) &amp; 0b1; // Get the left bit
	//DBGPRINTF(&quot;response_flag = %02x \n&quot;, response_flag);

	/* Get Opcode */
	unsigned short int opcode = (flags &gt;&gt; 11) &amp; 0b1111;
	//DBGPRINTF(&quot;opcode = %02x \n&quot;, opcode);

	/* Verify Z: reserved bit */
	unsigned short int reserved = (flags &gt;&gt; 6) &amp; 0b1;
	//DBGPRINTF(&quot;reserved = %02x \n&quot;, reserved);
	/* Reserved bit MUST be 0 */
	if (reserved != 0) {
		DBGPRINTF(&quot;DNS packet reserved bit (Z) is not 0, aborting message. \n&quot;);
		RETURN_DATA_AFTER(0)
	}

	/* Get reply code : 4 last bits */
	unsigned short int reply_code = flags &amp; 0b1111;
	//DBGPRINTF(&quot;reply_code = %02x \n&quot;, reply_code);

	union_short_int.pckt += 2;

	/* Get QDCOUNT */
	unsigned short int query_count = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;query_count = %02x \n&quot;, query_count);
	union_short_int.pckt += 2;

	/* Get ANCOUNT */
	unsigned short int answer_count = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;answer_count = %02x \n&quot;, answer_count);
	union_short_int.pckt += 2;

	/* Get NSCOUNT */
	unsigned short int authority_count = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;authority_count = %02x \n&quot;, authority_count);
	union_short_int.pckt += 2;

	/* Get ARCOUNT */
	unsigned short int additionnal_count = ntohs(*(union_short_int.two_bytes));
	//DBGPRINTF(&quot;additionnal_count = %02x \n&quot;, additionnal_count);
	union_short_int.pckt += 2;
	packet_ptr = union_short_int.pckt;

	fjson_object *queries = NULL;
	if ((queries = json_object_new_array()) == NULL) {
		DBGPRINTF(&quot;impcap::dns_parser: Cannot create new json array. Stopping.\n&quot;);
		RETURN_DATA_AFTER(0)
	}

	// For each query of query_count
	int query_cpt = 0;
	while (query_cpt &lt; query_count &amp;&amp; packet_ptr &lt; end_packet) {
		size_t query_size = strnlen((const char *)packet_ptr, (size_t)(end_packet - packet_ptr));
		// Check if query is valid (max 255 bytes, plus a '\0')
		if (query_size &gt;= 256) {
			DBGPRINTF(&quot;impcap::dns_parser: Length of domain queried is &gt; 255. Stopping.\n&quot;);
			break;
		}
		// Check if remaining data is enough to hold query + '\0' + 4 bytes (QTYPE and QCLASS fields)
		if (query_size + 5 &gt; (size_t)(end_packet - packet_ptr)) {
			DBGPRINTF(&quot;impcap::dns_parser: packet size too small to parse query. Stopping.\n&quot;);
			break;
		}
		fjson_object *query = NULL;
		if ((query = json_object_new_object()) == NULL) {
			DBGPRINTF(&quot;impcap::dns_parser: Cannot create new json object. Stopping.\n&quot;);
			break;
		}
		char domain_query[256] = {0};
		uchar nb_char = *packet_ptr;
		packet_ptr++;
		size_t cpt = 0;
		while (cpt + 1 &lt; query_size) {
			if (nb_char == 0) {
				nb_char = *packet_ptr;
				domain_query[cpt] = '.';
			} else {
				domain_query[cpt] = (char)*packet_ptr;
				nb_char--;
			}
			cpt++;
			packet_ptr++;
		}
		domain_query[cpt] = '\0';
		if (cpt)
			packet_ptr++; // pass the last \0, only if query was not empty
		// DBGPRINTF(&quot;Requested domain : '%s' \n&quot;, domain_query);

		/* Register the name in dict */
		json_object_object_add(query, &quot;qname&quot;, json_object_new_string(domain_query));
		/* Get QTYPE */
		union_short_int.pckt = packet_ptr;
		unsigned short int qtype = ntohs(*(union_short_int.two_bytes));
		//DBGPRINTF(&quot;qtype = %02x \n&quot;, qtype);
		json_object_object_add(query, &quot;qtype&quot;, json_object_new_int((int)qtype));
		json_object_object_add(query, &quot;type&quot;, json_object_new_string(get_type(qtype)));
		union_short_int.pckt += 2;
		/* Retrieve QCLASS */
		unsigned short int qclass = ntohs(*(union_short_int.two_bytes));
		//DBGPRINTF(&quot;qclass = %02x \n&quot;, qclass);
		json_object_object_add(query, &quot;qclass&quot;, json_object_new_int((int)qclass));
		json_object_object_add(query, &quot;class&quot;, json_object_new_string(get_class(qclass)));
		packet_ptr = union_short_int.pckt + 2;
		/* Register the query in json array */
		json_object_array_add(queries, query);
		query_cpt++;
	}

	json_object_object_add(jparent, &quot;DNS_transaction_id&quot;, json_object_new_int((int)transaction_id));

	json_bool is_reponse = FALSE;
	if (response_flag)
		is_reponse = TRUE;
	json_object_object_add(jparent, &quot;DNS_response_flag&quot;, json_object_new_boolean(is_reponse));

	json_object_object_add(jparent, &quot;DNS_opcode&quot;, json_object_new_int(opcode));
	json_object_object_add(jparent, &quot;DNS_rcode&quot;, json_object_new_int((int)reply_code));
	json_object_object_add(jparent, &quot;DNS_error&quot;, json_object_new_string(dns_rcodes[reply_code]));
	json_object_object_add(jparent, &quot;DNS_QDCOUNT&quot;, json_object_new_int((int)query_count));
	json_object_object_add(jparent, &quot;DNS_ANCOUNT&quot;, json_object_new_int((int)answer_count));
	json_object_object_add(jparent, &quot;DNS_NSCOUNT&quot;, json_object_new_int((int)authority_count));
	json_object_object_add(jparent, &quot;DNS_ARCOUNT&quot;, json_object_new_int((int)additionnal_count));
	json_object_object_add(jparent, &quot;DNS_Names&quot;, queries);

	/* Packet has been successfully parsed, there still can be some responses left, but do not process them */
	RETURN_DATA_AFTER(0);
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>msg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* msg.c
 * The msg object. Implementation of all msg-related functions
 *
 * File begun on 2007-07-13 by RGerhards (extracted from syslogd.c)
 * This file is under development and has not yet arrived at being fully
 * self-contained and a real object. So far, it is mostly an excerpt
 * of the &quot;old&quot; message code without any modifications. However, it
 * helps to have things at the right place one we go to the meat of it.
 *
 * Copyright 2007-2020 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * The rsyslog runtime library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The rsyslog runtime library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the rsyslog runtime library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 * A copy of the LGPL can be found in the file &quot;COPYING.LESSER&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#define SYSLOG_NAMES
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/socket.h&gt;
#ifdef HAVE_SYSINFO_UPTIME
#include &lt;sys/sysinfo.h&gt;
#endif
#include &lt;netdb.h&gt;
#include &lt;libestr.h&gt;
#include &lt;json.h&gt;
#ifdef HAVE_MALLOC_H
#  include &lt;malloc.h&gt;
#endif
#ifdef USE_LIBUUID
#  include &lt;uuid/uuid.h&gt;
#endif
#include &lt;errno.h&gt;
#include &quot;rsyslog.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;stringbuf.h&quot;
#include &quot;template.h&quot;
#include &quot;msg.h&quot;
#include &quot;datetime.h&quot;
#include &quot;glbl.h&quot;
#include &quot;regexp.h&quot;
#include &quot;atomic.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;prop.h&quot;
#include &quot;net.h&quot;
#include &quot;var.h&quot;
#include &quot;rsconf.h&quot;
#include &quot;parserif.h&quot;
#include &quot;errmsg.h&quot;

#define DEV_DEBUG 0	/* set to 1 to enable very verbose developer debugging messages */

/* inlines */
extern void msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri);

/* TODO: move the global variable root to the config object - had no time to to it
 * right now before vacation -- rgerhards, 2013-07-22
 */
static pthread_mutex_t glblVars_lock;
struct json_object *global_var_root = NULL;

/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(datetime)
DEFobjCurrIf(glbl)
DEFobjCurrIf(regexp)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
DEFobjCurrIf(var)

static const char *one_digit[10] = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot; };

static const char *two_digits[100] = {
	&quot;00&quot;, &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;,
	&quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;,
	&quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;,
	&quot;30&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, &quot;38&quot;, &quot;39&quot;,
	&quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;47&quot;, &quot;48&quot;, &quot;49&quot;,
	&quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot;, &quot;58&quot;, &quot;59&quot;,
	&quot;60&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;66&quot;, &quot;67&quot;, &quot;68&quot;, &quot;69&quot;,
	&quot;70&quot;, &quot;71&quot;, &quot;72&quot;, &quot;73&quot;, &quot;74&quot;, &quot;75&quot;, &quot;76&quot;, &quot;77&quot;, &quot;78&quot;, &quot;79&quot;,
	&quot;80&quot;, &quot;81&quot;, &quot;82&quot;, &quot;83&quot;, &quot;84&quot;, &quot;85&quot;, &quot;86&quot;, &quot;87&quot;, &quot;88&quot;, &quot;89&quot;,
	&quot;90&quot;, &quot;91&quot;, &quot;92&quot;, &quot;93&quot;, &quot;94&quot;, &quot;95&quot;, &quot;96&quot;, &quot;97&quot;, &quot;98&quot;, &quot;99&quot;};

static const char *wdayNames[7] = { &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot; };

/* Table of days in a year, needed for getYearDay */
static const char *daysInYear[366] = {
	       &quot;001&quot;, &quot;002&quot;, &quot;003&quot;, &quot;004&quot;, &quot;005&quot;, &quot;006&quot;, &quot;007&quot;, &quot;008&quot;, &quot;009&quot;,
	&quot;010&quot;, &quot;011&quot;, &quot;012&quot;, &quot;013&quot;, &quot;014&quot;, &quot;015&quot;, &quot;016&quot;, &quot;017&quot;, &quot;018&quot;, &quot;019&quot;,
	&quot;020&quot;, &quot;021&quot;, &quot;022&quot;, &quot;023&quot;, &quot;024&quot;, &quot;025&quot;, &quot;026&quot;, &quot;027&quot;, &quot;028&quot;, &quot;029&quot;,
	&quot;030&quot;, &quot;031&quot;, &quot;032&quot;, &quot;033&quot;, &quot;034&quot;, &quot;035&quot;, &quot;036&quot;, &quot;037&quot;, &quot;038&quot;, &quot;039&quot;,
	&quot;040&quot;, &quot;041&quot;, &quot;042&quot;, &quot;043&quot;, &quot;044&quot;, &quot;045&quot;, &quot;046&quot;, &quot;047&quot;, &quot;048&quot;, &quot;049&quot;,
	&quot;050&quot;, &quot;051&quot;, &quot;052&quot;, &quot;053&quot;, &quot;054&quot;, &quot;055&quot;, &quot;056&quot;, &quot;057&quot;, &quot;058&quot;, &quot;059&quot;,
	&quot;060&quot;, &quot;061&quot;, &quot;062&quot;, &quot;063&quot;, &quot;064&quot;, &quot;065&quot;, &quot;066&quot;, &quot;067&quot;, &quot;068&quot;, &quot;069&quot;,
	&quot;070&quot;, &quot;071&quot;, &quot;072&quot;, &quot;073&quot;, &quot;074&quot;, &quot;075&quot;, &quot;076&quot;, &quot;077&quot;, &quot;078&quot;, &quot;079&quot;,
	&quot;080&quot;, &quot;081&quot;, &quot;082&quot;, &quot;083&quot;, &quot;084&quot;, &quot;085&quot;, &quot;086&quot;, &quot;087&quot;, &quot;088&quot;, &quot;089&quot;,
	&quot;090&quot;, &quot;091&quot;, &quot;092&quot;, &quot;093&quot;, &quot;094&quot;, &quot;095&quot;, &quot;096&quot;, &quot;097&quot;, &quot;098&quot;, &quot;099&quot;,
	&quot;100&quot;, &quot;101&quot;, &quot;102&quot;, &quot;103&quot;, &quot;104&quot;, &quot;105&quot;, &quot;106&quot;, &quot;107&quot;, &quot;108&quot;, &quot;109&quot;,
	&quot;110&quot;, &quot;111&quot;, &quot;112&quot;, &quot;113&quot;, &quot;114&quot;, &quot;115&quot;, &quot;116&quot;, &quot;117&quot;, &quot;118&quot;, &quot;119&quot;,
	&quot;120&quot;, &quot;121&quot;, &quot;122&quot;, &quot;123&quot;, &quot;124&quot;, &quot;125&quot;, &quot;126&quot;, &quot;127&quot;, &quot;128&quot;, &quot;129&quot;,
	&quot;130&quot;, &quot;131&quot;, &quot;132&quot;, &quot;133&quot;, &quot;134&quot;, &quot;135&quot;, &quot;136&quot;, &quot;137&quot;, &quot;138&quot;, &quot;139&quot;,
	&quot;140&quot;, &quot;141&quot;, &quot;142&quot;, &quot;143&quot;, &quot;144&quot;, &quot;145&quot;, &quot;146&quot;, &quot;147&quot;, &quot;148&quot;, &quot;149&quot;,
	&quot;150&quot;, &quot;151&quot;, &quot;152&quot;, &quot;153&quot;, &quot;154&quot;, &quot;155&quot;, &quot;156&quot;, &quot;157&quot;, &quot;158&quot;, &quot;159&quot;,
	&quot;160&quot;, &quot;161&quot;, &quot;162&quot;, &quot;163&quot;, &quot;164&quot;, &quot;165&quot;, &quot;166&quot;, &quot;167&quot;, &quot;168&quot;, &quot;169&quot;,
	&quot;170&quot;, &quot;171&quot;, &quot;172&quot;, &quot;173&quot;, &quot;174&quot;, &quot;175&quot;, &quot;176&quot;, &quot;177&quot;, &quot;178&quot;, &quot;179&quot;,
	&quot;180&quot;, &quot;181&quot;, &quot;182&quot;, &quot;183&quot;, &quot;184&quot;, &quot;185&quot;, &quot;186&quot;, &quot;187&quot;, &quot;188&quot;, &quot;189&quot;,
	&quot;190&quot;, &quot;191&quot;, &quot;192&quot;, &quot;193&quot;, &quot;194&quot;, &quot;195&quot;, &quot;196&quot;, &quot;197&quot;, &quot;198&quot;, &quot;199&quot;,
	&quot;200&quot;, &quot;201&quot;, &quot;202&quot;, &quot;203&quot;, &quot;204&quot;, &quot;205&quot;, &quot;206&quot;, &quot;207&quot;, &quot;208&quot;, &quot;209&quot;,
	&quot;210&quot;, &quot;211&quot;, &quot;212&quot;, &quot;213&quot;, &quot;214&quot;, &quot;215&quot;, &quot;216&quot;, &quot;217&quot;, &quot;218&quot;, &quot;219&quot;,
	&quot;220&quot;, &quot;221&quot;, &quot;222&quot;, &quot;223&quot;, &quot;224&quot;, &quot;225&quot;, &quot;226&quot;, &quot;227&quot;, &quot;228&quot;, &quot;229&quot;,
	&quot;230&quot;, &quot;231&quot;, &quot;232&quot;, &quot;233&quot;, &quot;234&quot;, &quot;235&quot;, &quot;236&quot;, &quot;237&quot;, &quot;238&quot;, &quot;239&quot;,
	&quot;240&quot;, &quot;241&quot;, &quot;242&quot;, &quot;243&quot;, &quot;244&quot;, &quot;245&quot;, &quot;246&quot;, &quot;247&quot;, &quot;248&quot;, &quot;249&quot;,
	&quot;250&quot;, &quot;251&quot;, &quot;252&quot;, &quot;253&quot;, &quot;254&quot;, &quot;255&quot;, &quot;256&quot;, &quot;257&quot;, &quot;258&quot;, &quot;259&quot;,
	&quot;260&quot;, &quot;261&quot;, &quot;262&quot;, &quot;263&quot;, &quot;264&quot;, &quot;265&quot;, &quot;266&quot;, &quot;267&quot;, &quot;268&quot;, &quot;269&quot;,
	&quot;270&quot;, &quot;271&quot;, &quot;272&quot;, &quot;273&quot;, &quot;274&quot;, &quot;275&quot;, &quot;276&quot;, &quot;277&quot;, &quot;278&quot;, &quot;279&quot;,
	&quot;280&quot;, &quot;281&quot;, &quot;282&quot;, &quot;283&quot;, &quot;284&quot;, &quot;285&quot;, &quot;286&quot;, &quot;287&quot;, &quot;288&quot;, &quot;289&quot;,
	&quot;290&quot;, &quot;291&quot;, &quot;292&quot;, &quot;293&quot;, &quot;294&quot;, &quot;295&quot;, &quot;296&quot;, &quot;297&quot;, &quot;298&quot;, &quot;299&quot;,
	&quot;300&quot;, &quot;301&quot;, &quot;302&quot;, &quot;303&quot;, &quot;304&quot;, &quot;305&quot;, &quot;306&quot;, &quot;307&quot;, &quot;308&quot;, &quot;309&quot;,
	&quot;310&quot;, &quot;311&quot;, &quot;312&quot;, &quot;313&quot;, &quot;314&quot;, &quot;315&quot;, &quot;316&quot;, &quot;317&quot;, &quot;318&quot;, &quot;319&quot;,
	&quot;320&quot;, &quot;321&quot;, &quot;322&quot;, &quot;323&quot;, &quot;324&quot;, &quot;325&quot;, &quot;326&quot;, &quot;327&quot;, &quot;328&quot;, &quot;329&quot;,
	&quot;330&quot;, &quot;331&quot;, &quot;332&quot;, &quot;333&quot;, &quot;334&quot;, &quot;335&quot;, &quot;336&quot;, &quot;337&quot;, &quot;338&quot;, &quot;339&quot;,
	&quot;340&quot;, &quot;341&quot;, &quot;342&quot;, &quot;343&quot;, &quot;344&quot;, &quot;345&quot;, &quot;346&quot;, &quot;347&quot;, &quot;348&quot;, &quot;349&quot;,
	&quot;350&quot;, &quot;351&quot;, &quot;352&quot;, &quot;353&quot;, &quot;354&quot;, &quot;355&quot;, &quot;356&quot;, &quot;357&quot;, &quot;358&quot;, &quot;359&quot;,
	&quot;360&quot;, &quot;361&quot;, &quot;362&quot;, &quot;363&quot;, &quot;364&quot;, &quot;365&quot;, &quot;366&quot;};

/* The following is a table of supported years. This permits us
 * to avoid dynamic memory allocation. Note that the time-based
 * algos need to be upgraded after the year 2099 in any case.
 * Quite honestly, I don't expect that this is a real problem ;)
 */
static const char *years[] = {
	&quot;1967&quot;, &quot;1968&quot;, &quot;1969&quot;, &quot;1970&quot;, &quot;1971&quot;, &quot;1972&quot;, &quot;1973&quot;, &quot;1974&quot;,
	&quot;1975&quot;, &quot;1976&quot;, &quot;1977&quot;, &quot;1978&quot;, &quot;1979&quot;, &quot;1980&quot;, &quot;1981&quot;, &quot;1982&quot;,
	&quot;1983&quot;, &quot;1984&quot;, &quot;1985&quot;, &quot;1986&quot;, &quot;1987&quot;, &quot;1988&quot;, &quot;1989&quot;, &quot;1990&quot;,
	&quot;1991&quot;, &quot;1992&quot;, &quot;1993&quot;, &quot;1994&quot;, &quot;1995&quot;, &quot;1996&quot;, &quot;1997&quot;, &quot;1998&quot;,
	&quot;1999&quot;, &quot;2000&quot;, &quot;2001&quot;, &quot;2002&quot;, &quot;2003&quot;, &quot;2004&quot;, &quot;2005&quot;, &quot;2006&quot;,
	&quot;2007&quot;, &quot;2008&quot;, &quot;2009&quot;, &quot;2010&quot;, &quot;2011&quot;, &quot;2012&quot;, &quot;2013&quot;, &quot;2014&quot;,
	&quot;2015&quot;, &quot;2016&quot;, &quot;2017&quot;, &quot;2018&quot;, &quot;2019&quot;, &quot;2020&quot;, &quot;2021&quot;, &quot;2022&quot;,
	&quot;2023&quot;, &quot;2024&quot;, &quot;2025&quot;, &quot;2026&quot;, &quot;2027&quot;, &quot;2028&quot;, &quot;2029&quot;, &quot;2030&quot;,
	&quot;2031&quot;, &quot;2032&quot;, &quot;2033&quot;, &quot;2034&quot;, &quot;2035&quot;, &quot;2036&quot;, &quot;2037&quot;, &quot;2038&quot;,
	&quot;2039&quot;, &quot;2040&quot;, &quot;2041&quot;, &quot;2042&quot;, &quot;2043&quot;, &quot;2044&quot;, &quot;2045&quot;, &quot;2046&quot;,
	&quot;2047&quot;, &quot;2048&quot;, &quot;2049&quot;, &quot;2050&quot;, &quot;2051&quot;, &quot;2052&quot;, &quot;2053&quot;, &quot;2054&quot;,
	&quot;2055&quot;, &quot;2056&quot;, &quot;2057&quot;, &quot;2058&quot;, &quot;2059&quot;, &quot;2060&quot;, &quot;2061&quot;, &quot;2062&quot;,
	&quot;2063&quot;, &quot;2064&quot;, &quot;2065&quot;, &quot;2066&quot;, &quot;2067&quot;, &quot;2068&quot;, &quot;2069&quot;, &quot;2070&quot;,
	&quot;2071&quot;, &quot;2072&quot;, &quot;2073&quot;, &quot;2074&quot;, &quot;2075&quot;, &quot;2076&quot;, &quot;2077&quot;, &quot;2078&quot;,
	&quot;2079&quot;, &quot;2080&quot;, &quot;2081&quot;, &quot;2082&quot;, &quot;2083&quot;, &quot;2084&quot;, &quot;2085&quot;, &quot;2086&quot;,
	&quot;2087&quot;, &quot;2088&quot;, &quot;2089&quot;, &quot;2090&quot;, &quot;2091&quot;, &quot;2092&quot;, &quot;2093&quot;, &quot;2094&quot;,
	&quot;2095&quot;, &quot;2096&quot;, &quot;2097&quot;, &quot;2098&quot;, &quot;2099&quot; };

static struct {
	uchar *pszName;
} syslog_pri_names[200] = {
	{ UCHAR_CONSTANT(&quot;0&quot;) },
	{ UCHAR_CONSTANT(&quot;1&quot;) },
	{ UCHAR_CONSTANT(&quot;2&quot;) },
	{ UCHAR_CONSTANT(&quot;3&quot;) },
	{ UCHAR_CONSTANT(&quot;4&quot;) },
	{ UCHAR_CONSTANT(&quot;5&quot;) },
	{ UCHAR_CONSTANT(&quot;6&quot;) },
	{ UCHAR_CONSTANT(&quot;7&quot;) },
	{ UCHAR_CONSTANT(&quot;8&quot;) },
	{ UCHAR_CONSTANT(&quot;9&quot;) },
	{ UCHAR_CONSTANT(&quot;10&quot;) },
	{ UCHAR_CONSTANT(&quot;11&quot;) },
	{ UCHAR_CONSTANT(&quot;12&quot;) },
	{ UCHAR_CONSTANT(&quot;13&quot;) },
	{ UCHAR_CONSTANT(&quot;14&quot;) },
	{ UCHAR_CONSTANT(&quot;15&quot;) },
	{ UCHAR_CONSTANT(&quot;16&quot;) },
	{ UCHAR_CONSTANT(&quot;17&quot;) },
	{ UCHAR_CONSTANT(&quot;18&quot;) },
	{ UCHAR_CONSTANT(&quot;19&quot;) },
	{ UCHAR_CONSTANT(&quot;20&quot;) },
	{ UCHAR_CONSTANT(&quot;21&quot;) },
	{ UCHAR_CONSTANT(&quot;22&quot;) },
	{ UCHAR_CONSTANT(&quot;23&quot;) },
	{ UCHAR_CONSTANT(&quot;24&quot;) },
	{ UCHAR_CONSTANT(&quot;25&quot;) },
	{ UCHAR_CONSTANT(&quot;26&quot;) },
	{ UCHAR_CONSTANT(&quot;27&quot;) },
	{ UCHAR_CONSTANT(&quot;28&quot;) },
	{ UCHAR_CONSTANT(&quot;29&quot;) },
	{ UCHAR_CONSTANT(&quot;30&quot;) },
	{ UCHAR_CONSTANT(&quot;31&quot;) },
	{ UCHAR_CONSTANT(&quot;32&quot;) },
	{ UCHAR_CONSTANT(&quot;33&quot;) },
	{ UCHAR_CONSTANT(&quot;34&quot;) },
	{ UCHAR_CONSTANT(&quot;35&quot;) },
	{ UCHAR_CONSTANT(&quot;36&quot;) },
	{ UCHAR_CONSTANT(&quot;37&quot;) },
	{ UCHAR_CONSTANT(&quot;38&quot;) },
	{ UCHAR_CONSTANT(&quot;39&quot;) },
	{ UCHAR_CONSTANT(&quot;40&quot;) },
	{ UCHAR_CONSTANT(&quot;41&quot;) },
	{ UCHAR_CONSTANT(&quot;42&quot;) },
	{ UCHAR_CONSTANT(&quot;43&quot;) },
	{ UCHAR_CONSTANT(&quot;44&quot;) },
	{ UCHAR_CONSTANT(&quot;45&quot;) },
	{ UCHAR_CONSTANT(&quot;46&quot;) },
	{ UCHAR_CONSTANT(&quot;47&quot;) },
	{ UCHAR_CONSTANT(&quot;48&quot;) },
	{ UCHAR_CONSTANT(&quot;49&quot;) },
	{ UCHAR_CONSTANT(&quot;50&quot;) },
	{ UCHAR_CONSTANT(&quot;51&quot;) },
	{ UCHAR_CONSTANT(&quot;52&quot;) },
	{ UCHAR_CONSTANT(&quot;53&quot;) },
	{ UCHAR_CONSTANT(&quot;54&quot;) },
	{ UCHAR_CONSTANT(&quot;55&quot;) },
	{ UCHAR_CONSTANT(&quot;56&quot;) },
	{ UCHAR_CONSTANT(&quot;57&quot;) },
	{ UCHAR_CONSTANT(&quot;58&quot;) },
	{ UCHAR_CONSTANT(&quot;59&quot;) },
	{ UCHAR_CONSTANT(&quot;60&quot;) },
	{ UCHAR_CONSTANT(&quot;61&quot;) },
	{ UCHAR_CONSTANT(&quot;62&quot;) },
	{ UCHAR_CONSTANT(&quot;63&quot;) },
	{ UCHAR_CONSTANT(&quot;64&quot;) },
	{ UCHAR_CONSTANT(&quot;65&quot;) },
	{ UCHAR_CONSTANT(&quot;66&quot;) },
	{ UCHAR_CONSTANT(&quot;67&quot;) },
	{ UCHAR_CONSTANT(&quot;68&quot;) },
	{ UCHAR_CONSTANT(&quot;69&quot;) },
	{ UCHAR_CONSTANT(&quot;70&quot;) },
	{ UCHAR_CONSTANT(&quot;71&quot;) },
	{ UCHAR_CONSTANT(&quot;72&quot;) },
	{ UCHAR_CONSTANT(&quot;73&quot;) },
	{ UCHAR_CONSTANT(&quot;74&quot;) },
	{ UCHAR_CONSTANT(&quot;75&quot;) },
	{ UCHAR_CONSTANT(&quot;76&quot;) },
	{ UCHAR_CONSTANT(&quot;77&quot;) },
	{ UCHAR_CONSTANT(&quot;78&quot;) },
	{ UCHAR_CONSTANT(&quot;79&quot;) },
	{ UCHAR_CONSTANT(&quot;80&quot;) },
	{ UCHAR_CONSTANT(&quot;81&quot;) },
	{ UCHAR_CONSTANT(&quot;82&quot;) },
	{ UCHAR_CONSTANT(&quot;83&quot;) },
	{ UCHAR_CONSTANT(&quot;84&quot;) },
	{ UCHAR_CONSTANT(&quot;85&quot;) },
	{ UCHAR_CONSTANT(&quot;86&quot;) },
	{ UCHAR_CONSTANT(&quot;87&quot;) },
	{ UCHAR_CONSTANT(&quot;88&quot;) },
	{ UCHAR_CONSTANT(&quot;89&quot;) },
	{ UCHAR_CONSTANT(&quot;90&quot;) },
	{ UCHAR_CONSTANT(&quot;91&quot;) },
	{ UCHAR_CONSTANT(&quot;92&quot;) },
	{ UCHAR_CONSTANT(&quot;93&quot;) },
	{ UCHAR_CONSTANT(&quot;94&quot;) },
	{ UCHAR_CONSTANT(&quot;95&quot;) },
	{ UCHAR_CONSTANT(&quot;96&quot;) },
	{ UCHAR_CONSTANT(&quot;97&quot;) },
	{ UCHAR_CONSTANT(&quot;98&quot;) },
	{ UCHAR_CONSTANT(&quot;99&quot;) },
	{ UCHAR_CONSTANT(&quot;100&quot;) },
	{ UCHAR_CONSTANT(&quot;101&quot;) },
	{ UCHAR_CONSTANT(&quot;102&quot;) },
	{ UCHAR_CONSTANT(&quot;103&quot;) },
	{ UCHAR_CONSTANT(&quot;104&quot;) },
	{ UCHAR_CONSTANT(&quot;105&quot;) },
	{ UCHAR_CONSTANT(&quot;106&quot;) },
	{ UCHAR_CONSTANT(&quot;107&quot;) },
	{ UCHAR_CONSTANT(&quot;108&quot;) },
	{ UCHAR_CONSTANT(&quot;109&quot;) },
	{ UCHAR_CONSTANT(&quot;110&quot;) },
	{ UCHAR_CONSTANT(&quot;111&quot;) },
	{ UCHAR_CONSTANT(&quot;112&quot;) },
	{ UCHAR_CONSTANT(&quot;113&quot;) },
	{ UCHAR_CONSTANT(&quot;114&quot;) },
	{ UCHAR_CONSTANT(&quot;115&quot;) },
	{ UCHAR_CONSTANT(&quot;116&quot;) },
	{ UCHAR_CONSTANT(&quot;117&quot;) },
	{ UCHAR_CONSTANT(&quot;118&quot;) },
	{ UCHAR_CONSTANT(&quot;119&quot;) },
	{ UCHAR_CONSTANT(&quot;120&quot;) },
	{ UCHAR_CONSTANT(&quot;121&quot;) },
	{ UCHAR_CONSTANT(&quot;122&quot;) },
	{ UCHAR_CONSTANT(&quot;123&quot;) },
	{ UCHAR_CONSTANT(&quot;124&quot;) },
	{ UCHAR_CONSTANT(&quot;125&quot;) },
	{ UCHAR_CONSTANT(&quot;126&quot;) },
	{ UCHAR_CONSTANT(&quot;127&quot;) },
	{ UCHAR_CONSTANT(&quot;128&quot;) },
	{ UCHAR_CONSTANT(&quot;129&quot;) },
	{ UCHAR_CONSTANT(&quot;130&quot;) },
	{ UCHAR_CONSTANT(&quot;131&quot;) },
	{ UCHAR_CONSTANT(&quot;132&quot;) },
	{ UCHAR_CONSTANT(&quot;133&quot;) },
	{ UCHAR_CONSTANT(&quot;134&quot;) },
	{ UCHAR_CONSTANT(&quot;135&quot;) },
	{ UCHAR_CONSTANT(&quot;136&quot;) },
	{ UCHAR_CONSTANT(&quot;137&quot;) },
	{ UCHAR_CONSTANT(&quot;138&quot;) },
	{ UCHAR_CONSTANT(&quot;139&quot;) },
	{ UCHAR_CONSTANT(&quot;140&quot;) },
	{ UCHAR_CONSTANT(&quot;141&quot;) },
	{ UCHAR_CONSTANT(&quot;142&quot;) },
	{ UCHAR_CONSTANT(&quot;143&quot;) },
	{ UCHAR_CONSTANT(&quot;144&quot;) },
	{ UCHAR_CONSTANT(&quot;145&quot;) },
	{ UCHAR_CONSTANT(&quot;146&quot;) },
	{ UCHAR_CONSTANT(&quot;147&quot;) },
	{ UCHAR_CONSTANT(&quot;148&quot;) },
	{ UCHAR_CONSTANT(&quot;149&quot;) },
	{ UCHAR_CONSTANT(&quot;150&quot;) },
	{ UCHAR_CONSTANT(&quot;151&quot;) },
	{ UCHAR_CONSTANT(&quot;152&quot;) },
	{ UCHAR_CONSTANT(&quot;153&quot;) },
	{ UCHAR_CONSTANT(&quot;154&quot;) },
	{ UCHAR_CONSTANT(&quot;155&quot;) },
	{ UCHAR_CONSTANT(&quot;156&quot;) },
	{ UCHAR_CONSTANT(&quot;157&quot;) },
	{ UCHAR_CONSTANT(&quot;158&quot;) },
	{ UCHAR_CONSTANT(&quot;159&quot;) },
	{ UCHAR_CONSTANT(&quot;160&quot;) },
	{ UCHAR_CONSTANT(&quot;161&quot;) },
	{ UCHAR_CONSTANT(&quot;162&quot;) },
	{ UCHAR_CONSTANT(&quot;163&quot;) },
	{ UCHAR_CONSTANT(&quot;164&quot;) },
	{ UCHAR_CONSTANT(&quot;165&quot;) },
	{ UCHAR_CONSTANT(&quot;166&quot;) },
	{ UCHAR_CONSTANT(&quot;167&quot;) },
	{ UCHAR_CONSTANT(&quot;168&quot;) },
	{ UCHAR_CONSTANT(&quot;169&quot;) },
	{ UCHAR_CONSTANT(&quot;170&quot;) },
	{ UCHAR_CONSTANT(&quot;171&quot;) },
	{ UCHAR_CONSTANT(&quot;172&quot;) },
	{ UCHAR_CONSTANT(&quot;173&quot;) },
	{ UCHAR_CONSTANT(&quot;174&quot;) },
	{ UCHAR_CONSTANT(&quot;175&quot;) },
	{ UCHAR_CONSTANT(&quot;176&quot;) },
	{ UCHAR_CONSTANT(&quot;177&quot;) },
	{ UCHAR_CONSTANT(&quot;178&quot;) },
	{ UCHAR_CONSTANT(&quot;179&quot;) },
	{ UCHAR_CONSTANT(&quot;180&quot;) },
	{ UCHAR_CONSTANT(&quot;181&quot;) },
	{ UCHAR_CONSTANT(&quot;182&quot;) },
	{ UCHAR_CONSTANT(&quot;183&quot;) },
	{ UCHAR_CONSTANT(&quot;184&quot;) },
	{ UCHAR_CONSTANT(&quot;185&quot;) },
	{ UCHAR_CONSTANT(&quot;186&quot;) },
	{ UCHAR_CONSTANT(&quot;187&quot;) },
	{ UCHAR_CONSTANT(&quot;188&quot;) },
	{ UCHAR_CONSTANT(&quot;189&quot;) },
	{ UCHAR_CONSTANT(&quot;190&quot;) },
	{ UCHAR_CONSTANT(&quot;191&quot;) },
	{ UCHAR_CONSTANT(&quot;192&quot;) },
	{ UCHAR_CONSTANT(&quot;193&quot;) },
	{ UCHAR_CONSTANT(&quot;194&quot;) },
	{ UCHAR_CONSTANT(&quot;195&quot;) },
	{ UCHAR_CONSTANT(&quot;196&quot;) },
	{ UCHAR_CONSTANT(&quot;197&quot;) },
	{ UCHAR_CONSTANT(&quot;198&quot;) },
	{ UCHAR_CONSTANT(&quot;199&quot;) }
	};
static char hexdigit[16] =
	{'0', '1', '2', '3', '4', '5', '6', '7', '8',
	 '9', 'A', 'B', 'C', 'D', 'E', 'F' };

#if defined(_AIX)
/* AIXPORT : replace facility names with aso and caa only for AIX */
static const char *syslog_fac_names[LOG_NFACILITIES] = { &quot;kern&quot;, &quot;user&quot;, &quot;mail&quot;, &quot;daemon&quot;, &quot;auth&quot;, &quot;syslog&quot;, &quot;lpr&quot;,
							&quot;news&quot;, &quot;uucp&quot;, &quot;cron&quot;, &quot;authpriv&quot;, &quot;ftp&quot;, &quot;aso&quot;, &quot;audit&quot;,
							&quot;alert&quot;, &quot;caa&quot;, &quot;local0&quot;, &quot;local1&quot;, &quot;local2&quot;, &quot;local3&quot;,
							&quot;local4&quot;, &quot;local5&quot;, &quot;local6&quot;, &quot;local7&quot;, &quot;invld&quot;    };
/* length of the facility names string (for optimizatiions) */
static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
							4, 4, 4, 8, 3, 3, 5,
							5, 3, 6, 6, 6, 6,
							6, 6, 6, 6, 5 };

#else
/*syslog facility names (as of RFC5424) */
static const char *syslog_fac_names[LOG_NFACILITIES] = { &quot;kern&quot;, &quot;user&quot;, &quot;mail&quot;, &quot;daemon&quot;, &quot;auth&quot;, &quot;syslog&quot;, &quot;lpr&quot;,
							&quot;news&quot;, &quot;uucp&quot;, &quot;cron&quot;, &quot;authpriv&quot;, &quot;ftp&quot;, &quot;ntp&quot;, &quot;audit&quot;,
							&quot;alert&quot;, &quot;clock&quot;, &quot;local0&quot;, &quot;local1&quot;, &quot;local2&quot;, &quot;local3&quot;,
							&quot;local4&quot;, &quot;local5&quot;, &quot;local6&quot;, &quot;local7&quot;, &quot;invld&quot; };
/* length of the facility names string (for optimizatiions) */
static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
							4, 4, 4, 8, 3, 3, 5,
							5, 5, 6, 6, 6, 6,
							6, 6, 6, 6, 5 };
#endif

/* table of severity names (in numerical order)*/
static const char *syslog_severity_names[8] = { &quot;emerg&quot;, &quot;alert&quot;, &quot;crit&quot;, &quot;err&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;,
	&quot;debug&quot; };
static short len_syslog_severity_names[8] = { 5, 5, 4, 3, 7, 6, 4, 5 };

/* numerical values as string - this is the most efficient approach to convert severity
 * and facility values to a numerical string... -- rgerhars, 2009-06-17
 */

static const char *syslog_number_names[LOG_NFACILITIES] = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,
	&quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;,
	&quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot; };

/* global variables */
#if defined(HAVE_MALLOC_TRIM) &amp;&amp; !defined(HAVE_ATOMIC_BUILTINS)
static pthread_mutex_t mutTrimCtr;	 /* mutex to handle malloc trim */
#endif

/* some forward declarations */
static int getAPPNAMELen(smsg_t * const pM, sbool bLockMutex);
static rsRetVal jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf,
	struct json_object **parent, int bCreate);
static uchar * jsonPathGetLeaf(uchar *name, int lenName);
struct json_object *jsonDeepCopy(struct json_object *src);
static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value);
void getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen);


/* the locking and unlocking implementations: */
static inline void
MsgLock(smsg_t *pThis)
{
	#if DEV_DEBUG == 1
	dbgprintf(&quot;MsgLock(0x%lx)\n&quot;, (unsigned long) pThis);
	#endif
	pthread_mutex_lock(&amp;pThis-&gt;mut);
}
static inline void
MsgUnlock(smsg_t *pThis)
{
	#if DEV_DEBUG == 1
	dbgprintf(&quot;MsgUnlock(0x%lx)\n&quot;, (unsigned long) pThis);
	#endif
	pthread_mutex_unlock(&amp;pThis-&gt;mut);
}


/* set RcvFromIP name in msg object WITHOUT calling AddRef.
 * rgerhards, 2013-01-22
 */
static inline void
MsgSetRcvFromIPWithoutAddRef(smsg_t *pThis, prop_t *new)
{
	if(pThis-&gt;pRcvFromIP != NULL)
		prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
	pThis-&gt;pRcvFromIP = new;
}


/* set RcvFrom name in msg object WITHOUT calling AddRef.
 * rgerhards, 2013-01-22
 */
static void MsgSetRcvFromWithoutAddRef(smsg_t *pThis, prop_t *new)
{
	assert(pThis != NULL);

	if(pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
		if(pThis-&gt;rcvFrom.pfrominet != NULL)
			free(pThis-&gt;rcvFrom.pfrominet);
		pThis-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
	} else {
		if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
			prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
	}
	pThis-&gt;rcvFrom.pRcvFrom = new;
}


/* rgerhards 2012-04-18: set associated ruleset (by ruleset name)
 * pRuleset pointer inside msg is updated. If ruleset cannot be found,
 * no update is done and an error message emitted.
 */
static void ATTR_NONNULL()
MsgSetRulesetByName(smsg_t * const pMsg, cstr_t *const rulesetName)
{
	uchar *const rs_name = rsCStrGetSzStrNoNULL(rulesetName);
	const rsRetVal localRet =
		 rulesetGetRuleset(runConf, &amp;(pMsg-&gt;pRuleset), rs_name);

	if(localRet != RS_RET_OK) {
		LogError(0, localRet, &quot;msg: ruleset '%s' could not be found and could not &quot;
			&quot;be assigned to message object. This possibly leads to the message &quot;
			&quot;being processed incorrectly. We cannot do anything against this, but &quot;
			&quot;wanted to let you know.&quot;, rs_name);
	}
}

/* do a DNS reverse resolution, if not already done, reflect status
 * rgerhards, 2009-11-16
 */
static rsRetVal
resolveDNS(smsg_t * const pMsg) {
	rsRetVal localRet;
	prop_t *propFromHost = NULL;
	prop_t *ip;
	prop_t *localName;
	DEFiRet;

	MsgLock(pMsg);
	CHKiRet(objUse(net, CORE_COMPONENT));
	if(pMsg-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
		if (pMsg-&gt;msgFlags &amp; PRESERVE_CASE) {
			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, NULL, &amp;localName, &amp;ip);
		} else {
			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, &amp;localName, NULL, &amp;ip);
		}
		if(localRet == RS_RET_OK) {
			/* we pass down the props, so no need for AddRef */
			MsgSetRcvFromWithoutAddRef(pMsg, localName);
			MsgSetRcvFromIPWithoutAddRef(pMsg, ip);
		}
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		/* best we can do: remove property */
		MsgSetRcvFromStr(pMsg, UCHAR_CONSTANT(&quot;&quot;), 0, &amp;propFromHost);
		prop.Destruct(&amp;propFromHost);
	}
	MsgUnlock(pMsg);
	if(propFromHost != NULL)
		prop.Destruct(&amp;propFromHost);
	RETiRet;
}


void
getInputName(const smsg_t * const pM, uchar **ppsz, int *const plen)
{
	if(pM == NULL || pM-&gt;pInputName == NULL) {
		*ppsz = UCHAR_CONSTANT(&quot;&quot;);
		*plen = 0;
	} else {
		prop.GetString(pM-&gt;pInputName, ppsz, plen);
	}
}


static uchar*
getRcvFromIP(smsg_t * const pM)
{
	uchar *psz;
	int len;
	if(pM == NULL) {
		psz = UCHAR_CONSTANT(&quot;&quot;);
	} else {
		resolveDNS(pM); /* make sure we have a resolved entry */
		if(pM-&gt;pRcvFromIP == NULL)
			psz = UCHAR_CONSTANT(&quot;&quot;);
		else
			prop.GetString(pM-&gt;pRcvFromIP, &amp;psz, &amp;len);
	}
	return psz;
}


/* map a property name (string) to a property ID */
rsRetVal
propNameToID(const uchar *const pName, propid_t *const pPropID)
{
	DEFiRet;

	/* sometimes there are aliases to the original MonitoWare
	 * property names. These come after || in the ifs below. */
	if(!strcasecmp((char*) pName, &quot;msg&quot;)) {
		*pPropID = PROP_MSG;
	} else if(!strcasecmp((char*) pName, &quot;timestamp&quot;)
		  || !strcasecmp((char*) pName, &quot;timereported&quot;)) {
		*pPropID = PROP_TIMESTAMP;
	} else if(!strcasecmp((char*) pName, &quot;hostname&quot;) || !strcasecmp((char*) pName, &quot;source&quot;)) {
		*pPropID = PROP_HOSTNAME;
	} else if(!strcasecmp((char*) pName, &quot;syslogtag&quot;)) {
		*pPropID = PROP_SYSLOGTAG;
	} else if(!strcasecmp((char*) pName, &quot;rawmsg&quot;)) {
		*pPropID = PROP_RAWMSG;
	} else if(!strcasecmp((char*) pName, &quot;rawmsg-after-pri&quot;)) {
		*pPropID = PROP_RAWMSG_AFTER_PRI;
	} else if(!strcasecmp((char*) pName, &quot;inputname&quot;)) {
		*pPropID = PROP_INPUTNAME;
	} else if(!strcasecmp((char*) pName, &quot;fromhost&quot;)) {
		*pPropID = PROP_FROMHOST;
	} else if(!strcasecmp((char*) pName, &quot;fromhost-ip&quot;)) {
		*pPropID = PROP_FROMHOST_IP;
	} else if(!strcasecmp((char*) pName, &quot;pri&quot;)) {
		*pPropID = PROP_PRI;
	} else if(!strcasecmp((char*) pName, &quot;pri-text&quot;)) {
		*pPropID = PROP_PRI_TEXT;
	} else if(!strcasecmp((char*) pName, &quot;iut&quot;)) {
		*pPropID = PROP_IUT;
	} else if(!strcasecmp((char*) pName, &quot;syslogfacility&quot;)) {
		*pPropID = PROP_SYSLOGFACILITY;
	} else if(!strcasecmp((char*) pName, &quot;syslogfacility-text&quot;)) {
		*pPropID = PROP_SYSLOGFACILITY_TEXT;
	} else if(!strcasecmp((char*) pName, &quot;syslogseverity&quot;) || !strcasecmp((char*) pName, &quot;syslogpriority&quot;)) {
		*pPropID = PROP_SYSLOGSEVERITY;
	} else if(!strcasecmp((char*) pName, &quot;syslogseverity-text&quot;) ||
	!strcasecmp((char*) pName, &quot;syslogpriority-text&quot;)) {
		*pPropID = PROP_SYSLOGSEVERITY_TEXT;
	} else if(!strcasecmp((char*) pName, &quot;timegenerated&quot;)) {
		*pPropID = PROP_TIMEGENERATED;
	} else if(!strcasecmp((char*) pName, &quot;programname&quot;)) {
		*pPropID = PROP_PROGRAMNAME;
	} else if(!strcasecmp((char*) pName, &quot;protocol-version&quot;)) {
		*pPropID = PROP_PROTOCOL_VERSION;
	} else if(!strcasecmp((char*) pName, &quot;structured-data&quot;)) {
		*pPropID = PROP_STRUCTURED_DATA;
	} else if(!strcasecmp((char*) pName, &quot;app-name&quot;)) {
		*pPropID = PROP_APP_NAME;
	} else if(!strcasecmp((char*) pName, &quot;procid&quot;)) {
		*pPropID = PROP_PROCID;
	} else if(!strcasecmp((char*) pName, &quot;msgid&quot;)) {
		*pPropID = PROP_MSGID;
	} else if(!strcasecmp((char*) pName, &quot;jsonmesg&quot;)) {
		*pPropID = PROP_JSONMESG;
	} else if(!strcasecmp((char*) pName, &quot;parsesuccess&quot;)) {
		*pPropID = PROP_PARSESUCCESS;
#ifdef USE_LIBUUID
	} else if(!strcasecmp((char*) pName, &quot;uuid&quot;)) {
		*pPropID = PROP_UUID;
#endif
	/* here start system properties (those, that do not relate to the message itself */
	} else if(!strcasecmp((char*) pName, &quot;$NOW&quot;)) {
		*pPropID = PROP_SYS_NOW;
	} else if(!strcasecmp((char*) pName, &quot;$YEAR&quot;)) {
		*pPropID = PROP_SYS_YEAR;
	} else if(!strcasecmp((char*) pName, &quot;$MONTH&quot;)) {
		*pPropID = PROP_SYS_MONTH;
	} else if(!strcasecmp((char*) pName, &quot;$DAY&quot;)) {
		*pPropID = PROP_SYS_DAY;
	} else if(!strcasecmp((char*) pName, &quot;$HOUR&quot;)) {
		*pPropID = PROP_SYS_HOUR;
	} else if(!strcasecmp((char*) pName, &quot;$HHOUR&quot;)) {
		*pPropID = PROP_SYS_HHOUR;
	} else if(!strcasecmp((char*) pName, &quot;$QHOUR&quot;)) {
		*pPropID = PROP_SYS_QHOUR;
	} else if(!strcasecmp((char*) pName, &quot;$MINUTE&quot;)) {
		*pPropID = PROP_SYS_MINUTE;
	} else if(!strcasecmp((char*) pName, &quot;$WDAY&quot;)) {
		*pPropID = PROP_SYS_WDAY;
	} else if(!strcasecmp((char*) pName, &quot;$now-utc&quot;)) {
		*pPropID = PROP_SYS_NOW_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$year-utc&quot;)) {
		*pPropID = PROP_SYS_YEAR_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$month-utc&quot;)) {
		*pPropID = PROP_SYS_MONTH_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$day-utc&quot;)) {
		*pPropID = PROP_SYS_DAY_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$hour-utc&quot;)) {
		*pPropID = PROP_SYS_HOUR_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$hhour-utc&quot;)) {
		*pPropID = PROP_SYS_HHOUR_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$qhour-utc&quot;)) {
		*pPropID = PROP_SYS_QHOUR_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$minute-utc&quot;)) {
		*pPropID = PROP_SYS_MINUTE_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$wday-utc&quot;)) {
		*pPropID = PROP_SYS_WDAY_UTC;
	} else if(!strcasecmp((char*) pName, &quot;$now-unixtimestamp&quot;)) {
		*pPropID = PROP_SYS_NOW_UXTIMESTAMP;
	} else if(!strcasecmp((char*) pName, &quot;$MYHOSTNAME&quot;)) {
		*pPropID = PROP_SYS_MYHOSTNAME;
	} else if(!strcasecmp((char*) pName, &quot;$!all-json&quot;)) {
		*pPropID = PROP_CEE_ALL_JSON;
	} else if(!strcasecmp((char*) pName, &quot;$!all-json-plain&quot;)) {
		*pPropID = PROP_CEE_ALL_JSON_PLAIN;
	} else if(!strcasecmp((char*) pName, &quot;$BOM&quot;)) {
		*pPropID = PROP_SYS_BOM;
	} else if(!strcasecmp((char*) pName, &quot;$UPTIME&quot;)) {
		*pPropID = PROP_SYS_UPTIME;
	} else if(!strncmp((char*) pName, &quot;$!&quot;, 2) || pName[0] == '!') {
		*pPropID = PROP_CEE;
	} else if(!strncmp((char*) pName, &quot;$.&quot;, 2) || pName[0] == '.') {
		*pPropID = PROP_LOCAL_VAR;
	} else if(!strncmp((char*) pName, &quot;$/&quot;, 2) || pName[0] == '/') {
		*pPropID = PROP_GLOBAL_VAR;
	} else {
		DBGPRINTF(&quot;PROP_INVALID for name '%s'\n&quot;, pName);
		*pPropID = PROP_INVALID;
		iRet = RS_RET_VAR_NOT_FOUND;
	}

	RETiRet;
}

<A NAME="0"></A>
/* map a property ID to a name string (useful for displaying) */
uchar *propIDToName(propid_t propID)
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4362-0.html#0',2,'match4362-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
	switch(propID) {
		case PROP_MSG:
			return UCHAR_CONSTANT(&quot;msg&quot;);
		case PROP_TIMESTAMP:
			return UCHAR_CONSTANT(&quot;timestamp&quot;);
		case PROP_HOSTNAME:
			return UCHAR_CONSTANT(&quot;hostname&quot;);
		case PROP_SYSLOGTAG:
			return UCHAR_CONSTANT(&quot;syslogtag&quot;);
		case PROP_RAWMSG:
			return UCHAR_CONSTANT(&quot;rawmsg&quot;);</B></FONT>
		case PROP_RAWMSG_AFTER_PRI:
			return UCHAR_CONSTANT(&quot;rawmsg-after-pri&quot;);
		case PROP_INPUTNAME:
			return UCHAR_CONSTANT(&quot;inputname&quot;);
		case PROP_FROMHOST:
			return UCHAR_CONSTANT(&quot;fromhost&quot;);
		case PROP_FROMHOST_IP:
			return UCHAR_CONSTANT(&quot;fromhost-ip&quot;);
		case PROP_PRI:
			return UCHAR_CONSTANT(&quot;pri&quot;);
		case PROP_PRI_TEXT:
			return UCHAR_CONSTANT(&quot;pri-text&quot;);
		case PROP_IUT:
			return UCHAR_CONSTANT(&quot;iut&quot;);
		case PROP_SYSLOGFACILITY:
			return UCHAR_CONSTANT(&quot;syslogfacility&quot;);
		case PROP_SYSLOGFACILITY_TEXT:
			return UCHAR_CONSTANT(&quot;syslogfacility-text&quot;);
		case PROP_SYSLOGSEVERITY:
			return UCHAR_CONSTANT(&quot;syslogseverity&quot;);
		case PROP_SYSLOGSEVERITY_TEXT:
			return UCHAR_CONSTANT(&quot;syslogseverity-text&quot;);
		case PROP_TIMEGENERATED:
			return UCHAR_CONSTANT(&quot;timegenerated&quot;);
		case PROP_PROGRAMNAME:
			return UCHAR_CONSTANT(&quot;programname&quot;);
		case PROP_PROTOCOL_VERSION:
			return UCHAR_CONSTANT(&quot;protocol-version&quot;);
		case PROP_STRUCTURED_DATA:
			return UCHAR_CONSTANT(&quot;structured-data&quot;);
		case PROP_APP_NAME:
			return UCHAR_CONSTANT(&quot;app-name&quot;);
		case PROP_PROCID:
			return UCHAR_CONSTANT(&quot;procid&quot;);
		case PROP_MSGID:
			return UCHAR_CONSTANT(&quot;msgid&quot;);
		case PROP_JSONMESG:
			return UCHAR_CONSTANT(&quot;jsonmesg&quot;);
		case PROP_PARSESUCCESS:
			return UCHAR_CONSTANT(&quot;parsesuccess&quot;);
#ifdef USE_LIBUUID
		case PROP_UUID:
			return UCHAR_CONSTANT(&quot;uuid&quot;);
#endif
		case PROP_SYS_NOW:
			return UCHAR_CONSTANT(&quot;$NOW&quot;);
		case PROP_SYS_YEAR:
			return UCHAR_CONSTANT(&quot;$YEAR&quot;);
		case PROP_SYS_MONTH:
			return UCHAR_CONSTANT(&quot;$MONTH&quot;);
		case PROP_SYS_DAY:
			return UCHAR_CONSTANT(&quot;$DAY&quot;);
		case PROP_SYS_HOUR:
			return UCHAR_CONSTANT(&quot;$HOUR&quot;);
		case PROP_SYS_HHOUR:
			return UCHAR_CONSTANT(&quot;$HHOUR&quot;);
		case PROP_SYS_QHOUR:
			return UCHAR_CONSTANT(&quot;$QHOUR&quot;);
		case PROP_SYS_MINUTE:
			return UCHAR_CONSTANT(&quot;$MINUTE&quot;);
		case PROP_SYS_NOW_UTC:
			return UCHAR_CONSTANT(&quot;$NOW-UTC&quot;);
		case PROP_SYS_YEAR_UTC:
			return UCHAR_CONSTANT(&quot;$YEAR-UTC&quot;);
		case PROP_SYS_MONTH_UTC:
			return UCHAR_CONSTANT(&quot;$MONTH-UTC&quot;);
		case PROP_SYS_DAY_UTC:
			return UCHAR_CONSTANT(&quot;$DAY-UTC&quot;);
		case PROP_SYS_HOUR_UTC:
			return UCHAR_CONSTANT(&quot;$HOUR-UTC&quot;);
		case PROP_SYS_HHOUR_UTC:
			return UCHAR_CONSTANT(&quot;$HHOUR-UTC&quot;);
		case PROP_SYS_QHOUR_UTC:
			return UCHAR_CONSTANT(&quot;$QHOUR-UTC&quot;);
		case PROP_SYS_MINUTE_UTC:
			return UCHAR_CONSTANT(&quot;$MINUTE-UTC&quot;);
		case PROP_SYS_WDAY:
			return UCHAR_CONSTANT(&quot;$WDAY&quot;);
		case PROP_SYS_WDAY_UTC:
			return UCHAR_CONSTANT(&quot;$WDAY-UTC&quot;);
		case PROP_SYS_NOW_UXTIMESTAMP:
			return UCHAR_CONSTANT(&quot;$NOW-UNIXTIMESTAMP&quot;);
		case PROP_SYS_MYHOSTNAME:
			return UCHAR_CONSTANT(&quot;$MYHOSTNAME&quot;);
		case PROP_CEE_ALL_JSON:
			return UCHAR_CONSTANT(&quot;$!all-json&quot;);
		case PROP_CEE_ALL_JSON_PLAIN:
			return UCHAR_CONSTANT(&quot;$!all-json-plain&quot;);
		case PROP_SYS_BOM:
			return UCHAR_CONSTANT(&quot;$BOM&quot;);
		case PROP_SYS_UPTIME:
			return UCHAR_CONSTANT(&quot;$UPTIME&quot;);
		case PROP_CEE:
			return UCHAR_CONSTANT(&quot;*CEE-based property*&quot;);
		case PROP_LOCAL_VAR:
			return UCHAR_CONSTANT(&quot;*LOCAL_VARIABLE*&quot;);
		case PROP_GLOBAL_VAR:
			return UCHAR_CONSTANT(&quot;*GLOBAL_VARIABLE*&quot;);
		default:
			return UCHAR_CONSTANT(&quot;*invalid property id*&quot;);
	}
}


/* This is common code for all Constructors. It is defined in an
 * inline'able function so that we can save a function call in the
 * actual constructors (otherwise, the msgConstruct would need
 * to call msgConstructWithTime(), which would require a
 * function call). Now, both can use this inline function. This
 * enables us to be optimal, but still have the code just once.
 * the new object or NULL if no such object could be allocated.
 * An object constructed via this function should only be destroyed
 * via &quot;msgDestruct()&quot;. This constructor does not query system time
 * itself but rather uses a user-supplied value. This enables the caller
 * to do some tricks to save processing time (done, for example, in the
 * udp input).
 * NOTE: this constructor does NOT call calloc(), as we have many bytes
 * inside the structure which do not need to be cleared. bzero() will
 * heavily thrash the cache, so we do the init manually (which also
 * is the right thing to do with pointers, as they are not neccessarily
 * a binary 0 on all machines [but today almost always...]).
 * rgerhards, 2008-10-06
 */
static rsRetVal
msgBaseConstruct(smsg_t **ppThis)
{
	DEFiRet;
	smsg_t *pM;

	assert(ppThis != NULL);
	CHKmalloc(pM = malloc(sizeof(smsg_t)));
	objConstructSetObjInfo(pM); /* intialize object helper entities */

	/* initialize members in ORDER they appear in structure (think &quot;cache line&quot;!) */
	pM-&gt;flowCtlType = 0;
	pM-&gt;bParseSuccess = 0;
	pM-&gt;iRefCount = 1;
	pM-&gt;iSeverity = LOG_DEBUG;
	pM-&gt;iFacility = LOG_INVLD;
	pM-&gt;iLenPROGNAME = -1;
	pM-&gt;offAfterPRI = 0;
	pM-&gt;offMSG = -1;
	pM-&gt;iProtocolVersion = 0;
	pM-&gt;msgFlags = 0;
	pM-&gt;iLenRawMsg = 0;
	pM-&gt;iLenMSG = 0;
	pM-&gt;iLenTAG = 0;
	pM-&gt;iLenHOSTNAME = 0;
	pM-&gt;pszRawMsg = NULL;
	pM-&gt;pszHOSTNAME = NULL;
	pM-&gt;pszRcvdAt3164 = NULL;
	pM-&gt;pszRcvdAt3339 = NULL;
	pM-&gt;pszRcvdAt_MySQL = NULL;
	pM-&gt;pszRcvdAt_PgSQL = NULL;
	pM-&gt;pszTIMESTAMP3164 = NULL;
	pM-&gt;pszTIMESTAMP3339 = NULL;
	pM-&gt;pszTIMESTAMP_MySQL = NULL;
	pM-&gt;pszTIMESTAMP_PgSQL = NULL;
	pM-&gt;pszStrucData = NULL;
	pM-&gt;lenStrucData = 0;
	pM-&gt;pCSAPPNAME = NULL;
	pM-&gt;pCSPROCID = NULL;
	pM-&gt;pCSMSGID = NULL;
	pM-&gt;pInputName = NULL;
	pM-&gt;pRcvFromIP = NULL;
	pM-&gt;rcvFrom.pRcvFrom = NULL;
	pM-&gt;pRuleset = NULL;
	pM-&gt;json = NULL;
	pM-&gt;localvars = NULL;
	pM-&gt;dfltTZ[0] = '\0';
	memset(&amp;pM-&gt;tRcvdAt, 0, sizeof(pM-&gt;tRcvdAt));
	memset(&amp;pM-&gt;tTIMESTAMP, 0, sizeof(pM-&gt;tTIMESTAMP));
	pM-&gt;TAG.pszTAG = NULL;
	pM-&gt;pszTimestamp3164[0] = '\0';
	pM-&gt;pszTimestamp3339[0] = '\0';
	pM-&gt;pszTIMESTAMP_SecFrac[0] = '\0';
	pM-&gt;pszRcvdAt_SecFrac[0] = '\0';
	pM-&gt;pszTIMESTAMP_Unix[0] = '\0';
	pM-&gt;pszRcvdAt_Unix[0] = '\0';
	pM-&gt;pszUUID = NULL;
	pthread_mutex_init(&amp;pM-&gt;mut, NULL);

	#if DEV_DEBUG == 1
	dbgprintf(&quot;msgConstruct\t0x%x, ref 1\n&quot;, (int)pM);
	#endif

	*ppThis = pM;

finalize_it:
	RETiRet;
}


/* &quot;Constructor&quot; for a msg &quot;object&quot;. Returns a pointer to
 * the new object or NULL if no such object could be allocated.
 * An object constructed via this function should only be destroyed
 * via &quot;msgDestruct()&quot;. This constructor does not query system time
 * itself but rather uses a user-supplied value. This enables the caller
 * to do some tricks to save processing time (done, for example, in the
 * udp input).
 * rgerhards, 2008-10-06
 */
rsRetVal msgConstructWithTime(smsg_t **ppThis, const struct syslogTime *stTime, const time_t ttGenTime)
{
	DEFiRet;

	CHKiRet(msgBaseConstruct(ppThis));
	(*ppThis)-&gt;ttGenTime = ttGenTime;
	memcpy(&amp;(*ppThis)-&gt;tRcvdAt, stTime, sizeof(struct syslogTime));
	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, stTime, sizeof(struct syslogTime));

finalize_it:
	RETiRet;
}


/* &quot;Constructor&quot; for a msg &quot;object&quot;. Returns a pointer to
 * the new object or NULL if no such object could be allocated.
 * An object constructed via this function should only be destroyed
 * via &quot;msgDestruct()&quot;. This constructor, for historical reasons,
 * also sets the two timestamps to the current time.
 */
rsRetVal msgConstruct(smsg_t **ppThis)
{
	DEFiRet;

	CHKiRet(msgBaseConstruct(ppThis));
	/* we initialize both timestamps to contain the current time, so that they
	 * are consistent. Also, this saves us from doing any further time calls just
	 * to obtain a timestamp. The memcpy() should not really make a difference,
	 * especially as I think there is no codepath currently where it would not be
	 * required (after I have cleaned up the pathes ;)). -- rgerhards, 2008-10-02
	 */
	datetime.getCurrTime(&amp;((*ppThis)-&gt;tRcvdAt), &amp;((*ppThis)-&gt;ttGenTime), TIME_IN_LOCALTIME);
	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, &amp;(*ppThis)-&gt;tRcvdAt, sizeof(struct syslogTime));

finalize_it:
	RETiRet;
}


/* Special msg constructor, to be used when an object is deserialized.
 * we do only the base init as we know the properties will be set in
 * any case by the deserializer. We still do the &quot;inexpensive&quot; inits
 * just to be on the safe side. The whole process needs to be
 * refactored together with the msg serialization subsystem.
 */
rsRetVal
msgConstructForDeserializer(smsg_t **ppThis)
{
	return msgBaseConstruct(ppThis);
}


/* some free handlers for (slightly) complicated cases... All of them may be called
 * with an empty element.
 */
static inline void freeTAG(smsg_t *pThis)
{
	if(pThis-&gt;iLenTAG &gt;= CONF_TAG_BUFSIZE)
		free(pThis-&gt;TAG.pszTAG);
}
static inline void freeHOSTNAME(smsg_t *pThis)
{
	if(pThis-&gt;iLenHOSTNAME &gt;= CONF_HOSTNAME_BUFSIZE)
		free(pThis-&gt;pszHOSTNAME);
}


rsRetVal msgDestruct(smsg_t **ppThis)
{
	DEFiRet;
	smsg_t *pThis;
	int currRefCount;
#	ifdef HAVE_MALLOC_TRIM
	int currCnt;
#	endif
CODESTARTobjDestruct(msg)
	#if DEV_DEBUG == 1
	dbgprintf(&quot;msgDestruct\t0x%lx, &quot;
		&quot;Ref now: %d\n&quot;, (unsigned long)pThis, pThis-&gt;iRefCount - 1);
	#endif
#	ifdef HAVE_ATOMIC_BUILTINS
		currRefCount = ATOMIC_DEC_AND_FETCH(&amp;pThis-&gt;iRefCount, NULL);
#	else
		MsgLock(pThis);
		currRefCount = --pThis-&gt;iRefCount;
# 	endif
	if(currRefCount == 0)
	{
		#if DEV_DEBUG == 1
		dbgprintf(&quot;msgDestruct\t0x%lx, RefCount now 0, doing DESTROY\n&quot;,
			(unsigned long)pThis);
		#endif
		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
			free(pThis-&gt;pszRawMsg);
		freeTAG(pThis);
		freeHOSTNAME(pThis);
		if(pThis-&gt;pInputName != NULL)
			prop.Destruct(&amp;pThis-&gt;pInputName);
		if((pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) == 0) {
			if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
				prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
		} else {
			free(pThis-&gt;rcvFrom.pfrominet);
		}
		if(pThis-&gt;pRcvFromIP != NULL)
			prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
		free(pThis-&gt;pszRcvdAt3164);
		free(pThis-&gt;pszRcvdAt3339);
		free(pThis-&gt;pszRcvdAt_MySQL);
		free(pThis-&gt;pszRcvdAt_PgSQL);
		free(pThis-&gt;pszTIMESTAMP_MySQL);
		free(pThis-&gt;pszTIMESTAMP_PgSQL);
		free(pThis-&gt;pszStrucData);
		if(pThis-&gt;iLenPROGNAME &gt;= CONF_PROGNAME_BUFSIZE)
			free(pThis-&gt;PROGNAME.ptr);
		if(pThis-&gt;pCSAPPNAME != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSAPPNAME);
		if(pThis-&gt;pCSPROCID != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSPROCID);
		if(pThis-&gt;pCSMSGID != NULL)
			rsCStrDestruct(&amp;pThis-&gt;pCSMSGID);
		if(pThis-&gt;json != NULL)
			json_object_put(pThis-&gt;json);
		if(pThis-&gt;localvars != NULL)
			json_object_put(pThis-&gt;localvars);
		if(pThis-&gt;pszUUID != NULL)
			free(pThis-&gt;pszUUID);
#	ifndef HAVE_ATOMIC_BUILTINS
		MsgUnlock(pThis);
# 	endif
		pthread_mutex_destroy(&amp;pThis-&gt;mut);
		/* now we need to do our own optimization. Testing has shown that at least the glibc
		 * malloc() subsystem returns memory to the OS far too late in our case. So we need
		 * to help it a bit, by calling malloc_trim(), which will tell the alloc subsystem
		 * to consolidate and return to the OS. We keep 128K for our use, as a safeguard
		 * to too-frequent reallocs. But more importantly, we call this hook only every
		 * 100,000 messages (which is an approximation, as we do not work with atomic
		 * operations on the counter. --- rgerhards, 2009-06-22.
		 */
#		ifdef HAVE_MALLOC_TRIM
		{	/* standard C requires a new block for a new variable definition!
			 * To simplify matters, we use modulo arithmetic and live with the fact
			 * that we trim too often when the counter wraps.
			 */
			static unsigned iTrimCtr = 1;
			currCnt = ATOMIC_INC_AND_FETCH_unsigned(&amp;iTrimCtr, &amp;mutTrimCtr);
			if(currCnt % 100000 == 0) {
				malloc_trim(128*1024);
			}
		}
#		endif
	} else {
#	ifndef HAVE_ATOMIC_BUILTINS
		MsgUnlock(pThis);
# 	endif
		pThis = NULL; /* tell framework not to destructing the object! */
	}
ENDobjDestruct(msg)

/* The macros below are used in MsgDup(). I use macros
 * to keep the fuction code somewhat more readyble. It is my
 * replacement for inline functions in CPP
 */
#define tmpCOPYSZ(name) \
	if(pOld-&gt;psz##name != NULL) { \
		if((pNew-&gt;psz##name = srUtilStrDup(pOld-&gt;psz##name, pOld-&gt;iLen##name)) == NULL) {\
			msgDestruct(&amp;pNew);\
			return NULL;\
		}\
		pNew-&gt;iLen##name = pOld-&gt;iLen##name;\
	}

/* copy the CStr objects.
 * if the old value is NULL, we do not need to do anything because we
 * initialized the new value to NULL via calloc().
 */
#define tmpCOPYCSTR(name) \
	if(pOld-&gt;pCS##name != NULL) {\
		if(rsCStrConstructFromCStr(&amp;(pNew-&gt;pCS##name), pOld-&gt;pCS##name) != RS_RET_OK) {\
			msgDestruct(&amp;pNew);\
			return NULL;\
		}\
		cstrFinalize(pNew-&gt;pCS##name); \
	}
/* Constructs a message object by duplicating another one.
 * Returns NULL if duplication failed. We do not need to lock the
 * message object here, because a fully-created msg object is never
 * allowed to be manipulated. For this, MsgDup() must be used, so MsgDup()
 * can never run into a situation where the message object is being
 * modified while its content is copied - it's forbidden by definition.
 * rgerhards, 2007-07-10
 */
smsg_t* MsgDup(smsg_t* pOld)
{
	smsg_t* pNew;
	rsRetVal localRet;

	assert(pOld != NULL);

	if(msgConstructWithTime(&amp;pNew, &amp;pOld-&gt;tTIMESTAMP, pOld-&gt;ttGenTime) != RS_RET_OK) {
		return NULL;
	}

	/* now copy the message properties */
	pNew-&gt;iRefCount = 1;
	pNew-&gt;iSeverity = pOld-&gt;iSeverity;
	pNew-&gt;iFacility = pOld-&gt;iFacility;
	pNew-&gt;msgFlags = pOld-&gt;msgFlags;
	pNew-&gt;iProtocolVersion = pOld-&gt;iProtocolVersion;
	pNew-&gt;tRcvdAt = pOld-&gt;tRcvdAt;
	pNew-&gt;offMSG = pOld-&gt;offMSG;
	pNew-&gt;iLenRawMsg = pOld-&gt;iLenRawMsg;
	pNew-&gt;iLenMSG = pOld-&gt;iLenMSG;
	pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
	pNew-&gt;iLenHOSTNAME = pOld-&gt;iLenHOSTNAME;
	if((pOld-&gt;msgFlags &amp; NEEDS_DNSRESOL)) {
			localRet = msgSetFromSockinfo(pNew, pOld-&gt;rcvFrom.pfrominet);
			if(localRet != RS_RET_OK) {
				/* if something fails, we accept loss of this property, it is
				 * better than losing the whole message.
				 */
				pNew-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
				pNew-&gt;rcvFrom.pRcvFrom = NULL; /* make sure no dangling values */
			}
	} else {
		if(pOld-&gt;rcvFrom.pRcvFrom != NULL) {
			pNew-&gt;rcvFrom.pRcvFrom = pOld-&gt;rcvFrom.pRcvFrom;
			prop.AddRef(pNew-&gt;rcvFrom.pRcvFrom);
		}
	}
	if(pOld-&gt;pRcvFromIP != NULL) {
		pNew-&gt;pRcvFromIP = pOld-&gt;pRcvFromIP;
		prop.AddRef(pNew-&gt;pRcvFromIP);
	}
	if(pOld-&gt;pInputName != NULL) {
		pNew-&gt;pInputName = pOld-&gt;pInputName;
		prop.AddRef(pNew-&gt;pInputName);
	}
	if(pOld-&gt;iLenTAG &gt; 0) {
		if(pOld-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
			memcpy(pNew-&gt;TAG.szBuf, pOld-&gt;TAG.szBuf, pOld-&gt;iLenTAG + 1);
		} else {
			if((pNew-&gt;TAG.pszTAG = srUtilStrDup(pOld-&gt;TAG.pszTAG, pOld-&gt;iLenTAG)) == NULL) {
				msgDestruct(&amp;pNew);
				return NULL;
			}
			pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
		}
	}
	if(pOld-&gt;pszRawMsg == pOld-&gt;szRawMsg) {
		memcpy(pNew-&gt;szRawMsg, pOld-&gt;szRawMsg, pOld-&gt;iLenRawMsg + 1);
		pNew-&gt;pszRawMsg = pNew-&gt;szRawMsg;
	} else {
		tmpCOPYSZ(RawMsg);
	}
	if(pOld-&gt;pszHOSTNAME == NULL) {
		pNew-&gt;pszHOSTNAME = NULL;
	} else {
		if(pOld-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
			memcpy(pNew-&gt;szHOSTNAME, pOld-&gt;szHOSTNAME, pOld-&gt;iLenHOSTNAME + 1);
			pNew-&gt;pszHOSTNAME = pNew-&gt;szHOSTNAME;
		} else {
			tmpCOPYSZ(HOSTNAME);
		}
	}
	if(pOld-&gt;pszStrucData == NULL) {
		pNew-&gt;pszStrucData = NULL;
	} else {
		pNew-&gt;pszStrucData = (uchar*)strdup((char*)pOld-&gt;pszStrucData);
		pNew-&gt;lenStrucData = pOld-&gt;lenStrucData;
	}

	tmpCOPYCSTR(APPNAME);
	tmpCOPYCSTR(PROCID);
	tmpCOPYCSTR(MSGID);

	if(pOld-&gt;json != NULL)
		pNew-&gt;json = jsonDeepCopy(pOld-&gt;json);
	if(pOld-&gt;localvars != NULL)
		pNew-&gt;localvars = jsonDeepCopy(pOld-&gt;localvars);

	/* we do not copy all other cache properties, as we do not even know
	 * if they are needed once again. So we let them re-create if needed.
	 */

	return pNew;
}
#undef tmpCOPYSZ
#undef tmpCOPYCSTR


/* This method serializes a message object. That means the whole
 * object is modified into text form. That text form is suitable for
 * later reconstruction of the object by calling MsgDeSerialize().
 * The most common use case for this method is the creation of an
 * on-disk representation of the message object.
 * We do not serialize the cache properties. We re-create them when needed.
 * This saves us a lot of memory. Performance is no concern, as serializing
 * is a so slow operation that recration of the caches does not count. Also,
 * we do not serialize --currently none--, as this is only a helper variable
 * during msg construction - and never again used later.
 * rgerhards, 2008-01-03
 */
static rsRetVal MsgSerialize(smsg_t *pThis, strm_t *pStrm)
{
	uchar *psz;
	int len;
	DEFiRet;

	assert(pThis != NULL);
	assert(pStrm != NULL);

	/* then serialize elements */
	CHKiRet(obj.BeginSerialize(pStrm, (obj_t*) pThis));
	objSerializeSCALAR(pStrm, iProtocolVersion, SHORT);
	objSerializeSCALAR(pStrm, iSeverity, SHORT);
	objSerializeSCALAR(pStrm, iFacility, SHORT);
	objSerializeSCALAR(pStrm, msgFlags, INT);
	objSerializeSCALAR(pStrm, ttGenTime, INT);
	objSerializeSCALAR(pStrm, tRcvdAt, SYSLOGTIME);
	objSerializeSCALAR(pStrm, tTIMESTAMP, SYSLOGTIME);

	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszTAG&quot;), PROPTYPE_PSZ, (void*)
		((pThis-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pThis-&gt;TAG.szBuf : pThis-&gt;TAG.pszTAG)));

	objSerializePTR(pStrm, pszRawMsg, PSZ);
	objSerializePTR(pStrm, pszHOSTNAME, PSZ);
	getInputName(pThis, &amp;psz, &amp;len);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszInputName&quot;), PROPTYPE_PSZ, (void*) psz));
	psz = getRcvFrom(pThis);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszRcvFrom&quot;), PROPTYPE_PSZ, (void*) psz));
	psz = getRcvFromIP(pThis);
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszRcvFromIP&quot;), PROPTYPE_PSZ, (void*) psz));
	psz = pThis-&gt;pszStrucData;
	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszStrucData&quot;), PROPTYPE_PSZ, (void*) psz));
	if(pThis-&gt;json != NULL) {
		MsgLock(pThis);
		psz = (uchar*) json_object_get_string(pThis-&gt;json);
		MsgUnlock(pThis);
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;json&quot;), PROPTYPE_PSZ, (void*) psz));
	}
	if(pThis-&gt;localvars != NULL) {
		MsgLock(pThis);
		psz = (uchar*) json_object_get_string(pThis-&gt;localvars);
		MsgUnlock(pThis);
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;localvars&quot;), PROPTYPE_PSZ, (void*) psz));
	}

	objSerializePTR(pStrm, pCSAPPNAME, CSTR);
	objSerializePTR(pStrm, pCSPROCID, CSTR);
	objSerializePTR(pStrm, pCSMSGID, CSTR);

	objSerializePTR(pStrm, pszUUID, PSZ);

	if(pThis-&gt;pRuleset != NULL) {
		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT(&quot;pszRuleset&quot;), PROPTYPE_PSZ,
			rulesetGetName(pThis-&gt;pRuleset)));
	}

	/* offset must be serialized after pszRawMsg, because we need that to obtain the correct
	 * MSG size.
	 */
	objSerializeSCALAR(pStrm, offMSG, INT);

	CHKiRet(obj.EndSerialize(pStrm));

finalize_it:
	RETiRet;
}


/* This is a helper for MsgDeserialize that re-inits the var object. This
 * whole construct should be replaced, var is really ready to be retired.
 * But as an interim help during refactoring let's introduce this function
 * here (and thus NOT as method of var object!). -- rgerhads, 2012-11-06
 */
static void
reinitVar(var_t *pVar)
{
	rsCStrDestruct(&amp;pVar-&gt;pcsName); /* no longer needed */
	if(pVar-&gt;varType == VARTYPE_STR) {
		if(pVar-&gt;val.pStr != NULL)
			rsCStrDestruct(&amp;pVar-&gt;val.pStr);
	}
}
/* deserialize the message again
 * we deserialize the properties in the same order that we serialized them. Except
 * for some checks to cover downlevel version, we do not need to do all these
 * CPU intense name checkings.
 */
#define isProp(name) !rsCStrSzStrCmp(pVar-&gt;pcsName, (uchar*) name, sizeof(name) - 1)
rsRetVal
MsgDeserialize(smsg_t * const pMsg, strm_t *pStrm)
{
	prop_t *myProp;
	prop_t *propRcvFrom = NULL;
	prop_t *propRcvFromIP = NULL;
	struct json_tokener *tokener;
	var_t *pVar = NULL;
	DEFiRet;

	ISOBJ_TYPE_assert(pStrm, strm);

	CHKiRet(var.Construct(&amp;pVar));
	CHKiRet(var.ConstructFinalize(pVar));

	CHKiRet(objDeserializeProperty(pVar, pStrm));
	if(isProp(&quot;iProtocolVersion&quot;)) {
		setProtocolVersion(pMsg, pVar-&gt;val.num);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;iSeverity&quot;)) {
		pMsg-&gt;iSeverity = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;iFacility&quot;)) {
		pMsg-&gt;iFacility = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;msgFlags&quot;)) {
		pMsg-&gt;msgFlags = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;ttGenTime&quot;)) {
		pMsg-&gt;ttGenTime = pVar-&gt;val.num;
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;tRcvdAt&quot;)) {
		memcpy(&amp;pMsg-&gt;tRcvdAt, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;tTIMESTAMP&quot;)) {
		memcpy(&amp;pMsg-&gt;tTIMESTAMP, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszTAG&quot;)) {
		MsgSetTAG(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszRawMsg&quot;)) {
		MsgSetRawMsg(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszHOSTNAME&quot;)) {
		MsgSetHOSTNAME(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszInputName&quot;)) {
		/* we need to create a property */
		CHKiRet(prop.Construct(&amp;myProp));
		CHKiRet(prop.SetString(myProp, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr)));
		CHKiRet(prop.ConstructFinalize(myProp));
		MsgSetInputName(pMsg, myProp);
		prop.Destruct(&amp;myProp);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszRcvFrom&quot;)) {
		MsgSetRcvFromStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr), &amp;propRcvFrom);
		prop.Destruct(&amp;propRcvFrom);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszRcvFromIP&quot;)) {
		MsgSetRcvFromIPStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr),
			&amp;propRcvFromIP);
		prop.Destruct(&amp;propRcvFromIP);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszStrucData&quot;)) {
		MsgSetStructuredData(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;json&quot;)) {
		tokener = json_tokener_new();
		pMsg-&gt;json = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
					     cstrLen(pVar-&gt;val.pStr));
		json_tokener_free(tokener);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;localvars&quot;)) {
		tokener = json_tokener_new();
		pMsg-&gt;localvars = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
						        cstrLen(pVar-&gt;val.pStr));
		json_tokener_free(tokener);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pCSAPPNAME&quot;)) {
		MsgSetAPPNAME(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pCSPROCID&quot;)) {
		MsgSetPROCID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pCSMSGID&quot;)) {
		MsgSetMSGID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszUUID&quot;)) {
		pMsg-&gt;pszUUID = ustrdup(rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	if(isProp(&quot;pszRuleset&quot;)) {
		MsgSetRulesetByName(pMsg, pVar-&gt;val.pStr);
		reinitVar(pVar);
		CHKiRet(objDeserializeProperty(pVar, pStrm));
	}
	/* &quot;offMSG&quot; must always be our last field, so we use this as an
	 * indicator if the sequence is correct. This is a bit questionable,
	 * but on the other hand it works decently AND we will probably replace
	 * the whole persisted format soon in any case. -- rgerhards, 2012-11-06
	 */
	if(!isProp(&quot;offMSG&quot;)) {
		DBGPRINTF(&quot;error property: %s\n&quot;, rsCStrGetSzStrNoNULL(pVar-&gt;pcsName));
		ABORT_FINALIZE(RS_RET_DS_PROP_SEQ_ERR);
	}
	MsgSetMSGoffs(pMsg, pVar-&gt;val.num);
finalize_it:
	if(pVar != NULL)
		var.Destruct(&amp;pVar);
	if(Debug &amp;&amp; iRet != RS_RET_OK) {
		dbgprintf(&quot;MsgDeserialize error %d\n&quot;, iRet);
	}
	RETiRet;
}
#undef isProp


/* Increment reference count - see description of the &quot;msg&quot;
 * structure for details. As a convenience to developers,
 * this method returns the msg pointer that is passed to it.
 * It is recommended that it is called as follows:
 *
 * pSecondMsgPointer = MsgAddRef(pOrgMsgPointer);
 */
smsg_t *MsgAddRef(smsg_t * const pM)
{
	assert(pM != NULL);
#	ifdef HAVE_ATOMIC_BUILTINS
		ATOMIC_INC(&amp;pM-&gt;iRefCount, NULL);
#	else
		MsgLock(pM);
		pM-&gt;iRefCount++;
		MsgUnlock(pM);
#	endif
	#if DEV_DEBUG == 1
	dbgprintf(&quot;MsgAddRef\t0x%x done, Ref now: %d\n&quot;, (int)pM, pM-&gt;iRefCount);
	#endif
	return(pM);
}


/* This functions tries to acquire the PROCID from TAG. Its primary use is
 * when a legacy syslog message has been received and should be forwarded as
 * syslog-protocol (or the PROCID is requested for any other reason).
 * In legacy syslog, the PROCID is considered to be the character sequence
 * between the first [ and the first ]. This usually are digits only, but we
 * do not check that. However, if there is no closing ], we do not assume we
 * can obtain a PROCID. Take in mind that not every legacy syslog message
 * actually has a PROCID.
 * rgerhards, 2005-11-24
 * THIS MUST be called with the message lock locked.
 */
static rsRetVal acquirePROCIDFromTAG(smsg_t * const pM)
{
	register int i;
	uchar *pszTag;
	DEFiRet;

	assert(pM != NULL);

	if(pM-&gt;pCSPROCID != NULL)
		return RS_RET_OK; /* we are already done ;) */

	if(msgGetProtocolVersion(pM) != 0)
		return RS_RET_OK; /* we can only emulate if we have legacy format */

	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);

	/* find first '['... */
	i = 0;
	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != '['))
		++i;
	if(!(i &lt; pM-&gt;iLenTAG))
		return RS_RET_OK;	/* no [, so can not emulate... */

	++i; /* skip '[' */

	/* now obtain the PROCID string... */
	CHKiRet(cstrConstruct(&amp;pM-&gt;pCSPROCID));
	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != ']')) {
		CHKiRet(cstrAppendChar(pM-&gt;pCSPROCID, pszTag[i]));
		++i;
	}

	if(!(i &lt; pM-&gt;iLenTAG)) {
		/* oops... it looked like we had a PROCID, but now it has
		 * turned out this is not true. In this case, we need to free
		 * the buffer and simply return. Note that this is NOT an error
		 * case!
		 */
		cstrDestruct(&amp;pM-&gt;pCSPROCID);
		FINALIZE;
	}

	/* OK, finally we could obtain a PROCID. So let's use it ;) */
	cstrFinalize(pM-&gt;pCSPROCID);

finalize_it:
	RETiRet;
}


/* Parse and set the &quot;programname&quot; for a given MSG object. Programname
 * is a BSD concept, it is the tag without any instance-specific information.
 * Precisely, the programname is terminated by either (whichever occurs first):
 * - end of tag
 * - nonprintable character
 * - ':'
 * - '['
 * - '/'
 * The above definition has been taken from the FreeBSD syslogd sources.
 *
 * The program name is not parsed by default, because it is infrequently-used.
 * IMPORTANT: A locked message object must be provided, else a crash will occur.
 * rgerhards, 2005-10-19
 */
static rsRetVal
acquireProgramName(smsg_t * const pM)
{
	int i;
	uchar *pszTag, *pszProgName;
	DEFiRet;

	assert(pM != NULL);
	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);
	for(  i = 0
	    ; (i &lt; pM-&gt;iLenTAG) &amp;&amp; isprint((int) pszTag[i])
	      &amp;&amp; (pszTag[i] != '\0') &amp;&amp; (pszTag[i] != ':')
	      &amp;&amp; (pszTag[i] != '[')
	      &amp;&amp; (runConf-&gt;globals.parser.bPermitSlashInProgramname || (pszTag[i] != '/'))
	    ; ++i)
		; /* just search end of PROGNAME */
	if(i &lt; CONF_PROGNAME_BUFSIZE) {
		pszProgName = pM-&gt;PROGNAME.szBuf;
	} else {
		CHKmalloc(pM-&gt;PROGNAME.ptr = malloc(i+1));
		pszProgName = pM-&gt;PROGNAME.ptr;
	}
	memcpy((char*)pszProgName, (char*)pszTag, i);
	pszProgName[i] = '\0';
	pM-&gt;iLenPROGNAME = i;
finalize_it:
	RETiRet;
}


/* Access methods - dumb &amp; easy, not a comment for each ;)
 */
void setProtocolVersion(smsg_t * const pM, int iNewVersion)
{
	assert(pM != NULL);
	if(iNewVersion != 0 &amp;&amp; iNewVersion != 1) {
		dbgprintf(&quot;Tried to set unsupported protocol version %d - changed to 0.\n&quot;, iNewVersion);
		iNewVersion = 0;
	}
	pM-&gt;iProtocolVersion = iNewVersion;
}

/* note: string is taken from constant pool, do NOT free */
static const char *getProtocolVersionString(smsg_t * const pM)
{
	assert(pM != NULL);
	return(pM-&gt;iProtocolVersion ? &quot;1&quot; : &quot;0&quot;);
}

void
msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri)
{
	if(pri &gt; LOG_MAXPRI)
		pri = LOG_PRI_INVLD;
	pMsg-&gt;iFacility = pri2fac(pri),
	pMsg-&gt;iSeverity = pri2sev(pri);
}

#ifdef USE_LIBUUID
/* note: libuuid seems not to be thread-safe, so we need
 * to get some safeguards in place.
 */
static void msgSetUUID(smsg_t * const pM)
{
	size_t lenRes = sizeof(uuid_t) * 2 + 1;
	char hex_char [] = &quot;0123456789ABCDEF&quot;;
	unsigned int byte_nbr;
	uuid_t uuid;
	static pthread_mutex_t mutUUID = PTHREAD_MUTEX_INITIALIZER;

	dbgprintf(&quot;[MsgSetUUID] START, lenRes %llu\n&quot;, (long long unsigned) lenRes);
	assert(pM != NULL);

	if((pM-&gt;pszUUID = (uchar*) malloc(lenRes)) == NULL) {
		pM-&gt;pszUUID = (uchar *)&quot;&quot;;
	} else {
		pthread_mutex_lock(&amp;mutUUID);
		uuid_generate(uuid);
		pthread_mutex_unlock(&amp;mutUUID);
		for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
			pM-&gt;pszUUID[byte_nbr * 2 + 0] = hex_char[uuid [byte_nbr] &gt;&gt; 4];
			pM-&gt;pszUUID[byte_nbr * 2 + 1] = hex_char[uuid [byte_nbr] &amp; 15];
		}

		pM-&gt;pszUUID[lenRes-1] = '\0';
		dbgprintf(&quot;[MsgSetUUID] UUID : %s LEN: %d \n&quot;, pM-&gt;pszUUID, (int)lenRes);
	}
	dbgprintf(&quot;[MsgSetUUID] END\n&quot;);
}

static void getUUID(smsg_t * const pM, uchar **pBuf, int *piLen)
{
	dbgprintf(&quot;[getUUID] START\n&quot;);
	if(pM == NULL) {
		dbgprintf(&quot;[getUUID] pM is NULL\n&quot;);
		*pBuf=	UCHAR_CONSTANT(&quot;&quot;);
		*piLen = 0;
	} else {
		if(pM-&gt;pszUUID == NULL) {
			dbgprintf(&quot;[getUUID] pM-&gt;pszUUID is NULL\n&quot;);
			MsgLock(pM);
			/* re-query, things may have changed in the mean time... */
			if(pM-&gt;pszUUID == NULL)
				msgSetUUID(pM);
			MsgUnlock(pM);
		} else { /* UUID already there we reuse it */
			dbgprintf(&quot;[getUUID] pM-&gt;pszUUID already exists\n&quot;);
		}
		*pBuf = pM-&gt;pszUUID;
		*piLen = sizeof(uuid_t) * 2;
	}
	dbgprintf(&quot;[getUUID] END\n&quot;);
}
#endif

int ATTR_NONNULL()
getRawMsgLen(const smsg_t *const pMsg)
{
	return (pMsg-&gt;pszRawMsg == NULL) ?  0 : pMsg-&gt;iLenRawMsg;
}

void
getRawMsg(const smsg_t * const pM, uchar **pBuf, int *piLen)
{
	if(pM == NULL) {
		*pBuf=  UCHAR_CONSTANT(&quot;&quot;);
		*piLen = 0;
	} else {
		if(pM-&gt;pszRawMsg == NULL) {
			*pBuf=  UCHAR_CONSTANT(&quot;&quot;);
			*piLen = 0;
		} else {
			*pBuf = pM-&gt;pszRawMsg;
			*piLen = pM-&gt;iLenRawMsg;
		}
	}
}

void
getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen)
{
	if(pM == NULL) {
		*pBuf=  UCHAR_CONSTANT(&quot;&quot;);
		*piLen = 0;
	} else {
		if(pM-&gt;pszRawMsg == NULL) {
			*pBuf=  UCHAR_CONSTANT(&quot;&quot;);
			*piLen = 0;
		} else {
			/* unfortunately, pM-&gt;offAfterPRI seems NOT to be
			 * correct/consistent in all cases. imuxsock and imudp
			 * seem to have other values than imptcp. Testbench
			 * covers some of that. As a work-around, we caluculate
			 * the value ourselfes here. -- rgerhards, 2015-10-09
			 */
			size_t offAfterPRI = 0;
			if(pM-&gt;pszRawMsg[0] == '&lt;') { /* do we have a PRI? */
				if(pM-&gt;pszRawMsg[2] == '&gt;')
					offAfterPRI = 3;
				else if(pM-&gt;pszRawMsg[3] == '&gt;')
					offAfterPRI = 4;
				else if(pM-&gt;pszRawMsg[4] == '&gt;')
					offAfterPRI = 5;
			}
			*pBuf = pM-&gt;pszRawMsg + offAfterPRI;
			*piLen = pM-&gt;iLenRawMsg - offAfterPRI;
		}
	}
}


/* note: setMSGLen() is only for friends who really know what they
 * do. Setting an invalid length can be desasterous!
 */
void setMSGLen(smsg_t * const pM, int lenMsg)
{
	pM-&gt;iLenMSG = lenMsg;
}

int getMSGLen(smsg_t * const pM)
{
	return((pM == NULL) ? 0 : pM-&gt;iLenMSG);
}

uchar *getMSG(smsg_t * const pM)
{
	uchar *ret;
	if(pM == NULL)
		ret = UCHAR_CONSTANT(&quot;&quot;);
	else {
		if(pM-&gt;iLenMSG == 0)
			ret = UCHAR_CONSTANT(&quot;&quot;);
		else
			ret = pM-&gt;pszRawMsg + pM-&gt;offMSG;
	}
	return ret;
}


/* Get PRI value as integer */
int
getPRIi(const smsg_t * const pM)
{
	syslog_pri_t pri = (pM-&gt;iFacility &lt;&lt; 3) + (pM-&gt;iSeverity);
	if(pri &gt; 191)
		pri = LOG_PRI_INVLD;
	return pri;
}


/* Get PRI value in text form
 */
const char *
getPRI(smsg_t * const pM)
{
	/* PRI is a number in the range 0..191. Thus, we use a simple lookup table to obtain the
	 * string value. It looks a bit clumpsy here in code ;)
	 */
	int iPRI;

	if(pM == NULL)
		return &quot;&quot;;

	iPRI = getPRIi(pM);
	return (iPRI &gt; 191) ? &quot;invld&quot; : (char*)syslog_pri_names[iPRI].pszName;
}


static const char *
formatISOWeekOrYear(enum tplFormatTypes eFmt, struct syslogTime *pTm)
{
	if(pTm-&gt;year &gt;= 1970 &amp;&amp; pTm-&gt;year &lt;= 2099) {
		int isoWeekYear;
		int isoWeek;

		isoWeek = getISOWeek(pTm, &amp;isoWeekYear);

		if (eFmt == tplFmtISOWeek) {
			return two_digits[isoWeek];
		} else {
			return years[isoWeekYear - 1967];
		}
	} else {
		return &quot;YEAR OUT OF RANGE(1970-2099)&quot;;
	}
}

const char *
getTimeReported(smsg_t * const pM, enum tplFormatTypes eFmt)
{
	if(pM == NULL)
		return &quot;&quot;;

	switch(eFmt) {
	case tplFmtDefault:
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP3164 == NULL) {
			pM-&gt;pszTIMESTAMP3164 = pM-&gt;pszTimestamp3164;
			datetime.formatTimestamp3164(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3164,
						     (eFmt == tplFmtRFC3164BuggyDate));
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP3164);
	case tplFmtMySQLDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_MySQL == NULL) {
			if((pM-&gt;pszTIMESTAMP_MySQL = malloc(15)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestampToMySQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_MySQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_MySQL);
	case tplFmtPgSQLDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_PgSQL == NULL) {
			if((pM-&gt;pszTIMESTAMP_PgSQL = malloc(21)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestampToPgSQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_PgSQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_PgSQL);
	case tplFmtRFC3339Date:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP3339 == NULL) {
			pM-&gt;pszTIMESTAMP3339 = pM-&gt;pszTimestamp3339;
			datetime.formatTimestamp3339(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3339);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP3339);
	case tplFmtUnixDate:
		MsgLock(pM);
		if(pM-&gt;pszTIMESTAMP_Unix[0] == '\0') {
			datetime.formatTimestampUnix(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_Unix);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszTIMESTAMP_Unix);
	case tplFmtSecFrac:
		if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
			MsgLock(pM);
			/* re-check, may have changed while we did not hold lock */
			if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
				datetime.formatTimestampSecFrac(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_SecFrac);
			}
			MsgUnlock(pM);
		}
		return(pM-&gt;pszTIMESTAMP_SecFrac);
	case tplFmtWDayName:
		return wdayNames[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtWDay:
		return one_digit[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtMonth:
		return two_digits[(int)pM-&gt;tTIMESTAMP.month];
	case tplFmtYear:
		if(pM-&gt;tTIMESTAMP.year &gt;= 1967 &amp;&amp; pM-&gt;tTIMESTAMP.year &lt;= 2099)
			return years[pM-&gt;tTIMESTAMP.year - 1967];
		else
			return &quot;YEAR OUT OF RANGE(1967-2099)&quot;;
	case tplFmtDay:
		return two_digits[(int)pM-&gt;tTIMESTAMP.day];
	case tplFmtHour:
		return two_digits[(int)pM-&gt;tTIMESTAMP.hour];
	case tplFmtMinute:
		return two_digits[(int)pM-&gt;tTIMESTAMP.minute];
	case tplFmtSecond:
		return two_digits[(int)pM-&gt;tTIMESTAMP.second];
	case tplFmtTZOffsHour:
		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetHour];
	case tplFmtTZOffsMin:
		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetMinute];
	case tplFmtTZOffsDirection:
		return (pM-&gt;tTIMESTAMP.OffsetMode == '+')? &quot;+&quot; : &quot;-&quot;;
	case tplFmtOrdinal:
		return daysInYear[getOrdinal(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtWeek:
		return two_digits[getWeek(&amp;pM-&gt;tTIMESTAMP)];
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		return formatISOWeekOrYear(eFmt, &amp;pM-&gt;tTIMESTAMP);
	}
	return &quot;INVALID eFmt OPTION!&quot;;
}



static const char *getTimeUTC(struct syslogTime *const __restrict__ pTmIn,
	const enum tplFormatTypes eFmt,
	unsigned short *const __restrict__ pbMustBeFreed)
{
	struct syslogTime tUTC;
	char *retbuf = NULL;

	timeConvertToUTC(pTmIn, &amp;tUTC);
	struct syslogTime *const pTm = &amp;tUTC;

	switch(eFmt) {
	case tplFmtDefault:
		if((retbuf = malloc(16)) != NULL) {
			datetime.formatTimestamp3164(pTm, retbuf, 0);
		}
		break;
	case tplFmtMySQLDate:
		if((retbuf = malloc(15)) != NULL) {
			datetime.formatTimestampToMySQL(pTm, retbuf);
		}
		break;
	case tplFmtPgSQLDate:
		if((retbuf = malloc(21)) != NULL) {
			datetime.formatTimestampToPgSQL(pTm, retbuf);
		}
		break;
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		if((retbuf = malloc(16)) != NULL) {
			datetime.formatTimestamp3164(pTm, retbuf, (eFmt == tplFmtRFC3164BuggyDate));
		}
		break;
	case tplFmtRFC3339Date:
		if((retbuf = malloc(33)) != NULL) {
			datetime.formatTimestamp3339(pTm, retbuf);
		}
		break;
	case tplFmtUnixDate:
		if((retbuf = malloc(12)) != NULL) {
			datetime.formatTimestampUnix(pTm, retbuf);
		}
		break;
	case tplFmtSecFrac:
		if((retbuf = malloc(7)) != NULL) {
			datetime.formatTimestampSecFrac(pTm, retbuf);
		}
		break;
	case tplFmtWDayName:
		retbuf = strdup(wdayNames[getWeekdayNbr(pTm)]);
		break;
	case tplFmtWDay:
		retbuf = strdup(one_digit[getWeekdayNbr(pTm)]);
		break;
	case tplFmtMonth:
		retbuf = strdup(two_digits[(int)pTm-&gt;month]);
		break;
	case tplFmtYear:
		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
			retbuf = strdup(years[pTm-&gt;year - 1967]);
		else
			retbuf = strdup(&quot;YEAR OUT OF RANGE(1967-2099)&quot;);
		break;
	case tplFmtDay:
		retbuf = strdup(two_digits[(int)pTm-&gt;day]);
		break;
	case tplFmtHour:
		retbuf = strdup(two_digits[(int)pTm-&gt;hour]);
		break;
	case tplFmtMinute:
		retbuf = strdup(two_digits[(int)pTm-&gt;minute]);
		break;
	case tplFmtSecond:
		retbuf = strdup(two_digits[(int)pTm-&gt;second]);
		break;
	case tplFmtTZOffsHour:
		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetHour]);
		break;
	case tplFmtTZOffsMin:
		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetMinute]);
		break;
	case tplFmtTZOffsDirection:
		retbuf = strdup((pTm-&gt;OffsetMode == '+')? &quot;+&quot; : &quot;-&quot;);
		break;
	case tplFmtOrdinal:
		retbuf = strdup(daysInYear[getOrdinal(pTm)]);
		break;
	case tplFmtWeek:
		retbuf = strdup(two_digits[getWeek(pTm)]);
		break;
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		retbuf = strdup(formatISOWeekOrYear(eFmt, pTm));
		break;
	}

	if(retbuf == NULL) {
		retbuf = (char*)&quot;internal error: invalid eFmt option or malloc problem&quot;;
		*pbMustBeFreed = 0;
	} else {
		*pbMustBeFreed = 1;
	}
	return retbuf;
}

static const char *
getTimeGenerated(smsg_t *const __restrict__ pM,
	const enum tplFormatTypes eFmt)
{
	struct syslogTime *const pTm = &amp;pM-&gt;tRcvdAt;
	if(pM == NULL)
		return &quot;&quot;;

	switch(eFmt) {
	case tplFmtDefault:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3164 == NULL) {
			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164, 0);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3164);
	case tplFmtMySQLDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_MySQL == NULL) {
			if((pM-&gt;pszRcvdAt_MySQL = malloc(15)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestampToMySQL(pTm, pM-&gt;pszRcvdAt_MySQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_MySQL);
	case tplFmtPgSQLDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_PgSQL == NULL) {
			if((pM-&gt;pszRcvdAt_PgSQL = malloc(21)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestampToPgSQL(pTm, pM-&gt;pszRcvdAt_PgSQL);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_PgSQL);
	case tplFmtRFC3164Date:
	case tplFmtRFC3164BuggyDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3164 == NULL) {
			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
					MsgUnlock(pM);
					return &quot;&quot;;
				}
			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164,
						     (eFmt == tplFmtRFC3164BuggyDate));
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3164);
	case tplFmtRFC3339Date:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt3339 == NULL) {
			if((pM-&gt;pszRcvdAt3339 = malloc(33)) == NULL) {
				MsgUnlock(pM);
				return &quot;&quot;;
			}
			datetime.formatTimestamp3339(pTm, pM-&gt;pszRcvdAt3339);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt3339);
	case tplFmtUnixDate:
		MsgLock(pM);
		if(pM-&gt;pszRcvdAt_Unix[0] == '\0') {
			datetime.formatTimestampUnix(pTm, pM-&gt;pszRcvdAt_Unix);
		}
		MsgUnlock(pM);
		return(pM-&gt;pszRcvdAt_Unix);
	case tplFmtSecFrac:
		if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
			MsgLock(pM);
			/* re-check, may have changed while we did not hold lock */
			if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
				datetime.formatTimestampSecFrac(pTm, pM-&gt;pszRcvdAt_SecFrac);
			}
			MsgUnlock(pM);
		}
		return(pM-&gt;pszRcvdAt_SecFrac);
	case tplFmtWDayName:
		return wdayNames[getWeekdayNbr(pTm)];
	case tplFmtWDay:
		return one_digit[getWeekdayNbr(pTm)];
	case tplFmtMonth:
		return two_digits[(int)pTm-&gt;month];
	case tplFmtYear:
		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
			return years[pTm-&gt;year - 1967];
		else
			return &quot;YEAR OUT OF RANGE(1967-2099)&quot;;
	case tplFmtDay:
		return two_digits[(int)pTm-&gt;day];
	case tplFmtHour:
		return two_digits[(int)pTm-&gt;hour];
	case tplFmtMinute:
		return two_digits[(int)pTm-&gt;minute];
	case tplFmtSecond:
		return two_digits[(int)pTm-&gt;second];
	case tplFmtTZOffsHour:
		return two_digits[(int)pTm-&gt;OffsetHour];
	case tplFmtTZOffsMin:
		return two_digits[(int)pTm-&gt;OffsetMinute];
	case tplFmtTZOffsDirection:
		return (pTm-&gt;OffsetMode == '+')? &quot;+&quot; : &quot;-&quot;;
	case tplFmtOrdinal:
		return daysInYear[getOrdinal(pTm)];
	case tplFmtWeek:
		return two_digits[getWeek(pTm)];
	case tplFmtISOWeek:
	case tplFmtISOWeekYear:
		return formatISOWeekOrYear(eFmt, pTm);
	}
	return &quot;INVALID eFmt OPTION!&quot;;
}


static const char *getSeverity(smsg_t * const pM)
{
	const char *name = NULL;

	if(pM == NULL)
		return &quot;&quot;;

	if(pM-&gt;iSeverity &gt; 7) {
		name = &quot;invld&quot;;
	} else {
		name = syslog_number_names[pM-&gt;iSeverity];
	}

	return name;
}


static const char *getSeverityStr(smsg_t * const pM)
{
	const char *name = NULL;

	if(pM == NULL)
		return &quot;&quot;;

	if(pM-&gt;iSeverity &gt; 7) {
		name = &quot;invld&quot;;
	} else {
		name = syslog_severity_names[pM-&gt;iSeverity];
	}

	return name;
}

static const char *getFacility(smsg_t * const pM)
{
	const char *name = NULL;

	if(pM == NULL)
		return &quot;&quot;;

	if(pM-&gt;iFacility &gt; 23) {
		name = &quot;invld&quot;;
	} else {
		name = syslog_number_names[pM-&gt;iFacility];
	}

	return name;
}

static const char *getFacilityStr(smsg_t * const pM)
{
	const char *name = NULL;

	if(pM == NULL)
		return &quot;&quot;;

	if(pM-&gt;iFacility &gt; 23) {
		name = &quot;invld&quot;;
	} else {
		name = syslog_fac_names[pM-&gt;iFacility];
	}

	return name;
}


/* set flow control state (if not called, the default - NO_DELAY - is used)
 * This needs no locking because it is only done while the object is
 * not fully constructed (which also means you must not call this
 * method after the msg has been handed over to a queue).
 * rgerhards, 2008-03-14
 */
rsRetVal
MsgSetFlowControlType(smsg_t * const pMsg, flowControl_t eFlowCtl)
{
	DEFiRet;
	assert(pMsg != NULL);
	assert(eFlowCtl == eFLOWCTL_NO_DELAY || eFlowCtl == eFLOWCTL_LIGHT_DELAY || eFlowCtl == eFLOWCTL_FULL_DELAY);

	pMsg-&gt;flowCtlType = eFlowCtl;

	RETiRet;
}

/* set offset after which PRI in raw msg starts
 * rgerhards, 2009-06-16
 */
rsRetVal
MsgSetAfterPRIOffs(smsg_t * const pMsg, int offs)
{
	assert(pMsg != NULL);
	pMsg-&gt;offAfterPRI = offs;
	return RS_RET_OK;
}


/* rgerhards 2004-11-24: set APP-NAME in msg object
 * This is not locked, because it either is called during message
 * construction (where we need no locking) or later as part of a function
 * which already obtained the lock. So in general, this function here must
 * only be called when it it safe to do so without it aquiring a lock.
 */
rsRetVal ATTR_NONNULL(1,2)
MsgSetAPPNAME(smsg_t *__restrict__ const pMsg, const char *pszAPPNAME)
{
	DEFiRet;
	assert(pMsg != NULL);
	if(pszAPPNAME[0] == '\0') {
		pszAPPNAME = &quot;-&quot;; /* RFC5424 NIL value */
	}
	if(pMsg-&gt;pCSAPPNAME == NULL) {
		/* we need to obtain the object first */
		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSAPPNAME));
	}
	/* if we reach this point, we have the object */
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSAPPNAME, (uchar*) pszAPPNAME));
	cstrFinalize(pMsg-&gt;pCSAPPNAME);

finalize_it:
	RETiRet;
}


/* rgerhards 2004-11-24: set PROCID in msg object
 */
rsRetVal MsgSetPROCID(smsg_t *__restrict__ const pMsg, const char* pszPROCID)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	if(pMsg-&gt;pCSPROCID == NULL) {
		/* we need to obtain the object first */
		CHKiRet(cstrConstruct(&amp;pMsg-&gt;pCSPROCID));
	}
	/* if we reach this point, we have the object */
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSPROCID, (uchar*) pszPROCID));
	cstrFinalize(pMsg-&gt;pCSPROCID);

finalize_it:
	RETiRet;
}


/* check if we have a procid, and, if not, try to acquire/emulate it.
 * This must be called WITHOUT the message lock being held.
 * rgerhards, 2009-06-26
 */
static void preparePROCID(smsg_t * const pM, sbool bLockMutex)
{
	if(pM-&gt;pCSPROCID == NULL) {
		if(bLockMutex == LOCK_MUTEX)
			MsgLock(pM);
		/* re-query, things may have changed in the mean time... */
		if(pM-&gt;pCSPROCID == NULL)
			acquirePROCIDFromTAG(pM);
		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
	}
}


#if 0
/* rgerhards, 2005-11-24
 */
static int getPROCIDLen(smsg_t *pM, sbool bLockMutex)
{
	assert(pM != NULL);
	preparePROCID(pM, bLockMutex);
	return (pM-&gt;pCSPROCID == NULL) ? 1 : rsCStrLen(pM-&gt;pCSPROCID);
}
#endif


/* rgerhards, 2005-11-24
 */
char *getPROCID(smsg_t * const pM, sbool bLockMutex)
{
	uchar *pszRet;

	ISOBJ_TYPE_assert(pM, msg);
	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	preparePROCID(pM, MUTEX_ALREADY_LOCKED);
	if(pM-&gt;pCSPROCID == NULL)
		pszRet = UCHAR_CONSTANT(&quot;-&quot;);
	else
		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSPROCID);
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
	return (char*) pszRet;
}


/* rgerhards 2004-11-24: set MSGID in msg object
 */
rsRetVal MsgSetMSGID(smsg_t * const pMsg, const char* pszMSGID)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	if(pMsg-&gt;pCSMSGID == NULL) {
		/* we need to obtain the object first */
		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSMSGID));
	}
	/* if we reach this point, we have the object */
	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSMSGID, (uchar*) pszMSGID));
	cstrFinalize(pMsg-&gt;pCSMSGID);

finalize_it:
	RETiRet;
}


/* Return state of last parser. If it had success, &quot;OK&quot; is returned, else
 * &quot;FAIL&quot;. All from the constant pool.
 */
static const char *getParseSuccess(smsg_t * const pM)
{
	return (pM-&gt;bParseSuccess) ? &quot;OK&quot; : &quot;FAIL&quot;;
}


/* al, 2011-07-26: LockMsg to avoid race conditions
 */
static const char *getMSGID(smsg_t * const pM)
{
	if (pM-&gt;pCSMSGID == NULL) {
		return &quot;-&quot;;
	}
	else {
		MsgLock(pM);
		char* pszreturn = (char*) rsCStrGetSzStrNoNULL(pM-&gt;pCSMSGID);
		MsgUnlock(pM);
		return pszreturn;
	}
}

/* rgerhards 2012-03-15: set parser success (an integer, acutally bool)
 */
void MsgSetParseSuccess(smsg_t * const pMsg, int bSuccess)
{
	assert(pMsg != NULL);
	pMsg-&gt;bParseSuccess = bSuccess;
}


/* return full message as a json string */
const uchar*
msgGetJSONMESG(smsg_t *__restrict__ const pMsg)
{
	struct json_object *json;
	struct json_object *jval;
	uchar *pRes; /* result pointer */
	rs_size_t bufLen = -1; /* length of string or -1, if not known */

	json = json_object_new_object();

	jval = json_object_new_string((char*)getMSG(pMsg));
	json_object_object_add(json, &quot;msg&quot;, jval);

	getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;rawmsg&quot;, jval);

	pRes = (uchar*)getTimeReported(pMsg, tplFmtRFC3339Date);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;timereported&quot;, jval);

	jval = json_object_new_string(getHOSTNAME(pMsg));
	json_object_object_add(json, &quot;hostname&quot;, jval);

	getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;syslogtag&quot;, jval);

	getInputName(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;inputname&quot;, jval);

	jval = json_object_new_string((char*)getRcvFrom(pMsg));
	json_object_object_add(json, &quot;fromhost&quot;, jval);

	jval = json_object_new_string((char*)getRcvFromIP(pMsg));
	json_object_object_add(json, &quot;fromhost-ip&quot;, jval);

	jval = json_object_new_string(getPRI(pMsg));
	json_object_object_add(json, &quot;pri&quot;, jval);

	jval = json_object_new_string(getFacility(pMsg));
	json_object_object_add(json, &quot;syslogfacility&quot;, jval);

	jval = json_object_new_string(getSeverity(pMsg));
	json_object_object_add(json, &quot;syslogseverity&quot;, jval);

	pRes = (uchar*)getTimeGenerated(pMsg, tplFmtRFC3339Date);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;timegenerated&quot;, jval);

	jval = json_object_new_string((char*)getProgramName(pMsg, LOCK_MUTEX));
	json_object_object_add(json, &quot;programname&quot;, jval);

	jval = json_object_new_string(getProtocolVersionString(pMsg));
	json_object_object_add(json, &quot;protocol-version&quot;, jval);

	MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
	jval = json_object_new_string((char*)pRes);
	json_object_object_add(json, &quot;structured-data&quot;, jval);

	jval = json_object_new_string(getAPPNAME(pMsg, LOCK_MUTEX));
	json_object_object_add(json, &quot;app-name&quot;, jval);

	jval = json_object_new_string(getPROCID(pMsg, LOCK_MUTEX));
	json_object_object_add(json, &quot;procid&quot;, jval);

	jval = json_object_new_string(getMSGID(pMsg));
	json_object_object_add(json, &quot;msgid&quot;, jval);

#ifdef USE_LIBUUID
	if(pMsg-&gt;pszUUID == NULL) {
		jval = NULL;
	} else {
		getUUID(pMsg, &amp;pRes, &amp;bufLen);
		jval = json_object_new_string((char*)pRes);
	}
	json_object_object_add(json, &quot;uuid&quot;, jval);
#endif

	json_object_object_add(json, &quot;$!&quot;, json_object_get(pMsg-&gt;json));

	pRes = (uchar*) strdup(json_object_get_string(json));
	json_object_put(json);
	return pRes;
}

/* rgerhards 2009-06-12: set associated ruleset
 */
void MsgSetRuleset(smsg_t * const pMsg, ruleset_t *pRuleset)
{
	assert(pMsg != NULL);
	pMsg-&gt;pRuleset = pRuleset;
}


/* set TAG in msg object
 * (rewritten 2009-06-18 rgerhards)
 */
void MsgSetTAG(smsg_t *__restrict__ const pMsg, const uchar* pszBuf, const size_t lenBuf)
{
	uchar *pBuf;
	assert(pMsg != NULL);

	freeTAG(pMsg);

	pMsg-&gt;iLenTAG = lenBuf;
	if(pMsg-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
		/* small enough: use fixed buffer (faster!) */
		pBuf = pMsg-&gt;TAG.szBuf;
	} else {
		if((pBuf = (uchar*) malloc(pMsg-&gt;iLenTAG + 1)) == NULL) {
			/* truncate message, better than completely loosing it... */
			pBuf = pMsg-&gt;TAG.szBuf;
			pMsg-&gt;iLenTAG = CONF_TAG_BUFSIZE - 1;
		} else {
			pMsg-&gt;TAG.pszTAG = pBuf;
		}
	}

	memcpy(pBuf, pszBuf, pMsg-&gt;iLenTAG);
	pBuf[pMsg-&gt;iLenTAG] = '\0'; /* this also works with truncation! */
}


/* This function tries to emulate the TAG if none is
 * set. Its primary purpose is to provide an old-style TAG
 * when a syslog-protocol message has been received. Then,
 * the tag is APP-NAME &quot;[&quot; PROCID &quot;]&quot;. The function first checks
 * if there is a TAG and, if not, if it can emulate it.
 * rgerhards, 2005-11-24
 */
static void ATTR_NONNULL(1)
tryEmulateTAG(smsg_t *const pM, const sbool bLockMutex)
{
	size_t lenTAG;
	uchar bufTAG[CONF_TAG_MAXSIZE];
	assert(pM != NULL);

	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	if(pM-&gt;iLenTAG &gt; 0) {
		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
		return; /* done, no need to emulate */
	}

	if(msgGetProtocolVersion(pM) == 1) {
		if(!strcmp(getPROCID(pM, MUTEX_ALREADY_LOCKED), &quot;-&quot;)) {
			/* no process ID, use APP-NAME only */
			MsgSetTAG(pM, (uchar*) getAPPNAME(pM, MUTEX_ALREADY_LOCKED),
					getAPPNAMELen(pM, MUTEX_ALREADY_LOCKED));
		} else {
			/* now we can try to emulate */
			lenTAG = snprintf((char*)bufTAG, CONF_TAG_MAXSIZE, &quot;%s[%s]&quot;,
					  getAPPNAME(pM, MUTEX_ALREADY_LOCKED), getPROCID(pM, MUTEX_ALREADY_LOCKED));
			bufTAG[sizeof(bufTAG)-1] = '\0'; /* just to make sure... */
			MsgSetTAG(pM, bufTAG, lenTAG);
		}
		/* Signal change in TAG for acquireProgramName */
		pM-&gt;iLenPROGNAME = -1;
	}
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
}


void ATTR_NONNULL(2,3)
getTAG(smsg_t * const pM, uchar **const ppBuf, int *const piLen, const sbool bLockMutex)
{
	if(pM == NULL) {
		*ppBuf = UCHAR_CONSTANT(&quot;&quot;);
		*piLen = 0;
	} else {
		if(pM-&gt;iLenTAG == 0)
			tryEmulateTAG(pM, bLockMutex);
		if(pM-&gt;iLenTAG == 0) {
			*ppBuf = UCHAR_CONSTANT(&quot;&quot;);
			*piLen = 0;
		} else {
			*ppBuf = (pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG;
			*piLen = pM-&gt;iLenTAG;
		}
	}
}


int getHOSTNAMELen(smsg_t * const pM)
{
	if(pM == NULL)
		return 0;
	else
		if(pM-&gt;pszHOSTNAME == NULL) {
			resolveDNS(pM);
			if(pM-&gt;rcvFrom.pRcvFrom == NULL)
				return 0;
			else
				return prop.GetStringLen(pM-&gt;rcvFrom.pRcvFrom);
		} else
			return pM-&gt;iLenHOSTNAME;
}


const char *getHOSTNAME(smsg_t * const pM)
{
	if(pM == NULL)
		return &quot;&quot;;
	else
		if(pM-&gt;pszHOSTNAME == NULL) {
			resolveDNS(pM);
			if(pM-&gt;rcvFrom.pRcvFrom == NULL) {
				return &quot;&quot;;
			} else {
				uchar *psz;
				int len;
				prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
				return (char*) psz;
			}
		} else {
			return (char*) pM-&gt;pszHOSTNAME;
		}
}


uchar *getRcvFrom(smsg_t * const pM)
{
	uchar *psz;
	int len;

	if(pM == NULL) {
		psz = UCHAR_CONSTANT(&quot;&quot;);
	} else {
		resolveDNS(pM);
		if(pM-&gt;rcvFrom.pRcvFrom == NULL)
			psz = UCHAR_CONSTANT(&quot;&quot;);
		else
			prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
	}
	return psz;
}


/* rgerhards 2004-11-24: set STRUCTURED DATA in msg object
 */
rsRetVal MsgSetStructuredData(smsg_t * const pMsg, const char* pszStrucData)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pMsg, msg);
	free(pMsg-&gt;pszStrucData);
	CHKmalloc(pMsg-&gt;pszStrucData = (uchar*)strdup(pszStrucData));
	pMsg-&gt;lenStrucData = strlen(pszStrucData);
finalize_it:
	RETiRet;
}


/* get the &quot;STRUCTURED-DATA&quot; as sz string, including length */
void
MsgGetStructuredData(smsg_t * const pM, uchar **pBuf, rs_size_t *len)
{
	MsgLock(pM);
	if(pM-&gt;pszStrucData == NULL) {
		*pBuf = UCHAR_CONSTANT(&quot;-&quot;),
		*len = 1;
	} else  {
		*pBuf = pM-&gt;pszStrucData,
		*len = pM-&gt;lenStrucData;
	}
	MsgUnlock(pM);
}

/* get the &quot;programname&quot; as sz string
 * rgerhards, 2005-10-19
 */
uchar * ATTR_NONNULL(1)
getProgramName(smsg_t *const pM, const sbool bLockMutex)
{
	if(bLockMutex == LOCK_MUTEX) {
		MsgLock(pM);
	}

	if(pM-&gt;iLenPROGNAME == -1) {
		if(pM-&gt;iLenTAG == 0) {
			uchar *pRes;
			rs_size_t bufLen = -1;
			getTAG(pM, &amp;pRes, &amp;bufLen, MUTEX_ALREADY_LOCKED);
		}
		acquireProgramName(pM);
	}

	if(bLockMutex == LOCK_MUTEX) {
		MsgUnlock(pM);
	}
	return (pM-&gt;iLenPROGNAME &lt; CONF_PROGNAME_BUFSIZE) ? pM-&gt;PROGNAME.szBuf
						       : pM-&gt;PROGNAME.ptr;
}



/* check if we have a APPNAME, and, if not, try to acquire/emulate it.
 * rgerhards, 2009-06-26
 */
static void ATTR_NONNULL(1)
prepareAPPNAME(smsg_t *const pM, const sbool bLockMutex)
{
	if(pM-&gt;pCSAPPNAME == NULL) {
		if(bLockMutex == LOCK_MUTEX)
			MsgLock(pM);

		/* re-query as things might have changed during locking */
		if(pM-&gt;pCSAPPNAME == NULL) {
			if(msgGetProtocolVersion(pM) == 0) {
				/* only then it makes sense to emulate */
				MsgSetAPPNAME(pM, (char*)getProgramName(pM, MUTEX_ALREADY_LOCKED));
			}
		}

		if(bLockMutex == LOCK_MUTEX)
			MsgUnlock(pM);
	}
}

/* rgerhards, 2005-11-24
 */
char *getAPPNAME(smsg_t * const pM, const sbool bLockMutex)
{
	uchar *pszRet;

	assert(pM != NULL);
	if(bLockMutex == LOCK_MUTEX)
		MsgLock(pM);
	prepareAPPNAME(pM, MUTEX_ALREADY_LOCKED);
	if(pM-&gt;pCSAPPNAME == NULL)
		pszRet = UCHAR_CONSTANT(&quot;&quot;);
	else
		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSAPPNAME);
	if(bLockMutex == LOCK_MUTEX)
		MsgUnlock(pM);
	return (char*)pszRet;
}

/* rgerhards, 2005-11-24
 */
static int getAPPNAMELen(smsg_t * const pM, const sbool bLockMutex)
{
	assert(pM != NULL);
	prepareAPPNAME(pM, bLockMutex);
	return (pM-&gt;pCSAPPNAME == NULL) ? 0 : rsCStrLen(pM-&gt;pCSAPPNAME);
}

/* rgerhards 2008-09-10: set pszInputName in msg object. This calls AddRef()
 * on the property, because this must be done in all current cases and there
 * is no case expected where this may not be necessary.
 * rgerhards, 2009-06-16
 */
void MsgSetInputName(smsg_t *pThis, prop_t *inputName)
{
	assert(pThis != NULL);

	prop.AddRef(inputName);
	if(pThis-&gt;pInputName != NULL)
		prop.Destruct(&amp;pThis-&gt;pInputName);
	pThis-&gt;pInputName = inputName;
}

/* Set default TZ. Note that at most 7 chars are set, as we would
 * otherwise overrun our buffer!
 */
void MsgSetDfltTZ(smsg_t *pThis, char *tz)
{
	strncpy(pThis-&gt;dfltTZ, tz, 7);
	pThis-&gt;dfltTZ[7] = '\0'; /* ensure 0-Term in case of overflow! */
}


/* Set the pfrominet socket store, so that we can obtain the peer at some
 * later time. Note that we do not check if pRcvFrom is already set, so this
 * function must only be called during message creation.
 * NOTE: msgFlags is NOT set. While this is somewhat a violation of layers,
 * it is done because it gains us some performance. So the caller must make
 * sure the message flags are properly maintained. For all current callers,
 * this is always the case and without extra effort required.
 * rgerhards, 2009-11-17
 */
rsRetVal
msgSetFromSockinfo(smsg_t *pThis, struct sockaddr_storage *sa){
	DEFiRet;
	assert(pThis-&gt;rcvFrom.pRcvFrom == NULL);

	CHKmalloc(pThis-&gt;rcvFrom.pfrominet = malloc(sizeof(struct sockaddr_storage)));
	memcpy(pThis-&gt;rcvFrom.pfrominet, sa, sizeof(struct sockaddr_storage));

finalize_it:
	RETiRet;
}

/* rgerhards 2008-09-10: set RcvFrom name in msg object. This calls AddRef()
 * on the property, because this must be done in all current cases and there
 * is no case expected where this may not be necessary.
 * rgerhards, 2009-06-30
 */
void MsgSetRcvFrom(smsg_t *pThis, prop_t *new)
{
	prop.AddRef(new);
	MsgSetRcvFromWithoutAddRef(pThis, new);
}


/* This is used to set the property via a string. This function should not be
 * called if there is a reliable way for a caller to make sure that the
 * same name can be used across multiple messages. However, if it can not
 * ensure that, calling this function is the second best thing, because it
 * will re-use the previously created property if it contained the same
 * name (but it works only for the immediate previous).
 * rgerhards, 2009-06-31
 */
void MsgSetRcvFromStr(smsg_t * const pThis, const uchar *psz, const int len, prop_t **ppProp)
{
	assert(pThis != NULL);
	assert(ppProp != NULL);

	prop.CreateOrReuseStringProp(ppProp, psz, len);
	MsgSetRcvFrom(pThis, *ppProp);
}


/* set RcvFromIP name in msg object. This calls AddRef()
 * on the property, because this must be done in all current cases and there
 * is no case expected where this may not be necessary.
 * rgerhards, 2009-06-30
 */
rsRetVal MsgSetRcvFromIP(smsg_t *pThis, prop_t *new)
{
	assert(pThis != NULL);

	prop.AddRef(new);
	MsgSetRcvFromIPWithoutAddRef(pThis, new);
	return RS_RET_OK;
}


/* This is used to set the property via a string. This function should not be
 * called if there is a reliable way for a caller to make sure that the
 * same name can be used across multiple messages. However, if it can not
 * ensure that, calling this function is the second best thing, because it
 * will re-use the previously created property if it contained the same
 * name (but it works only for the immediate previous).
 * rgerhards, 2009-06-31
 */
rsRetVal MsgSetRcvFromIPStr(smsg_t *const pThis, const uchar *psz, const int len, prop_t **ppProp)
{
	DEFiRet;
	assert(pThis != NULL);

	CHKiRet(prop.CreateOrReuseStringProp(ppProp, psz, len));
	MsgSetRcvFromIP(pThis, *ppProp);

finalize_it:
	RETiRet;
}


/* rgerhards 2004-11-09: set HOSTNAME in msg object
 * rgerhards, 2007-06-21:
 * Does not return anything. If an error occurs, the hostname is
 * simply not set. I have changed this behaviour. The only problem
 * we can run into is memory shortage. If we have such, it is better
 * to loose the hostname than the full message. So we silently ignore
 * that problem and hope that memory will be available the next time
 * we need it. The rest of the code already knows how to handle an
 * unset HOSTNAME.
 */
void MsgSetHOSTNAME(smsg_t *pThis, const uchar* pszHOSTNAME, const int lenHOSTNAME)
{
	assert(pThis != NULL);

	freeHOSTNAME(pThis);

	pThis-&gt;iLenHOSTNAME = lenHOSTNAME;
	if(pThis-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
		/* small enough: use fixed buffer (faster!) */
		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
	} else if((pThis-&gt;pszHOSTNAME = (uchar*) malloc(pThis-&gt;iLenHOSTNAME + 1)) == NULL) {
		/* truncate message, better than completely loosing it... */
		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
		pThis-&gt;iLenHOSTNAME = CONF_HOSTNAME_BUFSIZE - 1;
	}

	memcpy(pThis-&gt;pszHOSTNAME, pszHOSTNAME, pThis-&gt;iLenHOSTNAME);
	pThis-&gt;pszHOSTNAME[pThis-&gt;iLenHOSTNAME] = '\0'; /* this also works with truncation! */
}


/* set the offset of the MSG part into the raw msg buffer
 * Note that the offset may be higher than the length of the raw message
 * (exactly by one). This can happen if we have a message that does not
 * contain any MSG part.
 */
void MsgSetMSGoffs(smsg_t * const pMsg, int offs)
{
	ISOBJ_TYPE_assert(pMsg, msg);
	pMsg-&gt;offMSG = offs;
	if(offs &gt; pMsg-&gt;iLenRawMsg) {
		assert((int)offs - 1 == pMsg-&gt;iLenRawMsg);
		pMsg-&gt;iLenMSG = 0;
	} else {
		pMsg-&gt;iLenMSG = pMsg-&gt;iLenRawMsg - offs;
	}
}


/* replace the MSG part of a message. The update actually takes place inside
 * rawmsg.
 * There are two cases: either the new message will be larger than the new msg
 * or it will be less than or equal. If it is less than or equal, we can utilize
 * the previous message buffer. If it is larger, we can utilize the smsg_t-included
 * message buffer if it fits in there. If this is not the case, we need to alloc
 * a new, larger, chunk and copy over the data to it. Note that this function is
 * (hopefully) relatively seldom being called, so some performance impact is
 * uncritical. In any case, pszMSG is copied, so if it was dynamically allocated,
 * the caller is responsible for freeing it.
 * rgerhards, 2009-06-23
 */
rsRetVal MsgReplaceMSG(smsg_t *pThis, const uchar* pszMSG, int lenMSG)
{
	int lenNew;
	uchar *bufNew;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, msg);
	assert(pszMSG != NULL);

	lenNew = pThis-&gt;iLenRawMsg + lenMSG - pThis-&gt;iLenMSG;
	if(lenMSG &gt; pThis-&gt;iLenMSG &amp;&amp; lenNew &gt;= CONF_RAWMSG_BUFSIZE) {
		/*  we have lost our &quot;bet&quot; and need to alloc a new buffer ;) */
		CHKmalloc(bufNew = malloc(lenNew + 1));
		memcpy(bufNew, pThis-&gt;pszRawMsg, pThis-&gt;offMSG);
		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
			free(pThis-&gt;pszRawMsg);
		pThis-&gt;pszRawMsg = bufNew;
	}

	if(lenMSG &gt; 0)
		memcpy(pThis-&gt;pszRawMsg + pThis-&gt;offMSG, pszMSG, lenMSG);
	pThis-&gt;pszRawMsg[lenNew] = '\0'; /* this also works with truncation! */
	pThis-&gt;iLenRawMsg = lenNew;
	pThis-&gt;iLenMSG = lenMSG;

finalize_it:
	RETiRet;
}

/* truncate the (raw) message to configured max size.
 * The function makes sure that the stored rawmsg remains
 * properly terminated by '\0'.
 */
void ATTR_NONNULL()
MsgTruncateToMaxSize(smsg_t *const pThis)
{
	ISOBJ_TYPE_assert(pThis, msg);
	const int maxMsgSize = glblGetMaxLine(runConf);
	assert(pThis-&gt;iLenRawMsg &gt; maxMsgSize);

	const int deltaSize = pThis-&gt;iLenRawMsg - maxMsgSize;
	pThis-&gt;pszRawMsg[maxMsgSize] = '\0';
	pThis-&gt;iLenRawMsg = maxMsgSize;
	if(pThis-&gt;iLenMSG &lt; deltaSize) {
		pThis-&gt;iLenMSG = 0;
	} else {
		pThis-&gt;iLenMSG -= deltaSize;
	}
}

/* set raw message in message object. Size of message is provided.
 * The function makes sure that the stored rawmsg is properly
 * terminated by '\0'.
 * rgerhards, 2009-06-16
 */
void ATTR_NONNULL()
MsgSetRawMsg(smsg_t *const pThis, const char*const pszRawMsg, const size_t lenMsg)
{
	ISOBJ_TYPE_assert(pThis, msg);
	int deltaSize;
	if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
		free(pThis-&gt;pszRawMsg);

	deltaSize = (int) lenMsg - pThis-&gt;iLenRawMsg; /* value &lt; 0 in truncation case! */
	pThis-&gt;iLenRawMsg = lenMsg;
	if(pThis-&gt;iLenRawMsg &lt; CONF_RAWMSG_BUFSIZE) {
		/* small enough: use fixed buffer (faster!) */
		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
	} else if((pThis-&gt;pszRawMsg = (uchar*) malloc(pThis-&gt;iLenRawMsg + 1)) == NULL) {
		/* truncate message, better than completely loosing it... */
		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
		pThis-&gt;iLenRawMsg = CONF_RAWMSG_BUFSIZE - 1;
	}

	memcpy(pThis-&gt;pszRawMsg, pszRawMsg, pThis-&gt;iLenRawMsg);
	pThis-&gt;pszRawMsg[pThis-&gt;iLenRawMsg] = '\0'; /* this also works with truncation! */
	/* correct other information */
	if(pThis-&gt;iLenRawMsg &gt; pThis-&gt;offMSG)
		pThis-&gt;iLenMSG += deltaSize;
	else
		pThis-&gt;iLenMSG = 0;
}


/* set raw message in message object. Size of message is not provided. This
 * function should only be used when it is unavoidable (and over time we should
 * try to remove it altogether).
 * rgerhards, 2009-06-16
 */
void MsgSetRawMsgWOSize(smsg_t * const pMsg, char* pszRawMsg)
{
	MsgSetRawMsg(pMsg, pszRawMsg, strlen(pszRawMsg));
}


/* create textual representation of facility and severity.
 * The variable pRes must point to a user-supplied buffer of
 * at least 20 characters.
 */
static uchar *
textpri(const smsg_t *const __restrict__ pMsg)
{
	int lenfac = len_syslog_fac_names[pMsg-&gt;iFacility];
	int lensev = len_syslog_severity_names[pMsg-&gt;iSeverity];
	int totlen = lenfac + 1 + lensev + 1;
	char *pRes = malloc(totlen);
	if(pRes != NULL) {
		memcpy(pRes, syslog_fac_names[pMsg-&gt;iFacility], lenfac);
		pRes[lenfac] = '.';
		memcpy(pRes+lenfac+1, syslog_severity_names[pMsg-&gt;iSeverity], lensev+1 /* for \0! */);
	}
	return (uchar*)pRes;
}


/* This function returns the current date in different
 * variants. It is used to construct the $NOW series of
 * system properties. The returned buffer must be freed
 * by the caller when no longer needed. If the function
 * can not allocate memory, it returns a NULL pointer.
 * Added 2007-07-10 rgerhards
 */
typedef enum ENOWType { NOW_NOW, NOW_YEAR, NOW_MONTH, NOW_DAY, NOW_HOUR,
		NOW_HHOUR, NOW_QHOUR, NOW_MINUTE, NOW_WDAY } eNOWType;
#define tmpBUFSIZE 16	/* size of formatting buffer */
static uchar *getNOW(eNOWType eNow, struct syslogTime *t, const int inUTC)
{
	uchar *pBuf;
	struct syslogTime tt;

	if((pBuf = (uchar*) malloc(tmpBUFSIZE)) == NULL) {
		return NULL;
	}

	if(t == NULL) { /* can happen if called via script engine */
		datetime.getCurrTime(&amp;tt, NULL, inUTC);
		t = &amp;tt;
	}

	if(t-&gt;year == 0 || t-&gt;inUTC != inUTC) { /* not yet set! */
		datetime.getCurrTime(t, NULL, inUTC);
	}

	switch(eNow) {
	case NOW_NOW:
		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
		memcpy(pBuf+2, two_digits[t-&gt;year%100], 2);
		pBuf[4] = '-';
		memcpy(pBuf+5, two_digits[(int)t-&gt;month], 2);
		pBuf[7] = '-';
		memcpy(pBuf+8, two_digits[(int)t-&gt;day], 3);
		break;
	case NOW_YEAR:
		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
		memcpy(pBuf+2, two_digits[t-&gt;year%100], 3);
		break;
	case NOW_MONTH:
		memcpy(pBuf, two_digits[(int)t-&gt;month], 3);
		break;
	case NOW_DAY:
		memcpy(pBuf, two_digits[(int)t-&gt;day], 3);
		break;
	case NOW_HOUR:
		memcpy(pBuf, two_digits[(int)t-&gt;hour], 3);
		break;
	case NOW_HHOUR:
		memcpy(pBuf, two_digits[t-&gt;minute/30], 3);
		break;
	case NOW_QHOUR:
		memcpy(pBuf, two_digits[t-&gt;minute/15], 3);
		break;
	case NOW_MINUTE:
		memcpy(pBuf, two_digits[(int)t-&gt;minute], 3);
		break;
	case NOW_WDAY:
		memcpy(pBuf, one_digit[(int)t-&gt;wday], 2);
		break;
	}

	return(pBuf);
}
#undef tmpBUFSIZE /* clean up */


/* helper function to obtain correct JSON root and mutex depending on
 * property type (essentially based on the property id. If a non-json
 * property id is given the function errors out.
 * Note well: jroot points to a pointer to a (ptr to a) json object.
 * This is necessary because the caller needs a pointer to where the
 * json object pointer is stored, that in turn is necessary because
 * while the address of the actual pointer stays stable, the actual
 * content is volatile until the caller has locked the variable tree,
 * which we DO NOT do to keep calling semantics simple.
 */
static rsRetVal ATTR_NONNULL()
getJSONRootAndMutex(smsg_t *const pMsg, const propid_t id,
	struct json_object ***const jroot, pthread_mutex_t **const mut)
{
	DEFiRet;
	assert(jroot != NULL); /* asserts also help static analyzer! */
	assert(mut != NULL);
<A NAME="1"></A>	assert(*mut == NULL); /* caller shall have initialized this one! */
	assert(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR);

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4362-0.html#1',2,'match4362-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(id == PROP_CEE) {
		*mut = &amp;pMsg-&gt;mut;
		*jroot = &amp;pMsg-&gt;json;
	} else if(id == PROP_LOCAL_VAR) {
		*mut = &amp;pMsg-&gt;mut;
		*jroot = &amp;pMsg-&gt;localvars;
	} else if(id == PROP_GLOBAL_VAR) {</B></FONT>
		*mut = &amp;glblVars_lock;
		*jroot = &amp;global_var_root;
	} else {
		LogError(0, RS_RET_NON_JSON_PROP, &quot;internal error:  &quot;
			&quot;getJSONRootAndMutex; invalid property id %d&quot;, id);
		iRet = RS_RET_NON_JSON_PROP;
	}

	RETiRet;
}

/* basically same function, but does not use property id, but the the
 * variable name type indicator (char after starting $, e.g. $!myvar --&gt; CEE)
 */
static rsRetVal ATTR_NONNULL()
getJSONRootAndMutexByVarChar(smsg_t *const pMsg, const char c,
	struct json_object ***const jroot, pthread_mutex_t **const mut)
{
	DEFiRet;
	propid_t id;
	assert(c == '!' || c == '.' || c == '/');

	switch(c) {
		case '!':
			id = PROP_CEE;
			break;
		case '.':
			id = PROP_LOCAL_VAR;
			break;
		case '/':
			id = PROP_GLOBAL_VAR;
			break;
		default:
			LogError(0, RS_RET_NON_JSON_PROP, &quot;internal error:  &quot;
				&quot;getJSONRootAndMutex; invalid indicator char %c(%2.2x)&quot;, c, c);
			ABORT_FINALIZE(RS_RET_NON_JSON_PROP);
			break;
	}
	iRet = getJSONRootAndMutex(pMsg, id, jroot, mut);

finalize_it:
	RETiRet;
}


/* Get a JSON-Property as string value  (used for various types of JSON-based vars) */
rsRetVal
getJSONPropVal(smsg_t * const pMsg, msgPropDescr_t *pProp, uchar **pRes, rs_size_t *buflen,
	unsigned short *pbMustBeFreed)
{
	uchar *leaf;
	struct json_object **jroot;
	struct json_object *parent;
	struct json_object *field;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	*pRes = NULL;
	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);

	if(*jroot == NULL) FINALIZE;

	if(!strcmp((char*)pProp-&gt;name, &quot;!&quot;)) {
		field = *jroot;
	} else {
		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
			field = NULL;
	}
	if(field != NULL) {
		*pRes = (uchar*) strdup(json_object_get_string(field));
		*buflen = (int) ustrlen(*pRes);
		*pbMustBeFreed = 1;
	}

finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	if(*pRes == NULL) {
		/* could not find any value, so set it to empty */
		*pRes = (unsigned char*)&quot;&quot;;
		*pbMustBeFreed = 0;
	}
	RETiRet;
}


/* Get a JSON-based-variable as native json object, except
 * when it is string type, in which case a string is returned.
 * This is an optimization to not use JSON when not strictly
 * necessary. This in turn is helpful, as calling json-c is
 * *very* expensive due to our need for locking and deep
 * copies.
 * The caller needs to check pjson and pcstr: one of them
 * is non-NULL and contains the return value. Note that
 * the caller is responsible for freeing the string pointer
 * it if is being returned.
 */
rsRetVal
msgGetJSONPropJSONorString(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson,
	uchar **pcstr)
{
	struct json_object **jroot;
	uchar *leaf;
	struct json_object *parent;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	*pjson = NULL, *pcstr = NULL;

	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);
	if(!strcmp((char*)pProp-&gt;name, &quot;!&quot;)) {
		*pjson = *jroot;
		FINALIZE;
	}
	if(*jroot == NULL) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(*pjson == NULL) {
		/* we had a NULL json object and represent this as empty string */
		*pcstr = (uchar*) strdup(&quot;&quot;);
	} else {
		if(json_object_get_type(*pjson) == json_type_string) {
			*pcstr = (uchar*) strdup(json_object_get_string(*pjson));
			*pjson = NULL;
		}
	}

finalize_it:
	/* we need a deep copy, as another thread may modify the object */
	if(*pjson != NULL)
		*pjson = jsonDeepCopy(*pjson);
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}



/* Get a JSON-based-variable as native json object */
rsRetVal
msgGetJSONPropJSON(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson)
{
	struct json_object **jroot;
	uchar *leaf;
	struct json_object *parent;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	*pjson = NULL;

	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);

	if(!strcmp((char*)pProp-&gt;name, &quot;!&quot;)) {
		*pjson = *jroot;
		FINALIZE;
	}
	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}

finalize_it:
	/* we need a deep copy, as another thread may modify the object */
	if(*pjson != NULL)
		*pjson = jsonDeepCopy(*pjson);
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}


/* Encode a JSON value and add it to provided string. Note that
 * the string object may be NULL. In this case, it is created
 * if and only if escaping is needed. if escapeAll is false, previously
 * escaped strings are left as is
 */
static rsRetVal
jsonAddVal(uchar *pSrc, unsigned buflen, es_str_t **dst, int escapeAll)
{
	unsigned char c;
	es_size_t i;
	char numbuf[4];
	unsigned ni;
	unsigned char nc;
	int j;
	DEFiRet;

	for(i = 0 ; i &lt; buflen ; ++i) {
		c = pSrc[i];
		if(   (c &gt;= 0x23 &amp;&amp; c &lt;= 0x2e)
		   || (c &gt;= 0x30 &amp;&amp; c &lt;= 0x5b)
		   || (c &gt;= 0x5d /* &amp;&amp; c &lt;= 0x10FFFF*/)
		   || c == 0x20 || c == 0x21) {
			/* no need to escape */
			if(*dst != NULL)
				es_addChar(dst, c);
		} else {
			if(*dst == NULL) {
				if(i == 0) {
					/* we hope we have only few escapes... */
					*dst = es_newStr(buflen+10);
				} else {
					*dst = es_newStrFromBuf((char*)pSrc, i);
				}
				if(*dst == NULL) {
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
			}
			/* we must escape, try RFC4627-defined special sequences first */
			switch(c) {
			case '\0':
				es_addBuf(dst, &quot;\\u0000&quot;, 6);
				break;
			case '\&quot;':
				es_addBuf(dst, &quot;\\\&quot;&quot;, 2);
				break;
			case '/':
				es_addBuf(dst, &quot;\\/&quot;, 2);
				break;
			case '\\':
				if (escapeAll == RSFALSE) {
					ni = i + 1;
					if (ni &lt;= buflen) {
						nc = pSrc[ni];

						/* Attempt to not double encode */
						if (   nc == '&quot;' || nc == '/' || nc == '\\' || nc == 'b' || nc == 'f'
							|| nc == 'n' || nc == 'r' || nc == 't' || nc == 'u') {

							es_addChar(dst, c);
							es_addChar(dst, nc);
							i = ni;
							break;
						}
					}
				}

				es_addBuf(dst, &quot;\\\\&quot;, 2);
				break;
			case '\010':
				es_addBuf(dst, &quot;\\b&quot;, 2);
				break;
			case '\014':
				es_addBuf(dst, &quot;\\f&quot;, 2);
				break;
			case '\n':
				es_addBuf(dst, &quot;\\n&quot;, 2);
				break;
			case '\r':
				es_addBuf(dst, &quot;\\r&quot;, 2);
				break;
			case '\t':
				es_addBuf(dst, &quot;\\t&quot;, 2);
				break;
			default:
				/* TODO : proper Unicode encoding (see header comment) */
				for(j = 0 ; j &lt; 4 ; ++j) {
					numbuf[3-j] = hexdigit[c % 16];
					c = c / 16;
				}
				es_addBuf(dst, &quot;\\u&quot;, 2);
				es_addBuf(dst, numbuf, 4);
				break;
			}
		}
	}
finalize_it:
	RETiRet;
}


/* encode a property in JSON escaped format. This is a helper
 * to MsgGetProp. It needs to update all provided parameters.
 * For performance reasons, we begin to copy the string only
 * when we recognice that we actually need to do some escaping.
 * rgerhards, 2012-03-16
 */
static rsRetVal
jsonEncode(uchar **ppRes, unsigned short *pbMustBeFreed, int *pBufLen, int escapeAll)
{
	unsigned buflen;
	uchar *pSrc;
	es_str_t *dst = NULL;
	DEFiRet;

	pSrc = *ppRes;
	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
	CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));

	if(dst != NULL) {
		/* we updated the string and need to replace the
		 * previous data.
		 */
		if(*pbMustBeFreed)
			free(*ppRes);
		*ppRes = (uchar*)es_str2cstr(dst, NULL);
		*pbMustBeFreed = 1;
		*pBufLen = -1;
		es_deleteStr(dst);
	}

finalize_it:
	RETiRet;
}


/* Format a property as JSON field, that means
 * &quot;name&quot;=&quot;value&quot;
 * where value is JSON-escaped (here we assume that the name
 * only contains characters from the valid character set).
 * Note: this function duplicates code from jsonEncode().
 * TODO: these two functions should be combined, at least if
 * that makes any sense from a performance PoV - definitely
 * something to consider at a later stage. rgerhards, 2012-04-19
 */
static rsRetVal ATTR_NONNULL()
jsonField(const struct templateEntry *const pTpe,
	uchar **const ppRes,
	unsigned short *const pbMustBeFreed,
	int *const pBufLen,
	int escapeAll)
{
	unsigned buflen;
	uchar *pSrc;
	es_str_t *dst = NULL;
	int is_numeric = 1;
	DEFiRet;

	pSrc = *ppRes;
	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
dbgprintf(&quot;jsonEncode: datatype: %u, onEmpty: %u val %*s\n&quot;, (unsigned) pTpe-&gt;data.field.options.dataType,
(unsigned) pTpe-&gt;data.field.options.onEmpty, buflen, pSrc);
	if(buflen == 0) {
		if(pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_SKIP) {
			FINALIZE;
		}
		is_numeric = 0;
	}
	/* we hope we have only few escapes... */
	dst = es_newStr(buflen+pTpe-&gt;lenFieldName+15);
	es_addChar(&amp;dst, '&quot;');
	es_addBuf(&amp;dst, (char*)pTpe-&gt;fieldName, pTpe-&gt;lenFieldName);
	es_addBufConstcstr(&amp;dst, &quot;\&quot;:&quot;);
	if(buflen == 0 &amp;&amp; pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_NULL) {
		es_addBufConstcstr(&amp;dst, &quot;null&quot;);
	} else {
		if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_AUTO) {
			for(unsigned i = 0 ; i &lt; buflen ; ++i) {
				if(pSrc[i] &lt; '0' || pSrc[i] &gt; '9') {
					is_numeric = 0;
					break;
				}
			}
			if(!is_numeric) {
				es_addChar(&amp;dst, '&quot;');
			}
			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			if(!is_numeric) {
				es_addChar(&amp;dst, '&quot;');
			}
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_STRING) {
			es_addChar(&amp;dst, '&quot;');
			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			es_addChar(&amp;dst, '&quot;');
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_NUMBER) {
			if(buflen == 0) {
				es_addChar(&amp;dst, '0');
			} else {
				CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
			}
		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_BOOL) {
			if(buflen == 1 &amp;&amp; *pSrc == '0') {
				es_addBufConstcstr(&amp;dst, &quot;false&quot;);
			} else {
				es_addBufConstcstr(&amp;dst, &quot;true&quot;);
			}
		}
	}

	if(*pbMustBeFreed)
		free(*ppRes);
	/* we know we do not have \0 chars - so the size does not change */
	*pBufLen = es_strlen(dst);
	*ppRes = (uchar*)es_str2cstr(dst, NULL);
	*pbMustBeFreed = 1;
	es_deleteStr(dst);

finalize_it:
	RETiRet;
}


/* This function returns a string-representation of the
 * requested message property. This is a generic function used
 * to abstract properties so that these can be easier
 * queried. Returns NULL if property could not be found.
 * Actually, this function is a big if..elseif. What it does
 * is simply to map property names (from MonitorWare) to the
 * message object data fields.
 *
 * In case we need string forms of propertis we do not
 * yet have in string form, we do a memory allocation that
 * is sufficiently large (in all cases). Once the string
 * form has been obtained, it is saved until the Msg object
 * is finally destroyed. This is so that we save the processing
 * time in the (likely) case that this property is requested
 * again. It also saves us a lot of dynamic memory management
 * issues in the upper layers, because we so can guarantee that
 * the buffer will remain static AND available during the lifetime
 * of the object. Please note that both the max size allocation as
 * well as keeping things in memory might like look like a
 * waste of memory (some might say it actually is...) - we
 * deliberately accept this because performance is more important
 * to us ;)
 * rgerhards 2004-11-18
 * Parameter &quot;bMustBeFreed&quot; is set by this function. It tells the
 * caller whether or not the string returned must be freed by the
 * caller itself. It is is 0, the caller MUST NOT free it. If it is
 * 1, the caller MUST free it. Handling this wrongly leads to either
 * a memory leak of a program abort (do to double-frees or frees on
 * the constant memory pool). So be careful to do it right.
 * rgerhards 2004-11-23
 * regular expression support contributed by Andres Riancho merged
 * on 2005-09-13
 * changed so that it now an be called without a template entry (NULL).
 * In this case, only the (unmodified) property is returned. This will
 * be used in selector line processing.
 * rgerhards 2005-09-15
 */
/* a quick helper to save some writing: */
#define RET_OUT_OF_MEMORY { *pbMustBeFreed = 0;\
	*pPropLen = sizeof(&quot;**OUT OF MEMORY**&quot;) - 1; \
	return(UCHAR_CONSTANT(&quot;**OUT OF MEMORY**&quot;));}
uchar *MsgGetProp(smsg_t *__restrict__ const pMsg, struct templateEntry *__restrict__ const pTpe,
			msgPropDescr_t *pProp, rs_size_t *__restrict__ const pPropLen,
			unsigned short *__restrict__ const pbMustBeFreed, struct syslogTime * const ttNow)
{
	uchar *pRes; /* result pointer */
	rs_size_t bufLen = -1; /* length of string or -1, if not known */
	uchar *pBufStart;
	uchar *pBuf;
	int iLen;
	short iOffs;
	enum tplFormatTypes datefmt;
	int bDateInUTC;

	assert(pMsg != NULL);
	assert(pbMustBeFreed != NULL);

#ifdef	FEATURE_REGEXP
	/* Variables necessary for regular expression matching */
	size_t nmatch = 10;
	regmatch_t pmatch[10];
#endif

	*pbMustBeFreed = 0;

	switch(pProp-&gt;id) {
		case PROP_MSG:
			pRes = getMSG(pMsg);
			bufLen = getMSGLen(pMsg);
			break;
		case PROP_TIMESTAMP:
			if(pTpe != NULL) {
				datefmt = pTpe-&gt;data.field.eDateFormat;
				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
			} else {
				datefmt = tplFmtDefault;
				bDateInUTC = 0;
			}
			if(bDateInUTC) {
				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tTIMESTAMP, datefmt, pbMustBeFreed);
			} else {
				pRes = (uchar*)getTimeReported(pMsg, datefmt);
			}
			break;
		case PROP_HOSTNAME:
			pRes = (uchar*)getHOSTNAME(pMsg);
			bufLen = getHOSTNAMELen(pMsg);
			break;
		case PROP_SYSLOGTAG:
			getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
			break;
		case PROP_RAWMSG:
			getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_RAWMSG_AFTER_PRI:
			getRawMsgAfterPRI(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_INPUTNAME:
			getInputName(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_FROMHOST:
			pRes = getRcvFrom(pMsg);
			break;
		case PROP_FROMHOST_IP:
			pRes = getRcvFromIP(pMsg);
			break;
		case PROP_PRI:
			pRes = (uchar*)getPRI(pMsg);
			break;
		case PROP_PRI_TEXT:
			pRes = textpri(pMsg);
			if(pRes == NULL)
				RET_OUT_OF_MEMORY;
			*pbMustBeFreed = 1;
			break;
		case PROP_IUT:
			pRes = UCHAR_CONSTANT(&quot;1&quot;); /* always 1 for syslog messages (a MonitorWare thing;)) */
			bufLen = 1;
			break;
		case PROP_SYSLOGFACILITY:
			pRes = (uchar*)getFacility(pMsg);
			break;
		case PROP_SYSLOGFACILITY_TEXT:
			pRes = (uchar*)getFacilityStr(pMsg);
			break;
		case PROP_SYSLOGSEVERITY:
			pRes = (uchar*)getSeverity(pMsg);
			break;
		case PROP_SYSLOGSEVERITY_TEXT:
			pRes = (uchar*)getSeverityStr(pMsg);
			break;
		case PROP_TIMEGENERATED:
			if(pTpe != NULL) {
				datefmt = pTpe-&gt;data.field.eDateFormat;
				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
			} else {
				datefmt = tplFmtDefault;
				bDateInUTC = 0;
			}
			if(bDateInUTC) {
				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tRcvdAt, datefmt, pbMustBeFreed);
			} else {
				pRes = (uchar*)getTimeGenerated(pMsg, datefmt);
			}
			break;
		case PROP_PROGRAMNAME:
			pRes = getProgramName(pMsg, LOCK_MUTEX);
			break;
		case PROP_PROTOCOL_VERSION:
			pRes = (uchar*)getProtocolVersionString(pMsg);
			break;
		case PROP_STRUCTURED_DATA:
			MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
			break;
		case PROP_APP_NAME:
			pRes = (uchar*)getAPPNAME(pMsg, LOCK_MUTEX);
			break;
		case PROP_PROCID:
			pRes = (uchar*)getPROCID(pMsg, LOCK_MUTEX);
			break;
		case PROP_MSGID:
			pRes = (uchar*)getMSGID(pMsg);
			break;
		case PROP_JSONMESG:
			pRes = (uchar*)msgGetJSONMESG(pMsg);
			*pbMustBeFreed = 1;
			break;
#ifdef USE_LIBUUID
		case PROP_UUID:
			getUUID(pMsg, &amp;pRes, &amp;bufLen);
			break;
#endif
		case PROP_PARSESUCCESS:
			pRes = (uchar*)getParseSuccess(pMsg);
			break;
		case PROP_SYS_NOW:
			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 10;
			}
			break;
		case PROP_SYS_YEAR:
			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 4;
			}
			break;
		case PROP_SYS_MONTH:
			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_DAY:
			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HOUR:
			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HHOUR:
			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_QHOUR:
			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_MINUTE:
			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_NOW_UTC:
			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 10;
			}
			break;
		case PROP_SYS_YEAR_UTC:
			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 4;
			}
			break;
		case PROP_SYS_MONTH_UTC:
			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_DAY_UTC:
			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HOUR_UTC:
			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_HHOUR_UTC:
			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_QHOUR_UTC:
			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_MINUTE_UTC:
			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 2;
			}
			break;
		case PROP_SYS_WDAY:
			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 1;
			}
			break;
		case PROP_SYS_WDAY_UTC:
			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_UTC)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				*pbMustBeFreed = 1;
				bufLen = 1;
			}
			break;
		case PROP_SYS_NOW_UXTIMESTAMP:
			if((pRes = malloc(16)) == NULL) {
				RET_OUT_OF_MEMORY;
			} else {
				snprintf((char*) pRes, 16-1, &quot;%lld&quot;, (long long) getTime(NULL));
				pRes[16-1] = '\0';
				*pbMustBeFreed = 1;
				bufLen = -1;
			}
			break;
		case PROP_SYS_MYHOSTNAME:
			pRes = glbl.GetLocalHostName();
			break;
		case PROP_CEE_ALL_JSON:
		case PROP_CEE_ALL_JSON_PLAIN:
			if(pMsg-&gt;json == NULL) {
				pRes = (uchar*) &quot;{}&quot;;
				bufLen = 2;
				*pbMustBeFreed = 0;
			} else {
				const char *jstr;
				MsgLock(pMsg);
				int jflag = 0;
				if(pProp-&gt;id == PROP_CEE_ALL_JSON) {
					jflag = JSON_C_TO_STRING_SPACED;
				} else if(pProp-&gt;id == PROP_CEE_ALL_JSON_PLAIN) {
					jflag = JSON_C_TO_STRING_PLAIN;
				}
				jstr = json_object_to_json_string_ext(pMsg-&gt;json, jflag);
				MsgUnlock(pMsg);
				if(jstr == NULL) {
					RET_OUT_OF_MEMORY;
				}
				pRes = (uchar*)strdup(jstr);
				if(pRes == NULL) {
					RET_OUT_OF_MEMORY;
				}
				*pbMustBeFreed = 1;
			}
			break;
		case PROP_CEE:
		case PROP_LOCAL_VAR:
		case PROP_GLOBAL_VAR:
			getJSONPropVal(pMsg, pProp, &amp;pRes, &amp;bufLen, pbMustBeFreed);
			break;
		case PROP_SYS_BOM:
			pRes = (uchar*) &quot;\xEF\xBB\xBF&quot;;
			*pbMustBeFreed = 0;
			break;
		case PROP_SYS_UPTIME:
#			ifndef HAVE_SYSINFO_UPTIME
			/* An alternative on some systems (eg Solaris) is to scan
			* /var/adm/utmpx for last boot time.
			*/
			pRes = (uchar*) &quot;UPTIME NOT available on this system&quot;;
			*pbMustBeFreed = 0;

#			elif defined(__FreeBSD__)

			{
			struct timespec tp;

			if((pRes = (uchar*) malloc(32)) == NULL) {
				RET_OUT_OF_MEMORY;
			}

			if(clock_gettime(CLOCK_UPTIME, &amp;tp) == -1) {
				free(pRes);
				*pPropLen = sizeof(&quot;**SYSCALL FAILED**&quot;) - 1;
				return(UCHAR_CONSTANT(&quot;**SYSCALL FAILED**&quot;));
			}

			*pbMustBeFreed = 1;

			snprintf((char*) pRes, 32, &quot;%ld&quot;, tp.tv_sec);
			}

#			else

			{
			struct sysinfo s_info;

			if((pRes = (uchar*) malloc(32)) == NULL) {
				RET_OUT_OF_MEMORY;
			}

			if(sysinfo(&amp;s_info) &lt; 0) {
				free(pRes);
				*pPropLen = sizeof(&quot;**SYSCALL FAILED**&quot;) - 1;
				return(UCHAR_CONSTANT(&quot;**SYSCALL FAILED**&quot;));
			}

			*pbMustBeFreed = 1;

			snprintf((char*) pRes, 32, &quot;%ld&quot;, s_info.uptime);
			}
#			endif
		break;
		default:
			/* there is no point in continuing, we may even otherwise render the
			 * error message unreadable. rgerhards, 2007-07-10
			 */
			dbgprintf(&quot;invalid property id: '%d'\n&quot;, pProp-&gt;id);
			*pbMustBeFreed = 0;
			*pPropLen = sizeof(&quot;**INVALID PROPERTY NAME**&quot;) - 1;
			return UCHAR_CONSTANT(&quot;**INVALID PROPERTY NAME**&quot;);
	}

	/* If we did not receive a template pointer, we are already done... */
	if(pTpe == NULL || !pTpe-&gt;bComplexProcessing) {
		*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;
		return pRes;
	}

	/* Now check if we need to make &quot;temporary&quot; transformations (these
	 * are transformations that do not go back into the message -
	 * memory must be allocated for them!).
	 */

	/* substring extraction */
	/* first we check if we need to extract by field number
	 * rgerhards, 2005-12-22
	 */
	if(pTpe-&gt;data.field.has_fields == 1) {
		size_t iCurrFld;
		uchar *pFld;
		uchar *pFldEnd;
		/* first, skip to the field in question. The field separator
		 * is always one character and is stored in the template entry.
		 */
		iCurrFld = 1;
		pFld = pRes;
		while(*pFld &amp;&amp; iCurrFld &lt; pTpe-&gt;data.field.iFieldNr) {
			/* skip fields until the requested field or end of string is found */
			while(*pFld &amp;&amp; (uchar) *pFld != pTpe-&gt;data.field.field_delim)
				++pFld; /* skip to field terminator */
			if(*pFld == pTpe-&gt;data.field.field_delim) {
				++pFld; /* eat it */
#ifdef STRICT_GPLV3
				if (pTpe-&gt;data.field.field_expand != 0) {
					while (*pFld == pTpe-&gt;data.field.field_delim) {
						++pFld;
					}
				}
#endif
				++iCurrFld;
			}
		}
		dbgprintf(&quot;field requested %d, field found %d\n&quot;, pTpe-&gt;data.field.iFieldNr, (int) iCurrFld);

		if(iCurrFld == pTpe-&gt;data.field.iFieldNr) {
			/* field found, now extract it */
			/* first of all, we need to find the end */
			pFldEnd = pFld;
			while(*pFldEnd &amp;&amp; *pFldEnd != pTpe-&gt;data.field.field_delim)
				++pFldEnd;
			--pFldEnd; /* we are already at the delimiter - so we need to
			            * step back a little not to copy it as part of the field. */
			/* we got our end pointer, now do the copy */
			/* TODO: code copied from below, this is a candidate for a separate function */
			iLen = pFldEnd - pFld + 1; /* the +1 is for an actual char, NOT \0! */
			pBufStart = pBuf = malloc(iLen + 1);
			if(pBuf == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			/* now copy */
			memcpy(pBuf, pFld, iLen);
			bufLen = iLen;
			pBuf[iLen] = '\0'; /* terminate it */
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBufStart;
			*pbMustBeFreed = 1;
		} else {
			/* field not found, return error */
			if(*pbMustBeFreed == 1)
				free(pRes);
			*pbMustBeFreed = 0;
			*pPropLen = sizeof(&quot;**FIELD NOT FOUND**&quot;) - 1;
			return UCHAR_CONSTANT(&quot;**FIELD NOT FOUND**&quot;);
		}
#ifdef FEATURE_REGEXP
	} else {
		/* Check for regular expressions */
		if (pTpe-&gt;data.field.has_regex != 0) {
			if (pTpe-&gt;data.field.has_regex == 2) {
				/* Could not compile regex before! */
				if (*pbMustBeFreed == 1) {
					free(pRes);
					*pbMustBeFreed = 0;
				}
				*pPropLen = sizeof(&quot;**NO MATCH** **BAD REGULAR EXPRESSION**&quot;) - 1;
				return UCHAR_CONSTANT(&quot;**NO MATCH** **BAD REGULAR EXPRESSION**&quot;);
			}

			dbgprintf(&quot;string to match for regex is: %s\n&quot;, pRes);

			if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
				short iTry = 0;
				uchar bFound = 0;
				iOffs = 0;
				/* first see if we find a match, iterating through the series of
				 * potential matches over the string.
				 */
				while(!bFound) {
					int iREstat;
					iREstat = regexp.regexec(&amp;pTpe-&gt;data.field.re, (char*)(pRes + iOffs),
								nmatch, pmatch, 0);
					dbgprintf(&quot;regexec return is %d\n&quot;, iREstat);
					if(iREstat == 0) {
						if(pmatch[0].rm_so == -1) {
							dbgprintf(&quot;oops ... start offset of successful &quot;
								&quot;regexec is -1\n&quot;);
							break;
						}
						if(iTry == pTpe-&gt;data.field.iMatchToUse) {
							bFound = 1;
						} else {
							dbgprintf(&quot;regex found at offset %d, new offset %d, &quot;
								&quot;tries %d\n&quot;, iOffs,
								(int) (iOffs + pmatch[0].rm_eo), iTry);
							iOffs += pmatch[0].rm_eo;
							++iTry;
						}
					} else {
						break;
					}
				}
				dbgprintf(&quot;regex: end search, found %d\n&quot;, bFound);
				if(!bFound) {
					/* we got no match! */
					if(pTpe-&gt;data.field.nomatchAction != TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
						if (*pbMustBeFreed == 1) {
							free(pRes);
							*pbMustBeFreed = 0;
						}
						if(pTpe-&gt;data.field.nomatchAction == TPL_REGEX_NOMATCH_USE_DFLTSTR) {
							bufLen = sizeof(&quot;**NO MATCH**&quot;) - 1;
							pRes = UCHAR_CONSTANT(&quot;**NO MATCH**&quot;);
						} else if(pTpe-&gt;data.field.nomatchAction ==
						TPL_REGEX_NOMATCH_USE_ZERO) {
							bufLen = 1;
							pRes = UCHAR_CONSTANT(&quot;0&quot;);
						} else {
							bufLen = 0;
							pRes = UCHAR_CONSTANT(&quot;&quot;);
						}
					}
				} else {
					/* Match- but did it match the one we wanted? */
					/* we got no match! */
					if(pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so == -1) {
						if(pTpe-&gt;data.field.nomatchAction !=
						TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
							if (*pbMustBeFreed == 1) {
								free(pRes);
								*pbMustBeFreed = 0;
							}
							if(pTpe-&gt;data.field.nomatchAction ==
							TPL_REGEX_NOMATCH_USE_DFLTSTR) {
								bufLen = sizeof(&quot;**NO MATCH**&quot;) - 1;
								pRes = UCHAR_CONSTANT(&quot;**NO MATCH**&quot;);
							} else if(pTpe-&gt;data.field.nomatchAction ==
								TPL_REGEX_NOMATCH_USE_ZERO) {
								bufLen = 1;
								pRes = UCHAR_CONSTANT(&quot;0&quot;);
							} else {
								bufLen = 0;
								pRes = UCHAR_CONSTANT(&quot;&quot;);
							}
						}
					}
					/* OK, we have a usable match - we now need to malloc pB */
					int iLenBuf;
					uchar *pB;

					iLenBuf = pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_eo
						  - pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so;
					pB = malloc(iLenBuf + 1);

					if (pB == NULL) {
						if (*pbMustBeFreed == 1)
							free(pRes);
						RET_OUT_OF_MEMORY;
					}

					/* Lets copy the matched substring to the buffer */
					memcpy(pB, pRes + iOffs +  pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so,
						iLenBuf);
					bufLen = iLenBuf;
					pB[iLenBuf] = '\0';/* terminate string, did not happen before */

					if (*pbMustBeFreed == 1)
						free(pRes);
					pRes = pB;
					*pbMustBeFreed = 1;
				}
			} else {
				/* we could not load regular expression support. This is quite unexpected at
				 * this stage of processing (after all, the config parser found it), but so
				 * it is. We return an error in that case. -- rgerhards, 2008-03-07
				 */
				dbgprintf(&quot;could not get regexp object pointer, so regexp can not be evaluated\n&quot;);
				if (*pbMustBeFreed == 1) {
					free(pRes);
					*pbMustBeFreed = 0;
				}
				*pPropLen = sizeof(&quot;***REGEXP NOT AVAILABLE***&quot;) - 1;
				return UCHAR_CONSTANT(&quot;***REGEXP NOT AVAILABLE***&quot;);
			}
		}
#endif /* #ifdef FEATURE_REGEXP */
	}

	if(pTpe-&gt;data.field.iFromPos != 0 || pTpe-&gt;data.field.iToPos != 0) {
		/* we need to obtain a private copy */
		int iFrom, iTo;
		uchar *pSb;
		iFrom = pTpe-&gt;data.field.iFromPos;
		iTo = pTpe-&gt;data.field.iToPos;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		if(pTpe-&gt;data.field.options.bFromPosEndRelative) {
			iFrom = (bufLen &lt; iFrom) ? 0 : bufLen - iFrom;
			iTo = (bufLen &lt; iTo)? 0 : bufLen - iTo;
		} else {
			/* need to zero-base to and from (they are 1-based!) */
			if(iFrom &gt; 0)
				--iFrom;
			if(iTo &gt; 0)
				--iTo;
		}
		if(iFrom &gt;= bufLen) {
			DBGPRINTF(&quot;msgGetProp: iFrom %d &gt;= buflen %d, returning empty string\n&quot;,
				iFrom, bufLen);
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = (uchar*) &quot;&quot;;
			*pbMustBeFreed = 0;
			bufLen = 0;
		} else if(iFrom == 0 &amp;&amp; iTo &gt;= bufLen &amp;&amp; pTpe-&gt;data.field.options.bFixedWidth == 0) {
			/* in this case, the requested string is a superset of what we already have,
			 * so there is no need to do any processing. This is a frequent case for size-limited
			 * fields like TAG in the default forwarding template (so it is a useful optimization
			 * to check for this condition ;)). -- rgerhards, 2009-07-09
			 */
			; /*DO NOTHING*/
		} else {
			if(iTo &gt;= bufLen)  /* iTo is very large, if no to-position is set in the template! */
				if (pTpe-&gt;data.field.options.bFixedWidth == 0)
					iTo = bufLen - 1;

			iLen = iTo - iFrom + 1; /* the +1 is for an actual char, NOT \0! */
			pBufStart = pBuf = malloc(iLen + 1);
			if(pBuf == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			pSb = pRes;
			if(iFrom) {
			/* skip to the start of the substring (can't do pointer arithmetic
			 * because the whole string might be smaller!!)
			 */
				while(*pSb &amp;&amp; iFrom) {
					--iFrom;
					++pSb;
				}
			}
			/* OK, we are at the begin - now let's copy... */
			bufLen = iLen;
			while(iLen) {
				if (*pSb) {
					*pBuf++ = *pSb;
					++pSb;
				} else {
					*pBuf++ = ' ';
				}
				--iLen;
			}
			*pBuf = '\0';
			bufLen -= iLen; /* subtract remaining length if the string was smaller! */
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBufStart;
			*pbMustBeFreed = 1;
		}
	}

	/* now check if we need to do our &quot;SP if first char is non-space&quot; hack logic */
	if(*pRes &amp;&amp; pTpe-&gt;data.field.options.bSPIffNo1stSP) {
		/* here, we always destruct the buffer and return a new one */
		uchar cFirst = *pRes; /* save first char */
		if(*pbMustBeFreed == 1)
			free(pRes);
		pRes = (cFirst == ' ') ? UCHAR_CONSTANT(&quot;&quot;) : UCHAR_CONSTANT(&quot; &quot;);
		bufLen = (cFirst == ' ') ? 0 : 1;
		*pbMustBeFreed = 0;
	}

	if(*pRes) {
		/* case conversations (should go after substring, because so we are able to
		 * work on the smallest possible buffer).
		 */
		if(pTpe-&gt;data.field.eCaseConv != tplCaseConvNo) {
			/* we need to obtain a private copy */
			if(bufLen == -1)
				bufLen = ustrlen(pRes);
			uchar *pBStart;
			uchar *pB;
			uchar *pSrc;
			pBStart = pB = malloc(bufLen + 1);
			if(pB == NULL) {
				if(*pbMustBeFreed == 1)
					free(pRes);
				RET_OUT_OF_MEMORY;
			}
			pSrc = pRes;
			while(*pSrc) {
				*pB++ = (pTpe-&gt;data.field.eCaseConv == tplCaseConvUpper) ?
					(uchar)toupper((int)*pSrc) : (uchar)tolower((int)*pSrc);
				/* currently only these two exist */
				++pSrc;
			}
			*pB = '\0';
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = pBStart;
			*pbMustBeFreed = 1;
		}

		/* now do control character dropping/escaping/replacement
		 * Only one of these can be used. If multiple options are given, the
		 * result is random (though currently there obviously is an order of
		 * preferrence, see code below. But this is NOT guaranteed.
		 * RGerhards, 2006-11-17
		 * We must copy the strings if we modify them, because they may either
		 * point to static memory or may point into the message object, in which
		 * case we would actually modify the original property (which of course
		 * is wrong).
		 * This was found and fixed by varmojefkoj on 2007-09-11
		 */
		if(pTpe-&gt;data.field.options.bDropCC) {
			int iLenBuf = 0;
			uchar *pSrc = pRes;
			uchar *pDstStart;
			uchar *pDst;
			uchar bDropped = 0;

			while(*pSrc) {
				if(!iscntrl((int) *pSrc++))
					iLenBuf++;
				else
					bDropped = 1;
			}

			if(bDropped) {
				pDst = pDstStart = malloc(iLenBuf + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(!iscntrl((int) *pSrc))
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pDstStart;
				bufLen = iLenBuf;
				*pbMustBeFreed = 1;
			}
		} else if(pTpe-&gt;data.field.options.bSpaceCC) {
			uchar *pSrc;
			uchar *pDstStart;
			uchar *pDst;

			if(*pbMustBeFreed == 1) {
				/* in this case, we already work on dynamic
				 * memory, so there is no need to copy it - we can
				 * modify it in-place without any harm. This is a
				 * performance optiomization.
				 */
				for(pDst = pRes; *pDst; pDst++) {
					if(iscntrl((int) *pDst))
						*pDst = ' ';
				}
			} else {
				if(bufLen == -1)
					bufLen = ustrlen(pRes);
				pDst = pDstStart = malloc(bufLen + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(iscntrl((int) *pSrc))
						*pDst++ = ' ';
					else
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				pRes = pDstStart;
				*pbMustBeFreed = 1;
			}
		} else if(pTpe-&gt;data.field.options.bEscapeCC) {
			/* we must first count how many control charactes are
			 * present, because we need this to compute the new string
			 * buffer length. While doing so, we also compute the string
			 * length.
			 */
			int iNumCC = 0;
			int iLenBuf = 0;
			uchar *pSrc;
			uchar *pB;

			for(pB = pRes ; *pB ; ++pB) {
				++iLenBuf;
				if(iscntrl((int) *pB))
					++iNumCC;
			}

			if(iNumCC &gt; 0) { /* if 0, there is nothing to escape, so we are done */
				/* OK, let's do the escaping... */
				uchar *pBStart;
				uchar szCCEsc[8]; /* buffer for escape sequence */
				int i;

				iLenBuf += iNumCC * 4;
				pBStart = pB = malloc(iLenBuf + 1);
				if(pB == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(iscntrl((int) *pSrc)) {
						snprintf((char*)szCCEsc, sizeof(szCCEsc), &quot;#%3.3d&quot;, *pSrc);
						for(i = 0 ; i &lt; 4 ; ++i)
							*pB++ = szCCEsc[i];
					} else {
						*pB++ = *pSrc;
					}
				}
				*pB = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pBStart;
				bufLen = -1;
				*pbMustBeFreed = 1;
			}
		}
	}

	/* Take care of spurious characters to make the property safe
	 * for a path definition
	 */
	if(pTpe-&gt;data.field.options.bSecPathDrop || pTpe-&gt;data.field.options.bSecPathReplace) {
		if(pTpe-&gt;data.field.options.bSecPathDrop) {
			int iLenBuf = 0;
			uchar *pSrc = pRes;
			uchar *pDstStart;
			uchar *pDst;
			uchar bDropped = 0;

			while(*pSrc) {
				if(*pSrc++ != '/')
					iLenBuf++;
				else
					bDropped = 1;
			}

			if(bDropped) {
				pDst = pDstStart = malloc(iLenBuf + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(*pSrc != '/')
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				if(*pbMustBeFreed == 1)
					free(pRes);
				pRes = pDstStart;
				bufLen = -1; /* TODO: can we do better? */
				*pbMustBeFreed = 1;
			}
		} else {
			uchar *pSrc;
			uchar *pDstStart;
			uchar *pDst;

			if(*pbMustBeFreed == 1) {
				/* here, again, we can modify the string as we already obtained
				 * a private buffer. As we do not change the size of that buffer,
				 * in-place modification is possible. This is a performance
				 * enhancement.
				 */
				for(pDst = pRes; *pDst; pDst++) {
					if(*pDst == '/')
						*pDst++ = '_';
				}
			} else {
				if(bufLen == -1)
					bufLen = ustrlen(pRes);
				pDst = pDstStart = malloc(bufLen + 1);
				if(pDst == NULL) {
					if(*pbMustBeFreed == 1)
						free(pRes);
					RET_OUT_OF_MEMORY;
				}
				for(pSrc = pRes; *pSrc; pSrc++) {
					if(*pSrc == '/')
						*pDst++ = '_';
					else
						*pDst++ = *pSrc;
				}
				*pDst = '\0';
				/* we must NOT check if it needs to be freed, because we have done
				 * this in the if above. So if we come to hear, the pSrc string needs
				 * not to be freed (and we do not need to care about it).
				 */
				pRes = pDstStart;
				*pbMustBeFreed = 1;
			}
		}

		/* check for &quot;.&quot; and &quot;..&quot; (note the parenthesis in the if condition!) */
		if(*pRes == '\0') {
			if(*pbMustBeFreed == 1)
				free(pRes);
			pRes = UCHAR_CONSTANT(&quot;_&quot;);
			bufLen = 1;
			*pbMustBeFreed = 0;
		} else if((*pRes == '.') &amp;&amp; (*(pRes + 1) == '\0' || (*(pRes + 1) == '.' &amp;&amp; *(pRes + 2) == '\0'))) {
			uchar *pTmp = pRes;

			if(*(pRes + 1) == '\0')
				pRes = UCHAR_CONSTANT(&quot;_&quot;);
			else
				pRes = UCHAR_CONSTANT(&quot;_.&quot;);;
			if(*pbMustBeFreed == 1)
				free(pTmp);
			*pbMustBeFreed = 0;
		}
	}

	/* Now drop last LF if present (pls note that this must not be done
	 * if bEscapeCC was set)!
	 */
	if(pTpe-&gt;data.field.options.bDropLastLF &amp;&amp; !pTpe-&gt;data.field.options.bEscapeCC) {
		int iLn;
		uchar *pB;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		iLn = bufLen;
		if(iLn &gt; 0 &amp;&amp; *(pRes + iLn - 1) == '\n') {
			/* we have a LF! */
			/* check if we need to obtain a private copy */
			if(*pbMustBeFreed == 0) {
				/* ok, original copy, need a private one */
				pB = malloc(iLn + 1);
				if(pB == NULL) {
					RET_OUT_OF_MEMORY;
				}
				memcpy(pB, pRes, iLn - 1);
				pRes = pB;
				*pbMustBeFreed = 1;
			}
			*(pRes + iLn - 1) = '\0'; /* drop LF ;) */
			--bufLen;
		}
	}

	/* Now everything is squased as much as possible and more or less ready to
	 * go. This is the perfect place to compress any remaining spaces, if so
	 * instructed by the user/config.
	 */
	if(pTpe-&gt;data.field.options.bCompressSP) {
		int needCompress = 0;
		int hadSP = 0;
		uchar *pB;
		if(*pbMustBeFreed == 0) {
			for(pB = pRes ; *pB &amp;&amp; needCompress == 0 ; ++pB) {
				if(*pB == ' ') {
					if(hadSP) {
						uchar *const tmp = ustrdup(pRes);
						if(tmp == NULL)
							/* better not compress than
							 * loose message. */
							break;
						*pbMustBeFreed = 1;
						pRes = tmp;
						needCompress = 1;
					} else {
						hadSP = 1;
					}
				}
			}
		} else {
			/* If we can modify the buffer in any case, we
			 * do NOT check if we actually need to compress,
			 * but &quot;just do it&quot; - that's the quickest way
			 * to get it done.
			 */
			needCompress = 1;
		}
		if(needCompress) {
			hadSP = 0;
			uchar *pDst = pRes;
			int needCopy = 0;
			for(pB = pRes ; *pB ; ++pB) {
				if(*pB == ' ') {
					if(hadSP) {
						needCopy = 1;
					}  else {
						hadSP = 1;
						if(needCopy)
							*pDst = *pB;
						++pDst;
					}
				} else {
					hadSP = 0;
					if(needCopy)
						*pDst = *pB;
					++pDst;
				}
			}
			*pDst = '\0';
			bufLen = pDst - pRes;
		}
	}

	/* finally, we need to check if the property should be formatted in CSV or JSON.
	 * For CSV we use RFC 4180, and always use double quotes. As of this writing,
	 * this should be the last action carried out on the property, but in the
	 * future there may be reasons to change that. -- rgerhards, 2009-04-02
	 */
	if(pTpe-&gt;data.field.options.bCSV) {
		/* we need to obtain a private copy, as we need to at least add the double quotes */
		int iBufLen;
		uchar *pBStart;
		uchar *pDst;
		uchar *pSrc;
		if(bufLen == -1)
			bufLen = ustrlen(pRes);
		iBufLen = bufLen;
		/* the malloc may be optimized, we currently use the worst case... */
		pBStart = pDst = malloc(2 * iBufLen + 3);
		if(pDst == NULL) {
			if(*pbMustBeFreed == 1)
				free(pRes);
			RET_OUT_OF_MEMORY;
		}
		pSrc = pRes;
		*pDst++ = '&quot;'; /* starting quote */
		while(*pSrc) {
			if(*pSrc == '&quot;')
				*pDst++ = '&quot;'; /* need to add double double quote (see RFC4180) */
			*pDst++ = *pSrc++;
		}
		*pDst++ = '&quot;';	/* ending quote */
		*pDst = '\0';
		if(*pbMustBeFreed == 1)
			free(pRes);
		pRes = pBStart;
		bufLen = -1;
		*pbMustBeFreed = 1;
	} else if(pTpe-&gt;data.field.options.bJSON) {
		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
	} else if(pTpe-&gt;data.field.options.bJSONf) {
		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
	} else if(pTpe-&gt;data.field.options.bJSONr) {
		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
	} else if(pTpe-&gt;data.field.options.bJSONfr) {
		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
	}

	*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;

	return(pRes);
}

/* Set a single property based on the JSON object provided. The
 * property name is extracted from the JSON object.
 */
static rsRetVal
msgSetPropViaJSON(smsg_t *__restrict__ const pMsg, const char *name, struct json_object *json, int sharedReference)
{
	const char *psz;
	int val;
	prop_t *propFromHost = NULL;
	prop_t *propRcvFromIP = NULL;
	int bNeedFree = 1;
	DEFiRet;

	/* note: json_object_get_string() manages the memory of the returned
	 *       string. So we MUST NOT free it!
	 */
	dbgprintf(&quot;DDDD: msgSetPropViaJSON key: '%s'\n&quot;, name);
	if(!strcmp(name, &quot;rawmsg&quot;)) {
		psz = json_object_get_string(json);
		MsgSetRawMsg(pMsg, psz, strlen(psz));
	} else if(!strcmp(name, &quot;msg&quot;)) {
		psz = json_object_get_string(json);
		MsgReplaceMSG(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, &quot;syslogtag&quot;)) {
		psz = json_object_get_string(json);
		MsgSetTAG(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, &quot;pri&quot;)) {
		val = json_object_get_int(json);
		msgSetPRI(pMsg, val);
	} else if(!strcmp(name, &quot;syslogfacility&quot;)) {
		val = json_object_get_int(json);
		if(val &gt;= 0 &amp;&amp; val &lt;= 24)
			pMsg-&gt;iFacility = val;
		else
			DBGPRINTF(&quot;mmexternal: invalid fac %d requested -- ignored\n&quot;, val);
	} else if(!strcmp(name, &quot;syslogseverity&quot;)) {
		val = json_object_get_int(json);
		if(val &gt;= 0 &amp;&amp; val &lt;= 7)
			pMsg-&gt;iSeverity = val;
		else
			DBGPRINTF(&quot;mmexternal: invalid fac %d requested -- ignored\n&quot;, val);
	} else if(!strcmp(name, &quot;procid&quot;)) {
		psz = json_object_get_string(json);
		MsgSetPROCID(pMsg, psz);
	} else if(!strcmp(name, &quot;msgid&quot;)) {
		psz = json_object_get_string(json);
		MsgSetMSGID(pMsg, psz);
	} else if(!strcmp(name, &quot;structured-data&quot;)) {
		psz = json_object_get_string(json);
		MsgSetStructuredData(pMsg, psz);
	} else if(!strcmp(name, &quot;hostname&quot;) || !strcmp(name, &quot;source&quot;)) {
		psz = json_object_get_string(json);
		MsgSetHOSTNAME(pMsg, (const uchar*)psz, strlen(psz));
	} else if(!strcmp(name, &quot;fromhost&quot;)) {
		psz = json_object_get_string(json);
		MsgSetRcvFromStr(pMsg, (const uchar*) psz, strlen(psz), &amp;propFromHost);
		prop.Destruct(&amp;propFromHost);
	} else if(!strcmp(name, &quot;fromhost-ip&quot;)) {
		psz = json_object_get_string(json);
		MsgSetRcvFromIPStr(pMsg, (const uchar*)psz, strlen(psz), &amp;propRcvFromIP);
		prop.Destruct(&amp;propRcvFromIP);
	} else if(!strcmp(name, &quot;$!&quot;)) {
		/* msgAddJSON expects that it can keep the object without incremeting
		 * the json reference count. So we MUST NOT free (_put) the object in
		 * this case. -- rgerhards, 2018-09-14
		 */
		bNeedFree = 0;
		msgAddJSON(pMsg, (uchar*)&quot;!&quot;, json, 0, sharedReference);
	} else {
		/* we ignore unknown properties */
		DBGPRINTF(&quot;msgSetPropViaJSON: unkonwn property ignored: %s\n&quot;,
			  name);
	}

	if(bNeedFree) {
		json_object_put(json);
	}

	RETiRet;
}


/* set message properties based on JSON string. This function does it all,
 * including parsing the JSON string. If an error is detected, the operation
 * is aborted at the time of error. Any modifications made before the
 * error ocurs are still PERSISTED.
 * This function is meant to support the external message modifiction module
 * interface. As such, replacing properties is expressively permited. Note that
 * properties which were derived from the message during parsing are NOT
 * updated if the underlying (raw)msg property is changed.
 */
rsRetVal
MsgSetPropsViaJSON(smsg_t *__restrict__ const pMsg, const uchar *__restrict__ const jsonstr)
{
	struct json_tokener *tokener = NULL;
	struct json_object *json;
	const char *errMsg;
	DEFiRet;

	DBGPRINTF(&quot;DDDDDD: JSON string for message mod: '%s'\n&quot;, jsonstr);
	if(!strcmp((char*)jsonstr, &quot;{}&quot;)) /* shortcut for a common case */
		FINALIZE;

	tokener = json_tokener_new();

	json = json_tokener_parse_ex(tokener, (char*)jsonstr, ustrlen(jsonstr));
	if(Debug) {
		errMsg = NULL;
		if(json == NULL) {
			enum json_tokener_error err;

			err = tokener-&gt;err;
			if(err != json_tokener_continue)
				errMsg = json_tokener_error_desc(err);
			else
				errMsg = &quot;Unterminated input&quot;;
		} else if(!json_object_is_type(json, json_type_object))
			errMsg = &quot;JSON value is not an object&quot;;
		if(errMsg != NULL) {
			DBGPRINTF(&quot;MsgSetPropsViaJSON: Error parsing JSON '%s': %s\n&quot;,
					jsonstr, errMsg);
		}
	}
	if(json == NULL || !json_object_is_type(json, json_type_object)) {
		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
	}
	MsgSetPropsViaJSON_Object(pMsg, json);

finalize_it:
	if(tokener != NULL)
		json_tokener_free(tokener);
	RETiRet;
}


/* Used by MsgSetPropsViaJSON to set properties.
 * The same as MsgSetPropsViaJSON only that a json object is given and not a string
 */
rsRetVal
MsgSetPropsViaJSON_Object(smsg_t *__restrict__ const pMsg, struct json_object *json)
{
	DEFiRet;
	if(json == NULL || !json_object_is_type(json, json_type_object)) {
		DBGPRINTF(&quot;MsgSetPropsViaJSON_Object: json NULL or not object type\n&quot;);
		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
	}
	struct json_object_iterator it = json_object_iter_begin(json);
	struct json_object_iterator itEnd = json_object_iter_end(json);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		struct json_object *child = json_object_iter_peek_value(&amp;it);
		json_object_get(child);
		msgSetPropViaJSON(pMsg, json_object_iter_peek_name(&amp;it),
			child, 0);
		json_object_iter_next(&amp;it);
	}
	json_object_put(json);

finalize_it:
	RETiRet;
}


/* get the severity - this is an entry point that
 * satisfies the base object class getSeverity semantics.
 * rgerhards, 2008-01-14
 */
rsRetVal
MsgGetSeverity(smsg_t * const pMsg, int *piSeverity)
{
	*piSeverity = pMsg-&gt;iSeverity;
	return RS_RET_OK;
}


static uchar *
jsonPathGetLeaf(uchar *name, int lenName)
{
	int i;
	for(i = lenName ; i &gt;= 0 ; --i)
		if(i == 0) {
			if(name[0] == '!'  || name[0] == '.' || name[0] == '/')
				break;
		} else {
			if(name[i] == '!')
				break;
		}
	if(name[i] == '!' || name[i] == '.' || name[i] == '/')
		++i;
	return name + i;
}

static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value) {
	char namebuf[MAX_VARIABLE_NAME_LEN];
	int key_len = strlen(key);
	char *array_idx_start = strstr(key, &quot;[&quot;);
	char *array_idx_end = NULL;
	char *array_idx_num_end_discovered = NULL;
	struct json_object *arr = NULL;
	if (array_idx_start != NULL) {
		array_idx_end = strstr(array_idx_start, &quot;]&quot;);
	}
	if (array_idx_end != NULL &amp;&amp; (array_idx_end - key + 1) == key_len) {
		errno = 0;
		int idx = (int) strtol(array_idx_start + 1, &amp;array_idx_num_end_discovered, 10);
		if (errno == 0 &amp;&amp; array_idx_num_end_discovered == array_idx_end) {
			memcpy(namebuf, key, array_idx_start - key);
			namebuf[array_idx_start - key] = '\0';
			json_bool found_obj = json_object_object_get_ex(root, namebuf, &amp;arr);
			if (found_obj &amp;&amp; json_object_is_type(arr, json_type_array)) {
				int len = json_object_array_length(arr);
				if (len &gt; idx) {
					*value = json_object_array_get_idx(arr, idx);
					if (*value != NULL) return TRUE;
				}
				return FALSE;
			}
		}
	}
	return json_object_object_get_ex(root, key, value);
}


static rsRetVal
jsonPathFindNext(struct json_object *root, uchar *namestart, uchar **name, uchar *leaf,
		 struct json_object **found, int bCreate)
{
	uchar namebuf[MAX_VARIABLE_NAME_LEN];
	struct json_object *json;
	size_t i;
	uchar *p = *name;
	DEFiRet;

	if(*p == '!' || (*name == namestart &amp;&amp; (*p == '.' || *p == '/')))
		++p;
	for(i = 0 ; *p &amp;&amp; !(p == namestart &amp;&amp; (*p == '.' || *p == '/')) &amp;&amp; *p != '!'
		&amp;&amp; p != leaf &amp;&amp; i &lt; sizeof(namebuf)-1 ; ++i, ++p)
		namebuf[i] = *p;
	if(i &gt; 0) {
		namebuf[i] = '\0';
		if(jsonVarExtract(root, (char*)namebuf, &amp;json) == FALSE) {
			json = NULL;
		}
	} else
		json = root;
	if(json == NULL) {
		if(!bCreate) {
			ABORT_FINALIZE(RS_RET_JNAME_INVALID);
		} else {
			if (json_object_get_type(root) != json_type_object) {
				DBGPRINTF(&quot;jsonPathFindNext with bCreate: not a container in json path, &quot;
					&quot;name is '%s'\n&quot;, namestart);
				ABORT_FINALIZE(RS_RET_INVLD_SETOP);
			}
			json = json_object_new_object();
			json_object_object_add(root, (char*)namebuf, json);
		}
	}

	*name = p;
	*found = json;
finalize_it:
	RETiRet;
}

static rsRetVal
jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf, struct json_object **parent,
	const int bCreate)
{
	uchar *namestart;
	DEFiRet;
	namestart = name;
	*parent = jroot;
	while(name &lt; leaf-1) {
		CHKiRet(jsonPathFindNext(*parent, namestart, &amp;name, leaf, parent, bCreate));
	}
	if(*parent == NULL)
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
finalize_it:
	RETiRet;
}

static rsRetVal
jsonMerge(struct json_object *existing, struct json_object *json)
{
	/* TODO: check &amp; handle duplicate names */
	DEFiRet;

	struct json_object_iterator it = json_object_iter_begin(json);
	struct json_object_iterator itEnd = json_object_iter_end(json);
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		json_object_object_add(existing, json_object_iter_peek_name(&amp;it),
			json_object_get(json_object_iter_peek_value(&amp;it)));
		json_object_iter_next(&amp;it);
	}
	/* note: json-c does ref counting. We added all descandants refcounts
	 * in the loop above. So when we now free(_put) the root object, only
	 * root gets freed().
	 */
	json_object_put(json);
	RETiRet;
}

/* find a JSON structure element (field or container doesn't matter).  */
rsRetVal
jsonFind(smsg_t *const pMsg, msgPropDescr_t *pProp, struct json_object **jsonres)
{
	uchar *leaf;
	struct json_object *parent;
	struct json_object *field;
	struct json_object **jroot = NULL;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);

	if(*jroot == NULL) {
		field = NULL;
		goto finalize_it;
	}

	if(!strcmp((char*)pProp-&gt;name, &quot;!&quot;)) {
		field = *jroot;
	} else if(!strcmp((char*)pProp-&gt;name, &quot;.&quot;)) {
		field = *jroot;
	} else {
		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
			field = NULL;
	}
	*jsonres = field;

finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}

/* check if JSON variable exists (works on terminal var and container) */
rsRetVal ATTR_NONNULL()
msgCheckVarExists(smsg_t *const pMsg, msgPropDescr_t *pProp)
{
	struct json_object *jsonres = NULL;
	DEFiRet;

	CHKiRet(jsonFind(pMsg, pProp, &amp;jsonres));
	if(jsonres == NULL) {
		iRet = RS_RET_NOT_FOUND;
	}

finalize_it:
	RETiRet;
}

rsRetVal
msgAddJSON(smsg_t * const pM, uchar *name, struct json_object *json, int force_reset, int sharedReference)
{
	/* TODO: error checks! This is a quick&amp;dirty PoC! */
	struct json_object **jroot;
	struct json_object *parent, *leafnode;
	struct json_object *given = NULL;
	uchar *leaf;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);

	if(name[0] == '/') { /* globl var special handling */
		if (sharedReference) {
			given = json;
			json = jsonDeepCopy(json);
			json_object_put(given);
		}
	}

	if(name[1] == '\0') { /* full tree? */
		if(*jroot == NULL)
			*jroot = json;
		else
			CHKiRet(jsonMerge(*jroot, json));
	} else {
		if(*jroot == NULL) {
			/* now we need a root obj */
			*jroot = json_object_new_object();
		}
		leaf = jsonPathGetLeaf(name, ustrlen(name));
		iRet = jsonPathFindParent(*jroot, name, leaf, &amp;parent, 1);
		if (unlikely(iRet != RS_RET_OK)) {
			json_object_put(json);
			FINALIZE;
		}
		if (json_object_get_type(parent) != json_type_object) {
			DBGPRINTF(&quot;msgAddJSON: not a container in json path,&quot;
				&quot;name is '%s'\n&quot;, name);
			json_object_put(json);
			ABORT_FINALIZE(RS_RET_INVLD_SETOP);
		}
		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
			leafnode = NULL;
		/* json-c code indicates we can simply replace a
		 * json type. Unfortunaltely, this is not documented
		 * as part of the interface spec. We still use it,
		 * because it speeds up processing. If it does not work
		 * at some point, use
		 * json_object_object_del(parent, (char*)leaf);
		 * before adding. rgerhards, 2012-09-17
		 */
		if (force_reset || (leafnode == NULL)) {
			json_object_object_add(parent, (char*)leaf, json);
		} else {
			if(json_object_get_type(json) == json_type_object) {
				CHKiRet(jsonMerge(*jroot, json));
			} else {
				/* TODO: improve the code below, however, the current
				 *       state is not really bad */
				if(json_object_get_type(leafnode) == json_type_object) {
					DBGPRINTF(&quot;msgAddJSON: trying to update a container &quot;
							  &quot;node with a leaf, name is %s - &quot;
							  &quot;forbidden&quot;, name);
					json_object_put(json);
					ABORT_FINALIZE(RS_RET_INVLD_SETOP);
				}
				json_object_object_add(parent, (char*)leaf, json);
			}
		}
	}

finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}


rsRetVal
msgDelJSON(smsg_t * const pM, uchar *name)
{
	struct json_object **jroot;
	struct json_object *parent, *leafnode;
	uchar *leaf;
	pthread_mutex_t *mut = NULL;
	DEFiRet;

	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
	pthread_mutex_lock(mut);

	if(*jroot == NULL) {
		DBGPRINTF(&quot;msgDelJSONVar; jroot empty in unset for property %s\n&quot;,
			  name);
		FINALIZE;
	}

	if(name[1] == '\0') {
		/* full tree! Strange, but I think we should permit this. After all,
		 * we trust rsyslog.conf to be written by the admin.
		 */
		DBGPRINTF(&quot;unsetting JSON root object\n&quot;);
		json_object_put(*jroot);
		*jroot = NULL;
	} else {
		leaf = jsonPathGetLeaf(name, ustrlen(name));
		CHKiRet(jsonPathFindParent(*jroot, name, leaf, &amp;parent, 0));
		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
			leafnode = NULL;
		if(leafnode == NULL) {
			DBGPRINTF(&quot;unset JSON: could not find '%s'\n&quot;, name);
			ABORT_FINALIZE(RS_RET_JNAME_NOTFOUND);
		} else {
			DBGPRINTF(&quot;deleting JSON value path '%s', &quot;
				  &quot;leaf '%s', type %d\n&quot;,
				  name, leaf, json_object_get_type(leafnode));
			json_object_object_del(parent, (char*)leaf);
		}
	}

finalize_it:
	if(mut != NULL)
		pthread_mutex_unlock(mut);
	RETiRet;
}

/* add Metadata to the message. This is stored in a special JSON
 * container. Note that only string types are currently supported,
 * what should pose absolutely no problem with the string-ish nature
 * of rsyslog metadata.
 * added 2015-01-09 rgerhards
 */
rsRetVal
msgAddMetadata(smsg_t *const __restrict__ pMsg,
	       uchar *const __restrict__ metaname,
	       uchar *const __restrict__ metaval)
{
	DEFiRet;
	struct json_object *const json = json_object_new_object();
	CHKmalloc(json);
	struct json_object *const jval = json_object_new_string((char*)metaval);
	if(jval == NULL) {
		json_object_put(json);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	json_object_object_add(json, (const char *const)metaname, jval);
	iRet = msgAddJSON(pMsg, (uchar*)&quot;!metadata&quot;, json, 0, 0);
finalize_it:
	RETiRet;
}

rsRetVal
msgAddMultiMetadata(smsg_t *const __restrict__ pMsg,
	       const uchar ** __restrict__ metaname,
	       const uchar ** __restrict__ metaval,
	       const int count)
{
	DEFiRet;
	int i = 0 ;
	struct json_object *const json = json_object_new_object();
	CHKmalloc(json);
	for ( i = 0 ; i &lt; count ; i++ ) {
		struct json_object *const jval = json_object_new_string((char*)metaval[i]);
		if(jval == NULL) {
			json_object_put(json);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		json_object_object_add(json, (const char *const)metaname[i], jval);
	}
	iRet = msgAddJSON(pMsg, (uchar*)&quot;!metadata&quot;, json, 0, 0);
finalize_it:
	RETiRet;
}

struct json_object *
jsonDeepCopy(struct json_object *src)
{
	struct json_object *dst = NULL, *json;
	int arrayLen, i;

	if(src == NULL) goto done;

	switch(json_object_get_type(src)) {
	case json_type_boolean:
		dst = json_object_new_boolean(json_object_get_boolean(src));
		break;
	case json_type_double:
		dst = json_object_new_double(json_object_get_double(src));
		break;
	case json_type_int:
		dst = json_object_new_int64(json_object_get_int64(src));
		break;
	case json_type_string:
		dst = json_object_new_string(json_object_get_string(src));
		break;
	case json_type_object:
		dst = json_object_new_object();
		struct json_object_iterator it = json_object_iter_begin(src);
		struct json_object_iterator itEnd = json_object_iter_end(src);
		while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
			json = jsonDeepCopy(json_object_iter_peek_value(&amp;it));
			json_object_object_add(dst, json_object_iter_peek_name(&amp;it), json);
			json_object_iter_next(&amp;it);
		}
		break;
	case json_type_array:
		arrayLen = json_object_array_length(src);
		dst = json_object_new_array();
		for(i = 0 ; i &lt; arrayLen ; ++i) {
			json = json_object_array_get_idx(src, i);
			json = jsonDeepCopy(json);
			json_object_array_add(dst, json);
		}
		break;
	case json_type_null:
	default:DBGPRINTF(&quot;jsonDeepCopy(): error unknown type %d\n&quot;,
			 json_object_get_type(src));
		dst = NULL;
		break;
	}
done:	return dst;
}


rsRetVal
msgSetJSONFromVar(smsg_t * const pMsg, uchar *varname, struct svar *v, int force_reset)
{
	struct json_object *json = NULL;
	char *cstr;
	DEFiRet;
	switch(v-&gt;datatype) {
	case 'S':/* string */
		cstr = es_str2cstr(v-&gt;d.estr, NULL);
		json = json_object_new_string(cstr);
		free(cstr);
		break;
	case 'N':/* number (integer) */
		json = json_object_new_int64(v-&gt;d.n);
		break;
	case 'J':/* native JSON */
		json = jsonDeepCopy(v-&gt;d.json);
		break;
	default:DBGPRINTF(&quot;msgSetJSONFromVar: unsupported datatype %c\n&quot;,
		v-&gt;datatype);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	msgAddJSON(pMsg, varname, json, force_reset, 0);
finalize_it:
	RETiRet;
}

rsRetVal
MsgAddToStructuredData(smsg_t * const pMsg, uchar *toadd, rs_size_t len)
{
	uchar *newptr;
	rs_size_t newlen;
	int empty;
	DEFiRet;
	empty = pMsg-&gt;pszStrucData == NULL || pMsg-&gt;pszStrucData[0] == '-';
	newlen = (empty) ? len : pMsg-&gt;lenStrucData + len;
	CHKmalloc(newptr = (uchar*) realloc(pMsg-&gt;pszStrucData, newlen+1));
	if(empty) {
		memcpy(newptr, toadd, len);
	} else {
		memcpy(newptr+pMsg-&gt;lenStrucData, toadd, len);
	}
	pMsg-&gt;pszStrucData = newptr;
	pMsg-&gt;pszStrucData[newlen] = '\0';
	pMsg-&gt;lenStrucData = newlen;
finalize_it:
	RETiRet;
}


/* Fill a message propert description. Space must already be alloced
 * by the caller. This is for efficiency, as we expect this to happen
 * as part of a larger structure alloc.
 * Note that CEE/LOCAL_VAR properties can come in either as
 * &quot;$!xx&quot;/&quot;$.xx&quot; or &quot;!xx&quot;/&quot;.xx&quot; - we will unify them here.
 */
rsRetVal
msgPropDescrFill(msgPropDescr_t *pProp, uchar *name, int nameLen)
{
	propid_t id;
	int offs;
	DEFiRet;
	if(propNameToID(name, &amp;id) != RS_RET_OK) {
		parser_errmsg(&quot;invalid property '%s'&quot;, name);
		/* now try to find some common error causes */
		if(!strcasecmp((char*)name, &quot;myhostname&quot;))
			parser_errmsg(&quot;did you mean '$myhostname' instead of '%s'? &quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;bom&quot;))
			parser_errmsg(&quot;did you mean '$bom' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;now&quot;))
			parser_errmsg(&quot;did you mean '$now' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;year&quot;))
			parser_errmsg(&quot;did you mean '$year' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;month&quot;))
			parser_errmsg(&quot;did you mean '$month' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;day&quot;))
			parser_errmsg(&quot;did you mean '$day' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;hour&quot;))
			parser_errmsg(&quot;did you mean '$hour' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;hhour&quot;))
			parser_errmsg(&quot;did you mean '$hhour' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;qhour&quot;))
			parser_errmsg(&quot;did you mean '$qhour' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;minute&quot;))
			parser_errmsg(&quot;did you mean '$minute' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;now-utc&quot;))
			parser_errmsg(&quot;did you mean '$now-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;year-utc&quot;))
			parser_errmsg(&quot;did you mean '$year-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;month-utc&quot;))
			parser_errmsg(&quot;did you mean '$month-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;day-utc&quot;))
			parser_errmsg(&quot;did you mean '$day-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;hour-utc&quot;))
			parser_errmsg(&quot;did you mean '$hour-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;hhour-utc&quot;))
			parser_errmsg(&quot;did you mean '$hhour-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;qhour-utc&quot;))
			parser_errmsg(&quot;did you mean '$qhour-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		else if(!strcasecmp((char*)name, &quot;minute-utc&quot;))
			parser_errmsg(&quot;did you mean '$minute-utc' instead of '%s'?&quot;
				&quot;See also: https://www.rsyslog.com/rsyslog-info-1/&quot;, name);
		ABORT_FINALIZE(RS_RET_INVLD_PROP);
	}
	if(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR) {
	  	/* in these cases, we need the field name for later processing */
		/* normalize name: remove $ if present */
		offs = (name[0] == '$') ? 1 : 0;
		pProp-&gt;name = ustrdup(name + offs);
		pProp-&gt;nameLen = nameLen - offs;
		/* we patch the root name, so that support functions do not need to
		 * check for different root chars. */
		pProp-&gt;name[0] = '!';
	}
	pProp-&gt;id = id;
finalize_it:
	RETiRet;
}

void
msgPropDescrDestruct(msgPropDescr_t *pProp)
{
	if(pProp != NULL) {
		if(pProp-&gt;id == PROP_CEE ||
		   pProp-&gt;id == PROP_LOCAL_VAR ||
		   pProp-&gt;id == PROP_GLOBAL_VAR)
			free(pProp-&gt;name);
	}
}


/* dummy */
static rsRetVal msgQueryInterface(interface_t __attribute__((unused)) *i) { return RS_RET_NOT_IMPLEMENTED; }

/* Initialize the message class. Must be called as the very first method
 * before anything else is called inside this class.
 * rgerhards, 2008-01-04
 */
BEGINObjClassInit(msg, 1, OBJ_IS_CORE_MODULE)
	pthread_mutex_init(&amp;glblVars_lock, NULL);

	/* request objects we use */
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(var, CORE_COMPONENT));

	/* set our own handlers */
	OBJSetMethodHandler(objMethod_SERIALIZE, MsgSerialize);
	/* some more inits */
#	ifdef HAVE_MALLOC_TRIM
	INIT_ATOMIC_HELPER_MUT(mutTrimCtr);
#	endif
ENDObjClassInit(msg)
/* vim:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
