<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for dns_parser.c &amp; msg.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for dns_parser.c &amp; msg.c
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>dns_parser.c (11.063829%)<th>msg.c (0.5110063%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(194-205)<td><a href="#" name="0">(699-710)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(173-181)<td><a href="#" name="1">(3104-3110)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dns_parser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "parsers.h"
3 static const char *dns_rcodes[] = {
4 		"NoError",  		"FormErr",  		"ServFail", 		"NXDomain", 		"NotImp",   		"Refused",  		"YXDomain", 		"YXRRSet",  		"NXRRSet",  		"NotAuth",  		"NotZone",  		"",         		"",         		"",         		"",         		"",         		"BADVERS|BADSIG", 		"BADKEY",   		"BADTIME",  		"BADMODE",  		"BADNAME",  		"BADALG",   		"BADTRUNC",  		NULL
5 };
6 static const char *dns_types[] = {
7 		0,
8 		"A",        		"NS",       		"MD",       		"MF",       		"CNAME",    		"SOA",      		"MB",       		"MG",       		"MR",       		"NULL",     		"WKS",      		"PTR",      		"HINFO",    		"MINFO",    		"MX",       		"TXT",      		"RP",       		"AFSDB",    		"X25",      		"ISDN",     		"RT",       		"NSAP",     		"NSAP-PTR", 		"SIG",      		"KEY",      		"PX",       		"GPOS",     		"AAAA",     		"LOC",      		"NXT",      		"EID",      		"NIMLOC",   		"SRV",      		"ATMA",     		"NAPTR",    		"KX",       		"CERT",     		"A6",       		"DNAME",    		"SINK",     		"OPT",      		"APL",      		"DS",       		"SSHFP",    		"IPSECKEY", 		"RRSIG",    		"NSEC",     		"DNSKEY",   		"DHCID",    		"NSEC3",    		"NSEC3PARAM",   		"TLSA",     		"SMIMEA",   		"Unassigned",   		"HIP",      		"NINFO",    		"RKEY",     		"TALINK",   		"CDS",      		"CDNSKEY",  		"OPENPGPKEY",   		"CSYNC",    		"ZONEMD",   		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
9 		"SPF",      		"UINFO",    		"UID",      		"GID",      		"UNSPEC",   		"NID",      		"L32",      		"L64",      		"LP",       		"EUI48",    		"EUI64",    		NULL
10 };
11 static const char *dns_types2[] = {
12 		"TKEY",
13 		"TSIG",
14 		"IXFR",
15 		"AXFR",
16 		"MAILB",
17 		"MAILA",
18 		"*",
19 		"URI",
20 		"CAA",
21 		"AVC",
22 		"DOA",
23 		"AMTRELAY",
24 		NULL
25 };
26 static const char *dns_types3[] = {
27 		"TA",
28 		"DLV",
29 		NULL
30 };
31 static const char *get_type(uint16_t x) {
32 	const char **types = NULL;
33 <a name="1"></a>	uint16_t len_types3 = (sizeof(dns_types3) / sizeof(char *)) - 1;
34 	uint16_t len_types2 = (sizeof(dns_types2) / sizeof(char *)) - 1;
35 	uint16_t len_types = (sizeof(dns_types) / sizeof(char *)) - 1;
36 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if (x &gt;= 32768 &amp;&amp; x &lt; 32768 + len_types3) {
37 		types = dns_types3;
38 		x -= 32768;
39 	}
40 	else if (x &gt;= 249 &amp;&amp; x &lt; 249 + len_types2) {
41 		types = dns_types2;
42 		x -= 249;
43 	}
44 	else if (x &gt; 0 &amp;&amp; x &lt; len_types)</b></font>
45 		types = dns_types;
46 	else
47 		return "UNKNOWN";
48 	if (types[x] != NULL)
49 		return types[x];
50 	return "UNKNOWN";
51 }
52 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const char *get_class(uint16_t x) {
53 	switch (x) {
54 		case 1:
55 			return "IN";
56 		case 3:
57 			return "CH";
58 		case 4:
59 			return "HS";
60 		case 254:
61 			return "QCLASS NONE";
62 		case 255:
63 			return "QCLASS *";</b></font>
64 	}
65 	return "UNKNOWN";
66 }
67 data_ret_t *dns_parse(const uchar *packet, int pktSize, struct json_object *jparent) {
68 	const uchar *packet_ptr = packet;
69 	const uchar *end_packet = packet + pktSize;
70 	DBGPRINTF("dns_parse\n");
71 	DBGPRINTF("packet size %d\n", pktSize);
72 	union {
73 		unsigned short int *two_bytes;
74 		const uchar *pckt;
75 	} union_short_int;
76 	union_short_int.pckt = packet_ptr;
77 	unsigned short int transaction_id = ntohs(*(union_short_int.two_bytes));
78 	union_short_int.pckt += 2;
79 	unsigned short int flags = ntohs(*(union_short_int.two_bytes));
80 	unsigned short int response_flag = (flags &gt;&gt; 15) &amp; 0b1; 
81 	unsigned short int opcode = (flags &gt;&gt; 11) &amp; 0b1111;
82 	unsigned short int reserved = (flags &gt;&gt; 6) &amp; 0b1;
83 	if (reserved != 0) {
84 		DBGPRINTF("DNS packet reserved bit (Z) is not 0, aborting message. \n");
85 		RETURN_DATA_AFTER(0)
86 	}
87 	unsigned short int reply_code = flags &amp; 0b1111;
88 	union_short_int.pckt += 2;
89 	unsigned short int query_count = ntohs(*(union_short_int.two_bytes));
90 	union_short_int.pckt += 2;
91 	unsigned short int answer_count = ntohs(*(union_short_int.two_bytes));
92 	union_short_int.pckt += 2;
93 	unsigned short int authority_count = ntohs(*(union_short_int.two_bytes));
94 	union_short_int.pckt += 2;
95 	unsigned short int additionnal_count = ntohs(*(union_short_int.two_bytes));
96 	union_short_int.pckt += 2;
97 	packet_ptr = union_short_int.pckt;
98 	fjson_object *queries = NULL;
99 	if ((queries = json_object_new_array()) == NULL) {
100 		DBGPRINTF("impcap::dns_parser: Cannot create new json array. Stopping.\n");
101 		RETURN_DATA_AFTER(0)
102 	}
103 	int query_cpt = 0;
104 	while (query_cpt &lt; query_count &amp;&amp; packet_ptr &lt; end_packet) {
105 		size_t query_size = strnlen((const char *)packet_ptr, (size_t)(end_packet - packet_ptr));
106 		if (query_size &gt;= 256) {
107 			DBGPRINTF("impcap::dns_parser: Length of domain queried is &gt; 255. Stopping.\n");
108 			break;
109 		}
110 		if (query_size + 5 &gt; (size_t)(end_packet - packet_ptr)) {
111 			DBGPRINTF("impcap::dns_parser: packet size too small to parse query. Stopping.\n");
112 			break;
113 		}
114 		fjson_object *query = NULL;
115 		if ((query = json_object_new_object()) == NULL) {
116 			DBGPRINTF("impcap::dns_parser: Cannot create new json object. Stopping.\n");
117 			break;
118 		}
119 		char domain_query[256] = {0};
120 		uchar nb_char = *packet_ptr;
121 		packet_ptr++;
122 		size_t cpt = 0;
123 		while (cpt + 1 &lt; query_size) {
124 			if (nb_char == 0) {
125 				nb_char = *packet_ptr;
126 				domain_query[cpt] = '.';
127 			} else {
128 				domain_query[cpt] = (char)*packet_ptr;
129 				nb_char--;
130 			}
131 			cpt++;
132 			packet_ptr++;
133 		}
134 		domain_query[cpt] = '\0';
135 		if (cpt)
136 			packet_ptr++; 
137 		json_object_object_add(query, "qname", json_object_new_string(domain_query));
138 		union_short_int.pckt = packet_ptr;
139 		unsigned short int qtype = ntohs(*(union_short_int.two_bytes));
140 		json_object_object_add(query, "qtype", json_object_new_int((int)qtype));
141 		json_object_object_add(query, "type", json_object_new_string(get_type(qtype)));
142 		union_short_int.pckt += 2;
143 		unsigned short int qclass = ntohs(*(union_short_int.two_bytes));
144 		json_object_object_add(query, "qclass", json_object_new_int((int)qclass));
145 		json_object_object_add(query, "class", json_object_new_string(get_class(qclass)));
146 		packet_ptr = union_short_int.pckt + 2;
147 		json_object_array_add(queries, query);
148 		query_cpt++;
149 	}
150 	json_object_object_add(jparent, "DNS_transaction_id", json_object_new_int((int)transaction_id));
151 	json_bool is_reponse = FALSE;
152 	if (response_flag)
153 		is_reponse = TRUE;
154 	json_object_object_add(jparent, "DNS_response_flag", json_object_new_boolean(is_reponse));
155 	json_object_object_add(jparent, "DNS_opcode", json_object_new_int(opcode));
156 	json_object_object_add(jparent, "DNS_rcode", json_object_new_int((int)reply_code));
157 	json_object_object_add(jparent, "DNS_error", json_object_new_string(dns_rcodes[reply_code]));
158 	json_object_object_add(jparent, "DNS_QDCOUNT", json_object_new_int((int)query_count));
159 	json_object_object_add(jparent, "DNS_ANCOUNT", json_object_new_int((int)answer_count));
160 	json_object_object_add(jparent, "DNS_NSCOUNT", json_object_new_int((int)authority_count));
161 	json_object_object_add(jparent, "DNS_ARCOUNT", json_object_new_int((int)additionnal_count));
162 	json_object_object_add(jparent, "DNS_Names", queries);
163 	RETURN_DATA_AFTER(0);
164 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>msg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #define SYSLOG_NAMES
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;sys/socket.h&gt;
10 #ifdef HAVE_SYSINFO_UPTIME
11 #include &lt;sys/sysinfo.h&gt;
12 #endif
13 #include &lt;netdb.h&gt;
14 #include &lt;libestr.h&gt;
15 #include &lt;json.h&gt;
16 #ifdef HAVE_MALLOC_H
17 #  include &lt;malloc.h&gt;
18 #endif
19 #ifdef USE_LIBUUID
20 #  include &lt;uuid/uuid.h&gt;
21 #endif
22 #include &lt;errno.h&gt;
23 #include "rsyslog.h"
24 #include "srUtils.h"
25 #include "stringbuf.h"
26 #include "template.h"
27 #include "msg.h"
28 #include "datetime.h"
29 #include "glbl.h"
30 #include "regexp.h"
31 #include "atomic.h"
32 #include "unicode-helper.h"
33 #include "ruleset.h"
34 #include "prop.h"
35 #include "net.h"
36 #include "var.h"
37 #include "rsconf.h"
38 #include "parserif.h"
39 #include "errmsg.h"
40 #define DEV_DEBUG 0	
41 extern void msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri);
42 static pthread_mutex_t glblVars_lock;
43 struct json_object *global_var_root = NULL;
44 DEFobjStaticHelpers
45 DEFobjCurrIf(datetime)
46 DEFobjCurrIf(glbl)
47 DEFobjCurrIf(regexp)
48 DEFobjCurrIf(prop)
49 DEFobjCurrIf(net)
50 DEFobjCurrIf(var)
51 static const char *one_digit[10] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };
52 static const char *two_digits[100] = {
53 	"00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
54 	"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
55 	"20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
56 	"30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
57 	"40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
58 	"50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
59 	"60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
60 	"70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
61 	"80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
62 	"90", "91", "92", "93", "94", "95", "96", "97", "98", "99"};
63 static const char *wdayNames[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
64 static const char *daysInYear[366] = {
65 	       "001", "002", "003", "004", "005", "006", "007", "008", "009",
66 	"010", "011", "012", "013", "014", "015", "016", "017", "018", "019",
67 	"020", "021", "022", "023", "024", "025", "026", "027", "028", "029",
68 	"030", "031", "032", "033", "034", "035", "036", "037", "038", "039",
69 	"040", "041", "042", "043", "044", "045", "046", "047", "048", "049",
70 	"050", "051", "052", "053", "054", "055", "056", "057", "058", "059",
71 	"060", "061", "062", "063", "064", "065", "066", "067", "068", "069",
72 	"070", "071", "072", "073", "074", "075", "076", "077", "078", "079",
73 	"080", "081", "082", "083", "084", "085", "086", "087", "088", "089",
74 	"090", "091", "092", "093", "094", "095", "096", "097", "098", "099",
75 	"100", "101", "102", "103", "104", "105", "106", "107", "108", "109",
76 	"110", "111", "112", "113", "114", "115", "116", "117", "118", "119",
77 	"120", "121", "122", "123", "124", "125", "126", "127", "128", "129",
78 	"130", "131", "132", "133", "134", "135", "136", "137", "138", "139",
79 	"140", "141", "142", "143", "144", "145", "146", "147", "148", "149",
80 	"150", "151", "152", "153", "154", "155", "156", "157", "158", "159",
81 	"160", "161", "162", "163", "164", "165", "166", "167", "168", "169",
82 	"170", "171", "172", "173", "174", "175", "176", "177", "178", "179",
83 	"180", "181", "182", "183", "184", "185", "186", "187", "188", "189",
84 	"190", "191", "192", "193", "194", "195", "196", "197", "198", "199",
85 	"200", "201", "202", "203", "204", "205", "206", "207", "208", "209",
86 	"210", "211", "212", "213", "214", "215", "216", "217", "218", "219",
87 	"220", "221", "222", "223", "224", "225", "226", "227", "228", "229",
88 	"230", "231", "232", "233", "234", "235", "236", "237", "238", "239",
89 	"240", "241", "242", "243", "244", "245", "246", "247", "248", "249",
90 	"250", "251", "252", "253", "254", "255", "256", "257", "258", "259",
91 	"260", "261", "262", "263", "264", "265", "266", "267", "268", "269",
92 	"270", "271", "272", "273", "274", "275", "276", "277", "278", "279",
93 	"280", "281", "282", "283", "284", "285", "286", "287", "288", "289",
94 	"290", "291", "292", "293", "294", "295", "296", "297", "298", "299",
95 	"300", "301", "302", "303", "304", "305", "306", "307", "308", "309",
96 	"310", "311", "312", "313", "314", "315", "316", "317", "318", "319",
97 	"320", "321", "322", "323", "324", "325", "326", "327", "328", "329",
98 	"330", "331", "332", "333", "334", "335", "336", "337", "338", "339",
99 	"340", "341", "342", "343", "344", "345", "346", "347", "348", "349",
100 	"350", "351", "352", "353", "354", "355", "356", "357", "358", "359",
101 	"360", "361", "362", "363", "364", "365", "366"};
102 static const char *years[] = {
103 	"1967", "1968", "1969", "1970", "1971", "1972", "1973", "1974",
104 	"1975", "1976", "1977", "1978", "1979", "1980", "1981", "1982",
105 	"1983", "1984", "1985", "1986", "1987", "1988", "1989", "1990",
106 	"1991", "1992", "1993", "1994", "1995", "1996", "1997", "1998",
107 	"1999", "2000", "2001", "2002", "2003", "2004", "2005", "2006",
108 	"2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014",
109 	"2015", "2016", "2017", "2018", "2019", "2020", "2021", "2022",
110 	"2023", "2024", "2025", "2026", "2027", "2028", "2029", "2030",
111 	"2031", "2032", "2033", "2034", "2035", "2036", "2037", "2038",
112 	"2039", "2040", "2041", "2042", "2043", "2044", "2045", "2046",
113 	"2047", "2048", "2049", "2050", "2051", "2052", "2053", "2054",
114 	"2055", "2056", "2057", "2058", "2059", "2060", "2061", "2062",
115 	"2063", "2064", "2065", "2066", "2067", "2068", "2069", "2070",
116 	"2071", "2072", "2073", "2074", "2075", "2076", "2077", "2078",
117 	"2079", "2080", "2081", "2082", "2083", "2084", "2085", "2086",
118 	"2087", "2088", "2089", "2090", "2091", "2092", "2093", "2094",
119 	"2095", "2096", "2097", "2098", "2099" };
120 static struct {
121 	uchar *pszName;
122 } syslog_pri_names[200] = {
123 	{ UCHAR_CONSTANT("0") },
124 	{ UCHAR_CONSTANT("1") },
125 	{ UCHAR_CONSTANT("2") },
126 	{ UCHAR_CONSTANT("3") },
127 	{ UCHAR_CONSTANT("4") },
128 	{ UCHAR_CONSTANT("5") },
129 	{ UCHAR_CONSTANT("6") },
130 	{ UCHAR_CONSTANT("7") },
131 	{ UCHAR_CONSTANT("8") },
132 	{ UCHAR_CONSTANT("9") },
133 	{ UCHAR_CONSTANT("10") },
134 	{ UCHAR_CONSTANT("11") },
135 	{ UCHAR_CONSTANT("12") },
136 	{ UCHAR_CONSTANT("13") },
137 	{ UCHAR_CONSTANT("14") },
138 	{ UCHAR_CONSTANT("15") },
139 	{ UCHAR_CONSTANT("16") },
140 	{ UCHAR_CONSTANT("17") },
141 	{ UCHAR_CONSTANT("18") },
142 	{ UCHAR_CONSTANT("19") },
143 	{ UCHAR_CONSTANT("20") },
144 	{ UCHAR_CONSTANT("21") },
145 	{ UCHAR_CONSTANT("22") },
146 	{ UCHAR_CONSTANT("23") },
147 	{ UCHAR_CONSTANT("24") },
148 	{ UCHAR_CONSTANT("25") },
149 	{ UCHAR_CONSTANT("26") },
150 	{ UCHAR_CONSTANT("27") },
151 	{ UCHAR_CONSTANT("28") },
152 	{ UCHAR_CONSTANT("29") },
153 	{ UCHAR_CONSTANT("30") },
154 	{ UCHAR_CONSTANT("31") },
155 	{ UCHAR_CONSTANT("32") },
156 	{ UCHAR_CONSTANT("33") },
157 	{ UCHAR_CONSTANT("34") },
158 	{ UCHAR_CONSTANT("35") },
159 	{ UCHAR_CONSTANT("36") },
160 	{ UCHAR_CONSTANT("37") },
161 	{ UCHAR_CONSTANT("38") },
162 	{ UCHAR_CONSTANT("39") },
163 	{ UCHAR_CONSTANT("40") },
164 	{ UCHAR_CONSTANT("41") },
165 	{ UCHAR_CONSTANT("42") },
166 	{ UCHAR_CONSTANT("43") },
167 	{ UCHAR_CONSTANT("44") },
168 	{ UCHAR_CONSTANT("45") },
169 	{ UCHAR_CONSTANT("46") },
170 	{ UCHAR_CONSTANT("47") },
171 	{ UCHAR_CONSTANT("48") },
172 	{ UCHAR_CONSTANT("49") },
173 	{ UCHAR_CONSTANT("50") },
174 	{ UCHAR_CONSTANT("51") },
175 	{ UCHAR_CONSTANT("52") },
176 	{ UCHAR_CONSTANT("53") },
177 	{ UCHAR_CONSTANT("54") },
178 	{ UCHAR_CONSTANT("55") },
179 	{ UCHAR_CONSTANT("56") },
180 	{ UCHAR_CONSTANT("57") },
181 	{ UCHAR_CONSTANT("58") },
182 	{ UCHAR_CONSTANT("59") },
183 	{ UCHAR_CONSTANT("60") },
184 	{ UCHAR_CONSTANT("61") },
185 	{ UCHAR_CONSTANT("62") },
186 	{ UCHAR_CONSTANT("63") },
187 	{ UCHAR_CONSTANT("64") },
188 	{ UCHAR_CONSTANT("65") },
189 	{ UCHAR_CONSTANT("66") },
190 	{ UCHAR_CONSTANT("67") },
191 	{ UCHAR_CONSTANT("68") },
192 	{ UCHAR_CONSTANT("69") },
193 	{ UCHAR_CONSTANT("70") },
194 	{ UCHAR_CONSTANT("71") },
195 	{ UCHAR_CONSTANT("72") },
196 	{ UCHAR_CONSTANT("73") },
197 	{ UCHAR_CONSTANT("74") },
198 	{ UCHAR_CONSTANT("75") },
199 	{ UCHAR_CONSTANT("76") },
200 	{ UCHAR_CONSTANT("77") },
201 	{ UCHAR_CONSTANT("78") },
202 	{ UCHAR_CONSTANT("79") },
203 	{ UCHAR_CONSTANT("80") },
204 	{ UCHAR_CONSTANT("81") },
205 	{ UCHAR_CONSTANT("82") },
206 	{ UCHAR_CONSTANT("83") },
207 	{ UCHAR_CONSTANT("84") },
208 	{ UCHAR_CONSTANT("85") },
209 	{ UCHAR_CONSTANT("86") },
210 	{ UCHAR_CONSTANT("87") },
211 	{ UCHAR_CONSTANT("88") },
212 	{ UCHAR_CONSTANT("89") },
213 	{ UCHAR_CONSTANT("90") },
214 	{ UCHAR_CONSTANT("91") },
215 	{ UCHAR_CONSTANT("92") },
216 	{ UCHAR_CONSTANT("93") },
217 	{ UCHAR_CONSTANT("94") },
218 	{ UCHAR_CONSTANT("95") },
219 	{ UCHAR_CONSTANT("96") },
220 	{ UCHAR_CONSTANT("97") },
221 	{ UCHAR_CONSTANT("98") },
222 	{ UCHAR_CONSTANT("99") },
223 	{ UCHAR_CONSTANT("100") },
224 	{ UCHAR_CONSTANT("101") },
225 	{ UCHAR_CONSTANT("102") },
226 	{ UCHAR_CONSTANT("103") },
227 	{ UCHAR_CONSTANT("104") },
228 	{ UCHAR_CONSTANT("105") },
229 	{ UCHAR_CONSTANT("106") },
230 	{ UCHAR_CONSTANT("107") },
231 	{ UCHAR_CONSTANT("108") },
232 	{ UCHAR_CONSTANT("109") },
233 	{ UCHAR_CONSTANT("110") },
234 	{ UCHAR_CONSTANT("111") },
235 	{ UCHAR_CONSTANT("112") },
236 	{ UCHAR_CONSTANT("113") },
237 	{ UCHAR_CONSTANT("114") },
238 	{ UCHAR_CONSTANT("115") },
239 	{ UCHAR_CONSTANT("116") },
240 	{ UCHAR_CONSTANT("117") },
241 	{ UCHAR_CONSTANT("118") },
242 	{ UCHAR_CONSTANT("119") },
243 	{ UCHAR_CONSTANT("120") },
244 	{ UCHAR_CONSTANT("121") },
245 	{ UCHAR_CONSTANT("122") },
246 	{ UCHAR_CONSTANT("123") },
247 	{ UCHAR_CONSTANT("124") },
248 	{ UCHAR_CONSTANT("125") },
249 	{ UCHAR_CONSTANT("126") },
250 	{ UCHAR_CONSTANT("127") },
251 	{ UCHAR_CONSTANT("128") },
252 	{ UCHAR_CONSTANT("129") },
253 	{ UCHAR_CONSTANT("130") },
254 	{ UCHAR_CONSTANT("131") },
255 	{ UCHAR_CONSTANT("132") },
256 	{ UCHAR_CONSTANT("133") },
257 	{ UCHAR_CONSTANT("134") },
258 	{ UCHAR_CONSTANT("135") },
259 	{ UCHAR_CONSTANT("136") },
260 	{ UCHAR_CONSTANT("137") },
261 	{ UCHAR_CONSTANT("138") },
262 	{ UCHAR_CONSTANT("139") },
263 	{ UCHAR_CONSTANT("140") },
264 	{ UCHAR_CONSTANT("141") },
265 	{ UCHAR_CONSTANT("142") },
266 	{ UCHAR_CONSTANT("143") },
267 	{ UCHAR_CONSTANT("144") },
268 	{ UCHAR_CONSTANT("145") },
269 	{ UCHAR_CONSTANT("146") },
270 	{ UCHAR_CONSTANT("147") },
271 	{ UCHAR_CONSTANT("148") },
272 	{ UCHAR_CONSTANT("149") },
273 	{ UCHAR_CONSTANT("150") },
274 	{ UCHAR_CONSTANT("151") },
275 	{ UCHAR_CONSTANT("152") },
276 	{ UCHAR_CONSTANT("153") },
277 	{ UCHAR_CONSTANT("154") },
278 	{ UCHAR_CONSTANT("155") },
279 	{ UCHAR_CONSTANT("156") },
280 	{ UCHAR_CONSTANT("157") },
281 	{ UCHAR_CONSTANT("158") },
282 	{ UCHAR_CONSTANT("159") },
283 	{ UCHAR_CONSTANT("160") },
284 	{ UCHAR_CONSTANT("161") },
285 	{ UCHAR_CONSTANT("162") },
286 	{ UCHAR_CONSTANT("163") },
287 	{ UCHAR_CONSTANT("164") },
288 	{ UCHAR_CONSTANT("165") },
289 	{ UCHAR_CONSTANT("166") },
290 	{ UCHAR_CONSTANT("167") },
291 	{ UCHAR_CONSTANT("168") },
292 	{ UCHAR_CONSTANT("169") },
293 	{ UCHAR_CONSTANT("170") },
294 	{ UCHAR_CONSTANT("171") },
295 	{ UCHAR_CONSTANT("172") },
296 	{ UCHAR_CONSTANT("173") },
297 	{ UCHAR_CONSTANT("174") },
298 	{ UCHAR_CONSTANT("175") },
299 	{ UCHAR_CONSTANT("176") },
300 	{ UCHAR_CONSTANT("177") },
301 	{ UCHAR_CONSTANT("178") },
302 	{ UCHAR_CONSTANT("179") },
303 	{ UCHAR_CONSTANT("180") },
304 	{ UCHAR_CONSTANT("181") },
305 	{ UCHAR_CONSTANT("182") },
306 	{ UCHAR_CONSTANT("183") },
307 	{ UCHAR_CONSTANT("184") },
308 	{ UCHAR_CONSTANT("185") },
309 	{ UCHAR_CONSTANT("186") },
310 	{ UCHAR_CONSTANT("187") },
311 	{ UCHAR_CONSTANT("188") },
312 	{ UCHAR_CONSTANT("189") },
313 	{ UCHAR_CONSTANT("190") },
314 	{ UCHAR_CONSTANT("191") },
315 	{ UCHAR_CONSTANT("192") },
316 	{ UCHAR_CONSTANT("193") },
317 	{ UCHAR_CONSTANT("194") },
318 	{ UCHAR_CONSTANT("195") },
319 	{ UCHAR_CONSTANT("196") },
320 	{ UCHAR_CONSTANT("197") },
321 	{ UCHAR_CONSTANT("198") },
322 	{ UCHAR_CONSTANT("199") }
323 	};
324 static char hexdigit[16] =
325 	{'0', '1', '2', '3', '4', '5', '6', '7', '8',
326 	 '9', 'A', 'B', 'C', 'D', 'E', 'F' };
327 #if defined(_AIX)
328 static const char *syslog_fac_names[LOG_NFACILITIES] = { "kern", "user", "mail", "daemon", "auth", "syslog", "lpr",
329 							"news", "uucp", "cron", "authpriv", "ftp", "aso", "audit",
330 							"alert", "caa", "local0", "local1", "local2", "local3",
331 							"local4", "local5", "local6", "local7", "invld"    };
332 static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
333 							4, 4, 4, 8, 3, 3, 5,
334 							5, 3, 6, 6, 6, 6,
335 							6, 6, 6, 6, 5 };
336 #else
337 static const char *syslog_fac_names[LOG_NFACILITIES] = { "kern", "user", "mail", "daemon", "auth", "syslog", "lpr",
338 							"news", "uucp", "cron", "authpriv", "ftp", "ntp", "audit",
339 							"alert", "clock", "local0", "local1", "local2", "local3",
340 							"local4", "local5", "local6", "local7", "invld" };
341 static short len_syslog_fac_names[LOG_NFACILITIES] = { 4, 4, 4, 6, 4, 6, 3,
342 							4, 4, 4, 8, 3, 3, 5,
343 							5, 5, 6, 6, 6, 6,
344 							6, 6, 6, 6, 5 };
345 #endif
346 static const char *syslog_severity_names[8] = { "emerg", "alert", "crit", "err", "warning", "notice", "info",
347 	"debug" };
348 static short len_syslog_severity_names[8] = { 5, 5, 4, 3, 7, 6, 4, 5 };
349 static const char *syslog_number_names[LOG_NFACILITIES] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
350 	"10", "11", "12", "13", "14",
351 	"15", "16", "17", "18", "19", "20", "21", "22", "23", "24" };
352 #if defined(HAVE_MALLOC_TRIM) &amp;&amp; !defined(HAVE_ATOMIC_BUILTINS)
353 static pthread_mutex_t mutTrimCtr;	 #endif
354 static int getAPPNAMELen(smsg_t * const pM, sbool bLockMutex);
355 static rsRetVal jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf,
356 	struct json_object **parent, int bCreate);
357 static uchar * jsonPathGetLeaf(uchar *name, int lenName);
358 struct json_object *jsonDeepCopy(struct json_object *src);
359 static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value);
360 void getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen);
361 static inline void
362 MsgLock(smsg_t *pThis)
363 {
364 	#if DEV_DEBUG == 1
365 	dbgprintf("MsgLock(0x%lx)\n", (unsigned long) pThis);
366 	#endif
367 	pthread_mutex_lock(&amp;pThis-&gt;mut);
368 }
369 static inline void
370 MsgUnlock(smsg_t *pThis)
371 {
372 	#if DEV_DEBUG == 1
373 	dbgprintf("MsgUnlock(0x%lx)\n", (unsigned long) pThis);
374 	#endif
375 	pthread_mutex_unlock(&amp;pThis-&gt;mut);
376 }
377 static inline void
378 MsgSetRcvFromIPWithoutAddRef(smsg_t *pThis, prop_t *new)
379 {
380 	if(pThis-&gt;pRcvFromIP != NULL)
381 		prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
382 	pThis-&gt;pRcvFromIP = new;
383 }
384 static void MsgSetRcvFromWithoutAddRef(smsg_t *pThis, prop_t *new)
385 {
386 	assert(pThis != NULL);
387 	if(pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
388 		if(pThis-&gt;rcvFrom.pfrominet != NULL)
389 			free(pThis-&gt;rcvFrom.pfrominet);
390 		pThis-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
391 	} else {
392 		if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
393 			prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
394 	}
395 	pThis-&gt;rcvFrom.pRcvFrom = new;
396 }
397 static void ATTR_NONNULL()
398 MsgSetRulesetByName(smsg_t * const pMsg, cstr_t *const rulesetName)
399 {
400 	uchar *const rs_name = rsCStrGetSzStrNoNULL(rulesetName);
401 	const rsRetVal localRet =
402 		 rulesetGetRuleset(runConf, &amp;(pMsg-&gt;pRuleset), rs_name);
403 	if(localRet != RS_RET_OK) {
404 		LogError(0, localRet, "msg: ruleset '%s' could not be found and could not "
405 			"be assigned to message object. This possibly leads to the message "
406 			"being processed incorrectly. We cannot do anything against this, but "
407 			"wanted to let you know.", rs_name);
408 	}
409 }
410 static rsRetVal
411 resolveDNS(smsg_t * const pMsg) {
412 	rsRetVal localRet;
413 	prop_t *propFromHost = NULL;
414 	prop_t *ip;
415 	prop_t *localName;
416 	DEFiRet;
417 	MsgLock(pMsg);
418 	CHKiRet(objUse(net, CORE_COMPONENT));
419 	if(pMsg-&gt;msgFlags &amp; NEEDS_DNSRESOL) {
420 		if (pMsg-&gt;msgFlags &amp; PRESERVE_CASE) {
421 			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, NULL, &amp;localName, &amp;ip);
422 		} else {
423 			localRet = net.cvthname(pMsg-&gt;rcvFrom.pfrominet, &amp;localName, NULL, &amp;ip);
424 		}
425 		if(localRet == RS_RET_OK) {
426 			MsgSetRcvFromWithoutAddRef(pMsg, localName);
427 			MsgSetRcvFromIPWithoutAddRef(pMsg, ip);
428 		}
429 	}
430 finalize_it:
431 	if(iRet != RS_RET_OK) {
432 		MsgSetRcvFromStr(pMsg, UCHAR_CONSTANT(""), 0, &amp;propFromHost);
433 		prop.Destruct(&amp;propFromHost);
434 	}
435 	MsgUnlock(pMsg);
436 	if(propFromHost != NULL)
437 		prop.Destruct(&amp;propFromHost);
438 	RETiRet;
439 }
440 void
441 getInputName(const smsg_t * const pM, uchar **ppsz, int *const plen)
442 {
443 	if(pM == NULL || pM-&gt;pInputName == NULL) {
444 		*ppsz = UCHAR_CONSTANT("");
445 		*plen = 0;
446 	} else {
447 		prop.GetString(pM-&gt;pInputName, ppsz, plen);
448 	}
449 }
450 static uchar*
451 getRcvFromIP(smsg_t * const pM)
452 {
453 	uchar *psz;
454 	int len;
455 	if(pM == NULL) {
456 		psz = UCHAR_CONSTANT("");
457 	} else {
458 		resolveDNS(pM); 		if(pM-&gt;pRcvFromIP == NULL)
459 			psz = UCHAR_CONSTANT("");
460 		else
461 			prop.GetString(pM-&gt;pRcvFromIP, &amp;psz, &amp;len);
462 	}
463 	return psz;
464 }
465 rsRetVal
466 propNameToID(const uchar *const pName, propid_t *const pPropID)
467 {
468 	DEFiRet;
469 	if(!strcasecmp((char*) pName, "msg")) {
470 		*pPropID = PROP_MSG;
471 	} else if(!strcasecmp((char*) pName, "timestamp")
472 		  || !strcasecmp((char*) pName, "timereported")) {
473 		*pPropID = PROP_TIMESTAMP;
474 	} else if(!strcasecmp((char*) pName, "hostname") || !strcasecmp((char*) pName, "source")) {
475 		*pPropID = PROP_HOSTNAME;
476 	} else if(!strcasecmp((char*) pName, "syslogtag")) {
477 		*pPropID = PROP_SYSLOGTAG;
478 	} else if(!strcasecmp((char*) pName, "rawmsg")) {
479 		*pPropID = PROP_RAWMSG;
480 	} else if(!strcasecmp((char*) pName, "rawmsg-after-pri")) {
481 		*pPropID = PROP_RAWMSG_AFTER_PRI;
482 	} else if(!strcasecmp((char*) pName, "inputname")) {
483 		*pPropID = PROP_INPUTNAME;
484 	} else if(!strcasecmp((char*) pName, "fromhost")) {
485 		*pPropID = PROP_FROMHOST;
486 	} else if(!strcasecmp((char*) pName, "fromhost-ip")) {
487 		*pPropID = PROP_FROMHOST_IP;
488 	} else if(!strcasecmp((char*) pName, "pri")) {
489 		*pPropID = PROP_PRI;
490 	} else if(!strcasecmp((char*) pName, "pri-text")) {
491 		*pPropID = PROP_PRI_TEXT;
492 	} else if(!strcasecmp((char*) pName, "iut")) {
493 		*pPropID = PROP_IUT;
494 	} else if(!strcasecmp((char*) pName, "syslogfacility")) {
495 		*pPropID = PROP_SYSLOGFACILITY;
496 	} else if(!strcasecmp((char*) pName, "syslogfacility-text")) {
497 		*pPropID = PROP_SYSLOGFACILITY_TEXT;
498 	} else if(!strcasecmp((char*) pName, "syslogseverity") || !strcasecmp((char*) pName, "syslogpriority")) {
499 		*pPropID = PROP_SYSLOGSEVERITY;
500 	} else if(!strcasecmp((char*) pName, "syslogseverity-text") ||
501 	!strcasecmp((char*) pName, "syslogpriority-text")) {
502 		*pPropID = PROP_SYSLOGSEVERITY_TEXT;
503 	} else if(!strcasecmp((char*) pName, "timegenerated")) {
504 		*pPropID = PROP_TIMEGENERATED;
505 	} else if(!strcasecmp((char*) pName, "programname")) {
506 		*pPropID = PROP_PROGRAMNAME;
507 	} else if(!strcasecmp((char*) pName, "protocol-version")) {
508 		*pPropID = PROP_PROTOCOL_VERSION;
509 	} else if(!strcasecmp((char*) pName, "structured-data")) {
510 		*pPropID = PROP_STRUCTURED_DATA;
511 	} else if(!strcasecmp((char*) pName, "app-name")) {
512 		*pPropID = PROP_APP_NAME;
513 	} else if(!strcasecmp((char*) pName, "procid")) {
514 		*pPropID = PROP_PROCID;
515 	} else if(!strcasecmp((char*) pName, "msgid")) {
516 		*pPropID = PROP_MSGID;
517 	} else if(!strcasecmp((char*) pName, "jsonmesg")) {
518 		*pPropID = PROP_JSONMESG;
519 	} else if(!strcasecmp((char*) pName, "parsesuccess")) {
520 		*pPropID = PROP_PARSESUCCESS;
521 #ifdef USE_LIBUUID
522 	} else if(!strcasecmp((char*) pName, "uuid")) {
523 		*pPropID = PROP_UUID;
524 #endif
525 	} else if(!strcasecmp((char*) pName, "$NOW")) {
526 		*pPropID = PROP_SYS_NOW;
527 	} else if(!strcasecmp((char*) pName, "$YEAR")) {
528 		*pPropID = PROP_SYS_YEAR;
529 	} else if(!strcasecmp((char*) pName, "$MONTH")) {
530 		*pPropID = PROP_SYS_MONTH;
531 	} else if(!strcasecmp((char*) pName, "$DAY")) {
532 		*pPropID = PROP_SYS_DAY;
533 	} else if(!strcasecmp((char*) pName, "$HOUR")) {
534 		*pPropID = PROP_SYS_HOUR;
535 	} else if(!strcasecmp((char*) pName, "$HHOUR")) {
536 		*pPropID = PROP_SYS_HHOUR;
537 	} else if(!strcasecmp((char*) pName, "$QHOUR")) {
538 		*pPropID = PROP_SYS_QHOUR;
539 	} else if(!strcasecmp((char*) pName, "$MINUTE")) {
540 		*pPropID = PROP_SYS_MINUTE;
541 	} else if(!strcasecmp((char*) pName, "$WDAY")) {
542 		*pPropID = PROP_SYS_WDAY;
543 	} else if(!strcasecmp((char*) pName, "$now-utc")) {
544 		*pPropID = PROP_SYS_NOW_UTC;
545 	} else if(!strcasecmp((char*) pName, "$year-utc")) {
546 		*pPropID = PROP_SYS_YEAR_UTC;
547 	} else if(!strcasecmp((char*) pName, "$month-utc")) {
548 		*pPropID = PROP_SYS_MONTH_UTC;
549 	} else if(!strcasecmp((char*) pName, "$day-utc")) {
550 		*pPropID = PROP_SYS_DAY_UTC;
551 	} else if(!strcasecmp((char*) pName, "$hour-utc")) {
552 		*pPropID = PROP_SYS_HOUR_UTC;
553 	} else if(!strcasecmp((char*) pName, "$hhour-utc")) {
554 		*pPropID = PROP_SYS_HHOUR_UTC;
555 	} else if(!strcasecmp((char*) pName, "$qhour-utc")) {
556 		*pPropID = PROP_SYS_QHOUR_UTC;
557 	} else if(!strcasecmp((char*) pName, "$minute-utc")) {
558 		*pPropID = PROP_SYS_MINUTE_UTC;
559 	} else if(!strcasecmp((char*) pName, "$wday-utc")) {
560 		*pPropID = PROP_SYS_WDAY_UTC;
561 	} else if(!strcasecmp((char*) pName, "$now-unixtimestamp")) {
562 		*pPropID = PROP_SYS_NOW_UXTIMESTAMP;
563 	} else if(!strcasecmp((char*) pName, "$MYHOSTNAME")) {
564 		*pPropID = PROP_SYS_MYHOSTNAME;
565 	} else if(!strcasecmp((char*) pName, "$!all-json")) {
566 		*pPropID = PROP_CEE_ALL_JSON;
567 	} else if(!strcasecmp((char*) pName, "$!all-json-plain")) {
568 		*pPropID = PROP_CEE_ALL_JSON_PLAIN;
569 	} else if(!strcasecmp((char*) pName, "$BOM")) {
570 		*pPropID = PROP_SYS_BOM;
571 	} else if(!strcasecmp((char*) pName, "$UPTIME")) {
572 		*pPropID = PROP_SYS_UPTIME;
573 	} else if(!strncmp((char*) pName, "$!", 2) || pName[0] == '!') {
574 		*pPropID = PROP_CEE;
575 	} else if(!strncmp((char*) pName, "$.", 2) || pName[0] == '.') {
576 		*pPropID = PROP_LOCAL_VAR;
577 	} else if(!strncmp((char*) pName, "$/", 2) || pName[0] == '/') {
578 		*pPropID = PROP_GLOBAL_VAR;
579 	} else {
580 		DBGPRINTF("PROP_INVALID for name '%s'\n", pName);
581 		*pPropID = PROP_INVALID;
582 		iRet = RS_RET_VAR_NOT_FOUND;
583 	}
584 	RETiRet;
585 }
586 <a name="0"></a>
587 uchar *propIDToName(propid_t propID)
588 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
589 	switch(propID) {
590 		case PROP_MSG:
591 			return UCHAR_CONSTANT("msg");
592 		case PROP_TIMESTAMP:
593 			return UCHAR_CONSTANT("timestamp");
594 		case PROP_HOSTNAME:
595 			return UCHAR_CONSTANT("hostname");
596 		case PROP_SYSLOGTAG:
597 			return UCHAR_CONSTANT("syslogtag");
598 		case PROP_RAWMSG:
599 			return UCHAR_CONSTANT("rawmsg");</b></font>
600 		case PROP_RAWMSG_AFTER_PRI:
601 			return UCHAR_CONSTANT("rawmsg-after-pri");
602 		case PROP_INPUTNAME:
603 			return UCHAR_CONSTANT("inputname");
604 		case PROP_FROMHOST:
605 			return UCHAR_CONSTANT("fromhost");
606 		case PROP_FROMHOST_IP:
607 			return UCHAR_CONSTANT("fromhost-ip");
608 		case PROP_PRI:
609 			return UCHAR_CONSTANT("pri");
610 		case PROP_PRI_TEXT:
611 			return UCHAR_CONSTANT("pri-text");
612 		case PROP_IUT:
613 			return UCHAR_CONSTANT("iut");
614 		case PROP_SYSLOGFACILITY:
615 			return UCHAR_CONSTANT("syslogfacility");
616 		case PROP_SYSLOGFACILITY_TEXT:
617 			return UCHAR_CONSTANT("syslogfacility-text");
618 		case PROP_SYSLOGSEVERITY:
619 			return UCHAR_CONSTANT("syslogseverity");
620 		case PROP_SYSLOGSEVERITY_TEXT:
621 			return UCHAR_CONSTANT("syslogseverity-text");
622 		case PROP_TIMEGENERATED:
623 			return UCHAR_CONSTANT("timegenerated");
624 		case PROP_PROGRAMNAME:
625 			return UCHAR_CONSTANT("programname");
626 		case PROP_PROTOCOL_VERSION:
627 			return UCHAR_CONSTANT("protocol-version");
628 		case PROP_STRUCTURED_DATA:
629 			return UCHAR_CONSTANT("structured-data");
630 		case PROP_APP_NAME:
631 			return UCHAR_CONSTANT("app-name");
632 		case PROP_PROCID:
633 			return UCHAR_CONSTANT("procid");
634 		case PROP_MSGID:
635 			return UCHAR_CONSTANT("msgid");
636 		case PROP_JSONMESG:
637 			return UCHAR_CONSTANT("jsonmesg");
638 		case PROP_PARSESUCCESS:
639 			return UCHAR_CONSTANT("parsesuccess");
640 #ifdef USE_LIBUUID
641 		case PROP_UUID:
642 			return UCHAR_CONSTANT("uuid");
643 #endif
644 		case PROP_SYS_NOW:
645 			return UCHAR_CONSTANT("$NOW");
646 		case PROP_SYS_YEAR:
647 			return UCHAR_CONSTANT("$YEAR");
648 		case PROP_SYS_MONTH:
649 			return UCHAR_CONSTANT("$MONTH");
650 		case PROP_SYS_DAY:
651 			return UCHAR_CONSTANT("$DAY");
652 		case PROP_SYS_HOUR:
653 			return UCHAR_CONSTANT("$HOUR");
654 		case PROP_SYS_HHOUR:
655 			return UCHAR_CONSTANT("$HHOUR");
656 		case PROP_SYS_QHOUR:
657 			return UCHAR_CONSTANT("$QHOUR");
658 		case PROP_SYS_MINUTE:
659 			return UCHAR_CONSTANT("$MINUTE");
660 		case PROP_SYS_NOW_UTC:
661 			return UCHAR_CONSTANT("$NOW-UTC");
662 		case PROP_SYS_YEAR_UTC:
663 			return UCHAR_CONSTANT("$YEAR-UTC");
664 		case PROP_SYS_MONTH_UTC:
665 			return UCHAR_CONSTANT("$MONTH-UTC");
666 		case PROP_SYS_DAY_UTC:
667 			return UCHAR_CONSTANT("$DAY-UTC");
668 		case PROP_SYS_HOUR_UTC:
669 			return UCHAR_CONSTANT("$HOUR-UTC");
670 		case PROP_SYS_HHOUR_UTC:
671 			return UCHAR_CONSTANT("$HHOUR-UTC");
672 		case PROP_SYS_QHOUR_UTC:
673 			return UCHAR_CONSTANT("$QHOUR-UTC");
674 		case PROP_SYS_MINUTE_UTC:
675 			return UCHAR_CONSTANT("$MINUTE-UTC");
676 		case PROP_SYS_WDAY:
677 			return UCHAR_CONSTANT("$WDAY");
678 		case PROP_SYS_WDAY_UTC:
679 			return UCHAR_CONSTANT("$WDAY-UTC");
680 		case PROP_SYS_NOW_UXTIMESTAMP:
681 			return UCHAR_CONSTANT("$NOW-UNIXTIMESTAMP");
682 		case PROP_SYS_MYHOSTNAME:
683 			return UCHAR_CONSTANT("$MYHOSTNAME");
684 		case PROP_CEE_ALL_JSON:
685 			return UCHAR_CONSTANT("$!all-json");
686 		case PROP_CEE_ALL_JSON_PLAIN:
687 			return UCHAR_CONSTANT("$!all-json-plain");
688 		case PROP_SYS_BOM:
689 			return UCHAR_CONSTANT("$BOM");
690 		case PROP_SYS_UPTIME:
691 			return UCHAR_CONSTANT("$UPTIME");
692 		case PROP_CEE:
693 			return UCHAR_CONSTANT("*CEE-based property*");
694 		case PROP_LOCAL_VAR:
695 			return UCHAR_CONSTANT("*LOCAL_VARIABLE*");
696 		case PROP_GLOBAL_VAR:
697 			return UCHAR_CONSTANT("*GLOBAL_VARIABLE*");
698 		default:
699 			return UCHAR_CONSTANT("*invalid property id*");
700 	}
701 }
702 static rsRetVal
703 msgBaseConstruct(smsg_t **ppThis)
704 {
705 	DEFiRet;
706 	smsg_t *pM;
707 	assert(ppThis != NULL);
708 	CHKmalloc(pM = malloc(sizeof(smsg_t)));
709 	objConstructSetObjInfo(pM); 
710 	pM-&gt;flowCtlType = 0;
711 	pM-&gt;bParseSuccess = 0;
712 	pM-&gt;iRefCount = 1;
713 	pM-&gt;iSeverity = LOG_DEBUG;
714 	pM-&gt;iFacility = LOG_INVLD;
715 	pM-&gt;iLenPROGNAME = -1;
716 	pM-&gt;offAfterPRI = 0;
717 	pM-&gt;offMSG = -1;
718 	pM-&gt;iProtocolVersion = 0;
719 	pM-&gt;msgFlags = 0;
720 	pM-&gt;iLenRawMsg = 0;
721 	pM-&gt;iLenMSG = 0;
722 	pM-&gt;iLenTAG = 0;
723 	pM-&gt;iLenHOSTNAME = 0;
724 	pM-&gt;pszRawMsg = NULL;
725 	pM-&gt;pszHOSTNAME = NULL;
726 	pM-&gt;pszRcvdAt3164 = NULL;
727 	pM-&gt;pszRcvdAt3339 = NULL;
728 	pM-&gt;pszRcvdAt_MySQL = NULL;
729 	pM-&gt;pszRcvdAt_PgSQL = NULL;
730 	pM-&gt;pszTIMESTAMP3164 = NULL;
731 	pM-&gt;pszTIMESTAMP3339 = NULL;
732 	pM-&gt;pszTIMESTAMP_MySQL = NULL;
733 	pM-&gt;pszTIMESTAMP_PgSQL = NULL;
734 	pM-&gt;pszStrucData = NULL;
735 	pM-&gt;lenStrucData = 0;
736 	pM-&gt;pCSAPPNAME = NULL;
737 	pM-&gt;pCSPROCID = NULL;
738 	pM-&gt;pCSMSGID = NULL;
739 	pM-&gt;pInputName = NULL;
740 	pM-&gt;pRcvFromIP = NULL;
741 	pM-&gt;rcvFrom.pRcvFrom = NULL;
742 	pM-&gt;pRuleset = NULL;
743 	pM-&gt;json = NULL;
744 	pM-&gt;localvars = NULL;
745 	pM-&gt;dfltTZ[0] = '\0';
746 	memset(&amp;pM-&gt;tRcvdAt, 0, sizeof(pM-&gt;tRcvdAt));
747 	memset(&amp;pM-&gt;tTIMESTAMP, 0, sizeof(pM-&gt;tTIMESTAMP));
748 	pM-&gt;TAG.pszTAG = NULL;
749 	pM-&gt;pszTimestamp3164[0] = '\0';
750 	pM-&gt;pszTimestamp3339[0] = '\0';
751 	pM-&gt;pszTIMESTAMP_SecFrac[0] = '\0';
752 	pM-&gt;pszRcvdAt_SecFrac[0] = '\0';
753 	pM-&gt;pszTIMESTAMP_Unix[0] = '\0';
754 	pM-&gt;pszRcvdAt_Unix[0] = '\0';
755 	pM-&gt;pszUUID = NULL;
756 	pthread_mutex_init(&amp;pM-&gt;mut, NULL);
757 	#if DEV_DEBUG == 1
758 	dbgprintf("msgConstruct\t0x%x, ref 1\n", (int)pM);
759 	#endif
760 	*ppThis = pM;
761 finalize_it:
762 	RETiRet;
763 }
764 rsRetVal msgConstructWithTime(smsg_t **ppThis, const struct syslogTime *stTime, const time_t ttGenTime)
765 {
766 	DEFiRet;
767 	CHKiRet(msgBaseConstruct(ppThis));
768 	(*ppThis)-&gt;ttGenTime = ttGenTime;
769 	memcpy(&amp;(*ppThis)-&gt;tRcvdAt, stTime, sizeof(struct syslogTime));
770 	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, stTime, sizeof(struct syslogTime));
771 finalize_it:
772 	RETiRet;
773 }
774 rsRetVal msgConstruct(smsg_t **ppThis)
775 {
776 	DEFiRet;
777 	CHKiRet(msgBaseConstruct(ppThis));
778 	datetime.getCurrTime(&amp;((*ppThis)-&gt;tRcvdAt), &amp;((*ppThis)-&gt;ttGenTime), TIME_IN_LOCALTIME);
779 	memcpy(&amp;(*ppThis)-&gt;tTIMESTAMP, &amp;(*ppThis)-&gt;tRcvdAt, sizeof(struct syslogTime));
780 finalize_it:
781 	RETiRet;
782 }
783 rsRetVal
784 msgConstructForDeserializer(smsg_t **ppThis)
785 {
786 	return msgBaseConstruct(ppThis);
787 }
788 static inline void freeTAG(smsg_t *pThis)
789 {
790 	if(pThis-&gt;iLenTAG &gt;= CONF_TAG_BUFSIZE)
791 		free(pThis-&gt;TAG.pszTAG);
792 }
793 static inline void freeHOSTNAME(smsg_t *pThis)
794 {
795 	if(pThis-&gt;iLenHOSTNAME &gt;= CONF_HOSTNAME_BUFSIZE)
796 		free(pThis-&gt;pszHOSTNAME);
797 }
798 rsRetVal msgDestruct(smsg_t **ppThis)
799 {
800 	DEFiRet;
801 	smsg_t *pThis;
802 	int currRefCount;
803 #	ifdef HAVE_MALLOC_TRIM
804 	int currCnt;
805 #	endif
806 CODESTARTobjDestruct(msg)
807 	#if DEV_DEBUG == 1
808 	dbgprintf("msgDestruct\t0x%lx, "
809 		"Ref now: %d\n", (unsigned long)pThis, pThis-&gt;iRefCount - 1);
810 	#endif
811 #	ifdef HAVE_ATOMIC_BUILTINS
812 		currRefCount = ATOMIC_DEC_AND_FETCH(&amp;pThis-&gt;iRefCount, NULL);
813 #	else
814 		MsgLock(pThis);
815 		currRefCount = --pThis-&gt;iRefCount;
816 # 	endif
817 	if(currRefCount == 0)
818 	{
819 		#if DEV_DEBUG == 1
820 		dbgprintf("msgDestruct\t0x%lx, RefCount now 0, doing DESTROY\n",
821 			(unsigned long)pThis);
822 		#endif
823 		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
824 			free(pThis-&gt;pszRawMsg);
825 		freeTAG(pThis);
826 		freeHOSTNAME(pThis);
827 		if(pThis-&gt;pInputName != NULL)
828 			prop.Destruct(&amp;pThis-&gt;pInputName);
829 		if((pThis-&gt;msgFlags &amp; NEEDS_DNSRESOL) == 0) {
830 			if(pThis-&gt;rcvFrom.pRcvFrom != NULL)
831 				prop.Destruct(&amp;pThis-&gt;rcvFrom.pRcvFrom);
832 		} else {
833 			free(pThis-&gt;rcvFrom.pfrominet);
834 		}
835 		if(pThis-&gt;pRcvFromIP != NULL)
836 			prop.Destruct(&amp;pThis-&gt;pRcvFromIP);
837 		free(pThis-&gt;pszRcvdAt3164);
838 		free(pThis-&gt;pszRcvdAt3339);
839 		free(pThis-&gt;pszRcvdAt_MySQL);
840 		free(pThis-&gt;pszRcvdAt_PgSQL);
841 		free(pThis-&gt;pszTIMESTAMP_MySQL);
842 		free(pThis-&gt;pszTIMESTAMP_PgSQL);
843 		free(pThis-&gt;pszStrucData);
844 		if(pThis-&gt;iLenPROGNAME &gt;= CONF_PROGNAME_BUFSIZE)
845 			free(pThis-&gt;PROGNAME.ptr);
846 		if(pThis-&gt;pCSAPPNAME != NULL)
847 			rsCStrDestruct(&amp;pThis-&gt;pCSAPPNAME);
848 		if(pThis-&gt;pCSPROCID != NULL)
849 			rsCStrDestruct(&amp;pThis-&gt;pCSPROCID);
850 		if(pThis-&gt;pCSMSGID != NULL)
851 			rsCStrDestruct(&amp;pThis-&gt;pCSMSGID);
852 		if(pThis-&gt;json != NULL)
853 			json_object_put(pThis-&gt;json);
854 		if(pThis-&gt;localvars != NULL)
855 			json_object_put(pThis-&gt;localvars);
856 		if(pThis-&gt;pszUUID != NULL)
857 			free(pThis-&gt;pszUUID);
858 #	ifndef HAVE_ATOMIC_BUILTINS
859 		MsgUnlock(pThis);
860 # 	endif
861 		pthread_mutex_destroy(&amp;pThis-&gt;mut);
862 #		ifdef HAVE_MALLOC_TRIM
863 			static unsigned iTrimCtr = 1;
864 			currCnt = ATOMIC_INC_AND_FETCH_unsigned(&amp;iTrimCtr, &amp;mutTrimCtr);
865 			if(currCnt % 100000 == 0) {
866 				malloc_trim(128*1024);
867 			}
868 		}
869 #		endif
870 	} else {
871 #	ifndef HAVE_ATOMIC_BUILTINS
872 		MsgUnlock(pThis);
873 # 	endif
874 		pThis = NULL; 	}
875 ENDobjDestruct(msg)
876 #define tmpCOPYSZ(name) \
877 	if(pOld-&gt;psz##name != NULL) { \
878 		if((pNew-&gt;psz##name = srUtilStrDup(pOld-&gt;psz##name, pOld-&gt;iLen##name)) == NULL) {\
879 			msgDestruct(&amp;pNew);\
880 			return NULL;\
881 		}\
882 		pNew-&gt;iLen##name = pOld-&gt;iLen##name;\
883 	}
884 #define tmpCOPYCSTR(name) \
885 	if(pOld-&gt;pCS##name != NULL) {\
886 		if(rsCStrConstructFromCStr(&amp;(pNew-&gt;pCS##name), pOld-&gt;pCS##name) != RS_RET_OK) {\
887 			msgDestruct(&amp;pNew);\
888 			return NULL;\
889 		}\
890 		cstrFinalize(pNew-&gt;pCS##name); \
891 	}
892 smsg_t* MsgDup(smsg_t* pOld)
893 {
894 	smsg_t* pNew;
895 	rsRetVal localRet;
896 	assert(pOld != NULL);
897 	if(msgConstructWithTime(&amp;pNew, &amp;pOld-&gt;tTIMESTAMP, pOld-&gt;ttGenTime) != RS_RET_OK) {
898 		return NULL;
899 	}
900 	pNew-&gt;iRefCount = 1;
901 	pNew-&gt;iSeverity = pOld-&gt;iSeverity;
902 	pNew-&gt;iFacility = pOld-&gt;iFacility;
903 	pNew-&gt;msgFlags = pOld-&gt;msgFlags;
904 	pNew-&gt;iProtocolVersion = pOld-&gt;iProtocolVersion;
905 	pNew-&gt;tRcvdAt = pOld-&gt;tRcvdAt;
906 	pNew-&gt;offMSG = pOld-&gt;offMSG;
907 	pNew-&gt;iLenRawMsg = pOld-&gt;iLenRawMsg;
908 	pNew-&gt;iLenMSG = pOld-&gt;iLenMSG;
909 	pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
910 	pNew-&gt;iLenHOSTNAME = pOld-&gt;iLenHOSTNAME;
911 	if((pOld-&gt;msgFlags &amp; NEEDS_DNSRESOL)) {
912 			localRet = msgSetFromSockinfo(pNew, pOld-&gt;rcvFrom.pfrominet);
913 			if(localRet != RS_RET_OK) {
914 				pNew-&gt;msgFlags &amp;= ~NEEDS_DNSRESOL;
915 				pNew-&gt;rcvFrom.pRcvFrom = NULL; 			}
916 	} else {
917 		if(pOld-&gt;rcvFrom.pRcvFrom != NULL) {
918 			pNew-&gt;rcvFrom.pRcvFrom = pOld-&gt;rcvFrom.pRcvFrom;
919 			prop.AddRef(pNew-&gt;rcvFrom.pRcvFrom);
920 		}
921 	}
922 	if(pOld-&gt;pRcvFromIP != NULL) {
923 		pNew-&gt;pRcvFromIP = pOld-&gt;pRcvFromIP;
924 		prop.AddRef(pNew-&gt;pRcvFromIP);
925 	}
926 	if(pOld-&gt;pInputName != NULL) {
927 		pNew-&gt;pInputName = pOld-&gt;pInputName;
928 		prop.AddRef(pNew-&gt;pInputName);
929 	}
930 	if(pOld-&gt;iLenTAG &gt; 0) {
931 		if(pOld-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
932 			memcpy(pNew-&gt;TAG.szBuf, pOld-&gt;TAG.szBuf, pOld-&gt;iLenTAG + 1);
933 		} else {
934 			if((pNew-&gt;TAG.pszTAG = srUtilStrDup(pOld-&gt;TAG.pszTAG, pOld-&gt;iLenTAG)) == NULL) {
935 				msgDestruct(&amp;pNew);
936 				return NULL;
937 			}
938 			pNew-&gt;iLenTAG = pOld-&gt;iLenTAG;
939 		}
940 	}
941 	if(pOld-&gt;pszRawMsg == pOld-&gt;szRawMsg) {
942 		memcpy(pNew-&gt;szRawMsg, pOld-&gt;szRawMsg, pOld-&gt;iLenRawMsg + 1);
943 		pNew-&gt;pszRawMsg = pNew-&gt;szRawMsg;
944 	} else {
945 		tmpCOPYSZ(RawMsg);
946 	}
947 	if(pOld-&gt;pszHOSTNAME == NULL) {
948 		pNew-&gt;pszHOSTNAME = NULL;
949 	} else {
950 		if(pOld-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
951 			memcpy(pNew-&gt;szHOSTNAME, pOld-&gt;szHOSTNAME, pOld-&gt;iLenHOSTNAME + 1);
952 			pNew-&gt;pszHOSTNAME = pNew-&gt;szHOSTNAME;
953 		} else {
954 			tmpCOPYSZ(HOSTNAME);
955 		}
956 	}
957 	if(pOld-&gt;pszStrucData == NULL) {
958 		pNew-&gt;pszStrucData = NULL;
959 	} else {
960 		pNew-&gt;pszStrucData = (uchar*)strdup((char*)pOld-&gt;pszStrucData);
961 		pNew-&gt;lenStrucData = pOld-&gt;lenStrucData;
962 	}
963 	tmpCOPYCSTR(APPNAME);
964 	tmpCOPYCSTR(PROCID);
965 	tmpCOPYCSTR(MSGID);
966 	if(pOld-&gt;json != NULL)
967 		pNew-&gt;json = jsonDeepCopy(pOld-&gt;json);
968 	if(pOld-&gt;localvars != NULL)
969 		pNew-&gt;localvars = jsonDeepCopy(pOld-&gt;localvars);
970 	return pNew;
971 }
972 #undef tmpCOPYSZ
973 #undef tmpCOPYCSTR
974 static rsRetVal MsgSerialize(smsg_t *pThis, strm_t *pStrm)
975 {
976 	uchar *psz;
977 	int len;
978 	DEFiRet;
979 	assert(pThis != NULL);
980 	assert(pStrm != NULL);
981 	CHKiRet(obj.BeginSerialize(pStrm, (obj_t*) pThis));
982 	objSerializeSCALAR(pStrm, iProtocolVersion, SHORT);
983 	objSerializeSCALAR(pStrm, iSeverity, SHORT);
984 	objSerializeSCALAR(pStrm, iFacility, SHORT);
985 	objSerializeSCALAR(pStrm, msgFlags, INT);
986 	objSerializeSCALAR(pStrm, ttGenTime, INT);
987 	objSerializeSCALAR(pStrm, tRcvdAt, SYSLOGTIME);
988 	objSerializeSCALAR(pStrm, tTIMESTAMP, SYSLOGTIME);
989 	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszTAG"), PROPTYPE_PSZ, (void*)
990 		((pThis-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pThis-&gt;TAG.szBuf : pThis-&gt;TAG.pszTAG)));
991 	objSerializePTR(pStrm, pszRawMsg, PSZ);
992 	objSerializePTR(pStrm, pszHOSTNAME, PSZ);
993 	getInputName(pThis, &amp;psz, &amp;len);
994 	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszInputName"), PROPTYPE_PSZ, (void*) psz));
995 	psz = getRcvFrom(pThis);
996 	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRcvFrom"), PROPTYPE_PSZ, (void*) psz));
997 	psz = getRcvFromIP(pThis);
998 	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRcvFromIP"), PROPTYPE_PSZ, (void*) psz));
999 	psz = pThis-&gt;pszStrucData;
1000 	CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszStrucData"), PROPTYPE_PSZ, (void*) psz));
1001 	if(pThis-&gt;json != NULL) {
1002 		MsgLock(pThis);
1003 		psz = (uchar*) json_object_get_string(pThis-&gt;json);
1004 		MsgUnlock(pThis);
1005 		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("json"), PROPTYPE_PSZ, (void*) psz));
1006 	}
1007 	if(pThis-&gt;localvars != NULL) {
1008 		MsgLock(pThis);
1009 		psz = (uchar*) json_object_get_string(pThis-&gt;localvars);
1010 		MsgUnlock(pThis);
1011 		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("localvars"), PROPTYPE_PSZ, (void*) psz));
1012 	}
1013 	objSerializePTR(pStrm, pCSAPPNAME, CSTR);
1014 	objSerializePTR(pStrm, pCSPROCID, CSTR);
1015 	objSerializePTR(pStrm, pCSMSGID, CSTR);
1016 	objSerializePTR(pStrm, pszUUID, PSZ);
1017 	if(pThis-&gt;pRuleset != NULL) {
1018 		CHKiRet(obj.SerializeProp(pStrm, UCHAR_CONSTANT("pszRuleset"), PROPTYPE_PSZ,
1019 			rulesetGetName(pThis-&gt;pRuleset)));
1020 	}
1021 	objSerializeSCALAR(pStrm, offMSG, INT);
1022 	CHKiRet(obj.EndSerialize(pStrm));
1023 finalize_it:
1024 	RETiRet;
1025 }
1026 static void
1027 reinitVar(var_t *pVar)
1028 {
1029 	rsCStrDestruct(&amp;pVar-&gt;pcsName); 	if(pVar-&gt;varType == VARTYPE_STR) {
1030 		if(pVar-&gt;val.pStr != NULL)
1031 			rsCStrDestruct(&amp;pVar-&gt;val.pStr);
1032 	}
1033 }
1034 #define isProp(name) !rsCStrSzStrCmp(pVar-&gt;pcsName, (uchar*) name, sizeof(name) - 1)
1035 rsRetVal
1036 MsgDeserialize(smsg_t * const pMsg, strm_t *pStrm)
1037 {
1038 	prop_t *myProp;
1039 	prop_t *propRcvFrom = NULL;
1040 	prop_t *propRcvFromIP = NULL;
1041 	struct json_tokener *tokener;
1042 	var_t *pVar = NULL;
1043 	DEFiRet;
1044 	ISOBJ_TYPE_assert(pStrm, strm);
1045 	CHKiRet(var.Construct(&amp;pVar));
1046 	CHKiRet(var.ConstructFinalize(pVar));
1047 	CHKiRet(objDeserializeProperty(pVar, pStrm));
1048 	if(isProp("iProtocolVersion")) {
1049 		setProtocolVersion(pMsg, pVar-&gt;val.num);
1050 		reinitVar(pVar);
1051 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1052 	}
1053 	if(isProp("iSeverity")) {
1054 		pMsg-&gt;iSeverity = pVar-&gt;val.num;
1055 		reinitVar(pVar);
1056 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1057 	}
1058 	if(isProp("iFacility")) {
1059 		pMsg-&gt;iFacility = pVar-&gt;val.num;
1060 		reinitVar(pVar);
1061 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1062 	}
1063 	if(isProp("msgFlags")) {
1064 		pMsg-&gt;msgFlags = pVar-&gt;val.num;
1065 		reinitVar(pVar);
1066 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1067 	}
1068 	if(isProp("ttGenTime")) {
1069 		pMsg-&gt;ttGenTime = pVar-&gt;val.num;
1070 		reinitVar(pVar);
1071 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1072 	}
1073 	if(isProp("tRcvdAt")) {
1074 		memcpy(&amp;pMsg-&gt;tRcvdAt, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
1075 		reinitVar(pVar);
1076 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1077 	}
1078 	if(isProp("tTIMESTAMP")) {
1079 		memcpy(&amp;pMsg-&gt;tTIMESTAMP, &amp;pVar-&gt;val.vSyslogTime, sizeof(struct syslogTime));
1080 		reinitVar(pVar);
1081 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1082 	}
1083 	if(isProp("pszTAG")) {
1084 		MsgSetTAG(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
1085 		reinitVar(pVar);
1086 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1087 	}
1088 	if(isProp("pszRawMsg")) {
1089 		MsgSetRawMsg(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), cstrLen(pVar-&gt;val.pStr));
1090 		reinitVar(pVar);
1091 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1092 	}
1093 	if(isProp("pszHOSTNAME")) {
1094 		MsgSetHOSTNAME(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr));
1095 		reinitVar(pVar);
1096 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1097 	}
1098 	if(isProp("pszInputName")) {
1099 		CHKiRet(prop.Construct(&amp;myProp));
1100 		CHKiRet(prop.SetString(myProp, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr)));
1101 		CHKiRet(prop.ConstructFinalize(myProp));
1102 		MsgSetInputName(pMsg, myProp);
1103 		prop.Destruct(&amp;myProp);
1104 		reinitVar(pVar);
1105 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1106 	}
1107 	if(isProp("pszRcvFrom")) {
1108 		MsgSetRcvFromStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr), &amp;propRcvFrom);
1109 		prop.Destruct(&amp;propRcvFrom);
1110 		reinitVar(pVar);
1111 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1112 	}
1113 	if(isProp("pszRcvFromIP")) {
1114 		MsgSetRcvFromIPStr(pMsg, rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr), rsCStrLen(pVar-&gt;val.pStr),
1115 			&amp;propRcvFromIP);
1116 		prop.Destruct(&amp;propRcvFromIP);
1117 		reinitVar(pVar);
1118 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1119 	}
1120 	if(isProp("pszStrucData")) {
1121 		MsgSetStructuredData(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
1122 		reinitVar(pVar);
1123 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1124 	}
1125 	if(isProp("json")) {
1126 		tokener = json_tokener_new();
1127 		pMsg-&gt;json = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
1128 					     cstrLen(pVar-&gt;val.pStr));
1129 		json_tokener_free(tokener);
1130 		reinitVar(pVar);
1131 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1132 	}
1133 	if(isProp("localvars")) {
1134 		tokener = json_tokener_new();
1135 		pMsg-&gt;localvars = json_tokener_parse_ex(tokener, (char*)rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr),
1136 						        cstrLen(pVar-&gt;val.pStr));
1137 		json_tokener_free(tokener);
1138 		reinitVar(pVar);
1139 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1140 	}
1141 	if(isProp("pCSAPPNAME")) {
1142 		MsgSetAPPNAME(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
1143 		reinitVar(pVar);
1144 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1145 	}
1146 	if(isProp("pCSPROCID")) {
1147 		MsgSetPROCID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
1148 		reinitVar(pVar);
1149 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1150 	}
1151 	if(isProp("pCSMSGID")) {
1152 		MsgSetMSGID(pMsg, (char*) rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
1153 		reinitVar(pVar);
1154 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1155 	}
1156 	if(isProp("pszUUID")) {
1157 		pMsg-&gt;pszUUID = ustrdup(rsCStrGetSzStrNoNULL(pVar-&gt;val.pStr));
1158 		reinitVar(pVar);
1159 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1160 	}
1161 	if(isProp("pszRuleset")) {
1162 		MsgSetRulesetByName(pMsg, pVar-&gt;val.pStr);
1163 		reinitVar(pVar);
1164 		CHKiRet(objDeserializeProperty(pVar, pStrm));
1165 	}
1166 	if(!isProp("offMSG")) {
1167 		DBGPRINTF("error property: %s\n", rsCStrGetSzStrNoNULL(pVar-&gt;pcsName));
1168 		ABORT_FINALIZE(RS_RET_DS_PROP_SEQ_ERR);
1169 	}
1170 	MsgSetMSGoffs(pMsg, pVar-&gt;val.num);
1171 finalize_it:
1172 	if(pVar != NULL)
1173 		var.Destruct(&amp;pVar);
1174 	if(Debug &amp;&amp; iRet != RS_RET_OK) {
1175 		dbgprintf("MsgDeserialize error %d\n", iRet);
1176 	}
1177 	RETiRet;
1178 }
1179 #undef isProp
1180 smsg_t *MsgAddRef(smsg_t * const pM)
1181 {
1182 	assert(pM != NULL);
1183 #	ifdef HAVE_ATOMIC_BUILTINS
1184 		ATOMIC_INC(&amp;pM-&gt;iRefCount, NULL);
1185 #	else
1186 		MsgLock(pM);
1187 		pM-&gt;iRefCount++;
1188 		MsgUnlock(pM);
1189 #	endif
1190 	#if DEV_DEBUG == 1
1191 	dbgprintf("MsgAddRef\t0x%x done, Ref now: %d\n", (int)pM, pM-&gt;iRefCount);
1192 	#endif
1193 	return(pM);
1194 }
1195 static rsRetVal acquirePROCIDFromTAG(smsg_t * const pM)
1196 {
1197 	register int i;
1198 	uchar *pszTag;
1199 	DEFiRet;
1200 	assert(pM != NULL);
1201 	if(pM-&gt;pCSPROCID != NULL)
1202 		return RS_RET_OK; 
1203 	if(msgGetProtocolVersion(pM) != 0)
1204 		return RS_RET_OK; 
1205 	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);
1206 	i = 0;
1207 	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != '['))
1208 		++i;
1209 	if(!(i &lt; pM-&gt;iLenTAG))
1210 		return RS_RET_OK;	
1211 	++i; 
1212 	CHKiRet(cstrConstruct(&amp;pM-&gt;pCSPROCID));
1213 	while((i &lt; pM-&gt;iLenTAG) &amp;&amp; (pszTag[i] != ']')) {
1214 		CHKiRet(cstrAppendChar(pM-&gt;pCSPROCID, pszTag[i]));
1215 		++i;
1216 	}
1217 	if(!(i &lt; pM-&gt;iLenTAG)) {
1218 		cstrDestruct(&amp;pM-&gt;pCSPROCID);
1219 		FINALIZE;
1220 	}
1221 	cstrFinalize(pM-&gt;pCSPROCID);
1222 finalize_it:
1223 	RETiRet;
1224 }
1225 static rsRetVal
1226 acquireProgramName(smsg_t * const pM)
1227 {
1228 	int i;
1229 	uchar *pszTag, *pszProgName;
1230 	DEFiRet;
1231 	assert(pM != NULL);
1232 	pszTag = (uchar*) ((pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG);
1233 	for(  i = 0
1234 	    ; (i &lt; pM-&gt;iLenTAG) &amp;&amp; isprint((int) pszTag[i])
1235 	      &amp;&amp; (pszTag[i] != '\0') &amp;&amp; (pszTag[i] != ':')
1236 	      &amp;&amp; (pszTag[i] != '[')
1237 	      &amp;&amp; (runConf-&gt;globals.parser.bPermitSlashInProgramname || (pszTag[i] != '/'))
1238 	    ; ++i)
1239 		; 	if(i &lt; CONF_PROGNAME_BUFSIZE) {
1240 		pszProgName = pM-&gt;PROGNAME.szBuf;
1241 	} else {
1242 		CHKmalloc(pM-&gt;PROGNAME.ptr = malloc(i+1));
1243 		pszProgName = pM-&gt;PROGNAME.ptr;
1244 	}
1245 	memcpy((char*)pszProgName, (char*)pszTag, i);
1246 	pszProgName[i] = '\0';
1247 	pM-&gt;iLenPROGNAME = i;
1248 finalize_it:
1249 	RETiRet;
1250 }
1251 void setProtocolVersion(smsg_t * const pM, int iNewVersion)
1252 {
1253 	assert(pM != NULL);
1254 	if(iNewVersion != 0 &amp;&amp; iNewVersion != 1) {
1255 		dbgprintf("Tried to set unsupported protocol version %d - changed to 0.\n", iNewVersion);
1256 		iNewVersion = 0;
1257 	}
1258 	pM-&gt;iProtocolVersion = iNewVersion;
1259 }
1260 static const char *getProtocolVersionString(smsg_t * const pM)
1261 {
1262 	assert(pM != NULL);
1263 	return(pM-&gt;iProtocolVersion ? "1" : "0");
1264 }
1265 void
1266 msgSetPRI(smsg_t *const __restrict__ pMsg, syslog_pri_t pri)
1267 {
1268 	if(pri &gt; LOG_MAXPRI)
1269 		pri = LOG_PRI_INVLD;
1270 	pMsg-&gt;iFacility = pri2fac(pri),
1271 	pMsg-&gt;iSeverity = pri2sev(pri);
1272 }
1273 #ifdef USE_LIBUUID
1274 static void msgSetUUID(smsg_t * const pM)
1275 {
1276 	size_t lenRes = sizeof(uuid_t) * 2 + 1;
1277 	char hex_char [] = "0123456789ABCDEF";
1278 	unsigned int byte_nbr;
1279 	uuid_t uuid;
1280 	static pthread_mutex_t mutUUID = PTHREAD_MUTEX_INITIALIZER;
1281 	dbgprintf("[MsgSetUUID] START, lenRes %llu\n", (long long unsigned) lenRes);
1282 	assert(pM != NULL);
1283 	if((pM-&gt;pszUUID = (uchar*) malloc(lenRes)) == NULL) {
1284 		pM-&gt;pszUUID = (uchar *)"";
1285 	} else {
1286 		pthread_mutex_lock(&amp;mutUUID);
1287 		uuid_generate(uuid);
1288 		pthread_mutex_unlock(&amp;mutUUID);
1289 		for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
1290 			pM-&gt;pszUUID[byte_nbr * 2 + 0] = hex_char[uuid [byte_nbr] &gt;&gt; 4];
1291 			pM-&gt;pszUUID[byte_nbr * 2 + 1] = hex_char[uuid [byte_nbr] &amp; 15];
1292 		}
1293 		pM-&gt;pszUUID[lenRes-1] = '\0';
1294 		dbgprintf("[MsgSetUUID] UUID : %s LEN: %d \n", pM-&gt;pszUUID, (int)lenRes);
1295 	}
1296 	dbgprintf("[MsgSetUUID] END\n");
1297 }
1298 static void getUUID(smsg_t * const pM, uchar **pBuf, int *piLen)
1299 {
1300 	dbgprintf("[getUUID] START\n");
1301 	if(pM == NULL) {
1302 		dbgprintf("[getUUID] pM is NULL\n");
1303 		*pBuf=	UCHAR_CONSTANT("");
1304 		*piLen = 0;
1305 	} else {
1306 		if(pM-&gt;pszUUID == NULL) {
1307 			dbgprintf("[getUUID] pM-&gt;pszUUID is NULL\n");
1308 			MsgLock(pM);
1309 			if(pM-&gt;pszUUID == NULL)
1310 				msgSetUUID(pM);
1311 			MsgUnlock(pM);
1312 		} else { 			dbgprintf("[getUUID] pM-&gt;pszUUID already exists\n");
1313 		}
1314 		*pBuf = pM-&gt;pszUUID;
1315 		*piLen = sizeof(uuid_t) * 2;
1316 	}
1317 	dbgprintf("[getUUID] END\n");
1318 }
1319 #endif
1320 int ATTR_NONNULL()
1321 getRawMsgLen(const smsg_t *const pMsg)
1322 {
1323 	return (pMsg-&gt;pszRawMsg == NULL) ?  0 : pMsg-&gt;iLenRawMsg;
1324 }
1325 void
1326 getRawMsg(const smsg_t * const pM, uchar **pBuf, int *piLen)
1327 {
1328 	if(pM == NULL) {
1329 		*pBuf=  UCHAR_CONSTANT("");
1330 		*piLen = 0;
1331 	} else {
1332 		if(pM-&gt;pszRawMsg == NULL) {
1333 			*pBuf=  UCHAR_CONSTANT("");
1334 			*piLen = 0;
1335 		} else {
1336 			*pBuf = pM-&gt;pszRawMsg;
1337 			*piLen = pM-&gt;iLenRawMsg;
1338 		}
1339 	}
1340 }
1341 void
1342 getRawMsgAfterPRI(smsg_t * const pM, uchar **pBuf, int *piLen)
1343 {
1344 	if(pM == NULL) {
1345 		*pBuf=  UCHAR_CONSTANT("");
1346 		*piLen = 0;
1347 	} else {
1348 		if(pM-&gt;pszRawMsg == NULL) {
1349 			*pBuf=  UCHAR_CONSTANT("");
1350 			*piLen = 0;
1351 		} else {
1352 			size_t offAfterPRI = 0;
1353 			if(pM-&gt;pszRawMsg[0] == '&lt;') { 				if(pM-&gt;pszRawMsg[2] == '&gt;')
1354 					offAfterPRI = 3;
1355 				else if(pM-&gt;pszRawMsg[3] == '&gt;')
1356 					offAfterPRI = 4;
1357 				else if(pM-&gt;pszRawMsg[4] == '&gt;')
1358 					offAfterPRI = 5;
1359 			}
1360 			*pBuf = pM-&gt;pszRawMsg + offAfterPRI;
1361 			*piLen = pM-&gt;iLenRawMsg - offAfterPRI;
1362 		}
1363 	}
1364 }
1365 void setMSGLen(smsg_t * const pM, int lenMsg)
1366 {
1367 	pM-&gt;iLenMSG = lenMsg;
1368 }
1369 int getMSGLen(smsg_t * const pM)
1370 {
1371 	return((pM == NULL) ? 0 : pM-&gt;iLenMSG);
1372 }
1373 uchar *getMSG(smsg_t * const pM)
1374 {
1375 	uchar *ret;
1376 	if(pM == NULL)
1377 		ret = UCHAR_CONSTANT("");
1378 	else {
1379 		if(pM-&gt;iLenMSG == 0)
1380 			ret = UCHAR_CONSTANT("");
1381 		else
1382 			ret = pM-&gt;pszRawMsg + pM-&gt;offMSG;
1383 	}
1384 	return ret;
1385 }
1386 int
1387 getPRIi(const smsg_t * const pM)
1388 {
1389 	syslog_pri_t pri = (pM-&gt;iFacility &lt;&lt; 3) + (pM-&gt;iSeverity);
1390 	if(pri &gt; 191)
1391 		pri = LOG_PRI_INVLD;
1392 	return pri;
1393 }
1394 const char *
1395 getPRI(smsg_t * const pM)
1396 {
1397 	int iPRI;
1398 	if(pM == NULL)
1399 		return "";
1400 	iPRI = getPRIi(pM);
1401 	return (iPRI &gt; 191) ? "invld" : (char*)syslog_pri_names[iPRI].pszName;
1402 }
1403 static const char *
1404 formatISOWeekOrYear(enum tplFormatTypes eFmt, struct syslogTime *pTm)
1405 {
1406 	if(pTm-&gt;year &gt;= 1970 &amp;&amp; pTm-&gt;year &lt;= 2099) {
1407 		int isoWeekYear;
1408 		int isoWeek;
1409 		isoWeek = getISOWeek(pTm, &amp;isoWeekYear);
1410 		if (eFmt == tplFmtISOWeek) {
1411 			return two_digits[isoWeek];
1412 		} else {
1413 			return years[isoWeekYear - 1967];
1414 		}
1415 	} else {
1416 		return "YEAR OUT OF RANGE(1970-2099)";
1417 	}
1418 }
1419 const char *
1420 getTimeReported(smsg_t * const pM, enum tplFormatTypes eFmt)
1421 {
1422 	if(pM == NULL)
1423 		return "";
1424 	switch(eFmt) {
1425 	case tplFmtDefault:
1426 	case tplFmtRFC3164Date:
1427 	case tplFmtRFC3164BuggyDate:
1428 		MsgLock(pM);
1429 		if(pM-&gt;pszTIMESTAMP3164 == NULL) {
1430 			pM-&gt;pszTIMESTAMP3164 = pM-&gt;pszTimestamp3164;
1431 			datetime.formatTimestamp3164(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3164,
1432 						     (eFmt == tplFmtRFC3164BuggyDate));
1433 		}
1434 		MsgUnlock(pM);
1435 		return(pM-&gt;pszTIMESTAMP3164);
1436 	case tplFmtMySQLDate:
1437 		MsgLock(pM);
1438 		if(pM-&gt;pszTIMESTAMP_MySQL == NULL) {
1439 			if((pM-&gt;pszTIMESTAMP_MySQL = malloc(15)) == NULL) {
1440 				MsgUnlock(pM);
1441 				return "";
1442 			}
1443 			datetime.formatTimestampToMySQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_MySQL);
1444 		}
1445 		MsgUnlock(pM);
1446 		return(pM-&gt;pszTIMESTAMP_MySQL);
1447 	case tplFmtPgSQLDate:
1448 		MsgLock(pM);
1449 		if(pM-&gt;pszTIMESTAMP_PgSQL == NULL) {
1450 			if((pM-&gt;pszTIMESTAMP_PgSQL = malloc(21)) == NULL) {
1451 				MsgUnlock(pM);
1452 				return "";
1453 			}
1454 			datetime.formatTimestampToPgSQL(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_PgSQL);
1455 		}
1456 		MsgUnlock(pM);
1457 		return(pM-&gt;pszTIMESTAMP_PgSQL);
1458 	case tplFmtRFC3339Date:
1459 		MsgLock(pM);
1460 		if(pM-&gt;pszTIMESTAMP3339 == NULL) {
1461 			pM-&gt;pszTIMESTAMP3339 = pM-&gt;pszTimestamp3339;
1462 			datetime.formatTimestamp3339(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP3339);
1463 		}
1464 		MsgUnlock(pM);
1465 		return(pM-&gt;pszTIMESTAMP3339);
1466 	case tplFmtUnixDate:
1467 		MsgLock(pM);
1468 		if(pM-&gt;pszTIMESTAMP_Unix[0] == '\0') {
1469 			datetime.formatTimestampUnix(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_Unix);
1470 		}
1471 		MsgUnlock(pM);
1472 		return(pM-&gt;pszTIMESTAMP_Unix);
1473 	case tplFmtSecFrac:
1474 		if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
1475 			MsgLock(pM);
1476 			if(pM-&gt;pszTIMESTAMP_SecFrac[0] == '\0') {
1477 				datetime.formatTimestampSecFrac(&amp;pM-&gt;tTIMESTAMP, pM-&gt;pszTIMESTAMP_SecFrac);
1478 			}
1479 			MsgUnlock(pM);
1480 		}
1481 		return(pM-&gt;pszTIMESTAMP_SecFrac);
1482 	case tplFmtWDayName:
1483 		return wdayNames[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
1484 	case tplFmtWDay:
1485 		return one_digit[getWeekdayNbr(&amp;pM-&gt;tTIMESTAMP)];
1486 	case tplFmtMonth:
1487 		return two_digits[(int)pM-&gt;tTIMESTAMP.month];
1488 	case tplFmtYear:
1489 		if(pM-&gt;tTIMESTAMP.year &gt;= 1967 &amp;&amp; pM-&gt;tTIMESTAMP.year &lt;= 2099)
1490 			return years[pM-&gt;tTIMESTAMP.year - 1967];
1491 		else
1492 			return "YEAR OUT OF RANGE(1967-2099)";
1493 	case tplFmtDay:
1494 		return two_digits[(int)pM-&gt;tTIMESTAMP.day];
1495 	case tplFmtHour:
1496 		return two_digits[(int)pM-&gt;tTIMESTAMP.hour];
1497 	case tplFmtMinute:
1498 		return two_digits[(int)pM-&gt;tTIMESTAMP.minute];
1499 	case tplFmtSecond:
1500 		return two_digits[(int)pM-&gt;tTIMESTAMP.second];
1501 	case tplFmtTZOffsHour:
1502 		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetHour];
1503 	case tplFmtTZOffsMin:
1504 		return two_digits[(int)pM-&gt;tTIMESTAMP.OffsetMinute];
1505 	case tplFmtTZOffsDirection:
1506 		return (pM-&gt;tTIMESTAMP.OffsetMode == '+')? "+" : "-";
1507 	case tplFmtOrdinal:
1508 		return daysInYear[getOrdinal(&amp;pM-&gt;tTIMESTAMP)];
1509 	case tplFmtWeek:
1510 		return two_digits[getWeek(&amp;pM-&gt;tTIMESTAMP)];
1511 	case tplFmtISOWeek:
1512 	case tplFmtISOWeekYear:
1513 		return formatISOWeekOrYear(eFmt, &amp;pM-&gt;tTIMESTAMP);
1514 	}
1515 	return "INVALID eFmt OPTION!";
1516 }
1517 static const char *getTimeUTC(struct syslogTime *const __restrict__ pTmIn,
1518 	const enum tplFormatTypes eFmt,
1519 	unsigned short *const __restrict__ pbMustBeFreed)
1520 {
1521 	struct syslogTime tUTC;
1522 	char *retbuf = NULL;
1523 	timeConvertToUTC(pTmIn, &amp;tUTC);
1524 	struct syslogTime *const pTm = &amp;tUTC;
1525 	switch(eFmt) {
1526 	case tplFmtDefault:
1527 		if((retbuf = malloc(16)) != NULL) {
1528 			datetime.formatTimestamp3164(pTm, retbuf, 0);
1529 		}
1530 		break;
1531 	case tplFmtMySQLDate:
1532 		if((retbuf = malloc(15)) != NULL) {
1533 			datetime.formatTimestampToMySQL(pTm, retbuf);
1534 		}
1535 		break;
1536 	case tplFmtPgSQLDate:
1537 		if((retbuf = malloc(21)) != NULL) {
1538 			datetime.formatTimestampToPgSQL(pTm, retbuf);
1539 		}
1540 		break;
1541 	case tplFmtRFC3164Date:
1542 	case tplFmtRFC3164BuggyDate:
1543 		if((retbuf = malloc(16)) != NULL) {
1544 			datetime.formatTimestamp3164(pTm, retbuf, (eFmt == tplFmtRFC3164BuggyDate));
1545 		}
1546 		break;
1547 	case tplFmtRFC3339Date:
1548 		if((retbuf = malloc(33)) != NULL) {
1549 			datetime.formatTimestamp3339(pTm, retbuf);
1550 		}
1551 		break;
1552 	case tplFmtUnixDate:
1553 		if((retbuf = malloc(12)) != NULL) {
1554 			datetime.formatTimestampUnix(pTm, retbuf);
1555 		}
1556 		break;
1557 	case tplFmtSecFrac:
1558 		if((retbuf = malloc(7)) != NULL) {
1559 			datetime.formatTimestampSecFrac(pTm, retbuf);
1560 		}
1561 		break;
1562 	case tplFmtWDayName:
1563 		retbuf = strdup(wdayNames[getWeekdayNbr(pTm)]);
1564 		break;
1565 	case tplFmtWDay:
1566 		retbuf = strdup(one_digit[getWeekdayNbr(pTm)]);
1567 		break;
1568 	case tplFmtMonth:
1569 		retbuf = strdup(two_digits[(int)pTm-&gt;month]);
1570 		break;
1571 	case tplFmtYear:
1572 		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
1573 			retbuf = strdup(years[pTm-&gt;year - 1967]);
1574 		else
1575 			retbuf = strdup("YEAR OUT OF RANGE(1967-2099)");
1576 		break;
1577 	case tplFmtDay:
1578 		retbuf = strdup(two_digits[(int)pTm-&gt;day]);
1579 		break;
1580 	case tplFmtHour:
1581 		retbuf = strdup(two_digits[(int)pTm-&gt;hour]);
1582 		break;
1583 	case tplFmtMinute:
1584 		retbuf = strdup(two_digits[(int)pTm-&gt;minute]);
1585 		break;
1586 	case tplFmtSecond:
1587 		retbuf = strdup(two_digits[(int)pTm-&gt;second]);
1588 		break;
1589 	case tplFmtTZOffsHour:
1590 		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetHour]);
1591 		break;
1592 	case tplFmtTZOffsMin:
1593 		retbuf = strdup(two_digits[(int)pTm-&gt;OffsetMinute]);
1594 		break;
1595 	case tplFmtTZOffsDirection:
1596 		retbuf = strdup((pTm-&gt;OffsetMode == '+')? "+" : "-");
1597 		break;
1598 	case tplFmtOrdinal:
1599 		retbuf = strdup(daysInYear[getOrdinal(pTm)]);
1600 		break;
1601 	case tplFmtWeek:
1602 		retbuf = strdup(two_digits[getWeek(pTm)]);
1603 		break;
1604 	case tplFmtISOWeek:
1605 	case tplFmtISOWeekYear:
1606 		retbuf = strdup(formatISOWeekOrYear(eFmt, pTm));
1607 		break;
1608 	}
1609 	if(retbuf == NULL) {
1610 		retbuf = (char*)"internal error: invalid eFmt option or malloc problem";
1611 		*pbMustBeFreed = 0;
1612 	} else {
1613 		*pbMustBeFreed = 1;
1614 	}
1615 	return retbuf;
1616 }
1617 static const char *
1618 getTimeGenerated(smsg_t *const __restrict__ pM,
1619 	const enum tplFormatTypes eFmt)
1620 {
1621 	struct syslogTime *const pTm = &amp;pM-&gt;tRcvdAt;
1622 	if(pM == NULL)
1623 		return "";
1624 	switch(eFmt) {
1625 	case tplFmtDefault:
1626 		MsgLock(pM);
1627 		if(pM-&gt;pszRcvdAt3164 == NULL) {
1628 			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
1629 				MsgUnlock(pM);
1630 				return "";
1631 			}
1632 			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164, 0);
1633 		}
1634 		MsgUnlock(pM);
1635 		return(pM-&gt;pszRcvdAt3164);
1636 	case tplFmtMySQLDate:
1637 		MsgLock(pM);
1638 		if(pM-&gt;pszRcvdAt_MySQL == NULL) {
1639 			if((pM-&gt;pszRcvdAt_MySQL = malloc(15)) == NULL) {
1640 				MsgUnlock(pM);
1641 				return "";
1642 			}
1643 			datetime.formatTimestampToMySQL(pTm, pM-&gt;pszRcvdAt_MySQL);
1644 		}
1645 		MsgUnlock(pM);
1646 		return(pM-&gt;pszRcvdAt_MySQL);
1647 	case tplFmtPgSQLDate:
1648 		MsgLock(pM);
1649 		if(pM-&gt;pszRcvdAt_PgSQL == NULL) {
1650 			if((pM-&gt;pszRcvdAt_PgSQL = malloc(21)) == NULL) {
1651 				MsgUnlock(pM);
1652 				return "";
1653 			}
1654 			datetime.formatTimestampToPgSQL(pTm, pM-&gt;pszRcvdAt_PgSQL);
1655 		}
1656 		MsgUnlock(pM);
1657 		return(pM-&gt;pszRcvdAt_PgSQL);
1658 	case tplFmtRFC3164Date:
1659 	case tplFmtRFC3164BuggyDate:
1660 		MsgLock(pM);
1661 		if(pM-&gt;pszRcvdAt3164 == NULL) {
1662 			if((pM-&gt;pszRcvdAt3164 = malloc(16)) == NULL) {
1663 					MsgUnlock(pM);
1664 					return "";
1665 				}
1666 			datetime.formatTimestamp3164(pTm, pM-&gt;pszRcvdAt3164,
1667 						     (eFmt == tplFmtRFC3164BuggyDate));
1668 		}
1669 		MsgUnlock(pM);
1670 		return(pM-&gt;pszRcvdAt3164);
1671 	case tplFmtRFC3339Date:
1672 		MsgLock(pM);
1673 		if(pM-&gt;pszRcvdAt3339 == NULL) {
1674 			if((pM-&gt;pszRcvdAt3339 = malloc(33)) == NULL) {
1675 				MsgUnlock(pM);
1676 				return "";
1677 			}
1678 			datetime.formatTimestamp3339(pTm, pM-&gt;pszRcvdAt3339);
1679 		}
1680 		MsgUnlock(pM);
1681 		return(pM-&gt;pszRcvdAt3339);
1682 	case tplFmtUnixDate:
1683 		MsgLock(pM);
1684 		if(pM-&gt;pszRcvdAt_Unix[0] == '\0') {
1685 			datetime.formatTimestampUnix(pTm, pM-&gt;pszRcvdAt_Unix);
1686 		}
1687 		MsgUnlock(pM);
1688 		return(pM-&gt;pszRcvdAt_Unix);
1689 	case tplFmtSecFrac:
1690 		if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
1691 			MsgLock(pM);
1692 			if(pM-&gt;pszRcvdAt_SecFrac[0] == '\0') {
1693 				datetime.formatTimestampSecFrac(pTm, pM-&gt;pszRcvdAt_SecFrac);
1694 			}
1695 			MsgUnlock(pM);
1696 		}
1697 		return(pM-&gt;pszRcvdAt_SecFrac);
1698 	case tplFmtWDayName:
1699 		return wdayNames[getWeekdayNbr(pTm)];
1700 	case tplFmtWDay:
1701 		return one_digit[getWeekdayNbr(pTm)];
1702 	case tplFmtMonth:
1703 		return two_digits[(int)pTm-&gt;month];
1704 	case tplFmtYear:
1705 		if(pTm-&gt;year &gt;= 1967 &amp;&amp; pTm-&gt;year &lt;= 2099)
1706 			return years[pTm-&gt;year - 1967];
1707 		else
1708 			return "YEAR OUT OF RANGE(1967-2099)";
1709 	case tplFmtDay:
1710 		return two_digits[(int)pTm-&gt;day];
1711 	case tplFmtHour:
1712 		return two_digits[(int)pTm-&gt;hour];
1713 	case tplFmtMinute:
1714 		return two_digits[(int)pTm-&gt;minute];
1715 	case tplFmtSecond:
1716 		return two_digits[(int)pTm-&gt;second];
1717 	case tplFmtTZOffsHour:
1718 		return two_digits[(int)pTm-&gt;OffsetHour];
1719 	case tplFmtTZOffsMin:
1720 		return two_digits[(int)pTm-&gt;OffsetMinute];
1721 	case tplFmtTZOffsDirection:
1722 		return (pTm-&gt;OffsetMode == '+')? "+" : "-";
1723 	case tplFmtOrdinal:
1724 		return daysInYear[getOrdinal(pTm)];
1725 	case tplFmtWeek:
1726 		return two_digits[getWeek(pTm)];
1727 	case tplFmtISOWeek:
1728 	case tplFmtISOWeekYear:
1729 		return formatISOWeekOrYear(eFmt, pTm);
1730 	}
1731 	return "INVALID eFmt OPTION!";
1732 }
1733 static const char *getSeverity(smsg_t * const pM)
1734 {
1735 	const char *name = NULL;
1736 	if(pM == NULL)
1737 		return "";
1738 	if(pM-&gt;iSeverity &gt; 7) {
1739 		name = "invld";
1740 	} else {
1741 		name = syslog_number_names[pM-&gt;iSeverity];
1742 	}
1743 	return name;
1744 }
1745 static const char *getSeverityStr(smsg_t * const pM)
1746 {
1747 	const char *name = NULL;
1748 	if(pM == NULL)
1749 		return "";
1750 	if(pM-&gt;iSeverity &gt; 7) {
1751 		name = "invld";
1752 	} else {
1753 		name = syslog_severity_names[pM-&gt;iSeverity];
1754 	}
1755 	return name;
1756 }
1757 static const char *getFacility(smsg_t * const pM)
1758 {
1759 	const char *name = NULL;
1760 	if(pM == NULL)
1761 		return "";
1762 	if(pM-&gt;iFacility &gt; 23) {
1763 		name = "invld";
1764 	} else {
1765 		name = syslog_number_names[pM-&gt;iFacility];
1766 	}
1767 	return name;
1768 }
1769 static const char *getFacilityStr(smsg_t * const pM)
1770 {
1771 	const char *name = NULL;
1772 	if(pM == NULL)
1773 		return "";
1774 	if(pM-&gt;iFacility &gt; 23) {
1775 		name = "invld";
1776 	} else {
1777 		name = syslog_fac_names[pM-&gt;iFacility];
1778 	}
1779 	return name;
1780 }
1781 rsRetVal
1782 MsgSetFlowControlType(smsg_t * const pMsg, flowControl_t eFlowCtl)
1783 {
1784 	DEFiRet;
1785 	assert(pMsg != NULL);
1786 	assert(eFlowCtl == eFLOWCTL_NO_DELAY || eFlowCtl == eFLOWCTL_LIGHT_DELAY || eFlowCtl == eFLOWCTL_FULL_DELAY);
1787 	pMsg-&gt;flowCtlType = eFlowCtl;
1788 	RETiRet;
1789 }
1790 rsRetVal
1791 MsgSetAfterPRIOffs(smsg_t * const pMsg, int offs)
1792 {
1793 	assert(pMsg != NULL);
1794 	pMsg-&gt;offAfterPRI = offs;
1795 	return RS_RET_OK;
1796 }
1797 rsRetVal ATTR_NONNULL(1,2)
1798 MsgSetAPPNAME(smsg_t *__restrict__ const pMsg, const char *pszAPPNAME)
1799 {
1800 	DEFiRet;
1801 	assert(pMsg != NULL);
1802 	if(pszAPPNAME[0] == '\0') {
1803 		pszAPPNAME = "-"; 	}
1804 	if(pMsg-&gt;pCSAPPNAME == NULL) {
1805 		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSAPPNAME));
1806 	}
1807 	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSAPPNAME, (uchar*) pszAPPNAME));
1808 	cstrFinalize(pMsg-&gt;pCSAPPNAME);
1809 finalize_it:
1810 	RETiRet;
1811 }
1812 rsRetVal MsgSetPROCID(smsg_t *__restrict__ const pMsg, const char* pszPROCID)
1813 {
1814 	DEFiRet;
1815 	ISOBJ_TYPE_assert(pMsg, msg);
1816 	if(pMsg-&gt;pCSPROCID == NULL) {
1817 		CHKiRet(cstrConstruct(&amp;pMsg-&gt;pCSPROCID));
1818 	}
1819 	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSPROCID, (uchar*) pszPROCID));
1820 	cstrFinalize(pMsg-&gt;pCSPROCID);
1821 finalize_it:
1822 	RETiRet;
1823 }
1824 static void preparePROCID(smsg_t * const pM, sbool bLockMutex)
1825 {
1826 	if(pM-&gt;pCSPROCID == NULL) {
1827 		if(bLockMutex == LOCK_MUTEX)
1828 			MsgLock(pM);
1829 		if(pM-&gt;pCSPROCID == NULL)
1830 			acquirePROCIDFromTAG(pM);
1831 		if(bLockMutex == LOCK_MUTEX)
1832 			MsgUnlock(pM);
1833 	}
1834 }
1835 #if 0
1836 static int getPROCIDLen(smsg_t *pM, sbool bLockMutex)
1837 {
1838 	assert(pM != NULL);
1839 	preparePROCID(pM, bLockMutex);
1840 	return (pM-&gt;pCSPROCID == NULL) ? 1 : rsCStrLen(pM-&gt;pCSPROCID);
1841 }
1842 #endif
1843 char *getPROCID(smsg_t * const pM, sbool bLockMutex)
1844 {
1845 	uchar *pszRet;
1846 	ISOBJ_TYPE_assert(pM, msg);
1847 	if(bLockMutex == LOCK_MUTEX)
1848 		MsgLock(pM);
1849 	preparePROCID(pM, MUTEX_ALREADY_LOCKED);
1850 	if(pM-&gt;pCSPROCID == NULL)
1851 		pszRet = UCHAR_CONSTANT("-");
1852 	else
1853 		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSPROCID);
1854 	if(bLockMutex == LOCK_MUTEX)
1855 		MsgUnlock(pM);
1856 	return (char*) pszRet;
1857 }
1858 rsRetVal MsgSetMSGID(smsg_t * const pMsg, const char* pszMSGID)
1859 {
1860 	DEFiRet;
1861 	ISOBJ_TYPE_assert(pMsg, msg);
1862 	if(pMsg-&gt;pCSMSGID == NULL) {
1863 		CHKiRet(rsCStrConstruct(&amp;pMsg-&gt;pCSMSGID));
1864 	}
1865 	CHKiRet(rsCStrSetSzStr(pMsg-&gt;pCSMSGID, (uchar*) pszMSGID));
1866 	cstrFinalize(pMsg-&gt;pCSMSGID);
1867 finalize_it:
1868 	RETiRet;
1869 }
1870 static const char *getParseSuccess(smsg_t * const pM)
1871 {
1872 	return (pM-&gt;bParseSuccess) ? "OK" : "FAIL";
1873 }
1874 static const char *getMSGID(smsg_t * const pM)
1875 {
1876 	if (pM-&gt;pCSMSGID == NULL) {
1877 		return "-";
1878 	}
1879 	else {
1880 		MsgLock(pM);
1881 		char* pszreturn = (char*) rsCStrGetSzStrNoNULL(pM-&gt;pCSMSGID);
1882 		MsgUnlock(pM);
1883 		return pszreturn;
1884 	}
1885 }
1886 void MsgSetParseSuccess(smsg_t * const pMsg, int bSuccess)
1887 {
1888 	assert(pMsg != NULL);
1889 	pMsg-&gt;bParseSuccess = bSuccess;
1890 }
1891 const uchar*
1892 msgGetJSONMESG(smsg_t *__restrict__ const pMsg)
1893 {
1894 	struct json_object *json;
1895 	struct json_object *jval;
1896 	uchar *pRes; 	rs_size_t bufLen = -1; 
1897 	json = json_object_new_object();
1898 	jval = json_object_new_string((char*)getMSG(pMsg));
1899 	json_object_object_add(json, "msg", jval);
1900 	getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
1901 	jval = json_object_new_string((char*)pRes);
1902 	json_object_object_add(json, "rawmsg", jval);
1903 	pRes = (uchar*)getTimeReported(pMsg, tplFmtRFC3339Date);
1904 	jval = json_object_new_string((char*)pRes);
1905 	json_object_object_add(json, "timereported", jval);
1906 	jval = json_object_new_string(getHOSTNAME(pMsg));
1907 	json_object_object_add(json, "hostname", jval);
1908 	getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
1909 	jval = json_object_new_string((char*)pRes);
1910 	json_object_object_add(json, "syslogtag", jval);
1911 	getInputName(pMsg, &amp;pRes, &amp;bufLen);
1912 	jval = json_object_new_string((char*)pRes);
1913 	json_object_object_add(json, "inputname", jval);
1914 	jval = json_object_new_string((char*)getRcvFrom(pMsg));
1915 	json_object_object_add(json, "fromhost", jval);
1916 	jval = json_object_new_string((char*)getRcvFromIP(pMsg));
1917 	json_object_object_add(json, "fromhost-ip", jval);
1918 	jval = json_object_new_string(getPRI(pMsg));
1919 	json_object_object_add(json, "pri", jval);
1920 	jval = json_object_new_string(getFacility(pMsg));
1921 	json_object_object_add(json, "syslogfacility", jval);
1922 	jval = json_object_new_string(getSeverity(pMsg));
1923 	json_object_object_add(json, "syslogseverity", jval);
1924 	pRes = (uchar*)getTimeGenerated(pMsg, tplFmtRFC3339Date);
1925 	jval = json_object_new_string((char*)pRes);
1926 	json_object_object_add(json, "timegenerated", jval);
1927 	jval = json_object_new_string((char*)getProgramName(pMsg, LOCK_MUTEX));
1928 	json_object_object_add(json, "programname", jval);
1929 	jval = json_object_new_string(getProtocolVersionString(pMsg));
1930 	json_object_object_add(json, "protocol-version", jval);
1931 	MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
1932 	jval = json_object_new_string((char*)pRes);
1933 	json_object_object_add(json, "structured-data", jval);
1934 	jval = json_object_new_string(getAPPNAME(pMsg, LOCK_MUTEX));
1935 	json_object_object_add(json, "app-name", jval);
1936 	jval = json_object_new_string(getPROCID(pMsg, LOCK_MUTEX));
1937 	json_object_object_add(json, "procid", jval);
1938 	jval = json_object_new_string(getMSGID(pMsg));
1939 	json_object_object_add(json, "msgid", jval);
1940 #ifdef USE_LIBUUID
1941 	if(pMsg-&gt;pszUUID == NULL) {
1942 		jval = NULL;
1943 	} else {
1944 		getUUID(pMsg, &amp;pRes, &amp;bufLen);
1945 		jval = json_object_new_string((char*)pRes);
1946 	}
1947 	json_object_object_add(json, "uuid", jval);
1948 #endif
1949 	json_object_object_add(json, "$!", json_object_get(pMsg-&gt;json));
1950 	pRes = (uchar*) strdup(json_object_get_string(json));
1951 	json_object_put(json);
1952 	return pRes;
1953 }
1954 void MsgSetRuleset(smsg_t * const pMsg, ruleset_t *pRuleset)
1955 {
1956 	assert(pMsg != NULL);
1957 	pMsg-&gt;pRuleset = pRuleset;
1958 }
1959 void MsgSetTAG(smsg_t *__restrict__ const pMsg, const uchar* pszBuf, const size_t lenBuf)
1960 {
1961 	uchar *pBuf;
1962 	assert(pMsg != NULL);
1963 	freeTAG(pMsg);
1964 	pMsg-&gt;iLenTAG = lenBuf;
1965 	if(pMsg-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) {
1966 		pBuf = pMsg-&gt;TAG.szBuf;
1967 	} else {
1968 		if((pBuf = (uchar*) malloc(pMsg-&gt;iLenTAG + 1)) == NULL) {
1969 			pBuf = pMsg-&gt;TAG.szBuf;
1970 			pMsg-&gt;iLenTAG = CONF_TAG_BUFSIZE - 1;
1971 		} else {
1972 			pMsg-&gt;TAG.pszTAG = pBuf;
1973 		}
1974 	}
1975 	memcpy(pBuf, pszBuf, pMsg-&gt;iLenTAG);
1976 	pBuf[pMsg-&gt;iLenTAG] = '\0'; }
1977 static void ATTR_NONNULL(1)
1978 tryEmulateTAG(smsg_t *const pM, const sbool bLockMutex)
1979 {
1980 	size_t lenTAG;
1981 	uchar bufTAG[CONF_TAG_MAXSIZE];
1982 	assert(pM != NULL);
1983 	if(bLockMutex == LOCK_MUTEX)
1984 		MsgLock(pM);
1985 	if(pM-&gt;iLenTAG &gt; 0) {
1986 		if(bLockMutex == LOCK_MUTEX)
1987 			MsgUnlock(pM);
1988 		return; 	}
1989 	if(msgGetProtocolVersion(pM) == 1) {
1990 		if(!strcmp(getPROCID(pM, MUTEX_ALREADY_LOCKED), "-")) {
1991 			MsgSetTAG(pM, (uchar*) getAPPNAME(pM, MUTEX_ALREADY_LOCKED),
1992 					getAPPNAMELen(pM, MUTEX_ALREADY_LOCKED));
1993 		} else {
1994 			lenTAG = snprintf((char*)bufTAG, CONF_TAG_MAXSIZE, "%s[%s]",
1995 					  getAPPNAME(pM, MUTEX_ALREADY_LOCKED), getPROCID(pM, MUTEX_ALREADY_LOCKED));
1996 			bufTAG[sizeof(bufTAG)-1] = '\0'; 			MsgSetTAG(pM, bufTAG, lenTAG);
1997 		}
1998 		pM-&gt;iLenPROGNAME = -1;
1999 	}
2000 	if(bLockMutex == LOCK_MUTEX)
2001 		MsgUnlock(pM);
2002 }
2003 void ATTR_NONNULL(2,3)
2004 getTAG(smsg_t * const pM, uchar **const ppBuf, int *const piLen, const sbool bLockMutex)
2005 {
2006 	if(pM == NULL) {
2007 		*ppBuf = UCHAR_CONSTANT("");
2008 		*piLen = 0;
2009 	} else {
2010 		if(pM-&gt;iLenTAG == 0)
2011 			tryEmulateTAG(pM, bLockMutex);
2012 		if(pM-&gt;iLenTAG == 0) {
2013 			*ppBuf = UCHAR_CONSTANT("");
2014 			*piLen = 0;
2015 		} else {
2016 			*ppBuf = (pM-&gt;iLenTAG &lt; CONF_TAG_BUFSIZE) ? pM-&gt;TAG.szBuf : pM-&gt;TAG.pszTAG;
2017 			*piLen = pM-&gt;iLenTAG;
2018 		}
2019 	}
2020 }
2021 int getHOSTNAMELen(smsg_t * const pM)
2022 {
2023 	if(pM == NULL)
2024 		return 0;
2025 	else
2026 		if(pM-&gt;pszHOSTNAME == NULL) {
2027 			resolveDNS(pM);
2028 			if(pM-&gt;rcvFrom.pRcvFrom == NULL)
2029 				return 0;
2030 			else
2031 				return prop.GetStringLen(pM-&gt;rcvFrom.pRcvFrom);
2032 		} else
2033 			return pM-&gt;iLenHOSTNAME;
2034 }
2035 const char *getHOSTNAME(smsg_t * const pM)
2036 {
2037 	if(pM == NULL)
2038 		return "";
2039 	else
2040 		if(pM-&gt;pszHOSTNAME == NULL) {
2041 			resolveDNS(pM);
2042 			if(pM-&gt;rcvFrom.pRcvFrom == NULL) {
2043 				return "";
2044 			} else {
2045 				uchar *psz;
2046 				int len;
2047 				prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
2048 				return (char*) psz;
2049 			}
2050 		} else {
2051 			return (char*) pM-&gt;pszHOSTNAME;
2052 		}
2053 }
2054 uchar *getRcvFrom(smsg_t * const pM)
2055 {
2056 	uchar *psz;
2057 	int len;
2058 	if(pM == NULL) {
2059 		psz = UCHAR_CONSTANT("");
2060 	} else {
2061 		resolveDNS(pM);
2062 		if(pM-&gt;rcvFrom.pRcvFrom == NULL)
2063 			psz = UCHAR_CONSTANT("");
2064 		else
2065 			prop.GetString(pM-&gt;rcvFrom.pRcvFrom, &amp;psz, &amp;len);
2066 	}
2067 	return psz;
2068 }
2069 rsRetVal MsgSetStructuredData(smsg_t * const pMsg, const char* pszStrucData)
2070 {
2071 	DEFiRet;
2072 	ISOBJ_TYPE_assert(pMsg, msg);
2073 	free(pMsg-&gt;pszStrucData);
2074 	CHKmalloc(pMsg-&gt;pszStrucData = (uchar*)strdup(pszStrucData));
2075 	pMsg-&gt;lenStrucData = strlen(pszStrucData);
2076 finalize_it:
2077 	RETiRet;
2078 }
2079 void
2080 MsgGetStructuredData(smsg_t * const pM, uchar **pBuf, rs_size_t *len)
2081 {
2082 	MsgLock(pM);
2083 	if(pM-&gt;pszStrucData == NULL) {
2084 		*pBuf = UCHAR_CONSTANT("-"),
2085 		*len = 1;
2086 	} else  {
2087 		*pBuf = pM-&gt;pszStrucData,
2088 		*len = pM-&gt;lenStrucData;
2089 	}
2090 	MsgUnlock(pM);
2091 }
2092 uchar * ATTR_NONNULL(1)
2093 getProgramName(smsg_t *const pM, const sbool bLockMutex)
2094 {
2095 	if(bLockMutex == LOCK_MUTEX) {
2096 		MsgLock(pM);
2097 	}
2098 	if(pM-&gt;iLenPROGNAME == -1) {
2099 		if(pM-&gt;iLenTAG == 0) {
2100 			uchar *pRes;
2101 			rs_size_t bufLen = -1;
2102 			getTAG(pM, &amp;pRes, &amp;bufLen, MUTEX_ALREADY_LOCKED);
2103 		}
2104 		acquireProgramName(pM);
2105 	}
2106 	if(bLockMutex == LOCK_MUTEX) {
2107 		MsgUnlock(pM);
2108 	}
2109 	return (pM-&gt;iLenPROGNAME &lt; CONF_PROGNAME_BUFSIZE) ? pM-&gt;PROGNAME.szBuf
2110 						       : pM-&gt;PROGNAME.ptr;
2111 }
2112 static void ATTR_NONNULL(1)
2113 prepareAPPNAME(smsg_t *const pM, const sbool bLockMutex)
2114 {
2115 	if(pM-&gt;pCSAPPNAME == NULL) {
2116 		if(bLockMutex == LOCK_MUTEX)
2117 			MsgLock(pM);
2118 		if(pM-&gt;pCSAPPNAME == NULL) {
2119 			if(msgGetProtocolVersion(pM) == 0) {
2120 				MsgSetAPPNAME(pM, (char*)getProgramName(pM, MUTEX_ALREADY_LOCKED));
2121 			}
2122 		}
2123 		if(bLockMutex == LOCK_MUTEX)
2124 			MsgUnlock(pM);
2125 	}
2126 }
2127 char *getAPPNAME(smsg_t * const pM, const sbool bLockMutex)
2128 {
2129 	uchar *pszRet;
2130 	assert(pM != NULL);
2131 	if(bLockMutex == LOCK_MUTEX)
2132 		MsgLock(pM);
2133 	prepareAPPNAME(pM, MUTEX_ALREADY_LOCKED);
2134 	if(pM-&gt;pCSAPPNAME == NULL)
2135 		pszRet = UCHAR_CONSTANT("");
2136 	else
2137 		pszRet = rsCStrGetSzStrNoNULL(pM-&gt;pCSAPPNAME);
2138 	if(bLockMutex == LOCK_MUTEX)
2139 		MsgUnlock(pM);
2140 	return (char*)pszRet;
2141 }
2142 static int getAPPNAMELen(smsg_t * const pM, const sbool bLockMutex)
2143 {
2144 	assert(pM != NULL);
2145 	prepareAPPNAME(pM, bLockMutex);
2146 	return (pM-&gt;pCSAPPNAME == NULL) ? 0 : rsCStrLen(pM-&gt;pCSAPPNAME);
2147 }
2148 void MsgSetInputName(smsg_t *pThis, prop_t *inputName)
2149 {
2150 	assert(pThis != NULL);
2151 	prop.AddRef(inputName);
2152 	if(pThis-&gt;pInputName != NULL)
2153 		prop.Destruct(&amp;pThis-&gt;pInputName);
2154 	pThis-&gt;pInputName = inputName;
2155 }
2156 void MsgSetDfltTZ(smsg_t *pThis, char *tz)
2157 {
2158 	strncpy(pThis-&gt;dfltTZ, tz, 7);
2159 	pThis-&gt;dfltTZ[7] = '\0'; }
2160 rsRetVal
2161 msgSetFromSockinfo(smsg_t *pThis, struct sockaddr_storage *sa){
2162 	DEFiRet;
2163 	assert(pThis-&gt;rcvFrom.pRcvFrom == NULL);
2164 	CHKmalloc(pThis-&gt;rcvFrom.pfrominet = malloc(sizeof(struct sockaddr_storage)));
2165 	memcpy(pThis-&gt;rcvFrom.pfrominet, sa, sizeof(struct sockaddr_storage));
2166 finalize_it:
2167 	RETiRet;
2168 }
2169 void MsgSetRcvFrom(smsg_t *pThis, prop_t *new)
2170 {
2171 	prop.AddRef(new);
2172 	MsgSetRcvFromWithoutAddRef(pThis, new);
2173 }
2174 void MsgSetRcvFromStr(smsg_t * const pThis, const uchar *psz, const int len, prop_t **ppProp)
2175 {
2176 	assert(pThis != NULL);
2177 	assert(ppProp != NULL);
2178 	prop.CreateOrReuseStringProp(ppProp, psz, len);
2179 	MsgSetRcvFrom(pThis, *ppProp);
2180 }
2181 rsRetVal MsgSetRcvFromIP(smsg_t *pThis, prop_t *new)
2182 {
2183 	assert(pThis != NULL);
2184 	prop.AddRef(new);
2185 	MsgSetRcvFromIPWithoutAddRef(pThis, new);
2186 	return RS_RET_OK;
2187 }
2188 rsRetVal MsgSetRcvFromIPStr(smsg_t *const pThis, const uchar *psz, const int len, prop_t **ppProp)
2189 {
2190 	DEFiRet;
2191 	assert(pThis != NULL);
2192 	CHKiRet(prop.CreateOrReuseStringProp(ppProp, psz, len));
2193 	MsgSetRcvFromIP(pThis, *ppProp);
2194 finalize_it:
2195 	RETiRet;
2196 }
2197 void MsgSetHOSTNAME(smsg_t *pThis, const uchar* pszHOSTNAME, const int lenHOSTNAME)
2198 {
2199 	assert(pThis != NULL);
2200 	freeHOSTNAME(pThis);
2201 	pThis-&gt;iLenHOSTNAME = lenHOSTNAME;
2202 	if(pThis-&gt;iLenHOSTNAME &lt; CONF_HOSTNAME_BUFSIZE) {
2203 		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
2204 	} else if((pThis-&gt;pszHOSTNAME = (uchar*) malloc(pThis-&gt;iLenHOSTNAME + 1)) == NULL) {
2205 		pThis-&gt;pszHOSTNAME = pThis-&gt;szHOSTNAME;
2206 		pThis-&gt;iLenHOSTNAME = CONF_HOSTNAME_BUFSIZE - 1;
2207 	}
2208 	memcpy(pThis-&gt;pszHOSTNAME, pszHOSTNAME, pThis-&gt;iLenHOSTNAME);
2209 	pThis-&gt;pszHOSTNAME[pThis-&gt;iLenHOSTNAME] = '\0'; }
2210 void MsgSetMSGoffs(smsg_t * const pMsg, int offs)
2211 {
2212 	ISOBJ_TYPE_assert(pMsg, msg);
2213 	pMsg-&gt;offMSG = offs;
2214 	if(offs &gt; pMsg-&gt;iLenRawMsg) {
2215 		assert((int)offs - 1 == pMsg-&gt;iLenRawMsg);
2216 		pMsg-&gt;iLenMSG = 0;
2217 	} else {
2218 		pMsg-&gt;iLenMSG = pMsg-&gt;iLenRawMsg - offs;
2219 	}
2220 }
2221 rsRetVal MsgReplaceMSG(smsg_t *pThis, const uchar* pszMSG, int lenMSG)
2222 {
2223 	int lenNew;
2224 	uchar *bufNew;
2225 	DEFiRet;
2226 	ISOBJ_TYPE_assert(pThis, msg);
2227 	assert(pszMSG != NULL);
2228 	lenNew = pThis-&gt;iLenRawMsg + lenMSG - pThis-&gt;iLenMSG;
2229 	if(lenMSG &gt; pThis-&gt;iLenMSG &amp;&amp; lenNew &gt;= CONF_RAWMSG_BUFSIZE) {
2230 		CHKmalloc(bufNew = malloc(lenNew + 1));
2231 		memcpy(bufNew, pThis-&gt;pszRawMsg, pThis-&gt;offMSG);
2232 		if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
2233 			free(pThis-&gt;pszRawMsg);
2234 		pThis-&gt;pszRawMsg = bufNew;
2235 	}
2236 	if(lenMSG &gt; 0)
2237 		memcpy(pThis-&gt;pszRawMsg + pThis-&gt;offMSG, pszMSG, lenMSG);
2238 	pThis-&gt;pszRawMsg[lenNew] = '\0'; 	pThis-&gt;iLenRawMsg = lenNew;
2239 	pThis-&gt;iLenMSG = lenMSG;
2240 finalize_it:
2241 	RETiRet;
2242 }
2243 void ATTR_NONNULL()
2244 MsgTruncateToMaxSize(smsg_t *const pThis)
2245 {
2246 	ISOBJ_TYPE_assert(pThis, msg);
2247 	const int maxMsgSize = glblGetMaxLine(runConf);
2248 	assert(pThis-&gt;iLenRawMsg &gt; maxMsgSize);
2249 	const int deltaSize = pThis-&gt;iLenRawMsg - maxMsgSize;
2250 	pThis-&gt;pszRawMsg[maxMsgSize] = '\0';
2251 	pThis-&gt;iLenRawMsg = maxMsgSize;
2252 	if(pThis-&gt;iLenMSG &lt; deltaSize) {
2253 		pThis-&gt;iLenMSG = 0;
2254 	} else {
2255 		pThis-&gt;iLenMSG -= deltaSize;
2256 	}
2257 }
2258 void ATTR_NONNULL()
2259 MsgSetRawMsg(smsg_t *const pThis, const char*const pszRawMsg, const size_t lenMsg)
2260 {
2261 	ISOBJ_TYPE_assert(pThis, msg);
2262 	int deltaSize;
2263 	if(pThis-&gt;pszRawMsg != pThis-&gt;szRawMsg)
2264 		free(pThis-&gt;pszRawMsg);
2265 	deltaSize = (int) lenMsg - pThis-&gt;iLenRawMsg; 	pThis-&gt;iLenRawMsg = lenMsg;
2266 	if(pThis-&gt;iLenRawMsg &lt; CONF_RAWMSG_BUFSIZE) {
2267 		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
2268 	} else if((pThis-&gt;pszRawMsg = (uchar*) malloc(pThis-&gt;iLenRawMsg + 1)) == NULL) {
2269 		pThis-&gt;pszRawMsg = pThis-&gt;szRawMsg;
2270 		pThis-&gt;iLenRawMsg = CONF_RAWMSG_BUFSIZE - 1;
2271 	}
2272 	memcpy(pThis-&gt;pszRawMsg, pszRawMsg, pThis-&gt;iLenRawMsg);
2273 	pThis-&gt;pszRawMsg[pThis-&gt;iLenRawMsg] = '\0'; 	if(pThis-&gt;iLenRawMsg &gt; pThis-&gt;offMSG)
2274 		pThis-&gt;iLenMSG += deltaSize;
2275 	else
2276 		pThis-&gt;iLenMSG = 0;
2277 }
2278 void MsgSetRawMsgWOSize(smsg_t * const pMsg, char* pszRawMsg)
2279 {
2280 	MsgSetRawMsg(pMsg, pszRawMsg, strlen(pszRawMsg));
2281 }
2282 static uchar *
2283 textpri(const smsg_t *const __restrict__ pMsg)
2284 {
2285 	int lenfac = len_syslog_fac_names[pMsg-&gt;iFacility];
2286 	int lensev = len_syslog_severity_names[pMsg-&gt;iSeverity];
2287 	int totlen = lenfac + 1 + lensev + 1;
2288 	char *pRes = malloc(totlen);
2289 	if(pRes != NULL) {
2290 		memcpy(pRes, syslog_fac_names[pMsg-&gt;iFacility], lenfac);
2291 		pRes[lenfac] = '.';
2292 		memcpy(pRes+lenfac+1, syslog_severity_names[pMsg-&gt;iSeverity], lensev+1 	}
2293 	return (uchar*)pRes;
2294 }
2295 typedef enum ENOWType { NOW_NOW, NOW_YEAR, NOW_MONTH, NOW_DAY, NOW_HOUR,
2296 		NOW_HHOUR, NOW_QHOUR, NOW_MINUTE, NOW_WDAY } eNOWType;
2297 #define tmpBUFSIZE 16	static uchar *getNOW(eNOWType eNow, struct syslogTime *t, const int inUTC)
2298 {
2299 	uchar *pBuf;
2300 	struct syslogTime tt;
2301 	if((pBuf = (uchar*) malloc(tmpBUFSIZE)) == NULL) {
2302 		return NULL;
2303 	}
2304 	if(t == NULL) { 		datetime.getCurrTime(&amp;tt, NULL, inUTC);
2305 		t = &amp;tt;
2306 	}
2307 	if(t-&gt;year == 0 || t-&gt;inUTC != inUTC) { 		datetime.getCurrTime(t, NULL, inUTC);
2308 	}
2309 	switch(eNow) {
2310 	case NOW_NOW:
2311 		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
2312 		memcpy(pBuf+2, two_digits[t-&gt;year%100], 2);
2313 		pBuf[4] = '-';
2314 		memcpy(pBuf+5, two_digits[(int)t-&gt;month], 2);
2315 		pBuf[7] = '-';
2316 		memcpy(pBuf+8, two_digits[(int)t-&gt;day], 3);
2317 		break;
2318 	case NOW_YEAR:
2319 		memcpy(pBuf, two_digits[t-&gt;year/100], 2);
2320 		memcpy(pBuf+2, two_digits[t-&gt;year%100], 3);
2321 		break;
2322 	case NOW_MONTH:
2323 		memcpy(pBuf, two_digits[(int)t-&gt;month], 3);
2324 		break;
2325 	case NOW_DAY:
2326 		memcpy(pBuf, two_digits[(int)t-&gt;day], 3);
2327 		break;
2328 	case NOW_HOUR:
2329 		memcpy(pBuf, two_digits[(int)t-&gt;hour], 3);
2330 		break;
2331 	case NOW_HHOUR:
2332 		memcpy(pBuf, two_digits[t-&gt;minute/30], 3);
2333 		break;
2334 	case NOW_QHOUR:
2335 		memcpy(pBuf, two_digits[t-&gt;minute/15], 3);
2336 		break;
2337 	case NOW_MINUTE:
2338 		memcpy(pBuf, two_digits[(int)t-&gt;minute], 3);
2339 		break;
2340 	case NOW_WDAY:
2341 		memcpy(pBuf, one_digit[(int)t-&gt;wday], 2);
2342 		break;
2343 	}
2344 	return(pBuf);
2345 }
2346 #undef tmpBUFSIZE 
2347 static rsRetVal ATTR_NONNULL()
2348 getJSONRootAndMutex(smsg_t *const pMsg, const propid_t id,
2349 	struct json_object ***const jroot, pthread_mutex_t **const mut)
2350 {
2351 	DEFiRet;
2352 	assert(jroot != NULL); 	assert(mut != NULL);
2353 <a name="1"></a>	assert(*mut == NULL); 	assert(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR);
2354 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(id == PROP_CEE) {
2355 		*mut = &amp;pMsg-&gt;mut;
2356 		*jroot = &amp;pMsg-&gt;json;
2357 	} else if(id == PROP_LOCAL_VAR) {
2358 		*mut = &amp;pMsg-&gt;mut;
2359 		*jroot = &amp;pMsg-&gt;localvars;
2360 	} else if(id == PROP_GLOBAL_VAR) {</b></font>
2361 		*mut = &amp;glblVars_lock;
2362 		*jroot = &amp;global_var_root;
2363 	} else {
2364 		LogError(0, RS_RET_NON_JSON_PROP, "internal error:  "
2365 			"getJSONRootAndMutex; invalid property id %d", id);
2366 		iRet = RS_RET_NON_JSON_PROP;
2367 	}
2368 	RETiRet;
2369 }
2370 static rsRetVal ATTR_NONNULL()
2371 getJSONRootAndMutexByVarChar(smsg_t *const pMsg, const char c,
2372 	struct json_object ***const jroot, pthread_mutex_t **const mut)
2373 {
2374 	DEFiRet;
2375 	propid_t id;
2376 	assert(c == '!' || c == '.' || c == '/');
2377 	switch(c) {
2378 		case '!':
2379 			id = PROP_CEE;
2380 			break;
2381 		case '.':
2382 			id = PROP_LOCAL_VAR;
2383 			break;
2384 		case '/':
2385 			id = PROP_GLOBAL_VAR;
2386 			break;
2387 		default:
2388 			LogError(0, RS_RET_NON_JSON_PROP, "internal error:  "
2389 				"getJSONRootAndMutex; invalid indicator char %c(%2.2x)", c, c);
2390 			ABORT_FINALIZE(RS_RET_NON_JSON_PROP);
2391 			break;
2392 	}
2393 	iRet = getJSONRootAndMutex(pMsg, id, jroot, mut);
2394 finalize_it:
2395 	RETiRet;
2396 }
2397 rsRetVal
2398 getJSONPropVal(smsg_t * const pMsg, msgPropDescr_t *pProp, uchar **pRes, rs_size_t *buflen,
2399 	unsigned short *pbMustBeFreed)
2400 {
2401 	uchar *leaf;
2402 	struct json_object **jroot;
2403 	struct json_object *parent;
2404 	struct json_object *field;
2405 	pthread_mutex_t *mut = NULL;
2406 	DEFiRet;
2407 	*pRes = NULL;
2408 	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
2409 	pthread_mutex_lock(mut);
2410 	if(*jroot == NULL) FINALIZE;
2411 	if(!strcmp((char*)pProp-&gt;name, "!")) {
2412 		field = *jroot;
2413 	} else {
2414 		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
2415 		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
2416 		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
2417 			field = NULL;
2418 	}
2419 	if(field != NULL) {
2420 		*pRes = (uchar*) strdup(json_object_get_string(field));
2421 		*buflen = (int) ustrlen(*pRes);
2422 		*pbMustBeFreed = 1;
2423 	}
2424 finalize_it:
2425 	if(mut != NULL)
2426 		pthread_mutex_unlock(mut);
2427 	if(*pRes == NULL) {
2428 		*pRes = (unsigned char*)"";
2429 		*pbMustBeFreed = 0;
2430 	}
2431 	RETiRet;
2432 }
2433 rsRetVal
2434 msgGetJSONPropJSONorString(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson,
2435 	uchar **pcstr)
2436 {
2437 	struct json_object **jroot;
2438 	uchar *leaf;
2439 	struct json_object *parent;
2440 	pthread_mutex_t *mut = NULL;
2441 	DEFiRet;
2442 	*pjson = NULL, *pcstr = NULL;
2443 	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
2444 	pthread_mutex_lock(mut);
2445 	if(!strcmp((char*)pProp-&gt;name, "!")) {
2446 		*pjson = *jroot;
2447 		FINALIZE;
2448 	}
2449 	if(*jroot == NULL) {
2450 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
2451 	}
2452 	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
2453 	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
2454 	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
2455 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
2456 	}
2457 	if(*pjson == NULL) {
2458 		*pcstr = (uchar*) strdup("");
2459 	} else {
2460 		if(json_object_get_type(*pjson) == json_type_string) {
2461 			*pcstr = (uchar*) strdup(json_object_get_string(*pjson));
2462 			*pjson = NULL;
2463 		}
2464 	}
2465 finalize_it:
2466 	if(*pjson != NULL)
2467 		*pjson = jsonDeepCopy(*pjson);
2468 	if(mut != NULL)
2469 		pthread_mutex_unlock(mut);
2470 	RETiRet;
2471 }
2472 rsRetVal
2473 msgGetJSONPropJSON(smsg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson)
2474 {
2475 	struct json_object **jroot;
2476 	uchar *leaf;
2477 	struct json_object *parent;
2478 	pthread_mutex_t *mut = NULL;
2479 	DEFiRet;
2480 	*pjson = NULL;
2481 	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
2482 	pthread_mutex_lock(mut);
2483 	if(!strcmp((char*)pProp-&gt;name, "!")) {
2484 		*pjson = *jroot;
2485 		FINALIZE;
2486 	}
2487 	leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
2488 	CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
2489 	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
2490 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
2491 	}
2492 finalize_it:
2493 	if(*pjson != NULL)
2494 		*pjson = jsonDeepCopy(*pjson);
2495 	if(mut != NULL)
2496 		pthread_mutex_unlock(mut);
2497 	RETiRet;
2498 }
2499 static rsRetVal
2500 jsonAddVal(uchar *pSrc, unsigned buflen, es_str_t **dst, int escapeAll)
2501 {
2502 	unsigned char c;
2503 	es_size_t i;
2504 	char numbuf[4];
2505 	unsigned ni;
2506 	unsigned char nc;
2507 	int j;
2508 	DEFiRet;
2509 	for(i = 0 ; i &lt; buflen ; ++i) {
2510 		c = pSrc[i];
2511 		if(   (c &gt;= 0x23 &amp;&amp; c &lt;= 0x2e)
2512 		   || (c &gt;= 0x30 &amp;&amp; c &lt;= 0x5b)
2513 		   || c == 0x20 || c == 0x21) {
2514 			if(*dst != NULL)
2515 				es_addChar(dst, c);
2516 		} else {
2517 			if(*dst == NULL) {
2518 				if(i == 0) {
2519 					*dst = es_newStr(buflen+10);
2520 				} else {
2521 					*dst = es_newStrFromBuf((char*)pSrc, i);
2522 				}
2523 				if(*dst == NULL) {
2524 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
2525 				}
2526 			}
2527 			switch(c) {
2528 			case '\0':
2529 				es_addBuf(dst, "\\u0000", 6);
2530 				break;
2531 			case '\"':
2532 				es_addBuf(dst, "\\\"", 2);
2533 				break;
2534 			case '/':
2535 				es_addBuf(dst, "\\/", 2);
2536 				break;
2537 			case '\\':
2538 				if (escapeAll == RSFALSE) {
2539 					ni = i + 1;
2540 					if (ni &lt;= buflen) {
2541 						nc = pSrc[ni];
2542 						if (   nc == '"' || nc == '/' || nc == '\\' || nc == 'b' || nc == 'f'
2543 							|| nc == 'n' || nc == 'r' || nc == 't' || nc == 'u') {
2544 							es_addChar(dst, c);
2545 							es_addChar(dst, nc);
2546 							i = ni;
2547 							break;
2548 						}
2549 					}
2550 				}
2551 				es_addBuf(dst, "\\\\", 2);
2552 				break;
2553 			case '\010':
2554 				es_addBuf(dst, "\\b", 2);
2555 				break;
2556 			case '\014':
2557 				es_addBuf(dst, "\\f", 2);
2558 				break;
2559 			case '\n':
2560 				es_addBuf(dst, "\\n", 2);
2561 				break;
2562 			case '\r':
2563 				es_addBuf(dst, "\\r", 2);
2564 				break;
2565 			case '\t':
2566 				es_addBuf(dst, "\\t", 2);
2567 				break;
2568 			default:
2569 				for(j = 0 ; j &lt; 4 ; ++j) {
2570 					numbuf[3-j] = hexdigit[c % 16];
2571 					c = c / 16;
2572 				}
2573 				es_addBuf(dst, "\\u", 2);
2574 				es_addBuf(dst, numbuf, 4);
2575 				break;
2576 			}
2577 		}
2578 	}
2579 finalize_it:
2580 	RETiRet;
2581 }
2582 static rsRetVal
2583 jsonEncode(uchar **ppRes, unsigned short *pbMustBeFreed, int *pBufLen, int escapeAll)
2584 {
2585 	unsigned buflen;
2586 	uchar *pSrc;
2587 	es_str_t *dst = NULL;
2588 	DEFiRet;
2589 	pSrc = *ppRes;
2590 	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
2591 	CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
2592 	if(dst != NULL) {
2593 		if(*pbMustBeFreed)
2594 			free(*ppRes);
2595 		*ppRes = (uchar*)es_str2cstr(dst, NULL);
2596 		*pbMustBeFreed = 1;
2597 		*pBufLen = -1;
2598 		es_deleteStr(dst);
2599 	}
2600 finalize_it:
2601 	RETiRet;
2602 }
2603 static rsRetVal ATTR_NONNULL()
2604 jsonField(const struct templateEntry *const pTpe,
2605 	uchar **const ppRes,
2606 	unsigned short *const pbMustBeFreed,
2607 	int *const pBufLen,
2608 	int escapeAll)
2609 {
2610 	unsigned buflen;
2611 	uchar *pSrc;
2612 	es_str_t *dst = NULL;
2613 	int is_numeric = 1;
2614 	DEFiRet;
2615 	pSrc = *ppRes;
2616 	buflen = (*pBufLen == -1) ? (int) ustrlen(pSrc) : *pBufLen;
2617 dbgprintf("jsonEncode: datatype: %u, onEmpty: %u val %*s\n", (unsigned) pTpe-&gt;data.field.options.dataType,
2618 (unsigned) pTpe-&gt;data.field.options.onEmpty, buflen, pSrc);
2619 	if(buflen == 0) {
2620 		if(pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_SKIP) {
2621 			FINALIZE;
2622 		}
2623 		is_numeric = 0;
2624 	}
2625 	dst = es_newStr(buflen+pTpe-&gt;lenFieldName+15);
2626 	es_addChar(&amp;dst, '"');
2627 	es_addBuf(&amp;dst, (char*)pTpe-&gt;fieldName, pTpe-&gt;lenFieldName);
2628 	es_addBufConstcstr(&amp;dst, "\":");
2629 	if(buflen == 0 &amp;&amp; pTpe-&gt;data.field.options.onEmpty == TPE_DATAEMPTY_NULL) {
2630 		es_addBufConstcstr(&amp;dst, "null");
2631 	} else {
2632 		if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_AUTO) {
2633 			for(unsigned i = 0 ; i &lt; buflen ; ++i) {
2634 				if(pSrc[i] &lt; '0' || pSrc[i] &gt; '9') {
2635 					is_numeric = 0;
2636 					break;
2637 				}
2638 			}
2639 			if(!is_numeric) {
2640 				es_addChar(&amp;dst, '"');
2641 			}
2642 			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
2643 			if(!is_numeric) {
2644 				es_addChar(&amp;dst, '"');
2645 			}
2646 		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_STRING) {
2647 			es_addChar(&amp;dst, '"');
2648 			CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
2649 			es_addChar(&amp;dst, '"');
2650 		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_NUMBER) {
2651 			if(buflen == 0) {
2652 				es_addChar(&amp;dst, '0');
2653 			} else {
2654 				CHKiRet(jsonAddVal(pSrc, buflen, &amp;dst, escapeAll));
2655 			}
2656 		} else if(pTpe-&gt;data.field.options.dataType == TPE_DATATYPE_BOOL) {
2657 			if(buflen == 1 &amp;&amp; *pSrc == '0') {
2658 				es_addBufConstcstr(&amp;dst, "false");
2659 			} else {
2660 				es_addBufConstcstr(&amp;dst, "true");
2661 			}
2662 		}
2663 	}
2664 	if(*pbMustBeFreed)
2665 		free(*ppRes);
2666 	*pBufLen = es_strlen(dst);
2667 	*ppRes = (uchar*)es_str2cstr(dst, NULL);
2668 	*pbMustBeFreed = 1;
2669 	es_deleteStr(dst);
2670 finalize_it:
2671 	RETiRet;
2672 }
2673 #define RET_OUT_OF_MEMORY { *pbMustBeFreed = 0;\
2674 	*pPropLen = sizeof("**OUT OF MEMORY**") - 1; \
2675 	return(UCHAR_CONSTANT("**OUT OF MEMORY**"));}
2676 uchar *MsgGetProp(smsg_t *__restrict__ const pMsg, struct templateEntry *__restrict__ const pTpe,
2677 			msgPropDescr_t *pProp, rs_size_t *__restrict__ const pPropLen,
2678 			unsigned short *__restrict__ const pbMustBeFreed, struct syslogTime * const ttNow)
2679 {
2680 	uchar *pRes; 	rs_size_t bufLen = -1; 	uchar *pBufStart;
2681 	uchar *pBuf;
2682 	int iLen;
2683 	short iOffs;
2684 	enum tplFormatTypes datefmt;
2685 	int bDateInUTC;
2686 	assert(pMsg != NULL);
2687 	assert(pbMustBeFreed != NULL);
2688 #ifdef	FEATURE_REGEXP
2689 	size_t nmatch = 10;
2690 	regmatch_t pmatch[10];
2691 #endif
2692 	*pbMustBeFreed = 0;
2693 	switch(pProp-&gt;id) {
2694 		case PROP_MSG:
2695 			pRes = getMSG(pMsg);
2696 			bufLen = getMSGLen(pMsg);
2697 			break;
2698 		case PROP_TIMESTAMP:
2699 			if(pTpe != NULL) {
2700 				datefmt = pTpe-&gt;data.field.eDateFormat;
2701 				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
2702 			} else {
2703 				datefmt = tplFmtDefault;
2704 				bDateInUTC = 0;
2705 			}
2706 			if(bDateInUTC) {
2707 				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tTIMESTAMP, datefmt, pbMustBeFreed);
2708 			} else {
2709 				pRes = (uchar*)getTimeReported(pMsg, datefmt);
2710 			}
2711 			break;
2712 		case PROP_HOSTNAME:
2713 			pRes = (uchar*)getHOSTNAME(pMsg);
2714 			bufLen = getHOSTNAMELen(pMsg);
2715 			break;
2716 		case PROP_SYSLOGTAG:
2717 			getTAG(pMsg, &amp;pRes, &amp;bufLen, LOCK_MUTEX);
2718 			break;
2719 		case PROP_RAWMSG:
2720 			getRawMsg(pMsg, &amp;pRes, &amp;bufLen);
2721 			break;
2722 		case PROP_RAWMSG_AFTER_PRI:
2723 			getRawMsgAfterPRI(pMsg, &amp;pRes, &amp;bufLen);
2724 			break;
2725 		case PROP_INPUTNAME:
2726 			getInputName(pMsg, &amp;pRes, &amp;bufLen);
2727 			break;
2728 		case PROP_FROMHOST:
2729 			pRes = getRcvFrom(pMsg);
2730 			break;
2731 		case PROP_FROMHOST_IP:
2732 			pRes = getRcvFromIP(pMsg);
2733 			break;
2734 		case PROP_PRI:
2735 			pRes = (uchar*)getPRI(pMsg);
2736 			break;
2737 		case PROP_PRI_TEXT:
2738 			pRes = textpri(pMsg);
2739 			if(pRes == NULL)
2740 				RET_OUT_OF_MEMORY;
2741 			*pbMustBeFreed = 1;
2742 			break;
2743 		case PROP_IUT:
2744 			pRes = UCHAR_CONSTANT("1"); 			bufLen = 1;
2745 			break;
2746 		case PROP_SYSLOGFACILITY:
2747 			pRes = (uchar*)getFacility(pMsg);
2748 			break;
2749 		case PROP_SYSLOGFACILITY_TEXT:
2750 			pRes = (uchar*)getFacilityStr(pMsg);
2751 			break;
2752 		case PROP_SYSLOGSEVERITY:
2753 			pRes = (uchar*)getSeverity(pMsg);
2754 			break;
2755 		case PROP_SYSLOGSEVERITY_TEXT:
2756 			pRes = (uchar*)getSeverityStr(pMsg);
2757 			break;
2758 		case PROP_TIMEGENERATED:
2759 			if(pTpe != NULL) {
2760 				datefmt = pTpe-&gt;data.field.eDateFormat;
2761 				bDateInUTC = pTpe-&gt;data.field.options.bDateInUTC;
2762 			} else {
2763 				datefmt = tplFmtDefault;
2764 				bDateInUTC = 0;
2765 			}
2766 			if(bDateInUTC) {
2767 				pRes = (uchar*)getTimeUTC(&amp;pMsg-&gt;tRcvdAt, datefmt, pbMustBeFreed);
2768 			} else {
2769 				pRes = (uchar*)getTimeGenerated(pMsg, datefmt);
2770 			}
2771 			break;
2772 		case PROP_PROGRAMNAME:
2773 			pRes = getProgramName(pMsg, LOCK_MUTEX);
2774 			break;
2775 		case PROP_PROTOCOL_VERSION:
2776 			pRes = (uchar*)getProtocolVersionString(pMsg);
2777 			break;
2778 		case PROP_STRUCTURED_DATA:
2779 			MsgGetStructuredData(pMsg, &amp;pRes, &amp;bufLen);
2780 			break;
2781 		case PROP_APP_NAME:
2782 			pRes = (uchar*)getAPPNAME(pMsg, LOCK_MUTEX);
2783 			break;
2784 		case PROP_PROCID:
2785 			pRes = (uchar*)getPROCID(pMsg, LOCK_MUTEX);
2786 			break;
2787 		case PROP_MSGID:
2788 			pRes = (uchar*)getMSGID(pMsg);
2789 			break;
2790 		case PROP_JSONMESG:
2791 			pRes = (uchar*)msgGetJSONMESG(pMsg);
2792 			*pbMustBeFreed = 1;
2793 			break;
2794 #ifdef USE_LIBUUID
2795 		case PROP_UUID:
2796 			getUUID(pMsg, &amp;pRes, &amp;bufLen);
2797 			break;
2798 #endif
2799 		case PROP_PARSESUCCESS:
2800 			pRes = (uchar*)getParseSuccess(pMsg);
2801 			break;
2802 		case PROP_SYS_NOW:
2803 			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2804 				RET_OUT_OF_MEMORY;
2805 			} else {
2806 				*pbMustBeFreed = 1;
2807 				bufLen = 10;
2808 			}
2809 			break;
2810 		case PROP_SYS_YEAR:
2811 			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2812 				RET_OUT_OF_MEMORY;
2813 			} else {
2814 				*pbMustBeFreed = 1;
2815 				bufLen = 4;
2816 			}
2817 			break;
2818 		case PROP_SYS_MONTH:
2819 			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2820 				RET_OUT_OF_MEMORY;
2821 			} else {
2822 				*pbMustBeFreed = 1;
2823 				bufLen = 2;
2824 			}
2825 			break;
2826 		case PROP_SYS_DAY:
2827 			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2828 				RET_OUT_OF_MEMORY;
2829 			} else {
2830 				*pbMustBeFreed = 1;
2831 				bufLen = 2;
2832 			}
2833 			break;
2834 		case PROP_SYS_HOUR:
2835 			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2836 				RET_OUT_OF_MEMORY;
2837 			} else {
2838 				*pbMustBeFreed = 1;
2839 				bufLen = 2;
2840 			}
2841 			break;
2842 		case PROP_SYS_HHOUR:
2843 			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2844 				RET_OUT_OF_MEMORY;
2845 			} else {
2846 				*pbMustBeFreed = 1;
2847 				bufLen = 2;
2848 			}
2849 			break;
2850 		case PROP_SYS_QHOUR:
2851 			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2852 				RET_OUT_OF_MEMORY;
2853 			} else {
2854 				*pbMustBeFreed = 1;
2855 				bufLen = 2;
2856 			}
2857 			break;
2858 		case PROP_SYS_MINUTE:
2859 			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2860 				RET_OUT_OF_MEMORY;
2861 			} else {
2862 				*pbMustBeFreed = 1;
2863 				bufLen = 2;
2864 			}
2865 			break;
2866 		case PROP_SYS_NOW_UTC:
2867 			if((pRes = getNOW(NOW_NOW, ttNow, TIME_IN_UTC)) == NULL) {
2868 				RET_OUT_OF_MEMORY;
2869 			} else {
2870 				*pbMustBeFreed = 1;
2871 				bufLen = 10;
2872 			}
2873 			break;
2874 		case PROP_SYS_YEAR_UTC:
2875 			if((pRes = getNOW(NOW_YEAR, ttNow, TIME_IN_UTC)) == NULL) {
2876 				RET_OUT_OF_MEMORY;
2877 			} else {
2878 				*pbMustBeFreed = 1;
2879 				bufLen = 4;
2880 			}
2881 			break;
2882 		case PROP_SYS_MONTH_UTC:
2883 			if((pRes = getNOW(NOW_MONTH, ttNow, TIME_IN_UTC)) == NULL) {
2884 				RET_OUT_OF_MEMORY;
2885 			} else {
2886 				*pbMustBeFreed = 1;
2887 				bufLen = 2;
2888 			}
2889 			break;
2890 		case PROP_SYS_DAY_UTC:
2891 			if((pRes = getNOW(NOW_DAY, ttNow, TIME_IN_UTC)) == NULL) {
2892 				RET_OUT_OF_MEMORY;
2893 			} else {
2894 				*pbMustBeFreed = 1;
2895 				bufLen = 2;
2896 			}
2897 			break;
2898 		case PROP_SYS_HOUR_UTC:
2899 			if((pRes = getNOW(NOW_HOUR, ttNow, TIME_IN_UTC)) == NULL) {
2900 				RET_OUT_OF_MEMORY;
2901 			} else {
2902 				*pbMustBeFreed = 1;
2903 				bufLen = 2;
2904 			}
2905 			break;
2906 		case PROP_SYS_HHOUR_UTC:
2907 			if((pRes = getNOW(NOW_HHOUR, ttNow, TIME_IN_UTC)) == NULL) {
2908 				RET_OUT_OF_MEMORY;
2909 			} else {
2910 				*pbMustBeFreed = 1;
2911 				bufLen = 2;
2912 			}
2913 			break;
2914 		case PROP_SYS_QHOUR_UTC:
2915 			if((pRes = getNOW(NOW_QHOUR, ttNow, TIME_IN_UTC)) == NULL) {
2916 				RET_OUT_OF_MEMORY;
2917 			} else {
2918 				*pbMustBeFreed = 1;
2919 				bufLen = 2;
2920 			}
2921 			break;
2922 		case PROP_SYS_MINUTE_UTC:
2923 			if((pRes = getNOW(NOW_MINUTE, ttNow, TIME_IN_UTC)) == NULL) {
2924 				RET_OUT_OF_MEMORY;
2925 			} else {
2926 				*pbMustBeFreed = 1;
2927 				bufLen = 2;
2928 			}
2929 			break;
2930 		case PROP_SYS_WDAY:
2931 			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_LOCALTIME)) == NULL) {
2932 				RET_OUT_OF_MEMORY;
2933 			} else {
2934 				*pbMustBeFreed = 1;
2935 				bufLen = 1;
2936 			}
2937 			break;
2938 		case PROP_SYS_WDAY_UTC:
2939 			if((pRes = getNOW(NOW_WDAY, ttNow, TIME_IN_UTC)) == NULL) {
2940 				RET_OUT_OF_MEMORY;
2941 			} else {
2942 				*pbMustBeFreed = 1;
2943 				bufLen = 1;
2944 			}
2945 			break;
2946 		case PROP_SYS_NOW_UXTIMESTAMP:
2947 			if((pRes = malloc(16)) == NULL) {
2948 				RET_OUT_OF_MEMORY;
2949 			} else {
2950 				snprintf((char*) pRes, 16-1, "%lld", (long long) getTime(NULL));
2951 				pRes[16-1] = '\0';
2952 				*pbMustBeFreed = 1;
2953 				bufLen = -1;
2954 			}
2955 			break;
2956 		case PROP_SYS_MYHOSTNAME:
2957 			pRes = glbl.GetLocalHostName();
2958 			break;
2959 		case PROP_CEE_ALL_JSON:
2960 		case PROP_CEE_ALL_JSON_PLAIN:
2961 			if(pMsg-&gt;json == NULL) {
2962 				pRes = (uchar*) "{}";
2963 				bufLen = 2;
2964 				*pbMustBeFreed = 0;
2965 			} else {
2966 				const char *jstr;
2967 				MsgLock(pMsg);
2968 				int jflag = 0;
2969 				if(pProp-&gt;id == PROP_CEE_ALL_JSON) {
2970 					jflag = JSON_C_TO_STRING_SPACED;
2971 				} else if(pProp-&gt;id == PROP_CEE_ALL_JSON_PLAIN) {
2972 					jflag = JSON_C_TO_STRING_PLAIN;
2973 				}
2974 				jstr = json_object_to_json_string_ext(pMsg-&gt;json, jflag);
2975 				MsgUnlock(pMsg);
2976 				if(jstr == NULL) {
2977 					RET_OUT_OF_MEMORY;
2978 				}
2979 				pRes = (uchar*)strdup(jstr);
2980 				if(pRes == NULL) {
2981 					RET_OUT_OF_MEMORY;
2982 				}
2983 				*pbMustBeFreed = 1;
2984 			}
2985 			break;
2986 		case PROP_CEE:
2987 		case PROP_LOCAL_VAR:
2988 		case PROP_GLOBAL_VAR:
2989 			getJSONPropVal(pMsg, pProp, &amp;pRes, &amp;bufLen, pbMustBeFreed);
2990 			break;
2991 		case PROP_SYS_BOM:
2992 			pRes = (uchar*) "\xEF\xBB\xBF";
2993 			*pbMustBeFreed = 0;
2994 			break;
2995 		case PROP_SYS_UPTIME:
2996 #			ifndef HAVE_SYSINFO_UPTIME
2997 			pRes = (uchar*) "UPTIME NOT available on this system";
2998 			*pbMustBeFreed = 0;
2999 #			elif defined(__FreeBSD__)
3000 			{
3001 			struct timespec tp;
3002 			if((pRes = (uchar*) malloc(32)) == NULL) {
3003 				RET_OUT_OF_MEMORY;
3004 			}
3005 			if(clock_gettime(CLOCK_UPTIME, &amp;tp) == -1) {
3006 				free(pRes);
3007 				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
3008 				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
3009 			}
3010 			*pbMustBeFreed = 1;
3011 			snprintf((char*) pRes, 32, "%ld", tp.tv_sec);
3012 			}
3013 #			else
3014 			{
3015 			struct sysinfo s_info;
3016 			if((pRes = (uchar*) malloc(32)) == NULL) {
3017 				RET_OUT_OF_MEMORY;
3018 			}
3019 			if(sysinfo(&amp;s_info) &lt; 0) {
3020 				free(pRes);
3021 				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
3022 				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
3023 			}
3024 			*pbMustBeFreed = 1;
3025 			snprintf((char*) pRes, 32, "%ld", s_info.uptime);
3026 			}
3027 #			endif
3028 		break;
3029 		default:
3030 			dbgprintf("invalid property id: '%d'\n", pProp-&gt;id);
3031 			*pbMustBeFreed = 0;
3032 			*pPropLen = sizeof("**INVALID PROPERTY NAME**") - 1;
3033 			return UCHAR_CONSTANT("**INVALID PROPERTY NAME**");
3034 	}
3035 	if(pTpe == NULL || !pTpe-&gt;bComplexProcessing) {
3036 		*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;
3037 		return pRes;
3038 	}
3039 	if(pTpe-&gt;data.field.has_fields == 1) {
3040 		size_t iCurrFld;
3041 		uchar *pFld;
3042 		uchar *pFldEnd;
3043 		iCurrFld = 1;
3044 		pFld = pRes;
3045 		while(*pFld &amp;&amp; iCurrFld &lt; pTpe-&gt;data.field.iFieldNr) {
3046 			while(*pFld &amp;&amp; (uchar) *pFld != pTpe-&gt;data.field.field_delim)
3047 				++pFld; 			if(*pFld == pTpe-&gt;data.field.field_delim) {
3048 				++pFld; #ifdef STRICT_GPLV3
3049 				if (pTpe-&gt;data.field.field_expand != 0) {
3050 					while (*pFld == pTpe-&gt;data.field.field_delim) {
3051 						++pFld;
3052 					}
3053 				}
3054 #endif
3055 				++iCurrFld;
3056 			}
3057 		}
3058 		dbgprintf("field requested %d, field found %d\n", pTpe-&gt;data.field.iFieldNr, (int) iCurrFld);
3059 		if(iCurrFld == pTpe-&gt;data.field.iFieldNr) {
3060 			pFldEnd = pFld;
3061 			while(*pFldEnd &amp;&amp; *pFldEnd != pTpe-&gt;data.field.field_delim)
3062 				++pFldEnd;
3063 			iLen = pFldEnd - pFld + 1; 			pBufStart = pBuf = malloc(iLen + 1);
3064 			if(pBuf == NULL) {
3065 				if(*pbMustBeFreed == 1)
3066 					free(pRes);
3067 				RET_OUT_OF_MEMORY;
3068 			}
3069 			memcpy(pBuf, pFld, iLen);
3070 			bufLen = iLen;
3071 			pBuf[iLen] = '\0'; 			if(*pbMustBeFreed == 1)
3072 				free(pRes);
3073 			pRes = pBufStart;
3074 			*pbMustBeFreed = 1;
3075 		} else {
3076 			if(*pbMustBeFreed == 1)
3077 				free(pRes);
3078 			*pbMustBeFreed = 0;
3079 			*pPropLen = sizeof("**FIELD NOT FOUND**") - 1;
3080 			return UCHAR_CONSTANT("**FIELD NOT FOUND**");
3081 		}
3082 #ifdef FEATURE_REGEXP
3083 	} else {
3084 		if (pTpe-&gt;data.field.has_regex != 0) {
3085 			if (pTpe-&gt;data.field.has_regex == 2) {
3086 				if (*pbMustBeFreed == 1) {
3087 					free(pRes);
3088 					*pbMustBeFreed = 0;
3089 				}
3090 				*pPropLen = sizeof("**NO MATCH** **BAD REGULAR EXPRESSION**") - 1;
3091 				return UCHAR_CONSTANT("**NO MATCH** **BAD REGULAR EXPRESSION**");
3092 			}
3093 			dbgprintf("string to match for regex is: %s\n", pRes);
3094 			if(objUse(regexp, LM_REGEXP_FILENAME) == RS_RET_OK) {
3095 				short iTry = 0;
3096 				uchar bFound = 0;
3097 				iOffs = 0;
3098 				while(!bFound) {
3099 					int iREstat;
3100 					iREstat = regexp.regexec(&amp;pTpe-&gt;data.field.re, (char*)(pRes + iOffs),
3101 								nmatch, pmatch, 0);
3102 					dbgprintf("regexec return is %d\n", iREstat);
3103 					if(iREstat == 0) {
3104 						if(pmatch[0].rm_so == -1) {
3105 							dbgprintf("oops ... start offset of successful "
3106 								"regexec is -1\n");
3107 							break;
3108 						}
3109 						if(iTry == pTpe-&gt;data.field.iMatchToUse) {
3110 							bFound = 1;
3111 						} else {
3112 							dbgprintf("regex found at offset %d, new offset %d, "
3113 								"tries %d\n", iOffs,
3114 								(int) (iOffs + pmatch[0].rm_eo), iTry);
3115 							iOffs += pmatch[0].rm_eo;
3116 							++iTry;
3117 						}
3118 					} else {
3119 						break;
3120 					}
3121 				}
3122 				dbgprintf("regex: end search, found %d\n", bFound);
3123 				if(!bFound) {
3124 					if(pTpe-&gt;data.field.nomatchAction != TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
3125 						if (*pbMustBeFreed == 1) {
3126 							free(pRes);
3127 							*pbMustBeFreed = 0;
3128 						}
3129 						if(pTpe-&gt;data.field.nomatchAction == TPL_REGEX_NOMATCH_USE_DFLTSTR) {
3130 							bufLen = sizeof("**NO MATCH**") - 1;
3131 							pRes = UCHAR_CONSTANT("**NO MATCH**");
3132 						} else if(pTpe-&gt;data.field.nomatchAction ==
3133 						TPL_REGEX_NOMATCH_USE_ZERO) {
3134 							bufLen = 1;
3135 							pRes = UCHAR_CONSTANT("0");
3136 						} else {
3137 							bufLen = 0;
3138 							pRes = UCHAR_CONSTANT("");
3139 						}
3140 					}
3141 				} else {
3142 					if(pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so == -1) {
3143 						if(pTpe-&gt;data.field.nomatchAction !=
3144 						TPL_REGEX_NOMATCH_USE_WHOLE_FIELD) {
3145 							if (*pbMustBeFreed == 1) {
3146 								free(pRes);
3147 								*pbMustBeFreed = 0;
3148 							}
3149 							if(pTpe-&gt;data.field.nomatchAction ==
3150 							TPL_REGEX_NOMATCH_USE_DFLTSTR) {
3151 								bufLen = sizeof("**NO MATCH**") - 1;
3152 								pRes = UCHAR_CONSTANT("**NO MATCH**");
3153 							} else if(pTpe-&gt;data.field.nomatchAction ==
3154 								TPL_REGEX_NOMATCH_USE_ZERO) {
3155 								bufLen = 1;
3156 								pRes = UCHAR_CONSTANT("0");
3157 							} else {
3158 								bufLen = 0;
3159 								pRes = UCHAR_CONSTANT("");
3160 							}
3161 						}
3162 					}
3163 					int iLenBuf;
3164 					uchar *pB;
3165 					iLenBuf = pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_eo
3166 						  - pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so;
3167 					pB = malloc(iLenBuf + 1);
3168 					if (pB == NULL) {
3169 						if (*pbMustBeFreed == 1)
3170 							free(pRes);
3171 						RET_OUT_OF_MEMORY;
3172 					}
3173 					memcpy(pB, pRes + iOffs +  pmatch[pTpe-&gt;data.field.iSubMatchToUse].rm_so,
3174 						iLenBuf);
3175 					bufLen = iLenBuf;
3176 					pB[iLenBuf] = '\0';
3177 					if (*pbMustBeFreed == 1)
3178 						free(pRes);
3179 					pRes = pB;
3180 					*pbMustBeFreed = 1;
3181 				}
3182 			} else {
3183 				dbgprintf("could not get regexp object pointer, so regexp can not be evaluated\n");
3184 				if (*pbMustBeFreed == 1) {
3185 					free(pRes);
3186 					*pbMustBeFreed = 0;
3187 				}
3188 				*pPropLen = sizeof("***REGEXP NOT AVAILABLE***") - 1;
3189 				return UCHAR_CONSTANT("***REGEXP NOT AVAILABLE***");
3190 			}
3191 		}
3192 #endif 	}
3193 	if(pTpe-&gt;data.field.iFromPos != 0 || pTpe-&gt;data.field.iToPos != 0) {
3194 		int iFrom, iTo;
3195 		uchar *pSb;
3196 		iFrom = pTpe-&gt;data.field.iFromPos;
3197 		iTo = pTpe-&gt;data.field.iToPos;
3198 		if(bufLen == -1)
3199 			bufLen = ustrlen(pRes);
3200 		if(pTpe-&gt;data.field.options.bFromPosEndRelative) {
3201 			iFrom = (bufLen &lt; iFrom) ? 0 : bufLen - iFrom;
3202 			iTo = (bufLen &lt; iTo)? 0 : bufLen - iTo;
3203 		} else {
3204 			if(iFrom &gt; 0)
3205 				--iFrom;
3206 			if(iTo &gt; 0)
3207 				--iTo;
3208 		}
3209 		if(iFrom &gt;= bufLen) {
3210 			DBGPRINTF("msgGetProp: iFrom %d &gt;= buflen %d, returning empty string\n",
3211 				iFrom, bufLen);
3212 			if(*pbMustBeFreed == 1)
3213 				free(pRes);
3214 			pRes = (uchar*) "";
3215 			*pbMustBeFreed = 0;
3216 			bufLen = 0;
3217 		} else if(iFrom == 0 &amp;&amp; iTo &gt;= bufLen &amp;&amp; pTpe-&gt;data.field.options.bFixedWidth == 0) {
3218 		} else {
3219 			if(iTo &gt;= bufLen)  				if (pTpe-&gt;data.field.options.bFixedWidth == 0)
3220 					iTo = bufLen - 1;
3221 			iLen = iTo - iFrom + 1; 			pBufStart = pBuf = malloc(iLen + 1);
3222 			if(pBuf == NULL) {
3223 				if(*pbMustBeFreed == 1)
3224 					free(pRes);
3225 				RET_OUT_OF_MEMORY;
3226 			}
3227 			pSb = pRes;
3228 			if(iFrom) {
3229 				while(*pSb &amp;&amp; iFrom) {
3230 					--iFrom;
3231 					++pSb;
3232 				}
3233 			}
3234 			bufLen = iLen;
3235 			while(iLen) {
3236 				if (*pSb) {
3237 					*pBuf++ = *pSb;
3238 					++pSb;
3239 				} else {
3240 					*pBuf++ = ' ';
3241 				}
3242 				--iLen;
3243 			}
3244 			*pBuf = '\0';
3245 			bufLen -= iLen; 			if(*pbMustBeFreed == 1)
3246 				free(pRes);
3247 			pRes = pBufStart;
3248 			*pbMustBeFreed = 1;
3249 		}
3250 	}
3251 	if(*pRes &amp;&amp; pTpe-&gt;data.field.options.bSPIffNo1stSP) {
3252 		uchar cFirst = *pRes; 		if(*pbMustBeFreed == 1)
3253 			free(pRes);
3254 		pRes = (cFirst == ' ') ? UCHAR_CONSTANT("") : UCHAR_CONSTANT(" ");
3255 		bufLen = (cFirst == ' ') ? 0 : 1;
3256 		*pbMustBeFreed = 0;
3257 	}
3258 	if(*pRes) {
3259 		if(pTpe-&gt;data.field.eCaseConv != tplCaseConvNo) {
3260 			if(bufLen == -1)
3261 				bufLen = ustrlen(pRes);
3262 			uchar *pBStart;
3263 			uchar *pB;
3264 			uchar *pSrc;
3265 			pBStart = pB = malloc(bufLen + 1);
3266 			if(pB == NULL) {
3267 				if(*pbMustBeFreed == 1)
3268 					free(pRes);
3269 				RET_OUT_OF_MEMORY;
3270 			}
3271 			pSrc = pRes;
3272 			while(*pSrc) {
3273 				*pB++ = (pTpe-&gt;data.field.eCaseConv == tplCaseConvUpper) ?
3274 					(uchar)toupper((int)*pSrc) : (uchar)tolower((int)*pSrc);
3275 				++pSrc;
3276 			}
3277 			*pB = '\0';
3278 			if(*pbMustBeFreed == 1)
3279 				free(pRes);
3280 			pRes = pBStart;
3281 			*pbMustBeFreed = 1;
3282 		}
3283 		if(pTpe-&gt;data.field.options.bDropCC) {
3284 			int iLenBuf = 0;
3285 			uchar *pSrc = pRes;
3286 			uchar *pDstStart;
3287 			uchar *pDst;
3288 			uchar bDropped = 0;
3289 			while(*pSrc) {
3290 				if(!iscntrl((int) *pSrc++))
3291 					iLenBuf++;
3292 				else
3293 					bDropped = 1;
3294 			}
3295 			if(bDropped) {
3296 				pDst = pDstStart = malloc(iLenBuf + 1);
3297 				if(pDst == NULL) {
3298 					if(*pbMustBeFreed == 1)
3299 						free(pRes);
3300 					RET_OUT_OF_MEMORY;
3301 				}
3302 				for(pSrc = pRes; *pSrc; pSrc++) {
3303 					if(!iscntrl((int) *pSrc))
3304 						*pDst++ = *pSrc;
3305 				}
3306 				*pDst = '\0';
3307 				if(*pbMustBeFreed == 1)
3308 					free(pRes);
3309 				pRes = pDstStart;
3310 				bufLen = iLenBuf;
3311 				*pbMustBeFreed = 1;
3312 			}
3313 		} else if(pTpe-&gt;data.field.options.bSpaceCC) {
3314 			uchar *pSrc;
3315 			uchar *pDstStart;
3316 			uchar *pDst;
3317 			if(*pbMustBeFreed == 1) {
3318 				for(pDst = pRes; *pDst; pDst++) {
3319 					if(iscntrl((int) *pDst))
3320 						*pDst = ' ';
3321 				}
3322 			} else {
3323 				if(bufLen == -1)
3324 					bufLen = ustrlen(pRes);
3325 				pDst = pDstStart = malloc(bufLen + 1);
3326 				if(pDst == NULL) {
3327 					if(*pbMustBeFreed == 1)
3328 						free(pRes);
3329 					RET_OUT_OF_MEMORY;
3330 				}
3331 				for(pSrc = pRes; *pSrc; pSrc++) {
3332 					if(iscntrl((int) *pSrc))
3333 						*pDst++ = ' ';
3334 					else
3335 						*pDst++ = *pSrc;
3336 				}
3337 				*pDst = '\0';
3338 				pRes = pDstStart;
3339 				*pbMustBeFreed = 1;
3340 			}
3341 		} else if(pTpe-&gt;data.field.options.bEscapeCC) {
3342 			int iNumCC = 0;
3343 			int iLenBuf = 0;
3344 			uchar *pSrc;
3345 			uchar *pB;
3346 			for(pB = pRes ; *pB ; ++pB) {
3347 				++iLenBuf;
3348 				if(iscntrl((int) *pB))
3349 					++iNumCC;
3350 			}
3351 			if(iNumCC &gt; 0) { 				uchar *pBStart;
3352 				uchar szCCEsc[8]; 				int i;
3353 				iLenBuf += iNumCC * 4;
3354 				pBStart = pB = malloc(iLenBuf + 1);
3355 				if(pB == NULL) {
3356 					if(*pbMustBeFreed == 1)
3357 						free(pRes);
3358 					RET_OUT_OF_MEMORY;
3359 				}
3360 				for(pSrc = pRes; *pSrc; pSrc++) {
3361 					if(iscntrl((int) *pSrc)) {
3362 						snprintf((char*)szCCEsc, sizeof(szCCEsc), "#%3.3d", *pSrc);
3363 						for(i = 0 ; i &lt; 4 ; ++i)
3364 							*pB++ = szCCEsc[i];
3365 					} else {
3366 						*pB++ = *pSrc;
3367 					}
3368 				}
3369 				*pB = '\0';
3370 				if(*pbMustBeFreed == 1)
3371 					free(pRes);
3372 				pRes = pBStart;
3373 				bufLen = -1;
3374 				*pbMustBeFreed = 1;
3375 			}
3376 		}
3377 	}
3378 	if(pTpe-&gt;data.field.options.bSecPathDrop || pTpe-&gt;data.field.options.bSecPathReplace) {
3379 		if(pTpe-&gt;data.field.options.bSecPathDrop) {
3380 			int iLenBuf = 0;
3381 			uchar *pSrc = pRes;
3382 			uchar *pDstStart;
3383 			uchar *pDst;
3384 			uchar bDropped = 0;
3385 			while(*pSrc) {
3386 				if(*pSrc++ != '/')
3387 					iLenBuf++;
3388 				else
3389 					bDropped = 1;
3390 			}
3391 			if(bDropped) {
3392 				pDst = pDstStart = malloc(iLenBuf + 1);
3393 				if(pDst == NULL) {
3394 					if(*pbMustBeFreed == 1)
3395 						free(pRes);
3396 					RET_OUT_OF_MEMORY;
3397 				}
3398 				for(pSrc = pRes; *pSrc; pSrc++) {
3399 					if(*pSrc != '/')
3400 						*pDst++ = *pSrc;
3401 				}
3402 				*pDst = '\0';
3403 				if(*pbMustBeFreed == 1)
3404 					free(pRes);
3405 				pRes = pDstStart;
3406 				bufLen = -1; 				*pbMustBeFreed = 1;
3407 			}
3408 		} else {
3409 			uchar *pSrc;
3410 			uchar *pDstStart;
3411 			uchar *pDst;
3412 			if(*pbMustBeFreed == 1) {
3413 				for(pDst = pRes; *pDst; pDst++) {
3414 					if(*pDst == '/')
3415 						*pDst++ = '_';
3416 				}
3417 			} else {
3418 				if(bufLen == -1)
3419 					bufLen = ustrlen(pRes);
3420 				pDst = pDstStart = malloc(bufLen + 1);
3421 				if(pDst == NULL) {
3422 					if(*pbMustBeFreed == 1)
3423 						free(pRes);
3424 					RET_OUT_OF_MEMORY;
3425 				}
3426 				for(pSrc = pRes; *pSrc; pSrc++) {
3427 					if(*pSrc == '/')
3428 						*pDst++ = '_';
3429 					else
3430 						*pDst++ = *pSrc;
3431 				}
3432 				*pDst = '\0';
3433 				pRes = pDstStart;
3434 				*pbMustBeFreed = 1;
3435 			}
3436 		}
3437 		if(*pRes == '\0') {
3438 			if(*pbMustBeFreed == 1)
3439 				free(pRes);
3440 			pRes = UCHAR_CONSTANT("_");
3441 			bufLen = 1;
3442 			*pbMustBeFreed = 0;
3443 		} else if((*pRes == '.') &amp;&amp; (*(pRes + 1) == '\0' || (*(pRes + 1) == '.' &amp;&amp; *(pRes + 2) == '\0'))) {
3444 			uchar *pTmp = pRes;
3445 			if(*(pRes + 1) == '\0')
3446 				pRes = UCHAR_CONSTANT("_");
3447 			else
3448 				pRes = UCHAR_CONSTANT("_.");;
3449 			if(*pbMustBeFreed == 1)
3450 				free(pTmp);
3451 			*pbMustBeFreed = 0;
3452 		}
3453 	}
3454 	if(pTpe-&gt;data.field.options.bDropLastLF &amp;&amp; !pTpe-&gt;data.field.options.bEscapeCC) {
3455 		int iLn;
3456 		uchar *pB;
3457 		if(bufLen == -1)
3458 			bufLen = ustrlen(pRes);
3459 		iLn = bufLen;
3460 		if(iLn &gt; 0 &amp;&amp; *(pRes + iLn - 1) == '\n') {
3461 			if(*pbMustBeFreed == 0) {
3462 				pB = malloc(iLn + 1);
3463 				if(pB == NULL) {
3464 					RET_OUT_OF_MEMORY;
3465 				}
3466 				memcpy(pB, pRes, iLn - 1);
3467 				pRes = pB;
3468 				*pbMustBeFreed = 1;
3469 			}
3470 			*(pRes + iLn - 1) = '\0'; 			--bufLen;
3471 		}
3472 	}
3473 	if(pTpe-&gt;data.field.options.bCompressSP) {
3474 		int needCompress = 0;
3475 		int hadSP = 0;
3476 		uchar *pB;
3477 		if(*pbMustBeFreed == 0) {
3478 			for(pB = pRes ; *pB &amp;&amp; needCompress == 0 ; ++pB) {
3479 				if(*pB == ' ') {
3480 					if(hadSP) {
3481 						uchar *const tmp = ustrdup(pRes);
3482 						if(tmp == NULL)
3483 							break;
3484 						*pbMustBeFreed = 1;
3485 						pRes = tmp;
3486 						needCompress = 1;
3487 					} else {
3488 						hadSP = 1;
3489 					}
3490 				}
3491 			}
3492 		} else {
3493 			needCompress = 1;
3494 		}
3495 		if(needCompress) {
3496 			hadSP = 0;
3497 			uchar *pDst = pRes;
3498 			int needCopy = 0;
3499 			for(pB = pRes ; *pB ; ++pB) {
3500 				if(*pB == ' ') {
3501 					if(hadSP) {
3502 						needCopy = 1;
3503 					}  else {
3504 						hadSP = 1;
3505 						if(needCopy)
3506 							*pDst = *pB;
3507 						++pDst;
3508 					}
3509 				} else {
3510 					hadSP = 0;
3511 					if(needCopy)
3512 						*pDst = *pB;
3513 					++pDst;
3514 				}
3515 			}
3516 			*pDst = '\0';
3517 			bufLen = pDst - pRes;
3518 		}
3519 	}
3520 	if(pTpe-&gt;data.field.options.bCSV) {
3521 		int iBufLen;
3522 		uchar *pBStart;
3523 		uchar *pDst;
3524 		uchar *pSrc;
3525 		if(bufLen == -1)
3526 			bufLen = ustrlen(pRes);
3527 		iBufLen = bufLen;
3528 		pBStart = pDst = malloc(2 * iBufLen + 3);
3529 		if(pDst == NULL) {
3530 			if(*pbMustBeFreed == 1)
3531 				free(pRes);
3532 			RET_OUT_OF_MEMORY;
3533 		}
3534 		pSrc = pRes;
3535 		*pDst++ = '"'; 		while(*pSrc) {
3536 			if(*pSrc == '"')
3537 				*pDst++ = '"'; 			*pDst++ = *pSrc++;
3538 		}
3539 		*pDst++ = '"';			*pDst = '\0';
3540 		if(*pbMustBeFreed == 1)
3541 			free(pRes);
3542 		pRes = pBStart;
3543 		bufLen = -1;
3544 		*pbMustBeFreed = 1;
3545 	} else if(pTpe-&gt;data.field.options.bJSON) {
3546 		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
3547 	} else if(pTpe-&gt;data.field.options.bJSONf) {
3548 		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSTRUE);
3549 	} else if(pTpe-&gt;data.field.options.bJSONr) {
3550 		jsonEncode(&amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
3551 	} else if(pTpe-&gt;data.field.options.bJSONfr) {
3552 		jsonField(pTpe, &amp;pRes, pbMustBeFreed, &amp;bufLen, RSFALSE);
3553 	}
3554 	*pPropLen = (bufLen == -1) ? (int) ustrlen(pRes) : bufLen;
3555 	return(pRes);
3556 }
3557 static rsRetVal
3558 msgSetPropViaJSON(smsg_t *__restrict__ const pMsg, const char *name, struct json_object *json, int sharedReference)
3559 {
3560 	const char *psz;
3561 	int val;
3562 	prop_t *propFromHost = NULL;
3563 	prop_t *propRcvFromIP = NULL;
3564 	int bNeedFree = 1;
3565 	DEFiRet;
3566 	dbgprintf("DDDD: msgSetPropViaJSON key: '%s'\n", name);
3567 	if(!strcmp(name, "rawmsg")) {
3568 		psz = json_object_get_string(json);
3569 		MsgSetRawMsg(pMsg, psz, strlen(psz));
3570 	} else if(!strcmp(name, "msg")) {
3571 		psz = json_object_get_string(json);
3572 		MsgReplaceMSG(pMsg, (const uchar*)psz, strlen(psz));
3573 	} else if(!strcmp(name, "syslogtag")) {
3574 		psz = json_object_get_string(json);
3575 		MsgSetTAG(pMsg, (const uchar*)psz, strlen(psz));
3576 	} else if(!strcmp(name, "pri")) {
3577 		val = json_object_get_int(json);
3578 		msgSetPRI(pMsg, val);
3579 	} else if(!strcmp(name, "syslogfacility")) {
3580 		val = json_object_get_int(json);
3581 		if(val &gt;= 0 &amp;&amp; val &lt;= 24)
3582 			pMsg-&gt;iFacility = val;
3583 		else
3584 			DBGPRINTF("mmexternal: invalid fac %d requested -- ignored\n", val);
3585 	} else if(!strcmp(name, "syslogseverity")) {
3586 		val = json_object_get_int(json);
3587 		if(val &gt;= 0 &amp;&amp; val &lt;= 7)
3588 			pMsg-&gt;iSeverity = val;
3589 		else
3590 			DBGPRINTF("mmexternal: invalid fac %d requested -- ignored\n", val);
3591 	} else if(!strcmp(name, "procid")) {
3592 		psz = json_object_get_string(json);
3593 		MsgSetPROCID(pMsg, psz);
3594 	} else if(!strcmp(name, "msgid")) {
3595 		psz = json_object_get_string(json);
3596 		MsgSetMSGID(pMsg, psz);
3597 	} else if(!strcmp(name, "structured-data")) {
3598 		psz = json_object_get_string(json);
3599 		MsgSetStructuredData(pMsg, psz);
3600 	} else if(!strcmp(name, "hostname") || !strcmp(name, "source")) {
3601 		psz = json_object_get_string(json);
3602 		MsgSetHOSTNAME(pMsg, (const uchar*)psz, strlen(psz));
3603 	} else if(!strcmp(name, "fromhost")) {
3604 		psz = json_object_get_string(json);
3605 		MsgSetRcvFromStr(pMsg, (const uchar*) psz, strlen(psz), &amp;propFromHost);
3606 		prop.Destruct(&amp;propFromHost);
3607 	} else if(!strcmp(name, "fromhost-ip")) {
3608 		psz = json_object_get_string(json);
3609 		MsgSetRcvFromIPStr(pMsg, (const uchar*)psz, strlen(psz), &amp;propRcvFromIP);
3610 		prop.Destruct(&amp;propRcvFromIP);
3611 	} else if(!strcmp(name, "$!")) {
3612 		bNeedFree = 0;
3613 		msgAddJSON(pMsg, (uchar*)"!", json, 0, sharedReference);
3614 	} else {
3615 		DBGPRINTF("msgSetPropViaJSON: unkonwn property ignored: %s\n",
3616 			  name);
3617 	}
3618 	if(bNeedFree) {
3619 		json_object_put(json);
3620 	}
3621 	RETiRet;
3622 }
3623 rsRetVal
3624 MsgSetPropsViaJSON(smsg_t *__restrict__ const pMsg, const uchar *__restrict__ const jsonstr)
3625 {
3626 	struct json_tokener *tokener = NULL;
3627 	struct json_object *json;
3628 	const char *errMsg;
3629 	DEFiRet;
3630 	DBGPRINTF("DDDDDD: JSON string for message mod: '%s'\n", jsonstr);
3631 	if(!strcmp((char*)jsonstr, "{}")) 		FINALIZE;
3632 	tokener = json_tokener_new();
3633 	json = json_tokener_parse_ex(tokener, (char*)jsonstr, ustrlen(jsonstr));
3634 	if(Debug) {
3635 		errMsg = NULL;
3636 		if(json == NULL) {
3637 			enum json_tokener_error err;
3638 			err = tokener-&gt;err;
3639 			if(err != json_tokener_continue)
3640 				errMsg = json_tokener_error_desc(err);
3641 			else
3642 				errMsg = "Unterminated input";
3643 		} else if(!json_object_is_type(json, json_type_object))
3644 			errMsg = "JSON value is not an object";
3645 		if(errMsg != NULL) {
3646 			DBGPRINTF("MsgSetPropsViaJSON: Error parsing JSON '%s': %s\n",
3647 					jsonstr, errMsg);
3648 		}
3649 	}
3650 	if(json == NULL || !json_object_is_type(json, json_type_object)) {
3651 		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
3652 	}
3653 	MsgSetPropsViaJSON_Object(pMsg, json);
3654 finalize_it:
3655 	if(tokener != NULL)
3656 		json_tokener_free(tokener);
3657 	RETiRet;
3658 }
3659 rsRetVal
3660 MsgSetPropsViaJSON_Object(smsg_t *__restrict__ const pMsg, struct json_object *json)
3661 {
3662 	DEFiRet;
3663 	if(json == NULL || !json_object_is_type(json, json_type_object)) {
3664 		DBGPRINTF("MsgSetPropsViaJSON_Object: json NULL or not object type\n");
3665 		ABORT_FINALIZE(RS_RET_JSON_UNUSABLE);
3666 	}
3667 	struct json_object_iterator it = json_object_iter_begin(json);
3668 	struct json_object_iterator itEnd = json_object_iter_end(json);
3669 	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
3670 		struct json_object *child = json_object_iter_peek_value(&amp;it);
3671 		json_object_get(child);
3672 		msgSetPropViaJSON(pMsg, json_object_iter_peek_name(&amp;it),
3673 			child, 0);
3674 		json_object_iter_next(&amp;it);
3675 	}
3676 	json_object_put(json);
3677 finalize_it:
3678 	RETiRet;
3679 }
3680 rsRetVal
3681 MsgGetSeverity(smsg_t * const pMsg, int *piSeverity)
3682 {
3683 	*piSeverity = pMsg-&gt;iSeverity;
3684 	return RS_RET_OK;
3685 }
3686 static uchar *
3687 jsonPathGetLeaf(uchar *name, int lenName)
3688 {
3689 	int i;
3690 	for(i = lenName ; i &gt;= 0 ; --i)
3691 		if(i == 0) {
3692 			if(name[0] == '!'  || name[0] == '.' || name[0] == '/')
3693 				break;
3694 		} else {
3695 			if(name[i] == '!')
3696 				break;
3697 		}
3698 	if(name[i] == '!' || name[i] == '.' || name[i] == '/')
3699 		++i;
3700 	return name + i;
3701 }
3702 static json_bool jsonVarExtract(struct json_object* root, const char *key, struct json_object **value) {
3703 	char namebuf[MAX_VARIABLE_NAME_LEN];
3704 	int key_len = strlen(key);
3705 	char *array_idx_start = strstr(key, "[");
3706 	char *array_idx_end = NULL;
3707 	char *array_idx_num_end_discovered = NULL;
3708 	struct json_object *arr = NULL;
3709 	if (array_idx_start != NULL) {
3710 		array_idx_end = strstr(array_idx_start, "]");
3711 	}
3712 	if (array_idx_end != NULL &amp;&amp; (array_idx_end - key + 1) == key_len) {
3713 		errno = 0;
3714 		int idx = (int) strtol(array_idx_start + 1, &amp;array_idx_num_end_discovered, 10);
3715 		if (errno == 0 &amp;&amp; array_idx_num_end_discovered == array_idx_end) {
3716 			memcpy(namebuf, key, array_idx_start - key);
3717 			namebuf[array_idx_start - key] = '\0';
3718 			json_bool found_obj = json_object_object_get_ex(root, namebuf, &amp;arr);
3719 			if (found_obj &amp;&amp; json_object_is_type(arr, json_type_array)) {
3720 				int len = json_object_array_length(arr);
3721 				if (len &gt; idx) {
3722 					*value = json_object_array_get_idx(arr, idx);
3723 					if (*value != NULL) return TRUE;
3724 				}
3725 				return FALSE;
3726 			}
3727 		}
3728 	}
3729 	return json_object_object_get_ex(root, key, value);
3730 }
3731 static rsRetVal
3732 jsonPathFindNext(struct json_object *root, uchar *namestart, uchar **name, uchar *leaf,
3733 		 struct json_object **found, int bCreate)
3734 {
3735 	uchar namebuf[MAX_VARIABLE_NAME_LEN];
3736 	struct json_object *json;
3737 	size_t i;
3738 	uchar *p = *name;
3739 	DEFiRet;
3740 	if(*p == '!' || (*name == namestart &amp;&amp; (*p == '.' || *p == '/')))
3741 		++p;
3742 	for(i = 0 ; *p &amp;&amp; !(p == namestart &amp;&amp; (*p == '.' || *p == '/')) &amp;&amp; *p != '!'
3743 		&amp;&amp; p != leaf &amp;&amp; i &lt; sizeof(namebuf)-1 ; ++i, ++p)
3744 		namebuf[i] = *p;
3745 	if(i &gt; 0) {
3746 		namebuf[i] = '\0';
3747 		if(jsonVarExtract(root, (char*)namebuf, &amp;json) == FALSE) {
3748 			json = NULL;
3749 		}
3750 	} else
3751 		json = root;
3752 	if(json == NULL) {
3753 		if(!bCreate) {
3754 			ABORT_FINALIZE(RS_RET_JNAME_INVALID);
3755 		} else {
3756 			if (json_object_get_type(root) != json_type_object) {
3757 				DBGPRINTF("jsonPathFindNext with bCreate: not a container in json path, "
3758 					"name is '%s'\n", namestart);
3759 				ABORT_FINALIZE(RS_RET_INVLD_SETOP);
3760 			}
3761 			json = json_object_new_object();
3762 			json_object_object_add(root, (char*)namebuf, json);
3763 		}
3764 	}
3765 	*name = p;
3766 	*found = json;
3767 finalize_it:
3768 	RETiRet;
3769 }
3770 static rsRetVal
3771 jsonPathFindParent(struct json_object *jroot, uchar *name, uchar *leaf, struct json_object **parent,
3772 	const int bCreate)
3773 {
3774 	uchar *namestart;
3775 	DEFiRet;
3776 	namestart = name;
3777 	*parent = jroot;
3778 	while(name &lt; leaf-1) {
3779 		CHKiRet(jsonPathFindNext(*parent, namestart, &amp;name, leaf, parent, bCreate));
3780 	}
3781 	if(*parent == NULL)
3782 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
3783 finalize_it:
3784 	RETiRet;
3785 }
3786 static rsRetVal
3787 jsonMerge(struct json_object *existing, struct json_object *json)
3788 {
3789 	DEFiRet;
3790 	struct json_object_iterator it = json_object_iter_begin(json);
3791 	struct json_object_iterator itEnd = json_object_iter_end(json);
3792 	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
3793 		json_object_object_add(existing, json_object_iter_peek_name(&amp;it),
3794 			json_object_get(json_object_iter_peek_value(&amp;it)));
3795 		json_object_iter_next(&amp;it);
3796 	}
3797 	json_object_put(json);
3798 	RETiRet;
3799 }
3800 rsRetVal
3801 jsonFind(smsg_t *const pMsg, msgPropDescr_t *pProp, struct json_object **jsonres)
3802 {
3803 	uchar *leaf;
3804 	struct json_object *parent;
3805 	struct json_object *field;
3806 	struct json_object **jroot = NULL;
3807 	pthread_mutex_t *mut = NULL;
3808 	DEFiRet;
3809 	CHKiRet(getJSONRootAndMutex(pMsg, pProp-&gt;id, &amp;jroot, &amp;mut));
3810 	pthread_mutex_lock(mut);
3811 	if(*jroot == NULL) {
3812 		field = NULL;
3813 		goto finalize_it;
3814 	}
3815 	if(!strcmp((char*)pProp-&gt;name, "!")) {
3816 		field = *jroot;
3817 	} else if(!strcmp((char*)pProp-&gt;name, ".")) {
3818 		field = *jroot;
3819 	} else {
3820 		leaf = jsonPathGetLeaf(pProp-&gt;name, pProp-&gt;nameLen);
3821 		CHKiRet(jsonPathFindParent(*jroot, pProp-&gt;name, leaf, &amp;parent, 0));
3822 		if(jsonVarExtract(parent, (char*)leaf, &amp;field) == FALSE)
3823 			field = NULL;
3824 	}
3825 	*jsonres = field;
3826 finalize_it:
3827 	if(mut != NULL)
3828 		pthread_mutex_unlock(mut);
3829 	RETiRet;
3830 }
3831 rsRetVal ATTR_NONNULL()
3832 msgCheckVarExists(smsg_t *const pMsg, msgPropDescr_t *pProp)
3833 {
3834 	struct json_object *jsonres = NULL;
3835 	DEFiRet;
3836 	CHKiRet(jsonFind(pMsg, pProp, &amp;jsonres));
3837 	if(jsonres == NULL) {
3838 		iRet = RS_RET_NOT_FOUND;
3839 	}
3840 finalize_it:
3841 	RETiRet;
3842 }
3843 rsRetVal
3844 msgAddJSON(smsg_t * const pM, uchar *name, struct json_object *json, int force_reset, int sharedReference)
3845 {
3846 	struct json_object **jroot;
3847 	struct json_object *parent, *leafnode;
3848 	struct json_object *given = NULL;
3849 	uchar *leaf;
3850 	pthread_mutex_t *mut = NULL;
3851 	DEFiRet;
3852 	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
3853 	pthread_mutex_lock(mut);
3854 	if(name[0] == '/') { 		if (sharedReference) {
3855 			given = json;
3856 			json = jsonDeepCopy(json);
3857 			json_object_put(given);
3858 		}
3859 	}
3860 	if(name[1] == '\0') { 		if(*jroot == NULL)
3861 			*jroot = json;
3862 		else
3863 			CHKiRet(jsonMerge(*jroot, json));
3864 	} else {
3865 		if(*jroot == NULL) {
3866 			*jroot = json_object_new_object();
3867 		}
3868 		leaf = jsonPathGetLeaf(name, ustrlen(name));
3869 		iRet = jsonPathFindParent(*jroot, name, leaf, &amp;parent, 1);
3870 		if (unlikely(iRet != RS_RET_OK)) {
3871 			json_object_put(json);
3872 			FINALIZE;
3873 		}
3874 		if (json_object_get_type(parent) != json_type_object) {
3875 			DBGPRINTF("msgAddJSON: not a container in json path,"
3876 				"name is '%s'\n", name);
3877 			json_object_put(json);
3878 			ABORT_FINALIZE(RS_RET_INVLD_SETOP);
3879 		}
3880 		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
3881 			leafnode = NULL;
3882 		if (force_reset || (leafnode == NULL)) {
3883 			json_object_object_add(parent, (char*)leaf, json);
3884 		} else {
3885 			if(json_object_get_type(json) == json_type_object) {
3886 				CHKiRet(jsonMerge(*jroot, json));
3887 			} else {
3888 				if(json_object_get_type(leafnode) == json_type_object) {
3889 					DBGPRINTF("msgAddJSON: trying to update a container "
3890 							  "node with a leaf, name is %s - "
3891 							  "forbidden", name);
3892 					json_object_put(json);
3893 					ABORT_FINALIZE(RS_RET_INVLD_SETOP);
3894 				}
3895 				json_object_object_add(parent, (char*)leaf, json);
3896 			}
3897 		}
3898 	}
3899 finalize_it:
3900 	if(mut != NULL)
3901 		pthread_mutex_unlock(mut);
3902 	RETiRet;
3903 }
3904 rsRetVal
3905 msgDelJSON(smsg_t * const pM, uchar *name)
3906 {
3907 	struct json_object **jroot;
3908 	struct json_object *parent, *leafnode;
3909 	uchar *leaf;
3910 	pthread_mutex_t *mut = NULL;
3911 	DEFiRet;
3912 	CHKiRet(getJSONRootAndMutexByVarChar(pM, name[0], &amp;jroot, &amp;mut));
3913 	pthread_mutex_lock(mut);
3914 	if(*jroot == NULL) {
3915 		DBGPRINTF("msgDelJSONVar; jroot empty in unset for property %s\n",
3916 			  name);
3917 		FINALIZE;
3918 	}
3919 	if(name[1] == '\0') {
3920 		DBGPRINTF("unsetting JSON root object\n");
3921 		json_object_put(*jroot);
3922 		*jroot = NULL;
3923 	} else {
3924 		leaf = jsonPathGetLeaf(name, ustrlen(name));
3925 		CHKiRet(jsonPathFindParent(*jroot, name, leaf, &amp;parent, 0));
3926 		if(jsonVarExtract(parent, (char*)leaf, &amp;leafnode) == FALSE)
3927 			leafnode = NULL;
3928 		if(leafnode == NULL) {
3929 			DBGPRINTF("unset JSON: could not find '%s'\n", name);
3930 			ABORT_FINALIZE(RS_RET_JNAME_NOTFOUND);
3931 		} else {
3932 			DBGPRINTF("deleting JSON value path '%s', "
3933 				  "leaf '%s', type %d\n",
3934 				  name, leaf, json_object_get_type(leafnode));
3935 			json_object_object_del(parent, (char*)leaf);
3936 		}
3937 	}
3938 finalize_it:
3939 	if(mut != NULL)
3940 		pthread_mutex_unlock(mut);
3941 	RETiRet;
3942 }
3943 rsRetVal
3944 msgAddMetadata(smsg_t *const __restrict__ pMsg,
3945 	       uchar *const __restrict__ metaname,
3946 	       uchar *const __restrict__ metaval)
3947 {
3948 	DEFiRet;
3949 	struct json_object *const json = json_object_new_object();
3950 	CHKmalloc(json);
3951 	struct json_object *const jval = json_object_new_string((char*)metaval);
3952 	if(jval == NULL) {
3953 		json_object_put(json);
3954 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
3955 	}
3956 	json_object_object_add(json, (const char *const)metaname, jval);
3957 	iRet = msgAddJSON(pMsg, (uchar*)"!metadata", json, 0, 0);
3958 finalize_it:
3959 	RETiRet;
3960 }
3961 rsRetVal
3962 msgAddMultiMetadata(smsg_t *const __restrict__ pMsg,
3963 	       const uchar ** __restrict__ metaname,
3964 	       const uchar ** __restrict__ metaval,
3965 	       const int count)
3966 {
3967 	DEFiRet;
3968 	int i = 0 ;
3969 	struct json_object *const json = json_object_new_object();
3970 	CHKmalloc(json);
3971 	for ( i = 0 ; i &lt; count ; i++ ) {
3972 		struct json_object *const jval = json_object_new_string((char*)metaval[i]);
3973 		if(jval == NULL) {
3974 			json_object_put(json);
3975 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
3976 		}
3977 		json_object_object_add(json, (const char *const)metaname[i], jval);
3978 	}
3979 	iRet = msgAddJSON(pMsg, (uchar*)"!metadata", json, 0, 0);
3980 finalize_it:
3981 	RETiRet;
3982 }
3983 struct json_object *
3984 jsonDeepCopy(struct json_object *src)
3985 {
3986 	struct json_object *dst = NULL, *json;
3987 	int arrayLen, i;
3988 	if(src == NULL) goto done;
3989 	switch(json_object_get_type(src)) {
3990 	case json_type_boolean:
3991 		dst = json_object_new_boolean(json_object_get_boolean(src));
3992 		break;
3993 	case json_type_double:
3994 		dst = json_object_new_double(json_object_get_double(src));
3995 		break;
3996 	case json_type_int:
3997 		dst = json_object_new_int64(json_object_get_int64(src));
3998 		break;
3999 	case json_type_string:
4000 		dst = json_object_new_string(json_object_get_string(src));
4001 		break;
4002 	case json_type_object:
4003 		dst = json_object_new_object();
4004 		struct json_object_iterator it = json_object_iter_begin(src);
4005 		struct json_object_iterator itEnd = json_object_iter_end(src);
4006 		while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
4007 			json = jsonDeepCopy(json_object_iter_peek_value(&amp;it));
4008 			json_object_object_add(dst, json_object_iter_peek_name(&amp;it), json);
4009 			json_object_iter_next(&amp;it);
4010 		}
4011 		break;
4012 	case json_type_array:
4013 		arrayLen = json_object_array_length(src);
4014 		dst = json_object_new_array();
4015 		for(i = 0 ; i &lt; arrayLen ; ++i) {
4016 			json = json_object_array_get_idx(src, i);
4017 			json = jsonDeepCopy(json);
4018 			json_object_array_add(dst, json);
4019 		}
4020 		break;
4021 	case json_type_null:
4022 	default:DBGPRINTF("jsonDeepCopy(): error unknown type %d\n",
4023 			 json_object_get_type(src));
4024 		dst = NULL;
4025 		break;
4026 	}
4027 done:	return dst;
4028 }
4029 rsRetVal
4030 msgSetJSONFromVar(smsg_t * const pMsg, uchar *varname, struct svar *v, int force_reset)
4031 {
4032 	struct json_object *json = NULL;
4033 	char *cstr;
4034 	DEFiRet;
4035 	switch(v-&gt;datatype) {
4036 	case 'S':		cstr = es_str2cstr(v-&gt;d.estr, NULL);
4037 		json = json_object_new_string(cstr);
4038 		free(cstr);
4039 		break;
4040 	case 'N':		json = json_object_new_int64(v-&gt;d.n);
4041 		break;
4042 	case 'J':		json = jsonDeepCopy(v-&gt;d.json);
4043 		break;
4044 	default:DBGPRINTF("msgSetJSONFromVar: unsupported datatype %c\n",
4045 		v-&gt;datatype);
4046 		ABORT_FINALIZE(RS_RET_ERR);
4047 	}
4048 	msgAddJSON(pMsg, varname, json, force_reset, 0);
4049 finalize_it:
4050 	RETiRet;
4051 }
4052 rsRetVal
4053 MsgAddToStructuredData(smsg_t * const pMsg, uchar *toadd, rs_size_t len)
4054 {
4055 	uchar *newptr;
4056 	rs_size_t newlen;
4057 	int empty;
4058 	DEFiRet;
4059 	empty = pMsg-&gt;pszStrucData == NULL || pMsg-&gt;pszStrucData[0] == '-';
4060 	newlen = (empty) ? len : pMsg-&gt;lenStrucData + len;
4061 	CHKmalloc(newptr = (uchar*) realloc(pMsg-&gt;pszStrucData, newlen+1));
4062 	if(empty) {
4063 		memcpy(newptr, toadd, len);
4064 	} else {
4065 		memcpy(newptr+pMsg-&gt;lenStrucData, toadd, len);
4066 	}
4067 	pMsg-&gt;pszStrucData = newptr;
4068 	pMsg-&gt;pszStrucData[newlen] = '\0';
4069 	pMsg-&gt;lenStrucData = newlen;
4070 finalize_it:
4071 	RETiRet;
4072 }
4073 rsRetVal
4074 msgPropDescrFill(msgPropDescr_t *pProp, uchar *name, int nameLen)
4075 {
4076 	propid_t id;
4077 	int offs;
4078 	DEFiRet;
4079 	if(propNameToID(name, &amp;id) != RS_RET_OK) {
4080 		parser_errmsg("invalid property '%s'", name);
4081 		if(!strcasecmp((char*)name, "myhostname"))
4082 			parser_errmsg("did you mean '$myhostname' instead of '%s'? "
4083 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4084 		else if(!strcasecmp((char*)name, "bom"))
4085 			parser_errmsg("did you mean '$bom' instead of '%s'?"
4086 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4087 		else if(!strcasecmp((char*)name, "now"))
4088 			parser_errmsg("did you mean '$now' instead of '%s'?"
4089 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4090 		else if(!strcasecmp((char*)name, "year"))
4091 			parser_errmsg("did you mean '$year' instead of '%s'?"
4092 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4093 		else if(!strcasecmp((char*)name, "month"))
4094 			parser_errmsg("did you mean '$month' instead of '%s'?"
4095 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4096 		else if(!strcasecmp((char*)name, "day"))
4097 			parser_errmsg("did you mean '$day' instead of '%s'?"
4098 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4099 		else if(!strcasecmp((char*)name, "hour"))
4100 			parser_errmsg("did you mean '$hour' instead of '%s'?"
4101 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4102 		else if(!strcasecmp((char*)name, "hhour"))
4103 			parser_errmsg("did you mean '$hhour' instead of '%s'?"
4104 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4105 		else if(!strcasecmp((char*)name, "qhour"))
4106 			parser_errmsg("did you mean '$qhour' instead of '%s'?"
4107 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4108 		else if(!strcasecmp((char*)name, "minute"))
4109 			parser_errmsg("did you mean '$minute' instead of '%s'?"
4110 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4111 		else if(!strcasecmp((char*)name, "now-utc"))
4112 			parser_errmsg("did you mean '$now-utc' instead of '%s'?"
4113 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4114 		else if(!strcasecmp((char*)name, "year-utc"))
4115 			parser_errmsg("did you mean '$year-utc' instead of '%s'?"
4116 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4117 		else if(!strcasecmp((char*)name, "month-utc"))
4118 			parser_errmsg("did you mean '$month-utc' instead of '%s'?"
4119 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4120 		else if(!strcasecmp((char*)name, "day-utc"))
4121 			parser_errmsg("did you mean '$day-utc' instead of '%s'?"
4122 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4123 		else if(!strcasecmp((char*)name, "hour-utc"))
4124 			parser_errmsg("did you mean '$hour-utc' instead of '%s'?"
4125 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4126 		else if(!strcasecmp((char*)name, "hhour-utc"))
4127 			parser_errmsg("did you mean '$hhour-utc' instead of '%s'?"
4128 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4129 		else if(!strcasecmp((char*)name, "qhour-utc"))
4130 			parser_errmsg("did you mean '$qhour-utc' instead of '%s'?"
4131 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4132 		else if(!strcasecmp((char*)name, "minute-utc"))
4133 			parser_errmsg("did you mean '$minute-utc' instead of '%s'?"
4134 				"See also: https://www.rsyslog.com/rsyslog-info-1/", name);
4135 		ABORT_FINALIZE(RS_RET_INVLD_PROP);
4136 	}
4137 	if(id == PROP_CEE || id == PROP_LOCAL_VAR || id == PROP_GLOBAL_VAR) {
4138 		offs = (name[0] == '$') ? 1 : 0;
4139 		pProp-&gt;name = ustrdup(name + offs);
4140 		pProp-&gt;nameLen = nameLen - offs;
4141 		pProp-&gt;name[0] = '!';
4142 	}
4143 	pProp-&gt;id = id;
4144 finalize_it:
4145 	RETiRet;
4146 }
4147 void
4148 msgPropDescrDestruct(msgPropDescr_t *pProp)
4149 {
4150 	if(pProp != NULL) {
4151 		if(pProp-&gt;id == PROP_CEE ||
4152 		   pProp-&gt;id == PROP_LOCAL_VAR ||
4153 		   pProp-&gt;id == PROP_GLOBAL_VAR)
4154 			free(pProp-&gt;name);
4155 	}
4156 }
4157 static rsRetVal msgQueryInterface(interface_t __attribute__((unused)) *i) { return RS_RET_NOT_IMPLEMENTED; }
4158 BEGINObjClassInit(msg, 1, OBJ_IS_CORE_MODULE)
4159 	pthread_mutex_init(&amp;glblVars_lock, NULL);
4160 	CHKiRet(objUse(datetime, CORE_COMPONENT));
4161 	CHKiRet(objUse(glbl, CORE_COMPONENT));
4162 	CHKiRet(objUse(prop, CORE_COMPONENT));
4163 	CHKiRet(objUse(var, CORE_COMPONENT));
4164 	OBJSetMethodHandler(objMethod_SERIALIZE, MsgSerialize);
4165 #	ifdef HAVE_MALLOC_TRIM
4166 	INIT_ATOMIC_HELPER_MUT(mutTrimCtr);
4167 #	endif
4168 ENDObjClassInit(msg)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
