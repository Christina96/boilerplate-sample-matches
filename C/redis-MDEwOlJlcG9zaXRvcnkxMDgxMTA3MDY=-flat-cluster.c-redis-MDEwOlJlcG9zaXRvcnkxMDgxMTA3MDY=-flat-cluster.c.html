
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-cluster.c</h3>
            <pre><code>1  #include "server.h"
2  #include "cluster.h"
3  #include "endianconv.h"
4  #include <sys/types.h>
5  POSIX_ONLY(#include <sys/socket.h>)
6  POSIX_ONLY(#include <arpa/inet.h>)
7  #include <fcntl.h>
8  POSIX_ONLY(#include <unistd.h>)
9  POSIX_ONLY(#include <sys/socket.h>)
10  #include <sys/stat.h>
11  POSIX_ONLY(#include <sys/file.h>)
12  #include <math.h>
13  #ifdef _WIN32
14  extern int WSIOCP_QueueAccept(int listenfd);
15  #include "Win32_Interop/Win32_Error.h"
16  #endif
17  clusterNode *myself = NULL;
18  clusterNode *createClusterNode(char *nodename, int flags);
19  int clusterAddNode(clusterNode *node);
20  void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);
21  void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask);
22  void clusterSendPing(clusterLink *link, int type);
23  void clusterSendFail(char *nodename);
24  void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);
25  void clusterUpdateState(void);
26  int clusterNodeGetSlotBit(clusterNode *n, int slot);
27  sds clusterGenNodesDescription(int filter);
28  clusterNode *clusterLookupNode(const char *name);
29  int clusterNodeAddSlave(clusterNode *master, clusterNode *slave);
30  int clusterAddSlot(clusterNode *n, int slot);
31  int clusterDelSlot(int slot);
32  int clusterDelNodeSlots(clusterNode *node);
33  int clusterNodeSetSlotBit(clusterNode *n, int slot);
34  void clusterSetMaster(clusterNode *n);
35  void clusterHandleSlaveFailover(void);
36  void clusterHandleSlaveMigration(int max_slaves);
37  int bitmapTestBit(unsigned char *bitmap, int pos);
38  void clusterDoBeforeSleep(int flags);
39  void clusterSendUpdate(clusterLink *link, clusterNode *node);
40  void resetManualFailover(void);
41  void clusterCloseAllSlots(void);
42  void clusterSetNodeAsMaster(clusterNode *n);
43  void clusterDelNode(clusterNode *delnode);
44  sds representClusterNodeFlags(sds ci, uint16_t flags);
45  uint64_t clusterGetMaxEpoch(void);
46  int clusterBumpConfigEpochWithoutConsensus(void);
47  void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len);
48  int clusterLoadConfig(char *filename) {
49      FILE *fp = fopen(filename, IF_WIN32("rb", "r"));
50      struct IF_WIN32(_stat64, stat) sb;                                           
51      char *line;
52      int maxline, j;
53      if (fp == NULL) {
54          if (errno == ENOENT) {
55              return C_ERR;
56          } else {
57              serverLog(LL_WARNING,
58                  "Loading the cluster node config from %s: %s",
59                  filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
60              exit(1);
61          }
62      }
63      if (fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
64          fclose(fp);
65          return C_ERR;
66      }
67      maxline = 1024+CLUSTER_SLOTS*128;
68      line = zmalloc(maxline);
69      while(fgets(line,maxline,fp) != NULL) {
70          int argc;
71          sds *argv;
72          clusterNode *n, *master;
73          char *p, *s;
74          if (line[0] == '\n' || line[0] == '\0') continue;
75          argv = sdssplitargs(line,&argc);
76          if (argv == NULL) goto fmterr;
77          if (strcasecmp(argv[0],"vars") == 0) {
78              if (!(argc % 2)) goto fmterr;
79              for (j = 1; j < argc; j += 2) {
80                  if (strcasecmp(argv[j],"currentEpoch") == 0) {
81                      server.cluster->currentEpoch =
82                              strtoull(argv[j+1],NULL,10);
83                  } else if (strcasecmp(argv[j],"lastVoteEpoch") == 0) {
84                      server.cluster->lastVoteEpoch =
85                              strtoull(argv[j+1],NULL,10);
86                  } else {
87                      serverLog(LL_WARNING,
88                          "Skipping unknown cluster config variable '%s'",
89                          argv[j]);
90                  }
91              }
92              sdsfreesplitres(argv,argc);
93              continue;
94          }
95          if (argc < 8) {
96              sdsfreesplitres(argv,argc);
97              goto fmterr;
98          }
99          n = clusterLookupNode(argv[0]);
100          if (!n) {
101              n = createClusterNode(argv[0],0);
102              clusterAddNode(n);
103          }
104          if ((p = strrchr(argv[1],':')) == NULL) {
105              sdsfreesplitres(argv,argc);
106              goto fmterr;
107          }
108          *p = '\0';
109          memcpy(n->ip,argv[1],strlen(argv[1])+1);
110          char *port = p+1;
111          char *busp = strchr(port,'@');
112          if (busp) {
113              *busp = '\0';
114              busp++;
115          }
116          n->port = atoi(port);
117          n->cport = busp ? atoi(busp) : n->port + CLUSTER_PORT_INCR;
118          p = s = argv[2];
119          while(p) {
120              p = strchr(s,',');
121              if (p) *p = '\0';
122              if (!strcasecmp(s,"myself")) {
123                  serverAssert(server.cluster->myself == NULL);
124                  myself = server.cluster->myself = n;
125                  n->flags |= CLUSTER_NODE_MYSELF;
126              } else if (!strcasecmp(s,"master")) {
127                  n->flags |= CLUSTER_NODE_MASTER;
128              } else if (!strcasecmp(s,"slave")) {
129                  n->flags |= CLUSTER_NODE_SLAVE;
130              } else if (!strcasecmp(s,"fail?")) {
131                  n->flags |= CLUSTER_NODE_PFAIL;
132              } else if (!strcasecmp(s,"fail")) {
133                  n->flags |= CLUSTER_NODE_FAIL;
134                  n->fail_time = mstime();
135              } else if (!strcasecmp(s,"handshake")) {
136                  n->flags |= CLUSTER_NODE_HANDSHAKE;
137              } else if (!strcasecmp(s,"noaddr")) {
138                  n->flags |= CLUSTER_NODE_NOADDR;
139              } else if (!strcasecmp(s,"nofailover")) {
140                  n->flags |= CLUSTER_NODE_NOFAILOVER;
141              } else if (!strcasecmp(s,"noflags")) {
142              } else {
143                  serverPanic("Unknown flag in redis cluster config file");
144              }
145              if (p) s = p+1;
146          }
147          if (argv[3][0] != '-') {
148              master = clusterLookupNode(argv[3]);
149              if (!master) {
150                  master = createClusterNode(argv[3],0);
151                  clusterAddNode(master);
152              }
153              n->slaveof = master;
154              clusterNodeAddSlave(master,n);
155          }
156          if (atoi(argv[4])) n->ping_sent = mstime();
157          if (atoi(argv[5])) n->pong_received = mstime();
158          n->configEpoch = strtoull(argv[6],NULL,10);
159          for (j = 8; j < argc; j++) {
160              int start, stop;
161              if (argv[j][0] == '[') {
162                  int slot;
163                  char direction;
164                  clusterNode *cn;
165                  p = strchr(argv[j],'-');
166                  serverAssert(p != NULL);
167                  *p = '\0';
168                  direction = p[1]; &bsol;* Either '>' or '<' */
169                  slot = atoi(argv[j]+1);
170                  if (slot < 0 || slot >= CLUSTER_SLOTS) {
171                      sdsfreesplitres(argv,argc);
172                      goto fmterr;
173                  }
174                  p += 3;
175                  cn = clusterLookupNode(p);
176                  if (!cn) {
177                      cn = createClusterNode(p,0);
178                      clusterAddNode(cn);
179                  }
180                  if (direction == '>') {
181                      server.cluster->migrating_slots_to[slot] = cn;
182                  } else {
183                      server.cluster->importing_slots_from[slot] = cn;
184                  }
185                  continue;
186              } else if ((p = strchr(argv[j],'-')) != NULL) {
187                  *p = '\0';
188                  start = atoi(argv[j]);
189                  stop = atoi(p+1);
190              } else {
191                  start = stop = atoi(argv[j]);
192              }
193              if (start < 0 || start >= CLUSTER_SLOTS ||
194                  stop < 0 || stop >= CLUSTER_SLOTS)
195              {
196                  sdsfreesplitres(argv,argc);
197                  goto fmterr;
198              }
199              while(start <= stop) clusterAddSlot(n, start++);
200          }
201          sdsfreesplitres(argv,argc);
202      }
203      if (server.cluster->myself == NULL) goto fmterr;
204      zfree(line);
205      fclose(fp);
206      serverLog(LL_NOTICE,"Node configuration loaded, I'm %.40s", myself->name);
207      if (clusterGetMaxEpoch() > server.cluster->currentEpoch) {
208          server.cluster->currentEpoch = clusterGetMaxEpoch();
209      }
210      return C_OK;
211  fmterr:
212      serverLog(LL_WARNING,
213          "Unrecoverable error: corrupted cluster config file.");
214      zfree(line);
215      if (fp) fclose(fp);
216      exit(1);
217  }
218  int clusterSaveConfig(int do_fsync) {
219      sds ci;
220      size_t content_size;
221      struct IF_WIN32(_stat64, stat) sb;                                           
222      int fd;
223      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;
224      ci = clusterGenNodesDescription(CLUSTER_NODE_HANDSHAKE);
225      ci = sdscatprintf(ci,"vars currentEpoch %llu lastVoteEpoch %llu\n",
226          (PORT_ULONGLONG) server.cluster->currentEpoch,
227          (PORT_ULONGLONG) server.cluster->lastVoteEpoch);
228      content_size = sdslen(ci);
229      if ((fd = open(server.cluster_configfile,O_WRONLY|O_CREAT,0644))
230          == -1) goto err;
231      if (fstat(fd,&sb) != -1) {
232          if (sb.st_size > (off_t)content_size) {
233              ci = sdsgrowzero(ci,sb.st_size);
234              memset(ci+content_size,'\n',sb.st_size-content_size);
235          }
236      }
237      if (write(fd,ci,sdslen(ci)) != (ssize_t)sdslen(ci)) goto err;
238      if (do_fsync) {
239          server.cluster->todo_before_sleep &= ~CLUSTER_TODO_FSYNC_CONFIG;
240          fsync(fd);
241      }
242      if (content_size != sdslen(ci) && ftruncate(fd,content_size) == -1) {
243      }
244      close(fd);
245      sdsfree(ci);
246      return 0;
247  err:
248      if (fd != -1) close(fd);
249      sdsfree(ci);
250      return -1;
251  }
252  void clusterSaveConfigOrDie(int do_fsync) {
253      if (clusterSaveConfig(do_fsync) == -1) {
254          serverLog(LL_WARNING,"Fatal: can't update cluster config file.");
255          exit(1);
256      }
257  }
258  int clusterLockConfig(char *filename) {
259  #if !defined(__sun)
260      int fd = open(filename,O_WRONLY|O_CREAT,0644);
261      if (fd == -1) {
262          serverLog(LL_WARNING,
263              "Can't open %s in order to acquire a lock: %s",
264              filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
265          return C_ERR;
266      }
267  #ifndef _WIN32
268      if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
269          if (errno == EWOULDBLOCK) {
270  #else
271      HANDLE hFile = (HANDLE) FDAPI_get_osfhandle(fd);
272      OVERLAPPED ovlp;
273      DWORD size_lower, size_upper;
274      memset(&ovlp, 0, sizeof ovlp);
275      size_lower = GetFileSize(hFile, &size_upper);
276      if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, size_lower, size_upper, &ovlp)) {
277          DWORD err = GetLastError();
278          if (err == ERROR_LOCK_VIOLATION) {
279  #endif
280              serverLog(LL_WARNING,
281                   "Sorry, the cluster configuration file %s is already used "
282                   "by a different Redis Cluster node. Please make sure that "
283                   "different nodes use different cluster configuration "
284                   "files.", filename);
285          } else {
286              serverLog(LL_WARNING,
287                  "Impossible to lock %s: %s", filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
288          }
289          close(fd);
290          return C_ERR;
291      }
292  #endif &bsol;* __sun */
293      return C_OK;
294  }
295  void clusterUpdateMyselfFlags(void) {
296      int oldflags = myself->flags;
297      int nofailover = server.cluster_slave_no_failover ?
298                       CLUSTER_NODE_NOFAILOVER : 0;
299      myself->flags &= ~CLUSTER_NODE_NOFAILOVER;
300      myself->flags |= nofailover;
301      if (myself->flags != oldflags) {
302          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
303                               CLUSTER_TODO_UPDATE_STATE);
304      }
305  }
306  void clusterInit(void) {
307      int saveconf = 0;
308      server.cluster = zmalloc(sizeof(clusterState));
309      server.cluster->myself = NULL;
310      server.cluster->currentEpoch = 0;
311      server.cluster->state = CLUSTER_FAIL;
312      server.cluster->size = 1;
313      server.cluster->todo_before_sleep = 0;
314      server.cluster->nodes = dictCreate(&clusterNodesDictType,NULL);
315      server.cluster->nodes_black_list =
316          dictCreate(&clusterNodesBlackListDictType,NULL);
317      server.cluster->failover_auth_time = 0;
318      server.cluster->failover_auth_count = 0;
319      server.cluster->failover_auth_rank = 0;
320      server.cluster->failover_auth_epoch = 0;
321      server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
322      server.cluster->lastVoteEpoch = 0;
323      for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
324          server.cluster->stats_bus_messages_sent[i] = 0;
325          server.cluster->stats_bus_messages_received[i] = 0;
326      }
327      server.cluster->stats_pfail_nodes = 0;
328      memset(server.cluster->slots,0, sizeof(server.cluster->slots));
329      clusterCloseAllSlots();
330  #ifndef WIN32   
331      if (clusterLockConfig(server.cluster_configfile) == C_ERR)
332          exit(1);
333  #endif
334      if (clusterLoadConfig(server.cluster_configfile) == C_ERR) {
335          myself = server.cluster->myself =
336              createClusterNode(NULL,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);
337          serverLog(LL_NOTICE,"No cluster configuration found, I'm %.40s",
338              myself->name);
339          clusterAddNode(myself);
340          saveconf = 1;
341      }
342      if (saveconf) clusterSaveConfigOrDie(1);
343      server.cfd_count = 0;
344      if (server.port > (65535-CLUSTER_PORT_INCR)) {
345          serverLog(LL_WARNING, "Redis port number too high. "
346                     "Cluster communication port is 10,000 port "
347                     "numbers higher than your Redis port. "
348                     "Your Redis port number must be "
349                     "lower than 55535.");
350          exit(1);
351      }
352      if (listenToPort(server.port+CLUSTER_PORT_INCR,
353          server.cfd,&server.cfd_count) == C_ERR)
354      {
355          exit(1);
356      } else {
357          int j;
358          for (j = 0; j < server.cfd_count; j++) {
359              if (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,
360                  clusterAcceptHandler, NULL) == AE_ERR)
361                      serverPanic("Unrecoverable error creating Redis Cluster "
362                                  "file event.");
363          }
364      }
365      server.cluster->slots_to_keys = raxNew();
366      memset(server.cluster->slots_keys_count,0,
367             sizeof(server.cluster->slots_keys_count));
368      myself->port = server.port;
369      myself->cport = server.port+CLUSTER_PORT_INCR;
370      if (server.cluster_announce_port)
371          myself->port = server.cluster_announce_port;
372      if (server.cluster_announce_bus_port)
373          myself->cport = server.cluster_announce_bus_port;
374      server.cluster->mf_end = 0;
375      resetManualFailover();
376      clusterUpdateMyselfFlags();
377  }
378  void clusterReset(int hard) {
379      dictIterator *di;
380      dictEntry *de;
381      int j;
382      if (nodeIsSlave(myself)) {
383          clusterSetNodeAsMaster(myself);
384          replicationUnsetMaster();
385          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
386      }
387      clusterCloseAllSlots();
388      resetManualFailover();
389      for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);
390      di = dictGetSafeIterator(server.cluster->nodes);
391      while((de = dictNext(di)) != NULL) {
392          clusterNode *node = dictGetVal(de);
393          if (node == myself) continue;
394          clusterDelNode(node);
395      }
396      dictReleaseIterator(di);
397      if (hard) {
398          sds oldname;
399          server.cluster->currentEpoch = 0;
400          server.cluster->lastVoteEpoch = 0;
401          myself->configEpoch = 0;
402          serverLog(LL_WARNING, "configEpoch set to 0 via CLUSTER RESET HARD");
403          oldname = sdsnewlen(myself->name, CLUSTER_NAMELEN);
404          dictDelete(server.cluster->nodes,oldname);
405          sdsfree(oldname);
406          getRandomHexChars(myself->name, CLUSTER_NAMELEN);
407          clusterAddNode(myself);
408          serverLog(LL_NOTICE,"Node hard reset, now I'm %.40s", myself->name);
409      }
410      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
411                           CLUSTER_TODO_UPDATE_STATE|
412                           CLUSTER_TODO_FSYNC_CONFIG);
413  }
414  clusterLink *createClusterLink(clusterNode *node) {
415      clusterLink *link = zmalloc(sizeof(*link));
416      link->ctime = mstime();
417      link->sndbuf = sdsempty();
418      link->rcvbuf = sdsempty();
419      link->node = node;
420      link->fd = -1;
421      return link;
422  }
423  void freeClusterLink(clusterLink *link) {
424      if (link->fd != -1) {
425          aeDeleteFileEvent(server.el, link->fd, AE_READABLE|AE_WRITABLE);
426      }
427      sdsfree(link->sndbuf);
428      sdsfree(link->rcvbuf);
429      if (link->node)
430          link->node->link = NULL;
431      close(link->fd);
432      zfree(link);
433  }
434  #define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
435  void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
436      int cport, cfd;
437      int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
438      char cip[NET_IP_STR_LEN];
439      clusterLink *link;
440      UNUSED(el);
441      UNUSED(mask);
442      UNUSED(privdata);
443  #ifndef _WIN32
444      if (server.masterhost == NULL && server.loading) return;
445  #else
446      if (server.masterhost == NULL && server.loading) {
447          WSIOCP_QueueAccept(fd);
448          return;
449      }
450  #endif
451      while(max--) {
452          cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
453          if (cfd == ANET_ERR) {
454              if (errno != EWOULDBLOCK)
455                  serverLog(LL_VERBOSE,
456                      "Error accepting cluster node: %s", server.neterr);
457  #ifdef _WIN32
458              if (WSIOCP_QueueAccept(fd) == -1) {
459                  serverLog(LL_WARNING,
460                      "acceptTcpHandler: failed to queue another accept.");
461              }
462  #endif
463              return;
464          }
465          anetNonBlock(NULL,cfd);
466          anetEnableTcpNoDelay(NULL,cfd);
467          serverLog(LL_VERBOSE,"Accepted cluster node %s:%d", cip, cport);
468          link = createClusterLink(NULL);
469          link->fd = cfd;
470          aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
471      }
472  }
473  unsigned int keyHashSlot(char *key, int keylen) {
474      int s, e; &bsol;* start-end indexes of { and } */
475      for (s = 0; s < keylen; s++)
476          if (key[s] == '{') break;
477      if (s == keylen) return crc16(key,keylen) & 0x3FFF;
478      for (e = s+1; e < keylen; e++)
479          if (key[e] == '}') break;
480      if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
481      return crc16(key+s+1,e-s-1) & 0x3FFF;
482  }
483  clusterNode *createClusterNode(char *nodename, int flags) {
484      clusterNode *node = zmalloc(sizeof(*node));
485      if (nodename)
486          memcpy(node->name, nodename, CLUSTER_NAMELEN);
487      else
488          getRandomHexChars(node->name, CLUSTER_NAMELEN);
489      node->ctime = mstime();
490      node->configEpoch = 0;
491      node->flags = flags;
492      memset(node->slots,0,sizeof(node->slots));
493      node->numslots = 0;
494      node->numslaves = 0;
495      node->slaves = NULL;
496      node->slaveof = NULL;
497      node->ping_sent = node->pong_received = 0;
498      node->data_received = 0;
499      node->fail_time = 0;
500      node->link = NULL;
501      memset(node->ip,0,sizeof(node->ip));
502      node->port = 0;
503      node->cport = 0;
504      node->fail_reports = listCreate();
505      node->voted_time = 0;
506      node->orphaned_time = 0;
507      node->repl_offset_time = 0;
508      node->repl_offset = 0;
509      listSetFreeMethod(node->fail_reports,zfree);
510      return node;
511  }
512  int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
513      list *l = failing->fail_reports;
514      listNode *ln;
515      listIter li;
516      clusterNodeFailReport *fr;
517      listRewind(l,&li);
518      while ((ln = listNext(&li)) != NULL) {
519          fr = ln->value;
520          if (fr->node == sender) {
521              fr->time = mstime();
522              return 0;
523          }
524      }
525      fr = zmalloc(sizeof(*fr));
526      fr->node = sender;
527      fr->time = mstime();
528      listAddNodeTail(l,fr);
529      return 1;
530  }
531  void clusterNodeCleanupFailureReports(clusterNode *node) {
532      list *l = node->fail_reports;
533      listNode *ln;
534      listIter li;
535      clusterNodeFailReport *fr;
536      mstime_t maxtime = server.cluster_node_timeout *
537                       CLUSTER_FAIL_REPORT_VALIDITY_MULT;
538      mstime_t now = mstime();
539      listRewind(l,&li);
540      while ((ln = listNext(&li)) != NULL) {
541          fr = ln->value;
542          if (now - fr->time > maxtime) listDelNode(l,ln);
543      }
544  }
545  int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
546      list *l = node->fail_reports;
547      listNode *ln;
548      listIter li;
549      clusterNodeFailReport *fr;
550      listRewind(l,&li);
551      while ((ln = listNext(&li)) != NULL) {
552          fr = ln->value;
553          if (fr->node == sender) break;
554      }
555      if (!ln) return 0; &bsol;* No failure report from this sender. */
556      listDelNode(l,ln);
557      clusterNodeCleanupFailureReports(node);
558      return 1;
559  }
560  int clusterNodeFailureReportsCount(clusterNode *node) {
561      clusterNodeCleanupFailureReports(node);
562      return (int)listLength(node->fail_reports);                                WIN_PORT_FIX &bsol;* cast (int) */
563  }
564  int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
565      int j;
566      for (j = 0; j < master->numslaves; j++) {
567          if (master->slaves[j] == slave) {
568              if ((j+1) < master->numslaves) {
569                  int remaining_slaves = (master->numslaves - j) - 1;
570                  memmove(master->slaves+j,master->slaves+(j+1),
571                          (sizeof(*master->slaves) * remaining_slaves));
572              }
573              master->numslaves--;
574              if (master->numslaves == 0)
575                  master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
576              return C_OK;
577          }
578      }
579      return C_ERR;
580  }
581  int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
582      int j;
583      for (j = 0; j < master->numslaves; j++)
584          if (master->slaves[j] == slave) return C_ERR;
585      master->slaves = zrealloc(master->slaves,
586          sizeof(clusterNode*)*(master->numslaves+1));
587      master->slaves[master->numslaves] = slave;
588      master->numslaves++;
589      master->flags |= CLUSTER_NODE_MIGRATE_TO;
590      return C_OK;
591  }
592  int clusterCountNonFailingSlaves(clusterNode *n) {
593      int j, okslaves = 0;
594      for (j = 0; j < n->numslaves; j++)
595          if (!nodeFailed(n->slaves[j])) okslaves++;
596      return okslaves;
597  }
598  void freeClusterNode(clusterNode *n) {
599      sds nodename;
600      int j;
601      for (j = 0; j < n->numslaves; j++)
602          n->slaves[j]->slaveof = NULL;
603      if (nodeIsSlave(n) && n->slaveof) clusterNodeRemoveSlave(n->slaveof,n);
604      nodename = sdsnewlen(n->name, CLUSTER_NAMELEN);
605      serverAssert(dictDelete(server.cluster->nodes,nodename) == DICT_OK);
606      sdsfree(nodename);
607      if (n->link) freeClusterLink(n->link);
608      listRelease(n->fail_reports);
609      zfree(n->slaves);
610      zfree(n);
611  }
612  int clusterAddNode(clusterNode *node) {
613      int retval;
614      retval = dictAdd(server.cluster->nodes,
615              sdsnewlen(node->name,CLUSTER_NAMELEN), node);
616      return (retval == DICT_OK) ? C_OK : C_ERR;
617  }
618  void clusterDelNode(clusterNode *delnode) {
619      int j;
620      dictIterator *di;
621      dictEntry *de;
622      for (j = 0; j < CLUSTER_SLOTS; j++) {
623          if (server.cluster->importing_slots_from[j] == delnode)
624              server.cluster->importing_slots_from[j] = NULL;
625          if (server.cluster->migrating_slots_to[j] == delnode)
626              server.cluster->migrating_slots_to[j] = NULL;
627          if (server.cluster->slots[j] == delnode)
628              clusterDelSlot(j);
629      }
<span onclick='openModal()' class='match'>630      di = dictGetSafeIterator(server.cluster->nodes);
631      while((de = dictNext(di)) != NULL) {
632          clusterNode *node = dictGetVal(de);
</span>633          if (node == delnode) continue;
634          clusterNodeDelFailureReport(node,delnode);
635      }
636      dictReleaseIterator(di);
637      freeClusterNode(delnode);
638  }
639  clusterNode *clusterLookupNode(const char *name) {
640      sds s = sdsnewlen(name, CLUSTER_NAMELEN);
641      dictEntry *de;
642      de = dictFind(server.cluster->nodes,s);
643      sdsfree(s);
644      if (de == NULL) return NULL;
645      return dictGetVal(de);
646  }
647  void clusterRenameNode(clusterNode *node, char *newname) {
648      int retval;
649      sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);
650      serverLog(LL_DEBUG,"Renaming node %.40s into %.40s",
651          node->name, newname);
652      retval = dictDelete(server.cluster->nodes, s);
653      sdsfree(s);
654      serverAssert(retval == DICT_OK);
655      memcpy(node->name, newname, CLUSTER_NAMELEN);
656      clusterAddNode(node);
657  }
658  uint64_t clusterGetMaxEpoch(void) {
659      uint64_t max = 0;
660      dictIterator *di;
661      dictEntry *de;
662      di = dictGetSafeIterator(server.cluster->nodes);
663      while((de = dictNext(di)) != NULL) {
664          clusterNode *node = dictGetVal(de);
665          if (node->configEpoch > max) max = node->configEpoch;
666      }
667      dictReleaseIterator(di);
668      if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
669      return max;
670  }
671  int clusterBumpConfigEpochWithoutConsensus(void) {
672      uint64_t maxEpoch = clusterGetMaxEpoch();
673      if (myself->configEpoch == 0 ||
674          myself->configEpoch != maxEpoch)
675      {
676          server.cluster->currentEpoch++;
677          myself->configEpoch = server.cluster->currentEpoch;
678          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
679                               CLUSTER_TODO_FSYNC_CONFIG);
680          serverLog(LL_WARNING,
681              "New configEpoch set to %llu",
682              (PORT_ULONGLONG) myself->configEpoch);
683          return C_OK;
684      } else {
685          return C_ERR;
686      }
687  }
688  void clusterHandleConfigEpochCollision(clusterNode *sender) {
689      if (sender->configEpoch != myself->configEpoch ||
690          !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
691      if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
692      server.cluster->currentEpoch++;
693      myself->configEpoch = server.cluster->currentEpoch;
694      clusterSaveConfigOrDie(1);
695      serverLog(LL_VERBOSE,
696          "WARNING: configEpoch collision with node %.40s."
697          " configEpoch set to %llu",
698          sender->name,
699          (PORT_ULONGLONG) myself->configEpoch);
700  }
701  #define CLUSTER_BLACKLIST_TTL 60      &bsol;* 1 minute. */
702  void clusterBlacklistCleanup(void) {
703      dictIterator *di;
704      dictEntry *de;
705      di = dictGetSafeIterator(server.cluster->nodes_black_list);
706      while((de = dictNext(di)) != NULL) {
707          int64_t expire = dictGetUnsignedIntegerVal(de);
708          if (expire < server.unixtime)
709              dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
710      }
711      dictReleaseIterator(di);
712  }
713  void clusterBlacklistAddNode(clusterNode *node) {
714      dictEntry *de;
715      sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);
716      clusterBlacklistCleanup();
717      if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
718          id = sdsdup(id);
719      }
720      de = dictFind(server.cluster->nodes_black_list,id);
721      dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
722      sdsfree(id);
723  }
724  int clusterBlacklistExists(char *nodeid) {
725      sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
726      int retval;
727      clusterBlacklistCleanup();
728      retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
729      sdsfree(id);
730      return retval;
731  }
732  void markNodeAsFailingIfNeeded(clusterNode *node) {
733      int failures;
734      int needed_quorum = (server.cluster->size / 2) + 1;
735      if (!nodeTimedOut(node)) return; &bsol;* We can reach it. */
736      if (nodeFailed(node)) return; &bsol;* Already FAILing. */
737      failures = clusterNodeFailureReportsCount(node);
738      if (nodeIsMaster(myself)) failures++;
739      if (failures < needed_quorum) return; &bsol;* No weak agreement from masters. */
740      serverLog(LL_NOTICE,
741          "Marking node %.40s as failing (quorum reached).", node->name);
742      node->flags &= ~CLUSTER_NODE_PFAIL;
743      node->flags |= CLUSTER_NODE_FAIL;
744      node->fail_time = mstime();
745      if (nodeIsMaster(myself)) clusterSendFail(node->name);
746      clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
747  }
748  void clearNodeFailureIfNeeded(clusterNode *node) {
749      mstime_t now = mstime();
750      serverAssert(nodeFailed(node));
751      if (nodeIsSlave(node) || node->numslots == 0) {
752          serverLog(LL_NOTICE,
753              "Clear FAIL state for node %.40s: %s is reachable again.",
754                  node->name,
755                  nodeIsSlave(node) ? "replica" : "master without slots");
756          node->flags &= ~CLUSTER_NODE_FAIL;
757          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
758      }
759      if (nodeIsMaster(node) && node->numslots > 0 &&
760          (now - node->fail_time) >
761          (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MULT))
762      {
763          serverLog(LL_NOTICE,
764              "Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after some time.",
765                  node->name);
766          node->flags &= ~CLUSTER_NODE_FAIL;
767          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
768      }
769  }
770  int clusterHandshakeInProgress(char *ip, int port, int cport) {
771      dictIterator *di;
772      dictEntry *de;
773      di = dictGetSafeIterator(server.cluster->nodes);
774      while((de = dictNext(di)) != NULL) {
775          clusterNode *node = dictGetVal(de);
776          if (!nodeInHandshake(node)) continue;
777          if (!strcasecmp(node->ip,ip) &&
778              node->port == port &&
779              node->cport == cport) break;
780      }
781      dictReleaseIterator(di);
782      return de != NULL;
783  }
784  int clusterStartHandshake(char *ip, int port, int cport) {
785      clusterNode *n;
786      char norm_ip[NET_IP_STR_LEN];
787      struct sockaddr_storage sa;
788      if (inet_pton(AF_INET,ip,
789              &(((struct sockaddr_in *)&sa)->sin_addr)))
790      {
791          sa.ss_family = AF_INET;
792      } else if (inet_pton(AF_INET6,ip,
793              &(((struct sockaddr_in6 *)&sa)->sin6_addr)))
794      {
795          sa.ss_family = AF_INET6;
796      } else {
797          errno = EINVAL;
798          return 0;
799      }
800      if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
801          errno = EINVAL;
802          return 0;
803      }
804      memset(norm_ip,0,NET_IP_STR_LEN);
805      if (sa.ss_family == AF_INET)
806          inet_ntop(AF_INET,
807              (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
808              norm_ip,NET_IP_STR_LEN);
809      else
810          inet_ntop(AF_INET6,
811              (void*)&(((struct sockaddr_in6 *)&sa)->sin6_addr),
812              norm_ip,NET_IP_STR_LEN);
813      if (clusterHandshakeInProgress(norm_ip,port,cport)) {
814          errno = EAGAIN;
815          return 0;
816      }
817      n = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
818      memcpy(n->ip,norm_ip,sizeof(n->ip));
819      n->port = port;
820      n->cport = cport;
821      clusterAddNode(n);
822      return 1;
823  }
824  void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
825      uint16_t count = ntohs(hdr->count);
826      clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
827      clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender);
828      while(count--) {
829          uint16_t flags = ntohs(g->flags);
830          clusterNode *node;
831          sds ci;
832          if (server.verbosity == LL_DEBUG) {
833              ci = representClusterNodeFlags(sdsempty(), flags);
834              serverLog(LL_DEBUG,"GOSSIP %.40s %s:%d@%d %s",
835                  g->nodename,
836                  g->ip,
837                  ntohs(g->port),
838                  ntohs(g->cport),
839                  ci);
840              sdsfree(ci);
841          }
842          node = clusterLookupNode(g->nodename);
843          if (node) {
844              if (sender && nodeIsMaster(sender) && node != myself) {
845                  if (flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) {
846                      if (clusterNodeAddFailureReport(node,sender)) {
847                          serverLog(LL_VERBOSE,
848                              "Node %.40s reported node %.40s as not reachable.",
849                              sender->name, node->name);
850                      }
851                      markNodeAsFailingIfNeeded(node);
852                  } else {
853                      if (clusterNodeDelFailureReport(node,sender)) {
854                          serverLog(LL_VERBOSE,
855                              "Node %.40s reported node %.40s is back online.",
856                              sender->name, node->name);
857                      }
858                  }
859              }
860              if (!(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
861                  node->ping_sent == 0 &&
862                  clusterNodeFailureReportsCount(node) == 0)
863              {
864                  mstime_t pongtime = ntohl(g->pong_received);
865                  pongtime *= 1000; &bsol;* Convert back to milliseconds. */
866                  if (pongtime <= (server.mstime+500) &&
867                      pongtime > node->pong_received)
868                  {
869                      node->pong_received = pongtime;
870                  }
871              }
872              if (node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) &&
873                  !(flags & CLUSTER_NODE_NOADDR) &&
874                  !(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
875                  (strcasecmp(node->ip,g->ip) ||
876                   node->port != ntohs(g->port) ||
877                   node->cport != ntohs(g->cport)))
878              {
879                  if (node->link) freeClusterLink(node->link);
880                  memcpy(node->ip,g->ip,NET_IP_STR_LEN);
881                  node->port = ntohs(g->port);
882                  node->cport = ntohs(g->cport);
883                  node->flags &= ~CLUSTER_NODE_NOADDR;
884              }
885          } else {
886              if (sender &&
887                  !(flags & CLUSTER_NODE_NOADDR) &&
888                  !clusterBlacklistExists(g->nodename))
889              {
890                  clusterNode *node;
891                  node = createClusterNode(g->nodename, flags);
892                  memcpy(node->ip,g->ip,NET_IP_STR_LEN);
893                  node->port = ntohs(g->port);
894                  node->cport = ntohs(g->cport);
895                  clusterAddNode(node);
896              }
897          }
898          g++;
899      }
900  }
901  void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
902      if (announced_ip[0] != '\0') {
903          memcpy(buf,announced_ip,NET_IP_STR_LEN);
904          buf[NET_IP_STR_LEN-1] = '\0'; &bsol;* We are not sure the input is sane. */
905      } else {
906          anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
907      }
908  }
909  int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
910                                clusterMsg *hdr)
911  {
912      char ip[NET_IP_STR_LEN] = {0};
913      int port = ntohs(hdr->port);
914      int cport = ntohs(hdr->cport);
915      if (link == node->link) return 0;
916      nodeIp2String(ip,link,hdr->myip);
917      if (node->port == port && node->cport == cport &&
918          strcmp(ip,node->ip) == 0) return 0;
919      memcpy(node->ip,ip,sizeof(ip));
920      node->port = port;
921      node->cport = cport;
922      if (node->link) freeClusterLink(node->link);
923      node->flags &= ~CLUSTER_NODE_NOADDR;
924      serverLog(LL_WARNING,"Address updated for node %.40s, now %s:%d",
925          node->name, node->ip, node->port);
926      if (nodeIsSlave(myself) && myself->slaveof == node)
927          replicationSetMaster(node->ip, node->port);
928      return 1;
929  }
930  void clusterSetNodeAsMaster(clusterNode *n) {
931      if (nodeIsMaster(n)) return;
932      if (n->slaveof) {
933          clusterNodeRemoveSlave(n->slaveof,n);
934          if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
935      }
936      n->flags &= ~CLUSTER_NODE_SLAVE;
937      n->flags |= CLUSTER_NODE_MASTER;
938      n->slaveof = NULL;
939      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
940                           CLUSTER_TODO_UPDATE_STATE);
941  }
942  void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
943      int j;
944      clusterNode *curmaster, *newmaster = NULL;
945      uint16_t dirty_slots[CLUSTER_SLOTS];
946      int dirty_slots_count = 0;
947      curmaster = nodeIsMaster(myself) ? myself : myself->slaveof;
948      if (sender == myself) {
949          serverLog(LL_WARNING,"Discarding UPDATE message about myself.");
950          return;
951      }
952      for (j = 0; j < CLUSTER_SLOTS; j++) {
953          if (bitmapTestBit(slots,j)) {
954              if (server.cluster->slots[j] == sender) continue;
955              if (server.cluster->importing_slots_from[j]) continue;
956              if (server.cluster->slots[j] == NULL ||
957                  server.cluster->slots[j]->configEpoch < senderConfigEpoch)
958              {
959                  if (server.cluster->slots[j] == myself &&
960                      countKeysInSlot(j) &&
961                      sender != myself)
962                  {
963                      dirty_slots[dirty_slots_count] = j;
964                      dirty_slots_count++;
965                  }
966                  if (server.cluster->slots[j] == curmaster)
967                      newmaster = sender;
968                  clusterDelSlot(j);
969                  clusterAddSlot(sender,j);
970                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
971                                       CLUSTER_TODO_UPDATE_STATE|
972                                       CLUSTER_TODO_FSYNC_CONFIG);
973              }
974          }
975      }
976      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
977          return;
978      if (newmaster && curmaster->numslots == 0) {
979          serverLog(LL_WARNING,
980              "Configuration change detected. Reconfiguring myself "
981              "as a replica of %.40s", sender->name);
982          clusterSetMaster(sender);
983          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
984                               CLUSTER_TODO_UPDATE_STATE|
985                               CLUSTER_TODO_FSYNC_CONFIG);
986      } else if (dirty_slots_count) {
987          for (j = 0; j < dirty_slots_count; j++)
988              delKeysInSlot(dirty_slots[j]);
989      }
990  }
991  int clusterProcessPacket(clusterLink *link) {
992      clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
993      uint32_t totlen = ntohl(hdr->totlen);
994      uint16_t type = ntohs(hdr->type);
995      mstime_t now = mstime();
996      if (type < CLUSTERMSG_TYPE_COUNT)
997          server.cluster->stats_bus_messages_received[type]++;
998      serverLog(LL_DEBUG,"--- Processing packet of type %d, %Iu bytes", WIN_PORT_FIX &bsol;* %lu -> %Iu */
999          type, (PORT_ULONG) totlen);
1000      if (totlen < 16) return 1; &bsol;* At least signature, version, totlen, count. */
1001      if (totlen > sdslen(link->rcvbuf)) return 1;
1002      if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {
1003          return 1;
1004      }
1005      uint16_t flags = ntohs(hdr->flags);
1006      uint64_t senderCurrentEpoch = 0, senderConfigEpoch = 0;
1007      clusterNode *sender;
1008      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||
1009          type == CLUSTERMSG_TYPE_MEET)
1010      {
1011          uint16_t count = ntohs(hdr->count);
1012          uint32_t explen; &bsol;* expected length of this packet */
1013          explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1014          explen += (sizeof(clusterMsgDataGossip)*count);
1015          if (totlen != explen) return 1;
1016      } else if (type == CLUSTERMSG_TYPE_FAIL) {
1017          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1018          explen += sizeof(clusterMsgDataFail);
1019          if (totlen != explen) return 1;
1020      } else if (type == CLUSTERMSG_TYPE_PUBLISH) {
1021          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1022          explen += sizeof(clusterMsgDataPublish) -
1023                  8 +
1024                  ntohl(hdr->data.publish.msg.channel_len) +
1025                  ntohl(hdr->data.publish.msg.message_len);
1026          if (totlen != explen) return 1;
1027      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST ||
1028                 type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK ||
1029                 type == CLUSTERMSG_TYPE_MFSTART)
1030      {
1031          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1032          if (totlen != explen) return 1;
1033      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1034          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1035          explen += sizeof(clusterMsgDataUpdate);
1036          if (totlen != explen) return 1;
1037      } else if (type == CLUSTERMSG_TYPE_MODULE) {
1038          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1039          explen += sizeof(clusterMsgDataPublish) -
1040                  3 + ntohl(hdr->data.module.msg.len);
1041          if (totlen != explen) return 1;
1042      }
1043      sender = clusterLookupNode(hdr->sender);
1044      if (sender) sender->data_received = now;
1045      if (sender && !nodeInHandshake(sender)) {
1046          senderCurrentEpoch = ntohu64(hdr->currentEpoch);
1047          senderConfigEpoch = ntohu64(hdr->configEpoch);
1048          if (senderCurrentEpoch > server.cluster->currentEpoch)
1049              server.cluster->currentEpoch = senderCurrentEpoch;
1050          if (senderConfigEpoch > sender->configEpoch) {
1051              sender->configEpoch = senderConfigEpoch;
1052              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1053                                   CLUSTER_TODO_FSYNC_CONFIG);
1054          }
1055          sender->repl_offset = ntohu64(hdr->offset);
1056          sender->repl_offset_time = now;
1057          if (server.cluster->mf_end &&
1058              nodeIsSlave(myself) &&
1059              myself->slaveof == sender &&
1060              hdr->mflags[0] & CLUSTERMSG_FLAG0_PAUSED &&
1061              server.cluster->mf_master_offset == 0)
1062          {
1063              server.cluster->mf_master_offset = sender->repl_offset;
1064              serverLog(LL_WARNING,
1065                  "Received replication offset for paused "
1066                  "master manual failover: %lld",
1067                  server.cluster->mf_master_offset);
1068          }
1069      }
1070      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) {
1071          serverLog(LL_DEBUG,"Ping packet received: %p", (void*)link->node);
1072          if ((type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\0') &&
1073              server.cluster_announce_ip == NULL)
1074          {
1075              char ip[NET_IP_STR_LEN];
1076              if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&
1077                  strcmp(ip,myself->ip))
1078              {
1079                  memcpy(myself->ip,ip,NET_IP_STR_LEN);
1080                  serverLog(LL_WARNING,"IP address for this node updated to %s",
1081                      myself->ip);
1082                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1083              }
1084          }
1085          if (!sender && type == CLUSTERMSG_TYPE_MEET) {
1086              clusterNode *node;
1087              node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);
1088              nodeIp2String(node->ip,link,hdr->myip);
1089              node->port = ntohs(hdr->port);
1090              node->cport = ntohs(hdr->cport);
1091              clusterAddNode(node);
1092              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1093          }
1094          if (!sender && type == CLUSTERMSG_TYPE_MEET)
1095              clusterProcessGossipSection(hdr,link);
1096          clusterSendPing(link,CLUSTERMSG_TYPE_PONG);
1097      }
1098      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||
1099          type == CLUSTERMSG_TYPE_MEET)
1100      {
1101          serverLog(LL_DEBUG,"%s packet received: %p",
1102              type == CLUSTERMSG_TYPE_PING ? "ping" : "pong",
1103              (void*)link->node);
1104          if (link->node) {
1105              if (nodeInHandshake(link->node)) {
1106                  if (sender) {
1107                      serverLog(LL_VERBOSE,
1108                          "Handshake: we already know node %.40s, "
1109                          "updating the address if needed.", sender->name);
1110                      if (nodeUpdateAddressIfNeeded(sender,link,hdr))
1111                      {
1112                          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1113                                               CLUSTER_TODO_UPDATE_STATE);
1114                      }
1115                      clusterDelNode(link->node);
1116                      return 0;
1117                  }
1118                  clusterRenameNode(link->node, hdr->sender);
1119                  serverLog(LL_DEBUG,"Handshake with node %.40s completed.",
1120                      link->node->name);
1121                  link->node->flags &= ~CLUSTER_NODE_HANDSHAKE;
1122                  link->node->flags |= flags&(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);
1123                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1124              } else if (memcmp(link->node->name,hdr->sender,
1125                          CLUSTER_NAMELEN) != 0)
1126              {
1127                  serverLog(LL_DEBUG,"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d",
1128                      link->node->name,
1129                      (int)(now-(link->node->ctime)),
1130                      link->node->flags);
1131                  link->node->flags |= CLUSTER_NODE_NOADDR;
1132                  link->node->ip[0] = '\0';
1133                  link->node->port = 0;
1134                  link->node->cport = 0;
1135                  freeClusterLink(link);
1136                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1137                  return 0;
1138              }
1139          }
1140          if (sender) {
1141              int nofailover = flags & CLUSTER_NODE_NOFAILOVER;
1142              sender->flags &= ~CLUSTER_NODE_NOFAILOVER;
1143              sender->flags |= nofailover;
1144          }
1145          if (sender && type == CLUSTERMSG_TYPE_PING &&
1146              !nodeInHandshake(sender) &&
1147              nodeUpdateAddressIfNeeded(sender,link,hdr))
1148          {
1149              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1150                                   CLUSTER_TODO_UPDATE_STATE);
1151          }
1152          if (link->node && type == CLUSTERMSG_TYPE_PONG) {
1153              link->node->pong_received = now;
1154              link->node->ping_sent = 0;
1155              if (nodeTimedOut(link->node)) {
1156                  link->node->flags &= ~CLUSTER_NODE_PFAIL;
1157                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1158                                       CLUSTER_TODO_UPDATE_STATE);
1159              } else if (nodeFailed(link->node)) {
1160                  clearNodeFailureIfNeeded(link->node);
1161              }
1162          }
1163          if (sender) {
1164              if (!memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,
1165                  sizeof(hdr->slaveof)))
1166              {
1167                  clusterSetNodeAsMaster(sender);
1168              } else {
1169                  clusterNode *master = clusterLookupNode(hdr->slaveof);
1170                  if (nodeIsMaster(sender)) {
1171                      clusterDelNodeSlots(sender);
1172                      sender->flags &= ~(CLUSTER_NODE_MASTER|
1173                                         CLUSTER_NODE_MIGRATE_TO);
1174                      sender->flags |= CLUSTER_NODE_SLAVE;
1175                      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1176                                           CLUSTER_TODO_UPDATE_STATE);
1177                  }
1178                  if (master && sender->slaveof != master) {
1179                      if (sender->slaveof)
1180                          clusterNodeRemoveSlave(sender->slaveof,sender);
1181                      clusterNodeAddSlave(master,sender);
1182                      sender->slaveof = master;
1183                      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1184                  }
1185              }
1186          }
1187          clusterNode *sender_master = NULL; &bsol;* Sender or its master if slave. */
1188          int dirty_slots = 0; &bsol;* Sender claimed slots don't match my view? */
1189          if (sender) {
1190              sender_master = nodeIsMaster(sender) ? sender : sender->slaveof;
1191              if (sender_master) {
1192                  dirty_slots = memcmp(sender_master->slots,
1193                          hdr->myslots,sizeof(hdr->myslots)) != 0;
1194              }
1195          }
1196          if (sender && nodeIsMaster(sender) && dirty_slots)
1197              clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots);
1198          if (sender && dirty_slots) {
1199              int j;
1200              for (j = 0; j < CLUSTER_SLOTS; j++) {
1201                  if (bitmapTestBit(hdr->myslots,j)) {
1202                      if (server.cluster->slots[j] == sender ||
1203                          server.cluster->slots[j] == NULL) continue;
1204                      if (server.cluster->slots[j]->configEpoch >
1205                          senderConfigEpoch)
1206                      {
1207                          serverLog(LL_VERBOSE,
1208                              "Node %.40s has old slots configuration, sending "
1209                              "an UPDATE message about %.40s",
1210                                  sender->name, server.cluster->slots[j]->name);
1211                          clusterSendUpdate(sender->link,
1212                              server.cluster->slots[j]);
1213                          break;
1214                      }
1215                  }
1216              }
1217          }
1218          if (sender &&
1219              nodeIsMaster(myself) && nodeIsMaster(sender) &&
1220              senderConfigEpoch == myself->configEpoch)
1221          {
1222              clusterHandleConfigEpochCollision(sender);
1223          }
1224          if (sender) clusterProcessGossipSection(hdr,link);
1225      } else if (type == CLUSTERMSG_TYPE_FAIL) {
1226          clusterNode *failing;
1227          if (sender) {
1228              failing = clusterLookupNode(hdr->data.fail.about.nodename);
1229              if (failing &&
1230                  !(failing->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_MYSELF)))
1231              {
1232                  serverLog(LL_NOTICE,
1233                      "FAIL message received from %.40s about %.40s",
1234                      hdr->sender, hdr->data.fail.about.nodename);
1235                  failing->flags |= CLUSTER_NODE_FAIL;
1236                  failing->fail_time = now;
1237                  failing->flags &= ~CLUSTER_NODE_PFAIL;
1238                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1239                                       CLUSTER_TODO_UPDATE_STATE);
1240              }
1241          } else {
1242              serverLog(LL_NOTICE,
1243                  "Ignoring FAIL message from unknown node %.40s about %.40s",
1244                  hdr->sender, hdr->data.fail.about.nodename);
1245          }
1246      } else if (type == CLUSTERMSG_TYPE_PUBLISH) {
1247          robj *channel, *message;
1248          uint32_t channel_len, message_len;
1249          if (dictSize(server.pubsub_channels) ||
1250             listLength(server.pubsub_patterns))
1251          {
1252              channel_len = ntohl(hdr->data.publish.msg.channel_len);
1253              message_len = ntohl(hdr->data.publish.msg.message_len);
1254              channel = createStringObject(
1255                          (char*)hdr->data.publish.msg.bulk_data,channel_len);
1256              message = createStringObject(
1257                          (char*)hdr->data.publish.msg.bulk_data+channel_len,
1258                          message_len);
1259              pubsubPublishMessage(channel,message);
1260              decrRefCount(channel);
1261              decrRefCount(message);
1262          }
1263      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) {
1264          if (!sender) return 1;  &bsol;* We don't know that node. */
1265          clusterSendFailoverAuthIfNeeded(sender,hdr);
1266      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) {
1267          if (!sender) return 1;  &bsol;* We don't know that node. */
1268          if (nodeIsMaster(sender) && sender->numslots > 0 &&
1269              senderCurrentEpoch >= server.cluster->failover_auth_epoch)
1270          {
1271              server.cluster->failover_auth_count++;
1272              clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
1273          }
1274      } else if (type == CLUSTERMSG_TYPE_MFSTART) {
1275          if (!sender || sender->slaveof != myself) return 1;
1276          resetManualFailover();
1277          server.cluster->mf_end = now + CLUSTER_MF_TIMEOUT;
1278          server.cluster->mf_slave = sender;
1279          pauseClients(now+(CLUSTER_MF_TIMEOUT*CLUSTER_MF_PAUSE_MULT));
1280          serverLog(LL_WARNING,"Manual failover requested by replica %.40s.",
1281              sender->name);
1282      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1283          clusterNode *n; &bsol;* The node the update is about. */
1284          uint64_t reportedConfigEpoch =
1285                      ntohu64(hdr->data.update.nodecfg.configEpoch);
1286          if (!sender) return 1;  &bsol;* We don't know the sender. */
1287          n = clusterLookupNode(hdr->data.update.nodecfg.nodename);
1288          if (!n) return 1;   &bsol;* We don't know the reported node. */
1289          if (n->configEpoch >= reportedConfigEpoch) return 1; &bsol;* Nothing new. */
1290          if (nodeIsSlave(n)) clusterSetNodeAsMaster(n);
1291          n->configEpoch = reportedConfigEpoch;
1292          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1293                               CLUSTER_TODO_FSYNC_CONFIG);
1294          clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,
1295              hdr->data.update.nodecfg.slots);
1296      } else if (type == CLUSTERMSG_TYPE_MODULE) {
1297          if (!sender) return 1;  &bsol;* Protect the module from unknown nodes. */
1298          uint64_t module_id = hdr->data.module.msg.module_id; &bsol;* Endian-safe ID */
1299          uint32_t len = ntohl(hdr->data.module.msg.len);
1300          uint8_t type = hdr->data.module.msg.type;
1301          unsigned char *payload = hdr->data.module.msg.bulk_data;
1302          moduleCallClusterReceivers(sender->name,module_id,type,payload,len);
1303      } else {
1304          serverLog(LL_WARNING,"Received unknown packet type: %d", type);
1305      }
1306      return 1;
1307  }
1308  void handleLinkIOError(clusterLink *link) {
1309      freeClusterLink(link);
1310  }
1311  #ifdef _WIN32
1312  void clusterWriteDone(aeEventLoop *el, int fd, void *privdata, int written) {
1313      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
1314      clusterLink *link = (clusterLink *) req->client;
1315      UNUSED(el);
1316      UNUSED(fd);
1317      if (sdslen(link->sndbuf) == written) {
1318          sdsrange(link->sndbuf, written, -1);
1319          aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
1320          serverLog(LL_DEBUG, "clusterWriteDone written %d fd %d", written, link->fd);
1321      }
1322  }
1323  void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1324      clusterLink *link = (clusterLink*) privdata;
1325      UNUSED(el);
1326      UNUSED(mask);
1327      int result = WSIOCP_SocketSend(fd,
1328          (char*) link->sndbuf,
1329          (int) (sdslen(link->sndbuf)),
1330          el,
1331          link,
1332          NULL,
1333          clusterWriteDone);
1334      if (errno == WSA_IO_PENDING)
1335          serverLog(LL_DEBUG, "WSA_IO_PENDING writing to socket fd %d", link->fd);
1336      if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
1337          serverLog(LL_WARNING, "Error writing to socket fd %d", link->fd);
1338          handleLinkIOError(link);
1339          return;
1340      }
1341  }
1342  #else
1343  void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1344      clusterLink *link = (clusterLink*) privdata;
1345      ssize_t nwritten;
1346      UNUSED(el);
1347      UNUSED(mask);
1348      nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));
1349      if (nwritten <= 0) {
1350          serverLog(LL_DEBUG,"I/O error writing to node link: %s",
1351              (nwritten == -1) ? strerror(errno) : "short write");
1352          handleLinkIOError(link);
1353          return;
1354      }
1355      sdsrange(link->sndbuf,nwritten,-1);
1356      if (sdslen(link->sndbuf) == 0)
1357          aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
1358  }
1359  #endif
1360  void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1361      char buf[sizeof(clusterMsg)];
1362      ssize_t nread;
1363      clusterMsg *hdr;
1364      clusterLink *link = (clusterLink*) privdata;
1365      unsigned int readlen, rcvbuflen;
1366      UNUSED(el);
1367      UNUSED(mask);
1368      while(1) { &bsol;* Read as long as there is data to read. */
1369          rcvbuflen = (unsigned int) sdslen(link->rcvbuf);                         WIN_PORT_FIX &bsol;* cast (unsigned int) */
1370          if (rcvbuflen < 8) {
1371              readlen = 8 - rcvbuflen;
1372          } else {
1373              hdr = (clusterMsg*) link->rcvbuf;
1374              if (rcvbuflen == 8) {
1375                  if (memcmp(hdr->sig,"RCmb",4) != 0 ||
1376                      ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)
1377                  {
1378                      serverLog(LL_WARNING,
1379                          "Bad message length or signature received "
1380                          "from Cluster bus.");
1381                      handleLinkIOError(link);
1382                      return;
1383                  }
1384              }
1385              readlen = ntohl(hdr->totlen) - rcvbuflen;
1386              if (readlen > sizeof(buf)) readlen = sizeof(buf);
1387          }
1388          nread = read(fd,buf,readlen);
1389          if (nread == -1 && errno == EAGAIN) { WIN32_ONLY(WSIOCP_QueueNextRead(fd);) return; } &bsol;* No more data ready. */
1390          if (nread <= 0) {
1391              serverLog(LL_DEBUG,"I/O error reading from node link: %s",
1392                  (nread == 0) ? "connection closed" : IF_WIN32(wsa_strerror(errno), strerror(errno)));
1393              handleLinkIOError(link);
1394              return;
1395          } else {
1396              link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);
1397              hdr = (clusterMsg*) link->rcvbuf;
1398              rcvbuflen += (unsigned int) nread;                                   WIN_PORT_FIX &bsol;* cast (unsigned int) */
1399          }
1400          if (rcvbuflen >= 8 && rcvbuflen == ntohl(hdr->totlen)) {
1401              if (clusterProcessPacket(link)) {
1402                  sdsfree(link->rcvbuf);
1403                  link->rcvbuf = sdsempty();
1404              } else {
1405                  return; &bsol;* Link no longer valid. */
1406              }
1407          }
1408      }
1409      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1410  }
1411  void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
1412      if (sdslen(link->sndbuf) == 0 && msglen != 0)
1413          aeCreateFileEvent(server.el,link->fd,AE_WRITABLE|AE_BARRIER,
1414                      clusterWriteHandler,link);
1415      link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);
1416      clusterMsg *hdr = (clusterMsg*) msg;
1417      uint16_t type = ntohs(hdr->type);
1418      if (type < CLUSTERMSG_TYPE_COUNT)
1419          server.cluster->stats_bus_messages_sent[type]++;
1420  }
1421  void clusterBroadcastMessage(void *buf, size_t len) {
1422      dictIterator *di;
1423      dictEntry *de;
1424      di = dictGetSafeIterator(server.cluster->nodes);
1425      while((de = dictNext(di)) != NULL) {
1426          clusterNode *node = dictGetVal(de);
1427          if (!node->link) continue;
1428          if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
1429              continue;
1430          clusterSendMessage(node->link,buf,len);
1431      }
1432      dictReleaseIterator(di);
1433  }
1434  void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
1435      int totlen = 0;
1436      uint64_t offset;
1437      clusterNode *master;
1438      master = (nodeIsSlave(myself) && myself->slaveof) ?
1439                myself->slaveof : myself;
1440      memset(hdr,0,sizeof(*hdr));
1441      hdr->ver = htons(CLUSTER_PROTO_VER);
1442      hdr->sig[0] = 'R';
1443      hdr->sig[1] = 'C';
1444      hdr->sig[2] = 'm';
1445      hdr->sig[3] = 'b';
1446      hdr->type = htons(type);
1447      memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);
1448      memset(hdr->myip,0,NET_IP_STR_LEN);
1449      if (server.cluster_announce_ip) {
1450          strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);
1451          hdr->myip[NET_IP_STR_LEN-1] = '\0';
1452      }
1453      int announced_port = server.cluster_announce_port ?
1454                           server.cluster_announce_port : server.port;
1455      int announced_cport = server.cluster_announce_bus_port ?
1456                            server.cluster_announce_bus_port :
1457                            (server.port + CLUSTER_PORT_INCR);
1458      memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));
1459      memset(hdr->slaveof,0,CLUSTER_NAMELEN);
1460      if (myself->slaveof != NULL)
1461          memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);
1462      hdr->port = htons(announced_port);
1463      hdr->cport = htons(announced_cport);
1464      hdr->flags = htons(myself->flags);
1465      hdr->state = server.cluster->state;
1466      hdr->currentEpoch = htonu64(server.cluster->currentEpoch);
1467      hdr->configEpoch = htonu64(master->configEpoch);
1468      if (nodeIsSlave(myself))
1469          offset = replicationGetSlaveOffset();
1470      else
1471          offset = server.master_repl_offset;
1472      hdr->offset = htonu64(offset);
1473      if (nodeIsMaster(myself) && server.cluster->mf_end)
1474          hdr->mflags[0] |= CLUSTERMSG_FLAG0_PAUSED;
1475      if (type == CLUSTERMSG_TYPE_FAIL) {
1476          totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1477          totlen += sizeof(clusterMsgDataFail);
1478      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1479          totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1480          totlen += sizeof(clusterMsgDataUpdate);
1481      }
1482      hdr->totlen = htonl(totlen);
1483  }
1484  int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {
1485      int j;
1486      for (j = 0; j < count; j++) {
1487          if (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
1488                  CLUSTER_NAMELEN) == 0) break;
1489      }
1490      return j != count;
1491  }
1492  void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
1493      clusterMsgDataGossip *gossip;
1494      gossip = &(hdr->data.ping.gossip[i]);
1495      memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
1496      gossip->ping_sent = htonl(n->ping_sent/1000);
1497      gossip->pong_received = htonl(n->pong_received/1000);
1498      memcpy(gossip->ip,n->ip,sizeof(n->ip));
1499      gossip->port = htons(n->port);
1500      gossip->cport = htons(n->cport);
1501      gossip->flags = htons(n->flags);
1502      gossip->notused1 = 0;
1503  }
1504  void clusterSendPing(clusterLink *link, int type) {
1505      unsigned char *buf;
1506      clusterMsg *hdr;
1507      int gossipcount = 0; &bsol;* Number of gossip sections added so far. */
1508      int wanted; &bsol;* Number of gossip sections we want to append if possible. */
1509      int totlen; &bsol;* Total packet length. */
1510      int freshnodes = (int) dictSize(server.cluster->nodes)-2;                    WIN_PORT_FIX &bsol;* cast (int) */
1511      wanted = floor(dictSize(server.cluster->nodes)/10);
1512      if (wanted < 3) wanted = 3;
1513      if (wanted > freshnodes) wanted = freshnodes;
1514      int pfail_wanted = server.cluster->stats_pfail_nodes;
1515      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1516      totlen += (sizeof(clusterMsgDataGossip)*(wanted+pfail_wanted));
1517      if (totlen < (int)sizeof(clusterMsg)) totlen = sizeof(clusterMsg);
1518      buf = zcalloc(totlen);
1519      hdr = (clusterMsg*) buf;
1520      if (link->node && type == CLUSTERMSG_TYPE_PING)
1521          link->node->ping_sent = mstime();
1522      clusterBuildMessageHdr(hdr,type);
1523      int maxiterations = wanted*3;
1524      while(freshnodes > 0 && gossipcount < wanted && maxiterations--) {
1525          dictEntry *de = dictGetRandomKey(server.cluster->nodes);
1526          clusterNode *this = dictGetVal(de);
1527          if (this == myself) continue;
1528          if (this->flags & CLUSTER_NODE_PFAIL) continue;
1529          if (this->flags & (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||
1530              (this->link == NULL && this->numslots == 0))
1531          {
1532              freshnodes--; &bsol;* Tecnically not correct, but saves CPU. */
1533              continue;
1534          }
1535          if (clusterNodeIsInGossipSection(hdr,gossipcount,this)) continue;
1536          clusterSetGossipEntry(hdr,gossipcount,this);
1537          freshnodes--;
1538          gossipcount++;
1539      }
1540      if (pfail_wanted) {
1541          dictIterator *di;
1542          dictEntry *de;
1543          di = dictGetSafeIterator(server.cluster->nodes);
1544          while((de = dictNext(di)) != NULL && pfail_wanted > 0) {
1545              clusterNode *node = dictGetVal(de);
1546              if (node->flags & CLUSTER_NODE_HANDSHAKE) continue;
1547              if (node->flags & CLUSTER_NODE_NOADDR) continue;
1548              if (!(node->flags & CLUSTER_NODE_PFAIL)) continue;
1549              clusterSetGossipEntry(hdr,gossipcount,node);
1550              freshnodes--;
1551              gossipcount++;
1552              pfail_wanted--;
1553          }
1554          dictReleaseIterator(di);
1555      }
1556      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1557      totlen += (sizeof(clusterMsgDataGossip)*gossipcount);
1558      hdr->count = htons(gossipcount);
1559      hdr->totlen = htonl(totlen);
1560      clusterSendMessage(link,buf,totlen);
1561      zfree(buf);
1562  }
1563  #define CLUSTER_BROADCAST_ALL 0
1564  #define CLUSTER_BROADCAST_LOCAL_SLAVES 1
1565  void clusterBroadcastPong(int target) {
1566      dictIterator *di;
1567      dictEntry *de;
1568      di = dictGetSafeIterator(server.cluster->nodes);
1569      while((de = dictNext(di)) != NULL) {
1570          clusterNode *node = dictGetVal(de);
1571          if (!node->link) continue;
1572          if (node == myself || nodeInHandshake(node)) continue;
1573          if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
1574              int local_slave =
1575                  nodeIsSlave(node) && node->slaveof &&
1576                  (node->slaveof == myself || node->slaveof == myself->slaveof);
1577              if (!local_slave) continue;
1578          }
1579          clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
1580      }
1581      dictReleaseIterator(di);
1582  }
1583  void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
1584      unsigned char buf[sizeof(clusterMsg)], *payload;
1585      clusterMsg *hdr = (clusterMsg*) buf;
1586      uint32_t totlen;
1587      uint32_t channel_len, message_len;
1588      channel = getDecodedObject(channel);
1589      message = getDecodedObject(message);
1590      channel_len = (uint32_t) sdslen(channel->ptr);                               WIN_PORT_FIX &bsol;* cast (uint32_t) */
1591      message_len = (uint32_t) sdslen(message->ptr);                               WIN_PORT_FIX &bsol;* cast (uint32_t) */
1592      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH);
1593      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1594      totlen += sizeof(clusterMsgDataPublish) - 8 + channel_len + message_len;
1595      hdr->data.publish.msg.channel_len = htonl(channel_len);
1596      hdr->data.publish.msg.message_len = htonl(message_len);
1597      hdr->totlen = htonl(totlen);
1598      if (totlen < sizeof(buf)) {
1599          payload = buf;
1600      } else {
1601          payload = zmalloc(totlen);
1602          memcpy(payload,hdr,sizeof(*hdr));
1603          hdr = (clusterMsg*) payload;
1604      }
1605      memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));
1606      memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),
1607          message->ptr,sdslen(message->ptr));
1608      if (link)
1609          clusterSendMessage(link,payload,totlen);
1610      else
1611          clusterBroadcastMessage(payload,totlen);
1612      decrRefCount(channel);
1613      decrRefCount(message);
1614      if (payload != buf) zfree(payload);
1615  }
1616  void clusterSendFail(char *nodename) {
1617      unsigned char buf[sizeof(clusterMsg)];
1618      clusterMsg *hdr = (clusterMsg*) buf;
1619      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
1620      memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
1621      clusterBroadcastMessage(buf,ntohl(hdr->totlen));
1622  }
1623  void clusterSendUpdate(clusterLink *link, clusterNode *node) {
1624      unsigned char buf[sizeof(clusterMsg)];
1625      clusterMsg *hdr = (clusterMsg*) buf;
1626      if (link == NULL) return;
1627      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);
1628      memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
1629      hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
1630      memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
1631      clusterSendMessage(link,buf,ntohl(hdr->totlen));
1632  }
1633  void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
1634                         unsigned char *payload, uint32_t len) {
1635      unsigned char buf[sizeof(clusterMsg)], *heapbuf;
1636      clusterMsg *hdr = (clusterMsg*) buf;
1637      uint32_t totlen;
1638      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MODULE);
1639      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1640      totlen += sizeof(clusterMsgModule) - 3 + len;
1641      hdr->data.module.msg.module_id = module_id; &bsol;* Already endian adjusted. */
1642      hdr->data.module.msg.type = type;
1643      hdr->data.module.msg.len = htonl(len);
1644      hdr->totlen = htonl(totlen);
1645      if (totlen < sizeof(buf)) {
1646          heapbuf = buf;
1647      } else {
1648          heapbuf = zmalloc(totlen);
1649          memcpy(heapbuf,hdr,sizeof(*hdr));
1650          hdr = (clusterMsg*) heapbuf;
1651      }
1652      memcpy(hdr->data.module.msg.bulk_data,payload,len);
1653      if (link)
1654          clusterSendMessage(link,heapbuf,totlen);
1655      else
1656          clusterBroadcastMessage(heapbuf,totlen);
1657      if (heapbuf != buf) zfree(heapbuf);
1658  }
1659  int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len) {
1660      clusterNode *node = NULL;
1661      if (target != NULL) {
1662          node = clusterLookupNode(target);
1663          if (node == NULL || node->link == NULL) return C_ERR;
1664      }
1665      clusterSendModule(target ? node->link : NULL,
1666                        module_id, type, payload, len);
1667      return C_OK;
1668  }
1669  void clusterPropagatePublish(robj *channel, robj *message) {
1670      clusterSendPublish(NULL, channel, message);
1671  }
1672  void clusterRequestFailoverAuth(void) {
1673      unsigned char buf[sizeof(clusterMsg)];
1674      clusterMsg *hdr = (clusterMsg*) buf;
1675      uint32_t totlen;
1676      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);
1677      if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;
1678      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1679      hdr->totlen = htonl(totlen);
1680      clusterBroadcastMessage(buf,totlen);
1681  }
1682  void clusterSendFailoverAuth(clusterNode *node) {
1683      unsigned char buf[sizeof(clusterMsg)];
1684      clusterMsg *hdr = (clusterMsg*) buf;
1685      uint32_t totlen;
1686      if (!node->link) return;
1687      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);
1688      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1689      hdr->totlen = htonl(totlen);
1690      clusterSendMessage(node->link,buf,totlen);
1691  }
1692  void clusterSendMFStart(clusterNode *node) {
1693      unsigned char buf[sizeof(clusterMsg)];
1694      clusterMsg *hdr = (clusterMsg*) buf;
1695      uint32_t totlen;
1696      if (!node->link) return;
1697      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART);
1698      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1699      hdr->totlen = htonl(totlen);
1700      clusterSendMessage(node->link,buf,totlen);
1701  }
1702  void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
1703      clusterNode *master = node->slaveof;
1704      uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);
1705      uint64_t requestConfigEpoch = ntohu64(request->configEpoch);
1706      unsigned char *claimed_slots = request->myslots;
1707      int force_ack = request->mflags[0] & CLUSTERMSG_FLAG0_FORCEACK;
1708      int j;
1709      if (nodeIsSlave(myself) || myself->numslots == 0) return;
1710      if (requestCurrentEpoch < server.cluster->currentEpoch) {
1711          serverLog(LL_WARNING,
1712              "Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)",
1713              node->name,
1714              (PORT_ULONGLONG) requestCurrentEpoch,
1715              (PORT_ULONGLONG) server.cluster->currentEpoch);
1716          return;
1717      }
1718      if (server.cluster->lastVoteEpoch == server.cluster->currentEpoch) {
1719          serverLog(LL_WARNING,
1720                  "Failover auth denied to %.40s: already voted for epoch %llu",
1721                  node->name,
1722                  (PORT_ULONGLONG) server.cluster->currentEpoch);
1723          return;
1724      }
1725      if (nodeIsMaster(node) || master == NULL ||
1726          (!nodeFailed(master) && !force_ack))
1727      {
1728          if (nodeIsMaster(node)) {
1729              serverLog(LL_WARNING,
1730                      "Failover auth denied to %.40s: it is a master node",
1731                      node->name);
1732          } else if (master == NULL) {
1733              serverLog(LL_WARNING,
1734                      "Failover auth denied to %.40s: I don't know its master",
1735                      node->name);
1736          } else if (!nodeFailed(master)) {
1737              serverLog(LL_WARNING,
1738                      "Failover auth denied to %.40s: its master is up",
1739                      node->name);
1740          }
1741          return;
1742      }
1743      if (mstime() - node->slaveof->voted_time < server.cluster_node_timeout * 2)
1744      {
1745          serverLog(LL_WARNING,
1746                  "Failover auth denied to %.40s: "
1747                  "can't vote about this master before %lld milliseconds",
1748                  node->name,
1749                  (PORT_LONGLONG) ((server.cluster_node_timeout*2)-
1750                               (mstime() - node->slaveof->voted_time)));
1751          return;
1752      }
1753      for (j = 0; j < CLUSTER_SLOTS; j++) {
1754          if (bitmapTestBit(claimed_slots, j) == 0) continue;
1755          if (server.cluster->slots[j] == NULL ||
1756              server.cluster->slots[j]->configEpoch <= requestConfigEpoch)
1757          {
1758              continue;
1759          }
1760          serverLog(LL_WARNING,
1761                  "Failover auth denied to %.40s: "
1762                  "slot %d epoch (%llu) > reqEpoch (%llu)",
1763                  node->name, j,
1764                  (PORT_ULONGLONG) server.cluster->slots[j]->configEpoch,
1765                  (PORT_ULONGLONG) requestConfigEpoch);
1766          return;
1767      }
1768      server.cluster->lastVoteEpoch = server.cluster->currentEpoch;
1769      node->slaveof->voted_time = mstime();
1770      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);
1771      clusterSendFailoverAuth(node);
1772      serverLog(LL_WARNING, "Failover auth granted to %.40s for epoch %llu",
1773          node->name, (PORT_ULONGLONG) server.cluster->currentEpoch);
1774  }
1775  int clusterGetSlaveRank(void) {
1776      PORT_LONGLONG myoffset;
1777      int j, rank = 0;
1778      clusterNode *master;
1779      serverAssert(nodeIsSlave(myself));
1780      master = myself->slaveof;
1781      if (master == NULL) return 0; &bsol;* Never called by slaves without master. */
1782      myoffset = replicationGetSlaveOffset();
1783      for (j = 0; j < master->numslaves; j++)
1784          if (master->slaves[j] != myself &&
1785              !nodeCantFailover(master->slaves[j]) &&
1786              master->slaves[j]->repl_offset > myoffset) rank++;
1787      return rank;
1788  }
1789  void clusterLogCantFailover(int reason) {
1790      char *msg;
1791      static time_t lastlog_time = 0;
1792      mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;
1793      if (reason == server.cluster->cant_failover_reason &&
1794          time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
1795          return;
1796      server.cluster->cant_failover_reason = reason;
1797      if (myself->slaveof &&
1798          nodeFailed(myself->slaveof) &&
1799          (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;
1800      switch(reason) {
1801      case CLUSTER_CANT_FAILOVER_DATA_AGE:
1802          msg = "Disconnected from master for longer than allowed. "
1803                "Please check the 'cluster-replica-validity-factor' configuration "
1804                "option.";
1805          break;
1806      case CLUSTER_CANT_FAILOVER_WAITING_DELAY:
1807          msg = "Waiting the delay before I can start a new failover.";
1808          break;
1809      case CLUSTER_CANT_FAILOVER_EXPIRED:
1810          msg = "Failover attempt expired.";
1811          break;
1812      case CLUSTER_CANT_FAILOVER_WAITING_VOTES:
1813          msg = "Waiting for votes, but majority still not reached.";
1814          break;
1815      default:
1816          msg = "Unknown reason code.";
1817          break;
1818      }
1819      lastlog_time = time(NULL);
1820      serverLog(LL_WARNING,"Currently unable to failover: %s", msg);
1821  }
1822  void clusterFailoverReplaceYourMaster(void) {
1823      int j;
1824      clusterNode *oldmaster = myself->slaveof;
1825      if (nodeIsMaster(myself) || oldmaster == NULL) return;
1826      clusterSetNodeAsMaster(myself);
1827      replicationUnsetMaster();
1828      for (j = 0; j < CLUSTER_SLOTS; j++) {
1829          if (clusterNodeGetSlotBit(oldmaster,j)) {
1830              clusterDelSlot(j);
1831              clusterAddSlot(myself,j);
1832          }
1833      }
1834      clusterUpdateState();
1835      clusterSaveConfigOrDie(1);
1836      clusterBroadcastPong(CLUSTER_BROADCAST_ALL);
1837      resetManualFailover();
1838  }
1839  void clusterHandleSlaveFailover(void) {
1840      mstime_t data_age;
1841      mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
1842      int needed_quorum = (server.cluster->size / 2) + 1;
1843      int manual_failover = server.cluster->mf_end != 0 &&
1844                            server.cluster->mf_can_start;
1845      mstime_t auth_timeout, auth_retry_time;
1846      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;
1847      auth_timeout = server.cluster_node_timeout*2;
1848      if (auth_timeout < 2000) auth_timeout = 2000;
1849      auth_retry_time = auth_timeout*2;
1850      if (nodeIsMaster(myself) ||
1851          myself->slaveof == NULL ||
1852          (!nodeFailed(myself->slaveof) && !manual_failover) ||
1853          (server.cluster_slave_no_failover && !manual_failover) ||
1854          myself->slaveof->numslots == 0)
1855      {
1856          server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
1857          return;
1858      }
1859      if (server.repl_state == REPL_STATE_CONNECTED) {
1860          data_age = (mstime_t)(server.unixtime - server.master->lastinteraction)
1861                     * 1000;
1862      } else {
1863          data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;
1864      }
1865      if (data_age > server.cluster_node_timeout)
1866          data_age -= server.cluster_node_timeout;
1867      if (server.cluster_slave_validity_factor &&
1868          data_age >
1869          (((mstime_t)server.repl_ping_slave_period * 1000) +
1870           (server.cluster_node_timeout * server.cluster_slave_validity_factor)))
1871      {
1872          if (!manual_failover) {
1873              clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);
1874              return;
1875          }
1876      }
1877      if (auth_age > auth_retry_time) {
1878          server.cluster->failover_auth_time = mstime() +
1879              500 + &bsol;* Fixed delay of 500 milliseconds, let FAIL msg propagate. */
1880              random() % 500; &bsol;* Random delay between 0 and 500 milliseconds. */
1881          server.cluster->failover_auth_count = 0;
1882          server.cluster->failover_auth_sent = 0;
1883          server.cluster->failover_auth_rank = clusterGetSlaveRank();
1884          server.cluster->failover_auth_time +=
1885              server.cluster->failover_auth_rank * 1000;
1886          if (server.cluster->mf_end) {
1887              server.cluster->failover_auth_time = mstime();
1888              server.cluster->failover_auth_rank = 0;
1889  	    clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
1890          }
1891          serverLog(LL_WARNING,
1892              "Start of election delayed for %lld milliseconds "
1893              "(rank #%d, offset %lld).",
1894              server.cluster->failover_auth_time - mstime(),
1895              server.cluster->failover_auth_rank,
1896              replicationGetSlaveOffset());
1897          clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
1898          return;
1899      }
1900      if (server.cluster->failover_auth_sent == 0 &&
1901          server.cluster->mf_end == 0)
1902      {
1903          int newrank = clusterGetSlaveRank();
1904          if (newrank > server.cluster->failover_auth_rank) {
1905              PORT_LONGLONG added_delay =
1906                  (newrank - server.cluster->failover_auth_rank) * 1000;
1907              server.cluster->failover_auth_time += added_delay;
1908              server.cluster->failover_auth_rank = newrank;
1909              serverLog(LL_WARNING,
1910                  "Replica rank updated to #%d, added %lld milliseconds of delay.",
1911                  newrank, added_delay);
1912          }
1913      }
1914      if (mstime() < server.cluster->failover_auth_time) {
1915          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
1916          return;
1917      }
1918      if (auth_age > auth_timeout) {
1919          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
1920          return;
1921      }
1922      if (server.cluster->failover_auth_sent == 0) {
1923          server.cluster->currentEpoch++;
1924          server.cluster->failover_auth_epoch = server.cluster->currentEpoch;
1925          serverLog(LL_WARNING,"Starting a failover election for epoch %llu.",
1926              (PORT_ULONGLONG) server.cluster->currentEpoch);
1927          clusterRequestFailoverAuth();
1928          server.cluster->failover_auth_sent = 1;
1929          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1930                               CLUSTER_TODO_UPDATE_STATE|
1931                               CLUSTER_TODO_FSYNC_CONFIG);
1932          return; &bsol;* Wait for replies. */
1933      }
1934      if (server.cluster->failover_auth_count >= needed_quorum) {
1935          serverLog(LL_WARNING,
1936              "Failover election won: I'm the new master.");
1937          if (myself->configEpoch < server.cluster->failover_auth_epoch) {
1938              myself->configEpoch = server.cluster->failover_auth_epoch;
1939              serverLog(LL_WARNING,
1940                  "configEpoch set to %llu after successful failover",
1941                  (PORT_ULONGLONG) myself->configEpoch);
1942          }
1943          clusterFailoverReplaceYourMaster();
1944      } else {
1945          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
1946      }
1947  }
1948  void clusterHandleSlaveMigration(int max_slaves) {
1949      int j, okslaves = 0;
1950      clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
1951      dictIterator *di;
1952      dictEntry *de;
1953      if (server.cluster->state != CLUSTER_OK) return;
1954      if (mymaster == NULL) return;
1955      for (j = 0; j < mymaster->numslaves; j++)
1956          if (!nodeFailed(mymaster->slaves[j]) &&
1957              !nodeTimedOut(mymaster->slaves[j])) okslaves++;
1958      if (okslaves <= server.cluster_migration_barrier) return;
1959      candidate = myself;
1960      di = dictGetSafeIterator(server.cluster->nodes);
1961      while((de = dictNext(di)) != NULL) {
1962          clusterNode *node = dictGetVal(de);
1963          int okslaves = 0, is_orphaned = 1;
1964          if (nodeIsSlave(node) || nodeFailed(node)) is_orphaned = 0;
1965          if (!(node->flags & CLUSTER_NODE_MIGRATE_TO)) is_orphaned = 0;
1966          if (nodeIsMaster(node)) okslaves = clusterCountNonFailingSlaves(node);
1967          if (okslaves > 0) is_orphaned = 0;
1968          if (is_orphaned) {
1969              if (!target && node->numslots > 0) target = node;
1970              if (!node->orphaned_time) node->orphaned_time = mstime();
1971          } else {
1972              node->orphaned_time = 0;
1973          }
1974          if (okslaves == max_slaves) {
1975              for (j = 0; j < node->numslaves; j++) {
1976                  if (memcmp(node->slaves[j]->name,
1977                             candidate->name,
1978                             CLUSTER_NAMELEN) < 0)
1979                  {
1980                      candidate = node->slaves[j];
1981                  }
1982              }
1983          }
1984      }
1985      dictReleaseIterator(di);
1986      if (target && candidate == myself &&
1987          (mstime()-target->orphaned_time) > CLUSTER_SLAVE_MIGRATION_DELAY &&
1988         !(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
1989      {
1990          serverLog(LL_WARNING,"Migrating to orphaned master %.40s",
1991              target->name);
1992          clusterSetMaster(target);
1993      }
1994  }
1995  void resetManualFailover(void) {
1996      if (server.cluster->mf_end && clientsArePaused()) {
1997          server.clients_pause_end_time = 0;
1998          clientsArePaused(); &bsol;* Just use the side effect of the function. */
1999      }
2000      server.cluster->mf_end = 0; &bsol;* No manual failover in progress. */
2001      server.cluster->mf_can_start = 0;
2002      server.cluster->mf_slave = NULL;
2003      server.cluster->mf_master_offset = 0;
2004  }
2005  void manualFailoverCheckTimeout(void) {
2006      if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
2007          serverLog(LL_WARNING,"Manual failover timed out.");
2008          resetManualFailover();
2009      }
2010  }
2011  void clusterHandleManualFailover(void) {
2012      if (server.cluster->mf_end == 0) return;
2013      if (server.cluster->mf_can_start) return;
2014      if (server.cluster->mf_master_offset == 0) return; &bsol;* Wait for offset... */
2015      if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
2016          server.cluster->mf_can_start = 1;
2017          serverLog(LL_WARNING,
2018              "All master replication stream processed, "
2019              "manual failover can start.");
2020      }
2021  }
2022  void clusterCron(void) {
2023      dictIterator *di;
2024      dictEntry *de;
2025      int update_state = 0;
2026      int orphaned_masters; &bsol;* How many masters there are without ok slaves. */
2027      int max_slaves; &bsol;* Max number of ok slaves for a single master. */
2028      int this_slaves; &bsol;* Number of ok slaves for our master (if we are slave). */
2029      mstime_t min_pong = 0, now = mstime();
2030      clusterNode *min_pong_node = NULL;
2031      static PORT_ULONGLONG iteration = 0;
2032      mstime_t handshake_timeout;
2033      iteration++; &bsol;* Number of times this function was called so far. */
2034      {
2035          static char *prev_ip = NULL;
2036          char *curr_ip = server.cluster_announce_ip;
2037          int changed = 0;
2038          if (prev_ip == NULL && curr_ip != NULL) changed = 1;
2039          else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
2040          else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;
2041          if (changed) {
2042              if (prev_ip) zfree(prev_ip);
2043              prev_ip = curr_ip;
2044              if (curr_ip) {
2045                  prev_ip = zstrdup(prev_ip);
2046                  strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
2047                  myself->ip[NET_IP_STR_LEN-1] = '\0';
2048              } else {
2049                  myself->ip[0] = '\0'; &bsol;* Force autodetection. */
2050              }
2051          }
2052      }
2053      handshake_timeout = server.cluster_node_timeout;
2054      if (handshake_timeout < 1000) handshake_timeout = 1000;
2055      clusterUpdateMyselfFlags();
2056      di = dictGetSafeIterator(server.cluster->nodes);
2057      server.cluster->stats_pfail_nodes = 0;
2058      while((de = dictNext(di)) != NULL) {
2059          clusterNode *node = dictGetVal(de);
2060          if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) continue;
2061          if (node->flags & CLUSTER_NODE_PFAIL)
2062              server.cluster->stats_pfail_nodes++;
2063          if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
2064              clusterDelNode(node);
2065              continue;
2066          }
2067          if (node->link == NULL) {
2068              int fd;
2069              mstime_t old_ping_sent;
2070              clusterLink *link;
2071              fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,
2072                  node->cport, NET_FIRST_BIND_ADDR);
2073              if (fd == -1) {
2074                  if (node->ping_sent == 0) node->ping_sent = mstime();
2075                  serverLog(LL_DEBUG, "Unable to connect to "
2076                      "Cluster Node [%s]:%d -> %s", node->ip,
2077                      node->cport, server.neterr);
2078                  continue;
2079              }
2080              link = createClusterLink(node);
2081              link->fd = fd;
2082              node->link = link;
2083              aeCreateFileEvent(server.el,link->fd,AE_READABLE,
2084                      clusterReadHandler,link);
2085              old_ping_sent = node->ping_sent;
2086              clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
2087                      CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
2088              if (old_ping_sent) {
2089                  node->ping_sent = old_ping_sent;
2090              }
2091              node->flags &= ~CLUSTER_NODE_MEET;
2092              serverLog(LL_DEBUG,"Connecting with Node %.40s at %s:%d",
2093                      node->name, node->ip, node->cport);
2094          }
2095      }
2096      dictReleaseIterator(di);
2097      if (!(iteration % 10)) {
2098          int j;
2099          for (j = 0; j < 5; j++) {
2100              de = dictGetRandomKey(server.cluster->nodes);
2101              clusterNode *this = dictGetVal(de);
2102              if (this->link == NULL || this->ping_sent != 0) continue;
2103              if (this->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
2104                  continue;
2105              if (min_pong_node == NULL || min_pong > this->pong_received) {
2106                  min_pong_node = this;
2107                  min_pong = this->pong_received;
2108              }
2109          }
2110          if (min_pong_node) {
2111              serverLog(LL_DEBUG,"Pinging node %.40s", min_pong_node->name);
2112              clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);
2113          }
2114      }
2115      orphaned_masters = 0;
2116      max_slaves = 0;
2117      this_slaves = 0;
2118      di = dictGetSafeIterator(server.cluster->nodes);
2119      while((de = dictNext(di)) != NULL) {
2120          clusterNode *node = dictGetVal(de);
2121          now = mstime(); &bsol;* Use an updated time at every iteration. */
2122          if (node->flags &
2123              (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
2124                  continue;
2125          if (nodeIsSlave(myself) && nodeIsMaster(node) && !nodeFailed(node)) {
2126              int okslaves = clusterCountNonFailingSlaves(node);
2127              if (okslaves == 0 && node->numslots > 0 &&
2128                  node->flags & CLUSTER_NODE_MIGRATE_TO)
2129              {
2130                  orphaned_masters++;
2131              }
2132              if (okslaves > max_slaves) max_slaves = okslaves;
2133              if (nodeIsSlave(myself) && myself->slaveof == node)
2134                  this_slaves = okslaves;
2135          }
2136          if (node->link && &bsol;* is connected */
2137              now - node->link->ctime >
2138              server.cluster_node_timeout && &bsol;* was not already reconnected */
2139              node->ping_sent && &bsol;* we already sent a ping */
2140              node->pong_received < node->ping_sent && &bsol;* still waiting pong */
2141              now - node->ping_sent > server.cluster_node_timeout/2 &&
2142              now - node->data_received > server.cluster_node_timeout/2)
2143          {
2144              freeClusterLink(node->link);
2145          }
2146          if (node->link &&
2147              node->ping_sent == 0 &&
2148              (now - node->pong_received) > server.cluster_node_timeout/2)
2149          {
2150              clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
2151              continue;
2152          }
2153          if (server.cluster->mf_end &&
2154              nodeIsMaster(myself) &&
2155              server.cluster->mf_slave == node &&
2156              node->link)
2157          {
2158              clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
2159              continue;
2160          }
2161          if (node->ping_sent == 0) continue;
2162          mstime_t delay = now - node->ping_sent;
2163          mstime_t data_delay = now - node->data_received;
2164          if (data_delay < delay) delay = data_delay;
2165          if (delay > server.cluster_node_timeout) {
2166              if (!(node->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) {
2167                  serverLog(LL_DEBUG,"*** NODE %.40s possibly failing",
2168                      node->name);
2169                  node->flags |= CLUSTER_NODE_PFAIL;
2170                  update_state = 1;
2171              }
2172          }
2173      }
2174      dictReleaseIterator(di);
2175      if (nodeIsSlave(myself) &&
2176          server.masterhost == NULL &&
2177          myself->slaveof &&
2178          nodeHasAddr(myself->slaveof))
2179      {
2180          replicationSetMaster(myself->slaveof->ip, myself->slaveof->port);
2181      }
2182      manualFailoverCheckTimeout();
2183      if (nodeIsSlave(myself)) {
2184          clusterHandleManualFailover();
2185          if (!(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
2186              clusterHandleSlaveFailover();
2187          if (orphaned_masters && max_slaves >= 2 && this_slaves == max_slaves)
2188              clusterHandleSlaveMigration(max_slaves);
2189      }
2190      if (update_state || server.cluster->state == CLUSTER_FAIL)
2191          clusterUpdateState();
2192  }
2193  void clusterBeforeSleep(void) {
2194      if (server.cluster->todo_before_sleep & CLUSTER_TODO_HANDLE_FAILOVER)
2195          clusterHandleSlaveFailover();
2196      if (server.cluster->todo_before_sleep & CLUSTER_TODO_UPDATE_STATE)
2197          clusterUpdateState();
2198      if (server.cluster->todo_before_sleep & CLUSTER_TODO_SAVE_CONFIG) {
2199          int fsync = server.cluster->todo_before_sleep &
2200                      CLUSTER_TODO_FSYNC_CONFIG;
2201          clusterSaveConfigOrDie(fsync);
2202      }
2203      server.cluster->todo_before_sleep = 0;
2204  }
2205  void clusterDoBeforeSleep(int flags) {
2206      server.cluster->todo_before_sleep |= flags;
2207  }
2208  int bitmapTestBit(unsigned char *bitmap, int pos) {
2209      off_t byte = pos/8;
2210      int bit = pos&7;
2211      return (bitmap[byte] & (1<<bit)) != 0;
2212  }
2213  void bitmapSetBit(unsigned char *bitmap, int pos) {
2214      off_t byte = pos/8;
2215      int bit = pos&7;
2216      bitmap[byte] |= 1<<bit;
2217  }
2218  void bitmapClearBit(unsigned char *bitmap, int pos) {
2219      off_t byte = pos/8;
2220      int bit = pos&7;
2221      bitmap[byte] &= ~(1<<bit);
2222  }
2223  int clusterMastersHaveSlaves(void) {
2224      dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
2225      dictEntry *de;
2226      int slaves = 0;
2227      while((de = dictNext(di)) != NULL) {
2228          clusterNode *node = dictGetVal(de);
2229          if (nodeIsSlave(node)) continue;
2230          slaves += node->numslaves;
2231      }
2232      dictReleaseIterator(di);
2233      return slaves != 0;
2234  }
2235  int clusterNodeSetSlotBit(clusterNode *n, int slot) {
2236      int old = bitmapTestBit(n->slots,slot);
2237      bitmapSetBit(n->slots,slot);
2238      if (!old) {
2239          n->numslots++;
2240          if (n->numslots == 1 && clusterMastersHaveSlaves())
2241              n->flags |= CLUSTER_NODE_MIGRATE_TO;
2242      }
2243      return old;
2244  }
2245  int clusterNodeClearSlotBit(clusterNode *n, int slot) {
2246      int old = bitmapTestBit(n->slots,slot);
2247      bitmapClearBit(n->slots,slot);
2248      if (old) n->numslots--;
2249      return old;
2250  }
2251  int clusterNodeGetSlotBit(clusterNode *n, int slot) {
2252      return bitmapTestBit(n->slots,slot);
2253  }
2254  int clusterAddSlot(clusterNode *n, int slot) {
2255      if (server.cluster->slots[slot]) return C_ERR;
2256      clusterNodeSetSlotBit(n,slot);
2257      server.cluster->slots[slot] = n;
2258      return C_OK;
2259  }
2260  int clusterDelSlot(int slot) {
2261      clusterNode *n = server.cluster->slots[slot];
2262      if (!n) return C_ERR;
2263      serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
2264      server.cluster->slots[slot] = NULL;
2265      return C_OK;
2266  }
2267  int clusterDelNodeSlots(clusterNode *node) {
2268      int deleted = 0, j;
2269      for (j = 0; j < CLUSTER_SLOTS; j++) {
2270          if (clusterNodeGetSlotBit(node,j)) {
2271              clusterDelSlot(j);
2272              deleted++;
2273          }
2274      }
2275      return deleted;
2276  }
2277  void clusterCloseAllSlots(void) {
2278      memset(server.cluster->migrating_slots_to,0,
2279          sizeof(server.cluster->migrating_slots_to));
2280      memset(server.cluster->importing_slots_from,0,
2281          sizeof(server.cluster->importing_slots_from));
2282  }
2283  #define CLUSTER_MAX_REJOIN_DELAY 5000
2284  #define CLUSTER_MIN_REJOIN_DELAY 500
2285  #define CLUSTER_WRITABLE_DELAY 2000
2286  void clusterUpdateState(void) {
2287      int j, new_state;
2288      int reachable_masters = 0;
2289      static mstime_t among_minority_time;
2290      static mstime_t first_call_time = 0;
2291      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_UPDATE_STATE;
2292      if (first_call_time == 0) first_call_time = mstime();
2293      if (nodeIsMaster(myself) &&
2294          server.cluster->state == CLUSTER_FAIL &&
2295          mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;
2296      new_state = CLUSTER_OK;
2297      if (server.cluster_require_full_coverage) {
2298          for (j = 0; j < CLUSTER_SLOTS; j++) {
2299              if (server.cluster->slots[j] == NULL ||
2300                  server.cluster->slots[j]->flags & (CLUSTER_NODE_FAIL))
2301              {
2302                  new_state = CLUSTER_FAIL;
2303                  break;
2304              }
2305          }
2306      }
2307      {
2308          dictIterator *di;
2309          dictEntry *de;
2310          server.cluster->size = 0;
2311          di = dictGetSafeIterator(server.cluster->nodes);
2312          while((de = dictNext(di)) != NULL) {
2313              clusterNode *node = dictGetVal(de);
2314              if (nodeIsMaster(node) && node->numslots) {
2315                  server.cluster->size++;
2316                  if ((node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) == 0)
2317                      reachable_masters++;
2318              }
2319          }
2320          dictReleaseIterator(di);
2321      }
2322      {
2323          int needed_quorum = (server.cluster->size / 2) + 1;
2324          if (reachable_masters < needed_quorum) {
2325              new_state = CLUSTER_FAIL;
2326              among_minority_time = mstime();
2327          }
2328      }
2329      if (new_state != server.cluster->state) {
2330          mstime_t rejoin_delay = server.cluster_node_timeout;
2331          if (rejoin_delay > CLUSTER_MAX_REJOIN_DELAY)
2332              rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;
2333          if (rejoin_delay < CLUSTER_MIN_REJOIN_DELAY)
2334              rejoin_delay = CLUSTER_MIN_REJOIN_DELAY;
2335          if (new_state == CLUSTER_OK &&
2336              nodeIsMaster(myself) &&
2337              mstime() - among_minority_time < rejoin_delay)
2338          {
2339              return;
2340          }
2341          serverLog(LL_WARNING,"Cluster state changed: %s",
2342              new_state == CLUSTER_OK ? "ok" : "fail");
2343          server.cluster->state = new_state;
2344      }
2345  }
2346  int verifyClusterConfigWithData(void) {
2347      int j;
2348      int update_config = 0;
2349      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
2350          return C_OK;
2351      if (nodeIsSlave(myself)) return C_OK;
2352      for (j = 1; j < server.dbnum; j++) {
2353          if (dictSize(server.db[j].dict)) return C_ERR;
2354      }
2355      for (j = 0; j < CLUSTER_SLOTS; j++) {
2356          if (!countKeysInSlot(j)) continue; &bsol;* No keys in this slot. */
2357          if (server.cluster->slots[j] == myself ||
2358              server.cluster->importing_slots_from[j] != NULL) continue;
2359          update_config++;
2360          if (server.cluster->slots[j] == NULL) {
2361              serverLog(LL_WARNING, "I have keys for unassigned slot %d. "
2362                                      "Taking responsibility for it.",j);
2363              clusterAddSlot(myself,j);
2364          } else {
2365              serverLog(LL_WARNING, "I have keys for slot %d, but the slot is "
2366                                      "assigned to another node. "
2367                                      "Setting it to importing state.",j);
2368              server.cluster->importing_slots_from[j] = server.cluster->slots[j];
2369          }
2370      }
2371      if (update_config) clusterSaveConfigOrDie(1);
2372      return C_OK;
2373  }
2374  void clusterSetMaster(clusterNode *n) {
2375      serverAssert(n != myself);
2376      serverAssert(myself->numslots == 0);
2377      if (nodeIsMaster(myself)) {
2378          myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
2379          myself->flags |= CLUSTER_NODE_SLAVE;
2380          clusterCloseAllSlots();
2381      } else {
2382          if (myself->slaveof)
2383              clusterNodeRemoveSlave(myself->slaveof,myself);
2384      }
2385      myself->slaveof = n;
2386      clusterNodeAddSlave(n,myself);
2387      replicationSetMaster(n->ip, n->port);
2388      resetManualFailover();
2389  }
2390  struct redisNodeFlags {
2391      uint16_t flag;
2392      char *name;
2393  };
2394  static struct redisNodeFlags redisNodeFlagsTable[] = {
2395      {CLUSTER_NODE_MYSELF,       "myself,"},
2396      {CLUSTER_NODE_MASTER,       "master,"},
2397      {CLUSTER_NODE_SLAVE,        "slave,"},
2398      {CLUSTER_NODE_PFAIL,        "fail?,"},
2399      {CLUSTER_NODE_FAIL,         "fail,"},
2400      {CLUSTER_NODE_HANDSHAKE,    "handshake,"},
2401      {CLUSTER_NODE_NOADDR,       "noaddr,"},
2402      {CLUSTER_NODE_NOFAILOVER,   "nofailover,"}
2403  };
2404  sds representClusterNodeFlags(sds ci, uint16_t flags) {
2405      size_t orig_len = sdslen(ci);
2406      int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
2407      for (i = 0; i < size; i++) {
2408          struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
2409          if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
2410      }
2411      if (sdslen(ci) == orig_len) ci = sdscat(ci,"noflags,");
2412      sdsIncrLen(ci,-1); &bsol;* Remove trailing comma. */
2413      return ci;
2414  }
2415  sds clusterGenNodeDescription(clusterNode *node) {
2416      int j, start;
2417      sds ci;
2418      ci = sdscatprintf(sdsempty(),"%.40s %s:%d@%d ",
2419          node->name,
2420          node->ip,
2421          node->port,
2422          node->cport);
2423      ci = representClusterNodeFlags(ci, node->flags);
2424      if (node->slaveof)
2425          ci = sdscatprintf(ci," %.40s ",node->slaveof->name);
2426      else
2427          ci = sdscatlen(ci," - ",3);
2428      ci = sdscatprintf(ci,"%lld %lld %llu %s",
2429          (PORT_LONGLONG) node->ping_sent,
2430          (PORT_LONGLONG) node->pong_received,
2431          (PORT_ULONGLONG) node->configEpoch,
2432          (node->link || node->flags & CLUSTER_NODE_MYSELF) ?
2433                      "connected" : "disconnected");
2434      start = -1;
2435      for (j = 0; j < CLUSTER_SLOTS; j++) {
2436          int bit;
2437          if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
2438              if (start == -1) start = j;
2439          }
2440          if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
2441              if (bit && j == CLUSTER_SLOTS-1) j++;
2442              if (start == j-1) {
2443                  ci = sdscatprintf(ci," %d",start);
2444              } else {
2445                  ci = sdscatprintf(ci," %d-%d",start,j-1);
2446              }
2447              start = -1;
2448          }
2449      }
2450      if (node->flags & CLUSTER_NODE_MYSELF) {
2451          for (j = 0; j < CLUSTER_SLOTS; j++) {
2452              if (server.cluster->migrating_slots_to[j]) {
2453                  ci = sdscatprintf(ci," [%d->-%.40s]",j,
2454                      server.cluster->migrating_slots_to[j]->name);
2455              } else if (server.cluster->importing_slots_from[j]) {
2456                  ci = sdscatprintf(ci," [%d-<-%.40s]",j,
2457                      server.cluster->importing_slots_from[j]->name);
2458              }
2459          }
2460      }
2461      return ci;
2462  }
2463  sds clusterGenNodesDescription(int filter) {
2464      sds ci = sdsempty(), ni;
2465      dictIterator *di;
2466      dictEntry *de;
2467      di = dictGetSafeIterator(server.cluster->nodes);
2468      while((de = dictNext(di)) != NULL) {
2469          clusterNode *node = dictGetVal(de);
2470          if (node->flags & filter) continue;
2471          ni = clusterGenNodeDescription(node);
2472          ci = sdscatsds(ci,ni);
2473          sdsfree(ni);
2474          ci = sdscatlen(ci,"\n",1);
2475      }
2476      dictReleaseIterator(di);
2477      return ci;
2478  }
2479  const char *clusterGetMessageTypeString(int type) {
2480      switch(type) {
2481      case CLUSTERMSG_TYPE_PING: return "ping";
2482      case CLUSTERMSG_TYPE_PONG: return "pong";
2483      case CLUSTERMSG_TYPE_MEET: return "meet";
2484      case CLUSTERMSG_TYPE_FAIL: return "fail";
2485      case CLUSTERMSG_TYPE_PUBLISH: return "publish";
2486      case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return "auth-req";
2487      case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return "auth-ack";
2488      case CLUSTERMSG_TYPE_UPDATE: return "update";
2489      case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
2490      case CLUSTERMSG_TYPE_MODULE: return "module";
2491      }
2492      return "unknown";
2493  }
2494  int getSlotOrReply(client *c, robj *o) {
2495      PORT_LONGLONG slot;
2496      if (getLongLongFromObject(o,&slot) != C_OK ||
2497          slot < 0 || slot >= CLUSTER_SLOTS)
2498      {
2499          addReplyError(c,"Invalid or out of range slot");
2500          return -1;
2501      }
2502      return (int) slot;
2503  }
2504  void clusterReplyMultiBulkSlots(client *c) {
2505      int num_masters = 0;
2506      void *slot_replylen = addDeferredMultiBulkLength(c);
2507      dictEntry *de;
2508      dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
2509      while((de = dictNext(di)) != NULL) {
2510          clusterNode *node = dictGetVal(de);
2511          int j = 0, start = -1;
2512          int i, nested_elements = 0;
2513          if (!nodeIsMaster(node) || node->numslots == 0) continue;
2514          for(i = 0; i < node->numslaves; i++) {
2515              if (nodeFailed(node->slaves[i])) continue;
2516              nested_elements++;
2517          }
2518          for (j = 0; j < CLUSTER_SLOTS; j++) {
2519              int bit, i;
2520              if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
2521                  if (start == -1) start = j;
2522              }
2523              if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
2524                  addReplyMultiBulkLen(c, nested_elements + 3); &bsol;* slots (2) + master addr (1). */
2525                  if (bit && j == CLUSTER_SLOTS-1) j++;
2526                  if (start == j-1) {
2527                      addReplyLongLong(c, start); &bsol;* only one slot; low==high */
2528                      addReplyLongLong(c, start);
2529                  } else {
2530                      addReplyLongLong(c, start); &bsol;* low */
2531                      addReplyLongLong(c, j-1);   &bsol;* high */
2532                  }
2533                  start = -1;
2534                  addReplyMultiBulkLen(c, 3);
2535                  addReplyBulkCString(c, node->ip);
2536                  addReplyLongLong(c, node->port);
2537                  addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
2538                  for (i = 0; i < node->numslaves; i++) {
2539                      if (nodeFailed(node->slaves[i])) continue;
2540                      addReplyMultiBulkLen(c, 3);
2541                      addReplyBulkCString(c, node->slaves[i]->ip);
2542                      addReplyLongLong(c, node->slaves[i]->port);
2543                      addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN);
2544                  }
2545                  num_masters++;
2546              }
2547          }
2548      }
2549      dictReleaseIterator(di);
2550      setDeferredMultiBulkLength(c, slot_replylen, num_masters);
2551  }
2552  void clusterCommand(client *c) {
2553      if (server.cluster_enabled == 0) {
2554          addReplyError(c,"This instance has cluster support disabled");
2555          return;
2556      }
2557      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
2558          const char *help[] = {
2559  "ADDSLOTS <slot> [slot ...] -- Assign slots to current node.",
2560  "BUMPEPOCH -- Advance the cluster config epoch.",
2561  "COUNT-failure-reports <node-id> -- Return number of failure reports for <node-id>.",
2562  "COUNTKEYSINSLOT <slot> - Return the number of keys in <slot>.",
2563  "DELSLOTS <slot> [slot ...] -- Delete slots information from current node.",
2564  "FAILOVER [force|takeover] -- Promote current replica node to being a master.",
2565  "FORGET <node-id> -- Remove a node from the cluster.",
2566  "GETKEYSINSLOT <slot> <count> -- Return key names stored by current node in a slot.",
2567  "FLUSHSLOTS -- Delete current node own slots information.",
2568  "INFO - Return onformation about the cluster.",
2569  "KEYSLOT <key> -- Return the hash slot for <key>.",
2570  "MEET <ip> <port> [bus-port] -- Connect nodes into a working cluster.",
2571  "MYID -- Return the node id.",
2572  "NODES -- Return cluster configuration seen by node. Output format:",
2573  "    <id> <ip:port> <flags> <master> <pings> <pongs> <epoch> <link> <slot> ... <slot>",
2574  "REPLICATE <node-id> -- Configure current node as replica to <node-id>.",
2575  "RESET [hard|soft] -- Reset current node (default: soft).",
2576  "SET-config-epoch <epoch> - Set config epoch of current node.",
2577  "SETSLOT <slot> (importing|migrating|stable|node <node-id>) -- Set slot state.",
2578  "REPLICAS <node-id> -- Return <node-id> replicas.",
2579  "SLOTS -- Return information about slots range mappings. Each range is made of:",
2580  "    start, end, master and replicas IP addresses, ports and ids",
2581  NULL
2582          };
2583          addReplyHelp(c, help);
2584      } else if (!strcasecmp(c->argv[1]->ptr,"meet") && (c->argc == 4 || c->argc == 5)) {
2585          PORT_LONGLONG port, cport;
2586          if (getLongLongFromObject(c->argv[3], &port) != C_OK) {
2587              addReplyErrorFormat(c,"Invalid TCP base port specified: %s",
2588                                  (char*)c->argv[3]->ptr);
2589              return;
2590          }
2591          if (c->argc == 5) {
2592              if (getLongLongFromObject(c->argv[4], &cport) != C_OK) {
2593                  addReplyErrorFormat(c,"Invalid TCP bus port specified: %s",
2594                                      (char*)c->argv[4]->ptr);
2595                  return;
2596              }
2597          } else {
2598              cport = port + CLUSTER_PORT_INCR;
2599          }
2600          if (clusterStartHandshake(c->argv[2]->ptr, (int) port, (int) cport) == 0 && WIN_PORT_FIX &bsol;* cast (int) */
2601              errno == EINVAL)
2602          {
2603              addReplyErrorFormat(c,"Invalid node address specified: %s:%s",
2604                              (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr);
2605          } else {
2606              addReply(c,shared.ok);
2607          }
2608      } else if (!strcasecmp(c->argv[1]->ptr,"nodes") && c->argc == 2) {
2609          robj *o;
2610          sds ci = clusterGenNodesDescription(0);
2611          o = createObject(OBJ_STRING,ci);
2612          addReplyBulk(c,o);
2613          decrRefCount(o);
2614      } else if (!strcasecmp(c->argv[1]->ptr,"myid") && c->argc == 2) {
2615          addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN);
2616      } else if (!strcasecmp(c->argv[1]->ptr,"slots") && c->argc == 2) {
2617          clusterReplyMultiBulkSlots(c);
2618      } else if (!strcasecmp(c->argv[1]->ptr,"flushslots") && c->argc == 2) {
2619          if (dictSize(server.db[0].dict) != 0) {
2620              addReplyError(c,"DB must be empty to perform CLUSTER FLUSHSLOTS.");
2621              return;
2622          }
2623          clusterDelNodeSlots(myself);
2624          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2625          addReply(c,shared.ok);
2626      } else if ((!strcasecmp(c->argv[1]->ptr,"addslots") ||
2627                 !strcasecmp(c->argv[1]->ptr,"delslots")) && c->argc >= 3)
2628      {
2629          int j, slot;
2630          unsigned char *slots = zmalloc(CLUSTER_SLOTS);
2631          int del = !strcasecmp(c->argv[1]->ptr,"delslots");
2632          memset(slots,0,CLUSTER_SLOTS);
2633          for (j = 2; j < c->argc; j++) {
2634              if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {
2635                  zfree(slots);
2636                  return;
2637              }
2638              if (del && server.cluster->slots[slot] == NULL) {
2639                  addReplyErrorFormat(c,"Slot %d is already unassigned", slot);
2640                  zfree(slots);
2641                  return;
2642              } else if (!del && server.cluster->slots[slot]) {
2643                  addReplyErrorFormat(c,"Slot %d is already busy", slot);
2644                  zfree(slots);
2645                  return;
2646              }
2647              if (slots[slot]++ == 1) {
2648                  addReplyErrorFormat(c,"Slot %d specified multiple times",
2649                      (int)slot);
2650                  zfree(slots);
2651                  return;
2652              }
2653          }
2654          for (j = 0; j < CLUSTER_SLOTS; j++) {
2655              if (slots[j]) {
2656                  int retval;
2657                  if (server.cluster->importing_slots_from[j])
2658                      server.cluster->importing_slots_from[j] = NULL;
2659                  retval = del ? clusterDelSlot(j) :
2660                                 clusterAddSlot(myself,j);
2661                  serverAssertWithInfo(c,NULL,retval == C_OK);
2662              }
2663          }
2664          zfree(slots);
2665          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2666          addReply(c,shared.ok);
2667      } else if (!strcasecmp(c->argv[1]->ptr,"setslot") && c->argc >= 4) {
2668          int slot;
2669          clusterNode *n;
2670          if (nodeIsSlave(myself)) {
2671              addReplyError(c,"Please use SETSLOT only with masters.");
2672              return;
2673          }
2674          if ((slot = getSlotOrReply(c,c->argv[2])) == -1) return;
2675          if (!strcasecmp(c->argv[3]->ptr,"migrating") && c->argc == 5) {
2676              if (server.cluster->slots[slot] != myself) {
2677                  addReplyErrorFormat(c,"I'm not the owner of hash slot %u",slot);
2678                  return;
2679              }
2680              if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {
2681                  addReplyErrorFormat(c,"I don't know about node %s",
2682                      (char*)c->argv[4]->ptr);
2683                  return;
2684              }
2685              server.cluster->migrating_slots_to[slot] = n;
2686          } else if (!strcasecmp(c->argv[3]->ptr,"importing") && c->argc == 5) {
2687              if (server.cluster->slots[slot] == myself) {
2688                  addReplyErrorFormat(c,
2689                      "I'm already the owner of hash slot %u",slot);
2690                  return;
2691              }
2692              if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {
2693                  addReplyErrorFormat(c,"I don't know about node %s",
2694                      (char*)c->argv[4]->ptr);
2695                  return;
2696              }
2697              server.cluster->importing_slots_from[slot] = n;
2698          } else if (!strcasecmp(c->argv[3]->ptr,"stable") && c->argc == 4) {
2699              server.cluster->importing_slots_from[slot] = NULL;
2700              server.cluster->migrating_slots_to[slot] = NULL;
2701          } else if (!strcasecmp(c->argv[3]->ptr,"node") && c->argc == 5) {
2702              clusterNode *n = clusterLookupNode(c->argv[4]->ptr);
2703              if (!n) {
2704                  addReplyErrorFormat(c,"Unknown node %s",
2705                      (char*)c->argv[4]->ptr);
2706                  return;
2707              }
2708              if (server.cluster->slots[slot] == myself && n != myself) {
2709                  if (countKeysInSlot(slot) != 0) {
2710                      addReplyErrorFormat(c,
2711                          "Can't assign hashslot %d to a different node "
2712                          "while I still hold keys for this hash slot.", slot);
2713                      return;
2714                  }
2715              }
2716              if (countKeysInSlot(slot) == 0 &&
2717                  server.cluster->migrating_slots_to[slot])
2718                  server.cluster->migrating_slots_to[slot] = NULL;
2719              if (n == myself &&
2720                  server.cluster->importing_slots_from[slot])
2721              {
2722                  if (clusterBumpConfigEpochWithoutConsensus() == C_OK) {
2723                      serverLog(LL_WARNING,
2724                          "configEpoch updated after importing slot %d", slot);
2725                  }
2726                  server.cluster->importing_slots_from[slot] = NULL;
2727              }
2728              clusterDelSlot(slot);
2729              clusterAddSlot(n,slot);
2730          } else {
2731              addReplyError(c,
2732                  "Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP");
2733              return;
2734          }
2735          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);
2736          addReply(c,shared.ok);
2737      } else if (!strcasecmp(c->argv[1]->ptr,"bumpepoch") && c->argc == 2) {
2738          int retval = clusterBumpConfigEpochWithoutConsensus();
2739          sds reply = sdscatprintf(sdsempty(),"+%s %llu\r\n",
2740                  (retval == C_OK) ? "BUMPED" : "STILL",
2741                  (PORT_ULONGLONG) myself->configEpoch);
2742          addReplySds(c,reply);
2743      } else if (!strcasecmp(c->argv[1]->ptr,"info") && c->argc == 2) {
2744          char *statestr[] = {"ok","fail","needhelp"};
2745          int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
2746          uint64_t myepoch;
2747          int j;
2748          for (j = 0; j < CLUSTER_SLOTS; j++) {
2749              clusterNode *n = server.cluster->slots[j];
2750              if (n == NULL) continue;
2751              slots_assigned++;
2752              if (nodeFailed(n)) {
2753                  slots_fail++;
2754              } else if (nodeTimedOut(n)) {
2755                  slots_pfail++;
2756              } else {
2757                  slots_ok++;
2758              }
2759          }
2760          myepoch = (nodeIsSlave(myself) && myself->slaveof) ?
2761                    myself->slaveof->configEpoch : myself->configEpoch;
2762          sds info = sdscatprintf(sdsempty(),
2763              "cluster_state:%s\r\n"
2764              "cluster_slots_assigned:%d\r\n"
2765              "cluster_slots_ok:%d\r\n"
2766              "cluster_slots_pfail:%d\r\n"
2767              "cluster_slots_fail:%d\r\n"
2768              "cluster_known_nodes:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %lu -> %Iu */
2769              "cluster_size:%d\r\n"
2770              "cluster_current_epoch:%llu\r\n"
2771              "cluster_my_epoch:%llu\r\n"
2772              , statestr[server.cluster->state],
2773              slots_assigned,
2774              slots_ok,
2775              slots_pfail,
2776              slots_fail,
2777              dictSize(server.cluster->nodes),
2778              server.cluster->size,
2779              (PORT_ULONGLONG) server.cluster->currentEpoch,
2780              (PORT_ULONGLONG) myepoch
2781          );
2782          PORT_LONGLONG tot_msg_sent = 0;
2783          PORT_LONGLONG tot_msg_received = 0;
2784          for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
2785              if (server.cluster->stats_bus_messages_sent[i] == 0) continue;
2786              tot_msg_sent += server.cluster->stats_bus_messages_sent[i];
2787              info = sdscatprintf(info,
2788                  "cluster_stats_messages_%s_sent:%lld\r\n",
2789                  clusterGetMessageTypeString(i),
2790                  server.cluster->stats_bus_messages_sent[i]);
2791          }
2792          info = sdscatprintf(info,
2793              "cluster_stats_messages_sent:%lld\r\n", tot_msg_sent);
2794          for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
2795              if (server.cluster->stats_bus_messages_received[i] == 0) continue;
2796              tot_msg_received += server.cluster->stats_bus_messages_received[i];
2797              info = sdscatprintf(info,
2798                  "cluster_stats_messages_%s_received:%lld\r\n",
2799                  clusterGetMessageTypeString(i),
2800                  server.cluster->stats_bus_messages_received[i]);
2801          }
2802          info = sdscatprintf(info,
2803              "cluster_stats_messages_received:%lld\r\n", tot_msg_received);
2804          addReplySds(c,sdscatprintf(sdsempty(),"$%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2805              (PORT_ULONG)sdslen(info)));
2806          addReplySds(c,info);
2807          addReply(c,shared.crlf);
2808      } else if (!strcasecmp(c->argv[1]->ptr,"saveconfig") && c->argc == 2) {
2809          int retval = clusterSaveConfig(1);
2810          if (retval == 0)
2811              addReply(c,shared.ok);
2812          else
2813              addReplyErrorFormat(c,"error saving the cluster node config: %s",
2814                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
2815      } else if (!strcasecmp(c->argv[1]->ptr,"keyslot") && c->argc == 3) {
2816          sds key = c->argv[2]->ptr;
2817          addReplyLongLong(c,keyHashSlot(key, (int)sdslen(key)));                  WIN_PORT_FIX &bsol;* cast (int) */
2818      } else if (!strcasecmp(c->argv[1]->ptr,"countkeysinslot") && c->argc == 3) {
2819          PORT_LONGLONG slot;
2820          if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
2821              return;
2822          if (slot < 0 || slot >= CLUSTER_SLOTS) {
2823              addReplyError(c,"Invalid slot");
2824              return;
2825          }
2826          addReplyLongLong(c,countKeysInSlot((unsigned int) slot));                WIN_PORT_FIX &bsol;* cast (unsigned int) */
2827      } else if (!strcasecmp(c->argv[1]->ptr,"getkeysinslot") && c->argc == 4) {
2828          PORT_LONGLONG maxkeys, slot;
2829          unsigned int numkeys, j;
2830          robj **keys;
2831          if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
2832              return;
2833          if (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)
2834              != C_OK)
2835              return;
2836          if (slot < 0 || slot >= CLUSTER_SLOTS || maxkeys < 0) {
2837              addReplyError(c,"Invalid slot or number of keys");
2838              return;
2839          }
2840          unsigned int keys_in_slot = countKeysInSlot(slot);
2841          if (maxkeys > keys_in_slot) maxkeys = keys_in_slot;
2842          keys = zmalloc(sizeof(robj*)*maxkeys);
2843          numkeys = getKeysInSlot((unsigned int)slot, keys, (unsigned int)maxkeys); WIN_PORT_FIX &bsol;* cast (unsigned int) */
2844          addReplyMultiBulkLen(c,numkeys);
2845          for (j = 0; j < numkeys; j++) {
2846              addReplyBulk(c,keys[j]);
2847              decrRefCount(keys[j]);
2848          }
2849          zfree(keys);
2850      } else if (!strcasecmp(c->argv[1]->ptr,"forget") && c->argc == 3) {
2851          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2852          if (!n) {
2853              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2854              return;
2855          } else if (n == myself) {
2856              addReplyError(c,"I tried hard but I can't forget myself...");
2857              return;
2858          } else if (nodeIsSlave(myself) && myself->slaveof == n) {
2859              addReplyError(c,"Can't forget my master!");
2860              return;
2861          }
2862          clusterBlacklistAddNode(n);
2863          clusterDelNode(n);
2864          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|
2865                               CLUSTER_TODO_SAVE_CONFIG);
2866          addReply(c,shared.ok);
2867      } else if (!strcasecmp(c->argv[1]->ptr,"replicate") && c->argc == 3) {
2868          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2869          if (!n) {
2870              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2871              return;
2872          }
2873          if (n == myself) {
2874              addReplyError(c,"Can't replicate myself");
2875              return;
2876          }
2877          if (nodeIsSlave(n)) {
2878              addReplyError(c,"I can only replicate a master, not a replica.");
2879              return;
2880          }
2881          if (nodeIsMaster(myself) &&
2882              (myself->numslots != 0 || dictSize(server.db[0].dict) != 0)) {
2883              addReplyError(c,
2884                  "To set a master the node must be empty and "
2885                  "without assigned slots.");
2886              return;
2887          }
2888          clusterSetMaster(n);
2889          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2890          addReply(c,shared.ok);
2891      } else if ((!strcasecmp(c->argv[1]->ptr,"slaves") ||
2892                  !strcasecmp(c->argv[1]->ptr,"replicas")) && c->argc == 3) {
2893          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2894          int j;
2895          if (!n) {
2896              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2897              return;
2898          }
2899          if (nodeIsSlave(n)) {
2900              addReplyError(c,"The specified node is not a master");
2901              return;
2902          }
2903          addReplyMultiBulkLen(c,n->numslaves);
2904          for (j = 0; j < n->numslaves; j++) {
2905              sds ni = clusterGenNodeDescription(n->slaves[j]);
2906              addReplyBulkCString(c,ni);
2907              sdsfree(ni);
2908          }
2909      } else if (!strcasecmp(c->argv[1]->ptr,"count-failure-reports") &&
2910                 c->argc == 3)
2911      {
2912          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2913          if (!n) {
2914              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2915              return;
2916          } else {
2917              addReplyLongLong(c,clusterNodeFailureReportsCount(n));
2918          }
2919      } else if (!strcasecmp(c->argv[1]->ptr,"failover") &&
2920                 (c->argc == 2 || c->argc == 3))
2921      {
2922          int force = 0, takeover = 0;
2923          if (c->argc == 3) {
2924              if (!strcasecmp(c->argv[2]->ptr,"force")) {
2925                  force = 1;
2926              } else if (!strcasecmp(c->argv[2]->ptr,"takeover")) {
2927                  takeover = 1;
2928                  force = 1; &bsol;* Takeover also implies force. */
2929              } else {
2930                  addReply(c,shared.syntaxerr);
2931                  return;
2932              }
2933          }
2934          if (nodeIsMaster(myself)) {
2935              addReplyError(c,"You should send CLUSTER FAILOVER to a replica");
2936              return;
2937          } else if (myself->slaveof == NULL) {
2938              addReplyError(c,"I'm a replica but my master is unknown to me");
2939              return;
2940          } else if (!force &&
2941                     (nodeFailed(myself->slaveof) ||
2942                      myself->slaveof->link == NULL))
2943          {
2944              addReplyError(c,"Master is down or failed, "
2945                              "please use CLUSTER FAILOVER FORCE");
2946              return;
2947          }
2948          resetManualFailover();
2949          server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;
2950          if (takeover) {
2951              serverLog(LL_WARNING,"Taking over the master (user request).");
2952              clusterBumpConfigEpochWithoutConsensus();
2953              clusterFailoverReplaceYourMaster();
2954          } else if (force) {
2955              serverLog(LL_WARNING,"Forced failover user request accepted.");
2956              server.cluster->mf_can_start = 1;
2957          } else {
2958              serverLog(LL_WARNING,"Manual failover user request accepted.");
2959              clusterSendMFStart(myself->slaveof);
2960          }
2961          addReply(c,shared.ok);
2962      } else if (!strcasecmp(c->argv[1]->ptr,"set-config-epoch") && c->argc == 3)
2963      {
2964          PORT_LONGLONG epoch;
2965          if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != C_OK)
2966              return;
2967          if (epoch < 0) {
2968              addReplyErrorFormat(c,"Invalid config epoch specified: %lld",epoch);
2969          } else if (dictSize(server.cluster->nodes) > 1) {
2970              addReplyError(c,"The user can assign a config epoch only when the "
2971                              "node does not know any other node.");
2972          } else if (myself->configEpoch != 0) {
2973              addReplyError(c,"Node config epoch is already non-zero");
2974          } else {
2975              myself->configEpoch = epoch;
2976              serverLog(LL_WARNING,
2977                  "configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH",
2978                  (PORT_ULONGLONG) myself->configEpoch);
2979              if (server.cluster->currentEpoch < (uint64_t)epoch)
2980                  server.cluster->currentEpoch = epoch;
2981              clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|
2982                                   CLUSTER_TODO_SAVE_CONFIG);
2983              addReply(c,shared.ok);
2984          }
2985      } else if (!strcasecmp(c->argv[1]->ptr,"reset") &&
2986                 (c->argc == 2 || c->argc == 3))
2987      {
2988          int hard = 0;
2989          if (c->argc == 3) {
2990              if (!strcasecmp(c->argv[2]->ptr,"hard")) {
2991                  hard = 1;
2992              } else if (!strcasecmp(c->argv[2]->ptr,"soft")) {
2993                  hard = 0;
2994              } else {
2995                  addReply(c,shared.syntaxerr);
2996                  return;
2997              }
2998          }
2999          if (nodeIsMaster(myself) && dictSize(c->db->dict) != 0) {
3000              addReplyError(c,"CLUSTER RESET can't be called with "
3001                              "master nodes containing keys");
3002              return;
3003          }
3004          clusterReset(hard);
3005          addReply(c,shared.ok);
3006      } else {
3007          addReplySubcommandSyntaxError(c);
3008          return;
3009      }
3010  }
3011  void createDumpPayload(rio *payload, robj *o, robj *key) {
3012      unsigned char buf[2];
3013      uint64_t crc;
3014      rioInitWithBuffer(payload,sdsempty());
3015      serverAssert(rdbSaveObjectType(payload,o));
3016      serverAssert(rdbSaveObject(payload,o,key));
3017      buf[0] = RDB_VERSION & 0xff;
3018      buf[1] = (RDB_VERSION >> 8) & 0xff;
3019      payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);
3020      crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
3021                  sdslen(payload->io.buffer.ptr));
3022      memrev64ifbe(&crc);
3023      payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
3024  }
3025  int verifyDumpPayload(unsigned char *p, size_t len) {
3026      unsigned char *footer;
3027      uint16_t rdbver;
3028      uint64_t crc;
3029      if (len < 10) return C_ERR;
3030      footer = p+(len-10);
3031      rdbver = (footer[1] << 8) | footer[0];
3032      if (rdbver > RDB_VERSION) return C_ERR;
3033      crc = crc64(0,p,len-8);
3034      memrev64ifbe(&crc);
3035      return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
3036  }
3037  void dumpCommand(client *c) {
3038      robj *o, *dumpobj;
3039      rio payload;
3040      if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
3041          addReply(c,shared.nullbulk);
3042          return;
3043      }
3044      createDumpPayload(&payload,o,c->argv[1]);
3045      dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);
3046      addReplyBulk(c,dumpobj);
3047      decrRefCount(dumpobj);
3048      return;
3049  }
3050  void restoreCommand(client *c) {
3051      PORT_LONGLONG ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
3052      rio payload;
3053      int j, type, replace = 0, absttl = 0;
3054      robj *obj;
3055      for (j = 4; j < c->argc; j++) {
3056          int additional = c->argc-j-1;
3057          if (!strcasecmp(c->argv[j]->ptr,"replace")) {
3058              replace = 1;
3059          } else if (!strcasecmp(c->argv[j]->ptr,"absttl")) {
3060              absttl = 1;
3061          } else if (!strcasecmp(c->argv[j]->ptr,"idletime") && additional >= 1 &&
3062                     lfu_freq == -1)
3063          {
3064              if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
3065                      != C_OK) return;
3066              if (lru_idle < 0) {
3067                  addReplyError(c,"Invalid IDLETIME value, must be >= 0");
3068                  return;
3069              }
3070              lru_clock = LRU_CLOCK();
3071              j++; &bsol;* Consume additional arg. */
3072          } else if (!strcasecmp(c->argv[j]->ptr,"freq") && additional >= 1 &&
3073                     lru_idle == -1)
3074          {
3075              if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lfu_freq,NULL)
3076                      != C_OK) return;
3077              if (lfu_freq < 0 || lfu_freq > 255) {
3078                  addReplyError(c,"Invalid FREQ value, must be >= 0 and <= 255");
3079                  return;
3080              }
3081              j++; &bsol;* Consume additional arg. */
3082          } else {
3083              addReply(c,shared.syntaxerr);
3084              return;
3085          }
3086      }
3087      robj *key = c->argv[1];
3088      if (!replace && lookupKeyWrite(c->db,key) != NULL) {
3089          addReply(c,shared.busykeyerr);
3090          return;
3091      }
3092      if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != C_OK) {
3093          return;
3094      } else if (ttl < 0) {
3095          addReplyError(c,"Invalid TTL value, must be >= 0");
3096          return;
3097      }
3098      if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == C_ERR)
3099      {
3100          addReplyError(c,"DUMP payload version or checksum are wrong");
3101          return;
3102      }
3103      rioInitWithBuffer(&payload,c->argv[3]->ptr);
3104      if (((type = rdbLoadObjectType(&payload)) == -1) ||
3105          ((obj = rdbLoadObject(type,&payload,key)) == NULL))
3106      {
3107          addReplyError(c,"Bad data format");
3108          return;
3109      }
3110      int deleted = 0;
3111      if (replace)
3112          deleted = dbDelete(c->db,key);
3113      if (ttl && !absttl) ttl+=mstime();
3114      if (ttl && checkAlreadyExpired(ttl)) {
3115          if (deleted) {
3116              rewriteClientCommandVector(c,2,shared.del,key);
3117              signalModifiedKey(c->db,key);
3118              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
3119              server.dirty++;
3120          }
3121          decrRefCount(obj);
3122          addReply(c, shared.ok);
3123          return;
3124      }
3125      dbAdd(c->db,key,obj);
3126      if (ttl) {
3127          setExpire(c,c->db,key,ttl);
3128      }
3129      objectSetLRUOrLFU(obj,lfu_freq,lru_idle,lru_clock);
3130      signalModifiedKey(c->db,key);
3131      addReply(c,shared.ok);
3132      server.dirty++;
3133  }
3134  #define MIGRATE_SOCKET_CACHE_ITEMS 64 &bsol;* max num of items in the cache. */
3135  #define MIGRATE_SOCKET_CACHE_TTL 10 &bsol;* close cached sockets after 10 sec. */
3136  typedef struct migrateCachedSocket {
3137      int fd;
3138      PORT_LONG last_dbid;
3139      time_t last_use_time;
3140  } migrateCachedSocket;
3141  migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, PORT_LONG timeout) {
3142      int fd;
3143      sds name = sdsempty();
3144      migrateCachedSocket *cs;
3145      name = sdscatlen(name,host->ptr,sdslen(host->ptr));
3146      name = sdscatlen(name,":",1);
3147      name = sdscatlen(name,port->ptr,sdslen(port->ptr));
3148      cs = dictFetchValue(server.migrate_cached_sockets,name);
3149      if (cs) {
3150          sdsfree(name);
3151          cs->last_use_time = server.unixtime;
3152          return cs;
3153      }
3154      if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {
3155          dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);
3156          cs = dictGetVal(de);
3157          close(cs->fd);
3158          zfree(cs);
3159          dictDelete(server.migrate_cached_sockets,dictGetKey(de));
3160      }
3161      fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,
3162                                  atoi(c->argv[2]->ptr));
3163      if (fd == -1) {
3164          sdsfree(name);
3165          addReplyErrorFormat(c,"Can't connect to target node: %s",
3166              server.neterr);
3167          return NULL;
3168      }
3169      anetEnableTcpNoDelay(server.neterr,fd);
3170      if ((aeWait(fd,AE_WRITABLE,timeout) & AE_WRITABLE) == 0) {
3171          sdsfree(name);
3172          addReplySds(c,
3173              sdsnew("-IOERR error or timeout connecting to the client\r\n"));
3174          close(fd);
3175          return NULL;
3176      }
3177      cs = zmalloc(sizeof(*cs));
3178      cs->fd = fd;
3179      cs->last_dbid = -1;
3180      cs->last_use_time = server.unixtime;
3181      dictAdd(server.migrate_cached_sockets,name,cs);
3182      return cs;
3183  }
3184  void migrateCloseSocket(robj *host, robj *port) {
3185      sds name = sdsempty();
3186      migrateCachedSocket *cs;
3187      name = sdscatlen(name,host->ptr,sdslen(host->ptr));
3188      name = sdscatlen(name,":",1);
3189      name = sdscatlen(name,port->ptr,sdslen(port->ptr));
3190      cs = dictFetchValue(server.migrate_cached_sockets,name);
3191      if (!cs) {
3192          sdsfree(name);
3193          return;
3194      }
3195      close(cs->fd);
3196      zfree(cs);
3197      dictDelete(server.migrate_cached_sockets,name);
3198      sdsfree(name);
3199  }
3200  void migrateCloseTimedoutSockets(void) {
3201      dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
3202      dictEntry *de;
3203      while((de = dictNext(di)) != NULL) {
3204          migrateCachedSocket *cs = dictGetVal(de);
3205          if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {
3206              close(cs->fd);
3207              zfree(cs);
3208              dictDelete(server.migrate_cached_sockets,dictGetKey(de));
3209          }
3210      }
3211      dictReleaseIterator(di);
3212  }
3213  void migrateCommand(client *c) {
3214      migrateCachedSocket *cs;
3215      int copy = 0, replace = 0, j;
3216      char *password = NULL;
3217      PORT_LONG timeout;
3218      PORT_LONG dbid;
3219      robj **ov = NULL; &bsol;* Objects to migrate. */
3220      robj **kv = NULL; &bsol;* Key names. */
3221      robj **newargv = NULL; &bsol;* Used to rewrite the command as DEL ... keys ... */
3222      rio cmd, payload;
3223      int may_retry = 1;
3224      int write_error = 0;
3225      int argv_rewritten = 0;
3226      int first_key = 3; &bsol;* Argument index of the first key. */
3227      int num_keys = 1;  &bsol;* By default only migrate the 'key' argument. */
3228      for (j = 6; j < c->argc; j++) {
3229          int moreargs = j < c->argc-1;
3230          if (!strcasecmp(c->argv[j]->ptr,"copy")) {
3231              copy = 1;
3232          } else if (!strcasecmp(c->argv[j]->ptr,"replace")) {
3233              replace = 1;
3234          } else if (!strcasecmp(c->argv[j]->ptr,"auth")) {
3235              if (!moreargs) {
3236                  addReply(c,shared.syntaxerr);
3237                  return;
3238              }
3239              j++;
3240              password = c->argv[j]->ptr;
3241          } else if (!strcasecmp(c->argv[j]->ptr,"keys")) {
3242              if (sdslen(c->argv[3]->ptr) != 0) {
3243                  addReplyError(c,
3244                      "When using MIGRATE KEYS option, the key argument"
3245                      " must be set to the empty string");
3246                  return;
3247              }
3248              first_key = j+1;
3249              num_keys = c->argc - j - 1;
3250              break; &bsol;* All the remaining args are keys. */
3251          } else {
3252              addReply(c,shared.syntaxerr);
3253              return;
3254          }
3255      }
3256      if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != C_OK ||
3257          getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != C_OK)
3258      {
3259          return;
3260      }
3261      if (timeout <= 0) timeout = 1000;
3262      ov = zrealloc(ov,sizeof(robj*)*num_keys);
3263      kv = zrealloc(kv,sizeof(robj*)*num_keys);
3264      int oi = 0;
3265      for (j = 0; j < num_keys; j++) {
3266          if ((ov[oi] = lookupKeyRead(c->db,c->argv[first_key+j])) != NULL) {
3267              kv[oi] = c->argv[first_key+j];
3268              oi++;
3269          }
3270      }
3271      num_keys = oi;
3272      if (num_keys == 0) {
3273          zfree(ov); zfree(kv);
3274          addReplySds(c,sdsnew("+NOKEY\r\n"));
3275          return;
3276      }
3277  try_again:
3278      write_error = 0;
3279      cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);
3280      if (cs == NULL) {
3281          zfree(ov); zfree(kv);
3282          return; &bsol;* error sent to the client by migrateGetSocket() */
3283      }
3284      rioInitWithBuffer(&cmd,sdsempty());
3285      if (password) {
3286          serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
3287          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"AUTH",4));
3288          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,password,
3289              sdslen(password)));
3290      }
3291      int select = cs->last_dbid != dbid; &bsol;* Should we emit SELECT? */
3292      if (select) {
3293          serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
3294          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"SELECT",6));
3295          serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
3296      }
3297      int non_expired = 0; &bsol;* Number of keys that we'll find non expired.
3298                              Note that serializing large keys may take some time
3299                              so certain keys that were found non expired by the
3300                              lookupKey() function, may be expired later. */
3301      for (j = 0; j < num_keys; j++) {
3302          PORT_LONGLONG ttl = 0;
3303          PORT_LONGLONG expireat = getExpire(c->db,kv[j]);
3304          if (expireat != -1) {
3305              ttl = expireat-mstime();
3306              if (ttl < 0) {
3307                  continue;
3308              }
3309              if (ttl < 1) ttl = 1;
3310          }
3311          kv[non_expired++] = kv[j];
3312          serverAssertWithInfo(c,NULL,
3313              rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));
3314          if (server.cluster_enabled)
3315              serverAssertWithInfo(c,NULL,
3316                  rioWriteBulkString(&cmd,"RESTORE-ASKING",14));
3317          else
3318              serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"RESTORE",7));
3319          serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));
3320          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,
3321                  sdslen(kv[j]->ptr)));
3322          serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));
3323          createDumpPayload(&payload,ov[j],kv[j]);
3324          serverAssertWithInfo(c,NULL,
3325              rioWriteBulkString(&cmd,payload.io.buffer.ptr,
3326                                 sdslen(payload.io.buffer.ptr)));
3327          sdsfree(payload.io.buffer.ptr);
3328          if (replace)
3329              serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"REPLACE",7));
3330      }
3331      num_keys = non_expired;
3332      errno = 0;
3333      {
3334          sds buf = cmd.io.buffer.ptr;
3335          size_t pos = 0, towrite;
3336          int nwritten = 0;
3337  #ifdef _WIN32
3338          while ((towrite = sdslen(buf) - pos) > 0) {
3339              towrite = (towrite > (64 * 1024) ? (64 * 1024) : towrite);
3340              while (nwritten != (signed) towrite) {
3341                  nwritten = (int) syncWrite(cs->fd, buf + pos, (ssize_t) towrite, timeout);
3342                  if (nwritten != (signed) towrite) {
3343                      DWORD err = GetLastError();
3344                      if (err == WSAEWOULDBLOCK) {
3345                          serverLog(LL_VERBOSE, "In migrate. WSAEWOULDBLOCK with synchronous socket: sleeping for 0.1s");
3346                          Sleep(100);
3347                      }
3348                      else {
3349                          serverLog(LL_WARNING, "SyncWrite failure toWrite=%d  written=%d err=%d timeout=%d ", towrite, nwritten, GetLastError(), timeout);
3350                          goto socket_err;
3351                      }
3352                  }
3353              }
3354              pos += nwritten;
3355              nwritten = 0;
3356          }
3357  #else
3358          while ((towrite = sdslen(buf)-pos) > 0) {
3359              towrite = (towrite > (64*1024) ? (64*1024) : towrite);
3360              nwritten = syncWrite(cs->fd,buf+pos,towrite,timeout);
3361              if (nwritten != (signed)towrite) {
3362                  write_error = 1;
3363                  goto socket_err;
3364              }
3365              pos += nwritten;
3366          }
3367  #endif
3368      }
3369      char buf0[1024]; &bsol;* Auth reply. */
3370      char buf1[1024]; &bsol;* Select reply. */
3371      char buf2[1024]; &bsol;* Restore reply. */
3372      if (password && syncReadLine(cs->fd, buf0, sizeof(buf0), timeout) <= 0)
3373          goto socket_err;
3374      if (select && syncReadLine(cs->fd, buf1, sizeof(buf1), timeout) <= 0)
3375          goto socket_err;
3376      int error_from_target = 0;
3377      int socket_error = 0;
3378      int del_idx = 1; &bsol;* Index of the key argument for the replicated DEL op. */
3379      if (!copy) newargv = zmalloc(sizeof(robj*)*(num_keys+1));
3380      for (j = 0; j < num_keys; j++) {
3381          if (syncReadLine(cs->fd, buf2, sizeof(buf2), timeout) <= 0) {
3382              socket_error = 1;
3383              break;
3384          }
3385          if ((password && buf0[0] == '-') ||
3386              (select && buf1[0] == '-') ||
3387              buf2[0] == '-')
3388          {
3389              if (!error_from_target) {
3390                  cs->last_dbid = -1;
3391                  char *errbuf;
3392                  if (password && buf0[0] == '-') errbuf = buf0;
3393                  else if (select && buf1[0] == '-') errbuf = buf1;
3394                  else errbuf = buf2;
3395                  error_from_target = 1;
3396                  addReplyErrorFormat(c,"Target instance replied with error: %s",
3397                      errbuf+1);
3398              }
3399          } else {
3400              if (!copy) {
3401                  dbDelete(c->db,kv[j]);
3402                  signalModifiedKey(c->db,kv[j]);
3403                  server.dirty++;
3404                  newargv[del_idx++] = kv[j];
3405                  incrRefCount(kv[j]);
3406              }
3407          }
3408      }
3409      if (!error_from_target && socket_error && j == 0 && may_retry &&
3410          errno != ETIMEDOUT)
3411      {
3412          goto socket_err; &bsol;* A retry is guaranteed because of tested conditions.*/
3413      }
3414      if (socket_error) migrateCloseSocket(c->argv[1],c->argv[2]);
3415      if (!copy) {
3416          if (del_idx > 1) {
3417              newargv[0] = createStringObject("DEL",3);
3418              replaceClientCommandVector(c,del_idx,newargv);
3419              argv_rewritten = 1;
3420          } else {
3421              zfree(newargv);
3422          }
3423          newargv = NULL; &bsol;* Make it safe to call zfree() on it in the future. */
3424      }
3425      if (!error_from_target && socket_error) {
3426          may_retry = 0;
3427          goto socket_err;
3428      }
3429      if (!error_from_target) {
3430          cs->last_dbid = dbid;
3431          addReply(c,shared.ok);
3432      } else {
3433      }
3434      sdsfree(cmd.io.buffer.ptr);
3435      zfree(ov); zfree(kv); zfree(newargv);
3436      return;
3437  socket_err:
3438  #ifdef _WIN32
3439      serverLog(LL_WARNING, "syncReadLine failure err=%d timeout=%d ", GetLastError(), timeout);
3440  #endif
3441      sdsfree(cmd.io.buffer.ptr);
3442      if (!argv_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);
3443      zfree(newargv);
3444      newargv = NULL; &bsol;* This will get reallocated on retry. */
3445      if (errno != ETIMEDOUT && may_retry) {
3446          may_retry = 0;
3447          goto try_again;
3448      }
3449      zfree(ov); zfree(kv);
3450      addReplySds(c,
3451          sdscatprintf(sdsempty(),
3452              "-IOERR error or timeout %s to target instance\r\n",
3453              write_error ? "writing" : "reading"));
3454      return;
3455  }
3456  void askingCommand(client *c) {
3457      if (server.cluster_enabled == 0) {
3458          addReplyError(c,"This instance has cluster support disabled");
3459          return;
3460      }
3461      c->flags |= CLIENT_ASKING;
3462      addReply(c,shared.ok);
3463  }
3464  void readonlyCommand(client *c) {
3465      if (server.cluster_enabled == 0) {
3466          addReplyError(c,"This instance has cluster support disabled");
3467          return;
3468      }
3469      c->flags |= CLIENT_READONLY;
3470      addReply(c,shared.ok);
3471  }
3472  void readwriteCommand(client *c) {
3473      c->flags &= ~CLIENT_READONLY;
3474      addReply(c,shared.ok);
3475  }
3476  clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
3477      clusterNode *n = NULL;
3478      robj *firstkey = NULL;
3479      int multiple_keys = 0;
3480      multiState *ms, _ms;
3481      multiCmd mc;
3482      int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;
3483      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
3484          return myself;
3485      if (error_code) *error_code = CLUSTER_REDIR_NONE;
3486      if (cmd->proc == execCommand) {
3487          if (!(c->flags & CLIENT_MULTI)) return myself;
3488          ms = &c->mstate;
3489      } else {
3490          ms = &_ms;
3491          _ms.commands = &mc;
3492          _ms.count = 1;
3493          mc.argv = argv;
3494          mc.argc = argc;
3495          mc.cmd = cmd;
3496      }
3497      for (i = 0; i < ms->count; i++) {
3498          struct redisCommand *mcmd;
3499          robj **margv;
3500          int margc, *keyindex, numkeys, j;
3501          mcmd = ms->commands[i].cmd;
3502          margc = ms->commands[i].argc;
3503          margv = ms->commands[i].argv;
3504          keyindex = getKeysFromCommand(mcmd,margv,margc,&numkeys);
3505          for (j = 0; j < numkeys; j++) {
3506              robj *thiskey = margv[keyindex[j]];
3507              int thisslot = keyHashSlot((char*)thiskey->ptr,
3508                                         (int) sdslen(thiskey->ptr));              WIN_PORT_FIX &bsol;* cast (int) */
3509              if (firstkey == NULL) {
3510                  firstkey = thiskey;
3511                  slot = thisslot;
3512                  n = server.cluster->slots[slot];
3513                  if (n == NULL) {
3514                      getKeysFreeResult(keyindex);
3515                      if (error_code)
3516                          *error_code = CLUSTER_REDIR_DOWN_UNBOUND;
3517                      return NULL;
3518                  }
3519                  if (n == myself &&
3520                      server.cluster->migrating_slots_to[slot] != NULL)
3521                  {
3522                      migrating_slot = 1;
3523                  } else if (server.cluster->importing_slots_from[slot] != NULL) {
3524                      importing_slot = 1;
3525                  }
3526              } else {
3527                  if (!equalStringObjects(firstkey,thiskey)) {
3528                      if (slot != thisslot) {
3529                          getKeysFreeResult(keyindex);
3530                          if (error_code)
3531                              *error_code = CLUSTER_REDIR_CROSS_SLOT;
3532                          return NULL;
3533                      } else {
3534                          multiple_keys = 1;
3535                      }
3536                  }
3537              }
3538              if ((migrating_slot || importing_slot) &&
3539                  lookupKeyRead(&server.db[0],thiskey) == NULL)
3540              {
3541                  missing_keys++;
3542              }
3543          }
3544          getKeysFreeResult(keyindex);
3545      }
3546      if (n == NULL) return myself;
3547      if (server.cluster->state != CLUSTER_OK) {
3548          if (error_code) *error_code = CLUSTER_REDIR_DOWN_STATE;
3549          return NULL;
3550      }
3551      if (hashslot) *hashslot = slot;
3552      if ((migrating_slot || importing_slot) && cmd->proc == migrateCommand)
3553          return myself;
3554      if (migrating_slot && missing_keys) {
3555          if (error_code) *error_code = CLUSTER_REDIR_ASK;
3556          return server.cluster->migrating_slots_to[slot];
3557      }
3558      if (importing_slot &&
3559          (c->flags & CLIENT_ASKING || cmd->flags & CMD_ASKING))
3560      {
3561          if (multiple_keys && missing_keys) {
3562              if (error_code) *error_code = CLUSTER_REDIR_UNSTABLE;
3563              return NULL;
3564          } else {
3565              return myself;
3566          }
3567      }
3568      if (c->flags & CLIENT_READONLY &&
3569          (cmd->flags & CMD_READONLY || cmd->proc == evalCommand ||
3570           cmd->proc == evalShaCommand) &&
3571          nodeIsSlave(myself) &&
3572          myself->slaveof == n)
3573      {
3574          return myself;
3575      }
3576      if (n != myself && error_code) *error_code = CLUSTER_REDIR_MOVED;
3577      return n;
3578  }
3579  void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
3580      if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
3581          addReplySds(c,sdsnew("-CROSSSLOT Keys in request don't hash to the same slot\r\n"));
3582      } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
3583          addReplySds(c,sdsnew("-TRYAGAIN Multiple keys request during rehashing of slot\r\n"));
3584      } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
3585          addReplySds(c,sdsnew("-CLUSTERDOWN The cluster is down\r\n"));
3586      } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
3587          addReplySds(c,sdsnew("-CLUSTERDOWN Hash slot not served\r\n"));
3588      } else if (error_code == CLUSTER_REDIR_MOVED ||
3589                 error_code == CLUSTER_REDIR_ASK)
3590      {
3591          addReplySds(c,sdscatprintf(sdsempty(),
3592              "-%s %d %s:%d\r\n",
3593              (error_code == CLUSTER_REDIR_ASK) ? "ASK" : "MOVED",
3594              hashslot,n->ip,n->port));
3595      } else {
3596          serverPanic("getNodeByQuery() unknown error.");
3597      }
3598  }
3599  int clusterRedirectBlockedClientIfNeeded(client *c) {
3600      if (c->flags & CLIENT_BLOCKED &&
3601          (c->btype == BLOCKED_LIST ||
3602           c->btype == BLOCKED_ZSET ||
3603           c->btype == BLOCKED_STREAM))
3604      {
3605          dictEntry *de;
3606          dictIterator *di;
3607          if (server.cluster->state == CLUSTER_FAIL) {
3608              clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
3609              return 1;
3610          }
3611          di = dictGetIterator(c->bpop.keys);
3612          if ((de = dictNext(di)) != NULL) {
3613              robj *key = dictGetKey(de);
3614              int slot = keyHashSlot((char*)key->ptr, (int)sdslen(key->ptr));     WIN_PORT_FIX &bsol;* cast (int) */
3615              clusterNode *node = server.cluster->slots[slot];
3616              if ((c->flags & CLIENT_READONLY) &&
3617                  (c->lastcmd->flags & CMD_READONLY) &&
3618                  nodeIsSlave(myself) && myself->slaveof == node)
3619              {
3620                  node = myself;
3621              }
3622              if (node != myself &&
3623                  server.cluster->importing_slots_from[slot] == NULL)
3624              {
3625                  if (node == NULL) {
3626                      clusterRedirectClient(c,NULL,0,
3627                          CLUSTER_REDIR_DOWN_UNBOUND);
3628                  } else {
3629                      clusterRedirectClient(c,node,slot,
3630                          CLUSTER_REDIR_MOVED);
3631                  }
3632                  dictReleaseIterator(di);
3633                  return 1;
3634              }
3635          }
3636          dictReleaseIterator(di);
3637      }
3638      return 0;
3639  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-cluster.c</h3>
            <pre><code>1  #include "server.h"
2  #include "cluster.h"
3  #include "endianconv.h"
4  #include <sys/types.h>
5  POSIX_ONLY(#include <sys/socket.h>)
6  POSIX_ONLY(#include <arpa/inet.h>)
7  #include <fcntl.h>
8  POSIX_ONLY(#include <unistd.h>)
9  POSIX_ONLY(#include <sys/socket.h>)
10  #include <sys/stat.h>
11  POSIX_ONLY(#include <sys/file.h>)
12  #include <math.h>
13  #ifdef _WIN32
14  extern int WSIOCP_QueueAccept(int listenfd);
15  #include "Win32_Interop/Win32_Error.h"
16  #endif
17  clusterNode *myself = NULL;
18  clusterNode *createClusterNode(char *nodename, int flags);
19  int clusterAddNode(clusterNode *node);
20  void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);
21  void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask);
22  void clusterSendPing(clusterLink *link, int type);
23  void clusterSendFail(char *nodename);
24  void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);
25  void clusterUpdateState(void);
26  int clusterNodeGetSlotBit(clusterNode *n, int slot);
27  sds clusterGenNodesDescription(int filter);
28  clusterNode *clusterLookupNode(const char *name);
29  int clusterNodeAddSlave(clusterNode *master, clusterNode *slave);
30  int clusterAddSlot(clusterNode *n, int slot);
31  int clusterDelSlot(int slot);
32  int clusterDelNodeSlots(clusterNode *node);
33  int clusterNodeSetSlotBit(clusterNode *n, int slot);
34  void clusterSetMaster(clusterNode *n);
35  void clusterHandleSlaveFailover(void);
36  void clusterHandleSlaveMigration(int max_slaves);
37  int bitmapTestBit(unsigned char *bitmap, int pos);
38  void clusterDoBeforeSleep(int flags);
39  void clusterSendUpdate(clusterLink *link, clusterNode *node);
40  void resetManualFailover(void);
41  void clusterCloseAllSlots(void);
42  void clusterSetNodeAsMaster(clusterNode *n);
43  void clusterDelNode(clusterNode *delnode);
44  sds representClusterNodeFlags(sds ci, uint16_t flags);
45  uint64_t clusterGetMaxEpoch(void);
46  int clusterBumpConfigEpochWithoutConsensus(void);
47  void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len);
48  int clusterLoadConfig(char *filename) {
49      FILE *fp = fopen(filename, IF_WIN32("rb", "r"));
50      struct IF_WIN32(_stat64, stat) sb;                                           
51      char *line;
52      int maxline, j;
53      if (fp == NULL) {
54          if (errno == ENOENT) {
55              return C_ERR;
56          } else {
57              serverLog(LL_WARNING,
58                  "Loading the cluster node config from %s: %s",
59                  filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
60              exit(1);
61          }
62      }
63      if (fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
64          fclose(fp);
65          return C_ERR;
66      }
67      maxline = 1024+CLUSTER_SLOTS*128;
68      line = zmalloc(maxline);
69      while(fgets(line,maxline,fp) != NULL) {
70          int argc;
71          sds *argv;
72          clusterNode *n, *master;
73          char *p, *s;
74          if (line[0] == '\n' || line[0] == '\0') continue;
75          argv = sdssplitargs(line,&argc);
76          if (argv == NULL) goto fmterr;
77          if (strcasecmp(argv[0],"vars") == 0) {
78              if (!(argc % 2)) goto fmterr;
79              for (j = 1; j < argc; j += 2) {
80                  if (strcasecmp(argv[j],"currentEpoch") == 0) {
81                      server.cluster->currentEpoch =
82                              strtoull(argv[j+1],NULL,10);
83                  } else if (strcasecmp(argv[j],"lastVoteEpoch") == 0) {
84                      server.cluster->lastVoteEpoch =
85                              strtoull(argv[j+1],NULL,10);
86                  } else {
87                      serverLog(LL_WARNING,
88                          "Skipping unknown cluster config variable '%s'",
89                          argv[j]);
90                  }
91              }
92              sdsfreesplitres(argv,argc);
93              continue;
94          }
95          if (argc < 8) {
96              sdsfreesplitres(argv,argc);
97              goto fmterr;
98          }
99          n = clusterLookupNode(argv[0]);
100          if (!n) {
101              n = createClusterNode(argv[0],0);
102              clusterAddNode(n);
103          }
104          if ((p = strrchr(argv[1],':')) == NULL) {
105              sdsfreesplitres(argv,argc);
106              goto fmterr;
107          }
108          *p = '\0';
109          memcpy(n->ip,argv[1],strlen(argv[1])+1);
110          char *port = p+1;
111          char *busp = strchr(port,'@');
112          if (busp) {
113              *busp = '\0';
114              busp++;
115          }
116          n->port = atoi(port);
117          n->cport = busp ? atoi(busp) : n->port + CLUSTER_PORT_INCR;
118          p = s = argv[2];
119          while(p) {
120              p = strchr(s,',');
121              if (p) *p = '\0';
122              if (!strcasecmp(s,"myself")) {
123                  serverAssert(server.cluster->myself == NULL);
124                  myself = server.cluster->myself = n;
125                  n->flags |= CLUSTER_NODE_MYSELF;
126              } else if (!strcasecmp(s,"master")) {
127                  n->flags |= CLUSTER_NODE_MASTER;
128              } else if (!strcasecmp(s,"slave")) {
129                  n->flags |= CLUSTER_NODE_SLAVE;
130              } else if (!strcasecmp(s,"fail?")) {
131                  n->flags |= CLUSTER_NODE_PFAIL;
132              } else if (!strcasecmp(s,"fail")) {
133                  n->flags |= CLUSTER_NODE_FAIL;
134                  n->fail_time = mstime();
135              } else if (!strcasecmp(s,"handshake")) {
136                  n->flags |= CLUSTER_NODE_HANDSHAKE;
137              } else if (!strcasecmp(s,"noaddr")) {
138                  n->flags |= CLUSTER_NODE_NOADDR;
139              } else if (!strcasecmp(s,"nofailover")) {
140                  n->flags |= CLUSTER_NODE_NOFAILOVER;
141              } else if (!strcasecmp(s,"noflags")) {
142              } else {
143                  serverPanic("Unknown flag in redis cluster config file");
144              }
145              if (p) s = p+1;
146          }
147          if (argv[3][0] != '-') {
148              master = clusterLookupNode(argv[3]);
149              if (!master) {
150                  master = createClusterNode(argv[3],0);
151                  clusterAddNode(master);
152              }
153              n->slaveof = master;
154              clusterNodeAddSlave(master,n);
155          }
156          if (atoi(argv[4])) n->ping_sent = mstime();
157          if (atoi(argv[5])) n->pong_received = mstime();
158          n->configEpoch = strtoull(argv[6],NULL,10);
159          for (j = 8; j < argc; j++) {
160              int start, stop;
161              if (argv[j][0] == '[') {
162                  int slot;
163                  char direction;
164                  clusterNode *cn;
165                  p = strchr(argv[j],'-');
166                  serverAssert(p != NULL);
167                  *p = '\0';
168                  direction = p[1]; &bsol;* Either '>' or '<' */
169                  slot = atoi(argv[j]+1);
170                  if (slot < 0 || slot >= CLUSTER_SLOTS) {
171                      sdsfreesplitres(argv,argc);
172                      goto fmterr;
173                  }
174                  p += 3;
175                  cn = clusterLookupNode(p);
176                  if (!cn) {
177                      cn = createClusterNode(p,0);
178                      clusterAddNode(cn);
179                  }
180                  if (direction == '>') {
181                      server.cluster->migrating_slots_to[slot] = cn;
182                  } else {
183                      server.cluster->importing_slots_from[slot] = cn;
184                  }
185                  continue;
186              } else if ((p = strchr(argv[j],'-')) != NULL) {
187                  *p = '\0';
188                  start = atoi(argv[j]);
189                  stop = atoi(p+1);
190              } else {
191                  start = stop = atoi(argv[j]);
192              }
193              if (start < 0 || start >= CLUSTER_SLOTS ||
194                  stop < 0 || stop >= CLUSTER_SLOTS)
195              {
196                  sdsfreesplitres(argv,argc);
197                  goto fmterr;
198              }
199              while(start <= stop) clusterAddSlot(n, start++);
200          }
201          sdsfreesplitres(argv,argc);
202      }
203      if (server.cluster->myself == NULL) goto fmterr;
204      zfree(line);
205      fclose(fp);
206      serverLog(LL_NOTICE,"Node configuration loaded, I'm %.40s", myself->name);
207      if (clusterGetMaxEpoch() > server.cluster->currentEpoch) {
208          server.cluster->currentEpoch = clusterGetMaxEpoch();
209      }
210      return C_OK;
211  fmterr:
212      serverLog(LL_WARNING,
213          "Unrecoverable error: corrupted cluster config file.");
214      zfree(line);
215      if (fp) fclose(fp);
216      exit(1);
217  }
218  int clusterSaveConfig(int do_fsync) {
219      sds ci;
220      size_t content_size;
221      struct IF_WIN32(_stat64, stat) sb;                                           
222      int fd;
223      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;
224      ci = clusterGenNodesDescription(CLUSTER_NODE_HANDSHAKE);
225      ci = sdscatprintf(ci,"vars currentEpoch %llu lastVoteEpoch %llu\n",
226          (PORT_ULONGLONG) server.cluster->currentEpoch,
227          (PORT_ULONGLONG) server.cluster->lastVoteEpoch);
228      content_size = sdslen(ci);
229      if ((fd = open(server.cluster_configfile,O_WRONLY|O_CREAT,0644))
230          == -1) goto err;
231      if (fstat(fd,&sb) != -1) {
232          if (sb.st_size > (off_t)content_size) {
233              ci = sdsgrowzero(ci,sb.st_size);
234              memset(ci+content_size,'\n',sb.st_size-content_size);
235          }
236      }
237      if (write(fd,ci,sdslen(ci)) != (ssize_t)sdslen(ci)) goto err;
238      if (do_fsync) {
239          server.cluster->todo_before_sleep &= ~CLUSTER_TODO_FSYNC_CONFIG;
240          fsync(fd);
241      }
242      if (content_size != sdslen(ci) && ftruncate(fd,content_size) == -1) {
243      }
244      close(fd);
245      sdsfree(ci);
246      return 0;
247  err:
248      if (fd != -1) close(fd);
249      sdsfree(ci);
250      return -1;
251  }
252  void clusterSaveConfigOrDie(int do_fsync) {
253      if (clusterSaveConfig(do_fsync) == -1) {
254          serverLog(LL_WARNING,"Fatal: can't update cluster config file.");
255          exit(1);
256      }
257  }
258  int clusterLockConfig(char *filename) {
259  #if !defined(__sun)
260      int fd = open(filename,O_WRONLY|O_CREAT,0644);
261      if (fd == -1) {
262          serverLog(LL_WARNING,
263              "Can't open %s in order to acquire a lock: %s",
264              filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
265          return C_ERR;
266      }
267  #ifndef _WIN32
268      if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
269          if (errno == EWOULDBLOCK) {
270  #else
271      HANDLE hFile = (HANDLE) FDAPI_get_osfhandle(fd);
272      OVERLAPPED ovlp;
273      DWORD size_lower, size_upper;
274      memset(&ovlp, 0, sizeof ovlp);
275      size_lower = GetFileSize(hFile, &size_upper);
276      if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, size_lower, size_upper, &ovlp)) {
277          DWORD err = GetLastError();
278          if (err == ERROR_LOCK_VIOLATION) {
279  #endif
280              serverLog(LL_WARNING,
281                   "Sorry, the cluster configuration file %s is already used "
282                   "by a different Redis Cluster node. Please make sure that "
283                   "different nodes use different cluster configuration "
284                   "files.", filename);
285          } else {
286              serverLog(LL_WARNING,
287                  "Impossible to lock %s: %s", filename, IF_WIN32(wsa_strerror(errno), strerror(errno)));
288          }
289          close(fd);
290          return C_ERR;
291      }
292  #endif &bsol;* __sun */
293      return C_OK;
294  }
295  void clusterUpdateMyselfFlags(void) {
296      int oldflags = myself->flags;
297      int nofailover = server.cluster_slave_no_failover ?
298                       CLUSTER_NODE_NOFAILOVER : 0;
299      myself->flags &= ~CLUSTER_NODE_NOFAILOVER;
300      myself->flags |= nofailover;
301      if (myself->flags != oldflags) {
302          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
303                               CLUSTER_TODO_UPDATE_STATE);
304      }
305  }
306  void clusterInit(void) {
307      int saveconf = 0;
308      server.cluster = zmalloc(sizeof(clusterState));
309      server.cluster->myself = NULL;
310      server.cluster->currentEpoch = 0;
311      server.cluster->state = CLUSTER_FAIL;
312      server.cluster->size = 1;
313      server.cluster->todo_before_sleep = 0;
314      server.cluster->nodes = dictCreate(&clusterNodesDictType,NULL);
315      server.cluster->nodes_black_list =
316          dictCreate(&clusterNodesBlackListDictType,NULL);
317      server.cluster->failover_auth_time = 0;
318      server.cluster->failover_auth_count = 0;
319      server.cluster->failover_auth_rank = 0;
320      server.cluster->failover_auth_epoch = 0;
321      server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
322      server.cluster->lastVoteEpoch = 0;
323      for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
324          server.cluster->stats_bus_messages_sent[i] = 0;
325          server.cluster->stats_bus_messages_received[i] = 0;
326      }
327      server.cluster->stats_pfail_nodes = 0;
328      memset(server.cluster->slots,0, sizeof(server.cluster->slots));
329      clusterCloseAllSlots();
330  #ifndef WIN32   
331      if (clusterLockConfig(server.cluster_configfile) == C_ERR)
332          exit(1);
333  #endif
334      if (clusterLoadConfig(server.cluster_configfile) == C_ERR) {
335          myself = server.cluster->myself =
336              createClusterNode(NULL,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);
337          serverLog(LL_NOTICE,"No cluster configuration found, I'm %.40s",
338              myself->name);
339          clusterAddNode(myself);
340          saveconf = 1;
341      }
342      if (saveconf) clusterSaveConfigOrDie(1);
343      server.cfd_count = 0;
344      if (server.port > (65535-CLUSTER_PORT_INCR)) {
345          serverLog(LL_WARNING, "Redis port number too high. "
346                     "Cluster communication port is 10,000 port "
347                     "numbers higher than your Redis port. "
348                     "Your Redis port number must be "
349                     "lower than 55535.");
350          exit(1);
351      }
352      if (listenToPort(server.port+CLUSTER_PORT_INCR,
353          server.cfd,&server.cfd_count) == C_ERR)
354      {
355          exit(1);
356      } else {
357          int j;
358          for (j = 0; j < server.cfd_count; j++) {
359              if (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,
360                  clusterAcceptHandler, NULL) == AE_ERR)
361                      serverPanic("Unrecoverable error creating Redis Cluster "
362                                  "file event.");
363          }
364      }
365      server.cluster->slots_to_keys = raxNew();
366      memset(server.cluster->slots_keys_count,0,
367             sizeof(server.cluster->slots_keys_count));
368      myself->port = server.port;
369      myself->cport = server.port+CLUSTER_PORT_INCR;
370      if (server.cluster_announce_port)
371          myself->port = server.cluster_announce_port;
372      if (server.cluster_announce_bus_port)
373          myself->cport = server.cluster_announce_bus_port;
374      server.cluster->mf_end = 0;
375      resetManualFailover();
376      clusterUpdateMyselfFlags();
377  }
378  void clusterReset(int hard) {
379      dictIterator *di;
380      dictEntry *de;
381      int j;
382      if (nodeIsSlave(myself)) {
383          clusterSetNodeAsMaster(myself);
384          replicationUnsetMaster();
385          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
386      }
387      clusterCloseAllSlots();
388      resetManualFailover();
389      for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);
390      di = dictGetSafeIterator(server.cluster->nodes);
391      while((de = dictNext(di)) != NULL) {
392          clusterNode *node = dictGetVal(de);
393          if (node == myself) continue;
394          clusterDelNode(node);
395      }
396      dictReleaseIterator(di);
397      if (hard) {
398          sds oldname;
399          server.cluster->currentEpoch = 0;
400          server.cluster->lastVoteEpoch = 0;
401          myself->configEpoch = 0;
402          serverLog(LL_WARNING, "configEpoch set to 0 via CLUSTER RESET HARD");
403          oldname = sdsnewlen(myself->name, CLUSTER_NAMELEN);
404          dictDelete(server.cluster->nodes,oldname);
405          sdsfree(oldname);
406          getRandomHexChars(myself->name, CLUSTER_NAMELEN);
407          clusterAddNode(myself);
408          serverLog(LL_NOTICE,"Node hard reset, now I'm %.40s", myself->name);
409      }
410      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
411                           CLUSTER_TODO_UPDATE_STATE|
412                           CLUSTER_TODO_FSYNC_CONFIG);
413  }
414  clusterLink *createClusterLink(clusterNode *node) {
415      clusterLink *link = zmalloc(sizeof(*link));
416      link->ctime = mstime();
417      link->sndbuf = sdsempty();
418      link->rcvbuf = sdsempty();
419      link->node = node;
420      link->fd = -1;
421      return link;
422  }
423  void freeClusterLink(clusterLink *link) {
424      if (link->fd != -1) {
425          aeDeleteFileEvent(server.el, link->fd, AE_READABLE|AE_WRITABLE);
426      }
427      sdsfree(link->sndbuf);
428      sdsfree(link->rcvbuf);
429      if (link->node)
430          link->node->link = NULL;
431      close(link->fd);
432      zfree(link);
433  }
434  #define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
435  void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
436      int cport, cfd;
437      int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
438      char cip[NET_IP_STR_LEN];
439      clusterLink *link;
440      UNUSED(el);
441      UNUSED(mask);
442      UNUSED(privdata);
443  #ifndef _WIN32
444      if (server.masterhost == NULL && server.loading) return;
445  #else
446      if (server.masterhost == NULL && server.loading) {
447          WSIOCP_QueueAccept(fd);
448          return;
449      }
450  #endif
451      while(max--) {
452          cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
453          if (cfd == ANET_ERR) {
454              if (errno != EWOULDBLOCK)
455                  serverLog(LL_VERBOSE,
456                      "Error accepting cluster node: %s", server.neterr);
457  #ifdef _WIN32
458              if (WSIOCP_QueueAccept(fd) == -1) {
459                  serverLog(LL_WARNING,
460                      "acceptTcpHandler: failed to queue another accept.");
461              }
462  #endif
463              return;
464          }
465          anetNonBlock(NULL,cfd);
466          anetEnableTcpNoDelay(NULL,cfd);
467          serverLog(LL_VERBOSE,"Accepted cluster node %s:%d", cip, cport);
468          link = createClusterLink(NULL);
469          link->fd = cfd;
470          aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
471      }
472  }
473  unsigned int keyHashSlot(char *key, int keylen) {
474      int s, e; &bsol;* start-end indexes of { and } */
475      for (s = 0; s < keylen; s++)
476          if (key[s] == '{') break;
477      if (s == keylen) return crc16(key,keylen) & 0x3FFF;
478      for (e = s+1; e < keylen; e++)
479          if (key[e] == '}') break;
480      if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
481      return crc16(key+s+1,e-s-1) & 0x3FFF;
482  }
483  clusterNode *createClusterNode(char *nodename, int flags) {
484      clusterNode *node = zmalloc(sizeof(*node));
485      if (nodename)
486          memcpy(node->name, nodename, CLUSTER_NAMELEN);
487      else
488          getRandomHexChars(node->name, CLUSTER_NAMELEN);
489      node->ctime = mstime();
490      node->configEpoch = 0;
491      node->flags = flags;
492      memset(node->slots,0,sizeof(node->slots));
493      node->numslots = 0;
494      node->numslaves = 0;
495      node->slaves = NULL;
496      node->slaveof = NULL;
497      node->ping_sent = node->pong_received = 0;
498      node->data_received = 0;
499      node->fail_time = 0;
500      node->link = NULL;
501      memset(node->ip,0,sizeof(node->ip));
502      node->port = 0;
503      node->cport = 0;
504      node->fail_reports = listCreate();
505      node->voted_time = 0;
506      node->orphaned_time = 0;
507      node->repl_offset_time = 0;
508      node->repl_offset = 0;
509      listSetFreeMethod(node->fail_reports,zfree);
510      return node;
511  }
512  int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
513      list *l = failing->fail_reports;
514      listNode *ln;
515      listIter li;
516      clusterNodeFailReport *fr;
517      listRewind(l,&li);
518      while ((ln = listNext(&li)) != NULL) {
519          fr = ln->value;
520          if (fr->node == sender) {
521              fr->time = mstime();
522              return 0;
523          }
524      }
525      fr = zmalloc(sizeof(*fr));
526      fr->node = sender;
527      fr->time = mstime();
528      listAddNodeTail(l,fr);
529      return 1;
530  }
531  void clusterNodeCleanupFailureReports(clusterNode *node) {
532      list *l = node->fail_reports;
533      listNode *ln;
534      listIter li;
535      clusterNodeFailReport *fr;
536      mstime_t maxtime = server.cluster_node_timeout *
537                       CLUSTER_FAIL_REPORT_VALIDITY_MULT;
538      mstime_t now = mstime();
539      listRewind(l,&li);
540      while ((ln = listNext(&li)) != NULL) {
541          fr = ln->value;
542          if (now - fr->time > maxtime) listDelNode(l,ln);
543      }
544  }
545  int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
546      list *l = node->fail_reports;
547      listNode *ln;
548      listIter li;
549      clusterNodeFailReport *fr;
550      listRewind(l,&li);
551      while ((ln = listNext(&li)) != NULL) {
552          fr = ln->value;
553          if (fr->node == sender) break;
554      }
555      if (!ln) return 0; &bsol;* No failure report from this sender. */
556      listDelNode(l,ln);
557      clusterNodeCleanupFailureReports(node);
558      return 1;
559  }
560  int clusterNodeFailureReportsCount(clusterNode *node) {
561      clusterNodeCleanupFailureReports(node);
562      return (int)listLength(node->fail_reports);                                WIN_PORT_FIX &bsol;* cast (int) */
563  }
564  int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
565      int j;
566      for (j = 0; j < master->numslaves; j++) {
567          if (master->slaves[j] == slave) {
568              if ((j+1) < master->numslaves) {
569                  int remaining_slaves = (master->numslaves - j) - 1;
570                  memmove(master->slaves+j,master->slaves+(j+1),
571                          (sizeof(*master->slaves) * remaining_slaves));
572              }
573              master->numslaves--;
574              if (master->numslaves == 0)
575                  master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
576              return C_OK;
577          }
578      }
579      return C_ERR;
580  }
581  int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
582      int j;
583      for (j = 0; j < master->numslaves; j++)
584          if (master->slaves[j] == slave) return C_ERR;
585      master->slaves = zrealloc(master->slaves,
586          sizeof(clusterNode*)*(master->numslaves+1));
587      master->slaves[master->numslaves] = slave;
588      master->numslaves++;
589      master->flags |= CLUSTER_NODE_MIGRATE_TO;
590      return C_OK;
591  }
592  int clusterCountNonFailingSlaves(clusterNode *n) {
593      int j, okslaves = 0;
594      for (j = 0; j < n->numslaves; j++)
595          if (!nodeFailed(n->slaves[j])) okslaves++;
596      return okslaves;
597  }
598  void freeClusterNode(clusterNode *n) {
599      sds nodename;
600      int j;
601      for (j = 0; j < n->numslaves; j++)
602          n->slaves[j]->slaveof = NULL;
603      if (nodeIsSlave(n) && n->slaveof) clusterNodeRemoveSlave(n->slaveof,n);
604      nodename = sdsnewlen(n->name, CLUSTER_NAMELEN);
605      serverAssert(dictDelete(server.cluster->nodes,nodename) == DICT_OK);
606      sdsfree(nodename);
607      if (n->link) freeClusterLink(n->link);
608      listRelease(n->fail_reports);
609      zfree(n->slaves);
610      zfree(n);
611  }
612  int clusterAddNode(clusterNode *node) {
613      int retval;
614      retval = dictAdd(server.cluster->nodes,
615              sdsnewlen(node->name,CLUSTER_NAMELEN), node);
616      return (retval == DICT_OK) ? C_OK : C_ERR;
617  }
618  void clusterDelNode(clusterNode *delnode) {
619      int j;
620      dictIterator *di;
621      dictEntry *de;
622      for (j = 0; j < CLUSTER_SLOTS; j++) {
623          if (server.cluster->importing_slots_from[j] == delnode)
624              server.cluster->importing_slots_from[j] = NULL;
625          if (server.cluster->migrating_slots_to[j] == delnode)
626              server.cluster->migrating_slots_to[j] = NULL;
627          if (server.cluster->slots[j] == delnode)
628              clusterDelSlot(j);
629      }
630      di = dictGetSafeIterator(server.cluster->nodes);
631      while((de = dictNext(di)) != NULL) {
632          clusterNode *node = dictGetVal(de);
633          if (node == delnode) continue;
634          clusterNodeDelFailureReport(node,delnode);
635      }
636      dictReleaseIterator(di);
637      freeClusterNode(delnode);
638  }
639  clusterNode *clusterLookupNode(const char *name) {
640      sds s = sdsnewlen(name, CLUSTER_NAMELEN);
641      dictEntry *de;
642      de = dictFind(server.cluster->nodes,s);
643      sdsfree(s);
644      if (de == NULL) return NULL;
645      return dictGetVal(de);
646  }
647  void clusterRenameNode(clusterNode *node, char *newname) {
648      int retval;
649      sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);
650      serverLog(LL_DEBUG,"Renaming node %.40s into %.40s",
651          node->name, newname);
652      retval = dictDelete(server.cluster->nodes, s);
653      sdsfree(s);
654      serverAssert(retval == DICT_OK);
655      memcpy(node->name, newname, CLUSTER_NAMELEN);
656      clusterAddNode(node);
657  }
658  uint64_t clusterGetMaxEpoch(void) {
659      uint64_t max = 0;
660      dictIterator *di;
661      dictEntry *de;
662      di = dictGetSafeIterator(server.cluster->nodes);
663      while((de = dictNext(di)) != NULL) {
664          clusterNode *node = dictGetVal(de);
665          if (node->configEpoch > max) max = node->configEpoch;
666      }
667      dictReleaseIterator(di);
668      if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
669      return max;
670  }
671  int clusterBumpConfigEpochWithoutConsensus(void) {
672      uint64_t maxEpoch = clusterGetMaxEpoch();
673      if (myself->configEpoch == 0 ||
674          myself->configEpoch != maxEpoch)
675      {
676          server.cluster->currentEpoch++;
677          myself->configEpoch = server.cluster->currentEpoch;
678          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
679                               CLUSTER_TODO_FSYNC_CONFIG);
680          serverLog(LL_WARNING,
681              "New configEpoch set to %llu",
682              (PORT_ULONGLONG) myself->configEpoch);
683          return C_OK;
684      } else {
685          return C_ERR;
686      }
687  }
688  void clusterHandleConfigEpochCollision(clusterNode *sender) {
689      if (sender->configEpoch != myself->configEpoch ||
690          !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
691      if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
692      server.cluster->currentEpoch++;
693      myself->configEpoch = server.cluster->currentEpoch;
694      clusterSaveConfigOrDie(1);
695      serverLog(LL_VERBOSE,
696          "WARNING: configEpoch collision with node %.40s."
697          " configEpoch set to %llu",
698          sender->name,
699          (PORT_ULONGLONG) myself->configEpoch);
700  }
701  #define CLUSTER_BLACKLIST_TTL 60      &bsol;* 1 minute. */
702  void clusterBlacklistCleanup(void) {
703      dictIterator *di;
704      dictEntry *de;
705      di = dictGetSafeIterator(server.cluster->nodes_black_list);
706      while((de = dictNext(di)) != NULL) {
707          int64_t expire = dictGetUnsignedIntegerVal(de);
708          if (expire < server.unixtime)
709              dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
710      }
711      dictReleaseIterator(di);
712  }
713  void clusterBlacklistAddNode(clusterNode *node) {
714      dictEntry *de;
715      sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);
716      clusterBlacklistCleanup();
717      if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
718          id = sdsdup(id);
719      }
720      de = dictFind(server.cluster->nodes_black_list,id);
721      dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
722      sdsfree(id);
723  }
724  int clusterBlacklistExists(char *nodeid) {
725      sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
726      int retval;
727      clusterBlacklistCleanup();
728      retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
729      sdsfree(id);
730      return retval;
731  }
732  void markNodeAsFailingIfNeeded(clusterNode *node) {
733      int failures;
734      int needed_quorum = (server.cluster->size / 2) + 1;
735      if (!nodeTimedOut(node)) return; &bsol;* We can reach it. */
736      if (nodeFailed(node)) return; &bsol;* Already FAILing. */
737      failures = clusterNodeFailureReportsCount(node);
738      if (nodeIsMaster(myself)) failures++;
739      if (failures < needed_quorum) return; &bsol;* No weak agreement from masters. */
740      serverLog(LL_NOTICE,
741          "Marking node %.40s as failing (quorum reached).", node->name);
742      node->flags &= ~CLUSTER_NODE_PFAIL;
743      node->flags |= CLUSTER_NODE_FAIL;
744      node->fail_time = mstime();
745      if (nodeIsMaster(myself)) clusterSendFail(node->name);
746      clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
747  }
748  void clearNodeFailureIfNeeded(clusterNode *node) {
749      mstime_t now = mstime();
750      serverAssert(nodeFailed(node));
751      if (nodeIsSlave(node) || node->numslots == 0) {
752          serverLog(LL_NOTICE,
753              "Clear FAIL state for node %.40s: %s is reachable again.",
754                  node->name,
755                  nodeIsSlave(node) ? "replica" : "master without slots");
756          node->flags &= ~CLUSTER_NODE_FAIL;
757          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
758      }
759      if (nodeIsMaster(node) && node->numslots > 0 &&
760          (now - node->fail_time) >
761          (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MULT))
762      {
763          serverLog(LL_NOTICE,
764              "Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after some time.",
765                  node->name);
766          node->flags &= ~CLUSTER_NODE_FAIL;
767          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
768      }
769  }
770  int clusterHandshakeInProgress(char *ip, int port, int cport) {
771      dictIterator *di;
772      dictEntry *de;
<span onclick='openModal()' class='match'>773      di = dictGetSafeIterator(server.cluster->nodes);
774      while((de = dictNext(di)) != NULL) {
775          clusterNode *node = dictGetVal(de);
</span>776          if (!nodeInHandshake(node)) continue;
777          if (!strcasecmp(node->ip,ip) &&
778              node->port == port &&
779              node->cport == cport) break;
780      }
781      dictReleaseIterator(di);
782      return de != NULL;
783  }
784  int clusterStartHandshake(char *ip, int port, int cport) {
785      clusterNode *n;
786      char norm_ip[NET_IP_STR_LEN];
787      struct sockaddr_storage sa;
788      if (inet_pton(AF_INET,ip,
789              &(((struct sockaddr_in *)&sa)->sin_addr)))
790      {
791          sa.ss_family = AF_INET;
792      } else if (inet_pton(AF_INET6,ip,
793              &(((struct sockaddr_in6 *)&sa)->sin6_addr)))
794      {
795          sa.ss_family = AF_INET6;
796      } else {
797          errno = EINVAL;
798          return 0;
799      }
800      if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
801          errno = EINVAL;
802          return 0;
803      }
804      memset(norm_ip,0,NET_IP_STR_LEN);
805      if (sa.ss_family == AF_INET)
806          inet_ntop(AF_INET,
807              (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
808              norm_ip,NET_IP_STR_LEN);
809      else
810          inet_ntop(AF_INET6,
811              (void*)&(((struct sockaddr_in6 *)&sa)->sin6_addr),
812              norm_ip,NET_IP_STR_LEN);
813      if (clusterHandshakeInProgress(norm_ip,port,cport)) {
814          errno = EAGAIN;
815          return 0;
816      }
817      n = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
818      memcpy(n->ip,norm_ip,sizeof(n->ip));
819      n->port = port;
820      n->cport = cport;
821      clusterAddNode(n);
822      return 1;
823  }
824  void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
825      uint16_t count = ntohs(hdr->count);
826      clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
827      clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender);
828      while(count--) {
829          uint16_t flags = ntohs(g->flags);
830          clusterNode *node;
831          sds ci;
832          if (server.verbosity == LL_DEBUG) {
833              ci = representClusterNodeFlags(sdsempty(), flags);
834              serverLog(LL_DEBUG,"GOSSIP %.40s %s:%d@%d %s",
835                  g->nodename,
836                  g->ip,
837                  ntohs(g->port),
838                  ntohs(g->cport),
839                  ci);
840              sdsfree(ci);
841          }
842          node = clusterLookupNode(g->nodename);
843          if (node) {
844              if (sender && nodeIsMaster(sender) && node != myself) {
845                  if (flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) {
846                      if (clusterNodeAddFailureReport(node,sender)) {
847                          serverLog(LL_VERBOSE,
848                              "Node %.40s reported node %.40s as not reachable.",
849                              sender->name, node->name);
850                      }
851                      markNodeAsFailingIfNeeded(node);
852                  } else {
853                      if (clusterNodeDelFailureReport(node,sender)) {
854                          serverLog(LL_VERBOSE,
855                              "Node %.40s reported node %.40s is back online.",
856                              sender->name, node->name);
857                      }
858                  }
859              }
860              if (!(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
861                  node->ping_sent == 0 &&
862                  clusterNodeFailureReportsCount(node) == 0)
863              {
864                  mstime_t pongtime = ntohl(g->pong_received);
865                  pongtime *= 1000; &bsol;* Convert back to milliseconds. */
866                  if (pongtime <= (server.mstime+500) &&
867                      pongtime > node->pong_received)
868                  {
869                      node->pong_received = pongtime;
870                  }
871              }
872              if (node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) &&
873                  !(flags & CLUSTER_NODE_NOADDR) &&
874                  !(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
875                  (strcasecmp(node->ip,g->ip) ||
876                   node->port != ntohs(g->port) ||
877                   node->cport != ntohs(g->cport)))
878              {
879                  if (node->link) freeClusterLink(node->link);
880                  memcpy(node->ip,g->ip,NET_IP_STR_LEN);
881                  node->port = ntohs(g->port);
882                  node->cport = ntohs(g->cport);
883                  node->flags &= ~CLUSTER_NODE_NOADDR;
884              }
885          } else {
886              if (sender &&
887                  !(flags & CLUSTER_NODE_NOADDR) &&
888                  !clusterBlacklistExists(g->nodename))
889              {
890                  clusterNode *node;
891                  node = createClusterNode(g->nodename, flags);
892                  memcpy(node->ip,g->ip,NET_IP_STR_LEN);
893                  node->port = ntohs(g->port);
894                  node->cport = ntohs(g->cport);
895                  clusterAddNode(node);
896              }
897          }
898          g++;
899      }
900  }
901  void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
902      if (announced_ip[0] != '\0') {
903          memcpy(buf,announced_ip,NET_IP_STR_LEN);
904          buf[NET_IP_STR_LEN-1] = '\0'; &bsol;* We are not sure the input is sane. */
905      } else {
906          anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
907      }
908  }
909  int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
910                                clusterMsg *hdr)
911  {
912      char ip[NET_IP_STR_LEN] = {0};
913      int port = ntohs(hdr->port);
914      int cport = ntohs(hdr->cport);
915      if (link == node->link) return 0;
916      nodeIp2String(ip,link,hdr->myip);
917      if (node->port == port && node->cport == cport &&
918          strcmp(ip,node->ip) == 0) return 0;
919      memcpy(node->ip,ip,sizeof(ip));
920      node->port = port;
921      node->cport = cport;
922      if (node->link) freeClusterLink(node->link);
923      node->flags &= ~CLUSTER_NODE_NOADDR;
924      serverLog(LL_WARNING,"Address updated for node %.40s, now %s:%d",
925          node->name, node->ip, node->port);
926      if (nodeIsSlave(myself) && myself->slaveof == node)
927          replicationSetMaster(node->ip, node->port);
928      return 1;
929  }
930  void clusterSetNodeAsMaster(clusterNode *n) {
931      if (nodeIsMaster(n)) return;
932      if (n->slaveof) {
933          clusterNodeRemoveSlave(n->slaveof,n);
934          if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
935      }
936      n->flags &= ~CLUSTER_NODE_SLAVE;
937      n->flags |= CLUSTER_NODE_MASTER;
938      n->slaveof = NULL;
939      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
940                           CLUSTER_TODO_UPDATE_STATE);
941  }
942  void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
943      int j;
944      clusterNode *curmaster, *newmaster = NULL;
945      uint16_t dirty_slots[CLUSTER_SLOTS];
946      int dirty_slots_count = 0;
947      curmaster = nodeIsMaster(myself) ? myself : myself->slaveof;
948      if (sender == myself) {
949          serverLog(LL_WARNING,"Discarding UPDATE message about myself.");
950          return;
951      }
952      for (j = 0; j < CLUSTER_SLOTS; j++) {
953          if (bitmapTestBit(slots,j)) {
954              if (server.cluster->slots[j] == sender) continue;
955              if (server.cluster->importing_slots_from[j]) continue;
956              if (server.cluster->slots[j] == NULL ||
957                  server.cluster->slots[j]->configEpoch < senderConfigEpoch)
958              {
959                  if (server.cluster->slots[j] == myself &&
960                      countKeysInSlot(j) &&
961                      sender != myself)
962                  {
963                      dirty_slots[dirty_slots_count] = j;
964                      dirty_slots_count++;
965                  }
966                  if (server.cluster->slots[j] == curmaster)
967                      newmaster = sender;
968                  clusterDelSlot(j);
969                  clusterAddSlot(sender,j);
970                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
971                                       CLUSTER_TODO_UPDATE_STATE|
972                                       CLUSTER_TODO_FSYNC_CONFIG);
973              }
974          }
975      }
976      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
977          return;
978      if (newmaster && curmaster->numslots == 0) {
979          serverLog(LL_WARNING,
980              "Configuration change detected. Reconfiguring myself "
981              "as a replica of %.40s", sender->name);
982          clusterSetMaster(sender);
983          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
984                               CLUSTER_TODO_UPDATE_STATE|
985                               CLUSTER_TODO_FSYNC_CONFIG);
986      } else if (dirty_slots_count) {
987          for (j = 0; j < dirty_slots_count; j++)
988              delKeysInSlot(dirty_slots[j]);
989      }
990  }
991  int clusterProcessPacket(clusterLink *link) {
992      clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
993      uint32_t totlen = ntohl(hdr->totlen);
994      uint16_t type = ntohs(hdr->type);
995      mstime_t now = mstime();
996      if (type < CLUSTERMSG_TYPE_COUNT)
997          server.cluster->stats_bus_messages_received[type]++;
998      serverLog(LL_DEBUG,"--- Processing packet of type %d, %Iu bytes", WIN_PORT_FIX &bsol;* %lu -> %Iu */
999          type, (PORT_ULONG) totlen);
1000      if (totlen < 16) return 1; &bsol;* At least signature, version, totlen, count. */
1001      if (totlen > sdslen(link->rcvbuf)) return 1;
1002      if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {
1003          return 1;
1004      }
1005      uint16_t flags = ntohs(hdr->flags);
1006      uint64_t senderCurrentEpoch = 0, senderConfigEpoch = 0;
1007      clusterNode *sender;
1008      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||
1009          type == CLUSTERMSG_TYPE_MEET)
1010      {
1011          uint16_t count = ntohs(hdr->count);
1012          uint32_t explen; &bsol;* expected length of this packet */
1013          explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1014          explen += (sizeof(clusterMsgDataGossip)*count);
1015          if (totlen != explen) return 1;
1016      } else if (type == CLUSTERMSG_TYPE_FAIL) {
1017          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1018          explen += sizeof(clusterMsgDataFail);
1019          if (totlen != explen) return 1;
1020      } else if (type == CLUSTERMSG_TYPE_PUBLISH) {
1021          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1022          explen += sizeof(clusterMsgDataPublish) -
1023                  8 +
1024                  ntohl(hdr->data.publish.msg.channel_len) +
1025                  ntohl(hdr->data.publish.msg.message_len);
1026          if (totlen != explen) return 1;
1027      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST ||
1028                 type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK ||
1029                 type == CLUSTERMSG_TYPE_MFSTART)
1030      {
1031          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1032          if (totlen != explen) return 1;
1033      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1034          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1035          explen += sizeof(clusterMsgDataUpdate);
1036          if (totlen != explen) return 1;
1037      } else if (type == CLUSTERMSG_TYPE_MODULE) {
1038          uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1039          explen += sizeof(clusterMsgDataPublish) -
1040                  3 + ntohl(hdr->data.module.msg.len);
1041          if (totlen != explen) return 1;
1042      }
1043      sender = clusterLookupNode(hdr->sender);
1044      if (sender) sender->data_received = now;
1045      if (sender && !nodeInHandshake(sender)) {
1046          senderCurrentEpoch = ntohu64(hdr->currentEpoch);
1047          senderConfigEpoch = ntohu64(hdr->configEpoch);
1048          if (senderCurrentEpoch > server.cluster->currentEpoch)
1049              server.cluster->currentEpoch = senderCurrentEpoch;
1050          if (senderConfigEpoch > sender->configEpoch) {
1051              sender->configEpoch = senderConfigEpoch;
1052              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1053                                   CLUSTER_TODO_FSYNC_CONFIG);
1054          }
1055          sender->repl_offset = ntohu64(hdr->offset);
1056          sender->repl_offset_time = now;
1057          if (server.cluster->mf_end &&
1058              nodeIsSlave(myself) &&
1059              myself->slaveof == sender &&
1060              hdr->mflags[0] & CLUSTERMSG_FLAG0_PAUSED &&
1061              server.cluster->mf_master_offset == 0)
1062          {
1063              server.cluster->mf_master_offset = sender->repl_offset;
1064              serverLog(LL_WARNING,
1065                  "Received replication offset for paused "
1066                  "master manual failover: %lld",
1067                  server.cluster->mf_master_offset);
1068          }
1069      }
1070      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) {
1071          serverLog(LL_DEBUG,"Ping packet received: %p", (void*)link->node);
1072          if ((type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\0') &&
1073              server.cluster_announce_ip == NULL)
1074          {
1075              char ip[NET_IP_STR_LEN];
1076              if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&
1077                  strcmp(ip,myself->ip))
1078              {
1079                  memcpy(myself->ip,ip,NET_IP_STR_LEN);
1080                  serverLog(LL_WARNING,"IP address for this node updated to %s",
1081                      myself->ip);
1082                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1083              }
1084          }
1085          if (!sender && type == CLUSTERMSG_TYPE_MEET) {
1086              clusterNode *node;
1087              node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);
1088              nodeIp2String(node->ip,link,hdr->myip);
1089              node->port = ntohs(hdr->port);
1090              node->cport = ntohs(hdr->cport);
1091              clusterAddNode(node);
1092              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1093          }
1094          if (!sender && type == CLUSTERMSG_TYPE_MEET)
1095              clusterProcessGossipSection(hdr,link);
1096          clusterSendPing(link,CLUSTERMSG_TYPE_PONG);
1097      }
1098      if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||
1099          type == CLUSTERMSG_TYPE_MEET)
1100      {
1101          serverLog(LL_DEBUG,"%s packet received: %p",
1102              type == CLUSTERMSG_TYPE_PING ? "ping" : "pong",
1103              (void*)link->node);
1104          if (link->node) {
1105              if (nodeInHandshake(link->node)) {
1106                  if (sender) {
1107                      serverLog(LL_VERBOSE,
1108                          "Handshake: we already know node %.40s, "
1109                          "updating the address if needed.", sender->name);
1110                      if (nodeUpdateAddressIfNeeded(sender,link,hdr))
1111                      {
1112                          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1113                                               CLUSTER_TODO_UPDATE_STATE);
1114                      }
1115                      clusterDelNode(link->node);
1116                      return 0;
1117                  }
1118                  clusterRenameNode(link->node, hdr->sender);
1119                  serverLog(LL_DEBUG,"Handshake with node %.40s completed.",
1120                      link->node->name);
1121                  link->node->flags &= ~CLUSTER_NODE_HANDSHAKE;
1122                  link->node->flags |= flags&(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);
1123                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1124              } else if (memcmp(link->node->name,hdr->sender,
1125                          CLUSTER_NAMELEN) != 0)
1126              {
1127                  serverLog(LL_DEBUG,"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d",
1128                      link->node->name,
1129                      (int)(now-(link->node->ctime)),
1130                      link->node->flags);
1131                  link->node->flags |= CLUSTER_NODE_NOADDR;
1132                  link->node->ip[0] = '\0';
1133                  link->node->port = 0;
1134                  link->node->cport = 0;
1135                  freeClusterLink(link);
1136                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1137                  return 0;
1138              }
1139          }
1140          if (sender) {
1141              int nofailover = flags & CLUSTER_NODE_NOFAILOVER;
1142              sender->flags &= ~CLUSTER_NODE_NOFAILOVER;
1143              sender->flags |= nofailover;
1144          }
1145          if (sender && type == CLUSTERMSG_TYPE_PING &&
1146              !nodeInHandshake(sender) &&
1147              nodeUpdateAddressIfNeeded(sender,link,hdr))
1148          {
1149              clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1150                                   CLUSTER_TODO_UPDATE_STATE);
1151          }
1152          if (link->node && type == CLUSTERMSG_TYPE_PONG) {
1153              link->node->pong_received = now;
1154              link->node->ping_sent = 0;
1155              if (nodeTimedOut(link->node)) {
1156                  link->node->flags &= ~CLUSTER_NODE_PFAIL;
1157                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1158                                       CLUSTER_TODO_UPDATE_STATE);
1159              } else if (nodeFailed(link->node)) {
1160                  clearNodeFailureIfNeeded(link->node);
1161              }
1162          }
1163          if (sender) {
1164              if (!memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,
1165                  sizeof(hdr->slaveof)))
1166              {
1167                  clusterSetNodeAsMaster(sender);
1168              } else {
1169                  clusterNode *master = clusterLookupNode(hdr->slaveof);
1170                  if (nodeIsMaster(sender)) {
1171                      clusterDelNodeSlots(sender);
1172                      sender->flags &= ~(CLUSTER_NODE_MASTER|
1173                                         CLUSTER_NODE_MIGRATE_TO);
1174                      sender->flags |= CLUSTER_NODE_SLAVE;
1175                      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1176                                           CLUSTER_TODO_UPDATE_STATE);
1177                  }
1178                  if (master && sender->slaveof != master) {
1179                      if (sender->slaveof)
1180                          clusterNodeRemoveSlave(sender->slaveof,sender);
1181                      clusterNodeAddSlave(master,sender);
1182                      sender->slaveof = master;
1183                      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
1184                  }
1185              }
1186          }
1187          clusterNode *sender_master = NULL; &bsol;* Sender or its master if slave. */
1188          int dirty_slots = 0; &bsol;* Sender claimed slots don't match my view? */
1189          if (sender) {
1190              sender_master = nodeIsMaster(sender) ? sender : sender->slaveof;
1191              if (sender_master) {
1192                  dirty_slots = memcmp(sender_master->slots,
1193                          hdr->myslots,sizeof(hdr->myslots)) != 0;
1194              }
1195          }
1196          if (sender && nodeIsMaster(sender) && dirty_slots)
1197              clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots);
1198          if (sender && dirty_slots) {
1199              int j;
1200              for (j = 0; j < CLUSTER_SLOTS; j++) {
1201                  if (bitmapTestBit(hdr->myslots,j)) {
1202                      if (server.cluster->slots[j] == sender ||
1203                          server.cluster->slots[j] == NULL) continue;
1204                      if (server.cluster->slots[j]->configEpoch >
1205                          senderConfigEpoch)
1206                      {
1207                          serverLog(LL_VERBOSE,
1208                              "Node %.40s has old slots configuration, sending "
1209                              "an UPDATE message about %.40s",
1210                                  sender->name, server.cluster->slots[j]->name);
1211                          clusterSendUpdate(sender->link,
1212                              server.cluster->slots[j]);
1213                          break;
1214                      }
1215                  }
1216              }
1217          }
1218          if (sender &&
1219              nodeIsMaster(myself) && nodeIsMaster(sender) &&
1220              senderConfigEpoch == myself->configEpoch)
1221          {
1222              clusterHandleConfigEpochCollision(sender);
1223          }
1224          if (sender) clusterProcessGossipSection(hdr,link);
1225      } else if (type == CLUSTERMSG_TYPE_FAIL) {
1226          clusterNode *failing;
1227          if (sender) {
1228              failing = clusterLookupNode(hdr->data.fail.about.nodename);
1229              if (failing &&
1230                  !(failing->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_MYSELF)))
1231              {
1232                  serverLog(LL_NOTICE,
1233                      "FAIL message received from %.40s about %.40s",
1234                      hdr->sender, hdr->data.fail.about.nodename);
1235                  failing->flags |= CLUSTER_NODE_FAIL;
1236                  failing->fail_time = now;
1237                  failing->flags &= ~CLUSTER_NODE_PFAIL;
1238                  clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1239                                       CLUSTER_TODO_UPDATE_STATE);
1240              }
1241          } else {
1242              serverLog(LL_NOTICE,
1243                  "Ignoring FAIL message from unknown node %.40s about %.40s",
1244                  hdr->sender, hdr->data.fail.about.nodename);
1245          }
1246      } else if (type == CLUSTERMSG_TYPE_PUBLISH) {
1247          robj *channel, *message;
1248          uint32_t channel_len, message_len;
1249          if (dictSize(server.pubsub_channels) ||
1250             listLength(server.pubsub_patterns))
1251          {
1252              channel_len = ntohl(hdr->data.publish.msg.channel_len);
1253              message_len = ntohl(hdr->data.publish.msg.message_len);
1254              channel = createStringObject(
1255                          (char*)hdr->data.publish.msg.bulk_data,channel_len);
1256              message = createStringObject(
1257                          (char*)hdr->data.publish.msg.bulk_data+channel_len,
1258                          message_len);
1259              pubsubPublishMessage(channel,message);
1260              decrRefCount(channel);
1261              decrRefCount(message);
1262          }
1263      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) {
1264          if (!sender) return 1;  &bsol;* We don't know that node. */
1265          clusterSendFailoverAuthIfNeeded(sender,hdr);
1266      } else if (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) {
1267          if (!sender) return 1;  &bsol;* We don't know that node. */
1268          if (nodeIsMaster(sender) && sender->numslots > 0 &&
1269              senderCurrentEpoch >= server.cluster->failover_auth_epoch)
1270          {
1271              server.cluster->failover_auth_count++;
1272              clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
1273          }
1274      } else if (type == CLUSTERMSG_TYPE_MFSTART) {
1275          if (!sender || sender->slaveof != myself) return 1;
1276          resetManualFailover();
1277          server.cluster->mf_end = now + CLUSTER_MF_TIMEOUT;
1278          server.cluster->mf_slave = sender;
1279          pauseClients(now+(CLUSTER_MF_TIMEOUT*CLUSTER_MF_PAUSE_MULT));
1280          serverLog(LL_WARNING,"Manual failover requested by replica %.40s.",
1281              sender->name);
1282      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1283          clusterNode *n; &bsol;* The node the update is about. */
1284          uint64_t reportedConfigEpoch =
1285                      ntohu64(hdr->data.update.nodecfg.configEpoch);
1286          if (!sender) return 1;  &bsol;* We don't know the sender. */
1287          n = clusterLookupNode(hdr->data.update.nodecfg.nodename);
1288          if (!n) return 1;   &bsol;* We don't know the reported node. */
1289          if (n->configEpoch >= reportedConfigEpoch) return 1; &bsol;* Nothing new. */
1290          if (nodeIsSlave(n)) clusterSetNodeAsMaster(n);
1291          n->configEpoch = reportedConfigEpoch;
1292          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1293                               CLUSTER_TODO_FSYNC_CONFIG);
1294          clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,
1295              hdr->data.update.nodecfg.slots);
1296      } else if (type == CLUSTERMSG_TYPE_MODULE) {
1297          if (!sender) return 1;  &bsol;* Protect the module from unknown nodes. */
1298          uint64_t module_id = hdr->data.module.msg.module_id; &bsol;* Endian-safe ID */
1299          uint32_t len = ntohl(hdr->data.module.msg.len);
1300          uint8_t type = hdr->data.module.msg.type;
1301          unsigned char *payload = hdr->data.module.msg.bulk_data;
1302          moduleCallClusterReceivers(sender->name,module_id,type,payload,len);
1303      } else {
1304          serverLog(LL_WARNING,"Received unknown packet type: %d", type);
1305      }
1306      return 1;
1307  }
1308  void handleLinkIOError(clusterLink *link) {
1309      freeClusterLink(link);
1310  }
1311  #ifdef _WIN32
1312  void clusterWriteDone(aeEventLoop *el, int fd, void *privdata, int written) {
1313      WSIOCP_Request *req = (WSIOCP_Request *) privdata;
1314      clusterLink *link = (clusterLink *) req->client;
1315      UNUSED(el);
1316      UNUSED(fd);
1317      if (sdslen(link->sndbuf) == written) {
1318          sdsrange(link->sndbuf, written, -1);
1319          aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
1320          serverLog(LL_DEBUG, "clusterWriteDone written %d fd %d", written, link->fd);
1321      }
1322  }
1323  void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1324      clusterLink *link = (clusterLink*) privdata;
1325      UNUSED(el);
1326      UNUSED(mask);
1327      int result = WSIOCP_SocketSend(fd,
1328          (char*) link->sndbuf,
1329          (int) (sdslen(link->sndbuf)),
1330          el,
1331          link,
1332          NULL,
1333          clusterWriteDone);
1334      if (errno == WSA_IO_PENDING)
1335          serverLog(LL_DEBUG, "WSA_IO_PENDING writing to socket fd %d", link->fd);
1336      if (result == SOCKET_ERROR && errno != WSA_IO_PENDING) {
1337          serverLog(LL_WARNING, "Error writing to socket fd %d", link->fd);
1338          handleLinkIOError(link);
1339          return;
1340      }
1341  }
1342  #else
1343  void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1344      clusterLink *link = (clusterLink*) privdata;
1345      ssize_t nwritten;
1346      UNUSED(el);
1347      UNUSED(mask);
1348      nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));
1349      if (nwritten <= 0) {
1350          serverLog(LL_DEBUG,"I/O error writing to node link: %s",
1351              (nwritten == -1) ? strerror(errno) : "short write");
1352          handleLinkIOError(link);
1353          return;
1354      }
1355      sdsrange(link->sndbuf,nwritten,-1);
1356      if (sdslen(link->sndbuf) == 0)
1357          aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
1358  }
1359  #endif
1360  void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
1361      char buf[sizeof(clusterMsg)];
1362      ssize_t nread;
1363      clusterMsg *hdr;
1364      clusterLink *link = (clusterLink*) privdata;
1365      unsigned int readlen, rcvbuflen;
1366      UNUSED(el);
1367      UNUSED(mask);
1368      while(1) { &bsol;* Read as long as there is data to read. */
1369          rcvbuflen = (unsigned int) sdslen(link->rcvbuf);                         WIN_PORT_FIX &bsol;* cast (unsigned int) */
1370          if (rcvbuflen < 8) {
1371              readlen = 8 - rcvbuflen;
1372          } else {
1373              hdr = (clusterMsg*) link->rcvbuf;
1374              if (rcvbuflen == 8) {
1375                  if (memcmp(hdr->sig,"RCmb",4) != 0 ||
1376                      ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)
1377                  {
1378                      serverLog(LL_WARNING,
1379                          "Bad message length or signature received "
1380                          "from Cluster bus.");
1381                      handleLinkIOError(link);
1382                      return;
1383                  }
1384              }
1385              readlen = ntohl(hdr->totlen) - rcvbuflen;
1386              if (readlen > sizeof(buf)) readlen = sizeof(buf);
1387          }
1388          nread = read(fd,buf,readlen);
1389          if (nread == -1 && errno == EAGAIN) { WIN32_ONLY(WSIOCP_QueueNextRead(fd);) return; } &bsol;* No more data ready. */
1390          if (nread <= 0) {
1391              serverLog(LL_DEBUG,"I/O error reading from node link: %s",
1392                  (nread == 0) ? "connection closed" : IF_WIN32(wsa_strerror(errno), strerror(errno)));
1393              handleLinkIOError(link);
1394              return;
1395          } else {
1396              link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);
1397              hdr = (clusterMsg*) link->rcvbuf;
1398              rcvbuflen += (unsigned int) nread;                                   WIN_PORT_FIX &bsol;* cast (unsigned int) */
1399          }
1400          if (rcvbuflen >= 8 && rcvbuflen == ntohl(hdr->totlen)) {
1401              if (clusterProcessPacket(link)) {
1402                  sdsfree(link->rcvbuf);
1403                  link->rcvbuf = sdsempty();
1404              } else {
1405                  return; &bsol;* Link no longer valid. */
1406              }
1407          }
1408      }
1409      WIN32_ONLY(WSIOCP_QueueNextRead(fd);)
1410  }
1411  void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
1412      if (sdslen(link->sndbuf) == 0 && msglen != 0)
1413          aeCreateFileEvent(server.el,link->fd,AE_WRITABLE|AE_BARRIER,
1414                      clusterWriteHandler,link);
1415      link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);
1416      clusterMsg *hdr = (clusterMsg*) msg;
1417      uint16_t type = ntohs(hdr->type);
1418      if (type < CLUSTERMSG_TYPE_COUNT)
1419          server.cluster->stats_bus_messages_sent[type]++;
1420  }
1421  void clusterBroadcastMessage(void *buf, size_t len) {
1422      dictIterator *di;
1423      dictEntry *de;
1424      di = dictGetSafeIterator(server.cluster->nodes);
1425      while((de = dictNext(di)) != NULL) {
1426          clusterNode *node = dictGetVal(de);
1427          if (!node->link) continue;
1428          if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
1429              continue;
1430          clusterSendMessage(node->link,buf,len);
1431      }
1432      dictReleaseIterator(di);
1433  }
1434  void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
1435      int totlen = 0;
1436      uint64_t offset;
1437      clusterNode *master;
1438      master = (nodeIsSlave(myself) && myself->slaveof) ?
1439                myself->slaveof : myself;
1440      memset(hdr,0,sizeof(*hdr));
1441      hdr->ver = htons(CLUSTER_PROTO_VER);
1442      hdr->sig[0] = 'R';
1443      hdr->sig[1] = 'C';
1444      hdr->sig[2] = 'm';
1445      hdr->sig[3] = 'b';
1446      hdr->type = htons(type);
1447      memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);
1448      memset(hdr->myip,0,NET_IP_STR_LEN);
1449      if (server.cluster_announce_ip) {
1450          strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);
1451          hdr->myip[NET_IP_STR_LEN-1] = '\0';
1452      }
1453      int announced_port = server.cluster_announce_port ?
1454                           server.cluster_announce_port : server.port;
1455      int announced_cport = server.cluster_announce_bus_port ?
1456                            server.cluster_announce_bus_port :
1457                            (server.port + CLUSTER_PORT_INCR);
1458      memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));
1459      memset(hdr->slaveof,0,CLUSTER_NAMELEN);
1460      if (myself->slaveof != NULL)
1461          memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);
1462      hdr->port = htons(announced_port);
1463      hdr->cport = htons(announced_cport);
1464      hdr->flags = htons(myself->flags);
1465      hdr->state = server.cluster->state;
1466      hdr->currentEpoch = htonu64(server.cluster->currentEpoch);
1467      hdr->configEpoch = htonu64(master->configEpoch);
1468      if (nodeIsSlave(myself))
1469          offset = replicationGetSlaveOffset();
1470      else
1471          offset = server.master_repl_offset;
1472      hdr->offset = htonu64(offset);
1473      if (nodeIsMaster(myself) && server.cluster->mf_end)
1474          hdr->mflags[0] |= CLUSTERMSG_FLAG0_PAUSED;
1475      if (type == CLUSTERMSG_TYPE_FAIL) {
1476          totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1477          totlen += sizeof(clusterMsgDataFail);
1478      } else if (type == CLUSTERMSG_TYPE_UPDATE) {
1479          totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1480          totlen += sizeof(clusterMsgDataUpdate);
1481      }
1482      hdr->totlen = htonl(totlen);
1483  }
1484  int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {
1485      int j;
1486      for (j = 0; j < count; j++) {
1487          if (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
1488                  CLUSTER_NAMELEN) == 0) break;
1489      }
1490      return j != count;
1491  }
1492  void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
1493      clusterMsgDataGossip *gossip;
1494      gossip = &(hdr->data.ping.gossip[i]);
1495      memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
1496      gossip->ping_sent = htonl(n->ping_sent/1000);
1497      gossip->pong_received = htonl(n->pong_received/1000);
1498      memcpy(gossip->ip,n->ip,sizeof(n->ip));
1499      gossip->port = htons(n->port);
1500      gossip->cport = htons(n->cport);
1501      gossip->flags = htons(n->flags);
1502      gossip->notused1 = 0;
1503  }
1504  void clusterSendPing(clusterLink *link, int type) {
1505      unsigned char *buf;
1506      clusterMsg *hdr;
1507      int gossipcount = 0; &bsol;* Number of gossip sections added so far. */
1508      int wanted; &bsol;* Number of gossip sections we want to append if possible. */
1509      int totlen; &bsol;* Total packet length. */
1510      int freshnodes = (int) dictSize(server.cluster->nodes)-2;                    WIN_PORT_FIX &bsol;* cast (int) */
1511      wanted = floor(dictSize(server.cluster->nodes)/10);
1512      if (wanted < 3) wanted = 3;
1513      if (wanted > freshnodes) wanted = freshnodes;
1514      int pfail_wanted = server.cluster->stats_pfail_nodes;
1515      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1516      totlen += (sizeof(clusterMsgDataGossip)*(wanted+pfail_wanted));
1517      if (totlen < (int)sizeof(clusterMsg)) totlen = sizeof(clusterMsg);
1518      buf = zcalloc(totlen);
1519      hdr = (clusterMsg*) buf;
1520      if (link->node && type == CLUSTERMSG_TYPE_PING)
1521          link->node->ping_sent = mstime();
1522      clusterBuildMessageHdr(hdr,type);
1523      int maxiterations = wanted*3;
1524      while(freshnodes > 0 && gossipcount < wanted && maxiterations--) {
1525          dictEntry *de = dictGetRandomKey(server.cluster->nodes);
1526          clusterNode *this = dictGetVal(de);
1527          if (this == myself) continue;
1528          if (this->flags & CLUSTER_NODE_PFAIL) continue;
1529          if (this->flags & (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||
1530              (this->link == NULL && this->numslots == 0))
1531          {
1532              freshnodes--; &bsol;* Tecnically not correct, but saves CPU. */
1533              continue;
1534          }
1535          if (clusterNodeIsInGossipSection(hdr,gossipcount,this)) continue;
1536          clusterSetGossipEntry(hdr,gossipcount,this);
1537          freshnodes--;
1538          gossipcount++;
1539      }
1540      if (pfail_wanted) {
1541          dictIterator *di;
1542          dictEntry *de;
1543          di = dictGetSafeIterator(server.cluster->nodes);
1544          while((de = dictNext(di)) != NULL && pfail_wanted > 0) {
1545              clusterNode *node = dictGetVal(de);
1546              if (node->flags & CLUSTER_NODE_HANDSHAKE) continue;
1547              if (node->flags & CLUSTER_NODE_NOADDR) continue;
1548              if (!(node->flags & CLUSTER_NODE_PFAIL)) continue;
1549              clusterSetGossipEntry(hdr,gossipcount,node);
1550              freshnodes--;
1551              gossipcount++;
1552              pfail_wanted--;
1553          }
1554          dictReleaseIterator(di);
1555      }
1556      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1557      totlen += (sizeof(clusterMsgDataGossip)*gossipcount);
1558      hdr->count = htons(gossipcount);
1559      hdr->totlen = htonl(totlen);
1560      clusterSendMessage(link,buf,totlen);
1561      zfree(buf);
1562  }
1563  #define CLUSTER_BROADCAST_ALL 0
1564  #define CLUSTER_BROADCAST_LOCAL_SLAVES 1
1565  void clusterBroadcastPong(int target) {
1566      dictIterator *di;
1567      dictEntry *de;
1568      di = dictGetSafeIterator(server.cluster->nodes);
1569      while((de = dictNext(di)) != NULL) {
1570          clusterNode *node = dictGetVal(de);
1571          if (!node->link) continue;
1572          if (node == myself || nodeInHandshake(node)) continue;
1573          if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
1574              int local_slave =
1575                  nodeIsSlave(node) && node->slaveof &&
1576                  (node->slaveof == myself || node->slaveof == myself->slaveof);
1577              if (!local_slave) continue;
1578          }
1579          clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
1580      }
1581      dictReleaseIterator(di);
1582  }
1583  void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
1584      unsigned char buf[sizeof(clusterMsg)], *payload;
1585      clusterMsg *hdr = (clusterMsg*) buf;
1586      uint32_t totlen;
1587      uint32_t channel_len, message_len;
1588      channel = getDecodedObject(channel);
1589      message = getDecodedObject(message);
1590      channel_len = (uint32_t) sdslen(channel->ptr);                               WIN_PORT_FIX &bsol;* cast (uint32_t) */
1591      message_len = (uint32_t) sdslen(message->ptr);                               WIN_PORT_FIX &bsol;* cast (uint32_t) */
1592      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_PUBLISH);
1593      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1594      totlen += sizeof(clusterMsgDataPublish) - 8 + channel_len + message_len;
1595      hdr->data.publish.msg.channel_len = htonl(channel_len);
1596      hdr->data.publish.msg.message_len = htonl(message_len);
1597      hdr->totlen = htonl(totlen);
1598      if (totlen < sizeof(buf)) {
1599          payload = buf;
1600      } else {
1601          payload = zmalloc(totlen);
1602          memcpy(payload,hdr,sizeof(*hdr));
1603          hdr = (clusterMsg*) payload;
1604      }
1605      memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));
1606      memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),
1607          message->ptr,sdslen(message->ptr));
1608      if (link)
1609          clusterSendMessage(link,payload,totlen);
1610      else
1611          clusterBroadcastMessage(payload,totlen);
1612      decrRefCount(channel);
1613      decrRefCount(message);
1614      if (payload != buf) zfree(payload);
1615  }
1616  void clusterSendFail(char *nodename) {
1617      unsigned char buf[sizeof(clusterMsg)];
1618      clusterMsg *hdr = (clusterMsg*) buf;
1619      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
1620      memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
1621      clusterBroadcastMessage(buf,ntohl(hdr->totlen));
1622  }
1623  void clusterSendUpdate(clusterLink *link, clusterNode *node) {
1624      unsigned char buf[sizeof(clusterMsg)];
1625      clusterMsg *hdr = (clusterMsg*) buf;
1626      if (link == NULL) return;
1627      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);
1628      memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
1629      hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
1630      memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
1631      clusterSendMessage(link,buf,ntohl(hdr->totlen));
1632  }
1633  void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
1634                         unsigned char *payload, uint32_t len) {
1635      unsigned char buf[sizeof(clusterMsg)], *heapbuf;
1636      clusterMsg *hdr = (clusterMsg*) buf;
1637      uint32_t totlen;
1638      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MODULE);
1639      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1640      totlen += sizeof(clusterMsgModule) - 3 + len;
1641      hdr->data.module.msg.module_id = module_id; &bsol;* Already endian adjusted. */
1642      hdr->data.module.msg.type = type;
1643      hdr->data.module.msg.len = htonl(len);
1644      hdr->totlen = htonl(totlen);
1645      if (totlen < sizeof(buf)) {
1646          heapbuf = buf;
1647      } else {
1648          heapbuf = zmalloc(totlen);
1649          memcpy(heapbuf,hdr,sizeof(*hdr));
1650          hdr = (clusterMsg*) heapbuf;
1651      }
1652      memcpy(hdr->data.module.msg.bulk_data,payload,len);
1653      if (link)
1654          clusterSendMessage(link,heapbuf,totlen);
1655      else
1656          clusterBroadcastMessage(heapbuf,totlen);
1657      if (heapbuf != buf) zfree(heapbuf);
1658  }
1659  int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len) {
1660      clusterNode *node = NULL;
1661      if (target != NULL) {
1662          node = clusterLookupNode(target);
1663          if (node == NULL || node->link == NULL) return C_ERR;
1664      }
1665      clusterSendModule(target ? node->link : NULL,
1666                        module_id, type, payload, len);
1667      return C_OK;
1668  }
1669  void clusterPropagatePublish(robj *channel, robj *message) {
1670      clusterSendPublish(NULL, channel, message);
1671  }
1672  void clusterRequestFailoverAuth(void) {
1673      unsigned char buf[sizeof(clusterMsg)];
1674      clusterMsg *hdr = (clusterMsg*) buf;
1675      uint32_t totlen;
1676      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);
1677      if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;
1678      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1679      hdr->totlen = htonl(totlen);
1680      clusterBroadcastMessage(buf,totlen);
1681  }
1682  void clusterSendFailoverAuth(clusterNode *node) {
1683      unsigned char buf[sizeof(clusterMsg)];
1684      clusterMsg *hdr = (clusterMsg*) buf;
1685      uint32_t totlen;
1686      if (!node->link) return;
1687      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);
1688      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1689      hdr->totlen = htonl(totlen);
1690      clusterSendMessage(node->link,buf,totlen);
1691  }
1692  void clusterSendMFStart(clusterNode *node) {
1693      unsigned char buf[sizeof(clusterMsg)];
1694      clusterMsg *hdr = (clusterMsg*) buf;
1695      uint32_t totlen;
1696      if (!node->link) return;
1697      clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART);
1698      totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
1699      hdr->totlen = htonl(totlen);
1700      clusterSendMessage(node->link,buf,totlen);
1701  }
1702  void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
1703      clusterNode *master = node->slaveof;
1704      uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);
1705      uint64_t requestConfigEpoch = ntohu64(request->configEpoch);
1706      unsigned char *claimed_slots = request->myslots;
1707      int force_ack = request->mflags[0] & CLUSTERMSG_FLAG0_FORCEACK;
1708      int j;
1709      if (nodeIsSlave(myself) || myself->numslots == 0) return;
1710      if (requestCurrentEpoch < server.cluster->currentEpoch) {
1711          serverLog(LL_WARNING,
1712              "Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)",
1713              node->name,
1714              (PORT_ULONGLONG) requestCurrentEpoch,
1715              (PORT_ULONGLONG) server.cluster->currentEpoch);
1716          return;
1717      }
1718      if (server.cluster->lastVoteEpoch == server.cluster->currentEpoch) {
1719          serverLog(LL_WARNING,
1720                  "Failover auth denied to %.40s: already voted for epoch %llu",
1721                  node->name,
1722                  (PORT_ULONGLONG) server.cluster->currentEpoch);
1723          return;
1724      }
1725      if (nodeIsMaster(node) || master == NULL ||
1726          (!nodeFailed(master) && !force_ack))
1727      {
1728          if (nodeIsMaster(node)) {
1729              serverLog(LL_WARNING,
1730                      "Failover auth denied to %.40s: it is a master node",
1731                      node->name);
1732          } else if (master == NULL) {
1733              serverLog(LL_WARNING,
1734                      "Failover auth denied to %.40s: I don't know its master",
1735                      node->name);
1736          } else if (!nodeFailed(master)) {
1737              serverLog(LL_WARNING,
1738                      "Failover auth denied to %.40s: its master is up",
1739                      node->name);
1740          }
1741          return;
1742      }
1743      if (mstime() - node->slaveof->voted_time < server.cluster_node_timeout * 2)
1744      {
1745          serverLog(LL_WARNING,
1746                  "Failover auth denied to %.40s: "
1747                  "can't vote about this master before %lld milliseconds",
1748                  node->name,
1749                  (PORT_LONGLONG) ((server.cluster_node_timeout*2)-
1750                               (mstime() - node->slaveof->voted_time)));
1751          return;
1752      }
1753      for (j = 0; j < CLUSTER_SLOTS; j++) {
1754          if (bitmapTestBit(claimed_slots, j) == 0) continue;
1755          if (server.cluster->slots[j] == NULL ||
1756              server.cluster->slots[j]->configEpoch <= requestConfigEpoch)
1757          {
1758              continue;
1759          }
1760          serverLog(LL_WARNING,
1761                  "Failover auth denied to %.40s: "
1762                  "slot %d epoch (%llu) > reqEpoch (%llu)",
1763                  node->name, j,
1764                  (PORT_ULONGLONG) server.cluster->slots[j]->configEpoch,
1765                  (PORT_ULONGLONG) requestConfigEpoch);
1766          return;
1767      }
1768      server.cluster->lastVoteEpoch = server.cluster->currentEpoch;
1769      node->slaveof->voted_time = mstime();
1770      clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);
1771      clusterSendFailoverAuth(node);
1772      serverLog(LL_WARNING, "Failover auth granted to %.40s for epoch %llu",
1773          node->name, (PORT_ULONGLONG) server.cluster->currentEpoch);
1774  }
1775  int clusterGetSlaveRank(void) {
1776      PORT_LONGLONG myoffset;
1777      int j, rank = 0;
1778      clusterNode *master;
1779      serverAssert(nodeIsSlave(myself));
1780      master = myself->slaveof;
1781      if (master == NULL) return 0; &bsol;* Never called by slaves without master. */
1782      myoffset = replicationGetSlaveOffset();
1783      for (j = 0; j < master->numslaves; j++)
1784          if (master->slaves[j] != myself &&
1785              !nodeCantFailover(master->slaves[j]) &&
1786              master->slaves[j]->repl_offset > myoffset) rank++;
1787      return rank;
1788  }
1789  void clusterLogCantFailover(int reason) {
1790      char *msg;
1791      static time_t lastlog_time = 0;
1792      mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;
1793      if (reason == server.cluster->cant_failover_reason &&
1794          time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
1795          return;
1796      server.cluster->cant_failover_reason = reason;
1797      if (myself->slaveof &&
1798          nodeFailed(myself->slaveof) &&
1799          (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;
1800      switch(reason) {
1801      case CLUSTER_CANT_FAILOVER_DATA_AGE:
1802          msg = "Disconnected from master for longer than allowed. "
1803                "Please check the 'cluster-replica-validity-factor' configuration "
1804                "option.";
1805          break;
1806      case CLUSTER_CANT_FAILOVER_WAITING_DELAY:
1807          msg = "Waiting the delay before I can start a new failover.";
1808          break;
1809      case CLUSTER_CANT_FAILOVER_EXPIRED:
1810          msg = "Failover attempt expired.";
1811          break;
1812      case CLUSTER_CANT_FAILOVER_WAITING_VOTES:
1813          msg = "Waiting for votes, but majority still not reached.";
1814          break;
1815      default:
1816          msg = "Unknown reason code.";
1817          break;
1818      }
1819      lastlog_time = time(NULL);
1820      serverLog(LL_WARNING,"Currently unable to failover: %s", msg);
1821  }
1822  void clusterFailoverReplaceYourMaster(void) {
1823      int j;
1824      clusterNode *oldmaster = myself->slaveof;
1825      if (nodeIsMaster(myself) || oldmaster == NULL) return;
1826      clusterSetNodeAsMaster(myself);
1827      replicationUnsetMaster();
1828      for (j = 0; j < CLUSTER_SLOTS; j++) {
1829          if (clusterNodeGetSlotBit(oldmaster,j)) {
1830              clusterDelSlot(j);
1831              clusterAddSlot(myself,j);
1832          }
1833      }
1834      clusterUpdateState();
1835      clusterSaveConfigOrDie(1);
1836      clusterBroadcastPong(CLUSTER_BROADCAST_ALL);
1837      resetManualFailover();
1838  }
1839  void clusterHandleSlaveFailover(void) {
1840      mstime_t data_age;
1841      mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
1842      int needed_quorum = (server.cluster->size / 2) + 1;
1843      int manual_failover = server.cluster->mf_end != 0 &&
1844                            server.cluster->mf_can_start;
1845      mstime_t auth_timeout, auth_retry_time;
1846      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;
1847      auth_timeout = server.cluster_node_timeout*2;
1848      if (auth_timeout < 2000) auth_timeout = 2000;
1849      auth_retry_time = auth_timeout*2;
1850      if (nodeIsMaster(myself) ||
1851          myself->slaveof == NULL ||
1852          (!nodeFailed(myself->slaveof) && !manual_failover) ||
1853          (server.cluster_slave_no_failover && !manual_failover) ||
1854          myself->slaveof->numslots == 0)
1855      {
1856          server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
1857          return;
1858      }
1859      if (server.repl_state == REPL_STATE_CONNECTED) {
1860          data_age = (mstime_t)(server.unixtime - server.master->lastinteraction)
1861                     * 1000;
1862      } else {
1863          data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;
1864      }
1865      if (data_age > server.cluster_node_timeout)
1866          data_age -= server.cluster_node_timeout;
1867      if (server.cluster_slave_validity_factor &&
1868          data_age >
1869          (((mstime_t)server.repl_ping_slave_period * 1000) +
1870           (server.cluster_node_timeout * server.cluster_slave_validity_factor)))
1871      {
1872          if (!manual_failover) {
1873              clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);
1874              return;
1875          }
1876      }
1877      if (auth_age > auth_retry_time) {
1878          server.cluster->failover_auth_time = mstime() +
1879              500 + &bsol;* Fixed delay of 500 milliseconds, let FAIL msg propagate. */
1880              random() % 500; &bsol;* Random delay between 0 and 500 milliseconds. */
1881          server.cluster->failover_auth_count = 0;
1882          server.cluster->failover_auth_sent = 0;
1883          server.cluster->failover_auth_rank = clusterGetSlaveRank();
1884          server.cluster->failover_auth_time +=
1885              server.cluster->failover_auth_rank * 1000;
1886          if (server.cluster->mf_end) {
1887              server.cluster->failover_auth_time = mstime();
1888              server.cluster->failover_auth_rank = 0;
1889  	    clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
1890          }
1891          serverLog(LL_WARNING,
1892              "Start of election delayed for %lld milliseconds "
1893              "(rank #%d, offset %lld).",
1894              server.cluster->failover_auth_time - mstime(),
1895              server.cluster->failover_auth_rank,
1896              replicationGetSlaveOffset());
1897          clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
1898          return;
1899      }
1900      if (server.cluster->failover_auth_sent == 0 &&
1901          server.cluster->mf_end == 0)
1902      {
1903          int newrank = clusterGetSlaveRank();
1904          if (newrank > server.cluster->failover_auth_rank) {
1905              PORT_LONGLONG added_delay =
1906                  (newrank - server.cluster->failover_auth_rank) * 1000;
1907              server.cluster->failover_auth_time += added_delay;
1908              server.cluster->failover_auth_rank = newrank;
1909              serverLog(LL_WARNING,
1910                  "Replica rank updated to #%d, added %lld milliseconds of delay.",
1911                  newrank, added_delay);
1912          }
1913      }
1914      if (mstime() < server.cluster->failover_auth_time) {
1915          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
1916          return;
1917      }
1918      if (auth_age > auth_timeout) {
1919          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
1920          return;
1921      }
1922      if (server.cluster->failover_auth_sent == 0) {
1923          server.cluster->currentEpoch++;
1924          server.cluster->failover_auth_epoch = server.cluster->currentEpoch;
1925          serverLog(LL_WARNING,"Starting a failover election for epoch %llu.",
1926              (PORT_ULONGLONG) server.cluster->currentEpoch);
1927          clusterRequestFailoverAuth();
1928          server.cluster->failover_auth_sent = 1;
1929          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
1930                               CLUSTER_TODO_UPDATE_STATE|
1931                               CLUSTER_TODO_FSYNC_CONFIG);
1932          return; &bsol;* Wait for replies. */
1933      }
1934      if (server.cluster->failover_auth_count >= needed_quorum) {
1935          serverLog(LL_WARNING,
1936              "Failover election won: I'm the new master.");
1937          if (myself->configEpoch < server.cluster->failover_auth_epoch) {
1938              myself->configEpoch = server.cluster->failover_auth_epoch;
1939              serverLog(LL_WARNING,
1940                  "configEpoch set to %llu after successful failover",
1941                  (PORT_ULONGLONG) myself->configEpoch);
1942          }
1943          clusterFailoverReplaceYourMaster();
1944      } else {
1945          clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
1946      }
1947  }
1948  void clusterHandleSlaveMigration(int max_slaves) {
1949      int j, okslaves = 0;
1950      clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
1951      dictIterator *di;
1952      dictEntry *de;
1953      if (server.cluster->state != CLUSTER_OK) return;
1954      if (mymaster == NULL) return;
1955      for (j = 0; j < mymaster->numslaves; j++)
1956          if (!nodeFailed(mymaster->slaves[j]) &&
1957              !nodeTimedOut(mymaster->slaves[j])) okslaves++;
1958      if (okslaves <= server.cluster_migration_barrier) return;
1959      candidate = myself;
1960      di = dictGetSafeIterator(server.cluster->nodes);
1961      while((de = dictNext(di)) != NULL) {
1962          clusterNode *node = dictGetVal(de);
1963          int okslaves = 0, is_orphaned = 1;
1964          if (nodeIsSlave(node) || nodeFailed(node)) is_orphaned = 0;
1965          if (!(node->flags & CLUSTER_NODE_MIGRATE_TO)) is_orphaned = 0;
1966          if (nodeIsMaster(node)) okslaves = clusterCountNonFailingSlaves(node);
1967          if (okslaves > 0) is_orphaned = 0;
1968          if (is_orphaned) {
1969              if (!target && node->numslots > 0) target = node;
1970              if (!node->orphaned_time) node->orphaned_time = mstime();
1971          } else {
1972              node->orphaned_time = 0;
1973          }
1974          if (okslaves == max_slaves) {
1975              for (j = 0; j < node->numslaves; j++) {
1976                  if (memcmp(node->slaves[j]->name,
1977                             candidate->name,
1978                             CLUSTER_NAMELEN) < 0)
1979                  {
1980                      candidate = node->slaves[j];
1981                  }
1982              }
1983          }
1984      }
1985      dictReleaseIterator(di);
1986      if (target && candidate == myself &&
1987          (mstime()-target->orphaned_time) > CLUSTER_SLAVE_MIGRATION_DELAY &&
1988         !(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
1989      {
1990          serverLog(LL_WARNING,"Migrating to orphaned master %.40s",
1991              target->name);
1992          clusterSetMaster(target);
1993      }
1994  }
1995  void resetManualFailover(void) {
1996      if (server.cluster->mf_end && clientsArePaused()) {
1997          server.clients_pause_end_time = 0;
1998          clientsArePaused(); &bsol;* Just use the side effect of the function. */
1999      }
2000      server.cluster->mf_end = 0; &bsol;* No manual failover in progress. */
2001      server.cluster->mf_can_start = 0;
2002      server.cluster->mf_slave = NULL;
2003      server.cluster->mf_master_offset = 0;
2004  }
2005  void manualFailoverCheckTimeout(void) {
2006      if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
2007          serverLog(LL_WARNING,"Manual failover timed out.");
2008          resetManualFailover();
2009      }
2010  }
2011  void clusterHandleManualFailover(void) {
2012      if (server.cluster->mf_end == 0) return;
2013      if (server.cluster->mf_can_start) return;
2014      if (server.cluster->mf_master_offset == 0) return; &bsol;* Wait for offset... */
2015      if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
2016          server.cluster->mf_can_start = 1;
2017          serverLog(LL_WARNING,
2018              "All master replication stream processed, "
2019              "manual failover can start.");
2020      }
2021  }
2022  void clusterCron(void) {
2023      dictIterator *di;
2024      dictEntry *de;
2025      int update_state = 0;
2026      int orphaned_masters; &bsol;* How many masters there are without ok slaves. */
2027      int max_slaves; &bsol;* Max number of ok slaves for a single master. */
2028      int this_slaves; &bsol;* Number of ok slaves for our master (if we are slave). */
2029      mstime_t min_pong = 0, now = mstime();
2030      clusterNode *min_pong_node = NULL;
2031      static PORT_ULONGLONG iteration = 0;
2032      mstime_t handshake_timeout;
2033      iteration++; &bsol;* Number of times this function was called so far. */
2034      {
2035          static char *prev_ip = NULL;
2036          char *curr_ip = server.cluster_announce_ip;
2037          int changed = 0;
2038          if (prev_ip == NULL && curr_ip != NULL) changed = 1;
2039          else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
2040          else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;
2041          if (changed) {
2042              if (prev_ip) zfree(prev_ip);
2043              prev_ip = curr_ip;
2044              if (curr_ip) {
2045                  prev_ip = zstrdup(prev_ip);
2046                  strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
2047                  myself->ip[NET_IP_STR_LEN-1] = '\0';
2048              } else {
2049                  myself->ip[0] = '\0'; &bsol;* Force autodetection. */
2050              }
2051          }
2052      }
2053      handshake_timeout = server.cluster_node_timeout;
2054      if (handshake_timeout < 1000) handshake_timeout = 1000;
2055      clusterUpdateMyselfFlags();
2056      di = dictGetSafeIterator(server.cluster->nodes);
2057      server.cluster->stats_pfail_nodes = 0;
2058      while((de = dictNext(di)) != NULL) {
2059          clusterNode *node = dictGetVal(de);
2060          if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) continue;
2061          if (node->flags & CLUSTER_NODE_PFAIL)
2062              server.cluster->stats_pfail_nodes++;
2063          if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
2064              clusterDelNode(node);
2065              continue;
2066          }
2067          if (node->link == NULL) {
2068              int fd;
2069              mstime_t old_ping_sent;
2070              clusterLink *link;
2071              fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,
2072                  node->cport, NET_FIRST_BIND_ADDR);
2073              if (fd == -1) {
2074                  if (node->ping_sent == 0) node->ping_sent = mstime();
2075                  serverLog(LL_DEBUG, "Unable to connect to "
2076                      "Cluster Node [%s]:%d -> %s", node->ip,
2077                      node->cport, server.neterr);
2078                  continue;
2079              }
2080              link = createClusterLink(node);
2081              link->fd = fd;
2082              node->link = link;
2083              aeCreateFileEvent(server.el,link->fd,AE_READABLE,
2084                      clusterReadHandler,link);
2085              old_ping_sent = node->ping_sent;
2086              clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
2087                      CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
2088              if (old_ping_sent) {
2089                  node->ping_sent = old_ping_sent;
2090              }
2091              node->flags &= ~CLUSTER_NODE_MEET;
2092              serverLog(LL_DEBUG,"Connecting with Node %.40s at %s:%d",
2093                      node->name, node->ip, node->cport);
2094          }
2095      }
2096      dictReleaseIterator(di);
2097      if (!(iteration % 10)) {
2098          int j;
2099          for (j = 0; j < 5; j++) {
2100              de = dictGetRandomKey(server.cluster->nodes);
2101              clusterNode *this = dictGetVal(de);
2102              if (this->link == NULL || this->ping_sent != 0) continue;
2103              if (this->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
2104                  continue;
2105              if (min_pong_node == NULL || min_pong > this->pong_received) {
2106                  min_pong_node = this;
2107                  min_pong = this->pong_received;
2108              }
2109          }
2110          if (min_pong_node) {
2111              serverLog(LL_DEBUG,"Pinging node %.40s", min_pong_node->name);
2112              clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);
2113          }
2114      }
2115      orphaned_masters = 0;
2116      max_slaves = 0;
2117      this_slaves = 0;
2118      di = dictGetSafeIterator(server.cluster->nodes);
2119      while((de = dictNext(di)) != NULL) {
2120          clusterNode *node = dictGetVal(de);
2121          now = mstime(); &bsol;* Use an updated time at every iteration. */
2122          if (node->flags &
2123              (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
2124                  continue;
2125          if (nodeIsSlave(myself) && nodeIsMaster(node) && !nodeFailed(node)) {
2126              int okslaves = clusterCountNonFailingSlaves(node);
2127              if (okslaves == 0 && node->numslots > 0 &&
2128                  node->flags & CLUSTER_NODE_MIGRATE_TO)
2129              {
2130                  orphaned_masters++;
2131              }
2132              if (okslaves > max_slaves) max_slaves = okslaves;
2133              if (nodeIsSlave(myself) && myself->slaveof == node)
2134                  this_slaves = okslaves;
2135          }
2136          if (node->link && &bsol;* is connected */
2137              now - node->link->ctime >
2138              server.cluster_node_timeout && &bsol;* was not already reconnected */
2139              node->ping_sent && &bsol;* we already sent a ping */
2140              node->pong_received < node->ping_sent && &bsol;* still waiting pong */
2141              now - node->ping_sent > server.cluster_node_timeout/2 &&
2142              now - node->data_received > server.cluster_node_timeout/2)
2143          {
2144              freeClusterLink(node->link);
2145          }
2146          if (node->link &&
2147              node->ping_sent == 0 &&
2148              (now - node->pong_received) > server.cluster_node_timeout/2)
2149          {
2150              clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
2151              continue;
2152          }
2153          if (server.cluster->mf_end &&
2154              nodeIsMaster(myself) &&
2155              server.cluster->mf_slave == node &&
2156              node->link)
2157          {
2158              clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
2159              continue;
2160          }
2161          if (node->ping_sent == 0) continue;
2162          mstime_t delay = now - node->ping_sent;
2163          mstime_t data_delay = now - node->data_received;
2164          if (data_delay < delay) delay = data_delay;
2165          if (delay > server.cluster_node_timeout) {
2166              if (!(node->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) {
2167                  serverLog(LL_DEBUG,"*** NODE %.40s possibly failing",
2168                      node->name);
2169                  node->flags |= CLUSTER_NODE_PFAIL;
2170                  update_state = 1;
2171              }
2172          }
2173      }
2174      dictReleaseIterator(di);
2175      if (nodeIsSlave(myself) &&
2176          server.masterhost == NULL &&
2177          myself->slaveof &&
2178          nodeHasAddr(myself->slaveof))
2179      {
2180          replicationSetMaster(myself->slaveof->ip, myself->slaveof->port);
2181      }
2182      manualFailoverCheckTimeout();
2183      if (nodeIsSlave(myself)) {
2184          clusterHandleManualFailover();
2185          if (!(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
2186              clusterHandleSlaveFailover();
2187          if (orphaned_masters && max_slaves >= 2 && this_slaves == max_slaves)
2188              clusterHandleSlaveMigration(max_slaves);
2189      }
2190      if (update_state || server.cluster->state == CLUSTER_FAIL)
2191          clusterUpdateState();
2192  }
2193  void clusterBeforeSleep(void) {
2194      if (server.cluster->todo_before_sleep & CLUSTER_TODO_HANDLE_FAILOVER)
2195          clusterHandleSlaveFailover();
2196      if (server.cluster->todo_before_sleep & CLUSTER_TODO_UPDATE_STATE)
2197          clusterUpdateState();
2198      if (server.cluster->todo_before_sleep & CLUSTER_TODO_SAVE_CONFIG) {
2199          int fsync = server.cluster->todo_before_sleep &
2200                      CLUSTER_TODO_FSYNC_CONFIG;
2201          clusterSaveConfigOrDie(fsync);
2202      }
2203      server.cluster->todo_before_sleep = 0;
2204  }
2205  void clusterDoBeforeSleep(int flags) {
2206      server.cluster->todo_before_sleep |= flags;
2207  }
2208  int bitmapTestBit(unsigned char *bitmap, int pos) {
2209      off_t byte = pos/8;
2210      int bit = pos&7;
2211      return (bitmap[byte] & (1<<bit)) != 0;
2212  }
2213  void bitmapSetBit(unsigned char *bitmap, int pos) {
2214      off_t byte = pos/8;
2215      int bit = pos&7;
2216      bitmap[byte] |= 1<<bit;
2217  }
2218  void bitmapClearBit(unsigned char *bitmap, int pos) {
2219      off_t byte = pos/8;
2220      int bit = pos&7;
2221      bitmap[byte] &= ~(1<<bit);
2222  }
2223  int clusterMastersHaveSlaves(void) {
2224      dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
2225      dictEntry *de;
2226      int slaves = 0;
2227      while((de = dictNext(di)) != NULL) {
2228          clusterNode *node = dictGetVal(de);
2229          if (nodeIsSlave(node)) continue;
2230          slaves += node->numslaves;
2231      }
2232      dictReleaseIterator(di);
2233      return slaves != 0;
2234  }
2235  int clusterNodeSetSlotBit(clusterNode *n, int slot) {
2236      int old = bitmapTestBit(n->slots,slot);
2237      bitmapSetBit(n->slots,slot);
2238      if (!old) {
2239          n->numslots++;
2240          if (n->numslots == 1 && clusterMastersHaveSlaves())
2241              n->flags |= CLUSTER_NODE_MIGRATE_TO;
2242      }
2243      return old;
2244  }
2245  int clusterNodeClearSlotBit(clusterNode *n, int slot) {
2246      int old = bitmapTestBit(n->slots,slot);
2247      bitmapClearBit(n->slots,slot);
2248      if (old) n->numslots--;
2249      return old;
2250  }
2251  int clusterNodeGetSlotBit(clusterNode *n, int slot) {
2252      return bitmapTestBit(n->slots,slot);
2253  }
2254  int clusterAddSlot(clusterNode *n, int slot) {
2255      if (server.cluster->slots[slot]) return C_ERR;
2256      clusterNodeSetSlotBit(n,slot);
2257      server.cluster->slots[slot] = n;
2258      return C_OK;
2259  }
2260  int clusterDelSlot(int slot) {
2261      clusterNode *n = server.cluster->slots[slot];
2262      if (!n) return C_ERR;
2263      serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
2264      server.cluster->slots[slot] = NULL;
2265      return C_OK;
2266  }
2267  int clusterDelNodeSlots(clusterNode *node) {
2268      int deleted = 0, j;
2269      for (j = 0; j < CLUSTER_SLOTS; j++) {
2270          if (clusterNodeGetSlotBit(node,j)) {
2271              clusterDelSlot(j);
2272              deleted++;
2273          }
2274      }
2275      return deleted;
2276  }
2277  void clusterCloseAllSlots(void) {
2278      memset(server.cluster->migrating_slots_to,0,
2279          sizeof(server.cluster->migrating_slots_to));
2280      memset(server.cluster->importing_slots_from,0,
2281          sizeof(server.cluster->importing_slots_from));
2282  }
2283  #define CLUSTER_MAX_REJOIN_DELAY 5000
2284  #define CLUSTER_MIN_REJOIN_DELAY 500
2285  #define CLUSTER_WRITABLE_DELAY 2000
2286  void clusterUpdateState(void) {
2287      int j, new_state;
2288      int reachable_masters = 0;
2289      static mstime_t among_minority_time;
2290      static mstime_t first_call_time = 0;
2291      server.cluster->todo_before_sleep &= ~CLUSTER_TODO_UPDATE_STATE;
2292      if (first_call_time == 0) first_call_time = mstime();
2293      if (nodeIsMaster(myself) &&
2294          server.cluster->state == CLUSTER_FAIL &&
2295          mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;
2296      new_state = CLUSTER_OK;
2297      if (server.cluster_require_full_coverage) {
2298          for (j = 0; j < CLUSTER_SLOTS; j++) {
2299              if (server.cluster->slots[j] == NULL ||
2300                  server.cluster->slots[j]->flags & (CLUSTER_NODE_FAIL))
2301              {
2302                  new_state = CLUSTER_FAIL;
2303                  break;
2304              }
2305          }
2306      }
2307      {
2308          dictIterator *di;
2309          dictEntry *de;
2310          server.cluster->size = 0;
2311          di = dictGetSafeIterator(server.cluster->nodes);
2312          while((de = dictNext(di)) != NULL) {
2313              clusterNode *node = dictGetVal(de);
2314              if (nodeIsMaster(node) && node->numslots) {
2315                  server.cluster->size++;
2316                  if ((node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) == 0)
2317                      reachable_masters++;
2318              }
2319          }
2320          dictReleaseIterator(di);
2321      }
2322      {
2323          int needed_quorum = (server.cluster->size / 2) + 1;
2324          if (reachable_masters < needed_quorum) {
2325              new_state = CLUSTER_FAIL;
2326              among_minority_time = mstime();
2327          }
2328      }
2329      if (new_state != server.cluster->state) {
2330          mstime_t rejoin_delay = server.cluster_node_timeout;
2331          if (rejoin_delay > CLUSTER_MAX_REJOIN_DELAY)
2332              rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;
2333          if (rejoin_delay < CLUSTER_MIN_REJOIN_DELAY)
2334              rejoin_delay = CLUSTER_MIN_REJOIN_DELAY;
2335          if (new_state == CLUSTER_OK &&
2336              nodeIsMaster(myself) &&
2337              mstime() - among_minority_time < rejoin_delay)
2338          {
2339              return;
2340          }
2341          serverLog(LL_WARNING,"Cluster state changed: %s",
2342              new_state == CLUSTER_OK ? "ok" : "fail");
2343          server.cluster->state = new_state;
2344      }
2345  }
2346  int verifyClusterConfigWithData(void) {
2347      int j;
2348      int update_config = 0;
2349      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
2350          return C_OK;
2351      if (nodeIsSlave(myself)) return C_OK;
2352      for (j = 1; j < server.dbnum; j++) {
2353          if (dictSize(server.db[j].dict)) return C_ERR;
2354      }
2355      for (j = 0; j < CLUSTER_SLOTS; j++) {
2356          if (!countKeysInSlot(j)) continue; &bsol;* No keys in this slot. */
2357          if (server.cluster->slots[j] == myself ||
2358              server.cluster->importing_slots_from[j] != NULL) continue;
2359          update_config++;
2360          if (server.cluster->slots[j] == NULL) {
2361              serverLog(LL_WARNING, "I have keys for unassigned slot %d. "
2362                                      "Taking responsibility for it.",j);
2363              clusterAddSlot(myself,j);
2364          } else {
2365              serverLog(LL_WARNING, "I have keys for slot %d, but the slot is "
2366                                      "assigned to another node. "
2367                                      "Setting it to importing state.",j);
2368              server.cluster->importing_slots_from[j] = server.cluster->slots[j];
2369          }
2370      }
2371      if (update_config) clusterSaveConfigOrDie(1);
2372      return C_OK;
2373  }
2374  void clusterSetMaster(clusterNode *n) {
2375      serverAssert(n != myself);
2376      serverAssert(myself->numslots == 0);
2377      if (nodeIsMaster(myself)) {
2378          myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
2379          myself->flags |= CLUSTER_NODE_SLAVE;
2380          clusterCloseAllSlots();
2381      } else {
2382          if (myself->slaveof)
2383              clusterNodeRemoveSlave(myself->slaveof,myself);
2384      }
2385      myself->slaveof = n;
2386      clusterNodeAddSlave(n,myself);
2387      replicationSetMaster(n->ip, n->port);
2388      resetManualFailover();
2389  }
2390  struct redisNodeFlags {
2391      uint16_t flag;
2392      char *name;
2393  };
2394  static struct redisNodeFlags redisNodeFlagsTable[] = {
2395      {CLUSTER_NODE_MYSELF,       "myself,"},
2396      {CLUSTER_NODE_MASTER,       "master,"},
2397      {CLUSTER_NODE_SLAVE,        "slave,"},
2398      {CLUSTER_NODE_PFAIL,        "fail?,"},
2399      {CLUSTER_NODE_FAIL,         "fail,"},
2400      {CLUSTER_NODE_HANDSHAKE,    "handshake,"},
2401      {CLUSTER_NODE_NOADDR,       "noaddr,"},
2402      {CLUSTER_NODE_NOFAILOVER,   "nofailover,"}
2403  };
2404  sds representClusterNodeFlags(sds ci, uint16_t flags) {
2405      size_t orig_len = sdslen(ci);
2406      int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
2407      for (i = 0; i < size; i++) {
2408          struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
2409          if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
2410      }
2411      if (sdslen(ci) == orig_len) ci = sdscat(ci,"noflags,");
2412      sdsIncrLen(ci,-1); &bsol;* Remove trailing comma. */
2413      return ci;
2414  }
2415  sds clusterGenNodeDescription(clusterNode *node) {
2416      int j, start;
2417      sds ci;
2418      ci = sdscatprintf(sdsempty(),"%.40s %s:%d@%d ",
2419          node->name,
2420          node->ip,
2421          node->port,
2422          node->cport);
2423      ci = representClusterNodeFlags(ci, node->flags);
2424      if (node->slaveof)
2425          ci = sdscatprintf(ci," %.40s ",node->slaveof->name);
2426      else
2427          ci = sdscatlen(ci," - ",3);
2428      ci = sdscatprintf(ci,"%lld %lld %llu %s",
2429          (PORT_LONGLONG) node->ping_sent,
2430          (PORT_LONGLONG) node->pong_received,
2431          (PORT_ULONGLONG) node->configEpoch,
2432          (node->link || node->flags & CLUSTER_NODE_MYSELF) ?
2433                      "connected" : "disconnected");
2434      start = -1;
2435      for (j = 0; j < CLUSTER_SLOTS; j++) {
2436          int bit;
2437          if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
2438              if (start == -1) start = j;
2439          }
2440          if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
2441              if (bit && j == CLUSTER_SLOTS-1) j++;
2442              if (start == j-1) {
2443                  ci = sdscatprintf(ci," %d",start);
2444              } else {
2445                  ci = sdscatprintf(ci," %d-%d",start,j-1);
2446              }
2447              start = -1;
2448          }
2449      }
2450      if (node->flags & CLUSTER_NODE_MYSELF) {
2451          for (j = 0; j < CLUSTER_SLOTS; j++) {
2452              if (server.cluster->migrating_slots_to[j]) {
2453                  ci = sdscatprintf(ci," [%d->-%.40s]",j,
2454                      server.cluster->migrating_slots_to[j]->name);
2455              } else if (server.cluster->importing_slots_from[j]) {
2456                  ci = sdscatprintf(ci," [%d-<-%.40s]",j,
2457                      server.cluster->importing_slots_from[j]->name);
2458              }
2459          }
2460      }
2461      return ci;
2462  }
2463  sds clusterGenNodesDescription(int filter) {
2464      sds ci = sdsempty(), ni;
2465      dictIterator *di;
2466      dictEntry *de;
2467      di = dictGetSafeIterator(server.cluster->nodes);
2468      while((de = dictNext(di)) != NULL) {
2469          clusterNode *node = dictGetVal(de);
2470          if (node->flags & filter) continue;
2471          ni = clusterGenNodeDescription(node);
2472          ci = sdscatsds(ci,ni);
2473          sdsfree(ni);
2474          ci = sdscatlen(ci,"\n",1);
2475      }
2476      dictReleaseIterator(di);
2477      return ci;
2478  }
2479  const char *clusterGetMessageTypeString(int type) {
2480      switch(type) {
2481      case CLUSTERMSG_TYPE_PING: return "ping";
2482      case CLUSTERMSG_TYPE_PONG: return "pong";
2483      case CLUSTERMSG_TYPE_MEET: return "meet";
2484      case CLUSTERMSG_TYPE_FAIL: return "fail";
2485      case CLUSTERMSG_TYPE_PUBLISH: return "publish";
2486      case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return "auth-req";
2487      case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return "auth-ack";
2488      case CLUSTERMSG_TYPE_UPDATE: return "update";
2489      case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
2490      case CLUSTERMSG_TYPE_MODULE: return "module";
2491      }
2492      return "unknown";
2493  }
2494  int getSlotOrReply(client *c, robj *o) {
2495      PORT_LONGLONG slot;
2496      if (getLongLongFromObject(o,&slot) != C_OK ||
2497          slot < 0 || slot >= CLUSTER_SLOTS)
2498      {
2499          addReplyError(c,"Invalid or out of range slot");
2500          return -1;
2501      }
2502      return (int) slot;
2503  }
2504  void clusterReplyMultiBulkSlots(client *c) {
2505      int num_masters = 0;
2506      void *slot_replylen = addDeferredMultiBulkLength(c);
2507      dictEntry *de;
2508      dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
2509      while((de = dictNext(di)) != NULL) {
2510          clusterNode *node = dictGetVal(de);
2511          int j = 0, start = -1;
2512          int i, nested_elements = 0;
2513          if (!nodeIsMaster(node) || node->numslots == 0) continue;
2514          for(i = 0; i < node->numslaves; i++) {
2515              if (nodeFailed(node->slaves[i])) continue;
2516              nested_elements++;
2517          }
2518          for (j = 0; j < CLUSTER_SLOTS; j++) {
2519              int bit, i;
2520              if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
2521                  if (start == -1) start = j;
2522              }
2523              if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
2524                  addReplyMultiBulkLen(c, nested_elements + 3); &bsol;* slots (2) + master addr (1). */
2525                  if (bit && j == CLUSTER_SLOTS-1) j++;
2526                  if (start == j-1) {
2527                      addReplyLongLong(c, start); &bsol;* only one slot; low==high */
2528                      addReplyLongLong(c, start);
2529                  } else {
2530                      addReplyLongLong(c, start); &bsol;* low */
2531                      addReplyLongLong(c, j-1);   &bsol;* high */
2532                  }
2533                  start = -1;
2534                  addReplyMultiBulkLen(c, 3);
2535                  addReplyBulkCString(c, node->ip);
2536                  addReplyLongLong(c, node->port);
2537                  addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
2538                  for (i = 0; i < node->numslaves; i++) {
2539                      if (nodeFailed(node->slaves[i])) continue;
2540                      addReplyMultiBulkLen(c, 3);
2541                      addReplyBulkCString(c, node->slaves[i]->ip);
2542                      addReplyLongLong(c, node->slaves[i]->port);
2543                      addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN);
2544                  }
2545                  num_masters++;
2546              }
2547          }
2548      }
2549      dictReleaseIterator(di);
2550      setDeferredMultiBulkLength(c, slot_replylen, num_masters);
2551  }
2552  void clusterCommand(client *c) {
2553      if (server.cluster_enabled == 0) {
2554          addReplyError(c,"This instance has cluster support disabled");
2555          return;
2556      }
2557      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
2558          const char *help[] = {
2559  "ADDSLOTS <slot> [slot ...] -- Assign slots to current node.",
2560  "BUMPEPOCH -- Advance the cluster config epoch.",
2561  "COUNT-failure-reports <node-id> -- Return number of failure reports for <node-id>.",
2562  "COUNTKEYSINSLOT <slot> - Return the number of keys in <slot>.",
2563  "DELSLOTS <slot> [slot ...] -- Delete slots information from current node.",
2564  "FAILOVER [force|takeover] -- Promote current replica node to being a master.",
2565  "FORGET <node-id> -- Remove a node from the cluster.",
2566  "GETKEYSINSLOT <slot> <count> -- Return key names stored by current node in a slot.",
2567  "FLUSHSLOTS -- Delete current node own slots information.",
2568  "INFO - Return onformation about the cluster.",
2569  "KEYSLOT <key> -- Return the hash slot for <key>.",
2570  "MEET <ip> <port> [bus-port] -- Connect nodes into a working cluster.",
2571  "MYID -- Return the node id.",
2572  "NODES -- Return cluster configuration seen by node. Output format:",
2573  "    <id> <ip:port> <flags> <master> <pings> <pongs> <epoch> <link> <slot> ... <slot>",
2574  "REPLICATE <node-id> -- Configure current node as replica to <node-id>.",
2575  "RESET [hard|soft] -- Reset current node (default: soft).",
2576  "SET-config-epoch <epoch> - Set config epoch of current node.",
2577  "SETSLOT <slot> (importing|migrating|stable|node <node-id>) -- Set slot state.",
2578  "REPLICAS <node-id> -- Return <node-id> replicas.",
2579  "SLOTS -- Return information about slots range mappings. Each range is made of:",
2580  "    start, end, master and replicas IP addresses, ports and ids",
2581  NULL
2582          };
2583          addReplyHelp(c, help);
2584      } else if (!strcasecmp(c->argv[1]->ptr,"meet") && (c->argc == 4 || c->argc == 5)) {
2585          PORT_LONGLONG port, cport;
2586          if (getLongLongFromObject(c->argv[3], &port) != C_OK) {
2587              addReplyErrorFormat(c,"Invalid TCP base port specified: %s",
2588                                  (char*)c->argv[3]->ptr);
2589              return;
2590          }
2591          if (c->argc == 5) {
2592              if (getLongLongFromObject(c->argv[4], &cport) != C_OK) {
2593                  addReplyErrorFormat(c,"Invalid TCP bus port specified: %s",
2594                                      (char*)c->argv[4]->ptr);
2595                  return;
2596              }
2597          } else {
2598              cport = port + CLUSTER_PORT_INCR;
2599          }
2600          if (clusterStartHandshake(c->argv[2]->ptr, (int) port, (int) cport) == 0 && WIN_PORT_FIX &bsol;* cast (int) */
2601              errno == EINVAL)
2602          {
2603              addReplyErrorFormat(c,"Invalid node address specified: %s:%s",
2604                              (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr);
2605          } else {
2606              addReply(c,shared.ok);
2607          }
2608      } else if (!strcasecmp(c->argv[1]->ptr,"nodes") && c->argc == 2) {
2609          robj *o;
2610          sds ci = clusterGenNodesDescription(0);
2611          o = createObject(OBJ_STRING,ci);
2612          addReplyBulk(c,o);
2613          decrRefCount(o);
2614      } else if (!strcasecmp(c->argv[1]->ptr,"myid") && c->argc == 2) {
2615          addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN);
2616      } else if (!strcasecmp(c->argv[1]->ptr,"slots") && c->argc == 2) {
2617          clusterReplyMultiBulkSlots(c);
2618      } else if (!strcasecmp(c->argv[1]->ptr,"flushslots") && c->argc == 2) {
2619          if (dictSize(server.db[0].dict) != 0) {
2620              addReplyError(c,"DB must be empty to perform CLUSTER FLUSHSLOTS.");
2621              return;
2622          }
2623          clusterDelNodeSlots(myself);
2624          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2625          addReply(c,shared.ok);
2626      } else if ((!strcasecmp(c->argv[1]->ptr,"addslots") ||
2627                 !strcasecmp(c->argv[1]->ptr,"delslots")) && c->argc >= 3)
2628      {
2629          int j, slot;
2630          unsigned char *slots = zmalloc(CLUSTER_SLOTS);
2631          int del = !strcasecmp(c->argv[1]->ptr,"delslots");
2632          memset(slots,0,CLUSTER_SLOTS);
2633          for (j = 2; j < c->argc; j++) {
2634              if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {
2635                  zfree(slots);
2636                  return;
2637              }
2638              if (del && server.cluster->slots[slot] == NULL) {
2639                  addReplyErrorFormat(c,"Slot %d is already unassigned", slot);
2640                  zfree(slots);
2641                  return;
2642              } else if (!del && server.cluster->slots[slot]) {
2643                  addReplyErrorFormat(c,"Slot %d is already busy", slot);
2644                  zfree(slots);
2645                  return;
2646              }
2647              if (slots[slot]++ == 1) {
2648                  addReplyErrorFormat(c,"Slot %d specified multiple times",
2649                      (int)slot);
2650                  zfree(slots);
2651                  return;
2652              }
2653          }
2654          for (j = 0; j < CLUSTER_SLOTS; j++) {
2655              if (slots[j]) {
2656                  int retval;
2657                  if (server.cluster->importing_slots_from[j])
2658                      server.cluster->importing_slots_from[j] = NULL;
2659                  retval = del ? clusterDelSlot(j) :
2660                                 clusterAddSlot(myself,j);
2661                  serverAssertWithInfo(c,NULL,retval == C_OK);
2662              }
2663          }
2664          zfree(slots);
2665          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2666          addReply(c,shared.ok);
2667      } else if (!strcasecmp(c->argv[1]->ptr,"setslot") && c->argc >= 4) {
2668          int slot;
2669          clusterNode *n;
2670          if (nodeIsSlave(myself)) {
2671              addReplyError(c,"Please use SETSLOT only with masters.");
2672              return;
2673          }
2674          if ((slot = getSlotOrReply(c,c->argv[2])) == -1) return;
2675          if (!strcasecmp(c->argv[3]->ptr,"migrating") && c->argc == 5) {
2676              if (server.cluster->slots[slot] != myself) {
2677                  addReplyErrorFormat(c,"I'm not the owner of hash slot %u",slot);
2678                  return;
2679              }
2680              if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {
2681                  addReplyErrorFormat(c,"I don't know about node %s",
2682                      (char*)c->argv[4]->ptr);
2683                  return;
2684              }
2685              server.cluster->migrating_slots_to[slot] = n;
2686          } else if (!strcasecmp(c->argv[3]->ptr,"importing") && c->argc == 5) {
2687              if (server.cluster->slots[slot] == myself) {
2688                  addReplyErrorFormat(c,
2689                      "I'm already the owner of hash slot %u",slot);
2690                  return;
2691              }
2692              if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {
2693                  addReplyErrorFormat(c,"I don't know about node %s",
2694                      (char*)c->argv[4]->ptr);
2695                  return;
2696              }
2697              server.cluster->importing_slots_from[slot] = n;
2698          } else if (!strcasecmp(c->argv[3]->ptr,"stable") && c->argc == 4) {
2699              server.cluster->importing_slots_from[slot] = NULL;
2700              server.cluster->migrating_slots_to[slot] = NULL;
2701          } else if (!strcasecmp(c->argv[3]->ptr,"node") && c->argc == 5) {
2702              clusterNode *n = clusterLookupNode(c->argv[4]->ptr);
2703              if (!n) {
2704                  addReplyErrorFormat(c,"Unknown node %s",
2705                      (char*)c->argv[4]->ptr);
2706                  return;
2707              }
2708              if (server.cluster->slots[slot] == myself && n != myself) {
2709                  if (countKeysInSlot(slot) != 0) {
2710                      addReplyErrorFormat(c,
2711                          "Can't assign hashslot %d to a different node "
2712                          "while I still hold keys for this hash slot.", slot);
2713                      return;
2714                  }
2715              }
2716              if (countKeysInSlot(slot) == 0 &&
2717                  server.cluster->migrating_slots_to[slot])
2718                  server.cluster->migrating_slots_to[slot] = NULL;
2719              if (n == myself &&
2720                  server.cluster->importing_slots_from[slot])
2721              {
2722                  if (clusterBumpConfigEpochWithoutConsensus() == C_OK) {
2723                      serverLog(LL_WARNING,
2724                          "configEpoch updated after importing slot %d", slot);
2725                  }
2726                  server.cluster->importing_slots_from[slot] = NULL;
2727              }
2728              clusterDelSlot(slot);
2729              clusterAddSlot(n,slot);
2730          } else {
2731              addReplyError(c,
2732                  "Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP");
2733              return;
2734          }
2735          clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);
2736          addReply(c,shared.ok);
2737      } else if (!strcasecmp(c->argv[1]->ptr,"bumpepoch") && c->argc == 2) {
2738          int retval = clusterBumpConfigEpochWithoutConsensus();
2739          sds reply = sdscatprintf(sdsempty(),"+%s %llu\r\n",
2740                  (retval == C_OK) ? "BUMPED" : "STILL",
2741                  (PORT_ULONGLONG) myself->configEpoch);
2742          addReplySds(c,reply);
2743      } else if (!strcasecmp(c->argv[1]->ptr,"info") && c->argc == 2) {
2744          char *statestr[] = {"ok","fail","needhelp"};
2745          int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
2746          uint64_t myepoch;
2747          int j;
2748          for (j = 0; j < CLUSTER_SLOTS; j++) {
2749              clusterNode *n = server.cluster->slots[j];
2750              if (n == NULL) continue;
2751              slots_assigned++;
2752              if (nodeFailed(n)) {
2753                  slots_fail++;
2754              } else if (nodeTimedOut(n)) {
2755                  slots_pfail++;
2756              } else {
2757                  slots_ok++;
2758              }
2759          }
2760          myepoch = (nodeIsSlave(myself) && myself->slaveof) ?
2761                    myself->slaveof->configEpoch : myself->configEpoch;
2762          sds info = sdscatprintf(sdsempty(),
2763              "cluster_state:%s\r\n"
2764              "cluster_slots_assigned:%d\r\n"
2765              "cluster_slots_ok:%d\r\n"
2766              "cluster_slots_pfail:%d\r\n"
2767              "cluster_slots_fail:%d\r\n"
2768              "cluster_known_nodes:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %lu -> %Iu */
2769              "cluster_size:%d\r\n"
2770              "cluster_current_epoch:%llu\r\n"
2771              "cluster_my_epoch:%llu\r\n"
2772              , statestr[server.cluster->state],
2773              slots_assigned,
2774              slots_ok,
2775              slots_pfail,
2776              slots_fail,
2777              dictSize(server.cluster->nodes),
2778              server.cluster->size,
2779              (PORT_ULONGLONG) server.cluster->currentEpoch,
2780              (PORT_ULONGLONG) myepoch
2781          );
2782          PORT_LONGLONG tot_msg_sent = 0;
2783          PORT_LONGLONG tot_msg_received = 0;
2784          for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
2785              if (server.cluster->stats_bus_messages_sent[i] == 0) continue;
2786              tot_msg_sent += server.cluster->stats_bus_messages_sent[i];
2787              info = sdscatprintf(info,
2788                  "cluster_stats_messages_%s_sent:%lld\r\n",
2789                  clusterGetMessageTypeString(i),
2790                  server.cluster->stats_bus_messages_sent[i]);
2791          }
2792          info = sdscatprintf(info,
2793              "cluster_stats_messages_sent:%lld\r\n", tot_msg_sent);
2794          for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
2795              if (server.cluster->stats_bus_messages_received[i] == 0) continue;
2796              tot_msg_received += server.cluster->stats_bus_messages_received[i];
2797              info = sdscatprintf(info,
2798                  "cluster_stats_messages_%s_received:%lld\r\n",
2799                  clusterGetMessageTypeString(i),
2800                  server.cluster->stats_bus_messages_received[i]);
2801          }
2802          info = sdscatprintf(info,
2803              "cluster_stats_messages_received:%lld\r\n", tot_msg_received);
2804          addReplySds(c,sdscatprintf(sdsempty(),"$%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2805              (PORT_ULONG)sdslen(info)));
2806          addReplySds(c,info);
2807          addReply(c,shared.crlf);
2808      } else if (!strcasecmp(c->argv[1]->ptr,"saveconfig") && c->argc == 2) {
2809          int retval = clusterSaveConfig(1);
2810          if (retval == 0)
2811              addReply(c,shared.ok);
2812          else
2813              addReplyErrorFormat(c,"error saving the cluster node config: %s",
2814                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
2815      } else if (!strcasecmp(c->argv[1]->ptr,"keyslot") && c->argc == 3) {
2816          sds key = c->argv[2]->ptr;
2817          addReplyLongLong(c,keyHashSlot(key, (int)sdslen(key)));                  WIN_PORT_FIX &bsol;* cast (int) */
2818      } else if (!strcasecmp(c->argv[1]->ptr,"countkeysinslot") && c->argc == 3) {
2819          PORT_LONGLONG slot;
2820          if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
2821              return;
2822          if (slot < 0 || slot >= CLUSTER_SLOTS) {
2823              addReplyError(c,"Invalid slot");
2824              return;
2825          }
2826          addReplyLongLong(c,countKeysInSlot((unsigned int) slot));                WIN_PORT_FIX &bsol;* cast (unsigned int) */
2827      } else if (!strcasecmp(c->argv[1]->ptr,"getkeysinslot") && c->argc == 4) {
2828          PORT_LONGLONG maxkeys, slot;
2829          unsigned int numkeys, j;
2830          robj **keys;
2831          if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
2832              return;
2833          if (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)
2834              != C_OK)
2835              return;
2836          if (slot < 0 || slot >= CLUSTER_SLOTS || maxkeys < 0) {
2837              addReplyError(c,"Invalid slot or number of keys");
2838              return;
2839          }
2840          unsigned int keys_in_slot = countKeysInSlot(slot);
2841          if (maxkeys > keys_in_slot) maxkeys = keys_in_slot;
2842          keys = zmalloc(sizeof(robj*)*maxkeys);
2843          numkeys = getKeysInSlot((unsigned int)slot, keys, (unsigned int)maxkeys); WIN_PORT_FIX &bsol;* cast (unsigned int) */
2844          addReplyMultiBulkLen(c,numkeys);
2845          for (j = 0; j < numkeys; j++) {
2846              addReplyBulk(c,keys[j]);
2847              decrRefCount(keys[j]);
2848          }
2849          zfree(keys);
2850      } else if (!strcasecmp(c->argv[1]->ptr,"forget") && c->argc == 3) {
2851          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2852          if (!n) {
2853              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2854              return;
2855          } else if (n == myself) {
2856              addReplyError(c,"I tried hard but I can't forget myself...");
2857              return;
2858          } else if (nodeIsSlave(myself) && myself->slaveof == n) {
2859              addReplyError(c,"Can't forget my master!");
2860              return;
2861          }
2862          clusterBlacklistAddNode(n);
2863          clusterDelNode(n);
2864          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|
2865                               CLUSTER_TODO_SAVE_CONFIG);
2866          addReply(c,shared.ok);
2867      } else if (!strcasecmp(c->argv[1]->ptr,"replicate") && c->argc == 3) {
2868          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2869          if (!n) {
2870              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2871              return;
2872          }
2873          if (n == myself) {
2874              addReplyError(c,"Can't replicate myself");
2875              return;
2876          }
2877          if (nodeIsSlave(n)) {
2878              addReplyError(c,"I can only replicate a master, not a replica.");
2879              return;
2880          }
2881          if (nodeIsMaster(myself) &&
2882              (myself->numslots != 0 || dictSize(server.db[0].dict) != 0)) {
2883              addReplyError(c,
2884                  "To set a master the node must be empty and "
2885                  "without assigned slots.");
2886              return;
2887          }
2888          clusterSetMaster(n);
2889          clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
2890          addReply(c,shared.ok);
2891      } else if ((!strcasecmp(c->argv[1]->ptr,"slaves") ||
2892                  !strcasecmp(c->argv[1]->ptr,"replicas")) && c->argc == 3) {
2893          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2894          int j;
2895          if (!n) {
2896              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2897              return;
2898          }
2899          if (nodeIsSlave(n)) {
2900              addReplyError(c,"The specified node is not a master");
2901              return;
2902          }
2903          addReplyMultiBulkLen(c,n->numslaves);
2904          for (j = 0; j < n->numslaves; j++) {
2905              sds ni = clusterGenNodeDescription(n->slaves[j]);
2906              addReplyBulkCString(c,ni);
2907              sdsfree(ni);
2908          }
2909      } else if (!strcasecmp(c->argv[1]->ptr,"count-failure-reports") &&
2910                 c->argc == 3)
2911      {
2912          clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
2913          if (!n) {
2914              addReplyErrorFormat(c,"Unknown node %s", (char*)c->argv[2]->ptr);
2915              return;
2916          } else {
2917              addReplyLongLong(c,clusterNodeFailureReportsCount(n));
2918          }
2919      } else if (!strcasecmp(c->argv[1]->ptr,"failover") &&
2920                 (c->argc == 2 || c->argc == 3))
2921      {
2922          int force = 0, takeover = 0;
2923          if (c->argc == 3) {
2924              if (!strcasecmp(c->argv[2]->ptr,"force")) {
2925                  force = 1;
2926              } else if (!strcasecmp(c->argv[2]->ptr,"takeover")) {
2927                  takeover = 1;
2928                  force = 1; &bsol;* Takeover also implies force. */
2929              } else {
2930                  addReply(c,shared.syntaxerr);
2931                  return;
2932              }
2933          }
2934          if (nodeIsMaster(myself)) {
2935              addReplyError(c,"You should send CLUSTER FAILOVER to a replica");
2936              return;
2937          } else if (myself->slaveof == NULL) {
2938              addReplyError(c,"I'm a replica but my master is unknown to me");
2939              return;
2940          } else if (!force &&
2941                     (nodeFailed(myself->slaveof) ||
2942                      myself->slaveof->link == NULL))
2943          {
2944              addReplyError(c,"Master is down or failed, "
2945                              "please use CLUSTER FAILOVER FORCE");
2946              return;
2947          }
2948          resetManualFailover();
2949          server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;
2950          if (takeover) {
2951              serverLog(LL_WARNING,"Taking over the master (user request).");
2952              clusterBumpConfigEpochWithoutConsensus();
2953              clusterFailoverReplaceYourMaster();
2954          } else if (force) {
2955              serverLog(LL_WARNING,"Forced failover user request accepted.");
2956              server.cluster->mf_can_start = 1;
2957          } else {
2958              serverLog(LL_WARNING,"Manual failover user request accepted.");
2959              clusterSendMFStart(myself->slaveof);
2960          }
2961          addReply(c,shared.ok);
2962      } else if (!strcasecmp(c->argv[1]->ptr,"set-config-epoch") && c->argc == 3)
2963      {
2964          PORT_LONGLONG epoch;
2965          if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != C_OK)
2966              return;
2967          if (epoch < 0) {
2968              addReplyErrorFormat(c,"Invalid config epoch specified: %lld",epoch);
2969          } else if (dictSize(server.cluster->nodes) > 1) {
2970              addReplyError(c,"The user can assign a config epoch only when the "
2971                              "node does not know any other node.");
2972          } else if (myself->configEpoch != 0) {
2973              addReplyError(c,"Node config epoch is already non-zero");
2974          } else {
2975              myself->configEpoch = epoch;
2976              serverLog(LL_WARNING,
2977                  "configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH",
2978                  (PORT_ULONGLONG) myself->configEpoch);
2979              if (server.cluster->currentEpoch < (uint64_t)epoch)
2980                  server.cluster->currentEpoch = epoch;
2981              clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|
2982                                   CLUSTER_TODO_SAVE_CONFIG);
2983              addReply(c,shared.ok);
2984          }
2985      } else if (!strcasecmp(c->argv[1]->ptr,"reset") &&
2986                 (c->argc == 2 || c->argc == 3))
2987      {
2988          int hard = 0;
2989          if (c->argc == 3) {
2990              if (!strcasecmp(c->argv[2]->ptr,"hard")) {
2991                  hard = 1;
2992              } else if (!strcasecmp(c->argv[2]->ptr,"soft")) {
2993                  hard = 0;
2994              } else {
2995                  addReply(c,shared.syntaxerr);
2996                  return;
2997              }
2998          }
2999          if (nodeIsMaster(myself) && dictSize(c->db->dict) != 0) {
3000              addReplyError(c,"CLUSTER RESET can't be called with "
3001                              "master nodes containing keys");
3002              return;
3003          }
3004          clusterReset(hard);
3005          addReply(c,shared.ok);
3006      } else {
3007          addReplySubcommandSyntaxError(c);
3008          return;
3009      }
3010  }
3011  void createDumpPayload(rio *payload, robj *o, robj *key) {
3012      unsigned char buf[2];
3013      uint64_t crc;
3014      rioInitWithBuffer(payload,sdsempty());
3015      serverAssert(rdbSaveObjectType(payload,o));
3016      serverAssert(rdbSaveObject(payload,o,key));
3017      buf[0] = RDB_VERSION & 0xff;
3018      buf[1] = (RDB_VERSION >> 8) & 0xff;
3019      payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);
3020      crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
3021                  sdslen(payload->io.buffer.ptr));
3022      memrev64ifbe(&crc);
3023      payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
3024  }
3025  int verifyDumpPayload(unsigned char *p, size_t len) {
3026      unsigned char *footer;
3027      uint16_t rdbver;
3028      uint64_t crc;
3029      if (len < 10) return C_ERR;
3030      footer = p+(len-10);
3031      rdbver = (footer[1] << 8) | footer[0];
3032      if (rdbver > RDB_VERSION) return C_ERR;
3033      crc = crc64(0,p,len-8);
3034      memrev64ifbe(&crc);
3035      return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
3036  }
3037  void dumpCommand(client *c) {
3038      robj *o, *dumpobj;
3039      rio payload;
3040      if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
3041          addReply(c,shared.nullbulk);
3042          return;
3043      }
3044      createDumpPayload(&payload,o,c->argv[1]);
3045      dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);
3046      addReplyBulk(c,dumpobj);
3047      decrRefCount(dumpobj);
3048      return;
3049  }
3050  void restoreCommand(client *c) {
3051      PORT_LONGLONG ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
3052      rio payload;
3053      int j, type, replace = 0, absttl = 0;
3054      robj *obj;
3055      for (j = 4; j < c->argc; j++) {
3056          int additional = c->argc-j-1;
3057          if (!strcasecmp(c->argv[j]->ptr,"replace")) {
3058              replace = 1;
3059          } else if (!strcasecmp(c->argv[j]->ptr,"absttl")) {
3060              absttl = 1;
3061          } else if (!strcasecmp(c->argv[j]->ptr,"idletime") && additional >= 1 &&
3062                     lfu_freq == -1)
3063          {
3064              if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
3065                      != C_OK) return;
3066              if (lru_idle < 0) {
3067                  addReplyError(c,"Invalid IDLETIME value, must be >= 0");
3068                  return;
3069              }
3070              lru_clock = LRU_CLOCK();
3071              j++; &bsol;* Consume additional arg. */
3072          } else if (!strcasecmp(c->argv[j]->ptr,"freq") && additional >= 1 &&
3073                     lru_idle == -1)
3074          {
3075              if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lfu_freq,NULL)
3076                      != C_OK) return;
3077              if (lfu_freq < 0 || lfu_freq > 255) {
3078                  addReplyError(c,"Invalid FREQ value, must be >= 0 and <= 255");
3079                  return;
3080              }
3081              j++; &bsol;* Consume additional arg. */
3082          } else {
3083              addReply(c,shared.syntaxerr);
3084              return;
3085          }
3086      }
3087      robj *key = c->argv[1];
3088      if (!replace && lookupKeyWrite(c->db,key) != NULL) {
3089          addReply(c,shared.busykeyerr);
3090          return;
3091      }
3092      if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != C_OK) {
3093          return;
3094      } else if (ttl < 0) {
3095          addReplyError(c,"Invalid TTL value, must be >= 0");
3096          return;
3097      }
3098      if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == C_ERR)
3099      {
3100          addReplyError(c,"DUMP payload version or checksum are wrong");
3101          return;
3102      }
3103      rioInitWithBuffer(&payload,c->argv[3]->ptr);
3104      if (((type = rdbLoadObjectType(&payload)) == -1) ||
3105          ((obj = rdbLoadObject(type,&payload,key)) == NULL))
3106      {
3107          addReplyError(c,"Bad data format");
3108          return;
3109      }
3110      int deleted = 0;
3111      if (replace)
3112          deleted = dbDelete(c->db,key);
3113      if (ttl && !absttl) ttl+=mstime();
3114      if (ttl && checkAlreadyExpired(ttl)) {
3115          if (deleted) {
3116              rewriteClientCommandVector(c,2,shared.del,key);
3117              signalModifiedKey(c->db,key);
3118              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
3119              server.dirty++;
3120          }
3121          decrRefCount(obj);
3122          addReply(c, shared.ok);
3123          return;
3124      }
3125      dbAdd(c->db,key,obj);
3126      if (ttl) {
3127          setExpire(c,c->db,key,ttl);
3128      }
3129      objectSetLRUOrLFU(obj,lfu_freq,lru_idle,lru_clock);
3130      signalModifiedKey(c->db,key);
3131      addReply(c,shared.ok);
3132      server.dirty++;
3133  }
3134  #define MIGRATE_SOCKET_CACHE_ITEMS 64 &bsol;* max num of items in the cache. */
3135  #define MIGRATE_SOCKET_CACHE_TTL 10 &bsol;* close cached sockets after 10 sec. */
3136  typedef struct migrateCachedSocket {
3137      int fd;
3138      PORT_LONG last_dbid;
3139      time_t last_use_time;
3140  } migrateCachedSocket;
3141  migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, PORT_LONG timeout) {
3142      int fd;
3143      sds name = sdsempty();
3144      migrateCachedSocket *cs;
3145      name = sdscatlen(name,host->ptr,sdslen(host->ptr));
3146      name = sdscatlen(name,":",1);
3147      name = sdscatlen(name,port->ptr,sdslen(port->ptr));
3148      cs = dictFetchValue(server.migrate_cached_sockets,name);
3149      if (cs) {
3150          sdsfree(name);
3151          cs->last_use_time = server.unixtime;
3152          return cs;
3153      }
3154      if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {
3155          dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);
3156          cs = dictGetVal(de);
3157          close(cs->fd);
3158          zfree(cs);
3159          dictDelete(server.migrate_cached_sockets,dictGetKey(de));
3160      }
3161      fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,
3162                                  atoi(c->argv[2]->ptr));
3163      if (fd == -1) {
3164          sdsfree(name);
3165          addReplyErrorFormat(c,"Can't connect to target node: %s",
3166              server.neterr);
3167          return NULL;
3168      }
3169      anetEnableTcpNoDelay(server.neterr,fd);
3170      if ((aeWait(fd,AE_WRITABLE,timeout) & AE_WRITABLE) == 0) {
3171          sdsfree(name);
3172          addReplySds(c,
3173              sdsnew("-IOERR error or timeout connecting to the client\r\n"));
3174          close(fd);
3175          return NULL;
3176      }
3177      cs = zmalloc(sizeof(*cs));
3178      cs->fd = fd;
3179      cs->last_dbid = -1;
3180      cs->last_use_time = server.unixtime;
3181      dictAdd(server.migrate_cached_sockets,name,cs);
3182      return cs;
3183  }
3184  void migrateCloseSocket(robj *host, robj *port) {
3185      sds name = sdsempty();
3186      migrateCachedSocket *cs;
3187      name = sdscatlen(name,host->ptr,sdslen(host->ptr));
3188      name = sdscatlen(name,":",1);
3189      name = sdscatlen(name,port->ptr,sdslen(port->ptr));
3190      cs = dictFetchValue(server.migrate_cached_sockets,name);
3191      if (!cs) {
3192          sdsfree(name);
3193          return;
3194      }
3195      close(cs->fd);
3196      zfree(cs);
3197      dictDelete(server.migrate_cached_sockets,name);
3198      sdsfree(name);
3199  }
3200  void migrateCloseTimedoutSockets(void) {
3201      dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
3202      dictEntry *de;
3203      while((de = dictNext(di)) != NULL) {
3204          migrateCachedSocket *cs = dictGetVal(de);
3205          if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {
3206              close(cs->fd);
3207              zfree(cs);
3208              dictDelete(server.migrate_cached_sockets,dictGetKey(de));
3209          }
3210      }
3211      dictReleaseIterator(di);
3212  }
3213  void migrateCommand(client *c) {
3214      migrateCachedSocket *cs;
3215      int copy = 0, replace = 0, j;
3216      char *password = NULL;
3217      PORT_LONG timeout;
3218      PORT_LONG dbid;
3219      robj **ov = NULL; &bsol;* Objects to migrate. */
3220      robj **kv = NULL; &bsol;* Key names. */
3221      robj **newargv = NULL; &bsol;* Used to rewrite the command as DEL ... keys ... */
3222      rio cmd, payload;
3223      int may_retry = 1;
3224      int write_error = 0;
3225      int argv_rewritten = 0;
3226      int first_key = 3; &bsol;* Argument index of the first key. */
3227      int num_keys = 1;  &bsol;* By default only migrate the 'key' argument. */
3228      for (j = 6; j < c->argc; j++) {
3229          int moreargs = j < c->argc-1;
3230          if (!strcasecmp(c->argv[j]->ptr,"copy")) {
3231              copy = 1;
3232          } else if (!strcasecmp(c->argv[j]->ptr,"replace")) {
3233              replace = 1;
3234          } else if (!strcasecmp(c->argv[j]->ptr,"auth")) {
3235              if (!moreargs) {
3236                  addReply(c,shared.syntaxerr);
3237                  return;
3238              }
3239              j++;
3240              password = c->argv[j]->ptr;
3241          } else if (!strcasecmp(c->argv[j]->ptr,"keys")) {
3242              if (sdslen(c->argv[3]->ptr) != 0) {
3243                  addReplyError(c,
3244                      "When using MIGRATE KEYS option, the key argument"
3245                      " must be set to the empty string");
3246                  return;
3247              }
3248              first_key = j+1;
3249              num_keys = c->argc - j - 1;
3250              break; &bsol;* All the remaining args are keys. */
3251          } else {
3252              addReply(c,shared.syntaxerr);
3253              return;
3254          }
3255      }
3256      if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != C_OK ||
3257          getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != C_OK)
3258      {
3259          return;
3260      }
3261      if (timeout <= 0) timeout = 1000;
3262      ov = zrealloc(ov,sizeof(robj*)*num_keys);
3263      kv = zrealloc(kv,sizeof(robj*)*num_keys);
3264      int oi = 0;
3265      for (j = 0; j < num_keys; j++) {
3266          if ((ov[oi] = lookupKeyRead(c->db,c->argv[first_key+j])) != NULL) {
3267              kv[oi] = c->argv[first_key+j];
3268              oi++;
3269          }
3270      }
3271      num_keys = oi;
3272      if (num_keys == 0) {
3273          zfree(ov); zfree(kv);
3274          addReplySds(c,sdsnew("+NOKEY\r\n"));
3275          return;
3276      }
3277  try_again:
3278      write_error = 0;
3279      cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);
3280      if (cs == NULL) {
3281          zfree(ov); zfree(kv);
3282          return; &bsol;* error sent to the client by migrateGetSocket() */
3283      }
3284      rioInitWithBuffer(&cmd,sdsempty());
3285      if (password) {
3286          serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
3287          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"AUTH",4));
3288          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,password,
3289              sdslen(password)));
3290      }
3291      int select = cs->last_dbid != dbid; &bsol;* Should we emit SELECT? */
3292      if (select) {
3293          serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
3294          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"SELECT",6));
3295          serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
3296      }
3297      int non_expired = 0; &bsol;* Number of keys that we'll find non expired.
3298                              Note that serializing large keys may take some time
3299                              so certain keys that were found non expired by the
3300                              lookupKey() function, may be expired later. */
3301      for (j = 0; j < num_keys; j++) {
3302          PORT_LONGLONG ttl = 0;
3303          PORT_LONGLONG expireat = getExpire(c->db,kv[j]);
3304          if (expireat != -1) {
3305              ttl = expireat-mstime();
3306              if (ttl < 0) {
3307                  continue;
3308              }
3309              if (ttl < 1) ttl = 1;
3310          }
3311          kv[non_expired++] = kv[j];
3312          serverAssertWithInfo(c,NULL,
3313              rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));
3314          if (server.cluster_enabled)
3315              serverAssertWithInfo(c,NULL,
3316                  rioWriteBulkString(&cmd,"RESTORE-ASKING",14));
3317          else
3318              serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"RESTORE",7));
3319          serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));
3320          serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,
3321                  sdslen(kv[j]->ptr)));
3322          serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));
3323          createDumpPayload(&payload,ov[j],kv[j]);
3324          serverAssertWithInfo(c,NULL,
3325              rioWriteBulkString(&cmd,payload.io.buffer.ptr,
3326                                 sdslen(payload.io.buffer.ptr)));
3327          sdsfree(payload.io.buffer.ptr);
3328          if (replace)
3329              serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"REPLACE",7));
3330      }
3331      num_keys = non_expired;
3332      errno = 0;
3333      {
3334          sds buf = cmd.io.buffer.ptr;
3335          size_t pos = 0, towrite;
3336          int nwritten = 0;
3337  #ifdef _WIN32
3338          while ((towrite = sdslen(buf) - pos) > 0) {
3339              towrite = (towrite > (64 * 1024) ? (64 * 1024) : towrite);
3340              while (nwritten != (signed) towrite) {
3341                  nwritten = (int) syncWrite(cs->fd, buf + pos, (ssize_t) towrite, timeout);
3342                  if (nwritten != (signed) towrite) {
3343                      DWORD err = GetLastError();
3344                      if (err == WSAEWOULDBLOCK) {
3345                          serverLog(LL_VERBOSE, "In migrate. WSAEWOULDBLOCK with synchronous socket: sleeping for 0.1s");
3346                          Sleep(100);
3347                      }
3348                      else {
3349                          serverLog(LL_WARNING, "SyncWrite failure toWrite=%d  written=%d err=%d timeout=%d ", towrite, nwritten, GetLastError(), timeout);
3350                          goto socket_err;
3351                      }
3352                  }
3353              }
3354              pos += nwritten;
3355              nwritten = 0;
3356          }
3357  #else
3358          while ((towrite = sdslen(buf)-pos) > 0) {
3359              towrite = (towrite > (64*1024) ? (64*1024) : towrite);
3360              nwritten = syncWrite(cs->fd,buf+pos,towrite,timeout);
3361              if (nwritten != (signed)towrite) {
3362                  write_error = 1;
3363                  goto socket_err;
3364              }
3365              pos += nwritten;
3366          }
3367  #endif
3368      }
3369      char buf0[1024]; &bsol;* Auth reply. */
3370      char buf1[1024]; &bsol;* Select reply. */
3371      char buf2[1024]; &bsol;* Restore reply. */
3372      if (password && syncReadLine(cs->fd, buf0, sizeof(buf0), timeout) <= 0)
3373          goto socket_err;
3374      if (select && syncReadLine(cs->fd, buf1, sizeof(buf1), timeout) <= 0)
3375          goto socket_err;
3376      int error_from_target = 0;
3377      int socket_error = 0;
3378      int del_idx = 1; &bsol;* Index of the key argument for the replicated DEL op. */
3379      if (!copy) newargv = zmalloc(sizeof(robj*)*(num_keys+1));
3380      for (j = 0; j < num_keys; j++) {
3381          if (syncReadLine(cs->fd, buf2, sizeof(buf2), timeout) <= 0) {
3382              socket_error = 1;
3383              break;
3384          }
3385          if ((password && buf0[0] == '-') ||
3386              (select && buf1[0] == '-') ||
3387              buf2[0] == '-')
3388          {
3389              if (!error_from_target) {
3390                  cs->last_dbid = -1;
3391                  char *errbuf;
3392                  if (password && buf0[0] == '-') errbuf = buf0;
3393                  else if (select && buf1[0] == '-') errbuf = buf1;
3394                  else errbuf = buf2;
3395                  error_from_target = 1;
3396                  addReplyErrorFormat(c,"Target instance replied with error: %s",
3397                      errbuf+1);
3398              }
3399          } else {
3400              if (!copy) {
3401                  dbDelete(c->db,kv[j]);
3402                  signalModifiedKey(c->db,kv[j]);
3403                  server.dirty++;
3404                  newargv[del_idx++] = kv[j];
3405                  incrRefCount(kv[j]);
3406              }
3407          }
3408      }
3409      if (!error_from_target && socket_error && j == 0 && may_retry &&
3410          errno != ETIMEDOUT)
3411      {
3412          goto socket_err; &bsol;* A retry is guaranteed because of tested conditions.*/
3413      }
3414      if (socket_error) migrateCloseSocket(c->argv[1],c->argv[2]);
3415      if (!copy) {
3416          if (del_idx > 1) {
3417              newargv[0] = createStringObject("DEL",3);
3418              replaceClientCommandVector(c,del_idx,newargv);
3419              argv_rewritten = 1;
3420          } else {
3421              zfree(newargv);
3422          }
3423          newargv = NULL; &bsol;* Make it safe to call zfree() on it in the future. */
3424      }
3425      if (!error_from_target && socket_error) {
3426          may_retry = 0;
3427          goto socket_err;
3428      }
3429      if (!error_from_target) {
3430          cs->last_dbid = dbid;
3431          addReply(c,shared.ok);
3432      } else {
3433      }
3434      sdsfree(cmd.io.buffer.ptr);
3435      zfree(ov); zfree(kv); zfree(newargv);
3436      return;
3437  socket_err:
3438  #ifdef _WIN32
3439      serverLog(LL_WARNING, "syncReadLine failure err=%d timeout=%d ", GetLastError(), timeout);
3440  #endif
3441      sdsfree(cmd.io.buffer.ptr);
3442      if (!argv_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);
3443      zfree(newargv);
3444      newargv = NULL; &bsol;* This will get reallocated on retry. */
3445      if (errno != ETIMEDOUT && may_retry) {
3446          may_retry = 0;
3447          goto try_again;
3448      }
3449      zfree(ov); zfree(kv);
3450      addReplySds(c,
3451          sdscatprintf(sdsempty(),
3452              "-IOERR error or timeout %s to target instance\r\n",
3453              write_error ? "writing" : "reading"));
3454      return;
3455  }
3456  void askingCommand(client *c) {
3457      if (server.cluster_enabled == 0) {
3458          addReplyError(c,"This instance has cluster support disabled");
3459          return;
3460      }
3461      c->flags |= CLIENT_ASKING;
3462      addReply(c,shared.ok);
3463  }
3464  void readonlyCommand(client *c) {
3465      if (server.cluster_enabled == 0) {
3466          addReplyError(c,"This instance has cluster support disabled");
3467          return;
3468      }
3469      c->flags |= CLIENT_READONLY;
3470      addReply(c,shared.ok);
3471  }
3472  void readwriteCommand(client *c) {
3473      c->flags &= ~CLIENT_READONLY;
3474      addReply(c,shared.ok);
3475  }
3476  clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
3477      clusterNode *n = NULL;
3478      robj *firstkey = NULL;
3479      int multiple_keys = 0;
3480      multiState *ms, _ms;
3481      multiCmd mc;
3482      int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;
3483      if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
3484          return myself;
3485      if (error_code) *error_code = CLUSTER_REDIR_NONE;
3486      if (cmd->proc == execCommand) {
3487          if (!(c->flags & CLIENT_MULTI)) return myself;
3488          ms = &c->mstate;
3489      } else {
3490          ms = &_ms;
3491          _ms.commands = &mc;
3492          _ms.count = 1;
3493          mc.argv = argv;
3494          mc.argc = argc;
3495          mc.cmd = cmd;
3496      }
3497      for (i = 0; i < ms->count; i++) {
3498          struct redisCommand *mcmd;
3499          robj **margv;
3500          int margc, *keyindex, numkeys, j;
3501          mcmd = ms->commands[i].cmd;
3502          margc = ms->commands[i].argc;
3503          margv = ms->commands[i].argv;
3504          keyindex = getKeysFromCommand(mcmd,margv,margc,&numkeys);
3505          for (j = 0; j < numkeys; j++) {
3506              robj *thiskey = margv[keyindex[j]];
3507              int thisslot = keyHashSlot((char*)thiskey->ptr,
3508                                         (int) sdslen(thiskey->ptr));              WIN_PORT_FIX &bsol;* cast (int) */
3509              if (firstkey == NULL) {
3510                  firstkey = thiskey;
3511                  slot = thisslot;
3512                  n = server.cluster->slots[slot];
3513                  if (n == NULL) {
3514                      getKeysFreeResult(keyindex);
3515                      if (error_code)
3516                          *error_code = CLUSTER_REDIR_DOWN_UNBOUND;
3517                      return NULL;
3518                  }
3519                  if (n == myself &&
3520                      server.cluster->migrating_slots_to[slot] != NULL)
3521                  {
3522                      migrating_slot = 1;
3523                  } else if (server.cluster->importing_slots_from[slot] != NULL) {
3524                      importing_slot = 1;
3525                  }
3526              } else {
3527                  if (!equalStringObjects(firstkey,thiskey)) {
3528                      if (slot != thisslot) {
3529                          getKeysFreeResult(keyindex);
3530                          if (error_code)
3531                              *error_code = CLUSTER_REDIR_CROSS_SLOT;
3532                          return NULL;
3533                      } else {
3534                          multiple_keys = 1;
3535                      }
3536                  }
3537              }
3538              if ((migrating_slot || importing_slot) &&
3539                  lookupKeyRead(&server.db[0],thiskey) == NULL)
3540              {
3541                  missing_keys++;
3542              }
3543          }
3544          getKeysFreeResult(keyindex);
3545      }
3546      if (n == NULL) return myself;
3547      if (server.cluster->state != CLUSTER_OK) {
3548          if (error_code) *error_code = CLUSTER_REDIR_DOWN_STATE;
3549          return NULL;
3550      }
3551      if (hashslot) *hashslot = slot;
3552      if ((migrating_slot || importing_slot) && cmd->proc == migrateCommand)
3553          return myself;
3554      if (migrating_slot && missing_keys) {
3555          if (error_code) *error_code = CLUSTER_REDIR_ASK;
3556          return server.cluster->migrating_slots_to[slot];
3557      }
3558      if (importing_slot &&
3559          (c->flags & CLIENT_ASKING || cmd->flags & CMD_ASKING))
3560      {
3561          if (multiple_keys && missing_keys) {
3562              if (error_code) *error_code = CLUSTER_REDIR_UNSTABLE;
3563              return NULL;
3564          } else {
3565              return myself;
3566          }
3567      }
3568      if (c->flags & CLIENT_READONLY &&
3569          (cmd->flags & CMD_READONLY || cmd->proc == evalCommand ||
3570           cmd->proc == evalShaCommand) &&
3571          nodeIsSlave(myself) &&
3572          myself->slaveof == n)
3573      {
3574          return myself;
3575      }
3576      if (n != myself && error_code) *error_code = CLUSTER_REDIR_MOVED;
3577      return n;
3578  }
3579  void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
3580      if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
3581          addReplySds(c,sdsnew("-CROSSSLOT Keys in request don't hash to the same slot\r\n"));
3582      } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
3583          addReplySds(c,sdsnew("-TRYAGAIN Multiple keys request during rehashing of slot\r\n"));
3584      } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
3585          addReplySds(c,sdsnew("-CLUSTERDOWN The cluster is down\r\n"));
3586      } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
3587          addReplySds(c,sdsnew("-CLUSTERDOWN Hash slot not served\r\n"));
3588      } else if (error_code == CLUSTER_REDIR_MOVED ||
3589                 error_code == CLUSTER_REDIR_ASK)
3590      {
3591          addReplySds(c,sdscatprintf(sdsempty(),
3592              "-%s %d %s:%d\r\n",
3593              (error_code == CLUSTER_REDIR_ASK) ? "ASK" : "MOVED",
3594              hashslot,n->ip,n->port));
3595      } else {
3596          serverPanic("getNodeByQuery() unknown error.");
3597      }
3598  }
3599  int clusterRedirectBlockedClientIfNeeded(client *c) {
3600      if (c->flags & CLIENT_BLOCKED &&
3601          (c->btype == BLOCKED_LIST ||
3602           c->btype == BLOCKED_ZSET ||
3603           c->btype == BLOCKED_STREAM))
3604      {
3605          dictEntry *de;
3606          dictIterator *di;
3607          if (server.cluster->state == CLUSTER_FAIL) {
3608              clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
3609              return 1;
3610          }
3611          di = dictGetIterator(c->bpop.keys);
3612          if ((de = dictNext(di)) != NULL) {
3613              robj *key = dictGetKey(de);
3614              int slot = keyHashSlot((char*)key->ptr, (int)sdslen(key->ptr));     WIN_PORT_FIX &bsol;* cast (int) */
3615              clusterNode *node = server.cluster->slots[slot];
3616              if ((c->flags & CLIENT_READONLY) &&
3617                  (c->lastcmd->flags & CMD_READONLY) &&
3618                  nodeIsSlave(myself) && myself->slaveof == node)
3619              {
3620                  node = myself;
3621              }
3622              if (node != myself &&
3623                  server.cluster->importing_slots_from[slot] == NULL)
3624              {
3625                  if (node == NULL) {
3626                      clusterRedirectClient(c,NULL,0,
3627                          CLUSTER_REDIR_DOWN_UNBOUND);
3628                  } else {
3629                      clusterRedirectClient(c,node,slot,
3630                          CLUSTER_REDIR_MOVED);
3631                  }
3632                  dictReleaseIterator(di);
3633                  return 1;
3634              }
3635          }
3636          dictReleaseIterator(di);
3637      }
3638      return 0;
3639  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-cluster.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-cluster.c</div>
                </div>
                <div class="column column_space"><pre><code>630      di = dictGetSafeIterator(server.cluster->nodes);
631      while((de = dictNext(di)) != NULL) {
632          clusterNode *node = dictGetVal(de);
</pre></code></div>
                <div class="column column_space"><pre><code>773      di = dictGetSafeIterator(server.cluster->nodes);
774      while((de = dictNext(di)) != NULL) {
775          clusterNode *node = dictGetVal(de);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    