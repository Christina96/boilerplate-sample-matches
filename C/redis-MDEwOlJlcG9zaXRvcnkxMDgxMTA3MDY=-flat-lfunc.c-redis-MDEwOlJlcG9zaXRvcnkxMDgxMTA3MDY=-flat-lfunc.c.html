
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lfunc.c</h3>
            <pre><code>1  #include <stddef.h>
2  #define lfunc_c
3  #define LUA_CORE
4  #include "lua.h"
5  #include "lfunc.h"
6  #include "lgc.h"
7  #include "lmem.h"
8  #include "lobject.h"
9  #include "lstate.h"
10  Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
11    Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
<span onclick='openModal()' class='match'>12    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
13    c->c.isC = 1;
14    c->c.env = e;
15    c->c.nupvalues = cast_byte(nelems);
16    return c;
</span>17  }
18  Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
19    Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
20    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
21    c->l.isC = 0;
22    c->l.env = e;
23    c->l.nupvalues = cast_byte(nelems);
24    while (nelems--) c->l.upvals[nelems] = NULL;
25    return c;
26  }
27  UpVal *luaF_newupval (lua_State *L) {
28    UpVal *uv = luaM_new(L, UpVal);
29    luaC_link(L, obj2gco(uv), LUA_TUPVAL);
30    uv->v = &uv->u.value;
31    setnilvalue(uv->v);
32    return uv;
33  }
34  UpVal *luaF_findupval (lua_State *L, StkId level) {
35    global_State *g = G(L);
36    GCObject **pp = &L->openupval;
37    UpVal *p;
38    UpVal *uv;
39    while (*pp != NULL && (p = ngcotouv(*pp))->v >= level) {
40      lua_assert(p->v != &p->u.value);
41      if (p->v == level) {  &bsol;* found a corresponding upvalue? */
42        if (isdead(g, obj2gco(p)))  &bsol;* is it dead? */
43          changewhite(obj2gco(p));  &bsol;* ressurect it */
44        return p;
45      }
46      pp = &p->next;
47    }
48    uv = luaM_new(L, UpVal);  &bsol;* not found: create a new one */
49    uv->tt = LUA_TUPVAL;
50    uv->marked = luaC_white(g);
51    uv->v = level;  &bsol;* current value lives in the stack */
52    uv->next = *pp;  &bsol;* chain it in the proper position */
53    *pp = obj2gco(uv);
54    uv->u.l.prev = &g->uvhead;  &bsol;* double link it in `uvhead' list */
55    uv->u.l.next = g->uvhead.u.l.next;
56    uv->u.l.next->u.l.prev = uv;
57    g->uvhead.u.l.next = uv;
58    lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
59    return uv;
60  }
61  static void unlinkupval (UpVal *uv) {
62    lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
63    uv->u.l.next->u.l.prev = uv->u.l.prev;  &bsol;* remove from `uvhead' list */
64    uv->u.l.prev->u.l.next = uv->u.l.next;
65  }
66  void luaF_freeupval (lua_State *L, UpVal *uv) {
67    if (uv->v != &uv->u.value)  &bsol;* is it open? */
68      unlinkupval(uv);  &bsol;* remove from open list */
69    luaM_free(L, uv);  &bsol;* free upvalue */
70  }
71  void luaF_close (lua_State *L, StkId level) {
72    UpVal *uv;
73    global_State *g = G(L);
74    while (L->openupval != NULL && (uv = ngcotouv(L->openupval))->v >= level) {
75      GCObject *o = obj2gco(uv);
76      lua_assert(!isblack(o) && uv->v != &uv->u.value);
77      L->openupval = uv->next;  &bsol;* remove from `open' list */
78      if (isdead(g, o))
79        luaF_freeupval(L, uv);  &bsol;* free upvalue */
80      else {
81        unlinkupval(uv);
82        setobj(L, &uv->u.value, uv->v);
83        uv->v = &uv->u.value;  &bsol;* now current value lives here */
84        luaC_linkupval(L, uv);  &bsol;* link upvalue into `gcroot' list */
85      }
86    }
87  }
88  Proto *luaF_newproto (lua_State *L) {
89    Proto *f = luaM_new(L, Proto);
90    luaC_link(L, obj2gco(f), LUA_TPROTO);
91    f->k = NULL;
92    f->sizek = 0;
93    f->p = NULL;
94    f->sizep = 0;
95    f->code = NULL;
96    f->sizecode = 0;
97    f->sizelineinfo = 0;
98    f->sizeupvalues = 0;
99    f->nups = 0;
100    f->upvalues = NULL;
101    f->numparams = 0;
102    f->is_vararg = 0;
103    f->maxstacksize = 0;
104    f->lineinfo = NULL;
105    f->sizelocvars = 0;
106    f->locvars = NULL;
107    f->linedefined = 0;
108    f->lastlinedefined = 0;
109    f->source = NULL;
110    return f;
111  }
112  void luaF_freeproto (lua_State *L, Proto *f) {
113    luaM_freearray(L, f->code, f->sizecode, Instruction);
114    luaM_freearray(L, f->p, f->sizep, Proto *);
115    luaM_freearray(L, f->k, f->sizek, TValue);
116    luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
117    luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
118    luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
119    luaM_free(L, f);
120  }
121  void luaF_freeclosure (lua_State *L, Closure *c) {
122    int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
123                            sizeLclosure(c->l.nupvalues);
124    luaM_freemem(L, c, size);
125  }
126  const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
127    int i;
128    for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
129      if (pc < f->locvars[i].endpc) {  &bsol;* is variable active? */
130        local_number--;
131        if (local_number == 0)
132          return getstr(f->locvars[i].varname);
133      }
134    }
135    return NULL;  &bsol;* not found */
136  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lfunc.c</h3>
            <pre><code>1  #include <stddef.h>
2  #define lfunc_c
3  #define LUA_CORE
4  #include "lua.h"
5  #include "lfunc.h"
6  #include "lgc.h"
7  #include "lmem.h"
8  #include "lobject.h"
9  #include "lstate.h"
10  Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
11    Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
12    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
13    c->c.isC = 1;
14    c->c.env = e;
15    c->c.nupvalues = cast_byte(nelems);
16    return c;
17  }
18  Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
19    Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
<span onclick='openModal()' class='match'>20    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
21    c->l.isC = 0;
22    c->l.env = e;
23    c->l.nupvalues = cast_byte(nelems);
24    while (nelems--) c->l.upvals[nelems] = NULL;
</span>25    return c;
26  }
27  UpVal *luaF_newupval (lua_State *L) {
28    UpVal *uv = luaM_new(L, UpVal);
29    luaC_link(L, obj2gco(uv), LUA_TUPVAL);
30    uv->v = &uv->u.value;
31    setnilvalue(uv->v);
32    return uv;
33  }
34  UpVal *luaF_findupval (lua_State *L, StkId level) {
35    global_State *g = G(L);
36    GCObject **pp = &L->openupval;
37    UpVal *p;
38    UpVal *uv;
39    while (*pp != NULL && (p = ngcotouv(*pp))->v >= level) {
40      lua_assert(p->v != &p->u.value);
41      if (p->v == level) {  &bsol;* found a corresponding upvalue? */
42        if (isdead(g, obj2gco(p)))  &bsol;* is it dead? */
43          changewhite(obj2gco(p));  &bsol;* ressurect it */
44        return p;
45      }
46      pp = &p->next;
47    }
48    uv = luaM_new(L, UpVal);  &bsol;* not found: create a new one */
49    uv->tt = LUA_TUPVAL;
50    uv->marked = luaC_white(g);
51    uv->v = level;  &bsol;* current value lives in the stack */
52    uv->next = *pp;  &bsol;* chain it in the proper position */
53    *pp = obj2gco(uv);
54    uv->u.l.prev = &g->uvhead;  &bsol;* double link it in `uvhead' list */
55    uv->u.l.next = g->uvhead.u.l.next;
56    uv->u.l.next->u.l.prev = uv;
57    g->uvhead.u.l.next = uv;
58    lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
59    return uv;
60  }
61  static void unlinkupval (UpVal *uv) {
62    lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
63    uv->u.l.next->u.l.prev = uv->u.l.prev;  &bsol;* remove from `uvhead' list */
64    uv->u.l.prev->u.l.next = uv->u.l.next;
65  }
66  void luaF_freeupval (lua_State *L, UpVal *uv) {
67    if (uv->v != &uv->u.value)  &bsol;* is it open? */
68      unlinkupval(uv);  &bsol;* remove from open list */
69    luaM_free(L, uv);  &bsol;* free upvalue */
70  }
71  void luaF_close (lua_State *L, StkId level) {
72    UpVal *uv;
73    global_State *g = G(L);
74    while (L->openupval != NULL && (uv = ngcotouv(L->openupval))->v >= level) {
75      GCObject *o = obj2gco(uv);
76      lua_assert(!isblack(o) && uv->v != &uv->u.value);
77      L->openupval = uv->next;  &bsol;* remove from `open' list */
78      if (isdead(g, o))
79        luaF_freeupval(L, uv);  &bsol;* free upvalue */
80      else {
81        unlinkupval(uv);
82        setobj(L, &uv->u.value, uv->v);
83        uv->v = &uv->u.value;  &bsol;* now current value lives here */
84        luaC_linkupval(L, uv);  &bsol;* link upvalue into `gcroot' list */
85      }
86    }
87  }
88  Proto *luaF_newproto (lua_State *L) {
89    Proto *f = luaM_new(L, Proto);
90    luaC_link(L, obj2gco(f), LUA_TPROTO);
91    f->k = NULL;
92    f->sizek = 0;
93    f->p = NULL;
94    f->sizep = 0;
95    f->code = NULL;
96    f->sizecode = 0;
97    f->sizelineinfo = 0;
98    f->sizeupvalues = 0;
99    f->nups = 0;
100    f->upvalues = NULL;
101    f->numparams = 0;
102    f->is_vararg = 0;
103    f->maxstacksize = 0;
104    f->lineinfo = NULL;
105    f->sizelocvars = 0;
106    f->locvars = NULL;
107    f->linedefined = 0;
108    f->lastlinedefined = 0;
109    f->source = NULL;
110    return f;
111  }
112  void luaF_freeproto (lua_State *L, Proto *f) {
113    luaM_freearray(L, f->code, f->sizecode, Instruction);
114    luaM_freearray(L, f->p, f->sizep, Proto *);
115    luaM_freearray(L, f->k, f->sizek, TValue);
116    luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
117    luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
118    luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
119    luaM_free(L, f);
120  }
121  void luaF_freeclosure (lua_State *L, Closure *c) {
122    int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
123                            sizeLclosure(c->l.nupvalues);
124    luaM_freemem(L, c, size);
125  }
126  const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
127    int i;
128    for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
129      if (pc < f->locvars[i].endpc) {  &bsol;* is variable active? */
130        local_number--;
131        if (local_number == 0)
132          return getstr(f->locvars[i].varname);
133      }
134    }
135    return NULL;  &bsol;* not found */
136  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lfunc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lfunc.c</div>
                </div>
                <div class="column column_space"><pre><code>12    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
13    c->c.isC = 1;
14    c->c.env = e;
15    c->c.nupvalues = cast_byte(nelems);
16    return c;
</pre></code></div>
                <div class="column column_space"><pre><code>20    luaC_link(L, obj2gco(c), LUA_TFUNCTION);
21    c->l.isC = 0;
22    c->l.env = e;
23    c->l.nupvalues = cast_byte(nelems);
24    while (nelems--) c->l.upvals[nelems] = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    