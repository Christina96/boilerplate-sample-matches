
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-read.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <string.h>
3  #include <stdlib.h>
4  #ifndef _MSC_VER
5  #include <unistd.h>
6  #endif
7  #include <assert.h>
8  #include <errno.h>
9  #include <ctype.h>
10  #include "read.h"
11  #include "sds.h"
12  static void __redisReaderSetError(redisReader *r, int type, const char *str) {
13      size_t len;
14      if (r->reply != NULL && r->fn && r->fn->freeObject) {
15          r->fn->freeObject(r->reply);
16          r->reply = NULL;
17      }
18      if (r->buf != NULL) {
19          sdsfree(r->buf);
20          r->buf = NULL;
21          r->pos = r->len = 0;
22      }
23      r->ridx = -1;
24      r->err = type;
25      len = strlen(str);
26      len = len < (sizeof(r->errstr)-1) ? len : (sizeof(r->errstr)-1);
27      memcpy(r->errstr,str,len);
28      r->errstr[len] = '\0';
29  }
30  static size_t chrtos(char *buf, size_t size, char byte) {
31      size_t len = 0;
32      switch(byte) {
33      case '\\':
34      case '"':
35          len = snprintf(buf,size,"\"\\%c\"",byte);
36          break;
37      case '\n': len = snprintf(buf,size,"\"\\n\""); break;
38      case '\r': len = snprintf(buf,size,"\"\\r\""); break;
39      case '\t': len = snprintf(buf,size,"\"\\t\""); break;
40      case '\a': len = snprintf(buf,size,"\"\\a\""); break;
41      case '\b': len = snprintf(buf,size,"\"\\b\""); break;
42      default:
43          if (isprint(byte))
44              len = snprintf(buf,size,"\"%c\"",byte);
45          else
46              len = snprintf(buf,size,"\"\\x%02x\"",(unsigned char)byte);
47          break;
48      }
49      return len;
50  }
51  static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {
52      char cbuf[8], sbuf[128];
53      chrtos(cbuf,sizeof(cbuf),byte);
54      snprintf(sbuf,sizeof(sbuf),
55          "Protocol error, got %s as reply type byte", cbuf);
56      __redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);
57  }
58  static void __redisReaderSetErrorOOM(redisReader *r) {
59      __redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");
60  }
61  static char *readBytes(redisReader *r, unsigned int bytes) {
62      char *p;
63      if (r->len-r->pos >= bytes) {
64          p = r->buf+r->pos;
65          r->pos += bytes;
66          return p;
67      }
68      return NULL;
69  }
70  static char *seekNewline(char *s, size_t len) {
71      int pos = 0;
72      int _len = len-1;
73      while (pos < _len) {
74          while(pos < _len && s[pos] != '\r') pos++;
75          if (pos==_len) {
76              return NULL;
77          } else {
78              if (s[pos+1] == '\n') {
79                  return s+pos;
80              } else {
81                  pos++;
82              }
83          }
84      }
85      return NULL;
86  }
87  static PORT_LONGLONG readLongLong(char *s) {
88      PORT_LONGLONG v = 0;
89      int dec, mult = 1;
90      char c;
91      if (*s == '-') {
92          mult = -1;
93          s++;
94      } else if (*s == '+') {
95          mult = 1;
96          s++;
97      }
98      while ((c = *(s++)) != '\r') {
99          dec = c - '0';
100          if (dec >= 0 && dec < 10) {
101              v *= 10;
102              v += dec;
103          } else {
104              return -1;
105          }
106      }
107      return mult*v;
108  }
109  static char *readLine(redisReader *r, int *_len) {
110      char *p, *s;
111      int len;
112      p = r->buf+r->pos;
113      s = seekNewline(p,(r->len-r->pos));
114      if (s != NULL) {
115          len = s-(r->buf+r->pos);
116          r->pos += len+2; &bsol;* skip \r\n */
117          if (_len) *_len = len;
118          return p;
119      }
120      return NULL;
121  }
122  static void moveToNextTask(redisReader *r) {
123      redisReadTask *cur, *prv;
124      while (r->ridx >= 0) {
125          if (r->ridx == 0) {
126              r->ridx--;
127              return;
128          }
129          cur = &(r->rstack[r->ridx]);
130          prv = &(r->rstack[r->ridx-1]);
131          assert(prv->type == REDIS_REPLY_ARRAY);
132          if (cur->idx == prv->elements-1) {
133              r->ridx--;
134          } else {
135              assert(cur->idx < prv->elements);
136              cur->type = -1;
137              cur->elements = -1;
138              cur->idx++;
139              return;
140          }
141      }
142  }
143  static int processLineItem(redisReader *r) {
144      redisReadTask *cur = &(r->rstack[r->ridx]);
145      void *obj;
146      char *p;
147      int len;
148      if ((p = readLine(r,&len)) != NULL) {
149          if (cur->type == REDIS_REPLY_INTEGER) {
150              if (r->fn && r->fn->createInteger)
151                  obj = r->fn->createInteger(cur,readLongLong(p));
152              else
153                  obj = (void*)REDIS_REPLY_INTEGER;
154          } else {
155              if (r->fn && r->fn->createString)
156                  obj = r->fn->createString(cur,p,len);
157              else
158                  obj = (void*)(size_t)(cur->type);
159          }
160          if (obj == NULL) {
161              __redisReaderSetErrorOOM(r);
162              return REDIS_ERR;
163          }
164          if (r->ridx == 0) r->reply = obj;
165          moveToNextTask(r);
166          return REDIS_OK;
167      }
168      return REDIS_ERR;
169  }
170  static int processBulkItem(redisReader *r) {
171      redisReadTask *cur = &(r->rstack[r->ridx]);
172      void *obj = NULL;
173      char *p, *s;
174      PORT_LONG len;
175      PORT_ULONG bytelen;
176      int success = 0;
177      p = r->buf+r->pos;
178      s = seekNewline(p,r->len-r->pos);
179      if (s != NULL) {
180          p = r->buf+r->pos;
181          bytelen = s-(r->buf+r->pos)+2; &bsol;* include \r\n */
182          len = readLongLong(p);
183          if (len < 0) {
184              if (r->fn && r->fn->createNil)
185                  obj = r->fn->createNil(cur);
186              else
187                  obj = (void*)REDIS_REPLY_NIL;
188              success = 1;
189          } else {
190              bytelen += len+2; &bsol;* include \r\n */
191              if (r->pos+bytelen <= r->len) {
192                  if (r->fn && r->fn->createString)
193                      obj = r->fn->createString(cur,s+2,len);
194                  else
195                      obj = (void*)REDIS_REPLY_STRING;
196                  success = 1;
197              }
198          }
199          if (success) {
200              if (obj == NULL) {
201                  __redisReaderSetErrorOOM(r);
202                  return REDIS_ERR;
203              }
204              r->pos += bytelen;
205              if (r->ridx == 0) r->reply = obj;
206              moveToNextTask(r);
207              return REDIS_OK;
208          }
209      }
210      return REDIS_ERR;
211  }
212  static int processMultiBulkItem(redisReader *r) {
213      redisReadTask *cur = &(r->rstack[r->ridx]);
214      void *obj;
215      char *p;
216      PORT_LONG elements;
217      int root = 0;
218      if (r->ridx == 8) {
219          __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
220              "No support for nested multi bulk replies with depth > 7");
221          return REDIS_ERR;
222      }
223      if ((p = readLine(r,NULL)) != NULL) {
224          elements = readLongLong(p);
225          root = (r->ridx == 0);
226          if (elements == -1) {
227              if (r->fn && r->fn->createNil)
228                  obj = r->fn->createNil(cur);
229              else
230                  obj = (void*)REDIS_REPLY_NIL;
231              if (obj == NULL) {
232                  __redisReaderSetErrorOOM(r);
233                  return REDIS_ERR;
234              }
235              moveToNextTask(r);
236          } else {
237              if (r->fn && r->fn->createArray)
238                  obj = r->fn->createArray(cur,elements);
239              else
240                  obj = (void*)REDIS_REPLY_ARRAY;
241              if (obj == NULL) {
242                  __redisReaderSetErrorOOM(r);
243                  return REDIS_ERR;
244              }
245              if (elements > 0) {
246                  cur->elements = elements;
247                  cur->obj = obj;
248                  r->ridx++;
249                  r->rstack[r->ridx].type = -1;
250                  r->rstack[r->ridx].elements = -1;
251                  r->rstack[r->ridx].idx = 0;
252                  r->rstack[r->ridx].obj = NULL;
253                  r->rstack[r->ridx].parent = cur;
254                  r->rstack[r->ridx].privdata = r->privdata;
255              } else {
256                  moveToNextTask(r);
257              }
258          }
259          if (root) r->reply = obj;
260          return REDIS_OK;
261      }
262      return REDIS_ERR;
263  }
264  static int processItem(redisReader *r) {
265      redisReadTask *cur = &(r->rstack[r->ridx]);
266      char *p;
267      if (cur->type < 0) {
268          if ((p = readBytes(r,1)) != NULL) {
269              switch (p[0]) {
270              case '-':
271                  cur->type = REDIS_REPLY_ERROR;
272                  break;
273              case '+':
274                  cur->type = REDIS_REPLY_STATUS;
275                  break;
276              case ':':
277                  cur->type = REDIS_REPLY_INTEGER;
278                  break;
279              case '$':
280                  cur->type = REDIS_REPLY_STRING;
281                  break;
282              case '*':
283                  cur->type = REDIS_REPLY_ARRAY;
284                  break;
285              default:
286                  __redisReaderSetErrorProtocolByte(r,*p);
287                  return REDIS_ERR;
288              }
289          } else {
290              return REDIS_ERR;
291          }
292      }
293      switch(cur->type) {
294      case REDIS_REPLY_ERROR:
295      case REDIS_REPLY_STATUS:
296      case REDIS_REPLY_INTEGER:
297          return processLineItem(r);
298      case REDIS_REPLY_STRING:
299          return processBulkItem(r);
300      case REDIS_REPLY_ARRAY:
301          return processMultiBulkItem(r);
302      default:
303          assert(NULL);
304          return REDIS_ERR; &bsol;* Avoid warning. */
305      }
306  }
307  redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
308      redisReader *r;
309      r = calloc(sizeof(redisReader),1);
310      if (r == NULL)
311          return NULL;
312      r->err = 0;
313      r->errstr[0] = '\0';
314      r->fn = fn;
315      r->buf = sdsempty();
316      r->maxbuf = REDIS_READER_MAX_BUF;
317      if (r->buf == NULL) {
318          free(r);
319          return NULL;
320      }
321      r->ridx = -1;
322      return r;
323  }
324  void redisReaderFree(redisReader *r) {
325      if (r->reply != NULL && r->fn && r->fn->freeObject)
326          r->fn->freeObject(r->reply);
327      if (r->buf != NULL)
328          sdsfree(r->buf);
329      free(r);
330  }
331  int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
332      sds newbuf;
333      if (r->err)
334          return REDIS_ERR;
335      if (buf != NULL && len >= 1) {
336          if (r->len == 0 && r->maxbuf != 0 && sdsavail(r->buf) > r->maxbuf) {
<span onclick='openModal()' class='match'>337              sdsfree(r->buf);
338              r->buf = sdsempty();
339              r->pos = 0;
</span>340              assert(r->buf != NULL);
341          }
342          newbuf = sdscatlen(r->buf,buf,len);
343          if (newbuf == NULL) {
344              __redisReaderSetErrorOOM(r);
345              return REDIS_ERR;
346          }
347          r->buf = newbuf;
348          r->len = sdslen(r->buf);
349      }
350      return REDIS_OK;
351  }
352  int redisReaderGetReply(redisReader *r, void **reply) {
353      if (reply != NULL)
354          *reply = NULL;
355      if (r->err)
356          return REDIS_ERR;
357      if (r->len == 0)
358          return REDIS_OK;
359      if (r->ridx == -1) {
360          r->rstack[0].type = -1;
361          r->rstack[0].elements = -1;
362          r->rstack[0].idx = -1;
363          r->rstack[0].obj = NULL;
364          r->rstack[0].parent = NULL;
365          r->rstack[0].privdata = r->privdata;
366          r->ridx = 0;
367      }
368      while (r->ridx >= 0)
369          if (processItem(r) != REDIS_OK)
370              break;
371      if (r->err)
372          return REDIS_ERR;
373      if (r->pos >= 1024) {
374          sdsrange(r->buf,r->pos,-1);
375          r->pos = 0;
376          r->len = sdslen(r->buf);
377      }
378      if (r->ridx == -1) {
379          if (reply != NULL)
380              *reply = r->reply;
381          r->reply = NULL;
382      }
383      return REDIS_OK;
384  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <string.h>
3  #include <stdlib.h>
4  #ifndef _WIN32
5  #include <unistd.h>
6  #endif
7  #include <assert.h>
8  #include <errno.h>
9  #include <ctype.h>
10  #include "hiredis.h"
11  #include "net.h"
12  #include "sds.h"
13  #ifdef _WIN32
14  #include "win32_hiredis.h"
15  #endif
16  static redisReply *createReplyObject(int type);
17  static void *createStringObject(const redisReadTask *task, char *str, size_t len);
18  static void *createArrayObject(const redisReadTask *task, int elements);
19  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value);
20  static void *createNilObject(const redisReadTask *task);
21  static redisReplyObjectFunctions defaultFunctions = {
22  	createStringObject,
23  	createArrayObject,
24  	createIntegerObject,
25  	createNilObject,
26  	freeReplyObject
27  };
28  static redisReply *createReplyObject(int type) {
29  	redisReply *r = calloc(1, sizeof(*r));
30  	if (r == NULL)
31  		return NULL;
32  	r->type = type;
33  	return r;
34  }
35  void freeReplyObject(void *reply) {
36  	redisReply *r = reply;
37  	size_t j;
38  	if (r == NULL)
39  		return;
40  	switch (r->type) {
41  	case REDIS_REPLY_INTEGER:
42  		break; &bsol;* Nothing to free */
43  	case REDIS_REPLY_ARRAY:
44  		if (r->element != NULL) {
45  			for (j = 0; j < r->elements; j++)
46  				if (r->element[j] != NULL)
47  					freeReplyObject(r->element[j]);
48  			free(r->element);
49  		}
50  		break;
51  	case REDIS_REPLY_ERROR:
52  	case REDIS_REPLY_STATUS:
53  	case REDIS_REPLY_STRING:
54  		if (r->str != NULL)
55  			free(r->str);
56  		break;
57  	}
58  	free(r);
59  }
60  static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
61  	redisReply *r, *parent;
62  	char *buf;
63  	r = createReplyObject(task->type);
64  	if (r == NULL)
65  		return NULL;
66  	buf = malloc(len + 1);
67  	if (buf == NULL) {
68  		freeReplyObject(r);
69  		return NULL;
70  	}
71  	assert(task->type == REDIS_REPLY_ERROR ||
72  		task->type == REDIS_REPLY_STATUS ||
73  		task->type == REDIS_REPLY_STRING);
74  	memcpy(buf, str, len);
75  	buf[len] = '\0';
76  	r->str = buf;
77  	r->len = (int)len;
78  	if (task->parent) {
79  		parent = task->parent->obj;
80  		assert(parent->type == REDIS_REPLY_ARRAY);
81  		parent->element[task->idx] = r;
82  	}
83  	return r;
84  }
85  static void *createArrayObject(const redisReadTask *task, int elements) {
86  	redisReply *r, *parent;
87  	r = createReplyObject(REDIS_REPLY_ARRAY);
88  	if (r == NULL)
89  		return NULL;
90  	if (elements > 0) {
91  		r->element = calloc(elements, sizeof(redisReply*));
92  		if (r->element == NULL) {
93  			freeReplyObject(r);
94  			return NULL;
95  		}
96  	}
97  	r->elements = elements;
98  	if (task->parent) {
99  		parent = task->parent->obj;
100  		assert(parent->type == REDIS_REPLY_ARRAY);
101  		parent->element[task->idx] = r;
102  	}
103  	return r;
104  }
105  static void *createIntegerObject(const redisReadTask *task, PORT_LONGLONG value) {
106  	redisReply *r, *parent;
107  	r = createReplyObject(REDIS_REPLY_INTEGER);
108  	if (r == NULL)
109  		return NULL;
110  	r->integer = value;
111  	if (task->parent) {
112  		parent = task->parent->obj;
113  		assert(parent->type == REDIS_REPLY_ARRAY);
114  		parent->element[task->idx] = r;
115  	}
116  	return r;
117  }
118  static void *createNilObject(const redisReadTask *task) {
119  	redisReply *r, *parent;
120  	r = createReplyObject(REDIS_REPLY_NIL);
121  	if (r == NULL)
122  		return NULL;
123  	if (task->parent) {
124  		parent = task->parent->obj;
125  		assert(parent->type == REDIS_REPLY_ARRAY);
126  		parent->element[task->idx] = r;
127  	}
128  	return r;
129  }
130  static uint32_t countDigits(uint64_t v) {
131  	uint32_t result = 1;
132  	for (;;) {
133  		if (v < 10) return result;
134  		if (v < 100) return result + 1;
135  		if (v < 1000) return result + 2;
136  		if (v < 10000) return result + 3;
137  		v /= 10000U;
138  		result += 4;
139  	}
140  }
141  static size_t bulklen(size_t len) {
142  	return (size_t)(1 + countDigits(len) + 2 + len + 2);
143  }
144  int redisvFormatCommand(char **target, const char *format, va_list ap) {
145  	const char *c = format;
146  	char *cmd = NULL; &bsol;* final command */
147  	int pos; &bsol;* position in final command */
148  	sds curarg, newarg; &bsol;* current argument */
149  	int touched = 0; &bsol;* was the current argument touched? */
150  	char **curargv = NULL, **newargv = NULL;
151  	int argc = 0;
152  	int totlen = 0;
153  	int error_type = 0; &bsol;* 0 = no error; -1 = memory error; -2 = format error */
154  	int j;
155  	if (target == NULL)
156  		return -1;
157  	curarg = sdsempty();
158  	if (curarg == NULL)
159  		return -1;
160  	while (*c != '\0') {
161  		if (*c != '%' || c[1] == '\0') {
162  			if (*c == ' ') {
163  				if (touched) {
164  					newargv = realloc(curargv, sizeof(char*)*(argc + 1));
165  					if (newargv == NULL) goto memory_err;
166  					curargv = newargv;
167  					curargv[argc++] = curarg;
168  					totlen += (int)bulklen(sdslen(curarg));
169  					curarg = sdsempty();
170  					if (curarg == NULL) goto memory_err;
171  					touched = 0;
172  				}
173  			}
174  			else {
175  				newarg = sdscatlen(curarg, c, 1);
176  				if (newarg == NULL) goto memory_err;
177  				curarg = newarg;
178  				touched = 1;
179  			}
180  		}
181  		else {
182  			char *arg;
183  			size_t size;
184  			newarg = curarg;
185  			switch (c[1]) {
186  			case 's':
187  				arg = va_arg(ap, char*);
188  				size = strlen(arg);
189  				if (size > 0)
190  					newarg = sdscatlen(curarg, arg, size);
191  				break;
192  			case 'b':
193  				arg = va_arg(ap, char*);
194  				size = va_arg(ap, size_t);
195  				if (size > 0)
196  					newarg = sdscatlen(curarg, arg, size);
197  				break;
198  			case '%':
199  				newarg = sdscat(curarg, "%");
200  				break;
201  			default:
202  			{
203  				static const char intfmts[] = "diouxX";
204  				static const char flags[] = "#0-+ ";
205  				char _format[16];
206  				const char *_p = c + 1;
207  				size_t _l = 0;
208  				va_list _cpy;
209  				while (*_p != '\0' && strchr(flags, *_p) != NULL) _p++;
210  				while (*_p != '\0' && isdigit(*_p)) _p++;
211  				if (*_p == '.') {
212  					_p++;
213  					while (*_p != '\0' && isdigit(*_p)) _p++;
214  				}
215  				va_copy(_cpy, ap);
216  				if (strchr(intfmts, *_p) != NULL) {
217  					va_arg(ap, int);
218  					goto fmt_valid;
219  				}
220  				if (strchr("eEfFgGaA", *_p) != NULL) {
221  					va_arg(ap, double);
222  					goto fmt_valid;
223  				}
224  				if (_p[0] == 'h' && _p[1] == 'h') {
225  					_p += 2;
226  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
227  						va_arg(ap, int); &bsol;* char gets promoted to int */
228  						goto fmt_valid;
229  					}
230  					goto fmt_invalid;
231  				}
232  				if (_p[0] == 'h') {
233  					_p += 1;
234  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
235  						va_arg(ap, int); &bsol;* short gets promoted to int */
236  						goto fmt_valid;
237  					}
238  					goto fmt_invalid;
239  				}
240  				if (_p[0] == 'l' && _p[1] == 'l') {
241  					_p += 2;
242  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
243  						va_arg(ap, PORT_LONGLONG);
244  						goto fmt_valid;
245  					}
246  					goto fmt_invalid;
247  				}
248  				if (_p[0] == 'l') {
249  					_p += 1;
250  					if (*_p != '\0' && strchr(intfmts, *_p) != NULL) {
251  						va_arg(ap, PORT_LONG);
252  						goto fmt_valid;
253  					}
254  					goto fmt_invalid;
255  				}
256  			fmt_invalid:
257  				va_end(_cpy);
258  				goto format_err;
259  			fmt_valid:
260  				_l = (_p + 1) - c;
261  				if (_l < sizeof(_format) - 2) {
262  					memcpy(_format, c, _l);
263  					_format[_l] = '\0';
264  					newarg = sdscatvprintf(curarg, _format, _cpy);
265  					c = _p - 1;
266  				}
267  				va_end(_cpy);
268  				break;
269  			}
270  			}
271  			if (newarg == NULL) goto memory_err;
272  			curarg = newarg;
273  			touched = 1;
274  			c++;
275  		}
276  		c++;
277  	}
278  	if (touched) {
279  		newargv = realloc(curargv, sizeof(char*)*(argc + 1));
280  		if (newargv == NULL) goto memory_err;
281  		curargv = newargv;
282  		curargv[argc++] = curarg;
283  		totlen += (int)bulklen(sdslen(curarg));
284  	}	else {
285  		sdsfree(curarg);
286  	}
287  	curarg = NULL;
288  	totlen += 1 + countDigits(argc) + 2;
289  	cmd = malloc(totlen + 1);
290  	if (cmd == NULL) goto memory_err;
291  	pos = sprintf(cmd, "*%d\r\n", argc);
292  	for (j = 0; j < argc; j++) {
293  		pos += sprintf(cmd + pos, "$%Iu\r\n", sdslen(curargv[j]));                  WIN_PORT_FIX &bsol;* %zu -> %Iu */
294  			memcpy(cmd + pos, curargv[j], sdslen(curargv[j]));
295  		pos += (int)sdslen(curargv[j]);
296  		sdsfree(curargv[j]);
297  		cmd[pos++] = '\r';
298  		cmd[pos++] = '\n';
299  	}
300  	assert(pos == totlen);
301  	cmd[pos] = '\0';
302  	free(curargv);
303  	*target = cmd;
304  	return totlen;
305  format_err:
306  	error_type = -2;
307  	goto cleanup;
308  memory_err:
309  	error_type = -1;
310  	goto cleanup;
311  cleanup:
312  	if (curargv) {
313  		while (argc--)
314  			sdsfree(curargv[argc]);
315  		free(curargv);
316  	}
317  	sdsfree(curarg);
318  	if (cmd != NULL)
319  		free(cmd);
320  	return error_type;
321  }
322  int redisFormatCommand(char **target, const char *format, ...) {
323  	va_list ap;
324  	int len;
325  	va_start(ap, format);
326  	len = redisvFormatCommand(target, format, ap);
327  	va_end(ap);
328  	if (len < 0)
329  		len = -1;
330  	return len;
331  }
332  int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
333  	const size_t *argvlen)
334  {
335  	sds cmd;
336  	PORT_ULONGLONG totlen;
337  	int j;
338  	size_t len;
339  	if (target == NULL)
340  		return -1;
341  	totlen = 1 + countDigits(argc) + 2;
342  	for (j = 0; j < argc; j++) {
343  		len = argvlen ? argvlen[j] : strlen(argv[j]);
344  		totlen += bulklen(len);
345  	}
346  	cmd = sdsempty();
347  	if (cmd == NULL)
348  		return -1;
349  	cmd = sdsMakeRoomFor(cmd, totlen);
350  	if (cmd == NULL)
351  		return -1;
352  	cmd = sdscatfmt(cmd, "*%i\r\n", argc);
353  	for (j = 0; j < argc; j++) {
354  		len = argvlen ? argvlen[j] : strlen(argv[j]);
355  		cmd = sdscatfmt(cmd, "$%u\r\n", len);
356  		cmd = sdscatlen(cmd, argv[j], len);
357  		cmd = sdscatlen(cmd, "\r\n", sizeof("\r\n") - 1);
358  	}
359  	assert(sdslen(cmd) == totlen);
360  	*target = cmd;
361  	return totlen;
362  }
363  void redisFreeSdsCommand(sds cmd) {
364  	sdsfree(cmd);
365  }
366  int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
367  	char *cmd = NULL; &bsol;* final command */
368  	int pos; &bsol;* position in final command */
369  	size_t len;
370  	int totlen, j;
371  	if (target == NULL)
372  		return -1;
373  	totlen = 1 + countDigits(argc) + 2;
374  	for (j = 0; j < argc; j++) {
375  		len = argvlen ? argvlen[j] : strlen(argv[j]);
376  		totlen += bulklen(len);
377  	}
378  	cmd = malloc(totlen + 1);
379  	if (cmd == NULL)
380  		return -1;
381  	pos = sprintf(cmd, "*%d\r\n", argc);
382  	for (j = 0; j < argc; j++) {
383  		len = argvlen ? argvlen[j] : strlen(argv[j]);
384  		pos += sprintf(cmd + pos, "$%Iu\r\n", len);                                 WIN_PORT_FIX &bsol;* %zu -> %Iu */
385  			memcpy(cmd + pos, argv[j], len);
386  		pos += (int)len;
387  		cmd[pos++] = '\r';
388  		cmd[pos++] = '\n';
389  	}
390  	assert(pos == totlen);
391  	cmd[pos] = '\0';
392  	*target = cmd;
393  	return totlen;
394  }
395  void redisFreeCommand(char *cmd) {
396  	free(cmd);
397  }
398  void __redisSetError(redisContext *c, int type, const char *str) {
399  	size_t len;
400  	c->err = type;
401  	if (str != NULL) {
402  		len = strlen(str);
403  		len = len < (sizeof(c->errstr) - 1) ? len : (sizeof(c->errstr) - 1);
404  		memcpy(c->errstr, str, len);
405  		c->errstr[len] = '\0';
406      } else {
407  		assert(type == REDIS_ERR_IO);
408  		__redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
409  	}
410  }
411  redisReader *redisReaderCreate(void) {
412  	return redisReaderCreateWithFunctions(&defaultFunctions);
413  }
414  static redisContext *redisContextInit(void) {
415  	redisContext *c;
416  	c = calloc(1, sizeof(redisContext));
417  	if (c == NULL)
418  		return NULL;
419  	c->err = 0;
420  	c->errstr[0] = '\0';
421  	c->obuf = sdsempty();
422  	c->reader = redisReaderCreate();
423  	c->tcp.host = NULL;
424  	c->tcp.source_addr = NULL;
425  	c->unix_sock.path = NULL;
426  	c->timeout = NULL;
427  	if (c->obuf == NULL || c->reader == NULL) {
428  		redisFree(c);
429  		return NULL;
430  	}
431  	return c;
432  }
433  void redisFree(redisContext *c) {
434  	if (c == NULL)
435  		return;
436  	if (c->fd > 0)
437  		close(c->fd);
438  	if (c->obuf != NULL)
439  		sdsfree(c->obuf);
440  	if (c->reader != NULL)
441  		redisReaderFree(c->reader);
442  	if (c->tcp.host)
443  		free(c->tcp.host);
444  	if (c->tcp.source_addr)
445  		free(c->tcp.source_addr);
446  	if (c->unix_sock.path)
447  		free(c->unix_sock.path);
448  	if (c->timeout)
449  		free(c->timeout);
450  	free(c);
451  }
452  int redisFreeKeepFd(redisContext *c) {
453  	int fd = c->fd;
454  	c->fd = -1;
455  	redisFree(c);
456  	return fd;
457  }
458  int redisReconnect(redisContext *c) {
459  	c->err = 0;
460  	memset(c->errstr, '\0', strlen(c->errstr));
461  	if (c->fd > 0) {
462  		close(c->fd);
463  	}
464  	sdsfree(c->obuf);
<span onclick='openModal()' class='match'>465  	redisReaderFree(c->reader);
466  	c->obuf = sdsempty();
467  	c->reader = redisReaderCreate();
</span>468  	if (c->connection_type == REDIS_CONN_TCP) {
469  		return redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
470  			c->timeout, c->tcp.source_addr);
471      } else if (c->connection_type == REDIS_CONN_UNIX) {
472  		return redisContextConnectUnix(c, c->unix_sock.path, c->timeout);
473      } else {
474  		__redisSetError(c, REDIS_ERR_OTHER, "Not enough information to reconnect");
475  	}
476  	return REDIS_ERR;
477  }
478  redisContext *redisConnect(const char *ip, int port) {
479  	redisContext *c;
480  	c = redisContextInit();
481  	if (c == NULL)
482  		return NULL;
483  	c->flags |= REDIS_BLOCK;
484  	redisContextConnectTcp(c, ip, port, NULL);
485  	return c;
486  }
487  redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
488  	redisContext *c;
489  	c = redisContextInit();
490  	if (c == NULL)
491  		return NULL;
492  	c->flags |= REDIS_BLOCK;
493  	redisContextConnectTcp(c, ip, port, &tv);
494  	return c;
495  }
496  redisContext *redisConnectNonBlock(const char *ip, int port) {
497  	redisContext *c;
498  	c = redisContextInit();
499  	if (c == NULL)
500  		return NULL;
501  	c->flags &= ~REDIS_BLOCK;
502  	redisContextConnectTcp(c, ip, port, NULL);
503  	return c;
504  }
505  redisContext *redisConnectBindNonBlock(const char *ip, int port,
506  	const char *source_addr) {
507  	redisContext *c = redisContextInit();
508  	c->flags &= ~REDIS_BLOCK;
509  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
510  	return c;
511  }
512  redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
513  	const char *source_addr) {
514  	redisContext *c = redisContextInit();
515  	c->flags &= ~REDIS_BLOCK;
516  	c->flags |= REDIS_REUSEADDR;
517  	redisContextConnectBindTcp(c, ip, port, NULL, source_addr);
518  	return c;
519  }
520  redisContext *redisConnectUnix(const char *path) {
521  	redisContext *c;
522  	c = redisContextInit();
523  	if (c == NULL)
524  		return NULL;
525  	c->flags |= REDIS_BLOCK;
526  	redisContextConnectUnix(c, path, NULL);
527  	return c;
528  }
529  redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {
530  	redisContext *c;
531  	c = redisContextInit();
532  	if (c == NULL)
533  		return NULL;
534  	c->flags |= REDIS_BLOCK;
535  	redisContextConnectUnix(c, path, &tv);
536  	return c;
537  }
538  redisContext *redisConnectUnixNonBlock(const char *path) {
539  	redisContext *c;
540  	c = redisContextInit();
541  	if (c == NULL)
542  		return NULL;
543  	c->flags &= ~REDIS_BLOCK;
544  	redisContextConnectUnix(c, path, NULL);
545  	return c;
546  }
547  redisContext *redisConnectFd(int fd) {
548  	redisContext *c;
549  	c = redisContextInit();
550  	if (c == NULL)
551  		return NULL;
552  	c->fd = fd;
553  	c->flags |= REDIS_BLOCK | REDIS_CONNECTED;
554  	return c;
555  }
556  #ifdef _WIN32
557  redisContext *redisPreConnectNonBlock(const char *ip, int port, SOCKADDR_STORAGE *ss) {
558  	redisContext *c = redisContextInit();
559  	c->fd = -1;
560  	c->flags &= ~REDIS_BLOCK;
561  	redisContextPreConnectTcp(c, ip, port, NULL, ss);
562  	return c;
563  }
564  #endif
565  int redisSetTimeout(redisContext *c, const struct timeval tv) {
566  	if (c->flags & REDIS_BLOCK)
567  		return redisContextSetTimeout(c, tv);
568  	return REDIS_ERR;
569  }
570  int redisEnableKeepAlive(redisContext *c) {
571  	if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)
572  		return REDIS_ERR;
573  	return REDIS_OK;
574  }
575  int redisBufferRead(redisContext *c) {
576  	char buf[1024 * 16];
577  	int nread;
578  	if (c->err)
579  		return REDIS_ERR;
580  	nread = (int)read(c->fd, buf, sizeof(buf));                                   WIN_PORT_FIX &bsol;* cast (int) */
581  		if (nread == -1) {
582  			if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
583  			}
584  			else {
585  				__redisSetError(c, REDIS_ERR_IO, NULL);
586  				return REDIS_ERR;
587  			}
588  		}
589  		else if (nread == 0) {
590  			__redisSetError(c, REDIS_ERR_EOF, "Server closed the connection");
591  			return REDIS_ERR;
592  		}
593  		else {
594  			if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
595  				__redisSetError(c, c->reader->err, c->reader->errstr);
596  				return REDIS_ERR;
597  			}
598  		}
599  		return REDIS_OK;
600  }
601  #ifdef _WIN32
602  int redisBufferReadDone(redisContext *c, char *buf, ssize_t nread) {
603  	if (nread == -1) {
604  		if (errno == EAGAIN && !(c->flags & REDIS_BLOCK)) {
605  		}
606  		else {
607  			__redisSetError(c, REDIS_ERR_IO, NULL);
608  			return REDIS_ERR;
609  		}
610  	}
611  	else if (nread == 0) {
612  		__redisSetError(c, REDIS_ERR_EOF, sdsnew("Server closed the connection"));
613  		return REDIS_ERR;
614  	}
615  	else {
616  		if (redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {
617  			__redisSetError(c, c->reader->err, c->reader->errstr);
618  			return REDIS_ERR;
619  		}
620  	}
621  	return REDIS_OK;
622  }
623  #endif
624  int redisBufferWrite(redisContext *c, int *done) {
625  	int nwritten;
626  	if (c->err)
627  		return REDIS_ERR;
628  	if (sdslen(c->obuf) > 0) {
629  		nwritten = (int)write(c->fd, c->obuf, sdslen(c->obuf));                   WIN_PORT_FIX &bsol;* cast (int) */
630  			if (nwritten == -1) {
631  				if ((errno == EAGAIN && !(c->flags & REDIS_BLOCK)) || (errno == EINTR)) {
632  				}
633  				else {
634  					__redisSetError(c, REDIS_ERR_IO, NULL);
635  					return REDIS_ERR;
636  				}
637  			}
638  			else if (nwritten > 0) {
639  				if (nwritten == (signed)sdslen(c->obuf)) {
640  					sdsfree(c->obuf);
641  					c->obuf = sdsempty();
642  				}
643  				else {
644  					sdsrange(c->obuf, nwritten, -1);
645  				}
646  			}
647  	}
648  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
649  	return REDIS_OK;
650  }
651  #ifdef _WIN32
652  int redisBufferWriteDone(redisContext *c, int nwritten, int *done) {
653  	if (nwritten > 0) {
654  		if (nwritten == (signed)sdslen(c->obuf)) {
655  			sdsfree(c->obuf);
656  			c->obuf = sdsempty();
657  		}
658  		else {
659  			sdsrange(c->obuf, nwritten, -1);
660  		}
661  	}
662  	if (done != NULL) *done = (sdslen(c->obuf) == 0);
663  	return REDIS_OK;
664  }
665  #endif
666  int redisGetReplyFromReader(redisContext *c, void **reply) {
667  	if (redisReaderGetReply(c->reader, reply) == REDIS_ERR) {
668  		__redisSetError(c, c->reader->err, c->reader->errstr);
669  		return REDIS_ERR;
670  	}
671  	return REDIS_OK;
672  }
673  int redisGetReply(redisContext *c, void **reply) {
674  	int wdone = 0;
675  	void *aux = NULL;
676  	if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
677  		return REDIS_ERR;
678  	if (aux == NULL && c->flags & REDIS_BLOCK) {
679  		do {
680  			if (redisBufferWrite(c, &wdone) == REDIS_ERR)
681  				return REDIS_ERR;
682  		} while (!wdone);
683  		do {
684  			if (redisBufferRead(c) == REDIS_ERR)
685  				return REDIS_ERR;
686  			if (redisGetReplyFromReader(c, &aux) == REDIS_ERR)
687  				return REDIS_ERR;
688  		} while (aux == NULL);
689  	}
690  	if (reply != NULL) *reply = aux;
691  	return REDIS_OK;
692  }
693  int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
694  	sds newbuf;
695  	newbuf = sdscatlen(c->obuf, cmd, len);
696  	if (newbuf == NULL) {
697  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
698  		return REDIS_ERR;
699  	}
700  	c->obuf = newbuf;
701  	return REDIS_OK;
702  }
703  int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
704  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
705  		return REDIS_ERR;
706  	}
707  	return REDIS_OK;
708  }
709  int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {
710  	char *cmd;
711  	int len;
712  	len = redisvFormatCommand(&cmd, format, ap);
713  	if (len == -1) {
714  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
715  		return REDIS_ERR;
716  	}
717  	else if (len == -2) {
718  		__redisSetError(c, REDIS_ERR_OTHER, "Invalid format string");
719  		return REDIS_ERR;
720  	}
721  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
722  		free(cmd);
723  		return REDIS_ERR;
724  	}
725  	free(cmd);
726  	return REDIS_OK;
727  }
728  int redisAppendCommand(redisContext *c, const char *format, ...) {
729  	va_list ap;
730  	int ret;
731  	va_start(ap, format);
732  	ret = redisvAppendCommand(c, format, ap);
733  	va_end(ap);
734  	return ret;
735  }
736  int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
737  	sds cmd;
738  	int len;
739  	len = redisFormatSdsCommandArgv(&cmd, argc, argv, argvlen);
740  	if (len == -1) {
741  		__redisSetError(c, REDIS_ERR_OOM, "Out of memory");
742  		return REDIS_ERR;
743  	}
744  	if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
745  		sdsfree(cmd);
746  		return REDIS_ERR;
747  	}
748  	sdsfree(cmd);
749  	return REDIS_OK;
750  }
751  static void *__redisBlockForReply(redisContext *c) {
752  	void *reply;
753  	if (c->flags & REDIS_BLOCK) {
754  		if (redisGetReply(c, &reply) != REDIS_OK)
755  			return NULL;
756  		return reply;
757  	}
758  	return NULL;
759  }
760  void *redisvCommand(redisContext *c, const char *format, va_list ap) {
761  	if (redisvAppendCommand(c, format, ap) != REDIS_OK)
762  		return NULL;
763  	return __redisBlockForReply(c);
764  }
765  void *redisCommand(redisContext *c, const char *format, ...) {
766  	va_list ap;
767  	void *reply = NULL;
768  	va_start(ap, format);
769  	reply = redisvCommand(c, format, ap);
770  	va_end(ap);
771  	return reply;
772  }
773  void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
774  	if (redisAppendCommandArgv(c, argc, argv, argvlen) != REDIS_OK)
775  		return NULL;
776  	return __redisBlockForReply(c);
777  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-read.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hiredis.c</div>
                </div>
                <div class="column column_space"><pre><code>337              sdsfree(r->buf);
338              r->buf = sdsempty();
339              r->pos = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>465  	redisReaderFree(c->reader);
466  	c->obuf = sdsempty();
467  	c->reader = redisReaderCreate();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    