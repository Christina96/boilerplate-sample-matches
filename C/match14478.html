<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for Lab2LCh.c &amp; draw_rect.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for Lab2LCh.c &amp; draw_rect.c
      </h3>
<h1 align="center">
        9.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>Lab2LCh.c (12.371134%)<th>draw_rect.c (7.94702%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(128-139)<td><a href="#" name="0">(157-168)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Lab2LCh.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include "pcolour.h"
8 typedef VipsColourTransform VipsLab2LCh;
9 typedef VipsColourTransformClass VipsLab2LChClass;
10 G_DEFINE_TYPE( VipsLab2LCh, vips_Lab2LCh, VIPS_TYPE_COLOUR_TRANSFORM );
11 double
12 vips_col_ab2h( double a, double b )
13 {
14 	double h;
15 	if( a == 0 ) {
16 		if( b &lt; 0.0 )
17 			h = 270;
18 		else if( b == 0.0 )
19 			h = 0;
20 		else
21 			h = 90;
22 	}
23 	else {
24 		double t = atan( b / a );
25 		if( a &gt; 0.0 )
26 			if( b &lt; 0.0 )
27 				h = VIPS_DEG( t + VIPS_PI * 2.0 );
28 			else
29 				h = VIPS_DEG( t );
30 		else
31 			h = VIPS_DEG( t + VIPS_PI );
32 	}
33 	return( h );
34 }
35 void
36 vips_col_ab2Ch( float a, float b, float *C, float *h )
37 {
38 	*h = vips_col_ab2h( a, b ); 
39 #ifdef HAVE_HYPOT
40 	*C = hypot( a, b ); 
41 #else
42 	*C = sqrt( a * a + b * b );
43 #endif
44 }
45 static void
46 vips_Lab2LCh_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
47 {
48 	float * restrict p = (float *) in[0]; 
49 	float * restrict q = (float *) out; 
50 	int x;
51 	for( x = 0; x &lt; width; x++ ) {
52 		float L = p[0];
53 		float a = p[1];
54 		float b = p[2];
55 		float C, h;
56 		p += 3;
57 		C = sqrt( a * a + b * b );
58 		h = vips_col_ab2h( a, b );
59 		q[0] = L;
60 		q[1] = C;
61 		q[2] = h;
62 <a name="0"></a>
63 		q += 3;
64 	}
65 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
66 static void
67 vips_Lab2LCh_class_init( VipsLab2LChClass *class )
68 {
69 	VipsObjectClass *object_class = (VipsObjectClass *) class;
70 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
71 	object_class-&gt;nickname = "Lab2LCh";
72 	object_class-&gt;description = _( "transform Lab to LCh" );
73 	colour_class-&gt;process_line = vips_Lab2LCh_line;</b></font>
74 }
75 static void
76 vips_Lab2LCh_init( VipsLab2LCh *Lab2LCh )
77 {
78 	VipsColour *colour = VIPS_COLOUR( Lab2LCh );
79 	colour-&gt;interpretation = VIPS_INTERPRETATION_LCH;
80 }
81 int
82 vips_Lab2LCh( VipsImage *in, VipsImage **out, ... )
83 {
84 	va_list ap;
85 	int result;
86 	va_start( ap, out );
87 	result = vips_call_split( "Lab2LCh", ap, in, out );
88 	va_end( ap );
89 	return( result );
90 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>draw_rect.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include "drawink.h"
10 typedef struct _VipsDrawRect {
11 	VipsDrawink parent_object;
12 	int left;
13 	int top;
14 	int width;
15 	int height;
16 	gboolean fill; 
17 } VipsDrawRect;
18 typedef struct _VipsDrawRectClass {
19 	VipsDrawinkClass parent_class;
20 } VipsDrawRectClass; 
21 G_DEFINE_TYPE( VipsDrawRect, vips_draw_rect, VIPS_TYPE_DRAWINK );
22 static int
23 vips_draw_rect_build( VipsObject *object )
24 {
25 	VipsDraw *draw = VIPS_DRAW( object );
26 	VipsDrawink *drawink = VIPS_DRAWINK( object );
27 	VipsArea *ink = VIPS_AREA( drawink-&gt;ink );
28 	VipsDrawRect *draw_rect = (VipsDrawRect *) object;
29 	int left = draw_rect-&gt;left;
30 	int top = draw_rect-&gt;top;
31 	int width = draw_rect-&gt;width;
32 	int height = draw_rect-&gt;height;
33 	VipsRect image;
34 	VipsRect rect; 
35 	VipsRect clip;
36 	if( VIPS_OBJECT_CLASS( vips_draw_rect_parent_class )-&gt;build( object ) )
37 		return( -1 );
38 	if( !draw_rect-&gt;fill &amp;&amp;
39 		width &gt; 2 &amp;&amp;
40 		height &gt; 2 ) 
41 		return( vips_draw_rect( draw-&gt;image, 
42 				ink-&gt;data, ink-&gt;n, 
43 				left, top, width, 1, NULL ) ||
44 			vips_draw_rect( draw-&gt;image, 
45 				ink-&gt;data, ink-&gt;n, 
46 				left + width - 1, top, 1, height, NULL ) ||
47 			vips_draw_rect( draw-&gt;image, 
48 				ink-&gt;data, ink-&gt;n, 
49 				left, top + height - 1, width, 1, NULL ) ||
50 			vips_draw_rect( draw-&gt;image, 
51 				ink-&gt;data, ink-&gt;n, 
52 				left, top, 1, height, NULL ) );
53 	image.left = 0;
54 	image.top = 0;
55 	image.width = draw-&gt;image-&gt;Xsize;
56 	image.height = draw-&gt;image-&gt;Ysize;
57 	rect.left = left;
58 	rect.top = top;
59 	rect.width = width;
60 	rect.height = height;
61 	vips_rect_intersectrect( &amp;rect, &amp;image, &amp;clip );
62 	if( !vips_rect_isempty( &amp;clip ) ) {
63 		VipsPel *to = 
64 			VIPS_IMAGE_ADDR( draw-&gt;image, clip.left, clip.top );
65 		VipsPel *q;
66 		int x, y;
67 		q = to;
68 		for( x = 0; x &lt; clip.width; x++ ) {
69 			vips__drawink_pel( drawink, q );
70 			q += draw-&gt;psize;
71 		}
72 		q = to + draw-&gt;lsize;
73 		for( y = 1; y &lt; clip.height; y++ ) {
74 			memcpy( q, to, clip.width * draw-&gt;psize );
75 			q += draw-&gt;lsize;
76 		}
77 <a name="0"></a>	}
78 	return( 0 );
79 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
80 static void
81 vips_draw_rect_class_init( VipsDrawRectClass *class )
82 {
83 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
84 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
85 	gobject_class-&gt;set_property = vips_object_set_property;
86 	gobject_class-&gt;get_property = vips_object_get_property;
87 	vobject_class-&gt;nickname = "draw_rect";</b></font>
88 	vobject_class-&gt;description = _( "paint a rectangle on an image" );
89 	vobject_class-&gt;build = vips_draw_rect_build;
90 	VIPS_ARG_INT( class, "left", 6, 
91 		_( "Left" ), 
92 		_( "Rect to fill" ),
93 		VIPS_ARGUMENT_REQUIRED_INPUT,
94 		G_STRUCT_OFFSET( VipsDrawRect, left ),
95 		-1000000000, 1000000000, 0 );
96 	VIPS_ARG_INT( class, "top", 7, 
97 		_( "top" ), 
98 		_( "Rect to fill" ),
99 		VIPS_ARGUMENT_REQUIRED_INPUT,
100 		G_STRUCT_OFFSET( VipsDrawRect, top ),
101 		-1000000000, 1000000000, 0 );
102 	VIPS_ARG_INT( class, "width", 8, 
103 		_( "width" ), 
104 		_( "Rect to fill" ),
105 		VIPS_ARGUMENT_REQUIRED_INPUT,
106 		G_STRUCT_OFFSET( VipsDrawRect, width ),
107 		-1000000000, 1000000000, 0 );
108 	VIPS_ARG_INT( class, "height", 9, 
109 		_( "height" ), 
110 		_( "Rect to fill" ),
111 		VIPS_ARGUMENT_REQUIRED_INPUT,
112 		G_STRUCT_OFFSET( VipsDrawRect, height ),
113 		-1000000000, 1000000000, 0 );
114 	VIPS_ARG_BOOL( class, "fill", 10, 
115 		_( "Fill" ), 
116 		_( "Draw a solid object" ),
117 		VIPS_ARGUMENT_OPTIONAL_INPUT,
118 		G_STRUCT_OFFSET( VipsDrawRect, fill ),
119 		FALSE ); 
120 }
121 static void
122 vips_draw_rect_init( VipsDrawRect *draw_rect )
123 {
124 }
125 static int
126 vips_draw_rectv( VipsImage *image, 
127 	double *ink, int n, int left, int top, int width, int height, 
128 	va_list ap )
129 {
130 	VipsArea *area_ink;
131 	int result;
132 	area_ink = VIPS_AREA( vips_array_double_new( ink, n ) );
133 	result = vips_call_split( "draw_rect", ap, 
134 		image, area_ink, left, top, width, height ); 
135 	vips_area_unref( area_ink );
136 	return( result );
137 }
138 int
139 vips_draw_rect( VipsImage *image, 
140 	double *ink, int n, int left, int top, int width, int height, ... ) 
141 {
142 	va_list ap;
143 	int result;
144 	va_start( ap, height );
145 	result = vips_draw_rectv( image, 
146 		ink, n, left, top, width, height, ap ); 
147 	va_end( ap );
148 	return( result );
149 }
150 int
151 vips_draw_rect1( VipsImage *image, 
152 	double ink, int left, int top, int width, int height, ... ) 
153 {
154 	double array_ink[1];
155 	va_list ap;
156 	int result;
157 	array_ink[0] = ink; 
158 	va_start( ap, height );
159 	result = vips_draw_rectv( image, 
160 		array_ink, 1, left, top, width, height, ap );
161 	va_end( ap );
162 	return( result );
163 }
164 int
165 vips_draw_point( VipsImage *image, double *ink, int n, int x, int y, ... ) 
166 {
167 	va_list ap;
168 	int result;
169 	va_start( ap, y );
170 	result = vips_draw_rectv( image, ink, n, x, y, 1, 1, ap ); 
171 	va_end( ap );
172 	return( result );
173 }
174 int
175 vips_draw_point1( VipsImage *image, double ink, int x, int y, ... ) 
176 {
177 	double array_ink[1];
178 	va_list ap;
179 	int result;
180 	array_ink[0] = ink; 
181 	va_start( ap, y );
182 	result = vips_draw_rectv( image, array_ink, 1, x, y, 1, 1, ap );
183 	va_end( ap );
184 	return( result );
185 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
