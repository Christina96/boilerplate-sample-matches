<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mask_ideal.c &amp; flatten.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mask_ideal.c &amp; flatten.c
      </h3>
<h1 align="center">
        10.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mask_ideal.c (34.042553%)<th>flatten.c (6.5306125%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(66-81)<td><a href="#" name="0">(395-411)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mask_ideal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include "pcreate.h"
10 #include "point.h"
11 #include "pmask.h"
12 G_DEFINE_TYPE( VipsMaskIdeal, vips_mask_ideal, VIPS_TYPE_MASK );
13 static double
14 vips_mask_ideal_point( VipsMask *mask, double dx, double dy ) 
15 {
16 	VipsMaskIdeal *ideal = (VipsMaskIdeal *) mask;
17 	double fc = ideal-&gt;frequency_cutoff;
18 	double dist2 = dx * dx + dy * dy;
19 <a name="0"></a>	double fc2 = fc * fc;
20 	return( dist2 &lt;= fc2 ? 0.0 : 1.0 ); 
21 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
22 static void
23 vips_mask_ideal_class_init( VipsMaskIdealClass *class )
24 {
25 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
26 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
27 	VipsMaskClass *mask_class = VIPS_MASK_CLASS( class );
28 	gobject_class-&gt;set_property = vips_object_set_property;
29 	gobject_class-&gt;get_property = vips_object_get_property;
30 	vobject_class-&gt;nickname = "mask_ideal";
31 	vobject_class-&gt;description = _( "make an ideal filter" );
32 	mask_class-&gt;point = vips_mask_ideal_point;</b></font>
33 	VIPS_ARG_DOUBLE( class, "frequency_cutoff", 6, 
34 		_( "Frequency cutoff" ), 
35 		_( "Frequency cutoff" ),
36 		VIPS_ARGUMENT_REQUIRED_INPUT,
37 		G_STRUCT_OFFSET( VipsMaskIdeal, frequency_cutoff ),
38 		0.0, 1000000.0, 0.5 );
39 }
40 static void
41 vips_mask_ideal_init( VipsMaskIdeal *ideal )
42 {
43 	ideal-&gt;frequency_cutoff = 0.5;
44 }
45 int
46 vips_mask_ideal( VipsImage **out, int width, int height, 
47 	double frequency_cutoff, ... )
48 {
49 	va_list ap;
50 	int result;
51 	va_start( ap, frequency_cutoff );
52 	result = vips_call_split( "mask_ideal", ap, out, width, height, 
53 		frequency_cutoff );
54 	va_end( ap );
55 	return( result );
56 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>flatten.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;vips/debug.h&gt;
11 #include "pconversion.h"
12 typedef struct _VipsFlatten {
13 	VipsConversion parent_instance;
14 	VipsImage *in;
15 	VipsArrayDouble *background;
16 	VipsPel *ink;
17 	double max_alpha;
18 } VipsFlatten;
19 typedef VipsConversionClass VipsFlattenClass;
20 G_DEFINE_TYPE( VipsFlatten, vips_flatten, VIPS_TYPE_CONVERSION );
21 #define VIPS_FLATTEN_BLACK_INT( TYPE ) { \
22 	TYPE * restrict p = (TYPE *) in; \
23 	TYPE * restrict q = (TYPE *) out; \
24 	\
25 	for( x = 0; x &lt; width; x++ ) { \
26 		TYPE alpha = p[bands - 1]; \
27 		int b; \
28 		\
29 		for( b = 0; b &lt; bands - 1; b++ ) \
30 			q[b] = (p[b] * alpha) / max_alpha; \
31 		\
32 		p += bands; \
33 		q += bands - 1; \
34 	} \
35 }
36 #define VIPS_FLATTEN_BLACK_FLOAT( TYPE ) { \
37 	TYPE * restrict p = (TYPE *) in; \
38 	TYPE * restrict q = (TYPE *) out; \
39 	\
40 	for( x = 0; x &lt; width; x++ ) { \
41 		TYPE alpha = p[bands - 1]; \
42 		int b; \
43 		\
44 		for( b = 0; b &lt; bands - 1; b++ ) \
45 			q[b] = ((double) p[b] * alpha) / max_alpha; \
46 		\
47 		p += bands; \
48 		q += bands - 1; \
49 	} \
50 }
51 #define VIPS_FLATTEN_INT( TYPE ) { \
52 	TYPE * restrict p = (TYPE *) in; \
53 	TYPE * restrict q = (TYPE *) out; \
54 	\
55 	for( x = 0; x &lt; width; x++ ) { \
56 		TYPE alpha = p[bands - 1]; \
57 		TYPE nalpha = max_alpha - alpha; \
58 		TYPE * restrict bg = (TYPE *) flatten-&gt;ink; \
59 		int b; \
60 		\
61 		for( b = 0; b &lt; bands - 1; b++ ) \
62 			q[b] = (p[b] * alpha + bg[b] * nalpha) / max_alpha; \
63 		\
64 		p += bands; \
65 		q += bands - 1; \
66 	} \
67 }
68 #define VIPS_FLATTEN_FLOAT( TYPE ) { \
69 	TYPE * restrict p = (TYPE *) in; \
70 	TYPE * restrict q = (TYPE *) out; \
71 	\
72 	for( x = 0; x &lt; width; x++ ) { \
73 		TYPE alpha = p[bands - 1]; \
74 		TYPE nalpha = max_alpha - alpha; \
75 		TYPE * restrict bg = (TYPE *) flatten-&gt;ink; \
76 		int b; \
77 		\
78 		for( b = 0; b &lt; bands - 1; b++ ) \
79 			q[b] = ((double) p[b] * alpha + \
80 				(double) bg[b] * nalpha) / max_alpha; \
81 		\
82 		p += bands; \
83 		q += bands - 1; \
84 	} \
85 }
86 static int
87 vips_flatten_black_gen( VipsRegion *or, void *vseq, void *a, void *b,
88 	gboolean *stop )
89 {
90 	VipsRegion *ir = (VipsRegion *) vseq;
91 	VipsFlatten *flatten = (VipsFlatten *) b;
92 	VipsRect *r = &amp;or-&gt;valid;
93 	int width = r-&gt;width;
94 	int bands = ir-&gt;im-&gt;Bands; 
95 	double max_alpha = flatten-&gt;max_alpha;
96 	int x, y;
97 	if( vips_region_prepare( ir, r ) )
98 		return( -1 );
99 	for( y = 0; y &lt; r-&gt;height; y++ ) {
100 		VipsPel *in = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); 
101 		VipsPel *out = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); 
102 		switch( ir-&gt;im-&gt;BandFmt ) { 
103 		case VIPS_FORMAT_UCHAR: 
104 			VIPS_FLATTEN_BLACK_INT( unsigned char ); 
105 			break; 
106 		case VIPS_FORMAT_CHAR: 
107 			VIPS_FLATTEN_BLACK_INT( signed char ); 
108 			break; 
109 		case VIPS_FORMAT_USHORT: 
110 			VIPS_FLATTEN_BLACK_FLOAT( unsigned short ); 
111 			break; 
112 		case VIPS_FORMAT_SHORT: 
113 			VIPS_FLATTEN_BLACK_FLOAT( signed short ); 
114 			break; 
115 		case VIPS_FORMAT_UINT: 
116 			VIPS_FLATTEN_BLACK_FLOAT( unsigned int ); 
117 			break; 
118 		case VIPS_FORMAT_INT: 
119 			VIPS_FLATTEN_BLACK_FLOAT( signed int ); 
120 			break; 
121 		case VIPS_FORMAT_FLOAT: 
122 			VIPS_FLATTEN_BLACK_FLOAT( float ); 
123 			break; 
124 		case VIPS_FORMAT_DOUBLE: 
125 			VIPS_FLATTEN_BLACK_FLOAT( double ); 
126 			break; 
127 		case VIPS_FORMAT_COMPLEX: 
128 		case VIPS_FORMAT_DPCOMPLEX: 
129 		default: 
130 			g_assert_not_reached(); 
131 		} 
132 	}
133 	return( 0 );
134 }
135 static int
136 vips_flatten_gen( VipsRegion *or, void *vseq, void *a, void *b,
137 	gboolean *stop )
138 {
139 	VipsRegion *ir = (VipsRegion *) vseq;
140 	VipsFlatten *flatten = (VipsFlatten *) b;
141 	VipsRect *r = &amp;or-&gt;valid;
142 	int width = r-&gt;width;
143 	int bands = ir-&gt;im-&gt;Bands; 
144 	double max_alpha = flatten-&gt;max_alpha;
145 	int x, y;
146 	if( vips_region_prepare( ir, r ) )
147 		return( -1 );
148 	for( y = 0; y &lt; r-&gt;height; y++ ) {
149 		VipsPel *in = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); 
150 		VipsPel *out = VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); 
151 		switch( ir-&gt;im-&gt;BandFmt ) { 
152 		case VIPS_FORMAT_UCHAR: 
153 			VIPS_FLATTEN_INT( unsigned char ); 
154 			break; 
155 		case VIPS_FORMAT_CHAR: 
156 			VIPS_FLATTEN_INT( signed char ); 
157 			break; 
158 		case VIPS_FORMAT_USHORT: 
159 			VIPS_FLATTEN_FLOAT( unsigned short ); 
160 			break; 
161 		case VIPS_FORMAT_SHORT: 
162 			VIPS_FLATTEN_FLOAT( signed short ); 
163 			break; 
164 		case VIPS_FORMAT_UINT: 
165 			VIPS_FLATTEN_FLOAT( unsigned int ); 
166 			break; 
167 		case VIPS_FORMAT_INT: 
168 			VIPS_FLATTEN_FLOAT( signed int ); 
169 			break; 
170 		case VIPS_FORMAT_FLOAT: 
171 			VIPS_FLATTEN_FLOAT( float ); 
172 			break; 
173 		case VIPS_FORMAT_DOUBLE: 
174 			VIPS_FLATTEN_FLOAT( double ); 
175 			break; 
176 		case VIPS_FORMAT_COMPLEX: 
177 		case VIPS_FORMAT_DPCOMPLEX: 
178 		default: 
179 			g_assert_not_reached(); 
180 		} 
181 	}
182 	return( 0 );
183 }
184 static int
185 vips_flatten_build( VipsObject *object )
186 {
187 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
188 	VipsConversion *conversion = VIPS_CONVERSION( object );
189 	VipsFlatten *flatten = (VipsFlatten *) object;
190 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
191 	VipsImage *in;
192 	int i;
193 	gboolean black;
194 	VipsBandFormat original_format;
195 	if( VIPS_OBJECT_CLASS( vips_flatten_parent_class )-&gt;build( object ) )
196 		return( -1 );
197 	in = flatten-&gt;in; 
198 	if( vips_image_decode( in, &amp;t[0] ) )
199 		return( -1 );
200 	in = t[0]; 
201 	if( in-&gt;Bands == 1 ) 
202 		return( vips_image_write( in, conversion-&gt;out ) );
203 	if( vips_check_noncomplex( class-&gt;nickname, in ) )
204 		return( -1 );
205 	if( !vips_object_argument_isset( object, "max_alpha" ) ) 
206 		if( in-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
207 			in-&gt;Type == VIPS_INTERPRETATION_RGB16 )
208 			flatten-&gt;max_alpha = 65535;
209 	original_format = VIPS_FORMAT_NOTSET;
210 	if( vips_band_format_isint( in-&gt;BandFmt ) &amp;&amp;
211 		flatten-&gt;max_alpha &lt; 
212 			vips_image_get_format_max( in-&gt;BandFmt ) ) {
213 		original_format = in-&gt;BandFmt;
214 		if( vips_cast( in, &amp;t[1], VIPS_FORMAT_DOUBLE, NULL ) )
215 			return( -1 );
216 		in = t[1];
217 	}
218 	t[2] = vips_image_new();
219 	if( vips_image_pipelinev( t[2], 
220 		VIPS_DEMAND_STYLE_THINSTRIP, in, NULL ) )
221 		return( -1 );
222 	t[2]-&gt;Bands -= 1;
223 	black = TRUE;
224 	for( i = 0; i &lt; VIPS_AREA( flatten-&gt;background )-&gt;n; i++ ) {
225 		const double *background = 
226 			vips_array_double_get( flatten-&gt;background, NULL );
227 		if( background[i] != 0.0 ) {
228 			black = FALSE;
229 			break;
230 		}
231 	}
232 	if( black ) {
233 		if( vips_image_generate( t[2],
234 			vips_start_one, vips_flatten_black_gen, vips_stop_one, 
235 			in, flatten ) )
236 			return( -1 );
237 		in = t[2];
238 	}
239 	else {
240 		if( !(flatten-&gt;ink = vips__vector_to_ink( class-&gt;nickname, t[2],
241 			VIPS_AREA( flatten-&gt;background )-&gt;data, NULL, 
242 			VIPS_AREA( flatten-&gt;background )-&gt;n )) )
243 			return( -1 );
244 		if( vips_image_generate( t[2],
245 			vips_start_one, vips_flatten_gen, vips_stop_one, 
246 			in, flatten ) )
247 			return( -1 );
248 		in = t[2];
249 	}
250 	if( original_format != VIPS_FORMAT_NOTSET ) {
251 		if( vips_cast( in, &amp;t[3], original_format, NULL ) )
252 			return( -1 );
253 		in = t[3];
254 	}
255 	if( vips_image_write( in, conversion-&gt;out ) )
256 <a name="0"></a>		return( -1 );
257 	return( 0 );
258 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
259 static void
260 vips_flatten_class_init( VipsFlattenClass *class )
261 {
262 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
263 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
264 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
265 	VIPS_DEBUG_MSG( "vips_flatten_class_init\n" );
266 	gobject_class-&gt;set_property = vips_object_set_property;
267 	gobject_class-&gt;get_property = vips_object_get_property;
268 	vobject_class-&gt;nickname = "flatten";
269 	vobject_class-&gt;description = _( "flatten alpha out of an image" );
270 	vobject_class-&gt;build = vips_flatten_build;</b></font>
271 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;
272 	VIPS_ARG_IMAGE( class, "in", 1, 
273 		_( "Input" ), 
274 		_( "Input image" ),
275 		VIPS_ARGUMENT_REQUIRED_INPUT,
276 		G_STRUCT_OFFSET( VipsFlatten, in ) );
277 	VIPS_ARG_BOXED( class, "background", 2, 
278 		_( "Background" ), 
279 		_( "Background value" ),
280 		VIPS_ARGUMENT_OPTIONAL_INPUT,
281 		G_STRUCT_OFFSET( VipsFlatten, background ),
282 		VIPS_TYPE_ARRAY_DOUBLE );
283 	VIPS_ARG_DOUBLE( class, "max_alpha", 115, 
284 		_( "Maximum alpha" ), 
285 		_( "Maximum value of alpha channel" ),
286 		VIPS_ARGUMENT_OPTIONAL_INPUT,
287 		G_STRUCT_OFFSET( VipsFlatten, max_alpha ),
288 		0, 100000000, 255 );
289 }
290 static void
291 vips_flatten_init( VipsFlatten *flatten )
292 {
293 	flatten-&gt;background = vips_array_double_newv( 1, 0.0 );
294 	flatten-&gt;max_alpha= 255.0;
295 }
296 int
297 vips_flatten( VipsImage *in, VipsImage **out, ... )
298 {
299 	va_list ap;
300 	int result;
301 	va_start( ap, out );
302 	result = vips_call_split( "flatten", ap, in, out );
303 	va_end( ap );
304 	return( result );
305 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
