
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include &lt;config.h&gt;
3  #endif
4  #include &lt;pcap-types.h&gt;
5  #ifndef _WIN32
6  #include &lt;sys/param.h&gt;
7  #ifndef MSDOS
8  #include &lt;sys/file.h&gt;
9  #endif
10  #include &lt;sys/ioctl.h&gt;
11  #include &lt;sys/socket.h&gt;
12  #ifdef HAVE_SYS_SOCKIO_H
13  #include &lt;sys/sockio.h&gt;
14  #endif
15  struct mbuf;		&amp;bsol;* Squelch compiler warnings on some platforms for */
16  struct rtentry;		&amp;bsol;* declarations in &lt;net/if.h&gt; */
17  #include &lt;net/if.h&gt;
18  #include &lt;netinet/in.h&gt;
19  #endif &amp;bsol;* _WIN32 */
20  #include &lt;stdio.h&gt;
21  #include &lt;stdlib.h&gt;
22  #include &lt;string.h&gt;
23  #if !defined(_MSC_VER) &amp;&amp; !defined(__BORLANDC__) &amp;&amp; !defined(__MINGW32__)
24  #include &lt;unistd.h&gt;
25  #endif
26  #include &lt;fcntl.h&gt;
27  #include &lt;errno.h&gt;
28  #include &lt;limits.h&gt;
29  #include &quot;diag-control.h&quot;
30  #include &quot;thread-local.h&quot;
31  #ifdef HAVE_OS_PROTO_H
32  #include &quot;os-proto.h&quot;
33  #endif
34  #ifdef MSDOS
35  #include &quot;pcap-dos.h&quot;
36  #endif
37  #include &quot;pcap-int.h&quot;
38  #include &quot;optimize.h&quot;
39  #ifdef HAVE_DAG_API
40  #include &quot;pcap-dag.h&quot;
41  #endif &amp;bsol;* HAVE_DAG_API */
42  #ifdef HAVE_SEPTEL_API
43  #include &quot;pcap-septel.h&quot;
44  #endif &amp;bsol;* HAVE_SEPTEL_API */
45  #ifdef HAVE_SNF_API
46  #include &quot;pcap-snf.h&quot;
47  #endif &amp;bsol;* HAVE_SNF_API */
48  #ifdef HAVE_TC_API
49  #include &quot;pcap-tc.h&quot;
50  #endif &amp;bsol;* HAVE_TC_API */
51  #ifdef PCAP_SUPPORT_LINUX_USBMON
52  #include &quot;pcap-usb-linux.h&quot;
53  #endif
54  #ifdef PCAP_SUPPORT_BT
55  #include &quot;pcap-bt-linux.h&quot;
56  #endif
57  #ifdef PCAP_SUPPORT_BT_MONITOR
58  #include &quot;pcap-bt-monitor-linux.h&quot;
59  #endif
60  #ifdef PCAP_SUPPORT_NETFILTER
61  #include &quot;pcap-netfilter-linux.h&quot;
62  #endif
63  #ifdef PCAP_SUPPORT_NETMAP
64  #include &quot;pcap-netmap.h&quot;
65  #endif
66  #ifdef PCAP_SUPPORT_DBUS
67  #include &quot;pcap-dbus.h&quot;
68  #endif
69  #ifdef PCAP_SUPPORT_RDMASNIFF
70  #include &quot;pcap-rdmasniff.h&quot;
71  #endif
72  #ifdef PCAP_SUPPORT_DPDK
73  #include &quot;pcap-dpdk.h&quot;
74  #endif
75  #ifdef HAVE_AIRPCAP_API
76  #include &quot;pcap-airpcap.h&quot;
77  #endif
78  #ifdef _WIN32
79  static void
80  internal_wsockfini(void)
81  {
82  	WSACleanup();
83  }
84  static int
85  internal_wsockinit(char *errbuf)
86  {
87  	WORD wVersionRequested;
88  	WSADATA wsaData;
89  	static int err = -1;
90  	static int done = 0;
91  	int status;
92  	if (done)
93  		return (err);
94  	wVersionRequested = MAKEWORD(2, 2);
95  	status = WSAStartup(wVersionRequested, &amp;wsaData);
96  	done = 1;
97  	if (status != 0) {
98  		if (errbuf != NULL) {
99  			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
100  			    status, &quot;WSAStartup() failed&quot;);
101  		}
102  		return (err);
103  	}
104  	atexit(internal_wsockfini);
105  	err = 0;
106  	return (err);
107  }
108  int
109  wsockinit(void)
110  {
111  	return (internal_wsockinit(NULL));
112  }
113  int
114  pcap_wsockinit(void)
115  {
116  	return (internal_wsockinit(NULL));
117  }
118  #endif &amp;bsol;* _WIN32 */
119  int pcap_new_api;		&amp;bsol;* pcap_lookupdev() always fails */
120  int pcap_utf_8_mode;		&amp;bsol;* Strings should be in UTF-8. */
121  int pcap_mmap_32bit;		&amp;bsol;* Map packet buffers with 32-bit addresses. */
122  int
123  pcap_init(unsigned int opts, char *errbuf)
124  {
125  	static int initialized;
126  	switch (opts) {
127  	case PCAP_CHAR_ENC_LOCAL:
128  		if (initialized) {
129  			if (pcap_utf_8_mode) {
130  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
131  				    &quot;Multiple pcap_init calls with different character encodings&quot;);
132  				return (PCAP_ERROR);
133  			}
134  		}
135  		break;
136  	case PCAP_CHAR_ENC_UTF_8:
137  		if (initialized) {
138  			if (!pcap_utf_8_mode) {
139  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
140  				    &quot;Multiple pcap_init calls with different character encodings&quot;);
141  				return (PCAP_ERROR);
142  			}
143  		}
144  		pcap_utf_8_mode = 1;
145  		break;
146  	case PCAP_MMAP_32BIT:
147  		pcap_mmap_32bit = 1;
148  		break;
149  	default:
150  		snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;Unknown options specified&quot;);
151  		return (PCAP_ERROR);
152  	}
153  	pcap_fmt_set_encoding(opts);
154  	if (initialized) {
155  		return (0);
156  	}
157  #ifdef _WIN32
158  	if (internal_wsockinit(errbuf) == -1) {
159  		return (PCAP_ERROR);
160  	}
161  #endif
162  	initialized = 1;
163  	pcap_new_api = 1;
164  	return (0);
165  }
166  PCAP_API char pcap_version[];
167  PCAP_API_DEF char pcap_version[] = PACKAGE_VERSION;
168  static void
169  pcap_set_not_initialized_message(pcap_t *pcap)
170  {
171  	if (pcap-&gt;activated) {
172  		(void)snprintf(pcap-&gt;errbuf, sizeof(pcap-&gt;errbuf),
173  		    &quot;This operation isn&#x27;t properly handled by that device&quot;);
174  		return;
175  	}
176  	(void)snprintf(pcap-&gt;errbuf, sizeof(pcap-&gt;errbuf),
177  	    &quot;This handle hasn&#x27;t been activated yet&quot;);
178  }
179  static int
180  pcap_read_not_initialized(pcap_t *pcap, int cnt _U_, pcap_handler callback _U_,
181      u_char *user _U_)
182  {
183  	pcap_set_not_initialized_message(pcap);
184  	return (PCAP_ERROR_NOT_ACTIVATED);
185  }
186  static int
187  pcap_inject_not_initialized(pcap_t *pcap, const void * buf _U_, int size _U_)
188  {
189  	pcap_set_not_initialized_message(pcap);
190  	return (PCAP_ERROR_NOT_ACTIVATED);
191  }
192  static int
193  pcap_setfilter_not_initialized(pcap_t *pcap, struct bpf_program *fp _U_)
194  {
195  	pcap_set_not_initialized_message(pcap);
196  	return (PCAP_ERROR_NOT_ACTIVATED);
197  }
198  static int
199  pcap_setdirection_not_initialized(pcap_t *pcap, pcap_direction_t d _U_)
200  {
201  	pcap_set_not_initialized_message(pcap);
202  	return (PCAP_ERROR_NOT_ACTIVATED);
203  }
204  static int
205  pcap_set_datalink_not_initialized(pcap_t *pcap, int dlt _U_)
206  {
207  	pcap_set_not_initialized_message(pcap);
208  	return (PCAP_ERROR_NOT_ACTIVATED);
209  }
210  static int
211  pcap_getnonblock_not_initialized(pcap_t *pcap)
212  {
213  	pcap_set_not_initialized_message(pcap);
214  	return (PCAP_ERROR_NOT_ACTIVATED);
215  }
216  static int
217  pcap_stats_not_initialized(pcap_t *pcap, struct pcap_stat *ps _U_)
218  {
219  	pcap_set_not_initialized_message(pcap);
220  	return (PCAP_ERROR_NOT_ACTIVATED);
221  }
222  #ifdef _WIN32
223  static struct pcap_stat *
224  pcap_stats_ex_not_initialized(pcap_t *pcap, int *pcap_stat_size _U_)
225  {
226  	pcap_set_not_initialized_message(pcap);
227  	return (NULL);
228  }
229  static int
230  pcap_setbuff_not_initialized(pcap_t *pcap, int dim _U_)
231  {
232  	pcap_set_not_initialized_message(pcap);
233  	return (PCAP_ERROR_NOT_ACTIVATED);
234  }
235  static int
236  pcap_setmode_not_initialized(pcap_t *pcap, int mode _U_)
237  {
238  	pcap_set_not_initialized_message(pcap);
239  	return (PCAP_ERROR_NOT_ACTIVATED);
240  }
241  static int
242  pcap_setmintocopy_not_initialized(pcap_t *pcap, int size _U_)
243  {
244  	pcap_set_not_initialized_message(pcap);
245  	return (PCAP_ERROR_NOT_ACTIVATED);
246  }
247  static HANDLE
248  pcap_getevent_not_initialized(pcap_t *pcap)
249  {
250  	pcap_set_not_initialized_message(pcap);
251  	return (INVALID_HANDLE_VALUE);
252  }
253  static int
254  pcap_oid_get_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,
255      void *data _U_, size_t *lenp _U_)
256  {
257  	pcap_set_not_initialized_message(pcap);
258  	return (PCAP_ERROR_NOT_ACTIVATED);
259  }
260  static int
261  pcap_oid_set_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,
262      const void *data _U_, size_t *lenp _U_)
263  {
264  	pcap_set_not_initialized_message(pcap);
265  	return (PCAP_ERROR_NOT_ACTIVATED);
266  }
267  static u_int
268  pcap_sendqueue_transmit_not_initialized(pcap_t *pcap, pcap_send_queue* queue _U_,
269      int sync _U_)
270  {
271  	pcap_set_not_initialized_message(pcap);
272  	return (0);
273  }
274  static int
275  pcap_setuserbuffer_not_initialized(pcap_t *pcap, int size _U_)
276  {
277  	pcap_set_not_initialized_message(pcap);
278  	return (PCAP_ERROR_NOT_ACTIVATED);
279  }
280  static int
281  pcap_live_dump_not_initialized(pcap_t *pcap, char *filename _U_, int maxsize _U_,
282      int maxpacks _U_)
283  {
284  	pcap_set_not_initialized_message(pcap);
285  	return (PCAP_ERROR_NOT_ACTIVATED);
286  }
287  static int
288  pcap_live_dump_ended_not_initialized(pcap_t *pcap, int sync _U_)
289  {
290  	pcap_set_not_initialized_message(pcap);
291  	return (PCAP_ERROR_NOT_ACTIVATED);
292  }
293  static PAirpcapHandle
294  pcap_get_airpcap_handle_not_initialized(pcap_t *pcap)
295  {
296  	pcap_set_not_initialized_message(pcap);
297  	return (NULL);
298  }
299  #endif
300  int
301  pcap_can_set_rfmon(pcap_t *p)
302  {
303  	return (p-&gt;can_set_rfmon_op(p));
304  }
305  static int
306  pcap_cant_set_rfmon(pcap_t *p _U_)
307  {
308  	return (0);
309  }
310  int
311  pcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp)
312  {
313  	if (p-&gt;tstamp_type_count == 0) {
314  		*tstamp_typesp = (int*)malloc(sizeof(**tstamp_typesp));
315  		if (*tstamp_typesp == NULL) {
316  			pcap_fmt_errmsg_for_errno(p-&gt;errbuf, sizeof(p-&gt;errbuf),
317  			    errno, &quot;malloc&quot;);
318  			return (PCAP_ERROR);
319  		}
320  		**tstamp_typesp = PCAP_TSTAMP_HOST;
321  		return (1);
322  	} else {
323  		*tstamp_typesp = (int*)calloc(sizeof(**tstamp_typesp),
324  		    p-&gt;tstamp_type_count);
325  		if (*tstamp_typesp == NULL) {
326  			pcap_fmt_errmsg_for_errno(p-&gt;errbuf, sizeof(p-&gt;errbuf),
327  			    errno, &quot;malloc&quot;);
328  			return (PCAP_ERROR);
329  		}
330  		(void)memcpy(*tstamp_typesp, p-&gt;tstamp_type_list,
331  		    sizeof(**tstamp_typesp) * p-&gt;tstamp_type_count);
332  		return (p-&gt;tstamp_type_count);
333  	}
334  }
335  void
336  pcap_free_tstamp_types(int *tstamp_type_list)
337  {
338  	free(tstamp_type_list);
339  }
340  void
341  pcap_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)
342  {
343  	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
344  	*sp-&gt;hdr = *h;
345  	*sp-&gt;pkt = pkt;
346  }
347  const u_char *
348  pcap_next(pcap_t *p, struct pcap_pkthdr *h)
349  {
350  	struct oneshot_userdata s;
351  	const u_char *pkt;
352  	s.hdr = h;
353  	s.pkt = &amp;pkt;
354  	s.pd = p;
355  	if (pcap_dispatch(p, 1, p-&gt;oneshot_callback, (u_char *)&amp;s) &lt;= 0)
356  		return (0);
357  	return (pkt);
358  }
359  int
360  pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,
361      const u_char **pkt_data)
362  {
363  	struct oneshot_userdata s;
364  	s.hdr = &amp;p-&gt;pcap_header;
365  	s.pkt = pkt_data;
366  	s.pd = p;
367  	*pkt_header= &amp;p-&gt;pcap_header;
368  	if (p-&gt;rfile != NULL) {
369  		int status;
370  		status = pcap_offline_read(p, 1, p-&gt;oneshot_callback,
371  		    (u_char *)&amp;s);
372  		if (status == 0)
373  			return (-2);
374  		else
375  			return (status);
376  	}
377  	return (p-&gt;read_op(p, 1, p-&gt;oneshot_callback, (u_char *)&amp;s));
378  }
379  struct pcap_if_list {
380  	pcap_if_t *beginning;
381  };
382  static struct capture_source_type {
383  	int (*findalldevs_op)(pcap_if_list_t *, char *);
384  	pcap_t *(*create_op)(const char *, char *, int *);
385  } capture_source_types[] = {
386  #ifdef HAVE_DAG_API
387  	{ dag_findalldevs, dag_create },
388  #endif
389  #ifdef HAVE_SEPTEL_API
390  	{ septel_findalldevs, septel_create },
391  #endif
392  #ifdef HAVE_SNF_API
393  	{ snf_findalldevs, snf_create },
394  #endif
395  #ifdef HAVE_TC_API
396  	{ TcFindAllDevs, TcCreate },
397  #endif
398  #ifdef PCAP_SUPPORT_BT
399  	{ bt_findalldevs, bt_create },
400  #endif
401  #ifdef PCAP_SUPPORT_BT_MONITOR
402  	{ bt_monitor_findalldevs, bt_monitor_create },
403  #endif
404  #ifdef PCAP_SUPPORT_LINUX_USBMON
405  	{ usb_findalldevs, usb_create },
406  #endif
407  #ifdef PCAP_SUPPORT_NETFILTER
408  	{ netfilter_findalldevs, netfilter_create },
409  #endif
410  #ifdef PCAP_SUPPORT_NETMAP
411  	{ pcap_netmap_findalldevs, pcap_netmap_create },
412  #endif
413  #ifdef PCAP_SUPPORT_DBUS
414  	{ dbus_findalldevs, dbus_create },
415  #endif
416  #ifdef PCAP_SUPPORT_RDMASNIFF
417  	{ rdmasniff_findalldevs, rdmasniff_create },
418  #endif
419  #ifdef PCAP_SUPPORT_DPDK
420  	{ pcap_dpdk_findalldevs, pcap_dpdk_create },
421  #endif
422  #ifdef HAVE_AIRPCAP_API
423  	{ airpcap_findalldevs, airpcap_create },
424  #endif
425  	{ NULL, NULL }
426  };
427  int
428  pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
429  {
430  	size_t i;
431  	pcap_if_list_t devlist;
432  	devlist.beginning = NULL;
433  	if (pcap_platform_finddevs(&amp;devlist, errbuf) == -1) {
434  		if (devlist.beginning != NULL)
435  			pcap_freealldevs(devlist.beginning);
436  		*alldevsp = NULL;
437  		return (-1);
438  	}
439  	for (i = 0; capture_source_types[i].findalldevs_op != NULL; i++) {
440  		if (capture_source_types[i].findalldevs_op(&amp;devlist, errbuf) == -1) {
441  			if (devlist.beginning != NULL)
442  				pcap_freealldevs(devlist.beginning);
443  			*alldevsp = NULL;
444  			return (-1);
445  		}
446  	}
447  	*alldevsp = devlist.beginning;
448  	return (0);
449  }
450  static struct sockaddr *
451  dup_sockaddr(struct sockaddr *sa, size_t sa_length)
452  {
453  	struct sockaddr *newsa;
454  	if ((newsa = malloc(sa_length)) == NULL)
455  		return (NULL);
456  	return (memcpy(newsa, sa, sa_length));
457  }
458  static u_int
459  get_figure_of_merit(pcap_if_t *dev)
460  {
461  	u_int n;
462  	n = 0;
463  	if (!(dev-&gt;flags &amp; PCAP_IF_RUNNING))
464  		n |= 0x80000000;
465  	if (!(dev-&gt;flags &amp; PCAP_IF_UP))
466  		n |= 0x40000000;
467  	if (!(dev-&gt;flags &amp; PCAP_IF_WIRELESS) &amp;&amp;
468  	    (dev-&gt;flags &amp; PCAP_IF_CONNECTION_STATUS) == PCAP_IF_CONNECTION_STATUS_DISCONNECTED)
469  		n |= 0x20000000;
470  	if (dev-&gt;flags &amp; PCAP_IF_LOOPBACK)
471  		n |= 0x10000000;
472  	if (strcmp(dev-&gt;name, &quot;any&quot;) == 0)
473  		n |= 0x08000000;
474  	return (n);
475  }
476  #ifndef _WIN32
477  static char *
478  #ifdef SIOCGIFDESCR
479  get_if_description(const char *name)
480  {
481  	char *description = NULL;
482  	int s;
483  	struct ifreq ifrdesc;
484  #ifndef IFDESCRSIZE
485  	size_t descrlen = 64;
486  #else
487  	size_t descrlen = IFDESCRSIZE;
488  #endif &amp;bsol;* IFDESCRSIZE */
489  	memset(&amp;ifrdesc, 0, sizeof ifrdesc);
490  	pcap_strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);
491  	s = socket(AF_INET, SOCK_DGRAM, 0);
492  	if (s &gt;= 0) {
493  #ifdef __FreeBSD__
494  		for (;;) {
495  			free(description);
496  			if ((description = malloc(descrlen)) != NULL) {
497  				ifrdesc.ifr_buffer.buffer = description;
498  				ifrdesc.ifr_buffer.length = descrlen;
499  				if (ioctl(s, SIOCGIFDESCR, &amp;ifrdesc) == 0) {
500  					if (ifrdesc.ifr_buffer.buffer ==
501  					    description)
502  						break;
503  					else
504  						descrlen = ifrdesc.ifr_buffer.length;
505  				} else {
506  					free(description);
507  					description = NULL;
508  					break;
509  				}
510  			} else
511  				break;
512  		}
513  #else &amp;bsol;* __FreeBSD__ */
514  		if ((description = malloc(descrlen)) != NULL) {
515  			ifrdesc.ifr_data = (caddr_t)description;
516  			if (ioctl(s, SIOCGIFDESCR, &amp;ifrdesc) != 0) {
517  				free(description);
518  				description = NULL;
519  			}
520  		}
521  #endif &amp;bsol;* __FreeBSD__ */
522  		close(s);
523  		if (description != NULL &amp;&amp; description[0] == &#x27;\0&#x27;) {
524  			free(description);
525  			description = NULL;
526  		}
527  	}
528  #ifdef __FreeBSD__
529  	if (description == NULL) {
530  		if (strncmp(name, &quot;usbus&quot;, 5) == 0) {
531  			long busnum;
532  			char *p;
533  			errno = 0;
534  			busnum = strtol(name + 5, &amp;p, 10);
535  			if (errno == 0 &amp;&amp; p != name + 5 &amp;&amp; *p == &#x27;\0&#x27; &amp;&amp;
536  			    busnum &gt;= 0 &amp;&amp; busnum &lt;= INT_MAX) {
537  				if (pcap_asprintf(&amp;description,
538  				    &quot;USB bus number %ld&quot;, busnum) == -1) {
539  					description = NULL;
540  				}
541  			}
542  		}
543  	}
544  #endif
545  	return (description);
546  #else &amp;bsol;* SIOCGIFDESCR */
547  get_if_description(const char *name _U_)
548  {
549  	return (NULL);
550  #endif &amp;bsol;* SIOCGIFDESCR */
551  }
552  pcap_if_t *
553  pcap_find_or_add_if(pcap_if_list_t *devlistp, const char *name,
554      bpf_u_int32 if_flags, get_if_flags_func get_flags_func, char *errbuf)
555  {
556  	bpf_u_int32 pcap_flags;
557  	pcap_flags = 0;
558  #ifdef IFF_LOOPBACK
559  	if (if_flags &amp; IFF_LOOPBACK)
560  		pcap_flags |= PCAP_IF_LOOPBACK;
561  #else
562  	if (name[0] == &#x27;l&#x27; &amp;&amp; name[1] == &#x27;o&#x27; &amp;&amp;
563  	    (PCAP_ISDIGIT(name[2]) || name[2] == &#x27;\0&#x27;))
564  		pcap_flags |= PCAP_IF_LOOPBACK;
565  #endif
566  #ifdef IFF_UP
567  	if (if_flags &amp; IFF_UP)
568  		pcap_flags |= PCAP_IF_UP;
569  #endif
570  #ifdef IFF_RUNNING
571  	if (if_flags &amp; IFF_RUNNING)
572  		pcap_flags |= PCAP_IF_RUNNING;
573  #endif
574  	return (pcap_find_or_add_dev(devlistp, name, pcap_flags,
575  	    get_flags_func, get_if_description(name), errbuf));
576  }
577  int
578  pcap_add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
579      bpf_u_int32 if_flags, get_if_flags_func get_flags_func,
580      struct sockaddr *addr, size_t addr_size,
581      struct sockaddr *netmask, size_t netmask_size,
582      struct sockaddr *broadaddr, size_t broadaddr_size,
583      struct sockaddr *dstaddr, size_t dstaddr_size,
584      char *errbuf)
585  {
586  	pcap_if_t *curdev;
587  	curdev = pcap_find_or_add_if(devlistp, name, if_flags, get_flags_func,
588  	    errbuf);
589  	if (curdev == NULL) {
590  		return (-1);
591  	}
592  	if (addr == NULL) {
593  		return (0);
594  	}
595  	return (pcap_add_addr_to_dev(curdev, addr, addr_size, netmask,
596  	    netmask_size, broadaddr, broadaddr_size, dstaddr,
597  	    dstaddr_size, errbuf));
598  }
599  #endif &amp;bsol;* _WIN32 */
600  int
601  pcap_add_addr_to_dev(pcap_if_t *curdev,
602      struct sockaddr *addr, size_t addr_size,
603      struct sockaddr *netmask, size_t netmask_size,
604      struct sockaddr *broadaddr, size_t broadaddr_size,
605      struct sockaddr *dstaddr, size_t dstaddr_size,
606      char *errbuf)
607  {
608  	pcap_addr_t *curaddr, *prevaddr, *nextaddr;
609  	curaddr = (pcap_addr_t *)malloc(sizeof(pcap_addr_t));
610  	if (curaddr == NULL) {
611  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
612  		    errno, &quot;malloc&quot;);
613  		return (-1);
614  	}
615  	curaddr-&gt;next = NULL;
616  	if (addr != NULL &amp;&amp; addr_size != 0) {
617  		curaddr-&gt;addr = (struct sockaddr *)dup_sockaddr(addr, addr_size);
618  		if (curaddr-&gt;addr == NULL) {
619  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
620  			    errno, &quot;malloc&quot;);
621  			free(curaddr);
622  			return (-1);
623  		}
624  	} else
625  		curaddr-&gt;addr = NULL;
626  	if (netmask != NULL &amp;&amp; netmask_size != 0) {
627  		curaddr-&gt;netmask = (struct sockaddr *)dup_sockaddr(netmask, netmask_size);
628  		if (curaddr-&gt;netmask == NULL) {
629  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
630  			    errno, &quot;malloc&quot;);
631  			if (curaddr-&gt;addr != NULL)
632  				free(curaddr-&gt;addr);
633  			free(curaddr);
634  			return (-1);
635  		}
636  	} else
637  		curaddr-&gt;netmask = NULL;
638  	if (broadaddr != NULL &amp;&amp; broadaddr_size != 0) {
639  		curaddr-&gt;broadaddr = (struct sockaddr *)dup_sockaddr(broadaddr, broadaddr_size);
640  		if (curaddr-&gt;broadaddr == NULL) {
641  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
642  			    errno, &quot;malloc&quot;);
643  			if (curaddr-&gt;netmask != NULL)
644  				free(curaddr-&gt;netmask);
645  			if (curaddr-&gt;addr != NULL)
646  				free(curaddr-&gt;addr);
647  			free(curaddr);
648  			return (-1);
649  		}
650  	} else
651  		curaddr-&gt;broadaddr = NULL;
652  	if (dstaddr != NULL &amp;&amp; dstaddr_size != 0) {
653  		curaddr-&gt;dstaddr = (struct sockaddr *)dup_sockaddr(dstaddr, dstaddr_size);
654  		if (curaddr-&gt;dstaddr == NULL) {
655  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
656  			    errno, &quot;malloc&quot;);
657  			if (curaddr-&gt;broadaddr != NULL)
658  				free(curaddr-&gt;broadaddr);
659  			if (curaddr-&gt;netmask != NULL)
660  				free(curaddr-&gt;netmask);
661  			if (curaddr-&gt;addr != NULL)
662  				free(curaddr-&gt;addr);
663  			free(curaddr);
664  			return (-1);
665  		}
666  	} else
667  		curaddr-&gt;dstaddr = NULL;
668  	for (prevaddr = curdev-&gt;addresses; prevaddr != NULL; prevaddr = nextaddr) {
669  		nextaddr = prevaddr-&gt;next;
670  		if (nextaddr == NULL) {
671  			break;
672  		}
673  	}
674  	if (prevaddr == NULL) {
675  		curdev-&gt;addresses = curaddr;
676  	} else {
677  		prevaddr-&gt;next = curaddr;
678  	}
679  	return (0);
680  }
681  pcap_if_t *
682  pcap_find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
683      get_if_flags_func get_flags_func, const char *description, char *errbuf)
684  {
685  	pcap_if_t *curdev;
686  	curdev = pcap_find_dev(devlistp, name);
687  	if (curdev != NULL) {
688  		return (curdev);
689  	}
690  	if ((*get_flags_func)(name, &amp;flags, errbuf) == -1) {
691  		return (NULL);
692  	}
693  	return (pcap_add_dev(devlistp, name, flags, description, errbuf));
694  }
695  pcap_if_t *
696  pcap_find_dev(pcap_if_list_t *devlistp, const char *name)
697  {
698  	pcap_if_t *curdev;
699  	for (curdev = devlistp-&gt;beginning; curdev != NULL;
700  	    curdev = curdev-&gt;next) {
701  		if (strcmp(name, curdev-&gt;name) == 0) {
702  			return (curdev);
703  		}
704  	}
705  	return (NULL);
706  }
707  pcap_if_t *
708  pcap_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
709      const char *description, char *errbuf)
710  {
711  	pcap_if_t *curdev, *prevdev, *nextdev;
712  	u_int this_figure_of_merit, nextdev_figure_of_merit;
713  	curdev = malloc(sizeof(pcap_if_t));
714  	if (curdev == NULL) {
715  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
716  		    errno, &quot;malloc&quot;);
717  		return (NULL);
718  	}
719  	curdev-&gt;next = NULL;
720  	curdev-&gt;name = strdup(name);
721  	if (curdev-&gt;name == NULL) {
722  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
723  		    errno, &quot;malloc&quot;);
724  		free(curdev);
725  		return (NULL);
726  	}
727  	if (description == NULL) {
728  		curdev-&gt;description = NULL;
729  	} else {
730  		curdev-&gt;description = strdup(description);
731  		if (curdev-&gt;description == NULL) {
732  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
733  			    errno, &quot;malloc&quot;);
734  			free(curdev-&gt;name);
735  			free(curdev);
736  			return (NULL);
737  		}
738  	}
739  	curdev-&gt;addresses = NULL;	&amp;bsol;* list starts out as empty */
740  	curdev-&gt;flags = flags;
741  	this_figure_of_merit = get_figure_of_merit(curdev);
742  	prevdev = NULL;
743  	for (;;) {
744  		if (prevdev == NULL) {
745  			nextdev = devlistp-&gt;beginning;
746  		} else
747  			nextdev = prevdev-&gt;next;
748  		if (nextdev == NULL) {
749  			break;
750  		}
751  		nextdev_figure_of_merit = get_figure_of_merit(nextdev);
752  		if (this_figure_of_merit &lt; nextdev_figure_of_merit) {
753  			break;
754  		}
755  		prevdev = nextdev;
756  	}
757  	curdev-&gt;next = nextdev;
758  	if (prevdev == NULL) {
759  		devlistp-&gt;beginning = curdev;
760  	} else
761  		prevdev-&gt;next = curdev;
762  	return (curdev);
763  }
764  pcap_if_t *
765  pcap_add_any_dev(pcap_if_list_t *devlistp, char *errbuf)
766  {
767  	static const char any_descr[] = &quot;Pseudo-device that captures on all interfaces&quot;;
768  	return pcap_add_dev(devlistp, &quot;any&quot;,
769  	    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
770  	    any_descr, errbuf);
771  }
772  void
773  pcap_freealldevs(pcap_if_t *alldevs)
774  {
775  	pcap_if_t *curdev, *nextdev;
776  	pcap_addr_t *curaddr, *nextaddr;
777  	for (curdev = alldevs; curdev != NULL; curdev = nextdev) {
778  		nextdev = curdev-&gt;next;
779  		for (curaddr = curdev-&gt;addresses; curaddr != NULL; curaddr = nextaddr) {
780  			nextaddr = curaddr-&gt;next;
781  			if (curaddr-&gt;addr)
<span onclick='openModal()' class='match'>782  				free(curaddr-&gt;addr);
783  			if (curaddr-&gt;netmask)
784  				free(curaddr-&gt;netmask);
785  			if (curaddr-&gt;broadaddr)
</span>786  				free(curaddr-&gt;broadaddr);
787  			if (curaddr-&gt;dstaddr)
788  				free(curaddr-&gt;dstaddr);
789  			free(curaddr);
790  		}
791  		free(curdev-&gt;name);
792  		if (curdev-&gt;description != NULL)
793  			free(curdev-&gt;description);
794  		free(curdev);
795  	}
796  }
797  #if !defined(HAVE_PACKET32) &amp;&amp; !defined(MSDOS)
798  char *
799  pcap_lookupdev(char *errbuf)
800  {
801  	pcap_if_t *alldevs;
802  #ifdef _WIN32
803    #define IF_NAMESIZE 8192
804  #else
805  #endif
806  	static char device[IF_NAMESIZE + 1];
807  	char *ret;
808  	if (pcap_new_api) {
809  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
810  		    &quot;pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()&quot;);
811  		return (NULL);
812  	}
813  	if (pcap_findalldevs(&amp;alldevs, errbuf) == -1)
814  		return (NULL);
815  	if (alldevs == NULL || (alldevs-&gt;flags &amp; PCAP_IF_LOOPBACK)) {
816  		(void)pcap_strlcpy(errbuf, &quot;no suitable device found&quot;,
817  		    PCAP_ERRBUF_SIZE);
818  		ret = NULL;
819  	} else {
820  		(void)pcap_strlcpy(device, alldevs-&gt;name, sizeof(device));
821  		ret = device;
822  	}
823  	pcap_freealldevs(alldevs);
824  	return (ret);
825  }
826  #endif &amp;bsol;* !defined(HAVE_PACKET32) &amp;&amp; !defined(MSDOS) */
827  #if !defined(_WIN32) &amp;&amp; !defined(MSDOS)
828  int
829  pcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,
830      char *errbuf)
831  {
832  	register int fd;
833  	register struct sockaddr_in *sin4;
834  	struct ifreq ifr;
835  	if (!device || strcmp(device, &quot;any&quot;) == 0
836  #ifdef HAVE_DAG_API
837  	    || strstr(device, &quot;dag&quot;) != NULL
838  #endif
839  #ifdef HAVE_SEPTEL_API
840  	    || strstr(device, &quot;septel&quot;) != NULL
841  #endif
842  #ifdef PCAP_SUPPORT_BT
843  	    || strstr(device, &quot;bluetooth&quot;) != NULL
844  #endif
845  #ifdef PCAP_SUPPORT_LINUX_USBMON
846  	    || strstr(device, &quot;usbmon&quot;) != NULL
847  #endif
848  #ifdef HAVE_SNF_API
849  	    || strstr(device, &quot;snf&quot;) != NULL
850  #endif
851  #ifdef PCAP_SUPPORT_NETMAP
852  	    || strncmp(device, &quot;netmap:&quot;, 7) == 0
853  	    || strncmp(device, &quot;vale&quot;, 4) == 0
854  #endif
855  #ifdef PCAP_SUPPORT_DPDK
856  	    || strncmp(device, &quot;dpdk:&quot;, 5) == 0
857  #endif
858  	    ) {
859  		*netp = *maskp = 0;
860  		return 0;
861  	}
862  	fd = socket(AF_INET, SOCK_DGRAM, 0);
863  	if (fd &lt; 0) {
864  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
865  		    errno, &quot;socket&quot;);
866  		return (-1);
867  	}
868  	memset(&amp;ifr, 0, sizeof(ifr));
869  #ifdef linux
870  	ifr.ifr_addr.sa_family = AF_INET;
871  #endif
872  	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
873  #if defined(__HAIKU__) &amp;&amp; defined(__clang__)
874  	if (ioctl(fd, SIOCGIFADDR, (char *)&amp;ifr, sizeof(ifr)) &lt; 0) {
875  #else
876  	if (ioctl(fd, SIOCGIFADDR, (char *)&amp;ifr) &lt; 0) {
877  #endif &amp;bsol;* __HAIKU__ &amp;&amp; __clang__ */
878  		if (errno == EADDRNOTAVAIL) {
879  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
880  			    &quot;%s: no IPv4 address assigned&quot;, device);
881  		} else {
882  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
883  			    errno, &quot;SIOCGIFADDR: %s&quot;, device);
884  		}
885  		(void)close(fd);
886  		return (-1);
887  	}
888  	sin4 = (struct sockaddr_in *)&amp;ifr.ifr_addr;
889  	*netp = sin4-&gt;sin_addr.s_addr;
890  	memset(&amp;ifr, 0, sizeof(ifr));
891  #ifdef linux
892  	ifr.ifr_addr.sa_family = AF_INET;
893  #endif
894  	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
895  #if defined(__HAIKU__) &amp;&amp; defined(__clang__)
896  	if (ioctl(fd, SIOCGIFNETMASK, (char *)&amp;ifr, sizeof(ifr)) &lt; 0) {
897  #else
898  	if (ioctl(fd, SIOCGIFNETMASK, (char *)&amp;ifr) &lt; 0) {
899  #endif &amp;bsol;* __HAIKU__ &amp;&amp; __clang__ */
900  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
901  		    errno, &quot;SIOCGIFNETMASK: %s&quot;, device);
902  		(void)close(fd);
903  		return (-1);
904  	}
905  	(void)close(fd);
906  	*maskp = sin4-&gt;sin_addr.s_addr;
907  	if (*maskp == 0) {
908  		if (IN_CLASSA(*netp))
909  			*maskp = IN_CLASSA_NET;
910  		else if (IN_CLASSB(*netp))
911  			*maskp = IN_CLASSB_NET;
912  		else if (IN_CLASSC(*netp))
913  			*maskp = IN_CLASSC_NET;
914  		else {
915  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
916  			    &quot;inet class for 0x%x unknown&quot;, *netp);
917  			return (-1);
918  		}
919  	}
920  	*netp &amp;= *maskp;
921  	return (0);
922  }
923  #endif &amp;bsol;* !defined(_WIN32) &amp;&amp; !defined(MSDOS) */
924  #ifdef ENABLE_REMOTE
925  #include &quot;pcap-rpcap.h&quot;
926  static char *
927  get_substring(const char *p, size_t len, char *ebuf)
928  {
929  	char *token;
930  	token = malloc(len + 1);
931  	if (token == NULL) {
932  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
933  		    errno, &quot;malloc&quot;);
934  		return (NULL);
935  	}
936  	memcpy(token, p, len);
937  	token[len] = &#x27;\0&#x27;;
938  	return (token);
939  }
940  static int
941  pcap_parse_source(const char *source, char **schemep, char **userinfop,
942      char **hostp, char **portp, char **pathp, char *ebuf)
943  {
944  	char *colonp;
945  	size_t scheme_len;
946  	char *scheme;
947  	const char *endp;
948  	size_t authority_len;
949  	char *authority;
950  	char *parsep, *atsignp, *bracketp;
951  	char *userinfo, *host, *port, *path;
952  	*schemep = NULL;
953  	*userinfop = NULL;
954  	*hostp = NULL;
955  	*portp = NULL;
956  	*pathp = NULL;
957  	colonp = strchr(source, &#x27;:&#x27;);
958  	if (colonp == NULL) {
959  		*pathp = strdup(source);
960  		if (*pathp == NULL) {
961  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
962  			    errno, &quot;malloc&quot;);
963  			return (-1);
964  		}
965  		return (0);
966  	}
967  	if (strncmp(colonp + 1, &quot;&amp;bsol;&amp;bsol;&quot;, 2) != 0) {
968  		*pathp = strdup(source);
969  		if (*pathp == NULL) {
970  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
971  			    errno, &quot;malloc&quot;);
972  			return (-1);
973  		}
974  		return (0);
975  	}
976  	scheme_len = colonp - source;
977  	scheme = malloc(scheme_len + 1);
978  	if (scheme == NULL) {
979  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
980  		    errno, &quot;malloc&quot;);
981  		return (-1);
982  	}
983  	memcpy(scheme, source, scheme_len);
984  	scheme[scheme_len] = &#x27;\0&#x27;;
985  	if (pcap_strcasecmp(scheme, &quot;file&quot;) == 0) {
986  		*pathp = strdup(colonp + 3);
987  		if (*pathp == NULL) {
988  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
989  			    errno, &quot;malloc&quot;);
990  			free(scheme);
991  			return (-1);
992  		}
993  		*schemep = scheme;
994  		return (0);
995  	}
996  	if ((pcap_strcasecmp(scheme, &quot;rpcap&quot;) == 0 ||
997  	    pcap_strcasecmp(scheme, &quot;rpcaps&quot;) == 0) &amp;&amp;
998  	    strchr(colonp + 3, &#x27;/&#x27;) == NULL) {
999  		free(scheme);
1000  		*pathp = strdup(colonp + 3);
1001  		if (*pathp == NULL) {
1002  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1003  			    errno, &quot;malloc&quot;);
1004  			return (-1);
1005  		}
1006  		return (0);
1007  	}
1008  	authority_len = strcspn(colonp + 3, &quot;/&quot;);
1009  	authority = get_substring(colonp + 3, authority_len, ebuf);
1010  	if (authority == NULL) {
1011  		free(scheme);
1012  		return (-1);
1013  	}
1014  	endp = colonp + 3 + authority_len;
1015  	parsep = authority;
1016  	atsignp = strchr(parsep, &#x27;@&#x27;);
1017  	if (atsignp != NULL) {
1018  		size_t userinfo_len;
1019  		userinfo_len = atsignp - parsep;
1020  		userinfo = get_substring(parsep, userinfo_len, ebuf);
1021  		if (userinfo == NULL) {
1022  			free(authority);
1023  			free(scheme);
1024  			return (-1);
1025  		}
1026  		parsep = atsignp + 1;
1027  	} else {
1028  		userinfo = NULL;
1029  	}
1030  	if (*parsep == &#x27;\0&#x27;) {
1031  		host = NULL;
1032  		port = NULL;
1033  	} else {
1034  		size_t host_len;
1035  		if (*parsep == &#x27;[&#x27;) {
1036  			bracketp = strchr(parsep, &#x27;]&#x27;);
1037  			if (bracketp == NULL) {
1038  				snprintf(ebuf, PCAP_ERRBUF_SIZE,
1039  				    &quot;IP-literal in URL doesn&#x27;t end with ]&quot;);
1040  				free(userinfo);
1041  				free(authority);
1042  				free(scheme);
1043  				return (-1);
1044  			}
1045  			if (*(bracketp + 1) != &#x27;\0&#x27; &amp;&amp;
1046  			    *(bracketp + 1) != &#x27;:&#x27;) {
1047  				snprintf(ebuf, PCAP_ERRBUF_SIZE,
1048  				    &quot;Extra text after IP-literal in URL&quot;);
1049  				free(userinfo);
1050  				free(authority);
1051  				free(scheme);
1052  				return (-1);
1053  			}
1054  			host_len = (bracketp - 1) - parsep;
1055  			host = get_substring(parsep + 1, host_len, ebuf);
1056  			if (host == NULL) {
1057  				free(userinfo);
1058  				free(authority);
1059  				free(scheme);
1060  				return (-1);
1061  			}
1062  			parsep = bracketp + 1;
1063  		} else {
1064  			host_len = strcspn(parsep, &quot;:&quot;);
1065  			host = get_substring(parsep, host_len, ebuf);
1066  			if (host == NULL) {
1067  				free(userinfo);
1068  				free(authority);
1069  				free(scheme);
1070  				return (-1);
1071  			}
1072  			parsep = parsep + host_len;
1073  		}
1074  		if (*parsep == &#x27;:&#x27;) {
1075  			size_t port_len;
1076  			parsep++;
1077  			port_len = strlen(parsep);
1078  			port = get_substring(parsep, port_len, ebuf);
1079  			if (port == NULL) {
1080  				free(host);
1081  				free(userinfo);
1082  				free(authority);
1083  				free(scheme);
1084  				return (-1);
1085  			}
1086  		} else {
1087  			port = NULL;
1088  		}
1089  	}
1090  	free(authority);
1091  	if (*endp == &#x27;\0&#x27;)
1092  		path = strdup(&quot;&quot;);
1093  	else
1094  		path = strdup(endp + 1);
1095  	if (path == NULL) {
1096  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1097  		    errno, &quot;malloc&quot;);
1098  		free(port);
1099  		free(host);
1100  		free(userinfo);
1101  		free(scheme);
1102  		return (-1);
1103  	}
1104  	*schemep = scheme;
1105  	*userinfop = userinfo;
1106  	*hostp = host;
1107  	*portp = port;
1108  	*pathp = path;
1109  	return (0);
1110  }
1111  int
1112  pcap_createsrcstr_ex(char *source, int type, const char *userinfo, const char *host,
1113      const char *port, const char *name, unsigned char uses_ssl, char *errbuf)
1114  {
1115  	switch (type) {
1116  	case PCAP_SRC_FILE:
1117  		pcap_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);
1118  		if (name != NULL &amp;&amp; *name != &#x27;\0&#x27;) {
1119  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1120  			return (0);
1121  		} else {
1122  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1123  			    &quot;The file name cannot be NULL.&quot;);
1124  			return (-1);
1125  		}
1126  	case PCAP_SRC_IFREMOTE:
1127  		pcap_strlcpy(source,
1128  		    (uses_ssl ? &quot;rpcaps:&amp;bsol;&amp;bsol;&quot; : PCAP_SRC_IF_STRING),
1129  		    PCAP_BUF_SIZE);
1130  		if (host != NULL &amp;&amp; *host != &#x27;\0&#x27;) {
1131  			if (userinfo != NULL &amp;&amp; *userinfo != &#x27;\0&#x27;) {
1132  				pcap_strlcat(source, userinfo, PCAP_BUF_SIZE);
1133  				pcap_strlcat(source, &quot;@&quot;, PCAP_BUF_SIZE);
1134  			}
1135  			if (strchr(host, &#x27;:&#x27;) != NULL) {
1136  				pcap_strlcat(source, &quot;[&quot;, PCAP_BUF_SIZE);
1137  				pcap_strlcat(source, host, PCAP_BUF_SIZE);
1138  				pcap_strlcat(source, &quot;]&quot;, PCAP_BUF_SIZE);
1139  			} else
1140  				pcap_strlcat(source, host, PCAP_BUF_SIZE);
1141  			if (port != NULL &amp;&amp; *port != &#x27;\0&#x27;) {
1142  				pcap_strlcat(source, &quot;:&quot;, PCAP_BUF_SIZE);
1143  				pcap_strlcat(source, port, PCAP_BUF_SIZE);
1144  			}
1145  			pcap_strlcat(source, &quot;/&quot;, PCAP_BUF_SIZE);
1146  		} else {
1147  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1148  			    &quot;The host name cannot be NULL.&quot;);
1149  			return (-1);
1150  		}
1151  		if (name != NULL &amp;&amp; *name != &#x27;\0&#x27;)
1152  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1153  		return (0);
1154  	case PCAP_SRC_IFLOCAL:
1155  		pcap_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);
1156  		if (name != NULL &amp;&amp; *name != &#x27;\0&#x27;)
1157  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1158  		return (0);
1159  	default:
1160  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1161  		    &quot;The interface type is not valid.&quot;);
1162  		return (-1);
1163  	}
1164  }
1165  int
1166  pcap_createsrcstr(char *source, int type, const char *host, const char *port,
1167      const char *name, char *errbuf)
1168  {
1169  	return (pcap_createsrcstr_ex(source, type, NULL, host, port, name, 0, errbuf));
1170  }
1171  int
1172  pcap_parsesrcstr_ex(const char *source, int *type, char *userinfo, char *host,
1173      char *port, char *name, unsigned char *uses_ssl, char *errbuf)
1174  {
1175  	char *scheme, *tmpuserinfo, *tmphost, *tmpport, *tmppath;
1176  	if (userinfo)
1177  		*userinfo = &#x27;\0&#x27;;
1178  	if (host)
1179  		*host = &#x27;\0&#x27;;
1180  	if (port)
1181  		*port = &#x27;\0&#x27;;
1182  	if (name)
1183  		*name = &#x27;\0&#x27;;
1184  	if (uses_ssl)
1185  		*uses_ssl = 0;
1186  	if (pcap_parse_source(source, &amp;scheme, &amp;tmpuserinfo, &amp;tmphost,
1187  	    &amp;tmpport, &amp;tmppath, errbuf) == -1) {
1188  		return (-1);
1189  	}
1190  	if (scheme == NULL) {
1191  		if (name &amp;&amp; tmppath)
1192  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1193  		if (type)
1194  			*type = PCAP_SRC_IFLOCAL;
1195  		free(tmppath);
1196  		free(tmpport);
1197  		free(tmphost);
1198  		free(tmpuserinfo);
1199  		return (0);
1200  	}
1201  	int is_rpcap = 0;
1202  	if (strcmp(scheme, &quot;rpcaps&quot;) == 0) {
1203  		is_rpcap = 1;
1204  		if (uses_ssl) *uses_ssl = 1;
1205  	} else if (strcmp(scheme, &quot;rpcap&quot;) == 0) {
1206  		is_rpcap = 1;
1207  	}
1208  	if (is_rpcap) {
1209  		if (userinfo &amp;&amp; tmpuserinfo)
1210  			pcap_strlcpy(userinfo, tmpuserinfo, PCAP_BUF_SIZE);
1211  		if (host &amp;&amp; tmphost)
1212  			pcap_strlcpy(host, tmphost, PCAP_BUF_SIZE);
1213  		if (port &amp;&amp; tmpport)
1214  			pcap_strlcpy(port, tmpport, PCAP_BUF_SIZE);
1215  		if (name &amp;&amp; tmppath)
1216  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1217  		if (type)
1218  			*type = PCAP_SRC_IFREMOTE;
1219  		free(tmppath);
1220  		free(tmpport);
1221  		free(tmphost);
1222  		free(tmpuserinfo);
1223  		free(scheme);
1224  		return (0);
1225  	}
1226  	if (strcmp(scheme, &quot;file&quot;) == 0) {
1227  		if (name &amp;&amp; tmppath)
1228  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1229  		if (type)
1230  			*type = PCAP_SRC_FILE;
1231  		free(tmppath);
1232  		free(tmpport);
1233  		free(tmphost);
1234  		free(tmpuserinfo);
1235  		free(scheme);
1236  		return (0);
1237  	}
1238  	if (name)
1239  		pcap_strlcpy(name, source, PCAP_BUF_SIZE);
1240  	if (type)
1241  		*type = PCAP_SRC_IFLOCAL;
1242  	free(tmppath);
1243  	free(tmpport);
1244  	free(tmphost);
1245  	free(tmpuserinfo);
1246  	free(scheme);
1247  	return (0);
1248  }
1249  int
1250  pcap_parsesrcstr(const char *source, int *type, char *host, char *port,
1251      char *name, char *errbuf)
1252  {
1253  	return (pcap_parsesrcstr_ex(source, type, NULL, host, port, name, NULL, errbuf));
1254  }
1255  #endif
1256  pcap_t *
1257  pcap_create(const char *device, char *errbuf)
1258  {
1259  	size_t i;
1260  	int is_theirs;
1261  	pcap_t *p;
1262  	char *device_str;
1263  	if (device == NULL)
1264  		device_str = strdup(&quot;any&quot;);
1265  	else {
1266  #ifdef _WIN32
1267  		if (!pcap_new_api &amp;&amp; device[0] != &#x27;\0&#x27; &amp;&amp; device[1] == &#x27;\0&#x27;) {
1268  			size_t length;
1269  			length = wcslen((wchar_t *)device);
1270  			device_str = (char *)malloc(length + 1);
1271  			if (device_str == NULL) {
1272  				pcap_fmt_errmsg_for_errno(errbuf,
1273  				    PCAP_ERRBUF_SIZE, errno,
1274  				    &quot;malloc&quot;);
1275  				return (NULL);
1276  			}
1277  			snprintf(device_str, length + 1, &quot;%ws&quot;,
1278  			    (const wchar_t *)device);
1279  		} else
1280  #endif
1281  			device_str = strdup(device);
1282  	}
1283  	if (device_str == NULL) {
1284  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1285  		    errno, &quot;malloc&quot;);
1286  		return (NULL);
1287  	}
1288  	for (i = 0; capture_source_types[i].create_op != NULL; i++) {
1289  		is_theirs = 0;
1290  		p = capture_source_types[i].create_op(device_str, errbuf,
1291  		    &amp;is_theirs);
1292  		if (is_theirs) {
1293  			if (p == NULL) {
1294  				free(device_str);
1295  				return (NULL);
1296  			}
1297  			p-&gt;opt.device = device_str;
1298  			return (p);
1299  		}
1300  	}
1301  	p = pcap_create_interface(device_str, errbuf);
1302  	if (p == NULL) {
1303  		free(device_str);
1304  		return (NULL);
1305  	}
1306  	p-&gt;opt.device = device_str;
1307  	return (p);
1308  }
1309  static int
1310  pcap_setnonblock_unactivated(pcap_t *p, int nonblock)
1311  {
1312  	p-&gt;opt.nonblock = nonblock;
1313  	return (0);
1314  }
1315  static void
1316  initialize_ops(pcap_t *p)
1317  {
1318  	p-&gt;read_op = pcap_read_not_initialized;
1319  	p-&gt;inject_op = pcap_inject_not_initialized;
1320  	p-&gt;setfilter_op = pcap_setfilter_not_initialized;
1321  	p-&gt;setdirection_op = pcap_setdirection_not_initialized;
1322  	p-&gt;set_datalink_op = pcap_set_datalink_not_initialized;
1323  	p-&gt;getnonblock_op = pcap_getnonblock_not_initialized;
1324  	p-&gt;stats_op = pcap_stats_not_initialized;
1325  #ifdef _WIN32
1326  	p-&gt;stats_ex_op = pcap_stats_ex_not_initialized;
1327  	p-&gt;setbuff_op = pcap_setbuff_not_initialized;
1328  	p-&gt;setmode_op = pcap_setmode_not_initialized;
1329  	p-&gt;setmintocopy_op = pcap_setmintocopy_not_initialized;
1330  	p-&gt;getevent_op = pcap_getevent_not_initialized;
1331  	p-&gt;oid_get_request_op = pcap_oid_get_request_not_initialized;
1332  	p-&gt;oid_set_request_op = pcap_oid_set_request_not_initialized;
1333  	p-&gt;sendqueue_transmit_op = pcap_sendqueue_transmit_not_initialized;
1334  	p-&gt;setuserbuffer_op = pcap_setuserbuffer_not_initialized;
1335  	p-&gt;live_dump_op = pcap_live_dump_not_initialized;
1336  	p-&gt;live_dump_ended_op = pcap_live_dump_ended_not_initialized;
1337  	p-&gt;get_airpcap_handle_op = pcap_get_airpcap_handle_not_initialized;
1338  #endif
1339  	p-&gt;cleanup_op = pcap_cleanup_live_common;
1340  	p-&gt;oneshot_callback = pcap_oneshot;
1341  	p-&gt;breakloop_op = pcap_breakloop_common;
1342  }
1343  static pcap_t *
1344  pcap_alloc_pcap_t(char *ebuf, size_t total_size, size_t private_offset)
1345  {
1346  	char *chunk;
1347  	pcap_t *p;
1348  	chunk = calloc(total_size, 1);
1349  	if (chunk == NULL) {
1350  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1351  		    errno, &quot;malloc&quot;);
1352  		return (NULL);
1353  	}
1354  	p = (pcap_t *)chunk;
1355  #ifdef _WIN32
1356  	p-&gt;handle = INVALID_HANDLE_VALUE;	&amp;bsol;* not opened yet */
1357  #else &amp;bsol;* _WIN32 */
1358  	p-&gt;fd = -1;	&amp;bsol;* not opened yet */
1359  #ifndef MSDOS
1360  	p-&gt;selectable_fd = -1;
1361  	p-&gt;required_select_timeout = NULL;
1362  #endif &amp;bsol;* MSDOS */
1363  #endif &amp;bsol;* _WIN32 */
1364  	p-&gt;priv = (void *)(chunk + private_offset);
1365  	return (p);
1366  }
1367  pcap_t *
1368  pcap_create_common(char *ebuf, size_t total_size, size_t private_offset)
1369  {
1370  	pcap_t *p;
1371  	p = pcap_alloc_pcap_t(ebuf, total_size, private_offset);
1372  	if (p == NULL)
1373  		return (NULL);
1374  	p-&gt;can_set_rfmon_op = pcap_cant_set_rfmon;
1375  	p-&gt;setnonblock_op = pcap_setnonblock_unactivated;
1376  	initialize_ops(p);
1377  	p-&gt;snapshot = 0;		&amp;bsol;* max packet size unspecified */
1378  	p-&gt;opt.timeout = 0;		&amp;bsol;* no timeout specified */
1379  	p-&gt;opt.buffer_size = 0;		&amp;bsol;* use the platform&#x27;s default */
1380  	p-&gt;opt.promisc = 0;
1381  	p-&gt;opt.rfmon = 0;
1382  	p-&gt;opt.immediate = 0;
1383  	p-&gt;opt.tstamp_type = -1;	&amp;bsol;* default to not setting time stamp type */
1384  	p-&gt;opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;
1385  #ifdef __linux__
1386  	p-&gt;opt.protocol = 0;
1387  #endif
1388  #ifdef _WIN32
1389  	p-&gt;opt.nocapture_local = 0;
1390  #endif
1391  	p-&gt;bpf_codegen_flags = 0;
1392  	return (p);
1393  }
1394  int
1395  pcap_check_activated(pcap_t *p)
1396  {
1397  	if (p-&gt;activated) {
1398  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;can&#x27;t perform &quot;
1399  			&quot; operation on activated capture&quot;);
1400  		return (-1);
1401  	}
1402  	return (0);
1403  }
1404  int
1405  pcap_set_snaplen(pcap_t *p, int snaplen)
1406  {
1407  	if (pcap_check_activated(p))
1408  		return (PCAP_ERROR_ACTIVATED);
1409  	p-&gt;snapshot = snaplen;
1410  	return (0);
1411  }
1412  int
1413  pcap_set_promisc(pcap_t *p, int promisc)
1414  {
1415  	if (pcap_check_activated(p))
1416  		return (PCAP_ERROR_ACTIVATED);
1417  	p-&gt;opt.promisc = promisc;
1418  	return (0);
1419  }
1420  int
1421  pcap_set_rfmon(pcap_t *p, int rfmon)
1422  {
1423  	if (pcap_check_activated(p))
1424  		return (PCAP_ERROR_ACTIVATED);
1425  	p-&gt;opt.rfmon = rfmon;
1426  	return (0);
1427  }
1428  int
1429  pcap_set_timeout(pcap_t *p, int timeout_ms)
1430  {
1431  	if (pcap_check_activated(p))
1432  		return (PCAP_ERROR_ACTIVATED);
1433  	p-&gt;opt.timeout = timeout_ms;
1434  	return (0);
1435  }
1436  int
1437  pcap_set_tstamp_type(pcap_t *p, int tstamp_type)
1438  {
1439  	int i;
1440  	if (pcap_check_activated(p))
1441  		return (PCAP_ERROR_ACTIVATED);
1442  	if (tstamp_type &lt; 0)
1443  		return (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);
1444  	if (p-&gt;tstamp_type_count == 0) {
1445  		if (tstamp_type == PCAP_TSTAMP_HOST) {
1446  			p-&gt;opt.tstamp_type = tstamp_type;
1447  			return (0);
1448  		}
1449  	} else {
1450  		for (i = 0; i &lt; p-&gt;tstamp_type_count; i++) {
1451  			if (p-&gt;tstamp_type_list[i] == (u_int)tstamp_type) {
1452  				p-&gt;opt.tstamp_type = tstamp_type;
1453  				return (0);
1454  			}
1455  		}
1456  	}
1457  	return (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);
1458  }
1459  int
1460  pcap_set_immediate_mode(pcap_t *p, int immediate)
1461  {
1462  	if (pcap_check_activated(p))
1463  		return (PCAP_ERROR_ACTIVATED);
1464  	p-&gt;opt.immediate = immediate;
1465  	return (0);
1466  }
1467  int
1468  pcap_set_buffer_size(pcap_t *p, int buffer_size)
1469  {
1470  	if (pcap_check_activated(p))
1471  		return (PCAP_ERROR_ACTIVATED);
1472  	if (buffer_size &lt;= 0) {
1473  		return (0);
1474  	}
1475  	p-&gt;opt.buffer_size = buffer_size;
1476  	return (0);
1477  }
1478  int
1479  pcap_set_tstamp_precision(pcap_t *p, int tstamp_precision)
1480  {
1481  	int i;
1482  	if (pcap_check_activated(p))
1483  		return (PCAP_ERROR_ACTIVATED);
1484  	if (tstamp_precision &lt; 0)
1485  		return (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);
1486  	if (p-&gt;tstamp_precision_count == 0) {
1487  		if (tstamp_precision == PCAP_TSTAMP_PRECISION_MICRO) {
1488  			p-&gt;opt.tstamp_precision = tstamp_precision;
1489  			return (0);
1490  		}
1491  	} else {
1492  		for (i = 0; i &lt; p-&gt;tstamp_precision_count; i++) {
1493  			if (p-&gt;tstamp_precision_list[i] == (u_int)tstamp_precision) {
1494  				p-&gt;opt.tstamp_precision = tstamp_precision;
1495  				return (0);
1496  			}
1497  		}
1498  	}
1499  	return (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);
1500  }
1501  int
1502  pcap_get_tstamp_precision(pcap_t *p)
1503  {
1504          return (p-&gt;opt.tstamp_precision);
1505  }
1506  int
1507  pcap_activate(pcap_t *p)
1508  {
1509  	int status;
1510  	if (pcap_check_activated(p))
1511  		return (PCAP_ERROR_ACTIVATED);
1512  	status = p-&gt;activate_op(p);
1513  	if (status &gt;= 0) {
1514  		if (p-&gt;opt.nonblock) {
1515  			status = p-&gt;setnonblock_op(p, 1);
1516  			if (status &lt; 0) {
1517  				p-&gt;cleanup_op(p);
1518  				initialize_ops(p);
1519  				return (status);
1520  			}
1521  		}
1522  		p-&gt;activated = 1;
1523  	} else {
1524  		if (p-&gt;errbuf[0] == &#x27;\0&#x27;) {
1525  			snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;%s&quot;,
1526  			    pcap_statustostr(status));
1527  		}
1528  		initialize_ops(p);
1529  	}
1530  	return (status);
1531  }
1532  pcap_t *
1533  pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)
1534  {
1535  	pcap_t *p;
1536  	int status;
1537  #ifdef ENABLE_REMOTE
1538  	char host[PCAP_BUF_SIZE + 1];
1539  	char port[PCAP_BUF_SIZE + 1];
1540  	char name[PCAP_BUF_SIZE + 1];
1541  	int srctype;
1542  	if (device == NULL)
1543  		device = &quot;any&quot;;
1544  	if (pcap_parsesrcstr(device, &amp;srctype, host, port, name, errbuf))
1545  		return (NULL);
1546  	if (srctype == PCAP_SRC_IFREMOTE) {
1547  		return (pcap_open_rpcap(device, snaplen,
1548  		    promisc ? PCAP_OPENFLAG_PROMISCUOUS : 0, to_ms,
1549  		    NULL, errbuf));
1550  	}
1551  	if (srctype == PCAP_SRC_FILE) {
1552  		snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;unknown URL scheme \&quot;file\&quot;&quot;);
1553  		return (NULL);
1554  	}
1555  	if (srctype == PCAP_SRC_IFLOCAL) {
1556  		if (strncmp(device, PCAP_SRC_IF_STRING, strlen(PCAP_SRC_IF_STRING)) == 0) {
1557  			size_t len = strlen(device) - strlen(PCAP_SRC_IF_STRING) + 1;
1558  			if (len &gt; 0)
1559  				device += strlen(PCAP_SRC_IF_STRING);
1560  		}
1561  	}
1562  #endif	&amp;bsol;* ENABLE_REMOTE */
1563  	p = pcap_create(device, errbuf);
1564  	if (p == NULL)
1565  		return (NULL);
1566  	status = pcap_set_snaplen(p, snaplen);
1567  	if (status &lt; 0)
1568  		goto fail;
1569  	status = pcap_set_promisc(p, promisc);
1570  	if (status &lt; 0)
1571  		goto fail;
1572  	status = pcap_set_timeout(p, to_ms);
1573  	if (status &lt; 0)
1574  		goto fail;
1575  	p-&gt;oldstyle = 1;
1576  	status = pcap_activate(p);
1577  	if (status &lt; 0)
1578  		goto fail;
1579  	return (p);
1580  fail:
1581  	if (status == PCAP_ERROR) {
1582  		char trimbuf[PCAP_ERRBUF_SIZE - 5]; &amp;bsol;* 2 bytes shorter */
1583  		pcap_strlcpy(trimbuf, p-&gt;errbuf, sizeof(trimbuf));
1584  		snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;%s: %.*s&quot;, device,
1585  		    PCAP_ERRBUF_SIZE - 3, trimbuf);
1586  	} else if (status == PCAP_ERROR_NO_SUCH_DEVICE ||
1587  	    status == PCAP_ERROR_PERM_DENIED ||
1588  	    status == PCAP_ERROR_PROMISC_PERM_DENIED) {
1589  		if (p-&gt;errbuf[0] != &#x27;\0&#x27;) {
1590  			char trimbuf[PCAP_ERRBUF_SIZE - 8]; &amp;bsol;* 2 bytes shorter */
1591  			pcap_strlcpy(trimbuf, p-&gt;errbuf, sizeof(trimbuf));
1592  			snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;%s: %s (%.*s)&quot;,
1593  			    device, pcap_statustostr(status),
1594  			    PCAP_ERRBUF_SIZE - 6, trimbuf);
1595  		} else {
1596  			snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;%s: %s&quot;,
1597  			    device, pcap_statustostr(status));
1598  		}
1599  	} else {
1600  		snprintf(errbuf, PCAP_ERRBUF_SIZE, &quot;%s: %s&quot;, device,
1601  		    pcap_statustostr(status));
1602  	}
1603  	pcap_close(p);
1604  	return (NULL);
1605  }
1606  pcap_t *
1607  pcap_open_offline_common(char *ebuf, size_t total_size, size_t private_offset)
1608  {
1609  	pcap_t *p;
1610  	p = pcap_alloc_pcap_t(ebuf, total_size, private_offset);
1611  	if (p == NULL)
1612  		return (NULL);
1613  	p-&gt;opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;
1614  	return (p);
1615  }
1616  int
1617  pcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
1618  {
1619  	return (p-&gt;read_op(p, cnt, callback, user));
1620  }
1621  int
1622  pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
1623  {
1624  	register int n;
1625  	for (;;) {
1626  		if (p-&gt;rfile != NULL) {
1627  			n = pcap_offline_read(p, cnt, callback, user);
1628  		} else {
1629  			do {
1630  				n = p-&gt;read_op(p, cnt, callback, user);
1631  			} while (n == 0);
1632  		}
1633  		if (n &lt;= 0)
1634  			return (n);
1635  		if (!PACKET_COUNT_IS_UNLIMITED(cnt)) {
1636  			cnt -= n;
1637  			if (cnt &lt;= 0)
1638  				return (0);
1639  		}
1640  	}
1641  }
1642  void
1643  pcap_breakloop(pcap_t *p)
1644  {
1645  	p-&gt;breakloop_op(p);
1646  }
1647  int
1648  pcap_datalink(pcap_t *p)
1649  {
1650  	if (!p-&gt;activated)
1651  		return (PCAP_ERROR_NOT_ACTIVATED);
1652  	return (p-&gt;linktype);
1653  }
1654  int
1655  pcap_datalink_ext(pcap_t *p)
1656  {
1657  	if (!p-&gt;activated)
1658  		return (PCAP_ERROR_NOT_ACTIVATED);
1659  	return (p-&gt;linktype_ext);
1660  }
1661  int
1662  pcap_list_datalinks(pcap_t *p, int **dlt_buffer)
1663  {
1664  	if (!p-&gt;activated)
1665  		return (PCAP_ERROR_NOT_ACTIVATED);
1666  	if (p-&gt;dlt_count == 0) {
1667  		*dlt_buffer = (int*)malloc(sizeof(**dlt_buffer));
1668  		if (*dlt_buffer == NULL) {
1669  			pcap_fmt_errmsg_for_errno(p-&gt;errbuf, sizeof(p-&gt;errbuf),
1670  			    errno, &quot;malloc&quot;);
1671  			return (PCAP_ERROR);
1672  		}
1673  		**dlt_buffer = p-&gt;linktype;
1674  		return (1);
1675  	} else {
1676  		*dlt_buffer = (int*)calloc(sizeof(**dlt_buffer), p-&gt;dlt_count);
1677  		if (*dlt_buffer == NULL) {
1678  			pcap_fmt_errmsg_for_errno(p-&gt;errbuf, sizeof(p-&gt;errbuf),
1679  			    errno, &quot;malloc&quot;);
1680  			return (PCAP_ERROR);
1681  		}
1682  		(void)memcpy(*dlt_buffer, p-&gt;dlt_list,
1683  		    sizeof(**dlt_buffer) * p-&gt;dlt_count);
1684  		return (p-&gt;dlt_count);
1685  	}
1686  }
1687  void
1688  pcap_free_datalinks(int *dlt_list)
1689  {
1690  	free(dlt_list);
1691  }
1692  int
1693  pcap_set_datalink(pcap_t *p, int dlt)
1694  {
1695  	int i;
1696  	const char *dlt_name;
1697  	if (dlt &lt; 0)
1698  		goto unsupported;
1699  	if (p-&gt;dlt_count == 0 || p-&gt;set_datalink_op == NULL) {
1700  		if (p-&gt;linktype != dlt)
1701  			goto unsupported;
1702  		return (0);
1703  	}
1704  	for (i = 0; i &lt; p-&gt;dlt_count; i++)
1705  		if (p-&gt;dlt_list[i] == (u_int)dlt)
1706  			break;
1707  	if (i &gt;= p-&gt;dlt_count)
1708  		goto unsupported;
1709  	if (p-&gt;dlt_count == 2 &amp;&amp; p-&gt;dlt_list[0] == DLT_EN10MB &amp;&amp;
1710  	    dlt == DLT_DOCSIS) {
1711  		p-&gt;linktype = dlt;
1712  		return (0);
1713  	}
1714  	if (p-&gt;set_datalink_op(p, dlt) == -1)
1715  		return (-1);
1716  	p-&gt;linktype = dlt;
1717  	return (0);
1718  unsupported:
1719  	dlt_name = pcap_datalink_val_to_name(dlt);
1720  	if (dlt_name != NULL) {
1721  		(void) snprintf(p-&gt;errbuf, sizeof(p-&gt;errbuf),
1722  		    &quot;%s is not one of the DLTs supported by this device&quot;,
1723  		    dlt_name);
1724  	} else {
1725  		(void) snprintf(p-&gt;errbuf, sizeof(p-&gt;errbuf),
1726  		    &quot;DLT %d is not one of the DLTs supported by this device&quot;,
1727  		    dlt);
1728  	}
1729  	return (-1);
1730  }
1731  static const u_char charmap[] = {
1732  	(u_char)&#x27;\000&#x27;, (u_char)&#x27;\001&#x27;, (u_char)&#x27;\002&#x27;, (u_char)&#x27;\003&#x27;,
1733  	(u_char)&#x27;\004&#x27;, (u_char)&#x27;\005&#x27;, (u_char)&#x27;\006&#x27;, (u_char)&#x27;\007&#x27;,
1734  	(u_char)&#x27;\010&#x27;, (u_char)&#x27;\011&#x27;, (u_char)&#x27;\012&#x27;, (u_char)&#x27;\013&#x27;,
1735  	(u_char)&#x27;\014&#x27;, (u_char)&#x27;\015&#x27;, (u_char)&#x27;\016&#x27;, (u_char)&#x27;\017&#x27;,
1736  	(u_char)&#x27;\020&#x27;, (u_char)&#x27;\021&#x27;, (u_char)&#x27;\022&#x27;, (u_char)&#x27;\023&#x27;,
1737  	(u_char)&#x27;\024&#x27;, (u_char)&#x27;\025&#x27;, (u_char)&#x27;\026&#x27;, (u_char)&#x27;\027&#x27;,
1738  	(u_char)&#x27;\030&#x27;, (u_char)&#x27;\031&#x27;, (u_char)&#x27;\032&#x27;, (u_char)&#x27;\033&#x27;,
1739  	(u_char)&#x27;\034&#x27;, (u_char)&#x27;\035&#x27;, (u_char)&#x27;\036&#x27;, (u_char)&#x27;\037&#x27;,
1740  	(u_char)&#x27;\040&#x27;, (u_char)&#x27;\041&#x27;, (u_char)&#x27;\042&#x27;, (u_char)&#x27;\043&#x27;,
1741  	(u_char)&#x27;\044&#x27;, (u_char)&#x27;\045&#x27;, (u_char)&#x27;\046&#x27;, (u_char)&#x27;\047&#x27;,
1742  	(u_char)&#x27;\050&#x27;, (u_char)&#x27;\051&#x27;, (u_char)&#x27;\052&#x27;, (u_char)&#x27;\053&#x27;,
1743  	(u_char)&#x27;\054&#x27;, (u_char)&#x27;\055&#x27;, (u_char)&#x27;\056&#x27;, (u_char)&#x27;\057&#x27;,
1744  	(u_char)&#x27;\060&#x27;, (u_char)&#x27;\061&#x27;, (u_char)&#x27;\062&#x27;, (u_char)&#x27;\063&#x27;,
1745  	(u_char)&#x27;\064&#x27;, (u_char)&#x27;\065&#x27;, (u_char)&#x27;\066&#x27;, (u_char)&#x27;\067&#x27;,
1746  	(u_char)&#x27;\070&#x27;, (u_char)&#x27;\071&#x27;, (u_char)&#x27;\072&#x27;, (u_char)&#x27;\073&#x27;,
1747  	(u_char)&#x27;\074&#x27;, (u_char)&#x27;\075&#x27;, (u_char)&#x27;\076&#x27;, (u_char)&#x27;\077&#x27;,
1748  	(u_char)&#x27;\100&#x27;, (u_char)&#x27;\141&#x27;, (u_char)&#x27;\142&#x27;, (u_char)&#x27;\143&#x27;,
1749  	(u_char)&#x27;\144&#x27;, (u_char)&#x27;\145&#x27;, (u_char)&#x27;\146&#x27;, (u_char)&#x27;\147&#x27;,
1750  	(u_char)&#x27;\150&#x27;, (u_char)&#x27;\151&#x27;, (u_char)&#x27;\152&#x27;, (u_char)&#x27;\153&#x27;,
1751  	(u_char)&#x27;\154&#x27;, (u_char)&#x27;\155&#x27;, (u_char)&#x27;\156&#x27;, (u_char)&#x27;\157&#x27;,
1752  	(u_char)&#x27;\160&#x27;, (u_char)&#x27;\161&#x27;, (u_char)&#x27;\162&#x27;, (u_char)&#x27;\163&#x27;,
1753  	(u_char)&#x27;\164&#x27;, (u_char)&#x27;\165&#x27;, (u_char)&#x27;\166&#x27;, (u_char)&#x27;\167&#x27;,
1754  	(u_char)&#x27;\170&#x27;, (u_char)&#x27;\171&#x27;, (u_char)&#x27;\172&#x27;, (u_char)&#x27;\133&#x27;,
1755  	(u_char)&#x27;\134&#x27;, (u_char)&#x27;\135&#x27;, (u_char)&#x27;\136&#x27;, (u_char)&#x27;\137&#x27;,
1756  	(u_char)&#x27;\140&#x27;, (u_char)&#x27;\141&#x27;, (u_char)&#x27;\142&#x27;, (u_char)&#x27;\143&#x27;,
1757  	(u_char)&#x27;\144&#x27;, (u_char)&#x27;\145&#x27;, (u_char)&#x27;\146&#x27;, (u_char)&#x27;\147&#x27;,
1758  	(u_char)&#x27;\150&#x27;, (u_char)&#x27;\151&#x27;, (u_char)&#x27;\152&#x27;, (u_char)&#x27;\153&#x27;,
1759  	(u_char)&#x27;\154&#x27;, (u_char)&#x27;\155&#x27;, (u_char)&#x27;\156&#x27;, (u_char)&#x27;\157&#x27;,
1760  	(u_char)&#x27;\160&#x27;, (u_char)&#x27;\161&#x27;, (u_char)&#x27;\162&#x27;, (u_char)&#x27;\163&#x27;,
1761  	(u_char)&#x27;\164&#x27;, (u_char)&#x27;\165&#x27;, (u_char)&#x27;\166&#x27;, (u_char)&#x27;\167&#x27;,
1762  	(u_char)&#x27;\170&#x27;, (u_char)&#x27;\171&#x27;, (u_char)&#x27;\172&#x27;, (u_char)&#x27;\173&#x27;,
1763  	(u_char)&#x27;\174&#x27;, (u_char)&#x27;\175&#x27;, (u_char)&#x27;\176&#x27;, (u_char)&#x27;\177&#x27;,
1764  	(u_char)&#x27;\200&#x27;, (u_char)&#x27;\201&#x27;, (u_char)&#x27;\202&#x27;, (u_char)&#x27;\203&#x27;,
1765  	(u_char)&#x27;\204&#x27;, (u_char)&#x27;\205&#x27;, (u_char)&#x27;\206&#x27;, (u_char)&#x27;\207&#x27;,
1766  	(u_char)&#x27;\210&#x27;, (u_char)&#x27;\211&#x27;, (u_char)&#x27;\212&#x27;, (u_char)&#x27;\213&#x27;,
1767  	(u_char)&#x27;\214&#x27;, (u_char)&#x27;\215&#x27;, (u_char)&#x27;\216&#x27;, (u_char)&#x27;\217&#x27;,
1768  	(u_char)&#x27;\220&#x27;, (u_char)&#x27;\221&#x27;, (u_char)&#x27;\222&#x27;, (u_char)&#x27;\223&#x27;,
1769  	(u_char)&#x27;\224&#x27;, (u_char)&#x27;\225&#x27;, (u_char)&#x27;\226&#x27;, (u_char)&#x27;\227&#x27;,
1770  	(u_char)&#x27;\230&#x27;, (u_char)&#x27;\231&#x27;, (u_char)&#x27;\232&#x27;, (u_char)&#x27;\233&#x27;,
1771  	(u_char)&#x27;\234&#x27;, (u_char)&#x27;\235&#x27;, (u_char)&#x27;\236&#x27;, (u_char)&#x27;\237&#x27;,
1772  	(u_char)&#x27;\240&#x27;, (u_char)&#x27;\241&#x27;, (u_char)&#x27;\242&#x27;, (u_char)&#x27;\243&#x27;,
1773  	(u_char)&#x27;\244&#x27;, (u_char)&#x27;\245&#x27;, (u_char)&#x27;\246&#x27;, (u_char)&#x27;\247&#x27;,
1774  	(u_char)&#x27;\250&#x27;, (u_char)&#x27;\251&#x27;, (u_char)&#x27;\252&#x27;, (u_char)&#x27;\253&#x27;,
1775  	(u_char)&#x27;\254&#x27;, (u_char)&#x27;\255&#x27;, (u_char)&#x27;\256&#x27;, (u_char)&#x27;\257&#x27;,
1776  	(u_char)&#x27;\260&#x27;, (u_char)&#x27;\261&#x27;, (u_char)&#x27;\262&#x27;, (u_char)&#x27;\263&#x27;,
1777  	(u_char)&#x27;\264&#x27;, (u_char)&#x27;\265&#x27;, (u_char)&#x27;\266&#x27;, (u_char)&#x27;\267&#x27;,
1778  	(u_char)&#x27;\270&#x27;, (u_char)&#x27;\271&#x27;, (u_char)&#x27;\272&#x27;, (u_char)&#x27;\273&#x27;,
1779  	(u_char)&#x27;\274&#x27;, (u_char)&#x27;\275&#x27;, (u_char)&#x27;\276&#x27;, (u_char)&#x27;\277&#x27;,
1780  	(u_char)&#x27;\300&#x27;, (u_char)&#x27;\341&#x27;, (u_char)&#x27;\342&#x27;, (u_char)&#x27;\343&#x27;,
1781  	(u_char)&#x27;\344&#x27;, (u_char)&#x27;\345&#x27;, (u_char)&#x27;\346&#x27;, (u_char)&#x27;\347&#x27;,
1782  	(u_char)&#x27;\350&#x27;, (u_char)&#x27;\351&#x27;, (u_char)&#x27;\352&#x27;, (u_char)&#x27;\353&#x27;,
1783  	(u_char)&#x27;\354&#x27;, (u_char)&#x27;\355&#x27;, (u_char)&#x27;\356&#x27;, (u_char)&#x27;\357&#x27;,
1784  	(u_char)&#x27;\360&#x27;, (u_char)&#x27;\361&#x27;, (u_char)&#x27;\362&#x27;, (u_char)&#x27;\363&#x27;,
1785  	(u_char)&#x27;\364&#x27;, (u_char)&#x27;\365&#x27;, (u_char)&#x27;\366&#x27;, (u_char)&#x27;\367&#x27;,
1786  	(u_char)&#x27;\370&#x27;, (u_char)&#x27;\371&#x27;, (u_char)&#x27;\372&#x27;, (u_char)&#x27;\333&#x27;,
1787  	(u_char)&#x27;\334&#x27;, (u_char)&#x27;\335&#x27;, (u_char)&#x27;\336&#x27;, (u_char)&#x27;\337&#x27;,
1788  	(u_char)&#x27;\340&#x27;, (u_char)&#x27;\341&#x27;, (u_char)&#x27;\342&#x27;, (u_char)&#x27;\343&#x27;,
1789  	(u_char)&#x27;\344&#x27;, (u_char)&#x27;\345&#x27;, (u_char)&#x27;\346&#x27;, (u_char)&#x27;\347&#x27;,
1790  	(u_char)&#x27;\350&#x27;, (u_char)&#x27;\351&#x27;, (u_char)&#x27;\352&#x27;, (u_char)&#x27;\353&#x27;,
1791  	(u_char)&#x27;\354&#x27;, (u_char)&#x27;\355&#x27;, (u_char)&#x27;\356&#x27;, (u_char)&#x27;\357&#x27;,
1792  	(u_char)&#x27;\360&#x27;, (u_char)&#x27;\361&#x27;, (u_char)&#x27;\362&#x27;, (u_char)&#x27;\363&#x27;,
1793  	(u_char)&#x27;\364&#x27;, (u_char)&#x27;\365&#x27;, (u_char)&#x27;\366&#x27;, (u_char)&#x27;\367&#x27;,
1794  	(u_char)&#x27;\370&#x27;, (u_char)&#x27;\371&#x27;, (u_char)&#x27;\372&#x27;, (u_char)&#x27;\373&#x27;,
1795  	(u_char)&#x27;\374&#x27;, (u_char)&#x27;\375&#x27;, (u_char)&#x27;\376&#x27;, (u_char)&#x27;\377&#x27;,
1796  };
1797  int
1798  pcap_strcasecmp(const char *s1, const char *s2)
1799  {
1800  	register const u_char	*cm = charmap,
1801  				*us1 = (const u_char *)s1,
1802  				*us2 = (const u_char *)s2;
1803  	while (cm[*us1] == cm[*us2++])
1804  		if (*us1++ == &#x27;\0&#x27;)
1805  			return(0);
1806  	return (cm[*us1] - cm[*--us2]);
1807  }
1808  struct dlt_choice {
1809  	const char *name;
1810  	const char *description;
1811  	int	dlt;
1812  };
1813  #define DLT_CHOICE(code, description) { #code, description, DLT_ ## code }
1814  #define DLT_CHOICE_SENTINEL { NULL, NULL, 0 }
1815  static struct dlt_choice dlt_choices[] = {
1816  	DLT_CHOICE(NULL, &quot;BSD loopback&quot;),
1817  	DLT_CHOICE(EN10MB, &quot;Ethernet&quot;),
1818  	DLT_CHOICE(IEEE802, &quot;Token ring&quot;),
1819  	DLT_CHOICE(ARCNET, &quot;BSD ARCNET&quot;),
1820  	DLT_CHOICE(SLIP, &quot;SLIP&quot;),
1821  	DLT_CHOICE(PPP, &quot;PPP&quot;),
1822  	DLT_CHOICE(FDDI, &quot;FDDI&quot;),
1823  	DLT_CHOICE(ATM_RFC1483, &quot;RFC 1483 LLC-encapsulated ATM&quot;),
1824  	DLT_CHOICE(RAW, &quot;Raw IP&quot;),
1825  	DLT_CHOICE(SLIP_BSDOS, &quot;BSD/OS SLIP&quot;),
1826  	DLT_CHOICE(PPP_BSDOS, &quot;BSD/OS PPP&quot;),
1827  	DLT_CHOICE(ATM_CLIP, &quot;Linux Classical IP over ATM&quot;),
1828  	DLT_CHOICE(PPP_SERIAL, &quot;PPP over serial&quot;),
1829  	DLT_CHOICE(PPP_ETHER, &quot;PPPoE&quot;),
1830  	DLT_CHOICE(SYMANTEC_FIREWALL, &quot;Symantec Firewall&quot;),
1831  	DLT_CHOICE(C_HDLC, &quot;Cisco HDLC&quot;),
1832  	DLT_CHOICE(IEEE802_11, &quot;802.11&quot;),
1833  	DLT_CHOICE(FRELAY, &quot;Frame Relay&quot;),
1834  	DLT_CHOICE(LOOP, &quot;OpenBSD loopback&quot;),
1835  	DLT_CHOICE(ENC, &quot;OpenBSD encapsulated IP&quot;),
1836  	DLT_CHOICE(LINUX_SLL, &quot;Linux cooked v1&quot;),
1837  	DLT_CHOICE(LTALK, &quot;Localtalk&quot;),
1838  	DLT_CHOICE(PFLOG, &quot;OpenBSD pflog file&quot;),
1839  	DLT_CHOICE(PFSYNC, &quot;Packet filter state syncing&quot;),
1840  	DLT_CHOICE(PRISM_HEADER, &quot;802.11 plus Prism header&quot;),
1841  	DLT_CHOICE(IP_OVER_FC, &quot;RFC 2625 IP-over-Fibre Channel&quot;),
1842  	DLT_CHOICE(SUNATM, &quot;Sun raw ATM&quot;),
1843  	DLT_CHOICE(IEEE802_11_RADIO, &quot;802.11 plus radiotap header&quot;),
1844  	DLT_CHOICE(ARCNET_LINUX, &quot;Linux ARCNET&quot;),
1845  	DLT_CHOICE(JUNIPER_MLPPP, &quot;Juniper Multi-Link PPP&quot;),
1846  	DLT_CHOICE(JUNIPER_MLFR, &quot;Juniper Multi-Link Frame Relay&quot;),
1847  	DLT_CHOICE(JUNIPER_ES, &quot;Juniper Encryption Services PIC&quot;),
1848  	DLT_CHOICE(JUNIPER_GGSN, &quot;Juniper GGSN PIC&quot;),
1849  	DLT_CHOICE(JUNIPER_MFR, &quot;Juniper FRF.16 Frame Relay&quot;),
1850  	DLT_CHOICE(JUNIPER_ATM2, &quot;Juniper ATM2 PIC&quot;),
1851  	DLT_CHOICE(JUNIPER_SERVICES, &quot;Juniper Advanced Services PIC&quot;),
1852  	DLT_CHOICE(JUNIPER_ATM1, &quot;Juniper ATM1 PIC&quot;),
1853  	DLT_CHOICE(APPLE_IP_OVER_IEEE1394, &quot;Apple IP-over-IEEE 1394&quot;),
1854  	DLT_CHOICE(MTP2_WITH_PHDR, &quot;SS7 MTP2 with Pseudo-header&quot;),
1855  	DLT_CHOICE(MTP2, &quot;SS7 MTP2&quot;),
1856  	DLT_CHOICE(MTP3, &quot;SS7 MTP3&quot;),
1857  	DLT_CHOICE(SCCP, &quot;SS7 SCCP&quot;),
1858  	DLT_CHOICE(DOCSIS, &quot;DOCSIS&quot;),
1859  	DLT_CHOICE(LINUX_IRDA, &quot;Linux IrDA&quot;),
1860  	DLT_CHOICE(IEEE802_11_RADIO_AVS, &quot;802.11 plus AVS radio information header&quot;),
1861  	DLT_CHOICE(JUNIPER_MONITOR, &quot;Juniper Passive Monitor PIC&quot;),
1862  	DLT_CHOICE(BACNET_MS_TP, &quot;BACnet MS/TP&quot;),
1863  	DLT_CHOICE(PPP_PPPD, &quot;PPP for pppd, with direction flag&quot;),
1864  	DLT_CHOICE(JUNIPER_PPPOE, &quot;Juniper PPPoE&quot;),
1865  	DLT_CHOICE(JUNIPER_PPPOE_ATM, &quot;Juniper PPPoE/ATM&quot;),
1866  	DLT_CHOICE(GPRS_LLC, &quot;GPRS LLC&quot;),
1867  	DLT_CHOICE(GPF_T, &quot;GPF-T&quot;),
1868  	DLT_CHOICE(GPF_F, &quot;GPF-F&quot;),
1869  	DLT_CHOICE(JUNIPER_PIC_PEER, &quot;Juniper PIC Peer&quot;),
1870  	DLT_CHOICE(ERF_ETH, &quot;Ethernet with Endace ERF header&quot;),
1871  	DLT_CHOICE(ERF_POS, &quot;Packet-over-SONET with Endace ERF header&quot;),
1872  	DLT_CHOICE(LINUX_LAPD, &quot;Linux vISDN LAPD&quot;),
1873  	DLT_CHOICE(JUNIPER_ETHER, &quot;Juniper Ethernet&quot;),
1874  	DLT_CHOICE(JUNIPER_PPP, &quot;Juniper PPP&quot;),
1875  	DLT_CHOICE(JUNIPER_FRELAY, &quot;Juniper Frame Relay&quot;),
1876  	DLT_CHOICE(JUNIPER_CHDLC, &quot;Juniper C-HDLC&quot;),
1877  	DLT_CHOICE(MFR, &quot;FRF.16 Frame Relay&quot;),
1878  	DLT_CHOICE(JUNIPER_VP, &quot;Juniper Voice PIC&quot;),
1879  	DLT_CHOICE(A429, &quot;Arinc 429&quot;),
1880  	DLT_CHOICE(A653_ICM, &quot;Arinc 653 Interpartition Communication&quot;),
1881  	DLT_CHOICE(USB_FREEBSD, &quot;USB with FreeBSD header&quot;),
1882  	DLT_CHOICE(BLUETOOTH_HCI_H4, &quot;Bluetooth HCI UART transport layer&quot;),
1883  	DLT_CHOICE(IEEE802_16_MAC_CPS, &quot;IEEE 802.16 MAC Common Part Sublayer&quot;),
1884  	DLT_CHOICE(USB_LINUX, &quot;USB with Linux header&quot;),
1885  	DLT_CHOICE(CAN20B, &quot;Controller Area Network (CAN) v. 2.0B&quot;),
1886  	DLT_CHOICE(IEEE802_15_4_LINUX, &quot;IEEE 802.15.4 with Linux padding&quot;),
1887  	DLT_CHOICE(PPI, &quot;Per-Packet Information&quot;),
1888  	DLT_CHOICE(IEEE802_16_MAC_CPS_RADIO, &quot;IEEE 802.16 MAC Common Part Sublayer plus radiotap header&quot;),
1889  	DLT_CHOICE(JUNIPER_ISM, &quot;Juniper Integrated Service Module&quot;),
1890  	DLT_CHOICE(IEEE802_15_4, &quot;IEEE 802.15.4 with FCS&quot;),
1891  	DLT_CHOICE(SITA, &quot;SITA pseudo-header&quot;),
1892  	DLT_CHOICE(ERF, &quot;Endace ERF header&quot;),
1893  	DLT_CHOICE(RAIF1, &quot;Ethernet with u10 Networks pseudo-header&quot;),
1894  	DLT_CHOICE(IPMB_KONTRON, &quot;IPMB with Kontron pseudo-header&quot;),
1895  	DLT_CHOICE(JUNIPER_ST, &quot;Juniper Secure Tunnel&quot;),
1896  	DLT_CHOICE(BLUETOOTH_HCI_H4_WITH_PHDR, &quot;Bluetooth HCI UART transport layer plus pseudo-header&quot;),
1897  	DLT_CHOICE(AX25_KISS, &quot;AX.25 with KISS header&quot;),
1898  	DLT_CHOICE(IPMB_LINUX, &quot;IPMB with Linux/Pigeon Point pseudo-header&quot;),
1899  	DLT_CHOICE(IEEE802_15_4_NONASK_PHY, &quot;IEEE 802.15.4 with non-ASK PHY data&quot;),
1900  	DLT_CHOICE(MPLS, &quot;MPLS with label as link-layer header&quot;),
1901  	DLT_CHOICE(LINUX_EVDEV, &quot;Linux evdev events&quot;),
1902  	DLT_CHOICE(USB_LINUX_MMAPPED, &quot;USB with padded Linux header&quot;),
1903  	DLT_CHOICE(DECT, &quot;DECT&quot;),
1904  	DLT_CHOICE(AOS, &quot;AOS Space Data Link protocol&quot;),
1905  	DLT_CHOICE(WIHART, &quot;WirelessHART&quot;),
1906  	DLT_CHOICE(FC_2, &quot;Fibre Channel FC-2&quot;),
1907  	DLT_CHOICE(FC_2_WITH_FRAME_DELIMS, &quot;Fibre Channel FC-2 with frame delimiters&quot;),
1908  	DLT_CHOICE(IPNET, &quot;Solaris ipnet&quot;),
1909  	DLT_CHOICE(CAN_SOCKETCAN, &quot;CAN-bus with SocketCAN headers&quot;),
1910  	DLT_CHOICE(IPV4, &quot;Raw IPv4&quot;),
1911  	DLT_CHOICE(IPV6, &quot;Raw IPv6&quot;),
1912  	DLT_CHOICE(IEEE802_15_4_NOFCS, &quot;IEEE 802.15.4 without FCS&quot;),
1913  	DLT_CHOICE(DBUS, &quot;D-Bus&quot;),
1914  	DLT_CHOICE(JUNIPER_VS, &quot;Juniper Virtual Server&quot;),
1915  	DLT_CHOICE(JUNIPER_SRX_E2E, &quot;Juniper SRX E2E&quot;),
1916  	DLT_CHOICE(JUNIPER_FIBRECHANNEL, &quot;Juniper Fibre Channel&quot;),
1917  	DLT_CHOICE(DVB_CI, &quot;DVB-CI&quot;),
1918  	DLT_CHOICE(MUX27010, &quot;MUX27010&quot;),
1919  	DLT_CHOICE(STANAG_5066_D_PDU, &quot;STANAG 5066 D_PDUs&quot;),
1920  	DLT_CHOICE(JUNIPER_ATM_CEMIC, &quot;Juniper ATM CEMIC&quot;),
1921  	DLT_CHOICE(NFLOG, &quot;Linux netfilter log messages&quot;),
1922  	DLT_CHOICE(NETANALYZER, &quot;Ethernet with Hilscher netANALYZER pseudo-header&quot;),
1923  	DLT_CHOICE(NETANALYZER_TRANSPARENT, &quot;Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD&quot;),
1924  	DLT_CHOICE(IPOIB, &quot;RFC 4391 IP-over-Infiniband&quot;),
1925  	DLT_CHOICE(MPEG_2_TS, &quot;MPEG-2 transport stream&quot;),
1926  	DLT_CHOICE(NG40, &quot;ng40 protocol tester Iub/Iur&quot;),
1927  	DLT_CHOICE(NFC_LLCP, &quot;NFC LLCP PDUs with pseudo-header&quot;),
1928  	DLT_CHOICE(INFINIBAND, &quot;InfiniBand&quot;),
1929  	DLT_CHOICE(SCTP, &quot;SCTP&quot;),
1930  	DLT_CHOICE(USBPCAP, &quot;USB with USBPcap header&quot;),
1931  	DLT_CHOICE(RTAC_SERIAL, &quot;Schweitzer Engineering Laboratories RTAC packets&quot;),
1932  	DLT_CHOICE(BLUETOOTH_LE_LL, &quot;Bluetooth Low Energy air interface&quot;),
1933  	DLT_CHOICE(NETLINK, &quot;Linux netlink&quot;),
1934  	DLT_CHOICE(BLUETOOTH_LINUX_MONITOR, &quot;Bluetooth Linux Monitor&quot;),
1935  	DLT_CHOICE(BLUETOOTH_BREDR_BB, &quot;Bluetooth Basic Rate/Enhanced Data Rate baseband packets&quot;),
1936  	DLT_CHOICE(BLUETOOTH_LE_LL_WITH_PHDR, &quot;Bluetooth Low Energy air interface with pseudo-header&quot;),
1937  	DLT_CHOICE(PROFIBUS_DL, &quot;PROFIBUS data link layer&quot;),
1938  	DLT_CHOICE(PKTAP, &quot;Apple DLT_PKTAP&quot;),
1939  	DLT_CHOICE(EPON, &quot;Ethernet with 802.3 Clause 65 EPON preamble&quot;),
1940  	DLT_CHOICE(IPMI_HPM_2, &quot;IPMI trace packets&quot;),
1941  	DLT_CHOICE(ZWAVE_R1_R2, &quot;Z-Wave RF profile R1 and R2 packets&quot;),
1942  	DLT_CHOICE(ZWAVE_R3, &quot;Z-Wave RF profile R3 packets&quot;),
1943  	DLT_CHOICE(WATTSTOPPER_DLM, &quot;WattStopper Digital Lighting Management (DLM) and Legrand Nitoo Open protocol&quot;),
1944  	DLT_CHOICE(ISO_14443, &quot;ISO 14443 messages&quot;),
1945  	DLT_CHOICE(RDS, &quot;IEC 62106 Radio Data System groups&quot;),
1946  	DLT_CHOICE(USB_DARWIN, &quot;USB with Darwin header&quot;),
1947  	DLT_CHOICE(OPENFLOW, &quot;OpenBSD DLT_OPENFLOW&quot;),
1948  	DLT_CHOICE(SDLC, &quot;IBM SDLC frames&quot;),
1949  	DLT_CHOICE(TI_LLN_SNIFFER, &quot;TI LLN sniffer frames&quot;),
1950  	DLT_CHOICE(VSOCK, &quot;Linux vsock&quot;),
1951  	DLT_CHOICE(NORDIC_BLE, &quot;Nordic Semiconductor Bluetooth LE sniffer frames&quot;),
1952  	DLT_CHOICE(DOCSIS31_XRA31, &quot;Excentis XRA-31 DOCSIS 3.1 RF sniffer frames&quot;),
1953  	DLT_CHOICE(ETHERNET_MPACKET, &quot;802.3br mPackets&quot;),
1954  	DLT_CHOICE(DISPLAYPORT_AUX, &quot;DisplayPort AUX channel monitoring data&quot;),
1955  	DLT_CHOICE(LINUX_SLL2, &quot;Linux cooked v2&quot;),
1956  	DLT_CHOICE(OPENVIZSLA, &quot;OpenVizsla USB&quot;),
1957  	DLT_CHOICE(EBHSCR, &quot;Elektrobit High Speed Capture and Replay (EBHSCR)&quot;),
1958  	DLT_CHOICE(VPP_DISPATCH, &quot;VPP graph dispatch tracer&quot;),
1959  	DLT_CHOICE(DSA_TAG_BRCM, &quot;Broadcom tag&quot;),
1960  	DLT_CHOICE(DSA_TAG_BRCM_PREPEND, &quot;Broadcom tag (prepended)&quot;),
1961  	DLT_CHOICE(IEEE802_15_4_TAP, &quot;IEEE 802.15.4 with pseudo-header&quot;),
1962  	DLT_CHOICE(DSA_TAG_DSA, &quot;Marvell DSA&quot;),
1963  	DLT_CHOICE(DSA_TAG_EDSA, &quot;Marvell EDSA&quot;),
1964  	DLT_CHOICE(ELEE, &quot;ELEE lawful intercept packets&quot;),
1965  	DLT_CHOICE(Z_WAVE_SERIAL, &quot;Z-Wave serial frames between host and chip&quot;),
1966  	DLT_CHOICE(USB_2_0, &quot;USB 2.0/1.1/1.0 as transmitted over the cable&quot;),
1967  	DLT_CHOICE(ATSC_ALP, &quot;ATSC Link-Layer Protocol packets&quot;),
1968  	DLT_CHOICE(ETW, &quot;Event Tracing for Windows messages&quot;),
1969  	DLT_CHOICE(NETANALYZER_NG, &quot;Hilscher netANALYZER NG pseudo-footer&quot;),
1970  	DLT_CHOICE(ZBOSS_NCP, &quot;ZBOSS NCP protocol with pseudo-header&quot;),
1971  	DLT_CHOICE(USB_2_0_LOW_SPEED, &quot;Low-Speed USB 2.0/1.1/1.0 as transmitted over the cable&quot;),
1972  	DLT_CHOICE(USB_2_0_FULL_SPEED, &quot;Full-Speed USB 2.0/1.1/1.0 as transmitted over the cable&quot;),
1973  	DLT_CHOICE(USB_2_0_HIGH_SPEED, &quot;High-Speed USB 2.0 as transmitted over the cable&quot;),
1974  	DLT_CHOICE(AUERSWALD_LOG, &quot;Auerswald Logger Protocol&quot;),
1975  	DLT_CHOICE(ZWAVE_TAP, &quot;Z-Wave packets with a TAP meta-data header&quot;),
1976  	DLT_CHOICE(SILABS_DEBUG_CHANNEL, &quot;Silicon Labs debug channel protocol&quot;),
1977  	DLT_CHOICE(FIRA_UCI, &quot;Ultra-wideband controller interface protocol&quot;),
1978  	DLT_CHOICE_SENTINEL
1979  };
1980  int
1981  pcap_datalink_name_to_val(const char *name)
1982  {
1983  	int i;
1984  	for (i = 0; dlt_choices[i].name != NULL; i++) {
1985  		if (pcap_strcasecmp(dlt_choices[i].name, name) == 0)
1986  			return (dlt_choices[i].dlt);
1987  	}
1988  	return (-1);
1989  }
1990  const char *
1991  pcap_datalink_val_to_name(int dlt)
1992  {
1993  	int i;
1994  	for (i = 0; dlt_choices[i].name != NULL; i++) {
1995  		if (dlt_choices[i].dlt == dlt)
1996  			return (dlt_choices[i].name);
1997  	}
1998  	return (NULL);
1999  }
2000  const char *
2001  pcap_datalink_val_to_description(int dlt)
2002  {
2003  	int i;
2004  	for (i = 0; dlt_choices[i].name != NULL; i++) {
2005  		if (dlt_choices[i].dlt == dlt)
2006  			return (dlt_choices[i].description);
2007  	}
2008  	return (NULL);
2009  }
2010  const char *
2011  pcap_datalink_val_to_description_or_dlt(int dlt)
2012  {
2013          static thread_local char unkbuf[40];
2014          const char *description;
2015          description = pcap_datalink_val_to_description(dlt);
2016          if (description != NULL) {
2017                  return description;
2018          } else {
2019                  (void)snprintf(unkbuf, sizeof(unkbuf), &quot;DLT %d&quot;, dlt);
2020                  return unkbuf;
2021          }
2022  }
2023  struct tstamp_type_choice {
2024  	const char *name;
2025  	const char *description;
2026  	int	type;
2027  };
2028  static struct tstamp_type_choice tstamp_type_choices[] = {
2029  	{ &quot;host&quot;, &quot;Host&quot;, PCAP_TSTAMP_HOST },
2030  	{ &quot;host_lowprec&quot;, &quot;Host, low precision&quot;, PCAP_TSTAMP_HOST_LOWPREC },
2031  	{ &quot;host_hiprec&quot;, &quot;Host, high precision&quot;, PCAP_TSTAMP_HOST_HIPREC },
2032  	{ &quot;adapter&quot;, &quot;Adapter&quot;, PCAP_TSTAMP_ADAPTER },
2033  	{ &quot;adapter_unsynced&quot;, &quot;Adapter, not synced with system time&quot;, PCAP_TSTAMP_ADAPTER_UNSYNCED },
2034  	{ &quot;host_hiprec_unsynced&quot;, &quot;Host, high precision, not synced with system time&quot;, PCAP_TSTAMP_HOST_HIPREC_UNSYNCED },
2035  	{ NULL, NULL, 0 }
2036  };
2037  int
2038  pcap_tstamp_type_name_to_val(const char *name)
2039  {
2040  	int i;
2041  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2042  		if (pcap_strcasecmp(tstamp_type_choices[i].name, name) == 0)
2043  			return (tstamp_type_choices[i].type);
2044  	}
2045  	return (PCAP_ERROR);
2046  }
2047  const char *
2048  pcap_tstamp_type_val_to_name(int tstamp_type)
2049  {
2050  	int i;
2051  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2052  		if (tstamp_type_choices[i].type == tstamp_type)
2053  			return (tstamp_type_choices[i].name);
2054  	}
2055  	return (NULL);
2056  }
2057  const char *
2058  pcap_tstamp_type_val_to_description(int tstamp_type)
2059  {
2060  	int i;
2061  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2062  		if (tstamp_type_choices[i].type == tstamp_type)
2063  			return (tstamp_type_choices[i].description);
2064  	}
2065  	return (NULL);
2066  }
2067  int
2068  pcap_snapshot(pcap_t *p)
2069  {
2070  	if (!p-&gt;activated)
2071  		return (PCAP_ERROR_NOT_ACTIVATED);
2072  	return (p-&gt;snapshot);
2073  }
2074  int
2075  pcap_is_swapped(pcap_t *p)
2076  {
2077  	if (!p-&gt;activated)
2078  		return (PCAP_ERROR_NOT_ACTIVATED);
2079  	return (p-&gt;swapped);
2080  }
2081  int
2082  pcap_major_version(pcap_t *p)
2083  {
2084  	if (!p-&gt;activated)
2085  		return (PCAP_ERROR_NOT_ACTIVATED);
2086  	return (p-&gt;version_major);
2087  }
2088  int
2089  pcap_minor_version(pcap_t *p)
2090  {
2091  	if (!p-&gt;activated)
2092  		return (PCAP_ERROR_NOT_ACTIVATED);
2093  	return (p-&gt;version_minor);
2094  }
2095  int
2096  pcap_bufsize(pcap_t *p)
2097  {
2098  	if (!p-&gt;activated)
2099  		return (PCAP_ERROR_NOT_ACTIVATED);
2100  	return (p-&gt;bufsize);
2101  }
2102  FILE *
2103  pcap_file(pcap_t *p)
2104  {
2105  	return (p-&gt;rfile);
2106  }
2107  #ifdef _WIN32
2108  int
2109  pcap_fileno(pcap_t *p)
2110  {
2111  	if (p-&gt;handle != INVALID_HANDLE_VALUE) {
2112  DIAG_OFF_NARROWING
2113  		return ((int)(intptr_t)p-&gt;handle);
2114  DIAG_ON_NARROWING
2115  	} else
2116  		return (PCAP_ERROR);
2117  }
2118  #else &amp;bsol;* _WIN32 */
2119  int
2120  pcap_fileno(pcap_t *p)
2121  {
2122  	return (p-&gt;fd);
2123  }
2124  #endif &amp;bsol;* _WIN32 */
2125  #if !defined(_WIN32) &amp;&amp; !defined(MSDOS)
2126  int
2127  pcap_get_selectable_fd(pcap_t *p)
2128  {
2129  	return (p-&gt;selectable_fd);
2130  }
2131  const struct timeval *
2132  pcap_get_required_select_timeout(pcap_t *p)
2133  {
2134  	return (p-&gt;required_select_timeout);
2135  }
2136  #endif
2137  void
2138  pcap_perror(pcap_t *p, const char *prefix)
2139  {
2140  	fprintf(stderr, &quot;%s: %s\n&quot;, prefix, p-&gt;errbuf);
2141  }
2142  char *
2143  pcap_geterr(pcap_t *p)
2144  {
2145  	return (p-&gt;errbuf);
2146  }
2147  int
2148  pcap_getnonblock(pcap_t *p, char *errbuf)
2149  {
2150  	int ret;
2151  	ret = p-&gt;getnonblock_op(p);
2152  	if (ret == -1) {
2153  		pcap_strlcpy(errbuf, p-&gt;errbuf, PCAP_ERRBUF_SIZE);
2154  	}
2155  	return (ret);
2156  }
2157  #if !defined(_WIN32) &amp;&amp; !defined(MSDOS)
2158  int
2159  pcap_getnonblock_fd(pcap_t *p)
2160  {
2161  	int fdflags;
2162  	fdflags = fcntl(p-&gt;fd, F_GETFL, 0);
2163  	if (fdflags == -1) {
2164  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2165  		    errno, &quot;F_GETFL&quot;);
2166  		return (-1);
2167  	}
2168  	if (fdflags &amp; O_NONBLOCK)
2169  		return (1);
2170  	else
2171  		return (0);
2172  }
2173  #endif
2174  int
2175  pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)
2176  {
2177  	int ret;
2178  	ret = p-&gt;setnonblock_op(p, nonblock);
2179  	if (ret == -1) {
2180  		pcap_strlcpy(errbuf, p-&gt;errbuf, PCAP_ERRBUF_SIZE);
2181  	}
2182  	return (ret);
2183  }
2184  #if !defined(_WIN32) &amp;&amp; !defined(MSDOS)
2185  int
2186  pcap_setnonblock_fd(pcap_t *p, int nonblock)
2187  {
2188  	int fdflags;
2189  	fdflags = fcntl(p-&gt;fd, F_GETFL, 0);
2190  	if (fdflags == -1) {
2191  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2192  		    errno, &quot;F_GETFL&quot;);
2193  		return (-1);
2194  	}
2195  	if (nonblock)
2196  		fdflags |= O_NONBLOCK;
2197  	else
2198  		fdflags &amp;= ~O_NONBLOCK;
2199  	if (fcntl(p-&gt;fd, F_SETFL, fdflags) == -1) {
2200  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2201  		    errno, &quot;F_SETFL&quot;);
2202  		return (-1);
2203  	}
2204  	return (0);
2205  }
2206  #endif
2207  const char *
2208  pcap_statustostr(int errnum)
2209  {
2210  	static thread_local char ebuf[15+10+1];
2211  	switch (errnum) {
2212  	case PCAP_WARNING:
2213  		return(&quot;Generic warning&quot;);
2214  	case PCAP_WARNING_TSTAMP_TYPE_NOTSUP:
2215  		return (&quot;That type of time stamp is not supported by that device&quot;);
2216  	case PCAP_WARNING_PROMISC_NOTSUP:
2217  		return (&quot;That device doesn&#x27;t support promiscuous mode&quot;);
2218  	case PCAP_ERROR:
2219  		return(&quot;Generic error&quot;);
2220  	case PCAP_ERROR_BREAK:
2221  		return(&quot;Loop terminated by pcap_breakloop&quot;);
2222  	case PCAP_ERROR_NOT_ACTIVATED:
2223  		return(&quot;The pcap_t has not been activated&quot;);
2224  	case PCAP_ERROR_ACTIVATED:
2225  		return (&quot;The setting can&#x27;t be changed after the pcap_t is activated&quot;);
2226  	case PCAP_ERROR_NO_SUCH_DEVICE:
2227  		return (&quot;No such device exists&quot;);
2228  	case PCAP_ERROR_RFMON_NOTSUP:
2229  		return (&quot;That device doesn&#x27;t support monitor mode&quot;);
2230  	case PCAP_ERROR_NOT_RFMON:
2231  		return (&quot;That operation is supported only in monitor mode&quot;);
2232  	case PCAP_ERROR_PERM_DENIED:
2233  		return (&quot;You don&#x27;t have permission to perform this capture on that device&quot;);
2234  	case PCAP_ERROR_IFACE_NOT_UP:
2235  		return (&quot;That device is not up&quot;);
2236  	case PCAP_ERROR_CANTSET_TSTAMP_TYPE:
2237  		return (&quot;That device doesn&#x27;t support setting the time stamp type&quot;);
2238  	case PCAP_ERROR_PROMISC_PERM_DENIED:
2239  		return (&quot;You don&#x27;t have permission to capture in promiscuous mode on that device&quot;);
2240  	case PCAP_ERROR_TSTAMP_PRECISION_NOTSUP:
2241  		return (&quot;That device doesn&#x27;t support that time stamp precision&quot;);
2242  	}
2243  	(void)snprintf(ebuf, sizeof ebuf, &quot;Unknown error: %d&quot;, errnum);
2244  	return(ebuf);
2245  }
2246  const char *
2247  pcap_strerror(int errnum)
2248  {
2249  #ifdef HAVE_STRERROR
2250  #ifdef _WIN32
2251  	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
2252  	errno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);
2253  	if (err != 0) &amp;bsol;* err = 0 if successful */
2254  		pcap_strlcpy(errbuf, &quot;strerror_s() error&quot;, PCAP_ERRBUF_SIZE);
2255  	return (errbuf);
2256  #else
2257  	return (strerror(errnum));
2258  #endif &amp;bsol;* _WIN32 */
2259  #else
2260  	extern int sys_nerr;
2261  	extern const char *const sys_errlist[];
2262  	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
2263  	if ((unsigned int)errnum &lt; sys_nerr)
2264  		return ((char *)sys_errlist[errnum]);
2265  	(void)snprintf(errbuf, sizeof errbuf, &quot;Unknown error: %d&quot;, errnum);
2266  	return (errbuf);
2267  #endif
2268  }
2269  int
2270  pcap_setfilter(pcap_t *p, struct bpf_program *fp)
2271  {
2272  	return (p-&gt;setfilter_op(p, fp));
2273  }
2274  int
2275  pcap_setdirection(pcap_t *p, pcap_direction_t d)
2276  {
2277  	if (p-&gt;setdirection_op == NULL) {
2278  		snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2279  		    &quot;Setting direction is not supported on this device&quot;);
2280  		return (-1);
2281  	} else {
2282  		switch (d) {
2283  		case PCAP_D_IN:
2284  		case PCAP_D_OUT:
2285  		case PCAP_D_INOUT:
2286  			return (p-&gt;setdirection_op(p, d));
2287  		default:
2288  			snprintf(p-&gt;errbuf, sizeof(p-&gt;errbuf),
2289  			    &quot;Invalid direction&quot;);
2290  			return (-1);
2291  		}
2292  	}
2293  }
2294  int
2295  pcap_stats(pcap_t *p, struct pcap_stat *ps)
2296  {
2297  	return (p-&gt;stats_op(p, ps));
2298  }
2299  #ifdef _WIN32
2300  struct pcap_stat *
2301  pcap_stats_ex(pcap_t *p, int *pcap_stat_size)
2302  {
2303  	return (p-&gt;stats_ex_op(p, pcap_stat_size));
2304  }
2305  int
2306  pcap_setbuff(pcap_t *p, int dim)
2307  {
2308  	return (p-&gt;setbuff_op(p, dim));
2309  }
2310  int
2311  pcap_setmode(pcap_t *p, int mode)
2312  {
2313  	return (p-&gt;setmode_op(p, mode));
2314  }
2315  int
2316  pcap_setmintocopy(pcap_t *p, int size)
2317  {
2318  	return (p-&gt;setmintocopy_op(p, size));
2319  }
2320  HANDLE
2321  pcap_getevent(pcap_t *p)
2322  {
2323  	return (p-&gt;getevent_op(p));
2324  }
2325  int
2326  pcap_oid_get_request(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)
2327  {
2328  	return (p-&gt;oid_get_request_op(p, oid, data, lenp));
2329  }
2330  int
2331  pcap_oid_set_request(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp)
2332  {
2333  	return (p-&gt;oid_set_request_op(p, oid, data, lenp));
2334  }
2335  pcap_send_queue *
2336  pcap_sendqueue_alloc(u_int memsize)
2337  {
2338  	pcap_send_queue *tqueue;
2339  	tqueue = (pcap_send_queue *)malloc(sizeof(pcap_send_queue));
2340  	if (tqueue == NULL){
2341  		return (NULL);
2342  	}
2343  	tqueue-&gt;buffer = (char *)malloc(memsize);
2344  	if (tqueue-&gt;buffer == NULL) {
2345  		free(tqueue);
2346  		return (NULL);
2347  	}
2348  	tqueue-&gt;maxlen = memsize;
2349  	tqueue-&gt;len = 0;
2350  	return (tqueue);
2351  }
2352  void
2353  pcap_sendqueue_destroy(pcap_send_queue *queue)
2354  {
2355  	free(queue-&gt;buffer);
2356  	free(queue);
2357  }
2358  int
2359  pcap_sendqueue_queue(pcap_send_queue *queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)
2360  {
2361  	if (queue-&gt;len + sizeof(struct pcap_pkthdr) + pkt_header-&gt;caplen &gt; queue-&gt;maxlen){
2362  		return (-1);
2363  	}
2364  	memcpy(queue-&gt;buffer + queue-&gt;len, pkt_header, sizeof(struct pcap_pkthdr));
2365  	queue-&gt;len += sizeof(struct pcap_pkthdr);
2366  	memcpy(queue-&gt;buffer + queue-&gt;len, pkt_data, pkt_header-&gt;caplen);
2367  	queue-&gt;len += pkt_header-&gt;caplen;
2368  	return (0);
2369  }
2370  u_int
2371  pcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue, int sync)
2372  {
2373  	return (p-&gt;sendqueue_transmit_op(p, queue, sync));
2374  }
2375  int
2376  pcap_setuserbuffer(pcap_t *p, int size)
2377  {
2378  	return (p-&gt;setuserbuffer_op(p, size));
2379  }
2380  int
2381  pcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)
2382  {
2383  	return (p-&gt;live_dump_op(p, filename, maxsize, maxpacks));
2384  }
2385  int
2386  pcap_live_dump_ended(pcap_t *p, int sync)
2387  {
2388  	return (p-&gt;live_dump_ended_op(p, sync));
2389  }
2390  PAirpcapHandle
2391  pcap_get_airpcap_handle(pcap_t *p)
2392  {
2393  	PAirpcapHandle handle;
2394  	handle = p-&gt;get_airpcap_handle_op(p);
2395  	if (handle == NULL) {
2396  		(void)snprintf(p-&gt;errbuf, sizeof(p-&gt;errbuf),
2397  		    &quot;This isn&#x27;t an AirPcap device&quot;);
2398  	}
2399  	return (handle);
2400  }
2401  #endif
2402  static struct pcap *pcaps_to_close;
2403  static int did_atexit;
2404  static void
2405  pcap_close_all(void)
2406  {
2407  	struct pcap *handle;
2408  	while ((handle = pcaps_to_close) != NULL) {
2409  		pcap_close(handle);
2410  		if (pcaps_to_close == handle)
2411  			abort();
2412  	}
2413  }
2414  int
2415  pcap_do_addexit(pcap_t *p)
2416  {
2417  	if (!did_atexit) {
2418  		if (atexit(pcap_close_all) != 0) {
2419  			pcap_strlcpy(p-&gt;errbuf, &quot;atexit failed&quot;, PCAP_ERRBUF_SIZE);
2420  			return (0);
2421  		}
2422  		did_atexit = 1;
2423  	}
2424  	return (1);
2425  }
2426  void
2427  pcap_add_to_pcaps_to_close(pcap_t *p)
2428  {
2429  	p-&gt;next = pcaps_to_close;
2430  	pcaps_to_close = p;
2431  }
2432  void
2433  pcap_remove_from_pcaps_to_close(pcap_t *p)
2434  {
2435  	pcap_t *pc, *prevpc;
2436  	for (pc = pcaps_to_close, prevpc = NULL; pc != NULL;
2437  	    prevpc = pc, pc = pc-&gt;next) {
2438  		if (pc == p) {
2439  			if (prevpc == NULL) {
2440  				pcaps_to_close = pc-&gt;next;
2441  			} else {
2442  				prevpc-&gt;next = pc-&gt;next;
2443  			}
2444  			break;
2445  		}
2446  	}
2447  }
2448  void
2449  pcap_breakloop_common(pcap_t *p)
2450  {
2451  	p-&gt;break_loop = 1;
2452  }
2453  void
2454  pcap_cleanup_live_common(pcap_t *p)
2455  {
2456  	if (p-&gt;opt.device != NULL) {
2457  		free(p-&gt;opt.device);
2458  		p-&gt;opt.device = NULL;
2459  	}
2460  	if (p-&gt;buffer != NULL) {
2461  		free(p-&gt;buffer);
2462  		p-&gt;buffer = NULL;
2463  	}
2464  	if (p-&gt;dlt_list != NULL) {
2465  		free(p-&gt;dlt_list);
2466  		p-&gt;dlt_list = NULL;
2467  		p-&gt;dlt_count = 0;
2468  	}
2469  	if (p-&gt;tstamp_type_list != NULL) {
2470  		free(p-&gt;tstamp_type_list);
2471  		p-&gt;tstamp_type_list = NULL;
2472  		p-&gt;tstamp_type_count = 0;
2473  	}
2474  	if (p-&gt;tstamp_precision_list != NULL) {
2475  		free(p-&gt;tstamp_precision_list);
2476  		p-&gt;tstamp_precision_list = NULL;
2477  		p-&gt;tstamp_precision_count = 0;
2478  	}
2479  	pcap_freecode(&amp;p-&gt;fcode);
2480  #if !defined(_WIN32) &amp;&amp; !defined(MSDOS)
2481  	if (p-&gt;fd &gt;= 0) {
2482  		close(p-&gt;fd);
2483  		p-&gt;fd = -1;
2484  	}
2485  	p-&gt;selectable_fd = -1;
2486  #endif
2487  }
2488  int
2489  pcap_sendpacket(pcap_t *p, const u_char *buf, int size)
2490  {
2491  	if (size &lt;= 0) {
2492  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2493  		    errno, &quot;The number of bytes to be sent must be positive&quot;);
2494  		return (PCAP_ERROR);
2495  	}
2496  	if (p-&gt;inject_op(p, buf, size) == -1)
2497  		return (-1);
2498  	return (0);
2499  }
2500  int
2501  pcap_inject(pcap_t *p, const void *buf, size_t size)
2502  {
2503  	if (size &gt; INT_MAX) {
2504  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2505  		    errno, &quot;More than %d bytes cannot be injected&quot;, INT_MAX);
2506  		return (PCAP_ERROR);
2507  	}
2508  	if (size == 0) {
2509  		pcap_fmt_errmsg_for_errno(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2510  		    errno, &quot;The number of bytes to be injected must not be zero&quot;);
2511  		return (PCAP_ERROR);
2512  	}
2513  	return (p-&gt;inject_op(p, buf, (int)size));
2514  }
2515  void
2516  pcap_close(pcap_t *p)
2517  {
2518  	p-&gt;cleanup_op(p);
2519  	free(p);
2520  }
2521  #ifdef _WIN32
2522  pcap_code_handle_t
2523  pcap_load_code(const char *name)
2524  {
2525  	CHAR path[MAX_PATH];
2526  	CHAR fullFileName[MAX_PATH];
2527  	UINT res;
2528  	HMODULE hModule = NULL;
2529  	do
2530  	{
2531  		res = GetSystemDirectoryA(path, MAX_PATH);
2532  		if (res == 0) {
2533  			break;
2534  		}
2535  		if (res &gt; MAX_PATH) {
2536  			SetLastError(ERROR_INSUFFICIENT_BUFFER);
2537  			break;
2538  		}
2539  		if (res + 1 + strlen(name) + 1 &lt; MAX_PATH) {
2540  			memcpy(fullFileName, path, res * sizeof(TCHAR));
2541  			fullFileName[res] = &#x27;\\&#x27;;
2542  			memcpy(&amp;fullFileName[res + 1], name, (strlen(name) + 1) * sizeof(TCHAR));
2543  			hModule = LoadLibraryA(fullFileName);
2544  		} else
2545  			SetLastError(ERROR_INSUFFICIENT_BUFFER);
2546  	} while(FALSE);
2547  	return hModule;
2548  }
2549  pcap_funcptr_t
2550  pcap_find_function(pcap_code_handle_t code, const char *func)
2551  {
2552  	return (GetProcAddress(code, func));
2553  }
2554  #endif
2555  int
2556  pcap_offline_filter(const struct bpf_program *fp, const struct pcap_pkthdr *h,
2557      const u_char *pkt)
2558  {
2559  	const struct bpf_insn *fcode = fp-&gt;bf_insns;
2560  	if (fcode != NULL)
2561  		return (pcap_filter(fcode, pkt, h-&gt;len, h-&gt;caplen));
2562  	else
2563  		return (0);
2564  }
2565  static int
2566  pcap_can_set_rfmon_dead(pcap_t *p)
2567  {
2568  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2569  	    &quot;Rfmon mode doesn&#x27;t apply on a pcap_open_dead pcap_t&quot;);
2570  	return (PCAP_ERROR);
2571  }
2572  static int
2573  pcap_read_dead(pcap_t *p, int cnt _U_, pcap_handler callback _U_,
2574      u_char *user _U_)
2575  {
2576  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2577  	    &quot;Packets aren&#x27;t available from a pcap_open_dead pcap_t&quot;);
2578  	return (-1);
2579  }
2580  static void
2581  pcap_breakloop_dead(pcap_t *p _U_)
2582  {
2583  }
2584  static int
2585  pcap_inject_dead(pcap_t *p, const void *buf _U_, int size _U_)
2586  {
2587  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2588  	    &quot;Packets can&#x27;t be sent on a pcap_open_dead pcap_t&quot;);
2589  	return (-1);
2590  }
2591  static int
2592  pcap_setfilter_dead(pcap_t *p, struct bpf_program *fp _U_)
2593  {
2594  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2595  	    &quot;A filter cannot be set on a pcap_open_dead pcap_t&quot;);
2596  	return (-1);
2597  }
2598  static int
2599  pcap_setdirection_dead(pcap_t *p, pcap_direction_t d _U_)
2600  {
2601  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2602  	    &quot;The packet direction cannot be set on a pcap_open_dead pcap_t&quot;);
2603  	return (-1);
2604  }
2605  static int
2606  pcap_set_datalink_dead(pcap_t *p, int dlt _U_)
2607  {
2608  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2609  	    &quot;The link-layer header type cannot be set on a pcap_open_dead pcap_t&quot;);
2610  	return (-1);
2611  }
2612  static int
2613  pcap_getnonblock_dead(pcap_t *p)
2614  {
2615  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2616  	    &quot;A pcap_open_dead pcap_t does not have a non-blocking mode setting&quot;);
2617  	return (-1);
2618  }
2619  static int
2620  pcap_setnonblock_dead(pcap_t *p, int nonblock _U_)
2621  {
2622  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2623  	    &quot;A pcap_open_dead pcap_t does not have a non-blocking mode setting&quot;);
2624  	return (-1);
2625  }
2626  static int
2627  pcap_stats_dead(pcap_t *p, struct pcap_stat *ps _U_)
2628  {
2629  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2630  	    &quot;Statistics aren&#x27;t available from a pcap_open_dead pcap_t&quot;);
2631  	return (-1);
2632  }
2633  #ifdef _WIN32
2634  static struct pcap_stat *
2635  pcap_stats_ex_dead(pcap_t *p, int *pcap_stat_size _U_)
2636  {
2637  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2638  	    &quot;Statistics aren&#x27;t available from a pcap_open_dead pcap_t&quot;);
2639  	return (NULL);
2640  }
2641  static int
2642  pcap_setbuff_dead(pcap_t *p, int dim _U_)
2643  {
2644  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2645  	    &quot;The kernel buffer size cannot be set on a pcap_open_dead pcap_t&quot;);
2646  	return (-1);
2647  }
2648  static int
2649  pcap_setmode_dead(pcap_t *p, int mode _U_)
2650  {
2651  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2652  	    &quot;impossible to set mode on a pcap_open_dead pcap_t&quot;);
2653  	return (-1);
2654  }
2655  static int
2656  pcap_setmintocopy_dead(pcap_t *p, int size _U_)
2657  {
2658  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2659  	    &quot;The mintocopy parameter cannot be set on a pcap_open_dead pcap_t&quot;);
2660  	return (-1);
2661  }
2662  static HANDLE
2663  pcap_getevent_dead(pcap_t *p)
2664  {
2665  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2666  	    &quot;A pcap_open_dead pcap_t has no event handle&quot;);
2667  	return (INVALID_HANDLE_VALUE);
2668  }
2669  static int
2670  pcap_oid_get_request_dead(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
2671      size_t *lenp _U_)
2672  {
2673  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2674  	    &quot;An OID get request cannot be performed on a pcap_open_dead pcap_t&quot;);
2675  	return (PCAP_ERROR);
2676  }
2677  static int
2678  pcap_oid_set_request_dead(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
2679      size_t *lenp _U_)
2680  {
2681  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2682  	    &quot;An OID set request cannot be performed on a pcap_open_dead pcap_t&quot;);
2683  	return (PCAP_ERROR);
2684  }
2685  static u_int
2686  pcap_sendqueue_transmit_dead(pcap_t *p, pcap_send_queue *queue _U_,
2687      int sync _U_)
2688  {
2689  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2690  	    &quot;Packets cannot be transmitted on a pcap_open_dead pcap_t&quot;);
2691  	return (0);
2692  }
2693  static int
2694  pcap_setuserbuffer_dead(pcap_t *p, int size _U_)
2695  {
2696  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2697  	    &quot;The user buffer cannot be set on a pcap_open_dead pcap_t&quot;);
2698  	return (-1);
2699  }
2700  static int
2701  pcap_live_dump_dead(pcap_t *p, char *filename _U_, int maxsize _U_,
2702      int maxpacks _U_)
2703  {
2704  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2705  	    &quot;Live packet dumping cannot be performed on a pcap_open_dead pcap_t&quot;);
2706  	return (-1);
2707  }
2708  static int
2709  pcap_live_dump_ended_dead(pcap_t *p, int sync _U_)
2710  {
2711  	snprintf(p-&gt;errbuf, PCAP_ERRBUF_SIZE,
2712  	    &quot;Live packet dumping cannot be performed on a pcap_open_dead pcap_t&quot;);
2713  	return (-1);
2714  }
2715  static PAirpcapHandle
2716  pcap_get_airpcap_handle_dead(pcap_t *p _U_)
2717  {
2718  	return (NULL);
2719  }
2720  #endif &amp;bsol;* _WIN32 */
2721  static void
2722  pcap_cleanup_dead(pcap_t *p _U_)
2723  {
2724  }
2725  pcap_t *
2726  pcap_open_dead_with_tstamp_precision(int linktype, int snaplen, u_int precision)
2727  {
2728  	pcap_t *p;
2729  	switch (precision) {
2730  	case PCAP_TSTAMP_PRECISION_MICRO:
2731  	case PCAP_TSTAMP_PRECISION_NANO:
2732  		break;
2733  	default:
2734  		precision = PCAP_TSTAMP_PRECISION_MICRO;
2735  		break;
2736  	}
2737  	p = malloc(sizeof(*p));
2738  	if (p == NULL)
2739  		return NULL;
2740  	memset (p, 0, sizeof(*p));
2741  	p-&gt;snapshot = snaplen;
2742  	p-&gt;linktype = linktype;
2743  	p-&gt;opt.tstamp_precision = precision;
2744  	p-&gt;can_set_rfmon_op = pcap_can_set_rfmon_dead;
2745  	p-&gt;read_op = pcap_read_dead;
2746  	p-&gt;inject_op = pcap_inject_dead;
2747  	p-&gt;setfilter_op = pcap_setfilter_dead;
2748  	p-&gt;setdirection_op = pcap_setdirection_dead;
2749  	p-&gt;set_datalink_op = pcap_set_datalink_dead;
2750  	p-&gt;getnonblock_op = pcap_getnonblock_dead;
2751  	p-&gt;setnonblock_op = pcap_setnonblock_dead;
2752  	p-&gt;stats_op = pcap_stats_dead;
2753  #ifdef _WIN32
2754  	p-&gt;stats_ex_op = pcap_stats_ex_dead;
2755  	p-&gt;setbuff_op = pcap_setbuff_dead;
2756  	p-&gt;setmode_op = pcap_setmode_dead;
2757  	p-&gt;setmintocopy_op = pcap_setmintocopy_dead;
2758  	p-&gt;getevent_op = pcap_getevent_dead;
2759  	p-&gt;oid_get_request_op = pcap_oid_get_request_dead;
2760  	p-&gt;oid_set_request_op = pcap_oid_set_request_dead;
2761  	p-&gt;sendqueue_transmit_op = pcap_sendqueue_transmit_dead;
2762  	p-&gt;setuserbuffer_op = pcap_setuserbuffer_dead;
2763  	p-&gt;live_dump_op = pcap_live_dump_dead;
2764  	p-&gt;live_dump_ended_op = pcap_live_dump_ended_dead;
2765  	p-&gt;get_airpcap_handle_op = pcap_get_airpcap_handle_dead;
2766  #endif
2767  	p-&gt;breakloop_op = pcap_breakloop_dead;
2768  	p-&gt;cleanup_op = pcap_cleanup_dead;
2769  	p-&gt;bpf_codegen_flags = 0;
2770  	p-&gt;activated = 1;
2771  	return (p);
2772  }
2773  pcap_t *
2774  pcap_open_dead(int linktype, int snaplen)
2775  {
2776  	return (pcap_open_dead_with_tstamp_precision(linktype, snaplen,
2777  	    PCAP_TSTAMP_PRECISION_MICRO));
2778  }
2779  #ifdef YYDEBUG
2780  PCAP_API void pcap_set_parser_debug(int value);
2781  PCAP_API_DEF void
2782  pcap_set_parser_debug(int value)
2783  {
2784  	pcap_debug = value;
2785  }
2786  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-allocate.c</h3>
            <pre><code>1  #include &quot;libbench2/bench.h&quot;
2  static void bounds(bench_problem *p, int *ilb, int *iub, int *olb, int *oub)
3  {
4       bench_tensor *t = tensor_append(p-&gt;sz, p-&gt;vecsz);
5       tensor_ibounds(t, ilb, iub);
6       tensor_obounds(t, olb, oub);
7       tensor_destroy(t);
8  }
9  void problem_alloc(bench_problem *p)
10  {
11       int ilb, iub, olb, oub;
12       int isz, osz;
13       bounds(p, &amp;ilb, &amp;iub, &amp;olb, &amp;oub);
14       isz = iub - ilb;
15       osz = oub - olb;
16       if (p-&gt;kind == PROBLEM_COMPLEX) {
17  	  bench_complex *in, *out;
18  	  p-&gt;iphyssz = isz;
19  	  p-&gt;inphys = in = (bench_complex *) bench_malloc(isz * sizeof(bench_complex));
20  	  p-&gt;in = in - ilb;
21  	  if (p-&gt;in_place) {
22  	       p-&gt;out = p-&gt;in;
23  	       p-&gt;outphys = p-&gt;inphys;
24  	       p-&gt;ophyssz = p-&gt;iphyssz;
25  	  } else {
26  	       p-&gt;ophyssz = osz;
27  	       p-&gt;outphys = out = (bench_complex *) bench_malloc(osz * sizeof(bench_complex));
28  	       p-&gt;out = out - olb;
29  	  }
30       } else if (p-&gt;kind == PROBLEM_R2R) {
31  	  bench_real *in, *out;
32  	  p-&gt;iphyssz = isz;
33  	  p-&gt;inphys = in = (bench_real *) bench_malloc(isz * sizeof(bench_real));
34  	  p-&gt;in = in - ilb;
35  	  if (p-&gt;in_place) {
36  	       p-&gt;out = p-&gt;in;
37  	       p-&gt;outphys = p-&gt;inphys;
38  	       p-&gt;ophyssz = p-&gt;iphyssz;
39  	  } else {
40  	       p-&gt;ophyssz = osz;
41  	       p-&gt;outphys = out = (bench_real *) bench_malloc(osz * sizeof(bench_real));
42  	       p-&gt;out = out - olb;
43  	  }
44       } else if (p-&gt;kind == PROBLEM_REAL &amp;&amp; p-&gt;sign &lt; 0) { &amp;bsol;* R2HC */
45  	  bench_real *in;
46  	  bench_complex *out;
47  	  isz = isz &gt; osz*2 ? isz : osz*2;
48  	  p-&gt;iphyssz = isz;
49  	  p-&gt;inphys = in = (bench_real *) bench_malloc(p-&gt;iphyssz * sizeof(bench_real));
50  	  p-&gt;in = in - ilb;
51  	  if (p-&gt;in_place) {
52  	       p-&gt;out = p-&gt;in;
53  	       p-&gt;outphys = p-&gt;inphys;
54  	       p-&gt;ophyssz = p-&gt;iphyssz / 2;
55  	  } else {
56  	       p-&gt;ophyssz = osz;
57  	       p-&gt;outphys = out = (bench_complex *) bench_malloc(osz * sizeof(bench_complex));
58  	       p-&gt;out = out - olb;
59  	  }
60       } else if (p-&gt;kind == PROBLEM_REAL &amp;&amp; p-&gt;sign &gt; 0) { &amp;bsol;* HC2R */
61  	  bench_real *out;
62  	  bench_complex *in;
63  	  osz = osz &gt; isz*2 ? osz : isz*2;
64  	  p-&gt;ophyssz = osz;
65  	  p-&gt;outphys = out = (bench_real *) bench_malloc(p-&gt;ophyssz * sizeof(bench_real));
66  	  p-&gt;out = out - olb;
67  	  if (p-&gt;in_place) {
68  	       p-&gt;in = p-&gt;out;
69  	       p-&gt;inphys = p-&gt;outphys;
70  	       p-&gt;iphyssz = p-&gt;ophyssz / 2;
71  	  } else {
72  	       p-&gt;iphyssz = isz;
73  	       p-&gt;inphys = in = (bench_complex *) bench_malloc(isz * sizeof(bench_complex));
74  	       p-&gt;in = in - ilb;
75  	  }
76       } else {
77  	  BENCH_ASSERT(0); &amp;bsol;* TODO */
78       }
79  }
80  void problem_free(bench_problem *p)
81  {
82       if (p-&gt;outphys &amp;&amp; p-&gt;outphys != p-&gt;inphys)
<span onclick='openModal()' class='match'>83  	  bench_free(p-&gt;outphys);
84       if (p-&gt;inphys)
85  	  bench_free(p-&gt;inphys);
86       tensor_destroy(p-&gt;sz);
</span>87       tensor_destroy(p-&gt;vecsz);
88  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-allocate.c</div>
                </div>
                <div class="column column_space"><pre><code>782  				free(curaddr-&gt;addr);
783  			if (curaddr-&gt;netmask)
784  				free(curaddr-&gt;netmask);
785  			if (curaddr-&gt;broadaddr)
</pre></code></div>
                <div class="column column_space"><pre><code>83  	  bench_free(p-&gt;outphys);
84       if (p-&gt;inphys)
85  	  bench_free(p-&gt;inphys);
86       tensor_destroy(p-&gt;sz);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    