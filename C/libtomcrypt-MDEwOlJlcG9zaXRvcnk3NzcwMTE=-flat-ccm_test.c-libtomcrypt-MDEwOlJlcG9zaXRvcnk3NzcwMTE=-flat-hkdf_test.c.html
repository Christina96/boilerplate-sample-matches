
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
9         unsigned char key[16];
10         unsigned char nonce[16];
11         int           noncelen;
12         unsigned char header[64];
13         int           headerlen;
14         unsigned char pt[64];
15         int           ptlen;
16         unsigned char ct[64];
<span onclick='openModal()' class='match'>17         unsigned char tag[16];
18         unsigned long taglen;
19     } tests[] = {
20  {
</span>21     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
22       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
23     { 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xA0,
24       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
25     13,
26     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
27     8,
28     { 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
29       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
30       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E },
31     23,
32     { 0x58, 0x8C, 0x97, 0x9A, 0x61, 0xC6, 0x63, 0xD2,
33       0xF0, 0x66, 0xD0, 0xC2, 0xC0, 0xF9, 0x89, 0x80,
34       0x6D, 0x5F, 0x6B, 0x61, 0xDA, 0xC3, 0x84 },
35     { 0x17, 0xe8, 0xd1, 0x2c, 0xfd, 0xf9, 0x26, 0xe0 },
36     8
37  },
38  {
39     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
40       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
41     { 0x00, 0x00, 0x00, 0x06, 0x05, 0x04, 0x03, 0xA0,
42       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
43     13,
44     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
45       0x08, 0x09, 0x0A, 0x0B },
46     12,
47     { 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
48       0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
49       0x1C, 0x1D, 0x1E },
50     19,
51     { 0xA2, 0x8C, 0x68, 0x65, 0x93, 0x9A, 0x9A, 0x79,
52       0xFA, 0xAA, 0x5C, 0x4C, 0x2A, 0x9D, 0x4A, 0x91,
53       0xCD, 0xAC, 0x8C },
54     { 0x96, 0xC8, 0x61, 0xB9, 0xC9, 0xE6, 0x1E, 0xF1 },
55     8
56  },
57  {
58     { 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
59       0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f },
60     { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16  },
61     7,
62     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
63     8,
64     { 0x20, 0x21, 0x22, 0x23 },
65     4,
66     { 0x71, 0x62, 0x01, 0x5b },
67     { 0x4d, 0xac, 0x25, 0x5d },
68     4
69  },
70  {
71     { 0xc9, 0x7c, 0x1f, 0x67, 0xce, 0x37, 0x11, 0x85,
72       0x51, 0x4a, 0x8a, 0x19, 0xf2, 0xbd, 0xd5, 0x2f },
73     { 0x00, 0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xb5,
74       0x03, 0x97, 0x76, 0xe7, 0x0c },
75     13,
76     { 0x08, 0x40, 0x0f, 0xd2, 0xe1, 0x28, 0xa5, 0x7c,
77       0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xab, 0xae,
78       0xa5, 0xb8, 0xfc, 0xba, 0x00, 0x00 },
79     22,
80     { 0xf8, 0xba, 0x1a, 0x55, 0xd0, 0x2f, 0x85, 0xae,
81       0x96, 0x7b, 0xb6, 0x2f, 0xb6, 0xcd, 0xa8, 0xeb,
82       0x7e, 0x78, 0xa0, 0x50 },
83     20,
84     { 0xf3, 0xd0, 0xa2, 0xfe, 0x9a, 0x3d, 0xbf, 0x23,
85       0x42, 0xa6, 0x43, 0xe4, 0x32, 0x46, 0xe8, 0x0c,
86       0x3c, 0x04, 0xd0, 0x19 },
87     { 0x78, 0x45, 0xce, 0x0b, 0x16, 0xf9, 0x76, 0x23 },
88     8
89  },
90  };
91     unsigned long taglen, x, y;
92     unsigned char buf[64], buf2[64], tag[16], tag2[16], tag3[16], zero[64];
93     int           err, idx;
94     symmetric_key skey;
95     ccm_state ccm;
96     zeromem(zero, 64);
97     idx = find_cipher("aes");
98     if (idx == -1) {
99        idx = find_cipher("rijndael");
100        if (idx == -1) {
101           return CRYPT_NOP;
102        }
103     }
104     for (x = 0; x < (sizeof(tests)/sizeof(tests[0])); x++) {
105        for (y = 0; y < 2; y++) {
106           taglen = tests[x].taglen;
107           if (y == 0) {
108              if ((err = cipher_descriptor[idx].setup(tests[x].key, 16, 0, &skey)) != CRYPT_OK) {
109                 return err;
110              }
111              if ((err = ccm_memory(idx,
112                                    tests[x].key, 16,
113                                    &skey,
114                                    tests[x].nonce, tests[x].noncelen,
115                                    tests[x].header, tests[x].headerlen,
116                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
117                                    buf,
118                                    tag, &taglen, 0)) != CRYPT_OK) {
119                 return err;
120              }
121              if ((err = ccm_memory(idx,
122                                    tests[x].key, 16,
123                                    &skey,
124                                    tests[x].nonce, tests[x].noncelen,
125                                    tests[x].header, tests[x].headerlen,
126                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
127                                    buf,
128                                    tag, &taglen, 0)) != CRYPT_OK) {
129                 return err;
130              }
131           } else {
132              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
133                 return err;
134              }
135              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
136                 return err;
137              }
138              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
139                 return err;
140              }
141              if ((err = ccm_process(&ccm, (unsigned char*)tests[x].pt, tests[x].ptlen, buf, CCM_ENCRYPT)) != CRYPT_OK) {
142                 return err;
143              }
144              if ((err = ccm_done(&ccm, tag, &taglen)) != CRYPT_OK) {
145                 return err;
146              }
147           }
148           if (compare_testvector(buf, tests[x].ptlen, tests[x].ct, tests[x].ptlen, "CCM encrypt data", x)) {
149              return CRYPT_FAIL_TESTVECTOR;
150           }
151           if (compare_testvector(tag, taglen, tests[x].tag, tests[x].taglen, "CCM encrypt tag", x)) {
152              return CRYPT_FAIL_TESTVECTOR;
153           }
154           if (y == 0) {
155              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
156              taglen = tests[x].taglen;
157              if ((err = ccm_memory(idx,
158                                    tests[x].key, 16,
159                                    NULL,
160                                    tests[x].nonce, tests[x].noncelen,
161                                    tests[x].header, tests[x].headerlen,
162                                    buf2, tests[x].ptlen,
163                                    buf,
164                                    tag3, &taglen, 1   )) != CRYPT_OK) {
165                 return err;
166              }
167           } else {
168              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
169                 return err;
170              }
171              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
172                 return err;
173              }
174              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
175                 return err;
176              }
177              if ((err = ccm_process(&ccm, buf2, tests[x].ptlen, buf, CCM_DECRYPT)) != CRYPT_OK) {
178                 return err;
179              }
180              if ((err = ccm_done(&ccm, tag2, &taglen)) != CRYPT_OK) {
181                 return err;
182              }
183           }
184           if (compare_testvector(buf2, tests[x].ptlen, tests[x].pt, tests[x].ptlen, "CCM decrypt data", x)) {
185              return CRYPT_FAIL_TESTVECTOR;
186           }
187           if (y == 0) {
188              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
189              tag3[0] ^= 0xff; &bsol;* set the tag to the wrong value */
190              taglen = tests[x].taglen;
191              if (ccm_memory(idx,
192                             tests[x].key, 16,
193                             NULL,
194                             tests[x].nonce, tests[x].noncelen,
195                             tests[x].header, tests[x].headerlen,
196                             buf2, tests[x].ptlen,
197                             buf,
198                             tag3, &taglen, 1   ) != CRYPT_ERROR) {
199                 return CRYPT_FAIL_TESTVECTOR;
200              }
201              if (compare_testvector(buf2, tests[x].ptlen, zero, tests[x].ptlen, "CCM decrypt wrong tag", x)) {
202                 return CRYPT_FAIL_TESTVECTOR;
203              }
204           } else {
205              if (compare_testvector(tag2, taglen, tests[x].tag, tests[x].taglen, "CCM decrypt tag", x)) {
206                 return CRYPT_FAIL_TESTVECTOR;
207              }
208           }
209           if (y == 0) {
210              cipher_descriptor[idx].done(&skey);
211           }
212        }
213     }
214     {
215        unsigned char key[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };
216        unsigned char iv[]  = { 0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51 };
217        unsigned char valid_tag[]   = { 0x23,0x1a,0x2d,0x8f };
218        unsigned char invalid_tag[] = { 0x23,0x1a,0x2d,0x8f,0x6a };
219        unsigned char msg[] = { 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f };
220        unsigned char ct[]  = { 0xd3,0xda,0xb1,0xee,0x49,0x4c,0xc2,0x29,0x09,0x9d,0x6c,0xac,0x7d,0xf1,0x4a,0xdd };
221        unsigned char pt[20] = { 0 };
222        taglen = sizeof(valid_tag);
223        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
224                         pt, sizeof(ct), ct, valid_tag, &taglen, CCM_DECRYPT);
225        if ((err != CRYPT_OK) || (XMEMCMP(msg, pt, sizeof(msg)) != 0)) {
226           return CRYPT_FAIL_TESTVECTOR;
227        }
228        taglen = sizeof(invalid_tag);
229        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
230                         pt, sizeof(ct), ct, invalid_tag, &taglen, CCM_DECRYPT);
231        if (err == CRYPT_OK) {
232           return CRYPT_FAIL_TESTVECTOR; &bsol;* should fail */
233        }
234     }
235     return CRYPT_OK;
236  #endif
237  }
238  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hkdf_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_HKDF
3  int hkdf_test(void)
4  {
5   #ifndef LTC_TEST
6      return CRYPT_NOP;
7   #else
8      unsigned char OKM[82];
9      int i;
10      static const struct hkdf_test_case {
11          int num;
12          const char* Hash;
13          unsigned char IKM[80];
14          unsigned long IKM_l;
15          unsigned char salt[80];
16          unsigned long salt_l;
17          unsigned char info[80];
18          unsigned long info_l;
19          unsigned char PRK[32];
20          unsigned long PRK_l;
<span onclick='openModal()' class='match'>21          unsigned char OKM[82];
22          unsigned long OKM_l;
23      } cases[] = {
24  #ifdef LTC_SHA256
</span>25             {1, "sha256",
26              {0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
27               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
28               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b}, 22,
29              {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
30               0x08, 0x09, 0x0a, 0x0b, 0x0c}, 13,
31              {0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
32               0xf8, 0xf9}, 10,
33              {0x07, 0x77, 0x09, 0x36, 0x2c, 0x2e, 0x32, 0xdf,
34               0x0d, 0xdc, 0x3f, 0x0d, 0xc4, 0x7b, 0xba, 0x63,
35               0x90, 0xb6, 0xc7, 0x3b, 0xb5, 0x0f, 0x9c, 0x31,
36               0x22, 0xec, 0x84, 0x4a, 0xd7, 0xc2, 0xb3, 0xe5}, 32,
37              {0x3c, 0xb2, 0x5f, 0x25, 0xfa, 0xac, 0xd5, 0x7a,
38               0x90, 0x43, 0x4f, 0x64, 0xd0, 0x36, 0x2f, 0x2a,
39               0x2d, 0x2d, 0x0a, 0x90, 0xcf, 0x1a, 0x5a, 0x4c,
40               0x5d, 0xb0, 0x2d, 0x56, 0xec, 0xc4, 0xc5, 0xbf,
41               0x34, 0x00, 0x72, 0x08, 0xd5, 0xb8, 0x87, 0x18,
42               0x58, 0x65}, 42},
43  #ifdef LTC_TEST_EXT
44             {2, "sha256",
45              {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
46               0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
47               0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
48               0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
49               0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
50               0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
51               0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
52               0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
53               0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
54               0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f}, 80,
55              {0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
56               0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
57               0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
58               0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
59               0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
60               0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
61               0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
62               0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
63               0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
64               0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf}, 80,
65              {0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
66               0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
67               0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
68               0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
69               0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
70               0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
71               0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
72               0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
73               0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
74               0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}, 80,
75              {0x06, 0xa6, 0xb8, 0x8c, 0x58, 0x53, 0x36, 0x1a,
76               0x06, 0x10, 0x4c, 0x9c, 0xeb, 0x35, 0xb4, 0x5c,
77               0xef, 0x76, 0x00, 0x14, 0x90, 0x46, 0x71, 0x01,
78               0x4a, 0x19, 0x3f, 0x40, 0xc1, 0x5f, 0xc2, 0x44}, 32,
79              {0xb1, 0x1e, 0x39, 0x8d, 0xc8, 0x03, 0x27, 0xa1,
80               0xc8, 0xe7, 0xf7, 0x8c, 0x59, 0x6a, 0x49, 0x34,
81               0x4f, 0x01, 0x2e, 0xda, 0x2d, 0x4e, 0xfa, 0xd8,
82               0xa0, 0x50, 0xcc, 0x4c, 0x19, 0xaf, 0xa9, 0x7c,
83               0x59, 0x04, 0x5a, 0x99, 0xca, 0xc7, 0x82, 0x72,
84               0x71, 0xcb, 0x41, 0xc6, 0x5e, 0x59, 0x0e, 0x09,
85               0xda, 0x32, 0x75, 0x60, 0x0c, 0x2f, 0x09, 0xb8,
86               0x36, 0x77, 0x93, 0xa9, 0xac, 0xa3, 0xdb, 0x71,
87               0xcc, 0x30, 0xc5, 0x81, 0x79, 0xec, 0x3e, 0x87,
88               0xc1, 0x4c, 0x01, 0xd5, 0xc1, 0xf3, 0x43, 0x4f,
89               0x1d, 0x87}, 82},
90             {3, "sha256",
91              {0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
92               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
93               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b}, 22,
94              {0}, 0,
95              {0}, 0,
96              {0x19, 0xef, 0x24, 0xa3, 0x2c, 0x71, 0x7b, 0x16,
97               0x7f, 0x33, 0xa9, 0x1d, 0x6f, 0x64, 0x8b, 0xdf,
98               0x96, 0x59, 0x67, 0x76, 0xaf, 0xdb, 0x63, 0x77,
99               0xac, 0x43, 0x4c, 0x1c, 0x29, 0x3c, 0xcb, 0x04}, 32,
100              {0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
101               0x71, 0x5f, 0x80, 0x2a, 0x06, 0x3c, 0x5a, 0x31,
102               0xb8, 0xa1, 0x1f, 0x5c, 0x5e, 0xe1, 0x87, 0x9e,
103               0xc3, 0x45, 0x4e, 0x5f, 0x3c, 0x73, 0x8d, 0x2d,
104               0x9d, 0x20, 0x13, 0x95, 0xfa, 0xa4, 0xb6, 0x1a,
105               0x96, 0xc8}, 42},
106  #endif &bsol;* LTC_TEST_EXT */
107  #endif &bsol;* LTC_SHA256 */
108  #ifdef LTC_SHA1
109             {4, "sha1",
110              {0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
111               0x0b, 0x0b, 0x0b}, 11,
112              {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
113               0x08, 0x09, 0x0a, 0x0b, 0x0c}, 13,
114              {0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
115               0xf8, 0xf9}, 10,
116              {0x9b, 0x6c, 0x18, 0xc4, 0x32, 0xa7, 0xbf, 0x8f,
117               0x0e, 0x71, 0xc8, 0xeb, 0x88, 0xf4, 0xb3, 0x0b,
118               0xaa, 0x2b, 0xa2, 0x43}, 20,
119              {0x08, 0x5a, 0x01, 0xea, 0x1b, 0x10, 0xf3, 0x69,
120               0x33, 0x06, 0x8b, 0x56, 0xef, 0xa5, 0xad, 0x81,
121               0xa4, 0xf1, 0x4b, 0x82, 0x2f, 0x5b, 0x09, 0x15,
122               0x68, 0xa9, 0xcd, 0xd4, 0xf1, 0x55, 0xfd, 0xa2,
123               0xc2, 0x2e, 0x42, 0x24, 0x78, 0xd3, 0x05, 0xf3,
124               0xf8, 0x96}, 42},
125  #ifdef LTC_TEST_EXT
126             {5, "sha1",
127              {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
128               0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
129               0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
130               0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
131               0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
132               0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
133               0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
134               0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
135               0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
136               0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f}, 80,
137              {0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
138               0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
139               0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
140               0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
141               0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
142               0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
143               0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
144               0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
145               0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
146               0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf}, 80,
147              {0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
148               0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
149               0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
150               0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
151               0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
152               0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
153               0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
154               0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
155               0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
156               0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}, 80,
157              {0x8a, 0xda, 0xe0, 0x9a, 0x2a, 0x30, 0x70, 0x59,
158               0x47, 0x8d, 0x30, 0x9b, 0x26, 0xc4, 0x11, 0x5a,
159               0x22, 0x4c, 0xfa, 0xf6}, 20,
160              {0x0b, 0xd7, 0x70, 0xa7, 0x4d, 0x11, 0x60, 0xf7,
161               0xc9, 0xf1, 0x2c, 0xd5, 0x91, 0x2a, 0x06, 0xeb,
162               0xff, 0x6a, 0xdc, 0xae, 0x89, 0x9d, 0x92, 0x19,
163               0x1f, 0xe4, 0x30, 0x56, 0x73, 0xba, 0x2f, 0xfe,
164               0x8f, 0xa3, 0xf1, 0xa4, 0xe5, 0xad, 0x79, 0xf3,
165               0xf3, 0x34, 0xb3, 0xb2, 0x02, 0xb2, 0x17, 0x3c,
166               0x48, 0x6e, 0xa3, 0x7c, 0xe3, 0xd3, 0x97, 0xed,
167               0x03, 0x4c, 0x7f, 0x9d, 0xfe, 0xb1, 0x5c, 0x5e,
168               0x92, 0x73, 0x36, 0xd0, 0x44, 0x1f, 0x4c, 0x43,
169               0x00, 0xe2, 0xcf, 0xf0, 0xd0, 0x90, 0x0b, 0x52,
170               0xd3, 0xb4}, 82},
171             {6, "sha1",
172              {0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
173               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
174               0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b}, 22,
175              {0}, 0,
176              {0}, 0,
177              {0xda, 0x8c, 0x8a, 0x73, 0xc7, 0xfa, 0x77, 0x28,
178               0x8e, 0xc6, 0xf5, 0xe7, 0xc2, 0x97, 0x78, 0x6a,
179               0xa0, 0xd3, 0x2d, 0x01}, 20,
180              {0x0a, 0xc1, 0xaf, 0x70, 0x02, 0xb3, 0xd7, 0x61,
181               0xd1, 0xe5, 0x52, 0x98, 0xda, 0x9d, 0x05, 0x06,
182               0xb9, 0xae, 0x52, 0x05, 0x72, 0x20, 0xa3, 0x06,
183               0xe0, 0x7b, 0x6b, 0x87, 0xe8, 0xdf, 0x21, 0xd0,
184               0xea, 0x00, 0x03, 0x3d, 0xe0, 0x39, 0x84, 0xd3,
185               0x49, 0x18}, 42},
186             {7, "sha1",
187              {0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
188               0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
189               0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c}, 22,
190              {0}, 0, &bsol;* pass a null pointer */
191              {0}, 0,
192              {0x2a, 0xdc, 0xca, 0xda, 0x18, 0x77, 0x9e, 0x7c,
193               0x20, 0x77, 0xad, 0x2e, 0xb1, 0x9d, 0x3f, 0x3e,
194               0x73, 0x13, 0x85, 0xdd}, 20,
195              {0x2c, 0x91, 0x11, 0x72, 0x04, 0xd7, 0x45, 0xf3,
196               0x50, 0x0d, 0x63, 0x6a, 0x62, 0xf6, 0x4f, 0x0a,
197               0xb3, 0xba, 0xe5, 0x48, 0xaa, 0x53, 0xd4, 0x23,
198               0xb0, 0xd1, 0xf2, 0x7e, 0xbb, 0xa6, 0xf5, 0xe5,
199               0x67, 0x3a, 0x08, 0x1d, 0x70, 0xcc, 0xe7, 0xac,
200               0xfc, 0x48}, 42},
201  #endif &bsol;* LTC_TEST_EXT */
202  #endif &bsol;* LTC_SHA1 */
203      };
204      int err;
205      int tested=0,failed=0;
206      for(i=0; i < (int)(sizeof(cases) / sizeof(cases[0])); i++) {
207          int hash = find_hash(cases[i].Hash);
208          if (hash == -1) continue;
209          ++tested;
210          if((err = hkdf(hash, cases[i].salt, cases[i].salt_l,
211                          cases[i].info, cases[i].info_l,
212                          cases[i].IKM,   cases[i].IKM_l,
213                          OKM, cases[i].OKM_l)) != CRYPT_OK) {
214  #if defined(LTC_TEST_DBG) && (LTC_TEST_DBG > 1)
215              printf("LTC_HKDF-%s test #%d, %s\n", cases[i].Hash, i, error_to_string(err));
216  #endif
217              return err;
218          }
219          if(compare_testvector(OKM, cases[i].OKM_l, cases[i].OKM, (size_t)cases[i].OKM_l, "HKDF", cases[i].num)) {
220              failed++;
221          }
222      }
223      if (failed != 0) {
224          return CRYPT_FAIL_TESTVECTOR;
225      }
226      if (tested == 0) {
227          return CRYPT_NOP;
228      }
229      return CRYPT_OK;
230   #endif
231  }
232  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hkdf_test.c</div>
                </div>
                <div class="column column_space"><pre><code>17         unsigned char tag[16];
18         unsigned long taglen;
19     } tests[] = {
20  {
</pre></code></div>
                <div class="column column_space"><pre><code>21          unsigned char OKM[82];
22          unsigned long OKM_l;
23      } cases[] = {
24  #ifdef LTC_SHA256
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    