
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.770848440899202%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-idea.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_IDEA
3  const struct ltc_cipher_descriptor idea_desc = {
4     "idea",
5     24,                  &bsol;* cipher_ID */
6     16, 16, 8, 8,        &bsol;* min_key_len, max_key_len, block_len, default_rounds */
7     &idea_setup,
8     &idea_ecb_encrypt,
9     &idea_ecb_decrypt,
10     &idea_test,
11     &idea_done,
12     &idea_keysize,
<span onclick='openModal()' class='match'>13     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
14  };
</span>15  typedef unsigned short int ushort16;
16  #define LOW16(x)     ((x)&0xffff)  &bsol;* compiler should be able to optimize this away if x is 16 bits */
17  #define HIGH16(x)    ((x)>>16)
18  #define MUL(a,b)     {                                               \
19                           ulong32 p = (ulong32)LOW16(a) * b;          \
20                           if (p) {                                     \
21                              p = LOW16(p) - HIGH16(p);               \
22                              a = (ushort16)p - (ushort16)HIGH16(p);   \
23                           }                                            \
24                           else                                         \
25                              a = 1 - a - b;                            \
26                        }
27  #define STORE16(x,y) { (y)[0] = (unsigned char)(((x)>>8)&255); (y)[1] = (unsigned char)((x)&255); }
28  #define LOAD16(x,y)  { x = ((ushort16)((y)[0] & 255)<<8) | ((ushort16)((y)[1] & 255)); }
29  static ushort16 s_mul_inv(ushort16 x)
30  {
31     ushort16 y = x;
32     unsigned i;
33     for (i = 0; i < 15; i++) {
34        MUL(y, LOW16(y));
35        MUL(y, x);
36     }
37     return LOW16(y);
38  }
39  static ushort16 s_add_inv(ushort16 x)
40  {
41     return LOW16(0 - x);
42  }
43  static int s_setup_key(const unsigned char *key, symmetric_key *skey)
44  {
45     int i, j;
46     ushort16 *e_key = skey->idea.ek;
47     ushort16 *d_key = skey->idea.dk;
48     for (i = 0; i < 8; i++) {
49        LOAD16(e_key[i], key + 2 * i);
50     }
51     for (; i < LTC_IDEA_KEYLEN; i++) {
52        j = (i - i % 8) - 8;
53        e_key[i] = LOW16((e_key[j+(i+1)%8] << 9) | (e_key[j+(i+2)%8] >> 7));
54     }
55     for (i = 0; i < LTC_IDEA_ROUNDS; i++) {
56        d_key[i*6+0] = s_mul_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+0]);
57        d_key[i*6+1] = s_add_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+1+(i>0 ? 1 : 0)]);
58        d_key[i*6+2] = s_add_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+2-(i>0 ? 1 : 0)]);
59        d_key[i*6+3] = s_mul_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+3]);
60        d_key[i*6+4] =           e_key[(LTC_IDEA_ROUNDS-1-i)*6+4];
61        d_key[i*6+5] =           e_key[(LTC_IDEA_ROUNDS-1-i)*6+5];
62     }
63     d_key[i*6+0] = s_mul_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+0]);
64     d_key[i*6+1] = s_add_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+1]);
65     d_key[i*6+2] = s_add_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+2]);
66     d_key[i*6+3] = s_mul_inv(e_key[(LTC_IDEA_ROUNDS-i)*6+3]);
67     return CRYPT_OK;
68  }
69  static int s_process_block(const unsigned char *in, unsigned char *out, const ushort16 *m_key)
70  {
71     int i;
72     ushort16 x0, x1, x2, x3, t0, t1;
73     LOAD16(x0, in + 0);
74     LOAD16(x1, in + 2);
75     LOAD16(x2, in + 4);
76     LOAD16(x3, in + 6);
77     for (i = 0; i < LTC_IDEA_ROUNDS; i++) {
78        MUL(x0, m_key[i*6+0]);
79        x1 += m_key[i*6+1];
80        x2 += m_key[i*6+2];
81        MUL(x3, m_key[i*6+3]);
82        t0 = x0^x2;
83        MUL(t0, m_key[i*6+4]);
84        t1 = t0 + (x1^x3);
85        MUL(t1, m_key[i*6+5]);
86        t0 += t1;
87        x0 ^= t1;
88        x3 ^= t0;
89        t0 ^= x1;
90        x1 = x2^t1;
91        x2 = t0;
92     }
93     MUL(x0, m_key[LTC_IDEA_ROUNDS*6+0]);
94     x2 += m_key[LTC_IDEA_ROUNDS*6+1];
95     x1 += m_key[LTC_IDEA_ROUNDS*6+2];
96     MUL(x3, m_key[LTC_IDEA_ROUNDS*6+3]);
97     STORE16(x0, out + 0);
98     STORE16(x2, out + 2);
99     STORE16(x1, out + 4);
100     STORE16(x3, out + 6);
101     return CRYPT_OK;
102  }
103  int idea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
104  {
105     LTC_ARGCHK(key  != NULL);
106     LTC_ARGCHK(skey != NULL);
107     if (num_rounds != 0 && num_rounds != 8) return CRYPT_INVALID_ROUNDS;
108     if (keylen != 16) return CRYPT_INVALID_KEYSIZE;
109     return s_setup_key(key, skey);
110  }
111  int idea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
112  {
113     int err = s_process_block(pt, ct, skey->idea.ek);
114  #ifdef LTC_CLEAN_STACK
115     burn_stack(sizeof(ushort16) * 6 + sizeof(int));
116  #endif
117     return err;
118  }
119  int idea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
120  {
121     int err = s_process_block(ct, pt, skey->idea.dk);
122  #ifdef LTC_CLEAN_STACK
123     burn_stack(sizeof(ushort16) * 6 + sizeof(int));
124  #endif
125     return err;
126  }
127  void idea_done(symmetric_key *skey)
128  {
129     LTC_UNUSED_PARAM(skey);
130  }
131  int idea_keysize(int *keysize)
132  {
133     LTC_ARGCHK(keysize != NULL);
134     if (*keysize < 16) {
135        return CRYPT_INVALID_KEYSIZE;
136     }
137     *keysize = 16;
138     return CRYPT_OK;
139  }
140  int idea_test(void)
141  {
142  #ifndef LTC_TEST
143     return CRYPT_NOP;
144  #else
145     static const struct {
146        unsigned char key[16], pt[8], ct[8];
147     } tests[] = {
148        {
149            { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
150            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
151            { 0xB1, 0xF5, 0xF7, 0xF8, 0x79, 0x01, 0x37, 0x0F }
152        },
153        {
154            { 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
155            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
156            { 0xB3, 0x92, 0x7D, 0xFF, 0xB6, 0x35, 0x86, 0x26 }
157        },
158        {
159            { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
160            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
161            { 0xE9, 0x87, 0xE0, 0x02, 0x9F, 0xB9, 0x97, 0x85 }
162        },
163        {
164            { 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
165            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
166            { 0x75, 0x4A, 0x03, 0xCE, 0x08, 0xDB, 0x7D, 0xAA }
167        },
168        {
169            { 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
170            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
171            { 0xF0, 0x15, 0xF9, 0xFB, 0x0C, 0xFC, 0x7E, 0x1C }
172        },
173     };
174     unsigned char buf[2][8];
175     symmetric_key key;
176     int err, x;
177     if (sizeof(ushort16) != 2) {
178        return CRYPT_FAIL_TESTVECTOR;
179     }
180     for (x = 0; x < (int)(sizeof(tests)/sizeof(tests[0])); x++) {
181        if ((err = idea_setup(tests[x].key, 16, 8, &key)) != CRYPT_OK) {
182           return err;
183        }
184        if ((err = idea_ecb_encrypt(tests[x].pt, buf[0], &key)) != CRYPT_OK) {
185           return err;
186        }
187        if (compare_testvector(buf[0], 8, tests[x].ct, 8, "IDEA Encrypt", x)) {
188           return CRYPT_FAIL_TESTVECTOR;
189        }
190        if ((err = idea_ecb_decrypt(tests[x].ct, buf[1], &key)) != CRYPT_OK) {
191           return err;
192        }
193        if (compare_testvector(buf[1], 8, tests[x].pt, 8, "IDEA Decrypt", x)) {
194           return CRYPT_FAIL_TESTVECTOR;
195        }
196     }
197     return CRYPT_OK;
198  #endif
199  }
200  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>  
3  #include "src/dsp/dsp.h"
4  #include "src/enc/vp8i_enc.h"
5  static WEBP_INLINE uint8_t clip_8b(int v) {
6    return (!(v & ~0xff)) ? v : (v < 0) ? 0 : 255;
7  }
8  #if !WEBP_NEON_OMIT_C_CODE
9  static WEBP_INLINE int clip_max(int v, int max) {
10    return (v > max) ? max : v;
11  }
12  #endif  
13  const int VP8DspScan[16 + 4 + 4] = {
14    0 +  0 * BPS,  4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS,
15    0 +  4 * BPS,  4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS,
16    0 +  8 * BPS,  4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS,
17    0 + 12 * BPS,  4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS,
18    0 + 0 * BPS,   4 + 0 * BPS, 0 + 4 * BPS,  4 + 4 * BPS,    
19    8 + 0 * BPS,  12 + 0 * BPS, 8 + 4 * BPS, 12 + 4 * BPS     
20  };
21  void VP8SetHistogramData(const int distribution[MAX_COEFF_THRESH + 1],
22                           VP8Histogram* const histo) {
23    int max_value = 0, last_non_zero = 1;
24    int k;
25    for (k = 0; k <= MAX_COEFF_THRESH; ++k) {
26      const int value = distribution[k];
27      if (value > 0) {
28        if (value > max_value) max_value = value;
29        last_non_zero = k;
30      }
31    }
32    histo->max_value = max_value;
33    histo->last_non_zero = last_non_zero;
34  }
35  #if !WEBP_NEON_OMIT_C_CODE
36  static void CollectHistogram_C(const uint8_t* ref, const uint8_t* pred,
37                                 int start_block, int end_block,
38                                 VP8Histogram* const histo) {
39    int j;
40    int distribution[MAX_COEFF_THRESH + 1] = { 0 };
41    for (j = start_block; j < end_block; ++j) {
42      int k;
43      int16_t out[16];
44      VP8FTransform(ref + VP8DspScan[j], pred + VP8DspScan[j], out);
45      for (k = 0; k < 16; ++k) {
46        const int v = abs(out[k]) >> 3;
47        const int clipped_value = clip_max(v, MAX_COEFF_THRESH);
48        ++distribution[clipped_value];
49      }
50    }
51    VP8SetHistogramData(distribution, histo);
52  }
53  #endif  
54  static uint8_t clip1[255 + 510 + 1];    
55  static volatile int tables_ok = 0;
56  static WEBP_TSAN_IGNORE_FUNCTION void InitTables(void) {
57    if (!tables_ok) {
58      int i;
59      for (i = -255; i <= 255 + 255; ++i) {
60        clip1[255 + i] = clip_8b(i);
61      }
62      tables_ok = 1;
63    }
64  }
65  #if !WEBP_NEON_OMIT_C_CODE
66  #define STORE(x, y, v) \
67    dst[(x) + (y) * BPS] = clip_8b(ref[(x) + (y) * BPS] + ((v) >> 3))
68  static const int kC1 = 20091 + (1 << 16);
69  static const int kC2 = 35468;
70  #define MUL(a, b) (((a) * (b)) >> 16)
71  static WEBP_INLINE void ITransformOne(const uint8_t* ref, const int16_t* in,
72                                        uint8_t* dst) {
73    int C[4 * 4], *tmp;
74    int i;
75    tmp = C;
76    for (i = 0; i < 4; ++i) {    
77      const int a = in[0] + in[8];
78      const int b = in[0] - in[8];
79      const int c = MUL(in[4], kC2) - MUL(in[12], kC1);
80      const int d = MUL(in[4], kC1) + MUL(in[12], kC2);
81      tmp[0] = a + d;
82      tmp[1] = b + c;
83      tmp[2] = b - c;
84      tmp[3] = a - d;
85      tmp += 4;
86      in++;
87    }
88    tmp = C;
89    for (i = 0; i < 4; ++i) {    
90      const int dc = tmp[0] + 4;
91      const int a =  dc +  tmp[8];
92      const int b =  dc -  tmp[8];
93      const int c = MUL(tmp[4], kC2) - MUL(tmp[12], kC1);
94      const int d = MUL(tmp[4], kC1) + MUL(tmp[12], kC2);
95      STORE(0, i, a + d);
96      STORE(1, i, b + c);
97      STORE(2, i, b - c);
98      STORE(3, i, a - d);
99      tmp++;
100    }
101  }
102  static void ITransform_C(const uint8_t* ref, const int16_t* in, uint8_t* dst,
103                           int do_two) {
104    ITransformOne(ref, in, dst);
105    if (do_two) {
106      ITransformOne(ref + 4, in + 16, dst + 4);
107    }
108  }
109  static void FTransform_C(const uint8_t* src, const uint8_t* ref, int16_t* out) {
110    int i;
111    int tmp[16];
112    for (i = 0; i < 4; ++i, src += BPS, ref += BPS) {
113      const int d0 = src[0] - ref[0];   
114      const int d1 = src[1] - ref[1];
115      const int d2 = src[2] - ref[2];
116      const int d3 = src[3] - ref[3];
117      const int a0 = (d0 + d3);         
118      const int a1 = (d1 + d2);
119      const int a2 = (d1 - d2);
120      const int a3 = (d0 - d3);
121      tmp[0 + i * 4] = (a0 + a1) * 8;   
122      tmp[1 + i * 4] = (a2 * 2217 + a3 * 5352 + 1812) >> 9;      
123      tmp[2 + i * 4] = (a0 - a1) * 8;
124      tmp[3 + i * 4] = (a3 * 2217 - a2 * 5352 +  937) >> 9;
125    }
126    for (i = 0; i < 4; ++i) {
127      const int a0 = (tmp[0 + i] + tmp[12 + i]);  
128      const int a1 = (tmp[4 + i] + tmp[ 8 + i]);
129      const int a2 = (tmp[4 + i] - tmp[ 8 + i]);
130      const int a3 = (tmp[0 + i] - tmp[12 + i]);
131      out[0 + i] = (a0 + a1 + 7) >> 4;            
132      out[4 + i] = ((a2 * 2217 + a3 * 5352 + 12000) >> 16) + (a3 != 0);
133      out[8 + i] = (a0 - a1 + 7) >> 4;
134      out[12+ i] = ((a3 * 2217 - a2 * 5352 + 51000) >> 16);
135    }
136  }
137  #endif  
138  static void FTransform2_C(const uint8_t* src, const uint8_t* ref,
139                            int16_t* out) {
140    VP8FTransform(src, ref, out);
141    VP8FTransform(src + 4, ref + 4, out + 16);
142  }
143  #if !WEBP_NEON_OMIT_C_CODE
144  static void FTransformWHT_C(const int16_t* in, int16_t* out) {
145    int32_t tmp[16];
146    int i;
147    for (i = 0; i < 4; ++i, in += 64) {
148      const int a0 = (in[0 * 16] + in[2 * 16]);  
149      const int a1 = (in[1 * 16] + in[3 * 16]);
150      const int a2 = (in[1 * 16] - in[3 * 16]);
151      const int a3 = (in[0 * 16] - in[2 * 16]);
152      tmp[0 + i * 4] = a0 + a1;   
153      tmp[1 + i * 4] = a3 + a2;
154      tmp[2 + i * 4] = a3 - a2;
155      tmp[3 + i * 4] = a0 - a1;
156    }
157    for (i = 0; i < 4; ++i) {
158      const int a0 = (tmp[0 + i] + tmp[8 + i]);  
159      const int a1 = (tmp[4 + i] + tmp[12+ i]);
160      const int a2 = (tmp[4 + i] - tmp[12+ i]);
161      const int a3 = (tmp[0 + i] - tmp[8 + i]);
162      const int b0 = a0 + a1;    
163      const int b1 = a3 + a2;
164      const int b2 = a3 - a2;
165      const int b3 = a0 - a1;
166      out[ 0 + i] = b0 >> 1;     
167      out[ 4 + i] = b1 >> 1;
168      out[ 8 + i] = b2 >> 1;
169      out[12 + i] = b3 >> 1;
170    }
171  }
172  #endif  
173  #undef MUL
174  #undef STORE
175  static WEBP_INLINE void Fill(uint8_t* dst, int value, int size) {
176    int j;
177    for (j = 0; j < size; ++j) {
178      memset(dst + j * BPS, value, size);
179    }
180  }
181  static WEBP_INLINE void VerticalPred(uint8_t* dst,
182                                       const uint8_t* top, int size) {
183    int j;
184    if (top != NULL) {
185      for (j = 0; j < size; ++j) memcpy(dst + j * BPS, top, size);
186    } else {
187      Fill(dst, 127, size);
188    }
189  }
190  static WEBP_INLINE void HorizontalPred(uint8_t* dst,
191                                         const uint8_t* left, int size) {
192    if (left != NULL) {
193      int j;
194      for (j = 0; j < size; ++j) {
195        memset(dst + j * BPS, left[j], size);
196      }
197    } else {
198      Fill(dst, 129, size);
199    }
200  }
201  static WEBP_INLINE void TrueMotion(uint8_t* dst, const uint8_t* left,
202                                     const uint8_t* top, int size) {
203    int y;
204    if (left != NULL) {
205      if (top != NULL) {
206        const uint8_t* const clip = clip1 + 255 - left[-1];
207        for (y = 0; y < size; ++y) {
208          const uint8_t* const clip_table = clip + left[y];
209          int x;
210          for (x = 0; x < size; ++x) {
211            dst[x] = clip_table[top[x]];
212          }
213          dst += BPS;
214        }
215      } else {
216        HorizontalPred(dst, left, size);
217      }
218    } else {
219      if (top != NULL) {
220        VerticalPred(dst, top, size);
221      } else {
222        Fill(dst, 129, size);
223      }
224    }
225  }
226  static WEBP_INLINE void DCMode(uint8_t* dst, const uint8_t* left,
227                                 const uint8_t* top,
228                                 int size, int round, int shift) {
229    int DC = 0;
230    int j;
231    if (top != NULL) {
232      for (j = 0; j < size; ++j) DC += top[j];
233      if (left != NULL) {   
234        for (j = 0; j < size; ++j) DC += left[j];
235      } else {      
236        DC += DC;
237      }
238      DC = (DC + round) >> shift;
239    } else if (left != NULL) {   
240      for (j = 0; j < size; ++j) DC += left[j];
241      DC += DC;
242      DC = (DC + round) >> shift;
243    } else {   
244      DC = 0x80;
245    }
246    Fill(dst, DC, size);
247  }
248  static void IntraChromaPreds_C(uint8_t* dst, const uint8_t* left,
249                                 const uint8_t* top) {
250    DCMode(C8DC8 + dst, left, top, 8, 8, 4);
251    VerticalPred(C8VE8 + dst, top, 8);
252    HorizontalPred(C8HE8 + dst, left, 8);
253    TrueMotion(C8TM8 + dst, left, top, 8);
254    dst += 8;
255    if (top != NULL) top += 8;
256    if (left != NULL) left += 16;
257    DCMode(C8DC8 + dst, left, top, 8, 8, 4);
258    VerticalPred(C8VE8 + dst, top, 8);
259    HorizontalPred(C8HE8 + dst, left, 8);
260    TrueMotion(C8TM8 + dst, left, top, 8);
261  }
262  static void Intra16Preds_C(uint8_t* dst,
263                             const uint8_t* left, const uint8_t* top) {
264    DCMode(I16DC16 + dst, left, top, 16, 16, 5);
265    VerticalPred(I16VE16 + dst, top, 16);
266    HorizontalPred(I16HE16 + dst, left, 16);
267    TrueMotion(I16TM16 + dst, left, top, 16);
268  }
269  #define DST(x, y) dst[(x) + (y) * BPS]
270  #define AVG3(a, b, c) ((uint8_t)(((a) + 2 * (b) + (c) + 2) >> 2))
271  #define AVG2(a, b) (((a) + (b) + 1) >> 1)
272  static void VE4(uint8_t* dst, const uint8_t* top) {    
273    const uint8_t vals[4] = {
274      AVG3(top[-1], top[0], top[1]),
275      AVG3(top[ 0], top[1], top[2]),
276      AVG3(top[ 1], top[2], top[3]),
277      AVG3(top[ 2], top[3], top[4])
278    };
279    int i;
280    for (i = 0; i < 4; ++i) {
281      memcpy(dst + i * BPS, vals, 4);
282    }
283  }
284  static void HE4(uint8_t* dst, const uint8_t* top) {    
285    const int X = top[-1];
286    const int I = top[-2];
287    const int J = top[-3];
288    const int K = top[-4];
289    const int L = top[-5];
290    WebPUint32ToMem(dst + 0 * BPS, 0x01010101U * AVG3(X, I, J));
291    WebPUint32ToMem(dst + 1 * BPS, 0x01010101U * AVG3(I, J, K));
292    WebPUint32ToMem(dst + 2 * BPS, 0x01010101U * AVG3(J, K, L));
293    WebPUint32ToMem(dst + 3 * BPS, 0x01010101U * AVG3(K, L, L));
294  }
295  static void DC4(uint8_t* dst, const uint8_t* top) {
296    uint32_t dc = 4;
297    int i;
298    for (i = 0; i < 4; ++i) dc += top[i] + top[-5 + i];
299    Fill(dst, dc >> 3, 4);
300  }
301  static void RD4(uint8_t* dst, const uint8_t* top) {
302    const int X = top[-1];
303    const int I = top[-2];
304    const int J = top[-3];
305    const int K = top[-4];
306    const int L = top[-5];
307    const int A = top[0];
308    const int B = top[1];
309    const int C = top[2];
310    const int D = top[3];
311    DST(0, 3)                                     = AVG3(J, K, L);
312    DST(0, 2) = DST(1, 3)                         = AVG3(I, J, K);
313    DST(0, 1) = DST(1, 2) = DST(2, 3)             = AVG3(X, I, J);
314    DST(0, 0) = DST(1, 1) = DST(2, 2) = DST(3, 3) = AVG3(A, X, I);
315    DST(1, 0) = DST(2, 1) = DST(3, 2)             = AVG3(B, A, X);
316    DST(2, 0) = DST(3, 1)                         = AVG3(C, B, A);
317    DST(3, 0)                                     = AVG3(D, C, B);
318  }
319  static void LD4(uint8_t* dst, const uint8_t* top) {
320    const int A = top[0];
321    const int B = top[1];
322    const int C = top[2];
323    const int D = top[3];
324    const int E = top[4];
325    const int F = top[5];
326    const int G = top[6];
327    const int H = top[7];
328    DST(0, 0)                                     = AVG3(A, B, C);
329    DST(1, 0) = DST(0, 1)                         = AVG3(B, C, D);
330    DST(2, 0) = DST(1, 1) = DST(0, 2)             = AVG3(C, D, E);
331    DST(3, 0) = DST(2, 1) = DST(1, 2) = DST(0, 3) = AVG3(D, E, F);
332    DST(3, 1) = DST(2, 2) = DST(1, 3)             = AVG3(E, F, G);
333    DST(3, 2) = DST(2, 3)                         = AVG3(F, G, H);
334    DST(3, 3)                                     = AVG3(G, H, H);
335  }
336  static void VR4(uint8_t* dst, const uint8_t* top) {
337    const int X = top[-1];
338    const int I = top[-2];
339    const int J = top[-3];
340    const int K = top[-4];
341    const int A = top[0];
342    const int B = top[1];
343    const int C = top[2];
344    const int D = top[3];
345    DST(0, 0) = DST(1, 2) = AVG2(X, A);
346    DST(1, 0) = DST(2, 2) = AVG2(A, B);
347    DST(2, 0) = DST(3, 2) = AVG2(B, C);
348    DST(3, 0)             = AVG2(C, D);
349    DST(0, 3) =             AVG3(K, J, I);
350    DST(0, 2) =             AVG3(J, I, X);
351    DST(0, 1) = DST(1, 3) = AVG3(I, X, A);
352    DST(1, 1) = DST(2, 3) = AVG3(X, A, B);
353    DST(2, 1) = DST(3, 3) = AVG3(A, B, C);
354    DST(3, 1) =             AVG3(B, C, D);
355  }
356  static void VL4(uint8_t* dst, const uint8_t* top) {
357    const int A = top[0];
358    const int B = top[1];
359    const int C = top[2];
360    const int D = top[3];
361    const int E = top[4];
362    const int F = top[5];
363    const int G = top[6];
364    const int H = top[7];
365    DST(0, 0) =             AVG2(A, B);
366    DST(1, 0) = DST(0, 2) = AVG2(B, C);
367    DST(2, 0) = DST(1, 2) = AVG2(C, D);
368    DST(3, 0) = DST(2, 2) = AVG2(D, E);
369    DST(0, 1) =             AVG3(A, B, C);
370    DST(1, 1) = DST(0, 3) = AVG3(B, C, D);
371    DST(2, 1) = DST(1, 3) = AVG3(C, D, E);
372    DST(3, 1) = DST(2, 3) = AVG3(D, E, F);
373                DST(3, 2) = AVG3(E, F, G);
374                DST(3, 3) = AVG3(F, G, H);
375  }
376  static void HU4(uint8_t* dst, const uint8_t* top) {
377    const int I = top[-2];
378    const int J = top[-3];
379    const int K = top[-4];
380    const int L = top[-5];
381    DST(0, 0) =             AVG2(I, J);
382    DST(2, 0) = DST(0, 1) = AVG2(J, K);
383    DST(2, 1) = DST(0, 2) = AVG2(K, L);
384    DST(1, 0) =             AVG3(I, J, K);
385    DST(3, 0) = DST(1, 1) = AVG3(J, K, L);
386    DST(3, 1) = DST(1, 2) = AVG3(K, L, L);
387    DST(3, 2) = DST(2, 2) =
388    DST(0, 3) = DST(1, 3) = DST(2, 3) = DST(3, 3) = L;
389  }
390  static void HD4(uint8_t* dst, const uint8_t* top) {
391    const int X = top[-1];
392    const int I = top[-2];
393    const int J = top[-3];
394    const int K = top[-4];
395    const int L = top[-5];
396    const int A = top[0];
397    const int B = top[1];
398    const int C = top[2];
399    DST(0, 0) = DST(2, 1) = AVG2(I, X);
400    DST(0, 1) = DST(2, 2) = AVG2(J, I);
401    DST(0, 2) = DST(2, 3) = AVG2(K, J);
402    DST(0, 3)             = AVG2(L, K);
403    DST(3, 0)             = AVG3(A, B, C);
404    DST(2, 0)             = AVG3(X, A, B);
405    DST(1, 0) = DST(3, 1) = AVG3(I, X, A);
406    DST(1, 1) = DST(3, 2) = AVG3(J, I, X);
407    DST(1, 2) = DST(3, 3) = AVG3(K, J, I);
408    DST(1, 3)             = AVG3(L, K, J);
409  }
410  static void TM4(uint8_t* dst, const uint8_t* top) {
411    int x, y;
412    const uint8_t* const clip = clip1 + 255 - top[-1];
413    for (y = 0; y < 4; ++y) {
414      const uint8_t* const clip_table = clip + top[-2 - y];
415      for (x = 0; x < 4; ++x) {
416        dst[x] = clip_table[top[x]];
417      }
418      dst += BPS;
419    }
420  }
421  #undef DST
422  #undef AVG3
423  #undef AVG2
424  static void Intra4Preds_C(uint8_t* dst, const uint8_t* top) {
425    DC4(I4DC4 + dst, top);
426    TM4(I4TM4 + dst, top);
427    VE4(I4VE4 + dst, top);
428    HE4(I4HE4 + dst, top);
429    RD4(I4RD4 + dst, top);
430    VR4(I4VR4 + dst, top);
431    LD4(I4LD4 + dst, top);
432    VL4(I4VL4 + dst, top);
433    HD4(I4HD4 + dst, top);
434    HU4(I4HU4 + dst, top);
435  }
436  #if !WEBP_NEON_OMIT_C_CODE
437  static WEBP_INLINE int GetSSE(const uint8_t* a, const uint8_t* b,
438                                int w, int h) {
439    int count = 0;
440    int y, x;
441    for (y = 0; y < h; ++y) {
442      for (x = 0; x < w; ++x) {
443        const int diff = (int)a[x] - b[x];
444        count += diff * diff;
445      }
446      a += BPS;
447      b += BPS;
448    }
449    return count;
450  }
451  static int SSE16x16_C(const uint8_t* a, const uint8_t* b) {
452    return GetSSE(a, b, 16, 16);
453  }
454  static int SSE16x8_C(const uint8_t* a, const uint8_t* b) {
455    return GetSSE(a, b, 16, 8);
456  }
457  static int SSE8x8_C(const uint8_t* a, const uint8_t* b) {
458    return GetSSE(a, b, 8, 8);
459  }
460  static int SSE4x4_C(const uint8_t* a, const uint8_t* b) {
461    return GetSSE(a, b, 4, 4);
462  }
463  #endif  
464  static void Mean16x4_C(const uint8_t* ref, uint32_t dc[4]) {
465    int k, x, y;
466    for (k = 0; k < 4; ++k) {
467      uint32_t avg = 0;
468      for (y = 0; y < 4; ++y) {
469        for (x = 0; x < 4; ++x) {
470          avg += ref[x + y * BPS];
471        }
472      }
473      dc[k] = avg;
474      ref += 4;   
475    }
476  }
477  #if !WEBP_NEON_OMIT_C_CODE
478  static int TTransform(const uint8_t* in, const uint16_t* w) {
479    int sum = 0;
480    int tmp[16];
481    int i;
482    for (i = 0; i < 4; ++i, in += BPS) {
483      const int a0 = in[0] + in[2];
484      const int a1 = in[1] + in[3];
485      const int a2 = in[1] - in[3];
486      const int a3 = in[0] - in[2];
487      tmp[0 + i * 4] = a0 + a1;
488      tmp[1 + i * 4] = a3 + a2;
489      tmp[2 + i * 4] = a3 - a2;
490      tmp[3 + i * 4] = a0 - a1;
491    }
492    for (i = 0; i < 4; ++i, ++w) {
493      const int a0 = tmp[0 + i] + tmp[8 + i];
494      const int a1 = tmp[4 + i] + tmp[12+ i];
495      const int a2 = tmp[4 + i] - tmp[12+ i];
496      const int a3 = tmp[0 + i] - tmp[8 + i];
497      const int b0 = a0 + a1;
498      const int b1 = a3 + a2;
499      const int b2 = a3 - a2;
500      const int b3 = a0 - a1;
501      sum += w[ 0] * abs(b0);
502      sum += w[ 4] * abs(b1);
503      sum += w[ 8] * abs(b2);
504      sum += w[12] * abs(b3);
505    }
506    return sum;
507  }
508  static int Disto4x4_C(const uint8_t* const a, const uint8_t* const b,
509                        const uint16_t* const w) {
510    const int sum1 = TTransform(a, w);
511    const int sum2 = TTransform(b, w);
512    return abs(sum2 - sum1) >> 5;
513  }
514  static int Disto16x16_C(const uint8_t* const a, const uint8_t* const b,
515                          const uint16_t* const w) {
516    int D = 0;
517    int x, y;
518    for (y = 0; y < 16 * BPS; y += 4 * BPS) {
519      for (x = 0; x < 16; x += 4) {
520        D += Disto4x4_C(a + x + y, b + x + y, w);
521      }
522    }
523    return D;
524  }
525  #endif  
526  static const uint8_t kZigzag[16] = {
527    0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15
528  };
529  static int QuantizeBlock_C(int16_t in[16], int16_t out[16],
530                             const VP8Matrix* const mtx) {
531    int last = -1;
532    int n;
533    for (n = 0; n < 16; ++n) {
534      const int j = kZigzag[n];
535      const int sign = (in[j] < 0);
536      const uint32_t coeff = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
537      if (coeff > mtx->zthresh_[j]) {
538        const uint32_t Q = mtx->q_[j];
539        const uint32_t iQ = mtx->iq_[j];
540        const uint32_t B = mtx->bias_[j];
541        int level = QUANTDIV(coeff, iQ, B);
542        if (level > MAX_LEVEL) level = MAX_LEVEL;
543        if (sign) level = -level;
544        in[j] = level * (int)Q;
545        out[n] = level;
546        if (level) last = n;
547      } else {
548        out[n] = 0;
549        in[j] = 0;
550      }
551    }
552    return (last >= 0);
553  }
554  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
555  static int Quantize2Blocks_C(int16_t in[32], int16_t out[32],
556                               const VP8Matrix* const mtx) {
557    int nz;
558    nz  = VP8EncQuantizeBlock(in + 0 * 16, out + 0 * 16, mtx) << 0;
559    nz |= VP8EncQuantizeBlock(in + 1 * 16, out + 1 * 16, mtx) << 1;
560    return nz;
561  }
562  #endif  
563  static WEBP_INLINE void Copy(const uint8_t* src, uint8_t* dst, int w, int h) {
564    int y;
565    for (y = 0; y < h; ++y) {
566      memcpy(dst, src, w);
567      src += BPS;
568      dst += BPS;
569    }
570  }
571  static void Copy4x4_C(const uint8_t* src, uint8_t* dst) {
572    Copy(src, dst, 4, 4);
573  }
574  static void Copy16x8_C(const uint8_t* src, uint8_t* dst) {
575    Copy(src, dst, 16, 8);
576  }
577  VP8CHisto VP8CollectHistogram;
578  VP8Idct VP8ITransform;
579  VP8Fdct VP8FTransform;
580  VP8Fdct VP8FTransform2;
581  VP8WHT VP8FTransformWHT;
582  VP8Intra4Preds VP8EncPredLuma4;
583  VP8IntraPreds VP8EncPredLuma16;
584  VP8IntraPreds VP8EncPredChroma8;
585  VP8Metric VP8SSE16x16;
586  VP8Metric VP8SSE8x8;
587  VP8Metric VP8SSE16x8;
588  VP8Metric VP8SSE4x4;
589  VP8WMetric VP8TDisto4x4;
590  VP8WMetric VP8TDisto16x16;
591  VP8MeanMetric VP8Mean16x4;
592  VP8QuantizeBlock VP8EncQuantizeBlock;
593  VP8Quantize2Blocks VP8EncQuantize2Blocks;
594  VP8QuantizeBlockWHT VP8EncQuantizeBlockWHT;
595  VP8BlockCopy VP8Copy4x4;
596  VP8BlockCopy VP8Copy16x8;
597  extern void VP8EncDspInitSSE2(void);
598  extern void VP8EncDspInitSSE41(void);
599  extern void VP8EncDspInitNEON(void);
600  extern void VP8EncDspInitMIPS32(void);
601  extern void VP8EncDspInitMIPSdspR2(void);
602  extern void VP8EncDspInitMSA(void);
603  WEBP_DSP_INIT_FUNC(VP8EncDspInit) {
604    VP8DspInit();  
605    InitTables();
606  #if !WEBP_NEON_OMIT_C_CODE
607    VP8ITransform = ITransform_C;
608    VP8FTransform = FTransform_C;
609    VP8FTransformWHT = FTransformWHT_C;
610    VP8TDisto4x4 = Disto4x4_C;
611    VP8TDisto16x16 = Disto16x16_C;
612    VP8CollectHistogram = CollectHistogram_C;
613    VP8SSE16x16 = SSE16x16_C;
614    VP8SSE16x8 = SSE16x8_C;
615    VP8SSE8x8 = SSE8x8_C;
616    VP8SSE4x4 = SSE4x4_C;
617  #endif
618  #if !WEBP_NEON_OMIT_C_CODE || WEBP_NEON_WORK_AROUND_GCC
619    VP8EncQuantizeBlock = QuantizeBlock_C;
620    VP8EncQuantize2Blocks = Quantize2Blocks_C;
621  #endif
622    VP8FTransform2 = FTransform2_C;
623    VP8EncPredLuma4 = Intra4Preds_C;
624    VP8EncPredLuma16 = Intra16Preds_C;
625    VP8EncPredChroma8 = IntraChromaPreds_C;
626    VP8Mean16x4 = Mean16x4_C;
627    VP8EncQuantizeBlockWHT = QuantizeBlock_C;
628    VP8Copy4x4 = Copy4x4_C;
629    VP8Copy16x8 = Copy16x8_C;
630    if (VP8GetCPUInfo != NULL) {
631  #if defined(WEBP_USE_SSE2)
632      if (VP8GetCPUInfo(kSSE2)) {
633        VP8EncDspInitSSE2();
634  #if defined(WEBP_USE_SSE41)
635        if (VP8GetCPUInfo(kSSE4_1)) {
636          VP8EncDspInitSSE41();
637        }
638  #endif
639      }
640  #endif
641  #if defined(WEBP_USE_MIPS32)
642      if (VP8GetCPUInfo(kMIPS32)) {
643        VP8EncDspInitMIPS32();
644      }
645  #endif
646  #if defined(WEBP_USE_MIPS_DSP_R2)
647      if (VP8GetCPUInfo(kMIPSdspR2)) {
648        VP8EncDspInitMIPSdspR2();
649      }
650  #endif
651  #if defined(WEBP_USE_MSA)
652      if (VP8GetCPUInfo(kMSA)) {
653        VP8EncDspInitMSA();
654      }
655  #endif
656    }
657  #if defined(WEBP_USE_NEON)
658    if (WEBP_NEON_OMIT_C_CODE ||
659        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
660      VP8EncDspInitNEON();
661    }
662  #endif
663    assert(VP8ITransform != NULL);
664    assert(VP8FTransform != NULL);
665    assert(VP8FTransformWHT != NULL);
666    assert(VP8TDisto4x4 != NULL);
667    assert(VP8TDisto16x16 != NULL);
668    assert(VP8CollectHistogram != NULL);
<span onclick='openModal()' class='match'>669    assert(VP8SSE16x16 != NULL);
670    assert(VP8SSE16x8 != NULL);
671    assert(VP8SSE8x8 != NULL);
672    assert(VP8SSE4x4 != NULL);
673    assert(VP8EncQuantizeBlock != NULL);
674    assert(VP8EncQuantize2Blocks != NULL);
675    assert(VP8FTransform2 != NULL);
676    assert(VP8EncPredLuma4 != NULL);
677    assert(VP8EncPredLuma16 != NULL);
678    assert(VP8EncPredChroma8 != NULL);
679    assert(VP8Mean16x4 != NULL);
680    assert(VP8EncQuantizeBlockWHT != NULL);
681    assert(VP8Copy4x4 != NULL);
682    assert(VP8Copy16x8 != NULL);
683  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-idea.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-enc.c</div>
                </div>
                <div class="column column_space"><pre><code>13     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
14  };
</pre></code></div>
                <div class="column column_space"><pre><code>669    assert(VP8SSE16x16 != NULL);
670    assert(VP8SSE16x8 != NULL);
671    assert(VP8SSE8x8 != NULL);
672    assert(VP8SSE4x4 != NULL);
673    assert(VP8EncQuantizeBlock != NULL);
674    assert(VP8EncQuantize2Blocks != NULL);
675    assert(VP8FTransform2 != NULL);
676    assert(VP8EncPredLuma4 != NULL);
677    assert(VP8EncPredLuma16 != NULL);
678    assert(VP8EncPredChroma8 != NULL);
679    assert(VP8Mean16x4 != NULL);
680    assert(VP8EncQuantizeBlockWHT != NULL);
681    assert(VP8Copy4x4 != NULL);
682    assert(VP8Copy16x8 != NULL);
683  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    