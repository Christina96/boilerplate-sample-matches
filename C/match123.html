<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omlibdbi.c & omsnmp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omlibdbi.c & omsnmp.c
      </h3>
      <h1 align="center">
        22.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omlibdbi.c (22.048998%)<TH>omsnmp.c (22.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match123-0.html#0',2,'match123-1.html#0',3)" NAME="0">(521-532)<TD><A HREF="javascript:ZweiFrames('match123-0.html#0',2,'match123-1.html#0',3)" NAME="0">(465-476)</A><TD ALIGN=center><FONT COLOR="#ff0000">33</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match123-0.html#1',2,'match123-1.html#1',3)" NAME="1">(120-131)<TD><A HREF="javascript:ZweiFrames('match123-0.html#1',2,'match123-1.html#1',3)" NAME="1">(128-139)</A><TD ALIGN=center><FONT COLOR="#a20000">21</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match123-0.html#2',2,'match123-1.html#2',3)" NAME="2">(502-520)<TD><A HREF="javascript:ZweiFrames('match123-0.html#2',2,'match123-1.html#2',3)" NAME="2">(437-454)</A><TD ALIGN=center><FONT COLOR="#830000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match123-0.html#3',2,'match123-1.html#3',3)" NAME="3">(609-623)<TD><A HREF="javascript:ZweiFrames('match123-0.html#3',2,'match123-1.html#3',3)" NAME="3">(580-593)</A><TD ALIGN=center><FONT COLOR="#6c0000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match123-0.html#4',2,'match123-1.html#4',3)" NAME="4">(539-558)<TD><A HREF="javascript:ZweiFrames('match123-0.html#4',2,'match123-1.html#4',3)" NAME="4">(501-520)</A><TD ALIGN=center><FONT COLOR="#6c0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omlibdbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omlibdbi.c
 * This is the implementation of the dbi output module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * This depends on libdbi being present with the proper settings. Older
 * versions do not necessarily have them. Please visit this bug tracker
 * for details: http://bugzilla.adiscon.com/show_bug.cgi?id=31
 *
 * File begun on 2008-02-14 by RGerhards (extracted from syslogd.c)
 *
 * Copyright 2008-2016 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;libgen.h&gt;
#include &lt;dbi/dbi.h&gt;
#include &quot;dirty.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;conf.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;debug.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;conf.h&quot;

#undef HAVE_DBI_TXSUPP
/* transaction support disabled in v8 -- TODO: reenable */

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omlibdbi&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA
static int bDbiInitialized = 0;	/* dbi_initialize() can only be called one - this keeps track of it */

typedef struct _instanceData {
	uchar *dbiDrvrDir;	/* where do the dbi drivers reside? */
	dbi_conn conn;		/* handle to database */
	uchar *drvrName;	/* driver to use */
	uchar *host;		/* host to connect to */
	uchar *usrName;		/* user name for connect */
	uchar *pwd;		/* password for connect */
	uchar *dbName;		/* database to use */
	unsigned uLastDBErrno;	/* last errno returned by libdbi or 0 if all is well */
	uchar	*tplName;       /* format template to use */
	int txSupport;		/* transaction support */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *dbiDrvrDir;	/* global: where do the dbi drivers reside? */
	uchar *drvrName;	/* driver to use */
	uchar *host;		/* host to connect to */
	uchar *usrName;		/* user name for connect */
	uchar *pwd;		/* password for connect */
	uchar *dbName;		/* database to use */
} configSettings_t;
static configSettings_t cs;
uchar	*pszFileDfltTplName; /* name of the default template to use */

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	uchar *dbiDrvrDir;	/* where do the dbi drivers reside? */
	uchar 	*tplName;	/* default template */
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;


/* tables for interfacing with the v6 config system */
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;driverdirectory&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
<A NAME="1"></A>	};
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match123-1.html#1',3,'match123-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;server&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;db&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;uid&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;pwd&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;driver&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

/* this function gets the default template. It coordinates action between
 * old-style and new-style configuration parts.
 */
static uchar*
getDfltTpl(void)
{
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
		return loadModConf-&gt;tplName;
	else if(pszFileDfltTplName == NULL)
		return (uchar*)&quot; StdDBFmt&quot;;
	else
		return pszFileDfltTplName;
}


BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.dbiDrvrDir = NULL;
	cs.drvrName = NULL;
	cs.host = NULL;
	cs.usrName = NULL;
	cs.pwd = NULL;
	cs.dbName = NULL;
ENDinitConfVars


/* config settings */
#ifdef HAVE_DBI_R
static dbi_inst dbiInst;
#endif


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	/* we do not like repeated message reduction inside the database */
ENDisCompatibleWithFeature


/* The following function is responsible for closing a
 * database connection.
 */
static void closeConn(instanceData *pData)
{
	assert(pData != NULL);
	if(pData-&gt;conn != NULL) {	/* just to be on the safe side... */
		dbi_conn_close(pData-&gt;conn);
		pData-&gt;conn = NULL;
	}
}

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;drvrName);
	free(pData-&gt;host);
	free(pData-&gt;usrName);
	free(pData-&gt;pwd);
	free(pData-&gt;dbName);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	closeConn(pWrkrData-&gt;pData);
ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* nothing special here */
ENDdbgPrintInstInfo


/* log a database error with descriptive message.
 * We check if we have a valid database handle. If not, we simply
 * report an error, but can not be specific. RGerhards, 2007-01-30
 */
static void
reportDBError(instanceData *pData, int bSilent)
{
	unsigned uDBErrno;
	char errMsg[1024];
	const char *pszDbiErr;

	assert(pData != NULL);

	/* output log message */
	errno = 0;
	if(pData-&gt;conn == NULL) {
		LogError(0, NO_ERRCODE, &quot;unknown DB error occurred - could not obtain connection handle&quot;);
	} else { /* we can ask dbi for the error description... */
		uDBErrno = dbi_conn_error(pData-&gt;conn, &amp;pszDbiErr);
		snprintf(errMsg, sizeof(errMsg), &quot;db error (%d): %s\n&quot;, uDBErrno, pszDbiErr);
		if(bSilent || uDBErrno == pData-&gt;uLastDBErrno)
			dbgprintf(&quot;libdbi, DBError(silent): %s\n&quot;, errMsg);
		else {
			pData-&gt;uLastDBErrno = uDBErrno;
			LogError(0, NO_ERRCODE, &quot;%s&quot;, errMsg);
		}
	}

}


/* The following function is responsible for initializing a connection
 */
static rsRetVal initConn(instanceData *pData, int bSilent)
{
	DEFiRet;
	int iDrvrsLoaded;

	assert(pData != NULL);
	assert(pData-&gt;conn == NULL);

	if(bDbiInitialized == 0) {
		/* we need to init libdbi first */
#		ifdef HAVE_DBI_R
		iDrvrsLoaded = dbi_initialize_r((char*) pData-&gt;dbiDrvrDir, &amp;dbiInst);
#		else
		iDrvrsLoaded = dbi_initialize((char*) pData-&gt;dbiDrvrDir);
#		endif
		if(iDrvrsLoaded == 0) {
			LogError(0, RS_RET_SUSPENDED, &quot;libdbi error: libdbi or libdbi drivers not &quot;
			&quot;present on this system - suspending.&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		} else if(iDrvrsLoaded &lt; 0) {
			LogError(0, RS_RET_SUSPENDED, &quot;libdbi error: libdbi could not be &quot;
				&quot;initialized (do you have any dbi drivers installed?) - suspending.&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		bDbiInitialized = 1; /* we are done for the rest of our existence... */
	}

#	ifdef HAVE_DBI_R
	pData-&gt;conn = dbi_conn_new_r((char*)pData-&gt;drvrName, dbiInst);
#	else
	pData-&gt;conn = dbi_conn_new((char*)pData-&gt;drvrName);
#	endif
	if(pData-&gt;conn == NULL) {
		LogError(0, RS_RET_SUSPENDED, &quot;can not initialize libdbi connection&quot;);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	} else { /* we could get the handle, now on with work... */
		/* Connect to database */
		dbi_conn_set_option(pData-&gt;conn, &quot;host&quot;,     (char*) pData-&gt;host);
		dbi_conn_set_option(pData-&gt;conn, &quot;username&quot;, (char*) pData-&gt;usrName);

		/* libdbi-driver-sqlite(2/3) requires to provide sqlite3_db dir which is absolute
		   path, where database file lives,
		 * and dbname, which is database file name itself. So in order to keep the config API unchanged,
		 * we split the dbname to path and filename.
		 */
		int is_sqlite2 = !strcmp((const char *)pData-&gt;drvrName, &quot;sqlite&quot;);
		int is_sqlite3 = !strcmp((const char *)pData-&gt;drvrName, &quot;sqlite3&quot;);
		if(is_sqlite2 || is_sqlite3) {
			dbi_conn_set_option(pData-&gt;conn, is_sqlite3 ? &quot;sqlite3_dbdir&quot; : &quot;sqlite_dbdir&quot;,
							dirname((char *)pData-&gt;dbName));
			dbi_conn_set_option(pData-&gt;conn, &quot;dbname&quot;, basename((char *)pData-&gt;dbName ));
		} else {
			dbi_conn_set_option(pData-&gt;conn, &quot;dbname&quot;,   (char*) pData-&gt;dbName);
		}
		if(pData-&gt;pwd != NULL)
			dbi_conn_set_option(pData-&gt;conn, &quot;password&quot;, (char*) pData-&gt;pwd);
		if(dbi_conn_connect(pData-&gt;conn) &lt; 0) {
			reportDBError(pData, bSilent);
			closeConn(pData); /* ignore any error we may get */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		pData-&gt;txSupport = dbi_conn_cap_get(pData-&gt;conn, &quot;transaction_support&quot;);
	}

finalize_it:
	RETiRet;
}


/* The following function writes the current log entry
 * to an established database connection.
 */
static rsRetVal
writeDB(const uchar *psz, instanceData *const __restrict__ pData)
{
	DEFiRet;
	dbi_result dbiRes = NULL;

	assert(psz != NULL);
	assert(pData != NULL);

	/* see if we are ready to proceed */
	if(pData-&gt;conn == NULL) {
		CHKiRet(initConn(pData, 0));
	}

	/* try insert */
	if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) {
		/* error occurred, try to re-init connection and retry */
		closeConn(pData); /* close the current handle */
		CHKiRet(initConn(pData, 0)); /* try to re-open */
		if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) { /* re-try insert */
			/* we failed, giving up for now */
			reportDBError(pData, 0);
			closeConn(pData); /* free ressources */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}

finalize_it:
	if(iRet == RS_RET_OK) {
		pData-&gt;uLastDBErrno = 0; /* reset error for error supression */
	}

	if(dbiRes != NULL)
		dbi_result_free(dbiRes);

	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
		iRet = initConn(pWrkrData-&gt;pData, 1);
	}
ENDtryResume

/* transaction support 2013-03 */
BEGINbeginTransaction
CODESTARTbeginTransaction
	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
		CHKiRet(initConn(pWrkrData-&gt;pData, 0));
	}
#	ifdef HAVE_DBI_TXSUPP
	if (pData-&gt;txSupport == 1) {
		if (dbi_conn_transaction_begin(pData-&gt;conn) != 0) {
			const char *emsg;
			dbi_conn_error(pData-&gt;conn, &amp;emsg);
			dbgprintf(&quot;libdbi server error: begin transaction &quot;
				  &quot;not successful: %s\n&quot;, emsg);
			closeConn(pData);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
#	endif
finalize_it:
ENDbeginTransaction
/* end transaction */

BEGINdoAction
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	CHKiRet(writeDB(ppString[0], pWrkrData-&gt;pData));
#	ifdef HAVE_DBI_TXSUPP
	if (pData-&gt;txSupport == 1) {
		iRet = RS_RET_DEFER_COMMIT;
	}
#	endif
finalize_it:
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction

/* transaction support 2013-03 */
BEGINendTransaction
CODESTARTendTransaction
#	ifdef HAVE_DBI_TXSUPP
	if (dbi_conn_transaction_commit(pData-&gt;conn) != 0) {
		const char *emsg;
		dbi_conn_error(pData-&gt;conn, &amp;emsg);
		dbgprintf(&quot;libdbi server error: transaction not committed: %s\n&quot;,
			  emsg);
		closeConn(pData);
		iRet = RS_RET_SUSPENDED;
	}
#	endif
ENDendTransaction
/* end transaction */

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tplName = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;omlibdbi: error processing &quot;
			  	&quot;module config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for omlibdbi:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;template&quot;)) {
			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pszFileDfltTplName != NULL) {
				LogError(0, RS_RET_DUP_PARAM, &quot;omlibdbi: warning: default template &quot;
						&quot;was already set via legacy directive - may lead to inconsistent &quot;
						&quot;results.&quot;);
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;driverdirectory&quot;)) {
			loadModConf-&gt;dbiDrvrDir = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;omlibdbi: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.dbiDrvrDir);
	free(cs.drvrName);
	free(cs.host);
	free(cs.usrName);
	free(cs.pwd);
	free(cs.dbName);
	cs.dbiDrvrDir = NULL;
	cs.drvrName = NULL;
	cs.host = NULL;
	cs.usrName = NULL;
	cs.pwd = NULL;
	cs.dbName = NULL;
	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;dbiDrvrDir);
ENDfreeCnf




<A NAME="2"></A>static inline void
setInstParamDefaults(instanceData *pData)
{
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match123-1.html#2',3,'match123-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pData-&gt;tplName = NULL;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *tplToUse;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	CODE_STD_STRING_REQUESTnewActInst(1)
<A NAME="0"></A>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;</B></FONT>
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match123-1.html#0',3,'match123-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
			pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;db&quot;)) {
			pData-&gt;dbName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;uid&quot;)) {
			pData-&gt;usrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;pwd&quot;)) {
			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;driver&quot;)) {
			pData-&gt;drvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else {
			dbgprintf(&quot;omlibdbi: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
<A NAME="4"></A>		}
	}

<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match123-1.html#4',3,'match123-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	tplToUse = (pData-&gt;tplName == NULL) ? (uchar*)strdup((char*)getDfltTpl()) : pData-&gt;tplName;
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_RQD_TPL_OPT_SQL));
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(!strncmp((char*) p, &quot;:omlibdbi:&quot;, sizeof(&quot;:omlibdbi:&quot;) - 1)) {
		p += sizeof(&quot;:omlibdbi:&quot;) - 1; /* eat indicator sequence (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	CHKiRet(createInstance(&amp;pData));
	/* no create the instance based on what we currently have */
	if(cs.drvrName == NULL) {</B></FONT>
		LogError(0, RS_RET_NO_DRIVERNAME, &quot;omlibdbi: no db driver name given - action can not &quot;
				&quot;be created&quot;);
		ABORT_FINALIZE(RS_RET_NO_DRIVERNAME);
	}

	if((pData-&gt;drvrName = (uchar*) strdup((char*)cs.drvrName)) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	/* NULL values are supported because drivers have different needs.
	 * They will err out on connect. -- rgerhards, 2008-02-15
	 */
	if(cs.host != NULL)
		CHKmalloc(pData-&gt;host = (uchar*) strdup((char*)cs.host));
	if(cs.usrName != NULL)
		CHKmalloc(pData-&gt;usrName = (uchar*) strdup((char*)cs.usrName));
	if(cs.dbName != NULL)
		CHKmalloc(pData-&gt;dbName = (uchar*) strdup((char*)cs.dbName));
	if(cs.pwd != NULL)
		CHKmalloc(pData-&gt;pwd = (uchar*) strdup((char*)cs.pwd));
	if(cs.dbiDrvrDir != NULL)
		CHKmalloc(loadModConf-&gt;dbiDrvrDir = (uchar*) strdup((char*)cs.dbiDrvrDir));
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, getDfltTpl());
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	/* if we initialized libdbi, we now need to cleanup */
	if(bDbiInitialized) {
#		ifdef HAVE_DBI_R
		dbi_shutdown_r(dbiInst);
#		else
		dbi_shutdown();
#		endif
	}
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
ENDqueryEtryPt

<A NAME="3"></A>
/* Reset config variables for this module to default values.
 */
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match123-1.html#3',3,'match123-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.dbiDrvrDir);
	cs.dbiDrvrDir = NULL;
	free(cs.drvrName);
	cs.drvrName = NULL;
	free(cs.host);
	cs.host = NULL;
	free(cs.usrName);
	cs.usrName = NULL;
	free(cs.pwd);
	cs.pwd = NULL;
	free(cs.dbName);
	cs.dbName = NULL;</B></FONT>
	RETiRet;
}


BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
#	ifndef HAVE_DBI_TXSUPP
	DBGPRINTF(&quot;omlibdbi: no transaction support in libdbi\n&quot;);
#	endif
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;actionlibdbidriverdirectory&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.dbiDrvrDir,
	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionlibdbidriver&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.drvrName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionlibdbihost&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.host,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionlibdbiusername&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.usrName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionlibdbipassword&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pwd,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionlibdbidbname&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.dbName,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));
	DBGPRINTF(&quot;omlibdbi compiled with version %s loaded, libdbi version %s\n&quot;, VERSION, dbi_version());
ENDmodInit

/* vim:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omsnmp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omsnmp.c
 *
 * This module sends an snmp trap.
 *
 * Copyright 2007-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;

#include &lt;net-snmp/net-snmp-config.h&gt;
#include &lt;net-snmp/net-snmp-includes.h&gt;
#include &quot;omsnmp.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omsnmp&quot;)

/* internal structures
 */
DEF_OMOD_STATIC_DATA

static oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
static oid             objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };

/* 4 */
#define SNMP_SOURCETEMPLATE &quot;\&quot;%fromhost-ip%\&quot;&quot;


typedef struct _instanceData {
	uchar	*szTransport;		/* Transport - Can be udp, tcp, udp6, tcp6 and other types
					   supported by NET-SNMP */
	uchar	*szTarget;		/* IP/hostname of Snmp Target*/
	uchar	*szCommunity;		/* Snmp Community */
	uchar	*szEnterpriseOID;	/* Snmp Enterprise OID-default is (1.3.6.1.4.1.3.1.1 = enterprises.cmu.1.1) */
	uchar	*szSnmpTrapOID;		/* Snmp Trap OID - default is (1.3.6.1.4.1.19406.1.2.1 =
					   ADISCON-MONITORWARE-MIB::syslogtrap) */
	uchar	*szSyslogMessageOID;	/* Snmp OID used for the Syslog Message:
	        * default is 1.3.6.1.4.1.19406.1.1.2.1 - ADISCON-MONITORWARE-MIB::syslogMsg
		* You will need the ADISCON-MONITORWARE-MIB and ADISCON-MIB mibs installed on the receiver
		* side in order to decode this mib.
		* Downloads of these mib files can be found here:
		*	http://www.adiscon.org/download/ADISCON-MONITORWARE-MIB.txt
		*	http://www.adiscon.org/download/ADISCON-MIB.txt
		*/
	uchar	*szSnmpV1Source;	/* If PDU source property needs to be overwritten, only valid for SNMPv1*/

	int iPort;			/* Target Port */
	int iSNMPVersion;		/* SNMP Version to use */
	int iTrapType;			/* Snmp TrapType or GenericType */
	int iSpecificType;		/* Snmp Specific Type */

	uchar	*tplName;       	/* format template to use */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	netsnmp_session *snmpsession;	/* Holds to SNMP Session, NULL if not initialized */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar* pszTransport; /* default transport */
	uchar* pszTarget;
	/* note using an unsigned for a port number is not a good idea from an IPv6 point of view */
	int iPort;
	int iSNMPVersion;	/* 0 Means SNMPv1, 1 Means SNMPv2c */
	uchar* pszCommunity;
	uchar* pszEnterpriseOID;
	uchar* pszSnmpTrapOID;
	uchar* pszSyslogMessageOID;

	int iSpecificType;
	int iTrapType;		/*Default is SNMP_TRAP_ENTERPRISESPECIFIC */
	/*
				Possible Values
		SNMP_TRAP_COLDSTART		(0)
		SNMP_TRAP_WARMSTART		(1)
		SNMP_TRAP_LINKDOWN		(2)
		SNMP_TRAP_LINKUP		(3)
		SNMP_TRAP_AUTHFAIL		(4)
		SNMP_TRAP_EGPNEIGHBORLOSS	(5)
		SNMP_TRAP_ENTERPRISESPECIFIC	(6)
	*/
} configSettings_t;
static configSettings_t cs;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;server&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;port&quot;, eCmdHdlrInt, 0 },
	{ &quot;transport&quot;, eCmdHdlrString, 0 },
<A NAME="1"></A>	{ &quot;version&quot;, eCmdHdlrInt, 0 },
	{ &quot;community&quot;, eCmdHdlrString, 0 },
	{ &quot;enterpriseoid&quot;, eCmdHdlrString, 0 },
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match123-0.html#1',2,'match123-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;trapoid&quot;, eCmdHdlrString, 0 },
	{ &quot;messageoid&quot;, eCmdHdlrString, 0 },
	{ &quot;snmpv1dynsource&quot;, eCmdHdlrString, 0 },
	{ &quot;traptype&quot;, eCmdHdlrInt, 0 },
	{ &quot;specifictype&quot;, eCmdHdlrInt, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.pszTransport = NULL;
	cs.pszTarget = NULL;
	cs.iPort = 0;
	cs.iSNMPVersion = 1;
	cs.pszCommunity = NULL;
	cs.pszEnterpriseOID = NULL;
	cs.pszSnmpTrapOID = NULL;
	cs.pszSyslogMessageOID = NULL;
	cs.iSpecificType = 0;
	cs.iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
ENDinitConfVars

BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;snmpsession = NULL;
ENDcreateWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;SNMPTransport: %s\n&quot;, pData-&gt;szTransport);
	dbgprintf(&quot;SNMPTarget: %s\n&quot;, pData-&gt;szTarget);
	dbgprintf(&quot;SNMPPort: %d\n&quot;, pData-&gt;iPort);
	dbgprintf(&quot;SNMPVersion (0=v1, 1=v2c): %d\n&quot;, pData-&gt;iSNMPVersion);
	dbgprintf(&quot;Community: %s\n&quot;, pData-&gt;szCommunity);
	dbgprintf(&quot;EnterpriseOID: %s\n&quot;, pData-&gt;szEnterpriseOID);
	dbgprintf(&quot;SnmpTrapOID: %s\n&quot;, pData-&gt;szSnmpTrapOID);
	dbgprintf(&quot;SyslogMessageOID: %s\n&quot;, pData-&gt;szSyslogMessageOID);
	dbgprintf(&quot;SnmpV1Source: %s\n&quot;, pData-&gt;szSnmpV1Source);
	dbgprintf(&quot;TrapType: %d\n&quot;, pData-&gt;iTrapType);
	dbgprintf(&quot;SpecificType: %d\n&quot;, pData-&gt;iSpecificType);
ENDdbgPrintInstInfo


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	/* we are not compatible with repeated msg reduction feature, so do not allow it */
ENDisCompatibleWithFeature

/* Exit SNMP Session
 * alorbach, 2008-02-12
 */
static rsRetVal
omsnmp_exitSession(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;

	if(pWrkrData-&gt;snmpsession != NULL) {
		DBGPRINTF(&quot;omsnmp_exitSession: Clearing Session to '%s' on Port = '%d'\n&quot;,
			  pWrkrData-&gt;pData-&gt;szTarget, pWrkrData-&gt;pData-&gt;iPort);
		snmp_close(pWrkrData-&gt;snmpsession);
		pWrkrData-&gt;snmpsession = NULL;
	}

	RETiRet;
}

/* Init SNMP Session
 * alorbach, 2008-02-12
 */
static rsRetVal
omsnmp_initSession(wrkrInstanceData_t *pWrkrData)
{
	netsnmp_session session;
	instanceData *pData;
	char szTargetAndPort[MAXHOSTNAMELEN+128]; /* work buffer for specifying a full target and port string */
	DEFiRet;

	/* should not happen, but if session is not cleared yet - we do it now! */
	if (pWrkrData-&gt;snmpsession != NULL)
		omsnmp_exitSession(pWrkrData);

	pData = pWrkrData-&gt;pData;

	snprintf((char*)szTargetAndPort, sizeof(szTargetAndPort), &quot;%s:%s:%d&quot;,
			(pData-&gt;szTransport == NULL) ? &quot;udp&quot; : (char*)pData-&gt;szTransport,
			pData-&gt;szTarget, pData-&gt;iPort == 0 ? 162 : pData-&gt;iPort);

	dbgprintf( &quot;omsnmp_initSession: ENTER - Target = '%s' on Port = '%d'\n&quot;, pData-&gt;szTarget, pData-&gt;iPort);

	if (setenv(&quot;POSIXLY_CORRECT&quot;, &quot;1&quot;, 1) == -1)
		ABORT_FINALIZE(RS_RET_ERR);

	snmp_sess_init(&amp;session);
	session.version = pData-&gt;iSNMPVersion;
	session.callback = NULL; /* NOT NEEDED */
	session.callback_magic = NULL;
	session.peername = (char*) szTargetAndPort;

	/* Set SNMP Community */
	if (session.version == SNMP_VERSION_1 || session.version == SNMP_VERSION_2c) {
		session.community = (unsigned char *) pData-&gt;szCommunity
			== NULL ? (uchar*)&quot;public&quot; : pData-&gt;szCommunity;
		session.community_len = strlen((char*) session.community);
	}

	pWrkrData-&gt;snmpsession = snmp_open(&amp;session);
	if (pWrkrData-&gt;snmpsession == NULL) {
		LogError(0, RS_RET_SUSPENDED, &quot;omsnmp_initSession: snmp_open to host '%s' on Port '%d' &quot;
		&quot;failed\n&quot;, pData-&gt;szTarget, pData-&gt;iPort);
		/* Stay suspended */
		iRet = RS_RET_SUSPENDED;
	}

finalize_it:
	RETiRet;
}

static rsRetVal omsnmp_sendsnmp(wrkrInstanceData_t *pWrkrData, uchar *psz, uchar *pszSource)
{
	DEFiRet;

	netsnmp_pdu    *pdu = NULL;
	oid             enterpriseoid[MAX_OID_LEN];
	size_t          enterpriseoidlen = MAX_OID_LEN;
	oid				oidSyslogMessage[MAX_OID_LEN];
	size_t			oLen = MAX_OID_LEN;
	int             status;
	char            *trap = NULL;
	const char		*strErr = NULL;
	struct sockaddr_in srcAddr;
	instanceData *pData;

	pData = pWrkrData-&gt;pData;
	/* Init SNMP Session if necessary */
	if (pWrkrData-&gt;snmpsession == NULL) {
		CHKiRet(omsnmp_initSession(pWrkrData));
	}

	/* String should not be NULL */
	assert(psz != NULL);
	dbgprintf( &quot;omsnmp_sendsnmp: ENTER - Syslogmessage = '%s'\n&quot;, (char*)psz);

	/* If SNMP Version1 is configured !*/
	if(pWrkrData-&gt;snmpsession-&gt;version == SNMP_VERSION_1) {
		dbgprintf( &quot;omsnmp_sendsnmp: Create SNMPv1 Trap - Source = '%s'\n&quot;, (char*)pszSource);
		pdu = snmp_pdu_create(SNMP_MSG_TRAP);

		/* Set enterprise */
		if(!snmp_parse_oid(pData-&gt;szEnterpriseOID == NULL ? &quot;1.3.6.1.4.1.3.1.1&quot; :
			(char*)pData-&gt;szEnterpriseOID, enterpriseoid, &amp;enterpriseoidlen )) {
			strErr = snmp_api_errstring(snmp_errno);
			LogError(0, RS_RET_DISABLE_ACTION, &quot;omsnmp_sendsnmp: Parsing EnterpriseOID &quot;
					&quot;failed '%s' with error '%s' \n&quot;, pData-&gt;szSyslogMessageOID, strErr);
			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
		}
		CHKmalloc(pdu-&gt;enterprise = (oid *) malloc(enterpriseoidlen * sizeof(oid)));
		memcpy(pdu-&gt;enterprise, enterpriseoid, enterpriseoidlen * sizeof(oid));
		pdu-&gt;enterprise_length = enterpriseoidlen;

		/* Set Traptype */
		pdu-&gt;trap_type = pData-&gt;iTrapType;

		/* Set SpecificType */
		pdu-&gt;specific_type = pData-&gt;iSpecificType;

		/* Set Updtime */
		pdu-&gt;time = get_uptime();

		/* Set PDU SOurce property if available */
		if (pszSource != NULL) {
			if (inet_aton((const char *)pszSource, &amp;srcAddr.sin_addr) != 0) {
				pdu-&gt;agent_addr[0] = (srcAddr.sin_addr.s_addr) &amp; 0xFF;
				pdu-&gt;agent_addr[1] = (srcAddr.sin_addr.s_addr &gt;&gt; 8) &amp; 0xFF;
				pdu-&gt;agent_addr[2] = (srcAddr.sin_addr.s_addr &gt;&gt; 16) &amp; 0xFF;
				pdu-&gt;agent_addr[3] = (srcAddr.sin_addr.s_addr &gt;&gt; 24) &amp; 0xFF;
				dbgprintf( &quot;omsnmp_sendsnmp: SNMPv1 Source Property set to %d.%d.%d.%d\n&quot;,
					(srcAddr.sin_addr.s_addr) &amp; 0xFF,
					(srcAddr.sin_addr.s_addr &gt;&gt; 8) &amp; 0xFF,
					(srcAddr.sin_addr.s_addr &gt;&gt; 16) &amp; 0xFF,
					(srcAddr.sin_addr.s_addr &gt;&gt; 24) &amp; 0xFF);
			} else {
				LogError(0, NO_ERRCODE, &quot;omsnmp_sendsnmp: Failed to convert '%s' into a valid IPv4&quot;
					&quot;address\n&quot;, pszSource);
			}
		}
	}
	/* If SNMP Version2c is configured !*/
	else if (pWrkrData-&gt;snmpsession-&gt;version == SNMP_VERSION_2c)
	{
		long sysuptime;
		char csysuptime[20];
		dbgprintf( &quot;omsnmp_sendsnmp: Create SNMPv2 Trap\n&quot;);

		/* Create PDU */
		pdu = snmp_pdu_create(SNMP_MSG_TRAP2);

		/* Set uptime */
		sysuptime = get_uptime();
		snprintf( csysuptime, sizeof(csysuptime) , &quot;%ld&quot;, sysuptime);
		trap = csysuptime;
		snmp_add_var(pdu, objid_sysuptime, sizeof(objid_sysuptime) / sizeof(oid), 't', trap);

		/* Now set the SyslogMessage Trap OID */
		if ( snmp_add_var(pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid), 'o',
			pData-&gt;szSnmpTrapOID == NULL ?  &quot;1.3.6.1.4.1.19406.1.2.1&quot; : (char*) pData-&gt;szSnmpTrapOID
			) != 0) {
			strErr = snmp_api_errstring(snmp_errno);
			LogError(0, RS_RET_DISABLE_ACTION, &quot;omsnmp_sendsnmp: Adding trap OID failed '%s' &quot;
			&quot;with error '%s' \n&quot;, pData-&gt;szSnmpTrapOID, strErr);
			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
		}
	}

	/* SET TRAP PARAMETER for SyslogMessage! */

	/* First create new OID object */
	if (snmp_parse_oid(pData-&gt;szSyslogMessageOID == NULL ?
			    &quot;1.3.6.1.4.1.19406.1.1.2.1&quot; : (char*)pData-&gt;szSyslogMessageOID,
				oidSyslogMessage, &amp;oLen)) {
		int iErrCode = snmp_add_var(pdu, oidSyslogMessage, oLen, 's', (char*) psz);
		if (iErrCode) {
			const char *str = snmp_api_errstring(iErrCode);
			LogError(0, RS_RET_DISABLE_ACTION,  &quot;omsnmp_sendsnmp: Invalid SyslogMessage OID, &quot;
			&quot;error code '%d' - '%s'\n&quot;, iErrCode, str );
			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
		}
	} else {
		strErr = snmp_api_errstring(snmp_errno);
		LogError(0, RS_RET_DISABLE_ACTION, &quot;omsnmp_sendsnmp: Parsing SyslogMessageOID failed '%s' &quot;
		&quot;with error '%s' \n&quot;, pData-&gt;szSyslogMessageOID, strErr);

		ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
	}

	/* Send the TRAP */
	status = snmp_send(pWrkrData-&gt;snmpsession, pdu) == 0;
	if (status)
	{
		/* Debug Output! */
		int iErrorCode = pWrkrData-&gt;snmpsession-&gt;s_snmp_errno;
		LogError(0, RS_RET_SUSPENDED,  &quot;omsnmp_sendsnmp: snmp_send failed error '%d', &quot;
		&quot;Description='%s'\n&quot;, iErrorCode*(-1), api_errors[iErrorCode*(-1)]);

		/* Clear Session */
		omsnmp_exitSession(pWrkrData);

		ABORT_FINALIZE(RS_RET_SUSPENDED);
	} else {
		dbgprintf( &quot;omsnmp_sendsnmp: Successfully send SNMP Trap to %s:%d\n&quot;,
			pData-&gt;szTarget, pData-&gt;iPort);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pdu != NULL) {
			snmp_free_pdu(pdu);
		}
	}

	dbgprintf( &quot;omsnmp_sendsnmp: LEAVE\n&quot;);
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	iRet = omsnmp_initSession(pWrkrData);
ENDtryResume

BEGINdoAction
CODESTARTdoAction
	/* Abort if the STRING is not set, should never happen */
	if (ppString[0] == NULL) {
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}

	/* This will generate and send the SNMP Trap */
	iRet = omsnmp_sendsnmp(pWrkrData, ppString[0], ppString[1]);
finalize_it:
ENDdoAction

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tplName);
	free(pData-&gt;szTarget);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	omsnmp_exitSession(pWrkrData);
ENDfreeWrkrInstance

static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tplName = NULL;
	pData-&gt;szCommunity = NULL;
<A NAME="2"></A>	pData-&gt;szEnterpriseOID = NULL;
	pData-&gt;szSnmpTrapOID = NULL;
	pData-&gt;szSyslogMessageOID = NULL;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match123-0.html#2',2,'match123-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	pData-&gt;szSnmpV1Source = NULL;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTnewActInst(2)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;</B></FONT>
		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
			pData-&gt;szTarget = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
			pData-&gt;iPort = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;transport&quot;)) {
			pData-&gt;szTransport = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;version&quot;)) {
<A NAME="0"></A>			pData-&gt;iSNMPVersion = pvals[i].val.d.n;
			if(pData-&gt;iSNMPVersion &lt; 0 || cs.iSNMPVersion &gt; 1)
				pData-&gt;iSNMPVersion = 1;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match123-0.html#0',2,'match123-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;community&quot;)) {
			pData-&gt;szCommunity = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;enterpriseoid&quot;)) {
			pData-&gt;szEnterpriseOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;trapoid&quot;)) {
			pData-&gt;szSnmpTrapOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;messageoid&quot;)) {
			pData-&gt;szSyslogMessageOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;snmpv1dynsource&quot;)) {
			pData-&gt;szSnmpV1Source = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;traptype&quot;)) {
			pData-&gt;iTrapType = pvals[i].val.d.n;</B></FONT>
			if(cs.iTrapType &lt; 0 || cs.iTrapType &gt; 6) {
				parser_errmsg(&quot;omsnmp: traptype invalid, setting to ENTERPRISESPECIFIC&quot;);
				pData-&gt;iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;specifictype&quot;)) {
			pData-&gt;iSpecificType = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;ompipe: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	/* Init NetSNMP library and read in MIB database */
	init_snmp(&quot;rsyslog&quot;);

	/* Set some defaults in the NetSNMP library */
	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT, pData-&gt;iPort );

	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
<A NAME="4"></A>						&quot;RSYSLOG_FileFormat&quot; : (char*)pData-&gt;tplName),
						OMSR_NO_RQD_TPL_OPTS));

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match123-0.html#4',2,'match123-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	CHKiRet(OMSRsetEntry(*ppOMSR, 1, (uchar*)strdup((pData-&gt;szSnmpV1Source == NULL) ?
						&quot; SNMP_SOURCETEMPLATE&quot; : (char*)pData-&gt;szSnmpV1Source),
						OMSR_NO_RQD_TPL_OPTS));

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(!strncmp((char*) p, &quot;:omsnmp:&quot;, sizeof(&quot;:omsnmp:&quot;) - 1)) {
		p += sizeof(&quot;:omsnmp:&quot;) - 1; /* eat indicator sequence (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	if((iRet = createInstance(&amp;pData)) != RS_RET_OK)</B></FONT>
		FINALIZE;

	/* Check Target */
	if(cs.pszTarget == NULL) {
		ABORT_FINALIZE( RS_RET_PARAM_ERROR );
	} else {
		CHKmalloc(pData-&gt;szTarget = (uchar*) strdup((char*)cs.pszTarget));
	}

	/* copy config params */
	pData-&gt;szTransport = (uchar*) ((cs.pszTransport == NULL) ? NULL : strdup((char*)cs.pszTransport));
	pData-&gt;szCommunity = (uchar*) ((cs.pszCommunity == NULL) ? NULL : strdup((char*)cs.pszCommunity));
	pData-&gt;szEnterpriseOID = (uchar*) ((cs.pszEnterpriseOID == NULL) ? NULL : strdup((char*)cs.pszEnterpriseOID));
	pData-&gt;szSnmpTrapOID = (uchar*) ((cs.pszSnmpTrapOID == NULL) ? NULL : strdup((char*)cs.pszSnmpTrapOID));
	pData-&gt;szSyslogMessageOID = (uchar*) ((cs.pszSyslogMessageOID == NULL) ? NULL :
		strdup((char*)cs.pszSyslogMessageOID));
	pData-&gt;iPort = cs.iPort;
	pData-&gt;iSpecificType = cs.iSpecificType;

	/* Set SNMPVersion */
	if ( cs.iSNMPVersion &lt; 0 || cs.iSNMPVersion &gt; 1)		/* Set default to 1 if out of range */
		pData-&gt;iSNMPVersion = 1;
	else
		pData-&gt;iSNMPVersion = cs.iSNMPVersion;

	/* Copy TrapType */
	if ( cs.iTrapType &lt; 0 || cs.iTrapType &gt;= 6)		/* Only allow values from 0 to 6 !*/
		pData-&gt;iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
	else
		pData-&gt;iTrapType = cs.iTrapType;

	/* Print Debug info */
	dbgprintf(&quot;SNMPTransport: %s\n&quot;, pData-&gt;szTransport);
	dbgprintf(&quot;SNMPTarget: %s\n&quot;, pData-&gt;szTarget);
	dbgprintf(&quot;SNMPPort: %d\n&quot;, pData-&gt;iPort);
	dbgprintf(&quot;SNMPVersion (0=v1, 1=v2c): %d\n&quot;, pData-&gt;iSNMPVersion);
	dbgprintf(&quot;Community: %s\n&quot;, pData-&gt;szCommunity);
	dbgprintf(&quot;EnterpriseOID: %s\n&quot;, pData-&gt;szEnterpriseOID);
	dbgprintf(&quot;SnmpTrapOID: %s\n&quot;, pData-&gt;szSnmpTrapOID);
	dbgprintf(&quot;SyslogMessageOID: %s\n&quot;, pData-&gt;szSyslogMessageOID);
	dbgprintf(&quot;SnmpV1Source: %s\n&quot;, pData-&gt;szSnmpV1Source);
	dbgprintf(&quot;TrapType: %d\n&quot;, pData-&gt;iTrapType);
	dbgprintf(&quot;SpecificType: %d\n&quot;, pData-&gt;iSpecificType);

	/* process template */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS,
		(uchar*) &quot;RSYSLOG_TraditionalForwardFormat&quot;));

	/* Init NetSNMP library and read in MIB database */
	init_snmp(&quot;rsyslog&quot;);

	/* Set some defaults in the NetSNMP library */
	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT, pData-&gt;iPort );
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct

<A NAME="3"></A>
/* Reset config variables for this module to default values.
 */
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match123-0.html#3',2,'match123-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.pszTarget);
	cs.pszTarget = NULL;
	free(cs.pszCommunity);
	cs.pszCommunity = NULL;
	free(cs.pszEnterpriseOID);
	cs.pszEnterpriseOID = NULL;
	free(cs.pszSnmpTrapOID);
	cs.pszSnmpTrapOID = NULL;
	free(cs.pszSyslogMessageOID);
	cs.pszSyslogMessageOID = NULL;
	cs.iPort = 0;</B></FONT>
	cs.iSNMPVersion = 1;
	cs.iSpecificType = 0;
	cs.iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
	RETiRet;
}


BEGINmodExit
CODESTARTmodExit
	free(cs.pszTarget);
	free(cs.pszCommunity);
	free(cs.pszEnterpriseOID);
	free(cs.pszSnmpTrapOID);
	free(cs.pszSyslogMessageOID);

	/* release what we no longer need */
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	uchar *pTmp;
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	initConfVars();

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmptransport&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszTransport,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmptarget&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszTarget,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmptargetport&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iPort,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmpversion&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iSNMPVersion,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmpcommunity&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszCommunity,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmpenterpriseoid&quot;, 0, eCmdHdlrGetWord, NULL,
	&amp;cs.pszEnterpriseOID, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmptrapoid&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszSnmpTrapOID,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmpsyslogmessageoid&quot;, 0, eCmdHdlrGetWord, NULL,
	&amp;cs.pszSyslogMessageOID, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmpspecifictype&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iSpecificType,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionsnmptraptype&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iTrapType,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));

	DBGPRINTF(&quot;omsnmp: Add SNMP_SOURCETEMPLATE to template system ONCE\n&quot;);
	pTmp = (uchar*) SNMP_SOURCETEMPLATE;
	tplAddLine(ourConf, &quot; SNMP_SOURCETEMPLATE&quot;, &amp;pTmp);
ENDmodInit
/*
 * vi:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
