<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omlibdbi.c &amp; omsnmp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omlibdbi.c &amp; omsnmp.c
      </h3>
<h1 align="center">
        22.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omlibdbi.c (22.048998%)<th>omsnmp.c (22.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(521-532)<td><a href="#" name="0">(465-476)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(120-131)<td><a href="#" name="1">(128-139)</a><td align="center"><font color="#a20000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(502-520)<td><a href="#" name="2">(437-454)</a><td align="center"><font color="#830000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(609-623)<td><a href="#" name="3">(580-593)</a><td align="center"><font color="#6c0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(539-558)<td><a href="#" name="4">(501-520)</a><td align="center"><font color="#6c0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omlibdbi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;time.h&gt;
11 #include &lt;libgen.h&gt;
12 #include &lt;dbi/dbi.h&gt;
13 #include "dirty.h"
14 #include "syslogd-types.h"
15 #include "cfsysline.h"
16 #include "conf.h"
17 #include "srUtils.h"
18 #include "template.h"
19 #include "module-template.h"
20 #include "debug.h"
21 #include "errmsg.h"
22 #include "conf.h"
23 #undef HAVE_DBI_TXSUPP
24 MODULE_TYPE_OUTPUT
25 MODULE_TYPE_NOKEEP
26 MODULE_CNFNAME("omlibdbi")
27 DEF_OMOD_STATIC_DATA
28 static int bDbiInitialized = 0;	
29 typedef struct _instanceData {
30 	uchar *dbiDrvrDir;		dbi_conn conn;			uchar *drvrName;		uchar *host;			uchar *usrName;			uchar *pwd;			uchar *dbName;			unsigned uLastDBErrno;		uchar	*tplName;       	int txSupport;		} instanceData;
31 typedef struct wrkrInstanceData {
32 	instanceData *pData;
33 } wrkrInstanceData_t;
34 typedef struct configSettings_s {
35 	uchar *dbiDrvrDir;		uchar *drvrName;		uchar *host;			uchar *usrName;			uchar *pwd;			uchar *dbName;		} configSettings_t;
36 static configSettings_t cs;
37 uchar	*pszFileDfltTplName; 
38 struct modConfData_s {
39 	rsconf_t *pConf;		uchar *dbiDrvrDir;		uchar 	*tplName;	};
40 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static int bLegacyCnfModGlobalsPermitted;
41 static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;
42 static struct cnfparamdescr modpdescr[] = {
43 	{ "template", eCmdHdlrGetWord, 0 },
44 	{ "driverdirectory", eCmdHdlrGetWord, 0 }
45 };
46 static struct cnfparamblk modpblk =
47 	{ CNFPARAMBLK_VERSION,
48 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
49 	  modpdescr
50 <a name="1"></a>	};
51 static struct cnfparamdescr actpdescr[] = {
52 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "server", eCmdHdlrGetWord, 1 },
53 	{ "db", eCmdHdlrGetWord, 1 },
54 	{ "uid", eCmdHdlrGetWord, 1 },
55 	{ "pwd", eCmdHdlrGetWord, 1 },
56 	{ "driver", eCmdHdlrGetWord, 1 },
57 	{ "template", eCmdHdlrGetWord, 0 }
58 };
59 static struct cnfparamblk actpblk =
60 	{ CNFPARAMBLK_VERSION,
61 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
62 	  actpdescr
63 	};</b></font>
64 static uchar*
65 getDfltTpl(void)
66 {
67 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
68 		return loadModConf-&gt;tplName;
69 	else if(pszFileDfltTplName == NULL)
70 		return (uchar*)" StdDBFmt";
71 	else
72 		return pszFileDfltTplName;
73 }
74 BEGINinitConfVars		CODESTARTinitConfVars
75 	cs.dbiDrvrDir = NULL;
76 	cs.drvrName = NULL;
77 	cs.host = NULL;
78 	cs.usrName = NULL;
79 	cs.pwd = NULL;
80 	cs.dbName = NULL;
81 ENDinitConfVars
82 #ifdef HAVE_DBI_R
83 static dbi_inst dbiInst;
84 #endif
85 BEGINcreateInstance
86 CODESTARTcreateInstance
87 ENDcreateInstance
88 BEGINcreateWrkrInstance
89 CODESTARTcreateWrkrInstance
90 ENDcreateWrkrInstance
91 BEGINisCompatibleWithFeature
92 CODESTARTisCompatibleWithFeature
93 ENDisCompatibleWithFeature
94 static void closeConn(instanceData *pData)
95 {
96 	assert(pData != NULL);
97 	if(pData-&gt;conn != NULL) {			dbi_conn_close(pData-&gt;conn);
98 		pData-&gt;conn = NULL;
99 	}
100 }
101 BEGINfreeInstance
102 CODESTARTfreeInstance
103 	free(pData-&gt;drvrName);
104 	free(pData-&gt;host);
105 	free(pData-&gt;usrName);
106 	free(pData-&gt;pwd);
107 	free(pData-&gt;dbName);
108 ENDfreeInstance
109 BEGINfreeWrkrInstance
110 CODESTARTfreeWrkrInstance
111 	closeConn(pWrkrData-&gt;pData);
112 ENDfreeWrkrInstance
113 BEGINdbgPrintInstInfo
114 CODESTARTdbgPrintInstInfo
115 ENDdbgPrintInstInfo
116 static void
117 reportDBError(instanceData *pData, int bSilent)
118 {
119 	unsigned uDBErrno;
120 	char errMsg[1024];
121 	const char *pszDbiErr;
122 	assert(pData != NULL);
123 	errno = 0;
124 	if(pData-&gt;conn == NULL) {
125 		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain connection handle");
126 	} else { 		uDBErrno = dbi_conn_error(pData-&gt;conn, &amp;pszDbiErr);
127 		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", uDBErrno, pszDbiErr);
128 		if(bSilent || uDBErrno == pData-&gt;uLastDBErrno)
129 			dbgprintf("libdbi, DBError(silent): %s\n", errMsg);
130 		else {
131 			pData-&gt;uLastDBErrno = uDBErrno;
132 			LogError(0, NO_ERRCODE, "%s", errMsg);
133 		}
134 	}
135 }
136 static rsRetVal initConn(instanceData *pData, int bSilent)
137 {
138 	DEFiRet;
139 	int iDrvrsLoaded;
140 	assert(pData != NULL);
141 	assert(pData-&gt;conn == NULL);
142 	if(bDbiInitialized == 0) {
143 #		ifdef HAVE_DBI_R
144 		iDrvrsLoaded = dbi_initialize_r((char*) pData-&gt;dbiDrvrDir, &amp;dbiInst);
145 #		else
146 		iDrvrsLoaded = dbi_initialize((char*) pData-&gt;dbiDrvrDir);
147 #		endif
148 		if(iDrvrsLoaded == 0) {
149 			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi or libdbi drivers not "
150 			"present on this system - suspending.");
151 			ABORT_FINALIZE(RS_RET_SUSPENDED);
152 		} else if(iDrvrsLoaded &lt; 0) {
153 			LogError(0, RS_RET_SUSPENDED, "libdbi error: libdbi could not be "
154 				"initialized (do you have any dbi drivers installed?) - suspending.");
155 			ABORT_FINALIZE(RS_RET_SUSPENDED);
156 		}
157 		bDbiInitialized = 1; 	}
158 #	ifdef HAVE_DBI_R
159 	pData-&gt;conn = dbi_conn_new_r((char*)pData-&gt;drvrName, dbiInst);
160 #	else
161 	pData-&gt;conn = dbi_conn_new((char*)pData-&gt;drvrName);
162 #	endif
163 	if(pData-&gt;conn == NULL) {
164 		LogError(0, RS_RET_SUSPENDED, "can not initialize libdbi connection");
165 		ABORT_FINALIZE(RS_RET_SUSPENDED);
166 	} else { 		dbi_conn_set_option(pData-&gt;conn, "host",     (char*) pData-&gt;host);
167 		dbi_conn_set_option(pData-&gt;conn, "username", (char*) pData-&gt;usrName);
168 		int is_sqlite2 = !strcmp((const char *)pData-&gt;drvrName, "sqlite");
169 		int is_sqlite3 = !strcmp((const char *)pData-&gt;drvrName, "sqlite3");
170 		if(is_sqlite2 || is_sqlite3) {
171 			dbi_conn_set_option(pData-&gt;conn, is_sqlite3 ? "sqlite3_dbdir" : "sqlite_dbdir",
172 							dirname((char *)pData-&gt;dbName));
173 			dbi_conn_set_option(pData-&gt;conn, "dbname", basename((char *)pData-&gt;dbName ));
174 		} else {
175 			dbi_conn_set_option(pData-&gt;conn, "dbname",   (char*) pData-&gt;dbName);
176 		}
177 		if(pData-&gt;pwd != NULL)
178 			dbi_conn_set_option(pData-&gt;conn, "password", (char*) pData-&gt;pwd);
179 		if(dbi_conn_connect(pData-&gt;conn) &lt; 0) {
180 			reportDBError(pData, bSilent);
181 			closeConn(pData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
182 		}
183 		pData-&gt;txSupport = dbi_conn_cap_get(pData-&gt;conn, "transaction_support");
184 	}
185 finalize_it:
186 	RETiRet;
187 }
188 static rsRetVal
189 writeDB(const uchar *psz, instanceData *const __restrict__ pData)
190 {
191 	DEFiRet;
192 	dbi_result dbiRes = NULL;
193 	assert(psz != NULL);
194 	assert(pData != NULL);
195 	if(pData-&gt;conn == NULL) {
196 		CHKiRet(initConn(pData, 0));
197 	}
198 	if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) {
199 		closeConn(pData); 		CHKiRet(initConn(pData, 0)); 		if((dbiRes = dbi_conn_query(pData-&gt;conn, (const char*)psz)) == NULL) { 			reportDBError(pData, 0);
200 			closeConn(pData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
201 		}
202 	}
203 finalize_it:
204 	if(iRet == RS_RET_OK) {
205 		pData-&gt;uLastDBErrno = 0; 	}
206 	if(dbiRes != NULL)
207 		dbi_result_free(dbiRes);
208 	RETiRet;
209 }
210 BEGINtryResume
211 CODESTARTtryResume
212 	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
213 		iRet = initConn(pWrkrData-&gt;pData, 1);
214 	}
215 ENDtryResume
216 BEGINbeginTransaction
217 CODESTARTbeginTransaction
218 	if(pWrkrData-&gt;pData-&gt;conn == NULL) {
219 		CHKiRet(initConn(pWrkrData-&gt;pData, 0));
220 	}
221 #	ifdef HAVE_DBI_TXSUPP
222 	if (pData-&gt;txSupport == 1) {
223 		if (dbi_conn_transaction_begin(pData-&gt;conn) != 0) {
224 			const char *emsg;
225 			dbi_conn_error(pData-&gt;conn, &amp;emsg);
226 			dbgprintf("libdbi server error: begin transaction "
227 				  "not successful: %s\n", emsg);
228 			closeConn(pData);
229 			ABORT_FINALIZE(RS_RET_SUSPENDED);
230 		}
231 	}
232 #	endif
233 finalize_it:
234 ENDbeginTransaction
235 BEGINdoAction
236 CODESTARTdoAction
237 	pthread_mutex_lock(&amp;mutDoAct);
238 	CHKiRet(writeDB(ppString[0], pWrkrData-&gt;pData));
239 #	ifdef HAVE_DBI_TXSUPP
240 	if (pData-&gt;txSupport == 1) {
241 		iRet = RS_RET_DEFER_COMMIT;
242 	}
243 #	endif
244 finalize_it:
245 	pthread_mutex_unlock(&amp;mutDoAct);
246 ENDdoAction
247 BEGINendTransaction
248 CODESTARTendTransaction
249 #	ifdef HAVE_DBI_TXSUPP
250 	if (dbi_conn_transaction_commit(pData-&gt;conn) != 0) {
251 		const char *emsg;
252 		dbi_conn_error(pData-&gt;conn, &amp;emsg);
253 		dbgprintf("libdbi server error: transaction not committed: %s\n",
254 			  emsg);
255 		closeConn(pData);
256 		iRet = RS_RET_SUSPENDED;
257 	}
258 #	endif
259 ENDendTransaction
260 BEGINbeginCnfLoad
261 CODESTARTbeginCnfLoad
262 	loadModConf = pModConf;
263 	pModConf-&gt;pConf = pConf;
264 	pModConf-&gt;tplName = NULL;
265 	bLegacyCnfModGlobalsPermitted = 1;
266 ENDbeginCnfLoad
267 BEGINsetModCnf
268 	struct cnfparamvals *pvals = NULL;
269 	int i;
270 CODESTARTsetModCnf
271 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
272 	if(pvals == NULL) {
273 		LogError(0, RS_RET_MISSING_CNFPARAMS, "omlibdbi: error processing "
274 			  	"module config parameters [module(...)]");
275 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
276 	}
277 	if(Debug) {
278 		dbgprintf("module (global) param blk for omlibdbi:\n");
279 		cnfparamsPrint(&amp;modpblk, pvals);
280 	}
281 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
282 		if(!pvals[i].bUsed)
283 			continue;
284 		if(!strcmp(modpblk.descr[i].name, "template")) {
285 			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
286 			if(pszFileDfltTplName != NULL) {
287 				LogError(0, RS_RET_DUP_PARAM, "omlibdbi: warning: default template "
288 						"was already set via legacy directive - may lead to inconsistent "
289 						"results.");
290 			}
291 		} else if(!strcmp(modpblk.descr[i].name, "driverdirectory")) {
292 			loadModConf-&gt;dbiDrvrDir = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
293 		} else {
294 			dbgprintf("omlibdbi: program error, non-handled "
295 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
296 		}
297 	}
298 	bLegacyCnfModGlobalsPermitted = 0;
299 finalize_it:
300 	if(pvals != NULL)
301 		cnfparamvalsDestruct(pvals, &amp;modpblk);
302 ENDsetModCnf
303 BEGINendCnfLoad
304 CODESTARTendCnfLoad
305 	loadModConf = NULL; 	free(cs.dbiDrvrDir);
306 	free(cs.drvrName);
307 	free(cs.host);
308 	free(cs.usrName);
309 	free(cs.pwd);
310 	free(cs.dbName);
311 	cs.dbiDrvrDir = NULL;
312 	cs.drvrName = NULL;
313 	cs.host = NULL;
314 	cs.usrName = NULL;
315 	cs.pwd = NULL;
316 	cs.dbName = NULL;
317 	free(pszFileDfltTplName);
318 	pszFileDfltTplName = NULL;
319 ENDendCnfLoad
320 BEGINcheckCnf
321 CODESTARTcheckCnf
322 ENDcheckCnf
323 BEGINactivateCnf
324 CODESTARTactivateCnf
325 	runModConf = pModConf;
326 ENDactivateCnf
327 BEGINfreeCnf
328 CODESTARTfreeCnf
329 	free(pModConf-&gt;tplName);
330 	free(pModConf-&gt;dbiDrvrDir);
331 ENDfreeCnf
332 <a name="2"></a>static inline void
333 setInstParamDefaults(instanceData *pData)
334 {
335 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pData-&gt;tplName = NULL;
336 }
337 BEGINnewActInst
338 	struct cnfparamvals *pvals;
339 	uchar *tplToUse;
340 	int i;
341 CODESTARTnewActInst
342 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
343 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
344 	}
345 	CHKiRet(createInstance(&amp;pData));
346 	setInstParamDefaults(pData);
347 	CODE_STD_STRING_REQUESTnewActInst(1)
348 <a name="0"></a>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
349 		if(!pvals[i].bUsed)
350 			continue;</b></font>
351 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if(!strcmp(actpblk.descr[i].name, "server")) {
352 			pData-&gt;host = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
353 		} else if(!strcmp(actpblk.descr[i].name, "db")) {
354 			pData-&gt;dbName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
355 		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
356 			pData-&gt;usrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
357 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
358 			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
359 		} else if(!strcmp(actpblk.descr[i].name, "driver")) {
360 			pData-&gt;drvrName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
361 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
362 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
363 		} else {
364 			dbgprintf("omlibdbi: program error, non-handled "
365 			  "param '%s'\n", actpblk.descr[i].name);
366 <a name="4"></a>		}
367 	}
368 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	tplToUse = (pData-&gt;tplName == NULL) ? (uchar*)strdup((char*)getDfltTpl()) : pData-&gt;tplName;
369 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_RQD_TPL_OPT_SQL));
370 CODE_STD_FINALIZERnewActInst
371 	cnfparamvalsDestruct(pvals, &amp;actpblk);
372 ENDnewActInst
373 BEGINparseSelectorAct
374 CODESTARTparseSelectorAct
375 CODE_STD_STRING_REQUESTparseSelectorAct(1)
376 	if(!strncmp((char*) p, ":omlibdbi:", sizeof(":omlibdbi:") - 1)) {
377 		p += sizeof(":omlibdbi:") - 1; 	} else {
378 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
379 	}
380 	CHKiRet(createInstance(&amp;pData));
381 	if(cs.drvrName == NULL) {</b></font>
382 		LogError(0, RS_RET_NO_DRIVERNAME, "omlibdbi: no db driver name given - action can not "
383 				"be created");
384 		ABORT_FINALIZE(RS_RET_NO_DRIVERNAME);
385 	}
386 	if((pData-&gt;drvrName = (uchar*) strdup((char*)cs.drvrName)) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
387 	if(cs.host != NULL)
388 		CHKmalloc(pData-&gt;host = (uchar*) strdup((char*)cs.host));
389 	if(cs.usrName != NULL)
390 		CHKmalloc(pData-&gt;usrName = (uchar*) strdup((char*)cs.usrName));
391 	if(cs.dbName != NULL)
392 		CHKmalloc(pData-&gt;dbName = (uchar*) strdup((char*)cs.dbName));
393 	if(cs.pwd != NULL)
394 		CHKmalloc(pData-&gt;pwd = (uchar*) strdup((char*)cs.pwd));
395 	if(cs.dbiDrvrDir != NULL)
396 		CHKmalloc(loadModConf-&gt;dbiDrvrDir = (uchar*) strdup((char*)cs.dbiDrvrDir));
397 	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, getDfltTpl());
398 CODE_STD_FINALIZERparseSelectorAct
399 ENDparseSelectorAct
400 BEGINmodExit
401 CODESTARTmodExit
402 	if(bDbiInitialized) {
403 #		ifdef HAVE_DBI_R
404 		dbi_shutdown_r(dbiInst);
405 #		else
406 		dbi_shutdown();
407 #		endif
408 	}
409 ENDmodExit
410 BEGINqueryEtryPt
411 CODESTARTqueryEtryPt
412 CODEqueryEtryPt_STD_OMOD_QUERIES
413 CODEqueryEtryPt_STD_OMOD8_QUERIES
414 CODEqueryEtryPt_STD_CONF2_QUERIES
415 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
416 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
417 CODEqueryEtryPt_TXIF_OMOD_QUERIES ENDqueryEtryPt
418 <a name="3"></a>
419 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
420 {
421 	DEFiRet;
422 	free(cs.dbiDrvrDir);
423 	cs.dbiDrvrDir = NULL;
424 	free(cs.drvrName);
425 	cs.drvrName = NULL;
426 	free(cs.host);
427 	cs.host = NULL;
428 	free(cs.usrName);
429 	cs.usrName = NULL;
430 	free(cs.pwd);
431 	cs.pwd = NULL;
432 	free(cs.dbName);
433 	cs.dbName = NULL;</b></font>
434 	RETiRet;
435 }
436 BEGINmodInit()
437 CODESTARTmodInit
438 INITLegCnfVars
439 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
440 #	ifndef HAVE_DBI_TXSUPP
441 	DBGPRINTF("omlibdbi: no transaction support in libdbi\n");
442 #	endif
443 	CHKiRet(regCfSysLineHdlr2((uchar *)"actionlibdbidriverdirectory", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbiDrvrDir,
444 	STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
445 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidriver", 0, eCmdHdlrGetWord, NULL, &amp;cs.drvrName,
446 	STD_LOADABLE_MODULE_ID));
447 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbihost", 0, eCmdHdlrGetWord, NULL, &amp;cs.host,
448 	STD_LOADABLE_MODULE_ID));
449 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbiusername", 0, eCmdHdlrGetWord, NULL, &amp;cs.usrName,
450 	STD_LOADABLE_MODULE_ID));
451 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbipassword", 0, eCmdHdlrGetWord, NULL, &amp;cs.pwd,
452 	STD_LOADABLE_MODULE_ID));
453 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionlibdbidbname", 0, eCmdHdlrGetWord, NULL, &amp;cs.dbName,
454 	STD_LOADABLE_MODULE_ID));
455 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
456 	NULL, STD_LOADABLE_MODULE_ID));
457 	DBGPRINTF("omlibdbi compiled with version %s loaded, libdbi version %s\n", VERSION, dbi_version());
458 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omsnmp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;netinet/in.h&gt;
8 #include &lt;sys/time.h&gt;
9 #include &lt;sys/socket.h&gt;
10 #include &lt;arpa/inet.h&gt;
11 #include &lt;netdb.h&gt;
12 #include &lt;ctype.h&gt;
13 #include &lt;assert.h&gt;
14 #include "conf.h"
15 #include "syslogd-types.h"
16 #include "cfsysline.h"
17 #include "module-template.h"
18 #include &lt;net-snmp/net-snmp-config.h&gt;
19 #include &lt;net-snmp/net-snmp-includes.h&gt;
20 #include "omsnmp.h"
21 #include "errmsg.h"
22 #include "parserif.h"
23 MODULE_TYPE_OUTPUT
24 MODULE_TYPE_NOKEEP
25 MODULE_CNFNAME("omsnmp")
26 DEF_OMOD_STATIC_DATA
27 static oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
28 static oid             objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
29 #define SNMP_SOURCETEMPLATE "\"%fromhost-ip%\""
30 typedef struct _instanceData {
31 	int iPort;				int iSNMPVersion;			int iTrapType;				int iSpecificType;		
32 	uchar	*tplName;       	} instanceData;
33 typedef struct wrkrInstanceData {
34 	instanceData *pData;
35 	netsnmp_session *snmpsession;	} wrkrInstanceData_t;
36 typedef struct configSettings_s {
37 	uchar* pszTransport; 	uchar* pszTarget;
38 	int iPort;
39 	int iSNMPVersion;		uchar* pszCommunity;
40 	uchar* pszEnterpriseOID;
41 	uchar* pszSnmpTrapOID;
42 	uchar* pszSyslogMessageOID;
43 	int iSpecificType;
44 } configSettings_t;
45 static configSettings_t cs;
46 static struct cnfparamdescr actpdescr[] = {
47 	{ "server", eCmdHdlrString, CNFPARAM_REQUIRED },
48 	{ "port", eCmdHdlrInt, 0 },
49 	{ "transport", eCmdHdlrString, 0 },
50 <a name="1"></a>	{ "version", eCmdHdlrInt, 0 },
51 	{ "community", eCmdHdlrString, 0 },
52 	{ "enterpriseoid", eCmdHdlrString, 0 },
53 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "trapoid", eCmdHdlrString, 0 },
54 	{ "messageoid", eCmdHdlrString, 0 },
55 	{ "snmpv1dynsource", eCmdHdlrString, 0 },
56 	{ "traptype", eCmdHdlrInt, 0 },
57 	{ "specifictype", eCmdHdlrInt, 0 },
58 	{ "template", eCmdHdlrGetWord, 0 }
59 };
60 static struct cnfparamblk actpblk =
61 	{ CNFPARAMBLK_VERSION,
62 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
63 	  actpdescr
64 	};</b></font>
65 BEGINinitConfVars		CODESTARTinitConfVars
66 	cs.pszTransport = NULL;
67 	cs.pszTarget = NULL;
68 	cs.iPort = 0;
69 	cs.iSNMPVersion = 1;
70 	cs.pszCommunity = NULL;
71 	cs.pszEnterpriseOID = NULL;
72 	cs.pszSnmpTrapOID = NULL;
73 	cs.pszSyslogMessageOID = NULL;
74 	cs.iSpecificType = 0;
75 	cs.iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
76 ENDinitConfVars
77 BEGINcreateInstance
78 CODESTARTcreateInstance
79 ENDcreateInstance
80 BEGINcreateWrkrInstance
81 CODESTARTcreateWrkrInstance
82 	pWrkrData-&gt;snmpsession = NULL;
83 ENDcreateWrkrInstance
84 BEGINdbgPrintInstInfo
85 CODESTARTdbgPrintInstInfo
86 	dbgprintf("SNMPTransport: %s\n", pData-&gt;szTransport);
87 	dbgprintf("SNMPTarget: %s\n", pData-&gt;szTarget);
88 	dbgprintf("SNMPPort: %d\n", pData-&gt;iPort);
89 	dbgprintf("SNMPVersion (0=v1, 1=v2c): %d\n", pData-&gt;iSNMPVersion);
90 	dbgprintf("Community: %s\n", pData-&gt;szCommunity);
91 	dbgprintf("EnterpriseOID: %s\n", pData-&gt;szEnterpriseOID);
92 	dbgprintf("SnmpTrapOID: %s\n", pData-&gt;szSnmpTrapOID);
93 	dbgprintf("SyslogMessageOID: %s\n", pData-&gt;szSyslogMessageOID);
94 	dbgprintf("SnmpV1Source: %s\n", pData-&gt;szSnmpV1Source);
95 	dbgprintf("TrapType: %d\n", pData-&gt;iTrapType);
96 	dbgprintf("SpecificType: %d\n", pData-&gt;iSpecificType);
97 ENDdbgPrintInstInfo
98 BEGINisCompatibleWithFeature
99 CODESTARTisCompatibleWithFeature
100 ENDisCompatibleWithFeature
101 static rsRetVal
102 omsnmp_exitSession(wrkrInstanceData_t *pWrkrData)
103 {
104 	DEFiRet;
105 	if(pWrkrData-&gt;snmpsession != NULL) {
106 		DBGPRINTF("omsnmp_exitSession: Clearing Session to '%s' on Port = '%d'\n",
107 			  pWrkrData-&gt;pData-&gt;szTarget, pWrkrData-&gt;pData-&gt;iPort);
108 		snmp_close(pWrkrData-&gt;snmpsession);
109 		pWrkrData-&gt;snmpsession = NULL;
110 	}
111 	RETiRet;
112 }
113 static rsRetVal
114 omsnmp_initSession(wrkrInstanceData_t *pWrkrData)
115 {
116 	netsnmp_session session;
117 	instanceData *pData;
118 	char szTargetAndPort[MAXHOSTNAMELEN+128]; 	DEFiRet;
119 	if (pWrkrData-&gt;snmpsession != NULL)
120 		omsnmp_exitSession(pWrkrData);
121 	pData = pWrkrData-&gt;pData;
122 	snprintf((char*)szTargetAndPort, sizeof(szTargetAndPort), "%s:%s:%d",
123 			(pData-&gt;szTransport == NULL) ? "udp" : (char*)pData-&gt;szTransport,
124 			pData-&gt;szTarget, pData-&gt;iPort == 0 ? 162 : pData-&gt;iPort);
125 	dbgprintf( "omsnmp_initSession: ENTER - Target = '%s' on Port = '%d'\n", pData-&gt;szTarget, pData-&gt;iPort);
126 	if (setenv("POSIXLY_CORRECT", "1", 1) == -1)
127 		ABORT_FINALIZE(RS_RET_ERR);
128 	snmp_sess_init(&amp;session);
129 	session.version = pData-&gt;iSNMPVersion;
130 	session.callback = NULL; 	session.callback_magic = NULL;
131 	session.peername = (char*) szTargetAndPort;
132 	if (session.version == SNMP_VERSION_1 || session.version == SNMP_VERSION_2c) {
133 		session.community = (unsigned char *) pData-&gt;szCommunity
134 			== NULL ? (uchar*)"public" : pData-&gt;szCommunity;
135 		session.community_len = strlen((char*) session.community);
136 	}
137 	pWrkrData-&gt;snmpsession = snmp_open(&amp;session);
138 	if (pWrkrData-&gt;snmpsession == NULL) {
139 		LogError(0, RS_RET_SUSPENDED, "omsnmp_initSession: snmp_open to host '%s' on Port '%d' "
140 		"failed\n", pData-&gt;szTarget, pData-&gt;iPort);
141 		iRet = RS_RET_SUSPENDED;
142 	}
143 finalize_it:
144 	RETiRet;
145 }
146 static rsRetVal omsnmp_sendsnmp(wrkrInstanceData_t *pWrkrData, uchar *psz, uchar *pszSource)
147 {
148 	DEFiRet;
149 	netsnmp_pdu    *pdu = NULL;
150 	oid             enterpriseoid[MAX_OID_LEN];
151 	size_t          enterpriseoidlen = MAX_OID_LEN;
152 	oid				oidSyslogMessage[MAX_OID_LEN];
153 	size_t			oLen = MAX_OID_LEN;
154 	int             status;
155 	char            *trap = NULL;
156 	const char		*strErr = NULL;
157 	struct sockaddr_in srcAddr;
158 	instanceData *pData;
159 	pData = pWrkrData-&gt;pData;
160 	if (pWrkrData-&gt;snmpsession == NULL) {
161 		CHKiRet(omsnmp_initSession(pWrkrData));
162 	}
163 	assert(psz != NULL);
164 	dbgprintf( "omsnmp_sendsnmp: ENTER - Syslogmessage = '%s'\n", (char*)psz);
165 	if(pWrkrData-&gt;snmpsession-&gt;version == SNMP_VERSION_1) {
166 		dbgprintf( "omsnmp_sendsnmp: Create SNMPv1 Trap - Source = '%s'\n", (char*)pszSource);
167 		pdu = snmp_pdu_create(SNMP_MSG_TRAP);
168 		if(!snmp_parse_oid(pData-&gt;szEnterpriseOID == NULL ? "1.3.6.1.4.1.3.1.1" :
169 			(char*)pData-&gt;szEnterpriseOID, enterpriseoid, &amp;enterpriseoidlen )) {
170 			strErr = snmp_api_errstring(snmp_errno);
171 			LogError(0, RS_RET_DISABLE_ACTION, "omsnmp_sendsnmp: Parsing EnterpriseOID "
172 					"failed '%s' with error '%s' \n", pData-&gt;szSyslogMessageOID, strErr);
173 			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
174 		}
175 		CHKmalloc(pdu-&gt;enterprise = (oid *) malloc(enterpriseoidlen * sizeof(oid)));
176 		memcpy(pdu-&gt;enterprise, enterpriseoid, enterpriseoidlen * sizeof(oid));
177 		pdu-&gt;enterprise_length = enterpriseoidlen;
178 		pdu-&gt;trap_type = pData-&gt;iTrapType;
179 		pdu-&gt;specific_type = pData-&gt;iSpecificType;
180 		pdu-&gt;time = get_uptime();
181 		if (pszSource != NULL) {
182 			if (inet_aton((const char *)pszSource, &amp;srcAddr.sin_addr) != 0) {
183 				pdu-&gt;agent_addr[0] = (srcAddr.sin_addr.s_addr) &amp; 0xFF;
184 				pdu-&gt;agent_addr[1] = (srcAddr.sin_addr.s_addr &gt;&gt; 8) &amp; 0xFF;
185 				pdu-&gt;agent_addr[2] = (srcAddr.sin_addr.s_addr &gt;&gt; 16) &amp; 0xFF;
186 				pdu-&gt;agent_addr[3] = (srcAddr.sin_addr.s_addr &gt;&gt; 24) &amp; 0xFF;
187 				dbgprintf( "omsnmp_sendsnmp: SNMPv1 Source Property set to %d.%d.%d.%d\n",
188 					(srcAddr.sin_addr.s_addr) &amp; 0xFF,
189 					(srcAddr.sin_addr.s_addr &gt;&gt; 8) &amp; 0xFF,
190 					(srcAddr.sin_addr.s_addr &gt;&gt; 16) &amp; 0xFF,
191 					(srcAddr.sin_addr.s_addr &gt;&gt; 24) &amp; 0xFF);
192 			} else {
193 				LogError(0, NO_ERRCODE, "omsnmp_sendsnmp: Failed to convert '%s' into a valid IPv4"
194 					"address\n", pszSource);
195 			}
196 		}
197 	}
198 	else if (pWrkrData-&gt;snmpsession-&gt;version == SNMP_VERSION_2c)
199 	{
200 		long sysuptime;
201 		char csysuptime[20];
202 		dbgprintf( "omsnmp_sendsnmp: Create SNMPv2 Trap\n");
203 		pdu = snmp_pdu_create(SNMP_MSG_TRAP2);
204 		sysuptime = get_uptime();
205 		snprintf( csysuptime, sizeof(csysuptime) , "%ld", sysuptime);
206 		trap = csysuptime;
207 		snmp_add_var(pdu, objid_sysuptime, sizeof(objid_sysuptime) / sizeof(oid), 't', trap);
208 		if ( snmp_add_var(pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid), 'o',
209 			pData-&gt;szSnmpTrapOID == NULL ?  "1.3.6.1.4.1.19406.1.2.1" : (char*) pData-&gt;szSnmpTrapOID
210 			) != 0) {
211 			strErr = snmp_api_errstring(snmp_errno);
212 			LogError(0, RS_RET_DISABLE_ACTION, "omsnmp_sendsnmp: Adding trap OID failed '%s' "
213 			"with error '%s' \n", pData-&gt;szSnmpTrapOID, strErr);
214 			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
215 		}
216 	}
217 	if (snmp_parse_oid(pData-&gt;szSyslogMessageOID == NULL ?
218 			    "1.3.6.1.4.1.19406.1.1.2.1" : (char*)pData-&gt;szSyslogMessageOID,
219 				oidSyslogMessage, &amp;oLen)) {
220 		int iErrCode = snmp_add_var(pdu, oidSyslogMessage, oLen, 's', (char*) psz);
221 		if (iErrCode) {
222 			const char *str = snmp_api_errstring(iErrCode);
223 			LogError(0, RS_RET_DISABLE_ACTION,  "omsnmp_sendsnmp: Invalid SyslogMessage OID, "
224 			"error code '%d' - '%s'\n", iErrCode, str );
225 			ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
226 		}
227 	} else {
228 		strErr = snmp_api_errstring(snmp_errno);
229 		LogError(0, RS_RET_DISABLE_ACTION, "omsnmp_sendsnmp: Parsing SyslogMessageOID failed '%s' "
230 		"with error '%s' \n", pData-&gt;szSyslogMessageOID, strErr);
231 		ABORT_FINALIZE(RS_RET_DISABLE_ACTION);
232 	}
233 	status = snmp_send(pWrkrData-&gt;snmpsession, pdu) == 0;
234 	if (status)
235 	{
236 		int iErrorCode = pWrkrData-&gt;snmpsession-&gt;s_snmp_errno;
237 		LogError(0, RS_RET_SUSPENDED,  "omsnmp_sendsnmp: snmp_send failed error '%d', "
238 		"Description='%s'\n", iErrorCode*(-1), api_errors[iErrorCode*(-1)]);
239 		omsnmp_exitSession(pWrkrData);
240 		ABORT_FINALIZE(RS_RET_SUSPENDED);
241 	} else {
242 		dbgprintf( "omsnmp_sendsnmp: Successfully send SNMP Trap to %s:%d\n",
243 			pData-&gt;szTarget, pData-&gt;iPort);
244 	}
245 finalize_it:
246 	if(iRet != RS_RET_OK) {
247 		if(pdu != NULL) {
248 			snmp_free_pdu(pdu);
249 		}
250 	}
251 	dbgprintf( "omsnmp_sendsnmp: LEAVE\n");
252 	RETiRet;
253 }
254 BEGINtryResume
255 CODESTARTtryResume
256 	iRet = omsnmp_initSession(pWrkrData);
257 ENDtryResume
258 BEGINdoAction
259 CODESTARTdoAction
260 	if (ppString[0] == NULL) {
261 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
262 	}
263 	iRet = omsnmp_sendsnmp(pWrkrData, ppString[0], ppString[1]);
264 finalize_it:
265 ENDdoAction
266 BEGINfreeInstance
267 CODESTARTfreeInstance
268 	free(pData-&gt;tplName);
269 	free(pData-&gt;szTarget);
270 ENDfreeInstance
271 BEGINfreeWrkrInstance
272 CODESTARTfreeWrkrInstance
273 	omsnmp_exitSession(pWrkrData);
274 ENDfreeWrkrInstance
275 static void
276 setInstParamDefaults(instanceData *pData)
277 {
278 	pData-&gt;tplName = NULL;
279 	pData-&gt;szCommunity = NULL;
280 <a name="2"></a>	pData-&gt;szEnterpriseOID = NULL;
281 	pData-&gt;szSnmpTrapOID = NULL;
282 	pData-&gt;szSyslogMessageOID = NULL;
283 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pData-&gt;szSnmpV1Source = NULL;
284 }
285 BEGINnewActInst
286 	struct cnfparamvals *pvals;
287 	int i;
288 CODESTARTnewActInst
289 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
290 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
291 	}
292 	CHKiRet(createInstance(&amp;pData));
293 	setInstParamDefaults(pData);
294 	CODE_STD_STRING_REQUESTnewActInst(2)
295 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
296 		if(!pvals[i].bUsed)
297 			continue;</b></font>
298 		if(!strcmp(actpblk.descr[i].name, "server")) {
299 			pData-&gt;szTarget = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
300 		} else if(!strcmp(actpblk.descr[i].name, "port")) {
301 			pData-&gt;iPort = pvals[i].val.d.n;
302 		} else if(!strcmp(actpblk.descr[i].name, "transport")) {
303 			pData-&gt;szTransport = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
304 		} else if(!strcmp(actpblk.descr[i].name, "version")) {
305 <a name="0"></a>			pData-&gt;iSNMPVersion = pvals[i].val.d.n;
306 			if(pData-&gt;iSNMPVersion &lt; 0 || cs.iSNMPVersion &gt; 1)
307 				pData-&gt;iSNMPVersion = 1;
308 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "community")) {
309 			pData-&gt;szCommunity = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
310 		} else if(!strcmp(actpblk.descr[i].name, "enterpriseoid")) {
311 			pData-&gt;szEnterpriseOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
312 		} else if(!strcmp(actpblk.descr[i].name, "trapoid")) {
313 			pData-&gt;szSnmpTrapOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
314 		} else if(!strcmp(actpblk.descr[i].name, "messageoid")) {
315 			pData-&gt;szSyslogMessageOID = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
316 		} else if(!strcmp(actpblk.descr[i].name, "snmpv1dynsource")) {
317 			pData-&gt;szSnmpV1Source = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
318 		} else if(!strcmp(actpblk.descr[i].name, "traptype")) {
319 			pData-&gt;iTrapType = pvals[i].val.d.n;</b></font>
320 			if(cs.iTrapType &lt; 0 || cs.iTrapType &gt; 6) {
321 				parser_errmsg("omsnmp: traptype invalid, setting to ENTERPRISESPECIFIC");
322 				pData-&gt;iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
323 			}
324 		} else if(!strcmp(actpblk.descr[i].name, "specifictype")) {
325 			pData-&gt;iSpecificType = pvals[i].val.d.n;
326 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
327 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
328 		} else {
329 			dbgprintf("ompipe: program error, non-handled "
330 			  "param '%s'\n", actpblk.descr[i].name);
331 		}
332 	}
333 	init_snmp("rsyslog");
334 	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT, pData-&gt;iPort );
335 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
336 <a name="4"></a>						"RSYSLOG_FileFormat" : (char*)pData-&gt;tplName),
337 						OMSR_NO_RQD_TPL_OPTS));
338 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	CHKiRet(OMSRsetEntry(*ppOMSR, 1, (uchar*)strdup((pData-&gt;szSnmpV1Source == NULL) ?
339 						" SNMP_SOURCETEMPLATE" : (char*)pData-&gt;szSnmpV1Source),
340 						OMSR_NO_RQD_TPL_OPTS));
341 CODE_STD_FINALIZERnewActInst
342 	cnfparamvalsDestruct(pvals, &amp;actpblk);
343 ENDnewActInst
344 BEGINparseSelectorAct
345 CODESTARTparseSelectorAct
346 CODE_STD_STRING_REQUESTparseSelectorAct(1)
347 	if(!strncmp((char*) p, ":omsnmp:", sizeof(":omsnmp:") - 1)) {
348 		p += sizeof(":omsnmp:") - 1; 	} else {
349 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
350 	}
351 	if((iRet = createInstance(&amp;pData)) != RS_RET_OK)</b></font>
352 		FINALIZE;
353 	if(cs.pszTarget == NULL) {
354 		ABORT_FINALIZE( RS_RET_PARAM_ERROR );
355 	} else {
356 		CHKmalloc(pData-&gt;szTarget = (uchar*) strdup((char*)cs.pszTarget));
357 	}
358 	pData-&gt;szTransport = (uchar*) ((cs.pszTransport == NULL) ? NULL : strdup((char*)cs.pszTransport));
359 	pData-&gt;szCommunity = (uchar*) ((cs.pszCommunity == NULL) ? NULL : strdup((char*)cs.pszCommunity));
360 	pData-&gt;szEnterpriseOID = (uchar*) ((cs.pszEnterpriseOID == NULL) ? NULL : strdup((char*)cs.pszEnterpriseOID));
361 	pData-&gt;szSnmpTrapOID = (uchar*) ((cs.pszSnmpTrapOID == NULL) ? NULL : strdup((char*)cs.pszSnmpTrapOID));
362 	pData-&gt;szSyslogMessageOID = (uchar*) ((cs.pszSyslogMessageOID == NULL) ? NULL :
363 		strdup((char*)cs.pszSyslogMessageOID));
364 	pData-&gt;iPort = cs.iPort;
365 	pData-&gt;iSpecificType = cs.iSpecificType;
366 	if ( cs.iSNMPVersion &lt; 0 || cs.iSNMPVersion &gt; 1)				pData-&gt;iSNMPVersion = 1;
367 	else
368 		pData-&gt;iSNMPVersion = cs.iSNMPVersion;
369 		pData-&gt;iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
370 	else
371 		pData-&gt;iTrapType = cs.iTrapType;
372 	dbgprintf("SNMPTransport: %s\n", pData-&gt;szTransport);
373 	dbgprintf("SNMPTarget: %s\n", pData-&gt;szTarget);
374 	dbgprintf("SNMPPort: %d\n", pData-&gt;iPort);
375 	dbgprintf("SNMPVersion (0=v1, 1=v2c): %d\n", pData-&gt;iSNMPVersion);
376 	dbgprintf("Community: %s\n", pData-&gt;szCommunity);
377 	dbgprintf("EnterpriseOID: %s\n", pData-&gt;szEnterpriseOID);
378 	dbgprintf("SnmpTrapOID: %s\n", pData-&gt;szSnmpTrapOID);
379 	dbgprintf("SyslogMessageOID: %s\n", pData-&gt;szSyslogMessageOID);
380 	dbgprintf("SnmpV1Source: %s\n", pData-&gt;szSnmpV1Source);
381 	dbgprintf("TrapType: %d\n", pData-&gt;iTrapType);
382 	dbgprintf("SpecificType: %d\n", pData-&gt;iSpecificType);
383 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS,
384 		(uchar*) "RSYSLOG_TraditionalForwardFormat"));
385 	init_snmp("rsyslog");
386 	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT, pData-&gt;iPort );
387 CODE_STD_FINALIZERparseSelectorAct
388 ENDparseSelectorAct
389 <a name="3"></a>
390 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
391 {
392 	DEFiRet;
393 	free(cs.pszTarget);
394 	cs.pszTarget = NULL;
395 	free(cs.pszCommunity);
396 	cs.pszCommunity = NULL;
397 	free(cs.pszEnterpriseOID);
398 	cs.pszEnterpriseOID = NULL;
399 	free(cs.pszSnmpTrapOID);
400 	cs.pszSnmpTrapOID = NULL;
401 	free(cs.pszSyslogMessageOID);
402 	cs.pszSyslogMessageOID = NULL;
403 	cs.iPort = 0;</b></font>
404 	cs.iSNMPVersion = 1;
405 	cs.iSpecificType = 0;
406 	cs.iTrapType = SNMP_TRAP_ENTERPRISESPECIFIC;
407 	RETiRet;
408 }
409 BEGINmodExit
410 CODESTARTmodExit
411 	free(cs.pszTarget);
412 	free(cs.pszCommunity);
413 	free(cs.pszEnterpriseOID);
414 	free(cs.pszSnmpTrapOID);
415 	free(cs.pszSyslogMessageOID);
416 ENDmodExit
417 BEGINqueryEtryPt
418 CODESTARTqueryEtryPt
419 CODEqueryEtryPt_STD_OMOD_QUERIES
420 CODEqueryEtryPt_STD_OMOD8_QUERIES
421 CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
422 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
423 ENDqueryEtryPt
424 BEGINmodInit()
425 CODESTARTmodInit
426 	uchar *pTmp;
427 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
428 	initConfVars();
429 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmptransport", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszTransport,
430 	STD_LOADABLE_MODULE_ID));
431 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmptarget", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszTarget,
432 	STD_LOADABLE_MODULE_ID));
433 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmptargetport", 0, eCmdHdlrInt, NULL, &amp;cs.iPort,
434 	STD_LOADABLE_MODULE_ID));
435 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmpversion", 0, eCmdHdlrInt, NULL, &amp;cs.iSNMPVersion,
436 	STD_LOADABLE_MODULE_ID));
437 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmpcommunity", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszCommunity,
438 	STD_LOADABLE_MODULE_ID));
439 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmpenterpriseoid", 0, eCmdHdlrGetWord, NULL,
440 	&amp;cs.pszEnterpriseOID, STD_LOADABLE_MODULE_ID));
441 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmptrapoid", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszSnmpTrapOID,
442 	STD_LOADABLE_MODULE_ID));
443 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmpsyslogmessageoid", 0, eCmdHdlrGetWord, NULL,
444 	&amp;cs.pszSyslogMessageOID, STD_LOADABLE_MODULE_ID));
445 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmpspecifictype", 0, eCmdHdlrInt, NULL, &amp;cs.iSpecificType,
446 	STD_LOADABLE_MODULE_ID));
447 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionsnmptraptype", 0, eCmdHdlrInt, NULL, &amp;cs.iTrapType,
448 	STD_LOADABLE_MODULE_ID));
449 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
450 	NULL, STD_LOADABLE_MODULE_ID));
451 	DBGPRINTF("omsnmp: Add SNMP_SOURCETEMPLATE to template system ONCE\n");
452 	pTmp = (uchar*) SNMP_SOURCETEMPLATE;
453 	tplAddLine(ourConf, " SNMP_SOURCETEMPLATE", &amp;pTmp);
454 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
