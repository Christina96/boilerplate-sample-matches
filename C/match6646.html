<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for csvload.c &amp; pdfiumload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for csvload.c &amp; pdfiumload.c
      </h3>
<h1 align="center">
        15.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>csvload.c (17.88413%)<th>pdfiumload.c (14.143426%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(568-611)<td><a href="#" name="0">(791-834)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(458-474)<td><a href="#" name="1">(840-859)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(631-646)<td><a href="#" name="2">(912-927)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(558-566)<td><a href="#" name="3">(777-786)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>csvload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #define MAX_ITEM_SIZE (256)
13 typedef struct _VipsForeignLoadCsv {
14 	VipsForeignLoad parent_object;
15 	VipsSource *source;
16 	VipsSbuf *sbuf;
17 	int skip;
18 	int lines;
19 	const char *whitespace;
20 	const char *separator;
21 	int lineno;
22 	int colno;
23 	char whitemap[256];
24 	char sepmap[256];
25 	char item[MAX_ITEM_SIZE];
26 	double *linebuf;
27 } VipsForeignLoadCsv;
28 typedef VipsForeignLoadClass VipsForeignLoadCsvClass;
29 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadCsv, vips_foreign_load_csv, 
30 	VIPS_TYPE_FOREIGN_LOAD );
31 static void
32 vips_foreign_load_csv_dispose( GObject *gobject )
33 {
34 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) gobject;
35 	VIPS_UNREF( csv-&gt;source );
36 	VIPS_UNREF( csv-&gt;sbuf );
37 	VIPS_FREE( csv-&gt;linebuf );
38 	G_OBJECT_CLASS( vips_foreign_load_csv_parent_class )-&gt;
39 		dispose( gobject );
40 }
41 static int
42 vips_foreign_load_csv_build( VipsObject *object )
43 {
44 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
45 	int i;
46 	const char *p;
47 	if( !(csv-&gt;sbuf = vips_sbuf_new_from_source( csv-&gt;source )) )
48 		return( -1 );
49 	for( i = 0; i &lt; 256; i++ ) {
50 		csv-&gt;whitemap[i] = 0;
51 		csv-&gt;sepmap[i] = 0;
52 	}
53 	for( p = csv-&gt;whitespace; *p; p++ )
54 		csv-&gt;whitemap[(int) *p] = 1;
55 	for( p = csv-&gt;separator; *p; p++ )
56 		csv-&gt;sepmap[(int) *p] = 1;
57 	csv-&gt;sepmap[(int) '\n'] = 0;
58 	csv-&gt;whitemap[(int) '\n'] = 0;
59 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_parent_class )-&gt;
60 		build( object ) )
61 		return( -1 );
62 	return( 0 );
63 }
64 static VipsForeignFlags
65 vips_foreign_load_csv_get_flags( VipsForeignLoad *load )
66 {
67 	return( 0 );
68 }
69 static int 
70 vips_foreign_load_csv_skip_white( VipsForeignLoadCsv *csv )
71 {
72         int ch;
73 	do {
74 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
75 	} while( ch != EOF &amp;&amp; 
76 		ch != '\n' &amp;&amp; 
77 		csv-&gt;whitemap[ch] );
78 	VIPS_SBUF_UNGETC( csv-&gt;sbuf );
79 	return( ch );
80 }
81 static int 
82 vips_foreign_load_csv_skip_quoted( VipsForeignLoadCsv *csv )
83 {
84         int ch;
85 	do {
86 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
87 		if( ch == '\\' ) 
88 			ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
89 		else if( ch == '"' )
90 			break;
91 	} while( ch != EOF &amp;&amp; 
92 		ch != '\n' );
93 	if( ch == '\n' )
94 		VIPS_SBUF_UNGETC( csv-&gt;sbuf );
95 	return( ch );
96 }
97 static const char *
98 vips_foreign_load_csv_fetch_item( VipsForeignLoadCsv *csv )
99 {
100 	int write_point;
101 	int space_remaining;
102 	int ch;
103 	space_remaining = MAX_ITEM_SIZE - 1;
104 	write_point = 0;
105 	while( (ch = VIPS_SBUF_GETC( csv-&gt;sbuf )) != -1 &amp;&amp;
106 		ch != '\n' &amp;&amp;
107 		!csv-&gt;whitemap[ch] &amp;&amp;
108 		!csv-&gt;sepmap[ch] &amp;&amp;
109 		space_remaining &gt; 0 ) {
110 		csv-&gt;item[write_point] = ch;
111 		write_point += 1;
112 		space_remaining -= 1;
113 	}
114 	csv-&gt;item[write_point] = '\0';
115 	if( ch == -1 &amp;&amp; 
116 		write_point == 0 )
117 		return( NULL );
118 	while( ch != -1 &amp;&amp;
119 		ch != '\n' &amp;&amp;
120 		!csv-&gt;whitemap[ch] &amp;&amp;
121 		!csv-&gt;sepmap[ch] ) 
122 		ch = VIPS_SBUF_GETC( csv-&gt;sbuf );
123 	if( ch == '\n' ||
124 		csv-&gt;whitemap[ch] ||
125 		csv-&gt;sepmap[ch] ) 
126 		VIPS_SBUF_UNGETC( csv-&gt;sbuf );
127 	return( csv-&gt;item );
128 }
129 static int
130 vips_foreign_load_csv_read_double( VipsForeignLoadCsv *csv, double *out )
131 {
132 	int ch;
133 	*out = 0;
134 	ch = vips_foreign_load_csv_skip_white( csv );
135 	if( ch == EOF || 
136 		ch == '\n' ) 
137 		return( ch );
138 	if( ch == '"' ) {
139 		(void) VIPS_SBUF_GETC( csv-&gt;sbuf );
140 		ch = vips_foreign_load_csv_skip_quoted( csv );
141 	}
142 	else if( !csv-&gt;sepmap[ch] ) {
143 		const char *item;
144 		item = vips_foreign_load_csv_fetch_item( csv );
145 		if( !item )
146 			return( EOF );
147 		if( vips_strtod( item, out ) ) 
148 			g_warning( _( "bad number, line %d, column %d" ),
149 				csv-&gt;lineno, csv-&gt;colno );
150 	}
151 	ch = vips_foreign_load_csv_skip_white( csv );
152 	if( ch == EOF || 
153 		ch == '\n' ) 
154 		return( ch );
155 	if( csv-&gt;sepmap[ch] ) 
156 		(void) VIPS_SBUF_GETC( csv-&gt;sbuf ); 
157 	return( ch );
158 }
159 static int
160 vips_foreign_load_csv_header( VipsForeignLoad *load )
161 {
162 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
163 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) load;
164 	int i;
165 	double value;
166 	int ch;
167 	int width;
168 	int height;
169 	vips_sbuf_unbuffer( csv-&gt;sbuf );
170 	if( vips_source_rewind( csv-&gt;source ) )
171 		return( -1 );
172 	for( i = 0; i &lt; csv-&gt;skip; i++ )
173 		if( !vips_sbuf_get_line( csv-&gt;sbuf ) ) {
174 			vips_error( class-&gt;nickname,
175 				"%s", _( "unexpected end of file" ) );
176 			return( -1 );
177 		}
178 	csv-&gt;lineno = csv-&gt;skip + 1;
179 	csv-&gt;colno = 0;
180 	do {
181 		csv-&gt;colno += 1;
182 		ch = vips_foreign_load_csv_read_double( csv, &amp;value );
183 	} while( ch != '\n' &amp;&amp;
184 		ch != EOF );
185 	width = csv-&gt;colno;
186 	if( !(csv-&gt;linebuf = VIPS_ARRAY( NULL, width, double )) )
187 		return( -1 );
188 	if( csv-&gt;lines == -1 ) 
189 		for( height = 0; vips_sbuf_get_line( csv-&gt;sbuf ); height++ )
190 			;
191 	else 
192 		height = csv-&gt;lines;
193 	vips_image_init_fields( load-&gt;out,
194 		width, height, 1, 
195 		VIPS_FORMAT_DOUBLE, 
196 		VIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );
197 	if( vips_image_pipelinev( load-&gt;out, 
198 		VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
199 		return( -1 );
200 	VIPS_SETSTR( load-&gt;out-&gt;filename, 
201 		vips_connection_filename( VIPS_CONNECTION( csv-&gt;source ) ) );
202 	return( 0 );
203 }
204 static int
205 vips_foreign_load_csv_load( VipsForeignLoad *load )
206 {
207 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
208 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) load;
209 	int i;
210 	int x, y;
211 	int ch;
212 	vips_sbuf_unbuffer( csv-&gt;sbuf );
213 	if( vips_source_rewind( csv-&gt;source ) )
214 		return( -1 );
215 	for( i = 0; i &lt; csv-&gt;skip; i++ )
216 		if( !vips_sbuf_get_line( csv-&gt;sbuf ) ) {
217 			vips_error( class-&gt;nickname,
218 				"%s", _( "unexpected end of file" ) );
219 			return( -1 );
220 		}
221 	vips_image_init_fields( load-&gt;real,
222 		load-&gt;out-&gt;Xsize, load-&gt;out-&gt;Ysize, 1, 
223 		VIPS_FORMAT_DOUBLE, 
224 		VIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );
225 	if( vips_image_pipelinev( load-&gt;real, 
226 		VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
227 		return( -1 );
228 	csv-&gt;lineno = csv-&gt;skip + 1;
229 	for( y = 0; y &lt; load-&gt;real-&gt;Ysize; y++ ) {
230 		csv-&gt;colno = 0;
231 		ch = EOF;
232 		for( x = 0; x &lt; load-&gt;real-&gt;Xsize; x++ ) {
233 			double value;
234 			csv-&gt;colno += 1;
235 			ch = vips_foreign_load_csv_read_double( csv, &amp;value );
236 			if( ch == EOF ) {
237 				vips_error( class-&gt;nickname,
238 					"%s", _( "unexpected end of file" ) );
239 				return( -1 );
240 			}
241 			if( ch == '\n' &amp;&amp;
242 				x != load-&gt;real-&gt;Xsize - 1 ) {
243 				vips_error( class-&gt;nickname,
244 					_( "line %d has only %d columns" ),
245 					csv-&gt;lineno, csv-&gt;colno );
246 				if( load-&gt;fail )
247 					return( -1 );
248 			}
249 			csv-&gt;linebuf[x] = value;
250 		}
251 		if( ch == '\n' ) {
252 			(void) VIPS_SBUF_GETC( csv-&gt;sbuf ); 
253 			csv-&gt;lineno += 1;
254 		}
255 		if( vips_image_write_line( load-&gt;real, y, 
256 			(VipsPel *) csv-&gt;linebuf ) )
257 <a name="1"></a>			return( -1 );
258 	}
259 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
260 }
261 static void
262 vips_foreign_load_csv_class_init( VipsForeignLoadCsvClass *class )
263 {
264 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
265 	VipsObjectClass *object_class = (VipsObjectClass *) class;
266 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
267 	gobject_class-&gt;dispose = vips_foreign_load_csv_dispose;
268 	gobject_class-&gt;set_property = vips_object_set_property;
269 	gobject_class-&gt;get_property = vips_object_get_property;
270 	object_class-&gt;nickname = "csvload_base";
271 	object_class-&gt;description = _( "load csv" );
272 	object_class-&gt;build = vips_foreign_load_csv_build;</b></font>
273 	load_class-&gt;get_flags = vips_foreign_load_csv_get_flags;
274 	load_class-&gt;header = vips_foreign_load_csv_header;
275 	load_class-&gt;load = vips_foreign_load_csv_load;
276 	VIPS_ARG_INT( class, "skip", 20, 
277 		_( "Skip" ), 
278 		_( "Skip this many lines at the start of the file" ),
279 		VIPS_ARGUMENT_OPTIONAL_INPUT,
280 		G_STRUCT_OFFSET( VipsForeignLoadCsv, skip ),
281 		0, 10000000, 0 );
282 	VIPS_ARG_INT( class, "lines", 21, 
283 		_( "Lines" ), 
284 		_( "Read this many lines from the file" ),
285 		VIPS_ARGUMENT_OPTIONAL_INPUT,
286 		G_STRUCT_OFFSET( VipsForeignLoadCsv, lines ),
287 		-1, 10000000, 0 );
288 	VIPS_ARG_STRING( class, "whitespace", 22, 
289 		_( "Whitespace" ), 
290 		_( "Set of whitespace characters" ),
291 		VIPS_ARGUMENT_OPTIONAL_INPUT,
292 		G_STRUCT_OFFSET( VipsForeignLoadCsv, whitespace ),
293 		" " ); 
294 	VIPS_ARG_STRING( class, "separator", 23, 
295 		_( "Separator" ), 
296 		_( "Set of separator characters" ),
297 		VIPS_ARGUMENT_OPTIONAL_INPUT,
298 		G_STRUCT_OFFSET( VipsForeignLoadCsv, separator ),
299 		";,\t" ); 
300 }
301 static void
302 vips_foreign_load_csv_init( VipsForeignLoadCsv *csv )
303 {
304 	csv-&gt;lines = -1;
305 	csv-&gt;whitespace = g_strdup( " " );
306 	csv-&gt;separator = g_strdup( ";,\t" );
307 }
308 typedef struct _VipsForeignLoadCsvFile {
309 	VipsForeignLoadCsv parent_object;
310 	char *filename;
311 } VipsForeignLoadCsvFile;
312 typedef VipsForeignLoadCsvClass VipsForeignLoadCsvFileClass;
313 G_DEFINE_TYPE( VipsForeignLoadCsvFile, vips_foreign_load_csv_file,
314 	vips_foreign_load_csv_get_type() );
315 static VipsForeignFlags
316 vips_foreign_load_csv_file_get_flags_filename( const char *filename )
317 {
318 	return( 0 );
319 }
320 static int
321 vips_foreign_load_csv_file_build( VipsObject *object )
322 {
323 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
324 	VipsForeignLoadCsvFile *file = (VipsForeignLoadCsvFile *) object;
325 	if( file-&gt;filename ) 
326 		if( !(csv-&gt;source = 
327 			vips_source_new_from_file( file-&gt;filename )) )
328 			return( -1 );
329 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_file_parent_class )-&gt;
330 		build( object ) )
331 		return( -1 );
332 	return( 0 );
333 }
334 <a name="3"></a>static const char *vips_foreign_load_csv_suffs[] = {
335 	".csv",
336 	NULL
337 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
338 static void
339 vips_foreign_load_csv_file_class_init( VipsForeignLoadCsvFileClass *class )
340 {
341 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
342 	VipsObjectClass *object_class = (VipsObjectClass *) class;
343 <a name="0"></a>	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
344 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
345 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;set_property = vips_object_set_property;
346 	gobject_class-&gt;get_property = vips_object_get_property;
347 	object_class-&gt;nickname = "csvload";
348 	object_class-&gt;build = vips_foreign_load_csv_file_build;
349 	foreign_class-&gt;suffs = vips_foreign_load_csv_suffs;
350 	load_class-&gt;get_flags_filename = 
351 		vips_foreign_load_csv_file_get_flags_filename;
352 	VIPS_ARG_STRING( class, "filename", 1,
353 		_( "Filename" ),
354 		_( "Filename to load from" ),
355 		VIPS_ARGUMENT_REQUIRED_INPUT,
356 		G_STRUCT_OFFSET( VipsForeignLoadCsvFile, filename ),
357 		NULL );
358 }
359 static void
360 vips_foreign_load_csv_file_init( VipsForeignLoadCsvFile *file )
361 {
362 }
363 typedef struct _VipsForeignLoadCsvSource {
364 	VipsForeignLoadCsv parent_object;
365 	VipsSource *source;
366 } VipsForeignLoadCsvSource;
367 typedef VipsForeignLoadCsvClass VipsForeignLoadCsvSourceClass;
368 G_DEFINE_TYPE( VipsForeignLoadCsvSource, vips_foreign_load_csv_source,
369 	vips_foreign_load_csv_get_type() );
370 static int
371 vips_foreign_load_csv_source_build( VipsObject *object )
372 {
373 	VipsForeignLoadCsv *csv = (VipsForeignLoadCsv *) object;
374 	VipsForeignLoadCsvSource *source = (VipsForeignLoadCsvSource *) object;
375 	if( source-&gt;source ) {</b></font>
376 		csv-&gt;source = source-&gt;source;
377 		g_object_ref( csv-&gt;source );
378 	}
379 	if( VIPS_OBJECT_CLASS( vips_foreign_load_csv_source_parent_class )-&gt;
380 		build( object ) )
381 		return( -1 );
382 	return( 0 );
383 }
384 static gboolean
385 vips_foreign_load_csv_source_is_a_source( VipsSource *source )
386 {
387 	return( FALSE );
388 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
389 static void
390 vips_foreign_load_csv_source_class_init( VipsForeignLoadCsvFileClass *class )
391 {
392 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
393 	VipsObjectClass *object_class = (VipsObjectClass *) class;
394 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
395 	gobject_class-&gt;set_property = vips_object_set_property;
396 	gobject_class-&gt;get_property = vips_object_get_property;
397 	object_class-&gt;nickname = "csvload_source";
398 	object_class-&gt;build = vips_foreign_load_csv_source_build;
399 	load_class-&gt;is_a_source = vips_foreign_load_csv_source_is_a_source;</b></font>
400 	VIPS_ARG_OBJECT( class, "source", 1,
401 		_( "Source" ),
402 		_( "Source to load from" ),
403 		VIPS_ARGUMENT_REQUIRED_INPUT, 
404 		G_STRUCT_OFFSET( VipsForeignLoadCsvSource, source ),
405 		VIPS_TYPE_SOURCE );
406 }
407 static void
408 vips_foreign_load_csv_source_init( VipsForeignLoadCsvSource *source )
409 {
410 }
411 int
412 vips_csvload( const char *filename, VipsImage **out, ... )
413 {
414 	va_list ap;
415 	int result;
416 	va_start( ap, out );
417 	result = vips_call_split( "csvload", ap, filename, out ); 
418 	va_end( ap );
419 	return( result );
420 }
421 int
422 vips_csvload_source( VipsSource *source, VipsImage **out, ... )
423 {
424 	va_list ap;
425 	int result;
426 	va_start( ap, out );
427 	result = vips_call_split( "csvload_source", ap, source, out ); 
428 	va_end( ap );
429 	return( result );
430 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pdfiumload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #ifdef HAVE_PDFIUM
13 #include &lt;fpdfview.h&gt;
14 #include &lt;fpdf_doc.h&gt;
15 typedef struct _VipsForeignLoadPdf {
16 	VipsForeignLoad parent_object;
17 	VipsSource *source;
18 	int page_no;
19 	int n; 
20 	double dpi;
21 	double scale;
22 	VipsArrayDouble *background;
23 	FPDF_FILEACCESS file_access;
24 	FPDF_DOCUMENT doc;
25 	FPDF_PAGE page;
26 	int current_page;
27 	int n_pages;
28 	VipsRect image;
29 	VipsRect *pages;
30 	VipsPel *ink;
31 } VipsForeignLoadPdf;
32 typedef VipsForeignLoadClass VipsForeignLoadPdfClass;
33 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPdf, vips_foreign_load_pdf, 
34 	VIPS_TYPE_FOREIGN_LOAD );
35 static char *vips_pdfium_errors[] = {
36 	"no error",
37 	"unknown error",
38 	"file not found or could not be opened",
39 	"file not in PDF format or corrupted",
40 	"password required or incorrect password",
41 	"unsupported security scheme",
42 	"page not found or content error"
43 };
44 static GMutex *vips_pdfium_mutex = NULL;
45 static void
46 vips_pdfium_error( void )
47 {
48 	int err = FPDF_GetLastError();
49 	if( err &gt;= 0 &amp;&amp; 
50 		err &lt; VIPS_NUMBER( vips_pdfium_errors ) )
51 		vips_error( "pdfload", "%s", _( vips_pdfium_errors[err] ) );
52 	else
53 		vips_error( "pdfload", "%s", _( "unknown error" ) ); 
54 }
55 static void
56 vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
57 {
58 	g_mutex_lock( vips_pdfium_mutex );
59 	VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
60 	VIPS_FREEF( FPDF_CloseDocument, pdf-&gt;doc ); 
61 	VIPS_UNREF( pdf-&gt;source );
62 	g_mutex_unlock( vips_pdfium_mutex );
63 }
64 static void
65 vips_foreign_load_pdf_dispose( GObject *gobject )
66 {
67 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) gobject;
68 	vips_foreign_load_pdf_close( pdf ); 
69 	G_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
70 		dispose( gobject );
71 }
72 static void *
73 vips_pdfium_init_cb( void *dummy )
74 {
75 	FPDF_LIBRARY_CONFIG config;
76 	config.version = 2;
77 	config.m_pUserFontPaths = NULL;
78 	config.m_pIsolate = NULL;
79 	config.m_v8EmbedderSlot = 0;
80 	FPDF_InitLibraryWithConfig( &amp;config );
81 	return( NULL );
82 }
83 static gboolean
84 vips_pdfium_GetBlock( void *param, 
85 	unsigned long position, unsigned char *pBuf, unsigned long size )
86 {
87 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) param;
88 	g_assert( size &gt; 0 );
89 	g_assert( position &gt;= 0 );
90 	g_assert( position + size &lt;= pdf-&gt;file_access.m_FileLen );
91 	if( vips_source_seek( pdf-&gt;source, position, SEEK_SET ) &lt; 0 )
92 		return( FALSE );
93 	while( size &gt; 0 ) {
94 		size_t n_read;
95 		if( (n_read = vips_source_read( pdf-&gt;source, pBuf, size )) &lt; 0 )
96 			return( FALSE );
97 		pBuf += n_read;
98 		size -= n_read;
99 	}
100 	return( TRUE );
101 }
102 static int
103 vips_foreign_load_pdf_build( VipsObject *object )
104 {
105 	static GOnce once = G_ONCE_INIT;
106 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
107 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
108 	gint64 length;
109 	VIPS_ONCE( &amp;once, vips_pdfium_init_cb, NULL );
110 	if( !vips_object_argument_isset( object, "scale" ) )
111 		pdf-&gt;scale = pdf-&gt;dpi / 72.0;
112 	if( pdf-&gt;source ) { 
113 		if( (length = vips_source_length( pdf-&gt;source )) &lt;= 0 )
114 			return( -1 );
115 		if( length &gt; 1 &lt;&lt; 30 ) {
116 			vips_error( class-&gt;nickname, 
117 				_( "%s: too large for pdfium" ),
118 				vips_connection_nick( 
119 					VIPS_CONNECTION( pdf-&gt;source ) ) );
120 			return( -1 );
121 		}
122 		pdf-&gt;file_access.m_FileLen = length;
123 		pdf-&gt;file_access.m_GetBlock = vips_pdfium_GetBlock;
124 		pdf-&gt;file_access.m_Param = pdf;
125 		g_mutex_lock( vips_pdfium_mutex );
126 		if( !(pdf-&gt;doc = FPDF_LoadCustomDocument( &amp;pdf-&gt;file_access, 
127 			NULL )) ) {
128 			g_mutex_unlock( vips_pdfium_mutex );
129 			vips_pdfium_error();
130 			vips_error( "pdfload", 
131 				_( "%s: unable to load" ), 
132 				vips_connection_nick( 
133 					VIPS_CONNECTION( pdf-&gt;source ) ) );
134 			return( -1 ); 
135 		}
136 		g_mutex_unlock( vips_pdfium_mutex );
137 	}
138 	if( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
139 		build( object ) )
140 		return( -1 );
141 	return( 0 );
142 }
143 static VipsForeignFlags
144 vips_foreign_load_pdf_get_flags_filename( const char *filename )
145 {
146 	return( VIPS_FOREIGN_PARTIAL );
147 }
148 static VipsForeignFlags
149 vips_foreign_load_pdf_get_flags( VipsForeignLoad *load )
150 {
151 	return( VIPS_FOREIGN_PARTIAL );
152 }
153 static int
154 vips_foreign_load_pdf_get_page( VipsForeignLoadPdf *pdf, int page_no )
155 {
156 	if( pdf-&gt;current_page != page_no ) { 
157 		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
158 		g_mutex_lock( vips_pdfium_mutex );
159 		VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
160 		pdf-&gt;current_page = -1;
161 #ifdef DEBUG
162 		printf( "vips_foreign_load_pdf_get_page: %d\n", page_no );
163 		if( !(pdf-&gt;page = FPDF_LoadPage( pdf-&gt;doc, page_no )) ) {
164 			g_mutex_unlock( vips_pdfium_mutex );
165 			vips_pdfium_error();
166 			vips_error( class-&gt;nickname, 
167 				_( "unable to load page %d" ), page_no );
168 			return( -1 ); 
169 		}
170 		pdf-&gt;current_page = page_no;
171 		g_mutex_unlock( vips_pdfium_mutex );
172 	}
173 	return( 0 );
174 }
175 typedef struct _VipsForeignLoadPdfMetadata {
176 	char *tag;			char *field;		} VipsForeignLoadPdfMetadata;
177 static VipsForeignLoadPdfMetadata vips_foreign_load_pdf_metadata[] = {
178 	{ "Title", "pdf-title" },
179 	{ "Author", "pdf-author" },
180 	{ "Subject", "pdf-subject" },
181 	{ "Keywords", "pdf-keywords" },
182 	{ "Creator", "pdf-creator" },
183 	{ "Producer", "pdf-producer" },
184 };
185 static int n_metadata = VIPS_NUMBER( vips_foreign_load_pdf_metadata );
186 static int
187 vips_foreign_load_pdf_set_image( VipsForeignLoadPdf *pdf, VipsImage *out )
188 {
189 	int i;
190 	double res;
191 #ifdef DEBUG
192 	printf( "vips_foreign_load_pdf_set_image: %p\n", pdf );
193         if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_FATSTRIP, NULL ) )
194 		return( -1 );
195 	vips_image_set_int( out, "pdf-n_pages", pdf-&gt;n_pages ); 
196 	vips_image_set_int( out, VIPS_META_N_PAGES, pdf-&gt;n_pages ); 
197 	g_mutex_lock( vips_pdfium_mutex );
198 	for( i = 0; i &lt; n_metadata; i++ ) {
199 		VipsForeignLoadPdfMetadata *metadata = 
200 			&amp;vips_foreign_load_pdf_metadata[i];
201 		char text[1024];
202 		int len;
203 		len = FPDF_GetMetaText( pdf-&gt;doc, metadata-&gt;tag, text, 1024 );
204 		if( len &gt; 0 ) { 
205 			char *str;
206 			if( (str = g_utf16_to_utf8( (gunichar2 *) text, len, 
207 				NULL, NULL, NULL )) ) {
208 				vips_image_set_string( out, 
209 					metadata-&gt;field, str ); 
210 				g_free( str );
211 			}
212 		}
213 	}
214 	g_mutex_unlock( vips_pdfium_mutex );
215 	res = pdf-&gt;dpi / 25.4;
216 	vips_image_init_fields( out, 
217 		pdf-&gt;image.width, pdf-&gt;image.height, 
218 		4, VIPS_FORMAT_UCHAR,
219 		VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, res, res );
220 	return( 0 );
221 }
222 static int
223 vips_foreign_load_pdf_header( VipsForeignLoad *load )
224 {
225 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
226 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
227 	int top;
228 	int i;
229 #ifdef DEBUG
230 	printf( "vips_foreign_load_pdf_header: %p\n", pdf );
231 	g_mutex_lock( vips_pdfium_mutex );
232 	pdf-&gt;n_pages = FPDF_GetPageCount( pdf-&gt;doc );
233 	g_mutex_unlock( vips_pdfium_mutex );
234 	if( pdf-&gt;n == -1 )
235 		pdf-&gt;n = pdf-&gt;n_pages - pdf-&gt;page_no;
236 	if( pdf-&gt;page_no + pdf-&gt;n &gt; pdf-&gt;n_pages ||
237 		pdf-&gt;page_no &lt; 0 ||
238 		pdf-&gt;n &lt;= 0 ) {
239 		vips_error( class-&gt;nickname, "%s", _( "pages out of range" ) );
240 		return( -1 ); 
241 	}
242 	if( !(pdf-&gt;pages = VIPS_ARRAY( pdf, pdf-&gt;n, VipsRect )) )
243 		return( -1 ); 
244 	top = 0;
245 	pdf-&gt;image.left = 0;
246 	pdf-&gt;image.top = 0;
247 	pdf-&gt;image.width = 0;
248 	pdf-&gt;image.height = 0;
249 	for( i = 0; i &lt; pdf-&gt;n; i++ ) {
250 		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
251 			return( -1 );
252 		pdf-&gt;pages[i].left = 0;
253 		pdf-&gt;pages[i].top = top;
254 		pdf-&gt;pages[i].width = VIPS_RINT( 
255 			FPDF_GetPageWidth( pdf-&gt;page ) * pdf-&gt;scale );
256 		pdf-&gt;pages[i].height = VIPS_RINT( 
257 			FPDF_GetPageHeight( pdf-&gt;page ) * pdf-&gt;scale );
258 		if( pdf-&gt;pages[i].width &gt; pdf-&gt;image.width )
259 			pdf-&gt;image.width = pdf-&gt;pages[i].width;
260 		pdf-&gt;image.height += pdf-&gt;pages[i].height;
261 		top += pdf-&gt;pages[i].height;
262 	}
263 	for( i = 1; i &lt; pdf-&gt;n; i++ ) 
264 		if( pdf-&gt;pages[i].height != pdf-&gt;pages[0].height )
265 			break;
266 	if( vips_object_argument_isset( VIPS_OBJECT( pdf ), "n" ) )
267 		vips_image_set_int( load-&gt;out, 
268 			VIPS_META_PAGE_HEIGHT, pdf-&gt;pages[0].height );
269 	vips_foreign_load_pdf_set_image( pdf, load-&gt;out ); 
270 	if( !(pdf-&gt;ink = vips__vector_to_ink( class-&gt;nickname, 
271 		load-&gt;out, 
272 		VIPS_AREA( pdf-&gt;background )-&gt;data, NULL, 
273 		VIPS_AREA( pdf-&gt;background )-&gt;n )) )
274 		return( -1 );
275 	return( 0 );
276 }
277 static void
278 vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
279 {
280 	vips_source_minimise( pdf-&gt;source );
281 }
282 static int
283 vips_foreign_load_pdf_generate( VipsRegion *or, 
284 	void *seq, void *a, void *b, gboolean *stop )
285 {
286 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
287 	VipsRect *r = &amp;or-&gt;valid;
288 	int top;
289 	int i;
290 	int y;
291 	vips_region_paint_pel( or, r, pdf-&gt;ink ); 
292 	for( i = 0; i &lt; pdf-&gt;n; i++ )
293 		if( VIPS_RECT_BOTTOM( &amp;pdf-&gt;pages[i] ) &gt; r-&gt;top )
294 			break;
295 	top = r-&gt;top; 
296 	while( top &lt; VIPS_RECT_BOTTOM( r ) ) {
297 		VipsRect rect;
298 		FPDF_BITMAP bitmap;
299 		vips_rect_intersectrect( r, &amp;pdf-&gt;pages[i], &amp;rect );
300 		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
301 			return( -1 ); 
302 		g_mutex_lock( vips_pdfium_mutex );
303 		bitmap = FPDFBitmap_CreateEx( rect.width, rect.height, 4, 
304 			VIPS_REGION_ADDR( or, rect.left, rect.top ), 
305 			VIPS_REGION_LSKIP( or ) );  
306 		FPDF_RenderPageBitmap( bitmap, pdf-&gt;page, 
307 			0, 0, rect.width, rect.height,
308 			0, 0 ); 
309 		FPDFBitmap_Destroy( bitmap ); 
310 		g_mutex_unlock( vips_pdfium_mutex );
311 		top += rect.height;
312 		i += 1;
313 	}
314 	for( y = 0; y &lt; r-&gt;height; y++ )
315 		vips__bgra2rgba( 
316 			(guint32 *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ),
317 			r-&gt;width );
318 	return( 0 ); 
319 }
320 static int
321 vips_foreign_load_pdf_load( VipsForeignLoad *load )
322 {
323 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
324 	VipsImage **t = (VipsImage **) 
325 		vips_object_local_array( (VipsObject *) load, 2 );
326 #ifdef DEBUG
327 	printf( "vips_foreign_load_pdf_load: %p\n", pdf );
328 	t[0] = vips_image_new(); 
329 	g_signal_connect( t[0], "minimise", 
330 		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
331 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
332 	if( vips_image_generate( t[0], 
333 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
334 		return( -1 );
335 	if( vips_linecache( t[0], &amp;t[1],
336 		"tile_height", pdf-&gt;pages[0].height, 
337 		NULL ) ) 
338 		return( -1 );
339 	if( vips_image_write( t[1], load-&gt;real ) ) 
340 		return( -1 );
341 	return( 0 );
342 }
343 static void *
344 vips_foreign_load_pdf_once_init( void *client )
345 {
346 	vips_pdfium_mutex = vips_g_mutex_new();
347 	return( NULL );
348 }
349 static void
350 vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
351 {
352 	static GOnce once = G_ONCE_INIT;
353 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
354 	VipsObjectClass *object_class = (VipsObjectClass *) class;
355 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
356 	VIPS_ONCE( &amp;once, vips_foreign_load_pdf_once_init, NULL );
357 	gobject_class-&gt;dispose = vips_foreign_load_pdf_dispose;
358 	gobject_class-&gt;set_property = vips_object_set_property;
359 	gobject_class-&gt;get_property = vips_object_get_property;
360 	object_class-&gt;nickname = "pdfload_base";
361 	object_class-&gt;description = _( "load PDF with PDFium" );
362 	object_class-&gt;build = vips_foreign_load_pdf_build;
363 	load_class-&gt;get_flags_filename = 
364 		vips_foreign_load_pdf_get_flags_filename;
365 	load_class-&gt;get_flags = vips_foreign_load_pdf_get_flags;
366 	load_class-&gt;header = vips_foreign_load_pdf_header;
367 	load_class-&gt;load = vips_foreign_load_pdf_load;
368 	VIPS_ARG_INT( class, "page", 10,
369 		_( "Page" ),
370 		_( "Load this page from the file" ),
371 		VIPS_ARGUMENT_OPTIONAL_INPUT,
372 		G_STRUCT_OFFSET( VipsForeignLoadPdf, page_no ),
373 		0, 100000, 0 );
374 	VIPS_ARG_INT( class, "n", 11,
375 		_( "n" ),
376 		_( "Load this many pages" ),
377 		VIPS_ARGUMENT_OPTIONAL_INPUT,
378 		G_STRUCT_OFFSET( VipsForeignLoadPdf, n ),
379 		-1, 100000, 1 );
380 	VIPS_ARG_DOUBLE( class, "dpi", 12,
381 		_( "DPI" ),
382 		_( "Render at this DPI" ),
383 		VIPS_ARGUMENT_OPTIONAL_INPUT,
384 		G_STRUCT_OFFSET( VipsForeignLoadPdf, dpi ),
385 		0.001, 100000.0, 72.0 );
386 	VIPS_ARG_DOUBLE( class, "scale", 13,
387 		_( "Scale" ),
388 		_( "Scale output by this factor" ),
389 		VIPS_ARGUMENT_OPTIONAL_INPUT,
390 		G_STRUCT_OFFSET( VipsForeignLoadPdf, scale ),
391 		0.001, 100000.0, 1.0 );
392 	VIPS_ARG_BOXED( class, "background", 14, 
393 		_( "Background" ), 
394 		_( "Background value" ),
395 		VIPS_ARGUMENT_OPTIONAL_INPUT,
396 		G_STRUCT_OFFSET( VipsForeignLoadPdf, background ),
397 		VIPS_TYPE_ARRAY_DOUBLE );
398 }
399 static void
400 vips_foreign_load_pdf_init( VipsForeignLoadPdf *pdf )
401 {
402 	pdf-&gt;dpi = 72.0;
403 	pdf-&gt;scale = 1.0;
404 	pdf-&gt;n = 1;
405 	pdf-&gt;current_page = -1;
406 	pdf-&gt;background = vips_array_double_newv( 1, 255.0 );
407 }
408 typedef struct _VipsForeignLoadPdfFile {
409 	VipsForeignLoadPdf parent_object;
410 	char *filename; 
411 } VipsForeignLoadPdfFile;
412 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfFileClass;
413 G_DEFINE_TYPE( VipsForeignLoadPdfFile, vips_foreign_load_pdf_file, 
414 	vips_foreign_load_pdf_get_type() );
415 static int
416 vips_foreign_load_pdf_file_header( VipsForeignLoad *load )
417 {
418 	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) load;
419 	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
420 	return( VIPS_FOREIGN_LOAD_CLASS(
421 		vips_foreign_load_pdf_file_parent_class )-&gt;header( load ) );
422 }
423 static const char *vips_foreign_pdf_suffs[] = {
424 	".pdf",
425 	NULL
426 };
427 static int
428 vips_foreign_load_pdf_file_build( VipsObject *object )
429 {
430 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
431 	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) pdf;
432 #ifdef DEBUG
433 	printf( "vips_foreign_load_pdf_file_build: %s\n", file-&gt;filename );
434 	if( file-&gt;filename &amp;&amp;
435 		!(pdf-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
436 		return( -1 );
437 	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_file_parent_class )-&gt;
438 		build( object ) );
439 }
440 static gboolean
441 vips_foreign_load_pdf_is_a_buffer( const void *buf, size_t len )
442 {
443 	const guchar *str = (const guchar *) buf;
444 	if( len &gt;= 4 &amp;&amp;
445 		str[0] == '%' &amp;&amp; 
446 		str[1] == 'P' &amp;&amp;
447 		str[2] == 'D' &amp;&amp;
448 		str[3] == 'F' )
449 		return( 1 );
450 	return( 0 );
451 }
452 static gboolean
453 vips_foreign_load_pdf_is_a( const char *filename )
454 {
455 	unsigned char buf[4];
456 	if( vips__get_bytes( filename, buf, 4 ) == 4 &amp;&amp;
457 		vips_foreign_load_pdf_is_a_buffer( buf, 4 ) )
458 <a name="3"></a>		return( 1 );
459 	return( 0 );
460 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
461 static void
462 vips_foreign_load_pdf_file_class_init( 
463 	VipsForeignLoadPdfFileClass *class )
464 {
465 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
466 	VipsObjectClass *object_class = (VipsObjectClass *) class;
467 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
468 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
469 <a name="0"></a>	gobject_class-&gt;set_property = vips_object_set_property;
470 	gobject_class-&gt;get_property = vips_object_get_property;
471 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	object_class-&gt;nickname = "pdfload";
472 	object_class-&gt;description = _( "load PDF from file" );
473 	object_class-&gt;build = vips_foreign_load_pdf_file_build;
474 	foreign_class-&gt;suffs = vips_foreign_pdf_suffs;
475 	load_class-&gt;is_a = vips_foreign_load_pdf_is_a;
476 	load_class-&gt;header = vips_foreign_load_pdf_file_header;
477 	VIPS_ARG_STRING( class, "filename", 1, 
478 		_( "Filename" ),
479 		_( "Filename to load from" ),
480 		VIPS_ARGUMENT_REQUIRED_INPUT, 
481 		G_STRUCT_OFFSET( VipsForeignLoadPdfFile, filename ),
482 		NULL );
483 }
484 static void
485 vips_foreign_load_pdf_file_init( VipsForeignLoadPdfFile *file )
486 {
487 }
488 typedef struct _VipsForeignLoadPdfBuffer {
489 	VipsForeignLoadPdf parent_object;
490 	VipsArea *buf;
491 } VipsForeignLoadPdfBuffer;
492 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfBufferClass;
493 G_DEFINE_TYPE( VipsForeignLoadPdfBuffer, vips_foreign_load_pdf_buffer, 
494 	vips_foreign_load_pdf_get_type() );
495 static int
496 vips_foreign_load_pdf_buffer_build( VipsObject *object )
497 {
498 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
499 	VipsForeignLoadPdfBuffer *buffer = (VipsForeignLoadPdfBuffer *) pdf;
500 	if( buffer-&gt;buf &amp;&amp;</b></font>
501 		!(pdf-&gt;source = vips_source_new_from_memory( 
502 			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
503 <a name="1"></a>			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
504 		return( -1 );
505 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_buffer_parent_class )-&gt;
506 		build( object ) );
507 }
508 static void
509 vips_foreign_load_pdf_buffer_class_init( 
510 	VipsForeignLoadPdfBufferClass *class )
511 {
512 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
513 	VipsObjectClass *object_class = (VipsObjectClass *) class;
514 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
515 	gobject_class-&gt;set_property = vips_object_set_property;
516 	gobject_class-&gt;get_property = vips_object_get_property;
517 	object_class-&gt;nickname = "pdfload_buffer";
518 	object_class-&gt;description = _( "load PDF from buffer" );
519 	object_class-&gt;build = vips_foreign_load_pdf_buffer_build;
520 	load_class-&gt;is_a_buffer = vips_foreign_load_pdf_is_a_buffer;</b></font>
521 	VIPS_ARG_BOXED( class, "buffer", 1, 
522 		_( "Buffer" ),
523 		_( "Buffer to load from" ),
524 		VIPS_ARGUMENT_REQUIRED_INPUT, 
525 		G_STRUCT_OFFSET( VipsForeignLoadPdfBuffer, buf ),
526 		VIPS_TYPE_BLOB );
527 }
528 static void
529 vips_foreign_load_pdf_buffer_init( VipsForeignLoadPdfBuffer *buffer )
530 {
531 }
532 typedef struct _VipsForeignLoadPdfSource {
533 	VipsForeignLoadPdf parent_object;
534 	VipsSource *source;
535 } VipsForeignLoadPdfSource;
536 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfSourceClass;
537 G_DEFINE_TYPE( VipsForeignLoadPdfSource, vips_foreign_load_pdf_source, 
538 	vips_foreign_load_pdf_get_type() );
539 static int
540 vips_foreign_load_pdf_source_build( VipsObject *object )
541 {
542 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
543 	VipsForeignLoadPdfSource *source = (VipsForeignLoadPdfSource *) pdf;
544 	if( source-&gt;source ) {
545 		pdf-&gt;source = source-&gt;source;
546 		g_object_ref( pdf-&gt;source );
547 	}
548 	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_source_parent_class )-&gt;
549 		build( object ) );
550 }
551 static gboolean
552 vips_foreign_load_pdf_source_is_a_source( VipsSource *source )
553 {
554 	const unsigned char *p;
555 	return( (p = vips_source_sniff( source, 4 )) &amp;&amp;
556 		p[0] == '%' &amp;&amp; 
557 <a name="2"></a>		p[1] == 'P' &amp;&amp;
558 		p[2] == 'D' &amp;&amp;
559 		p[3] == 'F' );
560 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
561 static void
562 vips_foreign_load_pdf_source_class_init( 
563 	VipsForeignLoadPdfSourceClass *class )
564 {
565 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
566 	VipsObjectClass *object_class = (VipsObjectClass *) class;
567 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
568 	gobject_class-&gt;set_property = vips_object_set_property;
569 	gobject_class-&gt;get_property = vips_object_get_property;
570 	object_class-&gt;nickname = "pdfload_source";
571 	object_class-&gt;description = _( "load PDF from source" );
572 	object_class-&gt;build = vips_foreign_load_pdf_source_build;</b></font>
573 	load_class-&gt;is_a_source = vips_foreign_load_pdf_source_is_a_source;
574 	VIPS_ARG_OBJECT( class, "source", 1,
575 		_( "Source" ),
576 		_( "Source to load from" ),
577 		VIPS_ARGUMENT_REQUIRED_INPUT, 
578 		G_STRUCT_OFFSET( VipsForeignLoadPdfSource, source ),
579 		VIPS_TYPE_SOURCE );
580 }
581 static void
582 vips_foreign_load_pdf_source_init( VipsForeignLoadPdfSource *source )
583 {
584 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
