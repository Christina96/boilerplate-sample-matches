<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for format_dispatch.c & package.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for format_dispatch.c & package.c
      </h3>
      <h1 align="center">
        38.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>format_dispatch.c (74.71265%)<TH>package.c (26.31579%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#0',2,'match547-1.html#0',3)" NAME="0">(157-208)<TD><A HREF="javascript:ZweiFrames('match547-0.html#0',2,'match547-1.html#0',3)" NAME="0">(333-384)</A><TD ALIGN=center><FONT COLOR="#ff0000">26</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#1',2,'match547-1.html#1',3)" NAME="1">(125-154)<TD><A HREF="javascript:ZweiFrames('match547-0.html#1',2,'match547-1.html#1',3)" NAME="1">(550-597)</A><TD ALIGN=center><FONT COLOR="#a60000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#2',2,'match547-1.html#2',3)" NAME="2">(307-327)<TD><A HREF="javascript:ZweiFrames('match547-0.html#2',2,'match547-1.html#2',3)" NAME="2">(106-133)</A><TD ALIGN=center><FONT COLOR="#9c0000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#3',2,'match547-1.html#3',3)" NAME="3">(399-419)<TD><A HREF="javascript:ZweiFrames('match547-0.html#3',2,'match547-1.html#3',3)" NAME="3">(266-292)</A><TD ALIGN=center><FONT COLOR="#930000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#4',2,'match547-1.html#4',3)" NAME="4">(351-372)<TD><A HREF="javascript:ZweiFrames('match547-0.html#4',2,'match547-1.html#4',3)" NAME="4">(451-481)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#5',2,'match547-1.html#5',3)" NAME="5">(328-349)<TD><A HREF="javascript:ZweiFrames('match547-0.html#5',2,'match547-1.html#5',3)" NAME="5">(422-448)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#6',2,'match547-1.html#6',3)" NAME="6">(261-287)<TD><A HREF="javascript:ZweiFrames('match547-0.html#6',2,'match547-1.html#6',3)" NAME="6">(202-229)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#7',2,'match547-1.html#7',3)" NAME="7">(209-235)<TD><A HREF="javascript:ZweiFrames('match547-0.html#7',2,'match547-1.html#7',3)" NAME="7">(142-169)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#8',2,'match547-1.html#8',3)" NAME="8">(74-95)<TD><A HREF="javascript:ZweiFrames('match547-0.html#8',2,'match547-1.html#8',3)" NAME="8">(386-413)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#9',2,'match547-1.html#9',3)" NAME="9">(48-69)<TD><A HREF="javascript:ZweiFrames('match547-0.html#9',2,'match547-1.html#9',3)" NAME="9">(297-324)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#10',2,'match547-1.html#10',3)" NAME="10">(102-121)<TD><A HREF="javascript:ZweiFrames('match547-0.html#10',2,'match547-1.html#10',3)" NAME="10">(508-538)</A><TD ALIGN=center><FONT COLOR="#7f0000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#11',2,'match547-1.html#11',3)" NAME="11">(377-395)<TD><A HREF="javascript:ZweiFrames('match547-0.html#11',2,'match547-1.html#11',3)" NAME="11">(231-256)</A><TD ALIGN=center><FONT COLOR="#750000">12</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match547-0.html#12',2,'match547-1.html#12',3)" NAME="12">(236-260)<TD><A HREF="javascript:ZweiFrames('match547-0.html#12',2,'match547-1.html#12',3)" NAME="12">(171-196)</A><TD ALIGN=center><FONT COLOR="#750000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>format_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* VIPS function dispatch tables for image format load/save.
 */

/*

    This file is part of VIPS.

    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;

static int
jpeg2vips_vec( im_object *argv )
{
	char *in = argv[0];
<A NAME="9"></A>	IMAGE *out = argv[1];

	if( im_jpeg2vips( in, out ) )
<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match547-1.html#9',3,'match547-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return( -1 );

	return( 0 );
}

static im_arg_desc jpeg2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

static im_function jpeg2vips_desc = {
	&quot;im_jpeg2vips&quot;,			/* Name */
	&quot;convert from jpeg&quot;,		/* Description */
	0,				/* Flags */
	jpeg2vips_vec,			/* Dispatch function */
	IM_NUMBER( jpeg2vips_args ), 	/* Size of arg list */
	jpeg2vips_args 			/* Arg list */
};

static int
vips2dz_vec( im_object *argv )
{</B></FONT>
	IMAGE *in = argv[0];
<A NAME="8"></A>	char *out = argv[1];

	if( im_vips2dz( in, out ) )
<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match547-1.html#8',3,'match547-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return( -1 );

	return( 0 );
}

static im_arg_desc vips2dz_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_STRING( &quot;out&quot; )
};

static im_function vips2dz_desc = {
	&quot;im_vips2dz&quot;,			/* Name */
	&quot;save as deepzoom&quot;,		/* Description */
	0,				/* Flags */
	vips2dz_vec,			/* Dispatch function */
	IM_NUMBER( vips2dz_args ), 	/* Size of arg list */
	vips2dz_args 			/* Arg list */
};

static int
vips2jpeg_vec( im_object *argv )
{</B></FONT>
	IMAGE *in = argv[0];
	char *out = argv[1];

<A NAME="10"></A>	if( im_vips2jpeg( in, out ) )
		return( -1 );

<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match547-1.html#10',3,'match547-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( 0 );
}

static im_arg_desc vips2jpeg_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_STRING( &quot;out&quot; )
};

static im_function vips2jpeg_desc = {
	&quot;im_vips2jpeg&quot;,			/* Name */
	&quot;convert to jpeg&quot;,		/* Description */
	0,				/* Flags */
	vips2jpeg_vec,			/* Dispatch function */
	IM_NUMBER( vips2jpeg_args ), 	/* Size of arg list */
	vips2jpeg_args 			/* Arg list */
};

static int
vips2mimejpeg_vec( im_object *argv )
{</B></FONT>
<A NAME="1"></A>	IMAGE *in = argv[0];
	int qfac = *((int *) argv[1]);

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match547-1.html#1',3,'match547-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if( im_vips2mimejpeg( in, qfac ) )
		return( -1 );

	return( 0 );
}

static im_arg_desc vips2mimejpeg_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_INT( &quot;qfac&quot; )
};

static im_function vips2mimejpeg_desc = {
	&quot;im_vips2mimejpeg&quot;,		/* Name */
	&quot;convert to jpeg as mime type on stdout&quot;, /* Description */
	0,				/* Flags */
	vips2mimejpeg_vec,		/* Dispatch function */
	IM_NUMBER( vips2mimejpeg_args ), /* Size of arg list */
	vips2mimejpeg_args 		/* Arg list */
};

/* Args for vips2png.
 */
static im_arg_desc vips2png_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_STRING( &quot;out&quot; )
};

/* Call im_vips2png via arg vector.
 */
<A NAME="0"></A>static int</B></FONT>
vips2png_vec( im_object *argv )
{
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match547-1.html#0',3,'match547-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_vips2png( argv[0], argv[1] ) );
}

/* Description of im_vips2png.
 */
static im_function vips2png_desc = {
	&quot;im_vips2png&quot;, 			/* Name */
	&quot;convert VIPS image to PNG file&quot;, /* Description */
	0,
	vips2png_vec, 			/* Dispatch function */
	IM_NUMBER( vips2png_args ), 	/* Size of arg list */
	vips2png_args 			/* Arg list */
};

/* Args for png2vips.
 */
static im_arg_desc png2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_png2vips via arg vector.
 */
static int
png2vips_vec( im_object *argv )
{
	return( im_png2vips( argv[0], argv[1] ) );
}

/* Description of im_png2vips.
 */
static im_function png2vips_desc = {
	&quot;im_png2vips&quot;, 			/* Name */
	&quot;convert PNG file to VIPS image&quot;, /* Description */
	0,
	png2vips_vec, 			/* Dispatch function */
	IM_NUMBER( png2vips_args ), 	/* Size of arg list */
	png2vips_args 			/* Arg list */
};

/* Args for exr2vips.
 */
static im_arg_desc exr2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_exr2vips via arg vector.
 */
<A NAME="7"></A>static int
exr2vips_vec( im_object *argv )
{</B></FONT>
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match547-1.html#7',3,'match547-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_exr2vips( argv[0], argv[1] ) );
}

/* Description of im_exr2vips.
 */
static im_function exr2vips_desc = {
	&quot;im_exr2vips&quot;, 			/* Name */
	&quot;convert an OpenEXR file to VIPS&quot;, /* Description */
	0,
	exr2vips_vec, 			/* Dispatch function */
	IM_NUMBER( exr2vips_args ), 	/* Size of arg list */
	exr2vips_args 			/* Arg list */
};

/* Args for vips2tiff.
 */
static im_arg_desc vips2tiff_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_STRING( &quot;out&quot; )
};

/* Call im_vips2tiff via arg vector.
 */
static int
<A NAME="12"></A>vips2tiff_vec( im_object *argv )
{
	return( im_vips2tiff( argv[0], argv[1] ) );</B></FONT>
<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match547-1.html#12',3,'match547-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

/* Description of im_vips2tiff.
 */
static im_function vips2tiff_desc = {
	&quot;im_vips2tiff&quot;, 		/* Name */
	&quot;convert VIPS image to TIFF file&quot;, /* Description */
	0,
	vips2tiff_vec, 			/* Dispatch function */
	IM_NUMBER( vips2tiff_args ), 	/* Size of arg list */
	vips2tiff_args 			/* Arg list */
};

/* Args for magick2vips.
 */
static im_arg_desc magick2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_magick2vips via arg vector.
 */
<A NAME="6"></A>static int
magick2vips_vec( im_object *argv )
{</B></FONT>
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match547-1.html#6',3,'match547-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_magick2vips( argv[0], argv[1] ) );
}

/* Description of im_magick2vips.
 */
static im_function magick2vips_desc = {
	&quot;im_magick2vips&quot;, 		/* Name */
	&quot;load file with libMagick&quot;, 	/* Description */
	0,
	magick2vips_vec, 		/* Dispatch function */
	IM_NUMBER( magick2vips_args ), 	/* Size of arg list */
	magick2vips_args 		/* Arg list */
};

/* Args for tiff2vips.
 */
static im_arg_desc tiff2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_tiff2vips via arg vector.
 */
static int
tiff2vips_vec( im_object *argv )
{
	return( im_tiff2vips( argv[0], argv[1] ) );</B></FONT>
}

/* Description of im_tiff2vips.
 */
static im_function tiff2vips_desc = {
	&quot;im_tiff2vips&quot;, 		/* Name */
	&quot;convert TIFF file to VIPS image&quot;, /* Description */
	0,
	tiff2vips_vec, 			/* Dispatch function */
	IM_NUMBER( tiff2vips_args ), 	/* Size of arg list */
	tiff2vips_args 			/* Arg list */
};

static int
analyze2vips_vec( im_object *argv )
{
<A NAME="2"></A>        const char *in = argv[0];
        IMAGE *out = argv[1];

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match547-1.html#2',3,'match547-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        return( im_analyze2vips( in, out ) );
}

static im_arg_desc analyze2vips_arg_types[] = {
        IM_INPUT_STRING( &quot;filename&quot; ),
        IM_OUTPUT_IMAGE( &quot;im&quot; )
};

static im_function analyze2vips_desc = {
        &quot;im_analyze2vips&quot;,          	/* Name */
        &quot;read a file in analyze format&quot;,/* Description */
        0,                             	/* Flags */
        analyze2vips_vec,               /* Dispatch function */
        IM_NUMBER( analyze2vips_arg_types ),/* Size of arg list */
        analyze2vips_arg_types          /* Arg list */
};

static int
<A NAME="5"></A>csv2vips_vec( im_object *argv )
{
        const char *in = argv[0];</B></FONT>
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match547-1.html#5',3,'match547-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        IMAGE *out = argv[1];

        return( im_csv2vips( in, out ) );
}

static im_arg_desc csv2vips_arg_types[] = {
        IM_INPUT_STRING( &quot;filename&quot; ),
        IM_OUTPUT_IMAGE( &quot;im&quot; )
};

static im_function csv2vips_desc = {
        &quot;im_csv2vips&quot;,          	/* Name */
        &quot;read a file in csv format&quot;,/* Description */
        0,                             	/* Flags */
        csv2vips_vec,               /* Dispatch function */
        IM_NUMBER( csv2vips_arg_types ),/* Size of arg list */
        csv2vips_arg_types          /* Arg list */
};

static int
<A NAME="4"></A>vips2csv_vec( im_object *argv )
{</B></FONT>
        IMAGE *in = argv[0];
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match547-1.html#4',3,'match547-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        const char *filename = argv[1];

        return( im_vips2csv( in, filename ) );
}

static im_arg_desc vips2csv_arg_types[] = {
        IM_INPUT_IMAGE( &quot;in&quot; ),
        IM_INPUT_STRING( &quot;filename&quot; )
};

static im_function vips2csv_desc = {
        &quot;im_vips2csv&quot;,          	/* Name */
        &quot;write an image in csv format&quot;,	/* Description */
        0,                          	/* Flags */
        vips2csv_vec,               	/* Dispatch function */
        IM_NUMBER( vips2csv_arg_types ),/* Size of arg list */
        vips2csv_arg_types          	/* Arg list */
};

static int
ppm2vips_vec( im_object *argv )
{</B></FONT>
        const char *in = argv[0];
<A NAME="11"></A>        IMAGE *out = argv[1];

        return( im_ppm2vips( in, out ) );
<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match547-1.html#11',3,'match547-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static im_arg_desc ppm2vips_arg_types[] = {
        IM_INPUT_STRING( &quot;filename&quot; ),
        IM_OUTPUT_IMAGE( &quot;im&quot; )
};

static im_function ppm2vips_desc = {
        &quot;im_ppm2vips&quot;,                  /* Name */
        &quot;read a file in pbm/pgm/ppm format&quot;,     /* Description */
        0,                              /* Flags */
        ppm2vips_vec,                  	/* Dispatch function */
        IM_NUMBER( ppm2vips_arg_types ),/* Size of arg list */
        ppm2vips_arg_types              /* Arg list */
};

static int
vips2ppm_vec( im_object *argv )
{</B></FONT>
<A NAME="3"></A>        IMAGE *im = argv[0];
        const char *filename = argv[1];

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match547-1.html#3',3,'match547-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        return( im_vips2ppm( im, filename ) );
}

static im_arg_desc vips2ppm_arg_types[] = {
        IM_INPUT_IMAGE( &quot;im&quot; ),
        IM_INPUT_STRING( &quot;filename&quot; )
};

static im_function vips2ppm_desc = {
        &quot;im_vips2ppm&quot;,                  /* Name */
        &quot;write a file in pbm/pgm/ppm format&quot;,     /* Description */
        0,                              /* Flags */
        vips2ppm_vec,                  	/* Dispatch function */
        IM_NUMBER( vips2ppm_arg_types ),/* Size of arg list */
        vips2ppm_arg_types              /* Arg list */
};

static int
fits2vips_vec( im_object *argv )
{
	char *in = argv[0];</B></FONT>
	IMAGE *out = argv[1];

	if( im_fits2vips( in, out ) )
		return( -1 );

	return( 0 );
}

static im_arg_desc fits2vips_args[] = {
	IM_INPUT_STRING( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

static im_function fits2vips_desc = {
	&quot;im_fits2vips&quot;,			/* Name */
	&quot;convert from fits&quot;,		/* Description */
	0,				/* Flags */
	fits2vips_vec,			/* Dispatch function */
	IM_NUMBER( fits2vips_args ), 	/* Size of arg list */
	fits2vips_args 			/* Arg list */
};

/* Package up all these functions.
 */
static im_function *list[] = {
	&amp;csv2vips_desc,
	&amp;fits2vips_desc,
	&amp;jpeg2vips_desc,
	&amp;magick2vips_desc,
	&amp;png2vips_desc,
	&amp;exr2vips_desc,
	&amp;ppm2vips_desc,
	&amp;analyze2vips_desc,
	&amp;tiff2vips_desc,
	&amp;vips2csv_desc,
	&amp;vips2dz_desc,
	&amp;vips2jpeg_desc,
	&amp;vips2mimejpeg_desc,
	&amp;vips2png_desc,
	&amp;vips2ppm_desc,
	&amp;vips2tiff_desc
};

/* Package of functions.
 */
im_package im__format = {
	&quot;format&quot;,
	IM_NUMBER( list ),
	list
};
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>package.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* VIPS package handling.
 *
 * J. Cupitt, 8/4/93.
 *
 * 18/2/04 JC
 *	- now uses g_module_*() instead of dlopen()
 * 9/8/04
 *	- uses glib dir scanning stuff instead of dirent.h
 * 20/5/08
 * 	- note_dependencies() does IMAGEVEC as well as IMAGE
 * 5/8/08
 * 	- silent success in loading plugins if the dir isn't there
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef HAVE_SYS_PARAM_H
#include &lt;sys/param.h&gt;
#endif /*HAVE_SYS_PARAM_H*/
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

/* Standard VIPS packages.
 */
extern im_package im__arithmetic;
extern im_package im__cimg;
extern im_package im__colour;
extern im_package im__conversion;
extern im_package im__convolution;
extern im_package im__deprecated;
extern im_package im__format;
extern im_package im__freq_filt;
extern im_package im__histograms_lut;
extern im_package im__inplace;
extern im_package im__mask;
extern im_package im__morphology;
extern im_package im__mosaicing;
extern im_package im__other;
extern im_package im__resample;
extern im_package im__video;

/* im_guess_prefix() args.
 */
static im_arg_desc guess_prefix_args[] = {
	IM_INPUT_STRING( &quot;argv0&quot; ),
	IM_INPUT_STRING( &quot;env_name&quot; ),
	IM_OUTPUT_STRING( &quot;PREFIX&quot; )
};

/* Call im_guess_prefix() via arg vector.
 */
static int
guess_prefix_vec( im_object *argv )
{
	const char *prefix = vips_guess_prefix( argv[0], argv[1] );

	if( !prefix ) {
		argv[2] = NULL;
		return( -1 );
	}
<A NAME="2"></A>
	argv[2] = im_strdup( NULL, prefix );

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#2',2,'match547-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_guess_prefix.
 */ 
static im_function guess_prefix_desc = {
	&quot;im_guess_prefix&quot;, 		/* Name */
	&quot;guess install area&quot;,		/* Description */
	0,				/* Flags */
	guess_prefix_vec, 		/* Dispatch function */
	VIPS_NUMBER( guess_prefix_args ), /* Size of arg list */
	guess_prefix_args 		/* Arg list */
};

/* im_guess_libdir() args.
 */
static im_arg_desc guess_libdir_args[] = {
	IM_INPUT_STRING( &quot;argv0&quot; ),
	IM_INPUT_STRING( &quot;env_name&quot; ),
	IM_OUTPUT_STRING( &quot;LIBDIR&quot; )
};

/* Call im_guess_libdir() via arg vector.
 */
static int
guess_libdir_vec( im_object *argv )
{
	const char *libdir = vips_guess_libdir( argv[0], argv[1] );</B></FONT>

	if( !libdir ) {
		argv[2] = NULL;
		return( -1 );
	}
<A NAME="7"></A>
	argv[2] = im_strdup( NULL, libdir );

<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#7',2,'match547-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_guess_libdir.
 */ 
static im_function guess_libdir_desc = {
	&quot;im_guess_libdir&quot;, 		/* Name */
	&quot;guess library area&quot;,		/* Description */
	0,				/* Flags */
	guess_libdir_vec, 		/* Dispatch function */
	VIPS_NUMBER( guess_libdir_args ),/* Size of arg list */
	guess_libdir_args 		/* Arg list */
};

/* im_header_int() args.
 */
static im_arg_desc header_int_args[] = {
	IM_INPUT_STRING( &quot;field&quot; ),
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_INT( &quot;value&quot; )
};

/* Call im_header_int() via arg vector.
 */
static int
header_int_vec( im_object *argv )
<A NAME="12"></A>{
	return( im_header_int( (IMAGE *) argv[1], (const char *) argv[0], </B></FONT>
		(int *) argv[2] ) );
<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#12',2,'match547-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_header_int().
 */ 
static im_function header_int_desc = {
	&quot;im_header_int&quot;, 		/* Name */
	&quot;extract int fields from header&quot;,	/* Description */
	0,				/* Flags */
	header_int_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_int_args ),	/* Size of arg list */
	header_int_args 		/* Arg list */
};

/* im_header_get_typeof() args.
 */
static im_arg_desc header_get_typeof_args[] = {
	IM_INPUT_STRING( &quot;field&quot; ),
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_INT( &quot;gtype&quot; )
};

/* Call im_header_get_typeof() via arg vector.
 */
static int
header_get_typeof_vec( im_object *argv )
{</B></FONT>
	int *out = (int *) argv[2];

<A NAME="6"></A>	*out = im_header_get_typeof( (IMAGE *) argv[1], 
		(const char *) argv[0] ); 

<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#6',2,'match547-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_header_get_typeof().
 */ 
static im_function header_get_typeof_desc = {
	&quot;im_header_get_typeof&quot;,		/* Name */
	&quot;return field type&quot;,		/* Description */
	0,				/* Flags */
	header_get_typeof_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_get_typeof_args ),/* Size of arg list */
	header_get_typeof_args 		/* Arg list */
};

/* im_header_double() args.
 */
static im_arg_desc header_double_args[] = {
	IM_INPUT_STRING( &quot;field&quot; ),
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_DOUBLE( &quot;value&quot; )
};

/* Call im_header_double() via arg vector.
 */
static int
header_double_vec( im_object *argv )
<A NAME="11"></A>{
	return( im_header_double( (IMAGE *) argv[1], (const char *) argv[0], </B></FONT>
		(double *) argv[2] ) );
<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#11',2,'match547-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_header_double().
 */ 
static im_function header_double_desc = {
	&quot;im_header_double&quot;, 		/* Name */
	&quot;extract double fields from header&quot;,	/* Description */
	0,				/* Flags */
	header_double_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_double_args ), /* Size of arg list */
	header_double_args 		/* Arg list */
};

/* im_header_string() args.
 */
static im_arg_desc header_string_args[] = {
	IM_INPUT_STRING( &quot;field&quot; ),
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_STRING( &quot;value&quot; )
};

/* Call im_header_string() via arg vector.
 */
static int
header_string_vec( im_object *argv )
{</B></FONT>
	char **out = (char **) &amp;argv[2];

	/* Actually, we call im_header_as_string(), so we can do any field and
	 * not just the string-valued ones.
	 */
	if( im_header_as_string( (IMAGE *) argv[1], 
<A NAME="3"></A>		(const char *) argv[0], out ) )
		return( -1 );

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#3',2,'match547-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_header_string().
 */ 
static im_function header_string_desc = {
	&quot;im_header_string&quot;, 		/* Name */
	&quot;extract fields from headers as strings&quot;,	/* Description */
	0,				/* Flags */
	header_string_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_string_args ),/* Size of arg list */
	header_string_args 		/* Arg list */
};

/* im_history_get() args.
 */
static im_arg_desc history_get_args[] = {
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_STRING( &quot;history&quot; )
};

/* Call im_history_get() via arg vector.
 */
static int
history_get_vec( im_object *argv )
{
	char **out = (char **) &amp;argv[1];</B></FONT>
	const char *str;
<A NAME="9"></A>
	if( !(str = im_history_get( (IMAGE *) argv[0] )) ||
		!(*out = im_strdup( NULL, str )) )
<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#9',2,'match547-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		return( -1 );

	return( 0 );
}

/* Description of im_history_get().
 */ 
static im_function history_get_desc = {
	&quot;im_history_get&quot;, 		/* Name */
	&quot;return the image history as a string&quot;,	/* Description */
	0,				/* Flags */
	history_get_vec, 		/* Dispatch function */
	VIPS_NUMBER( history_get_args ),/* Size of arg list */
	history_get_args 		/* Arg list */
};

/* im_getext() args.
 */
static im_arg_desc getext_args[] = {
	IM_INPUT_IMAGE( &quot;image&quot; ),
	IM_OUTPUT_STRING( &quot;history&quot; )
};

/* Call im_getext() via arg vector.
 */
static int
getext_vec( im_object *argv )
{</B></FONT>
	void **out = (void **) &amp;argv[1];
	int size;

	/* void/char confusion is fine.
	 */
<A NAME="0"></A>	if( !(*out = im__read_extension_block( (IMAGE *) argv[0], &amp;size )) )
		return( -1 );

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#0',2,'match547-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_getext().
 */ 
static im_function getext_desc = {
	&quot;im_getext&quot;, 			/* Name */
	&quot;return the image metadata XML as a string&quot;,	/* Description */
	0,				/* Flags */
	getext_vec, 			/* Dispatch function */
	VIPS_NUMBER( getext_args ), 	/* Size of arg list */
	getext_args 			/* Arg list */
};

/* im_printdesc() args.
 */
static im_arg_desc printdesc_args[] = {
	IM_INPUT_IMAGE( &quot;image&quot; ),
};

/* Call im_printdesc() via arg vector.
 */
static int
printdesc_vec( im_object *argv )
{
	vips_object_print_dump( VIPS_OBJECT( argv[0] ) );

	return( 0 );
}

/* Description of im_printdesc().
 */ 
static im_function printdesc_desc = {
	&quot;im_printdesc&quot;, 		/* Name */
	&quot;print an image header to stdout&quot;,	/* Description */
	0,				/* Flags */
	printdesc_vec, 			/* Dispatch function */
	VIPS_NUMBER( printdesc_args ), 	/* Size of arg list */
	printdesc_args 			/* Arg list */
};

/* im_version_string() args.
 */
static im_arg_desc version_string_args[] = {
	IM_OUTPUT_STRING( &quot;version&quot; )
};

/* Call im_version_string() via arg vector.
 */
static int
<A NAME="8"></A>version_string_vec( im_object *argv )
{</B></FONT>
	if( !(argv[0] = im_strdup( NULL, vips_version_string() )) )
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#8',2,'match547-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		return( -1 );

	return( 0 );
}

/* Description of im_version_string.
 */ 
static im_function version_string_desc = {
	&quot;im_version_string&quot;, 		/* Name */
	&quot;VIPS version string&quot;,		/* Description */
	0,				/* Flags */
	version_string_vec, 		/* Dispatch function */
	VIPS_NUMBER( version_string_args ),/* Size of arg list */
	version_string_args 		/* Arg list */
};

/* im_version() args.
 */
static im_arg_desc version_args[] = {
	IM_INPUT_INT( &quot;flag&quot; ),
	IM_OUTPUT_INT( &quot;version&quot; )
};

/* Call im_version() via arg vector.
 */
static int
version_vec( im_object *argv )
{</B></FONT>
	int flag = *((int *) argv[0]);
	int *out = ((int *) argv[1]);

	int version = vips_version( flag );

<A NAME="5"></A>	if( version &lt; 0 )
		return( -1 );

<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#5',2,'match547-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	*out = version;

	return( 0 );
}

/* Description of im_version.
 */ 
static im_function version_desc = {
	&quot;im_version&quot;, 			/* Name */
	&quot;VIPS version number&quot;,		/* Description */
	0,				/* Flags */
	version_vec, 			/* Dispatch function */
	VIPS_NUMBER( version_args ), 	/* Size of arg list */
	version_args 			/* Arg list */
};

/* im_concurrency_get() args.
 */
static im_arg_desc concurrency_get_args[] = {
	IM_OUTPUT_INT( &quot;concurrency&quot; )
};

/* Call im_concurrency_get() via arg vector.
 */
static int
concurrency_get_vec( im_object *argv )
<A NAME="4"></A>{</B></FONT>
	int *out = ((int *) argv[0]);

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#4',2,'match547-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	*out = vips_concurrency_get();

	return( 0 );
}

/* Description of im_concurrency_get.
 */ 
static im_function concurrency_get_desc = {
	&quot;im_concurrency_get&quot;, 			/* Name */
	&quot;get concurrency level&quot;,		/* Description */
	0,					/* Flags */
	concurrency_get_vec, 			/* Dispatch function */
	VIPS_NUMBER( concurrency_get_args ), 	/* Size of arg list */
	concurrency_get_args 			/* Arg list */
};

/* im_cache() args.
 */
static im_arg_desc cache_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;tile_width&quot; ),
	IM_INPUT_INT( &quot;tile_height&quot; ),
	IM_INPUT_INT( &quot;max_tiles&quot; )
};

/* Call im_cache() via arg vector.
 */
static int
cache_vec( im_object *argv )
{</B></FONT>
	int tile_width = *((int *) argv[2]);
	int tile_height = *((int *) argv[3]);
	int max_tiles = *((int *) argv[4]);

	return( im_cache( argv[0], argv[1], 
		tile_width, tile_height, max_tiles ) );
}

/* Description of im_cache.
 */ 
static im_function cache_desc = {
	&quot;im_cache&quot;, 			/* Name */
	&quot;cache results of an operation&quot;,/* Description */
	0,				/* Flags */
	cache_vec, 			/* Dispatch function */
	VIPS_NUMBER( cache_args ), 	/* Size of arg list */
	cache_args 			/* Arg list */
};

static int
tile_cache_random_vec( im_object *argv )
{
	int tile_width = *((int *) argv[2]);
<A NAME="10"></A>	int tile_height = *((int *) argv[3]);
	int max_tiles = *((int *) argv[4]);

<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#10',2,'match547-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( im_tile_cache_random( argv[0], argv[1], 
		tile_width, tile_height, max_tiles ) );
}

/* Description of im_cache.
 */ 
static im_function tile_cache_random_desc = {
	&quot;im_tile_cache_random&quot;,		/* Name */
	&quot;cache results of an operation&quot;,/* Description */
	0,				/* Flags */
	tile_cache_random_vec, 		/* Dispatch function */
	VIPS_NUMBER( cache_args ), 	/* Size of arg list */
	cache_args 			/* Arg list */
};

/* im_binfile() args.
 */
static im_arg_desc binfile_args[] = {
	IM_INPUT_STRING( &quot;filename&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;height&quot; ),
	IM_INPUT_INT( &quot;bands&quot; ),
	IM_INPUT_INT( &quot;offset&quot; )
};

/* Call im_binfile() via arg vector.
 */
static int
binfile_vec( im_object *argv )
{</B></FONT>
	int width = *((int *) argv[2]);
	int height = *((int *) argv[3]);
	int bands = *((int *) argv[4]);
	int offset = *((int *) argv[5]);
	VipsImage *im;

	if( !(im = vips_image_new_from_file_raw( argv[0], 
		width, height, bands, offset )) )
<A NAME="1"></A>		return( -1 );
	vips_object_local( argv[1], im );

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match547-0.html#1',2,'match547-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if( im_copy( im, argv[1] ) )
		return( -1 );

	return( 0 );
}

/* Description of im_binfile.
 */ 
static im_function binfile_desc = {
	&quot;im_binfile&quot;, 			/* Name */
	&quot;open a headerless binary file&quot;,/* Description */
	0,				/* Flags */
	binfile_vec, 			/* Dispatch function */
	VIPS_NUMBER( binfile_args ), 	/* Size of arg list */
	binfile_args 			/* Arg list */
};

/* Package up iofuncs functions.
 */
static im_function *iofuncs_list[] = {
	&amp;binfile_desc,
	&amp;cache_desc,
	&amp;tile_cache_random_desc,
	&amp;concurrency_get_desc,
	&amp;getext_desc,
	&amp;guess_prefix_desc,
	&amp;guess_libdir_desc,
	&amp;header_get_typeof_desc,
	&amp;header_int_desc,
	&amp;header_double_desc,
	&amp;header_string_desc,
	&amp;history_get_desc,
	&amp;printdesc_desc,
	&amp;version_desc,
	&amp;version_string_desc
};

/* Package of io functions.
 */
static im_package im__iofuncs = {
	&quot;iofuncs&quot;,
	VIPS_NUMBER( iofuncs_list ),
	iofuncs_list
};

/* List of built-in VIPS packages.
 */
static im_package *built_in[] = {</B></FONT>
	&amp;im__arithmetic,
	&amp;im__cimg,
	&amp;im__colour,
	&amp;im__conversion,
	&amp;im__convolution,
	&amp;im__deprecated,
	&amp;im__format,
	&amp;im__freq_filt,
	&amp;im__histograms_lut,
	&amp;im__inplace,
	&amp;im__iofuncs,
	&amp;im__mask,
	&amp;im__morphology,
	&amp;im__mosaicing,
	&amp;im__other,
	&amp;im__resample,
	&amp;im__video
};
/* How we represent a loaded plugin.
 */
typedef struct _Plugin {
	GModule *module;		/* As loaded by g_module_open() */
	char *name;			/* Name we loaded */
	im_package *pack;		/* Package table */
} Plugin;

/* List of loaded plugins.
 */
static GSList *plugin_list = NULL;

/* Free a plugin.
 */
static int
plugin_free( Plugin *plug )
{
	char *name = plug-&gt;name ? plug-&gt;name : &quot;&lt;unknown&gt;&quot;;

	if( plug-&gt;module ) {
		if( !g_module_close( plug-&gt;module ) ) {
			vips_error( &quot;plugin&quot;, 
				_( &quot;unable to close plugin \&quot;%s\&quot;&quot; ), name );
			vips_error( &quot;plugin&quot;, &quot;%s&quot;, g_module_error() );
			return( -1 );
		}

		plug-&gt;module = NULL;
	}
	VIPS_FREE( plug-&gt;name );
	plug-&gt;pack = NULL;
	g_free( plug );

	plugin_list = g_slist_remove( plugin_list, plug );

	return( 0 );
}

/* Load a plugin.
 */
im_package *
im_load_plugin( const char *name )
{
	Plugin *plug;

#ifdef DEBUG
	printf( &quot;im_load_plugin: \&quot;%s\&quot;\n&quot;, name );
#endif /*DEBUG*/

	if( !g_module_supported() ) {
		vips_error( &quot;plugin&quot;,	
			&quot;%s&quot;, _( &quot;plugins not supported on this platform&quot; ) );
		return( NULL );
	}

	/* Build a new plugin.
	 */
	plug = VIPS_NEW( NULL, Plugin );
	plug-&gt;module = NULL;
	plug-&gt;name = g_strdup( name );
	plug-&gt;pack = NULL;
	plugin_list = g_slist_prepend( plugin_list, plug );

	/* Open library.
	 */
	if( !(plug-&gt;module = g_module_open( name, 0 )) ) {
		vips_error( &quot;plugin&quot;, 
			_( &quot;unable to open plugin \&quot;%s\&quot;&quot; ), name );
		vips_error( &quot;plugin&quot;, &quot;%s&quot;, g_module_error() );
		plugin_free( plug );

		return( NULL );
	}

	/* Find package.
	 */
	/* Bizarre double-cast stops a bogus gcc 4.1 compiler warning.
	 */
	if( !g_module_symbol( plug-&gt;module, 
		&quot;package_table&quot;, (gpointer *) ((void *) &amp;plug-&gt;pack) ) ) {
		vips_error( &quot;plugin&quot;,
			_( &quot;unable to find symbol \&quot;package_table\&quot; &quot;
				&quot;in plugin \&quot;%s\&quot;&quot; ), name );
		vips_error( &quot;plugin&quot;, &quot;%s&quot;, g_module_error() );
		plugin_free( plug );

		return( NULL );
	}

	/* Sanity check.
	 */
	if( !plug-&gt;pack-&gt;name || plug-&gt;pack-&gt;nfuncs &lt; 0 || 
		plug-&gt;pack-&gt;nfuncs &gt; 10000 ) {
		vips_error( &quot;plugin&quot;,
			_( &quot;corrupted package table in plugin \&quot;%s\&quot;&quot; ), name );
		plugin_free( plug );

		return( NULL );
	}

#ifdef DEBUG
	printf( &quot;added package \&quot;%s\&quot;\n&quot;, plug-&gt;pack-&gt;name );
#endif /*DEBUG*/

	return( plug-&gt;pack );
}

/* Load all plugins in a directory ... look for '.plg' suffix. Error if we had
 * any probs.
 */
int
im_load_plugins( const char *fmt, ... )
{
        va_list ap;
        char dir_name[VIPS_PATH_MAX];
        GDir *dir;
	const char *name;
        int result;

	/* Silently succeed if we can't do modules.
	 */
	if( !g_module_supported() )
		return( 0 );

        va_start( ap, fmt );
        (void) im_vsnprintf( dir_name, VIPS_PATH_MAX - 1, fmt, ap );
        va_end( ap );

#ifdef DEBUG
	printf( &quot;im_load_plugins: searching \&quot;%s\&quot;\n&quot;, dir_name );
#endif /*DEBUG*/

        if( !(dir = g_dir_open( dir_name, 0, NULL )) ) 
		/* Silent success for dir not there.
		 */
                return( 0 );

        result = 0;
        while( (name = g_dir_read_name( dir )) )
                if( im_ispostfix( name, &quot;.plg&quot; ) ) { 
			char path[VIPS_PATH_MAX];

			im_snprintf( path, VIPS_PATH_MAX - 1, 
				&quot;%s&quot; G_DIR_SEPARATOR_S &quot;%s&quot;, dir_name, name );
			if( !im_load_plugin( path ) )
				result = -1;
                }
        g_dir_close( dir );

	return( result );
}

/* Close all loaded plugins.
 */
int
im_close_plugins( void )
{
	while( plugin_list )
		if( plugin_free( (Plugin *) plugin_list-&gt;data ) )
			return( -1 );

	return( 0 );
}

/* Apply a user-function to a plugin package.
 */
static void *
apply_plugin( Plugin *plug, VSListMap2Fn fn, void *a )
{
	if( !plug-&gt;pack )
		return( NULL );
	else
		return( fn( plug-&gt;pack, a, NULL ) );
}

/* Map a function over all packages. Map over plugins first, to allow
 * overriding of VIPS functions.
 */
void *
im_map_packages( VSListMap2Fn fn, void *a )
{
	void *r = im_slist_map2( plugin_list, 
		(VSListMap2Fn) apply_plugin, (void *) fn, a );

	/* If not there, try main VIPS package list.
	 */
	if( !r ) {
		int i;

		for( i = 0; i &lt; VIPS_NUMBER( built_in ); i++ )
			if( (r = fn( built_in[i], a, NULL )) )
				return( r );
	}

	return( r );
}

/* Search a package for a function.
 */
static im_function *
search_package( im_package *pack, const char *name )
{
	int i;

	for( i = 0; i &lt; pack-&gt;nfuncs; i++ ) 
		if( strcmp( pack-&gt;table[i]-&gt;name, name ) == 0 )
			return( pack-&gt;table[i] );

	return( NULL );
}

/* Search all packages for a function.
 */
im_function *
im_find_function( const char *name )
{
	im_function *fn = im_map_packages( 
		(VSListMap2Fn) search_package, (void *) name );

	if( !fn ) {
		vips_error( &quot;im_find_function&quot;, _( &quot;\&quot;%s\&quot; not found&quot; ), name );
		return( NULL );
	}

	return( fn );
}

/* Test for package is of name.
 */
static im_package *
package_name( im_package *pack, const char *name )
{
	if( strcmp( pack-&gt;name, name ) == 0 )
		return( pack );

	return( NULL );
}

/* Find a package.
 */
im_package *
im_find_package( const char *name )
{
	im_package *pack = im_map_packages( 
		(VSListMap2Fn) package_name, (void *) name );

	if( !pack ) {
		vips_error( &quot;im_find_package&quot;, _( &quot;\&quot;%s\&quot; not found&quot; ), name );
		return( NULL );
	}

	return( pack );
}

/* Test for package contains a function.
 */
static im_package *
package_function( im_package *pack, const char *name )
{
	if( search_package( pack, name ) )
		return( pack );
	else
		return( NULL );
}

/* Find a function's package by name.
 */
im_package *
im_package_of_function( const char *name )
{
	im_package *pack = im_map_packages( 
		(VSListMap2Fn) package_function, (void *) name );

	if( !pack ) {
		vips_error( &quot;im_package_of_function&quot;,
			_( &quot;\&quot;%s\&quot; not found&quot; ), name );
		return( NULL );
	}

	return( pack );
}

/* Free any store we allocated for the argument list.
 */
int
im_free_vargv( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Free all elements.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( vargv[i] ) {
			/* If there is local storage, free it.
			 */
			if( fn-&gt;argv[i].desc-&gt;size != 0 )
				g_free( vargv[i] );

			/* NULL out pointer.
			 */
			vargv[i] = NULL;
		}

	return( 0 );
}

/* Allocate any local store the args will need; NULL out all others.
 */
int
im_allocate_vargv( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* NULL out all pointers.
	 */
	for( i = 0; i &lt; vargc; i++ )
		vargv[i] = NULL;

	/* Allocate any space we will need.
	 */
	for( i = 0; i &lt; vargc; i++ ) {
		int sz = fn-&gt;argv[i].desc-&gt;size;

		if( sz != 0 )
			if( !(vargv[i] = vips_malloc( NULL, sz )) ) {
				/* Free anything we did allocate.
				 */
				(void) im_free_vargv( fn, vargv );
				return( -1 );
			}

		/* Zero memory.
		 */
		memset( vargv[i], 0, sz );
	}

	return( 0 );
}

/* Destroy the objects in the arg list.
 */
static int
destroy_args( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Destroy all elements with destroy functions.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( vargv[i] ) 
			/* If there's a destroy function for this type,
			 * trigger it.
			 */
			if( fn-&gt;argv[i].desc-&gt;dest &amp;&amp;
				fn-&gt;argv[i].desc-&gt;dest( vargv[i] ) )
				return( -1 );

	return( 0 );
}

/* Init an im_object array from a set of command-line arguments.
 */
static int
build_args( im_function *fn, im_object *vargv, int argc, char **argv )
{
	im_arg_desc *arg = fn-&gt;argv;
	int vargc = fn-&gt;argc;
	char *str;
	int i, j;

	/* Loop, constructing each im_arg.
	 */
	for( i = 0, j = 0; i &lt; vargc; i++ ) {
		/* Find type for this arg.
		 */
		im_type_desc *type = arg[i].desc;

		/* Do we need to use up a command line argument?
		 */
		if( type-&gt;flags &amp; IM_TYPE_ARG ) {
			if( !argv[j] ) {
				vips_error( &quot;im_run_command&quot;,
					&quot;%s&quot;, _( &quot;too few arguments&quot; ) );
				return( -1 );
			}
			str = argv[j++];

			/* Init object.
			 */
			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], str ) )
				return( -1 );
		}
		else {
			/* Init object with no arg.
			 */
			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], &quot;no arg&quot; ) )
				return( -1 );
		}
	}

	/* Have we used up all the command-line args?
	 */
	if( argv[j] ) {
		vips_error( &quot;im_run_command&quot;, &quot;%s&quot;, _( &quot;too many arguments&quot; ) );
		return( -1 );
	}

	return( 0 );
}

/* Make a region on sub, closed by callback on main.
 */
static int
region_local_image( IMAGE *main, IMAGE *sub )
{
	VipsRegion *reg;

	if( !(reg = vips_region_new( sub )) )
		return( -1 );
	vips_object_local( main, reg ); 
 
        return( 0 );
}

/* vargv[i] is an output image on a PIO function ... make all input images 
 * depend on it.
 */
static int
note_dependencies( im_function *fn, im_object *vargv, int i )
{
	int j;

	for( j = 0; j &lt; fn-&gt;argc; j++ ) {
		im_type_desc *type = fn-&gt;argv[j].desc;

		if( !(type-&gt;flags &amp; IM_TYPE_OUTPUT) ) {
			if( strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 ) {
				if( region_local_image( vargv[i], vargv[j] ) )
					return( -1 );
			}
			else if( strcmp( type-&gt;type, IM_TYPE_IMAGEVEC ) == 0 ) {
				im_imagevec_object *iv = vargv[j];
				int k;

				for( k = 0; k &lt; iv-&gt;n; k++ )
					if( region_local_image( vargv[i], 
						iv-&gt;vec[k] ) )
						return( -1 );
			}
		}
	}

	return( 0 );
}

/* Call all defined print functions.
 */
static int
print_args( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Print all elements.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( fn-&gt;argv[i].print &amp;&amp; vargv[i] ) 
			if( fn-&gt;argv[i].print( vargv[i] ) )
				return( -1 );

	return( 0 );
}

/* Add to the hist of all output images.
 */
static int
add_hist( im_function *fn, im_object *vargv, int argc, char **argv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Search for output images.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( strcmp( fn-&gt;argv[i].desc-&gt;type, IM_TYPE_IMAGE ) == 0 &amp;&amp;
			(fn-&gt;argv[i].desc-&gt;flags &amp; IM_TYPE_OUTPUT) )
			if( im_updatehist( vargv[i], fn-&gt;name, argc, argv ) )
				return( -1 );

	return( 0 );
}

/* Call a VIPS function.
 */
static int
dispatch_function( im_function *fn, im_object *vargv, int argc, char **argv )
{
	/* Init memory from command line arguments.
	 */
	if( build_args( fn, vargv, argc, argv ) ) 
		return( -1 );

	/* If this is a PIO function, we need to make sure that we close
	 * the input images after the output images, since the output image
	 * may include delayed image conversion filters which will not run
	 * until the output is closed.
	 *
	 * Do this by:
	 *	- for each output image
	 *		- for each input image
	 *			- create a region on the input, closed by a
	 *			  close callback on the output image
	 */
	if( fn-&gt;flags &amp; IM_FN_PIO ) {
		int i;

		for( i = 0; i &lt; fn-&gt;argc; i++ ) {
			im_type_desc *type = fn-&gt;argv[i].desc;

			if( type-&gt;flags &amp; IM_TYPE_OUTPUT &amp;&amp;
				strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 )
				if( note_dependencies( fn, vargv, i ) )
					return( -1 );
		}
	}

	/* Call function.
	 */
	if( fn-&gt;disp( vargv ) ) 
		return( -1 );

	/* Print output.
	 */
	if( print_args( fn, vargv ) ) 
		return( -1 );

	/* Add to history of all output images.
	 */
	if( add_hist( fn, vargv, argc, argv ) )
		return( -1 );

	/* All ok!
	 */
	return( 0 );
}

/* Run a command.
 */
int
im_run_command( char *name, int argc, char **argv )
{
	static im_object object_array[IM_MAX_ARGS];
	im_object *vargv = object_array;
	im_function *fn;

	/* Search packages for a matching function.
	 */
	if( !(fn = im_find_function( name )) )
		return( -1 );

	/* Allocate space for arguments.
	 */
	if( im_allocate_vargv( fn, vargv ) ) 
		return( -1 );

	/* Call it.
	 */ 
	if( dispatch_function( fn, vargv, argc, argv ) ) {
		destroy_args( fn, vargv );
		im_free_vargv( fn, vargv );
		return( -1 );
	}

	/* Clean up and exit.
	 */
	if( destroy_args( fn, vargv ) ) 
		return( -1 );
	im_free_vargv( fn, vargv );

	return( 0 );
}
</PRE>
</div>
  </div>
</body>
</html>
