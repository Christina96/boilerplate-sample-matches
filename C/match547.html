<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for format_dispatch.c &amp; package.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for format_dispatch.c &amp; package.c
      </h3>
<h1 align="center">
        38.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>format_dispatch.c (74.71265%)<th>package.c (26.31579%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(157-208)<td><a href="#" name="0">(333-384)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(125-154)<td><a href="#" name="1">(550-597)</a><td align="center"><font color="#a60000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(307-327)<td><a href="#" name="2">(106-133)</a><td align="center"><font color="#9c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(399-419)<td><a href="#" name="3">(266-292)</a><td align="center"><font color="#930000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(351-372)<td><a href="#" name="4">(451-481)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(328-349)<td><a href="#" name="5">(422-448)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(261-287)<td><a href="#" name="6">(202-229)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(209-235)<td><a href="#" name="7">(142-169)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(74-95)<td><a href="#" name="8">(386-413)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(48-69)<td><a href="#" name="9">(297-324)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(102-121)<td><a href="#" name="10">(508-538)</a><td align="center"><font color="#7f0000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(377-395)<td><a href="#" name="11">(231-256)</a><td align="center"><font color="#750000">12</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(236-260)<td><a href="#" name="12">(171-196)</a><td align="center"><font color="#750000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>format_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 static int
8 jpeg2vips_vec( im_object *argv )
9 {
10 	char *in = argv[0];
11 <a name="9"></a>	IMAGE *out = argv[1];
12 	if( im_jpeg2vips( in, out ) )
13 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
14 	return( 0 );
15 }
16 static im_arg_desc jpeg2vips_args[] = {
17 	IM_INPUT_STRING( "in" ),
18 	IM_OUTPUT_IMAGE( "out" )
19 };
20 static im_function jpeg2vips_desc = {
21 	"im_jpeg2vips",				"convert from jpeg",			0,					jpeg2vips_vec,				IM_NUMBER( jpeg2vips_args ), 		jpeg2vips_args 			};
22 static int
23 vips2dz_vec( im_object *argv )
24 {</b></font>
25 	IMAGE *in = argv[0];
26 <a name="8"></a>	char *out = argv[1];
27 	if( im_vips2dz( in, out ) )
28 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
29 	return( 0 );
30 }
31 static im_arg_desc vips2dz_args[] = {
32 	IM_INPUT_IMAGE( "in" ),
33 	IM_INPUT_STRING( "out" )
34 };
35 static im_function vips2dz_desc = {
36 	"im_vips2dz",				"save as deepzoom",			0,					vips2dz_vec,				IM_NUMBER( vips2dz_args ), 		vips2dz_args 			};
37 static int
38 vips2jpeg_vec( im_object *argv )
39 {</b></font>
40 	IMAGE *in = argv[0];
41 	char *out = argv[1];
42 <a name="10"></a>	if( im_vips2jpeg( in, out ) )
43 		return( -1 );
44 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
45 }
46 static im_arg_desc vips2jpeg_args[] = {
47 	IM_INPUT_IMAGE( "in" ),
48 	IM_INPUT_STRING( "out" )
49 };
50 static im_function vips2jpeg_desc = {
51 	"im_vips2jpeg",				"convert to jpeg",			0,					vips2jpeg_vec,				IM_NUMBER( vips2jpeg_args ), 		vips2jpeg_args 			};
52 static int
53 vips2mimejpeg_vec( im_object *argv )
54 {</b></font>
55 <a name="1"></a>	IMAGE *in = argv[0];
56 	int qfac = *((int *) argv[1]);
57 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( im_vips2mimejpeg( in, qfac ) )
58 		return( -1 );
59 	return( 0 );
60 }
61 static im_arg_desc vips2mimejpeg_args[] = {
62 	IM_INPUT_IMAGE( "in" ),
63 	IM_INPUT_INT( "qfac" )
64 };
65 static im_function vips2mimejpeg_desc = {
66 	"im_vips2mimejpeg",			"convert to jpeg as mime type on stdout", 	0,					vips2mimejpeg_vec,			IM_NUMBER( vips2mimejpeg_args ), 	vips2mimejpeg_args 		};
67 static im_arg_desc vips2png_args[] = {
68 	IM_INPUT_IMAGE( "in" ),
69 	IM_INPUT_STRING( "out" )
70 };
71 <a name="0"></a>static int</b></font>
72 vips2png_vec( im_object *argv )
73 {
74 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_vips2png( argv[0], argv[1] ) );
75 }
76 static im_function vips2png_desc = {
77 	"im_vips2png", 				"convert VIPS image to PNG file", 	0,
78 	vips2png_vec, 				IM_NUMBER( vips2png_args ), 		vips2png_args 			};
79 static im_arg_desc png2vips_args[] = {
80 	IM_INPUT_STRING( "in" ),
81 	IM_OUTPUT_IMAGE( "out" )
82 };
83 static int
84 png2vips_vec( im_object *argv )
85 {
86 	return( im_png2vips( argv[0], argv[1] ) );
87 }
88 static im_function png2vips_desc = {
89 	"im_png2vips", 				"convert PNG file to VIPS image", 	0,
90 	png2vips_vec, 				IM_NUMBER( png2vips_args ), 		png2vips_args 			};
91 static im_arg_desc exr2vips_args[] = {
92 	IM_INPUT_STRING( "in" ),
93 	IM_OUTPUT_IMAGE( "out" )
94 };
95 <a name="7"></a>static int
96 exr2vips_vec( im_object *argv )
97 {</b></font>
98 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_exr2vips( argv[0], argv[1] ) );
99 }
100 static im_function exr2vips_desc = {
101 	"im_exr2vips", 				"convert an OpenEXR file to VIPS", 	0,
102 	exr2vips_vec, 				IM_NUMBER( exr2vips_args ), 		exr2vips_args 			};
103 static im_arg_desc vips2tiff_args[] = {
104 	IM_INPUT_IMAGE( "in" ),
105 	IM_INPUT_STRING( "out" )
106 };
107 static int
108 <a name="12"></a>vips2tiff_vec( im_object *argv )
109 {
110 	return( im_vips2tiff( argv[0], argv[1] ) );</b></font>
111 <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
112 static im_function vips2tiff_desc = {
113 	"im_vips2tiff", 			"convert VIPS image to TIFF file", 	0,
114 	vips2tiff_vec, 				IM_NUMBER( vips2tiff_args ), 		vips2tiff_args 			};
115 static im_arg_desc magick2vips_args[] = {
116 	IM_INPUT_STRING( "in" ),
117 	IM_OUTPUT_IMAGE( "out" )
118 };
119 <a name="6"></a>static int
120 magick2vips_vec( im_object *argv )
121 {</b></font>
122 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_magick2vips( argv[0], argv[1] ) );
123 }
124 static im_function magick2vips_desc = {
125 	"im_magick2vips", 			"load file with libMagick", 		0,
126 	magick2vips_vec, 			IM_NUMBER( magick2vips_args ), 		magick2vips_args 		};
127 static im_arg_desc tiff2vips_args[] = {
128 	IM_INPUT_STRING( "in" ),
129 	IM_OUTPUT_IMAGE( "out" )
130 };
131 static int
132 tiff2vips_vec( im_object *argv )
133 {
134 	return( im_tiff2vips( argv[0], argv[1] ) );</b></font>
135 }
136 static im_function tiff2vips_desc = {
137 	"im_tiff2vips", 			"convert TIFF file to VIPS image", 	0,
138 	tiff2vips_vec, 				IM_NUMBER( tiff2vips_args ), 		tiff2vips_args 			};
139 static int
140 analyze2vips_vec( im_object *argv )
141 {
142 <a name="2"></a>        const char *in = argv[0];
143         IMAGE *out = argv[1];
144 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_analyze2vips( in, out ) );
145 }
146 static im_arg_desc analyze2vips_arg_types[] = {
147         IM_INPUT_STRING( "filename" ),
148         IM_OUTPUT_IMAGE( "im" )
149 };
150 static im_function analyze2vips_desc = {
151         "im_analyze2vips",          	        "read a file in analyze format",        0,                             	        analyze2vips_vec,                       IM_NUMBER( analyze2vips_arg_types ),        analyze2vips_arg_types          };
152 static int
153 <a name="5"></a>csv2vips_vec( im_object *argv )
154 {
155         const char *in = argv[0];</b></font>
156 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        IMAGE *out = argv[1];
157         return( im_csv2vips( in, out ) );
158 }
159 static im_arg_desc csv2vips_arg_types[] = {
160         IM_INPUT_STRING( "filename" ),
161         IM_OUTPUT_IMAGE( "im" )
162 };
163 static im_function csv2vips_desc = {
164         "im_csv2vips",          	        "read a file in csv format",        0,                             	        csv2vips_vec,                       IM_NUMBER( csv2vips_arg_types ),        csv2vips_arg_types          };
165 static int
166 <a name="4"></a>vips2csv_vec( im_object *argv )
167 {</b></font>
168         IMAGE *in = argv[0];
169 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        const char *filename = argv[1];
170         return( im_vips2csv( in, filename ) );
171 }
172 static im_arg_desc vips2csv_arg_types[] = {
173         IM_INPUT_IMAGE( "in" ),
174         IM_INPUT_STRING( "filename" )
175 };
176 static im_function vips2csv_desc = {
177         "im_vips2csv",          	        "write an image in csv format",	        0,                          	        vips2csv_vec,               	        IM_NUMBER( vips2csv_arg_types ),        vips2csv_arg_types          	};
178 static int
179 ppm2vips_vec( im_object *argv )
180 {</b></font>
181         const char *in = argv[0];
182 <a name="11"></a>        IMAGE *out = argv[1];
183         return( im_ppm2vips( in, out ) );
184 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
185 static im_arg_desc ppm2vips_arg_types[] = {
186         IM_INPUT_STRING( "filename" ),
187         IM_OUTPUT_IMAGE( "im" )
188 };
189 static im_function ppm2vips_desc = {
190         "im_ppm2vips",                          "read a file in pbm/pgm/ppm format",             0,                                      ppm2vips_vec,                  	        IM_NUMBER( ppm2vips_arg_types ),        ppm2vips_arg_types              };
191 static int
192 vips2ppm_vec( im_object *argv )
193 {</b></font>
194 <a name="3"></a>        IMAGE *im = argv[0];
195         const char *filename = argv[1];
196 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_vips2ppm( im, filename ) );
197 }
198 static im_arg_desc vips2ppm_arg_types[] = {
199         IM_INPUT_IMAGE( "im" ),
200         IM_INPUT_STRING( "filename" )
201 };
202 static im_function vips2ppm_desc = {
203         "im_vips2ppm",                          "write a file in pbm/pgm/ppm format",             0,                                      vips2ppm_vec,                  	        IM_NUMBER( vips2ppm_arg_types ),        vips2ppm_arg_types              };
204 static int
205 fits2vips_vec( im_object *argv )
206 {
207 	char *in = argv[0];</b></font>
208 	IMAGE *out = argv[1];
209 	if( im_fits2vips( in, out ) )
210 		return( -1 );
211 	return( 0 );
212 }
213 static im_arg_desc fits2vips_args[] = {
214 	IM_INPUT_STRING( "in" ),
215 	IM_OUTPUT_IMAGE( "out" )
216 };
217 static im_function fits2vips_desc = {
218 	"im_fits2vips",				"convert from fits",			0,					fits2vips_vec,				IM_NUMBER( fits2vips_args ), 		fits2vips_args 			};
219 static im_function *list[] = {
220 	&amp;csv2vips_desc,
221 	&amp;fits2vips_desc,
222 	&amp;jpeg2vips_desc,
223 	&amp;magick2vips_desc,
224 	&amp;png2vips_desc,
225 	&amp;exr2vips_desc,
226 	&amp;ppm2vips_desc,
227 	&amp;analyze2vips_desc,
228 	&amp;tiff2vips_desc,
229 	&amp;vips2csv_desc,
230 	&amp;vips2dz_desc,
231 	&amp;vips2jpeg_desc,
232 	&amp;vips2mimejpeg_desc,
233 	&amp;vips2png_desc,
234 	&amp;vips2ppm_desc,
235 	&amp;vips2tiff_desc
236 };
237 im_package im__format = {
238 	"format",
239 	IM_NUMBER( list ),
240 	list
241 };
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>package.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #ifdef HAVE_SYS_PARAM_H
7 #include &lt;sys/param.h&gt;
8 #include &lt;string.h&gt;
9 #include &lt;stdarg.h&gt;
10 #include &lt;limits.h&gt;
11 #include &lt;vips/vips.h&gt;
12 #include &lt;vips/vips7compat.h&gt;
13 #include &lt;vips/internal.h&gt;
14 #include &lt;vips/debug.h&gt;
15 extern im_package im__arithmetic;
16 extern im_package im__cimg;
17 extern im_package im__colour;
18 extern im_package im__conversion;
19 extern im_package im__convolution;
20 extern im_package im__deprecated;
21 extern im_package im__format;
22 extern im_package im__freq_filt;
23 extern im_package im__histograms_lut;
24 extern im_package im__inplace;
25 extern im_package im__mask;
26 extern im_package im__morphology;
27 extern im_package im__mosaicing;
28 extern im_package im__other;
29 extern im_package im__resample;
30 extern im_package im__video;
31 static im_arg_desc guess_prefix_args[] = {
32 	IM_INPUT_STRING( "argv0" ),
33 	IM_INPUT_STRING( "env_name" ),
34 	IM_OUTPUT_STRING( "PREFIX" )
35 };
36 static int
37 guess_prefix_vec( im_object *argv )
38 {
39 	const char *prefix = vips_guess_prefix( argv[0], argv[1] );
40 	if( !prefix ) {
41 		argv[2] = NULL;
42 		return( -1 );
43 	}
44 <a name="2"></a>
45 	argv[2] = im_strdup( NULL, prefix );
46 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
47 }
48 static im_function guess_prefix_desc = {
49 	"im_guess_prefix", 			"guess install area",			0,					guess_prefix_vec, 			VIPS_NUMBER( guess_prefix_args ), 	guess_prefix_args 		};
50 static im_arg_desc guess_libdir_args[] = {
51 	IM_INPUT_STRING( "argv0" ),
52 	IM_INPUT_STRING( "env_name" ),
53 	IM_OUTPUT_STRING( "LIBDIR" )
54 };
55 static int
56 guess_libdir_vec( im_object *argv )
57 {
58 	const char *libdir = vips_guess_libdir( argv[0], argv[1] );</b></font>
59 	if( !libdir ) {
60 		argv[2] = NULL;
61 		return( -1 );
62 	}
63 <a name="7"></a>
64 	argv[2] = im_strdup( NULL, libdir );
65 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
66 }
67 static im_function guess_libdir_desc = {
68 	"im_guess_libdir", 			"guess library area",			0,					guess_libdir_vec, 			VIPS_NUMBER( guess_libdir_args ),	guess_libdir_args 		};
69 static im_arg_desc header_int_args[] = {
70 	IM_INPUT_STRING( "field" ),
71 	IM_INPUT_IMAGE( "image" ),
72 	IM_OUTPUT_INT( "value" )
73 };
74 static int
75 header_int_vec( im_object *argv )
76 <a name="12"></a>{
77 	return( im_header_int( (IMAGE *) argv[1], (const char *) argv[0], </b></font>
78 		(int *) argv[2] ) );
79 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
80 static im_function header_int_desc = {
81 	"im_header_int", 			"extract int fields from header",		0,					header_int_vec, 			VIPS_NUMBER( header_int_args ),		header_int_args 		};
82 static im_arg_desc header_get_typeof_args[] = {
83 	IM_INPUT_STRING( "field" ),
84 	IM_INPUT_IMAGE( "image" ),
85 	IM_OUTPUT_INT( "gtype" )
86 };
87 static int
88 header_get_typeof_vec( im_object *argv )
89 {</b></font>
90 	int *out = (int *) argv[2];
91 <a name="6"></a>	*out = im_header_get_typeof( (IMAGE *) argv[1], 
92 		(const char *) argv[0] ); 
93 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
94 }
95 static im_function header_get_typeof_desc = {
96 	"im_header_get_typeof",			"return field type",			0,					header_get_typeof_vec, 			VIPS_NUMBER( header_get_typeof_args ),	header_get_typeof_args 		};
97 static im_arg_desc header_double_args[] = {
98 	IM_INPUT_STRING( "field" ),
99 	IM_INPUT_IMAGE( "image" ),
100 	IM_OUTPUT_DOUBLE( "value" )
101 };
102 static int
103 header_double_vec( im_object *argv )
104 <a name="11"></a>{
105 	return( im_header_double( (IMAGE *) argv[1], (const char *) argv[0], </b></font>
106 		(double *) argv[2] ) );
107 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
108 static im_function header_double_desc = {
109 	"im_header_double", 			"extract double fields from header",		0,					header_double_vec, 			VIPS_NUMBER( header_double_args ), 	header_double_args 		};
110 static im_arg_desc header_string_args[] = {
111 	IM_INPUT_STRING( "field" ),
112 	IM_INPUT_IMAGE( "image" ),
113 	IM_OUTPUT_STRING( "value" )
114 };
115 static int
116 header_string_vec( im_object *argv )
117 {</b></font>
118 	char **out = (char **) &amp;argv[2];
119 	if( im_header_as_string( (IMAGE *) argv[1], 
120 <a name="3"></a>		(const char *) argv[0], out ) )
121 		return( -1 );
122 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
123 }
124 static im_function header_string_desc = {
125 	"im_header_string", 			"extract fields from headers as strings",		0,					header_string_vec, 			VIPS_NUMBER( header_string_args ),	header_string_args 		};
126 static im_arg_desc history_get_args[] = {
127 	IM_INPUT_IMAGE( "image" ),
128 	IM_OUTPUT_STRING( "history" )
129 };
130 static int
131 history_get_vec( im_object *argv )
132 {
133 	char **out = (char **) &amp;argv[1];</b></font>
134 	const char *str;
135 <a name="9"></a>
136 	if( !(str = im_history_get( (IMAGE *) argv[0] )) ||
137 		!(*out = im_strdup( NULL, str )) )
138 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
139 	return( 0 );
140 }
141 static im_function history_get_desc = {
142 	"im_history_get", 			"return the image history as a string",		0,					history_get_vec, 			VIPS_NUMBER( history_get_args ),	history_get_args 		};
143 static im_arg_desc getext_args[] = {
144 	IM_INPUT_IMAGE( "image" ),
145 	IM_OUTPUT_STRING( "history" )
146 };
147 static int
148 getext_vec( im_object *argv )
149 {</b></font>
150 	void **out = (void **) &amp;argv[1];
151 	int size;
152 <a name="0"></a>	if( !(*out = im__read_extension_block( (IMAGE *) argv[0], &amp;size )) )
153 		return( -1 );
154 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
155 }
156 static im_function getext_desc = {
157 	"im_getext", 				"return the image metadata XML as a string",		0,					getext_vec, 				VIPS_NUMBER( getext_args ), 		getext_args 			};
158 static im_arg_desc printdesc_args[] = {
159 	IM_INPUT_IMAGE( "image" ),
160 };
161 static int
162 printdesc_vec( im_object *argv )
163 {
164 	vips_object_print_dump( VIPS_OBJECT( argv[0] ) );
165 	return( 0 );
166 }
167 static im_function printdesc_desc = {
168 	"im_printdesc", 			"print an image header to stdout",		0,					printdesc_vec, 				VIPS_NUMBER( printdesc_args ), 		printdesc_args 			};
169 static im_arg_desc version_string_args[] = {
170 	IM_OUTPUT_STRING( "version" )
171 };
172 static int
173 <a name="8"></a>version_string_vec( im_object *argv )
174 {</b></font>
175 	if( !(argv[0] = im_strdup( NULL, vips_version_string() )) )
176 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
177 	return( 0 );
178 }
179 static im_function version_string_desc = {
180 	"im_version_string", 			"VIPS version string",			0,					version_string_vec, 			VIPS_NUMBER( version_string_args ),	version_string_args 		};
181 static im_arg_desc version_args[] = {
182 	IM_INPUT_INT( "flag" ),
183 	IM_OUTPUT_INT( "version" )
184 };
185 static int
186 version_vec( im_object *argv )
187 {</b></font>
188 	int flag = *((int *) argv[0]);
189 	int *out = ((int *) argv[1]);
190 	int version = vips_version( flag );
191 <a name="5"></a>	if( version &lt; 0 )
192 		return( -1 );
193 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	*out = version;
194 	return( 0 );
195 }
196 static im_function version_desc = {
197 	"im_version", 				"VIPS version number",			0,					version_vec, 				VIPS_NUMBER( version_args ), 		version_args 			};
198 static im_arg_desc concurrency_get_args[] = {
199 	IM_OUTPUT_INT( "concurrency" )
200 };
201 static int
202 concurrency_get_vec( im_object *argv )
203 <a name="4"></a>{</b></font>
204 	int *out = ((int *) argv[0]);
205 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	*out = vips_concurrency_get();
206 	return( 0 );
207 }
208 static im_function concurrency_get_desc = {
209 	"im_concurrency_get", 				"get concurrency level",			0,						concurrency_get_vec, 				VIPS_NUMBER( concurrency_get_args ), 		concurrency_get_args 			};
210 static im_arg_desc cache_args[] = {
211 	IM_INPUT_IMAGE( "in" ),
212 	IM_OUTPUT_IMAGE( "out" ),
213 	IM_INPUT_INT( "tile_width" ),
214 	IM_INPUT_INT( "tile_height" ),
215 	IM_INPUT_INT( "max_tiles" )
216 };
217 static int
218 cache_vec( im_object *argv )
219 {</b></font>
220 	int tile_width = *((int *) argv[2]);
221 	int tile_height = *((int *) argv[3]);
222 	int max_tiles = *((int *) argv[4]);
223 	return( im_cache( argv[0], argv[1], 
224 		tile_width, tile_height, max_tiles ) );
225 }
226 static im_function cache_desc = {
227 	"im_cache", 				"cache results of an operation",	0,					cache_vec, 				VIPS_NUMBER( cache_args ), 		cache_args 			};
228 static int
229 tile_cache_random_vec( im_object *argv )
230 {
231 	int tile_width = *((int *) argv[2]);
232 <a name="10"></a>	int tile_height = *((int *) argv[3]);
233 	int max_tiles = *((int *) argv[4]);
234 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_tile_cache_random( argv[0], argv[1], 
235 		tile_width, tile_height, max_tiles ) );
236 }
237 static im_function tile_cache_random_desc = {
238 	"im_tile_cache_random",			"cache results of an operation",	0,					tile_cache_random_vec, 			VIPS_NUMBER( cache_args ), 		cache_args 			};
239 static im_arg_desc binfile_args[] = {
240 	IM_INPUT_STRING( "filename" ),
241 	IM_OUTPUT_IMAGE( "out" ),
242 	IM_INPUT_INT( "width" ),
243 	IM_INPUT_INT( "height" ),
244 	IM_INPUT_INT( "bands" ),
245 	IM_INPUT_INT( "offset" )
246 };
247 static int
248 binfile_vec( im_object *argv )
249 {</b></font>
250 	int width = *((int *) argv[2]);
251 	int height = *((int *) argv[3]);
252 	int bands = *((int *) argv[4]);
253 	int offset = *((int *) argv[5]);
254 	VipsImage *im;
255 	if( !(im = vips_image_new_from_file_raw( argv[0], 
256 		width, height, bands, offset )) )
257 <a name="1"></a>		return( -1 );
258 	vips_object_local( argv[1], im );
259 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_copy( im, argv[1] ) )
260 		return( -1 );
261 	return( 0 );
262 }
263 static im_function binfile_desc = {
264 	"im_binfile", 				"open a headerless binary file",	0,					binfile_vec, 				VIPS_NUMBER( binfile_args ), 		binfile_args 			};
265 static im_function *iofuncs_list[] = {
266 	&amp;binfile_desc,
267 	&amp;cache_desc,
268 	&amp;tile_cache_random_desc,
269 	&amp;concurrency_get_desc,
270 	&amp;getext_desc,
271 	&amp;guess_prefix_desc,
272 	&amp;guess_libdir_desc,
273 	&amp;header_get_typeof_desc,
274 	&amp;header_int_desc,
275 	&amp;header_double_desc,
276 	&amp;header_string_desc,
277 	&amp;history_get_desc,
278 	&amp;printdesc_desc,
279 	&amp;version_desc,
280 	&amp;version_string_desc
281 };
282 static im_package im__iofuncs = {
283 	"iofuncs",
284 	VIPS_NUMBER( iofuncs_list ),
285 	iofuncs_list
286 };
287 static im_package *built_in[] = {</b></font>
288 	&amp;im__arithmetic,
289 	&amp;im__cimg,
290 	&amp;im__colour,
291 	&amp;im__conversion,
292 	&amp;im__convolution,
293 	&amp;im__deprecated,
294 	&amp;im__format,
295 	&amp;im__freq_filt,
296 	&amp;im__histograms_lut,
297 	&amp;im__inplace,
298 	&amp;im__iofuncs,
299 	&amp;im__mask,
300 	&amp;im__morphology,
301 	&amp;im__mosaicing,
302 	&amp;im__other,
303 	&amp;im__resample,
304 	&amp;im__video
305 };
306 typedef struct _Plugin {
307 	GModule *module;			char *name;				im_package *pack;		} Plugin;
308 static GSList *plugin_list = NULL;
309 static int
310 plugin_free( Plugin *plug )
311 {
312 	char *name = plug-&gt;name ? plug-&gt;name : "&lt;unknown&gt;";
313 	if( plug-&gt;module ) {
314 		if( !g_module_close( plug-&gt;module ) ) {
315 			vips_error( "plugin", 
316 				_( "unable to close plugin \"%s\"" ), name );
317 			vips_error( "plugin", "%s", g_module_error() );
318 			return( -1 );
319 		}
320 		plug-&gt;module = NULL;
321 	}
322 	VIPS_FREE( plug-&gt;name );
323 	plug-&gt;pack = NULL;
324 	g_free( plug );
325 	plugin_list = g_slist_remove( plugin_list, plug );
326 	return( 0 );
327 }
328 im_package *
329 im_load_plugin( const char *name )
330 {
331 	Plugin *plug;
332 #ifdef DEBUG
333 	printf( "im_load_plugin: \"%s\"\n", name );
334 	if( !g_module_supported() ) {
335 		vips_error( "plugin",	
336 			"%s", _( "plugins not supported on this platform" ) );
337 		return( NULL );
338 	}
339 	plug = VIPS_NEW( NULL, Plugin );
340 	plug-&gt;module = NULL;
341 	plug-&gt;name = g_strdup( name );
342 	plug-&gt;pack = NULL;
343 	plugin_list = g_slist_prepend( plugin_list, plug );
344 	if( !(plug-&gt;module = g_module_open( name, 0 )) ) {
345 		vips_error( "plugin", 
346 			_( "unable to open plugin \"%s\"" ), name );
347 		vips_error( "plugin", "%s", g_module_error() );
348 		plugin_free( plug );
349 		return( NULL );
350 	}
351 	if( !g_module_symbol( plug-&gt;module, 
352 		"package_table", (gpointer *) ((void *) &amp;plug-&gt;pack) ) ) {
353 		vips_error( "plugin",
354 			_( "unable to find symbol \"package_table\" "
355 				"in plugin \"%s\"" ), name );
356 		vips_error( "plugin", "%s", g_module_error() );
357 		plugin_free( plug );
358 		return( NULL );
359 	}
360 	if( !plug-&gt;pack-&gt;name || plug-&gt;pack-&gt;nfuncs &lt; 0 || 
361 		plug-&gt;pack-&gt;nfuncs &gt; 10000 ) {
362 		vips_error( "plugin",
363 			_( "corrupted package table in plugin \"%s\"" ), name );
364 		plugin_free( plug );
365 		return( NULL );
366 	}
367 #ifdef DEBUG
368 	printf( "added package \"%s\"\n", plug-&gt;pack-&gt;name );
369 	return( plug-&gt;pack );
370 }
371 int
372 im_load_plugins( const char *fmt, ... )
373 {
374         va_list ap;
375         char dir_name[VIPS_PATH_MAX];
376         GDir *dir;
377 	const char *name;
378         int result;
379 	if( !g_module_supported() )
380 		return( 0 );
381         va_start( ap, fmt );
382         (void) im_vsnprintf( dir_name, VIPS_PATH_MAX - 1, fmt, ap );
383         va_end( ap );
384 #ifdef DEBUG
385 	printf( "im_load_plugins: searching \"%s\"\n", dir_name );
386         if( !(dir = g_dir_open( dir_name, 0, NULL )) ) 
387                 return( 0 );
388         result = 0;
389         while( (name = g_dir_read_name( dir )) )
390                 if( im_ispostfix( name, ".plg" ) ) { 
391 			char path[VIPS_PATH_MAX];
392 			im_snprintf( path, VIPS_PATH_MAX - 1, 
393 				"%s" G_DIR_SEPARATOR_S "%s", dir_name, name );
394 			if( !im_load_plugin( path ) )
395 				result = -1;
396                 }
397         g_dir_close( dir );
398 	return( result );
399 }
400 int
401 im_close_plugins( void )
402 {
403 	while( plugin_list )
404 		if( plugin_free( (Plugin *) plugin_list-&gt;data ) )
405 			return( -1 );
406 	return( 0 );
407 }
408 static void *
409 apply_plugin( Plugin *plug, VSListMap2Fn fn, void *a )
410 {
411 	if( !plug-&gt;pack )
412 		return( NULL );
413 	else
414 		return( fn( plug-&gt;pack, a, NULL ) );
415 }
416 void *
417 im_map_packages( VSListMap2Fn fn, void *a )
418 {
419 	void *r = im_slist_map2( plugin_list, 
420 		(VSListMap2Fn) apply_plugin, (void *) fn, a );
421 	if( !r ) {
422 		int i;
423 		for( i = 0; i &lt; VIPS_NUMBER( built_in ); i++ )
424 			if( (r = fn( built_in[i], a, NULL )) )
425 				return( r );
426 	}
427 	return( r );
428 }
429 static im_function *
430 search_package( im_package *pack, const char *name )
431 {
432 	int i;
433 	for( i = 0; i &lt; pack-&gt;nfuncs; i++ ) 
434 		if( strcmp( pack-&gt;table[i]-&gt;name, name ) == 0 )
435 			return( pack-&gt;table[i] );
436 	return( NULL );
437 }
438 im_function *
439 im_find_function( const char *name )
440 {
441 	im_function *fn = im_map_packages( 
442 		(VSListMap2Fn) search_package, (void *) name );
443 	if( !fn ) {
444 		vips_error( "im_find_function", _( "\"%s\" not found" ), name );
445 		return( NULL );
446 	}
447 	return( fn );
448 }
449 static im_package *
450 package_name( im_package *pack, const char *name )
451 {
452 	if( strcmp( pack-&gt;name, name ) == 0 )
453 		return( pack );
454 	return( NULL );
455 }
456 im_package *
457 im_find_package( const char *name )
458 {
459 	im_package *pack = im_map_packages( 
460 		(VSListMap2Fn) package_name, (void *) name );
461 	if( !pack ) {
462 		vips_error( "im_find_package", _( "\"%s\" not found" ), name );
463 		return( NULL );
464 	}
465 	return( pack );
466 }
467 static im_package *
468 package_function( im_package *pack, const char *name )
469 {
470 	if( search_package( pack, name ) )
471 		return( pack );
472 	else
473 		return( NULL );
474 }
475 im_package *
476 im_package_of_function( const char *name )
477 {
478 	im_package *pack = im_map_packages( 
479 		(VSListMap2Fn) package_function, (void *) name );
480 	if( !pack ) {
481 		vips_error( "im_package_of_function",
482 			_( "\"%s\" not found" ), name );
483 		return( NULL );
484 	}
485 	return( pack );
486 }
487 int
488 im_free_vargv( im_function *fn, im_object *vargv )
489 {
490 	int i;
491 	int vargc = fn-&gt;argc;
492 	for( i = 0; i &lt; vargc; i++ )
493 		if( vargv[i] ) {
494 			if( fn-&gt;argv[i].desc-&gt;size != 0 )
495 				g_free( vargv[i] );
496 			vargv[i] = NULL;
497 		}
498 	return( 0 );
499 }
500 int
501 im_allocate_vargv( im_function *fn, im_object *vargv )
502 {
503 	int i;
504 	int vargc = fn-&gt;argc;
505 	for( i = 0; i &lt; vargc; i++ )
506 		vargv[i] = NULL;
507 	for( i = 0; i &lt; vargc; i++ ) {
508 		int sz = fn-&gt;argv[i].desc-&gt;size;
509 		if( sz != 0 )
510 			if( !(vargv[i] = vips_malloc( NULL, sz )) ) {
511 				(void) im_free_vargv( fn, vargv );
512 				return( -1 );
513 			}
514 		memset( vargv[i], 0, sz );
515 	}
516 	return( 0 );
517 }
518 static int
519 destroy_args( im_function *fn, im_object *vargv )
520 {
521 	int i;
522 	int vargc = fn-&gt;argc;
523 	for( i = 0; i &lt; vargc; i++ )
524 		if( vargv[i] ) 
525 			if( fn-&gt;argv[i].desc-&gt;dest &amp;&amp;
526 				fn-&gt;argv[i].desc-&gt;dest( vargv[i] ) )
527 				return( -1 );
528 	return( 0 );
529 }
530 static int
531 build_args( im_function *fn, im_object *vargv, int argc, char **argv )
532 {
533 	im_arg_desc *arg = fn-&gt;argv;
534 	int vargc = fn-&gt;argc;
535 	char *str;
536 	int i, j;
537 	for( i = 0, j = 0; i &lt; vargc; i++ ) {
538 		im_type_desc *type = arg[i].desc;
539 		if( type-&gt;flags &amp; IM_TYPE_ARG ) {
540 			if( !argv[j] ) {
541 				vips_error( "im_run_command",
542 					"%s", _( "too few arguments" ) );
543 				return( -1 );
544 			}
545 			str = argv[j++];
546 			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], str ) )
547 				return( -1 );
548 		}
549 		else {
550 			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], "no arg" ) )
551 				return( -1 );
552 		}
553 	}
554 	if( argv[j] ) {
555 		vips_error( "im_run_command", "%s", _( "too many arguments" ) );
556 		return( -1 );
557 	}
558 	return( 0 );
559 }
560 static int
561 region_local_image( IMAGE *main, IMAGE *sub )
562 {
563 	VipsRegion *reg;
564 	if( !(reg = vips_region_new( sub )) )
565 		return( -1 );
566 	vips_object_local( main, reg ); 
567         return( 0 );
568 }
569 static int
570 note_dependencies( im_function *fn, im_object *vargv, int i )
571 {
572 	int j;
573 	for( j = 0; j &lt; fn-&gt;argc; j++ ) {
574 		im_type_desc *type = fn-&gt;argv[j].desc;
575 		if( !(type-&gt;flags &amp; IM_TYPE_OUTPUT) ) {
576 			if( strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 ) {
577 				if( region_local_image( vargv[i], vargv[j] ) )
578 					return( -1 );
579 			}
580 			else if( strcmp( type-&gt;type, IM_TYPE_IMAGEVEC ) == 0 ) {
581 				im_imagevec_object *iv = vargv[j];
582 				int k;
583 				for( k = 0; k &lt; iv-&gt;n; k++ )
584 					if( region_local_image( vargv[i], 
585 						iv-&gt;vec[k] ) )
586 						return( -1 );
587 			}
588 		}
589 	}
590 	return( 0 );
591 }
592 static int
593 print_args( im_function *fn, im_object *vargv )
594 {
595 	int i;
596 	int vargc = fn-&gt;argc;
597 	for( i = 0; i &lt; vargc; i++ )
598 		if( fn-&gt;argv[i].print &amp;&amp; vargv[i] ) 
599 			if( fn-&gt;argv[i].print( vargv[i] ) )
600 				return( -1 );
601 	return( 0 );
602 }
603 static int
604 add_hist( im_function *fn, im_object *vargv, int argc, char **argv )
605 {
606 	int i;
607 	int vargc = fn-&gt;argc;
608 	for( i = 0; i &lt; vargc; i++ )
609 		if( strcmp( fn-&gt;argv[i].desc-&gt;type, IM_TYPE_IMAGE ) == 0 &amp;&amp;
610 			(fn-&gt;argv[i].desc-&gt;flags &amp; IM_TYPE_OUTPUT) )
611 			if( im_updatehist( vargv[i], fn-&gt;name, argc, argv ) )
612 				return( -1 );
613 	return( 0 );
614 }
615 static int
616 dispatch_function( im_function *fn, im_object *vargv, int argc, char **argv )
617 {
618 	if( build_args( fn, vargv, argc, argv ) ) 
619 		return( -1 );
620 	if( fn-&gt;flags &amp; IM_FN_PIO ) {
621 		int i;
622 		for( i = 0; i &lt; fn-&gt;argc; i++ ) {
623 			im_type_desc *type = fn-&gt;argv[i].desc;
624 			if( type-&gt;flags &amp; IM_TYPE_OUTPUT &amp;&amp;
625 				strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 )
626 				if( note_dependencies( fn, vargv, i ) )
627 					return( -1 );
628 		}
629 	}
630 	if( fn-&gt;disp( vargv ) ) 
631 		return( -1 );
632 	if( print_args( fn, vargv ) ) 
633 		return( -1 );
634 	if( add_hist( fn, vargv, argc, argv ) )
635 		return( -1 );
636 	return( 0 );
637 }
638 int
639 im_run_command( char *name, int argc, char **argv )
640 {
641 	static im_object object_array[IM_MAX_ARGS];
642 	im_object *vargv = object_array;
643 	im_function *fn;
644 	if( !(fn = im_find_function( name )) )
645 		return( -1 );
646 	if( im_allocate_vargv( fn, vargv ) ) 
647 		return( -1 );
648 	if( dispatch_function( fn, vargv, argc, argv ) ) {
649 		destroy_args( fn, vargv );
650 		im_free_vargv( fn, vargv );
651 		return( -1 );
652 	}
653 	if( destroy_args( fn, vargv ) ) 
654 		return( -1 );
655 	im_free_vargv( fn, vargv );
656 	return( 0 );
657 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
