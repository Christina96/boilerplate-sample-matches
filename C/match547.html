<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for format_dispatch.c &amp; package.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for format_dispatch.c &amp; package.c
      </h3>
<h1 align="center">
        38.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>format_dispatch.c (74.71265%)<th>package.c (26.31579%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(157-208)<td><a href="#" name="0">(333-384)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(125-154)<td><a href="#" name="1">(550-597)</a><td align="center"><font color="#a60000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(307-327)<td><a href="#" name="2">(106-133)</a><td align="center"><font color="#9c0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(399-419)<td><a href="#" name="3">(266-292)</a><td align="center"><font color="#930000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(351-372)<td><a href="#" name="4">(451-481)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(328-349)<td><a href="#" name="5">(422-448)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(261-287)<td><a href="#" name="6">(202-229)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(209-235)<td><a href="#" name="7">(142-169)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(74-95)<td><a href="#" name="8">(386-413)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(48-69)<td><a href="#" name="9">(297-324)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(102-121)<td><a href="#" name="10">(508-538)</a><td align="center"><font color="#7f0000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(377-395)<td><a href="#" name="11">(231-256)</a><td align="center"><font color="#750000">12</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(236-260)<td><a href="#" name="12">(171-196)</a><td align="center"><font color="#750000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>format_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* VIPS function dispatch tables for image format load/save.
 */

/*

    This file is part of VIPS.

    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;

static int
jpeg2vips_vec( im_object *argv )
{
	char *in = argv[0];
<a name="9"></a>	IMAGE *out = argv[1];

	if( im_jpeg2vips( in, out ) )
<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );

	return( 0 );
}

static im_arg_desc jpeg2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

static im_function jpeg2vips_desc = {
	"im_jpeg2vips",			/* Name */
	"convert from jpeg",		/* Description */
	0,				/* Flags */
	jpeg2vips_vec,			/* Dispatch function */
	IM_NUMBER( jpeg2vips_args ), 	/* Size of arg list */
	jpeg2vips_args 			/* Arg list */
};

static int
vips2dz_vec( im_object *argv )
{</b></font>
	IMAGE *in = argv[0];
<a name="8"></a>	char *out = argv[1];

	if( im_vips2dz( in, out ) )
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );

	return( 0 );
}

static im_arg_desc vips2dz_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_STRING( "out" )
};

static im_function vips2dz_desc = {
	"im_vips2dz",			/* Name */
	"save as deepzoom",		/* Description */
	0,				/* Flags */
	vips2dz_vec,			/* Dispatch function */
	IM_NUMBER( vips2dz_args ), 	/* Size of arg list */
	vips2dz_args 			/* Arg list */
};

static int
vips2jpeg_vec( im_object *argv )
{</b></font>
	IMAGE *in = argv[0];
	char *out = argv[1];

<a name="10"></a>	if( im_vips2jpeg( in, out ) )
		return( -1 );

<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}

static im_arg_desc vips2jpeg_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_STRING( "out" )
};

static im_function vips2jpeg_desc = {
	"im_vips2jpeg",			/* Name */
	"convert to jpeg",		/* Description */
	0,				/* Flags */
	vips2jpeg_vec,			/* Dispatch function */
	IM_NUMBER( vips2jpeg_args ), 	/* Size of arg list */
	vips2jpeg_args 			/* Arg list */
};

static int
vips2mimejpeg_vec( im_object *argv )
{</b></font>
<a name="1"></a>	IMAGE *in = argv[0];
	int qfac = *((int *) argv[1]);

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( im_vips2mimejpeg( in, qfac ) )
		return( -1 );

	return( 0 );
}

static im_arg_desc vips2mimejpeg_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_INT( "qfac" )
};

static im_function vips2mimejpeg_desc = {
	"im_vips2mimejpeg",		/* Name */
	"convert to jpeg as mime type on stdout", /* Description */
	0,				/* Flags */
	vips2mimejpeg_vec,		/* Dispatch function */
	IM_NUMBER( vips2mimejpeg_args ), /* Size of arg list */
	vips2mimejpeg_args 		/* Arg list */
};

/* Args for vips2png.
 */
static im_arg_desc vips2png_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_STRING( "out" )
};

/* Call im_vips2png via arg vector.
 */
<a name="0"></a>static int</b></font>
vips2png_vec( im_object *argv )
{
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_vips2png( argv[0], argv[1] ) );
}

/* Description of im_vips2png.
 */
static im_function vips2png_desc = {
	"im_vips2png", 			/* Name */
	"convert VIPS image to PNG file", /* Description */
	0,
	vips2png_vec, 			/* Dispatch function */
	IM_NUMBER( vips2png_args ), 	/* Size of arg list */
	vips2png_args 			/* Arg list */
};

/* Args for png2vips.
 */
static im_arg_desc png2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

/* Call im_png2vips via arg vector.
 */
static int
png2vips_vec( im_object *argv )
{
	return( im_png2vips( argv[0], argv[1] ) );
}

/* Description of im_png2vips.
 */
static im_function png2vips_desc = {
	"im_png2vips", 			/* Name */
	"convert PNG file to VIPS image", /* Description */
	0,
	png2vips_vec, 			/* Dispatch function */
	IM_NUMBER( png2vips_args ), 	/* Size of arg list */
	png2vips_args 			/* Arg list */
};

/* Args for exr2vips.
 */
static im_arg_desc exr2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

/* Call im_exr2vips via arg vector.
 */
<a name="7"></a>static int
exr2vips_vec( im_object *argv )
{</b></font>
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_exr2vips( argv[0], argv[1] ) );
}

/* Description of im_exr2vips.
 */
static im_function exr2vips_desc = {
	"im_exr2vips", 			/* Name */
	"convert an OpenEXR file to VIPS", /* Description */
	0,
	exr2vips_vec, 			/* Dispatch function */
	IM_NUMBER( exr2vips_args ), 	/* Size of arg list */
	exr2vips_args 			/* Arg list */
};

/* Args for vips2tiff.
 */
static im_arg_desc vips2tiff_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_STRING( "out" )
};

/* Call im_vips2tiff via arg vector.
 */
static int
<a name="12"></a>vips2tiff_vec( im_object *argv )
{
	return( im_vips2tiff( argv[0], argv[1] ) );</b></font>
<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

/* Description of im_vips2tiff.
 */
static im_function vips2tiff_desc = {
	"im_vips2tiff", 		/* Name */
	"convert VIPS image to TIFF file", /* Description */
	0,
	vips2tiff_vec, 			/* Dispatch function */
	IM_NUMBER( vips2tiff_args ), 	/* Size of arg list */
	vips2tiff_args 			/* Arg list */
};

/* Args for magick2vips.
 */
static im_arg_desc magick2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

/* Call im_magick2vips via arg vector.
 */
<a name="6"></a>static int
magick2vips_vec( im_object *argv )
{</b></font>
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_magick2vips( argv[0], argv[1] ) );
}

/* Description of im_magick2vips.
 */
static im_function magick2vips_desc = {
	"im_magick2vips", 		/* Name */
	"load file with libMagick", 	/* Description */
	0,
	magick2vips_vec, 		/* Dispatch function */
	IM_NUMBER( magick2vips_args ), 	/* Size of arg list */
	magick2vips_args 		/* Arg list */
};

/* Args for tiff2vips.
 */
static im_arg_desc tiff2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

/* Call im_tiff2vips via arg vector.
 */
static int
tiff2vips_vec( im_object *argv )
{
	return( im_tiff2vips( argv[0], argv[1] ) );</b></font>
}

/* Description of im_tiff2vips.
 */
static im_function tiff2vips_desc = {
	"im_tiff2vips", 		/* Name */
	"convert TIFF file to VIPS image", /* Description */
	0,
	tiff2vips_vec, 			/* Dispatch function */
	IM_NUMBER( tiff2vips_args ), 	/* Size of arg list */
	tiff2vips_args 			/* Arg list */
};

static int
analyze2vips_vec( im_object *argv )
{
<a name="2"></a>        const char *in = argv[0];
        IMAGE *out = argv[1];

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_analyze2vips( in, out ) );
}

static im_arg_desc analyze2vips_arg_types[] = {
        IM_INPUT_STRING( "filename" ),
        IM_OUTPUT_IMAGE( "im" )
};

static im_function analyze2vips_desc = {
        "im_analyze2vips",          	/* Name */
        "read a file in analyze format",/* Description */
        0,                             	/* Flags */
        analyze2vips_vec,               /* Dispatch function */
        IM_NUMBER( analyze2vips_arg_types ),/* Size of arg list */
        analyze2vips_arg_types          /* Arg list */
};

static int
<a name="5"></a>csv2vips_vec( im_object *argv )
{
        const char *in = argv[0];</b></font>
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        IMAGE *out = argv[1];

        return( im_csv2vips( in, out ) );
}

static im_arg_desc csv2vips_arg_types[] = {
        IM_INPUT_STRING( "filename" ),
        IM_OUTPUT_IMAGE( "im" )
};

static im_function csv2vips_desc = {
        "im_csv2vips",          	/* Name */
        "read a file in csv format",/* Description */
        0,                             	/* Flags */
        csv2vips_vec,               /* Dispatch function */
        IM_NUMBER( csv2vips_arg_types ),/* Size of arg list */
        csv2vips_arg_types          /* Arg list */
};

static int
<a name="4"></a>vips2csv_vec( im_object *argv )
{</b></font>
        IMAGE *in = argv[0];
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        const char *filename = argv[1];

        return( im_vips2csv( in, filename ) );
}

static im_arg_desc vips2csv_arg_types[] = {
        IM_INPUT_IMAGE( "in" ),
        IM_INPUT_STRING( "filename" )
};

static im_function vips2csv_desc = {
        "im_vips2csv",          	/* Name */
        "write an image in csv format",	/* Description */
        0,                          	/* Flags */
        vips2csv_vec,               	/* Dispatch function */
        IM_NUMBER( vips2csv_arg_types ),/* Size of arg list */
        vips2csv_arg_types          	/* Arg list */
};

static int
ppm2vips_vec( im_object *argv )
{</b></font>
        const char *in = argv[0];
<a name="11"></a>        IMAGE *out = argv[1];

        return( im_ppm2vips( in, out ) );
<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static im_arg_desc ppm2vips_arg_types[] = {
        IM_INPUT_STRING( "filename" ),
        IM_OUTPUT_IMAGE( "im" )
};

static im_function ppm2vips_desc = {
        "im_ppm2vips",                  /* Name */
        "read a file in pbm/pgm/ppm format",     /* Description */
        0,                              /* Flags */
        ppm2vips_vec,                  	/* Dispatch function */
        IM_NUMBER( ppm2vips_arg_types ),/* Size of arg list */
        ppm2vips_arg_types              /* Arg list */
};

static int
vips2ppm_vec( im_object *argv )
{</b></font>
<a name="3"></a>        IMAGE *im = argv[0];
        const char *filename = argv[1];

<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        return( im_vips2ppm( im, filename ) );
}

static im_arg_desc vips2ppm_arg_types[] = {
        IM_INPUT_IMAGE( "im" ),
        IM_INPUT_STRING( "filename" )
};

static im_function vips2ppm_desc = {
        "im_vips2ppm",                  /* Name */
        "write a file in pbm/pgm/ppm format",     /* Description */
        0,                              /* Flags */
        vips2ppm_vec,                  	/* Dispatch function */
        IM_NUMBER( vips2ppm_arg_types ),/* Size of arg list */
        vips2ppm_arg_types              /* Arg list */
};

static int
fits2vips_vec( im_object *argv )
{
	char *in = argv[0];</b></font>
	IMAGE *out = argv[1];

	if( im_fits2vips( in, out ) )
		return( -1 );

	return( 0 );
}

static im_arg_desc fits2vips_args[] = {
	IM_INPUT_STRING( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};

static im_function fits2vips_desc = {
	"im_fits2vips",			/* Name */
	"convert from fits",		/* Description */
	0,				/* Flags */
	fits2vips_vec,			/* Dispatch function */
	IM_NUMBER( fits2vips_args ), 	/* Size of arg list */
	fits2vips_args 			/* Arg list */
};

/* Package up all these functions.
 */
static im_function *list[] = {
	&amp;csv2vips_desc,
	&amp;fits2vips_desc,
	&amp;jpeg2vips_desc,
	&amp;magick2vips_desc,
	&amp;png2vips_desc,
	&amp;exr2vips_desc,
	&amp;ppm2vips_desc,
	&amp;analyze2vips_desc,
	&amp;tiff2vips_desc,
	&amp;vips2csv_desc,
	&amp;vips2dz_desc,
	&amp;vips2jpeg_desc,
	&amp;vips2mimejpeg_desc,
	&amp;vips2png_desc,
	&amp;vips2ppm_desc,
	&amp;vips2tiff_desc
};

/* Package of functions.
 */
im_package im__format = {
	"format",
	IM_NUMBER( list ),
	list
};
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>package.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* VIPS package handling.
 *
 * J. Cupitt, 8/4/93.
 *
 * 18/2/04 JC
 *	- now uses g_module_*() instead of dlopen()
 * 9/8/04
 *	- uses glib dir scanning stuff instead of dirent.h
 * 20/5/08
 * 	- note_dependencies() does IMAGEVEC as well as IMAGE
 * 5/8/08
 * 	- silent success in loading plugins if the dir isn't there
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef HAVE_SYS_PARAM_H
#include &lt;sys/param.h&gt;
#endif /*HAVE_SYS_PARAM_H*/
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

/* Standard VIPS packages.
 */
extern im_package im__arithmetic;
extern im_package im__cimg;
extern im_package im__colour;
extern im_package im__conversion;
extern im_package im__convolution;
extern im_package im__deprecated;
extern im_package im__format;
extern im_package im__freq_filt;
extern im_package im__histograms_lut;
extern im_package im__inplace;
extern im_package im__mask;
extern im_package im__morphology;
extern im_package im__mosaicing;
extern im_package im__other;
extern im_package im__resample;
extern im_package im__video;

/* im_guess_prefix() args.
 */
static im_arg_desc guess_prefix_args[] = {
	IM_INPUT_STRING( "argv0" ),
	IM_INPUT_STRING( "env_name" ),
	IM_OUTPUT_STRING( "PREFIX" )
};

/* Call im_guess_prefix() via arg vector.
 */
static int
guess_prefix_vec( im_object *argv )
{
	const char *prefix = vips_guess_prefix( argv[0], argv[1] );

	if( !prefix ) {
		argv[2] = NULL;
		return( -1 );
	}
<a name="2"></a>
	argv[2] = im_strdup( NULL, prefix );

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Description of im_guess_prefix.
 */ 
static im_function guess_prefix_desc = {
	"im_guess_prefix", 		/* Name */
	"guess install area",		/* Description */
	0,				/* Flags */
	guess_prefix_vec, 		/* Dispatch function */
	VIPS_NUMBER( guess_prefix_args ), /* Size of arg list */
	guess_prefix_args 		/* Arg list */
};

/* im_guess_libdir() args.
 */
static im_arg_desc guess_libdir_args[] = {
	IM_INPUT_STRING( "argv0" ),
	IM_INPUT_STRING( "env_name" ),
	IM_OUTPUT_STRING( "LIBDIR" )
};

/* Call im_guess_libdir() via arg vector.
 */
static int
guess_libdir_vec( im_object *argv )
{
	const char *libdir = vips_guess_libdir( argv[0], argv[1] );</b></font>

	if( !libdir ) {
		argv[2] = NULL;
		return( -1 );
	}
<a name="7"></a>
	argv[2] = im_strdup( NULL, libdir );

<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Description of im_guess_libdir.
 */ 
static im_function guess_libdir_desc = {
	"im_guess_libdir", 		/* Name */
	"guess library area",		/* Description */
	0,				/* Flags */
	guess_libdir_vec, 		/* Dispatch function */
	VIPS_NUMBER( guess_libdir_args ),/* Size of arg list */
	guess_libdir_args 		/* Arg list */
};

/* im_header_int() args.
 */
static im_arg_desc header_int_args[] = {
	IM_INPUT_STRING( "field" ),
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_INT( "value" )
};

/* Call im_header_int() via arg vector.
 */
static int
header_int_vec( im_object *argv )
<a name="12"></a>{
	return( im_header_int( (IMAGE *) argv[1], (const char *) argv[0], </b></font>
		(int *) argv[2] ) );
<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

/* Description of im_header_int().
 */ 
static im_function header_int_desc = {
	"im_header_int", 		/* Name */
	"extract int fields from header",	/* Description */
	0,				/* Flags */
	header_int_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_int_args ),	/* Size of arg list */
	header_int_args 		/* Arg list */
};

/* im_header_get_typeof() args.
 */
static im_arg_desc header_get_typeof_args[] = {
	IM_INPUT_STRING( "field" ),
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_INT( "gtype" )
};

/* Call im_header_get_typeof() via arg vector.
 */
static int
header_get_typeof_vec( im_object *argv )
{</b></font>
	int *out = (int *) argv[2];

<a name="6"></a>	*out = im_header_get_typeof( (IMAGE *) argv[1], 
		(const char *) argv[0] ); 

<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Description of im_header_get_typeof().
 */ 
static im_function header_get_typeof_desc = {
	"im_header_get_typeof",		/* Name */
	"return field type",		/* Description */
	0,				/* Flags */
	header_get_typeof_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_get_typeof_args ),/* Size of arg list */
	header_get_typeof_args 		/* Arg list */
};

/* im_header_double() args.
 */
static im_arg_desc header_double_args[] = {
	IM_INPUT_STRING( "field" ),
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_DOUBLE( "value" )
};

/* Call im_header_double() via arg vector.
 */
static int
header_double_vec( im_object *argv )
<a name="11"></a>{
	return( im_header_double( (IMAGE *) argv[1], (const char *) argv[0], </b></font>
		(double *) argv[2] ) );
<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

/* Description of im_header_double().
 */ 
static im_function header_double_desc = {
	"im_header_double", 		/* Name */
	"extract double fields from header",	/* Description */
	0,				/* Flags */
	header_double_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_double_args ), /* Size of arg list */
	header_double_args 		/* Arg list */
};

/* im_header_string() args.
 */
static im_arg_desc header_string_args[] = {
	IM_INPUT_STRING( "field" ),
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_STRING( "value" )
};

/* Call im_header_string() via arg vector.
 */
static int
header_string_vec( im_object *argv )
{</b></font>
	char **out = (char **) &amp;argv[2];

	/* Actually, we call im_header_as_string(), so we can do any field and
	 * not just the string-valued ones.
	 */
	if( im_header_as_string( (IMAGE *) argv[1], 
<a name="3"></a>		(const char *) argv[0], out ) )
		return( -1 );

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Description of im_header_string().
 */ 
static im_function header_string_desc = {
	"im_header_string", 		/* Name */
	"extract fields from headers as strings",	/* Description */
	0,				/* Flags */
	header_string_vec, 		/* Dispatch function */
	VIPS_NUMBER( header_string_args ),/* Size of arg list */
	header_string_args 		/* Arg list */
};

/* im_history_get() args.
 */
static im_arg_desc history_get_args[] = {
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_STRING( "history" )
};

/* Call im_history_get() via arg vector.
 */
static int
history_get_vec( im_object *argv )
{
	char **out = (char **) &amp;argv[1];</b></font>
	const char *str;
<a name="9"></a>
	if( !(str = im_history_get( (IMAGE *) argv[0] )) ||
		!(*out = im_strdup( NULL, str )) )
<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );

	return( 0 );
}

/* Description of im_history_get().
 */ 
static im_function history_get_desc = {
	"im_history_get", 		/* Name */
	"return the image history as a string",	/* Description */
	0,				/* Flags */
	history_get_vec, 		/* Dispatch function */
	VIPS_NUMBER( history_get_args ),/* Size of arg list */
	history_get_args 		/* Arg list */
};

/* im_getext() args.
 */
static im_arg_desc getext_args[] = {
	IM_INPUT_IMAGE( "image" ),
	IM_OUTPUT_STRING( "history" )
};

/* Call im_getext() via arg vector.
 */
static int
getext_vec( im_object *argv )
{</b></font>
	void **out = (void **) &amp;argv[1];
	int size;

	/* void/char confusion is fine.
	 */
<a name="0"></a>	if( !(*out = im__read_extension_block( (IMAGE *) argv[0], &amp;size )) )
		return( -1 );

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Description of im_getext().
 */ 
static im_function getext_desc = {
	"im_getext", 			/* Name */
	"return the image metadata XML as a string",	/* Description */
	0,				/* Flags */
	getext_vec, 			/* Dispatch function */
	VIPS_NUMBER( getext_args ), 	/* Size of arg list */
	getext_args 			/* Arg list */
};

/* im_printdesc() args.
 */
static im_arg_desc printdesc_args[] = {
	IM_INPUT_IMAGE( "image" ),
};

/* Call im_printdesc() via arg vector.
 */
static int
printdesc_vec( im_object *argv )
{
	vips_object_print_dump( VIPS_OBJECT( argv[0] ) );

	return( 0 );
}

/* Description of im_printdesc().
 */ 
static im_function printdesc_desc = {
	"im_printdesc", 		/* Name */
	"print an image header to stdout",	/* Description */
	0,				/* Flags */
	printdesc_vec, 			/* Dispatch function */
	VIPS_NUMBER( printdesc_args ), 	/* Size of arg list */
	printdesc_args 			/* Arg list */
};

/* im_version_string() args.
 */
static im_arg_desc version_string_args[] = {
	IM_OUTPUT_STRING( "version" )
};

/* Call im_version_string() via arg vector.
 */
static int
<a name="8"></a>version_string_vec( im_object *argv )
{</b></font>
	if( !(argv[0] = im_strdup( NULL, vips_version_string() )) )
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );

	return( 0 );
}

/* Description of im_version_string.
 */ 
static im_function version_string_desc = {
	"im_version_string", 		/* Name */
	"VIPS version string",		/* Description */
	0,				/* Flags */
	version_string_vec, 		/* Dispatch function */
	VIPS_NUMBER( version_string_args ),/* Size of arg list */
	version_string_args 		/* Arg list */
};

/* im_version() args.
 */
static im_arg_desc version_args[] = {
	IM_INPUT_INT( "flag" ),
	IM_OUTPUT_INT( "version" )
};

/* Call im_version() via arg vector.
 */
static int
version_vec( im_object *argv )
{</b></font>
	int flag = *((int *) argv[0]);
	int *out = ((int *) argv[1]);

	int version = vips_version( flag );

<a name="5"></a>	if( version &lt; 0 )
		return( -1 );

<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	*out = version;

	return( 0 );
}

/* Description of im_version.
 */ 
static im_function version_desc = {
	"im_version", 			/* Name */
	"VIPS version number",		/* Description */
	0,				/* Flags */
	version_vec, 			/* Dispatch function */
	VIPS_NUMBER( version_args ), 	/* Size of arg list */
	version_args 			/* Arg list */
};

/* im_concurrency_get() args.
 */
static im_arg_desc concurrency_get_args[] = {
	IM_OUTPUT_INT( "concurrency" )
};

/* Call im_concurrency_get() via arg vector.
 */
static int
concurrency_get_vec( im_object *argv )
<a name="4"></a>{</b></font>
	int *out = ((int *) argv[0]);

<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	*out = vips_concurrency_get();

	return( 0 );
}

/* Description of im_concurrency_get.
 */ 
static im_function concurrency_get_desc = {
	"im_concurrency_get", 			/* Name */
	"get concurrency level",		/* Description */
	0,					/* Flags */
	concurrency_get_vec, 			/* Dispatch function */
	VIPS_NUMBER( concurrency_get_args ), 	/* Size of arg list */
	concurrency_get_args 			/* Arg list */
};

/* im_cache() args.
 */
static im_arg_desc cache_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "tile_width" ),
	IM_INPUT_INT( "tile_height" ),
	IM_INPUT_INT( "max_tiles" )
};

/* Call im_cache() via arg vector.
 */
static int
cache_vec( im_object *argv )
{</b></font>
	int tile_width = *((int *) argv[2]);
	int tile_height = *((int *) argv[3]);
	int max_tiles = *((int *) argv[4]);

	return( im_cache( argv[0], argv[1], 
		tile_width, tile_height, max_tiles ) );
}

/* Description of im_cache.
 */ 
static im_function cache_desc = {
	"im_cache", 			/* Name */
	"cache results of an operation",/* Description */
	0,				/* Flags */
	cache_vec, 			/* Dispatch function */
	VIPS_NUMBER( cache_args ), 	/* Size of arg list */
	cache_args 			/* Arg list */
};

static int
tile_cache_random_vec( im_object *argv )
{
	int tile_width = *((int *) argv[2]);
<a name="10"></a>	int tile_height = *((int *) argv[3]);
	int max_tiles = *((int *) argv[4]);

<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_tile_cache_random( argv[0], argv[1], 
		tile_width, tile_height, max_tiles ) );
}

/* Description of im_cache.
 */ 
static im_function tile_cache_random_desc = {
	"im_tile_cache_random",		/* Name */
	"cache results of an operation",/* Description */
	0,				/* Flags */
	tile_cache_random_vec, 		/* Dispatch function */
	VIPS_NUMBER( cache_args ), 	/* Size of arg list */
	cache_args 			/* Arg list */
};

/* im_binfile() args.
 */
static im_arg_desc binfile_args[] = {
	IM_INPUT_STRING( "filename" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "height" ),
	IM_INPUT_INT( "bands" ),
	IM_INPUT_INT( "offset" )
};

/* Call im_binfile() via arg vector.
 */
static int
binfile_vec( im_object *argv )
{</b></font>
	int width = *((int *) argv[2]);
	int height = *((int *) argv[3]);
	int bands = *((int *) argv[4]);
	int offset = *((int *) argv[5]);
	VipsImage *im;

	if( !(im = vips_image_new_from_file_raw( argv[0], 
		width, height, bands, offset )) )
<a name="1"></a>		return( -1 );
	vips_object_local( argv[1], im );

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_copy( im, argv[1] ) )
		return( -1 );

	return( 0 );
}

/* Description of im_binfile.
 */ 
static im_function binfile_desc = {
	"im_binfile", 			/* Name */
	"open a headerless binary file",/* Description */
	0,				/* Flags */
	binfile_vec, 			/* Dispatch function */
	VIPS_NUMBER( binfile_args ), 	/* Size of arg list */
	binfile_args 			/* Arg list */
};

/* Package up iofuncs functions.
 */
static im_function *iofuncs_list[] = {
	&amp;binfile_desc,
	&amp;cache_desc,
	&amp;tile_cache_random_desc,
	&amp;concurrency_get_desc,
	&amp;getext_desc,
	&amp;guess_prefix_desc,
	&amp;guess_libdir_desc,
	&amp;header_get_typeof_desc,
	&amp;header_int_desc,
	&amp;header_double_desc,
	&amp;header_string_desc,
	&amp;history_get_desc,
	&amp;printdesc_desc,
	&amp;version_desc,
	&amp;version_string_desc
};

/* Package of io functions.
 */
static im_package im__iofuncs = {
	"iofuncs",
	VIPS_NUMBER( iofuncs_list ),
	iofuncs_list
};

/* List of built-in VIPS packages.
 */
static im_package *built_in[] = {</b></font>
	&amp;im__arithmetic,
	&amp;im__cimg,
	&amp;im__colour,
	&amp;im__conversion,
	&amp;im__convolution,
	&amp;im__deprecated,
	&amp;im__format,
	&amp;im__freq_filt,
	&amp;im__histograms_lut,
	&amp;im__inplace,
	&amp;im__iofuncs,
	&amp;im__mask,
	&amp;im__morphology,
	&amp;im__mosaicing,
	&amp;im__other,
	&amp;im__resample,
	&amp;im__video
};
/* How we represent a loaded plugin.
 */
typedef struct _Plugin {
	GModule *module;		/* As loaded by g_module_open() */
	char *name;			/* Name we loaded */
	im_package *pack;		/* Package table */
} Plugin;

/* List of loaded plugins.
 */
static GSList *plugin_list = NULL;

/* Free a plugin.
 */
static int
plugin_free( Plugin *plug )
{
	char *name = plug-&gt;name ? plug-&gt;name : "&lt;unknown&gt;";

	if( plug-&gt;module ) {
		if( !g_module_close( plug-&gt;module ) ) {
			vips_error( "plugin", 
				_( "unable to close plugin \"%s\"" ), name );
			vips_error( "plugin", "%s", g_module_error() );
			return( -1 );
		}

		plug-&gt;module = NULL;
	}
	VIPS_FREE( plug-&gt;name );
	plug-&gt;pack = NULL;
	g_free( plug );

	plugin_list = g_slist_remove( plugin_list, plug );

	return( 0 );
}

/* Load a plugin.
 */
im_package *
im_load_plugin( const char *name )
{
	Plugin *plug;

#ifdef DEBUG
	printf( "im_load_plugin: \"%s\"\n", name );
#endif /*DEBUG*/

	if( !g_module_supported() ) {
		vips_error( "plugin",	
			"%s", _( "plugins not supported on this platform" ) );
		return( NULL );
	}

	/* Build a new plugin.
	 */
	plug = VIPS_NEW( NULL, Plugin );
	plug-&gt;module = NULL;
	plug-&gt;name = g_strdup( name );
	plug-&gt;pack = NULL;
	plugin_list = g_slist_prepend( plugin_list, plug );

	/* Open library.
	 */
	if( !(plug-&gt;module = g_module_open( name, 0 )) ) {
		vips_error( "plugin", 
			_( "unable to open plugin \"%s\"" ), name );
		vips_error( "plugin", "%s", g_module_error() );
		plugin_free( plug );

		return( NULL );
	}

	/* Find package.
	 */
	/* Bizarre double-cast stops a bogus gcc 4.1 compiler warning.
	 */
	if( !g_module_symbol( plug-&gt;module, 
		"package_table", (gpointer *) ((void *) &amp;plug-&gt;pack) ) ) {
		vips_error( "plugin",
			_( "unable to find symbol \"package_table\" "
				"in plugin \"%s\"" ), name );
		vips_error( "plugin", "%s", g_module_error() );
		plugin_free( plug );

		return( NULL );
	}

	/* Sanity check.
	 */
	if( !plug-&gt;pack-&gt;name || plug-&gt;pack-&gt;nfuncs &lt; 0 || 
		plug-&gt;pack-&gt;nfuncs &gt; 10000 ) {
		vips_error( "plugin",
			_( "corrupted package table in plugin \"%s\"" ), name );
		plugin_free( plug );

		return( NULL );
	}

#ifdef DEBUG
	printf( "added package \"%s\"\n", plug-&gt;pack-&gt;name );
#endif /*DEBUG*/

	return( plug-&gt;pack );
}

/* Load all plugins in a directory ... look for '.plg' suffix. Error if we had
 * any probs.
 */
int
im_load_plugins( const char *fmt, ... )
{
        va_list ap;
        char dir_name[VIPS_PATH_MAX];
        GDir *dir;
	const char *name;
        int result;

	/* Silently succeed if we can't do modules.
	 */
	if( !g_module_supported() )
		return( 0 );

        va_start( ap, fmt );
        (void) im_vsnprintf( dir_name, VIPS_PATH_MAX - 1, fmt, ap );
        va_end( ap );

#ifdef DEBUG
	printf( "im_load_plugins: searching \"%s\"\n", dir_name );
#endif /*DEBUG*/

        if( !(dir = g_dir_open( dir_name, 0, NULL )) ) 
		/* Silent success for dir not there.
		 */
                return( 0 );

        result = 0;
        while( (name = g_dir_read_name( dir )) )
                if( im_ispostfix( name, ".plg" ) ) { 
			char path[VIPS_PATH_MAX];

			im_snprintf( path, VIPS_PATH_MAX - 1, 
				"%s" G_DIR_SEPARATOR_S "%s", dir_name, name );
			if( !im_load_plugin( path ) )
				result = -1;
                }
        g_dir_close( dir );

	return( result );
}

/* Close all loaded plugins.
 */
int
im_close_plugins( void )
{
	while( plugin_list )
		if( plugin_free( (Plugin *) plugin_list-&gt;data ) )
			return( -1 );

	return( 0 );
}

/* Apply a user-function to a plugin package.
 */
static void *
apply_plugin( Plugin *plug, VSListMap2Fn fn, void *a )
{
	if( !plug-&gt;pack )
		return( NULL );
	else
		return( fn( plug-&gt;pack, a, NULL ) );
}

/* Map a function over all packages. Map over plugins first, to allow
 * overriding of VIPS functions.
 */
void *
im_map_packages( VSListMap2Fn fn, void *a )
{
	void *r = im_slist_map2( plugin_list, 
		(VSListMap2Fn) apply_plugin, (void *) fn, a );

	/* If not there, try main VIPS package list.
	 */
	if( !r ) {
		int i;

		for( i = 0; i &lt; VIPS_NUMBER( built_in ); i++ )
			if( (r = fn( built_in[i], a, NULL )) )
				return( r );
	}

	return( r );
}

/* Search a package for a function.
 */
static im_function *
search_package( im_package *pack, const char *name )
{
	int i;

	for( i = 0; i &lt; pack-&gt;nfuncs; i++ ) 
		if( strcmp( pack-&gt;table[i]-&gt;name, name ) == 0 )
			return( pack-&gt;table[i] );

	return( NULL );
}

/* Search all packages for a function.
 */
im_function *
im_find_function( const char *name )
{
	im_function *fn = im_map_packages( 
		(VSListMap2Fn) search_package, (void *) name );

	if( !fn ) {
		vips_error( "im_find_function", _( "\"%s\" not found" ), name );
		return( NULL );
	}

	return( fn );
}

/* Test for package is of name.
 */
static im_package *
package_name( im_package *pack, const char *name )
{
	if( strcmp( pack-&gt;name, name ) == 0 )
		return( pack );

	return( NULL );
}

/* Find a package.
 */
im_package *
im_find_package( const char *name )
{
	im_package *pack = im_map_packages( 
		(VSListMap2Fn) package_name, (void *) name );

	if( !pack ) {
		vips_error( "im_find_package", _( "\"%s\" not found" ), name );
		return( NULL );
	}

	return( pack );
}

/* Test for package contains a function.
 */
static im_package *
package_function( im_package *pack, const char *name )
{
	if( search_package( pack, name ) )
		return( pack );
	else
		return( NULL );
}

/* Find a function's package by name.
 */
im_package *
im_package_of_function( const char *name )
{
	im_package *pack = im_map_packages( 
		(VSListMap2Fn) package_function, (void *) name );

	if( !pack ) {
		vips_error( "im_package_of_function",
			_( "\"%s\" not found" ), name );
		return( NULL );
	}

	return( pack );
}

/* Free any store we allocated for the argument list.
 */
int
im_free_vargv( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Free all elements.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( vargv[i] ) {
			/* If there is local storage, free it.
			 */
			if( fn-&gt;argv[i].desc-&gt;size != 0 )
				g_free( vargv[i] );

			/* NULL out pointer.
			 */
			vargv[i] = NULL;
		}

	return( 0 );
}

/* Allocate any local store the args will need; NULL out all others.
 */
int
im_allocate_vargv( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* NULL out all pointers.
	 */
	for( i = 0; i &lt; vargc; i++ )
		vargv[i] = NULL;

	/* Allocate any space we will need.
	 */
	for( i = 0; i &lt; vargc; i++ ) {
		int sz = fn-&gt;argv[i].desc-&gt;size;

		if( sz != 0 )
			if( !(vargv[i] = vips_malloc( NULL, sz )) ) {
				/* Free anything we did allocate.
				 */
				(void) im_free_vargv( fn, vargv );
				return( -1 );
			}

		/* Zero memory.
		 */
		memset( vargv[i], 0, sz );
	}

	return( 0 );
}

/* Destroy the objects in the arg list.
 */
static int
destroy_args( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Destroy all elements with destroy functions.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( vargv[i] ) 
			/* If there's a destroy function for this type,
			 * trigger it.
			 */
			if( fn-&gt;argv[i].desc-&gt;dest &amp;&amp;
				fn-&gt;argv[i].desc-&gt;dest( vargv[i] ) )
				return( -1 );

	return( 0 );
}

/* Init an im_object array from a set of command-line arguments.
 */
static int
build_args( im_function *fn, im_object *vargv, int argc, char **argv )
{
	im_arg_desc *arg = fn-&gt;argv;
	int vargc = fn-&gt;argc;
	char *str;
	int i, j;

	/* Loop, constructing each im_arg.
	 */
	for( i = 0, j = 0; i &lt; vargc; i++ ) {
		/* Find type for this arg.
		 */
		im_type_desc *type = arg[i].desc;

		/* Do we need to use up a command line argument?
		 */
		if( type-&gt;flags &amp; IM_TYPE_ARG ) {
			if( !argv[j] ) {
				vips_error( "im_run_command",
					"%s", _( "too few arguments" ) );
				return( -1 );
			}
			str = argv[j++];

			/* Init object.
			 */
			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], str ) )
				return( -1 );
		}
		else {
			/* Init object with no arg.
			 */
			if( type-&gt;init &amp;&amp; type-&gt;init( &amp;vargv[i], "no arg" ) )
				return( -1 );
		}
	}

	/* Have we used up all the command-line args?
	 */
	if( argv[j] ) {
		vips_error( "im_run_command", "%s", _( "too many arguments" ) );
		return( -1 );
	}

	return( 0 );
}

/* Make a region on sub, closed by callback on main.
 */
static int
region_local_image( IMAGE *main, IMAGE *sub )
{
	VipsRegion *reg;

	if( !(reg = vips_region_new( sub )) )
		return( -1 );
	vips_object_local( main, reg ); 
 
        return( 0 );
}

/* vargv[i] is an output image on a PIO function ... make all input images 
 * depend on it.
 */
static int
note_dependencies( im_function *fn, im_object *vargv, int i )
{
	int j;

	for( j = 0; j &lt; fn-&gt;argc; j++ ) {
		im_type_desc *type = fn-&gt;argv[j].desc;

		if( !(type-&gt;flags &amp; IM_TYPE_OUTPUT) ) {
			if( strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 ) {
				if( region_local_image( vargv[i], vargv[j] ) )
					return( -1 );
			}
			else if( strcmp( type-&gt;type, IM_TYPE_IMAGEVEC ) == 0 ) {
				im_imagevec_object *iv = vargv[j];
				int k;

				for( k = 0; k &lt; iv-&gt;n; k++ )
					if( region_local_image( vargv[i], 
						iv-&gt;vec[k] ) )
						return( -1 );
			}
		}
	}

	return( 0 );
}

/* Call all defined print functions.
 */
static int
print_args( im_function *fn, im_object *vargv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Print all elements.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( fn-&gt;argv[i].print &amp;&amp; vargv[i] ) 
			if( fn-&gt;argv[i].print( vargv[i] ) )
				return( -1 );

	return( 0 );
}

/* Add to the hist of all output images.
 */
static int
add_hist( im_function *fn, im_object *vargv, int argc, char **argv )
{
	int i;
	int vargc = fn-&gt;argc;

	/* Search for output images.
	 */
	for( i = 0; i &lt; vargc; i++ )
		if( strcmp( fn-&gt;argv[i].desc-&gt;type, IM_TYPE_IMAGE ) == 0 &amp;&amp;
			(fn-&gt;argv[i].desc-&gt;flags &amp; IM_TYPE_OUTPUT) )
			if( im_updatehist( vargv[i], fn-&gt;name, argc, argv ) )
				return( -1 );

	return( 0 );
}

/* Call a VIPS function.
 */
static int
dispatch_function( im_function *fn, im_object *vargv, int argc, char **argv )
{
	/* Init memory from command line arguments.
	 */
	if( build_args( fn, vargv, argc, argv ) ) 
		return( -1 );

	/* If this is a PIO function, we need to make sure that we close
	 * the input images after the output images, since the output image
	 * may include delayed image conversion filters which will not run
	 * until the output is closed.
	 *
	 * Do this by:
	 *	- for each output image
	 *		- for each input image
	 *			- create a region on the input, closed by a
	 *			  close callback on the output image
	 */
	if( fn-&gt;flags &amp; IM_FN_PIO ) {
		int i;

		for( i = 0; i &lt; fn-&gt;argc; i++ ) {
			im_type_desc *type = fn-&gt;argv[i].desc;

			if( type-&gt;flags &amp; IM_TYPE_OUTPUT &amp;&amp;
				strcmp( type-&gt;type, IM_TYPE_IMAGE ) == 0 )
				if( note_dependencies( fn, vargv, i ) )
					return( -1 );
		}
	}

	/* Call function.
	 */
	if( fn-&gt;disp( vargv ) ) 
		return( -1 );

	/* Print output.
	 */
	if( print_args( fn, vargv ) ) 
		return( -1 );

	/* Add to history of all output images.
	 */
	if( add_hist( fn, vargv, argc, argv ) )
		return( -1 );

	/* All ok!
	 */
	return( 0 );
}

/* Run a command.
 */
int
im_run_command( char *name, int argc, char **argv )
{
	static im_object object_array[IM_MAX_ARGS];
	im_object *vargv = object_array;
	im_function *fn;

	/* Search packages for a matching function.
	 */
	if( !(fn = im_find_function( name )) )
		return( -1 );

	/* Allocate space for arguments.
	 */
	if( im_allocate_vargv( fn, vargv ) ) 
		return( -1 );

	/* Call it.
	 */ 
	if( dispatch_function( fn, vargv, argc, argv ) ) {
		destroy_args( fn, vargv );
		im_free_vargv( fn, vargv );
		return( -1 );
	}

	/* Clean up and exit.
	 */
	if( destroy_args( fn, vargv ) ) 
		return( -1 );
	im_free_vargv( fn, vargv );

	return( 0 );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
