
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_SC_H
2  #define JEMALLOC_INTERNAL_SC_H
3  #include "jemalloc/internal/jemalloc_internal_types.h"
4  #define SC_LG_NGROUP 2
5  #define SC_LG_TINY_MIN 3
6  #if SC_LG_TINY_MIN == 0
7  #error "Unsupported LG_TINY_MIN"
8  #endif
9  #define SC_NGROUP (1ULL << SC_LG_NGROUP)
10  #define SC_PTR_BITS ((1ULL << LG_SIZEOF_PTR) * 8)
11  #define SC_NTINY (LG_QUANTUM - SC_LG_TINY_MIN)
12  #define SC_LG_TINY_MAXCLASS (LG_QUANTUM > SC_LG_TINY_MIN ? LG_QUANTUM - 1 : -1)
13  #define SC_NPSEUDO SC_NGROUP
14  #define SC_LG_FIRST_REGULAR_BASE (LG_QUANTUM + SC_LG_NGROUP)
15  #define SC_LG_BASE_MAX (SC_PTR_BITS - 2)
16  #define SC_NREGULAR (SC_NGROUP * 					\
17      (SC_LG_BASE_MAX - SC_LG_FIRST_REGULAR_BASE + 1) - 1)
18  #define SC_NSIZES (SC_NTINY + SC_NPSEUDO + SC_NREGULAR)
19  #define SC_NPSIZES (							\
20      				\
21      SC_NSIZES								\
22      		\
23      - (LG_PAGE - 1 - SC_LG_FIRST_REGULAR_BASE) * SC_NGROUP		\
24      						\
25      - SC_NPSEUDO							\
26      						\
27      - SC_NTINY								\
28      	\
29      - (SC_LG_NGROUP * SC_NGROUP))
30  #define SC_NBINS (							\
31      					\
32      SC_NTINY + SC_NPSEUDO						\
33      	\
34      + SC_NGROUP * (LG_PAGE + SC_LG_NGROUP - SC_LG_FIRST_REGULAR_BASE)	\
35      	\
36      - 1)
37  #if (SC_NBINS > 256)
38  #  error "Too many small size classes"
39  #endif
40  #define SC_LOOKUP_MAXCLASS ((size_t)1 << 12)
41  #define SC_SMALL_MAX_BASE ((size_t)1 << (LG_PAGE + SC_LG_NGROUP - 1))
42  #define SC_SMALL_MAX_DELTA ((size_t)1 << (LG_PAGE - 1))
43  #define SC_SMALL_MAXCLASS (SC_SMALL_MAX_BASE				\
44      + (SC_NGROUP - 1) * SC_SMALL_MAX_DELTA)
45  #define SC_LARGE_MINCLASS ((size_t)1ULL << (LG_PAGE + SC_LG_NGROUP))
46  #define SC_LG_LARGE_MINCLASS (LG_PAGE + SC_LG_NGROUP)
47  #define SC_MAX_BASE ((size_t)1 << (SC_PTR_BITS - 2))
48  #define SC_MAX_DELTA ((size_t)1 << (SC_PTR_BITS - 2 - SC_LG_NGROUP))
49  #define SC_LARGE_MAXCLASS (SC_MAX_BASE + (SC_NGROUP - 1) * SC_MAX_DELTA)
50  typedef struct sc_s sc_t;
51  struct sc_s {
52  	int index;
53  	int lg_base;
54  	int lg_delta;
55  	int ndelta;
56  	bool psz;
57  	bool bin;
58  	int pgs;
59  	int lg_delta_lookup;
60  };
61  typedef struct sc_data_s sc_data_t;
62  struct sc_data_s {
<span onclick='openModal()' class='match'>63  	unsigned ntiny;
64  	int nlbins;
65  	int nbins;
66  	int nsizes;
67  	int lg_ceil_nsizes;
68  	unsigned npsizes;
</span>69  	int lg_tiny_maxclass;
70  	size_t lookup_maxclass;
71  	size_t small_maxclass;
72  	int lg_large_minclass;
73  	size_t large_minclass;
74  	size_t large_maxclass;
75  	bool initialized;
76  	sc_t sc[SC_NSIZES];
77  };
78  void sc_data_init(sc_data_t *data);
79  void sc_data_update_slab_size(sc_data_t *data, size_t begin, size_t end,
80      int pgs);
81  void sc_boot(sc_data_t *data);
82  #endif &bsol;* JEMALLOC_INTERNAL_SC_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include "fuse_i.h"
3  #include "fuse_misc.h"
4  #include "fuse_opt.h"
5  #include "fuse_lowlevel.h"
6  #include "mount_util.h"
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <stddef.h>
10  #include <unistd.h>
11  #include <string.h>
12  #include <limits.h>
13  #include <errno.h>
14  #include <sys/param.h>
15  #define FUSE_HELPER_OPT(t, p) \
16  	{ t, offsetof(struct fuse_cmdline_opts, p), 1 }
17  static const struct fuse_opt fuse_helper_opts[] = {
18  	FUSE_HELPER_OPT("-h",		show_help),
19  	FUSE_HELPER_OPT("--help",	show_help),
20  	FUSE_HELPER_OPT("-V",		show_version),
21  	FUSE_HELPER_OPT("--version",	show_version),
22  	FUSE_HELPER_OPT("-d",		debug),
23  	FUSE_HELPER_OPT("debug",	debug),
24  	FUSE_HELPER_OPT("-d",		foreground),
25  	FUSE_HELPER_OPT("debug",	foreground),
26  	FUSE_OPT_KEY("-d",		FUSE_OPT_KEY_KEEP),
27  	FUSE_OPT_KEY("debug",		FUSE_OPT_KEY_KEEP),
28  	FUSE_HELPER_OPT("-f",		foreground),
29  	FUSE_HELPER_OPT("-s",		singlethread),
30  	FUSE_HELPER_OPT("fsname=",	nodefault_subtype),
31  	FUSE_OPT_KEY("fsname=",		FUSE_OPT_KEY_KEEP),
32  #ifndef __FreeBSD__
33  	FUSE_HELPER_OPT("subtype=",	nodefault_subtype),
34  	FUSE_OPT_KEY("subtype=",	FUSE_OPT_KEY_KEEP),
35  #endif
36  	FUSE_HELPER_OPT("clone_fd",	clone_fd),
37  	FUSE_HELPER_OPT("max_idle_threads=%u", max_idle_threads),
38  	FUSE_HELPER_OPT("max_threads=%u", max_threads),
39  	FUSE_OPT_END
40  };
41  struct fuse_conn_info_opts {
42  	int atomic_o_trunc;
43  	int no_remote_posix_lock;
44  	int no_remote_flock;
45  	int splice_write;
46  	int splice_move;
47  	int splice_read;
48  	int no_splice_write;
49  	int no_splice_move;
50  	int no_splice_read;
51  	int auto_inval_data;
52  	int no_auto_inval_data;
53  	int no_readdirplus;
54  	int no_readdirplus_auto;
55  	int async_dio;
56  	int no_async_dio;
57  	int writeback_cache;
58  	int no_writeback_cache;
59  	int async_read;
60  	int sync_read;
61  	unsigned max_write;
62  	unsigned max_readahead;
63  	unsigned max_background;
64  	unsigned congestion_threshold;
<span onclick='openModal()' class='match'>65  	unsigned time_gran;
66  	int set_max_write;
67  	int set_max_readahead;
68  	int set_max_background;
69  	int set_congestion_threshold;
70  	int set_time_gran;
</span>71  };
72  #define CONN_OPTION(t, p, v)					\
73  	{ t, offsetof(struct fuse_conn_info_opts, p), v }
74  static const struct fuse_opt conn_info_opt_spec[] = {
75  	CONN_OPTION("max_write=%u", max_write, 0),
76  	CONN_OPTION("max_write=", set_max_write, 1),
77  	CONN_OPTION("max_readahead=%u", max_readahead, 0),
78  	CONN_OPTION("max_readahead=", set_max_readahead, 1),
79  	CONN_OPTION("max_background=%u", max_background, 0),
80  	CONN_OPTION("max_background=", set_max_background, 1),
81  	CONN_OPTION("congestion_threshold=%u", congestion_threshold, 0),
82  	CONN_OPTION("congestion_threshold=", set_congestion_threshold, 1),
83  	CONN_OPTION("sync_read", sync_read, 1),
84  	CONN_OPTION("async_read", async_read, 1),
85  	CONN_OPTION("atomic_o_trunc", atomic_o_trunc, 1),
86  	CONN_OPTION("no_remote_lock", no_remote_posix_lock, 1),
87  	CONN_OPTION("no_remote_lock", no_remote_flock, 1),
88  	CONN_OPTION("no_remote_flock", no_remote_flock, 1),
89  	CONN_OPTION("no_remote_posix_lock", no_remote_posix_lock, 1),
90  	CONN_OPTION("splice_write", splice_write, 1),
91  	CONN_OPTION("no_splice_write", no_splice_write, 1),
92  	CONN_OPTION("splice_move", splice_move, 1),
93  	CONN_OPTION("no_splice_move", no_splice_move, 1),
94  	CONN_OPTION("splice_read", splice_read, 1),
95  	CONN_OPTION("no_splice_read", no_splice_read, 1),
96  	CONN_OPTION("auto_inval_data", auto_inval_data, 1),
97  	CONN_OPTION("no_auto_inval_data", no_auto_inval_data, 1),
98  	CONN_OPTION("readdirplus=no", no_readdirplus, 1),
99  	CONN_OPTION("readdirplus=yes", no_readdirplus, 0),
100  	CONN_OPTION("readdirplus=yes", no_readdirplus_auto, 1),
101  	CONN_OPTION("readdirplus=auto", no_readdirplus, 0),
102  	CONN_OPTION("readdirplus=auto", no_readdirplus_auto, 0),
103  	CONN_OPTION("async_dio", async_dio, 1),
104  	CONN_OPTION("no_async_dio", no_async_dio, 1),
105  	CONN_OPTION("writeback_cache", writeback_cache, 1),
106  	CONN_OPTION("no_writeback_cache", no_writeback_cache, 1),
107  	CONN_OPTION("time_gran=%u", time_gran, 0),
108  	CONN_OPTION("time_gran=", set_time_gran, 1),
109  	FUSE_OPT_END
110  };
111  void fuse_cmdline_help(void)
112  {
113  	printf("    -h   --help            print help\n"
114  	       "    -V   --version         print version\n"
115  	       "    -d   -o debug          enable debug output (implies -f)\n"
116  	       "    -f                     foreground operation\n"
117  	       "    -s                     disable multi-threaded operation\n"
118  	       "    -o clone_fd            use separate fuse device fd for each thread\n"
119  	       "                           (may improve performance)\n"
120  	       "    -o max_idle_threads    the maximum number of idle worker threads\n"
121  	       "                           allowed (default: -1)\n"
122  	       "    -o max_threads         the maximum number of worker threads\n"
123  	       "                           allowed (default: 10)\n");
124  }
125  static int fuse_helper_opt_proc(void *data, const char *arg, int key,
126  				struct fuse_args *outargs)
127  {
128  	(void) outargs;
129  	struct fuse_cmdline_opts *opts = data;
130  	switch (key) {
131  	case FUSE_OPT_KEY_NONOPT:
132  		if (!opts->mountpoint) {
133  			if (fuse_mnt_parse_fuse_fd(arg) != -1) {
134  				return fuse_opt_add_opt(&opts->mountpoint, arg);
135  			}
136  			char mountpoint[PATH_MAX] = "";
137  			if (realpath(arg, mountpoint) == NULL) {
138  				fuse_log(FUSE_LOG_ERR,
139  					"fuse: bad mount point `%s': %s\n",
140  					arg, strerror(errno));
141  				return -1;
142  			}
143  			return fuse_opt_add_opt(&opts->mountpoint, mountpoint);
144  		} else {
145  			fuse_log(FUSE_LOG_ERR, "fuse: invalid argument `%s'\n", arg);
146  			return -1;
147  		}
148  	default:
149  		return 1;
150  	}
151  }
152  static int add_default_subtype(const char *progname, struct fuse_args *args)
153  {
154  	int res;
155  	char *subtype_opt;
156  	const char *basename = strrchr(progname, '/');
157  	if (basename == NULL)
158  		basename = progname;
159  	else if (basename[1] != '\0')
160  		basename++;
161  	subtype_opt = (char *) malloc(strlen(basename) + 64);
162  	if (subtype_opt == NULL) {
163  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
164  		return -1;
165  	}
166  #ifdef __FreeBSD__
167  	sprintf(subtype_opt, "-ofsname=%s", basename);
168  #else
169  	sprintf(subtype_opt, "-osubtype=%s", basename);
170  #endif
171  	res = fuse_opt_add_arg(args, subtype_opt);
172  	free(subtype_opt);
173  	return res;
174  }
175  int fuse_parse_cmdline_312(struct fuse_args *args,
176  			   struct fuse_cmdline_opts *opts);
177  FUSE_SYMVER("fuse_parse_cmdline_312", "fuse_parse_cmdline@@FUSE_3.12")
178  int fuse_parse_cmdline_312(struct fuse_args *args,
179  			   struct fuse_cmdline_opts *opts)
180  {
181  	memset(opts, 0, sizeof(struct fuse_cmdline_opts));
182  	opts->max_idle_threads = UINT_MAX; &bsol;* new default in fuse version 3.12 */
183  	opts->max_threads = 10;
184  	if (fuse_opt_parse(args, opts, fuse_helper_opts,
185  			   fuse_helper_opt_proc) == -1)
186  		return -1;
187  	if (!opts->nodefault_subtype)
188  		if (add_default_subtype(args->argv[0], args) == -1)
189  			return -1;
190  	return 0;
191  }
192  int fuse_parse_cmdline_30(struct fuse_args *args,
193  		       struct fuse_cmdline_opts *opts);
194  FUSE_SYMVER("fuse_parse_cmdline_30", "fuse_parse_cmdline@FUSE_3.0")
195  int fuse_parse_cmdline_30(struct fuse_args *args,
196  			  struct fuse_cmdline_opts *out_opts)
197  {
198  	struct fuse_cmdline_opts opts;
199  	int rc = fuse_parse_cmdline_312(args, &opts);
200  	if (rc == 0) {
201  		memcpy(out_opts, &opts,
202  		       offsetof(struct fuse_cmdline_opts, max_idle_threads) +
203  		       sizeof(opts.max_idle_threads));
204  	}
205  	return rc;
206  }
207  int fuse_daemonize(int foreground)
208  {
209  	if (!foreground) {
210  		int nullfd;
211  		int waiter[2];
212  		char completed;
213  		if (pipe(waiter)) {
214  			perror("fuse_daemonize: pipe");
215  			return -1;
216  		}
217  		switch(fork()) {
218  		case -1:
219  			perror("fuse_daemonize: fork");
220  			return -1;
221  		case 0:
222  			break;
223  		default:
224  			(void) read(waiter[0], &completed, sizeof(completed));
225  			_exit(0);
226  		}
227  		if (setsid() == -1) {
228  			perror("fuse_daemonize: setsid");
229  			return -1;
230  		}
231  		(void) chdir("/");
232  		nullfd = open("/dev/null", O_RDWR, 0);
233  		if (nullfd != -1) {
234  			(void) dup2(nullfd, 0);
235  			(void) dup2(nullfd, 1);
236  			(void) dup2(nullfd, 2);
237  			if (nullfd > 2)
238  				close(nullfd);
239  		}
240  		completed = 1;
241  		(void) write(waiter[1], &completed, sizeof(completed));
242  		close(waiter[0]);
243  		close(waiter[1]);
244  	} else {
245  		(void) chdir("/");
246  	}
247  	return 0;
248  }
249  int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
250  		   size_t op_size, void *user_data)
251  {
252  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
253  	struct fuse *fuse;
254  	struct fuse_cmdline_opts opts;
255  	int res;
256  	struct fuse_loop_config *loop_config = NULL;
257  	if (fuse_parse_cmdline(&args, &opts) != 0)
258  		return 1;
259  	if (opts.show_version) {
260  		printf("FUSE library version %s\n", PACKAGE_VERSION);
261  		fuse_lowlevel_version();
262  		res = 0;
263  		goto out1;
264  	}
265  	if (opts.show_help) {
266  		if(args.argv[0][0] != '\0')
267  			printf("usage: %s [options] <mountpoint>\n\n",
268  			       args.argv[0]);
269  		printf("FUSE options:\n");
270  		fuse_cmdline_help();
271  		fuse_lib_help(&args);
272  		res = 0;
273  		goto out1;
274  	}
275  	if (!opts.show_help &&
276  	    !opts.mountpoint) {
277  		fuse_log(FUSE_LOG_ERR, "error: no mountpoint specified\n");
278  		res = 2;
279  		goto out1;
280  	}
281  	fuse = fuse_new_31(&args, op, op_size, user_data);
282  	if (fuse == NULL) {
283  		res = 3;
284  		goto out1;
285  	}
286  	if (fuse_mount(fuse,opts.mountpoint) != 0) {
287  		res = 4;
288  		goto out2;
289  	}
290  	if (fuse_daemonize(opts.foreground) != 0) {
291  		res = 5;
292  		goto out3;
293  	}
294  	struct fuse_session *se = fuse_get_session(fuse);
295  	if (fuse_set_signal_handlers(se) != 0) {
296  		res = 6;
297  		goto out3;
298  	}
299  	if (opts.singlethread)
300  		res = fuse_loop(fuse);
301  	else {
302  		loop_config = fuse_loop_cfg_create();
303  		if (loop_config == NULL) {
304  			res = 7;
305  			goto out3;
306  		}
307  		fuse_loop_cfg_set_clone_fd(loop_config, opts.clone_fd);
308  		fuse_loop_cfg_set_idle_threads(loop_config, opts.max_idle_threads);
309  		fuse_loop_cfg_set_max_threads(loop_config, opts.max_threads);
310  		res = fuse_loop_mt(fuse, loop_config);
311  	}
312  	if (res)
313  		res = 8;
314  	fuse_remove_signal_handlers(se);
315  out3:
316  	fuse_unmount(fuse);
317  out2:
318  	fuse_destroy(fuse);
319  out1:
320  	fuse_loop_cfg_destroy(loop_config);
321  	free(opts.mountpoint);
322  	fuse_opt_free_args(&args);
323  	return res;
324  }
325  void fuse_apply_conn_info_opts(struct fuse_conn_info_opts *opts,
326  			       struct fuse_conn_info *conn)
327  {
328  	if(opts->set_max_write)
329  		conn->max_write = opts->max_write;
330  	if(opts->set_max_background)
331  		conn->max_background = opts->max_background;
332  	if(opts->set_congestion_threshold)
333  		conn->congestion_threshold = opts->congestion_threshold;
334  	if(opts->set_time_gran)
335  		conn->time_gran = opts->time_gran;
336  	if(opts->set_max_readahead)
337  		conn->max_readahead = opts->max_readahead;
338  #define LL_ENABLE(cond,cap) \
339  	if (cond) conn->want |= (cap)
340  #define LL_DISABLE(cond,cap) \
341  	if (cond) conn->want &= ~(cap)
342  	LL_ENABLE(opts->splice_read, FUSE_CAP_SPLICE_READ);
343  	LL_DISABLE(opts->no_splice_read, FUSE_CAP_SPLICE_READ);
344  	LL_ENABLE(opts->splice_write, FUSE_CAP_SPLICE_WRITE);
345  	LL_DISABLE(opts->no_splice_write, FUSE_CAP_SPLICE_WRITE);
346  	LL_ENABLE(opts->splice_move, FUSE_CAP_SPLICE_MOVE);
347  	LL_DISABLE(opts->no_splice_move, FUSE_CAP_SPLICE_MOVE);
348  	LL_ENABLE(opts->auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
349  	LL_DISABLE(opts->no_auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
350  	LL_DISABLE(opts->no_readdirplus, FUSE_CAP_READDIRPLUS);
351  	LL_DISABLE(opts->no_readdirplus_auto, FUSE_CAP_READDIRPLUS_AUTO);
352  	LL_ENABLE(opts->async_dio, FUSE_CAP_ASYNC_DIO);
353  	LL_DISABLE(opts->no_async_dio, FUSE_CAP_ASYNC_DIO);
354  	LL_ENABLE(opts->writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
355  	LL_DISABLE(opts->no_writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
356  	LL_ENABLE(opts->async_read, FUSE_CAP_ASYNC_READ);
357  	LL_DISABLE(opts->sync_read, FUSE_CAP_ASYNC_READ);
358  	LL_DISABLE(opts->no_remote_posix_lock, FUSE_CAP_POSIX_LOCKS);
359  	LL_DISABLE(opts->no_remote_flock, FUSE_CAP_FLOCK_LOCKS);
360  }
361  struct fuse_conn_info_opts* fuse_parse_conn_info_opts(struct fuse_args *args)
362  {
363  	struct fuse_conn_info_opts *opts;
364  	opts = calloc(1, sizeof(struct fuse_conn_info_opts));
365  	if(opts == NULL) {
366  		fuse_log(FUSE_LOG_ERR, "calloc failed\n");
367  		return NULL;
368  	}
369  	if(fuse_opt_parse(args, opts, conn_info_opt_spec, NULL) == -1) {
370  		free(opts);
371  		return NULL;
372  	}
373  	return opts;
374  }
375  int fuse_open_channel(const char *mountpoint, const char* options)
376  {
377  	struct mount_opts *opts = NULL;
378  	int fd = -1;
379  	const char *argv[] = { "", "-o", options };
380  	int argc = sizeof(argv) / sizeof(argv[0]);
381  	struct fuse_args args = FUSE_ARGS_INIT(argc, (char**) argv);
382  	opts = parse_mount_opts(&args);
383  	if (opts == NULL)
384  		return -1;
385  	fd = fuse_kern_mount(mountpoint, opts);
386  	destroy_mount_opts(opts);
387  	return fd;
388  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</div>
                </div>
                <div class="column column_space"><pre><code>63  	unsigned ntiny;
64  	int nlbins;
65  	int nbins;
66  	int nsizes;
67  	int lg_ceil_nsizes;
68  	unsigned npsizes;
</pre></code></div>
                <div class="column column_space"><pre><code>65  	unsigned time_gran;
66  	int set_max_write;
67  	int set_max_readahead;
68  	int set_max_background;
69  	int set_congestion_threshold;
70  	int set_time_gran;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    