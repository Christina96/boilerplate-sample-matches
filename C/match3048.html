<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-traffic-replay.c &amp; inf-gtk-browser-store.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-traffic-replay.c &amp; inf-gtk-browser-store.c
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-traffic-replay.c (2.2304833%)<th>inf-gtk-browser-store.c (0.8759124%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(48-73)<td><a href="#" name="0">(40-84)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-traffic-replay.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#define _XOPEN_SOURCE 700
#include "util/inf-test-util.h"
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;libxml/xmlsave.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
typedef struct _InfTestTrafficReplay InfTestTrafficReplay;
struct _InfTestTrafficReplay {
  InfStandaloneIo* io;
  guint port;
  InfdXmppServer* xmpp;
  const gchar* filename;
<a name="0"></a>  GSList* conns;
};
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef enum _InfTestTrafficReplayMessageType {
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR
} InfTestTrafficReplayMessageType;
typedef struct _InfTestTrafficReplayMessage InfTestTrafficReplayMessage;
struct _InfTestTrafficReplayMessage {
  gint64 timestamp;   InfTestTrafficReplayMessageType type;
  xmlNodePtr xml;
  xmlNodePtr xml_iter;
};
typedef struct _InfTestTrafficReplayConnection InfTestTrafficReplayConnection;
struct _InfTestTrafficReplayConnection {
  gchar* name;
  InfTestTrafficReplay* replay;
  InfCertificateCredentials* creds;
  InfXmppConnection* xmpp;
  FILE* file;
  InfTestTrafficReplayMessage* message;
  GHashTable* group_queues; };</b></font>
typedef enum _InfTestTrafficReplayError {
  INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
  INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF
} InfTestTrafficReplayError;
static GQuark
inf_test_traffic_replay_error_quark()
{
  return g_quark_from_static_string("INF_TEST_TRAFFIC_REPLAY_ERROR");
}
static void
inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
                                    xmlNodePtr xml,
                                    gpointer user_data);
static void
inf_test_traffic_replay_notify_status_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data);
static void
inf_test_traffic_replay_queue_free(GQueue* queue)
{
  g_queue_free_full(queue, (GDestroyNotify)xmlFreeDoc);
}
static void
inf_test_traffic_replay_message_free(InfTestTrafficReplayMessage* message)
{
  if(message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    if(message-&gt;xml != NULL)
      xmlFreeNode(message-&gt;xml);
  }
  g_slice_free(InfTestTrafficReplayMessage, message);
}
static char*
inf_test_traffic_replay_get_next_line(InfTestTrafficReplayConnection* conn,
                                      size_t* len,
                                      GError** error)
{
  char* line;
  size_t n;
  ssize_t len_;
  int err;
  line = NULL;
  n = 0;
  len_ = getline(&amp;line, &amp;n, conn-&gt;file);
  if(len_ &gt;= 0)
  {
    *len = len_;
    return line;
  }
  else
  {
    if(feof(conn-&gt;file))
    {
      g_set_error(
        error,
        inf_test_traffic_replay_error_quark(),
        INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF,
        "Unexpected end of file"
      );
    }
    else
    {
      err = ferror(conn-&gt;file);
      g_set_error_literal(
        error,
        G_FILE_ERROR,
        g_file_error_from_errno(err),
        strerror(err)
      );
    }
    return NULL;
  }
}
static InfTestTrafficReplayMessage*
inf_test_traffic_replay_get_next_message(InfTestTrafficReplayConnection* conn,
                                         GError** error)
{
  char* line;
  size_t len;
  size_t n;
  struct tm tm;
  char* end;
  gulong msecs;
  InfTestTrafficReplayMessageType type;
  xmlDocPtr xml;
  GString* str;
  InfTestTrafficReplayMessage* message;
  line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
  if(!line) return NULL;
  if(line[0] != '[')
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Line does not start with a timestamp"
    );
    free(line);
    return FALSE;
  }
  end = strptime(&amp;line[1], "%a %d %b %Y %I:%M:%S %p %Z", &amp;tm);
  if(end == NULL || *end != ' ' || *(end+1) != '.')
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Failed to parse timestamp"
    );
    free(line);
    return FALSE;
  }
  errno = 0;
  msecs = strtoul(&amp;end[2], &amp;end, 10);
  if(errno != 0 || *end != ']' || msecs &gt;= 1000000)
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Failed to parse timestamp"
    );
    free(line);
    return FALSE;
  }
  ++end;
  tm.tm_isdst = 1;
  n = (end - line) + 1;
  if(line[n] == '!')
  {
    if(strstr(line + n + 4, "connected") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT;
    else if(strstr(line + n + 4, "Connection error") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR;
    else if(strstr(line + n + 4, "closed") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT;
    else
    {
      g_set_error(
        error,
        inf_test_traffic_replay_error_quark(),
        INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
        "Unknown connection event \"%s\"",
        line + n + 4
      );
      free(line);
      return FALSE;
    }
  }
  else if(line[n] == '&lt;')
  {
    if(FALSE)       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
    else
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
  }
  else if(line[n] == '&gt;')
  {
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
    else
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
  }
  else
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Unknown control character \"%c\" (%d)",
      line[n],
      (int)line[n]
    );
    free(line);
    return FALSE;
  }
  if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    str = g_string_new_len(line + n + 4, len - n - 5);
    xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
    while(!xml)
    {
      free(line);
      line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
      if(!line)
      {
        g_string_free(str, TRUE);
        return NULL;
      }
      g_string_append_c(str, '\n');
      g_string_append_len(str, line, len - 1);
      xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
    }
    g_string_free(str, TRUE);
  }
  free(line);
  message = g_slice_new(InfTestTrafficReplayMessage);
  message-&gt;timestamp = (gint64)mktime(&amp;tm) * 1000000 + msecs;
  message-&gt;type = type;
  if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    message-&gt;xml = xmlCopyNode(xmlDocGetRootElement(xml), 1);
    if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
      message-&gt;xml_iter = message-&gt;xml-&gt;children;
    xmlFreeDoc(xml);
  }
  return message;
}
static void
inf_test_traffic_replay_connection_close(InfTestTrafficReplayConnection* conn)
{
  InfXmlConnectionStatus status;
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(conn-&gt;xmpp),
    G_CALLBACK(inf_test_traffic_replay_received_cb),
    conn
  );
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(conn-&gt;xmpp),
    G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
    conn
  );
  if(conn-&gt;xmpp != NULL)
  {
    g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
    if(status == INF_XML_CONNECTION_OPEN ||
       status == INF_XML_CONNECTION_OPENING)
    {
      inf_xml_connection_close(INF_XML_CONNECTION(conn-&gt;xmpp));
    }
  }
  if(conn-&gt;creds != NULL)
    inf_certificate_credentials_unref(conn-&gt;creds);
  g_object_unref(conn-&gt;xmpp);
  if(conn-&gt;file != NULL) fclose(conn-&gt;file);
  g_hash_table_destroy(conn-&gt;group_queues);
  fprintf(stderr, "[%s] Disconnected\n", conn-&gt;name);
  g_free(conn-&gt;name);
  conn-&gt;replay-&gt;conns = g_slist_remove(conn-&gt;replay-&gt;conns, conn);
  if(conn-&gt;replay-&gt;conns == NULL)
    inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
  g_slice_free(InfTestTrafficReplayConnection, conn);
}
static void
inf_test_traffic_replay_connection_check_message(
  InfTestTrafficReplayConnection* conn,
  xmlNodePtr xml)
{
  xmlBufferPtr received_buffer;
  xmlBufferPtr expected_buffer;
  xmlSaveCtxtPtr ctx;
  received_buffer = xmlBufferCreate();
  expected_buffer = xmlBufferCreate();
  if(strcmp(conn-&gt;message-&gt;xml_iter-&gt;name, "message") == 0)
    xmlSetProp(conn-&gt;message-&gt;xml_iter, "time", NULL);
  if(strcmp(xml-&gt;name, "message") == 0)
    xmlSetProp(xml, "time", NULL);
  ctx = xmlSaveToBuffer(expected_buffer, "UTF-8", 0);
  xmlSaveTree(ctx, conn-&gt;message-&gt;xml_iter);
  xmlSaveClose(ctx);
  ctx = xmlSaveToBuffer(received_buffer, "UTF-8", 0);
  xmlSaveTree(ctx, xml);
  xmlSaveClose(ctx);
  if(strcmp(xmlBufferContent(expected_buffer), xmlBufferContent(received_buffer)) != 0)
  {
    fprintf(
      stderr,
      "[WARNING] [%s] Mismatch between expected and received: "
      "\n\n\"%s\"\n\nvs.\n\n\"%s\"\n",
      conn-&gt;name,
      (const gchar*)xmlBufferContent(expected_buffer),
      (const gchar*)xmlBufferContent(received_buffer)
    );
    xmlBufferFree(expected_buffer);
    xmlBufferFree(received_buffer);
    if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
      inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
    return;
  }
  xmlBufferFree(expected_buffer);
  xmlBufferFree(received_buffer);
}
static gboolean
inf_test_traffic_replay_connection_process_next_message(
  InfTestTrafficReplayConnection* conn)
{
  InfIpAddress* addr;
  InfTcpConnection* tcp;
  GError* error;
  xmlChar* group;
  GQueue* queue;
  switch(conn-&gt;message-&gt;type)
  {
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT:
    if(conn-&gt;xmpp != NULL)
      return FALSE;
    fprintf(stderr, "[%s] Connecting...\n", conn-&gt;name);
    addr = inf_ip_address_new_loopback4();
    tcp = inf_tcp_connection_new(
      INF_IO(conn-&gt;replay-&gt;io),
      addr,
      conn-&gt;replay-&gt;port
    );
    inf_ip_address_free(addr);
    conn-&gt;xmpp = inf_xmpp_connection_new(
      tcp,
      INF_XMPP_CONNECTION_CLIENT,
      NULL,
      "localhost",
      INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
      conn-&gt;creds,
      NULL,
      NULL
    );
    g_signal_connect(
      G_OBJECT(conn-&gt;xmpp),
      "received",
      G_CALLBACK(inf_test_traffic_replay_received_cb),
      conn
    );
    g_signal_connect(
      G_OBJECT(conn-&gt;xmpp),
      "notify::status",
      G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
      conn
    );
    error = NULL;
    if(!inf_tcp_connection_open(tcp, &amp;error))
    {
      fprintf(stderr, "[ERROR] [%s] %s\n", conn-&gt;name, error-&gt;message);
      g_error_free(error);
      if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
        inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return FALSE;
    }
    g_object_unref(tcp);
    return FALSE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT:
    g_assert(conn-&gt;xmpp != NULL);
    inf_test_traffic_replay_connection_close(conn);
    return TRUE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR:
    g_assert(conn-&gt;xmpp != NULL);
    fprintf(stderr, "[%s] Recorded connection error, ignored\n", conn-&gt;name);
    return TRUE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING:
    g_assert(conn-&gt;xmpp != NULL);
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(stderr, "[%s] Expecting data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml_iter-&gt;name);     queue = g_hash_table_lookup(conn-&gt;group_queues, group);
    xmlFree(group);
    g_assert(queue == NULL || g_queue_is_empty(queue));
    return FALSE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING:
    g_assert(conn-&gt;xmpp != NULL);
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(stderr, "[%s] Sending data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml-&gt;children-&gt;name);     xmlFree(group);
    inf_xml_connection_send(
      INF_XML_CONNECTION(conn-&gt;xmpp),
      conn-&gt;message-&gt;xml
    );
    conn-&gt;message-&gt;xml = NULL;
    return TRUE;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay);
static void
inf_test_traffic_replay_connection_fetch_next_message(
  InfTestTrafficReplayConnection* conn)
{
  xmlChar* group;
  GQueue* queue;
  xmlNodePtr xml;
  if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
    return;
  if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING &amp;&amp;
     conn-&gt;message-&gt;xml_iter-&gt;next != NULL)
  {
    conn-&gt;message-&gt;xml_iter = conn-&gt;message-&gt;xml_iter-&gt;next;
  }
  else
  {
    GError* error;
    inf_test_traffic_replay_message_free(conn-&gt;message);
    error = NULL;
    conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
    if(error != NULL)
    {
      fprintf(
        stderr,
        "[ERROR] [%s] Failed to fetch message: %s\n",
        conn-&gt;name,
        error-&gt;message
      );
      g_error_free(error);
      if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
        inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return;
    }
  }
  if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
  {
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    queue = g_hash_table_lookup(conn-&gt;group_queues, group);
    if(queue != NULL &amp;&amp; !g_queue_is_empty(queue))
    {
      xml = g_queue_pop_head(queue);
      fprintf(stderr, "[%s] Replay data (%s, %s)\n", conn-&gt;name, group, xml-&gt;name);
      inf_test_traffic_replay_connection_check_message(conn, xml);
      inf_test_traffic_replay_connection_fetch_next_message(conn);
      xmlFree(group);
      return;
    }
    xmlFree(group);
  }
  inf_test_traffic_replay_process_next_message(conn-&gt;replay);
}
static void
inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay)
{
  GSList* item;
  InfTestTrafficReplayConnection* conn;
  InfTestTrafficReplayConnection* low;
  if(!inf_standalone_io_loop_running(replay-&gt;io))
    return;
  low = NULL;
  for(item = replay-&gt;conns; item != NULL; item = item-&gt;next)
  {
    conn = (InfTestTrafficReplayConnection*)item-&gt;data;
    if(low == NULL || conn-&gt;message-&gt;timestamp &lt; low-&gt;message-&gt;timestamp)
      low = conn;
    else if(conn-&gt;message-&gt;timestamp == low-&gt;message-&gt;timestamp)
    {
      if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING &amp;&amp;
         low-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
      {
        low = conn;
      }
    }
  }
  if(inf_test_traffic_replay_connection_process_next_message(low))
  {
    if(g_slist_find(replay-&gt;conns, low))
      inf_test_traffic_replay_connection_fetch_next_message(low);
    else
      inf_test_traffic_replay_process_next_message(replay);
  }
}
static void
inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
                                    xmlNodePtr xml,
                                    gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  xmlBufferPtr buffer;
  xmlSaveCtxtPtr ctx;
  xmlNodePtr child;
  GQueue* queue;
  xmlChar* received_group;
  xmlChar* expected_group;
  conn = (InfTestTrafficReplayConnection*)user_data;
  g_assert(strcmp(xml-&gt;name, "group") == 0);
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
      break;
    if(!conn-&gt;message ||
       conn-&gt;message-&gt;type != INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
    {
      buffer = xmlBufferCreate();
      ctx = xmlSaveToBuffer(buffer, "UTF-8", 0);
      xmlSaveTree(ctx, child);
      xmlSaveClose(ctx);
      fprintf(
        stderr,
        "[ERROR] [%s] Received text \"%s\" without expecting any\n",
        conn-&gt;name,
        (const gchar*)xmlBufferContent(buffer)
      );
      xmlBufferFree(buffer);
      inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return;
    }
    received_group = xmlGetProp(xml, "name");
    expected_group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(
      stderr,
      "[%s] Received data (%s, %s), expected %s\n",
      conn-&gt;name,
      received_group,
      child-&gt;name,
      expected_group
    );
    queue = g_hash_table_lookup(conn-&gt;group_queues, expected_group);
    g_assert(queue == NULL || g_queue_is_empty(queue));
    if(strcmp(received_group, expected_group) != 0)
    {
      queue = g_hash_table_lookup(conn-&gt;group_queues, received_group);
      if(!queue)
      {
        queue = g_queue_new();
        g_hash_table_insert(
          conn-&gt;group_queues,
          g_strdup(received_group),
          queue
        );
      }
      g_queue_push_tail(queue, xmlCopyNode(child, 1));
      xmlFree(received_group);
      xmlFree(expected_group);
    }
    else
    {
      xmlFree(received_group);
      xmlFree(expected_group);
      inf_test_traffic_replay_connection_check_message(conn, child);
      inf_test_traffic_replay_connection_fetch_next_message(conn);
    }
  }
}
static void
inf_test_traffic_replay_notify_status_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  InfXmlConnectionStatus status;
  conn = (InfTestTrafficReplayConnection*)user_data;
  g_object_get(object, "status", &amp;status, NULL);
  switch(status)
  {
  case INF_XML_CONNECTION_OPENING:
    break;
  case INF_XML_CONNECTION_OPEN:
    fprintf(stderr, "[%s] Connected\n", conn-&gt;name);
    inf_test_traffic_replay_connection_fetch_next_message(conn);
    break;
  case INF_XML_CONNECTION_CLOSING:
  case INF_XML_CONNECTION_CLOSED:
    fprintf(stderr, "[ERROR] [%s] Remote connection closed\n", conn-&gt;name);
    inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
    break;
  }
}
static void
inf_test_traffic_replay_new_connection_cb(InfdXmppServer* server,
                                          InfXmppConnection* xmpp,
                                          gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  InfTestTrafficReplay* replay;
  InfXmlConnectionStatus status;
  GError* error;
  conn = g_slice_new(InfTestTrafficReplayConnection);
  replay = (InfTestTrafficReplay*)user_data;
  conn-&gt;name = g_strdup("server");
  conn-&gt;replay = replay;
  conn-&gt;creds = NULL;
  conn-&gt;xmpp = xmpp;
  conn-&gt;group_queues = g_hash_table_new_full(
    g_str_hash,
    g_str_equal,
    g_free,
    (GDestroyNotify)inf_test_traffic_replay_queue_free
  );
  error = NULL;
  conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
  if(error != NULL)
  {
    fprintf(
      stderr,
      "Failed to read initial message for %s: %s\n",
      conn-&gt;name,
      error-&gt;message
    );
    inf_test_traffic_replay_connection_close(conn);
  }
  replay-&gt;conns = g_slist_prepend(replay-&gt;conns, conn);
  g_object_ref(xmpp);
  g_signal_connect(
    G_OBJECT(xmpp),
    "received",
    G_CALLBACK(inf_test_traffic_replay_received_cb),
    conn
  );
  g_signal_connect(
    G_OBJECT(conn-&gt;xmpp),
    "notify::status",
    G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
    conn
  );
  conn-&gt;file = fopen(replay-&gt;filename, "r");
  if(!conn-&gt;file)
  {
    fprintf(
      stderr,
      "Failed to open %s: %s\n",
      replay-&gt;filename,
      strerror(errno)
    );
    inf_test_traffic_replay_connection_close(conn);
  }
  else
  {
    g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
    if(status == INF_XML_CONNECTION_OPEN)
    {
      inf_test_traffic_replay_connection_fetch_next_message(conn);
    }
  }
}
static InfCertificateCredentials*
inf_test_traffic_replay_load_server_credentials(GError** error)
{
  GPtrArray* array;
  gnutls_x509_privkey_t key;
  InfCertificateCredentials* creds;
  gnutls_certificate_credentials_t gcreds;
  guint i;
  key = inf_cert_util_read_private_key(
    "/home/armin/kombia/kombia.cert",
    error
  );
  if(!key) return NULL;
  array = inf_cert_util_read_certificate(
    "/home/armin/kombia/kombia.cert",
    NULL,
    error
  );
  if(!array) return NULL;
  creds = inf_certificate_credentials_new();
  gcreds = inf_certificate_credentials_get(creds);
  gnutls_certificate_set_x509_key(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len,
    key
  );
  gnutls_certificate_set_x509_trust(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len
  );
  gnutls_x509_privkey_deinit(key);
  for(i = 0; i &lt; array-&gt;len; ++i)
    gnutls_x509_crt_deinit(array-&gt;pdata[i]);
  g_ptr_array_free(array, TRUE);
  return creds;
}
static InfCertificateCredentials*
inf_test_traffic_replay_load_client_credentials(const gchar* path,
                                                GError** error)
{
  gchar* basename;
  gchar* dirname;
  gchar* full;
  GPtrArray* array;
  gnutls_x509_privkey_t key;
  InfCertificateCredentials* creds;
  gnutls_certificate_credentials_t gcreds;
  guint i;
  basename = g_path_get_basename(path);
  dirname = g_path_get_dirname(path);
  full = g_build_filename(dirname, "certs", basename, NULL);
  g_free(basename);
  g_free(dirname);
  key = inf_cert_util_read_private_key(full, error);
  if(!key) { g_free(full); return NULL; }
  array = inf_cert_util_read_certificate(full, NULL, error);
  if(!array) { g_free(full); return NULL; }
  g_free(full);
  creds = inf_certificate_credentials_new();
  gcreds = inf_certificate_credentials_get(creds);
  gnutls_certificate_set_x509_key(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len,
    key
  );
  gnutls_certificate_set_x509_trust(
    gcreds,
    (gnutls_x509_crt_t*)&amp;array-&gt;pdata[array-&gt;len - 1],
    1
  );
  gnutls_x509_privkey_deinit(key);
  for(i = 0; i &lt; array-&gt;len; ++i)
    gnutls_x509_crt_deinit(array-&gt;pdata[i]);
  g_ptr_array_free(array, TRUE);
  return creds;
}
static void
inf_test_traffic_replay_start_func(gpointer user_data)
{
  inf_test_traffic_replay_process_next_message(user_data);
}
int main(int argc, char* argv[])
{
  InfTestTrafficReplay replay;
  InfdTcpServer* server;
  InfCertificateCredentials* creds;
  GError* error;
  gboolean as_server;
  guint port;
  int i;
  FILE* f;
  InfTestTrafficReplayConnection* conn;
  as_server = FALSE;
  port = 6524;
  if(argc &lt; 2)
  {
    fprintf(stderr, "Usage: %s &lt;traffic-log&gt;\n", argv[0]);
    return -1;
  }
  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    g_error_free(error);
    return -1;
  }
  replay.io = inf_standalone_io_new();
  replay.port = port;
  replay.xmpp = NULL;
  replay.conns = NULL;
  if(as_server == TRUE)
  {
    replay.filename = argv[1];
    creds = inf_test_traffic_replay_load_server_credentials(&amp;error);
    if(!creds)
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      return -1;
    }
    server = g_object_new(
      INFD_TYPE_TCP_SERVER,
      "io", replay.io,
      "local-address", NULL,
      "local-port", port,
      NULL
    );
    replay.xmpp = infd_xmpp_server_new(
      server,
      INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
      creds,
      NULL,
      NULL
    );
    inf_certificate_credentials_unref(creds);
    g_signal_connect(
      G_OBJECT(replay.xmpp),
      "new-connection",
      G_CALLBACK(inf_test_traffic_replay_new_connection_cb),
      &amp;replay
    );
    if(!infd_tcp_server_open(server, &amp;error))
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      return 1;
    }
    g_object_unref(server);
  }
  else
  {
    replay.filename = NULL;
    for(i = 1; i &lt; argc; ++i)
    {
      f = fopen(argv[i], "r");
      if(!f)
      {
        fprintf(
          stderr,
          "Failed to open %s: %s\n",
          argv[i],
          strerror(errno)
        );
        return 1;
      }
      conn = g_slice_new(InfTestTrafficReplayConnection);
      conn-&gt;replay = &amp;replay;
      conn-&gt;name = g_strdup_printf("client %d (%s)", i, argv[i]);
      conn-&gt;xmpp = NULL;
      conn-&gt;file = f;
      conn-&gt;group_queues = g_hash_table_new_full(
        g_str_hash,
        g_str_equal,
        g_free,
        (GDestroyNotify)inf_test_traffic_replay_queue_free
      );
      conn-&gt;creds = inf_test_traffic_replay_load_client_credentials(argv[i], &amp;error);
      if(error != NULL)
      {
        if(error-&gt;domain == G_FILE_ERROR &amp;&amp; error-&gt;code == G_FILE_ERROR_NOENT)
        {
          printf("No client credentials for %s\n", conn-&gt;name);
          g_error_free(error);
          error = NULL;
        }
        else
        {
          fprintf(
            stderr,
            "Failed to load client credentials for %s: %s\n",
            conn-&gt;name,
            error-&gt;message
          );
          return 1;
        }
      }
      else
      {
        printf("Loaded client credentials for %s\n", conn-&gt;name);
      }
      replay.conns = g_slist_prepend(replay.conns, conn);
      conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
      if(error != NULL)
      {
        fprintf(
          stderr,
          "Failed to read initial message for %s: %s\n",
          conn-&gt;name,
          error-&gt;message
        );
        return 1;
      }
    }
    inf_io_add_dispatch(
      INF_IO(replay.io),
      inf_test_traffic_replay_start_func,
      &amp;replay,
      NULL
    );
  }
  inf_standalone_io_loop(replay.io);
  return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-browser-store.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfgtk/inf-gtk-browser-store.h&gt;
#include &lt;libinfgtk/inf-gtk-browser-model.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;gtk/gtk.h&gt;
typedef struct _InfGtkBrowserStoreItem InfGtkBrowserStoreItem;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct _InfGtkBrowserStoreItem {
  gchar* name;
  InfDiscovery* discovery;
  InfDiscoveryInfo* info;
  InfBrowser* browser;
  gpointer missing;
  GSList* requests;
  GHashTable* node_errors;
  InfGtkBrowserModelStatus status;
  GError* error;
  InfGtkBrowserStoreItem* next;
};
typedef struct _InfGtkBrowserStoreRequestData InfGtkBrowserStoreRequestData;
struct _InfGtkBrowserStoreRequestData {
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
};
typedef struct _InfGtkBrowserStorePrivate InfGtkBrowserStorePrivate;
struct _InfGtkBrowserStorePrivate {
  gint stamp;
  InfIo* io;
  InfCommunicationManager* communication_manager;
  GSList* discoveries;
  InfGtkBrowserStoreItem* first_item;
  InfGtkBrowserStoreItem* last_item;
};</b></font>
enum {
  PROP_0,
  PROP_IO,
  PROP_COMMUNICATION_MANAGER
};
#define INF_GTK_BROWSER_STORE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_BROWSER_STORE, InfGtkBrowserStorePrivate))
static void inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface);
static void inf_gtk_browser_store_browser_model_iface_init(InfGtkBrowserModelInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfGtkBrowserStore, inf_gtk_browser_store, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfGtkBrowserStore)
  G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, inf_gtk_browser_store_tree_model_iface_init)
  G_IMPLEMENT_INTERFACE(INF_GTK_TYPE_BROWSER_MODEL, inf_gtk_browser_store_browser_model_iface_init))
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_connection(InfGtkBrowserStore* store,
                                              InfXmlConnection* connection)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfcBrowser* browser;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
  {
    if(item-&gt;browser != NULL &amp;&amp; INFC_IS_BROWSER(item-&gt;browser))
    {
      browser = INFC_BROWSER(item-&gt;browser);
      if(infc_browser_get_connection(browser) == connection)
        return item;
    }
  }
  return NULL;
}
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_browser(InfGtkBrowserStore* store,
                                           InfBrowser* browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;browser != NULL)
      if(item-&gt;browser == browser)
        return item;
  return NULL;
}
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_discovery_info(InfGtkBrowserStore* store,
                                                  InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;info != NULL)
      if(item-&gt;info == info)
        return item;
  return NULL;
}
static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data);
static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data);
static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data);
static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data);
static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data);
static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data);
static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data);
static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was);
static void
inf_gtk_browser_store_request_data_free(gpointer data,
                                        GClosure* closure)
{
  g_slice_free(InfGtkBrowserStoreRequestData, data);
}
static void
inf_gtk_browser_store_item_request_remove(InfGtkBrowserStoreItem* item,
                                          InfRequest* request)
{
  g_object_weak_unref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(request),
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    item
  );
  item-&gt;requests = g_slist_remove(item-&gt;requests, request);
}
static void
inf_gtk_browser_store_item_request_add(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       InfRequest* request)
{
  InfGtkBrowserStoreRequestData* data;
  g_assert(g_slist_find(item-&gt;requests, request) == NULL);
  item-&gt;requests = g_slist_prepend(item-&gt;requests, request);
  data = g_slice_new(InfGtkBrowserStoreRequestData);
  data-&gt;store = store;
  data-&gt;item = item;
  g_signal_connect_data(
    G_OBJECT(request),
    "finished",
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    data,
    inf_gtk_browser_store_request_data_free,
    0
  );
  g_object_weak_ref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );
}
static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data)
{
  InfGtkBrowserStoreRequestData* data;
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter request_iter;
  gboolean node_exists;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  data = (InfGtkBrowserStoreRequestData*)user_data;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(data-&gt;store);
  g_assert(g_slist_find(data-&gt;item-&gt;requests, request) != NULL);
  g_assert(data-&gt;item-&gt;browser != NULL);
  if(error != NULL)
  {
    node_exists = inf_browser_iter_from_request(
      data-&gt;item-&gt;browser,
      request,
      &amp;request_iter
    );
    inf_gtk_browser_store_item_request_remove(data-&gt;item, request);
    if(G_LIKELY(node_exists))
    {
      g_hash_table_insert(
        data-&gt;item-&gt;node_errors,
        GUINT_TO_POINTER(request_iter.node_id),
        g_error_copy(error)
      );
      tree_iter.stamp = priv-&gt;stamp;
      tree_iter.user_data = data-&gt;item;
      tree_iter.user_data2 = GUINT_TO_POINTER(request_iter.node_id);
      if(request_iter.node_id == 0)
        tree_iter.user_data3 = NULL;
      else
        tree_iter.user_data3 = request_iter.node;
      path = gtk_tree_model_get_path(GTK_TREE_MODEL(data-&gt;store), &amp;tree_iter);
      gtk_tree_model_row_changed(GTK_TREE_MODEL(data-&gt;store), path, &amp;tree_iter);
      gtk_tree_path_free(path);
    }
  }
}
static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was)
{
  InfGtkBrowserStoreItem* item;
  item = (InfGtkBrowserStoreItem*)data;
  item-&gt;requests = g_slist_remove(item-&gt;requests, where_the_object_was);
}
static void
inf_gtk_browser_store_item_set_browser(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       GtkTreePath* path,
                                       InfBrowser* browser)
{
  GtkTreeIter tree_iter;
  InfGtkBrowserStorePrivate* priv;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;
  inf_gtk_browser_model_set_browser(
    INF_GTK_BROWSER_MODEL(store),
    path,
    &amp;tree_iter,
    item-&gt;browser,
    browser
  );
}
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_browser(InfGtkBrowserStore* store,
                                          InfDiscovery* discovery,
                                          InfDiscoveryInfo* info,
                                          InfBrowser* browser,
                                          gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  GtkTreeIter iter;
  guint index;
  g_assert(
    browser == NULL ||
    inf_gtk_browser_store_find_item_by_browser(store, browser) == NULL
  );
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = g_slice_new(InfGtkBrowserStoreItem);
  item-&gt;name = name;
  item-&gt;discovery = discovery;
  item-&gt;info = info;
  item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
  if(discovery != NULL &amp;&amp; info != NULL)
    item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
  item-&gt;browser = NULL;
  item-&gt;missing = NULL;
  item-&gt;node_errors = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)g_error_free
  );
  item-&gt;requests = NULL;
  item-&gt;error = NULL;
  item-&gt;next = NULL;
  index = 0;
  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
    ++ index;
  if(priv-&gt;first_item == NULL)
  {
    priv-&gt;first_item = item;
    priv-&gt;last_item = item;
  }
  else
  {
    priv-&gt;last_item-&gt;next = item;
    priv-&gt;last_item = item;
  }
  path = gtk_tree_path_new_from_indices(index, -1);
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;
  gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;iter);
  if(browser != NULL)
    inf_gtk_browser_store_item_set_browser(store, item, path, browser);
  gtk_tree_path_free(path);
  return item;
}
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_connection(InfGtkBrowserStore* store,
                                             InfDiscovery* discovery,
                                             InfDiscoveryInfo* info,
                                             InfXmlConnection* connection,
                                             gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfcBrowser* browser;
  InfGtkBrowserStoreItem* item;
  g_assert(
    connection == NULL ||
    inf_gtk_browser_store_find_item_by_connection(store, connection) == NULL
  );
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  browser = NULL;
  if(connection != NULL)
  {
    browser = infc_browser_new(
      priv-&gt;io,
      priv-&gt;communication_manager,
      connection
    );
    if(infc_browser_get_connection(browser) == NULL)
    {
      g_object_unref(browser);
      g_free(name);
      return NULL;
    }
  }
  item = inf_gtk_browser_store_add_item_by_browser(
    store,
    discovery,
    info,
    INF_BROWSER(browser),
    name
  );
  if(browser != NULL)
    g_object_unref(browser);
  return item;
}
static void
inf_gtk_browser_store_remove_item(InfGtkBrowserStore* store,
                                  InfGtkBrowserStoreItem* item)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  guint index;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  prev = NULL;
  index = 0;
  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
  {
    if(cur == item)
      break;
    prev = cur;
    ++ index;
  }
  g_assert(cur != NULL);
  path = gtk_tree_path_new_from_indices(index, -1);
  if(item-&gt;browser != NULL)
  {
    inf_gtk_browser_store_item_set_browser(store, item, path, NULL);
    g_assert(item-&gt;browser == NULL);   }
  if(prev == NULL)
    priv-&gt;first_item = item-&gt;next;
  else
    prev-&gt;next = item-&gt;next;
  if(item-&gt;next == NULL)
    priv-&gt;last_item = prev;
  g_assert(cur != NULL);
  gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
  gtk_tree_path_free(path);
  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);
  g_hash_table_unref(item-&gt;node_errors);
  g_free(item-&gt;name);
  g_slice_free(InfGtkBrowserStoreItem, item);
}
static void
inf_gtk_browser_store_discovered_cb(InfDiscovery* discovery,
                                    InfDiscoveryInfo* info,
                                    gpointer user_data)
{
  inf_gtk_browser_store_add_item_by_browser(
    INF_GTK_BROWSER_STORE(user_data),
    discovery,
    info,
    NULL,
    inf_discovery_info_get_service_name(discovery, info)
  );
}
static void
inf_gtk_browser_store_undiscovered_cb(InfDiscovery* discovery,
                                      InfDiscoveryInfo* info,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
  if(item != NULL)
  {
    if(item-&gt;browser == NULL)
    {
      inf_gtk_browser_store_remove_item(store, item);
    }
    else
    {
      g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_DISCOVERED &amp;&amp;
               item-&gt;status != INF_GTK_BROWSER_MODEL_RESOLVING);
      item-&gt;discovery = NULL;
      item-&gt;info = NULL;
    }
  }
}
static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStorePrivate* priv;
  GtkTreeIter iter;
  GtkTreePath* path;
  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_assert(item != NULL);
  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);
  item-&gt;error = g_error_copy(error);
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;
  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}
static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfBrowser* browser;
  InfBrowserStatus status;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;
  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(user_data);  
  browser = INF_BROWSER(object);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_assert(item != NULL);
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;
  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);
  switch(status)
  {
  case INF_BROWSER_CLOSED:
    item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
    if(item-&gt;error == NULL)
    {
      item-&gt;error = g_error_new_literal(
        g_quark_from_static_string("INF_GTK_BROWSER_STORE_ERROR"),
        0,
        _("Disconnected")
      );
    }
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPENING:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPEN:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  gtk_tree_path_free(path);
}
static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfBrowserIter test_iter;
  gboolean test_result;
  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;
  if(iter-&gt;node_id != 0)
  {
    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;tree_iter);
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
    gtk_tree_path_up(path);
    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;
    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);
    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }
    gtk_tree_path_free(path);
  }
}
static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfBrowserIter test_iter;
  gboolean test_result;
  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_assert(item-&gt;missing == NULL);
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;
  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
  item-&gt;missing = iter-&gt;node;
  if(iter-&gt;node_id != 0)
  {
    gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
    gtk_tree_path_up(path);
    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;
    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);
    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }
  }
  else
  {
    if(inf_browser_get_explored(browser, iter))
    {
      test_iter = *iter;
      test_result = inf_browser_get_child(browser, &amp;test_iter);
      gtk_tree_path_down(path);
      do
      {
        gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
      } while(inf_browser_get_next(browser, &amp;test_iter));
      if(test_result == TRUE)
      {
        gtk_tree_path_up(path);
        gtk_tree_model_row_has_child_toggled(
          GTK_TREE_MODEL(store),
          path,
          &amp;tree_iter
        );
      }
    }
  }
  item-&gt;missing = NULL;
  gtk_tree_path_free(path);
}
static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  inf_gtk_browser_store_item_request_add(store, item, request);
}
static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  g_assert(iter != NULL);
  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  inf_gtk_browser_store_item_request_add(store, item, request);
}
static void
inf_gtk_browser_store_resolv_complete_func(InfDiscoveryInfo* info,
                                           InfXmlConnection* connection,
                                           const GError* error,
                                           gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* new_item;
  InfGtkBrowserStoreItem* old_item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfcBrowser* browser;
  InfGtkBrowserStoreItem* cur;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* prev_new;
  InfGtkBrowserStoreItem* prev_old;
  gint* order;
  guint count;
  guint new_pos;
  guint old_pos;
  guint i;
  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  new_item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
  g_assert(new_item != NULL);
  g_assert(new_item-&gt;status == INF_GTK_BROWSER_MODEL_RESOLVING);
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = new_item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;
  if(error != NULL)
  {
    new_item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
    new_item-&gt;error = g_error_copy(error);
    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;tree_iter);
    gtk_tree_path_free(path);
  }
  else
  {
    old_item =
      inf_gtk_browser_store_find_item_by_connection(store, connection);
    if(old_item != NULL)
    {
      g_assert(old_item != new_item);
      count = 0;
      prev = NULL;
      for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      {
        if(cur == old_item) { old_pos = count; prev_old = prev; }
        if(cur == new_item) { new_pos = count; prev_new = prev; }
        ++ count;
        prev = cur;
      }
      inf_gtk_browser_store_remove_item(store, new_item);
      if(old_pos &gt; new_pos) -- old_pos;
      else -- new_pos;
      -- count;
      if(new_pos != old_pos)
      {
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = prev_old;
        if(prev_old != NULL)
          prev_old-&gt;next = old_item-&gt;next;
        else
          priv-&gt;first_item = old_item-&gt;next;
        old_item-&gt;next = prev_new-&gt;next;
        if(prev_new != NULL)
          prev_new-&gt;next = old_item;
        else
          priv-&gt;first_item = old_item;
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = old_item;
        order = g_malloc(sizeof(gint) * count);
        if(new_pos &lt; old_pos)
        {
          for(i = 0; i &lt; new_pos; ++ i)
            order[i] = i;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt;= old_pos; ++ i)
            order[i] = i - 1;
          for(i = old_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }
        else
        {
          for(i = 0; i &lt; old_pos; ++ i)
            order[i] = i;
          for(i = old_pos; i &lt; new_pos; ++ i)
            order[i] = i + 1;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }
        path = gtk_tree_path_new();
        gtk_tree_model_rows_reordered(
          GTK_TREE_MODEL(store),
          path,
          NULL,
          order
        );
        gtk_tree_path_free(path);
        g_free(order);
      }
    }
    else
    {
      path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
      browser = infc_browser_new(
        priv-&gt;io,
        priv-&gt;communication_manager,
        connection
      );
      if(infc_browser_get_connection(browser) != NULL)
      {
        inf_gtk_browser_store_item_set_browser(
          store,
          new_item,
          path,
          INF_BROWSER(browser)
        );
      }
      g_object_unref(G_OBJECT(browser));
      gtk_tree_path_free(path);
    }
  }
}
static void
inf_gtk_browser_store_init(InfGtkBrowserStore* store)
{
  InfGtkBrowserStorePrivate* priv;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  priv-&gt;stamp = g_random_int();
  priv-&gt;io = NULL;
  priv-&gt;communication_manager = NULL;
  priv-&gt;discoveries = NULL;
  priv-&gt;first_item = NULL;
  priv-&gt;last_item = NULL;
}
static void
inf_gtk_browser_store_dispose(GObject* object)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  GSList* item;
  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  while(priv-&gt;first_item != NULL)
    inf_gtk_browser_store_remove_item(store, priv-&gt;first_item);
  g_assert(priv-&gt;last_item == NULL);
  for(item = priv-&gt;discoveries; item != NULL; item = g_slist_next(item))
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_discovered_cb),
      store
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
      store
    );
    g_object_unref(G_OBJECT(item-&gt;data));
  }
  g_slist_free(priv-&gt;discoveries);
  priv-&gt;discoveries = NULL;
  if(priv-&gt;communication_manager != NULL)
  {
    g_object_unref(priv-&gt;communication_manager);
    priv-&gt;communication_manager = NULL;
  }
  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }
  G_OBJECT_CLASS(inf_gtk_browser_store_parent_class)-&gt;dispose(object);
}
static void
inf_gtk_browser_store_set_property(GObject* object,
                                   guint prop_id,
                                   const GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_COMMUNICATION_MANAGER: 
    g_assert(priv-&gt;communication_manager == NULL);     priv-&gt;communication_manager =
      INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_gtk_browser_store_get_property(GObject* object,
                                   guint prop_id,
                                   GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, priv-&gt;io);
    break;
  case PROP_COMMUNICATION_MANAGER:
    g_value_set_object(value, priv-&gt;communication_manager);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static GtkTreeModelFlags
inf_gtk_browser_store_tree_model_get_flags(GtkTreeModel* model)
{
  return GTK_TREE_MODEL_ITERS_PERSIST;
}
static gint
inf_gtk_browser_store_tree_model_get_n_columns(GtkTreeModel* model)
{
  return INF_GTK_BROWSER_MODEL_NUM_COLS;
}
static GType
inf_gtk_browser_store_tree_model_get_column_type(GtkTreeModel* model,
                                                 gint index)
{
  switch(index)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    return INF_TYPE_DISCOVERY;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    return INFC_TYPE_BROWSER;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    return INF_GTK_TYPE_BROWSER_MODEL_STATUS;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    return G_TYPE_STRING;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    return INF_TYPE_BROWSER_ITER;
  default:
    g_assert_not_reached();
    return G_TYPE_INVALID;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_get_iter(GtkTreeModel* model,
                                          GtkTreeIter* iter,
                                          GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gint* indices;
  guint i;
  guint n;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  if(gtk_tree_path_get_depth(path) == 0) return FALSE;
  indices = gtk_tree_path_get_indices(path);
  n = indices[0];
  i = 0;
  for(item = priv-&gt;first_item; item != NULL &amp;&amp; i &lt; n; item = item-&gt;next)
    ++i;
  if(item == NULL) return FALSE;
  if(gtk_tree_path_get_depth(path) == 1)
  {
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  if(item-&gt;browser == NULL) return FALSE;
  inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
  for(n = 1; n &lt; (guint)gtk_tree_path_get_depth(path); ++ n)
  {
    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;
    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;
    if(browser_iter.node == item-&gt;missing)
      ++indices[n];
    for(i = 0; i &lt; (guint)indices[n]; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;
      if(browser_iter.node == item-&gt;missing)
        ++indices[n];
    }
  }
  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;
  return TRUE;
}
static void
inf_gtk_browser_store_tree_model_get_path_impl(InfGtkBrowserStore* store,
                                               InfGtkBrowserStoreItem* item,
                                               InfBrowserIter* iter,
                                               GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter cur_iter;
  InfGtkBrowserStoreItem* cur;
  gboolean result;
  guint n;
  cur_iter = *iter;
  if(inf_browser_get_parent(item-&gt;browser, &amp;cur_iter) == FALSE)
  {
    priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;
    gtk_tree_path_append_index(path, n);
  }
  else
  {
    inf_gtk_browser_store_tree_model_get_path_impl(
      store,
      item,
      &amp;cur_iter,
      path
    );
    result = inf_browser_get_child(item-&gt;browser, &amp;cur_iter);
    g_assert(result == TRUE);
    if(cur_iter.node == item-&gt;missing)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);
    }
    n = 0;
    while(cur_iter.node_id != iter-&gt;node_id)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);
      if(cur_iter.node == item-&gt;missing)
      {
        result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
        g_assert(result == TRUE);
      }
      ++n;
    }
    gtk_tree_path_append_index(path, n);
  }
}
static GtkTreePath*
inf_gtk_browser_store_tree_model_get_path(GtkTreeModel* model,
                                          GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  InfBrowserIter browser_iter;
  guint n;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  g_assert(iter-&gt;user_data != NULL);
  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  path = gtk_tree_path_new();
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;
  if(browser_iter.node != NULL)
  {
    g_assert(item-&gt;browser != NULL);
    inf_gtk_browser_store_tree_model_get_path_impl(
      INF_GTK_BROWSER_STORE(model),
      item,
      &amp;browser_iter,
      path
    );
  }
  else
  {
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;
    gtk_tree_path_append_index(path, n);
  }
  return path;
}
static void
inf_gtk_browser_store_tree_model_get_value(GtkTreeModel* model,
                                           GtkTreeIter* iter,
                                           gint column,
                                           GValue* value)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  InfBrowserStatus browser_status;
  GError* error;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );
  switch(column)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, item-&gt;info);
    break;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    g_value_init(value, G_TYPE_OBJECT);
    g_value_set_object(value, item-&gt;discovery);
    break;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    g_value_init(value, INF_TYPE_BROWSER);
    g_value_set_object(value, G_OBJECT(item-&gt;browser));
    break;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    g_assert(browser_iter.node == NULL);     g_value_init(value, INF_GTK_TYPE_BROWSER_MODEL_STATUS);
    g_value_set_enum(value, item-&gt;status);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    g_value_init(value, G_TYPE_STRING);
    if(browser_iter.node == NULL)
    {
      g_value_set_string(value, item-&gt;name);
    }
    else
    {
      g_value_set_string(
        value,
        inf_browser_get_node_name(INF_BROWSER(item-&gt;browser), &amp;browser_iter)
      );
    }
    break;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    if(browser_iter.node == NULL)
    {
      if(item-&gt;error != NULL)
      {
        error = item-&gt;error;
      }
      else if(item-&gt;browser != NULL)
      {
        g_object_get(
          G_OBJECT(item-&gt;browser),
          "status",
          &amp;browser_status,
          NULL
        );
        if(browser_status == INF_BROWSER_OPEN)
        {
          inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
          error = g_hash_table_lookup(
            item-&gt;node_errors,
            GUINT_TO_POINTER(browser_iter.node_id)
          );
        }
        else
        {
          error = NULL;
        }
      }
      else
      {
        error = NULL;
      }
    }
    else
    {
      g_assert(item-&gt;browser != NULL);
      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
      g_assert(browser_status == INF_BROWSER_OPEN);
      error = g_hash_table_lookup(
        item-&gt;node_errors,
        GUINT_TO_POINTER(browser_iter.node_id)
      );
    }
    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, error);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    g_assert(item-&gt;browser != NULL);
    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
    g_assert(browser_status == INF_BROWSER_OPEN);
    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    g_value_init(value, INF_TYPE_BROWSER_ITER);
    g_value_set_boxed(value, &amp;browser_iter);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_iter_next(GtkTreeModel* model,
                                           GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;
  if(browser_iter.node == NULL)
  {
    if(item-&gt;next == NULL)
      return FALSE;
    iter-&gt;user_data = item-&gt;next;
    return TRUE;
  }
  else
  {
    g_assert(browser_iter.node != item-&gt;missing);
    if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;
    if(browser_iter.node == item-&gt;missing)
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_iter_children(GtkTreeModel* model,
                                               GtkTreeIter* iter,
                                               GtkTreeIter* parent)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus browser_status;
  InfBrowserIter browser_iter;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  if(parent == NULL)
  {
    if(priv-&gt;first_item == NULL)
      return FALSE;
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = priv-&gt;first_item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);
    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    if(item-&gt;browser == NULL)
      return FALSE;
    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
    if(browser_status != INF_BROWSER_OPEN)
      return FALSE;
    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );
    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;
    if(!inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter))
      return FALSE;
    if(!inf_browser_get_explored(item-&gt;browser, &amp;browser_iter))
      return FALSE;
    if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
      return FALSE;
    if(browser_iter.node == item-&gt;missing)
      if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
        return FALSE;
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_iter_has_child(GtkTreeModel* model,
                                                GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  InfBrowserIter browser_iter;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  if(item-&gt;browser == NULL) return FALSE;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;
  g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
  if(status != INF_BROWSER_OPEN)
    return FALSE;
  if(browser_iter.node == NULL)
    inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );
  if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
    return FALSE;
  if(inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;
  if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;
  if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
    return FALSE;
  if(browser_iter.node == item-&gt;missing)
    if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
      return FALSE;
  return TRUE;
}
static gint
inf_gtk_browser_store_tree_model_iter_n_children(GtkTreeModel* model,
                                                 GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  gboolean result;
  guint n;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter == NULL || iter-&gt;stamp == priv-&gt;stamp);
  if(iter == NULL)
  {
    n = 0;
    for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      ++n;
    return n;
  }
  else
  {
    item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
    browser_iter.node = iter-&gt;user_data3;
    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );
    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return 0;
    n = 0;
    for(result = inf_browser_get_child(item-&gt;browser, &amp;browser_iter);
        result == TRUE;
        result = inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
    {
      if(browser_iter.node != item-&gt;missing)
        ++n;
    }
    return n;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_iter_nth_child(GtkTreeModel* model,
                                                GtkTreeIter* iter,
                                                GtkTreeIter* parent,
                                                gint n)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  guint i;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  if(parent == NULL)
  {
    cur = priv-&gt;first_item;
    if(cur == NULL) return FALSE;
    for(i = 0; i &lt; (guint)n; ++ i)
    {
      cur = cur-&gt;next;
      if(cur == NULL) return FALSE;
    }
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = cur;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);
    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );
    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;
    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;
    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;
    if(browser_iter.node == item-&gt;missing)
      ++n;
    for(i = 0; i &lt; (guint)n; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;
      if(browser_iter.node == item-&gt;missing)
        ++n;
    }
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}
static gboolean
inf_gtk_browser_store_tree_model_iter_parent(GtkTreeModel* model,
                                             GtkTreeIter* iter,
                                             GtkTreeIter* child)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gboolean result;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(child-&gt;stamp == priv-&gt;stamp);
  item = (InfGtkBrowserStoreItem*)child-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(child-&gt;user_data2);
  browser_iter.node = child-&gt;user_data3;
  if(browser_iter.node == NULL)
    return FALSE;
  g_assert(browser_iter.node != item-&gt;missing);
  result = inf_browser_get_parent(item-&gt;browser, &amp;browser_iter);
  g_assert(result == TRUE);
  g_assert(browser_iter.node != item-&gt;missing);
  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;
  if(browser_iter.node_id == 0)
    iter-&gt;user_data3 = NULL;
  return TRUE;
}
static void
inf_gtk_browser_store_browser_model_set_browser(InfGtkBrowserModel* model,
                                                GtkTreePath* path,
                                                GtkTreeIter* tree_iter,
                                                InfBrowser* old_browser,
                                                InfBrowser* new_browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter iter;
  guint n;
  gboolean had_children;
  InfBrowserStatus status;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  had_children = FALSE;
  item = (InfGtkBrowserStoreItem*)tree_iter-&gt;user_data;
  g_assert(tree_iter-&gt;user_data3 == NULL);
  if(item-&gt;browser != NULL)
  {
    g_assert(item-&gt;browser == old_browser);
    g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
    if(status == INF_BROWSER_OPEN)
    {
      inf_browser_get_root(item-&gt;browser, &amp;iter);
      if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
         inf_browser_get_child(item-&gt;browser, &amp;iter))
      {
        n = 1;
        while(inf_browser_get_next(item-&gt;browser, &amp;iter))
          ++ n;
        gtk_tree_path_append_index(path, n);
        for(; n &gt; 0; -- n)
        {
          had_children = TRUE;
          gtk_tree_path_prev(path);
          gtk_tree_model_row_deleted(GTK_TREE_MODEL(model), path);
        }
        gtk_tree_path_up(path);
      }
    }
    while(item-&gt;requests != NULL)
      inf_gtk_browser_store_item_request_remove(item, item-&gt;requests-&gt;data);
    g_hash_table_remove_all(item-&gt;node_errors);
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );
    g_object_unref(G_OBJECT(item-&gt;browser));
  }
  item-&gt;browser = NULL;
  if(had_children)
  {
    gtk_tree_model_row_has_child_toggled(
      GTK_TREE_MODEL(model),
      path,
      tree_iter
    );
  }
  item-&gt;browser = new_browser;
  if(new_browser != NULL)
  {
    g_object_ref(new_browser);
    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      "error",
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );
    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      "notify::status",
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );
    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "node-added",
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );
    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "node-removed",
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );
    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "begin-request::explore-node",
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );
    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      "begin-request::subscribe-session",
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );
  }
  if(item-&gt;browser == NULL &amp;&amp; item-&gt;info == NULL &amp;&amp;
     (item-&gt;error == NULL || item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR))
  {
    g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR);
    if(item-&gt;error != NULL)
    {
      g_error_free(item-&gt;error);
      item-&gt;error = NULL;
    }
    item-&gt;status = INF_GTK_BROWSER_MODEL_INVALID;
  }
  else if(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR)
  {
    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else
    {
      g_assert(item-&gt;info != NULL);
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
  }
  else
  {
    g_assert(item-&gt;error != NULL);
  }
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, tree_iter);
  if(item-&gt;browser != NULL &amp;&amp; item-&gt;status == INF_GTK_BROWSER_MODEL_CONNECTED)
  {
    inf_browser_get_root(item-&gt;browser, &amp;iter);
    if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
       inf_browser_get_child(item-&gt;browser, &amp;iter))
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(model),
        path,
        tree_iter
      );
    }
  }
}
static void
inf_gtk_browser_store_browser_model_resolve(InfGtkBrowserModel* model,
                                            InfDiscovery* discovery,
                                            InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  g_assert(INF_GTK_IS_BROWSER_STORE(model));
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_discovery_info(
    INF_GTK_BROWSER_STORE(model),
    info
  );
  g_assert(item != NULL);
  g_assert(
    item-&gt;status == INF_GTK_BROWSER_MODEL_DISCOVERED ||
    item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR
  );
  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);
    g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }
  else
  {
    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;
  path = gtk_tree_model_get_path(GTK_TREE_MODEL(model), &amp;tree_iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, &amp;tree_iter);
  gtk_tree_path_free(path);
  inf_discovery_resolve(
    discovery,
    info,
    inf_gtk_browser_store_resolv_complete_func,
    model
  );
}
static gboolean
inf_gtk_browser_store_browser_iter_to_tree_iter(InfGtkBrowserModel* model,
                                                InfBrowser* browser,
                                                const InfBrowserIter* iter,
                                                GtkTreeIter* tree_iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  g_assert(INF_GTK_IS_BROWSER_STORE(model));
  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_browser(
    INF_GTK_BROWSER_STORE(model),
    browser
  );
  if(item == NULL || (iter != NULL &amp;&amp; item-&gt;missing == iter-&gt;node))
    return FALSE;
  tree_iter-&gt;stamp = priv-&gt;stamp;
  tree_iter-&gt;user_data = item;
  if(iter != NULL &amp;&amp; iter-&gt;node_id != 0)
  {
    tree_iter-&gt;user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
    tree_iter-&gt;user_data3 = iter-&gt;node;
  }
  else
  {
    tree_iter-&gt;user_data2 = 0;
    tree_iter-&gt;user_data3 = NULL;
  }
  return TRUE;
}
static void
inf_gtk_browser_store_class_init(InfGtkBrowserStoreClass* browser_store_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(browser_store_class);
  object_class-&gt;dispose = inf_gtk_browser_store_dispose;
  object_class-&gt;set_property = inf_gtk_browser_store_set_property;
  object_class-&gt;get_property = inf_gtk_browser_store_get_property;
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object used for the created browsers to schedule timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_COMMUNICATION_MANAGER,
    g_param_spec_object(
      "communication-manager",
      "Communication manager", 
      "The communication manager used for browsing remote directories",
      INF_COMMUNICATION_TYPE_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}
static void
inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface)
{
  iface-&gt;get_flags = inf_gtk_browser_store_tree_model_get_flags;
  iface-&gt;get_n_columns = inf_gtk_browser_store_tree_model_get_n_columns;
  iface-&gt;get_column_type = inf_gtk_browser_store_tree_model_get_column_type;
  iface-&gt;get_iter = inf_gtk_browser_store_tree_model_get_iter;
  iface-&gt;get_path = inf_gtk_browser_store_tree_model_get_path;
  iface-&gt;get_value = inf_gtk_browser_store_tree_model_get_value;
  iface-&gt;iter_next = inf_gtk_browser_store_tree_model_iter_next;
  iface-&gt;iter_children = inf_gtk_browser_store_tree_model_iter_children;
  iface-&gt;iter_has_child = inf_gtk_browser_store_tree_model_iter_has_child;
  iface-&gt;iter_n_children = inf_gtk_browser_store_tree_model_iter_n_children;
  iface-&gt;iter_nth_child = inf_gtk_browser_store_tree_model_iter_nth_child;
  iface-&gt;iter_parent = inf_gtk_browser_store_tree_model_iter_parent;
}
static void
inf_gtk_browser_store_browser_model_iface_init(
  InfGtkBrowserModelInterface* iface)
{
  iface-&gt;set_browser = inf_gtk_browser_store_browser_model_set_browser;
  iface-&gt;resolve = inf_gtk_browser_store_browser_model_resolve;
  iface-&gt;browser_iter_to_tree_iter =
    inf_gtk_browser_store_browser_iter_to_tree_iter;
}
InfGtkBrowserStore*
inf_gtk_browser_store_new(InfIo* io,
                          InfCommunicationManager* comm_manager)
{
  GObject* object;
  object = g_object_new(
    INF_GTK_TYPE_BROWSER_STORE,
    "io", io,
    "communication-manager", comm_manager,
    NULL
  );
  return INF_GTK_BROWSER_STORE(object);
}
void
inf_gtk_browser_store_add_discovery(InfGtkBrowserStore* store,
                                    InfDiscovery* discovery)
{
  InfGtkBrowserStorePrivate* priv;
  GSList* discovered;
  GSList* item;
  InfDiscoveryInfo* info;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_DISCOVERY(discovery));
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  g_return_if_fail(g_slist_find(priv-&gt;discoveries, discovery) == NULL);
  g_object_ref(G_OBJECT(discovery));
  priv-&gt;discoveries = g_slist_prepend(priv-&gt;discoveries, discovery);
  g_signal_connect(
    G_OBJECT(discovery),
    "discovered",
    G_CALLBACK(inf_gtk_browser_store_discovered_cb),
    store
  );
  g_signal_connect(
    G_OBJECT(discovery),
    "undiscovered",
    G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
    store
  );
  discovered = inf_discovery_get_discovered(discovery, "_infinote._tcp");
  for(item = discovered; item != NULL; item = g_slist_next(item))
  {
    info = (InfDiscoveryInfo*)item-&gt;data;
    inf_gtk_browser_store_add_item_by_browser(
      store,
      discovery,
      info,
      NULL,
      inf_discovery_info_get_service_name(discovery, info)
    );
  }
  g_slist_free(discovered);
  inf_discovery_discover(discovery, "_infinote._tcp");
}
InfBrowser*
inf_gtk_browser_store_add_connection(InfGtkBrowserStore* store,
                                     InfXmlConnection* connection,
                                     const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  gchar* remote_id;
  g_return_val_if_fail(INF_GTK_IS_BROWSER_STORE(store), NULL);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  if(item == NULL)
  {
    if(name == NULL)
    {
      g_object_get(G_OBJECT(connection), "remote-id", &amp;remote_id, NULL);
      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        remote_id
      );
    }
    else
    {
      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        g_strdup(name)
      );
    }
  }
  return item-&gt;browser;
}
void
inf_gtk_browser_store_add_browser(InfGtkBrowserStore* store,
                                  InfBrowser* browser,
                                  const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));
  g_return_if_fail(name != NULL);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  if(item == NULL)
  {
    inf_gtk_browser_store_add_item_by_browser(
      store,
      NULL,
      NULL,
      browser,
      g_strdup(name)
    );
  }
}
void
inf_gtk_browser_store_remove_browser(InfGtkBrowserStore* store,
                                     InfBrowser* browser)
{
  InfGtkBrowserStoreItem* item;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_return_if_fail(item != NULL);
  inf_gtk_browser_store_remove_item (store, item);
}
void
inf_gtk_browser_store_remove_connection(InfGtkBrowserStore* store,
                                        InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);
  inf_gtk_browser_store_remove_item (store, item);
}
void
inf_gtk_browser_store_clear_connection_error(InfGtkBrowserStore* store,
                                             InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  GtkTreeIter iter;
  GtkTreePath* path;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);
  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);
    g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else if(item-&gt;info != NULL)
    {
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
    else
    {
      g_assert_not_reached();
    }
    iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
    iter.user_data = item;
    iter.user_data2 = GUINT_TO_POINTER(0);
    iter.user_data3 = NULL;
    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    gtk_tree_path_free (path);
  }
}
void
inf_gtk_browser_store_set_connection_name(InfGtkBrowserStore* store,
                                          InfXmlConnection* connection,
                                          const gchar* name)
{
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;
  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(name != NULL);
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);
  g_free (item-&gt;name);
  item-&gt;name = g_strdup(name);
  iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;
  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
