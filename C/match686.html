<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for bn_mp_mul_d.c &amp; sha1.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for bn_mp_mul_d.c &amp; sha1.c
      </h3>
<h1 align="center">
        12.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>bn_mp_mul_d.c (39.473682%)<th>sha1.c (7.246377%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-57)<td><a href="#" name="0">(259-275)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>bn_mp_mul_d.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "tommath.h"
2 #ifdef BN_MP_MUL_D_C
3 int
4 mp_mul_d (mp_int * a, mp_digit b, mp_int * c)
5 {
6   mp_digit u, *tmpa, *tmpc;
7   mp_word  r;
8   int      ix, res, olduse;
9   if (c-&gt;alloc &lt; a-&gt;used + 1) {
10 <a name="0"></a>    if ((res = mp_grow (c, a-&gt;used + 1)) != MP_OKAY) {
11       return res;
12     }
13 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
14   olduse = c-&gt;used;
15   c-&gt;sign = a-&gt;sign;
16   tmpa = a-&gt;dp;
17   tmpc = c-&gt;dp;
18   u = 0;
19   for (ix = 0; ix &lt; a-&gt;used; ix++) {
20     r       = ((mp_word) u) + ((mp_word)*tmpa++) * ((mp_word)b);
21     *tmpc++ = (mp_digit) (r &amp; ((mp_word) MP_MASK));
22     u       = (mp_digit) (r &gt;&gt; ((mp_word) DIGIT_BIT));</b></font>
23   }
24   *tmpc++ = u;
25   ++ix;
26   while (ix++ &lt; olduse) {
27      *tmpc++ = 0;
28   }
29   c-&gt;used = a-&gt;used + 1;
30   mp_clamp(c);
31   return MP_OKAY;
32 }
33 #endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>sha1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;bncsutil/sha1.h&gt;
2 #define SHA1CircularShift(bits,word) \
3                 (((word) &lt;&lt; (bits)) | ((word) &gt;&gt; (32-(bits))))
4 void SHA1PadMessage(SHA1Context *);
5 void SHA1ProcessMessageBlock(SHA1Context *);
6 int SHA1Reset(SHA1Context *context)
7 {
8     if (!context)
9     {
10         return shaNull;
11     }
12     context-&gt;Length_Low             = 0;
13     context-&gt;Length_High            = 0;
14     context-&gt;Message_Block_Index    = 0;
15     context-&gt;Intermediate_Hash[0]   = 0x67452301;
16     context-&gt;Intermediate_Hash[1]   = 0xEFCDAB89;
17     context-&gt;Intermediate_Hash[2]   = 0x98BADCFE;
18     context-&gt;Intermediate_Hash[3]   = 0x10325476;
19     context-&gt;Intermediate_Hash[4]   = 0xC3D2E1F0;
20     context-&gt;Computed   = 0;
21     context-&gt;Corrupted  = 0;
22     return shaSuccess;
23 }
24 int SHA1Result( SHA1Context *context,
25                 uint8_t Message_Digest[SHA1HashSize])
26 {
27     int i;
28     if (!context || !Message_Digest)
29     {
30         return shaNull;
31     }
32     if (context-&gt;Corrupted)
33     {
34         return context-&gt;Corrupted;
35     }
36     if (!context-&gt;Computed)
37     {
38         SHA1PadMessage(context);
39         for(i=0; i&lt;64; ++i)
40         {
41             context-&gt;Message_Block[i] = 0;
42         }
43         context-&gt;Length_Low = 0;            context-&gt;Length_High = 0;
44         context-&gt;Computed = 1;
45     }
46     for(i = 0; i &lt; SHA1HashSize; ++i)
47     {
48         Message_Digest[i] = context-&gt;Intermediate_Hash[i&gt;&gt;2]
49                             &gt;&gt; 8 * ( 3 - ( i &amp; 0x03 ) );
50     }
51     return shaSuccess;
52 }
53 int SHA1Input(    SHA1Context    *context,
54                   const uint8_t  *message_array,
55                   unsigned       length)
56 {
57     if (!length)
58     {
59         return shaSuccess;
60     }
61     if (!context || !message_array)
62     {
63         return shaNull;
64     }
65     if (context-&gt;Computed)
66     {
67         context-&gt;Corrupted = shaStateError;
68         return shaStateError;
69     }
70     if (context-&gt;Corrupted)
71     {
72          return context-&gt;Corrupted;
73     }
74     while(length-- &amp;&amp; !context-&gt;Corrupted)
75     {
76     context-&gt;Message_Block[context-&gt;Message_Block_Index++] =
77                     (*message_array &amp; 0xFF);
78     context-&gt;Length_Low += 8;
79     if (context-&gt;Length_Low == 0)
80     {
81         context-&gt;Length_High++;
82         if (context-&gt;Length_High == 0)
83         {
84             context-&gt;Corrupted = 1;
85         }
86     }
87     if (context-&gt;Message_Block_Index == 64)
88     {
89         SHA1ProcessMessageBlock(context);
90     }
91     message_array++;
92     }
93     return shaSuccess;
94 }
95 void SHA1ProcessMessageBlock(SHA1Context *context)
96 {
97     const uint32_t K[] =    {                                   0x5A827999,
98                             0x6ED9EBA1,
99                             0x8F1BBCDC,
100                             0xCA62C1D6
101                             };
102     int           t;                     uint32_t      temp;                  uint32_t      W[80];                 uint32_t      A, B, C, D, E;     
103     for(t = 0; t &lt; 16; t++)
104     {
105         W[t] = context-&gt;Message_Block[t * 4] &lt;&lt; 24;
106         W[t] |= context-&gt;Message_Block[t * 4 + 1] &lt;&lt; 16;
107         W[t] |= context-&gt;Message_Block[t * 4 + 2] &lt;&lt; 8;
108         W[t] |= context-&gt;Message_Block[t * 4 + 3];
109     }
110 <a name="0"></a>    for(t = 16; t &lt; 80; t++)
111     {
112        W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
113 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    }
114     A = context-&gt;Intermediate_Hash[0];
115     B = context-&gt;Intermediate_Hash[1];
116     C = context-&gt;Intermediate_Hash[2];
117     D = context-&gt;Intermediate_Hash[3];
118     E = context-&gt;Intermediate_Hash[4];
119     for(t = 0; t &lt; 20; t++)
120     {
121         temp =  SHA1CircularShift(5,A) +
122                 ((B &amp; C) | ((~B) &amp; D)) + E + W[t] + K[0];
123         E = D;
124         D = C;
125         C = SHA1CircularShift(30,B);
126         B = A;</b></font>
127         A = temp;
128     }
129     for(t = 20; t &lt; 40; t++)
130     {
131         temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
132         E = D;
133         D = C;
134         C = SHA1CircularShift(30,B);
135         B = A;
136         A = temp;
137     }
138     for(t = 40; t &lt; 60; t++)
139     {
140         temp = SHA1CircularShift(5,A) +
141                ((B &amp; C) | (B &amp; D) | (C &amp; D)) + E + W[t] + K[2];
142         E = D;
143         D = C;
144         C = SHA1CircularShift(30,B);
145         B = A;
146         A = temp;
147     }
148     for(t = 60; t &lt; 80; t++)
149     {
150         temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
151         E = D;
152         D = C;
153         C = SHA1CircularShift(30,B);
154         B = A;
155         A = temp;
156     }
157     context-&gt;Intermediate_Hash[0] += A;
158     context-&gt;Intermediate_Hash[1] += B;
159     context-&gt;Intermediate_Hash[2] += C;
160     context-&gt;Intermediate_Hash[3] += D;
161     context-&gt;Intermediate_Hash[4] += E;
162     context-&gt;Message_Block_Index = 0;
163 }
164 void SHA1PadMessage(SHA1Context *context)
165 {
166     if (context-&gt;Message_Block_Index &gt; 55)
167     {
168         context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0x80;
169         while(context-&gt;Message_Block_Index &lt; 64)
170         {
171             context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
172         }
173         SHA1ProcessMessageBlock(context);
174         while(context-&gt;Message_Block_Index &lt; 56)
175         {
176             context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
177         }
178     }
179     else
180     {
181         context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0x80;
182         while(context-&gt;Message_Block_Index &lt; 56)
183         {
184             context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
185         }
186     }
187     context-&gt;Message_Block[56] = context-&gt;Length_High &gt;&gt; 24;
188     context-&gt;Message_Block[57] = context-&gt;Length_High &gt;&gt; 16;
189     context-&gt;Message_Block[58] = context-&gt;Length_High &gt;&gt; 8;
190     context-&gt;Message_Block[59] = context-&gt;Length_High;
191     context-&gt;Message_Block[60] = context-&gt;Length_Low &gt;&gt; 24;
192     context-&gt;Message_Block[61] = context-&gt;Length_Low &gt;&gt; 16;
193     context-&gt;Message_Block[62] = context-&gt;Length_Low &gt;&gt; 8;
194     context-&gt;Message_Block[63] = context-&gt;Length_Low;
195     SHA1ProcessMessageBlock(context);
196 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
