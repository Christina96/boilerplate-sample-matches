<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for bn_mp_mul_d.c & sha1.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for bn_mp_mul_d.c & sha1.c
      </h3>
      <h1 align="center">
        12.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>bn_mp_mul_d.c (39.473682%)<TH>sha1.c (7.246377%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match686-0.html#0',2,'match686-1.html#0',3)" NAME="0">(31-57)<TD><A HREF="javascript:ZweiFrames('match686-0.html#0',2,'match686-1.html#0',3)" NAME="0">(259-275)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>bn_mp_mul_d.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &quot;tommath.h&quot;
#ifdef BN_MP_MUL_D_C
/* LibTomMath, multiple-precision integer library -- Tom St Denis
 *
 * LibTomMath is a library that provides multiple-precision
 * integer arithmetic as well as number theoretic functionality.
 *
 * The library was designed directly after the MPI library by
 * Michael Fromberger but has been written from scratch with
 * additional optimizations in place.
 *
 * The library is free for all purposes without any express
 * guarantee it works.
 *
 * Tom St Denis, tomstdenis@gmail.com, http://libtom.org
 */

/* multiply by a digit */
int
mp_mul_d (mp_int * a, mp_digit b, mp_int * c)
{
  mp_digit u, *tmpa, *tmpc;
  mp_word  r;
  int      ix, res, olduse;

  /* make sure c is big enough to hold a*b */
  if (c-&gt;alloc &lt; a-&gt;used + 1) {
<A NAME="0"></A>    if ((res = mp_grow (c, a-&gt;used + 1)) != MP_OKAY) {
      return res;
    }
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match686-1.html#0',3,'match686-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  }

  /* get the original destinations used count */
  olduse = c-&gt;used;

  /* set the sign */
  c-&gt;sign = a-&gt;sign;

  /* alias for a-&gt;dp [source] */
  tmpa = a-&gt;dp;

  /* alias for c-&gt;dp [dest] */
  tmpc = c-&gt;dp;

  /* zero carry */
  u = 0;

  /* compute columns */
  for (ix = 0; ix &lt; a-&gt;used; ix++) {
    /* compute product and carry sum for this term */
    r       = ((mp_word) u) + ((mp_word)*tmpa++) * ((mp_word)b);

    /* mask off higher bits to get a single digit */
    *tmpc++ = (mp_digit) (r &amp; ((mp_word) MP_MASK));

    /* send carry into next iteration */
    u       = (mp_digit) (r &gt;&gt; ((mp_word) DIGIT_BIT));</B></FONT>
  }

  /* store final carry [if any] and increment ix offset  */
  *tmpc++ = u;
  ++ix;

  /* now zero digits above the top */
  while (ix++ &lt; olduse) {
     *tmpc++ = 0;
  }

  /* set used count */
  c-&gt;used = a-&gt;used + 1;
  mp_clamp(c);

  return MP_OKAY;
}
#endif

/* $Source: /cvs/libtom/libtommath/bn_mp_mul_d.c,v $ */
/* $Revision: 1.4 $ */
/* $Date: 2006/12/28 01:25:13 $ */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>sha1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 *  sha1.c
 *
 *  Description:
 *      This file implements the Secure Hashing Algorithm 1 as
 *      defined in FIPS PUB 180-1 published April 17, 1995.
 *
 *      The SHA-1, produces a 160-bit message digest for a given
 *      data stream.  It should take about 2**n steps to find a
 *      message with the same digest as a given message and
 *      2**(n/2) to find any two messages with the same digest,
 *      when n is the digest size in bits.  Therefore, this
 *      algorithm can serve as a means of providing a
 *      &quot;fingerprint&quot; for a message.
 *
 *  Portability Issues:
 *      SHA-1 is defined in terms of 32-bit &quot;words&quot;.  This code
 *      uses &lt;stdint.h&gt; (included via &quot;sha1.h&quot; to define 32 and 8
 *      bit unsigned integer types.  If your C compiler does not
 *      support 32 bit unsigned integers, this code is not
 *      appropriate.
 *
 *  Caveats:
 *      SHA-1 is designed to work with messages less than 2^64 bits
 *      long.  Although SHA-1 allows a message digest to be generated
 *      for messages of any number of bits less than 2^64, this
 *      implementation only works with messages with a length that is
 *      a multiple of the size of an 8-bit character.
 *
 */

#include &lt;bncsutil/sha1.h&gt;

/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word) \
                (((word) &lt;&lt; (bits)) | ((word) &gt;&gt; (32-(bits))))

/* Local Function Prototyptes */
void SHA1PadMessage(SHA1Context *);
void SHA1ProcessMessageBlock(SHA1Context *);

/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Reset(SHA1Context *context)
{
    if (!context)
    {
        return shaNull;
    }

    context-&gt;Length_Low             = 0;
    context-&gt;Length_High            = 0;
    context-&gt;Message_Block_Index    = 0;

    context-&gt;Intermediate_Hash[0]   = 0x67452301;
    context-&gt;Intermediate_Hash[1]   = 0xEFCDAB89;
    context-&gt;Intermediate_Hash[2]   = 0x98BADCFE;
    context-&gt;Intermediate_Hash[3]   = 0x10325476;
    context-&gt;Intermediate_Hash[4]   = 0xC3D2E1F0;

    context-&gt;Computed   = 0;
    context-&gt;Corrupted  = 0;

    return shaSuccess;
}

/*
 *  SHA1Result
 *
 *  Description:
 *      This function will return the 160-bit message digest into the
 *      Message_Digest array  provided by the caller.
 *      NOTE: The first octet of hash is stored in the 0th element,
 *            the last octet of hash in the 19th element.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to use to calculate the SHA-1 hash.
 *      Message_Digest: [out]
 *          Where the digest is returned.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Result( SHA1Context *context,
                uint8_t Message_Digest[SHA1HashSize])
{
    int i;

    if (!context || !Message_Digest)
    {
        return shaNull;
    }

    if (context-&gt;Corrupted)
    {
        return context-&gt;Corrupted;
    }

    if (!context-&gt;Computed)
    {
        SHA1PadMessage(context);
        for(i=0; i&lt;64; ++i)
        {
            /* message may be sensitive, clear it out */
            context-&gt;Message_Block[i] = 0;
        }
        context-&gt;Length_Low = 0;    /* and clear length */
        context-&gt;Length_High = 0;
        context-&gt;Computed = 1;

    }

    for(i = 0; i &lt; SHA1HashSize; ++i)
    {
        Message_Digest[i] = context-&gt;Intermediate_Hash[i&gt;&gt;2]
                            &gt;&gt; 8 * ( 3 - ( i &amp; 0x03 ) );
    }

    return shaSuccess;
}

/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update
 *      message_array: [in]
 *          An array of characters representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Input(    SHA1Context    *context,
                  const uint8_t  *message_array,
                  unsigned       length)
{
    if (!length)
    {
        return shaSuccess;
    }

    if (!context || !message_array)
    {
        return shaNull;
    }

    if (context-&gt;Computed)
    {
        context-&gt;Corrupted = shaStateError;

        return shaStateError;
    }

    if (context-&gt;Corrupted)
    {
         return context-&gt;Corrupted;
    }
    while(length-- &amp;&amp; !context-&gt;Corrupted)
    {
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] =
                    (*message_array &amp; 0xFF);

    context-&gt;Length_Low += 8;
    if (context-&gt;Length_Low == 0)
    {
        context-&gt;Length_High++;
        if (context-&gt;Length_High == 0)
        {
            /* Message is too long */
            context-&gt;Corrupted = 1;
        }
    }

    if (context-&gt;Message_Block_Index == 64)
    {
        SHA1ProcessMessageBlock(context);
    }

    message_array++;
    }

    return shaSuccess;
}

/*
 *  SHA1ProcessMessageBlock
 *
 *  Description:
 *      This function will process the next 512 bits of the message
 *      stored in the Message_Block array.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Comments:

 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the
 *      names used in the publication.
 *
 *
 */
void SHA1ProcessMessageBlock(SHA1Context *context)
{
    const uint32_t K[] =    {       /* Constants defined in SHA-1   */
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
                            };
    int           t;                 /* Loop counter                */
    uint32_t      temp;              /* Temporary word value        */
    uint32_t      W[80];             /* Word sequence               */
    uint32_t      A, B, C, D, E;     /* Word buffers                */

    /*
     *  Initialize the first 16 words in the array W
     */
    for(t = 0; t &lt; 16; t++)
    {
        W[t] = context-&gt;Message_Block[t * 4] &lt;&lt; 24;
        W[t] |= context-&gt;Message_Block[t * 4 + 1] &lt;&lt; 16;
        W[t] |= context-&gt;Message_Block[t * 4 + 2] &lt;&lt; 8;
        W[t] |= context-&gt;Message_Block[t * 4 + 3];
    }

<A NAME="0"></A>    for(t = 16; t &lt; 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match686-0.html#0',2,'match686-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    }

    A = context-&gt;Intermediate_Hash[0];
    B = context-&gt;Intermediate_Hash[1];
    C = context-&gt;Intermediate_Hash[2];
    D = context-&gt;Intermediate_Hash[3];
    E = context-&gt;Intermediate_Hash[4];

    for(t = 0; t &lt; 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B &amp; C) | ((~B) &amp; D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);

        B = A;</B></FONT>
        A = temp;
    }

    for(t = 20; t &lt; 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    for(t = 40; t &lt; 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B &amp; C) | (B &amp; D) | (C &amp; D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    for(t = 60; t &lt; 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }

    context-&gt;Intermediate_Hash[0] += A;
    context-&gt;Intermediate_Hash[1] += B;
    context-&gt;Intermediate_Hash[2] += C;
    context-&gt;Intermediate_Hash[3] += D;
    context-&gt;Intermediate_Hash[4] += E;

    context-&gt;Message_Block_Index = 0;
}

/*
 *  SHA1PadMessage
 *

 *  Description:
 *      According to the standard, the message must be padded to an even
 *      512 bits.  The first padding bit must be a '1'.  The last 64
 *      bits represent the length of the original message.  All bits in
 *      between should be 0.  This function will pad the message
 *      according to those rules by filling the Message_Block array
 *      accordingly.  It will also call the ProcessMessageBlock function
 *      provided appropriately.  When it returns, it can be assumed that
 *      the message digest has been computed.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to pad
 *      ProcessMessageBlock: [in]
 *          The appropriate SHA*ProcessMessageBlock function
 *  Returns:
 *      Nothing.
 *
 */

void SHA1PadMessage(SHA1Context *context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context-&gt;Message_Block_Index &gt; 55)
    {
        context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0x80;
        while(context-&gt;Message_Block_Index &lt; 64)
        {
            context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        }

        SHA1ProcessMessageBlock(context);

        while(context-&gt;Message_Block_Index &lt; 56)
        {
            context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        }
    }
    else
    {
        context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0x80;
        while(context-&gt;Message_Block_Index &lt; 56)
        {

            context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        }
    }

    /*
     *  Store the message length as the last 8 octets
     */
    context-&gt;Message_Block[56] = context-&gt;Length_High &gt;&gt; 24;
    context-&gt;Message_Block[57] = context-&gt;Length_High &gt;&gt; 16;
    context-&gt;Message_Block[58] = context-&gt;Length_High &gt;&gt; 8;
    context-&gt;Message_Block[59] = context-&gt;Length_High;
    context-&gt;Message_Block[60] = context-&gt;Length_Low &gt;&gt; 24;
    context-&gt;Message_Block[61] = context-&gt;Length_Low &gt;&gt; 16;
    context-&gt;Message_Block[62] = context-&gt;Length_Low &gt;&gt; 8;
    context-&gt;Message_Block[63] = context-&gt;Length_Low;

    SHA1ProcessMessageBlock(context);
}
</PRE>
</div>
  </div>
</body>
</html>
