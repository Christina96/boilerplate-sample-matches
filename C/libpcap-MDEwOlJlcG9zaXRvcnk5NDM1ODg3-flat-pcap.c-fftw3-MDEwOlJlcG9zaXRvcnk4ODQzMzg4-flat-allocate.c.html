
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap-types.h>
5  #ifndef _WIN32
6  #include <sys/param.h>
7  #ifndef MSDOS
8  #include <sys/file.h>
9  #endif
10  #include <sys/ioctl.h>
11  #include <sys/socket.h>
12  #ifdef HAVE_SYS_SOCKIO_H
13  #include <sys/sockio.h>
14  #endif
15  struct mbuf;		&bsol;* Squelch compiler warnings on some platforms for */
16  struct rtentry;		&bsol;* declarations in <net/if.h> */
17  #include <net/if.h>
18  #include <netinet/in.h>
19  #endif &bsol;* _WIN32 */
20  #include <stdio.h>
21  #include <stdlib.h>
22  #include <string.h>
23  #if !defined(_MSC_VER) && !defined(__BORLANDC__) && !defined(__MINGW32__)
24  #include <unistd.h>
25  #endif
26  #include <fcntl.h>
27  #include <errno.h>
28  #include <limits.h>
29  #include "diag-control.h"
30  #include "thread-local.h"
31  #ifdef HAVE_OS_PROTO_H
32  #include "os-proto.h"
33  #endif
34  #ifdef MSDOS
35  #include "pcap-dos.h"
36  #endif
37  #include "pcap-int.h"
38  #include "optimize.h"
39  #ifdef HAVE_DAG_API
40  #include "pcap-dag.h"
41  #endif &bsol;* HAVE_DAG_API */
42  #ifdef HAVE_SEPTEL_API
43  #include "pcap-septel.h"
44  #endif &bsol;* HAVE_SEPTEL_API */
45  #ifdef HAVE_SNF_API
46  #include "pcap-snf.h"
47  #endif &bsol;* HAVE_SNF_API */
48  #ifdef HAVE_TC_API
49  #include "pcap-tc.h"
50  #endif &bsol;* HAVE_TC_API */
51  #ifdef PCAP_SUPPORT_LINUX_USBMON
52  #include "pcap-usb-linux.h"
53  #endif
54  #ifdef PCAP_SUPPORT_BT
55  #include "pcap-bt-linux.h"
56  #endif
57  #ifdef PCAP_SUPPORT_BT_MONITOR
58  #include "pcap-bt-monitor-linux.h"
59  #endif
60  #ifdef PCAP_SUPPORT_NETFILTER
61  #include "pcap-netfilter-linux.h"
62  #endif
63  #ifdef PCAP_SUPPORT_NETMAP
64  #include "pcap-netmap.h"
65  #endif
66  #ifdef PCAP_SUPPORT_DBUS
67  #include "pcap-dbus.h"
68  #endif
69  #ifdef PCAP_SUPPORT_RDMASNIFF
70  #include "pcap-rdmasniff.h"
71  #endif
72  #ifdef PCAP_SUPPORT_DPDK
73  #include "pcap-dpdk.h"
74  #endif
75  #ifdef HAVE_AIRPCAP_API
76  #include "pcap-airpcap.h"
77  #endif
78  #ifdef _WIN32
79  static void
80  internal_wsockfini(void)
81  {
82  	WSACleanup();
83  }
84  static int
85  internal_wsockinit(char *errbuf)
86  {
87  	WORD wVersionRequested;
88  	WSADATA wsaData;
89  	static int err = -1;
90  	static int done = 0;
91  	int status;
92  	if (done)
93  		return (err);
94  	wVersionRequested = MAKEWORD(2, 2);
95  	status = WSAStartup(wVersionRequested, &wsaData);
96  	done = 1;
97  	if (status != 0) {
98  		if (errbuf != NULL) {
99  			pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
100  			    status, "WSAStartup() failed");
101  		}
102  		return (err);
103  	}
104  	atexit(internal_wsockfini);
105  	err = 0;
106  	return (err);
107  }
108  int
109  wsockinit(void)
110  {
111  	return (internal_wsockinit(NULL));
112  }
113  int
114  pcap_wsockinit(void)
115  {
116  	return (internal_wsockinit(NULL));
117  }
118  #endif &bsol;* _WIN32 */
119  int pcap_new_api;		&bsol;* pcap_lookupdev() always fails */
120  int pcap_utf_8_mode;		&bsol;* Strings should be in UTF-8. */
121  int pcap_mmap_32bit;		&bsol;* Map packet buffers with 32-bit addresses. */
122  int
123  pcap_init(unsigned int opts, char *errbuf)
124  {
125  	static int initialized;
126  	switch (opts) {
127  	case PCAP_CHAR_ENC_LOCAL:
128  		if (initialized) {
129  			if (pcap_utf_8_mode) {
130  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
131  				    "Multiple pcap_init calls with different character encodings");
132  				return (PCAP_ERROR);
133  			}
134  		}
135  		break;
136  	case PCAP_CHAR_ENC_UTF_8:
137  		if (initialized) {
138  			if (!pcap_utf_8_mode) {
139  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
140  				    "Multiple pcap_init calls with different character encodings");
141  				return (PCAP_ERROR);
142  			}
143  		}
144  		pcap_utf_8_mode = 1;
145  		break;
146  	case PCAP_MMAP_32BIT:
147  		pcap_mmap_32bit = 1;
148  		break;
149  	default:
150  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Unknown options specified");
151  		return (PCAP_ERROR);
152  	}
153  	pcap_fmt_set_encoding(opts);
154  	if (initialized) {
155  		return (0);
156  	}
157  #ifdef _WIN32
158  	if (internal_wsockinit(errbuf) == -1) {
159  		return (PCAP_ERROR);
160  	}
161  #endif
162  	initialized = 1;
163  	pcap_new_api = 1;
164  	return (0);
165  }
166  PCAP_API char pcap_version[];
167  PCAP_API_DEF char pcap_version[] = PACKAGE_VERSION;
168  static void
169  pcap_set_not_initialized_message(pcap_t *pcap)
170  {
171  	if (pcap->activated) {
172  		(void)snprintf(pcap->errbuf, sizeof(pcap->errbuf),
173  		    "This operation isn't properly handled by that device");
174  		return;
175  	}
176  	(void)snprintf(pcap->errbuf, sizeof(pcap->errbuf),
177  	    "This handle hasn't been activated yet");
178  }
179  static int
180  pcap_read_not_initialized(pcap_t *pcap, int cnt _U_, pcap_handler callback _U_,
181      u_char *user _U_)
182  {
183  	pcap_set_not_initialized_message(pcap);
184  	return (PCAP_ERROR_NOT_ACTIVATED);
185  }
186  static int
187  pcap_inject_not_initialized(pcap_t *pcap, const void * buf _U_, int size _U_)
188  {
189  	pcap_set_not_initialized_message(pcap);
190  	return (PCAP_ERROR_NOT_ACTIVATED);
191  }
192  static int
193  pcap_setfilter_not_initialized(pcap_t *pcap, struct bpf_program *fp _U_)
194  {
195  	pcap_set_not_initialized_message(pcap);
196  	return (PCAP_ERROR_NOT_ACTIVATED);
197  }
198  static int
199  pcap_setdirection_not_initialized(pcap_t *pcap, pcap_direction_t d _U_)
200  {
201  	pcap_set_not_initialized_message(pcap);
202  	return (PCAP_ERROR_NOT_ACTIVATED);
203  }
204  static int
205  pcap_set_datalink_not_initialized(pcap_t *pcap, int dlt _U_)
206  {
207  	pcap_set_not_initialized_message(pcap);
208  	return (PCAP_ERROR_NOT_ACTIVATED);
209  }
210  static int
211  pcap_getnonblock_not_initialized(pcap_t *pcap)
212  {
213  	pcap_set_not_initialized_message(pcap);
214  	return (PCAP_ERROR_NOT_ACTIVATED);
215  }
216  static int
217  pcap_stats_not_initialized(pcap_t *pcap, struct pcap_stat *ps _U_)
218  {
219  	pcap_set_not_initialized_message(pcap);
220  	return (PCAP_ERROR_NOT_ACTIVATED);
221  }
222  #ifdef _WIN32
223  static struct pcap_stat *
224  pcap_stats_ex_not_initialized(pcap_t *pcap, int *pcap_stat_size _U_)
225  {
226  	pcap_set_not_initialized_message(pcap);
227  	return (NULL);
228  }
229  static int
230  pcap_setbuff_not_initialized(pcap_t *pcap, int dim _U_)
231  {
232  	pcap_set_not_initialized_message(pcap);
233  	return (PCAP_ERROR_NOT_ACTIVATED);
234  }
235  static int
236  pcap_setmode_not_initialized(pcap_t *pcap, int mode _U_)
237  {
238  	pcap_set_not_initialized_message(pcap);
239  	return (PCAP_ERROR_NOT_ACTIVATED);
240  }
241  static int
242  pcap_setmintocopy_not_initialized(pcap_t *pcap, int size _U_)
243  {
244  	pcap_set_not_initialized_message(pcap);
245  	return (PCAP_ERROR_NOT_ACTIVATED);
246  }
247  static HANDLE
248  pcap_getevent_not_initialized(pcap_t *pcap)
249  {
250  	pcap_set_not_initialized_message(pcap);
251  	return (INVALID_HANDLE_VALUE);
252  }
253  static int
254  pcap_oid_get_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,
255      void *data _U_, size_t *lenp _U_)
256  {
257  	pcap_set_not_initialized_message(pcap);
258  	return (PCAP_ERROR_NOT_ACTIVATED);
259  }
260  static int
261  pcap_oid_set_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,
262      const void *data _U_, size_t *lenp _U_)
263  {
264  	pcap_set_not_initialized_message(pcap);
265  	return (PCAP_ERROR_NOT_ACTIVATED);
266  }
267  static u_int
268  pcap_sendqueue_transmit_not_initialized(pcap_t *pcap, pcap_send_queue* queue _U_,
269      int sync _U_)
270  {
271  	pcap_set_not_initialized_message(pcap);
272  	return (0);
273  }
274  static int
275  pcap_setuserbuffer_not_initialized(pcap_t *pcap, int size _U_)
276  {
277  	pcap_set_not_initialized_message(pcap);
278  	return (PCAP_ERROR_NOT_ACTIVATED);
279  }
280  static int
281  pcap_live_dump_not_initialized(pcap_t *pcap, char *filename _U_, int maxsize _U_,
282      int maxpacks _U_)
283  {
284  	pcap_set_not_initialized_message(pcap);
285  	return (PCAP_ERROR_NOT_ACTIVATED);
286  }
287  static int
288  pcap_live_dump_ended_not_initialized(pcap_t *pcap, int sync _U_)
289  {
290  	pcap_set_not_initialized_message(pcap);
291  	return (PCAP_ERROR_NOT_ACTIVATED);
292  }
293  static PAirpcapHandle
294  pcap_get_airpcap_handle_not_initialized(pcap_t *pcap)
295  {
296  	pcap_set_not_initialized_message(pcap);
297  	return (NULL);
298  }
299  #endif
300  int
301  pcap_can_set_rfmon(pcap_t *p)
302  {
303  	return (p->can_set_rfmon_op(p));
304  }
305  static int
306  pcap_cant_set_rfmon(pcap_t *p _U_)
307  {
308  	return (0);
309  }
310  int
311  pcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp)
312  {
313  	if (p->tstamp_type_count == 0) {
314  		*tstamp_typesp = (int*)malloc(sizeof(**tstamp_typesp));
315  		if (*tstamp_typesp == NULL) {
316  			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
317  			    errno, "malloc");
318  			return (PCAP_ERROR);
319  		}
320  		**tstamp_typesp = PCAP_TSTAMP_HOST;
321  		return (1);
322  	} else {
323  		*tstamp_typesp = (int*)calloc(sizeof(**tstamp_typesp),
324  		    p->tstamp_type_count);
325  		if (*tstamp_typesp == NULL) {
326  			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
327  			    errno, "malloc");
328  			return (PCAP_ERROR);
329  		}
330  		(void)memcpy(*tstamp_typesp, p->tstamp_type_list,
331  		    sizeof(**tstamp_typesp) * p->tstamp_type_count);
332  		return (p->tstamp_type_count);
333  	}
334  }
335  void
336  pcap_free_tstamp_types(int *tstamp_type_list)
337  {
338  	free(tstamp_type_list);
339  }
340  void
341  pcap_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)
342  {
343  	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
344  	*sp->hdr = *h;
345  	*sp->pkt = pkt;
346  }
347  const u_char *
348  pcap_next(pcap_t *p, struct pcap_pkthdr *h)
349  {
350  	struct oneshot_userdata s;
351  	const u_char *pkt;
352  	s.hdr = h;
353  	s.pkt = &pkt;
354  	s.pd = p;
355  	if (pcap_dispatch(p, 1, p->oneshot_callback, (u_char *)&s) <= 0)
356  		return (0);
357  	return (pkt);
358  }
359  int
360  pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,
361      const u_char **pkt_data)
362  {
363  	struct oneshot_userdata s;
364  	s.hdr = &p->pcap_header;
365  	s.pkt = pkt_data;
366  	s.pd = p;
367  	*pkt_header= &p->pcap_header;
368  	if (p->rfile != NULL) {
369  		int status;
370  		status = pcap_offline_read(p, 1, p->oneshot_callback,
371  		    (u_char *)&s);
372  		if (status == 0)
373  			return (-2);
374  		else
375  			return (status);
376  	}
377  	return (p->read_op(p, 1, p->oneshot_callback, (u_char *)&s));
378  }
379  struct pcap_if_list {
380  	pcap_if_t *beginning;
381  };
382  static struct capture_source_type {
383  	int (*findalldevs_op)(pcap_if_list_t *, char *);
384  	pcap_t *(*create_op)(const char *, char *, int *);
385  } capture_source_types[] = {
386  #ifdef HAVE_DAG_API
387  	{ dag_findalldevs, dag_create },
388  #endif
389  #ifdef HAVE_SEPTEL_API
390  	{ septel_findalldevs, septel_create },
391  #endif
392  #ifdef HAVE_SNF_API
393  	{ snf_findalldevs, snf_create },
394  #endif
395  #ifdef HAVE_TC_API
396  	{ TcFindAllDevs, TcCreate },
397  #endif
398  #ifdef PCAP_SUPPORT_BT
399  	{ bt_findalldevs, bt_create },
400  #endif
401  #ifdef PCAP_SUPPORT_BT_MONITOR
402  	{ bt_monitor_findalldevs, bt_monitor_create },
403  #endif
404  #ifdef PCAP_SUPPORT_LINUX_USBMON
405  	{ usb_findalldevs, usb_create },
406  #endif
407  #ifdef PCAP_SUPPORT_NETFILTER
408  	{ netfilter_findalldevs, netfilter_create },
409  #endif
410  #ifdef PCAP_SUPPORT_NETMAP
411  	{ pcap_netmap_findalldevs, pcap_netmap_create },
412  #endif
413  #ifdef PCAP_SUPPORT_DBUS
414  	{ dbus_findalldevs, dbus_create },
415  #endif
416  #ifdef PCAP_SUPPORT_RDMASNIFF
417  	{ rdmasniff_findalldevs, rdmasniff_create },
418  #endif
419  #ifdef PCAP_SUPPORT_DPDK
420  	{ pcap_dpdk_findalldevs, pcap_dpdk_create },
421  #endif
422  #ifdef HAVE_AIRPCAP_API
423  	{ airpcap_findalldevs, airpcap_create },
424  #endif
425  	{ NULL, NULL }
426  };
427  int
428  pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
429  {
430  	size_t i;
431  	pcap_if_list_t devlist;
432  	devlist.beginning = NULL;
433  	if (pcap_platform_finddevs(&devlist, errbuf) == -1) {
434  		if (devlist.beginning != NULL)
435  			pcap_freealldevs(devlist.beginning);
436  		*alldevsp = NULL;
437  		return (-1);
438  	}
439  	for (i = 0; capture_source_types[i].findalldevs_op != NULL; i++) {
440  		if (capture_source_types[i].findalldevs_op(&devlist, errbuf) == -1) {
441  			if (devlist.beginning != NULL)
442  				pcap_freealldevs(devlist.beginning);
443  			*alldevsp = NULL;
444  			return (-1);
445  		}
446  	}
447  	*alldevsp = devlist.beginning;
448  	return (0);
449  }
450  static struct sockaddr *
451  dup_sockaddr(struct sockaddr *sa, size_t sa_length)
452  {
453  	struct sockaddr *newsa;
454  	if ((newsa = malloc(sa_length)) == NULL)
455  		return (NULL);
456  	return (memcpy(newsa, sa, sa_length));
457  }
458  static u_int
459  get_figure_of_merit(pcap_if_t *dev)
460  {
461  	u_int n;
462  	n = 0;
463  	if (!(dev->flags & PCAP_IF_RUNNING))
464  		n |= 0x80000000;
465  	if (!(dev->flags & PCAP_IF_UP))
466  		n |= 0x40000000;
467  	if (!(dev->flags & PCAP_IF_WIRELESS) &&
468  	    (dev->flags & PCAP_IF_CONNECTION_STATUS) == PCAP_IF_CONNECTION_STATUS_DISCONNECTED)
469  		n |= 0x20000000;
470  	if (dev->flags & PCAP_IF_LOOPBACK)
471  		n |= 0x10000000;
472  	if (strcmp(dev->name, "any") == 0)
473  		n |= 0x08000000;
474  	return (n);
475  }
476  #ifndef _WIN32
477  static char *
478  #ifdef SIOCGIFDESCR
479  get_if_description(const char *name)
480  {
481  	char *description = NULL;
482  	int s;
483  	struct ifreq ifrdesc;
484  #ifndef IFDESCRSIZE
485  	size_t descrlen = 64;
486  #else
487  	size_t descrlen = IFDESCRSIZE;
488  #endif &bsol;* IFDESCRSIZE */
489  	memset(&ifrdesc, 0, sizeof ifrdesc);
490  	pcap_strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);
491  	s = socket(AF_INET, SOCK_DGRAM, 0);
492  	if (s >= 0) {
493  #ifdef __FreeBSD__
494  		for (;;) {
495  			free(description);
496  			if ((description = malloc(descrlen)) != NULL) {
497  				ifrdesc.ifr_buffer.buffer = description;
498  				ifrdesc.ifr_buffer.length = descrlen;
499  				if (ioctl(s, SIOCGIFDESCR, &ifrdesc) == 0) {
500  					if (ifrdesc.ifr_buffer.buffer ==
501  					    description)
502  						break;
503  					else
504  						descrlen = ifrdesc.ifr_buffer.length;
505  				} else {
506  					free(description);
507  					description = NULL;
508  					break;
509  				}
510  			} else
511  				break;
512  		}
513  #else &bsol;* __FreeBSD__ */
514  		if ((description = malloc(descrlen)) != NULL) {
515  			ifrdesc.ifr_data = (caddr_t)description;
516  			if (ioctl(s, SIOCGIFDESCR, &ifrdesc) != 0) {
517  				free(description);
518  				description = NULL;
519  			}
520  		}
521  #endif &bsol;* __FreeBSD__ */
522  		close(s);
523  		if (description != NULL && description[0] == '\0') {
524  			free(description);
525  			description = NULL;
526  		}
527  	}
528  #ifdef __FreeBSD__
529  	if (description == NULL) {
530  		if (strncmp(name, "usbus", 5) == 0) {
531  			long busnum;
532  			char *p;
533  			errno = 0;
534  			busnum = strtol(name + 5, &p, 10);
535  			if (errno == 0 && p != name + 5 && *p == '\0' &&
536  			    busnum >= 0 && busnum <= INT_MAX) {
537  				if (pcap_asprintf(&description,
538  				    "USB bus number %ld", busnum) == -1) {
539  					description = NULL;
540  				}
541  			}
542  		}
543  	}
544  #endif
545  	return (description);
546  #else &bsol;* SIOCGIFDESCR */
547  get_if_description(const char *name _U_)
548  {
549  	return (NULL);
550  #endif &bsol;* SIOCGIFDESCR */
551  }
552  pcap_if_t *
553  pcap_find_or_add_if(pcap_if_list_t *devlistp, const char *name,
554      bpf_u_int32 if_flags, get_if_flags_func get_flags_func, char *errbuf)
555  {
556  	bpf_u_int32 pcap_flags;
557  	pcap_flags = 0;
558  #ifdef IFF_LOOPBACK
559  	if (if_flags & IFF_LOOPBACK)
560  		pcap_flags |= PCAP_IF_LOOPBACK;
561  #else
562  	if (name[0] == 'l' && name[1] == 'o' &&
563  	    (PCAP_ISDIGIT(name[2]) || name[2] == '\0'))
564  		pcap_flags |= PCAP_IF_LOOPBACK;
565  #endif
566  #ifdef IFF_UP
567  	if (if_flags & IFF_UP)
568  		pcap_flags |= PCAP_IF_UP;
569  #endif
570  #ifdef IFF_RUNNING
571  	if (if_flags & IFF_RUNNING)
572  		pcap_flags |= PCAP_IF_RUNNING;
573  #endif
574  	return (pcap_find_or_add_dev(devlistp, name, pcap_flags,
575  	    get_flags_func, get_if_description(name), errbuf));
576  }
577  int
578  pcap_add_addr_to_if(pcap_if_list_t *devlistp, const char *name,
579      bpf_u_int32 if_flags, get_if_flags_func get_flags_func,
580      struct sockaddr *addr, size_t addr_size,
581      struct sockaddr *netmask, size_t netmask_size,
582      struct sockaddr *broadaddr, size_t broadaddr_size,
583      struct sockaddr *dstaddr, size_t dstaddr_size,
584      char *errbuf)
585  {
586  	pcap_if_t *curdev;
587  	curdev = pcap_find_or_add_if(devlistp, name, if_flags, get_flags_func,
588  	    errbuf);
589  	if (curdev == NULL) {
590  		return (-1);
591  	}
592  	if (addr == NULL) {
593  		return (0);
594  	}
595  	return (pcap_add_addr_to_dev(curdev, addr, addr_size, netmask,
596  	    netmask_size, broadaddr, broadaddr_size, dstaddr,
597  	    dstaddr_size, errbuf));
598  }
599  #endif &bsol;* _WIN32 */
600  int
601  pcap_add_addr_to_dev(pcap_if_t *curdev,
602      struct sockaddr *addr, size_t addr_size,
603      struct sockaddr *netmask, size_t netmask_size,
604      struct sockaddr *broadaddr, size_t broadaddr_size,
605      struct sockaddr *dstaddr, size_t dstaddr_size,
606      char *errbuf)
607  {
608  	pcap_addr_t *curaddr, *prevaddr, *nextaddr;
609  	curaddr = (pcap_addr_t *)malloc(sizeof(pcap_addr_t));
610  	if (curaddr == NULL) {
611  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
612  		    errno, "malloc");
613  		return (-1);
614  	}
615  	curaddr->next = NULL;
616  	if (addr != NULL && addr_size != 0) {
617  		curaddr->addr = (struct sockaddr *)dup_sockaddr(addr, addr_size);
618  		if (curaddr->addr == NULL) {
619  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
620  			    errno, "malloc");
621  			free(curaddr);
622  			return (-1);
623  		}
624  	} else
625  		curaddr->addr = NULL;
626  	if (netmask != NULL && netmask_size != 0) {
627  		curaddr->netmask = (struct sockaddr *)dup_sockaddr(netmask, netmask_size);
628  		if (curaddr->netmask == NULL) {
629  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
630  			    errno, "malloc");
631  			if (curaddr->addr != NULL)
632  				free(curaddr->addr);
633  			free(curaddr);
634  			return (-1);
635  		}
636  	} else
637  		curaddr->netmask = NULL;
638  	if (broadaddr != NULL && broadaddr_size != 0) {
639  		curaddr->broadaddr = (struct sockaddr *)dup_sockaddr(broadaddr, broadaddr_size);
640  		if (curaddr->broadaddr == NULL) {
641  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
642  			    errno, "malloc");
643  			if (curaddr->netmask != NULL)
644  				free(curaddr->netmask);
645  			if (curaddr->addr != NULL)
646  				free(curaddr->addr);
647  			free(curaddr);
648  			return (-1);
649  		}
650  	} else
651  		curaddr->broadaddr = NULL;
652  	if (dstaddr != NULL && dstaddr_size != 0) {
653  		curaddr->dstaddr = (struct sockaddr *)dup_sockaddr(dstaddr, dstaddr_size);
654  		if (curaddr->dstaddr == NULL) {
655  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
656  			    errno, "malloc");
657  			if (curaddr->broadaddr != NULL)
658  				free(curaddr->broadaddr);
659  			if (curaddr->netmask != NULL)
660  				free(curaddr->netmask);
661  			if (curaddr->addr != NULL)
662  				free(curaddr->addr);
663  			free(curaddr);
664  			return (-1);
665  		}
666  	} else
667  		curaddr->dstaddr = NULL;
668  	for (prevaddr = curdev->addresses; prevaddr != NULL; prevaddr = nextaddr) {
669  		nextaddr = prevaddr->next;
670  		if (nextaddr == NULL) {
671  			break;
672  		}
673  	}
674  	if (prevaddr == NULL) {
675  		curdev->addresses = curaddr;
676  	} else {
677  		prevaddr->next = curaddr;
678  	}
679  	return (0);
680  }
681  pcap_if_t *
682  pcap_find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
683      get_if_flags_func get_flags_func, const char *description, char *errbuf)
684  {
685  	pcap_if_t *curdev;
686  	curdev = pcap_find_dev(devlistp, name);
687  	if (curdev != NULL) {
688  		return (curdev);
689  	}
690  	if ((*get_flags_func)(name, &flags, errbuf) == -1) {
691  		return (NULL);
692  	}
693  	return (pcap_add_dev(devlistp, name, flags, description, errbuf));
694  }
695  pcap_if_t *
696  pcap_find_dev(pcap_if_list_t *devlistp, const char *name)
697  {
698  	pcap_if_t *curdev;
699  	for (curdev = devlistp->beginning; curdev != NULL;
700  	    curdev = curdev->next) {
701  		if (strcmp(name, curdev->name) == 0) {
702  			return (curdev);
703  		}
704  	}
705  	return (NULL);
706  }
707  pcap_if_t *
708  pcap_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,
709      const char *description, char *errbuf)
710  {
711  	pcap_if_t *curdev, *prevdev, *nextdev;
712  	u_int this_figure_of_merit, nextdev_figure_of_merit;
713  	curdev = malloc(sizeof(pcap_if_t));
714  	if (curdev == NULL) {
715  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
716  		    errno, "malloc");
717  		return (NULL);
718  	}
719  	curdev->next = NULL;
720  	curdev->name = strdup(name);
721  	if (curdev->name == NULL) {
722  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
723  		    errno, "malloc");
724  		free(curdev);
725  		return (NULL);
726  	}
727  	if (description == NULL) {
728  		curdev->description = NULL;
729  	} else {
730  		curdev->description = strdup(description);
731  		if (curdev->description == NULL) {
732  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
733  			    errno, "malloc");
734  			free(curdev->name);
735  			free(curdev);
736  			return (NULL);
737  		}
738  	}
739  	curdev->addresses = NULL;	&bsol;* list starts out as empty */
740  	curdev->flags = flags;
741  	this_figure_of_merit = get_figure_of_merit(curdev);
742  	prevdev = NULL;
743  	for (;;) {
744  		if (prevdev == NULL) {
745  			nextdev = devlistp->beginning;
746  		} else
747  			nextdev = prevdev->next;
748  		if (nextdev == NULL) {
749  			break;
750  		}
751  		nextdev_figure_of_merit = get_figure_of_merit(nextdev);
752  		if (this_figure_of_merit < nextdev_figure_of_merit) {
753  			break;
754  		}
755  		prevdev = nextdev;
756  	}
757  	curdev->next = nextdev;
758  	if (prevdev == NULL) {
759  		devlistp->beginning = curdev;
760  	} else
761  		prevdev->next = curdev;
762  	return (curdev);
763  }
764  pcap_if_t *
765  pcap_add_any_dev(pcap_if_list_t *devlistp, char *errbuf)
766  {
767  	static const char any_descr[] = "Pseudo-device that captures on all interfaces";
768  	return pcap_add_dev(devlistp, "any",
769  	    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
770  	    any_descr, errbuf);
771  }
772  void
773  pcap_freealldevs(pcap_if_t *alldevs)
774  {
775  	pcap_if_t *curdev, *nextdev;
776  	pcap_addr_t *curaddr, *nextaddr;
777  	for (curdev = alldevs; curdev != NULL; curdev = nextdev) {
778  		nextdev = curdev->next;
779  		for (curaddr = curdev->addresses; curaddr != NULL; curaddr = nextaddr) {
780  			nextaddr = curaddr->next;
781  			if (curaddr->addr)
<span onclick='openModal()' class='match'>782  				free(curaddr->addr);
783  			if (curaddr->netmask)
784  				free(curaddr->netmask);
785  			if (curaddr->broadaddr)
</span>786  				free(curaddr->broadaddr);
787  			if (curaddr->dstaddr)
788  				free(curaddr->dstaddr);
789  			free(curaddr);
790  		}
791  		free(curdev->name);
792  		if (curdev->description != NULL)
793  			free(curdev->description);
794  		free(curdev);
795  	}
796  }
797  #if !defined(HAVE_PACKET32) && !defined(MSDOS)
798  char *
799  pcap_lookupdev(char *errbuf)
800  {
801  	pcap_if_t *alldevs;
802  #ifdef _WIN32
803    #define IF_NAMESIZE 8192
804  #else
805  #endif
806  	static char device[IF_NAMESIZE + 1];
807  	char *ret;
808  	if (pcap_new_api) {
809  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
810  		    "pcap_lookupdev() is deprecated and is not supported in programs calling pcap_init()");
811  		return (NULL);
812  	}
813  	if (pcap_findalldevs(&alldevs, errbuf) == -1)
814  		return (NULL);
815  	if (alldevs == NULL || (alldevs->flags & PCAP_IF_LOOPBACK)) {
816  		(void)pcap_strlcpy(errbuf, "no suitable device found",
817  		    PCAP_ERRBUF_SIZE);
818  		ret = NULL;
819  	} else {
820  		(void)pcap_strlcpy(device, alldevs->name, sizeof(device));
821  		ret = device;
822  	}
823  	pcap_freealldevs(alldevs);
824  	return (ret);
825  }
826  #endif &bsol;* !defined(HAVE_PACKET32) && !defined(MSDOS) */
827  #if !defined(_WIN32) && !defined(MSDOS)
828  int
829  pcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,
830      char *errbuf)
831  {
832  	register int fd;
833  	register struct sockaddr_in *sin4;
834  	struct ifreq ifr;
835  	if (!device || strcmp(device, "any") == 0
836  #ifdef HAVE_DAG_API
837  	    || strstr(device, "dag") != NULL
838  #endif
839  #ifdef HAVE_SEPTEL_API
840  	    || strstr(device, "septel") != NULL
841  #endif
842  #ifdef PCAP_SUPPORT_BT
843  	    || strstr(device, "bluetooth") != NULL
844  #endif
845  #ifdef PCAP_SUPPORT_LINUX_USBMON
846  	    || strstr(device, "usbmon") != NULL
847  #endif
848  #ifdef HAVE_SNF_API
849  	    || strstr(device, "snf") != NULL
850  #endif
851  #ifdef PCAP_SUPPORT_NETMAP
852  	    || strncmp(device, "netmap:", 7) == 0
853  	    || strncmp(device, "vale", 4) == 0
854  #endif
855  #ifdef PCAP_SUPPORT_DPDK
856  	    || strncmp(device, "dpdk:", 5) == 0
857  #endif
858  	    ) {
859  		*netp = *maskp = 0;
860  		return 0;
861  	}
862  	fd = socket(AF_INET, SOCK_DGRAM, 0);
863  	if (fd < 0) {
864  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
865  		    errno, "socket");
866  		return (-1);
867  	}
868  	memset(&ifr, 0, sizeof(ifr));
869  #ifdef linux
870  	ifr.ifr_addr.sa_family = AF_INET;
871  #endif
872  	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
873  #if defined(__HAIKU__) && defined(__clang__)
874  	if (ioctl(fd, SIOCGIFADDR, (char *)&ifr, sizeof(ifr)) < 0) {
875  #else
876  	if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {
877  #endif &bsol;* __HAIKU__ && __clang__ */
878  		if (errno == EADDRNOTAVAIL) {
879  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
880  			    "%s: no IPv4 address assigned", device);
881  		} else {
882  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
883  			    errno, "SIOCGIFADDR: %s", device);
884  		}
885  		(void)close(fd);
886  		return (-1);
887  	}
888  	sin4 = (struct sockaddr_in *)&ifr.ifr_addr;
889  	*netp = sin4->sin_addr.s_addr;
890  	memset(&ifr, 0, sizeof(ifr));
891  #ifdef linux
892  	ifr.ifr_addr.sa_family = AF_INET;
893  #endif
894  	(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
895  #if defined(__HAIKU__) && defined(__clang__)
896  	if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr, sizeof(ifr)) < 0) {
897  #else
898  	if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {
899  #endif &bsol;* __HAIKU__ && __clang__ */
900  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
901  		    errno, "SIOCGIFNETMASK: %s", device);
902  		(void)close(fd);
903  		return (-1);
904  	}
905  	(void)close(fd);
906  	*maskp = sin4->sin_addr.s_addr;
907  	if (*maskp == 0) {
908  		if (IN_CLASSA(*netp))
909  			*maskp = IN_CLASSA_NET;
910  		else if (IN_CLASSB(*netp))
911  			*maskp = IN_CLASSB_NET;
912  		else if (IN_CLASSC(*netp))
913  			*maskp = IN_CLASSC_NET;
914  		else {
915  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
916  			    "inet class for 0x%x unknown", *netp);
917  			return (-1);
918  		}
919  	}
920  	*netp &= *maskp;
921  	return (0);
922  }
923  #endif &bsol;* !defined(_WIN32) && !defined(MSDOS) */
924  #ifdef ENABLE_REMOTE
925  #include "pcap-rpcap.h"
926  static char *
927  get_substring(const char *p, size_t len, char *ebuf)
928  {
929  	char *token;
930  	token = malloc(len + 1);
931  	if (token == NULL) {
932  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
933  		    errno, "malloc");
934  		return (NULL);
935  	}
936  	memcpy(token, p, len);
937  	token[len] = '\0';
938  	return (token);
939  }
940  static int
941  pcap_parse_source(const char *source, char **schemep, char **userinfop,
942      char **hostp, char **portp, char **pathp, char *ebuf)
943  {
944  	char *colonp;
945  	size_t scheme_len;
946  	char *scheme;
947  	const char *endp;
948  	size_t authority_len;
949  	char *authority;
950  	char *parsep, *atsignp, *bracketp;
951  	char *userinfo, *host, *port, *path;
952  	*schemep = NULL;
953  	*userinfop = NULL;
954  	*hostp = NULL;
955  	*portp = NULL;
956  	*pathp = NULL;
957  	colonp = strchr(source, ':');
958  	if (colonp == NULL) {
959  		*pathp = strdup(source);
960  		if (*pathp == NULL) {
961  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
962  			    errno, "malloc");
963  			return (-1);
964  		}
965  		return (0);
966  	}
967  	if (strncmp(colonp + 1, "&bsol;&bsol;", 2) != 0) {
968  		*pathp = strdup(source);
969  		if (*pathp == NULL) {
970  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
971  			    errno, "malloc");
972  			return (-1);
973  		}
974  		return (0);
975  	}
976  	scheme_len = colonp - source;
977  	scheme = malloc(scheme_len + 1);
978  	if (scheme == NULL) {
979  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
980  		    errno, "malloc");
981  		return (-1);
982  	}
983  	memcpy(scheme, source, scheme_len);
984  	scheme[scheme_len] = '\0';
985  	if (pcap_strcasecmp(scheme, "file") == 0) {
986  		*pathp = strdup(colonp + 3);
987  		if (*pathp == NULL) {
988  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
989  			    errno, "malloc");
990  			free(scheme);
991  			return (-1);
992  		}
993  		*schemep = scheme;
994  		return (0);
995  	}
996  	if ((pcap_strcasecmp(scheme, "rpcap") == 0 ||
997  	    pcap_strcasecmp(scheme, "rpcaps") == 0) &&
998  	    strchr(colonp + 3, '/') == NULL) {
999  		free(scheme);
1000  		*pathp = strdup(colonp + 3);
1001  		if (*pathp == NULL) {
1002  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1003  			    errno, "malloc");
1004  			return (-1);
1005  		}
1006  		return (0);
1007  	}
1008  	authority_len = strcspn(colonp + 3, "/");
1009  	authority = get_substring(colonp + 3, authority_len, ebuf);
1010  	if (authority == NULL) {
1011  		free(scheme);
1012  		return (-1);
1013  	}
1014  	endp = colonp + 3 + authority_len;
1015  	parsep = authority;
1016  	atsignp = strchr(parsep, '@');
1017  	if (atsignp != NULL) {
1018  		size_t userinfo_len;
1019  		userinfo_len = atsignp - parsep;
1020  		userinfo = get_substring(parsep, userinfo_len, ebuf);
1021  		if (userinfo == NULL) {
1022  			free(authority);
1023  			free(scheme);
1024  			return (-1);
1025  		}
1026  		parsep = atsignp + 1;
1027  	} else {
1028  		userinfo = NULL;
1029  	}
1030  	if (*parsep == '\0') {
1031  		host = NULL;
1032  		port = NULL;
1033  	} else {
1034  		size_t host_len;
1035  		if (*parsep == '[') {
1036  			bracketp = strchr(parsep, ']');
1037  			if (bracketp == NULL) {
1038  				snprintf(ebuf, PCAP_ERRBUF_SIZE,
1039  				    "IP-literal in URL doesn't end with ]");
1040  				free(userinfo);
1041  				free(authority);
1042  				free(scheme);
1043  				return (-1);
1044  			}
1045  			if (*(bracketp + 1) != '\0' &&
1046  			    *(bracketp + 1) != ':') {
1047  				snprintf(ebuf, PCAP_ERRBUF_SIZE,
1048  				    "Extra text after IP-literal in URL");
1049  				free(userinfo);
1050  				free(authority);
1051  				free(scheme);
1052  				return (-1);
1053  			}
1054  			host_len = (bracketp - 1) - parsep;
1055  			host = get_substring(parsep + 1, host_len, ebuf);
1056  			if (host == NULL) {
1057  				free(userinfo);
1058  				free(authority);
1059  				free(scheme);
1060  				return (-1);
1061  			}
1062  			parsep = bracketp + 1;
1063  		} else {
1064  			host_len = strcspn(parsep, ":");
1065  			host = get_substring(parsep, host_len, ebuf);
1066  			if (host == NULL) {
1067  				free(userinfo);
1068  				free(authority);
1069  				free(scheme);
1070  				return (-1);
1071  			}
1072  			parsep = parsep + host_len;
1073  		}
1074  		if (*parsep == ':') {
1075  			size_t port_len;
1076  			parsep++;
1077  			port_len = strlen(parsep);
1078  			port = get_substring(parsep, port_len, ebuf);
1079  			if (port == NULL) {
1080  				free(host);
1081  				free(userinfo);
1082  				free(authority);
1083  				free(scheme);
1084  				return (-1);
1085  			}
1086  		} else {
1087  			port = NULL;
1088  		}
1089  	}
1090  	free(authority);
1091  	if (*endp == '\0')
1092  		path = strdup("");
1093  	else
1094  		path = strdup(endp + 1);
1095  	if (path == NULL) {
1096  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1097  		    errno, "malloc");
1098  		free(port);
1099  		free(host);
1100  		free(userinfo);
1101  		free(scheme);
1102  		return (-1);
1103  	}
1104  	*schemep = scheme;
1105  	*userinfop = userinfo;
1106  	*hostp = host;
1107  	*portp = port;
1108  	*pathp = path;
1109  	return (0);
1110  }
1111  int
1112  pcap_createsrcstr_ex(char *source, int type, const char *userinfo, const char *host,
1113      const char *port, const char *name, unsigned char uses_ssl, char *errbuf)
1114  {
1115  	switch (type) {
1116  	case PCAP_SRC_FILE:
1117  		pcap_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);
1118  		if (name != NULL && *name != '\0') {
1119  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1120  			return (0);
1121  		} else {
1122  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1123  			    "The file name cannot be NULL.");
1124  			return (-1);
1125  		}
1126  	case PCAP_SRC_IFREMOTE:
1127  		pcap_strlcpy(source,
1128  		    (uses_ssl ? "rpcaps:&bsol;&bsol;" : PCAP_SRC_IF_STRING),
1129  		    PCAP_BUF_SIZE);
1130  		if (host != NULL && *host != '\0') {
1131  			if (userinfo != NULL && *userinfo != '\0') {
1132  				pcap_strlcat(source, userinfo, PCAP_BUF_SIZE);
1133  				pcap_strlcat(source, "@", PCAP_BUF_SIZE);
1134  			}
1135  			if (strchr(host, ':') != NULL) {
1136  				pcap_strlcat(source, "[", PCAP_BUF_SIZE);
1137  				pcap_strlcat(source, host, PCAP_BUF_SIZE);
1138  				pcap_strlcat(source, "]", PCAP_BUF_SIZE);
1139  			} else
1140  				pcap_strlcat(source, host, PCAP_BUF_SIZE);
1141  			if (port != NULL && *port != '\0') {
1142  				pcap_strlcat(source, ":", PCAP_BUF_SIZE);
1143  				pcap_strlcat(source, port, PCAP_BUF_SIZE);
1144  			}
1145  			pcap_strlcat(source, "/", PCAP_BUF_SIZE);
1146  		} else {
1147  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
1148  			    "The host name cannot be NULL.");
1149  			return (-1);
1150  		}
1151  		if (name != NULL && *name != '\0')
1152  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1153  		return (0);
1154  	case PCAP_SRC_IFLOCAL:
1155  		pcap_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);
1156  		if (name != NULL && *name != '\0')
1157  			pcap_strlcat(source, name, PCAP_BUF_SIZE);
1158  		return (0);
1159  	default:
1160  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1161  		    "The interface type is not valid.");
1162  		return (-1);
1163  	}
1164  }
1165  int
1166  pcap_createsrcstr(char *source, int type, const char *host, const char *port,
1167      const char *name, char *errbuf)
1168  {
1169  	return (pcap_createsrcstr_ex(source, type, NULL, host, port, name, 0, errbuf));
1170  }
1171  int
1172  pcap_parsesrcstr_ex(const char *source, int *type, char *userinfo, char *host,
1173      char *port, char *name, unsigned char *uses_ssl, char *errbuf)
1174  {
1175  	char *scheme, *tmpuserinfo, *tmphost, *tmpport, *tmppath;
1176  	if (userinfo)
1177  		*userinfo = '\0';
1178  	if (host)
1179  		*host = '\0';
1180  	if (port)
1181  		*port = '\0';
1182  	if (name)
1183  		*name = '\0';
1184  	if (uses_ssl)
1185  		*uses_ssl = 0;
1186  	if (pcap_parse_source(source, &scheme, &tmpuserinfo, &tmphost,
1187  	    &tmpport, &tmppath, errbuf) == -1) {
1188  		return (-1);
1189  	}
1190  	if (scheme == NULL) {
1191  		if (name && tmppath)
1192  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1193  		if (type)
1194  			*type = PCAP_SRC_IFLOCAL;
1195  		free(tmppath);
1196  		free(tmpport);
1197  		free(tmphost);
1198  		free(tmpuserinfo);
1199  		return (0);
1200  	}
1201  	int is_rpcap = 0;
1202  	if (strcmp(scheme, "rpcaps") == 0) {
1203  		is_rpcap = 1;
1204  		if (uses_ssl) *uses_ssl = 1;
1205  	} else if (strcmp(scheme, "rpcap") == 0) {
1206  		is_rpcap = 1;
1207  	}
1208  	if (is_rpcap) {
1209  		if (userinfo && tmpuserinfo)
1210  			pcap_strlcpy(userinfo, tmpuserinfo, PCAP_BUF_SIZE);
1211  		if (host && tmphost)
1212  			pcap_strlcpy(host, tmphost, PCAP_BUF_SIZE);
1213  		if (port && tmpport)
1214  			pcap_strlcpy(port, tmpport, PCAP_BUF_SIZE);
1215  		if (name && tmppath)
1216  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1217  		if (type)
1218  			*type = PCAP_SRC_IFREMOTE;
1219  		free(tmppath);
1220  		free(tmpport);
1221  		free(tmphost);
1222  		free(tmpuserinfo);
1223  		free(scheme);
1224  		return (0);
1225  	}
1226  	if (strcmp(scheme, "file") == 0) {
1227  		if (name && tmppath)
1228  			pcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);
1229  		if (type)
1230  			*type = PCAP_SRC_FILE;
1231  		free(tmppath);
1232  		free(tmpport);
1233  		free(tmphost);
1234  		free(tmpuserinfo);
1235  		free(scheme);
1236  		return (0);
1237  	}
1238  	if (name)
1239  		pcap_strlcpy(name, source, PCAP_BUF_SIZE);
1240  	if (type)
1241  		*type = PCAP_SRC_IFLOCAL;
1242  	free(tmppath);
1243  	free(tmpport);
1244  	free(tmphost);
1245  	free(tmpuserinfo);
1246  	free(scheme);
1247  	return (0);
1248  }
1249  int
1250  pcap_parsesrcstr(const char *source, int *type, char *host, char *port,
1251      char *name, char *errbuf)
1252  {
1253  	return (pcap_parsesrcstr_ex(source, type, NULL, host, port, name, NULL, errbuf));
1254  }
1255  #endif
1256  pcap_t *
1257  pcap_create(const char *device, char *errbuf)
1258  {
1259  	size_t i;
1260  	int is_theirs;
1261  	pcap_t *p;
1262  	char *device_str;
1263  	if (device == NULL)
1264  		device_str = strdup("any");
1265  	else {
1266  #ifdef _WIN32
1267  		if (!pcap_new_api && device[0] != '\0' && device[1] == '\0') {
1268  			size_t length;
1269  			length = wcslen((wchar_t *)device);
1270  			device_str = (char *)malloc(length + 1);
1271  			if (device_str == NULL) {
1272  				pcap_fmt_errmsg_for_errno(errbuf,
1273  				    PCAP_ERRBUF_SIZE, errno,
1274  				    "malloc");
1275  				return (NULL);
1276  			}
1277  			snprintf(device_str, length + 1, "%ws",
1278  			    (const wchar_t *)device);
1279  		} else
1280  #endif
1281  			device_str = strdup(device);
1282  	}
1283  	if (device_str == NULL) {
1284  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1285  		    errno, "malloc");
1286  		return (NULL);
1287  	}
1288  	for (i = 0; capture_source_types[i].create_op != NULL; i++) {
1289  		is_theirs = 0;
1290  		p = capture_source_types[i].create_op(device_str, errbuf,
1291  		    &is_theirs);
1292  		if (is_theirs) {
1293  			if (p == NULL) {
1294  				free(device_str);
1295  				return (NULL);
1296  			}
1297  			p->opt.device = device_str;
1298  			return (p);
1299  		}
1300  	}
1301  	p = pcap_create_interface(device_str, errbuf);
1302  	if (p == NULL) {
1303  		free(device_str);
1304  		return (NULL);
1305  	}
1306  	p->opt.device = device_str;
1307  	return (p);
1308  }
1309  static int
1310  pcap_setnonblock_unactivated(pcap_t *p, int nonblock)
1311  {
1312  	p->opt.nonblock = nonblock;
1313  	return (0);
1314  }
1315  static void
1316  initialize_ops(pcap_t *p)
1317  {
1318  	p->read_op = pcap_read_not_initialized;
1319  	p->inject_op = pcap_inject_not_initialized;
1320  	p->setfilter_op = pcap_setfilter_not_initialized;
1321  	p->setdirection_op = pcap_setdirection_not_initialized;
1322  	p->set_datalink_op = pcap_set_datalink_not_initialized;
1323  	p->getnonblock_op = pcap_getnonblock_not_initialized;
1324  	p->stats_op = pcap_stats_not_initialized;
1325  #ifdef _WIN32
1326  	p->stats_ex_op = pcap_stats_ex_not_initialized;
1327  	p->setbuff_op = pcap_setbuff_not_initialized;
1328  	p->setmode_op = pcap_setmode_not_initialized;
1329  	p->setmintocopy_op = pcap_setmintocopy_not_initialized;
1330  	p->getevent_op = pcap_getevent_not_initialized;
1331  	p->oid_get_request_op = pcap_oid_get_request_not_initialized;
1332  	p->oid_set_request_op = pcap_oid_set_request_not_initialized;
1333  	p->sendqueue_transmit_op = pcap_sendqueue_transmit_not_initialized;
1334  	p->setuserbuffer_op = pcap_setuserbuffer_not_initialized;
1335  	p->live_dump_op = pcap_live_dump_not_initialized;
1336  	p->live_dump_ended_op = pcap_live_dump_ended_not_initialized;
1337  	p->get_airpcap_handle_op = pcap_get_airpcap_handle_not_initialized;
1338  #endif
1339  	p->cleanup_op = pcap_cleanup_live_common;
1340  	p->oneshot_callback = pcap_oneshot;
1341  	p->breakloop_op = pcap_breakloop_common;
1342  }
1343  static pcap_t *
1344  pcap_alloc_pcap_t(char *ebuf, size_t total_size, size_t private_offset)
1345  {
1346  	char *chunk;
1347  	pcap_t *p;
1348  	chunk = calloc(total_size, 1);
1349  	if (chunk == NULL) {
1350  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
1351  		    errno, "malloc");
1352  		return (NULL);
1353  	}
1354  	p = (pcap_t *)chunk;
1355  #ifdef _WIN32
1356  	p->handle = INVALID_HANDLE_VALUE;	&bsol;* not opened yet */
1357  #else &bsol;* _WIN32 */
1358  	p->fd = -1;	&bsol;* not opened yet */
1359  #ifndef MSDOS
1360  	p->selectable_fd = -1;
1361  	p->required_select_timeout = NULL;
1362  #endif &bsol;* MSDOS */
1363  #endif &bsol;* _WIN32 */
1364  	p->priv = (void *)(chunk + private_offset);
1365  	return (p);
1366  }
1367  pcap_t *
1368  pcap_create_common(char *ebuf, size_t total_size, size_t private_offset)
1369  {
1370  	pcap_t *p;
1371  	p = pcap_alloc_pcap_t(ebuf, total_size, private_offset);
1372  	if (p == NULL)
1373  		return (NULL);
1374  	p->can_set_rfmon_op = pcap_cant_set_rfmon;
1375  	p->setnonblock_op = pcap_setnonblock_unactivated;
1376  	initialize_ops(p);
1377  	p->snapshot = 0;		&bsol;* max packet size unspecified */
1378  	p->opt.timeout = 0;		&bsol;* no timeout specified */
1379  	p->opt.buffer_size = 0;		&bsol;* use the platform's default */
1380  	p->opt.promisc = 0;
1381  	p->opt.rfmon = 0;
1382  	p->opt.immediate = 0;
1383  	p->opt.tstamp_type = -1;	&bsol;* default to not setting time stamp type */
1384  	p->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;
1385  #ifdef __linux__
1386  	p->opt.protocol = 0;
1387  #endif
1388  #ifdef _WIN32
1389  	p->opt.nocapture_local = 0;
1390  #endif
1391  	p->bpf_codegen_flags = 0;
1392  	return (p);
1393  }
1394  int
1395  pcap_check_activated(pcap_t *p)
1396  {
1397  	if (p->activated) {
1398  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "can't perform "
1399  			" operation on activated capture");
1400  		return (-1);
1401  	}
1402  	return (0);
1403  }
1404  int
1405  pcap_set_snaplen(pcap_t *p, int snaplen)
1406  {
1407  	if (pcap_check_activated(p))
1408  		return (PCAP_ERROR_ACTIVATED);
1409  	p->snapshot = snaplen;
1410  	return (0);
1411  }
1412  int
1413  pcap_set_promisc(pcap_t *p, int promisc)
1414  {
1415  	if (pcap_check_activated(p))
1416  		return (PCAP_ERROR_ACTIVATED);
1417  	p->opt.promisc = promisc;
1418  	return (0);
1419  }
1420  int
1421  pcap_set_rfmon(pcap_t *p, int rfmon)
1422  {
1423  	if (pcap_check_activated(p))
1424  		return (PCAP_ERROR_ACTIVATED);
1425  	p->opt.rfmon = rfmon;
1426  	return (0);
1427  }
1428  int
1429  pcap_set_timeout(pcap_t *p, int timeout_ms)
1430  {
1431  	if (pcap_check_activated(p))
1432  		return (PCAP_ERROR_ACTIVATED);
1433  	p->opt.timeout = timeout_ms;
1434  	return (0);
1435  }
1436  int
1437  pcap_set_tstamp_type(pcap_t *p, int tstamp_type)
1438  {
1439  	int i;
1440  	if (pcap_check_activated(p))
1441  		return (PCAP_ERROR_ACTIVATED);
1442  	if (tstamp_type < 0)
1443  		return (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);
1444  	if (p->tstamp_type_count == 0) {
1445  		if (tstamp_type == PCAP_TSTAMP_HOST) {
1446  			p->opt.tstamp_type = tstamp_type;
1447  			return (0);
1448  		}
1449  	} else {
1450  		for (i = 0; i < p->tstamp_type_count; i++) {
1451  			if (p->tstamp_type_list[i] == (u_int)tstamp_type) {
1452  				p->opt.tstamp_type = tstamp_type;
1453  				return (0);
1454  			}
1455  		}
1456  	}
1457  	return (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);
1458  }
1459  int
1460  pcap_set_immediate_mode(pcap_t *p, int immediate)
1461  {
1462  	if (pcap_check_activated(p))
1463  		return (PCAP_ERROR_ACTIVATED);
1464  	p->opt.immediate = immediate;
1465  	return (0);
1466  }
1467  int
1468  pcap_set_buffer_size(pcap_t *p, int buffer_size)
1469  {
1470  	if (pcap_check_activated(p))
1471  		return (PCAP_ERROR_ACTIVATED);
1472  	if (buffer_size <= 0) {
1473  		return (0);
1474  	}
1475  	p->opt.buffer_size = buffer_size;
1476  	return (0);
1477  }
1478  int
1479  pcap_set_tstamp_precision(pcap_t *p, int tstamp_precision)
1480  {
1481  	int i;
1482  	if (pcap_check_activated(p))
1483  		return (PCAP_ERROR_ACTIVATED);
1484  	if (tstamp_precision < 0)
1485  		return (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);
1486  	if (p->tstamp_precision_count == 0) {
1487  		if (tstamp_precision == PCAP_TSTAMP_PRECISION_MICRO) {
1488  			p->opt.tstamp_precision = tstamp_precision;
1489  			return (0);
1490  		}
1491  	} else {
1492  		for (i = 0; i < p->tstamp_precision_count; i++) {
1493  			if (p->tstamp_precision_list[i] == (u_int)tstamp_precision) {
1494  				p->opt.tstamp_precision = tstamp_precision;
1495  				return (0);
1496  			}
1497  		}
1498  	}
1499  	return (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);
1500  }
1501  int
1502  pcap_get_tstamp_precision(pcap_t *p)
1503  {
1504          return (p->opt.tstamp_precision);
1505  }
1506  int
1507  pcap_activate(pcap_t *p)
1508  {
1509  	int status;
1510  	if (pcap_check_activated(p))
1511  		return (PCAP_ERROR_ACTIVATED);
1512  	status = p->activate_op(p);
1513  	if (status >= 0) {
1514  		if (p->opt.nonblock) {
1515  			status = p->setnonblock_op(p, 1);
1516  			if (status < 0) {
1517  				p->cleanup_op(p);
1518  				initialize_ops(p);
1519  				return (status);
1520  			}
1521  		}
1522  		p->activated = 1;
1523  	} else {
1524  		if (p->errbuf[0] == '\0') {
1525  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s",
1526  			    pcap_statustostr(status));
1527  		}
1528  		initialize_ops(p);
1529  	}
1530  	return (status);
1531  }
1532  pcap_t *
1533  pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)
1534  {
1535  	pcap_t *p;
1536  	int status;
1537  #ifdef ENABLE_REMOTE
1538  	char host[PCAP_BUF_SIZE + 1];
1539  	char port[PCAP_BUF_SIZE + 1];
1540  	char name[PCAP_BUF_SIZE + 1];
1541  	int srctype;
1542  	if (device == NULL)
1543  		device = "any";
1544  	if (pcap_parsesrcstr(device, &srctype, host, port, name, errbuf))
1545  		return (NULL);
1546  	if (srctype == PCAP_SRC_IFREMOTE) {
1547  		return (pcap_open_rpcap(device, snaplen,
1548  		    promisc ? PCAP_OPENFLAG_PROMISCUOUS : 0, to_ms,
1549  		    NULL, errbuf));
1550  	}
1551  	if (srctype == PCAP_SRC_FILE) {
1552  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "unknown URL scheme \"file\"");
1553  		return (NULL);
1554  	}
1555  	if (srctype == PCAP_SRC_IFLOCAL) {
1556  		if (strncmp(device, PCAP_SRC_IF_STRING, strlen(PCAP_SRC_IF_STRING)) == 0) {
1557  			size_t len = strlen(device) - strlen(PCAP_SRC_IF_STRING) + 1;
1558  			if (len > 0)
1559  				device += strlen(PCAP_SRC_IF_STRING);
1560  		}
1561  	}
1562  #endif	&bsol;* ENABLE_REMOTE */
1563  	p = pcap_create(device, errbuf);
1564  	if (p == NULL)
1565  		return (NULL);
1566  	status = pcap_set_snaplen(p, snaplen);
1567  	if (status < 0)
1568  		goto fail;
1569  	status = pcap_set_promisc(p, promisc);
1570  	if (status < 0)
1571  		goto fail;
1572  	status = pcap_set_timeout(p, to_ms);
1573  	if (status < 0)
1574  		goto fail;
1575  	p->oldstyle = 1;
1576  	status = pcap_activate(p);
1577  	if (status < 0)
1578  		goto fail;
1579  	return (p);
1580  fail:
1581  	if (status == PCAP_ERROR) {
1582  		char trimbuf[PCAP_ERRBUF_SIZE - 5]; &bsol;* 2 bytes shorter */
1583  		pcap_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
1584  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %.*s", device,
1585  		    PCAP_ERRBUF_SIZE - 3, trimbuf);
1586  	} else if (status == PCAP_ERROR_NO_SUCH_DEVICE ||
1587  	    status == PCAP_ERROR_PERM_DENIED ||
1588  	    status == PCAP_ERROR_PROMISC_PERM_DENIED) {
1589  		if (p->errbuf[0] != '\0') {
1590  			char trimbuf[PCAP_ERRBUF_SIZE - 8]; &bsol;* 2 bytes shorter */
1591  			pcap_strlcpy(trimbuf, p->errbuf, sizeof(trimbuf));
1592  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s (%.*s)",
1593  			    device, pcap_statustostr(status),
1594  			    PCAP_ERRBUF_SIZE - 6, trimbuf);
1595  		} else {
1596  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s",
1597  			    device, pcap_statustostr(status));
1598  		}
1599  	} else {
1600  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s", device,
1601  		    pcap_statustostr(status));
1602  	}
1603  	pcap_close(p);
1604  	return (NULL);
1605  }
1606  pcap_t *
1607  pcap_open_offline_common(char *ebuf, size_t total_size, size_t private_offset)
1608  {
1609  	pcap_t *p;
1610  	p = pcap_alloc_pcap_t(ebuf, total_size, private_offset);
1611  	if (p == NULL)
1612  		return (NULL);
1613  	p->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;
1614  	return (p);
1615  }
1616  int
1617  pcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
1618  {
1619  	return (p->read_op(p, cnt, callback, user));
1620  }
1621  int
1622  pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
1623  {
1624  	register int n;
1625  	for (;;) {
1626  		if (p->rfile != NULL) {
1627  			n = pcap_offline_read(p, cnt, callback, user);
1628  		} else {
1629  			do {
1630  				n = p->read_op(p, cnt, callback, user);
1631  			} while (n == 0);
1632  		}
1633  		if (n <= 0)
1634  			return (n);
1635  		if (!PACKET_COUNT_IS_UNLIMITED(cnt)) {
1636  			cnt -= n;
1637  			if (cnt <= 0)
1638  				return (0);
1639  		}
1640  	}
1641  }
1642  void
1643  pcap_breakloop(pcap_t *p)
1644  {
1645  	p->breakloop_op(p);
1646  }
1647  int
1648  pcap_datalink(pcap_t *p)
1649  {
1650  	if (!p->activated)
1651  		return (PCAP_ERROR_NOT_ACTIVATED);
1652  	return (p->linktype);
1653  }
1654  int
1655  pcap_datalink_ext(pcap_t *p)
1656  {
1657  	if (!p->activated)
1658  		return (PCAP_ERROR_NOT_ACTIVATED);
1659  	return (p->linktype_ext);
1660  }
1661  int
1662  pcap_list_datalinks(pcap_t *p, int **dlt_buffer)
1663  {
1664  	if (!p->activated)
1665  		return (PCAP_ERROR_NOT_ACTIVATED);
1666  	if (p->dlt_count == 0) {
1667  		*dlt_buffer = (int*)malloc(sizeof(**dlt_buffer));
1668  		if (*dlt_buffer == NULL) {
1669  			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1670  			    errno, "malloc");
1671  			return (PCAP_ERROR);
1672  		}
1673  		**dlt_buffer = p->linktype;
1674  		return (1);
1675  	} else {
1676  		*dlt_buffer = (int*)calloc(sizeof(**dlt_buffer), p->dlt_count);
1677  		if (*dlt_buffer == NULL) {
1678  			pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1679  			    errno, "malloc");
1680  			return (PCAP_ERROR);
1681  		}
1682  		(void)memcpy(*dlt_buffer, p->dlt_list,
1683  		    sizeof(**dlt_buffer) * p->dlt_count);
1684  		return (p->dlt_count);
1685  	}
1686  }
1687  void
1688  pcap_free_datalinks(int *dlt_list)
1689  {
1690  	free(dlt_list);
1691  }
1692  int
1693  pcap_set_datalink(pcap_t *p, int dlt)
1694  {
1695  	int i;
1696  	const char *dlt_name;
1697  	if (dlt < 0)
1698  		goto unsupported;
1699  	if (p->dlt_count == 0 || p->set_datalink_op == NULL) {
1700  		if (p->linktype != dlt)
1701  			goto unsupported;
1702  		return (0);
1703  	}
1704  	for (i = 0; i < p->dlt_count; i++)
1705  		if (p->dlt_list[i] == (u_int)dlt)
1706  			break;
1707  	if (i >= p->dlt_count)
1708  		goto unsupported;
1709  	if (p->dlt_count == 2 && p->dlt_list[0] == DLT_EN10MB &&
1710  	    dlt == DLT_DOCSIS) {
1711  		p->linktype = dlt;
1712  		return (0);
1713  	}
1714  	if (p->set_datalink_op(p, dlt) == -1)
1715  		return (-1);
1716  	p->linktype = dlt;
1717  	return (0);
1718  unsupported:
1719  	dlt_name = pcap_datalink_val_to_name(dlt);
1720  	if (dlt_name != NULL) {
1721  		(void) snprintf(p->errbuf, sizeof(p->errbuf),
1722  		    "%s is not one of the DLTs supported by this device",
1723  		    dlt_name);
1724  	} else {
1725  		(void) snprintf(p->errbuf, sizeof(p->errbuf),
1726  		    "DLT %d is not one of the DLTs supported by this device",
1727  		    dlt);
1728  	}
1729  	return (-1);
1730  }
1731  static const u_char charmap[] = {
1732  	(u_char)'\000', (u_char)'\001', (u_char)'\002', (u_char)'\003',
1733  	(u_char)'\004', (u_char)'\005', (u_char)'\006', (u_char)'\007',
1734  	(u_char)'\010', (u_char)'\011', (u_char)'\012', (u_char)'\013',
1735  	(u_char)'\014', (u_char)'\015', (u_char)'\016', (u_char)'\017',
1736  	(u_char)'\020', (u_char)'\021', (u_char)'\022', (u_char)'\023',
1737  	(u_char)'\024', (u_char)'\025', (u_char)'\026', (u_char)'\027',
1738  	(u_char)'\030', (u_char)'\031', (u_char)'\032', (u_char)'\033',
1739  	(u_char)'\034', (u_char)'\035', (u_char)'\036', (u_char)'\037',
1740  	(u_char)'\040', (u_char)'\041', (u_char)'\042', (u_char)'\043',
1741  	(u_char)'\044', (u_char)'\045', (u_char)'\046', (u_char)'\047',
1742  	(u_char)'\050', (u_char)'\051', (u_char)'\052', (u_char)'\053',
1743  	(u_char)'\054', (u_char)'\055', (u_char)'\056', (u_char)'\057',
1744  	(u_char)'\060', (u_char)'\061', (u_char)'\062', (u_char)'\063',
1745  	(u_char)'\064', (u_char)'\065', (u_char)'\066', (u_char)'\067',
1746  	(u_char)'\070', (u_char)'\071', (u_char)'\072', (u_char)'\073',
1747  	(u_char)'\074', (u_char)'\075', (u_char)'\076', (u_char)'\077',
1748  	(u_char)'\100', (u_char)'\141', (u_char)'\142', (u_char)'\143',
1749  	(u_char)'\144', (u_char)'\145', (u_char)'\146', (u_char)'\147',
1750  	(u_char)'\150', (u_char)'\151', (u_char)'\152', (u_char)'\153',
1751  	(u_char)'\154', (u_char)'\155', (u_char)'\156', (u_char)'\157',
1752  	(u_char)'\160', (u_char)'\161', (u_char)'\162', (u_char)'\163',
1753  	(u_char)'\164', (u_char)'\165', (u_char)'\166', (u_char)'\167',
1754  	(u_char)'\170', (u_char)'\171', (u_char)'\172', (u_char)'\133',
1755  	(u_char)'\134', (u_char)'\135', (u_char)'\136', (u_char)'\137',
1756  	(u_char)'\140', (u_char)'\141', (u_char)'\142', (u_char)'\143',
1757  	(u_char)'\144', (u_char)'\145', (u_char)'\146', (u_char)'\147',
1758  	(u_char)'\150', (u_char)'\151', (u_char)'\152', (u_char)'\153',
1759  	(u_char)'\154', (u_char)'\155', (u_char)'\156', (u_char)'\157',
1760  	(u_char)'\160', (u_char)'\161', (u_char)'\162', (u_char)'\163',
1761  	(u_char)'\164', (u_char)'\165', (u_char)'\166', (u_char)'\167',
1762  	(u_char)'\170', (u_char)'\171', (u_char)'\172', (u_char)'\173',
1763  	(u_char)'\174', (u_char)'\175', (u_char)'\176', (u_char)'\177',
1764  	(u_char)'\200', (u_char)'\201', (u_char)'\202', (u_char)'\203',
1765  	(u_char)'\204', (u_char)'\205', (u_char)'\206', (u_char)'\207',
1766  	(u_char)'\210', (u_char)'\211', (u_char)'\212', (u_char)'\213',
1767  	(u_char)'\214', (u_char)'\215', (u_char)'\216', (u_char)'\217',
1768  	(u_char)'\220', (u_char)'\221', (u_char)'\222', (u_char)'\223',
1769  	(u_char)'\224', (u_char)'\225', (u_char)'\226', (u_char)'\227',
1770  	(u_char)'\230', (u_char)'\231', (u_char)'\232', (u_char)'\233',
1771  	(u_char)'\234', (u_char)'\235', (u_char)'\236', (u_char)'\237',
1772  	(u_char)'\240', (u_char)'\241', (u_char)'\242', (u_char)'\243',
1773  	(u_char)'\244', (u_char)'\245', (u_char)'\246', (u_char)'\247',
1774  	(u_char)'\250', (u_char)'\251', (u_char)'\252', (u_char)'\253',
1775  	(u_char)'\254', (u_char)'\255', (u_char)'\256', (u_char)'\257',
1776  	(u_char)'\260', (u_char)'\261', (u_char)'\262', (u_char)'\263',
1777  	(u_char)'\264', (u_char)'\265', (u_char)'\266', (u_char)'\267',
1778  	(u_char)'\270', (u_char)'\271', (u_char)'\272', (u_char)'\273',
1779  	(u_char)'\274', (u_char)'\275', (u_char)'\276', (u_char)'\277',
1780  	(u_char)'\300', (u_char)'\341', (u_char)'\342', (u_char)'\343',
1781  	(u_char)'\344', (u_char)'\345', (u_char)'\346', (u_char)'\347',
1782  	(u_char)'\350', (u_char)'\351', (u_char)'\352', (u_char)'\353',
1783  	(u_char)'\354', (u_char)'\355', (u_char)'\356', (u_char)'\357',
1784  	(u_char)'\360', (u_char)'\361', (u_char)'\362', (u_char)'\363',
1785  	(u_char)'\364', (u_char)'\365', (u_char)'\366', (u_char)'\367',
1786  	(u_char)'\370', (u_char)'\371', (u_char)'\372', (u_char)'\333',
1787  	(u_char)'\334', (u_char)'\335', (u_char)'\336', (u_char)'\337',
1788  	(u_char)'\340', (u_char)'\341', (u_char)'\342', (u_char)'\343',
1789  	(u_char)'\344', (u_char)'\345', (u_char)'\346', (u_char)'\347',
1790  	(u_char)'\350', (u_char)'\351', (u_char)'\352', (u_char)'\353',
1791  	(u_char)'\354', (u_char)'\355', (u_char)'\356', (u_char)'\357',
1792  	(u_char)'\360', (u_char)'\361', (u_char)'\362', (u_char)'\363',
1793  	(u_char)'\364', (u_char)'\365', (u_char)'\366', (u_char)'\367',
1794  	(u_char)'\370', (u_char)'\371', (u_char)'\372', (u_char)'\373',
1795  	(u_char)'\374', (u_char)'\375', (u_char)'\376', (u_char)'\377',
1796  };
1797  int
1798  pcap_strcasecmp(const char *s1, const char *s2)
1799  {
1800  	register const u_char	*cm = charmap,
1801  				*us1 = (const u_char *)s1,
1802  				*us2 = (const u_char *)s2;
1803  	while (cm[*us1] == cm[*us2++])
1804  		if (*us1++ == '\0')
1805  			return(0);
1806  	return (cm[*us1] - cm[*--us2]);
1807  }
1808  struct dlt_choice {
1809  	const char *name;
1810  	const char *description;
1811  	int	dlt;
1812  };
1813  #define DLT_CHOICE(code, description) { #code, description, DLT_ ## code }
1814  #define DLT_CHOICE_SENTINEL { NULL, NULL, 0 }
1815  static struct dlt_choice dlt_choices[] = {
1816  	DLT_CHOICE(NULL, "BSD loopback"),
1817  	DLT_CHOICE(EN10MB, "Ethernet"),
1818  	DLT_CHOICE(IEEE802, "Token ring"),
1819  	DLT_CHOICE(ARCNET, "BSD ARCNET"),
1820  	DLT_CHOICE(SLIP, "SLIP"),
1821  	DLT_CHOICE(PPP, "PPP"),
1822  	DLT_CHOICE(FDDI, "FDDI"),
1823  	DLT_CHOICE(ATM_RFC1483, "RFC 1483 LLC-encapsulated ATM"),
1824  	DLT_CHOICE(RAW, "Raw IP"),
1825  	DLT_CHOICE(SLIP_BSDOS, "BSD/OS SLIP"),
1826  	DLT_CHOICE(PPP_BSDOS, "BSD/OS PPP"),
1827  	DLT_CHOICE(ATM_CLIP, "Linux Classical IP over ATM"),
1828  	DLT_CHOICE(PPP_SERIAL, "PPP over serial"),
1829  	DLT_CHOICE(PPP_ETHER, "PPPoE"),
1830  	DLT_CHOICE(SYMANTEC_FIREWALL, "Symantec Firewall"),
1831  	DLT_CHOICE(C_HDLC, "Cisco HDLC"),
1832  	DLT_CHOICE(IEEE802_11, "802.11"),
1833  	DLT_CHOICE(FRELAY, "Frame Relay"),
1834  	DLT_CHOICE(LOOP, "OpenBSD loopback"),
1835  	DLT_CHOICE(ENC, "OpenBSD encapsulated IP"),
1836  	DLT_CHOICE(LINUX_SLL, "Linux cooked v1"),
1837  	DLT_CHOICE(LTALK, "Localtalk"),
1838  	DLT_CHOICE(PFLOG, "OpenBSD pflog file"),
1839  	DLT_CHOICE(PFSYNC, "Packet filter state syncing"),
1840  	DLT_CHOICE(PRISM_HEADER, "802.11 plus Prism header"),
1841  	DLT_CHOICE(IP_OVER_FC, "RFC 2625 IP-over-Fibre Channel"),
1842  	DLT_CHOICE(SUNATM, "Sun raw ATM"),
1843  	DLT_CHOICE(IEEE802_11_RADIO, "802.11 plus radiotap header"),
1844  	DLT_CHOICE(ARCNET_LINUX, "Linux ARCNET"),
1845  	DLT_CHOICE(JUNIPER_MLPPP, "Juniper Multi-Link PPP"),
1846  	DLT_CHOICE(JUNIPER_MLFR, "Juniper Multi-Link Frame Relay"),
1847  	DLT_CHOICE(JUNIPER_ES, "Juniper Encryption Services PIC"),
1848  	DLT_CHOICE(JUNIPER_GGSN, "Juniper GGSN PIC"),
1849  	DLT_CHOICE(JUNIPER_MFR, "Juniper FRF.16 Frame Relay"),
1850  	DLT_CHOICE(JUNIPER_ATM2, "Juniper ATM2 PIC"),
1851  	DLT_CHOICE(JUNIPER_SERVICES, "Juniper Advanced Services PIC"),
1852  	DLT_CHOICE(JUNIPER_ATM1, "Juniper ATM1 PIC"),
1853  	DLT_CHOICE(APPLE_IP_OVER_IEEE1394, "Apple IP-over-IEEE 1394"),
1854  	DLT_CHOICE(MTP2_WITH_PHDR, "SS7 MTP2 with Pseudo-header"),
1855  	DLT_CHOICE(MTP2, "SS7 MTP2"),
1856  	DLT_CHOICE(MTP3, "SS7 MTP3"),
1857  	DLT_CHOICE(SCCP, "SS7 SCCP"),
1858  	DLT_CHOICE(DOCSIS, "DOCSIS"),
1859  	DLT_CHOICE(LINUX_IRDA, "Linux IrDA"),
1860  	DLT_CHOICE(IEEE802_11_RADIO_AVS, "802.11 plus AVS radio information header"),
1861  	DLT_CHOICE(JUNIPER_MONITOR, "Juniper Passive Monitor PIC"),
1862  	DLT_CHOICE(BACNET_MS_TP, "BACnet MS/TP"),
1863  	DLT_CHOICE(PPP_PPPD, "PPP for pppd, with direction flag"),
1864  	DLT_CHOICE(JUNIPER_PPPOE, "Juniper PPPoE"),
1865  	DLT_CHOICE(JUNIPER_PPPOE_ATM, "Juniper PPPoE/ATM"),
1866  	DLT_CHOICE(GPRS_LLC, "GPRS LLC"),
1867  	DLT_CHOICE(GPF_T, "GPF-T"),
1868  	DLT_CHOICE(GPF_F, "GPF-F"),
1869  	DLT_CHOICE(JUNIPER_PIC_PEER, "Juniper PIC Peer"),
1870  	DLT_CHOICE(ERF_ETH, "Ethernet with Endace ERF header"),
1871  	DLT_CHOICE(ERF_POS, "Packet-over-SONET with Endace ERF header"),
1872  	DLT_CHOICE(LINUX_LAPD, "Linux vISDN LAPD"),
1873  	DLT_CHOICE(JUNIPER_ETHER, "Juniper Ethernet"),
1874  	DLT_CHOICE(JUNIPER_PPP, "Juniper PPP"),
1875  	DLT_CHOICE(JUNIPER_FRELAY, "Juniper Frame Relay"),
1876  	DLT_CHOICE(JUNIPER_CHDLC, "Juniper C-HDLC"),
1877  	DLT_CHOICE(MFR, "FRF.16 Frame Relay"),
1878  	DLT_CHOICE(JUNIPER_VP, "Juniper Voice PIC"),
1879  	DLT_CHOICE(A429, "Arinc 429"),
1880  	DLT_CHOICE(A653_ICM, "Arinc 653 Interpartition Communication"),
1881  	DLT_CHOICE(USB_FREEBSD, "USB with FreeBSD header"),
1882  	DLT_CHOICE(BLUETOOTH_HCI_H4, "Bluetooth HCI UART transport layer"),
1883  	DLT_CHOICE(IEEE802_16_MAC_CPS, "IEEE 802.16 MAC Common Part Sublayer"),
1884  	DLT_CHOICE(USB_LINUX, "USB with Linux header"),
1885  	DLT_CHOICE(CAN20B, "Controller Area Network (CAN) v. 2.0B"),
1886  	DLT_CHOICE(IEEE802_15_4_LINUX, "IEEE 802.15.4 with Linux padding"),
1887  	DLT_CHOICE(PPI, "Per-Packet Information"),
1888  	DLT_CHOICE(IEEE802_16_MAC_CPS_RADIO, "IEEE 802.16 MAC Common Part Sublayer plus radiotap header"),
1889  	DLT_CHOICE(JUNIPER_ISM, "Juniper Integrated Service Module"),
1890  	DLT_CHOICE(IEEE802_15_4, "IEEE 802.15.4 with FCS"),
1891  	DLT_CHOICE(SITA, "SITA pseudo-header"),
1892  	DLT_CHOICE(ERF, "Endace ERF header"),
1893  	DLT_CHOICE(RAIF1, "Ethernet with u10 Networks pseudo-header"),
1894  	DLT_CHOICE(IPMB_KONTRON, "IPMB with Kontron pseudo-header"),
1895  	DLT_CHOICE(JUNIPER_ST, "Juniper Secure Tunnel"),
1896  	DLT_CHOICE(BLUETOOTH_HCI_H4_WITH_PHDR, "Bluetooth HCI UART transport layer plus pseudo-header"),
1897  	DLT_CHOICE(AX25_KISS, "AX.25 with KISS header"),
1898  	DLT_CHOICE(IPMB_LINUX, "IPMB with Linux/Pigeon Point pseudo-header"),
1899  	DLT_CHOICE(IEEE802_15_4_NONASK_PHY, "IEEE 802.15.4 with non-ASK PHY data"),
1900  	DLT_CHOICE(MPLS, "MPLS with label as link-layer header"),
1901  	DLT_CHOICE(LINUX_EVDEV, "Linux evdev events"),
1902  	DLT_CHOICE(USB_LINUX_MMAPPED, "USB with padded Linux header"),
1903  	DLT_CHOICE(DECT, "DECT"),
1904  	DLT_CHOICE(AOS, "AOS Space Data Link protocol"),
1905  	DLT_CHOICE(WIHART, "WirelessHART"),
1906  	DLT_CHOICE(FC_2, "Fibre Channel FC-2"),
1907  	DLT_CHOICE(FC_2_WITH_FRAME_DELIMS, "Fibre Channel FC-2 with frame delimiters"),
1908  	DLT_CHOICE(IPNET, "Solaris ipnet"),
1909  	DLT_CHOICE(CAN_SOCKETCAN, "CAN-bus with SocketCAN headers"),
1910  	DLT_CHOICE(IPV4, "Raw IPv4"),
1911  	DLT_CHOICE(IPV6, "Raw IPv6"),
1912  	DLT_CHOICE(IEEE802_15_4_NOFCS, "IEEE 802.15.4 without FCS"),
1913  	DLT_CHOICE(DBUS, "D-Bus"),
1914  	DLT_CHOICE(JUNIPER_VS, "Juniper Virtual Server"),
1915  	DLT_CHOICE(JUNIPER_SRX_E2E, "Juniper SRX E2E"),
1916  	DLT_CHOICE(JUNIPER_FIBRECHANNEL, "Juniper Fibre Channel"),
1917  	DLT_CHOICE(DVB_CI, "DVB-CI"),
1918  	DLT_CHOICE(MUX27010, "MUX27010"),
1919  	DLT_CHOICE(STANAG_5066_D_PDU, "STANAG 5066 D_PDUs"),
1920  	DLT_CHOICE(JUNIPER_ATM_CEMIC, "Juniper ATM CEMIC"),
1921  	DLT_CHOICE(NFLOG, "Linux netfilter log messages"),
1922  	DLT_CHOICE(NETANALYZER, "Ethernet with Hilscher netANALYZER pseudo-header"),
1923  	DLT_CHOICE(NETANALYZER_TRANSPARENT, "Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD"),
1924  	DLT_CHOICE(IPOIB, "RFC 4391 IP-over-Infiniband"),
1925  	DLT_CHOICE(MPEG_2_TS, "MPEG-2 transport stream"),
1926  	DLT_CHOICE(NG40, "ng40 protocol tester Iub/Iur"),
1927  	DLT_CHOICE(NFC_LLCP, "NFC LLCP PDUs with pseudo-header"),
1928  	DLT_CHOICE(INFINIBAND, "InfiniBand"),
1929  	DLT_CHOICE(SCTP, "SCTP"),
1930  	DLT_CHOICE(USBPCAP, "USB with USBPcap header"),
1931  	DLT_CHOICE(RTAC_SERIAL, "Schweitzer Engineering Laboratories RTAC packets"),
1932  	DLT_CHOICE(BLUETOOTH_LE_LL, "Bluetooth Low Energy air interface"),
1933  	DLT_CHOICE(NETLINK, "Linux netlink"),
1934  	DLT_CHOICE(BLUETOOTH_LINUX_MONITOR, "Bluetooth Linux Monitor"),
1935  	DLT_CHOICE(BLUETOOTH_BREDR_BB, "Bluetooth Basic Rate/Enhanced Data Rate baseband packets"),
1936  	DLT_CHOICE(BLUETOOTH_LE_LL_WITH_PHDR, "Bluetooth Low Energy air interface with pseudo-header"),
1937  	DLT_CHOICE(PROFIBUS_DL, "PROFIBUS data link layer"),
1938  	DLT_CHOICE(PKTAP, "Apple DLT_PKTAP"),
1939  	DLT_CHOICE(EPON, "Ethernet with 802.3 Clause 65 EPON preamble"),
1940  	DLT_CHOICE(IPMI_HPM_2, "IPMI trace packets"),
1941  	DLT_CHOICE(ZWAVE_R1_R2, "Z-Wave RF profile R1 and R2 packets"),
1942  	DLT_CHOICE(ZWAVE_R3, "Z-Wave RF profile R3 packets"),
1943  	DLT_CHOICE(WATTSTOPPER_DLM, "WattStopper Digital Lighting Management (DLM) and Legrand Nitoo Open protocol"),
1944  	DLT_CHOICE(ISO_14443, "ISO 14443 messages"),
1945  	DLT_CHOICE(RDS, "IEC 62106 Radio Data System groups"),
1946  	DLT_CHOICE(USB_DARWIN, "USB with Darwin header"),
1947  	DLT_CHOICE(OPENFLOW, "OpenBSD DLT_OPENFLOW"),
1948  	DLT_CHOICE(SDLC, "IBM SDLC frames"),
1949  	DLT_CHOICE(TI_LLN_SNIFFER, "TI LLN sniffer frames"),
1950  	DLT_CHOICE(VSOCK, "Linux vsock"),
1951  	DLT_CHOICE(NORDIC_BLE, "Nordic Semiconductor Bluetooth LE sniffer frames"),
1952  	DLT_CHOICE(DOCSIS31_XRA31, "Excentis XRA-31 DOCSIS 3.1 RF sniffer frames"),
1953  	DLT_CHOICE(ETHERNET_MPACKET, "802.3br mPackets"),
1954  	DLT_CHOICE(DISPLAYPORT_AUX, "DisplayPort AUX channel monitoring data"),
1955  	DLT_CHOICE(LINUX_SLL2, "Linux cooked v2"),
1956  	DLT_CHOICE(OPENVIZSLA, "OpenVizsla USB"),
1957  	DLT_CHOICE(EBHSCR, "Elektrobit High Speed Capture and Replay (EBHSCR)"),
1958  	DLT_CHOICE(VPP_DISPATCH, "VPP graph dispatch tracer"),
1959  	DLT_CHOICE(DSA_TAG_BRCM, "Broadcom tag"),
1960  	DLT_CHOICE(DSA_TAG_BRCM_PREPEND, "Broadcom tag (prepended)"),
1961  	DLT_CHOICE(IEEE802_15_4_TAP, "IEEE 802.15.4 with pseudo-header"),
1962  	DLT_CHOICE(DSA_TAG_DSA, "Marvell DSA"),
1963  	DLT_CHOICE(DSA_TAG_EDSA, "Marvell EDSA"),
1964  	DLT_CHOICE(ELEE, "ELEE lawful intercept packets"),
1965  	DLT_CHOICE(Z_WAVE_SERIAL, "Z-Wave serial frames between host and chip"),
1966  	DLT_CHOICE(USB_2_0, "USB 2.0/1.1/1.0 as transmitted over the cable"),
1967  	DLT_CHOICE(ATSC_ALP, "ATSC Link-Layer Protocol packets"),
1968  	DLT_CHOICE(ETW, "Event Tracing for Windows messages"),
1969  	DLT_CHOICE(NETANALYZER_NG, "Hilscher netANALYZER NG pseudo-footer"),
1970  	DLT_CHOICE(ZBOSS_NCP, "ZBOSS NCP protocol with pseudo-header"),
1971  	DLT_CHOICE(USB_2_0_LOW_SPEED, "Low-Speed USB 2.0/1.1/1.0 as transmitted over the cable"),
1972  	DLT_CHOICE(USB_2_0_FULL_SPEED, "Full-Speed USB 2.0/1.1/1.0 as transmitted over the cable"),
1973  	DLT_CHOICE(USB_2_0_HIGH_SPEED, "High-Speed USB 2.0 as transmitted over the cable"),
1974  	DLT_CHOICE(AUERSWALD_LOG, "Auerswald Logger Protocol"),
1975  	DLT_CHOICE(ZWAVE_TAP, "Z-Wave packets with a TAP meta-data header"),
1976  	DLT_CHOICE(SILABS_DEBUG_CHANNEL, "Silicon Labs debug channel protocol"),
1977  	DLT_CHOICE(FIRA_UCI, "Ultra-wideband controller interface protocol"),
1978  	DLT_CHOICE_SENTINEL
1979  };
1980  int
1981  pcap_datalink_name_to_val(const char *name)
1982  {
1983  	int i;
1984  	for (i = 0; dlt_choices[i].name != NULL; i++) {
1985  		if (pcap_strcasecmp(dlt_choices[i].name, name) == 0)
1986  			return (dlt_choices[i].dlt);
1987  	}
1988  	return (-1);
1989  }
1990  const char *
1991  pcap_datalink_val_to_name(int dlt)
1992  {
1993  	int i;
1994  	for (i = 0; dlt_choices[i].name != NULL; i++) {
1995  		if (dlt_choices[i].dlt == dlt)
1996  			return (dlt_choices[i].name);
1997  	}
1998  	return (NULL);
1999  }
2000  const char *
2001  pcap_datalink_val_to_description(int dlt)
2002  {
2003  	int i;
2004  	for (i = 0; dlt_choices[i].name != NULL; i++) {
2005  		if (dlt_choices[i].dlt == dlt)
2006  			return (dlt_choices[i].description);
2007  	}
2008  	return (NULL);
2009  }
2010  const char *
2011  pcap_datalink_val_to_description_or_dlt(int dlt)
2012  {
2013          static thread_local char unkbuf[40];
2014          const char *description;
2015          description = pcap_datalink_val_to_description(dlt);
2016          if (description != NULL) {
2017                  return description;
2018          } else {
2019                  (void)snprintf(unkbuf, sizeof(unkbuf), "DLT %d", dlt);
2020                  return unkbuf;
2021          }
2022  }
2023  struct tstamp_type_choice {
2024  	const char *name;
2025  	const char *description;
2026  	int	type;
2027  };
2028  static struct tstamp_type_choice tstamp_type_choices[] = {
2029  	{ "host", "Host", PCAP_TSTAMP_HOST },
2030  	{ "host_lowprec", "Host, low precision", PCAP_TSTAMP_HOST_LOWPREC },
2031  	{ "host_hiprec", "Host, high precision", PCAP_TSTAMP_HOST_HIPREC },
2032  	{ "adapter", "Adapter", PCAP_TSTAMP_ADAPTER },
2033  	{ "adapter_unsynced", "Adapter, not synced with system time", PCAP_TSTAMP_ADAPTER_UNSYNCED },
2034  	{ "host_hiprec_unsynced", "Host, high precision, not synced with system time", PCAP_TSTAMP_HOST_HIPREC_UNSYNCED },
2035  	{ NULL, NULL, 0 }
2036  };
2037  int
2038  pcap_tstamp_type_name_to_val(const char *name)
2039  {
2040  	int i;
2041  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2042  		if (pcap_strcasecmp(tstamp_type_choices[i].name, name) == 0)
2043  			return (tstamp_type_choices[i].type);
2044  	}
2045  	return (PCAP_ERROR);
2046  }
2047  const char *
2048  pcap_tstamp_type_val_to_name(int tstamp_type)
2049  {
2050  	int i;
2051  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2052  		if (tstamp_type_choices[i].type == tstamp_type)
2053  			return (tstamp_type_choices[i].name);
2054  	}
2055  	return (NULL);
2056  }
2057  const char *
2058  pcap_tstamp_type_val_to_description(int tstamp_type)
2059  {
2060  	int i;
2061  	for (i = 0; tstamp_type_choices[i].name != NULL; i++) {
2062  		if (tstamp_type_choices[i].type == tstamp_type)
2063  			return (tstamp_type_choices[i].description);
2064  	}
2065  	return (NULL);
2066  }
2067  int
2068  pcap_snapshot(pcap_t *p)
2069  {
2070  	if (!p->activated)
2071  		return (PCAP_ERROR_NOT_ACTIVATED);
2072  	return (p->snapshot);
2073  }
2074  int
2075  pcap_is_swapped(pcap_t *p)
2076  {
2077  	if (!p->activated)
2078  		return (PCAP_ERROR_NOT_ACTIVATED);
2079  	return (p->swapped);
2080  }
2081  int
2082  pcap_major_version(pcap_t *p)
2083  {
2084  	if (!p->activated)
2085  		return (PCAP_ERROR_NOT_ACTIVATED);
2086  	return (p->version_major);
2087  }
2088  int
2089  pcap_minor_version(pcap_t *p)
2090  {
2091  	if (!p->activated)
2092  		return (PCAP_ERROR_NOT_ACTIVATED);
2093  	return (p->version_minor);
2094  }
2095  int
2096  pcap_bufsize(pcap_t *p)
2097  {
2098  	if (!p->activated)
2099  		return (PCAP_ERROR_NOT_ACTIVATED);
2100  	return (p->bufsize);
2101  }
2102  FILE *
2103  pcap_file(pcap_t *p)
2104  {
2105  	return (p->rfile);
2106  }
2107  #ifdef _WIN32
2108  int
2109  pcap_fileno(pcap_t *p)
2110  {
2111  	if (p->handle != INVALID_HANDLE_VALUE) {
2112  DIAG_OFF_NARROWING
2113  		return ((int)(intptr_t)p->handle);
2114  DIAG_ON_NARROWING
2115  	} else
2116  		return (PCAP_ERROR);
2117  }
2118  #else &bsol;* _WIN32 */
2119  int
2120  pcap_fileno(pcap_t *p)
2121  {
2122  	return (p->fd);
2123  }
2124  #endif &bsol;* _WIN32 */
2125  #if !defined(_WIN32) && !defined(MSDOS)
2126  int
2127  pcap_get_selectable_fd(pcap_t *p)
2128  {
2129  	return (p->selectable_fd);
2130  }
2131  const struct timeval *
2132  pcap_get_required_select_timeout(pcap_t *p)
2133  {
2134  	return (p->required_select_timeout);
2135  }
2136  #endif
2137  void
2138  pcap_perror(pcap_t *p, const char *prefix)
2139  {
2140  	fprintf(stderr, "%s: %s\n", prefix, p->errbuf);
2141  }
2142  char *
2143  pcap_geterr(pcap_t *p)
2144  {
2145  	return (p->errbuf);
2146  }
2147  int
2148  pcap_getnonblock(pcap_t *p, char *errbuf)
2149  {
2150  	int ret;
2151  	ret = p->getnonblock_op(p);
2152  	if (ret == -1) {
2153  		pcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
2154  	}
2155  	return (ret);
2156  }
2157  #if !defined(_WIN32) && !defined(MSDOS)
2158  int
2159  pcap_getnonblock_fd(pcap_t *p)
2160  {
2161  	int fdflags;
2162  	fdflags = fcntl(p->fd, F_GETFL, 0);
2163  	if (fdflags == -1) {
2164  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2165  		    errno, "F_GETFL");
2166  		return (-1);
2167  	}
2168  	if (fdflags & O_NONBLOCK)
2169  		return (1);
2170  	else
2171  		return (0);
2172  }
2173  #endif
2174  int
2175  pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)
2176  {
2177  	int ret;
2178  	ret = p->setnonblock_op(p, nonblock);
2179  	if (ret == -1) {
2180  		pcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);
2181  	}
2182  	return (ret);
2183  }
2184  #if !defined(_WIN32) && !defined(MSDOS)
2185  int
2186  pcap_setnonblock_fd(pcap_t *p, int nonblock)
2187  {
2188  	int fdflags;
2189  	fdflags = fcntl(p->fd, F_GETFL, 0);
2190  	if (fdflags == -1) {
2191  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2192  		    errno, "F_GETFL");
2193  		return (-1);
2194  	}
2195  	if (nonblock)
2196  		fdflags |= O_NONBLOCK;
2197  	else
2198  		fdflags &= ~O_NONBLOCK;
2199  	if (fcntl(p->fd, F_SETFL, fdflags) == -1) {
2200  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2201  		    errno, "F_SETFL");
2202  		return (-1);
2203  	}
2204  	return (0);
2205  }
2206  #endif
2207  const char *
2208  pcap_statustostr(int errnum)
2209  {
2210  	static thread_local char ebuf[15+10+1];
2211  	switch (errnum) {
2212  	case PCAP_WARNING:
2213  		return("Generic warning");
2214  	case PCAP_WARNING_TSTAMP_TYPE_NOTSUP:
2215  		return ("That type of time stamp is not supported by that device");
2216  	case PCAP_WARNING_PROMISC_NOTSUP:
2217  		return ("That device doesn't support promiscuous mode");
2218  	case PCAP_ERROR:
2219  		return("Generic error");
2220  	case PCAP_ERROR_BREAK:
2221  		return("Loop terminated by pcap_breakloop");
2222  	case PCAP_ERROR_NOT_ACTIVATED:
2223  		return("The pcap_t has not been activated");
2224  	case PCAP_ERROR_ACTIVATED:
2225  		return ("The setting can't be changed after the pcap_t is activated");
2226  	case PCAP_ERROR_NO_SUCH_DEVICE:
2227  		return ("No such device exists");
2228  	case PCAP_ERROR_RFMON_NOTSUP:
2229  		return ("That device doesn't support monitor mode");
2230  	case PCAP_ERROR_NOT_RFMON:
2231  		return ("That operation is supported only in monitor mode");
2232  	case PCAP_ERROR_PERM_DENIED:
2233  		return ("You don't have permission to perform this capture on that device");
2234  	case PCAP_ERROR_IFACE_NOT_UP:
2235  		return ("That device is not up");
2236  	case PCAP_ERROR_CANTSET_TSTAMP_TYPE:
2237  		return ("That device doesn't support setting the time stamp type");
2238  	case PCAP_ERROR_PROMISC_PERM_DENIED:
2239  		return ("You don't have permission to capture in promiscuous mode on that device");
2240  	case PCAP_ERROR_TSTAMP_PRECISION_NOTSUP:
2241  		return ("That device doesn't support that time stamp precision");
2242  	}
2243  	(void)snprintf(ebuf, sizeof ebuf, "Unknown error: %d", errnum);
2244  	return(ebuf);
2245  }
2246  const char *
2247  pcap_strerror(int errnum)
2248  {
2249  #ifdef HAVE_STRERROR
2250  #ifdef _WIN32
2251  	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
2252  	errno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);
2253  	if (err != 0) &bsol;* err = 0 if successful */
2254  		pcap_strlcpy(errbuf, "strerror_s() error", PCAP_ERRBUF_SIZE);
2255  	return (errbuf);
2256  #else
2257  	return (strerror(errnum));
2258  #endif &bsol;* _WIN32 */
2259  #else
2260  	extern int sys_nerr;
2261  	extern const char *const sys_errlist[];
2262  	static thread_local char errbuf[PCAP_ERRBUF_SIZE];
2263  	if ((unsigned int)errnum < sys_nerr)
2264  		return ((char *)sys_errlist[errnum]);
2265  	(void)snprintf(errbuf, sizeof errbuf, "Unknown error: %d", errnum);
2266  	return (errbuf);
2267  #endif
2268  }
2269  int
2270  pcap_setfilter(pcap_t *p, struct bpf_program *fp)
2271  {
2272  	return (p->setfilter_op(p, fp));
2273  }
2274  int
2275  pcap_setdirection(pcap_t *p, pcap_direction_t d)
2276  {
2277  	if (p->setdirection_op == NULL) {
2278  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2279  		    "Setting direction is not supported on this device");
2280  		return (-1);
2281  	} else {
2282  		switch (d) {
2283  		case PCAP_D_IN:
2284  		case PCAP_D_OUT:
2285  		case PCAP_D_INOUT:
2286  			return (p->setdirection_op(p, d));
2287  		default:
2288  			snprintf(p->errbuf, sizeof(p->errbuf),
2289  			    "Invalid direction");
2290  			return (-1);
2291  		}
2292  	}
2293  }
2294  int
2295  pcap_stats(pcap_t *p, struct pcap_stat *ps)
2296  {
2297  	return (p->stats_op(p, ps));
2298  }
2299  #ifdef _WIN32
2300  struct pcap_stat *
2301  pcap_stats_ex(pcap_t *p, int *pcap_stat_size)
2302  {
2303  	return (p->stats_ex_op(p, pcap_stat_size));
2304  }
2305  int
2306  pcap_setbuff(pcap_t *p, int dim)
2307  {
2308  	return (p->setbuff_op(p, dim));
2309  }
2310  int
2311  pcap_setmode(pcap_t *p, int mode)
2312  {
2313  	return (p->setmode_op(p, mode));
2314  }
2315  int
2316  pcap_setmintocopy(pcap_t *p, int size)
2317  {
2318  	return (p->setmintocopy_op(p, size));
2319  }
2320  HANDLE
2321  pcap_getevent(pcap_t *p)
2322  {
2323  	return (p->getevent_op(p));
2324  }
2325  int
2326  pcap_oid_get_request(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)
2327  {
2328  	return (p->oid_get_request_op(p, oid, data, lenp));
2329  }
2330  int
2331  pcap_oid_set_request(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp)
2332  {
2333  	return (p->oid_set_request_op(p, oid, data, lenp));
2334  }
2335  pcap_send_queue *
2336  pcap_sendqueue_alloc(u_int memsize)
2337  {
2338  	pcap_send_queue *tqueue;
2339  	tqueue = (pcap_send_queue *)malloc(sizeof(pcap_send_queue));
2340  	if (tqueue == NULL){
2341  		return (NULL);
2342  	}
2343  	tqueue->buffer = (char *)malloc(memsize);
2344  	if (tqueue->buffer == NULL) {
2345  		free(tqueue);
2346  		return (NULL);
2347  	}
2348  	tqueue->maxlen = memsize;
2349  	tqueue->len = 0;
2350  	return (tqueue);
2351  }
2352  void
2353  pcap_sendqueue_destroy(pcap_send_queue *queue)
2354  {
2355  	free(queue->buffer);
2356  	free(queue);
2357  }
2358  int
2359  pcap_sendqueue_queue(pcap_send_queue *queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)
2360  {
2361  	if (queue->len + sizeof(struct pcap_pkthdr) + pkt_header->caplen > queue->maxlen){
2362  		return (-1);
2363  	}
2364  	memcpy(queue->buffer + queue->len, pkt_header, sizeof(struct pcap_pkthdr));
2365  	queue->len += sizeof(struct pcap_pkthdr);
2366  	memcpy(queue->buffer + queue->len, pkt_data, pkt_header->caplen);
2367  	queue->len += pkt_header->caplen;
2368  	return (0);
2369  }
2370  u_int
2371  pcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue, int sync)
2372  {
2373  	return (p->sendqueue_transmit_op(p, queue, sync));
2374  }
2375  int
2376  pcap_setuserbuffer(pcap_t *p, int size)
2377  {
2378  	return (p->setuserbuffer_op(p, size));
2379  }
2380  int
2381  pcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)
2382  {
2383  	return (p->live_dump_op(p, filename, maxsize, maxpacks));
2384  }
2385  int
2386  pcap_live_dump_ended(pcap_t *p, int sync)
2387  {
2388  	return (p->live_dump_ended_op(p, sync));
2389  }
2390  PAirpcapHandle
2391  pcap_get_airpcap_handle(pcap_t *p)
2392  {
2393  	PAirpcapHandle handle;
2394  	handle = p->get_airpcap_handle_op(p);
2395  	if (handle == NULL) {
2396  		(void)snprintf(p->errbuf, sizeof(p->errbuf),
2397  		    "This isn't an AirPcap device");
2398  	}
2399  	return (handle);
2400  }
2401  #endif
2402  static struct pcap *pcaps_to_close;
2403  static int did_atexit;
2404  static void
2405  pcap_close_all(void)
2406  {
2407  	struct pcap *handle;
2408  	while ((handle = pcaps_to_close) != NULL) {
2409  		pcap_close(handle);
2410  		if (pcaps_to_close == handle)
2411  			abort();
2412  	}
2413  }
2414  int
2415  pcap_do_addexit(pcap_t *p)
2416  {
2417  	if (!did_atexit) {
2418  		if (atexit(pcap_close_all) != 0) {
2419  			pcap_strlcpy(p->errbuf, "atexit failed", PCAP_ERRBUF_SIZE);
2420  			return (0);
2421  		}
2422  		did_atexit = 1;
2423  	}
2424  	return (1);
2425  }
2426  void
2427  pcap_add_to_pcaps_to_close(pcap_t *p)
2428  {
2429  	p->next = pcaps_to_close;
2430  	pcaps_to_close = p;
2431  }
2432  void
2433  pcap_remove_from_pcaps_to_close(pcap_t *p)
2434  {
2435  	pcap_t *pc, *prevpc;
2436  	for (pc = pcaps_to_close, prevpc = NULL; pc != NULL;
2437  	    prevpc = pc, pc = pc->next) {
2438  		if (pc == p) {
2439  			if (prevpc == NULL) {
2440  				pcaps_to_close = pc->next;
2441  			} else {
2442  				prevpc->next = pc->next;
2443  			}
2444  			break;
2445  		}
2446  	}
2447  }
2448  void
2449  pcap_breakloop_common(pcap_t *p)
2450  {
2451  	p->break_loop = 1;
2452  }
2453  void
2454  pcap_cleanup_live_common(pcap_t *p)
2455  {
2456  	if (p->opt.device != NULL) {
2457  		free(p->opt.device);
2458  		p->opt.device = NULL;
2459  	}
2460  	if (p->buffer != NULL) {
2461  		free(p->buffer);
2462  		p->buffer = NULL;
2463  	}
2464  	if (p->dlt_list != NULL) {
2465  		free(p->dlt_list);
2466  		p->dlt_list = NULL;
2467  		p->dlt_count = 0;
2468  	}
2469  	if (p->tstamp_type_list != NULL) {
2470  		free(p->tstamp_type_list);
2471  		p->tstamp_type_list = NULL;
2472  		p->tstamp_type_count = 0;
2473  	}
2474  	if (p->tstamp_precision_list != NULL) {
2475  		free(p->tstamp_precision_list);
2476  		p->tstamp_precision_list = NULL;
2477  		p->tstamp_precision_count = 0;
2478  	}
2479  	pcap_freecode(&p->fcode);
2480  #if !defined(_WIN32) && !defined(MSDOS)
2481  	if (p->fd >= 0) {
2482  		close(p->fd);
2483  		p->fd = -1;
2484  	}
2485  	p->selectable_fd = -1;
2486  #endif
2487  }
2488  int
2489  pcap_sendpacket(pcap_t *p, const u_char *buf, int size)
2490  {
2491  	if (size <= 0) {
2492  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2493  		    errno, "The number of bytes to be sent must be positive");
2494  		return (PCAP_ERROR);
2495  	}
2496  	if (p->inject_op(p, buf, size) == -1)
2497  		return (-1);
2498  	return (0);
2499  }
2500  int
2501  pcap_inject(pcap_t *p, const void *buf, size_t size)
2502  {
2503  	if (size > INT_MAX) {
2504  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2505  		    errno, "More than %d bytes cannot be injected", INT_MAX);
2506  		return (PCAP_ERROR);
2507  	}
2508  	if (size == 0) {
2509  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
2510  		    errno, "The number of bytes to be injected must not be zero");
2511  		return (PCAP_ERROR);
2512  	}
2513  	return (p->inject_op(p, buf, (int)size));
2514  }
2515  void
2516  pcap_close(pcap_t *p)
2517  {
2518  	p->cleanup_op(p);
2519  	free(p);
2520  }
2521  #ifdef _WIN32
2522  pcap_code_handle_t
2523  pcap_load_code(const char *name)
2524  {
2525  	CHAR path[MAX_PATH];
2526  	CHAR fullFileName[MAX_PATH];
2527  	UINT res;
2528  	HMODULE hModule = NULL;
2529  	do
2530  	{
2531  		res = GetSystemDirectoryA(path, MAX_PATH);
2532  		if (res == 0) {
2533  			break;
2534  		}
2535  		if (res > MAX_PATH) {
2536  			SetLastError(ERROR_INSUFFICIENT_BUFFER);
2537  			break;
2538  		}
2539  		if (res + 1 + strlen(name) + 1 < MAX_PATH) {
2540  			memcpy(fullFileName, path, res * sizeof(TCHAR));
2541  			fullFileName[res] = '\\';
2542  			memcpy(&fullFileName[res + 1], name, (strlen(name) + 1) * sizeof(TCHAR));
2543  			hModule = LoadLibraryA(fullFileName);
2544  		} else
2545  			SetLastError(ERROR_INSUFFICIENT_BUFFER);
2546  	} while(FALSE);
2547  	return hModule;
2548  }
2549  pcap_funcptr_t
2550  pcap_find_function(pcap_code_handle_t code, const char *func)
2551  {
2552  	return (GetProcAddress(code, func));
2553  }
2554  #endif
2555  int
2556  pcap_offline_filter(const struct bpf_program *fp, const struct pcap_pkthdr *h,
2557      const u_char *pkt)
2558  {
2559  	const struct bpf_insn *fcode = fp->bf_insns;
2560  	if (fcode != NULL)
2561  		return (pcap_filter(fcode, pkt, h->len, h->caplen));
2562  	else
2563  		return (0);
2564  }
2565  static int
2566  pcap_can_set_rfmon_dead(pcap_t *p)
2567  {
2568  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2569  	    "Rfmon mode doesn't apply on a pcap_open_dead pcap_t");
2570  	return (PCAP_ERROR);
2571  }
2572  static int
2573  pcap_read_dead(pcap_t *p, int cnt _U_, pcap_handler callback _U_,
2574      u_char *user _U_)
2575  {
2576  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2577  	    "Packets aren't available from a pcap_open_dead pcap_t");
2578  	return (-1);
2579  }
2580  static void
2581  pcap_breakloop_dead(pcap_t *p _U_)
2582  {
2583  }
2584  static int
2585  pcap_inject_dead(pcap_t *p, const void *buf _U_, int size _U_)
2586  {
2587  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2588  	    "Packets can't be sent on a pcap_open_dead pcap_t");
2589  	return (-1);
2590  }
2591  static int
2592  pcap_setfilter_dead(pcap_t *p, struct bpf_program *fp _U_)
2593  {
2594  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2595  	    "A filter cannot be set on a pcap_open_dead pcap_t");
2596  	return (-1);
2597  }
2598  static int
2599  pcap_setdirection_dead(pcap_t *p, pcap_direction_t d _U_)
2600  {
2601  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2602  	    "The packet direction cannot be set on a pcap_open_dead pcap_t");
2603  	return (-1);
2604  }
2605  static int
2606  pcap_set_datalink_dead(pcap_t *p, int dlt _U_)
2607  {
2608  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2609  	    "The link-layer header type cannot be set on a pcap_open_dead pcap_t");
2610  	return (-1);
2611  }
2612  static int
2613  pcap_getnonblock_dead(pcap_t *p)
2614  {
2615  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2616  	    "A pcap_open_dead pcap_t does not have a non-blocking mode setting");
2617  	return (-1);
2618  }
2619  static int
2620  pcap_setnonblock_dead(pcap_t *p, int nonblock _U_)
2621  {
2622  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2623  	    "A pcap_open_dead pcap_t does not have a non-blocking mode setting");
2624  	return (-1);
2625  }
2626  static int
2627  pcap_stats_dead(pcap_t *p, struct pcap_stat *ps _U_)
2628  {
2629  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2630  	    "Statistics aren't available from a pcap_open_dead pcap_t");
2631  	return (-1);
2632  }
2633  #ifdef _WIN32
2634  static struct pcap_stat *
2635  pcap_stats_ex_dead(pcap_t *p, int *pcap_stat_size _U_)
2636  {
2637  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2638  	    "Statistics aren't available from a pcap_open_dead pcap_t");
2639  	return (NULL);
2640  }
2641  static int
2642  pcap_setbuff_dead(pcap_t *p, int dim _U_)
2643  {
2644  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2645  	    "The kernel buffer size cannot be set on a pcap_open_dead pcap_t");
2646  	return (-1);
2647  }
2648  static int
2649  pcap_setmode_dead(pcap_t *p, int mode _U_)
2650  {
2651  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2652  	    "impossible to set mode on a pcap_open_dead pcap_t");
2653  	return (-1);
2654  }
2655  static int
2656  pcap_setmintocopy_dead(pcap_t *p, int size _U_)
2657  {
2658  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2659  	    "The mintocopy parameter cannot be set on a pcap_open_dead pcap_t");
2660  	return (-1);
2661  }
2662  static HANDLE
2663  pcap_getevent_dead(pcap_t *p)
2664  {
2665  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2666  	    "A pcap_open_dead pcap_t has no event handle");
2667  	return (INVALID_HANDLE_VALUE);
2668  }
2669  static int
2670  pcap_oid_get_request_dead(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
2671      size_t *lenp _U_)
2672  {
2673  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2674  	    "An OID get request cannot be performed on a pcap_open_dead pcap_t");
2675  	return (PCAP_ERROR);
2676  }
2677  static int
2678  pcap_oid_set_request_dead(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
2679      size_t *lenp _U_)
2680  {
2681  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2682  	    "An OID set request cannot be performed on a pcap_open_dead pcap_t");
2683  	return (PCAP_ERROR);
2684  }
2685  static u_int
2686  pcap_sendqueue_transmit_dead(pcap_t *p, pcap_send_queue *queue _U_,
2687      int sync _U_)
2688  {
2689  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2690  	    "Packets cannot be transmitted on a pcap_open_dead pcap_t");
2691  	return (0);
2692  }
2693  static int
2694  pcap_setuserbuffer_dead(pcap_t *p, int size _U_)
2695  {
2696  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2697  	    "The user buffer cannot be set on a pcap_open_dead pcap_t");
2698  	return (-1);
2699  }
2700  static int
2701  pcap_live_dump_dead(pcap_t *p, char *filename _U_, int maxsize _U_,
2702      int maxpacks _U_)
2703  {
2704  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2705  	    "Live packet dumping cannot be performed on a pcap_open_dead pcap_t");
2706  	return (-1);
2707  }
2708  static int
2709  pcap_live_dump_ended_dead(pcap_t *p, int sync _U_)
2710  {
2711  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
2712  	    "Live packet dumping cannot be performed on a pcap_open_dead pcap_t");
2713  	return (-1);
2714  }
2715  static PAirpcapHandle
2716  pcap_get_airpcap_handle_dead(pcap_t *p _U_)
2717  {
2718  	return (NULL);
2719  }
2720  #endif &bsol;* _WIN32 */
2721  static void
2722  pcap_cleanup_dead(pcap_t *p _U_)
2723  {
2724  }
2725  pcap_t *
2726  pcap_open_dead_with_tstamp_precision(int linktype, int snaplen, u_int precision)
2727  {
2728  	pcap_t *p;
2729  	switch (precision) {
2730  	case PCAP_TSTAMP_PRECISION_MICRO:
2731  	case PCAP_TSTAMP_PRECISION_NANO:
2732  		break;
2733  	default:
2734  		precision = PCAP_TSTAMP_PRECISION_MICRO;
2735  		break;
2736  	}
2737  	p = malloc(sizeof(*p));
2738  	if (p == NULL)
2739  		return NULL;
2740  	memset (p, 0, sizeof(*p));
2741  	p->snapshot = snaplen;
2742  	p->linktype = linktype;
2743  	p->opt.tstamp_precision = precision;
2744  	p->can_set_rfmon_op = pcap_can_set_rfmon_dead;
2745  	p->read_op = pcap_read_dead;
2746  	p->inject_op = pcap_inject_dead;
2747  	p->setfilter_op = pcap_setfilter_dead;
2748  	p->setdirection_op = pcap_setdirection_dead;
2749  	p->set_datalink_op = pcap_set_datalink_dead;
2750  	p->getnonblock_op = pcap_getnonblock_dead;
2751  	p->setnonblock_op = pcap_setnonblock_dead;
2752  	p->stats_op = pcap_stats_dead;
2753  #ifdef _WIN32
2754  	p->stats_ex_op = pcap_stats_ex_dead;
2755  	p->setbuff_op = pcap_setbuff_dead;
2756  	p->setmode_op = pcap_setmode_dead;
2757  	p->setmintocopy_op = pcap_setmintocopy_dead;
2758  	p->getevent_op = pcap_getevent_dead;
2759  	p->oid_get_request_op = pcap_oid_get_request_dead;
2760  	p->oid_set_request_op = pcap_oid_set_request_dead;
2761  	p->sendqueue_transmit_op = pcap_sendqueue_transmit_dead;
2762  	p->setuserbuffer_op = pcap_setuserbuffer_dead;
2763  	p->live_dump_op = pcap_live_dump_dead;
2764  	p->live_dump_ended_op = pcap_live_dump_ended_dead;
2765  	p->get_airpcap_handle_op = pcap_get_airpcap_handle_dead;
2766  #endif
2767  	p->breakloop_op = pcap_breakloop_dead;
2768  	p->cleanup_op = pcap_cleanup_dead;
2769  	p->bpf_codegen_flags = 0;
2770  	p->activated = 1;
2771  	return (p);
2772  }
2773  pcap_t *
2774  pcap_open_dead(int linktype, int snaplen)
2775  {
2776  	return (pcap_open_dead_with_tstamp_precision(linktype, snaplen,
2777  	    PCAP_TSTAMP_PRECISION_MICRO));
2778  }
2779  #ifdef YYDEBUG
2780  PCAP_API void pcap_set_parser_debug(int value);
2781  PCAP_API_DEF void
2782  pcap_set_parser_debug(int value)
2783  {
2784  	pcap_debug = value;
2785  }
2786  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-allocate.c</h3>
            <pre><code>1  #include "libbench2/bench.h"
2  static void bounds(bench_problem *p, int *ilb, int *iub, int *olb, int *oub)
3  {
4       bench_tensor *t = tensor_append(p->sz, p->vecsz);
5       tensor_ibounds(t, ilb, iub);
6       tensor_obounds(t, olb, oub);
7       tensor_destroy(t);
8  }
9  void problem_alloc(bench_problem *p)
10  {
11       int ilb, iub, olb, oub;
12       int isz, osz;
13       bounds(p, &ilb, &iub, &olb, &oub);
14       isz = iub - ilb;
15       osz = oub - olb;
16       if (p->kind == PROBLEM_COMPLEX) {
17  	  bench_complex *in, *out;
18  	  p->iphyssz = isz;
19  	  p->inphys = in = (bench_complex *) bench_malloc(isz * sizeof(bench_complex));
20  	  p->in = in - ilb;
21  	  if (p->in_place) {
22  	       p->out = p->in;
23  	       p->outphys = p->inphys;
24  	       p->ophyssz = p->iphyssz;
25  	  } else {
26  	       p->ophyssz = osz;
27  	       p->outphys = out = (bench_complex *) bench_malloc(osz * sizeof(bench_complex));
28  	       p->out = out - olb;
29  	  }
30       } else if (p->kind == PROBLEM_R2R) {
31  	  bench_real *in, *out;
32  	  p->iphyssz = isz;
33  	  p->inphys = in = (bench_real *) bench_malloc(isz * sizeof(bench_real));
34  	  p->in = in - ilb;
35  	  if (p->in_place) {
36  	       p->out = p->in;
37  	       p->outphys = p->inphys;
38  	       p->ophyssz = p->iphyssz;
39  	  } else {
40  	       p->ophyssz = osz;
41  	       p->outphys = out = (bench_real *) bench_malloc(osz * sizeof(bench_real));
42  	       p->out = out - olb;
43  	  }
44       } else if (p->kind == PROBLEM_REAL && p->sign < 0) { &bsol;* R2HC */
45  	  bench_real *in;
46  	  bench_complex *out;
47  	  isz = isz > osz*2 ? isz : osz*2;
48  	  p->iphyssz = isz;
49  	  p->inphys = in = (bench_real *) bench_malloc(p->iphyssz * sizeof(bench_real));
50  	  p->in = in - ilb;
51  	  if (p->in_place) {
52  	       p->out = p->in;
53  	       p->outphys = p->inphys;
54  	       p->ophyssz = p->iphyssz / 2;
55  	  } else {
56  	       p->ophyssz = osz;
57  	       p->outphys = out = (bench_complex *) bench_malloc(osz * sizeof(bench_complex));
58  	       p->out = out - olb;
59  	  }
60       } else if (p->kind == PROBLEM_REAL && p->sign > 0) { &bsol;* HC2R */
61  	  bench_real *out;
62  	  bench_complex *in;
63  	  osz = osz > isz*2 ? osz : isz*2;
64  	  p->ophyssz = osz;
65  	  p->outphys = out = (bench_real *) bench_malloc(p->ophyssz * sizeof(bench_real));
66  	  p->out = out - olb;
67  	  if (p->in_place) {
68  	       p->in = p->out;
69  	       p->inphys = p->outphys;
70  	       p->iphyssz = p->ophyssz / 2;
71  	  } else {
72  	       p->iphyssz = isz;
73  	       p->inphys = in = (bench_complex *) bench_malloc(isz * sizeof(bench_complex));
74  	       p->in = in - ilb;
75  	  }
76       } else {
77  	  BENCH_ASSERT(0); &bsol;* TODO */
78       }
79  }
80  void problem_free(bench_problem *p)
81  {
82       if (p->outphys && p->outphys != p->inphys)
<span onclick='openModal()' class='match'>83  	  bench_free(p->outphys);
84       if (p->inphys)
85  	  bench_free(p->inphys);
86       tensor_destroy(p->sz);
</span>87       tensor_destroy(p->vecsz);
88  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-allocate.c</div>
                </div>
                <div class="column column_space"><pre><code>782  				free(curaddr->addr);
783  			if (curaddr->netmask)
784  				free(curaddr->netmask);
785  			if (curaddr->broadaddr)
</pre></code></div>
                <div class="column column_space"><pre><code>83  	  bench_free(p->outphys);
84       if (p->inphys)
85  	  bench_free(p->inphys);
86       tensor_destroy(p->sz);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    