
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.7507987220447285%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_generalizedtime.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  static int s_char_to_int(unsigned char x)
4  {
5     switch (x)  {
6        case '0': return 0;
7        case '1': return 1;
8        case '2': return 2;
9        case '3': return 3;
10        case '4': return 4;
11        case '5': return 5;
12        case '6': return 6;
13        case '7': return 7;
14        case '8': return 8;
15        case '9': return 9;
16        default:  return 100;
17     }
18  }
19  #define DECODE_V(y, max) do {\
20     y  = s_char_to_int(buf[x])*10 + s_char_to_int(buf[x+1]); \
21     if (y >= max) return CRYPT_INVALID_PACKET;           \
22     x += 2; \
23  } while(0)
24  #define DECODE_V4(y, max) do {\
25     y  = s_char_to_int(buf[x])*1000 + s_char_to_int(buf[x+1])*100 + s_char_to_int(buf[x+2])*10 + s_char_to_int(buf[x+3]); \
26     if (y >= max) return CRYPT_INVALID_PACKET; \
27     x += 4; \
28  } while(0)
29  int der_decode_generalizedtime(const unsigned char *in, unsigned long *inlen,
30                                 ltc_generalizedtime *out)
31  {
32     unsigned char buf[32];
33     unsigned long x;
34     int           y;
35     LTC_ARGCHK(in    != NULL);
36     LTC_ARGCHK(inlen != NULL);
37     LTC_ARGCHK(out   != NULL);
38     if (*inlen < 2UL || (in[1] >= sizeof(buf)) || ((in[1] + 2UL) > *inlen)) {
39        return CRYPT_INVALID_PACKET;
40     }
41     for (x = 0; x < in[1]; x++) {
42         y = der_ia5_value_decode(in[x+2]);
<span onclick='openModal()' class='match'>43         if (y == -1) {
44            return CRYPT_INVALID_PACKET;
45         }
46         if (!((y >= '0' && y <= '9')
47              || y == 'Z' || y == '.'
48              || y == '+' || y == '-')) {
49            return CRYPT_INVALID_PACKET;
50         }
51         buf[x] = y;
</span>52     }
53     *inlen = 2 + x;
54     if (x < 15) {
55        return CRYPT_INVALID_PACKET;
56     }
57      x = 0;
58      DECODE_V4(out->YYYY, 10000);
59      DECODE_V(out->MM, 13);
60      DECODE_V(out->DD, 32);
61      DECODE_V(out->hh, 24);
62      DECODE_V(out->mm, 60);
63      DECODE_V(out->ss, 60);
64      out->fs = 0;
65      if (buf[x] == 'Z') {
66         return CRYPT_OK;
67      }
68      if (buf[x] == '.') {
69         x++;
70         while (buf[x] >= '0' && buf[x] <= '9') {
71            unsigned fs = out->fs;
72            if (x >= sizeof(buf)) return CRYPT_INVALID_PACKET;
73            out->fs *= 10;
74            out->fs += s_char_to_int(buf[x]);
75            if (fs > out->fs) return CRYPT_OVERFLOW;
76            x++;
77         }
78      }
79      if (buf[x] == 'Z') {
80         return CRYPT_OK;
81      }
82      if (buf[x] == '+' || buf[x] == '-') {
83         out->off_dir = (buf[x++] == '+') ? 0 : 1;
84         DECODE_V(out->off_hh, 24);
85         DECODE_V(out->off_mm, 60);
86         return CRYPT_OK;
87      }
88      return CRYPT_INVALID_PACKET;
89  }
90  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-check-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #include "Win32_Interop/Win32_Error.h"
5  #include "Win32_Interop/win32fixes.h"
6  #endif
7  #include "server.h"
8  #include <sys/stat.h>
9  #ifdef _WIN32
10  #define strcasecmp _stricmp
11  #define strncasecmp _strnicmp
12  #endif
13  #define ERROR(...) { \
14      char __buf[1024]; \
15      snprintf(__buf, sizeof(__buf), __VA_ARGS__); \
16      snprintf(error, sizeof(error), "0x%16llx: %s", (PORT_LONGLONG)epos, __buf); \
17  }
18  static char error[1044];
19  static off_t epos;
20  int consumeNewline(char *buf) {
21      if (strncmp(buf,"\r\n",2) != 0) {
22          ERROR("Expected \\r\\n, got: %02x%02x",buf[0],buf[1]);
23          return 0;
24      }
25      return 1;
26  }
27  int readLong(FILE *fp, char prefix, PORT_LONG *target) {
28      char buf[128], *eptr;
29      epos = ftello(fp);
30      if (fgets(buf,sizeof(buf),fp) == NULL) {
31          return 0;
32      }
33      if (buf[0] != prefix) {
34          ERROR("Expected prefix '%c', got: '%c'",prefix,buf[0]);
35          return 0;
36      }
37      *target = strtol(buf+1,&eptr,10);
38      return consumeNewline(eptr);
39  }
40  int readBytes(FILE *fp, char *target, PORT_LONG length) {
41      PORT_LONG real;
42      epos = ftello(fp);
43      real = (PORT_LONG)fread(target,1,length,fp);
44      if (real != length) {
45          ERROR("Expected to read %Id bytes, got %Id bytes",length,real);                        WIN_PORT_FIX &bsol;* %ld -> %Id */
46          return 0;
47      }
48      return 1;
49  }
50  int readString(FILE *fp, char** target) {
51      PORT_LONG len;
52      *target = NULL;
53      if (!readLong(fp,'$',&len)) {
54          return 0;
55      }
56      len += 2;
57      *target = (char*)zmalloc(len);
<span onclick='openModal()' class='match'>58      if (!readBytes(fp,*target,len)) {
59          return 0;
60      }
61      if (!consumeNewline(*target+len-2)) {
62          return 0;
63      }
64      (*target)[len-2] = '\0';
</span>65      return 1;
66  }
67  int readArgc(FILE *fp, PORT_LONG *target) {
68      return readLong(fp,'*',target);
69  }
70  off_t process(FILE *fp) {
71      PORT_LONG argc;
72      off_t pos = 0;
73      int i, multi = 0;
74      char *str;
75      while(1) {
76          if (!multi) pos = ftello(fp);
77          if (!readArgc(fp, &argc)) break;
78          for (i = 0; i < argc; i++) {
79              if (!readString(fp,&str)) break;
80              if (i == 0) {
81                  if (strcasecmp(str, "multi") == 0) {
82                      if (multi++) {
83                          ERROR("Unexpected MULTI");
84                          break;
85                      }
86                  } else if (strcasecmp(str, "exec") == 0) {
87                      if (--multi) {
88                          ERROR("Unexpected EXEC");
89                          break;
90                      }
91                  }
92              }
93              zfree(str);
94          }
95          if (i < argc) {
96              if (str) zfree(str);
97              break;
98          }
99      }
100      if (feof(fp) && multi && strlen(error) == 0) {
101          ERROR("Reached EOF before reading EXEC for MULTI");
102      }
103      if (strlen(error) > 0) {
104          printf("%s\n", error);
105      }
106      return pos;
107  }
108  int redis_check_aof_main(int argc, char **argv) {
109      char *filename;
110      int fix = 0;
111  #ifdef _WIN32
112      _fmode = _O_BINARY;
113      setmode(_fileno(stdin), _O_BINARY);
114      setmode(_fileno(stdout), _O_BINARY);
115      setmode(_fileno(stderr), _O_BINARY);
116  #endif
117      if (argc < 2) {
118          printf("Usage: %s [--fix] <file.aof>\n", argv[0]);
119          exit(1);
120      } else if (argc == 2) {
121          filename = argv[1];
122      } else if (argc == 3) {
123          if (strcmp(argv[1],"--fix") != 0) {
124              printf("Invalid argument: %s\n", argv[1]);
125              exit(1);
126          }
127          filename = argv[2];
128          fix = 1;
129      } else {
130          printf("Invalid arguments\n");
131          exit(1);
132      }
133      FILE *fp = fopen(filename, IF_WIN32("r+b", "r+"));
134      if (fp == NULL) {
135          printf("Cannot open file: %s\n", filename);
136          exit(1);
137      }
138      struct redis_stat sb;
139      if (redis_fstat(fileno(fp),&sb) == -1) {
140          printf("Cannot stat file: %s\n", filename);
141          exit(1);
142      }
143      off_t size = sb.st_size;
144      if (size == 0) {
145          printf("Empty file: %s\n", filename);
146          exit(1);
147      }
148      if (size >= 8) {    &bsol;* There must be at least room for the RDB header. */
149          char sig[5];
150          int has_preamble = fread(sig,sizeof(sig),1,fp) == 1 &&
151                              memcmp(sig,"REDIS",sizeof(sig)) == 0;
152          rewind(fp);
153          if (has_preamble) {
154              printf("The AOF appears to start with an RDB preamble.\n"
155                     "Checking the RDB preamble to start:\n");
156              if (redis_check_rdb_main(argc,argv,fp) == C_ERR) {
157                  printf("RDB preamble of AOF file is not sane, aborting.\n");
158                  exit(1);
159              } else {
160                  printf("RDB preamble is OK, proceeding with AOF tail...\n");
161              }
162          }
163      }
164      off_t pos = process(fp);
165      off_t diff = size-pos;
166      printf("AOF analyzed: size=%lld, ok_up_to=%lld, diff=%lld\n",
167          (PORT_LONGLONG) size, (PORT_LONGLONG) pos, (PORT_LONGLONG) diff);
168      if (diff > 0) {
169          if (fix) {
170              char buf[2];
171              printf("This will shrink the AOF from %lld bytes, with %lld bytes, to %lld bytes\n", (PORT_LONGLONG)size, (PORT_LONGLONG)diff, (PORT_LONGLONG)pos);
172              printf("Continue? [y/N]: ");
173              if (fgets(buf,sizeof(buf),stdin) == NULL ||
174                  strncasecmp(buf,"y",1) != 0) {
175                      printf("Aborting...\n");
176                      exit(1);
177              }
178              if (ftruncate(fileno(fp), pos) == -1) {
179                  printf("Failed to truncate AOF\n");
180                  exit(1);
181              } else {
182                  printf("Successfully truncated AOF\n");
183              }
184          } else {
185              printf("AOF is not valid. "
186                     "Use the --fix option to try fixing it.\n");
187              exit(1);
188          }
189      } else {
190          printf("AOF is valid\n");
191      }
192      fclose(fp);
193      exit(0);
194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_generalizedtime.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-check-aof.c</div>
                </div>
                <div class="column column_space"><pre><code>43         if (y == -1) {
44            return CRYPT_INVALID_PACKET;
45         }
46         if (!((y >= '0' && y <= '9')
47              || y == 'Z' || y == '.'
48              || y == '+' || y == '-')) {
49            return CRYPT_INVALID_PACKET;
50         }
51         buf[x] = y;
</pre></code></div>
                <div class="column column_space"><pre><code>58      if (!readBytes(fp,*target,len)) {
59          return 0;
60      }
61      if (!consumeNewline(*target+len-2)) {
62          return 0;
63      }
64      (*target)[len-2] = '\0';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    