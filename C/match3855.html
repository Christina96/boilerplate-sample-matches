<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for omrabbitmq.c &amp; miniamqpsrvr.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omrabbitmq.c &amp; miniamqpsrvr.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omrabbitmq.c (1.3527576%)<th>miniamqpsrvr.c (2.631579%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(595-614)<td><a href="#" name="0">(551-562)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omrabbitmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omrabbitmq.c
 *
 * This output plugin enables rsyslog to send messages to the RabbitMQ.
 *
 * Copyright 2012-2013 Vaclav Tomec
 * Copyright 2014 Rainer Gerhards
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program. If not, see
 * &lt;http://www.gnu.org/licenses/&gt;.
 *
 * Author: Vaclav Tomec
 * &lt;vaclav.tomec@gmail.com&gt;
 */
#include "config.h"
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "debug.h"
#include "datetime.h"
#include "rsconf.h"

#include &lt;sys/socket.h&gt;

#include "amqp.h"
#include "amqp_framing.h"
#include "amqp_tcp_socket.h"
#if (AMQP_VERSION_MAJOR == 0) &amp;&amp; (AMQP_VERSION_MINOR &lt; 4)
#error "rabbitmq-c version must be &gt;= 0.4.0"
#endif

#define RABBITMQ_CHANNEL 1

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omrabbitmq")

/*
 * internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)

static int instance_counter = 0;
static int mode_test = 0;

typedef struct  {
	char *host;                    /* rabbitmq server fqdn or IP */
	int port;                      /* rabbitmq server port */
} server_t;

typedef struct  {
	server_t s;                    /* rabbitmq server */
	int failures;                  /* rabbitmq server failures */
} server_wrk_t;


typedef struct {
	time_t return_check_interval;      /* time interval between usual server health checks */
	time_t half_return_check_interval; /* for computing */
	time_t quick_oscillation_interval; /* time interval below which the service is not stable */
	int quick_oscillation_max; /* number of quick oscillation after which the connection is kept on backup */
	time_t graceful_interval; /* time interval the connection is kept on backup after which the usual server
							   * check restarts */
	int quick_oscillation_count; /* current number of simultaneous quick oscillation detected */
} recover_t;

typedef struct _instanceData {
	/* here you need to define all action-specific data. A record of type
	 * instanceData will be handed over to each instance of the action. Keep
	 * in mind that there may be several invocations of the same type of action
	 * inside rsyslog.conf, and this is what keeps them apart. Do NOT use
	 * static data for this!
	 */
	amqp_bytes_t exchange;                    /* exchange to send message to */

	amqp_bytes_t routing_key;                 /* fixed routing_key to use */
	uchar *routing_key_template;              /* routing_key template */
	int idx_routing_key_template;             /* routing_key template index in doAction tab */

	sbool populate_properties;                /* populates message properties */
	int delivery_mode;                        /* delivery mode transient or persistent message */
	amqp_bytes_t expiration;                  /* message expiration */

	uchar *body_template;                     /* body template */
	int idx_body_template;                    /* body template index in doAction tab */

	amqp_basic_properties_t amqp_props_tpl_type; /*  */
	char *content_type;                       /*  */
	amqp_basic_properties_t amqp_props_plaintext;   /*  */

	char *exchange_type;                      /*  */
	int durable;                              /*  */
	int auto_delete;                          /*  */

	int iidx;
	int nbWrkr;

	server_t server1;               /* first rabbitmq server  */
	server_t server2;               /* second rabbitmq server */

	char *vhost;                    /* rabbitmq server vhost */
	char *user;                     /* rabbitmq username */
	char *password;                 /* rabbitmq username's password */

	recover_t recover_policy;

} instanceData;

typedef struct wrkrInstanceData {
	amqp_connection_state_t a_conn; /* amqp connection */

	int connected;
	int channel_opened;

	pthread_t thread;               /*  */
	short thread_running;           /*  */
	pthread_mutex_t send_mutex;     /*  */
	pthread_cond_t cond;            /*  */

	rsRetVal state;                 /* state of the connection */

	server_wrk_t serverPrefered;              /* usual rabbitmq server */
	server_wrk_t serverBackup;                /* backup rabbitmq server */
	server_wrk_t *serverActive;               /* active rabbitmq server */

	instanceData *pData;

	recover_t recover_policy;
	time_t last_failback;

	int iidx;
	int widx;
	int go_on;
} wrkrInstanceData_t;

typedef struct _msg2amqp_props_ {
	propid_t id;
	const char *name;
	amqp_bytes_t *standardprop;
	int flag;
} msg2amqp_props_t;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "host", eCmdHdlrString, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "virtual_host", eCmdHdlrGetWord, 0 },
	{ "user", eCmdHdlrGetWord, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "exchange", eCmdHdlrGetWord, 0 },
	{ "routing_key", eCmdHdlrGetWord, 0 },
	{ "routing_key_template", eCmdHdlrGetWord, 0 },
	{ "delivery_mode", eCmdHdlrGetWord, 0 },
	{ "expiration", eCmdHdlrNonNegInt, 0 },
	{ "populate_properties", eCmdHdlrBinary, 0 },
	{ "body_template", eCmdHdlrGetWord, 0 },
	{ "content_type", eCmdHdlrGetWord, 0 },
	{ "recover_policy", eCmdHdlrString, 0 },
	{ "exchange_type", eCmdHdlrGetWord, 0},
	{ "durable", eCmdHdlrBinary, 0},
	{ "auto_delete", eCmdHdlrBinary, 0},
};
static struct cnfparamblk actpblk =
	{
		CNFPARAMBLK_VERSION,
		sizeof(actpdescr)/sizeof(struct cnfparamdescr),
		actpdescr
	};

static amqp_bytes_t cstring_bytes(const char *str)
{
	return str ? amqp_cstring_bytes(str) : amqp_empty_bytes;
}

/* Initialize recover structure from the configuration string
 */
static void init_recover(recover_t *fb, char *str)
{
	time_t value[4] = { 0, 0, 0, 0 };

	if (str &amp;&amp; *str){
		int i = -1;
		do {
			value[++i] = strtoul(str, &amp;str, 10);
			if (*str) str++;
		} while (i &lt; 3 &amp;&amp; value[i] &amp;&amp; *str);
	}

	fb-&gt;return_check_interval = (value[0]) ? value[0] : 60;
	fb-&gt;half_return_check_interval = fb-&gt;return_check_interval / 2;
	fb-&gt;quick_oscillation_interval = (value[1]) ? value[1] : (fb-&gt;return_check_interval / 10);
	fb-&gt;quick_oscillation_max = (value[2]) ? (int)(value[2]) : 3;
	fb-&gt;graceful_interval = (value[3]) ? value[3] : (fb-&gt;return_check_interval * 10) -
							fb-&gt;half_return_check_interval;
	fb-&gt;quick_oscillation_count = 0;
}

/* this method compute the delay before next reconnection attempt according
 */
static unsigned long next_check(recover_t *fb, time_t last_failback)
{
	time_t now = time(NULL);
	srandom(now);

	if (now - last_failback &lt; fb-&gt;quick_oscillation_interval) {
		/* quick oscillation detected */
		fb-&gt;quick_oscillation_count++;

		if (fb-&gt;quick_oscillation_count &gt; fb-&gt;quick_oscillation_max) {
			/* too much oscillation inserting a graceful sleep */
			fb-&gt;quick_oscillation_count = 0;
			return fb-&gt;graceful_interval + fb-&gt;return_check_interval * random() / RAND_MAX;
		}
	} else
		fb-&gt;quick_oscillation_count = 0;

	/* returning a standard delay between 0,5 and 1,5 * return_check_interval */
	return fb-&gt;half_return_check_interval + fb-&gt;return_check_interval * random() / RAND_MAX;
}

/* authenticate to rabbitmq server and set connection parameter according to rsyslog configuration
 */
static int amqp_authenticate(wrkrInstanceData_t *self, amqp_connection_state_t a_conn)
{
	amqp_rpc_reply_t ret;

	/* define the frame size */
	int frame_size = (glbl.GetMaxLine(runConf)&lt;130000) ? 131072 : (glbl.GetMaxLine(runConf)+1072);

	/* authenticate */
	ret = amqp_login(a_conn, (char const *)self-&gt;pData-&gt;vhost, 1, frame_size, 0,
			AMQP_SASL_METHOD_PLAIN, self-&gt;pData-&gt;user, self-&gt;pData-&gt;password);

	if (ret.reply_type != AMQP_RESPONSE_NORMAL)
	{
		LogError(0, RS_RET_RABBITMQ_LOGIN_ERR, "omrabbitmq module %d/%d: login to AMQP "
				"server %s failed. (%d / %s)",
				self-&gt;iidx, self-&gt;widx, self-&gt;serverActive-&gt;s.host, ret.reply_type,
				amqp_error_string2(ret.library_error));
		return 0;
	}

	/* open the communication channel */
	amqp_channel_open(a_conn, 1);

	if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
	{
		LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR, "omrabbitmq module %d/%d: open channel failed.",
				self-&gt;iidx, self-&gt;widx);
		return 0;
	}

	if (self-&gt;pData-&gt;exchange_type) {
		/* we declare the exchange according to specifications */
		amqp_table_t props = { 0, NULL };
		#if (AMQP_VERSION_MAJOR == 0) &amp;&amp; (AMQP_VERSION_MINOR &lt; 6)
		amqp_exchange_declare(a_conn, 1, self-&gt;pData-&gt;exchange, cstring_bytes(self-&gt;pData-&gt;exchange_type),
		                      0, self-&gt;pData-&gt;durable, props);
		#else
		amqp_exchange_declare(a_conn, 1, self-&gt;pData-&gt;exchange, cstring_bytes(self-&gt;pData-&gt;exchange_type),
		                      0, self-&gt;pData-&gt;durable, self-&gt;pData-&gt;auto_delete, 0, props);
		#endif

		if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
		{
			/* if a problem occurs on declaring the exchange we receive a channel_close with the
			 * error then we can log the error, respond a channel_close_ok and reopen it
			 * so we can work with the existing exchange.
			 */
			amqp_channel_close_ok_t chan_cls_ok;
			amqp_channel_close_t *chan_cls =
							(amqp_channel_close_t*)amqp_get_rpc_reply(a_conn).reply.decoded;

			if (amqp_get_rpc_reply(a_conn).reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION) {
				LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
						"omrabbitmq module %d/%d: disconnected while exchange declare (%d)",
						self-&gt;iidx, self-&gt;widx, amqp_get_rpc_reply(a_conn).library_error);
				return 0;
			}

			LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
			    "omrabbitmq module %d/%d: exchange declare failed %.*s.", self-&gt;iidx, self-&gt;widx,
					(int)chan_cls-&gt;reply_text.len, (char*)chan_cls-&gt;reply_text.bytes);

			chan_cls_ok.dummy = '\0';
			amqp_send_method(a_conn, 1, AMQP_CHANNEL_CLOSE_OK_METHOD, &amp;chan_cls_ok);

			/* reopen the communication channel in case of error it should be close by server*/
			amqp_channel_open(a_conn, 1);

			if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
			{
				LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR, "omrabbitmq module %d/%d: "
				    "open channel failed.", self-&gt;iidx, self-&gt;widx);
				return 0;
			}

		}
	}
	/* release the buffers if possible */
	amqp_maybe_release_buffers(a_conn);

	return 1;
}

/* This method establish a new connection
 * @self pointer on the worker datas
 * @server pointer on the server datas (preferred or backup)
 * @return the connection state or NULL on error
 */
static amqp_connection_state_t tryConnection(wrkrInstanceData_t *self, server_t *server)
{
	int retconn = 0;
	struct timeval delay;
	delay.tv_sec = 1;
	delay.tv_usec = 0;

	amqp_connection_state_t a_conn = amqp_new_connection();
	amqp_socket_t *sockfd = (a_conn) ? amqp_tcp_socket_new(a_conn) : NULL;

	if (sockfd)
	{
		LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
		    "omrabbitmq module %d/%d: server %s port %d.", self-&gt;iidx, self-&gt;widx,
		    server-&gt;host, server-&gt;port);

		#if defined(_AIX)
		retconn = amqp_socket_open(sockfd, server-&gt;host, server-&gt;port);
		#else
		retconn = amqp_socket_open_noblock(sockfd, (const char*)server-&gt;host, server-&gt;port, &amp;delay);
		#endif
	}

	if (retconn == AMQP_STATUS_OK &amp;&amp; amqp_authenticate(self, a_conn))
		return a_conn;

	/* the connection failed so free it and return NULL */
	amqp_connection_close(a_conn, 200);
	amqp_destroy_connection(a_conn);

	return NULL;
}

static int manage_connection(wrkrInstanceData_t *self, 	amqp_frame_t *pFrame)
{
	int result;

	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	do {
		if (self-&gt;serverActive == &amp;self-&gt;serverBackup)
		{
			amqp_connection_state_t new_conn;
			struct timeval delay;

			/* The worker is connected to the backup server.
			 * next_check function compute the delay before trying to recover
			 * the connection to the preferred server according to recover_policy
			 */
			delay.tv_sec = next_check(&amp;self-&gt;recover_policy, self-&gt;last_failback);
			delay.tv_usec = 0;

			result = amqp_simple_wait_frame_noblock(self-&gt;a_conn, pFrame, &amp;delay);

			/* if connected to backup server then check if usual server is alive.
			 * if so then disconnect from backup */
			if (result == AMQP_STATUS_TIMEOUT &amp;&amp;
					(new_conn = tryConnection(self,
							&amp;(self-&gt;serverPrefered.s)))
					!= NULL) {
				/* connection is re-established to preferred server so
				 * swap connections */
				amqp_connection_state_t old_conn = self-&gt;a_conn;

				/* now lock to avoid message publishing. */
				pthread_mutex_lock(&amp;self-&gt;send_mutex);
				self-&gt;a_conn = new_conn;
				self-&gt;serverActive = &amp;self-&gt;serverPrefered;
				self-&gt;serverActive-&gt;failures = 0;
				pthread_mutex_unlock(&amp;self-&gt;send_mutex);
				/* back to unlock mode */

				DBGPRINTF("omrabbitmq module %d: reconnects to usual server.\n",
							self-&gt;iidx);
				amqp_connection_close(old_conn, 200);
				amqp_destroy_connection(old_conn);
			}

		} else {

			result = amqp_simple_wait_frame(self-&gt;a_conn, pFrame);

		}
	} while(result == AMQP_STATUS_TIMEOUT);

	/* now lock the mutex to avoid message publishing. */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	return result;
}

static void send_connection_close(amqp_connection_state_t state) {
	amqp_connection_close_t *req = malloc(sizeof(amqp_connection_close_t));
	memset(req, 0, sizeof(amqp_connection_close_t));
	req-&gt;reply_code = 200;
	req-&gt;reply_text.bytes = (void*)"200";
	req-&gt;reply_text.len = 3;
	req-&gt;class_id = (uint16_t)(AMQP_CONNECTION_CLOSE_METHOD &gt;&gt; 16);
	req-&gt;method_id = (uint16_t)(AMQP_CONNECTION_CLOSE_METHOD &amp; 0xFFFF);
	amqp_send_method(state, 0, AMQP_CONNECTION_CLOSE_METHOD, req);
	free(req);
}

static void send_channel_close(amqp_connection_state_t state, amqp_channel_t ch) {
	amqp_channel_close_t *req = malloc(sizeof(amqp_channel_close_t));
	memset(req, 0, sizeof(amqp_channel_close_t));
	req-&gt;reply_code = 200;
	req-&gt;reply_text.bytes = (void*)"200";
	req-&gt;reply_text.len = 3;
	req-&gt;class_id = (uint16_t)(AMQP_CHANNEL_CLOSE_METHOD &gt;&gt; 16);
	req-&gt;method_id = (uint16_t)(AMQP_CHANNEL_CLOSE_METHOD &amp; 0xFFFF);
	amqp_send_method(state, ch, AMQP_CHANNEL_CLOSE_METHOD, req);
	free(req);
}

static void send_connection_close_ok(amqp_connection_state_t state) {
	amqp_connection_close_ok_t *req = malloc(sizeof(amqp_connection_close_ok_t));
	memset(req, 0, sizeof(amqp_connection_close_ok_t));
	req-&gt;dummy = '\0';
	amqp_send_method(state, 0, AMQP_CONNECTION_CLOSE_OK_METHOD, req);
	free(req);
}

static void send_channel_close_ok(amqp_connection_state_t state, amqp_channel_t ch) {
	amqp_channel_close_ok_t *req = malloc(sizeof(amqp_channel_close_ok_t));
	memset(req, 0, sizeof(amqp_channel_close_ok_t));
	req-&gt;dummy = '\0';
	amqp_send_method(state, ch, AMQP_CHANNEL_CLOSE_OK_METHOD, req);
	free(req);
}

/* run_connection_routine is the thread monitoring of the rabbitmq connection.
 * This method manage reconnection to preferred and backup servers apply the recover_policy
 */
static void* run_connection_routine(void* arg)
{
	wrkrInstanceData_t *self = (wrkrInstanceData_t *) arg;
	amqp_frame_t frm;
	int result;
	self-&gt;connected = 0;
	self-&gt;channel_opened = 0;
	rsRetVal state_out = RS_RET_SUSPENDED;

	dbgSetThrdName((uchar*)"amqp connection");

	/* now lock to avoid message publishing during part of the thread loop */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	self-&gt;thread_running = 1;

	self-&gt;state = RS_RET_OK;

	srSleep(0,100);

	DBGPRINTF("omrabbitmq module %d/%d: connection thread started\n", self-&gt;iidx, self-&gt;widx);

	int go_on = self-&gt;go_on;

	while (go_on) // this loop is used to reconnect on connection failure
	{
		if (self-&gt;a_conn != NULL)
		{
			amqp_connection_close(self-&gt;a_conn, 200);
			amqp_destroy_connection(self-&gt;a_conn);
		}

		self-&gt;a_conn = NULL;

		if (!self-&gt;go_on)
		{
			go_on = 0;
			state_out = RS_RET_DISABLE_ACTION;
			continue; /* lets go back to wile (go_on) and leave cleanly */
		}

		if (self-&gt;serverActive == &amp;self-&gt;serverBackup) {
			self-&gt;serverBackup.failures = 0;
			self-&gt;serverPrefered.failures = 0;
			self-&gt;serverActive = &amp;self-&gt;serverPrefered;
		}

		do { /* this loop tries 3 times per server before switching servers */
			if ((self-&gt;a_conn = tryConnection(self, &amp;(self-&gt;serverActive-&gt;s))) != NULL) {
				self-&gt;serverActive-&gt;failures = 0;
			} else {
				/* set 1 second before retry */
				struct timeval delay;

				delay.tv_sec = 1;
				delay.tv_usec = 0;

				self-&gt;serverActive-&gt;failures++;

				/* if 3 tries */
				if (self-&gt;serverActive-&gt;failures == 3) {

					if (!self-&gt;serverBackup.s.host || self-&gt;serverBackup.failures == 3)
					{
						LogError(0, RS_RET_RABBITMQ_CONN_ERR, "omrabbitmq module connection "
								"failed 3 times on each server.");
					}

					if (self-&gt;serverActive == &amp;self-&gt;serverBackup) {
						self-&gt;serverBackup.failures = 0;
						self-&gt;serverPrefered.failures = 0;
						self-&gt;serverActive = &amp;self-&gt;serverPrefered;
					} else {
						/* on usual server switch to backup server */
						if (self-&gt;serverBackup.s.host)
							self-&gt;serverActive = &amp;self-&gt;serverBackup;
						else
							self-&gt;serverPrefered.failures = 0;
					}
					/* set 5 second before new round trip */
					delay.tv_sec = 5;
				}
				select(0,NULL,NULL,NULL,&amp;delay);
			}
		}
		while (self-&gt;a_conn == NULL &amp;&amp; self-&gt;go_on);

		if (!self-&gt;go_on)
		{
			go_on = 0;
			state_out = RS_RET_DISABLE_ACTION;
			continue; /* lets go back to wile (go_on) and leave cleanly */
		}

		/* signal that the thread is started */
		pthread_cond_signal(&amp;self-&gt;cond);

		self-&gt;connected = 1;
		self-&gt;channel_opened = 1;

		DBGPRINTF("omrabbitmq module %d: connected.\n", self-&gt;iidx);

		self-&gt;state = RS_RET_OK;

		if (self-&gt;serverActive == &amp;self-&gt;serverBackup)
			self-&gt;last_failback = time(NULL);

		while (self-&gt;connected) // this loop is used to manage an established connection
		{

			result = manage_connection(self, &amp;frm);

			switch (result)
			{
			case AMQP_STATUS_NO_MEMORY:
				LogError(0, RS_RET_OUT_OF_MEMORY, "omrabbitmq module %d/%d: no memory "
					": aborting module.", self-&gt;iidx, self-&gt;widx);
				go_on = 0; /* non recoverable error let's go out */
<a name="0"></a>				self-&gt;connected = 0;
				state_out = RS_RET_DISABLE_ACTION;
				break;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			case AMQP_STATUS_BAD_AMQP_DATA:
				LogError(0, RS_RET_RABBITMQ_CONN_ERR, "omrabbitmq module %d/%d: bad "
					"data received : reconnect.", self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_SOCKET_ERROR:
				LogError(0, RS_RET_RABBITMQ_CONN_ERR, "omrabbitmq module %d/%d: Socket"
					" error : reconnect.", self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_CONNECTION_CLOSED:
				LogError(0, RS_RET_OUT_OF_MEMORY, "omrabbitmq module %d/%d: Connection"
					" closed : reconnect.", self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_OK:
				/* perhaps not a frame type so ignore it */
				if (frm.frame_type == AMQP_FRAME_METHOD)
				{
					amqp_method_number_t id = frm.payload.method.id;</b></font>
					/* now handle frames from the server */
					switch (id)
					{
					case AMQP_CONNECTION_CLOSE_OK_METHOD:

						/* We asked to close the connection and server has responded to us */
						self-&gt;connected = 0;
						go_on = 0;
						break;

					case AMQP_CHANNEL_CLOSE_OK_METHOD:

						/* We asked to close the channel and server has responded to us */
						send_connection_close(self-&gt;a_conn);
						self-&gt;channel_opened = 0;
						break;

					case AMQP_CHANNEL_CLOSE_METHOD:

						/* the server wants to close the channel then the connection */
						LogMsg(0, RS_RET_OK, LOG_WARNING,"omrabbitmq module %d/%d: "
							"Close Channel Received (%X).", self-&gt;iidx, self-&gt;widx, id);
						 /* answer the server request &amp; send the method */
						send_channel_close_ok(self-&gt;a_conn, frm.channel);
						self-&gt;channel_opened = 0;
						break;

					case AMQP_CONNECTION_CLOSE_METHOD:

						/* the server want to close the connection */
						LogMsg(0, RS_RET_OK, LOG_WARNING, "omrabbitmq module %d/%d: "
							"Close Connection Received (%X).", self-&gt;iidx, self-&gt;widx, id);
						/* answer the server request */
						send_connection_close_ok(self-&gt;a_conn);
						self-&gt;connected = 0;
						break;

					default :

						LogMsg(0, RS_RET_OK, LOG_WARNING, "omrabbitmq module %d/%d: "
							"Unmanaged amqp method received (%X) : ignored.",
							self-&gt;iidx, self-&gt;widx, id);
					} /* switch (frm.payload.method.id) */
				} /* if (frm.frame_type == AMQP_FRAME_METHOD) */
				break;
			} /* switch (result) */
		}
	}
	self-&gt;state = state_out;

	/* The core ask to die so let's disconnect */
	if (self-&gt;a_conn != NULL)
	{
		if (self-&gt;channel_opened)
			amqp_channel_close(self-&gt;a_conn, 1, 200);
		if (self-&gt;connected)
			amqp_connection_close(self-&gt;a_conn, 200);
		amqp_destroy_connection(self-&gt;a_conn);
		self-&gt;a_conn = NULL;
	}

	self-&gt;thread_running = 0;

	/* Finishing by unlocking before the end of the thread */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	/* Now notify the worker that this thread is stopping */
	pthread_cond_signal(&amp;self-&gt;cond);

	return NULL;
}

/* ============================================================================================
 * Main thread
 * ============================================================================================
 */

static rsRetVal startAMQPConnection(wrkrInstanceData_t *self)
{
	DEFiRet;
	pthread_mutex_lock(&amp;self-&gt;send_mutex);
	self-&gt;go_on = 1;
	if (self-&gt;thread_running == 0)
	{
		if (!pthread_create(&amp;self-&gt;thread, NULL, run_connection_routine, self))
		{
			pthread_cond_wait(&amp;self-&gt;cond,&amp;self-&gt;send_mutex);
			iRet = self-&gt;state;
		}else{
			iRet = RS_RET_DISABLE_ACTION;
		}
	}
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);
	RETiRet;
}

static void closeAMQPConnection(wrkrInstanceData_t *self)
{
	if (!self || !self-&gt;a_conn) return;

	void *ret;

	/* Now locks to allow exclusive access to sock */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	self-&gt;go_on = 0;

	/* send the method */
	if (self-&gt;a_conn)
	{
		if (self-&gt;channel_opened){
			send_channel_close(self-&gt;a_conn, 0);
		} else {
			send_connection_close(self-&gt;a_conn);
		}
	}
	/* Release the lock */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	/* Now wvait for the thread to stop */
	pthread_join(self-&gt;thread, &amp;ret);
}

/*
 * Report general error
 */
static int manage_error(int x, char const *context)
{
	int retVal = 0; // false

	if (x &lt; 0) {
		#if (AMQP_VERSION_MINOR &gt;= 4)
		const char *errstr = amqp_error_string2(-x);
		LogError(0, RS_RET_ERR, "omrabbitmq: %s: %s", context, errstr);
		#else
		char *errstr = amqp_error_string(-x);
		LogError(0, RS_RET_ERR, "omrabbitmq: %s: %s", context, errstr);
		free(errstr);
		#endif
		retVal = 1; // true
	}

	return retVal;
}

static rsRetVal publishRabbitMQ(wrkrInstanceData_t *self, amqp_bytes_t exchange,
		amqp_bytes_t routing_key, amqp_basic_properties_t *p_amqp_props,
		amqp_bytes_t body_bytes)
{
	DEFiRet;
	/* locks to allow exclusive access to connection */
	if (mode_test &gt; 0) {
		struct timeval tv;
		tv.tv_sec = mode_test/1000;
		tv.tv_usec = mode_test%1000 * 1000;
		select(0, NULL, NULL, NULL, &amp;tv);
	}

	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	if (self-&gt;state != RS_RET_OK)
		 ABORT_FINALIZE(self-&gt;state);

	if (!self-&gt;a_conn){
		ABORT_FINALIZE(RS_RET_RABBITMQ_CONN_ERR);
	}

	if (manage_error(amqp_basic_publish(self-&gt;a_conn, 1, exchange, routing_key,
			0, 0, p_amqp_props, body_bytes), "amqp_basic_publish")) {
		/* error already notified */
		FINALIZE;
	}

finalize_it:
	/* release exclusive access to connection */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);
	RETiRet;
}

BEGINdoAction
	int iLen;
CODESTARTdoAction
	/* The first element is a smsg_t pointer */
	smsg_t **pMsg = (smsg_t **)pMsgData;
	smsg_t *msg = pMsg[0];

	amqp_bytes_t body_bytes;
	amqp_basic_properties_t *amqp_props_msg;

	if (!pWrkrData-&gt;pData-&gt;idx_body_template)
	{
		/* No body template so send it as rawmsg */
		getRawMsg(msg, (uchar**)(&amp;body_bytes.bytes), &amp;iLen);
		body_bytes.len = (size_t)iLen;
		amqp_props_msg = &amp;pWrkrData-&gt;pData-&gt;amqp_props_plaintext;
	}
	else
	{
		/* we have a body template */
		body_bytes = cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_body_template]);
		amqp_props_msg = &amp;pWrkrData-&gt;pData-&gt;amqp_props_tpl_type;
	}

	if (pWrkrData-&gt;pData-&gt;populate_properties) {
		/* populate amqp message properties */
		msgPropDescr_t pProp;
		int i, custom = 0;
		amqp_basic_properties_t amqp_props;

		memcpy(&amp;amqp_props, amqp_props_msg, sizeof(amqp_basic_properties_t));

		/* list and mapping of smsg to amqp properties */
		msg2amqp_props_t prop_list[] = {
			{ PROP_SYSLOGFACILITY_TEXT, "facility",  NULL, 0 },
			{ PROP_SYSLOGSEVERITY_TEXT, "severity",  NULL, 0 },
			{ PROP_HOSTNAME, "hostname", NULL, 0 },
			{ PROP_FROMHOST, "fromhost", NULL, 0 },
			{ PROP_SYSLOGTAG, NULL, &amp;(amqp_props.app_id), AMQP_BASIC_APP_ID_FLAG }
		};
		int len = sizeof(prop_list)/sizeof(msg2amqp_props_t);
		uchar *val[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		rs_size_t valLen[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		unsigned short mustBeFreed[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		struct amqp_table_entry_t_ tab_entries[sizeof(prop_list)/sizeof(msg2amqp_props_t)];

		amqp_props.headers.entries = tab_entries;

		amqp_props.timestamp = (uint64_t)datetime.syslogTime2time_t(&amp;msg-&gt;tTIMESTAMP);
		amqp_props._flags |= AMQP_BASIC_TIMESTAMP_FLAG;

		for (i=0; i&lt;len; i++)
		{
			/* for each msg property in list get the value and initialize flags */
			pProp.id = prop_list[i].id;
			valLen[i] = 0;
			mustBeFreed[i] = 0;
			val[i] = (uchar*)MsgGetProp(msg, NULL, &amp;pProp, &amp;(valLen[i]), &amp;(mustBeFreed[i]), NULL);
			if (val[i] &amp;&amp; *val[i])
			{
				if (prop_list[i].name)
				{
					/* custom amqp properties */
					tab_entries[custom].key = amqp_cstring_bytes(prop_list[i].name);
					tab_entries[custom].value.kind = AMQP_FIELD_KIND_UTF8;
					tab_entries[custom].value.value.bytes = amqp_cstring_bytes((char*)val[i]);
					amqp_props._flags |= AMQP_BASIC_HEADERS_FLAG;
					custom++;
				} else {
					/* standard amqp properties*/
					prop_list[i].standardprop-&gt;bytes = val[i];
					prop_list[i].standardprop-&gt;len = (size_t)valLen[i];
					amqp_props._flags |= prop_list[i].flag;
				}
			}
		}
		amqp_props.headers.num_entries = custom;

		/* CHKiRet could not be used because we need to release allocations */
		iRet = publishRabbitMQ(pWrkrData, pWrkrData-&gt;pData-&gt;exchange,
			(pWrkrData-&gt;pData-&gt;routing_key_template)?
				cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_routing_key_template])
				: pWrkrData-&gt;pData-&gt;routing_key,
			&amp;amqp_props, body_bytes);

		for (i=0; i&lt;len; i++)
			if (mustBeFreed[i]) free(val[i]);
	}
	else
	{
		/* As CHKiRet could not be used earlier, iRet is directly used again */
		iRet = publishRabbitMQ(pWrkrData, pWrkrData-&gt;pData-&gt;exchange,
			(pWrkrData-&gt;pData-&gt;routing_key_template)?
				cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_routing_key_template])
				: pWrkrData-&gt;pData-&gt;routing_key,
			amqp_props_msg, body_bytes);
	}

ENDdoAction

BEGINtryResume
CODESTARTtryResume
	iRet = startAMQPConnection(pWrkrData);
ENDtryResume

BEGINcreateInstance
	void *env_var;
CODESTARTcreateInstance
	if ((env_var = getenv("OMRABBITMQ_TEST")) != NULL)
		mode_test = atoi(env_var);

	memset(pData, 0, sizeof(instanceData));
	pData-&gt;iidx = ++instance_counter;
	pData-&gt;delivery_mode = 2;
	pData-&gt;exchange_type = NULL;
	pData-&gt;durable = 0;
	pData-&gt;auto_delete = 1;
ENDcreateInstance

BEGINfreeInstance
CODESTARTfreeInstance
	/* this is a cleanup callback. All dynamically-allocated resources
	 * in instance data must be cleaned up here. Prime examples are
	 * malloc()ed memory, file &amp; database handles and the like.
	 */
	if (pData-&gt;exchange.bytes) free(pData-&gt;exchange.bytes);
	if (pData-&gt;routing_key.bytes) free(pData-&gt;routing_key.bytes);
	if (pData-&gt;routing_key_template) free(pData-&gt;routing_key_template);
	if (pData-&gt;body_template) free(pData-&gt;body_template);
	if (pData-&gt;expiration.bytes) free(pData-&gt;expiration.bytes);
	if (pData-&gt;content_type) free(pData-&gt;content_type);
	if (pData-&gt;vhost) free(pData-&gt;vhost);
	if (pData-&gt;user) free(pData-&gt;user);
	if (pData-&gt;password) free(pData-&gt;password);
	if (pData-&gt;exchange_type) free(pData-&gt;exchange_type);
	if (pData-&gt;server1.host) free(pData-&gt;server1.host);
ENDfreeInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	/* use this to specify if select features are supported by this
	 * plugin. If not, the framework will handle that. Currently, only
	 * RepeatedMsgReduction ("last message repeated n times") is optional.
	 */
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* permits to spit out some debug info */
	dbgprintf("omrabbitmq instance : %d\n", pData-&gt;iidx);
	if (pData-&gt;server2.host) {
		dbgprintf("\thost1='%s' \n", pData-&gt;server1.host);
		dbgprintf("\tport1=%d\n", pData-&gt;server1.port);
		dbgprintf("\thost2='%s' \n", pData-&gt;server2.host);
		dbgprintf("\tport2=%d\n", pData-&gt;server2.port);
		dbgprintf("\tfailback policy :");
		dbgprintf("\t\tusual server check interval=%ld s",
				pData-&gt;recover_policy.return_check_interval);
		dbgprintf("\t\tquick oscillation limit=%ld s",
				pData-&gt;recover_policy.quick_oscillation_interval);
		dbgprintf("\t\tmax number of oscillation=%d s",
				pData-&gt;recover_policy.quick_oscillation_max);
		dbgprintf("\t\tgraceful interval after quick oscillation detection=%ld s",
				pData-&gt;recover_policy.graceful_interval);
	}else{
		dbgprintf("\thost='%s' \n", pData-&gt;server1.host);
		dbgprintf("\tport=%d\n", pData-&gt;server1.port);
	}
	dbgprintf("\tvirtual_host='%s'\n", pData-&gt;vhost);
	dbgprintf("\tuser='%s'\n",  pData-&gt;user == NULL ? "(not configured)" : pData-&gt;user);
	dbgprintf("\tpassword=(%sconfigured)\n", pData-&gt;password == NULL ? "not " : "");

	dbgprintf("\texchange='%*s'\n", (int)pData-&gt;exchange.len,
				(char*)pData-&gt;exchange.bytes);
	dbgprintf("\trouting_key='%*s'\n", (int)pData-&gt;routing_key.len,
				(char*) pData-&gt;routing_key.bytes);
	dbgprintf("\trouting_key_template='%s'\n", pData-&gt;routing_key_template);
	dbgprintf("\tbody_template='%s'\n", pData-&gt;body_template);
	dbgprintf("\texchange_type='%s'\n", pData-&gt;exchange_type);
	dbgprintf("\tauto_delete=%d\n", pData-&gt;auto_delete);
	dbgprintf("\tdurable=%d\n", pData-&gt;durable);
	dbgprintf("\tpopulate_properties=%s\n", (pData-&gt;populate_properties)?"ON":"OFF");
	dbgprintf((pData-&gt;delivery_mode == 1) ? "\tdelivery_mode=TRANSIENT\n":
			"\tdelivery_mode=PERSISTENT\n");
	if (pData-&gt;expiration.len == 0) {
		dbgprintf("\texpiration=UNLIMITED\n");
	}else{
		dbgprintf("\texpiration=%*s\n",
			(int)pData-&gt;expiration.len, (char*) pData-&gt;expiration.bytes);
	}
ENDdbgPrintInstInfo

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	char *host = NULL, *vhost= NULL, *user = NULL, *password = NULL, *recover = NULL;
	int port = 0;
	long long expiration = 0;
CODESTARTnewActInst

	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));

	/* let read parameters */
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, "host")) {
			host = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "recover_policy")) {
			recover = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "port")) {
			port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "virtual_host")) {
			vhost = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "user")) {
			user = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "password")) {
			password = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "exchange")) {
			pData-&gt;exchange = cstring_bytes(es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if (!strcmp(actpblk.descr[i].name, "routing_key")) {
			pData-&gt;routing_key = cstring_bytes(es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if (!strcmp(actpblk.descr[i].name, "routing_key_template")) {
			pData-&gt;routing_key_template = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "populate_properties")) {
			pData-&gt;populate_properties = (sbool) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "delivery_mode")) {
			char *temp = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if (temp){
			  if (!strcasecmp(temp, "TRANSIENT") || !strcmp(temp, "1")) {
				pData-&gt;delivery_mode = 1;
			  } else { if (!strcasecmp(temp, "PERSISTENT") || !strcmp(temp, "2")) {
				pData-&gt;delivery_mode = 2;
			  } else {
				 pData-&gt;delivery_mode = 0;
			  } }
			  free(temp);
			}
		} else if (!strcmp(actpblk.descr[i].name, "expiration")) {
		  expiration =  pvals[i].val.d.n;
			if (expiration &gt; 0) {
				char buf[40];
				snprintf(buf, 40, "%lld", expiration);
				#ifndef __clang_analyzer__
				pData-&gt;expiration = cstring_bytes(strdup(buf));
				#endif
			}
		} else if (!strcmp(actpblk.descr[i].name, "body_template")) {
			pData-&gt;body_template = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "content_type")) {
			pData-&gt;content_type = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "exchange_type")) {
			pData-&gt;exchange_type = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "auto_delete")) {
			pData-&gt;auto_delete = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "durable")) {
			pData-&gt;durable = (int) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INVALID_PARAMS,
				"omrabbitmq module %d: program error, non-handled param '%s'\n",
				pData-&gt;iidx, actpblk.descr[i].name);
		}
	}

	/* let's check config validity */

	if (host == NULL)  {
		LogError(0, RS_RET_INVALID_PARAMS, "omrabbitmq module %d disabled: parameter "
					"host must be specified",
					pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* first if a template for routing_key is set let verify its existence */
	if (pData-&gt;routing_key_template &amp;&amp; tplFind(ourConf, (char*)pData-&gt;routing_key_template,
					strlen((char*)pData-&gt;routing_key_template)) == NULL)
	{
		LogError(0, RS_RET_INVALID_PARAMS, "omrabbitmq module %d : template '%s'"
				" used for routing key does not exist !",
				pData-&gt;iidx, pData-&gt;routing_key_template);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* an exchange must be defined */
	if (pData-&gt;exchange.bytes == NULL) {
		LogError(0, RS_RET_INVALID_PARAMS, "omrabbitmq module %d disabled: parameter "
					"exchange must be specified",
					pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* a static or a template's routing_key must be defined */
	if (pData-&gt;routing_key.bytes == NULL &amp;&amp; pData-&gt;routing_key_template == NULL) {
		LogError(0, RS_RET_INVALID_PARAMS, "omrabbitmq module %d disabled: "
						"one of parameters routing_key or "
						"routing_key_template must be specified", pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* a valid delivery mode must be defined : a 0 means that an invalid value
	 * has been done */
	if (!pData-&gt;delivery_mode)
	{
		LogError(0, RS_RET_CONF_PARAM_INVLD, "omrabbitmq module %d disabled: "
				"parameter delivery_mode must be "
				"TRANSIENT or PERSISTENT (default)", pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* first if a template for message body is set let verify its existence */
	if (pData-&gt;body_template &amp;&amp; *pData-&gt;body_template &amp;&amp;
				tplFind(ourConf, (char*)pData-&gt;body_template,
				        strlen((char*)pData-&gt;body_template)) == NULL)
	{
		LogError(0, RS_RET_CONF_PARAM_INVLD, "omrabbitmq module %d : template '%s'"
				" used for body does not exist !",
				pData-&gt;iidx, pData-&gt;body_template);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* Let's define the size of the doAction tab */
	CODE_STD_STRING_REQUESTnewActInst(1 + ((pData-&gt;routing_key_template) ? 1 : 0) +
					((pData-&gt;body_template &amp;&amp; *pData-&gt;body_template == '\0') ? 0 : 1));

	/* Set the plain text message props */
	memset(&amp;pData-&gt;amqp_props_plaintext, 0, sizeof(amqp_basic_properties_t));
	pData-&gt;amqp_props_plaintext._flags =
				AMQP_BASIC_DELIVERY_MODE_FLAG | AMQP_BASIC_CONTENT_TYPE_FLAG;
	pData-&gt;amqp_props_plaintext.delivery_mode = pData-&gt;delivery_mode;
			/* persistent delivery mode */
	pData-&gt;amqp_props_plaintext.content_type = amqp_cstring_bytes("plain/text");
	if (pData-&gt;expiration.len)
	{
		pData-&gt;amqp_props_plaintext._flags |= AMQP_BASIC_EXPIRATION_FLAG;
		pData-&gt;amqp_props_plaintext.expiration = pData-&gt;expiration;
	}

	memcpy(&amp;pData-&gt;amqp_props_tpl_type, &amp;pData-&gt;amqp_props_plaintext,
			sizeof(amqp_basic_properties_t));

	/* The first position of doAction tab will contain the internal message */
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));

	// RabbitMQ properties initialization
	if (pData-&gt;routing_key_template)
	{
		pData-&gt;idx_routing_key_template = 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, 1,
			(uchar*)strdup((const char *)pData-&gt;routing_key_template),
			OMSR_NO_RQD_TPL_OPTS));
	}

	/* if pData-&gt;body_template is NULL (not defined) then let's use former
	 * json format if pData-&gt;body_template is not an empty string then let's
	 * use it. In this case the content type is defined either
	 * by the template name or the user defined content_type if set
	 * otherwise raw data (unformatted) are sent this is done setting
	 * pData-&gt;idx_body_template to 0 */
	if (pData-&gt;body_template == NULL)
	{ /* no template */
		DBGPRINTF("Body_template is using default StdJSONFmt definition.\n");
		pData-&gt;idx_body_template = pData-&gt;idx_routing_key_template + 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, pData-&gt;idx_body_template,
				(uchar*)strdup(" StdJSONFmt"), OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes("application/json");
	}
	else if (*pData-&gt;body_template)
	{
		pData-&gt;idx_body_template = pData-&gt;idx_routing_key_template + 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, pData-&gt;idx_body_template,
					(uchar*)strdup((const char *)pData-&gt;body_template),
					OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes(
										(pData-&gt;content_type)
										 ? pData-&gt;content_type
										 : (char*)pData-&gt;body_template);
	}else{
		pData-&gt;idx_body_template = 0;
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes(
						(pData-&gt;content_type)
						 ? pData-&gt;content_type
						 :"raw");
	}

	/* treatment of the server parameter
	 * first the default port */
	pData-&gt;server2.port = pData-&gt;server1.port = port ? port : 5672;

	char *temp;
	int p;
	pData-&gt;server1.host = host;

	/* Is there more than one server in parameter */
	if ((pData-&gt;server2.host = strchr(pData-&gt;server1.host,' ')) != NULL)
	{
		*pData-&gt;server2.host++ ='\0';
		/* is there a port with the second server */
		if ((temp = strchr(pData-&gt;server2.host,':')) != NULL)
		{
			*temp++ ='\0';
			p = atoi(temp);
			if (p) pData-&gt;server2.port = p;
		}
	}

	/* is there a port with the first/unique server */
	if ((temp = strchr(pData-&gt;server1.host,':')) != NULL)
	{
		*temp++ ='\0';
		p = atoi(temp);
		if (p) pData-&gt;server1.port = p;
	}

	pData-&gt;vhost = vhost ? vhost : strdup("/");
	pData-&gt;user = user ? user : strdup("");
	pData-&gt;password = password ? password : strdup("");

	init_recover(&amp;pData-&gt;recover_policy, recover);

	if (recover)
	  free(recover);

	dbgPrintInstInfo(pData);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	memset(pWrkrData, 0, sizeof(wrkrInstanceData_t));

	pWrkrData-&gt;pData = pData;

	pthread_mutex_init(&amp;pWrkrData-&gt;send_mutex, NULL);
	pthread_cond_init(&amp;pWrkrData-&gt;cond, NULL);

	pWrkrData-&gt;state = RS_RET_SUSPENDED;
	pWrkrData-&gt;iidx = pData-&gt;iidx;
	pWrkrData-&gt;widx = ++pData-&gt;nbWrkr;

	memcpy(&amp;(pWrkrData-&gt;recover_policy), &amp;(pData-&gt;recover_policy),
			sizeof(recover_t));

	if (pData-&gt;server2.host &amp;&amp; *pData-&gt;server2.host) {
		time_t odd = time(NULL) % 2;
		memcpy(&amp;(pWrkrData-&gt;serverPrefered.s), (odd) ?
				&amp;pData-&gt;server1 : &amp;pData-&gt;server2, sizeof(server_t));
		memcpy(&amp;(pWrkrData-&gt;serverBackup.s), (odd) ?
				&amp;pData-&gt;server2 : &amp;pData-&gt;server1, sizeof(server_t));
	}else{
		memcpy(&amp;(pWrkrData-&gt;serverPrefered.s), &amp;pData-&gt;server1, sizeof(server_t));
	}
	pWrkrData-&gt;serverActive = &amp;pWrkrData-&gt;serverPrefered;

	startAMQPConnection(pWrkrData);

ENDcreateWrkrInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance

	if (pWrkrData != NULL) {
		closeAMQPConnection(pWrkrData);

		pthread_mutex_destroy(&amp;(pWrkrData-&gt;send_mutex));
		pthread_cond_destroy(&amp;(pWrkrData-&gt;cond));
	}
ENDfreeWrkrInstance

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>miniamqpsrvr.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* a very simplistic tcp receiver for the rsyslog testbench.
 *
 * Author Philippe Duveau
 *
 * This file is contribution of the rsyslog project.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#if defined(__FreeBSD__)
#include &lt;netinet/in.h&gt;
#endif

#include "rsyslog.h"


#include &lt;amqp.h&gt;
#include &lt;amqp_framing.h&gt;

#define AMQP_STARTING     ((uchar)0x10)
#define AMQP_STOP         ((uchar)0x00)

#define AMQP_BEHAVIOR_STANDARD	1
#define AMQP_BEHAVIOR_NOEXCH 	2
#define AMQP_BEHAVIOR_DECEXCH 	3
#define AMQP_BEHAVIOR_BADEXCH 	4

uchar connection_start[487] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDF, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x01,
	 0xBA, 0x0C, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6C, 0x69, 0x74, 0x69, 0x65, 0x73, 0x46, 0x00,
	 0x00, 0x00, 0xC7, 0x12, 0x70, 0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x72, 0x5F, 0x63, 0x6F,
	 0x6E, 0x66, 0x69, 0x72, 0x6D, 0x73, 0x74, 0x01, 0x1A, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6E, 0x67,
	 0x65, 0x5F, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x5F, 0x62, 0x69, 0x6E, 0x64, 0x69,
	 0x6E, 0x67, 0x73, 0x74, 0x01, 0x0A, 0x62, 0x61, 0x73, 0x69, 0x63, 0x2E, 0x6E, 0x61, 0x63, 0x6B,
	 0x74, 0x01, 0x16, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x5F, 0x63, 0x61, 0x6E, 0x63,
	 0x65, 0x6C, 0x5F, 0x6E, 0x6F, 0x74, 0x69, 0x66, 0x79, 0x74, 0x01, 0x12, 0x63, 0x6F, 0x6E, 0x6E,
	 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x74, 0x01,
	 0x13, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x5F, 0x70, 0x72, 0x69, 0x6F, 0x72, 0x69,
	 0x74, 0x69, 0x65, 0x73, 0x74, 0x01, 0x1C, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6E, 0x74, 0x69, 0x63,
	 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x5F, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x5F, 0x63, 0x6C,
	 0x6F, 0x73, 0x65, 0x74, 0x01, 0x10, 0x70, 0x65, 0x72, 0x5F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D,
	 0x65, 0x72, 0x5F, 0x71, 0x6F, 0x73, 0x74, 0x01, 0x0F, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x5F,
	 0x72, 0x65, 0x70, 0x6C, 0x79, 0x5F, 0x74, 0x6F, 0x74, 0x01, 0x0C, 0x63, 0x6C, 0x75, 0x73, 0x74,
	 0x65, 0x72, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x53, 0x00, 0x00, 0x00, 0x0D, 0x72, 0x61, 0x62, 0x62,
	 0x69, 0x74, 0x40, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x09, 0x63, 0x6F, 0x70, 0x79, 0x72, 0x69,
	 0x67, 0x68, 0x74, 0x53, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68,
	 0x74, 0x20, 0x28, 0x43, 0x29, 0x20, 0x32, 0x30, 0x30, 0x37, 0x2D, 0x32, 0x30, 0x31, 0x36, 0x20,
	 0x50, 0x69, 0x76, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x53, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65,
	 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x0B, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69,
	 0x6F, 0x6E, 0x53, 0x00, 0x00, 0x00, 0x35, 0x4C, 0x69, 0x63, 0x65, 0x6E, 0x73, 0x65, 0x64, 0x20,
	 0x75, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4D, 0x50, 0x4C, 0x2E, 0x20, 0x20,
	 0x53, 0x65, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x72,
	 0x61, 0x62, 0x62, 0x69, 0x74, 0x6D, 0x71, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x08, 0x70, 0x6C, 0x61,
	 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x53, 0x00, 0x00, 0x00, 0x0A, 0x45, 0x72, 0x6C, 0x61, 0x6E, 0x67,
	 0x2F, 0x4F, 0x54, 0x50, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x53, 0x00, 0x00, 0x00,
	 0x08, 0x52, 0x61, 0x62, 0x62, 0x69, 0x74, 0x4D, 0x51, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F,
	 0x6E, 0x53, 0x00, 0x00, 0x00, 0x05, 0x33, 0x2E, 0x36, 0x2E, 0x32, 0x00, 0x00, 0x00, 0x0E, 0x41,
	 0x4D, 0x51, 0x50, 0x4C, 0x41, 0x49, 0x4E, 0x20, 0x50, 0x4C, 0x41, 0x49, 0x4E, 0x00, 0x00, 0x00,
	 0x05, 0x65, 0x6E, 0x5F, 0x55, 0x53, 0xCE
};

static uchar connection_tune[20] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x0A, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x02, 0x00,
	 0x00, 0x00, 0x3C, 0xCE
};

static uchar connection_open_ok[13] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0A, 0x00, 0x29, 0x00, 0xCE
};

static uchar channel_open_ok[16] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x14, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0xCE
};

static uchar exchange_declare_ok[12] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x28, 0x00, 0x0B, 0xCE
};

static uchar channel_close_ok[12] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x14, 0x00, 0x29, 0xCE
};

static uchar connection_close_ok[12] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0A, 0x00, 0x33, 0xCE
};

static uchar channel_close_ok_on_badexch[148] = {
	0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x14, 0x00, 0x28, 0x01,
	0x96, 0x81, 0x50, 0x52, 0x45, 0x43, 0x4F, 0x4E, 0x44, 0x49, 0x54, 0x49,
	0x4F, 0x4E, 0x5F, 0x46, 0x41, 0x49, 0x4C, 0x45, 0x44, 0x20, 0x2D, 0x20,
	0x69, 0x6E, 0x65, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74,
	0x20, 0x61, 0x72, 0x67, 0x20, 0x27, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6C,
	0x65, 0x27, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x63, 0x68, 0x61,
	0x6E, 0x67, 0x65, 0x20, 0x27, 0x69, 0x6E, 0x27, 0x20, 0x69, 0x6E, 0x20,
	0x76, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x27, 0x2F, 0x6D, 0x65, 0x74, 0x72,
	0x6F, 0x6C, 0x6F, 0x67, 0x69, 0x65, 0x27, 0x3A, 0x20, 0x72, 0x65, 0x63,
	0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x27, 0x66, 0x61, 0x6C, 0x73, 0x65,
	0x27, 0x20, 0x62, 0x75, 0x74, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E,
	0x74, 0x20, 0x69, 0x73, 0x20, 0x27, 0x74, 0x72, 0x75, 0x65, 0x27, 0x00,
	0x28, 0x00, 0x0A, 0xCE
};

typedef struct {
	uchar type;
	ushort ch;
	uint32_t method;
	uint16_t header_flags;
	size_t datalen;
	size_t framelen;
	uchar *data;
} amqp_frame_type_t;

#define DBGPRINTF0(f, ...) if (debug&gt;0) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	fprintf(stderr, "%02d.%03d " f, (int)(dbgtv.tv_sec % 60), \
	       (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}
#define DBGPRINTF1(f, ...) if (debug&gt;0) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	dbgtv.tv_sec -= dbgtv_base.tv_sec; \
	dbgtv.tv_usec -= dbgtv_base.tv_usec; \
	if (dbgtv.tv_usec &lt; 0) { \
		dbgtv.tv_usec += 1000000; \
		dbgtv.tv_sec--; \
	} \
	fprintf(stderr, "%02d.%03d " f, (int)(dbgtv.tv_sec % 60), \
	       (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}
#define DBGPRINTF2(f, ...) if (debug==2) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	dbgtv.tv_sec -= dbgtv_base.tv_sec; \
	dbgtv.tv_usec -= dbgtv_base.tv_usec; \
	if (dbgtv.tv_usec &lt; 0) { \
		dbgtv.tv_usec += 1000000; \
		dbgtv.tv_sec--; \
	} \
	fprintf(stderr, "%02d.%03d " f, (int)(dbgtv.tv_sec % 60), \
				 (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}

static struct timeval dbgtv_base;
static int server_behaviors = 0;
static int behaviors;
static int wait_after_accept = 200; /* milliseconds */
static char *outfile = NULL;
static int debug = 1;

FILE* fpout = NULL;

static ATTR_NORETURN void
errout(const char *reason, int server)
{
	char txt[256];
	snprintf(txt,256,"%s server %d", reason, server);
	perror(txt);
	if (fpout &amp;&amp; fpout != stdout) { fclose(fpout); fpout = NULL; }
	if (outfile) unlink(outfile);
	exit(1);
}

static ATTR_NORETURN void
usage(void)
{
	fprintf(stderr, "usage: minirmqsrvr -f outfile [-b behaviour] "
	        "[-t keep_alive_max] [-w delay_after_fail] [-d]\n");
	exit (1);
}

/* Those three functions are "endianess" insensitive */
static uint16_t buf2uint16(uchar*b) {
	return ((uint16_t)b[0]) &lt;&lt; 8  | ((uint16_t)b[1]);
}

static uint32_t buf2uint32(uchar*b) {
	return ((uint32_t)b[0]) &lt;&lt; 24 | ((uint32_t)b[1]) &lt;&lt; 16 | ((uint32_t)b[2]) &lt;&lt; 8  | ((uint32_t)b[3]);
}

static uint64_t buf2uint64(uchar*b) {
	return ((uint64_t)b[0]) &lt;&lt; 56 | ((uint64_t)b[1]) &lt;&lt; 48 | ((uint64_t)b[2]) &lt;&lt; 40 | ((uint64_t)b[3]) &lt;&lt; 32
	     | ((uint64_t)b[4]) &lt;&lt; 24 | ((uint64_t)b[5]) &lt;&lt; 16 | ((uint64_t)b[6]) &lt;&lt; 8  | ((uint64_t)b[7]);
}


static char AMQP091[8] = { 'A', 'M', 'Q', 'P', 0x00, 0x00, 0x09, 0x01 };

static int
decode_frame_type(uchar *buf, amqp_frame_type_t *frame, size_t nread) {
	if (nread == 8){
		if (memcmp(buf, AMQP091, sizeof(AMQP091)))
			return -1;
		frame-&gt;framelen = 8;
		frame-&gt;type = AMQP_STARTING;
		frame-&gt;ch = 0;
		return 0;
	}
	frame-&gt;type = buf[0];
	frame-&gt;ch = buf2uint16(buf+1);
	frame-&gt;datalen = buf2uint32(buf+3);
	frame-&gt;framelen = frame-&gt;datalen + 8;
	frame-&gt;method = buf2uint32(buf+7);
	switch (frame-&gt;type) {
	case AMQP_FRAME_BODY:
		frame-&gt;data = buf + 7;
		break;
	default:
		frame-&gt;data = buf + 11;
	}
	return 0;
}

static ssize_t
amqp_write(int fdc, uchar *buf, size_t blen, unsigned short channel) {
	buf[1] = (char) (channel &gt;&gt; 8);
	buf[2] = (char) (channel &amp; 0xFF);
	return write(fdc, buf, blen);
}

static uchar *
amqpFieldUint64(uint64_t *d, uchar *s) {
	*d = buf2uint64(s);
	return s + 8;
}

static uchar *
amqpFieldUint32(uint32_t *d, uchar *s) {
	*d = buf2uint32(s);
	return s + 4;
}

static uchar *
amqpFieldUint16(uint16_t *d, uchar *s) {
	*d = buf2uint16(s);
	return s + 2;
}

static uchar *
amqpFieldLenFprintf(const char *pfx, uchar *s, uint32_t len) {
	if (fpout)
		fprintf(fpout, "%s%.*s", pfx, (int)len, (char*)s);
	return s + len;
}

static uchar *
amqpFieldFprintf(const char *pfx, uchar *s) {
	uint32_t len = *s++;
	return amqpFieldLenFprintf(pfx, s, len);
}

static uchar *
amqpHeaderFprintf(uchar *s, uint32_t *size) {
	uint32_t len;
	uchar *p = amqpFieldFprintf(", ", s);
	p++; /* value type */
	p = amqpFieldUint32(&amp;len, p);
	*size -= (p - s) + len;
	return amqpFieldLenFprintf(":",  p, len);
}

static void
amqp_srvr(int port, int srvr, int fds, int piperead, int pipewrite)
{
	uchar wrkBuf[8192], *p;
	size_t nRead = 0, bsize = 0;
	ssize_t nSent;
	amqp_frame_type_t frame;
	uint64_t body_ui64 = 0;
	uint32_t props_header_size;
	uint16_t props_flags;
	int my_behaviour;
	struct timeval tv;
	fd_set rfds;
	int nfds = ((piperead &gt; fds)? piperead : fds) + 1;

	int fdc;

	my_behaviour = behaviors &amp; 0x000F;
	behaviors = behaviors &gt;&gt; 4; /* for next server */;

	if(listen(fds, 0) != 0) errout("listen", port);

	DBGPRINTF1("Server AMQP %d on port %d started\n", srvr, port);

	tv.tv_sec = 120;
	tv.tv_usec = 0;
	FD_ZERO(&amp;rfds);
	FD_SET(fds, &amp;rfds);
	if (piperead &gt; 0)
		FD_SET(piperead, &amp;rfds);

	if (select(nfds,&amp;rfds,NULL,NULL, &amp;tv) == 0) {
		exit(1);
	}

	if (piperead &gt; 0 &amp;&amp; FD_ISSET(piperead, &amp;rfds)) {
		char c;
		int l = read(piperead, &amp;c, 1);
		if (l == 1) {
			my_behaviour = behaviors &amp; 0x000F;
			if (my_behaviour != 0) {
				DBGPRINTF1("Server AMQP %d on port %d switch behaviour", srvr, port);
			} else {
				DBGPRINTF1("Server AMQP %d on port %d leaving", srvr, port);
				if (fpout &amp;&amp; fpout != stdout) { fclose(fpout); fpout = NULL; }
				exit(1);
			}
		}
	}

	fdc = accept(fds, NULL, NULL);

	if (pipewrite &gt; 0)
		nSent = write(pipewrite, "N", 1);

	close(fds);
	fds = -1;

	/* this let the os understand that the port is closed */
	usleep(1000 * wait_after_accept);

	frame.type = AMQP_STARTING;

	while(fdc &gt; 0) {
		nSent = 0;
		ssize_t rd = 0;
		if (nRead &lt; 12) {
			rd = read(fdc, wrkBuf + nRead, sizeof(wrkBuf) - nRead);
			if (rd &lt;= 0) {
				DBGPRINTF1("Server AMQP %d on port %d disconnected\n", srvr, port);
				close(fdc);
				fdc = 0;
				break;
			}else {
				nRead += (size_t)rd;
			}
		}

		if (decode_frame_type(wrkBuf, &amp;frame, nRead)) {
			DBGPRINTF1("Server AMQP %d on port %d killed : bad protocol\n", srvr, port);
			close(fdc);
			fdc = 0;
			break;
		}
		if (rd &gt; 4)
			DBGPRINTF2("Server received : %zd\n", rd);

		switch (frame.type) {

		case AMQP_STARTING: /* starting handshake */

			DBGPRINTF1("Server AMQP %d on port %d type %d connected\n", srvr, port, my_behaviour);
			DBGPRINTF2("Server %d connection.start\n", srvr);
			nSent = amqp_write(fdc, connection_start, sizeof(connection_start), frame.ch);
			break;

		case AMQP_FRAME_METHOD:

			DBGPRINTF2("Server %d method : 0x%X\n", srvr, frame.method);

			switch (frame.method) {

			case AMQP_CONNECTION_START_OK_METHOD:

				DBGPRINTF2("Server %d connection.tune\n", srvr);
				nSent = amqp_write(fdc, connection_tune, sizeof(connection_tune), frame.ch);
				break;

			case AMQP_CONNECTION_TUNE_OK_METHOD:

				DBGPRINTF2("Client %d connection.tune-ok\n", srvr);
				nSent = 0;
				break;

			case AMQP_CONNECTION_OPEN_METHOD:

				nSent = amqp_write(fdc, connection_open_ok,
				          sizeof(connection_open_ok), frame.ch);
				DBGPRINTF2("Server %d connection.open\n", srvr);
				break;

			case AMQP_CHANNEL_OPEN_METHOD:

				nSent = amqp_write(fdc, channel_open_ok,
				        sizeof(channel_open_ok), frame.ch);
				DBGPRINTF2("Server %d channel.open\n", srvr);
				if (my_behaviour == AMQP_BEHAVIOR_NOEXCH) {
					close(fdc);
					DBGPRINTF1("Server AMQP %d on port %d stopped\n", srvr, port);
					fdc = 0;
					frame.type = 0;
				}
				break;

			case AMQP_EXCHANGE_DECLARE_METHOD:

				if (my_behaviour == AMQP_BEHAVIOR_BADEXCH) {
					nSent = amqp_write(fdc, channel_close_ok_on_badexch,
					        sizeof(channel_close_ok_on_badexch), frame.ch);
				}else{
					nSent = amqp_write(fdc, exchange_declare_ok,
					        sizeof(exchange_declare_ok), frame.ch);
				}
				DBGPRINTF2("Server %d exchange.declare\n", srvr);
				if (my_behaviour == AMQP_BEHAVIOR_DECEXCH) {
					close(fdc);
					DBGPRINTF1("Server AMQP %d on port %d stopped\n", srvr, port);
					fdc = 0;
					frame.type = 0;
				}
				break;

			case AMQP_CHANNEL_CLOSE_METHOD:

				nSent = amqp_write(fdc, channel_close_ok,
				           sizeof(channel_close_ok), frame.ch);
				DBGPRINTF2("Server %d channel.close\n", srvr);
				break;

			case AMQP_CONNECTION_CLOSE_METHOD:

				nSent = amqp_write(fdc, connection_close_ok,
				           sizeof(connection_close_ok), frame.ch);
				DBGPRINTF2("Server %d connection.close\n", srvr);
				break;

			case AMQP_BASIC_PUBLISH_METHOD:

				p = amqpFieldFprintf("Exchange:", frame.data + 2);
				amqpFieldFprintf(", routing-key:", p);
				break;

			default:

				nSent = 0;
			}
			break;

		case AMQP_FRAME_HEADER:

			DBGPRINTF2("Server %d HEADERS\n", srvr);
			p = amqpFieldUint64(&amp;body_ui64, frame.data);
			bsize = (size_t)body_ui64;
			p = amqpFieldUint16(&amp;props_flags, p);
			if (props_flags &amp; AMQP_BASIC_CONTENT_TYPE_FLAG) {
				p = amqpFieldFprintf(", content-type:", p);
			}
			if (props_flags &amp; AMQP_BASIC_HEADERS_FLAG) {
				p = amqpFieldUint32(&amp;props_header_size, p);
				while (props_header_size) {
					p = amqpHeaderFprintf(p, &amp;props_header_size);
				}
			}
			if (props_flags &amp; AMQP_BASIC_DELIVERY_MODE_FLAG) {
				if (fpout)
					fprintf(fpout, ", delivery-mode:%s", (*p++)?"transient":"persistent");
			}
			if (props_flags &amp; AMQP_BASIC_EXPIRATION_FLAG) {
				p = amqpFieldFprintf(", expiration:", p);
			}
			if (props_flags &amp; AMQP_BASIC_TIMESTAMP_FLAG) {
				if (fpout)
					fprintf(fpout, ", timestamp:OK");
				p += sizeof(uint64_t);
			}
			if (props_flags &amp; AMQP_BASIC_APP_ID_FLAG) {
				amqpFieldFprintf(", app-id:", p);
			}
			if (fpout)
				fprintf(fpout, ", msg:");
			break;

		case AMQP_FRAME_BODY:

			DBGPRINTF2("Server %d Body size left : %zu, received : %zu\n",
								 srvr, bsize, frame.datalen);
			bsize -= frame.datalen;
			if (fpout) {
				fprintf(fpout, "%.*s", (int)frame.datalen, frame.data);
				if (frame.data[frame.datalen-1] != '\n')
					fprintf(fpout, "\n");
				fflush(fpout);
			}
			break;

		default:

			DBGPRINTF1("Server %d unsupported frame type %d\n", srvr, frame.type);
			close(fdc);
			fdc = 0;
			frame.type = 0;
			frame.framelen = 0;
		} /* switch (frame.type) */

		nRead -= frame.framelen;
		if (nRead&gt;0)
			memmove(wrkBuf, wrkBuf + frame.framelen, nRead);

		if (nSent &lt; 0) {
			close(fdc);
			fdc = 0;
		}
	} /* while(fdc) */
	DBGPRINTF2("Leaving thread %d\n", srvr);
}

int
main(int argc, char *argv[])
{
	int port[2], fds[2], i, opt, nb_port = 1;
	int pipeS1toS2[2] = { -1, -1 };
	int pipeS2toS1[2] = { -1, -1 };
	int pipeRead[2], pipeWrite[2];


	struct sockaddr_in srvAddr[2];
	unsigned int addrLen = sizeof(struct sockaddr_in), len;
	pid_t pid[2];

	fpout = stdout;
<a name="0"></a>
	while((opt = getopt(argc, argv, "f:b:w:d")) != -1) {
		switch (opt) {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		case 'w':
			wait_after_accept = atoi(optarg);
			break;
		case 'd':
			debug = 2;
			break;
		case 'b':
			server_behaviors = atoi(optarg);
			break;
		case 'f':
			if(strcmp(optarg, "-")) {
				outfile = optarg;</b></font>
				fpout = fopen(optarg, "w");
				if(fpout == NULL){
					fprintf(stderr, "file %s could not be created\n", outfile);
					exit(1);
				}
			}
			break;
		default:
			fprintf(stderr, "invalid option '%c' or value missing - terminating...\n", opt);
			usage();
			break;
		}
	}

	switch (server_behaviors) {
	case 0:
		behaviors = AMQP_BEHAVIOR_STANDARD;
		nb_port = 1;
		break;
	case 1: /* two standard servers get message successfully */
		behaviors = AMQP_BEHAVIOR_STANDARD;
		nb_port = 2;
		break;
	case 2:	/* 2 servers first server which disconnect after after open channel : no declare exchange */
		behaviors = AMQP_BEHAVIOR_NOEXCH | AMQP_BEHAVIOR_STANDARD &lt;&lt; 4;
		nb_port = 2;
		break;
	case 3: /* 2 servers first server which disconnect after declare exchange*/
		behaviors = AMQP_BEHAVIOR_DECEXCH | AMQP_BEHAVIOR_STANDARD &lt;&lt; 4;
		nb_port = 2;
		break;
	case 4: /* one server with bad exchange declare */
		behaviors = AMQP_BEHAVIOR_BADEXCH;
		nb_port = 1;
		break;
	default:
		fprintf(stderr,"Invalid behavior");
		exit(1);
	}

	gettimeofday(&amp;dbgtv_base, NULL);

	port[0] = port[1] = -1;

	if (nb_port == 2) {
		if(pipe(pipeS1toS2) == -1 || pipe(pipeS2toS1) == -1) {
			fprintf(stderr, "Pipe failed !");
			exit(1);
		}
	}

	pipeRead[0] = pipeS2toS1[0];
	pipeWrite[0] =  pipeS1toS2[1];

	pipeRead[1] = pipeS1toS2[0];
	pipeWrite[1] = pipeS2toS1[1];

	for (i = 0; i &lt; nb_port; i++) {
		fds[i] = socket(AF_INET, SOCK_STREAM, 0);
		srvAddr[i].sin_family = AF_INET;
		srvAddr[i].sin_addr.s_addr = INADDR_ANY;
		srvAddr[i].sin_port = 0;
		if(bind(fds[i], (struct sockaddr *)&amp;srvAddr[i], addrLen) != 0)
			errout("bind", 1);
		len = addrLen;
		if (getsockname(fds[i], (struct sockaddr *)&amp;srvAddr[i], &amp;len) == -1)
			errout("bind", i+1);
		if ((port[i] = ntohs(srvAddr[i].sin_port)) &lt;= 0)
			errout("get port", i+1);
	}

	for (i = 0; i &lt; nb_port; i++) {
		if ((pid[i] = fork()) == -1) {
			fprintf(stderr, "Fork failed !");
			exit(1);
		}
		if (pid[i] == 0) {
			/* this is the child */
			if (fds[1-i] &gt; 0) close(fds[1-i]);
			amqp_srvr(port[i], i+1, fds[i], pipeRead[i], pipeWrite[i]);

			if (fpout &amp;&amp; fpout != stdout) fclose(fpout);

			DBGPRINTF2("%s\n","Leaving server");
			return 0;
		}
	}

	if (nb_port==2)
		printf("export AMQPSRVRPID1=%ld AMQPSRVRPID2=%ld PORT_AMQP1=%d PORT_AMQP2=%d",
				(long)pid[0], (long)pid[1], port[0], port[1]);
	else
		printf("export AMQPSRVRPID1=%ld PORT_AMQP1=%d",
				(long)pid[0], port[0]);
	return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
