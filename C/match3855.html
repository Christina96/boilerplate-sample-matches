<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omrabbitmq.c & miniamqpsrvr.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omrabbitmq.c & miniamqpsrvr.c
      </h3>
      <h1 align="center">
        1.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omrabbitmq.c (1.3527576%)<TH>miniamqpsrvr.c (2.631579%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3855-0.html#0',2,'match3855-1.html#0',3)" NAME="0">(595-614)<TD><A HREF="javascript:ZweiFrames('match3855-0.html#0',2,'match3855-1.html#0',3)" NAME="0">(551-562)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omrabbitmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omrabbitmq.c
 *
 * This output plugin enables rsyslog to send messages to the RabbitMQ.
 *
 * Copyright 2012-2013 Vaclav Tomec
 * Copyright 2014 Rainer Gerhards
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program. If not, see
 * &lt;http://www.gnu.org/licenses/&gt;.
 *
 * Author: Vaclav Tomec
 * &lt;vaclav.tomec@gmail.com&gt;
 */
#include &quot;config.h&quot;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;debug.h&quot;
#include &quot;datetime.h&quot;
#include &quot;rsconf.h&quot;

#include &lt;sys/socket.h&gt;

#include &quot;amqp.h&quot;
#include &quot;amqp_framing.h&quot;
#include &quot;amqp_tcp_socket.h&quot;
#if (AMQP_VERSION_MAJOR == 0) &amp;&amp; (AMQP_VERSION_MINOR &lt; 4)
#error &quot;rabbitmq-c version must be &gt;= 0.4.0&quot;
#endif

#define RABBITMQ_CHANNEL 1

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omrabbitmq&quot;)

/*
 * internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)

static int instance_counter = 0;
static int mode_test = 0;

typedef struct  {
	char *host;                    /* rabbitmq server fqdn or IP */
	int port;                      /* rabbitmq server port */
} server_t;

typedef struct  {
	server_t s;                    /* rabbitmq server */
	int failures;                  /* rabbitmq server failures */
} server_wrk_t;


typedef struct {
	time_t return_check_interval;      /* time interval between usual server health checks */
	time_t half_return_check_interval; /* for computing */
	time_t quick_oscillation_interval; /* time interval below which the service is not stable */
	int quick_oscillation_max; /* number of quick oscillation after which the connection is kept on backup */
	time_t graceful_interval; /* time interval the connection is kept on backup after which the usual server
							   * check restarts */
	int quick_oscillation_count; /* current number of simultaneous quick oscillation detected */
} recover_t;

typedef struct _instanceData {
	/* here you need to define all action-specific data. A record of type
	 * instanceData will be handed over to each instance of the action. Keep
	 * in mind that there may be several invocations of the same type of action
	 * inside rsyslog.conf, and this is what keeps them apart. Do NOT use
	 * static data for this!
	 */
	amqp_bytes_t exchange;                    /* exchange to send message to */

	amqp_bytes_t routing_key;                 /* fixed routing_key to use */
	uchar *routing_key_template;              /* routing_key template */
	int idx_routing_key_template;             /* routing_key template index in doAction tab */

	sbool populate_properties;                /* populates message properties */
	int delivery_mode;                        /* delivery mode transient or persistent message */
	amqp_bytes_t expiration;                  /* message expiration */

	uchar *body_template;                     /* body template */
	int idx_body_template;                    /* body template index in doAction tab */

	amqp_basic_properties_t amqp_props_tpl_type; /*  */
	char *content_type;                       /*  */
	amqp_basic_properties_t amqp_props_plaintext;   /*  */

	char *exchange_type;                      /*  */
	int durable;                              /*  */
	int auto_delete;                          /*  */

	int iidx;
	int nbWrkr;

	server_t server1;               /* first rabbitmq server  */
	server_t server2;               /* second rabbitmq server */

	char *vhost;                    /* rabbitmq server vhost */
	char *user;                     /* rabbitmq username */
	char *password;                 /* rabbitmq username's password */

	recover_t recover_policy;

} instanceData;

typedef struct wrkrInstanceData {
	amqp_connection_state_t a_conn; /* amqp connection */

	int connected;
	int channel_opened;

	pthread_t thread;               /*  */
	short thread_running;           /*  */
	pthread_mutex_t send_mutex;     /*  */
	pthread_cond_t cond;            /*  */

	rsRetVal state;                 /* state of the connection */

	server_wrk_t serverPrefered;              /* usual rabbitmq server */
	server_wrk_t serverBackup;                /* backup rabbitmq server */
	server_wrk_t *serverActive;               /* active rabbitmq server */

	instanceData *pData;

	recover_t recover_policy;
	time_t last_failback;

	int iidx;
	int widx;
	int go_on;
} wrkrInstanceData_t;

typedef struct _msg2amqp_props_ {
	propid_t id;
	const char *name;
	amqp_bytes_t *standardprop;
	int flag;
} msg2amqp_props_t;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;host&quot;, eCmdHdlrString, 0 },
	{ &quot;port&quot;, eCmdHdlrInt, 0 },
	{ &quot;virtual_host&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;user&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;password&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;exchange&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;routing_key&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;routing_key_template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;delivery_mode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;expiration&quot;, eCmdHdlrNonNegInt, 0 },
	{ &quot;populate_properties&quot;, eCmdHdlrBinary, 0 },
	{ &quot;body_template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;content_type&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;recover_policy&quot;, eCmdHdlrString, 0 },
	{ &quot;exchange_type&quot;, eCmdHdlrGetWord, 0},
	{ &quot;durable&quot;, eCmdHdlrBinary, 0},
	{ &quot;auto_delete&quot;, eCmdHdlrBinary, 0},
};
static struct cnfparamblk actpblk =
	{
		CNFPARAMBLK_VERSION,
		sizeof(actpdescr)/sizeof(struct cnfparamdescr),
		actpdescr
	};

static amqp_bytes_t cstring_bytes(const char *str)
{
	return str ? amqp_cstring_bytes(str) : amqp_empty_bytes;
}

/* Initialize recover structure from the configuration string
 */
static void init_recover(recover_t *fb, char *str)
{
	time_t value[4] = { 0, 0, 0, 0 };

	if (str &amp;&amp; *str){
		int i = -1;
		do {
			value[++i] = strtoul(str, &amp;str, 10);
			if (*str) str++;
		} while (i &lt; 3 &amp;&amp; value[i] &amp;&amp; *str);
	}

	fb-&gt;return_check_interval = (value[0]) ? value[0] : 60;
	fb-&gt;half_return_check_interval = fb-&gt;return_check_interval / 2;
	fb-&gt;quick_oscillation_interval = (value[1]) ? value[1] : (fb-&gt;return_check_interval / 10);
	fb-&gt;quick_oscillation_max = (value[2]) ? (int)(value[2]) : 3;
	fb-&gt;graceful_interval = (value[3]) ? value[3] : (fb-&gt;return_check_interval * 10) -
							fb-&gt;half_return_check_interval;
	fb-&gt;quick_oscillation_count = 0;
}

/* this method compute the delay before next reconnection attempt according
 */
static unsigned long next_check(recover_t *fb, time_t last_failback)
{
	time_t now = time(NULL);
	srandom(now);

	if (now - last_failback &lt; fb-&gt;quick_oscillation_interval) {
		/* quick oscillation detected */
		fb-&gt;quick_oscillation_count++;

		if (fb-&gt;quick_oscillation_count &gt; fb-&gt;quick_oscillation_max) {
			/* too much oscillation inserting a graceful sleep */
			fb-&gt;quick_oscillation_count = 0;
			return fb-&gt;graceful_interval + fb-&gt;return_check_interval * random() / RAND_MAX;
		}
	} else
		fb-&gt;quick_oscillation_count = 0;

	/* returning a standard delay between 0,5 and 1,5 * return_check_interval */
	return fb-&gt;half_return_check_interval + fb-&gt;return_check_interval * random() / RAND_MAX;
}

/* authenticate to rabbitmq server and set connection parameter according to rsyslog configuration
 */
static int amqp_authenticate(wrkrInstanceData_t *self, amqp_connection_state_t a_conn)
{
	amqp_rpc_reply_t ret;

	/* define the frame size */
	int frame_size = (glbl.GetMaxLine(runConf)&lt;130000) ? 131072 : (glbl.GetMaxLine(runConf)+1072);

	/* authenticate */
	ret = amqp_login(a_conn, (char const *)self-&gt;pData-&gt;vhost, 1, frame_size, 0,
			AMQP_SASL_METHOD_PLAIN, self-&gt;pData-&gt;user, self-&gt;pData-&gt;password);

	if (ret.reply_type != AMQP_RESPONSE_NORMAL)
	{
		LogError(0, RS_RET_RABBITMQ_LOGIN_ERR, &quot;omrabbitmq module %d/%d: login to AMQP &quot;
				&quot;server %s failed. (%d / %s)&quot;,
				self-&gt;iidx, self-&gt;widx, self-&gt;serverActive-&gt;s.host, ret.reply_type,
				amqp_error_string2(ret.library_error));
		return 0;
	}

	/* open the communication channel */
	amqp_channel_open(a_conn, 1);

	if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
	{
		LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR, &quot;omrabbitmq module %d/%d: open channel failed.&quot;,
				self-&gt;iidx, self-&gt;widx);
		return 0;
	}

	if (self-&gt;pData-&gt;exchange_type) {
		/* we declare the exchange according to specifications */
		amqp_table_t props = { 0, NULL };
		#if (AMQP_VERSION_MAJOR == 0) &amp;&amp; (AMQP_VERSION_MINOR &lt; 6)
		amqp_exchange_declare(a_conn, 1, self-&gt;pData-&gt;exchange, cstring_bytes(self-&gt;pData-&gt;exchange_type),
		                      0, self-&gt;pData-&gt;durable, props);
		#else
		amqp_exchange_declare(a_conn, 1, self-&gt;pData-&gt;exchange, cstring_bytes(self-&gt;pData-&gt;exchange_type),
		                      0, self-&gt;pData-&gt;durable, self-&gt;pData-&gt;auto_delete, 0, props);
		#endif

		if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
		{
			/* if a problem occurs on declaring the exchange we receive a channel_close with the
			 * error then we can log the error, respond a channel_close_ok and reopen it
			 * so we can work with the existing exchange.
			 */
			amqp_channel_close_ok_t chan_cls_ok;
			amqp_channel_close_t *chan_cls =
							(amqp_channel_close_t*)amqp_get_rpc_reply(a_conn).reply.decoded;

			if (amqp_get_rpc_reply(a_conn).reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION) {
				LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
						&quot;omrabbitmq module %d/%d: disconnected while exchange declare (%d)&quot;,
						self-&gt;iidx, self-&gt;widx, amqp_get_rpc_reply(a_conn).library_error);
				return 0;
			}

			LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
			    &quot;omrabbitmq module %d/%d: exchange declare failed %.*s.&quot;, self-&gt;iidx, self-&gt;widx,
					(int)chan_cls-&gt;reply_text.len, (char*)chan_cls-&gt;reply_text.bytes);

			chan_cls_ok.dummy = '\0';
			amqp_send_method(a_conn, 1, AMQP_CHANNEL_CLOSE_OK_METHOD, &amp;chan_cls_ok);

			/* reopen the communication channel in case of error it should be close by server*/
			amqp_channel_open(a_conn, 1);

			if (amqp_get_rpc_reply(a_conn).reply_type != AMQP_RESPONSE_NORMAL)
			{
				LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR, &quot;omrabbitmq module %d/%d: &quot;
				    &quot;open channel failed.&quot;, self-&gt;iidx, self-&gt;widx);
				return 0;
			}

		}
	}
	/* release the buffers if possible */
	amqp_maybe_release_buffers(a_conn);

	return 1;
}

/* This method establish a new connection
 * @self pointer on the worker datas
 * @server pointer on the server datas (preferred or backup)
 * @return the connection state or NULL on error
 */
static amqp_connection_state_t tryConnection(wrkrInstanceData_t *self, server_t *server)
{
	int retconn = 0;
	struct timeval delay;
	delay.tv_sec = 1;
	delay.tv_usec = 0;

	amqp_connection_state_t a_conn = amqp_new_connection();
	amqp_socket_t *sockfd = (a_conn) ? amqp_tcp_socket_new(a_conn) : NULL;

	if (sockfd)
	{
		LogError(0, RS_RET_RABBITMQ_CHANNEL_ERR,
		    &quot;omrabbitmq module %d/%d: server %s port %d.&quot;, self-&gt;iidx, self-&gt;widx,
		    server-&gt;host, server-&gt;port);

		#if defined(_AIX)
		retconn = amqp_socket_open(sockfd, server-&gt;host, server-&gt;port);
		#else
		retconn = amqp_socket_open_noblock(sockfd, (const char*)server-&gt;host, server-&gt;port, &amp;delay);
		#endif
	}

	if (retconn == AMQP_STATUS_OK &amp;&amp; amqp_authenticate(self, a_conn))
		return a_conn;

	/* the connection failed so free it and return NULL */
	amqp_connection_close(a_conn, 200);
	amqp_destroy_connection(a_conn);

	return NULL;
}

static int manage_connection(wrkrInstanceData_t *self, 	amqp_frame_t *pFrame)
{
	int result;

	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	do {
		if (self-&gt;serverActive == &amp;self-&gt;serverBackup)
		{
			amqp_connection_state_t new_conn;
			struct timeval delay;

			/* The worker is connected to the backup server.
			 * next_check function compute the delay before trying to recover
			 * the connection to the preferred server according to recover_policy
			 */
			delay.tv_sec = next_check(&amp;self-&gt;recover_policy, self-&gt;last_failback);
			delay.tv_usec = 0;

			result = amqp_simple_wait_frame_noblock(self-&gt;a_conn, pFrame, &amp;delay);

			/* if connected to backup server then check if usual server is alive.
			 * if so then disconnect from backup */
			if (result == AMQP_STATUS_TIMEOUT &amp;&amp;
					(new_conn = tryConnection(self,
							&amp;(self-&gt;serverPrefered.s)))
					!= NULL) {
				/* connection is re-established to preferred server so
				 * swap connections */
				amqp_connection_state_t old_conn = self-&gt;a_conn;

				/* now lock to avoid message publishing. */
				pthread_mutex_lock(&amp;self-&gt;send_mutex);
				self-&gt;a_conn = new_conn;
				self-&gt;serverActive = &amp;self-&gt;serverPrefered;
				self-&gt;serverActive-&gt;failures = 0;
				pthread_mutex_unlock(&amp;self-&gt;send_mutex);
				/* back to unlock mode */

				DBGPRINTF(&quot;omrabbitmq module %d: reconnects to usual server.\n&quot;,
							self-&gt;iidx);
				amqp_connection_close(old_conn, 200);
				amqp_destroy_connection(old_conn);
			}

		} else {

			result = amqp_simple_wait_frame(self-&gt;a_conn, pFrame);

		}
	} while(result == AMQP_STATUS_TIMEOUT);

	/* now lock the mutex to avoid message publishing. */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	return result;
}

static void send_connection_close(amqp_connection_state_t state) {
	amqp_connection_close_t *req = malloc(sizeof(amqp_connection_close_t));
	memset(req, 0, sizeof(amqp_connection_close_t));
	req-&gt;reply_code = 200;
	req-&gt;reply_text.bytes = (void*)&quot;200&quot;;
	req-&gt;reply_text.len = 3;
	req-&gt;class_id = (uint16_t)(AMQP_CONNECTION_CLOSE_METHOD &gt;&gt; 16);
	req-&gt;method_id = (uint16_t)(AMQP_CONNECTION_CLOSE_METHOD &amp; 0xFFFF);
	amqp_send_method(state, 0, AMQP_CONNECTION_CLOSE_METHOD, req);
	free(req);
}

static void send_channel_close(amqp_connection_state_t state, amqp_channel_t ch) {
	amqp_channel_close_t *req = malloc(sizeof(amqp_channel_close_t));
	memset(req, 0, sizeof(amqp_channel_close_t));
	req-&gt;reply_code = 200;
	req-&gt;reply_text.bytes = (void*)&quot;200&quot;;
	req-&gt;reply_text.len = 3;
	req-&gt;class_id = (uint16_t)(AMQP_CHANNEL_CLOSE_METHOD &gt;&gt; 16);
	req-&gt;method_id = (uint16_t)(AMQP_CHANNEL_CLOSE_METHOD &amp; 0xFFFF);
	amqp_send_method(state, ch, AMQP_CHANNEL_CLOSE_METHOD, req);
	free(req);
}

static void send_connection_close_ok(amqp_connection_state_t state) {
	amqp_connection_close_ok_t *req = malloc(sizeof(amqp_connection_close_ok_t));
	memset(req, 0, sizeof(amqp_connection_close_ok_t));
	req-&gt;dummy = '\0';
	amqp_send_method(state, 0, AMQP_CONNECTION_CLOSE_OK_METHOD, req);
	free(req);
}

static void send_channel_close_ok(amqp_connection_state_t state, amqp_channel_t ch) {
	amqp_channel_close_ok_t *req = malloc(sizeof(amqp_channel_close_ok_t));
	memset(req, 0, sizeof(amqp_channel_close_ok_t));
	req-&gt;dummy = '\0';
	amqp_send_method(state, ch, AMQP_CHANNEL_CLOSE_OK_METHOD, req);
	free(req);
}

/* run_connection_routine is the thread monitoring of the rabbitmq connection.
 * This method manage reconnection to preferred and backup servers apply the recover_policy
 */
static void* run_connection_routine(void* arg)
{
	wrkrInstanceData_t *self = (wrkrInstanceData_t *) arg;
	amqp_frame_t frm;
	int result;
	self-&gt;connected = 0;
	self-&gt;channel_opened = 0;
	rsRetVal state_out = RS_RET_SUSPENDED;

	dbgSetThrdName((uchar*)&quot;amqp connection&quot;);

	/* now lock to avoid message publishing during part of the thread loop */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	self-&gt;thread_running = 1;

	self-&gt;state = RS_RET_OK;

	srSleep(0,100);

	DBGPRINTF(&quot;omrabbitmq module %d/%d: connection thread started\n&quot;, self-&gt;iidx, self-&gt;widx);

	int go_on = self-&gt;go_on;

	while (go_on) // this loop is used to reconnect on connection failure
	{
		if (self-&gt;a_conn != NULL)
		{
			amqp_connection_close(self-&gt;a_conn, 200);
			amqp_destroy_connection(self-&gt;a_conn);
		}

		self-&gt;a_conn = NULL;

		if (!self-&gt;go_on)
		{
			go_on = 0;
			state_out = RS_RET_DISABLE_ACTION;
			continue; /* lets go back to wile (go_on) and leave cleanly */
		}

		if (self-&gt;serverActive == &amp;self-&gt;serverBackup) {
			self-&gt;serverBackup.failures = 0;
			self-&gt;serverPrefered.failures = 0;
			self-&gt;serverActive = &amp;self-&gt;serverPrefered;
		}

		do { /* this loop tries 3 times per server before switching servers */
			if ((self-&gt;a_conn = tryConnection(self, &amp;(self-&gt;serverActive-&gt;s))) != NULL) {
				self-&gt;serverActive-&gt;failures = 0;
			} else {
				/* set 1 second before retry */
				struct timeval delay;

				delay.tv_sec = 1;
				delay.tv_usec = 0;

				self-&gt;serverActive-&gt;failures++;

				/* if 3 tries */
				if (self-&gt;serverActive-&gt;failures == 3) {

					if (!self-&gt;serverBackup.s.host || self-&gt;serverBackup.failures == 3)
					{
						LogError(0, RS_RET_RABBITMQ_CONN_ERR, &quot;omrabbitmq module connection &quot;
								&quot;failed 3 times on each server.&quot;);
					}

					if (self-&gt;serverActive == &amp;self-&gt;serverBackup) {
						self-&gt;serverBackup.failures = 0;
						self-&gt;serverPrefered.failures = 0;
						self-&gt;serverActive = &amp;self-&gt;serverPrefered;
					} else {
						/* on usual server switch to backup server */
						if (self-&gt;serverBackup.s.host)
							self-&gt;serverActive = &amp;self-&gt;serverBackup;
						else
							self-&gt;serverPrefered.failures = 0;
					}
					/* set 5 second before new round trip */
					delay.tv_sec = 5;
				}
				select(0,NULL,NULL,NULL,&amp;delay);
			}
		}
		while (self-&gt;a_conn == NULL &amp;&amp; self-&gt;go_on);

		if (!self-&gt;go_on)
		{
			go_on = 0;
			state_out = RS_RET_DISABLE_ACTION;
			continue; /* lets go back to wile (go_on) and leave cleanly */
		}

		/* signal that the thread is started */
		pthread_cond_signal(&amp;self-&gt;cond);

		self-&gt;connected = 1;
		self-&gt;channel_opened = 1;

		DBGPRINTF(&quot;omrabbitmq module %d: connected.\n&quot;, self-&gt;iidx);

		self-&gt;state = RS_RET_OK;

		if (self-&gt;serverActive == &amp;self-&gt;serverBackup)
			self-&gt;last_failback = time(NULL);

		while (self-&gt;connected) // this loop is used to manage an established connection
		{

			result = manage_connection(self, &amp;frm);

			switch (result)
			{
			case AMQP_STATUS_NO_MEMORY:
				LogError(0, RS_RET_OUT_OF_MEMORY, &quot;omrabbitmq module %d/%d: no memory &quot;
					&quot;: aborting module.&quot;, self-&gt;iidx, self-&gt;widx);
				go_on = 0; /* non recoverable error let's go out */
<A NAME="0"></A>				self-&gt;connected = 0;
				state_out = RS_RET_DISABLE_ACTION;
				break;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3855-1.html#0',3,'match3855-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			case AMQP_STATUS_BAD_AMQP_DATA:
				LogError(0, RS_RET_RABBITMQ_CONN_ERR, &quot;omrabbitmq module %d/%d: bad &quot;
					&quot;data received : reconnect.&quot;, self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_SOCKET_ERROR:
				LogError(0, RS_RET_RABBITMQ_CONN_ERR, &quot;omrabbitmq module %d/%d: Socket&quot;
					&quot; error : reconnect.&quot;, self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_CONNECTION_CLOSED:
				LogError(0, RS_RET_OUT_OF_MEMORY, &quot;omrabbitmq module %d/%d: Connection&quot;
					&quot; closed : reconnect.&quot;, self-&gt;iidx, self-&gt;widx);
				self-&gt;connected = 0;
				break;
			case AMQP_STATUS_OK:
				/* perhaps not a frame type so ignore it */
				if (frm.frame_type == AMQP_FRAME_METHOD)
				{
					amqp_method_number_t id = frm.payload.method.id;</B></FONT>
					/* now handle frames from the server */
					switch (id)
					{
					case AMQP_CONNECTION_CLOSE_OK_METHOD:

						/* We asked to close the connection and server has responded to us */
						self-&gt;connected = 0;
						go_on = 0;
						break;

					case AMQP_CHANNEL_CLOSE_OK_METHOD:

						/* We asked to close the channel and server has responded to us */
						send_connection_close(self-&gt;a_conn);
						self-&gt;channel_opened = 0;
						break;

					case AMQP_CHANNEL_CLOSE_METHOD:

						/* the server wants to close the channel then the connection */
						LogMsg(0, RS_RET_OK, LOG_WARNING,&quot;omrabbitmq module %d/%d: &quot;
							&quot;Close Channel Received (%X).&quot;, self-&gt;iidx, self-&gt;widx, id);
						 /* answer the server request &amp; send the method */
						send_channel_close_ok(self-&gt;a_conn, frm.channel);
						self-&gt;channel_opened = 0;
						break;

					case AMQP_CONNECTION_CLOSE_METHOD:

						/* the server want to close the connection */
						LogMsg(0, RS_RET_OK, LOG_WARNING, &quot;omrabbitmq module %d/%d: &quot;
							&quot;Close Connection Received (%X).&quot;, self-&gt;iidx, self-&gt;widx, id);
						/* answer the server request */
						send_connection_close_ok(self-&gt;a_conn);
						self-&gt;connected = 0;
						break;

					default :

						LogMsg(0, RS_RET_OK, LOG_WARNING, &quot;omrabbitmq module %d/%d: &quot;
							&quot;Unmanaged amqp method received (%X) : ignored.&quot;,
							self-&gt;iidx, self-&gt;widx, id);
					} /* switch (frm.payload.method.id) */
				} /* if (frm.frame_type == AMQP_FRAME_METHOD) */
				break;
			} /* switch (result) */
		}
	}
	self-&gt;state = state_out;

	/* The core ask to die so let's disconnect */
	if (self-&gt;a_conn != NULL)
	{
		if (self-&gt;channel_opened)
			amqp_channel_close(self-&gt;a_conn, 1, 200);
		if (self-&gt;connected)
			amqp_connection_close(self-&gt;a_conn, 200);
		amqp_destroy_connection(self-&gt;a_conn);
		self-&gt;a_conn = NULL;
	}

	self-&gt;thread_running = 0;

	/* Finishing by unlocking before the end of the thread */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	/* Now notify the worker that this thread is stopping */
	pthread_cond_signal(&amp;self-&gt;cond);

	return NULL;
}

/* ============================================================================================
 * Main thread
 * ============================================================================================
 */

static rsRetVal startAMQPConnection(wrkrInstanceData_t *self)
{
	DEFiRet;
	pthread_mutex_lock(&amp;self-&gt;send_mutex);
	self-&gt;go_on = 1;
	if (self-&gt;thread_running == 0)
	{
		if (!pthread_create(&amp;self-&gt;thread, NULL, run_connection_routine, self))
		{
			pthread_cond_wait(&amp;self-&gt;cond,&amp;self-&gt;send_mutex);
			iRet = self-&gt;state;
		}else{
			iRet = RS_RET_DISABLE_ACTION;
		}
	}
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);
	RETiRet;
}

static void closeAMQPConnection(wrkrInstanceData_t *self)
{
	if (!self || !self-&gt;a_conn) return;

	void *ret;

	/* Now locks to allow exclusive access to sock */
	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	self-&gt;go_on = 0;

	/* send the method */
	if (self-&gt;a_conn)
	{
		if (self-&gt;channel_opened){
			send_channel_close(self-&gt;a_conn, 0);
		} else {
			send_connection_close(self-&gt;a_conn);
		}
	}
	/* Release the lock */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);

	/* Now wvait for the thread to stop */
	pthread_join(self-&gt;thread, &amp;ret);
}

/*
 * Report general error
 */
static int manage_error(int x, char const *context)
{
	int retVal = 0; // false

	if (x &lt; 0) {
		#if (AMQP_VERSION_MINOR &gt;= 4)
		const char *errstr = amqp_error_string2(-x);
		LogError(0, RS_RET_ERR, &quot;omrabbitmq: %s: %s&quot;, context, errstr);
		#else
		char *errstr = amqp_error_string(-x);
		LogError(0, RS_RET_ERR, &quot;omrabbitmq: %s: %s&quot;, context, errstr);
		free(errstr);
		#endif
		retVal = 1; // true
	}

	return retVal;
}

static rsRetVal publishRabbitMQ(wrkrInstanceData_t *self, amqp_bytes_t exchange,
		amqp_bytes_t routing_key, amqp_basic_properties_t *p_amqp_props,
		amqp_bytes_t body_bytes)
{
	DEFiRet;
	/* locks to allow exclusive access to connection */
	if (mode_test &gt; 0) {
		struct timeval tv;
		tv.tv_sec = mode_test/1000;
		tv.tv_usec = mode_test%1000 * 1000;
		select(0, NULL, NULL, NULL, &amp;tv);
	}

	pthread_mutex_lock(&amp;self-&gt;send_mutex);

	if (self-&gt;state != RS_RET_OK)
		 ABORT_FINALIZE(self-&gt;state);

	if (!self-&gt;a_conn){
		ABORT_FINALIZE(RS_RET_RABBITMQ_CONN_ERR);
	}

	if (manage_error(amqp_basic_publish(self-&gt;a_conn, 1, exchange, routing_key,
			0, 0, p_amqp_props, body_bytes), &quot;amqp_basic_publish&quot;)) {
		/* error already notified */
		FINALIZE;
	}

finalize_it:
	/* release exclusive access to connection */
	pthread_mutex_unlock(&amp;self-&gt;send_mutex);
	RETiRet;
}

BEGINdoAction
	int iLen;
CODESTARTdoAction
	/* The first element is a smsg_t pointer */
	smsg_t **pMsg = (smsg_t **)pMsgData;
	smsg_t *msg = pMsg[0];

	amqp_bytes_t body_bytes;
	amqp_basic_properties_t *amqp_props_msg;

	if (!pWrkrData-&gt;pData-&gt;idx_body_template)
	{
		/* No body template so send it as rawmsg */
		getRawMsg(msg, (uchar**)(&amp;body_bytes.bytes), &amp;iLen);
		body_bytes.len = (size_t)iLen;
		amqp_props_msg = &amp;pWrkrData-&gt;pData-&gt;amqp_props_plaintext;
	}
	else
	{
		/* we have a body template */
		body_bytes = cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_body_template]);
		amqp_props_msg = &amp;pWrkrData-&gt;pData-&gt;amqp_props_tpl_type;
	}

	if (pWrkrData-&gt;pData-&gt;populate_properties) {
		/* populate amqp message properties */
		msgPropDescr_t pProp;
		int i, custom = 0;
		amqp_basic_properties_t amqp_props;

		memcpy(&amp;amqp_props, amqp_props_msg, sizeof(amqp_basic_properties_t));

		/* list and mapping of smsg to amqp properties */
		msg2amqp_props_t prop_list[] = {
			{ PROP_SYSLOGFACILITY_TEXT, &quot;facility&quot;,  NULL, 0 },
			{ PROP_SYSLOGSEVERITY_TEXT, &quot;severity&quot;,  NULL, 0 },
			{ PROP_HOSTNAME, &quot;hostname&quot;, NULL, 0 },
			{ PROP_FROMHOST, &quot;fromhost&quot;, NULL, 0 },
			{ PROP_SYSLOGTAG, NULL, &amp;(amqp_props.app_id), AMQP_BASIC_APP_ID_FLAG }
		};
		int len = sizeof(prop_list)/sizeof(msg2amqp_props_t);
		uchar *val[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		rs_size_t valLen[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		unsigned short mustBeFreed[sizeof(prop_list)/sizeof(msg2amqp_props_t)];
		struct amqp_table_entry_t_ tab_entries[sizeof(prop_list)/sizeof(msg2amqp_props_t)];

		amqp_props.headers.entries = tab_entries;

		amqp_props.timestamp = (uint64_t)datetime.syslogTime2time_t(&amp;msg-&gt;tTIMESTAMP);
		amqp_props._flags |= AMQP_BASIC_TIMESTAMP_FLAG;

		for (i=0; i&lt;len; i++)
		{
			/* for each msg property in list get the value and initialize flags */
			pProp.id = prop_list[i].id;
			valLen[i] = 0;
			mustBeFreed[i] = 0;
			val[i] = (uchar*)MsgGetProp(msg, NULL, &amp;pProp, &amp;(valLen[i]), &amp;(mustBeFreed[i]), NULL);
			if (val[i] &amp;&amp; *val[i])
			{
				if (prop_list[i].name)
				{
					/* custom amqp properties */
					tab_entries[custom].key = amqp_cstring_bytes(prop_list[i].name);
					tab_entries[custom].value.kind = AMQP_FIELD_KIND_UTF8;
					tab_entries[custom].value.value.bytes = amqp_cstring_bytes((char*)val[i]);
					amqp_props._flags |= AMQP_BASIC_HEADERS_FLAG;
					custom++;
				} else {
					/* standard amqp properties*/
					prop_list[i].standardprop-&gt;bytes = val[i];
					prop_list[i].standardprop-&gt;len = (size_t)valLen[i];
					amqp_props._flags |= prop_list[i].flag;
				}
			}
		}
		amqp_props.headers.num_entries = custom;

		/* CHKiRet could not be used because we need to release allocations */
		iRet = publishRabbitMQ(pWrkrData, pWrkrData-&gt;pData-&gt;exchange,
			(pWrkrData-&gt;pData-&gt;routing_key_template)?
				cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_routing_key_template])
				: pWrkrData-&gt;pData-&gt;routing_key,
			&amp;amqp_props, body_bytes);

		for (i=0; i&lt;len; i++)
			if (mustBeFreed[i]) free(val[i]);
	}
	else
	{
		/* As CHKiRet could not be used earlier, iRet is directly used again */
		iRet = publishRabbitMQ(pWrkrData, pWrkrData-&gt;pData-&gt;exchange,
			(pWrkrData-&gt;pData-&gt;routing_key_template)?
				cstring_bytes((char*)ppString[pWrkrData-&gt;pData-&gt;idx_routing_key_template])
				: pWrkrData-&gt;pData-&gt;routing_key,
			amqp_props_msg, body_bytes);
	}

ENDdoAction

BEGINtryResume
CODESTARTtryResume
	iRet = startAMQPConnection(pWrkrData);
ENDtryResume

BEGINcreateInstance
	void *env_var;
CODESTARTcreateInstance
	if ((env_var = getenv(&quot;OMRABBITMQ_TEST&quot;)) != NULL)
		mode_test = atoi(env_var);

	memset(pData, 0, sizeof(instanceData));
	pData-&gt;iidx = ++instance_counter;
	pData-&gt;delivery_mode = 2;
	pData-&gt;exchange_type = NULL;
	pData-&gt;durable = 0;
	pData-&gt;auto_delete = 1;
ENDcreateInstance

BEGINfreeInstance
CODESTARTfreeInstance
	/* this is a cleanup callback. All dynamically-allocated resources
	 * in instance data must be cleaned up here. Prime examples are
	 * malloc()ed memory, file &amp; database handles and the like.
	 */
	if (pData-&gt;exchange.bytes) free(pData-&gt;exchange.bytes);
	if (pData-&gt;routing_key.bytes) free(pData-&gt;routing_key.bytes);
	if (pData-&gt;routing_key_template) free(pData-&gt;routing_key_template);
	if (pData-&gt;body_template) free(pData-&gt;body_template);
	if (pData-&gt;expiration.bytes) free(pData-&gt;expiration.bytes);
	if (pData-&gt;content_type) free(pData-&gt;content_type);
	if (pData-&gt;vhost) free(pData-&gt;vhost);
	if (pData-&gt;user) free(pData-&gt;user);
	if (pData-&gt;password) free(pData-&gt;password);
	if (pData-&gt;exchange_type) free(pData-&gt;exchange_type);
	if (pData-&gt;server1.host) free(pData-&gt;server1.host);
ENDfreeInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	/* use this to specify if select features are supported by this
	 * plugin. If not, the framework will handle that. Currently, only
	 * RepeatedMsgReduction (&quot;last message repeated n times&quot;) is optional.
	 */
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* permits to spit out some debug info */
	dbgprintf(&quot;omrabbitmq instance : %d\n&quot;, pData-&gt;iidx);
	if (pData-&gt;server2.host) {
		dbgprintf(&quot;\thost1='%s' \n&quot;, pData-&gt;server1.host);
		dbgprintf(&quot;\tport1=%d\n&quot;, pData-&gt;server1.port);
		dbgprintf(&quot;\thost2='%s' \n&quot;, pData-&gt;server2.host);
		dbgprintf(&quot;\tport2=%d\n&quot;, pData-&gt;server2.port);
		dbgprintf(&quot;\tfailback policy :&quot;);
		dbgprintf(&quot;\t\tusual server check interval=%ld s&quot;,
				pData-&gt;recover_policy.return_check_interval);
		dbgprintf(&quot;\t\tquick oscillation limit=%ld s&quot;,
				pData-&gt;recover_policy.quick_oscillation_interval);
		dbgprintf(&quot;\t\tmax number of oscillation=%d s&quot;,
				pData-&gt;recover_policy.quick_oscillation_max);
		dbgprintf(&quot;\t\tgraceful interval after quick oscillation detection=%ld s&quot;,
				pData-&gt;recover_policy.graceful_interval);
	}else{
		dbgprintf(&quot;\thost='%s' \n&quot;, pData-&gt;server1.host);
		dbgprintf(&quot;\tport=%d\n&quot;, pData-&gt;server1.port);
	}
	dbgprintf(&quot;\tvirtual_host='%s'\n&quot;, pData-&gt;vhost);
	dbgprintf(&quot;\tuser='%s'\n&quot;,  pData-&gt;user == NULL ? &quot;(not configured)&quot; : pData-&gt;user);
	dbgprintf(&quot;\tpassword=(%sconfigured)\n&quot;, pData-&gt;password == NULL ? &quot;not &quot; : &quot;&quot;);

	dbgprintf(&quot;\texchange='%*s'\n&quot;, (int)pData-&gt;exchange.len,
				(char*)pData-&gt;exchange.bytes);
	dbgprintf(&quot;\trouting_key='%*s'\n&quot;, (int)pData-&gt;routing_key.len,
				(char*) pData-&gt;routing_key.bytes);
	dbgprintf(&quot;\trouting_key_template='%s'\n&quot;, pData-&gt;routing_key_template);
	dbgprintf(&quot;\tbody_template='%s'\n&quot;, pData-&gt;body_template);
	dbgprintf(&quot;\texchange_type='%s'\n&quot;, pData-&gt;exchange_type);
	dbgprintf(&quot;\tauto_delete=%d\n&quot;, pData-&gt;auto_delete);
	dbgprintf(&quot;\tdurable=%d\n&quot;, pData-&gt;durable);
	dbgprintf(&quot;\tpopulate_properties=%s\n&quot;, (pData-&gt;populate_properties)?&quot;ON&quot;:&quot;OFF&quot;);
	dbgprintf((pData-&gt;delivery_mode == 1) ? &quot;\tdelivery_mode=TRANSIENT\n&quot;:
			&quot;\tdelivery_mode=PERSISTENT\n&quot;);
	if (pData-&gt;expiration.len == 0) {
		dbgprintf(&quot;\texpiration=UNLIMITED\n&quot;);
	}else{
		dbgprintf(&quot;\texpiration=%*s\n&quot;,
			(int)pData-&gt;expiration.len, (char*) pData-&gt;expiration.bytes);
	}
ENDdbgPrintInstInfo

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	char *host = NULL, *vhost= NULL, *user = NULL, *password = NULL, *recover = NULL;
	int port = 0;
	long long expiration = 0;
CODESTARTnewActInst

	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));

	/* let read parameters */
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, &quot;host&quot;)) {
			host = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;recover_policy&quot;)) {
			recover = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
			port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, &quot;virtual_host&quot;)) {
			vhost = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;user&quot;)) {
			user = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;password&quot;)) {
			password = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;exchange&quot;)) {
			pData-&gt;exchange = cstring_bytes(es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if (!strcmp(actpblk.descr[i].name, &quot;routing_key&quot;)) {
			pData-&gt;routing_key = cstring_bytes(es_str2cstr(pvals[i].val.d.estr, NULL));
		} else if (!strcmp(actpblk.descr[i].name, &quot;routing_key_template&quot;)) {
			pData-&gt;routing_key_template = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;populate_properties&quot;)) {
			pData-&gt;populate_properties = (sbool) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, &quot;delivery_mode&quot;)) {
			char *temp = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if (temp){
			  if (!strcasecmp(temp, &quot;TRANSIENT&quot;) || !strcmp(temp, &quot;1&quot;)) {
				pData-&gt;delivery_mode = 1;
			  } else { if (!strcasecmp(temp, &quot;PERSISTENT&quot;) || !strcmp(temp, &quot;2&quot;)) {
				pData-&gt;delivery_mode = 2;
			  } else {
				 pData-&gt;delivery_mode = 0;
			  } }
			  free(temp);
			}
		} else if (!strcmp(actpblk.descr[i].name, &quot;expiration&quot;)) {
		  expiration =  pvals[i].val.d.n;
			if (expiration &gt; 0) {
				char buf[40];
				snprintf(buf, 40, &quot;%lld&quot;, expiration);
				#ifndef __clang_analyzer__
				pData-&gt;expiration = cstring_bytes(strdup(buf));
				#endif
			}
		} else if (!strcmp(actpblk.descr[i].name, &quot;body_template&quot;)) {
			pData-&gt;body_template = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;content_type&quot;)) {
			pData-&gt;content_type = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;exchange_type&quot;)) {
			pData-&gt;exchange_type = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;auto_delete&quot;)) {
			pData-&gt;auto_delete = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, &quot;durable&quot;)) {
			pData-&gt;durable = (int) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INVALID_PARAMS,
				&quot;omrabbitmq module %d: program error, non-handled param '%s'\n&quot;,
				pData-&gt;iidx, actpblk.descr[i].name);
		}
	}

	/* let's check config validity */

	if (host == NULL)  {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;omrabbitmq module %d disabled: parameter &quot;
					&quot;host must be specified&quot;,
					pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* first if a template for routing_key is set let verify its existence */
	if (pData-&gt;routing_key_template &amp;&amp; tplFind(ourConf, (char*)pData-&gt;routing_key_template,
					strlen((char*)pData-&gt;routing_key_template)) == NULL)
	{
		LogError(0, RS_RET_INVALID_PARAMS, &quot;omrabbitmq module %d : template '%s'&quot;
				&quot; used for routing key does not exist !&quot;,
				pData-&gt;iidx, pData-&gt;routing_key_template);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* an exchange must be defined */
	if (pData-&gt;exchange.bytes == NULL) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;omrabbitmq module %d disabled: parameter &quot;
					&quot;exchange must be specified&quot;,
					pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* a static or a template's routing_key must be defined */
	if (pData-&gt;routing_key.bytes == NULL &amp;&amp; pData-&gt;routing_key_template == NULL) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;omrabbitmq module %d disabled: &quot;
						&quot;one of parameters routing_key or &quot;
						&quot;routing_key_template must be specified&quot;, pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* a valid delivery mode must be defined : a 0 means that an invalid value
	 * has been done */
	if (!pData-&gt;delivery_mode)
	{
		LogError(0, RS_RET_CONF_PARAM_INVLD, &quot;omrabbitmq module %d disabled: &quot;
				&quot;parameter delivery_mode must be &quot;
				&quot;TRANSIENT or PERSISTENT (default)&quot;, pData-&gt;iidx);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* first if a template for message body is set let verify its existence */
	if (pData-&gt;body_template &amp;&amp; *pData-&gt;body_template &amp;&amp;
				tplFind(ourConf, (char*)pData-&gt;body_template,
				        strlen((char*)pData-&gt;body_template)) == NULL)
	{
		LogError(0, RS_RET_CONF_PARAM_INVLD, &quot;omrabbitmq module %d : template '%s'&quot;
				&quot; used for body does not exist !&quot;,
				pData-&gt;iidx, pData-&gt;body_template);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	/* Let's define the size of the doAction tab */
	CODE_STD_STRING_REQUESTnewActInst(1 + ((pData-&gt;routing_key_template) ? 1 : 0) +
					((pData-&gt;body_template &amp;&amp; *pData-&gt;body_template == '\0') ? 0 : 1));

	/* Set the plain text message props */
	memset(&amp;pData-&gt;amqp_props_plaintext, 0, sizeof(amqp_basic_properties_t));
	pData-&gt;amqp_props_plaintext._flags =
				AMQP_BASIC_DELIVERY_MODE_FLAG | AMQP_BASIC_CONTENT_TYPE_FLAG;
	pData-&gt;amqp_props_plaintext.delivery_mode = pData-&gt;delivery_mode;
			/* persistent delivery mode */
	pData-&gt;amqp_props_plaintext.content_type = amqp_cstring_bytes(&quot;plain/text&quot;);
	if (pData-&gt;expiration.len)
	{
		pData-&gt;amqp_props_plaintext._flags |= AMQP_BASIC_EXPIRATION_FLAG;
		pData-&gt;amqp_props_plaintext.expiration = pData-&gt;expiration;
	}

	memcpy(&amp;pData-&gt;amqp_props_tpl_type, &amp;pData-&gt;amqp_props_plaintext,
			sizeof(amqp_basic_properties_t));

	/* The first position of doAction tab will contain the internal message */
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));

	// RabbitMQ properties initialization
	if (pData-&gt;routing_key_template)
	{
		pData-&gt;idx_routing_key_template = 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, 1,
			(uchar*)strdup((const char *)pData-&gt;routing_key_template),
			OMSR_NO_RQD_TPL_OPTS));
	}

	/* if pData-&gt;body_template is NULL (not defined) then let's use former
	 * json format if pData-&gt;body_template is not an empty string then let's
	 * use it. In this case the content type is defined either
	 * by the template name or the user defined content_type if set
	 * otherwise raw data (unformatted) are sent this is done setting
	 * pData-&gt;idx_body_template to 0 */
	if (pData-&gt;body_template == NULL)
	{ /* no template */
		DBGPRINTF(&quot;Body_template is using default StdJSONFmt definition.\n&quot;);
		pData-&gt;idx_body_template = pData-&gt;idx_routing_key_template + 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, pData-&gt;idx_body_template,
				(uchar*)strdup(&quot; StdJSONFmt&quot;), OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes(&quot;application/json&quot;);
	}
	else if (*pData-&gt;body_template)
	{
		pData-&gt;idx_body_template = pData-&gt;idx_routing_key_template + 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, pData-&gt;idx_body_template,
					(uchar*)strdup((const char *)pData-&gt;body_template),
					OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes(
										(pData-&gt;content_type)
										 ? pData-&gt;content_type
										 : (char*)pData-&gt;body_template);
	}else{
		pData-&gt;idx_body_template = 0;
		pData-&gt;amqp_props_tpl_type.content_type = amqp_cstring_bytes(
						(pData-&gt;content_type)
						 ? pData-&gt;content_type
						 :&quot;raw&quot;);
	}

	/* treatment of the server parameter
	 * first the default port */
	pData-&gt;server2.port = pData-&gt;server1.port = port ? port : 5672;

	char *temp;
	int p;
	pData-&gt;server1.host = host;

	/* Is there more than one server in parameter */
	if ((pData-&gt;server2.host = strchr(pData-&gt;server1.host,' ')) != NULL)
	{
		*pData-&gt;server2.host++ ='\0';
		/* is there a port with the second server */
		if ((temp = strchr(pData-&gt;server2.host,':')) != NULL)
		{
			*temp++ ='\0';
			p = atoi(temp);
			if (p) pData-&gt;server2.port = p;
		}
	}

	/* is there a port with the first/unique server */
	if ((temp = strchr(pData-&gt;server1.host,':')) != NULL)
	{
		*temp++ ='\0';
		p = atoi(temp);
		if (p) pData-&gt;server1.port = p;
	}

	pData-&gt;vhost = vhost ? vhost : strdup(&quot;/&quot;);
	pData-&gt;user = user ? user : strdup(&quot;&quot;);
	pData-&gt;password = password ? password : strdup(&quot;&quot;);

	init_recover(&amp;pData-&gt;recover_policy, recover);

	if (recover)
	  free(recover);

	dbgPrintInstInfo(pData);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	memset(pWrkrData, 0, sizeof(wrkrInstanceData_t));

	pWrkrData-&gt;pData = pData;

	pthread_mutex_init(&amp;pWrkrData-&gt;send_mutex, NULL);
	pthread_cond_init(&amp;pWrkrData-&gt;cond, NULL);

	pWrkrData-&gt;state = RS_RET_SUSPENDED;
	pWrkrData-&gt;iidx = pData-&gt;iidx;
	pWrkrData-&gt;widx = ++pData-&gt;nbWrkr;

	memcpy(&amp;(pWrkrData-&gt;recover_policy), &amp;(pData-&gt;recover_policy),
			sizeof(recover_t));

	if (pData-&gt;server2.host &amp;&amp; *pData-&gt;server2.host) {
		time_t odd = time(NULL) % 2;
		memcpy(&amp;(pWrkrData-&gt;serverPrefered.s), (odd) ?
				&amp;pData-&gt;server1 : &amp;pData-&gt;server2, sizeof(server_t));
		memcpy(&amp;(pWrkrData-&gt;serverBackup.s), (odd) ?
				&amp;pData-&gt;server2 : &amp;pData-&gt;server1, sizeof(server_t));
	}else{
		memcpy(&amp;(pWrkrData-&gt;serverPrefered.s), &amp;pData-&gt;server1, sizeof(server_t));
	}
	pWrkrData-&gt;serverActive = &amp;pWrkrData-&gt;serverPrefered;

	startAMQPConnection(pWrkrData);

ENDcreateWrkrInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance

	if (pWrkrData != NULL) {
		closeAMQPConnection(pWrkrData);

		pthread_mutex_destroy(&amp;(pWrkrData-&gt;send_mutex));
		pthread_cond_destroy(&amp;(pWrkrData-&gt;cond));
	}
ENDfreeWrkrInstance

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>miniamqpsrvr.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* a very simplistic tcp receiver for the rsyslog testbench.
 *
 * Author Philippe Duveau
 *
 * This file is contribution of the rsyslog project.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#if defined(__FreeBSD__)
#include &lt;netinet/in.h&gt;
#endif

#include &quot;rsyslog.h&quot;


#include &lt;amqp.h&gt;
#include &lt;amqp_framing.h&gt;

#define AMQP_STARTING     ((uchar)0x10)
#define AMQP_STOP         ((uchar)0x00)

#define AMQP_BEHAVIOR_STANDARD	1
#define AMQP_BEHAVIOR_NOEXCH 	2
#define AMQP_BEHAVIOR_DECEXCH 	3
#define AMQP_BEHAVIOR_BADEXCH 	4

uchar connection_start[487] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDF, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x01,
	 0xBA, 0x0C, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6C, 0x69, 0x74, 0x69, 0x65, 0x73, 0x46, 0x00,
	 0x00, 0x00, 0xC7, 0x12, 0x70, 0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x72, 0x5F, 0x63, 0x6F,
	 0x6E, 0x66, 0x69, 0x72, 0x6D, 0x73, 0x74, 0x01, 0x1A, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6E, 0x67,
	 0x65, 0x5F, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x5F, 0x62, 0x69, 0x6E, 0x64, 0x69,
	 0x6E, 0x67, 0x73, 0x74, 0x01, 0x0A, 0x62, 0x61, 0x73, 0x69, 0x63, 0x2E, 0x6E, 0x61, 0x63, 0x6B,
	 0x74, 0x01, 0x16, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x5F, 0x63, 0x61, 0x6E, 0x63,
	 0x65, 0x6C, 0x5F, 0x6E, 0x6F, 0x74, 0x69, 0x66, 0x79, 0x74, 0x01, 0x12, 0x63, 0x6F, 0x6E, 0x6E,
	 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x74, 0x01,
	 0x13, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x5F, 0x70, 0x72, 0x69, 0x6F, 0x72, 0x69,
	 0x74, 0x69, 0x65, 0x73, 0x74, 0x01, 0x1C, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6E, 0x74, 0x69, 0x63,
	 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x5F, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x5F, 0x63, 0x6C,
	 0x6F, 0x73, 0x65, 0x74, 0x01, 0x10, 0x70, 0x65, 0x72, 0x5F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D,
	 0x65, 0x72, 0x5F, 0x71, 0x6F, 0x73, 0x74, 0x01, 0x0F, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x5F,
	 0x72, 0x65, 0x70, 0x6C, 0x79, 0x5F, 0x74, 0x6F, 0x74, 0x01, 0x0C, 0x63, 0x6C, 0x75, 0x73, 0x74,
	 0x65, 0x72, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x53, 0x00, 0x00, 0x00, 0x0D, 0x72, 0x61, 0x62, 0x62,
	 0x69, 0x74, 0x40, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x09, 0x63, 0x6F, 0x70, 0x79, 0x72, 0x69,
	 0x67, 0x68, 0x74, 0x53, 0x00, 0x00, 0x00, 0x2E, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68,
	 0x74, 0x20, 0x28, 0x43, 0x29, 0x20, 0x32, 0x30, 0x30, 0x37, 0x2D, 0x32, 0x30, 0x31, 0x36, 0x20,
	 0x50, 0x69, 0x76, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x53, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65,
	 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x0B, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69,
	 0x6F, 0x6E, 0x53, 0x00, 0x00, 0x00, 0x35, 0x4C, 0x69, 0x63, 0x65, 0x6E, 0x73, 0x65, 0x64, 0x20,
	 0x75, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4D, 0x50, 0x4C, 0x2E, 0x20, 0x20,
	 0x53, 0x65, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x72,
	 0x61, 0x62, 0x62, 0x69, 0x74, 0x6D, 0x71, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x08, 0x70, 0x6C, 0x61,
	 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x53, 0x00, 0x00, 0x00, 0x0A, 0x45, 0x72, 0x6C, 0x61, 0x6E, 0x67,
	 0x2F, 0x4F, 0x54, 0x50, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x53, 0x00, 0x00, 0x00,
	 0x08, 0x52, 0x61, 0x62, 0x62, 0x69, 0x74, 0x4D, 0x51, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F,
	 0x6E, 0x53, 0x00, 0x00, 0x00, 0x05, 0x33, 0x2E, 0x36, 0x2E, 0x32, 0x00, 0x00, 0x00, 0x0E, 0x41,
	 0x4D, 0x51, 0x50, 0x4C, 0x41, 0x49, 0x4E, 0x20, 0x50, 0x4C, 0x41, 0x49, 0x4E, 0x00, 0x00, 0x00,
	 0x05, 0x65, 0x6E, 0x5F, 0x55, 0x53, 0xCE
};

static uchar connection_tune[20] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x0A, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x02, 0x00,
	 0x00, 0x00, 0x3C, 0xCE
};

static uchar connection_open_ok[13] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0A, 0x00, 0x29, 0x00, 0xCE
};

static uchar channel_open_ok[16] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x14, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0xCE
};

static uchar exchange_declare_ok[12] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x28, 0x00, 0x0B, 0xCE
};

static uchar channel_close_ok[12] = {
	 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x14, 0x00, 0x29, 0xCE
};

static uchar connection_close_ok[12] = {
	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0A, 0x00, 0x33, 0xCE
};

static uchar channel_close_ok_on_badexch[148] = {
	0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x8C, 0x00, 0x14, 0x00, 0x28, 0x01,
	0x96, 0x81, 0x50, 0x52, 0x45, 0x43, 0x4F, 0x4E, 0x44, 0x49, 0x54, 0x49,
	0x4F, 0x4E, 0x5F, 0x46, 0x41, 0x49, 0x4C, 0x45, 0x44, 0x20, 0x2D, 0x20,
	0x69, 0x6E, 0x65, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74,
	0x20, 0x61, 0x72, 0x67, 0x20, 0x27, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6C,
	0x65, 0x27, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x63, 0x68, 0x61,
	0x6E, 0x67, 0x65, 0x20, 0x27, 0x69, 0x6E, 0x27, 0x20, 0x69, 0x6E, 0x20,
	0x76, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x27, 0x2F, 0x6D, 0x65, 0x74, 0x72,
	0x6F, 0x6C, 0x6F, 0x67, 0x69, 0x65, 0x27, 0x3A, 0x20, 0x72, 0x65, 0x63,
	0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x27, 0x66, 0x61, 0x6C, 0x73, 0x65,
	0x27, 0x20, 0x62, 0x75, 0x74, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E,
	0x74, 0x20, 0x69, 0x73, 0x20, 0x27, 0x74, 0x72, 0x75, 0x65, 0x27, 0x00,
	0x28, 0x00, 0x0A, 0xCE
};

typedef struct {
	uchar type;
	ushort ch;
	uint32_t method;
	uint16_t header_flags;
	size_t datalen;
	size_t framelen;
	uchar *data;
} amqp_frame_type_t;

#define DBGPRINTF0(f, ...) if (debug&gt;0) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	fprintf(stderr, &quot;%02d.%03d &quot; f, (int)(dbgtv.tv_sec % 60), \
	       (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}
#define DBGPRINTF1(f, ...) if (debug&gt;0) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	dbgtv.tv_sec -= dbgtv_base.tv_sec; \
	dbgtv.tv_usec -= dbgtv_base.tv_usec; \
	if (dbgtv.tv_usec &lt; 0) { \
		dbgtv.tv_usec += 1000000; \
		dbgtv.tv_sec--; \
	} \
	fprintf(stderr, &quot;%02d.%03d &quot; f, (int)(dbgtv.tv_sec % 60), \
	       (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}
#define DBGPRINTF2(f, ...) if (debug==2) { \
	struct timeval dbgtv; \
	gettimeofday(&amp;dbgtv, NULL);\
	dbgtv.tv_sec -= dbgtv_base.tv_sec; \
	dbgtv.tv_usec -= dbgtv_base.tv_usec; \
	if (dbgtv.tv_usec &lt; 0) { \
		dbgtv.tv_usec += 1000000; \
		dbgtv.tv_sec--; \
	} \
	fprintf(stderr, &quot;%02d.%03d &quot; f, (int)(dbgtv.tv_sec % 60), \
				 (int)(dbgtv.tv_usec/1000), __VA_ARGS__); \
}

static struct timeval dbgtv_base;
static int server_behaviors = 0;
static int behaviors;
static int wait_after_accept = 200; /* milliseconds */
static char *outfile = NULL;
static int debug = 1;

FILE* fpout = NULL;

static ATTR_NORETURN void
errout(const char *reason, int server)
{
	char txt[256];
	snprintf(txt,256,&quot;%s server %d&quot;, reason, server);
	perror(txt);
	if (fpout &amp;&amp; fpout != stdout) { fclose(fpout); fpout = NULL; }
	if (outfile) unlink(outfile);
	exit(1);
}

static ATTR_NORETURN void
usage(void)
{
	fprintf(stderr, &quot;usage: minirmqsrvr -f outfile [-b behaviour] &quot;
	        &quot;[-t keep_alive_max] [-w delay_after_fail] [-d]\n&quot;);
	exit (1);
}

/* Those three functions are &quot;endianess&quot; insensitive */
static uint16_t buf2uint16(uchar*b) {
	return ((uint16_t)b[0]) &lt;&lt; 8  | ((uint16_t)b[1]);
}

static uint32_t buf2uint32(uchar*b) {
	return ((uint32_t)b[0]) &lt;&lt; 24 | ((uint32_t)b[1]) &lt;&lt; 16 | ((uint32_t)b[2]) &lt;&lt; 8  | ((uint32_t)b[3]);
}

static uint64_t buf2uint64(uchar*b) {
	return ((uint64_t)b[0]) &lt;&lt; 56 | ((uint64_t)b[1]) &lt;&lt; 48 | ((uint64_t)b[2]) &lt;&lt; 40 | ((uint64_t)b[3]) &lt;&lt; 32
	     | ((uint64_t)b[4]) &lt;&lt; 24 | ((uint64_t)b[5]) &lt;&lt; 16 | ((uint64_t)b[6]) &lt;&lt; 8  | ((uint64_t)b[7]);
}


static char AMQP091[8] = { 'A', 'M', 'Q', 'P', 0x00, 0x00, 0x09, 0x01 };

static int
decode_frame_type(uchar *buf, amqp_frame_type_t *frame, size_t nread) {
	if (nread == 8){
		if (memcmp(buf, AMQP091, sizeof(AMQP091)))
			return -1;
		frame-&gt;framelen = 8;
		frame-&gt;type = AMQP_STARTING;
		frame-&gt;ch = 0;
		return 0;
	}
	frame-&gt;type = buf[0];
	frame-&gt;ch = buf2uint16(buf+1);
	frame-&gt;datalen = buf2uint32(buf+3);
	frame-&gt;framelen = frame-&gt;datalen + 8;
	frame-&gt;method = buf2uint32(buf+7);
	switch (frame-&gt;type) {
	case AMQP_FRAME_BODY:
		frame-&gt;data = buf + 7;
		break;
	default:
		frame-&gt;data = buf + 11;
	}
	return 0;
}

static ssize_t
amqp_write(int fdc, uchar *buf, size_t blen, unsigned short channel) {
	buf[1] = (char) (channel &gt;&gt; 8);
	buf[2] = (char) (channel &amp; 0xFF);
	return write(fdc, buf, blen);
}

static uchar *
amqpFieldUint64(uint64_t *d, uchar *s) {
	*d = buf2uint64(s);
	return s + 8;
}

static uchar *
amqpFieldUint32(uint32_t *d, uchar *s) {
	*d = buf2uint32(s);
	return s + 4;
}

static uchar *
amqpFieldUint16(uint16_t *d, uchar *s) {
	*d = buf2uint16(s);
	return s + 2;
}

static uchar *
amqpFieldLenFprintf(const char *pfx, uchar *s, uint32_t len) {
	if (fpout)
		fprintf(fpout, &quot;%s%.*s&quot;, pfx, (int)len, (char*)s);
	return s + len;
}

static uchar *
amqpFieldFprintf(const char *pfx, uchar *s) {
	uint32_t len = *s++;
	return amqpFieldLenFprintf(pfx, s, len);
}

static uchar *
amqpHeaderFprintf(uchar *s, uint32_t *size) {
	uint32_t len;
	uchar *p = amqpFieldFprintf(&quot;, &quot;, s);
	p++; /* value type */
	p = amqpFieldUint32(&amp;len, p);
	*size -= (p - s) + len;
	return amqpFieldLenFprintf(&quot;:&quot;,  p, len);
}

static void
amqp_srvr(int port, int srvr, int fds, int piperead, int pipewrite)
{
	uchar wrkBuf[8192], *p;
	size_t nRead = 0, bsize = 0;
	ssize_t nSent;
	amqp_frame_type_t frame;
	uint64_t body_ui64 = 0;
	uint32_t props_header_size;
	uint16_t props_flags;
	int my_behaviour;
	struct timeval tv;
	fd_set rfds;
	int nfds = ((piperead &gt; fds)? piperead : fds) + 1;

	int fdc;

	my_behaviour = behaviors &amp; 0x000F;
	behaviors = behaviors &gt;&gt; 4; /* for next server */;

	if(listen(fds, 0) != 0) errout(&quot;listen&quot;, port);

	DBGPRINTF1(&quot;Server AMQP %d on port %d started\n&quot;, srvr, port);

	tv.tv_sec = 120;
	tv.tv_usec = 0;
	FD_ZERO(&amp;rfds);
	FD_SET(fds, &amp;rfds);
	if (piperead &gt; 0)
		FD_SET(piperead, &amp;rfds);

	if (select(nfds,&amp;rfds,NULL,NULL, &amp;tv) == 0) {
		exit(1);
	}

	if (piperead &gt; 0 &amp;&amp; FD_ISSET(piperead, &amp;rfds)) {
		char c;
		int l = read(piperead, &amp;c, 1);
		if (l == 1) {
			my_behaviour = behaviors &amp; 0x000F;
			if (my_behaviour != 0) {
				DBGPRINTF1(&quot;Server AMQP %d on port %d switch behaviour&quot;, srvr, port);
			} else {
				DBGPRINTF1(&quot;Server AMQP %d on port %d leaving&quot;, srvr, port);
				if (fpout &amp;&amp; fpout != stdout) { fclose(fpout); fpout = NULL; }
				exit(1);
			}
		}
	}

	fdc = accept(fds, NULL, NULL);

	if (pipewrite &gt; 0)
		nSent = write(pipewrite, &quot;N&quot;, 1);

	close(fds);
	fds = -1;

	/* this let the os understand that the port is closed */
	usleep(1000 * wait_after_accept);

	frame.type = AMQP_STARTING;

	while(fdc &gt; 0) {
		nSent = 0;
		ssize_t rd = 0;
		if (nRead &lt; 12) {
			rd = read(fdc, wrkBuf + nRead, sizeof(wrkBuf) - nRead);
			if (rd &lt;= 0) {
				DBGPRINTF1(&quot;Server AMQP %d on port %d disconnected\n&quot;, srvr, port);
				close(fdc);
				fdc = 0;
				break;
			}else {
				nRead += (size_t)rd;
			}
		}

		if (decode_frame_type(wrkBuf, &amp;frame, nRead)) {
			DBGPRINTF1(&quot;Server AMQP %d on port %d killed : bad protocol\n&quot;, srvr, port);
			close(fdc);
			fdc = 0;
			break;
		}
		if (rd &gt; 4)
			DBGPRINTF2(&quot;Server received : %zd\n&quot;, rd);

		switch (frame.type) {

		case AMQP_STARTING: /* starting handshake */

			DBGPRINTF1(&quot;Server AMQP %d on port %d type %d connected\n&quot;, srvr, port, my_behaviour);
			DBGPRINTF2(&quot;Server %d connection.start\n&quot;, srvr);
			nSent = amqp_write(fdc, connection_start, sizeof(connection_start), frame.ch);
			break;

		case AMQP_FRAME_METHOD:

			DBGPRINTF2(&quot;Server %d method : 0x%X\n&quot;, srvr, frame.method);

			switch (frame.method) {

			case AMQP_CONNECTION_START_OK_METHOD:

				DBGPRINTF2(&quot;Server %d connection.tune\n&quot;, srvr);
				nSent = amqp_write(fdc, connection_tune, sizeof(connection_tune), frame.ch);
				break;

			case AMQP_CONNECTION_TUNE_OK_METHOD:

				DBGPRINTF2(&quot;Client %d connection.tune-ok\n&quot;, srvr);
				nSent = 0;
				break;

			case AMQP_CONNECTION_OPEN_METHOD:

				nSent = amqp_write(fdc, connection_open_ok,
				          sizeof(connection_open_ok), frame.ch);
				DBGPRINTF2(&quot;Server %d connection.open\n&quot;, srvr);
				break;

			case AMQP_CHANNEL_OPEN_METHOD:

				nSent = amqp_write(fdc, channel_open_ok,
				        sizeof(channel_open_ok), frame.ch);
				DBGPRINTF2(&quot;Server %d channel.open\n&quot;, srvr);
				if (my_behaviour == AMQP_BEHAVIOR_NOEXCH) {
					close(fdc);
					DBGPRINTF1(&quot;Server AMQP %d on port %d stopped\n&quot;, srvr, port);
					fdc = 0;
					frame.type = 0;
				}
				break;

			case AMQP_EXCHANGE_DECLARE_METHOD:

				if (my_behaviour == AMQP_BEHAVIOR_BADEXCH) {
					nSent = amqp_write(fdc, channel_close_ok_on_badexch,
					        sizeof(channel_close_ok_on_badexch), frame.ch);
				}else{
					nSent = amqp_write(fdc, exchange_declare_ok,
					        sizeof(exchange_declare_ok), frame.ch);
				}
				DBGPRINTF2(&quot;Server %d exchange.declare\n&quot;, srvr);
				if (my_behaviour == AMQP_BEHAVIOR_DECEXCH) {
					close(fdc);
					DBGPRINTF1(&quot;Server AMQP %d on port %d stopped\n&quot;, srvr, port);
					fdc = 0;
					frame.type = 0;
				}
				break;

			case AMQP_CHANNEL_CLOSE_METHOD:

				nSent = amqp_write(fdc, channel_close_ok,
				           sizeof(channel_close_ok), frame.ch);
				DBGPRINTF2(&quot;Server %d channel.close\n&quot;, srvr);
				break;

			case AMQP_CONNECTION_CLOSE_METHOD:

				nSent = amqp_write(fdc, connection_close_ok,
				           sizeof(connection_close_ok), frame.ch);
				DBGPRINTF2(&quot;Server %d connection.close\n&quot;, srvr);
				break;

			case AMQP_BASIC_PUBLISH_METHOD:

				p = amqpFieldFprintf(&quot;Exchange:&quot;, frame.data + 2);
				amqpFieldFprintf(&quot;, routing-key:&quot;, p);
				break;

			default:

				nSent = 0;
			}
			break;

		case AMQP_FRAME_HEADER:

			DBGPRINTF2(&quot;Server %d HEADERS\n&quot;, srvr);
			p = amqpFieldUint64(&amp;body_ui64, frame.data);
			bsize = (size_t)body_ui64;
			p = amqpFieldUint16(&amp;props_flags, p);
			if (props_flags &amp; AMQP_BASIC_CONTENT_TYPE_FLAG) {
				p = amqpFieldFprintf(&quot;, content-type:&quot;, p);
			}
			if (props_flags &amp; AMQP_BASIC_HEADERS_FLAG) {
				p = amqpFieldUint32(&amp;props_header_size, p);
				while (props_header_size) {
					p = amqpHeaderFprintf(p, &amp;props_header_size);
				}
			}
			if (props_flags &amp; AMQP_BASIC_DELIVERY_MODE_FLAG) {
				if (fpout)
					fprintf(fpout, &quot;, delivery-mode:%s&quot;, (*p++)?&quot;transient&quot;:&quot;persistent&quot;);
			}
			if (props_flags &amp; AMQP_BASIC_EXPIRATION_FLAG) {
				p = amqpFieldFprintf(&quot;, expiration:&quot;, p);
			}
			if (props_flags &amp; AMQP_BASIC_TIMESTAMP_FLAG) {
				if (fpout)
					fprintf(fpout, &quot;, timestamp:OK&quot;);
				p += sizeof(uint64_t);
			}
			if (props_flags &amp; AMQP_BASIC_APP_ID_FLAG) {
				amqpFieldFprintf(&quot;, app-id:&quot;, p);
			}
			if (fpout)
				fprintf(fpout, &quot;, msg:&quot;);
			break;

		case AMQP_FRAME_BODY:

			DBGPRINTF2(&quot;Server %d Body size left : %zu, received : %zu\n&quot;,
								 srvr, bsize, frame.datalen);
			bsize -= frame.datalen;
			if (fpout) {
				fprintf(fpout, &quot;%.*s&quot;, (int)frame.datalen, frame.data);
				if (frame.data[frame.datalen-1] != '\n')
					fprintf(fpout, &quot;\n&quot;);
				fflush(fpout);
			}
			break;

		default:

			DBGPRINTF1(&quot;Server %d unsupported frame type %d\n&quot;, srvr, frame.type);
			close(fdc);
			fdc = 0;
			frame.type = 0;
			frame.framelen = 0;
		} /* switch (frame.type) */

		nRead -= frame.framelen;
		if (nRead&gt;0)
			memmove(wrkBuf, wrkBuf + frame.framelen, nRead);

		if (nSent &lt; 0) {
			close(fdc);
			fdc = 0;
		}
	} /* while(fdc) */
	DBGPRINTF2(&quot;Leaving thread %d\n&quot;, srvr);
}

int
main(int argc, char *argv[])
{
	int port[2], fds[2], i, opt, nb_port = 1;
	int pipeS1toS2[2] = { -1, -1 };
	int pipeS2toS1[2] = { -1, -1 };
	int pipeRead[2], pipeWrite[2];


	struct sockaddr_in srvAddr[2];
	unsigned int addrLen = sizeof(struct sockaddr_in), len;
	pid_t pid[2];

	fpout = stdout;
<A NAME="0"></A>
	while((opt = getopt(argc, argv, &quot;f:b:w:d&quot;)) != -1) {
		switch (opt) {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3855-0.html#0',2,'match3855-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		case 'w':
			wait_after_accept = atoi(optarg);
			break;
		case 'd':
			debug = 2;
			break;
		case 'b':
			server_behaviors = atoi(optarg);
			break;
		case 'f':
			if(strcmp(optarg, &quot;-&quot;)) {
				outfile = optarg;</B></FONT>
				fpout = fopen(optarg, &quot;w&quot;);
				if(fpout == NULL){
					fprintf(stderr, &quot;file %s could not be created\n&quot;, outfile);
					exit(1);
				}
			}
			break;
		default:
			fprintf(stderr, &quot;invalid option '%c' or value missing - terminating...\n&quot;, opt);
			usage();
			break;
		}
	}

	switch (server_behaviors) {
	case 0:
		behaviors = AMQP_BEHAVIOR_STANDARD;
		nb_port = 1;
		break;
	case 1: /* two standard servers get message successfully */
		behaviors = AMQP_BEHAVIOR_STANDARD;
		nb_port = 2;
		break;
	case 2:	/* 2 servers first server which disconnect after after open channel : no declare exchange */
		behaviors = AMQP_BEHAVIOR_NOEXCH | AMQP_BEHAVIOR_STANDARD &lt;&lt; 4;
		nb_port = 2;
		break;
	case 3: /* 2 servers first server which disconnect after declare exchange*/
		behaviors = AMQP_BEHAVIOR_DECEXCH | AMQP_BEHAVIOR_STANDARD &lt;&lt; 4;
		nb_port = 2;
		break;
	case 4: /* one server with bad exchange declare */
		behaviors = AMQP_BEHAVIOR_BADEXCH;
		nb_port = 1;
		break;
	default:
		fprintf(stderr,&quot;Invalid behavior&quot;);
		exit(1);
	}

	gettimeofday(&amp;dbgtv_base, NULL);

	port[0] = port[1] = -1;

	if (nb_port == 2) {
		if(pipe(pipeS1toS2) == -1 || pipe(pipeS2toS1) == -1) {
			fprintf(stderr, &quot;Pipe failed !&quot;);
			exit(1);
		}
	}

	pipeRead[0] = pipeS2toS1[0];
	pipeWrite[0] =  pipeS1toS2[1];

	pipeRead[1] = pipeS1toS2[0];
	pipeWrite[1] = pipeS2toS1[1];

	for (i = 0; i &lt; nb_port; i++) {
		fds[i] = socket(AF_INET, SOCK_STREAM, 0);
		srvAddr[i].sin_family = AF_INET;
		srvAddr[i].sin_addr.s_addr = INADDR_ANY;
		srvAddr[i].sin_port = 0;
		if(bind(fds[i], (struct sockaddr *)&amp;srvAddr[i], addrLen) != 0)
			errout(&quot;bind&quot;, 1);
		len = addrLen;
		if (getsockname(fds[i], (struct sockaddr *)&amp;srvAddr[i], &amp;len) == -1)
			errout(&quot;bind&quot;, i+1);
		if ((port[i] = ntohs(srvAddr[i].sin_port)) &lt;= 0)
			errout(&quot;get port&quot;, i+1);
	}

	for (i = 0; i &lt; nb_port; i++) {
		if ((pid[i] = fork()) == -1) {
			fprintf(stderr, &quot;Fork failed !&quot;);
			exit(1);
		}
		if (pid[i] == 0) {
			/* this is the child */
			if (fds[1-i] &gt; 0) close(fds[1-i]);
			amqp_srvr(port[i], i+1, fds[i], pipeRead[i], pipeWrite[i]);

			if (fpout &amp;&amp; fpout != stdout) fclose(fpout);

			DBGPRINTF2(&quot;%s\n&quot;,&quot;Leaving server&quot;);
			return 0;
		}
	}

	if (nb_port==2)
		printf(&quot;export AMQPSRVRPID1=%ld AMQPSRVRPID2=%ld PORT_AMQP1=%d PORT_AMQP2=%d&quot;,
				(long)pid[0], (long)pid[1], port[0], port[1]);
	else
		printf(&quot;export AMQPSRVRPID1=%ld PORT_AMQP1=%d&quot;,
				(long)pid[0], port[0]);
	return 0;
}
</PRE>
</div>
  </div>
</body>
</html>
