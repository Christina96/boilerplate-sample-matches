
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nfct.h</h3>
            <pre><code>1  #ifndef NRF_NFCT_H__
2  #define NRF_NFCT_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_NFCT_CRC_SIZE 2                 &bsol;**< CRC size in bytes. */
8  #define NRF_NFCT_DISABLE_ALL_INT 0xFFFFFFFF &bsol;**< Value to disable all interrupts. */
9  #define NRF_NFCT_MOD_CTRL_PIN_NOT_CONNECTED  0xFFFFFFFF
10  typedef enum
11  {
12      NRF_NFCT_TASK_ACTIVATE     = offsetof(NRF_NFCT_Type, TASKS_ACTIVATE),     &bsol;**< Activate the NFCT peripheral for the incoming and outgoing frames, change state to activated. */
13      NRF_NFCT_TASK_DISABLE      = offsetof(NRF_NFCT_Type, TASKS_DISABLE),      &bsol;**< Disable the NFCT peripheral. */
14      NRF_NFCT_TASK_SENSE        = offsetof(NRF_NFCT_Type, TASKS_SENSE),        &bsol;**< Enable the NFC sense field mode, change state to sense mode. */
15      NRF_NFCT_TASK_STARTTX      = offsetof(NRF_NFCT_Type, TASKS_STARTTX),      &bsol;**< Start the transmission of an outgoing frame, change state to transmit. */
16      NRF_NFCT_TASK_ENABLERXDATA = offsetof(NRF_NFCT_Type, TASKS_ENABLERXDATA), &bsol;**< Initialize EasyDMA for receive. */
17      NRF_NFCT_TASK_GOIDLE       = offsetof(NRF_NFCT_Type, TASKS_GOIDLE),       &bsol;**< Force state machine to the IDLE state. */
18      NRF_NFCT_TASK_GOSLEEP      = offsetof(NRF_NFCT_Type, TASKS_GOSLEEP),      &bsol;**< Force state machine to the SLEEP_A state. */
19  } nrf_nfct_task_t;
20  typedef enum
21  {
22      NRF_NFCT_EVENT_READY             = offsetof(NRF_NFCT_Type, EVENTS_READY),             &bsol;**< The NFCT peripheral is ready to receive and send frames. */
23      NRF_NFCT_EVENT_FIELDDETECTED     = offsetof(NRF_NFCT_Type, EVENTS_FIELDDETECTED),     &bsol;**< Remote NFC field is detected. */
24      NRF_NFCT_EVENT_FIELDLOST         = offsetof(NRF_NFCT_Type, EVENTS_FIELDLOST),         &bsol;**< Remote NFC field is lost. */
25      NRF_NFCT_EVENT_TXFRAMESTART      = offsetof(NRF_NFCT_Type, EVENTS_TXFRAMESTART),      &bsol;**< The start of the first symbol of a transmitted frame. */
26      NRF_NFCT_EVENT_TXFRAMEEND        = offsetof(NRF_NFCT_Type, EVENTS_TXFRAMEEND),        &bsol;**< The end of the last transmitted on-air symbol of a frame. */
27      NRF_NFCT_EVENT_RXFRAMESTART      = offsetof(NRF_NFCT_Type, EVENTS_RXFRAMESTART),      &bsol;**< The end of the first symbol of a received frame. */
28      NRF_NFCT_EVENT_RXFRAMEEND        = offsetof(NRF_NFCT_Type, EVENTS_RXFRAMEEND),        &bsol;**< Received data was checked (CRC, parity) and transferred to RAM, and EasyDMA ended accessing the RX buffer. */
29      NRF_NFCT_EVENT_ERROR             = offsetof(NRF_NFCT_Type, EVENTS_ERROR),             &bsol;**< NFC error reported. The ERRORSTATUS register contains details on the source of the error. */
30      NRF_NFCT_EVENT_RXERROR           = offsetof(NRF_NFCT_Type, EVENTS_RXERROR),           &bsol;**< NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error. */
31      NRF_NFCT_EVENT_ENDRX             = offsetof(NRF_NFCT_Type, EVENTS_ENDRX),             &bsol;**< RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full. */
32      NRF_NFCT_EVENT_ENDTX             = offsetof(NRF_NFCT_Type, EVENTS_ENDTX),             &bsol;**< Transmission of data in RAM ended, and EasyDMA ended accessing the TX buffer. */
33      NRF_NFCT_EVENT_AUTOCOLRESSTARTED = offsetof(NRF_NFCT_Type, EVENTS_AUTOCOLRESSTARTED), &bsol;**< Auto collision resolution process started. */
34      NRF_NFCT_EVENT_COLLISION         = offsetof(NRF_NFCT_Type, EVENTS_COLLISION),         &bsol;**< NFC auto collision resolution error reported. */
35      NRF_NFCT_EVENT_SELECTED          = offsetof(NRF_NFCT_Type, EVENTS_SELECTED),          &bsol;**< NFC auto collision resolution successfully completed. */
36      NRF_NFCT_EVENT_STARTED           = offsetof(NRF_NFCT_Type, EVENTS_STARTED),           &bsol;**< EasyDMA is ready to receive or send frames. */
37  } nrf_nfct_event_t;
38  typedef enum
39  {
40      NRF_NFCT_SHORT_FIELDDETECTED_ACTIVATE_MASK  = NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk,  &bsol;**< Shortcut between the FIELDDETECTED event and the ACTIVATE task. */
41      NRF_NFCT_SHORT_FIELDLOST_SENSE_MASK         = NFCT_SHORTS_FIELDLOST_SENSE_Msk,         &bsol;**< Shortcut between the FIELDLOST event and the SENSE task. */
42  #if defined(NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk) || defined(__NRFX_DOXYGEN__)
43      NRF_NFCT_SHORT_TXFRAMEEND_ENABLERXDATA_MASK = NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk, &bsol;**< Shortcut between the TXFRAMEEND event and the ENABLERXDATA task. */
44  #endif 
45  } nrf_nfct_short_mask_t;
46  typedef enum
47  {
48      NRF_NFCT_INT_READY_MASK             = NFCT_INTEN_READY_Msk,             &bsol;**< Interrupt on READY event. */
49      NRF_NFCT_INT_FIELDDETECTED_MASK     = NFCT_INTEN_FIELDDETECTED_Msk,     &bsol;**< Interrupt on FIELDDETECTED event. */
50      NRF_NFCT_INT_FIELDLOST_MASK         = NFCT_INTEN_FIELDLOST_Msk,         &bsol;**< Interrupt on FIELDLOST event. */
51      NRF_NFCT_INT_TXFRAMESTART_MASK      = NFCT_INTEN_TXFRAMESTART_Msk,      &bsol;**< Interrupt on TXFRAMESTART event. */
52      NRF_NFCT_INT_TXFRAMEEND_MASK        = NFCT_INTEN_TXFRAMEEND_Msk,        &bsol;**< Interrupt on TXFRAMEEND event. */
53      NRF_NFCT_INT_RXFRAMESTART_MASK      = NFCT_INTEN_RXFRAMESTART_Msk,      &bsol;**< Interrupt on RXFRAMESTART event. */
54      NRF_NFCT_INT_RXFRAMEEND_MASK        = NFCT_INTEN_RXFRAMEEND_Msk,        &bsol;**< Interrupt on RXFRAMEEND event. */
55      NRF_NFCT_INT_ERROR_MASK             = NFCT_INTEN_ERROR_Msk,             &bsol;**< Interrupt on ERROR event. */
56      NRF_NFCT_INT_RXERROR_MASK           = NFCT_INTEN_RXERROR_Msk,           &bsol;**< Interrupt on RXERROR event. */
57      NRF_NFCT_INT_ENDRX_MASK             = NFCT_INTEN_ENDRX_Msk,             &bsol;**< Interrupt on ENDRX event. */
58      NRF_NFCT_INT_ENDTX_MASK             = NFCT_INTEN_ENDTX_Msk,             &bsol;**< Interrupt on ENDTX event. */
59      NRF_NFCT_INT_AUTOCOLRESSTARTED_MASK = NFCT_INTEN_AUTOCOLRESSTARTED_Msk, &bsol;**< Interrupt on AUTOCOLRESSTARTED event. */
60      NRF_NFCT_INT_COLLISION_MASK         = NFCT_INTEN_COLLISION_Msk,         &bsol;**< Interrupt on COLLISION event. */
61      NRF_NFCT_INT_SELECTED_MASK          = NFCT_INTEN_SELECTED_Msk,          &bsol;**< Interrupt on SELECTED event. */
62      NRF_NFCT_INT_STARTED_MASK           = NFCT_INTEN_STARTED_Msk,           &bsol;**< Interrupt on STARTED event. */
63  } nrf_nfct_int_mask_t;
64  typedef enum
65  {
66      NRF_NFCT_ERROR_FRAMEDELAYTIMEOUT_MASK = NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk, &bsol;**< Timeout of the Frame Delay Timer (no frame transmission started in the FDT window). */
67  #if defined(NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk) || defined(__NRFX_DOXYGEN__)
68      NRF_NFCT_ERROR_NFCFIELDTOOSTRONG_MASK = NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk, &bsol;**< Field level is too high at maximum load resistance. */
69  #endif 
70  #if defined(NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk) || defined(__NRFX_DOXYGEN__)
71      NRF_NFCT_ERROR_NFCFIELDTOOWEAK_MASK = NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk,     &bsol;**< Field level is too low at minimum load resistance. */
72  #endif 
73  } nrf_nfct_error_status_t;
74  typedef enum
75  {
76      NRF_NFCT_RX_FRAME_STATUS_CRC_MASK     = NFCT_FRAMESTATUS_RX_CRCERROR_Msk,     &bsol;**< CRC status mask. */
77      NRF_NFCT_RX_FRAME_STATUS_PARITY_MASK  = NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk, &bsol;**< Parity status mask. */
78      NRF_NFCT_RX_FRAME_STATUS_OVERRUN_MASK = NFCT_FRAMESTATUS_RX_OVERRUN_Msk,      &bsol;**< Overrun status mask. */
79  } nrf_nfct_rx_frame_status_t;
80  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
81  typedef enum
82  {
83      NRF_NFCT_TAG_STATE_DISABLED    = NFCT_NFCTAGSTATE_NFCTAGSTATE_Disabled,   &bsol;**< Disabled or sensing NFC field. */
84      NRF_NFCT_TAG_STATE_RAMP_UP     = NFCT_NFCTAGSTATE_NFCTAGSTATE_RampUp,     &bsol;**< Ramping up. */
85      NRF_NFCT_TAG_STATE_IDLE        = NFCT_NFCTAGSTATE_NFCTAGSTATE_Idle,       &bsol;**< Idle. */
86      NRF_NFCT_TAG_STATE_RECEIVE     = NFCT_NFCTAGSTATE_NFCTAGSTATE_Receive,    &bsol;**< Receiving data. */
87      NRF_NFCT_TAG_STATE_FRAME_DELAY = NFCT_NFCTAGSTATE_NFCTAGSTATE_FrameDelay, &bsol;**< Counting Frame Delay Time since the last symbol of the last received frame. */
88      NRF_NFCT_TAG_STATE_TRANSMIT    = NFCT_NFCTAGSTATE_NFCTAGSTATE_Transmit    &bsol;**< Transmitting data. */
89  } nrf_nfct_tag_state_t;
90  #endif 
91  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
92  typedef enum
93  {
94      NRF_NFCT_SLEEP_STATE_IDLE    = NFCT_SLEEPSTATE_SLEEPSTATE_Idle,  &bsol;**< 'IDLE' state. */
95      NRF_NFCT_SLEEP_STATE_SLEEP_A = NFCT_SLEEPSTATE_SLEEPSTATE_SleepA &bsol;**< 'SLEEP_A' state. */
96  } nrf_nfct_sleep_state_t;
97  #endif 
98  typedef enum
99  {
100      NRF_NFCT_FIELD_STATE_PRESENT_MASK = NFCT_FIELDPRESENT_FIELDPRESENT_Msk, &bsol;**< Field presence mask. */
101      NRF_NFCT_FIELD_STATE_LOCK_MASK    = NFCT_FIELDPRESENT_LOCKDETECT_Msk    &bsol;**< Field lock mask. */
102  } nrf_nfct_field_state_t;
103  typedef enum
104  {
105      NRF_NFCT_FRAME_DELAY_MODE_FREERUN    = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun,   &bsol;**< Frame transmission starts when @ref NRF_NFCT_TASK_STARTTX is set (delay timer is not used). */
106      NRF_NFCT_FRAME_DELAY_MODE_WINDOW     = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window,    &bsol;**< Frame transmission starts in a window between FRAMEDELAYMIN and FRAMEDELAYMAX. */
107      NRF_NFCT_FRAME_DELAY_MODE_EXACTVAL   = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal,  &bsol;**< Frame transmission starts when the delay timer reaches FRAMEDELAYMAX. */
108      NRF_NFCT_FRAME_DELAY_MODE_WINDOWGRID = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid &bsol;**< Frame transmission starts in a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX. */
109  } nrf_nfct_frame_delay_mode_t;
110  typedef enum
111  {
112      NRF_NFCT_TX_FRAME_CONFIG_PARITY        = NFCT_TXD_FRAMECONFIG_PARITY_Msk,      &bsol;**< Indicates whether parity is added in the transmitted frames. */
113      NRF_NFCT_TX_FRAME_CONFIG_DISCARD_START = NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk, &bsol;**< Indicates whether unused bits are discarded at the start or at the end of the transmitted frames. */
114      NRF_NFCT_TX_FRAME_CONFIG_SOF           = NFCT_TXD_FRAMECONFIG_SOF_Msk,         &bsol;**< Indicates whether SoF symbol is added in the transmitted frames. */
115      NRF_NFCT_TX_FRAME_CONFIG_CRC16         = NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk    &bsol;**< Indicates whether CRC is added in the transmitted frames. */
116  } nrf_nfct_tx_frame_config_t;
117  typedef enum
118  {
119      NRF_NFCT_RX_FRAME_CONFIG_PARITY = NFCT_RXD_FRAMECONFIG_PARITY_Msk,   &bsol;**< Indicates whether parity is expected in the received frames. */
120      NRF_NFCT_RX_FRAME_CONFIG_SOF    = NFCT_RXD_FRAMECONFIG_SOF_Msk,      &bsol;**< Indicates whether SoF symbol is expected in the received frames. */
121      NRF_NFCT_RX_FRAME_CONFIG_CRC16  = NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk &bsol;**< Indicates whether CRC is expected and checked in the received frames. */
122  } nrf_nfct_rx_frame_config_t;
123  typedef enum
124  {
125      NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE =
126          NFCT_SENSRES_NFCIDSIZE_NFCID1Single << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Single size NFCID1 (4 bytes). */
127      NRF_NFCT_SENSRES_NFCID1_SIZE_DOUBLE =
128          NFCT_SENSRES_NFCIDSIZE_NFCID1Double << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Double size NFCID1 (7 bytes). */
129      NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE =
130          NFCT_SENSRES_NFCIDSIZE_NFCID1Triple << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Triple size NFCID1 (10 bytes). */
131      NRF_NFCT_SENSRES_NFCID1_SIZE_DEFAULT =
132          NFCT_SENSRES_NFCIDSIZE_Msk                                         &bsol;**< Default size. Use this option to leave NFCID1 size unchanged. */
133  } nrf_nfct_sensres_nfcid1_size_t;
134  typedef enum
135  {
136      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00000 =
137          NFCT_SENSRES_BITFRAMESDD_SDD00000 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00000. */
138      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00001 =
139          NFCT_SENSRES_BITFRAMESDD_SDD00001 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00001. */
140      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00010 =
141          NFCT_SENSRES_BITFRAMESDD_SDD00010 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00010. */
142      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00100 =
143          NFCT_SENSRES_BITFRAMESDD_SDD00100 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00100. */
144      NRF_NFCT_SENSRES_BIT_FRAME_SDD_01000 =
145          NFCT_SENSRES_BITFRAMESDD_SDD01000 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 01000. */
146      NRF_NFCT_SENSRES_BIT_FRAME_SDD_10000 =
147          NFCT_SENSRES_BITFRAMESDD_SDD10000 << NFCT_SENSRES_BITFRAMESDD_Pos  &bsol;**< SDD pattern 10000. */
148  } nrf_nfct_sensres_bit_frame_sdd_t;
149  typedef enum
150  {
151      NRF_NFCT_SENSRES_PLATFORM_CONFIG_T1T   = 6 << NFCT_SENSRES_PLATFCONFIG_Pos,
152      NRF_NFCT_SENSRES_PLATFORM_CONFIG_OTHER = 0 << NFCT_SENSRES_PLATFCONFIG_Pos
153  } nrf_nfct_sensres_platform_config_t;
154  typedef enum
155  {
156      NRF_NFCT_SELRES_CASCADE_MASK  = NFCT_SELRES_CASCADE_Msk,  &bsol;**< SEL_RES Cascade field bit mask. */
157      NRF_NFCT_SELRES_PROTOCOL_MASK = NFCT_SELRES_PROTOCOL_Msk  &bsol;**< SEL_RES Protocol field bit mask. */
158  } nrf_nfct_selres_t;
159  typedef enum
160  {
161      NRF_NFCT_SELRES_PROTOCOL_T2T         = 0,  &bsol;**< Type 2 Tag platform. */
162      NRF_NFCT_SELRES_PROTOCOL_T4AT        = 1,  &bsol;**< Type 4A Tag platform. */
163      NRF_NFCT_SELRES_PROTOCOL_NFCDEP      = 2,  &bsol;**< NFC-DEP Protocol. */
164      NRF_NFCT_SELRES_PROTOCOL_NFCDEP_T4AT = 3,  &bsol;**< NFC-DEP Protocol and Type 4A Tag platform). */
165  } nrf_nfct_selres_protocol_t;
166  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk) || defined(__NRFX_DOXYGEN__)
167  typedef enum
168  {
169      NRF_NFCT_MODULATION_CTRL_INVALID       = NFCT_MODULATIONCTRL_MODULATIONCTRL_Invalid,             &bsol;**< Invalid configuration. Defaults to the same behavior as NRF_NFCT_MODULATION_CTRL_INTERNAL. */
170      NRF_NFCT_MODULATION_CTRL_INTERNAL      = NFCT_MODULATIONCTRL_MODULATIONCTRL_Internal,            &bsol;**< Use internal modulator only. */
171      NRF_NFCT_MODULATION_CTRL_GPIO          = NFCT_MODULATIONCTRL_MODULATIONCTRL_ModToGpio,           &bsol;**< Transmit output digital modulation signal to a GPIO pin. */
172      NRF_NFCT_MODULATION_CTRL_INTERNAL_GPIO = NFCT_MODULATIONCTRL_MODULATIONCTRL_InternalAndModToGpio &bsol;**< Use internal modulator and transmit output digital modulation signal to a GPIO pin. */
173  } nrf_nfct_modulation_ctrl_t;
174  #endif 
175  NRF_STATIC_INLINE void nrf_nfct_task_trigger(NRF_NFCT_Type * p_reg, nrf_nfct_task_t task);
176  NRF_STATIC_INLINE uint32_t nrf_nfct_task_address_get(NRF_NFCT_Type const * p_reg,
177                                                       nrf_nfct_task_t       task);
178  NRF_STATIC_INLINE void nrf_nfct_event_clear(NRF_NFCT_Type * p_reg, nrf_nfct_event_t event);
179  NRF_STATIC_INLINE bool nrf_nfct_event_check(NRF_NFCT_Type const * p_reg, nrf_nfct_event_t event);
180  NRF_STATIC_INLINE uint32_t nrf_nfct_event_address_get(NRF_NFCT_Type const * p_reg,
181                                                        nrf_nfct_event_t      event);
182  NRF_STATIC_INLINE void nrf_nfct_shorts_enable(NRF_NFCT_Type * p_reg, uint32_t short_mask);
183  NRF_STATIC_INLINE void nrf_nfct_shorts_disable(NRF_NFCT_Type * p_reg, uint32_t short_mask);
184  NRF_STATIC_INLINE uint32_t nrf_nfct_shorts_get(NRF_NFCT_Type const * p_reg);
185  NRF_STATIC_INLINE void nrf_nfct_shorts_set(NRF_NFCT_Type * p_reg, uint32_t short_mask);
186  NRF_STATIC_INLINE void nrf_nfct_int_enable(NRF_NFCT_Type * p_reg, uint32_t mask);
187  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_check(NRF_NFCT_Type const * p_reg, uint32_t mask);
188  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_get(NRF_NFCT_Type const * p_reg);
189  NRF_STATIC_INLINE void nrf_nfct_int_disable(NRF_NFCT_Type * p_reg, uint32_t mask);
190  #if defined(NFCT_MODULATIONPSEL_PIN_Msk) || defined(__NRFX_DOXYGEN__)
191  NRF_STATIC_INLINE void nrf_nfct_mod_ctrl_pin_set(NRF_NFCT_Type * p_reg, uint32_t mod_ctrl_pin);
192  NRF_STATIC_INLINE uint32_t nrf_nfct_mod_ctrl_pin_get(NRF_NFCT_Type const * p_reg);
193  #endif 
194  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk) || defined(__NRFX_DOXYGEN__)
195  NRF_STATIC_INLINE void nrf_nfct_modulation_output_set(NRF_NFCT_Type *            p_reg,
196                                                        nrf_nfct_modulation_ctrl_t mod_ctrl);
197  NRF_STATIC_INLINE
198  nrf_nfct_modulation_ctrl_t nrf_nfct_modulation_output_get(NRF_NFCT_Type const * p_reg);
199  #endif 
200  NRF_STATIC_INLINE uint32_t nrf_nfct_error_status_get(NRF_NFCT_Type const * p_reg);
201  NRF_STATIC_INLINE void nrf_nfct_error_status_clear(NRF_NFCT_Type * p_reg, uint32_t error_flag);
202  NRF_STATIC_INLINE uint32_t nrf_nfct_rx_frame_status_get(NRF_NFCT_Type const * p_reg);
203  NRF_STATIC_INLINE void nrf_nfct_rx_frame_status_clear(NRF_NFCT_Type * p_reg,
204                                                        uint32_t        framestatus_flags);
205  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
206  NRF_STATIC_INLINE nrf_nfct_tag_state_t nrf_nfct_tag_state_get(NRF_NFCT_Type const * p_reg);
207  #endif 
208  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
<span onclick='openModal()' class='match'>209  NRF_STATIC_INLINE nrf_nfct_sleep_state_t nrf_nfct_sleep_state_get(NRF_NFCT_Type const * p_reg);
210  #endif 
211  NRF_STATIC_INLINE uint8_t nrf_nfct_field_status_get(NRF_NFCT_Type const * p_reg);
212  NRF_STATIC_INLINE uint16_t nrf_nfct_frame_delay_min_get(NRF_NFCT_Type const * p_reg);
</span>213  NRF_STATIC_INLINE void nrf_nfct_frame_delay_min_set(NRF_NFCT_Type * p_reg,
214                                                      uint16_t        frame_delay_min);
215  NRF_STATIC_INLINE uint32_t nrf_nfct_frame_delay_max_get(NRF_NFCT_Type const * p_reg);
216  NRF_STATIC_INLINE void nrf_nfct_frame_delay_max_set(NRF_NFCT_Type * p_reg,
217                                                      uint32_t        frame_delay_max);
218  NRF_STATIC_INLINE
219  nrf_nfct_frame_delay_mode_t nrf_nfct_frame_delay_mode_get(NRF_NFCT_Type const * p_reg);
220  NRF_STATIC_INLINE void nrf_nfct_frame_delay_mode_set(NRF_NFCT_Type *             p_reg,
221                                                       nrf_nfct_frame_delay_mode_t frame_delay_mode);
222  NRF_STATIC_INLINE uint8_t * nrf_nfct_rxtx_buffer_get(NRF_NFCT_Type const * p_reg);
223  NRF_STATIC_INLINE void nrf_nfct_rxtx_buffer_set(NRF_NFCT_Type * p_reg,
224                                                  uint8_t *       p_rxtx_buf,
225                                                  uint16_t        max_txrx_len);
226  NRF_STATIC_INLINE uint16_t nrf_nfct_max_rxtx_length_get(NRF_NFCT_Type const * p_reg);
227  NRF_STATIC_INLINE uint8_t nrf_nfct_tx_frame_config_get(NRF_NFCT_Type const * p_reg);
228  NRF_STATIC_INLINE void nrf_nfct_tx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags);
229  NRF_STATIC_INLINE uint16_t nrf_nfct_tx_bits_get(NRF_NFCT_Type const * p_reg);
230  NRF_STATIC_INLINE void nrf_nfct_tx_bits_set(NRF_NFCT_Type * p_reg, uint16_t tx_bits);
231  NRF_STATIC_INLINE uint8_t nrf_nfct_rx_frame_config_get(NRF_NFCT_Type const * p_reg);
232  NRF_STATIC_INLINE void nrf_nfct_rx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags);
233  NRF_STATIC_INLINE uint16_t nrf_nfct_rx_bits_get(NRF_NFCT_Type const * p_reg, bool crc_excluded);
234  NRF_STATIC_INLINE
235  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_nfcid1_get(NRF_NFCT_Type const * p_reg,
236                                                     uint8_t *             p_nfcid1_buf);
237  NRF_STATIC_INLINE void nrf_nfct_nfcid1_set(NRF_NFCT_Type *                p_reg,
238                                             uint8_t const *                p_nfcid1_buf,
239                                             nrf_nfct_sensres_nfcid1_size_t nfcid1_size);
240  #if defined (NFCT_AUTOCOLRESCONFIG_MODE_Msk) || defined(__NRFX_DOXYGEN__)
241  NRF_STATIC_INLINE bool nrf_nfct_autocolres_is_enabled(NRF_NFCT_Type const * p_reg);
242  NRF_STATIC_INLINE void nrf_nfct_autocolres_enable(NRF_NFCT_Type * p_reg);
243  NRF_STATIC_INLINE void nrf_nfct_autocolres_disable(NRF_NFCT_Type * p_reg);
244  #endif 
245  NRF_STATIC_INLINE
246  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_sensres_nfcid1_size_get(NRF_NFCT_Type const * p_reg);
247  NRF_STATIC_INLINE
248  void nrf_nfct_sensres_nfcid1_size_set(NRF_NFCT_Type *                p_reg,
249                                        nrf_nfct_sensres_nfcid1_size_t nfcid1_size);
250  NRF_STATIC_INLINE
251  nrf_nfct_sensres_bit_frame_sdd_t nrf_nfct_sensres_bit_frame_sdd_get(NRF_NFCT_Type const * p_reg);
252  NRF_STATIC_INLINE
253  void nrf_nfct_sensres_bit_frame_sdd_set(NRF_NFCT_Type *                  p_reg,
254                                          nrf_nfct_sensres_bit_frame_sdd_t bit_frame_sdd);
255  NRF_STATIC_INLINE nrf_nfct_sensres_platform_config_t
256  nrf_nfct_sensres_platform_config_get(NRF_NFCT_Type const * p_reg);
257  NRF_STATIC_INLINE
258  void nrf_nfct_sensres_platform_config_set(NRF_NFCT_Type *                    p_reg,
259                                            nrf_nfct_sensres_platform_config_t platform_config);
260  NRF_STATIC_INLINE bool nrf_nfct_selres_cascade_check(NRF_NFCT_Type const * p_reg);
261  NRF_STATIC_INLINE
262  nrf_nfct_selres_protocol_t nrf_nfct_selres_protocol_get(NRF_NFCT_Type const * p_reg);
263  NRF_STATIC_INLINE void nrf_nfct_selres_protocol_set(NRF_NFCT_Type *            p_reg,
264                                                      nrf_nfct_selres_protocol_t sel_res_protocol);
265  #ifndef NRF_DECLARE_ONLY
266  NRF_STATIC_INLINE void nrf_nfct_task_trigger(NRF_NFCT_Type * p_reg, nrf_nfct_task_t task)
267  {
268      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 1UL;
269  }
270  NRF_STATIC_INLINE uint32_t nrf_nfct_task_address_get(NRF_NFCT_Type const * p_reg,
271                                                       nrf_nfct_task_t       task)
272  {
273      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
274  }
275  NRF_STATIC_INLINE void nrf_nfct_event_clear(NRF_NFCT_Type * p_reg, nrf_nfct_event_t event)
276  {
277      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0UL;
278      __DSB();
279  }
280  NRF_STATIC_INLINE bool nrf_nfct_event_check(NRF_NFCT_Type const * p_reg, nrf_nfct_event_t event)
281  {
282      return (bool)*(volatile const uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
283  }
284  NRF_STATIC_INLINE uint32_t nrf_nfct_event_address_get(NRF_NFCT_Type const * p_reg,
285                                                        nrf_nfct_event_t      event)
286  {
287      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
288  }
289  NRF_STATIC_INLINE void nrf_nfct_shorts_enable(NRF_NFCT_Type * p_reg, uint32_t short_mask)
290  {
291      p_reg->SHORTS |= short_mask;
292  }
293  NRF_STATIC_INLINE void nrf_nfct_shorts_disable(NRF_NFCT_Type * p_reg, uint32_t short_mask)
294  {
295      p_reg->SHORTS &= ~short_mask;
296  }
297  NRF_STATIC_INLINE uint32_t nrf_nfct_shorts_get(NRF_NFCT_Type const * p_reg)
298  {
299      return p_reg->SHORTS;
300  }
301  NRF_STATIC_INLINE void nrf_nfct_shorts_set(NRF_NFCT_Type * p_reg, uint32_t short_mask)
302  {
303      p_reg->SHORTS = short_mask;
304  }
305  NRF_STATIC_INLINE void nrf_nfct_int_enable(NRF_NFCT_Type * p_reg, uint32_t mask)
306  {
307      p_reg->INTENSET = mask;
308  }
309  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_check(NRF_NFCT_Type const * p_reg, uint32_t mask)
310  {
311      return p_reg->INTENSET & mask;
312  }
313  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_get(NRF_NFCT_Type const * p_reg)
314  {
315      return p_reg->INTENSET;
316  }
317  NRF_STATIC_INLINE void nrf_nfct_int_disable(NRF_NFCT_Type * p_reg, uint32_t mask)
318  {
319      p_reg->INTENCLR = mask;
320  }
321  #if defined(NFCT_MODULATIONPSEL_PIN_Msk)
322  NRF_STATIC_INLINE void nrf_nfct_mod_ctrl_pin_set(NRF_NFCT_Type * p_reg, uint32_t mod_ctrl_pin)
323  {
324      p_reg->MODULATIONPSEL = mod_ctrl_pin;
325  }
326  NRF_STATIC_INLINE uint32_t nrf_nfct_mod_ctrl_pin_get(NRF_NFCT_Type const * p_reg)
327  {
328      return p_reg->MODULATIONPSEL;
329  }
330  #endif 
331  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk)
332  NRF_STATIC_INLINE void nrf_nfct_modulation_output_set(NRF_NFCT_Type *            p_reg,
333                                                        nrf_nfct_modulation_ctrl_t mod_ctrl)
334  {
335      p_reg->MODULATIONCTRL = (uint32_t)mod_ctrl;
336  }
337  NRF_STATIC_INLINE
338  nrf_nfct_modulation_ctrl_t nrf_nfct_modulation_output_get(NRF_NFCT_Type const * p_reg)
339  {
340      return (nrf_nfct_modulation_ctrl_t)(p_reg->MODULATIONCTRL &
341                                          NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk);
342  }
343  #endif 
344  NRF_STATIC_INLINE uint32_t nrf_nfct_error_status_get(NRF_NFCT_Type const * p_reg)
345  {
346      return p_reg->ERRORSTATUS;
347  }
348  NRF_STATIC_INLINE void nrf_nfct_error_status_clear(NRF_NFCT_Type * p_reg, uint32_t error_flags)
349  {
350      p_reg->ERRORSTATUS = error_flags;
351  }
352  NRF_STATIC_INLINE uint32_t nrf_nfct_rx_frame_status_get(NRF_NFCT_Type const * p_reg)
353  {
354      return p_reg->FRAMESTATUS.RX;
355  }
356  NRF_STATIC_INLINE void nrf_nfct_rx_frame_status_clear(NRF_NFCT_Type * p_reg,
357                                                        uint32_t        framestatus_flags)
358  {
359      p_reg->FRAMESTATUS.RX = framestatus_flags;
360  }
361  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
362  NRF_STATIC_INLINE nrf_nfct_tag_state_t nrf_nfct_tag_state_get(NRF_NFCT_Type const * p_reg)
363  {
364      return (nrf_nfct_tag_state_t)((p_reg->NFCTAGSTATE & NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) >>
365                                    NFCT_NFCTAGSTATE_NFCTAGSTATE_Pos);
366  }
367  #endif 
368  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
369  NRF_STATIC_INLINE nrf_nfct_sleep_state_t nrf_nfct_sleep_state_get(NRF_NFCT_Type const * p_reg)
370  {
371      return (nrf_nfct_sleep_state_t)((p_reg->SLEEPSTATE & NFCT_SLEEPSTATE_SLEEPSTATE_Msk) >>
372                                      NFCT_SLEEPSTATE_SLEEPSTATE_Pos);
373  }
374  #endif 
375  NRF_STATIC_INLINE uint8_t nrf_nfct_field_status_get(NRF_NFCT_Type const * p_reg)
376  {
377      return (uint8_t)(p_reg->FIELDPRESENT);
378  }
379  NRF_STATIC_INLINE uint16_t nrf_nfct_frame_delay_min_get(NRF_NFCT_Type const * p_reg)
380  {
381      return (uint16_t)((p_reg->FRAMEDELAYMIN & NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk) >>
382                        NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos);
383  }
384  NRF_STATIC_INLINE void nrf_nfct_frame_delay_min_set(NRF_NFCT_Type * p_reg, uint16_t frame_delay_min)
385  {
386      p_reg->FRAMEDELAYMIN =
387          ((uint32_t)frame_delay_min << NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos) &
388          NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk;
389  }
390  NRF_STATIC_INLINE uint32_t nrf_nfct_frame_delay_max_get(NRF_NFCT_Type const * p_reg)
391  {
392      return (p_reg->FRAMEDELAYMAX & NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk) >>
393             NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos;
394  }
395  NRF_STATIC_INLINE void nrf_nfct_frame_delay_max_set(NRF_NFCT_Type * p_reg, uint32_t frame_delay_max)
396  {
397      p_reg->FRAMEDELAYMAX =
398          ((uint32_t)frame_delay_max << NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos) &
399          NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk;
400  }
401  NRF_STATIC_INLINE
402  nrf_nfct_frame_delay_mode_t nrf_nfct_frame_delay_mode_get(NRF_NFCT_Type const * p_reg)
403  {
404      return (nrf_nfct_frame_delay_mode_t)(p_reg->FRAMEDELAYMODE &
405                                           NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk);
406  }
407  NRF_STATIC_INLINE void nrf_nfct_frame_delay_mode_set(NRF_NFCT_Type *             p_reg,
408                                                       nrf_nfct_frame_delay_mode_t frame_delay_mode)
409  {
410      p_reg->FRAMEDELAYMODE = (uint32_t)frame_delay_mode;
411  }
412  NRF_STATIC_INLINE uint8_t * nrf_nfct_rxtx_buffer_get(NRF_NFCT_Type const * p_reg)
413  {
414      return (uint8_t *)(p_reg->PACKETPTR);
415  }
416  NRF_STATIC_INLINE void nrf_nfct_rxtx_buffer_set(NRF_NFCT_Type * p_reg,
417                                                  uint8_t *       p_rxtx_buf,
418                                                  uint16_t        max_txrx_len)
419  {
420      p_reg->PACKETPTR = (uint32_t)p_rxtx_buf;
421      p_reg->MAXLEN    = ((uint32_t)max_txrx_len << NFCT_MAXLEN_MAXLEN_Pos) & NFCT_MAXLEN_MAXLEN_Msk;
422  }
423  NRF_STATIC_INLINE uint16_t nrf_nfct_max_rxtx_length_get(NRF_NFCT_Type const * p_reg)
424  {
425      return (uint16_t)((p_reg->MAXLEN & NFCT_MAXLEN_MAXLEN_Msk) >> NFCT_MAXLEN_MAXLEN_Pos);
426  }
427  NRF_STATIC_INLINE uint8_t nrf_nfct_tx_frame_config_get(NRF_NFCT_Type const * p_reg)
428  {
429      return (uint8_t)(p_reg->TXD.FRAMECONFIG);
430  }
431  NRF_STATIC_INLINE void nrf_nfct_tx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags)
432  {
433      p_reg->TXD.FRAMECONFIG = flags;
434  }
435  NRF_STATIC_INLINE uint16_t nrf_nfct_tx_bits_get(NRF_NFCT_Type const * p_reg)
436  {
437      return (uint16_t)(p_reg->TXD.AMOUNT & (NFCT_TXD_AMOUNT_TXDATABITS_Msk |
438                                             NFCT_TXD_AMOUNT_TXDATABYTES_Msk));
439  }
440  NRF_STATIC_INLINE void nrf_nfct_tx_bits_set(NRF_NFCT_Type * p_reg, uint16_t tx_bits)
441  {
442      p_reg->TXD.AMOUNT = (tx_bits & (NFCT_TXD_AMOUNT_TXDATABITS_Msk |
443                                      NFCT_TXD_AMOUNT_TXDATABYTES_Msk));
444  }
445  NRF_STATIC_INLINE uint8_t nrf_nfct_rx_frame_config_get(NRF_NFCT_Type const * p_reg)
446  {
447      return (uint8_t)(p_reg->RXD.FRAMECONFIG);
448  }
449  NRF_STATIC_INLINE void nrf_nfct_rx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags)
450  {
451      p_reg->RXD.FRAMECONFIG = flags;
452  }
453  NRF_STATIC_INLINE uint16_t nrf_nfct_rx_bits_get(NRF_NFCT_Type const * p_reg, bool crc_excluded)
454  {
455      uint16_t rx_bits = p_reg->RXD.AMOUNT & (NFCT_RXD_AMOUNT_RXDATABITS_Msk |
456                                              NFCT_RXD_AMOUNT_RXDATABYTES_Msk);
457      return rx_bits - (crc_excluded ? (8u * NRF_NFCT_CRC_SIZE) : 0);
458  }
459  NRF_STATIC_INLINE
460  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_nfcid1_get(NRF_NFCT_Type const * p_reg,
461                                                     uint8_t *             p_nfcid1_buf)
462  {
463      uint32_t nfcid1_last = p_reg->NFCID1_LAST;
464      nrf_nfct_sensres_nfcid1_size_t size =
465          (nrf_nfct_sensres_nfcid1_size_t)(p_reg->SENSRES & NFCT_SENSRES_NFCIDSIZE_Msk);
466      if (size != NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE)
467      {
468          uint32_t nfcid1_2nd_last = p_reg->NFCID1_2ND_LAST;
469          if (size == NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE)
470          {
471              uint32_t nfcid1_3rd_last = p_reg->NFCID1_3RD_LAST;
472              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 16UL);
473              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 8UL);
474              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 0UL);
475          }
476          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 16UL);
477          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 8UL);
478          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 0UL);
479      }
480      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 24UL);
481      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 16UL);
482      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 8UL);
483      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 0UL);
484      return size;
485  }
486  NRF_STATIC_INLINE void nrf_nfct_nfcid1_set(NRF_NFCT_Type *                p_reg,
487                                             uint8_t const *                p_nfcid1_buf,
488                                             nrf_nfct_sensres_nfcid1_size_t nfcid1_size)
489  {
490      nrf_nfct_sensres_nfcid1_size_t size = (nfcid1_size == NRF_NFCT_SENSRES_NFCID1_SIZE_DEFAULT) ?
491          NRF_NFCT_SENSRES_NFCID1_SIZE_DOUBLE : nfcid1_size;
492      if (size != NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE)
493      {
494          if (size == NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE)
495          {
496              p_reg->NFCID1_3RD_LAST = ((uint32_t)p_nfcid1_buf[0] << 16UL) |
497                                          ((uint32_t)p_nfcid1_buf[1] << 8UL)  |
498                                          ((uint32_t)p_nfcid1_buf[2] << 0UL);
499              p_nfcid1_buf += 3UL;
500          }
501          p_reg->NFCID1_2ND_LAST = ((uint32_t)p_nfcid1_buf[0] << 16UL) |
502                                      ((uint32_t)p_nfcid1_buf[1] << 8UL)  |
503                                      ((uint32_t)p_nfcid1_buf[2] << 0UL);
504          p_nfcid1_buf += 3UL;
505      }
506      p_reg->NFCID1_LAST = ((uint32_t)p_nfcid1_buf[0] << 24UL) |
507                              ((uint32_t)p_nfcid1_buf[1] << 16UL) |
508                              ((uint32_t)p_nfcid1_buf[2] << 8UL)  |
509                              ((uint32_t)p_nfcid1_buf[3] << 0UL);
510      p_reg->SENSRES = ((p_reg->SENSRES & ~NFCT_SENSRES_NFCIDSIZE_Msk) |
511                           (uint32_t)size);
512  }
513  #if defined (NFCT_AUTOCOLRESCONFIG_MODE_Msk) || defined(__NRFX_DOXYGEN__)
514  NRF_STATIC_INLINE bool nrf_nfct_autocolres_is_enabled(NRF_NFCT_Type const * p_reg)
515  {
516      return (p_reg->AUTOCOLRESCONFIG & NFCT_AUTOCOLRESCONFIG_MODE_Msk) ==
517             (NFCT_AUTOCOLRESCONFIG_MODE_Enabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
518  }
519  NRF_STATIC_INLINE void nrf_nfct_autocolres_enable(NRF_NFCT_Type * p_reg)
520  {
521      p_reg->AUTOCOLRESCONFIG =
522          (p_reg->AUTOCOLRESCONFIG & ~NFCT_AUTOCOLRESCONFIG_MODE_Msk) |
523          (NFCT_AUTOCOLRESCONFIG_MODE_Enabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
524  }
525  NRF_STATIC_INLINE void nrf_nfct_autocolres_disable(NRF_NFCT_Type * p_reg)
526  {
527      p_reg->AUTOCOLRESCONFIG =
528          (p_reg->AUTOCOLRESCONFIG & ~NFCT_AUTOCOLRESCONFIG_MODE_Msk) |
529          (NFCT_AUTOCOLRESCONFIG_MODE_Disabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
530  }
531  #endif 
532  NRF_STATIC_INLINE
533  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_sensres_nfcid1_size_get(NRF_NFCT_Type const * p_reg)
534  {
535      return (nrf_nfct_sensres_nfcid1_size_t)(p_reg->SENSRES & NFCT_SENSRES_NFCIDSIZE_Msk);
536  }
537  NRF_STATIC_INLINE void nrf_nfct_sensres_nfcid1_size_set(NRF_NFCT_Type *                p_reg,
538                                                          nrf_nfct_sensres_nfcid1_size_t nfcid1_size)
539  {
540      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_NFCIDSIZE_Msk)) |
541                           (uint32_t)nfcid1_size);
542  }
543  NRF_STATIC_INLINE
544  nrf_nfct_sensres_bit_frame_sdd_t nrf_nfct_sensres_bit_frame_sdd_get(NRF_NFCT_Type const * p_reg)
545  {
546      return (nrf_nfct_sensres_bit_frame_sdd_t)(p_reg->SENSRES & NFCT_SENSRES_BITFRAMESDD_Msk);
547  }
548  NRF_STATIC_INLINE
549  void nrf_nfct_sensres_bit_frame_sdd_set(NRF_NFCT_Type * p_reg,
550                                          nrf_nfct_sensres_bit_frame_sdd_t bit_frame_sdd)
551  {
552      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_BITFRAMESDD_Msk)) | (uint32_t)bit_frame_sdd);
553  }
554  NRF_STATIC_INLINE
555  nrf_nfct_sensres_platform_config_t nrf_nfct_sensres_platform_config_get(NRF_NFCT_Type const * p_reg)
556  {
557      return (nrf_nfct_sensres_platform_config_t)(p_reg->SENSRES & NFCT_SENSRES_PLATFCONFIG_Msk);
558  }
559  NRF_STATIC_INLINE
560  void nrf_nfct_sensres_platform_config_set(NRF_NFCT_Type * p_reg,
561                                            nrf_nfct_sensres_platform_config_t platform_config)
562  {
563      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_PLATFCONFIG_Msk)) |
564                        (uint32_t)platform_config);
565  }
566  NRF_STATIC_INLINE bool nrf_nfct_selres_cascade_check(NRF_NFCT_Type const * p_reg)
567  {
568      return (bool)(p_reg->SELRES & NFCT_SELRES_CASCADE_Msk);
569  }
570  NRF_STATIC_INLINE
571  nrf_nfct_selres_protocol_t nrf_nfct_selres_protocol_get(NRF_NFCT_Type const * p_reg)
572  {
573      return (nrf_nfct_selres_protocol_t)((p_reg->SELRES & NFCT_SELRES_PROTOCOL_Msk) >>
574                                          NFCT_SELRES_PROTOCOL_Pos);
575  }
576  NRF_STATIC_INLINE void nrf_nfct_selres_protocol_set(NRF_NFCT_Type *            p_reg,
577                                                      nrf_nfct_selres_protocol_t sel_res_protocol)
578  {
579      p_reg->SELRES = (p_reg->SELRES & ~NFCT_SELRES_PROTOCOL_Msk) |
580                      ((uint32_t)sel_res_protocol << NFCT_SELRES_PROTOCOL_Pos);
581  }
582  #endif &bsol;* NRF_DECLARE_ONLY */
583  #ifdef __cplusplus
584  }
585  #endif
586  #endif &bsol;* NRF_NFCT_H__ */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nfct.h</h3>
            <pre><code>1  #ifndef NRF_NFCT_H__
2  #define NRF_NFCT_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_NFCT_CRC_SIZE 2                 &bsol;**< CRC size in bytes. */
8  #define NRF_NFCT_DISABLE_ALL_INT 0xFFFFFFFF &bsol;**< Value to disable all interrupts. */
9  #define NRF_NFCT_MOD_CTRL_PIN_NOT_CONNECTED  0xFFFFFFFF
10  typedef enum
11  {
12      NRF_NFCT_TASK_ACTIVATE     = offsetof(NRF_NFCT_Type, TASKS_ACTIVATE),     &bsol;**< Activate the NFCT peripheral for the incoming and outgoing frames, change state to activated. */
13      NRF_NFCT_TASK_DISABLE      = offsetof(NRF_NFCT_Type, TASKS_DISABLE),      &bsol;**< Disable the NFCT peripheral. */
14      NRF_NFCT_TASK_SENSE        = offsetof(NRF_NFCT_Type, TASKS_SENSE),        &bsol;**< Enable the NFC sense field mode, change state to sense mode. */
15      NRF_NFCT_TASK_STARTTX      = offsetof(NRF_NFCT_Type, TASKS_STARTTX),      &bsol;**< Start the transmission of an outgoing frame, change state to transmit. */
16      NRF_NFCT_TASK_ENABLERXDATA = offsetof(NRF_NFCT_Type, TASKS_ENABLERXDATA), &bsol;**< Initialize EasyDMA for receive. */
17      NRF_NFCT_TASK_GOIDLE       = offsetof(NRF_NFCT_Type, TASKS_GOIDLE),       &bsol;**< Force state machine to the IDLE state. */
18      NRF_NFCT_TASK_GOSLEEP      = offsetof(NRF_NFCT_Type, TASKS_GOSLEEP),      &bsol;**< Force state machine to the SLEEP_A state. */
19  } nrf_nfct_task_t;
20  typedef enum
21  {
22      NRF_NFCT_EVENT_READY             = offsetof(NRF_NFCT_Type, EVENTS_READY),             &bsol;**< The NFCT peripheral is ready to receive and send frames. */
23      NRF_NFCT_EVENT_FIELDDETECTED     = offsetof(NRF_NFCT_Type, EVENTS_FIELDDETECTED),     &bsol;**< Remote NFC field is detected. */
24      NRF_NFCT_EVENT_FIELDLOST         = offsetof(NRF_NFCT_Type, EVENTS_FIELDLOST),         &bsol;**< Remote NFC field is lost. */
25      NRF_NFCT_EVENT_TXFRAMESTART      = offsetof(NRF_NFCT_Type, EVENTS_TXFRAMESTART),      &bsol;**< The start of the first symbol of a transmitted frame. */
26      NRF_NFCT_EVENT_TXFRAMEEND        = offsetof(NRF_NFCT_Type, EVENTS_TXFRAMEEND),        &bsol;**< The end of the last transmitted on-air symbol of a frame. */
27      NRF_NFCT_EVENT_RXFRAMESTART      = offsetof(NRF_NFCT_Type, EVENTS_RXFRAMESTART),      &bsol;**< The end of the first symbol of a received frame. */
28      NRF_NFCT_EVENT_RXFRAMEEND        = offsetof(NRF_NFCT_Type, EVENTS_RXFRAMEEND),        &bsol;**< Received data was checked (CRC, parity) and transferred to RAM, and EasyDMA ended accessing the RX buffer. */
29      NRF_NFCT_EVENT_ERROR             = offsetof(NRF_NFCT_Type, EVENTS_ERROR),             &bsol;**< NFC error reported. The ERRORSTATUS register contains details on the source of the error. */
30      NRF_NFCT_EVENT_RXERROR           = offsetof(NRF_NFCT_Type, EVENTS_RXERROR),           &bsol;**< NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error. */
31      NRF_NFCT_EVENT_ENDRX             = offsetof(NRF_NFCT_Type, EVENTS_ENDRX),             &bsol;**< RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full. */
32      NRF_NFCT_EVENT_ENDTX             = offsetof(NRF_NFCT_Type, EVENTS_ENDTX),             &bsol;**< Transmission of data in RAM ended, and EasyDMA ended accessing the TX buffer. */
33      NRF_NFCT_EVENT_AUTOCOLRESSTARTED = offsetof(NRF_NFCT_Type, EVENTS_AUTOCOLRESSTARTED), &bsol;**< Auto collision resolution process started. */
34      NRF_NFCT_EVENT_COLLISION         = offsetof(NRF_NFCT_Type, EVENTS_COLLISION),         &bsol;**< NFC auto collision resolution error reported. */
35      NRF_NFCT_EVENT_SELECTED          = offsetof(NRF_NFCT_Type, EVENTS_SELECTED),          &bsol;**< NFC auto collision resolution successfully completed. */
36      NRF_NFCT_EVENT_STARTED           = offsetof(NRF_NFCT_Type, EVENTS_STARTED),           &bsol;**< EasyDMA is ready to receive or send frames. */
37  } nrf_nfct_event_t;
38  typedef enum
39  {
40      NRF_NFCT_SHORT_FIELDDETECTED_ACTIVATE_MASK  = NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk,  &bsol;**< Shortcut between the FIELDDETECTED event and the ACTIVATE task. */
41      NRF_NFCT_SHORT_FIELDLOST_SENSE_MASK         = NFCT_SHORTS_FIELDLOST_SENSE_Msk,         &bsol;**< Shortcut between the FIELDLOST event and the SENSE task. */
42  #if defined(NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk) || defined(__NRFX_DOXYGEN__)
43      NRF_NFCT_SHORT_TXFRAMEEND_ENABLERXDATA_MASK = NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk, &bsol;**< Shortcut between the TXFRAMEEND event and the ENABLERXDATA task. */
44  #endif 
45  } nrf_nfct_short_mask_t;
46  typedef enum
47  {
48      NRF_NFCT_INT_READY_MASK             = NFCT_INTEN_READY_Msk,             &bsol;**< Interrupt on READY event. */
49      NRF_NFCT_INT_FIELDDETECTED_MASK     = NFCT_INTEN_FIELDDETECTED_Msk,     &bsol;**< Interrupt on FIELDDETECTED event. */
50      NRF_NFCT_INT_FIELDLOST_MASK         = NFCT_INTEN_FIELDLOST_Msk,         &bsol;**< Interrupt on FIELDLOST event. */
51      NRF_NFCT_INT_TXFRAMESTART_MASK      = NFCT_INTEN_TXFRAMESTART_Msk,      &bsol;**< Interrupt on TXFRAMESTART event. */
52      NRF_NFCT_INT_TXFRAMEEND_MASK        = NFCT_INTEN_TXFRAMEEND_Msk,        &bsol;**< Interrupt on TXFRAMEEND event. */
53      NRF_NFCT_INT_RXFRAMESTART_MASK      = NFCT_INTEN_RXFRAMESTART_Msk,      &bsol;**< Interrupt on RXFRAMESTART event. */
54      NRF_NFCT_INT_RXFRAMEEND_MASK        = NFCT_INTEN_RXFRAMEEND_Msk,        &bsol;**< Interrupt on RXFRAMEEND event. */
55      NRF_NFCT_INT_ERROR_MASK             = NFCT_INTEN_ERROR_Msk,             &bsol;**< Interrupt on ERROR event. */
56      NRF_NFCT_INT_RXERROR_MASK           = NFCT_INTEN_RXERROR_Msk,           &bsol;**< Interrupt on RXERROR event. */
57      NRF_NFCT_INT_ENDRX_MASK             = NFCT_INTEN_ENDRX_Msk,             &bsol;**< Interrupt on ENDRX event. */
58      NRF_NFCT_INT_ENDTX_MASK             = NFCT_INTEN_ENDTX_Msk,             &bsol;**< Interrupt on ENDTX event. */
59      NRF_NFCT_INT_AUTOCOLRESSTARTED_MASK = NFCT_INTEN_AUTOCOLRESSTARTED_Msk, &bsol;**< Interrupt on AUTOCOLRESSTARTED event. */
60      NRF_NFCT_INT_COLLISION_MASK         = NFCT_INTEN_COLLISION_Msk,         &bsol;**< Interrupt on COLLISION event. */
61      NRF_NFCT_INT_SELECTED_MASK          = NFCT_INTEN_SELECTED_Msk,          &bsol;**< Interrupt on SELECTED event. */
62      NRF_NFCT_INT_STARTED_MASK           = NFCT_INTEN_STARTED_Msk,           &bsol;**< Interrupt on STARTED event. */
63  } nrf_nfct_int_mask_t;
64  typedef enum
65  {
66      NRF_NFCT_ERROR_FRAMEDELAYTIMEOUT_MASK = NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk, &bsol;**< Timeout of the Frame Delay Timer (no frame transmission started in the FDT window). */
67  #if defined(NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk) || defined(__NRFX_DOXYGEN__)
68      NRF_NFCT_ERROR_NFCFIELDTOOSTRONG_MASK = NFCT_ERRORSTATUS_NFCFIELDTOOSTRONG_Msk, &bsol;**< Field level is too high at maximum load resistance. */
69  #endif 
70  #if defined(NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk) || defined(__NRFX_DOXYGEN__)
71      NRF_NFCT_ERROR_NFCFIELDTOOWEAK_MASK = NFCT_ERRORSTATUS_NFCFIELDTOOWEAK_Msk,     &bsol;**< Field level is too low at minimum load resistance. */
72  #endif 
73  } nrf_nfct_error_status_t;
74  typedef enum
75  {
76      NRF_NFCT_RX_FRAME_STATUS_CRC_MASK     = NFCT_FRAMESTATUS_RX_CRCERROR_Msk,     &bsol;**< CRC status mask. */
77      NRF_NFCT_RX_FRAME_STATUS_PARITY_MASK  = NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk, &bsol;**< Parity status mask. */
78      NRF_NFCT_RX_FRAME_STATUS_OVERRUN_MASK = NFCT_FRAMESTATUS_RX_OVERRUN_Msk,      &bsol;**< Overrun status mask. */
79  } nrf_nfct_rx_frame_status_t;
80  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
81  typedef enum
82  {
83      NRF_NFCT_TAG_STATE_DISABLED    = NFCT_NFCTAGSTATE_NFCTAGSTATE_Disabled,   &bsol;**< Disabled or sensing NFC field. */
84      NRF_NFCT_TAG_STATE_RAMP_UP     = NFCT_NFCTAGSTATE_NFCTAGSTATE_RampUp,     &bsol;**< Ramping up. */
85      NRF_NFCT_TAG_STATE_IDLE        = NFCT_NFCTAGSTATE_NFCTAGSTATE_Idle,       &bsol;**< Idle. */
86      NRF_NFCT_TAG_STATE_RECEIVE     = NFCT_NFCTAGSTATE_NFCTAGSTATE_Receive,    &bsol;**< Receiving data. */
87      NRF_NFCT_TAG_STATE_FRAME_DELAY = NFCT_NFCTAGSTATE_NFCTAGSTATE_FrameDelay, &bsol;**< Counting Frame Delay Time since the last symbol of the last received frame. */
88      NRF_NFCT_TAG_STATE_TRANSMIT    = NFCT_NFCTAGSTATE_NFCTAGSTATE_Transmit    &bsol;**< Transmitting data. */
89  } nrf_nfct_tag_state_t;
90  #endif 
91  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
92  typedef enum
93  {
94      NRF_NFCT_SLEEP_STATE_IDLE    = NFCT_SLEEPSTATE_SLEEPSTATE_Idle,  &bsol;**< 'IDLE' state. */
95      NRF_NFCT_SLEEP_STATE_SLEEP_A = NFCT_SLEEPSTATE_SLEEPSTATE_SleepA &bsol;**< 'SLEEP_A' state. */
96  } nrf_nfct_sleep_state_t;
97  #endif 
98  typedef enum
99  {
100      NRF_NFCT_FIELD_STATE_PRESENT_MASK = NFCT_FIELDPRESENT_FIELDPRESENT_Msk, &bsol;**< Field presence mask. */
101      NRF_NFCT_FIELD_STATE_LOCK_MASK    = NFCT_FIELDPRESENT_LOCKDETECT_Msk    &bsol;**< Field lock mask. */
102  } nrf_nfct_field_state_t;
103  typedef enum
104  {
105      NRF_NFCT_FRAME_DELAY_MODE_FREERUN    = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun,   &bsol;**< Frame transmission starts when @ref NRF_NFCT_TASK_STARTTX is set (delay timer is not used). */
106      NRF_NFCT_FRAME_DELAY_MODE_WINDOW     = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window,    &bsol;**< Frame transmission starts in a window between FRAMEDELAYMIN and FRAMEDELAYMAX. */
107      NRF_NFCT_FRAME_DELAY_MODE_EXACTVAL   = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal,  &bsol;**< Frame transmission starts when the delay timer reaches FRAMEDELAYMAX. */
108      NRF_NFCT_FRAME_DELAY_MODE_WINDOWGRID = NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid &bsol;**< Frame transmission starts in a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX. */
109  } nrf_nfct_frame_delay_mode_t;
110  typedef enum
111  {
112      NRF_NFCT_TX_FRAME_CONFIG_PARITY        = NFCT_TXD_FRAMECONFIG_PARITY_Msk,      &bsol;**< Indicates whether parity is added in the transmitted frames. */
113      NRF_NFCT_TX_FRAME_CONFIG_DISCARD_START = NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk, &bsol;**< Indicates whether unused bits are discarded at the start or at the end of the transmitted frames. */
114      NRF_NFCT_TX_FRAME_CONFIG_SOF           = NFCT_TXD_FRAMECONFIG_SOF_Msk,         &bsol;**< Indicates whether SoF symbol is added in the transmitted frames. */
115      NRF_NFCT_TX_FRAME_CONFIG_CRC16         = NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk    &bsol;**< Indicates whether CRC is added in the transmitted frames. */
116  } nrf_nfct_tx_frame_config_t;
117  typedef enum
118  {
119      NRF_NFCT_RX_FRAME_CONFIG_PARITY = NFCT_RXD_FRAMECONFIG_PARITY_Msk,   &bsol;**< Indicates whether parity is expected in the received frames. */
120      NRF_NFCT_RX_FRAME_CONFIG_SOF    = NFCT_RXD_FRAMECONFIG_SOF_Msk,      &bsol;**< Indicates whether SoF symbol is expected in the received frames. */
121      NRF_NFCT_RX_FRAME_CONFIG_CRC16  = NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk &bsol;**< Indicates whether CRC is expected and checked in the received frames. */
122  } nrf_nfct_rx_frame_config_t;
123  typedef enum
124  {
125      NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE =
126          NFCT_SENSRES_NFCIDSIZE_NFCID1Single << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Single size NFCID1 (4 bytes). */
127      NRF_NFCT_SENSRES_NFCID1_SIZE_DOUBLE =
128          NFCT_SENSRES_NFCIDSIZE_NFCID1Double << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Double size NFCID1 (7 bytes). */
129      NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE =
130          NFCT_SENSRES_NFCIDSIZE_NFCID1Triple << NFCT_SENSRES_NFCIDSIZE_Pos, &bsol;**< Triple size NFCID1 (10 bytes). */
131      NRF_NFCT_SENSRES_NFCID1_SIZE_DEFAULT =
132          NFCT_SENSRES_NFCIDSIZE_Msk                                         &bsol;**< Default size. Use this option to leave NFCID1 size unchanged. */
133  } nrf_nfct_sensres_nfcid1_size_t;
134  typedef enum
135  {
136      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00000 =
137          NFCT_SENSRES_BITFRAMESDD_SDD00000 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00000. */
138      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00001 =
139          NFCT_SENSRES_BITFRAMESDD_SDD00001 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00001. */
140      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00010 =
141          NFCT_SENSRES_BITFRAMESDD_SDD00010 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00010. */
142      NRF_NFCT_SENSRES_BIT_FRAME_SDD_00100 =
143          NFCT_SENSRES_BITFRAMESDD_SDD00100 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 00100. */
144      NRF_NFCT_SENSRES_BIT_FRAME_SDD_01000 =
145          NFCT_SENSRES_BITFRAMESDD_SDD01000 << NFCT_SENSRES_BITFRAMESDD_Pos, &bsol;**< SDD pattern 01000. */
146      NRF_NFCT_SENSRES_BIT_FRAME_SDD_10000 =
147          NFCT_SENSRES_BITFRAMESDD_SDD10000 << NFCT_SENSRES_BITFRAMESDD_Pos  &bsol;**< SDD pattern 10000. */
148  } nrf_nfct_sensres_bit_frame_sdd_t;
149  typedef enum
150  {
151      NRF_NFCT_SENSRES_PLATFORM_CONFIG_T1T   = 6 << NFCT_SENSRES_PLATFCONFIG_Pos,
152      NRF_NFCT_SENSRES_PLATFORM_CONFIG_OTHER = 0 << NFCT_SENSRES_PLATFCONFIG_Pos
153  } nrf_nfct_sensres_platform_config_t;
154  typedef enum
155  {
156      NRF_NFCT_SELRES_CASCADE_MASK  = NFCT_SELRES_CASCADE_Msk,  &bsol;**< SEL_RES Cascade field bit mask. */
157      NRF_NFCT_SELRES_PROTOCOL_MASK = NFCT_SELRES_PROTOCOL_Msk  &bsol;**< SEL_RES Protocol field bit mask. */
158  } nrf_nfct_selres_t;
159  typedef enum
160  {
161      NRF_NFCT_SELRES_PROTOCOL_T2T         = 0,  &bsol;**< Type 2 Tag platform. */
162      NRF_NFCT_SELRES_PROTOCOL_T4AT        = 1,  &bsol;**< Type 4A Tag platform. */
163      NRF_NFCT_SELRES_PROTOCOL_NFCDEP      = 2,  &bsol;**< NFC-DEP Protocol. */
164      NRF_NFCT_SELRES_PROTOCOL_NFCDEP_T4AT = 3,  &bsol;**< NFC-DEP Protocol and Type 4A Tag platform). */
165  } nrf_nfct_selres_protocol_t;
166  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk) || defined(__NRFX_DOXYGEN__)
167  typedef enum
168  {
169      NRF_NFCT_MODULATION_CTRL_INVALID       = NFCT_MODULATIONCTRL_MODULATIONCTRL_Invalid,             &bsol;**< Invalid configuration. Defaults to the same behavior as NRF_NFCT_MODULATION_CTRL_INTERNAL. */
170      NRF_NFCT_MODULATION_CTRL_INTERNAL      = NFCT_MODULATIONCTRL_MODULATIONCTRL_Internal,            &bsol;**< Use internal modulator only. */
171      NRF_NFCT_MODULATION_CTRL_GPIO          = NFCT_MODULATIONCTRL_MODULATIONCTRL_ModToGpio,           &bsol;**< Transmit output digital modulation signal to a GPIO pin. */
172      NRF_NFCT_MODULATION_CTRL_INTERNAL_GPIO = NFCT_MODULATIONCTRL_MODULATIONCTRL_InternalAndModToGpio &bsol;**< Use internal modulator and transmit output digital modulation signal to a GPIO pin. */
173  } nrf_nfct_modulation_ctrl_t;
174  #endif 
175  NRF_STATIC_INLINE void nrf_nfct_task_trigger(NRF_NFCT_Type * p_reg, nrf_nfct_task_t task);
176  NRF_STATIC_INLINE uint32_t nrf_nfct_task_address_get(NRF_NFCT_Type const * p_reg,
177                                                       nrf_nfct_task_t       task);
178  NRF_STATIC_INLINE void nrf_nfct_event_clear(NRF_NFCT_Type * p_reg, nrf_nfct_event_t event);
179  NRF_STATIC_INLINE bool nrf_nfct_event_check(NRF_NFCT_Type const * p_reg, nrf_nfct_event_t event);
180  NRF_STATIC_INLINE uint32_t nrf_nfct_event_address_get(NRF_NFCT_Type const * p_reg,
181                                                        nrf_nfct_event_t      event);
182  NRF_STATIC_INLINE void nrf_nfct_shorts_enable(NRF_NFCT_Type * p_reg, uint32_t short_mask);
183  NRF_STATIC_INLINE void nrf_nfct_shorts_disable(NRF_NFCT_Type * p_reg, uint32_t short_mask);
184  NRF_STATIC_INLINE uint32_t nrf_nfct_shorts_get(NRF_NFCT_Type const * p_reg);
185  NRF_STATIC_INLINE void nrf_nfct_shorts_set(NRF_NFCT_Type * p_reg, uint32_t short_mask);
186  NRF_STATIC_INLINE void nrf_nfct_int_enable(NRF_NFCT_Type * p_reg, uint32_t mask);
187  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_check(NRF_NFCT_Type const * p_reg, uint32_t mask);
188  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_get(NRF_NFCT_Type const * p_reg);
189  NRF_STATIC_INLINE void nrf_nfct_int_disable(NRF_NFCT_Type * p_reg, uint32_t mask);
190  #if defined(NFCT_MODULATIONPSEL_PIN_Msk) || defined(__NRFX_DOXYGEN__)
191  NRF_STATIC_INLINE void nrf_nfct_mod_ctrl_pin_set(NRF_NFCT_Type * p_reg, uint32_t mod_ctrl_pin);
192  NRF_STATIC_INLINE uint32_t nrf_nfct_mod_ctrl_pin_get(NRF_NFCT_Type const * p_reg);
193  #endif 
194  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk) || defined(__NRFX_DOXYGEN__)
195  NRF_STATIC_INLINE void nrf_nfct_modulation_output_set(NRF_NFCT_Type *            p_reg,
196                                                        nrf_nfct_modulation_ctrl_t mod_ctrl);
<span onclick='openModal()' class='match'>197  NRF_STATIC_INLINE
198  nrf_nfct_modulation_ctrl_t nrf_nfct_modulation_output_get(NRF_NFCT_Type const * p_reg);
199  #endif 
200  NRF_STATIC_INLINE uint32_t nrf_nfct_error_status_get(NRF_NFCT_Type const * p_reg);
201  NRF_STATIC_INLINE void nrf_nfct_error_status_clear(NRF_NFCT_Type * p_reg, uint32_t error_flag);
</span>202  NRF_STATIC_INLINE uint32_t nrf_nfct_rx_frame_status_get(NRF_NFCT_Type const * p_reg);
203  NRF_STATIC_INLINE void nrf_nfct_rx_frame_status_clear(NRF_NFCT_Type * p_reg,
204                                                        uint32_t        framestatus_flags);
205  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
206  NRF_STATIC_INLINE nrf_nfct_tag_state_t nrf_nfct_tag_state_get(NRF_NFCT_Type const * p_reg);
207  #endif 
208  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
209  NRF_STATIC_INLINE nrf_nfct_sleep_state_t nrf_nfct_sleep_state_get(NRF_NFCT_Type const * p_reg);
210  #endif 
211  NRF_STATIC_INLINE uint8_t nrf_nfct_field_status_get(NRF_NFCT_Type const * p_reg);
212  NRF_STATIC_INLINE uint16_t nrf_nfct_frame_delay_min_get(NRF_NFCT_Type const * p_reg);
213  NRF_STATIC_INLINE void nrf_nfct_frame_delay_min_set(NRF_NFCT_Type * p_reg,
214                                                      uint16_t        frame_delay_min);
215  NRF_STATIC_INLINE uint32_t nrf_nfct_frame_delay_max_get(NRF_NFCT_Type const * p_reg);
216  NRF_STATIC_INLINE void nrf_nfct_frame_delay_max_set(NRF_NFCT_Type * p_reg,
217                                                      uint32_t        frame_delay_max);
218  NRF_STATIC_INLINE
219  nrf_nfct_frame_delay_mode_t nrf_nfct_frame_delay_mode_get(NRF_NFCT_Type const * p_reg);
220  NRF_STATIC_INLINE void nrf_nfct_frame_delay_mode_set(NRF_NFCT_Type *             p_reg,
221                                                       nrf_nfct_frame_delay_mode_t frame_delay_mode);
222  NRF_STATIC_INLINE uint8_t * nrf_nfct_rxtx_buffer_get(NRF_NFCT_Type const * p_reg);
223  NRF_STATIC_INLINE void nrf_nfct_rxtx_buffer_set(NRF_NFCT_Type * p_reg,
224                                                  uint8_t *       p_rxtx_buf,
225                                                  uint16_t        max_txrx_len);
226  NRF_STATIC_INLINE uint16_t nrf_nfct_max_rxtx_length_get(NRF_NFCT_Type const * p_reg);
227  NRF_STATIC_INLINE uint8_t nrf_nfct_tx_frame_config_get(NRF_NFCT_Type const * p_reg);
228  NRF_STATIC_INLINE void nrf_nfct_tx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags);
229  NRF_STATIC_INLINE uint16_t nrf_nfct_tx_bits_get(NRF_NFCT_Type const * p_reg);
230  NRF_STATIC_INLINE void nrf_nfct_tx_bits_set(NRF_NFCT_Type * p_reg, uint16_t tx_bits);
231  NRF_STATIC_INLINE uint8_t nrf_nfct_rx_frame_config_get(NRF_NFCT_Type const * p_reg);
232  NRF_STATIC_INLINE void nrf_nfct_rx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags);
233  NRF_STATIC_INLINE uint16_t nrf_nfct_rx_bits_get(NRF_NFCT_Type const * p_reg, bool crc_excluded);
234  NRF_STATIC_INLINE
235  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_nfcid1_get(NRF_NFCT_Type const * p_reg,
236                                                     uint8_t *             p_nfcid1_buf);
237  NRF_STATIC_INLINE void nrf_nfct_nfcid1_set(NRF_NFCT_Type *                p_reg,
238                                             uint8_t const *                p_nfcid1_buf,
239                                             nrf_nfct_sensres_nfcid1_size_t nfcid1_size);
240  #if defined (NFCT_AUTOCOLRESCONFIG_MODE_Msk) || defined(__NRFX_DOXYGEN__)
241  NRF_STATIC_INLINE bool nrf_nfct_autocolres_is_enabled(NRF_NFCT_Type const * p_reg);
242  NRF_STATIC_INLINE void nrf_nfct_autocolres_enable(NRF_NFCT_Type * p_reg);
243  NRF_STATIC_INLINE void nrf_nfct_autocolres_disable(NRF_NFCT_Type * p_reg);
244  #endif 
245  NRF_STATIC_INLINE
246  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_sensres_nfcid1_size_get(NRF_NFCT_Type const * p_reg);
247  NRF_STATIC_INLINE
248  void nrf_nfct_sensres_nfcid1_size_set(NRF_NFCT_Type *                p_reg,
249                                        nrf_nfct_sensres_nfcid1_size_t nfcid1_size);
250  NRF_STATIC_INLINE
251  nrf_nfct_sensres_bit_frame_sdd_t nrf_nfct_sensres_bit_frame_sdd_get(NRF_NFCT_Type const * p_reg);
252  NRF_STATIC_INLINE
253  void nrf_nfct_sensres_bit_frame_sdd_set(NRF_NFCT_Type *                  p_reg,
254                                          nrf_nfct_sensres_bit_frame_sdd_t bit_frame_sdd);
255  NRF_STATIC_INLINE nrf_nfct_sensres_platform_config_t
256  nrf_nfct_sensres_platform_config_get(NRF_NFCT_Type const * p_reg);
257  NRF_STATIC_INLINE
258  void nrf_nfct_sensres_platform_config_set(NRF_NFCT_Type *                    p_reg,
259                                            nrf_nfct_sensres_platform_config_t platform_config);
260  NRF_STATIC_INLINE bool nrf_nfct_selres_cascade_check(NRF_NFCT_Type const * p_reg);
261  NRF_STATIC_INLINE
262  nrf_nfct_selres_protocol_t nrf_nfct_selres_protocol_get(NRF_NFCT_Type const * p_reg);
263  NRF_STATIC_INLINE void nrf_nfct_selres_protocol_set(NRF_NFCT_Type *            p_reg,
264                                                      nrf_nfct_selres_protocol_t sel_res_protocol);
265  #ifndef NRF_DECLARE_ONLY
266  NRF_STATIC_INLINE void nrf_nfct_task_trigger(NRF_NFCT_Type * p_reg, nrf_nfct_task_t task)
267  {
268      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 1UL;
269  }
270  NRF_STATIC_INLINE uint32_t nrf_nfct_task_address_get(NRF_NFCT_Type const * p_reg,
271                                                       nrf_nfct_task_t       task)
272  {
273      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
274  }
275  NRF_STATIC_INLINE void nrf_nfct_event_clear(NRF_NFCT_Type * p_reg, nrf_nfct_event_t event)
276  {
277      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0UL;
278      __DSB();
279  }
280  NRF_STATIC_INLINE bool nrf_nfct_event_check(NRF_NFCT_Type const * p_reg, nrf_nfct_event_t event)
281  {
282      return (bool)*(volatile const uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
283  }
284  NRF_STATIC_INLINE uint32_t nrf_nfct_event_address_get(NRF_NFCT_Type const * p_reg,
285                                                        nrf_nfct_event_t      event)
286  {
287      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
288  }
289  NRF_STATIC_INLINE void nrf_nfct_shorts_enable(NRF_NFCT_Type * p_reg, uint32_t short_mask)
290  {
291      p_reg->SHORTS |= short_mask;
292  }
293  NRF_STATIC_INLINE void nrf_nfct_shorts_disable(NRF_NFCT_Type * p_reg, uint32_t short_mask)
294  {
295      p_reg->SHORTS &= ~short_mask;
296  }
297  NRF_STATIC_INLINE uint32_t nrf_nfct_shorts_get(NRF_NFCT_Type const * p_reg)
298  {
299      return p_reg->SHORTS;
300  }
301  NRF_STATIC_INLINE void nrf_nfct_shorts_set(NRF_NFCT_Type * p_reg, uint32_t short_mask)
302  {
303      p_reg->SHORTS = short_mask;
304  }
305  NRF_STATIC_INLINE void nrf_nfct_int_enable(NRF_NFCT_Type * p_reg, uint32_t mask)
306  {
307      p_reg->INTENSET = mask;
308  }
309  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_check(NRF_NFCT_Type const * p_reg, uint32_t mask)
310  {
311      return p_reg->INTENSET & mask;
312  }
313  NRF_STATIC_INLINE uint32_t nrf_nfct_int_enable_get(NRF_NFCT_Type const * p_reg)
314  {
315      return p_reg->INTENSET;
316  }
317  NRF_STATIC_INLINE void nrf_nfct_int_disable(NRF_NFCT_Type * p_reg, uint32_t mask)
318  {
319      p_reg->INTENCLR = mask;
320  }
321  #if defined(NFCT_MODULATIONPSEL_PIN_Msk)
322  NRF_STATIC_INLINE void nrf_nfct_mod_ctrl_pin_set(NRF_NFCT_Type * p_reg, uint32_t mod_ctrl_pin)
323  {
324      p_reg->MODULATIONPSEL = mod_ctrl_pin;
325  }
326  NRF_STATIC_INLINE uint32_t nrf_nfct_mod_ctrl_pin_get(NRF_NFCT_Type const * p_reg)
327  {
328      return p_reg->MODULATIONPSEL;
329  }
330  #endif 
331  #if defined(NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk)
332  NRF_STATIC_INLINE void nrf_nfct_modulation_output_set(NRF_NFCT_Type *            p_reg,
333                                                        nrf_nfct_modulation_ctrl_t mod_ctrl)
334  {
335      p_reg->MODULATIONCTRL = (uint32_t)mod_ctrl;
336  }
337  NRF_STATIC_INLINE
338  nrf_nfct_modulation_ctrl_t nrf_nfct_modulation_output_get(NRF_NFCT_Type const * p_reg)
339  {
340      return (nrf_nfct_modulation_ctrl_t)(p_reg->MODULATIONCTRL &
341                                          NFCT_MODULATIONCTRL_MODULATIONCTRL_Msk);
342  }
343  #endif 
344  NRF_STATIC_INLINE uint32_t nrf_nfct_error_status_get(NRF_NFCT_Type const * p_reg)
345  {
346      return p_reg->ERRORSTATUS;
347  }
348  NRF_STATIC_INLINE void nrf_nfct_error_status_clear(NRF_NFCT_Type * p_reg, uint32_t error_flags)
349  {
350      p_reg->ERRORSTATUS = error_flags;
351  }
352  NRF_STATIC_INLINE uint32_t nrf_nfct_rx_frame_status_get(NRF_NFCT_Type const * p_reg)
353  {
354      return p_reg->FRAMESTATUS.RX;
355  }
356  NRF_STATIC_INLINE void nrf_nfct_rx_frame_status_clear(NRF_NFCT_Type * p_reg,
357                                                        uint32_t        framestatus_flags)
358  {
359      p_reg->FRAMESTATUS.RX = framestatus_flags;
360  }
361  #if defined(NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) || defined(__NRFX_DOXYGEN__)
362  NRF_STATIC_INLINE nrf_nfct_tag_state_t nrf_nfct_tag_state_get(NRF_NFCT_Type const * p_reg)
363  {
364      return (nrf_nfct_tag_state_t)((p_reg->NFCTAGSTATE & NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk) >>
365                                    NFCT_NFCTAGSTATE_NFCTAGSTATE_Pos);
366  }
367  #endif 
368  #if defined (NFCT_SLEEPSTATE_SLEEPSTATE_Msk) || defined(__NRFX_DOXYGEN__)
369  NRF_STATIC_INLINE nrf_nfct_sleep_state_t nrf_nfct_sleep_state_get(NRF_NFCT_Type const * p_reg)
370  {
371      return (nrf_nfct_sleep_state_t)((p_reg->SLEEPSTATE & NFCT_SLEEPSTATE_SLEEPSTATE_Msk) >>
372                                      NFCT_SLEEPSTATE_SLEEPSTATE_Pos);
373  }
374  #endif 
375  NRF_STATIC_INLINE uint8_t nrf_nfct_field_status_get(NRF_NFCT_Type const * p_reg)
376  {
377      return (uint8_t)(p_reg->FIELDPRESENT);
378  }
379  NRF_STATIC_INLINE uint16_t nrf_nfct_frame_delay_min_get(NRF_NFCT_Type const * p_reg)
380  {
381      return (uint16_t)((p_reg->FRAMEDELAYMIN & NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk) >>
382                        NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos);
383  }
384  NRF_STATIC_INLINE void nrf_nfct_frame_delay_min_set(NRF_NFCT_Type * p_reg, uint16_t frame_delay_min)
385  {
386      p_reg->FRAMEDELAYMIN =
387          ((uint32_t)frame_delay_min << NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos) &
388          NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk;
389  }
390  NRF_STATIC_INLINE uint32_t nrf_nfct_frame_delay_max_get(NRF_NFCT_Type const * p_reg)
391  {
392      return (p_reg->FRAMEDELAYMAX & NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk) >>
393             NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos;
394  }
395  NRF_STATIC_INLINE void nrf_nfct_frame_delay_max_set(NRF_NFCT_Type * p_reg, uint32_t frame_delay_max)
396  {
397      p_reg->FRAMEDELAYMAX =
398          ((uint32_t)frame_delay_max << NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos) &
399          NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk;
400  }
401  NRF_STATIC_INLINE
402  nrf_nfct_frame_delay_mode_t nrf_nfct_frame_delay_mode_get(NRF_NFCT_Type const * p_reg)
403  {
404      return (nrf_nfct_frame_delay_mode_t)(p_reg->FRAMEDELAYMODE &
405                                           NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk);
406  }
407  NRF_STATIC_INLINE void nrf_nfct_frame_delay_mode_set(NRF_NFCT_Type *             p_reg,
408                                                       nrf_nfct_frame_delay_mode_t frame_delay_mode)
409  {
410      p_reg->FRAMEDELAYMODE = (uint32_t)frame_delay_mode;
411  }
412  NRF_STATIC_INLINE uint8_t * nrf_nfct_rxtx_buffer_get(NRF_NFCT_Type const * p_reg)
413  {
414      return (uint8_t *)(p_reg->PACKETPTR);
415  }
416  NRF_STATIC_INLINE void nrf_nfct_rxtx_buffer_set(NRF_NFCT_Type * p_reg,
417                                                  uint8_t *       p_rxtx_buf,
418                                                  uint16_t        max_txrx_len)
419  {
420      p_reg->PACKETPTR = (uint32_t)p_rxtx_buf;
421      p_reg->MAXLEN    = ((uint32_t)max_txrx_len << NFCT_MAXLEN_MAXLEN_Pos) & NFCT_MAXLEN_MAXLEN_Msk;
422  }
423  NRF_STATIC_INLINE uint16_t nrf_nfct_max_rxtx_length_get(NRF_NFCT_Type const * p_reg)
424  {
425      return (uint16_t)((p_reg->MAXLEN & NFCT_MAXLEN_MAXLEN_Msk) >> NFCT_MAXLEN_MAXLEN_Pos);
426  }
427  NRF_STATIC_INLINE uint8_t nrf_nfct_tx_frame_config_get(NRF_NFCT_Type const * p_reg)
428  {
429      return (uint8_t)(p_reg->TXD.FRAMECONFIG);
430  }
431  NRF_STATIC_INLINE void nrf_nfct_tx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags)
432  {
433      p_reg->TXD.FRAMECONFIG = flags;
434  }
435  NRF_STATIC_INLINE uint16_t nrf_nfct_tx_bits_get(NRF_NFCT_Type const * p_reg)
436  {
437      return (uint16_t)(p_reg->TXD.AMOUNT & (NFCT_TXD_AMOUNT_TXDATABITS_Msk |
438                                             NFCT_TXD_AMOUNT_TXDATABYTES_Msk));
439  }
440  NRF_STATIC_INLINE void nrf_nfct_tx_bits_set(NRF_NFCT_Type * p_reg, uint16_t tx_bits)
441  {
442      p_reg->TXD.AMOUNT = (tx_bits & (NFCT_TXD_AMOUNT_TXDATABITS_Msk |
443                                      NFCT_TXD_AMOUNT_TXDATABYTES_Msk));
444  }
445  NRF_STATIC_INLINE uint8_t nrf_nfct_rx_frame_config_get(NRF_NFCT_Type const * p_reg)
446  {
447      return (uint8_t)(p_reg->RXD.FRAMECONFIG);
448  }
449  NRF_STATIC_INLINE void nrf_nfct_rx_frame_config_set(NRF_NFCT_Type * p_reg, uint8_t flags)
450  {
451      p_reg->RXD.FRAMECONFIG = flags;
452  }
453  NRF_STATIC_INLINE uint16_t nrf_nfct_rx_bits_get(NRF_NFCT_Type const * p_reg, bool crc_excluded)
454  {
455      uint16_t rx_bits = p_reg->RXD.AMOUNT & (NFCT_RXD_AMOUNT_RXDATABITS_Msk |
456                                              NFCT_RXD_AMOUNT_RXDATABYTES_Msk);
457      return rx_bits - (crc_excluded ? (8u * NRF_NFCT_CRC_SIZE) : 0);
458  }
459  NRF_STATIC_INLINE
460  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_nfcid1_get(NRF_NFCT_Type const * p_reg,
461                                                     uint8_t *             p_nfcid1_buf)
462  {
463      uint32_t nfcid1_last = p_reg->NFCID1_LAST;
464      nrf_nfct_sensres_nfcid1_size_t size =
465          (nrf_nfct_sensres_nfcid1_size_t)(p_reg->SENSRES & NFCT_SENSRES_NFCIDSIZE_Msk);
466      if (size != NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE)
467      {
468          uint32_t nfcid1_2nd_last = p_reg->NFCID1_2ND_LAST;
469          if (size == NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE)
470          {
471              uint32_t nfcid1_3rd_last = p_reg->NFCID1_3RD_LAST;
472              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 16UL);
473              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 8UL);
474              *p_nfcid1_buf++ = (uint8_t)(nfcid1_3rd_last >> 0UL);
475          }
476          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 16UL);
477          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 8UL);
478          *p_nfcid1_buf++ = (uint8_t)(nfcid1_2nd_last >> 0UL);
479      }
480      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 24UL);
481      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 16UL);
482      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 8UL);
483      *p_nfcid1_buf++ = (uint8_t)(nfcid1_last >> 0UL);
484      return size;
485  }
486  NRF_STATIC_INLINE void nrf_nfct_nfcid1_set(NRF_NFCT_Type *                p_reg,
487                                             uint8_t const *                p_nfcid1_buf,
488                                             nrf_nfct_sensres_nfcid1_size_t nfcid1_size)
489  {
490      nrf_nfct_sensres_nfcid1_size_t size = (nfcid1_size == NRF_NFCT_SENSRES_NFCID1_SIZE_DEFAULT) ?
491          NRF_NFCT_SENSRES_NFCID1_SIZE_DOUBLE : nfcid1_size;
492      if (size != NRF_NFCT_SENSRES_NFCID1_SIZE_SINGLE)
493      {
494          if (size == NRF_NFCT_SENSRES_NFCID1_SIZE_TRIPLE)
495          {
496              p_reg->NFCID1_3RD_LAST = ((uint32_t)p_nfcid1_buf[0] << 16UL) |
497                                          ((uint32_t)p_nfcid1_buf[1] << 8UL)  |
498                                          ((uint32_t)p_nfcid1_buf[2] << 0UL);
499              p_nfcid1_buf += 3UL;
500          }
501          p_reg->NFCID1_2ND_LAST = ((uint32_t)p_nfcid1_buf[0] << 16UL) |
502                                      ((uint32_t)p_nfcid1_buf[1] << 8UL)  |
503                                      ((uint32_t)p_nfcid1_buf[2] << 0UL);
504          p_nfcid1_buf += 3UL;
505      }
506      p_reg->NFCID1_LAST = ((uint32_t)p_nfcid1_buf[0] << 24UL) |
507                              ((uint32_t)p_nfcid1_buf[1] << 16UL) |
508                              ((uint32_t)p_nfcid1_buf[2] << 8UL)  |
509                              ((uint32_t)p_nfcid1_buf[3] << 0UL);
510      p_reg->SENSRES = ((p_reg->SENSRES & ~NFCT_SENSRES_NFCIDSIZE_Msk) |
511                           (uint32_t)size);
512  }
513  #if defined (NFCT_AUTOCOLRESCONFIG_MODE_Msk) || defined(__NRFX_DOXYGEN__)
514  NRF_STATIC_INLINE bool nrf_nfct_autocolres_is_enabled(NRF_NFCT_Type const * p_reg)
515  {
516      return (p_reg->AUTOCOLRESCONFIG & NFCT_AUTOCOLRESCONFIG_MODE_Msk) ==
517             (NFCT_AUTOCOLRESCONFIG_MODE_Enabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
518  }
519  NRF_STATIC_INLINE void nrf_nfct_autocolres_enable(NRF_NFCT_Type * p_reg)
520  {
521      p_reg->AUTOCOLRESCONFIG =
522          (p_reg->AUTOCOLRESCONFIG & ~NFCT_AUTOCOLRESCONFIG_MODE_Msk) |
523          (NFCT_AUTOCOLRESCONFIG_MODE_Enabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
524  }
525  NRF_STATIC_INLINE void nrf_nfct_autocolres_disable(NRF_NFCT_Type * p_reg)
526  {
527      p_reg->AUTOCOLRESCONFIG =
528          (p_reg->AUTOCOLRESCONFIG & ~NFCT_AUTOCOLRESCONFIG_MODE_Msk) |
529          (NFCT_AUTOCOLRESCONFIG_MODE_Disabled << NFCT_AUTOCOLRESCONFIG_MODE_Pos);
530  }
531  #endif 
532  NRF_STATIC_INLINE
533  nrf_nfct_sensres_nfcid1_size_t nrf_nfct_sensres_nfcid1_size_get(NRF_NFCT_Type const * p_reg)
534  {
535      return (nrf_nfct_sensres_nfcid1_size_t)(p_reg->SENSRES & NFCT_SENSRES_NFCIDSIZE_Msk);
536  }
537  NRF_STATIC_INLINE void nrf_nfct_sensres_nfcid1_size_set(NRF_NFCT_Type *                p_reg,
538                                                          nrf_nfct_sensres_nfcid1_size_t nfcid1_size)
539  {
540      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_NFCIDSIZE_Msk)) |
541                           (uint32_t)nfcid1_size);
542  }
543  NRF_STATIC_INLINE
544  nrf_nfct_sensres_bit_frame_sdd_t nrf_nfct_sensres_bit_frame_sdd_get(NRF_NFCT_Type const * p_reg)
545  {
546      return (nrf_nfct_sensres_bit_frame_sdd_t)(p_reg->SENSRES & NFCT_SENSRES_BITFRAMESDD_Msk);
547  }
548  NRF_STATIC_INLINE
549  void nrf_nfct_sensres_bit_frame_sdd_set(NRF_NFCT_Type * p_reg,
550                                          nrf_nfct_sensres_bit_frame_sdd_t bit_frame_sdd)
551  {
552      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_BITFRAMESDD_Msk)) | (uint32_t)bit_frame_sdd);
553  }
554  NRF_STATIC_INLINE
555  nrf_nfct_sensres_platform_config_t nrf_nfct_sensres_platform_config_get(NRF_NFCT_Type const * p_reg)
556  {
557      return (nrf_nfct_sensres_platform_config_t)(p_reg->SENSRES & NFCT_SENSRES_PLATFCONFIG_Msk);
558  }
559  NRF_STATIC_INLINE
560  void nrf_nfct_sensres_platform_config_set(NRF_NFCT_Type * p_reg,
561                                            nrf_nfct_sensres_platform_config_t platform_config)
562  {
563      p_reg->SENSRES = ((p_reg->SENSRES & ~(NFCT_SENSRES_PLATFCONFIG_Msk)) |
564                        (uint32_t)platform_config);
565  }
566  NRF_STATIC_INLINE bool nrf_nfct_selres_cascade_check(NRF_NFCT_Type const * p_reg)
567  {
568      return (bool)(p_reg->SELRES & NFCT_SELRES_CASCADE_Msk);
569  }
570  NRF_STATIC_INLINE
571  nrf_nfct_selres_protocol_t nrf_nfct_selres_protocol_get(NRF_NFCT_Type const * p_reg)
572  {
573      return (nrf_nfct_selres_protocol_t)((p_reg->SELRES & NFCT_SELRES_PROTOCOL_Msk) >>
574                                          NFCT_SELRES_PROTOCOL_Pos);
575  }
576  NRF_STATIC_INLINE void nrf_nfct_selres_protocol_set(NRF_NFCT_Type *            p_reg,
577                                                      nrf_nfct_selres_protocol_t sel_res_protocol)
578  {
579      p_reg->SELRES = (p_reg->SELRES & ~NFCT_SELRES_PROTOCOL_Msk) |
580                      ((uint32_t)sel_res_protocol << NFCT_SELRES_PROTOCOL_Pos);
581  }
582  #endif &bsol;* NRF_DECLARE_ONLY */
583  #ifdef __cplusplus
584  }
585  #endif
586  #endif &bsol;* NRF_NFCT_H__ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nfct.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nfct.h</div>
                </div>
                <div class="column column_space"><pre><code>209  NRF_STATIC_INLINE nrf_nfct_sleep_state_t nrf_nfct_sleep_state_get(NRF_NFCT_Type const * p_reg);
210  #endif 
211  NRF_STATIC_INLINE uint8_t nrf_nfct_field_status_get(NRF_NFCT_Type const * p_reg);
212  NRF_STATIC_INLINE uint16_t nrf_nfct_frame_delay_min_get(NRF_NFCT_Type const * p_reg);
</pre></code></div>
                <div class="column column_space"><pre><code>197  NRF_STATIC_INLINE
198  nrf_nfct_modulation_ctrl_t nrf_nfct_modulation_output_get(NRF_NFCT_Type const * p_reg);
199  #endif 
200  NRF_STATIC_INLINE uint32_t nrf_nfct_error_status_get(NRF_NFCT_Type const * p_reg);
201  NRF_STATIC_INLINE void nrf_nfct_error_status_clear(NRF_NFCT_Type * p_reg, uint32_t error_flag);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    