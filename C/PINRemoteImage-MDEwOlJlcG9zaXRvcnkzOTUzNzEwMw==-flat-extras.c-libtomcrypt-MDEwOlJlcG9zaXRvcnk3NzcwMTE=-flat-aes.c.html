
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.140350877192982%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-extras.c</h3>
            <pre><code>1  #include "extras/extras.h"
2  #include "webp/format_constants.h"
3  #include "src/dsp/dsp.h"
4  #include <assert.h>
5  #include <string.h>
6  #define XTRA_MAJ_VERSION 1
7  #define XTRA_MIN_VERSION 1
8  #define XTRA_REV_VERSION 0
9  int WebPGetExtrasVersion(void) {
10    return (XTRA_MAJ_VERSION << 16) | (XTRA_MIN_VERSION << 8) | XTRA_REV_VERSION;
11  }
12  int WebPImportGray(const uint8_t* gray_data, WebPPicture* pic) {
13    int y, width, uv_width;
14    if (pic == NULL || gray_data == NULL) return 0;
15    pic->colorspace = WEBP_YUV420;
16    if (!WebPPictureAlloc(pic)) return 0;
17    width = pic->width;
18    uv_width = (width + 1) >> 1;
19    for (y = 0; y < pic->height; ++y) {
20      memcpy(pic->y + y * pic->y_stride, gray_data, width);
21      gray_data += width;    
22      if ((y & 1) == 0) {
23        memset(pic->u + (y >> 1) * pic->uv_stride, 128, uv_width);
24        memset(pic->v + (y >> 1) * pic->uv_stride, 128, uv_width);
25      }
26    }
27    return 1;
28  }
29  int WebPImportRGB565(const uint8_t* rgb565, WebPPicture* pic) {
30    int x, y;
31    uint32_t* dst;
32    if (pic == NULL || rgb565 == NULL) return 0;
33    pic->colorspace = WEBP_YUV420;
34    pic->use_argb = 1;
35    if (!WebPPictureAlloc(pic)) return 0;
36    dst = pic->argb;
37    for (y = 0; y < pic->height; ++y) {
38      const int width = pic->width;
39      for (x = 0; x < width; ++x) {
40  #if defined(WEBP_SWAP_16BIT_CSP) && (WEBP_SWAP_16BIT_CSP == 1)
41        const uint32_t rg = rgb565[2 * x + 1];
42        const uint32_t gb = rgb565[2 * x + 0];
43  #else
44        const uint32_t rg = rgb565[2 * x + 0];
45        const uint32_t gb = rgb565[2 * x + 1];
46  #endif
47        uint32_t r = rg & 0xf8;
48        uint32_t g = ((rg << 5) | (gb >> 3)) & 0xfc;
49        uint32_t b = (gb << 5);
50        r = r | (r >> 5);
51        g = g | (g >> 6);
52        b = b | (b >> 5);
53        dst[x] = (0xffu << 24) | (r << 16) | (g << 8) | b;
54      }
55      rgb565 += 2 * width;
56      dst += pic->argb_stride;
57    }
58    return 1;
59  }
60  int WebPImportRGB4444(const uint8_t* rgb4444, WebPPicture* pic) {
61    int x, y;
62    uint32_t* dst;
63    if (pic == NULL || rgb4444 == NULL) return 0;
64    pic->colorspace = WEBP_YUV420;
65    pic->use_argb = 1;
66    if (!WebPPictureAlloc(pic)) return 0;
67    dst = pic->argb;
68    for (y = 0; y < pic->height; ++y) {
69      const int width = pic->width;
70      for (x = 0; x < width; ++x) {
71  #if defined(WEBP_SWAP_16BIT_CSP) && (WEBP_SWAP_16BIT_CSP == 1)
72        const uint32_t rg = rgb4444[2 * x + 1];
73        const uint32_t ba = rgb4444[2 * x + 0];
74  #else
75        const uint32_t rg = rgb4444[2 * x + 0];
<span onclick='openModal()' class='match'>76        const uint32_t ba = rgb4444[2 * x + 1];
77  #endif
78        uint32_t r = rg & 0xf0;
79        uint32_t g = (rg << 4);
80        uint32_t b = (ba & 0xf0);
81        uint32_t a = (ba << 4);
82        r = r | (r >> 4);
83        g = g | (g >> 4);
84        b = b | (b >> 4);
85        a = a | (a >> 4);
86        dst[x] = (a << 24) | (r << 16) | (g << 8) | b;
87      }
88      rgb4444 += 2 * width;
89      dst += pic->argb_stride;
</span>90    }
91    return 1;
92  }
93  int WebPImportColorMappedARGB(const uint8_t* indexed, int indexed_stride,
94                                const uint32_t palette[], int palette_size,
95                                WebPPicture* pic) {
96    int x, y;
97    uint32_t* dst;
98    assert(MAX_PALETTE_SIZE <= 256);
99    if (pic == NULL || indexed == NULL || indexed_stride < pic->width ||
100        palette == NULL || palette_size > MAX_PALETTE_SIZE || palette_size <= 0) {
101      return 0;
102    }
103    pic->use_argb = 1;
104    if (!WebPPictureAlloc(pic)) return 0;
105    dst = pic->argb;
106    for (y = 0; y < pic->height; ++y) {
107      for (x = 0; x < pic->width; ++x) {
108        if (indexed[x] >= palette_size) {
109          WebPPictureFree(pic);
110          return 0;
111        }
112        dst[x] = palette[indexed[x]];
113      }
114      indexed += indexed_stride;
115      dst += pic->argb_stride;
116    }
117    return 1;
118  }
119  int WebPUnmultiplyARGB(WebPPicture* pic) {
120    int y;
121    uint32_t* dst;
122    if (pic == NULL || pic->use_argb != 1 || pic->argb == NULL) return 0;
123    WebPInitAlphaProcessing();
124    dst = pic->argb;
125    for (y = 0; y < pic->height; ++y) {
126      WebPMultARGBRow(dst, pic->width, &bsol;*inverse=*/1);
127      dst += pic->argb_stride;
128    }
129    return 1;
130  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIJNDAEL
3  #ifndef ENCRYPT_ONLY
4  #define SETUP    rijndael_setup
5  #define ECB_ENC  rijndael_ecb_encrypt
6  #define ECB_DEC  rijndael_ecb_decrypt
7  #define ECB_DONE rijndael_done
8  #define ECB_TEST rijndael_test
9  #define ECB_KS   rijndael_keysize
10  const struct ltc_cipher_descriptor rijndael_desc =
11  {
12      "rijndael",
13      6,
14      16, 32, 16, 10,
15      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  const struct ltc_cipher_descriptor aes_desc =
19  {
20      "aes",
21      6,
22      16, 32, 16, 10,
23      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
24      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
25  };
26  #else
27  #define SETUP    rijndael_enc_setup
28  #define ECB_ENC  rijndael_enc_ecb_encrypt
29  #define ECB_KS   rijndael_enc_keysize
30  #define ECB_DONE rijndael_enc_done
31  const struct ltc_cipher_descriptor rijndael_enc_desc =
32  {
33      "rijndael",
34      6,
35      16, 32, 16, 10,
36      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
37      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
38  };
39  const struct ltc_cipher_descriptor aes_enc_desc =
40  {
41      "aes",
42      6,
43      16, 32, 16, 10,
44      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
45      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
46  };
47  #endif
48  #define LTC_AES_TAB_C
49  #include "aes_tab.c"
50  static ulong32 setup_mix(ulong32 temp)
51  {
52     return (Te4_3[LTC_BYTE(temp, 2)]) ^
53            (Te4_2[LTC_BYTE(temp, 1)]) ^
54            (Te4_1[LTC_BYTE(temp, 0)]) ^
55            (Te4_0[LTC_BYTE(temp, 3)]);
56  }
57  #ifndef ENCRYPT_ONLY
58  #ifdef LTC_SMALL_CODE
59  static ulong32 setup_mix2(ulong32 temp)
60  {
61     return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
62            Td1(255 & Te4[LTC_BYTE(temp, 2)]) ^
63            Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
64            Td3(255 & Te4[LTC_BYTE(temp, 0)]);
65  }
66  #endif
67  #endif
68  int SETUP(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
69  {
70      int i;
71      ulong32 temp, *rk;
72  #ifndef ENCRYPT_ONLY
73      ulong32 *rrk;
74  #endif
75      LTC_ARGCHK(key  != NULL);
76      LTC_ARGCHK(skey != NULL);
77      if (keylen != 16 && keylen != 24 && keylen != 32) {
78         return CRYPT_INVALID_KEYSIZE;
79      }
80      if (num_rounds != 0 && num_rounds != (10 + ((keylen/8)-2)*2)) {
81         return CRYPT_INVALID_ROUNDS;
82      }
83      skey->rijndael.Nr = 10 + ((keylen/8)-2)*2;
84      i                 = 0;
85      rk                = skey->rijndael.eK;
86      LOAD32H(rk[0], key     );
87      LOAD32H(rk[1], key +  4);
88      LOAD32H(rk[2], key +  8);
89      LOAD32H(rk[3], key + 12);
90      if (keylen == 16) {
91          for (;;) {
92              temp  = rk[3];
93              rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
94              rk[5] = rk[1] ^ rk[4];
95              rk[6] = rk[2] ^ rk[5];
96              rk[7] = rk[3] ^ rk[6];
97              if (++i == 10) {
98                 break;
99              }
100              rk += 4;
101          }
102      } else if (keylen == 24) {
103          LOAD32H(rk[4], key + 16);
104          LOAD32H(rk[5], key + 20);
105          for (;;) {
106          #ifdef _MSC_VER
107              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 5];
108          #else
109              temp = rk[5];
110          #endif
111              rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
112              rk[ 7] = rk[ 1] ^ rk[ 6];
113              rk[ 8] = rk[ 2] ^ rk[ 7];
114              rk[ 9] = rk[ 3] ^ rk[ 8];
115              if (++i == 8) {
116                  break;
117              }
118              rk[10] = rk[ 4] ^ rk[ 9];
119              rk[11] = rk[ 5] ^ rk[10];
120              rk += 6;
121          }
122      } else if (keylen == 32) {
123          LOAD32H(rk[4], key + 16);
124          LOAD32H(rk[5], key + 20);
125          LOAD32H(rk[6], key + 24);
126          LOAD32H(rk[7], key + 28);
127          for (;;) {
128          #ifdef _MSC_VER
129              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 7];
130          #else
131              temp = rk[7];
132          #endif
133              rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
134              rk[ 9] = rk[ 1] ^ rk[ 8];
135              rk[10] = rk[ 2] ^ rk[ 9];
136              rk[11] = rk[ 3] ^ rk[10];
137              if (++i == 7) {
138                  break;
139              }
140              temp = rk[11];
141              rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
142              rk[13] = rk[ 5] ^ rk[12];
143              rk[14] = rk[ 6] ^ rk[13];
144              rk[15] = rk[ 7] ^ rk[14];
145              rk += 8;
146          }
147      } else {
148         return CRYPT_ERROR;
149      }
150  #ifndef ENCRYPT_ONLY
151      rk   = skey->rijndael.dK;
152      rrk  = skey->rijndael.eK + (28 + keylen) - 4;
153      *rk++ = *rrk++;
154      *rk++ = *rrk++;
155      *rk++ = *rrk++;
156      *rk   = *rrk;
157      rk -= 3; rrk -= 3;
158      for (i = 1; i < skey->rijndael.Nr; i++) {
159          rrk -= 4;
160          rk  += 4;
161      #ifdef LTC_SMALL_CODE
162          temp = rrk[0];
163          rk[0] = setup_mix2(temp);
164          temp = rrk[1];
165          rk[1] = setup_mix2(temp);
166          temp = rrk[2];
167          rk[2] = setup_mix2(temp);
<span onclick='openModal()' class='match'>168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
191              Tks0[LTC_BYTE(temp, 3)] ^
192              Tks1[LTC_BYTE(temp, 2)] ^
193              Tks2[LTC_BYTE(temp, 1)] ^
194              Tks3[LTC_BYTE(temp, 0)];
195        #endif
196      }
197      rrk -= 4;
198      rk  += 4;
</span>199      *rk++ = *rrk++;
200      *rk++ = *rrk++;
201      *rk++ = *rrk++;
202      *rk   = *rrk;
203  #endif &bsol;* ENCRYPT_ONLY */
204      return CRYPT_OK;
205  }
206  #ifdef LTC_CLEAN_STACK
207  static int s_rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
208  #else
209  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
210  #endif
211  {
212      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
213      const ulong32 *rk;
214      int Nr, r;
215      LTC_ARGCHK(pt != NULL);
216      LTC_ARGCHK(ct != NULL);
217      LTC_ARGCHK(skey != NULL);
218      Nr = skey->rijndael.Nr;
219      if (Nr < 2 || Nr > 16)
220          return CRYPT_INVALID_ROUNDS;
221      rk = skey->rijndael.eK;
222      LOAD32H(s0, pt      ); s0 ^= rk[0];
223      LOAD32H(s1, pt  +  4); s1 ^= rk[1];
224      LOAD32H(s2, pt  +  8); s2 ^= rk[2];
225      LOAD32H(s3, pt  + 12); s3 ^= rk[3];
226  #ifdef LTC_SMALL_CODE
227      for (r = 0; ; r++) {
228          rk += 4;
229          t0 =
230              Te0(LTC_BYTE(s0, 3)) ^
231              Te1(LTC_BYTE(s1, 2)) ^
232              Te2(LTC_BYTE(s2, 1)) ^
233              Te3(LTC_BYTE(s3, 0)) ^
234              rk[0];
235          t1 =
236              Te0(LTC_BYTE(s1, 3)) ^
237              Te1(LTC_BYTE(s2, 2)) ^
238              Te2(LTC_BYTE(s3, 1)) ^
239              Te3(LTC_BYTE(s0, 0)) ^
240              rk[1];
241          t2 =
242              Te0(LTC_BYTE(s2, 3)) ^
243              Te1(LTC_BYTE(s3, 2)) ^
244              Te2(LTC_BYTE(s0, 1)) ^
245              Te3(LTC_BYTE(s1, 0)) ^
246              rk[2];
247          t3 =
248              Te0(LTC_BYTE(s3, 3)) ^
249              Te1(LTC_BYTE(s0, 2)) ^
250              Te2(LTC_BYTE(s1, 1)) ^
251              Te3(LTC_BYTE(s2, 0)) ^
252              rk[3];
253          if (r == Nr-2) {
254             break;
255          }
256          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
257      }
258      rk += 4;
259  #else
260      r = Nr >> 1;
261      for (;;) {
262          t0 =
263              Te0(LTC_BYTE(s0, 3)) ^
264              Te1(LTC_BYTE(s1, 2)) ^
265              Te2(LTC_BYTE(s2, 1)) ^
266              Te3(LTC_BYTE(s3, 0)) ^
267              rk[4];
268          t1 =
269              Te0(LTC_BYTE(s1, 3)) ^
270              Te1(LTC_BYTE(s2, 2)) ^
271              Te2(LTC_BYTE(s3, 1)) ^
272              Te3(LTC_BYTE(s0, 0)) ^
273              rk[5];
274          t2 =
275              Te0(LTC_BYTE(s2, 3)) ^
276              Te1(LTC_BYTE(s3, 2)) ^
277              Te2(LTC_BYTE(s0, 1)) ^
278              Te3(LTC_BYTE(s1, 0)) ^
279              rk[6];
280          t3 =
281              Te0(LTC_BYTE(s3, 3)) ^
282              Te1(LTC_BYTE(s0, 2)) ^
283              Te2(LTC_BYTE(s1, 1)) ^
284              Te3(LTC_BYTE(s2, 0)) ^
285              rk[7];
286          rk += 8;
287          if (--r == 0) {
288              break;
289          }
290          s0 =
291              Te0(LTC_BYTE(t0, 3)) ^
292              Te1(LTC_BYTE(t1, 2)) ^
293              Te2(LTC_BYTE(t2, 1)) ^
294              Te3(LTC_BYTE(t3, 0)) ^
295              rk[0];
296          s1 =
297              Te0(LTC_BYTE(t1, 3)) ^
298              Te1(LTC_BYTE(t2, 2)) ^
299              Te2(LTC_BYTE(t3, 1)) ^
300              Te3(LTC_BYTE(t0, 0)) ^
301              rk[1];
302          s2 =
303              Te0(LTC_BYTE(t2, 3)) ^
304              Te1(LTC_BYTE(t3, 2)) ^
305              Te2(LTC_BYTE(t0, 1)) ^
306              Te3(LTC_BYTE(t1, 0)) ^
307              rk[2];
308          s3 =
309              Te0(LTC_BYTE(t3, 3)) ^
310              Te1(LTC_BYTE(t0, 2)) ^
311              Te2(LTC_BYTE(t1, 1)) ^
312              Te3(LTC_BYTE(t2, 0)) ^
313              rk[3];
314      }
315  #endif
316      s0 =
317          (Te4_3[LTC_BYTE(t0, 3)]) ^
318          (Te4_2[LTC_BYTE(t1, 2)]) ^
319          (Te4_1[LTC_BYTE(t2, 1)]) ^
320          (Te4_0[LTC_BYTE(t3, 0)]) ^
321          rk[0];
322      STORE32H(s0, ct);
323      s1 =
324          (Te4_3[LTC_BYTE(t1, 3)]) ^
325          (Te4_2[LTC_BYTE(t2, 2)]) ^
326          (Te4_1[LTC_BYTE(t3, 1)]) ^
327          (Te4_0[LTC_BYTE(t0, 0)]) ^
328          rk[1];
329      STORE32H(s1, ct+4);
330      s2 =
331          (Te4_3[LTC_BYTE(t2, 3)]) ^
332          (Te4_2[LTC_BYTE(t3, 2)]) ^
333          (Te4_1[LTC_BYTE(t0, 1)]) ^
334          (Te4_0[LTC_BYTE(t1, 0)]) ^
335          rk[2];
336      STORE32H(s2, ct+8);
337      s3 =
338          (Te4_3[LTC_BYTE(t3, 3)]) ^
339          (Te4_2[LTC_BYTE(t0, 2)]) ^
340          (Te4_1[LTC_BYTE(t1, 1)]) ^
341          (Te4_0[LTC_BYTE(t2, 0)]) ^
342          rk[3];
343      STORE32H(s3, ct+12);
344      return CRYPT_OK;
345  }
346  #ifdef LTC_CLEAN_STACK
347  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
348  {
349     int err = s_rijndael_ecb_encrypt(pt, ct, skey);
350     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
351     return err;
352  }
353  #endif
354  #ifndef ENCRYPT_ONLY
355  #ifdef LTC_CLEAN_STACK
356  static int s_rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
357  #else
358  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
359  #endif
360  {
361      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
362      const ulong32 *rk;
363      int Nr, r;
364      LTC_ARGCHK(pt != NULL);
365      LTC_ARGCHK(ct != NULL);
366      LTC_ARGCHK(skey != NULL);
367      Nr = skey->rijndael.Nr;
368      if (Nr < 2 || Nr > 16)
369          return CRYPT_INVALID_ROUNDS;
370      rk = skey->rijndael.dK;
371      LOAD32H(s0, ct      ); s0 ^= rk[0];
372      LOAD32H(s1, ct  +  4); s1 ^= rk[1];
373      LOAD32H(s2, ct  +  8); s2 ^= rk[2];
374      LOAD32H(s3, ct  + 12); s3 ^= rk[3];
375  #ifdef LTC_SMALL_CODE
376      for (r = 0; ; r++) {
377          rk += 4;
378          t0 =
379              Td0(LTC_BYTE(s0, 3)) ^
380              Td1(LTC_BYTE(s3, 2)) ^
381              Td2(LTC_BYTE(s2, 1)) ^
382              Td3(LTC_BYTE(s1, 0)) ^
383              rk[0];
384          t1 =
385              Td0(LTC_BYTE(s1, 3)) ^
386              Td1(LTC_BYTE(s0, 2)) ^
387              Td2(LTC_BYTE(s3, 1)) ^
388              Td3(LTC_BYTE(s2, 0)) ^
389              rk[1];
390          t2 =
391              Td0(LTC_BYTE(s2, 3)) ^
392              Td1(LTC_BYTE(s1, 2)) ^
393              Td2(LTC_BYTE(s0, 1)) ^
394              Td3(LTC_BYTE(s3, 0)) ^
395              rk[2];
396          t3 =
397              Td0(LTC_BYTE(s3, 3)) ^
398              Td1(LTC_BYTE(s2, 2)) ^
399              Td2(LTC_BYTE(s1, 1)) ^
400              Td3(LTC_BYTE(s0, 0)) ^
401              rk[3];
402          if (r == Nr-2) {
403             break;
404          }
405          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
406      }
407      rk += 4;
408  #else
409      r = Nr >> 1;
410      for (;;) {
411          t0 =
412              Td0(LTC_BYTE(s0, 3)) ^
413              Td1(LTC_BYTE(s3, 2)) ^
414              Td2(LTC_BYTE(s2, 1)) ^
415              Td3(LTC_BYTE(s1, 0)) ^
416              rk[4];
417          t1 =
418              Td0(LTC_BYTE(s1, 3)) ^
419              Td1(LTC_BYTE(s0, 2)) ^
420              Td2(LTC_BYTE(s3, 1)) ^
421              Td3(LTC_BYTE(s2, 0)) ^
422              rk[5];
423          t2 =
424              Td0(LTC_BYTE(s2, 3)) ^
425              Td1(LTC_BYTE(s1, 2)) ^
426              Td2(LTC_BYTE(s0, 1)) ^
427              Td3(LTC_BYTE(s3, 0)) ^
428              rk[6];
429          t3 =
430              Td0(LTC_BYTE(s3, 3)) ^
431              Td1(LTC_BYTE(s2, 2)) ^
432              Td2(LTC_BYTE(s1, 1)) ^
433              Td3(LTC_BYTE(s0, 0)) ^
434              rk[7];
435          rk += 8;
436          if (--r == 0) {
437              break;
438          }
439          s0 =
440              Td0(LTC_BYTE(t0, 3)) ^
441              Td1(LTC_BYTE(t3, 2)) ^
442              Td2(LTC_BYTE(t2, 1)) ^
443              Td3(LTC_BYTE(t1, 0)) ^
444              rk[0];
445          s1 =
446              Td0(LTC_BYTE(t1, 3)) ^
447              Td1(LTC_BYTE(t0, 2)) ^
448              Td2(LTC_BYTE(t3, 1)) ^
449              Td3(LTC_BYTE(t2, 0)) ^
450              rk[1];
451          s2 =
452              Td0(LTC_BYTE(t2, 3)) ^
453              Td1(LTC_BYTE(t1, 2)) ^
454              Td2(LTC_BYTE(t0, 1)) ^
455              Td3(LTC_BYTE(t3, 0)) ^
456              rk[2];
457          s3 =
458              Td0(LTC_BYTE(t3, 3)) ^
459              Td1(LTC_BYTE(t2, 2)) ^
460              Td2(LTC_BYTE(t1, 1)) ^
461              Td3(LTC_BYTE(t0, 0)) ^
462              rk[3];
463      }
464  #endif
465      s0 =
466          (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
467          (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
468          (Td4[LTC_BYTE(t2, 1)] & 0x0000ff00) ^
469          (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
470          rk[0];
471      STORE32H(s0, pt);
472      s1 =
473          (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
474          (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
475          (Td4[LTC_BYTE(t3, 1)] & 0x0000ff00) ^
476          (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
477          rk[1];
478      STORE32H(s1, pt+4);
479      s2 =
480          (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
481          (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
482          (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
483          (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
484          rk[2];
485      STORE32H(s2, pt+8);
486      s3 =
487          (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
488          (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
489          (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
490          (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
491          rk[3];
492      STORE32H(s3, pt+12);
493      return CRYPT_OK;
494  }
495  #ifdef LTC_CLEAN_STACK
496  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
497  {
498     int err = s_rijndael_ecb_decrypt(ct, pt, skey);
499     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
500     return err;
501  }
502  #endif
503  int ECB_TEST(void)
504  {
505   #ifndef LTC_TEST
506      return CRYPT_NOP;
507   #else
508   int err;
509   static const struct {
510       int keylen;
511       unsigned char key[32], pt[16], ct[16];
512   } tests[] = {
513      { 16,
514        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
515          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
516        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
517          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
518        { 0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
519          0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a }
520      }, {
521        24,
522        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
523          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
524          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 },
525        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
526          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
527        { 0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
528          0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91 }
529      }, {
530        32,
531        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
532          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
533          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
534          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
535        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
536          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
537        { 0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
538          0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89 }
539      }
540   };
541    symmetric_key key;
542    unsigned char tmp[2][16];
543    int i, y;
544    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
545      zeromem(&key, sizeof(key));
546      if ((err = rijndael_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
547         return err;
548      }
549      rijndael_ecb_encrypt(tests[i].pt, tmp[0], &key);
550      rijndael_ecb_decrypt(tmp[0], tmp[1], &key);
551      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "AES Encrypt", i) ||
552            compare_testvector(tmp[1], 16, tests[i].pt, 16, "AES Decrypt", i)) {
553          return CRYPT_FAIL_TESTVECTOR;
554      }
555      for (y = 0; y < 16; y++) tmp[0][y] = 0;
556      for (y = 0; y < 1000; y++) rijndael_ecb_encrypt(tmp[0], tmp[0], &key);
557      for (y = 0; y < 1000; y++) rijndael_ecb_decrypt(tmp[0], tmp[0], &key);
558      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
559    }
560    return CRYPT_OK;
561   #endif
562  }
563  #endif &bsol;* ENCRYPT_ONLY */
564  void ECB_DONE(symmetric_key *skey)
565  {
566    LTC_UNUSED_PARAM(skey);
567  }
568  int ECB_KS(int *keysize)
569  {
570     LTC_ARGCHK(keysize != NULL);
571     if (*keysize < 16) {
572        return CRYPT_INVALID_KEYSIZE;
573     }
574     if (*keysize < 24) {
575        *keysize = 16;
576        return CRYPT_OK;
577     }
578     if (*keysize < 32) {
579        *keysize = 24;
580        return CRYPT_OK;
581     }
582     *keysize = 32;
583     return CRYPT_OK;
584  }
585  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-extras.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</div>
                </div>
                <div class="column column_space"><pre><code>76        const uint32_t ba = rgb4444[2 * x + 1];
77  #endif
78        uint32_t r = rg & 0xf0;
79        uint32_t g = (rg << 4);
80        uint32_t b = (ba & 0xf0);
81        uint32_t a = (ba << 4);
82        r = r | (r >> 4);
83        g = g | (g >> 4);
84        b = b | (b >> 4);
85        a = a | (a >> 4);
86        dst[x] = (a << 24) | (r << 16) | (g << 8) | b;
87      }
88      rgb4444 += 2 * width;
89      dst += pic->argb_stride;
</pre></code></div>
                <div class="column column_space"><pre><code>168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
191              Tks0[LTC_BYTE(temp, 3)] ^
192              Tks1[LTC_BYTE(temp, 2)] ^
193              Tks2[LTC_BYTE(temp, 1)] ^
194              Tks3[LTC_BYTE(temp, 0)];
195        #endif
196      }
197      rrk -= 4;
198      rk  += 4;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    