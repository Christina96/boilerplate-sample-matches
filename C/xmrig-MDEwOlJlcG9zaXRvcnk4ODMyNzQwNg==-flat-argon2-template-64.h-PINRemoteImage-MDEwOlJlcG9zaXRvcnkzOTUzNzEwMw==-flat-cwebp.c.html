
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1788079470198674%, Tokens: 8</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-template-64.h</h3>
            <pre><code>1  #include <string.h>
2  #include "core.h"
3  #define MASK_32 UINT64_C(0xFFFFFFFF)
4  #define F(x, y) ((x) + (y) + 2 * ((x) & MASK_32) * ((y) & MASK_32))
5  #define G(a, b, c, d) \
6      do { \
7          a = F(a, b); \
8          d = rotr64(d ^ a, 32); \
9          c = F(c, d); \
10          b = rotr64(b ^ c, 24); \
11          a = F(a, b); \
12          d = rotr64(d ^ a, 16); \
13          c = F(c, d); \
14          b = rotr64(b ^ c, 63); \
15      } while ((void)0, 0)
16  #define BLAKE2_ROUND_NOMSG(v0, v1, v2, v3, v4, v5, v6, v7, \
17                             v8, v9, v10, v11, v12, v13, v14, v15) \
18      do { \
19          G(v0, v4, v8,  v12); \
20          G(v1, v5, v9,  v13); \
21          G(v2, v6, v10, v14); \
22          G(v3, v7, v11, v15); \
23          G(v0, v5, v10, v15); \
24          G(v1, v6, v11, v12); \
25          G(v2, v7, v8,  v13); \
26          G(v3, v4, v9,  v14); \
27      } while ((void)0, 0)
28  #define BLAKE2_ROUND_NOMSG1(v) \
29      BLAKE2_ROUND_NOMSG( \
30          (v)[ 0], (v)[ 1], (v)[ 2], (v)[ 3], \
31          (v)[ 4], (v)[ 5], (v)[ 6], (v)[ 7], \
32          (v)[ 8], (v)[ 9], (v)[10], (v)[11], \
33          (v)[12], (v)[13], (v)[14], (v)[15])
34  #define BLAKE2_ROUND_NOMSG2(v) \
35      BLAKE2_ROUND_NOMSG( \
36          (v)[  0], (v)[  1], (v)[ 16], (v)[ 17], \
37          (v)[ 32], (v)[ 33], (v)[ 48], (v)[ 49], \
38          (v)[ 64], (v)[ 65], (v)[ 80], (v)[ 81], \
39          (v)[ 96], (v)[ 97], (v)[112], (v)[113])
40  static void fill_block(const block *prev_block, const block *ref_block,
41                         block *next_block, int with_xor)
42  {
43      block blockR, block_tmp;
44      copy_block(&blockR, ref_block);
45      xor_block(&blockR, prev_block);
46      copy_block(&block_tmp, &blockR);
47      if (with_xor) {
48          xor_block(&block_tmp, next_block);
49      }
50      BLAKE2_ROUND_NOMSG1(blockR.v + 0 * 16);
51      BLAKE2_ROUND_NOMSG1(blockR.v + 1 * 16);
52      BLAKE2_ROUND_NOMSG1(blockR.v + 2 * 16);
53      BLAKE2_ROUND_NOMSG1(blockR.v + 3 * 16);
54      BLAKE2_ROUND_NOMSG1(blockR.v + 4 * 16);
55      BLAKE2_ROUND_NOMSG1(blockR.v + 5 * 16);
56      BLAKE2_ROUND_NOMSG1(blockR.v + 6 * 16);
57      BLAKE2_ROUND_NOMSG1(blockR.v + 7 * 16);
58      BLAKE2_ROUND_NOMSG2(blockR.v + 0 * 2);
59      BLAKE2_ROUND_NOMSG2(blockR.v + 1 * 2);
60      BLAKE2_ROUND_NOMSG2(blockR.v + 2 * 2);
61      BLAKE2_ROUND_NOMSG2(blockR.v + 3 * 2);
62      BLAKE2_ROUND_NOMSG2(blockR.v + 4 * 2);
63      BLAKE2_ROUND_NOMSG2(blockR.v + 5 * 2);
64      BLAKE2_ROUND_NOMSG2(blockR.v + 6 * 2);
65      BLAKE2_ROUND_NOMSG2(blockR.v + 7 * 2);
66      copy_block(next_block, &block_tmp);
67      xor_block(next_block, &blockR);
68  }
69  static void next_addresses(block *address_block, block *input_block,
70                             const block *zero_block)
71  {
72      input_block->v[6]++;
73      fill_block(zero_block, input_block, address_block, 0);
74      fill_block(zero_block, address_block, address_block, 0);
75  }
76  static void fill_segment_64(const argon2_instance_t *instance,
77                              argon2_position_t position)
78  {
79      block *ref_block, *curr_block, *prev_block;
80      block address_block, input_block, zero_block;
81      uint64_t pseudo_rand, ref_index, ref_lane;
82      uint32_t prev_offset, curr_offset;
83      uint32_t starting_index, i;
84      int data_independent_addressing;
85      if (instance == NULL) {
86          return;
87      }
88      data_independent_addressing = (instance->type == Argon2_i) ||
89              (instance->type == Argon2_id && (position.pass == 0) &&
90               (position.slice < ARGON2_SYNC_POINTS / 2));
91      if (data_independent_addressing) {
92          init_block_value(&zero_block, 0);
93          init_block_value(&input_block, 0);
94          input_block.v[0] = position.pass;
95          input_block.v[1] = position.lane;
96          input_block.v[2] = position.slice;
97          input_block.v[3] = instance->memory_blocks;
98          input_block.v[4] = instance->passes;
99          input_block.v[5] = instance->type;
100      }
101      starting_index = 0;
102      if ((0 == position.pass) && (0 == position.slice)) {
103          starting_index = 2; &bsol;* we have already generated the first two blocks */
104          if (data_independent_addressing) {
105              next_addresses(&address_block, &input_block, &zero_block);
106          }
107      }
108      curr_offset = position.lane * instance->lane_length +
109                    position.slice * instance->segment_length + starting_index;
110      if (0 == curr_offset % instance->lane_length) {
111          prev_offset = curr_offset + instance->lane_length - 1;
112      } else {
113          prev_offset = curr_offset - 1;
114      }
115      for (i = starting_index; i < instance->segment_length;
116           ++i, ++curr_offset, ++prev_offset) {
117          if (curr_offset % instance->lane_length == 1) {
118              prev_offset = curr_offset - 1;
119          }
120          if (data_independent_addressing) {
121              if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {
122                  next_addresses(&address_block, &input_block, &zero_block);
123              }
124              pseudo_rand = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];
125          } else {
126              pseudo_rand = instance->memory[prev_offset].v[0];
127          }
128          ref_lane = ((pseudo_rand >> 32)) % instance->lanes;
129          if ((position.pass == 0) && (position.slice == 0)) {
130              ref_lane = position.lane;
131          }
132          position.index = i;
133          ref_index = xmrig_ar2_index_alpha(instance, &position, pseudo_rand & 0xFFFFFFFF, ref_lane == position.lane);
134          ref_block =
135              instance->memory + instance->lane_length * ref_lane + ref_index;
136          curr_block = instance->memory + curr_offset;
137          prev_block = instance->memory + prev_offset;
<span onclick='openModal()' class='match'>138          if (0 == position.pass || ARGON2_VERSION_10 == instance->version) {
139              fill_block(prev_block, ref_block, curr_block, 0);
140          } else {
141              fill_block(prev_block, ref_block, curr_block, 1);
142          }
143      }
144  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #ifdef HAVE_CONFIG_H
5  #include "webp/config.h"
6  #endif
7  #include "../examples/example_util.h"
8  #include "../imageio/image_dec.h"
9  #include "../imageio/imageio_util.h"
10  #include "./stopwatch.h"
11  #include "./unicode.h"
12  #include "webp/encode.h"
13  #ifndef WEBP_DLL
14  #ifdef __cplusplus
15  extern "C" {
16  #endif
17  extern void* VP8GetCPUInfo;   
18  #ifdef __cplusplus
19  }    
20  #endif
21  #endif  
22  static int verbose = 0;
23  static int ReadYUV(const uint8_t* const data, size_t data_size,
24                     WebPPicture* const pic) {
25    const int use_argb = pic->use_argb;
26    const int uv_width = (pic->width + 1) / 2;
27    const int uv_height = (pic->height + 1) / 2;
28    const int y_plane_size = pic->width * pic->height;
29    const int uv_plane_size = uv_width * uv_height;
30    const size_t expected_data_size = y_plane_size + 2 * uv_plane_size;
31    if (data_size != expected_data_size) {
32      fprintf(stderr,
33              "input data doesn't have the expected size (%d instead of %d)\n",
34              (int)data_size, (int)expected_data_size);
35      return 0;
36    }
37    pic->use_argb = 0;
38    if (!WebPPictureAlloc(pic)) return 0;
39    ImgIoUtilCopyPlane(data, pic->width, pic->y, pic->y_stride,
40                       pic->width, pic->height);
41    ImgIoUtilCopyPlane(data + y_plane_size, uv_width,
42                       pic->u, pic->uv_stride, uv_width, uv_height);
43    ImgIoUtilCopyPlane(data + y_plane_size + uv_plane_size, uv_width,
44                       pic->v, pic->uv_stride, uv_width, uv_height);
45    return use_argb ? WebPPictureYUVAToARGB(pic) : 1;
46  }
47  #ifdef HAVE_WINCODEC_H
48  static int ReadPicture(const char* const filename, WebPPicture* const pic,
49                         int keep_alpha, Metadata* const metadata) {
50    int ok = 0;
51    const uint8_t* data = NULL;
52    size_t data_size = 0;
53    if (pic->width != 0 && pic->height != 0) {
54      ok = ImgIoUtilReadFile(filename, &data, &data_size);
55      ok = ok && ReadYUV(data, data_size, pic);
56    } else {
57      ok = ReadPictureWithWIC(filename, pic, keep_alpha, metadata);
58      if (!ok) {
59        ok = ImgIoUtilReadFile(filename, &data, &data_size);
60        ok = ok && ReadWebP(data, data_size, pic, keep_alpha, metadata);
61      }
62    }
63    if (!ok) {
64      WFPRINTF(stderr, "Error! Could not process file %s\n",
65               (const W_CHAR*)filename);
66    }
67    free((void*)data);
68    return ok;
69  }
70  #else  
71  static int ReadPicture(const char* const filename, WebPPicture* const pic,
72                         int keep_alpha, Metadata* const metadata) {
73    const uint8_t* data = NULL;
74    size_t data_size = 0;
75    int ok = 0;
76    ok = ImgIoUtilReadFile(filename, &data, &data_size);
77    if (!ok) goto End;
78    if (pic->width == 0 || pic->height == 0) {
79      WebPImageReader reader = WebPGuessImageReader(data, data_size);
80      ok = reader(data, data_size, pic, keep_alpha, metadata);
81    } else {
82      ok = ReadYUV(data, data_size, pic);
83    }
84   End:
85    if (!ok) {
86      WFPRINTF(stderr, "Error! Could not process file %s\n",
87               (const W_CHAR*)filename);
88    }
89    free((void*)data);
90    return ok;
91  }
92  #endif  
93  static void AllocExtraInfo(WebPPicture* const pic) {
94    const int mb_w = (pic->width + 15) / 16;
95    const int mb_h = (pic->height + 15) / 16;
96    pic->extra_info =
97        (uint8_t*)WebPMalloc(mb_w * mb_h * sizeof(*pic->extra_info));
98  }
99  static void PrintByteCount(const int bytes[4], int total_size,
100                             int* const totals) {
101    int s;
102    int total = 0;
103    for (s = 0; s < 4; ++s) {
104      fprintf(stderr, "| %7d ", bytes[s]);
105      total += bytes[s];
106      if (totals) totals[s] += bytes[s];
107    }
108    fprintf(stderr, "| %7d  (%.1f%%)\n", total, 100.f * total / total_size);
109  }
110  static void PrintPercents(const int counts[4]) {
111    int s;
112    const int total = counts[0] + counts[1] + counts[2] + counts[3];
113    for (s = 0; s < 4; ++s) {
114      fprintf(stderr, "|      %2d%%", (int)(100. * counts[s] / total + .5));
115    }
116    fprintf(stderr, "| %7d\n", total);
117  }
118  static void PrintValues(const int values[4]) {
119    int s;
120    for (s = 0; s < 4; ++s) {
121      fprintf(stderr, "| %7d ", values[s]);
122    }
123    fprintf(stderr, "|\n");
124  }
125  static void PrintFullLosslessInfo(const WebPAuxStats* const stats,
126                                    const char* const description) {
127    fprintf(stderr, "Lossless-%s compressed size: %d bytes\n",
128            description, stats->lossless_size);
129    fprintf(stderr, "  * Header size: %d bytes, image data size: %d\n",
130            stats->lossless_hdr_size, stats->lossless_data_size);
131    if (stats->lossless_features) {
132      fprintf(stderr, "  * Lossless features used:");
133      if (stats->lossless_features & 1) fprintf(stderr, " PREDICTION");
134      if (stats->lossless_features & 2) fprintf(stderr, " CROSS-COLOR-TRANSFORM");
135      if (stats->lossless_features & 4) fprintf(stderr, " SUBTRACT-GREEN");
136      if (stats->lossless_features & 8) fprintf(stderr, " PALETTE");
137      fprintf(stderr, "\n");
138    }
139    fprintf(stderr, "  * Precision Bits: histogram=%d transform=%d cache=%d\n",
140            stats->histogram_bits, stats->transform_bits, stats->cache_bits);
141    if (stats->palette_size > 0) {
142      fprintf(stderr, "  * Palette size:   %d\n", stats->palette_size);
143    }
144  }
145  static void PrintExtraInfoLossless(const WebPPicture* const pic,
146                                     int short_output,
147                                     const char* const file_name) {
148    const WebPAuxStats* const stats = pic->stats;
149    if (short_output) {
150      fprintf(stderr, "%7d %2.2f\n", stats->coded_size, stats->PSNR[3]);
151    } else {
152      WFPRINTF(stderr, "File:      %s\n", (const W_CHAR*)file_name);
153      fprintf(stderr, "Dimension: %d x %d\n", pic->width, pic->height);
154      fprintf(stderr, "Output:    %d bytes (%.2f bpp)\n", stats->coded_size,
155              8.f * stats->coded_size / pic->width / pic->height);
156      PrintFullLosslessInfo(stats, "ARGB");
157    }
158  }
159  static void PrintExtraInfoLossy(const WebPPicture* const pic, int short_output,
160                                  int full_details,
161                                  const char* const file_name) {
162    const WebPAuxStats* const stats = pic->stats;
163    if (short_output) {
164      fprintf(stderr, "%7d %2.2f\n", stats->coded_size, stats->PSNR[3]);
165    } else {
166      const int num_i4 = stats->block_count[0];
167      const int num_i16 = stats->block_count[1];
168      const int num_skip = stats->block_count[2];
169      const int total = num_i4 + num_i16;
170      WFPRINTF(stderr, "File:      %s\n", (const W_CHAR*)file_name);
171      fprintf(stderr, "Dimension: %d x %d%s\n",
172              pic->width, pic->height,
173              stats->alpha_data_size ? " (with alpha)" : "");
174      fprintf(stderr, "Output:    "
175              "%d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n"
176              "           (%.2f bpp)\n",
177              stats->coded_size,
178              stats->PSNR[0], stats->PSNR[1], stats->PSNR[2], stats->PSNR[3],
179              8.f * stats->coded_size / pic->width / pic->height);
180      if (total > 0) {
181        int totals[4] = { 0, 0, 0, 0 };
182        fprintf(stderr, "block count:  intra4:     %6d  (%.2f%%)\n"
183                        "              intra16:    %6d  (%.2f%%)\n"
184                        "              skipped:    %6d  (%.2f%%)\n",
185                num_i4, 100.f * num_i4 / total,
186                num_i16, 100.f * num_i16 / total,
187                num_skip, 100.f * num_skip / total);
188        fprintf(stderr, "bytes used:  header:         %6d  (%.1f%%)\n"
189                        "             mode-partition: %6d  (%.1f%%)\n",
190                stats->header_bytes[0],
191                100.f * stats->header_bytes[0] / stats->coded_size,
192                stats->header_bytes[1],
193                100.f * stats->header_bytes[1] / stats->coded_size);
194        if (stats->alpha_data_size > 0) {
195          fprintf(stderr, "             transparency:   %6d (%.1f dB)\n",
196                  stats->alpha_data_size, stats->PSNR[4]);
197        }
198        fprintf(stderr, " Residuals bytes  "
199                        "|segment 1|segment 2|segment 3"
200                        "|segment 4|  total\n");
201        if (full_details) {
202          fprintf(stderr, "  intra4-coeffs:  ");
203          PrintByteCount(stats->residual_bytes[0], stats->coded_size, totals);
204          fprintf(stderr, " intra16-coeffs:  ");
205          PrintByteCount(stats->residual_bytes[1], stats->coded_size, totals);
206          fprintf(stderr, "  chroma coeffs:  ");
207          PrintByteCount(stats->residual_bytes[2], stats->coded_size, totals);
208        }
209        fprintf(stderr, "    macroblocks:  ");
210        PrintPercents(stats->segment_size);
211        fprintf(stderr, "      quantizer:  ");
212        PrintValues(stats->segment_quant);
213        fprintf(stderr, "   filter level:  ");
214        PrintValues(stats->segment_level);
215        if (full_details) {
216          fprintf(stderr, "------------------+---------");
217          fprintf(stderr, "+---------+---------+---------+-----------------\n");
218          fprintf(stderr, " segments total:  ");
219          PrintByteCount(totals, stats->coded_size, NULL);
220        }
221      }
222      if (stats->lossless_size > 0) {
223        PrintFullLosslessInfo(stats, "alpha");
224      }
225    }
226  }
227  static void PrintMapInfo(const WebPPicture* const pic) {
228    if (pic->extra_info != NULL) {
229      const int mb_w = (pic->width + 15) / 16;
230      const int mb_h = (pic->height + 15) / 16;
231      const int type = pic->extra_info_type;
232      int x, y;
233      for (y = 0; y < mb_h; ++y) {
234        for (x = 0; x < mb_w; ++x) {
235          const int c = pic->extra_info[x + y * mb_w];
236          if (type == 1) {   
237            fprintf(stderr, "%c", "+."[c]);
238          } else if (type == 2) {    
239            fprintf(stderr, "%c", ".-*X"[c]);
240          } else if (type == 3) {    
241            fprintf(stderr, "%.2d ", c);
<span onclick='openModal()' class='match'>242          } else if (type == 6 || type == 7) {
243            fprintf(stderr, "%3d ", c);
244          } else {
245            fprintf(stderr, "0x%.2x ", c);
246          }
247        }
248        fprintf(stderr, "\n");
249      }
</span>250    }
251  }
252  static int MyWriter(const uint8_t* data, size_t data_size,
253                      const WebPPicture* const pic) {
254    FILE* const out = (FILE*)pic->custom_ptr;
255    return data_size ? (fwrite(data, data_size, 1, out) == 1) : 1;
256  }
257  static int DumpPicture(const WebPPicture* const picture, const char* PGM_name) {
258    int y;
259    const int uv_width = (picture->width + 1) / 2;
260    const int uv_height = (picture->height + 1) / 2;
261    const int stride = (picture->width + 1) & ~1;
262    const uint8_t* src_y = picture->y;
263    const uint8_t* src_u = picture->u;
264    const uint8_t* src_v = picture->v;
265    const uint8_t* src_a = picture->a;
266    const int alpha_height =
267        WebPPictureHasTransparency(picture) ? picture->height : 0;
268    const int height = picture->height + uv_height + alpha_height;
269    FILE* const f = WFOPEN(PGM_name, "wb");
270    if (f == NULL) return 0;
271    fprintf(f, "P5\n%d %d\n255\n", stride, height);
272    for (y = 0; y < picture->height; ++y) {
273      if (fwrite(src_y, picture->width, 1, f) != 1) return 0;
274      if (picture->width & 1) fputc(0, f);  
275      src_y += picture->y_stride;
276    }
277    for (y = 0; y < uv_height; ++y) {
278      if (fwrite(src_u, uv_width, 1, f) != 1) return 0;
279      if (fwrite(src_v, uv_width, 1, f) != 1) return 0;
280      src_u += picture->uv_stride;
281      src_v += picture->uv_stride;
282    }
283    for (y = 0; y < alpha_height; ++y) {
284      if (fwrite(src_a, picture->width, 1, f) != 1) return 0;
285      if (picture->width & 1) fputc(0, f);  
286      src_a += picture->a_stride;
287    }
288    fclose(f);
289    return 1;
290  }
291  enum {
292    METADATA_EXIF = (1 << 0),
293    METADATA_ICC  = (1 << 1),
294    METADATA_XMP  = (1 << 2),
295    METADATA_ALL  = METADATA_EXIF | METADATA_ICC | METADATA_XMP
296  };
297  static const int kChunkHeaderSize = 8;
298  static const int kTagSize = 4;
299  static void PrintMetadataInfo(const Metadata* const metadata,
300                                int metadata_written) {
301    if (metadata == NULL || metadata_written == 0) return;
302    fprintf(stderr, "Metadata:\n");
303    if (metadata_written & METADATA_ICC) {
304      fprintf(stderr, "  * ICC profile:  %6d bytes\n", (int)metadata->iccp.size);
305    }
306    if (metadata_written & METADATA_EXIF) {
307      fprintf(stderr, "  * EXIF data:    %6d bytes\n", (int)metadata->exif.size);
308    }
309    if (metadata_written & METADATA_XMP) {
310      fprintf(stderr, "  * XMP data:     %6d bytes\n", (int)metadata->xmp.size);
311    }
312  }
313  static int WriteLE(FILE* const out, uint32_t val, int num) {
314    uint8_t buf[4];
315    int i;
316    for (i = 0; i < num; ++i) {
317      buf[i] = (uint8_t)(val & 0xff);
318      val >>= 8;
319    }
320    return (fwrite(buf, num, 1, out) == 1);
321  }
322  static int WriteLE24(FILE* const out, uint32_t val) {
323    return WriteLE(out, val, 3);
324  }
325  static int WriteLE32(FILE* const out, uint32_t val) {
326    return WriteLE(out, val, 4);
327  }
328  static int WriteMetadataChunk(FILE* const out, const char fourcc[4],
329                                const MetadataPayload* const payload) {
330    const uint8_t zero = 0;
331    const size_t need_padding = payload->size & 1;
332    int ok = (fwrite(fourcc, kTagSize, 1, out) == 1);
333    ok = ok && WriteLE32(out, (uint32_t)payload->size);
334    ok = ok && (fwrite(payload->bytes, payload->size, 1, out) == 1);
335    return ok && (fwrite(&zero, need_padding, need_padding, out) == need_padding);
336  }
337  static int UpdateFlagsAndSize(const MetadataPayload* const payload,
338                                int keep, int flag,
339                                uint32_t* vp8x_flags, uint64_t* metadata_size) {
340    if (keep && payload->bytes != NULL && payload->size > 0) {
341      *vp8x_flags |= flag;
342      *metadata_size += kChunkHeaderSize + payload->size + (payload->size & 1);
343      return 1;
344    }
345    return 0;
346  }
347  static int WriteWebPWithMetadata(FILE* const out,
348                                   const WebPPicture* const picture,
349                                   const WebPMemoryWriter* const memory_writer,
350                                   const Metadata* const metadata,
351                                   int keep_metadata,
352                                   int* const metadata_written) {
353    const char kVP8XHeader[] = "VP8X\x0a\x00\x00\x00";
354    const int kAlphaFlag = 0x10;
355    const int kEXIFFlag  = 0x08;
356    const int kICCPFlag  = 0x20;
357    const int kXMPFlag   = 0x04;
358    const size_t kRiffHeaderSize = 12;
359    const size_t kMaxChunkPayload = ~0 - kChunkHeaderSize - 1;
360    const size_t kMinSize = kRiffHeaderSize + kChunkHeaderSize;
361    uint32_t flags = 0;
362    uint64_t metadata_size = 0;
363    const int write_exif = UpdateFlagsAndSize(&metadata->exif,
364                                              !!(keep_metadata & METADATA_EXIF),
365                                              kEXIFFlag, &flags, &metadata_size);
366    const int write_iccp = UpdateFlagsAndSize(&metadata->iccp,
367                                              !!(keep_metadata & METADATA_ICC),
368                                              kICCPFlag, &flags, &metadata_size);
369    const int write_xmp  = UpdateFlagsAndSize(&metadata->xmp,
370                                              !!(keep_metadata & METADATA_XMP),
371                                              kXMPFlag, &flags, &metadata_size);
372    uint8_t* webp = memory_writer->mem;
373    size_t webp_size = memory_writer->size;
374    *metadata_written = 0;
375    if (webp_size < kMinSize) return 0;
376    if (webp_size - kChunkHeaderSize + metadata_size > kMaxChunkPayload) {
377      fprintf(stderr, "Error! Addition of metadata would exceed "
378                      "container size limit.\n");
379      return 0;
380    }
381    if (metadata_size > 0) {
382      const int kVP8XChunkSize = 18;
383      const int has_vp8x = !memcmp(webp + kRiffHeaderSize, "VP8X", kTagSize);
384      const uint32_t riff_size = (uint32_t)(webp_size - kChunkHeaderSize +
385                                            (has_vp8x ? 0 : kVP8XChunkSize) +
386                                            metadata_size);
387      int ok = (fwrite(webp, kTagSize, 1, out) == 1);
388      ok = ok && WriteLE32(out, riff_size);
389      webp += kChunkHeaderSize;
390      webp_size -= kChunkHeaderSize;
391      ok = ok && (fwrite(webp, kTagSize, 1, out) == 1);
392      webp += kTagSize;
393      webp_size -= kTagSize;
394      if (has_vp8x) {  
395        webp[kChunkHeaderSize] |= (uint8_t)(flags & 0xff);
396        ok = ok && (fwrite(webp, kVP8XChunkSize, 1, out) == 1);
397        webp += kVP8XChunkSize;
398        webp_size -= kVP8XChunkSize;
399      } else {
400        const int is_lossless = !memcmp(webp, "VP8L", kTagSize);
401        if (is_lossless) {
402          if (webp[kChunkHeaderSize + 4] & (1 << 4)) flags |= kAlphaFlag;
403        }
404        ok = ok && (fwrite(kVP8XHeader, kChunkHeaderSize, 1, out) == 1);
405        ok = ok && WriteLE32(out, flags);
406        ok = ok && WriteLE24(out, picture->width - 1);
407        ok = ok && WriteLE24(out, picture->height - 1);
408      }
409      if (write_iccp) {
410        ok = ok && WriteMetadataChunk(out, "ICCP", &metadata->iccp);
411        *metadata_written |= METADATA_ICC;
412      }
413      ok = ok && (fwrite(webp, webp_size, 1, out) == 1);
414      if (write_exif) {
415        ok = ok && WriteMetadataChunk(out, "EXIF", &metadata->exif);
416        *metadata_written |= METADATA_EXIF;
417      }
418      if (write_xmp) {
419        ok = ok && WriteMetadataChunk(out, "XMP ", &metadata->xmp);
420        *metadata_written |= METADATA_XMP;
421      }
422      return ok;
423    }
424    return (fwrite(webp, webp_size, 1, out) == 1);
425  }
426  static int ProgressReport(int percent, const WebPPicture* const picture) {
427    fprintf(stderr, "[%s]: %3d %%      \r",
428            (char*)picture->user_data, percent);
429    return 1;  
430  }
431  static void HelpShort(void) {
432    printf("Usage:\n\n");
433    printf("   cwebp [options] -q quality input.png -o output.webp\n\n");
434    printf("where quality is between 0 (poor) to 100 (very good).\n");
435    printf("Typical value is around 80.\n\n");
436    printf("Try -longhelp for an exhaustive list of advanced options.\n");
437  }
438  static void HelpLong(void) {
439    printf("Usage:\n");
440    printf(" cwebp [-preset <...>] [options] in_file [-o out_file]\n\n");
441    printf("If input size (-s) for an image is not specified, it is\n"
442           "assumed to be a PNG, JPEG, TIFF or WebP file.\n");
443  #ifdef HAVE_WINCODEC_H
444    printf("Windows builds can take as input any of the files handled by WIC.\n");
445  #endif
446    printf("\nOptions:\n");
447    printf("  -h / -help ............. short help\n");
448    printf("  -H / -longhelp ......... long help\n");
449    printf("  -q <float> ............. quality factor (0:small..100:big), "
450           "default=75\n");
451    printf("  -alpha_q <int> ......... transparency-compression quality (0..100),"
452           "\n                           default=100\n");
453    printf("  -preset <string> ....... preset setting, one of:\n");
454    printf("                            default, photo, picture,\n");
455    printf("                            drawing, icon, text\n");
456    printf("     -preset must come first, as it overwrites other parameters\n");
457    printf("  -z <int> ............... activates lossless preset with given\n"
458           "                           level in [0:fast, ..., 9:slowest]\n");
459    printf("\n");
460    printf("  -m <int> ............... compression method (0=fast, 6=slowest), "
461           "default=4\n");
462    printf("  -segments <int> ........ number of segments to use (1..4), "
463           "default=4\n");
464    printf("  -size <int> ............ target size (in bytes)\n");
465    printf("  -psnr <float> .......... target PSNR (in dB. typically: 42)\n");
466    printf("\n");
467    printf("  -s <int> <int> ......... input size (width x height) for YUV\n");
468    printf("  -sns <int> ............. spatial noise shaping (0:off, 100:max), "
469           "default=50\n");
470    printf("  -f <int> ............... filter strength (0=off..100), "
471           "default=60\n");
472    printf("  -sharpness <int> ....... "
473           "filter sharpness (0:most .. 7:least sharp), default=0\n");
474    printf("  -strong ................ use strong filter instead "
475                                       "of simple (default)\n");
476    printf("  -nostrong .............. use simple filter instead of strong\n");
477    printf("  -sharp_yuv ............. use sharper (and slower) RGB->YUV "
478                                       "conversion\n");
479    printf("  -partition_limit <int> . limit quality to fit the 512k limit on\n");
480    printf("                           "
481           "the first partition (0=no degradation ... 100=full)\n");
482    printf("  -pass <int> ............ analysis pass number (1..10)\n");
483    printf("  -crop <x> <y> <w> <h> .. crop picture with the given rectangle\n");
484    printf("  -resize <w> <h> ........ resize picture (after any cropping)\n");
485    printf("  -mt .................... use multi-threading if available\n");
486    printf("  -low_memory ............ reduce memory usage (slower encoding)\n");
487    printf("  -map <int> ............. print map of extra info\n");
488    printf("  -print_psnr ............ prints averaged PSNR distortion\n");
489    printf("  -print_ssim ............ prints averaged SSIM distortion\n");
490    printf("  -print_lsim ............ prints local-similarity distortion\n");
491    printf("  -d <file.pgm> .......... dump the compressed output (PGM file)\n");
492    printf("  -alpha_method <int> .... transparency-compression method (0..1), "
493           "default=1\n");
494    printf("  -alpha_filter <string> . predictive filtering for alpha plane,\n");
495    printf("                           one of: none, fast (default) or best\n");
496    printf("  -exact ................. preserve RGB values in transparent area, "
497           "default=off\n");
498    printf("  -blend_alpha <hex> ..... blend colors against background color\n"
499           "                           expressed as RGB values written in\n"
500           "                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n"
501           "                           green=0xe0 and blue=0xd0\n");
502    printf("  -noalpha ............... discard any transparency information\n");
503    printf("  -lossless .............. encode image losslessly, default=off\n");
504    printf("  -near_lossless <int> ... use near-lossless image\n"
505           "                           preprocessing (0..100=off), "
506           "default=100\n");
507    printf("  -hint <string> ......... specify image characteristics hint,\n");
508    printf("                           one of: photo, picture or graph\n");
509    printf("\n");
510    printf("  -metadata <string> ..... comma separated list of metadata to\n");
511    printf("                           ");
512    printf("copy from the input to the output if present.\n");
513    printf("                           "
514           "Valid values: all, none (default), exif, icc, xmp\n");
515    printf("\n");
516    printf("  -short ................. condense printed message\n");
517    printf("  -quiet ................. don't print anything\n");
518    printf("  -version ............... print version number and exit\n");
519  #ifndef WEBP_DLL
520    printf("  -noasm ................. disable all assembly optimizations\n");
521  #endif
522    printf("  -v ..................... verbose, e.g. print encoding/decoding "
523           "times\n");
524    printf("  -progress .............. report encoding progress\n");
525    printf("\n");
526    printf("Experimental Options:\n");
527    printf("  -jpeg_like ............. roughly match expected JPEG size\n");
528    printf("  -af .................... auto-adjust filter strength\n");
529    printf("  -pre <int> ............. pre-processing filter\n");
530    printf("\n");
531  }
532  static const char* const kErrorMessages[VP8_ENC_ERROR_LAST] = {
533    "OK",
534    "OUT_OF_MEMORY: Out of memory allocating objects",
535    "BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer",
536    "NULL_PARAMETER: NULL parameter passed to function",
537    "INVALID_CONFIGURATION: configuration is invalid",
538    "BAD_DIMENSION: Bad picture dimension. Maximum width and height "
539    "allowed is 16383 pixels.",
540    "PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\n"
541    "To reduce the size of this partition, try using less segments "
542    "with the -segments option, and eventually reduce the number of "
543    "header bits using -partition_limit. More details are available "
544    "in the manual (`man cwebp`)",
545    "PARTITION_OVERFLOW: Partition is too big to fit 16M",
546    "BAD_WRITE: Picture writer returned an I/O error",
547    "FILE_TOO_BIG: File would be too big to fit in 4G",
548    "USER_ABORT: encoding abort requested by user"
549  };
550  int main(int argc, const char* argv[]) {
551    int return_value = -1;
552    const char* in_file = NULL, *out_file = NULL, *dump_file = NULL;
553    FILE* out = NULL;
554    int c;
555    int short_output = 0;
556    int quiet = 0;
557    int keep_alpha = 1;
558    int blend_alpha = 0;
559    uint32_t background_color = 0xffffffu;
560    int crop = 0, crop_x = 0, crop_y = 0, crop_w = 0, crop_h = 0;
561    int resize_w = 0, resize_h = 0;
562    int lossless_preset = 6;
563    int use_lossless_preset = -1;  
564    int show_progress = 0;
565    int keep_metadata = 0;
566    int metadata_written = 0;
567    WebPPicture picture;
568    int print_distortion = -1;        
569    WebPPicture original_picture;    
570    WebPConfig config;
571    WebPAuxStats stats;
572    WebPMemoryWriter memory_writer;
573    Metadata metadata;
574    Stopwatch stop_watch;
575    INIT_WARGV(argc, argv);
576    MetadataInit(&metadata);
577    WebPMemoryWriterInit(&memory_writer);
578    if (!WebPPictureInit(&picture) ||
579        !WebPPictureInit(&original_picture) ||
580        !WebPConfigInit(&config)) {
581      fprintf(stderr, "Error! Version mismatch!\n");
582      FREE_WARGV_AND_RETURN(-1);
583    }
584    if (argc == 1) {
585      HelpShort();
586      FREE_WARGV_AND_RETURN(0);
587    }
588    for (c = 1; c < argc; ++c) {
589      int parse_error = 0;
590      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
591        HelpShort();
592        FREE_WARGV_AND_RETURN(0);
593      } else if (!strcmp(argv[c], "-H") || !strcmp(argv[c], "-longhelp")) {
594        HelpLong();
595        FREE_WARGV_AND_RETURN(0);
596      } else if (!strcmp(argv[c], "-o") && c < argc - 1) {
597        out_file = (const char*)GET_WARGV(argv, ++c);
598      } else if (!strcmp(argv[c], "-d") && c < argc - 1) {
599        dump_file = (const char*)GET_WARGV(argv, ++c);
600        config.show_compressed = 1;
601      } else if (!strcmp(argv[c], "-print_psnr")) {
602        config.show_compressed = 1;
603        print_distortion = 0;
604      } else if (!strcmp(argv[c], "-print_ssim")) {
605        config.show_compressed = 1;
606        print_distortion = 1;
607      } else if (!strcmp(argv[c], "-print_lsim")) {
608        config.show_compressed = 1;
609        print_distortion = 2;
610      } else if (!strcmp(argv[c], "-short")) {
611        ++short_output;
612      } else if (!strcmp(argv[c], "-s") && c < argc - 2) {
613        picture.width = ExUtilGetInt(argv[++c], 0, &parse_error);
614        picture.height = ExUtilGetInt(argv[++c], 0, &parse_error);
615        if (picture.width > WEBP_MAX_DIMENSION || picture.width < 0 ||
616            picture.height > WEBP_MAX_DIMENSION ||  picture.height < 0) {
617          fprintf(stderr,
618                  "Specified dimension (%d x %d) is out of range.\n",
619                  picture.width, picture.height);
620          goto Error;
621        }
622      } else if (!strcmp(argv[c], "-m") && c < argc - 1) {
623        config.method = ExUtilGetInt(argv[++c], 0, &parse_error);
624        use_lossless_preset = 0;   
625      } else if (!strcmp(argv[c], "-q") && c < argc - 1) {
626        config.quality = ExUtilGetFloat(argv[++c], &parse_error);
627        use_lossless_preset = 0;   
628      } else if (!strcmp(argv[c], "-z") && c < argc - 1) {
629        lossless_preset = ExUtilGetInt(argv[++c], 0, &parse_error);
630        if (use_lossless_preset != 0) use_lossless_preset = 1;
631      } else if (!strcmp(argv[c], "-alpha_q") && c < argc - 1) {
632        config.alpha_quality = ExUtilGetInt(argv[++c], 0, &parse_error);
633      } else if (!strcmp(argv[c], "-alpha_method") && c < argc - 1) {
634        config.alpha_compression = ExUtilGetInt(argv[++c], 0, &parse_error);
635      } else if (!strcmp(argv[c], "-alpha_cleanup")) {
636        config.exact = 0;
637      } else if (!strcmp(argv[c], "-exact")) {
638        config.exact = 1;
639      } else if (!strcmp(argv[c], "-blend_alpha") && c < argc - 1) {
640        blend_alpha = 1;
641        background_color = ExUtilGetInt(argv[++c], 16, &parse_error);
642        background_color = background_color & 0x00ffffffu;
643      } else if (!strcmp(argv[c], "-alpha_filter") && c < argc - 1) {
644        ++c;
645        if (!strcmp(argv[c], "none")) {
646          config.alpha_filtering = 0;
647        } else if (!strcmp(argv[c], "fast")) {
648          config.alpha_filtering = 1;
649        } else if (!strcmp(argv[c], "best")) {
650          config.alpha_filtering = 2;
651        } else {
652          fprintf(stderr, "Error! Unrecognized alpha filter: %s\n", argv[c]);
653          goto Error;
654        }
655      } else if (!strcmp(argv[c], "-noalpha")) {
656        keep_alpha = 0;
657      } else if (!strcmp(argv[c], "-lossless")) {
658        config.lossless = 1;
659      } else if (!strcmp(argv[c], "-near_lossless") && c < argc - 1) {
660        config.near_lossless = ExUtilGetInt(argv[++c], 0, &parse_error);
661        config.lossless = 1;  
662      } else if (!strcmp(argv[c], "-hint") && c < argc - 1) {
663        ++c;
664        if (!strcmp(argv[c], "photo")) {
665          config.image_hint = WEBP_HINT_PHOTO;
666        } else if (!strcmp(argv[c], "picture")) {
667          config.image_hint = WEBP_HINT_PICTURE;
668        } else if (!strcmp(argv[c], "graph")) {
669          config.image_hint = WEBP_HINT_GRAPH;
670        } else {
671          fprintf(stderr, "Error! Unrecognized image hint: %s\n", argv[c]);
672          goto Error;
673        }
674      } else if (!strcmp(argv[c], "-size") && c < argc - 1) {
675        config.target_size = ExUtilGetInt(argv[++c], 0, &parse_error);
676      } else if (!strcmp(argv[c], "-psnr") && c < argc - 1) {
677        config.target_PSNR = ExUtilGetFloat(argv[++c], &parse_error);
678      } else if (!strcmp(argv[c], "-sns") && c < argc - 1) {
679        config.sns_strength = ExUtilGetInt(argv[++c], 0, &parse_error);
680      } else if (!strcmp(argv[c], "-f") && c < argc - 1) {
681        config.filter_strength = ExUtilGetInt(argv[++c], 0, &parse_error);
682      } else if (!strcmp(argv[c], "-af")) {
683        config.autofilter = 1;
684      } else if (!strcmp(argv[c], "-jpeg_like")) {
685        config.emulate_jpeg_size = 1;
686      } else if (!strcmp(argv[c], "-mt")) {
687        ++config.thread_level;  
688      } else if (!strcmp(argv[c], "-low_memory")) {
689        config.low_memory = 1;
690      } else if (!strcmp(argv[c], "-strong")) {
691        config.filter_type = 1;
692      } else if (!strcmp(argv[c], "-nostrong")) {
693        config.filter_type = 0;
694      } else if (!strcmp(argv[c], "-sharpness") && c < argc - 1) {
695        config.filter_sharpness = ExUtilGetInt(argv[++c], 0, &parse_error);
696      } else if (!strcmp(argv[c], "-sharp_yuv")) {
697        config.use_sharp_yuv = 1;
698      } else if (!strcmp(argv[c], "-pass") && c < argc - 1) {
699        config.pass = ExUtilGetInt(argv[++c], 0, &parse_error);
700      } else if (!strcmp(argv[c], "-pre") && c < argc - 1) {
701        config.preprocessing = ExUtilGetInt(argv[++c], 0, &parse_error);
702      } else if (!strcmp(argv[c], "-segments") && c < argc - 1) {
703        config.segments = ExUtilGetInt(argv[++c], 0, &parse_error);
704      } else if (!strcmp(argv[c], "-partition_limit") && c < argc - 1) {
705        config.partition_limit = ExUtilGetInt(argv[++c], 0, &parse_error);
706      } else if (!strcmp(argv[c], "-map") && c < argc - 1) {
707        picture.extra_info_type = ExUtilGetInt(argv[++c], 0, &parse_error);
708      } else if (!strcmp(argv[c], "-crop") && c < argc - 4) {
709        crop = 1;
710        crop_x = ExUtilGetInt(argv[++c], 0, &parse_error);
711        crop_y = ExUtilGetInt(argv[++c], 0, &parse_error);
712        crop_w = ExUtilGetInt(argv[++c], 0, &parse_error);
713        crop_h = ExUtilGetInt(argv[++c], 0, &parse_error);
714      } else if (!strcmp(argv[c], "-resize") && c < argc - 2) {
715        resize_w = ExUtilGetInt(argv[++c], 0, &parse_error);
716        resize_h = ExUtilGetInt(argv[++c], 0, &parse_error);
717  #ifndef WEBP_DLL
718      } else if (!strcmp(argv[c], "-noasm")) {
719        VP8GetCPUInfo = NULL;
720  #endif
721      } else if (!strcmp(argv[c], "-version")) {
722        const int version = WebPGetEncoderVersion();
723        printf("%d.%d.%d\n",
724               (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
725        FREE_WARGV_AND_RETURN(0);
726      } else if (!strcmp(argv[c], "-progress")) {
727        show_progress = 1;
728      } else if (!strcmp(argv[c], "-quiet")) {
729        quiet = 1;
730      } else if (!strcmp(argv[c], "-preset") && c < argc - 1) {
731        WebPPreset preset;
732        ++c;
733        if (!strcmp(argv[c], "default")) {
734          preset = WEBP_PRESET_DEFAULT;
735        } else if (!strcmp(argv[c], "photo")) {
736          preset = WEBP_PRESET_PHOTO;
737        } else if (!strcmp(argv[c], "picture")) {
738          preset = WEBP_PRESET_PICTURE;
739        } else if (!strcmp(argv[c], "drawing")) {
740          preset = WEBP_PRESET_DRAWING;
741        } else if (!strcmp(argv[c], "icon")) {
742          preset = WEBP_PRESET_ICON;
743        } else if (!strcmp(argv[c], "text")) {
744          preset = WEBP_PRESET_TEXT;
745        } else {
746          fprintf(stderr, "Error! Unrecognized preset: %s\n", argv[c]);
747          goto Error;
748        }
749        if (!WebPConfigPreset(&config, preset, config.quality)) {
750          fprintf(stderr, "Error! Could initialize configuration with preset.\n");
751          goto Error;
752        }
753      } else if (!strcmp(argv[c], "-metadata") && c < argc - 1) {
754        static const struct {
755          const char* option;
756          int flag;
757        } kTokens[] = {
758          { "all",  METADATA_ALL },
759          { "none", 0 },
760          { "exif", METADATA_EXIF },
761          { "icc",  METADATA_ICC },
762          { "xmp",  METADATA_XMP },
763        };
764        const size_t kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
765        const char* start = argv[++c];
766        const char* const end = start + strlen(start);
767        while (start < end) {
768          size_t i;
769          const char* token = strchr(start, ',');
770          if (token == NULL) token = end;
771          for (i = 0; i < kNumTokens; ++i) {
772            if ((size_t)(token - start) == strlen(kTokens[i].option) &&
773                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
774              if (kTokens[i].flag != 0) {
775                keep_metadata |= kTokens[i].flag;
776              } else {
777                keep_metadata = 0;
778              }
779              break;
780            }
781          }
782          if (i == kNumTokens) {
783            fprintf(stderr, "Error! Unknown metadata type '%.*s'\n",
784                    (int)(token - start), start);
785            FREE_WARGV_AND_RETURN(-1);
786          }
787          start = token + 1;
788        }
789  #ifdef HAVE_WINCODEC_H
790        if (keep_metadata != 0 && keep_metadata != METADATA_ICC) {
791          fprintf(stderr, "Warning: only ICC profile extraction is currently"
792                          " supported on this platform!\n");
793        }
794  #endif
795      } else if (!strcmp(argv[c], "-v")) {
796        verbose = 1;
797      } else if (!strcmp(argv[c], "--")) {
798        if (c < argc - 1) in_file = (const char*)GET_WARGV(argv, ++c);
799        break;
800      } else if (argv[c][0] == '-') {
801        fprintf(stderr, "Error! Unknown option '%s'\n", argv[c]);
802        HelpLong();
803        FREE_WARGV_AND_RETURN(-1);
804      } else {
805        in_file = (const char*)GET_WARGV(argv, c);
806      }
807      if (parse_error) {
808        HelpLong();
809        FREE_WARGV_AND_RETURN(-1);
810      }
811    }
812    if (in_file == NULL) {
813      fprintf(stderr, "No input file specified!\n");
814      HelpShort();
815      goto Error;
816    }
817    if (use_lossless_preset == 1) {
818      if (!WebPConfigLosslessPreset(&config, lossless_preset)) {
819        fprintf(stderr, "Invalid lossless preset (-z %d)\n", lossless_preset);
820        goto Error;
821      }
822    }
823    if (!quiet && config.lossless == 1) {
824      if (config.target_size > 0 || config.target_PSNR > 0) {
825        fprintf(stderr, "Encoding for specified size or PSNR is not supported"
826                        " for lossless encoding. Ignoring such option(s)!\n");
827      }
828      if (config.partition_limit > 0) {
829        fprintf(stderr, "Partition limit option is not required for lossless"
830                        " encoding. Ignoring this option!\n");
831      }
832    }
833    if (config.target_size > 0 || config.target_PSNR > 0) {
834      if (config.pass == 1) config.pass = 6;
835    }
836    if (!WebPValidateConfig(&config)) {
837      fprintf(stderr, "Error! Invalid configuration.\n");
838      goto Error;
839    }
840    picture.use_argb = (config.lossless || config.use_sharp_yuv ||
841                        config.preprocessing > 0 ||
842                        crop || (resize_w | resize_h) > 0);
843    if (verbose) {
844      StopwatchReset(&stop_watch);
845    }
846    if (!ReadPicture(in_file, &picture, keep_alpha,
847                     (keep_metadata == 0) ? NULL : &metadata)) {
848      WFPRINTF(stderr, "Error! Cannot read input picture file '%s'\n",
849               (const W_CHAR*)in_file);
850      goto Error;
851    }
852    picture.progress_hook = (show_progress && !quiet) ? ProgressReport : NULL;
853    if (blend_alpha) {
854      WebPBlendAlpha(&picture, background_color);
855    }
856    if (verbose) {
857      const double read_time = StopwatchReadAndReset(&stop_watch);
858      fprintf(stderr, "Time to read input: %.3fs\n", read_time);
859    }
860    if (out_file != NULL) {
861      const int use_stdout = !WSTRCMP(out_file, "-");
862      out = use_stdout ? ImgIoUtilSetBinaryMode(stdout) : WFOPEN(out_file, "wb");
863      if (out == NULL) {
864        WFPRINTF(stderr, "Error! Cannot open output file '%s'\n",
865                 (const W_CHAR*)out_file);
866        goto Error;
867      } else {
868        if (!short_output && !quiet) {
869          WFPRINTF(stderr, "Saving file '%s'\n", (const W_CHAR*)out_file);
870        }
871      }
872      if (keep_metadata == 0) {
873        picture.writer = MyWriter;
874        picture.custom_ptr = (void*)out;
875      } else {
876        picture.writer = WebPMemoryWrite;
877        picture.custom_ptr = (void*)&memory_writer;
878      }
879    } else {
880      out = NULL;
881      if (!quiet && !short_output) {
882        fprintf(stderr, "No output file specified (no -o flag). Encoding will\n");
883        fprintf(stderr, "be performed, but its results discarded.\n\n");
884      }
885    }
886    if (!quiet) {
887      picture.stats = &stats;
888      picture.user_data = (void*)in_file;
889    }
890    if (verbose) {
891      StopwatchReset(&stop_watch);
892    }
893    if (crop != 0) {
894      if (!WebPPictureView(&picture, crop_x, crop_y, crop_w, crop_h, &picture)) {
895        fprintf(stderr, "Error! Cannot crop picture\n");
896        goto Error;
897      }
898    }
899    if ((resize_w | resize_h) > 0) {
900      WebPPicture picture_no_alpha;
901      if (config.exact) {
902        if (!WebPPictureCopy(&picture, &picture_no_alpha)) {
903          fprintf(stderr, "Error! Cannot copy temporary picture\n");
904          goto Error;
905        }
906        {
907          int x, y;
908          uint32_t* argb_no_alpha = picture_no_alpha.argb;
909          for (y = 0; y < picture_no_alpha.height; ++y) {
910            for (x = 0; x < picture_no_alpha.width; ++x) {
911              argb_no_alpha[x] |= 0xff000000;  
912            }
913            argb_no_alpha += picture_no_alpha.argb_stride;
914          }
915        }
916        if (!WebPPictureRescale(&picture_no_alpha, resize_w, resize_h)) {
917          fprintf(stderr, "Error! Cannot resize temporary picture\n");
918          goto Error;
919        }
920      }
921      if (!WebPPictureRescale(&picture, resize_w, resize_h)) {
922        fprintf(stderr, "Error! Cannot resize picture\n");
923        goto Error;
924      }
925      if (config.exact) {  
926        int x, y;
927        uint32_t* argb_no_alpha = picture_no_alpha.argb;
928        uint32_t* argb = picture.argb;
929        for (y = 0; y < picture_no_alpha.height; ++y) {
930          for (x = 0; x < picture_no_alpha.width; ++x) {
931            argb[x] = (argb[x] & 0xff000000) | (argb_no_alpha[x] & 0x00ffffff);
932          }
933          argb_no_alpha += picture_no_alpha.argb_stride;
934          argb += picture.argb_stride;
935        }
936        WebPPictureFree(&picture_no_alpha);
937      }
938    }
939    if (verbose && (crop != 0 || (resize_w | resize_h) > 0)) {
940      const double preproc_time = StopwatchReadAndReset(&stop_watch);
941      fprintf(stderr, "Time to crop/resize picture: %.3fs\n", preproc_time);
942    }
943    if (picture.extra_info_type > 0) {
944      AllocExtraInfo(&picture);
945    }
946    if (print_distortion >= 0) {  
947      WebPPictureCopy(&picture, &original_picture);
948    }
949    if (verbose) {
950      StopwatchReset(&stop_watch);
951    }
952    if (!WebPEncode(&config, &picture)) {
953      fprintf(stderr, "Error! Cannot encode picture as WebP\n");
954      fprintf(stderr, "Error code: %d (%s)\n",
955              picture.error_code, kErrorMessages[picture.error_code]);
956      goto Error;
957    }
958    if (verbose) {
959      const double encode_time = StopwatchReadAndReset(&stop_watch);
960      fprintf(stderr, "Time to encode picture: %.3fs\n", encode_time);
961    }
962    if (dump_file) {
963      if (picture.use_argb) {
964        fprintf(stderr, "Warning: can't dump file (-d option) "
965                        "in lossless mode.\n");
966      } else if (!DumpPicture(&picture, dump_file)) {
967        WFPRINTF(stderr, "Warning, couldn't dump picture %s\n",
968                 (const W_CHAR*)dump_file);
969      }
970    }
971    if (keep_metadata != 0) {
972      if (out != NULL) {
973        if (!WriteWebPWithMetadata(out, &picture, &memory_writer,
974                                   &metadata, keep_metadata, &metadata_written)) {
975          fprintf(stderr, "Error writing WebP file with metadata!\n");
976          goto Error;
977        }
978      } else {  
979        const struct {
980          const MetadataPayload* const payload;
981          int flag;
982        } *iter, info[] = {
983          { &metadata.exif, METADATA_EXIF },
984          { &metadata.iccp, METADATA_ICC },
985          { &metadata.xmp, METADATA_XMP },
986          { NULL, 0 }
987        };
988        uint32_t unused1 = 0;
989        uint64_t unused2 = 0;
990        for (iter = info; iter->payload != NULL; ++iter) {
991          if (UpdateFlagsAndSize(iter->payload, !!(keep_metadata & iter->flag),
992                                 0, &unused1, &unused2)) {
993            metadata_written |= iter->flag;
994          }
995        }
996      }
997    }
998    if (!quiet) {
999      if (!short_output || print_distortion < 0) {
1000        if (config.lossless) {
1001          PrintExtraInfoLossless(&picture, short_output, in_file);
1002        } else {
1003          PrintExtraInfoLossy(&picture, short_output, config.low_memory, in_file);
1004        }
1005      }
1006      if (!short_output && picture.extra_info_type > 0) {
1007        PrintMapInfo(&picture);
1008      }
1009      if (print_distortion >= 0) {    
1010        static const char* distortion_names[] = { "PSNR", "SSIM", "LSIM" };
1011        float values[5];
1012        if (!WebPPictureDistortion(&picture, &original_picture,
1013                                   print_distortion, values)) {
1014          fprintf(stderr, "Error while computing the distortion.\n");
1015          goto Error;
1016        }
1017        if (!short_output) {
1018          fprintf(stderr, "%s: ", distortion_names[print_distortion]);
1019          fprintf(stderr, "B:%.2f G:%.2f R:%.2f A:%.2f  Total:%.2f\n",
1020                  values[0], values[1], values[2], values[3], values[4]);
1021        } else {
1022          fprintf(stderr, "%7d %.4f\n", picture.stats->coded_size, values[4]);
1023        }
1024      }
1025      if (!short_output) {
1026        PrintMetadataInfo(&metadata, metadata_written);
1027      }
1028    }
1029    return_value = 0;
1030   Error:
1031    WebPMemoryWriterClear(&memory_writer);
1032    WebPFree(picture.extra_info);
1033    MetadataFree(&metadata);
1034    WebPPictureFree(&picture);
1035    WebPPictureFree(&original_picture);
1036    if (out != NULL && out != stdout) {
1037      fclose(out);
1038    }
1039    FREE_WARGV_AND_RETURN(return_value);
1040  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-template-64.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</div>
                <div class="column column_space"><pre><code>138          if (0 == position.pass || ARGON2_VERSION_10 == instance->version) {
139              fill_block(prev_block, ref_block, curr_block, 0);
140          } else {
141              fill_block(prev_block, ref_block, curr_block, 1);
142          }
143      }
144  }
</pre></code></div>
                <div class="column column_space"><pre><code>242          } else if (type == 6 || type == 7) {
243            fprintf(stderr, "%3d ", c);
244          } else {
245            fprintf(stderr, "0x%.2x ", c);
246          }
247        }
248        fprintf(stderr, "\n");
249      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    