<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-remote-delete-operation.c &amp; inf-name-resolver.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-remote-delete-operation.c &amp; inf-name-resolver.c
      </h3>
<h1 align="center">
        11.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-remote-delete-operation.c (17.816092%)<th>inf-name-resolver.c (8.378378%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(249-276)<td><a href="#" name="0">(1025-1052)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(675-723)<td><a href="#" name="1">(797-828)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(215-245)<td><a href="#" name="2">(969-1003)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(36-62)<td><a href="#" name="3">(84-118)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-remote-delete-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-split-operation.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextRemoteDeleteOperationRecon
  InfTextRemoteDeleteOperationRecon;
struct _InfTextRemoteDeleteOperationRecon {
  guint position;
  InfTextChunk* chunk;
};
typedef struct _InfTextRemoteDeleteOperationPrivate
  InfTextRemoteDeleteOperationPrivate;
struct _InfTextRemoteDeleteOperationPrivate {
  guint position;
  guint length;
  GSList* recon;
  guint recon_offset;
};
enum {
  PROP_0,
  PROP_POSITION,
  PROP_LENGTH
};</b></font>
#define INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_REMOTE_DELETE_OPERATION, InfTextRemoteDeleteOperationPrivate))
static void inf_text_remote_delete_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
static void inf_text_remote_delete_operation_delete_operation_iface_init(InfTextDeleteOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextRemoteDeleteOperation, inf_text_remote_delete_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextRemoteDeleteOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_remote_delete_operation_operation_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_DELETE_OPERATION, inf_text_remote_delete_operation_delete_operation_iface_init))
static GSList*
g_slist_append_fast(GSList* list,
                    GSList** last,
                    gpointer item)
{
  GSList* temp;
  g_assert(last != NULL);
  if(list == NULL)
  {
    list = g_slist_prepend(list, item);
    *last = list;
  }
  else
  {
    g_assert(*last != NULL);
    temp = g_slist_append(*last, item);
    *last = (*last)-&gt;next;
  }
  return list;
}
static GSList*
inf_text_remote_delete_operation_recon_copy(GSList* recon_list)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;
  GSList* new_list;
  GSList* last;
  InfTextRemoteDeleteOperationRecon* new_recon;
  new_list = NULL;
  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = recon-&gt;position;
    new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }
  return new_list;
}
static void
inf_text_remote_delete_operation_recon_free(GSList* recon_list)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;
  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    inf_text_chunk_free(recon-&gt;chunk);
    g_slice_free(InfTextRemoteDeleteOperationRecon, recon);
  }
  g_slist_free(recon_list);
}
static GSList*
inf_text_remote_delete_operation_recon_feed(GSList* recon_list,
                                            guint position,
                                            InfTextChunk* chunk)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;
  GSList* new_list;
  GSList* last;
  InfTextRemoteDeleteOperationRecon* new_recon;
  guint text_pos;
  guint cur_len;
  guint text_len;
  new_list = NULL;
  text_pos = 0;
  cur_len = 0;
  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    if(position + text_pos + cur_len &lt; recon-&gt;position &amp;&amp;
       text_pos &lt; inf_text_chunk_get_length(chunk))
    {
      text_len = recon-&gt;position - position - text_pos - cur_len;
      if(text_len &gt; inf_text_chunk_get_length(chunk) - text_pos)
        text_len = inf_text_chunk_get_length(chunk) - text_pos;
      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = position + text_pos + cur_len;
      new_recon-&gt;chunk = inf_text_chunk_substring(chunk, text_pos, text_len);
      new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
      text_pos += text_len;
    }
    cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = recon-&gt;position;
    new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }
  if(text_pos &lt; inf_text_chunk_get_length(chunk))
  {
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = position + text_pos + cur_len;
    new_recon-&gt;chunk = inf_text_chunk_substring(
      chunk,
      text_pos,
      inf_text_chunk_get_length(chunk) - text_pos
    );
    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }
  return new_list;
}
static void
inf_text_remote_delete_operation_init(InfTextRemoteDeleteOperation* operation)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  priv-&gt;position = 0;
  priv-&gt;length = 0;
<a name="2"></a>
  priv-&gt;recon = NULL;
  priv-&gt;recon_offset = 0;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
inf_text_remote_delete_operation_finalize(GObject* object)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;
  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  inf_text_remote_delete_operation_recon_free(priv-&gt;recon);
  G_OBJECT_CLASS(inf_text_remote_delete_operation_parent_class)-&gt;finalize(object);
}
static void
inf_text_remote_delete_operation_set_property(GObject* object,
                                              guint prop_id,
                                              const GValue* value,
                                              GParamSpec* pspec)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;
  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  switch(prop_id)
  {
  case PROP_POSITION:</b></font>
<a name="0"></a>    priv-&gt;position = g_value_get_uint(value);
    break;
  case PROP_LENGTH:
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;length = g_value_get_uint(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_remote_delete_operation_get_property(GObject* object,
                                              guint prop_id,
                                              GValue* value,
                                              GParamSpec* pspec)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;
  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_LENGTH:
    g_value_set_uint(value, priv-&gt;length);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static gboolean
inf_text_remote_delete_operation_need_concurrency_id(
  InfAdoptedOperation* operation,
  InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
  return inf_text_delete_operation_need_concurrency_id(
    INF_TEXT_DELETE_OPERATION(operation),
    against
  );
}
static InfAdoptedOperation*
inf_text_remote_delete_operation_transform(InfAdoptedOperation* operation,
                                           InfAdoptedOperation* against,
                                           InfAdoptedOperation* operation_lcs,
                                           InfAdoptedOperation* against_lcs,
                                           InfAdoptedConcurrencyId cid)
{
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    return inf_text_delete_operation_transform_insert(
      INF_TEXT_DELETE_OPERATION(operation),
      INF_TEXT_INSERT_OPERATION(against)
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    return inf_text_delete_operation_transform_delete(
      INF_TEXT_DELETE_OPERATION(operation),
      INF_TEXT_DELETE_OPERATION(against)
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }
}
static InfAdoptedOperation*
inf_text_remote_delete_operation_copy(InfAdoptedOperation* operation)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", priv-&gt;position,
    "length", priv-&gt;length,
    NULL
  );
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
    priv-&gt;recon
  );
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_ADOPTED_OPERATION(result);
}
static InfAdoptedOperationFlags
inf_text_remote_delete_operation_get_flags(InfAdoptedOperation* operation)
{
  return INF_ADOPTED_OPERATION_AFFECTS_BUFFER;
}
static gboolean
inf_text_remote_delete_operation_apply(InfAdoptedOperation* operation,
                                       InfAdoptedUser* by,
                                       InfBuffer* buffer,
                                       GError** error)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
  g_assert(INF_TEXT_IS_BUFFER(buffer));
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  if(priv-&gt;position + priv-&gt;length &gt;
     inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
      INF_TEXT_OPERATION_ERROR_INVALID_DELETE,
      _("Attempt to remove text from after the end of the document")
    );
    return FALSE;
  }
  else
  {
    inf_text_buffer_erase_text(
      INF_TEXT_BUFFER(buffer),
      priv-&gt;position,
      priv-&gt;length,
      INF_USER(by)
    );
    return TRUE;
  }
}
static InfAdoptedOperation*
inf_text_remote_delete_operation_apply_transformed(InfAdoptedOperation* op,
                                                   InfAdoptedOperation* trans,
                                                   InfAdoptedUser* by,
                                                   InfBuffer* buffer,
                                                   GError** error)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  InfTextChunk* chunk;
  InfTextChunk* temp_slice;
  GSList* list;
  GSList* item;
  InfAdoptedOperation* operation;
  GSList* recon_list;
  GSList* recon_item;
  InfTextRemoteDeleteOperationRecon* recon;
  InfTextDefaultDeleteOperation* result;
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(op));
  g_assert(INF_TEXT_IS_BUFFER(buffer));
  if(INF_ADOPTED_IS_SPLIT_OPERATION(trans))
  {
    list = inf_adopted_split_operation_unsplit(
      INF_ADOPTED_SPLIT_OPERATION(trans)
    );
  }
  else
  {
    list = g_slist_prepend(NULL, trans);
  }
  chunk = inf_text_chunk_new(
    inf_text_buffer_get_encoding(INF_TEXT_BUFFER(buffer))
  );
  for(item = list; item != NULL; item = g_slist_next(item))
  {
    g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(item-&gt;data));
    priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(item-&gt;data);
    operation = INF_ADOPTED_OPERATION(item-&gt;data);
    if(priv-&gt;length &gt; 0)
    {
      temp_slice = inf_text_buffer_get_slice(
        INF_TEXT_BUFFER(buffer),
        priv-&gt;position,
        priv-&gt;length
      );
      recon_list = inf_text_remote_delete_operation_recon_feed(
        priv-&gt;recon,
        0,
        temp_slice
      );
      inf_text_chunk_free(temp_slice);
    }
    else
    {
      recon_list = priv-&gt;recon;
    }
    for(recon_item = recon_list;
        recon_item != NULL;
        recon_item = g_slist_next(recon_item))
    {
      recon = (InfTextRemoteDeleteOperationRecon*)recon_item-&gt;data;
      g_assert(priv-&gt;recon_offset + recon-&gt;position ==
               inf_text_chunk_get_length(chunk));
      inf_text_chunk_insert_chunk(
        chunk,
        inf_text_chunk_get_length(chunk),
        recon-&gt;chunk
      );
    }
    if(priv-&gt;length &gt; 0)
      inf_text_remote_delete_operation_recon_free(recon_list);
    if(!inf_adopted_operation_apply(operation, by, buffer, error))
    {
      g_slist_free(list);
      inf_text_chunk_free(chunk);
      return NULL;
    }
  }
  g_slist_free(list);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(op);
  result = inf_text_default_delete_operation_new(priv-&gt;position, chunk);
  inf_text_chunk_free(chunk);
  return INF_ADOPTED_OPERATION(result);
}
static guint
inf_text_remote_delete_operation_get_position(
  InfTextDeleteOperation* operation)
{
  return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;position;
}
static guint
inf_text_remote_delete_operation_get_length(InfTextDeleteOperation* operation)
{
  return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;length;
}
static InfTextDeleteOperation*
inf_text_remote_delete_operation_transform_position(
  InfTextDeleteOperation* operation,
  guint position)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", position,
    "length", priv-&gt;length,
    NULL
  );
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
    priv-&gt;recon
  );
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_TEXT_DELETE_OPERATION(result);
}
static InfTextDeleteOperation*
inf_text_remote_delete_operation_transform_overlap(
  InfTextDeleteOperation* operation,
  InfTextDeleteOperation* other,
  guint position,
  guint begin,
  guint other_begin,
  guint length)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  InfTextChunk* chunk;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;
  g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(other));
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  chunk = inf_text_chunk_substring(
    inf_text_default_delete_operation_get_chunk(
      INF_TEXT_DEFAULT_DELETE_OPERATION(other)
    ),
    other_begin,
    length
  );
  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", position,
    "length", priv-&gt;length - length,
    NULL
  );
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_feed(
    priv-&gt;recon,
    begin,
    chunk
  );
  inf_text_chunk_free(chunk);
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_TEXT_DELETE_OPERATION(result);
}
static InfAdoptedSplitOperation*
inf_text_remote_delete_operation_transform_split(
  InfTextDeleteOperation* operation,
  guint split_pos,
  guint split_len)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  InfAdoptedSplitOperation* result;
  GObject* first_operation;
  GObject* second_operation;
  InfTextRemoteDeleteOperationPrivate* result_priv;
  InfTextRemoteDeleteOperationRecon* recon;
  InfTextRemoteDeleteOperationRecon* new_recon;
  GSList* first_recon;
  GSList* second_recon;
  guint recon_cur_len;
  GSList* item;
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  first_recon = NULL;
  second_recon = NULL;
  recon_cur_len = 0;
  for(item = priv-&gt;recon; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    g_assert(recon-&gt;position &gt;= recon_cur_len);
    if(recon-&gt;position - recon_cur_len &lt;= split_pos)
    {
      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = recon-&gt;position;
      new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
      first_recon = g_slist_prepend(first_recon, new_recon);
      recon_cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
    }
    else
    {
      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = recon-&gt;position - (split_pos + recon_cur_len);
      new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
      second_recon = g_slist_prepend(second_recon, new_recon);
    }
  }
  first_operation = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", priv-&gt;position,
    "length", split_pos,
    NULL
  );
  second_operation = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", priv-&gt;position + split_len,
    "length", priv-&gt;length - split_pos,
    NULL
  );
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(first_operation);
  result_priv-&gt;recon = g_slist_reverse(first_recon);
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(second_operation);
  result_priv-&gt;recon = g_slist_reverse(second_recon);
  result_priv-&gt;recon_offset = priv-&gt;recon_offset + split_pos + recon_cur_len;
  result = inf_adopted_split_operation_new(
    INF_ADOPTED_OPERATION(first_operation),
    INF_ADOPTED_OPERATION(second_operation)
  );
  g_object_unref(G_OBJECT(second_operation));
  g_object_unref(G_OBJECT(first_operation));
  return result;
}
static void
inf_text_remote_delete_operation_class_init(
<a name="1"></a>  InfTextRemoteDeleteOperationClass* remote_delete_operation_class)
{
  GObjectClass* object_class;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  object_class = G_OBJECT_CLASS(remote_delete_operation_class);
  object_class-&gt;finalize = inf_text_remote_delete_operation_finalize;
  object_class-&gt;set_property = inf_text_remote_delete_operation_set_property;
  object_class-&gt;get_property = inf_text_remote_delete_operation_get_property;
  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      "position",
      "Position",
      "Position where to start deleting characters",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LENGTH,
    g_param_spec_uint(
      "length",
      "Length",
      "The length of the deleted text",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}
static void
inf_text_remote_delete_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id =
    inf_text_remote_delete_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_remote_delete_operation_transform;
  iface-&gt;copy = inf_text_remote_delete_operation_copy;
  iface-&gt;get_flags = inf_text_remote_delete_operation_get_flags;
  iface-&gt;apply = inf_text_remote_delete_operation_apply;
  iface-&gt;apply_transformed =
    inf_text_remote_delete_operation_apply_transformed;
  iface-&gt;revert = NULL;</b></font>
}
static void
inf_text_remote_delete_operation_delete_operation_iface_init(
  InfTextDeleteOperationInterface* iface)
{
  iface-&gt;get_position = inf_text_remote_delete_operation_get_position;
  iface-&gt;get_length = inf_text_remote_delete_operation_get_length;
  iface-&gt;transform_position =
    inf_text_remote_delete_operation_transform_position;
  iface-&gt;transform_overlap =
    inf_text_remote_delete_operation_transform_overlap;
  iface-&gt;transform_split = inf_text_remote_delete_operation_transform_split;
}
InfTextRemoteDeleteOperation*
inf_text_remote_delete_operation_new(guint position,
                                     guint length)
{
  GObject* object;
  object = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    "position", position,
    "length", length,
    NULL
  );
  return INF_TEXT_REMOTE_DELETE_OPERATION(object);
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-name-resolver.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-name-resolver.h&gt;
#include &lt;libinfinity/common/inf-async-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#ifdef G_OS_WIN32
# include &lt;ws2tcpip.h&gt;
# include &lt;wspiapi.h&gt;
#else
# include &lt;sys/types.h&gt;
# include &lt;sys/socket.h&gt;
# include &lt;netinet/in.h&gt; # include &lt;netdb.h&gt;
#endif
#ifdef G_OS_WIN32
# include &lt;windns.h&gt;
#else
# include &lt;resolv.h&gt;
# include &lt;arpa/nameser.h&gt;
# include &lt;arpa/nameser_compat.h&gt;
#endif
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
typedef struct _InfNameResolverEntry InfNameResolverEntry;
struct _InfNameResolverEntry {
  InfIpAddress* address;
  guint port;
};
typedef struct _InfNameResolverSRV InfNameResolverSRV;
struct _InfNameResolverSRV {
  guint priority;
  guint weight;
  guint port;
<a name="3"></a>  gchar* address;
};
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfNameResolverResult InfNameResolverResult;
struct _InfNameResolverResult {
  InfNameResolverEntry* entries;
  guint n_entries;
  InfNameResolverSRV* srvs;
  guint n_srvs;
  GError* error;
};
typedef struct _InfNameResolverPrivate InfNameResolverPrivate;
struct _InfNameResolverPrivate {
  InfIo* io;
  gchar* hostname;
  gchar* service;
  gchar* srv;
  InfAsyncOperation* operation;
  InfNameResolverResult result;
};
enum {
  PROP_0,
  PROP_IO,
  PROP_HOSTNAME,
  PROP_SERVICE,
  PROP_SRV
};</b></font>
enum {
  RESOLVED,
  LAST_SIGNAL
};
#define INF_NAME_RESOLVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_NAME_RESOLVER, InfNameResolverPrivate))
static guint name_resolver_signals[LAST_SIGNAL];
G_DEFINE_TYPE_WITH_CODE(InfNameResolver, inf_name_resolver, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfNameResolver))
static void
inf_name_resolver_result_nullify(InfNameResolverResult* result)
{
  result-&gt;entries = NULL;
  result-&gt;n_entries = 0;
  result-&gt;srvs = NULL;
  result-&gt;n_srvs = 0;
  result-&gt;error = NULL;
}
static void
inf_name_resolver_result_cleanup(InfNameResolverResult* result)
{
  guint i;
  for(i = 0; i &lt; result-&gt;n_entries; ++i)
    inf_ip_address_free(result-&gt;entries[i].address);
  g_free(result-&gt;entries);
  for(i = 0; i &lt; result-&gt;n_srvs; ++i)
    g_free(result-&gt;srvs[i].address);
  g_free(result-&gt;srvs);
  if(result-&gt;error != NULL)
    g_error_free(result-&gt;error);
}
static void
inf_name_resolver_result_free(gpointer result_ptr)
{
  InfNameResolverResult* result;
  result = (InfNameResolverResult*)result_ptr;
  inf_name_resolver_result_cleanup(result);
  g_slice_free(InfNameResolverResult, result);
}
#ifndef G_OS_WIN32
static void
inf_name_resolver_set_herrno_error(GError** error,
                                   int code)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string("INF_NAME_RESOLVER_HERRNO_ERROR"),
    code,
    hstrerror(code)
  );
}
static void
inf_name_resolver_set_errno_error(GError** error,
                                  int code)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string("INF_NAME_RESOLVER_ERRNO_ERROR"),
    code,
    strerror(code)
  );
}
static void
inf_name_resolver_set_incomplete_error(GError** error)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string("INF_NAME_RESOLVER_INCOMPLETE_ERROR"),
    0,
    _("The reply from the DNS server is incomplete")
  );
}
static const char*
inf_name_resolver_parse_dns_uint16(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   guint16* result,
                                   GError** error)
{
  if(cur + 2 &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }
  *result = ntohs(*((guint16*)cur));
  return cur + 2;
}
static const char*
inf_name_resolver_parse_dns_uint32(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   guint32* result,
                                   GError** error)
{
  if(cur + 4 &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }
  *result = ntohl(*((guint32*)cur));
  return cur + 4;
}
static const char*
inf_name_resolver_parse_dns_host(const char* msg,
                                 const char* end,
                                 const char* cur,
                                 gchar* result,
                                 gsize reslen,
                                 GError** error)
{
  int len;
  len = dn_expand(msg, end, cur, result, reslen);
  if(len &lt; 0)
  {
    inf_name_resolver_set_errno_error(error, errno);
    return NULL;
  }
  if(cur + len &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }
  return cur + len;
}
static const char*
inf_name_resolver_parse_srv_record(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   InfNameResolverSRV* srv,
                                   GError** error)
{
  gchar buf[256];
  gsize bufsize;
  guint16 type;
  guint16 cls;
  guint32 ttl;
  guint16 msglen;
  guint16 prio;
  guint16 weight;
  guint16 port;
  bufsize = sizeof(buf);
  cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;type, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;cls, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint32(msg, end, cur, &amp;ttl, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;msglen, error);
  if(cur == NULL) return NULL;
  if(type != T_SRV)
  {
    srv-&gt;address = NULL;
    cur += msglen;
    return cur;
  }
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;prio, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;weight, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;port, error);
  if(cur == NULL) return NULL;
  cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
  if(cur == NULL) return NULL;
  srv-&gt;priority = prio;
  srv-&gt;weight = weight;
  srv-&gt;port = port;
  srv-&gt;address = g_strdup(buf);
  return cur;
}
#endif
static gchar*
inf_name_resolver_choose_srv(InfNameResolverSRV** srvs,
                             guint* n_srvs,
                             guint* port)
{
  InfNameResolverSRV** low_prio_srvs;
  guint n_low_prio_srvs;
  guint total_weight;
  guint accum_weight;
  guint rand;
  guint i;
  guint index;
  gchar* selected_address;
  guint selected_port;
  g_assert(*n_srvs &gt; 0);
  low_prio_srvs = g_malloc(sizeof(InfNameResolverSRV*) * (*n_srvs));
  n_low_prio_srvs = 0;
  total_weight = 0;
  for(i = 0; i &lt; *n_srvs; ++i)
  {
    if(n_low_prio_srvs == 0 ||
       (*srvs)[i].priority &lt; low_prio_srvs[0]-&gt;priority)
    {
      n_low_prio_srvs = 1;
      low_prio_srvs[0] = &amp;(*srvs)[i];
      total_weight = (*srvs)[i].weight;
    }
    else if( (*srvs)[i].priority == low_prio_srvs[0]-&gt;priority)
    {
      low_prio_srvs[n_low_prio_srvs++] = &amp;(*srvs)[i];
      total_weight += (*srvs)[i].weight;
    }
  }
  if(total_weight == 0)
  {
    i = g_random_int_range(0, n_low_prio_srvs);
  }
  else
  {
    rand = g_random_int_range(0, total_weight);
    accum_weight = 0;
    for(i = 0; i &lt; n_low_prio_srvs; ++i)
    {
      accum_weight += low_prio_srvs[i]-&gt;weight;
      if(rand &lt; accum_weight) break;
    }
  }
  g_assert(i &lt; n_low_prio_srvs);
  index = low_prio_srvs[i] - *srvs;
  selected_address = (*srvs)[index].address;
  selected_port = (*srvs)[index].port;
  g_free(low_prio_srvs);
  (*srvs)[index] = (*srvs)[*n_srvs - 1];
  *srvs = g_realloc(*srvs, sizeof(InfNameResolverSRV) * (*n_srvs - 1));
  --*n_srvs;
  if(port != NULL) *port = selected_port;
  return selected_address;
}
static InfNameResolverSRV*
inf_name_resolver_lookup_srv(const gchar* query,
                             guint* n_srvs,
                             GError** error)
{
#ifdef G_OS_WIN32
  PDNS_RECORD data;
  PDNS_RECORD item;
  DNS_STATUS status;
  gchar* str;
  GArray* array;
  InfNameResolverSRV srv;
  status = DnsQuery_UTF8(
    query,
    DNS_TYPE_SRV,
    DNS_QUERY_STANDARD,
    NULL,
    &amp;data,
    NULL
  );
  if(status != 0)
  {
    str = g_win32_error_message(status);
    g_set_error_literal(
      error,
      g_quark_from_static_string("WIN32_ERROR"),
      status,
      str
    );
    g_free(str);
    return NULL;
  }
  array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverSRV));
  for(item = data; item != NULL; item = item-&gt;pNext)
  {
    if(item-&gt;wType != DNS_TYPE_SRV)
      continue;
    srv.priority = item-&gt;Data.SRV.wPriority;
    srv.weight = item-&gt;Data.SRV.wWeight;
    srv.port = item-&gt;Data.SRV.wPort;
    srv.address = g_strdup(item-&gt;Data.SRV.pNameTarget);     g_array_append_val(array, srv);
  }
  DnsRecordListFree(data, DnsFreeRecordListDeep);
  *n_srvs = array-&gt;len;
  return (InfNameResolverSRV*)g_array_free(array, FALSE);
#else
  char ansbuf[4096];
  char hostbuf[256];
  int len;
  HEADER* header;
  int query_count;
  int answer_count;
  const char* msg;
  const char* cur;
  const char* end;
  InfNameResolverSRV* srvs;
  guint n_answers;
  int i;
  static GMutex mutex;
  g_mutex_lock(&amp;mutex);
  *n_srvs = 0;
  h_errno = 0;
  len = res_query(query, C_IN, T_SRV, ansbuf, sizeof(ansbuf));
  if(h_errno != 0)
  {
    if(h_errno != HOST_NOT_FOUND)
      inf_name_resolver_set_herrno_error(error, h_errno);
    g_mutex_unlock(&amp;mutex);
    return NULL;
  }
  g_mutex_unlock(&amp;mutex);
  if(len &lt; sizeof(HEADER))
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }
  msg = ansbuf;
  end = ansbuf + len;
  cur = ansbuf + sizeof(HEADER);
  header = (HEADER*)msg;
  query_count = ntohs(header-&gt;qdcount);
  answer_count = ntohs(header-&gt;ancount);
  for(i = 0; i &lt; query_count; ++i)
  {
    len = dn_expand(msg, end, cur, hostbuf, sizeof(hostbuf));
    if(len &lt; 0)
    {
      inf_name_resolver_set_errno_error(error, errno);
      return NULL;
    }
    if(cur + len + QFIXEDSZ &gt; end)
    {
      inf_name_resolver_set_incomplete_error(error);
      return NULL;
    }
    cur += len + QFIXEDSZ;
  }
  srvs = g_malloc(sizeof(InfNameResolverSRV) * answer_count);
  n_answers = 0;
  for(i = 0; i &lt; answer_count; ++i)
  {
    cur = inf_name_resolver_parse_srv_record(
      msg,
      end,
      cur,
      &amp;srvs[n_answers],
      error
    );
    if(cur == NULL)
    {
      for(i = 0; i &lt; n_answers; ++i)
        g_free(srvs[i].address);
      g_free(srvs);
      return NULL;
    }
    if(srvs[n_answers].address != NULL)
      ++n_answers;
  }
  if(n_answers &lt; answer_count)
    srvs = g_realloc(srvs, n_answers * sizeof(InfNameResolverSRV));
  *n_srvs = n_answers;
  return srvs;
#endif
}
static InfNameResolverEntry*
inf_name_resolver_lookup_a_aaaa(const gchar* hostname,
                                const gchar* service,
                                guint* n_entries,
                                GError** error)
{
  struct addrinfo hint;
  struct addrinfo* res;
  int err;
  GArray* array;
  InfNameResolverEntry entry;
  struct addrinfo* item;
#ifdef AI_ADDRCONFIG
  hint.ai_flags = AI_ADDRCONFIG;
#else
  hint.ai_flags = 0;
#endif
  hint.ai_family = AF_UNSPEC;
  hint.ai_socktype = SOCK_STREAM;
  hint.ai_protocol = 0;
  hint.ai_addrlen = 0;
  hint.ai_canonname = NULL;
  hint.ai_addr = NULL;
  hint.ai_next = NULL;
  res = NULL;
  err = getaddrinfo(hostname, service, &amp;hint, &amp;res);
  if(err != 0)
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string("GETADDRINFO_ERROR"),
      err,
      gai_strerror(err)
    );
    *n_entries = 0;
    return NULL;
  }
  else
  {
    g_assert(res != NULL);
    array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverEntry));
    for(item = res; item != NULL; item = item-&gt;ai_next)
    {
      switch(item-&gt;ai_family)
      {
      case AF_INET:
        entry.address = inf_ip_address_new_raw4(
          ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_addr.s_addr
        );
        entry.port = ntohs( ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_port);
        break;
      case AF_INET6:
        entry.address = inf_ip_address_new_raw6(
          ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_addr.s6_addr
        );
        entry.port = ntohs( ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_port);
        break;
      default:
        g_assert_not_reached();
        break;
      }
      g_array_append_val(array, entry);
    }
    freeaddrinfo(res);
    *n_entries = array-&gt;len;
    return (InfNameResolverEntry*)g_array_free(array, FALSE);
  }
}
static InfNameResolverEntry*
inf_name_resolver_resolve_srv(InfNameResolverSRV** srvs,
                              guint* n_srvs,
                              const gchar* service,
                              guint* n_entries,
                              GError** error)
{
  gchar* srvaddr;
  guint srvport;
  GError* local_error;
  InfNameResolverEntry* entries;
  guint i;
  g_assert(*n_srvs &gt; 0);
  local_error = NULL;
  srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);
  while(srvaddr != NULL)
  {
    entries = inf_name_resolver_lookup_a_aaaa(
      srvaddr,
      service,
      n_entries,
      &amp;local_error
    );
    g_free(srvaddr);
    srvaddr = NULL;
    if(entries == NULL)
    {
      if(*n_srvs &gt; 0)
        srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);
      if(srvaddr != NULL)
      {
        g_error_free(local_error);
        local_error = NULL;
      }
    }
    else
    {
      for(i = 0; i &lt; *n_entries; ++i)
        if(entries[i].port == 0)
          entries[i].port = srvport;
      return entries;
    }
  }
  g_assert(local_error != NULL);
  g_propagate_error(error, local_error);
  return NULL;
}
static InfNameResolverResult*
inf_name_resolver_resolve(const gchar* hostname,
                          const gchar* service,
                          const gchar* srv)
{
  InfNameResolverResult* result;
  gchar* query;
  GError* error;
  error = NULL;
  result = g_slice_new(InfNameResolverResult);
  inf_name_resolver_result_nullify(result);
  if(srv != NULL)
  {
    query = g_strdup_printf("%s.%s", srv, hostname);
    result-&gt;srvs = inf_name_resolver_lookup_srv(
      query,
      &amp;result-&gt;n_srvs,
      &amp;error
    );
    g_free(query);
    if(error != NULL)
    {
      g_warning(
        _("Failure during SRV record lookup: %s\n"
          "Will go on with normal A/AAAA lookup"),
        error-&gt;message
      );
      g_error_free(error);
      error = NULL;
    }
    else if(result-&gt;n_srvs &gt; 0)
    {
      result-&gt;entries = inf_name_resolver_resolve_srv(
        &amp;result-&gt;srvs,
        &amp;result-&gt;n_srvs,
        service,
        &amp;result-&gt;n_entries,
        &amp;result-&gt;error
      );
      return result;
    }
  }
  result-&gt;entries = inf_name_resolver_lookup_a_aaaa(
    hostname,
    service,
    &amp;result-&gt;n_entries,
    &amp;result-&gt;error
  );
  return result;
}
static void
inf_name_resolver_run_func(gpointer* run_data,
                           GDestroyNotify* run_notify,
                           gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  gchar* hostname;
  gchar* service;
  gchar* srv;
  InfNameResolverResult* result;
  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
<a name="1"></a>
  hostname = g_strdup(priv-&gt;hostname);
  service = g_strdup(priv-&gt;service);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  srv = g_strdup(priv-&gt;srv);
  g_object_unref(resolver);
  result = inf_name_resolver_resolve(hostname, service, srv);
  g_free(hostname);
  g_free(service);
  g_free(srv);
  *run_data = result;
  *run_notify = inf_name_resolver_result_free;
}
static void
inf_name_resolver_backup_run_func(gpointer* run_data,
                                  GDestroyNotify* run_notify,
                                  gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;
  gchar* service;
  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  result = g_slice_new(InfNameResolverResult);
  result-&gt;srvs = priv-&gt;result.srvs;
  result-&gt;n_srvs = priv-&gt;result.n_srvs;
  service = g_strdup(priv-&gt;service);
  priv-&gt;result.srvs = NULL;</b></font>
  priv-&gt;result.n_srvs = 0;
  g_object_unref(resolver);
  g_assert(result-&gt;n_srvs &gt; 0);
  result-&gt;error = NULL;
  result-&gt;entries = inf_name_resolver_resolve_srv(
    &amp;result-&gt;srvs,
    &amp;result-&gt;n_srvs,
    service,
    &amp;result-&gt;n_entries,
    &amp;result-&gt;error
  );
  g_free(service);
  *run_data = result;
  *run_notify = inf_name_resolver_result_free;
}
static void
inf_name_resolver_done_func(gpointer run_data,
                            gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;
  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  result = (InfNameResolverResult*)run_data;
  g_assert(priv-&gt;result.n_entries == 0);
  g_assert(priv-&gt;result.n_srvs == 0);
  g_assert(priv-&gt;result.error == NULL);
  priv-&gt;operation = NULL;
  priv-&gt;result = *result;
  inf_name_resolver_result_nullify(result);
  g_signal_emit(
    G_OBJECT(resolver),
    name_resolver_signals[RESOLVED],
    0,
    priv-&gt;result.error
  );
}
static void
inf_name_resolver_backup_done_func(gpointer run_data,
                                   gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;
  guint i;
  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  result = (InfNameResolverResult*)run_data;
  g_assert(priv-&gt;result.n_srvs == 0);
  g_assert(priv-&gt;result.error == NULL);
  priv-&gt;operation = NULL;
  priv-&gt;result.srvs = result-&gt;srvs;
  priv-&gt;result.n_srvs = result-&gt;n_srvs;
  priv-&gt;result.error = result-&gt;error;
  if(result-&gt;n_entries &gt; 0)
  {
    priv-&gt;result.entries = g_realloc(
      priv-&gt;result.entries,
      sizeof(InfNameResolverEntry) *
        (priv-&gt;result.n_entries + result-&gt;n_entries)
    );
    for(i = 0; i &lt; result-&gt;n_entries; ++i)
      priv-&gt;result.entries[priv-&gt;result.n_entries + i] = result-&gt;entries[i];
    priv-&gt;result.n_entries += result-&gt;n_entries;
  }
  inf_name_resolver_result_nullify(result);
  g_signal_emit(
    G_OBJECT(resolver),
    name_resolver_signals[RESOLVED],
    0,
    priv-&gt;result.error
  );
}
static void
inf_name_resolver_init(InfNameResolver* resolver)
{
  InfNameResolverPrivate* priv;
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  priv-&gt;io = NULL;
  priv-&gt;hostname = NULL;
  priv-&gt;service = NULL;
  priv-&gt;srv = NULL;
  priv-&gt;operation = NULL;
  inf_name_resolver_result_nullify(&amp;priv-&gt;result);
}
static void
inf_name_resolver_dispose(GObject* object)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  resolver = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  if(priv-&gt;operation != NULL)
  {
    inf_async_operation_free(priv-&gt;operation);
    priv-&gt;operation = NULL;
  }
  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
<a name="2"></a>  }
  G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;dispose(object);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
inf_name_resolver_finalize(GObject* object)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  resolver = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  inf_name_resolver_result_cleanup(&amp;priv-&gt;result);
  g_free(priv-&gt;hostname);
  g_free(priv-&gt;service);
  g_free(priv-&gt;srv);
  G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;finalize(object);
}
static void
inf_name_resolver_set_property(GObject* object,
                               guint prop_id,
                               const GValue* value,
                               GParamSpec* pspec)
{
  InfNameResolver* connection;
  InfNameResolverPrivate* priv;
  connection = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(connection);
  switch(prop_id)
  {
  case PROP_IO:</b></font>
    g_assert(priv-&gt;operation == NULL);
    if(priv-&gt;io != NULL) g_object_unref(priv-&gt;io);
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_HOSTNAME:
    g_assert(priv-&gt;operation == NULL);
    g_free(priv-&gt;hostname);
    priv-&gt;hostname = g_value_dup_string(value);
    break;
  case PROP_SERVICE:
    g_assert(priv-&gt;operation == NULL);
    g_free(priv-&gt;service);
    priv-&gt;service = g_value_dup_string(value);
    break;
  case PROP_SRV:
<a name="0"></a>    g_assert(priv-&gt;operation == NULL);
    g_free(priv-&gt;srv);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;srv = g_value_dup_string(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_name_resolver_get_property(GObject* object,
                               guint prop_id,
                               GValue* value,
                               GParamSpec* pspec)
{
  InfNameResolver* connection;
  InfNameResolverPrivate* priv;
  connection = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(connection);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_HOSTNAME:
    g_value_set_string(value, priv-&gt;hostname);
    break;</b></font>
  case PROP_SERVICE:
    g_value_set_string(value, priv-&gt;service);
    break;
  case PROP_SRV:
    g_value_set_string(value, priv-&gt;srv);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_name_resolver_class_init(InfNameResolverClass* name_resolver_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(name_resolver_class);
  object_class-&gt;dispose = inf_name_resolver_dispose;
  object_class-&gt;finalize = inf_name_resolver_finalize;
  object_class-&gt;set_property = inf_name_resolver_set_property;
  object_class-&gt;get_property = inf_name_resolver_get_property;
  name_resolver_class-&gt;resolved = NULL;
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "I/O handler",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_HOSTNAME,
    g_param_spec_string(
      "hostname",
      "Hostname",
      "The hostname to be looked up",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SERVICE,
    g_param_spec_string(
      "service",
      "Service",
      "The expected service at the remote endpoint",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SRV,
    g_param_spec_string(
      "srv",
      "SRV",
      "The SRV record to look up for the given hostname, e.g. _jabber._tcp",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  name_resolver_signals[RESOLVED] = g_signal_new(
    "resolved",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfNameResolverClass, resolved),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}
InfNameResolver*
inf_name_resolver_new(InfIo* io,
                      const gchar* hostname,
                      const gchar* service,
                      const gchar* srv)
{
  InfNameResolver* resolver;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  resolver = INF_NAME_RESOLVER(
    g_object_new(
      INF_TYPE_NAME_RESOLVER,
      "io", io,
      "hostname", hostname,
      "service", service,
      "srv", srv,
      NULL
    )
  );
  return resolver;
}
const gchar*
inf_name_resolver_get_hostname(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;hostname;
}
const gchar*
inf_name_resolver_get_service(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;service;
}
const gchar*
inf_name_resolver_get_srv(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;srv;
}
gboolean
inf_name_resolver_start(InfNameResolver* resolver,
                        GError** error)
{
  InfNameResolverPrivate* priv;
  gboolean success;
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);
  inf_name_resolver_result_cleanup(&amp;priv-&gt;result);
  inf_name_resolver_result_nullify(&amp;priv-&gt;result);
  priv-&gt;operation = inf_async_operation_new(
    priv-&gt;io,
    inf_name_resolver_run_func,
    inf_name_resolver_done_func,
    resolver
  );
  g_object_ref(resolver);
  success = inf_async_operation_start(priv-&gt;operation, error);
  if(success == FALSE)
  {
    g_object_unref(resolver);
    priv-&gt;operation = FALSE;
    return FALSE;
  }
  return TRUE;
}
gboolean
inf_name_resolver_lookup_backup(InfNameResolver* resolver,
                                GError** error)
{
  InfNameResolverPrivate* priv;
  gboolean success;
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);
  if(priv-&gt;result.n_srvs == 0)
    return FALSE;
  if(priv-&gt;result.error != NULL)
  {
    g_error_free(priv-&gt;result.error);
    priv-&gt;result.error = NULL;
  }
  priv-&gt;operation = inf_async_operation_new(
    priv-&gt;io,
    inf_name_resolver_backup_run_func,
    inf_name_resolver_backup_done_func,
    resolver
  );
  g_object_ref(resolver);
  success = inf_async_operation_start(priv-&gt;operation, error);
  if(success == FALSE)
  {
    g_object_unref(resolver);
    priv-&gt;operation = FALSE;
    return FALSE;
  }
  return TRUE;
}
gboolean
inf_name_resolver_finished(InfNameResolver* resolver)
{
  InfNameResolverPrivate* priv;
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  if(priv-&gt;operation != NULL)
    return FALSE;
  return TRUE;
}
guint
inf_name_resolver_get_n_addresses(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;result.n_entries;
}
const InfIpAddress*
inf_name_resolver_get_address(InfNameResolver* resolver,
                              guint index)
{
  InfNameResolverPrivate* priv;
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, NULL);
  return priv-&gt;result.entries[index].address;
}
guint
inf_name_resolver_get_port(InfNameResolver* resolver,
                           guint index)
{
  InfNameResolverPrivate* priv;
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, 0);
  return priv-&gt;result.entries[index].port;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
