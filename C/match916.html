<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-text-remote-delete-operation.c & inf-name-resolver.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-text-remote-delete-operation.c & inf-name-resolver.c
      </h3>
      <h1 align="center">
        11.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-text-remote-delete-operation.c (17.816092%)<TH>inf-name-resolver.c (8.378378%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match916-0.html#0',2,'match916-1.html#0',3)" NAME="0">(249-276)<TD><A HREF="javascript:ZweiFrames('match916-0.html#0',2,'match916-1.html#0',3)" NAME="0">(1025-1052)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match916-0.html#1',2,'match916-1.html#1',3)" NAME="1">(675-723)<TD><A HREF="javascript:ZweiFrames('match916-0.html#1',2,'match916-1.html#1',3)" NAME="1">(797-828)</A><TD ALIGN=center><FONT COLOR="#f00000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match916-0.html#2',2,'match916-1.html#2',3)" NAME="2">(215-245)<TD><A HREF="javascript:ZweiFrames('match916-0.html#2',2,'match916-1.html#2',3)" NAME="2">(969-1003)</A><TD ALIGN=center><FONT COLOR="#f00000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match916-0.html#3',2,'match916-1.html#3',3)" NAME="3">(36-62)<TD><A HREF="javascript:ZweiFrames('match916-0.html#3',2,'match916-1.html#3',3)" NAME="3">(84-118)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-remote-delete-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;

#include &lt;libinfinity/adopted/inf-adopted-split-operation.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

/* recon is helper information to reconstruct the original delete operation.
 * It stores the parts that have been erased from the remote delete operation
 * by transforming against other delete operations, including the deleted
<A NAME="3"></A> * text that is obtained from the operations transformed against. This
 * is necessary because that information is no longer available in the buffer
 * in the state the remote delete operation is made reversible. */
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match916-1.html#3',3,'match916-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>typedef struct _InfTextRemoteDeleteOperationRecon
  InfTextRemoteDeleteOperationRecon;
struct _InfTextRemoteDeleteOperationRecon {
  guint position;
  InfTextChunk* chunk;
};

typedef struct _InfTextRemoteDeleteOperationPrivate
  InfTextRemoteDeleteOperationPrivate;
struct _InfTextRemoteDeleteOperationPrivate {
  guint position;
  guint length;

  /* TODO: Don't use GSList but link InfTextRemoteDeleteOperationRecon
   * directly? */
  GSList* recon;
  /* TODO: We don't actually need recon_offset, it is just used in an
   * assertion. Perhaps keep in debug code. */
  guint recon_offset;
};

enum {
  PROP_0,

  PROP_POSITION,
  PROP_LENGTH
};</B></FONT>

#define INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_REMOTE_DELETE_OPERATION, InfTextRemoteDeleteOperationPrivate))

static void inf_text_remote_delete_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
static void inf_text_remote_delete_operation_delete_operation_iface_init(InfTextDeleteOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextRemoteDeleteOperation, inf_text_remote_delete_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextRemoteDeleteOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_remote_delete_operation_operation_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_DELETE_OPERATION, inf_text_remote_delete_operation_delete_operation_iface_init))

/* This appends an element to a GSList more efficiently than
 * g_slist_append() when the last item of the list in known. This updates
 * *last to point to the new last item. */
static GSList*
g_slist_append_fast(GSList* list,
                    GSList** last,
                    gpointer item)
{
  GSList* temp;

  g_assert(last != NULL);
  if(list == NULL)
  {
    list = g_slist_prepend(list, item);
    *last = list;
  }
  else
  {
    g_assert(*last != NULL);

    /* We don't actually need the return value, but glib warns if it
     * remains unused. We know that g_slist_append does not change the list
     * because the list has at least one element (otherwise it would be
     * NULL). */
    temp = g_slist_append(*last, item);
    *last = (*last)-&gt;next;
  }

  return list;
}

static GSList*
inf_text_remote_delete_operation_recon_copy(GSList* recon_list)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;

  GSList* new_list;
  GSList* last;
  InfTextRemoteDeleteOperationRecon* new_recon;

  new_list = NULL;
  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = recon-&gt;position;
    new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }

  return new_list;
}

static void
inf_text_remote_delete_operation_recon_free(GSList* recon_list)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;

  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    inf_text_chunk_free(recon-&gt;chunk);
    g_slice_free(InfTextRemoteDeleteOperationRecon, recon);
  }

  g_slist_free(recon_list);
}

/* TODO: Make this work inline, adjust usages */
/* TODO: Merge adjacent text chunks */
static GSList*
inf_text_remote_delete_operation_recon_feed(GSList* recon_list,
                                            guint position,
                                            InfTextChunk* chunk)
{
  GSList* item;
  InfTextRemoteDeleteOperationRecon* recon;
  GSList* new_list;
  GSList* last;
  InfTextRemoteDeleteOperationRecon* new_recon;

  guint text_pos;
  guint cur_len;
  guint text_len;

  new_list = NULL;
  text_pos = 0;
  cur_len = 0;

  for(item = recon_list; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
    if(position + text_pos + cur_len &lt; recon-&gt;position &amp;&amp;
       text_pos &lt; inf_text_chunk_get_length(chunk))
    {
      text_len = recon-&gt;position - position - text_pos - cur_len;
      if(text_len &gt; inf_text_chunk_get_length(chunk) - text_pos)
        text_len = inf_text_chunk_get_length(chunk) - text_pos;

      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = position + text_pos + cur_len;
      new_recon-&gt;chunk = inf_text_chunk_substring(chunk, text_pos, text_len);
      new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
      text_pos += text_len;
    }

    cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = recon-&gt;position;
    new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }

  if(text_pos &lt; inf_text_chunk_get_length(chunk))
  {
    new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
    new_recon-&gt;position = position + text_pos + cur_len;
    new_recon-&gt;chunk = inf_text_chunk_substring(
      chunk,
      text_pos,
      inf_text_chunk_get_length(chunk) - text_pos
    );

    new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
  }

  return new_list;
}

static void
inf_text_remote_delete_operation_init(InfTextRemoteDeleteOperation* operation)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  priv-&gt;position = 0;
  priv-&gt;length = 0;
<A NAME="2"></A>
  priv-&gt;recon = NULL;
  priv-&gt;recon_offset = 0;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match916-1.html#2',3,'match916-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
inf_text_remote_delete_operation_finalize(GObject* object)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;

  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  inf_text_remote_delete_operation_recon_free(priv-&gt;recon);

  G_OBJECT_CLASS(inf_text_remote_delete_operation_parent_class)-&gt;finalize(object);
}

static void
inf_text_remote_delete_operation_set_property(GObject* object,
                                              guint prop_id,
                                              const GValue* value,
                                              GParamSpec* pspec)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;

  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:</B></FONT>
<A NAME="0"></A>    priv-&gt;position = g_value_get_uint(value);
    break;
  case PROP_LENGTH:
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match916-1.html#0',3,'match916-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    priv-&gt;length = g_value_get_uint(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_remote_delete_operation_get_property(GObject* object,
                                              guint prop_id,
                                              GValue* value,
                                              GParamSpec* pspec)
{
  InfTextRemoteDeleteOperation* operation;
  InfTextRemoteDeleteOperationPrivate* priv;

  operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_LENGTH:
    g_value_set_uint(value, priv-&gt;length);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_remote_delete_operation_need_concurrency_id(
  InfAdoptedOperation* operation,
  InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));

  return inf_text_delete_operation_need_concurrency_id(
    INF_TEXT_DELETE_OPERATION(operation),
    against
  );
}

static InfAdoptedOperation*
inf_text_remote_delete_operation_transform(InfAdoptedOperation* operation,
                                           InfAdoptedOperation* against,
                                           InfAdoptedOperation* operation_lcs,
                                           InfAdoptedOperation* against_lcs,
                                           InfAdoptedConcurrencyId cid)
{
  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));

  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    return inf_text_delete_operation_transform_insert(
      INF_TEXT_DELETE_OPERATION(operation),
      INF_TEXT_INSERT_OPERATION(against)
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    return inf_text_delete_operation_transform_delete(
      INF_TEXT_DELETE_OPERATION(operation),
      INF_TEXT_DELETE_OPERATION(against)
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }
}

static InfAdoptedOperation*
inf_text_remote_delete_operation_copy(InfAdoptedOperation* operation)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, priv-&gt;position,
    &quot;length&quot;, priv-&gt;length,
    NULL
  );

  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);

  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
    priv-&gt;recon
  );

  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_ADOPTED_OPERATION(result);
}

static InfAdoptedOperationFlags
inf_text_remote_delete_operation_get_flags(InfAdoptedOperation* operation)
{
  /* RemoteDeleteOperation is not reversible because it does not know
   * what text has been deleted */
  return INF_ADOPTED_OPERATION_AFFECTS_BUFFER;
}

static gboolean
inf_text_remote_delete_operation_apply(InfAdoptedOperation* operation,
                                       InfAdoptedUser* by,
                                       InfBuffer* buffer,
                                       GError** error)
{
  InfTextRemoteDeleteOperationPrivate* priv;

  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
  g_assert(INF_TEXT_IS_BUFFER(buffer));

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  if(priv-&gt;position + priv-&gt;length &gt;
     inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string(&quot;INF_TEXT_OPERATION_ERROR&quot;),
      INF_TEXT_OPERATION_ERROR_INVALID_DELETE,
      _(&quot;Attempt to remove text from after the end of the document&quot;)
    );

    return FALSE;
  }
  else
  {
    inf_text_buffer_erase_text(
      INF_TEXT_BUFFER(buffer),
      priv-&gt;position,
      priv-&gt;length,
      INF_USER(by)
    );
    
    return TRUE;
  }
}

static InfAdoptedOperation*
inf_text_remote_delete_operation_apply_transformed(InfAdoptedOperation* op,
                                                   InfAdoptedOperation* trans,
                                                   InfAdoptedUser* by,
                                                   InfBuffer* buffer,
                                                   GError** error)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  InfTextChunk* chunk;
  InfTextChunk* temp_slice;
  GSList* list;
  GSList* item;
  InfAdoptedOperation* operation;
  GSList* recon_list;
  GSList* recon_item;
  InfTextRemoteDeleteOperationRecon* recon;
  InfTextDefaultDeleteOperation* result;

  g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(op));
  g_assert(INF_TEXT_IS_BUFFER(buffer));

  /* TODO: We can probably optimize this function, but then we should
   * a) profile it and b) in many cases input parameters to this function
   * are trivial anyway. */
  if(INF_ADOPTED_IS_SPLIT_OPERATION(trans))
  {
    list = inf_adopted_split_operation_unsplit(
      INF_ADOPTED_SPLIT_OPERATION(trans)
    );
  }
  else
  {
    list = g_slist_prepend(NULL, trans);
  }

  chunk = inf_text_chunk_new(
    inf_text_buffer_get_encoding(INF_TEXT_BUFFER(buffer))
  );

  /* We assume the list of remote delete operations to be in order */
  for(item = list; item != NULL; item = g_slist_next(item))
  {
    g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(item-&gt;data));
    priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(item-&gt;data);

    operation = INF_ADOPTED_OPERATION(item-&gt;data);

    if(priv-&gt;length &gt; 0)
    {
      temp_slice = inf_text_buffer_get_slice(
        INF_TEXT_BUFFER(buffer),
        priv-&gt;position,
        priv-&gt;length
      );

      recon_list = inf_text_remote_delete_operation_recon_feed(
        priv-&gt;recon,
        0,
        temp_slice
      );

      inf_text_chunk_free(temp_slice);
    }
    else
    {
      recon_list = priv-&gt;recon;
    }

    for(recon_item = recon_list;
        recon_item != NULL;
        recon_item = g_slist_next(recon_item))
    {
      recon = (InfTextRemoteDeleteOperationRecon*)recon_item-&gt;data;
      g_assert(priv-&gt;recon_offset + recon-&gt;position ==
               inf_text_chunk_get_length(chunk));

      inf_text_chunk_insert_chunk(
        chunk,
        inf_text_chunk_get_length(chunk),
        recon-&gt;chunk
      );
    }

    /* Free recon list if newly allocated */
    if(priv-&gt;length &gt; 0)
      inf_text_remote_delete_operation_recon_free(recon_list);

    if(!inf_adopted_operation_apply(operation, by, buffer, error))
    {
      g_slist_free(list);
      inf_text_chunk_free(chunk);
      return NULL;
    }
  }

  g_slist_free(list);

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(op);
  result = inf_text_default_delete_operation_new(priv-&gt;position, chunk);
  inf_text_chunk_free(chunk);

  return INF_ADOPTED_OPERATION(result);
}

static guint
inf_text_remote_delete_operation_get_position(
  InfTextDeleteOperation* operation)
{
  return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;position;
}

static guint
inf_text_remote_delete_operation_get_length(InfTextDeleteOperation* operation)
{
  return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;length;
}

static InfTextDeleteOperation*
inf_text_remote_delete_operation_transform_position(
  InfTextDeleteOperation* operation,
  guint position)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, position,
    &quot;length&quot;, priv-&gt;length,
    NULL
  );
  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);

  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
    priv-&gt;recon
  );
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_TEXT_DELETE_OPERATION(result);
}

static InfTextDeleteOperation*
inf_text_remote_delete_operation_transform_overlap(
  InfTextDeleteOperation* operation,
  InfTextDeleteOperation* other,
  guint position,
  guint begin,
  guint other_begin,
  guint length)
{
  InfTextRemoteDeleteOperationPrivate* priv;
  InfTextChunk* chunk;
  GObject* result;
  InfTextRemoteDeleteOperationPrivate* result_priv;

  /* It is actually possible that two remote delete operations are
   * transformed against each other (actually the parts of a splitted
   * remote delete operation). However, they must not overlap. */
  g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(other));

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  chunk = inf_text_chunk_substring(
    inf_text_default_delete_operation_get_chunk(
      INF_TEXT_DEFAULT_DELETE_OPERATION(other)
    ),
    other_begin,
    length
  );

  result = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, position,
    &quot;length&quot;, priv-&gt;length - length,
    NULL
  );

  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);

  result_priv-&gt;recon = inf_text_remote_delete_operation_recon_feed(
    priv-&gt;recon,
    begin,
    chunk
  );

  inf_text_chunk_free(chunk);

  result_priv-&gt;recon_offset = priv-&gt;recon_offset;
  return INF_TEXT_DELETE_OPERATION(result);
}

static InfAdoptedSplitOperation*
inf_text_remote_delete_operation_transform_split(
  InfTextDeleteOperation* operation,
  guint split_pos,
  guint split_len)
{
  /* Need to split the delete operation and the recon list */
  InfTextRemoteDeleteOperationPrivate* priv;
  InfAdoptedSplitOperation* result;
  GObject* first_operation;
  GObject* second_operation;
  InfTextRemoteDeleteOperationPrivate* result_priv;
  InfTextRemoteDeleteOperationRecon* recon;
  InfTextRemoteDeleteOperationRecon* new_recon;
  GSList* first_recon;
  GSList* second_recon;
  guint recon_cur_len;
  GSList* item;

  priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);

  first_recon = NULL;
  second_recon = NULL;
  recon_cur_len = 0;

  for(item = priv-&gt;recon; item != NULL; item = g_slist_next(item))
  {
    recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;

    g_assert(recon-&gt;position &gt;= recon_cur_len);
    if(recon-&gt;position - recon_cur_len &lt;= split_pos)
    {
      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = recon-&gt;position;
      new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
      first_recon = g_slist_prepend(first_recon, new_recon);

      recon_cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
    }
    else
    {
      new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
      new_recon-&gt;position = recon-&gt;position - (split_pos + recon_cur_len);
      new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
      second_recon = g_slist_prepend(second_recon, new_recon);
    }
  }

  first_operation = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, priv-&gt;position,
    &quot;length&quot;, split_pos,
    NULL
  );
  
  second_operation = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, priv-&gt;position + split_len,
    &quot;length&quot;, priv-&gt;length - split_pos,
    NULL
  );

  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(first_operation);
  result_priv-&gt;recon = g_slist_reverse(first_recon);
  result_priv-&gt;recon_offset = priv-&gt;recon_offset;

  result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(second_operation);
  result_priv-&gt;recon = g_slist_reverse(second_recon);
  result_priv-&gt;recon_offset = priv-&gt;recon_offset + split_pos + recon_cur_len;

  result = inf_adopted_split_operation_new(
    INF_ADOPTED_OPERATION(first_operation),
    INF_ADOPTED_OPERATION(second_operation)
  );

  g_object_unref(G_OBJECT(second_operation));
  g_object_unref(G_OBJECT(first_operation));
  return result;
}

static void
inf_text_remote_delete_operation_class_init(
<A NAME="1"></A>  InfTextRemoteDeleteOperationClass* remote_delete_operation_class)
{
  GObjectClass* object_class;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match916-1.html#1',3,'match916-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  object_class = G_OBJECT_CLASS(remote_delete_operation_class);

  object_class-&gt;finalize = inf_text_remote_delete_operation_finalize;
  object_class-&gt;set_property = inf_text_remote_delete_operation_set_property;
  object_class-&gt;get_property = inf_text_remote_delete_operation_get_property;

  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      &quot;position&quot;,
      &quot;Position&quot;,
      &quot;Position where to start deleting characters&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LENGTH,
    g_param_spec_uint(
      &quot;length&quot;,
      &quot;Length&quot;,
      &quot;The length of the deleted text&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

static void
inf_text_remote_delete_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id =
    inf_text_remote_delete_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_remote_delete_operation_transform;
  iface-&gt;copy = inf_text_remote_delete_operation_copy;
  iface-&gt;get_flags = inf_text_remote_delete_operation_get_flags;
  iface-&gt;apply = inf_text_remote_delete_operation_apply;
  iface-&gt;apply_transformed =
    inf_text_remote_delete_operation_apply_transformed;
  /* RemoteDeleteOperation is not reversible */
  iface-&gt;revert = NULL;</B></FONT>
}

static void
inf_text_remote_delete_operation_delete_operation_iface_init(
  InfTextDeleteOperationInterface* iface)
{
  iface-&gt;get_position = inf_text_remote_delete_operation_get_position;
  iface-&gt;get_length = inf_text_remote_delete_operation_get_length;
  iface-&gt;transform_position =
    inf_text_remote_delete_operation_transform_position;
  iface-&gt;transform_overlap =
    inf_text_remote_delete_operation_transform_overlap;
  iface-&gt;transform_split = inf_text_remote_delete_operation_transform_split;
}

/**
 * inf_text_remote_delete_operation_new: (constructor)
 * @position: The position at which to delete text.
 * @length: The number of characters to delete.
 *
 * Creates a new delete operation that, when applied, deletes @length
 * characters starting from position @position. Note that this operation is
 * not reversible because it does not know the text to delete and is therefore
 * only used to transmit a delete operation through the network to reduce
 * bandwidth usage. The remote part can then reconstruct the deleted text
 * using inf_adopted_operation_apply_transformed().
 *
 * However, it is easier to just use #InfTextDefaultDeleteOperation if you
 * want the operation to be reversible.
 *
 * Returns: (transfer full): A new #InfTextRemoteDeleteOperation.
 **/
InfTextRemoteDeleteOperation*
inf_text_remote_delete_operation_new(guint position,
                                     guint length)
{
  GObject* object;

  object = g_object_new(
    INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
    &quot;position&quot;, position,
    &quot;length&quot;, length,
    NULL
  );

  return INF_TEXT_REMOTE_DELETE_OPERATION(object);
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-name-resolver.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-name-resolver
 * @title: InfNameResolver
 * @short_description: Asynchronous DNS name lookup with support for SRV
 * records
 * @include: libinfinity/common/inf-name-resolver.h
 * @stability: Unstable
 *
 * #InfNameResolver provides a portable interface to look up DNS entries. When
 * a resorver object has been created, the name lookup can be started with
 * inf_name_resolver_start(), and once it finishes, the
 * #InfNameResolver::resolved signal is emitted. The
 * inf_name_resolver_get_address() and inf_name_resolver_get_port() functions
 * can then be used to obtain the result.
 *
 * There can at most be one hostname lookup at a time. If you need more than
 * one concurrent hostname lookup, use multiple #InfNameResolver objects.
 **/

#include &lt;libinfinity/common/inf-name-resolver.h&gt;
#include &lt;libinfinity/common/inf-async-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

/* For getaddrinfo */
#ifdef G_OS_WIN32
# include &lt;ws2tcpip.h&gt;
/* We need to include wspiapi.h to support getaddrinfo on Windows 2000.
 * See the MSDN article for getaddrinfo
 * http://msdn.microsoft.com/en-us/library/ms738520(VS.85).aspx
 * and bug #425. */
# include &lt;wspiapi.h&gt;
#else
# include &lt;sys/types.h&gt;
# include &lt;sys/socket.h&gt;
# include &lt;netinet/in.h&gt; /* Required for FreeBSD. See bug #431. */
# include &lt;netdb.h&gt;
#endif

/* For SRV lookup */
#ifdef G_OS_WIN32
# include &lt;windns.h&gt;
#else
# include &lt;resolv.h&gt;
# include &lt;arpa/nameser.h&gt;
# include &lt;arpa/nameser_compat.h&gt;
#endif

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

typedef struct _InfNameResolverEntry InfNameResolverEntry;
struct _InfNameResolverEntry {
  InfIpAddress* address;
  guint port;
};

typedef struct _InfNameResolverSRV InfNameResolverSRV;
struct _InfNameResolverSRV {
  guint priority;
  guint weight;
  guint port;
<A NAME="3"></A>  gchar* address;
};

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match916-0.html#3',2,'match916-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>typedef struct _InfNameResolverResult InfNameResolverResult;
struct _InfNameResolverResult {
  /* The primarily resolved entries */
  InfNameResolverEntry* entries;
  guint n_entries;

  /* Not-yet-checked SRV records. If none of the above entries work, we can
   * look up these as a backup. */
  InfNameResolverSRV* srvs;
  guint n_srvs;

  GError* error;
};

typedef struct _InfNameResolverPrivate InfNameResolverPrivate;
struct _InfNameResolverPrivate {
  InfIo* io;
  gchar* hostname;
  gchar* service;
  gchar* srv;

  InfAsyncOperation* operation;

  /* Output */
  InfNameResolverResult result;
};

enum {
  PROP_0,

  PROP_IO,
  PROP_HOSTNAME,
  PROP_SERVICE,
  PROP_SRV
};</B></FONT>

enum {
  RESOLVED,

  LAST_SIGNAL
};

#define INF_NAME_RESOLVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_NAME_RESOLVER, InfNameResolverPrivate))

static guint name_resolver_signals[LAST_SIGNAL];

G_DEFINE_TYPE_WITH_CODE(InfNameResolver, inf_name_resolver, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfNameResolver))

static void
inf_name_resolver_result_nullify(InfNameResolverResult* result)
{
  result-&gt;entries = NULL;
  result-&gt;n_entries = 0;
  result-&gt;srvs = NULL;
  result-&gt;n_srvs = 0;
  result-&gt;error = NULL;
}

static void
inf_name_resolver_result_cleanup(InfNameResolverResult* result)
{
  guint i;

  for(i = 0; i &lt; result-&gt;n_entries; ++i)
    inf_ip_address_free(result-&gt;entries[i].address);
  g_free(result-&gt;entries);

  for(i = 0; i &lt; result-&gt;n_srvs; ++i)
    g_free(result-&gt;srvs[i].address);
  g_free(result-&gt;srvs);

  if(result-&gt;error != NULL)
    g_error_free(result-&gt;error);
}

static void
inf_name_resolver_result_free(gpointer result_ptr)
{
  InfNameResolverResult* result;

  result = (InfNameResolverResult*)result_ptr;

  inf_name_resolver_result_cleanup(result);
  g_slice_free(InfNameResolverResult, result);
}

/* Worker thread */

#ifndef G_OS_WIN32
static void
inf_name_resolver_set_herrno_error(GError** error,
                                   int code)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string(&quot;INF_NAME_RESOLVER_HERRNO_ERROR&quot;),
    code,
    hstrerror(code)
  );
}

static void
inf_name_resolver_set_errno_error(GError** error,
                                  int code)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string(&quot;INF_NAME_RESOLVER_ERRNO_ERROR&quot;),
    code,
    strerror(code)
  );
}

static void
inf_name_resolver_set_incomplete_error(GError** error)
{
  g_set_error_literal(
    error,
    g_quark_from_static_string(&quot;INF_NAME_RESOLVER_INCOMPLETE_ERROR&quot;),
    0,
    _(&quot;The reply from the DNS server is incomplete&quot;)
  );
}

static const char*
inf_name_resolver_parse_dns_uint16(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   guint16* result,
                                   GError** error)
{
  if(cur + 2 &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }

  *result = ntohs(*((guint16*)cur));
  return cur + 2;
}

static const char*
inf_name_resolver_parse_dns_uint32(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   guint32* result,
                                   GError** error)
{
  if(cur + 4 &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }

  *result = ntohl(*((guint32*)cur));
  return cur + 4;
}

static const char*
inf_name_resolver_parse_dns_host(const char* msg,
                                 const char* end,
                                 const char* cur,
                                 gchar* result,
                                 gsize reslen,
                                 GError** error)
{
  int len;

  len = dn_expand(msg, end, cur, result, reslen);
  if(len &lt; 0)
  {
    inf_name_resolver_set_errno_error(error, errno);
    return NULL;
  }

  if(cur + len &gt; end)
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }

  return cur + len;
}

static const char*
inf_name_resolver_parse_srv_record(const char* msg,
                                   const char* end,
                                   const char* cur,
                                   InfNameResolverSRV* srv,
                                   GError** error)
{
  gchar buf[256];
  gsize bufsize;

  guint16 type;
  guint16 cls;
  guint32 ttl;
  guint16 msglen;
  guint16 prio;
  guint16 weight;
  guint16 port;

  bufsize = sizeof(buf);

  cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;type, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;cls, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint32(msg, end, cur, &amp;ttl, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;msglen, error);
  if(cur == NULL) return NULL;

  if(type != T_SRV)
  {
    srv-&gt;address = NULL;
    cur += msglen;
    return cur;
  }

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;prio, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;weight, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;port, error);
  if(cur == NULL) return NULL;

  cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
  if(cur == NULL) return NULL;

  srv-&gt;priority = prio;
  srv-&gt;weight = weight;
  srv-&gt;port = port;
  srv-&gt;address = g_strdup(buf);
  return cur;
}
#endif

static gchar*
inf_name_resolver_choose_srv(InfNameResolverSRV** srvs,
                             guint* n_srvs,
                             guint* port)
{
  InfNameResolverSRV** low_prio_srvs;
  guint n_low_prio_srvs;
  guint total_weight;
  guint accum_weight;
  guint rand;
  guint i;
  guint index;

  gchar* selected_address;
  guint selected_port;

  g_assert(*n_srvs &gt; 0);

  /* Choose the SRV records with lowest priority */
  low_prio_srvs = g_malloc(sizeof(InfNameResolverSRV*) * (*n_srvs));
  n_low_prio_srvs = 0;
  total_weight = 0;
  for(i = 0; i &lt; *n_srvs; ++i)
  {
    if(n_low_prio_srvs == 0 ||
       (*srvs)[i].priority &lt; low_prio_srvs[0]-&gt;priority)
    {
      n_low_prio_srvs = 1;
      low_prio_srvs[0] = &amp;(*srvs)[i];
      total_weight = (*srvs)[i].weight;
    }
    else if( (*srvs)[i].priority == low_prio_srvs[0]-&gt;priority)
    {
      low_prio_srvs[n_low_prio_srvs++] = &amp;(*srvs)[i];
      total_weight += (*srvs)[i].weight;
    }
  }

  /* Choose a server randomly, according to their weight */
  if(total_weight == 0)
  {
    /* No weight available, chose uniformly */
    i = g_random_int_range(0, n_low_prio_srvs);
  }
  else
  {
    rand = g_random_int_range(0, total_weight);
    accum_weight = 0;
    for(i = 0; i &lt; n_low_prio_srvs; ++i)
    {
      accum_weight += low_prio_srvs[i]-&gt;weight;
      if(rand &lt; accum_weight) break;
    }
  }

  g_assert(i &lt; n_low_prio_srvs);

  /* Select the SRV record with index i */
  index = low_prio_srvs[i] - *srvs;
  selected_address = (*srvs)[index].address;
  selected_port = (*srvs)[index].port;
  g_free(low_prio_srvs);

  /* Remove the chosen SRV entry from the array, so that we don't try the
   * same record again if the selected one does not work. */
  (*srvs)[index] = (*srvs)[*n_srvs - 1];
  *srvs = g_realloc(*srvs, sizeof(InfNameResolverSRV) * (*n_srvs - 1));
  --*n_srvs;

  if(port != NULL) *port = selected_port;
  return selected_address;
}

static InfNameResolverSRV*
inf_name_resolver_lookup_srv(const gchar* query,
                             guint* n_srvs,
                             GError** error)
{
#ifdef G_OS_WIN32
  PDNS_RECORD data;
  PDNS_RECORD item;
  DNS_STATUS status;
  gchar* str;

  GArray* array;
  InfNameResolverSRV srv;

  status = DnsQuery_UTF8(
    query,
    DNS_TYPE_SRV,
    DNS_QUERY_STANDARD,
    NULL,
    &amp;data,
    NULL
  );

  if(status != 0)
  {
    str = g_win32_error_message(status);

    g_set_error_literal(
      error,
      g_quark_from_static_string(&quot;WIN32_ERROR&quot;),
      status,
      str
    );

    g_free(str);
    return NULL;
  }

  array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverSRV));
  for(item = data; item != NULL; item = item-&gt;pNext)
  {
    if(item-&gt;wType != DNS_TYPE_SRV)
      continue;

    srv.priority = item-&gt;Data.SRV.wPriority;
    srv.weight = item-&gt;Data.SRV.wWeight;
    srv.port = item-&gt;Data.SRV.wPort;
    srv.address = g_strdup(item-&gt;Data.SRV.pNameTarget); // TODO: utf16_to_utf8?
    g_array_append_val(array, srv);
  }

  DnsRecordListFree(data, DnsFreeRecordListDeep);

  *n_srvs = array-&gt;len;
  return (InfNameResolverSRV*)g_array_free(array, FALSE);
#else
  char ansbuf[4096];
  char hostbuf[256];
  int len;

  HEADER* header;
  int query_count;
  int answer_count;

  const char* msg;
  const char* cur;
  const char* end;

  InfNameResolverSRV* srvs;
  guint n_answers;
  int i;

  /* libresolv uses a global struct for its operation, and is not threadsafe.
   * Therefore, we protect this function callby a mutex. */
  static GMutex mutex;

  /* Make the DNS query */
  g_mutex_lock(&amp;mutex);

  *n_srvs = 0;
  h_errno = 0;
  len = res_query(query, C_IN, T_SRV, ansbuf, sizeof(ansbuf));

  if(h_errno != 0)
  {
    /* If the host was not found, simply return 0 SRV entries */
    if(h_errno != HOST_NOT_FOUND)
      inf_name_resolver_set_herrno_error(error, h_errno);
    g_mutex_unlock(&amp;mutex);
    return NULL;
  }

  /* At this point we have the DNS answer, and the rest of the function
   * is thread-safe. */
  g_mutex_unlock(&amp;mutex);

  if(len &lt; sizeof(HEADER))
  {
    inf_name_resolver_set_incomplete_error(error);
    return NULL;
  }

  msg = ansbuf;
  end = ansbuf + len;
  cur = ansbuf + sizeof(HEADER);

  header = (HEADER*)msg;
  query_count = ntohs(header-&gt;qdcount);
  answer_count = ntohs(header-&gt;ancount);

  /* Skip over the query */
  for(i = 0; i &lt; query_count; ++i)
  {
    len = dn_expand(msg, end, cur, hostbuf, sizeof(hostbuf));
    if(len &lt; 0)
    {
      inf_name_resolver_set_errno_error(error, errno);
      return NULL;
    }

    if(cur + len + QFIXEDSZ &gt; end)
    {
      inf_name_resolver_set_incomplete_error(error);
      return NULL;
    }

    cur += len + QFIXEDSZ;
  }

  /* Go over the answers */
  srvs = g_malloc(sizeof(InfNameResolverSRV) * answer_count);
  n_answers = 0;

  for(i = 0; i &lt; answer_count; ++i)
  {
    cur = inf_name_resolver_parse_srv_record(
      msg,
      end,
      cur,
      &amp;srvs[n_answers],
      error
    );

    if(cur == NULL)
    {
      for(i = 0; i &lt; n_answers; ++i)
        g_free(srvs[i].address);
      g_free(srvs);
      return NULL;
    }

    if(srvs[n_answers].address != NULL)
      ++n_answers;
  }
  
  if(n_answers &lt; answer_count)
    srvs = g_realloc(srvs, n_answers * sizeof(InfNameResolverSRV));

  *n_srvs = n_answers;
  return srvs;
#endif
}

static InfNameResolverEntry*
inf_name_resolver_lookup_a_aaaa(const gchar* hostname,
                                const gchar* service,
                                guint* n_entries,
                                GError** error)
{
  struct addrinfo hint;
  struct addrinfo* res;
  int err;

  GArray* array;
  InfNameResolverEntry entry;
  struct addrinfo* item;

#ifdef AI_ADDRCONFIG
  hint.ai_flags = AI_ADDRCONFIG;
#else
  hint.ai_flags = 0;
#endif
  hint.ai_family = AF_UNSPEC;
  hint.ai_socktype = SOCK_STREAM;
  hint.ai_protocol = 0;
  hint.ai_addrlen = 0;
  hint.ai_canonname = NULL;
  hint.ai_addr = NULL;
  hint.ai_next = NULL;

  res = NULL;
  err = getaddrinfo(hostname, service, &amp;hint, &amp;res);

  if(err != 0)
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string(&quot;GETADDRINFO_ERROR&quot;),
      err,
      gai_strerror(err)
    );

    *n_entries = 0;
    return NULL;
  }
  else
  {
    g_assert(res != NULL);
    array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverEntry));

    for(item = res; item != NULL; item = item-&gt;ai_next)
    {
      switch(item-&gt;ai_family)
      {
      case AF_INET:
        entry.address = inf_ip_address_new_raw4(
          ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_addr.s_addr
        );

        entry.port = ntohs( ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_port);
        break;
      case AF_INET6:
        entry.address = inf_ip_address_new_raw6(
          ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_addr.s6_addr
        );

        entry.port = ntohs( ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_port);
        break;
      default:
        g_assert_not_reached();
        break;
      }

      g_array_append_val(array, entry);
    }

    freeaddrinfo(res);

    *n_entries = array-&gt;len;
    return (InfNameResolverEntry*)g_array_free(array, FALSE);
  }
}

static InfNameResolverEntry*
inf_name_resolver_resolve_srv(InfNameResolverSRV** srvs,
                              guint* n_srvs,
                              const gchar* service,
                              guint* n_entries,
                              GError** error)
{
  gchar* srvaddr;
  guint srvport;
  GError* local_error;
  InfNameResolverEntry* entries;
  guint i;

  g_assert(*n_srvs &gt; 0);

  local_error = NULL;

  /* We have at least one SRV record. Choose one of the SRV records. */
  srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);

  while(srvaddr != NULL)
  {
    /* Look it up */
    entries = inf_name_resolver_lookup_a_aaaa(
      srvaddr,
      service,
      n_entries,
      &amp;local_error
    );

    g_free(srvaddr);
    srvaddr = NULL;

    /* If there was an error, try the next SRV record */
    if(entries == NULL)
    {
      if(*n_srvs &gt; 0)
        srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);

      /* Skip error if we have another record */
      if(srvaddr != NULL)
      {
        g_error_free(local_error);
        local_error = NULL;
      }
    }
    else
    {
      /* Fill in default port from SRV record */
      for(i = 0; i &lt; *n_entries; ++i)
        if(entries[i].port == 0)
          entries[i].port = srvport;

      /* Remember the remaining SRV entries, in case connecting to the
       * chosen one does not work. */
      return entries;
    }
  }

  /* SRV records exhausted; report last error */
  g_assert(local_error != NULL);
  g_propagate_error(error, local_error);
  return NULL;
}

static InfNameResolverResult*
inf_name_resolver_resolve(const gchar* hostname,
                          const gchar* service,
                          const gchar* srv)
{
  InfNameResolverResult* result;
  gchar* query;
  GError* error;

  error = NULL;

  result = g_slice_new(InfNameResolverResult);
  inf_name_resolver_result_nullify(result);

  /* Look up a SRV record */
  if(srv != NULL)
  {
    query = g_strdup_printf(&quot;%s.%s&quot;, srv, hostname);

    result-&gt;srvs = inf_name_resolver_lookup_srv(
      query,
      &amp;result-&gt;n_srvs,
      &amp;error
    );

    g_free(query);

    if(error != NULL)
    {
      g_warning(
        _(&quot;Failure during SRV record lookup: %s\n&quot;
          &quot;Will go on with normal A/AAAA lookup&quot;),
        error-&gt;message
      );

      g_error_free(error);
      error = NULL;
    }
    else if(result-&gt;n_srvs &gt; 0)
    {
      result-&gt;entries = inf_name_resolver_resolve_srv(
        &amp;result-&gt;srvs,
        &amp;result-&gt;n_srvs,
        service,
        &amp;result-&gt;n_entries,
        &amp;result-&gt;error
      );

      /* If we failed to look up the SRV record, we do not attempt to look up
       * the original hostname as A/AAAA record -- we only do that if no SRV
       * records exist. */
      return result;
    }
  }

  /* If that did not yield a result, lookup A/AAAA record */
  result-&gt;entries = inf_name_resolver_lookup_a_aaaa(
    hostname,
    service,
    &amp;result-&gt;n_entries,
    &amp;result-&gt;error
  );

  return result;
}

static void
inf_name_resolver_run_func(gpointer* run_data,
                           GDestroyNotify* run_notify,
                           gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;

  gchar* hostname;
  gchar* service;
  gchar* srv;

  InfNameResolverResult* result;

  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
<A NAME="1"></A>
  hostname = g_strdup(priv-&gt;hostname);
  service = g_strdup(priv-&gt;service);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match916-0.html#1',2,'match916-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  srv = g_strdup(priv-&gt;srv);
  g_object_unref(resolver);

  result = inf_name_resolver_resolve(hostname, service, srv);

  g_free(hostname);
  g_free(service);
  g_free(srv);

  *run_data = result;
  *run_notify = inf_name_resolver_result_free;
}

static void
inf_name_resolver_backup_run_func(gpointer* run_data,
                                  GDestroyNotify* run_notify,
                                  gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;
  gchar* service;

  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  result = g_slice_new(InfNameResolverResult);
  result-&gt;srvs = priv-&gt;result.srvs;
  result-&gt;n_srvs = priv-&gt;result.n_srvs;
  service = g_strdup(priv-&gt;service);

  priv-&gt;result.srvs = NULL;</B></FONT>
  priv-&gt;result.n_srvs = 0;
  g_object_unref(resolver);

  g_assert(result-&gt;n_srvs &gt; 0);

  result-&gt;error = NULL;

  result-&gt;entries = inf_name_resolver_resolve_srv(
    &amp;result-&gt;srvs,
    &amp;result-&gt;n_srvs,
    service,
    &amp;result-&gt;n_entries,
    &amp;result-&gt;error
  );

  g_free(service);

  *run_data = result;
  *run_notify = inf_name_resolver_result_free;
  
}

/* Main thread */

static void
inf_name_resolver_done_func(gpointer run_data,
                            gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;

  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  result = (InfNameResolverResult*)run_data;

  g_assert(priv-&gt;result.n_entries == 0);
  g_assert(priv-&gt;result.n_srvs == 0);
  g_assert(priv-&gt;result.error == NULL);

  priv-&gt;operation = NULL;
  priv-&gt;result = *result;

  /* Nullify this so that the destroy notify lets the data alive */
  inf_name_resolver_result_nullify(result);

  g_signal_emit(
    G_OBJECT(resolver),
    name_resolver_signals[RESOLVED],
    0,
    priv-&gt;result.error
  );
}

static void
inf_name_resolver_backup_done_func(gpointer run_data,
                                   gpointer user_data)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;
  InfNameResolverResult* result;
  guint i;

  resolver = INF_NAME_RESOLVER(user_data);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  result = (InfNameResolverResult*)run_data;

  g_assert(priv-&gt;result.n_srvs == 0);
  g_assert(priv-&gt;result.error == NULL);

  /* Push the remaining SRV entries back for later lookup */
  priv-&gt;operation = NULL;
  priv-&gt;result.srvs = result-&gt;srvs;
  priv-&gt;result.n_srvs = result-&gt;n_srvs;
  priv-&gt;result.error = result-&gt;error;

  /* If there are new addresses, append them */
  if(result-&gt;n_entries &gt; 0)
  {
    priv-&gt;result.entries = g_realloc(
      priv-&gt;result.entries,
      sizeof(InfNameResolverEntry) *
        (priv-&gt;result.n_entries + result-&gt;n_entries)
    );

    for(i = 0; i &lt; result-&gt;n_entries; ++i)
      priv-&gt;result.entries[priv-&gt;result.n_entries + i] = result-&gt;entries[i];

    priv-&gt;result.n_entries += result-&gt;n_entries;
  }

  /* Nullify this so that the destroy notify lets the data alive */
  inf_name_resolver_result_nullify(result);

  g_signal_emit(
    G_OBJECT(resolver),
    name_resolver_signals[RESOLVED],
    0,
    priv-&gt;result.error
  );
}

static void
inf_name_resolver_init(InfNameResolver* resolver)
{
  InfNameResolverPrivate* priv;
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  priv-&gt;io = NULL;
  priv-&gt;hostname = NULL;
  priv-&gt;service = NULL;
  priv-&gt;srv = NULL;

  priv-&gt;operation = NULL;

  inf_name_resolver_result_nullify(&amp;priv-&gt;result);
}

static void
inf_name_resolver_dispose(GObject* object)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;

  resolver = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  if(priv-&gt;operation != NULL)
  {
    inf_async_operation_free(priv-&gt;operation);
    priv-&gt;operation = NULL;
  }

  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
<A NAME="2"></A>  }

  G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;dispose(object);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match916-0.html#2',2,'match916-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

static void
inf_name_resolver_finalize(GObject* object)
{
  InfNameResolver* resolver;
  InfNameResolverPrivate* priv;

  resolver = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  inf_name_resolver_result_cleanup(&amp;priv-&gt;result);

  g_free(priv-&gt;hostname);
  g_free(priv-&gt;service);
  g_free(priv-&gt;srv);

  G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;finalize(object);
}

static void
inf_name_resolver_set_property(GObject* object,
                               guint prop_id,
                               const GValue* value,
                               GParamSpec* pspec)
{
  InfNameResolver* connection;
  InfNameResolverPrivate* priv;

  connection = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(connection);

  switch(prop_id)
  {
  case PROP_IO:</B></FONT>
    g_assert(priv-&gt;operation == NULL);

    if(priv-&gt;io != NULL) g_object_unref(priv-&gt;io);
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_HOSTNAME:
    g_assert(priv-&gt;operation == NULL);

    g_free(priv-&gt;hostname);
    priv-&gt;hostname = g_value_dup_string(value);
    break;
  case PROP_SERVICE:
    g_assert(priv-&gt;operation == NULL);

    g_free(priv-&gt;service);
    priv-&gt;service = g_value_dup_string(value);
    break;
  case PROP_SRV:
<A NAME="0"></A>    g_assert(priv-&gt;operation == NULL);

    g_free(priv-&gt;srv);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match916-0.html#0',2,'match916-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    priv-&gt;srv = g_value_dup_string(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_name_resolver_get_property(GObject* object,
                               guint prop_id,
                               GValue* value,
                               GParamSpec* pspec)
{
  InfNameResolver* connection;
  InfNameResolverPrivate* priv;

  connection = INF_NAME_RESOLVER(object);
  priv = INF_NAME_RESOLVER_PRIVATE(connection);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_HOSTNAME:
    g_value_set_string(value, priv-&gt;hostname);
    break;</B></FONT>
  case PROP_SERVICE:
    g_value_set_string(value, priv-&gt;service);
    break;
  case PROP_SRV:
    g_value_set_string(value, priv-&gt;srv);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_name_resolver_class_init(InfNameResolverClass* name_resolver_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(name_resolver_class);

  object_class-&gt;dispose = inf_name_resolver_dispose;
  object_class-&gt;finalize = inf_name_resolver_finalize;
  object_class-&gt;set_property = inf_name_resolver_set_property;
  object_class-&gt;get_property = inf_name_resolver_get_property;

  name_resolver_class-&gt;resolved = NULL;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;IO&quot;,
      &quot;I/O handler&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_HOSTNAME,
    g_param_spec_string(
      &quot;hostname&quot;,
      &quot;Hostname&quot;,
      &quot;The hostname to be looked up&quot;,
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SERVICE,
    g_param_spec_string(
      &quot;service&quot;,
      &quot;Service&quot;,
      &quot;The expected service at the remote endpoint&quot;,
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SRV,
    g_param_spec_string(
      &quot;srv&quot;,
      &quot;SRV&quot;,
      &quot;The SRV record to look up for the given hostname, e.g. _jabber._tcp&quot;,
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );

  /**
   * InfNameResolver::resolved:
   * @resolver: The #InfNameResolver that has resolved a hostname.
   * @error: A description of the error that occurred, or %NULL.
   *
   * This signal is emitted when the hostname has been resolved. The function
   * inf_name_resolver_get_address() and inf_name_resolver_get_port() can be
   * called to obtain the resolved addresses.
   */
  name_resolver_signals[RESOLVED] = g_signal_new(
    &quot;resolved&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfNameResolverClass, resolved),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}

/**
 * inf_name_resolver_new: (constructor)
 * @io: A #InfIo object used to schedule events in the main thread.
 * @hostname: The hostname to look up.
 * @service: (allow-none): The name of the service to look up, or %NULL.
 * @srv: (allow-none): The SRV record to look up, or %NULL.
 *
 * Creates a new #InfNameResolver. Use inf_name_resolver_start() to start
 * resolving the hostname.
 *
 * If @service is not %NULL, it should be a decimal port number or a
 * well-known service name that is translated into a port number, such as
 * &amp;quot;http&amp;quot. If @srv is not %NULL, the function will first attempt
 * a SRV lookup, and fall back to a regular A/AAAA lookup in case no SRV
 * record exists. Otherwise the SRV result is taken. If @service is
 * provided, it always overwrites the port number obtained from the hostname
 * lookup.
 *
 * The recommended procedure is to call this function with @service equal to
 * the port number entered by the user, or %NULL if the user did not provide
 * an explicit port number. If the resulting port number obtained with
 * inf_name_resolver_get_port() is then different from 0, then use that
 * port number, otherwise the default port number for the service.
 *
 * Returns: (transfer full): A new #InfNameResolver. Free with
 * g_object_unref().
 **/
InfNameResolver*
inf_name_resolver_new(InfIo* io,
                      const gchar* hostname,
                      const gchar* service,
                      const gchar* srv)
{
  InfNameResolver* resolver;

  g_return_val_if_fail(INF_IS_IO(io), NULL);

  resolver = INF_NAME_RESOLVER(
    g_object_new(
      INF_TYPE_NAME_RESOLVER,
      &quot;io&quot;, io,
      &quot;hostname&quot;, hostname,
      &quot;service&quot;, service,
      &quot;srv&quot;, srv,
      NULL
    )
  );

  return resolver;
}

/**
 * inf_name_resolver_get_hostname:
 * @resolver: A #InfNameResolver.
 *
 * Returns the currently configured hostname that @resolver will look up.
 *
 * Returns: (allow-none): The currently configured hostname.
 */
const gchar*
inf_name_resolver_get_hostname(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;hostname;
}

/**
 * inf_name_resolver_get_service:
 * @resolver: A #InfNameResolver.
 *
 * Returns the currently configured service that @resolver will look up.
 *
 * Returns: (allow-none): The currently configured service.
 */
const gchar*
inf_name_resolver_get_service(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;service;
}

/**
 * inf_name_resolver_get_srv:
 * @resolver: A #InfNameResolver.
 *
 * Returns the currently configured SRV record that @resolver will look up.
 *
 * Returns: (allow-none): The currently configured SRV record.
 */
const gchar*
inf_name_resolver_get_srv(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;srv;
}

/**
 * inf_name_resolver_start:
 * @resolver: A #InfNameResolver.
 * @error: Location to store error information, if any.
 *
 * Starts the name resolution for the hostname configured with @resolver.
 *
 * When the hostname lookup has finished, the #InfNameResolver::resolved
 * signal is emitted. The function can only be called again once this signal
 * has been emitted. When this function is called, the previously looked up
 * result can no longer be obtained with the inf_name_resolver_get_address()
 * and inf_name_resolver_get_port() functions.
 *
 * Returns: %TRUE on success or %FALSE if a (synchronous) error occurred.
 */
gboolean
inf_name_resolver_start(InfNameResolver* resolver,
                        GError** error)
{
  InfNameResolverPrivate* priv;
  gboolean success;

  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);

  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);

  inf_name_resolver_result_cleanup(&amp;priv-&gt;result);
  inf_name_resolver_result_nullify(&amp;priv-&gt;result);

  priv-&gt;operation = inf_async_operation_new(
    priv-&gt;io,
    inf_name_resolver_run_func,
    inf_name_resolver_done_func,
    resolver
  );

  g_object_ref(resolver);
  success = inf_async_operation_start(priv-&gt;operation, error);

  if(success == FALSE)
  {
    g_object_unref(resolver);
    priv-&gt;operation = FALSE;
    return FALSE;
  }

  /* The launched thread takes over the reference on resolver */
  return TRUE;
}

/**
 * inf_name_resolver_lookup_backup:
 * @resolver: A #InfNameResolver.
 * @error: Location to store error information, if any, or %NULL.
 *
 * Tries to look up backup addresses for the configured hostname. This should
 * be used if connecting to none of the initially reported addresses works.
 * The function returns %FALSE if there are no backup addresses available, or
 * %TRUE otherwise. If it returns %TRUE, it the #InfNameResolver::resolved
 * signal will be emitted again, and when it is, more addresses might be
 * available from the resolver object.
 *
 * Returns: %TRUE if looking up backup addresses is attempted, or %FALSE
 * otherwise.
 */
gboolean
inf_name_resolver_lookup_backup(InfNameResolver* resolver,
                                GError** error)
{
  InfNameResolverPrivate* priv;
  gboolean success;

  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);

  priv = INF_NAME_RESOLVER_PRIVATE(resolver);
  g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);

  if(priv-&gt;result.n_srvs == 0)
    return FALSE;

  if(priv-&gt;result.error != NULL)
  {
    g_error_free(priv-&gt;result.error);
    priv-&gt;result.error = NULL;
  }

  priv-&gt;operation = inf_async_operation_new(
    priv-&gt;io,
    inf_name_resolver_backup_run_func,
    inf_name_resolver_backup_done_func,
    resolver
  );

  g_object_ref(resolver);
  success = inf_async_operation_start(priv-&gt;operation, error);

  if(success == FALSE)
  {
    g_object_unref(resolver);
    priv-&gt;operation = FALSE;
    return FALSE;
  }

  /* The launched thread takes over the reference on resolver */
  return TRUE;
}

/**
 * inf_name_resolver_finished:
 * @resolver: A #InfNameResolver.
 *
 * Returns whether the resolver is currently looking up a hostname, or whether
 * it is ready to start a new lookup with inf_name_resolver_start().
 *
 * Returns: Whether a call to inf_name_resolver_start() can be made.
 */
gboolean
inf_name_resolver_finished(InfNameResolver* resolver)
{
  InfNameResolverPrivate* priv;

  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);

  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  if(priv-&gt;operation != NULL)
    return FALSE;

  return TRUE;
}

/**
 * inf_name_resolver_get_n_addresses:
 * @resolver: A #InfNameResolver.
 *
 * Returns the number of resolved addresses that belongs to the hostname
 * that was looked up.
 *
 * Returns: The number of addresses available.
 */
guint
inf_name_resolver_get_n_addresses(InfNameResolver* resolver)
{
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);
  return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;result.n_entries;
}

/**
 * inf_name_resolver_get_address:
 * @resolver: A #InfNameResolver.
 * @index: The index for which to return the address, in case multiple
 * IP addresses correspond to the same hostname.
 *
 * Returns the @index&lt;!-- --&gt;th address looked up in the last hostname
 * resolution operation.
 *
 * Returns: (transfer none): The looked up #InfIpAddress.
 */
const InfIpAddress*
inf_name_resolver_get_address(InfNameResolver* resolver,
                              guint index)
{
  InfNameResolverPrivate* priv;

  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);

  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, NULL);
  return priv-&gt;result.entries[index].address;
}

/**
 * inf_name_resolver_get_port:
 * @resolver: A #InfNameResolver.
 * @index: The index for which to return the port, in case multiple
 * IP addresses correspond to the same hostname.
 *
 * Returns the @index&lt;!-- --&gt;th port looked up in the last hostname
 * resolution operation. This can be 0 if the @service parameter in
 * inf_name_resolver_start() has been set to %NULL and no SRV record has
 * been found.
 *
 * Returns: The looked up #InfIpAddress.
 */
guint
inf_name_resolver_get_port(InfNameResolver* resolver,
                           guint index)
{
  InfNameResolverPrivate* priv;

  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);

  priv = INF_NAME_RESOLVER_PRIVATE(resolver);

  g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, 0);
  return priv-&gt;result.entries[index].port;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
