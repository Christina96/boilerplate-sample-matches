<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-remote-delete-operation.c &amp; inf-name-resolver.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-remote-delete-operation.c &amp; inf-name-resolver.c
      </h3>
<h1 align="center">
        11.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-remote-delete-operation.c (17.816092%)<th>inf-name-resolver.c (8.378378%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(249-276)<td><a href="#" name="0">(1025-1052)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(675-723)<td><a href="#" name="1">(797-828)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(215-245)<td><a href="#" name="2">(969-1003)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(36-62)<td><a href="#" name="3">(84-118)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-remote-delete-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
2 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
3 #include &lt;libinftext/inf-text-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-insert-operation.h&gt;
5 #include &lt;libinftext/inf-text-buffer.h&gt;
6 #include &lt;libinfinity/adopted/inf-adopted-split-operation.h&gt;
7 #include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
8 #include &lt;libinfinity/inf-i18n.h&gt;
9 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextRemoteDeleteOperationRecon
10   InfTextRemoteDeleteOperationRecon;
11 struct _InfTextRemoteDeleteOperationRecon {
12   guint position;
13   InfTextChunk* chunk;
14 };
15 typedef struct _InfTextRemoteDeleteOperationPrivate
16   InfTextRemoteDeleteOperationPrivate;
17 struct _InfTextRemoteDeleteOperationPrivate {
18   guint position;
19   guint length;
20   GSList* recon;
21   guint recon_offset;
22 };
23 enum {
24   PROP_0,
25   PROP_POSITION,
26   PROP_LENGTH
27 };</b></font>
28 #define INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_REMOTE_DELETE_OPERATION, InfTextRemoteDeleteOperationPrivate))
29 static void inf_text_remote_delete_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
30 static void inf_text_remote_delete_operation_delete_operation_iface_init(InfTextDeleteOperationInterface* iface);
31 G_DEFINE_TYPE_WITH_CODE(InfTextRemoteDeleteOperation, inf_text_remote_delete_operation, G_TYPE_OBJECT,
32   G_ADD_PRIVATE(InfTextRemoteDeleteOperation)
33   G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_remote_delete_operation_operation_iface_init)
34   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_DELETE_OPERATION, inf_text_remote_delete_operation_delete_operation_iface_init))
35 static GSList*
36 g_slist_append_fast(GSList* list,
37                     GSList** last,
38                     gpointer item)
39 {
40   GSList* temp;
41   g_assert(last != NULL);
42   if(list == NULL)
43   {
44     list = g_slist_prepend(list, item);
45     *last = list;
46   }
47   else
48   {
49     g_assert(*last != NULL);
50     temp = g_slist_append(*last, item);
51     *last = (*last)-&gt;next;
52   }
53   return list;
54 }
55 static GSList*
56 inf_text_remote_delete_operation_recon_copy(GSList* recon_list)
57 {
58   GSList* item;
59   InfTextRemoteDeleteOperationRecon* recon;
60   GSList* new_list;
61   GSList* last;
62   InfTextRemoteDeleteOperationRecon* new_recon;
63   new_list = NULL;
64   for(item = recon_list; item != NULL; item = g_slist_next(item))
65   {
66     recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
67     new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
68     new_recon-&gt;position = recon-&gt;position;
69     new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
70     new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
71   }
72   return new_list;
73 }
74 static void
75 inf_text_remote_delete_operation_recon_free(GSList* recon_list)
76 {
77   GSList* item;
78   InfTextRemoteDeleteOperationRecon* recon;
79   for(item = recon_list; item != NULL; item = g_slist_next(item))
80   {
81     recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
82     inf_text_chunk_free(recon-&gt;chunk);
83     g_slice_free(InfTextRemoteDeleteOperationRecon, recon);
84   }
85   g_slist_free(recon_list);
86 }
87 static GSList*
88 inf_text_remote_delete_operation_recon_feed(GSList* recon_list,
89                                             guint position,
90                                             InfTextChunk* chunk)
91 {
92   GSList* item;
93   InfTextRemoteDeleteOperationRecon* recon;
94   GSList* new_list;
95   GSList* last;
96   InfTextRemoteDeleteOperationRecon* new_recon;
97   guint text_pos;
98   guint cur_len;
99   guint text_len;
100   new_list = NULL;
101   text_pos = 0;
102   cur_len = 0;
103   for(item = recon_list; item != NULL; item = g_slist_next(item))
104   {
105     recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
106     if(position + text_pos + cur_len &lt; recon-&gt;position &amp;&amp;
107        text_pos &lt; inf_text_chunk_get_length(chunk))
108     {
109       text_len = recon-&gt;position - position - text_pos - cur_len;
110       if(text_len &gt; inf_text_chunk_get_length(chunk) - text_pos)
111         text_len = inf_text_chunk_get_length(chunk) - text_pos;
112       new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
113       new_recon-&gt;position = position + text_pos + cur_len;
114       new_recon-&gt;chunk = inf_text_chunk_substring(chunk, text_pos, text_len);
115       new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
116       text_pos += text_len;
117     }
118     cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
119     new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
120     new_recon-&gt;position = recon-&gt;position;
121     new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
122     new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
123   }
124   if(text_pos &lt; inf_text_chunk_get_length(chunk))
125   {
126     new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
127     new_recon-&gt;position = position + text_pos + cur_len;
128     new_recon-&gt;chunk = inf_text_chunk_substring(
129       chunk,
130       text_pos,
131       inf_text_chunk_get_length(chunk) - text_pos
132     );
133     new_list = g_slist_append_fast(new_list, &amp;last, new_recon);
134   }
135   return new_list;
136 }
137 static void
138 inf_text_remote_delete_operation_init(InfTextRemoteDeleteOperation* operation)
139 {
140   InfTextRemoteDeleteOperationPrivate* priv;
141   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
142   priv-&gt;position = 0;
143   priv-&gt;length = 0;
144 <a name="2"></a>
145   priv-&gt;recon = NULL;
146   priv-&gt;recon_offset = 0;
147 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
148 static void
149 inf_text_remote_delete_operation_finalize(GObject* object)
150 {
151   InfTextRemoteDeleteOperation* operation;
152   InfTextRemoteDeleteOperationPrivate* priv;
153   operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
154   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
155   inf_text_remote_delete_operation_recon_free(priv-&gt;recon);
156   G_OBJECT_CLASS(inf_text_remote_delete_operation_parent_class)-&gt;finalize(object);
157 }
158 static void
159 inf_text_remote_delete_operation_set_property(GObject* object,
160                                               guint prop_id,
161                                               const GValue* value,
162                                               GParamSpec* pspec)
163 {
164   InfTextRemoteDeleteOperation* operation;
165   InfTextRemoteDeleteOperationPrivate* priv;
166   operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
167   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
168   switch(prop_id)
169   {
170   case PROP_POSITION:</b></font>
171 <a name="0"></a>    priv-&gt;position = g_value_get_uint(value);
172     break;
173   case PROP_LENGTH:
174 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;length = g_value_get_uint(value);
175     break;
176   default:
177     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
178     break;
179   }
180 }
181 static void
182 inf_text_remote_delete_operation_get_property(GObject* object,
183                                               guint prop_id,
184                                               GValue* value,
185                                               GParamSpec* pspec)
186 {
187   InfTextRemoteDeleteOperation* operation;
188   InfTextRemoteDeleteOperationPrivate* priv;
189   operation = INF_TEXT_REMOTE_DELETE_OPERATION(object);
190   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
191   switch(prop_id)
192   {
193   case PROP_POSITION:
194     g_value_set_uint(value, priv-&gt;position);
195     break;
196   case PROP_LENGTH:
197     g_value_set_uint(value, priv-&gt;length);
198     break;</b></font>
199   default:
200     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
201     break;
202   }
203 }
204 static gboolean
205 inf_text_remote_delete_operation_need_concurrency_id(
206   InfAdoptedOperation* operation,
207   InfAdoptedOperation* against)
208 {
209   g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
210   return inf_text_delete_operation_need_concurrency_id(
211     INF_TEXT_DELETE_OPERATION(operation),
212     against
213   );
214 }
215 static InfAdoptedOperation*
216 inf_text_remote_delete_operation_transform(InfAdoptedOperation* operation,
217                                            InfAdoptedOperation* against,
218                                            InfAdoptedOperation* operation_lcs,
219                                            InfAdoptedOperation* against_lcs,
220                                            InfAdoptedConcurrencyId cid)
221 {
222   g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
223   if(INF_TEXT_IS_INSERT_OPERATION(against))
224   {
225     return inf_text_delete_operation_transform_insert(
226       INF_TEXT_DELETE_OPERATION(operation),
227       INF_TEXT_INSERT_OPERATION(against)
228     );
229   }
230   else if(INF_TEXT_IS_DELETE_OPERATION(against))
231   {
232     return inf_text_delete_operation_transform_delete(
233       INF_TEXT_DELETE_OPERATION(operation),
234       INF_TEXT_DELETE_OPERATION(against)
235     );
236   }
237   else
238   {
239     g_assert_not_reached();
240     return NULL;
241   }
242 }
243 static InfAdoptedOperation*
244 inf_text_remote_delete_operation_copy(InfAdoptedOperation* operation)
245 {
246   InfTextRemoteDeleteOperationPrivate* priv;
247   GObject* result;
248   InfTextRemoteDeleteOperationPrivate* result_priv;
249   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
250   result = g_object_new(
251     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
252     "position", priv-&gt;position,
253     "length", priv-&gt;length,
254     NULL
255   );
256   result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
257   result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
258     priv-&gt;recon
259   );
260   result_priv-&gt;recon_offset = priv-&gt;recon_offset;
261   return INF_ADOPTED_OPERATION(result);
262 }
263 static InfAdoptedOperationFlags
264 inf_text_remote_delete_operation_get_flags(InfAdoptedOperation* operation)
265 {
266   return INF_ADOPTED_OPERATION_AFFECTS_BUFFER;
267 }
268 static gboolean
269 inf_text_remote_delete_operation_apply(InfAdoptedOperation* operation,
270                                        InfAdoptedUser* by,
271                                        InfBuffer* buffer,
272                                        GError** error)
273 {
274   InfTextRemoteDeleteOperationPrivate* priv;
275   g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(operation));
276   g_assert(INF_TEXT_IS_BUFFER(buffer));
277   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
278   if(priv-&gt;position + priv-&gt;length &gt;
279      inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
280   {
281     g_set_error_literal(
282       error,
283       g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
284       INF_TEXT_OPERATION_ERROR_INVALID_DELETE,
285       _("Attempt to remove text from after the end of the document")
286     );
287     return FALSE;
288   }
289   else
290   {
291     inf_text_buffer_erase_text(
292       INF_TEXT_BUFFER(buffer),
293       priv-&gt;position,
294       priv-&gt;length,
295       INF_USER(by)
296     );
297     return TRUE;
298   }
299 }
300 static InfAdoptedOperation*
301 inf_text_remote_delete_operation_apply_transformed(InfAdoptedOperation* op,
302                                                    InfAdoptedOperation* trans,
303                                                    InfAdoptedUser* by,
304                                                    InfBuffer* buffer,
305                                                    GError** error)
306 {
307   InfTextRemoteDeleteOperationPrivate* priv;
308   InfTextChunk* chunk;
309   InfTextChunk* temp_slice;
310   GSList* list;
311   GSList* item;
312   InfAdoptedOperation* operation;
313   GSList* recon_list;
314   GSList* recon_item;
315   InfTextRemoteDeleteOperationRecon* recon;
316   InfTextDefaultDeleteOperation* result;
317   g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(op));
318   g_assert(INF_TEXT_IS_BUFFER(buffer));
319   if(INF_ADOPTED_IS_SPLIT_OPERATION(trans))
320   {
321     list = inf_adopted_split_operation_unsplit(
322       INF_ADOPTED_SPLIT_OPERATION(trans)
323     );
324   }
325   else
326   {
327     list = g_slist_prepend(NULL, trans);
328   }
329   chunk = inf_text_chunk_new(
330     inf_text_buffer_get_encoding(INF_TEXT_BUFFER(buffer))
331   );
332   for(item = list; item != NULL; item = g_slist_next(item))
333   {
334     g_assert(INF_TEXT_IS_REMOTE_DELETE_OPERATION(item-&gt;data));
335     priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(item-&gt;data);
336     operation = INF_ADOPTED_OPERATION(item-&gt;data);
337     if(priv-&gt;length &gt; 0)
338     {
339       temp_slice = inf_text_buffer_get_slice(
340         INF_TEXT_BUFFER(buffer),
341         priv-&gt;position,
342         priv-&gt;length
343       );
344       recon_list = inf_text_remote_delete_operation_recon_feed(
345         priv-&gt;recon,
346         0,
347         temp_slice
348       );
349       inf_text_chunk_free(temp_slice);
350     }
351     else
352     {
353       recon_list = priv-&gt;recon;
354     }
355     for(recon_item = recon_list;
356         recon_item != NULL;
357         recon_item = g_slist_next(recon_item))
358     {
359       recon = (InfTextRemoteDeleteOperationRecon*)recon_item-&gt;data;
360       g_assert(priv-&gt;recon_offset + recon-&gt;position ==
361                inf_text_chunk_get_length(chunk));
362       inf_text_chunk_insert_chunk(
363         chunk,
364         inf_text_chunk_get_length(chunk),
365         recon-&gt;chunk
366       );
367     }
368     if(priv-&gt;length &gt; 0)
369       inf_text_remote_delete_operation_recon_free(recon_list);
370     if(!inf_adopted_operation_apply(operation, by, buffer, error))
371     {
372       g_slist_free(list);
373       inf_text_chunk_free(chunk);
374       return NULL;
375     }
376   }
377   g_slist_free(list);
378   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(op);
379   result = inf_text_default_delete_operation_new(priv-&gt;position, chunk);
380   inf_text_chunk_free(chunk);
381   return INF_ADOPTED_OPERATION(result);
382 }
383 static guint
384 inf_text_remote_delete_operation_get_position(
385   InfTextDeleteOperation* operation)
386 {
387   return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;position;
388 }
389 static guint
390 inf_text_remote_delete_operation_get_length(InfTextDeleteOperation* operation)
391 {
392   return INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation)-&gt;length;
393 }
394 static InfTextDeleteOperation*
395 inf_text_remote_delete_operation_transform_position(
396   InfTextDeleteOperation* operation,
397   guint position)
398 {
399   InfTextRemoteDeleteOperationPrivate* priv;
400   GObject* result;
401   InfTextRemoteDeleteOperationPrivate* result_priv;
402   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
403   result = g_object_new(
404     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
405     "position", position,
406     "length", priv-&gt;length,
407     NULL
408   );
409   result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
410   result_priv-&gt;recon = inf_text_remote_delete_operation_recon_copy(
411     priv-&gt;recon
412   );
413   result_priv-&gt;recon_offset = priv-&gt;recon_offset;
414   return INF_TEXT_DELETE_OPERATION(result);
415 }
416 static InfTextDeleteOperation*
417 inf_text_remote_delete_operation_transform_overlap(
418   InfTextDeleteOperation* operation,
419   InfTextDeleteOperation* other,
420   guint position,
421   guint begin,
422   guint other_begin,
423   guint length)
424 {
425   InfTextRemoteDeleteOperationPrivate* priv;
426   InfTextChunk* chunk;
427   GObject* result;
428   InfTextRemoteDeleteOperationPrivate* result_priv;
429   g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(other));
430   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
431   chunk = inf_text_chunk_substring(
432     inf_text_default_delete_operation_get_chunk(
433       INF_TEXT_DEFAULT_DELETE_OPERATION(other)
434     ),
435     other_begin,
436     length
437   );
438   result = g_object_new(
439     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
440     "position", position,
441     "length", priv-&gt;length - length,
442     NULL
443   );
444   result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(result);
445   result_priv-&gt;recon = inf_text_remote_delete_operation_recon_feed(
446     priv-&gt;recon,
447     begin,
448     chunk
449   );
450   inf_text_chunk_free(chunk);
451   result_priv-&gt;recon_offset = priv-&gt;recon_offset;
452   return INF_TEXT_DELETE_OPERATION(result);
453 }
454 static InfAdoptedSplitOperation*
455 inf_text_remote_delete_operation_transform_split(
456   InfTextDeleteOperation* operation,
457   guint split_pos,
458   guint split_len)
459 {
460   InfTextRemoteDeleteOperationPrivate* priv;
461   InfAdoptedSplitOperation* result;
462   GObject* first_operation;
463   GObject* second_operation;
464   InfTextRemoteDeleteOperationPrivate* result_priv;
465   InfTextRemoteDeleteOperationRecon* recon;
466   InfTextRemoteDeleteOperationRecon* new_recon;
467   GSList* first_recon;
468   GSList* second_recon;
469   guint recon_cur_len;
470   GSList* item;
471   priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(operation);
472   first_recon = NULL;
473   second_recon = NULL;
474   recon_cur_len = 0;
475   for(item = priv-&gt;recon; item != NULL; item = g_slist_next(item))
476   {
477     recon = (InfTextRemoteDeleteOperationRecon*)item-&gt;data;
478     g_assert(recon-&gt;position &gt;= recon_cur_len);
479     if(recon-&gt;position - recon_cur_len &lt;= split_pos)
480     {
481       new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
482       new_recon-&gt;position = recon-&gt;position;
483       new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
484       first_recon = g_slist_prepend(first_recon, new_recon);
485       recon_cur_len += inf_text_chunk_get_length(recon-&gt;chunk);
486     }
487     else
488     {
489       new_recon = g_slice_new(InfTextRemoteDeleteOperationRecon);
490       new_recon-&gt;position = recon-&gt;position - (split_pos + recon_cur_len);
491       new_recon-&gt;chunk = inf_text_chunk_copy(recon-&gt;chunk);
492       second_recon = g_slist_prepend(second_recon, new_recon);
493     }
494   }
495   first_operation = g_object_new(
496     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
497     "position", priv-&gt;position,
498     "length", split_pos,
499     NULL
500   );
501   second_operation = g_object_new(
502     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
503     "position", priv-&gt;position + split_len,
504     "length", priv-&gt;length - split_pos,
505     NULL
506   );
507   result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(first_operation);
508   result_priv-&gt;recon = g_slist_reverse(first_recon);
509   result_priv-&gt;recon_offset = priv-&gt;recon_offset;
510   result_priv = INF_TEXT_REMOTE_DELETE_OPERATION_PRIVATE(second_operation);
511   result_priv-&gt;recon = g_slist_reverse(second_recon);
512   result_priv-&gt;recon_offset = priv-&gt;recon_offset + split_pos + recon_cur_len;
513   result = inf_adopted_split_operation_new(
514     INF_ADOPTED_OPERATION(first_operation),
515     INF_ADOPTED_OPERATION(second_operation)
516   );
517   g_object_unref(G_OBJECT(second_operation));
518   g_object_unref(G_OBJECT(first_operation));
519   return result;
520 }
521 static void
522 inf_text_remote_delete_operation_class_init(
523 <a name="1"></a>  InfTextRemoteDeleteOperationClass* remote_delete_operation_class)
524 {
525   GObjectClass* object_class;
526 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  object_class = G_OBJECT_CLASS(remote_delete_operation_class);
527   object_class-&gt;finalize = inf_text_remote_delete_operation_finalize;
528   object_class-&gt;set_property = inf_text_remote_delete_operation_set_property;
529   object_class-&gt;get_property = inf_text_remote_delete_operation_get_property;
530   g_object_class_install_property(
531     object_class,
532     PROP_POSITION,
533     g_param_spec_uint(
534       "position",
535       "Position",
536       "Position where to start deleting characters",
537       0,
538       G_MAXUINT,
539       0,
540       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
541     )
542   );
543   g_object_class_install_property(
544     object_class,
545     PROP_LENGTH,
546     g_param_spec_uint(
547       "length",
548       "Length",
549       "The length of the deleted text",
550       0,
551       G_MAXUINT,
552       0,
553       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
554     )
555   );
556 }
557 static void
558 inf_text_remote_delete_operation_operation_iface_init(
559   InfAdoptedOperationInterface* iface)
560 {
561   iface-&gt;need_concurrency_id =
562     inf_text_remote_delete_operation_need_concurrency_id;
563   iface-&gt;transform = inf_text_remote_delete_operation_transform;
564   iface-&gt;copy = inf_text_remote_delete_operation_copy;
565   iface-&gt;get_flags = inf_text_remote_delete_operation_get_flags;
566   iface-&gt;apply = inf_text_remote_delete_operation_apply;
567   iface-&gt;apply_transformed =
568     inf_text_remote_delete_operation_apply_transformed;
569   iface-&gt;revert = NULL;</b></font>
570 }
571 static void
572 inf_text_remote_delete_operation_delete_operation_iface_init(
573   InfTextDeleteOperationInterface* iface)
574 {
575   iface-&gt;get_position = inf_text_remote_delete_operation_get_position;
576   iface-&gt;get_length = inf_text_remote_delete_operation_get_length;
577   iface-&gt;transform_position =
578     inf_text_remote_delete_operation_transform_position;
579   iface-&gt;transform_overlap =
580     inf_text_remote_delete_operation_transform_overlap;
581   iface-&gt;transform_split = inf_text_remote_delete_operation_transform_split;
582 }
583 InfTextRemoteDeleteOperation*
584 inf_text_remote_delete_operation_new(guint position,
585                                      guint length)
586 {
587   GObject* object;
588   object = g_object_new(
589     INF_TEXT_TYPE_REMOTE_DELETE_OPERATION,
590     "position", position,
591     "length", length,
592     NULL
593   );
594   return INF_TEXT_REMOTE_DELETE_OPERATION(object);
595 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-name-resolver.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-name-resolver.h&gt;
2 #include &lt;libinfinity/common/inf-async-operation.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #ifdef G_OS_WIN32
5 # include &lt;ws2tcpip.h&gt;
6 # include &lt;wspiapi.h&gt;
7 #else
8 # include &lt;sys/types.h&gt;
9 # include &lt;sys/socket.h&gt;
10 # include &lt;netinet/in.h&gt; # include &lt;netdb.h&gt;
11 #endif
12 #ifdef G_OS_WIN32
13 # include &lt;windns.h&gt;
14 #else
15 # include &lt;resolv.h&gt;
16 # include &lt;arpa/nameser.h&gt;
17 # include &lt;arpa/nameser_compat.h&gt;
18 #endif
19 #include &lt;errno.h&gt;
20 #include &lt;string.h&gt;
21 typedef struct _InfNameResolverEntry InfNameResolverEntry;
22 struct _InfNameResolverEntry {
23   InfIpAddress* address;
24   guint port;
25 };
26 typedef struct _InfNameResolverSRV InfNameResolverSRV;
27 struct _InfNameResolverSRV {
28   guint priority;
29   guint weight;
30   guint port;
31 <a name="3"></a>  gchar* address;
32 };
33 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfNameResolverResult InfNameResolverResult;
34 struct _InfNameResolverResult {
35   InfNameResolverEntry* entries;
36   guint n_entries;
37   InfNameResolverSRV* srvs;
38   guint n_srvs;
39   GError* error;
40 };
41 typedef struct _InfNameResolverPrivate InfNameResolverPrivate;
42 struct _InfNameResolverPrivate {
43   InfIo* io;
44   gchar* hostname;
45   gchar* service;
46   gchar* srv;
47   InfAsyncOperation* operation;
48   InfNameResolverResult result;
49 };
50 enum {
51   PROP_0,
52   PROP_IO,
53   PROP_HOSTNAME,
54   PROP_SERVICE,
55   PROP_SRV
56 };</b></font>
57 enum {
58   RESOLVED,
59   LAST_SIGNAL
60 };
61 #define INF_NAME_RESOLVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_NAME_RESOLVER, InfNameResolverPrivate))
62 static guint name_resolver_signals[LAST_SIGNAL];
63 G_DEFINE_TYPE_WITH_CODE(InfNameResolver, inf_name_resolver, G_TYPE_OBJECT,
64   G_ADD_PRIVATE(InfNameResolver))
65 static void
66 inf_name_resolver_result_nullify(InfNameResolverResult* result)
67 {
68   result-&gt;entries = NULL;
69   result-&gt;n_entries = 0;
70   result-&gt;srvs = NULL;
71   result-&gt;n_srvs = 0;
72   result-&gt;error = NULL;
73 }
74 static void
75 inf_name_resolver_result_cleanup(InfNameResolverResult* result)
76 {
77   guint i;
78   for(i = 0; i &lt; result-&gt;n_entries; ++i)
79     inf_ip_address_free(result-&gt;entries[i].address);
80   g_free(result-&gt;entries);
81   for(i = 0; i &lt; result-&gt;n_srvs; ++i)
82     g_free(result-&gt;srvs[i].address);
83   g_free(result-&gt;srvs);
84   if(result-&gt;error != NULL)
85     g_error_free(result-&gt;error);
86 }
87 static void
88 inf_name_resolver_result_free(gpointer result_ptr)
89 {
90   InfNameResolverResult* result;
91   result = (InfNameResolverResult*)result_ptr;
92   inf_name_resolver_result_cleanup(result);
93   g_slice_free(InfNameResolverResult, result);
94 }
95 #ifndef G_OS_WIN32
96 static void
97 inf_name_resolver_set_herrno_error(GError** error,
98                                    int code)
99 {
100   g_set_error_literal(
101     error,
102     g_quark_from_static_string("INF_NAME_RESOLVER_HERRNO_ERROR"),
103     code,
104     hstrerror(code)
105   );
106 }
107 static void
108 inf_name_resolver_set_errno_error(GError** error,
109                                   int code)
110 {
111   g_set_error_literal(
112     error,
113     g_quark_from_static_string("INF_NAME_RESOLVER_ERRNO_ERROR"),
114     code,
115     strerror(code)
116   );
117 }
118 static void
119 inf_name_resolver_set_incomplete_error(GError** error)
120 {
121   g_set_error_literal(
122     error,
123     g_quark_from_static_string("INF_NAME_RESOLVER_INCOMPLETE_ERROR"),
124     0,
125     _("The reply from the DNS server is incomplete")
126   );
127 }
128 static const char*
129 inf_name_resolver_parse_dns_uint16(const char* msg,
130                                    const char* end,
131                                    const char* cur,
132                                    guint16* result,
133                                    GError** error)
134 {
135   if(cur + 2 &gt; end)
136   {
137     inf_name_resolver_set_incomplete_error(error);
138     return NULL;
139   }
140   *result = ntohs(*((guint16*)cur));
141   return cur + 2;
142 }
143 static const char*
144 inf_name_resolver_parse_dns_uint32(const char* msg,
145                                    const char* end,
146                                    const char* cur,
147                                    guint32* result,
148                                    GError** error)
149 {
150   if(cur + 4 &gt; end)
151   {
152     inf_name_resolver_set_incomplete_error(error);
153     return NULL;
154   }
155   *result = ntohl(*((guint32*)cur));
156   return cur + 4;
157 }
158 static const char*
159 inf_name_resolver_parse_dns_host(const char* msg,
160                                  const char* end,
161                                  const char* cur,
162                                  gchar* result,
163                                  gsize reslen,
164                                  GError** error)
165 {
166   int len;
167   len = dn_expand(msg, end, cur, result, reslen);
168   if(len &lt; 0)
169   {
170     inf_name_resolver_set_errno_error(error, errno);
171     return NULL;
172   }
173   if(cur + len &gt; end)
174   {
175     inf_name_resolver_set_incomplete_error(error);
176     return NULL;
177   }
178   return cur + len;
179 }
180 static const char*
181 inf_name_resolver_parse_srv_record(const char* msg,
182                                    const char* end,
183                                    const char* cur,
184                                    InfNameResolverSRV* srv,
185                                    GError** error)
186 {
187   gchar buf[256];
188   gsize bufsize;
189   guint16 type;
190   guint16 cls;
191   guint32 ttl;
192   guint16 msglen;
193   guint16 prio;
194   guint16 weight;
195   guint16 port;
196   bufsize = sizeof(buf);
197   cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
198   if(cur == NULL) return NULL;
199   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;type, error);
200   if(cur == NULL) return NULL;
201   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;cls, error);
202   if(cur == NULL) return NULL;
203   cur = inf_name_resolver_parse_dns_uint32(msg, end, cur, &amp;ttl, error);
204   if(cur == NULL) return NULL;
205   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;msglen, error);
206   if(cur == NULL) return NULL;
207   if(type != T_SRV)
208   {
209     srv-&gt;address = NULL;
210     cur += msglen;
211     return cur;
212   }
213   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;prio, error);
214   if(cur == NULL) return NULL;
215   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;weight, error);
216   if(cur == NULL) return NULL;
217   cur = inf_name_resolver_parse_dns_uint16(msg, end, cur, &amp;port, error);
218   if(cur == NULL) return NULL;
219   cur = inf_name_resolver_parse_dns_host(msg, end, cur, buf, bufsize, error);
220   if(cur == NULL) return NULL;
221   srv-&gt;priority = prio;
222   srv-&gt;weight = weight;
223   srv-&gt;port = port;
224   srv-&gt;address = g_strdup(buf);
225   return cur;
226 }
227 #endif
228 static gchar*
229 inf_name_resolver_choose_srv(InfNameResolverSRV** srvs,
230                              guint* n_srvs,
231                              guint* port)
232 {
233   InfNameResolverSRV** low_prio_srvs;
234   guint n_low_prio_srvs;
235   guint total_weight;
236   guint accum_weight;
237   guint rand;
238   guint i;
239   guint index;
240   gchar* selected_address;
241   guint selected_port;
242   g_assert(*n_srvs &gt; 0);
243   low_prio_srvs = g_malloc(sizeof(InfNameResolverSRV*) * (*n_srvs));
244   n_low_prio_srvs = 0;
245   total_weight = 0;
246   for(i = 0; i &lt; *n_srvs; ++i)
247   {
248     if(n_low_prio_srvs == 0 ||
249        (*srvs)[i].priority &lt; low_prio_srvs[0]-&gt;priority)
250     {
251       n_low_prio_srvs = 1;
252       low_prio_srvs[0] = &amp;(*srvs)[i];
253       total_weight = (*srvs)[i].weight;
254     }
255     else if( (*srvs)[i].priority == low_prio_srvs[0]-&gt;priority)
256     {
257       low_prio_srvs[n_low_prio_srvs++] = &amp;(*srvs)[i];
258       total_weight += (*srvs)[i].weight;
259     }
260   }
261   if(total_weight == 0)
262   {
263     i = g_random_int_range(0, n_low_prio_srvs);
264   }
265   else
266   {
267     rand = g_random_int_range(0, total_weight);
268     accum_weight = 0;
269     for(i = 0; i &lt; n_low_prio_srvs; ++i)
270     {
271       accum_weight += low_prio_srvs[i]-&gt;weight;
272       if(rand &lt; accum_weight) break;
273     }
274   }
275   g_assert(i &lt; n_low_prio_srvs);
276   index = low_prio_srvs[i] - *srvs;
277   selected_address = (*srvs)[index].address;
278   selected_port = (*srvs)[index].port;
279   g_free(low_prio_srvs);
280   (*srvs)[index] = (*srvs)[*n_srvs - 1];
281   *srvs = g_realloc(*srvs, sizeof(InfNameResolverSRV) * (*n_srvs - 1));
282   --*n_srvs;
283   if(port != NULL) *port = selected_port;
284   return selected_address;
285 }
286 static InfNameResolverSRV*
287 inf_name_resolver_lookup_srv(const gchar* query,
288                              guint* n_srvs,
289                              GError** error)
290 {
291 #ifdef G_OS_WIN32
292   PDNS_RECORD data;
293   PDNS_RECORD item;
294   DNS_STATUS status;
295   gchar* str;
296   GArray* array;
297   InfNameResolverSRV srv;
298   status = DnsQuery_UTF8(
299     query,
300     DNS_TYPE_SRV,
301     DNS_QUERY_STANDARD,
302     NULL,
303     &amp;data,
304     NULL
305   );
306   if(status != 0)
307   {
308     str = g_win32_error_message(status);
309     g_set_error_literal(
310       error,
311       g_quark_from_static_string("WIN32_ERROR"),
312       status,
313       str
314     );
315     g_free(str);
316     return NULL;
317   }
318   array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverSRV));
319   for(item = data; item != NULL; item = item-&gt;pNext)
320   {
321     if(item-&gt;wType != DNS_TYPE_SRV)
322       continue;
323     srv.priority = item-&gt;Data.SRV.wPriority;
324     srv.weight = item-&gt;Data.SRV.wWeight;
325     srv.port = item-&gt;Data.SRV.wPort;
326     srv.address = g_strdup(item-&gt;Data.SRV.pNameTarget);     g_array_append_val(array, srv);
327   }
328   DnsRecordListFree(data, DnsFreeRecordListDeep);
329   *n_srvs = array-&gt;len;
330   return (InfNameResolverSRV*)g_array_free(array, FALSE);
331 #else
332   char ansbuf[4096];
333   char hostbuf[256];
334   int len;
335   HEADER* header;
336   int query_count;
337   int answer_count;
338   const char* msg;
339   const char* cur;
340   const char* end;
341   InfNameResolverSRV* srvs;
342   guint n_answers;
343   int i;
344   static GMutex mutex;
345   g_mutex_lock(&amp;mutex);
346   *n_srvs = 0;
347   h_errno = 0;
348   len = res_query(query, C_IN, T_SRV, ansbuf, sizeof(ansbuf));
349   if(h_errno != 0)
350   {
351     if(h_errno != HOST_NOT_FOUND)
352       inf_name_resolver_set_herrno_error(error, h_errno);
353     g_mutex_unlock(&amp;mutex);
354     return NULL;
355   }
356   g_mutex_unlock(&amp;mutex);
357   if(len &lt; sizeof(HEADER))
358   {
359     inf_name_resolver_set_incomplete_error(error);
360     return NULL;
361   }
362   msg = ansbuf;
363   end = ansbuf + len;
364   cur = ansbuf + sizeof(HEADER);
365   header = (HEADER*)msg;
366   query_count = ntohs(header-&gt;qdcount);
367   answer_count = ntohs(header-&gt;ancount);
368   for(i = 0; i &lt; query_count; ++i)
369   {
370     len = dn_expand(msg, end, cur, hostbuf, sizeof(hostbuf));
371     if(len &lt; 0)
372     {
373       inf_name_resolver_set_errno_error(error, errno);
374       return NULL;
375     }
376     if(cur + len + QFIXEDSZ &gt; end)
377     {
378       inf_name_resolver_set_incomplete_error(error);
379       return NULL;
380     }
381     cur += len + QFIXEDSZ;
382   }
383   srvs = g_malloc(sizeof(InfNameResolverSRV) * answer_count);
384   n_answers = 0;
385   for(i = 0; i &lt; answer_count; ++i)
386   {
387     cur = inf_name_resolver_parse_srv_record(
388       msg,
389       end,
390       cur,
391       &amp;srvs[n_answers],
392       error
393     );
394     if(cur == NULL)
395     {
396       for(i = 0; i &lt; n_answers; ++i)
397         g_free(srvs[i].address);
398       g_free(srvs);
399       return NULL;
400     }
401     if(srvs[n_answers].address != NULL)
402       ++n_answers;
403   }
404   if(n_answers &lt; answer_count)
405     srvs = g_realloc(srvs, n_answers * sizeof(InfNameResolverSRV));
406   *n_srvs = n_answers;
407   return srvs;
408 #endif
409 }
410 static InfNameResolverEntry*
411 inf_name_resolver_lookup_a_aaaa(const gchar* hostname,
412                                 const gchar* service,
413                                 guint* n_entries,
414                                 GError** error)
415 {
416   struct addrinfo hint;
417   struct addrinfo* res;
418   int err;
419   GArray* array;
420   InfNameResolverEntry entry;
421   struct addrinfo* item;
422 #ifdef AI_ADDRCONFIG
423   hint.ai_flags = AI_ADDRCONFIG;
424 #else
425   hint.ai_flags = 0;
426 #endif
427   hint.ai_family = AF_UNSPEC;
428   hint.ai_socktype = SOCK_STREAM;
429   hint.ai_protocol = 0;
430   hint.ai_addrlen = 0;
431   hint.ai_canonname = NULL;
432   hint.ai_addr = NULL;
433   hint.ai_next = NULL;
434   res = NULL;
435   err = getaddrinfo(hostname, service, &amp;hint, &amp;res);
436   if(err != 0)
437   {
438     g_set_error_literal(
439       error,
440       g_quark_from_static_string("GETADDRINFO_ERROR"),
441       err,
442       gai_strerror(err)
443     );
444     *n_entries = 0;
445     return NULL;
446   }
447   else
448   {
449     g_assert(res != NULL);
450     array = g_array_new(FALSE, FALSE, sizeof(InfNameResolverEntry));
451     for(item = res; item != NULL; item = item-&gt;ai_next)
452     {
453       switch(item-&gt;ai_family)
454       {
455       case AF_INET:
456         entry.address = inf_ip_address_new_raw4(
457           ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_addr.s_addr
458         );
459         entry.port = ntohs( ((struct sockaddr_in*)item-&gt;ai_addr)-&gt;sin_port);
460         break;
461       case AF_INET6:
462         entry.address = inf_ip_address_new_raw6(
463           ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_addr.s6_addr
464         );
465         entry.port = ntohs( ((struct sockaddr_in6*)item-&gt;ai_addr)-&gt;sin6_port);
466         break;
467       default:
468         g_assert_not_reached();
469         break;
470       }
471       g_array_append_val(array, entry);
472     }
473     freeaddrinfo(res);
474     *n_entries = array-&gt;len;
475     return (InfNameResolverEntry*)g_array_free(array, FALSE);
476   }
477 }
478 static InfNameResolverEntry*
479 inf_name_resolver_resolve_srv(InfNameResolverSRV** srvs,
480                               guint* n_srvs,
481                               const gchar* service,
482                               guint* n_entries,
483                               GError** error)
484 {
485   gchar* srvaddr;
486   guint srvport;
487   GError* local_error;
488   InfNameResolverEntry* entries;
489   guint i;
490   g_assert(*n_srvs &gt; 0);
491   local_error = NULL;
492   srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);
493   while(srvaddr != NULL)
494   {
495     entries = inf_name_resolver_lookup_a_aaaa(
496       srvaddr,
497       service,
498       n_entries,
499       &amp;local_error
500     );
501     g_free(srvaddr);
502     srvaddr = NULL;
503     if(entries == NULL)
504     {
505       if(*n_srvs &gt; 0)
506         srvaddr = inf_name_resolver_choose_srv(srvs, n_srvs, &amp;srvport);
507       if(srvaddr != NULL)
508       {
509         g_error_free(local_error);
510         local_error = NULL;
511       }
512     }
513     else
514     {
515       for(i = 0; i &lt; *n_entries; ++i)
516         if(entries[i].port == 0)
517           entries[i].port = srvport;
518       return entries;
519     }
520   }
521   g_assert(local_error != NULL);
522   g_propagate_error(error, local_error);
523   return NULL;
524 }
525 static InfNameResolverResult*
526 inf_name_resolver_resolve(const gchar* hostname,
527                           const gchar* service,
528                           const gchar* srv)
529 {
530   InfNameResolverResult* result;
531   gchar* query;
532   GError* error;
533   error = NULL;
534   result = g_slice_new(InfNameResolverResult);
535   inf_name_resolver_result_nullify(result);
536   if(srv != NULL)
537   {
538     query = g_strdup_printf("%s.%s", srv, hostname);
539     result-&gt;srvs = inf_name_resolver_lookup_srv(
540       query,
541       &amp;result-&gt;n_srvs,
542       &amp;error
543     );
544     g_free(query);
545     if(error != NULL)
546     {
547       g_warning(
548         _("Failure during SRV record lookup: %s\n"
549           "Will go on with normal A/AAAA lookup"),
550         error-&gt;message
551       );
552       g_error_free(error);
553       error = NULL;
554     }
555     else if(result-&gt;n_srvs &gt; 0)
556     {
557       result-&gt;entries = inf_name_resolver_resolve_srv(
558         &amp;result-&gt;srvs,
559         &amp;result-&gt;n_srvs,
560         service,
561         &amp;result-&gt;n_entries,
562         &amp;result-&gt;error
563       );
564       return result;
565     }
566   }
567   result-&gt;entries = inf_name_resolver_lookup_a_aaaa(
568     hostname,
569     service,
570     &amp;result-&gt;n_entries,
571     &amp;result-&gt;error
572   );
573   return result;
574 }
575 static void
576 inf_name_resolver_run_func(gpointer* run_data,
577                            GDestroyNotify* run_notify,
578                            gpointer user_data)
579 {
580   InfNameResolver* resolver;
581   InfNameResolverPrivate* priv;
582   gchar* hostname;
583   gchar* service;
584   gchar* srv;
585   InfNameResolverResult* result;
586   resolver = INF_NAME_RESOLVER(user_data);
587   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
588 <a name="1"></a>
589   hostname = g_strdup(priv-&gt;hostname);
590   service = g_strdup(priv-&gt;service);
591 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  srv = g_strdup(priv-&gt;srv);
592   g_object_unref(resolver);
593   result = inf_name_resolver_resolve(hostname, service, srv);
594   g_free(hostname);
595   g_free(service);
596   g_free(srv);
597   *run_data = result;
598   *run_notify = inf_name_resolver_result_free;
599 }
600 static void
601 inf_name_resolver_backup_run_func(gpointer* run_data,
602                                   GDestroyNotify* run_notify,
603                                   gpointer user_data)
604 {
605   InfNameResolver* resolver;
606   InfNameResolverPrivate* priv;
607   InfNameResolverResult* result;
608   gchar* service;
609   resolver = INF_NAME_RESOLVER(user_data);
610   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
611   result = g_slice_new(InfNameResolverResult);
612   result-&gt;srvs = priv-&gt;result.srvs;
613   result-&gt;n_srvs = priv-&gt;result.n_srvs;
614   service = g_strdup(priv-&gt;service);
615   priv-&gt;result.srvs = NULL;</b></font>
616   priv-&gt;result.n_srvs = 0;
617   g_object_unref(resolver);
618   g_assert(result-&gt;n_srvs &gt; 0);
619   result-&gt;error = NULL;
620   result-&gt;entries = inf_name_resolver_resolve_srv(
621     &amp;result-&gt;srvs,
622     &amp;result-&gt;n_srvs,
623     service,
624     &amp;result-&gt;n_entries,
625     &amp;result-&gt;error
626   );
627   g_free(service);
628   *run_data = result;
629   *run_notify = inf_name_resolver_result_free;
630 }
631 static void
632 inf_name_resolver_done_func(gpointer run_data,
633                             gpointer user_data)
634 {
635   InfNameResolver* resolver;
636   InfNameResolverPrivate* priv;
637   InfNameResolverResult* result;
638   resolver = INF_NAME_RESOLVER(user_data);
639   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
640   result = (InfNameResolverResult*)run_data;
641   g_assert(priv-&gt;result.n_entries == 0);
642   g_assert(priv-&gt;result.n_srvs == 0);
643   g_assert(priv-&gt;result.error == NULL);
644   priv-&gt;operation = NULL;
645   priv-&gt;result = *result;
646   inf_name_resolver_result_nullify(result);
647   g_signal_emit(
648     G_OBJECT(resolver),
649     name_resolver_signals[RESOLVED],
650     0,
651     priv-&gt;result.error
652   );
653 }
654 static void
655 inf_name_resolver_backup_done_func(gpointer run_data,
656                                    gpointer user_data)
657 {
658   InfNameResolver* resolver;
659   InfNameResolverPrivate* priv;
660   InfNameResolverResult* result;
661   guint i;
662   resolver = INF_NAME_RESOLVER(user_data);
663   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
664   result = (InfNameResolverResult*)run_data;
665   g_assert(priv-&gt;result.n_srvs == 0);
666   g_assert(priv-&gt;result.error == NULL);
667   priv-&gt;operation = NULL;
668   priv-&gt;result.srvs = result-&gt;srvs;
669   priv-&gt;result.n_srvs = result-&gt;n_srvs;
670   priv-&gt;result.error = result-&gt;error;
671   if(result-&gt;n_entries &gt; 0)
672   {
673     priv-&gt;result.entries = g_realloc(
674       priv-&gt;result.entries,
675       sizeof(InfNameResolverEntry) *
676         (priv-&gt;result.n_entries + result-&gt;n_entries)
677     );
678     for(i = 0; i &lt; result-&gt;n_entries; ++i)
679       priv-&gt;result.entries[priv-&gt;result.n_entries + i] = result-&gt;entries[i];
680     priv-&gt;result.n_entries += result-&gt;n_entries;
681   }
682   inf_name_resolver_result_nullify(result);
683   g_signal_emit(
684     G_OBJECT(resolver),
685     name_resolver_signals[RESOLVED],
686     0,
687     priv-&gt;result.error
688   );
689 }
690 static void
691 inf_name_resolver_init(InfNameResolver* resolver)
692 {
693   InfNameResolverPrivate* priv;
694   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
695   priv-&gt;io = NULL;
696   priv-&gt;hostname = NULL;
697   priv-&gt;service = NULL;
698   priv-&gt;srv = NULL;
699   priv-&gt;operation = NULL;
700   inf_name_resolver_result_nullify(&amp;priv-&gt;result);
701 }
702 static void
703 inf_name_resolver_dispose(GObject* object)
704 {
705   InfNameResolver* resolver;
706   InfNameResolverPrivate* priv;
707   resolver = INF_NAME_RESOLVER(object);
708   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
709   if(priv-&gt;operation != NULL)
710   {
711     inf_async_operation_free(priv-&gt;operation);
712     priv-&gt;operation = NULL;
713   }
714   if(priv-&gt;io != NULL)
715   {
716     g_object_unref(G_OBJECT(priv-&gt;io));
717     priv-&gt;io = NULL;
718 <a name="2"></a>  }
719   G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;dispose(object);
720 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
721 static void
722 inf_name_resolver_finalize(GObject* object)
723 {
724   InfNameResolver* resolver;
725   InfNameResolverPrivate* priv;
726   resolver = INF_NAME_RESOLVER(object);
727   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
728   inf_name_resolver_result_cleanup(&amp;priv-&gt;result);
729   g_free(priv-&gt;hostname);
730   g_free(priv-&gt;service);
731   g_free(priv-&gt;srv);
732   G_OBJECT_CLASS(inf_name_resolver_parent_class)-&gt;finalize(object);
733 }
734 static void
735 inf_name_resolver_set_property(GObject* object,
736                                guint prop_id,
737                                const GValue* value,
738                                GParamSpec* pspec)
739 {
740   InfNameResolver* connection;
741   InfNameResolverPrivate* priv;
742   connection = INF_NAME_RESOLVER(object);
743   priv = INF_NAME_RESOLVER_PRIVATE(connection);
744   switch(prop_id)
745   {
746   case PROP_IO:</b></font>
747     g_assert(priv-&gt;operation == NULL);
748     if(priv-&gt;io != NULL) g_object_unref(priv-&gt;io);
749     priv-&gt;io = INF_IO(g_value_dup_object(value));
750     break;
751   case PROP_HOSTNAME:
752     g_assert(priv-&gt;operation == NULL);
753     g_free(priv-&gt;hostname);
754     priv-&gt;hostname = g_value_dup_string(value);
755     break;
756   case PROP_SERVICE:
757     g_assert(priv-&gt;operation == NULL);
758     g_free(priv-&gt;service);
759     priv-&gt;service = g_value_dup_string(value);
760     break;
761   case PROP_SRV:
762 <a name="0"></a>    g_assert(priv-&gt;operation == NULL);
763     g_free(priv-&gt;srv);
764 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;srv = g_value_dup_string(value);
765     break;
766   default:
767     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
768     break;
769   }
770 }
771 static void
772 inf_name_resolver_get_property(GObject* object,
773                                guint prop_id,
774                                GValue* value,
775                                GParamSpec* pspec)
776 {
777   InfNameResolver* connection;
778   InfNameResolverPrivate* priv;
779   connection = INF_NAME_RESOLVER(object);
780   priv = INF_NAME_RESOLVER_PRIVATE(connection);
781   switch(prop_id)
782   {
783   case PROP_IO:
784     g_value_set_object(value, G_OBJECT(priv-&gt;io));
785     break;
786   case PROP_HOSTNAME:
787     g_value_set_string(value, priv-&gt;hostname);
788     break;</b></font>
789   case PROP_SERVICE:
790     g_value_set_string(value, priv-&gt;service);
791     break;
792   case PROP_SRV:
793     g_value_set_string(value, priv-&gt;srv);
794     break;
795   default:
796     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
797     break;
798   }
799 }
800 static void
801 inf_name_resolver_class_init(InfNameResolverClass* name_resolver_class)
802 {
803   GObjectClass* object_class;
804   object_class = G_OBJECT_CLASS(name_resolver_class);
805   object_class-&gt;dispose = inf_name_resolver_dispose;
806   object_class-&gt;finalize = inf_name_resolver_finalize;
807   object_class-&gt;set_property = inf_name_resolver_set_property;
808   object_class-&gt;get_property = inf_name_resolver_get_property;
809   name_resolver_class-&gt;resolved = NULL;
810   g_object_class_install_property(
811     object_class,
812     PROP_IO,
813     g_param_spec_object(
814       "io",
815       "IO",
816       "I/O handler",
817       INF_TYPE_IO,
818       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
819     )
820   );
821   g_object_class_install_property(
822     object_class,
823     PROP_HOSTNAME,
824     g_param_spec_string(
825       "hostname",
826       "Hostname",
827       "The hostname to be looked up",
828       NULL,
829       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
830     )
831   );
832   g_object_class_install_property(
833     object_class,
834     PROP_SERVICE,
835     g_param_spec_string(
836       "service",
837       "Service",
838       "The expected service at the remote endpoint",
839       NULL,
840       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
841     )
842   );
843   g_object_class_install_property(
844     object_class,
845     PROP_SRV,
846     g_param_spec_string(
847       "srv",
848       "SRV",
849       "The SRV record to look up for the given hostname, e.g. _jabber._tcp",
850       NULL,
851       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
852     )
853   );
854   name_resolver_signals[RESOLVED] = g_signal_new(
855     "resolved",
856     G_OBJECT_CLASS_TYPE(object_class),
857     G_SIGNAL_RUN_LAST,
858     G_STRUCT_OFFSET(InfNameResolverClass, resolved),
859     NULL, NULL,
860     g_cclosure_marshal_VOID__BOXED,
861     G_TYPE_NONE,
862     1,
863     G_TYPE_ERROR
864   );
865 }
866 InfNameResolver*
867 inf_name_resolver_new(InfIo* io,
868                       const gchar* hostname,
869                       const gchar* service,
870                       const gchar* srv)
871 {
872   InfNameResolver* resolver;
873   g_return_val_if_fail(INF_IS_IO(io), NULL);
874   resolver = INF_NAME_RESOLVER(
875     g_object_new(
876       INF_TYPE_NAME_RESOLVER,
877       "io", io,
878       "hostname", hostname,
879       "service", service,
880       "srv", srv,
881       NULL
882     )
883   );
884   return resolver;
885 }
886 const gchar*
887 inf_name_resolver_get_hostname(InfNameResolver* resolver)
888 {
889   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
890   return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;hostname;
891 }
892 const gchar*
893 inf_name_resolver_get_service(InfNameResolver* resolver)
894 {
895   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
896   return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;service;
897 }
898 const gchar*
899 inf_name_resolver_get_srv(InfNameResolver* resolver)
900 {
901   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
902   return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;srv;
903 }
904 gboolean
905 inf_name_resolver_start(InfNameResolver* resolver,
906                         GError** error)
907 {
908   InfNameResolverPrivate* priv;
909   gboolean success;
910   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
911   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
912   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
913   g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);
914   inf_name_resolver_result_cleanup(&amp;priv-&gt;result);
915   inf_name_resolver_result_nullify(&amp;priv-&gt;result);
916   priv-&gt;operation = inf_async_operation_new(
917     priv-&gt;io,
918     inf_name_resolver_run_func,
919     inf_name_resolver_done_func,
920     resolver
921   );
922   g_object_ref(resolver);
923   success = inf_async_operation_start(priv-&gt;operation, error);
924   if(success == FALSE)
925   {
926     g_object_unref(resolver);
927     priv-&gt;operation = FALSE;
928     return FALSE;
929   }
930   return TRUE;
931 }
932 gboolean
933 inf_name_resolver_lookup_backup(InfNameResolver* resolver,
934                                 GError** error)
935 {
936   InfNameResolverPrivate* priv;
937   gboolean success;
938   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
939   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
940   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
941   g_return_val_if_fail(priv-&gt;operation == NULL, FALSE);
942   if(priv-&gt;result.n_srvs == 0)
943     return FALSE;
944   if(priv-&gt;result.error != NULL)
945   {
946     g_error_free(priv-&gt;result.error);
947     priv-&gt;result.error = NULL;
948   }
949   priv-&gt;operation = inf_async_operation_new(
950     priv-&gt;io,
951     inf_name_resolver_backup_run_func,
952     inf_name_resolver_backup_done_func,
953     resolver
954   );
955   g_object_ref(resolver);
956   success = inf_async_operation_start(priv-&gt;operation, error);
957   if(success == FALSE)
958   {
959     g_object_unref(resolver);
960     priv-&gt;operation = FALSE;
961     return FALSE;
962   }
963   return TRUE;
964 }
965 gboolean
966 inf_name_resolver_finished(InfNameResolver* resolver)
967 {
968   InfNameResolverPrivate* priv;
969   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), FALSE);
970   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
971   if(priv-&gt;operation != NULL)
972     return FALSE;
973   return TRUE;
974 }
975 guint
976 inf_name_resolver_get_n_addresses(InfNameResolver* resolver)
977 {
978   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);
979   return INF_NAME_RESOLVER_PRIVATE(resolver)-&gt;result.n_entries;
980 }
981 const InfIpAddress*
982 inf_name_resolver_get_address(InfNameResolver* resolver,
983                               guint index)
984 {
985   InfNameResolverPrivate* priv;
986   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
987   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
988   g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, NULL);
989   return priv-&gt;result.entries[index].address;
990 }
991 guint
992 inf_name_resolver_get_port(InfNameResolver* resolver,
993                            guint index)
994 {
995   InfNameResolverPrivate* priv;
996   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), 0);
997   priv = INF_NAME_RESOLVER_PRIVATE(resolver);
998   g_return_val_if_fail(index &lt; priv-&gt;result.n_entries, 0);
999   return priv-&gt;result.entries[index].port;
1000 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
