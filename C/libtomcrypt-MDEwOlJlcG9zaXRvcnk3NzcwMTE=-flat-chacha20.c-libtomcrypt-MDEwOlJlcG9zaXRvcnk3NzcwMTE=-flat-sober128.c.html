
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 178, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-chacha20.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CHACHA20_PRNG
3  const struct ltc_prng_descriptor chacha20_prng_desc =
4  {
5     "chacha20",
6     40,
7     &chacha20_prng_start,
8     &chacha20_prng_add_entropy,
9     &chacha20_prng_ready,
10     &chacha20_prng_read,
11     &chacha20_prng_done,
12     &chacha20_prng_export,
13     &chacha20_prng_import,
14     &chacha20_prng_test
15  };
16  int chacha20_prng_start(prng_state *prng)
17  {
18     LTC_ARGCHK(prng != NULL);
<span onclick='openModal()' class='match'>19     prng->ready = 0;
20     XMEMSET(&prng->u.chacha.ent, 0, sizeof(prng->u.chacha.ent));
21     prng->u.chacha.idx = 0;
22     LTC_MUTEX_INIT(&prng->lock)
23     return CRYPT_OK;
24  }
25  int chacha20_prng_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
30     LTC_ARGCHK(prng != NULL);
31     LTC_ARGCHK(in != NULL);
32     LTC_ARGCHK(inlen > 0);
33     LTC_MUTEX_LOCK(&prng->lock);
34     if (prng->ready) {
35        if ((err = chacha_keystream(&prng->u.chacha.s, buf, sizeof(buf))) != CRYPT_OK) goto LBL_UNLOCK;
36        for(i = 0; i < inlen; i++) buf[i % sizeof(buf)] ^= in[i];
37        if ((err = chacha_setup(&prng->u.chacha.s, buf, 32, 20)) != CRYPT_OK)      goto LBL_UNLOCK;
</span>38        if ((err = chacha_ivctr64(&prng->u.chacha.s, buf + 32, 8, 0)) != CRYPT_OK) goto LBL_UNLOCK;
39        zeromem(buf, sizeof(buf));
40     }
41     else {
42        while (inlen--) prng->u.chacha.ent[prng->u.chacha.idx++ % sizeof(prng->u.chacha.ent)] ^= *in++;
43     }
44     err = CRYPT_OK;
45  LBL_UNLOCK:
46     LTC_MUTEX_UNLOCK(&prng->lock);
47     return err;
48  }
49  int chacha20_prng_ready(prng_state *prng)
50  {
51     int err;
52     LTC_ARGCHK(prng != NULL);
53     LTC_MUTEX_LOCK(&prng->lock);
54     if (prng->ready)                                                    { err = CRYPT_OK; goto LBL_UNLOCK; }
55     if ((err = chacha_setup(&prng->u.chacha.s, prng->u.chacha.ent, 32, 20)) != CRYPT_OK)      goto LBL_UNLOCK;
56     if ((err = chacha_ivctr64(&prng->u.chacha.s, prng->u.chacha.ent + 32, 8, 0)) != CRYPT_OK) goto LBL_UNLOCK;
57     XMEMSET(&prng->u.chacha.ent, 0, sizeof(prng->u.chacha.ent));
58     prng->u.chacha.idx = 0;
59     prng->ready = 1;
60  LBL_UNLOCK:
61     LTC_MUTEX_UNLOCK(&prng->lock);
62     return err;
63  }
64  unsigned long chacha20_prng_read(unsigned char *out, unsigned long outlen, prng_state *prng)
65  {
66     if (outlen == 0 || prng == NULL || out == NULL) return 0;
67     LTC_MUTEX_LOCK(&prng->lock);
68     if (!prng->ready) { outlen = 0; goto LBL_UNLOCK; }
69     if (chacha_keystream(&prng->u.chacha.s, out, outlen) != CRYPT_OK) outlen = 0;
70  LBL_UNLOCK:
71     LTC_MUTEX_UNLOCK(&prng->lock);
72     return outlen;
73  }
74  int chacha20_prng_done(prng_state *prng)
75  {
76     int err;
77     LTC_ARGCHK(prng != NULL);
78     LTC_MUTEX_LOCK(&prng->lock);
79     prng->ready = 0;
80     err = chacha_done(&prng->u.chacha.s);
81     LTC_MUTEX_UNLOCK(&prng->lock);
82     LTC_MUTEX_DESTROY(&prng->lock);
83     return err;
84  }
85  LTC_PRNG_EXPORT(chacha20_prng)
86  int chacha20_prng_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
87  {
88     int err;
89     LTC_ARGCHK(prng != NULL);
90     LTC_ARGCHK(in   != NULL);
91     if (inlen < (unsigned long)chacha20_prng_desc.export_size) return CRYPT_INVALID_ARG;
92     if ((err = chacha20_prng_start(prng)) != CRYPT_OK)                  return err;
93     if ((err = chacha20_prng_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
94     return CRYPT_OK;
95  }
96  int chacha20_prng_test(void)
97  {
98  #ifndef LTC_TEST
99     return CRYPT_NOP;
100  #else
101     prng_state st;
102     unsigned char en[] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
103                            0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
104                            0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
105                            0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
106                            0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32 };
107     unsigned char dmp[300];
108     unsigned long dmplen = sizeof(dmp);
109     unsigned char out[500];
110     unsigned char t1[] = { 0x59, 0xB2, 0x26, 0x95, 0x2B, 0x01, 0x8F, 0x05, 0xBE, 0xD8 };
111     unsigned char t2[] = { 0x47, 0xC9, 0x0D, 0x03, 0xE4, 0x75, 0x34, 0x27, 0xBD, 0xDE };
112     unsigned char t3[] = { 0xBC, 0xFA, 0xEF, 0x59, 0x37, 0x7F, 0x1A, 0x91, 0x1A, 0xA6 };
113     int err;
114     if ((err = chacha20_prng_start(&st)) != CRYPT_OK)                       return err;
115     if ((err = chacha20_prng_add_entropy(en, sizeof(en), &st)) != CRYPT_OK) return err;
116     if ((err = chacha20_prng_ready(&st)) != CRYPT_OK)                       return err;
117     if (chacha20_prng_read(out, 10, &st) != 10)                             return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
118     if (compare_testvector(out, 10, t1, sizeof(t1), "CHACHA-PRNG", 1))      return CRYPT_FAIL_TESTVECTOR;
119     if (chacha20_prng_read(out, 500, &st) != 500)                           return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
120     if ((err = chacha20_prng_add_entropy(en, sizeof(en), &st)) != CRYPT_OK) return err;
121     if (chacha20_prng_read(out, 500, &st) != 500)                           return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
122     if ((err = chacha20_prng_export(dmp, &dmplen, &st)) != CRYPT_OK)        return err;
123     if (chacha20_prng_read(out, 500, &st) != 500)                           return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
124     if (chacha20_prng_read(out, 10, &st) != 10)                             return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
125     if (compare_testvector(out, 10, t2, sizeof(t2), "CHACHA-PRNG", 2))      return CRYPT_FAIL_TESTVECTOR;
126     if ((err = chacha20_prng_done(&st)) != CRYPT_OK)                        return err;
127     if ((err = chacha20_prng_import(dmp, dmplen, &st)) != CRYPT_OK)         return err;
128     if ((err = chacha20_prng_ready(&st)) != CRYPT_OK)                       return err;
129     if (chacha20_prng_read(out, 500, &st) != 500)                           return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
130     if (chacha20_prng_read(out, 10, &st) != 10)                             return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
131     if (compare_testvector(out, 10, t3, sizeof(t3), "CHACHA-PRNG", 3))      return CRYPT_FAIL_TESTVECTOR;
132     if ((err = chacha20_prng_done(&st)) != CRYPT_OK)                        return err;
133     return CRYPT_OK;
134  #endif
135  }
136  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SOBER128
3  const struct ltc_prng_descriptor sober128_desc =
4  {
5     "sober128",
6     40,
7     &sober128_start,
8     &sober128_add_entropy,
9     &sober128_ready,
10     &sober128_read,
11     &sober128_done,
12     &sober128_export,
13     &sober128_import,
14     &sober128_test
15  };
16  int sober128_start(prng_state *prng)
17  {
18     LTC_ARGCHK(prng != NULL);
<span onclick='openModal()' class='match'>19     prng->ready = 0;
20     XMEMSET(&prng->u.sober128.ent, 0, sizeof(prng->u.sober128.ent));
21     prng->u.sober128.idx = 0;
22     LTC_MUTEX_INIT(&prng->lock)
23     return CRYPT_OK;
24  }
25  int sober128_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
30     LTC_ARGCHK(prng != NULL);
31     LTC_ARGCHK(in != NULL);
32     LTC_ARGCHK(inlen > 0);
33     LTC_MUTEX_LOCK(&prng->lock);
34     if (prng->ready) {
35        if ((err = sober128_stream_keystream(&prng->u.sober128.s, buf, sizeof(buf))) != CRYPT_OK) goto LBL_UNLOCK;
36        for(i = 0; i < inlen; i++) buf[i % sizeof(buf)] ^= in[i];
37        if ((err = sober128_stream_setup(&prng->u.sober128.s, buf, 32)) != CRYPT_OK)     goto LBL_UNLOCK;
</span>38        if ((err = sober128_stream_setiv(&prng->u.sober128.s, buf + 32, 8)) != CRYPT_OK) goto LBL_UNLOCK;
39        zeromem(buf, sizeof(buf));
40     }
41     else {
42        while (inlen--) prng->u.sober128.ent[prng->u.sober128.idx++ % sizeof(prng->u.sober128.ent)] ^= *in++;
43     }
44     err = CRYPT_OK;
45  LBL_UNLOCK:
46     LTC_MUTEX_UNLOCK(&prng->lock);
47     return err;
48  }
49  int sober128_ready(prng_state *prng)
50  {
51     int err;
52     LTC_ARGCHK(prng != NULL);
53     LTC_MUTEX_LOCK(&prng->lock);
54     if (prng->ready)                                                            { err = CRYPT_OK; goto LBL_UNLOCK; }
55     if ((err = sober128_stream_setup(&prng->u.sober128.s, prng->u.sober128.ent, 32)) != CRYPT_OK)     goto LBL_UNLOCK;
56     if ((err = sober128_stream_setiv(&prng->u.sober128.s, prng->u.sober128.ent + 32, 8)) != CRYPT_OK) goto LBL_UNLOCK;
57     XMEMSET(&prng->u.sober128.ent, 0, sizeof(prng->u.sober128.ent));
58     prng->u.sober128.idx = 0;
59     prng->ready = 1;
60  LBL_UNLOCK:
61     LTC_MUTEX_UNLOCK(&prng->lock);
62     return err;
63  }
64  unsigned long sober128_read(unsigned char *out, unsigned long outlen, prng_state *prng)
65  {
66     if (outlen == 0 || prng == NULL || out == NULL) return 0;
67     LTC_MUTEX_LOCK(&prng->lock);
68     if (!prng->ready) { outlen = 0; goto LBL_UNLOCK; }
69     if (sober128_stream_keystream(&prng->u.sober128.s, out, outlen) != CRYPT_OK) outlen = 0;
70  LBL_UNLOCK:
71     LTC_MUTEX_UNLOCK(&prng->lock);
72     return outlen;
73  }
74  int sober128_done(prng_state *prng)
75  {
76     int err;
77     LTC_ARGCHK(prng != NULL);
78     LTC_MUTEX_LOCK(&prng->lock);
79     prng->ready = 0;
80     err = sober128_stream_done(&prng->u.sober128.s);
81     LTC_MUTEX_UNLOCK(&prng->lock);
82     LTC_MUTEX_DESTROY(&prng->lock);
83     return err;
84  }
85  LTC_PRNG_EXPORT(sober128)
86  int sober128_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
87  {
88     int err;
89     LTC_ARGCHK(prng != NULL);
90     LTC_ARGCHK(in   != NULL);
91     if (inlen < (unsigned long)sober128_desc.export_size) return CRYPT_INVALID_ARG;
92     if ((err = sober128_start(prng)) != CRYPT_OK) return err;
93     if ((err = sober128_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
94     return CRYPT_OK;
95  }
96  int sober128_test(void)
97  {
98  #ifndef LTC_TEST
99     return CRYPT_NOP;
100  #else
101     prng_state st;
102     unsigned char en[] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
103                            0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
104                            0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
105                            0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
106                            0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32 };
107     unsigned char dmp[300];
108     unsigned long dmplen = sizeof(dmp);
109     unsigned char out[500];
110     unsigned char t1[] = { 0x31, 0x82, 0xA7, 0xA5, 0x8B, 0xD7, 0xCB, 0x39, 0x86, 0x1A };
111     unsigned char t2[] = { 0x6B, 0x43, 0x9E, 0xBC, 0xE7, 0x62, 0x9B, 0xE6, 0x9B, 0x83 };
112     unsigned char t3[] = { 0x4A, 0x0E, 0x6C, 0xC1, 0xCF, 0xB4, 0x73, 0x49, 0x99, 0x05 };
113     int err;
114     if ((err = sober128_start(&st)) != CRYPT_OK)                         return err;
115     if ((err = sober128_add_entropy(en, sizeof(en), &st)) != CRYPT_OK)   return err;
116     if ((err = sober128_ready(&st)) != CRYPT_OK)                         return err;
117     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
118     if (compare_testvector(out, 10, t1, sizeof(t1), "SOBER128-PRNG", 1)) return CRYPT_FAIL_TESTVECTOR;
119     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
120     if ((err = sober128_add_entropy(en, sizeof(en), &st)) != CRYPT_OK)   return err;
121     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
122     if ((err = sober128_export(dmp, &dmplen, &st)) != CRYPT_OK)          return err;
123     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
124     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
125     if (compare_testvector(out, 10, t2, sizeof(t2), "SOBER128-PRNG", 2)) return CRYPT_FAIL_TESTVECTOR;
126     if ((err = sober128_done(&st)) != CRYPT_OK)                          return err;
127     if ((err = sober128_import(dmp, dmplen, &st)) != CRYPT_OK)           return err;
128     if ((err = sober128_ready(&st)) != CRYPT_OK)                         return err;
129     if (sober128_read(out, 500, &st) != 500)                             return CRYPT_ERROR_READPRNG; &bsol;* skip 500 bytes */
130     if (sober128_read(out, 10, &st) != 10)                               return CRYPT_ERROR_READPRNG; &bsol;* 10 bytes for testing */
131     if (compare_testvector(out, 10, t3, sizeof(t3), "SOBER128-PRNG", 3)) return CRYPT_FAIL_TESTVECTOR;
132     if ((err = sober128_done(&st)) != CRYPT_OK)                          return err;
133     return CRYPT_OK;
134  #endif
135  }
136  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-chacha20.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128.c</div>
                </div>
                <div class="column column_space"><pre><code>19     prng->ready = 0;
20     XMEMSET(&prng->u.chacha.ent, 0, sizeof(prng->u.chacha.ent));
21     prng->u.chacha.idx = 0;
22     LTC_MUTEX_INIT(&prng->lock)
23     return CRYPT_OK;
24  }
25  int chacha20_prng_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
30     LTC_ARGCHK(prng != NULL);
31     LTC_ARGCHK(in != NULL);
32     LTC_ARGCHK(inlen > 0);
33     LTC_MUTEX_LOCK(&prng->lock);
34     if (prng->ready) {
35        if ((err = chacha_keystream(&prng->u.chacha.s, buf, sizeof(buf))) != CRYPT_OK) goto LBL_UNLOCK;
36        for(i = 0; i < inlen; i++) buf[i % sizeof(buf)] ^= in[i];
37        if ((err = chacha_setup(&prng->u.chacha.s, buf, 32, 20)) != CRYPT_OK)      goto LBL_UNLOCK;
</pre></code></div>
                <div class="column column_space"><pre><code>19     prng->ready = 0;
20     XMEMSET(&prng->u.sober128.ent, 0, sizeof(prng->u.sober128.ent));
21     prng->u.sober128.idx = 0;
22     LTC_MUTEX_INIT(&prng->lock)
23     return CRYPT_OK;
24  }
25  int sober128_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
26  {
27     unsigned char buf[40];
28     unsigned long i;
29     int err;
30     LTC_ARGCHK(prng != NULL);
31     LTC_ARGCHK(in != NULL);
32     LTC_ARGCHK(inlen > 0);
33     LTC_MUTEX_LOCK(&prng->lock);
34     if (prng->ready) {
35        if ((err = sober128_stream_keystream(&prng->u.sober128.s, buf, sizeof(buf))) != CRYPT_OK) goto LBL_UNLOCK;
36        for(i = 0; i < inlen; i++) buf[i % sizeof(buf)] ^= in[i];
37        if ((err = sober128_stream_setup(&prng->u.sober128.s, buf, 32)) != CRYPT_OK)     goto LBL_UNLOCK;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    