
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.691931540342297%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dsa_import.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MDSA
3  int dsa_import(const unsigned char *in, unsigned long inlen, dsa_key *key)
4  {
5     int           err, stat;
6     unsigned long zero = 0, len;
7     unsigned char* tmpbuf = NULL;
8     unsigned char flags[1];
9     LTC_ARGCHK(in  != NULL);
10     LTC_ARGCHK(key != NULL);
11     LTC_ARGCHK(ltc_mp.name != NULL);
12     if (mp_init_multi(&key->p, &key->g, &key->q, &key->x, &key->y, LTC_NULL) != CRYPT_OK) {
13        return CRYPT_MEM;
14     }
15     err = der_decode_sequence_multi(in, inlen, LTC_ASN1_BIT_STRING, 1UL, flags,
16                                                LTC_ASN1_EOL,        0UL, NULL);
17     if (err == CRYPT_OK || err == CRYPT_INPUT_TOO_LONG) {
18         if (flags[0] == 1) {
19             if ((err = der_decode_sequence_multi(in, inlen,
20                                    LTC_ASN1_BIT_STRING,   1UL, flags,
21                                    LTC_ASN1_INTEGER,      1UL, key->g,
22                                    LTC_ASN1_INTEGER,      1UL, key->p,
23                                    LTC_ASN1_INTEGER,      1UL, key->q,
24                                    LTC_ASN1_INTEGER,      1UL, key->y,
25                                    LTC_ASN1_INTEGER,      1UL, key->x,
26                                    LTC_ASN1_EOL,          0UL, NULL)) != CRYPT_OK) {
27                 goto LBL_ERR;
28             }
29             key->type = PK_PRIVATE;
30             goto LBL_OK;
31         }
32         else if (flags[0] == 0) {
33             if ((err = der_decode_sequence_multi(in, inlen,
34                                        LTC_ASN1_BIT_STRING,   1UL, flags,
35                                        LTC_ASN1_INTEGER,      1UL, key->g,
36                                        LTC_ASN1_INTEGER,      1UL, key->p,
37                                        LTC_ASN1_INTEGER,      1UL, key->q,
38                                        LTC_ASN1_INTEGER,      1UL, key->y,
39                                        LTC_ASN1_EOL,          0UL, NULL)) != CRYPT_OK) {
40                 goto LBL_ERR;
41             }
42             key->type = PK_PUBLIC;
43             goto LBL_OK;
44         }
45         else {
46            err = CRYPT_INVALID_PACKET;
47            goto LBL_ERR;
48         }
49     }
50     if ((err = der_decode_sequence_multi(in, inlen,
51                            LTC_ASN1_SHORT_INTEGER, 1UL, &zero,
52                            LTC_ASN1_INTEGER,      1UL, key->p,
53                            LTC_ASN1_INTEGER,      1UL, key->q,
54                            LTC_ASN1_INTEGER,      1UL, key->g,
55                            LTC_ASN1_INTEGER,      1UL, key->y,
56                            LTC_ASN1_INTEGER,      1UL, key->x,
57                            LTC_ASN1_EOL,          0UL, NULL)) == CRYPT_OK) {
58         key->type = PK_PRIVATE;
59     } else { &bsol;* public */
60        ltc_asn1_list params[3];
61        unsigned long tmpbuf_len = inlen;
62        LTC_SET_ASN1(params, 0, LTC_ASN1_INTEGER, key->p, 1UL);
63        LTC_SET_ASN1(params, 1, LTC_ASN1_INTEGER, key->q, 1UL);
64        LTC_SET_ASN1(params, 2, LTC_ASN1_INTEGER, key->g, 1UL);
65        tmpbuf = XCALLOC(1, tmpbuf_len);
66        if (tmpbuf == NULL) {
67           err = CRYPT_MEM;
68           goto LBL_ERR;
69        }
70        len = 3;
71        err = x509_decode_subject_public_key_info(in, inlen, LTC_OID_DSA,
72                                                 tmpbuf, &tmpbuf_len,
73                                                 LTC_ASN1_SEQUENCE, params, &len);
<span onclick='openModal()' class='match'>74        if (err != CRYPT_OK) {
75           XFREE(tmpbuf);
76           goto LBL_ERR;
77        }
78        if ((err=der_decode_integer(tmpbuf, tmpbuf_len, key->y)) != CRYPT_OK) {
79           XFREE(tmpbuf);
80           goto LBL_ERR;
81        }
</span>82        XFREE(tmpbuf);
83        key->type = PK_PUBLIC;
84     }
85  LBL_OK:
86     key->qord = mp_unsigned_bin_size(key->q);
87     if ((err = dsa_int_validate_pqg(key, &stat)) != CRYPT_OK) {
88        goto LBL_ERR;
89     }
90     if (stat == 0) {
91        err = CRYPT_INVALID_PACKET;
92        goto LBL_ERR;
93     }
94     if ((err = dsa_int_validate_xy(key, &stat)) != CRYPT_OK) {
95        goto LBL_ERR;
96     }
97     if (stat == 0) {
98        err = CRYPT_INVALID_PACKET;
99        goto LBL_ERR;
100     }
101    return CRYPT_OK;
102  LBL_ERR:
103     dsa_free(key);
104     return err;
105  }
106  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dh_test.c</h3>
            <pre><code>1  #include <tomcrypt_test.h>
2  #if defined(LTC_MDH)
3  static int s_prime_test(void)
4  {
5     void *p, *g, *tmp;
6     int x, err, primality;
7     if ((err = mp_init_multi(&p, &g, &tmp, LTC_NULL)) != CRYPT_OK)               { goto error; }
8     for (x = 0; ltc_dh_sets[x].size != 0; x++) {
9        if ((strcmp(ltc_mp.name, "TomsFastMath") == 0) && (ltc_dh_sets[x].size > 256)) break;
<span onclick='openModal()' class='match'>10        if ((err = mp_read_radix(g, ltc_dh_sets[x].base, 16)) != CRYPT_OK)    { goto error; }
11        if ((err = mp_read_radix(p, ltc_dh_sets[x].prime, 16)) != CRYPT_OK)   { goto error; }
</span>12        if ((err = mp_prime_is_prime(p, 8, &primality)) != CRYPT_OK)          { goto done; }
13        if (primality != LTC_MP_YES ) {
14           err = CRYPT_FAIL_TESTVECTOR;
15           goto done;
16        }
17        if ((err = mp_sub_d(p, 1, tmp)) != CRYPT_OK)                          { goto error; }
18        if ((err = mp_div_2(tmp, tmp)) != CRYPT_OK)                           { goto error; }
19        if ((err = mp_prime_is_prime(tmp, 8, &primality)) != CRYPT_OK)        { goto done; }
20        if (primality == 0) {
21           err = CRYPT_FAIL_TESTVECTOR;
22           goto done;
23        }
24        if ((err = mp_exptmod(g, tmp, p, tmp)) != CRYPT_OK)                   { goto error; }
25        if (mp_cmp_d(tmp, 1)) {
26           err = CRYPT_FAIL_TESTVECTOR;
27           goto done;
28        }
29     }
30     err = CRYPT_OK;
31  error:
32  done:
33     mp_clear_multi(tmp, g, p, LTC_NULL);
34     return err;
35  }
36  static int s_dhparam_test(void)
37  {
38     dh_key k;
39     unsigned char buf[1024];
40     unsigned char dhparam_der[] = {
41        0x30, 0x82, 0x01, 0x08, 0x02, 0x82, 0x01, 0x01, 0x00, 0xae, 0xfe, 0x78, 0xce, 0x80, 0xd5, 0xd7,
42        0x8e, 0xcc, 0x4f, 0x0c, 0x1b, 0xb0, 0x95, 0x10, 0xe1, 0x41, 0x15, 0x53, 0x4d, 0x0e, 0x68, 0xb0,
43        0xf8, 0x5a, 0x41, 0x0e, 0x65, 0x2f, 0x9f, 0xac, 0x9c, 0x30, 0xb0, 0x76, 0xec, 0x02, 0xe9, 0x43,
44        0x55, 0x08, 0xb4, 0x20, 0x60, 0xd9, 0x52, 0xda, 0x2d, 0xab, 0x9a, 0xba, 0xe6, 0xcf, 0x11, 0xa7,
45        0x00, 0x44, 0xc2, 0x5e, 0xd1, 0xba, 0x9b, 0xaa, 0xfe, 0x03, 0xdd, 0xdc, 0xef, 0x41, 0x89, 0x9c,
46        0xac, 0x64, 0x13, 0xd9, 0x6a, 0x8a, 0x55, 0xa0, 0x5b, 0xff, 0x12, 0x92, 0x37, 0x52, 0x6a, 0x91,
47        0xa4, 0x6e, 0x9e, 0x61, 0xb7, 0xfe, 0xb0, 0x17, 0x8e, 0x67, 0x0f, 0x88, 0x46, 0xa7, 0x9e, 0xb1,
48        0xdb, 0x68, 0x77, 0x70, 0xb5, 0x77, 0xf2, 0x7e, 0x33, 0xb1, 0x3e, 0x10, 0xc4, 0x63, 0x36, 0xd0,
49        0x13, 0x27, 0xd3, 0x29, 0xc3, 0xb6, 0x5d, 0xf6, 0x5d, 0xa7, 0xd8, 0x25, 0x5c, 0x0b, 0x65, 0x99,
50        0xfa, 0xf9, 0x5f, 0x1d, 0xee, 0xd1, 0x86, 0x64, 0x7c, 0x44, 0xcb, 0xa0, 0x12, 0x52, 0x4c, 0xd4,
51        0x46, 0x81, 0xae, 0x07, 0xdb, 0xc7, 0x13, 0x29, 0xce, 0x9b, 0xcf, 0x1c, 0x06, 0xd2, 0x0f, 0x2d,
52        0xbb, 0x12, 0x33, 0xb9, 0xb1, 0x0f, 0x67, 0x5d, 0x3f, 0x0c, 0xe4, 0xfa, 0x67, 0x26, 0xe2, 0x89,
53        0xa2, 0xd5, 0x66, 0x29, 0x1c, 0xe2, 0x8e, 0xbb, 0x7b, 0xcb, 0xcc, 0x70, 0x7e, 0x4f, 0x0e, 0xd3,
54        0x5d, 0x64, 0x64, 0x1b, 0x27, 0xbb, 0xda, 0xa9, 0x08, 0x2b, 0x62, 0xd4, 0xca, 0xc3, 0x3a, 0x23,
55        0x39, 0x58, 0x57, 0xaf, 0x7b, 0x8b, 0x0c, 0x5b, 0x2e, 0xfc, 0x42, 0x57, 0x59, 0x39, 0x2e, 0x6d,
56        0x39, 0x97, 0xdb, 0x5b, 0x5c, 0xb9, 0x59, 0x71, 0x42, 0xf3, 0xcd, 0xea, 0xda, 0x86, 0x54, 0x86,
57        0x61, 0x8d, 0x93, 0x66, 0xc7, 0x65, 0xd1, 0x98, 0xcb, 0x02, 0x01, 0x02
58     };
59     unsigned char prime[] = {
60              0xae, 0xfe, 0x78, 0xce, 0x80, 0xd5, 0xd7, 0x8e, 0xcc, 0x4f, 0x0c, 0x1b, 0xb0, 0x95,
61        0x10, 0xe1, 0x41, 0x15, 0x53, 0x4d, 0x0e, 0x68, 0xb0, 0xf8, 0x5a, 0x41, 0x0e, 0x65, 0x2f,
62        0x9f, 0xac, 0x9c, 0x30, 0xb0, 0x76, 0xec, 0x02, 0xe9, 0x43, 0x55, 0x08, 0xb4, 0x20, 0x60,
63        0xd9, 0x52, 0xda, 0x2d, 0xab, 0x9a, 0xba, 0xe6, 0xcf, 0x11, 0xa7, 0x00, 0x44, 0xc2, 0x5e,
64        0xd1, 0xba, 0x9b, 0xaa, 0xfe, 0x03, 0xdd, 0xdc, 0xef, 0x41, 0x89, 0x9c, 0xac, 0x64, 0x13,
65        0xd9, 0x6a, 0x8a, 0x55, 0xa0, 0x5b, 0xff, 0x12, 0x92, 0x37, 0x52, 0x6a, 0x91, 0xa4, 0x6e,
66        0x9e, 0x61, 0xb7, 0xfe, 0xb0, 0x17, 0x8e, 0x67, 0x0f, 0x88, 0x46, 0xa7, 0x9e, 0xb1, 0xdb,
67        0x68, 0x77, 0x70, 0xb5, 0x77, 0xf2, 0x7e, 0x33, 0xb1, 0x3e, 0x10, 0xc4, 0x63, 0x36, 0xd0,
68        0x13, 0x27, 0xd3, 0x29, 0xc3, 0xb6, 0x5d, 0xf6, 0x5d, 0xa7, 0xd8, 0x25, 0x5c, 0x0b, 0x65,
69        0x99, 0xfa, 0xf9, 0x5f, 0x1d, 0xee, 0xd1, 0x86, 0x64, 0x7c, 0x44, 0xcb, 0xa0, 0x12, 0x52,
70        0x4c, 0xd4, 0x46, 0x81, 0xae, 0x07, 0xdb, 0xc7, 0x13, 0x29, 0xce, 0x9b, 0xcf, 0x1c, 0x06,
71        0xd2, 0x0f, 0x2d, 0xbb, 0x12, 0x33, 0xb9, 0xb1, 0x0f, 0x67, 0x5d, 0x3f, 0x0c, 0xe4, 0xfa,
72        0x67, 0x26, 0xe2, 0x89, 0xa2, 0xd5, 0x66, 0x29, 0x1c, 0xe2, 0x8e, 0xbb, 0x7b, 0xcb, 0xcc,
73        0x70, 0x7e, 0x4f, 0x0e, 0xd3, 0x5d, 0x64, 0x64, 0x1b, 0x27, 0xbb, 0xda, 0xa9, 0x08, 0x2b,
74        0x62, 0xd4, 0xca, 0xc3, 0x3a, 0x23, 0x39, 0x58, 0x57, 0xaf, 0x7b, 0x8b, 0x0c, 0x5b, 0x2e,
75        0xfc, 0x42, 0x57, 0x59, 0x39, 0x2e, 0x6d, 0x39, 0x97, 0xdb, 0x5b, 0x5c, 0xb9, 0x59, 0x71,
76        0x42, 0xf3, 0xcd, 0xea, 0xda, 0x86, 0x54, 0x86, 0x61, 0x8d, 0x93, 0x66, 0xc7, 0x65, 0xd1,
77        0x98, 0xcb
78     };
79     DO(dh_set_pg_dhparam(dhparam_der, sizeof(dhparam_der), &k));
80     DO(dh_generate_key(&yarrow_prng, find_prng ("yarrow"), &k));
81     if (mp_unsigned_bin_size(k.prime) > sizeof(buf)) {
82        printf("dhparam_test: short buf\n");
83        dh_free(&k);
84        return CRYPT_ERROR;
85     }
86     DO(mp_to_unsigned_bin(k.prime, buf));
87     DO(do_compare_testvector(buf, sizeof(prime), prime, sizeof(prime), "dhparam_test: prime mismatch", 1));
88     if (mp_cmp_d(k.base, 2) != LTC_MP_EQ) {
89        printf("dhparam_test: base mismatch\n");
90        dh_free(&k);
91        return CRYPT_ERROR;
92     }
93     dh_free(&k);
94     return CRYPT_OK;
95  }
96  static int s_set_test(void)
97  {
98     dh_key k1, k2, k3;
99     unsigned char buf[4096];
100     unsigned long len;
101     int i;
102     unsigned char gbin[] = { 0x02 };
103     unsigned char pbin[] = {
104        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
105        0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
106        0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
107        0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
108        0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
109        0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
110        0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
111        0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
112        0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
113        0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
114        0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
115        0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
116        0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
117        0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
118        0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
119        0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
120     };
121     unsigned char xbin[] = {
122        0xA6, 0x68, 0x1A, 0xDC, 0x38, 0x6C, 0xE9, 0x44, 0xC3, 0xDE, 0xD9, 0xA7, 0x30, 0x1D, 0xCC, 0x9C,
123        0x51, 0x82, 0x50, 0xE3, 0xED, 0xB6, 0x2F, 0x95, 0x91, 0x98, 0xF8, 0xDC, 0x00, 0x57, 0xDD, 0x6F,
124        0xB5, 0x7A, 0xBA, 0xFD, 0x78, 0x81, 0x98, 0xB1
125     };
126     unsigned char ybin[] = {
127        0x39, 0x04, 0x66, 0x32, 0xC8, 0x34, 0x41, 0x8D, 0xFA, 0x07, 0xB3, 0x09, 0x15, 0x38, 0xB6, 0x14,
128        0xD1, 0xFB, 0x5D, 0xBB, 0x78, 0x5C, 0x0F, 0xBE, 0xA3, 0xB9, 0x8B, 0x29, 0x5B, 0xC0, 0xCD, 0x07,
129        0x6A, 0x88, 0xD9, 0x45, 0x21, 0x41, 0xA2, 0x69, 0xE8, 0xBA, 0xEB, 0x1D, 0xD6, 0x54, 0xEB, 0xA0,
130        0x3A, 0x57, 0x05, 0x31, 0x8D, 0x12, 0x97, 0x54, 0xCD, 0xF4, 0x00, 0x3A, 0x8C, 0x39, 0x92, 0x40,
131        0xFB, 0xB8, 0xF1, 0x62, 0x49, 0x0F, 0x6F, 0x0D, 0xC7, 0x0E, 0x41, 0x4B, 0x6F, 0xEE, 0x88, 0x08,
132        0x6A, 0xFA, 0xA4, 0x8E, 0x9F, 0x3A, 0x24, 0x8E, 0xDC, 0x09, 0x34, 0x52, 0x66, 0x3D, 0x34, 0xE0,
133        0xE8, 0x09, 0xD4, 0xF6, 0xBA, 0xDB, 0xB3, 0x6F, 0x80, 0xB6, 0x81, 0x3E, 0xBF, 0x7C, 0x32, 0x81,
134        0xB8, 0x62, 0x20, 0x9E, 0x56, 0x04, 0xBD, 0xEA, 0x8B, 0x8F, 0x5F, 0x7B, 0xFD, 0xC3, 0xEE, 0xB7,
135        0xAD, 0xB7, 0x30, 0x48, 0x28, 0x9B, 0xCE, 0xA0, 0xF5, 0xA5, 0xCD, 0xEE, 0x7D, 0xF9, 0x1C, 0xD1,
136        0xF0, 0xBA, 0x63, 0x2F, 0x06, 0xDB, 0xE9, 0xBA, 0x7E, 0xF0, 0x14, 0xB8, 0x4B, 0x02, 0xD4, 0x97,
137        0xCA, 0x7D, 0x0C, 0x60, 0xF7, 0x34, 0x75, 0x2A, 0x64, 0x9D, 0xA4, 0x96, 0x94, 0x6B, 0x4E, 0x53,
138        0x1B, 0x30, 0xD9, 0xF8, 0x2E, 0xDD, 0x85, 0x56, 0x36, 0xC0, 0xB0, 0xF2, 0xAE, 0x23, 0x2E, 0x41,
139        0x86, 0x45, 0x4E, 0x88, 0x87, 0xBB, 0x42, 0x3E, 0x32, 0xA5, 0xA2, 0x49, 0x5E, 0xAC, 0xBA, 0x99,
140        0x62, 0x0A, 0xCD, 0x03, 0xA3, 0x83, 0x45, 0xEB, 0xB6, 0x73, 0x5E, 0x62, 0x33, 0x0A, 0x8E, 0xE9,
141        0xAA, 0x6C, 0x83, 0x70, 0x41, 0x0F, 0x5C, 0xD4, 0x5A, 0xF3, 0x7E, 0xE9, 0x0A, 0x0D, 0xA9, 0x5B,
142        0xE9, 0x6F, 0xC9, 0x39, 0xE8, 0x8F, 0xE0, 0xBD, 0x2C, 0xD0, 0x9F, 0xC8, 0xF5, 0x24, 0x20, 0x8C
143     };
144     struct {
145       int radix;
146       void* g; int glen;
147       void* p; int plen;
148       void* x; int xlen;
149       void* y; int ylen;
150     } test[1] = {
151        { 256, gbin, sizeof(gbin),   pbin, sizeof(pbin),   xbin, sizeof(xbin),   ybin, sizeof(ybin)   }
152     };
153     unsigned char export_private[] = {
154        0x30, 0x82, 0x01, 0x3A, 0x02, 0x01, 0x00, 0x03, 0x02, 0x07, 0x80, 0x02, 0x82, 0x01, 0x01, 0x00,
155        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
156        0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
157        0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
158        0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
159        0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
160        0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
161        0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
162        0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
163        0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
164        0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
165        0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
166        0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
167        0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
168        0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
169        0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
170        0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
171        0x02, 0x01, 0x02, 0x02, 0x29, 0x00, 0xA6, 0x68, 0x1A, 0xDC, 0x38, 0x6C, 0xE9, 0x44, 0xC3, 0xDE,
172        0xD9, 0xA7, 0x30, 0x1D, 0xCC, 0x9C, 0x51, 0x82, 0x50, 0xE3, 0xED, 0xB6, 0x2F, 0x95, 0x91, 0x98,
173        0xF8, 0xDC, 0x00, 0x57, 0xDD, 0x6F, 0xB5, 0x7A, 0xBA, 0xFD, 0x78, 0x81, 0x98, 0xB1
174     };
175     unsigned char export_public[] = {
176        0x30, 0x82, 0x02, 0x13, 0x02, 0x01, 0x00, 0x03, 0x02, 0x07, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00,
177        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
178        0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
179        0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
180        0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
181        0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
182        0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
183        0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
184        0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
185        0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
186        0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
187        0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
188        0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
189        0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
190        0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
191        0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
192        0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
193        0x02, 0x01, 0x02, 0x02, 0x82, 0x01, 0x00, 0x39, 0x04, 0x66, 0x32, 0xC8, 0x34, 0x41, 0x8D, 0xFA,
194        0x07, 0xB3, 0x09, 0x15, 0x38, 0xB6, 0x14, 0xD1, 0xFB, 0x5D, 0xBB, 0x78, 0x5C, 0x0F, 0xBE, 0xA3,
195        0xB9, 0x8B, 0x29, 0x5B, 0xC0, 0xCD, 0x07, 0x6A, 0x88, 0xD9, 0x45, 0x21, 0x41, 0xA2, 0x69, 0xE8,
196        0xBA, 0xEB, 0x1D, 0xD6, 0x54, 0xEB, 0xA0, 0x3A, 0x57, 0x05, 0x31, 0x8D, 0x12, 0x97, 0x54, 0xCD,
197        0xF4, 0x00, 0x3A, 0x8C, 0x39, 0x92, 0x40, 0xFB, 0xB8, 0xF1, 0x62, 0x49, 0x0F, 0x6F, 0x0D, 0xC7,
198        0x0E, 0x41, 0x4B, 0x6F, 0xEE, 0x88, 0x08, 0x6A, 0xFA, 0xA4, 0x8E, 0x9F, 0x3A, 0x24, 0x8E, 0xDC,
199        0x09, 0x34, 0x52, 0x66, 0x3D, 0x34, 0xE0, 0xE8, 0x09, 0xD4, 0xF6, 0xBA, 0xDB, 0xB3, 0x6F, 0x80,
200        0xB6, 0x81, 0x3E, 0xBF, 0x7C, 0x32, 0x81, 0xB8, 0x62, 0x20, 0x9E, 0x56, 0x04, 0xBD, 0xEA, 0x8B,
201        0x8F, 0x5F, 0x7B, 0xFD, 0xC3, 0xEE, 0xB7, 0xAD, 0xB7, 0x30, 0x48, 0x28, 0x9B, 0xCE, 0xA0, 0xF5,
202        0xA5, 0xCD, 0xEE, 0x7D, 0xF9, 0x1C, 0xD1, 0xF0, 0xBA, 0x63, 0x2F, 0x06, 0xDB, 0xE9, 0xBA, 0x7E,
203        0xF0, 0x14, 0xB8, 0x4B, 0x02, 0xD4, 0x97, 0xCA, 0x7D, 0x0C, 0x60, 0xF7, 0x34, 0x75, 0x2A, 0x64,
204        0x9D, 0xA4, 0x96, 0x94, 0x6B, 0x4E, 0x53, 0x1B, 0x30, 0xD9, 0xF8, 0x2E, 0xDD, 0x85, 0x56, 0x36,
205        0xC0, 0xB0, 0xF2, 0xAE, 0x23, 0x2E, 0x41, 0x86, 0x45, 0x4E, 0x88, 0x87, 0xBB, 0x42, 0x3E, 0x32,
206        0xA5, 0xA2, 0x49, 0x5E, 0xAC, 0xBA, 0x99, 0x62, 0x0A, 0xCD, 0x03, 0xA3, 0x83, 0x45, 0xEB, 0xB6,
207        0x73, 0x5E, 0x62, 0x33, 0x0A, 0x8E, 0xE9, 0xAA, 0x6C, 0x83, 0x70, 0x41, 0x0F, 0x5C, 0xD4, 0x5A,
208        0xF3, 0x7E, 0xE9, 0x0A, 0x0D, 0xA9, 0x5B, 0xE9, 0x6F, 0xC9, 0x39, 0xE8, 0x8F, 0xE0, 0xBD, 0x2C,
209        0xD0, 0x9F, 0xC8, 0xF5, 0x24, 0x20, 0x8C
210     };
211     for (i = 0; i < 1; i++) {
212        DO(dh_set_pg(test[i].p, test[i].plen, test[i].g, test[i].glen, &k1));
213        DO(dh_set_key(test[i].x, test[i].xlen, PK_PRIVATE, &k1));
214        len = sizeof(buf);
215        DO(dh_export(buf, &len, PK_PRIVATE, &k1));
216        DO(do_compare_testvector(buf, len, export_private, sizeof(export_private), "radix_test: dh_export+PK_PRIVATE mismatch", i*10 + 0));
217        len = sizeof(buf);
218        DO(dh_export(buf, &len, PK_PUBLIC, &k1));
219        DO(do_compare_testvector(buf, len, export_public, sizeof(export_public), "radix_test: dh_export+PK_PUBLIC mismatch", i*10 + 1));
220        len = sizeof(buf);
221        DO(dh_export_key(buf, &len, PK_PRIVATE, &k1));
222        DO(do_compare_testvector(buf, len, xbin, sizeof(xbin), "radix_test: dh_export+PK_PRIVATE mismatch", i*10 + 2));
223        len = sizeof(buf);
224        DO(dh_export_key(buf, &len, PK_PUBLIC, &k1));
225        DO(do_compare_testvector(buf, len, ybin, sizeof(ybin), "radix_test: dh_export+PK_PUBLIC mismatch", i*10 + 3));
226        dh_free(&k1);
227        DO(dh_set_pg(test[i].p, test[i].plen, test[i].g, test[i].glen, &k1));
228        DO(dh_set_key(test[i].x, test[i].xlen, PK_PRIVATE, &k1));
229        len = sizeof(buf);
230        DO(dh_export(buf, &len, PK_PRIVATE, &k1));
231        DO(do_compare_testvector(buf, len, export_private, sizeof(export_private), "radix_test: dh_export+PK_PRIVATE mismatc", i*10 + 4));
232        len = sizeof(buf);
233        DO(dh_export(buf, &len, PK_PUBLIC, &k1));
234        DO(do_compare_testvector(buf, len, export_public, sizeof(export_public), "radix_test: dh_export+PK_PUBLIC mismatch", i*10 + 5));
235        dh_free(&k1);
236        DO(dh_set_pg(test[i].p, test[i].plen, test[i].g, test[i].glen, &k2));
237        DO(dh_set_key(test[i].y, test[i].ylen, PK_PUBLIC, &k2));
238        len = sizeof(buf);
239        DO(dh_export(buf, &len, PK_PUBLIC, &k2));
240        DO(do_compare_testvector(buf, len, export_public, sizeof(export_public), "radix_test: dh_export+PK_PUBLIC mismatch", i*10 + 6));
241        len = sizeof(buf);
242        DO(dh_export_key(buf, &len, PK_PUBLIC, &k2));
243        DO(do_compare_testvector(buf, len, ybin, sizeof(ybin), "radix_test: dh_export+PK_PUBLIC mismatch", i*10 + 7));
244        dh_free(&k2);
245        DO(dh_set_pg(test[i].p, test[i].plen, test[i].g, test[i].glen, &k3));
246        DO(dh_generate_key(&yarrow_prng, find_prng("yarrow"), &k3));
247        len = mp_unsigned_bin_size(k3.prime);
248        DO(mp_to_unsigned_bin(k3.prime, buf));
249        DO(do_compare_testvector(buf, len, pbin, sizeof(pbin), "radix_test: dh_make_key_ex prime mismatch", i*10 + 8));
250        len = mp_unsigned_bin_size(k3.base);
251        DO(mp_to_unsigned_bin(k3.base, buf));
252        DO(do_compare_testvector(buf, len, gbin, sizeof(gbin), "radix_test: dh_make_key_ex base mismatch", i*10 + 9));
253        dh_free(&k3);
254     }
255     return CRYPT_OK;
256  }
257  static int s_basic_test(void)
258  {
259     unsigned char buf[3][4096];
260     unsigned long x, y, z;
261     int           size, KEYSIZE;
262     dh_key        usera, userb;
263     KEYSIZE = (strcmp(ltc_mp.name, "TomsFastMath") == 0) ? 2048 : 4096;
264     DO(dh_set_pg_groupsize(KEYSIZE/8, &usera));
265     DO(dh_generate_key(&yarrow_prng, find_prng ("yarrow"), &usera));
266     DO(dh_set_pg_groupsize(KEYSIZE/8, &userb));
267     DO(dh_generate_key(&yarrow_prng, find_prng ("yarrow"), &userb));
268     x = KEYSIZE;
269     DO(dh_shared_secret (&usera, &userb, buf[0], &x));
270     y = KEYSIZE;
271     DO(dh_shared_secret (&userb, &usera, buf[1], &y));
272     if (y != x) {
273        fprintf(stderr, "DH Shared keys are not same size.\n");
274        dh_free (&usera);
275        dh_free (&userb);
276        return CRYPT_ERROR;
277     }
278     if (memcmp (buf[0], buf[1], x)) {
279        fprintf(stderr, "DH Shared keys not same contents.\n");
280        dh_free (&usera);
281        dh_free (&userb);
282        return CRYPT_ERROR;
283     }
284     y = KEYSIZE;
285     DO(dh_export (buf[1], &y, PK_PUBLIC, &userb));
286     dh_free (&userb);
287     DO(dh_import (buf[1], y, &userb));
288     z = KEYSIZE;
289     DO(dh_shared_secret (&usera, &userb, buf[2], &z));
290     dh_free (&usera);
291     dh_free (&userb);
292     if (z != x) {
293        fprintf(stderr, "failed.  Size don't match?\n");
294        return CRYPT_ERROR;
295     }
296     if (memcmp (buf[0], buf[2], x)) {
297        fprintf(stderr, "Failed.  Content didn't match.\n");
298        return CRYPT_ERROR;
299     }
300     for (x = 0; ltc_dh_sets[x].size != 0; x++) {
301        if ((strcmp(ltc_mp.name, "TomsFastMath") == 0) && (ltc_dh_sets[x].size > 256)) break;
302        DO(dh_set_pg_groupsize(ltc_dh_sets[x].size, &usera));
303        DO(dh_generate_key(&yarrow_prng, find_prng ("yarrow"), &usera));
304        size = dh_get_groupsize(&usera);
305        dh_free(&usera);
306        if (size != ltc_dh_sets[x].size) {
307           fprintf(stderr, "dh_groupsize mismatch %d %d\n", size, ltc_dh_sets[x].size);
308           return CRYPT_ERROR;
309        }
310        dh_free(&usera);
311     }
312     return CRYPT_OK;
313  }
314  int dh_test(void)
315  {
316     int fails = 0;
317     if (ltc_mp.name == NULL) return CRYPT_NOP;
318     if (s_prime_test() != CRYPT_OK) fails++;
319     if (s_basic_test() != CRYPT_OK) fails++;
320     if (s_dhparam_test() != CRYPT_OK) fails++;
321     if (s_set_test() != CRYPT_OK) fails++;
322     return fails > 0 ? CRYPT_FAIL_TESTVECTOR : CRYPT_OK;
323  }
324  #else
325  int dh_test(void)
326  {
327     return CRYPT_NOP;
328  }
329  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dsa_import.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dh_test.c</div>
                </div>
                <div class="column column_space"><pre><code>74        if (err != CRYPT_OK) {
75           XFREE(tmpbuf);
76           goto LBL_ERR;
77        }
78        if ((err=der_decode_integer(tmpbuf, tmpbuf_len, key->y)) != CRYPT_OK) {
79           XFREE(tmpbuf);
80           goto LBL_ERR;
81        }
</pre></code></div>
                <div class="column column_space"><pre><code>10        if ((err = mp_read_radix(g, ltc_dh_sets[x].base, 16)) != CRYPT_OK)    { goto error; }
11        if ((err = mp_read_radix(p, ltc_dh_sets[x].prime, 16)) != CRYPT_OK)   { goto error; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    