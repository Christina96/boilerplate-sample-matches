<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-text-cleanup.c &amp; inf-test-text-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-text-cleanup.c &amp; inf-test-text-session.c
      </h3>
<h1 align="center">
        35.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-text-cleanup.c (39.20705%)<th>inf-test-text-session.c (33.085503%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(347-360)<td><a href="#" name="0">(316-329)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(323-338)<td><a href="#" name="1">(298-313)</a><td align="center"><font color="#b00000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(293-322)<td><a href="#" name="2">(266-297)</a><td align="center"><font color="#a60000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(397-416)<td><a href="#" name="3">(378-397)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(362-386)<td><a href="#" name="4">(330-354)</a><td align="center"><font color="#890000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-cleanup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "util/inf-test-util.h"
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/common/inf-user-table.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;
#include &lt;string.h&gt;
typedef struct {
  guint total;
  guint passed;
} test_result;
typedef enum {
  INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
  INF_TEST_TEXT_CLEANUP_UNSUPPORTED,
  INF_TEST_TEXT_CLEANUP_VERIFY_FAILED
} InfTestTextCleanupError;
static GQuark
inf_test_text_cleanup_error_quark()
{
  return g_quark_from_static_string("INF_TEST_TEXT_CLEANUP_ERROR");
}
static void
error_cb(InfSession* session,
         InfXmlConnection* connection,
         xmlNodePtr xml,
         const GError* error,
         gpointer user_data)
{
  GError** error_loc = (GError**)user_data;
  *error_loc = g_error_copy(error);
}
static gboolean
perform_test(guint max_total_log_size,
             InfTextChunk* initial,
             GSList* users,
             GSList* requests,
             GError** error)
{
  InfTextBuffer* buffer;
  InfCommunicationManager* manager;
  InfIo* io;
  InfTextSession* session;
  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;
  InfTextUser* user;
  gchar* user_name;
  GSList* item;
  xmlNodePtr request;
  gboolean result;
  GError* local_error;
  guint verify_user_id;
  InfAdoptedUser* verify_user;
  guint verify_log_size;
  gint verify_can_undo;
  gint verify_can_redo;
  InfAdoptedRequestLog* log;
  guint log_size;
  buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new("UTF-8"));
  inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);
  manager = inf_communication_manager_new();
  io = INF_IO(inf_standalone_io_new());
  user_table = inf_user_table_new();
  local_error = NULL;
  for(item = users; item != NULL; item = g_slist_next(item))
  {
    user_name = g_strdup_printf("User_%u", GPOINTER_TO_UINT(item-&gt;data));
    user = INF_TEXT_USER(
      g_object_new(
        INF_TEXT_TYPE_USER,
        "id", GPOINTER_TO_UINT(item-&gt;data),
        "name", user_name,
        "status", INF_USER_ACTIVE,
        "flags", 0,
        NULL
      )
    );
    g_free(user_name);
    inf_user_table_add_user(user_table, INF_USER(user));
    g_object_unref(user);
  }
  session = INF_TEXT_SESSION(
    g_object_new(
      INF_TEXT_TYPE_SESSION,
      "communication-manager", manager,
      "buffer", buffer,
      "io", io,
      "user_table", user_table,
      "max-total-log-size", max_total_log_size,
      NULL
    )
  );
  g_signal_connect(
    G_OBJECT(session),
    "error",
    G_CALLBACK(error_cb),
    &amp;local_error
  );
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  g_object_unref(io);
  g_object_unref(manager);
  g_object_unref(user_table);
  g_object_unref(buffer);
  for(item = requests; item != NULL; item = item-&gt;next)
  {
    request = (xmlNodePtr)item-&gt;data;
    if(strcmp((const char*)request-&gt;name, "request") == 0)
    {
      result = inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(session),
        NULL,
        request
      );
      if(local_error != NULL)
      {
        g_prefix_error(&amp;local_error, "[%d] ", request-&gt;line);
        goto fail;
      }
    }
    else
    {
      result = inf_xml_util_get_attribute_uint_required(
        request,
        "user",
        &amp;verify_user_id,
        &amp;local_error
      );
      if(result == FALSE)
        goto fail;
      verify_user = INF_ADOPTED_USER(
        inf_user_table_lookup_user_by_id(user_table, verify_user_id)
      );
      if(verify_user == NULL)
      {
        g_set_error(
          error,
          inf_test_text_cleanup_error_quark(),
          INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
          "[%d] User ID '%u' not available",
          request-&gt;line,
          verify_user_id
        );
        goto fail;
      }
      result = inf_xml_util_get_attribute_uint(
        request,
        "log-size",
        &amp;verify_log_size,
        &amp;local_error
      );
      if(local_error) goto fail;
      if(result)
      {
        log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(verify_user));
        log_size = inf_adopted_request_log_get_end(log) -
          inf_adopted_request_log_get_begin(log);
        if(verify_log_size != log_size)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            "[%d] Log size does not match; got %u, but expected %u",
            request-&gt;line,
            log_size,
            verify_log_size
          );
          goto fail;
        }
      }
      result = inf_xml_util_get_attribute_int(
        request,
        "can-undo",
        &amp;verify_can_undo,
        &amp;local_error
      );
      if(local_error) goto fail;
      if(result)
      {
        result = inf_adopted_algorithm_can_undo(algorithm, verify_user);
        if(result != verify_can_undo)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            "[%d] can-undo does not match; got %d, but expected %d",
            request-&gt;line,
            (guint)result,
            verify_can_undo
          );
          goto fail;
        }
      }
      result = inf_xml_util_get_attribute_int(
        request,
        "can-redo",
        &amp;verify_can_redo,
        &amp;local_error
      );
      if(local_error) goto fail;
      if(result)
      {
        result = inf_adopted_algorithm_can_redo(algorithm, verify_user);
        if(result != verify_can_redo)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            "[%d] can-redo does not match; got %d, but expected %d",
            request-&gt;line,
            (guint)result,
            verify_can_redo
          );
          goto fail;
        }
      }
    }
  }
  g_object_unref(session);
  return TRUE;
<a name="2"></a>fail:
  g_object_unref(session);
  if(local_error) g_propagate_error(error, local_error);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return FALSE;
}
static void
foreach_test_func(const gchar* testfile,
                  gpointer user_data)
{
  test_result* result;
  xmlDocPtr doc;
  xmlNodePtr root;
  xmlNodePtr child;
  GSList* requests;
  InfTextChunk* initial;
  GSList* users;
  guint max_total_log_size;
  GError* error;
  gboolean res;
  if(!g_str_has_suffix(testfile, ".xml"))
    return;
  result = (test_result*)user_data;
  doc = xmlParseFile(testfile);
  requests = NULL;
<a name="1"></a>  initial = NULL;
  users = NULL;
  max_total_log_size = 0;</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  error = NULL;
  printf("%s... ", testfile);
  fflush(stdout);
  ++ result-&gt;total;
  if(doc != NULL)
  {
    root = xmlDocGetRootElement(doc);
    for(child = root-&gt;children; child != NULL; child = child-&gt;next)
    {
      if(child-&gt;type != XML_ELEMENT_NODE) continue;
      if(strcmp((const char*)child-&gt;name, "log") == 0)
      {</b></font>
        res = inf_xml_util_get_attribute_uint_required(
          child,
          "size",
          &amp;max_total_log_size,
          &amp;error
<a name="0"></a>        );
        if(!res)
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          break;
      }
      else if(strcmp((const char*)child-&gt;name, "initial-buffer") == 0)
      {
        if(initial != NULL) inf_text_chunk_free(initial);
        initial = inf_test_util_parse_buffer(child, &amp;error);
        if(initial == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, "user") == 0)
      {
        if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
          break;
<a name="4"></a>      }
      else if(strcmp((const char*)child-&gt;name, "request") == 0 ||</b></font>
              strcmp((const char*)child-&gt;name, "verify") == 0)
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      {
        requests = g_slist_prepend(requests, child);
      }
      else
      {
        g_set_error(
          &amp;error,
          inf_test_util_parse_error_quark(),
          INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
          "Node '%s' unexpected",
          (const gchar*)child-&gt;name
        );
        break;
      }
    }
    if(error != NULL)
    {
      printf("Failed to parse: %s\n", error-&gt;message);
      g_error_free(error);
      xmlFreeDoc(doc);
      g_slist_free(requests);
      if(initial != NULL) inf_text_chunk_free(initial);</b></font>
      g_slist_free(users);
    }
    else
    {
      g_assert(initial != NULL);
      requests = g_slist_reverse(requests);
<a name="3"></a>      if(perform_test(max_total_log_size, initial, users, requests, &amp;error) ==
         TRUE)
      {
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        ++ result-&gt;passed;
        printf("OK\n");
      }
      else
      {
        printf("FAILED (%s)\n", error-&gt;message);
        g_error_free(error);
      }
      xmlFreeDoc(doc);
      g_slist_free(requests);
      inf_text_chunk_free(initial);
      g_slist_free(users);
    }
  }
}
int main(int argc, char* argv[])
{
  const char* dir;</b></font>
  GError* error;
  test_result result;
  if(argc &gt; 1)
    dir = argv[1];
  else
    dir = "cleanup";
  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return 1;
  }
  result.total = 0;
  result.passed = 0;
  if(inf_test_util_dir_foreach(dir, foreach_test_func, &amp;result, &amp;error) ==
     FALSE)
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    g_error_free(error);
    return -1;
  }
  printf("%u out of %u tests passed\n", result.passed, result.total);
  if(result.passed &lt; result.total)
    return -1;
  return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "util/inf-test-util.h"
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/common/inf-user-table.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;
#include &lt;string.h&gt;
#define NUM_PERMUTATIONS 100
typedef struct {
  GRand* rand;
  guint total;
  guint passed;
  gdouble time;
} test_result;
static gboolean
perform_single_test(InfTextChunk* initial,
                    InfTextChunk* final,
                    GSList* users,
                    GSList* requests,
                    gdouble* time)
{
  InfTextBuffer* buffer;
  InfCommunicationManager* manager;
  InfIo* io;
  InfTextSession* session;
  InfUserTable* user_table;
  InfTextUser* user;
  gchar* user_name;
  GSList* item;
  xmlNodePtr request;
  gboolean result;
  InfTextChunk* test_chunk;
  gchar* first;
  gchar* second;
  gsize first_bytes;
  gsize second_bytes;
  GTimer* timer;
  buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new("UTF-8"));
  inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);
  manager = inf_communication_manager_new();
  io = INF_IO(inf_standalone_io_new());
  user_table = inf_user_table_new();
  for(item = users; item != NULL; item = g_slist_next(item))
  {
    user_name = g_strdup_printf("User_%u", GPOINTER_TO_UINT(item-&gt;data));
    user = INF_TEXT_USER(
      g_object_new(
        INF_TEXT_TYPE_USER,
        "id", GPOINTER_TO_UINT(item-&gt;data),
        "name", user_name,
        "status", INF_USER_ACTIVE,
        "flags", 0,
        NULL
      )
    );
    g_free(user_name);
    inf_user_table_add_user(user_table, INF_USER(user));
    g_object_unref(user);
  }
  session = inf_text_session_new_with_user_table(
    manager,
    buffer,
    io,
    user_table,
    INF_SESSION_RUNNING,
    NULL,
    NULL
  );
  g_object_unref(G_OBJECT(io));
  g_object_unref(G_OBJECT(manager));
  g_object_unref(G_OBJECT(user_table));
  timer = g_timer_new();
  for(item = requests; item != NULL; item = item-&gt;next)
  {
    request = (xmlNodePtr)item-&gt;data;
    inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(session),
      NULL,
      request
    );
  }
  *time = g_timer_elapsed(timer, NULL);
  g_timer_destroy(timer);
  test_chunk = inf_text_buffer_get_slice(
    buffer,
    0,
    inf_text_buffer_get_length(buffer)
  );
  g_object_unref(G_OBJECT(session));
  result = inf_text_chunk_equal(test_chunk, final);
  if(result == FALSE)
  {
    first = inf_text_chunk_get_text(final, &amp;first_bytes);
    second = inf_text_chunk_get_text(test_chunk, &amp;second_bytes);
    printf("(%.*s vs. %.*s) ", (int)second_bytes, second, (int)first_bytes, first);
    g_free(second);
    g_free(first);
  }
  inf_text_chunk_free(test_chunk);
  g_object_unref(G_OBJECT(buffer));
  return result;
}
static gboolean
perform_test(InfTextChunk* initial,
             InfTextChunk* final,
             GSList* users,
             GSList* requests,
             GRand* rand,
             gdouble* time)
{
  GSList* permutation;
  GSList* item;
  GSList* item2;
  GSList* dist_item;
  unsigned int i;
  unsigned int dist;
  unsigned int rval;
  gpointer temp;
  gboolean retval;
  gdouble local_time;
  guint user;
  guint user2;
  InfAdoptedStateVector* v;
  GError* error;
  g_assert(requests != NULL);
  permutation = g_slist_copy(requests);
  v = inf_adopted_state_vector_new();
  error = NULL;
  for(item = permutation; item != NULL; item = g_slist_next(item))
  {
    if(!inf_xml_util_get_attribute_uint(item-&gt;data, "user", &amp;user, &amp;error))
    {
      printf("%s\n", error-&gt;message);
      inf_adopted_state_vector_free(v);
      g_slist_free(permutation);
      return FALSE;
    }
    ((xmlNodePtr)item-&gt;data)-&gt;_private = GUINT_TO_POINTER(
      inf_adopted_state_vector_get(v, user)
    );
    inf_adopted_state_vector_add(v, user, 1);
  }
  inf_adopted_state_vector_free(v);
  *time = 0.0;
  for(i = 0; i &lt; NUM_PERMUTATIONS; ++ i)
  {
    dist = 0;
    for(item = permutation-&gt;next; item != NULL; item = g_slist_next(item))
    {
      ++ dist;
      dist_item = g_slist_nth(permutation, g_rand_int(rand) % (dist + 1));
      rval = g_rand_int(rand) % (dist + 1);
      temp = item-&gt;data;
      item-&gt;data = dist_item-&gt;data;
      dist_item-&gt;data = temp;
    }
    for(item = permutation; item != NULL; item = g_slist_next(item))
    {
      for(item2 = item-&gt;next; item2 != NULL; item2 = g_slist_next(item2))
      {
        inf_xml_util_get_attribute_uint(item-&gt;data, "user", &amp;user, NULL);
        inf_xml_util_get_attribute_uint(item2-&gt;data, "user", &amp;user2, NULL);
        if(user == user2)
        {
          if(GPOINTER_TO_UINT( ((xmlNodePtr)item-&gt;data)-&gt;_private) &gt;
             GPOINTER_TO_UINT( ((xmlNodePtr)item2-&gt;data)-&gt;_private) )
          {
            temp = item-&gt;data;
            item-&gt;data = item2-&gt;data;
            item2-&gt;data = temp;
          }
        }
      }
    }
    if(i % (MAX(NUM_PERMUTATIONS/30, 1)) == 0)
    {
      printf(".");
      fflush(stdout);
    }
    retval = perform_single_test(
      initial,
      final,
      users,
      permutation,
      &amp;local_time
    );
    if(!retval) break;
    *time += local_time;
<a name="2"></a>  }
  g_slist_free(permutation);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return retval;
}
static void
foreach_test_func(const gchar* testfile,
                  gpointer user_data)
{
  test_result* result;
  xmlDocPtr doc;
  xmlNodePtr root;
  xmlNodePtr child;
  GSList* requests;
  InfTextChunk* initial;
  InfTextChunk* final;
  GSList* users;
  GError* error;
  gboolean retval;
  gdouble local_time;
  if(!g_str_has_suffix(testfile, ".xml"))
    return;
  result = (test_result*)user_data;
  doc = xmlParseFile(testfile);
  requests = NULL;
<a name="1"></a>  initial = NULL;
  final = NULL;
  error = NULL;</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  users = NULL;
  printf("%s... ", testfile);
  fflush(stdout);
  ++ result-&gt;total;
  if(doc != NULL)
  {
    root = xmlDocGetRootElement(doc);
    for(child = root-&gt;children; child != NULL; child = child-&gt;next)
    {
      if(child-&gt;type != XML_ELEMENT_NODE) continue;
      if(strcmp((const char*)child-&gt;name, "initial-buffer") == 0)
<a name="0"></a>      {</b></font>
        if(initial != NULL) inf_text_chunk_free(initial);
        initial = inf_test_util_parse_buffer(child, &amp;error);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if(initial == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, "final-buffer") == 0)
      {
        if(final != NULL) inf_text_chunk_free(final);
        final = inf_test_util_parse_buffer(child, &amp;error);
        if(final == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, "user") == 0)
      {
        if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
<a name="4"></a>          break;
      }
      else if(strcmp((const char*)child-&gt;name, "request") == 0)</b></font>
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      {
        requests = g_slist_prepend(requests, child);
      }
      else
      {
        g_set_error(
          &amp;error,
          inf_test_util_parse_error_quark(),
          INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
          "Node '%s' unexpected",
          (const gchar*)child-&gt;name
        );
        break;
      }
    }
    if(error != NULL)
    {
      printf("Failed to parse: %s\n", error-&gt;message);
      g_error_free(error);
      xmlFreeDoc(doc);
      g_slist_free(requests);
      if(initial != NULL) inf_text_chunk_free(initial);</b></font>
      if(final != NULL) inf_text_chunk_free(final);
      g_slist_free(users);
    }
    else
    {
      g_assert(initial != NULL);
      g_assert(final != NULL);
      requests = g_slist_reverse(requests);
      retval = perform_test(
        initial,
        final,
        users,
        requests,
        result-&gt;rand,
        &amp;local_time
      );
      if(retval == TRUE)
<a name="3"></a>      {
        ++ result-&gt;passed;
        printf("OK (%g secs)\n", local_time);
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        result-&gt;time += local_time;
      }
      else
      {
        printf("FAILED\n");
      }
      xmlFreeDoc(doc);
      g_slist_free(requests);
      inf_text_chunk_free(initial);
      inf_text_chunk_free(final);
      g_slist_free(users);
    }
  }
}
int main(int argc, char* argv[])
{
  const char* dir;</b></font>
  GError* error;
  test_result result;
  unsigned int rseed;
  int dirarg;
  gboolean retval;
  GTimer* timer;
  gdouble elapsed;
  dirarg = 1;
  if(argc &gt; 1)
  {
    rseed = atoi(argv[1]);
    if(rseed &gt; 0) dirarg = 2;
    else rseed = time(NULL);
  }
  else
  {
    rseed = time(NULL);
  }
  printf("Using random seed %u\n", rseed);
  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return 1;
  }
  if(argc &gt; dirarg)
    dir = argv[dirarg];
  else
    dir = "session";
  result.rand = g_rand_new_with_seed(rseed);
  result.total = 0;
  result.passed = 0;
  result.time = 0.0;
  timer = g_timer_new();
  retval = inf_test_util_dir_foreach(
    dir,
    foreach_test_func,
    &amp;result,
    &amp;error
  );
  g_timer_stop(timer);
  elapsed = g_timer_elapsed(timer, NULL);
  g_rand_free(result.rand);
  g_timer_destroy(timer);
  if(retval == FALSE)
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    g_error_free(error);
    return -1;
  }
  printf(
    "%u out of %u tests passed (real %g secs, algo %g secs)\n",
    result.passed, result.total, elapsed, result.time
  );
  if(result.passed &lt; result.total)
    return -1;
  return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
