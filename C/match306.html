<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-text-cleanup.c &amp; inf-test-text-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-text-cleanup.c &amp; inf-test-text-session.c
      </h3>
<h1 align="center">
        35.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-text-cleanup.c (39.20705%)<th>inf-test-text-session.c (33.085503%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(347-360)<td><a href="#" name="0">(316-329)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(323-338)<td><a href="#" name="1">(298-313)</a><td align="center"><font color="#b00000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(293-322)<td><a href="#" name="2">(266-297)</a><td align="center"><font color="#a60000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(397-416)<td><a href="#" name="3">(378-397)</a><td align="center"><font color="#890000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(362-386)<td><a href="#" name="4">(330-354)</a><td align="center"><font color="#890000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-cleanup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "util/inf-test-util.h"
2 #include &lt;libinftext/inf-text-session.h&gt;
3 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
4 #include &lt;libinftext/inf-text-insert-operation.h&gt;
5 #include &lt;libinftext/inf-text-delete-operation.h&gt;
6 #include &lt;libinftext/inf-text-default-buffer.h&gt;
7 #include &lt;libinftext/inf-text-user.h&gt;
8 #include &lt;libinfinity/common/inf-user-table.h&gt;
9 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
10 #include &lt;libinfinity/common/inf-xml-util.h&gt;
11 #include &lt;libinfinity/common/inf-init.h&gt;
12 #include &lt;string.h&gt;
13 typedef struct {
14   guint total;
15   guint passed;
16 } test_result;
17 typedef enum {
18   INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
19   INF_TEST_TEXT_CLEANUP_UNSUPPORTED,
20   INF_TEST_TEXT_CLEANUP_VERIFY_FAILED
21 } InfTestTextCleanupError;
22 static GQuark
23 inf_test_text_cleanup_error_quark()
24 {
25   return g_quark_from_static_string("INF_TEST_TEXT_CLEANUP_ERROR");
26 }
27 static void
28 error_cb(InfSession* session,
29          InfXmlConnection* connection,
30          xmlNodePtr xml,
31          const GError* error,
32          gpointer user_data)
33 {
34   GError** error_loc = (GError**)user_data;
35   *error_loc = g_error_copy(error);
36 }
37 static gboolean
38 perform_test(guint max_total_log_size,
39              InfTextChunk* initial,
40              GSList* users,
41              GSList* requests,
42              GError** error)
43 {
44   InfTextBuffer* buffer;
45   InfCommunicationManager* manager;
46   InfIo* io;
47   InfTextSession* session;
48   InfAdoptedAlgorithm* algorithm;
49   InfUserTable* user_table;
50   InfTextUser* user;
51   gchar* user_name;
52   GSList* item;
53   xmlNodePtr request;
54   gboolean result;
55   GError* local_error;
56   guint verify_user_id;
57   InfAdoptedUser* verify_user;
58   guint verify_log_size;
59   gint verify_can_undo;
60   gint verify_can_redo;
61   InfAdoptedRequestLog* log;
62   guint log_size;
63   buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new("UTF-8"));
64   inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);
65   manager = inf_communication_manager_new();
66   io = INF_IO(inf_standalone_io_new());
67   user_table = inf_user_table_new();
68   local_error = NULL;
69   for(item = users; item != NULL; item = g_slist_next(item))
70   {
71     user_name = g_strdup_printf("User_%u", GPOINTER_TO_UINT(item-&gt;data));
72     user = INF_TEXT_USER(
73       g_object_new(
74         INF_TEXT_TYPE_USER,
75         "id", GPOINTER_TO_UINT(item-&gt;data),
76         "name", user_name,
77         "status", INF_USER_ACTIVE,
78         "flags", 0,
79         NULL
80       )
81     );
82     g_free(user_name);
83     inf_user_table_add_user(user_table, INF_USER(user));
84     g_object_unref(user);
85   }
86   session = INF_TEXT_SESSION(
87     g_object_new(
88       INF_TEXT_TYPE_SESSION,
89       "communication-manager", manager,
90       "buffer", buffer,
91       "io", io,
92       "user_table", user_table,
93       "max-total-log-size", max_total_log_size,
94       NULL
95     )
96   );
97   g_signal_connect(
98     G_OBJECT(session),
99     "error",
100     G_CALLBACK(error_cb),
101     &amp;local_error
102   );
103   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
104   g_object_unref(io);
105   g_object_unref(manager);
106   g_object_unref(user_table);
107   g_object_unref(buffer);
108   for(item = requests; item != NULL; item = item-&gt;next)
109   {
110     request = (xmlNodePtr)item-&gt;data;
111     if(strcmp((const char*)request-&gt;name, "request") == 0)
112     {
113       result = inf_communication_object_received(
114         INF_COMMUNICATION_OBJECT(session),
115         NULL,
116         request
117       );
118       if(local_error != NULL)
119       {
120         g_prefix_error(&amp;local_error, "[%d] ", request-&gt;line);
121         goto fail;
122       }
123     }
124     else
125     {
126       result = inf_xml_util_get_attribute_uint_required(
127         request,
128         "user",
129         &amp;verify_user_id,
130         &amp;local_error
131       );
132       if(result == FALSE)
133         goto fail;
134       verify_user = INF_ADOPTED_USER(
135         inf_user_table_lookup_user_by_id(user_table, verify_user_id)
136       );
137       if(verify_user == NULL)
138       {
139         g_set_error(
140           error,
141           inf_test_text_cleanup_error_quark(),
142           INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
143           "[%d] User ID '%u' not available",
144           request-&gt;line,
145           verify_user_id
146         );
147         goto fail;
148       }
149       result = inf_xml_util_get_attribute_uint(
150         request,
151         "log-size",
152         &amp;verify_log_size,
153         &amp;local_error
154       );
155       if(local_error) goto fail;
156       if(result)
157       {
158         log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(verify_user));
159         log_size = inf_adopted_request_log_get_end(log) -
160           inf_adopted_request_log_get_begin(log);
161         if(verify_log_size != log_size)
162         {
163           g_set_error(
164             error,
165             inf_test_text_cleanup_error_quark(),
166             INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
167             "[%d] Log size does not match; got %u, but expected %u",
168             request-&gt;line,
169             log_size,
170             verify_log_size
171           );
172           goto fail;
173         }
174       }
175       result = inf_xml_util_get_attribute_int(
176         request,
177         "can-undo",
178         &amp;verify_can_undo,
179         &amp;local_error
180       );
181       if(local_error) goto fail;
182       if(result)
183       {
184         result = inf_adopted_algorithm_can_undo(algorithm, verify_user);
185         if(result != verify_can_undo)
186         {
187           g_set_error(
188             error,
189             inf_test_text_cleanup_error_quark(),
190             INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
191             "[%d] can-undo does not match; got %d, but expected %d",
192             request-&gt;line,
193             (guint)result,
194             verify_can_undo
195           );
196           goto fail;
197         }
198       }
199       result = inf_xml_util_get_attribute_int(
200         request,
201         "can-redo",
202         &amp;verify_can_redo,
203         &amp;local_error
204       );
205       if(local_error) goto fail;
206       if(result)
207       {
208         result = inf_adopted_algorithm_can_redo(algorithm, verify_user);
209         if(result != verify_can_redo)
210         {
211           g_set_error(
212             error,
213             inf_test_text_cleanup_error_quark(),
214             INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
215             "[%d] can-redo does not match; got %d, but expected %d",
216             request-&gt;line,
217             (guint)result,
218             verify_can_redo
219           );
220           goto fail;
221         }
222       }
223     }
224   }
225   g_object_unref(session);
226   return TRUE;
227 <a name="2"></a>fail:
228   g_object_unref(session);
229   if(local_error) g_propagate_error(error, local_error);
230 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return FALSE;
231 }
232 static void
233 foreach_test_func(const gchar* testfile,
234                   gpointer user_data)
235 {
236   test_result* result;
237   xmlDocPtr doc;
238   xmlNodePtr root;
239   xmlNodePtr child;
240   GSList* requests;
241   InfTextChunk* initial;
242   GSList* users;
243   guint max_total_log_size;
244   GError* error;
245   gboolean res;
246   if(!g_str_has_suffix(testfile, ".xml"))
247     return;
248   result = (test_result*)user_data;
249   doc = xmlParseFile(testfile);
250   requests = NULL;
251 <a name="1"></a>  initial = NULL;
252   users = NULL;
253   max_total_log_size = 0;</b></font>
254 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  error = NULL;
255   printf("%s... ", testfile);
256   fflush(stdout);
257   ++ result-&gt;total;
258   if(doc != NULL)
259   {
260     root = xmlDocGetRootElement(doc);
261     for(child = root-&gt;children; child != NULL; child = child-&gt;next)
262     {
263       if(child-&gt;type != XML_ELEMENT_NODE) continue;
264       if(strcmp((const char*)child-&gt;name, "log") == 0)
265       {</b></font>
266         res = inf_xml_util_get_attribute_uint_required(
267           child,
268           "size",
269           &amp;max_total_log_size,
270           &amp;error
271 <a name="0"></a>        );
272         if(!res)
273 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          break;
274       }
275       else if(strcmp((const char*)child-&gt;name, "initial-buffer") == 0)
276       {
277         if(initial != NULL) inf_text_chunk_free(initial);
278         initial = inf_test_util_parse_buffer(child, &amp;error);
279         if(initial == NULL) break;
280       }
281       else if(strcmp((const char*)child-&gt;name, "user") == 0)
282       {
283         if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
284           break;
285 <a name="4"></a>      }
286       else if(strcmp((const char*)child-&gt;name, "request") == 0 ||</b></font>
287               strcmp((const char*)child-&gt;name, "verify") == 0)
288 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      {
289         requests = g_slist_prepend(requests, child);
290       }
291       else
292       {
293         g_set_error(
294           &amp;error,
295           inf_test_util_parse_error_quark(),
296           INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
297           "Node '%s' unexpected",
298           (const gchar*)child-&gt;name
299         );
300         break;
301       }
302     }
303     if(error != NULL)
304     {
305       printf("Failed to parse: %s\n", error-&gt;message);
306       g_error_free(error);
307       xmlFreeDoc(doc);
308       g_slist_free(requests);
309       if(initial != NULL) inf_text_chunk_free(initial);</b></font>
310       g_slist_free(users);
311     }
312     else
313     {
314       g_assert(initial != NULL);
315       requests = g_slist_reverse(requests);
316 <a name="3"></a>      if(perform_test(max_total_log_size, initial, users, requests, &amp;error) ==
317          TRUE)
318       {
319 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        ++ result-&gt;passed;
320         printf("OK\n");
321       }
322       else
323       {
324         printf("FAILED (%s)\n", error-&gt;message);
325         g_error_free(error);
326       }
327       xmlFreeDoc(doc);
328       g_slist_free(requests);
329       inf_text_chunk_free(initial);
330       g_slist_free(users);
331     }
332   }
333 }
334 int main(int argc, char* argv[])
335 {
336   const char* dir;</b></font>
337   GError* error;
338   test_result result;
339   if(argc &gt; 1)
340     dir = argv[1];
341   else
342     dir = "cleanup";
343   error = NULL;
344   if(!inf_init(&amp;error))
345   {
346     fprintf(stderr, "%s\n", error-&gt;message);
347     return 1;
348   }
349   result.total = 0;
350   result.passed = 0;
351   if(inf_test_util_dir_foreach(dir, foreach_test_func, &amp;result, &amp;error) ==
352      FALSE)
353   {
354     fprintf(stderr, "%s\n", error-&gt;message);
355     g_error_free(error);
356     return -1;
357   }
358   printf("%u out of %u tests passed\n", result.passed, result.total);
359   if(result.passed &lt; result.total)
360     return -1;
361   return 0;
362 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "util/inf-test-util.h"
2 #include &lt;libinftext/inf-text-session.h&gt;
3 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
4 #include &lt;libinftext/inf-text-insert-operation.h&gt;
5 #include &lt;libinftext/inf-text-delete-operation.h&gt;
6 #include &lt;libinftext/inf-text-default-buffer.h&gt;
7 #include &lt;libinftext/inf-text-user.h&gt;
8 #include &lt;libinfinity/common/inf-user-table.h&gt;
9 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
10 #include &lt;libinfinity/common/inf-xml-util.h&gt;
11 #include &lt;libinfinity/common/inf-init.h&gt;
12 #include &lt;string.h&gt;
13 #define NUM_PERMUTATIONS 100
14 typedef struct {
15   GRand* rand;
16   guint total;
17   guint passed;
18   gdouble time;
19 } test_result;
20 static gboolean
21 perform_single_test(InfTextChunk* initial,
22                     InfTextChunk* final,
23                     GSList* users,
24                     GSList* requests,
25                     gdouble* time)
26 {
27   InfTextBuffer* buffer;
28   InfCommunicationManager* manager;
29   InfIo* io;
30   InfTextSession* session;
31   InfUserTable* user_table;
32   InfTextUser* user;
33   gchar* user_name;
34   GSList* item;
35   xmlNodePtr request;
36   gboolean result;
37   InfTextChunk* test_chunk;
38   gchar* first;
39   gchar* second;
40   gsize first_bytes;
41   gsize second_bytes;
42   GTimer* timer;
43   buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new("UTF-8"));
44   inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);
45   manager = inf_communication_manager_new();
46   io = INF_IO(inf_standalone_io_new());
47   user_table = inf_user_table_new();
48   for(item = users; item != NULL; item = g_slist_next(item))
49   {
50     user_name = g_strdup_printf("User_%u", GPOINTER_TO_UINT(item-&gt;data));
51     user = INF_TEXT_USER(
52       g_object_new(
53         INF_TEXT_TYPE_USER,
54         "id", GPOINTER_TO_UINT(item-&gt;data),
55         "name", user_name,
56         "status", INF_USER_ACTIVE,
57         "flags", 0,
58         NULL
59       )
60     );
61     g_free(user_name);
62     inf_user_table_add_user(user_table, INF_USER(user));
63     g_object_unref(user);
64   }
65   session = inf_text_session_new_with_user_table(
66     manager,
67     buffer,
68     io,
69     user_table,
70     INF_SESSION_RUNNING,
71     NULL,
72     NULL
73   );
74   g_object_unref(G_OBJECT(io));
75   g_object_unref(G_OBJECT(manager));
76   g_object_unref(G_OBJECT(user_table));
77   timer = g_timer_new();
78   for(item = requests; item != NULL; item = item-&gt;next)
79   {
80     request = (xmlNodePtr)item-&gt;data;
81     inf_communication_object_received(
82       INF_COMMUNICATION_OBJECT(session),
83       NULL,
84       request
85     );
86   }
87   *time = g_timer_elapsed(timer, NULL);
88   g_timer_destroy(timer);
89   test_chunk = inf_text_buffer_get_slice(
90     buffer,
91     0,
92     inf_text_buffer_get_length(buffer)
93   );
94   g_object_unref(G_OBJECT(session));
95   result = inf_text_chunk_equal(test_chunk, final);
96   if(result == FALSE)
97   {
98     first = inf_text_chunk_get_text(final, &amp;first_bytes);
99     second = inf_text_chunk_get_text(test_chunk, &amp;second_bytes);
100     printf("(%.*s vs. %.*s) ", (int)second_bytes, second, (int)first_bytes, first);
101     g_free(second);
102     g_free(first);
103   }
104   inf_text_chunk_free(test_chunk);
105   g_object_unref(G_OBJECT(buffer));
106   return result;
107 }
108 static gboolean
109 perform_test(InfTextChunk* initial,
110              InfTextChunk* final,
111              GSList* users,
112              GSList* requests,
113              GRand* rand,
114              gdouble* time)
115 {
116   GSList* permutation;
117   GSList* item;
118   GSList* item2;
119   GSList* dist_item;
120   unsigned int i;
121   unsigned int dist;
122   unsigned int rval;
123   gpointer temp;
124   gboolean retval;
125   gdouble local_time;
126   guint user;
127   guint user2;
128   InfAdoptedStateVector* v;
129   GError* error;
130   g_assert(requests != NULL);
131   permutation = g_slist_copy(requests);
132   v = inf_adopted_state_vector_new();
133   error = NULL;
134   for(item = permutation; item != NULL; item = g_slist_next(item))
135   {
136     if(!inf_xml_util_get_attribute_uint(item-&gt;data, "user", &amp;user, &amp;error))
137     {
138       printf("%s\n", error-&gt;message);
139       inf_adopted_state_vector_free(v);
140       g_slist_free(permutation);
141       return FALSE;
142     }
143     ((xmlNodePtr)item-&gt;data)-&gt;_private = GUINT_TO_POINTER(
144       inf_adopted_state_vector_get(v, user)
145     );
146     inf_adopted_state_vector_add(v, user, 1);
147   }
148   inf_adopted_state_vector_free(v);
149   *time = 0.0;
150   for(i = 0; i &lt; NUM_PERMUTATIONS; ++ i)
151   {
152     dist = 0;
153     for(item = permutation-&gt;next; item != NULL; item = g_slist_next(item))
154     {
155       ++ dist;
156       dist_item = g_slist_nth(permutation, g_rand_int(rand) % (dist + 1));
157       rval = g_rand_int(rand) % (dist + 1);
158       temp = item-&gt;data;
159       item-&gt;data = dist_item-&gt;data;
160       dist_item-&gt;data = temp;
161     }
162     for(item = permutation; item != NULL; item = g_slist_next(item))
163     {
164       for(item2 = item-&gt;next; item2 != NULL; item2 = g_slist_next(item2))
165       {
166         inf_xml_util_get_attribute_uint(item-&gt;data, "user", &amp;user, NULL);
167         inf_xml_util_get_attribute_uint(item2-&gt;data, "user", &amp;user2, NULL);
168         if(user == user2)
169         {
170           if(GPOINTER_TO_UINT( ((xmlNodePtr)item-&gt;data)-&gt;_private) &gt;
171              GPOINTER_TO_UINT( ((xmlNodePtr)item2-&gt;data)-&gt;_private) )
172           {
173             temp = item-&gt;data;
174             item-&gt;data = item2-&gt;data;
175             item2-&gt;data = temp;
176           }
177         }
178       }
179     }
180     if(i % (MAX(NUM_PERMUTATIONS/30, 1)) == 0)
181     {
182       printf(".");
183       fflush(stdout);
184     }
185     retval = perform_single_test(
186       initial,
187       final,
188       users,
189       permutation,
190       &amp;local_time
191     );
192     if(!retval) break;
193     *time += local_time;
194 <a name="2"></a>  }
195   g_slist_free(permutation);
196 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return retval;
197 }
198 static void
199 foreach_test_func(const gchar* testfile,
200                   gpointer user_data)
201 {
202   test_result* result;
203   xmlDocPtr doc;
204   xmlNodePtr root;
205   xmlNodePtr child;
206   GSList* requests;
207   InfTextChunk* initial;
208   InfTextChunk* final;
209   GSList* users;
210   GError* error;
211   gboolean retval;
212   gdouble local_time;
213   if(!g_str_has_suffix(testfile, ".xml"))
214     return;
215   result = (test_result*)user_data;
216   doc = xmlParseFile(testfile);
217   requests = NULL;
218 <a name="1"></a>  initial = NULL;
219   final = NULL;
220   error = NULL;</b></font>
221 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  users = NULL;
222   printf("%s... ", testfile);
223   fflush(stdout);
224   ++ result-&gt;total;
225   if(doc != NULL)
226   {
227     root = xmlDocGetRootElement(doc);
228     for(child = root-&gt;children; child != NULL; child = child-&gt;next)
229     {
230       if(child-&gt;type != XML_ELEMENT_NODE) continue;
231       if(strcmp((const char*)child-&gt;name, "initial-buffer") == 0)
232 <a name="0"></a>      {</b></font>
233         if(initial != NULL) inf_text_chunk_free(initial);
234         initial = inf_test_util_parse_buffer(child, &amp;error);
235 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if(initial == NULL) break;
236       }
237       else if(strcmp((const char*)child-&gt;name, "final-buffer") == 0)
238       {
239         if(final != NULL) inf_text_chunk_free(final);
240         final = inf_test_util_parse_buffer(child, &amp;error);
241         if(final == NULL) break;
242       }
243       else if(strcmp((const char*)child-&gt;name, "user") == 0)
244       {
245         if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
246 <a name="4"></a>          break;
247       }
248       else if(strcmp((const char*)child-&gt;name, "request") == 0)</b></font>
249 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      {
250         requests = g_slist_prepend(requests, child);
251       }
252       else
253       {
254         g_set_error(
255           &amp;error,
256           inf_test_util_parse_error_quark(),
257           INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
258           "Node '%s' unexpected",
259           (const gchar*)child-&gt;name
260         );
261         break;
262       }
263     }
264     if(error != NULL)
265     {
266       printf("Failed to parse: %s\n", error-&gt;message);
267       g_error_free(error);
268       xmlFreeDoc(doc);
269       g_slist_free(requests);
270       if(initial != NULL) inf_text_chunk_free(initial);</b></font>
271       if(final != NULL) inf_text_chunk_free(final);
272       g_slist_free(users);
273     }
274     else
275     {
276       g_assert(initial != NULL);
277       g_assert(final != NULL);
278       requests = g_slist_reverse(requests);
279       retval = perform_test(
280         initial,
281         final,
282         users,
283         requests,
284         result-&gt;rand,
285         &amp;local_time
286       );
287       if(retval == TRUE)
288 <a name="3"></a>      {
289         ++ result-&gt;passed;
290         printf("OK (%g secs)\n", local_time);
291 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        result-&gt;time += local_time;
292       }
293       else
294       {
295         printf("FAILED\n");
296       }
297       xmlFreeDoc(doc);
298       g_slist_free(requests);
299       inf_text_chunk_free(initial);
300       inf_text_chunk_free(final);
301       g_slist_free(users);
302     }
303   }
304 }
305 int main(int argc, char* argv[])
306 {
307   const char* dir;</b></font>
308   GError* error;
309   test_result result;
310   unsigned int rseed;
311   int dirarg;
312   gboolean retval;
313   GTimer* timer;
314   gdouble elapsed;
315   dirarg = 1;
316   if(argc &gt; 1)
317   {
318     rseed = atoi(argv[1]);
319     if(rseed &gt; 0) dirarg = 2;
320     else rseed = time(NULL);
321   }
322   else
323   {
324     rseed = time(NULL);
325   }
326   printf("Using random seed %u\n", rseed);
327   error = NULL;
328   if(!inf_init(&amp;error))
329   {
330     fprintf(stderr, "%s\n", error-&gt;message);
331     return 1;
332   }
333   if(argc &gt; dirarg)
334     dir = argv[dirarg];
335   else
336     dir = "session";
337   result.rand = g_rand_new_with_seed(rseed);
338   result.total = 0;
339   result.passed = 0;
340   result.time = 0.0;
341   timer = g_timer_new();
342   retval = inf_test_util_dir_foreach(
343     dir,
344     foreach_test_func,
345     &amp;result,
346     &amp;error
347   );
348   g_timer_stop(timer);
349   elapsed = g_timer_elapsed(timer, NULL);
350   g_rand_free(result.rand);
351   g_timer_destroy(timer);
352   if(retval == FALSE)
353   {
354     fprintf(stderr, "%s\n", error-&gt;message);
355     g_error_free(error);
356     return -1;
357   }
358   printf(
359     "%u out of %u tests passed (real %g secs, algo %g secs)\n",
360     result.passed, result.total, elapsed, result.time
361   );
362   if(result.passed &lt; result.total)
363     return -1;
364   return 0;
365 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
