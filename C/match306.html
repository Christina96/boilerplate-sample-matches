<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-test-text-cleanup.c & inf-test-text-session.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-test-text-cleanup.c & inf-test-text-session.c
      </h3>
      <h1 align="center">
        35.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-test-text-cleanup.c (39.20705%)<TH>inf-test-text-session.c (33.085503%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match306-0.html#0',2,'match306-1.html#0',3)" NAME="0">(347-360)<TD><A HREF="javascript:ZweiFrames('match306-0.html#0',2,'match306-1.html#0',3)" NAME="0">(316-329)</A><TD ALIGN=center><FONT COLOR="#ff0000">26</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match306-0.html#1',2,'match306-1.html#1',3)" NAME="1">(323-338)<TD><A HREF="javascript:ZweiFrames('match306-0.html#1',2,'match306-1.html#1',3)" NAME="1">(298-313)</A><TD ALIGN=center><FONT COLOR="#b00000">18</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match306-0.html#2',2,'match306-1.html#2',3)" NAME="2">(293-322)<TD><A HREF="javascript:ZweiFrames('match306-0.html#2',2,'match306-1.html#2',3)" NAME="2">(266-297)</A><TD ALIGN=center><FONT COLOR="#a60000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match306-0.html#3',2,'match306-1.html#3',3)" NAME="3">(397-416)<TD><A HREF="javascript:ZweiFrames('match306-0.html#3',2,'match306-1.html#3',3)" NAME="3">(378-397)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match306-0.html#4',2,'match306-1.html#4',3)" NAME="4">(362-386)<TD><A HREF="javascript:ZweiFrames('match306-0.html#4',2,'match306-1.html#4',3)" NAME="4">(330-354)</A><TD ALIGN=center><FONT COLOR="#890000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-cleanup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &quot;util/inf-test-util.h&quot;

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/common/inf-user-table.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

typedef struct {
  guint total;
  guint passed;
} test_result;

typedef enum {
  INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
  INF_TEST_TEXT_CLEANUP_UNSUPPORTED,
  INF_TEST_TEXT_CLEANUP_VERIFY_FAILED
} InfTestTextCleanupError;

static GQuark
inf_test_text_cleanup_error_quark()
{
  return g_quark_from_static_string(&quot;INF_TEST_TEXT_CLEANUP_ERROR&quot;);
}

static void
error_cb(InfSession* session,
         InfXmlConnection* connection,
         xmlNodePtr xml,
         const GError* error,
         gpointer user_data)
{
  GError** error_loc = (GError**)user_data;
  *error_loc = g_error_copy(error);
}

static gboolean
perform_test(guint max_total_log_size,
             InfTextChunk* initial,
             GSList* users,
             GSList* requests,
             GError** error)
{
  InfTextBuffer* buffer;
  InfCommunicationManager* manager;
  InfIo* io;
  InfTextSession* session;
  InfAdoptedAlgorithm* algorithm;

  InfUserTable* user_table;
  InfTextUser* user;
  gchar* user_name;

  GSList* item;
  xmlNodePtr request;
  gboolean result;
  GError* local_error;
  
  guint verify_user_id;
  InfAdoptedUser* verify_user;
  guint verify_log_size;
  gint verify_can_undo;
  gint verify_can_redo;

  InfAdoptedRequestLog* log;
  guint log_size;

  buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new(&quot;UTF-8&quot;));
  inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);

  manager = inf_communication_manager_new();
  io = INF_IO(inf_standalone_io_new());
  user_table = inf_user_table_new();
  local_error = NULL;

  for(item = users; item != NULL; item = g_slist_next(item))
  {
    user_name = g_strdup_printf(&quot;User_%u&quot;, GPOINTER_TO_UINT(item-&gt;data));

    user = INF_TEXT_USER(
      g_object_new(
        INF_TEXT_TYPE_USER,
        &quot;id&quot;, GPOINTER_TO_UINT(item-&gt;data),
        &quot;name&quot;, user_name,
        &quot;status&quot;, INF_USER_ACTIVE,
        &quot;flags&quot;, 0,
        NULL
      )
    );

    g_free(user_name);
    inf_user_table_add_user(user_table, INF_USER(user));
    g_object_unref(user);
  }

  session = INF_TEXT_SESSION(
    g_object_new(
      INF_TEXT_TYPE_SESSION,
      &quot;communication-manager&quot;, manager,
      &quot;buffer&quot;, buffer,
      &quot;io&quot;, io,
      &quot;user_table&quot;, user_table,
      &quot;max-total-log-size&quot;, max_total_log_size,
      NULL
    )
  );

  g_signal_connect(
    G_OBJECT(session),
    &quot;error&quot;,
    G_CALLBACK(error_cb),
    &amp;local_error
  );
  
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));

  g_object_unref(io);
  g_object_unref(manager);
  g_object_unref(user_table);
  g_object_unref(buffer);

  for(item = requests; item != NULL; item = item-&gt;next)
  {
    request = (xmlNodePtr)item-&gt;data;
    
    if(strcmp((const char*)request-&gt;name, &quot;request&quot;) == 0)
    {
      /* Request */
      result = inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(session),
        NULL,
        request
      );

      if(local_error != NULL)
      {
        g_prefix_error(&amp;local_error, &quot;[%d] &quot;, request-&gt;line);
        goto fail;
      }
    }
    else
    {
      /* TODO: Make an extra function out of this: */
      /* Verify */
      result = inf_xml_util_get_attribute_uint_required(
        request,
        &quot;user&quot;,
        &amp;verify_user_id,
        &amp;local_error
      );
      
      if(result == FALSE)
        goto fail;

      verify_user = INF_ADOPTED_USER(
        inf_user_table_lookup_user_by_id(user_table, verify_user_id)
      );

      if(verify_user == NULL)
      {
        g_set_error(
          error,
          inf_test_text_cleanup_error_quark(),
          INF_TEST_TEXT_CLEANUP_USER_UNAVAILABLE,
          &quot;[%d] User ID '%u' not available&quot;,
          request-&gt;line,
          verify_user_id
        );
        
        goto fail;
      }

      result = inf_xml_util_get_attribute_uint(
        request,
        &quot;log-size&quot;,
        &amp;verify_log_size,
        &amp;local_error
      );

      if(local_error) goto fail;

      if(result)
      {
        log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(verify_user));
        log_size = inf_adopted_request_log_get_end(log) -
          inf_adopted_request_log_get_begin(log);
        if(verify_log_size != log_size)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            &quot;[%d] Log size does not match; got %u, but expected %u&quot;,
            request-&gt;line,
            log_size,
            verify_log_size
          );

          goto fail;
        }
      }
      
      result = inf_xml_util_get_attribute_int(
        request,
        &quot;can-undo&quot;,
        &amp;verify_can_undo,
        &amp;local_error
      );

      if(local_error) goto fail;

      if(result)
      {
        result = inf_adopted_algorithm_can_undo(algorithm, verify_user);
        if(result != verify_can_undo)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            &quot;[%d] can-undo does not match; got %d, but expected %d&quot;,
            request-&gt;line,
            (guint)result,
            verify_can_undo
          );

          goto fail;
        }
      }

      result = inf_xml_util_get_attribute_int(
        request,
        &quot;can-redo&quot;,
        &amp;verify_can_redo,
        &amp;local_error
      );

      if(local_error) goto fail;

      if(result)
      {
        result = inf_adopted_algorithm_can_redo(algorithm, verify_user);
        if(result != verify_can_redo)
        {
          g_set_error(
            error,
            inf_test_text_cleanup_error_quark(),
            INF_TEST_TEXT_CLEANUP_VERIFY_FAILED,
            &quot;[%d] can-redo does not match; got %d, but expected %d&quot;,
            request-&gt;line,
            (guint)result,
            verify_can_redo
          );

          goto fail;
        }
      }
    }
  }

  g_object_unref(session);
  return TRUE;

<A NAME="2"></A>fail:
  g_object_unref(session);
  if(local_error) g_propagate_error(error, local_error);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match306-1.html#2',3,'match306-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  return FALSE;
}

static void
foreach_test_func(const gchar* testfile,
                  gpointer user_data)
{
  test_result* result;
  xmlDocPtr doc;
  xmlNodePtr root;
  xmlNodePtr child;

  GSList* requests;
  InfTextChunk* initial;
  GSList* users;
  guint max_total_log_size;
  GError* error;
  gboolean res;

  /* Only process XML files, not the Makefiles or other stuff */
  if(!g_str_has_suffix(testfile, &quot;.xml&quot;))
    return;

  result = (test_result*)user_data;
  doc = xmlParseFile(testfile);

  requests = NULL;
<A NAME="1"></A>  initial = NULL;
  users = NULL;
  max_total_log_size = 0;</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match306-1.html#1',3,'match306-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  error = NULL;

  printf(&quot;%s... &quot;, testfile);
  fflush(stdout);

  ++ result-&gt;total;

  if(doc != NULL)
  {
    root = xmlDocGetRootElement(doc);
    for(child = root-&gt;children; child != NULL; child = child-&gt;next)
    {
      if(child-&gt;type != XML_ELEMENT_NODE) continue;

      if(strcmp((const char*)child-&gt;name, &quot;log&quot;) == 0)
      {</B></FONT>
        res = inf_xml_util_get_attribute_uint_required(
          child,
          &quot;size&quot;,
          &amp;max_total_log_size,
          &amp;error
<A NAME="0"></A>        );

        if(!res)
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match306-1.html#0',3,'match306-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>          break;
      }
      else if(strcmp((const char*)child-&gt;name, &quot;initial-buffer&quot;) == 0)
      {
        if(initial != NULL) inf_text_chunk_free(initial);
        initial = inf_test_util_parse_buffer(child, &amp;error);
        if(initial == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, &quot;user&quot;) == 0)
      {
        if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
          break;
<A NAME="4"></A>      }
      else if(strcmp((const char*)child-&gt;name, &quot;request&quot;) == 0 ||</B></FONT>
              strcmp((const char*)child-&gt;name, &quot;verify&quot;) == 0)
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match306-1.html#4',3,'match306-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      {
        requests = g_slist_prepend(requests, child);
      }
      else
      {
        g_set_error(
          &amp;error,
          inf_test_util_parse_error_quark(),
          INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
          &quot;Node '%s' unexpected&quot;,
          (const gchar*)child-&gt;name
        );

        break;
      }
    }

    if(error != NULL)
    {
      printf(&quot;Failed to parse: %s\n&quot;, error-&gt;message);
      g_error_free(error);
      xmlFreeDoc(doc);

      g_slist_free(requests);
      if(initial != NULL) inf_text_chunk_free(initial);</B></FONT>
      g_slist_free(users);
    }
    else
    {
      g_assert(initial != NULL);

      requests = g_slist_reverse(requests);
<A NAME="3"></A>      if(perform_test(max_total_log_size, initial, users, requests, &amp;error) ==
         TRUE)
      {
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match306-1.html#3',3,'match306-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        ++ result-&gt;passed;
        printf(&quot;OK\n&quot;);
      }
      else
      {
        printf(&quot;FAILED (%s)\n&quot;, error-&gt;message);
        g_error_free(error);
      }

      xmlFreeDoc(doc);
      g_slist_free(requests);
      inf_text_chunk_free(initial);
      g_slist_free(users);
    }
  }
}

int main(int argc, char* argv[])
{
  const char* dir;</B></FONT>
  GError* error;
  test_result result;

  if(argc &gt; 1)
    dir = argv[1];
  else
    dir = &quot;cleanup&quot;;

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    return 1;
  }

  result.total = 0;
  result.passed = 0;

  if(inf_test_util_dir_foreach(dir, foreach_test_func, &amp;result, &amp;error) ==
     FALSE)
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    g_error_free(error);
    return -1;
  }

  printf(&quot;%u out of %u tests passed\n&quot;, result.passed, result.total);
  if(result.passed &lt; result.total)
    return -1;

  return 0;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &quot;util/inf-test-util.h&quot;

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/common/inf-user-table.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

#define NUM_PERMUTATIONS 100

typedef struct {
  GRand* rand;
  guint total;
  guint passed;
  gdouble time;
} test_result;

static gboolean
perform_single_test(InfTextChunk* initial,
                    InfTextChunk* final,
                    GSList* users,
                    GSList* requests,
                    gdouble* time)
{
  InfTextBuffer* buffer;
  InfCommunicationManager* manager;
  InfIo* io;
  InfTextSession* session;

  InfUserTable* user_table;
  InfTextUser* user;
  gchar* user_name;

  GSList* item;
  xmlNodePtr request;

  gboolean result;
  InfTextChunk* test_chunk;
  gchar* first;
  gchar* second;
  gsize first_bytes;
  gsize second_bytes;

  GTimer* timer;

  buffer = INF_TEXT_BUFFER(inf_text_default_buffer_new(&quot;UTF-8&quot;));
  inf_text_buffer_insert_chunk(buffer, 0, initial, NULL);

  manager = inf_communication_manager_new();
  io = INF_IO(inf_standalone_io_new());
  user_table = inf_user_table_new();

  for(item = users; item != NULL; item = g_slist_next(item))
  {
    user_name = g_strdup_printf(&quot;User_%u&quot;, GPOINTER_TO_UINT(item-&gt;data));

    user = INF_TEXT_USER(
      g_object_new(
        INF_TEXT_TYPE_USER,
        &quot;id&quot;, GPOINTER_TO_UINT(item-&gt;data),
        &quot;name&quot;, user_name,
        &quot;status&quot;, INF_USER_ACTIVE,
        &quot;flags&quot;, 0,
        NULL
      )
    );

    g_free(user_name);
    inf_user_table_add_user(user_table, INF_USER(user));
    g_object_unref(user);
  }

  session = inf_text_session_new_with_user_table(
    manager,
    buffer,
    io,
    user_table,
    INF_SESSION_RUNNING,
    NULL,
    NULL
  );

  g_object_unref(G_OBJECT(io));
  g_object_unref(G_OBJECT(manager));
  g_object_unref(G_OBJECT(user_table));

  timer = g_timer_new();
  for(item = requests; item != NULL; item = item-&gt;next)
  {
    request = (xmlNodePtr)item-&gt;data;

    inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(session),
      NULL,
      request
    );
  }

  *time = g_timer_elapsed(timer, NULL);
  g_timer_destroy(timer);

  test_chunk = inf_text_buffer_get_slice(
    buffer,
    0,
    inf_text_buffer_get_length(buffer)
  );

  g_object_unref(G_OBJECT(session));

  result = inf_text_chunk_equal(test_chunk, final);

  if(result == FALSE)
  {
    first = inf_text_chunk_get_text(final, &amp;first_bytes);
    second = inf_text_chunk_get_text(test_chunk, &amp;second_bytes);
    printf(&quot;(%.*s vs. %.*s) &quot;, (int)second_bytes, second, (int)first_bytes, first);
    g_free(second);
    g_free(first);
  }

  inf_text_chunk_free(test_chunk);
  g_object_unref(G_OBJECT(buffer));
  return result;
}

static gboolean
perform_test(InfTextChunk* initial,
             InfTextChunk* final,
             GSList* users,
             GSList* requests,
             GRand* rand,
             gdouble* time)
{
  GSList* permutation;
  GSList* item;
  GSList* item2;
  GSList* dist_item;
  unsigned int i;
  unsigned int dist;
  unsigned int rval;
  gpointer temp;
  gboolean retval;
  gdouble local_time;

  guint user;
  guint user2;
  InfAdoptedStateVector* v;
  GError* error;

  g_assert(requests != NULL);
  permutation = g_slist_copy(requests);

  /* Mark per-user request order which must be kept when applying for the 
   * state vector diffs to work. */
  v = inf_adopted_state_vector_new();
  error = NULL;

  for(item = permutation; item != NULL; item = g_slist_next(item))
  {
    if(!inf_xml_util_get_attribute_uint(item-&gt;data, &quot;user&quot;, &amp;user, &amp;error))
    {
      printf(&quot;%s\n&quot;, error-&gt;message);
      inf_adopted_state_vector_free(v);
      g_slist_free(permutation);
      return FALSE;
    }

    ((xmlNodePtr)item-&gt;data)-&gt;_private = GUINT_TO_POINTER(
      inf_adopted_state_vector_get(v, user)
    );

    inf_adopted_state_vector_add(v, user, 1);
  }

  inf_adopted_state_vector_free(v);

  *time = 0.0;
  for(i = 0; i &lt; NUM_PERMUTATIONS; ++ i)
  {
    dist = 0;

    /* TODO: This can be optimized */
    /* shuffle random */
    for(item = permutation-&gt;next; item != NULL; item = g_slist_next(item))
    {
      ++ dist;
      dist_item = g_slist_nth(permutation, g_rand_int(rand) % (dist + 1));
      rval = g_rand_int(rand) % (dist + 1);

      temp = item-&gt;data;
      item-&gt;data = dist_item-&gt;data;
      dist_item-&gt;data = temp;
    }

    /* Resort according to per-user request order */
    /* We could probably use g_slist_sort if it was stable, but the
     * documentation says nothing about it. So just do a primitive bubblesort
     * for now. */
    for(item = permutation; item != NULL; item = g_slist_next(item))
    {
      for(item2 = item-&gt;next; item2 != NULL; item2 = g_slist_next(item2))
      {
        /* This can't fail anymore, otherwise it
         * would already have failed above. */
        inf_xml_util_get_attribute_uint(item-&gt;data, &quot;user&quot;, &amp;user, NULL);
        inf_xml_util_get_attribute_uint(item2-&gt;data, &quot;user&quot;, &amp;user2, NULL);
        if(user == user2)
        {
          if(GPOINTER_TO_UINT( ((xmlNodePtr)item-&gt;data)-&gt;_private) &gt;
             GPOINTER_TO_UINT( ((xmlNodePtr)item2-&gt;data)-&gt;_private) )
          {
            temp = item-&gt;data;
            item-&gt;data = item2-&gt;data;
            item2-&gt;data = temp;
          }
        }
      }
    }

    if(i % (MAX(NUM_PERMUTATIONS/30, 1)) == 0)
    {
      printf(&quot;.&quot;);
      fflush(stdout);
    }

    retval = perform_single_test(
      initial,
      final,
      users,
      permutation,
      &amp;local_time
    );

    if(!retval) break;

    *time += local_time;
<A NAME="2"></A>  }

  g_slist_free(permutation);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match306-0.html#2',2,'match306-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  return retval;
}

static void
foreach_test_func(const gchar* testfile,
                  gpointer user_data)
{
  test_result* result;
  xmlDocPtr doc;
  xmlNodePtr root;
  xmlNodePtr child;

  GSList* requests;
  InfTextChunk* initial;
  InfTextChunk* final;
  GSList* users;
  GError* error;
  gboolean retval;

  gdouble local_time;

  /* Only process XML files, not the Makefiles or other stuff */
  if(!g_str_has_suffix(testfile, &quot;.xml&quot;))
    return;

  result = (test_result*)user_data;
  doc = xmlParseFile(testfile);

  requests = NULL;
<A NAME="1"></A>  initial = NULL;
  final = NULL;
  error = NULL;</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match306-0.html#1',2,'match306-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  users = NULL;

  printf(&quot;%s... &quot;, testfile);
  fflush(stdout);

  ++ result-&gt;total;

  if(doc != NULL)
  {
    root = xmlDocGetRootElement(doc);
    for(child = root-&gt;children; child != NULL; child = child-&gt;next)
    {
      if(child-&gt;type != XML_ELEMENT_NODE) continue;

      if(strcmp((const char*)child-&gt;name, &quot;initial-buffer&quot;) == 0)
<A NAME="0"></A>      {</B></FONT>
        if(initial != NULL) inf_text_chunk_free(initial);
        initial = inf_test_util_parse_buffer(child, &amp;error);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match306-0.html#0',2,'match306-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        if(initial == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, &quot;final-buffer&quot;) == 0)
      {
        if(final != NULL) inf_text_chunk_free(final);
        final = inf_test_util_parse_buffer(child, &amp;error);
        if(final == NULL) break;
      }
      else if(strcmp((const char*)child-&gt;name, &quot;user&quot;) == 0)
      {
        if(inf_test_util_parse_user(child, &amp;users, &amp;error) == FALSE)
<A NAME="4"></A>          break;
      }
      else if(strcmp((const char*)child-&gt;name, &quot;request&quot;) == 0)</B></FONT>
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match306-0.html#4',2,'match306-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>      {
        requests = g_slist_prepend(requests, child);
      }
      else
      {
        g_set_error(
          &amp;error,
          inf_test_util_parse_error_quark(),
          INF_TEST_UTIL_PARSE_ERROR_UNEXPECTED_NODE,
          &quot;Node '%s' unexpected&quot;,
          (const gchar*)child-&gt;name
        );

        break;
      }
    }

    if(error != NULL)
    {
      printf(&quot;Failed to parse: %s\n&quot;, error-&gt;message);
      g_error_free(error);
      xmlFreeDoc(doc);

      g_slist_free(requests);
      if(initial != NULL) inf_text_chunk_free(initial);</B></FONT>
      if(final != NULL) inf_text_chunk_free(final);
      g_slist_free(users);
    }
    else
    {
      g_assert(initial != NULL);
      g_assert(final != NULL);

      requests = g_slist_reverse(requests);

      retval = perform_test(
        initial,
        final,
        users,
        requests,
        result-&gt;rand,
        &amp;local_time
      );
      
      if(retval == TRUE)
<A NAME="3"></A>      {
        ++ result-&gt;passed;
        printf(&quot;OK (%g secs)\n&quot;, local_time);
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match306-0.html#3',2,'match306-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        result-&gt;time += local_time;
      }
      else
      {
        printf(&quot;FAILED\n&quot;);
      }

      xmlFreeDoc(doc);
      g_slist_free(requests);
      inf_text_chunk_free(initial);
      inf_text_chunk_free(final);

      g_slist_free(users);
    }
  }
}

int main(int argc, char* argv[])
{
  const char* dir;</B></FONT>
  GError* error;
  test_result result;
  unsigned int rseed;
  int dirarg;
  gboolean retval;
  GTimer* timer;
  gdouble elapsed;

  dirarg = 1;
  if(argc &gt; 1)
  {
    rseed = atoi(argv[1]);
    if(rseed &gt; 0) dirarg = 2;
    else rseed = time(NULL);
  }
  else
  {
    rseed = time(NULL);
  }

  printf(&quot;Using random seed %u\n&quot;, rseed);

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    return 1;
  }

  if(argc &gt; dirarg)
    dir = argv[dirarg];
  else
    dir = &quot;session&quot;;

  result.rand = g_rand_new_with_seed(rseed);
  result.total = 0;
  result.passed = 0;
  result.time = 0.0;

  timer = g_timer_new();
  retval = inf_test_util_dir_foreach(
    dir,
    foreach_test_func,
    &amp;result,
    &amp;error
  );

  g_timer_stop(timer);
  elapsed = g_timer_elapsed(timer, NULL);
  g_rand_free(result.rand);
  g_timer_destroy(timer);

  if(retval == FALSE)
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    g_error_free(error);
    return -1;
  }

  printf(
    &quot;%u out of %u tests passed (real %g secs, algo %g secs)\n&quot;,
    result.passed, result.total, elapsed, result.time
  );

  if(result.passed &lt; result.total)
    return -1;

  return 0;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
