<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for infd-session-proxy.c & infc-request-manager.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for infd-session-proxy.c & infc-request-manager.c
      </h3>
      <h1 align="center">
        8.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>infd-session-proxy.c (6.2402496%)<TH>infc-request-manager.c (12.539185%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1300-0.html#0',2,'match1300-1.html#0',3)" NAME="0">(60-101)<TD><A HREF="javascript:ZweiFrames('match1300-0.html#0',2,'match1300-1.html#0',3)" NAME="0">(56-85)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1300-0.html#1',2,'match1300-1.html#1',3)" NAME="1">(971-993)<TD><A HREF="javascript:ZweiFrames('match1300-0.html#1',2,'match1300-1.html#1',3)" NAME="1">(224-246)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1300-0.html#2',2,'match1300-1.html#2',3)" NAME="2">(1358-1377)<TD><A HREF="javascript:ZweiFrames('match1300-0.html#2',2,'match1300-1.html#2',3)" NAME="2">(283-323)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:infd-session-proxy
 * @title: InfdSessionProxy
 * @short_description: Server-side session management
 * @include: libinfinity/server/infd-session-proxy.h
 * @see_also: #InfSession
 * @stability: Unstable
 *
 * #InfdSessionProxy is a manager for #InfSession that is specific for the
 * server side. The #InfdSessionProxy manages exactly one #InfSession. It is
 * usually created by #InfdDirectory when the content of a node is requested.
 *
 * #InfdSessionProxy allows to perform server-specific operations for the
 * session it manages, such as joining a local user, or removing a connection
 * from the list of subscribed connections. In addition it handles requests
 * made by its counterpart, #InfcSessionProxy, for the client side, such as
 * remote user joins.
 *
 * #InfdSessionProxy implements the #InfSessionProxy interface, which can be
 * used to access the underlying #InfSession or to join a local user.
 */

#include &lt;libinfinity/server/infd-session-proxy.h&gt;
#include &lt;libinfinity/server/infd-request.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;string.h&gt;

typedef struct _InfdSessionProxySubscription InfdSessionProxySubscription;
struct _InfdSessionProxySubscription {
  InfXmlConnection* connection;
<A NAME="0"></A>  guint seq_id;

  GSList* users; /* Available users joined via this connection */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1300-1.html#0',3,'match1300-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

typedef struct _InfdSessionProxyPrivate InfdSessionProxyPrivate;
struct _InfdSessionProxyPrivate {
  InfIo* io;
  InfSession* session;
  InfCommunicationHostedGroup* subscription_group;

  GSList* subscriptions;
  guint user_id_counter;

  /* Local users that do not belong to a particular connection */
  GSList* local_users;
  /* Whether there are any subscriptions / synchronizations */
  gboolean idle;
};

enum {
  PROP_0,

  /* construct/only */
  PROP_IO,
  PROP_SESSION,
  PROP_SUBSCRIPTION_GROUP,

  /* read/only */
  PROP_IDLE
};

enum {
  ADD_SUBSCRIPTION,
  REMOVE_SUBSCRIPTION,
  REJECT_USER_JOIN,

  LAST_SIGNAL
};

#define INFD_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_SESSION_PROXY, InfdSessionProxyPrivate))

static guint session_proxy_signals[LAST_SIGNAL];

static void infd_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);</B></FONT>
static void infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfdSessionProxy, infd_session_proxy, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdSessionProxy)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infd_session_proxy_communication_object_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infd_session_proxy_session_proxy_iface_init))

/*
 * SessionProxy subscriptions.
 */

static InfdSessionProxySubscription*
infd_session_proxy_subscription_new(InfXmlConnection* connection,
                                    guint seq_id)
{
  InfdSessionProxySubscription* subscription;
  subscription = g_slice_new(InfdSessionProxySubscription);

  subscription-&gt;connection = connection;
  subscription-&gt;seq_id = seq_id;
  subscription-&gt;users = NULL;

  g_object_ref(G_OBJECT(connection));
  return subscription;
}

static void
infd_session_proxy_subscription_free(InfdSessionProxySubscription* subscr)
{
  g_object_unref(G_OBJECT(subscr-&gt;connection));
  g_slist_free(subscr-&gt;users);
  g_slice_free(InfdSessionProxySubscription, subscr);
}

static GSList*
infd_session_proxy_find_subscription_item(InfdSessionProxy* proxy,
                                          InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  GSList* item;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  for(item = priv-&gt;subscriptions; item != NULL; item = g_slist_next(item))
    if( ((InfdSessionProxySubscription*)item-&gt;data)-&gt;connection == connection)
      return item;

  return NULL;
}

static InfdSessionProxySubscription*
infd_session_proxy_find_subscription(InfdSessionProxy* proxy,
                                     InfXmlConnection* connection)
{
  GSList* item;

  item = infd_session_proxy_find_subscription_item(proxy, connection);
  if(item == NULL) return NULL;

  return (InfdSessionProxySubscription*)item-&gt;data;
}

static gboolean
infd_session_proxy_check_idle(InfdSessionProxy* proxy)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;subscriptions == NULL &amp;&amp;
     priv-&gt;local_users == NULL &amp;&amp;
     !inf_session_has_synchronizations(priv-&gt;session))
  {
    return TRUE;
  }

  return FALSE;
}

static void
infd_session_proxy_user_notify_status_cb(InfUser* user,
                                         const GParamSpec* pspec,
                                         gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscr;

  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE)
  {
    proxy = INFD_SESSION_PROXY(user_data);
    priv = INFD_SESSION_PROXY_PRIVATE(proxy);

    if(inf_user_get_connection(user))
    {
      subscr = infd_session_proxy_find_subscription(
        proxy,
        inf_user_get_connection(user)
      );

      g_assert(subscr != NULL);
      subscr-&gt;users = g_slist_remove(subscr-&gt;users, user);

      g_object_set(G_OBJECT(user), &quot;connection&quot;, NULL, NULL);
    }
    else
    {
      priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, user);

      if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
      {
        priv-&gt;idle = TRUE;
        g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
      }
    }

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(user),
      G_CALLBACK(infd_session_proxy_user_notify_status_cb),
      proxy
    );
  }
}

/*
 * Utility functions.
 */

static gboolean
infd_session_proxy_make_seq(InfdSessionProxy* proxy,
                            InfXmlConnection* connection,
                            xmlNodePtr xml,
                            gchar** seq,
                            GError** error)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  GError* local_error;
  guint seq_num;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  local_error = NULL;
  if(!inf_xml_util_get_attribute_uint(xml, &quot;seq&quot;, &amp;seq_num, &amp;local_error))
  {
    if(local_error)
    {
      g_propagate_error(error, local_error);
      return FALSE;
    }

    *seq = NULL;
    return TRUE;
  }

  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_assert(subscription != NULL);

  *seq = g_strdup_printf(&quot;%u/%u&quot;, subscription-&gt;seq_id, seq_num);
  return TRUE;
}

/* Performs a user join on the given proxy. If connection is not null, the
 * user join is made from that connection, otherwise a local user join is
 * performed. seq is the seq of the user join request and used in
 * the reply, or NULL if there was no seq. */
static InfUser*
infd_session_proxy_perform_user_join(InfdSessionProxy* proxy,
                                     InfXmlConnection* connection,
                                     const gchar* seq,
                                     GArray* user_props,
                                     GError** error)
{
  InfSessionClass* session_class;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  InfUser* user;
  const GParameter* name_param;
  GParameter* param;
  gboolean result;
  xmlNodePtr xml;
  guint i;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);

  g_assert(session_class-&gt;validate_user_props != NULL);
  g_assert(session_class-&gt;user_new != NULL);

  name_param = inf_session_lookup_user_property(
    (const GParameter*)user_props-&gt;data,
    user_props-&gt;len,
    &quot;name&quot;
  );

  if(name_param == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _(&quot;Request does not contain required attribute \&quot;name\&quot;&quot;)
    );

    return NULL;
  }

  /* TODO: Isn't this already done in validate_user_props? */
  user = inf_user_table_lookup_user_by_name(
    inf_session_get_user_table(priv-&gt;session),
    g_value_get_string(&amp;name_param-&gt;value)
  );

  if(user != NULL &amp;&amp; inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NAME_IN_USE,
      _(&quot;Name \&quot;%s\&quot; already in use&quot;),
      g_value_get_string(&amp;name_param-&gt;value)
    );

    return NULL;
  }

  /* User join requests must not have the id value set because the server
   * chooses an ID, or reuses an existing one in the case of a rejoin. */
  param = inf_session_get_user_property(user_props, &quot;id&quot;);
  if(G_IS_VALUE(&amp;param-&gt;value))
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
      inf_user_strerror(INF_USER_ERROR_ID_PROVIDED)
    );

    return NULL;
  }

  /* The user ID counter is increased in the add-user default signal
   * handler. */
  g_value_init(&amp;param-&gt;value, G_TYPE_UINT);

  /* Reuse user ID on rejoin. */
  if(user != NULL)
    g_value_set_uint(&amp;param-&gt;value, inf_user_get_id(user));
  else
    g_value_set_uint(&amp;param-&gt;value, priv-&gt;user_id_counter);

  /* Check user status. It must not be unavailable on join/rejoin */
  param = inf_session_get_user_property(user_props, &quot;status&quot;);
  if(G_IS_VALUE(&amp;param-&gt;value))
  {
    if(g_value_get_enum(&amp;param-&gt;value) == INF_USER_UNAVAILABLE)
    {
      g_set_error_literal(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
        _(&quot;\&quot;status\&quot; attribute is \&quot;unavailable\&quot; in user join request&quot;)
      );

      return NULL;
    }
  }
  else
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_USER_STATUS);
    g_value_set_enum(&amp;param-&gt;value, INF_USER_ACTIVE);
  }

  /* flags should not be set by get_xml_user_props, nor given
   * to infd_session_proxy_add_user. */
  param = inf_session_get_user_property(user_props, &quot;flags&quot;);
  g_assert(!G_IS_VALUE(&amp;param-&gt;value));

  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(connection == NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);


  /* same with connection */
  param = inf_session_get_user_property(user_props, &quot;connection&quot;);
  g_assert(!G_IS_VALUE(&amp;param-&gt;value));
  g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
  g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));

  /* Validate properties, but exclude the rejoining user from the check.
   * Otherwise, we would get conflicts because the name and the ID
   * of the request and the rejoining user are the same. */
  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)user_props-&gt;data,
    user_props-&gt;len,
    user,
    error
  );

  if(result == FALSE)
    return NULL;

  g_signal_emit(
    proxy,
    session_proxy_signals[REJECT_USER_JOIN],
    0,
    connection,
    user_props,
    user,
    &amp;result
  );

  if(result == TRUE)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NOT_AUTHORIZED,
      _(&quot;Permission denied&quot;)
    );

    return NULL;
  }

  if(user == NULL)
  {
    user = inf_session_add_user(
      priv-&gt;session,
      (const GParameter*)user_props-&gt;data,
      user_props-&gt;len
    );

    g_assert(user != NULL);
    xml = xmlNewNode(NULL, (const xmlChar*)&quot;user-join&quot;);
  }
  else
  {
    g_object_freeze_notify(G_OBJECT(user));

    /* Set properties on already existing user object. */
    for(i = 0; i &lt; user_props-&gt;len; ++ i)
    {
      param = &amp;g_array_index(user_props, GParameter, i);

      /* Don't set name and ID because they did not change, and we are not
       * even allowed to set ID because it is construct only. */
      if(strcmp(param-&gt;name, &quot;name&quot;) != 0 &amp;&amp; strcmp(param-&gt;name, &quot;id&quot;) != 0)
        g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
    }

    g_object_thaw_notify(G_OBJECT(user));

    xml = xmlNewNode(NULL, (const xmlChar*)&quot;user-rejoin&quot;);
  }

  inf_session_user_to_xml(priv-&gt;session, user, xml);
  if(seq != NULL) inf_xml_util_set_attribute(xml, &quot;seq&quot;, seq);

  /* TODO: Send with &quot;connection&quot; to subscriptions that are in the same
   * network, and that are non-local. */

  g_signal_connect(
    G_OBJECT(user),
    &quot;notify::status&quot;,
    G_CALLBACK(infd_session_proxy_user_notify_status_cb),
    proxy
  );

  inf_session_send_to_subscriptions(priv-&gt;session, xml);

  if(connection != NULL)
  {
    subscription = infd_session_proxy_find_subscription(proxy, connection);
    g_assert(subscription != NULL);

    subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);
  }
  else
  {
    priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, user);

    if(priv-&gt;idle == TRUE)
    {
      priv-&gt;idle = FALSE;
      g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
    }
  }

  return user;
}

/*
 * Signal handlers.
 */

static void
infd_session_proxy_member_removed_cb(InfCommunicationGroup* group,
                                     InfXmlConnection* connection,
                                     gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  xmlNodePtr xml;
  GSList* item;
  InfUser* user;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_assert(subscription != NULL);

  /* TODO: Only send user-status-change to users that don't have a direct
   * connection to the closed connection. */
  for(item = subscription-&gt;users; item != NULL; item = g_slist_next(item))
  {
    user = INF_USER(item-&gt;data);

    /* Send user-status-change to remaining subscriptions. */
    /* Note: We cannot simply use inf_session_set_user_status because it
     * would also try to send the status change to the subscription we are
     * removing, and because it only works for local users. */
    xml = xmlNewNode(NULL, (const xmlChar*)&quot;user-status-change&quot;);
    inf_xml_util_set_attribute_uint(xml, &quot;id&quot;, inf_user_get_id(user));

    inf_xml_util_set_attribute(
      xml,
      &quot;status&quot;,
      inf_user_status_to_string(INF_USER_UNAVAILABLE)
    );

    /* The actual status change is performed in the default signal handler
     * of the remove-subscription signal. */
    inf_session_send_to_subscriptions(priv-&gt;session, xml);
  }

  g_signal_emit(
    proxy,
    session_proxy_signals[REMOVE_SUBSCRIPTION],
    0,
    connection
  );
}

static void
infd_session_proxy_add_user_cb(InfUserTable* user_table,
                               InfUser* user,
                               gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfXmlConnection* sync_conn;
  InfdSessionProxySubscription* subscription;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* Make sure that we generate a non-existing user ID for the next user. */
  if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
    priv-&gt;user_id_counter = inf_user_get_id(user) + 1;

  if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING)
  {
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
    {
      g_object_get(
        G_OBJECT(priv-&gt;session),
        &quot;sync-connection&quot;,
        &amp;sync_conn,
        NULL
      );

      g_assert(sync_conn != NULL);
      subscription = infd_session_proxy_find_subscription(proxy, sync_conn);

      /* During synchronization, available users are always considered to
       * belong to the synchronizing connection. Everything else is just not
       * supported and causes session closure. */
      if(sync_conn != inf_user_get_connection(user) || subscription == NULL)
      {
        /* This actually cancels the synchronization: */
        inf_session_close(priv-&gt;session);
      }
      else
      {
        subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);

        g_signal_connect(
          G_OBJECT(user),
          &quot;notify::status&quot;,
          G_CALLBACK(infd_session_proxy_user_notify_status_cb),
          proxy
        );
      }

      g_object_unref(sync_conn);
    }
  }
}

static void
infd_session_proxy_synchronization_begin_cb(InfSession* session,
                                            InfCommunicationGroup* group,
                                            InfXmlConnection* connection,
                                            gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;idle)
  {
    priv-&gt;idle = FALSE;
    g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
  }
}

static void
infd_session_proxy_synchronization_complete_cb(InfSession* session,
                                               InfXmlConnection* conn,
                                               gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* Set idle if no more synchronizations are running */
  if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
     priv-&gt;local_users == NULL &amp;&amp;
     !inf_session_has_synchronizations(session))
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
  }
}

static void
infd_session_proxy_synchronization_failed_cb_before(InfSession* session,
                                                    InfXmlConnection* conn,
                                                    const GError* error,
                                                    gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfSessionStatus status;
  InfdSessionProxySubscription* subscription;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  g_object_get(session, &quot;status&quot;, &amp;status, NULL);

  /* We do not need handle the status == INF_SESSION_PROXY_SYNCHRONIZING case
   * since there cannot be any subscriptions while we are synchronizing. */

  if(status == INF_SESSION_RUNNING)
  {
    /* Remove from subscription group if the connection was subscribed */
    subscription = infd_session_proxy_find_subscription(proxy, conn);
    if(subscription != NULL)
    {
      inf_communication_hosted_group_remove_member(
        priv-&gt;subscription_group,
        conn
      );
    }
  }
}

static void
infd_session_proxy_synchronization_failed_cb_after(InfSession* session,
                                                   InfXmlConnection* conn,
                                                   const GError* error,
                                                   gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* Set idle if no more synchronizations are running */
  if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
     !inf_session_has_synchronizations(session))
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
  }
}

static void
infd_session_proxy_session_close_cb(InfSession* session,
                                    gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;subscription_group),
    G_CALLBACK(infd_session_proxy_member_removed_cb),
    proxy
  );

  while(priv-&gt;subscriptions != NULL)
  {
    subscription = (InfdSessionProxySubscription*)priv-&gt;subscriptions-&gt;data;

    /* Note that this does not call our signal handler because we already
     * disconnected it. This way, we make sure not to send user status updates
     * which would be pointless since we are closing the group anyway. */
    infd_session_proxy_unsubscribe(proxy, subscription-&gt;connection);

    /* However, this means we need to emit the unsubscribe signal ourselves */
    g_signal_emit(
      proxy,
      session_proxy_signals[REMOVE_SUBSCRIPTION],
      0,
      subscription-&gt;connection
    );
  }

  /* Set local users to unavailable */
  while(priv-&gt;local_users != NULL)
  {
    g_object_set(
      G_OBJECT(priv-&gt;local_users-&gt;data),
      &quot;status&quot;, INF_USER_UNAVAILABLE,
      NULL
    );
  }

  g_object_unref(priv-&gt;subscription_group);
  priv-&gt;subscription_group = NULL;
}

/*
 * GObject overrides.
 */

static void
infd_session_proxy_init(InfdSessionProxy* session_proxy)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);

  priv-&gt;io = NULL;
  priv-&gt;subscriptions = NULL;
  priv-&gt;subscription_group = NULL;
  priv-&gt;user_id_counter = 1;
  priv-&gt;local_users = NULL;
  priv-&gt;idle = TRUE;
}

static void
infd_session_proxy_constructed(GObject* object)
{
  InfdSessionProxy* session_proxy;
  InfdSessionProxyPrivate* priv;

  session_proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);

  G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;constructed(object);

  g_assert(priv-&gt;subscription_group != NULL);
  g_assert(priv-&gt;session != NULL);

  /* Set unidle when session is currently being synchronized */
  if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING ||
     priv-&gt;local_users != NULL)
  {
    priv-&gt;idle = FALSE;
  }

  /* TODO: We could perhaps optimize by only setting the subscription
   * group when there are subscribed connections. */
  inf_session_set_subscription_group(
    priv-&gt;session,
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
  );
}

static void
infd_session_proxy_dispose(GObject* object)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfCommunicationManager* manager;

  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  manager = inf_session_get_communication_manager(priv-&gt;session);
  g_object_ref(manager);

  g_slist_free(priv-&gt;local_users);
  priv-&gt;local_users = NULL;

  /* We need to close the session explicitely before we unref so that
   * the signal handler for the close signal is called. */
  /* Note this emits the close signal, removing all subscriptions and
   * the subscription group */
  if(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED)
    inf_session_close(priv-&gt;session);

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_session_close_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
    G_CALLBACK(infd_session_proxy_add_user_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
    proxy
  );

  g_object_unref(priv-&gt;session);
  priv-&gt;session = NULL;

  g_assert(priv-&gt;subscription_group == NULL);
  g_assert(priv-&gt;subscriptions == NULL);

  g_object_unref(priv-&gt;io);
  priv-&gt;io = NULL;

  g_object_unref(manager);

  G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;dispose(object);
}

static void
infd_session_proxy_session_init_user_func(InfUser* user,
                                          gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
    priv-&gt;user_id_counter = inf_user_get_id(user) + 1;
}

static void
infd_session_proxy_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_SESSION:
    g_assert(priv-&gt;session == NULL); /* construct only */
    priv-&gt;session = INF_SESSION(g_value_dup_object(value));

    /* Adjust user id counter so the next joining user gets a free ID */
    /* TODO: Add local users to priv-&gt;local_users, assert that there are no
     * available non-local users. */
    inf_user_table_foreach_user(
      inf_session_get_user_table(priv-&gt;session),
      infd_session_proxy_session_init_user_func,
      proxy
    );

    /* This in not connect_after to fix bug #499. This makes more sense
     * anyway, because otherwise the signal handler does not have any
     * synchronization info anymore. */
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      &quot;close&quot;,
      G_CALLBACK(infd_session_proxy_session_close_cb),
      proxy
    );

    g_signal_connect(
      G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
      &quot;add-user&quot;,
      G_CALLBACK(infd_session_proxy_add_user_cb),
      proxy
    );

    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      &quot;synchronization-begin&quot;,
      G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
      proxy
    );

    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      &quot;synchronization-complete&quot;,
      G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
      proxy
    );

    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      &quot;synchronization-failed&quot;,
      G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
      proxy
    );

    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      &quot;synchronization-failed&quot;,
      G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
      proxy
    );

    break;
  case PROP_SUBSCRIPTION_GROUP:
    g_assert(priv-&gt;subscription_group == NULL); /* construct only */
    priv-&gt;subscription_group =
      INF_COMMUNICATION_HOSTED_GROUP(g_value_dup_object(value));

    g_signal_connect(
      G_OBJECT(priv-&gt;subscription_group),
      &quot;member-removed&quot;,
      G_CALLBACK(infd_session_proxy_member_removed_cb),
      proxy
    );

<A NAME="1"></A>    break;
  case PROP_IDLE:
    /* read/only */
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1300-1.html#1',3,'match1300-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infd_session_proxy_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, priv-&gt;io);
    break;</B></FONT>
  case PROP_SESSION:
    g_value_set_object(value, priv-&gt;session);
    break;
  case PROP_SUBSCRIPTION_GROUP:
    g_value_set_object(value, priv-&gt;subscription_group);
    break;
  case PROP_IDLE:
    g_value_set_boolean(value, priv-&gt;idle);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * Default signal handlers
 */

static void
infd_session_proxy_add_subscription(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    guint seq_id)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(infd_session_proxy_find_subscription(proxy, connection) == NULL);

  subscription = infd_session_proxy_subscription_new(connection, seq_id);
  priv-&gt;subscriptions = g_slist_prepend(priv-&gt;subscriptions, subscription);

  if(priv-&gt;idle == TRUE)
  {
    priv-&gt;idle = FALSE;
    g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
  }
}

static void
infd_session_proxy_remove_subscription(InfdSessionProxy* proxy,
                                       InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscr;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  subscr = infd_session_proxy_find_subscription(proxy, connection);

  g_assert(subscr != NULL);

  /* TODO: Cancel synchronization if the synchronization to this subscription
   * did not yet finish. */

  while(subscr-&gt;users)
  {
    /* The signal handler of the user's notify::status signal removes the user
     * from the subscription. */
    g_object_set(
      G_OBJECT(subscr-&gt;users-&gt;data),
      &quot;status&quot;, INF_USER_UNAVAILABLE,
      NULL
    );
  }

  priv-&gt;subscriptions = g_slist_remove(priv-&gt;subscriptions, subscr);
  infd_session_proxy_subscription_free(subscr);

  if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), &quot;idle&quot;);
  }
}

static gboolean
infd_session_proxy_reject_user_join(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    const GArray* user_properties,
                                    InfUser* user_rejoin)
{
  /* Allow user join by default */
  return FALSE;
}

/*
 * Message handling.
 */

static gboolean
infd_session_proxy_handle_user_join(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    xmlNodePtr xml,
                                    GError** error)
{
  InfdSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  GArray* array;
  InfUser* user;
  gchar* seq;
  guint i;

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);

  if(!infd_session_proxy_make_seq(proxy, connection, xml, &amp;seq, error))
    return FALSE;

  array = session_class-&gt;get_xml_user_props(
    priv-&gt;session,
    connection,
    xml
  );

  user = infd_session_proxy_perform_user_join(
    proxy,
    connection,
    seq,
    array,
    error
  );

  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);

  g_array_free(array, TRUE);
  g_free(seq);

  if(user == NULL)
    return FALSE;

  return TRUE;
}

static gboolean
infd_session_proxy_handle_session_unsubscribe(InfdSessionProxy* proxy,
                                              InfXmlConnection* connection,
                                              const xmlNodePtr xml,
                                              GError** error)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);

  inf_communication_hosted_group_remove_member(
    priv-&gt;subscription_group,
    connection
  );

  return TRUE;
}

/*
 * InfCommunicationObject implementation
 */

static void
infd_session_proxy_communication_object_sent(InfCommunicationObject* object,
                                             InfXmlConnection* connection,
                                             xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Don't forward for messages the proxy issued */

  g_assert(priv-&gt;session != NULL);

  inf_communication_object_sent(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}

static void
infd_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;

  proxy = INFD_SESSION_PROXY(obj);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Don't forward for messages the proxy issued */

  g_assert(priv-&gt;session != NULL);

  inf_communication_object_enqueued(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}

static InfCommunicationScope
infd_session_proxy_communication_object_received(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfSessionSyncStatus status;
  GError* local_error;
  xmlNodePtr reply_xml;
  gchar* seq;

  proxy = INFD_SESSION_PROXY(obj);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Don't forward for messages the proxy issued */

  g_assert(priv-&gt;session != NULL);
  status = inf_session_get_synchronization_status(priv-&gt;session, connection);
  local_error = NULL;

  if(status != INF_SESSION_SYNC_NONE)
  {
    return inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(priv-&gt;session),
      connection,
      node
    );
  }
  else
  {
    if(strcmp((const char*)node-&gt;name, &quot;user-join&quot;) == 0)
    {
      infd_session_proxy_handle_user_join(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, &quot;session-unsubscribe&quot;) == 0)
    {
      /* TODO: Handle this in InfSession, if possible */
      infd_session_proxy_handle_session_unsubscribe(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else
    {
      return inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(priv-&gt;session),
        connection,
        node
      );
    }
  }

  if(local_error != NULL)
  {
    if(!infd_session_proxy_make_seq(proxy, connection, node, &amp;seq, NULL))
      seq = NULL;

    /* Only send request-failed when it was a proxy-related request */
    reply_xml = inf_xml_util_new_node_from_error(local_error,
                                                 NULL,
                                                 &quot;request-failed&quot;);

    if(seq != NULL) inf_xml_util_set_attribute(reply_xml, &quot;seq&quot;, seq);
    g_free(seq);

    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      connection,
      reply_xml
    );

    g_error_free(local_error);
  }

  /* Don't forward proxy-related messages */
  return INF_COMMUNICATION_SCOPE_PTP;
}

/*
 * InfSessionProxy implementation
 */

static InfRequest*
infd_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
                                           guint n_params,
                                           const GParameter* params,
                                           InfRequestFunc func,
                                           gpointer user_data)
{
  InfdRequest* request;
  GArray* array;

  guint i;
  GParameter param;

  GError* error;
  InfUser* user;

  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), NULL);

  request = g_object_new(
    INFD_TYPE_REQUEST,
    &quot;type&quot;, &quot;user-join&quot;,
    NULL
  );

  if(func != NULL)
  {
    g_signal_connect_after(
      G_OBJECT(request),
      &quot;finished&quot;,
      G_CALLBACK(func),
      user_data
    );
  }

  array = g_array_sized_new(
    FALSE,
    FALSE,
    sizeof(GParameter),
    n_params
  );

  g_array_append_vals(array, params, n_params);

  error = NULL;
  user = infd_session_proxy_perform_user_join(
    INFD_SESSION_PROXY(proxy),
    NULL,
    NULL,
    array,
    &amp;error
  );

  /* Remove only those parameters that were added by the
   * infd_session_proxy_perform_user_join function */
  for(i = n_params; i &lt; array-&gt;len; ++i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);

  if(error != NULL)
  {
    inf_request_fail(INF_REQUEST(request), error);
  }
  else
  {
    inf_request_finish(
      INF_REQUEST(request),
      inf_request_result_make_join_user(proxy, user)
    );
  }
<A NAME="2"></A>
  if(error) g_error_free(error);
  g_object_unref(request);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1300-1.html#2',3,'match1300-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  return NULL;
}

/*
 * GType registration.
 */

static void
infd_session_proxy_class_init(InfdSessionProxyClass* proxy_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(proxy_class);

  object_class-&gt;constructed = infd_session_proxy_constructed;
  object_class-&gt;dispose = infd_session_proxy_dispose;
  object_class-&gt;set_property = infd_session_proxy_set_property;
  object_class-&gt;get_property = infd_session_proxy_get_property;

  proxy_class-&gt;add_subscription = infd_session_proxy_add_subscription;
  proxy_class-&gt;remove_subscription = infd_session_proxy_remove_subscription;</B></FONT>
  proxy_class-&gt;reject_user_join = infd_session_proxy_reject_user_join;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;Io&quot;,
      &quot;The InfIo object for scheduling events&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SUBSCRIPTION_GROUP,
    g_param_spec_object(
      &quot;subscription-group&quot;,
      &quot;Subscription group&quot;,
      &quot;The communication manager group of subscribed connections&quot;,
      INF_COMMUNICATION_TYPE_HOSTED_GROUP,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_IDLE,
    g_param_spec_boolean(
      &quot;idle&quot;,
      &quot;Idle&quot;,
      &quot;The session is considered idle when are no subscriptions and no &quot;
      &quot;synchronizations&quot;,
      TRUE,
      G_PARAM_READABLE
    )
  );

  g_object_class_override_property(object_class, PROP_SESSION, &quot;session&quot;);

  /**
   * InfdSessionProxy::add-subscription:
   * @proxy: The #InfdSessionProxy emitting the signal.
   * @connection: The subscribed #InfXmlConnection.
   * @seq_id: The sequence identifier for @connection as passed to
   * infd_session_proxy_subscribe_to().
   *
   * Emitted every time a connection is subscribed to the session.
   **/
  session_proxy_signals[ADD_SUBSCRIPTION] = g_signal_new(
    &quot;add-subscription&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, add_subscription),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_UINT
  );

  /**
   * InfdSessionProxy::remove-subscription:
   * @proxy: The #InfdSessionProxy emitting the signal.
   * @connection: The unsubscribed #InfXmlConnection.
   *
   * Emitted every time a connection is unsubscribed to the session, or a
   * subscription is removed because the session is closed.
   **/
  session_proxy_signals[REMOVE_SUBSCRIPTION] = g_signal_new(
    &quot;remove-subscription&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, remove_subscription),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_XML_CONNECTION
  );

  /**
   * InfdSessionProxy::reject-user-join:
   * @proxy: The #InfdSessionProxy emitting the signal.
   * @connection: A subscribed #InfXmlConnection requesting the user join.
   * @user_properties: An array with the properties for the new user.
   * @rejoin_user: The existing unavailable user that is being rejoined, or
   * %NULL.
   *
   * This signal is emitted before every remote user join. The signal handler
   * can return %TRUE in which case the #InfdSessionProxy does not allow the
   * user join with %INF_REQUEST_ERROR_NOT_AUTHORIZED error. If there is more
   * than one signal handler, then if one of them returns %TRUE the user
   * join is rejected.
   *
   * The @user_properties parameter is a #GArray of #GParameter values. It
   * contains the construct properties for the #InfUser object that would be
   * created if the user join is not rejected. It must not be modified, but
   * it can be used to make the decision whether to reject the user join or
   * not dependent on the parameters, such as allowing the user join only if
   * the user has a predefined name. The function
   * inf_session_lookup_user_property() can be used to look up a named
   * parameter in the array.
   */
  session_proxy_signals[REJECT_USER_JOIN] = g_signal_new(
    &quot;reject-user-join&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, reject_user_join),
    g_signal_accumulator_true_handled, NULL,
    NULL,
    G_TYPE_BOOLEAN,
    3,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_ARRAY,
    INF_TYPE_USER
  );
}

static void
infd_session_proxy_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;sent = infd_session_proxy_communication_object_sent;
  iface-&gt;enqueued = infd_session_proxy_communication_object_enqueued;
  iface-&gt;received = infd_session_proxy_communication_object_received;
}

static void
infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
{
  iface-&gt;join_user = infd_session_proxy_session_proxy_join_user;
}

/*
 * Public API.
 */

/**
 * infd_session_proxy_subscribe_to:
 * @proxy: A #InfdSessionProxy.
 * @connection: A #InfXmlConnection that is not yet subscribed.
 * @seq_id: The sequence identifier for @connection.
 * @synchronize: If %TRUE, then synchronize the session to @connection first.
 *
 * Subscribes @connection to @proxy's session. The first thing that will be
 * done is a synchronization (see inf_session_synchronize_to()). Then, all
 * changes to the session are propagated to @connection.
 *
 * @seq_id should be a unique number for @connection, and the same number must
 * be passed on the client side to the #InfcSessionProxy object. Normally
 * #InfdDirectory and #InfcBrowser take care of choosing an appropriate
 * sequence identifier.
 *
 * Normally, you want to set @synchronize to %TRUE in which case the whole
 * session state will be synchronized to @connection (within the subscription
 * group). However, if for whatever reason the remote site already has a
 * copy of the session, then you may set @synchronize to %FALSE to skip
 * synchronization. This happens for example for newly created documents, or
 * when the remote site synchronized the local site and wants to be
 * initially subscribed.
 *
 * If @proxy's session is not in %INF_SESSION_RUNNING status, but in
 * %INF_SESSION_SYNCHRONIZING, then @connection must be the connection that
 * synchronizes the session and @synchronize needs to be set to %FALSE. This
 * causes the synchronizing connection to initially be subscribed. This
 * needs to be called directly after having created the session proxy (i.e.
 * without returning to the main loop before) so that the synchronization
 * connection is added to the subscription group for synchronization.
 *
 * Otherwise a subscription can only be initiated if @proxy's session is in
 * state %INF_SESSION_RUNNING.
 **/
void
infd_session_proxy_subscribe_to(InfdSessionProxy* proxy,
                                InfXmlConnection* connection,
                                guint seq_id,
                                gboolean synchronize)
{
  InfdSessionProxyPrivate* priv;

  g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  g_return_if_fail(
    infd_session_proxy_find_subscription(proxy, connection) == NULL
  );

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_return_if_fail(priv-&gt;session != NULL);

  /* TODO: Also check connection against sync-conn in synchronizing case: */
  g_return_if_fail(
    inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING ||
    (synchronize == FALSE)
  );

  /* Note we can't do this in the default signal handler since it doesn't
   * know the parent group. TODO: We can, meanwhile. */
  inf_communication_hosted_group_add_member(
    priv-&gt;subscription_group,
    connection
  );

  g_signal_emit(
    G_OBJECT(proxy),
    session_proxy_signals[ADD_SUBSCRIPTION],
    0,
    connection,
    seq_id
  );

  /* Make sure the default handler ran. Stopping the signal emission before
   * would leave us in an inconsistent state. */
  g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);

  if(synchronize)
  {
    /* Directly synchronize within the subscription group so that we do not
     * need a group change after synchronization, and the connection already
     * receives requests from other group members to process after
     * synchronization. */
    inf_session_synchronize_to(
      priv-&gt;session,
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      connection
    );
  }
}

/**
 * infd_session_proxy_unsubscribe:
 * @proxy: A #InfdSessionProxy.
 * @connection: The #InfXmlConnection to unsubscribe.
 *
 * Unsubscribes a subscribed connection from @proxy's session. This will
 * prevent all users joined via @connection to continue modifying the
 * session's buffer, and it will cancel ongoing synchronization to
 * @connection, if not yet finished.
 */
void
infd_session_proxy_unsubscribe(InfdSessionProxy* proxy,
                               InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  InfSessionSyncStatus status;
  xmlNodePtr xml;

  g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Can we support the SYNCHRONIZING case? In that case the session
   * will probably end up closed... */
  g_assert(inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING);

  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_return_if_fail(subscription != NULL);

  status = inf_session_get_synchronization_status(
    priv-&gt;session,
    subscription-&gt;connection
  );

  /* If synchronization is still in progress, the default handler of
   * InfSession will cancel the synchronization in which case we do
   * not need to send an extra session-close message. */

  /* We send session_close when we are in AWAITING_ACK status. In
   * AWAITING_ACK status we cannot cancel the synchronization anymore
   * because everything has already been sent out. Therefore the client
   * will eventuelly get in RUNNING state when it receives this message,
   * and process it correctly. */
  if(status != INF_SESSION_SYNC_IN_PROGRESS)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)&quot;session-close&quot;);

    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      subscription-&gt;connection,
      xml
    );
  }
  else
  {
    /* In case we are synchronizing the client */
    inf_session_cancel_synchronization(
      priv-&gt;session,
      subscription-&gt;connection
    );
  }

  inf_communication_hosted_group_remove_member(
    priv-&gt;subscription_group,
    subscription-&gt;connection
  );
}

/**
 * infd_session_proxy_has_subscriptions:
 * @proxy: A #InfdSessionProxy.
 *
 * Returns whether there are subscribed connections to the session.
 *
 * Returns: Whether there are subscribed connections.
 **/
gboolean
infd_session_proxy_has_subscriptions(InfdSessionProxy* proxy)
{
  InfdSessionProxyPrivate* priv;

  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;subscriptions == NULL)
    return FALSE;

  return TRUE;
}

/**
 * infd_session_proxy_is_subscribed:
 * @proxy: A #InfdSessionProxy.
 * @connection: The connection to check for being subscribed.
 *
 * Returns %TRUE when @connection is subscribed to the session and %FALSE
 * otherwise.
 *
 * Returns: Whether @connection is subscribed.
 **/
gboolean
infd_session_proxy_is_subscribed(InfdSessionProxy* proxy,
                                 InfXmlConnection* connection)
{
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), FALSE);

  if(infd_session_proxy_find_subscription(proxy, connection) == NULL)
    return FALSE;

  return TRUE;
}

/**
 * infd_session_proxy_is_idle:
 * @proxy: A #InfdSessionProxy.
 *
 * Returns whether the session is idle. The session is considered idle when
 * there are no subscriptions and no synchronizations (in either direction).
 *
 * Returns: Whether the session is idle.
 **/
gboolean
infd_session_proxy_is_idle(InfdSessionProxy* proxy)
{
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  return INFD_SESSION_PROXY_PRIVATE(proxy)-&gt;idle;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-request-manager.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* infcinote - Collaborative notetaking application
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:infc-request-manager
 * @short_description: Keeps track of pending asynchronous requests
 * @see_also: #InfRequest, #InfcRequest, #InfcBrowser, #InfcSessionProxy
 * @include: libinfinity/client/infc-request-manager.h
 * @stability: Unstable
 *
 * This class keeps track of requests sent by #InfcBrowser and
 * #InfcSessionProxy (typically via the #InfBrowser and #InfSessionProxy
 * APIs). It is used internally by #InfcBrowser and #InfcSessionProxy, and
 * usually end-users of the libinfinity API do not need to use this class
 * directly.
 *
 * Requests can be added with the infc_request_manager_add_request() and
 * infc_request_manager_add_request_valist() methods and retrieved back via
 * their unique seq number with infc_request_manager_get_request_by_seq(). In
 * addition to this basic API, there are various convenience functions
 * available as well.
 **/

#include &lt;libinfinity/client/infc-request-manager.h&gt;
#include &lt;libinfinity/common/inf-request.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

#include &lt;gobject/gvaluecollector.h&gt;

#include &lt;string.h&gt;
#include &lt;errno.h&gt;

typedef struct _InfcRequestManagerForeachData InfcRequestManagerForeachData;
struct _InfcRequestManagerForeachData {
<A NAME="0"></A>  InfcRequestManagerForeachFunc func;
  gpointer user_data;
  const gchar* name;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1300-0.html#0',2,'match1300-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};

typedef struct _InfcRequestManagerPrivate InfcRequestManagerPrivate;
struct _InfcRequestManagerPrivate {
  GHashTable* requests;
  guint seq_id;
  guint seq_counter;
};

enum {
  PROP_0,

  PROP_SEQUENCE_ID
};

enum {
  REQUEST_ADD,
  REQUEST_REMOVE,

  LAST_SIGNAL
};

#define INFC_REQUEST_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_REQUEST_MANAGER, InfcRequestManagerPrivate))

static guint request_manager_signals[LAST_SIGNAL];

G_DEFINE_TYPE_WITH_CODE(InfcRequestManager, infc_request_manager, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcRequestManager))

static void</B></FONT>
infc_request_manager_foreach_request_func(gpointer key,
                                          gpointer value,
                                          gpointer user_data)
{
  InfcRequest* request;
  InfcRequestManagerForeachData* foreach_data;
  gchar* type;

  request = INFC_REQUEST(value);
  foreach_data = (InfcRequestManagerForeachData*)user_data;
  g_object_get(G_OBJECT(request), &quot;type&quot;, &amp;type, NULL);

  if(foreach_data-&gt;name == NULL || strcmp(foreach_data-&gt;name, type) == 0)
  {
    foreach_data-&gt;func(request, foreach_data-&gt;user_data);
  }

  g_free(type);
}

/* TODO: inf_protocol_version_parse() uses a very similar routine. We should
 * avoid the code duplication. */
static gboolean
infc_request_manager_parse_seq(const gchar* seq,
                               guint* seq_id,
                               guint* seq_num,
                               GError** error)
{
  gchar* endptr;
  unsigned long sid;
  unsigned long snum;

  errno = 0;
  sid = strtoul(seq, &amp;endptr, 10);
  if(errno == ERANGE || sid &gt; (unsigned long)G_MAXUINT)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _(&quot;Sequence identifier causes overflow&quot;)
    );

    return FALSE;
  }

  if(*endptr != '/')
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _(&quot;Sequence components are not separated by '/'&quot;)
    );

    return FALSE;
  }

  errno = 0;
  snum = strtoul(endptr + 1, &amp;endptr, 10);
  if(errno == ERANGE || snum &gt; (unsigned long)G_MAXUINT)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _(&quot;Sequence number causes overflow&quot;)
    );

    return FALSE;
  }

  if(*endptr != '\0')
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _(&quot;Trailing characters after sequence number&quot;)
    );

    return FALSE;
  }

  if(seq_id) *seq_id = sid;
  if(seq_num) *seq_num = snum;
  return TRUE;
}

static void
infc_request_manager_init(InfcRequestManager* manager)
{
  InfcRequestManagerPrivate* priv;
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);

  priv-&gt;requests = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)g_object_unref
  );

  priv-&gt;seq_id = 0;
  priv-&gt;seq_counter = 0;
}

static void
infc_request_manager_dispose(GObject* object)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;

  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);

  g_hash_table_destroy(priv-&gt;requests);
  priv-&gt;requests = NULL;

  G_OBJECT_CLASS(infc_request_manager_parent_class)-&gt;dispose(object);
}

static void
infc_request_manager_set_property(GObject* object,
                                  guint prop_id,
                                  const GValue* value,
                                  GParamSpec* pspec)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;

  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);

  switch(prop_id)
  {
<A NAME="1"></A>  case PROP_SEQUENCE_ID:
    priv-&gt;seq_id = g_value_get_uint(value);
    break;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1300-0.html#1',2,'match1300-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infc_request_manager_get_property(GObject* object,
                                  guint prop_id,
                                  GValue* value,
                                  GParamSpec* pspec)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;

  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);

  switch(prop_id)
  {
  case PROP_SEQUENCE_ID:
    g_value_set_uint(value, priv-&gt;seq_id);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infc_request_manager_request_add(InfcRequestManager* manager,
                                 InfcRequest* request)
{
  InfcRequestManagerPrivate* priv;
  guint seq;
  gpointer seq_ptr;

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  g_object_get(G_OBJECT(request), &quot;seq&quot;, &amp;seq, NULL);
  seq_ptr = GUINT_TO_POINTER(seq);

  g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) == NULL);
  g_hash_table_insert(priv-&gt;requests, seq_ptr, request);

  g_object_ref(G_OBJECT(request));
}

static void
infc_request_manager_request_remove(InfcRequestManager* manager,
                                    InfcRequest* request)
{
  InfcRequestManagerPrivate* priv;
  guint seq;
  gpointer seq_ptr;

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
<A NAME="2"></A>  g_object_get(G_OBJECT(request), &quot;seq&quot;, &amp;seq, NULL);
  seq_ptr = GUINT_TO_POINTER(seq);

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1300-0.html#2',2,'match1300-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) != NULL);
  g_hash_table_remove(priv-&gt;requests, seq_ptr);
}

static void
infc_request_manager_class_init(
  InfcRequestManagerClass* request_manager_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(request_manager_class);

  object_class-&gt;dispose = infc_request_manager_dispose;
  object_class-&gt;set_property = infc_request_manager_set_property;
  object_class-&gt;get_property = infc_request_manager_get_property;

  request_manager_class-&gt;request_add = infc_request_manager_request_add;
  request_manager_class-&gt;request_remove = infc_request_manager_request_remove;

  g_object_class_install_property(
    object_class,
    PROP_SEQUENCE_ID,
    g_param_spec_uint(
      &quot;sequence-id&quot;,
      &quot;Sequence ID&quot;,
      &quot;The local sequence identifier&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  /**
   * InfcRequestManager::request-add:
   * @manager: The #InfcRequestManager emitting the signal.
   * @request: The #InfcRequest that was added.
   *
   * This signal is emitted whenever a request was added to the request
   * manager.
   */
  request_manager_signals[REQUEST_ADD] = g_signal_new(</B></FONT>
    &quot;request-add&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfcRequestManagerClass, request_add),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INFC_TYPE_REQUEST
  );

  /**
   * InfcRequestManager::request-remove:
   * @manager: The #InfcRequestManager emitting the signal.
   * @request: The #InfcRequest that was removed.
   *
   * This signal is emitted whenever a request was removed from the request
   * manager. Typically this happens when the request has finished (either
   * successfully or unsuccessfully). It can also happen when the client is
   * disconnected from the server while a request was still pending.
   */
  request_manager_signals[REQUEST_REMOVE] = g_signal_new(
    &quot;request-remove&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfcRequestManagerClass, request_remove),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INFC_TYPE_REQUEST
  );
}

/**
 * infc_request_manager_new: (constructor)
 * @seq_id: The local sequence ID.
 *
 * Creates a new #InfcRequestManager.
 *
 * Returns: (transfer full): A newly allocated #InfcRequestManager.
 **/
InfcRequestManager*
infc_request_manager_new(guint seq_id)
{
  GObject* object;
  object =
    g_object_new(INFC_TYPE_REQUEST_MANAGER, &quot;sequence-id&quot;, seq_id, NULL);
  return INFC_REQUEST_MANAGER(object);
}

/**
 * infc_request_manager_add_request:
 * @manager: A #InfcRequestManager.
 * @request_type: The type of request to add, such as #InfcProgressRequest.
 * @request_name: The name of the request, such as &quot;explore-node&quot; or
 * &quot;subscribe-session&quot;.
 * @callback: (scope async): A #GCallback that will be called when the request
 * has completed, or %NULL.
 * @user_data: Additional data passed to the callback.
 * @first_property_name: The first property name apart from name and seq to
 * set for the new request.
 * @...: The value of the first property, followed optionally by more
 * name/value pairs, followed by %NULL.
 *
 * Adds a request to the request manager. A new signal handler for the
 * request's &quot;finished&quot; signal will be installed and made to invoke the given
 * callback.
 *
 * Returns: (transfer none): The generated #InfcRequest (actually of type
 * @request_type).
 **/
InfcRequest*
infc_request_manager_add_request(InfcRequestManager* manager,
                                 GType request_type,
                                 const gchar* request_name,
                                 GCallback callback,
                                 gpointer user_data,
                                 const gchar* first_property_name,
                                 ...)
{
  InfcRequest* request;

  va_list arglist;
  va_start(arglist, first_property_name);

  request = infc_request_manager_add_request_valist(
    manager,
    request_type,
    request_name,
    callback,
    user_data,
    first_property_name,
    arglist
  );

  va_end(arglist);
  return request;
}

/**
 * infc_request_manager_add_request_valist:
 * @manager: A #InfcRequestManager.
 * @request_type: The type of request to add, such as #InfcProgressRequest.
 * @request_name: The name of the request, such as &amp;quot;explore-node&amp;quot; or
 * &amp;quot;subscribe-session&amp;quot;
 * @callback: (scope async): A #GCallback that will be called when the request
 * has completed, or %NULL.
 * @user_data: Additional data passed to the callback.
 * @first_property_name: The first property name apart from name and seq to
 * set for the new request.
 * @arglist: The value of the first property, followed optionally by more
 * name/value pairs, followed by %NULL.
 *
 * Adds a request to the request manager. A new signal handler for the
 * request's &quot;finished&quot; signal will be installed and made to invoke the given
 * callback.
 *
 * Returns: (transfer none): The generated #InfcRequest (actually of type
 * @request_type).
 */
InfcRequest*
infc_request_manager_add_request_valist(InfcRequestManager* manager,
                                        GType request_type,
                                        const gchar* request_name,
                                        GCallback callback,
                                        gpointer user_data,
                                        const gchar* first_property_name,
                                        va_list arglist)
{
  InfcRequestManagerPrivate* priv;
  GObjectClass* request_class;
  InfcRequest* request;
  GParameter* params;
  const gchar* prop_name;
  gsize param_size;
  gsize param_alloc;
  guint seq;
  gchar* error;
  GParamSpec* pspec;
  guint i;

  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
  g_return_val_if_fail(request_name != NULL, NULL);

  request_class = g_type_class_ref(request_type);
  g_return_val_if_fail(request_class != NULL, NULL);

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  seq = priv-&gt;seq_counter;

  g_assert(
    g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq)) == NULL
  );

  param_size = 0;
  param_alloc = 16;
  params = g_malloc0(param_alloc * sizeof(GParameter));

  params[param_size].name = &quot;type&quot;;
  g_value_init(&amp;params[param_size].value, G_TYPE_STRING);
  g_value_set_static_string(&amp;params[param_size].value, request_name);
  ++ param_size;

  params[param_size].name = &quot;seq&quot;;
  g_value_init(&amp;params[param_size].value, G_TYPE_UINT);
  g_value_set_uint(&amp;params[param_size].value, seq);
  ++ param_size;

  prop_name = first_property_name;
  error = NULL;

  while(prop_name != NULL)
  {
    pspec = g_object_class_find_property(request_class, prop_name);
    if(pspec == NULL)
    {
      g_warning(
        &quot;%s: object class `%s' has no attribute named `%s'&quot;,
        G_STRFUNC,
        g_type_name(request_type),
        prop_name
      );

      break;
    }

    if(param_size &gt;= param_alloc)
    {
      param_alloc += 16;
      params = g_realloc(params, param_alloc * sizeof(GParameter));
    }

    params[param_size].name = prop_name;
    g_value_init(&amp;params[param_size].value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    G_VALUE_COLLECT(&amp;params[param_size].value, arglist, 0, &amp;error);
    if(error != NULL)
    {
      g_warning(&quot;%s: %s&quot;, G_STRFUNC, error);
      g_value_unset(&amp;params[param_size].value);
      g_free(error);
      break;
    }

    ++ param_size;
    prop_name = va_arg(arglist, const gchar*);
  }

  if(prop_name == NULL)
  {
    request = INFC_REQUEST(g_object_newv(request_type, param_size, params));
    g_hash_table_insert(priv-&gt;requests, GUINT_TO_POINTER(seq), request);
    ++ priv-&gt;seq_counter;
  }
  else
  {
    /* An error occurred. We do not use GError here tough, because this is a
     * most likely a bug in someone's code (if not, it is one in
     * libinfinity's code). */
    request = NULL;
  }

  for(i = 0; i &lt; param_size; ++ i)
    g_value_unset(&amp;params[i].value);
  g_free(params);
  g_type_class_unref(request_class);

  if(callback != NULL)
  {
    g_signal_connect_after(
      G_OBJECT(request),
      &quot;finished&quot;,
      callback,
      user_data
    );
  }

  return request;
}

/**
 * infc_request_manager_remove_request:
 * @manager: A #InfcRequestManager.
 * @request: A #InfcRequest that has previously been added to @manager.
 *
 * Removes a request from the request manager.
 **/
void
infc_request_manager_remove_request(InfcRequestManager* manager,
                                    InfcRequest* request)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));

  g_object_ref(G_OBJECT(request));

  g_signal_emit(
    G_OBJECT(manager),
    request_manager_signals[REQUEST_REMOVE],
    0,
    request
  );

  g_object_unref(G_OBJECT(request));
}

/**
 * infc_request_manager_finish_request:
 * @manager: A #InfcRequestManager.
 * @request: A #InfcRequest that has previously been added to @manager.
 * @result: (transfer full): The request result.
 *
 * Marks @request as finished using inf_request_finish() and then removes the
 * request from the manager. The function takes ownership of @result.
 **/
void
infc_request_manager_finish_request(InfcRequestManager* manager,
                                    InfcRequest* request,
                                    InfRequestResult* result)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));
  g_return_if_fail(result != NULL);

  g_object_ref(request);
  infc_request_manager_remove_request(manager, request);
  inf_request_finish(INF_REQUEST(request), result);
  g_object_unref(request);
}

/**
 * infc_request_manager_fail_request:
 * @manager: A #InfcRequestManager.
 * @request: A #InfcRequest that has previously been added to @manager.
 * @error: Error information why the request failed.
 *
 * Marks @request as failed using inf_request_fail() and then removes the
 * request from the manager.
 **/
void
infc_request_manager_fail_request(InfcRequestManager* manager,
                                  InfcRequest* request,
                                  const GError* error)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));
  g_return_if_fail(error != NULL);

  g_object_ref(request);
  infc_request_manager_remove_request(manager, request);
  inf_request_fail(INF_REQUEST(request), error);
  g_object_unref(request);
}

/**
 * infc_request_manager_clear:
 * @manager: A #InfcRequestManager.
 *
 * Removes all the requests in @manager.
 **/
void
infc_request_manager_clear(InfcRequestManager* manager)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_hash_table_remove_all(INFC_REQUEST_MANAGER_PRIVATE(manager)-&gt;requests);
}

/**
 * infc_request_manager_get_request_by_seq:
 * @manager: A #InfcRequestManager.
 * @seq: The sequence number to which the request should be retrieved.
 *
 * Returns a previously-added request that has the given seq.
 *
 * Returns: (transfer none) (allow-none): The request with the given seq,
 * or %NULL if there is no such request.
 **/
InfcRequest*
infc_request_manager_get_request_by_seq(InfcRequestManager* manager,
                                        guint seq)
{
  InfcRequestManagerPrivate* priv;

  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);

  return INFC_REQUEST(
    g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq))
  );
}

/**
 * infc_request_manager_get_request_by_xml:
 * @manager: A #InfcRequestManager.
 * @name: Name of the expected request. May be %NULL to allow all requests.
 * @xml: XML node that is supposed to contain a &quot;seq&quot; attribute.
 * @error: Location to store error information.
 *
 * Looks whether there is a &quot;seq&quot; attribute in @xml. If not, the function
 * returns %NULL (without setting @error). Otherwise, it returns the request
 * with the given seq and name, if the sequence ID matches. If the &quot;seq&quot;
 * attribute is set but the actual request is not present (or has another
 * name), the function returns %NULL and @error is set.
 *
 * Returns: (transfer none) (allow-none): The resulting request, or %NULL
 * if the &quot;seq&quot; attribute was not present or an error occurred.
 **/
InfcRequest*
infc_request_manager_get_request_by_xml(InfcRequestManager* manager,
                                        const gchar* name,
                                        xmlNodePtr xml,
                                        GError** error)
{
  InfcRequestManagerPrivate* priv;
  InfcRequest* request;
  xmlChar* seq_attr;
  gboolean has_seq;
  guint seq_id;
  guint seq;
  gchar* request_type;

  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
  g_return_val_if_fail(xml != NULL, NULL);

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  request = NULL;

  seq_attr = inf_xml_util_get_attribute(xml, &quot;seq&quot;);
  if(!seq_attr) return NULL;

  has_seq = infc_request_manager_parse_seq(
    (const gchar*)seq_attr,
    &amp;seq_id,
    &amp;seq,
    error
  );

  xmlFree(seq_attr);
  if(!has_seq) return NULL;

  /* Not our seq ID */
  if(seq_id != priv-&gt;seq_id) return NULL;

  request = infc_request_manager_get_request_by_seq(manager, seq);
  if(request == NULL)
  {
    g_set_error(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _(&quot;No such sequence number %u&quot;),
      seq
    );
  }
  else
  {
    g_object_get(G_OBJECT(request), &quot;type&quot;, &amp;request_type, NULL);
    if(name != NULL &amp;&amp; strcmp(name, request_type) != 0)
    {
      g_set_error(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _(&quot;The request contains a sequence number referring to a request of &quot;
          &quot;type '%s', but a request of type '%s' was expected&quot;),
        request_type,
        name
      );

      request = NULL;
    }

    g_free(request_type);
  }

  return request;
}

/**
 * infc_request_manager_get_request_by_xml_required:
 * @manager: A #InfcRequestManager.
 * @name: Name of the expected request. May be %NULL to allow all requests.
 * @xml: XML node that is supposed to contain a &quot;seq&quot; attribute.
 * @error: Location to store error information.
 *
 * Looks whether there is a &quot;seq&quot; attribute in @xml. If so, it returns the
 * request with the given seq and name, if the sequence ID matches. If the
 * &quot;seq&quot; attribute is not set or the actual request is not present (or has
 * another name), the function returns %NULL and @error is set.
 *
 * Returns: (transfer none): The resulting request, or %NULL if an error
 * occurred.
 **/
InfcRequest*
infc_request_manager_get_request_by_xml_required(InfcRequestManager* manager,
                                                 const gchar* name,
                                                 xmlNodePtr xml,
                                                 GError** error)
{
  InfcRequest* request;
  GError* own_error;

  own_error = NULL;
  request = infc_request_manager_get_request_by_xml(
    manager,
    name,
    xml,
    &amp;own_error
  );

  if(request == NULL)
  {
    if(own_error == NULL)
    {
      g_set_error_literal(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _(&quot;The request does not contain a sequence number, but one &quot;
          &quot;is required&quot;)
      );
    }
    else
    {
      g_propagate_error(error, own_error);
    }
  }

  return request;
}

/**
 * infc_request_manager_foreach_request:
 * @manager: A #InfcRequestManager.
 * @func: (scope call): The function to be called.
 * @user_data: Arbitrary data to be passed to @func.
 *
 * Calls the given function for each request that has been added to the
 * request manager.
 **/
void
infc_request_manager_foreach_request(InfcRequestManager* manager,
                                     InfcRequestManagerForeachFunc func,
                                     gpointer user_data)
{
  InfcRequestManagerPrivate* priv;
  InfcRequestManagerForeachData data;

  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(func != NULL);

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);

  data.func = func;
  data.user_data = user_data;
  data.name = NULL;

  g_hash_table_foreach(
    priv-&gt;requests,
    infc_request_manager_foreach_request_func,
    &amp;data
  );
}

/**
 * infc_request_manager_foreach_named_request:
 * @manager: A #InfcRequestManager.
 * @name: The name of the request to look for.
 * @func: (scope call): The function to be called.
 * @user_data: Arbitrary data to be passed to @func.
 *
 * Calls the given function for each request that has been added to the
 * request manager that has the name @name.
 **/
void
infc_request_manager_foreach_named_request(InfcRequestManager* manager,
                                           const gchar* name,
                                           InfcRequestManagerForeachFunc func,
                                           gpointer user_data)
{
  InfcRequestManagerPrivate* priv;
  InfcRequestManagerForeachData data;

  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(func != NULL);

  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);

  data.func = func;
  data.user_data = user_data;
  data.name = name;

  g_hash_table_foreach(
    priv-&gt;requests,
    infc_request_manager_foreach_request_func,
    &amp;data
  );
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
