<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-session-proxy.c &amp; infc-request-manager.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-session-proxy.c &amp; infc-request-manager.c
      </h3>
<h1 align="center">
        8.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-session-proxy.c (6.2402496%)<th>infc-request-manager.c (12.539185%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(60-101)<td><a href="#" name="0">(56-85)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(971-993)<td><a href="#" name="1">(224-246)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1358-1377)<td><a href="#" name="2">(283-323)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/server/infd-session-proxy.h&gt;
#include &lt;libinfinity/server/infd-request.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt;
typedef struct _InfdSessionProxySubscription InfdSessionProxySubscription;
struct _InfdSessionProxySubscription {
  InfXmlConnection* connection;
<a name="0"></a>  guint seq_id;
  GSList* users; <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
typedef struct _InfdSessionProxyPrivate InfdSessionProxyPrivate;
struct _InfdSessionProxyPrivate {
  InfIo* io;
  InfSession* session;
  InfCommunicationHostedGroup* subscription_group;
  GSList* subscriptions;
  guint user_id_counter;
  GSList* local_users;
  gboolean idle;
};
enum {
  PROP_0,
  PROP_IO,
  PROP_SESSION,
  PROP_SUBSCRIPTION_GROUP,
  PROP_IDLE
};
enum {
  ADD_SUBSCRIPTION,
  REMOVE_SUBSCRIPTION,
  REJECT_USER_JOIN,
  LAST_SIGNAL
};
#define INFD_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_SESSION_PROXY, InfdSessionProxyPrivate))
static guint session_proxy_signals[LAST_SIGNAL];
static void infd_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);</b></font>
static void infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfdSessionProxy, infd_session_proxy, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdSessionProxy)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infd_session_proxy_communication_object_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infd_session_proxy_session_proxy_iface_init))
static InfdSessionProxySubscription*
infd_session_proxy_subscription_new(InfXmlConnection* connection,
                                    guint seq_id)
{
  InfdSessionProxySubscription* subscription;
  subscription = g_slice_new(InfdSessionProxySubscription);
  subscription-&gt;connection = connection;
  subscription-&gt;seq_id = seq_id;
  subscription-&gt;users = NULL;
  g_object_ref(G_OBJECT(connection));
  return subscription;
}
static void
infd_session_proxy_subscription_free(InfdSessionProxySubscription* subscr)
{
  g_object_unref(G_OBJECT(subscr-&gt;connection));
  g_slist_free(subscr-&gt;users);
  g_slice_free(InfdSessionProxySubscription, subscr);
}
static GSList*
infd_session_proxy_find_subscription_item(InfdSessionProxy* proxy,
                                          InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  GSList* item;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  for(item = priv-&gt;subscriptions; item != NULL; item = g_slist_next(item))
    if( ((InfdSessionProxySubscription*)item-&gt;data)-&gt;connection == connection)
      return item;
  return NULL;
}
static InfdSessionProxySubscription*
infd_session_proxy_find_subscription(InfdSessionProxy* proxy,
                                     InfXmlConnection* connection)
{
  GSList* item;
  item = infd_session_proxy_find_subscription_item(proxy, connection);
  if(item == NULL) return NULL;
  return (InfdSessionProxySubscription*)item-&gt;data;
}
static gboolean
infd_session_proxy_check_idle(InfdSessionProxy* proxy)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;subscriptions == NULL &amp;&amp;
     priv-&gt;local_users == NULL &amp;&amp;
     !inf_session_has_synchronizations(priv-&gt;session))
  {
    return TRUE;
  }
  return FALSE;
}
static void
infd_session_proxy_user_notify_status_cb(InfUser* user,
                                         const GParamSpec* pspec,
                                         gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscr;
  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE)
  {
    proxy = INFD_SESSION_PROXY(user_data);
    priv = INFD_SESSION_PROXY_PRIVATE(proxy);
    if(inf_user_get_connection(user))
    {
      subscr = infd_session_proxy_find_subscription(
        proxy,
        inf_user_get_connection(user)
      );
      g_assert(subscr != NULL);
      subscr-&gt;users = g_slist_remove(subscr-&gt;users, user);
      g_object_set(G_OBJECT(user), "connection", NULL, NULL);
    }
    else
    {
      priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, user);
      if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
      {
        priv-&gt;idle = TRUE;
        g_object_notify(G_OBJECT(proxy), "idle");
      }
    }
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(user),
      G_CALLBACK(infd_session_proxy_user_notify_status_cb),
      proxy
    );
  }
}
static gboolean
infd_session_proxy_make_seq(InfdSessionProxy* proxy,
                            InfXmlConnection* connection,
                            xmlNodePtr xml,
                            gchar** seq,
                            GError** error)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  GError* local_error;
  guint seq_num;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  local_error = NULL;
  if(!inf_xml_util_get_attribute_uint(xml, "seq", &amp;seq_num, &amp;local_error))
  {
    if(local_error)
    {
      g_propagate_error(error, local_error);
      return FALSE;
    }
    *seq = NULL;
    return TRUE;
  }
  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_assert(subscription != NULL);
  *seq = g_strdup_printf("%u/%u", subscription-&gt;seq_id, seq_num);
  return TRUE;
}
static InfUser*
infd_session_proxy_perform_user_join(InfdSessionProxy* proxy,
                                     InfXmlConnection* connection,
                                     const gchar* seq,
                                     GArray* user_props,
                                     GError** error)
{
  InfSessionClass* session_class;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  InfUser* user;
  const GParameter* name_param;
  GParameter* param;
  gboolean result;
  xmlNodePtr xml;
  guint i;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  g_assert(session_class-&gt;validate_user_props != NULL);
  g_assert(session_class-&gt;user_new != NULL);
  name_param = inf_session_lookup_user_property(
    (const GParameter*)user_props-&gt;data,
    user_props-&gt;len,
    "name"
  );
  if(name_param == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("Request does not contain required attribute \"name\"")
    );
    return NULL;
  }
  user = inf_user_table_lookup_user_by_name(
    inf_session_get_user_table(priv-&gt;session),
    g_value_get_string(&amp;name_param-&gt;value)
  );
  if(user != NULL &amp;&amp; inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NAME_IN_USE,
      _("Name \"%s\" already in use"),
      g_value_get_string(&amp;name_param-&gt;value)
    );
    return NULL;
  }
  param = inf_session_get_user_property(user_props, "id");
  if(G_IS_VALUE(&amp;param-&gt;value))
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
      inf_user_strerror(INF_USER_ERROR_ID_PROVIDED)
    );
    return NULL;
  }
  g_value_init(&amp;param-&gt;value, G_TYPE_UINT);
  if(user != NULL)
    g_value_set_uint(&amp;param-&gt;value, inf_user_get_id(user));
  else
    g_value_set_uint(&amp;param-&gt;value, priv-&gt;user_id_counter);
  param = inf_session_get_user_property(user_props, "status");
  if(G_IS_VALUE(&amp;param-&gt;value))
  {
    if(g_value_get_enum(&amp;param-&gt;value) == INF_USER_UNAVAILABLE)
    {
      g_set_error_literal(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
        _("\"status\" attribute is \"unavailable\" in user join request")
      );
      return NULL;
    }
  }
  else
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_USER_STATUS);
    g_value_set_enum(&amp;param-&gt;value, INF_USER_ACTIVE);
  }
  param = inf_session_get_user_property(user_props, "flags");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value));
  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(connection == NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);
  param = inf_session_get_user_property(user_props, "connection");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value));
  g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
  g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)user_props-&gt;data,
    user_props-&gt;len,
    user,
    error
  );
  if(result == FALSE)
    return NULL;
  g_signal_emit(
    proxy,
    session_proxy_signals[REJECT_USER_JOIN],
    0,
    connection,
    user_props,
    user,
    &amp;result
  );
  if(result == TRUE)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NOT_AUTHORIZED,
      _("Permission denied")
    );
    return NULL;
  }
  if(user == NULL)
  {
    user = inf_session_add_user(
      priv-&gt;session,
      (const GParameter*)user_props-&gt;data,
      user_props-&gt;len
    );
    g_assert(user != NULL);
    xml = xmlNewNode(NULL, (const xmlChar*)"user-join");
  }
  else
  {
    g_object_freeze_notify(G_OBJECT(user));
    for(i = 0; i &lt; user_props-&gt;len; ++ i)
    {
      param = &amp;g_array_index(user_props, GParameter, i);
      if(strcmp(param-&gt;name, "name") != 0 &amp;&amp; strcmp(param-&gt;name, "id") != 0)
        g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
    }
    g_object_thaw_notify(G_OBJECT(user));
    xml = xmlNewNode(NULL, (const xmlChar*)"user-rejoin");
  }
  inf_session_user_to_xml(priv-&gt;session, user, xml);
  if(seq != NULL) inf_xml_util_set_attribute(xml, "seq", seq);
  g_signal_connect(
    G_OBJECT(user),
    "notify::status",
    G_CALLBACK(infd_session_proxy_user_notify_status_cb),
    proxy
  );
  inf_session_send_to_subscriptions(priv-&gt;session, xml);
  if(connection != NULL)
  {
    subscription = infd_session_proxy_find_subscription(proxy, connection);
    g_assert(subscription != NULL);
    subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);
  }
  else
  {
    priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, user);
    if(priv-&gt;idle == TRUE)
    {
      priv-&gt;idle = FALSE;
      g_object_notify(G_OBJECT(proxy), "idle");
    }
  }
  return user;
}
static void
infd_session_proxy_member_removed_cb(InfCommunicationGroup* group,
                                     InfXmlConnection* connection,
                                     gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  xmlNodePtr xml;
  GSList* item;
  InfUser* user;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_assert(subscription != NULL);
  for(item = subscription-&gt;users; item != NULL; item = g_slist_next(item))
  {
    user = INF_USER(item-&gt;data);
    xml = xmlNewNode(NULL, (const xmlChar*)"user-status-change");
    inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(user));
    inf_xml_util_set_attribute(
      xml,
      "status",
      inf_user_status_to_string(INF_USER_UNAVAILABLE)
    );
    inf_session_send_to_subscriptions(priv-&gt;session, xml);
  }
  g_signal_emit(
    proxy,
    session_proxy_signals[REMOVE_SUBSCRIPTION],
    0,
    connection
  );
}
static void
infd_session_proxy_add_user_cb(InfUserTable* user_table,
                               InfUser* user,
                               gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfXmlConnection* sync_conn;
  InfdSessionProxySubscription* subscription;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
    priv-&gt;user_id_counter = inf_user_get_id(user) + 1;
  if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING)
  {
    if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
    {
      g_object_get(
        G_OBJECT(priv-&gt;session),
        "sync-connection",
        &amp;sync_conn,
        NULL
      );
      g_assert(sync_conn != NULL);
      subscription = infd_session_proxy_find_subscription(proxy, sync_conn);
      if(sync_conn != inf_user_get_connection(user) || subscription == NULL)
      {
        inf_session_close(priv-&gt;session);
      }
      else
      {
        subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);
        g_signal_connect(
          G_OBJECT(user),
          "notify::status",
          G_CALLBACK(infd_session_proxy_user_notify_status_cb),
          proxy
        );
      }
      g_object_unref(sync_conn);
    }
  }
}
static void
infd_session_proxy_synchronization_begin_cb(InfSession* session,
                                            InfCommunicationGroup* group,
                                            InfXmlConnection* connection,
                                            gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;idle)
  {
    priv-&gt;idle = FALSE;
    g_object_notify(G_OBJECT(proxy), "idle");
  }
}
static void
infd_session_proxy_synchronization_complete_cb(InfSession* session,
                                               InfXmlConnection* conn,
                                               gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
     priv-&gt;local_users == NULL &amp;&amp;
     !inf_session_has_synchronizations(session))
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), "idle");
  }
}
static void
infd_session_proxy_synchronization_failed_cb_before(InfSession* session,
                                                    InfXmlConnection* conn,
                                                    const GError* error,
                                                    gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfSessionStatus status;
  InfdSessionProxySubscription* subscription;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_object_get(session, "status", &amp;status, NULL);
  if(status == INF_SESSION_RUNNING)
  {
    subscription = infd_session_proxy_find_subscription(proxy, conn);
    if(subscription != NULL)
    {
      inf_communication_hosted_group_remove_member(
        priv-&gt;subscription_group,
        conn
      );
    }
  }
}
static void
infd_session_proxy_synchronization_failed_cb_after(InfSession* session,
                                                   InfXmlConnection* conn,
                                                   const GError* error,
                                                   gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
     !inf_session_has_synchronizations(session))
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), "idle");
  }
}
static void
infd_session_proxy_session_close_cb(InfSession* session,
                                    gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;subscription_group),
    G_CALLBACK(infd_session_proxy_member_removed_cb),
    proxy
  );
  while(priv-&gt;subscriptions != NULL)
  {
    subscription = (InfdSessionProxySubscription*)priv-&gt;subscriptions-&gt;data;
    infd_session_proxy_unsubscribe(proxy, subscription-&gt;connection);
    g_signal_emit(
      proxy,
      session_proxy_signals[REMOVE_SUBSCRIPTION],
      0,
      subscription-&gt;connection
    );
  }
  while(priv-&gt;local_users != NULL)
  {
    g_object_set(
      G_OBJECT(priv-&gt;local_users-&gt;data),
      "status", INF_USER_UNAVAILABLE,
      NULL
    );
  }
  g_object_unref(priv-&gt;subscription_group);
  priv-&gt;subscription_group = NULL;
}
static void
infd_session_proxy_init(InfdSessionProxy* session_proxy)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);
  priv-&gt;io = NULL;
  priv-&gt;subscriptions = NULL;
  priv-&gt;subscription_group = NULL;
  priv-&gt;user_id_counter = 1;
  priv-&gt;local_users = NULL;
  priv-&gt;idle = TRUE;
}
static void
infd_session_proxy_constructed(GObject* object)
{
  InfdSessionProxy* session_proxy;
  InfdSessionProxyPrivate* priv;
  session_proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);
  G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;constructed(object);
  g_assert(priv-&gt;subscription_group != NULL);
  g_assert(priv-&gt;session != NULL);
  if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING ||
     priv-&gt;local_users != NULL)
  {
    priv-&gt;idle = FALSE;
  }
  inf_session_set_subscription_group(
    priv-&gt;session,
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
  );
}
static void
infd_session_proxy_dispose(GObject* object)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfCommunicationManager* manager;
  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  manager = inf_session_get_communication_manager(priv-&gt;session);
  g_object_ref(manager);
  g_slist_free(priv-&gt;local_users);
  priv-&gt;local_users = NULL;
  if(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED)
    inf_session_close(priv-&gt;session);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_session_close_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
    G_CALLBACK(infd_session_proxy_add_user_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
    proxy
  );
  g_object_unref(priv-&gt;session);
  priv-&gt;session = NULL;
  g_assert(priv-&gt;subscription_group == NULL);
  g_assert(priv-&gt;subscriptions == NULL);
  g_object_unref(priv-&gt;io);
  priv-&gt;io = NULL;
  g_object_unref(manager);
  G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;dispose(object);
}
static void
infd_session_proxy_session_init_user_func(InfUser* user,
                                          gpointer user_data)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(user_data);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
    priv-&gt;user_id_counter = inf_user_get_id(user) + 1;
}
static void
infd_session_proxy_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_SESSION:
    g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_SESSION(g_value_dup_object(value));
    inf_user_table_foreach_user(
      inf_session_get_user_table(priv-&gt;session),
      infd_session_proxy_session_init_user_func,
      proxy
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "close",
      G_CALLBACK(infd_session_proxy_session_close_cb),
      proxy
    );
    g_signal_connect(
      G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
      "add-user",
      G_CALLBACK(infd_session_proxy_add_user_cb),
      proxy
    );
    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      "synchronization-begin",
      G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
      proxy
    );
    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      "synchronization-complete",
      G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
      proxy
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "synchronization-failed",
      G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
      proxy
    );
    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      "synchronization-failed",
      G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
      proxy
    );
    break;
  case PROP_SUBSCRIPTION_GROUP:
    g_assert(priv-&gt;subscription_group == NULL);     priv-&gt;subscription_group =
      INF_COMMUNICATION_HOSTED_GROUP(g_value_dup_object(value));
    g_signal_connect(
      G_OBJECT(priv-&gt;subscription_group),
      "member-removed",
      G_CALLBACK(infd_session_proxy_member_removed_cb),
      proxy
    );
<a name="1"></a>    break;
  case PROP_IDLE:
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_session_proxy_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, priv-&gt;io);
    break;</b></font>
  case PROP_SESSION:
    g_value_set_object(value, priv-&gt;session);
    break;
  case PROP_SUBSCRIPTION_GROUP:
    g_value_set_object(value, priv-&gt;subscription_group);
    break;
  case PROP_IDLE:
    g_value_set_boolean(value, priv-&gt;idle);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_session_proxy_add_subscription(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    guint seq_id)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(infd_session_proxy_find_subscription(proxy, connection) == NULL);
  subscription = infd_session_proxy_subscription_new(connection, seq_id);
  priv-&gt;subscriptions = g_slist_prepend(priv-&gt;subscriptions, subscription);
  if(priv-&gt;idle == TRUE)
  {
    priv-&gt;idle = FALSE;
    g_object_notify(G_OBJECT(proxy), "idle");
  }
}
static void
infd_session_proxy_remove_subscription(InfdSessionProxy* proxy,
                                       InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscr;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  subscr = infd_session_proxy_find_subscription(proxy, connection);
  g_assert(subscr != NULL);
  while(subscr-&gt;users)
  {
    g_object_set(
      G_OBJECT(subscr-&gt;users-&gt;data),
      "status", INF_USER_UNAVAILABLE,
      NULL
    );
  }
  priv-&gt;subscriptions = g_slist_remove(priv-&gt;subscriptions, subscr);
  infd_session_proxy_subscription_free(subscr);
  if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
  {
    priv-&gt;idle = TRUE;
    g_object_notify(G_OBJECT(proxy), "idle");
  }
}
static gboolean
infd_session_proxy_reject_user_join(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    const GArray* user_properties,
                                    InfUser* user_rejoin)
{
  return FALSE;
}
static gboolean
infd_session_proxy_handle_user_join(InfdSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    xmlNodePtr xml,
                                    GError** error)
{
  InfdSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  GArray* array;
  InfUser* user;
  gchar* seq;
  guint i;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  if(!infd_session_proxy_make_seq(proxy, connection, xml, &amp;seq, error))
    return FALSE;
  array = session_class-&gt;get_xml_user_props(
    priv-&gt;session,
    connection,
    xml
  );
  user = infd_session_proxy_perform_user_join(
    proxy,
    connection,
    seq,
    array,
    error
  );
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  g_free(seq);
  if(user == NULL)
    return FALSE;
  return TRUE;
}
static gboolean
infd_session_proxy_handle_session_unsubscribe(InfdSessionProxy* proxy,
                                              InfXmlConnection* connection,
                                              const xmlNodePtr xml,
                                              GError** error)
{
  InfdSessionProxyPrivate* priv;
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);
  inf_communication_hosted_group_remove_member(
    priv-&gt;subscription_group,
    connection
  );
  return TRUE;
}
static void
infd_session_proxy_communication_object_sent(InfCommunicationObject* object,
                                             InfXmlConnection* connection,
                                             xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(object);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;session != NULL);
  inf_communication_object_sent(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}
static void
infd_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  proxy = INFD_SESSION_PROXY(obj);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;session != NULL);
  inf_communication_object_enqueued(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}
static InfCommunicationScope
infd_session_proxy_communication_object_received(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfdSessionProxy* proxy;
  InfdSessionProxyPrivate* priv;
  InfSessionSyncStatus status;
  GError* local_error;
  xmlNodePtr reply_xml;
  gchar* seq;
  proxy = INFD_SESSION_PROXY(obj);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;session != NULL);
  status = inf_session_get_synchronization_status(priv-&gt;session, connection);
  local_error = NULL;
  if(status != INF_SESSION_SYNC_NONE)
  {
    return inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(priv-&gt;session),
      connection,
      node
    );
  }
  else
  {
    if(strcmp((const char*)node-&gt;name, "user-join") == 0)
    {
      infd_session_proxy_handle_user_join(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "session-unsubscribe") == 0)
    {
      infd_session_proxy_handle_session_unsubscribe(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else
    {
      return inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(priv-&gt;session),
        connection,
        node
      );
    }
  }
  if(local_error != NULL)
  {
    if(!infd_session_proxy_make_seq(proxy, connection, node, &amp;seq, NULL))
      seq = NULL;
    reply_xml = inf_xml_util_new_node_from_error(local_error,
                                                 NULL,
                                                 "request-failed");
    if(seq != NULL) inf_xml_util_set_attribute(reply_xml, "seq", seq);
    g_free(seq);
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      connection,
      reply_xml
    );
    g_error_free(local_error);
  }
  return INF_COMMUNICATION_SCOPE_PTP;
}
static InfRequest*
infd_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
                                           guint n_params,
                                           const GParameter* params,
                                           InfRequestFunc func,
                                           gpointer user_data)
{
  InfdRequest* request;
  GArray* array;
  guint i;
  GParameter param;
  GError* error;
  InfUser* user;
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), NULL);
  request = g_object_new(
    INFD_TYPE_REQUEST,
    "type", "user-join",
    NULL
  );
  if(func != NULL)
  {
    g_signal_connect_after(
      G_OBJECT(request),
      "finished",
      G_CALLBACK(func),
      user_data
    );
  }
  array = g_array_sized_new(
    FALSE,
    FALSE,
    sizeof(GParameter),
    n_params
  );
  g_array_append_vals(array, params, n_params);
  error = NULL;
  user = infd_session_proxy_perform_user_join(
    INFD_SESSION_PROXY(proxy),
    NULL,
    NULL,
    array,
    &amp;error
  );
  for(i = n_params; i &lt; array-&gt;len; ++i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  if(error != NULL)
  {
    inf_request_fail(INF_REQUEST(request), error);
  }
  else
  {
    inf_request_finish(
      INF_REQUEST(request),
      inf_request_result_make_join_user(proxy, user)
    );
  }
<a name="2"></a>
  if(error) g_error_free(error);
  g_object_unref(request);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return NULL;
}
static void
infd_session_proxy_class_init(InfdSessionProxyClass* proxy_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(proxy_class);
  object_class-&gt;constructed = infd_session_proxy_constructed;
  object_class-&gt;dispose = infd_session_proxy_dispose;
  object_class-&gt;set_property = infd_session_proxy_set_property;
  object_class-&gt;get_property = infd_session_proxy_get_property;
  proxy_class-&gt;add_subscription = infd_session_proxy_add_subscription;
  proxy_class-&gt;remove_subscription = infd_session_proxy_remove_subscription;</b></font>
  proxy_class-&gt;reject_user_join = infd_session_proxy_reject_user_join;
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "Io",
      "The InfIo object for scheduling events",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SUBSCRIPTION_GROUP,
    g_param_spec_object(
      "subscription-group",
      "Subscription group",
      "The communication manager group of subscribed connections",
      INF_COMMUNICATION_TYPE_HOSTED_GROUP,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_IDLE,
    g_param_spec_boolean(
      "idle",
      "Idle",
      "The session is considered idle when are no subscriptions and no "
      "synchronizations",
      TRUE,
      G_PARAM_READABLE
    )
  );
  g_object_class_override_property(object_class, PROP_SESSION, "session");
  session_proxy_signals[ADD_SUBSCRIPTION] = g_signal_new(
    "add-subscription",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, add_subscription),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_UINT
  );
  session_proxy_signals[REMOVE_SUBSCRIPTION] = g_signal_new(
    "remove-subscription",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, remove_subscription),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_XML_CONNECTION
  );
  session_proxy_signals[REJECT_USER_JOIN] = g_signal_new(
    "reject-user-join",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdSessionProxyClass, reject_user_join),
    g_signal_accumulator_true_handled, NULL,
    NULL,
    G_TYPE_BOOLEAN,
    3,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_ARRAY,
    INF_TYPE_USER
  );
}
static void
infd_session_proxy_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;sent = infd_session_proxy_communication_object_sent;
  iface-&gt;enqueued = infd_session_proxy_communication_object_enqueued;
  iface-&gt;received = infd_session_proxy_communication_object_received;
}
static void
infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
{
  iface-&gt;join_user = infd_session_proxy_session_proxy_join_user;
}
void
infd_session_proxy_subscribe_to(InfdSessionProxy* proxy,
                                InfXmlConnection* connection,
                                guint seq_id,
                                gboolean synchronize)
{
  InfdSessionProxyPrivate* priv;
  g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(
    infd_session_proxy_find_subscription(proxy, connection) == NULL
  );
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_return_if_fail(priv-&gt;session != NULL);
  g_return_if_fail(
    inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING ||
    (synchronize == FALSE)
  );
  inf_communication_hosted_group_add_member(
    priv-&gt;subscription_group,
    connection
  );
  g_signal_emit(
    G_OBJECT(proxy),
    session_proxy_signals[ADD_SUBSCRIPTION],
    0,
    connection,
    seq_id
  );
  g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);
  if(synchronize)
  {
    inf_session_synchronize_to(
      priv-&gt;session,
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      connection
    );
  }
}
void
infd_session_proxy_unsubscribe(InfdSessionProxy* proxy,
                               InfXmlConnection* connection)
{
  InfdSessionProxyPrivate* priv;
  InfdSessionProxySubscription* subscription;
  InfSessionSyncStatus status;
  xmlNodePtr xml;
  g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  g_assert(inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING);
  subscription = infd_session_proxy_find_subscription(proxy, connection);
  g_return_if_fail(subscription != NULL);
  status = inf_session_get_synchronization_status(
    priv-&gt;session,
    subscription-&gt;connection
  );
  if(status != INF_SESSION_SYNC_IN_PROGRESS)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)"session-close");
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      subscription-&gt;connection,
      xml
    );
  }
  else
  {
    inf_session_cancel_synchronization(
      priv-&gt;session,
      subscription-&gt;connection
    );
  }
  inf_communication_hosted_group_remove_member(
    priv-&gt;subscription_group,
    subscription-&gt;connection
  );
}
gboolean
infd_session_proxy_has_subscriptions(InfdSessionProxy* proxy)
{
  InfdSessionProxyPrivate* priv;
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  priv = INFD_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;subscriptions == NULL)
    return FALSE;
  return TRUE;
}
gboolean
infd_session_proxy_is_subscribed(InfdSessionProxy* proxy,
                                 InfXmlConnection* connection)
{
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), FALSE);
  if(infd_session_proxy_find_subscription(proxy, connection) == NULL)
    return FALSE;
  return TRUE;
}
gboolean
infd_session_proxy_is_idle(InfdSessionProxy* proxy)
{
  g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
  return INFD_SESSION_PROXY_PRIVATE(proxy)-&gt;idle;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-request-manager.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/client/infc-request-manager.h&gt;
#include &lt;libinfinity/common/inf-request.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;gobject/gvaluecollector.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
typedef struct _InfcRequestManagerForeachData InfcRequestManagerForeachData;
struct _InfcRequestManagerForeachData {
<a name="0"></a>  InfcRequestManagerForeachFunc func;
  gpointer user_data;
  const gchar* name;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
typedef struct _InfcRequestManagerPrivate InfcRequestManagerPrivate;
struct _InfcRequestManagerPrivate {
  GHashTable* requests;
  guint seq_id;
  guint seq_counter;
};
enum {
  PROP_0,
  PROP_SEQUENCE_ID
};
enum {
  REQUEST_ADD,
  REQUEST_REMOVE,
  LAST_SIGNAL
};
#define INFC_REQUEST_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_REQUEST_MANAGER, InfcRequestManagerPrivate))
static guint request_manager_signals[LAST_SIGNAL];
G_DEFINE_TYPE_WITH_CODE(InfcRequestManager, infc_request_manager, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcRequestManager))
static void</b></font>
infc_request_manager_foreach_request_func(gpointer key,
                                          gpointer value,
                                          gpointer user_data)
{
  InfcRequest* request;
  InfcRequestManagerForeachData* foreach_data;
  gchar* type;
  request = INFC_REQUEST(value);
  foreach_data = (InfcRequestManagerForeachData*)user_data;
  g_object_get(G_OBJECT(request), "type", &amp;type, NULL);
  if(foreach_data-&gt;name == NULL || strcmp(foreach_data-&gt;name, type) == 0)
  {
    foreach_data-&gt;func(request, foreach_data-&gt;user_data);
  }
  g_free(type);
}
static gboolean
infc_request_manager_parse_seq(const gchar* seq,
                               guint* seq_id,
                               guint* seq_num,
                               GError** error)
{
  gchar* endptr;
  unsigned long sid;
  unsigned long snum;
  errno = 0;
  sid = strtoul(seq, &amp;endptr, 10);
  if(errno == ERANGE || sid &gt; (unsigned long)G_MAXUINT)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _("Sequence identifier causes overflow")
    );
    return FALSE;
  }
  if(*endptr != '/')
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _("Sequence components are not separated by '/'")
    );
    return FALSE;
  }
  errno = 0;
  snum = strtoul(endptr + 1, &amp;endptr, 10);
  if(errno == ERANGE || snum &gt; (unsigned long)G_MAXUINT)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _("Sequence number causes overflow")
    );
    return FALSE;
  }
  if(*endptr != '\0')
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _("Trailing characters after sequence number")
    );
    return FALSE;
  }
  if(seq_id) *seq_id = sid;
  if(seq_num) *seq_num = snum;
  return TRUE;
}
static void
infc_request_manager_init(InfcRequestManager* manager)
{
  InfcRequestManagerPrivate* priv;
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  priv-&gt;requests = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)g_object_unref
  );
  priv-&gt;seq_id = 0;
  priv-&gt;seq_counter = 0;
}
static void
infc_request_manager_dispose(GObject* object)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;
  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
  g_hash_table_destroy(priv-&gt;requests);
  priv-&gt;requests = NULL;
  G_OBJECT_CLASS(infc_request_manager_parent_class)-&gt;dispose(object);
}
static void
infc_request_manager_set_property(GObject* object,
                                  guint prop_id,
                                  const GValue* value,
                                  GParamSpec* pspec)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;
  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
  switch(prop_id)
  {
<a name="1"></a>  case PROP_SEQUENCE_ID:
    priv-&gt;seq_id = g_value_get_uint(value);
    break;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infc_request_manager_get_property(GObject* object,
                                  guint prop_id,
                                  GValue* value,
                                  GParamSpec* pspec)
{
  InfcRequestManager* request_manager;
  InfcRequestManagerPrivate* priv;
  request_manager = INFC_REQUEST_MANAGER(object);
  priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
  switch(prop_id)
  {
  case PROP_SEQUENCE_ID:
    g_value_set_uint(value, priv-&gt;seq_id);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infc_request_manager_request_add(InfcRequestManager* manager,
                                 InfcRequest* request)
{
  InfcRequestManagerPrivate* priv;
  guint seq;
  gpointer seq_ptr;
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  g_object_get(G_OBJECT(request), "seq", &amp;seq, NULL);
  seq_ptr = GUINT_TO_POINTER(seq);
  g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) == NULL);
  g_hash_table_insert(priv-&gt;requests, seq_ptr, request);
  g_object_ref(G_OBJECT(request));
}
static void
infc_request_manager_request_remove(InfcRequestManager* manager,
                                    InfcRequest* request)
{
  InfcRequestManagerPrivate* priv;
  guint seq;
  gpointer seq_ptr;
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
<a name="2"></a>  g_object_get(G_OBJECT(request), "seq", &amp;seq, NULL);
  seq_ptr = GUINT_TO_POINTER(seq);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) != NULL);
  g_hash_table_remove(priv-&gt;requests, seq_ptr);
}
static void
infc_request_manager_class_init(
  InfcRequestManagerClass* request_manager_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(request_manager_class);
  object_class-&gt;dispose = infc_request_manager_dispose;
  object_class-&gt;set_property = infc_request_manager_set_property;
  object_class-&gt;get_property = infc_request_manager_get_property;
  request_manager_class-&gt;request_add = infc_request_manager_request_add;
  request_manager_class-&gt;request_remove = infc_request_manager_request_remove;
  g_object_class_install_property(
    object_class,
    PROP_SEQUENCE_ID,
    g_param_spec_uint(
      "sequence-id",
      "Sequence ID",
      "The local sequence identifier",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  request_manager_signals[REQUEST_ADD] = g_signal_new(</b></font>
    "request-add",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfcRequestManagerClass, request_add),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INFC_TYPE_REQUEST
  );
  request_manager_signals[REQUEST_REMOVE] = g_signal_new(
    "request-remove",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfcRequestManagerClass, request_remove),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INFC_TYPE_REQUEST
  );
}
InfcRequestManager*
infc_request_manager_new(guint seq_id)
{
  GObject* object;
  object =
    g_object_new(INFC_TYPE_REQUEST_MANAGER, "sequence-id", seq_id, NULL);
  return INFC_REQUEST_MANAGER(object);
}
InfcRequest*
infc_request_manager_add_request(InfcRequestManager* manager,
                                 GType request_type,
                                 const gchar* request_name,
                                 GCallback callback,
                                 gpointer user_data,
                                 const gchar* first_property_name,
                                 ...)
{
  InfcRequest* request;
  va_list arglist;
  va_start(arglist, first_property_name);
  request = infc_request_manager_add_request_valist(
    manager,
    request_type,
    request_name,
    callback,
    user_data,
    first_property_name,
    arglist
  );
  va_end(arglist);
  return request;
}
InfcRequest*
infc_request_manager_add_request_valist(InfcRequestManager* manager,
                                        GType request_type,
                                        const gchar* request_name,
                                        GCallback callback,
                                        gpointer user_data,
                                        const gchar* first_property_name,
                                        va_list arglist)
{
  InfcRequestManagerPrivate* priv;
  GObjectClass* request_class;
  InfcRequest* request;
  GParameter* params;
  const gchar* prop_name;
  gsize param_size;
  gsize param_alloc;
  guint seq;
  gchar* error;
  GParamSpec* pspec;
  guint i;
  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
  g_return_val_if_fail(request_name != NULL, NULL);
  request_class = g_type_class_ref(request_type);
  g_return_val_if_fail(request_class != NULL, NULL);
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  seq = priv-&gt;seq_counter;
  g_assert(
    g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq)) == NULL
  );
  param_size = 0;
  param_alloc = 16;
  params = g_malloc0(param_alloc * sizeof(GParameter));
  params[param_size].name = "type";
  g_value_init(&amp;params[param_size].value, G_TYPE_STRING);
  g_value_set_static_string(&amp;params[param_size].value, request_name);
  ++ param_size;
  params[param_size].name = "seq";
  g_value_init(&amp;params[param_size].value, G_TYPE_UINT);
  g_value_set_uint(&amp;params[param_size].value, seq);
  ++ param_size;
  prop_name = first_property_name;
  error = NULL;
  while(prop_name != NULL)
  {
    pspec = g_object_class_find_property(request_class, prop_name);
    if(pspec == NULL)
    {
      g_warning(
        "%s: object class `%s' has no attribute named `%s'",
        G_STRFUNC,
        g_type_name(request_type),
        prop_name
      );
      break;
    }
    if(param_size &gt;= param_alloc)
    {
      param_alloc += 16;
      params = g_realloc(params, param_alloc * sizeof(GParameter));
    }
    params[param_size].name = prop_name;
    g_value_init(&amp;params[param_size].value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    G_VALUE_COLLECT(&amp;params[param_size].value, arglist, 0, &amp;error);
    if(error != NULL)
    {
      g_warning("%s: %s", G_STRFUNC, error);
      g_value_unset(&amp;params[param_size].value);
      g_free(error);
      break;
    }
    ++ param_size;
    prop_name = va_arg(arglist, const gchar*);
  }
  if(prop_name == NULL)
  {
    request = INFC_REQUEST(g_object_newv(request_type, param_size, params));
    g_hash_table_insert(priv-&gt;requests, GUINT_TO_POINTER(seq), request);
    ++ priv-&gt;seq_counter;
  }
  else
  {
    request = NULL;
  }
  for(i = 0; i &lt; param_size; ++ i)
    g_value_unset(&amp;params[i].value);
  g_free(params);
  g_type_class_unref(request_class);
  if(callback != NULL)
  {
    g_signal_connect_after(
      G_OBJECT(request),
      "finished",
      callback,
      user_data
    );
  }
  return request;
}
void
infc_request_manager_remove_request(InfcRequestManager* manager,
                                    InfcRequest* request)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));
  g_object_ref(G_OBJECT(request));
  g_signal_emit(
    G_OBJECT(manager),
    request_manager_signals[REQUEST_REMOVE],
    0,
    request
  );
  g_object_unref(G_OBJECT(request));
}
void
infc_request_manager_finish_request(InfcRequestManager* manager,
                                    InfcRequest* request,
                                    InfRequestResult* result)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));
  g_return_if_fail(result != NULL);
  g_object_ref(request);
  infc_request_manager_remove_request(manager, request);
  inf_request_finish(INF_REQUEST(request), result);
  g_object_unref(request);
}
void
infc_request_manager_fail_request(InfcRequestManager* manager,
                                  InfcRequest* request,
                                  const GError* error)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(INFC_IS_REQUEST(request));
  g_return_if_fail(error != NULL);
  g_object_ref(request);
  infc_request_manager_remove_request(manager, request);
  inf_request_fail(INF_REQUEST(request), error);
  g_object_unref(request);
}
void
infc_request_manager_clear(InfcRequestManager* manager)
{
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_hash_table_remove_all(INFC_REQUEST_MANAGER_PRIVATE(manager)-&gt;requests);
}
InfcRequest*
infc_request_manager_get_request_by_seq(InfcRequestManager* manager,
                                        guint seq)
{
  InfcRequestManagerPrivate* priv;
  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  return INFC_REQUEST(
    g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq))
  );
}
InfcRequest*
infc_request_manager_get_request_by_xml(InfcRequestManager* manager,
                                        const gchar* name,
                                        xmlNodePtr xml,
                                        GError** error)
{
  InfcRequestManagerPrivate* priv;
  InfcRequest* request;
  xmlChar* seq_attr;
  gboolean has_seq;
  guint seq_id;
  guint seq;
  gchar* request_type;
  g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
  g_return_val_if_fail(xml != NULL, NULL);
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  request = NULL;
  seq_attr = inf_xml_util_get_attribute(xml, "seq");
  if(!seq_attr) return NULL;
  has_seq = infc_request_manager_parse_seq(
    (const gchar*)seq_attr,
    &amp;seq_id,
    &amp;seq,
    error
  );
  xmlFree(seq_attr);
  if(!has_seq) return NULL;
  if(seq_id != priv-&gt;seq_id) return NULL;
  request = infc_request_manager_get_request_by_seq(manager, seq);
  if(request == NULL)
  {
    g_set_error(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_INVALID_SEQ,
      _("No such sequence number %u"),
      seq
    );
  }
  else
  {
    g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
    if(name != NULL &amp;&amp; strcmp(name, request_type) != 0)
    {
      g_set_error(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _("The request contains a sequence number referring to a request of "
          "type '%s', but a request of type '%s' was expected"),
        request_type,
        name
      );
      request = NULL;
    }
    g_free(request_type);
  }
  return request;
}
InfcRequest*
infc_request_manager_get_request_by_xml_required(InfcRequestManager* manager,
                                                 const gchar* name,
                                                 xmlNodePtr xml,
                                                 GError** error)
{
  InfcRequest* request;
  GError* own_error;
  own_error = NULL;
  request = infc_request_manager_get_request_by_xml(
    manager,
    name,
    xml,
    &amp;own_error
  );
  if(request == NULL)
  {
    if(own_error == NULL)
    {
      g_set_error_literal(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _("The request does not contain a sequence number, but one "
          "is required")
      );
    }
    else
    {
      g_propagate_error(error, own_error);
    }
  }
  return request;
}
void
infc_request_manager_foreach_request(InfcRequestManager* manager,
                                     InfcRequestManagerForeachFunc func,
                                     gpointer user_data)
{
  InfcRequestManagerPrivate* priv;
  InfcRequestManagerForeachData data;
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(func != NULL);
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  data.func = func;
  data.user_data = user_data;
  data.name = NULL;
  g_hash_table_foreach(
    priv-&gt;requests,
    infc_request_manager_foreach_request_func,
    &amp;data
  );
}
void
infc_request_manager_foreach_named_request(InfcRequestManager* manager,
                                           const gchar* name,
                                           InfcRequestManagerForeachFunc func,
                                           gpointer user_data)
{
  InfcRequestManagerPrivate* priv;
  InfcRequestManagerForeachData data;
  g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
  g_return_if_fail(func != NULL);
  priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
  data.func = func;
  data.user_data = user_data;
  data.name = name;
  g_hash_table_foreach(
    priv-&gt;requests,
    infc_request_manager_foreach_request_func,
    &amp;data
  );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
