<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-session-proxy.c &amp; infc-request-manager.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-session-proxy.c &amp; infc-request-manager.c
      </h3>
<h1 align="center">
        8.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-session-proxy.c (6.2402496%)<th>infc-request-manager.c (12.539185%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(60-101)<td><a href="#" name="0">(56-85)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(971-993)<td><a href="#" name="1">(224-246)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1358-1377)<td><a href="#" name="2">(283-323)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-session-proxy.h&gt;
2 #include &lt;libinfinity/server/infd-request.h&gt;
3 #include &lt;libinfinity/common/inf-session-proxy.h&gt;
4 #include &lt;libinfinity/common/inf-request-result.h&gt;
5 #include &lt;libinfinity/common/inf-io.h&gt;
6 #include &lt;libinfinity/common/inf-xml-util.h&gt;
7 #include &lt;libinfinity/common/inf-error.h&gt;
8 #include &lt;libinfinity/inf-i18n.h&gt;
9 #include &lt;libinfinity/inf-signals.h&gt;
10 #include &lt;string.h&gt;
11 typedef struct _InfdSessionProxySubscription InfdSessionProxySubscription;
12 struct _InfdSessionProxySubscription {
13   InfXmlConnection* connection;
14 <a name="0"></a>  guint seq_id;
15   GSList* users; <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
16 typedef struct _InfdSessionProxyPrivate InfdSessionProxyPrivate;
17 struct _InfdSessionProxyPrivate {
18   InfIo* io;
19   InfSession* session;
20   InfCommunicationHostedGroup* subscription_group;
21   GSList* subscriptions;
22   guint user_id_counter;
23   GSList* local_users;
24   gboolean idle;
25 };
26 enum {
27   PROP_0,
28   PROP_IO,
29   PROP_SESSION,
30   PROP_SUBSCRIPTION_GROUP,
31   PROP_IDLE
32 };
33 enum {
34   ADD_SUBSCRIPTION,
35   REMOVE_SUBSCRIPTION,
36   REJECT_USER_JOIN,
37   LAST_SIGNAL
38 };
39 #define INFD_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_SESSION_PROXY, InfdSessionProxyPrivate))
40 static guint session_proxy_signals[LAST_SIGNAL];
41 static void infd_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);</b></font>
42 static void infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
43 G_DEFINE_TYPE_WITH_CODE(InfdSessionProxy, infd_session_proxy, G_TYPE_OBJECT,
44   G_ADD_PRIVATE(InfdSessionProxy)
45   G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infd_session_proxy_communication_object_iface_init)
46   G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infd_session_proxy_session_proxy_iface_init))
47 static InfdSessionProxySubscription*
48 infd_session_proxy_subscription_new(InfXmlConnection* connection,
49                                     guint seq_id)
50 {
51   InfdSessionProxySubscription* subscription;
52   subscription = g_slice_new(InfdSessionProxySubscription);
53   subscription-&gt;connection = connection;
54   subscription-&gt;seq_id = seq_id;
55   subscription-&gt;users = NULL;
56   g_object_ref(G_OBJECT(connection));
57   return subscription;
58 }
59 static void
60 infd_session_proxy_subscription_free(InfdSessionProxySubscription* subscr)
61 {
62   g_object_unref(G_OBJECT(subscr-&gt;connection));
63   g_slist_free(subscr-&gt;users);
64   g_slice_free(InfdSessionProxySubscription, subscr);
65 }
66 static GSList*
67 infd_session_proxy_find_subscription_item(InfdSessionProxy* proxy,
68                                           InfXmlConnection* connection)
69 {
70   InfdSessionProxyPrivate* priv;
71   GSList* item;
72   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
73   for(item = priv-&gt;subscriptions; item != NULL; item = g_slist_next(item))
74     if( ((InfdSessionProxySubscription*)item-&gt;data)-&gt;connection == connection)
75       return item;
76   return NULL;
77 }
78 static InfdSessionProxySubscription*
79 infd_session_proxy_find_subscription(InfdSessionProxy* proxy,
80                                      InfXmlConnection* connection)
81 {
82   GSList* item;
83   item = infd_session_proxy_find_subscription_item(proxy, connection);
84   if(item == NULL) return NULL;
85   return (InfdSessionProxySubscription*)item-&gt;data;
86 }
87 static gboolean
88 infd_session_proxy_check_idle(InfdSessionProxy* proxy)
89 {
90   InfdSessionProxyPrivate* priv;
91   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
92   if(priv-&gt;subscriptions == NULL &amp;&amp;
93      priv-&gt;local_users == NULL &amp;&amp;
94      !inf_session_has_synchronizations(priv-&gt;session))
95   {
96     return TRUE;
97   }
98   return FALSE;
99 }
100 static void
101 infd_session_proxy_user_notify_status_cb(InfUser* user,
102                                          const GParamSpec* pspec,
103                                          gpointer user_data)
104 {
105   InfdSessionProxy* proxy;
106   InfdSessionProxyPrivate* priv;
107   InfdSessionProxySubscription* subscr;
108   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE)
109   {
110     proxy = INFD_SESSION_PROXY(user_data);
111     priv = INFD_SESSION_PROXY_PRIVATE(proxy);
112     if(inf_user_get_connection(user))
113     {
114       subscr = infd_session_proxy_find_subscription(
115         proxy,
116         inf_user_get_connection(user)
117       );
118       g_assert(subscr != NULL);
119       subscr-&gt;users = g_slist_remove(subscr-&gt;users, user);
120       g_object_set(G_OBJECT(user), "connection", NULL, NULL);
121     }
122     else
123     {
124       priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, user);
125       if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
126       {
127         priv-&gt;idle = TRUE;
128         g_object_notify(G_OBJECT(proxy), "idle");
129       }
130     }
131     inf_signal_handlers_disconnect_by_func(
132       G_OBJECT(user),
133       G_CALLBACK(infd_session_proxy_user_notify_status_cb),
134       proxy
135     );
136   }
137 }
138 static gboolean
139 infd_session_proxy_make_seq(InfdSessionProxy* proxy,
140                             InfXmlConnection* connection,
141                             xmlNodePtr xml,
142                             gchar** seq,
143                             GError** error)
144 {
145   InfdSessionProxyPrivate* priv;
146   InfdSessionProxySubscription* subscription;
147   GError* local_error;
148   guint seq_num;
149   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
150   local_error = NULL;
151   if(!inf_xml_util_get_attribute_uint(xml, "seq", &amp;seq_num, &amp;local_error))
152   {
153     if(local_error)
154     {
155       g_propagate_error(error, local_error);
156       return FALSE;
157     }
158     *seq = NULL;
159     return TRUE;
160   }
161   subscription = infd_session_proxy_find_subscription(proxy, connection);
162   g_assert(subscription != NULL);
163   *seq = g_strdup_printf("%u/%u", subscription-&gt;seq_id, seq_num);
164   return TRUE;
165 }
166 static InfUser*
167 infd_session_proxy_perform_user_join(InfdSessionProxy* proxy,
168                                      InfXmlConnection* connection,
169                                      const gchar* seq,
170                                      GArray* user_props,
171                                      GError** error)
172 {
173   InfSessionClass* session_class;
174   InfdSessionProxyPrivate* priv;
175   InfdSessionProxySubscription* subscription;
176   InfUser* user;
177   const GParameter* name_param;
178   GParameter* param;
179   gboolean result;
180   xmlNodePtr xml;
181   guint i;
182   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
183   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
184   g_assert(session_class-&gt;validate_user_props != NULL);
185   g_assert(session_class-&gt;user_new != NULL);
186   name_param = inf_session_lookup_user_property(
187     (const GParameter*)user_props-&gt;data,
188     user_props-&gt;len,
189     "name"
190   );
191   if(name_param == NULL)
192   {
193     g_set_error_literal(
194       error,
195       inf_request_error_quark(),
196       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
197       _("Request does not contain required attribute \"name\"")
198     );
199     return NULL;
200   }
201   user = inf_user_table_lookup_user_by_name(
202     inf_session_get_user_table(priv-&gt;session),
203     g_value_get_string(&amp;name_param-&gt;value)
204   );
205   if(user != NULL &amp;&amp; inf_user_get_status(user) != INF_USER_UNAVAILABLE)
206   {
207     g_set_error(
208       error,
209       inf_user_error_quark(),
210       INF_USER_ERROR_NAME_IN_USE,
211       _("Name \"%s\" already in use"),
212       g_value_get_string(&amp;name_param-&gt;value)
213     );
214     return NULL;
215   }
216   param = inf_session_get_user_property(user_props, "id");
217   if(G_IS_VALUE(&amp;param-&gt;value))
218   {
219     g_set_error_literal(
220       error,
221       inf_request_error_quark(),
222       INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
223       inf_user_strerror(INF_USER_ERROR_ID_PROVIDED)
224     );
225     return NULL;
226   }
227   g_value_init(&amp;param-&gt;value, G_TYPE_UINT);
228   if(user != NULL)
229     g_value_set_uint(&amp;param-&gt;value, inf_user_get_id(user));
230   else
231     g_value_set_uint(&amp;param-&gt;value, priv-&gt;user_id_counter);
232   param = inf_session_get_user_property(user_props, "status");
233   if(G_IS_VALUE(&amp;param-&gt;value))
234   {
235     if(g_value_get_enum(&amp;param-&gt;value) == INF_USER_UNAVAILABLE)
236     {
237       g_set_error_literal(
238         error,
239         inf_request_error_quark(),
240         INF_REQUEST_ERROR_INVALID_ATTRIBUTE,
241         _("\"status\" attribute is \"unavailable\" in user join request")
242       );
243       return NULL;
244     }
245   }
246   else
247   {
248     g_value_init(&amp;param-&gt;value, INF_TYPE_USER_STATUS);
249     g_value_set_enum(&amp;param-&gt;value, INF_USER_ACTIVE);
250   }
251   param = inf_session_get_user_property(user_props, "flags");
252   g_assert(!G_IS_VALUE(&amp;param-&gt;value));
253   g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
254   if(connection == NULL)
255     g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
256   else
257     g_value_set_flags(&amp;param-&gt;value, 0);
258   param = inf_session_get_user_property(user_props, "connection");
259   g_assert(!G_IS_VALUE(&amp;param-&gt;value));
260   g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
261   g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
262   result = session_class-&gt;validate_user_props(
263     priv-&gt;session,
264     (const GParameter*)user_props-&gt;data,
265     user_props-&gt;len,
266     user,
267     error
268   );
269   if(result == FALSE)
270     return NULL;
271   g_signal_emit(
272     proxy,
273     session_proxy_signals[REJECT_USER_JOIN],
274     0,
275     connection,
276     user_props,
277     user,
278     &amp;result
279   );
280   if(result == TRUE)
281   {
282     g_set_error_literal(
283       error,
284       inf_request_error_quark(),
285       INF_REQUEST_ERROR_NOT_AUTHORIZED,
286       _("Permission denied")
287     );
288     return NULL;
289   }
290   if(user == NULL)
291   {
292     user = inf_session_add_user(
293       priv-&gt;session,
294       (const GParameter*)user_props-&gt;data,
295       user_props-&gt;len
296     );
297     g_assert(user != NULL);
298     xml = xmlNewNode(NULL, (const xmlChar*)"user-join");
299   }
300   else
301   {
302     g_object_freeze_notify(G_OBJECT(user));
303     for(i = 0; i &lt; user_props-&gt;len; ++ i)
304     {
305       param = &amp;g_array_index(user_props, GParameter, i);
306       if(strcmp(param-&gt;name, "name") != 0 &amp;&amp; strcmp(param-&gt;name, "id") != 0)
307         g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
308     }
309     g_object_thaw_notify(G_OBJECT(user));
310     xml = xmlNewNode(NULL, (const xmlChar*)"user-rejoin");
311   }
312   inf_session_user_to_xml(priv-&gt;session, user, xml);
313   if(seq != NULL) inf_xml_util_set_attribute(xml, "seq", seq);
314   g_signal_connect(
315     G_OBJECT(user),
316     "notify::status",
317     G_CALLBACK(infd_session_proxy_user_notify_status_cb),
318     proxy
319   );
320   inf_session_send_to_subscriptions(priv-&gt;session, xml);
321   if(connection != NULL)
322   {
323     subscription = infd_session_proxy_find_subscription(proxy, connection);
324     g_assert(subscription != NULL);
325     subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);
326   }
327   else
328   {
329     priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, user);
330     if(priv-&gt;idle == TRUE)
331     {
332       priv-&gt;idle = FALSE;
333       g_object_notify(G_OBJECT(proxy), "idle");
334     }
335   }
336   return user;
337 }
338 static void
339 infd_session_proxy_member_removed_cb(InfCommunicationGroup* group,
340                                      InfXmlConnection* connection,
341                                      gpointer user_data)
342 {
343   InfdSessionProxy* proxy;
344   InfdSessionProxyPrivate* priv;
345   InfdSessionProxySubscription* subscription;
346   xmlNodePtr xml;
347   GSList* item;
348   InfUser* user;
349   proxy = INFD_SESSION_PROXY(user_data);
350   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
351   subscription = infd_session_proxy_find_subscription(proxy, connection);
352   g_assert(subscription != NULL);
353   for(item = subscription-&gt;users; item != NULL; item = g_slist_next(item))
354   {
355     user = INF_USER(item-&gt;data);
356     xml = xmlNewNode(NULL, (const xmlChar*)"user-status-change");
357     inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(user));
358     inf_xml_util_set_attribute(
359       xml,
360       "status",
361       inf_user_status_to_string(INF_USER_UNAVAILABLE)
362     );
363     inf_session_send_to_subscriptions(priv-&gt;session, xml);
364   }
365   g_signal_emit(
366     proxy,
367     session_proxy_signals[REMOVE_SUBSCRIPTION],
368     0,
369     connection
370   );
371 }
372 static void
373 infd_session_proxy_add_user_cb(InfUserTable* user_table,
374                                InfUser* user,
375                                gpointer user_data)
376 {
377   InfdSessionProxy* proxy;
378   InfdSessionProxyPrivate* priv;
379   InfXmlConnection* sync_conn;
380   InfdSessionProxySubscription* subscription;
381   proxy = INFD_SESSION_PROXY(user_data);
382   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
383   if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
384     priv-&gt;user_id_counter = inf_user_get_id(user) + 1;
385   if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING)
386   {
387     if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
388     {
389       g_object_get(
390         G_OBJECT(priv-&gt;session),
391         "sync-connection",
392         &amp;sync_conn,
393         NULL
394       );
395       g_assert(sync_conn != NULL);
396       subscription = infd_session_proxy_find_subscription(proxy, sync_conn);
397       if(sync_conn != inf_user_get_connection(user) || subscription == NULL)
398       {
399         inf_session_close(priv-&gt;session);
400       }
401       else
402       {
403         subscription-&gt;users = g_slist_prepend(subscription-&gt;users, user);
404         g_signal_connect(
405           G_OBJECT(user),
406           "notify::status",
407           G_CALLBACK(infd_session_proxy_user_notify_status_cb),
408           proxy
409         );
410       }
411       g_object_unref(sync_conn);
412     }
413   }
414 }
415 static void
416 infd_session_proxy_synchronization_begin_cb(InfSession* session,
417                                             InfCommunicationGroup* group,
418                                             InfXmlConnection* connection,
419                                             gpointer user_data)
420 {
421   InfdSessionProxy* proxy;
422   InfdSessionProxyPrivate* priv;
423   proxy = INFD_SESSION_PROXY(user_data);
424   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
425   if(priv-&gt;idle)
426   {
427     priv-&gt;idle = FALSE;
428     g_object_notify(G_OBJECT(proxy), "idle");
429   }
430 }
431 static void
432 infd_session_proxy_synchronization_complete_cb(InfSession* session,
433                                                InfXmlConnection* conn,
434                                                gpointer user_data)
435 {
436   InfdSessionProxy* proxy;
437   InfdSessionProxyPrivate* priv;
438   proxy = INFD_SESSION_PROXY(user_data);
439   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
440   if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
441      priv-&gt;local_users == NULL &amp;&amp;
442      !inf_session_has_synchronizations(session))
443   {
444     priv-&gt;idle = TRUE;
445     g_object_notify(G_OBJECT(proxy), "idle");
446   }
447 }
448 static void
449 infd_session_proxy_synchronization_failed_cb_before(InfSession* session,
450                                                     InfXmlConnection* conn,
451                                                     const GError* error,
452                                                     gpointer user_data)
453 {
454   InfdSessionProxy* proxy;
455   InfdSessionProxyPrivate* priv;
456   InfSessionStatus status;
457   InfdSessionProxySubscription* subscription;
458   proxy = INFD_SESSION_PROXY(user_data);
459   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
460   g_object_get(session, "status", &amp;status, NULL);
461   if(status == INF_SESSION_RUNNING)
462   {
463     subscription = infd_session_proxy_find_subscription(proxy, conn);
464     if(subscription != NULL)
465     {
466       inf_communication_hosted_group_remove_member(
467         priv-&gt;subscription_group,
468         conn
469       );
470     }
471   }
472 }
473 static void
474 infd_session_proxy_synchronization_failed_cb_after(InfSession* session,
475                                                    InfXmlConnection* conn,
476                                                    const GError* error,
477                                                    gpointer user_data)
478 {
479   InfdSessionProxy* proxy;
480   InfdSessionProxyPrivate* priv;
481   proxy = INFD_SESSION_PROXY(user_data);
482   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
483   if(!priv-&gt;idle &amp;&amp; priv-&gt;subscriptions == NULL &amp;&amp;
484      !inf_session_has_synchronizations(session))
485   {
486     priv-&gt;idle = TRUE;
487     g_object_notify(G_OBJECT(proxy), "idle");
488   }
489 }
490 static void
491 infd_session_proxy_session_close_cb(InfSession* session,
492                                     gpointer user_data)
493 {
494   InfdSessionProxy* proxy;
495   InfdSessionProxyPrivate* priv;
496   InfdSessionProxySubscription* subscription;
497   proxy = INFD_SESSION_PROXY(user_data);
498   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
499   inf_signal_handlers_disconnect_by_func(
500     G_OBJECT(priv-&gt;subscription_group),
501     G_CALLBACK(infd_session_proxy_member_removed_cb),
502     proxy
503   );
504   while(priv-&gt;subscriptions != NULL)
505   {
506     subscription = (InfdSessionProxySubscription*)priv-&gt;subscriptions-&gt;data;
507     infd_session_proxy_unsubscribe(proxy, subscription-&gt;connection);
508     g_signal_emit(
509       proxy,
510       session_proxy_signals[REMOVE_SUBSCRIPTION],
511       0,
512       subscription-&gt;connection
513     );
514   }
515   while(priv-&gt;local_users != NULL)
516   {
517     g_object_set(
518       G_OBJECT(priv-&gt;local_users-&gt;data),
519       "status", INF_USER_UNAVAILABLE,
520       NULL
521     );
522   }
523   g_object_unref(priv-&gt;subscription_group);
524   priv-&gt;subscription_group = NULL;
525 }
526 static void
527 infd_session_proxy_init(InfdSessionProxy* session_proxy)
528 {
529   InfdSessionProxyPrivate* priv;
530   priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);
531   priv-&gt;io = NULL;
532   priv-&gt;subscriptions = NULL;
533   priv-&gt;subscription_group = NULL;
534   priv-&gt;user_id_counter = 1;
535   priv-&gt;local_users = NULL;
536   priv-&gt;idle = TRUE;
537 }
538 static void
539 infd_session_proxy_constructed(GObject* object)
540 {
541   InfdSessionProxy* session_proxy;
542   InfdSessionProxyPrivate* priv;
543   session_proxy = INFD_SESSION_PROXY(object);
544   priv = INFD_SESSION_PROXY_PRIVATE(session_proxy);
545   G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;constructed(object);
546   g_assert(priv-&gt;subscription_group != NULL);
547   g_assert(priv-&gt;session != NULL);
548   if(inf_session_get_status(priv-&gt;session) == INF_SESSION_SYNCHRONIZING ||
549      priv-&gt;local_users != NULL)
550   {
551     priv-&gt;idle = FALSE;
552   }
553   inf_session_set_subscription_group(
554     priv-&gt;session,
555     INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
556   );
557 }
558 static void
559 infd_session_proxy_dispose(GObject* object)
560 {
561   InfdSessionProxy* proxy;
562   InfdSessionProxyPrivate* priv;
563   InfCommunicationManager* manager;
564   proxy = INFD_SESSION_PROXY(object);
565   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
566   manager = inf_session_get_communication_manager(priv-&gt;session);
567   g_object_ref(manager);
568   g_slist_free(priv-&gt;local_users);
569   priv-&gt;local_users = NULL;
570   if(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED)
571     inf_session_close(priv-&gt;session);
572   inf_signal_handlers_disconnect_by_func(
573     G_OBJECT(priv-&gt;session),
574     G_CALLBACK(infd_session_proxy_session_close_cb),
575     proxy
576   );
577   inf_signal_handlers_disconnect_by_func(
578     G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
579     G_CALLBACK(infd_session_proxy_add_user_cb),
580     proxy
581   );
582   inf_signal_handlers_disconnect_by_func(
583     G_OBJECT(priv-&gt;session),
584     G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
585     proxy
586   );
587   inf_signal_handlers_disconnect_by_func(
588     G_OBJECT(priv-&gt;session),
589     G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
590     proxy
591   );
592   inf_signal_handlers_disconnect_by_func(
593     G_OBJECT(priv-&gt;session),
594     G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
595     proxy
596   );
597   inf_signal_handlers_disconnect_by_func(
598     G_OBJECT(priv-&gt;session),
599     G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
600     proxy
601   );
602   g_object_unref(priv-&gt;session);
603   priv-&gt;session = NULL;
604   g_assert(priv-&gt;subscription_group == NULL);
605   g_assert(priv-&gt;subscriptions == NULL);
606   g_object_unref(priv-&gt;io);
607   priv-&gt;io = NULL;
608   g_object_unref(manager);
609   G_OBJECT_CLASS(infd_session_proxy_parent_class)-&gt;dispose(object);
610 }
611 static void
612 infd_session_proxy_session_init_user_func(InfUser* user,
613                                           gpointer user_data)
614 {
615   InfdSessionProxy* proxy;
616   InfdSessionProxyPrivate* priv;
617   proxy = INFD_SESSION_PROXY(user_data);
618   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
619   if(priv-&gt;user_id_counter &lt;= inf_user_get_id(user))
620     priv-&gt;user_id_counter = inf_user_get_id(user) + 1;
621 }
622 static void
623 infd_session_proxy_set_property(GObject* object,
624                                 guint prop_id,
625                                 const GValue* value,
626                                 GParamSpec* pspec)
627 {
628   InfdSessionProxy* proxy;
629   InfdSessionProxyPrivate* priv;
630   proxy = INFD_SESSION_PROXY(object);
631   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
632   switch(prop_id)
633   {
634   case PROP_IO:
635     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
636     break;
637   case PROP_SESSION:
638     g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_SESSION(g_value_dup_object(value));
639     inf_user_table_foreach_user(
640       inf_session_get_user_table(priv-&gt;session),
641       infd_session_proxy_session_init_user_func,
642       proxy
643     );
644     g_signal_connect(
645       G_OBJECT(priv-&gt;session),
646       "close",
647       G_CALLBACK(infd_session_proxy_session_close_cb),
648       proxy
649     );
650     g_signal_connect(
651       G_OBJECT(inf_session_get_user_table(priv-&gt;session)),
652       "add-user",
653       G_CALLBACK(infd_session_proxy_add_user_cb),
654       proxy
655     );
656     g_signal_connect_after(
657       G_OBJECT(priv-&gt;session),
658       "synchronization-begin",
659       G_CALLBACK(infd_session_proxy_synchronization_begin_cb),
660       proxy
661     );
662     g_signal_connect_after(
663       G_OBJECT(priv-&gt;session),
664       "synchronization-complete",
665       G_CALLBACK(infd_session_proxy_synchronization_complete_cb),
666       proxy
667     );
668     g_signal_connect(
669       G_OBJECT(priv-&gt;session),
670       "synchronization-failed",
671       G_CALLBACK(infd_session_proxy_synchronization_failed_cb_before),
672       proxy
673     );
674     g_signal_connect_after(
675       G_OBJECT(priv-&gt;session),
676       "synchronization-failed",
677       G_CALLBACK(infd_session_proxy_synchronization_failed_cb_after),
678       proxy
679     );
680     break;
681   case PROP_SUBSCRIPTION_GROUP:
682     g_assert(priv-&gt;subscription_group == NULL);     priv-&gt;subscription_group =
683       INF_COMMUNICATION_HOSTED_GROUP(g_value_dup_object(value));
684     g_signal_connect(
685       G_OBJECT(priv-&gt;subscription_group),
686       "member-removed",
687       G_CALLBACK(infd_session_proxy_member_removed_cb),
688       proxy
689     );
690 <a name="1"></a>    break;
691   case PROP_IDLE:
692 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
693     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
694     break;
695   }
696 }
697 static void
698 infd_session_proxy_get_property(GObject* object,
699                                 guint prop_id,
700                                 GValue* value,
701                                 GParamSpec* pspec)
702 {
703   InfdSessionProxy* proxy;
704   InfdSessionProxyPrivate* priv;
705   proxy = INFD_SESSION_PROXY(object);
706   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
707   switch(prop_id)
708   {
709   case PROP_IO:
710     g_value_set_object(value, priv-&gt;io);
711     break;</b></font>
712   case PROP_SESSION:
713     g_value_set_object(value, priv-&gt;session);
714     break;
715   case PROP_SUBSCRIPTION_GROUP:
716     g_value_set_object(value, priv-&gt;subscription_group);
717     break;
718   case PROP_IDLE:
719     g_value_set_boolean(value, priv-&gt;idle);
720     break;
721   default:
722     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
723     break;
724   }
725 }
726 static void
727 infd_session_proxy_add_subscription(InfdSessionProxy* proxy,
728                                     InfXmlConnection* connection,
729                                     guint seq_id)
730 {
731   InfdSessionProxyPrivate* priv;
732   InfdSessionProxySubscription* subscription;
733   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
734   g_assert(infd_session_proxy_find_subscription(proxy, connection) == NULL);
735   subscription = infd_session_proxy_subscription_new(connection, seq_id);
736   priv-&gt;subscriptions = g_slist_prepend(priv-&gt;subscriptions, subscription);
737   if(priv-&gt;idle == TRUE)
738   {
739     priv-&gt;idle = FALSE;
740     g_object_notify(G_OBJECT(proxy), "idle");
741   }
742 }
743 static void
744 infd_session_proxy_remove_subscription(InfdSessionProxy* proxy,
745                                        InfXmlConnection* connection)
746 {
747   InfdSessionProxyPrivate* priv;
748   InfdSessionProxySubscription* subscr;
749   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
750   subscr = infd_session_proxy_find_subscription(proxy, connection);
751   g_assert(subscr != NULL);
752   while(subscr-&gt;users)
753   {
754     g_object_set(
755       G_OBJECT(subscr-&gt;users-&gt;data),
756       "status", INF_USER_UNAVAILABLE,
757       NULL
758     );
759   }
760   priv-&gt;subscriptions = g_slist_remove(priv-&gt;subscriptions, subscr);
761   infd_session_proxy_subscription_free(subscr);
762   if(priv-&gt;idle == FALSE &amp;&amp; infd_session_proxy_check_idle(proxy) == TRUE)
763   {
764     priv-&gt;idle = TRUE;
765     g_object_notify(G_OBJECT(proxy), "idle");
766   }
767 }
768 static gboolean
769 infd_session_proxy_reject_user_join(InfdSessionProxy* proxy,
770                                     InfXmlConnection* connection,
771                                     const GArray* user_properties,
772                                     InfUser* user_rejoin)
773 {
774   return FALSE;
775 }
776 static gboolean
777 infd_session_proxy_handle_user_join(InfdSessionProxy* proxy,
778                                     InfXmlConnection* connection,
779                                     xmlNodePtr xml,
780                                     GError** error)
781 {
782   InfdSessionProxyPrivate* priv;
783   InfSessionClass* session_class;
784   GArray* array;
785   InfUser* user;
786   gchar* seq;
787   guint i;
788   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
789   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
790   if(!infd_session_proxy_make_seq(proxy, connection, xml, &amp;seq, error))
791     return FALSE;
792   array = session_class-&gt;get_xml_user_props(
793     priv-&gt;session,
794     connection,
795     xml
796   );
797   user = infd_session_proxy_perform_user_join(
798     proxy,
799     connection,
800     seq,
801     array,
802     error
803   );
804   for(i = 0; i &lt; array-&gt;len; ++ i)
805     g_value_unset(&amp;g_array_index(array, GParameter, i).value);
806   g_array_free(array, TRUE);
807   g_free(seq);
808   if(user == NULL)
809     return FALSE;
810   return TRUE;
811 }
812 static gboolean
813 infd_session_proxy_handle_session_unsubscribe(InfdSessionProxy* proxy,
814                                               InfXmlConnection* connection,
815                                               const xmlNodePtr xml,
816                                               GError** error)
817 {
818   InfdSessionProxyPrivate* priv;
819   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
820   g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);
821   inf_communication_hosted_group_remove_member(
822     priv-&gt;subscription_group,
823     connection
824   );
825   return TRUE;
826 }
827 static void
828 infd_session_proxy_communication_object_sent(InfCommunicationObject* object,
829                                              InfXmlConnection* connection,
830                                              xmlNodePtr node)
831 {
832   InfdSessionProxy* proxy;
833   InfdSessionProxyPrivate* priv;
834   proxy = INFD_SESSION_PROXY(object);
835   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
836   g_assert(priv-&gt;session != NULL);
837   inf_communication_object_sent(
838     INF_COMMUNICATION_OBJECT(priv-&gt;session),
839     connection,
840     node
841   );
842 }
843 static void
844 infd_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
845                                                  InfXmlConnection* connection,
846                                                  xmlNodePtr node)
847 {
848   InfdSessionProxy* proxy;
849   InfdSessionProxyPrivate* priv;
850   proxy = INFD_SESSION_PROXY(obj);
851   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
852   g_assert(priv-&gt;session != NULL);
853   inf_communication_object_enqueued(
854     INF_COMMUNICATION_OBJECT(priv-&gt;session),
855     connection,
856     node
857   );
858 }
859 static InfCommunicationScope
860 infd_session_proxy_communication_object_received(InfCommunicationObject* obj,
861                                                  InfXmlConnection* connection,
862                                                  xmlNodePtr node)
863 {
864   InfdSessionProxy* proxy;
865   InfdSessionProxyPrivate* priv;
866   InfSessionSyncStatus status;
867   GError* local_error;
868   xmlNodePtr reply_xml;
869   gchar* seq;
870   proxy = INFD_SESSION_PROXY(obj);
871   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
872   g_assert(priv-&gt;session != NULL);
873   status = inf_session_get_synchronization_status(priv-&gt;session, connection);
874   local_error = NULL;
875   if(status != INF_SESSION_SYNC_NONE)
876   {
877     return inf_communication_object_received(
878       INF_COMMUNICATION_OBJECT(priv-&gt;session),
879       connection,
880       node
881     );
882   }
883   else
884   {
885     if(strcmp((const char*)node-&gt;name, "user-join") == 0)
886     {
887       infd_session_proxy_handle_user_join(
888         proxy,
889         connection,
890         node,
891         &amp;local_error
892       );
893     }
894     else if(strcmp((const char*)node-&gt;name, "session-unsubscribe") == 0)
895     {
896       infd_session_proxy_handle_session_unsubscribe(
897         proxy,
898         connection,
899         node,
900         &amp;local_error
901       );
902     }
903     else
904     {
905       return inf_communication_object_received(
906         INF_COMMUNICATION_OBJECT(priv-&gt;session),
907         connection,
908         node
909       );
910     }
911   }
912   if(local_error != NULL)
913   {
914     if(!infd_session_proxy_make_seq(proxy, connection, node, &amp;seq, NULL))
915       seq = NULL;
916     reply_xml = inf_xml_util_new_node_from_error(local_error,
917                                                  NULL,
918                                                  "request-failed");
919     if(seq != NULL) inf_xml_util_set_attribute(reply_xml, "seq", seq);
920     g_free(seq);
921     inf_communication_group_send_message(
922       INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
923       connection,
924       reply_xml
925     );
926     g_error_free(local_error);
927   }
928   return INF_COMMUNICATION_SCOPE_PTP;
929 }
930 static InfRequest*
931 infd_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
932                                            guint n_params,
933                                            const GParameter* params,
934                                            InfRequestFunc func,
935                                            gpointer user_data)
936 {
937   InfdRequest* request;
938   GArray* array;
939   guint i;
940   GParameter param;
941   GError* error;
942   InfUser* user;
943   g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), NULL);
944   request = g_object_new(
945     INFD_TYPE_REQUEST,
946     "type", "user-join",
947     NULL
948   );
949   if(func != NULL)
950   {
951     g_signal_connect_after(
952       G_OBJECT(request),
953       "finished",
954       G_CALLBACK(func),
955       user_data
956     );
957   }
958   array = g_array_sized_new(
959     FALSE,
960     FALSE,
961     sizeof(GParameter),
962     n_params
963   );
964   g_array_append_vals(array, params, n_params);
965   error = NULL;
966   user = infd_session_proxy_perform_user_join(
967     INFD_SESSION_PROXY(proxy),
968     NULL,
969     NULL,
970     array,
971     &amp;error
972   );
973   for(i = n_params; i &lt; array-&gt;len; ++i)
974     g_value_unset(&amp;g_array_index(array, GParameter, i).value);
975   g_array_free(array, TRUE);
976   if(error != NULL)
977   {
978     inf_request_fail(INF_REQUEST(request), error);
979   }
980   else
981   {
982     inf_request_finish(
983       INF_REQUEST(request),
984       inf_request_result_make_join_user(proxy, user)
985     );
986   }
987 <a name="2"></a>
988   if(error) g_error_free(error);
989   g_object_unref(request);
990 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return NULL;
991 }
992 static void
993 infd_session_proxy_class_init(InfdSessionProxyClass* proxy_class)
994 {
995   GObjectClass* object_class;
996   object_class = G_OBJECT_CLASS(proxy_class);
997   object_class-&gt;constructed = infd_session_proxy_constructed;
998   object_class-&gt;dispose = infd_session_proxy_dispose;
999   object_class-&gt;set_property = infd_session_proxy_set_property;
1000   object_class-&gt;get_property = infd_session_proxy_get_property;
1001   proxy_class-&gt;add_subscription = infd_session_proxy_add_subscription;
1002   proxy_class-&gt;remove_subscription = infd_session_proxy_remove_subscription;</b></font>
1003   proxy_class-&gt;reject_user_join = infd_session_proxy_reject_user_join;
1004   g_object_class_install_property(
1005     object_class,
1006     PROP_IO,
1007     g_param_spec_object(
1008       "io",
1009       "Io",
1010       "The InfIo object for scheduling events",
1011       INF_TYPE_IO,
1012       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1013     )
1014   );
1015   g_object_class_install_property(
1016     object_class,
1017     PROP_SUBSCRIPTION_GROUP,
1018     g_param_spec_object(
1019       "subscription-group",
1020       "Subscription group",
1021       "The communication manager group of subscribed connections",
1022       INF_COMMUNICATION_TYPE_HOSTED_GROUP,
1023       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1024     )
1025   );
1026   g_object_class_install_property(
1027     object_class,
1028     PROP_IDLE,
1029     g_param_spec_boolean(
1030       "idle",
1031       "Idle",
1032       "The session is considered idle when are no subscriptions and no "
1033       "synchronizations",
1034       TRUE,
1035       G_PARAM_READABLE
1036     )
1037   );
1038   g_object_class_override_property(object_class, PROP_SESSION, "session");
1039   session_proxy_signals[ADD_SUBSCRIPTION] = g_signal_new(
1040     "add-subscription",
1041     G_OBJECT_CLASS_TYPE(object_class),
1042     G_SIGNAL_RUN_LAST,
1043     G_STRUCT_OFFSET(InfdSessionProxyClass, add_subscription),
1044     NULL, NULL,
1045     NULL,
1046     G_TYPE_NONE,
1047     2,
1048     INF_TYPE_XML_CONNECTION,
1049     G_TYPE_UINT
1050   );
1051   session_proxy_signals[REMOVE_SUBSCRIPTION] = g_signal_new(
1052     "remove-subscription",
1053     G_OBJECT_CLASS_TYPE(object_class),
1054     G_SIGNAL_RUN_LAST,
1055     G_STRUCT_OFFSET(InfdSessionProxyClass, remove_subscription),
1056     NULL, NULL,
1057     g_cclosure_marshal_VOID__OBJECT,
1058     G_TYPE_NONE,
1059     1,
1060     INF_TYPE_XML_CONNECTION
1061   );
1062   session_proxy_signals[REJECT_USER_JOIN] = g_signal_new(
1063     "reject-user-join",
1064     G_OBJECT_CLASS_TYPE(object_class),
1065     G_SIGNAL_RUN_LAST,
1066     G_STRUCT_OFFSET(InfdSessionProxyClass, reject_user_join),
1067     g_signal_accumulator_true_handled, NULL,
1068     NULL,
1069     G_TYPE_BOOLEAN,
1070     3,
1071     INF_TYPE_XML_CONNECTION,
1072     G_TYPE_ARRAY,
1073     INF_TYPE_USER
1074   );
1075 }
1076 static void
1077 infd_session_proxy_communication_object_iface_init(
1078   InfCommunicationObjectInterface* iface)
1079 {
1080   iface-&gt;sent = infd_session_proxy_communication_object_sent;
1081   iface-&gt;enqueued = infd_session_proxy_communication_object_enqueued;
1082   iface-&gt;received = infd_session_proxy_communication_object_received;
1083 }
1084 static void
1085 infd_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
1086 {
1087   iface-&gt;join_user = infd_session_proxy_session_proxy_join_user;
1088 }
1089 void
1090 infd_session_proxy_subscribe_to(InfdSessionProxy* proxy,
1091                                 InfXmlConnection* connection,
1092                                 guint seq_id,
1093                                 gboolean synchronize)
1094 {
1095   InfdSessionProxyPrivate* priv;
1096   g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
1097   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1098   g_return_if_fail(
1099     infd_session_proxy_find_subscription(proxy, connection) == NULL
1100   );
1101   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
1102   g_return_if_fail(priv-&gt;session != NULL);
1103   g_return_if_fail(
1104     inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING ||
1105     (synchronize == FALSE)
1106   );
1107   inf_communication_hosted_group_add_member(
1108     priv-&gt;subscription_group,
1109     connection
1110   );
1111   g_signal_emit(
1112     G_OBJECT(proxy),
1113     session_proxy_signals[ADD_SUBSCRIPTION],
1114     0,
1115     connection,
1116     seq_id
1117   );
1118   g_assert(infd_session_proxy_find_subscription(proxy, connection) != NULL);
1119   if(synchronize)
1120   {
1121     inf_session_synchronize_to(
1122       priv-&gt;session,
1123       INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
1124       connection
1125     );
1126   }
1127 }
1128 void
1129 infd_session_proxy_unsubscribe(InfdSessionProxy* proxy,
1130                                InfXmlConnection* connection)
1131 {
1132   InfdSessionProxyPrivate* priv;
1133   InfdSessionProxySubscription* subscription;
1134   InfSessionSyncStatus status;
1135   xmlNodePtr xml;
1136   g_return_if_fail(INFD_IS_SESSION_PROXY(proxy));
1137   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1138   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
1139   g_assert(inf_session_get_status(priv-&gt;session) == INF_SESSION_RUNNING);
1140   subscription = infd_session_proxy_find_subscription(proxy, connection);
1141   g_return_if_fail(subscription != NULL);
1142   status = inf_session_get_synchronization_status(
1143     priv-&gt;session,
1144     subscription-&gt;connection
1145   );
1146   if(status != INF_SESSION_SYNC_IN_PROGRESS)
1147   {
1148     xml = xmlNewNode(NULL, (const xmlChar*)"session-close");
1149     inf_communication_group_send_message(
1150       INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
1151       subscription-&gt;connection,
1152       xml
1153     );
1154   }
1155   else
1156   {
1157     inf_session_cancel_synchronization(
1158       priv-&gt;session,
1159       subscription-&gt;connection
1160     );
1161   }
1162   inf_communication_hosted_group_remove_member(
1163     priv-&gt;subscription_group,
1164     subscription-&gt;connection
1165   );
1166 }
1167 gboolean
1168 infd_session_proxy_has_subscriptions(InfdSessionProxy* proxy)
1169 {
1170   InfdSessionProxyPrivate* priv;
1171   g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
1172   priv = INFD_SESSION_PROXY_PRIVATE(proxy);
1173   if(priv-&gt;subscriptions == NULL)
1174     return FALSE;
1175   return TRUE;
1176 }
1177 gboolean
1178 infd_session_proxy_is_subscribed(InfdSessionProxy* proxy,
1179                                  InfXmlConnection* connection)
1180 {
1181   g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
1182   g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), FALSE);
1183   if(infd_session_proxy_find_subscription(proxy, connection) == NULL)
1184     return FALSE;
1185   return TRUE;
1186 }
1187 gboolean
1188 infd_session_proxy_is_idle(InfdSessionProxy* proxy)
1189 {
1190   g_return_val_if_fail(INFD_IS_SESSION_PROXY(proxy), FALSE);
1191   return INFD_SESSION_PROXY_PRIVATE(proxy)-&gt;idle;
1192 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-request-manager.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-request-manager.h&gt;
2 #include &lt;libinfinity/common/inf-request.h&gt;
3 #include &lt;libinfinity/common/inf-xml-util.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;gobject/gvaluecollector.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;errno.h&gt;
9 typedef struct _InfcRequestManagerForeachData InfcRequestManagerForeachData;
10 struct _InfcRequestManagerForeachData {
11 <a name="0"></a>  InfcRequestManagerForeachFunc func;
12   gpointer user_data;
13   const gchar* name;
14 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
15 typedef struct _InfcRequestManagerPrivate InfcRequestManagerPrivate;
16 struct _InfcRequestManagerPrivate {
17   GHashTable* requests;
18   guint seq_id;
19   guint seq_counter;
20 };
21 enum {
22   PROP_0,
23   PROP_SEQUENCE_ID
24 };
25 enum {
26   REQUEST_ADD,
27   REQUEST_REMOVE,
28   LAST_SIGNAL
29 };
30 #define INFC_REQUEST_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_REQUEST_MANAGER, InfcRequestManagerPrivate))
31 static guint request_manager_signals[LAST_SIGNAL];
32 G_DEFINE_TYPE_WITH_CODE(InfcRequestManager, infc_request_manager, G_TYPE_OBJECT,
33   G_ADD_PRIVATE(InfcRequestManager))
34 static void</b></font>
35 infc_request_manager_foreach_request_func(gpointer key,
36                                           gpointer value,
37                                           gpointer user_data)
38 {
39   InfcRequest* request;
40   InfcRequestManagerForeachData* foreach_data;
41   gchar* type;
42   request = INFC_REQUEST(value);
43   foreach_data = (InfcRequestManagerForeachData*)user_data;
44   g_object_get(G_OBJECT(request), "type", &amp;type, NULL);
45   if(foreach_data-&gt;name == NULL || strcmp(foreach_data-&gt;name, type) == 0)
46   {
47     foreach_data-&gt;func(request, foreach_data-&gt;user_data);
48   }
49   g_free(type);
50 }
51 static gboolean
52 infc_request_manager_parse_seq(const gchar* seq,
53                                guint* seq_id,
54                                guint* seq_num,
55                                GError** error)
56 {
57   gchar* endptr;
58   unsigned long sid;
59   unsigned long snum;
60   errno = 0;
61   sid = strtoul(seq, &amp;endptr, 10);
62   if(errno == ERANGE || sid &gt; (unsigned long)G_MAXUINT)
63   {
64     g_set_error_literal(
65       error,
66       inf_request_error_quark(),
67       INF_REQUEST_ERROR_INVALID_SEQ,
68       _("Sequence identifier causes overflow")
69     );
70     return FALSE;
71   }
72   if(*endptr != '/')
73   {
74     g_set_error_literal(
75       error,
76       inf_request_error_quark(),
77       INF_REQUEST_ERROR_INVALID_SEQ,
78       _("Sequence components are not separated by '/'")
79     );
80     return FALSE;
81   }
82   errno = 0;
83   snum = strtoul(endptr + 1, &amp;endptr, 10);
84   if(errno == ERANGE || snum &gt; (unsigned long)G_MAXUINT)
85   {
86     g_set_error_literal(
87       error,
88       inf_request_error_quark(),
89       INF_REQUEST_ERROR_INVALID_SEQ,
90       _("Sequence number causes overflow")
91     );
92     return FALSE;
93   }
94   if(*endptr != '\0')
95   {
96     g_set_error_literal(
97       error,
98       inf_request_error_quark(),
99       INF_REQUEST_ERROR_INVALID_SEQ,
100       _("Trailing characters after sequence number")
101     );
102     return FALSE;
103   }
104   if(seq_id) *seq_id = sid;
105   if(seq_num) *seq_num = snum;
106   return TRUE;
107 }
108 static void
109 infc_request_manager_init(InfcRequestManager* manager)
110 {
111   InfcRequestManagerPrivate* priv;
112   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
113   priv-&gt;requests = g_hash_table_new_full(
114     NULL,
115     NULL,
116     NULL,
117     (GDestroyNotify)g_object_unref
118   );
119   priv-&gt;seq_id = 0;
120   priv-&gt;seq_counter = 0;
121 }
122 static void
123 infc_request_manager_dispose(GObject* object)
124 {
125   InfcRequestManager* request_manager;
126   InfcRequestManagerPrivate* priv;
127   request_manager = INFC_REQUEST_MANAGER(object);
128   priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
129   g_hash_table_destroy(priv-&gt;requests);
130   priv-&gt;requests = NULL;
131   G_OBJECT_CLASS(infc_request_manager_parent_class)-&gt;dispose(object);
132 }
133 static void
134 infc_request_manager_set_property(GObject* object,
135                                   guint prop_id,
136                                   const GValue* value,
137                                   GParamSpec* pspec)
138 {
139   InfcRequestManager* request_manager;
140   InfcRequestManagerPrivate* priv;
141   request_manager = INFC_REQUEST_MANAGER(object);
142   priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
143   switch(prop_id)
144   {
145 <a name="1"></a>  case PROP_SEQUENCE_ID:
146     priv-&gt;seq_id = g_value_get_uint(value);
147     break;
148 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
149     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
150     break;
151   }
152 }
153 static void
154 infc_request_manager_get_property(GObject* object,
155                                   guint prop_id,
156                                   GValue* value,
157                                   GParamSpec* pspec)
158 {
159   InfcRequestManager* request_manager;
160   InfcRequestManagerPrivate* priv;
161   request_manager = INFC_REQUEST_MANAGER(object);
162   priv = INFC_REQUEST_MANAGER_PRIVATE(request_manager);
163   switch(prop_id)
164   {
165   case PROP_SEQUENCE_ID:
166     g_value_set_uint(value, priv-&gt;seq_id);
167     break;</b></font>
168   default:
169     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
170     break;
171   }
172 }
173 static void
174 infc_request_manager_request_add(InfcRequestManager* manager,
175                                  InfcRequest* request)
176 {
177   InfcRequestManagerPrivate* priv;
178   guint seq;
179   gpointer seq_ptr;
180   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
181   g_object_get(G_OBJECT(request), "seq", &amp;seq, NULL);
182   seq_ptr = GUINT_TO_POINTER(seq);
183   g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) == NULL);
184   g_hash_table_insert(priv-&gt;requests, seq_ptr, request);
185   g_object_ref(G_OBJECT(request));
186 }
187 static void
188 infc_request_manager_request_remove(InfcRequestManager* manager,
189                                     InfcRequest* request)
190 {
191   InfcRequestManagerPrivate* priv;
192   guint seq;
193   gpointer seq_ptr;
194   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
195 <a name="2"></a>  g_object_get(G_OBJECT(request), "seq", &amp;seq, NULL);
196   seq_ptr = GUINT_TO_POINTER(seq);
197 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  g_assert(g_hash_table_lookup(priv-&gt;requests, seq_ptr) != NULL);
198   g_hash_table_remove(priv-&gt;requests, seq_ptr);
199 }
200 static void
201 infc_request_manager_class_init(
202   InfcRequestManagerClass* request_manager_class)
203 {
204   GObjectClass* object_class;
205   object_class = G_OBJECT_CLASS(request_manager_class);
206   object_class-&gt;dispose = infc_request_manager_dispose;
207   object_class-&gt;set_property = infc_request_manager_set_property;
208   object_class-&gt;get_property = infc_request_manager_get_property;
209   request_manager_class-&gt;request_add = infc_request_manager_request_add;
210   request_manager_class-&gt;request_remove = infc_request_manager_request_remove;
211   g_object_class_install_property(
212     object_class,
213     PROP_SEQUENCE_ID,
214     g_param_spec_uint(
215       "sequence-id",
216       "Sequence ID",
217       "The local sequence identifier",
218       0,
219       G_MAXUINT,
220       0,
221       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
222     )
223   );
224   request_manager_signals[REQUEST_ADD] = g_signal_new(</b></font>
225     "request-add",
226     G_OBJECT_CLASS_TYPE(object_class),
227     G_SIGNAL_RUN_LAST,
228     G_STRUCT_OFFSET(InfcRequestManagerClass, request_add),
229     NULL, NULL,
230     g_cclosure_marshal_VOID__OBJECT,
231     G_TYPE_NONE,
232     1,
233     INFC_TYPE_REQUEST
234   );
235   request_manager_signals[REQUEST_REMOVE] = g_signal_new(
236     "request-remove",
237     G_OBJECT_CLASS_TYPE(object_class),
238     G_SIGNAL_RUN_LAST,
239     G_STRUCT_OFFSET(InfcRequestManagerClass, request_remove),
240     NULL, NULL,
241     g_cclosure_marshal_VOID__OBJECT,
242     G_TYPE_NONE,
243     1,
244     INFC_TYPE_REQUEST
245   );
246 }
247 InfcRequestManager*
248 infc_request_manager_new(guint seq_id)
249 {
250   GObject* object;
251   object =
252     g_object_new(INFC_TYPE_REQUEST_MANAGER, "sequence-id", seq_id, NULL);
253   return INFC_REQUEST_MANAGER(object);
254 }
255 InfcRequest*
256 infc_request_manager_add_request(InfcRequestManager* manager,
257                                  GType request_type,
258                                  const gchar* request_name,
259                                  GCallback callback,
260                                  gpointer user_data,
261                                  const gchar* first_property_name,
262                                  ...)
263 {
264   InfcRequest* request;
265   va_list arglist;
266   va_start(arglist, first_property_name);
267   request = infc_request_manager_add_request_valist(
268     manager,
269     request_type,
270     request_name,
271     callback,
272     user_data,
273     first_property_name,
274     arglist
275   );
276   va_end(arglist);
277   return request;
278 }
279 InfcRequest*
280 infc_request_manager_add_request_valist(InfcRequestManager* manager,
281                                         GType request_type,
282                                         const gchar* request_name,
283                                         GCallback callback,
284                                         gpointer user_data,
285                                         const gchar* first_property_name,
286                                         va_list arglist)
287 {
288   InfcRequestManagerPrivate* priv;
289   GObjectClass* request_class;
290   InfcRequest* request;
291   GParameter* params;
292   const gchar* prop_name;
293   gsize param_size;
294   gsize param_alloc;
295   guint seq;
296   gchar* error;
297   GParamSpec* pspec;
298   guint i;
299   g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
300   g_return_val_if_fail(request_name != NULL, NULL);
301   request_class = g_type_class_ref(request_type);
302   g_return_val_if_fail(request_class != NULL, NULL);
303   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
304   seq = priv-&gt;seq_counter;
305   g_assert(
306     g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq)) == NULL
307   );
308   param_size = 0;
309   param_alloc = 16;
310   params = g_malloc0(param_alloc * sizeof(GParameter));
311   params[param_size].name = "type";
312   g_value_init(&amp;params[param_size].value, G_TYPE_STRING);
313   g_value_set_static_string(&amp;params[param_size].value, request_name);
314   ++ param_size;
315   params[param_size].name = "seq";
316   g_value_init(&amp;params[param_size].value, G_TYPE_UINT);
317   g_value_set_uint(&amp;params[param_size].value, seq);
318   ++ param_size;
319   prop_name = first_property_name;
320   error = NULL;
321   while(prop_name != NULL)
322   {
323     pspec = g_object_class_find_property(request_class, prop_name);
324     if(pspec == NULL)
325     {
326       g_warning(
327         "%s: object class `%s' has no attribute named `%s'",
328         G_STRFUNC,
329         g_type_name(request_type),
330         prop_name
331       );
332       break;
333     }
334     if(param_size &gt;= param_alloc)
335     {
336       param_alloc += 16;
337       params = g_realloc(params, param_alloc * sizeof(GParameter));
338     }
339     params[param_size].name = prop_name;
340     g_value_init(&amp;params[param_size].value, G_PARAM_SPEC_VALUE_TYPE(pspec));
341     G_VALUE_COLLECT(&amp;params[param_size].value, arglist, 0, &amp;error);
342     if(error != NULL)
343     {
344       g_warning("%s: %s", G_STRFUNC, error);
345       g_value_unset(&amp;params[param_size].value);
346       g_free(error);
347       break;
348     }
349     ++ param_size;
350     prop_name = va_arg(arglist, const gchar*);
351   }
352   if(prop_name == NULL)
353   {
354     request = INFC_REQUEST(g_object_newv(request_type, param_size, params));
355     g_hash_table_insert(priv-&gt;requests, GUINT_TO_POINTER(seq), request);
356     ++ priv-&gt;seq_counter;
357   }
358   else
359   {
360     request = NULL;
361   }
362   for(i = 0; i &lt; param_size; ++ i)
363     g_value_unset(&amp;params[i].value);
364   g_free(params);
365   g_type_class_unref(request_class);
366   if(callback != NULL)
367   {
368     g_signal_connect_after(
369       G_OBJECT(request),
370       "finished",
371       callback,
372       user_data
373     );
374   }
375   return request;
376 }
377 void
378 infc_request_manager_remove_request(InfcRequestManager* manager,
379                                     InfcRequest* request)
380 {
381   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
382   g_return_if_fail(INFC_IS_REQUEST(request));
383   g_object_ref(G_OBJECT(request));
384   g_signal_emit(
385     G_OBJECT(manager),
386     request_manager_signals[REQUEST_REMOVE],
387     0,
388     request
389   );
390   g_object_unref(G_OBJECT(request));
391 }
392 void
393 infc_request_manager_finish_request(InfcRequestManager* manager,
394                                     InfcRequest* request,
395                                     InfRequestResult* result)
396 {
397   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
398   g_return_if_fail(INFC_IS_REQUEST(request));
399   g_return_if_fail(result != NULL);
400   g_object_ref(request);
401   infc_request_manager_remove_request(manager, request);
402   inf_request_finish(INF_REQUEST(request), result);
403   g_object_unref(request);
404 }
405 void
406 infc_request_manager_fail_request(InfcRequestManager* manager,
407                                   InfcRequest* request,
408                                   const GError* error)
409 {
410   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
411   g_return_if_fail(INFC_IS_REQUEST(request));
412   g_return_if_fail(error != NULL);
413   g_object_ref(request);
414   infc_request_manager_remove_request(manager, request);
415   inf_request_fail(INF_REQUEST(request), error);
416   g_object_unref(request);
417 }
418 void
419 infc_request_manager_clear(InfcRequestManager* manager)
420 {
421   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
422   g_hash_table_remove_all(INFC_REQUEST_MANAGER_PRIVATE(manager)-&gt;requests);
423 }
424 InfcRequest*
425 infc_request_manager_get_request_by_seq(InfcRequestManager* manager,
426                                         guint seq)
427 {
428   InfcRequestManagerPrivate* priv;
429   g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
430   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
431   return INFC_REQUEST(
432     g_hash_table_lookup(priv-&gt;requests, GUINT_TO_POINTER(seq))
433   );
434 }
435 InfcRequest*
436 infc_request_manager_get_request_by_xml(InfcRequestManager* manager,
437                                         const gchar* name,
438                                         xmlNodePtr xml,
439                                         GError** error)
440 {
441   InfcRequestManagerPrivate* priv;
442   InfcRequest* request;
443   xmlChar* seq_attr;
444   gboolean has_seq;
445   guint seq_id;
446   guint seq;
447   gchar* request_type;
448   g_return_val_if_fail(INFC_IS_REQUEST_MANAGER(manager), NULL);
449   g_return_val_if_fail(xml != NULL, NULL);
450   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
451   request = NULL;
452   seq_attr = inf_xml_util_get_attribute(xml, "seq");
453   if(!seq_attr) return NULL;
454   has_seq = infc_request_manager_parse_seq(
455     (const gchar*)seq_attr,
456     &amp;seq_id,
457     &amp;seq,
458     error
459   );
460   xmlFree(seq_attr);
461   if(!has_seq) return NULL;
462   if(seq_id != priv-&gt;seq_id) return NULL;
463   request = infc_request_manager_get_request_by_seq(manager, seq);
464   if(request == NULL)
465   {
466     g_set_error(
467       error,
468       inf_request_error_quark(),
469       INF_REQUEST_ERROR_INVALID_SEQ,
470       _("No such sequence number %u"),
471       seq
472     );
473   }
474   else
475   {
476     g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
477     if(name != NULL &amp;&amp; strcmp(name, request_type) != 0)
478     {
479       g_set_error(
480         error,
481         inf_request_error_quark(),
482         INF_REQUEST_ERROR_INVALID_SEQ,
483         _("The request contains a sequence number referring to a request of "
484           "type '%s', but a request of type '%s' was expected"),
485         request_type,
486         name
487       );
488       request = NULL;
489     }
490     g_free(request_type);
491   }
492   return request;
493 }
494 InfcRequest*
495 infc_request_manager_get_request_by_xml_required(InfcRequestManager* manager,
496                                                  const gchar* name,
497                                                  xmlNodePtr xml,
498                                                  GError** error)
499 {
500   InfcRequest* request;
501   GError* own_error;
502   own_error = NULL;
503   request = infc_request_manager_get_request_by_xml(
504     manager,
505     name,
506     xml,
507     &amp;own_error
508   );
509   if(request == NULL)
510   {
511     if(own_error == NULL)
512     {
513       g_set_error_literal(
514         error,
515         inf_request_error_quark(),
516         INF_REQUEST_ERROR_INVALID_SEQ,
517         _("The request does not contain a sequence number, but one "
518           "is required")
519       );
520     }
521     else
522     {
523       g_propagate_error(error, own_error);
524     }
525   }
526   return request;
527 }
528 void
529 infc_request_manager_foreach_request(InfcRequestManager* manager,
530                                      InfcRequestManagerForeachFunc func,
531                                      gpointer user_data)
532 {
533   InfcRequestManagerPrivate* priv;
534   InfcRequestManagerForeachData data;
535   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
536   g_return_if_fail(func != NULL);
537   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
538   data.func = func;
539   data.user_data = user_data;
540   data.name = NULL;
541   g_hash_table_foreach(
542     priv-&gt;requests,
543     infc_request_manager_foreach_request_func,
544     &amp;data
545   );
546 }
547 void
548 infc_request_manager_foreach_named_request(InfcRequestManager* manager,
549                                            const gchar* name,
550                                            InfcRequestManagerForeachFunc func,
551                                            gpointer user_data)
552 {
553   InfcRequestManagerPrivate* priv;
554   InfcRequestManagerForeachData data;
555   g_return_if_fail(INFC_IS_REQUEST_MANAGER(manager));
556   g_return_if_fail(func != NULL);
557   priv = INFC_REQUEST_MANAGER_PRIVATE(manager);
558   data.func = func;
559   data.user_data = user_data;
560   data.name = name;
561   g_hash_table_foreach(
562     priv-&gt;requests,
563     infc_request_manager_foreach_request_func,
564     &amp;data
565   );
566 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
