
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 63, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "bio.h"
7  #include "rio.h"
8  #include <signal.h>
9  #include <fcntl.h>
10  #include <sys/stat.h>
11  #include <sys/types.h>
12  #ifndef _WIN32
13  #include <sys/time.h>
14  #include <sys/resource.h>
15  #include <sys/wait.h>
16  #include <sys/param.h>
17  #else
18  #include "Win32_Interop/Win32_QFork.h"
19  #include <direct.h>
20  #define MAXPATHLEN 1024
21  #endif
22  void aofUpdateCurrentSize(void);
23  void aofClosePipes(void);
24  #define AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    &bsol;* 10 MB per block */
25  typedef struct aofrwblock {
26      PORT_ULONG used, free;
27      char buf[AOF_RW_BUF_BLOCK_SIZE];
28  } aofrwblock;
29  void aofRewriteBufferReset(void) {
30      if (server.aof_rewrite_buf_blocks)
31          listRelease(server.aof_rewrite_buf_blocks);
32      server.aof_rewrite_buf_blocks = listCreate();
33      listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
34  }
35  PORT_ULONG aofRewriteBufferSize(void) {
36      listNode *ln;
37      listIter li;
38      PORT_ULONG size = 0;
39      listRewind(server.aof_rewrite_buf_blocks,&li);
40      while((ln = listNext(&li))) {
41          aofrwblock *block = listNodeValue(ln);
42          size += block->used;
43      }
44      return size;
45  }
46  void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
47      listNode *ln;
48      aofrwblock *block;
49      ssize_t nwritten;
50      UNUSED(el);
51      UNUSED(fd);
52      UNUSED(privdata);
53      UNUSED(mask);
54      while(1) {
55          ln = listFirst(server.aof_rewrite_buf_blocks);
56          block = ln ? ln->value : NULL;
57          if (server.aof_stop_sending_diff || !block) {
58  #ifndef _WIN32
59              aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
60                                AE_WRITABLE);
61  #endif
62              return;
63          }
64          if (block->used > 0) {
65              nwritten = write(server.aof_pipe_write_data_to_child,
66                               block->buf,block->used);
67              if (nwritten <= 0) return;
68              memmove(block->buf,block->buf+nwritten,block->used-nwritten);
69              block->used -= nwritten;
70              block->free += nwritten;
71          }
72          if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
73      }
74  }
75  void aofRewriteBufferAppend(unsigned char *s, PORT_ULONG len) {
76      listNode *ln = listLast(server.aof_rewrite_buf_blocks);
77      aofrwblock *block = ln ? ln->value : NULL;
78      while(len) {
79          if (block) {
80              PORT_ULONG thislen = (block->free < len) ? block->free : len;
81              if (thislen) {  &bsol;* The current block is not already full. */
82                  memcpy(block->buf+block->used, s, thislen);
83                  block->used += thislen;
84                  block->free -= thislen;
85                  s += thislen;
86                  len -= thislen;
87              }
88          }
89          if (len) { &bsol;* First block to allocate, or need another block. */
90              int numblocks;
91              block = zmalloc(sizeof(*block));
92  #ifdef _WIN32
93              if (block) {
94  #endif
95                  block->free = AOF_RW_BUF_BLOCK_SIZE;
96                  block->used = 0;
97  #ifdef _WIN32
98              }
99  #endif
100              listAddNodeTail(server.aof_rewrite_buf_blocks,block);
101              numblocks = (int) listLength(server.aof_rewrite_buf_blocks);         WIN_PORT_FIX &bsol;* cast (int) */
102              if (((numblocks+1) % 10) == 0) {
103                  int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
104                                                           LL_NOTICE;
105                  serverLog(level,"Background AOF buffer size: %Iu MB", WIN_PORT_FIX &bsol;* %lu -> %Iu */
106                      aofRewriteBufferSize()/(1024*1024));
107              }
108          }
109      }
110  #ifndef _WIN32
111      if (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == 0) {
112          aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
113              AE_WRITABLE, aofChildWriteDiffData, NULL);
114      }
115  #endif
116  }
117  ssize_t aofRewriteBufferWrite(int fd) {
118      listNode *ln;
119      listIter li;
120      ssize_t count = 0;
121      listRewind(server.aof_rewrite_buf_blocks,&li);
122      while((ln = listNext(&li))) {
123          aofrwblock *block = listNodeValue(ln);
124          ssize_t nwritten;
125          if (block->used) {
126              nwritten = write(fd,block->buf,block->used);
127              if (nwritten != (ssize_t)block->used) {
128                  if (nwritten == 0) errno = EIO;
129                  return -1;
130              }
131              count += nwritten;
132          }
133      }
134      return count;
135  }
136  int aofFsyncInProgress(void) {
137      return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
138  }
139  void aof_background_fsync(int fd) {
140      bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(PORT_LONG)fd,NULL,NULL);
141  }
142  static void killAppendOnlyChild(void) {
143      POSIX_ONLY(int statloc;)
144      if (server.aof_child_pid == -1) return;
145      serverLog(LL_NOTICE,"Killing running AOF rewrite child: %Id", WIN_PORT_FIX &bsol;* %ld -> %Id */
146          (PORT_LONG) server.aof_child_pid);
147  #ifdef _WIN32
148          AbortForkOperation();
149  #else
150      if (kill(server.aof_child_pid,SIGUSR1) != -1) {
151          while(wait3(&statloc,0,NULL) != server.aof_child_pid);
152      }
153  #endif
154      aofRewriteBufferReset();
155      aofRemoveTempFile(server.aof_child_pid);
156      server.aof_child_pid = -1;
157      server.aof_rewrite_time_start = -1;
158      aofClosePipes();
159  }
160  void stopAppendOnly(void) {
161      serverAssert(server.aof_state != AOF_OFF);
162      flushAppendOnlyFile(1);
163      redis_fsync(server.aof_fd);
164      close(server.aof_fd);
165      server.aof_fd = -1;
166      server.aof_selected_db = -1;
167      server.aof_state = AOF_OFF;
168      killAppendOnlyChild();
169  }
170  int startAppendOnly(void) {
171      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
172      int newfd;
173      newfd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT WIN32_ONLY(|_O_BINARY), IF_WIN32(_S_IREAD|_S_IWRITE, 0644));
174      serverAssert(server.aof_state == AOF_OFF);
175      if (newfd == -1) {
176          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
177          serverLog(LL_WARNING,
178              "Redis needs to enable the AOF but can't open the "
179              "append only file %s (in server root dir %s): %s",
180              server.aof_filename,
181              cwdp ? cwdp : "unknown",
182              IF_WIN32(wsa_strerror(errno), strerror(errno)));
183          return C_ERR;
184      }
185      if (server.rdb_child_pid != -1) {
186          server.aof_rewrite_scheduled = 1;
187          serverLog(LL_WARNING,"AOF was enabled but there is already a child process saving an RDB file on disk. An AOF background was scheduled to start when possible.");
188      } else {
189          if (server.aof_child_pid != -1) {
190              serverLog(LL_WARNING,"AOF was enabled but there is already an AOF rewriting in background. Stopping background AOF and starting a rewrite now.");
191              killAppendOnlyChild();
192          }
193          if (rewriteAppendOnlyFileBackground() == C_ERR) {
194              close(newfd);
195              serverLog(LL_WARNING,"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.");
196              return C_ERR;
197          }
198      }
199      server.aof_state = AOF_WAIT_REWRITE;
200      server.aof_last_fsync = server.unixtime;
201      server.aof_fd = newfd;
202      return C_OK;
203  }
204  ssize_t aofWrite(int fd, const char *buf, size_t len) {
205      ssize_t nwritten = 0, totwritten = 0;
206      while(len) {
207          nwritten = write(fd, buf, len);
208          if (nwritten < 0) {
209              if (errno == EINTR) {
210                  continue;
211              }
212              return totwritten ? totwritten : -1;
213          }
214          len -= nwritten;
215          buf += nwritten;
216          totwritten += nwritten;
217      }
218      return totwritten;
219  }
220  #define AOF_WRITE_LOG_ERROR_RATE 30 &bsol;* Seconds between errors logging. */
221  void flushAppendOnlyFile(int force) {
222      ssize_t nwritten;
223      int sync_in_progress = 0;
224      mstime_t latency;
225      if (sdslen(server.aof_buf) == 0) {
226          if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
227              server.aof_fsync_offset != server.aof_current_size &&
228              server.unixtime > server.aof_last_fsync &&
229              !(sync_in_progress = aofFsyncInProgress())) {
230              goto try_fsync;
231          } else {
232              return;
233          }
234      }
235      if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
236          sync_in_progress = aofFsyncInProgress();
237      if (server.aof_fsync == AOF_FSYNC_EVERYSEC && !force) {
238          if (sync_in_progress) {
239              if (server.aof_flush_postponed_start == 0) {
240                  server.aof_flush_postponed_start = server.unixtime;
241                  return;
242              } else if (server.unixtime - server.aof_flush_postponed_start < 2) {
243                  return;
244              }
245              server.aof_delayed_fsync++;
246              serverLog(LL_NOTICE,"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.");
247          }
248      }
249      latencyStartMonitor(latency);
250      nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));
251      latencyEndMonitor(latency);
252      if (sync_in_progress) {
253          latencyAddSampleIfNeeded("aof-write-pending-fsync",latency);
254      } else if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
255          latencyAddSampleIfNeeded("aof-write-active-child",latency);
256      } else {
257          latencyAddSampleIfNeeded("aof-write-alone",latency);
258      }
259      latencyAddSampleIfNeeded("aof-write",latency);
260      server.aof_flush_postponed_start = 0;
261      if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
262          static time_t last_write_error_log = 0;
263          int can_log = 0;
264          if ((server.unixtime - last_write_error_log) > AOF_WRITE_LOG_ERROR_RATE) {
265              can_log = 1;
266              last_write_error_log = server.unixtime;
267          }
268          if (nwritten == -1) {
269              if (can_log) {
270                  serverLog(LL_WARNING,"Error writing to the AOF file: %s",
271                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
272                  server.aof_last_write_errno = errno;
273              }
274          } else {
275              if (can_log) {
276                  serverLog(LL_WARNING,"Short write while writing to "
277                                         "the AOF file: (nwritten=%lld, "
278                                         "expected=%lld)",
279                                         (PORT_LONGLONG)nwritten,
280                                         (PORT_LONGLONG)sdslen(server.aof_buf));
281              }
282              if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
283                  if (can_log) {
284                      serverLog(LL_WARNING, "Could not remove short write "
285                               "from the append-only file.  Redis may refuse "
286                               "to load the AOF the next time it starts.  "
287                               "ftruncate: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
288                  }
289              } else {
290                  nwritten = -1;
291              }
292              server.aof_last_write_errno = ENOSPC;
293          }
294          if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
295              serverLog(LL_WARNING,"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...");
296              exit(1);
297          } else {
298              server.aof_last_write_status = C_ERR;
299              if (nwritten > 0) {
300                  server.aof_current_size += nwritten;
301                  sdsrange(server.aof_buf,(int)nwritten,-1);                      WIN_PORT_FIX &bsol;* cast (int) */
302              }
303              return; &bsol;* We'll try again on the next call... */
304          }
305      } else {
306          if (server.aof_last_write_status == C_ERR) {
307              serverLog(LL_WARNING,
308                  "AOF write error looks solved, Redis can write again.");
309              server.aof_last_write_status = C_OK;
310          }
311      }
312      server.aof_current_size += nwritten;
313      if ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) < 4000) {
314          sdsclear(server.aof_buf);
315      } else {
316          sdsfree(server.aof_buf);
317          server.aof_buf = sdsempty();
318      }
319  try_fsync:
320      if (server.aof_no_fsync_on_rewrite &&
321          (server.aof_child_pid != -1 || server.rdb_child_pid != -1))
322              return;
323      if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
324          latencyStartMonitor(latency);
325          redis_fsync(server.aof_fd); &bsol;* Let's try to get this data on the disk */
326          latencyEndMonitor(latency);
327          latencyAddSampleIfNeeded("aof-fsync-always",latency);
328          server.aof_fsync_offset = server.aof_current_size;
329          server.aof_last_fsync = server.unixtime;
330      } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &&
331                  server.unixtime > server.aof_last_fsync)) {
332          if (!sync_in_progress) {
333              aof_background_fsync(server.aof_fd);
334              server.aof_fsync_offset = server.aof_current_size;
335          }
336          server.aof_last_fsync = server.unixtime;
337      }
338  }
339  sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
340      char buf[32];
341      int len, j;
342      robj *o;
343      buf[0] = '*';
344      len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
345      buf[len++] = '\r';
346      buf[len++] = '\n';
347      dst = sdscatlen(dst,buf,len);
348      for (j = 0; j < argc; j++) {
349          o = getDecodedObject(argv[j]);
350          buf[0] = '$';
351          len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
352          buf[len++] = '\r';
353          buf[len++] = '\n';
354          dst = sdscatlen(dst,buf,len);
355          dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
356          dst = sdscatlen(dst,"\r\n",2);
357          decrRefCount(o);
358      }
359      return dst;
360  }
361  sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {
362      PORT_LONGLONG when;
363      robj *argv[3];
364      seconds = getDecodedObject(seconds);
365      when = strtoll(seconds->ptr,NULL,10);
366      if (cmd->proc == expireCommand || cmd->proc == setexCommand ||
367          cmd->proc == expireatCommand)
368      {
369          when *= 1000;
370      }
371      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
372          cmd->proc == setexCommand || cmd->proc == psetexCommand)
373      {
374          when += mstime();
375      }
376      decrRefCount(seconds);
377      argv[0] = createStringObject("PEXPIREAT",9);
378      argv[1] = key;
379      argv[2] = createStringObjectFromLongLong(when);
380      buf = catAppendOnlyGenericCommand(buf, 3, argv);
381      decrRefCount(argv[0]);
382      decrRefCount(argv[2]);
383      return buf;
384  }
385  void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
386      sds buf = sdsempty();
387      robj *tmpargv[3];
388      if (dictid != server.aof_selected_db) {
389          char seldb[64];
390          snprintf(seldb,sizeof(seldb),"%d",dictid);
391          WIN32_ONLY(seldb[sizeof(seldb)-1] = 0;) &bsol;*get rid of C6053 warning*/
392          buf = sdscatprintf(buf,"*2\r\n$6\r\nSELECT\r\n$%Iu\r\n%s\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
393              (PORT_ULONG)strlen(seldb),seldb);
394          server.aof_selected_db = dictid;
395      }
396      if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
397          cmd->proc == expireatCommand) {
398          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
399      } else if (cmd->proc == setexCommand || cmd->proc == psetexCommand) {
400          tmpargv[0] = createStringObject("SET",3);
401          tmpargv[1] = argv[1];
402          tmpargv[2] = argv[3];
403          buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
404          decrRefCount(tmpargv[0]);
405          buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
406      } else if (cmd->proc == setCommand && argc > 3) {
407          int i;
408          robj *exarg = NULL, *pxarg = NULL;
409          buf = catAppendOnlyGenericCommand(buf,3,argv);
410          for (i = 3; i < argc; i ++) {
411              if (!strcasecmp(argv[i]->ptr, "ex")) exarg = argv[i+1];
412              if (!strcasecmp(argv[i]->ptr, "px")) pxarg = argv[i+1];
413          }
414          serverAssert(!(exarg && pxarg));
415          if (exarg)
416              buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
417                                                 exarg);
418          if (pxarg)
419              buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
420                                                 pxarg);
421      } else {
422          buf = catAppendOnlyGenericCommand(buf,argc,argv);
423      }
424      if (server.aof_state == AOF_ON)
425          server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
426      if (server.aof_child_pid != -1)
427          aofRewriteBufferAppend((unsigned char*)buf,(PORT_ULONG)sdslen(buf));    WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
428      sdsfree(buf);
429  }
430  struct client *createFakeClient(void) {
431      struct client *c = zmalloc(sizeof(*c));
432      selectDb(c,0);
433      c->fd = -1;
434      c->name = NULL;
435      c->querybuf = sdsempty();
436      c->querybuf_peak = 0;
437      c->argc = 0;
438      c->argv = NULL;
439      c->bufpos = 0;
440      c->flags = 0;
441      c->btype = BLOCKED_NONE;
442      c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
443      c->reply = listCreate();
444      c->reply_bytes = 0;
445      c->obuf_soft_limit_reached_time = 0;
446      c->watched_keys = listCreate();
447      c->peerid = NULL;
448      listSetFreeMethod(c->reply,freeClientReplyValue);
449      listSetDupMethod(c->reply,dupClientReplyValue);
450      initClientMultiState(c);
451      return c;
452  }
453  void freeFakeClientArgv(struct client *c) {
454      int j;
455      for (j = 0; j < c->argc; j++)
456          decrRefCount(c->argv[j]);
457      zfree(c->argv);
458  }
459  void freeFakeClient(struct client *c) {
460      sdsfree(c->querybuf);
461      listRelease(c->reply);
462      listRelease(c->watched_keys);
463      freeClientMultiState(c);
464      zfree(c);
465  }
466  int loadAppendOnlyFile(char *filename) {
467      struct client *fakeClient;
468      FILE *fp = fopen(filename, IF_WIN32("rb", "r"));
469      struct redis_stat sb;
470      int old_aof_state = server.aof_state;
471      PORT_LONG loops = 0;
472      off_t valid_up_to = 0; &bsol;* Offset of latest well-formed command loaded. */
473      off_t valid_before_multi = 0; &bsol;* Offset before MULTI command loaded. */
474      if (fp == NULL) {
475          serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
476          exit(1);
477      }
478      if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
479          server.aof_current_size = 0;
480          server.aof_fsync_offset = server.aof_current_size;
481          fclose(fp);
482          return C_ERR;
483      }
484      server.aof_state = AOF_OFF;
485      fakeClient = createFakeClient();
486      startLoading(fp);
487      char sig[5]; &bsol;* "REDIS" */
488      if (fread(sig,1,5,fp) != 5 || memcmp(sig,"REDIS",5) != 0) {
489          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
490      } else {
491          rio rdb;
492          serverLog(LL_NOTICE,"Reading RDB preamble from AOF file...");
493          if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
494          rioInitWithFile(&rdb,fp);
495          if (rdbLoadRio(&rdb,NULL,1) != C_OK) {
496              serverLog(LL_WARNING,"Error reading the RDB preamble of the AOF file, AOF loading aborted");
497              goto readerr;
498          } else {
499              serverLog(LL_NOTICE,"Reading the remaining AOF tail...");
500          }
501      }
502      while(1) {
503          int argc, j;
504          PORT_ULONG len;
505          robj **argv;
506          char buf[128];
507          sds argsds;
508          struct redisCommand *cmd;
509          if (!(loops++ % 1000)) {
510              loadingProgress((off_t) ftello(fp));                                 WIN_PORT_FIX &bsol;* cast (off_t) */
511              processEventsWhileBlocked();
512          }
513          if (fgets(buf,sizeof(buf),fp) == NULL) {
514              if (feof(fp))
515                  break;
516              else
517                  goto readerr;
518          }
519          if (buf[0] != '*') goto fmterr;
520          if (buf[1] == '\0') goto readerr;
521          argc = atoi(buf+1);
522          if (argc < 1) goto fmterr;
523          argv = zmalloc(sizeof(robj*)*argc);
524          fakeClient->argc = argc;
525          fakeClient->argv = argv;
526          for (j = 0; j < argc; j++) {
527              char *readres = fgets(buf,sizeof(buf),fp);
528              if (readres == NULL || buf[0] != '$') {
529                  fakeClient->argc = j; &bsol;* Free up to j-1. */
530                  freeFakeClientArgv(fakeClient);
531                  if (readres == NULL)
532                      goto readerr;
533                  else
534                      goto fmterr;
535              }
536              len = strtol(buf+1,NULL,10);
537              argsds = sdsnewlen(SDS_NOINIT,len);
538              if (len && fread(argsds,len,1,fp) == 0) {
539                  sdsfree(argsds);
540                  fakeClient->argc = j; &bsol;* Free up to j-1. */
541                  freeFakeClientArgv(fakeClient);
542                  goto readerr;
543              }
544              argv[j] = createObject(OBJ_STRING,argsds);
545              if (fread(buf,2,1,fp) == 0) {
546                  fakeClient->argc = j+1; &bsol;* Free up to j. */
547                  freeFakeClientArgv(fakeClient);
548                  goto readerr;
549              }
550          }
551          cmd = lookupCommand(argv[0]->ptr);
552          if (!cmd) {
553              serverLog(LL_WARNING,
554                  "Unknown command '%s' reading the append only file",
555                  (char*)argv[0]->ptr);
556              exit(1);
557          }
558          if (cmd == server.multiCommand) valid_before_multi = valid_up_to;
559          fakeClient->cmd = cmd;
560          if (fakeClient->flags & CLIENT_MULTI &&
561              fakeClient->cmd->proc != execCommand)
562          {
563              queueMultiCommand(fakeClient);
564          } else {
565              cmd->proc(fakeClient);
566          }
567          serverAssert(fakeClient->bufpos == 0 &&
568                       listLength(fakeClient->reply) == 0);
569          serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);
570          freeFakeClientArgv(fakeClient);
571          fakeClient->cmd = NULL;
572          if (server.aof_load_truncated) valid_up_to = ftello(fp);
573      }
574      if (fakeClient->flags & CLIENT_MULTI) {
575          serverLog(LL_WARNING,
576              "Revert incomplete MULTI/EXEC transaction in AOF file");
577          valid_up_to = valid_before_multi;
578          goto uxeof;
579      }
580  loaded_ok: &bsol;* DB loaded, cleanup and return C_OK to the caller. */
581      fclose(fp);
582      freeFakeClient(fakeClient);
583      server.aof_state = old_aof_state;
584      stopLoading();
585      aofUpdateCurrentSize();
586      server.aof_rewrite_base_size = server.aof_current_size;
587      server.aof_fsync_offset = server.aof_current_size;
588      return C_OK;
589  readerr: &bsol;* Read error. If feof(fp) is true, fall through to unexpected EOF. */
590      if (!feof(fp)) {
591          if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
592          serverLog(LL_WARNING,"Unrecoverable error reading the append only file: %s", strerror(errno));
593          exit(1);
594      }
595  uxeof: &bsol;* Unexpected AOF end of file. */
596      if (server.aof_load_truncated) {
597          serverLog(LL_WARNING,"!!! Warning: short read while loading the AOF file !!!");
598          serverLog(LL_WARNING,"!!! Truncating the AOF at offset %llu !!!",
599              (PORT_ULONGLONG) valid_up_to);
600          if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
601              if (valid_up_to == -1) {
602                  serverLog(LL_WARNING,"Last valid command offset is invalid");
603              } else {
604                  serverLog(LL_WARNING,"Error truncating the AOF file: %s",
605                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
606              }
607          } else {
608              if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {
609                  serverLog(LL_WARNING,"Can't seek the end of the AOF file: %s",
610                      IF_WIN32(wsa_strerror(errno), strerror(errno)));
611              } else {
612                  serverLog(LL_WARNING,
613                      "AOF loaded anyway because aof-load-truncated is enabled");
614                  goto loaded_ok;
615              }
616          }
617      }
618      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
619      serverLog(LL_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
620      exit(1);
621  fmterr: &bsol;* Format error. */
622      if (fakeClient) freeFakeClient(fakeClient); &bsol;* avoid valgrind warning */
623      serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
624      exit(1);
625  }
626  int rioWriteBulkObject(rio *r, robj *obj) {
627      if (obj->encoding == OBJ_ENCODING_INT) {
628          return (int)rioWriteBulkLongLong(r,(PORT_LONG)obj->ptr);               WIN_PORT_FIX &bsol;* cast (int) */
629      } else if (sdsEncodedObject(obj)) {
630          return (int)rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));           WIN_PORT_FIX &bsol;* cast (int) */
631      } else {
632          serverPanic("Unknown string encoding");
633      }
634  }
635  int rewriteListObject(rio *r, robj *key, robj *o) {
636      PORT_LONGLONG count = 0, items = listTypeLength(o);
637      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
638          quicklist *list = o->ptr;
639          quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);
640          quicklistEntry entry;
641          while (quicklistNext(li,&entry)) {
642              if (count == 0) {
643                  PORT_LONGLONG cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?  WIN_PORT_FIX &bsol;* int -> PORT_LONGLONG */
644                      AOF_REWRITE_ITEMS_PER_CMD : items;
645                  if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
646                  if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
647                  if (rioWriteBulkObject(r,key) == 0) return 0;
648              }
649              if (entry.value) {
650                  if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
651              } else {
652                  if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
653              }
654              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
655              items--;
656          }
657          quicklistReleaseIterator(li);
658      } else {
659          serverPanic("Unknown list encoding");
660      }
661      return 1;
662  }
663  int rewriteSetObject(rio *r, robj *key, robj *o) {
664      PORT_LONGLONG count = 0, items = setTypeSize(o);
665      if (o->encoding == OBJ_ENCODING_INTSET) {
666          int ii = 0;
667          int64_t llval;
668          while(intsetGet(o->ptr,ii++,&llval)) {
669              if (count == 0) {
670                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
671                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
672                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
673                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
674                  if (rioWriteBulkObject(r,key) == 0) return 0;
675              }
676              if (rioWriteBulkLongLong(r,llval) == 0) return 0;
677              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
678              items--;
679          }
680      } else if (o->encoding == OBJ_ENCODING_HT) {
681          dictIterator *di = dictGetIterator(o->ptr);
682          dictEntry *de;
683          while((de = dictNext(di)) != NULL) {
684              sds ele = dictGetKey(de);
685              if (count == 0) {
686                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
687                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
688                  if (rioWriteBulkCount(r,'*',(PORT_LONG)2+cmd_items) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
689                  if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
690                  if (rioWriteBulkObject(r,key) == 0) return 0;
691              }
692              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
693              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
694              items--;
695          }
696          dictReleaseIterator(di);
697      } else {
698          serverPanic("Unknown set encoding");
699      }
700      return 1;
701  }
702  int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
703      PORT_LONGLONG count = 0, items = zsetLength(o);
704      if (o->encoding == OBJ_ENCODING_ZIPLIST) {
705          unsigned char *zl = o->ptr;
706          unsigned char *eptr, *sptr;
707          unsigned char *vstr;
708          unsigned int vlen;
709          PORT_LONGLONG vll;
710          double score;
<span onclick='openModal()' class='match'>711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
</span>719                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
720                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
721                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
722                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
723                  if (rioWriteBulkObject(r,key) == 0) return 0;
724              }
725              if (rioWriteBulkDouble(r,score) == 0) return 0;
726              if (vstr != NULL) {
727                  if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
728              } else {
729                  if (rioWriteBulkLongLong(r,vll) == 0) return 0;
730              }
731              zzlNext(zl,&eptr,&sptr);
732              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
733              items--;
734          }
735      } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
736          zset *zs = o->ptr;
737          dictIterator *di = dictGetIterator(zs->dict);
738          dictEntry *de;
739          while((de = dictNext(di)) != NULL) {
740              sds ele = dictGetKey(de);
741              double *score = dictGetVal(de);
742              if (count == 0) {
743                  int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
744                      AOF_REWRITE_ITEMS_PER_CMD : (int)items;               WIN_PORT_FIX &bsol;* cast (int) */
745                  if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
746                  if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
747                  if (rioWriteBulkObject(r,key) == 0) return 0;
748              }
749              if (rioWriteBulkDouble(r,*score) == 0) return 0;
750              if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
751              if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
752              items--;
753          }
754          dictReleaseIterator(di);
755      } else {
756          serverPanic("Unknown sorted zset encoding");
757      }
758      return 1;
759  }
760  static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
761      if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
762          unsigned char *vstr = NULL;
763          unsigned int vlen = UINT_MAX;
764          PORT_LONGLONG vll = LLONG_MAX;
765          hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
766          if (vstr)
767              return (int)rioWriteBulkString(r, (char*)vstr, vlen);       WIN_PORT_FIX &bsol;* cast (int) */
768          else
769              return (int)rioWriteBulkLongLong(r, vll);                   WIN_PORT_FIX &bsol;* cast (int) */
770      } else if (hi->encoding == OBJ_ENCODING_HT) {
771          sds value = hashTypeCurrentFromHashTable(hi, what);
772          return (int)rioWriteBulkString(r, value, sdslen(value));        WIN_PORT_FIX &bsol;* cast (int) */
773      }
774      serverPanic("Unknown hash encoding");
775      return 0;
776  }
777  int rewriteHashObject(rio *r, robj *key, robj *o) {
778      hashTypeIterator *hi;
779      PORT_LONGLONG count = 0, items = hashTypeLength(o);
780      hi = hashTypeInitIterator(o);
781      while (hashTypeNext(hi) != C_ERR) {
782          if (count == 0) {
783              int cmd_items = (int) ((items > AOF_REWRITE_ITEMS_PER_CMD) ? WIN_PORT_FIX &bsol;* cast (int) */
784                  AOF_REWRITE_ITEMS_PER_CMD : items);
785              if (rioWriteBulkCount(r,'*',2+((PORT_LONG)cmd_items)*2) == 0) return 0;  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
786              if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
787              if (rioWriteBulkObject(r,key) == 0) return 0;
788          }
789          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
790          if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
791          if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
792          items--;
793      }
794      hashTypeReleaseIterator(hi);
795      return 1;
796  }
797  int rioWriteBulkStreamID(rio *r,streamID *id) {
798      int retval;
799      sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
800      retval = rioWriteBulkString(r,replyid,sdslen(replyid));
801      sdsfree(replyid);
802      return retval;
803  }
804  int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
805      streamID id;
806      streamDecodeID(rawid,&id);
807      if (rioWriteBulkCount(r,'*',12) == 0) return 0;
808      if (rioWriteBulkString(r,"XCLAIM",6) == 0) return 0;
809      if (rioWriteBulkObject(r,key) == 0) return 0;
810      if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
811      if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
812      if (rioWriteBulkString(r,"0",1) == 0) return 0;
813      if (rioWriteBulkStreamID(r,&id) == 0) return 0;
814      if (rioWriteBulkString(r,"TIME",4) == 0) return 0;
815      if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
816      if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
817      if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) return 0;
818      if (rioWriteBulkString(r,"JUSTID",6) == 0) return 0;
819      if (rioWriteBulkString(r,"FORCE",5) == 0) return 0;
820      return 1;
821  }
822  int rewriteStreamObject(rio *r, robj *key, robj *o) {
823      stream *s = o->ptr;
824      streamIterator si;
825      streamIteratorStart(&si,s,NULL,NULL,0);
826      streamID id;
827      int64_t numfields;
828      if (s->length) {
829          while(streamIteratorGetID(&si,&id,&numfields)) {
830              if (rioWriteBulkCount(r,'*',3+numfields*2) == 0) return 0;
831              if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
832              if (rioWriteBulkObject(r,key) == 0) return 0;
833              if (rioWriteBulkStreamID(r,&id) == 0) return 0;
834              while(numfields--) {
835                  unsigned char *field, *value;
836                  int64_t field_len, value_len;
837                  streamIteratorGetField(&si,&field,&value,&field_len,&value_len);
838                  if (rioWriteBulkString(r,(char*)field,field_len) == 0) return 0;
839                  if (rioWriteBulkString(r,(char*)value,value_len) == 0) return 0;
840              }
841          }
842      } else {
843          if (rioWriteBulkCount(r,'*',7) == 0) return 0;
844          if (rioWriteBulkString(r,"XADD",4) == 0) return 0;
845          if (rioWriteBulkObject(r,key) == 0) return 0;
846          if (rioWriteBulkString(r,"MAXLEN",6) == 0) return 0;
847          if (rioWriteBulkString(r,"0",1) == 0) return 0;
848          if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
849          if (rioWriteBulkString(r,"x",1) == 0) return 0;
850          if (rioWriteBulkString(r,"y",1) == 0) return 0;
851      }
852      if (rioWriteBulkCount(r,'*',3) == 0) return 0;
853      if (rioWriteBulkString(r,"XSETID",6) == 0) return 0;
854      if (rioWriteBulkObject(r,key) == 0) return 0;
855      if (rioWriteBulkStreamID(r,&s->last_id) == 0) return 0;
856      if (s->cgroups) {
857          raxIterator ri;
858          raxStart(&ri,s->cgroups);
859          raxSeek(&ri,"^",NULL,0);
860          while(raxNext(&ri)) {
861              streamCG *group = ri.data;
862              if (rioWriteBulkCount(r,'*',5) == 0) return 0;
863              if (rioWriteBulkString(r,"XGROUP",6) == 0) return 0;
864              if (rioWriteBulkString(r,"CREATE",6) == 0) return 0;
865              if (rioWriteBulkObject(r,key) == 0) return 0;
866              if (rioWriteBulkString(r,(char*)ri.key,ri.key_len) == 0) return 0;
867              if (rioWriteBulkStreamID(r,&group->last_id) == 0) return 0;
868              raxIterator ri_cons;
869              raxStart(&ri_cons,group->consumers);
870              raxSeek(&ri_cons,"^",NULL,0);
871              while(raxNext(&ri_cons)) {
872                  streamConsumer *consumer = ri_cons.data;
873                  raxIterator ri_pel;
874                  raxStart(&ri_pel,consumer->pel);
875                  raxSeek(&ri_pel,"^",NULL,0);
876                  while(raxNext(&ri_pel)) {
877                      streamNACK *nack = ri_pel.data;
878                      if (rioWriteStreamPendingEntry(r,key,(char*)ri.key,
879                                                     ri.key_len,consumer,
880                                                     ri_pel.key,nack) == 0)
881                      {
882                          return 0;
883                      }
884                  }
885                  raxStop(&ri_pel);
886              }
887              raxStop(&ri_cons);
888          }
889          raxStop(&ri);
890      }
891      streamIteratorStop(&si);
892      return 1;
893  }
894  int rewriteModuleObject(rio *r, robj *key, robj *o) {
895      RedisModuleIO io;
896      moduleValue *mv = o->ptr;
897      moduleType *mt = mv->type;
898      moduleInitIOContext(io,mt,r,key);
899      mt->aof_rewrite(&io,key,mv->value);
900      if (io.ctx) {
901          moduleFreeContext(io.ctx);
902          zfree(io.ctx);
903      }
904      return io.error ? 0 : 1;
905  }
906  ssize_t aofReadDiffFromParent(void) {
907  #ifndef _WIN32
908      char buf[65536]; &bsol;* Default pipe buffer size on most Linux systems. */
909  #else
910      char* buf = zmalloc(65536); 
911  #endif
912      ssize_t nread, total = 0;
913      while ((nread =
914              read(server.aof_pipe_read_data_from_parent,buf,IF_WIN32(65536,sizeof(buf)))) > 0) {
915          server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
916          total += nread;
917      }
918  #ifdef _WIN32
919      zfree(buf);
920  #endif
921      return total;
922  }
923  int rewriteAppendOnlyFileRio(rio *aof) {
924      dictIterator *di = NULL;
925      dictEntry *de;
926      size_t processed = 0;
927      int j;
928      for (j = 0; j < server.dbnum; j++) {
929          char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
930          redisDb *db = server.db+j;
931          dict *d = db->dict;
932          if (dictSize(d) == 0) continue;
933          di = dictGetSafeIterator(d);
934          if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
935          if (rioWriteBulkLongLong(aof,j) == 0) goto werr;
936          while((de = dictNext(di)) != NULL) {
937              sds keystr;
938              robj key, *o;
939              PORT_LONGLONG expiretime;
940              keystr = dictGetKey(de);
941              o = dictGetVal(de);
942              initStaticStringObject(key,keystr);
943              expiretime = getExpire(db,&key);
944              if (o->type == OBJ_STRING) {
945                  char cmd[]="*3\r\n$3\r\nSET\r\n";
946                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
947                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
948                  if (rioWriteBulkObject(aof,o) == 0) goto werr;
949              } else if (o->type == OBJ_LIST) {
950                  if (rewriteListObject(aof,&key,o) == 0) goto werr;
951              } else if (o->type == OBJ_SET) {
952                  if (rewriteSetObject(aof,&key,o) == 0) goto werr;
953              } else if (o->type == OBJ_ZSET) {
954                  if (rewriteSortedSetObject(aof,&key,o) == 0) goto werr;
955              } else if (o->type == OBJ_HASH) {
956                  if (rewriteHashObject(aof,&key,o) == 0) goto werr;
957              } else if (o->type == OBJ_STREAM) {
958                  if (rewriteStreamObject(aof,&key,o) == 0) goto werr;
959              } else if (o->type == OBJ_MODULE) {
960                  if (rewriteModuleObject(aof,&key,o) == 0) goto werr;
961              } else {
962                  serverPanic("Unknown object type");
963              }
964              if (expiretime != -1) {
965                  char cmd[]="*3\r\n$9\r\nPEXPIREAT\r\n";
966                  if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
967                  if (rioWriteBulkObject(aof,&key) == 0) goto werr;
968                  if (rioWriteBulkLongLong(aof,expiretime) == 0) goto werr;
969              }
970              if (aof->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES) {
971                  processed = aof->processed_bytes;
972                  aofReadDiffFromParent();
973              }
974          }
975          dictReleaseIterator(di);
976          di = NULL;
977      }
978      return C_OK;
979  werr:
980      if (di) dictReleaseIterator(di);
981      return C_ERR;
982  }
983  int rewriteAppendOnlyFile(char *filename) {
984      rio aof;
985      FILE *fp;
986      char tmpfile[256];
987      char byte;
988      snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
989      fp = fopen(tmpfile, IF_WIN32("wb", "w"));
990      if (!fp) {
991          serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
992          return C_ERR;
993      }
994      server.aof_child_diff = sdsempty();
995      rioInitWithFile(&aof,fp);
996      if (server.aof_rewrite_incremental_fsync)
997          rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
998      if (server.aof_use_rdb_preamble) {
999          int error;
1000          if (rdbSaveRio(&aof,&error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
1001              errno = error;
1002              goto werr;
1003          }
1004      } else {
1005          if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto werr;
1006      }
1007      if (fflush(fp) == EOF) goto werr;
1008      if (fsync(fileno(fp)) == -1) goto werr;
1009      int nodata = 0;
1010      mstime_t start = mstime();
1011      while(mstime()-start < 1000 && nodata < 20) {
1012          if (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, 1) <= 0)
1013          {
1014              nodata++;
1015              continue;
1016          }
1017          nodata = 0; &bsol;* Start counting from zero, we stop on N *contiguous*
1018                         timeouts. */
1019          aofReadDiffFromParent();
1020      }
1021      if (write(server.aof_pipe_write_ack_to_parent,"!",1) != 1) goto werr;
1022  #ifndef _WIN32
1023      if (anetNonBlock(NULL,server.aof_pipe_read_ack_from_parent) != ANET_OK)
1024          goto werr;
1025  #endif
1026      if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||
1027          byte != '!') goto werr;
1028      serverLog(LL_NOTICE,"Parent agreed to stop sending diffs. Finalizing AOF...");
1029      aofReadDiffFromParent();
1030      serverLog(LL_NOTICE,
1031          "Concatenating %.2f MB of AOF diff received from parent.",
1032          (double) (sdslen(server.aof_child_diff) / (1024*1024)));  WIN_PORT_FIX
1033      if (rioWrite(&aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
1034          goto werr;
1035      if (fflush(fp) == EOF) goto werr;
1036      if (fsync(fileno(fp)) == -1) goto werr;
1037      if (fclose(fp) == EOF) goto werr;
1038      if (rename(tmpfile,filename) == -1) {
1039          serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1040          unlink(tmpfile);
1041          return C_ERR;
1042      }
1043      serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
1044      return C_OK;
1045  werr:
1046      serverLog(LL_WARNING,"Write error writing append only file on disk: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1047      fclose(fp);
1048      unlink(tmpfile);
1049      return C_ERR;
1050  }
1051  void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1052      char byte;
1053      UNUSED(el);
1054      UNUSED(privdata);
1055      UNUSED(mask);
1056      if (read(fd,&byte,1) == 1 && byte == '!') {
1057          serverLog(LL_NOTICE,"AOF rewrite child asks to stop sending diffs.");
1058          server.aof_stop_sending_diff = 1;
1059          if (write(server.aof_pipe_write_ack_to_child,"!",1) != 1) {
1060              serverLog(LL_WARNING,"Can't send ACK to AOF child: %s",
1061                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1062          }
1063      }
1064  #ifndef _WIN32
1065      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1066  #endif
1067  }
1068  int aofCreatePipes(void) {
1069      int fds[6] = {-1, -1, -1, -1, -1, -1};
1070      int j;
1071      if (pipe(fds) == -1) goto error; &bsol;* parent -> children data. */
1072      if (pipe(fds+2) == -1) goto error; &bsol;* children -> parent ack. */
1073      if (pipe(fds+4) == -1) goto error; &bsol;* parent -> children ack. */
1074  #ifndef WIN32
1075      if (anetNonBlock(NULL,fds[0]) != ANET_OK) goto error;
1076      if (anetNonBlock(NULL,fds[1]) != ANET_OK) goto error;
1077      if (aeCreateFileEvent(server.el, fds[2], AE_READABLE, aofChildPipeReadable, NULL) == AE_ERR) goto error;
1078  #else
1079      if (FDAPI_PipeSetNonBlock(fds[0], 1) != 0) goto error;
1080      if (FDAPI_PipeSetNonBlock(fds[1], 1) != 0) goto error;
1081      if (FDAPI_PipeSetNonBlock(fds[2], 1) != 0) goto error;
1082  #endif
1083      server.aof_pipe_write_data_to_child = fds[1];
1084      server.aof_pipe_read_data_from_parent = fds[0];
1085      server.aof_pipe_write_ack_to_parent = fds[3];
1086      server.aof_pipe_read_ack_from_child = fds[2];
1087      server.aof_pipe_write_ack_to_child = fds[5];
1088      server.aof_pipe_read_ack_from_parent = fds[4];
1089      server.aof_stop_sending_diff = 0;
1090      return C_OK;
1091  error:
1092      serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
1093          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1094      for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
1095      return C_ERR;
1096  }
1097  void aofClosePipes(void) {
1098      aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
1099      aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
1100      close(server.aof_pipe_write_data_to_child);
1101      close(server.aof_pipe_read_data_from_parent);
1102      close(server.aof_pipe_write_ack_to_parent);
1103      close(server.aof_pipe_read_ack_from_child);
1104      close(server.aof_pipe_write_ack_to_child);
1105      close(server.aof_pipe_read_ack_from_parent);
1106  }
1107  int rewriteAppendOnlyFileBackground(void) {
1108      pid_t childpid;
1109      PORT_LONGLONG start;
1110      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1111      if (aofCreatePipes() != C_OK) return C_ERR;
1112      openChildInfoPipe();
1113      start = ustime();
1114  #ifndef _WIN32
1115      if ((childpid = fork()) == 0) {
1116  #endif
1117          char tmpfile[256];
1118  #ifndef _WIN32
1119          closeListeningSockets(0);
1120          redisSetProcTitle("redis-aof-rewrite");
1121  #endif
1122          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
1123  #ifdef _WIN32
1124          childpid = BeginForkOperation_Aof(server.aof_pipe_write_ack_to_parent,
1125              server.aof_pipe_read_ack_from_parent,
1126              server.aof_pipe_read_data_from_parent,
1127              tmpfile,
1128              &server,
1129              sizeof(server),
1130              dictGetHashFunctionSeed(),
1131              modules);
1132  #else
1133          if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
1134              size_t private_dirty = zmalloc_get_private_dirty(-1);
1135              if (private_dirty) {
1136                  serverLog(LL_NOTICE,
1137                      "AOF rewrite: %Iu MB of memory used by copy-on-write", WIN_PORT_FIX &bsol;* %zu -> %Iu */
1138                      private_dirty/(1024*1024));
1139              }
1140              server.child_info_data.cow_size = private_dirty;
1141              sendChildInfo(CHILD_INFO_TYPE_AOF);
1142              exitFromChild(0);
1143          } else {
1144              exitFromChild(1);
1145          }
1146      } else {
1147  #endif
1148          server.stat_fork_time = ustime()-start;
1149  #ifdef _WIN32
1150          if (server.stat_fork_time == 0) {
1151              server.stat_fork_time = 100000; 
1152          }
1153  #endif
1154          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1155          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1156          if (childpid == -1) {
1157              closeChildInfoPipe();
1158              serverLog(LL_WARNING,
1159                  "Can't rewrite append only file in background: fork: %s",
1160                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1161              aofClosePipes();
1162              return C_ERR;
1163          }
1164          serverLog(LL_NOTICE,
1165              "Background append only file rewriting started by pid %d",childpid);
1166          server.aof_rewrite_scheduled = 0;
1167          server.aof_rewrite_time_start = time(NULL);
1168          server.aof_child_pid = childpid;
1169          updateDictResizePolicy();
1170          server.aof_selected_db = -1;
1171          replicationScriptCacheFlush();
1172          return C_OK;
1173  #ifndef _WIN32
1174      }
1175  #endif
1176      return C_OK; &bsol;* unreached */
1177  }
1178  void bgrewriteaofCommand(client *c) {
1179      if (server.aof_child_pid != -1) {
1180          addReplyError(c,"Background append only file rewriting already in progress");
1181      } else if (server.rdb_child_pid != -1) {
1182          server.aof_rewrite_scheduled = 1;
1183          addReplyStatus(c,"Background append only file rewriting scheduled");
1184      } else if (rewriteAppendOnlyFileBackground() == C_OK) {
1185          addReplyStatus(c,"Background append only file rewriting started");
1186      } else {
1187          addReply(c,shared.err);
1188      }
1189  }
1190  void aofRemoveTempFile(pid_t childpid) {
1191      char tmpfile[256];
1192      snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) childpid);
1193      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1194      unlink(tmpfile);
1195  }
1196  void aofUpdateCurrentSize(void) {
1197      struct redis_stat sb;
1198      mstime_t latency;
1199  #ifdef _WIN32
1200      if (server.aof_fd == -1) {
1201          serverLog(LL_NOTICE, "Unable to check the AOF length: %s", "appendfd is -1");
1202          return;
1203      }
1204  #endif
1205      latencyStartMonitor(latency);
1206      if (redis_fstat(server.aof_fd,&sb) == -1) {
1207          serverLog(LL_WARNING,"Unable to obtain the AOF file length. stat: %s",
1208              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1209      } else {
1210          server.aof_current_size = sb.st_size;
1211      }
1212      latencyEndMonitor(latency);
1213      latencyAddSampleIfNeeded("aof-fstat",latency);
1214  }
1215  void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
1216      if (!bysignal && exitcode == 0) {
1217          int newfd, oldfd;
1218          char tmpfile[256];
1219          PORT_LONGLONG now = ustime();
1220          mstime_t latency;
1221          serverLog(LL_NOTICE,
1222              "Background AOF rewrite terminated with success");
1223          latencyStartMonitor(latency);
1224  #ifdef _WIN32
1225          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1226              getpid());
1227          newfd = open(tmpfile,O_WRONLY|O_APPEND|O_CREAT|_O_BINARY,_S_IREAD|_S_IWRITE);
1228  #else
1229          snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
1230              (int)server.aof_child_pid);
1231          newfd = open(tmpfile,O_WRONLY|O_APPEND);
1232  #endif
1233          if (newfd == -1) {
1234              serverLog(LL_WARNING,
1235                  "Unable to open the temporary AOF produced by the child: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1236              goto cleanup;
1237          }
1238          if (aofRewriteBufferWrite(newfd) == -1) {
1239              serverLog(LL_WARNING,
1240                  "Error trying to flush the parent diff to the rewritten AOF: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1241              close(newfd);
1242              goto cleanup;
1243          }
1244          latencyEndMonitor(latency);
1245          latencyAddSampleIfNeeded("aof-rewrite-diff-write",latency);
1246          serverLog(LL_NOTICE,
1247              "Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)", (double) (aofRewriteBufferSize() / (1024*1024)));  WIN_PORT_FIX
1248  #ifdef _WIN32
1249          oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1250          char tmpfile_win_old[256];
1251          snprintf(tmpfile_win_old, 256, "temp-rewriteaof-old-%d.aof",
1252              (int) server.aof_child_pid);
1253          if (server.aof_fd != -1) {
1254              close(server.aof_fd);
1255              if (rename(server.aof_filename, tmpfile_win_old) == -1) {
1256                  serverLog(LL_WARNING,
1257                      "Error trying to rename the existing AOF to old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1258                  unlink(tmpfile_win_old);
1259                  goto cleanup;
1260              }
1261          }
1262          latencyStartMonitor(latency);
1263          close(newfd);
1264          if (rename(tmpfile, server.aof_filename) == -1) {
1265              serverLog(LL_WARNING,
1266                  "Error trying to rename the temporary AOF file %s into %s: %s",
1267                  tmpfile,
1268                  server.aof_filename,
1269                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1270              if (server.aof_fd != -1) {
1271                  if (rename(tmpfile_win_old, server.aof_filename) == -1) {
1272                      serverLog(LL_WARNING,
1273                          "Error trying to rename the old tempfile %s into the existing AOF file %s: %s",
1274                          tmpfile,
1275                          server.aof_filename,
1276                          IF_WIN32(wsa_strerror(errno), strerror(errno)));
1277                      serverLog(LL_WARNING,
1278                          "Error trying to rename the existing AOF from old tempfile: %s", IF_WIN32(wsa_strerror(errno), strerror(errno)));
1279                  }
1280              }
1281              goto cleanup;
1282          }
1283          newfd = open(server.aof_filename, O_WRONLY | O_APPEND | _O_BINARY, 0);
1284          if (newfd == -1) {
1285              serverLog(LL_WARNING, "Not able to reopen the temporary AOF file after rename");
1286              goto cleanup;
1287          }
1288          if (server.aof_fd != -1) {
1289              server.aof_fd = open(
1290                  tmpfile_win_old,
1291                  O_WRONLY | O_APPEND | O_CREAT | _O_BINARY | _O_TEMPORARY,     
1292                  0644);
1293          }
1294  #else
1295          if (server.aof_fd == -1) {
1296              oldfd = open(server.aof_filename,O_RDONLY|O_NONBLOCK);
1297          } else {
1298              oldfd = -1; &bsol;* We'll set this to the current AOF filedes later. */
1299          }
1300          latencyStartMonitor(latency);
1301          if (rename(tmpfile,server.aof_filename) == -1) {
1302              serverLog(LL_WARNING,
1303                  "Error trying to rename the temporary AOF file %s into %s: %s",
1304                  tmpfile,
1305                  server.aof_filename,
1306                  strerror(errno));
1307              close(newfd);
1308              if (oldfd != -1) close(oldfd);
1309              goto cleanup;
1310          }
1311  #endif
1312          latencyEndMonitor(latency);
1313          latencyAddSampleIfNeeded("aof-rename",latency);
1314          if (server.aof_fd == -1) {
1315              close(newfd);
1316          } else {
1317              oldfd = server.aof_fd;
1318              server.aof_fd = newfd;
1319              if (server.aof_fsync == AOF_FSYNC_ALWAYS)
1320                  redis_fsync(newfd);
1321              else if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
1322                  aof_background_fsync(newfd);
1323              server.aof_selected_db = -1; &bsol;* Make sure SELECT is re-issued */
1324              aofUpdateCurrentSize();
1325              server.aof_rewrite_base_size = server.aof_current_size;
1326              server.aof_fsync_offset = server.aof_current_size;
1327              sdsfree(server.aof_buf);
1328              server.aof_buf = sdsempty();
1329          }
1330          server.aof_lastbgrewrite_status = C_OK;
1331          serverLog(LL_NOTICE, "Background AOF rewrite finished successfully");
1332          if (server.aof_state == AOF_WAIT_REWRITE)
1333              server.aof_state = AOF_ON;
1334          if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
1335          serverLog(LL_VERBOSE,
1336              "Background AOF rewrite signal handler took %lldus", ustime()-now);
1337      } else if (!bysignal && exitcode != 0) {
1338          server.aof_lastbgrewrite_status = C_ERR;
1339          serverLog(LL_WARNING,
1340              "Background AOF rewrite terminated with error");
1341      } else {
1342          if (bysignal != SIGUSR1)
1343              server.aof_lastbgrewrite_status = C_ERR;
1344          serverLog(LL_WARNING,
1345              "Background AOF rewrite terminated by signal %d", bysignal);
1346      }
1347  cleanup:
1348      aofClosePipes();
1349      aofRewriteBufferReset();
1350      aofRemoveTempFile(IF_WIN32(getpid(), server.aof_child_pid));
1351      server.aof_child_pid = -1;
1352      server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
1353      server.aof_rewrite_time_start = -1;
1354      if (server.aof_state == AOF_WAIT_REWRITE)
1355          server.aof_rewrite_scheduled = 1;
1356  }
1357  #ifdef _WIN32
1358  void aofProcessDiffRewriteEvents(aeEventLoop* eventLoop)
1359  {
1360      if (server.aof_child_pid != -1 && server.aof_pipe_read_ack_from_child != -1) {
1361          if (server.aof_stop_sending_diff == 0) {
1362              aofChildWriteDiffData(eventLoop,server.aof_pipe_write_data_to_child,NULL,0);
1363          }
1364          if (server.aof_stop_sending_diff == 0) {
1365              aofChildPipeReadable(eventLoop,server.aof_pipe_read_ack_from_child,NULL,0);
1366          }
1367      }
1368  }
1369  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-debug.c</h3>
            <pre><code>1  #include "server.h"
2  #include "sha1.h"   &bsol;* SHA1 is used for DEBUG DIGEST */
3  #include "crc64.h"
4  #ifndef _WIN32
5  #include <arpa/inet.h>
6  #include <dlfcn.h>
7  #else
8  #include "Win32_Interop/Win32_Portability.h"
9  #include "Win32_Interop/dlfcn.h"
10  #endif
11  #include <signal.h>
12  #ifdef HAVE_BACKTRACE
13  #include <execinfo.h>
14  #ifndef __OpenBSD__
15  #include <ucontext.h>
16  #else
17  typedef ucontext_t sigcontext_t;
18  #endif
19  #include <fcntl.h>
20  #include "bio.h"
21  #include <unistd.h>
22  #endif &bsol;* HAVE_BACKTRACE */
23  #ifdef __CYGWIN__
24  #ifndef SA_ONSTACK
25  #define SA_ONSTACK 0x08000000
26  #endif
27  #endif
28  void xorDigest(unsigned char *digest, void *ptr, size_t len) {
29      SHA1_CTX ctx;
30      unsigned char hash[20], *s = ptr;
31      int j;
32      SHA1Init(&ctx);
33      SHA1Update(&ctx,s,(u_int32_t)len);                                          WIN_PORT_FIX &bsol;* cast (u_int32_t) */
34      SHA1Final(hash,&ctx);
35      for (j = 0; j < 20; j++)
36          digest[j] ^= hash[j];
37  }
38  void xorStringObjectDigest(unsigned char *digest, robj *o) {
39      o = getDecodedObject(o);
40      xorDigest(digest,o->ptr,sdslen(o->ptr));
41      decrRefCount(o);
42  }
43  void mixDigest(unsigned char *digest, void *ptr, size_t len) {
44      SHA1_CTX ctx;
45      char *s = ptr;
46      xorDigest(digest,s,len);
47      SHA1Init(&ctx);
48      SHA1Update(&ctx,digest,20);
49      SHA1Final(digest,&ctx);
50  }
51  void mixStringObjectDigest(unsigned char *digest, robj *o) {
52      o = getDecodedObject(o);
53      mixDigest(digest,o->ptr,sdslen(o->ptr));
54      decrRefCount(o);
55  }
56  void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
57      uint32_t aux = htonl(o->type);
58      mixDigest(digest,&aux,sizeof(aux));
59      PORT_LONGLONG expiretime = getExpire(db,keyobj);
60      char buf[128];
61      if (o->type == OBJ_STRING) {
62          mixStringObjectDigest(digest,o);
63      } else if (o->type == OBJ_LIST) {
64          listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
65          listTypeEntry entry;
66          while(listTypeNext(li,&entry)) {
67              robj *eleobj = listTypeGet(&entry);
68              mixStringObjectDigest(digest,eleobj);
69              decrRefCount(eleobj);
70          }
71          listTypeReleaseIterator(li);
72      } else if (o->type == OBJ_SET) {
73          setTypeIterator *si = setTypeInitIterator(o);
74          sds sdsele;
75          while((sdsele = setTypeNextObject(si)) != NULL) {
76              xorDigest(digest,sdsele,sdslen(sdsele));
77              sdsfree(sdsele);
78          }
79          setTypeReleaseIterator(si);
80      } else if (o->type == OBJ_ZSET) {
81          unsigned char eledigest[20];
82          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
83              unsigned char *zl = o->ptr;
84              unsigned char *eptr, *sptr;
85              unsigned char *vstr;
86              unsigned int vlen;
87              PORT_LONGLONG vll;
88              double score;
<span onclick='openModal()' class='match'>89              eptr = ziplistIndex(zl,0);
90              serverAssert(eptr != NULL);
91              sptr = ziplistNext(zl,eptr);
92              serverAssert(sptr != NULL);
93              while (eptr != NULL) {
94                  serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
95                  score = zzlGetScore(sptr);
96                  memset(eledigest,0,20);
</span>97                  if (vstr != NULL) {
98                      mixDigest(eledigest,vstr,vlen);
99                  } else {
100                      ll2string(buf,sizeof(buf),vll);
101                      mixDigest(eledigest,buf,strlen(buf));
102                  }
103                  snprintf(buf,sizeof(buf),"%.17g",score);
104                  mixDigest(eledigest,buf,strlen(buf));
105                  xorDigest(digest,eledigest,20);
106                  zzlNext(zl,&eptr,&sptr);
107              }
108          } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
109              zset *zs = o->ptr;
110              dictIterator *di = dictGetIterator(zs->dict);
111              dictEntry *de;
112              while((de = dictNext(di)) != NULL) {
113                  sds sdsele = dictGetKey(de);
114                  double *score = dictGetVal(de);
115                  snprintf(buf,sizeof(buf),"%.17g",*score);
116                  memset(eledigest,0,20);
117                  mixDigest(eledigest,sdsele,sdslen(sdsele));
118                  mixDigest(eledigest,buf,strlen(buf));
119                  xorDigest(digest,eledigest,20);
120              }
121              dictReleaseIterator(di);
122          } else {
123              serverPanic("Unknown sorted set encoding");
124          }
125      } else if (o->type == OBJ_HASH) {
126          hashTypeIterator *hi = hashTypeInitIterator(o);
127          while (hashTypeNext(hi) != C_ERR) {
128              unsigned char eledigest[20];
129              sds sdsele;
130              memset(eledigest,0,20);
131              sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
132              mixDigest(eledigest,sdsele,sdslen(sdsele));
133              sdsfree(sdsele);
134              sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
135              mixDigest(eledigest,sdsele,sdslen(sdsele));
136              sdsfree(sdsele);
137              xorDigest(digest,eledigest,20);
138          }
139          hashTypeReleaseIterator(hi);
140      } else if (o->type == OBJ_STREAM) {
141          streamIterator si;
142          streamIteratorStart(&si,o->ptr,NULL,NULL,0);
143          streamID id;
144          int64_t numfields;
145          while(streamIteratorGetID(&si,&id,&numfields)) {
146              sds itemid = sdscatfmt(sdsempty(),"%U.%U",id.ms,id.seq);
147              mixDigest(digest,itemid,sdslen(itemid));
148              sdsfree(itemid);
149              while(numfields--) {
150                  unsigned char *field, *value;
151                  int64_t field_len, value_len;
152                  streamIteratorGetField(&si,&field,&value,
153                                             &field_len,&value_len);
154                  mixDigest(digest,field,field_len);
155                  mixDigest(digest,value,value_len);
156              }
157          }
158          streamIteratorStop(&si);
159      } else if (o->type == OBJ_MODULE) {
160          RedisModuleDigest md;
161          moduleValue *mv = o->ptr;
162          moduleType *mt = mv->type;
163          moduleInitDigestContext(md);
164          if (mt->digest) {
165              mt->digest(&md,mv->value);
166              xorDigest(digest,md.x,sizeof(md.x));
167          }
168      } else {
169          serverPanic("Unknown object type");
170      }
171      if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
172  }
173  void computeDatasetDigest(unsigned char *final) {
174      unsigned char digest[20];
175      dictIterator *di = NULL;
176      dictEntry *de;
177      int j;
178      uint32_t aux;
179      memset(final,0,20); &bsol;* Start with a clean result */
180      for (j = 0; j < server.dbnum; j++) {
181          redisDb *db = server.db+j;
182          if (dictSize(db->dict) == 0) continue;
183          di = dictGetSafeIterator(db->dict);
184          aux = htonl(j);
185          mixDigest(final,&aux,sizeof(aux));
186          while((de = dictNext(di)) != NULL) {
187              sds key;
188              robj *keyobj, *o;
189              memset(digest,0,20); &bsol;* This key-val digest */
190              key = dictGetKey(de);
191              keyobj = createStringObject(key,sdslen(key));
192              mixDigest(digest,key,sdslen(key));
193              o = dictGetVal(de);
194              xorObjectDigest(db,keyobj,digest,o);
195              xorDigest(final,digest,20);
196              decrRefCount(keyobj);
197          }
198          dictReleaseIterator(di);
199      }
200  }
201  void debugCommand(client *c) {
202      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
203          const char *help[] = {
204  "ASSERT -- Crash by assertion failed.",
205  "CHANGE-REPL-ID -- Change the replication IDs of the instance. Dangerous, should be used only for testing the replication subsystem.",
206  "CRASH-AND-RECOVER <milliseconds> -- Hard crash and restart after <milliseconds> delay.",
207  "DIGEST -- Output a hex signature representing the current DB content.",
208  "DIGEST-VALUE <key-1> ... <key-N>-- Output a hex signature of the values of all the specified keys.",
209  "ERROR <string> -- Return a Redis protocol error with <string> as message. Useful for clients unit tests to simulate Redis errors.",
210  "LOG <message> -- write message to the server log.",
211  "HTSTATS <dbid> -- Return hash table statistics of the specified Redis database.",
212  "HTSTATS-KEY <key> -- Like htstats but for the hash table stored as key's value.",
213  "LOADAOF -- Flush the AOF buffers on disk and reload the AOF in memory.",
214  "LUA-ALWAYS-REPLICATE-COMMANDS <0|1> -- Setting it to 1 makes Lua replication defaulting to replicating single commands, without the script having to enable effects replication.",
215  "OBJECT <key> -- Show low level info about key and associated value.",
216  "PANIC -- Crash the server simulating a panic.",
217  "POPULATE <count> [prefix] [size] -- Create <count> string keys named key:<num>. If a prefix is specified is used instead of the 'key' prefix.",
218  "RELOAD -- Save the RDB on disk and reload it back in memory.",
219  "RESTART -- Graceful restart: save config, db, restart.",
220  "SDSLEN <key> -- Show low level SDS string info representing key and value.",
221  "SEGFAULT -- Crash the server with sigsegv.",
222  "SET-ACTIVE-EXPIRE <0|1> -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.",
223  "SLEEP <seconds> -- Stop the server for <seconds>. Decimals allowed.",
224  "STRUCTSIZE -- Return the size of different Redis core C structures.",
225  "ZIPLIST <key> -- Show low level info about the ziplist encoding.",
226  "STRINGMATCH-TEST -- Run a fuzz tester against the stringmatchlen() function.",
227  NULL
228          };
229          addReplyHelp(c, help);
230      } else if (!strcasecmp(c->argv[1]->ptr,"segfault")) {
231          *((char*)-1) = 'x';
232      } else if (!strcasecmp(c->argv[1]->ptr,"panic")) {
233          serverPanic("DEBUG PANIC called at Unix time %Id", time(NULL));                           WIN_PORT_FIX &bsol;* %ld -> %Id */
234      } else if (!strcasecmp(c->argv[1]->ptr,"restart") ||
235                 !strcasecmp(c->argv[1]->ptr,"crash-and-recover"))
236      {
237          PORT_LONGLONG delay = 0;
238          if (c->argc >= 3) {
239              if (getLongLongFromObjectOrReply(c, c->argv[2], &delay, NULL)
240                  != C_OK) return;
241              if (delay < 0) delay = 0;
242          }
243          int flags = !strcasecmp(c->argv[1]->ptr,"restart") ?
244              (RESTART_SERVER_GRACEFULLY|RESTART_SERVER_CONFIG_REWRITE) :
245               RESTART_SERVER_NONE;
246          restartServer(flags,delay);
247          addReplyError(c,"failed to restart the server. Check server logs.");
248      } else if (!strcasecmp(c->argv[1]->ptr,"oom")) {
249          void *ptr = zmalloc(PORT_ULONG_MAX); &bsol;* Should trigger an out of memory. */
250          zfree(ptr);
251          addReply(c,shared.ok);
252      } else if (!strcasecmp(c->argv[1]->ptr,"assert")) {
253          serverAssertWithInfo(c,c->argv[0],1 == 2);
254      } else if (!strcasecmp(c->argv[1]->ptr,"log") && c->argc == 3) {
255          serverLog(LL_WARNING, "DEBUG LOG: %s", (char*)c->argv[2]->ptr);
256          addReply(c,shared.ok);
257      } else if (!strcasecmp(c->argv[1]->ptr,"reload")) {
258          rdbSaveInfo rsi, *rsiptr;
259          rsiptr = rdbPopulateSaveInfo(&rsi);
260          if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {
261              addReply(c,shared.err);
262              return;
263          }
264          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
265          protectClient(c);
266          int ret = rdbLoad(server.rdb_filename,NULL);
267          unprotectClient(c);
268          if (ret != C_OK) {
269              addReplyError(c,"Error trying to load the RDB dump");
270              return;
271          }
272          serverLog(LL_WARNING,"DB reloaded by DEBUG RELOAD");
273          addReply(c,shared.ok);
274      } else if (!strcasecmp(c->argv[1]->ptr,"loadaof")) {
275          if (server.aof_state != AOF_OFF) flushAppendOnlyFile(1);
276          emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
277          protectClient(c);
278          int ret = loadAppendOnlyFile(server.aof_filename);
279          unprotectClient(c);
280          if (ret != C_OK) {
281              addReply(c,shared.err);
282              return;
283          }
284          server.dirty = 0; &bsol;* Prevent AOF / replication */
285          serverLog(LL_WARNING,"Append Only File loaded by DEBUG LOADAOF");
286          addReply(c,shared.ok);
287      } else if (!strcasecmp(c->argv[1]->ptr,"object") && c->argc == 3) {
288          dictEntry *de;
289          robj *val;
290          char *strenc;
291          if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {
292              addReply(c,shared.nokeyerr);
293              return;
294          }
295          val = dictGetVal(de);
296          strenc = strEncoding(val->encoding);
297          char extra[138] = {0};
298          if (val->encoding == OBJ_ENCODING_QUICKLIST) {
299              char *nextra = extra;
300              int remaining = sizeof(extra);
301              quicklist *ql = val->ptr;
302              int used = snprintf(nextra, remaining, " ql_nodes:%Iu", ql->len);		WIN_PORT_FIX &bsol;* %lu -> %Iu */
303              nextra += used;
304              remaining -= used;
305              double avg = (double)ql->count/ql->len;
306              used = snprintf(nextra, remaining, " ql_avg_node:%.2f", avg);
307              nextra += used;
308              remaining -= used;
309              used = snprintf(nextra, remaining, " ql_ziplist_max:%d", ql->fill);
310              nextra += used;
311              remaining -= used;
312              int compressed = ql->compress != 0;
313              used = snprintf(nextra, remaining, " ql_compressed:%d", compressed);
314              nextra += used;
315              remaining -= used;
316              PORT_ULONG sz = 0;
317              for (quicklistNode *node = ql->head; node; node = node->next) {
318                  sz += node->sz;
319              }
320              used = snprintf(nextra, remaining, " ql_uncompressed_size:%Iu", sz);        WIN_PORT_FIX &bsol;* %lu -> %Iu */
321              nextra += used;
322              remaining -= used;
323          }
324          addReplyStatusFormat(c,
325              "Value at:%p refcount:%d "
326              "encoding:%s serializedlength:%Iu "                                 WIN_PORT_FIX &bsol;* %zu -> %Iu */
327              "lru:%d lru_seconds_idle:%llu%s",
328              (void*)val, val->refcount,
329              strenc, (PORT_LONGLONG) rdbSavedObjectLen(val),
330              val->lru, estimateObjectIdleTime(val)/1000, extra);
331      } else if (!strcasecmp(c->argv[1]->ptr,"sdslen") && c->argc == 3) {
332          dictEntry *de;
333          robj *val;
334          sds key;
335          if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {
336              addReply(c,shared.nokeyerr);
337              return;
338          }
339          val = dictGetVal(de);
340          key = dictGetKey(de);
341          if (val->type != OBJ_STRING || !sdsEncodedObject(val)) {
342              addReplyError(c,"Not an sds encoded string.");
343          } else {
344              addReplyStatusFormat(c,
345                  "key_sds_len:%lld, key_sds_avail:%lld, key_zmalloc: %lld, "
346                  "val_sds_len:%lld, val_sds_avail:%lld, val_zmalloc: %lld",
347                  (PORT_LONGLONG) sdslen(key),
348                  (PORT_LONGLONG) sdsavail(key),
349                  (PORT_LONGLONG) sdsZmallocSize(key),
350                  (PORT_LONGLONG) sdslen(val->ptr),
351                  (PORT_LONGLONG) sdsavail(val->ptr),
352                  (PORT_LONGLONG) getStringObjectSdsUsedMemory(val));
353          }
354      } else if (!strcasecmp(c->argv[1]->ptr,"ziplist") && c->argc == 3) {
355          robj *o;
356          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))
357                  == NULL) return;
358          if (o->encoding != OBJ_ENCODING_ZIPLIST) {
359              addReplyError(c,"Not an sds encoded string.");
360          } else {
361              ziplistRepr(o->ptr);
362              addReplyStatus(c,"Ziplist structure printed on stdout");
363          }
364      } else if (!strcasecmp(c->argv[1]->ptr,"populate") &&
365                 c->argc >= 3 && c->argc <= 5) {
366          PORT_LONG keys, j;
367          robj *key, *val;
368          char buf[128];
369          if (getLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)
370              return;
371          dictExpand(c->db->dict,keys);
372          for (j = 0; j < keys; j++) {
373              PORT_LONG valsize = 0;
374              snprintf(buf,sizeof(buf),"%s:%Iu",                                  WIN_PORT_FIX &bsol;* %lu -> %Iu */
375                  (c->argc == 3) ? "key" : (char*)c->argv[3]->ptr, j);
376              key = createStringObject(buf,strlen(buf));
377              if (c->argc == 5)
378                  if (getLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK)
379                      return;
380              if (lookupKeyWrite(c->db,key) != NULL) {
381                  decrRefCount(key);
382                  continue;
383              }
384              snprintf(buf,sizeof(buf),"value:%Iu",j);                            WIN_PORT_FIX &bsol;* %lu -> %Iu */
385              if (valsize==0)
386                  val = createStringObject(buf,strlen(buf));
387              else {
388                  int buflen = strlen(buf);
389                  val = createStringObject(NULL,valsize);
390                  memcpy(val->ptr, buf, valsize<=buflen? valsize: buflen);
391              }
392              dbAdd(c->db,key,val);
393              signalModifiedKey(c->db,key);
394              decrRefCount(key);
395          }
396          addReply(c,shared.ok);
397      } else if (!strcasecmp(c->argv[1]->ptr,"digest") && c->argc == 2) {
398          unsigned char digest[20];
399          sds d = sdsempty();
400          computeDatasetDigest(digest);
401          for (int i = 0; i < 20; i++) d = sdscatprintf(d, "%02x",digest[i]);
402          addReplyStatus(c,d);
403          sdsfree(d);
404      } else if (!strcasecmp(c->argv[1]->ptr,"digest-value") && c->argc >= 2) {
405          addReplyMultiBulkLen(c,c->argc-2);
406          for (int j = 2; j < c->argc; j++) {
407              unsigned char digest[20];
408              memset(digest,0,20); &bsol;* Start with a clean result */
409              robj *o = lookupKeyReadWithFlags(c->db,c->argv[j],LOOKUP_NOTOUCH);
410              if (o) xorObjectDigest(c->db,c->argv[j],digest,o);
411              sds d = sdsempty();
412              for (int i = 0; i < 20; i++) d = sdscatprintf(d, "%02x",digest[i]);
413              addReplyStatus(c,d);
414              sdsfree(d);
415          }
416      } else if (!strcasecmp(c->argv[1]->ptr,"sleep") && c->argc == 3) {
417          double dtime = strtod(c->argv[2]->ptr,NULL);
418          PORT_LONGLONG utime = (PORT_LONGLONG)(dtime*1000000);                   WIN_PORT_FIX &bsol;* cast (PORT_LONGLONG) */
419  #ifdef _WIN32
420          usleep(utime);
421  #else
422          struct timespec tv;
423          tv.tv_sec = utime / 1000000;
424          tv.tv_nsec = (utime % 1000000) * 1000;
425          nanosleep(&tv, NULL);
426  #endif
427          addReply(c,shared.ok);
428      } else if (!strcasecmp(c->argv[1]->ptr,"set-active-expire") &&
429                 c->argc == 3)
430      {
431          server.active_expire_enabled = atoi(c->argv[2]->ptr);
432          addReply(c,shared.ok);
433      } else if (!strcasecmp(c->argv[1]->ptr,"lua-always-replicate-commands") &&
434                 c->argc == 3)
435      {
436          server.lua_always_replicate_commands = atoi(c->argv[2]->ptr);
437          addReply(c,shared.ok);
438      } else if (!strcasecmp(c->argv[1]->ptr,"error") && c->argc == 3) {
439          sds errstr = sdsnewlen("-",1);
440          errstr = sdscatsds(errstr,c->argv[2]->ptr);
441          errstr = sdsmapchars(errstr,"\n\r","  ",2); &bsol;* no newlines in errors. */
442          errstr = sdscatlen(errstr,"\r\n",2);
443          addReplySds(c,errstr);
444      } else if (!strcasecmp(c->argv[1]->ptr,"structsize") && c->argc == 2) {
445          sds sizes = sdsempty();
446          sizes = sdscatprintf(sizes,"bits:%d ",(sizeof(void*) == 8)?64:32);
447          sizes = sdscatprintf(sizes,"robj:%d ",(int)sizeof(robj));
448          sizes = sdscatprintf(sizes,"dictentry:%d ",(int)sizeof(dictEntry));
449          sizes = sdscatprintf(sizes,"sdshdr5:%d ",(int)sizeof(struct sdshdr5));
450          sizes = sdscatprintf(sizes,"sdshdr8:%d ",(int)sizeof(struct sdshdr8));
451          sizes = sdscatprintf(sizes,"sdshdr16:%d ",(int)sizeof(struct sdshdr16));
452          sizes = sdscatprintf(sizes,"sdshdr32:%d ",(int)sizeof(struct sdshdr32));
453          sizes = sdscatprintf(sizes,"sdshdr64:%d ",(int)sizeof(struct sdshdr64));
454          addReplyBulkSds(c,sizes);
455      } else if (!strcasecmp(c->argv[1]->ptr,"htstats") && c->argc == 3) {
456          PORT_LONG dbid;
457          sds stats = sdsempty();
458          char buf[4096];
459          if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
460              return;
461          if (dbid < 0 || dbid >= server.dbnum) {
462              addReplyError(c,"Out of range database");
463              return;
464          }
465          stats = sdscatprintf(stats,"[Dictionary HT]\n");
466          dictGetStats(buf,sizeof(buf),server.db[dbid].dict);
467          stats = sdscat(stats,buf);
468          stats = sdscatprintf(stats,"[Expires HT]\n");
469          dictGetStats(buf,sizeof(buf),server.db[dbid].expires);
470          stats = sdscat(stats,buf);
471          addReplyBulkSds(c,stats);
472      } else if (!strcasecmp(c->argv[1]->ptr,"htstats-key") && c->argc == 3) {
473          robj *o;
474          dict *ht = NULL;
475          if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))
476                  == NULL) return;
477          switch (o->encoding) {
478          case OBJ_ENCODING_SKIPLIST:
479              {
480                  zset *zs = o->ptr;
481                  ht = zs->dict;
482              }
483              break;
484          case OBJ_ENCODING_HT:
485              ht = o->ptr;
486              break;
487          }
488          if (ht == NULL) {
489              addReplyError(c,"The value stored at the specified key is not "
490                              "represented using an hash table");
491          } else {
492              char buf[4096];
493              dictGetStats(buf,sizeof(buf),ht);
494              addReplyBulkCString(c,buf);
495          }
496      } else if (!strcasecmp(c->argv[1]->ptr,"change-repl-id") && c->argc == 2) {
497          serverLog(LL_WARNING,"Changing replication IDs after receiving DEBUG change-repl-id");
498          changeReplicationId();
499          clearReplicationId2();
500          addReply(c,shared.ok);
501      } else if (!strcasecmp(c->argv[1]->ptr,"stringmatch-test") && c->argc == 2)
502      {
503          stringmatchlen_fuzz_test();
504          addReplyStatus(c,"Apparently Redis did not crash: test passed");
505      } else {
506          addReplySubcommandSyntaxError(c);
507          return;
508      }
509  }
510  void _serverAssert(const char *estr, const char *file, int line) {
511      bugReportStart();
512      serverLog(LL_WARNING,"=== ASSERTION FAILED ===");
513      serverLog(LL_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
514  #ifdef HAVE_BACKTRACE
515      server.assert_failed = estr;
516      server.assert_file = file;
517      server.assert_line = line;
518      serverLog(LL_WARNING,"(forcing SIGSEGV to print the bug report.)");
519  #endif
520      *((char*)-1) = 'x';
521  }
522  void _serverAssertPrintClientInfo(const client *c) {
523      int j;
524      bugReportStart();
525      serverLog(LL_WARNING,"=== ASSERTION FAILED CLIENT CONTEXT ===");
526      serverLog(LL_WARNING,"client->flags = %d", c->flags);
527      serverLog(LL_WARNING,"client->fd = %d", c->fd);
528      serverLog(LL_WARNING,"client->argc = %d", c->argc);
529      for (j=0; j < c->argc; j++) {
530          char buf[128];
531          char *arg;
532          if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {
533              arg = (char*) c->argv[j]->ptr;
534          } else {
535              snprintf(buf,sizeof(buf),"Object type: %u, encoding: %u",
536                  c->argv[j]->type, c->argv[j]->encoding);
537              arg = buf;
538          }
539          serverLog(LL_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
540              j, arg, c->argv[j]->refcount);
541      }
542  }
543  void serverLogObjectDebugInfo(const robj *o) {
544      serverLog(LL_WARNING,"Object type: %d", o->type);
545      serverLog(LL_WARNING,"Object encoding: %d", o->encoding);
546      serverLog(LL_WARNING,"Object refcount: %d", o->refcount);
547      if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
548          serverLog(LL_WARNING,"Object raw string len: %Iu", sdslen(o->ptr));   WIN_PORT_FIX &bsol;* %zu -> %Iu */
549          if (sdslen(o->ptr) < 4096) {
550              sds repr = sdscatrepr(sdsempty(),o->ptr,sdslen(o->ptr));
551              serverLog(LL_WARNING,"Object raw string content: %s", repr);
552              sdsfree(repr);
553          }
554      } else if (o->type == OBJ_LIST) {
555          serverLog(LL_WARNING,"List length: %d", (int) listTypeLength(o));
556      } else if (o->type == OBJ_SET) {
557          serverLog(LL_WARNING,"Set size: %d", (int) setTypeSize(o));
558      } else if (o->type == OBJ_HASH) {
559          serverLog(LL_WARNING,"Hash size: %d", (int) hashTypeLength(o));
560      } else if (o->type == OBJ_ZSET) {
561          serverLog(LL_WARNING,"Sorted set size: %d", (int) zsetLength(o));
562          if (o->encoding == OBJ_ENCODING_SKIPLIST)
563              serverLog(LL_WARNING,"Skiplist level: %d", (int) ((const zset*)o->ptr)->zsl->level);
564      }
565  }
566  void _serverAssertPrintObject(const robj *o) {
567      bugReportStart();
568      serverLog(LL_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
569      serverLogObjectDebugInfo(o);
570  }
571  void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
572      if (c) _serverAssertPrintClientInfo(c);
573      if (o) _serverAssertPrintObject(o);
574      _serverAssert(estr,file,line);
575  }
576  void _serverPanic(const char *file, int line, const char *msg, ...) {
577      va_list ap;
578      va_start(ap,msg);
579      char fmtmsg[256];
580      vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);
581      va_end(ap);
582      bugReportStart();
583      serverLog(LL_WARNING,"------------------------------------------------");
584  #ifdef _WIN32
585      serverLog(LL_WARNING, "Fatal Error: %s #%s:%d", fmtmsg, file, line);
586  #else
587      serverLog(LL_WARNING,"!!! Software Failure. Press left mouse button to continue");
588      serverLog(LL_WARNING,"Guru Meditation: %s #%s:%d",fmtmsg,file,line);
589  #endif
590  #ifdef HAVE_BACKTRACE
591      serverLog(LL_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
592  #endif
593      serverLog(LL_WARNING,"------------------------------------------------");
594      *((char*)-1) = 'x';
595  }
596  void bugReportStart(void) {
597      if (server.bug_report_start == 0) {
598          serverLogRaw(LL_WARNING|LL_RAW,
599          "\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n");
600          server.bug_report_start = 1;
601          WIN32_ONLY(serverLog(LL_WARNING|LL_RAW, "Redis version: %s\n", REDIS_VERSION);)
602      }
603  }
604  #ifdef HAVE_BACKTRACE
605  static void *getMcontextEip(ucontext_t *uc) {
606  #if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
607      #if defined(__x86_64__)
608      return (void*) uc->uc_mcontext->__ss.__rip;
609      #elif defined(__i386__)
610      return (void*) uc->uc_mcontext->__ss.__eip;
611      #else
612      return (void*) uc->uc_mcontext->__ss.__srr0;
613      #endif
614  #elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
615      #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)
616      return (void*) uc->uc_mcontext->__ss.__rip;
617      #else
618      return (void*) uc->uc_mcontext->__ss.__eip;
619      #endif
620  #elif defined(__linux__)
621      #if defined(__i386__)
622      return (void*) uc->uc_mcontext.gregs[14]; &bsol;* Linux 32 */
623      #elif defined(__X86_64__) || defined(__x86_64__)
624      return (void*) uc->uc_mcontext.gregs[16]; &bsol;* Linux 64 */
625      #elif defined(__ia64__) &bsol;* Linux IA64 */
626      return (void*) uc->uc_mcontext.sc_ip;
627      #elif defined(__arm__) &bsol;* Linux ARM */
628      return (void*) uc->uc_mcontext.arm_pc;
629      #elif defined(__aarch64__) &bsol;* Linux AArch64 */
630      return (void*) uc->uc_mcontext.pc;
631      #endif
632  #elif defined(__FreeBSD__)
633      #if defined(__i386__)
634      return (void*) uc->uc_mcontext.mc_eip;
635      #elif defined(__x86_64__)
636      return (void*) uc->uc_mcontext.mc_rip;
637      #endif
638  #elif defined(__OpenBSD__)
639      #if defined(__i386__)
640      return (void*) uc->sc_eip;
641      #elif defined(__x86_64__)
642      return (void*) uc->sc_rip;
643      #endif
644  #elif defined(__DragonFly__)
645      return (void*) uc->uc_mcontext.mc_rip;
646  #else
647      return NULL;
648  #endif
649  }
650  void logStackContent(void **sp) {
651      int i;
652      for (i = 15; i >= 0; i--) {
653          PORT_ULONG addr = (PORT_ULONG) sp+i;
654          PORT_ULONG val = (PORT_ULONG) sp[i];
655          if (sizeof(PORT_LONG) == 4)
656              serverLog(LL_WARNING, "(%08lx) -> %08lx", addr, val);
657          else
658              serverLog(LL_WARNING, "(%016lx) -> %016lx", addr, val);
659      }
660  }
661  void logRegisters(ucontext_t *uc) {
662      serverLog(LL_WARNING|LL_RAW, "\n------ REGISTERS ------\n");
663  #if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
664      #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)
665      serverLog(LL_WARNING,
666      "\n"
667      "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
668      "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
669      "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
670      "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
671      "RIP:%016lx EFL:%016lx\nCS :%016lx FS:%016lx  GS:%016lx",
672          (PORT_ULONG) uc->uc_mcontext->__ss.__rax,
673          (PORT_ULONG) uc->uc_mcontext->__ss.__rbx,
674          (PORT_ULONG) uc->uc_mcontext->__ss.__rcx,
675          (PORT_ULONG) uc->uc_mcontext->__ss.__rdx,
676          (PORT_ULONG) uc->uc_mcontext->__ss.__rdi,
677          (PORT_ULONG) uc->uc_mcontext->__ss.__rsi,
678          (PORT_ULONG) uc->uc_mcontext->__ss.__rbp,
679          (PORT_ULONG) uc->uc_mcontext->__ss.__rsp,
680          (PORT_ULONG) uc->uc_mcontext->__ss.__r8,
681          (PORT_ULONG) uc->uc_mcontext->__ss.__r9,
682          (PORT_ULONG) uc->uc_mcontext->__ss.__r10,
683          (PORT_ULONG) uc->uc_mcontext->__ss.__r11,
684          (PORT_ULONG) uc->uc_mcontext->__ss.__r12,
685          (PORT_ULONG) uc->uc_mcontext->__ss.__r13,
686          (PORT_ULONG) uc->uc_mcontext->__ss.__r14,
687          (PORT_ULONG) uc->uc_mcontext->__ss.__r15,
688          (PORT_ULONG) uc->uc_mcontext->__ss.__rip,
689          (PORT_ULONG) uc->uc_mcontext->__ss.__rflags,
690          (PORT_ULONG) uc->uc_mcontext->__ss.__cs,
691          (PORT_ULONG) uc->uc_mcontext->__ss.__fs,
692          (PORT_ULONG) uc->uc_mcontext->__ss.__gs
693      );
694      logStackContent((void**)uc->uc_mcontext->__ss.__rsp);
695      #else
696      serverLog(LL_WARNING,
697      "\n"
698      "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
699      "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
700      "SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\n"
701      "DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx",
702          (PORT_ULONG) uc->uc_mcontext->__ss.__eax,
703          (PORT_ULONG) uc->uc_mcontext->__ss.__ebx,
704          (PORT_ULONG) uc->uc_mcontext->__ss.__ecx,
705          (PORT_ULONG) uc->uc_mcontext->__ss.__edx,
706          (PORT_ULONG) uc->uc_mcontext->__ss.__edi,
707          (PORT_ULONG) uc->uc_mcontext->__ss.__esi,
708          (PORT_ULONG) uc->uc_mcontext->__ss.__ebp,
709          (PORT_ULONG) uc->uc_mcontext->__ss.__esp,
710          (PORT_ULONG) uc->uc_mcontext->__ss.__ss,
711          (PORT_ULONG) uc->uc_mcontext->__ss.__eflags,
712          (PORT_ULONG) uc->uc_mcontext->__ss.__eip,
713          (PORT_ULONG) uc->uc_mcontext->__ss.__cs,
714          (PORT_ULONG) uc->uc_mcontext->__ss.__ds,
715          (PORT_ULONG) uc->uc_mcontext->__ss.__es,
716          (PORT_ULONG) uc->uc_mcontext->__ss.__fs,
717          (PORT_ULONG) uc->uc_mcontext->__ss.__gs
718      );
719      logStackContent((void**)uc->uc_mcontext->__ss.__esp);
720      #endif
721  #elif defined(__linux__)
722      #if defined(__i386__)
723      serverLog(LL_WARNING,
724      "\n"
725      "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
726      "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
727      "SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n"
728      "DS :%08lx ES :%08lx FS :%08lx GS:%08lx",
729          (PORT_ULONG) uc->uc_mcontext.gregs[11],
730          (PORT_ULONG) uc->uc_mcontext.gregs[8],
731          (PORT_ULONG) uc->uc_mcontext.gregs[10],
732          (PORT_ULONG) uc->uc_mcontext.gregs[9],
733          (PORT_ULONG) uc->uc_mcontext.gregs[4],
734          (PORT_ULONG) uc->uc_mcontext.gregs[5],
735          (PORT_ULONG) uc->uc_mcontext.gregs[6],
736          (PORT_ULONG) uc->uc_mcontext.gregs[7],
737          (PORT_ULONG) uc->uc_mcontext.gregs[18],
738          (PORT_ULONG) uc->uc_mcontext.gregs[17],
739          (PORT_ULONG) uc->uc_mcontext.gregs[14],
740          (PORT_ULONG) uc->uc_mcontext.gregs[15],
741          (PORT_ULONG) uc->uc_mcontext.gregs[3],
742          (PORT_ULONG) uc->uc_mcontext.gregs[2],
743          (PORT_ULONG) uc->uc_mcontext.gregs[1],
744          (PORT_ULONG) uc->uc_mcontext.gregs[0]
745      );
746      logStackContent((void**)uc->uc_mcontext.gregs[7]);
747      #elif defined(__X86_64__) || defined(__x86_64__)
748      serverLog(LL_WARNING,
749      "\n"
750      "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
751      "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
752      "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
753      "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
754      "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
755          (PORT_ULONG) uc->uc_mcontext.gregs[13],
756          (PORT_ULONG) uc->uc_mcontext.gregs[11],
757          (PORT_ULONG) uc->uc_mcontext.gregs[14],
758          (PORT_ULONG) uc->uc_mcontext.gregs[12],
759          (PORT_ULONG) uc->uc_mcontext.gregs[8],
760          (PORT_ULONG) uc->uc_mcontext.gregs[9],
761          (PORT_ULONG) uc->uc_mcontext.gregs[10],
762          (PORT_ULONG) uc->uc_mcontext.gregs[15],
763          (PORT_ULONG) uc->uc_mcontext.gregs[0],
764          (PORT_ULONG) uc->uc_mcontext.gregs[1],
765          (PORT_ULONG) uc->uc_mcontext.gregs[2],
766          (PORT_ULONG) uc->uc_mcontext.gregs[3],
767          (PORT_ULONG) uc->uc_mcontext.gregs[4],
768          (PORT_ULONG) uc->uc_mcontext.gregs[5],
769          (PORT_ULONG) uc->uc_mcontext.gregs[6],
770          (PORT_ULONG) uc->uc_mcontext.gregs[7],
771          (PORT_ULONG) uc->uc_mcontext.gregs[16],
772          (PORT_ULONG) uc->uc_mcontext.gregs[17],
773          (PORT_ULONG) uc->uc_mcontext.gregs[18]
774      );
775      logStackContent((void**)uc->uc_mcontext.gregs[15]);
776      #endif
777  #elif defined(__FreeBSD__)
778      #if defined(__x86_64__)
779      serverLog(LL_WARNING,
780      "\n"
781      "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
782      "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
783      "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
784      "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
785      "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
786          (unsigned long) uc->uc_mcontext.mc_rax,
787          (unsigned long) uc->uc_mcontext.mc_rbx,
788          (unsigned long) uc->uc_mcontext.mc_rcx,
789          (unsigned long) uc->uc_mcontext.mc_rdx,
790          (unsigned long) uc->uc_mcontext.mc_rdi,
791          (unsigned long) uc->uc_mcontext.mc_rsi,
792          (unsigned long) uc->uc_mcontext.mc_rbp,
793          (unsigned long) uc->uc_mcontext.mc_rsp,
794          (unsigned long) uc->uc_mcontext.mc_r8,
795          (unsigned long) uc->uc_mcontext.mc_r9,
796          (unsigned long) uc->uc_mcontext.mc_r10,
797          (unsigned long) uc->uc_mcontext.mc_r11,
798          (unsigned long) uc->uc_mcontext.mc_r12,
799          (unsigned long) uc->uc_mcontext.mc_r13,
800          (unsigned long) uc->uc_mcontext.mc_r14,
801          (unsigned long) uc->uc_mcontext.mc_r15,
802          (unsigned long) uc->uc_mcontext.mc_rip,
803          (unsigned long) uc->uc_mcontext.mc_rflags,
804          (unsigned long) uc->uc_mcontext.mc_cs
805      );
806      logStackContent((void**)uc->uc_mcontext.mc_rsp);
807      #elif defined(__i386__)
808      serverLog(LL_WARNING,
809      "\n"
810      "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
811      "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
812      "SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n"
813      "DS :%08lx ES :%08lx FS :%08lx GS:%08lx",
814          (unsigned long) uc->uc_mcontext.mc_eax,
815          (unsigned long) uc->uc_mcontext.mc_ebx,
816          (unsigned long) uc->uc_mcontext.mc_ebx,
817          (unsigned long) uc->uc_mcontext.mc_edx,
818          (unsigned long) uc->uc_mcontext.mc_edi,
819          (unsigned long) uc->uc_mcontext.mc_esi,
820          (unsigned long) uc->uc_mcontext.mc_ebp,
821          (unsigned long) uc->uc_mcontext.mc_esp,
822          (unsigned long) uc->uc_mcontext.mc_ss,
823          (unsigned long) uc->uc_mcontext.mc_eflags,
824          (unsigned long) uc->uc_mcontext.mc_eip,
825          (unsigned long) uc->uc_mcontext.mc_cs,
826          (unsigned long) uc->uc_mcontext.mc_es,
827          (unsigned long) uc->uc_mcontext.mc_fs,
828          (unsigned long) uc->uc_mcontext.mc_gs
829      );
830      logStackContent((void**)uc->uc_mcontext.mc_esp);
831      #endif
832  #elif defined(__OpenBSD__)
833      #if defined(__x86_64__)
834      serverLog(LL_WARNING,
835      "\n"
836      "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
837      "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
838      "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
839      "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
840      "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
841          (unsigned long) uc->sc_rax,
842          (unsigned long) uc->sc_rbx,
843          (unsigned long) uc->sc_rcx,
844          (unsigned long) uc->sc_rdx,
845          (unsigned long) uc->sc_rdi,
846          (unsigned long) uc->sc_rsi,
847          (unsigned long) uc->sc_rbp,
848          (unsigned long) uc->sc_rsp,
849          (unsigned long) uc->sc_r8,
850          (unsigned long) uc->sc_r9,
851          (unsigned long) uc->sc_r10,
852          (unsigned long) uc->sc_r11,
853          (unsigned long) uc->sc_r12,
854          (unsigned long) uc->sc_r13,
855          (unsigned long) uc->sc_r14,
856          (unsigned long) uc->sc_r15,
857          (unsigned long) uc->sc_rip,
858          (unsigned long) uc->sc_rflags,
859          (unsigned long) uc->sc_cs
860      );
861      logStackContent((void**)uc->sc_rsp);
862      #elif defined(__i386__)
863      serverLog(LL_WARNING,
864      "\n"
865      "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
866      "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
867      "SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n"
868      "DS :%08lx ES :%08lx FS :%08lx GS:%08lx",
869          (unsigned long) uc->sc_eax,
870          (unsigned long) uc->sc_ebx,
871          (unsigned long) uc->sc_ebx,
872          (unsigned long) uc->sc_edx,
873          (unsigned long) uc->sc_edi,
874          (unsigned long) uc->sc_esi,
875          (unsigned long) uc->sc_ebp,
876          (unsigned long) uc->sc_esp,
877          (unsigned long) uc->sc_ss,
878          (unsigned long) uc->sc_eflags,
879          (unsigned long) uc->sc_eip,
880          (unsigned long) uc->sc_cs,
881          (unsigned long) uc->sc_es,
882          (unsigned long) uc->sc_fs,
883          (unsigned long) uc->sc_gs
884      );
885      logStackContent((void**)uc->sc_esp);
886      #endif
887  #elif defined(__DragonFly__)
888      serverLog(LL_WARNING,
889      "\n"
890      "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
891      "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
892      "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
893      "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
894      "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
895          (unsigned long) uc->uc_mcontext.mc_rax,
896          (unsigned long) uc->uc_mcontext.mc_rbx,
897          (unsigned long) uc->uc_mcontext.mc_rcx,
898          (unsigned long) uc->uc_mcontext.mc_rdx,
899          (unsigned long) uc->uc_mcontext.mc_rdi,
900          (unsigned long) uc->uc_mcontext.mc_rsi,
901          (unsigned long) uc->uc_mcontext.mc_rbp,
902          (unsigned long) uc->uc_mcontext.mc_rsp,
903          (unsigned long) uc->uc_mcontext.mc_r8,
904          (unsigned long) uc->uc_mcontext.mc_r9,
905          (unsigned long) uc->uc_mcontext.mc_r10,
906          (unsigned long) uc->uc_mcontext.mc_r11,
907          (unsigned long) uc->uc_mcontext.mc_r12,
908          (unsigned long) uc->uc_mcontext.mc_r13,
909          (unsigned long) uc->uc_mcontext.mc_r14,
910          (unsigned long) uc->uc_mcontext.mc_r15,
911          (unsigned long) uc->uc_mcontext.mc_rip,
912          (unsigned long) uc->uc_mcontext.mc_rflags,
913          (unsigned long) uc->uc_mcontext.mc_cs
914      );
915      logStackContent((void**)uc->uc_mcontext.mc_rsp);
916  #else
917      serverLog(LL_WARNING,
918          "  Dumping of registers not supported for this OS/arch");
919  #endif
920  }
921  int openDirectLogFiledes(void) {
922      int log_to_stdout = server.logfile[0] == '\0';
923      int fd = log_to_stdout ?
924          STDOUT_FILENO :
925          open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
926      return fd;
927  }
928  void closeDirectLogFiledes(int fd) {
929      int log_to_stdout = server.logfile[0] == '\0';
930      if (!log_to_stdout) close(fd);
931  }
932  void logStackTrace(ucontext_t *uc) {
933      void *trace[101];
934      int trace_size = 0, fd = openDirectLogFiledes();
935      if (fd == -1) return; &bsol;* If we can't log there is anything to do. */
936      trace_size = backtrace(trace+1, 100);
937      if (getMcontextEip(uc) != NULL) {
938          char *msg1 = "EIP:\n";
939          char *msg2 = "\nBacktrace:\n";
940          if (write(fd,msg1,strlen(msg1)) == -1) {&bsol;* Avoid warning. */};
941          trace[0] = getMcontextEip(uc);
942          backtrace_symbols_fd(trace, 1, fd);
943          if (write(fd,msg2,strlen(msg2)) == -1) {&bsol;* Avoid warning. */};
944      }
945      backtrace_symbols_fd(trace+1, trace_size, fd);
946      closeDirectLogFiledes(fd);
947  }
948  void logCurrentClient(void) {
949      if (server.current_client == NULL) return;
950      client *cc = server.current_client;
951      sds client;
952      int j;
953      serverLogRaw(LL_WARNING|LL_RAW, "\n------ CURRENT CLIENT INFO ------\n");
954      client = catClientInfoString(sdsempty(),cc);
955      serverLog(LL_WARNING|LL_RAW,"%s\n", client);
956      sdsfree(client);
957      for (j = 0; j < cc->argc; j++) {
958          robj *decoded;
959          decoded = getDecodedObject(cc->argv[j]);
960          serverLog(LL_WARNING|LL_RAW,"argv[%d]: '%s'\n", j,
961              (char*)decoded->ptr);
962          decrRefCount(decoded);
963      }
964      if (cc->argc >= 1) {
965          robj *val, *key;
966          dictEntry *de;
967          key = getDecodedObject(cc->argv[1]);
968          de = dictFind(cc->db->dict, key->ptr);
969          if (de) {
970              val = dictGetVal(de);
971              serverLog(LL_WARNING,"key '%s' found in DB containing the following object:", (char*)key->ptr);
972              serverLogObjectDebugInfo(val);
973          }
974          decrRefCount(key);
975      }
976  }
977  #if defined(HAVE_PROC_MAPS)
978  #define MEMTEST_MAX_REGIONS 128
979  int memtest_test_linux_anonymous_maps(void) {
980      FILE *fp;
981      char line[1024];
982      char logbuf[1024];
983      size_t start_addr, end_addr, size;
984      size_t start_vect[MEMTEST_MAX_REGIONS];
985      size_t size_vect[MEMTEST_MAX_REGIONS];
986      int regions = 0, j;
987      int fd = openDirectLogFiledes();
988      if (!fd) return 0;
989      fp = fopen("/proc/self/maps","r");
990      if (!fp) return 0;
991      while(fgets(line,sizeof(line),fp) != NULL) {
992          char *start, *end, *p = line;
993          start = p;
994          p = strchr(p,'-');
995          if (!p) continue;
996          *p++ = '\0';
997          end = p;
998          p = strchr(p,' ');
999          if (!p) continue;
1000          *p++ = '\0';
1001          if (strstr(p,"stack") ||
1002              strstr(p,"vdso") ||
1003              strstr(p,"vsyscall")) continue;
1004          if (!strstr(p,"00:00")) continue;
1005          if (!strstr(p,"rw")) continue;
1006          start_addr = strtoul(start,NULL,16);
1007          end_addr = strtoul(end,NULL,16);
1008          size = end_addr-start_addr;
1009          start_vect[regions] = start_addr;
1010          size_vect[regions] = size;
1011          snprintf(logbuf,sizeof(logbuf),
1012              "*** Preparing to test memory region %lx (%lu bytes)\n",
1013                  (PORT_ULONG) start_vect[regions],
1014                  (PORT_ULONG) size_vect[regions]);
1015          if (write(fd,logbuf,strlen(logbuf)) == -1) { &bsol;* Nothing to do. */ }
1016          regions++;
1017      }
1018      int errors = 0;
1019      for (j = 0; j < regions; j++) {
1020          if (write(fd,".",1) == -1) { &bsol;* Nothing to do. */ }
1021          errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);
1022          if (write(fd, errors ? "E" : "O",1) == -1) { &bsol;* Nothing to do. */ }
1023      }
1024      if (write(fd,"\n",1) == -1) { &bsol;* Nothing to do. */ }
1025      fclose(fp);
1026      closeDirectLogFiledes(fd);
1027      return errors;
1028  }
1029  #endif
1030  void dumpX86Calls(void *addr, size_t len) {
1031      size_t j;
1032      unsigned char *p = addr;
1033      Dl_info info;
1034      PORT_ULONG ht[256] = {0};
1035      if (len < 5) return;
1036      for (j = 0; j < len-4; j++) {
1037          if (p[j] != 0xE8) continue; &bsol;* Not an E8 CALL opcode. */
1038          PORT_ULONG target = (PORT_ULONG)addr+j+5;
1039          target += *((int32_t*)(p+j+1));
1040          if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {
1041              if (ht[target&0xff] != target) {
1042                  printf("Function at 0x%lx is %s\n",target,info.dli_sname);
1043                  ht[target&0xff] = target;
1044              }
1045              j += 4; &bsol;* Skip the 32 bit immediate. */
1046          }
1047      }
1048  }
1049  void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
1050      ucontext_t *uc = (ucontext_t*) secret;
1051      void *eip = getMcontextEip(uc);
1052      sds infostring, clients;
1053      struct sigaction act;
1054      UNUSED(info);
1055      bugReportStart();
1056      serverLog(LL_WARNING,
1057          "Redis %s crashed by signal: %d", REDIS_VERSION, sig);
1058      if (eip != NULL) {
1059          serverLog(LL_WARNING,
1060          "Crashed running the instruction at: %p", eip);
1061      }
1062      if (sig == SIGSEGV || sig == SIGBUS) {
1063          serverLog(LL_WARNING,
1064          "Accessing address: %p", (void*)info->si_addr);
1065      }
1066      serverLog(LL_WARNING,
1067          "Failed assertion: %s (%s:%d)", server.assert_failed,
1068                          server.assert_file, server.assert_line);
1069      serverLogRaw(LL_WARNING|LL_RAW, "\n------ STACK TRACE ------\n");
1070      logStackTrace(uc);
1071      serverLogRaw(LL_WARNING|LL_RAW, "\n------ INFO OUTPUT ------\n");
1072      infostring = genRedisInfoString("all");
1073      serverLogRaw(LL_WARNING|LL_RAW, infostring);
1074      serverLogRaw(LL_WARNING|LL_RAW, "\n------ CLIENT LIST OUTPUT ------\n");
1075      clients = getAllClientsInfoString(-1);
1076      serverLogRaw(LL_WARNING|LL_RAW, clients);
1077      sdsfree(infostring);
1078      sdsfree(clients);
1079      logCurrentClient();
1080      logRegisters(uc);
1081  #if defined(HAVE_PROC_MAPS)
1082      serverLogRaw(LL_WARNING|LL_RAW, "\n------ FAST MEMORY TEST ------\n");
1083      bioKillThreads();
1084      if (memtest_test_linux_anonymous_maps()) {
1085          serverLogRaw(LL_WARNING|LL_RAW,
1086              "!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\n");
1087      } else {
1088          serverLogRaw(LL_WARNING|LL_RAW,
1089              "Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\n");
1090      }
1091  #endif
1092      if (eip != NULL) {
1093          Dl_info info;
1094          if (dladdr(eip, &info) != 0) {
1095              serverLog(LL_WARNING|LL_RAW,
1096                  "\n------ DUMPING CODE AROUND EIP ------\n"
1097                  "Symbol: %s (base: %p)\n"
1098                  "Module: %s (base %p)\n"
1099                  "$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\n"
1100                  "$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\n"
1101                  "------\n",
1102                  info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,
1103                  info.dli_saddr);
1104              size_t len = (PORT_LONG)eip - (PORT_LONG)info.dli_saddr;
1105              PORT_ULONG sz = sysconf(_SC_PAGESIZE);
1106              if (len < 1<<13) { &bsol;* we don't have functions over 8k (verified) */
1107                  PORT_ULONG next = ((PORT_ULONG)eip + sz) & ~(sz-1);
1108                  PORT_ULONG end = (PORT_ULONG)eip + 128;
1109                  if (end > next) end = next;
1110                  len = end - (PORT_ULONG)info.dli_saddr;
1111                  serverLogHexDump(LL_WARNING, "dump of function",
1112                      info.dli_saddr ,len);
1113                  dumpX86Calls(info.dli_saddr,len);
1114              }
1115          }
1116      }
1117      serverLogRaw(LL_WARNING|LL_RAW,
1118  "\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n"
1119  "       Please report the crash by opening an issue on github:\n\n"
1120  "           https:&bsol;&bsol;github.com/tporadowski/redis/issues\n\n"
1121  "  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n"
1122  );
1123      if (server.daemonize && server.supervised == 0) unlink(server.pidfile);
1124      sigemptyset (&act.sa_mask);
1125      act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
1126      act.sa_handler = SIG_DFL;
1127      sigaction (sig, &act, NULL);
1128      kill(getpid(),sig);
1129  }
1130  #endif &bsol;* HAVE_BACKTRACE */
1131  void serverLogHexDump(int level, char *descr, void *value, size_t len) {
1132      char buf[65], *b;
1133      unsigned char *v = value;
1134      char charset[] = "0123456789abcdef";
1135      serverLog(level,"%s (hexdump of %Iu bytes):", descr, len);         WIN_PORT_FIX &bsol;* %zu -> %Iu */
1136      b = buf;
1137      while(len) {
1138          b[0] = charset[(*v)>>4];
1139          b[1] = charset[(*v)&0xf];
1140          b[2] = '\0';
1141          b += 2;
1142          len--;
1143          v++;
1144          if (b-buf == 64 || len == 0) {
1145              serverLogRaw(level|LL_RAW,buf);
1146              b = buf;
1147          }
1148      }
1149      serverLogRaw(level|LL_RAW,"\n");
1150  }
1151  #ifdef _WIN32
1152  void watchdogScheduleSignal(int period) {
1153      UNUSED(period);
1154  }
1155  void enableWatchdog(int period) {
1156      UNUSED(period);
1157  }
1158  void disableWatchdog(void) {
1159  }
1160  #else
1161  #include <sys/time.h>
1162  void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
1163  #ifdef HAVE_BACKTRACE
1164      ucontext_t *uc = (ucontext_t*) secret;
1165  #else
1166      (void)secret;
1167  #endif
1168      UNUSED(info);
1169      UNUSED(sig);
1170      serverLogFromHandler(LL_WARNING,"\n--- WATCHDOG TIMER EXPIRED ---");
1171  #ifdef HAVE_BACKTRACE
1172      logStackTrace(uc);
1173  #else
1174      serverLogFromHandler(LL_WARNING,"Sorry: no support for backtrace().");
1175  #endif
1176      serverLogFromHandler(LL_WARNING,"--------\n");
1177  }
1178  void watchdogScheduleSignal(int period) {
1179      struct itimerval it;
1180      it.it_value.tv_sec = period/1000;
1181      it.it_value.tv_usec = (period%1000)*1000;
1182      it.it_interval.tv_sec = 0;
1183      it.it_interval.tv_usec = 0;
1184      setitimer(ITIMER_REAL, &it, NULL);
1185  }
1186  void enableWatchdog(int period) {
1187      int min_period;
1188      if (server.watchdog_period == 0) {
1189          struct sigaction act;
1190          sigemptyset(&act.sa_mask);
1191          act.sa_flags = SA_ONSTACK | SA_SIGINFO;
1192          act.sa_sigaction = watchdogSignalHandler;
1193          sigaction(SIGALRM, &act, NULL);
1194      }
1195      min_period = (1000/server.hz)*2;
1196      if (period < min_period) period = min_period;
1197      watchdogScheduleSignal(period); &bsol;* Adjust the current timer. */
1198      server.watchdog_period = period;
1199  }
1200  void disableWatchdog(void) {
1201      struct sigaction act;
1202      if (server.watchdog_period == 0) return; &bsol;* Already disabled. */
1203      watchdogScheduleSignal(0); &bsol;* Stop the current timer. */
1204      sigemptyset(&act.sa_mask);
1205      act.sa_flags = 0;
1206      act.sa_handler = SIG_IGN;
1207      sigaction(SIGALRM, &act, NULL);
1208      server.watchdog_period = 0;
1209  }
1210  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-aof.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-debug.c</div>
                </div>
                <div class="column column_space"><pre><code>711          eptr = ziplistIndex(zl,0);
712          serverAssert(eptr != NULL);
713          sptr = ziplistNext(zl,eptr);
714          serverAssert(sptr != NULL);
715          while (eptr != NULL) {
716              serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
717              score = zzlGetScore(sptr);
718              if (count == 0) {
</pre></code></div>
                <div class="column column_space"><pre><code>89              eptr = ziplistIndex(zl,0);
90              serverAssert(eptr != NULL);
91              sptr = ziplistNext(zl,eptr);
92              serverAssert(sptr != NULL);
93              while (eptr != NULL) {
94                  serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
95                  score = zzlGetScore(sptr);
96                  memset(eledigest,0,20);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    