
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.0%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</h3>
            <pre><code>1  #ifndef NRF_SAADC_H_
2  #define NRF_SAADC_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_SAADC_RESOLUTION_8BIT  = SAADC_RESOLUTION_VAL_8bit,  
10      NRF_SAADC_RESOLUTION_10BIT = SAADC_RESOLUTION_VAL_10bit, 
11      NRF_SAADC_RESOLUTION_12BIT = SAADC_RESOLUTION_VAL_12bit, 
12      NRF_SAADC_RESOLUTION_14BIT = SAADC_RESOLUTION_VAL_14bit  
13  } nrf_saadc_resolution_t;
14  typedef enum
15  {
16      NRF_SAADC_INPUT_DISABLED = SAADC_CH_PSELP_PSELP_NC,           
17      NRF_SAADC_INPUT_AIN0     = SAADC_CH_PSELP_PSELP_AnalogInput0, 
18      NRF_SAADC_INPUT_AIN1     = SAADC_CH_PSELP_PSELP_AnalogInput1, 
19      NRF_SAADC_INPUT_AIN2     = SAADC_CH_PSELP_PSELP_AnalogInput2, 
20      NRF_SAADC_INPUT_AIN3     = SAADC_CH_PSELP_PSELP_AnalogInput3, 
21      NRF_SAADC_INPUT_AIN4     = SAADC_CH_PSELP_PSELP_AnalogInput4, 
22      NRF_SAADC_INPUT_AIN5     = SAADC_CH_PSELP_PSELP_AnalogInput5, 
23      NRF_SAADC_INPUT_AIN6     = SAADC_CH_PSELP_PSELP_AnalogInput6, 
24      NRF_SAADC_INPUT_AIN7     = SAADC_CH_PSELP_PSELP_AnalogInput7, 
25      NRF_SAADC_INPUT_VDD      = SAADC_CH_PSELP_PSELP_VDD,          
26  #if defined(SAADC_CH_PSELP_PSELP_VDDHDIV5) || defined(__NRFX_DOXYGEN__)
27      NRF_SAADC_INPUT_VDDHDIV5 = SAADC_CH_PSELP_PSELP_VDDHDIV5      
28  #endif
29  } nrf_saadc_input_t;
30  typedef enum
<span onclick='openModal()' class='match'>31  {
32      NRF_SAADC_OVERSAMPLE_DISABLED = SAADC_OVERSAMPLE_OVERSAMPLE_Bypass,   
33      NRF_SAADC_OVERSAMPLE_2X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over2x,   
34      NRF_SAADC_OVERSAMPLE_4X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over4x,   
35      NRF_SAADC_OVERSAMPLE_8X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over8x,   
36      NRF_SAADC_OVERSAMPLE_16X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over16x,  
37      NRF_SAADC_OVERSAMPLE_32X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over32x,  
38      NRF_SAADC_OVERSAMPLE_64X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over64x,  
39      NRF_SAADC_OVERSAMPLE_128X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over128x, 
40      NRF_SAADC_OVERSAMPLE_256X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over256x  
</span>41  } nrf_saadc_oversample_t;
42  typedef enum
43  {
44      NRF_SAADC_RESISTOR_DISABLED = SAADC_CH_CONFIG_RESP_Bypass,   
45      NRF_SAADC_RESISTOR_PULLDOWN = SAADC_CH_CONFIG_RESP_Pulldown, 
46      NRF_SAADC_RESISTOR_PULLUP   = SAADC_CH_CONFIG_RESP_Pullup,   
47      NRF_SAADC_RESISTOR_VDD1_2   = SAADC_CH_CONFIG_RESP_VDD1_2    
48  } nrf_saadc_resistor_t;
49  typedef enum
50  {
51      NRF_SAADC_GAIN1_6 = SAADC_CH_CONFIG_GAIN_Gain1_6, 
52      NRF_SAADC_GAIN1_5 = SAADC_CH_CONFIG_GAIN_Gain1_5, 
53      NRF_SAADC_GAIN1_4 = SAADC_CH_CONFIG_GAIN_Gain1_4, 
54      NRF_SAADC_GAIN1_3 = SAADC_CH_CONFIG_GAIN_Gain1_3, 
55      NRF_SAADC_GAIN1_2 = SAADC_CH_CONFIG_GAIN_Gain1_2, 
56      NRF_SAADC_GAIN1   = SAADC_CH_CONFIG_GAIN_Gain1,   
57      NRF_SAADC_GAIN2   = SAADC_CH_CONFIG_GAIN_Gain2,   
58      NRF_SAADC_GAIN4   = SAADC_CH_CONFIG_GAIN_Gain4,   
59  } nrf_saadc_gain_t;
60  typedef enum
61  {
62      NRF_SAADC_REFERENCE_INTERNAL = SAADC_CH_CONFIG_REFSEL_Internal, 
63      NRF_SAADC_REFERENCE_VDD4     = SAADC_CH_CONFIG_REFSEL_VDD1_4    
64  } nrf_saadc_reference_t;
65  typedef enum
66  {
67      NRF_SAADC_ACQTIME_3US  = SAADC_CH_CONFIG_TACQ_3us,  
68      NRF_SAADC_ACQTIME_5US  = SAADC_CH_CONFIG_TACQ_5us,  
69      NRF_SAADC_ACQTIME_10US = SAADC_CH_CONFIG_TACQ_10us, 
70      NRF_SAADC_ACQTIME_15US = SAADC_CH_CONFIG_TACQ_15us, 
71      NRF_SAADC_ACQTIME_20US = SAADC_CH_CONFIG_TACQ_20us, 
72      NRF_SAADC_ACQTIME_40US = SAADC_CH_CONFIG_TACQ_40us  
73  } nrf_saadc_acqtime_t;
74  typedef enum
75  {
76      NRF_SAADC_MODE_SINGLE_ENDED = SAADC_CH_CONFIG_MODE_SE,  
77      NRF_SAADC_MODE_DIFFERENTIAL = SAADC_CH_CONFIG_MODE_Diff 
78  } nrf_saadc_mode_t;
79  typedef enum
80  {
81      NRF_SAADC_BURST_DISABLED = SAADC_CH_CONFIG_BURST_Disabled, 
82      NRF_SAADC_BURST_ENABLED  = SAADC_CH_CONFIG_BURST_Enabled   
83  } nrf_saadc_burst_t;
84  typedef enum
85  {
86      NRF_SAADC_TASK_START           = offsetof(NRF_SAADC_Type, TASKS_START),           
87      NRF_SAADC_TASK_SAMPLE          = offsetof(NRF_SAADC_Type, TASKS_SAMPLE),          
88      NRF_SAADC_TASK_STOP            = offsetof(NRF_SAADC_Type, TASKS_STOP),            
89      NRF_SAADC_TASK_CALIBRATEOFFSET = offsetof(NRF_SAADC_Type, TASKS_CALIBRATEOFFSET), 
90  } nrf_saadc_task_t;
91  typedef enum
92  {
93      NRF_SAADC_EVENT_STARTED       = offsetof(NRF_SAADC_Type, EVENTS_STARTED),       
94      NRF_SAADC_EVENT_END           = offsetof(NRF_SAADC_Type, EVENTS_END),           
95      NRF_SAADC_EVENT_DONE          = offsetof(NRF_SAADC_Type, EVENTS_DONE),          
96      NRF_SAADC_EVENT_RESULTDONE    = offsetof(NRF_SAADC_Type, EVENTS_RESULTDONE),    
97      NRF_SAADC_EVENT_CALIBRATEDONE = offsetof(NRF_SAADC_Type, EVENTS_CALIBRATEDONE), 
98      NRF_SAADC_EVENT_STOPPED       = offsetof(NRF_SAADC_Type, EVENTS_STOPPED),       
99      NRF_SAADC_EVENT_CH0_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITH),  
100      NRF_SAADC_EVENT_CH0_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITL),  
101      NRF_SAADC_EVENT_CH1_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITH),  
102      NRF_SAADC_EVENT_CH1_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITL),  
103      NRF_SAADC_EVENT_CH2_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITH),  
104      NRF_SAADC_EVENT_CH2_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITL),  
105      NRF_SAADC_EVENT_CH3_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITH),  
106      NRF_SAADC_EVENT_CH3_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITL),  
107      NRF_SAADC_EVENT_CH4_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITH),  
108      NRF_SAADC_EVENT_CH4_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITL),  
109      NRF_SAADC_EVENT_CH5_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITH),  
110      NRF_SAADC_EVENT_CH5_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITL),  
111      NRF_SAADC_EVENT_CH6_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITH),  
112      NRF_SAADC_EVENT_CH6_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITL),  
113      NRF_SAADC_EVENT_CH7_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITH),  
114      NRF_SAADC_EVENT_CH7_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITL)   
115  } nrf_saadc_event_t;
116  typedef enum
117  {
118      NRF_SAADC_INT_STARTED       = SAADC_INTENSET_STARTED_Msk,       
119      NRF_SAADC_INT_END           = SAADC_INTENSET_END_Msk,           
120      NRF_SAADC_INT_DONE          = SAADC_INTENSET_DONE_Msk,          
121      NRF_SAADC_INT_RESULTDONE    = SAADC_INTENSET_RESULTDONE_Msk,    
122      NRF_SAADC_INT_CALIBRATEDONE = SAADC_INTENSET_CALIBRATEDONE_Msk, 
123      NRF_SAADC_INT_STOPPED       = SAADC_INTENSET_STOPPED_Msk,       
124      NRF_SAADC_INT_CH0LIMITH     = SAADC_INTENSET_CH0LIMITH_Msk,     
125      NRF_SAADC_INT_CH0LIMITL     = SAADC_INTENSET_CH0LIMITL_Msk,     
126      NRF_SAADC_INT_CH1LIMITH     = SAADC_INTENSET_CH1LIMITH_Msk,     
127      NRF_SAADC_INT_CH1LIMITL     = SAADC_INTENSET_CH1LIMITL_Msk,     
128      NRF_SAADC_INT_CH2LIMITH     = SAADC_INTENSET_CH2LIMITH_Msk,     
129      NRF_SAADC_INT_CH2LIMITL     = SAADC_INTENSET_CH2LIMITL_Msk,     
130      NRF_SAADC_INT_CH3LIMITH     = SAADC_INTENSET_CH3LIMITH_Msk,     
131      NRF_SAADC_INT_CH3LIMITL     = SAADC_INTENSET_CH3LIMITL_Msk,     
132      NRF_SAADC_INT_CH4LIMITH     = SAADC_INTENSET_CH4LIMITH_Msk,     
133      NRF_SAADC_INT_CH4LIMITL     = SAADC_INTENSET_CH4LIMITL_Msk,     
134      NRF_SAADC_INT_CH5LIMITH     = SAADC_INTENSET_CH5LIMITH_Msk,     
135      NRF_SAADC_INT_CH5LIMITL     = SAADC_INTENSET_CH5LIMITL_Msk,     
136      NRF_SAADC_INT_CH6LIMITH     = SAADC_INTENSET_CH6LIMITH_Msk,     
137      NRF_SAADC_INT_CH6LIMITL     = SAADC_INTENSET_CH6LIMITL_Msk,     
138      NRF_SAADC_INT_CH7LIMITH     = SAADC_INTENSET_CH7LIMITH_Msk,     
139      NRF_SAADC_INT_CH7LIMITL     = SAADC_INTENSET_CH7LIMITL_Msk,     
140      NRF_SAADC_INT_ALL           = 0x7FFFFFFFUL                      
141  } nrf_saadc_int_mask_t;
142  typedef enum
143  {
144      NRF_SAADC_LIMIT_LOW  = 0, 
145      NRF_SAADC_LIMIT_HIGH = 1  
146  } nrf_saadc_limit_t;
147  typedef int16_t nrf_saadc_value_t;
148  typedef struct
149  {
150      nrf_saadc_resolution_t resolution;  
151      nrf_saadc_oversample_t oversample;  
152      nrf_saadc_value_t *    buffer;      
153      uint32_t               buffer_size; 
154  } nrf_saadc_config_t;
155  typedef struct
156  {
157      nrf_saadc_resistor_t  resistor_p; 
158      nrf_saadc_resistor_t  resistor_n; 
159      nrf_saadc_gain_t      gain;       
160      nrf_saadc_reference_t reference;  
161      nrf_saadc_acqtime_t   acq_time;   
162      nrf_saadc_mode_t      mode;       
163      nrf_saadc_burst_t     burst;      
164  } nrf_saadc_channel_config_t;
165  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg,
166                                                nrf_saadc_task_t task);
167  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
168                                                        nrf_saadc_task_t       task);
169  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg,
170                                               nrf_saadc_event_t      event);
171  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type *  p_reg,
172                                               nrf_saadc_event_t event);
173  NRF_STATIC_INLINE uint32_t nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
174                                                         nrf_saadc_event_t      event);
175  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
176  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
177                                                 nrf_saadc_task_t task,
178                                                 uint8_t          channel);
179  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg,
180                                                   nrf_saadc_task_t task);
181  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
182                                               nrf_saadc_event_t event,
183                                               uint8_t           channel);
184  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type *  p_reg,
185                                                 nrf_saadc_event_t event);
186  #endif 
187  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
188                                                                nrf_saadc_limit_t limit_type);
189  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
190                                                     uint8_t           channel,
191                                                     nrf_saadc_input_t pselp,
192                                                     nrf_saadc_input_t pseln);
193  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
194                                                         uint8_t           channel,
195                                                         nrf_saadc_input_t pselp);
196  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
197                                                      uint8_t          channel,
198                                                      int16_t          low,
199                                                      int16_t          high);
200  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask);
201  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask);
202  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask);
203  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask);
204  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
205                                                     nrf_saadc_limit_t limit_type);
206  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg);
207  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg);
208  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg);
209  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg);
210  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
211                                               nrf_saadc_value_t * p_buffer,
212                                               uint32_t            size);
213  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
214                                                      nrf_saadc_value_t * p_buffer);
215  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg);
216  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg);
217  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
218                                                  nrf_saadc_resolution_t resolution);
219  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg);
220  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
221                                                  nrf_saadc_oversample_t oversample);
222  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg);
223  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample);
224  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg,
225                                                          uint16_t         cc);
226  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg);
227  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg);
228  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
229                                                uint8_t                            channel,
230                                                nrf_saadc_channel_config_t const * config);
231  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
232                                             uint8_t           channel,
233                                             nrf_saadc_burst_t burst);
234  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution);
235  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution);
236  #ifndef NRF_DECLARE_ONLY
237  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
238  {
239      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
240  }
241  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
242                                                        nrf_saadc_task_t       task)
243  {
244      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
245  }
246  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg, nrf_saadc_event_t event)
247  {
248      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
249  }
250  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
251  {
252      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
253  #if __CORTEX_M == 0x04
254      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
255      (void)dummy;
256  #endif
257  }
258  NRF_STATIC_INLINE uint32_t  nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
259                                                          nrf_saadc_event_t      event)
260  {
261      return (uint32_t )((uint8_t *)p_reg + (uint32_t)event);
262  }
263  #if defined(DPPI_PRESENT)
264  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
265                                                 nrf_saadc_task_t task,
266                                                 uint8_t          channel)
267  {
268      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
269              ((uint32_t)channel | SAADC_SUBSCRIBE_START_EN_Msk);
270  }
271  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
272  {
273      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
274  }
275  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
276                                               nrf_saadc_event_t event,
277                                               uint8_t           channel)
278  {
279      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
280              ((uint32_t)channel | SAADC_PUBLISH_STARTED_EN_Msk);
281  }
282  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
283  {
284      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
285  }
286  #endif 
287  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
288                                                                nrf_saadc_limit_t limit_type)
289  {
290      if (limit_type == NRF_SAADC_LIMIT_HIGH)
291      {
292          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITH);
293      }
294      else
295      {
296          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITL);
297      }
298  }
299  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
300                                                     uint8_t           channel,
301                                                     nrf_saadc_input_t pselp,
302                                                     nrf_saadc_input_t pseln)
303  {
304      p_reg->CH[channel].PSELN = pseln;
305      p_reg->CH[channel].PSELP = pselp;
306  }
307  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
308                                                         uint8_t           channel,
309                                                         nrf_saadc_input_t pselp)
310  {
311      p_reg->CH[channel].PSELP = pselp;
312  }
313  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
314                                                      uint8_t          channel,
315                                                      int16_t          low,
316                                                      int16_t          high)
317  {
318      p_reg->CH[channel].LIMIT = (
319              (((uint32_t) low << SAADC_CH_LIMIT_LOW_Pos) & SAADC_CH_LIMIT_LOW_Msk)
320            | (((uint32_t) high << SAADC_CH_LIMIT_HIGH_Pos) & SAADC_CH_LIMIT_HIGH_Msk));
321  }
322  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask)
323  {
324      p_reg->INTEN = mask;
325  }
326  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask)
327  {
328      p_reg->INTENSET = mask;
329  }
330  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask)
331  {
332      return p_reg->INTENSET & mask;
333  }
334  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask)
335  {
336      p_reg->INTENCLR = mask;
337  }
338  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
339                                                     nrf_saadc_limit_t limit_type)
340  {
341      NRFX_ASSERT(channel < SAADC_CH_NUM);
342      uint32_t mask = (limit_type == NRF_SAADC_LIMIT_LOW) ?
343                       NRF_SAADC_INT_CH0LIMITL : NRF_SAADC_INT_CH0LIMITH;
344      return mask << (channel * 2);
345  }
346  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg)
347  {
348      return (p_reg->STATUS == (SAADC_STATUS_STATUS_Busy << SAADC_STATUS_STATUS_Pos));
349  }
350  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg)
351  {
352      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos);
353  }
354  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg)
355  {
356      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Disabled << SAADC_ENABLE_ENABLE_Pos);
357  }
358  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg)
359  {
360      return (p_reg->ENABLE == (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos));
361  }
362  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
363                                               nrf_saadc_value_t * p_buffer,
364                                               uint32_t            size)
365  {
366      p_reg->RESULT.PTR = (uint32_t)p_buffer;
367      p_reg->RESULT.MAXCNT = size;
368  }
369  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
370                                                      nrf_saadc_value_t * p_buffer)
371  {
372      p_reg->RESULT.PTR = (uint32_t)p_buffer;
373  }
374  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg)
375  {
376      return (nrf_saadc_value_t *)p_reg->RESULT.PTR;
377  }
378  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg)
379  {
380      return p_reg->RESULT.AMOUNT;
381  }
382  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
383                                                  nrf_saadc_resolution_t resolution)
384  {
385      p_reg->RESOLUTION = resolution;
386  }
387  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg)
388  {
389      return (nrf_saadc_resolution_t)p_reg->RESOLUTION;
390  }
391  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
392                                                  nrf_saadc_oversample_t oversample)
393  {
394      p_reg->OVERSAMPLE = oversample;
395  }
396  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg)
397  {
398      return (nrf_saadc_oversample_t)p_reg->OVERSAMPLE;
399  }
400  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample)
401  {
402      return (1 << (uint32_t)oversample);
403  }
404  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg, uint16_t cc)
405  {
406      NRFX_ASSERT((cc >= 80) && (cc <= 2047));
407      p_reg->SAMPLERATE = (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos)
408                          | ((uint32_t)cc << SAADC_SAMPLERATE_CC_Pos);
409  }
410  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg)
411  {
412      return (bool)((p_reg->SAMPLERATE & SAADC_SAMPLERATE_MODE_Msk)
413                     == (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos));
414  }
415  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg)
416  {
417      p_reg->SAMPLERATE = SAADC_SAMPLERATE_MODE_Task << SAADC_SAMPLERATE_MODE_Pos;
418  }
419  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
420                                                uint8_t                            channel,
421                                                nrf_saadc_channel_config_t const * config)
422  {
423      p_reg->CH[channel].CONFIG =
424              ((config->resistor_p   << SAADC_CH_CONFIG_RESP_Pos)   & SAADC_CH_CONFIG_RESP_Msk)
425              | ((config->resistor_n << SAADC_CH_CONFIG_RESN_Pos)   & SAADC_CH_CONFIG_RESN_Msk)
426              | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
427              | ((config->reference  << SAADC_CH_CONFIG_REFSEL_Pos) & SAADC_CH_CONFIG_REFSEL_Msk)
428              | ((config->acq_time   << SAADC_CH_CONFIG_TACQ_Pos)   & SAADC_CH_CONFIG_TACQ_Msk)
429              | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk)
430              | ((config->burst      << SAADC_CH_CONFIG_BURST_Pos)  & SAADC_CH_CONFIG_BURST_Msk);
431  }
432  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
433                                             uint8_t           channel,
434                                             nrf_saadc_burst_t burst)
435  {
436      p_reg->CH[channel].CONFIG = (p_reg->CH[channel].CONFIG & ~SAADC_CH_CONFIG_BURST_Msk) |
437                                  (burst << SAADC_CH_CONFIG_BURST_Pos);
438  }
439  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution)
440  {
441      uint8_t res_bits = 0;
442      switch (resolution)
443      {
444          case NRF_SAADC_RESOLUTION_8BIT:
445              res_bits = 8;
446              break;
447          case NRF_SAADC_RESOLUTION_10BIT:
448              res_bits = 10;
449              break;
450          case NRF_SAADC_RESOLUTION_12BIT:
451              res_bits = 12;
452              break;
453          case NRF_SAADC_RESOLUTION_14BIT:
454              res_bits = 14;
455              break;
456          default:
457              NRFX_ASSERT(false);
458      }
459      return (nrf_saadc_value_t)(-(1 << res_bits));
460  }
461  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution)
462  {
463      uint8_t res_bits = 0;
464      switch (resolution)
465      {
466          case NRF_SAADC_RESOLUTION_8BIT:
467              res_bits = 8;
468              break;
469          case NRF_SAADC_RESOLUTION_10BIT:
470              res_bits = 10;
471              break;
472          case NRF_SAADC_RESOLUTION_12BIT:
473              res_bits = 12;
474              break;
475          case NRF_SAADC_RESOLUTION_14BIT:
476              res_bits = 14;
477              break;
478          default:
479              NRFX_ASSERT(false);
480      }
481      return (nrf_saadc_value_t)((1 << res_bits) - 1);
482  }
483  #endif 
484  #ifdef __cplusplus
485  }
486  #endif
487  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_echo.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include <limits.h>
4  #include "sph_echo.h"
5  #ifdef __cplusplus
6  extern "C"{
7  #endif
8  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_ECHO
9  #define SPH_SMALL_FOOTPRINT_ECHO   1
10  #endif
11  #if !defined SPH_ECHO_64 && SPH_64_TRUE
12  #define SPH_ECHO_64   1
13  #endif
14  #if !SPH_64
15  #undef SPH_ECHO_64
16  #endif
17  #ifdef _MSC_VER
18  #pragma warning (disable: 4146)
19  #endif
20  #define T32   SPH_T32
21  #define C32   SPH_C32
22  #if SPH_64
23  #define C64   SPH_C64
24  #endif
25  #define AES_BIG_ENDIAN   0
26  #include "aes_helper.c"
27  #if SPH_ECHO_64
28  #define DECL_STATE_SMALL   \
29  	sph_u64 W[16][2];
30  #define DECL_STATE_BIG   \
31  	sph_u64 W[16][2];
32  #define INPUT_BLOCK_SMALL(sc)   do { \
33  		unsigned u; \
34  		memcpy(W, sc->u.Vb, 8 * sizeof(sph_u64)); \
35  		for (u = 0; u < 12; u ++) { \
36  			W[u + 4][0] = sph_dec64le_aligned( \
37  				sc->buf + 16 * u); \
38  			W[u + 4][1] = sph_dec64le_aligned( \
39  				sc->buf + 16 * u + 8); \
40  		} \
41  	} while (0)
42  #define INPUT_BLOCK_BIG(sc)   do { \
43  		unsigned u; \
44  		memcpy(W, sc->u.Vb, 16 * sizeof(sph_u64)); \
45  		for (u = 0; u < 8; u ++) { \
46  			W[u + 8][0] = sph_dec64le_aligned( \
47  				sc->buf + 16 * u); \
48  			W[u + 8][1] = sph_dec64le_aligned( \
49  				sc->buf + 16 * u + 8); \
50  		} \
51  	} while (0)
52  #if SPH_SMALL_FOOTPRINT_ECHO
53  static void
54  aes_2rounds_all(sph_u64 W[16][2],
55  	sph_u32 *pK0, sph_u32 *pK1, sph_u32 *pK2, sph_u32 *pK3)
56  {
57  	int n;
58  	sph_u32 K0 = *pK0;
59  	sph_u32 K1 = *pK1;
60  	sph_u32 K2 = *pK2;
61  	sph_u32 K3 = *pK3;
62  	for (n = 0; n < 16; n ++) {
63  		sph_u64 Wl = W[n][0];
64  		sph_u64 Wh = W[n][1];
65  		sph_u32 X0 = (sph_u32)Wl;
66  		sph_u32 X1 = (sph_u32)(Wl >> 32);
67  		sph_u32 X2 = (sph_u32)Wh;
68  		sph_u32 X3 = (sph_u32)(Wh >> 32);
69  		sph_u32 Y0, Y1, Y2, Y3; \
70  		AES_ROUND_LE(X0, X1, X2, X3, K0, K1, K2, K3, Y0, Y1, Y2, Y3);
71  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
72  		W[n][0] = (sph_u64)X0 | ((sph_u64)X1 << 32);
73  		W[n][1] = (sph_u64)X2 | ((sph_u64)X3 << 32);
74  		if ((K0 = T32(K0 + 1)) == 0) {
75  			if ((K1 = T32(K1 + 1)) == 0)
76  				if ((K2 = T32(K2 + 1)) == 0)
77  					K3 = T32(K3 + 1);
78  		}
79  	}
80  	*pK0 = K0;
81  	*pK1 = K1;
82  	*pK2 = K2;
83  	*pK3 = K3;
84  }
85  #define BIG_SUB_WORDS   do { \
86  		aes_2rounds_all(W, &K0, &K1, &K2, &K3); \
87  	} while (0)
88  #else
89  #define AES_2ROUNDS(X)   do { \
90  		sph_u32 X0 = (sph_u32)(X[0]); \
91  		sph_u32 X1 = (sph_u32)(X[0] >> 32); \
92  		sph_u32 X2 = (sph_u32)(X[1]); \
93  		sph_u32 X3 = (sph_u32)(X[1] >> 32); \
94  		sph_u32 Y0, Y1, Y2, Y3; \
95  		AES_ROUND_LE(X0, X1, X2, X3, K0, K1, K2, K3, Y0, Y1, Y2, Y3); \
96  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X0, X1, X2, X3); \
97  		X[0] = (sph_u64)X0 | ((sph_u64)X1 << 32); \
98  		X[1] = (sph_u64)X2 | ((sph_u64)X3 << 32); \
99  		if ((K0 = T32(K0 + 1)) == 0) { \
100  			if ((K1 = T32(K1 + 1)) == 0) \
101  				if ((K2 = T32(K2 + 1)) == 0) \
102  					K3 = T32(K3 + 1); \
103  		} \
104  	} while (0)
105  #define BIG_SUB_WORDS   do { \
106  		AES_2ROUNDS(W[ 0]); \
107  		AES_2ROUNDS(W[ 1]); \
108  		AES_2ROUNDS(W[ 2]); \
109  		AES_2ROUNDS(W[ 3]); \
110  		AES_2ROUNDS(W[ 4]); \
111  		AES_2ROUNDS(W[ 5]); \
112  		AES_2ROUNDS(W[ 6]); \
113  		AES_2ROUNDS(W[ 7]); \
114  		AES_2ROUNDS(W[ 8]); \
115  		AES_2ROUNDS(W[ 9]); \
116  		AES_2ROUNDS(W[10]); \
117  		AES_2ROUNDS(W[11]); \
118  		AES_2ROUNDS(W[12]); \
119  		AES_2ROUNDS(W[13]); \
120  		AES_2ROUNDS(W[14]); \
121  		AES_2ROUNDS(W[15]); \
122  	} while (0)
123  #endif
124  #define SHIFT_ROW1(a, b, c, d)   do { \
125  		sph_u64 tmp; \
126  		tmp = W[a][0]; \
127  		W[a][0] = W[b][0]; \
128  		W[b][0] = W[c][0]; \
129  		W[c][0] = W[d][0]; \
130  		W[d][0] = tmp; \
131  		tmp = W[a][1]; \
132  		W[a][1] = W[b][1]; \
133  		W[b][1] = W[c][1]; \
134  		W[c][1] = W[d][1]; \
135  		W[d][1] = tmp; \
136  	} while (0)
137  #define SHIFT_ROW2(a, b, c, d)   do { \
138  		sph_u64 tmp; \
139  		tmp = W[a][0]; \
140  		W[a][0] = W[c][0]; \
141  		W[c][0] = tmp; \
142  		tmp = W[b][0]; \
143  		W[b][0] = W[d][0]; \
144  		W[d][0] = tmp; \
145  		tmp = W[a][1]; \
146  		W[a][1] = W[c][1]; \
147  		W[c][1] = tmp; \
148  		tmp = W[b][1]; \
149  		W[b][1] = W[d][1]; \
150  		W[d][1] = tmp; \
151  	} while (0)
152  #define SHIFT_ROW3(a, b, c, d)   SHIFT_ROW1(d, c, b, a)
153  #define BIG_SHIFT_ROWS   do { \
154  		SHIFT_ROW1(1, 5, 9, 13); \
155  		SHIFT_ROW2(2, 6, 10, 14); \
156  		SHIFT_ROW3(3, 7, 11, 15); \
157  	} while (0)
158  #if SPH_SMALL_FOOTPRINT_ECHO
159  static void
160  mix_column(sph_u64 W[16][2], int ia, int ib, int ic, int id)
161  {
162  	int n;
163  	for (n = 0; n < 2; n ++) {
164  		sph_u64 a = W[ia][n];
165  		sph_u64 b = W[ib][n];
166  		sph_u64 c = W[ic][n];
167  		sph_u64 d = W[id][n];
168  		sph_u64 ab = a ^ b;
169  		sph_u64 bc = b ^ c;
170  		sph_u64 cd = c ^ d;
171  		sph_u64 abx = ((ab & C64(0x8080808080808080)) >> 7) * 27U
172  			^ ((ab & C64(0x7F7F7F7F7F7F7F7F)) << 1);
173  		sph_u64 bcx = ((bc & C64(0x8080808080808080)) >> 7) * 27U
174  			^ ((bc & C64(0x7F7F7F7F7F7F7F7F)) << 1);
175  		sph_u64 cdx = ((cd & C64(0x8080808080808080)) >> 7) * 27U
176  			^ ((cd & C64(0x7F7F7F7F7F7F7F7F)) << 1);
177  		W[ia][n] = abx ^ bc ^ d;
178  		W[ib][n] = bcx ^ a ^ cd;
179  		W[ic][n] = cdx ^ ab ^ d;
180  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c;
181  	}
182  }
183  #define MIX_COLUMN(a, b, c, d)   mix_column(W, a, b, c, d)
184  #else
185  #define MIX_COLUMN1(ia, ib, ic, id, n)   do { \
186  		sph_u64 a = W[ia][n]; \
187  		sph_u64 b = W[ib][n]; \
188  		sph_u64 c = W[ic][n]; \
189  		sph_u64 d = W[id][n]; \
190  		sph_u64 ab = a ^ b; \
191  		sph_u64 bc = b ^ c; \
192  		sph_u64 cd = c ^ d; \
193  		sph_u64 abx = ((ab & C64(0x8080808080808080)) >> 7) * 27U \
194  			^ ((ab & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
195  		sph_u64 bcx = ((bc & C64(0x8080808080808080)) >> 7) * 27U \
196  			^ ((bc & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
197  		sph_u64 cdx = ((cd & C64(0x8080808080808080)) >> 7) * 27U \
198  			^ ((cd & C64(0x7F7F7F7F7F7F7F7F)) << 1); \
199  		W[ia][n] = abx ^ bc ^ d; \
200  		W[ib][n] = bcx ^ a ^ cd; \
201  		W[ic][n] = cdx ^ ab ^ d; \
202  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c; \
203  	} while (0)
204  #define MIX_COLUMN(a, b, c, d)   do { \
205  		MIX_COLUMN1(a, b, c, d, 0); \
206  		MIX_COLUMN1(a, b, c, d, 1); \
207  	} while (0)
208  #endif
209  #define BIG_MIX_COLUMNS   do { \
210  		MIX_COLUMN(0, 1, 2, 3); \
211  		MIX_COLUMN(4, 5, 6, 7); \
212  		MIX_COLUMN(8, 9, 10, 11); \
213  		MIX_COLUMN(12, 13, 14, 15); \
214  	} while (0)
215  #define BIG_ROUND   do { \
216  		BIG_SUB_WORDS; \
217  		BIG_SHIFT_ROWS; \
218  		BIG_MIX_COLUMNS; \
219  	} while (0)
220  #define FINAL_SMALL   do { \
221  		unsigned u; \
222  		sph_u64 *VV = &sc->u.Vb[0][0]; \
223  		sph_u64 *WW = &W[0][0]; \
224  		for (u = 0; u < 8; u ++) { \
225  			VV[u] ^= sph_dec64le_aligned(sc->buf + (u * 8)) \
226  				^ sph_dec64le_aligned(sc->buf + (u * 8) + 64) \
227  				^ sph_dec64le_aligned(sc->buf + (u * 8) + 128) \
228  				^ WW[u] ^ WW[u + 8] \
229  				^ WW[u + 16] ^ WW[u + 24]; \
230  		} \
231  	} while (0)
232  #define FINAL_BIG   do { \
233  		unsigned u; \
234  		sph_u64 *VV = &sc->u.Vb[0][0]; \
235  		sph_u64 *WW = &W[0][0]; \
236  		for (u = 0; u < 16; u ++) { \
237  			VV[u] ^= sph_dec64le_aligned(sc->buf + (u * 8)) \
238  				^ WW[u] ^ WW[u + 16]; \
239  		} \
240  	} while (0)
241  #define COMPRESS_SMALL(sc)   do { \
242  		sph_u32 K0 = sc->C0; \
243  		sph_u32 K1 = sc->C1; \
244  		sph_u32 K2 = sc->C2; \
245  		sph_u32 K3 = sc->C3; \
246  		unsigned u; \
247  		INPUT_BLOCK_SMALL(sc); \
248  		for (u = 0; u < 8; u ++) { \
249  			BIG_ROUND; \
250  		} \
251  		FINAL_SMALL; \
252  	} while (0)
253  #define COMPRESS_BIG(sc)   do { \
254  		sph_u32 K0 = sc->C0; \
255  		sph_u32 K1 = sc->C1; \
256  		sph_u32 K2 = sc->C2; \
257  		sph_u32 K3 = sc->C3; \
258  		unsigned u; \
259  		INPUT_BLOCK_BIG(sc); \
260  		for (u = 0; u < 10; u ++) { \
261  			BIG_ROUND; \
262  		} \
263  		FINAL_BIG; \
264  	} while (0)
265  #else
266  #define DECL_STATE_SMALL   \
267  	sph_u32 W[16][4];
268  #define DECL_STATE_BIG   \
269  	sph_u32 W[16][4];
270  #define INPUT_BLOCK_SMALL(sc)   do { \
271  		unsigned u; \
272  		memcpy(W, sc->u.Vs, 16 * sizeof(sph_u32)); \
273  		for (u = 0; u < 12; u ++) { \
274  			W[u + 4][0] = sph_dec32le_aligned( \
275  				sc->buf + 16 * u); \
276  			W[u + 4][1] = sph_dec32le_aligned( \
277  				sc->buf + 16 * u + 4); \
278  			W[u + 4][2] = sph_dec32le_aligned( \
279  				sc->buf + 16 * u + 8); \
280  			W[u + 4][3] = sph_dec32le_aligned( \
281  				sc->buf + 16 * u + 12); \
282  		} \
283  	} while (0)
284  #define INPUT_BLOCK_BIG(sc)   do { \
285  		unsigned u; \
286  		memcpy(W, sc->u.Vs, 32 * sizeof(sph_u32)); \
287  		for (u = 0; u < 8; u ++) { \
288  			W[u + 8][0] = sph_dec32le_aligned( \
289  				sc->buf + 16 * u); \
290  			W[u + 8][1] = sph_dec32le_aligned( \
291  				sc->buf + 16 * u + 4); \
292  			W[u + 8][2] = sph_dec32le_aligned( \
293  				sc->buf + 16 * u + 8); \
294  			W[u + 8][3] = sph_dec32le_aligned( \
295  				sc->buf + 16 * u + 12); \
296  		} \
297  	} while (0)
298  #if SPH_SMALL_FOOTPRINT_ECHO
299  static void
300  aes_2rounds_all(sph_u32 W[16][4],
301  	sph_u32 *pK0, sph_u32 *pK1, sph_u32 *pK2, sph_u32 *pK3)
302  {
303  	int n;
304  	sph_u32 K0 = *pK0;
305  	sph_u32 K1 = *pK1;
306  	sph_u32 K2 = *pK2;
307  	sph_u32 K3 = *pK3;
308  	for (n = 0; n < 16; n ++) {
309  		sph_u32 *X = W[n];
310  		sph_u32 Y0, Y1, Y2, Y3;
311  		AES_ROUND_LE(X[0], X[1], X[2], X[3],
312  			K0, K1, K2, K3, Y0, Y1, Y2, Y3);
313  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X[0], X[1], X[2], X[3]);
314  		if ((K0 = T32(K0 + 1)) == 0) {
315  			if ((K1 = T32(K1 + 1)) == 0)
316  				if ((K2 = T32(K2 + 1)) == 0)
317  					K3 = T32(K3 + 1);
318  		}
319  	}
320  	*pK0 = K0;
321  	*pK1 = K1;
322  	*pK2 = K2;
323  	*pK3 = K3;
324  }
325  #define BIG_SUB_WORDS   do { \
326  		aes_2rounds_all(W, &K0, &K1, &K2, &K3); \
327  	} while (0)
328  #else
329  #define AES_2ROUNDS(X)   do { \
330  		sph_u32 Y0, Y1, Y2, Y3; \
331  		AES_ROUND_LE(X[0], X[1], X[2], X[3], \
332  			K0, K1, K2, K3, Y0, Y1, Y2, Y3); \
333  		AES_ROUND_NOKEY_LE(Y0, Y1, Y2, Y3, X[0], X[1], X[2], X[3]); \
334  		if ((K0 = T32(K0 + 1)) == 0) { \
335  			if ((K1 = T32(K1 + 1)) == 0) \
336  				if ((K2 = T32(K2 + 1)) == 0) \
337  					K3 = T32(K3 + 1); \
338  		} \
339  	} while (0)
340  #define BIG_SUB_WORDS   do { \
341  		AES_2ROUNDS(W[ 0]); \
342  		AES_2ROUNDS(W[ 1]); \
343  		AES_2ROUNDS(W[ 2]); \
344  		AES_2ROUNDS(W[ 3]); \
345  		AES_2ROUNDS(W[ 4]); \
346  		AES_2ROUNDS(W[ 5]); \
347  		AES_2ROUNDS(W[ 6]); \
348  		AES_2ROUNDS(W[ 7]); \
349  		AES_2ROUNDS(W[ 8]); \
350  		AES_2ROUNDS(W[ 9]); \
351  		AES_2ROUNDS(W[10]); \
352  		AES_2ROUNDS(W[11]); \
353  		AES_2ROUNDS(W[12]); \
354  		AES_2ROUNDS(W[13]); \
355  		AES_2ROUNDS(W[14]); \
356  		AES_2ROUNDS(W[15]); \
357  	} while (0)
358  #endif
359  #define SHIFT_ROW1(a, b, c, d)   do { \
360  		sph_u32 tmp; \
361  		tmp = W[a][0]; \
362  		W[a][0] = W[b][0]; \
363  		W[b][0] = W[c][0]; \
364  		W[c][0] = W[d][0]; \
365  		W[d][0] = tmp; \
366  		tmp = W[a][1]; \
367  		W[a][1] = W[b][1]; \
368  		W[b][1] = W[c][1]; \
369  		W[c][1] = W[d][1]; \
370  		W[d][1] = tmp; \
371  		tmp = W[a][2]; \
372  		W[a][2] = W[b][2]; \
373  		W[b][2] = W[c][2]; \
374  		W[c][2] = W[d][2]; \
375  		W[d][2] = tmp; \
376  		tmp = W[a][3]; \
377  		W[a][3] = W[b][3]; \
378  		W[b][3] = W[c][3]; \
379  		W[c][3] = W[d][3]; \
380  		W[d][3] = tmp; \
381  	} while (0)
382  #define SHIFT_ROW2(a, b, c, d)   do { \
383  		sph_u32 tmp; \
384  		tmp = W[a][0]; \
385  		W[a][0] = W[c][0]; \
386  		W[c][0] = tmp; \
387  		tmp = W[b][0]; \
388  		W[b][0] = W[d][0]; \
389  		W[d][0] = tmp; \
390  		tmp = W[a][1]; \
391  		W[a][1] = W[c][1]; \
392  		W[c][1] = tmp; \
393  		tmp = W[b][1]; \
394  		W[b][1] = W[d][1]; \
395  		W[d][1] = tmp; \
396  		tmp = W[a][2]; \
397  		W[a][2] = W[c][2]; \
398  		W[c][2] = tmp; \
399  		tmp = W[b][2]; \
400  		W[b][2] = W[d][2]; \
401  		W[d][2] = tmp; \
402  		tmp = W[a][3]; \
403  		W[a][3] = W[c][3]; \
404  		W[c][3] = tmp; \
405  		tmp = W[b][3]; \
406  		W[b][3] = W[d][3]; \
407  		W[d][3] = tmp; \
408  	} while (0)
409  #define SHIFT_ROW3(a, b, c, d)   SHIFT_ROW1(d, c, b, a)
410  #define BIG_SHIFT_ROWS   do { \
411  		SHIFT_ROW1(1, 5, 9, 13); \
412  		SHIFT_ROW2(2, 6, 10, 14); \
413  		SHIFT_ROW3(3, 7, 11, 15); \
414  	} while (0)
415  #if SPH_SMALL_FOOTPRINT_ECHO
416  static void
417  mix_column(sph_u32 W[16][4], int ia, int ib, int ic, int id)
418  {
419  	int n;
<span onclick='openModal()' class='match'>420  	for (n = 0; n < 4; n ++) {
421  		sph_u32 a = W[ia][n];
422  		sph_u32 b = W[ib][n];
423  		sph_u32 c = W[ic][n];
424  		sph_u32 d = W[id][n];
425  		sph_u32 ab = a ^ b;
426  		sph_u32 bc = b ^ c;
427  		sph_u32 cd = c ^ d;
428  		sph_u32 abx = ((ab & C32(0x80808080)) >> 7) * 27U
429  			^ ((ab & C32(0x7F7F7F7F)) << 1);
430  		sph_u32 bcx = ((bc & C32(0x80808080)) >> 7) * 27U
</span>431  			^ ((bc & C32(0x7F7F7F7F)) << 1);
432  		sph_u32 cdx = ((cd & C32(0x80808080)) >> 7) * 27U
433  			^ ((cd & C32(0x7F7F7F7F)) << 1);
434  		W[ia][n] = abx ^ bc ^ d;
435  		W[ib][n] = bcx ^ a ^ cd;
436  		W[ic][n] = cdx ^ ab ^ d;
437  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c;
438  	}
439  }
440  #define MIX_COLUMN(a, b, c, d)   mix_column(W, a, b, c, d)
441  #else
442  #define MIX_COLUMN1(ia, ib, ic, id, n)   do { \
443  		sph_u32 a = W[ia][n]; \
444  		sph_u32 b = W[ib][n]; \
445  		sph_u32 c = W[ic][n]; \
446  		sph_u32 d = W[id][n]; \
447  		sph_u32 ab = a ^ b; \
448  		sph_u32 bc = b ^ c; \
449  		sph_u32 cd = c ^ d; \
450  		sph_u32 abx = ((ab & C32(0x80808080)) >> 7) * 27U \
451  			^ ((ab & C32(0x7F7F7F7F)) << 1); \
452  		sph_u32 bcx = ((bc & C32(0x80808080)) >> 7) * 27U \
453  			^ ((bc & C32(0x7F7F7F7F)) << 1); \
454  		sph_u32 cdx = ((cd & C32(0x80808080)) >> 7) * 27U \
455  			^ ((cd & C32(0x7F7F7F7F)) << 1); \
456  		W[ia][n] = abx ^ bc ^ d; \
457  		W[ib][n] = bcx ^ a ^ cd; \
458  		W[ic][n] = cdx ^ ab ^ d; \
459  		W[id][n] = abx ^ bcx ^ cdx ^ ab ^ c; \
460  	} while (0)
461  #define MIX_COLUMN(a, b, c, d)   do { \
462  		MIX_COLUMN1(a, b, c, d, 0); \
463  		MIX_COLUMN1(a, b, c, d, 1); \
464  		MIX_COLUMN1(a, b, c, d, 2); \
465  		MIX_COLUMN1(a, b, c, d, 3); \
466  	} while (0)
467  #endif
468  #define BIG_MIX_COLUMNS   do { \
469  		MIX_COLUMN(0, 1, 2, 3); \
470  		MIX_COLUMN(4, 5, 6, 7); \
471  		MIX_COLUMN(8, 9, 10, 11); \
472  		MIX_COLUMN(12, 13, 14, 15); \
473  	} while (0)
474  #define BIG_ROUND   do { \
475  		BIG_SUB_WORDS; \
476  		BIG_SHIFT_ROWS; \
477  		BIG_MIX_COLUMNS; \
478  	} while (0)
479  #define FINAL_SMALL   do { \
480  		unsigned u; \
481  		sph_u32 *VV = &sc->u.Vs[0][0]; \
482  		sph_u32 *WW = &W[0][0]; \
483  		for (u = 0; u < 16; u ++) { \
484  			VV[u] ^= sph_dec32le_aligned(sc->buf + (u * 4)) \
485  				^ sph_dec32le_aligned(sc->buf + (u * 4) + 64) \
486  				^ sph_dec32le_aligned(sc->buf + (u * 4) + 128) \
487  				^ WW[u] ^ WW[u + 16] \
488  				^ WW[u + 32] ^ WW[u + 48]; \
489  		} \
490  	} while (0)
491  #define FINAL_BIG   do { \
492  		unsigned u; \
493  		sph_u32 *VV = &sc->u.Vs[0][0]; \
494  		sph_u32 *WW = &W[0][0]; \
495  		for (u = 0; u < 32; u ++) { \
496  			VV[u] ^= sph_dec32le_aligned(sc->buf + (u * 4)) \
497  				^ WW[u] ^ WW[u + 32]; \
498  		} \
499  	} while (0)
500  #define COMPRESS_SMALL(sc)   do { \
501  		sph_u32 K0 = sc->C0; \
502  		sph_u32 K1 = sc->C1; \
503  		sph_u32 K2 = sc->C2; \
504  		sph_u32 K3 = sc->C3; \
505  		unsigned u; \
506  		INPUT_BLOCK_SMALL(sc); \
507  		for (u = 0; u < 8; u ++) { \
508  			BIG_ROUND; \
509  		} \
510  		FINAL_SMALL; \
511  	} while (0)
512  #define COMPRESS_BIG(sc)   do { \
513  		sph_u32 K0 = sc->C0; \
514  		sph_u32 K1 = sc->C1; \
515  		sph_u32 K2 = sc->C2; \
516  		sph_u32 K3 = sc->C3; \
517  		unsigned u; \
518  		INPUT_BLOCK_BIG(sc); \
519  		for (u = 0; u < 10; u ++) { \
520  			BIG_ROUND; \
521  		} \
522  		FINAL_BIG; \
523  	} while (0)
524  #endif
525  #define INCR_COUNTER(sc, val)   do { \
526  		sc->C0 = T32(sc->C0 + (sph_u32)(val)); \
527  		if (sc->C0 < (sph_u32)(val)) { \
528  			if ((sc->C1 = T32(sc->C1 + 1)) == 0) \
529  				if ((sc->C2 = T32(sc->C2 + 1)) == 0) \
530  					sc->C3 = T32(sc->C3 + 1); \
531  		} \
532  	} while (0)
533  static void
534  echo_small_init(sph_echo_small_context *sc, unsigned out_len)
535  {
536  #if SPH_ECHO_64
537  	sc->u.Vb[0][0] = (sph_u64)out_len;
538  	sc->u.Vb[0][1] = 0;
539  	sc->u.Vb[1][0] = (sph_u64)out_len;
540  	sc->u.Vb[1][1] = 0;
541  	sc->u.Vb[2][0] = (sph_u64)out_len;
542  	sc->u.Vb[2][1] = 0;
543  	sc->u.Vb[3][0] = (sph_u64)out_len;
544  	sc->u.Vb[3][1] = 0;
545  #else
546  	sc->u.Vs[0][0] = (sph_u32)out_len;
547  	sc->u.Vs[0][1] = sc->u.Vs[0][2] = sc->u.Vs[0][3] = 0;
548  	sc->u.Vs[1][0] = (sph_u32)out_len;
549  	sc->u.Vs[1][1] = sc->u.Vs[1][2] = sc->u.Vs[1][3] = 0;
550  	sc->u.Vs[2][0] = (sph_u32)out_len;
551  	sc->u.Vs[2][1] = sc->u.Vs[2][2] = sc->u.Vs[2][3] = 0;
552  	sc->u.Vs[3][0] = (sph_u32)out_len;
553  	sc->u.Vs[3][1] = sc->u.Vs[3][2] = sc->u.Vs[3][3] = 0;
554  #endif
555  	sc->ptr = 0;
556  	sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
557  }
558  static void
559  echo_big_init(sph_echo_big_context *sc, unsigned out_len)
560  {
561  #if SPH_ECHO_64
562  	sc->u.Vb[0][0] = (sph_u64)out_len;
563  	sc->u.Vb[0][1] = 0;
564  	sc->u.Vb[1][0] = (sph_u64)out_len;
565  	sc->u.Vb[1][1] = 0;
566  	sc->u.Vb[2][0] = (sph_u64)out_len;
567  	sc->u.Vb[2][1] = 0;
568  	sc->u.Vb[3][0] = (sph_u64)out_len;
569  	sc->u.Vb[3][1] = 0;
570  	sc->u.Vb[4][0] = (sph_u64)out_len;
571  	sc->u.Vb[4][1] = 0;
572  	sc->u.Vb[5][0] = (sph_u64)out_len;
573  	sc->u.Vb[5][1] = 0;
574  	sc->u.Vb[6][0] = (sph_u64)out_len;
575  	sc->u.Vb[6][1] = 0;
576  	sc->u.Vb[7][0] = (sph_u64)out_len;
577  	sc->u.Vb[7][1] = 0;
578  #else
579  	sc->u.Vs[0][0] = (sph_u32)out_len;
580  	sc->u.Vs[0][1] = sc->u.Vs[0][2] = sc->u.Vs[0][3] = 0;
581  	sc->u.Vs[1][0] = (sph_u32)out_len;
582  	sc->u.Vs[1][1] = sc->u.Vs[1][2] = sc->u.Vs[1][3] = 0;
583  	sc->u.Vs[2][0] = (sph_u32)out_len;
584  	sc->u.Vs[2][1] = sc->u.Vs[2][2] = sc->u.Vs[2][3] = 0;
585  	sc->u.Vs[3][0] = (sph_u32)out_len;
586  	sc->u.Vs[3][1] = sc->u.Vs[3][2] = sc->u.Vs[3][3] = 0;
587  	sc->u.Vs[4][0] = (sph_u32)out_len;
588  	sc->u.Vs[4][1] = sc->u.Vs[4][2] = sc->u.Vs[4][3] = 0;
589  	sc->u.Vs[5][0] = (sph_u32)out_len;
590  	sc->u.Vs[5][1] = sc->u.Vs[5][2] = sc->u.Vs[5][3] = 0;
591  	sc->u.Vs[6][0] = (sph_u32)out_len;
592  	sc->u.Vs[6][1] = sc->u.Vs[6][2] = sc->u.Vs[6][3] = 0;
593  	sc->u.Vs[7][0] = (sph_u32)out_len;
594  	sc->u.Vs[7][1] = sc->u.Vs[7][2] = sc->u.Vs[7][3] = 0;
595  #endif
596  	sc->ptr = 0;
597  	sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
598  }
599  static void
600  echo_small_compress(sph_echo_small_context *sc)
601  {
602  	DECL_STATE_SMALL
603  	COMPRESS_SMALL(sc);
604  }
605  static void
606  echo_big_compress(sph_echo_big_context *sc)
607  {
608  	DECL_STATE_BIG
609  	COMPRESS_BIG(sc);
610  }
611  static void
612  echo_small_core(sph_echo_small_context *sc,
613  	const unsigned char *data, size_t len)
614  {
615  	unsigned char *buf;
616  	size_t ptr;
617  	buf = sc->buf;
618  	ptr = sc->ptr;
619  	if (len < (sizeof sc->buf) - ptr) {
620  		memcpy(buf + ptr, data, len);
621  		ptr += len;
622  		sc->ptr = ptr;
623  		return;
624  	}
625  	while (len > 0) {
626  		size_t clen;
627  		clen = (sizeof sc->buf) - ptr;
628  		if (clen > len)
629  			clen = len;
630  		memcpy(buf + ptr, data, clen);
631  		ptr += clen;
632  		data += clen;
633  		len -= clen;
634  		if (ptr == sizeof sc->buf) {
635  			INCR_COUNTER(sc, 1536);
636  			echo_small_compress(sc);
637  			ptr = 0;
638  		}
639  	}
640  	sc->ptr = ptr;
641  }
642  static void
643  echo_big_core(sph_echo_big_context *sc,
644  	const unsigned char *data, size_t len)
645  {
646  	unsigned char *buf;
647  	size_t ptr;
648  	buf = sc->buf;
649  	ptr = sc->ptr;
650  	if (len < (sizeof sc->buf) - ptr) {
651  		memcpy(buf + ptr, data, len);
652  		ptr += len;
653  		sc->ptr = ptr;
654  		return;
655  	}
656  	while (len > 0) {
657  		size_t clen;
658  		clen = (sizeof sc->buf) - ptr;
659  		if (clen > len)
660  			clen = len;
661  		memcpy(buf + ptr, data, clen);
662  		ptr += clen;
663  		data += clen;
664  		len -= clen;
665  		if (ptr == sizeof sc->buf) {
666  			INCR_COUNTER(sc, 1024);
667  			echo_big_compress(sc);
668  			ptr = 0;
669  		}
670  	}
671  	sc->ptr = ptr;
672  }
673  static void
674  echo_small_close(sph_echo_small_context *sc, unsigned ub, unsigned n,
675  	void *dst, unsigned out_size_w32)
676  {
677  	unsigned char *buf;
678  	size_t ptr;
679  	unsigned z;
680  	unsigned elen;
681  	union {
682  		unsigned char tmp[32];
683  		sph_u32 dummy;
684  #if SPH_ECHO_64
685  		sph_u64 dummy2;
686  #endif
687  	} u;
688  #if SPH_ECHO_64
689  	sph_u64 *VV;
690  #else
691  	sph_u32 *VV;
692  #endif
693  	unsigned k;
694  	buf = sc->buf;
695  	ptr = sc->ptr;
696  	elen = ((unsigned)ptr << 3) + n;
697  	INCR_COUNTER(sc, elen);
698  	sph_enc32le_aligned(u.tmp, sc->C0);
699  	sph_enc32le_aligned(u.tmp + 4, sc->C1);
700  	sph_enc32le_aligned(u.tmp + 8, sc->C2);
701  	sph_enc32le_aligned(u.tmp + 12, sc->C3);
702  	if (elen == 0) {
703  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
704  	}
705  	z = 0x80 >> n;
706  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
707  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
708  	if (ptr > ((sizeof sc->buf) - 18)) {
709  		echo_small_compress(sc);
710  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
711  		memset(buf, 0, sizeof sc->buf);
712  	}
713  	sph_enc16le(buf + (sizeof sc->buf) - 18, out_size_w32 << 5);
714  	memcpy(buf + (sizeof sc->buf) - 16, u.tmp, 16);
715  	echo_small_compress(sc);
716  #if SPH_ECHO_64
717  	for (VV = &sc->u.Vb[0][0], k = 0; k < ((out_size_w32 + 1) >> 1); k ++)
718  		sph_enc64le_aligned(u.tmp + (k << 3), VV[k]);
719  #else
720  	for (VV = &sc->u.Vs[0][0], k = 0; k < out_size_w32; k ++)
721  		sph_enc32le_aligned(u.tmp + (k << 2), VV[k]);
722  #endif
723  	memcpy(dst, u.tmp, out_size_w32 << 2);
724  	echo_small_init(sc, out_size_w32 << 5);
725  }
726  static void
727  echo_big_close(sph_echo_big_context *sc, unsigned ub, unsigned n,
728  	void *dst, unsigned out_size_w32)
729  {
730  	unsigned char *buf;
731  	size_t ptr;
732  	unsigned z;
733  	unsigned elen;
734  	union {
735  		unsigned char tmp[64];
736  		sph_u32 dummy;
737  #if SPH_ECHO_64
738  		sph_u64 dummy2;
739  #endif
740  	} u;
741  #if SPH_ECHO_64
742  	sph_u64 *VV;
743  #else
744  	sph_u32 *VV;
745  #endif
746  	unsigned k;
747  	buf = sc->buf;
748  	ptr = sc->ptr;
749  	elen = ((unsigned)ptr << 3) + n;
750  	INCR_COUNTER(sc, elen);
751  	sph_enc32le_aligned(u.tmp, sc->C0);
752  	sph_enc32le_aligned(u.tmp + 4, sc->C1);
753  	sph_enc32le_aligned(u.tmp + 8, sc->C2);
754  	sph_enc32le_aligned(u.tmp + 12, sc->C3);
755  	if (elen == 0) {
756  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
757  	}
758  	z = 0x80 >> n;
759  	buf[ptr ++] = ((ub & -z) | z) & 0xFF;
760  	memset(buf + ptr, 0, (sizeof sc->buf) - ptr);
761  	if (ptr > ((sizeof sc->buf) - 18)) {
762  		echo_big_compress(sc);
763  		sc->C0 = sc->C1 = sc->C2 = sc->C3 = 0;
764  		memset(buf, 0, sizeof sc->buf);
765  	}
766  	sph_enc16le(buf + (sizeof sc->buf) - 18, out_size_w32 << 5);
767  	memcpy(buf + (sizeof sc->buf) - 16, u.tmp, 16);
768  	echo_big_compress(sc);
769  #if SPH_ECHO_64
770  	for (VV = &sc->u.Vb[0][0], k = 0; k < ((out_size_w32 + 1) >> 1); k ++)
771  		sph_enc64le_aligned(u.tmp + (k << 3), VV[k]);
772  #else
773  	for (VV = &sc->u.Vs[0][0], k = 0; k < out_size_w32; k ++)
774  		sph_enc32le_aligned(u.tmp + (k << 2), VV[k]);
775  #endif
776  	memcpy(dst, u.tmp, out_size_w32 << 2);
777  	echo_big_init(sc, out_size_w32 << 5);
778  }
779  void
780  sph_echo224_init(void *cc)
781  {
782  	echo_small_init(cc, 224);
783  }
784  void
785  sph_echo224(void *cc, const void *data, size_t len)
786  {
787  	echo_small_core(cc, data, len);
788  }
789  void
790  sph_echo224_close(void *cc, void *dst)
791  {
792  	echo_small_close(cc, 0, 0, dst, 7);
793  }
794  void
795  sph_echo224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
796  {
797  	echo_small_close(cc, ub, n, dst, 7);
798  }
799  void
800  sph_echo256_init(void *cc)
801  {
802  	echo_small_init(cc, 256);
803  }
804  void
805  sph_echo256(void *cc, const void *data, size_t len)
806  {
807  	echo_small_core(cc, data, len);
808  }
809  void
810  sph_echo256_close(void *cc, void *dst)
811  {
812  	echo_small_close(cc, 0, 0, dst, 8);
813  }
814  void
815  sph_echo256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
816  {
817  	echo_small_close(cc, ub, n, dst, 8);
818  }
819  void
820  sph_echo384_init(void *cc)
821  {
822  	echo_big_init(cc, 384);
823  }
824  void
825  sph_echo384(void *cc, const void *data, size_t len)
826  {
827  	echo_big_core(cc, data, len);
828  }
829  void
830  sph_echo384_close(void *cc, void *dst)
831  {
832  	echo_big_close(cc, 0, 0, dst, 12);
833  }
834  void
835  sph_echo384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
836  {
837  	echo_big_close(cc, ub, n, dst, 12);
838  }
839  void
840  sph_echo512_init(void *cc)
841  {
842  	echo_big_init(cc, 512);
843  }
844  void
845  sph_echo512(void *cc, const void *data, size_t len)
846  {
847  	echo_big_core(cc, data, len);
848  }
849  void
850  sph_echo512_close(void *cc, void *dst)
851  {
852  	echo_big_close(cc, 0, 0, dst, 16);
853  }
854  void
855  sph_echo512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
856  {
857  	echo_big_close(cc, ub, n, dst, 16);
858  }
859  #ifdef __cplusplus
860  }
861  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_echo.c</div>
                </div>
                <div class="column column_space"><pre><code>31  {
32      NRF_SAADC_OVERSAMPLE_DISABLED = SAADC_OVERSAMPLE_OVERSAMPLE_Bypass,   
33      NRF_SAADC_OVERSAMPLE_2X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over2x,   
34      NRF_SAADC_OVERSAMPLE_4X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over4x,   
35      NRF_SAADC_OVERSAMPLE_8X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over8x,   
36      NRF_SAADC_OVERSAMPLE_16X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over16x,  
37      NRF_SAADC_OVERSAMPLE_32X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over32x,  
38      NRF_SAADC_OVERSAMPLE_64X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over64x,  
39      NRF_SAADC_OVERSAMPLE_128X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over128x, 
40      NRF_SAADC_OVERSAMPLE_256X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over256x  
</pre></code></div>
                <div class="column column_space"><pre><code>420  	for (n = 0; n < 4; n ++) {
421  		sph_u32 a = W[ia][n];
422  		sph_u32 b = W[ib][n];
423  		sph_u32 c = W[ic][n];
424  		sph_u32 d = W[id][n];
425  		sph_u32 ab = a ^ b;
426  		sph_u32 bc = b ^ c;
427  		sph_u32 cd = c ^ d;
428  		sph_u32 abx = ((ab & C32(0x80808080)) >> 7) * 27U
429  			^ ((ab & C32(0x7F7F7F7F)) << 1);
430  		sph_u32 bcx = ((bc & C32(0x80808080)) >> 7) * 27U
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    