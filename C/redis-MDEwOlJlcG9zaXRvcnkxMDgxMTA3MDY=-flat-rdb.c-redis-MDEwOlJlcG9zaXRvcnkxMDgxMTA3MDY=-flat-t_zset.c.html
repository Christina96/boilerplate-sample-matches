
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "lzf.h"    &bsol;* LZF compression library */
7  #include "zipmap.h"
8  #include "endianconv.h"
9  #include "stream.h"
10  #include <math.h>
11  #include <sys/types.h>
12  #ifdef _WIN32
13  #include <stdio.h>
14  #include "Win32_Interop/Win32_QFork.h"
15  #include <direct.h>
16  #define MAXPATHLEN 1024
17  #else
18  #include <sys/time.h>
19  #include <sys/resource.h>
20  #include <sys/wait.h>
21  #include <arpa/inet.h>
22  #endif
23  #include <sys/stat.h>
24  #ifndef _WIN32
25  #include <sys/param.h>
26  #endif
27  #define rdbExitReportCorruptRDB(...) rdbCheckThenExit(__LINE__,__VA_ARGS__)
28  extern int rdbCheckMode;
29  void rdbCheckError(const char *fmt, ...);
30  void rdbCheckSetError(const char *fmt, ...);
31  WIN32_ONLY(__declspec(noreturn))
32  void rdbCheckThenExit(int linenum, char *reason, ...) {
33      va_list ap;
34      char msg[1024];
35      int len;
36      len = snprintf(msg,sizeof(msg),
37          "Internal error in RDB reading function at rdb.c:%d -> ", linenum);
38      va_start(ap,reason);
39      vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
40      va_end(ap);
41      if (!rdbCheckMode) {
42          serverLog(LL_WARNING, "%s", msg);
43          char *argv[2] = {"",server.rdb_filename};
44          redis_check_rdb_main(2,argv,NULL);
45      } else {
46          rdbCheckError("%s",msg);
47      }
48      exit(1);
49  }
50  static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
51      if (rdb && rioWrite(rdb,p,len) == 0)
52          return -1;
53      return (int)len;                  WIN_PORT_FIX &bsol;* cast (int) */
54  }
55  void rdbLoadRaw(rio *rdb, void *buf, uint64_t len) {
56      if (rioRead(rdb,buf,len) == 0) {
57          rdbExitReportCorruptRDB(
58              "Impossible to read %llu bytes in rdbLoadRaw()",
59              (PORT_ULONGLONG) len);
60          return; &bsol;* Not reached. */
61      }
62  }
63  int rdbSaveType(rio *rdb, unsigned char type) {
64      return rdbWriteRaw(rdb,&type,1);
65  }
66  int rdbLoadType(rio *rdb) {
67      unsigned char type;
68      if (rioRead(rdb,&type,1) == 0) return -1;
69      return type;
70  }
71  time_t rdbLoadTime(rio *rdb) {
72      int32_t t32;
73      rdbLoadRaw(rdb,&t32,4);
74      return (time_t)t32;
75  }
76  int rdbSaveMillisecondTime(rio *rdb, PORT_LONGLONG t) {
77      int64_t t64 = (int64_t) t;
78      memrev64ifbe(&t64); &bsol;* Store in little endian. */
79      return rdbWriteRaw(rdb,&t64,8);
80  }
81  PORT_LONGLONG rdbLoadMillisecondTime(rio *rdb, int rdbver) {
82      int64_t t64;
83      rdbLoadRaw(rdb,&t64,8);
84      if (rdbver >= 9) &bsol;* Check the top comment of this function. */
85          memrev64ifbe(&t64); &bsol;* Convert in big endian if the system is BE. */
86      return (PORT_LONGLONG)t64;
87  }
88  int rdbSaveLen(rio *rdb, uint64_t len) {
89      unsigned char buf[2];
90      size_t nwritten;
91      if (len < (1<<6)) {
92          buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
93          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
94          nwritten = 1;
95      } else if (len < (1<<14)) {
96          buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
97          buf[1] = len&0xFF;
98          if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
99          nwritten = 2;
100      } else if (len <= UINT32_MAX) {
101          buf[0] = RDB_32BITLEN;
102          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
103          uint32_t len32 = htonl(len);
104          if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
105          nwritten = 1+4;
106      } else {
107          buf[0] = RDB_64BITLEN;
108          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
109          len = htonu64(len);
110          if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
111          nwritten = 1+8;
112      }
113      return (int)nwritten;                                                       WIN_PORT_FIX &bsol;* cast (int) */
114  }
115  int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
116      unsigned char buf[2];
117      int type;
118      if (isencoded) *isencoded = 0;
119      if (rioRead(rdb,buf,1) == 0) return -1;
120      type = (buf[0]&0xC0)>>6;
121      if (type == RDB_ENCVAL) {
122          if (isencoded) *isencoded = 1;
123          *lenptr = buf[0]&0x3F;
124      } else if (type == RDB_6BITLEN) {
125          *lenptr = buf[0]&0x3F;
126      } else if (type == RDB_14BITLEN) {
127          if (rioRead(rdb,buf+1,1) == 0) return -1;
128          *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
129      } else if (buf[0] == RDB_32BITLEN) {
130          uint32_t len;
131          if (rioRead(rdb,&len,4) == 0) return -1;
132          *lenptr = ntohl(len);
133      } else if (buf[0] == RDB_64BITLEN) {
134          uint64_t len;
135          if (rioRead(rdb,&len,8) == 0) return -1;
136          *lenptr = ntohu64(len);
137      } else {
138          rdbExitReportCorruptRDB(
139              "Unknown length encoding %d in rdbLoadLen()",type);
140          return -1; &bsol;* Never reached. */
141      }
142      return 0;
143  }
144  uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
145      uint64_t len;
146      if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
147      return len;
148  }
149  int rdbEncodeInteger(PORT_LONGLONG value, unsigned char *enc) {
150      if (value >= -(1<<7) && value <= (1<<7)-1) {
151          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
152          enc[1] = value&0xFF;
153          return 2;
154      } else if (value >= -(1<<15) && value <= (1<<15)-1) {
155          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
156          enc[1] = value&0xFF;
157          enc[2] = (value>>8)&0xFF;
158          return 3;
159      } else if (value >= -((PORT_LONGLONG)1<<31) && value <= ((PORT_LONGLONG)1<<31)-1) {
160          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
161          enc[1] = value&0xFF;
162          enc[2] = (value>>8)&0xFF;
163          enc[3] = (value>>16)&0xFF;
164          enc[4] = (value>>24)&0xFF;
165          return 5;
166      } else {
167          return 0;
168      }
169  }
170  void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
171      int plain = flags & RDB_LOAD_PLAIN;
172      int sds = flags & RDB_LOAD_SDS;
173      int encode = flags & RDB_LOAD_ENC;
174      unsigned char enc[4];
175      PORT_LONGLONG val;
176      if (enctype == RDB_ENC_INT8) {
177          if (rioRead(rdb,enc,1) == 0) return NULL;
178          val = (signed char)enc[0];
179      } else if (enctype == RDB_ENC_INT16) {
180          uint16_t v;
181          if (rioRead(rdb,enc,2) == 0) return NULL;
182          v = enc[0]|(enc[1]<<8);
183          val = (int16_t)v;
184      } else if (enctype == RDB_ENC_INT32) {
185          uint32_t v;
186          if (rioRead(rdb,enc,4) == 0) return NULL;
187          v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
188          val = (int32_t)v;
189      } else {
190          val = 0; &bsol;* anti-warning */
191          rdbExitReportCorruptRDB("Unknown RDB integer encoding type %d",enctype);
192      }
193      if (plain || sds) {
194          char buf[LONG_STR_SIZE], *p;
195          int len = ll2string(buf,sizeof(buf),val);
196          if (lenptr) *lenptr = len;
197          p = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
198          memcpy(p,buf,len);
199          return p;
200      } else if (encode) {
201          return createStringObjectFromLongLongForValue(val);
202      } else {
203          return createObject(OBJ_STRING,sdsfromlonglong(val));
204      }
205  }
206  int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
207      PORT_LONGLONG value;
208      char *endptr, buf[32];
209      value = strtoll(s, &endptr, 10);
210      if (endptr[0] != '\0') return 0;
211      ll2string(buf,32,value);
212      if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
213      return rdbEncodeInteger(value,enc);
214  }
215  ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
216                         size_t original_len) {
217      unsigned char byte;
218      ssize_t n, nwritten = 0;
219      byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
220      if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
221      nwritten += n;
222      if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
223      nwritten += n;
224      if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
225      nwritten += n;
226      if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
227      nwritten += n;
228      return nwritten;
229  writeerr:
230      return -1;
231  }
232  ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
233      size_t comprlen, outlen;
234      void *out;
235      if (len <= 4) return 0;
236      outlen = len-4;
237      if ((out = zmalloc(outlen+1)) == NULL) return 0;
238      comprlen = lzf_compress(s, len, out, outlen);
239      if (comprlen == 0) {
240          zfree(out);
241          return 0;
242      }
243      ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
244      zfree(out);
245      return nwritten;
246  }
247  void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
248      int plain = flags & RDB_LOAD_PLAIN;
249      int sds = flags & RDB_LOAD_SDS;
250      uint64_t len, clen;
251      unsigned char *c = NULL;
252      char *val = NULL;
253      if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
254      if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
255      if ((c = zmalloc(clen)) == NULL) goto err;
256      if (plain) {
257          val = zmalloc(len);
258      } else {
259          val = sdsnewlen(SDS_NOINIT,len);
260      }
261      if (lenptr) *lenptr = len;
262      if (rioRead(rdb,c,clen) == 0) goto err;
263      if (lzf_decompress(c,clen,val,len) == 0) {
264          if (rdbCheckMode) rdbCheckSetError("Invalid LZF compressed string");
265          goto err;
266      }
267      zfree(c);
268      if (plain || sds) {
269          return val;
270      } else {
271          return createObject(OBJ_STRING,val);
272      }
273  err:
274      zfree(c);
275      if (plain)
276          zfree(val);
277      else
278          sdsfree(val);
279      return NULL;
280  }
281  ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
282      int enclen;
283      ssize_t n, nwritten = 0;
284      if (len <= 11) {
285          unsigned char buf[5];
286          if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
287              if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
288              return enclen;
289          }
290      }
291      if (server.rdb_compression && len > 20) {
292          n = rdbSaveLzfStringObject(rdb,s,len);
293          if (n == -1) return -1;
294          if (n > 0) return n;
295      }
296      if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
297      nwritten += n;
298      if (len > 0) {
299          if (rdbWriteRaw(rdb,s,len) == -1) return -1;
300          nwritten += len;
301      }
302      return nwritten;
303  }
304  ssize_t rdbSaveLongLongAsStringObject(rio *rdb, PORT_LONGLONG value) {
305      unsigned char buf[32];
306      ssize_t n, nwritten = 0;
307      int enclen = rdbEncodeInteger(value,buf);
308      if (enclen > 0) {
309          return rdbWriteRaw(rdb,buf,enclen);
310      } else {
311          enclen = ll2string((char*)buf,32,value);
312          serverAssert(enclen < 32);
313          if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
314          nwritten += n;
315          if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
316          nwritten += n;
317      }
318      return nwritten;
319  }
320  ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
321      if (obj->encoding == OBJ_ENCODING_INT) {
322          return rdbSaveLongLongAsStringObject(rdb,(PORT_LONG)obj->ptr);
323      } else {
324          serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
325          return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
326      }
327  }
328  void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
329      int encode = flags & RDB_LOAD_ENC;
330      int plain = flags & RDB_LOAD_PLAIN;
331      int sds = flags & RDB_LOAD_SDS;
332      int isencoded;
333      uint64_t len;
334      len = rdbLoadLen(rdb,&isencoded);
335      if (isencoded) {
336          switch(len) {
337          case RDB_ENC_INT8:
338          case RDB_ENC_INT16:
339          case RDB_ENC_INT32:
340              return rdbLoadIntegerObject(rdb,len,flags,lenptr);
341          case RDB_ENC_LZF:
342              return rdbLoadLzfStringObject(rdb,flags,lenptr);
343          default:
344              rdbExitReportCorruptRDB("Unknown RDB string encoding type %d",len);
345          }
346      }
347      if (len == RDB_LENERR) return NULL;
348      if (plain || sds) {
349          void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
350          if (lenptr) *lenptr = len;
351          if (len && rioRead(rdb,buf,len) == 0) {
352              if (plain)
353                  zfree(buf);
354              else
355                  sdsfree(buf);
356              return NULL;
357          }
358          return buf;
359      } else {
360          robj *o = encode ? createStringObject(SDS_NOINIT,len) :
361                             createRawStringObject(SDS_NOINIT,len);
362          if (len && rioRead(rdb,o->ptr,len) == 0) {
363              decrRefCount(o);
364              return NULL;
365          }
366          return o;
367      }
368  }
369  robj *rdbLoadStringObject(rio *rdb) {
370      return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
371  }
372  robj *rdbLoadEncodedStringObject(rio *rdb) {
373      return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
374  }
375  int rdbSaveDoubleValue(rio *rdb, double val) {
376      unsigned char buf[128];
377      int len;
378      if (isnan(val)) {
379          buf[0] = 253;
380          len = 1;
381      } else if (!isfinite(val)) {
382          len = 1;
383          buf[0] = (val < 0) ? 255 : 254;
384      } else {
385  #if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)
386          double min = -4503599627370495; &bsol;* (2^52)-1 */
387          double max = 4503599627370496; &bsol;* -(2^52) */
388          if (val > min && val < max && val == ((double)((PORT_LONGLONG)val)))
389              ll2string((char*)buf+1,sizeof(buf)-1,(PORT_LONGLONG)val);
390          else
391  #endif
392              snprintf((char*)buf+1,sizeof(buf)-1,"%.17g",val);
393          buf[0] = (unsigned char)strlen((char*)buf+1);                           WIN_PORT_FIX &bsol;* cast (unsigned char) */
394          len = buf[0]+1;
395      }
396      return rdbWriteRaw(rdb,buf,len);
397  }
398  int rdbLoadDoubleValue(rio *rdb, double *val) {
399      char buf[256];
400      unsigned char len;
401  #ifdef _WIN32
402      double scannedVal = 0;
403      int assigned = 0;
404      memset(buf, 0, sizeof(buf));
405  #endif
406      if (rioRead(rdb,&len,1) == 0) return -1;
407      switch(len) {
408      case 255: *val = R_NegInf; return 0;
409      case 254: *val = R_PosInf; return 0;
410      case 253: *val = R_Nan; return 0;
411      default:
412          if (rioRead(rdb,buf,len) == 0) return -1;
413          buf[len] = '\0';
414  #ifdef _WIN32
415          assigned = sscanf_s(buf, "%lg", &scannedVal);
416          if( assigned != 0 ) {
417              (*val) = scannedVal;
418              return 0;
419          } else {
420              return -1;
421          }
422  #else
423          sscanf(buf, "%lg", val);
424          return 0;
425  #endif
426      }
427  }
428  int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
429      memrev64ifbe(&val);
430      return rdbWriteRaw(rdb,&val,sizeof(val));
431  }
432  int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
433      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
434      memrev64ifbe(val);
435      return 0;
436  }
437  int rdbSaveBinaryFloatValue(rio *rdb, float val) {
438      memrev32ifbe(&val);
439      return rdbWriteRaw(rdb,&val,sizeof(val));
440  }
441  int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
442      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
443      memrev32ifbe(val);
444      return 0;
445  }
446  int rdbSaveObjectType(rio *rdb, robj *o) {
447      switch (o->type) {
448      case OBJ_STRING:
449          return rdbSaveType(rdb,RDB_TYPE_STRING);
450      case OBJ_LIST:
451          if (o->encoding == OBJ_ENCODING_QUICKLIST)
452              return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);
453          else
454              serverPanic("Unknown list encoding");
455      case OBJ_SET:
456          if (o->encoding == OBJ_ENCODING_INTSET)
457              return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
458          else if (o->encoding == OBJ_ENCODING_HT)
459              return rdbSaveType(rdb,RDB_TYPE_SET);
460          else
461              serverPanic("Unknown set encoding");
462      case OBJ_ZSET:
463          if (o->encoding == OBJ_ENCODING_ZIPLIST)
464              return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);
465          else if (o->encoding == OBJ_ENCODING_SKIPLIST)
466              return rdbSaveType(rdb,RDB_TYPE_ZSET_2);
467          else
468              serverPanic("Unknown sorted set encoding");
469      case OBJ_HASH:
470          if (o->encoding == OBJ_ENCODING_ZIPLIST)
471              return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);
472          else if (o->encoding == OBJ_ENCODING_HT)
473              return rdbSaveType(rdb,RDB_TYPE_HASH);
474          else
475              serverPanic("Unknown hash encoding");
476      case OBJ_STREAM:
477          return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);
478      case OBJ_MODULE:
479          return rdbSaveType(rdb,RDB_TYPE_MODULE_2);
480      default:
481          serverPanic("Unknown object type");
482      }
483      return -1; &bsol;* avoid warning */
484  }
485  int rdbLoadObjectType(rio *rdb) {
486      int type;
487      if ((type = rdbLoadType(rdb)) == -1) return -1;
488      if (!rdbIsObjectType(type)) return -1;
489      return type;
490  }
491  ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
492      ssize_t n, nwritten = 0;
493      if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
494      nwritten += n;
495      raxIterator ri;
496      raxStart(&ri,pel);
497      raxSeek(&ri,"^",NULL,0);
498      while(raxNext(&ri)) {
499          if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
500          nwritten += n;
501          if (nacks) {
502              streamNACK *nack = ri.data;
503              if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
504                  return -1;
505              nwritten += n;
506              if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
507              nwritten += n;
508          }
509      }
510      raxStop(&ri);
511      return nwritten;
512  }
513  size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
514      ssize_t n, nwritten = 0;
515      if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
516      nwritten += n;
517      raxIterator ri;
518      raxStart(&ri,cg->consumers);
519      raxSeek(&ri,"^",NULL,0);
520      while(raxNext(&ri)) {
521          streamConsumer *consumer = ri.data;
522          if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
523          nwritten += n;
524          if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
525              return -1;
526          nwritten += n;
527          if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
528              return -1;
529          nwritten += n;
530      }
531      raxStop(&ri);
532      return nwritten;
533  }
<span onclick='openModal()' class='match'>534  ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
535      ssize_t n = 0, nwritten = 0;
</span>536      if (o->type == OBJ_STRING) {
537          if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
538          nwritten += n;
539      } else if (o->type == OBJ_LIST) {
540          if (o->encoding == OBJ_ENCODING_QUICKLIST) {
541              quicklist *ql = o->ptr;
542              quicklistNode *node = ql->head;
543              if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
544              nwritten += n;
545              while(node) {
546                  if (quicklistNodeIsCompressed(node)) {
547                      void *data;
548                      size_t compress_len = quicklistGetLzf(node, &data);
549                      if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
550                      nwritten += n;
551                  } else {
552                      if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;
553                      nwritten += n;
554                  }
555                  node = node->next;
556              }
557          } else {
558              serverPanic("Unknown list encoding");
559          }
560      } else if (o->type == OBJ_SET) {
561          if (o->encoding == OBJ_ENCODING_HT) {
562              dict *set = o->ptr;
563              dictIterator *di = dictGetIterator(set);
564              dictEntry *de;
565              if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {
566                  dictReleaseIterator(di);
567                  return -1;
568              }
569              nwritten += n;
570              while((de = dictNext(di)) != NULL) {
571                  sds ele = dictGetKey(de);
572                  if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))
573                      == -1)
574                  {
575                      dictReleaseIterator(di);
576                      return -1;
577                  }
578                  nwritten += n;
579              }
580              dictReleaseIterator(di);
581          } else if (o->encoding == OBJ_ENCODING_INTSET) {
582              size_t l = intsetBlobLen((intset*)o->ptr);
583              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
584              nwritten += n;
585          } else {
586              serverPanic("Unknown set encoding");
587          }
588      } else if (o->type == OBJ_ZSET) {
589          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
590              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
591              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
592              nwritten += n;
593          } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
594              zset *zs = o->ptr;
595              zskiplist *zsl = zs->zsl;
596              if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;
597              nwritten += n;
598              zskiplistNode *zn = zsl->tail;
599              while (zn != NULL) {
600                  if ((n = rdbSaveRawString(rdb,
601                      (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)
602                  {
603                      return -1;
604                  }
605                  nwritten += n;
606                  if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
607                      return -1;
608                  nwritten += n;
609                  zn = zn->backward;
610              }
611          } else {
612              serverPanic("Unknown sorted set encoding");
613          }
614      } else if (o->type == OBJ_HASH) {
615          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
616              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
617              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
618              nwritten += n;
619          } else if (o->encoding == OBJ_ENCODING_HT) {
620              dictIterator *di = dictGetIterator(o->ptr);
621              dictEntry *de;
622              if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {
623                  dictReleaseIterator(di);
624                  return -1;
625              }
626              nwritten += n;
627              while((de = dictNext(di)) != NULL) {
628                  sds field = dictGetKey(de);
629                  sds value = dictGetVal(de);
630                  if ((n = rdbSaveRawString(rdb,(unsigned char*)field,
631                          sdslen(field))) == -1)
632                  {
633                      dictReleaseIterator(di);
634                      return -1;
635                  }
636                  nwritten += n;
637                  if ((n = rdbSaveRawString(rdb,(unsigned char*)value,
638                          sdslen(value))) == -1)
639                  {
640                      dictReleaseIterator(di);
641                      return -1;
642                  }
643                  nwritten += n;
644              }
645              dictReleaseIterator(di);
646          } else {
647              serverPanic("Unknown hash encoding");
648          }
649      } else if (o->type == OBJ_STREAM) {
650          stream *s = o->ptr;
651          rax *rax = s->rax;
652          if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;
653          nwritten += n;
654          raxIterator ri;
655          raxStart(&ri,rax);
656          raxSeek(&ri,"^",NULL,0);
657          while (raxNext(&ri)) {
658              unsigned char *lp = ri.data;
659              size_t lp_bytes = lpBytes(lp);
660              if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
661              nwritten += n;
662              if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) return -1;
663              nwritten += n;
664          }
665          raxStop(&ri);
666          if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;
667          nwritten += n;
668          if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;
669          nwritten += n;
670          if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;
671          nwritten += n;
672          size_t num_cgroups = s->cgroups ? raxSize(s->cgroups) : 0;
673          if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;
674          nwritten += n;
675          if (num_cgroups) {
676              raxStart(&ri,s->cgroups);
677              raxSeek(&ri,"^",NULL,0);
678              while(raxNext(&ri)) {
679                  streamCG *cg = ri.data;
680                  if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1)
681                      return -1;
682                  nwritten += n;
683                  if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) return -1;
684                  nwritten += n;
685                  if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) return -1;
686                  nwritten += n;
687                  if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) return -1;
688                  nwritten += n;
689                  if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) return -1;
690                  nwritten += n;
691              }
692              raxStop(&ri);
693          }
694      } else if (o->type == OBJ_MODULE) {
695          RedisModuleIO io;
696          moduleValue *mv = o->ptr;
697          moduleType *mt = mv->type;
698          int retval = rdbSaveLen(rdb,mt->id);
699          if (retval == -1) return -1;
700          moduleInitIOContext(io,mt,rdb,key);
701          io.bytes += retval;
702          mt->rdb_save(&io,mv->value);
703          retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
704          if (retval == -1)
705              io.error = 1;
706          else
707              io.bytes += retval;
708          if (io.ctx) {
709              moduleFreeContext(io.ctx);
710              zfree(io.ctx);
711          }
712          return io.error ? -1 : (ssize_t)io.bytes;
713      } else {
714          serverPanic("Unknown object type");
715      }
716      return nwritten;
717  }
718  size_t rdbSavedObjectLen(robj *o) {
719      ssize_t len = rdbSaveObject(NULL,o,NULL);
720      serverAssertWithInfo(NULL,o,len != -1);
721      return len;
722  }
723  int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, PORT_LONGLONG expiretime) {
724      int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
725      int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;
726      if (expiretime != -1) {
727          if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
728          if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
729      }
730      if (savelru) {
731          uint64_t idletime = estimateObjectIdleTime(val);
732          idletime /= 1000; &bsol;* Using seconds is enough and requires less space.*/
733          if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
734          if (rdbSaveLen(rdb,idletime) == -1) return -1;
735      }
736      if (savelfu) {
737          uint8_t buf[1];
738          buf[0] = LFUDecrAndReturn(val);
739          if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
740          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
741      }
742      if (rdbSaveObjectType(rdb,val) == -1) return -1;
743      if (rdbSaveStringObject(rdb,key) == -1) return -1;
744      if (rdbSaveObject(rdb,val,key) == -1) return -1;
745      return 1;
746  }
747  ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
748      ssize_t ret, len = 0;
749      if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
750      len += ret;
751      if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
752      len += ret;
753      if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
754      len += ret;
755      return len;
756  }
757  ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
758      return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
759  }
760  ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, PORT_LONGLONG val) {
761      char buf[LONG_STR_SIZE];
762      int vlen = ll2string(buf,sizeof(buf),val);
763      return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
764  }
765  int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
766      int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
767      int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
768      if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
769      if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
770      if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
771      if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
772      if (rsi) {
773          if (rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
774              == -1) return -1;
775          if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid)
776              == -1) return -1;
777          if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset)
778              == -1) return -1;
779      }
780      if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
781      return 1;
782  }
783  ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
784      RedisModuleIO io;
785      int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);
786      if (retval == -1) return -1;
787      moduleInitIOContext(io,mt,rdb,NULL);                           WIN_PORT_FIX &bsol;*moved earlier before first usage of "io"*/
788      io.bytes += retval;
789      retval = rdbSaveLen(rdb,mt->id);
790      if (retval == -1) return -1;
791      io.bytes += retval;
792      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);
793      if (retval == -1) return -1;
794      io.bytes += retval;
795      retval = rdbSaveLen(rdb,when);
796      if (retval == -1) return -1;
797      io.bytes += retval;
798      mt->aux_save(&io,when);
799      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
800      if (retval == -1)
801          io.error = 1;
802      else
803          io.bytes += retval;
804      if (io.ctx) {
805          moduleFreeContext(io.ctx);
806          zfree(io.ctx);
807      }
808      if (io.error)
809          return -1;
810      return io.bytes;
811  }
812  int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
813      dictIterator *di = NULL;
814      dictEntry *de;
815      char magic[10];
816      int j;
817      uint64_t cksum;
818      size_t processed = 0;
819      if (server.rdb_checksum)
820          rdb->update_cksum = rioGenericUpdateChecksum;
821      snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
822      if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
823      if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
824      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;
825      for (j = 0; j < server.dbnum; j++) {
826          redisDb *db = server.db+j;
827          dict *d = db->dict;
828          if (dictSize(d) == 0) continue;
829          di = dictGetSafeIterator(d);
830          if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
831          if (rdbSaveLen(rdb,j) == -1) goto werr;
832          uint64_t db_size, expires_size;
833          db_size = dictSize(db->dict);
834          expires_size = dictSize(db->expires);
835          if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
836          if (rdbSaveLen(rdb,db_size) == -1) goto werr;
837          if (rdbSaveLen(rdb,expires_size) == -1) goto werr;
838          while((de = dictNext(di)) != NULL) {
839              sds keystr = dictGetKey(de);
840              robj key, *o = dictGetVal(de);
841              PORT_LONGLONG expire;
842              initStaticStringObject(key,keystr);
843              expire = getExpire(db,&key);
844              if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;
845              if (flags & RDB_SAVE_AOF_PREAMBLE &&
846                  rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)
847              {
848                  processed = rdb->processed_bytes;
849                  aofReadDiffFromParent();
850              }
851          }
852          dictReleaseIterator(di);
853          di = NULL; &bsol;* So that we don't release it again on error. */
854      }
855      if (rsi && dictSize(server.lua_scripts)) {
856          di = dictGetIterator(server.lua_scripts);
857          while((de = dictNext(di)) != NULL) {
858              robj *body = dictGetVal(de);
859              if (rdbSaveAuxField(rdb,"lua",3,body->ptr,sdslen(body->ptr)) == -1)
860                  goto werr;
861          }
862          dictReleaseIterator(di);
863          di = NULL; &bsol;* So that we don't release it again on error. */
864      }
865      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;
866      if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
867      cksum = rdb->cksum;
868      memrev64ifbe(&cksum);
869      if (rioWrite(rdb,&cksum,8) == 0) goto werr;
870      return C_OK;
871  werr:
872      if (error) *error = errno;
873      if (di) dictReleaseIterator(di);
874      return C_ERR;
875  }
876  int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
877      char eofmark[RDB_EOF_MARK_SIZE];
878      getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
879      if (error) *error = 0;
880      if (rioWrite(rdb,"$EOF:",5) == 0) goto werr;
881      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
882      if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
883      if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
884      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
885      return C_OK;
886  werr: &bsol;* Write error. */
887      if (error && *error == 0) *error = errno;
888      return C_ERR;
889  }
890  int rdbSave(char *filename, rdbSaveInfo *rsi) {
891      char tmpfile[256];
892      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
893      FILE *fp;
894      rio rdb;
895      int error = 0;
896      snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
897      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
898      fp = fopen(tmpfile,IF_WIN32("wb","w"));
899      if (!fp) {
900          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
901          serverLog(LL_WARNING,
902              "Failed opening the RDB file %s (in server root dir %s) "
903              "for saving: %s",
904              filename,
905              cwdp ? cwdp : "unknown",
906              IF_WIN32(wsa_strerror(errno), strerror(errno)));
907          return C_ERR;
908      }
909      rioInitWithFile(&rdb,fp);
910      if (server.rdb_save_incremental_fsync)
911          rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
912      if (rdbSaveRio(&rdb,&error,RDB_SAVE_NONE,rsi) == C_ERR) {
913          errno = error;
914          goto werr;
915      }
916      if (fflush(fp) == EOF) goto werr;
917      if (fsync(fileno(fp)) == -1) goto werr;
918      if (fclose(fp) == EOF) goto werr;
919      if (rename(tmpfile,filename) == -1) {
920          char *cwdp = getcwd(cwd,MAXPATHLEN);
921          serverLog(LL_WARNING,
922              "Error moving temp DB file %s on the final "
923              "destination %s (in server root dir %s): %s",
924              tmpfile,
925              filename,
926              cwdp ? cwdp : "unknown",
927              IF_WIN32(wsa_strerror(errno),strerror(errno)));
928          unlink(tmpfile);
929          return C_ERR;
930      }
931      serverLog(LL_NOTICE,"DB saved on disk");
932      server.dirty = 0;
933      server.lastsave = time(NULL);
934      server.lastbgsave_status = C_OK;
935      return C_OK;
936  werr:
937      serverLog(LL_WARNING,"Write error saving DB on disk: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
938      fclose(fp);
939      unlink(tmpfile);
940      return C_ERR;
941  }
942  int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
943      pid_t childpid;
944      PORT_LONGLONG start;
945      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
946      server.dirty_before_bgsave = server.dirty;
947      server.lastbgsave_try = time(NULL);
948      openChildInfoPipe();
949      start = ustime();
950  #ifdef _WIN32
951      childpid = BeginForkOperation_Rdb(filename, &server, sizeof(server), dictGetHashFunctionSeed(), modules);
952  #else
953      if ((childpid = fork()) == 0) {
954          int retval;
955          closeListeningSockets(0);
956          redisSetProcTitle("redis-rdb-bgsave");
957          retval = rdbSave(filename,rsi);
958          if (retval == C_OK) {
959              size_t private_dirty = zmalloc_get_private_dirty(-1);
960              if (private_dirty) {
961                  serverLog(LL_NOTICE,
962                      "RDB: %zu MB of memory used by copy-on-write",
963                      private_dirty/(1024*1024));
964              }
965              server.child_info_data.cow_size = private_dirty;
966              sendChildInfo(CHILD_INFO_TYPE_RDB);
967          }
968          exitFromChild((retval == C_OK) ? 0 : 1);
969      } else {
970  #endif
971          server.stat_fork_time = ustime()-start;
972  #ifdef _WIN32
973          if (server.stat_fork_time == 0) {
974              server.stat_fork_time = 100000; 
975          }
976  #endif
977          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
978          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
979          if (childpid == -1) {
980              closeChildInfoPipe();
981              server.lastbgsave_status = C_ERR;
982              serverLog(LL_WARNING,"Can't save in background: fork: %s",
983                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
984              return C_ERR;
985          }
986          serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
987          server.rdb_save_time_start = time(NULL);
988          server.rdb_child_pid = childpid;
989          server.rdb_child_type = RDB_CHILD_TYPE_DISK;
990          updateDictResizePolicy();
991          return C_OK;
992  #ifndef _WIN32
993      }
994  #endif
995      return C_OK; &bsol;* unreached */
996  }
997  void rdbRemoveTempFile(pid_t childpid) {
998      char tmpfile[256];
999      snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
1000      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1001      unlink(tmpfile);
1002  }
1003  robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
1004      uint64_t opcode;
1005      while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
1006          if (opcode == RDB_MODULE_OPCODE_SINT ||
1007              opcode == RDB_MODULE_OPCODE_UINT)
1008          {
1009              uint64_t len;
1010              if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
1011                  rdbExitReportCorruptRDB(
1012                      "Error reading integer from module %s value", modulename);
1013              }
1014          } else if (opcode == RDB_MODULE_OPCODE_STRING) {
1015              robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
1016              if (o == NULL) {
1017                  rdbExitReportCorruptRDB(
1018                      "Error reading string from module %s value", modulename);
1019              }
1020              decrRefCount(o);
1021          } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
1022              float val;
1023              if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
1024                  rdbExitReportCorruptRDB(
1025                      "Error reading float from module %s value", modulename);
1026              }
1027          } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {
1028              double val;
1029              if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {
1030                  rdbExitReportCorruptRDB(
1031                      "Error reading double from module %s value", modulename);
1032              }
1033          }
1034      }
1035      return createStringObject("module-dummy-value",18);
1036  }
1037  robj *rdbLoadObject(int rdbtype, rio *rdb, robj *key) {
1038      robj *o = NULL, *ele, *dec;
1039      uint64_t len;
1040      unsigned int i;
1041      if (rdbtype == RDB_TYPE_STRING) {
1042          if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1043          o = tryObjectEncoding(o);
1044      } else if (rdbtype == RDB_TYPE_LIST) {
1045          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1046          o = createQuicklistObject();
1047          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1048                              server.list_compress_depth);
1049          while(len--) {
1050              if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1051              dec = getDecodedObject(ele);
1052              size_t len = sdslen(dec->ptr);
1053              quicklistPushTail(o->ptr, dec->ptr, len);
1054              decrRefCount(dec);
1055              decrRefCount(ele);
1056          }
1057      } else if (rdbtype == RDB_TYPE_SET) {
1058          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1059          if (len > server.set_max_intset_entries) {
1060              o = createSetObject();
1061              if (len > DICT_HT_INITIAL_SIZE)
1062                  dictExpand(o->ptr,len);
1063          } else {
1064              o = createIntsetObject();
1065          }
1066          for (i = 0; i < len; i++) {
1067              PORT_LONGLONG llval;
1068              sds sdsele;
1069              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1070                  == NULL) return NULL;
1071              if (o->encoding == OBJ_ENCODING_INTSET) {
1072                  if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {
1073                      o->ptr = intsetAdd(o->ptr,llval,NULL);
1074                  } else {
1075                      setTypeConvert(o,OBJ_ENCODING_HT);
1076                      dictExpand(o->ptr,len);
1077                  }
1078              }
1079              if (o->encoding == OBJ_ENCODING_HT) {
1080                  dictAdd((dict*)o->ptr,sdsele,NULL);
1081              } else {
1082                  sdsfree(sdsele);
1083              }
1084          }
1085      } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {
1086          uint64_t zsetlen;
1087          size_t maxelelen = 0;
1088          zset *zs;
1089          if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1090          o = createZsetObject();
1091          zs = o->ptr;
1092          if (zsetlen > DICT_HT_INITIAL_SIZE)
1093              dictExpand(zs->dict,zsetlen);
1094          while(zsetlen--) {
1095              sds sdsele;
1096              double score;
1097              zskiplistNode *znode;
1098              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1099                  == NULL) return NULL;
1100              if (rdbtype == RDB_TYPE_ZSET_2) {
1101                  if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) return NULL;
1102              } else {
1103                  if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
1104              }
1105              if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);
1106              znode = zslInsert(zs->zsl,score,sdsele);
1107              dictAdd(zs->dict,sdsele,&znode->score);
1108          }
1109          if (zsetLength(o) <= server.zset_max_ziplist_entries &&
1110              maxelelen <= server.zset_max_ziplist_value)
1111                  zsetConvert(o,OBJ_ENCODING_ZIPLIST);
1112      } else if (rdbtype == RDB_TYPE_HASH) {
1113          uint64_t len;
1114          int ret;
1115          sds field, value;
1116          len = rdbLoadLen(rdb, NULL);
1117          if (len == RDB_LENERR) return NULL;
1118          o = createHashObject();
1119          if (len > server.hash_max_ziplist_entries)
1120              hashTypeConvert(o, OBJ_ENCODING_HT);
1121          while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {
1122              len--;
1123              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1124                  == NULL) return NULL;
1125              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1126                  == NULL) return NULL;
1127              o->ptr = ziplistPush(o->ptr, (unsigned char*)field,
1128                      sdslen(field), ZIPLIST_TAIL);
1129              o->ptr = ziplistPush(o->ptr, (unsigned char*)value,
1130                      sdslen(value), ZIPLIST_TAIL);
1131              if (sdslen(field) > server.hash_max_ziplist_value ||
1132                  sdslen(value) > server.hash_max_ziplist_value)
1133              {
1134                  sdsfree(field);
1135                  sdsfree(value);
1136                  hashTypeConvert(o, OBJ_ENCODING_HT);
1137                  break;
1138              }
1139              sdsfree(field);
1140              sdsfree(value);
1141          }
1142          if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)
1143              dictExpand(o->ptr,len);
1144          while (o->encoding == OBJ_ENCODING_HT && len > 0) {
1145              len--;
1146              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1147                  == NULL) return NULL;
1148              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1149                  == NULL) return NULL;
1150              ret = dictAdd((dict*)o->ptr, field, value);
1151              if (ret == DICT_ERR) {
1152                  rdbExitReportCorruptRDB("Duplicate keys detected");
1153              }
1154          }
1155          serverAssert(len == 0);
1156      } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {
1157          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1158          o = createQuicklistObject();
1159          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1160                              server.list_compress_depth);
1161          while (len--) {
1162              unsigned char *zl =
1163                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1164              if (zl == NULL) return NULL;
1165              quicklistAppendZiplist(o->ptr, zl);
1166          }
1167      } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||
1168                 rdbtype == RDB_TYPE_LIST_ZIPLIST ||
1169                 rdbtype == RDB_TYPE_SET_INTSET   ||
1170                 rdbtype == RDB_TYPE_ZSET_ZIPLIST ||
1171                 rdbtype == RDB_TYPE_HASH_ZIPLIST)
1172      {
1173          unsigned char *encoded =
1174              rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1175          if (encoded == NULL) return NULL;
1176          o = createObject(OBJ_STRING,encoded); &bsol;* Obj type fixed below. */
1177          switch(rdbtype) {
1178              case RDB_TYPE_HASH_ZIPMAP:
1179                  {
1180                      unsigned char *zl = ziplistNew();
1181                      unsigned char *zi = zipmapRewind(o->ptr);
1182                      unsigned char *fstr, *vstr;
1183                      unsigned int flen, vlen;
1184                      unsigned int maxlen = 0;
1185                      while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {
1186                          if (flen > maxlen) maxlen = flen;
1187                          if (vlen > maxlen) maxlen = vlen;
1188                          zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);
1189                          zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);
1190                      }
1191                      zfree(o->ptr);
1192                      o->ptr = zl;
1193                      o->type = OBJ_HASH;
1194                      o->encoding = OBJ_ENCODING_ZIPLIST;
1195                      if (hashTypeLength(o) > server.hash_max_ziplist_entries ||
1196                          maxlen > server.hash_max_ziplist_value)
1197                      {
1198                          hashTypeConvert(o, OBJ_ENCODING_HT);
1199                      }
1200                  }
1201                  break;
1202              case RDB_TYPE_LIST_ZIPLIST:
1203                  o->type = OBJ_LIST;
1204                  o->encoding = OBJ_ENCODING_ZIPLIST;
1205                  listTypeConvert(o,OBJ_ENCODING_QUICKLIST);
1206                  break;
1207              case RDB_TYPE_SET_INTSET:
1208                  o->type = OBJ_SET;
1209                  o->encoding = OBJ_ENCODING_INTSET;
1210                  if (intsetLen(o->ptr) > server.set_max_intset_entries)
1211                      setTypeConvert(o,OBJ_ENCODING_HT);
1212                  break;
1213              case RDB_TYPE_ZSET_ZIPLIST:
1214                  o->type = OBJ_ZSET;
1215                  o->encoding = OBJ_ENCODING_ZIPLIST;
1216                  if (zsetLength(o) > server.zset_max_ziplist_entries)
1217                      zsetConvert(o,OBJ_ENCODING_SKIPLIST);
1218                  break;
1219              case RDB_TYPE_HASH_ZIPLIST:
1220                  o->type = OBJ_HASH;
1221                  o->encoding = OBJ_ENCODING_ZIPLIST;
1222                  if (hashTypeLength(o) > server.hash_max_ziplist_entries)
1223                      hashTypeConvert(o, OBJ_ENCODING_HT);
1224                  break;
1225              default:
1226                  rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1227                  break;
1228          }
1229      } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {
1230          o = createStreamObject();
1231          stream *s = o->ptr;
1232          uint64_t listpacks = rdbLoadLen(rdb,NULL);
1233          while(listpacks--) {
1234              sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1235              if (nodekey == NULL) {
1236                  rdbExitReportCorruptRDB("Stream master ID loading failed: invalid encoding or I/O error.");
1237              }
1238              if (sdslen(nodekey) != sizeof(streamID)) {
1239                  rdbExitReportCorruptRDB("Stream node key entry is not the "
1240                                          "size of a stream ID");
1241              }
1242              unsigned char *lp =
1243                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1244              if (lp == NULL) return NULL;
1245              unsigned char *first = lpFirst(lp);
1246              if (first == NULL) {
1247                  rdbExitReportCorruptRDB("Empty listpack inside stream");
1248              }
1249              int retval = raxInsert(s->rax,
1250                  (unsigned char*)nodekey,sizeof(streamID),lp,NULL);
1251              sdsfree(nodekey);
1252              if (!retval)
1253                  rdbExitReportCorruptRDB("Listpack re-added with existing key");
1254          }
1255          s->length = rdbLoadLen(rdb,NULL);
1256          s->last_id.ms = rdbLoadLen(rdb,NULL);
1257          s->last_id.seq = rdbLoadLen(rdb,NULL);
1258          size_t cgroups_count = rdbLoadLen(rdb,NULL);
1259          while(cgroups_count--) {
1260              streamID cg_id;
1261              sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1262              if (cgname == NULL) {
1263                  rdbExitReportCorruptRDB(
1264                      "Error reading the consumer group name from Stream");
1265              }
1266              cg_id.ms = rdbLoadLen(rdb,NULL);
1267              cg_id.seq = rdbLoadLen(rdb,NULL);
1268              streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);
1269              if (cgroup == NULL)
1270                  rdbExitReportCorruptRDB("Duplicated consumer group name %s",
1271                                           cgname);
1272              sdsfree(cgname);
1273              size_t pel_size = rdbLoadLen(rdb,NULL);
1274              while(pel_size--) {
1275                  unsigned char rawid[sizeof(streamID)];
1276                  rdbLoadRaw(rdb,rawid,sizeof(rawid));
1277                  streamNACK *nack = streamCreateNACK(NULL);
1278                  nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1279                  nack->delivery_count = rdbLoadLen(rdb,NULL);
1280                  if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))
1281                      rdbExitReportCorruptRDB("Duplicated gobal PEL entry "
1282                                              "loading stream consumer group");
1283              }
1284              size_t consumers_num = rdbLoadLen(rdb,NULL);
1285              while(consumers_num--) {
1286                  sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1287                  if (cname == NULL) {
1288                      rdbExitReportCorruptRDB(
1289                          "Error reading the consumer name from Stream group");
1290                  }
1291                  streamConsumer *consumer =
1292                      streamLookupConsumer(cgroup,cname,SLC_NONE);
1293                  sdsfree(cname);
1294                  consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1295                  pel_size = rdbLoadLen(rdb,NULL);
1296                  while(pel_size--) {
1297                      unsigned char rawid[sizeof(streamID)];
1298                      rdbLoadRaw(rdb,rawid,sizeof(rawid));
1299                      streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));
1300                      if (nack == raxNotFound)
1301                          rdbExitReportCorruptRDB("Consumer entry not found in "
1302                                                  "group global PEL");
1303                      nack->consumer = consumer;
1304                      if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))
1305                          rdbExitReportCorruptRDB("Duplicated consumer PEL entry "
1306                                                  " loading a stream consumer "
1307                                                  "group");
1308                  }
1309              }
1310          }
1311      } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {
1312          uint64_t moduleid = rdbLoadLen(rdb,NULL);
1313          moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1314          char name[10];
1315          if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {
1316              moduleTypeNameByID(name,moduleid);
1317              return rdbLoadCheckModuleValue(rdb,name);
1318          }
1319          if (mt == NULL) {
1320              moduleTypeNameByID(name,moduleid);
1321              serverLog(LL_WARNING,"The RDB file contains module data I can't load: no matching module '%s'", name);
1322              exit(1);
1323          }
1324          RedisModuleIO io;
1325          moduleInitIOContext(io,mt,rdb,key);
1326          io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;
1327          void *ptr = mt->rdb_load(&io,moduleid&1023);
1328          if (io.ctx) {
1329              moduleFreeContext(io.ctx);
1330              zfree(io.ctx);
1331          }
1332          if (io.ver == 2) {
1333              uint64_t eof = rdbLoadLen(rdb,NULL);
1334              if (eof != RDB_MODULE_OPCODE_EOF) {
1335                  serverLog(LL_WARNING,"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1336                  exit(1);
1337              }
1338          }
1339          if (ptr == NULL) {
1340              moduleTypeNameByID(name,moduleid);
1341              serverLog(LL_WARNING,"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1342              exit(1);
1343          }
1344          o = createModuleObject(mt,ptr);
1345      } else {
1346          rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1347      }
1348      return o;
1349  }
1350  void startLoading(FILE *fp) {
1351      struct IF_WIN32(_stat64,stat) sb;                                           
1352      server.loading = 1;
1353      server.loading_start_time = time(NULL);
1354      server.loading_loaded_bytes = 0;
1355      if (fstat(fileno(fp), &sb) == -1) {
1356          server.loading_total_bytes = 0;
1357      } else {
1358          server.loading_total_bytes = sb.st_size;
1359      }
1360  }
1361  void loadingProgress(off_t pos) {
1362      server.loading_loaded_bytes = pos;
1363      if (server.stat_peak_memory < zmalloc_used_memory())
1364          server.stat_peak_memory = zmalloc_used_memory();
1365  }
1366  void stopLoading(void) {
1367      server.loading = 0;
1368  }
1369  void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
1370      if (server.rdb_checksum)
1371          rioGenericUpdateChecksum(r, buf, len);
1372      if (server.loading_process_events_interval_bytes &&
1373          (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
1374      {
1375          updateCachedTime(0);
1376          if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
1377              replicationSendNewlineToMaster();
1378          loadingProgress((off_t)r->processed_bytes);                             WIN_PORT_FIX &bsol;* cast (off_t) */
1379          processEventsWhileBlocked();
1380      }
1381  }
1382  int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
1383      uint64_t dbid;
1384      int type, rdbver;
1385      redisDb *db = server.db+0;
1386      char buf[1024];
1387      rdb->update_cksum = rdbLoadProgressCallback;
1388      rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
1389      if (rioRead(rdb,buf,9) == 0) goto eoferr;
1390      buf[9] = '\0';
1391      if (memcmp(buf,"REDIS",5) != 0) {
1392          serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
1393          errno = EINVAL;
1394          return C_ERR;
1395      }
1396      rdbver = atoi(buf+5);
1397      if (rdbver < 1 || rdbver > RDB_VERSION) {
1398          serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
1399          errno = EINVAL;
1400          return C_ERR;
1401      }
1402      PORT_LONGLONG lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
1403      PORT_LONGLONG lru_clock = LRU_CLOCK();
1404      while(1) {
1405          robj *key, *val;
1406          if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
1407          if (type == RDB_OPCODE_EXPIRETIME) {
1408              expiretime = rdbLoadTime(rdb);
1409              expiretime *= 1000;
1410              continue; &bsol;* Read next opcode. */
1411          } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
1412              expiretime = rdbLoadMillisecondTime(rdb,rdbver);
1413              continue; &bsol;* Read next opcode. */
1414          } else if (type == RDB_OPCODE_FREQ) {
1415              uint8_t byte;
1416              if (rioRead(rdb,&byte,1) == 0) goto eoferr;
1417              lfu_freq = byte;
1418              continue; &bsol;* Read next opcode. */
1419          } else if (type == RDB_OPCODE_IDLE) {
1420              uint64_t qword;
1421              if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1422              lru_idle = qword;
1423              continue; &bsol;* Read next opcode. */
1424          } else if (type == RDB_OPCODE_EOF) {
1425              break;
1426          } else if (type == RDB_OPCODE_SELECTDB) {
1427              if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1428              if (dbid >= (unsigned)server.dbnum) {
1429                  serverLog(LL_WARNING,
1430                      "FATAL: Data file was created with a Redis "
1431                      "server configured to handle more than %d "
1432                      "databases. Exiting\n", server.dbnum);
1433                  exit(1);
1434              }
1435              db = server.db+dbid;
1436              continue; &bsol;* Read next opcode. */
1437          } else if (type == RDB_OPCODE_RESIZEDB) {
1438              uint64_t db_size, expires_size;
1439              if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1440                  goto eoferr;
1441              if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1442                  goto eoferr;
1443              dictExpand(db->dict,db_size);
1444              dictExpand(db->expires,expires_size);
1445              continue; &bsol;* Read next opcode. */
1446          } else if (type == RDB_OPCODE_AUX) {
1447              robj *auxkey, *auxval;
1448              if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1449              if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1450              if (((char*)auxkey->ptr)[0] == '%') {
1451                  serverLog(LL_NOTICE,"RDB '%s': %s",
1452                      (char*)auxkey->ptr,
1453                      (char*)auxval->ptr);
1454              } else if (!strcasecmp(auxkey->ptr,"repl-stream-db")) {
1455                  if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
1456              } else if (!strcasecmp(auxkey->ptr,"repl-id")) {
1457                  if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {
1458                      memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
1459                      rsi->repl_id_is_set = 1;
1460                  }
1461              } else if (!strcasecmp(auxkey->ptr,"repl-offset")) {
1462                  if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
1463              } else if (!strcasecmp(auxkey->ptr,"lua")) {
1464                  if (luaCreateFunction(NULL,server.lua,auxval) == NULL) {
1465                      rdbExitReportCorruptRDB(
1466                          "Can't load Lua script from RDB file! "
1467                          "BODY: %s", auxval->ptr);
1468                  }
1469              } else {
1470                  serverLog(LL_DEBUG,"Unrecognized RDB AUX field: '%s'",
1471                      (char*)auxkey->ptr);
1472              }
1473              decrRefCount(auxkey);
1474              decrRefCount(auxval);
1475              continue; &bsol;* Read type again. */
1476          } else if (type == RDB_OPCODE_MODULE_AUX) {
1477              uint64_t moduleid = rdbLoadLen(rdb,NULL);
1478              int when_opcode = rdbLoadLen(rdb,NULL);
1479              int when = rdbLoadLen(rdb,NULL);
1480              if (when_opcode != RDB_MODULE_OPCODE_UINT)
1481                  rdbExitReportCorruptRDB("bad when_opcode");
1482              moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1483              char name[10];
1484              moduleTypeNameByID(name,moduleid);
1485              if (!rdbCheckMode && mt == NULL) {
1486                  serverLog(LL_WARNING,"The RDB file contains AUX module data I can't load: no matching module '%s'", name);
1487                  exit(1);
1488              } else if (!rdbCheckMode && mt != NULL) {
1489                  if (!mt->aux_load) {
1490                      serverLog(LL_WARNING,"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.", name);
1491                      exit(1);
1492                  }
1493                  RedisModuleIO io;
1494                  moduleInitIOContext(io,mt,rdb,NULL);
1495                  io.ver = 2;
1496                  if (mt->aux_load(&io,moduleid&1023, when) || io.error) {
1497                      moduleTypeNameByID(name,moduleid);
1498                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1499                      exit(1);
1500                  }
1501                  if (io.ctx) {
1502                      moduleFreeContext(io.ctx);
1503                      zfree(io.ctx);
1504                  }
1505                  uint64_t eof = rdbLoadLen(rdb,NULL);
1506                  if (eof != RDB_MODULE_OPCODE_EOF) {
1507                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1508                      exit(1);
1509                  }
1510                  continue;
1511              } else {
1512                  robj *aux = rdbLoadCheckModuleValue(rdb,name);
1513                  decrRefCount(aux);
1514                  continue; &bsol;* Read next opcode. */
1515              }
1516          }
1517          if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1518          if ((val = rdbLoadObject(type,rdb,key)) == NULL) goto eoferr;
1519          if (server.masterhost == NULL && !loading_aof && expiretime != -1 && expiretime < now) {
1520              decrRefCount(key);
1521              decrRefCount(val);
1522          } else {
1523              dbAdd(db,key,val);
1524              if (expiretime != -1) setExpire(NULL,db,key,expiretime);
1525              objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock);
1526              decrRefCount(key);
1527          }
1528          expiretime = -1;
1529          lfu_freq = -1;
1530          lru_idle = -1;
1531      }
1532      if (rdbver >= 5) {
1533          uint64_t cksum, expected = rdb->cksum;
1534          if (rioRead(rdb,&cksum,8) == 0) goto eoferr;
1535          if (server.rdb_checksum) {
1536              memrev64ifbe(&cksum);
1537              if (cksum == 0) {
1538                  serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
1539              } else if (cksum != expected) {
1540                  serverLog(LL_WARNING,"Wrong RDB checksum. Aborting now.");
1541                  rdbExitReportCorruptRDB("RDB CRC error");
1542              }
1543          }
1544      }
1545      return C_OK;
1546  eoferr: &bsol;* unexpected end of file is handled here with a fatal exit */
1547      serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
1548      rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
1549      return C_ERR; &bsol;* Just to avoid warning */
1550  }
1551  int rdbLoad(char *filename, rdbSaveInfo *rsi) {
1552      FILE *fp;
1553      rio rdb;
1554      int retval;
1555      if ((fp = fopen(filename,IF_WIN32("rb","r"))) == NULL) return C_ERR;
1556      startLoading(fp);
1557      rioInitWithFile(&rdb,fp);
1558      retval = rdbLoadRio(&rdb,rsi,0);
1559      fclose(fp);
1560      stopLoading();
1561      return retval;
1562  }
1563  void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
1564      if (!bysignal && exitcode == 0) {
1565          serverLog(LL_NOTICE,
1566              "Background saving terminated with success");
1567          server.dirty = server.dirty - server.dirty_before_bgsave;
1568          server.lastsave = time(NULL);
1569          server.lastbgsave_status = C_OK;
1570      } else if (!bysignal && exitcode != 0) {
1571          serverLog(LL_WARNING, "Background saving error");
1572          server.lastbgsave_status = C_ERR;
1573      } else {
1574          mstime_t latency;
1575          serverLog(LL_WARNING,
1576              "Background saving terminated by signal %d", bysignal);
1577          latencyStartMonitor(latency);
1578          rdbRemoveTempFile(server.rdb_child_pid);
1579          latencyEndMonitor(latency);
1580          latencyAddSampleIfNeeded("rdb-unlink-temp-file",latency);
1581          if (bysignal != SIGUSR1)
1582              server.lastbgsave_status = C_ERR;
1583      }
1584      server.rdb_child_pid = -1;
1585      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1586      server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
1587      server.rdb_save_time_start = -1;
1588      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
1589  }
1590  void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
1591      uint64_t *ok_slaves;
1592      if (!bysignal && exitcode == 0) {
1593          serverLog(LL_NOTICE,
1594              "Background RDB transfer terminated with success");
1595      } else if (!bysignal && exitcode != 0) {
1596          serverLog(LL_WARNING, "Background transfer error");
1597      } else {
1598          serverLog(LL_WARNING,
1599              "Background transfer terminated by signal %d", bysignal);
1600      }
1601      server.rdb_child_pid = -1;
1602      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1603      server.rdb_save_time_start = -1;
1604      ok_slaves = zmalloc(sizeof(uint64_t)); &bsol;* Make space for the count. */
1605      ok_slaves[0] = 0;
1606      if (!bysignal && exitcode == 0) {
1607          int readlen = sizeof(uint64_t);
1608          if (read(server.rdb_pipe_read_result_from_child, ok_slaves, readlen) ==
1609                   readlen)
1610          {
1611              readlen = (int)(ok_slaves[0]*sizeof(uint64_t)*2);                   WIN_PORT_FIX &bsol;* cast (int) */
1612              ok_slaves = zrealloc(ok_slaves,sizeof(uint64_t)+readlen);
1613              if (readlen &&
1614                  read(server.rdb_pipe_read_result_from_child, ok_slaves+1,
1615                       readlen) != readlen)
1616              {
1617                  ok_slaves[0] = 0;
1618              }
1619          }
1620      }
1621      close(server.rdb_pipe_read_result_from_child);
1622      close(server.rdb_pipe_write_result_to_parent);
1623      listNode *ln;
1624      listIter li;
1625      listRewind(server.slaves,&li);
1626      while((ln = listNext(&li))) {
1627          client *slave = ln->value;
1628          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
1629              uint64_t j;
1630              int errorcode = 0;
1631              for (j = 0; j < ok_slaves[0]; j++) {
1632                  if (slave->id == ok_slaves[2*j+1]) {
1633                      errorcode = (int)(ok_slaves[2*j+2]);                        WIN_PORT_FIX &bsol;* cast (int) */
1634                      break; &bsol;* Found in slaves list. */
1635                  }
1636              }
1637              if (j == ok_slaves[0] || errorcode != 0) {
1638                  serverLog(LL_WARNING,
1639                  "Closing slave %s: child->slave RDB transfer failed: %s",
1640                      replicationGetSlaveName(slave),
1641                      (errorcode == 0) ? "RDB transfer child aborted"
1642                                       : strerror(errorcode));
1643                  freeClient(slave);
1644              } else {
1645                  serverLog(LL_WARNING,
1646                  "Slave %s correctly received the streamed RDB file.",
1647                      replicationGetSlaveName(slave));
1648                  anetNonBlock(NULL,slave->fd);
1649                  anetSendTimeout(NULL,slave->fd,0);
1650              }
1651          }
1652      }
1653      zfree(ok_slaves);
1654      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
1655  }
1656  void backgroundSaveDoneHandler(int exitcode, int bysignal) {
1657      switch(server.rdb_child_type) {
1658      case RDB_CHILD_TYPE_DISK:
1659          backgroundSaveDoneHandlerDisk(exitcode,bysignal);
1660          break;
1661      case RDB_CHILD_TYPE_SOCKET:
1662          backgroundSaveDoneHandlerSocket(exitcode,bysignal);
1663          break;
1664      default:
1665          serverPanic("Unknown RDB child type.");
1666          break;
1667      }
1668  }
1669  int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
1670      int *fds;
1671      uint64_t *clientids;
1672      int numfds;
1673      listNode *ln;
1674      listIter li;
1675      pid_t childpid;
1676      PORT_LONGLONG start;
1677      int pipefds[2];
1678      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1679      if (pipe(pipefds) == -1) return C_ERR;
1680      server.rdb_pipe_read_result_from_child = pipefds[0];
1681      server.rdb_pipe_write_result_to_parent = pipefds[1];
1682      fds = zmalloc(sizeof(int)*listLength(server.slaves));
1683      clientids = zmalloc(sizeof(uint64_t)*listLength(server.slaves));
1684      numfds = 0;
1685      listRewind(server.slaves,&li);
1686      while((ln = listNext(&li))) {
1687          client *slave = ln->value;
1688          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1689              clientids[numfds] = slave->id;
1690              fds[numfds++] = slave->fd;
1691              replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());
1692              anetBlock(NULL,slave->fd);
1693              anetSendTimeout(NULL,slave->fd,(PORT_ULONG)server.repl_timeout*1000);  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1694          }
1695      }
1696      openChildInfoPipe();
1697      start = ustime();
1698  #ifdef _WIN32
1699      childpid = BeginForkOperation_Socket(fds, numfds, clientids, pipefds[1], &server, sizeof(server), dictGetHashFunctionSeed(), modules);
1700  #else
1701      if ((childpid = fork()) == 0) {
1702          int retval;
1703          rio slave_sockets;
1704          rioInitWithFdset(&slave_sockets,fds,numfds);
1705          zfree(fds);
1706          closeListeningSockets(0);
1707          redisSetProcTitle("redis-rdb-to-slaves");
1708          retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL,rsi);
1709          if (retval == C_OK && rioFlush(&slave_sockets) == 0)
1710              retval = C_ERR;
1711          if (retval == C_OK) {
1712              size_t private_dirty = zmalloc_get_private_dirty(-1);
1713              if (private_dirty) {
1714                  serverLog(LL_NOTICE,
1715                      "RDB: %zu MB of memory used by copy-on-write",
1716                      private_dirty/(1024*1024));
1717              }
1718              server.child_info_data.cow_size = private_dirty;
1719              sendChildInfo(CHILD_INFO_TYPE_RDB);
1720              void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
1721              uint64_t *len = msg;
1722              uint64_t *ids = len+1;
1723              int j, msglen;
1724              *len = numfds;
1725              for (j = 0; j < numfds; j++) {
1726                  *ids++ = clientids[j];
1727                  *ids++ = slave_sockets.io.fdset.state[j];
1728              }
1729              msglen = sizeof(uint64_t)*(1+2*numfds);
1730              if (*len == 0 ||
1731                  write(server.rdb_pipe_write_result_to_parent,msg,msglen)
1732                  != msglen)
1733              {
1734                  retval = C_ERR;
1735              }
1736              zfree(msg);
1737          }
1738          zfree(clientids);
1739          rioFreeFdset(&slave_sockets);
1740          exitFromChild((retval == C_OK) ? 0 : 1);
1741      } else {
1742  #endif
1743          if (childpid == -1) {
1744              serverLog(LL_WARNING,"Can't save in background: fork: %s",
1745                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1746              listRewind(server.slaves,&li);
1747              while((ln = listNext(&li))) {
1748                  client *slave = ln->value;
1749                  int j;
1750                  for (j = 0; j < numfds; j++) {
1751                      if (slave->id == clientids[j]) {
1752                          slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
1753                          break;
1754                      }
1755                  }
1756              }
1757              close(pipefds[0]);
1758              close(pipefds[1]);
1759              closeChildInfoPipe();
1760          } else {
1761              server.stat_fork_time = ustime()-start;
1762  #ifdef _WIN32
1763              if (server.stat_fork_time == 0) {
1764                  server.stat_fork_time = 100000; 
1765              }
1766  #endif
1767              server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1768              latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1769              serverLog(LL_NOTICE,"Background RDB transfer started by pid %d",
1770                  childpid);
1771              server.rdb_save_time_start = time(NULL);
1772              server.rdb_child_pid = childpid;
1773              server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;
1774              updateDictResizePolicy();
1775          }
1776          zfree(clientids);
1777          zfree(fds);
1778          return (childpid == -1) ? C_ERR : C_OK;
1779  #ifndef _WIN32
1780      }
1781  #endif
1782      return C_OK; &bsol;* Unreached. */
1783  }
1784  void saveCommand(client *c) {
1785      if (server.rdb_child_pid != -1) {
1786          addReplyError(c,"Background save already in progress");
1787          return;
1788      }
1789      rdbSaveInfo rsi, *rsiptr;
1790      rsiptr = rdbPopulateSaveInfo(&rsi);
1791      if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {
1792          addReply(c,shared.ok);
1793      } else {
1794          addReply(c,shared.err);
1795      }
1796  }
1797  void bgsaveCommand(client *c) {
1798      int schedule = 0;
1799      if (c->argc > 1) {
1800          if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"schedule")) {
1801              schedule = 1;
1802          } else {
1803              addReply(c,shared.syntaxerr);
1804              return;
1805          }
1806      }
1807      rdbSaveInfo rsi, *rsiptr;
1808      rsiptr = rdbPopulateSaveInfo(&rsi);
1809      if (server.rdb_child_pid != -1) {
1810          addReplyError(c,"Background save already in progress");
1811      } else if (server.aof_child_pid != -1) {
1812          if (schedule) {
1813              server.rdb_bgsave_scheduled = 1;
1814              addReplyStatus(c,"Background saving scheduled");
1815          } else {
1816              addReplyError(c,
1817                  "An AOF log rewriting in progress: can't BGSAVE right now. "
1818                  "Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever "
1819                  "possible.");
1820          }
1821      } else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) {
1822          addReplyStatus(c,"Background saving started");
1823      } else {
1824          addReply(c,shared.err);
1825      }
1826  }
1827  rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
1828      rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
1829      *rsi = rsi_init;
1830      if (!server.masterhost && server.repl_backlog) {
1831          rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
1832          return rsi;
1833      }
1834      if (server.master) {
1835          rsi->repl_stream_db = server.master->db->id;
1836          return rsi;
1837      }
1838      if (server.cached_master) {
1839          rsi->repl_stream_db = server.cached_master->db->id;
1840          return rsi;
1841      }
1842      return NULL;
1843  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</h3>
            <pre><code>1  #include "server.h"
2  #include <math.h>
3  #ifdef _WIN32
4  #define bzero(b,len) (memset((b), '\0', (len)), (void) 0)
5  #endif
6  int zslLexValueGteMin(sds value, zlexrangespec *spec);
7  int zslLexValueLteMax(sds value, zlexrangespec *spec);
8  zskiplistNode *zslCreateNode(int level, double score, sds ele) {
9      zskiplistNode *zn =
10          zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
11      zn->score = score;
12      zn->ele = ele;
13      return zn;
14  }
15  zskiplist *zslCreate(void) {
16      int j;
17      zskiplist *zsl;
18      zsl = zmalloc(sizeof(*zsl));
19      zsl->level = 1;
20      zsl->length = 0;
21      zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
22      for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
23          zsl->header->level[j].forward = NULL;
24          zsl->header->level[j].span = 0;
25      }
26      zsl->header->backward = NULL;
27      zsl->tail = NULL;
28      return zsl;
29  }
30  void zslFreeNode(zskiplistNode *node) {
31      sdsfree(node->ele);
32      zfree(node);
33  }
34  void zslFree(zskiplist *zsl) {
35      zskiplistNode *node = zsl->header->level[0].forward, *next;
36      zfree(zsl->header);
37      while(node) {
38          next = node->level[0].forward;
39          zslFreeNode(node);
40          node = next;
41      }
42      zfree(zsl);
43  }
44  int zslRandomLevel(void) {
45      int level = 1;
46      while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
47          level += 1;
48      return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
49  }
50  zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
51      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
52      unsigned int rank[ZSKIPLIST_MAXLEVEL];
53      int i, level;
54      serverAssert(!isnan(score));
55      x = zsl->header;
56      for (i = zsl->level-1; i >= 0; i--) {
57          rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
58          while (x->level[i].forward &&
59                  (x->level[i].forward->score < score ||
60                      (x->level[i].forward->score == score &&
61                      sdscmp(x->level[i].forward->ele,ele) < 0)))
62          {
63              rank[i] += x->level[i].span;
64              x = x->level[i].forward;
65          }
66          update[i] = x;
67      }
68      level = zslRandomLevel();
69      if (level > zsl->level) {
70          for (i = zsl->level; i < level; i++) {
71              rank[i] = 0;
72              update[i] = zsl->header;
73              update[i]->level[i].span = zsl->length;
74          }
75          zsl->level = level;
76      }
77      x = zslCreateNode(level,score,ele);
78      for (i = 0; i < level; i++) {
79          x->level[i].forward = update[i]->level[i].forward;
80          update[i]->level[i].forward = x;
81          x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
82          update[i]->level[i].span = (rank[0] - rank[i]) + 1;
83      }
84      for (i = level; i < zsl->level; i++) {
85          update[i]->level[i].span++;
86      }
87      x->backward = (update[0] == zsl->header) ? NULL : update[0];
88      if (x->level[0].forward)
89          x->level[0].forward->backward = x;
90      else
91          zsl->tail = x;
92      zsl->length++;
93      return x;
94  }
95  void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
96      int i;
97      for (i = 0; i < zsl->level; i++) {
98          if (update[i]->level[i].forward == x) {
99              update[i]->level[i].span += x->level[i].span - 1;
100              update[i]->level[i].forward = x->level[i].forward;
101          } else {
102              update[i]->level[i].span -= 1;
103          }
104      }
105      if (x->level[0].forward) {
106          x->level[0].forward->backward = x->backward;
107      } else {
108          zsl->tail = x->backward;
109      }
110      while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
111          zsl->level--;
112      zsl->length--;
113  }
114  int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
115      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
116      int i;
117      x = zsl->header;
118      for (i = zsl->level-1; i >= 0; i--) {
119          while (x->level[i].forward &&
120                  (x->level[i].forward->score < score ||
121                      (x->level[i].forward->score == score &&
122                       sdscmp(x->level[i].forward->ele,ele) < 0)))
123          {
124              x = x->level[i].forward;
125          }
126          update[i] = x;
127      }
128      x = x->level[0].forward;
129      if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
130          zslDeleteNode(zsl, x, update);
131          if (!node)
132              zslFreeNode(x);
133          else
134              *node = x;
135          return 1;
136      }
137      return 0; &bsol;* not found */
138  }
139  zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
140      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
141      int i;
142      x = zsl->header;
143      for (i = zsl->level-1; i >= 0; i--) {
144          while (x->level[i].forward &&
145                  (x->level[i].forward->score < curscore ||
146                      (x->level[i].forward->score == curscore &&
147                       sdscmp(x->level[i].forward->ele,ele) < 0)))
148          {
149              x = x->level[i].forward;
150          }
151          update[i] = x;
152      }
153      x = x->level[0].forward;
154      serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);
155      if ((x->backward == NULL || x->backward->score < newscore) &&
156          (x->level[0].forward == NULL || x->level[0].forward->score > newscore))
157      {
158          x->score = newscore;
159          return x;
160      }
161      zslDeleteNode(zsl, x, update);
162      zskiplistNode *newnode = zslInsert(zsl,newscore,x->ele);
163      x->ele = NULL;
164      zslFreeNode(x);
165      return newnode;
166  }
167  int zslValueGteMin(double value, zrangespec *spec) {
168      return spec->minex ? (value > spec->min) : (value >= spec->min);
169  }
170  int zslValueLteMax(double value, zrangespec *spec) {
171      return spec->maxex ? (value < spec->max) : (value <= spec->max);
172  }
173  int zslIsInRange(zskiplist *zsl, zrangespec *range) {
174      zskiplistNode *x;
175      if (range->min > range->max ||
176              (range->min == range->max && (range->minex || range->maxex)))
177          return 0;
178      x = zsl->tail;
179      if (x == NULL || !zslValueGteMin(x->score,range))
180          return 0;
181      x = zsl->header->level[0].forward;
182      if (x == NULL || !zslValueLteMax(x->score,range))
183          return 0;
184      return 1;
185  }
186  zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
187      zskiplistNode *x;
188      int i;
189      if (!zslIsInRange(zsl,range)) return NULL;
190      x = zsl->header;
191      for (i = zsl->level-1; i >= 0; i--) {
192          while (x->level[i].forward &&
193              !zslValueGteMin(x->level[i].forward->score,range))
194                  x = x->level[i].forward;
195      }
196      x = x->level[0].forward;
197      serverAssert(x != NULL);
198      if (!zslValueLteMax(x->score,range)) return NULL;
199      return x;
200  }
201  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
202      zskiplistNode *x;
203      int i;
204      if (!zslIsInRange(zsl,range)) return NULL;
205      x = zsl->header;
206      for (i = zsl->level-1; i >= 0; i--) {
207          while (x->level[i].forward &&
208              zslValueLteMax(x->level[i].forward->score,range))
209                  x = x->level[i].forward;
210      }
211      serverAssert(x != NULL);
212      if (!zslValueGteMin(x->score,range)) return NULL;
213      return x;
214  }
<span onclick='openModal()' class='match'>215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
216      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
</span>217      PORT_ULONG removed = 0;
218      int i;
219      x = zsl->header;
220      for (i = zsl->level-1; i >= 0; i--) {
221          while (x->level[i].forward && (range->minex ?
222              x->level[i].forward->score <= range->min :
223              x->level[i].forward->score < range->min))
224                  x = x->level[i].forward;
225          update[i] = x;
226      }
227      x = x->level[0].forward;
228      while (x &&
229             (range->maxex ? x->score < range->max : x->score <= range->max))
230      {
231          zskiplistNode *next = x->level[0].forward;
232          zslDeleteNode(zsl,x,update);
233          dictDelete(dict,x->ele);
234          zslFreeNode(x); &bsol;* Here is where x->ele is actually released. */
235          removed++;
236          x = next;
237      }
238      return removed;
239  }
240  PORT_ULONG zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
241      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
242      PORT_ULONG removed = 0;
243      int i;
244      x = zsl->header;
245      for (i = zsl->level-1; i >= 0; i--) {
246          while (x->level[i].forward &&
247              !zslLexValueGteMin(x->level[i].forward->ele,range))
248                  x = x->level[i].forward;
249          update[i] = x;
250      }
251      x = x->level[0].forward;
252      while (x && zslLexValueLteMax(x->ele,range)) {
253          zskiplistNode *next = x->level[0].forward;
254          zslDeleteNode(zsl,x,update);
255          dictDelete(dict,x->ele);
256          zslFreeNode(x); &bsol;* Here is where x->ele is actually released. */
257          removed++;
258          x = next;
259      }
260      return removed;
261  }
262  PORT_ULONG zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
263      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
264      PORT_ULONG traversed = 0, removed = 0;
265      int i;
266      x = zsl->header;
267      for (i = zsl->level-1; i >= 0; i--) {
268          while (x->level[i].forward && (traversed + x->level[i].span) < start) {
269              traversed += x->level[i].span;
270              x = x->level[i].forward;
271          }
272          update[i] = x;
273      }
274      traversed++;
275      x = x->level[0].forward;
276      while (x && traversed <= end) {
277          zskiplistNode *next = x->level[0].forward;
278          zslDeleteNode(zsl,x,update);
279          dictDelete(dict,x->ele);
280          zslFreeNode(x);
281          removed++;
282          traversed++;
283          x = next;
284      }
285      return removed;
286  }
287  PORT_ULONG zslGetRank(zskiplist *zsl, double score, sds ele) {
288      zskiplistNode *x;
289      PORT_ULONG rank = 0;
290      int i;
291      x = zsl->header;
292      for (i = zsl->level-1; i >= 0; i--) {
293          while (x->level[i].forward &&
294              (x->level[i].forward->score < score ||
295                  (x->level[i].forward->score == score &&
296                  sdscmp(x->level[i].forward->ele,ele) <= 0))) {
297              rank += x->level[i].span;
298              x = x->level[i].forward;
299          }
300          if (x->ele && sdscmp(x->ele,ele) == 0) {
301              return rank;
302          }
303      }
304      return 0;
305  }
306  zskiplistNode* zslGetElementByRank(zskiplist *zsl, PORT_ULONG rank) {
307      zskiplistNode *x;
308      PORT_ULONG traversed = 0;
309      int i;
310      x = zsl->header;
311      for (i = zsl->level-1; i >= 0; i--) {
312          while (x->level[i].forward && (traversed + x->level[i].span) <= rank)
313          {
314              traversed += x->level[i].span;
315              x = x->level[i].forward;
316          }
317          if (traversed == rank) {
318              return x;
319          }
320      }
321      return NULL;
322  }
323  static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
324      char *eptr;
325      spec->minex = spec->maxex = 0;
326      if (min->encoding == OBJ_ENCODING_INT) {
327          spec->min = (PORT_LONG)min->ptr;
328      } else {
329          if (((char*)min->ptr)[0] == '(') {
330              spec->min = strtod((char*)min->ptr+1,&eptr);
331              if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
332              spec->minex = 1;
333          } else {
334              spec->min = strtod((char*)min->ptr,&eptr);
335              if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
336          }
337      }
338      if (max->encoding == OBJ_ENCODING_INT) {
339          spec->max = (PORT_LONG)max->ptr;
340      } else {
341          if (((char*)max->ptr)[0] == '(') {
342              spec->max = strtod((char*)max->ptr+1,&eptr);
343              if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
344              spec->maxex = 1;
345          } else {
346              spec->max = strtod((char*)max->ptr,&eptr);
347              if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
348          }
349      }
350      return C_OK;
351  }
352  int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
353      char *c = item->ptr;
354      switch(c[0]) {
355      case '+':
356          if (c[1] != '\0') return C_ERR;
357          *ex = 1;
358          *dest = shared.maxstring;
359          return C_OK;
360      case '-':
361          if (c[1] != '\0') return C_ERR;
362          *ex = 1;
363          *dest = shared.minstring;
364          return C_OK;
365      case '(':
366          *ex = 1;
367          *dest = sdsnewlen(c+1,sdslen(c)-1);
368          return C_OK;
369      case '[':
370          *ex = 0;
371          *dest = sdsnewlen(c+1,sdslen(c)-1);
372          return C_OK;
373      default:
374          return C_ERR;
375      }
376  }
377  void zslFreeLexRange(zlexrangespec *spec) {
378      if (spec->min != shared.minstring &&
379          spec->min != shared.maxstring) sdsfree(spec->min);
380      if (spec->max != shared.minstring &&
381          spec->max != shared.maxstring) sdsfree(spec->max);
382  }
383  int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
384      if (min->encoding == OBJ_ENCODING_INT ||
385          max->encoding == OBJ_ENCODING_INT) return C_ERR;
386      spec->min = spec->max = NULL;
387      if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
388          zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
389          zslFreeLexRange(spec);
390          return C_ERR;
391      } else {
392          return C_OK;
393      }
394  }
395  int sdscmplex(sds a, sds b) {
396      if (a == b) return 0;
397      if (a == shared.minstring || b == shared.maxstring) return -1;
398      if (a == shared.maxstring || b == shared.minstring) return 1;
399      return sdscmp(a,b);
400  }
401  int zslLexValueGteMin(sds value, zlexrangespec *spec) {
402      return spec->minex ?
403          (sdscmplex(value,spec->min) > 0) :
404          (sdscmplex(value,spec->min) >= 0);
405  }
406  int zslLexValueLteMax(sds value, zlexrangespec *spec) {
407      return spec->maxex ?
408          (sdscmplex(value,spec->max) < 0) :
409          (sdscmplex(value,spec->max) <= 0);
410  }
411  int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
412      zskiplistNode *x;
413      int cmp = sdscmplex(range->min,range->max);
414      if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
415          return 0;
416      x = zsl->tail;
417      if (x == NULL || !zslLexValueGteMin(x->ele,range))
418          return 0;
419      x = zsl->header->level[0].forward;
420      if (x == NULL || !zslLexValueLteMax(x->ele,range))
421          return 0;
422      return 1;
423  }
424  zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
425      zskiplistNode *x;
426      int i;
427      if (!zslIsInLexRange(zsl,range)) return NULL;
428      x = zsl->header;
429      for (i = zsl->level-1; i >= 0; i--) {
430          while (x->level[i].forward &&
431              !zslLexValueGteMin(x->level[i].forward->ele,range))
432                  x = x->level[i].forward;
433      }
434      x = x->level[0].forward;
435      serverAssert(x != NULL);
436      if (!zslLexValueLteMax(x->ele,range)) return NULL;
437      return x;
438  }
439  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
440      zskiplistNode *x;
441      int i;
442      if (!zslIsInLexRange(zsl,range)) return NULL;
443      x = zsl->header;
444      for (i = zsl->level-1; i >= 0; i--) {
445          while (x->level[i].forward &&
446              zslLexValueLteMax(x->level[i].forward->ele,range))
447                  x = x->level[i].forward;
448      }
449      serverAssert(x != NULL);
450      if (!zslLexValueGteMin(x->ele,range)) return NULL;
451      return x;
452  }
453  double zzlGetScore(unsigned char *sptr) {
454      unsigned char *vstr;
455      unsigned int vlen;
456      PORT_LONGLONG vlong;
457      char buf[128];
458      double score;
459      serverAssert(sptr != NULL);
460      serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
461      if (vstr) {
462          memcpy(buf,vstr,vlen);
463          buf[vlen] = '\0';
464          score = strtod(buf,NULL);
465      } else {
466          score = (double)vlong;                                                  WIN_PORT_FIX &bsol;* cast (double) */
467      }
468      return score;
469  }
470  sds ziplistGetObject(unsigned char *sptr) {
471      unsigned char *vstr;
472      unsigned int vlen;
473      PORT_LONGLONG vlong;
474      serverAssert(sptr != NULL);
475      serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
476      if (vstr) {
477          return sdsnewlen((char*)vstr,vlen);
478      } else {
479          return sdsfromlonglong(vlong);
480      }
481  }
482  int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
483      unsigned char *vstr;
484      unsigned int vlen;
485      PORT_LONGLONG vlong;
486      unsigned char vbuf[32];
487      int minlen, cmp;
488      serverAssert(ziplistGet(eptr,&vstr,&vlen,&vlong));
489      if (vstr == NULL) {
490          vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
491          vstr = vbuf;
492      }
493      minlen = (vlen < clen) ? vlen : clen;
494      cmp = memcmp(vstr,cstr,minlen);
495      if (cmp == 0) return vlen-clen;
496      return cmp;
497  }
498  unsigned int zzlLength(unsigned char *zl) {
499      return ziplistLen(zl)/2;
500  }
501  void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
502      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &bsol;* compiler error: _sptr -> l_sptr */
503      serverAssert(*eptr != NULL && *sptr != NULL);
504      l_eptr = ziplistNext(zl, *sptr);
505      if (l_eptr != NULL) {
506          l_sptr = ziplistNext(zl, l_eptr);
507          serverAssert(l_sptr != NULL);
508      } else {
509          l_sptr = NULL;
510      }
511      *eptr = l_eptr;
512      *sptr = l_sptr;
513  }
514  void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
515      unsigned char *l_eptr, *l_sptr;                                             WIN_PORT_FIX &bsol;* compiler error: _sptr -> l_sptr */
516      serverAssert(*eptr != NULL && *sptr != NULL);
517      l_sptr = ziplistPrev(zl, *eptr);
518      if (l_sptr != NULL) {
519          l_eptr = ziplistPrev(zl, l_sptr);
520          serverAssert(l_eptr != NULL);
521      } else {
522          l_eptr = NULL;
523      }
524      *eptr = l_eptr;
525      *sptr = l_sptr;
526  }
527  int zzlIsInRange(unsigned char *zl, zrangespec *range) {
528      unsigned char *p;
529      double score;
530      if (range->min > range->max ||
531              (range->min == range->max && (range->minex || range->maxex)))
532          return 0;
533      p = ziplistIndex(zl,-1); &bsol;* Last score. */
534      if (p == NULL) return 0; &bsol;* Empty sorted set */
535      score = zzlGetScore(p);
536      if (!zslValueGteMin(score,range))
537          return 0;
538      p = ziplistIndex(zl,1); &bsol;* First score. */
539      serverAssert(p != NULL);
540      score = zzlGetScore(p);
541      if (!zslValueLteMax(score,range))
542          return 0;
543      return 1;
544  }
545  unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
546      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
547      double score;
548      if (!zzlIsInRange(zl,range)) return NULL;
549      while (eptr != NULL) {
550          sptr = ziplistNext(zl,eptr);
551          serverAssert(sptr != NULL);
552          score = zzlGetScore(sptr);
553          if (zslValueGteMin(score,range)) {
554              if (zslValueLteMax(score,range))
555                  return eptr;
556              return NULL;
557          }
558          eptr = ziplistNext(zl,sptr);
559      }
560      return NULL;
561  }
562  unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
563      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
564      double score;
565      if (!zzlIsInRange(zl,range)) return NULL;
566      while (eptr != NULL) {
567          sptr = ziplistNext(zl,eptr);
568          serverAssert(sptr != NULL);
569          score = zzlGetScore(sptr);
570          if (zslValueLteMax(score,range)) {
571              if (zslValueGteMin(score,range))
572                  return eptr;
573              return NULL;
574          }
575          sptr = ziplistPrev(zl,eptr);
576          if (sptr != NULL)
577              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
578          else
579              eptr = NULL;
580      }
581      return NULL;
582  }
583  int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
584      sds value = ziplistGetObject(p);
585      int res = zslLexValueGteMin(value,spec);
586      sdsfree(value);
587      return res;
588  }
589  int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
590      sds value = ziplistGetObject(p);
591      int res = zslLexValueLteMax(value,spec);
592      sdsfree(value);
593      return res;
594  }
595  int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
596      unsigned char *p;
597      int cmp = sdscmplex(range->min,range->max);
598      if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
599          return 0;
600      p = ziplistIndex(zl,-2); &bsol;* Last element. */
601      if (p == NULL) return 0;
602      if (!zzlLexValueGteMin(p,range))
603          return 0;
604      p = ziplistIndex(zl,0); &bsol;* First element. */
605      serverAssert(p != NULL);
606      if (!zzlLexValueLteMax(p,range))
607          return 0;
608      return 1;
609  }
610  unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
611      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
612      if (!zzlIsInLexRange(zl,range)) return NULL;
613      while (eptr != NULL) {
614          if (zzlLexValueGteMin(eptr,range)) {
615              if (zzlLexValueLteMax(eptr,range))
616                  return eptr;
617              return NULL;
618          }
619          sptr = ziplistNext(zl,eptr); &bsol;* This element score. Skip it. */
620          serverAssert(sptr != NULL);
621          eptr = ziplistNext(zl,sptr); &bsol;* Next element. */
622      }
623      return NULL;
624  }
625  unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
626      unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
627      if (!zzlIsInLexRange(zl,range)) return NULL;
628      while (eptr != NULL) {
629          if (zzlLexValueLteMax(eptr,range)) {
630              if (zzlLexValueGteMin(eptr,range))
631                  return eptr;
632              return NULL;
633          }
634          sptr = ziplistPrev(zl,eptr);
635          if (sptr != NULL)
636              serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
637          else
638              eptr = NULL;
639      }
640      return NULL;
641  }
642  unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
643      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
644      while (eptr != NULL) {
645          sptr = ziplistNext(zl,eptr);
646          serverAssert(sptr != NULL);
647          if (ziplistCompare(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele))) {     WIN_PORT_FIX &bsol;* unsigned int */
648              if (score != NULL) *score = zzlGetScore(sptr);
649              return eptr;
650          }
651          eptr = ziplistNext(zl,sptr);
652      }
653      return NULL;
654  }
655  unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
656      unsigned char *p = eptr;
657      zl = ziplistDelete(zl,&p);
658      zl = ziplistDelete(zl,&p);
659      return zl;
660  }
661  unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
662      unsigned char *sptr;
663      char scorebuf[128];
664      int scorelen;
665      size_t offset;
666      scorelen = d2string(scorebuf,sizeof(scorebuf),score);
667      if (eptr == NULL) {
668          zl = ziplistPush(zl,(unsigned char*)ele,(unsigned int)sdslen(ele),ZIPLIST_TAIL); WIN_PORT_FIX &bsol;* unsigned int */
669          zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
670      } else {
671          offset = eptr-zl;
672          zl = ziplistInsert(zl,eptr,(unsigned char*)ele,(unsigned int)sdslen(ele));    WIN_PORT_FIX &bsol;* unsigned int */
673          eptr = zl+offset;
674          serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
675          zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
676      }
677      return zl;
678  }
679  unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
680      unsigned char *eptr = ziplistIndex(zl,0), *sptr;
681      double s;
682      while (eptr != NULL) {
683          sptr = ziplistNext(zl,eptr);
684          serverAssert(sptr != NULL);
685          s = zzlGetScore(sptr);
686          if (s > score) {
687              zl = zzlInsertAt(zl,eptr,ele,score);
688              break;
689          } else if (s == score) {
690              if (zzlCompareElements(eptr,(unsigned char*)ele,(unsigned int)sdslen(ele)) > 0) { WIN_PORT_FIX &bsol;* unsigned int */
691                  zl = zzlInsertAt(zl,eptr,ele,score);
692                  break;
693              }
694          }
695          eptr = ziplistNext(zl,sptr);
696      }
697      if (eptr == NULL)
698          zl = zzlInsertAt(zl,NULL,ele,score);
699      return zl;
700  }
701  unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, PORT_ULONG *deleted) {
702      unsigned char *eptr, *sptr;
703      double score;
704      PORT_ULONG num = 0;
705      if (deleted != NULL) *deleted = 0;
706      eptr = zzlFirstInRange(zl,range);
707      if (eptr == NULL) return zl;
708      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
709          score = zzlGetScore(sptr);
710          if (zslValueLteMax(score,range)) {
711              zl = ziplistDelete(zl,&eptr);
712              zl = ziplistDelete(zl,&eptr);
713              num++;
714          } else {
715              break;
716          }
717      }
718      if (deleted != NULL) *deleted = num;
719      return zl;
720  }
721  unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, PORT_ULONG *deleted) {
722      unsigned char *eptr, *sptr;
723      PORT_ULONG num = 0;
724      if (deleted != NULL) *deleted = 0;
725      eptr = zzlFirstInLexRange(zl,range);
726      if (eptr == NULL) return zl;
727      while ((sptr = ziplistNext(zl,eptr)) != NULL) {
728          if (zzlLexValueLteMax(eptr,range)) {
729              zl = ziplistDelete(zl,&eptr);
730              zl = ziplistDelete(zl,&eptr);
731              num++;
732          } else {
733              break;
734          }
735      }
736      if (deleted != NULL) *deleted = num;
737      return zl;
738  }
739  unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, PORT_ULONG *deleted) {
740      unsigned int num = (end-start)+1;
741      if (deleted) *deleted = num;
742      zl = ziplistDeleteRange(zl,2*(start-1),2*num);
743      return zl;
744  }
745  PORT_ULONG zsetLength(const robj *zobj) {
746      PORT_ULONG length = 0;
747      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
748          length = zzlLength(zobj->ptr);
749      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
750          length = (PORT_ULONG) ((const zset*)zobj->ptr)->zsl->length;                         WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
751      } else {
752          serverPanic("Unknown sorted set encoding");
753      }
754      return length;
755  }
756  void zsetConvert(robj *zobj, int encoding) {
757      zset *zs;
758      zskiplistNode *node, *next;
759      sds ele;
760      double score;
761      if (zobj->encoding == encoding) return;
762      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
763          unsigned char *zl = zobj->ptr;
764          unsigned char *eptr, *sptr;
765          unsigned char *vstr;
766          unsigned int vlen;
767          PORT_LONGLONG vlong;
768          if (encoding != OBJ_ENCODING_SKIPLIST)
769              serverPanic("Unknown target encoding");
770          zs = zmalloc(sizeof(*zs));
771          zs->dict = dictCreate(&zsetDictType,NULL);
772          zs->zsl = zslCreate();
773          eptr = ziplistIndex(zl,0);
774          serverAssertWithInfo(NULL,zobj,eptr != NULL);
775          sptr = ziplistNext(zl,eptr);
776          serverAssertWithInfo(NULL,zobj,sptr != NULL);
777          while (eptr != NULL) {
778              score = zzlGetScore(sptr);
779              serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
780              if (vstr == NULL)
781                  ele = sdsfromlonglong(vlong);
782              else
783                  ele = sdsnewlen((char*)vstr,vlen);
784              node = zslInsert(zs->zsl,score,ele);
785              serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);
786              zzlNext(zl,&eptr,&sptr);
787          }
788          zfree(zobj->ptr);
789          zobj->ptr = zs;
790          zobj->encoding = OBJ_ENCODING_SKIPLIST;
791      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
792          unsigned char *zl = ziplistNew();
793          if (encoding != OBJ_ENCODING_ZIPLIST)
794              serverPanic("Unknown target encoding");
795          zs = zobj->ptr;
796          dictRelease(zs->dict);
797          node = zs->zsl->header->level[0].forward;
798          zfree(zs->zsl->header);
799          zfree(zs->zsl);
800          while (node) {
801              zl = zzlInsertAt(zl,NULL,node->ele,node->score);
802              next = node->level[0].forward;
803              zslFreeNode(node);
804              node = next;
805          }
806          zfree(zs);
807          zobj->ptr = zl;
808          zobj->encoding = OBJ_ENCODING_ZIPLIST;
809      } else {
810          serverPanic("Unknown sorted set encoding");
811      }
812  }
813  void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
814      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;
815      zset *zset = zobj->ptr;
816      if (zset->zsl->length <= server.zset_max_ziplist_entries &&
817          maxelelen <= server.zset_max_ziplist_value)
818              zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
819  }
820  int zsetScore(robj *zobj, sds member, double *score) {
821      if (!zobj || !member) return C_ERR;
822      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
823          if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
824      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
825          zset *zs = zobj->ptr;
826          dictEntry *de = dictFind(zs->dict, member);
827          if (de == NULL) return C_ERR;
828          *score = *(double*)dictGetVal(de);
829      } else {
830          serverPanic("Unknown sorted set encoding");
831      }
832      return C_OK;
833  }
834  int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {
835      int incr = (*flags & ZADD_INCR) != 0;
836      int nx = (*flags & ZADD_NX) != 0;
837      int xx = (*flags & ZADD_XX) != 0;
838      *flags = 0; &bsol;* We'll return our response flags. */
839      double curscore;
840      if (isnan(score)) {
841          *flags = ZADD_NAN;
842          return 0;
843      }
844      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
845          unsigned char *eptr;
846          if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
847              if (nx) {
848                  *flags |= ZADD_NOP;
849                  return 1;
850              }
851              if (incr) {
852                  score += curscore;
853                  if (isnan(score)) {
854                      *flags |= ZADD_NAN;
855                      return 0;
856                  }
857                  if (newscore) *newscore = score;
858              }
859              if (score != curscore) {
860                  zobj->ptr = zzlDelete(zobj->ptr,eptr);
861                  zobj->ptr = zzlInsert(zobj->ptr,ele,score);
862                  *flags |= ZADD_UPDATED;
863              }
864              return 1;
865          } else if (!xx) {
866              zobj->ptr = zzlInsert(zobj->ptr,ele,score);
867              if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||
868                  sdslen(ele) > server.zset_max_ziplist_value)
869                  zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
870              if (newscore) *newscore = score;
871              *flags |= ZADD_ADDED;
872              return 1;
873          } else {
874              *flags |= ZADD_NOP;
875              return 1;
876          }
877      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
878          zset *zs = zobj->ptr;
879          zskiplistNode *znode;
880          dictEntry *de;
881          de = dictFind(zs->dict,ele);
882          if (de != NULL) {
883              if (nx) {
884                  *flags |= ZADD_NOP;
885                  return 1;
886              }
887              curscore = *(double*)dictGetVal(de);
888              if (incr) {
889                  score += curscore;
890                  if (isnan(score)) {
891                      *flags |= ZADD_NAN;
892                      return 0;
893                  }
894                  if (newscore) *newscore = score;
895              }
896              if (score != curscore) {
897                  znode = zslUpdateScore(zs->zsl,curscore,ele,score);
898                  dictGetVal(de) = &znode->score; &bsol;* Update score ptr. */
899                  *flags |= ZADD_UPDATED;
900              }
901              return 1;
902          } else if (!xx) {
903              ele = sdsdup(ele);
904              znode = zslInsert(zs->zsl,score,ele);
905              serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
906              *flags |= ZADD_ADDED;
907              if (newscore) *newscore = score;
908              return 1;
909          } else {
910              *flags |= ZADD_NOP;
911              return 1;
912          }
913      } else {
914          serverPanic("Unknown sorted set encoding");
915      }
916      return 0; &bsol;* Never reached. */
917  }
918  int zsetDel(robj *zobj, sds ele) {
919      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
920          unsigned char *eptr;
921          if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
922              zobj->ptr = zzlDelete(zobj->ptr,eptr);
923              return 1;
924          }
925      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
926          zset *zs = zobj->ptr;
927          dictEntry *de;
928          double score;
929          de = dictUnlink(zs->dict,ele);
930          if (de != NULL) {
931              score = *(double*)dictGetVal(de);
932              dictFreeUnlinkedEntry(zs->dict,de);
933              int retval = zslDelete(zs->zsl,score,ele,NULL);
934              serverAssert(retval);
935              if (htNeedsResize(zs->dict)) dictResize(zs->dict);
936              return 1;
937          }
938      } else {
939          serverPanic("Unknown sorted set encoding");
940      }
941      return 0; &bsol;* No such element found. */
942  }
943  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse) {
944      PORT_ULONG llen;
945      PORT_ULONG rank;
946      llen = zsetLength(zobj);
947      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
948          unsigned char *zl = zobj->ptr;
949          unsigned char *eptr, *sptr;
950          eptr = ziplistIndex(zl,0);
951          serverAssert(eptr != NULL);
952          sptr = ziplistNext(zl,eptr);
953          serverAssert(sptr != NULL);
954          rank = 1;
955          while(eptr != NULL) {
956              if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
957                  break;
958              rank++;
959              zzlNext(zl,&eptr,&sptr);
960          }
961          if (eptr != NULL) {
962              if (reverse)
963                  return llen-rank;
964              else
965                  return rank-1;
966          } else {
967              return -1;
968          }
969      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
970          zset *zs = zobj->ptr;
971          zskiplist *zsl = zs->zsl;
972          dictEntry *de;
973          double score;
974          de = dictFind(zs->dict,ele);
975          if (de != NULL) {
976              score = *(double*)dictGetVal(de);
977              rank = zslGetRank(zsl,score,ele);
978              serverAssert(rank != 0);
979              if (reverse)
980                  return llen-rank;
981              else
982                  return rank-1;
983          } else {
984              return -1;
985          }
986      } else {
987          serverPanic("Unknown sorted set encoding");
988      }
989  }
990  void zaddGenericCommand(client *c, int flags) {
991      static char *nanerr = "resulting score is not a number (NaN)";
992      robj *key = c->argv[1];
993      robj *zobj;
994      sds ele;
995      double score = 0, *scores = NULL;
996      int j, elements;
997      int scoreidx = 0;
998      int added = 0;      &bsol;* Number of new elements added. */
999      int updated = 0;    &bsol;* Number of elements with updated score. */
1000      int processed = 0;  &bsol;* Number of elements processed, may remain zero with
1001                             options like XX. */
1002      scoreidx = 2;
1003      while(scoreidx < c->argc) {
1004          char *opt = c->argv[scoreidx]->ptr;
1005          if (!strcasecmp(opt,"nx")) flags |= ZADD_NX;
1006          else if (!strcasecmp(opt,"xx")) flags |= ZADD_XX;
1007          else if (!strcasecmp(opt,"ch")) flags |= ZADD_CH;
1008          else if (!strcasecmp(opt,"incr")) flags |= ZADD_INCR;
1009          else break;
1010          scoreidx++;
1011      }
1012      int incr = (flags & ZADD_INCR) != 0;
1013      int nx = (flags & ZADD_NX) != 0;
1014      int xx = (flags & ZADD_XX) != 0;
1015      int ch = (flags & ZADD_CH) != 0;
1016      elements = c->argc-scoreidx;
1017      if (elements % 2 || !elements) {
1018          addReply(c,shared.syntaxerr);
1019          return;
1020      }
1021      elements /= 2; &bsol;* Now this holds the number of score-element pairs. */
1022      if (nx && xx) {
1023          addReplyError(c,
1024              "XX and NX options at the same time are not compatible");
1025          return;
1026      }
1027      if (incr && elements > 1) {
1028          addReplyError(c,
1029              "INCR option supports a single increment-element pair");
1030          return;
1031      }
1032      scores = zmalloc(sizeof(double)*elements);
1033      for (j = 0; j < elements; j++) {
1034          if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)
1035              != C_OK) goto cleanup;
1036      }
1037      zobj = lookupKeyWrite(c->db,key);
1038      if (zobj == NULL) {
1039          if (xx) goto reply_to_client; &bsol;* No key + XX option: nothing to do. */
1040          if (server.zset_max_ziplist_entries == 0 ||
1041              server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))
1042          {
1043              zobj = createZsetObject();
1044          } else {
1045              zobj = createZsetZiplistObject();
1046          }
1047          dbAdd(c->db,key,zobj);
1048      } else {
1049          if (zobj->type != OBJ_ZSET) {
1050              addReply(c,shared.wrongtypeerr);
1051              goto cleanup;
1052          }
1053      }
1054      for (j = 0; j < elements; j++) {
1055          double newscore;
1056          score = scores[j];
1057          int retflags = flags;
1058          ele = c->argv[scoreidx+1+j*2]->ptr;
1059          int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);
1060          if (retval == 0) {
1061              addReplyError(c,nanerr);
1062              goto cleanup;
1063          }
1064          if (retflags & ZADD_ADDED) added++;
1065          if (retflags & ZADD_UPDATED) updated++;
1066          if (!(retflags & ZADD_NOP)) processed++;
1067          score = newscore;
1068      }
1069      server.dirty += (added+updated);
1070  reply_to_client:
1071      if (incr) { &bsol;* ZINCRBY or INCR option. */
1072          if (processed)
1073              addReplyDouble(c,score);
1074          else
1075              addReply(c,shared.nullbulk);
1076      } else { &bsol;* ZADD. */
1077          addReplyLongLong(c,ch ? added+updated : added);
1078      }
1079  cleanup:
1080      zfree(scores);
1081      if (added || updated) {
1082          signalModifiedKey(c->db,key);
1083          notifyKeyspaceEvent(NOTIFY_ZSET,
1084              incr ? "zincr" : "zadd", key, c->db->id);
1085      }
1086  }
1087  void zaddCommand(client *c) {
1088      zaddGenericCommand(c,ZADD_NONE);
1089  }
1090  void zincrbyCommand(client *c) {
1091      zaddGenericCommand(c,ZADD_INCR);
1092  }
1093  void zremCommand(client *c) {
1094      robj *key = c->argv[1];
1095      robj *zobj;
1096      int deleted = 0, keyremoved = 0, j;
1097      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1098          checkType(c,zobj,OBJ_ZSET)) return;
1099      for (j = 2; j < c->argc; j++) {
1100          if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
1101          if (zsetLength(zobj) == 0) {
1102              dbDelete(c->db,key);
1103              keyremoved = 1;
1104              break;
1105          }
1106      }
1107      if (deleted) {
1108          notifyKeyspaceEvent(NOTIFY_ZSET,"zrem",key,c->db->id);
1109          if (keyremoved)
1110              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
1111          signalModifiedKey(c->db,key);
1112          server.dirty += deleted;
1113      }
1114      addReplyLongLong(c,deleted);
1115  }
1116  #define ZRANGE_RANK 0
1117  #define ZRANGE_SCORE 1
1118  #define ZRANGE_LEX 2
1119  void zremrangeGenericCommand(client *c, int rangetype) {
1120      robj *key = c->argv[1];
1121      robj *zobj;
1122      int keyremoved = 0;
1123      PORT_ULONG deleted = 0;
1124      zrangespec range;
1125      zlexrangespec lexrange;
1126      PORT_LONG start, end, llen;
1127      if (rangetype == ZRANGE_RANK) {
1128          if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
1129              (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
1130              return;
1131      } else if (rangetype == ZRANGE_SCORE) {
1132          if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
1133              addReplyError(c,"min or max is not a float");
1134              return;
1135          }
1136      } else if (rangetype == ZRANGE_LEX) {
1137          if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
1138              addReplyError(c,"min or max not valid string range item");
1139              return;
1140          }
1141      }
1142      if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
1143          checkType(c,zobj,OBJ_ZSET)) goto cleanup;
1144      if (rangetype == ZRANGE_RANK) {
1145          llen = zsetLength(zobj);
1146          if (start < 0) start = llen+start;
1147          if (end < 0) end = llen+end;
1148          if (start < 0) start = 0;
1149          if (start > end || start >= llen) {
1150              addReply(c,shared.czero);
1151              goto cleanup;
1152          }
1153          if (end >= llen) end = llen-1;
1154      }
1155      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1156          switch(rangetype) {
1157          case ZRANGE_RANK:
1158              zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,(int)start+1,(int)end+1,&deleted);   WIN_PORT_FIX &bsol;* cast (int), cast (int) */
1159              break;
1160          case ZRANGE_SCORE:
1161              zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);
1162              break;
1163          case ZRANGE_LEX:
1164              zobj->ptr = zzlDeleteRangeByLex(zobj->ptr,&lexrange,&deleted);
1165              break;
1166          }
1167          if (zzlLength(zobj->ptr) == 0) {
1168              dbDelete(c->db,key);
1169              keyremoved = 1;
1170          }
1171      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1172          zset *zs = zobj->ptr;
1173          switch(rangetype) {
1174          case ZRANGE_RANK:
1175              deleted = zslDeleteRangeByRank(zs->zsl,(int)start+1,(int)end+1,zs->dict);   WIN_PORT_FIX &bsol;* cast (int), cast (int) */
1176              break;
1177          case ZRANGE_SCORE:
1178              deleted = zslDeleteRangeByScore(zs->zsl,&range,zs->dict);
1179              break;
1180          case ZRANGE_LEX:
1181              deleted = zslDeleteRangeByLex(zs->zsl,&lexrange,zs->dict);
1182              break;
1183          }
1184          if (htNeedsResize(zs->dict)) dictResize(zs->dict);
1185          if (dictSize(zs->dict) == 0) {
1186              dbDelete(c->db,key);
1187              keyremoved = 1;
1188          }
1189      } else {
1190          serverPanic("Unknown sorted set encoding");
1191      }
1192      if (deleted) {
1193          char *event[3] = {"zremrangebyrank","zremrangebyscore","zremrangebylex"};
1194          signalModifiedKey(c->db,key);
1195          notifyKeyspaceEvent(NOTIFY_ZSET,event[rangetype],key,c->db->id);
1196          if (keyremoved)
1197              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
1198      }
1199      server.dirty += deleted;
1200      addReplyLongLong(c,deleted);
1201  cleanup:
1202      if (rangetype == ZRANGE_LEX) zslFreeLexRange(&lexrange);
1203  }
1204  void zremrangebyrankCommand(client *c) {
1205      zremrangeGenericCommand(c,ZRANGE_RANK);
1206  }
1207  void zremrangebyscoreCommand(client *c) {
1208      zremrangeGenericCommand(c,ZRANGE_SCORE);
1209  }
1210  void zremrangebylexCommand(client *c) {
1211      zremrangeGenericCommand(c,ZRANGE_LEX);
1212  }
1213  typedef struct {
1214      robj *subject;
1215      int type; &bsol;* Set, sorted set */
1216      int encoding;
1217      double weight;
1218      union {
1219          union _iterset {
1220              struct {
1221                  intset *is;
1222                  int ii;
1223              } is;
1224              struct {
1225                  dict *dict;
1226                  dictIterator *di;
1227                  dictEntry *de;
1228              } ht;
1229          } set;
1230          union _iterzset {
1231              struct {
1232                  unsigned char *zl;
1233                  unsigned char *eptr, *sptr;
1234              } zl;
1235              struct {
1236                  zset *zs;
1237                  zskiplistNode *node;
1238              } sl;
1239          } zset;
1240      } iter;
1241  } zsetopsrc;
1242  #define OPVAL_DIRTY_SDS 1
1243  #define OPVAL_DIRTY_LL 2
1244  #define OPVAL_VALID_LL 4
1245  typedef struct {
1246      int flags;
1247      unsigned char _buf[32]; &bsol;* Private buffer. */
1248      sds ele;
1249      unsigned char *estr;
1250      unsigned int elen;
1251      PORT_LONGLONG ell;
1252      double score;
1253  } zsetopval;
1254  typedef union _iterset iterset;
1255  typedef union _iterzset iterzset;
1256  void zuiInitIterator(zsetopsrc *op) {
1257      if (op->subject == NULL)
1258          return;
1259      if (op->type == OBJ_SET) {
1260          iterset *it = &op->iter.set;
1261          if (op->encoding == OBJ_ENCODING_INTSET) {
1262              it->is.is = op->subject->ptr;
1263              it->is.ii = 0;
1264          } else if (op->encoding == OBJ_ENCODING_HT) {
1265              it->ht.dict = op->subject->ptr;
1266              it->ht.di = dictGetIterator(op->subject->ptr);
1267              it->ht.de = dictNext(it->ht.di);
1268          } else {
1269              serverPanic("Unknown set encoding");
1270          }
1271      } else if (op->type == OBJ_ZSET) {
1272          iterzset *it = &op->iter.zset;
1273          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1274              it->zl.zl = op->subject->ptr;
1275              it->zl.eptr = ziplistIndex(it->zl.zl,0);
1276              if (it->zl.eptr != NULL) {
1277                  it->zl.sptr = ziplistNext(it->zl.zl,it->zl.eptr);
1278                  serverAssert(it->zl.sptr != NULL);
1279              }
1280          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1281              it->sl.zs = op->subject->ptr;
1282              it->sl.node = it->sl.zs->zsl->header->level[0].forward;
1283          } else {
1284              serverPanic("Unknown sorted set encoding");
1285          }
1286      } else {
1287          serverPanic("Unsupported type");
1288      }
1289  }
1290  void zuiClearIterator(zsetopsrc *op) {
1291      if (op->subject == NULL)
1292          return;
1293      if (op->type == OBJ_SET) {
1294          iterset *it = &op->iter.set;
1295          if (op->encoding == OBJ_ENCODING_INTSET) {
1296              UNUSED(it); &bsol;* skip */
1297          } else if (op->encoding == OBJ_ENCODING_HT) {
1298              dictReleaseIterator(it->ht.di);
1299          } else {
1300              serverPanic("Unknown set encoding");
1301          }
1302      } else if (op->type == OBJ_ZSET) {
1303          iterzset *it = &op->iter.zset;
1304          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1305              UNUSED(it); &bsol;* skip */
1306          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1307              UNUSED(it); &bsol;* skip */
1308          } else {
1309              serverPanic("Unknown sorted set encoding");
1310          }
1311      } else {
1312          serverPanic("Unsupported type");
1313      }
1314  }
1315  PORT_ULONG zuiLength(zsetopsrc *op) {
1316      if (op->subject == NULL)
1317          return 0;
1318      if (op->type == OBJ_SET) {
1319          if (op->encoding == OBJ_ENCODING_INTSET) {
1320              return intsetLen(op->subject->ptr);
1321          } else if (op->encoding == OBJ_ENCODING_HT) {
1322              dict *ht = op->subject->ptr;
1323              return dictSize(ht);
1324          } else {
1325              serverPanic("Unknown set encoding");
1326          }
1327      } else if (op->type == OBJ_ZSET) {
1328          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1329              return zzlLength(op->subject->ptr);
1330          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1331              zset *zs = op->subject->ptr;
1332              return zs->zsl->length;
1333          } else {
1334              serverPanic("Unknown sorted set encoding");
1335          }
1336      } else {
1337          serverPanic("Unsupported type");
1338      }
1339  }
1340  int zuiNext(zsetopsrc *op, zsetopval *val) {
1341      if (op->subject == NULL)
1342          return 0;
1343      if (val->flags & OPVAL_DIRTY_SDS)
1344          sdsfree(val->ele);
1345      memset(val,0,sizeof(zsetopval));
1346      if (op->type == OBJ_SET) {
1347          iterset *it = &op->iter.set;
1348          if (op->encoding == OBJ_ENCODING_INTSET) {
1349              int64_t ell;
1350              if (!intsetGet(it->is.is,it->is.ii,&ell))
1351                  return 0;
1352              val->ell = ell;
1353              val->score = 1.0;
1354              it->is.ii++;
1355          } else if (op->encoding == OBJ_ENCODING_HT) {
1356              if (it->ht.de == NULL)
1357                  return 0;
1358              val->ele = dictGetKey(it->ht.de);
1359              val->score = 1.0;
1360              it->ht.de = dictNext(it->ht.di);
1361          } else {
1362              serverPanic("Unknown set encoding");
1363          }
1364      } else if (op->type == OBJ_ZSET) {
1365          iterzset *it = &op->iter.zset;
1366          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1367              if (it->zl.eptr == NULL || it->zl.sptr == NULL)
1368                  return 0;
1369              serverAssert(ziplistGet(it->zl.eptr,&val->estr,&val->elen,&val->ell));
1370              val->score = zzlGetScore(it->zl.sptr);
1371              zzlNext(it->zl.zl,&it->zl.eptr,&it->zl.sptr);
1372          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1373              if (it->sl.node == NULL)
1374                  return 0;
1375              val->ele = it->sl.node->ele;
1376              val->score = it->sl.node->score;
1377              it->sl.node = it->sl.node->level[0].forward;
1378          } else {
1379              serverPanic("Unknown sorted set encoding");
1380          }
1381      } else {
1382          serverPanic("Unsupported type");
1383      }
1384      return 1;
1385  }
1386  int zuiLongLongFromValue(zsetopval *val) {
1387      if (!(val->flags & OPVAL_DIRTY_LL)) {
1388          val->flags |= OPVAL_DIRTY_LL;
1389          if (val->ele != NULL) {
1390              if (string2ll(val->ele,sdslen(val->ele),&val->ell))
1391                  val->flags |= OPVAL_VALID_LL;
1392          } else if (val->estr != NULL) {
1393              if (string2ll((char*)val->estr,val->elen,&val->ell))
1394                  val->flags |= OPVAL_VALID_LL;
1395          } else {
1396              val->flags |= OPVAL_VALID_LL;
1397          }
1398      }
1399      return val->flags & OPVAL_VALID_LL;
1400  }
1401  sds zuiSdsFromValue(zsetopval *val) {
1402      if (val->ele == NULL) {
1403          if (val->estr != NULL) {
1404              val->ele = sdsnewlen((char*)val->estr,val->elen);
1405          } else {
1406              val->ele = sdsfromlonglong(val->ell);
1407          }
1408          val->flags |= OPVAL_DIRTY_SDS;
1409      }
1410      return val->ele;
1411  }
1412  sds zuiNewSdsFromValue(zsetopval *val) {
1413      if (val->flags & OPVAL_DIRTY_SDS) {
1414          sds ele = val->ele;
1415          val->flags &= ~OPVAL_DIRTY_SDS;
1416          val->ele = NULL;
1417          return ele;
1418      } else if (val->ele) {
1419          return sdsdup(val->ele);
1420      } else if (val->estr) {
1421          return sdsnewlen((char*)val->estr,val->elen);
1422      } else {
1423          return sdsfromlonglong(val->ell);
1424      }
1425  }
1426  int zuiBufferFromValue(zsetopval *val) {
1427      if (val->estr == NULL) {
1428          if (val->ele != NULL) {
1429              val->elen = sdslen(val->ele);
1430              val->estr = (unsigned char*)val->ele;
1431          } else {
1432              val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
1433              val->estr = val->_buf;
1434          }
1435      }
1436      return 1;
1437  }
1438  int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
1439      if (op->subject == NULL)
1440          return 0;
1441      if (op->type == OBJ_SET) {
1442          if (op->encoding == OBJ_ENCODING_INTSET) {
1443              if (zuiLongLongFromValue(val) &&
1444                  intsetFind(op->subject->ptr,val->ell))
1445              {
1446                  *score = 1.0;
1447                  return 1;
1448              } else {
1449                  return 0;
1450              }
1451          } else if (op->encoding == OBJ_ENCODING_HT) {
1452              dict *ht = op->subject->ptr;
1453              zuiSdsFromValue(val);
1454              if (dictFind(ht,val->ele) != NULL) {
1455                  *score = 1.0;
1456                  return 1;
1457              } else {
1458                  return 0;
1459              }
1460          } else {
1461              serverPanic("Unknown set encoding");
1462          }
1463      } else if (op->type == OBJ_ZSET) {
1464          zuiSdsFromValue(val);
1465          if (op->encoding == OBJ_ENCODING_ZIPLIST) {
1466              if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
1467                  return 1;
1468              } else {
1469                  return 0;
1470              }
1471          } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
1472              zset *zs = op->subject->ptr;
1473              dictEntry *de;
1474              if ((de = dictFind(zs->dict,val->ele)) != NULL) {
1475                  *score = *(double*)dictGetVal(de);
1476                  return 1;
1477              } else {
1478                  return 0;
1479              }
1480          } else {
1481              serverPanic("Unknown sorted set encoding");
1482          }
1483      } else {
1484          serverPanic("Unsupported type");
1485      }
1486  }
1487  int zuiCompareByCardinality(const void *s1, const void *s2) {
1488      PORT_ULONG first = zuiLength((zsetopsrc*)s1);
1489      PORT_ULONG second = zuiLength((zsetopsrc*)s2);
1490      if (first > second) return 1;
1491      if (first < second) return -1;
1492      return 0;
1493  }
1494  #define REDIS_AGGR_SUM 1
1495  #define REDIS_AGGR_MIN 2
1496  #define REDIS_AGGR_MAX 3
1497  #define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
1498  inline static void zunionInterAggregate(double *target, double val, int aggregate) {
1499      if (aggregate == REDIS_AGGR_SUM) {
1500          *target = *target + val;
1501          if (isnan(*target)) *target = 0.0;
1502      } else if (aggregate == REDIS_AGGR_MIN) {
1503          *target = val < *target ? val : *target;
1504      } else if (aggregate == REDIS_AGGR_MAX) {
1505          *target = val > *target ? val : *target;
1506      } else {
1507          serverPanic("Unknown ZUNION/INTER aggregate type");
1508      }
1509  }
1510  uint64_t dictSdsHash(const void *key);
1511  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
1512  dictType setAccumulatorDictType = {
1513      dictSdsHash,               &bsol;* hash function */
1514      NULL,                      &bsol;* key dup */
1515      NULL,                      &bsol;* val dup */
1516      dictSdsKeyCompare,         &bsol;* key compare */
1517      NULL,                      &bsol;* key destructor */
1518      NULL                       &bsol;* val destructor */
1519  };
1520  void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
1521      int i, j;
1522      PORT_LONG setnum;
1523      int aggregate = REDIS_AGGR_SUM;
1524      zsetopsrc *src;
1525      zsetopval zval;
1526      sds tmp;
1527      size_t maxelelen = 0;
1528      robj *dstobj;
1529      zset *dstzset;
1530      zskiplistNode *znode;
1531      int touched = 0;
1532      if ((getLongFromObjectOrReply(c, c->argv[2], &setnum, NULL) != C_OK))
1533          return;
1534      if (setnum < 1) {
1535          addReplyError(c,
1536              "at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE");
1537          return;
1538      }
1539      if (setnum > c->argc-3) {
1540          addReply(c,shared.syntaxerr);
1541          return;
1542      }
1543      src = zcalloc(sizeof(zsetopsrc) * setnum);
1544      for (i = 0, j = 3; i < setnum; i++, j++) {
1545          robj *obj = lookupKeyWrite(c->db,c->argv[j]);
1546          if (obj != NULL) {
1547              if (obj->type != OBJ_ZSET && obj->type != OBJ_SET) {
1548                  zfree(src);
1549                  addReply(c,shared.wrongtypeerr);
1550                  return;
1551              }
1552              src[i].subject = obj;
1553              src[i].type = obj->type;
1554              src[i].encoding = obj->encoding;
1555          } else {
1556              src[i].subject = NULL;
1557          }
1558          src[i].weight = 1.0;
1559      }
1560      if (j < c->argc) {
1561          int remaining = c->argc - j;
1562          while (remaining) {
1563              if (remaining >= (setnum + 1) &&
1564                  !strcasecmp(c->argv[j]->ptr,"weights"))
1565              {
1566                  j++; remaining--;
1567                  for (i = 0; i < setnum; i++, j++, remaining--) {
1568                      if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
1569                              "weight value is not a float") != C_OK)
1570                      {
1571                          zfree(src);
1572                          return;
1573                      }
1574                  }
1575              } else if (remaining >= 2 &&
1576                         !strcasecmp(c->argv[j]->ptr,"aggregate"))
1577              {
1578                  j++; remaining--;
1579                  if (!strcasecmp(c->argv[j]->ptr,"sum")) {
1580                      aggregate = REDIS_AGGR_SUM;
1581                  } else if (!strcasecmp(c->argv[j]->ptr,"min")) {
1582                      aggregate = REDIS_AGGR_MIN;
1583                  } else if (!strcasecmp(c->argv[j]->ptr,"max")) {
1584                      aggregate = REDIS_AGGR_MAX;
1585                  } else {
1586                      zfree(src);
1587                      addReply(c,shared.syntaxerr);
1588                      return;
1589                  }
1590                  j++; remaining--;
1591              } else {
1592                  zfree(src);
1593                  addReply(c,shared.syntaxerr);
1594                  return;
1595              }
1596          }
1597      }
1598      qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
1599      dstobj = createZsetObject();
1600      dstzset = dstobj->ptr;
1601      memset(&zval, 0, sizeof(zval));
1602      if (op == SET_OP_INTER) {
1603          if (zuiLength(&src[0]) > 0) {
1604              zuiInitIterator(&src[0]);
1605              while (zuiNext(&src[0],&zval)) {
1606                  double score, value;
1607                  score = src[0].weight * zval.score;
1608                  if (isnan(score)) score = 0;
1609                  for (j = 1; j < setnum; j++) {
1610                      if (src[j].subject == src[0].subject) {
1611                          value = zval.score*src[j].weight;
1612                          zunionInterAggregate(&score,value,aggregate);
1613                      } else if (zuiFind(&src[j],&zval,&value)) {
1614                          value *= src[j].weight;
1615                          zunionInterAggregate(&score,value,aggregate);
1616                      } else {
1617                          break;
1618                      }
1619                  }
1620                  if (j == setnum) {
1621                      tmp = zuiNewSdsFromValue(&zval);
1622                      znode = zslInsert(dstzset->zsl,score,tmp);
1623                      dictAdd(dstzset->dict,tmp,&znode->score);
1624                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
1625                  }
1626              }
1627              zuiClearIterator(&src[0]);
1628          }
1629      } else if (op == SET_OP_UNION) {
1630          dict *accumulator = dictCreate(&setAccumulatorDictType,NULL);
1631          dictIterator *di;
1632          dictEntry *de, *existing;
1633          double score;
1634          if (setnum) {
1635              dictExpand(accumulator,zuiLength(&src[setnum-1]));
1636          }
1637          for (i = 0; i < setnum; i++) {
1638              if (zuiLength(&src[i]) == 0) continue;
1639              zuiInitIterator(&src[i]);
1640              while (zuiNext(&src[i],&zval)) {
1641                  score = src[i].weight * zval.score;
1642                  if (isnan(score)) score = 0;
1643                  de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);
1644                  if (!existing) {
1645                      tmp = zuiNewSdsFromValue(&zval);
1646                       if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
1647                      dictSetKey(accumulator, de, tmp);
1648                      dictSetDoubleVal(de,score);
1649                  } else {
1650                      zunionInterAggregate(&existing->v.d,score,aggregate);
1651                  }
1652              }
1653              zuiClearIterator(&src[i]);
1654          }
1655          di = dictGetIterator(accumulator);
1656          dictExpand(dstzset->dict,dictSize(accumulator));
1657          while((de = dictNext(di)) != NULL) {
1658              sds ele = dictGetKey(de);
1659              score = dictGetDoubleVal(de);
1660              znode = zslInsert(dstzset->zsl,score,ele);
1661              dictAdd(dstzset->dict,ele,&znode->score);
1662          }
1663          dictReleaseIterator(di);
1664          dictRelease(accumulator);
1665      } else {
1666          serverPanic("Unknown operator");
1667      }
1668      if (dbDelete(c->db,dstkey))
1669          touched = 1;
1670      if (dstzset->zsl->length) {
1671          zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
1672          dbAdd(c->db,dstkey,dstobj);
1673          addReplyLongLong(c,zsetLength(dstobj));
1674          signalModifiedKey(c->db,dstkey);
1675          notifyKeyspaceEvent(NOTIFY_ZSET,
1676              (op == SET_OP_UNION) ? "zunionstore" : "zinterstore",
1677              dstkey,c->db->id);
1678          server.dirty++;
1679      } else {
1680          decrRefCount(dstobj);
1681          addReply(c,shared.czero);
1682          if (touched) {
1683              signalModifiedKey(c->db,dstkey);
1684              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",dstkey,c->db->id);
1685              server.dirty++;
1686          }
1687      }
1688      zfree(src);
1689  }
1690  void zunionstoreCommand(client *c) {
1691      zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
1692  }
1693  void zinterstoreCommand(client *c) {
1694      zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
1695  }
1696  void zrangeGenericCommand(client *c, int reverse) {
1697      robj *key = c->argv[1];
1698      robj *zobj;
1699      int withscores = 0;
1700      PORT_LONG start;
1701      PORT_LONG end;
1702      PORT_LONG llen;
1703      PORT_LONG rangelen;
1704      if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
1705          (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
1706      if (c->argc == 5 && !strcasecmp(c->argv[4]->ptr,"withscores")) {
1707          withscores = 1;
1708      } else if (c->argc >= 5) {
1709          addReply(c,shared.syntaxerr);
1710          return;
1711      }
1712      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
1713           || checkType(c,zobj,OBJ_ZSET)) return;
1714      llen = zsetLength(zobj);
1715      if (start < 0) start = llen+start;
1716      if (end < 0) end = llen+end;
1717      if (start < 0) start = 0;
1718      if (start > end || start >= llen) {
1719          addReply(c,shared.emptymultibulk);
1720          return;
1721      }
1722      if (end >= llen) end = llen-1;
1723      rangelen = (int)(end-start)+1;                                              WIN_PORT_FIX &bsol;* cast (int) */
1724      addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
1725      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1726          unsigned char *zl = zobj->ptr;
1727          unsigned char *eptr, *sptr;
1728          unsigned char *vstr;
1729          unsigned int vlen;
1730          PORT_LONGLONG vlong;
1731          if (reverse)
1732              eptr = ziplistIndex(zl,(int)(-2-(2*start)));                        WIN_PORT_FIX &bsol;* cast (int) */
1733          else
1734              eptr = ziplistIndex(zl,(int)(2*start));                             WIN_PORT_FIX &bsol;* cast (int) */
1735          serverAssertWithInfo(c,zobj,eptr != NULL);
1736          sptr = ziplistNext(zl,eptr);
1737          while (rangelen--) {
1738              serverAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);
1739              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
1740              if (vstr == NULL)
1741                  addReplyBulkLongLong(c,vlong);
1742              else
1743                  addReplyBulkCBuffer(c,vstr,vlen);
1744              if (withscores)
1745                  addReplyDouble(c,zzlGetScore(sptr));
1746              if (reverse)
1747                  zzlPrev(zl,&eptr,&sptr);
1748              else
1749                  zzlNext(zl,&eptr,&sptr);
1750          }
1751      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1752          zset *zs = zobj->ptr;
1753          zskiplist *zsl = zs->zsl;
1754          zskiplistNode *ln;
1755          sds ele;
1756          if (reverse) {
1757              ln = zsl->tail;
1758              if (start > 0)
1759                  ln = zslGetElementByRank(zsl,llen-start);
1760          } else {
1761              ln = zsl->header->level[0].forward;
1762              if (start > 0)
1763                  ln = zslGetElementByRank(zsl,start+1);
1764          }
1765          while(rangelen--) {
1766              serverAssertWithInfo(c,zobj,ln != NULL);
1767              ele = ln->ele;
1768              addReplyBulkCBuffer(c,ele,sdslen(ele));
1769              if (withscores)
1770                  addReplyDouble(c,ln->score);
1771              ln = reverse ? ln->backward : ln->level[0].forward;
1772          }
1773      } else {
1774          serverPanic("Unknown sorted set encoding");
1775      }
1776  }
1777  void zrangeCommand(client *c) {
1778      zrangeGenericCommand(c,0);
1779  }
1780  void zrevrangeCommand(client *c) {
1781      zrangeGenericCommand(c,1);
1782  }
1783  void genericZrangebyscoreCommand(client *c, int reverse) {
1784      zrangespec range;
1785      robj *key = c->argv[1];
1786      robj *zobj;
1787      PORT_LONG offset = 0, limit = -1;
1788      int withscores = 0;
1789      PORT_ULONG rangelen = 0;
1790      void *replylen = NULL;
1791      int minidx, maxidx;
1792      if (reverse) {
1793          maxidx = 2; minidx = 3;
1794      } else {
1795          minidx = 2; maxidx = 3;
1796      }
1797      if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
1798          addReplyError(c,"min or max is not a float");
1799          return;
1800      }
1801      if (c->argc > 4) {
1802          int remaining = c->argc - 4;
1803          int pos = 4;
1804          while (remaining) {
1805              if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,"withscores")) {
1806                  pos++; remaining--;
1807                  withscores = 1;
1808              } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
1809                  if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)
1810                          != C_OK) ||
1811                      (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)
1812                          != C_OK))
1813                  {
1814                      return;
1815                  }
1816                  pos += 3; remaining -= 3;
1817              } else {
1818                  addReply(c,shared.syntaxerr);
1819                  return;
1820              }
1821          }
1822      }
1823      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
1824          checkType(c,zobj,OBJ_ZSET)) return;
1825      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1826          unsigned char *zl = zobj->ptr;
1827          unsigned char *eptr, *sptr;
1828          unsigned char *vstr;
1829          unsigned int vlen;
1830          PORT_LONGLONG vlong;
1831          double score;
1832          if (reverse) {
1833              eptr = zzlLastInRange(zl,&range);
1834          } else {
1835              eptr = zzlFirstInRange(zl,&range);
1836          }
1837          if (eptr == NULL) {
1838              addReply(c, shared.emptymultibulk);
1839              return;
1840          }
1841          serverAssertWithInfo(c,zobj,eptr != NULL);
1842          sptr = ziplistNext(zl,eptr);
1843          replylen = addDeferredMultiBulkLength(c);
1844          while (eptr && offset--) {
1845              if (reverse) {
1846                  zzlPrev(zl,&eptr,&sptr);
1847              } else {
1848                  zzlNext(zl,&eptr,&sptr);
1849              }
1850          }
1851          while (eptr && limit--) {
1852              score = zzlGetScore(sptr);
1853              if (reverse) {
1854                  if (!zslValueGteMin(score,&range)) break;
1855              } else {
1856                  if (!zslValueLteMax(score,&range)) break;
1857              }
1858              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
1859              rangelen++;
1860              if (vstr == NULL) {
1861                  addReplyBulkLongLong(c,vlong);
1862              } else {
1863                  addReplyBulkCBuffer(c,vstr,vlen);
1864              }
1865              if (withscores) {
1866                  addReplyDouble(c,score);
1867              }
1868              if (reverse) {
1869                  zzlPrev(zl,&eptr,&sptr);
1870              } else {
1871                  zzlNext(zl,&eptr,&sptr);
1872              }
1873          }
1874      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1875          zset *zs = zobj->ptr;
1876          zskiplist *zsl = zs->zsl;
1877          zskiplistNode *ln;
1878          if (reverse) {
1879              ln = zslLastInRange(zsl,&range);
1880          } else {
1881              ln = zslFirstInRange(zsl,&range);
1882          }
1883          if (ln == NULL) {
1884              addReply(c, shared.emptymultibulk);
1885              return;
1886          }
1887          replylen = addDeferredMultiBulkLength(c);
1888          while (ln && offset--) {
1889              if (reverse) {
1890                  ln = ln->backward;
1891              } else {
1892                  ln = ln->level[0].forward;
1893              }
1894          }
1895          while (ln && limit--) {
1896              if (reverse) {
1897                  if (!zslValueGteMin(ln->score,&range)) break;
1898              } else {
1899                  if (!zslValueLteMax(ln->score,&range)) break;
1900              }
1901              rangelen++;
1902              addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
1903              if (withscores) {
1904                  addReplyDouble(c,ln->score);
1905              }
1906              if (reverse) {
1907                  ln = ln->backward;
1908              } else {
1909                  ln = ln->level[0].forward;
1910              }
1911          }
1912      } else {
1913          serverPanic("Unknown sorted set encoding");
1914      }
1915      if (withscores) {
1916          rangelen *= 2;
1917      }
1918      setDeferredMultiBulkLength(c, replylen, rangelen);
1919  }
1920  void zrangebyscoreCommand(client *c) {
1921      genericZrangebyscoreCommand(c,0);
1922  }
1923  void zrevrangebyscoreCommand(client *c) {
1924      genericZrangebyscoreCommand(c,1);
1925  }
1926  void zcountCommand(client *c) {
1927      robj *key = c->argv[1];
1928      robj *zobj;
1929      zrangespec range;
1930      PORT_ULONG count = 0;
1931      if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
1932          addReplyError(c,"min or max is not a float");
1933          return;
1934      }
1935      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1936          checkType(c, zobj, OBJ_ZSET)) return;
1937      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1938          unsigned char *zl = zobj->ptr;
1939          unsigned char *eptr, *sptr;
1940          double score;
1941          eptr = zzlFirstInRange(zl,&range);
1942          if (eptr == NULL) {
1943              addReply(c, shared.czero);
1944              return;
1945          }
1946          sptr = ziplistNext(zl,eptr);
1947          score = zzlGetScore(sptr);
1948          serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));
1949          while (eptr) {
1950              score = zzlGetScore(sptr);
1951              if (!zslValueLteMax(score,&range)) {
1952                  break;
1953              } else {
1954                  count++;
1955                  zzlNext(zl,&eptr,&sptr);
1956              }
1957          }
1958      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
1959          zset *zs = zobj->ptr;
1960          zskiplist *zsl = zs->zsl;
1961          zskiplistNode *zn;
1962          PORT_ULONG rank;
1963          zn = zslFirstInRange(zsl, &range);
1964          if (zn != NULL) {
1965              rank = zslGetRank(zsl, zn->score, zn->ele);
1966              count = (int)(zsl->length - (rank - 1));                            WIN_PORT_FIX &bsol;* cast (int) */
1967              zn = zslLastInRange(zsl, &range);
1968              if (zn != NULL) {
1969                  rank = zslGetRank(zsl, zn->score, zn->ele);
1970                  count -= (int)(zsl->length - rank);                             WIN_PORT_FIX &bsol;* cast (int) */
1971              }
1972          }
1973      } else {
1974          serverPanic("Unknown sorted set encoding");
1975      }
1976      addReplyLongLong(c, count);
1977  }
1978  void zlexcountCommand(client *c) {
1979      robj *key = c->argv[1];
1980      robj *zobj;
1981      zlexrangespec range;
1982      PORT_ULONG count = 0;
1983      if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {
1984          addReplyError(c,"min or max not valid string range item");
1985          return;
1986      }
1987      if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
1988          checkType(c, zobj, OBJ_ZSET))
1989      {
1990          zslFreeLexRange(&range);
1991          return;
1992      }
1993      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
1994          unsigned char *zl = zobj->ptr;
1995          unsigned char *eptr, *sptr;
1996          eptr = zzlFirstInLexRange(zl,&range);
1997          if (eptr == NULL) {
1998              zslFreeLexRange(&range);
1999              addReply(c, shared.czero);
2000              return;
2001          }
2002          sptr = ziplistNext(zl,eptr);
2003          serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));
2004          while (eptr) {
2005              if (!zzlLexValueLteMax(eptr,&range)) {
2006                  break;
2007              } else {
2008                  count++;
2009                  zzlNext(zl,&eptr,&sptr);
2010              }
2011          }
2012      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2013          zset *zs = zobj->ptr;
2014          zskiplist *zsl = zs->zsl;
2015          zskiplistNode *zn;
2016          PORT_ULONG rank;
2017          zn = zslFirstInLexRange(zsl, &range);
2018          if (zn != NULL) {
2019              rank = zslGetRank(zsl, zn->score, zn->ele);
2020              count = (int)(zsl->length - (rank - 1));                            WIN_PORT_FIX &bsol;* cast (int) */
2021              zn = zslLastInLexRange(zsl, &range);
2022              if (zn != NULL) {
2023                  rank = zslGetRank(zsl, zn->score, zn->ele);
2024                  count -= (int)(zsl->length - rank);                             WIN_PORT_FIX &bsol;* cast (int) */
2025              }
2026          }
2027      } else {
2028          serverPanic("Unknown sorted set encoding");
2029      }
2030      zslFreeLexRange(&range);
2031      addReplyLongLong(c, count);
2032  }
2033  void genericZrangebylexCommand(client *c, int reverse) {
2034      zlexrangespec range;
2035      robj *key = c->argv[1];
2036      robj *zobj;
2037      PORT_LONG offset = 0, limit = -1;
2038      PORT_ULONG rangelen = 0;
2039      void *replylen = NULL;
2040      int minidx, maxidx;
2041      if (reverse) {
2042          maxidx = 2; minidx = 3;
2043      } else {
2044          minidx = 2; maxidx = 3;
2045      }
2046      if (zslParseLexRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
2047          addReplyError(c,"min or max not valid string range item");
2048          return;
2049      }
2050      if (c->argc > 4) {
2051          int remaining = c->argc - 4;
2052          int pos = 4;
2053          while (remaining) {
2054              if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
2055                  if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
2056                      (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != C_OK)) {
2057                      zslFreeLexRange(&range);
2058                      return;
2059                  }
2060                  pos += 3; remaining -= 3;
2061              } else {
2062                  zslFreeLexRange(&range);
2063                  addReply(c,shared.syntaxerr);
2064                  return;
2065              }
2066          }
2067      }
2068      if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
2069          checkType(c,zobj,OBJ_ZSET))
2070      {
2071          zslFreeLexRange(&range);
2072          return;
2073      }
2074      if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
2075          unsigned char *zl = zobj->ptr;
2076          unsigned char *eptr, *sptr;
2077          unsigned char *vstr;
2078          unsigned int vlen;
2079          PORT_LONGLONG vlong;
2080          if (reverse) {
2081              eptr = zzlLastInLexRange(zl,&range);
2082          } else {
2083              eptr = zzlFirstInLexRange(zl,&range);
2084          }
2085          if (eptr == NULL) {
2086              addReply(c, shared.emptymultibulk);
2087              zslFreeLexRange(&range);
2088              return;
2089          }
2090          serverAssertWithInfo(c,zobj,eptr != NULL);
2091          sptr = ziplistNext(zl,eptr);
2092          replylen = addDeferredMultiBulkLength(c);
2093          while (eptr && offset--) {
2094              if (reverse) {
2095                  zzlPrev(zl,&eptr,&sptr);
2096              } else {
2097                  zzlNext(zl,&eptr,&sptr);
2098              }
2099          }
2100          while (eptr && limit--) {
2101              if (reverse) {
2102                  if (!zzlLexValueGteMin(eptr,&range)) break;
2103              } else {
2104                  if (!zzlLexValueLteMax(eptr,&range)) break;
2105              }
2106              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
2107              rangelen++;
2108              if (vstr == NULL) {
2109                  addReplyBulkLongLong(c,vlong);
2110              } else {
2111                  addReplyBulkCBuffer(c,vstr,vlen);
2112              }
2113              if (reverse) {
2114                  zzlPrev(zl,&eptr,&sptr);
2115              } else {
2116                  zzlNext(zl,&eptr,&sptr);
2117              }
2118          }
2119      } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2120          zset *zs = zobj->ptr;
2121          zskiplist *zsl = zs->zsl;
2122          zskiplistNode *ln;
2123          if (reverse) {
2124              ln = zslLastInLexRange(zsl,&range);
2125          } else {
2126              ln = zslFirstInLexRange(zsl,&range);
2127          }
2128          if (ln == NULL) {
2129              addReply(c, shared.emptymultibulk);
2130              zslFreeLexRange(&range);
2131              return;
2132          }
2133          replylen = addDeferredMultiBulkLength(c);
2134          while (ln && offset--) {
2135              if (reverse) {
2136                  ln = ln->backward;
2137              } else {
2138                  ln = ln->level[0].forward;
2139              }
2140          }
2141          while (ln && limit--) {
2142              if (reverse) {
2143                  if (!zslLexValueGteMin(ln->ele,&range)) break;
2144              } else {
2145                  if (!zslLexValueLteMax(ln->ele,&range)) break;
2146              }
2147              rangelen++;
2148              addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
2149              if (reverse) {
2150                  ln = ln->backward;
2151              } else {
2152                  ln = ln->level[0].forward;
2153              }
2154          }
2155      } else {
2156          serverPanic("Unknown sorted set encoding");
2157      }
2158      zslFreeLexRange(&range);
2159      setDeferredMultiBulkLength(c, replylen, rangelen);
2160  }
2161  void zrangebylexCommand(client *c) {
2162      genericZrangebylexCommand(c,0);
2163  }
2164  void zrevrangebylexCommand(client *c) {
2165      genericZrangebylexCommand(c,1);
2166  }
2167  void zcardCommand(client *c) {
2168      robj *key = c->argv[1];
2169      robj *zobj;
2170      if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
2171          checkType(c,zobj,OBJ_ZSET)) return;
2172      addReplyLongLong(c,zsetLength(zobj));
2173  }
2174  void zscoreCommand(client *c) {
2175      robj *key = c->argv[1];
2176      robj *zobj;
2177      double score;
2178      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2179          checkType(c,zobj,OBJ_ZSET)) return;
2180      if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
2181          addReply(c,shared.nullbulk);
2182      } else {
2183          addReplyDouble(c,score);
2184      }
2185  }
2186  void zrankGenericCommand(client *c, int reverse) {
2187      robj *key = c->argv[1];
2188      robj *ele = c->argv[2];
2189      robj *zobj;
2190      PORT_LONG rank;
2191      if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
2192          checkType(c,zobj,OBJ_ZSET)) return;
2193      serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
2194      rank = zsetRank(zobj,ele->ptr,reverse);
2195      if (rank >= 0) {
2196          addReplyLongLong(c,rank);
2197      } else {
2198          addReply(c,shared.nullbulk);
2199      }
2200  }
2201  void zrankCommand(client *c) {
2202      zrankGenericCommand(c, 0);
2203  }
2204  void zrevrankCommand(client *c) {
2205      zrankGenericCommand(c, 1);
2206  }
2207  void zscanCommand(client *c) {
2208      robj *o;
2209      PORT_ULONG cursor;
2210      if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
2211      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
2212          checkType(c,o,OBJ_ZSET)) return;
2213      scanGenericCommand(c,o,cursor);
2214  }
2215  void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {
2216      int idx;
2217      robj *key = NULL;
2218      robj *zobj = NULL;
2219      sds ele;
2220      double score;
2221      PORT_LONG count = 1;
2222      if (countarg) {
2223          if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK)
2224              return;
2225          if (count <= 0) {
2226              addReply(c,shared.emptymultibulk);
2227              return;
2228          }
2229      }
2230      idx = 0;
2231      while (idx < keyc) {
2232          key = keyv[idx++];
2233          zobj = lookupKeyWrite(c->db,key);
2234          if (!zobj) continue;
2235          if (checkType(c,zobj,OBJ_ZSET)) return;
2236          break;
2237      }
2238      if (!zobj) {
2239          addReply(c,shared.emptymultibulk);
2240          return;
2241      }
2242      void *arraylen_ptr = addDeferredMultiBulkLength(c);
2243      PORT_LONG arraylen = 0;
2244      if (emitkey) addReplyBulk(c,key);
2245      do {
2246          if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
2247              unsigned char *zl = zobj->ptr;
2248              unsigned char *eptr, *sptr;
2249              unsigned char *vstr;
2250              unsigned int vlen;
2251              PORT_LONGLONG vlong;
2252              eptr = ziplistIndex(zl,where == ZSET_MAX ? -2 : 0);
2253              serverAssertWithInfo(c,zobj,eptr != NULL);
2254              serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
2255              if (vstr == NULL)
2256                  ele = sdsfromlonglong(vlong);
2257              else
2258                  ele = sdsnewlen(vstr,vlen);
2259              sptr = ziplistNext(zl,eptr);
2260              serverAssertWithInfo(c,zobj,sptr != NULL);
2261              score = zzlGetScore(sptr);
2262          } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
2263              zset *zs = zobj->ptr;
2264              zskiplist *zsl = zs->zsl;
2265              zskiplistNode *zln;
2266              zln = (where == ZSET_MAX ? zsl->tail :
2267                                         zsl->header->level[0].forward);
2268              serverAssertWithInfo(c,zobj,zln != NULL);
2269              ele = sdsdup(zln->ele);
2270              score = zln->score;
2271          } else {
2272              serverPanic("Unknown sorted set encoding");
2273          }
2274          serverAssertWithInfo(c,zobj,zsetDel(zobj,ele));
2275          server.dirty++;
2276          if (arraylen == 0) { &bsol;* Do this only for the first iteration. */
2277              char *events[2] = {"zpopmin","zpopmax"};
2278              notifyKeyspaceEvent(NOTIFY_ZSET,events[where],key,c->db->id);
2279              signalModifiedKey(c->db,key);
2280          }
2281          addReplyBulkCBuffer(c,ele,sdslen(ele));
2282          addReplyDouble(c,score);
2283          sdsfree(ele);
2284          arraylen += 2;
2285          if (zsetLength(zobj) == 0) {
2286              dbDelete(c->db,key);
2287              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
2288              break;
2289          }
2290      } while(--count);
2291      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
2292  }
2293  void zpopminCommand(client *c) {
2294      if (c->argc > 3) {
2295          addReply(c,shared.syntaxerr);
2296          return;
2297      }
2298      genericZpopCommand(c,&c->argv[1],1,ZSET_MIN,0,
2299          c->argc == 3 ? c->argv[2] : NULL);
2300  }
2301  void zpopmaxCommand(client *c) {
2302      if (c->argc > 3) {
2303          addReply(c,shared.syntaxerr);
2304          return;
2305      }
2306      genericZpopCommand(c,&c->argv[1],1,ZSET_MAX,0,
2307          c->argc == 3 ? c->argv[2] : NULL);
2308  }
2309  void blockingGenericZpopCommand(client *c, int where) {
2310      robj *o;
2311      mstime_t timeout;
2312      int j;
2313      if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
2314          != C_OK) return;
2315      for (j = 1; j < c->argc-1; j++) {
2316          o = lookupKeyWrite(c->db,c->argv[j]);
2317          if (o != NULL) {
2318              if (o->type != OBJ_ZSET) {
2319                  addReply(c,shared.wrongtypeerr);
2320                  return;
2321              } else {
2322                  if (zsetLength(o) != 0) {
2323                      genericZpopCommand(c,&c->argv[j],1,where,1,NULL);
2324                      rewriteClientCommandVector(c,2,
2325                          where == ZSET_MAX ? shared.zpopmax : shared.zpopmin,
2326                          c->argv[j]);
2327                      return;
2328                  }
2329              }
2330          }
2331      }
2332      if (c->flags & CLIENT_MULTI) {
2333          addReply(c,shared.nullmultibulk);
2334          return;
2335      }
2336      blockForKeys(c,BLOCKED_ZSET,c->argv + 1,c->argc - 2,timeout,NULL,NULL);
2337  }
2338  void bzpopminCommand(client *c) {
2339      blockingGenericZpopCommand(c,ZSET_MIN);
2340  }
2341  void bzpopmaxCommand(client *c) {
2342      blockingGenericZpopCommand(c,ZSET_MAX);
2343  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_zset.c</div>
                </div>
                <div class="column column_space"><pre><code>534  ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
535      ssize_t n = 0, nwritten = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>215  PORT_ULONG zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
216      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    