<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mask_ideal_band.c & bandbool.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mask_ideal_band.c & bandbool.c
      </h3>
      <h1 align="center">
        17.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mask_ideal_band.c (24.615385%)<TH>bandbool.c (13.445378%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match5470-0.html#0',2,'match5470-1.html#0',3)" NAME="0">(80-95)<TD><A HREF="javascript:ZweiFrames('match5470-0.html#0',2,'match5470-1.html#0',3)" NAME="0">(195-209)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mask_ideal_band.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* creates an ideal filter.
 *
 * 02/01/14
 * 	- from ideal.c
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;

#include &quot;pcreate.h&quot;
#include &quot;point.h&quot;
#include &quot;pmask.h&quot;

typedef struct _VipsMaskIdealBand {
	VipsMask parent_instance;

	double frequency_cutoff_x;
	double frequency_cutoff_y;
	double radius;

} VipsMaskIdealBand;

typedef VipsMaskClass VipsMaskIdealBandClass;

G_DEFINE_TYPE( VipsMaskIdealBand, vips_mask_ideal_band, 
	VIPS_TYPE_MASK );

static double
vips_mask_ideal_band_point( VipsMask *mask, double dx, double dy ) 
{
	VipsMaskIdealBand *ideal_band = (VipsMaskIdealBand *) mask;
	double fcx = ideal_band-&gt;frequency_cutoff_x;
	double fcy = ideal_band-&gt;frequency_cutoff_y;
	double r2 = ideal_band-&gt;radius * ideal_band-&gt;radius;

	double d1 = (dx - fcx) * (dx - fcx) + (dy - fcy) * (dy - fcy);
<A NAME="0"></A>	double d2 = (dx + fcx) * (dx + fcx) + (dy + fcy) * (dy + fcy);

	return( (d1 &lt; r2 || d2 &lt; r2) ? 1.0 : 0.0 ); 
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match5470-1.html#0',3,'match5470-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
vips_mask_ideal_band_class_init( VipsMaskIdealBandClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VipsMaskClass *mask_class = VIPS_MASK_CLASS( class );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = &quot;mask_ideal_band&quot;;
	vobject_class-&gt;description = _( &quot;make an ideal band filter&quot; );

	mask_class-&gt;point = vips_mask_ideal_band_point;</B></FONT>

	VIPS_ARG_DOUBLE( class, &quot;frequency_cutoff_x&quot;, 6, 
		_( &quot;Frequency cutoff x&quot; ), 
		_( &quot;Frequency cutoff x&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsMaskIdealBand, frequency_cutoff_x ),
		0.0, 1000000.0, 0.5 );

	VIPS_ARG_DOUBLE( class, &quot;frequency_cutoff_y&quot;, 7, 
		_( &quot;Frequency cutoff y&quot; ), 
		_( &quot;Frequency cutoff y&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsMaskIdealBand, frequency_cutoff_y ),
		0.0, 1000000.0, 0.5 );

	VIPS_ARG_DOUBLE( class, &quot;radius&quot;, 8, 
		_( &quot;radius&quot; ), 
		_( &quot;radius of circle&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsMaskIdealBand, radius ),
		0.0, 1000000.0, 0.1 );

}

static void
vips_mask_ideal_band_init( VipsMaskIdealBand *ideal_band )
{
	ideal_band-&gt;frequency_cutoff_x = 0.5;
	ideal_band-&gt;frequency_cutoff_y = 0.5;
	ideal_band-&gt;radius = 0.1;
}

/**
 * vips_mask_ideal_band:
 * @out: (out): output image
 * @width: image size
 * @height: image size
 * @frequency_cutoff_x: position of band
 * @frequency_cutoff_y: position of band
 * @radius: size of band
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @nodc: don't set the DC pixel
 * * @reject: invert the filter sense
 * * @optical: coordinates in optical space
 * * @uchar: output a uchar image
 *
 * Make an ideal band-pass or band-reject filter, that is, one with a 
 * sharp cutoff around the point @frequency_cutoff_x, @frequency_cutoff_y, 
 * of size @radius. 
 *
 * See also: vips_mask_ideal().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_mask_ideal_band( VipsImage **out, int width, int height, 
	double frequency_cutoff_x, double frequency_cutoff_y, 
	double radius, ... )
{
	va_list ap;
	int result;

	va_start( ap, radius );
	result = vips_call_split( &quot;mask_ideal_band&quot;, ap, out, width, height, 
		frequency_cutoff_x, frequency_cutoff_y, radius );
	va_end( ap );

	return( result );
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bandbool.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* bandbool.c --- bool op across image bands
 *
 * 7/12/12
 * 	- from boolean.c
 */

/*

    Copyright (C) 1991-2005 The National Gallery

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;vips/vips.h&gt;

#include &quot;bandary.h&quot;

typedef struct _VipsBandbool {
	VipsBandary parent_instance;

	VipsImage *in;

	VipsOperationBoolean operation;

} VipsBandbool;

typedef VipsBandaryClass VipsBandboolClass;

G_DEFINE_TYPE( VipsBandbool, vips_bandbool, VIPS_TYPE_BANDARY );

static int
vips_bandbool_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsBandary *bandary = (VipsBandary *) object;
	VipsBandbool *bandbool = (VipsBandbool *) object;

	/* &lt;&lt; and &gt;&gt; don't work over bands.
	 */
	if( bandbool-&gt;operation == VIPS_OPERATION_BOOLEAN_LSHIFT ||
		bandbool-&gt;operation == VIPS_OPERATION_BOOLEAN_RSHIFT ) {
		vips_error( class-&gt;nickname, 
			_( &quot;operator %s not supported across image bands&quot; ), 
			vips_enum_nick( VIPS_TYPE_OPERATION_BOOLEAN, 
				bandbool-&gt;operation ) );
		return( -1 );
	}

	if( bandbool-&gt;in ) {
		if( vips_check_noncomplex( class-&gt;nickname, bandbool-&gt;in ) )
			return( -1 );

		bandary-&gt;n = 1;
		bandary-&gt;in = &amp;bandbool-&gt;in;

		if( bandbool-&gt;in-&gt;Bands == 1 ) 
			return( vips_bandary_copy( bandary ) );
	}

	bandary-&gt;out_bands = 1;

	if( VIPS_OBJECT_CLASS( vips_bandbool_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

#define SWITCH( I, F, OP ) \
	switch( vips_image_get_format( im ) ) { \
	case VIPS_FORMAT_UCHAR:		I( unsigned char, OP ); break; \
	case VIPS_FORMAT_CHAR:		I( signed char, OP ); break; \
	case VIPS_FORMAT_USHORT: 	I( unsigned short, OP ); break; \
	case VIPS_FORMAT_SHORT: 	I( signed short, OP ); break; \
	case VIPS_FORMAT_UINT: 		I( unsigned int, OP ); break; \
	case VIPS_FORMAT_INT: 		I( signed int, OP ); break; \
	case VIPS_FORMAT_FLOAT: 	F( float, OP ); break; \
	case VIPS_FORMAT_DOUBLE: 	F( double, OP ); break;\
 	\
	default: \
		g_assert_not_reached(); \
	} 

#define LOOPB( TYPE, OP ) { \
	TYPE *p = (TYPE *) in[0]; \
	TYPE *q = (TYPE *) out; \
 	\
	for( x = 0; x &lt; width; x++ ) { \
		TYPE acc; \
		\
		acc = p[0]; \
		for( b = 1; b &lt; bands; b++ ) \
			acc = acc OP p[b]; \
		\
		q[x] = acc; \
		p += bands; \
	} \
}

#define FLOOPB( TYPE, OP ) { \
	TYPE *p = (TYPE *) in[0]; \
	int *q = (int *) out; \
 	\
	for( x = 0; x &lt; width; x++ ) { \
		int acc; \
		\
		acc = (int) p[0]; \
		for( b = 1; b &lt; bands; b++ ) \
			acc = acc OP ((int) p[b]); \
		\
		q[x] = acc; \
		p += bands; \
	} \
}

static void
vips_bandbool_buffer( VipsBandarySequence *seq,
	VipsPel *out, VipsPel **in, int width )
{
	VipsBandary *bandary = seq-&gt;bandary;
	VipsBandbool *bandbool = (VipsBandbool *) bandary;
	VipsImage *im = bandary-&gt;ready[0];
	int bands = im-&gt;Bands;

	int x, b;

	switch( bandbool-&gt;operation ) {
	case VIPS_OPERATION_BOOLEAN_AND: 	
		SWITCH( LOOPB, FLOOPB, &amp; ); 
		break;

	case VIPS_OPERATION_BOOLEAN_OR: 	
		SWITCH( LOOPB, FLOOPB, | ); 
		break;

	case VIPS_OPERATION_BOOLEAN_EOR: 	
		SWITCH( LOOPB, FLOOPB, ^ ); 
		break;

	default:
		g_assert_not_reached();
	}
}

/* Save a bit of typing.
 */
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX

/* Format conversions for boolean. 
 */
<A NAME="0"></A>static const VipsBandFormat vips_bandbool_format_table[10] = {
/* UC  C   US  S   UI  I   F   X   D   DX */
   UC, C,  US, S,  UI, I,  I,  I,  I,  I,
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match5470-0.html#0',2,'match5470-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};

static void
vips_bandbool_class_init( VipsBandboolClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsBandaryClass *bandary_class = VIPS_BANDARY_CLASS( class );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;bandbool&quot;;
	object_class-&gt;description = _( &quot;boolean operation across image bands&quot; );
	object_class-&gt;build = vips_bandbool_build;</B></FONT>

	bandary_class-&gt;process_line = vips_bandbool_buffer;
	bandary_class-&gt;format_table = vips_bandbool_format_table;

	VIPS_ARG_IMAGE( class, &quot;in&quot;, 0, 
		_( &quot;Input&quot; ), 
		_( &quot;Input image argument&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsBandbool, in ) );

	VIPS_ARG_ENUM( class, &quot;boolean&quot;, 200, 
		_( &quot;Operation&quot; ), 
		_( &quot;boolean to perform&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsBandbool, operation ),
		VIPS_TYPE_OPERATION_BOOLEAN, 
			VIPS_OPERATION_BOOLEAN_AND ); 
}

static void
vips_bandbool_init( VipsBandbool *bandbool )
{
	bandbool-&gt;operation = VIPS_OPERATION_BOOLEAN_AND;
}

static int
vips_bandboolv( VipsImage *in, VipsImage **out, 
	VipsOperationBoolean operation, va_list ap )
{
	return( vips_call_split( &quot;bandbool&quot;, ap, in, out, operation ) );
}

/**
 * vips_bandbool: (method)
 * @in: left-hand input #VipsImage
 * @out: (out): output #VipsImage
 * @boolean: boolean operation to perform
 * @...: %NULL-terminated list of optional named arguments
 *
 * Perform various boolean operations across the bands of an image. For
 * example, a three-band uchar image operated on with
 * #VIPS_OPERATION_BOOLEAN_AND will produce a one-band uchar image where each
 * pixel is the bitwise and of the band elements of the corresponding pixel in
 * the input image. 
 *
 * The output image is the same format as the input image for integer
 * types. Float types are cast to int before processing. Complex types are not
 * supported.
 *
 * The output image always has one band. 
 *
 * This operation is useful in conjuction with vips_relational(). You can use
 * it to see if all image bands match exactly. 
 *
 * See also: vips_boolean_const().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_bandbool( VipsImage *in, VipsImage **out, 
	VipsOperationBoolean boolean, ... )
{
	va_list ap;
	int result;

	va_start( ap, boolean );
	result = vips_bandboolv( in, out, boolean, ap );
	va_end( ap );

	return( result );
}

/**
 * vips_bandand: (method)
 * @in: left-hand input #VipsImage
 * @out: (out): output #VipsImage
 * @...: %NULL-terminated list of optional named arguments
 *
 * Perform #VIPS_OPERATION_BOOLEAN_AND on an image. See
 * vips_bandbool().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_bandand( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_bandboolv( in, out, VIPS_OPERATION_BOOLEAN_AND, ap );
	va_end( ap );

	return( result );
}

/**
 * vips_bandor: (method)
 * @in: left-hand input #VipsImage
 * @out: (out): output #VipsImage
 * @...: %NULL-terminated list of optional named arguments
 *
 * Perform #VIPS_OPERATION_BOOLEAN_OR on an image. See
 * vips_bandbool().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_bandor( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_bandboolv( in, out, VIPS_OPERATION_BOOLEAN_OR, ap );
	va_end( ap );

	return( result );
}

/**
 * vips_bandeor: (method)
 * @in: left-hand input #VipsImage
 * @out: (out): output #VipsImage
 * @...: %NULL-terminated list of optional named arguments
 *
 * Perform #VIPS_OPERATION_BOOLEAN_EOR on an image. See
 * vips_bandbool().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_bandeor( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_bandboolv( in, out, VIPS_OPERATION_BOOLEAN_EOR, ap );
	va_end( ap );

	return( result );
}

</PRE>
</div>
  </div>
</body>
</html>
