
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</h3>
            <pre><code>1  #include <tomcrypt_test.h>
2  #if !defined(LTC_DER)
3  int der_test(void)
4  {
5     return CRYPT_NOP;
6  }
7  #else
8  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 2
9  #define LTC_DER_TESTS_PRINT_FLEXI
10  #endif
11  static const char s_der_tests_stinky_root_cert[] =
12     "MIIFETCCA/mgAwIBAgIQbv53JNmv518t5lkCHE272jANBgkqhkiG9w0BAQUFADCB"
13     "lTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug"
14     "Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho"
15     "dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHTAbBgNVBAMTFFVUTi1VU0VSRmlyc3Qt"
16     "T2JqZWN0MB4XDTA4MDQyOTAwMDAwMFoXDTEwMDQyOTIzNTk1OVowgbUxCzAJBgNV"
17     "BAYTAlVTMQ4wDAYDVQQRDAU0NDE0MzELMAkGA1UECAwCT0gxGTAXBgNVBAcMEE1h"
18     "eWZpZWxkIFZpbGxhZ2UxEDAOBgNVBAkMB1N1aXRlIEExFDASBgNVBAkMCzc2NyBC"
19     "ZXRhIERyMSIwIAYDVQQKDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMSIwIAYD"
20     "VQQDDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMIIBIjANBgkqhkiG9w0BAQEF"
21     "AAOCAQ8AMIIBCgKCAQEAzH7ZBkMcBuHx8d2f10RGTHAf7gzzVteGbOihJGH2BwlS"
22     "ZvNp6WEE4DfL+s1vp0wzk1XeLN5tRjg2qum9YqyCk7okh7pXGy46f5mWbLQiefGA"
23     "j5UXRcr6WJ3xeACdbXxKrYMV0REia+4Jb2UbFA8S81PjhRon6vcRz76ziUWwt8NC"
24     "igX+4ZC0skhhKzKszel6KGL7bJCtLG7ukw9DZCrvPCRcKFeM/GwQ6ACMgP88CSCL"
25     "t1fbIXDH1vd/x2XM3QlaSDN6hYDbef8m1T+9TCkXVKeqG1GYjSUrHzYnCZUmTRrR"
26     "38jgC3qXxiIpDKW105uM0nlXe2XF9c+ot2MdWvV4TwIDAQABo4IBOTCCATUwHwYD"
27     "VR0jBBgwFoAU2u1kdBScFDyr3ZmpvVsoTYs8ydgwHQYDVR0OBBYEFK+1HzZE4i28"
28     "oLIzuqlFR9SspiCIMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMBMGA1Ud"
29     "JQQMMAoGCCsGAQUFBwMDMBEGCWCGSAGG+EIBAQQEAwIEEDBGBgNVHSAEPzA9MDsG"
30     "DCsGAQQBsjEBAgEDAjArMCkGCCsGAQUFBwIBFh1odHRwczovL3NlY3VyZS5jb21v"
31     "ZG8ubmV0L0NQUzBCBgNVHR8EOzA5MDegNaAzhjFodHRwOi8vY3JsLnVzZXJ0cnVz"
32     "dC5jb20vVVROLVVTRVJGaXJzdC1PYmplY3QuY3JsMCEGA1UdEQQaMBiBFnN1cHBv"
33     "cnRAcHJlZW1wdGl2ZS5jb20wDQYJKoZIhvcNAQEFBQADggEBAC+JM26Dokvonudl"
34     "JXe/Yun7IBhimkagZUjbk9l/GQWN6i+v1o95UJ1wGJtBdm2+MxbSaPoNTDZR4B+2"
35     "lYL9MW57UVmePrnfUPXQKZZG+8gTRDz8+7ol/CEAKmS3MLKCRcH5oe+J5345sGxi"
36     "FC/KWNKedTNraW95xlg8NTlL2yRP7TMsjvBxgLmkbaFUoXzPTbQWmtovIagIT8GC"
37     "JeXwdFaRjbamiz3Irl+u7x/mhxdza6RvgBYylXRFMudANpeGsV7gDXlnfzpFDKHQ"
38     "niVwB7P5sbPFIlmIc+4/xRItkLIRjCVXaepgN9KYu3VOgiSDI6wXiTwP44/LUXQM"
39     "hetwa7s=";
40  const char ltc_der_tests_cacert_root_cert[] =
41     "MIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290"
42     "IENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB"
43     "IENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA"
44     "Y2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO"
45     "BgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi"
46     "MCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ"
47     "ARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC"
48     "CgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ"
49     "8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6"
50     "zWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y"
51     "fk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7"
52     "w2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc"
53     "G8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k"
54     "epKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q"
55     "laegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ"
56     "QUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU"
57     "fslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826"
58     "YreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w"
59     "ggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY"
60     "gBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe"
61     "MBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0"
62     "IFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy"
63     "dC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw"
64     "czovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0"
65     "dHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl"
66     "aHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC"
67     "AQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg"
68     "b3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB"
69     "ACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc"
70     "nWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg"
71     "18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c"
72     "gr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl"
73     "Jzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY"
74     "sONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T"
75     "SCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF"
76     "CpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum"
77     "GCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk"
78     "zk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW"
79     "omTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD";
80  const unsigned long ltc_der_tests_cacert_root_cert_size = sizeof(ltc_der_tests_cacert_root_cert);
81  #define ASN1_FMTSTRING_FMT "line: %d, type=%d, size=%lu, data=%p, self=%p, next=%p, prev=%p, parent=%p, child=%p"
82  #define ASN1_FMTSTRING_VAL(l)  __LINE__, (l)->type, (l)->size, (l)->data, (l), (l)->next, (l)->prev, (l)->parent, (l)->child
83  #define ASN1_ERR(l) fprintf(stderr, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l)); \
84      exit(EXIT_FAILURE)
85  #define CHECK_ASN1_HAS(l, w) do { if ((l)->w == NULL) { \
86      ASN1_ERR(l);\
87  } } while(0)
88  #define CHECK_ASN1_HAS_NO(l, w) do { if ((l)->w != NULL) { \
89      ASN1_ERR(l);\
90  } } while(0)
91  #define CHECK_ASN1_TYPE(l, t) do { if ((l)->type != (t)) { \
92      ASN1_ERR(l);\
93  } } while(0)
94  #define CHECK_ASN1_HAS_CHILD(l) CHECK_ASN1_HAS(l, child)
95  #define CHECK_ASN1_HAS_NO_CHILD(l) CHECK_ASN1_HAS_NO(l, child)
96  #define CHECK_ASN1_HAS_NEXT(l) CHECK_ASN1_HAS(l, next)
97  #define CHECK_ASN1_HAS_NO_NEXT(l) CHECK_ASN1_HAS_NO(l, next)
98  #define CHECK_ASN1_HAS_DATA(l) CHECK_ASN1_HAS(l, data)
99  #define CHECK_ASN1_HAS_NO_DATA(l) CHECK_ASN1_HAS_NO(l, data)
100  #ifdef LTC_DER_TESTS_PRINT_FLEXI
101  static void* s_xmalloc(int l)
102  {
103     void *r = XMALLOC(l);
104  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
105     fprintf(stderr, "ALLOC %9d to %p\n", l, r);
106  #endif
107     if (!r) {
108        fprintf(stderr, "Could not allocate %d bytes of memory\n", l);
109        exit(EXIT_FAILURE);
110     }
111     return r;
112  }
113  static void s_free(void *p)
114  {
115  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
116     fprintf(stderr, "FREE %p\n", p);
117  #endif
118     XFREE(p);
119  }
120  static void s_der_tests_print_flexi(ltc_asn1_list* l, unsigned int level)
121  {
122    char *buf = NULL;
123    const char* name = NULL;
124    const char* text = NULL;
125    ltc_asn1_list* ostring = NULL;
126    unsigned int n;
127    int slen;
128    switch (l->type)
129      {
130    case LTC_ASN1_EOL:
131      name = "EOL";
132      slen = snprintf(NULL, 0, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
133      buf = s_xmalloc(slen);
134      slen = snprintf(buf, slen, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
135      text = buf;
136      break;
137    case LTC_ASN1_BOOLEAN:
138      name = "BOOLEAN";
139      {
140        if (*(int*)l->data)
141          text = "true";
142        else
143          text = "false";
144      }
145      break;
146    case LTC_ASN1_INTEGER:
147      name = "INTEGER";
148      buf = s_xmalloc(((mp_get_digit_count(l->data) + 1) * ltc_mp.bits_per_digit) / 3);
149      mp_toradix(l->data, buf, 10);
150      text = buf;
151      break;
152    case LTC_ASN1_SHORT_INTEGER:
153      name = "SHORT INTEGER";
154      break;
155    case LTC_ASN1_BIT_STRING:
156      name = "BIT STRING";
157      break;
158    case LTC_ASN1_OCTET_STRING:
159      name = "OCTET STRING";
160      {
161        unsigned long ostring_l = l->size;
162        if (der_decode_sequence_flexi(l->data, &ostring_l, &ostring) == CRYPT_OK) {
163            text = "";
164        } else {
165            int r;
166            int sz = l->size * 2 + 1;
167            char* s = buf = s_xmalloc(sz);
168            for (n = 0; n < l->size; ++n) {
169                r = snprintf(s, sz, "%02X", ((unsigned char*)l->data)[n]);
170                if (r < 0 || r >= sz) {
171                    fprintf(stderr, "%s boom\n", name);
172                    exit(EXIT_FAILURE);
173                }
174                s += r;
175                sz -= r;
176            }
177            text = buf;
178        }
179      }
180      break;
181    case LTC_ASN1_NULL:
182      name = "NULL";
183      text = "";
184      break;
185    case LTC_ASN1_OBJECT_IDENTIFIER:
186      name = "OBJECT IDENTIFIER";
187      {
188        unsigned long len = 0;
189        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_BUFFER_OVERFLOW) {
190          fprintf(stderr, "%s WTF\n", name);
191          exit(EXIT_FAILURE);
192        }
193        buf = s_xmalloc(len);
194        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_OK) {
195          fprintf(stderr, "%s boom\n", name);
196          exit(EXIT_FAILURE);
197        }
198        text = buf;
199      }
200      break;
201    case LTC_ASN1_IA5_STRING:
202      name = "IA5 STRING";
203      text = l->data;
204      break;
205    case LTC_ASN1_PRINTABLE_STRING:
206      name = "PRINTABLE STRING";
207      text = l->data;
208      break;
209    case LTC_ASN1_UTF8_STRING:
210      name = "UTF8 STRING";
211      break;
212    case LTC_ASN1_UTCTIME:
213      name = "UTCTIME";
214      {
215        ltc_utctime* ut = l->data;
216        slen = 32;
217        buf = s_xmalloc(slen);
218        snprintf(buf, slen, "%02d-%02d-%02d %02d:%02d:%02d %c%02d:%02d",
219            ut->YY, ut->MM, ut->DD, ut->hh, ut->mm, ut->ss,
220            ut->off_dir ? '-' : '+', ut->off_hh, ut->off_mm);
221        text = buf;
222      }
223      break;
224    case LTC_ASN1_GENERALIZEDTIME:
225      name = "GENERALIZED TIME";
226      {
227        ltc_generalizedtime* gt = l->data;
228        slen = 32;
229        buf = s_xmalloc(slen);
230        if(gt->fs)
231           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02d.%02dZ",
232            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss, gt->fs);
233        else
234           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02dZ",
235            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss);
236        text = buf;
237      }
238      break;
239    case LTC_ASN1_CHOICE:
240      name = "CHOICE";
241      break;
242    case LTC_ASN1_SEQUENCE:
243      name = "SEQUENCE";
244      text = "";
245      break;
246    case LTC_ASN1_SET:
247      name = "SET";
248      text = "";
249      break;
250    case LTC_ASN1_SETOF:
251      name = "SETOF";
252      text = "";
253      break;
254    case LTC_ASN1_RAW_BIT_STRING:
255      name = "RAW BIT STRING";
256      break;
257    case LTC_ASN1_TELETEX_STRING:
258      name = "TELETEX STRING";
259      text = l->data;
260      break;
261    case LTC_ASN1_CUSTOM_TYPE:
262      name = "NON STANDARD";
263      {
264         int r;
265         int sz = 128;
266         char* s = buf = s_xmalloc(sz);
267         r = snprintf(s, sz, "[%s %s %llu]", der_asn1_class_to_string_map[l->klass], der_asn1_pc_to_string_map[l->pc], l->tag);
268         if (r < 0 || r >= sz) {
269             fprintf(stderr, "%s boom\n", name);
270             exit(EXIT_FAILURE);
271         }
272         s += r;
273         sz -= r;
274         text = buf;
275      }
276      break;
277    }
278    for (n = 0; n < level; ++n) {
279       fprintf(stderr, "    ");
280    }
281    if (name) {
282        if (text)
283           fprintf(stderr, "%s %s\n", name, text);
284        else
285           fprintf(stderr, "%s <missing decoding>\n", name);
286    }
287    else
288       fprintf(stderr, "WTF type=%i\n", l->type);
289    if (buf) {
290       s_free(buf);
291       buf = NULL;
292    }
293    if (ostring) {
294        s_der_tests_print_flexi(ostring, level + 1);
295        der_free_sequence_flexi(ostring);
296    }
297    if (l->child)
298      s_der_tests_print_flexi(l->child, level + 1);
299    if (l->next)
300      s_der_tests_print_flexi(l->next, level);
301  }
302  #endif
303  static void der_cacert_test(void)
304  {
305    unsigned char buf[sizeof(ltc_der_tests_cacert_root_cert)];
306    unsigned long len1 = sizeof(buf), len2;
307    ltc_asn1_list *decoded_list, *l, *l1, *l2;
308    DO(base64_decode(s_der_tests_stinky_root_cert, sizeof(s_der_tests_stinky_root_cert), buf, &len1));
309    len2 = len1;
310    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
311    der_free_sequence_flexi(decoded_list);
312    len1 = sizeof(buf);
313    DO(base64_decode(ltc_der_tests_cacert_root_cert, sizeof(ltc_der_tests_cacert_root_cert), buf, &len1));
314    len2 = len1;
315    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
316    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
317    CHECK_ASN1_HAS_DATA(decoded_list);
318    der_sequence_shrink(decoded_list);
319    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
320    CHECK_ASN1_HAS_NO_DATA(decoded_list);
321  #ifdef LTC_DER_TESTS_PRINT_FLEXI
322    printf("\n\n--- test print start ---\n\n");
323    s_der_tests_print_flexi(decoded_list, 0);
324    printf("\n\n--- test print end ---\n\n");
325  #endif
326    l = decoded_list;
327    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
328    CHECK_ASN1_HAS_CHILD(l);
329    CHECK_ASN1_HAS_NO_NEXT(l);
330    l = l->child;
331    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
332    CHECK_ASN1_HAS_CHILD(l);
333    CHECK_ASN1_HAS_NEXT(l);
334    l1 = l->child;
335    CHECK_ASN1_TYPE(l1, LTC_ASN1_CUSTOM_TYPE);
336    CHECK_ASN1_HAS_CHILD(l1);
337    CHECK_ASN1_HAS_NEXT(l1);
338    l2 = l1->child;
339    CHECK_ASN1_TYPE(l2, LTC_ASN1_INTEGER);
340    CHECK_ASN1_HAS_NO_CHILD(l2);
341    CHECK_ASN1_HAS_NO_NEXT(l2);
342    l1 = l1->next;
343    CHECK_ASN1_TYPE(l1, LTC_ASN1_INTEGER);
344    CHECK_ASN1_HAS_NO_CHILD(l1);
345    CHECK_ASN1_HAS_NEXT(l1);
346    l1 = l1->next;
347    CHECK_ASN1_TYPE(l1, LTC_ASN1_SEQUENCE);
348    CHECK_ASN1_HAS_CHILD(l1);
349    CHECK_ASN1_HAS_NEXT(l1);
350    l2 = l1->child;
351    CHECK_ASN1_TYPE(l2, LTC_ASN1_OBJECT_IDENTIFIER);
352    CHECK_ASN1_HAS_NO_CHILD(l2);
353    CHECK_ASN1_HAS_NEXT(l2);
354    l2 = l2->next;
355    CHECK_ASN1_TYPE(l2, LTC_ASN1_NULL);
356    CHECK_ASN1_HAS_NO_CHILD(l2);
357    CHECK_ASN1_HAS_NO_NEXT(l2);
358    l = l->next;
359    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
360    CHECK_ASN1_HAS_CHILD(l);
361    CHECK_ASN1_HAS_NEXT(l);
362    l1 = l->child;
363    CHECK_ASN1_TYPE(l1, LTC_ASN1_OBJECT_IDENTIFIER);
364    CHECK_ASN1_HAS_NO_CHILD(l1);
365    CHECK_ASN1_HAS_NEXT(l1);
366    l1 = l1->next;
367    CHECK_ASN1_TYPE(l1, LTC_ASN1_NULL);
368    CHECK_ASN1_HAS_NO_CHILD(l1);
369    CHECK_ASN1_HAS_NO_NEXT(l1);
370    l = l->next;
371    CHECK_ASN1_TYPE(l, LTC_ASN1_BIT_STRING);
372    CHECK_ASN1_HAS_NO_CHILD(l);
373    CHECK_ASN1_HAS_NO_NEXT(l);
374    der_free_sequence_flexi(decoded_list);
375  }
376  static void der_set_test(void)
377  {
378     ltc_asn1_list list[10];
379     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
380     static const unsigned char bin_str[] = { 1, 0, 0, 1 };
381     static const unsigned long int_val   = 12345678UL;
382     unsigned char strs[10][10], outbuf[128];
383     unsigned long x, val, outlen;
384     LTC_SET_ASN1(list, 0, LTC_ASN1_OCTET_STRING,  oct_str, sizeof(oct_str));
385     LTC_SET_ASN1(list, 1, LTC_ASN1_BIT_STRING,    bin_str, sizeof(bin_str));
386     LTC_SET_ASN1(list, 2, LTC_ASN1_SHORT_INTEGER, &int_val, 1);
387     outlen = sizeof(outbuf);
388     DO(der_encode_set(list, 3, outbuf, &outlen));
389     LTC_SET_ASN1(list, 0, LTC_ASN1_BIT_STRING,    strs[1], sizeof(strs[1]));
390     LTC_SET_ASN1(list, 1, LTC_ASN1_SHORT_INTEGER, &val, 1);
391     LTC_SET_ASN1(list, 2, LTC_ASN1_OCTET_STRING,  strs[0], sizeof(strs[0]));
392     DO(der_decode_set(outbuf, outlen, list, 3));
393     if (memcmp(strs[0], oct_str, sizeof(oct_str))) {
394        fprintf(stderr, "error decoding set using der_decode_set (oct_str is wrong):\n");
395        exit(EXIT_FAILURE);
396     }
397     if (memcmp(strs[1], bin_str, sizeof(bin_str))) {
398        fprintf(stderr, "error decoding set using der_decode_set (bin_str is wrong):\n");
399        exit(EXIT_FAILURE);
400     }
401     if (val != int_val) {
402        fprintf(stderr, "error decoding set using der_decode_set (int_val is wrong):\n");
403        exit(EXIT_FAILURE);
404     }
405     strcpy((char*)strs[0], "one");
406     strcpy((char*)strs[1], "one2");
407     strcpy((char*)strs[2], "two");
408     strcpy((char*)strs[3], "aaa");
409     strcpy((char*)strs[4], "aaaa");
410     strcpy((char*)strs[5], "aab");
411     strcpy((char*)strs[6], "aaab");
412     strcpy((char*)strs[7], "bbb");
413     strcpy((char*)strs[8], "bbba");
414     strcpy((char*)strs[9], "bbbb");
415     for (x = 0; x < 10; x++) {
416         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], XSTRLEN((char*)strs[x]));
417     }
418     outlen = sizeof(outbuf);
419     DO(der_encode_setof(list, 10, outbuf, &outlen));
420     for (x = 0; x < 10; x++) {
421         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], sizeof(strs[x]) - 1);
422     }
423     XMEMSET(strs, 0, sizeof(strs));
424     DO(der_decode_set(outbuf, outlen, list, 10));
425     for (x = 1; x < 10; x++) {
426        if (!(XSTRLEN((char*)strs[x-1]) <= XSTRLEN((char*)strs[x])) && strcmp((char*)strs[x-1], (char*)strs[x]) >= 0) {
427           fprintf(stderr, "error SET OF order at %lu is wrong\n", x);
428           exit(EXIT_FAILURE);
429        }
430     }
431  }
432  static void s_der_oid_test(void)
433  {
434     static const unsigned char oid_x690_8_19_5_example[] = { 0x06, 0x03, 0x88, 0x37, 0x03 };
435     unsigned long len, oid[3];
436     unsigned char buf[64];
437     ltc_asn1_list *decoded_list, static_list[1];
438     len = sizeof(oid_x690_8_19_5_example);
439     DO(der_decode_sequence_flexi(oid_x690_8_19_5_example, &len, &decoded_list));
440     LTC_SET_ASN1(static_list, 0, LTC_ASN1_OBJECT_IDENTIFIER, (void *)decoded_list->data, decoded_list->size);
441     len = sizeof(buf);
442     DO(der_encode_object_identifier(decoded_list->data, decoded_list->size, buf, &len));
443     der_sequence_free(decoded_list);
444     DO(do_compare_testvector(buf, len, oid_x690_8_19_5_example, sizeof(oid_x690_8_19_5_example), "OID X6.90 Ch. 8.19.5 Example", 0));
445     oid[0] = 3;
446     oid[1] = 4;
447     oid[2] = 5;
448     len = sizeof(buf);
449     SHOULD_FAIL(der_encode_object_identifier(oid, 3, buf, &len));
450     len = sizeof(buf);
451     SHOULD_FAIL(der_length_object_identifier(oid, 3, &len));
452  }
453  static void der_flexi_test(void)
454  {
455     static const char printable_str[]    = "printable";
456     static const char set1_str[]         = "333";
457     static const char set2_str[]         = "222";
458     static const char ia5_str[]          = "ia5";
459     static const unsigned long int_val   = 12345678UL;
460     static const ltc_utctime   utctime   = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
461     static const ltc_generalizedtime gtime = { 2017, 03, 21, 10, 21, 12, 421, 1, 2, 0 };
462     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
463     static const unsigned char bit_str[] = { 1, 0, 0, 1 };
464     static const unsigned long oid_str[] = { 1, 2, 840, 113549 };
465     unsigned char encode_buf[192];
466     unsigned long encode_buf_len, decode_len;
467     ltc_asn1_list static_list[5][4], *decoded_list, *l;
468     LTC_SET_ASN1(static_list[0], 0, LTC_ASN1_PRINTABLE_STRING, (void *)printable_str, XSTRLEN(printable_str));
469     LTC_SET_ASN1(static_list[0], 1, LTC_ASN1_IA5_STRING,       (void *)ia5_str,       XSTRLEN(ia5_str));
470     LTC_SET_ASN1(static_list[0], 2, LTC_ASN1_SEQUENCE,         static_list[1],   4);
471     LTC_SET_ASN1(static_list[1], 0, LTC_ASN1_SHORT_INTEGER,    (void *)&int_val,         1);
472     LTC_SET_ASN1(static_list[1], 1, LTC_ASN1_UTCTIME,          (void *)&utctime,         1);
473     LTC_SET_ASN1(static_list[1], 2, LTC_ASN1_GENERALIZEDTIME,  (void *)&gtime,           1);
474     LTC_SET_ASN1(static_list[1], 3, LTC_ASN1_SEQUENCE,         static_list[2],   3);
475     LTC_SET_ASN1(static_list[2], 0, LTC_ASN1_OCTET_STRING,     (void *)oct_str,          4);
476     LTC_SET_ASN1(static_list[2], 1, LTC_ASN1_BIT_STRING,       (void *)bit_str,          4);
477     LTC_SET_ASN1(static_list[2], 2, LTC_ASN1_SEQUENCE,         static_list[3],   3);
478     LTC_SET_ASN1(static_list[3], 0, LTC_ASN1_OBJECT_IDENTIFIER,(void *)oid_str,          4);
479     LTC_SET_ASN1(static_list[3], 1, LTC_ASN1_NULL,             NULL,             0);
480     LTC_SET_ASN1(static_list[3], 2, LTC_ASN1_SETOF,            static_list[4],   2);
481     LTC_SET_ASN1(static_list[4], 0, LTC_ASN1_PRINTABLE_STRING, set1_str, XSTRLEN(set1_str));
482     LTC_SET_ASN1(static_list[4], 1, LTC_ASN1_PRINTABLE_STRING, set2_str, XSTRLEN(set2_str));
483     encode_buf_len = sizeof(encode_buf);
484     DO(der_encode_sequence(&static_list[0][0], 3, encode_buf, &encode_buf_len));
485  #if 0
486     {
487       FILE *f;
488       f = fopen("t.bin", "wb");
489       fwrite(encode_buf, 1, encode_buf_len, f);
490       fclose(f);
491     }
492  #endif
493     decode_len = encode_buf_len;
494     DO(der_decode_sequence_flexi(encode_buf, &decode_len, &decoded_list));
495     if (decode_len != encode_buf_len) {
496        fprintf(stderr, "Decode len of %lu does not match encode len of %lu \n", decode_len, encode_buf_len);
497        exit(EXIT_FAILURE);
498     }
499     l = decoded_list;
500     if (l->next != NULL || l->child == NULL) {
501        fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
502        exit(EXIT_FAILURE);
503     }
504        if (l->type != LTC_ASN1_SEQUENCE) {
505           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
506           exit(EXIT_FAILURE);
507        }
508        l = l->child;
509        if (l->next == NULL || l->child != NULL) {
510           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
511           exit(EXIT_FAILURE);
512        }
513        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
514           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
515           exit(EXIT_FAILURE);
516        }
517        if (l->size != XSTRLEN(printable_str) || memcmp(printable_str, l->data, l->size)) {
518           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
519           exit(EXIT_FAILURE);
520        }
521        l = l->next;
522        if (l->next == NULL || l->child != NULL) {
523           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
524           exit(EXIT_FAILURE);
525        }
526        if (l->type != LTC_ASN1_IA5_STRING) {
527           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
528           exit(EXIT_FAILURE);
529        }
530        if (l->size != XSTRLEN(ia5_str) || memcmp(ia5_str, l->data, l->size)) {
531           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
532           exit(EXIT_FAILURE);
533        }
534        l = l->next;
535        if (l->next != NULL || l->child == NULL) {
536           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
537           exit(EXIT_FAILURE);
538        }
539        if (l->type != LTC_ASN1_SEQUENCE) {
540           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
541           exit(EXIT_FAILURE);
542        }
543        l = l->child;
544        if (l->next == NULL || l->child != NULL) {
545           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
546           exit(EXIT_FAILURE);
547        }
548        if (l->type != LTC_ASN1_INTEGER) {
549           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
550           exit(EXIT_FAILURE);
551        }
552        if (mp_cmp_d(l->data, 12345678UL) != LTC_MP_EQ) {
553           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
554           exit(EXIT_FAILURE);
555        }
556        l = l->next;
557        if (l->next == NULL || l->child != NULL) {
558           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
559           exit(EXIT_FAILURE);
560        }
561        if (l->type != LTC_ASN1_UTCTIME) {
562           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
563           exit(EXIT_FAILURE);
564        }
565        if (memcmp(l->data, &utctime, sizeof(utctime))) {
566           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
567           exit(EXIT_FAILURE);
568        }
569        l = l->next;
570        if (l->next == NULL || l->child != NULL) {
571           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
572           exit(EXIT_FAILURE);
573        }
574        if (l->type != LTC_ASN1_GENERALIZEDTIME) {
575           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
576           exit(EXIT_FAILURE);
577        }
578        if (memcmp(l->data, &gtime, sizeof(gtime))) {
579           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
580           exit(EXIT_FAILURE);
581        }
582        l = l->next;
583        if (l->next != NULL || l->child == NULL) {
584           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
585           exit(EXIT_FAILURE);
586        }
587        if (l->type != LTC_ASN1_SEQUENCE) {
588           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
589           exit(EXIT_FAILURE);
590        }
591        l = l->child;
592        if (l->next == NULL || l->child != NULL) {
593           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
594           exit(EXIT_FAILURE);
595        }
596        if (l->type != LTC_ASN1_OCTET_STRING) {
597           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
598           exit(EXIT_FAILURE);
599        }
600        if (l->size != sizeof(oct_str) || memcmp(oct_str, l->data, l->size)) {
601           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
602           exit(EXIT_FAILURE);
603        }
604        l = l->next;
605        if (l->next == NULL || l->child != NULL) {
606           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
607           exit(EXIT_FAILURE);
608        }
609        if (l->type != LTC_ASN1_BIT_STRING) {
610           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
611           exit(EXIT_FAILURE);
612        }
613        if (l->size != sizeof(bit_str) || memcmp(bit_str, l->data, l->size)) {
614           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
615           exit(EXIT_FAILURE);
616        }
617        l = l->next;
618        if (l->next != NULL || l->child == NULL) {
619           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
620           exit(EXIT_FAILURE);
621        }
622        if (l->type != LTC_ASN1_SEQUENCE) {
623           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
624           exit(EXIT_FAILURE);
625        }
626        l = l->child;
627        if (l->next == NULL || l->child != NULL) {
628           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
629           exit(EXIT_FAILURE);
630        }
631        if (l->type != LTC_ASN1_OBJECT_IDENTIFIER) {
632           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
633           exit(EXIT_FAILURE);
634        }
635        if (l->size != sizeof(oid_str)/sizeof(oid_str[0]) || memcmp(oid_str, l->data, l->size*sizeof(oid_str[0]))) {
636           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
637           exit(EXIT_FAILURE);
638        }
639        l = l->next;
640        if (l->type != LTC_ASN1_NULL) {
641           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
642           exit(EXIT_FAILURE);
643        }
644        l = l->next;
645        if (l->next != NULL || l->child == NULL) {
646           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
647           exit(EXIT_FAILURE);
648        }
649        if (l->type != LTC_ASN1_SET) {
650           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
651           exit(EXIT_FAILURE);
652        }
653        l = l->child;
654        if (l->next == NULL || l->child != NULL) {
655           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
656           exit(EXIT_FAILURE);
657        }
658        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
659           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
660           exit(EXIT_FAILURE);
661        }
662        if (l->size != XSTRLEN(set2_str) || memcmp(set2_str, l->data, l->size)) {
663           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
664           exit(EXIT_FAILURE);
665        }
666        l = l->next;
667        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
668           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
669           exit(EXIT_FAILURE);
670        }
671        if (l->size != XSTRLEN(set1_str) || memcmp(set1_str, l->data, l->size)) {
672           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
673           exit(EXIT_FAILURE);
674        }
675     der_sequence_free(l);
676  }
677  static int der_choice_n_custom_test(void)
678  {
679     ltc_asn1_list types[10], host[1], custom[1], root[1], child[1];
680     int boolean[1];
681     unsigned char bitbuf[10], octetbuf[10], ia5buf[10], printbuf[10], outbuf[256], custbuf[256], x, y;
682     wchar_t utf8buf[10];
683     unsigned long integer, oidbuf[10], outlen, custlen, inlen, n;
684     void          *mpinteger;
685     ltc_utctime   utctime = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
686     ltc_generalizedtime gtime = { 2038, 01, 19, 3, 14, 8, 0, 0, 0, 0 };
687     for (x = 0; x < sizeof(bitbuf); x++)   { bitbuf[x]   = x & 1; }
688     for (x = 0; x < sizeof(octetbuf); x++) { octetbuf[x] = x;     }
689     for (x = 0; x < sizeof(ia5buf); x++)   { ia5buf[x]   = 'a';   }
690     for (x = 0; x < sizeof(printbuf); x++) { printbuf[x] = 'a';   }
691     for (x = 0; x < sizeof(utf8buf)/sizeof(utf8buf[0]); x++) { utf8buf[x] = L'a';   }
692     integer = 1;
693     boolean[0] = 1;
694     for (x = 0; x < sizeof(oidbuf)/sizeof(oidbuf[0]); x++)   { oidbuf[x] = x + 1;   }
695     DO(mp_init(&mpinteger));
696     n = sizeof(types)/sizeof(types[0]);
697     for (x = 0; x < n * 2; x++) {
698         y = 0;
699         LTC_SET_ASN1(types, y++, LTC_ASN1_PRINTABLE_STRING, printbuf, sizeof(printbuf));
700         if (x > n) {
701            LTC_SET_ASN1(types, y++, LTC_ASN1_BIT_STRING, bitbuf, sizeof(bitbuf));
702         } else {
703            LTC_SET_ASN1(types, y++, LTC_ASN1_RAW_BIT_STRING, bitbuf, sizeof(bitbuf));
704         }
705         LTC_SET_ASN1(types, y++, LTC_ASN1_OCTET_STRING, octetbuf, sizeof(octetbuf));
706         LTC_SET_ASN1(types, y++, LTC_ASN1_IA5_STRING, ia5buf, sizeof(ia5buf));
707         LTC_SET_ASN1(types, y++, LTC_ASN1_BOOLEAN, boolean, sizeof(boolean)/sizeof(boolean[0]));
708         if (x > n) {
709            LTC_SET_ASN1(types, y++, LTC_ASN1_SHORT_INTEGER, &integer, 1);
710         } else {
711            LTC_SET_ASN1(types, y++, LTC_ASN1_INTEGER, mpinteger, 1);
712         }
713         LTC_SET_ASN1(types, y++, LTC_ASN1_OBJECT_IDENTIFIER, oidbuf, sizeof(oidbuf)/sizeof(oidbuf[0]));
714         if (x > n) {
715            LTC_SET_ASN1(types, y++, LTC_ASN1_UTCTIME, &utctime, 1);
716         } else {
717            LTC_SET_ASN1(types, y++, LTC_ASN1_GENERALIZEDTIME, &gtime, 1);
718         }
719         LTC_SET_ASN1(custom, 0, LTC_ASN1_NULL, NULL, 0);
720         LTC_SET_ASN1_CUSTOM_CONSTRUCTED(types, y++, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0, custom);
721         LTC_SET_ASN1(types, y++, LTC_ASN1_UTF8_STRING, utf8buf, sizeof(utf8buf)/sizeof(utf8buf[0]));
722         LTC_SET_ASN1(host, 0, LTC_ASN1_CHOICE, types, n);
723         outlen = sizeof(outbuf);
724         DO(der_encode_sequence(&types[x % n], 1, outbuf, &outlen));
725         child[0] = types[x % n];
726         if (x < n) {
727            LTC_SET_ASN1_CUSTOM_CONSTRUCTED(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child);
728         } else {
729            LTC_SET_ASN1_CUSTOM_PRIMITIVE(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child->type, child->data, child->size);
730         }
731         custlen = sizeof(custbuf);
732         if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
733            DO(der_encode_custom_type(root, custbuf, &custlen));
734         }
735         inlen = outlen;
736         DO(der_decode_sequence(outbuf, inlen, host, 1));
737         for (y = 0; y < n; y++) {
738             if (types[y].used && y != (x % n)) {
739                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to one\n", y, x);
740                 return 1;
741             }
742             if (!types[y].used && y == (x % n)) {
743                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to zero\n", y, x);
744                 return 1;
745             }
746        }
747        if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
748           DO(der_decode_custom_type(custbuf, custlen, root));
749        }
750    }
751    mp_clear(mpinteger);
752    return 0;
753  }
754  static void s_der_decode_print(const void* p, unsigned long* plen)
755  {
756     ltc_asn1_list *list;
757     DO(der_decode_sequence_flexi(p, plen, &list));
758  #ifdef LTC_DER_TESTS_PRINT_FLEXI
759     fprintf(stderr, "\n\n");
<span onclick='openModal()' class='match'>760     s_der_tests_print_flexi(list, 0);
761     fprintf(stderr, "\n\n");
762  #endif
763     der_sequence_free(list);
</span>764  }
765  static const unsigned char eckey_privc_der[] = {
766    0x30, 0x81, 0xf0, 0x02, 0x01, 0x01, 0x04, 0x18, 0x96, 0x9d, 0x28, 0xf2, 0x40, 0x48, 0x19, 0x11,
767    0x79, 0xb0, 0x47, 0x8e, 0x8c, 0x6b, 0x3d, 0x9b, 0xf2, 0x31, 0x16, 0x10, 0x08, 0x72, 0xb1, 0x86,
768    0xa0, 0x81, 0xb2, 0x30, 0x81, 0xaf, 0x02, 0x01, 0x01, 0x30, 0x24, 0x06, 0x07, 0x2a, 0x86, 0x48,
769    0xce, 0x3d, 0x01, 0x01, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
770    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30,
771    0x4b, 0x04, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
772    0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x04, 0x18, 0x22, 0x12, 0x3d,
773    0xc2, 0x39, 0x5a, 0x05, 0xca, 0xa7, 0x42, 0x3d, 0xae, 0xcc, 0xc9, 0x47, 0x60, 0xa7, 0xd4, 0x62,
774    0x25, 0x6b, 0xd5, 0x69, 0x16, 0x03, 0x15, 0x00, 0xc4, 0x69, 0x68, 0x44, 0x35, 0xde, 0xb3, 0x78,
775    0xc4, 0xb6, 0x5c, 0xa9, 0x59, 0x1e, 0x2a, 0x57, 0x63, 0x05, 0x9a, 0x2e, 0x04, 0x19, 0x02, 0x7d,
776    0x29, 0x77, 0x81, 0x00, 0xc6, 0x5a, 0x1d, 0xa1, 0x78, 0x37, 0x16, 0x58, 0x8d, 0xce, 0x2b, 0x8b,
777    0x4a, 0xee, 0x8e, 0x22, 0x8f, 0x18, 0x96, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
778    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x62, 0xd0, 0x31, 0xc8, 0x3f, 0x42, 0x94, 0xf6, 0x40,
779    0xec, 0x13, 0x02, 0x01, 0x01, 0xa1, 0x1c, 0x03, 0x1a, 0x00, 0x02, 0x55, 0x2c, 0xb8, 0x73, 0x5c,
780    0x9d, 0x98, 0xe4, 0x57, 0xfe, 0xd5, 0x96, 0x0a, 0x73, 0x8d, 0x82, 0xd7, 0xce, 0x05, 0xa9, 0x79,
781    0x91, 0x5c, 0xf9
782  };
783  static const unsigned char eckey_privs_der[] = {
784    0x30, 0x50, 0x02, 0x01, 0x01, 0x04, 0x14, 0x82, 0xef, 0x42, 0x0b, 0xc7, 0xe2, 0x9f, 0x3a, 0x84,
785    0xe5, 0x74, 0xec, 0x9c, 0xc5, 0x10, 0x26, 0x63, 0x8d, 0xb5, 0x46, 0xa0, 0x07, 0x06, 0x05, 0x2b,
786    0x81, 0x04, 0x00, 0x09, 0xa1, 0x2c, 0x03, 0x2a, 0x00, 0x04, 0xb5, 0xb1, 0x5a, 0xb0, 0x2a, 0x10,
787    0xd1, 0xf5, 0x4d, 0x6a, 0x41, 0xde, 0xcd, 0x69, 0x09, 0xb3, 0x5f, 0x26, 0xb0, 0xa2, 0xaf, 0xd3,
788    0x02, 0x89, 0x5e, 0xd4, 0x96, 0x5c, 0xbc, 0x2a, 0x7e, 0x75, 0x85, 0x86, 0x29, 0xb3, 0x29, 0x13,
789    0x77, 0xc3
790  };
791  static void der_custom_test(void)
792  {
793     ltc_asn1_list bool_ean[1], seq1[1], custom[1];
794     int boolean;
795     unsigned long len;
796     unsigned char buf[1024];
797     unsigned char buf1[] = { 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
798     unsigned char buf2[] = { 0x30, 0x08, 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
799     boolean = 0x1;
800     LTC_SET_ASN1(bool_ean, 0, LTC_ASN1_BOOLEAN, &boolean, 1);
801     LTC_SET_ASN1(seq1, 0, LTC_ASN1_SEQUENCE, bool_ean, 1);
802     LTC_SET_ASN1_CUSTOM_CONSTRUCTED(custom, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x1000, seq1);
803     DO(der_length_custom_type(custom, &len, NULL));
804     len = sizeof(buf);
805     DO(der_encode_custom_type(custom, buf, &len));
806     s_der_decode_print(buf, &len);
807     boolean = 0x0;
808     DO(der_decode_custom_type(buf, len, custom));
809     DO(der_length_sequence(custom, 1, &len));
810     len = sizeof(buf);
811     DO(der_encode_sequence(custom, 1, buf, &len));
812     s_der_decode_print(buf, &len);
813     boolean = 0x0;
814     DO(der_decode_sequence(buf, len, custom, 1));
815     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
816     DO(der_length_custom_type(bool_ean, &len, NULL));
817     len = sizeof(buf);
818     DO(der_encode_custom_type(bool_ean, buf, &len));
819     s_der_decode_print(buf, &len);
820     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
821     DO(der_decode_custom_type(buf, len, bool_ean));
822     len = sizeof(buf1);
823     s_der_decode_print(buf1, &len);
824     len = sizeof(buf2);
825     s_der_decode_print(buf2, &len);
826     len = sizeof(eckey_privc_der);
827     s_der_decode_print(eckey_privc_der, &len);
828     len = sizeof(eckey_privs_der);
829     s_der_decode_print(eckey_privs_der, &len);
830  }
831  typedef int (*s_der_Xcode)(const void*, unsigned long, void*, unsigned long*);
832  typedef struct {
833     s_der_Xcode encode;
834     s_der_Xcode decode;
835     const void* in;
836     size_t in_sz;
837     size_t factor;
838     size_t type_sz;
839     const char* what;
840  } der_Xcode_t;
841  static void der_Xcode_run(const der_Xcode_t* x)
842  {
843     unsigned long l1, l2, sz;
844     void *d1, *d2;
845     l1 = 1;
846     d1 = XMALLOC(l1 * x->type_sz);
847     sz = (x->in_sz * x->factor)/x->type_sz;
848     if (x->encode(x->in, sz, d1, &l1) == CRYPT_BUFFER_OVERFLOW) {
849        d1 = XREALLOC(d1, l1 * x->type_sz);
850     }
851     DO(x->encode(x->in, sz, d1, &l1));
852     l2 = 1;
853     d2 = XMALLOC(l2 * x->type_sz);
854     while (x->decode(d1, l1, d2, &l2) == CRYPT_BUFFER_OVERFLOW) {
855        d2 = XREALLOC(d2, l2 * x->type_sz);
856     }
857     DO(x->decode(d1, l1, d2, &l2));
858     DO(do_compare_testvector(d2, (l2/x->factor) * x->type_sz, x->in, x->in_sz, x->what, __LINE__));
859     XFREE(d2);
860     XFREE(d1);
861  }
862  #if defined(_MSC_VER)
863  #define typeof(x) x
864  #endif
865  #define DER_XCODE_X(n, b, x) {  \
866        (s_der_Xcode)der_encode_ ## n,    \
867        (s_der_Xcode)der_decode_ ## n,    \
868        b,                   \
869        sizeof(b),           \
870        x,                   \
871        sizeof(typeof(b[0])),\
872        #n                   \
873  }
874  #define DER_XCODE(n, b) DER_XCODE_X(n, b, 1)
875  static void der_Xcode_test(void)
876  {
877     unsigned long i;
878     ltc_asn1_list *list;
879     ltc_asn1_list ttex_neg_int[2];
880     unsigned char buf[128];
881     void* mpinteger;
882     const unsigned long oid[3] = { 1, 23, 42 };
883     const unsigned char bit_string[] = { 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1 };
884     const unsigned char multi_buf[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
885     const char multi_string[] = {'l','i','b','t','o','m','c','r','y','p','t'};
886     const wchar_t wchar_string[] = L"libtomcrypt";
887     const unsigned char teletex_neg_int[] = {   0x30, 0x11, 0x14, 0x0b, 0x6c, 0x69, 0x62, 0x74,
888                                                 0x6f, 0x6d, 0x63, 0x72, 0x79, 0x70, 0x74, 0x02,
889                                                 0x02, 0xfc, 0x19 };
890     const der_Xcode_t xcode_tests[] =
891     {
892      DER_XCODE(bit_string, bit_string),
893      DER_XCODE_X(raw_bit_string, multi_buf, 8),
894      DER_XCODE(octet_string, multi_buf),
895      DER_XCODE(object_identifier, oid),
896      DER_XCODE(ia5_string, multi_string),
897      DER_XCODE(printable_string, multi_string),
898      DER_XCODE(utf8_string, wchar_string),
899     };
900     for (i = 0; i < sizeof(xcode_tests)/sizeof(xcode_tests[0]); ++i) {
901        der_Xcode_run(&xcode_tests[i]);
902     }
903     i = sizeof(teletex_neg_int);
904     DO(der_decode_sequence_flexi(teletex_neg_int, &i, &list));
905  #ifdef LTC_DER_TESTS_PRINT_FLEXI
906     fprintf(stderr, "\n\n");
907     s_der_tests_print_flexi(list, 0);
908     fprintf(stderr, "\n\n");
909  #endif
910     if (list->child == NULL || list->child->next == NULL)
911        exit(EXIT_FAILURE);
912     ttex_neg_int[0] = *list->child->next;
913     i = sizeof(buf);
914     DO(der_encode_sequence(ttex_neg_int, 1, buf, &i));
915     der_sequence_free(list);
916     DO(mp_init(&mpinteger));
917     LTC_SET_ASN1(ttex_neg_int, 0, LTC_ASN1_TELETEX_STRING, buf, sizeof(buf));
918     LTC_SET_ASN1(ttex_neg_int, 1, LTC_ASN1_INTEGER, mpinteger, 1);
919     DO(der_decode_sequence(teletex_neg_int, sizeof(teletex_neg_int), ttex_neg_int, 2));
920     mp_clear(mpinteger);
921  }
922  #ifdef LTC_TEST_READDIR
923  static int s_der_decode_sequence_flexi(const void *in, unsigned long inlen, void* ctx)
924  {
925     ltc_asn1_list** list = ctx;
926     if (der_decode_sequence_flexi(in, &inlen, list) == CRYPT_OK) {
927  #ifdef LTC_DER_TESTS_PRINT_FLEXI
928        fprintf(stderr, "\n\n");
929        s_der_tests_print_flexi(*list, 0);
930        fprintf(stderr, "\n\n");
931  #endif
932        der_sequence_free(*list);
933     }
934     return CRYPT_OK;
935  }
936  #endif
937  static void s_der_regression_test(void)
938  {
939     static const unsigned char s_broken_sequence[] = {
940       0x30,0x41,0x02,0x84,0x7f,0xff,0xff,0xff,0x1e,0x41,0xb4,0x79,0xad,0x57,0x69,
941       0x05,0xb9,0x60,0xfe,0x14,0xea,0xdb,0x91,0xb0,0xcc,0xf3,0x48,0x43,0xda,0xb9,
942       0x16,0x17,0x3b,0xb8,0xc9,0xcd,0x02,0x1d,0x00,0xad,0xe6,0x59,0x88,0xd2,0x37,
943       0xd3,0x0f,0x9e,0xf4,0x1d,0xd4,0x24,0xa4,0xe1,0xc8,0xf1,0x69,0x67,0xcf,0x33,
944       0x65,0x81,0x3f,0xe8,0x78,0x62,0x36
945     };
946     static const unsigned char s_addtl_bytes[] = {
947       0x30,0x45,0x02,0x21,0x00,0xb7,0xba,0xba,0xe9,0x33,0x2b,0x54,0xb8,0xa3,0xa0,0x5b,0x70,0x04,0x57,
948       0x98,0x21,0xa8,0x87,0xa1,0xb2,0x14,0x65,0xf7,0xdb,0x8a,0x3d,0x49,0x1b,0x39,0xfd,0x2c,0x3f,0x02,
949       0x20,0x74,0x72,0x91,0xdd,0x2f,0x3f,0x44,0xaf,0x7a,0xce,0x68,0xea,0x33,0x43,0x1d,0x6f,0x94,0xe4,
950       0x18,0xc1,0x06,0xa6,0xe7,0x62,0x85,0xcd,0x59,0xf4,0x32,0x60,0xec,0xce,0x00,0x00
951     };
952     static const unsigned char issue_507[] = "\x30\x04"           &bsol;* Start DER-sequence of length 4 */
953                                              "\x0c\x02\xbf\xbf"   &bsol;* Start UTF8 string of actual length 2 and evaluated length 3 */
954                                              "\xaa"               &bsol;* One byte padding */
955                                              "\x04\x82\xff\xff";  &bsol;* Start OCTET sequence of length 0xffff */
956     unsigned long len;
957     void *x, *y;
958     ltc_asn1_list seq[2];
959     ltc_asn1_list *l;
960     mp_init_multi(&x, &y, LTC_NULL);
961     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
962     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
963     SHOULD_FAIL(der_decode_sequence(s_broken_sequence, sizeof(s_broken_sequence), seq, 2));
964     mp_cleanup_multi(&y, &x, LTC_NULL);
965     len = sizeof(s_broken_sequence);
966     mp_init_multi(&x, &y, LTC_NULL);
967     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
968     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
969     SHOULD_FAIL_WITH(der_decode_sequence(s_addtl_bytes, sizeof(s_addtl_bytes), seq, 2), CRYPT_INPUT_TOO_LONG);
970     mp_cleanup_multi(&y, &x, LTC_NULL);
971     len = sizeof(s_addtl_bytes);
972     s_der_decode_print(s_addtl_bytes, &len);
973     len = sizeof(issue_507);
974     SHOULD_FAIL(der_decode_sequence_flexi(issue_507, &len, &l));
975  }
976  static void der_toolong_test(void)
977  {
978     int n, err, failed = 0;
979     ltc_asn1_list *list;
980     unsigned long len, oid[16];
981     unsigned char buf5[5], buf12[12], buf32[32];
982     static const unsigned char invalid1[] = {
983           0x30,0x19, &bsol;* SEQUENCE len=25 bytes */
984                0x30,0x0a, &bsol;* SEQUENCE len=10 bytes (which is wrong, should be 9) */
985                     0x04,0x05, &bsol;* OCTET STRING len=5 */ 0x2b,0x0e,0x03,0x02,0x1a,
986                     0x05,0x00, &bsol;* NULL */
987                0x04,0x0c, &bsol;* OCTET STRING len=12 */ 0xf7,0xff,0x9e,0x8b,0x7b,0xb2,0xe0,0x9b,0x70,0x93,0x5a,0x5d,
988     };
989     static const unsigned char invalid2[] = {
990           0x30,0x0d, &bsol;* SEQUENCE len=13 bytes*/
991                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
992                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
993           0x00,0x00 &bsol;* garbage after the sequence, der_decode_sequence_flexi should ignore this */
994     };
995     static const unsigned char invalid3[] = {
996           0x30,0x0f, &bsol;* SEQUENCE len=15 bytes*/
997                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
998                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
999                0x00,0x00  &bsol;* garbage inside the sequence */
1000     };
1001     static const unsigned char invalid4[] = {
1002           0x30, 0x30,
1003                 0x30, 0x0d,
1004                       0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1005                       0x05, 0x00,
1006                 0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c,
1007                             0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25
1008     };
1009     static const unsigned char invalid5[] = {
1010            0x30, 0x31,
1011                  0x30, 0x0e,
1012                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1013                        0x05, 0x00,
1014                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1015                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1016     };
1017     static const unsigned char invalid6[] = {
1018            0x30, 0x31,
1019                  0x30, 0x0c,
1020                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1021                        0x05, 0x00,
1022                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1023                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1024     };
1025     ltc_asn1_list seqsub[2], seqoid[2], seqmain[2], seqint[2];
1026     void *int1, *int2;
1027     LTC_SET_ASN1(seqsub,  0, LTC_ASN1_OCTET_STRING, buf5,   5);
1028     LTC_SET_ASN1(seqsub,  1, LTC_ASN1_NULL,         NULL,   0);
1029     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,     seqsub, 2);
1030     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING, buf12,  12);
1031     n = 1;
1032     len = sizeof(invalid1);
1033     err = der_decode_sequence_strict(invalid1, len, seqmain, 2);
1034     if (err == CRYPT_OK) {
1035        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1036        failed = 1;
1037     }
1038     len = sizeof(invalid1);
1039     err = der_decode_sequence_flexi(invalid1, &len, &list);
1040     if (err == CRYPT_OK) {
1041        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1042        failed = 1;
1043        der_sequence_free(list);
1044     }
1045     mp_init_multi(&int1, &int2, LTC_NULL);
1046     LTC_SET_ASN1(seqint,  0, LTC_ASN1_INTEGER,      int1,   1);
1047     LTC_SET_ASN1(seqint,  1, LTC_ASN1_INTEGER,      int2,   1);
1048     n++;
1049     len = sizeof(invalid2);
1050     err = der_decode_sequence_strict(invalid2, len, seqint, 2);
1051     if (err == CRYPT_OK) {
1052        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1053        failed = 1;
1054     }
1055     len = sizeof(invalid2);
1056     err = der_decode_sequence_flexi(invalid2, &len, &list);
1057     if (err != CRYPT_OK || len != 15) {
1058        fprintf(stderr,"der_decode_sequence_flexi failed, err=%d (expected 0) len=%lu (expected 15)\n", err, len);
1059        failed = 1;
1060     }
1061     if (err == CRYPT_OK)
1062        der_sequence_free(list);
1063     n++;
1064     len = sizeof(invalid3);
1065     err = der_decode_sequence_strict(invalid3, len, seqint, 2);
1066     if (err == CRYPT_OK) {
1067        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1068        failed = 1;
1069     }
1070     len = sizeof(invalid3);
1071     err = der_decode_sequence_flexi(invalid3, &len, &list);
1072     if (err == CRYPT_OK) {
1073        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1074        failed = 1;
1075        der_sequence_free(list);
1076     }
1077     mp_clear_multi(int1, int2, LTC_NULL);
1078     LTC_SET_ASN1(seqoid,  0, LTC_ASN1_OBJECT_IDENTIFIER, oid, sizeof(oid)/sizeof(oid[0]));
1079     LTC_SET_ASN1(seqoid,  1, LTC_ASN1_NULL,              NULL,   0);
1080     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,          seqoid, 2);
1081     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING,      buf32,  32);
1082     n++;
1083     len = sizeof(invalid4);
1084     err = der_decode_sequence_strict(invalid4, len, seqmain, 2);
1085     if (err == CRYPT_OK) {
1086        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1087        failed = 1;
1088     }
1089     len = sizeof(invalid4);
1090     err = der_decode_sequence_flexi(invalid4, &len, &list);
1091     if (err == CRYPT_OK) {
1092        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1093        failed = 1;
1094        der_sequence_free(list);
1095     }
1096     n++;
1097     len = sizeof(invalid5);
1098     err = der_decode_sequence_strict(invalid5, len, seqmain, 2);
1099     if (err == CRYPT_OK) {
1100        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1101        failed = 1;
1102     }
1103     len = sizeof(invalid5);
1104     err = der_decode_sequence_flexi(invalid5, &len, &list);
1105     if (err == CRYPT_OK) {
1106        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1107        failed = 1;
1108        der_sequence_free(list);
1109     }
1110     n++;
1111     len = sizeof(invalid6);
1112     err = der_decode_sequence_strict(invalid6, len, seqmain, 2);
1113     if (err == CRYPT_OK) {
1114        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1115        failed = 1;
1116     }
1117     len = sizeof(invalid6);
1118     err = der_decode_sequence_flexi(invalid6, &len, &list);
1119     if (err == CRYPT_OK) {
1120        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1121        failed = 1;
1122        der_sequence_free(list);
1123     }
1124     if (failed) exit(EXIT_FAILURE);
1125  }
1126  static void s_der_recursion_limit(void)
1127  {
1128     unsigned int n, m;
1129     unsigned long integer = 123, s;
1130     ltc_asn1_list seqs[LTC_DER_MAX_RECURSION + 2], dummy[1], *flexi;
1131     unsigned char buf[2048];
1132     for (m = 0; m < 3; ++m) {
1133        LTC_SET_ASN1(dummy, 0, LTC_ASN1_SHORT_INTEGER, &integer, 1);
1134        LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION + 1, LTC_ASN1_SEQUENCE, dummy, 1);
1135        for (n = m; n < LTC_DER_MAX_RECURSION + 1; ++n) {
1136           LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION - n, LTC_ASN1_SEQUENCE, &seqs[LTC_DER_MAX_RECURSION - n + 1], 1);
1137        }
1138        s = sizeof(buf);
1139        DO(der_encode_sequence(&seqs[m], 1, buf, &s));
1140        DO(der_decode_sequence(buf, s, &seqs[m], 1));
1141        if (m < 2) {
1142           SHOULD_FAIL(der_decode_sequence_flexi(buf, &s, &flexi));
1143        }
1144        else {
1145           DO(der_decode_sequence_flexi(buf, &s, &flexi));
1146           der_free_sequence_flexi(flexi);
1147        }
1148     }
1149  }
1150  int der_test(void)
1151  {
1152     unsigned long x, y, z, zz, oid[2][32];
1153     unsigned char buf[3][2048];
1154     void *a, *b, *c, *d, *e, *f, *g;
1155     static const unsigned char rsa_oid_der[] = { 0x06, 0x06, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d };
1156     static const unsigned long rsa_oid[]     = { 1, 2, 840, 113549 };
1157     static const unsigned char rsa_ia5[]     = "test1@rsa.com";
1158     static const unsigned char rsa_ia5_der[] = { 0x16, 0x0d, 0x74, 0x65, 0x73, 0x74, 0x31,
1159                                                  0x40, 0x72, 0x73, 0x61, 0x2e, 0x63, 0x6f, 0x6d };
1160     static const unsigned char rsa_printable[] = "Test User 1";
1161     static const unsigned char rsa_printable_der[] = { 0x13, 0x0b, 0x54, 0x65, 0x73, 0x74, 0x20, 0x55,
1162                                                        0x73, 0x65, 0x72, 0x20, 0x31 };
1163     static const ltc_utctime   rsa_time1 = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
1164     static const ltc_utctime   rsa_time2 = { 91, 5, 6, 23, 45, 40, 0, 0, 0 };
1165     ltc_utctime                tmp_time;
1166     static const unsigned char rsa_time1_der[] = { 0x17, 0x11, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x31, 0x36, 0x34, 0x35, 0x34, 0x30, 0x2D, 0x30, 0x37, 0x30, 0x30 };
1167     static const unsigned char rsa_time2_der[] = { 0x17, 0x0d, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x32, 0x33, 0x34, 0x35, 0x34, 0x30, 0x5a };
1168     static const wchar_t utf8_1[]           = { 0x0041, 0x2262, 0x0391, 0x002E };
1169     static const unsigned char utf8_1_der[] = { 0x0C, 0x07, 0x41, 0xE2, 0x89, 0xA2, 0xCE, 0x91, 0x2E };
1170     static const wchar_t utf8_2[]           = { 0xD55C, 0xAD6D, 0xC5B4 };
1171     static const unsigned char utf8_2_der[] = { 0x0C, 0x09, 0xED, 0x95, 0x9C, 0xEA, 0xB5, 0xAD, 0xEC, 0x96, 0xB4 };
1172     static const wchar_t utf8_3[]           = { 0x05E9, 0x05DC, 0x05D5, 0x05DD };
1173     static const unsigned char utf8_3_der[] = { 0x0C, 0x08, 0xD7, 0xA9, 0xD7, 0x9C, 0xD7, 0x95, 0xD7, 0x9D };
1174     unsigned char utf8_buf[32];
1175     wchar_t utf8_out[32];
1176  #ifdef LTC_TEST_READDIR
1177     ltc_asn1_list *list;
1178  #endif
1179     if (ltc_mp.name == NULL) return CRYPT_NOP;
1180     s_der_recursion_limit();
1181     der_Xcode_test();
1182  #ifdef LTC_TEST_READDIR
1183     DO(test_process_dir("tests/asn1", &list, s_der_decode_sequence_flexi, NULL, "DER ASN.1 special cases"));
1184  #endif
1185     der_custom_test();
1186     s_der_regression_test();
1187     der_toolong_test();
1188     der_cacert_test();
1189     s_der_oid_test();
1190     y = 0xffffff00;
1191  #if ULONG_MAX == ULLONG_MAX
1192     y <<= 32;
1193  #endif
1194     while (y != 0) {
1195        x = sizeof(buf[0]);
1196        DO(der_encode_asn1_length(y, buf[0], &x));
1197        x = y + x;
1198        DO(der_decode_asn1_length(buf[0], &x, &z));
1199        if (y != z) {
1200           fprintf(stderr, "Failed to en- or decode length correctly! %lu != %lu\n", y, z);
1201           return 1;
1202        }
1203        y >>= 3;
1204     }
1205     DO(mp_init_multi(&a, &b, &c, &d, &e, &f, &g, LTC_NULL));
1206     for (zz = 0; zz < 16; zz++) {
1207  #ifdef USE_TFM
1208        for (z = 0; z < 256; z++) {
1209  #else
1210        for (z = 0; z < 1024; z++) {
1211  #endif
1212           ENSURE(yarrow_read(buf[0], z, &yarrow_prng) == z);
1213           DO(mp_read_unsigned_bin(a, buf[0], z));
1214           x = sizeof(buf[0]);
1215           DO(der_encode_integer(a, buf[0], &x));
1216           DO(der_length_integer(a, &y));
1217           if (y != x) { fprintf(stderr, "DER INTEGER size mismatch %lu != %lu\n", y, x); return 1; }
1218           mp_set_int(b, 0);
1219           DO(der_decode_integer(buf[0], y, b));
1220           if (y != x || mp_cmp(a, b) != LTC_MP_EQ) {
1221              fprintf(stderr, "%lu: %lu vs %lu\n", z, x, y);
1222              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1223              return 1;
1224           }
1225        }
1226     }
1227     for (zz = 0; zz < 256; zz++) {
1228        for (z = 1; z < 4; z++) {
1229           ENSURE(yarrow_read(buf[2], z, &yarrow_prng) == z);
1230           DO(mp_read_unsigned_bin(a, buf[2], z));
1231           x = sizeof(buf[0]);
1232           DO(der_encode_integer(a, buf[0], &x));
1233           y = sizeof(buf[1]);
1234           DO(der_encode_short_integer(mp_get_int(a), buf[1], &y));
1235           if (x != y || memcmp(buf[0], buf[1], x)) {
1236              fprintf(stderr, "DER INTEGER short encoding failed, %lu, %lu, 0x%lX\n", x, y, mp_get_int(a));
1237              for (zz = 0; zz < z; zz++) fprintf(stderr, "%02x ", buf[2][zz]);
1238              fprintf(stderr, "\n");
1239              for (z = 0; z < x; z++) fprintf(stderr, "%02x ", buf[0][z]);
1240              fprintf(stderr, "\n");
1241              for (z = 0; z < y; z++) fprintf(stderr, "%02x ", buf[1][z]);
1242              fprintf(stderr, "\n");
1243              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1244              return 1;
1245           }
1246           x = 0;
1247           DO(der_decode_short_integer(buf[1], y, &x));
1248           if (x != mp_get_int(a)) {
1249              fprintf(stderr, "DER INTEGER short decoding failed, %lu, %lu\n", x, mp_get_int(a));
1250              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1251              return 1;
1252           }
1253        }
1254     }
1255     mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1256     for (zz = 1; zz < 1536; zz++) {
1257         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1258         for (z = 0; z < zz; z++) {
1259             buf[0][z] &= 0x01;
1260         }
1261         x = sizeof(buf[1]);
1262         DO(der_encode_bit_string(buf[0], zz, buf[1], &x));
1263         DO(der_length_bit_string(zz, &y));
1264         if (y != x) {
1265            fprintf(stderr, "\nDER BIT STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1266            return 1;
1267         }
1268         y = sizeof(buf[2]);
1269         DO(der_decode_bit_string(buf[1], x, buf[2], &y));
1270         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1271            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1272            return 1;
1273         }
1274     }
1275     for (zz = 1; zz < 1536; zz++) {
1276         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1277         x = sizeof(buf[1]);
1278         DO(der_encode_octet_string(buf[0], zz, buf[1], &x));
1279         DO(der_length_octet_string(zz, &y));
1280         if (y != x) {
1281            fprintf(stderr, "\nDER OCTET STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1282            return 1;
1283         }
1284         y = sizeof(buf[2]);
1285         DO(der_decode_octet_string(buf[1], x, buf[2], &y));
1286         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1287            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1288            return 1;
1289         }
1290     }
1291     x = sizeof(buf[0]);
1292     DO(der_encode_object_identifier((unsigned long*)rsa_oid, sizeof(rsa_oid)/sizeof(rsa_oid[0]), buf[0], &x));
1293     if (x != sizeof(rsa_oid_der) || memcmp(rsa_oid_der, buf[0], x)) {
1294        fprintf(stderr, "rsa_oid_der encode failed to match, %lu, ", x);
1295        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1296        fprintf(stderr, "\n");
1297        return 1;
1298     }
1299     y = sizeof(oid[0])/sizeof(oid[0][0]);
1300     DO(der_decode_object_identifier(buf[0], x, oid[0], &y));
1301     if (y != sizeof(rsa_oid)/sizeof(rsa_oid[0]) || memcmp(rsa_oid, oid[0], sizeof(rsa_oid))) {
1302        fprintf(stderr, "rsa_oid_der decode failed to match, %lu, ", y);
1303        for (z = 0; z < y; z++) fprintf(stderr, "%lu ", oid[0][z]);
1304        fprintf(stderr, "\n");
1305        return 1;
1306     }
1307     for (zz = 0; zz < 5000; zz++) {
1308         ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1309         LOAD32L(z, buf[0]);
1310         z = 2 + (z % ((sizeof(oid[0])/sizeof(oid[0][0])) - 2));
1311         oid[0][0] = buf[0][0] % 3;
1312         oid[0][1] = buf[0][1] % 40;
1313         for (y = 2; y < z; y++) {
1314            ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1315            LOAD32L(oid[0][y], buf[0]);
1316         }
1317         x = sizeof(buf[0]);
1318         DO(der_encode_object_identifier(oid[0], z, buf[0], &x));
1319         DO(der_length_object_identifier(oid[0], z, &y));
1320         if (x != y) {
1321            fprintf(stderr, "Random OID %lu test failed, length mismatch: %lu, %lu\n", z, x, y);
1322            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1323            return 1;
1324         }
1325         y = sizeof(oid[0])/sizeof(oid[0][0]);
1326         DO(der_decode_object_identifier(buf[0], x, oid[1], &y));
1327         if (y != z) {
1328            fprintf(stderr, "Random OID %lu test failed, decode length mismatch: %lu, %lu\n", z, x, y);
1329            return 1;
1330         }
1331         if (memcmp(oid[0], oid[1], sizeof(oid[0][0]) * z)) {
1332            fprintf(stderr, "Random OID %lu test failed, decoded values wrong\n", z);
1333            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1334            fprintf(stderr, "\n\n Got \n\n");
1335            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[1][x]);
1336            return 1;
1337         }
1338     }
1339     x = sizeof(buf[0]);
1340     DO(der_encode_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), buf[0], &x));
1341     if (x != sizeof(rsa_ia5_der) || memcmp(buf[0], rsa_ia5_der, x)) {
1342        fprintf(stderr, "IA5 encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_ia5_der));
1343        return 1;
1344     }
1345     DO(der_length_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), &y));
1346     if (y != x) {
1347        fprintf(stderr, "IA5 length failed to match: %lu, %lu\n", x, y);
1348        return 1;
1349     }
1350     y = sizeof(buf[1]);
1351     DO(der_decode_ia5_string(buf[0], x, buf[1], &y));
1352     if (y != XSTRLEN((char*)rsa_ia5) || memcmp(buf[1], rsa_ia5, XSTRLEN((char*)rsa_ia5))) {
1353         fprintf(stderr, "DER IA5 failed test vector\n");
1354         return 1;
1355     }
1356     x = sizeof(buf[0]);
1357     DO(der_encode_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), buf[0], &x));
1358     if (x != sizeof(rsa_printable_der) || memcmp(buf[0], rsa_printable_der, x)) {
1359        fprintf(stderr, "PRINTABLE encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_printable_der));
1360        return 1;
1361     }
1362     DO(der_length_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), &y));
1363     if (y != x) {
1364        fprintf(stderr, "printable length failed to match: %lu, %lu\n", x, y);
1365        return 1;
1366     }
1367     y = sizeof(buf[1]);
1368     DO(der_decode_printable_string(buf[0], x, buf[1], &y));
1369     if (y != XSTRLEN((char*)rsa_printable) || memcmp(buf[1], rsa_printable, XSTRLEN((char*)rsa_printable))) {
1370         fprintf(stderr, "DER printable failed test vector\n");
1371         return 1;
1372     }
1373     x = sizeof(buf[0]);
1374     DO(der_encode_utctime((ltc_utctime*)&rsa_time1, buf[0], &x));
1375     if (x != sizeof(rsa_time1_der) || memcmp(buf[0], rsa_time1_der, x)) {
1376        fprintf(stderr, "UTCTIME encode of rsa_time1 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1377        fprintf(stderr, "\n\n");
1378        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1379        fprintf(stderr, "\n");
1380        return 1;
1381     }
1382     DO(der_length_utctime((ltc_utctime*)&rsa_time1, &y));
1383     if (y != x) {
1384        fprintf(stderr, "UTCTIME length failed to match for rsa_time1: %lu, %lu\n", x, y);
1385        return 1;
1386     }
1387     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1388     if (y != x || memcmp(&rsa_time1, &tmp_time, sizeof(ltc_utctime))) {
1389        fprintf(stderr, "UTCTIME decode failed for rsa_time1: %lu %lu\n", x, y);
1390  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1391  tmp_time.YY,
1392  tmp_time.MM,
1393  tmp_time.DD,
1394  tmp_time.hh,
1395  tmp_time.mm,
1396  tmp_time.ss,
1397  tmp_time.off_dir,
1398  tmp_time.off_mm,
1399  tmp_time.off_hh);
1400        return 1;
1401     }
1402     x = sizeof(buf[0]);
1403     DO(der_encode_utctime((ltc_utctime*)&rsa_time2, buf[0], &x));
1404     if (x != sizeof(rsa_time2_der) || memcmp(buf[0], rsa_time2_der, x)) {
1405        fprintf(stderr, "UTCTIME encode of rsa_time2 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1406        fprintf(stderr, "\n\n");
1407        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1408        fprintf(stderr, "\n");
1409        return 1;
1410     }
1411     DO(der_length_utctime((ltc_utctime*)&rsa_time2, &y));
1412     if (y != x) {
1413        fprintf(stderr, "UTCTIME length failed to match for rsa_time2: %lu, %lu\n", x, y);
1414        return 1;
1415     }
1416     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1417     if (y != x || memcmp(&rsa_time2, &tmp_time, sizeof(ltc_utctime))) {
1418        fprintf(stderr, "UTCTIME decode failed for rsa_time2: %lu %lu\n", x, y);
1419  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1420  tmp_time.YY,
1421  tmp_time.MM,
1422  tmp_time.DD,
1423  tmp_time.hh,
1424  tmp_time.mm,
1425  tmp_time.ss,
1426  tmp_time.off_dir,
1427  tmp_time.off_mm,
1428  tmp_time.off_hh);
1429        return 1;
1430     }
1431       x = sizeof(utf8_buf);
1432       DO(der_encode_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), utf8_buf, &x));
1433       DO(der_length_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), &y));
1434       if (x != sizeof(utf8_1_der) || memcmp(utf8_buf, utf8_1_der, x) || x != y) {
1435          fprintf(stderr, "DER UTF8_1 encoded to %lu bytes\n", x);
1436          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1437          fprintf(stderr, "\n");
1438          return 1;
1439       }
1440       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1441       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1442       if (y != (sizeof(utf8_1) / sizeof(utf8_1[0])) || memcmp(utf8_1, utf8_out, y * sizeof(wchar_t))) {
1443          fprintf(stderr, "DER UTF8_1 decoded to %lu wchar_t\n", y);
1444          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1445          fprintf(stderr, "\n");
1446          return 1;
1447       }
1448       x = sizeof(utf8_buf);
1449       DO(der_encode_utf8_string(utf8_2, sizeof(utf8_2) / sizeof(utf8_2[0]), utf8_buf, &x));
1450       if (x != sizeof(utf8_2_der) || memcmp(utf8_buf, utf8_2_der, x)) {
1451          fprintf(stderr, "DER UTF8_2 encoded to %lu bytes\n", x);
1452          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1453          fprintf(stderr, "\n");
1454          return 1;
1455       }
1456       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1457       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1458       if (y != (sizeof(utf8_2) / sizeof(utf8_2[0])) || memcmp(utf8_2, utf8_out, y * sizeof(wchar_t))) {
1459          fprintf(stderr, "DER UTF8_2 decoded to %lu wchar_t\n", y);
1460          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1461          fprintf(stderr, "\n");
1462          return 1;
1463       }
1464       x = sizeof(utf8_buf);
1465       DO(der_encode_utf8_string(utf8_3, sizeof(utf8_3) / sizeof(utf8_3[0]), utf8_buf, &x));
1466       if (x != sizeof(utf8_3_der) || memcmp(utf8_buf, utf8_3_der, x)) {
1467          fprintf(stderr, "DER UTF8_3 encoded to %lu bytes\n", x);
1468          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1469          fprintf(stderr, "\n");
1470          return 1;
1471       }
1472       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1473       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1474       if (y != (sizeof(utf8_3) / sizeof(utf8_3[0])) || memcmp(utf8_3, utf8_out, y * sizeof(wchar_t))) {
1475          fprintf(stderr, "DER UTF8_3 decoded to %lu wchar_t\n", y);
1476          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1477          fprintf(stderr, "\n");
1478          return 1;
1479       }
1480     der_set_test();
1481     der_flexi_test();
1482     return der_choice_n_custom_test();
1483  }
1484  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</h3>
            <pre><code>1  #include <tomcrypt_test.h>
2  #if !defined(LTC_DER)
3  int der_test(void)
4  {
5     return CRYPT_NOP;
6  }
7  #else
8  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 2
9  #define LTC_DER_TESTS_PRINT_FLEXI
10  #endif
11  static const char s_der_tests_stinky_root_cert[] =
12     "MIIFETCCA/mgAwIBAgIQbv53JNmv518t5lkCHE272jANBgkqhkiG9w0BAQUFADCB"
13     "lTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug"
14     "Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho"
15     "dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHTAbBgNVBAMTFFVUTi1VU0VSRmlyc3Qt"
16     "T2JqZWN0MB4XDTA4MDQyOTAwMDAwMFoXDTEwMDQyOTIzNTk1OVowgbUxCzAJBgNV"
17     "BAYTAlVTMQ4wDAYDVQQRDAU0NDE0MzELMAkGA1UECAwCT0gxGTAXBgNVBAcMEE1h"
18     "eWZpZWxkIFZpbGxhZ2UxEDAOBgNVBAkMB1N1aXRlIEExFDASBgNVBAkMCzc2NyBC"
19     "ZXRhIERyMSIwIAYDVQQKDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMSIwIAYD"
20     "VQQDDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMIIBIjANBgkqhkiG9w0BAQEF"
21     "AAOCAQ8AMIIBCgKCAQEAzH7ZBkMcBuHx8d2f10RGTHAf7gzzVteGbOihJGH2BwlS"
22     "ZvNp6WEE4DfL+s1vp0wzk1XeLN5tRjg2qum9YqyCk7okh7pXGy46f5mWbLQiefGA"
23     "j5UXRcr6WJ3xeACdbXxKrYMV0REia+4Jb2UbFA8S81PjhRon6vcRz76ziUWwt8NC"
24     "igX+4ZC0skhhKzKszel6KGL7bJCtLG7ukw9DZCrvPCRcKFeM/GwQ6ACMgP88CSCL"
25     "t1fbIXDH1vd/x2XM3QlaSDN6hYDbef8m1T+9TCkXVKeqG1GYjSUrHzYnCZUmTRrR"
26     "38jgC3qXxiIpDKW105uM0nlXe2XF9c+ot2MdWvV4TwIDAQABo4IBOTCCATUwHwYD"
27     "VR0jBBgwFoAU2u1kdBScFDyr3ZmpvVsoTYs8ydgwHQYDVR0OBBYEFK+1HzZE4i28"
28     "oLIzuqlFR9SspiCIMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMBMGA1Ud"
29     "JQQMMAoGCCsGAQUFBwMDMBEGCWCGSAGG+EIBAQQEAwIEEDBGBgNVHSAEPzA9MDsG"
30     "DCsGAQQBsjEBAgEDAjArMCkGCCsGAQUFBwIBFh1odHRwczovL3NlY3VyZS5jb21v"
31     "ZG8ubmV0L0NQUzBCBgNVHR8EOzA5MDegNaAzhjFodHRwOi8vY3JsLnVzZXJ0cnVz"
32     "dC5jb20vVVROLVVTRVJGaXJzdC1PYmplY3QuY3JsMCEGA1UdEQQaMBiBFnN1cHBv"
33     "cnRAcHJlZW1wdGl2ZS5jb20wDQYJKoZIhvcNAQEFBQADggEBAC+JM26Dokvonudl"
34     "JXe/Yun7IBhimkagZUjbk9l/GQWN6i+v1o95UJ1wGJtBdm2+MxbSaPoNTDZR4B+2"
35     "lYL9MW57UVmePrnfUPXQKZZG+8gTRDz8+7ol/CEAKmS3MLKCRcH5oe+J5345sGxi"
36     "FC/KWNKedTNraW95xlg8NTlL2yRP7TMsjvBxgLmkbaFUoXzPTbQWmtovIagIT8GC"
37     "JeXwdFaRjbamiz3Irl+u7x/mhxdza6RvgBYylXRFMudANpeGsV7gDXlnfzpFDKHQ"
38     "niVwB7P5sbPFIlmIc+4/xRItkLIRjCVXaepgN9KYu3VOgiSDI6wXiTwP44/LUXQM"
39     "hetwa7s=";
40  const char ltc_der_tests_cacert_root_cert[] =
41     "MIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290"
42     "IENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB"
43     "IENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA"
44     "Y2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO"
45     "BgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi"
46     "MCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ"
47     "ARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC"
48     "CgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ"
49     "8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6"
50     "zWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y"
51     "fk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7"
52     "w2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc"
53     "G8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k"
54     "epKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q"
55     "laegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ"
56     "QUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU"
57     "fslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826"
58     "YreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w"
59     "ggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY"
60     "gBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe"
61     "MBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0"
62     "IFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy"
63     "dC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw"
64     "czovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0"
65     "dHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl"
66     "aHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC"
67     "AQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg"
68     "b3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB"
69     "ACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc"
70     "nWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg"
71     "18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c"
72     "gr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl"
73     "Jzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY"
74     "sONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T"
75     "SCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF"
76     "CpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum"
77     "GCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk"
78     "zk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW"
79     "omTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD";
80  const unsigned long ltc_der_tests_cacert_root_cert_size = sizeof(ltc_der_tests_cacert_root_cert);
81  #define ASN1_FMTSTRING_FMT "line: %d, type=%d, size=%lu, data=%p, self=%p, next=%p, prev=%p, parent=%p, child=%p"
82  #define ASN1_FMTSTRING_VAL(l)  __LINE__, (l)->type, (l)->size, (l)->data, (l), (l)->next, (l)->prev, (l)->parent, (l)->child
83  #define ASN1_ERR(l) fprintf(stderr, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l)); \
84      exit(EXIT_FAILURE)
85  #define CHECK_ASN1_HAS(l, w) do { if ((l)->w == NULL) { \
86      ASN1_ERR(l);\
87  } } while(0)
88  #define CHECK_ASN1_HAS_NO(l, w) do { if ((l)->w != NULL) { \
89      ASN1_ERR(l);\
90  } } while(0)
91  #define CHECK_ASN1_TYPE(l, t) do { if ((l)->type != (t)) { \
92      ASN1_ERR(l);\
93  } } while(0)
94  #define CHECK_ASN1_HAS_CHILD(l) CHECK_ASN1_HAS(l, child)
95  #define CHECK_ASN1_HAS_NO_CHILD(l) CHECK_ASN1_HAS_NO(l, child)
96  #define CHECK_ASN1_HAS_NEXT(l) CHECK_ASN1_HAS(l, next)
97  #define CHECK_ASN1_HAS_NO_NEXT(l) CHECK_ASN1_HAS_NO(l, next)
98  #define CHECK_ASN1_HAS_DATA(l) CHECK_ASN1_HAS(l, data)
99  #define CHECK_ASN1_HAS_NO_DATA(l) CHECK_ASN1_HAS_NO(l, data)
100  #ifdef LTC_DER_TESTS_PRINT_FLEXI
101  static void* s_xmalloc(int l)
102  {
103     void *r = XMALLOC(l);
104  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
105     fprintf(stderr, "ALLOC %9d to %p\n", l, r);
106  #endif
107     if (!r) {
108        fprintf(stderr, "Could not allocate %d bytes of memory\n", l);
109        exit(EXIT_FAILURE);
110     }
111     return r;
112  }
113  static void s_free(void *p)
114  {
115  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
116     fprintf(stderr, "FREE %p\n", p);
117  #endif
118     XFREE(p);
119  }
120  static void s_der_tests_print_flexi(ltc_asn1_list* l, unsigned int level)
121  {
122    char *buf = NULL;
123    const char* name = NULL;
124    const char* text = NULL;
125    ltc_asn1_list* ostring = NULL;
126    unsigned int n;
127    int slen;
128    switch (l->type)
129      {
130    case LTC_ASN1_EOL:
131      name = "EOL";
132      slen = snprintf(NULL, 0, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
133      buf = s_xmalloc(slen);
134      slen = snprintf(buf, slen, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
135      text = buf;
136      break;
137    case LTC_ASN1_BOOLEAN:
138      name = "BOOLEAN";
139      {
140        if (*(int*)l->data)
141          text = "true";
142        else
143          text = "false";
144      }
145      break;
146    case LTC_ASN1_INTEGER:
147      name = "INTEGER";
148      buf = s_xmalloc(((mp_get_digit_count(l->data) + 1) * ltc_mp.bits_per_digit) / 3);
149      mp_toradix(l->data, buf, 10);
150      text = buf;
151      break;
152    case LTC_ASN1_SHORT_INTEGER:
153      name = "SHORT INTEGER";
154      break;
155    case LTC_ASN1_BIT_STRING:
156      name = "BIT STRING";
157      break;
158    case LTC_ASN1_OCTET_STRING:
159      name = "OCTET STRING";
160      {
161        unsigned long ostring_l = l->size;
162        if (der_decode_sequence_flexi(l->data, &ostring_l, &ostring) == CRYPT_OK) {
163            text = "";
164        } else {
165            int r;
166            int sz = l->size * 2 + 1;
167            char* s = buf = s_xmalloc(sz);
168            for (n = 0; n < l->size; ++n) {
169                r = snprintf(s, sz, "%02X", ((unsigned char*)l->data)[n]);
170                if (r < 0 || r >= sz) {
171                    fprintf(stderr, "%s boom\n", name);
172                    exit(EXIT_FAILURE);
173                }
174                s += r;
175                sz -= r;
176            }
177            text = buf;
178        }
179      }
180      break;
181    case LTC_ASN1_NULL:
182      name = "NULL";
183      text = "";
184      break;
185    case LTC_ASN1_OBJECT_IDENTIFIER:
186      name = "OBJECT IDENTIFIER";
187      {
188        unsigned long len = 0;
189        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_BUFFER_OVERFLOW) {
190          fprintf(stderr, "%s WTF\n", name);
191          exit(EXIT_FAILURE);
192        }
193        buf = s_xmalloc(len);
194        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_OK) {
195          fprintf(stderr, "%s boom\n", name);
196          exit(EXIT_FAILURE);
197        }
198        text = buf;
199      }
200      break;
201    case LTC_ASN1_IA5_STRING:
202      name = "IA5 STRING";
203      text = l->data;
204      break;
205    case LTC_ASN1_PRINTABLE_STRING:
206      name = "PRINTABLE STRING";
207      text = l->data;
208      break;
209    case LTC_ASN1_UTF8_STRING:
210      name = "UTF8 STRING";
211      break;
212    case LTC_ASN1_UTCTIME:
213      name = "UTCTIME";
214      {
215        ltc_utctime* ut = l->data;
216        slen = 32;
217        buf = s_xmalloc(slen);
218        snprintf(buf, slen, "%02d-%02d-%02d %02d:%02d:%02d %c%02d:%02d",
219            ut->YY, ut->MM, ut->DD, ut->hh, ut->mm, ut->ss,
220            ut->off_dir ? '-' : '+', ut->off_hh, ut->off_mm);
221        text = buf;
222      }
223      break;
224    case LTC_ASN1_GENERALIZEDTIME:
225      name = "GENERALIZED TIME";
226      {
227        ltc_generalizedtime* gt = l->data;
228        slen = 32;
229        buf = s_xmalloc(slen);
230        if(gt->fs)
231           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02d.%02dZ",
232            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss, gt->fs);
233        else
234           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02dZ",
235            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss);
236        text = buf;
237      }
238      break;
239    case LTC_ASN1_CHOICE:
240      name = "CHOICE";
241      break;
242    case LTC_ASN1_SEQUENCE:
243      name = "SEQUENCE";
244      text = "";
245      break;
246    case LTC_ASN1_SET:
247      name = "SET";
248      text = "";
249      break;
250    case LTC_ASN1_SETOF:
251      name = "SETOF";
252      text = "";
253      break;
254    case LTC_ASN1_RAW_BIT_STRING:
255      name = "RAW BIT STRING";
256      break;
257    case LTC_ASN1_TELETEX_STRING:
258      name = "TELETEX STRING";
259      text = l->data;
260      break;
261    case LTC_ASN1_CUSTOM_TYPE:
262      name = "NON STANDARD";
263      {
264         int r;
265         int sz = 128;
266         char* s = buf = s_xmalloc(sz);
267         r = snprintf(s, sz, "[%s %s %llu]", der_asn1_class_to_string_map[l->klass], der_asn1_pc_to_string_map[l->pc], l->tag);
268         if (r < 0 || r >= sz) {
269             fprintf(stderr, "%s boom\n", name);
270             exit(EXIT_FAILURE);
271         }
272         s += r;
273         sz -= r;
274         text = buf;
275      }
276      break;
277    }
278    for (n = 0; n < level; ++n) {
279       fprintf(stderr, "    ");
280    }
281    if (name) {
282        if (text)
283           fprintf(stderr, "%s %s\n", name, text);
284        else
285           fprintf(stderr, "%s <missing decoding>\n", name);
286    }
287    else
288       fprintf(stderr, "WTF type=%i\n", l->type);
289    if (buf) {
290       s_free(buf);
291       buf = NULL;
292    }
293    if (ostring) {
294        s_der_tests_print_flexi(ostring, level + 1);
295        der_free_sequence_flexi(ostring);
296    }
297    if (l->child)
298      s_der_tests_print_flexi(l->child, level + 1);
299    if (l->next)
300      s_der_tests_print_flexi(l->next, level);
301  }
302  #endif
303  static void der_cacert_test(void)
304  {
305    unsigned char buf[sizeof(ltc_der_tests_cacert_root_cert)];
306    unsigned long len1 = sizeof(buf), len2;
307    ltc_asn1_list *decoded_list, *l, *l1, *l2;
308    DO(base64_decode(s_der_tests_stinky_root_cert, sizeof(s_der_tests_stinky_root_cert), buf, &len1));
309    len2 = len1;
310    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
311    der_free_sequence_flexi(decoded_list);
312    len1 = sizeof(buf);
313    DO(base64_decode(ltc_der_tests_cacert_root_cert, sizeof(ltc_der_tests_cacert_root_cert), buf, &len1));
314    len2 = len1;
315    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
316    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
317    CHECK_ASN1_HAS_DATA(decoded_list);
318    der_sequence_shrink(decoded_list);
319    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
320    CHECK_ASN1_HAS_NO_DATA(decoded_list);
321  #ifdef LTC_DER_TESTS_PRINT_FLEXI
322    printf("\n\n--- test print start ---\n\n");
323    s_der_tests_print_flexi(decoded_list, 0);
324    printf("\n\n--- test print end ---\n\n");
325  #endif
326    l = decoded_list;
327    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
328    CHECK_ASN1_HAS_CHILD(l);
329    CHECK_ASN1_HAS_NO_NEXT(l);
330    l = l->child;
331    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
332    CHECK_ASN1_HAS_CHILD(l);
333    CHECK_ASN1_HAS_NEXT(l);
334    l1 = l->child;
335    CHECK_ASN1_TYPE(l1, LTC_ASN1_CUSTOM_TYPE);
336    CHECK_ASN1_HAS_CHILD(l1);
337    CHECK_ASN1_HAS_NEXT(l1);
338    l2 = l1->child;
339    CHECK_ASN1_TYPE(l2, LTC_ASN1_INTEGER);
340    CHECK_ASN1_HAS_NO_CHILD(l2);
341    CHECK_ASN1_HAS_NO_NEXT(l2);
342    l1 = l1->next;
343    CHECK_ASN1_TYPE(l1, LTC_ASN1_INTEGER);
344    CHECK_ASN1_HAS_NO_CHILD(l1);
345    CHECK_ASN1_HAS_NEXT(l1);
346    l1 = l1->next;
347    CHECK_ASN1_TYPE(l1, LTC_ASN1_SEQUENCE);
348    CHECK_ASN1_HAS_CHILD(l1);
349    CHECK_ASN1_HAS_NEXT(l1);
350    l2 = l1->child;
351    CHECK_ASN1_TYPE(l2, LTC_ASN1_OBJECT_IDENTIFIER);
352    CHECK_ASN1_HAS_NO_CHILD(l2);
353    CHECK_ASN1_HAS_NEXT(l2);
354    l2 = l2->next;
355    CHECK_ASN1_TYPE(l2, LTC_ASN1_NULL);
356    CHECK_ASN1_HAS_NO_CHILD(l2);
357    CHECK_ASN1_HAS_NO_NEXT(l2);
358    l = l->next;
359    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
360    CHECK_ASN1_HAS_CHILD(l);
361    CHECK_ASN1_HAS_NEXT(l);
362    l1 = l->child;
363    CHECK_ASN1_TYPE(l1, LTC_ASN1_OBJECT_IDENTIFIER);
364    CHECK_ASN1_HAS_NO_CHILD(l1);
365    CHECK_ASN1_HAS_NEXT(l1);
366    l1 = l1->next;
367    CHECK_ASN1_TYPE(l1, LTC_ASN1_NULL);
368    CHECK_ASN1_HAS_NO_CHILD(l1);
369    CHECK_ASN1_HAS_NO_NEXT(l1);
370    l = l->next;
371    CHECK_ASN1_TYPE(l, LTC_ASN1_BIT_STRING);
372    CHECK_ASN1_HAS_NO_CHILD(l);
373    CHECK_ASN1_HAS_NO_NEXT(l);
374    der_free_sequence_flexi(decoded_list);
375  }
376  static void der_set_test(void)
377  {
378     ltc_asn1_list list[10];
379     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
380     static const unsigned char bin_str[] = { 1, 0, 0, 1 };
381     static const unsigned long int_val   = 12345678UL;
382     unsigned char strs[10][10], outbuf[128];
383     unsigned long x, val, outlen;
384     LTC_SET_ASN1(list, 0, LTC_ASN1_OCTET_STRING,  oct_str, sizeof(oct_str));
385     LTC_SET_ASN1(list, 1, LTC_ASN1_BIT_STRING,    bin_str, sizeof(bin_str));
386     LTC_SET_ASN1(list, 2, LTC_ASN1_SHORT_INTEGER, &int_val, 1);
387     outlen = sizeof(outbuf);
388     DO(der_encode_set(list, 3, outbuf, &outlen));
389     LTC_SET_ASN1(list, 0, LTC_ASN1_BIT_STRING,    strs[1], sizeof(strs[1]));
390     LTC_SET_ASN1(list, 1, LTC_ASN1_SHORT_INTEGER, &val, 1);
391     LTC_SET_ASN1(list, 2, LTC_ASN1_OCTET_STRING,  strs[0], sizeof(strs[0]));
392     DO(der_decode_set(outbuf, outlen, list, 3));
393     if (memcmp(strs[0], oct_str, sizeof(oct_str))) {
394        fprintf(stderr, "error decoding set using der_decode_set (oct_str is wrong):\n");
395        exit(EXIT_FAILURE);
396     }
397     if (memcmp(strs[1], bin_str, sizeof(bin_str))) {
398        fprintf(stderr, "error decoding set using der_decode_set (bin_str is wrong):\n");
399        exit(EXIT_FAILURE);
400     }
401     if (val != int_val) {
402        fprintf(stderr, "error decoding set using der_decode_set (int_val is wrong):\n");
403        exit(EXIT_FAILURE);
404     }
405     strcpy((char*)strs[0], "one");
406     strcpy((char*)strs[1], "one2");
407     strcpy((char*)strs[2], "two");
408     strcpy((char*)strs[3], "aaa");
409     strcpy((char*)strs[4], "aaaa");
410     strcpy((char*)strs[5], "aab");
411     strcpy((char*)strs[6], "aaab");
412     strcpy((char*)strs[7], "bbb");
413     strcpy((char*)strs[8], "bbba");
414     strcpy((char*)strs[9], "bbbb");
415     for (x = 0; x < 10; x++) {
416         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], XSTRLEN((char*)strs[x]));
417     }
418     outlen = sizeof(outbuf);
419     DO(der_encode_setof(list, 10, outbuf, &outlen));
420     for (x = 0; x < 10; x++) {
421         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], sizeof(strs[x]) - 1);
422     }
423     XMEMSET(strs, 0, sizeof(strs));
424     DO(der_decode_set(outbuf, outlen, list, 10));
425     for (x = 1; x < 10; x++) {
426        if (!(XSTRLEN((char*)strs[x-1]) <= XSTRLEN((char*)strs[x])) && strcmp((char*)strs[x-1], (char*)strs[x]) >= 0) {
427           fprintf(stderr, "error SET OF order at %lu is wrong\n", x);
428           exit(EXIT_FAILURE);
429        }
430     }
431  }
432  static void s_der_oid_test(void)
433  {
434     static const unsigned char oid_x690_8_19_5_example[] = { 0x06, 0x03, 0x88, 0x37, 0x03 };
435     unsigned long len, oid[3];
436     unsigned char buf[64];
437     ltc_asn1_list *decoded_list, static_list[1];
438     len = sizeof(oid_x690_8_19_5_example);
439     DO(der_decode_sequence_flexi(oid_x690_8_19_5_example, &len, &decoded_list));
440     LTC_SET_ASN1(static_list, 0, LTC_ASN1_OBJECT_IDENTIFIER, (void *)decoded_list->data, decoded_list->size);
441     len = sizeof(buf);
442     DO(der_encode_object_identifier(decoded_list->data, decoded_list->size, buf, &len));
443     der_sequence_free(decoded_list);
444     DO(do_compare_testvector(buf, len, oid_x690_8_19_5_example, sizeof(oid_x690_8_19_5_example), "OID X6.90 Ch. 8.19.5 Example", 0));
445     oid[0] = 3;
446     oid[1] = 4;
447     oid[2] = 5;
448     len = sizeof(buf);
449     SHOULD_FAIL(der_encode_object_identifier(oid, 3, buf, &len));
450     len = sizeof(buf);
451     SHOULD_FAIL(der_length_object_identifier(oid, 3, &len));
452  }
453  static void der_flexi_test(void)
454  {
455     static const char printable_str[]    = "printable";
456     static const char set1_str[]         = "333";
457     static const char set2_str[]         = "222";
458     static const char ia5_str[]          = "ia5";
459     static const unsigned long int_val   = 12345678UL;
460     static const ltc_utctime   utctime   = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
461     static const ltc_generalizedtime gtime = { 2017, 03, 21, 10, 21, 12, 421, 1, 2, 0 };
462     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
463     static const unsigned char bit_str[] = { 1, 0, 0, 1 };
464     static const unsigned long oid_str[] = { 1, 2, 840, 113549 };
465     unsigned char encode_buf[192];
466     unsigned long encode_buf_len, decode_len;
467     ltc_asn1_list static_list[5][4], *decoded_list, *l;
468     LTC_SET_ASN1(static_list[0], 0, LTC_ASN1_PRINTABLE_STRING, (void *)printable_str, XSTRLEN(printable_str));
469     LTC_SET_ASN1(static_list[0], 1, LTC_ASN1_IA5_STRING,       (void *)ia5_str,       XSTRLEN(ia5_str));
470     LTC_SET_ASN1(static_list[0], 2, LTC_ASN1_SEQUENCE,         static_list[1],   4);
471     LTC_SET_ASN1(static_list[1], 0, LTC_ASN1_SHORT_INTEGER,    (void *)&int_val,         1);
472     LTC_SET_ASN1(static_list[1], 1, LTC_ASN1_UTCTIME,          (void *)&utctime,         1);
473     LTC_SET_ASN1(static_list[1], 2, LTC_ASN1_GENERALIZEDTIME,  (void *)&gtime,           1);
474     LTC_SET_ASN1(static_list[1], 3, LTC_ASN1_SEQUENCE,         static_list[2],   3);
475     LTC_SET_ASN1(static_list[2], 0, LTC_ASN1_OCTET_STRING,     (void *)oct_str,          4);
476     LTC_SET_ASN1(static_list[2], 1, LTC_ASN1_BIT_STRING,       (void *)bit_str,          4);
477     LTC_SET_ASN1(static_list[2], 2, LTC_ASN1_SEQUENCE,         static_list[3],   3);
478     LTC_SET_ASN1(static_list[3], 0, LTC_ASN1_OBJECT_IDENTIFIER,(void *)oid_str,          4);
479     LTC_SET_ASN1(static_list[3], 1, LTC_ASN1_NULL,             NULL,             0);
480     LTC_SET_ASN1(static_list[3], 2, LTC_ASN1_SETOF,            static_list[4],   2);
481     LTC_SET_ASN1(static_list[4], 0, LTC_ASN1_PRINTABLE_STRING, set1_str, XSTRLEN(set1_str));
482     LTC_SET_ASN1(static_list[4], 1, LTC_ASN1_PRINTABLE_STRING, set2_str, XSTRLEN(set2_str));
483     encode_buf_len = sizeof(encode_buf);
484     DO(der_encode_sequence(&static_list[0][0], 3, encode_buf, &encode_buf_len));
485  #if 0
486     {
487       FILE *f;
488       f = fopen("t.bin", "wb");
489       fwrite(encode_buf, 1, encode_buf_len, f);
490       fclose(f);
491     }
492  #endif
493     decode_len = encode_buf_len;
494     DO(der_decode_sequence_flexi(encode_buf, &decode_len, &decoded_list));
495     if (decode_len != encode_buf_len) {
496        fprintf(stderr, "Decode len of %lu does not match encode len of %lu \n", decode_len, encode_buf_len);
497        exit(EXIT_FAILURE);
498     }
499     l = decoded_list;
500     if (l->next != NULL || l->child == NULL) {
501        fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
502        exit(EXIT_FAILURE);
503     }
504        if (l->type != LTC_ASN1_SEQUENCE) {
505           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
506           exit(EXIT_FAILURE);
507        }
508        l = l->child;
509        if (l->next == NULL || l->child != NULL) {
510           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
511           exit(EXIT_FAILURE);
512        }
513        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
514           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
515           exit(EXIT_FAILURE);
516        }
517        if (l->size != XSTRLEN(printable_str) || memcmp(printable_str, l->data, l->size)) {
518           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
519           exit(EXIT_FAILURE);
520        }
521        l = l->next;
522        if (l->next == NULL || l->child != NULL) {
523           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
524           exit(EXIT_FAILURE);
525        }
526        if (l->type != LTC_ASN1_IA5_STRING) {
527           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
528           exit(EXIT_FAILURE);
529        }
530        if (l->size != XSTRLEN(ia5_str) || memcmp(ia5_str, l->data, l->size)) {
531           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
532           exit(EXIT_FAILURE);
533        }
534        l = l->next;
535        if (l->next != NULL || l->child == NULL) {
536           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
537           exit(EXIT_FAILURE);
538        }
539        if (l->type != LTC_ASN1_SEQUENCE) {
540           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
541           exit(EXIT_FAILURE);
542        }
543        l = l->child;
544        if (l->next == NULL || l->child != NULL) {
545           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
546           exit(EXIT_FAILURE);
547        }
548        if (l->type != LTC_ASN1_INTEGER) {
549           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
550           exit(EXIT_FAILURE);
551        }
552        if (mp_cmp_d(l->data, 12345678UL) != LTC_MP_EQ) {
553           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
554           exit(EXIT_FAILURE);
555        }
556        l = l->next;
557        if (l->next == NULL || l->child != NULL) {
558           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
559           exit(EXIT_FAILURE);
560        }
561        if (l->type != LTC_ASN1_UTCTIME) {
562           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
563           exit(EXIT_FAILURE);
564        }
565        if (memcmp(l->data, &utctime, sizeof(utctime))) {
566           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
567           exit(EXIT_FAILURE);
568        }
569        l = l->next;
570        if (l->next == NULL || l->child != NULL) {
571           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
572           exit(EXIT_FAILURE);
573        }
574        if (l->type != LTC_ASN1_GENERALIZEDTIME) {
575           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
576           exit(EXIT_FAILURE);
577        }
578        if (memcmp(l->data, &gtime, sizeof(gtime))) {
579           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
580           exit(EXIT_FAILURE);
581        }
582        l = l->next;
583        if (l->next != NULL || l->child == NULL) {
584           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
585           exit(EXIT_FAILURE);
586        }
587        if (l->type != LTC_ASN1_SEQUENCE) {
588           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
589           exit(EXIT_FAILURE);
590        }
591        l = l->child;
592        if (l->next == NULL || l->child != NULL) {
593           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
594           exit(EXIT_FAILURE);
595        }
596        if (l->type != LTC_ASN1_OCTET_STRING) {
597           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
598           exit(EXIT_FAILURE);
599        }
600        if (l->size != sizeof(oct_str) || memcmp(oct_str, l->data, l->size)) {
601           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
602           exit(EXIT_FAILURE);
603        }
604        l = l->next;
605        if (l->next == NULL || l->child != NULL) {
606           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
607           exit(EXIT_FAILURE);
608        }
609        if (l->type != LTC_ASN1_BIT_STRING) {
610           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
611           exit(EXIT_FAILURE);
612        }
613        if (l->size != sizeof(bit_str) || memcmp(bit_str, l->data, l->size)) {
614           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
615           exit(EXIT_FAILURE);
616        }
617        l = l->next;
618        if (l->next != NULL || l->child == NULL) {
619           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
620           exit(EXIT_FAILURE);
621        }
622        if (l->type != LTC_ASN1_SEQUENCE) {
623           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
624           exit(EXIT_FAILURE);
625        }
626        l = l->child;
627        if (l->next == NULL || l->child != NULL) {
628           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
629           exit(EXIT_FAILURE);
630        }
631        if (l->type != LTC_ASN1_OBJECT_IDENTIFIER) {
632           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
633           exit(EXIT_FAILURE);
634        }
635        if (l->size != sizeof(oid_str)/sizeof(oid_str[0]) || memcmp(oid_str, l->data, l->size*sizeof(oid_str[0]))) {
636           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
637           exit(EXIT_FAILURE);
638        }
639        l = l->next;
640        if (l->type != LTC_ASN1_NULL) {
641           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
642           exit(EXIT_FAILURE);
643        }
644        l = l->next;
645        if (l->next != NULL || l->child == NULL) {
646           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
647           exit(EXIT_FAILURE);
648        }
649        if (l->type != LTC_ASN1_SET) {
650           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
651           exit(EXIT_FAILURE);
652        }
653        l = l->child;
654        if (l->next == NULL || l->child != NULL) {
655           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
656           exit(EXIT_FAILURE);
657        }
658        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
659           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
660           exit(EXIT_FAILURE);
661        }
662        if (l->size != XSTRLEN(set2_str) || memcmp(set2_str, l->data, l->size)) {
663           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
664           exit(EXIT_FAILURE);
665        }
666        l = l->next;
667        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
668           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
669           exit(EXIT_FAILURE);
670        }
671        if (l->size != XSTRLEN(set1_str) || memcmp(set1_str, l->data, l->size)) {
672           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
673           exit(EXIT_FAILURE);
674        }
675     der_sequence_free(l);
676  }
677  static int der_choice_n_custom_test(void)
678  {
679     ltc_asn1_list types[10], host[1], custom[1], root[1], child[1];
680     int boolean[1];
681     unsigned char bitbuf[10], octetbuf[10], ia5buf[10], printbuf[10], outbuf[256], custbuf[256], x, y;
682     wchar_t utf8buf[10];
683     unsigned long integer, oidbuf[10], outlen, custlen, inlen, n;
684     void          *mpinteger;
685     ltc_utctime   utctime = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
686     ltc_generalizedtime gtime = { 2038, 01, 19, 3, 14, 8, 0, 0, 0, 0 };
687     for (x = 0; x < sizeof(bitbuf); x++)   { bitbuf[x]   = x & 1; }
688     for (x = 0; x < sizeof(octetbuf); x++) { octetbuf[x] = x;     }
689     for (x = 0; x < sizeof(ia5buf); x++)   { ia5buf[x]   = 'a';   }
690     for (x = 0; x < sizeof(printbuf); x++) { printbuf[x] = 'a';   }
691     for (x = 0; x < sizeof(utf8buf)/sizeof(utf8buf[0]); x++) { utf8buf[x] = L'a';   }
692     integer = 1;
693     boolean[0] = 1;
694     for (x = 0; x < sizeof(oidbuf)/sizeof(oidbuf[0]); x++)   { oidbuf[x] = x + 1;   }
695     DO(mp_init(&mpinteger));
696     n = sizeof(types)/sizeof(types[0]);
697     for (x = 0; x < n * 2; x++) {
698         y = 0;
699         LTC_SET_ASN1(types, y++, LTC_ASN1_PRINTABLE_STRING, printbuf, sizeof(printbuf));
700         if (x > n) {
701            LTC_SET_ASN1(types, y++, LTC_ASN1_BIT_STRING, bitbuf, sizeof(bitbuf));
702         } else {
703            LTC_SET_ASN1(types, y++, LTC_ASN1_RAW_BIT_STRING, bitbuf, sizeof(bitbuf));
704         }
705         LTC_SET_ASN1(types, y++, LTC_ASN1_OCTET_STRING, octetbuf, sizeof(octetbuf));
706         LTC_SET_ASN1(types, y++, LTC_ASN1_IA5_STRING, ia5buf, sizeof(ia5buf));
707         LTC_SET_ASN1(types, y++, LTC_ASN1_BOOLEAN, boolean, sizeof(boolean)/sizeof(boolean[0]));
708         if (x > n) {
709            LTC_SET_ASN1(types, y++, LTC_ASN1_SHORT_INTEGER, &integer, 1);
710         } else {
711            LTC_SET_ASN1(types, y++, LTC_ASN1_INTEGER, mpinteger, 1);
712         }
713         LTC_SET_ASN1(types, y++, LTC_ASN1_OBJECT_IDENTIFIER, oidbuf, sizeof(oidbuf)/sizeof(oidbuf[0]));
714         if (x > n) {
715            LTC_SET_ASN1(types, y++, LTC_ASN1_UTCTIME, &utctime, 1);
716         } else {
717            LTC_SET_ASN1(types, y++, LTC_ASN1_GENERALIZEDTIME, &gtime, 1);
718         }
719         LTC_SET_ASN1(custom, 0, LTC_ASN1_NULL, NULL, 0);
720         LTC_SET_ASN1_CUSTOM_CONSTRUCTED(types, y++, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0, custom);
721         LTC_SET_ASN1(types, y++, LTC_ASN1_UTF8_STRING, utf8buf, sizeof(utf8buf)/sizeof(utf8buf[0]));
722         LTC_SET_ASN1(host, 0, LTC_ASN1_CHOICE, types, n);
723         outlen = sizeof(outbuf);
724         DO(der_encode_sequence(&types[x % n], 1, outbuf, &outlen));
725         child[0] = types[x % n];
726         if (x < n) {
727            LTC_SET_ASN1_CUSTOM_CONSTRUCTED(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child);
728         } else {
729            LTC_SET_ASN1_CUSTOM_PRIMITIVE(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child->type, child->data, child->size);
730         }
731         custlen = sizeof(custbuf);
732         if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
733            DO(der_encode_custom_type(root, custbuf, &custlen));
734         }
735         inlen = outlen;
736         DO(der_decode_sequence(outbuf, inlen, host, 1));
737         for (y = 0; y < n; y++) {
738             if (types[y].used && y != (x % n)) {
739                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to one\n", y, x);
740                 return 1;
741             }
742             if (!types[y].used && y == (x % n)) {
743                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to zero\n", y, x);
744                 return 1;
745             }
746        }
747        if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
748           DO(der_decode_custom_type(custbuf, custlen, root));
749        }
750    }
751    mp_clear(mpinteger);
752    return 0;
753  }
754  static void s_der_decode_print(const void* p, unsigned long* plen)
755  {
756     ltc_asn1_list *list;
757     DO(der_decode_sequence_flexi(p, plen, &list));
758  #ifdef LTC_DER_TESTS_PRINT_FLEXI
759     fprintf(stderr, "\n\n");
760     s_der_tests_print_flexi(list, 0);
761     fprintf(stderr, "\n\n");
762  #endif
763     der_sequence_free(list);
764  }
765  static const unsigned char eckey_privc_der[] = {
766    0x30, 0x81, 0xf0, 0x02, 0x01, 0x01, 0x04, 0x18, 0x96, 0x9d, 0x28, 0xf2, 0x40, 0x48, 0x19, 0x11,
767    0x79, 0xb0, 0x47, 0x8e, 0x8c, 0x6b, 0x3d, 0x9b, 0xf2, 0x31, 0x16, 0x10, 0x08, 0x72, 0xb1, 0x86,
768    0xa0, 0x81, 0xb2, 0x30, 0x81, 0xaf, 0x02, 0x01, 0x01, 0x30, 0x24, 0x06, 0x07, 0x2a, 0x86, 0x48,
769    0xce, 0x3d, 0x01, 0x01, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
770    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30,
771    0x4b, 0x04, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
772    0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x04, 0x18, 0x22, 0x12, 0x3d,
773    0xc2, 0x39, 0x5a, 0x05, 0xca, 0xa7, 0x42, 0x3d, 0xae, 0xcc, 0xc9, 0x47, 0x60, 0xa7, 0xd4, 0x62,
774    0x25, 0x6b, 0xd5, 0x69, 0x16, 0x03, 0x15, 0x00, 0xc4, 0x69, 0x68, 0x44, 0x35, 0xde, 0xb3, 0x78,
775    0xc4, 0xb6, 0x5c, 0xa9, 0x59, 0x1e, 0x2a, 0x57, 0x63, 0x05, 0x9a, 0x2e, 0x04, 0x19, 0x02, 0x7d,
776    0x29, 0x77, 0x81, 0x00, 0xc6, 0x5a, 0x1d, 0xa1, 0x78, 0x37, 0x16, 0x58, 0x8d, 0xce, 0x2b, 0x8b,
777    0x4a, 0xee, 0x8e, 0x22, 0x8f, 0x18, 0x96, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
778    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x62, 0xd0, 0x31, 0xc8, 0x3f, 0x42, 0x94, 0xf6, 0x40,
779    0xec, 0x13, 0x02, 0x01, 0x01, 0xa1, 0x1c, 0x03, 0x1a, 0x00, 0x02, 0x55, 0x2c, 0xb8, 0x73, 0x5c,
780    0x9d, 0x98, 0xe4, 0x57, 0xfe, 0xd5, 0x96, 0x0a, 0x73, 0x8d, 0x82, 0xd7, 0xce, 0x05, 0xa9, 0x79,
781    0x91, 0x5c, 0xf9
782  };
783  static const unsigned char eckey_privs_der[] = {
784    0x30, 0x50, 0x02, 0x01, 0x01, 0x04, 0x14, 0x82, 0xef, 0x42, 0x0b, 0xc7, 0xe2, 0x9f, 0x3a, 0x84,
785    0xe5, 0x74, 0xec, 0x9c, 0xc5, 0x10, 0x26, 0x63, 0x8d, 0xb5, 0x46, 0xa0, 0x07, 0x06, 0x05, 0x2b,
786    0x81, 0x04, 0x00, 0x09, 0xa1, 0x2c, 0x03, 0x2a, 0x00, 0x04, 0xb5, 0xb1, 0x5a, 0xb0, 0x2a, 0x10,
787    0xd1, 0xf5, 0x4d, 0x6a, 0x41, 0xde, 0xcd, 0x69, 0x09, 0xb3, 0x5f, 0x26, 0xb0, 0xa2, 0xaf, 0xd3,
788    0x02, 0x89, 0x5e, 0xd4, 0x96, 0x5c, 0xbc, 0x2a, 0x7e, 0x75, 0x85, 0x86, 0x29, 0xb3, 0x29, 0x13,
789    0x77, 0xc3
790  };
791  static void der_custom_test(void)
792  {
793     ltc_asn1_list bool_ean[1], seq1[1], custom[1];
794     int boolean;
795     unsigned long len;
796     unsigned char buf[1024];
797     unsigned char buf1[] = { 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
798     unsigned char buf2[] = { 0x30, 0x08, 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
799     boolean = 0x1;
800     LTC_SET_ASN1(bool_ean, 0, LTC_ASN1_BOOLEAN, &boolean, 1);
801     LTC_SET_ASN1(seq1, 0, LTC_ASN1_SEQUENCE, bool_ean, 1);
802     LTC_SET_ASN1_CUSTOM_CONSTRUCTED(custom, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x1000, seq1);
803     DO(der_length_custom_type(custom, &len, NULL));
804     len = sizeof(buf);
805     DO(der_encode_custom_type(custom, buf, &len));
806     s_der_decode_print(buf, &len);
807     boolean = 0x0;
808     DO(der_decode_custom_type(buf, len, custom));
809     DO(der_length_sequence(custom, 1, &len));
810     len = sizeof(buf);
811     DO(der_encode_sequence(custom, 1, buf, &len));
812     s_der_decode_print(buf, &len);
813     boolean = 0x0;
814     DO(der_decode_sequence(buf, len, custom, 1));
815     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
816     DO(der_length_custom_type(bool_ean, &len, NULL));
817     len = sizeof(buf);
818     DO(der_encode_custom_type(bool_ean, buf, &len));
819     s_der_decode_print(buf, &len);
820     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
821     DO(der_decode_custom_type(buf, len, bool_ean));
822     len = sizeof(buf1);
823     s_der_decode_print(buf1, &len);
824     len = sizeof(buf2);
825     s_der_decode_print(buf2, &len);
826     len = sizeof(eckey_privc_der);
827     s_der_decode_print(eckey_privc_der, &len);
828     len = sizeof(eckey_privs_der);
829     s_der_decode_print(eckey_privs_der, &len);
830  }
831  typedef int (*s_der_Xcode)(const void*, unsigned long, void*, unsigned long*);
832  typedef struct {
833     s_der_Xcode encode;
834     s_der_Xcode decode;
835     const void* in;
836     size_t in_sz;
837     size_t factor;
838     size_t type_sz;
839     const char* what;
840  } der_Xcode_t;
841  static void der_Xcode_run(const der_Xcode_t* x)
842  {
843     unsigned long l1, l2, sz;
844     void *d1, *d2;
845     l1 = 1;
846     d1 = XMALLOC(l1 * x->type_sz);
847     sz = (x->in_sz * x->factor)/x->type_sz;
848     if (x->encode(x->in, sz, d1, &l1) == CRYPT_BUFFER_OVERFLOW) {
849        d1 = XREALLOC(d1, l1 * x->type_sz);
850     }
851     DO(x->encode(x->in, sz, d1, &l1));
852     l2 = 1;
853     d2 = XMALLOC(l2 * x->type_sz);
854     while (x->decode(d1, l1, d2, &l2) == CRYPT_BUFFER_OVERFLOW) {
855        d2 = XREALLOC(d2, l2 * x->type_sz);
856     }
857     DO(x->decode(d1, l1, d2, &l2));
858     DO(do_compare_testvector(d2, (l2/x->factor) * x->type_sz, x->in, x->in_sz, x->what, __LINE__));
859     XFREE(d2);
860     XFREE(d1);
861  }
862  #if defined(_MSC_VER)
863  #define typeof(x) x
864  #endif
865  #define DER_XCODE_X(n, b, x) {  \
866        (s_der_Xcode)der_encode_ ## n,    \
867        (s_der_Xcode)der_decode_ ## n,    \
868        b,                   \
869        sizeof(b),           \
870        x,                   \
871        sizeof(typeof(b[0])),\
872        #n                   \
873  }
874  #define DER_XCODE(n, b) DER_XCODE_X(n, b, 1)
875  static void der_Xcode_test(void)
876  {
877     unsigned long i;
878     ltc_asn1_list *list;
879     ltc_asn1_list ttex_neg_int[2];
880     unsigned char buf[128];
881     void* mpinteger;
882     const unsigned long oid[3] = { 1, 23, 42 };
883     const unsigned char bit_string[] = { 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1 };
884     const unsigned char multi_buf[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
885     const char multi_string[] = {'l','i','b','t','o','m','c','r','y','p','t'};
886     const wchar_t wchar_string[] = L"libtomcrypt";
887     const unsigned char teletex_neg_int[] = {   0x30, 0x11, 0x14, 0x0b, 0x6c, 0x69, 0x62, 0x74,
888                                                 0x6f, 0x6d, 0x63, 0x72, 0x79, 0x70, 0x74, 0x02,
889                                                 0x02, 0xfc, 0x19 };
890     const der_Xcode_t xcode_tests[] =
891     {
892      DER_XCODE(bit_string, bit_string),
893      DER_XCODE_X(raw_bit_string, multi_buf, 8),
894      DER_XCODE(octet_string, multi_buf),
895      DER_XCODE(object_identifier, oid),
896      DER_XCODE(ia5_string, multi_string),
897      DER_XCODE(printable_string, multi_string),
898      DER_XCODE(utf8_string, wchar_string),
899     };
900     for (i = 0; i < sizeof(xcode_tests)/sizeof(xcode_tests[0]); ++i) {
901        der_Xcode_run(&xcode_tests[i]);
902     }
903     i = sizeof(teletex_neg_int);
904     DO(der_decode_sequence_flexi(teletex_neg_int, &i, &list));
905  #ifdef LTC_DER_TESTS_PRINT_FLEXI
906     fprintf(stderr, "\n\n");
<span onclick='openModal()' class='match'>907     s_der_tests_print_flexi(list, 0);
908     fprintf(stderr, "\n\n");
909  #endif
910     if (list->child == NULL || list->child->next == NULL)
</span>911        exit(EXIT_FAILURE);
912     ttex_neg_int[0] = *list->child->next;
913     i = sizeof(buf);
914     DO(der_encode_sequence(ttex_neg_int, 1, buf, &i));
915     der_sequence_free(list);
916     DO(mp_init(&mpinteger));
917     LTC_SET_ASN1(ttex_neg_int, 0, LTC_ASN1_TELETEX_STRING, buf, sizeof(buf));
918     LTC_SET_ASN1(ttex_neg_int, 1, LTC_ASN1_INTEGER, mpinteger, 1);
919     DO(der_decode_sequence(teletex_neg_int, sizeof(teletex_neg_int), ttex_neg_int, 2));
920     mp_clear(mpinteger);
921  }
922  #ifdef LTC_TEST_READDIR
923  static int s_der_decode_sequence_flexi(const void *in, unsigned long inlen, void* ctx)
924  {
925     ltc_asn1_list** list = ctx;
926     if (der_decode_sequence_flexi(in, &inlen, list) == CRYPT_OK) {
927  #ifdef LTC_DER_TESTS_PRINT_FLEXI
928        fprintf(stderr, "\n\n");
929        s_der_tests_print_flexi(*list, 0);
930        fprintf(stderr, "\n\n");
931  #endif
932        der_sequence_free(*list);
933     }
934     return CRYPT_OK;
935  }
936  #endif
937  static void s_der_regression_test(void)
938  {
939     static const unsigned char s_broken_sequence[] = {
940       0x30,0x41,0x02,0x84,0x7f,0xff,0xff,0xff,0x1e,0x41,0xb4,0x79,0xad,0x57,0x69,
941       0x05,0xb9,0x60,0xfe,0x14,0xea,0xdb,0x91,0xb0,0xcc,0xf3,0x48,0x43,0xda,0xb9,
942       0x16,0x17,0x3b,0xb8,0xc9,0xcd,0x02,0x1d,0x00,0xad,0xe6,0x59,0x88,0xd2,0x37,
943       0xd3,0x0f,0x9e,0xf4,0x1d,0xd4,0x24,0xa4,0xe1,0xc8,0xf1,0x69,0x67,0xcf,0x33,
944       0x65,0x81,0x3f,0xe8,0x78,0x62,0x36
945     };
946     static const unsigned char s_addtl_bytes[] = {
947       0x30,0x45,0x02,0x21,0x00,0xb7,0xba,0xba,0xe9,0x33,0x2b,0x54,0xb8,0xa3,0xa0,0x5b,0x70,0x04,0x57,
948       0x98,0x21,0xa8,0x87,0xa1,0xb2,0x14,0x65,0xf7,0xdb,0x8a,0x3d,0x49,0x1b,0x39,0xfd,0x2c,0x3f,0x02,
949       0x20,0x74,0x72,0x91,0xdd,0x2f,0x3f,0x44,0xaf,0x7a,0xce,0x68,0xea,0x33,0x43,0x1d,0x6f,0x94,0xe4,
950       0x18,0xc1,0x06,0xa6,0xe7,0x62,0x85,0xcd,0x59,0xf4,0x32,0x60,0xec,0xce,0x00,0x00
951     };
952     static const unsigned char issue_507[] = "\x30\x04"           &bsol;* Start DER-sequence of length 4 */
953                                              "\x0c\x02\xbf\xbf"   &bsol;* Start UTF8 string of actual length 2 and evaluated length 3 */
954                                              "\xaa"               &bsol;* One byte padding */
955                                              "\x04\x82\xff\xff";  &bsol;* Start OCTET sequence of length 0xffff */
956     unsigned long len;
957     void *x, *y;
958     ltc_asn1_list seq[2];
959     ltc_asn1_list *l;
960     mp_init_multi(&x, &y, LTC_NULL);
961     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
962     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
963     SHOULD_FAIL(der_decode_sequence(s_broken_sequence, sizeof(s_broken_sequence), seq, 2));
964     mp_cleanup_multi(&y, &x, LTC_NULL);
965     len = sizeof(s_broken_sequence);
966     mp_init_multi(&x, &y, LTC_NULL);
967     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
968     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
969     SHOULD_FAIL_WITH(der_decode_sequence(s_addtl_bytes, sizeof(s_addtl_bytes), seq, 2), CRYPT_INPUT_TOO_LONG);
970     mp_cleanup_multi(&y, &x, LTC_NULL);
971     len = sizeof(s_addtl_bytes);
972     s_der_decode_print(s_addtl_bytes, &len);
973     len = sizeof(issue_507);
974     SHOULD_FAIL(der_decode_sequence_flexi(issue_507, &len, &l));
975  }
976  static void der_toolong_test(void)
977  {
978     int n, err, failed = 0;
979     ltc_asn1_list *list;
980     unsigned long len, oid[16];
981     unsigned char buf5[5], buf12[12], buf32[32];
982     static const unsigned char invalid1[] = {
983           0x30,0x19, &bsol;* SEQUENCE len=25 bytes */
984                0x30,0x0a, &bsol;* SEQUENCE len=10 bytes (which is wrong, should be 9) */
985                     0x04,0x05, &bsol;* OCTET STRING len=5 */ 0x2b,0x0e,0x03,0x02,0x1a,
986                     0x05,0x00, &bsol;* NULL */
987                0x04,0x0c, &bsol;* OCTET STRING len=12 */ 0xf7,0xff,0x9e,0x8b,0x7b,0xb2,0xe0,0x9b,0x70,0x93,0x5a,0x5d,
988     };
989     static const unsigned char invalid2[] = {
990           0x30,0x0d, &bsol;* SEQUENCE len=13 bytes*/
991                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
992                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
993           0x00,0x00 &bsol;* garbage after the sequence, der_decode_sequence_flexi should ignore this */
994     };
995     static const unsigned char invalid3[] = {
996           0x30,0x0f, &bsol;* SEQUENCE len=15 bytes*/
997                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
998                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
999                0x00,0x00  &bsol;* garbage inside the sequence */
1000     };
1001     static const unsigned char invalid4[] = {
1002           0x30, 0x30,
1003                 0x30, 0x0d,
1004                       0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1005                       0x05, 0x00,
1006                 0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c,
1007                             0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25
1008     };
1009     static const unsigned char invalid5[] = {
1010            0x30, 0x31,
1011                  0x30, 0x0e,
1012                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1013                        0x05, 0x00,
1014                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1015                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1016     };
1017     static const unsigned char invalid6[] = {
1018            0x30, 0x31,
1019                  0x30, 0x0c,
1020                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1021                        0x05, 0x00,
1022                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1023                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1024     };
1025     ltc_asn1_list seqsub[2], seqoid[2], seqmain[2], seqint[2];
1026     void *int1, *int2;
1027     LTC_SET_ASN1(seqsub,  0, LTC_ASN1_OCTET_STRING, buf5,   5);
1028     LTC_SET_ASN1(seqsub,  1, LTC_ASN1_NULL,         NULL,   0);
1029     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,     seqsub, 2);
1030     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING, buf12,  12);
1031     n = 1;
1032     len = sizeof(invalid1);
1033     err = der_decode_sequence_strict(invalid1, len, seqmain, 2);
1034     if (err == CRYPT_OK) {
1035        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1036        failed = 1;
1037     }
1038     len = sizeof(invalid1);
1039     err = der_decode_sequence_flexi(invalid1, &len, &list);
1040     if (err == CRYPT_OK) {
1041        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1042        failed = 1;
1043        der_sequence_free(list);
1044     }
1045     mp_init_multi(&int1, &int2, LTC_NULL);
1046     LTC_SET_ASN1(seqint,  0, LTC_ASN1_INTEGER,      int1,   1);
1047     LTC_SET_ASN1(seqint,  1, LTC_ASN1_INTEGER,      int2,   1);
1048     n++;
1049     len = sizeof(invalid2);
1050     err = der_decode_sequence_strict(invalid2, len, seqint, 2);
1051     if (err == CRYPT_OK) {
1052        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1053        failed = 1;
1054     }
1055     len = sizeof(invalid2);
1056     err = der_decode_sequence_flexi(invalid2, &len, &list);
1057     if (err != CRYPT_OK || len != 15) {
1058        fprintf(stderr,"der_decode_sequence_flexi failed, err=%d (expected 0) len=%lu (expected 15)\n", err, len);
1059        failed = 1;
1060     }
1061     if (err == CRYPT_OK)
1062        der_sequence_free(list);
1063     n++;
1064     len = sizeof(invalid3);
1065     err = der_decode_sequence_strict(invalid3, len, seqint, 2);
1066     if (err == CRYPT_OK) {
1067        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1068        failed = 1;
1069     }
1070     len = sizeof(invalid3);
1071     err = der_decode_sequence_flexi(invalid3, &len, &list);
1072     if (err == CRYPT_OK) {
1073        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1074        failed = 1;
1075        der_sequence_free(list);
1076     }
1077     mp_clear_multi(int1, int2, LTC_NULL);
1078     LTC_SET_ASN1(seqoid,  0, LTC_ASN1_OBJECT_IDENTIFIER, oid, sizeof(oid)/sizeof(oid[0]));
1079     LTC_SET_ASN1(seqoid,  1, LTC_ASN1_NULL,              NULL,   0);
1080     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,          seqoid, 2);
1081     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING,      buf32,  32);
1082     n++;
1083     len = sizeof(invalid4);
1084     err = der_decode_sequence_strict(invalid4, len, seqmain, 2);
1085     if (err == CRYPT_OK) {
1086        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1087        failed = 1;
1088     }
1089     len = sizeof(invalid4);
1090     err = der_decode_sequence_flexi(invalid4, &len, &list);
1091     if (err == CRYPT_OK) {
1092        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1093        failed = 1;
1094        der_sequence_free(list);
1095     }
1096     n++;
1097     len = sizeof(invalid5);
1098     err = der_decode_sequence_strict(invalid5, len, seqmain, 2);
1099     if (err == CRYPT_OK) {
1100        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1101        failed = 1;
1102     }
1103     len = sizeof(invalid5);
1104     err = der_decode_sequence_flexi(invalid5, &len, &list);
1105     if (err == CRYPT_OK) {
1106        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1107        failed = 1;
1108        der_sequence_free(list);
1109     }
1110     n++;
1111     len = sizeof(invalid6);
1112     err = der_decode_sequence_strict(invalid6, len, seqmain, 2);
1113     if (err == CRYPT_OK) {
1114        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1115        failed = 1;
1116     }
1117     len = sizeof(invalid6);
1118     err = der_decode_sequence_flexi(invalid6, &len, &list);
1119     if (err == CRYPT_OK) {
1120        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1121        failed = 1;
1122        der_sequence_free(list);
1123     }
1124     if (failed) exit(EXIT_FAILURE);
1125  }
1126  static void s_der_recursion_limit(void)
1127  {
1128     unsigned int n, m;
1129     unsigned long integer = 123, s;
1130     ltc_asn1_list seqs[LTC_DER_MAX_RECURSION + 2], dummy[1], *flexi;
1131     unsigned char buf[2048];
1132     for (m = 0; m < 3; ++m) {
1133        LTC_SET_ASN1(dummy, 0, LTC_ASN1_SHORT_INTEGER, &integer, 1);
1134        LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION + 1, LTC_ASN1_SEQUENCE, dummy, 1);
1135        for (n = m; n < LTC_DER_MAX_RECURSION + 1; ++n) {
1136           LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION - n, LTC_ASN1_SEQUENCE, &seqs[LTC_DER_MAX_RECURSION - n + 1], 1);
1137        }
1138        s = sizeof(buf);
1139        DO(der_encode_sequence(&seqs[m], 1, buf, &s));
1140        DO(der_decode_sequence(buf, s, &seqs[m], 1));
1141        if (m < 2) {
1142           SHOULD_FAIL(der_decode_sequence_flexi(buf, &s, &flexi));
1143        }
1144        else {
1145           DO(der_decode_sequence_flexi(buf, &s, &flexi));
1146           der_free_sequence_flexi(flexi);
1147        }
1148     }
1149  }
1150  int der_test(void)
1151  {
1152     unsigned long x, y, z, zz, oid[2][32];
1153     unsigned char buf[3][2048];
1154     void *a, *b, *c, *d, *e, *f, *g;
1155     static const unsigned char rsa_oid_der[] = { 0x06, 0x06, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d };
1156     static const unsigned long rsa_oid[]     = { 1, 2, 840, 113549 };
1157     static const unsigned char rsa_ia5[]     = "test1@rsa.com";
1158     static const unsigned char rsa_ia5_der[] = { 0x16, 0x0d, 0x74, 0x65, 0x73, 0x74, 0x31,
1159                                                  0x40, 0x72, 0x73, 0x61, 0x2e, 0x63, 0x6f, 0x6d };
1160     static const unsigned char rsa_printable[] = "Test User 1";
1161     static const unsigned char rsa_printable_der[] = { 0x13, 0x0b, 0x54, 0x65, 0x73, 0x74, 0x20, 0x55,
1162                                                        0x73, 0x65, 0x72, 0x20, 0x31 };
1163     static const ltc_utctime   rsa_time1 = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
1164     static const ltc_utctime   rsa_time2 = { 91, 5, 6, 23, 45, 40, 0, 0, 0 };
1165     ltc_utctime                tmp_time;
1166     static const unsigned char rsa_time1_der[] = { 0x17, 0x11, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x31, 0x36, 0x34, 0x35, 0x34, 0x30, 0x2D, 0x30, 0x37, 0x30, 0x30 };
1167     static const unsigned char rsa_time2_der[] = { 0x17, 0x0d, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x32, 0x33, 0x34, 0x35, 0x34, 0x30, 0x5a };
1168     static const wchar_t utf8_1[]           = { 0x0041, 0x2262, 0x0391, 0x002E };
1169     static const unsigned char utf8_1_der[] = { 0x0C, 0x07, 0x41, 0xE2, 0x89, 0xA2, 0xCE, 0x91, 0x2E };
1170     static const wchar_t utf8_2[]           = { 0xD55C, 0xAD6D, 0xC5B4 };
1171     static const unsigned char utf8_2_der[] = { 0x0C, 0x09, 0xED, 0x95, 0x9C, 0xEA, 0xB5, 0xAD, 0xEC, 0x96, 0xB4 };
1172     static const wchar_t utf8_3[]           = { 0x05E9, 0x05DC, 0x05D5, 0x05DD };
1173     static const unsigned char utf8_3_der[] = { 0x0C, 0x08, 0xD7, 0xA9, 0xD7, 0x9C, 0xD7, 0x95, 0xD7, 0x9D };
1174     unsigned char utf8_buf[32];
1175     wchar_t utf8_out[32];
1176  #ifdef LTC_TEST_READDIR
1177     ltc_asn1_list *list;
1178  #endif
1179     if (ltc_mp.name == NULL) return CRYPT_NOP;
1180     s_der_recursion_limit();
1181     der_Xcode_test();
1182  #ifdef LTC_TEST_READDIR
1183     DO(test_process_dir("tests/asn1", &list, s_der_decode_sequence_flexi, NULL, "DER ASN.1 special cases"));
1184  #endif
1185     der_custom_test();
1186     s_der_regression_test();
1187     der_toolong_test();
1188     der_cacert_test();
1189     s_der_oid_test();
1190     y = 0xffffff00;
1191  #if ULONG_MAX == ULLONG_MAX
1192     y <<= 32;
1193  #endif
1194     while (y != 0) {
1195        x = sizeof(buf[0]);
1196        DO(der_encode_asn1_length(y, buf[0], &x));
1197        x = y + x;
1198        DO(der_decode_asn1_length(buf[0], &x, &z));
1199        if (y != z) {
1200           fprintf(stderr, "Failed to en- or decode length correctly! %lu != %lu\n", y, z);
1201           return 1;
1202        }
1203        y >>= 3;
1204     }
1205     DO(mp_init_multi(&a, &b, &c, &d, &e, &f, &g, LTC_NULL));
1206     for (zz = 0; zz < 16; zz++) {
1207  #ifdef USE_TFM
1208        for (z = 0; z < 256; z++) {
1209  #else
1210        for (z = 0; z < 1024; z++) {
1211  #endif
1212           ENSURE(yarrow_read(buf[0], z, &yarrow_prng) == z);
1213           DO(mp_read_unsigned_bin(a, buf[0], z));
1214           x = sizeof(buf[0]);
1215           DO(der_encode_integer(a, buf[0], &x));
1216           DO(der_length_integer(a, &y));
1217           if (y != x) { fprintf(stderr, "DER INTEGER size mismatch %lu != %lu\n", y, x); return 1; }
1218           mp_set_int(b, 0);
1219           DO(der_decode_integer(buf[0], y, b));
1220           if (y != x || mp_cmp(a, b) != LTC_MP_EQ) {
1221              fprintf(stderr, "%lu: %lu vs %lu\n", z, x, y);
1222              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1223              return 1;
1224           }
1225        }
1226     }
1227     for (zz = 0; zz < 256; zz++) {
1228        for (z = 1; z < 4; z++) {
1229           ENSURE(yarrow_read(buf[2], z, &yarrow_prng) == z);
1230           DO(mp_read_unsigned_bin(a, buf[2], z));
1231           x = sizeof(buf[0]);
1232           DO(der_encode_integer(a, buf[0], &x));
1233           y = sizeof(buf[1]);
1234           DO(der_encode_short_integer(mp_get_int(a), buf[1], &y));
1235           if (x != y || memcmp(buf[0], buf[1], x)) {
1236              fprintf(stderr, "DER INTEGER short encoding failed, %lu, %lu, 0x%lX\n", x, y, mp_get_int(a));
1237              for (zz = 0; zz < z; zz++) fprintf(stderr, "%02x ", buf[2][zz]);
1238              fprintf(stderr, "\n");
1239              for (z = 0; z < x; z++) fprintf(stderr, "%02x ", buf[0][z]);
1240              fprintf(stderr, "\n");
1241              for (z = 0; z < y; z++) fprintf(stderr, "%02x ", buf[1][z]);
1242              fprintf(stderr, "\n");
1243              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1244              return 1;
1245           }
1246           x = 0;
1247           DO(der_decode_short_integer(buf[1], y, &x));
1248           if (x != mp_get_int(a)) {
1249              fprintf(stderr, "DER INTEGER short decoding failed, %lu, %lu\n", x, mp_get_int(a));
1250              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1251              return 1;
1252           }
1253        }
1254     }
1255     mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1256     for (zz = 1; zz < 1536; zz++) {
1257         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1258         for (z = 0; z < zz; z++) {
1259             buf[0][z] &= 0x01;
1260         }
1261         x = sizeof(buf[1]);
1262         DO(der_encode_bit_string(buf[0], zz, buf[1], &x));
1263         DO(der_length_bit_string(zz, &y));
1264         if (y != x) {
1265            fprintf(stderr, "\nDER BIT STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1266            return 1;
1267         }
1268         y = sizeof(buf[2]);
1269         DO(der_decode_bit_string(buf[1], x, buf[2], &y));
1270         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1271            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1272            return 1;
1273         }
1274     }
1275     for (zz = 1; zz < 1536; zz++) {
1276         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1277         x = sizeof(buf[1]);
1278         DO(der_encode_octet_string(buf[0], zz, buf[1], &x));
1279         DO(der_length_octet_string(zz, &y));
1280         if (y != x) {
1281            fprintf(stderr, "\nDER OCTET STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1282            return 1;
1283         }
1284         y = sizeof(buf[2]);
1285         DO(der_decode_octet_string(buf[1], x, buf[2], &y));
1286         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1287            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1288            return 1;
1289         }
1290     }
1291     x = sizeof(buf[0]);
1292     DO(der_encode_object_identifier((unsigned long*)rsa_oid, sizeof(rsa_oid)/sizeof(rsa_oid[0]), buf[0], &x));
1293     if (x != sizeof(rsa_oid_der) || memcmp(rsa_oid_der, buf[0], x)) {
1294        fprintf(stderr, "rsa_oid_der encode failed to match, %lu, ", x);
1295        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1296        fprintf(stderr, "\n");
1297        return 1;
1298     }
1299     y = sizeof(oid[0])/sizeof(oid[0][0]);
1300     DO(der_decode_object_identifier(buf[0], x, oid[0], &y));
1301     if (y != sizeof(rsa_oid)/sizeof(rsa_oid[0]) || memcmp(rsa_oid, oid[0], sizeof(rsa_oid))) {
1302        fprintf(stderr, "rsa_oid_der decode failed to match, %lu, ", y);
1303        for (z = 0; z < y; z++) fprintf(stderr, "%lu ", oid[0][z]);
1304        fprintf(stderr, "\n");
1305        return 1;
1306     }
1307     for (zz = 0; zz < 5000; zz++) {
1308         ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1309         LOAD32L(z, buf[0]);
1310         z = 2 + (z % ((sizeof(oid[0])/sizeof(oid[0][0])) - 2));
1311         oid[0][0] = buf[0][0] % 3;
1312         oid[0][1] = buf[0][1] % 40;
1313         for (y = 2; y < z; y++) {
1314            ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1315            LOAD32L(oid[0][y], buf[0]);
1316         }
1317         x = sizeof(buf[0]);
1318         DO(der_encode_object_identifier(oid[0], z, buf[0], &x));
1319         DO(der_length_object_identifier(oid[0], z, &y));
1320         if (x != y) {
1321            fprintf(stderr, "Random OID %lu test failed, length mismatch: %lu, %lu\n", z, x, y);
1322            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1323            return 1;
1324         }
1325         y = sizeof(oid[0])/sizeof(oid[0][0]);
1326         DO(der_decode_object_identifier(buf[0], x, oid[1], &y));
1327         if (y != z) {
1328            fprintf(stderr, "Random OID %lu test failed, decode length mismatch: %lu, %lu\n", z, x, y);
1329            return 1;
1330         }
1331         if (memcmp(oid[0], oid[1], sizeof(oid[0][0]) * z)) {
1332            fprintf(stderr, "Random OID %lu test failed, decoded values wrong\n", z);
1333            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1334            fprintf(stderr, "\n\n Got \n\n");
1335            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[1][x]);
1336            return 1;
1337         }
1338     }
1339     x = sizeof(buf[0]);
1340     DO(der_encode_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), buf[0], &x));
1341     if (x != sizeof(rsa_ia5_der) || memcmp(buf[0], rsa_ia5_der, x)) {
1342        fprintf(stderr, "IA5 encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_ia5_der));
1343        return 1;
1344     }
1345     DO(der_length_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), &y));
1346     if (y != x) {
1347        fprintf(stderr, "IA5 length failed to match: %lu, %lu\n", x, y);
1348        return 1;
1349     }
1350     y = sizeof(buf[1]);
1351     DO(der_decode_ia5_string(buf[0], x, buf[1], &y));
1352     if (y != XSTRLEN((char*)rsa_ia5) || memcmp(buf[1], rsa_ia5, XSTRLEN((char*)rsa_ia5))) {
1353         fprintf(stderr, "DER IA5 failed test vector\n");
1354         return 1;
1355     }
1356     x = sizeof(buf[0]);
1357     DO(der_encode_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), buf[0], &x));
1358     if (x != sizeof(rsa_printable_der) || memcmp(buf[0], rsa_printable_der, x)) {
1359        fprintf(stderr, "PRINTABLE encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_printable_der));
1360        return 1;
1361     }
1362     DO(der_length_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), &y));
1363     if (y != x) {
1364        fprintf(stderr, "printable length failed to match: %lu, %lu\n", x, y);
1365        return 1;
1366     }
1367     y = sizeof(buf[1]);
1368     DO(der_decode_printable_string(buf[0], x, buf[1], &y));
1369     if (y != XSTRLEN((char*)rsa_printable) || memcmp(buf[1], rsa_printable, XSTRLEN((char*)rsa_printable))) {
1370         fprintf(stderr, "DER printable failed test vector\n");
1371         return 1;
1372     }
1373     x = sizeof(buf[0]);
1374     DO(der_encode_utctime((ltc_utctime*)&rsa_time1, buf[0], &x));
1375     if (x != sizeof(rsa_time1_der) || memcmp(buf[0], rsa_time1_der, x)) {
1376        fprintf(stderr, "UTCTIME encode of rsa_time1 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1377        fprintf(stderr, "\n\n");
1378        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1379        fprintf(stderr, "\n");
1380        return 1;
1381     }
1382     DO(der_length_utctime((ltc_utctime*)&rsa_time1, &y));
1383     if (y != x) {
1384        fprintf(stderr, "UTCTIME length failed to match for rsa_time1: %lu, %lu\n", x, y);
1385        return 1;
1386     }
1387     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1388     if (y != x || memcmp(&rsa_time1, &tmp_time, sizeof(ltc_utctime))) {
1389        fprintf(stderr, "UTCTIME decode failed for rsa_time1: %lu %lu\n", x, y);
1390  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1391  tmp_time.YY,
1392  tmp_time.MM,
1393  tmp_time.DD,
1394  tmp_time.hh,
1395  tmp_time.mm,
1396  tmp_time.ss,
1397  tmp_time.off_dir,
1398  tmp_time.off_mm,
1399  tmp_time.off_hh);
1400        return 1;
1401     }
1402     x = sizeof(buf[0]);
1403     DO(der_encode_utctime((ltc_utctime*)&rsa_time2, buf[0], &x));
1404     if (x != sizeof(rsa_time2_der) || memcmp(buf[0], rsa_time2_der, x)) {
1405        fprintf(stderr, "UTCTIME encode of rsa_time2 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1406        fprintf(stderr, "\n\n");
1407        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1408        fprintf(stderr, "\n");
1409        return 1;
1410     }
1411     DO(der_length_utctime((ltc_utctime*)&rsa_time2, &y));
1412     if (y != x) {
1413        fprintf(stderr, "UTCTIME length failed to match for rsa_time2: %lu, %lu\n", x, y);
1414        return 1;
1415     }
1416     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1417     if (y != x || memcmp(&rsa_time2, &tmp_time, sizeof(ltc_utctime))) {
1418        fprintf(stderr, "UTCTIME decode failed for rsa_time2: %lu %lu\n", x, y);
1419  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1420  tmp_time.YY,
1421  tmp_time.MM,
1422  tmp_time.DD,
1423  tmp_time.hh,
1424  tmp_time.mm,
1425  tmp_time.ss,
1426  tmp_time.off_dir,
1427  tmp_time.off_mm,
1428  tmp_time.off_hh);
1429        return 1;
1430     }
1431       x = sizeof(utf8_buf);
1432       DO(der_encode_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), utf8_buf, &x));
1433       DO(der_length_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), &y));
1434       if (x != sizeof(utf8_1_der) || memcmp(utf8_buf, utf8_1_der, x) || x != y) {
1435          fprintf(stderr, "DER UTF8_1 encoded to %lu bytes\n", x);
1436          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1437          fprintf(stderr, "\n");
1438          return 1;
1439       }
1440       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1441       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1442       if (y != (sizeof(utf8_1) / sizeof(utf8_1[0])) || memcmp(utf8_1, utf8_out, y * sizeof(wchar_t))) {
1443          fprintf(stderr, "DER UTF8_1 decoded to %lu wchar_t\n", y);
1444          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1445          fprintf(stderr, "\n");
1446          return 1;
1447       }
1448       x = sizeof(utf8_buf);
1449       DO(der_encode_utf8_string(utf8_2, sizeof(utf8_2) / sizeof(utf8_2[0]), utf8_buf, &x));
1450       if (x != sizeof(utf8_2_der) || memcmp(utf8_buf, utf8_2_der, x)) {
1451          fprintf(stderr, "DER UTF8_2 encoded to %lu bytes\n", x);
1452          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1453          fprintf(stderr, "\n");
1454          return 1;
1455       }
1456       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1457       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1458       if (y != (sizeof(utf8_2) / sizeof(utf8_2[0])) || memcmp(utf8_2, utf8_out, y * sizeof(wchar_t))) {
1459          fprintf(stderr, "DER UTF8_2 decoded to %lu wchar_t\n", y);
1460          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1461          fprintf(stderr, "\n");
1462          return 1;
1463       }
1464       x = sizeof(utf8_buf);
1465       DO(der_encode_utf8_string(utf8_3, sizeof(utf8_3) / sizeof(utf8_3[0]), utf8_buf, &x));
1466       if (x != sizeof(utf8_3_der) || memcmp(utf8_buf, utf8_3_der, x)) {
1467          fprintf(stderr, "DER UTF8_3 encoded to %lu bytes\n", x);
1468          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1469          fprintf(stderr, "\n");
1470          return 1;
1471       }
1472       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1473       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1474       if (y != (sizeof(utf8_3) / sizeof(utf8_3[0])) || memcmp(utf8_3, utf8_out, y * sizeof(wchar_t))) {
1475          fprintf(stderr, "DER UTF8_3 decoded to %lu wchar_t\n", y);
1476          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1477          fprintf(stderr, "\n");
1478          return 1;
1479       }
1480     der_set_test();
1481     der_flexi_test();
1482     return der_choice_n_custom_test();
1483  }
1484  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</div>
                </div>
                <div class="column column_space"><pre><code>760     s_der_tests_print_flexi(list, 0);
761     fprintf(stderr, "\n\n");
762  #endif
763     der_sequence_free(list);
</pre></code></div>
                <div class="column column_space"><pre><code>907     s_der_tests_print_flexi(list, 0);
908     fprintf(stderr, "\n\n");
909  #endif
910     if (list->child == NULL || list->child->next == NULL)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    