
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pbes2.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PBES
3  static const char * const s_oid_pbes2 =  "1.2.840.113549.1.5.13";
4  static const char * const s_oid_pbkdf2 = "1.2.840.113549.1.5.12";
5  typedef struct {
6     const char *oid;
7     const char *id;
8  } oid_id_st;
9  static const oid_id_st s_hmac_oid_names[] = {
10     { "1.2.840.113549.2.7",  "sha1" },
11     { "1.2.840.113549.2.8",  "sha224" },
12     { "1.2.840.113549.2.9",  "sha256" },
13     { "1.2.840.113549.2.10", "sha384" },
14     { "1.2.840.113549.2.11", "sha512" },
15     { "1.2.840.113549.2.12", "sha512-224" },
16     { "1.2.840.113549.2.13", "sha512-256" },
17  };
18  static const pbes_properties s_pbes2_default_types[] = {
19     { pkcs_5_alg2, "sha1",   "des",   8, 0 },
20     { pkcs_5_alg2, "sha1",   "rc2",   4, 0 },
21     { pkcs_5_alg2, "sha1",   "3des", 24, 0 },
22     { pkcs_5_alg2, "sha1",   "aes",  16, 0 },
23     { pkcs_5_alg2, "sha1",   "aes",  24, 0 },
24     { pkcs_5_alg2, "sha1",   "aes",  32, 0 },
25  };
26  typedef struct {
27     const pbes_properties *data;
28     const char* oid;
29  } oid_to_pbes;
30  static const oid_to_pbes s_pbes2_list[] = {
31     { &s_pbes2_default_types[0], "1.3.14.3.2.7"            },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.3.14.3.2.7            desCBC */
32     { &s_pbes2_default_types[1], "1.2.840.113549.3.2"      },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.2.840.113549.3.2      rc2CBC */
33     { &s_pbes2_default_types[2], "1.2.840.113549.3.7"      },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/1.2.840.113549.3.7      des-EDE3-CBC */
34     { &s_pbes2_default_types[3], "2.16.840.1.101.3.4.1.2"  },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.2  aes128-CBC */
35     { &s_pbes2_default_types[4], "2.16.840.1.101.3.4.1.22" },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.22 aes192-CBC */
36     { &s_pbes2_default_types[5], "2.16.840.1.101.3.4.1.42" },  &bsol;* http:&bsol;&bsol;www.oid-info.com/get/2.16.840.1.101.3.4.1.42 aes256-CBC */
37  };
38  static int s_pbes2_from_oid(const ltc_asn1_list *cipher_oid, const ltc_asn1_list *hmac_oid, pbes_properties *res)
39  {
40     unsigned int i;
41     for (i = 0; i < sizeof(s_pbes2_list)/sizeof(s_pbes2_list[0]); ++i) {
42        if (pk_oid_cmp_with_asn1(s_pbes2_list[i].oid, cipher_oid) == CRYPT_OK) {
43           *res = *s_pbes2_list[i].data;
44           break;
45        }
46     }
47     if (res->c == NULL) return CRYPT_INVALID_CIPHER;
48     if (hmac_oid != NULL) {
49        for (i = 0; i < sizeof(s_hmac_oid_names)/sizeof(s_hmac_oid_names[0]); ++i) {
50           if (pk_oid_cmp_with_asn1(s_hmac_oid_names[i].oid, hmac_oid) == CRYPT_OK) {
51              res->h = s_hmac_oid_names[i].id;
52              return CRYPT_OK;
53           }
54        }
55        return CRYPT_INVALID_HASH;
56     }
57     return CRYPT_OK;
58  }
59  int pbes2_extract(const ltc_asn1_list *s, pbes_arg *res)
60  {
61     unsigned long klen;
62     ltc_asn1_list *lkdf, *lenc, *loptseq, *liter, *lhmac;
63     int err;
64     LTC_ARGCHK(s   != NULL);
65     LTC_ARGCHK(res != NULL);
66     if ((err = pk_oid_cmp_with_asn1(s_oid_pbes2, s)) != CRYPT_OK) return err;
67     if (!LTC_ASN1_IS_TYPE(s->next, LTC_ASN1_SEQUENCE) ||
68         !LTC_ASN1_IS_TYPE(s->next->child, LTC_ASN1_SEQUENCE) ||
69         !LTC_ASN1_IS_TYPE(s->next->child->child, LTC_ASN1_OBJECT_IDENTIFIER) ||
70         !LTC_ASN1_IS_TYPE(s->next->child->child->next, LTC_ASN1_SEQUENCE) ||
71         !LTC_ASN1_IS_TYPE(s->next->child->next, LTC_ASN1_SEQUENCE) ||
72         !LTC_ASN1_IS_TYPE(s->next->child->next->child, LTC_ASN1_OBJECT_IDENTIFIER)) {
73        return CRYPT_INVALID_PACKET;
74     }
75     lkdf = s->next->child->child;
76     lenc = s->next->child->next->child;
77     if ((err = pk_oid_cmp_with_asn1(s_oid_pbkdf2, lkdf)) != CRYPT_OK) return err;
78     if (!LTC_ASN1_IS_TYPE(lkdf->next, LTC_ASN1_SEQUENCE) ||
79         !LTC_ASN1_IS_TYPE(lkdf->next->child, LTC_ASN1_OCTET_STRING) ||
80         !LTC_ASN1_IS_TYPE(lkdf->next->child->next, LTC_ASN1_INTEGER)) {
81        return CRYPT_INVALID_PACKET;
82     }
83     liter = lkdf->next->child->next;
84     loptseq = liter->next;
85     res->salt = lkdf->next->child;
86     res->iterations = mp_get_int(liter->data);
87     if(LTC_ASN1_IS_TYPE(loptseq, LTC_ASN1_INTEGER)) {
88        loptseq = loptseq->next;
89     }
90     lhmac = NULL;
91     if (LTC_ASN1_IS_TYPE(loptseq, LTC_ASN1_SEQUENCE) &&
92         LTC_ASN1_IS_TYPE(loptseq->child, LTC_ASN1_OBJECT_IDENTIFIER)) {
93        lhmac = loptseq->child;
94     }
95     if ((err = s_pbes2_from_oid(lenc, lhmac, &res->type)) != CRYPT_OK) return err;
96     if (LTC_ASN1_IS_TYPE(lenc->next, LTC_ASN1_OCTET_STRING)) {
97        res->iv = lenc->next;
98     } else if (LTC_ASN1_IS_TYPE(lenc->next, LTC_ASN1_SEQUENCE)) {
99        if (LTC_ASN1_IS_TYPE(lenc->next->child, LTC_ASN1_INTEGER) &&
100            LTC_ASN1_IS_TYPE(lenc->next->child->next, LTC_ASN1_OCTET_STRING)) {
101           klen = mp_get_int(lenc->next->child->data);
102           res->iv   = lenc->next->child->next;
103           switch (klen) {
104              case 160:
105                 res->key_bits = 40;
106                 break;
107              case 120:
108                 res->key_bits = 64;
109                 break;
110              case 58:
111                 res->key_bits = 128;
112                 break;
113              default:
114                 if (klen < 256) return CRYPT_INVALID_KEYSIZE;
115                 res->key_bits = klen;
116                 break;
117           }
118        } else if (LTC_ASN1_IS_TYPE(lenc->next->child, LTC_ASN1_OCTET_STRING)) {
<span onclick='openModal()' class='match'>119           res->iv   = lenc->next->child;
120           res->key_bits = 32;
121        } else {
</span>122           return CRYPT_INVALID_PACKET;
123        }
124     }
125     return CRYPT_OK;
126  }
127  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</h3>
            <pre><code>1  #include <string.h> &bsol;* for memcpy */
2  #include "quicklist.h"
3  #include "zmalloc.h"
4  #include "ziplist.h"
5  #include "util.h" &bsol;* for ll2string */
6  #include "lzf.h"
7  #if defined(REDIS_TEST) || defined(REDIS_TEST_VERBOSE)
8  #include <stdio.h> &bsol;* for printf (debug printing), snprintf (genstr) */
9  #endif
10  #ifndef REDIS_STATIC
11  #define REDIS_STATIC static
12  #endif
13  static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};
14  #define SIZE_SAFETY_LIMIT 8192
15  #define MIN_COMPRESS_BYTES 48
16  #define MIN_COMPRESS_IMPROVE 8
17  #ifndef REDIS_TEST_VERBOSE
18  #define D(...)
19  #else
20  #define D(...)                                                                 \
21      do {                                                                       \
22          printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
23          printf(__VA_ARGS__);                                                   \
24          printf("\n");                                                          \
25      } while (0);
26  #endif
27  #define initEntry(e)                                                           \
28      do {                                                                       \
29          (e)->zi = (e)->value = NULL;                                           \
30          (e)->longval = -123456789;                                             \
31          (e)->quicklist = NULL;                                                 \
32          (e)->node = NULL;                                                      \
33          (e)->offset = 123456789;                                               \
34          (e)->sz = 0;                                                           \
35      } while (0)
36  #if __GNUC__ >= 3
37  #define likely(x) __builtin_expect(!!(x), 1)
38  #define unlikely(x) __builtin_expect(!!(x), 0)
39  #else
40  #define likely(x) (x)
41  #define unlikely(x) (x)
42  #endif
43  quicklist *quicklistCreate(void) {
44      struct quicklist *quicklist;
45      quicklist = zmalloc(sizeof(*quicklist));
46      quicklist->head = quicklist->tail = NULL;
47      quicklist->len = 0;
48      quicklist->count = 0;
49      quicklist->compress = 0;
50      quicklist->fill = -2;
51      return quicklist;
52  }
53  #define COMPRESS_MAX (1 << 16)
54  void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
55      if (compress > COMPRESS_MAX) {
56          compress = COMPRESS_MAX;
57      } else if (compress < 0) {
58          compress = 0;
59      }
60      quicklist->compress = compress;
61  }
62  #define FILL_MAX (1 << 15)
63  void quicklistSetFill(quicklist *quicklist, int fill) {
64      if (fill > FILL_MAX) {
65          fill = FILL_MAX;
66      } else if (fill < -5) {
67          fill = -5;
68      }
69      quicklist->fill = fill;
70  }
71  void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
72      quicklistSetFill(quicklist, fill);
73      quicklistSetCompressDepth(quicklist, depth);
74  }
75  quicklist *quicklistNew(int fill, int compress) {
76      quicklist *quicklist = quicklistCreate();
77      quicklistSetOptions(quicklist, fill, compress);
78      return quicklist;
79  }
80  REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
81      quicklistNode *node;
82      node = zmalloc(sizeof(*node));
83      node->zl = NULL;
84      node->count = 0;
85      node->sz = 0;
86      node->next = node->prev = NULL;
87      node->encoding = QUICKLIST_NODE_ENCODING_RAW;
88      node->container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
89      node->recompress = 0;
90      return node;
91  }
92  PORT_ULONG quicklistCount(const quicklist *ql) { return (PORT_ULONG)(ql->count); } WIN_PORT_FIX &bsol;* cast (unsigned int) */
93  void quicklistRelease(quicklist *quicklist) {
94      PORT_ULONG len;
95      quicklistNode *current, *next;
96      current = quicklist->head;
97      len = quicklist->len;
98      while (len--) {
99          next = current->next;
100          zfree(current->zl);
101          quicklist->count -= current->count;
102          zfree(current);
103          quicklist->len--;
104          current = next;
105      }
106      zfree(quicklist);
107  }
108  REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
109  #ifdef REDIS_TEST
110      node->attempted_compress = 1;
111  #endif
112      if (node->sz < MIN_COMPRESS_BYTES)
113          return 0;
114      quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);
115      if (((lzf->sz = lzf_compress(node->zl, node->sz, lzf->compressed,
116                                   node->sz)) == 0) ||
117          lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
118          zfree(lzf);
119          return 0;
120      }
121      lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
122      zfree(node->zl);
123      node->zl = (unsigned char *)lzf;
124      node->encoding = QUICKLIST_NODE_ENCODING_LZF;
125      node->recompress = 0;
126      return 1;
127  }
128  #define quicklistCompressNode(_node)                                           \
129      do {                                                                       \
130          if ((_node) && (_node)->encoding == QUICKLIST_NODE_ENCODING_RAW) {     \
131              __quicklistCompressNode((_node));                                  \
132          }                                                                      \
133      } while (0)
134  REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
135  #ifdef REDIS_TEST
136      node->attempted_compress = 0;
137  #endif
138      void *decompressed = zmalloc(node->sz);
139      quicklistLZF *lzf = (quicklistLZF *)node->zl;
140      if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
141          zfree(decompressed);
142          return 0;
143      }
144      zfree(lzf);
145      node->zl = decompressed;
146      node->encoding = QUICKLIST_NODE_ENCODING_RAW;
147      return 1;
148  }
149  #define quicklistDecompressNode(_node)                                         \
150      do {                                                                       \
151          if ((_node) && (_node)->encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
152              __quicklistDecompressNode((_node));                                \
153          }                                                                      \
154      } while (0)
155  #define quicklistDecompressNodeForUse(_node)                                   \
156      do {                                                                       \
157          if ((_node) && (_node)->encoding == QUICKLIST_NODE_ENCODING_LZF) {     \
158              __quicklistDecompressNode((_node));                                \
159              (_node)->recompress = 1;                                           \
160          }                                                                      \
161      } while (0)
162  size_t quicklistGetLzf(const quicklistNode *node, void **data) {
163      quicklistLZF *lzf = (quicklistLZF *)node->zl;
164      *data = lzf->compressed;
165      return lzf->sz;
166  }
167  #define quicklistAllowsCompression(_ql) ((_ql)->compress != 0)
168  REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
169                                        quicklistNode *node) {
170      if (!quicklistAllowsCompression(quicklist) ||
171          quicklist->len < (unsigned int)(quicklist->compress * 2))
172          return;
173  #if 0
174      if (quicklist->compress == 1) {
175          quicklistNode *h = quicklist->head, *t = quicklist->tail;
176          quicklistDecompressNode(h);
177          quicklistDecompressNode(t);
178          if (h != node && t != node)
179              quicklistCompressNode(node);
180          return;
181      } else if (quicklist->compress == 2) {
182          quicklistNode *h = quicklist->head, *hn = h->next, *hnn = hn->next;
183          quicklistNode *t = quicklist->tail, *tp = t->prev, *tpp = tp->prev;
184          quicklistDecompressNode(h);
185          quicklistDecompressNode(hn);
186          quicklistDecompressNode(t);
187          quicklistDecompressNode(tp);
188          if (h != node && hn != node && t != node && tp != node) {
189              quicklistCompressNode(node);
190          }
191          if (hnn != t) {
192              quicklistCompressNode(hnn);
193          }
194          if (tpp != h) {
195              quicklistCompressNode(tpp);
196          }
197          return;
198      }
199  #endif
200      quicklistNode *forward = quicklist->head;
201      quicklistNode *reverse = quicklist->tail;
202      int depth = 0;
203      int in_depth = 0;
204      while (depth++ < quicklist->compress) {
205          quicklistDecompressNode(forward);
206          quicklistDecompressNode(reverse);
207          if (forward == node || reverse == node)
208              in_depth = 1;
209          if (forward == reverse)
210              return;
211          forward = forward->next;
212          reverse = reverse->prev;
213      }
214      if (!in_depth)
215          quicklistCompressNode(node);
216      if (depth > 2) {
217          quicklistCompressNode(forward);
218          quicklistCompressNode(reverse);
219      }
220  }
221  #define quicklistCompress(_ql, _node)                                          \
222      do {                                                                       \
223          if ((_node)->recompress)                                               \
224              quicklistCompressNode((_node));                                    \
225          else                                                                   \
226              __quicklistCompress((_ql), (_node));                               \
227      } while (0)
228  #define quicklistRecompressOnly(_ql, _node)                                    \
229      do {                                                                       \
230          if ((_node)->recompress)                                               \
231              quicklistCompressNode((_node));                                    \
232      } while (0)
233  REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
234                                          quicklistNode *old_node,
235                                          quicklistNode *new_node, int after) {
236      if (after) {
237          new_node->prev = old_node;
238          if (old_node) {
239              new_node->next = old_node->next;
240              if (old_node->next)
241                  old_node->next->prev = new_node;
242              old_node->next = new_node;
243          }
244          if (quicklist->tail == old_node)
245              quicklist->tail = new_node;
246      } else {
247          new_node->next = old_node;
248          if (old_node) {
249              new_node->prev = old_node->prev;
250              if (old_node->prev)
251                  old_node->prev->next = new_node;
252              old_node->prev = new_node;
253          }
254          if (quicklist->head == old_node)
255              quicklist->head = new_node;
256      }
257      if (quicklist->len == 0) {
258          quicklist->head = quicklist->tail = new_node;
259      }
260      if (old_node)
261          quicklistCompress(quicklist, old_node);
262      quicklist->len++;
263  }
264  REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
265                                               quicklistNode *old_node,
266                                               quicklistNode *new_node) {
267      __quicklistInsertNode(quicklist, old_node, new_node, 0);
268  }
269  REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
270                                              quicklistNode *old_node,
271                                              quicklistNode *new_node) {
272      __quicklistInsertNode(quicklist, old_node, new_node, 1);
273  }
274  REDIS_STATIC int
275  _quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,
276                                                 const int fill) {
277      if (fill >= 0)
278          return 0;
279      size_t offset = (-fill) - 1;
280      if (offset < (sizeof(optimization_level) / sizeof(*optimization_level))) {
281          if (sz <= optimization_level[offset]) {
282              return 1;
283          } else {
284              return 0;
285          }
286      } else {
287          return 0;
288      }
289  }
290  #define sizeMeetsSafetyLimit(sz) ((sz) <= SIZE_SAFETY_LIMIT)
291  REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
292                                             const int fill, const size_t sz) {
293      if (unlikely(!node))
294          return 0;
295      int ziplist_overhead;
296      if (sz < 254)
297          ziplist_overhead = 1;
298      else
299          ziplist_overhead = 5;
300      if (sz < 64)
301          ziplist_overhead += 1;
302      else if (likely(sz < 16384))
303          ziplist_overhead += 2;
304      else
305          ziplist_overhead += 5;
306      unsigned int new_sz = (unsigned int)(node->sz + sz + ziplist_overhead);     WIN_PORT_FIX &bsol;* cast (unsigned int) */
307      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
308          return 1;
309      else if (!sizeMeetsSafetyLimit(new_sz))
310          return 0;
311      else if ((int)node->count < fill)
312          return 1;
313      else
314          return 0;
315  }
316  REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
317                                            const quicklistNode *b,
318                                            const int fill) {
319      if (!a || !b)
320          return 0;
321      unsigned int merge_sz = a->sz + b->sz - 11;
322      if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))
323          return 1;
324      else if (!sizeMeetsSafetyLimit(merge_sz))
325          return 0;
326      else if ((int)(a->count + b->count) <= fill)
327          return 1;
328      else
329          return 0;
330  }
331  #define quicklistNodeUpdateSz(node)                                            \
332      do {                                                                       \
333          (node)->sz = ziplistBlobLen((node)->zl);                               \
334      } while (0)
335  int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
336      quicklistNode *orig_head = quicklist->head;
337      if (likely(
338              _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
339          quicklist->head->zl =
340              ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);
341          quicklistNodeUpdateSz(quicklist->head);
342      } else {
343          quicklistNode *node = quicklistCreateNode();
344          node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
345          quicklistNodeUpdateSz(node);
346          _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
347      }
348      quicklist->count++;
349      quicklist->head->count++;
350      return (orig_head != quicklist->head);
351  }
352  int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
353      quicklistNode *orig_tail = quicklist->tail;
354      if (likely(
355              _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
356          quicklist->tail->zl =
357              ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);
358          quicklistNodeUpdateSz(quicklist->tail);
359      } else {
360          quicklistNode *node = quicklistCreateNode();
361          node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);
362          quicklistNodeUpdateSz(node);
363          _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
364      }
365      quicklist->count++;
366      quicklist->tail->count++;
367      return (orig_tail != quicklist->tail);
368  }
369  void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
370      quicklistNode *node = quicklistCreateNode();
371      node->zl = zl;
372      node->count = ziplistLen(node->zl);
373      node->sz = ziplistBlobLen(zl);
374      _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
375      quicklist->count += node->count;
376  }
377  quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
378                                              unsigned char *zl) {
379      unsigned char *value;
380      unsigned int sz;
381      PORT_LONGLONG longval;
382      char longstr[32] = {0};
383      unsigned char *p = ziplistIndex(zl, 0);
384      while (ziplistGet(p, &value, &sz, &longval)) {
385          if (!value) {
386              sz = ll2string(longstr, sizeof(longstr), longval);
387              value = (unsigned char *)longstr;
388          }
389          quicklistPushTail(quicklist, value, sz);
390          p = ziplistNext(zl, p);
391      }
392      zfree(zl);
393      return quicklist;
394  }
395  quicklist *quicklistCreateFromZiplist(int fill, int compress,
396                                        unsigned char *zl) {
397      return quicklistAppendValuesFromZiplist(quicklistNew(fill, compress), zl);
398  }
399  #define quicklistDeleteIfEmpty(ql, n)                                          \
400      do {                                                                       \
401          if ((n)->count == 0) {                                                 \
402              __quicklistDelNode((ql), (n));                                     \
403              (n) = NULL;                                                        \
404          }                                                                      \
405      } while (0)
406  REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
407                                       quicklistNode *node) {
408      if (node->next)
409          node->next->prev = node->prev;
410      if (node->prev)
411          node->prev->next = node->next;
412      if (node == quicklist->tail) {
413          quicklist->tail = node->prev;
414      }
415      if (node == quicklist->head) {
416          quicklist->head = node->next;
417      }
418      __quicklistCompress(quicklist, NULL);
419      quicklist->count -= node->count;
420      zfree(node->zl);
421      zfree(node);
422      quicklist->len--;
423  }
424  REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
425                                     unsigned char **p) {
426      int gone = 0;
427      node->zl = ziplistDelete(node->zl, p);
428      node->count--;
429      if (node->count == 0) {
430          gone = 1;
431          __quicklistDelNode(quicklist, node);
432      } else {
433          quicklistNodeUpdateSz(node);
434      }
435      quicklist->count--;
436      return gone ? 1 : 0;
437  }
438  void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
439      quicklistNode *prev = entry->node->prev;
440      quicklistNode *next = entry->node->next;
441      int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,
442                                           entry->node, &entry->zi);
443      iter->zi = NULL;
444      if (deleted_node) {
445          if (iter->direction == AL_START_HEAD) {
446              iter->current = next;
447              iter->offset = 0;
448          } else if (iter->direction == AL_START_TAIL) {
449              iter->current = prev;
450              iter->offset = -1;
451          }
452      }
453  }
454  int quicklistReplaceAtIndex(quicklist *quicklist, PORT_LONG index, void *data,
455                              int sz) {
456      quicklistEntry entry;
457      if (likely(quicklistIndex(quicklist, index, &entry))) {
458          entry.node->zl = ziplistDelete(entry.node->zl, &entry.zi);
459          entry.node->zl = ziplistInsert(entry.node->zl, entry.zi, data, sz);
460          quicklistNodeUpdateSz(entry.node);
461          quicklistCompress(quicklist, entry.node);
462          return 1;
463      } else {
464          return 0;
465      }
466  }
467  REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,
468                                                     quicklistNode *a,
469                                                     quicklistNode *b) {
470      D("Requested merge (a,b) (%u, %u)", a->count, b->count);
471      quicklistDecompressNode(a);
472      quicklistDecompressNode(b);
473      if ((ziplistMerge(&a->zl, &b->zl))) {
474          quicklistNode *keep = NULL, *nokeep = NULL;
475          if (!a->zl) {
476              nokeep = a;
477              keep = b;
478          } else if (!b->zl) {
479              nokeep = b;
480              keep = a;
481          }
482          keep->count = ziplistLen(keep->zl);
483          quicklistNodeUpdateSz(keep);
484          nokeep->count = 0;
485          __quicklistDelNode(quicklist, nokeep);
486          quicklistCompress(quicklist, keep);
487          return keep;
488      } else {
489          return NULL;
490      }
491  }
492  REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
493                                         quicklistNode *center) {
494      int fill = quicklist->fill;
495      quicklistNode *prev, *prev_prev, *next, *next_next, *target;
496      prev = prev_prev = next = next_next = target = NULL;
497      if (center->prev) {
498          prev = center->prev;
499          if (center->prev->prev)
500              prev_prev = center->prev->prev;
501      }
502      if (center->next) {
503          next = center->next;
504          if (center->next->next)
505              next_next = center->next->next;
506      }
507      if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
508          _quicklistZiplistMerge(quicklist, prev_prev, prev);
509          prev_prev = prev = NULL; &bsol;* they could have moved, invalidate them. */
510      }
511      if (_quicklistNodeAllowMerge(next, next_next, fill)) {
512          _quicklistZiplistMerge(quicklist, next, next_next);
513          next = next_next = NULL; &bsol;* they could have moved, invalidate them. */
514      }
515      if (_quicklistNodeAllowMerge(center, center->prev, fill)) {
516          target = _quicklistZiplistMerge(quicklist, center->prev, center);
517          center = NULL; &bsol;* center could have been deleted, invalidate it. */
518      } else {
519          target = center;
520      }
521      if (_quicklistNodeAllowMerge(target, target->next, fill)) {
522          _quicklistZiplistMerge(quicklist, target, target->next);
523      }
524  }
525  REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
526                                                  int after) {
527      size_t zl_sz = node->sz;
528      quicklistNode *new_node = quicklistCreateNode();
529      new_node->zl = zmalloc(zl_sz);
530      memcpy(new_node->zl, node->zl, zl_sz);
531      int orig_start = after ? offset + 1 : 0;
532      int orig_extent = after ? -1 : offset;
533      int new_start = after ? 0 : offset;
534      int new_extent = after ? offset + 1 : -1;
535      D("After %d (%d); ranges: [%d, %d], [%d, %d]", after, offset, orig_start,
536        orig_extent, new_start, new_extent);
537      node->zl = ziplistDeleteRange(node->zl, orig_start, orig_extent);
538      node->count = ziplistLen(node->zl);
539      quicklistNodeUpdateSz(node);
540      new_node->zl = ziplistDeleteRange(new_node->zl, new_start, new_extent);
541      new_node->count = ziplistLen(new_node->zl);
542      quicklistNodeUpdateSz(new_node);
543      D("After split lengths: orig (%d), new (%d)", node->count, new_node->count);
544      return new_node;
545  }
546  REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
547                                     void *value, const size_t sz, int after) {
548      int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;
549      int fill = quicklist->fill;
550      quicklistNode *node = entry->node;
551      quicklistNode *new_node = NULL;
552      if (!node) {
553          D("No node given!");
554          new_node = quicklistCreateNode();
555          new_node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
556          __quicklistInsertNode(quicklist, NULL, new_node, after);
557          new_node->count++;
558          quicklist->count++;
559          return;
560      }
561      if (!_quicklistNodeAllowInsert(node, fill, sz)) {
562          D("Current node is full with count %d with requested fill %Iu",                    WIN_PORT_FIX &bsol;* %lu -> %Iu */
563            node->count, fill);
564          full = 1;
565      }
566      if (after && (entry->offset == node->count)) {
567          D("At Tail of current ziplist");
568          at_tail = 1;
569          if (!_quicklistNodeAllowInsert(node->next, fill, sz)) {
570              D("Next node is full too.");
571              full_next = 1;
572          }
573      }
574      if (!after && (entry->offset == 0)) {
575          D("At Head");
576          at_head = 1;
577          if (!_quicklistNodeAllowInsert(node->prev, fill, sz)) {
578              D("Prev node is full too.");
579              full_prev = 1;
580          }
581      }
582      if (!full && after) {
583          D("Not full, inserting after current position.");
584          quicklistDecompressNodeForUse(node);
585          unsigned char *next = ziplistNext(node->zl, entry->zi);
586          if (next == NULL) {
587              node->zl = ziplistPush(node->zl, value, sz, ZIPLIST_TAIL);
588          } else {
589              node->zl = ziplistInsert(node->zl, next, value, sz);
590          }
591          node->count++;
592          quicklistNodeUpdateSz(node);
593          quicklistRecompressOnly(quicklist, node);
594      } else if (!full && !after) {
595          D("Not full, inserting before current position.");
596          quicklistDecompressNodeForUse(node);
597          node->zl = ziplistInsert(node->zl, entry->zi, value, sz);
598          node->count++;
599          quicklistNodeUpdateSz(node);
600          quicklistRecompressOnly(quicklist, node);
601      } else if (full && at_tail && node->next && !full_next && after) {
602          D("Full and tail, but next isn't full; inserting next node head");
603          new_node = node->next;
604          quicklistDecompressNodeForUse(new_node);
605          new_node->zl = ziplistPush(new_node->zl, value, sz, ZIPLIST_HEAD);
606          new_node->count++;
607          quicklistNodeUpdateSz(new_node);
608          quicklistRecompressOnly(quicklist, new_node);
609      } else if (full && at_head && node->prev && !full_prev && !after) {
610          D("Full and head, but prev isn't full, inserting prev node tail");
611          new_node = node->prev;
612          quicklistDecompressNodeForUse(new_node);
613          new_node->zl = ziplistPush(new_node->zl, value, sz, ZIPLIST_TAIL);
614          new_node->count++;
615          quicklistNodeUpdateSz(new_node);
616          quicklistRecompressOnly(quicklist, new_node);
617      } else if (full && ((at_tail && node->next && full_next && after) ||
618                          (at_head && node->prev && full_prev && !after))) {
619          D("\tprovisioning new node...");
620          new_node = quicklistCreateNode();
621          new_node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
622          new_node->count++;
623          quicklistNodeUpdateSz(new_node);
624          __quicklistInsertNode(quicklist, node, new_node, after);
625      } else if (full) {
626          D("\tsplitting node...");
627          quicklistDecompressNodeForUse(node);
628          new_node = _quicklistSplitNode(node, entry->offset, after);
629          new_node->zl = ziplistPush(new_node->zl, value, sz,
630                                     after ? ZIPLIST_HEAD : ZIPLIST_TAIL);
631          new_node->count++;
632          quicklistNodeUpdateSz(new_node);
633          __quicklistInsertNode(quicklist, node, new_node, after);
634          _quicklistMergeNodes(quicklist, node);
635      }
636      quicklist->count++;
637  }
638  void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,
639                             void *value, const size_t sz) {
640      _quicklistInsert(quicklist, entry, value, sz, 0);
641  }
642  void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
643                            void *value, const size_t sz) {
644      _quicklistInsert(quicklist, entry, value, sz, 1);
645  }
646  int quicklistDelRange(quicklist *quicklist, const PORT_LONG start,
647                        const PORT_LONG count) {
648      if (count <= 0)
649          return 0;
650      PORT_ULONG extent = count; &bsol;* range is inclusive of start position */
651      if (start >= 0 && extent > (quicklist->count - start)) {
652          extent = quicklist->count - start;
653      } else if (start < 0 && extent > (PORT_ULONG)(-start)) {
654          extent = -start; &bsol;* c.f. LREM -29 29; just delete until end. */
655      }
656      quicklistEntry entry;
657      if (!quicklistIndex(quicklist, start, &entry))
658          return 0;
659      D("Quicklist delete request for start %Id, count %Id, extent: %Id", start,                 WIN_PORT_FIX &bsol;* %ld -> %Id */
660        count, extent);
661      quicklistNode *node = entry.node;
662      while (extent) {
663          quicklistNode *next = node->next;
664          PORT_ULONG del;
665          int delete_entire_node = 0;
666          if (entry.offset == 0 && extent >= node->count) {
667              delete_entire_node = 1;
668              del = node->count;
669          } else if (entry.offset >= 0 && extent >= node->count) {
670              del = node->count - entry.offset;
671          } else if (entry.offset < 0) {
672              del = -entry.offset;
673              if (del > extent)
674                  del = extent;
675          } else {
676              del = extent;
677          }
678          D("[%Id]: asking to del: %Id because offset: %d; (ENTIRE NODE: %d), "                             WIN_PORT_FIX &bsol;* %ld -> %Id */
679            "node count: %u",
680            extent, del, entry.offset, delete_entire_node, node->count);
681          if (delete_entire_node) {
682              __quicklistDelNode(quicklist, node);
683          } else {
684              quicklistDecompressNodeForUse(node);
685              node->zl = ziplistDeleteRange(node->zl, entry.offset, del);
686              quicklistNodeUpdateSz(node);
687              node->count -= del;
688              quicklist->count -= del;
689              quicklistDeleteIfEmpty(quicklist, node);
690              if (node)
691                  quicklistRecompressOnly(quicklist, node);
692          }
693          extent -= del;
694          node = next;
695          entry.offset = 0;
696      }
697      return 1;
698  }
699  int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
700      return ziplistCompare(p1, p2, p2_len);
701  }
702  quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {
703      quicklistIter *iter;
704      iter = zmalloc(sizeof(*iter));
705      if (direction == AL_START_HEAD) {
706          iter->current = quicklist->head;
707          iter->offset = 0;
708      } else if (direction == AL_START_TAIL) {
709          iter->current = quicklist->tail;
710          iter->offset = -1;
711      }
712      iter->direction = direction;
713      iter->quicklist = quicklist;
714      iter->zi = NULL;
715      return iter;
716  }
717  quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,
718                                           const int direction,
719                                           const PORT_LONGLONG idx) {
720      quicklistEntry entry;
721      if (quicklistIndex(quicklist, idx, &entry)) {
722          quicklistIter *base = quicklistGetIterator(quicklist, direction);
723          base->zi = NULL;
724          base->current = entry.node;
725          base->offset = entry.offset;
726          return base;
727      } else {
728          return NULL;
729      }
730  }
731  void quicklistReleaseIterator(quicklistIter *iter) {
732      if (iter->current)
733          quicklistCompress(iter->quicklist, iter->current);
734      zfree(iter);
735  }
736  int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
737      initEntry(entry);
738      if (!iter) {
739          D("Returning because no iter!");
740          return 0;
741      }
742      entry->quicklist = iter->quicklist;
743      entry->node = iter->current;
744      if (!iter->current) {
745          D("Returning because current node is NULL")
746          return 0;
747      }
748      unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
749      int offset_update = 0;
750      if (!iter->zi) {
751          quicklistDecompressNodeForUse(iter->current);
752          iter->zi = ziplistIndex(iter->current->zl, iter->offset);
753      } else {
754          if (iter->direction == AL_START_HEAD) {
755              nextFn = ziplistNext;
756              offset_update = 1;
757          } else if (iter->direction == AL_START_TAIL) {
758              nextFn = ziplistPrev;
759              offset_update = -1;
760          }
761          iter->zi = nextFn(iter->current->zl, iter->zi);
762          iter->offset += offset_update;
763      }
764      entry->zi = iter->zi;
765      entry->offset = iter->offset;
766      if (iter->zi) {
767          ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval);
768          return 1;
769      } else {
770          quicklistCompress(iter->quicklist, iter->current);
771          if (iter->direction == AL_START_HEAD) {
772              D("Jumping to start of next node");
<span onclick='openModal()' class='match'>773              iter->current = iter->current->next;
774              iter->offset = 0;
775          } else if (iter->direction == AL_START_TAIL) {
</span>776              D("Jumping to end of previous node");
777              iter->current = iter->current->prev;
778              iter->offset = -1;
779          }
780          iter->zi = NULL;
781          return quicklistNext(iter, entry);
782      }
783  }
784  quicklist *quicklistDup(quicklist *orig) {
785      quicklist *copy;
786      copy = quicklistNew(orig->fill, orig->compress);
787      for (quicklistNode *current = orig->head; current;
788           current = current->next) {
789          quicklistNode *node = quicklistCreateNode();
790          if (current->encoding == QUICKLIST_NODE_ENCODING_LZF) {
791              quicklistLZF *lzf = (quicklistLZF *)current->zl;
792              size_t lzf_sz = sizeof(*lzf) + lzf->sz;
793              node->zl = zmalloc(lzf_sz);
794              memcpy(node->zl, current->zl, lzf_sz);
795          } else if (current->encoding == QUICKLIST_NODE_ENCODING_RAW) {
796              node->zl = zmalloc(current->sz);
797              memcpy(node->zl, current->zl, current->sz);
798          }
799          node->count = current->count;
800          copy->count += node->count;
801          node->sz = current->sz;
802          node->encoding = current->encoding;
803          _quicklistInsertNodeAfter(copy, copy->tail, node);
804      }
805      return copy;
806  }
807  int quicklistIndex(const quicklist *quicklist, const PORT_LONGLONG idx,
808                     quicklistEntry *entry) {
809      quicklistNode *n;
810      PORT_ULONGLONG accum = 0;
811      PORT_ULONGLONG index;
812      int forward = idx < 0 ? 0 : 1; &bsol;* < 0 -> reverse, 0+ -> forward */
813      initEntry(entry);
814      entry->quicklist = quicklist;
815      if (!forward) {
816          index = (-idx) - 1;
817          n = quicklist->tail;
818      } else {
819          index = idx;
820          n = quicklist->head;
821      }
822      if (index >= quicklist->count)
823          return 0;
824      while (likely(n)) {
825          if ((accum + n->count) > index) {
826              break;
827          } else {
828              D("Skipping over (%p) %u at accum %lld", (void *)n, n->count,
829                accum);
830              accum += n->count;
831              n = forward ? n->next : n->prev;
832          }
833      }
834      if (!n)
835          return 0;
836      D("Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu", (void *)n,
837        accum, index, index - accum, (-index) - 1 + accum);
838      entry->node = n;
839      if (forward) {
840          entry->offset = index - accum;
841      } else {
842          entry->offset = (-index) - 1 + accum;
843      }
844      quicklistDecompressNodeForUse(entry->node);
845      entry->zi = ziplistIndex(entry->node->zl, entry->offset);
846      ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval);
847      return 1;
848  }
849  void quicklistRotate(quicklist *quicklist) {
850      if (quicklist->count <= 1)
851          return;
852      unsigned char *p = ziplistIndex(quicklist->tail->zl, -1);
853      unsigned char *value;
854      PORT_LONGLONG longval;
855      unsigned int sz;
856      char longstr[32] = {0};
857      ziplistGet(p, &value, &sz, &longval);
858      if (!value) {
859          sz = ll2string(longstr, sizeof(longstr), longval);
860          value = (unsigned char *)longstr;
861      }
862      quicklistPushHead(quicklist, value, sz);
863      if (quicklist->len == 1) {
864          p = ziplistIndex(quicklist->tail->zl, -1);
865      }
866      quicklistDelIndex(quicklist, quicklist->tail, &p);
867  }
868  int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
869                         unsigned int *sz, PORT_LONGLONG *sval,
870                         void *(*saver)(unsigned char *data, unsigned int sz)) {
871      unsigned char *p;
872      unsigned char *vstr;
873      unsigned int vlen;
874      PORT_LONGLONG vlong;
875      int pos = (where == QUICKLIST_HEAD) ? 0 : -1;
876      if (quicklist->count == 0)
877          return 0;
878      if (data)
879          *data = NULL;
880      if (sz)
881          *sz = 0;
882      if (sval)
883          *sval = -123456789;
884      quicklistNode *node;
885      if (where == QUICKLIST_HEAD && quicklist->head) {
886          node = quicklist->head;
887      } else if (where == QUICKLIST_TAIL && quicklist->tail) {
888          node = quicklist->tail;
889      } else {
890          return 0;
891      }
892      p = ziplistIndex(node->zl, pos);
893      if (ziplistGet(p, &vstr, &vlen, &vlong)) {
894          if (vstr) {
895              if (data)
896                  *data = saver(vstr, vlen);
897              if (sz)
898                  *sz = vlen;
899          } else {
900              if (data)
901                  *data = NULL;
902              if (sval)
903                  *sval = vlong;
904          }
905          quicklistDelIndex(quicklist, node, &p);
906          return 1;
907      }
908      return 0;
909  }
910  REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {
911      unsigned char *vstr;
912      if (data) {
913          vstr = zmalloc(sz);
914          memcpy(vstr, data, sz);
915          return vstr;
916      }
917      return NULL;
918  }
919  int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
920                   unsigned int *sz, PORT_LONGLONG *slong) {
921      unsigned char *vstr;
922      unsigned int vlen;
923      PORT_LONGLONG vlong;
924      if (quicklist->count == 0)
925          return 0;
926      int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,
927                                   _quicklistSaver);
928      if (data)
929          *data = vstr;
930      if (slong)
931          *slong = vlong;
932      if (sz)
933          *sz = vlen;
934      return ret;
935  }
936  void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
937                     int where) {
938      if (where == QUICKLIST_HEAD) {
939          quicklistPushHead(quicklist, value, sz);
940      } else if (where == QUICKLIST_TAIL) {
941          quicklistPushTail(quicklist, value, sz);
942      }
943  }
944  #ifdef REDIS_TEST
945  #include <stdint.h>
946  #include <sys/time.h>
947  #define assert(_e)                                                             \
948      do {                                                                       \
949          if (!(_e)) {                                                           \
950              printf("\n\n=== ASSERTION FAILED ===\n");                          \
951              printf("==> %s:%d '%s' is not true\n", __FILE__, __LINE__, #_e);   \
952              err++;                                                             \
953          }                                                                      \
954      } while (0)
955  #define yell(str, ...) printf("ERROR! " str "\n\n", __VA_ARGS__)
956  #define OK printf("\tOK\n")
957  #define ERROR                                                                  \
958      do {                                                                       \
959          printf("\tERROR!\n");                                                  \
960          err++;                                                                 \
961      } while (0)
962  #define ERR(x, ...)                                                            \
963      do {                                                                       \
964          printf("%s:%s:%d:\t", __FILE__, __FUNCTION__, __LINE__);               \
965          printf("ERROR! " x "\n", __VA_ARGS__);                                 \
966          err++;                                                                 \
967      } while (0)
968  #define TEST(name) printf("test  %s\n", name);
969  #define TEST_DESC(name, ...) printf("test  " name "\n", __VA_ARGS__);
970  #define QL_TEST_VERBOSE 0
971  #define UNUSED(x) (void)(x)
972  static void ql_info(quicklist *ql) {
973  #if QL_TEST_VERBOSE
974      printf("Container length: %lu\n", ql->len);
975      printf("Container size: %lu\n", ql->count);
976      if (ql->head)
977          printf("\t(zsize head: %d)\n", ziplistLen(ql->head->zl));
978      if (ql->tail)
979          printf("\t(zsize tail: %d)\n", ziplistLen(ql->tail->zl));
980      printf("\n");
981  #else
982      UNUSED(ql);
983  #endif
984  }
985  static PORT_LONGLONG ustime(void) {
986      struct timeval tv;
987      PORT_LONGLONG ust;
988      gettimeofday(&tv, NULL);
989      ust = ((PORT_LONGLONG)tv.tv_sec) * 1000000;
990      ust += tv.tv_usec;
991      return ust;
992  }
993  static PORT_LONGLONG mstime(void) { return ustime() / 1000; }
994  static int _itrprintr(quicklist *ql, int print, int forward) {
995      quicklistIter *iter =
996          quicklistGetIterator(ql, forward ? AL_START_HEAD : AL_START_TAIL);
997      quicklistEntry entry;
998      int i = 0;
999      int p = 0;
1000      quicklistNode *prev = NULL;
1001      while (quicklistNext(iter, &entry)) {
1002          if (entry.node != prev) {
1003              p++;
1004              prev = entry.node;
1005          }
1006          if (print) {
1007              printf("[%3d (%2d)]: [%.*s] (%lld)\n", i, p, entry.sz,
1008                     (char *)entry.value, entry.longval);
1009          }
1010          i++;
1011      }
1012      quicklistReleaseIterator(iter);
1013      return i;
1014  }
1015  static int itrprintr(quicklist *ql, int print) {
1016      return _itrprintr(ql, print, 1);
1017  }
1018  static int itrprintr_rev(quicklist *ql, int print) {
1019      return _itrprintr(ql, print, 0);
1020  }
1021  #define ql_verify(a, b, c, d, e)                                               \
1022      do {                                                                       \
1023          err += _ql_verify((a), (b), (c), (d), (e));                            \
1024      } while (0)
1025  static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
1026                        uint32_t head_count, uint32_t tail_count) {
1027      int errors = 0;
1028      ql_info(ql);
1029      if (len != ql->len) {
1030          yell("quicklist length wrong: expected %d, got %u", len, ql->len);
1031          errors++;
1032      }
1033      if (count != ql->count) {
1034          yell("quicklist count wrong: expected %d, got %lu", count, ql->count);
1035          errors++;
1036      }
1037      int loopr = itrprintr(ql, 0);
1038      if (loopr != (int)ql->count) {
1039          yell("quicklist cached count not match actual count: expected %lu, got "
1040               "%d",
1041               ql->count, loopr);
1042          errors++;
1043      }
1044      int rloopr = itrprintr_rev(ql, 0);
1045      if (loopr != rloopr) {
1046          yell("quicklist has different forward count than reverse count!  "
1047               "Forward count is %d, reverse count is %d.",
1048               loopr, rloopr);
1049          errors++;
1050      }
1051      if (ql->len == 0 && !errors) {
1052          OK;
1053          return errors;
1054      }
1055      if (ql->head && head_count != ql->head->count &&
1056          head_count != ziplistLen(ql->head->zl)) {
1057          yell("quicklist head count wrong: expected %d, "
1058               "got cached %d vs. actual %d",
1059               head_count, ql->head->count, ziplistLen(ql->head->zl));
1060          errors++;
1061      }
1062      if (ql->tail && tail_count != ql->tail->count &&
1063          tail_count != ziplistLen(ql->tail->zl)) {
1064          yell("quicklist tail count wrong: expected %d, "
1065               "got cached %u vs. actual %d",
1066               tail_count, ql->tail->count, ziplistLen(ql->tail->zl));
1067          errors++;
1068      }
1069      if (quicklistAllowsCompression(ql)) {
1070          quicklistNode *node = ql->head;
1071          unsigned int low_raw = ql->compress;
1072          unsigned int high_raw = ql->len - ql->compress;
1073          for (unsigned int at = 0; at < ql->len; at++, node = node->next) {
1074              if (node && (at < low_raw || at >= high_raw)) {
1075                  if (node->encoding != QUICKLIST_NODE_ENCODING_RAW) {
1076                      yell("Incorrect compression: node %d is "
1077                           "compressed at depth %d ((%u, %u); total "
1078                           "nodes: %u; size: %u; recompress: %d)",
1079                           at, ql->compress, low_raw, high_raw, ql->len, node->sz,
1080                           node->recompress);
1081                      errors++;
1082                  }
1083              } else {
1084                  if (node->encoding != QUICKLIST_NODE_ENCODING_LZF &&
1085                      !node->attempted_compress) {
1086                      yell("Incorrect non-compression: node %d is NOT "
1087                           "compressed at depth %d ((%u, %u); total "
1088                           "nodes: %u; size: %u; recompress: %d; attempted: %d)",
1089                           at, ql->compress, low_raw, high_raw, ql->len, node->sz,
1090                           node->recompress, node->attempted_compress);
1091                      errors++;
1092                  }
1093              }
1094          }
1095      }
1096      if (!errors)
1097          OK;
1098      return errors;
1099  }
1100  static char *genstr(char *prefix, int i) {
1101      static char result[64] = {0};
1102      snprintf(result, sizeof(result), "%s%d", prefix, i);
1103      return result;
1104  }
1105  int quicklistTest(int argc, char *argv[]) {
1106      UNUSED(argc);
1107      UNUSED(argv);
1108      unsigned int err = 0;
1109      int optimize_start =
1110          -(int)(sizeof(optimization_level) / sizeof(*optimization_level));
1111      printf("Starting optimization offset at: %d\n", optimize_start);
1112      int options[] = {0, 1, 2, 3, 4, 5, 6, 10};
1113      size_t option_count = sizeof(options) / sizeof(*options);
1114      PORT_LONGLONG runtime[option_count];
1115      for (int _i = 0; _i < (int)option_count; _i++) {
1116          printf("Testing Option %d\n", options[_i]);
1117          PORT_LONGLONG start = mstime();
1118          TEST("create list") {
1119              quicklist *ql = quicklistNew(-2, options[_i]);
1120              ql_verify(ql, 0, 0, 0, 0);
1121              quicklistRelease(ql);
1122          }
1123          TEST("add to tail of empty list") {
1124              quicklist *ql = quicklistNew(-2, options[_i]);
1125              quicklistPushTail(ql, "hello", 6);
1126              ql_verify(ql, 1, 1, 1, 1);
1127              quicklistRelease(ql);
1128          }
1129          TEST("add to head of empty list") {
1130              quicklist *ql = quicklistNew(-2, options[_i]);
1131              quicklistPushHead(ql, "hello", 6);
1132              ql_verify(ql, 1, 1, 1, 1);
1133              quicklistRelease(ql);
1134          }
1135          for (int f = optimize_start; f < 32; f++) {
1136              TEST_DESC("add to tail 5x at fill %d at compress %d", f,
1137                        options[_i]) {
1138                  quicklist *ql = quicklistNew(f, options[_i]);
1139                  for (int i = 0; i < 5; i++)
1140                      quicklistPushTail(ql, genstr("hello", i), 32);
1141                  if (ql->count != 5)
1142                      ERROR;
1143                  if (f == 32)
1144                      ql_verify(ql, 1, 5, 5, 5);
1145                  quicklistRelease(ql);
1146              }
1147          }
1148          for (int f = optimize_start; f < 32; f++) {
1149              TEST_DESC("add to head 5x at fill %d at compress %d", f,
1150                        options[_i]) {
1151                  quicklist *ql = quicklistNew(f, options[_i]);
1152                  for (int i = 0; i < 5; i++)
1153                      quicklistPushHead(ql, genstr("hello", i), 32);
1154                  if (ql->count != 5)
1155                      ERROR;
1156                  if (f == 32)
1157                      ql_verify(ql, 1, 5, 5, 5);
1158                  quicklistRelease(ql);
1159              }
1160          }
1161          for (int f = optimize_start; f < 512; f++) {
1162              TEST_DESC("add to tail 500x at fill %d at compress %d", f,
1163                        options[_i]) {
1164                  quicklist *ql = quicklistNew(f, options[_i]);
1165                  for (int i = 0; i < 500; i++)
1166                      quicklistPushTail(ql, genstr("hello", i), 64);
1167                  if (ql->count != 500)
1168                      ERROR;
1169                  if (f == 32)
1170                      ql_verify(ql, 16, 500, 32, 20);
1171                  quicklistRelease(ql);
1172              }
1173          }
1174          for (int f = optimize_start; f < 512; f++) {
1175              TEST_DESC("add to head 500x at fill %d at compress %d", f,
1176                        options[_i]) {
1177                  quicklist *ql = quicklistNew(f, options[_i]);
1178                  for (int i = 0; i < 500; i++)
1179                      quicklistPushHead(ql, genstr("hello", i), 32);
1180                  if (ql->count != 500)
1181                      ERROR;
1182                  if (f == 32)
1183                      ql_verify(ql, 16, 500, 20, 32);
1184                  quicklistRelease(ql);
1185              }
1186          }
1187          TEST("rotate empty") {
1188              quicklist *ql = quicklistNew(-2, options[_i]);
1189              quicklistRotate(ql);
1190              ql_verify(ql, 0, 0, 0, 0);
1191              quicklistRelease(ql);
1192          }
1193          for (int f = optimize_start; f < 32; f++) {
1194              TEST("rotate one val once") {
1195                  quicklist *ql = quicklistNew(f, options[_i]);
1196                  quicklistPushHead(ql, "hello", 6);
1197                  quicklistRotate(ql);
1198                  ql_verify(ql, 1, 1, 1, 1);
1199                  quicklistRelease(ql);
1200              }
1201          }
1202          for (int f = optimize_start; f < 3; f++) {
1203              TEST_DESC("rotate 500 val 5000 times at fill %d at compress %d", f,
1204                        options[_i]) {
1205                  quicklist *ql = quicklistNew(f, options[_i]);
1206                  quicklistPushHead(ql, "900", 3);
1207                  quicklistPushHead(ql, "7000", 4);
1208                  quicklistPushHead(ql, "-1200", 5);
1209                  quicklistPushHead(ql, "42", 2);
1210                  for (int i = 0; i < 500; i++)
1211                      quicklistPushHead(ql, genstr("hello", i), 64);
1212                  ql_info(ql);
1213                  for (int i = 0; i < 5000; i++) {
1214                      ql_info(ql);
1215                      quicklistRotate(ql);
1216                  }
1217                  if (f == 1)
1218                      ql_verify(ql, 504, 504, 1, 1);
1219                  else if (f == 2)
1220                      ql_verify(ql, 252, 504, 2, 2);
1221                  else if (f == 32)
1222                      ql_verify(ql, 16, 504, 32, 24);
1223                  quicklistRelease(ql);
1224              }
1225          }
1226          TEST("pop empty") {
1227              quicklist *ql = quicklistNew(-2, options[_i]);
1228              quicklistPop(ql, QUICKLIST_HEAD, NULL, NULL, NULL);
1229              ql_verify(ql, 0, 0, 0, 0);
1230              quicklistRelease(ql);
1231          }
1232          TEST("pop 1 string from 1") {
1233              quicklist *ql = quicklistNew(-2, options[_i]);
1234              char *populate = genstr("hello", 331);
1235              quicklistPushHead(ql, populate, 32);
1236              unsigned char *data;
1237              unsigned int sz;
1238              PORT_LONGLONG lv;
1239              ql_info(ql);
1240              quicklistPop(ql, QUICKLIST_HEAD, &data, &sz, &lv);
1241              assert(data != NULL);
1242              assert(sz == 32);
1243              if (strcmp(populate, (char *)data))
1244                  ERR("Pop'd value (%.*s) didn't equal original value (%s)", sz,
1245                      data, populate);
1246              zfree(data);
1247              ql_verify(ql, 0, 0, 0, 0);
1248              quicklistRelease(ql);
1249          }
1250          TEST("pop head 1 number from 1") {
1251              quicklist *ql = quicklistNew(-2, options[_i]);
1252              quicklistPushHead(ql, "55513", 5);
1253              unsigned char *data;
1254              unsigned int sz;
1255              PORT_LONGLONG lv;
1256              ql_info(ql);
1257              quicklistPop(ql, QUICKLIST_HEAD, &data, &sz, &lv);
1258              assert(data == NULL);
1259              assert(lv == 55513);
1260              ql_verify(ql, 0, 0, 0, 0);
1261              quicklistRelease(ql);
1262          }
1263          TEST("pop head 500 from 500") {
1264              quicklist *ql = quicklistNew(-2, options[_i]);
1265              for (int i = 0; i < 500; i++)
1266                  quicklistPushHead(ql, genstr("hello", i), 32);
1267              ql_info(ql);
1268              for (int i = 0; i < 500; i++) {
1269                  unsigned char *data;
1270                  unsigned int sz;
1271                  PORT_LONGLONG lv;
1272                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &data, &sz, &lv);
1273                  assert(ret == 1);
1274                  assert(data != NULL);
1275                  assert(sz == 32);
1276                  if (strcmp(genstr("hello", 499 - i), (char *)data))
1277                      ERR("Pop'd value (%.*s) didn't equal original value (%s)",
1278                          sz, data, genstr("hello", 499 - i));
1279                  zfree(data);
1280              }
1281              ql_verify(ql, 0, 0, 0, 0);
1282              quicklistRelease(ql);
1283          }
1284          TEST("pop head 5000 from 500") {
1285              quicklist *ql = quicklistNew(-2, options[_i]);
1286              for (int i = 0; i < 500; i++)
1287                  quicklistPushHead(ql, genstr("hello", i), 32);
1288              for (int i = 0; i < 5000; i++) {
1289                  unsigned char *data;
1290                  unsigned int sz;
1291                  PORT_LONGLONG lv;
1292                  int ret = quicklistPop(ql, QUICKLIST_HEAD, &data, &sz, &lv);
1293                  if (i < 500) {
1294                      assert(ret == 1);
1295                      assert(data != NULL);
1296                      assert(sz == 32);
1297                      if (strcmp(genstr("hello", 499 - i), (char *)data))
1298                          ERR("Pop'd value (%.*s) didn't equal original value "
1299                              "(%s)",
1300                              sz, data, genstr("hello", 499 - i));
1301                      zfree(data);
1302                  } else {
1303                      assert(ret == 0);
1304                  }
1305              }
1306              ql_verify(ql, 0, 0, 0, 0);
1307              quicklistRelease(ql);
1308          }
1309          TEST("iterate forward over 500 list") {
1310              quicklist *ql = quicklistNew(-2, options[_i]);
1311              quicklistSetFill(ql, 32);
1312              for (int i = 0; i < 500; i++)
1313                  quicklistPushHead(ql, genstr("hello", i), 32);
1314              quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1315              quicklistEntry entry;
1316              int i = 499, count = 0;
1317              while (quicklistNext(iter, &entry)) {
1318                  char *h = genstr("hello", i);
1319                  if (strcmp((char *)entry.value, h))
1320                      ERR("value [%s] didn't match [%s] at position %d",
1321                          entry.value, h, i);
1322                  i--;
1323                  count++;
1324              }
1325              if (count != 500)
1326                  ERR("Didn't iterate over exactly 500 elements (%d)", i);
1327              ql_verify(ql, 16, 500, 20, 32);
1328              quicklistReleaseIterator(iter);
1329              quicklistRelease(ql);
1330          }
1331          TEST("iterate reverse over 500 list") {
1332              quicklist *ql = quicklistNew(-2, options[_i]);
1333              quicklistSetFill(ql, 32);
1334              for (int i = 0; i < 500; i++)
1335                  quicklistPushHead(ql, genstr("hello", i), 32);
1336              quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1337              quicklistEntry entry;
1338              int i = 0;
1339              while (quicklistNext(iter, &entry)) {
1340                  char *h = genstr("hello", i);
1341                  if (strcmp((char *)entry.value, h))
1342                      ERR("value [%s] didn't match [%s] at position %d",
1343                          entry.value, h, i);
1344                  i++;
1345              }
1346              if (i != 500)
1347                  ERR("Didn't iterate over exactly 500 elements (%d)", i);
1348              ql_verify(ql, 16, 500, 20, 32);
1349              quicklistReleaseIterator(iter);
1350              quicklistRelease(ql);
1351          }
1352          TEST("insert before with 0 elements") {
1353              quicklist *ql = quicklistNew(-2, options[_i]);
1354              quicklistEntry entry;
1355              quicklistIndex(ql, 0, &entry);
1356              quicklistInsertBefore(ql, &entry, "abc", 4);
1357              ql_verify(ql, 1, 1, 1, 1);
1358              quicklistRelease(ql);
1359          }
1360          TEST("insert after with 0 elements") {
1361              quicklist *ql = quicklistNew(-2, options[_i]);
1362              quicklistEntry entry;
1363              quicklistIndex(ql, 0, &entry);
1364              quicklistInsertAfter(ql, &entry, "abc", 4);
1365              ql_verify(ql, 1, 1, 1, 1);
1366              quicklistRelease(ql);
1367          }
1368          TEST("insert after 1 element") {
1369              quicklist *ql = quicklistNew(-2, options[_i]);
1370              quicklistPushHead(ql, "hello", 6);
1371              quicklistEntry entry;
1372              quicklistIndex(ql, 0, &entry);
1373              quicklistInsertAfter(ql, &entry, "abc", 4);
1374              ql_verify(ql, 1, 2, 2, 2);
1375              quicklistRelease(ql);
1376          }
1377          TEST("insert before 1 element") {
1378              quicklist *ql = quicklistNew(-2, options[_i]);
1379              quicklistPushHead(ql, "hello", 6);
1380              quicklistEntry entry;
1381              quicklistIndex(ql, 0, &entry);
1382              quicklistInsertAfter(ql, &entry, "abc", 4);
1383              ql_verify(ql, 1, 2, 2, 2);
1384              quicklistRelease(ql);
1385          }
1386          for (int f = optimize_start; f < 12; f++) {
1387              TEST_DESC("insert once in elements while iterating at fill %d at "
1388                        "compress %d\n",
1389                        f, options[_i]) {
1390                  quicklist *ql = quicklistNew(f, options[_i]);
1391                  quicklistPushTail(ql, "abc", 3);
1392                  quicklistSetFill(ql, 1);
1393                  quicklistPushTail(ql, "def", 3); &bsol;* force to unique node */
1394                  quicklistSetFill(ql, f);
1395                  quicklistPushTail(ql, "bob", 3); &bsol;* force to reset for +3 */
1396                  quicklistPushTail(ql, "foo", 3);
1397                  quicklistPushTail(ql, "zoo", 3);
1398                  itrprintr(ql, 0);
1399                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1400                  quicklistEntry entry;
1401                  while (quicklistNext(iter, &entry)) {
1402                      if (!strncmp((char *)entry.value, "bob", 3)) {
1403                          quicklistInsertBefore(ql, &entry, "bar", 3);
1404                          break; &bsol;* didn't we fix insert-while-iterating? */
1405                      }
1406                  }
1407                  itrprintr(ql, 0);
1408                  quicklistIndex(ql, 0, &entry);
1409                  if (strncmp((char *)entry.value, "abc", 3))
1410                      ERR("Value 0 didn't match, instead got: %.*s", entry.sz,
1411                          entry.value);
1412                  quicklistIndex(ql, 1, &entry);
1413                  if (strncmp((char *)entry.value, "def", 3))
1414                      ERR("Value 1 didn't match, instead got: %.*s", entry.sz,
1415                          entry.value);
1416                  quicklistIndex(ql, 2, &entry);
1417                  if (strncmp((char *)entry.value, "bar", 3))
1418                      ERR("Value 2 didn't match, instead got: %.*s", entry.sz,
1419                          entry.value);
1420                  quicklistIndex(ql, 3, &entry);
1421                  if (strncmp((char *)entry.value, "bob", 3))
1422                      ERR("Value 3 didn't match, instead got: %.*s", entry.sz,
1423                          entry.value);
1424                  quicklistIndex(ql, 4, &entry);
1425                  if (strncmp((char *)entry.value, "foo", 3))
1426                      ERR("Value 4 didn't match, instead got: %.*s", entry.sz,
1427                          entry.value);
1428                  quicklistIndex(ql, 5, &entry);
1429                  if (strncmp((char *)entry.value, "zoo", 3))
1430                      ERR("Value 5 didn't match, instead got: %.*s", entry.sz,
1431                          entry.value);
1432                  quicklistReleaseIterator(iter);
1433                  quicklistRelease(ql);
1434              }
1435          }
1436          for (int f = optimize_start; f < 1024; f++) {
1437              TEST_DESC(
1438                  "insert [before] 250 new in middle of 500 elements at fill"
1439                  " %d at compress %d",
1440                  f, options[_i]) {
1441                  quicklist *ql = quicklistNew(f, options[_i]);
1442                  for (int i = 0; i < 500; i++)
1443                      quicklistPushTail(ql, genstr("hello", i), 32);
1444                  for (int i = 0; i < 250; i++) {
1445                      quicklistEntry entry;
1446                      quicklistIndex(ql, 250, &entry);
1447                      quicklistInsertBefore(ql, &entry, genstr("abc", i), 32);
1448                  }
1449                  if (f == 32)
1450                      ql_verify(ql, 25, 750, 32, 20);
1451                  quicklistRelease(ql);
1452              }
1453          }
1454          for (int f = optimize_start; f < 1024; f++) {
1455              TEST_DESC("insert [after] 250 new in middle of 500 elements at "
1456                        "fill %d at compress %d",
1457                        f, options[_i]) {
1458                  quicklist *ql = quicklistNew(f, options[_i]);
1459                  for (int i = 0; i < 500; i++)
1460                      quicklistPushHead(ql, genstr("hello", i), 32);
1461                  for (int i = 0; i < 250; i++) {
1462                      quicklistEntry entry;
1463                      quicklistIndex(ql, 250, &entry);
1464                      quicklistInsertAfter(ql, &entry, genstr("abc", i), 32);
1465                  }
1466                  if (ql->count != 750)
1467                      ERR("List size not 750, but rather %ld", ql->count);
1468                  if (f == 32)
1469                      ql_verify(ql, 26, 750, 20, 32);
1470                  quicklistRelease(ql);
1471              }
1472          }
1473          TEST("duplicate empty list") {
1474              quicklist *ql = quicklistNew(-2, options[_i]);
1475              ql_verify(ql, 0, 0, 0, 0);
1476              quicklist *copy = quicklistDup(ql);
1477              ql_verify(copy, 0, 0, 0, 0);
1478              quicklistRelease(ql);
1479              quicklistRelease(copy);
1480          }
1481          TEST("duplicate list of 1 element") {
1482              quicklist *ql = quicklistNew(-2, options[_i]);
1483              quicklistPushHead(ql, genstr("hello", 3), 32);
1484              ql_verify(ql, 1, 1, 1, 1);
1485              quicklist *copy = quicklistDup(ql);
1486              ql_verify(copy, 1, 1, 1, 1);
1487              quicklistRelease(ql);
1488              quicklistRelease(copy);
1489          }
1490          TEST("duplicate list of 500") {
1491              quicklist *ql = quicklistNew(-2, options[_i]);
1492              quicklistSetFill(ql, 32);
1493              for (int i = 0; i < 500; i++)
1494                  quicklistPushHead(ql, genstr("hello", i), 32);
1495              ql_verify(ql, 16, 500, 20, 32);
1496              quicklist *copy = quicklistDup(ql);
1497              ql_verify(copy, 16, 500, 20, 32);
1498              quicklistRelease(ql);
1499              quicklistRelease(copy);
1500          }
1501          for (int f = optimize_start; f < 512; f++) {
1502              TEST_DESC("index 1,200 from 500 list at fill %d at compress %d", f,
1503                        options[_i]) {
1504                  quicklist *ql = quicklistNew(f, options[_i]);
1505                  for (int i = 0; i < 500; i++)
1506                      quicklistPushTail(ql, genstr("hello", i + 1), 32);
1507                  quicklistEntry entry;
1508                  quicklistIndex(ql, 1, &entry);
1509                  if (!strcmp((char *)entry.value, "hello2"))
1510                      OK;
1511                  else
1512                      ERR("Value: %s", entry.value);
1513                  quicklistIndex(ql, 200, &entry);
1514                  if (!strcmp((char *)entry.value, "hello201"))
1515                      OK;
1516                  else
1517                      ERR("Value: %s", entry.value);
1518                  quicklistRelease(ql);
1519              }
1520              TEST_DESC("index -1,-2 from 500 list at fill %d at compress %d", f,
1521                        options[_i]) {
1522                  quicklist *ql = quicklistNew(f, options[_i]);
1523                  for (int i = 0; i < 500; i++)
1524                      quicklistPushTail(ql, genstr("hello", i + 1), 32);
1525                  quicklistEntry entry;
1526                  quicklistIndex(ql, -1, &entry);
1527                  if (!strcmp((char *)entry.value, "hello500"))
1528                      OK;
1529                  else
1530                      ERR("Value: %s", entry.value);
1531                  quicklistIndex(ql, -2, &entry);
1532                  if (!strcmp((char *)entry.value, "hello499"))
1533                      OK;
1534                  else
1535                      ERR("Value: %s", entry.value);
1536                  quicklistRelease(ql);
1537              }
1538              TEST_DESC("index -100 from 500 list at fill %d at compress %d", f,
1539                        options[_i]) {
1540                  quicklist *ql = quicklistNew(f, options[_i]);
1541                  for (int i = 0; i < 500; i++)
1542                      quicklistPushTail(ql, genstr("hello", i + 1), 32);
1543                  quicklistEntry entry;
1544                  quicklistIndex(ql, -100, &entry);
1545                  if (!strcmp((char *)entry.value, "hello401"))
1546                      OK;
1547                  else
1548                      ERR("Value: %s", entry.value);
1549                  quicklistRelease(ql);
1550              }
1551              TEST_DESC("index too big +1 from 50 list at fill %d at compress %d",
1552                        f, options[_i]) {
1553                  quicklist *ql = quicklistNew(f, options[_i]);
1554                  for (int i = 0; i < 50; i++)
1555                      quicklistPushTail(ql, genstr("hello", i + 1), 32);
1556                  quicklistEntry entry;
1557                  if (quicklistIndex(ql, 50, &entry))
1558                      ERR("Index found at 50 with 50 list: %.*s", entry.sz,
1559                          entry.value);
1560                  else
1561                      OK;
1562                  quicklistRelease(ql);
1563              }
1564          }
1565          TEST("delete range empty list") {
1566              quicklist *ql = quicklistNew(-2, options[_i]);
1567              quicklistDelRange(ql, 5, 20);
1568              ql_verify(ql, 0, 0, 0, 0);
1569              quicklistRelease(ql);
1570          }
1571          TEST("delete range of entire node in list of one node") {
1572              quicklist *ql = quicklistNew(-2, options[_i]);
1573              for (int i = 0; i < 32; i++)
1574                  quicklistPushHead(ql, genstr("hello", i), 32);
1575              ql_verify(ql, 1, 32, 32, 32);
1576              quicklistDelRange(ql, 0, 32);
1577              ql_verify(ql, 0, 0, 0, 0);
1578              quicklistRelease(ql);
1579          }
1580          TEST("delete range of entire node with overflow counts") {
1581              quicklist *ql = quicklistNew(-2, options[_i]);
1582              for (int i = 0; i < 32; i++)
1583                  quicklistPushHead(ql, genstr("hello", i), 32);
1584              ql_verify(ql, 1, 32, 32, 32);
1585              quicklistDelRange(ql, 0, 128);
1586              ql_verify(ql, 0, 0, 0, 0);
1587              quicklistRelease(ql);
1588          }
1589          TEST("delete middle 100 of 500 list") {
1590              quicklist *ql = quicklistNew(-2, options[_i]);
1591              quicklistSetFill(ql, 32);
1592              for (int i = 0; i < 500; i++)
1593                  quicklistPushTail(ql, genstr("hello", i + 1), 32);
1594              ql_verify(ql, 16, 500, 32, 20);
1595              quicklistDelRange(ql, 200, 100);
1596              ql_verify(ql, 14, 400, 32, 20);
1597              quicklistRelease(ql);
1598          }
1599          TEST("delete negative 1 from 500 list") {
1600              quicklist *ql = quicklistNew(-2, options[_i]);
1601              quicklistSetFill(ql, 32);
1602              for (int i = 0; i < 500; i++)
1603                  quicklistPushTail(ql, genstr("hello", i + 1), 32);
1604              ql_verify(ql, 16, 500, 32, 20);
1605              quicklistDelRange(ql, -1, 1);
1606              ql_verify(ql, 16, 499, 32, 19);
1607              quicklistRelease(ql);
1608          }
1609          TEST("delete negative 1 from 500 list with overflow counts") {
1610              quicklist *ql = quicklistNew(-2, options[_i]);
1611              quicklistSetFill(ql, 32);
1612              for (int i = 0; i < 500; i++)
1613                  quicklistPushTail(ql, genstr("hello", i + 1), 32);
1614              ql_verify(ql, 16, 500, 32, 20);
1615              quicklistDelRange(ql, -1, 128);
1616              ql_verify(ql, 16, 499, 32, 19);
1617              quicklistRelease(ql);
1618          }
1619          TEST("delete negative 100 from 500 list") {
1620              quicklist *ql = quicklistNew(-2, options[_i]);
1621              quicklistSetFill(ql, 32);
1622              for (int i = 0; i < 500; i++)
1623                  quicklistPushTail(ql, genstr("hello", i + 1), 32);
1624              quicklistDelRange(ql, -100, 100);
1625              ql_verify(ql, 13, 400, 32, 16);
1626              quicklistRelease(ql);
1627          }
1628          TEST("delete -10 count 5 from 50 list") {
1629              quicklist *ql = quicklistNew(-2, options[_i]);
1630              quicklistSetFill(ql, 32);
1631              for (int i = 0; i < 50; i++)
1632                  quicklistPushTail(ql, genstr("hello", i + 1), 32);
1633              ql_verify(ql, 2, 50, 32, 18);
1634              quicklistDelRange(ql, -10, 5);
1635              ql_verify(ql, 2, 45, 32, 13);
1636              quicklistRelease(ql);
1637          }
1638          TEST("numbers only list read") {
1639              quicklist *ql = quicklistNew(-2, options[_i]);
1640              quicklistPushTail(ql, "1111", 4);
1641              quicklistPushTail(ql, "2222", 4);
1642              quicklistPushTail(ql, "3333", 4);
1643              quicklistPushTail(ql, "4444", 4);
1644              ql_verify(ql, 1, 4, 4, 4);
1645              quicklistEntry entry;
1646              quicklistIndex(ql, 0, &entry);
1647              if (entry.longval != 1111)
1648                  ERR("Not 1111, %lld", entry.longval);
1649              quicklistIndex(ql, 1, &entry);
1650              if (entry.longval != 2222)
1651                  ERR("Not 2222, %lld", entry.longval);
1652              quicklistIndex(ql, 2, &entry);
1653              if (entry.longval != 3333)
1654                  ERR("Not 3333, %lld", entry.longval);
1655              quicklistIndex(ql, 3, &entry);
1656              if (entry.longval != 4444)
1657                  ERR("Not 4444, %lld", entry.longval);
1658              if (quicklistIndex(ql, 4, &entry))
1659                  ERR("Index past elements: %lld", entry.longval);
1660              quicklistIndex(ql, -1, &entry);
1661              if (entry.longval != 4444)
1662                  ERR("Not 4444 (reverse), %lld", entry.longval);
1663              quicklistIndex(ql, -2, &entry);
1664              if (entry.longval != 3333)
1665                  ERR("Not 3333 (reverse), %lld", entry.longval);
1666              quicklistIndex(ql, -3, &entry);
1667              if (entry.longval != 2222)
1668                  ERR("Not 2222 (reverse), %lld", entry.longval);
1669              quicklistIndex(ql, -4, &entry);
1670              if (entry.longval != 1111)
1671                  ERR("Not 1111 (reverse), %lld", entry.longval);
1672              if (quicklistIndex(ql, -5, &entry))
1673                  ERR("Index past elements (reverse), %lld", entry.longval);
1674              quicklistRelease(ql);
1675          }
1676          TEST("numbers larger list read") {
1677              quicklist *ql = quicklistNew(-2, options[_i]);
1678              quicklistSetFill(ql, 32);
1679              char num[32];
1680              PORT_LONGLONG nums[5000];
1681              for (int i = 0; i < 5000; i++) {
1682                  nums[i] = -5157318210846258176 + i;
1683                  int sz = ll2string(num, sizeof(num), nums[i]);
1684                  quicklistPushTail(ql, num, sz);
1685              }
1686              quicklistPushTail(ql, "xxxxxxxxxxxxxxxxxxxx", 20);
1687              quicklistEntry entry;
1688              for (int i = 0; i < 5000; i++) {
1689                  quicklistIndex(ql, i, &entry);
1690                  if (entry.longval != nums[i])
1691                      ERR("[%d] Not longval %lld but rather %lld", i, nums[i],
1692                          entry.longval);
1693                  entry.longval = 0xdeadbeef;
1694              }
1695              quicklistIndex(ql, 5000, &entry);
1696              if (strncmp((char *)entry.value, "xxxxxxxxxxxxxxxxxxxx", 20))
1697                  ERR("String val not match: %s", entry.value);
1698              ql_verify(ql, 157, 5001, 32, 9);
1699              quicklistRelease(ql);
1700          }
1701          TEST("numbers larger list read B") {
1702              quicklist *ql = quicklistNew(-2, options[_i]);
1703              quicklistPushTail(ql, "99", 2);
1704              quicklistPushTail(ql, "98", 2);
1705              quicklistPushTail(ql, "xxxxxxxxxxxxxxxxxxxx", 20);
1706              quicklistPushTail(ql, "96", 2);
1707              quicklistPushTail(ql, "95", 2);
1708              quicklistReplaceAtIndex(ql, 1, "foo", 3);
1709              quicklistReplaceAtIndex(ql, -1, "bar", 3);
1710              quicklistRelease(ql);
1711              OK;
1712          }
1713          for (int f = optimize_start; f < 16; f++) {
1714              TEST_DESC("lrem test at fill %d at compress %d", f, options[_i]) {
1715                  quicklist *ql = quicklistNew(f, options[_i]);
1716                  char *words[] = {"abc", "foo", "bar",  "foobar", "foobared",
1717                                   "zap", "bar", "test", "foo"};
1718                  char *result[] = {"abc", "foo",  "foobar", "foobared",
1719                                    "zap", "test", "foo"};
1720                  char *resultB[] = {"abc",      "foo", "foobar",
1721                                     "foobared", "zap", "test"};
1722                  for (int i = 0; i < 9; i++)
1723                      quicklistPushTail(ql, words[i], strlen(words[i]));
1724                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);
1725                  quicklistEntry entry;
1726                  int i = 0;
1727                  while (quicklistNext(iter, &entry)) {
1728                      if (quicklistCompare(entry.zi, (unsigned char *)"bar", 3)) {
1729                          quicklistDelEntry(iter, &entry);
1730                      }
1731                      i++;
1732                  }
1733                  quicklistReleaseIterator(iter);
1734                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1735                  i = 0;
1736                  int ok = 1;
1737                  while (quicklistNext(iter, &entry)) {
1738                      if (strncmp((char *)entry.value, result[i], entry.sz)) {
1739                          ERR("No match at position %d, got %.*s instead of %s",
1740                              i, entry.sz, entry.value, result[i]);
1741                          ok = 0;
1742                      }
1743                      i++;
1744                  }
1745                  quicklistReleaseIterator(iter);
1746                  quicklistPushTail(ql, "foo", 3);
1747                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1748                  i = 0;
1749                  int del = 2;
1750                  while (quicklistNext(iter, &entry)) {
1751                      if (quicklistCompare(entry.zi, (unsigned char *)"foo", 3)) {
1752                          quicklistDelEntry(iter, &entry);
1753                          del--;
1754                      }
1755                      if (!del)
1756                          break;
1757                      i++;
1758                  }
1759                  quicklistReleaseIterator(iter);
1760                  iter = quicklistGetIterator(ql, AL_START_TAIL);
1761                  i = 0;
1762                  size_t resB = sizeof(resultB) / sizeof(*resultB);
1763                  while (quicklistNext(iter, &entry)) {
1764                      if (strncmp((char *)entry.value, resultB[resB - 1 - i],
1765                                  entry.sz)) {
1766                          ERR("No match at position %d, got %.*s instead of %s",
1767                              i, entry.sz, entry.value, resultB[resB - 1 - i]);
1768                          ok = 0;
1769                      }
1770                      i++;
1771                  }
1772                  quicklistReleaseIterator(iter);
1773                  if (ok)
1774                      OK;
1775                  quicklistRelease(ql);
1776              }
1777          }
1778          for (int f = optimize_start; f < 16; f++) {
1779              TEST_DESC("iterate reverse + delete at fill %d at compress %d", f,
1780                        options[_i]) {
1781                  quicklist *ql = quicklistNew(f, options[_i]);
1782                  quicklistPushTail(ql, "abc", 3);
1783                  quicklistPushTail(ql, "def", 3);
1784                  quicklistPushTail(ql, "hij", 3);
1785                  quicklistPushTail(ql, "jkl", 3);
1786                  quicklistPushTail(ql, "oop", 3);
1787                  quicklistEntry entry;
1788                  quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);
1789                  int i = 0;
1790                  while (quicklistNext(iter, &entry)) {
1791                      if (quicklistCompare(entry.zi, (unsigned char *)"hij", 3)) {
1792                          quicklistDelEntry(iter, &entry);
1793                      }
1794                      i++;
1795                  }
1796                  quicklistReleaseIterator(iter);
1797                  if (i != 5)
1798                      ERR("Didn't iterate 5 times, iterated %d times.", i);
1799                  iter = quicklistGetIterator(ql, AL_START_HEAD);
1800                  i = 0;
1801                  char *vals[] = {"abc", "def", "jkl", "oop"};
1802                  while (quicklistNext(iter, &entry)) {
1803                      if (!quicklistCompare(entry.zi, (unsigned char *)vals[i],
1804                                            3)) {
1805                          ERR("Value at %d didn't match %s\n", i, vals[i]);
1806                      }
1807                      i++;
1808                  }
1809                  quicklistReleaseIterator(iter);
1810                  quicklistRelease(ql);
1811              }
1812          }
1813          for (int f = optimize_start; f < 800; f++) {
1814              TEST_DESC("iterator at index test at fill %d at compress %d", f,
1815                        options[_i]) {
1816                  quicklist *ql = quicklistNew(f, options[_i]);
1817                  char num[32];
1818                  PORT_LONGLONG nums[5000];
1819                  for (int i = 0; i < 760; i++) {
1820                      nums[i] = -5157318210846258176 + i;
1821                      int sz = ll2string(num, sizeof(num), nums[i]);
1822                      quicklistPushTail(ql, num, sz);
1823                  }
1824                  quicklistEntry entry;
1825                  quicklistIter *iter =
1826                      quicklistGetIteratorAtIdx(ql, AL_START_HEAD, 437);
1827                  int i = 437;
1828                  while (quicklistNext(iter, &entry)) {
1829                      if (entry.longval != nums[i])
1830                          ERR("Expected %lld, but got %lld", entry.longval,
1831                              nums[i]);
1832                      i++;
1833                  }
1834                  quicklistReleaseIterator(iter);
1835                  quicklistRelease(ql);
1836              }
1837          }
1838          for (int f = optimize_start; f < 40; f++) {
1839              TEST_DESC("ltrim test A at fill %d at compress %d", f,
1840                        options[_i]) {
1841                  quicklist *ql = quicklistNew(f, options[_i]);
1842                  char num[32];
1843                  PORT_LONGLONG nums[5000];
1844                  for (int i = 0; i < 32; i++) {
1845                      nums[i] = -5157318210846258176 + i;
1846                      int sz = ll2string(num, sizeof(num), nums[i]);
1847                      quicklistPushTail(ql, num, sz);
1848                  }
1849                  if (f == 32)
1850                      ql_verify(ql, 1, 32, 32, 32);
1851                  quicklistDelRange(ql, 0, 25);
1852                  quicklistDelRange(ql, 0, 0);
1853                  quicklistEntry entry;
1854                  for (int i = 0; i < 7; i++) {
1855                      quicklistIndex(ql, i, &entry);
1856                      if (entry.longval != nums[25 + i])
1857                          ERR("Deleted invalid range!  Expected %lld but got "
1858                              "%lld",
1859                              entry.longval, nums[25 + i]);
1860                  }
1861                  if (f == 32)
1862                      ql_verify(ql, 1, 7, 7, 7);
1863                  quicklistRelease(ql);
1864              }
1865          }
1866          for (int f = optimize_start; f < 40; f++) {
1867              TEST_DESC("ltrim test B at fill %d at compress %d", f,
1868                        options[_i]) {
1869                  quicklist *ql = quicklistNew(f, QUICKLIST_NOCOMPRESS);
1870                  char num[32];
1871                  PORT_LONGLONG nums[5000];
1872                  for (int i = 0; i < 33; i++) {
1873                      nums[i] = i;
1874                      int sz = ll2string(num, sizeof(num), nums[i]);
1875                      quicklistPushTail(ql, num, sz);
1876                  }
1877                  if (f == 32)
1878                      ql_verify(ql, 2, 33, 32, 1);
1879                  quicklistDelRange(ql, 0, 5);
1880                  quicklistDelRange(ql, -16, 16);
1881                  if (f == 32)
1882                      ql_verify(ql, 1, 12, 12, 12);
1883                  quicklistEntry entry;
1884                  quicklistIndex(ql, 0, &entry);
1885                  if (entry.longval != 5)
1886                      ERR("A: longval not 5, but %lld", entry.longval);
1887                  else
1888                      OK;
1889                  quicklistIndex(ql, -1, &entry);
1890                  if (entry.longval != 16)
1891                      ERR("B! got instead: %lld", entry.longval);
1892                  else
1893                      OK;
1894                  quicklistPushTail(ql, "bobobob", 7);
1895                  quicklistIndex(ql, -1, &entry);
1896                  if (strncmp((char *)entry.value, "bobobob", 7))
1897                      ERR("Tail doesn't match bobobob, it's %.*s instead",
1898                          entry.sz, entry.value);
1899                  for (int i = 0; i < 12; i++) {
1900                      quicklistIndex(ql, i, &entry);
1901                      if (entry.longval != nums[5 + i])
1902                          ERR("Deleted invalid range!  Expected %lld but got "
1903                              "%lld",
1904                              entry.longval, nums[5 + i]);
1905                  }
1906                  quicklistRelease(ql);
1907              }
1908          }
1909          for (int f = optimize_start; f < 40; f++) {
1910              TEST_DESC("ltrim test C at fill %d at compress %d", f,
1911                        options[_i]) {
1912                  quicklist *ql = quicklistNew(f, options[_i]);
1913                  char num[32];
1914                  PORT_LONGLONG nums[5000];
1915                  for (int i = 0; i < 33; i++) {
1916                      nums[i] = -5157318210846258176 + i;
1917                      int sz = ll2string(num, sizeof(num), nums[i]);
1918                      quicklistPushTail(ql, num, sz);
1919                  }
1920                  if (f == 32)
1921                      ql_verify(ql, 2, 33, 32, 1);
1922                  quicklistDelRange(ql, 0, 3);
1923                  quicklistDelRange(ql, -29,
1924                                    4000); &bsol;* make sure not loop forever */
1925                  if (f == 32)
1926                      ql_verify(ql, 1, 1, 1, 1);
1927                  quicklistEntry entry;
1928                  quicklistIndex(ql, 0, &entry);
1929                  if (entry.longval != -5157318210846258173)
1930                      ERROR;
1931                  else
1932                      OK;
1933                  quicklistRelease(ql);
1934              }
1935          }
1936          for (int f = optimize_start; f < 40; f++) {
1937              TEST_DESC("ltrim test D at fill %d at compress %d", f,
1938                        options[_i]) {
1939                  quicklist *ql = quicklistNew(f, options[_i]);
1940                  char num[32];
1941                  PORT_LONGLONG nums[5000];
1942                  for (int i = 0; i < 33; i++) {
1943                      nums[i] = -5157318210846258176 + i;
1944                      int sz = ll2string(num, sizeof(num), nums[i]);
1945                      quicklistPushTail(ql, num, sz);
1946                  }
1947                  if (f == 32)
1948                      ql_verify(ql, 2, 33, 32, 1);
1949                  quicklistDelRange(ql, -12, 3);
1950                  if (ql->count != 30)
1951                      ERR("Didn't delete exactly three elements!  Count is: %lu",
1952                          ql->count);
1953                  quicklistRelease(ql);
1954              }
1955          }
1956          for (int f = optimize_start; f < 72; f++) {
1957              TEST_DESC("create quicklist from ziplist at fill %d at compress %d",
1958                        f, options[_i]) {
1959                  unsigned char *zl = ziplistNew();
1960                  PORT_LONGLONG nums[64];
1961                  char num[64];
1962                  for (int i = 0; i < 33; i++) {
1963                      nums[i] = -5157318210846258176 + i;
1964                      int sz = ll2string(num, sizeof(num), nums[i]);
1965                      zl =
1966                          ziplistPush(zl, (unsigned char *)num, sz, ZIPLIST_TAIL);
1967                  }
1968                  for (int i = 0; i < 33; i++) {
1969                      zl = ziplistPush(zl, (unsigned char *)genstr("hello", i),
1970                                       32, ZIPLIST_TAIL);
1971                  }
1972                  quicklist *ql = quicklistCreateFromZiplist(f, options[_i], zl);
1973                  if (f == 1)
1974                      ql_verify(ql, 66, 66, 1, 1);
1975                  else if (f == 32)
1976                      ql_verify(ql, 3, 66, 32, 2);
1977                  else if (f == 66)
1978                      ql_verify(ql, 1, 66, 66, 66);
1979                  quicklistRelease(ql);
1980              }
1981          }
1982          PORT_LONGLONG stop = mstime();
1983          runtime[_i] = stop - start;
1984      }
1985      int list_sizes[] = {250, 251, 500, 999, 1000};
1986      PORT_LONGLONG start = mstime();
1987      for (int list = 0; list < (int)(sizeof(list_sizes) / sizeof(*list_sizes));
1988           list++) {
1989          for (int f = optimize_start; f < 128; f++) {
1990              for (int depth = 1; depth < 40; depth++) {
1991                  TEST_DESC("verify specific compression of interior nodes with "
1992                            "%d list "
1993                            "at fill %d at compress %d",
1994                            list_sizes[list], f, depth) {
1995                      quicklist *ql = quicklistNew(f, depth);
1996                      for (int i = 0; i < list_sizes[list]; i++) {
1997                          quicklistPushTail(ql, genstr("hello TAIL", i + 1), 64);
1998                          quicklistPushHead(ql, genstr("hello HEAD", i + 1), 64);
1999                      }
2000                      quicklistNode *node = ql->head;
2001                      unsigned int low_raw = ql->compress;
2002                      unsigned int high_raw = ql->len - ql->compress;
2003                      for (unsigned int at = 0; at < ql->len;
2004                           at++, node = node->next) {
2005                          if (at < low_raw || at >= high_raw) {
2006                              if (node->encoding != QUICKLIST_NODE_ENCODING_RAW) {
2007                                  ERR("Incorrect compression: node %d is "
2008                                      "compressed at depth %d ((%u, %u); total "
2009                                      "nodes: %u; size: %u)",
2010                                      at, depth, low_raw, high_raw, ql->len,
2011                                      node->sz);
2012                              }
2013                          } else {
2014                              if (node->encoding != QUICKLIST_NODE_ENCODING_LZF) {
2015                                  ERR("Incorrect non-compression: node %d is NOT "
2016                                      "compressed at depth %d ((%u, %u); total "
2017                                      "nodes: %u; size: %u; attempted: %d)",
2018                                      at, depth, low_raw, high_raw, ql->len,
2019                                      node->sz, node->attempted_compress);
2020                              }
2021                          }
2022                      }
2023                      quicklistRelease(ql);
2024                  }
2025              }
2026          }
2027      }
2028      PORT_LONGLONG stop = mstime();
2029      printf("\n");
2030      for (size_t i = 0; i < option_count; i++)
2031          printf("Test Loop %02d: %0.2f seconds.\n", options[i],
2032                 (float)runtime[i] / 1000);
2033      printf("Compressions: %0.2f seconds.\n", (float)(stop - start) / 1000);
2034      printf("\n");
2035      if (!err)
2036          printf("ALL TESTS PASSED!\n");
2037      else
2038          ERR("Sorry, not all tests passed!  In fact, %d tests failed.", err);
2039      return err;
2040  }
2041  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pbes2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-quicklist.c</div>
                </div>
                <div class="column column_space"><pre><code>119           res->iv   = lenc->next->child;
120           res->key_bits = 32;
121        } else {
</pre></code></div>
                <div class="column column_space"><pre><code>773              iter->current = iter->current->next;
774              iter->offset = 0;
775          } else if (iter->direction == AL_START_TAIL) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    