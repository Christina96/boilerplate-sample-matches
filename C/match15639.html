<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for im_debugim.c &amp; linear.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for im_debugim.c &amp; linear.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>im_debugim.c (25.0%)<th>linear.c (5.4945054%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(124-130)<td><a href="#" name="0">(346-356)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>im_debugim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 int 
8 im_debugim( IMAGE *in )
9 {
10 	if( im_incheck( in ) )
11 		return( -1 );
12 	if( in-&gt;Coding != IM_CODING_NONE ) {
13 		im_error( "im_debugim", "%s", _( "input must be uncoded" ) );
14 		return( -1 );
15 	}
16 #define loopuc(TYPE) \
17 	{	TYPE *p = (TYPE *) in-&gt;data; \
18 		int x, y, z; \
19 		\
20 		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
21 			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
22 				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
23 					fprintf(stderr, "%4d", (TYPE)*p++ );\
24 				} \
25 			} \
26 			fprintf(stderr, "\n");\
27 		} \
28 	} 
29 #define loop(TYPE) \
30 	{	TYPE *p = (TYPE *) in-&gt;data; \
31 		int x, y, z; \
32 		\
33 		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
34 			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
35 				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
36 					fprintf(stderr, "%g\t", (double)*p++ );\
37 				} \
38 			} \
39 			fprintf(stderr, "\n");\
40 		} \
41 	} 
42 #define loopcmplx(TYPE) \
43 	{	TYPE *p = (TYPE *) in-&gt;data; \
44 		int x, y, z; \
45 		\
46 		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
47 			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
48 				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
49 					fprintf(stderr,"re=%g\t",(double)*p++);\
50 					fprintf(stderr,"im=%g\t",(double)*p++);\
51 				} \
52 			} \
53 			fprintf(stderr, "\n");\
54 		} \
55 	} 
56 	switch( in-&gt;BandFmt ) {
57 	case IM_BANDFMT_UCHAR:		loopuc(unsigned char); break; 
58 	case IM_BANDFMT_CHAR:		loop(char); break; 
59 <a name="0"></a>	case IM_BANDFMT_USHORT:		loop(unsigned short); break; 
60 	case IM_BANDFMT_SHORT:		loop(short); break; 
61 	case IM_BANDFMT_UINT:		loop(unsigned int); break; 
62 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	case IM_BANDFMT_INT:		loop(int); break; 
63 	case IM_BANDFMT_FLOAT:		loop(float); break; 
64 	case IM_BANDFMT_DOUBLE:		loop(double); break; 
65 	case IM_BANDFMT_COMPLEX:	loopcmplx(float); break; 
66 	case IM_BANDFMT_DPCOMPLEX:	loopcmplx(double); break; 
67 	default: </b></font>
68 		im_error( "im_debugim", "%s", _( "unknown input format") ); 
69 		return( -1 );
70 	}
71 	return( 0 );
72 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>linear.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 typedef struct _VipsLinear {
10 	VipsUnary parent_instance;
11 	VipsArea *a;
12 	VipsArea *b;
13 	gboolean uchar;
14 	int n;
15 	double *a_ready;
16 	double *b_ready;
17 } VipsLinear;
18 typedef VipsUnaryClass VipsLinearClass;
19 G_DEFINE_TYPE( VipsLinear, vips_linear, VIPS_TYPE_UNARY );
20 static int
21 vips_linear_build( VipsObject *object )
22 {
23 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
24 	VipsArithmetic *arithmetic = VIPS_ARITHMETIC( object );
25 	VipsUnary *unary = (VipsUnary *) object;
26 	VipsLinear *linear = (VipsLinear *) object;
27 	int i;
28 	linear-&gt;n = 1;
29 	if( linear-&gt;a )
30 		linear-&gt;n = VIPS_MAX( linear-&gt;n, linear-&gt;a-&gt;n );
31 	if( linear-&gt;b )
32 		linear-&gt;n = VIPS_MAX( linear-&gt;n, linear-&gt;b-&gt;n );
33 	if( unary-&gt;in ) {
34 		int bands;
35 		vips_image_decode_predict( unary-&gt;in, &amp;bands, NULL ); 
36 		linear-&gt;n = VIPS_MAX( linear-&gt;n, bands );
37 	}
38 	arithmetic-&gt;base_bands = linear-&gt;n;
39 	if( unary-&gt;in &amp;&amp; 
40 		linear-&gt;a &amp;&amp; 
41 		linear-&gt;b ) {
42 		if( vips_check_vector( class-&gt;nickname, 
43 			linear-&gt;a-&gt;n, unary-&gt;in ) ||
44 			vips_check_vector( class-&gt;nickname, 
45 				linear-&gt;b-&gt;n, unary-&gt;in ) )
46 		return( -1 );
47 	}
48 	if( linear-&gt;a ) {
49 		double *ary = (double *) linear-&gt;a-&gt;data;
50 		gboolean all_equal;
51 		all_equal = TRUE;
52 		for( i = 1; i &lt; linear-&gt;a-&gt;n; i++ )
53 			if( ary[i] != ary[0] ) {
54 				all_equal = FALSE;
55 				break;
56 			}
57 		if( all_equal )
58 			linear-&gt;a-&gt;n = 1;
59 	}
60 	if( linear-&gt;b ) {
61 		double *ary = (double *) linear-&gt;b-&gt;data;
62 		gboolean all_equal;
63 		all_equal = TRUE;
64 		for( i = 1; i &lt; linear-&gt;b-&gt;n; i++ )
65 			if( ary[i] != ary[0] ) {
66 				all_equal = FALSE;
67 				break;
68 			}
69 		if( all_equal )
70 			linear-&gt;b-&gt;n = 1;
71 	}
72 	linear-&gt;a_ready = VIPS_ARRAY( linear, linear-&gt;n, double );
73 	linear-&gt;b_ready = VIPS_ARRAY( linear, linear-&gt;n, double );
74 	for( i = 0; i &lt; linear-&gt;n; i++ ) {
75 		if( linear-&gt;a ) {
76 			double *ary = (double *) linear-&gt;a-&gt;data;
77 			int j = VIPS_MIN( i, linear-&gt;a-&gt;n - 1 );
78 			linear-&gt;a_ready[i] = ary[j];
79 		}
80 		if( linear-&gt;b ) {
81 			double *ary = (double *) linear-&gt;b-&gt;data;
82 			int j = VIPS_MIN( i, linear-&gt;b-&gt;n - 1 );
83 			linear-&gt;b_ready[i] = ary[j];
84 		}
85 	}
86 	if( linear-&gt;uchar )
87 		arithmetic-&gt;format = VIPS_FORMAT_UCHAR;
88 	if( VIPS_OBJECT_CLASS( vips_linear_parent_class )-&gt;build( object ) )
89 		return( -1 );
90 	return( 0 );
91 }
92 #define LOOP1( IN, OUT ) { \
93 	IN * restrict p = (IN *) in[0]; \
94 	OUT * restrict q = (OUT *) out; \
95 	OUT a1 = a[0]; \
96 	OUT b1 = b[0]; \
97 	int sz = width * nb; \
98 	\
99 	for( x = 0; x &lt; sz; x++ ) \
100 		q[x] = a1 * (OUT) p[x] + b1; \
101 }
102 #define LOOPN( IN, OUT ) { \
103 	IN * restrict p = (IN *) in[0]; \
104 	OUT * restrict q = (OUT *) out; \
105 	\
106 	for( i = 0, x = 0; x &lt; width; x++ ) \
107 		for( k = 0; k &lt; nb; k++, i++ ) \
108 			q[i] = a[k] * (OUT) p[i] + b[k]; \
109 }
110 #define LOOP( IN, OUT ) { \
111 	if( linear-&gt;a-&gt;n == 1 &amp;&amp; linear-&gt;b-&gt;n == 1 ) { \
112 		LOOP1( IN, OUT ); \
113 	} \
114 	else { \
115 		LOOPN( IN, OUT ); \
116 	} \
117 }
118 #define LOOPCMPLXN( IN, OUT ) { \
119 	IN * restrict p = (IN *) in[0]; \
120 	OUT * restrict q = (OUT *) out; \
121 	\
122 	for( x = 0; x &lt; width; x++ ) \
123 		for( k = 0; k &lt; nb; k++ ) { \
124 			q[0] = a[k] * p[0] + b[k]; \
125 			q[1] = p[1]; \
126 			q += 2; \
127 			p += 2; \
128 		} \
129 }
130 #define LOOP1uc( IN ) { \
131 	IN * restrict p = (IN *) in[0]; \
132 	VipsPel * restrict q = (VipsPel *) out; \
133 	float a1 = a[0]; \
134 	float b1 = b[0]; \
135 	int sz = width * nb; \
136 	\
137 	for( x = 0; x &lt; sz; x++ ) { \
138 		float t = a1 * p[x] + b1; \
139 		\
140 		q[x] = VIPS_FCLIP( 0, t, 255 ); \
141 	} \
142 }
143 #define LOOPNuc( IN ) { \
144 	IN * restrict p = (IN *) in[0]; \
145 	VipsPel * restrict q = (VipsPel *) out; \
146 	\
147 	for( i = 0, x = 0; x &lt; width; x++ ) \
148 		for( k = 0; k &lt; nb; k++, i++ ) { \
149 			double t = a[k] * p[i] + b[k]; \
150 			\
151 			q[i] = VIPS_FCLIP( 0, t, 255 ); \
152 		} \
153 }
154 #define LOOPuc( IN ) { \
155 	if( linear-&gt;a-&gt;n == 1 &amp;&amp; linear-&gt;b-&gt;n == 1 ) { \
156 		LOOP1uc( IN ); \
157 	} \
158 	else { \
159 		LOOPNuc( IN ); \
160 	} \
161 }
162 #define LOOPCMPLXNuc( IN ) { \
163 	IN * restrict p = (IN *) in[0]; \
164 	VipsPel * restrict q = (VipsPel *) out; \
165 	\
166 	for( i = 0, x = 0; x &lt; width; x++ ) \
167 		for( k = 0; k &lt; nb; k++, i++ ) { \
168 			double t = a[k] * p[0] + b[k]; \
169 			\
170 			q[i] = VIPS_FCLIP( 0, t, 255 ); \
171 			p += 2; \
172 		} \
173 }
174 static void
175 vips_linear_buffer( VipsArithmetic *arithmetic, 
176 	VipsPel *out, VipsPel **in, int width )
177 {
178 	VipsImage *im = arithmetic-&gt;ready[0];
179 	VipsLinear *linear = (VipsLinear *) arithmetic;
180 	double * restrict a = linear-&gt;a_ready;
181 	double * restrict b = linear-&gt;b_ready;
182 	int nb = im-&gt;Bands;
183 	int i, x, k;
184 	if( linear-&gt;uchar )
185 		switch( vips_image_get_format( im ) ) {
186 		case VIPS_FORMAT_UCHAR: 	
187 			LOOPuc( unsigned char ); break;
188 		case VIPS_FORMAT_CHAR: 		
189 			LOOPuc( signed char ); break; 
190 		case VIPS_FORMAT_USHORT: 	
191 			LOOPuc( unsigned short ); break; 
192 		case VIPS_FORMAT_SHORT: 	
193 			LOOPuc( signed short ); break; 
194 <a name="0"></a>		case VIPS_FORMAT_UINT: 		
195 			LOOPuc( unsigned int ); break; 
196 		case VIPS_FORMAT_INT: 		
197 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			LOOPuc( signed int );  break; 
198 		case VIPS_FORMAT_FLOAT: 	
199 			LOOPuc( float ); break; 
200 		case VIPS_FORMAT_DOUBLE:	
201 			LOOPuc( double ); break; 
202 		case VIPS_FORMAT_COMPLEX:	
203 			LOOPCMPLXNuc( float ); break; 
204 		case VIPS_FORMAT_DPCOMPLEX:	
205 			LOOPCMPLXNuc( double ); break;
206 		default:</b></font>
207 			g_assert_not_reached();
208 		}
209 	else
210 		switch( vips_image_get_format( im ) ) {
211 		case VIPS_FORMAT_UCHAR: 	
212 			LOOP( unsigned char, float ); break;
213 		case VIPS_FORMAT_CHAR: 		
214 			LOOP( signed char, float ); break; 
215 		case VIPS_FORMAT_USHORT: 	
216 			LOOP( unsigned short, float ); break; 
217 		case VIPS_FORMAT_SHORT: 	
218 			LOOP( signed short, float ); break; 
219 		case VIPS_FORMAT_UINT: 		
220 			LOOP( unsigned int, float ); break; 
221 		case VIPS_FORMAT_INT: 		
222 			LOOP( signed int, float );  break; 
223 		case VIPS_FORMAT_FLOAT: 	
224 			LOOP( float, float ); break; 
225 		case VIPS_FORMAT_DOUBLE:	
226 			LOOP( double, double ); break; 
227 		case VIPS_FORMAT_COMPLEX:	
228 			LOOPCMPLXN( float, float ); break; 
229 		case VIPS_FORMAT_DPCOMPLEX:	
230 			LOOPCMPLXN( double, double ); break;
231 		default:
232 			g_assert_not_reached();
233 		}
234 }
235 #define UC VIPS_FORMAT_UCHAR
236 #define C VIPS_FORMAT_CHAR
237 #define US VIPS_FORMAT_USHORT
238 #define S VIPS_FORMAT_SHORT
239 #define UI VIPS_FORMAT_UINT
240 #define I VIPS_FORMAT_INT
241 #define F VIPS_FORMAT_FLOAT
242 #define X VIPS_FORMAT_COMPLEX
243 #define D VIPS_FORMAT_DOUBLE
244 #define DX VIPS_FORMAT_DPCOMPLEX
245 static const VipsBandFormat vips_linear_format_table[10] = {
246    F,  F,  F,  F,  F,  F,  F,  X,  D,  DX 
247 };
248 static void
249 vips_linear_class_init( VipsLinearClass *class )
250 {
251 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
252 	VipsObjectClass *object_class = (VipsObjectClass *) class;
253 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
254 	gobject_class-&gt;set_property = vips_object_set_property;
255 	gobject_class-&gt;get_property = vips_object_get_property;
256 	object_class-&gt;nickname = "linear";
257 	object_class-&gt;description = _( "calculate (a * in + b)" );
258 	object_class-&gt;build = vips_linear_build;
259 	aclass-&gt;process_line = vips_linear_buffer;
260 	vips_arithmetic_set_format_table( aclass, vips_linear_format_table ); 
261 	VIPS_ARG_BOXED( class, "a", 110, 
262 		_( "a" ), 
263 		_( "Multiply by this" ),
264 		VIPS_ARGUMENT_REQUIRED_INPUT,
265 		G_STRUCT_OFFSET( VipsLinear, a ),
266 		VIPS_TYPE_ARRAY_DOUBLE );
267 	VIPS_ARG_BOXED( class, "b", 111, 
268 		_( "b" ), 
269 		_( "Add this" ),
270 		VIPS_ARGUMENT_REQUIRED_INPUT,
271 		G_STRUCT_OFFSET( VipsLinear, b ),
272 		VIPS_TYPE_ARRAY_DOUBLE );
273 	VIPS_ARG_BOOL( class, "uchar", 112, 
274 		_( "uchar" ), 
275 		_( "Output should be uchar" ),
276 		VIPS_ARGUMENT_OPTIONAL_INPUT,
277 		G_STRUCT_OFFSET( VipsLinear, uchar ),
278 		FALSE );
279 }
280 static void
281 vips_linear_init( VipsLinear *linear )
282 {
283 }
284 static int
285 vips_linearv( VipsImage *in, VipsImage **out, 
286 	const double *a, const double *b, int n, va_list ap )
287 {
288 	VipsArea *area_a;
289 	VipsArea *area_b;
290 	int result;
291 	area_a = VIPS_AREA( vips_array_double_new( a, n ) );
292 	area_b = VIPS_AREA( vips_array_double_new( b, n ) );
293 	result = vips_call_split( "linear", ap, in, out, area_a, area_b );
294 	vips_area_unref( area_a );
295 	vips_area_unref( area_b );
296 	return( result );
297 }
298 int
299 vips_linear( VipsImage *in, VipsImage **out, 
300 	const double *a, const double *b, int n, ... )
301 {
302 	va_list ap;
303 	int result;
304 	va_start( ap, n );
305 	result = vips_linearv( in, out, a, b, n, ap );
306 	va_end( ap );
307 	return( result );
308 }
309 int
310 vips_linear1( VipsImage *in, VipsImage **out, double a, double b, ... )
311 {
312 	va_list ap;
313 	int result;
314 	va_start( ap, b );
315 	result = vips_linearv( in, out, &amp;a, &amp;b, 1, ap );
316 	va_end( ap );
317 	return( result );
318 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
