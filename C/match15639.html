<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for im_debugim.c &amp; linear.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for im_debugim.c &amp; linear.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>im_debugim.c (25.0%)<th>linear.c (5.4945054%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(124-130)<td><a href="#" name="0">(346-356)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>im_debugim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* @(#) Function which prints in stdout the values of a picture
 * @(#)
 * @(#) For debuging only
 * @(#) is either memory mapped or in a buffer.
 * @(#)
 * @(#) void 
 * @(#) im_debugim( in )
 * @(#) IMAGE *in;
 * @(#)
 *
 * Copyright: 1991 N. Dessipris
 *
 * Author: N. Dessipris
 * Written on: 18/03/1991
 * Modified on:
 * 15/4/93 J.Cupitt
 *      - returns int, not void now, so error messages work
 *      - detects im-&gt;data invalid.
 * 15/4/93 J.Cupitt
 *      - uses %g format, not %f for printf()
 * 23/7/93 JC
 *	- im_incheck() added
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;

int 
im_debugim( IMAGE *in )
{
/* Check our args. */
	if( im_incheck( in ) )
		return( -1 );
	if( in-&gt;Coding != IM_CODING_NONE ) {
		im_error( "im_debugim", "%s", _( "input must be uncoded" ) );
		return( -1 );
	}

/* What type? First define the loop we want to perform for all types. */
#define loopuc(TYPE) \
	{	TYPE *p = (TYPE *) in-&gt;data; \
		int x, y, z; \
		\
		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
					fprintf(stderr, "%4d", (TYPE)*p++ );\
				} \
			} \
			fprintf(stderr, "\n");\
		} \
	} 

#define loop(TYPE) \
	{	TYPE *p = (TYPE *) in-&gt;data; \
		int x, y, z; \
		\
		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
					fprintf(stderr, "%g\t", (double)*p++ );\
				} \
			} \
			fprintf(stderr, "\n");\
		} \
	} 

#define loopcmplx(TYPE) \
	{	TYPE *p = (TYPE *) in-&gt;data; \
		int x, y, z; \
		\
		for ( y=0; y&lt;in-&gt;Ysize; y++ ) {\
			for ( x=0; x&lt;in-&gt;Xsize; x++ ) {\
				for ( z=0; z&lt;in-&gt;Bands; z++ ) {\
					fprintf(stderr,"re=%g\t",(double)*p++);\
					fprintf(stderr,"im=%g\t",(double)*p++);\
				} \
			} \
			fprintf(stderr, "\n");\
		} \
	} 

/* Now generate code for all types. */
	switch( in-&gt;BandFmt ) {
	case IM_BANDFMT_UCHAR:		loopuc(unsigned char); break; 
	case IM_BANDFMT_CHAR:		loop(char); break; 
<a name="0"></a>	case IM_BANDFMT_USHORT:		loop(unsigned short); break; 
	case IM_BANDFMT_SHORT:		loop(short); break; 
	case IM_BANDFMT_UINT:		loop(unsigned int); break; 
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	case IM_BANDFMT_INT:		loop(int); break; 
	case IM_BANDFMT_FLOAT:		loop(float); break; 
	case IM_BANDFMT_DOUBLE:		loop(double); break; 
	case IM_BANDFMT_COMPLEX:	loopcmplx(float); break; 
	case IM_BANDFMT_DPCOMPLEX:	loopcmplx(double); break; 

	default: </b></font>
		im_error( "im_debugim", "%s", _( "unknown input format") ); 
		return( -1 );
	}

	return( 0 );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>linear.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* im_lintra.c -- linear transform 
 *
 * Copyright: 1990, N. Dessipris, based on im_powtra()
 * Author: Nicos Dessipris
 * Written on: 02/05/1990
 * Modified on: 
 * 23/4/93 JC
 *	- adapted to work with partial images
 * 1/7/93 JC
 *	- adapted for partial v2
 * 7/10/94 JC
 *	- new IM_NEW()
 *	- more typedefs 
 * 9/2/95 JC
 *	- adapted for im_wrap...
 *	- operations on complex images now just transform the real channel
 * 29/9/95 JC
 *	- complex was broken
 * 15/4/97 JC
 *	- return(0) missing from generate, arrgh!
 * 1/7/98 JC
 *	- im_lintra_vec added
 * 3/8/02 JC
 *	- fall back to im_copy() for a == 1, b == 0
 * 10/10/02 JC
 *	- auug, failing to multiply imag for complex! (thanks matt)
 * 10/12/02 JC
 *	- removed im_copy() fallback ... meant that output format could change
 *	  with value :-( very confusing
 * 30/6/04
 *	- added 1 band image * n band vector case
 * 8/12/06
 * 	- add liboil support
 * 9/9/09
 * 	- gtkdoc comment, minor reformat
 * 31/7/10
 * 	- remove liboil
 * 31/10/11
 * 	- rework as a class
 * 	- removed the 1-ary constant path, no faster
 * 30/11/13
 * 	- 1ary is back, faster with gcc 4.8
 * 14/1/14
 * 	- add uchar output option
 * 30/9/17
 * 	- squash constants with all elements equal so we use 1ary path more
 * 	  often
 */

/*

    Copyright (C) 1991-2005 The National Gallery

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;

#include "unary.h"

typedef struct _VipsLinear {
	VipsUnary parent_instance;

	/* Our constants: multiply by a, add b.
	 */
	VipsArea *a;
	VipsArea *b;

	/* uchar output.
	 */
	gboolean uchar;

	/* Our constants expanded to match arith-&gt;ready in size.
	 */
	int n;
	double *a_ready;
	double *b_ready;

} VipsLinear;

typedef VipsUnaryClass VipsLinearClass;

G_DEFINE_TYPE( VipsLinear, vips_linear, VIPS_TYPE_UNARY );

static int
vips_linear_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsArithmetic *arithmetic = VIPS_ARITHMETIC( object );
	VipsUnary *unary = (VipsUnary *) object;
	VipsLinear *linear = (VipsLinear *) object;

	int i;

	/* If we have a three-element vector, we need to bandup the image to
	 * match.
	 */
	linear-&gt;n = 1;
	if( linear-&gt;a )
		linear-&gt;n = VIPS_MAX( linear-&gt;n, linear-&gt;a-&gt;n );
	if( linear-&gt;b )
		linear-&gt;n = VIPS_MAX( linear-&gt;n, linear-&gt;b-&gt;n );
	if( unary-&gt;in ) {
		int bands;

		vips_image_decode_predict( unary-&gt;in, &amp;bands, NULL ); 
		linear-&gt;n = VIPS_MAX( linear-&gt;n, bands );
	}
	arithmetic-&gt;base_bands = linear-&gt;n;

	if( unary-&gt;in &amp;&amp; 
		linear-&gt;a &amp;&amp; 
		linear-&gt;b ) {
		if( vips_check_vector( class-&gt;nickname, 
			linear-&gt;a-&gt;n, unary-&gt;in ) ||
			vips_check_vector( class-&gt;nickname, 
				linear-&gt;b-&gt;n, unary-&gt;in ) )
		return( -1 );
	}

	/* If all elements of the constants are equal, we can shrink them down
	 * to a single element.
	 */
	if( linear-&gt;a ) {
		double *ary = (double *) linear-&gt;a-&gt;data;
		gboolean all_equal;

		all_equal = TRUE;
		for( i = 1; i &lt; linear-&gt;a-&gt;n; i++ )
			if( ary[i] != ary[0] ) {
				all_equal = FALSE;
				break;
			}

		if( all_equal )
			linear-&gt;a-&gt;n = 1;
	}
	if( linear-&gt;b ) {
		double *ary = (double *) linear-&gt;b-&gt;data;
		gboolean all_equal;

		all_equal = TRUE;
		for( i = 1; i &lt; linear-&gt;b-&gt;n; i++ )
			if( ary[i] != ary[0] ) {
				all_equal = FALSE;
				break;
			}

		if( all_equal )
			linear-&gt;b-&gt;n = 1;
	}

	/* Make up-banded versions of our constants.
	 */
	linear-&gt;a_ready = VIPS_ARRAY( linear, linear-&gt;n, double );
	linear-&gt;b_ready = VIPS_ARRAY( linear, linear-&gt;n, double );

	for( i = 0; i &lt; linear-&gt;n; i++ ) {
		if( linear-&gt;a ) {
			double *ary = (double *) linear-&gt;a-&gt;data;
			int j = VIPS_MIN( i, linear-&gt;a-&gt;n - 1 );

			linear-&gt;a_ready[i] = ary[j];
		}

		if( linear-&gt;b ) {
			double *ary = (double *) linear-&gt;b-&gt;data;
			int j = VIPS_MIN( i, linear-&gt;b-&gt;n - 1 );

			linear-&gt;b_ready[i] = ary[j];
		}
	}

	if( linear-&gt;uchar )
		arithmetic-&gt;format = VIPS_FORMAT_UCHAR;

	if( VIPS_OBJECT_CLASS( vips_linear_parent_class )-&gt;build( object ) )
		return( -1 );

	return( 0 );
}

/* Non-complex input, any output, all bands of the constant equal.
 */
#define LOOP1( IN, OUT ) { \
	IN * restrict p = (IN *) in[0]; \
	OUT * restrict q = (OUT *) out; \
	OUT a1 = a[0]; \
	OUT b1 = b[0]; \
	int sz = width * nb; \
	\
	for( x = 0; x &lt; sz; x++ ) \
		q[x] = a1 * (OUT) p[x] + b1; \
}

/* Non-complex input, any output.
 */
#define LOOPN( IN, OUT ) { \
	IN * restrict p = (IN *) in[0]; \
	OUT * restrict q = (OUT *) out; \
	\
	for( i = 0, x = 0; x &lt; width; x++ ) \
		for( k = 0; k &lt; nb; k++, i++ ) \
			q[i] = a[k] * (OUT) p[i] + b[k]; \
}

#define LOOP( IN, OUT ) { \
	if( linear-&gt;a-&gt;n == 1 &amp;&amp; linear-&gt;b-&gt;n == 1 ) { \
		LOOP1( IN, OUT ); \
	} \
	else { \
		LOOPN( IN, OUT ); \
	} \
}

/* Complex input, complex output. 
 */
#define LOOPCMPLXN( IN, OUT ) { \
	IN * restrict p = (IN *) in[0]; \
	OUT * restrict q = (OUT *) out; \
	\
	for( x = 0; x &lt; width; x++ ) \
		for( k = 0; k &lt; nb; k++ ) { \
			q[0] = a[k] * p[0] + b[k]; \
			q[1] = p[1]; \
			q += 2; \
			p += 2; \
		} \
}

/* Non-complex input, any output, all bands of the constant equal, uchar
 * output.
 */
#define LOOP1uc( IN ) { \
	IN * restrict p = (IN *) in[0]; \
	VipsPel * restrict q = (VipsPel *) out; \
	float a1 = a[0]; \
	float b1 = b[0]; \
	int sz = width * nb; \
	\
	for( x = 0; x &lt; sz; x++ ) { \
		float t = a1 * p[x] + b1; \
		\
		q[x] = VIPS_FCLIP( 0, t, 255 ); \
	} \
}

/* Non-complex input, uchar output.
 */
#define LOOPNuc( IN ) { \
	IN * restrict p = (IN *) in[0]; \
	VipsPel * restrict q = (VipsPel *) out; \
	\
	for( i = 0, x = 0; x &lt; width; x++ ) \
		for( k = 0; k &lt; nb; k++, i++ ) { \
			double t = a[k] * p[i] + b[k]; \
			\
			q[i] = VIPS_FCLIP( 0, t, 255 ); \
		} \
}

#define LOOPuc( IN ) { \
	if( linear-&gt;a-&gt;n == 1 &amp;&amp; linear-&gt;b-&gt;n == 1 ) { \
		LOOP1uc( IN ); \
	} \
	else { \
		LOOPNuc( IN ); \
	} \
}

/* Complex input, uchar output. 
 */
#define LOOPCMPLXNuc( IN ) { \
	IN * restrict p = (IN *) in[0]; \
	VipsPel * restrict q = (VipsPel *) out; \
	\
	for( i = 0, x = 0; x &lt; width; x++ ) \
		for( k = 0; k &lt; nb; k++, i++ ) { \
			double t = a[k] * p[0] + b[k]; \
			\
			q[i] = VIPS_FCLIP( 0, t, 255 ); \
			p += 2; \
		} \
}

/* Lintra a buffer, n set of scale/offset.
 */
static void
vips_linear_buffer( VipsArithmetic *arithmetic, 
	VipsPel *out, VipsPel **in, int width )
{
	VipsImage *im = arithmetic-&gt;ready[0];
	VipsLinear *linear = (VipsLinear *) arithmetic;
	double * restrict a = linear-&gt;a_ready;
	double * restrict b = linear-&gt;b_ready;
	int nb = im-&gt;Bands;

	int i, x, k;

	if( linear-&gt;uchar )
		switch( vips_image_get_format( im ) ) {
		case VIPS_FORMAT_UCHAR: 	
			LOOPuc( unsigned char ); break;
		case VIPS_FORMAT_CHAR: 		
			LOOPuc( signed char ); break; 
		case VIPS_FORMAT_USHORT: 	
			LOOPuc( unsigned short ); break; 
		case VIPS_FORMAT_SHORT: 	
			LOOPuc( signed short ); break; 
<a name="0"></a>		case VIPS_FORMAT_UINT: 		
			LOOPuc( unsigned int ); break; 
		case VIPS_FORMAT_INT: 		
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			LOOPuc( signed int );  break; 
		case VIPS_FORMAT_FLOAT: 	
			LOOPuc( float ); break; 
		case VIPS_FORMAT_DOUBLE:	
			LOOPuc( double ); break; 
		case VIPS_FORMAT_COMPLEX:	
			LOOPCMPLXNuc( float ); break; 
		case VIPS_FORMAT_DPCOMPLEX:	
			LOOPCMPLXNuc( double ); break;

		default:</b></font>
			g_assert_not_reached();
		}
	else
		switch( vips_image_get_format( im ) ) {
		case VIPS_FORMAT_UCHAR: 	
			LOOP( unsigned char, float ); break;
		case VIPS_FORMAT_CHAR: 		
			LOOP( signed char, float ); break; 
		case VIPS_FORMAT_USHORT: 	
			LOOP( unsigned short, float ); break; 
		case VIPS_FORMAT_SHORT: 	
			LOOP( signed short, float ); break; 
		case VIPS_FORMAT_UINT: 		
			LOOP( unsigned int, float ); break; 
		case VIPS_FORMAT_INT: 		
			LOOP( signed int, float );  break; 
		case VIPS_FORMAT_FLOAT: 	
			LOOP( float, float ); break; 
		case VIPS_FORMAT_DOUBLE:	
			LOOP( double, double ); break; 
		case VIPS_FORMAT_COMPLEX:	
			LOOPCMPLXN( float, float ); break; 
		case VIPS_FORMAT_DPCOMPLEX:	
			LOOPCMPLXN( double, double ); break;

		default:
			g_assert_not_reached();
		}

}

/* Save a bit of typing.
 */
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX

/* Format doesn't change with linear.
 */
static const VipsBandFormat vips_linear_format_table[10] = {
/* UC  C   US  S   UI  I   F   X   D   DX */
   F,  F,  F,  F,  F,  F,  F,  X,  D,  DX 
};

static void
vips_linear_class_init( VipsLinearClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "linear";
	object_class-&gt;description = _( "calculate (a * in + b)" );
	object_class-&gt;build = vips_linear_build;

	aclass-&gt;process_line = vips_linear_buffer;

	vips_arithmetic_set_format_table( aclass, vips_linear_format_table ); 

	VIPS_ARG_BOXED( class, "a", 110, 
		_( "a" ), 
		_( "Multiply by this" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsLinear, a ),
		VIPS_TYPE_ARRAY_DOUBLE );

	VIPS_ARG_BOXED( class, "b", 111, 
		_( "b" ), 
		_( "Add this" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsLinear, b ),
		VIPS_TYPE_ARRAY_DOUBLE );

	VIPS_ARG_BOOL( class, "uchar", 112, 
		_( "uchar" ), 
		_( "Output should be uchar" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsLinear, uchar ),
		FALSE );

}

static void
vips_linear_init( VipsLinear *linear )
{
}

static int
vips_linearv( VipsImage *in, VipsImage **out, 
	const double *a, const double *b, int n, va_list ap )
{
	VipsArea *area_a;
	VipsArea *area_b;
	int result;

	area_a = VIPS_AREA( vips_array_double_new( a, n ) );
	area_b = VIPS_AREA( vips_array_double_new( b, n ) );

	result = vips_call_split( "linear", ap, in, out, area_a, area_b );

	vips_area_unref( area_a );
	vips_area_unref( area_b );

	return( result );
}

/**
 * vips_linear: (method)
 * @in: image to transform
 * @out: (out): output image
 * @a: (array length=n): array of constants for multiplication
 * @b: (array length=n): array of constants for addition
 * @n: length of constant arrays
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @uchar: output uchar pixels
 *
 * Pass an image through a linear transform, ie. (@out = @in * @a + @b). Output
 * is float for integer input, double for double input, complex for
 * complex input and double complex for double complex input. Set @uchar to
 * output uchar pixels. 
 *
 * If the arrays of constants have just one element, that constant is used for 
 * all image bands. If the arrays have more than one element and they have 
 * the same number of elements as there are bands in the image, then 
 * one array element is used for each band. If the arrays have more than one
 * element and the image only has a single band, the result is a many-band
 * image where each band corresponds to one array element.
 *
 * See also: vips_linear1(), vips_add().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_linear( VipsImage *in, VipsImage **out, 
	const double *a, const double *b, int n, ... )
{
	va_list ap;
	int result;

	va_start( ap, n );
	result = vips_linearv( in, out, a, b, n, ap );
	va_end( ap );

	return( result );
}

/**
 * vips_linear1: (method)
 * @in: image to transform
 * @out: (out): output image
 * @a: constant for multiplication
 * @b: constant for addition
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @uchar: output uchar pixels
 *
 * Run vips_linear() with a single constant. 
 *
 * See also: vips_linear().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_linear1( VipsImage *in, VipsImage **out, double a, double b, ... )
{
	va_list ap;
	int result;

	va_start( ap, b );
	result = vips_linearv( in, out, &amp;a, &amp;b, 1, ap );
	va_end( ap );

	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
