
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #define FOR(i,n) for (i = 0;i < n;++i)
3  #define sv static void
4  typedef unsigned char u8;
5  typedef ulong32 u32;
6  typedef ulong64 u64;
7  typedef long64 i64;
8  typedef i64 gf[16];
9  static const u8
10    nine[32] = {9};
11  static const gf
12    gf0,
13    gf1 = {1},
14    gf121665 = {0xDB41,1},
15    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
16    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
17    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
18    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
19    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
20  static int vn(const u8 *x,const u8 *y,int n)
21  {
22    int i;
23    u32 d = 0;
24    FOR(i,n) d |= x[i]^y[i];
25    return (1 & ((d - 1) >> 8)) - 1;
26  }
27  static int tweetnacl_crypto_verify_32(const u8 *x,const u8 *y)
28  {
29    return vn(x,y,32);
30  }
31  sv set25519(gf r, const gf a)
32  {
33    int i;
34    FOR(i,16) r[i]=a[i];
35  }
36  sv car25519(gf o)
37  {
38    int i;
39    i64 c;
40    FOR(i,16) {
41      o[i]+=(1LL<<16);
42      c=o[i]>>16;
43      o[(i+1)*(i<15)]+=c-1+37*(c-1)*(i==15);
44      o[i]-=c<<16;
45    }
46  }
47  sv sel25519(gf p,gf q,int b)
48  {
49    i64 t,i,c=~(b-1);
50    FOR(i,16) {
51      t= c&(p[i]^q[i]);
52      p[i]^=t;
53      q[i]^=t;
54    }
55  }
56  sv pack25519(u8 *o,const gf n)
57  {
58    int i,j,b;
59    gf m,t;
60    FOR(i,16) t[i]=n[i];
61    car25519(t);
62    car25519(t);
63    car25519(t);
64    FOR(j,2) {
65      m[0]=t[0]-0xffed;
66      for(i=1;i<15;i++) {
67        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
68        m[i-1]&=0xffff;
69      }
70      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
71      b=(m[15]>>16)&1;
72      m[14]&=0xffff;
73      sel25519(t,m,1-b);
74    }
75    FOR(i,16) {
76      o[2*i]=t[i]&0xff;
77      o[2*i+1]=t[i]>>8;
78    }
79  }
80  static int neq25519(const gf a, const gf b)
81  {
82    u8 c[32],d[32];
83    pack25519(c,a);
84    pack25519(d,b);
85    return tweetnacl_crypto_verify_32(c,d);
86  }
87  static u8 par25519(const gf a)
88  {
89    u8 d[32];
90    pack25519(d,a);
91    return d[0]&1;
92  }
93  sv unpack25519(gf o, const u8 *n)
94  {
95    int i;
96    FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
97    o[15]&=0x7fff;
98  }
99  sv A(gf o,const gf a,const gf b)
100  {
101    int i;
102    FOR(i,16) o[i]=a[i]+b[i];
103  }
104  sv Z(gf o,const gf a,const gf b)
105  {
106    int i;
107    FOR(i,16) o[i]=a[i]-b[i];
108  }
109  sv M(gf o,const gf a,const gf b)
110  {
111    i64 i,j,t[31];
112    FOR(i,31) t[i]=0;
113    FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
114    FOR(i,15) t[i]+=38*t[i+16];
115    FOR(i,16) o[i]=t[i];
116    car25519(o);
117    car25519(o);
118  }
119  sv S(gf o,const gf a)
120  {
121    M(o,a,a);
122  }
123  sv inv25519(gf o,const gf i)
124  {
125    gf c;
126    int a;
127    FOR(a,16) c[a]=i[a];
128    for(a=253;a>=0;a--) {
129      S(c,c);
130      if(a!=2&&a!=4) M(c,c,i);
131    }
132    FOR(a,16) o[a]=c[a];
133  }
134  sv pow2523(gf o,const gf i)
135  {
136    gf c;
137    int a;
138    FOR(a,16) c[a]=i[a];
139    for(a=250;a>=0;a--) {
140      S(c,c);
141      if(a!=1) M(c,c,i);
142    }
143    FOR(a,16) o[a]=c[a];
144  }
145  int tweetnacl_crypto_scalarmult(u8 *q,const u8 *n,const u8 *p)
146  {
147    u8 z[32];
148    i64 x[80],r,i;
149    gf a,b,c,d,e,f;
150    FOR(i,31) z[i]=n[i];
151    z[31]=(n[31]&127)|64;
152    z[0]&=248;
153    unpack25519(x,p);
154    FOR(i,16) {
155      b[i]=x[i];
156      d[i]=a[i]=c[i]=0;
157    }
158    a[0]=d[0]=1;
159    for(i=254;i>=0;--i) {
160      r=(z[i>>3]>>(i&7))&1;
161      sel25519(a,b,r);
162      sel25519(c,d,r);
163      A(e,a,c);
164      Z(a,a,c);
165      A(c,b,d);
166      Z(b,b,d);
167      S(d,e);
168      S(f,a);
169      M(a,c,a);
170      M(c,b,e);
171      A(e,a,c);
172      Z(a,a,c);
173      S(b,a);
174      Z(c,d,f);
175      M(a,c,gf121665);
176      A(a,a,d);
177      M(c,c,a);
178      M(a,d,f);
179      M(d,b,x);
180      S(b,e);
181      sel25519(a,b,r);
182      sel25519(c,d,r);
183    }
184    FOR(i,16) {
185      x[i+16]=a[i];
186      x[i+32]=c[i];
187      x[i+48]=b[i];
188      x[i+64]=d[i];
189    }
190    inv25519(x+32,x+32);
191    M(x+16,x+16,x+32);
192    pack25519(q,x+16);
193    return 0;
194  }
195  int tweetnacl_crypto_scalarmult_base(u8 *q,const u8 *n)
196  {
197    return tweetnacl_crypto_scalarmult(q,n,nine);
198  }
199  static LTC_INLINE int tweetnacl_crypto_hash_ctx(u8 *out,const u8 *m,u64 n,const u8 *ctx,u32 cs)
200  {
201    unsigned long len = 64;
202    int hash_idx = find_hash("sha512");
203    if (n > ULONG_MAX) return CRYPT_OVERFLOW;
204    if(cs == 0)
205      return hash_memory(hash_idx, m, n, out, &len);
206    return hash_memory_multi(hash_idx, out, &len, ctx, cs, m, n, LTC_NULL);
207  }
208  static LTC_INLINE int tweetnacl_crypto_hash(u8 *out,const u8 *m,u64 n)
209  {
210    return tweetnacl_crypto_hash_ctx(out, m, n, NULL, 0);
211  }
212  sv add(gf p[4],gf q[4])
213  {
214    gf a,b,c,d,t,e,f,g,h;
215    Z(a, p[1], p[0]);
216    Z(t, q[1], q[0]);
217    M(a, a, t);
218    A(b, p[0], p[1]);
219    A(t, q[0], q[1]);
220    M(b, b, t);
221    M(c, p[3], q[3]);
222    M(c, c, D2);
223    M(d, p[2], q[2]);
224    A(d, d, d);
225    Z(e, b, a);
226    Z(f, d, c);
227    A(g, d, c);
228    A(h, b, a);
229    M(p[0], e, f);
230    M(p[1], h, g);
231    M(p[2], g, f);
232    M(p[3], e, h);
233  }
234  sv cswap(gf p[4],gf q[4],u8 b)
235  {
236    int i;
237    FOR(i,4)
238      sel25519(p[i],q[i],b);
239  }
<span onclick='openModal()' class='match'>240  sv pack(u8 *r,gf p[4])
241  {
242    gf tx, ty, zi;
243    inv25519(zi, p[2]);
</span>244    M(tx, p[0], zi);
245    M(ty, p[1], zi);
246    pack25519(r, ty);
247    r[31] ^= par25519(tx) << 7;
248  }
249  sv scalarmult(gf p[4],gf q[4],const u8 *s)
250  {
251    int i;
252    set25519(p[0],gf0);
253    set25519(p[1],gf1);
254    set25519(p[2],gf1);
255    set25519(p[3],gf0);
256    for (i = 255;i >= 0;--i) {
257      u8 b = (s[i/8]>>(i&7))&1;
258      cswap(p,q,b);
259      add(q,p);
260      add(p,p);
261      cswap(p,q,b);
262    }
263  }
264  sv scalarbase(gf p[4],const u8 *s)
265  {
266    gf q[4];
267    set25519(q[0],X);
268    set25519(q[1],Y);
269    set25519(q[2],gf1);
270    M(q[3],X,Y);
271    scalarmult(p,q,s);
272  }
273  int tweetnacl_crypto_sk_to_pk(u8 *pk, const u8 *sk)
274  {
275    u8 d[64];
276    gf p[4];
277    tweetnacl_crypto_hash(d, sk, 32);
278    d[0] &= 248;
279    d[31] &= 127;
280    d[31] |= 64;
281    scalarbase(p,d);
282    pack(pk,p);
283    return 0;
284  }
285  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, u8 *pk, u8 *sk)
286  {
287    int err;
288    if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
289       return err;
290    }
291    if (prng_descriptor[wprng].read(sk,32, prng) != 32) {
292       return CRYPT_ERROR_READPRNG;
293    }
294    if ((err = tweetnacl_crypto_sk_to_pk(pk, sk)) != CRYPT_OK) {
295       return err;
296    }
297    return CRYPT_OK;
298  }
299  static const u64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};
300  sv modL(u8 *r,i64 x[64])
301  {
302    i64 carry,i,j;
303    for (i = 63;i >= 32;--i) {
304      carry = 0;
305      for (j = i - 32;j < i - 12;++j) {
306        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
307        carry = (x[j] + 128) >> 8;
308        x[j] -= carry << 8;
309      }
310      x[j] += carry;
311      x[i] = 0;
312    }
313    carry = 0;
314    FOR(j,32) {
315      x[j] += carry - (x[31] >> 4) * L[j];
316      carry = x[j] >> 8;
317      x[j] &= 255;
318    }
319    FOR(j,32) x[j] -= carry * L[j];
320    FOR(i,32) {
321      x[i+1] += x[i] >> 8;
322      r[i] = x[i] & 255;
323    }
324  }
325  sv reduce(u8 *r)
326  {
327    i64 x[64],i;
328    FOR(i,64) x[i] = (u64) r[i];
329    FOR(i,64) r[i] = 0;
330    modL(r,x);
331  }
332  int tweetnacl_crypto_sign(u8 *sm,u64 *smlen,const u8 *m,u64 mlen,const u8 *sk,const u8 *pk, const u8 *ctx, u64 cs)
333  {
334    u8 d[64],h[64],r[64];
335    i64 i,j,x[64];
336    gf p[4];
337    tweetnacl_crypto_hash(d, sk, 32);
338    d[0] &= 248;
339    d[31] &= 127;
340    d[31] |= 64;
341    *smlen = mlen+64;
342    FOR(i,(i64)mlen) sm[64 + i] = m[i];
343    FOR(i,32) sm[32 + i] = d[32 + i];
344    tweetnacl_crypto_hash_ctx(r, sm+32, mlen+32,ctx,cs);
345    reduce(r);
346    scalarbase(p,r);
347    pack(sm,p);
348    FOR(i,32) sm[i+32] = pk[i];
349    tweetnacl_crypto_hash_ctx(h,sm,mlen + 64,ctx,cs);
350    reduce(h);
351    FOR(i,64) x[i] = 0;
352    FOR(i,32) x[i] = (u64) r[i];
353    FOR(i,32) FOR(j,32) x[i+j] += h[i] * (u64) d[j];
354    modL(sm + 32,x);
355    return 0;
356  }
357  static int unpackneg(gf r[4],const u8 p[32])
358  {
359    gf t, chk, num, den, den2, den4, den6;
360    set25519(r[2],gf1);
361    unpack25519(r[1],p);
362    S(num,r[1]);
363    M(den,num,D);
364    Z(num,num,r[2]);
365    A(den,r[2],den);
366    S(den2,den);
367    S(den4,den2);
368    M(den6,den4,den2);
369    M(t,den6,num);
370    M(t,t,den);
371    pow2523(t,t);
372    M(t,t,num);
373    M(t,t,den);
374    M(t,t,den);
375    M(r[0],t,den);
376    S(chk,r[0]);
377    M(chk,chk,den);
378    if (neq25519(chk, num)) M(r[0],r[0],I);
379    S(chk,r[0]);
380    M(chk,chk,den);
381    if (neq25519(chk, num)) return -1;
382    if (par25519(r[0]) == (p[31]>>7)) Z(r[0],gf0,r[0]);
383    M(r[3],r[0],r[1]);
384    return 0;
385  }
386  int tweetnacl_crypto_sign_open(int *stat, u8 *m,u64 *mlen,const u8 *sm,u64 smlen,const u8 *ctx,u64 cs,const u8 *pk)
387  {
388    u64 i;
389    u8 s[32],t[32],h[64];
390    gf p[4],q[4];
391    *stat = 0;
392    if (*mlen < smlen) return CRYPT_BUFFER_OVERFLOW;
393    *mlen = -1;
394    if (smlen < 64) return CRYPT_INVALID_ARG;
395    if (unpackneg(q,pk)) return CRYPT_ERROR;
396    XMEMMOVE(m,sm,smlen);
397    XMEMMOVE(s,m + 32,32);
398    XMEMMOVE(m + 32,pk,32);
399    tweetnacl_crypto_hash_ctx(h,m,smlen,ctx,cs);
400    reduce(h);
401    scalarmult(p,q,h);
402    scalarbase(q,s);
403    add(p,q);
404    pack(t,p);
405    smlen -= 64;
406    if (tweetnacl_crypto_verify_32(sm, t)) {
407      FOR(i,smlen) m[i] = 0;
408      zeromem(m, smlen);
409      return CRYPT_OK;
410    }
411    *stat = 1;
412    XMEMMOVE(m,m + 64,smlen);
413    *mlen = smlen;
414    return CRYPT_OK;
415  }
416  int tweetnacl_crypto_ph(u8 *out,const u8 *msg,u64 msglen)
417  {
418    return tweetnacl_crypto_hash(out, msg, msglen);
419  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #define FOR(i,n) for (i = 0;i < n;++i)
3  #define sv static void
4  typedef unsigned char u8;
5  typedef ulong32 u32;
6  typedef ulong64 u64;
7  typedef long64 i64;
8  typedef i64 gf[16];
9  static const u8
10    nine[32] = {9};
11  static const gf
12    gf0,
13    gf1 = {1},
14    gf121665 = {0xDB41,1},
15    D = {0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203},
16    D2 = {0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406},
17    X = {0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169},
18    Y = {0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666},
19    I = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83};
20  static int vn(const u8 *x,const u8 *y,int n)
21  {
22    int i;
23    u32 d = 0;
24    FOR(i,n) d |= x[i]^y[i];
25    return (1 & ((d - 1) >> 8)) - 1;
26  }
27  static int tweetnacl_crypto_verify_32(const u8 *x,const u8 *y)
28  {
29    return vn(x,y,32);
30  }
31  sv set25519(gf r, const gf a)
32  {
33    int i;
34    FOR(i,16) r[i]=a[i];
35  }
36  sv car25519(gf o)
37  {
38    int i;
39    i64 c;
40    FOR(i,16) {
41      o[i]+=(1LL<<16);
42      c=o[i]>>16;
43      o[(i+1)*(i<15)]+=c-1+37*(c-1)*(i==15);
44      o[i]-=c<<16;
45    }
46  }
47  sv sel25519(gf p,gf q,int b)
48  {
49    i64 t,i,c=~(b-1);
50    FOR(i,16) {
51      t= c&(p[i]^q[i]);
52      p[i]^=t;
53      q[i]^=t;
54    }
55  }
56  sv pack25519(u8 *o,const gf n)
57  {
58    int i,j,b;
59    gf m,t;
60    FOR(i,16) t[i]=n[i];
61    car25519(t);
62    car25519(t);
63    car25519(t);
64    FOR(j,2) {
65      m[0]=t[0]-0xffed;
66      for(i=1;i<15;i++) {
67        m[i]=t[i]-0xffff-((m[i-1]>>16)&1);
68        m[i-1]&=0xffff;
69      }
70      m[15]=t[15]-0x7fff-((m[14]>>16)&1);
71      b=(m[15]>>16)&1;
72      m[14]&=0xffff;
73      sel25519(t,m,1-b);
74    }
75    FOR(i,16) {
76      o[2*i]=t[i]&0xff;
77      o[2*i+1]=t[i]>>8;
78    }
79  }
80  static int neq25519(const gf a, const gf b)
81  {
82    u8 c[32],d[32];
83    pack25519(c,a);
84    pack25519(d,b);
85    return tweetnacl_crypto_verify_32(c,d);
86  }
87  static u8 par25519(const gf a)
88  {
89    u8 d[32];
90    pack25519(d,a);
91    return d[0]&1;
92  }
93  sv unpack25519(gf o, const u8 *n)
94  {
95    int i;
96    FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
97    o[15]&=0x7fff;
98  }
99  sv A(gf o,const gf a,const gf b)
100  {
101    int i;
102    FOR(i,16) o[i]=a[i]+b[i];
103  }
104  sv Z(gf o,const gf a,const gf b)
105  {
106    int i;
107    FOR(i,16) o[i]=a[i]-b[i];
108  }
109  sv M(gf o,const gf a,const gf b)
110  {
111    i64 i,j,t[31];
112    FOR(i,31) t[i]=0;
113    FOR(i,16) FOR(j,16) t[i+j]+=a[i]*b[j];
114    FOR(i,15) t[i]+=38*t[i+16];
115    FOR(i,16) o[i]=t[i];
116    car25519(o);
117    car25519(o);
118  }
119  sv S(gf o,const gf a)
120  {
121    M(o,a,a);
122  }
123  sv inv25519(gf o,const gf i)
124  {
125    gf c;
126    int a;
127    FOR(a,16) c[a]=i[a];
128    for(a=253;a>=0;a--) {
129      S(c,c);
130      if(a!=2&&a!=4) M(c,c,i);
131    }
132    FOR(a,16) o[a]=c[a];
133  }
134  sv pow2523(gf o,const gf i)
135  {
136    gf c;
137    int a;
138    FOR(a,16) c[a]=i[a];
139    for(a=250;a>=0;a--) {
140      S(c,c);
141      if(a!=1) M(c,c,i);
142    }
143    FOR(a,16) o[a]=c[a];
144  }
145  int tweetnacl_crypto_scalarmult(u8 *q,const u8 *n,const u8 *p)
146  {
147    u8 z[32];
148    i64 x[80],r,i;
149    gf a,b,c,d,e,f;
150    FOR(i,31) z[i]=n[i];
151    z[31]=(n[31]&127)|64;
152    z[0]&=248;
153    unpack25519(x,p);
154    FOR(i,16) {
155      b[i]=x[i];
156      d[i]=a[i]=c[i]=0;
157    }
158    a[0]=d[0]=1;
159    for(i=254;i>=0;--i) {
160      r=(z[i>>3]>>(i&7))&1;
161      sel25519(a,b,r);
162      sel25519(c,d,r);
163      A(e,a,c);
164      Z(a,a,c);
165      A(c,b,d);
166      Z(b,b,d);
167      S(d,e);
168      S(f,a);
169      M(a,c,a);
170      M(c,b,e);
171      A(e,a,c);
172      Z(a,a,c);
173      S(b,a);
174      Z(c,d,f);
175      M(a,c,gf121665);
176      A(a,a,d);
177      M(c,c,a);
178      M(a,d,f);
179      M(d,b,x);
180      S(b,e);
181      sel25519(a,b,r);
182      sel25519(c,d,r);
183    }
184    FOR(i,16) {
185      x[i+16]=a[i];
186      x[i+32]=c[i];
187      x[i+48]=b[i];
188      x[i+64]=d[i];
189    }
190    inv25519(x+32,x+32);
191    M(x+16,x+16,x+32);
192    pack25519(q,x+16);
193    return 0;
194  }
195  int tweetnacl_crypto_scalarmult_base(u8 *q,const u8 *n)
196  {
197    return tweetnacl_crypto_scalarmult(q,n,nine);
198  }
199  static LTC_INLINE int tweetnacl_crypto_hash_ctx(u8 *out,const u8 *m,u64 n,const u8 *ctx,u32 cs)
200  {
201    unsigned long len = 64;
202    int hash_idx = find_hash("sha512");
203    if (n > ULONG_MAX) return CRYPT_OVERFLOW;
204    if(cs == 0)
205      return hash_memory(hash_idx, m, n, out, &len);
206    return hash_memory_multi(hash_idx, out, &len, ctx, cs, m, n, LTC_NULL);
207  }
208  static LTC_INLINE int tweetnacl_crypto_hash(u8 *out,const u8 *m,u64 n)
209  {
210    return tweetnacl_crypto_hash_ctx(out, m, n, NULL, 0);
211  }
212  sv add(gf p[4],gf q[4])
213  {
214    gf a,b,c,d,t,e,f,g,h;
215    Z(a, p[1], p[0]);
216    Z(t, q[1], q[0]);
217    M(a, a, t);
218    A(b, p[0], p[1]);
219    A(t, q[0], q[1]);
220    M(b, b, t);
221    M(c, p[3], q[3]);
222    M(c, c, D2);
223    M(d, p[2], q[2]);
224    A(d, d, d);
225    Z(e, b, a);
226    Z(f, d, c);
227    A(g, d, c);
228    A(h, b, a);
229    M(p[0], e, f);
230    M(p[1], h, g);
231    M(p[2], g, f);
232    M(p[3], e, h);
233  }
234  sv cswap(gf p[4],gf q[4],u8 b)
235  {
236    int i;
237    FOR(i,4)
238      sel25519(p[i],q[i],b);
239  }
240  sv pack(u8 *r,gf p[4])
241  {
242    gf tx, ty, zi;
243    inv25519(zi, p[2]);
244    M(tx, p[0], zi);
245    M(ty, p[1], zi);
246    pack25519(r, ty);
247    r[31] ^= par25519(tx) << 7;
248  }
249  sv scalarmult(gf p[4],gf q[4],const u8 *s)
250  {
251    int i;
252    set25519(p[0],gf0);
253    set25519(p[1],gf1);
254    set25519(p[2],gf1);
255    set25519(p[3],gf0);
256    for (i = 255;i >= 0;--i) {
257      u8 b = (s[i/8]>>(i&7))&1;
258      cswap(p,q,b);
259      add(q,p);
260      add(p,p);
261      cswap(p,q,b);
262    }
263  }
264  sv scalarbase(gf p[4],const u8 *s)
265  {
266    gf q[4];
267    set25519(q[0],X);
268    set25519(q[1],Y);
269    set25519(q[2],gf1);
270    M(q[3],X,Y);
271    scalarmult(p,q,s);
272  }
273  int tweetnacl_crypto_sk_to_pk(u8 *pk, const u8 *sk)
274  {
275    u8 d[64];
276    gf p[4];
277    tweetnacl_crypto_hash(d, sk, 32);
278    d[0] &= 248;
279    d[31] &= 127;
280    d[31] |= 64;
281    scalarbase(p,d);
282    pack(pk,p);
283    return 0;
284  }
285  int tweetnacl_crypto_sign_keypair(prng_state *prng, int wprng, u8 *pk, u8 *sk)
286  {
287    int err;
288    if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
289       return err;
290    }
291    if (prng_descriptor[wprng].read(sk,32, prng) != 32) {
292       return CRYPT_ERROR_READPRNG;
293    }
294    if ((err = tweetnacl_crypto_sk_to_pk(pk, sk)) != CRYPT_OK) {
295       return err;
296    }
297    return CRYPT_OK;
298  }
299  static const u64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};
<span onclick='openModal()' class='match'>300  sv modL(u8 *r,i64 x[64])
301  {
302    i64 carry,i,j;
303    for (i = 63;i >= 32;--i) {
</span>304      carry = 0;
305      for (j = i - 32;j < i - 12;++j) {
306        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
307        carry = (x[j] + 128) >> 8;
308        x[j] -= carry << 8;
309      }
310      x[j] += carry;
311      x[i] = 0;
312    }
313    carry = 0;
314    FOR(j,32) {
315      x[j] += carry - (x[31] >> 4) * L[j];
316      carry = x[j] >> 8;
317      x[j] &= 255;
318    }
319    FOR(j,32) x[j] -= carry * L[j];
320    FOR(i,32) {
321      x[i+1] += x[i] >> 8;
322      r[i] = x[i] & 255;
323    }
324  }
325  sv reduce(u8 *r)
326  {
327    i64 x[64],i;
328    FOR(i,64) x[i] = (u64) r[i];
329    FOR(i,64) r[i] = 0;
330    modL(r,x);
331  }
332  int tweetnacl_crypto_sign(u8 *sm,u64 *smlen,const u8 *m,u64 mlen,const u8 *sk,const u8 *pk, const u8 *ctx, u64 cs)
333  {
334    u8 d[64],h[64],r[64];
335    i64 i,j,x[64];
336    gf p[4];
337    tweetnacl_crypto_hash(d, sk, 32);
338    d[0] &= 248;
339    d[31] &= 127;
340    d[31] |= 64;
341    *smlen = mlen+64;
342    FOR(i,(i64)mlen) sm[64 + i] = m[i];
343    FOR(i,32) sm[32 + i] = d[32 + i];
344    tweetnacl_crypto_hash_ctx(r, sm+32, mlen+32,ctx,cs);
345    reduce(r);
346    scalarbase(p,r);
347    pack(sm,p);
348    FOR(i,32) sm[i+32] = pk[i];
349    tweetnacl_crypto_hash_ctx(h,sm,mlen + 64,ctx,cs);
350    reduce(h);
351    FOR(i,64) x[i] = 0;
352    FOR(i,32) x[i] = (u64) r[i];
353    FOR(i,32) FOR(j,32) x[i+j] += h[i] * (u64) d[j];
354    modL(sm + 32,x);
355    return 0;
356  }
357  static int unpackneg(gf r[4],const u8 p[32])
358  {
359    gf t, chk, num, den, den2, den4, den6;
360    set25519(r[2],gf1);
361    unpack25519(r[1],p);
362    S(num,r[1]);
363    M(den,num,D);
364    Z(num,num,r[2]);
365    A(den,r[2],den);
366    S(den2,den);
367    S(den4,den2);
368    M(den6,den4,den2);
369    M(t,den6,num);
370    M(t,t,den);
371    pow2523(t,t);
372    M(t,t,num);
373    M(t,t,den);
374    M(t,t,den);
375    M(r[0],t,den);
376    S(chk,r[0]);
377    M(chk,chk,den);
378    if (neq25519(chk, num)) M(r[0],r[0],I);
379    S(chk,r[0]);
380    M(chk,chk,den);
381    if (neq25519(chk, num)) return -1;
382    if (par25519(r[0]) == (p[31]>>7)) Z(r[0],gf0,r[0]);
383    M(r[3],r[0],r[1]);
384    return 0;
385  }
386  int tweetnacl_crypto_sign_open(int *stat, u8 *m,u64 *mlen,const u8 *sm,u64 smlen,const u8 *ctx,u64 cs,const u8 *pk)
387  {
388    u64 i;
389    u8 s[32],t[32],h[64];
390    gf p[4],q[4];
391    *stat = 0;
392    if (*mlen < smlen) return CRYPT_BUFFER_OVERFLOW;
393    *mlen = -1;
394    if (smlen < 64) return CRYPT_INVALID_ARG;
395    if (unpackneg(q,pk)) return CRYPT_ERROR;
396    XMEMMOVE(m,sm,smlen);
397    XMEMMOVE(s,m + 32,32);
398    XMEMMOVE(m + 32,pk,32);
399    tweetnacl_crypto_hash_ctx(h,m,smlen,ctx,cs);
400    reduce(h);
401    scalarmult(p,q,h);
402    scalarbase(q,s);
403    add(p,q);
404    pack(t,p);
405    smlen -= 64;
406    if (tweetnacl_crypto_verify_32(sm, t)) {
407      FOR(i,smlen) m[i] = 0;
408      zeromem(m, smlen);
409      return CRYPT_OK;
410    }
411    *stat = 1;
412    XMEMMOVE(m,m + 64,smlen);
413    *mlen = smlen;
414    return CRYPT_OK;
415  }
416  int tweetnacl_crypto_ph(u8 *out,const u8 *msg,u64 msglen)
417  {
418    return tweetnacl_crypto_hash(out, msg, msglen);
419  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-tweetnacl.c</div>
                </div>
                <div class="column column_space"><pre><code>240  sv pack(u8 *r,gf p[4])
241  {
242    gf tx, ty, zi;
243    inv25519(zi, p[2]);
</pre></code></div>
                <div class="column column_space"><pre><code>300  sv modL(u8 *r,i64 x[64])
301  {
302    i64 carry,i,j;
303    for (i = 63;i >= 32;--i) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    