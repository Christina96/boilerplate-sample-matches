
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.849855630413859%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_PWM_ENABLED)
3  #if !(NRFX_CHECK(NRFX_PWM0_ENABLED) || NRFX_CHECK(NRFX_PWM1_ENABLED) || \
4        NRFX_CHECK(NRFX_PWM2_ENABLED) || NRFX_CHECK(NRFX_PWM3_ENABLED))
5  #error "No enabled PWM instances. Check <nrfx_config.h>."
6  #endif
7  #include <nrfx_pwm.h>
8  #include <hal/nrf_gpio.h>
9  #define NRFX_LOG_MODULE PWM
10  #include <nrfx_log.h>
11  #if NRFX_CHECK(NRFX_PWM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
12  #include <hal/nrf_egu.h>
13  #define USE_DMA_ISSUE_WORKAROUND
14  #endif
15  #if defined(USE_DMA_ISSUE_WORKAROUND)
16  #define EGU_IRQn(i)         EGU_IRQn_(i)
17  #define EGU_IRQn_(i)        SWI##i##_EGU##i##_IRQn
18  #define EGU_IRQHandler(i)   EGU_IRQHandler_(i)
19  #define EGU_IRQHandler_(i)  nrfx_egu_##i##_irq_handler
20  #define DMA_ISSUE_EGU_IDX           NRFX_PWM_NRF52_ANOMALY_109_EGU_INSTANCE
21  #define DMA_ISSUE_EGU               NRFX_CONCAT_2(NRF_EGU, DMA_ISSUE_EGU_IDX)
22  #define DMA_ISSUE_EGU_IRQn          EGU_IRQn(DMA_ISSUE_EGU_IDX)
23  #define DMA_ISSUE_EGU_IRQHandler    EGU_IRQHandler(DMA_ISSUE_EGU_IDX)
24  #endif
25  typedef struct
26  {
27  #if defined(USE_DMA_ISSUE_WORKAROUND)
28      uint32_t                  starting_task_address;
29  #endif
30      nrfx_pwm_handler_t        handler;
31      void *                    p_context;
32      nrfx_drv_state_t volatile state;
33      uint8_t                   flags;
34  } pwm_control_block_t;
35  static pwm_control_block_t m_cb[NRFX_PWM_ENABLED_COUNT];
36  static void configure_pins(nrfx_pwm_t const *        p_instance,
37                             nrfx_pwm_config_t const * p_config)
38  {
39      uint32_t out_pins[NRF_PWM_CHANNEL_COUNT];
40      uint8_t i;
41      for (i = 0; i < NRF_PWM_CHANNEL_COUNT; ++i)
42      {
43          uint8_t output_pin = p_config->output_pins[i];
44          if (output_pin != NRFX_PWM_PIN_NOT_USED)
45          {
46              bool inverted = output_pin &  NRFX_PWM_PIN_INVERTED;
47              out_pins[i]   = output_pin & ~NRFX_PWM_PIN_INVERTED;
48              if (!p_config->skip_gpio_cfg)
49              {
50                  if (inverted)
51                  {
52                      nrf_gpio_pin_set(out_pins[i]);
53                  }
54                  else
55                  {
56                      nrf_gpio_pin_clear(out_pins[i]);
57                  }
58                  nrf_gpio_cfg_output(out_pins[i]);
59              }
60          }
61          else
62          {
63              out_pins[i] = NRF_PWM_PIN_NOT_CONNECTED;
64          }
65      }
66      nrf_pwm_pins_set(p_instance->p_registers, out_pins);
67  }
68  nrfx_err_t nrfx_pwm_init(nrfx_pwm_t const *        p_instance,
69                           nrfx_pwm_config_t const * p_config,
70                           nrfx_pwm_handler_t        handler,
71                           void *                    p_context)
72  {
73      NRFX_ASSERT(p_config);
74      nrfx_err_t err_code;
75      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
76      if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
77      {
78          err_code = NRFX_ERROR_INVALID_STATE;
79          NRFX_LOG_WARNING("Function: %s, error code: %s.",
80                           __func__,
81                           NRFX_LOG_ERROR_STRING_GET(err_code));
82          return err_code;
83      }
84      p_cb->handler = handler;
85      p_cb->p_context = p_context;
86      configure_pins(p_instance, p_config);
87      nrf_pwm_enable(p_instance->p_registers);
88      nrf_pwm_configure(p_instance->p_registers,
89          p_config->base_clock, p_config->count_mode, p_config->top_value);
90      nrf_pwm_decoder_set(p_instance->p_registers,
91          p_config->load_mode, p_config->step_mode);
92      nrf_pwm_shorts_set(p_instance->p_registers, 0);
93      nrf_pwm_int_set(p_instance->p_registers, 0);
94      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_LOOPSDONE);
95      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND0);
96      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND1);
97      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
98  #if defined(USE_DMA_ISSUE_WORKAROUND)
99      NRFX_IRQ_PRIORITY_SET(DMA_ISSUE_EGU_IRQn, p_config->irq_priority);
100      NRFX_IRQ_ENABLE(DMA_ISSUE_EGU_IRQn);
101  #else
102      if (p_cb->handler)
103  #endif
104      {
105          NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_registers),
106              p_config->irq_priority);
107          NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_registers));
108      }
109      p_cb->state = NRFX_DRV_STATE_INITIALIZED;
110      err_code = NRFX_SUCCESS;
111      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
112      return err_code;
113  }
114  void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance)
115  {
116      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
117      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
118      NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_registers));
119  #if defined(USE_DMA_ISSUE_WORKAROUND)
120      NRFX_IRQ_DISABLE(DMA_ISSUE_EGU_IRQn);
121  #endif
122      nrf_pwm_disable(p_instance->p_registers);
123      p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
124  }
125  static uint32_t start_playback(nrfx_pwm_t const * p_instance,
126                                 pwm_control_block_t * p_cb,
127                                 uint8_t               flags,
128                                 nrf_pwm_task_t        starting_task)
129  {
130      p_cb->state = NRFX_DRV_STATE_POWERED_ON;
131      p_cb->flags = flags;
132      if (p_cb->handler)
133      {
134          uint32_t int_mask = NRF_PWM_INT_LOOPSDONE_MASK |
135                              NRF_PWM_INT_STOPPED_MASK;
136  #if defined(USE_DMA_ISSUE_WORKAROUND)
137          int_mask |= NRF_PWM_INT_SEQEND0_MASK | NRF_PWM_INT_SEQEND1_MASK;
138  #else
139          if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ0)
140          {
141              int_mask |= NRF_PWM_INT_SEQEND0_MASK;
142          }
143          if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ1)
144          {
145              int_mask |= NRF_PWM_INT_SEQEND1_MASK;
146          }
147  #endif
148          if (flags & NRFX_PWM_FLAG_NO_EVT_FINISHED)
149          {
150              int_mask &= ~NRF_PWM_INT_LOOPSDONE_MASK;
151          }
152          nrf_pwm_int_set(p_instance->p_registers, int_mask);
153      }
154  #if defined(USE_DMA_ISSUE_WORKAROUND)
155      else
156      {
157          nrf_pwm_int_set(p_instance->p_registers,
158              NRF_PWM_INT_SEQEND0_MASK | NRF_PWM_INT_SEQEND1_MASK);
159      }
160  #endif
161      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
162      if (flags & NRFX_PWM_FLAG_START_VIA_TASK)
163      {
164          uint32_t starting_task_address =
165              nrf_pwm_task_address_get(p_instance->p_registers, starting_task);
166  #if defined(USE_DMA_ISSUE_WORKAROUND)
167          p_cb->starting_task_address = starting_task_address;
168          nrf_egu_int_enable(DMA_ISSUE_EGU, nrf_egu_channel_int_get(p_instance->drv_inst_idx));
169          return nrf_egu_task_address_get(DMA_ISSUE_EGU,
170                                          nrf_egu_trigger_task_get(p_instance->drv_inst_idx));
171  #else
172          return starting_task_address;
173  #endif
174      }
175      nrf_pwm_task_trigger(p_instance->p_registers, starting_task);
176      return 0;
177  }
178  uint32_t nrfx_pwm_simple_playback(nrfx_pwm_t const *         p_instance,
179                                    nrf_pwm_sequence_t const * p_sequence,
180                                    uint16_t                   playback_count,
181                                    uint32_t                   flags)
182  {
183      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
184      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
185      NRFX_ASSERT(playback_count > 0);
186      NRFX_ASSERT(nrfx_is_in_ram(p_sequence->values.p_raw));
187      nrf_pwm_sequence_set(p_instance->p_registers, 0, p_sequence);
188      nrf_pwm_sequence_set(p_instance->p_registers, 1, p_sequence);
189      bool odd = (playback_count & 1);
190      nrf_pwm_loop_set(p_instance->p_registers,
191          (playback_count / 2) + (odd ? 1 : 0));
192      uint32_t shorts_mask;
193      if (flags & NRFX_PWM_FLAG_STOP)
194      {
195          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
196      }
197      else if (flags & NRFX_PWM_FLAG_LOOP)
198      {
199          shorts_mask = odd ? NRF_PWM_SHORT_LOOPSDONE_SEQSTART1_MASK
200                            : NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
201      }
202      else
203      {
204          shorts_mask = 0;
205      }
206      nrf_pwm_shorts_set(p_instance->p_registers, shorts_mask);
207      NRFX_LOG_INFO("Function: %s, sequence length: %d.",
208                    __func__,
209                    p_sequence->length);
210      NRFX_LOG_DEBUG("Sequence data:");
211      NRFX_LOG_HEXDUMP_DEBUG((uint8_t *)p_sequence->values.p_raw,
212                             p_sequence->length * sizeof(uint16_t));
213      return start_playback(p_instance, p_cb, flags,
214          odd ? NRF_PWM_TASK_SEQSTART1 : NRF_PWM_TASK_SEQSTART0);
215  }
216  uint32_t nrfx_pwm_complex_playback(nrfx_pwm_t const *         p_instance,
217                                     nrf_pwm_sequence_t const * p_sequence_0,
218                                     nrf_pwm_sequence_t const * p_sequence_1,
219                                     uint16_t                   playback_count,
220                                     uint32_t                   flags)
221  {
222      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
223      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
224      NRFX_ASSERT(playback_count > 0);
225      NRFX_ASSERT(nrfx_is_in_ram(p_sequence_0->values.p_raw));
226      NRFX_ASSERT(nrfx_is_in_ram(p_sequence_1->values.p_raw));
227      nrf_pwm_sequence_set(p_instance->p_registers, 0, p_sequence_0);
228      nrf_pwm_sequence_set(p_instance->p_registers, 1, p_sequence_1);
229      nrf_pwm_loop_set(p_instance->p_registers, playback_count);
230      uint32_t shorts_mask;
<span onclick='openModal()' class='match'>231      if (flags & NRFX_PWM_FLAG_STOP)
232      {
233          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
234      }
235      else if (flags & NRFX_PWM_FLAG_LOOP)
236      {
237          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
</span>238      }
239      else
240      {
241          shorts_mask = 0;
242      }
243      nrf_pwm_shorts_set(p_instance->p_registers, shorts_mask);
244      NRFX_LOG_INFO("Function: %s, sequence 0 length: %d.",
245                    __func__,
246                    p_sequence_0->length);
247      NRFX_LOG_INFO("Function: %s, sequence 1 length: %d.",
248                    __func__,
249                    p_sequence_1->length);
250      NRFX_LOG_DEBUG("Sequence 0 data:");
251      NRFX_LOG_HEXDUMP_DEBUG(p_sequence_0->values.p_raw,
252                             p_sequence_0->length * sizeof(uint16_t));
253      NRFX_LOG_DEBUG("Sequence 1 data:");
254      NRFX_LOG_HEXDUMP_DEBUG(p_sequence_1->values.p_raw,
255                             p_sequence_1->length * sizeof(uint16_t));
256      return start_playback(p_instance, p_cb, flags, NRF_PWM_TASK_SEQSTART0);
257  }
258  bool nrfx_pwm_stop(nrfx_pwm_t const * p_instance,
259                     bool               wait_until_stopped)
260  {
261      NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state != NRFX_DRV_STATE_UNINITIALIZED);
262      bool ret_val = false;
263      nrf_pwm_shorts_set(p_instance->p_registers, 0);
264      nrf_pwm_task_trigger(p_instance->p_registers, NRF_PWM_TASK_STOP);
265      if (nrfx_pwm_is_stopped(p_instance))
266      {
267          ret_val = true;
268      }
269      else
270      {
271          do {
272              if (nrfx_pwm_is_stopped(p_instance))
273              {
274                  ret_val = true;
275                  break;
276              }
277          } while (wait_until_stopped);
278      }
279      NRFX_LOG_INFO("%s returned %d.", __func__, ret_val);
280      return ret_val;
281  }
282  bool nrfx_pwm_is_stopped(nrfx_pwm_t const * p_instance)
283  {
284      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
285      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
286      bool ret_val = false;
287      if (p_cb->state != NRFX_DRV_STATE_POWERED_ON)
288      {
289          ret_val = true;
290      }
291      if (nrf_pwm_event_check(p_instance->p_registers, NRF_PWM_EVENT_STOPPED))
292      {
293          p_cb->state = NRFX_DRV_STATE_INITIALIZED;
294          NRFX_LOG_INFO("Disabled.");
295          ret_val = true;
296      }
297      NRFX_LOG_INFO("%s returned %d.", __func__, ret_val);
298      return ret_val;
299  }
300  static void irq_handler(NRF_PWM_Type * p_pwm, pwm_control_block_t * p_cb)
301  {
302      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_SEQEND0))
303      {
304          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_SEQEND0);
305          if ((p_cb->flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ0) && p_cb->handler)
306          {
307              p_cb->handler(NRFX_PWM_EVT_END_SEQ0, p_cb->p_context);
308          }
309      }
310      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_SEQEND1))
311      {
312          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_SEQEND1);
313          if ((p_cb->flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ1) && p_cb->handler)
314          {
315              p_cb->handler(NRFX_PWM_EVT_END_SEQ1, p_cb->p_context);
316          }
317      }
318      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_LOOPSDONE))
319      {
320          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_LOOPSDONE);
321          if (!(p_cb->flags & NRFX_PWM_FLAG_NO_EVT_FINISHED) && p_cb->handler)
322          {
323              p_cb->handler(NRFX_PWM_EVT_FINISHED, p_cb->p_context);
324          }
325      }
326      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_STOPPED))
327      {
328          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_STOPPED);
329          p_cb->state = NRFX_DRV_STATE_INITIALIZED;
330          if (p_cb->handler)
331          {
332              p_cb->handler(NRFX_PWM_EVT_STOPPED, p_cb->p_context);
333          }
334      }
335  }
336  #if defined(USE_DMA_ISSUE_WORKAROUND)
337  void DMA_ISSUE_EGU_IRQHandler(void)
338  {
339      for (uint8_t i = 0; i < NRFX_PWM_ENABLED_COUNT; i++)
340      {
341          nrf_egu_event_t event = nrf_egu_triggered_event_get(i);
342          if (nrf_egu_event_check(DMA_ISSUE_EGU, event))
343          {
344              nrf_egu_event_clear(DMA_ISSUE_EGU, event);
345              *(volatile uint32_t *)(m_cb[i].starting_task_address) = 1;
346          }
347      }
348  }
349  #endif
350  #if NRFX_CHECK(NRFX_PWM0_ENABLED)
351  void nrfx_pwm_0_irq_handler(void)
352  {
353      irq_handler(NRF_PWM0, &m_cb[NRFX_PWM0_INST_IDX]);
354  }
355  #endif
356  #if NRFX_CHECK(NRFX_PWM1_ENABLED)
357  void nrfx_pwm_1_irq_handler(void)
358  {
359      irq_handler(NRF_PWM1, &m_cb[NRFX_PWM1_INST_IDX]);
360  }
361  #endif
362  #if NRFX_CHECK(NRFX_PWM2_ENABLED)
363  void nrfx_pwm_2_irq_handler(void)
364  {
365      irq_handler(NRF_PWM2, &m_cb[NRFX_PWM2_INST_IDX]);
366  }
367  #endif
368  #if NRFX_CHECK(NRFX_PWM3_ENABLED)
369  void nrfx_pwm_3_irq_handler(void)
370  {
371      irq_handler(NRF_PWM3, &m_cb[NRFX_PWM3_INST_IDX]);
372  }
373  #endif
374  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-printf.h</h3>
            <pre><code>1  #ifndef FMT_PRINTF_H_
2  #define FMT_PRINTF_H_
3  #include <algorithm>  
4  #include <limits>     
5  #include "ostream.h"
6  FMT_BEGIN_NAMESPACE
7  namespace detail {
8  template <bool IsSigned> struct int_checker {
9    template <typename T> static bool fits_in_int(T value) {
10      unsigned max = max_value<int>();
11      return value <= max;
12    }
13    static bool fits_in_int(bool) { return true; }
14  };
15  template <> struct int_checker<true> {
16    template <typename T> static bool fits_in_int(T value) {
17      return value >= (std::numeric_limits<int>::min)() &&
18             value <= max_value<int>();
19    }
20    static bool fits_in_int(int) { return true; }
21  };
22  class printf_precision_handler {
23   public:
24    template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
25    int operator()(T value) {
26      if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
27        FMT_THROW(format_error("number is too big"));
28      return (std::max)(static_cast<int>(value), 0);
29    }
30    template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
31    int operator()(T) {
32      FMT_THROW(format_error("precision is not integer"));
33      return 0;
34    }
35  };
36  class is_zero_int {
37   public:
38    template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
39    bool operator()(T value) {
40      return value == 0;
41    }
42    template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
43    bool operator()(T) {
44      return false;
45    }
46  };
47  template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};
48  template <> struct make_unsigned_or_bool<bool> { using type = bool; };
49  template <typename T, typename Context> class arg_converter {
50   private:
51    using char_type = typename Context::char_type;
52    basic_format_arg<Context>& arg_;
53    char_type type_;
54   public:
55    arg_converter(basic_format_arg<Context>& arg, char_type type)
56        : arg_(arg), type_(type) {}
57    void operator()(bool value) {
58      if (type_ != 's') operator()<bool>(value);
59    }
60    template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
61    void operator()(U value) {
62      bool is_signed = type_ == 'd' || type_ == 'i';
63      using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
64      if (const_check(sizeof(target_type) <= sizeof(int))) {
65        if (is_signed) {
66          arg_ = detail::make_arg<Context>(
67              static_cast<int>(static_cast<target_type>(value)));
68        } else {
69          using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
70          arg_ = detail::make_arg<Context>(
71              static_cast<unsigned>(static_cast<unsigned_type>(value)));
72        }
73      } else {
74        if (is_signed) {
75          arg_ = detail::make_arg<Context>(static_cast<long long>(value));
76        } else {
77          arg_ = detail::make_arg<Context>(
78              static_cast<typename make_unsigned_or_bool<U>::type>(value));
79        }
80      }
81    }
82    template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
83    void operator()(U) {}  
84  };
85  template <typename T, typename Context, typename Char>
86  void convert_arg(basic_format_arg<Context>& arg, Char type) {
87    visit_format_arg(arg_converter<T, Context>(arg, type), arg);
88  }
89  template <typename Context> class char_converter {
90   private:
91    basic_format_arg<Context>& arg_;
92   public:
93    explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}
94    template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
95    void operator()(T value) {
96      arg_ = detail::make_arg<Context>(
97          static_cast<typename Context::char_type>(value));
98    }
99    template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
100    void operator()(T) {}  
101  };
102  template <typename Char> struct get_cstring {
103    template <typename T> const Char* operator()(T) { return nullptr; }
104    const Char* operator()(const Char* s) { return s; }
105  };
106  template <typename Char> class printf_width_handler {
107   private:
108    using format_specs = basic_format_specs<Char>;
109    format_specs& specs_;
110   public:
111    explicit printf_width_handler(format_specs& specs) : specs_(specs) {}
112    template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
113    unsigned operator()(T value) {
114      auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
115      if (detail::is_negative(value)) {
116        specs_.align = align::left;
117        width = 0 - width;
118      }
119      unsigned int_max = max_value<int>();
120      if (width > int_max) FMT_THROW(format_error("number is too big"));
121      return static_cast<unsigned>(width);
122    }
123    template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
124    unsigned operator()(T) {
125      FMT_THROW(format_error("width is not integer"));
126      return 0;
127    }
128  };
129  template <typename Char, typename Context>
130  void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
131               basic_format_args<Context> args) {
132    Context(buffer_appender<Char>(buf), format, args).format();
133  }
134  }  
135  template <typename Char, typename Context>
136  FMT_DEPRECATED void printf(detail::buffer<Char>& buf,
137                             basic_string_view<Char> format,
138                             basic_format_args<Context> args) {
139    return detail::vprintf(buf, format, args);
140  }
141  using detail::vprintf;
142  template <typename Char>
143  class basic_printf_parse_context : public basic_format_parse_context<Char> {
144    using basic_format_parse_context<Char>::basic_format_parse_context;
145  };
146  template <typename OutputIt, typename Char> class basic_printf_context;
147  template <typename OutputIt, typename Char>
148  class printf_arg_formatter : public detail::arg_formatter_base<OutputIt, Char> {
149   public:
150    using iterator = OutputIt;
151   private:
152    using char_type = Char;
153    using base = detail::arg_formatter_base<OutputIt, Char>;
154    using context_type = basic_printf_context<OutputIt, Char>;
155    context_type& context_;
156    void write_null_pointer(char) {
157      this->specs()->type = 0;
158      this->write("(nil)");
159    }
160    void write_null_pointer(wchar_t) {
161      this->specs()->type = 0;
162      this->write(L"(nil)");
163    }
164   public:
165    using format_specs = typename base::format_specs;
166    printf_arg_formatter(iterator iter, format_specs& specs, context_type& ctx)
167        : base(iter, &specs, detail::locale_ref()), context_(ctx) {}
168    template <typename T, FMT_ENABLE_IF(fmt::detail::is_integral<T>::value)>
169    iterator operator()(T value) {
170      if (std::is_same<T, bool>::value) {
171        format_specs& fmt_specs = *this->specs();
172        if (fmt_specs.type != 's') return base::operator()(value ? 1 : 0);
173        fmt_specs.type = 0;
174        this->write(value != 0);
175      } else if (std::is_same<T, char_type>::value) {
176        format_specs& fmt_specs = *this->specs();
177        if (fmt_specs.type && fmt_specs.type != 'c')
178          return (*this)(static_cast<int>(value));
179        fmt_specs.sign = sign::none;
180        fmt_specs.alt = false;
181        fmt_specs.fill[0] = ' ';  
182        if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
183          fmt_specs.align = align::right;
184        return base::operator()(value);
185      } else {
186        return base::operator()(value);
187      }
188      return this->out();
189    }
190    template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
191    iterator operator()(T value) {
192      return base::operator()(value);
193    }
194    iterator operator()(const char* value) {
195      if (value)
196        base::operator()(value);
197      else if (this->specs()->type == 'p')
198        write_null_pointer(char_type());
199      else
200        this->write("(null)");
201      return this->out();
202    }
203    iterator operator()(const wchar_t* value) {
204      if (value)
205        base::operator()(value);
206      else if (this->specs()->type == 'p')
207        write_null_pointer(char_type());
208      else
209        this->write(L"(null)");
210      return this->out();
211    }
212    iterator operator()(basic_string_view<char_type> value) {
213      return base::operator()(value);
214    }
215    iterator operator()(monostate value) { return base::operator()(value); }
216    iterator operator()(const void* value) {
217      if (value) return base::operator()(value);
218      this->specs()->type = 0;
219      write_null_pointer(char_type());
220      return this->out();
221    }
222    iterator operator()(typename basic_format_arg<context_type>::handle handle) {
223      handle.format(context_.parse_context(), context_);
224      return this->out();
225    }
226  };
227  template <typename T> struct printf_formatter {
228    printf_formatter() = delete;
229    template <typename ParseContext>
230    auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
231      return ctx.begin();
232    }
233    template <typename FormatContext>
234    auto format(const T& value, FormatContext& ctx) -> decltype(ctx.out()) {
235      detail::format_value(detail::get_container(ctx.out()), value);
236      return ctx.out();
237    }
238  };
239  template <typename OutputIt, typename Char> class basic_printf_context {
240   public:
241    using char_type = Char;
242    using iterator = OutputIt;
243    using format_arg = basic_format_arg<basic_printf_context>;
244    using parse_context_type = basic_printf_parse_context<Char>;
245    template <typename T> using formatter_type = printf_formatter<T>;
246   private:
247    using format_specs = basic_format_specs<char_type>;
248    OutputIt out_;
249    basic_format_args<basic_printf_context> args_;
250    parse_context_type parse_ctx_;
251    static void parse_flags(format_specs& specs, const Char*& it,
252                            const Char* end);
253    format_arg get_arg(int arg_index = -1);
254    int parse_header(const Char*& it, const Char* end, format_specs& specs);
255   public:
256    basic_printf_context(OutputIt out, basic_string_view<char_type> format_str,
257                         basic_format_args<basic_printf_context> args)
258        : out_(out), args_(args), parse_ctx_(format_str) {}
259    OutputIt out() { return out_; }
260    void advance_to(OutputIt it) { out_ = it; }
261    detail::locale_ref locale() { return {}; }
262    format_arg arg(int id) const { return args_.get(id); }
263    parse_context_type& parse_context() { return parse_ctx_; }
264    FMT_CONSTEXPR void on_error(const char* message) {
265      parse_ctx_.on_error(message);
266    }
267    template <typename ArgFormatter = printf_arg_formatter<OutputIt, Char>>
268    OutputIt format();
269  };
270  template <typename OutputIt, typename Char>
271  void basic_printf_context<OutputIt, Char>::parse_flags(format_specs& specs,
272                                                         const Char*& it,
273                                                         const Char* end) {
274    for (; it != end; ++it) {
275      switch (*it) {
276      case '-':
277        specs.align = align::left;
278        break;
279      case '+':
280        specs.sign = sign::plus;
281        break;
282      case '0':
283        specs.fill[0] = '0';
284        break;
285      case ' ':
286        if (specs.sign != sign::plus) {
287          specs.sign = sign::space;
288        }
289        break;
290      case '#':
291        specs.alt = true;
292        break;
293      default:
294        return;
295      }
296    }
297  }
298  template <typename OutputIt, typename Char>
299  typename basic_printf_context<OutputIt, Char>::format_arg
300  basic_printf_context<OutputIt, Char>::get_arg(int arg_index) {
301    if (arg_index < 0)
302      arg_index = parse_ctx_.next_arg_id();
303    else
304      parse_ctx_.check_arg_id(--arg_index);
305    return detail::get_arg(*this, arg_index);
306  }
307  template <typename OutputIt, typename Char>
308  int basic_printf_context<OutputIt, Char>::parse_header(const Char*& it,
309                                                         const Char* end,
310                                                         format_specs& specs) {
311    int arg_index = -1;
312    char_type c = *it;
313    if (c >= '0' && c <= '9') {
314      detail::error_handler eh;
315      int value = parse_nonnegative_int(it, end, eh);
316      if (it != end && *it == '$') {  
317        ++it;
318        arg_index = value;
319      } else {
320        if (c == '0') specs.fill[0] = '0';
321        if (value != 0) {
322          specs.width = value;
323          return arg_index;
324        }
325      }
326    }
327    parse_flags(specs, it, end);
328    if (it != end) {
<span onclick='openModal()' class='match'>329      if (*it >= '0' && *it <= '9') {
330        detail::error_handler eh;
331        specs.width = parse_nonnegative_int(it, end, eh);
332      } else if (*it == '*') {
333        ++it;
</span>334        specs.width = static_cast<int>(visit_format_arg(
335            detail::printf_width_handler<char_type>(specs), get_arg()));
336      }
337    }
338    return arg_index;
339  }
340  template <typename OutputIt, typename Char>
341  template <typename ArgFormatter>
342  OutputIt basic_printf_context<OutputIt, Char>::format() {
343    auto out = this->out();
344    const Char* start = parse_ctx_.begin();
345    const Char* end = parse_ctx_.end();
346    auto it = start;
347    while (it != end) {
348      char_type c = *it++;
349      if (c != '%') continue;
350      if (it != end && *it == c) {
351        out = std::copy(start, it, out);
352        start = ++it;
353        continue;
354      }
355      out = std::copy(start, it - 1, out);
356      format_specs specs;
357      specs.align = align::right;
358      int arg_index = parse_header(it, end, specs);
359      if (arg_index == 0) on_error("argument not found");
360      if (it != end && *it == '.') {
361        ++it;
362        c = it != end ? *it : 0;
363        if ('0' <= c && c <= '9') {
364          detail::error_handler eh;
365          specs.precision = parse_nonnegative_int(it, end, eh);
366        } else if (c == '*') {
367          ++it;
368          specs.precision = static_cast<int>(
369              visit_format_arg(detail::printf_precision_handler(), get_arg()));
370        } else {
371          specs.precision = 0;
372        }
373      }
374      format_arg arg = get_arg(arg_index);
375      if (specs.precision >= 0 && arg.is_integral())
376        specs.fill[0] =
377            ' ';  
378      if (specs.precision >= 0 && arg.type() == detail::type::cstring_type) {
379        auto str = visit_format_arg(detail::get_cstring<Char>(), arg);
380        auto str_end = str + specs.precision;
381        auto nul = std::find(str, str_end, Char());
382        arg = detail::make_arg<basic_printf_context>(basic_string_view<Char>(
383            str,
384            detail::to_unsigned(nul != str_end ? nul - str : specs.precision)));
385      }
386      if (specs.alt && visit_format_arg(detail::is_zero_int(), arg))
387        specs.alt = false;
388      if (specs.fill[0] == '0') {
389        if (arg.is_arithmetic() && specs.align != align::left)
390          specs.align = align::numeric;
391        else
392          specs.fill[0] = ' ';  
393      }
394      c = it != end ? *it++ : 0;
395      char_type t = it != end ? *it : 0;
396      using detail::convert_arg;
397      switch (c) {
398      case 'h':
399        if (t == 'h') {
400          ++it;
401          t = it != end ? *it : 0;
402          convert_arg<signed char>(arg, t);
403        } else {
404          convert_arg<short>(arg, t);
405        }
406        break;
407      case 'l':
408        if (t == 'l') {
409          ++it;
410          t = it != end ? *it : 0;
411          convert_arg<long long>(arg, t);
412        } else {
413          convert_arg<long>(arg, t);
414        }
415        break;
416      case 'j':
417        convert_arg<intmax_t>(arg, t);
418        break;
419      case 'z':
420        convert_arg<size_t>(arg, t);
421        break;
422      case 't':
423        convert_arg<std::ptrdiff_t>(arg, t);
424        break;
425      case 'L':
426        break;
427      default:
428        --it;
429        convert_arg<void>(arg, c);
430      }
431      if (it == end) FMT_THROW(format_error("invalid format string"));
432      specs.type = static_cast<char>(*it++);
433      if (arg.is_integral()) {
434        switch (specs.type) {
435        case 'i':
436        case 'u':
437          specs.type = 'd';
438          break;
439        case 'c':
440          visit_format_arg(detail::char_converter<basic_printf_context>(arg),
441                           arg);
442          break;
443        }
444      }
445      start = it;
446      out = visit_format_arg(ArgFormatter(out, specs, *this), arg);
447    }
448    return std::copy(start, it, out);
449  }
450  template <typename Char>
451  using basic_printf_context_t =
452      basic_printf_context<detail::buffer_appender<Char>, Char>;
453  using printf_context = basic_printf_context_t<char>;
454  using wprintf_context = basic_printf_context_t<wchar_t>;
455  using printf_args = basic_format_args<printf_context>;
456  using wprintf_args = basic_format_args<wprintf_context>;
457  template <typename... Args>
458  inline format_arg_store<printf_context, Args...> make_printf_args(
459      const Args&... args) {
460    return {args...};
461  }
462  template <typename... Args>
463  inline format_arg_store<wprintf_context, Args...> make_wprintf_args(
464      const Args&... args) {
465    return {args...};
466  }
467  template <typename S, typename Char = char_t<S>>
468  inline std::basic_string<Char> vsprintf(
469      const S& format,
470      basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args) {
471    basic_memory_buffer<Char> buffer;
472    vprintf(buffer, to_string_view(format), args);
473    return to_string(buffer);
474  }
475  template <typename S, typename... Args,
476            typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
477  inline std::basic_string<Char> sprintf(const S& format, const Args&... args) {
478    using context = basic_printf_context_t<Char>;
479    return vsprintf(to_string_view(format), make_format_args<context>(args...));
480  }
481  template <typename S, typename Char = char_t<S>>
482  inline int vfprintf(
483      std::FILE* f, const S& format,
484      basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args) {
485    basic_memory_buffer<Char> buffer;
486    vprintf(buffer, to_string_view(format), args);
487    size_t size = buffer.size();
488    return std::fwrite(buffer.data(), sizeof(Char), size, f) < size
489               ? -1
490               : static_cast<int>(size);
491  }
492  template <typename S, typename... Args,
493            typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
494  inline int fprintf(std::FILE* f, const S& format, const Args&... args) {
495    using context = basic_printf_context_t<Char>;
496    return vfprintf(f, to_string_view(format),
497                    make_format_args<context>(args...));
498  }
499  template <typename S, typename Char = char_t<S>>
500  inline int vprintf(
501      const S& format,
502      basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args) {
503    return vfprintf(stdout, to_string_view(format), args);
504  }
505  template <typename S, typename... Args,
506            FMT_ENABLE_IF(detail::is_string<S>::value)>
507  inline int printf(const S& format_str, const Args&... args) {
508    using context = basic_printf_context_t<char_t<S>>;
509    return vprintf(to_string_view(format_str),
510                   make_format_args<context>(args...));
511  }
512  template <typename S, typename Char = char_t<S>>
513  inline int vfprintf(
514      std::basic_ostream<Char>& os, const S& format,
515      basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args) {
516    basic_memory_buffer<Char> buffer;
517    vprintf(buffer, to_string_view(format), args);
518    detail::write_buffer(os, buffer);
519    return static_cast<int>(buffer.size());
520  }
521  template <typename ArgFormatter, typename Char,
522            typename Context =
523                basic_printf_context<typename ArgFormatter::iterator, Char>>
524  typename ArgFormatter::iterator vprintf(
525      detail::buffer<Char>& out, basic_string_view<Char> format_str,
526      basic_format_args<type_identity_t<Context>> args) {
527    typename ArgFormatter::iterator iter(out);
528    Context(iter, format_str, args).template format<ArgFormatter>();
529    return iter;
530  }
531  template <typename S, typename... Args, typename Char = char_t<S>>
532  inline int fprintf(std::basic_ostream<Char>& os, const S& format_str,
533                     const Args&... args) {
534    using context = basic_printf_context_t<Char>;
535    return vfprintf(os, to_string_view(format_str),
536                    make_format_args<context>(args...));
537  }
538  FMT_END_NAMESPACE
539  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-printf.h</div>
                </div>
                <div class="column column_space"><pre><code>231      if (flags & NRFX_PWM_FLAG_STOP)
232      {
233          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
234      }
235      else if (flags & NRFX_PWM_FLAG_LOOP)
236      {
237          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
</pre></code></div>
                <div class="column column_space"><pre><code>329      if (*it >= '0' && *it <= '9') {
330        detail::error_handler eh;
331        specs.width = parse_nonnegative_int(it, end, eh);
332      } else if (*it == '*') {
333        ++it;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    