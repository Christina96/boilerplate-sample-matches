
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.03954802259887%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mutex_pool.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_MUTEX_POOL_H
2  #define JEMALLOC_INTERNAL_MUTEX_POOL_H
3  #include "jemalloc/internal/hash.h"
4  #include "jemalloc/internal/mutex.h"
5  #include "jemalloc/internal/witness.h"
6  #define MUTEX_POOL_SIZE 256
7  typedef struct mutex_pool_s mutex_pool_t;
8  struct mutex_pool_s {
9  	malloc_mutex_t mutexes[MUTEX_POOL_SIZE];
10  };
11  bool mutex_pool_init(mutex_pool_t *pool, const char *name, witness_rank_t rank);
12  static inline malloc_mutex_t *
13  mutex_pool_mutex(mutex_pool_t *pool, uintptr_t key) {
14  	size_t hash_result[2];
15  	hash(&key, sizeof(key), 0xd50dcc1b, hash_result);
16  	return &pool->mutexes[hash_result[0] % MUTEX_POOL_SIZE];
17  }
18  static inline void
19  mutex_pool_assert_not_held(tsdn_t *tsdn, mutex_pool_t *pool) {
20  	for (int i = 0; i < MUTEX_POOL_SIZE; i++) {
21  		malloc_mutex_assert_not_owner(tsdn, &pool->mutexes[i]);
22  	}
23  }
24  static inline void
25  mutex_pool_lock(tsdn_t *tsdn, mutex_pool_t *pool, uintptr_t key) {
26  	mutex_pool_assert_not_held(tsdn, pool);
27  	malloc_mutex_t *mutex = mutex_pool_mutex(pool, key);
28  	malloc_mutex_lock(tsdn, mutex);
29  }
30  static inline void
31  mutex_pool_unlock(tsdn_t *tsdn, mutex_pool_t *pool, uintptr_t key) {
32  	malloc_mutex_t *mutex = mutex_pool_mutex(pool, key);
33  	malloc_mutex_unlock(tsdn, mutex);
34  	mutex_pool_assert_not_held(tsdn, pool);
35  }
36  static inline void
37  mutex_pool_lock2(tsdn_t *tsdn, mutex_pool_t *pool, uintptr_t key1,
38      uintptr_t key2) {
39  	mutex_pool_assert_not_held(tsdn, pool);
40  	malloc_mutex_t *mutex1 = mutex_pool_mutex(pool, key1);
41  	malloc_mutex_t *mutex2 = mutex_pool_mutex(pool, key2);
<span onclick='openModal()' class='match'>42  	if ((uintptr_t)mutex1 < (uintptr_t)mutex2) {
43  		malloc_mutex_lock(tsdn, mutex1);
44  		malloc_mutex_lock(tsdn, mutex2);
45  	} else if ((uintptr_t)mutex1 == (uintptr_t)mutex2) {
46  		malloc_mutex_lock(tsdn, mutex1);
47  	} else {
</span>48  		malloc_mutex_lock(tsdn, mutex2);
49  		malloc_mutex_lock(tsdn, mutex1);
50  	}
51  }
52  static inline void
53  mutex_pool_unlock2(tsdn_t *tsdn, mutex_pool_t *pool, uintptr_t key1,
54      uintptr_t key2) {
55  	malloc_mutex_t *mutex1 = mutex_pool_mutex(pool, key1);
56  	malloc_mutex_t *mutex2 = mutex_pool_mutex(pool, key2);
57  	if (mutex1 == mutex2) {
58  		malloc_mutex_unlock(tsdn, mutex1);
59  	} else {
60  		malloc_mutex_unlock(tsdn, mutex1);
61  		malloc_mutex_unlock(tsdn, mutex2);
62  	}
63  	mutex_pool_assert_not_held(tsdn, pool);
64  }
65  static inline void
66  mutex_pool_assert_owner(tsdn_t *tsdn, mutex_pool_t *pool, uintptr_t key) {
67  	malloc_mutex_assert_owner(tsdn, mutex_pool_mutex(pool, key));
68  }
69  #endif &bsol;* JEMALLOC_INTERNAL_MUTEX_POOL_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-slowlog.c</h3>
            <pre><code>1  #include "server.h"
2  #include "slowlog.h"
3  slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, PORT_LONGLONG duration) {
4      slowlogEntry *se = zmalloc(sizeof(*se));
5      int j, slargc = argc;
6      if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
7      se->argc = slargc;
8      se->argv = zmalloc(sizeof(robj*)*slargc);
9      for (j = 0; j < slargc; j++) {
10          if (slargc != argc && j == slargc-1) {
11              se->argv[j] = createObject(OBJ_STRING,
12                  sdscatprintf(sdsempty(),"... (%d more arguments)",
13                  argc-slargc+1));
14          } else {
15              if (argv[j]->type == OBJ_STRING &&
16                  sdsEncodedObject(argv[j]) &&
17                  sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
18              {
19                  sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);
20                  s = sdscatprintf(s,"... (%Iu more bytes)",                      WIN_PORT_FIX &bsol;* %lu -> %Iu */
21                      (PORT_ULONG)
22                      sdslen(argv[j]->ptr) - SLOWLOG_ENTRY_MAX_STRING);
23                  se->argv[j] = createObject(OBJ_STRING,s);
24              } else if (argv[j]->refcount == OBJ_SHARED_REFCOUNT) {
25                  se->argv[j] = argv[j];
26              } else {
27                  se->argv[j] = dupStringObject(argv[j]);
28              }
29          }
30      }
31      se->time = time(NULL);
32      se->duration = duration;
33      se->id = server.slowlog_entry_id++;
34      se->peerid = sdsnew(getClientPeerId(c));
35      se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();
36      return se;
37  }
38  void slowlogFreeEntry(void *septr) {
39      slowlogEntry *se = septr;
40      int j;
41      for (j = 0; j < se->argc; j++)
42          decrRefCount(se->argv[j]);
43      zfree(se->argv);
44      sdsfree(se->peerid);
45      sdsfree(se->cname);
46      zfree(se);
47  }
48  void slowlogInit(void) {
49      server.slowlog = listCreate();
50      server.slowlog_entry_id = 0;
51      listSetFreeMethod(server.slowlog,slowlogFreeEntry);
52  }
53  void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, PORT_LONGLONG duration) {
54      if (server.slowlog_log_slower_than < 0) return; &bsol;* Slowlog disabled */
55      if (duration >= server.slowlog_log_slower_than)
56          listAddNodeHead(server.slowlog,
57                          slowlogCreateEntry(c,argv,argc,duration));
58      while (listLength(server.slowlog) > server.slowlog_max_len)
59          listDelNode(server.slowlog,listLast(server.slowlog));
60  }
61  void slowlogReset(void) {
62      while (listLength(server.slowlog) > 0)
63          listDelNode(server.slowlog,listLast(server.slowlog));
64  }
65  void slowlogCommand(client *c) {
66      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
67          const char *help[] = {
68  "GET [count] -- Return top entries from the slowlog (default: 10)."
69  "    Entries are made of:",
70  "    id, timestamp, time in microseconds, arguments array, client IP and port, client name",
71  "LEN -- Return the length of the slowlog.",
72  "RESET -- Reset the slowlog.",
73  NULL
74          };
75          addReplyHelp(c, help);
<span onclick='openModal()' class='match'>76      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"reset")) {
77          slowlogReset();
78          addReply(c,shared.ok);
79      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"len")) {
80          addReplyLongLong(c,listLength(server.slowlog));
81      } else if ((c->argc == 2 || c->argc == 3) &&
</span>82                 !strcasecmp(c->argv[1]->ptr,"get"))
83      {
84          PORT_LONG count = 10, sent = 0;
85          listIter li;
86          void *totentries;
87          listNode *ln;
88          slowlogEntry *se;
89          if (c->argc == 3 &&
90              getLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK)
91              return;
92          listRewind(server.slowlog,&li);
93          totentries = addDeferredMultiBulkLength(c);
94          while(count-- && (ln = listNext(&li))) {
95              int j;
96              se = ln->value;
97              addReplyMultiBulkLen(c,6);
98              addReplyLongLong(c,se->id);
99              addReplyLongLong(c,se->time);
100              addReplyLongLong(c,se->duration);
101              addReplyMultiBulkLen(c,se->argc);
102              for (j = 0; j < se->argc; j++)
103                  addReplyBulk(c,se->argv[j]);
104              addReplyBulkCBuffer(c,se->peerid,sdslen(se->peerid));
105              addReplyBulkCBuffer(c,se->cname,sdslen(se->cname));
106              sent++;
107          }
108          setDeferredMultiBulkLength(c,totentries,sent);
109      } else {
110          addReplySubcommandSyntaxError(c);
111      }
112  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mutex_pool.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-slowlog.c</div>
                </div>
                <div class="column column_space"><pre><code>42  	if ((uintptr_t)mutex1 < (uintptr_t)mutex2) {
43  		malloc_mutex_lock(tsdn, mutex1);
44  		malloc_mutex_lock(tsdn, mutex2);
45  	} else if ((uintptr_t)mutex1 == (uintptr_t)mutex2) {
46  		malloc_mutex_lock(tsdn, mutex1);
47  	} else {
</pre></code></div>
                <div class="column column_space"><pre><code>76      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"reset")) {
77          slowlogReset();
78          addReply(c,shared.ok);
79      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"len")) {
80          addReplyLongLong(c,listLength(server.slowlog));
81      } else if ((c->argc == 2 || c->argc == 3) &&
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    