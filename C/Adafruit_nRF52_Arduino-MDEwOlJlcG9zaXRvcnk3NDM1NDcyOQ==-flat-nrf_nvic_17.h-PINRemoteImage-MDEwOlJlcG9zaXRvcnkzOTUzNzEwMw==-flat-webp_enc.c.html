
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.7037037037037033%, Tokens: 10</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</h3>
            <pre><code>1  #ifndef NRF_NVIC_H__
2  #define NRF_NVIC_H__
3  #include <stdint.h>
4  #include "nrf.h"
5  #include "nrf_svc.h"
6  #include "nrf_error.h"
7  #include "nrf_error_soc.h"
8  #ifdef __cplusplus
9  extern "C" {
10  #endif
11  #define __NRF_NVIC_NVMC_IRQn (30) &bsol;**< The peripheral ID of the NVMC. IRQ numbers are used to identify peripherals, but the NVMC doesn't have an IRQ number in the MDK. */
12  #define __NRF_NVIC_ISER_COUNT (2) &bsol;**< The number of ISER/ICER registers in the NVIC that are used. */
13  #define __NRF_NVIC_SD_IRQ_PRIOS ((uint8_t)( \
14        (1U << 0)  &bsol;**< Priority level high .*/   \
15      | (1U << 1)  &bsol;**< Priority level medium. */ \
16      | (1U << 4)  &bsol;**< Priority level low. */    \
17    ))
18  #define __NRF_NVIC_APP_IRQ_PRIOS ((uint8_t)~__NRF_NVIC_SD_IRQ_PRIOS)
19  #define __NRF_NVIC_SD_IRQS_0 ((uint32_t)( \
20        (1U << POWER_CLOCK_IRQn) \
21      | (1U << RADIO_IRQn) \
22      | (1U << RTC0_IRQn) \
23      | (1U << TIMER0_IRQn) \
24      | (1U << RNG_IRQn) \
25      | (1U << ECB_IRQn) \
26      | (1U << CCM_AAR_IRQn) \
27      | (1U << TEMP_IRQn) \
28      | (1U << __NRF_NVIC_NVMC_IRQn) \
29      | (1U << (uint32_t)SWI5_IRQn) \
30    ))
31  #define __NRF_NVIC_SD_IRQS_1 ((uint32_t)0)
32  #define __NRF_NVIC_APP_IRQS_0 (~__NRF_NVIC_SD_IRQS_0)
33  #define __NRF_NVIC_APP_IRQS_1 (~__NRF_NVIC_SD_IRQS_1)
34  typedef struct
35  {
36    uint32_t volatile __irq_masks[__NRF_NVIC_ISER_COUNT]; &bsol;**< IRQs enabled by the application in the NVIC. */
37    uint32_t volatile __cr_flag;                          &bsol;**< Non-zero if already in a critical region */
38  } nrf_nvic_state_t;
39  extern nrf_nvic_state_t nrf_nvic_state;
40  __STATIC_INLINE int __sd_nvic_irq_disable(void);
41  __STATIC_INLINE void __sd_nvic_irq_enable(void);
42  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn);
43  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority);
44  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn);
45  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn);
46  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
47  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
48  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
49  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority);
50  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority);
51  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void);
52  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
53  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
54  #ifndef SUPPRESS_INLINE_IMPLEMENTATION
55  __STATIC_INLINE int __sd_nvic_irq_disable(void)
56  {
57    int pm = __get_PRIMASK();
58    __disable_irq();
59    return pm;
60  }
61  __STATIC_INLINE void __sd_nvic_irq_enable(void)
62  {
63    __enable_irq();
64  }
65  __STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
66  {
67    if (IRQn < 32)
68    {
69      return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
70    }
71    else if (IRQn < 64)
72    {
73      return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
74    }
75    else
76    {
77      return 1;
78    }
79  }
80  __STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
81  {
82    if( (priority >= (1 << __NVIC_PRIO_BITS))
83     || (((1 << priority) & __NRF_NVIC_APP_IRQ_PRIOS) == 0)
84      )
85    {
86      return 0;
87    }
88    return 1;
89  }
90  __STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
91  {
<span onclick='openModal()' class='match'>92    if (!__sd_nvic_app_accessible_irq(IRQn))
93    {
94      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
95    }
96    if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
97    {
98      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
99    }
100    if (nrf_nvic_state.__cr_flag)
101    {
</span>102      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
103    }
104    else
105    {
106      NVIC_EnableIRQ(IRQn);
107    }
108    return NRF_SUCCESS;
109  }
110  __STATIC_INLINE uint32_t sd_nvic_DisableIRQ(IRQn_Type IRQn)
111  {
112    if (!__sd_nvic_app_accessible_irq(IRQn))
113    {
114      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
115    }
116    if (nrf_nvic_state.__cr_flag)
117    {
118      nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] &= ~(1UL << ((uint32_t)(IRQn) & 0x1F));
119    }
120    else
121    {
122      NVIC_DisableIRQ(IRQn);
123    }
124    return NRF_SUCCESS;
125  }
126  __STATIC_INLINE uint32_t sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq)
127  {
128    if (__sd_nvic_app_accessible_irq(IRQn))
129    {
130      *p_pending_irq = NVIC_GetPendingIRQ(IRQn);
131      return NRF_SUCCESS;
132    }
133    else
134    {
135      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
136    }
137  }
138  __STATIC_INLINE uint32_t sd_nvic_SetPendingIRQ(IRQn_Type IRQn)
139  {
140    if (__sd_nvic_app_accessible_irq(IRQn))
141    {
142      NVIC_SetPendingIRQ(IRQn);
143      return NRF_SUCCESS;
144    }
145    else
146    {
147      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
148    }
149  }
150  __STATIC_INLINE uint32_t sd_nvic_ClearPendingIRQ(IRQn_Type IRQn)
151  {
152    if (__sd_nvic_app_accessible_irq(IRQn))
153    {
154      NVIC_ClearPendingIRQ(IRQn);
155      return NRF_SUCCESS;
156    }
157    else
158    {
159      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
160    }
161  }
162  __STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
163  {
164    if (!__sd_nvic_app_accessible_irq(IRQn))
165    {
166      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
167    }
168    if (!__sd_nvic_is_app_accessible_priority(priority))
169    {
170      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
171    }
172    NVIC_SetPriority(IRQn, (uint32_t)priority);
173    return NRF_SUCCESS;
174  }
175  __STATIC_INLINE uint32_t sd_nvic_GetPriority(IRQn_Type IRQn, uint32_t * p_priority)
176  {
177    if (__sd_nvic_app_accessible_irq(IRQn))
178    {
179      *p_priority = (NVIC_GetPriority(IRQn) & 0xFF);
180      return NRF_SUCCESS;
181    }
182    else
183    {
184      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
185    }
186  }
187  __STATIC_INLINE uint32_t sd_nvic_SystemReset(void)
188  {
189    NVIC_SystemReset();
190    return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
191  }
192  __STATIC_INLINE uint32_t sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region)
193  {
194    int was_masked = __sd_nvic_irq_disable();
195    if (!nrf_nvic_state.__cr_flag)
196    {
197      nrf_nvic_state.__cr_flag = 1;
198      nrf_nvic_state.__irq_masks[0] = ( NVIC->ICER[0] & __NRF_NVIC_APP_IRQS_0 );
199      NVIC->ICER[0] = __NRF_NVIC_APP_IRQS_0;
200      nrf_nvic_state.__irq_masks[1] = ( NVIC->ICER[1] & __NRF_NVIC_APP_IRQS_1 );
201      NVIC->ICER[1] = __NRF_NVIC_APP_IRQS_1;
202      *p_is_nested_critical_region = 0;
203    }
204    else
205    {
206      *p_is_nested_critical_region = 1;
207    }
208    if (!was_masked)
209    {
210      __sd_nvic_irq_enable();
211    }
212    return NRF_SUCCESS;
213  }
214  __STATIC_INLINE uint32_t sd_nvic_critical_region_exit(uint8_t is_nested_critical_region)
215  {
216    if (nrf_nvic_state.__cr_flag && (is_nested_critical_region == 0))
217    {
218      int was_masked = __sd_nvic_irq_disable();
219      NVIC->ISER[0] = nrf_nvic_state.__irq_masks[0];
220      NVIC->ISER[1] = nrf_nvic_state.__irq_masks[1];
221      nrf_nvic_state.__cr_flag = 0;
222      if (!was_masked)
223      {
224        __sd_nvic_irq_enable();
225      }
226    }
227    return NRF_SUCCESS;
228  }
229  #endif &bsol;* SUPPRESS_INLINE_IMPLEMENTATION */
230  #ifdef __cplusplus
231  }
232  #endif
233  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <math.h>
5  #include "src/enc/cost_enc.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/enc/vp8li_enc.h"
8  #include "src/utils/utils.h"
9  #ifdef PRINT_MEMORY_INFO
10  #include <stdio.h>
11  #endif
12  int WebPGetEncoderVersion(void) {
13    return (ENC_MAJ_VERSION << 16) | (ENC_MIN_VERSION << 8) | ENC_REV_VERSION;
14  }
15  static void ResetSegmentHeader(VP8Encoder* const enc) {
16    VP8EncSegmentHeader* const hdr = &enc->segment_hdr_;
17    hdr->num_segments_ = enc->config_->segments;
18    hdr->update_map_  = (hdr->num_segments_ > 1);
19    hdr->size_ = 0;
20  }
21  static void ResetFilterHeader(VP8Encoder* const enc) {
22    VP8EncFilterHeader* const hdr = &enc->filter_hdr_;
23    hdr->simple_ = 1;
24    hdr->level_ = 0;
25    hdr->sharpness_ = 0;
26    hdr->i4x4_lf_delta_ = 0;
27  }
28  static void ResetBoundaryPredictions(VP8Encoder* const enc) {
29    int i;
30    uint8_t* const top = enc->preds_ - enc->preds_w_;
31    uint8_t* const left = enc->preds_ - 1;
32    for (i = -1; i < 4 * enc->mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i < 4 * enc->mb_h_; ++i) {
36      left[i * enc->preds_w_] = B_DC_PRED;
37    }
38    enc->nz_[-1] = 0;   
39  }
40  static void MapConfigToTools(VP8Encoder* const enc) {
41    const WebPConfig* const config = enc->config_;
42    const int method = config->method;
43    const int limit = 100 - config->partition_limit;
44    enc->method_ = method;
45    enc->rd_opt_level_ = (method >= 6) ? RD_OPT_TRELLIS_ALL
46                       : (method >= 5) ? RD_OPT_TRELLIS
47                       : (method >= 3) ? RD_OPT_BASIC
48                       : RD_OPT_NONE;
49    enc->max_i4_header_bits_ =
50        256 * 16 * 16 *                 
51        (limit * limit) / (100 * 100);  
52    enc->mb_header_limit_ =
53        (score_t)256 * 510 * 8 * 1024 / (enc->mb_w_ * enc->mb_h_);
54    enc->thread_level_ = config->thread_level;
55    enc->do_search_ = (config->target_size > 0 || config->target_PSNR > 0);
56    if (!config->low_memory) {
57  #if !defined(DISABLE_TOKEN_BUFFER)
58      enc->use_tokens_ = (enc->rd_opt_level_ >= RD_OPT_BASIC);  
59  #endif
60      if (enc->use_tokens_) {
61        enc->num_parts_ = 1;   
62      }
63    }
64  }
65  static VP8Encoder* InitVP8Encoder(const WebPConfig* const config,
66                                    WebPPicture* const picture) {
67    VP8Encoder* enc;
68    const int use_filter =
69        (config->filter_strength > 0) || (config->autofilter > 0);
70    const int mb_w = (picture->width + 15) >> 4;
71    const int mb_h = (picture->height + 15) >> 4;
72    const int preds_w = 4 * mb_w + 1;
73    const int preds_h = 4 * mb_h + 1;
74    const size_t preds_size = preds_w * preds_h * sizeof(*enc->preds_);
75    const int top_stride = mb_w * 16;
76    const size_t nz_size = (mb_w + 1) * sizeof(*enc->nz_) + WEBP_ALIGN_CST;
77    const size_t info_size = mb_w * mb_h * sizeof(*enc->mb_info_);
78    const size_t samples_size =
79        2 * top_stride * sizeof(*enc->y_top_)  
80        + WEBP_ALIGN_CST;                      
81    const size_t lf_stats_size =
82        config->autofilter ? sizeof(*enc->lf_stats_) + WEBP_ALIGN_CST : 0;
83    const size_t top_derr_size =
84        (config->quality <= ERROR_DIFFUSION_QUALITY || config->pass > 1) ?
85            mb_w * sizeof(*enc->top_derr_) : 0;
86    uint8_t* mem;
87    const uint64_t size = (uint64_t)sizeof(*enc)   
88                        + WEBP_ALIGN_CST           
89                        + info_size                
90                        + preds_size               
91                        + samples_size             
92                        + top_derr_size            
93                        + nz_size                  
94                        + lf_stats_size;           
95  #ifdef PRINT_MEMORY_INFO
96    printf("===================================\n");
97    printf("Memory used:\n"
98           "             encoder: %ld\n"
99           "                info: %ld\n"
100           "               preds: %ld\n"
101           "         top samples: %ld\n"
102           "       top diffusion: %ld\n"
103           "            non-zero: %ld\n"
104           "            lf-stats: %ld\n"
105           "               total: %ld\n",
106           sizeof(*enc) + WEBP_ALIGN_CST, info_size,
107           preds_size, samples_size, top_derr_size, nz_size, lf_stats_size, size);
108    printf("Transient object sizes:\n"
109           "      VP8EncIterator: %ld\n"
110           "        VP8ModeScore: %ld\n"
111           "      VP8SegmentInfo: %ld\n"
112           "         VP8EncProba: %ld\n"
113           "             LFStats: %ld\n",
114           sizeof(VP8EncIterator), sizeof(VP8ModeScore),
115           sizeof(VP8SegmentInfo), sizeof(VP8EncProba),
116           sizeof(LFStats));
117    printf("Picture size (yuv): %ld\n",
118           mb_w * mb_h * 384 * sizeof(uint8_t));
119    printf("===================================\n");
120  #endif
121    mem = (uint8_t*)WebPSafeMalloc(size, sizeof(*mem));
122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
128    memset(enc, 0, sizeof(*enc));
129    enc->num_parts_ = 1 << config->partitions;
130    enc->mb_w_ = mb_w;
131    enc->mb_h_ = mb_h;
132    enc->preds_w_ = preds_w;
133    enc->mb_info_ = (VP8MBInfo*)mem;
134    mem += info_size;
135    enc->preds_ = mem + 1 + enc->preds_w_;
136    mem += preds_size;
137    enc->nz_ = 1 + (uint32_t*)WEBP_ALIGN(mem);
138    mem += nz_size;
139    enc->lf_stats_ = lf_stats_size ? (LFStats*)WEBP_ALIGN(mem) : NULL;
140    mem += lf_stats_size;
141    mem = (uint8_t*)WEBP_ALIGN(mem);
142    enc->y_top_ = mem;
143    enc->uv_top_ = enc->y_top_ + top_stride;
144    mem += 2 * top_stride;
145    enc->top_derr_ = top_derr_size ? (DError*)mem : NULL;
146    mem += top_derr_size;
147    assert(mem <= (uint8_t*)enc + size);
148    enc->config_ = config;
149    enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;
150    enc->pic_ = picture;
151    enc->percent_ = 0;
152    MapConfigToTools(enc);
153    VP8EncDspInit();
154    VP8DefaultProbas(enc);
155    ResetSegmentHeader(enc);
156    ResetFilterHeader(enc);
157    ResetBoundaryPredictions(enc);
158    VP8EncDspCostInit();
159    VP8EncInitAlpha(enc);
160    {
161      const float scale = 1.f + config->quality * 5.f / 100.f;  
162      VP8TBufferInit(&enc->tokens_, (int)(mb_w * mb_h * 4 * scale));
163    }
164    return enc;
165  }
166  static int DeleteVP8Encoder(VP8Encoder* enc) {
167    int ok = 1;
168    if (enc != NULL) {
169      ok = VP8EncDeleteAlpha(enc);
170      VP8TBufferClear(&enc->tokens_);
171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
177    return (err > 0 && size > 0) ? 10. * log10(255. * 255. * size / err) : 99.;
178  }
179  static void FinalizePSNR(const VP8Encoder* const enc) {
180    WebPAuxStats* stats = enc->pic_->stats;
181    const uint64_t size = enc->sse_count_;
182    const uint64_t* const sse = enc->sse_;
183    stats->PSNR[0] = (float)GetPSNR(sse[0], size);
184    stats->PSNR[1] = (float)GetPSNR(sse[1], size / 4);
185    stats->PSNR[2] = (float)GetPSNR(sse[2], size / 4);
186    stats->PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);
187    stats->PSNR[4] = (float)GetPSNR(sse[3], size);
188  }
189  #endif  
190  static void StoreStats(VP8Encoder* const enc) {
191  #if !defined(WEBP_DISABLE_STATS)
192    WebPAuxStats* const stats = enc->pic_->stats;
193    if (stats != NULL) {
194      int i, s;
195      for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
196        stats->segment_level[i] = enc->dqm_[i].fstrength_;
197        stats->segment_quant[i] = enc->dqm_[i].quant_;
198        for (s = 0; s <= 2; ++s) {
199          stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
200        }
201      }
202      FinalizePSNR(enc);
203      stats->coded_size = enc->coded_size_;
204      for (i = 0; i < 3; ++i) {
205        stats->block_count[i] = enc->block_count_[i];
206      }
207    }
208  #else  
209    WebPReportProgress(enc->pic_, 100, &enc->percent_);  
210  #endif  
211  }
212  int WebPEncodingSetError(const WebPPicture* const pic,
213                           WebPEncodingError error) {
214    assert((int)error < VP8_ENC_ERROR_LAST);
215    assert((int)error >= VP8_ENC_OK);
216    ((WebPPicture*)pic)->error_code = error;
217    return 0;
218  }
219  int WebPReportProgress(const WebPPicture* const pic,
220                         int percent, int* const percent_store) {
221    if (percent_store != NULL && percent != *percent_store) {
222      *percent_store = percent;
223      if (pic->progress_hook && !pic->progress_hook(percent, pic)) {
224        WebPEncodingSetError(pic, VP8_ENC_ERROR_USER_ABORT);
225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
232    if (pic == NULL) return 0;
233    WebPEncodingSetError(pic, VP8_ENC_OK);  
234    if (config == NULL) {  
235      return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);
236    }
<span onclick='openModal()' class='match'>237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic->width <= 0 || pic->height <= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic->width > WEBP_MAX_DIMENSION || pic->height > WEBP_MAX_DIMENSION) {
</span>244      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
245    }
246    if (pic->stats != NULL) memset(pic->stats, 0, sizeof(*pic->stats));
247    if (!config->lossless) {
248      VP8Encoder* enc = NULL;
249      if (pic->use_argb || pic->y == NULL || pic->u == NULL || pic->v == NULL) {
250        if (config->use_sharp_yuv || (config->preprocessing & 4)) {
251          if (!WebPPictureSharpARGBToYUVA(pic)) {
252            return 0;
253          }
254        } else {
255          float dithering = 0.f;
256          if (config->preprocessing & 2) {
257            const float x = config->quality / 100.f;
258            const float x2 = x * x;
259            dithering = 1.0f + (0.5f - 1.0f) * x2 * x2;
260          }
261          if (!WebPPictureARGBToYUVADithered(pic, WEBP_YUV420, dithering)) {
262            return 0;
263          }
264        }
265      }
266      if (!config->exact) {
267        WebPCleanupTransparentArea(pic);
268      }
269      enc = InitVP8Encoder(config, pic);
270      if (enc == NULL) return 0;  
271      ok = VP8EncAnalyze(enc);
272      ok = ok && VP8EncStartAlpha(enc);   
273      if (!enc->use_tokens_) {
274        ok = ok && VP8EncLoop(enc);
275      } else {
276        ok = ok && VP8EncTokenLoop(enc);
277      }
278      ok = ok && VP8EncFinishAlpha(enc);
279      ok = ok && VP8EncWrite(enc);
280      StoreStats(enc);
281      if (!ok) {
282        VP8EncFreeBitWriters(enc);
283      }
284      ok &= DeleteVP8Encoder(enc);  
285    } else {
286      if (pic->argb == NULL && !WebPPictureYUVAToARGB(pic)) {
287        return 0;
288      }
289      if (!config->exact) {
290        WebPCleanupTransparentAreaLossless(pic);
291      }
292      ok = VP8LEncodeImage(config, pic);  
293    }
294    return ok;
295  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvic_17.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</div>
                <div class="column column_space"><pre><code>92    if (!__sd_nvic_app_accessible_irq(IRQn))
93    {
94      return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
95    }
96    if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
97    {
98      return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
99    }
100    if (nrf_nvic_state.__cr_flag)
101    {
</pre></code></div>
                <div class="column column_space"><pre><code>237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic->width <= 0 || pic->height <= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic->width > WEBP_MAX_DIMENSION || pic->height > WEBP_MAX_DIMENSION) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    