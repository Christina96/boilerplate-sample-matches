
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.5135135135135136%, Tokens: 13</h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-bpf_image.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap-types.h>
5  #include <stdio.h>
6  #include <string.h>
7  #ifdef __linux__
8  #include <linux/types.h>
9  #include <linux/if_packet.h>
10  #include <linux/filter.h>
11  #undef BPF_STMT
12  #undef BPF_JUMP
13  #endif
14  #include "pcap-int.h"
15  #include "thread-local.h"
16  #ifdef HAVE_OS_PROTO_H
17  #include "os-proto.h"
18  #endif
19  #ifdef SKF_AD_OFF
<span onclick='openModal()' class='match'>20  static const char *offsets[SKF_AD_MAX] = {
21  #ifdef SKF_AD_PROTOCOL
22  	[SKF_AD_PROTOCOL] = "proto",
23  #endif
24  #ifdef SKF_AD_PKTTYPE
25  	[SKF_AD_PKTTYPE] = "type",
26  #endif
27  #ifdef SKF_AD_IFINDEX
28  	[SKF_AD_IFINDEX] = "ifidx",
29  #endif
30  #ifdef SKF_AD_NLATTR
31  	[SKF_AD_NLATTR] = "nla",
32  #endif
33  #ifdef SKF_AD_NLATTR_NEST
34  	[SKF_AD_NLATTR_NEST] = "nlan",
35  #endif
36  #ifdef SKF_AD_MARK
37  	[SKF_AD_MARK] = "mark",
38  #endif
39  #ifdef SKF_AD_QUEUE
40  	[SKF_AD_QUEUE] = "queue",
41  #endif
42  #ifdef SKF_AD_HATYPE
43  	[SKF_AD_HATYPE] = "hatype",
44  #endif
45  #ifdef SKF_AD_RXHASH
46  	[SKF_AD_RXHASH] = "rxhash",
47  #endif
48  #ifdef SKF_AD_CPU
49  	[SKF_AD_CPU] = "cpu",
50  #endif
51  #ifdef SKF_AD_ALU_XOR_X
52  	[SKF_AD_ALU_XOR_X] = "xor_x",
53  #endif
54  #ifdef SKF_AD_VLAN_TAG
55  	[SKF_AD_VLAN_TAG] = "vlan_tci",
</span>56  #endif
57  #ifdef SKF_AD_VLAN_TAG_PRESENT
58  	[SKF_AD_VLAN_TAG_PRESENT] = "vlanp",
59  #endif
60  #ifdef SKF_AD_PAY_OFFSET
61  	[SKF_AD_PAY_OFFSET] = "poff",
62  #endif
63  #ifdef SKF_AD_RANDOM
64  	[SKF_AD_RANDOM] = "random",
65  #endif
66  #ifdef SKF_AD_VLAN_TPID
67  	[SKF_AD_VLAN_TPID] = "vlan_tpid"
68  #endif
69  };
70  #endif
71  static void
72  bpf_print_abs_load_operand(char *buf, size_t bufsize, const struct bpf_insn *p)
73  {
74  #ifdef SKF_AD_OFF
75  	const char *sym;
76  	if (p->k >= (bpf_u_int32)SKF_AD_OFF &&
77  	    p->k < (bpf_u_int32)(SKF_AD_OFF + SKF_AD_MAX) &&
78  	    (sym = offsets[p->k - (bpf_u_int32)SKF_AD_OFF]) != NULL) {
79  		(void)snprintf(buf, bufsize, "[%s]", sym);
80  	} else
81  #endif
82  		(void)snprintf(buf, bufsize, "[%d]", p->k);
83  }
84  char *
85  bpf_image(const struct bpf_insn *p, int n)
86  {
87  	const char *op;
88  	static thread_local char image[256];
89  	char operand_buf[64];
90  	const char *operand;
91  	switch (p->code) {
92  	default:
93  		op = "unimp";
94  		(void)snprintf(operand_buf, sizeof operand_buf, "0x%x", p->code);
95  		operand = operand_buf;
96  		break;
97  	case BPF_RET|BPF_K:
98  		op = "ret";
99  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
100  		operand = operand_buf;
101  		break;
102  	case BPF_RET|BPF_A:
103  		op = "ret";
104  		operand = "";
105  		break;
106  	case BPF_LD|BPF_W|BPF_ABS:
107  		op = "ld";
108  		bpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);
109  		operand = operand_buf;
110  		break;
111  	case BPF_LD|BPF_H|BPF_ABS:
112  		op = "ldh";
113  		bpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);
114  		operand = operand_buf;
115  		break;
116  	case BPF_LD|BPF_B|BPF_ABS:
117  		op = "ldb";
118  		bpf_print_abs_load_operand(operand_buf, sizeof operand_buf, p);
119  		operand = operand_buf;
120  		break;
121  	case BPF_LD|BPF_W|BPF_LEN:
122  		op = "ld";
123  		operand = "#pktlen";
124  		break;
125  	case BPF_LD|BPF_W|BPF_IND:
126  		op = "ld";
127  		(void)snprintf(operand_buf, sizeof operand_buf, "[x + %d]", p->k);
128  		operand = operand_buf;
129  		break;
130  	case BPF_LD|BPF_H|BPF_IND:
131  		op = "ldh";
132  		(void)snprintf(operand_buf, sizeof operand_buf, "[x + %d]", p->k);
133  		operand = operand_buf;
134  		break;
135  	case BPF_LD|BPF_B|BPF_IND:
136  		op = "ldb";
137  		(void)snprintf(operand_buf, sizeof operand_buf, "[x + %d]", p->k);
138  		operand = operand_buf;
139  		break;
140  	case BPF_LD|BPF_IMM:
141  		op = "ld";
142  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
143  		operand = operand_buf;
144  		break;
145  	case BPF_LDX|BPF_IMM:
146  		op = "ldx";
147  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
148  		operand = operand_buf;
149  		break;
150  	case BPF_LDX|BPF_MSH|BPF_B:
151  		op = "ldxb";
152  		(void)snprintf(operand_buf, sizeof operand_buf, "4*([%d]&0xf)", p->k);
153  		operand = operand_buf;
154  		break;
155  	case BPF_LD|BPF_MEM:
156  		op = "ld";
157  		(void)snprintf(operand_buf, sizeof operand_buf, "M[%d]", p->k);
158  		operand = operand_buf;
159  		break;
160  	case BPF_LDX|BPF_MEM:
161  		op = "ldx";
162  		(void)snprintf(operand_buf, sizeof operand_buf, "M[%d]", p->k);
163  		operand = operand_buf;
164  		break;
165  	case BPF_ST:
166  		op = "st";
167  		(void)snprintf(operand_buf, sizeof operand_buf, "M[%d]", p->k);
168  		operand = operand_buf;
169  		break;
170  	case BPF_STX:
171  		op = "stx";
172  		(void)snprintf(operand_buf, sizeof operand_buf, "M[%d]", p->k);
173  		operand = operand_buf;
174  		break;
175  	case BPF_JMP|BPF_JA:
176  		op = "ja";
177  		(void)snprintf(operand_buf, sizeof operand_buf, "%d", n + 1 + p->k);
178  		operand = operand_buf;
179  		break;
180  	case BPF_JMP|BPF_JGT|BPF_K:
181  		op = "jgt";
182  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
183  		operand = operand_buf;
184  		break;
185  	case BPF_JMP|BPF_JGE|BPF_K:
186  		op = "jge";
187  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
188  		operand = operand_buf;
189  		break;
190  	case BPF_JMP|BPF_JEQ|BPF_K:
191  		op = "jeq";
192  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
193  		operand = operand_buf;
194  		break;
195  	case BPF_JMP|BPF_JSET|BPF_K:
196  		op = "jset";
197  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
198  		operand = operand_buf;
199  		break;
200  	case BPF_JMP|BPF_JGT|BPF_X:
201  		op = "jgt";
202  		operand = "x";
203  		break;
204  	case BPF_JMP|BPF_JGE|BPF_X:
205  		op = "jge";
206  		operand = "x";
207  		break;
208  	case BPF_JMP|BPF_JEQ|BPF_X:
209  		op = "jeq";
210  		operand = "x";
211  		break;
212  	case BPF_JMP|BPF_JSET|BPF_X:
213  		op = "jset";
214  		operand = "x";
215  		break;
216  	case BPF_ALU|BPF_ADD|BPF_X:
217  		op = "add";
218  		operand = "x";
219  		break;
220  	case BPF_ALU|BPF_SUB|BPF_X:
221  		op = "sub";
222  		operand = "x";
223  		break;
224  	case BPF_ALU|BPF_MUL|BPF_X:
225  		op = "mul";
226  		operand = "x";
227  		break;
228  	case BPF_ALU|BPF_DIV|BPF_X:
229  		op = "div";
230  		operand = "x";
231  		break;
232  	case BPF_ALU|BPF_MOD|BPF_X:
233  		op = "mod";
234  		operand = "x";
235  		break;
236  	case BPF_ALU|BPF_AND|BPF_X:
237  		op = "and";
238  		operand = "x";
239  		break;
240  	case BPF_ALU|BPF_OR|BPF_X:
241  		op = "or";
242  		operand = "x";
243  		break;
244  	case BPF_ALU|BPF_XOR|BPF_X:
245  		op = "xor";
246  		operand = "x";
247  		break;
248  	case BPF_ALU|BPF_LSH|BPF_X:
249  		op = "lsh";
250  		operand = "x";
251  		break;
252  	case BPF_ALU|BPF_RSH|BPF_X:
253  		op = "rsh";
254  		operand = "x";
255  		break;
256  	case BPF_ALU|BPF_ADD|BPF_K:
257  		op = "add";
258  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
259  		operand = operand_buf;
260  		break;
261  	case BPF_ALU|BPF_SUB|BPF_K:
262  		op = "sub";
263  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
264  		operand = operand_buf;
265  		break;
266  	case BPF_ALU|BPF_MUL|BPF_K:
267  		op = "mul";
268  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
269  		operand = operand_buf;
270  		break;
271  	case BPF_ALU|BPF_DIV|BPF_K:
272  		op = "div";
273  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
274  		operand = operand_buf;
275  		break;
276  	case BPF_ALU|BPF_MOD|BPF_K:
277  		op = "mod";
278  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
279  		operand = operand_buf;
280  		break;
281  	case BPF_ALU|BPF_AND|BPF_K:
282  		op = "and";
283  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
284  		operand = operand_buf;
285  		break;
286  	case BPF_ALU|BPF_OR|BPF_K:
287  		op = "or";
288  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
289  		operand = operand_buf;
290  		break;
291  	case BPF_ALU|BPF_XOR|BPF_K:
292  		op = "xor";
293  		(void)snprintf(operand_buf, sizeof operand_buf, "#0x%x", p->k);
294  		operand = operand_buf;
295  		break;
296  	case BPF_ALU|BPF_LSH|BPF_K:
297  		op = "lsh";
298  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
299  		operand = operand_buf;
300  		break;
301  	case BPF_ALU|BPF_RSH|BPF_K:
302  		op = "rsh";
303  		(void)snprintf(operand_buf, sizeof operand_buf, "#%d", p->k);
304  		operand = operand_buf;
305  		break;
306  	case BPF_ALU|BPF_NEG:
307  		op = "neg";
308  		operand = "";
309  		break;
310  	case BPF_MISC|BPF_TAX:
311  		op = "tax";
312  		operand = "";
313  		break;
314  	case BPF_MISC|BPF_TXA:
315  		op = "txa";
316  		operand = "";
317  		break;
318  	}
319  	if (BPF_CLASS(p->code) == BPF_JMP && BPF_OP(p->code) != BPF_JA) {
320  		(void)snprintf(image, sizeof image,
321  			      "(%03d) %-8s %-16s jt %d\tjf %d",
322  			      n, op, operand, n + 1 + p->jt, n + 1 + p->jf);
323  	} else {
324  		(void)snprintf(image, sizeof image,
325  			      "(%03d) %-8s %s",
326  			      n, op, operand);
327  	}
328  	return image;
329  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-alpha_processing.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/dsp/dsp.h"
3  #if !defined(USE_TABLES_FOR_ALPHA_MULT)
4  #define USE_TABLES_FOR_ALPHA_MULT 0   
5  #endif
6  #define MFIX 24    
7  #define HALF ((1u << MFIX) >> 1)
8  #define KINV_255 ((1u << MFIX) / 255u)
9  static uint32_t Mult(uint8_t x, uint32_t mult) {
10    const uint32_t v = (x * mult + HALF) >> MFIX;
11    assert(v <= 255);  
12    return v;
13  }
14  #if (USE_TABLES_FOR_ALPHA_MULT == 1)
15  static const uint32_t kMultTables[2][256] = {
16    {    
17      0x00000000, 0xff000000, 0x7f800000, 0x55000000, 0x3fc00000, 0x33000000,
18      0x2a800000, 0x246db6db, 0x1fe00000, 0x1c555555, 0x19800000, 0x172e8ba2,
19      0x15400000, 0x139d89d8, 0x1236db6d, 0x11000000, 0x0ff00000, 0x0f000000,
20      0x0e2aaaaa, 0x0d6bca1a, 0x0cc00000, 0x0c249249, 0x0b9745d1, 0x0b1642c8,
21      0x0aa00000, 0x0a333333, 0x09cec4ec, 0x0971c71c, 0x091b6db6, 0x08cb08d3,
22      0x08800000, 0x0839ce73, 0x07f80000, 0x07ba2e8b, 0x07800000, 0x07492492,
23      0x07155555, 0x06e45306, 0x06b5e50d, 0x0689d89d, 0x06600000, 0x063831f3,
24      0x06124924, 0x05ee23b8, 0x05cba2e8, 0x05aaaaaa, 0x058b2164, 0x056cefa8,
25      0x05500000, 0x05343eb1, 0x05199999, 0x05000000, 0x04e76276, 0x04cfb2b7,
26      0x04b8e38e, 0x04a2e8ba, 0x048db6db, 0x0479435e, 0x04658469, 0x045270d0,
27      0x04400000, 0x042e29f7, 0x041ce739, 0x040c30c3, 0x03fc0000, 0x03ec4ec4,
28      0x03dd1745, 0x03ce540f, 0x03c00000, 0x03b21642, 0x03a49249, 0x03976fc6,
29      0x038aaaaa, 0x037e3f1f, 0x03722983, 0x03666666, 0x035af286, 0x034fcace,
30      0x0344ec4e, 0x033a5440, 0x03300000, 0x0325ed09, 0x031c18f9, 0x0312818a,
31      0x03092492, 0x03000000, 0x02f711dc, 0x02ee5846, 0x02e5d174, 0x02dd7baf,
32      0x02d55555, 0x02cd5cd5, 0x02c590b2, 0x02bdef7b, 0x02b677d4, 0x02af286b,
33      0x02a80000, 0x02a0fd5c, 0x029a1f58, 0x029364d9, 0x028ccccc, 0x0286562d,
34      0x02800000, 0x0279c952, 0x0273b13b, 0x026db6db, 0x0267d95b, 0x026217ec,
35      0x025c71c7, 0x0256e62a, 0x0251745d, 0x024c1bac, 0x0246db6d, 0x0241b2f9,
36      0x023ca1af, 0x0237a6f4, 0x0232c234, 0x022df2df, 0x02293868, 0x02249249,
37      0x02200000, 0x021b810e, 0x021714fb, 0x0212bb51, 0x020e739c, 0x020a3d70,
38      0x02061861, 0x02020408, 0x01fe0000, 0x01fa0be8, 0x01f62762, 0x01f25213,
39      0x01ee8ba2, 0x01ead3ba, 0x01e72a07, 0x01e38e38, 0x01e00000, 0x01dc7f10,
40      0x01d90b21, 0x01d5a3e9, 0x01d24924, 0x01cefa8d, 0x01cbb7e3, 0x01c880e5,
41      0x01c55555, 0x01c234f7, 0x01bf1f8f, 0x01bc14e5, 0x01b914c1, 0x01b61eed,
42      0x01b33333, 0x01b05160, 0x01ad7943, 0x01aaaaaa, 0x01a7e567, 0x01a5294a,
43      0x01a27627, 0x019fcbd2, 0x019d2a20, 0x019a90e7, 0x01980000, 0x01957741,
44      0x0192f684, 0x01907da4, 0x018e0c7c, 0x018ba2e8, 0x018940c5, 0x0186e5f0,
45      0x01849249, 0x018245ae, 0x01800000, 0x017dc11f, 0x017b88ee, 0x0179574e,
46      0x01772c23, 0x01750750, 0x0172e8ba, 0x0170d045, 0x016ebdd7, 0x016cb157,
47      0x016aaaaa, 0x0168a9b9, 0x0166ae6a, 0x0164b8a7, 0x0162c859, 0x0160dd67,
48      0x015ef7bd, 0x015d1745, 0x015b3bea, 0x01596596, 0x01579435, 0x0155c7b4,
49      0x01540000, 0x01523d03, 0x01507eae, 0x014ec4ec, 0x014d0fac, 0x014b5edc,
50      0x0149b26c, 0x01480a4a, 0x01466666, 0x0144c6af, 0x01432b16, 0x0141938b,
51      0x01400000, 0x013e7063, 0x013ce4a9, 0x013b5cc0, 0x0139d89d, 0x01385830,
52      0x0136db6d, 0x01356246, 0x0133ecad, 0x01327a97, 0x01310bf6, 0x012fa0be,
53      0x012e38e3, 0x012cd459, 0x012b7315, 0x012a150a, 0x0128ba2e, 0x01276276,
54      0x01260dd6, 0x0124bc44, 0x01236db6, 0x01222222, 0x0120d97c, 0x011f93bc,
55      0x011e50d7, 0x011d10c4, 0x011bd37a, 0x011a98ef, 0x0119611a, 0x01182bf2,
56      0x0116f96f, 0x0115c988, 0x01149c34, 0x0113716a, 0x01124924, 0x01112358,
57      0x01100000, 0x010edf12, 0x010dc087, 0x010ca458, 0x010b8a7d, 0x010a72f0,
58      0x01095da8, 0x01084a9f, 0x010739ce, 0x01062b2e, 0x01051eb8, 0x01041465,
59      0x01030c30, 0x01020612, 0x01010204, 0x01000000 },
60    {   
61      0x00000000, 0x00010101, 0x00020202, 0x00030303, 0x00040404, 0x00050505,
62      0x00060606, 0x00070707, 0x00080808, 0x00090909, 0x000a0a0a, 0x000b0b0b,
63      0x000c0c0c, 0x000d0d0d, 0x000e0e0e, 0x000f0f0f, 0x00101010, 0x00111111,
64      0x00121212, 0x00131313, 0x00141414, 0x00151515, 0x00161616, 0x00171717,
65      0x00181818, 0x00191919, 0x001a1a1a, 0x001b1b1b, 0x001c1c1c, 0x001d1d1d,
66      0x001e1e1e, 0x001f1f1f, 0x00202020, 0x00212121, 0x00222222, 0x00232323,
67      0x00242424, 0x00252525, 0x00262626, 0x00272727, 0x00282828, 0x00292929,
68      0x002a2a2a, 0x002b2b2b, 0x002c2c2c, 0x002d2d2d, 0x002e2e2e, 0x002f2f2f,
69      0x00303030, 0x00313131, 0x00323232, 0x00333333, 0x00343434, 0x00353535,
70      0x00363636, 0x00373737, 0x00383838, 0x00393939, 0x003a3a3a, 0x003b3b3b,
71      0x003c3c3c, 0x003d3d3d, 0x003e3e3e, 0x003f3f3f, 0x00404040, 0x00414141,
72      0x00424242, 0x00434343, 0x00444444, 0x00454545, 0x00464646, 0x00474747,
73      0x00484848, 0x00494949, 0x004a4a4a, 0x004b4b4b, 0x004c4c4c, 0x004d4d4d,
74      0x004e4e4e, 0x004f4f4f, 0x00505050, 0x00515151, 0x00525252, 0x00535353,
75      0x00545454, 0x00555555, 0x00565656, 0x00575757, 0x00585858, 0x00595959,
76      0x005a5a5a, 0x005b5b5b, 0x005c5c5c, 0x005d5d5d, 0x005e5e5e, 0x005f5f5f,
77      0x00606060, 0x00616161, 0x00626262, 0x00636363, 0x00646464, 0x00656565,
78      0x00666666, 0x00676767, 0x00686868, 0x00696969, 0x006a6a6a, 0x006b6b6b,
79      0x006c6c6c, 0x006d6d6d, 0x006e6e6e, 0x006f6f6f, 0x00707070, 0x00717171,
80      0x00727272, 0x00737373, 0x00747474, 0x00757575, 0x00767676, 0x00777777,
81      0x00787878, 0x00797979, 0x007a7a7a, 0x007b7b7b, 0x007c7c7c, 0x007d7d7d,
82      0x007e7e7e, 0x007f7f7f, 0x00808080, 0x00818181, 0x00828282, 0x00838383,
83      0x00848484, 0x00858585, 0x00868686, 0x00878787, 0x00888888, 0x00898989,
84      0x008a8a8a, 0x008b8b8b, 0x008c8c8c, 0x008d8d8d, 0x008e8e8e, 0x008f8f8f,
85      0x00909090, 0x00919191, 0x00929292, 0x00939393, 0x00949494, 0x00959595,
86      0x00969696, 0x00979797, 0x00989898, 0x00999999, 0x009a9a9a, 0x009b9b9b,
87      0x009c9c9c, 0x009d9d9d, 0x009e9e9e, 0x009f9f9f, 0x00a0a0a0, 0x00a1a1a1,
88      0x00a2a2a2, 0x00a3a3a3, 0x00a4a4a4, 0x00a5a5a5, 0x00a6a6a6, 0x00a7a7a7,
89      0x00a8a8a8, 0x00a9a9a9, 0x00aaaaaa, 0x00ababab, 0x00acacac, 0x00adadad,
90      0x00aeaeae, 0x00afafaf, 0x00b0b0b0, 0x00b1b1b1, 0x00b2b2b2, 0x00b3b3b3,
91      0x00b4b4b4, 0x00b5b5b5, 0x00b6b6b6, 0x00b7b7b7, 0x00b8b8b8, 0x00b9b9b9,
92      0x00bababa, 0x00bbbbbb, 0x00bcbcbc, 0x00bdbdbd, 0x00bebebe, 0x00bfbfbf,
93      0x00c0c0c0, 0x00c1c1c1, 0x00c2c2c2, 0x00c3c3c3, 0x00c4c4c4, 0x00c5c5c5,
94      0x00c6c6c6, 0x00c7c7c7, 0x00c8c8c8, 0x00c9c9c9, 0x00cacaca, 0x00cbcbcb,
95      0x00cccccc, 0x00cdcdcd, 0x00cecece, 0x00cfcfcf, 0x00d0d0d0, 0x00d1d1d1,
96      0x00d2d2d2, 0x00d3d3d3, 0x00d4d4d4, 0x00d5d5d5, 0x00d6d6d6, 0x00d7d7d7,
97      0x00d8d8d8, 0x00d9d9d9, 0x00dadada, 0x00dbdbdb, 0x00dcdcdc, 0x00dddddd,
98      0x00dedede, 0x00dfdfdf, 0x00e0e0e0, 0x00e1e1e1, 0x00e2e2e2, 0x00e3e3e3,
99      0x00e4e4e4, 0x00e5e5e5, 0x00e6e6e6, 0x00e7e7e7, 0x00e8e8e8, 0x00e9e9e9,
100      0x00eaeaea, 0x00ebebeb, 0x00ececec, 0x00ededed, 0x00eeeeee, 0x00efefef,
101      0x00f0f0f0, 0x00f1f1f1, 0x00f2f2f2, 0x00f3f3f3, 0x00f4f4f4, 0x00f5f5f5,
102      0x00f6f6f6, 0x00f7f7f7, 0x00f8f8f8, 0x00f9f9f9, 0x00fafafa, 0x00fbfbfb,
103      0x00fcfcfc, 0x00fdfdfd, 0x00fefefe, 0x00ffffff }
104  };
105  static WEBP_INLINE uint32_t GetScale(uint32_t a, int inverse) {
106    return kMultTables[!inverse][a];
107  }
108  #else
109  static WEBP_INLINE uint32_t GetScale(uint32_t a, int inverse) {
110    return inverse ? (255u << MFIX) / a : a * KINV_255;
111  }
112  #endif  
113  void WebPMultARGBRow_C(uint32_t* const ptr, int width, int inverse) {
114    int x;
115    for (x = 0; x < width; ++x) {
116      const uint32_t argb = ptr[x];
117      if (argb < 0xff000000u) {      
118        if (argb <= 0x00ffffffu) {   
119          ptr[x] = 0;
120        } else {
121          const uint32_t alpha = (argb >> 24) & 0xff;
122          const uint32_t scale = GetScale(alpha, inverse);
123          uint32_t out = argb & 0xff000000u;
124          out |= Mult(argb >>  0, scale) <<  0;
125          out |= Mult(argb >>  8, scale) <<  8;
126          out |= Mult(argb >> 16, scale) << 16;
127          ptr[x] = out;
128        }
129      }
130    }
131  }
132  void WebPMultRow_C(uint8_t* const ptr, const uint8_t* const alpha,
133                     int width, int inverse) {
134    int x;
135    for (x = 0; x < width; ++x) {
136      const uint32_t a = alpha[x];
137      if (a != 255) {
138        if (a == 0) {
139          ptr[x] = 0;
140        } else {
141          const uint32_t scale = GetScale(a, inverse);
142          ptr[x] = Mult(ptr[x], scale);
143        }
144      }
145    }
146  }
147  #undef KINV_255
148  #undef HALF
149  #undef MFIX
150  void (*WebPMultARGBRow)(uint32_t* const ptr, int width, int inverse);
151  void (*WebPMultRow)(uint8_t* const ptr, const uint8_t* const alpha,
152                      int width, int inverse);
153  void WebPMultARGBRows(uint8_t* ptr, int stride, int width, int num_rows,
154                        int inverse) {
155    int n;
156    for (n = 0; n < num_rows; ++n) {
157      WebPMultARGBRow((uint32_t*)ptr, width, inverse);
158      ptr += stride;
159    }
160  }
161  void WebPMultRows(uint8_t* ptr, int stride,
162                    const uint8_t* alpha, int alpha_stride,
163                    int width, int num_rows, int inverse) {
164    int n;
165    for (n = 0; n < num_rows; ++n) {
166      WebPMultRow(ptr, alpha, width, inverse);
167      ptr += stride;
168      alpha += alpha_stride;
169    }
170  }
171  #if 1     
172  #define MULTIPLIER(a)   ((a) * 32897U)
173  #define PREMULTIPLY(x, m) (((x) * (m)) >> 23)
174  #else     
175  #define MULTIPLIER(a) ((a) * 65793U)
176  #define PREMULTIPLY(x, m) (((x) * (m) + (1U << 23)) >> 24)
177  #endif
178  #if !WEBP_NEON_OMIT_C_CODE
179  static void ApplyAlphaMultiply_C(uint8_t* rgba, int alpha_first,
180                                   int w, int h, int stride) {
181    while (h-- > 0) {
182      uint8_t* const rgb = rgba + (alpha_first ? 1 : 0);
183      const uint8_t* const alpha = rgba + (alpha_first ? 0 : 3);
184      int i;
185      for (i = 0; i < w; ++i) {
186        const uint32_t a = alpha[4 * i];
187        if (a != 0xff) {
188          const uint32_t mult = MULTIPLIER(a);
189          rgb[4 * i + 0] = PREMULTIPLY(rgb[4 * i + 0], mult);
190          rgb[4 * i + 1] = PREMULTIPLY(rgb[4 * i + 1], mult);
191          rgb[4 * i + 2] = PREMULTIPLY(rgb[4 * i + 2], mult);
192        }
193      }
194      rgba += stride;
195    }
196  }
197  #endif  
198  #undef MULTIPLIER
199  #undef PREMULTIPLY
200  #define MULTIPLIER(a)  ((a) * 0x1111)    
201  static WEBP_INLINE uint8_t dither_hi(uint8_t x) {
202    return (x & 0xf0) | (x >> 4);
203  }
204  static WEBP_INLINE uint8_t dither_lo(uint8_t x) {
205    return (x & 0x0f) | (x << 4);
206  }
207  static WEBP_INLINE uint8_t multiply(uint8_t x, uint32_t m) {
208    return (x * m) >> 16;
209  }
210  static WEBP_INLINE void ApplyAlphaMultiply4444_C(uint8_t* rgba4444,
211                                                   int w, int h, int stride,
212                                                   int rg_byte_pos &bsol;* 0 or 1 */) {
213    while (h-- > 0) {
214      int i;
215      for (i = 0; i < w; ++i) {
216        const uint32_t rg = rgba4444[2 * i + rg_byte_pos];
217        const uint32_t ba = rgba4444[2 * i + (rg_byte_pos ^ 1)];
218        const uint8_t a = ba & 0x0f;
219        const uint32_t mult = MULTIPLIER(a);
220        const uint8_t r = multiply(dither_hi(rg), mult);
221        const uint8_t g = multiply(dither_lo(rg), mult);
222        const uint8_t b = multiply(dither_hi(ba), mult);
223        rgba4444[2 * i + rg_byte_pos] = (r & 0xf0) | ((g >> 4) & 0x0f);
224        rgba4444[2 * i + (rg_byte_pos ^ 1)] = (b & 0xf0) | a;
225      }
226      rgba4444 += stride;
227    }
228  }
229  #undef MULTIPLIER
230  static void ApplyAlphaMultiply_16b_C(uint8_t* rgba4444,
231                                       int w, int h, int stride) {
232  #if (WEBP_SWAP_16BIT_CSP == 1)
233    ApplyAlphaMultiply4444_C(rgba4444, w, h, stride, 1);
234  #else
235    ApplyAlphaMultiply4444_C(rgba4444, w, h, stride, 0);
236  #endif
237  }
238  #if !WEBP_NEON_OMIT_C_CODE
239  static int DispatchAlpha_C(const uint8_t* alpha, int alpha_stride,
240                             int width, int height,
241                             uint8_t* dst, int dst_stride) {
242    uint32_t alpha_mask = 0xff;
243    int i, j;
244    for (j = 0; j < height; ++j) {
245      for (i = 0; i < width; ++i) {
246        const uint32_t alpha_value = alpha[i];
247        dst[4 * i] = alpha_value;
248        alpha_mask &= alpha_value;
249      }
250      alpha += alpha_stride;
251      dst += dst_stride;
252    }
253    return (alpha_mask != 0xff);
254  }
255  static void DispatchAlphaToGreen_C(const uint8_t* alpha, int alpha_stride,
256                                     int width, int height,
257                                     uint32_t* dst, int dst_stride) {
258    int i, j;
259    for (j = 0; j < height; ++j) {
260      for (i = 0; i < width; ++i) {
261        dst[i] = alpha[i] << 8;  
262      }
263      alpha += alpha_stride;
264      dst += dst_stride;
265    }
266  }
267  static int ExtractAlpha_C(const uint8_t* argb, int argb_stride,
268                            int width, int height,
269                            uint8_t* alpha, int alpha_stride) {
270    uint8_t alpha_mask = 0xff;
271    int i, j;
272    for (j = 0; j < height; ++j) {
273      for (i = 0; i < width; ++i) {
274        const uint8_t alpha_value = argb[4 * i];
275        alpha[i] = alpha_value;
276        alpha_mask &= alpha_value;
277      }
278      argb += argb_stride;
279      alpha += alpha_stride;
280    }
281    return (alpha_mask == 0xff);
282  }
283  static void ExtractGreen_C(const uint32_t* argb, uint8_t* alpha, int size) {
284    int i;
285    for (i = 0; i < size; ++i) alpha[i] = argb[i] >> 8;
286  }
287  #endif  
288  static int HasAlpha8b_C(const uint8_t* src, int length) {
289    while (length-- > 0) if (*src++ != 0xff) return 1;
290    return 0;
291  }
292  static int HasAlpha32b_C(const uint8_t* src, int length) {
293    int x;
294    for (x = 0; length-- > 0; x += 4) if (src[x] != 0xff) return 1;
295    return 0;
296  }
297  static WEBP_INLINE uint32_t MakeARGB32(int a, int r, int g, int b) {
298    return (((uint32_t)a << 24) | (r << 16) | (g << 8) | b);
299  }
300  #ifdef WORDS_BIGENDIAN
301  static void PackARGB_C(const uint8_t* a, const uint8_t* r, const uint8_t* g,
302                         const uint8_t* b, int len, uint32_t* out) {
303    int i;
304    for (i = 0; i < len; ++i) {
305      out[i] = MakeARGB32(a[4 * i], r[4 * i], g[4 * i], b[4 * i]);
306    }
307  }
308  #endif
309  static void PackRGB_C(const uint8_t* r, const uint8_t* g, const uint8_t* b,
310                        int len, int step, uint32_t* out) {
311    int i, offset = 0;
312    for (i = 0; i < len; ++i) {
313      out[i] = MakeARGB32(0xff, r[offset], g[offset], b[offset]);
314      offset += step;
315    }
316  }
317  void (*WebPApplyAlphaMultiply)(uint8_t*, int, int, int, int);
318  void (*WebPApplyAlphaMultiply4444)(uint8_t*, int, int, int);
319  int (*WebPDispatchAlpha)(const uint8_t*, int, int, int, uint8_t*, int);
320  void (*WebPDispatchAlphaToGreen)(const uint8_t*, int, int, int, uint32_t*, int);
321  int (*WebPExtractAlpha)(const uint8_t*, int, int, int, uint8_t*, int);
322  void (*WebPExtractGreen)(const uint32_t* argb, uint8_t* alpha, int size);
323  #ifdef WORDS_BIGENDIAN
324  void (*WebPPackARGB)(const uint8_t* a, const uint8_t* r, const uint8_t* g,
325                       const uint8_t* b, int, uint32_t*);
326  #endif
327  void (*WebPPackRGB)(const uint8_t* r, const uint8_t* g, const uint8_t* b,
328                      int len, int step, uint32_t* out);
329  int (*WebPHasAlpha8b)(const uint8_t* src, int length);
330  int (*WebPHasAlpha32b)(const uint8_t* src, int length);
331  extern void WebPInitAlphaProcessingMIPSdspR2(void);
332  extern void WebPInitAlphaProcessingSSE2(void);
333  extern void WebPInitAlphaProcessingSSE41(void);
334  extern void WebPInitAlphaProcessingNEON(void);
<span onclick='openModal()' class='match'>335  WEBP_DSP_INIT_FUNC(WebPInitAlphaProcessing) {
336    WebPMultARGBRow = WebPMultARGBRow_C;
337    WebPMultRow = WebPMultRow_C;
338    WebPApplyAlphaMultiply4444 = ApplyAlphaMultiply_16b_C;
339  #ifdef WORDS_BIGENDIAN
340    WebPPackARGB = PackARGB_C;
341  #endif
342    WebPPackRGB = PackRGB_C;
343  #if !WEBP_NEON_OMIT_C_CODE
344    WebPApplyAlphaMultiply = ApplyAlphaMultiply_C;
345    WebPDispatchAlpha = DispatchAlpha_C;
346    WebPDispatchAlphaToGreen = DispatchAlphaToGreen_C;
347    WebPExtractAlpha = ExtractAlpha_C;
348    WebPExtractGreen = ExtractGreen_C;
349  #endif
350    WebPHasAlpha8b = HasAlpha8b_C;
351    WebPHasAlpha32b = HasAlpha32b_C;
</span>352    if (VP8GetCPUInfo != NULL) {
353  #if defined(WEBP_USE_SSE2)
354      if (VP8GetCPUInfo(kSSE2)) {
355        WebPInitAlphaProcessingSSE2();
356  #if defined(WEBP_USE_SSE41)
357        if (VP8GetCPUInfo(kSSE4_1)) {
358          WebPInitAlphaProcessingSSE41();
359        }
360  #endif
361      }
362  #endif
363  #if defined(WEBP_USE_MIPS_DSP_R2)
364      if (VP8GetCPUInfo(kMIPSdspR2)) {
365        WebPInitAlphaProcessingMIPSdspR2();
366      }
367  #endif
368    }
369  #if defined(WEBP_USE_NEON)
370    if (WEBP_NEON_OMIT_C_CODE ||
371        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
372      WebPInitAlphaProcessingNEON();
373    }
374  #endif
375    assert(WebPMultARGBRow != NULL);
376    assert(WebPMultRow != NULL);
377    assert(WebPApplyAlphaMultiply != NULL);
378    assert(WebPApplyAlphaMultiply4444 != NULL);
379    assert(WebPDispatchAlpha != NULL);
380    assert(WebPDispatchAlphaToGreen != NULL);
381    assert(WebPExtractAlpha != NULL);
382    assert(WebPExtractGreen != NULL);
383  #ifdef WORDS_BIGENDIAN
384    assert(WebPPackARGB != NULL);
385  #endif
386    assert(WebPPackRGB != NULL);
387    assert(WebPHasAlpha8b != NULL);
388    assert(WebPHasAlpha32b != NULL);
389  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-bpf_image.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-alpha_processing.c</div>
                <div class="column column_space"><pre><code>20  static const char *offsets[SKF_AD_MAX] = {
21  #ifdef SKF_AD_PROTOCOL
22  	[SKF_AD_PROTOCOL] = "proto",
23  #endif
24  #ifdef SKF_AD_PKTTYPE
25  	[SKF_AD_PKTTYPE] = "type",
26  #endif
27  #ifdef SKF_AD_IFINDEX
28  	[SKF_AD_IFINDEX] = "ifidx",
29  #endif
30  #ifdef SKF_AD_NLATTR
31  	[SKF_AD_NLATTR] = "nla",
32  #endif
33  #ifdef SKF_AD_NLATTR_NEST
34  	[SKF_AD_NLATTR_NEST] = "nlan",
35  #endif
36  #ifdef SKF_AD_MARK
37  	[SKF_AD_MARK] = "mark",
38  #endif
39  #ifdef SKF_AD_QUEUE
40  	[SKF_AD_QUEUE] = "queue",
41  #endif
42  #ifdef SKF_AD_HATYPE
43  	[SKF_AD_HATYPE] = "hatype",
44  #endif
45  #ifdef SKF_AD_RXHASH
46  	[SKF_AD_RXHASH] = "rxhash",
47  #endif
48  #ifdef SKF_AD_CPU
49  	[SKF_AD_CPU] = "cpu",
50  #endif
51  #ifdef SKF_AD_ALU_XOR_X
52  	[SKF_AD_ALU_XOR_X] = "xor_x",
53  #endif
54  #ifdef SKF_AD_VLAN_TAG
55  	[SKF_AD_VLAN_TAG] = "vlan_tci",
</pre></code></div>
                <div class="column column_space"><pre><code>335  WEBP_DSP_INIT_FUNC(WebPInitAlphaProcessing) {
336    WebPMultARGBRow = WebPMultARGBRow_C;
337    WebPMultRow = WebPMultRow_C;
338    WebPApplyAlphaMultiply4444 = ApplyAlphaMultiply_16b_C;
339  #ifdef WORDS_BIGENDIAN
340    WebPPackARGB = PackARGB_C;
341  #endif
342    WebPPackRGB = PackRGB_C;
343  #if !WEBP_NEON_OMIT_C_CODE
344    WebPApplyAlphaMultiply = ApplyAlphaMultiply_C;
345    WebPDispatchAlpha = DispatchAlpha_C;
346    WebPDispatchAlphaToGreen = DispatchAlphaToGreen_C;
347    WebPExtractAlpha = ExtractAlpha_C;
348    WebPExtractGreen = ExtractGreen_C;
349  #endif
350    WebPHasAlpha8b = HasAlpha8b_C;
351    WebPHasAlpha32b = HasAlpha32b_C;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    