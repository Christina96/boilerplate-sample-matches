<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for pmsnare.c & omfile-hardened.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for pmsnare.c & omfile-hardened.c
      </h3>
      <h1 align="center">
        5.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>pmsnare.c (14.624506%)<TH>omfile-hardened.c (3.1409168%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2227-0.html#0',2,'match2227-1.html#0',3)" NAME="0">(157-172)<TD><A HREF="javascript:ZweiFrames('match2227-0.html#0',2,'match2227-1.html#0',3)" NAME="0">(1314-1334)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2227-0.html#1',2,'match2227-1.html#1',3)" NAME="1">(94-103)<TD><A HREF="javascript:ZweiFrames('match2227-0.html#1',2,'match2227-1.html#1',3)" NAME="1">(246-255)</A><TD ALIGN=center><FONT COLOR="#d80000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmsnare.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* pmsnare.c
 *
 * this detects logs sent by Snare and cleans them up so that they can be processed by the normal parser
 *
 * there are two variations of this, if the client is set to 'syslog' mode it sends
 *
 * &lt;pri&gt;timestamp&lt;sp&gt;hostname&lt;sp&gt;tag&lt;tab&gt;otherstuff
 *
 * if the client is not set to syslog it sends
 *
 * hostname&lt;tab&gt;tag&lt;tab&gt;otherstuff
 *
 * The tabs can be represented in different ways. This module will auto-detect the tab representation based on
 * the global config settings, but they can be overridden for each instance in the config file if needed.
 *
 * ToDo, take advantage of items in the message itself to set more friendly information
 * where the normal parser will find it by re-writing more of the message
 *
 * Interesting information includes:
 *
 * in the case of windows snare messages:
 *   the system hostname is field 12
 *   the severity is field 3 (criticality ranging form 0 to 4)
 *   the source of the log is field 4 and may be able to be mapped to facility
 *
 *
 * created 2010-12-13 by David Lang based on pmlastmsg
 * Modified 2017-05-29 by Shane Lawrence.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;msg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;glbl.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parser.h&quot;
#include &quot;datetime.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;rsconf.h&quot;

MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME(&quot;rsyslog.snare&quot;)
MODULE_CNFNAME(&quot;pmsnare&quot;)

/* internal structures
 */
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)


/* static data */
static int bParseHOSTNAMEandTAG;	/* cache for the equally-named global param - performance enhancement */

/* Keep a list of parser instances so we can apply global settings after config is loaded. */
typedef struct modInstances_s {
	instanceConf_t *root;
	instanceConf_t *tail;
} modInstances_t;
static modInstances_t *modInstances = NULL;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *modConf = NULL;
<A NAME="1"></A>
/* Per-instance config settings. */
static struct cnfparamdescr parserpdescr[] = {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2227-1.html#1',3,'match2227-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;parser.controlcharacterescapeprefix&quot;, eCmdHdlrGetChar, 0 },
	{ &quot;parser.escapecontrolcharactersonreceive&quot;, eCmdHdlrBinary, 0 },
	{ &quot;parser.escapecontrolcharactertab&quot;, eCmdHdlrBinary, 0},
	{ &quot;parser.escapecontrolcharacterscstyle&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk parserpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	parserpdescr
};</B></FONT>
struct instanceConf_s {
	int bEscapeCCOnRcv;
	int bEscapeTab;
	int bParserEscapeCCCStyle;
	uchar cCCEscapeChar;
	int tabLength;
	char tabRepresentation[5];
	struct instanceConf_s *next;
};

/* Creates the instance and adds it to the list of instances. */
static rsRetVal createInstance(instanceConf_t **pinst) {
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	*pinst = inst;

	/*  Add to list of instances. */
	if(modInstances == NULL) {
		CHKmalloc(modInstances = malloc(sizeof(modInstances_t)));
		modInstances-&gt;tail = modInstances-&gt;root = NULL;
	}
	if (modInstances-&gt;tail == NULL) {
		modInstances-&gt;tail = modInstances-&gt;root = inst;
	} else {
		modInstances-&gt;tail-&gt;next = inst;
		modInstances-&gt;tail = inst;
	}

	finalize_it:
	RETiRet;
}

BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	DBGPRINTF(&quot;newParserInst (pmsnare)\n&quot;);
	inst = NULL;
	CHKiRet(createInstance(&amp;inst));

	/* Mark these as unset so we know if they should be overridden later. */
	inst-&gt;bEscapeCCOnRcv = -1;
	inst-&gt;bEscapeTab = -1;
	inst-&gt;bParserEscapeCCCStyle = -1;
	inst-&gt;cCCEscapeChar = '\0';

	/* If using the old config, just use global settings for each instance. */
	if (lst == NULL)
<A NAME="0"></A>		FINALIZE;

	/* If using the new config, process module settings for this instance. */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2227-1.html#0',3,'match2227-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;pmsnare: parser param blk:\n&quot;);
		cnfparamsPrint(&amp;parserpblk, pvals);
	}

	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(parserpblk.descr[i].name, &quot;parser.escapecontrolcharactersonreceive&quot;)) {
			inst-&gt;bEscapeCCOnRcv = pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;parser.escapecontrolcharactertab&quot;)) {
			inst-&gt;bEscapeTab = pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(parserpblk.descr[i].name, &quot;parser.escapecontrolcharacterscstyle&quot;)) {
			inst-&gt;bParserEscapeCCCStyle = pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;parser.controlcharacterescapeprefix&quot;)) {
			inst-&gt;cCCEscapeChar = (uchar) *es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;pmsnare: program error, non-handled param '%s'\n&quot;, parserpblk.descr[i].name);
		}
	}

finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
	if(iRet != RS_RET_OK)
		free(inst);
ENDnewParserInst

BEGINfreeParserInst
CODESTARTfreeParserInst
	dbgprintf(&quot;pmsnare: free parser instance %p\n&quot;, pInst);
ENDfreeParserInst

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticSanitazion)
		iRet = RS_RET_OK;
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

/* Interface with the global config. */
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	modConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINsetModCnf
CODESTARTsetModCnf
	/* Could use module-globals here, but not global globals. */
	(void) lst;
ENDsetModCnf

BEGINendCnfLoad
	instanceConf_t *inst;
CODESTARTendCnfLoad
	dbgprintf(&quot;pmsnare: Begin endCnfLoad\n&quot;);
	/* Loop through each parser instance and apply global settings to any option that hasn't been overridden.
	 * This can't be done any earlier because the config wasn't fully loaded until now. */
	for(inst = modInstances-&gt;root; inst != NULL; inst = inst-&gt;next) {
		if(inst-&gt;bEscapeCCOnRcv == -1)
			inst-&gt;bEscapeCCOnRcv = glbl.GetParserEscapeControlCharactersOnReceive(modConf-&gt;pConf);
		if(inst-&gt;bEscapeTab == -1)
			inst-&gt;bEscapeTab = glbl.GetParserEscapeControlCharacterTab(modConf-&gt;pConf);
		if(inst-&gt;bParserEscapeCCCStyle == -1)
			inst-&gt;bParserEscapeCCCStyle = glbl.GetParserEscapeControlCharactersCStyle(modConf-&gt;pConf);
		if(inst-&gt;cCCEscapeChar == '\0')
			inst-&gt;cCCEscapeChar = glbl.GetParserControlCharacterEscapePrefix(modConf-&gt;pConf);

		/* Determine tab representation. Possible options:
		 *		&quot;#011&quot;	escape on, escapetabs on, no change to prefix (default)
		 *		&quot;?011&quot;	prefix changed in config
		 *		&quot;\\t&quot;	C style
		 *		'\t' 	escape turned off
		 */
		if (inst-&gt;bEscapeCCOnRcv &amp;&amp; inst-&gt;bEscapeTab) {
			if (inst-&gt;bParserEscapeCCCStyle) {
				strncpy(inst-&gt;tabRepresentation, &quot;\\t&quot;, 5);
			} else {
				strncpy(inst-&gt;tabRepresentation, &quot;#011&quot;, 5);
				inst-&gt;tabRepresentation[0] = inst-&gt;cCCEscapeChar;
			}
		} else {
			strncpy(inst-&gt;tabRepresentation, &quot;\t&quot;, 5);
		}
		inst-&gt;tabLength=strlen(inst-&gt;tabRepresentation);
		/* TODO: This debug message would be more useful if it told which Snare instance! */
		dbgprintf(&quot;pmsnare: Snare parser will treat '%s' as tab.\n&quot;, inst-&gt;tabRepresentation);
	}

	assert(pModConf == modConf);
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf

BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = modInstances-&gt;root ; inst != NULL ; ) {
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(modInstances);
ENDfreeCnf

BEGINparse2
	uchar *p2parse;
	int lenMsg;
	int snaremessage; /* 0 means not a snare message, otherwise it's the index of the tab after the tag  */

CODESTARTparse2
	dbgprintf(&quot;Message will now be parsed by fix Snare parser.\n&quot;);
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);

	/* check if this message is of the type we handle in this (very limited) parser
	 *
	 * - Find out if the first separator is a tab.
	 * - If it is, see if the second word is one of our expected tags.
	 *   - If so, flag as Snare and replace the first tab with space so that
	 *     hostname and syslog tag are going to be parsed properly
	 *   - Else not a snare message, abort.
	 * - Else assume valid 3164 timestamp, move over to the syslog tag.
	 * - See if syslog header is followed by tab and one of our expected tags.
	 *   - If so, flag as Snare.
	 * - See if either type flagged as Snare.
	 *   - If so, replace the tab with a space so that it will be parsed properly.
	 */

	snaremessage=0;
	/* note: offAfterPRI is already the number of PRI chars (do not add one!) */
	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
	/* point to start of text, after PRI */
	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI;
	dbgprintf(&quot;pmsnare: msg to look at: [%d]'%s'\n&quot;, lenMsg, p2parse);
	if((unsigned) lenMsg &lt; 30) {
		/* too short, can not be &quot;our&quot; message */
		dbgprintf(&quot;pmsnare: Message is too short to be Snare!\n&quot;);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}

	/* Find the first separator and check if it's a tab. */
	while(lenMsg &amp;&amp; *p2parse != ' ' &amp;&amp; *p2parse != '\t' &amp;&amp; *p2parse != pInst-&gt;tabRepresentation[0]) {
		--lenMsg;
		++p2parse;
	}
	if ((lenMsg &gt; pInst-&gt;tabLength) &amp;&amp; (strncasecmp((char *)p2parse, pInst-&gt;tabRepresentation,
			pInst-&gt;tabLength) == 0)) {
		dbgprintf(&quot;pmsnare: tab separated message\n&quot;);
		dbgprintf(&quot;pmsnare: tab [%d]'%s'	msg at the first separator: [%d]'%s'\n&quot;,
			pInst-&gt;tabLength, pInst-&gt;tabRepresentation, lenMsg, p2parse);

		/* Look for the Snare tag. */
		if(strncasecmp((char*)(p2parse + pInst-&gt;tabLength), &quot;MSWinEventLog&quot;, 13) == 0) {
			dbgprintf(&quot;Found a non-syslog Windows Snare message.\n&quot;);
			snaremessage = p2parse - pMsg-&gt;pszRawMsg + pInst-&gt;tabLength + 13;
		}
		else if(strncasecmp((char*) (p2parse + pInst-&gt;tabLength), &quot;LinuxKAudit&quot;, 11) == 0) {
			dbgprintf(&quot;Found a non-syslog Linux Snare message.\n&quot;);
			snaremessage = p2parse - pMsg-&gt;pszRawMsg + pInst-&gt;tabLength + 11;
		} else {
			/* Tab-separated but no Snare tag-&gt; can't be Snare! */
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}

		/* This is a non-syslog Snare message. Example:
		 * other.lab.home	MSWinEventLog	1	Security	606129	Wed May 17 02:25:10 2017
		 */

		/* Remove the tab between the hostname and Snare tag. */
		*p2parse = ' ';
		p2parse++;
		lenMsg--;
		lenMsg -= (pInst-&gt;tabLength-1); /* size of tab goes from tabLength to 1, so shorten
						the message by the difference */
		memmove(p2parse, p2parse+(pInst-&gt;tabLength-1), lenMsg);
		/* move the message portion up to overwrite the tab */
		*(p2parse + lenMsg)	= '\0';
		pMsg-&gt;iLenRawMsg -= (pInst-&gt;tabLength-1);
		pMsg-&gt;iLenMSG -= (pInst-&gt;tabLength-1);
		snaremessage -= (pInst-&gt;tabLength-1);
	} else {
		/* The first separator is not a tab. Look for a syslog Snare message. Example:
		 * &lt;14&gt;May 17 02:25:10 syslog.lab.home MSWinEventLog     1    Security  606129
			Wed May 17 02:25:10 2017
		 */

		/* go back to the beginning of the message */
		lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
		/* offAfterPRI is already the number of PRI chars (do not add one!) */
		p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI;

		/* skip over timestamp and space (15 chars + space). */
		lenMsg -=16;
		p2parse +=16;
		/* skip over what should be the hostname and space */
		while(lenMsg &amp;&amp; *p2parse != ' ') {
			--lenMsg;
			++p2parse;
		}
		if (lenMsg){
			--lenMsg;
			++p2parse;
		}
		dbgprintf(&quot;pmsnare: tab [%d]'%s'	msg after the timestamp and hostname: [%d]'%s'\n&quot;,
				pInst-&gt;tabLength,pInst-&gt;tabRepresentation,lenMsg, p2parse);

		/* Look for the Snare tag. */
		if(lenMsg &gt; 13 &amp;&amp; strncasecmp((char*) p2parse, &quot;MSWinEventLog&quot;, 13) == 0) {
			dbgprintf(&quot;Found a syslog Windows Snare message.\n&quot;);
			snaremessage = p2parse - pMsg-&gt;pszRawMsg + 13;
		}
		else if(lenMsg &gt; 11 &amp;&amp; strncasecmp((char*) p2parse, &quot;LinuxKAudit&quot;, 11) == 0) {
			dbgprintf(&quot;pmsnare: Found a syslog Linux Snare message.\n&quot;);
			snaremessage = p2parse - pMsg-&gt;pszRawMsg + 11;
		}
	}

	if(snaremessage) {
		/* Skip to the end of the tag. */
		p2parse = pMsg-&gt;pszRawMsg + snaremessage;
		lenMsg = pMsg-&gt;iLenRawMsg - snaremessage;

		/* Remove the tab after the tag. */
		*p2parse = ' ';
		p2parse++;
		lenMsg--;
		lenMsg -= (pInst-&gt;tabLength-1); /* size of tab goes from tabLength to 1, so shorten
						the message by the difference */
		memmove(p2parse, p2parse+(pInst-&gt;tabLength-1), lenMsg);
		/* move the message portion up to overwrite the tab */
		*(p2parse + lenMsg) = '\0';
		pMsg-&gt;iLenRawMsg -= (pInst-&gt;tabLength-1);
		pMsg-&gt;iLenMSG -= (pInst-&gt;tabLength-1);

		DBGPRINTF(&quot;pmsnare: new message: [%d]'%s'\n&quot;, lenMsg, pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI);
	}

	ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);

finalize_it:
ENDparse2

BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_MOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF(&quot;snare parser init called, compiled with version %s\n&quot;, VERSION);
	bParseHOSTNAMEandTAG = glbl.GetParseHOSTNAMEandTAG(loadConf);
	/* cache value, is set only during rsyslogd option processing */
ENDmodInit

/* vim:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfile-hardened.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omfile.c
 * This is the implementation of the build-in file output module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-07-21 by RGerhards (extracted from syslogd.c, which
 * at the time of the fork from sysklogd was under BSD license)
 *
 * A large re-write of this file was done in June, 2009. The focus was
 * to introduce many more features (like zipped writing), clean up the code
 * and make it more reliable. In short, that rewrite tries to provide a new
 * solid basis for the next three to five years to come. During it, bugs
 * may have been introduced ;) -- rgerhards, 2009-06-04
 *
 * Note that as of 2010-02-28 this module does no longer handle
 * pipes. These have been moved to ompipe, to reduced the entanglement
 * between the two different functionalities. -- rgerhards
 *
 * Copyright 2007-2017 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &quot;glbl.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;libgen.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/statvfs.h&gt;
#ifdef HAVE_ATOMIC_BUILTINS
#	include &lt;pthread.h&gt;
#endif


#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;outchannel.h&quot;
#include &quot;omfile.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;stream.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;atomic.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;sigprov.h&quot;
#include &quot;cryprov.h&quot;
#include &quot;parserif.h&quot;
#include &quot;janitor.h&quot;
#include &quot;rsconf.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omfile&quot;)

/* forward definitions */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* internal structures
 */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(strm)
DEFobjCurrIf(statsobj)

/* for our current LRU mechanism, we need a monotonically increasing counters. We use
 * it much like a &quot;Lamport logical clock&quot;: we do not need the actual time, we just need
 * to know the sequence in which files were accessed. So we use a simple counter to
 * create that sequence. We use an unsigned 64 bit value which is extremely unlike to
 * wrap within the lifetime of a process. If we process 1,000,000 file writes per
 * second, the process could still exist over 500,000 years before a wrap to 0 happens.
 * That should be sufficient (and even than, there would no really bad effect ;)).
 * The variable below is the global counter/clock.
 */
#if HAVE_ATOMIC_BUILTINS64
static uint64 clockFileAccess = 0;
#else
static unsigned clockFileAccess = 0;
#endif
/* and the &quot;tick&quot; function */
#ifndef HAVE_ATOMIC_BUILTINS
static pthread_mutex_t mutClock;
#endif
static uint64
getClockFileAccess(void)
{
#if HAVE_ATOMIC_BUILTINS64
	return ATOMIC_INC_AND_FETCH_uint64(&amp;clockFileAccess, &amp;mutClock);
#else
	return ATOMIC_INC_AND_FETCH_unsigned(&amp;clockFileAccess, &amp;mutClock);
#endif
}


/* The following structure is a dynafile name cache entry.
 */
struct s_dynaFileCacheEntry {
	uchar *pName;		/* name currently open, if dynamic name */
	strm_t	*pStrm;		/* our output stream */
	void	*sigprovFileData;	/* opaque data ptr for provider use */
	uint64	clkTickAccessed;/* for LRU - based on clockFileAccess */
	short nInactive;	/* number of minutes not writen - for close timeout */
};
typedef struct s_dynaFileCacheEntry dynaFileCacheEntry;


#define IOBUF_DFLT_SIZE 4096	/* default size for io buffers */
#define FLUSH_INTRVL_DFLT 1 	/* default buffer flush interval (in seconds) */
#define USE_ASYNCWRITER_DFLT 0 	/* default buffer use async writer */
#define FLUSHONTX_DFLT 1 	/* default for flush on TX end */

typedef struct _instanceData {
	pthread_mutex_t mutWrite; /* guard against multiple instances writing to single file */
	uchar	*fname;	/* file or template name (display only) */
	uchar 	*tplName;	/* name of assigned template */
	strm_t	*pStrm;		/* our output stream */
	short nInactive;	/* number of minutes not writen (STATIC files only) */
	char	bDynamicName;	/* 0 - static name, 1 - dynamic name (with properties) */
	int	fCreateMode;	/* file creation mode for open() */
	int	fDirCreateMode;	/* creation mode for mkdir() */
	int	bCreateDirs;	/* auto-create directories? */
	int	bSyncFile;	/* should the file by sync()'ed? 1- yes, 0- no */
	uint8_t iNumTpls;	/* number of tpls we use */
	uid_t	fileUID;	/* IDs for creation */
	uid_t	dirUID;
	gid_t	fileGID;
	gid_t	dirGID;
	int	bFailOnChown;	/* fail creation if chown fails? */
	uchar 	*sigprovName;	/* signature provider */
	uchar 	*sigprovNameFull;/* full internal signature provider name */
	sigprov_if_t sigprov;	/* ptr to signature provider interface */
	void	*sigprovData;	/* opaque data ptr for provider use */
	void 	*sigprovFileData;/* opaque data ptr for file instance */
	sbool	useSigprov;	/* quicker than checkig ptr (1 vs 8 bytes!) */
	uchar 	*cryprovName;	/* crypto provider */
	uchar 	*cryprovNameFull;/* full internal crypto provider name */
	void	*cryprovData;	/* opaque data ptr for provider use */
	cryprov_if_t cryprov;	/* ptr to crypto provider interface */
	sbool	useCryprov;	/* quicker than checkig ptr (1 vs 8 bytes!) */
	int	iCurrElt;	/* currently active cache element (-1 = none) */
	uint	iCurrCacheSize;	/* currently cache size (1-based) */
	uint	iDynaFileCacheSize; /* size of file handle cache */
	/* The cache is implemented as an array. An empty element is indicated
	 * by a NULL pointer. Memory is allocated as needed. The following
	 * pointer points to the overall structure.
	 */
	dynaFileCacheEntry **dynCache;
	off_t	iSizeLimit;		/* file size limit, 0 = no limit */
	uchar	*pszSizeLimitCmd;	/* command to carry out when size limit is reached */
	int 	iZipLevel;		/* zip mode to use for this selector */
	uint	iIOBufSize;		/* size of associated io buffer */
	int	iFlushInterval;		/* how fast flush buffer on inactivity? */
	short	iCloseTimeout;		/* after how many *minutes* shall the file be closed if inactive? */
	sbool	bFlushOnTXEnd;		/* flush write buffers when transaction has ended? */
	sbool	bUseAsyncWriter;	/* use async stream writer? */
	sbool	bVeryRobustZip;
	statsobj_t *stats;		/* dynafile, primarily cache stats */
	STATSCOUNTER_DEF(ctrRequests, mutCtrRequests);
	STATSCOUNTER_DEF(ctrLevel0, mutCtrLevel0);
	STATSCOUNTER_DEF(ctrEvict, mutCtrEvict);
	STATSCOUNTER_DEF(ctrMiss, mutCtrMiss);
	STATSCOUNTER_DEF(ctrMax, mutCtrMax);
	STATSCOUNTER_DEF(ctrCloseTimeouts, mutCtrCloseTimeouts);
	char janitorID[128];		/* holds ID for janitor calls */
} instanceData;


typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;


typedef struct configSettings_s {
	uint iDynaFileCacheSize; /* max cache for dynamic files */
	int fCreateMode; /* mode to use when creating files */
	int fDirCreateMode; /* mode to use when creating files */
	int	bFailOnChown;	/* fail if chown fails? */
	uid_t	fileUID;	/* UID to be used for newly created files */
	uid_t	fileGID;	/* GID to be used for newly created files */
	uid_t	dirUID;		/* UID to be used for newly created directories */
	uid_t	dirGID;		/* GID to be used for newly created directories */
	int	bCreateDirs;/* auto-create directories for dynaFiles: 0 - no, 1 - yes */
	int	bEnableSync;/* enable syncing of files (no dash in front of pathname in conf): 0 - no, 1 - yes */
	int	iZipLevel;	/* zip compression mode (0..9 as usual) */
	sbool	bFlushOnTXEnd;/* flush write buffers when transaction has ended? */
	int64	iIOBufSize;	/* size of an io buffer */
	int	iFlushInterval; 	/* how often flush the output buffer on inactivity? */
	int	bUseAsyncWriter;	/* should we enable asynchronous writing? */
	EMPTY_STRUCT
} configSettings_t;
static configSettings_t cs;
uchar	*pszFileDfltTplName; /* name of the default template to use */

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	uchar 	*tplName;	/* default template */
	int fCreateMode; /* default mode to use when creating files */
	int fDirCreateMode; /* default mode to use when creating files */
	uid_t fileUID;	/* default IDs for creation */
	uid_t dirUID;
	gid_t fileGID;
	gid_t dirGID;
	int bDynafileDoNotSuspend;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */

/* tables for interfacing with the v6 config system */
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;dircreatemode&quot;, eCmdHdlrFileCreateMode, 0 },
	{ &quot;filecreatemode&quot;, eCmdHdlrFileCreateMode, 0 },
	{ &quot;dirowner&quot;, eCmdHdlrUID, 0 },
	{ &quot;dirownernum&quot;, eCmdHdlrInt, 0 },
<A NAME="1"></A>	{ &quot;dirgroup&quot;, eCmdHdlrGID, 0 },
	{ &quot;dirgroupnum&quot;, eCmdHdlrInt, 0 },
	{ &quot;fileowner&quot;, eCmdHdlrUID, 0 },
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2227-0.html#1',2,'match2227-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;fileownernum&quot;, eCmdHdlrInt, 0 },
	{ &quot;filegroup&quot;, eCmdHdlrGID, 0 },
	{ &quot;dynafile.donotsuspend&quot;, eCmdHdlrBinary, 0 },
	{ &quot;filegroupnum&quot;, eCmdHdlrInt, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</B></FONT>

/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;dynafilecachesize&quot;, eCmdHdlrInt, 0 }, /* legacy: dynafilecachesize */
	{ &quot;ziplevel&quot;, eCmdHdlrInt, 0 }, /* legacy: omfileziplevel */
	{ &quot;flushinterval&quot;, eCmdHdlrInt, 0 }, /* legacy: omfileflushinterval */
	{ &quot;asyncwriting&quot;, eCmdHdlrBinary, 0 }, /* legacy: omfileasyncwriting */
	{ &quot;veryrobustzip&quot;, eCmdHdlrBinary, 0 },
	{ &quot;flushontxend&quot;, eCmdHdlrBinary, 0 }, /* legacy: omfileflushontxend */
	{ &quot;iobuffersize&quot;, eCmdHdlrSize, 0 }, /* legacy: omfileiobuffersize */
	{ &quot;dirowner&quot;, eCmdHdlrUID, 0 }, /* legacy: dirowner */
	{ &quot;dirownernum&quot;, eCmdHdlrInt, 0 }, /* legacy: dirownernum */
	{ &quot;dirgroup&quot;, eCmdHdlrGID, 0 }, /* legacy: dirgroup */
	{ &quot;dirgroupnum&quot;, eCmdHdlrInt, 0 }, /* legacy: dirgroupnum */
	{ &quot;fileowner&quot;, eCmdHdlrUID, 0 }, /* legacy: fileowner */
	{ &quot;fileownernum&quot;, eCmdHdlrInt, 0 }, /* legacy: fileownernum */
	{ &quot;filegroup&quot;, eCmdHdlrGID, 0 }, /* legacy: filegroup */
	{ &quot;filegroupnum&quot;, eCmdHdlrInt, 0 }, /* legacy: filegroupnum */
	{ &quot;dircreatemode&quot;, eCmdHdlrFileCreateMode, 0 }, /* legacy: dircreatemode */
	{ &quot;filecreatemode&quot;, eCmdHdlrFileCreateMode, 0 }, /* legacy: filecreatemode */
	{ &quot;failonchownfailure&quot;, eCmdHdlrBinary, 0 }, /* legacy: failonchownfailure */
	{ &quot;createdirs&quot;, eCmdHdlrBinary, 0 }, /* legacy: createdirs */
	{ &quot;sync&quot;, eCmdHdlrBinary, 0 }, /* legacy: actionfileenablesync */
	{ &quot;file&quot;, eCmdHdlrString, 0 },     /* either &quot;file&quot; or ... */
	{ &quot;dynafile&quot;, eCmdHdlrString, 0 }, /* &quot;dynafile&quot; MUST be present */
	{ &quot;sig.provider&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;cry.provider&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;closetimeout&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};


/* this function gets the default template. It coordinates action between
 * old-style and new-style configuration parts.
 */
static uchar*
getDfltTpl(void)
{
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
		return loadModConf-&gt;tplName;
	else if(pszFileDfltTplName == NULL)
		return (uchar*)&quot;RSYSLOG_FileFormat&quot;;
	else
		return pszFileDfltTplName;
}


BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	pszFileDfltTplName = NULL; /* make sure this can be free'ed! */
	iRet = resetConfigVariables(NULL, NULL); /* params are dummies */
ENDinitConfVars

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	if(pData-&gt;bDynamicName) {
		dbgprintf(&quot;[dynamic]\n&quot;);
	} else { /* regular file */
		dbgprintf(&quot;%s%s\n&quot;, pData-&gt;fname,
			  (pData-&gt;pStrm == NULL) ? &quot; (closed)&quot; : &quot;&quot;);
	}

	dbgprintf(&quot;\ttemplate='%s'\n&quot;, pData-&gt;fname);
	dbgprintf(&quot;\tuse async writer=%d\n&quot;, pData-&gt;bUseAsyncWriter);
	dbgprintf(&quot;\tflush on TX end=%d\n&quot;, pData-&gt;bFlushOnTXEnd);
	dbgprintf(&quot;\tflush interval=%d\n&quot;, pData-&gt;iFlushInterval);
	dbgprintf(&quot;\tfile cache size=%d\n&quot;, pData-&gt;iDynaFileCacheSize);
	dbgprintf(&quot;\tcreate directories: %s\n&quot;, pData-&gt;bCreateDirs ? &quot;on&quot; : &quot;off&quot;);
	dbgprintf(&quot;\tvery robust zip: %s\n&quot;, pData-&gt;bCreateDirs ? &quot;on&quot; : &quot;off&quot;);
	dbgprintf(&quot;\tfile owner %d, group %d\n&quot;, (int) pData-&gt;fileUID, (int) pData-&gt;fileGID);
	dbgprintf(&quot;\tdirectory owner %d, group %d\n&quot;, (int) pData-&gt;dirUID, (int) pData-&gt;dirGID);
	dbgprintf(&quot;\tdir create mode 0%3.3o, file create mode 0%3.3o\n&quot;,
		  pData-&gt;fDirCreateMode, pData-&gt;fCreateMode);
	dbgprintf(&quot;\tfail if owner/group can not be set: %s\n&quot;, pData-&gt;bFailOnChown ? &quot;yes&quot; : &quot;no&quot;);
ENDdbgPrintInstInfo



/* set the default template to be used
 * This is a module-global parameter, and as such needs special handling. It needs to
 * be coordinated with values set via the v2 config system (rsyslog v6+). What we do
 * is we do not permit this directive after the v2 config system has been used to set
 * the parameter.
 */
static rsRetVal
setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
{
	DEFiRet;

	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
		free(newVal);
		parser_errmsg(&quot;omfile: default template already set via module &quot;
			&quot;global parameter - can no longer be changed&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	free(pszFileDfltTplName);
	pszFileDfltTplName = newVal;
finalize_it:
	RETiRet;
}


/* set the dynaFile cache size. Does some limit checking.
 * rgerhards, 2007-07-31
 */
static rsRetVal setDynaFileCacheSize(void __attribute__((unused)) *pVal, int iNewVal)
{
	DEFiRet;

	if(iNewVal &lt; 1) {
		errno = 0;
		parser_errmsg(
		         &quot;DynaFileCacheSize must be greater 0 (%d given), changed to 1.&quot;, iNewVal);
		iRet = RS_RET_VAL_OUT_OF_RANGE;
		iNewVal = 1;
	} else if(iNewVal &gt; 1000) {
		errno = 0;
		parser_errmsg(
		         &quot;DynaFileCacheSize maximum is 1,000 (%d given), changed to 1,000.&quot;, iNewVal);
		iRet = RS_RET_VAL_OUT_OF_RANGE;
		iNewVal = 1000;
	}

	cs.iDynaFileCacheSize = iNewVal;
	DBGPRINTF(&quot;DynaFileCacheSize changed to %d.\n&quot;, iNewVal);

	RETiRet;
}


/* Helper to cfline(). Parses a output channel name up until the first
 * comma and then looks for the template specifier. Tries
 * to find that template. Maps the output channel to the
 * proper filed structure settings. Everything is stored in the
 * filed struct. Over time, the dependency on filed might be
 * removed.
 * rgerhards 2005-06-21
 */
static rsRetVal cflineParseOutchannel(instanceData *pData, uchar* p, omodStringRequest_t *pOMSR,
	int iEntry, int iTplOpts)
{
	DEFiRet;
	size_t i;
	struct outchannel *pOch;
	char szBuf[128];	/* should be more than sufficient */

	++p; /* skip '$' */
	i = 0;
	/* get outchannel name */
	while(*p &amp;&amp; *p != ';' &amp;&amp; *p != ' ' &amp;&amp;
	      i &lt; (sizeof(szBuf) - 1) ) {
	      szBuf[i++] = *p++;
	}
	szBuf[i] = '\0';

	/* got the name, now look up the channel... */
	pOch = ochFind(szBuf, i);

	if(pOch == NULL) {
		parser_errmsg(
			 &quot;outchannel '%s' not found - ignoring action line&quot;,
			 szBuf);
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}

	/* check if there is a file name in the outchannel... */
	if(pOch-&gt;pszFileTemplate == NULL) {
		parser_errmsg(
			 &quot;outchannel '%s' has no file name template - ignoring action line&quot;,
			 szBuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* OK, we finally got a correct template. So let's use it... */
	pData-&gt;fname = ustrdup(pOch-&gt;pszFileTemplate);
	pData-&gt;iSizeLimit = pOch-&gt;uSizeLimit;
	/* WARNING: It is dangerous &quot;just&quot; to pass the pointer. As we
	 * never rebuild the output channel description, this is acceptable here.
	 */
	pData-&gt;pszSizeLimitCmd = pOch-&gt;cmdOnSizeLimit;

	iRet = cflineParseTemplateName(&amp;p, pOMSR, iEntry, iTplOpts, getDfltTpl());

finalize_it:
	RETiRet;
}


/* This function deletes an entry from the dynamic file name
 * cache. A pointer to the cache must be passed in as well
 * as the index of the to-be-deleted entry. This index may
 * point to an unallocated entry, in whcih case the
 * function immediately returns. Parameter bFreeEntry is 1
 * if the entry should be free()ed and 0 if not.
 */
static rsRetVal
dynaFileDelCacheEntry(instanceData *__restrict__ const pData, const int iEntry, const int bFreeEntry)
{
	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
	DEFiRet;
	assert(pCache != NULL);

	if(pCache[iEntry] == NULL)
		FINALIZE;

	DBGPRINTF(&quot;Removing entry %d for file '%s' from dynaCache.\n&quot;, iEntry,
		pCache[iEntry]-&gt;pName == NULL ? UCHAR_CONSTANT(&quot;[OPEN FAILED]&quot;) : pCache[iEntry]-&gt;pName);

	if(pCache[iEntry]-&gt;pName != NULL) {
		free(pCache[iEntry]-&gt;pName);
		pCache[iEntry]-&gt;pName = NULL;
	}

	if(pCache[iEntry]-&gt;pStrm != NULL) {
		strm.Destruct(&amp;pCache[iEntry]-&gt;pStrm);
		if(pData-&gt;useSigprov) {
			pData-&gt;sigprov.OnFileClose(pCache[iEntry]-&gt;sigprovFileData);
			pCache[iEntry]-&gt;sigprovFileData = NULL;
		}
	}

	if(bFreeEntry) {
		free(pCache[iEntry]);
		pCache[iEntry] = NULL;
	}

finalize_it:
	RETiRet;
}


/* This function frees all dynamic file name cache entries and closes the
 * relevant files. Part of Shutdown and HUP processing.
 * rgerhards, 2008-10-23
 */
static void
dynaFileFreeCacheEntries(instanceData *__restrict__ const pData)
{
	register uint i;
	assert(pData != NULL);

	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		dynaFileDelCacheEntry(pData, i, 1);
	}
	pData-&gt;iCurrElt = -1; /* invalidate current element */
}


/* This function frees the dynamic file name cache.
 */
static void dynaFileFreeCache(instanceData *__restrict__ const pData)
{
	assert(pData != NULL);

	dynaFileFreeCacheEntries(pData);
	if(pData-&gt;dynCache != NULL)
		free(pData-&gt;dynCache);
}


/* close current file */
static rsRetVal
closeFile(instanceData *__restrict__ const pData)
{
	DEFiRet;
	if(pData-&gt;useSigprov) {
		pData-&gt;sigprov.OnFileClose(pData-&gt;sigprovFileData);
		pData-&gt;sigprovFileData = NULL;
	}
	strm.Destruct(&amp;pData-&gt;pStrm);
	RETiRet;
}


/* This prepares the signature provider to process a file */
static rsRetVal
sigprovPrepare(instanceData *__restrict__ const pData, uchar *__restrict__ const fn)
{
	DEFiRet;
	pData-&gt;sigprov.OnFileOpen(pData-&gt;sigprovData, fn, &amp;pData-&gt;sigprovFileData);
	RETiRet;
}

/* This is now shared code for all types of files. It simply prepares
 * file access, which, among others, means the the file wil be opened
 * and any directories in between will be created (based on config, of
 * course). -- rgerhards, 2008-10-22
 * changed to iRet interface - 2009-03-19
 */
static rsRetVal
prepareFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
{
	int fd;
	char errStr[1024]; /* buffer for strerr() */
	DEFiRet;

	pData-&gt;pStrm = NULL;
	if(access((char*)newFileName, F_OK) != 0) {
		/* file does not exist, create it (and eventually parent directories */
		if(pData-&gt;bCreateDirs) {
			/* We first need to create parent dirs if they are missing.
			 * We do not report any errors here ourselfs but let the code
			 * fall through to error handler below.
			 */
			if(makeFileParentDirs(newFileName, ustrlen(newFileName),
			     pData-&gt;fDirCreateMode, pData-&gt;dirUID,
			     pData-&gt;dirGID, pData-&gt;bFailOnChown) != 0) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				parser_errmsg( &quot;omfile: creating parent &quot;
					&quot;directories for file  '%s' failed: %s&quot;,
					newFileName, errStr);
			     	ABORT_FINALIZE(RS_RET_ERR); /* we give up */
			}
		}
		/* no matter if we needed to create directories or not, we now try to create
		 * the file. -- rgerhards, 2008-12-18 (based on patch from William Tisater)
		 */
		fd = open((char*) newFileName, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY|O_CLOEXEC,
				pData-&gt;fCreateMode);
		if(fd != -1) {
			/* check and set uid/gid */
			if(pData-&gt;fileUID != (uid_t)-1 || pData-&gt;fileGID != (gid_t) -1) {
				/* we need to set owner/group */
				if(fchown(fd, pData-&gt;fileUID, pData-&gt;fileGID) != 0) {
					rs_strerror_r(errno, errStr, sizeof(errStr));
					parser_errmsg(
						&quot;omfile: chown for file '%s' failed: %s&quot;,
						newFileName, errStr);
					if(pData-&gt;bFailOnChown) {
						close(fd);
						ABORT_FINALIZE(RS_RET_ERR); /* we give up */
					}
					/* we will silently ignore the chown() failure
					 * if configured to do so.
					 */
				}
			}
			close(fd); /* close again, as we need a stream further on */
		}
		else {
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

	/* the copies below are clumpsy, but there is no way around given the
	 * anomalies in dirname() and basename() [they MODIFY the provided buffer...]
	 */
	uchar szNameBuf[MAXFNAME+1];
	uchar szDirName[MAXFNAME+1];
	uchar szBaseName[MAXFNAME+1];
	ustrncpy(szNameBuf, newFileName, MAXFNAME);
	szNameBuf[MAXFNAME] = '\0';
	ustrncpy(szDirName, (uchar*)dirname((char*)szNameBuf), MAXFNAME);
	szDirName[MAXFNAME] = '\0';
	ustrncpy(szNameBuf, newFileName, MAXFNAME);
	szNameBuf[MAXFNAME] = '\0';
	ustrncpy(szBaseName, (uchar*)basename((char*)szNameBuf), MAXFNAME);
	szBaseName[MAXFNAME] = '\0';

	CHKiRet(strm.Construct(&amp;pData-&gt;pStrm));
	CHKiRet(strm.SetFName(pData-&gt;pStrm, szBaseName, ustrlen(szBaseName)));
	CHKiRet(strm.SetDir(pData-&gt;pStrm, szDirName, ustrlen(szDirName)));
	CHKiRet(strm.SetiZipLevel(pData-&gt;pStrm, pData-&gt;iZipLevel));
	CHKiRet(strm.SetbVeryReliableZip(pData-&gt;pStrm, pData-&gt;bVeryRobustZip));
	CHKiRet(strm.SetsIOBufSize(pData-&gt;pStrm, (size_t) pData-&gt;iIOBufSize));
	CHKiRet(strm.SettOperationsMode(pData-&gt;pStrm, STREAMMODE_WRITE_APPEND));
	CHKiRet(strm.SettOpenMode(pData-&gt;pStrm, cs.fCreateMode));
	CHKiRet(strm.SetbSync(pData-&gt;pStrm, pData-&gt;bSyncFile));
	CHKiRet(strm.SetsType(pData-&gt;pStrm, STREAMTYPE_FILE_SINGLE));
	CHKiRet(strm.SetiSizeLimit(pData-&gt;pStrm, pData-&gt;iSizeLimit));
	if(pData-&gt;useCryprov) {
		CHKiRet(strm.Setcryprov(pData-&gt;pStrm, &amp;pData-&gt;cryprov));
		CHKiRet(strm.SetcryprovData(pData-&gt;pStrm, pData-&gt;cryprovData));
	}
	/* set the flush interval only if we actually use it - otherwise it will activate
	 * async processing, which is a real performance waste if we do not do buffered
	 * writes! -- rgerhards, 2009-07-06
	 */
	if(pData-&gt;bUseAsyncWriter)
		CHKiRet(strm.SetiFlushInterval(pData-&gt;pStrm, pData-&gt;iFlushInterval));
	if(pData-&gt;pszSizeLimitCmd != NULL)
		CHKiRet(strm.SetpszSizeLimitCmd(pData-&gt;pStrm, ustrdup(pData-&gt;pszSizeLimitCmd)));
	CHKiRet(strm.ConstructFinalize(pData-&gt;pStrm));

	if(pData-&gt;useSigprov)
		sigprovPrepare(pData, szNameBuf);

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pData-&gt;pStrm != NULL) {
			closeFile(pData);
		}
	}
	RETiRet;
}

// &lt;kortemik date=&quot;2018-02-20&quot;&gt;
/* verify enough we have space left for writes */
static rsRetVal
fsCheck(instanceData *__restrict__ const pData, const uchar *__restrict__ const fileName)
{
	DEFiRet;
	struct statvfs stat;
	char *pathcopy;
	const char *path;

	pathcopy = strdup((char*)fileName);
	path = dirname(pathcopy);

	if (statvfs(path, &amp;stat) != 0) {
		iRet = RS_RET_FILE_NO_STAT;
		LogError(0, iRet, &quot;could not stat %s&quot;, path);
		FINALIZE;
	}

	/* check if we have space available for all buffers to be flushed and for
	 * a maximum length message, perhaps current msg size would be enough */
	if (stat.f_bsize * stat.f_bavail &lt;
		pData-&gt;iIOBufSize * pData-&gt;iDynaFileCacheSize + (uint)(glbl.GetMaxLine(runModConf-&gt;pConf)))
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, &quot;too few available blocks in %s&quot;, path);
			FINALIZE;
		}
	/* there must be enough inodes left, one is left for administrative purposes
	 * check is not done if file system reports 0 total inodes, such as btrfs */
	if (stat.f_favail &lt; 2 &amp;&amp; stat.f_files &gt; 0)
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, &quot;too few available inodes in %s&quot;, path);
			FINALIZE;
		}

	/* file system must not be read only */
	if (stat.f_flag == ST_RDONLY)
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, &quot;file-system is read-only in %s&quot;, path);
			FINALIZE;
		}

	iRet = RS_RET_OK;

finalize_it:
	if (pathcopy != NULL)
		free(pathcopy);
	RETiRet;
}
// &lt;/kortemik&gt;

/* This function handles dynamic file names. It checks if the
 * requested file name is already open and, if not, does everything
 * needed to switch to the it.
 * Function returns 0 if all went well and non-zero otherwise.
 * On successful return pData-&gt;fd must point to the correct file to
 * be written.
 * This is a helper to writeFile(). rgerhards, 2007-07-03
 */
static rsRetVal
prepareDynFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
{
	uint64 ctOldest; /* &quot;timestamp&quot; of oldest element */
	int iOldest;
	uint i;
	int iFirstFree;
	rsRetVal localRet;
	dynaFileCacheEntry **pCache;
	DEFiRet;

	assert(pData != NULL);
	assert(newFileName != NULL);

	pCache = pData-&gt;dynCache;

	/* first check, if we still have the current file */
	if(   (pData-&gt;iCurrElt != -1)
	   &amp;&amp; !ustrcmp(newFileName, pCache[pData-&gt;iCurrElt]-&gt;pName)) {
		CHKiRet(fsCheck(pData, newFileName));

	   	/* great, we are all set */
		pCache[pData-&gt;iCurrElt]-&gt;clkTickAccessed = getClockFileAccess();
		STATSCOUNTER_INC(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
		/* LRU needs only a strictly monotonically increasing counter, so such a one could do */
		FINALIZE;
	}

	/* ok, no luck. Now let's search the table if we find a matching spot.
	 * While doing so, we also prepare for creation of a new one.
	 */
	pData-&gt;iCurrElt = -1;	/* invalid current element pointer */
	iFirstFree = -1; /* not yet found */
	iOldest = 0; /* we assume the first element to be the oldest - that will change as we loop */
	ctOldest = getClockFileAccess(); /* there must always be an older one */
	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		if(pCache[i] == NULL || pCache[i]-&gt;pName == NULL) {
			if(iFirstFree == -1)
				iFirstFree = i;
		} else { /* got an element, let's see if it matches */
			if(!ustrcmp(newFileName, pCache[i]-&gt;pName)) {
				CHKiRet(fsCheck(pData, newFileName));

				/* we found our element! */
				pData-&gt;pStrm = pCache[i]-&gt;pStrm;
				if(pData-&gt;useSigprov)
					pData-&gt;sigprovFileData = pCache[i]-&gt;sigprovFileData;
				pData-&gt;iCurrElt = i;
				pCache[i]-&gt;clkTickAccessed = getClockFileAccess(); /* update &quot;timestamp&quot; for LRU */
				FINALIZE;
			}
			/* did not find it - so lets keep track of the counters for LRU */
			if(pCache[i]-&gt;clkTickAccessed &lt; ctOldest) {
				ctOldest = pCache[i]-&gt;clkTickAccessed;
				iOldest = i;
				}
		}
	}

	/* we have not found an entry */
	STATSCOUNTER_INC(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);

	/* similarly, we need to set the current pStrm to NULL, because otherwise, if prepareFile() fails,
	 * we may end up using an old stream. This bug depends on how exactly prepareFile fails,
	 * but it could be triggered in the common case of a failed open() system call.
	 * rgerhards, 2010-03-22
	 */
	pData-&gt;pStrm = NULL, pData-&gt;sigprovFileData = NULL;

	if(iFirstFree == -1 &amp;&amp; (pData-&gt;iCurrCacheSize &lt; pData-&gt;iDynaFileCacheSize)) {
		/* there is space left, so set it to that index */
		iFirstFree = pData-&gt;iCurrCacheSize++;
		STATSCOUNTER_SETMAX_NOMUT(pData-&gt;ctrMax, (unsigned) pData-&gt;iCurrCacheSize);
	}

	/* Note that the following code sequence does not work with the cache entry itself,
	 * but rather with pData-&gt;pStrm, the (sole) stream pointer in the non-dynafile case.
	 * The cache array is only updated after the open was successful. -- rgerhards, 2010-03-21
	 */
	if(iFirstFree == -1) {
		dynaFileDelCacheEntry(pData, iOldest, 0);
		STATSCOUNTER_INC(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
		iFirstFree = iOldest; /* this one *is* now free ;) */
	} else {
		/* we need to allocate memory for the cache structure */
		CHKmalloc(pCache[iFirstFree] = (dynaFileCacheEntry*) calloc(1, sizeof(dynaFileCacheEntry)));
	}

	/* Ok, we finally can open the file */
	localRet = prepareFile(pData, newFileName); /* ignore exact error, we check fd below */

	/* check if we had an error */
	if(localRet != RS_RET_OK) {
		/* We do no longer care about internal messages. The errmsg rate limiter
		 * will take care of too-frequent error messages.
		 */
		parser_errmsg(&quot;Could not open dynamic file '%s' [state %d]&quot;, newFileName, localRet);
		ABORT_FINALIZE(localRet);
	}

	localRet = fsCheck(pData, newFileName);
	if(localRet != RS_RET_OK) {
		parser_errmsg(&quot;Invalid file-system condition for dynamic file '%s' [state %d]&quot;, newFileName, localRet);
		ABORT_FINALIZE(localRet);
	}

	if((pCache[iFirstFree]-&gt;pName = ustrdup(newFileName)) == NULL) {
		closeFile(pData); /* need to free failed entry! */
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pCache[iFirstFree]-&gt;pStrm = pData-&gt;pStrm;
	if(pData-&gt;useSigprov)
		pCache[iFirstFree]-&gt;sigprovFileData = pData-&gt;sigprovFileData;
	pCache[iFirstFree]-&gt;clkTickAccessed = getClockFileAccess();
	pData-&gt;iCurrElt = iFirstFree;
	DBGPRINTF(&quot;Added new entry %d for file cache, file '%s'.\n&quot;, iFirstFree, newFileName);

finalize_it:
	if(iRet == RS_RET_OK)
		pCache[pData-&gt;iCurrElt]-&gt;nInactive = 0;
	RETiRet;
}


/* do the actual write process. This function is to be called once we are ready for writing.
 * It will do buffered writes and persist data only when the buffer is full. Note that we must
 * be careful to detect when the file handle changed.
 * rgerhards, 2009-06-03
 */
static  rsRetVal
doWrite(instanceData *__restrict__ const pData, uchar *__restrict__ const pszBuf, const int lenBuf)
{
	DEFiRet;
	assert(pData != NULL);
	assert(pszBuf != NULL);

	DBGPRINTF(&quot;omfile: write to stream, pData-&gt;pStrm %p, lenBuf %d, strt data %.128s\n&quot;,
		  pData-&gt;pStrm, lenBuf, pszBuf);
	if(pData-&gt;pStrm != NULL){
		CHKiRet(strm.Write(pData-&gt;pStrm, pszBuf, lenBuf));
		if(pData-&gt;useSigprov) {
			CHKiRet(pData-&gt;sigprov.OnRecordWrite(pData-&gt;sigprovFileData, pszBuf, lenBuf));
		}
	}

finalize_it:
	RETiRet;
}

/* rgerhards 2004-11-11: write to a file output.  */
static rsRetVal
writeFile(instanceData *__restrict__ const pData,
	  const actWrkrIParams_t *__restrict__ const pParam,
	  const int iMsg)
{
	DEFiRet;

	STATSCOUNTER_INC(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
	/* first check if we have a dynamic file name and, if so,
	 * check if it still is ok or a new file needs to be created
	 */
	if(pData-&gt;bDynamicName) {
		DBGPRINTF(&quot;omfile: file to log to: %s\n&quot;,
			  actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param);
		CHKiRet(prepareDynFile(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param));
	} else { /* &quot;regular&quot;, non-dynafile */
		if(pData-&gt;pStrm == NULL) {
			CHKiRet(prepareFile(pData, pData-&gt;fname));
			if(pData-&gt;pStrm == NULL) {
				parser_errmsg(
					&quot;Could not open output file '%s'&quot;, pData-&gt;fname);
			}
			CHKiRet(fsCheck(pData, pData-&gt;fname));
		}
		pData-&gt;nInactive = 0;
	}

	iRet = doWrite(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).param,
		actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).lenStr);

finalize_it:
	RETiRet;
}


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tplName = NULL;
	pModConf-&gt;fCreateMode = 0644;
	pModConf-&gt;fDirCreateMode = 0700;
	pModConf-&gt;fileUID = -1;
	pModConf-&gt;dirUID = -1;
	pModConf-&gt;fileGID = -1;
	pModConf-&gt;dirGID = -1;
	pModConf-&gt;bDynafileDoNotSuspend = 1;
ENDbeginCnfLoad

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		parser_errmsg(&quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for omfile:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		}

		if(!strcmp(modpblk.descr[i].name, &quot;template&quot;)) {
			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pszFileDfltTplName != NULL) {
				parser_errmsg(&quot;omfile: warning: default template was already &quot;
					&quot;set via legacy directive - may lead to inconsistent &quot;
					&quot;results.&quot;);
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;dircreatemode&quot;)) {
			loadModConf-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;filecreatemode&quot;)) {
			loadModConf-&gt;fCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dirowner&quot;)) {
			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dirownernum&quot;)) {
			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dirgroup&quot;)) {
			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dirgroupnum&quot;)) {
			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;fileowner&quot;)) {
			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;fileownernum&quot;)) {
			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;filegroup&quot;)) {
			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;filegroupnum&quot;)) {
			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dynafile.donotsuspend&quot;)) {
			loadModConf-&gt;bDynafileDoNotSuspend = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;omfile: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

/* This function checks dynafile cache for janitor action */
static void
janitorChkDynaFiles(instanceData *__restrict__ const pData)
{
	uint i;
	dynaFileCacheEntry **pCache = pData-&gt;dynCache;

	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		if(pCache[i] == NULL)
			continue;
		DBGPRINTF(&quot;omfile janitor: checking dynafile %d:%s, inactive since %d\n&quot;, i,
			pCache[i]-&gt;pName == NULL ? UCHAR_CONSTANT(&quot;[OPEN FAILED]&quot;) : pCache[i]-&gt;pName,
			(int) pCache[i]-&gt;nInactive);
		if(pCache[i]-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
			STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
			dynaFileDelCacheEntry(pData, i, 1);
			if(pData-&gt;iCurrElt &gt;= 0) {
				if((uint)(pData-&gt;iCurrElt) == i)
				pData-&gt;iCurrElt = -1; /* no longer available! */
			}
		} else {
			pCache[i]-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
		}
	}
}

/* callback for the janitor. This cleans out files (if so configured) */
static void
janitorCB(void *pUsr)
{
	instanceData *__restrict__ const pData = (instanceData *) pUsr;
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
	if(pData-&gt;bDynamicName) {
		janitorChkDynaFiles(pData);
	} else {
		if(pData-&gt;pStrm != NULL) {
			DBGPRINTF(&quot;omfile janitor: checking file %s, inactive since %d\n&quot;,
				pData-&gt;fname, pData-&gt;nInactive);
			if(pData-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
				STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
				closeFile(pData);
			} else {
				pData-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
			}
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
}


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;pStrm = NULL;
	pthread_mutex_init(&amp;pData-&gt;mutWrite, NULL);
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tplName);
	free(pData-&gt;fname);
	if(pData-&gt;iCloseTimeout &gt; 0)
		janitorDelEtry(pData-&gt;janitorID);
	if(pData-&gt;bDynamicName) {
		dynaFileFreeCache(pData);
	} else if(pData-&gt;pStrm != NULL)
		closeFile(pData);
	if(pData-&gt;stats != NULL)
		statsobj.Destruct(&amp;(pData-&gt;stats));
	if(pData-&gt;useSigprov) {
		pData-&gt;sigprov.Destruct(&amp;pData-&gt;sigprovData);
		obj.ReleaseObj(__FILE__, pData-&gt;sigprovNameFull+2, pData-&gt;sigprovNameFull,
			       (void*) &amp;pData-&gt;sigprov);
		free(pData-&gt;sigprovName);
		free(pData-&gt;sigprovNameFull);
	}
	if(pData-&gt;useCryprov) {
		pData-&gt;cryprov.Destruct(&amp;pData-&gt;cryprovData);
		obj.ReleaseObj(__FILE__, pData-&gt;cryprovNameFull+2, pData-&gt;cryprovNameFull,
			       (void*) &amp;pData-&gt;cryprov);
		free(pData-&gt;cryprovName);
		free(pData-&gt;cryprovNameFull);
	}
	pthread_mutex_destroy(&amp;pData-&gt;mutWrite);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINtryResume
CODESTARTtryResume
ENDtryResume

BEGINbeginTransaction
CODESTARTbeginTransaction
	/* we have nothing to do to begin a transaction */
ENDbeginTransaction


BEGINcommitTransaction
	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
	unsigned i;
CODESTARTcommitTransaction
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);

	for(i = 0 ; i &lt; nParams ; ++i) {
		CHKiRet(writeFile(pData, pParams, i));
	}
	/* Note: pStrm may be NULL if there was an error opening the stream */
	/* if bFlushOnTXEnd is set, we need to flush on transaction end - in
	 * any case. It is not relevant if this is using background writes
	 * (which then become pretty slow) or not. And, similarly, no flush
	 * happens when it is not set. Please see
	 * https://github.com/rsyslog/rsyslog/issues/1297
	 * for a discussion of why we actually need this.
	 * rgerhards, 2017-01-13
	 */
	if(pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
		CHKiRet(strm.Flush(pData-&gt;pStrm));
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		if (runModConf-&gt;bDynafileDoNotSuspend == 0 || !(pData-&gt;bDynamicName)) {
			LogError(0, iRet, &quot;suspending action&quot;);
			iRet = RS_RET_SUSPENDED;
		}
		else {
			LogError(0, iRet, &quot;discarding message&quot;);
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
ENDcommitTransaction


static void
setInstParamDefaults(instanceData *__restrict__ const pData)
{
	pData-&gt;fname = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;fileUID = loadModConf-&gt;fileUID;
	pData-&gt;fileGID = loadModConf-&gt;fileGID;
	pData-&gt;dirUID = loadModConf-&gt;dirUID;
	pData-&gt;dirGID = loadModConf-&gt;dirGID;
	pData-&gt;bFailOnChown = 1;
	pData-&gt;iDynaFileCacheSize = 10;
	pData-&gt;fCreateMode = loadModConf-&gt;fCreateMode;
	pData-&gt;fDirCreateMode = loadModConf-&gt;fDirCreateMode;
	pData-&gt;bCreateDirs = 1;
	pData-&gt;bSyncFile = 0;
	pData-&gt;iZipLevel = 0;
	pData-&gt;bVeryRobustZip = 0;
	pData-&gt;bFlushOnTXEnd = FLUSHONTX_DFLT;
	pData-&gt;iIOBufSize = IOBUF_DFLT_SIZE;
	pData-&gt;iFlushInterval = FLUSH_INTRVL_DFLT;
	pData-&gt;bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
	pData-&gt;sigprovName = NULL;
	pData-&gt;cryprovName = NULL;
	pData-&gt;useSigprov = 0;
	pData-&gt;useCryprov = 0;
	pData-&gt;iCloseTimeout = -1;
}


static rsRetVal
setupInstStatsCtrs(instanceData *__restrict__ const pData)
{
	uchar ctrName[512];
	DEFiRet;

	if(!pData-&gt;bDynamicName) {
		FINALIZE;
	}

	/* support statistics gathering */
	snprintf((char*)ctrName, sizeof(ctrName), &quot;dynafile cache %s&quot;, pData-&gt;fname);
	ctrName[sizeof(ctrName)-1] = '\0'; /* be on the save side */
	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)&quot;omfile&quot;));
	STATSCOUNTER_INIT(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;requests&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrRequests)));
	STATSCOUNTER_INIT(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;level0&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrLevel0)));
	STATSCOUNTER_INIT(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;missed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMiss)));
	STATSCOUNTER_INIT(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;evicted&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrEvict)));
	STATSCOUNTER_INIT(pData-&gt;ctrMax, pData-&gt;mutCtrMax);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;maxused&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMax)));
	STATSCOUNTER_INIT(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT(&quot;closetimeouts&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrCloseTimeouts)));
	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));

finalize_it:
	RETiRet;
}

static void
initSigprov(instanceData *__restrict__ const pData, struct nvlst *lst)
{
	uchar szDrvrName[1024];

	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), &quot;lmsig_%s&quot;, pData-&gt;sigprovName)
		== sizeof(szDrvrName)) {
		parser_errmsg(&quot;omfile: signature provider &quot;
				&quot;name is too long: '%s' - signatures disabled&quot;,
				pData-&gt;sigprovName);
		goto done;
	}
	pData-&gt;sigprovNameFull = ustrdup(szDrvrName);

	pData-&gt;sigprov.ifVersion = sigprovCURR_IF_VERSION;
	/* The pDrvrName+2 below is a hack to obtain the object name. It
	 * safes us to have yet another variable with the name without &quot;lm&quot; in
	 * front of it. If we change the module load interface, we may re-think
	 * about this hack, but for the time being it is efficient and clean enough.
	 */
	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;sigprov)
		!= RS_RET_OK) {
		parser_errmsg(&quot;omfile: could not load &quot;
				&quot;signature provider '%s' - signatures disabled&quot;,
				szDrvrName);
		goto done;
	}

	if(pData-&gt;sigprov.Construct(&amp;pData-&gt;sigprovData) != RS_RET_OK) {
		parser_errmsg(&quot;omfile: error constructing &quot;
				&quot;signature provider %s dataset - signatures disabled&quot;,
				szDrvrName);
		goto done;
	}
	pData-&gt;sigprov.SetCnfParam(pData-&gt;sigprovData, lst);

	dbgprintf(&quot;loaded signature provider %s, data instance at %p\n&quot;,
		  szDrvrName, pData-&gt;sigprovData);
	pData-&gt;useSigprov = 1;
done:	return;
}

static rsRetVal
initCryprov(instanceData *__restrict__ const pData, struct nvlst *lst)
{
	uchar szDrvrName[1024];
	DEFiRet;

	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), &quot;lmcry_%s&quot;, pData-&gt;cryprovName)
		== sizeof(szDrvrName)) {
		parser_errmsg(&quot;omfile: crypto provider &quot;
				&quot;name is too long: '%s' - encryption disabled&quot;,
				pData-&gt;cryprovName);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pData-&gt;cryprovNameFull = ustrdup(szDrvrName);

	pData-&gt;cryprov.ifVersion = cryprovCURR_IF_VERSION;
	/* The pDrvrName+2 below is a hack to obtain the object name. It
	 * safes us to have yet another variable with the name without &quot;lm&quot; in
	 * front of it. If we change the module load interface, we may re-think
	 * about this hack, but for the time being it is efficient and clean enough.
	 */
	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;cryprov)
		!= RS_RET_OK) {
		parser_errmsg(&quot;omfile: could not load &quot;
				&quot;crypto provider '%s' - encryption disabled&quot;,
				szDrvrName);
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}

	if(pData-&gt;cryprov.Construct(&amp;pData-&gt;cryprovData) != RS_RET_OK) {
		parser_errmsg(&quot;omfile: error constructing &quot;
				&quot;crypto provider %s dataset - encryption disabled&quot;,
				szDrvrName);
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}
	CHKiRet(pData-&gt;cryprov.SetCnfParam(pData-&gt;cryprovData, lst, CRYPROV_PARAMTYPE_REGULAR));

	dbgprintf(&quot;loaded crypto provider %s, data instance at %p\n&quot;,
		  szDrvrName, pData-&gt;cryprovData);
	pData-&gt;useCryprov = 1;
finalize_it:
	RETiRet;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *tplToUse;
	int i;
CODESTARTnewActInst
<A NAME="0"></A>	DBGPRINTF(&quot;newActInst (omfile)\n&quot;);

	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2227-0.html#0',2,'match2227-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(pvals == NULL) {
		parser_errmsg(&quot;omfile: either the \&quot;file\&quot; or &quot;
				&quot;\&quot;dynafile\&quot; parameter must be given&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;action param blk in omfile:\n&quot;);
		cnfparamsPrint(&amp;actpblk, pvals);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;dynafilecachesize&quot;)) {
			pData-&gt;iDynaFileCacheSize = (uint) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;ziplevel&quot;)) {
			pData-&gt;iZipLevel = (int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;flushinterval&quot;)) {
			pData-&gt;iFlushInterval = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;veryrobustzip&quot;)) {
			pData-&gt;bVeryRobustZip = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;asyncwriting&quot;)) {
			pData-&gt;bUseAsyncWriter = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;flushontxend&quot;)) {
			pData-&gt;bFlushOnTXEnd = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;iobuffersize&quot;)) {
			pData-&gt;iIOBufSize = (uint) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dirowner&quot;)) {
			pData-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dirownernum&quot;)) {
			pData-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dirgroup&quot;)) {
			pData-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dirgroupnum&quot;)) {
			pData-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;fileowner&quot;)) {
			pData-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;fileownernum&quot;)) {
			pData-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;filegroup&quot;)) {
			pData-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;filegroupnum&quot;)) {
			pData-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dircreatemode&quot;)) {
			pData-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;filecreatemode&quot;)) {
			pData-&gt;fCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;failonchownfailure&quot;)) {
			pData-&gt;bFailOnChown = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;sync&quot;)) {
			pData-&gt;bSyncFile = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;createdirs&quot;)) {
			pData-&gt;bCreateDirs = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;file&quot;)) {
			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			CODE_STD_STRING_REQUESTnewActInst(1)
			pData-&gt;bDynamicName = 0;
		} else if(!strcmp(actpblk.descr[i].name, &quot;dynafile&quot;)) {
			if(pData-&gt;fname != NULL) {
				parser_errmsg(&quot;omfile: both \&quot;file\&quot; and \&quot;dynafile\&quot; set, will use dynafile&quot;);
			}
			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			CODE_STD_STRING_REQUESTnewActInst(2)
			pData-&gt;bDynamicName = 1;
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;sig.provider&quot;)) {
			pData-&gt;sigprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;cry.provider&quot;)) {
			pData-&gt;cryprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;closetimeout&quot;)) {
			pData-&gt;iCloseTimeout = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;omfile: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;fname == NULL) {
		parser_errmsg(&quot;omfile: either the \&quot;file\&quot; or &quot;
				&quot;\&quot;dynafile\&quot; parameter must be given&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(pData-&gt;sigprovName != NULL) {
		initSigprov(pData, lst);
	}

	if(pData-&gt;cryprovName != NULL) {
		CHKiRet(initCryprov(pData, lst));
	}

	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
	pData-&gt;iNumTpls = 1;

	if(pData-&gt;bDynamicName) {
		/* &quot;filename&quot; is actually a template name, we need this as string 1. So let's add it
		 * to the pOMSR. -- rgerhards, 2007-07-27
		 */
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;iNumTpls = 2;
		// TODO: create unified code for this (legacy+v6 system)
		/* we now allocate the cache table */
		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
				calloc(pData-&gt;iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
		pData-&gt;iCurrElt = -1;		  /* no current element */
	}
// TODO: add	pData-&gt;iSizeLimit = 0; /* default value, use outchannels to configure! */
	setupInstStatsCtrs(pData);

	if(pData-&gt;iCloseTimeout == -1) { /* unset? */
		pData-&gt;iCloseTimeout = (pData-&gt;bDynamicName) ? 10 : 0;
	}

	snprintf(pData-&gt;janitorID, sizeof(pData-&gt;janitorID), &quot;omfile:%sfile:%s:%p&quot;,
		(pData-&gt;bDynamicName) ? &quot;dyna&quot; : &quot;&quot;, pData-&gt;fname, pData);
	pData-&gt;janitorID[sizeof(pData-&gt;janitorID)-1] = '\0'; /* just in case... */

	if(pData-&gt;iCloseTimeout &gt; 0)
		janitorAddEtry(janitorCB, pData-&gt;janitorID, pData);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
	uchar fname[MAXFNAME];
CODESTARTparseSelectorAct
	/* Note: the indicator sequence permits us to use '$' to signify
	 * outchannel, what otherwise is not possible due to truely
	 * unresolvable grammar conflicts (*this time no way around*).
	 * rgerhards, 2011-07-09
	 */
	if(!strncmp((char*) p, &quot;:omfile:&quot;, sizeof(&quot;:omfile:&quot;) - 1)) {
		p += sizeof(&quot;:omfile:&quot;) - 1;
	}
	if(!(*p == '$' || *p == '?' || *p == '/' || *p == '.' || *p == '-'))
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);

	CHKiRet(createInstance(&amp;pData));

	if(*p == '-') {
		pData-&gt;bSyncFile = 0;
		p++;
	} else {
		pData-&gt;bSyncFile = cs.bEnableSync;
	}
	pData-&gt;iSizeLimit = 0; /* default value, use outchannels to configure! */

	switch(*p) {
	case '$':
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
		pData-&gt;iNumTpls = 1;
		/* rgerhards 2005-06-21: this is a special setting for output-channel
		 * definitions. In the long term, this setting will probably replace
		 * anything else, but for the time being we must co-exist with the
		 * traditional mode lines.
		 * rgerhards, 2007-07-24: output-channels will go away. We keep them
		 * for compatibility reasons, but seems to have been a bad idea.
		 */
		CHKiRet(cflineParseOutchannel(pData, p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;bDynamicName = 0;
		break;

	case '?': /* This is much like a regular file handle, but we need to obtain
		   * a template name. rgerhards, 2007-07-03
		   */
		CODE_STD_STRING_REQUESTparseSelectorAct(2)
		pData-&gt;iNumTpls = 2;
		++p; /* eat '?' */
		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
		pData-&gt;fname = ustrdup(fname);
		pData-&gt;bDynamicName = 1;
		pData-&gt;iCurrElt = -1;		  /* no current element */
		/* &quot;filename&quot; is actually a template name, we need this as string 1. So let's add it
		 * to the pOMSR. -- rgerhards, 2007-07-27
		 */
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
		/* we now allocate the cache table */
		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
				calloc(cs.iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
		break;

	case '/':
	case '.':
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
		pData-&gt;iNumTpls = 1;
		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
		pData-&gt;fname = ustrdup(fname);
		pData-&gt;bDynamicName = 0;
		break;
	default:
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* freeze current paremeters for this action */
	pData-&gt;iDynaFileCacheSize = cs.iDynaFileCacheSize;
	pData-&gt;fCreateMode = cs.fCreateMode;
	pData-&gt;fDirCreateMode = cs.fDirCreateMode;
	pData-&gt;bCreateDirs = cs.bCreateDirs;
	pData-&gt;bFailOnChown = cs.bFailOnChown;
	pData-&gt;fileUID = cs.fileUID;
	pData-&gt;fileGID = cs.fileGID;
	pData-&gt;dirUID = cs.dirUID;
	pData-&gt;dirGID = cs.dirGID;
	pData-&gt;iZipLevel = cs.iZipLevel;
	pData-&gt;bFlushOnTXEnd = cs.bFlushOnTXEnd;
	pData-&gt;iIOBufSize = (uint) cs.iIOBufSize;
	pData-&gt;iFlushInterval = cs.iFlushInterval;
	pData-&gt;bUseAsyncWriter = cs.bUseAsyncWriter;
	pData-&gt;bVeryRobustZip = 0;	/* cannot be specified via legacy conf */
	pData-&gt;iCloseTimeout = 0;	/* cannot be specified via legacy conf */
	setupInstStatsCtrs(pData);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


/* Reset config variables for this module to default values.
 * rgerhards, 2007-07-17
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.fileUID = -1;
	cs.fileGID = -1;
	cs.dirUID = -1;
	cs.dirGID = -1;
	cs.bFailOnChown = 1;
	cs.iDynaFileCacheSize = 10;
	cs.fCreateMode = 0644;
	cs.fDirCreateMode = 0700;
	cs.bCreateDirs = 1;
	cs.bEnableSync = 0;
	cs.iZipLevel = 0;
	cs.bFlushOnTXEnd = FLUSHONTX_DFLT;
	cs.iIOBufSize = IOBUF_DFLT_SIZE;
	cs.iFlushInterval = FLUSH_INTRVL_DFLT;
	cs.bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
	return RS_RET_OK;
}


BEGINdoHUP
CODESTARTdoHUP
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
	if(pData-&gt;bDynamicName) {
		dynaFileFreeCacheEntries(pData);
	} else {
		if(pData-&gt;pStrm != NULL) {
			closeFile(pData);
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
ENDdoHUP


BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(strm, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	DESTROY_ATOMIC_HELPER_MUT(mutClock);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
ENDqueryEtryPt


BEGINmodInit(File)
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
INITLegCnfVars
	CHKiRet(objUse(strm, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	INIT_ATOMIC_HELPER_MUT(mutClock);

	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF(&quot;omfile: %susing transactional output interface.\n&quot;, bCoreSupportsBatching ? &quot;&quot; : &quot;not &quot;);
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dynafilecachesize&quot;, 0, eCmdHdlrInt, setDynaFileCacheSize,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileziplevel&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iZipLevel,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileflushinterval&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iFlushInterval,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileasyncwriting&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bUseAsyncWriter,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileflushontxend&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bFlushOnTXEnd,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileiobuffersize&quot;, 0, eCmdHdlrSize, NULL, &amp;cs.iIOBufSize,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dirowner&quot;, 0, eCmdHdlrUID, NULL, &amp;cs.dirUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dirownernum&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.dirUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dirgroup&quot;, 0, eCmdHdlrGID, NULL, &amp;cs.dirGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dirgroupnum&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.dirGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;fileowner&quot;, 0, eCmdHdlrUID, NULL, &amp;cs.fileUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;fileownernum&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.fileUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;filegroup&quot;, 0, eCmdHdlrGID, NULL, &amp;cs.fileGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;filegroupnum&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.fileGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;dircreatemode&quot;, 0, eCmdHdlrFileCreateMode, NULL,
		&amp;cs.fDirCreateMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;filecreatemode&quot;, 0, eCmdHdlrFileCreateMode, NULL,
		&amp;cs.fCreateMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;createdirs&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bCreateDirs,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;failonchownfailure&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bFailOnChown,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;omfileforcechown&quot;, 0, eCmdHdlrGoneAway, NULL, NULL,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionfileenablesync&quot;, 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableSync,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionfiledefaulttemplate&quot;, 0, eCmdHdlrGetWord, setLegacyDfltTpl,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
