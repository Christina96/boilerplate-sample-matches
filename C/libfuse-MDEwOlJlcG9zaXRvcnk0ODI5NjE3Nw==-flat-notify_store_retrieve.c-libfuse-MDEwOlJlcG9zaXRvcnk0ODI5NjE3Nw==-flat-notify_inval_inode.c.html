
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 66, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_store_retrieve.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 34
2  #include <fuse_lowlevel.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <errno.h>
7  #include <fcntl.h>
8  #include <assert.h>
9  #include <stddef.h>
10  #include <unistd.h>
11  #include <pthread.h>
12  #define NO_TIMEOUT 500000
13  #define MAX_STR_LEN 128
14  #define FILE_INO 2
15  #define FILE_NAME "current_time"
16  static char file_contents[MAX_STR_LEN];
17  static int lookup_cnt = 0;
18  static size_t file_size;
19  static int retrieve_status = 0;
20  struct options {
21      int no_notify;
22      int update_interval;
23  };
24  static struct options options = {
25      .no_notify = 0,
26      .update_interval = 1,
27  };
28  #define OPTION(t, p)                           \
29      { t, offsetof(struct options, p), 1 }
30  static const struct fuse_opt option_spec[] = {
31      OPTION("--no-notify", no_notify),
32      OPTION("--update-interval=%d", update_interval),
<span onclick='openModal()' class='match'>33      FUSE_OPT_END
34  };
35  static int tfs_stat(fuse_ino_t ino, struct stat *stbuf) {
36      stbuf->st_ino = ino;
37      if (ino == FUSE_ROOT_ID) {
38          stbuf->st_mode = S_IFDIR | 0755;
39          stbuf->st_nlink = 1;
40      }
41      else if (ino == FILE_INO) {
42          stbuf->st_mode = S_IFREG | 0444;
43          stbuf->st_nlink = 1;
44          stbuf->st_size = file_size;
</span>45      }
46      else
47          return -1;
48      return 0;
49  }
50  static void tfs_lookup(fuse_req_t req, fuse_ino_t parent,
51                         const char *name) {
52      struct fuse_entry_param e;
53      memset(&e, 0, sizeof(e));
54      if (parent != FUSE_ROOT_ID)
55          goto err_out;
56      else if (strcmp(name, FILE_NAME) == 0) {
57          e.ino = FILE_INO;
58          lookup_cnt++;
59      } else
60          goto err_out;
61      e.attr_timeout = NO_TIMEOUT;
62      e.entry_timeout = NO_TIMEOUT;
63      if (tfs_stat(e.ino, &e.attr) != 0)
64          goto err_out;
65      fuse_reply_entry(req, &e);
66      return;
67  err_out:
68      fuse_reply_err(req, ENOENT);
69  }
70  static void tfs_forget (fuse_req_t req, fuse_ino_t ino,
71                          uint64_t nlookup) {
72      (void) req;
73      if(ino == FILE_INO)
74          lookup_cnt -= nlookup;
75      else
76          assert(ino == FUSE_ROOT_ID);
77      fuse_reply_none(req);
78  }
79  static void tfs_getattr(fuse_req_t req, fuse_ino_t ino,
80                          struct fuse_file_info *fi) {
81      struct stat stbuf;
82      (void) fi;
83      memset(&stbuf, 0, sizeof(stbuf));
84      if (tfs_stat(ino, &stbuf) != 0)
85          fuse_reply_err(req, ENOENT);
86      else
87          fuse_reply_attr(req, &stbuf, NO_TIMEOUT);
88  }
89  struct dirbuf {
90      char *p;
91      size_t size;
92  };
93  static void dirbuf_add(fuse_req_t req, struct dirbuf *b, const char *name,
94                         fuse_ino_t ino) {
95      struct stat stbuf;
96      size_t oldsize = b->size;
97      b->size += fuse_add_direntry(req, NULL, 0, name, NULL, 0);
98      b->p = (char *) realloc(b->p, b->size);
99      memset(&stbuf, 0, sizeof(stbuf));
100      stbuf.st_ino = ino;
101      fuse_add_direntry(req, b->p + oldsize, b->size - oldsize, name, &stbuf,
102                        b->size);
103  }
104  #define min(x, y) ((x) < (y) ? (x) : (y))
105  static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,
106                               off_t off, size_t maxsize) {
107      if (off < bufsize)
108          return fuse_reply_buf(req, buf + off,
109                                min(bufsize - off, maxsize));
110      else
111          return fuse_reply_buf(req, NULL, 0);
112  }
113  static void tfs_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
114                          off_t off, struct fuse_file_info *fi) {
115      (void) fi;
116      if (ino != FUSE_ROOT_ID)
117          fuse_reply_err(req, ENOTDIR);
118      else {
119          struct dirbuf b;
120          memset(&b, 0, sizeof(b));
121          dirbuf_add(req, &b, FILE_NAME, FILE_INO);
122          reply_buf_limited(req, b.p, b.size, off, size);
123          free(b.p);
124      }
125  }
126  static void tfs_open(fuse_req_t req, fuse_ino_t ino,
127                       struct fuse_file_info *fi) {
128      fi->keep_cache = 1;
129      if (ino == FUSE_ROOT_ID)
130          fuse_reply_err(req, EISDIR);
131      else if ((fi->flags & O_ACCMODE) != O_RDONLY)
132          fuse_reply_err(req, EACCES);
133      else if (ino == FILE_INO)
134          fuse_reply_open(req, fi);
135      else {
136          fprintf(stderr, "Got open for non-existing inode!\n");
137          fuse_reply_err(req, ENOENT);
138      }
139  }
140  static void tfs_read(fuse_req_t req, fuse_ino_t ino, size_t size,
141                       off_t off, struct fuse_file_info *fi) {
142      (void) fi;
143      assert(ino == FILE_INO);
144      reply_buf_limited(req, file_contents, file_size, off, size);
145  }
146  static void tfs_retrieve_reply(fuse_req_t req, void *cookie, fuse_ino_t ino,
147                                 off_t offset, struct fuse_bufvec *data) {
148      struct fuse_bufvec bufv;
149      char buf[MAX_STR_LEN];
150      char *expected;
151      ssize_t ret;
152      assert(ino == FILE_INO);
153      assert(offset == 0);
154      expected = (char*) cookie;
155      bufv.count = 1;
156      bufv.idx = 0;
157      bufv.off = 0;
158      bufv.buf[0].size = MAX_STR_LEN;
159      bufv.buf[0].mem = buf;
160      bufv.buf[0].flags = 0;
161      ret = fuse_buf_copy(&bufv, data, 0);
162      assert(ret > 0);
163      assert(strncmp(buf, expected, ret) == 0);
164      free(expected);
165      retrieve_status = 2;
166      fuse_reply_none(req);
167  }
168  static const struct fuse_lowlevel_ops tfs_oper = {
169      .lookup	= tfs_lookup,
170      .getattr	= tfs_getattr,
171      .readdir	= tfs_readdir,
172      .open	= tfs_open,
173      .read	= tfs_read,
174      .forget     = tfs_forget,
175      .retrieve_reply = tfs_retrieve_reply,
176  };
177  static void update_fs(void) {
178      struct tm *now;
179      time_t t;
180      t = time(NULL);
181      now = localtime(&t);
182      assert(now != NULL);
183      file_size = strftime(file_contents, MAX_STR_LEN,
184                           "The current time is %H:%M:%S\n", now);
185      assert(file_size != 0);
186  }
187  static void* update_fs_loop(void *data) {
188      struct fuse_session *se = (struct fuse_session*) data;
189      struct fuse_bufvec bufv;
190      int ret;
191      while(1) {
192          update_fs();
193          if (!options.no_notify && lookup_cnt) {
194              bufv.count = 1;
195              bufv.idx = 0;
196              bufv.off = 0;
197              bufv.buf[0].size = file_size;
198              bufv.buf[0].mem = file_contents;
199              bufv.buf[0].flags = 0;
200              ret = fuse_lowlevel_notify_store(se, FILE_INO, 0, &bufv, 0);
201              if (-ret == ENODEV) {
202                  break;
203              }
204              else if (ret != 0) {
205                  fprintf(stderr, "ERROR: fuse_lowlevel_notify_store() failed with %s (%d)\n",
206                          strerror(-ret), -ret);
207                  abort();
208              }
209              ret = fuse_lowlevel_notify_retrieve(se, FILE_INO, MAX_STR_LEN,
210                                                  0, (void*) strdup(file_contents));
211              if (-ret == ENODEV) { 
212                  break;
213              }
214              assert(ret == 0);
215              if(retrieve_status == 0)
216                  retrieve_status = 1;
217          }
218          sleep(options.update_interval);
219      }
220      return NULL;
221  }
222  static void show_help(const char *progname)
223  {
224      printf("usage: %s [options] <mountpoint>\n\n", progname);
225      printf("File-system specific options:\n"
226                 "    --update-interval=<secs>  Update-rate of file system contents\n"
227                 "    --no-notify            Disable kernel notifications\n"
228                 "\n");
229  }
230  int main(int argc, char *argv[]) {
231      struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
232      struct fuse_session *se;
233      struct fuse_cmdline_opts opts;
234      struct fuse_loop_config config;
235      pthread_t updater;
236      int ret = -1;
237      if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1)
238          return 1;
239      if (fuse_parse_cmdline(&args, &opts) != 0)
240          return 1;
241      if (opts.show_help) {
242          show_help(argv[0]);
243          fuse_cmdline_help();
244          fuse_lowlevel_help();
245          ret = 0;
246          goto err_out1;
247      } else if (opts.show_version) {
248          printf("FUSE library version %s\n", fuse_pkgversion());
249          fuse_lowlevel_version();
250          ret = 0;
251          goto err_out1;
252      }
253      update_fs();
254      se = fuse_session_new(&args, &tfs_oper,
255                            sizeof(tfs_oper), NULL);
256      if (se == NULL)
257          goto err_out1;
258      if (fuse_set_signal_handlers(se) != 0)
259          goto err_out2;
260      if (fuse_session_mount(se, opts.mountpoint) != 0)
261          goto err_out3;
262      fuse_daemonize(opts.foreground);
263      ret = pthread_create(&updater, NULL, update_fs_loop, (void *)se);
264      if (ret != 0) {
265          fprintf(stderr, "pthread_create failed with %s\n",
266                  strerror(ret));
267          goto err_out3;
268      }
269      if (opts.singlethread)
270          ret = fuse_session_loop(se);
271      else {
272          config.clone_fd = opts.clone_fd;
273          config.max_idle_threads = opts.max_idle_threads;
274          ret = fuse_session_loop_mt(se, &config);
275      }
276      assert(retrieve_status != 1);
277      fuse_session_unmount(se);
278  err_out3:
279      fuse_remove_signal_handlers(se);
280  err_out2:
281      fuse_session_destroy(se);
282  err_out1:
283      free(opts.mountpoint);
284      fuse_opt_free_args(&args);
285      return ret ? 1 : 0;
286  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_inval_inode.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 34
2  #include <fuse_lowlevel.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <errno.h>
7  #include <fcntl.h>
8  #include <assert.h>
9  #include <stddef.h>
10  #include <unistd.h>
11  #include <pthread.h>
12  #define NO_TIMEOUT 500000
13  #define MAX_STR_LEN 128
14  #define FILE_INO 2
15  #define FILE_NAME "current_time"
16  static char file_contents[MAX_STR_LEN];
17  static int lookup_cnt = 0;
18  static size_t file_size;
19  struct options {
20      int no_notify;
21      int update_interval;
22  };
23  static struct options options = {
24      .no_notify = 0,
25      .update_interval = 1,
26  };
27  #define OPTION(t, p)                           \
28      { t, offsetof(struct options, p), 1 }
29  static const struct fuse_opt option_spec[] = {
30      OPTION("--no-notify", no_notify),
31      OPTION("--update-interval=%d", update_interval),
<span onclick='openModal()' class='match'>32      FUSE_OPT_END
33  };
34  static int tfs_stat(fuse_ino_t ino, struct stat *stbuf) {
35      stbuf->st_ino = ino;
36      if (ino == FUSE_ROOT_ID) {
37          stbuf->st_mode = S_IFDIR | 0755;
38          stbuf->st_nlink = 1;
39      }
40      else if (ino == FILE_INO) {
41          stbuf->st_mode = S_IFREG | 0444;
42          stbuf->st_nlink = 1;
43          stbuf->st_size = file_size;
</span>44      }
45      else
46          return -1;
47      return 0;
48  }
49  static void tfs_lookup(fuse_req_t req, fuse_ino_t parent,
50                         const char *name) {
51      struct fuse_entry_param e;
52      memset(&e, 0, sizeof(e));
53      if (parent != FUSE_ROOT_ID)
54          goto err_out;
55      else if (strcmp(name, FILE_NAME) == 0) {
56          e.ino = FILE_INO;
57          lookup_cnt++;
58      } else
59          goto err_out;
60      e.attr_timeout = NO_TIMEOUT;
61      e.entry_timeout = NO_TIMEOUT;
62      if (tfs_stat(e.ino, &e.attr) != 0)
63          goto err_out;
64      fuse_reply_entry(req, &e);
65      return;
66  err_out:
67      fuse_reply_err(req, ENOENT);
68  }
69  static void tfs_forget (fuse_req_t req, fuse_ino_t ino,
70                          uint64_t nlookup) {
71      (void) req;
72      if(ino == FILE_INO)
73          lookup_cnt -= nlookup;
74      else
75          assert(ino == FUSE_ROOT_ID);
76      fuse_reply_none(req);
77  }
78  static void tfs_getattr(fuse_req_t req, fuse_ino_t ino,
79                          struct fuse_file_info *fi) {
80      struct stat stbuf;
81      (void) fi;
82      memset(&stbuf, 0, sizeof(stbuf));
83      if (tfs_stat(ino, &stbuf) != 0)
84          fuse_reply_err(req, ENOENT);
85      else
86          fuse_reply_attr(req, &stbuf, NO_TIMEOUT);
87  }
88  struct dirbuf {
89      char *p;
90      size_t size;
91  };
92  static void dirbuf_add(fuse_req_t req, struct dirbuf *b, const char *name,
93                         fuse_ino_t ino) {
94      struct stat stbuf;
95      size_t oldsize = b->size;
96      b->size += fuse_add_direntry(req, NULL, 0, name, NULL, 0);
97      b->p = (char *) realloc(b->p, b->size);
98      memset(&stbuf, 0, sizeof(stbuf));
99      stbuf.st_ino = ino;
100      fuse_add_direntry(req, b->p + oldsize, b->size - oldsize, name, &stbuf,
101                        b->size);
102  }
103  #define min(x, y) ((x) < (y) ? (x) : (y))
104  static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,
105                               off_t off, size_t maxsize) {
106      if (off < bufsize)
107          return fuse_reply_buf(req, buf + off,
108                                min(bufsize - off, maxsize));
109      else
110          return fuse_reply_buf(req, NULL, 0);
111  }
112  static void tfs_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
113                          off_t off, struct fuse_file_info *fi) {
114      (void) fi;
115      if (ino != FUSE_ROOT_ID)
116          fuse_reply_err(req, ENOTDIR);
117      else {
118          struct dirbuf b;
119          memset(&b, 0, sizeof(b));
120          dirbuf_add(req, &b, FILE_NAME, FILE_INO);
121          reply_buf_limited(req, b.p, b.size, off, size);
122          free(b.p);
123      }
124  }
125  static void tfs_open(fuse_req_t req, fuse_ino_t ino,
126                       struct fuse_file_info *fi) {
127      fi->keep_cache = 1;
128      if (ino == FUSE_ROOT_ID)
129          fuse_reply_err(req, EISDIR);
130      else if ((fi->flags & O_ACCMODE) != O_RDONLY)
131          fuse_reply_err(req, EACCES);
132      else if (ino == FILE_INO)
133          fuse_reply_open(req, fi);
134      else {
135          fprintf(stderr, "Got open for non-existing inode!\n");
136          fuse_reply_err(req, ENOENT);
137      }
138  }
139  static void tfs_read(fuse_req_t req, fuse_ino_t ino, size_t size,
140                       off_t off, struct fuse_file_info *fi) {
141      (void) fi;
142      assert(ino == FILE_INO);
143      reply_buf_limited(req, file_contents, file_size, off, size);
144  }
145  static const struct fuse_lowlevel_ops tfs_oper = {
146      .lookup	= tfs_lookup,
147      .getattr	= tfs_getattr,
148      .readdir	= tfs_readdir,
149      .open	= tfs_open,
150      .read	= tfs_read,
151      .forget     = tfs_forget,
152  };
153  static void update_fs(void) {
154      struct tm *now;
155      time_t t;
156      t = time(NULL);
157      now = localtime(&t);
158      assert(now != NULL);
159      file_size = strftime(file_contents, MAX_STR_LEN,
160                           "The current time is %H:%M:%S\n", now);
161      assert(file_size != 0);
162  }
163  static void* update_fs_loop(void *data) {
164      struct fuse_session *se = (struct fuse_session*) data;
165      while(1) {
166          update_fs();
167          if (!options.no_notify && lookup_cnt) {
168              assert(fuse_lowlevel_notify_inval_inode
169                     (se, FILE_INO, 0, 0) == 0);
170          }
171          sleep(options.update_interval);
172      }
173      return NULL;
174  }
175  static void show_help(const char *progname)
176  {
177      printf("usage: %s [options] <mountpoint>\n\n", progname);
178      printf("File-system specific options:\n"
179                 "    --update-interval=<secs>  Update-rate of file system contents\n"
180                 "    --no-notify            Disable kernel notifications\n"
181                 "\n");
182  }
183  int main(int argc, char *argv[]) {
184      struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
185      struct fuse_session *se;
186      struct fuse_cmdline_opts opts;
187      struct fuse_loop_config config;
188      pthread_t updater;
189      int ret = -1;
190      if (fuse_opt_parse(&args, &options, option_spec, NULL) == -1)
191          return 1;
192      if (fuse_parse_cmdline(&args, &opts) != 0) {
193          ret = 1;
194          goto err_out1;
195      }
196      if (opts.show_help) {
197          show_help(argv[0]);
198          fuse_cmdline_help();
199          fuse_lowlevel_help();
200          ret = 0;
201          goto err_out1;
202      } else if (opts.show_version) {
203          printf("FUSE library version %s\n", fuse_pkgversion());
204          fuse_lowlevel_version();
205          ret = 0;
206          goto err_out1;
207      }
208      update_fs();
209      se = fuse_session_new(&args, &tfs_oper,
210                            sizeof(tfs_oper), NULL);
211      if (se == NULL)
212          goto err_out1;
213      if (fuse_set_signal_handlers(se) != 0)
214          goto err_out2;
215      if (fuse_session_mount(se, opts.mountpoint) != 0)
216          goto err_out3;
217      fuse_daemonize(opts.foreground);
218      ret = pthread_create(&updater, NULL, update_fs_loop, (void *)se);
219      if (ret != 0) {
220          fprintf(stderr, "pthread_create failed with %s\n",
221                  strerror(ret));
222          goto err_out3;
223      }
224      if (opts.singlethread)
225          ret = fuse_session_loop(se);
226      else {
227          config.clone_fd = opts.clone_fd;
228          config.max_idle_threads = opts.max_idle_threads;
229          ret = fuse_session_loop_mt(se, &config);
230      }
231      fuse_session_unmount(se);
232  err_out3:
233      fuse_remove_signal_handlers(se);
234  err_out2:
235      fuse_session_destroy(se);
236  err_out1:
237      fuse_opt_free_args(&args);
238      free(opts.mountpoint);
239      return ret ? 1 : 0;
240  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_store_retrieve.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-notify_inval_inode.c</div>
                </div>
                <div class="column column_space"><pre><code>33      FUSE_OPT_END
34  };
35  static int tfs_stat(fuse_ino_t ino, struct stat *stbuf) {
36      stbuf->st_ino = ino;
37      if (ino == FUSE_ROOT_ID) {
38          stbuf->st_mode = S_IFDIR | 0755;
39          stbuf->st_nlink = 1;
40      }
41      else if (ino == FILE_INO) {
42          stbuf->st_mode = S_IFREG | 0444;
43          stbuf->st_nlink = 1;
44          stbuf->st_size = file_size;
</pre></code></div>
                <div class="column column_space"><pre><code>32      FUSE_OPT_END
33  };
34  static int tfs_stat(fuse_ino_t ino, struct stat *stbuf) {
35      stbuf->st_ino = ino;
36      if (ino == FUSE_ROOT_ID) {
37          stbuf->st_mode = S_IFDIR | 0755;
38          stbuf->st_nlink = 1;
39      }
40      else if (ino == FILE_INO) {
41          stbuf->st_mode = S_IFREG | 0444;
42          stbuf->st_nlink = 1;
43          stbuf->st_size = file_size;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    