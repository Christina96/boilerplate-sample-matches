
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.2432012432012431%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-mux_types.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_MUX_TYPES_H_
2  #define WEBP_WEBP_MUX_TYPES_H_
3  #include <string.h>  
4  #include "./types.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  typedef struct WebPData WebPData;
9  typedef enum WebPFeatureFlags {
10    ANIMATION_FLAG  = 0x00000002,
11    XMP_FLAG        = 0x00000004,
12    EXIF_FLAG       = 0x00000008,
13    ALPHA_FLAG      = 0x00000010,
14    ICCP_FLAG       = 0x00000020,
15    ALL_VALID_FLAGS = 0x0000003e
16  } WebPFeatureFlags;
17  typedef enum WebPMuxAnimDispose {
18    WEBP_MUX_DISPOSE_NONE,       
19    WEBP_MUX_DISPOSE_BACKGROUND  
20  } WebPMuxAnimDispose;
21  typedef enum WebPMuxAnimBlend {
22    WEBP_MUX_BLEND,              
23    WEBP_MUX_NO_BLEND            
24  } WebPMuxAnimBlend;
25  struct WebPData {
26    const uint8_t* bytes;
27    size_t size;
28  };
29  static WEBP_INLINE void WebPDataInit(WebPData* webp_data) {
30    if (webp_data != NULL) {
31      memset(webp_data, 0, sizeof(*webp_data));
32    }
33  }
<span onclick='openModal()' class='match'>34  static WEBP_INLINE void WebPDataClear(WebPData* webp_data) {
35    if (webp_data != NULL) {
36      WebPFree((void*)webp_data->bytes);
37      WebPDataInit(webp_data);
38    }
39  }
40  static WEBP_INLINE int WebPDataCopy(const WebPData* src, WebPData* dst) {
</span>41    if (src == NULL || dst == NULL) return 0;
42    WebPDataInit(dst);
43    if (src->bytes != NULL && src->size != 0) {
44      dst->bytes = (uint8_t*)WebPMalloc(src->size);
45      if (dst->bytes == NULL) return 0;
46      memcpy((void*)dst->bytes, src->bytes, src->size);
47      dst->size = src->size;
48    }
49    return 1;
50  }
51  #ifdef __cplusplus
52  }    
53  #endif
54  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-udprelay.c</h3>
            <pre><code>1  #include <sys/stat.h>
2  #include <sys/types.h>
3  #include <fcntl.h>
4  #include <locale.h>
5  #include <signal.h>
6  #include <string.h>
7  #include <strings.h>
8  #include <time.h>
9  #include <unistd.h>
10  #ifndef __MINGW32__
11  #include <arpa/inet.h>
12  #include <errno.h>
13  #include <netdb.h>
14  #include <netinet/in.h>
15  #include <pthread.h>
16  #endif
17  #ifdef HAVE_CONFIG_H
18  #include "config.h"
19  #endif
20  #if defined(HAVE_SYS_IOCTL_H) && defined(HAVE_NET_IF_H) && defined(__linux__)
21  #include <net/if.h>
22  #include <sys/ioctl.h>
23  #define SET_INTERFACE
24  #endif
25  #ifdef __MINGW32__
26  #include "win32.h"
27  #endif
28  #include <libcork/core.h>
29  #include <udns.h>
30  #include "utils.h"
31  #include "netutils.h"
32  #include "cache.h"
33  #include "udprelay.h"
34  #ifdef MODULE_REMOTE
35  #define MAX_UDP_CONN_NUM 512
36  #else
37  #define MAX_UDP_CONN_NUM 256
38  #endif
39  #ifdef MODULE_REMOTE
40  #ifdef MODULE_
41  #error "MODULE_REMOTE and MODULE_LOCAL should not be both defined"
42  #endif
43  #endif
44  #ifndef EAGAIN
45  #define EAGAIN EWOULDBLOCK
46  #endif
47  #ifndef EWOULDBLOCK
48  #define EWOULDBLOCK EAGAIN
49  #endif
50  static void server_recv_cb(EV_P_ ev_io *w, int revents);
51  static void remote_recv_cb(EV_P_ ev_io *w, int revents);
52  static void remote_timeout_cb(EV_P_ ev_timer *watcher, int revents);
53  static char *hash_key(const int af, const struct sockaddr_storage *addr);
54  #ifdef MODULE_REMOTE
55  static void query_resolve_cb(struct sockaddr *addr, void *data);
56  #endif
57  static void close_and_free_remote(EV_P_ remote_ctx_t *ctx);
58  static remote_ctx_t *new_remote(int fd, server_ctx_t *server_ctx);
59  #ifdef ANDROID
60  extern uint64_t tx;
61  extern uint64_t rx;
62  extern int vpn;
63  #endif
64  extern int verbose;
65  #ifdef MODULE_REMOTE
66  extern uint64_t tx;
67  extern uint64_t rx;
68  #endif
69  static int packet_size                               = DEFAULT_PACKET_SIZE;
70  static int buf_size                                  = DEFAULT_PACKET_SIZE * 2;
71  static int server_num                                = 0;
72  static server_ctx_t *server_ctx_list[MAX_REMOTE_NUM] = { NULL };
73  #ifndef __MINGW32__
74  static int
75  setnonblocking(int fd)
76  {
77      int flags;
78      if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
79          flags = 0;
80      }
81      return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
82  }
83  #endif
84  #if defined(MODULE_REMOTE) && defined(SO_BROADCAST)
85  static int
86  set_broadcast(int socket_fd)
87  {
88      int opt = 1;
89      return setsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));
90  }
91  #endif
92  #ifdef SO_NOSIGPIPE
93  static int
94  set_nosigpipe(int socket_fd)
95  {
96      int opt = 1;
97      return setsockopt(socket_fd, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));
98  }
99  #endif
100  #ifdef MODULE_REDIR
101  #ifndef IP_TRANSPARENT
102  #define IP_TRANSPARENT       19
103  #endif
104  #ifndef IP_RECVORIGDSTADDR
105  #define IP_RECVORIGDSTADDR   20
106  #endif
107  static int
108  get_dstaddr(struct msghdr *msg, struct sockaddr_storage *dstaddr)
109  {
110      struct cmsghdr *cmsg;
111      for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
112          if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVORIGDSTADDR) {
113              memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in));
114              dstaddr->ss_family = AF_INET;
115              return 0;
116          } else if (cmsg->cmsg_level == SOL_IPV6 && cmsg->cmsg_type == IP_RECVORIGDSTADDR) {
117              memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in6));
118              dstaddr->ss_family = AF_INET6;
119              return 0;
120          }
121      }
122      return 1;
123  }
124  #endif
125  #define HASH_KEY_LEN sizeof(struct sockaddr_storage) + sizeof(int)
126  static char *
127  hash_key(const int af, const struct sockaddr_storage *addr)
128  {
129      size_t addr_len = sizeof(struct sockaddr_storage);
130      static char key[HASH_KEY_LEN];
131      memset(key, 0, HASH_KEY_LEN);
132      memcpy(key, &af, sizeof(int));
133      memcpy(key + sizeof(int), (const uint8_t *)addr, addr_len);
134      return key;
135  }
136  #if defined(MODULE_REDIR) || defined(MODULE_REMOTE)
137  static int
138  construct_udprealy_header(const struct sockaddr_storage *in_addr,
139                            char *addr_header)
140  {
141      int addr_header_len = 0;
142      if (in_addr->ss_family == AF_INET) {
143          struct sockaddr_in *addr = (struct sockaddr_in *)in_addr;
144          size_t addr_len          = sizeof(struct in_addr);
145          addr_header[addr_header_len++] = 1;
146          memcpy(addr_header + addr_header_len, &addr->sin_addr, addr_len);
147          addr_header_len += addr_len;
148          memcpy(addr_header + addr_header_len, &addr->sin_port, 2);
149          addr_header_len += 2;
150      } else if (in_addr->ss_family == AF_INET6) {
151          struct sockaddr_in6 *addr = (struct sockaddr_in6 *)in_addr;
152          size_t addr_len           = sizeof(struct in6_addr);
153          addr_header[addr_header_len++] = 4;
154          memcpy(addr_header + addr_header_len, &addr->sin6_addr, addr_len);
155          addr_header_len += addr_len;
156          memcpy(addr_header + addr_header_len, &addr->sin6_port, 2);
157          addr_header_len += 2;
158      } else {
159          return 0;
160      }
161      return addr_header_len;
162  }
163  #endif
164  static int
165  parse_udprealy_header(const char *buf, const size_t buf_len,
166                        char *host, char *port, struct sockaddr_storage *storage)
167  {
168      const uint8_t atyp = *(uint8_t *)buf;
169      int offset         = 1;
170      if ((atyp & ADDRTYPE_MASK) == 1) {
171          size_t in_addr_len = sizeof(struct in_addr);
172          if (buf_len >= in_addr_len + 3) {
173              if (storage != NULL) {
174                  struct sockaddr_in *addr = (struct sockaddr_in *)storage;
175                  addr->sin_family = AF_INET;
176                  addr->sin_addr   = *(struct in_addr *)(buf + offset);
177                  addr->sin_port   = *(uint16_t *)(buf + offset + in_addr_len);
178              }
179              if (host != NULL) {
180                  dns_ntop(AF_INET, (const void *)(buf + offset),
181                           host, INET_ADDRSTRLEN);
182              }
183              offset += in_addr_len;
184          }
185      } else if ((atyp & ADDRTYPE_MASK) == 3) {
186          uint8_t name_len = *(uint8_t *)(buf + offset);
187          if (name_len + 4 <= buf_len) {
188              if (storage != NULL) {
189                  char tmp[257] = { 0 };
190                  struct cork_ip ip;
191                  memcpy(tmp, buf + offset + 1, name_len);
192                  if (cork_ip_init(&ip, tmp) != -1) {
193                      if (ip.version == 4) {
194                          struct sockaddr_in *addr = (struct sockaddr_in *)storage;
195                          dns_pton(AF_INET, tmp, &(addr->sin_addr));
196                          addr->sin_port   = *(uint16_t *)(buf + offset + 1 + name_len);
197                          addr->sin_family = AF_INET;
198                      } else if (ip.version == 6) {
199                          struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
200                          dns_pton(AF_INET, tmp, &(addr->sin6_addr));
201                          addr->sin6_port   = *(uint16_t *)(buf + offset + 1 + name_len);
202                          addr->sin6_family = AF_INET6;
203                      }
204                  }
205              }
206              if (host != NULL) {
207                  memcpy(host, buf + offset + 1, name_len);
208              }
209              offset += 1 + name_len;
210          }
211      } else if ((atyp & ADDRTYPE_MASK) == 4) {
212          size_t in6_addr_len = sizeof(struct in6_addr);
213          if (buf_len >= in6_addr_len + 3) {
214              if (storage != NULL) {
215                  struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
216                  addr->sin6_family = AF_INET6;
217                  addr->sin6_addr   = *(struct in6_addr *)(buf + offset);
218                  addr->sin6_port   = *(uint16_t *)(buf + offset + in6_addr_len);
219              }
220              if (host != NULL) {
221                  dns_ntop(AF_INET6, (const void *)(buf + offset),
222                           host, INET6_ADDRSTRLEN);
223              }
224              offset += in6_addr_len;
225          }
226      }
227      if (offset == 1) {
228          LOGE("[udp] invalid header with addr type %d", atyp);
229          return 0;
230      }
231      if (port != NULL) {
232          sprintf(port, "%d", ntohs(*(uint16_t *)(buf + offset)));
233      }
234      offset += 2;
235      return offset;
236  }
237  static char *
238  get_addr_str(const struct sockaddr *sa)
239  {
240      static char s[SS_ADDRSTRLEN];
241      memset(s, 0, SS_ADDRSTRLEN);
242      char addr[INET6_ADDRSTRLEN] = { 0 };
243      char port[PORTSTRLEN]       = { 0 };
244      uint16_t p;
245      switch (sa->sa_family) {
246      case AF_INET:
247          dns_ntop(AF_INET, &(((struct sockaddr_in *)sa)->sin_addr),
248                   addr, INET_ADDRSTRLEN);
249          p = ntohs(((struct sockaddr_in *)sa)->sin_port);
250          sprintf(port, "%d", p);
251          break;
252      case AF_INET6:
253          dns_ntop(AF_INET6, &(((struct sockaddr_in6 *)sa)->sin6_addr),
254                   addr, INET6_ADDRSTRLEN);
255          p = ntohs(((struct sockaddr_in *)sa)->sin_port);
256          sprintf(port, "%d", p);
257          break;
258      default:
259          strncpy(s, "Unknown AF", SS_ADDRSTRLEN);
260      }
261      int addr_len = strlen(addr);
262      int port_len = strlen(port);
263      memcpy(s, addr, addr_len);
264      memcpy(s + addr_len + 1, port, port_len);
265      s[addr_len] = ':';
266      return s;
267  }
268  int
269  create_remote_socket(int ipv6)
270  {
271      int remote_sock;
272      if (ipv6) {
273          struct sockaddr_in6 addr;
274          memset(&addr, 0, sizeof(struct sockaddr_in6));
275          addr.sin6_family = AF_INET6;
276          addr.sin6_addr   = in6addr_any;
277          addr.sin6_port   = 0;
278          remote_sock      = socket(AF_INET6, SOCK_DGRAM, 0);
279          if (remote_sock == -1) {
280              ERROR("[udp] cannot create socket");
281              return -1;
282          }
283          if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
284              FATAL("[udp] cannot bind remote");
285              return -1;
286          }
287      } else {
288          struct sockaddr_in addr;
289          memset(&addr, 0, sizeof(struct sockaddr_in));
290          addr.sin_family      = AF_INET;
291          addr.sin_addr.s_addr = INADDR_ANY;
292          addr.sin_port        = 0;
293          remote_sock          = socket(AF_INET, SOCK_DGRAM, 0);
294          if (remote_sock == -1) {
295              ERROR("[udp] cannot create socket");
296              return -1;
297          }
298          if (bind(remote_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
299              FATAL("[udp] cannot bind remote");
300              return -1;
301          }
302      }
303      return remote_sock;
304  }
305  int
306  create_server_socket(const char *host, const char *port)
307  {
308      struct addrinfo hints;
309      struct addrinfo *result, *rp, *ipv4v6bindall;
310      int s, server_sock;
311      memset(&hints, 0, sizeof(struct addrinfo));
312      hints.ai_family   = AF_UNSPEC;               &bsol;* Return IPv4 and IPv6 choices */
313      hints.ai_socktype = SOCK_DGRAM;              &bsol;* We want a UDP socket */
314      hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; &bsol;* For wildcard IP address */
315      hints.ai_protocol = IPPROTO_UDP;
316      s = getaddrinfo(host, port, &hints, &result);
317      if (s != 0) {
318          LOGE("[udp] getaddrinfo: %s", gai_strerror(s));
319          return -1;
320      }
321      rp = result;
322      if (!host) {
323          ipv4v6bindall = result;
324          while (ipv4v6bindall) {
325              if (ipv4v6bindall->ai_family == AF_INET6) {
326                  rp = ipv4v6bindall; &bsol;* Take first IPV6 address available */
327                  break;
328              }
329              ipv4v6bindall = ipv4v6bindall->ai_next; &bsol;* Get next address info, if any */
330          }
331      }
332      for (&bsol;*rp = result*/; rp != NULL; rp = rp->ai_next) {
333          server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
334          if (server_sock == -1) {
335              continue;
336          }
337          if (rp->ai_family == AF_INET6) {
338              int ipv6only = host ? 1 : 0;
339              setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));
340          }
341          int opt = 1;
342          setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
343  #ifdef SO_NOSIGPIPE
344          set_nosigpipe(server_sock);
345  #endif
346          int err = set_reuseport(server_sock);
347          if (err == 0) {
348              LOGI("udp port reuse enabled");
349          }
350  #ifdef IP_TOS
351          int tos = 46;
352          setsockopt(server_sock, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
353  #endif
354  #ifdef MODULE_REDIR
355          if (setsockopt(server_sock, SOL_IP, IP_TRANSPARENT, &opt, sizeof(opt))) {
356              ERROR("[udp] setsockopt IP_TRANSPARENT");
357              exit(EXIT_FAILURE);
358          }
359          if (setsockopt(server_sock, IPPROTO_IP, IP_RECVORIGDSTADDR, &opt, sizeof(opt))) {
360              FATAL("[udp] setsockopt IP_RECVORIGDSTADDR");
361          }
362  #endif
363          s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);
364          if (s == 0) {
365              break;
366          } else {
367              ERROR("[udp] bind");
368          }
369          close(server_sock);
370      }
371      if (rp == NULL) {
372          LOGE("[udp] cannot bind");
373          return -1;
374      }
375      freeaddrinfo(result);
376      return server_sock;
377  }
378  remote_ctx_t *
379  new_remote(int fd, server_ctx_t *server_ctx)
380  {
381      remote_ctx_t *ctx = ss_malloc(sizeof(remote_ctx_t));
382      memset(ctx, 0, sizeof(remote_ctx_t));
383      ctx->fd         = fd;
384      ctx->server_ctx = server_ctx;
385      ev_io_init(&ctx->io, remote_recv_cb, fd, EV_READ);
386      ev_timer_init(&ctx->watcher, remote_timeout_cb, server_ctx->timeout,
387                    server_ctx->timeout);
388      return ctx;
389  }
390  server_ctx_t *
391  new_server_ctx(int fd)
392  {
393      server_ctx_t *ctx = ss_malloc(sizeof(server_ctx_t));
394      memset(ctx, 0, sizeof(server_ctx_t));
395      ctx->fd = fd;
396      ev_io_init(&ctx->io, server_recv_cb, fd, EV_READ);
397      return ctx;
398  }
399  #ifdef MODULE_REMOTE
400  struct query_ctx *
401  new_query_ctx(char *buf, size_t len)
402  {
403      struct query_ctx *ctx = ss_malloc(sizeof(struct query_ctx));
404      memset(ctx, 0, sizeof(struct query_ctx));
405      ctx->buf = ss_malloc(sizeof(buffer_t));
406      balloc(ctx->buf, len);
407      memcpy(ctx->buf->array, buf, len);
408      ctx->buf->len = len;
409      return ctx;
410  }
411  void
412  close_and_free_query(EV_P_ struct query_ctx *ctx)
413  {
414      if (ctx != NULL) {
415          if (ctx->query != NULL) {
416              resolv_cancel(ctx->query);
417              ctx->query = NULL;
418          }
419          if (ctx->buf != NULL) {
420              bfree(ctx->buf);
421              ss_free(ctx->buf);
422          }
423          ss_free(ctx);
424      }
425  }
426  #endif
427  void
428  close_and_free_remote(EV_P_ remote_ctx_t *ctx)
<span onclick='openModal()' class='match'>429  {
430      if (ctx != NULL) {
431          ev_timer_stop(EV_A_ & ctx->watcher);
432          ev_io_stop(EV_A_ & ctx->io);
433          close(ctx->fd);
434          ss_free(ctx);
435      }
436  }
437  static void
438  remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
</span>439  {
440      remote_ctx_t *remote_ctx
441          = cork_container_of(watcher, remote_ctx_t, watcher);
442      if (verbose) {
443          LOGI("[udp] connection timeout");
444      }
445      char *key = hash_key(remote_ctx->af, &remote_ctx->src_addr);
446      cache_remove(remote_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN);
447  }
448  #ifdef MODULE_REMOTE
449  static void
450  query_resolve_cb(struct sockaddr *addr, void *data)
451  {
452      struct query_ctx *query_ctx = (struct query_ctx *)data;
453      struct ev_loop *loop        = query_ctx->server_ctx->loop;
454      if (verbose) {
455          LOGI("[udp] udns resolved");
456      }
457      query_ctx->query = NULL;
458      if (addr == NULL) {
459          LOGE("[udp] udns returned an error");
460      } else {
461          remote_ctx_t *remote_ctx = query_ctx->remote_ctx;
462          int cache_hit            = 0;
463          if (remote_ctx == NULL) {
464              char *key = hash_key(AF_UNSPEC, &query_ctx->src_addr);
465              cache_lookup(query_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)&remote_ctx);
466          }
467          if (remote_ctx == NULL) {
468              int remotefd = create_remote_socket(addr->sa_family == AF_INET6);
469              if (remotefd != -1) {
470                  setnonblocking(remotefd);
471  #ifdef SO_BROADCAST
472                  set_broadcast(remotefd);
473  #endif
474  #ifdef SO_NOSIGPIPE
475                  set_nosigpipe(remotefd);
476  #endif
477  #ifdef IP_TOS
478                  int tos = 46;
479                  setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
480  #endif
481  #ifdef SET_INTERFACE
482                  if (query_ctx->server_ctx->iface) {
483                      if (setinterface(remotefd, query_ctx->server_ctx->iface) == -1)
484                          ERROR("setinterface");
485                  }
486  #endif
487                  remote_ctx                  = new_remote(remotefd, query_ctx->server_ctx);
488                  remote_ctx->src_addr        = query_ctx->src_addr;
489                  remote_ctx->server_ctx      = query_ctx->server_ctx;
490                  remote_ctx->addr_header_len = query_ctx->addr_header_len;
491                  memcpy(remote_ctx->addr_header, query_ctx->addr_header,
492                         query_ctx->addr_header_len);
493              } else {
494                  ERROR("[udp] bind() error");
495              }
496          } else {
497              cache_hit = 1;
498          }
499          if (remote_ctx != NULL) {
500              memcpy(&remote_ctx->dst_addr, addr, sizeof(struct sockaddr_storage));
501              size_t addr_len = get_sockaddr_len(addr);
502              int s           = sendto(remote_ctx->fd, query_ctx->buf->array, query_ctx->buf->len,
503                                       0, addr, addr_len);
504              if (s == -1) {
505                  ERROR("[udp] sendto_remote");
506                  if (!cache_hit) {
507                      close_and_free_remote(EV_A_ remote_ctx);
508                  }
509              } else {
510                  if (!cache_hit) {
511                      char *key = hash_key(AF_UNSPEC, &remote_ctx->src_addr);
512                      cache_insert(query_ctx->server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
513                      ev_io_start(EV_A_ & remote_ctx->io);
514                      ev_timer_start(EV_A_ & remote_ctx->watcher);
515                  }
516              }
517          }
518      }
519      close_and_free_query(EV_A_ query_ctx);
520  }
521  #endif
522  static void
523  remote_recv_cb(EV_P_ ev_io *w, int revents)
524  {
525      ssize_t r;
526      remote_ctx_t *remote_ctx = (remote_ctx_t *)w;
527      server_ctx_t *server_ctx = remote_ctx->server_ctx;
528      if (server_ctx == NULL) {
529          LOGE("[udp] invalid server");
530          close_and_free_remote(EV_A_ remote_ctx);
531          return;
532      }
533      struct sockaddr_storage src_addr;
534      socklen_t src_addr_len = sizeof(struct sockaddr_storage);
535      memset(&src_addr, 0, src_addr_len);
536      buffer_t *buf = ss_malloc(sizeof(buffer_t));
537      balloc(buf, buf_size);
538      r = recvfrom(remote_ctx->fd, buf->array, buf_size, 0, (struct sockaddr *)&src_addr, &src_addr_len);
539      if (r == -1) {
540          ERROR("[udp] remote_recv_recvfrom");
541          goto CLEAN_UP;
542      } else if (r > packet_size) {
543          LOGE("[udp] remote_recv_recvfrom fragmentation");
544          goto CLEAN_UP;
545      }
546      buf->len = r;
547  #ifdef MODULE_LOCAL
548      int err = ss_decrypt_all(buf, server_ctx->method, 0, buf_size);
549      if (err) {
550          goto CLEAN_UP;
551      }
552      if (server_ctx->protocol_plugin) {
553          obfs_class *protocol_plugin = server_ctx->protocol_plugin;
554          if (protocol_plugin->client_udp_post_decrypt) {
555              buf->len = protocol_plugin->client_udp_post_decrypt(server_ctx->protocol, &buf->array, buf->len, &buf->capacity);
556              if ((int)buf->len < 0) {
557                  LOGE("client_udp_post_decrypt");
558                  close_and_free_remote(EV_A_ remote_ctx);
559                  return;
560              }
561              if ( buf->len == 0 )
562                  return;
563          }
564      }
565  #ifdef MODULE_REDIR
566      struct sockaddr_storage dst_addr;
567      memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
568      int len = parse_udprealy_header(buf->array, buf->len, NULL, NULL, &dst_addr);
569      if (dst_addr.ss_family != AF_INET && dst_addr.ss_family != AF_INET6) {
570          LOGI("[udp] ss-redir does not support domain name");
571          goto CLEAN_UP;
572      }
573      if (verbose) {
574          char src[SS_ADDRSTRLEN];
575          char dst[SS_ADDRSTRLEN];
576          strcpy(src, get_addr_str((struct sockaddr *)&src_addr));
577          strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr));
578          LOGI("[udp] recv %s via %s", dst, src);
579      }
580  #else
581      int len = parse_udprealy_header(buf->array, buf->len, NULL, NULL, NULL);
582  #endif
583      if (len == 0) {
584          LOGI("[udp] error in parse header");
585          goto CLEAN_UP;
586      }
587  #if defined(MODULE_TUNNEL) || defined(MODULE_REDIR)
588      buf->len -= len;
589      memmove(buf->array, buf->array + len, buf->len);
590  #else
591  #ifdef ANDROID
592      rx += buf->len;
593  #endif
594      brealloc(buf, buf->len + 3, buf_size);
595      memmove(buf->array + 3, buf->array, buf->len);
596      memset(buf->array, 0, 3);
597      buf->len += 3;
598  #endif
599  #endif
600  #ifdef MODULE_REMOTE
601      rx += buf->len;
602      char addr_header_buf[512];
603      char *addr_header   = remote_ctx->addr_header;
604      int addr_header_len = remote_ctx->addr_header_len;
605      if (remote_ctx->af == AF_INET || remote_ctx->af == AF_INET6) {
606          addr_header_len = construct_udprealy_header(&src_addr, addr_header_buf);
607          addr_header     = addr_header_buf;
608      }
609      brealloc(buf, buf->len + addr_header_len, buf_size);
610      memmove(buf->array + addr_header_len, buf->array, buf->len);
611      memcpy(buf->array, addr_header, addr_header_len);
612      buf->len += addr_header_len;
613      int err = ss_encrypt_all(buf, server_ctx->method, 0, buf_size);
614      if (err) {
615          goto CLEAN_UP;
616      }
617  #endif
618      if (buf->len > packet_size) {
619          LOGE("[udp] remote_recv_sendto fragmentation");
620          goto CLEAN_UP;
621      }
622      size_t remote_src_addr_len = get_sockaddr_len((struct sockaddr *)&remote_ctx->src_addr);
623  #ifdef MODULE_REDIR
624      size_t remote_dst_addr_len = get_sockaddr_len((struct sockaddr *)&dst_addr);
625      int src_fd = socket(remote_ctx->src_addr.ss_family, SOCK_DGRAM, 0);
626      if (src_fd < 0) {
627          ERROR("[udp] remote_recv_socket");
628          goto CLEAN_UP;
629      }
630      int opt = 1;
631      if (setsockopt(src_fd, SOL_IP, IP_TRANSPARENT, &opt, sizeof(opt))) {
632          ERROR("[udp] remote_recv_setsockopt");
633          close(src_fd);
634          goto CLEAN_UP;
635      }
636      if (setsockopt(src_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
637          ERROR("[udp] remote_recv_setsockopt");
638          close(src_fd);
639          goto CLEAN_UP;
640      }
641  #ifdef IP_TOS
642      int tos = 46;
643      setsockopt(src_fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
644  #endif
645      if (bind(src_fd, (struct sockaddr *)&dst_addr, remote_dst_addr_len) != 0) {
646          ERROR("[udp] remote_recv_bind");
647          close(src_fd);
648          goto CLEAN_UP;
649      }
650      int s = sendto(src_fd, buf->array, buf->len, 0,
651                     (struct sockaddr *)&remote_ctx->src_addr, remote_src_addr_len);
652      if (s == -1) {
653          ERROR("[udp] remote_recv_sendto");
654          close(src_fd);
655          goto CLEAN_UP;
656      }
657      close(src_fd);
658  #else
659      int s = sendto(server_ctx->fd, buf->array, buf->len, 0,
660                     (struct sockaddr *)&remote_ctx->src_addr, remote_src_addr_len);
661      if (s == -1) {
662          ERROR("[udp] remote_recv_sendto");
663          goto CLEAN_UP;
664      }
665  #endif
666      ev_timer_again(EV_A_ & remote_ctx->watcher);
667  CLEAN_UP:
668      bfree(buf);
669      ss_free(buf);
670  }
671  static void
672  server_recv_cb(EV_P_ ev_io *w, int revents)
673  {
674      server_ctx_t *server_ctx = (server_ctx_t *)w;
675      struct sockaddr_storage src_addr;
676      memset(&src_addr, 0, sizeof(struct sockaddr_storage));
677      buffer_t *buf = ss_malloc(sizeof(buffer_t));
678      balloc(buf, buf_size);
679      socklen_t src_addr_len = sizeof(struct sockaddr_storage);
680      unsigned int offset    = 0;
681  #ifdef MODULE_REDIR
682      char control_buffer[64] = { 0 };
683      struct msghdr msg;
684      memset(&msg, 0, sizeof(struct msghdr));
685      struct iovec iov[1];
686      struct sockaddr_storage dst_addr;
687      memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
688      msg.msg_name       = &src_addr;
689      msg.msg_namelen    = src_addr_len;
690      msg.msg_control    = control_buffer;
691      msg.msg_controllen = sizeof(control_buffer);
692      iov[0].iov_base = buf->array;
693      iov[0].iov_len  = buf_size;
694      msg.msg_iov     = iov;
695      msg.msg_iovlen  = 1;
696      buf->len = recvmsg(server_ctx->fd, &msg, 0);
697      if (buf->len == -1) {
698          ERROR("[udp] server_recvmsg");
699          goto CLEAN_UP;
700      } else if (buf->len > packet_size) {
701          ERROR("[udp] UDP server_recv_recvmsg fragmentation");
702          goto CLEAN_UP;
703      }
704      if (get_dstaddr(&msg, &dst_addr)) {
705          LOGE("[udp] unable to get dest addr");
706          goto CLEAN_UP;
707      }
708      src_addr_len = msg.msg_namelen;
709  #else
710      ssize_t r;
711      r = recvfrom(server_ctx->fd, buf->array, buf_size,
712                   0, (struct sockaddr *)&src_addr, &src_addr_len);
713      if (r == -1) {
714          ERROR("[udp] server_recv_recvfrom");
715          goto CLEAN_UP;
716      } else if (r > packet_size) {
717          ERROR("[udp] server_recv_recvfrom fragmentation");
718          goto CLEAN_UP;
719      }
720      buf->len = r;
721  #endif
722  #ifdef MODULE_REMOTE
723      tx += buf->len;
724      int err = ss_decrypt_all(buf, server_ctx->method, server_ctx->auth, buf_size);
725      if (err) {
726          goto CLEAN_UP;
727      }
728  #endif
729  #ifdef MODULE_LOCAL
730  #if !defined(MODULE_TUNNEL) && !defined(MODULE_REDIR)
731  #ifdef ANDROID
732      tx += buf->len;
733  #endif
734      uint8_t frag = *(uint8_t *)(buf->array + 2);
735      offset += 3;
736  #endif
737  #endif
738  #ifdef MODULE_REDIR
739      if (verbose) {
740          char src[SS_ADDRSTRLEN];
741          char dst[SS_ADDRSTRLEN];
742          strcpy(src, get_addr_str((struct sockaddr *)&src_addr));
743          strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr));
744          LOGI("[udp] redir to %s from %s", dst, src);
745      }
746      char addr_header[512] = { 0 };
747      int addr_header_len   = construct_udprealy_header(&dst_addr, addr_header);
748      if (addr_header_len == 0) {
749          LOGE("[udp] failed to parse tproxy addr");
750          goto CLEAN_UP;
751      }
752      brealloc(buf, buf->len + addr_header_len, buf_size);
753      memmove(buf->array + addr_header_len, buf->array, buf->len);
754      memcpy(buf->array, addr_header, addr_header_len);
755      buf->len += addr_header_len;
756  #elif MODULE_TUNNEL
757      char addr_header[512] = { 0 };
758      char *host            = server_ctx->tunnel_addr.host;
759      char *port            = server_ctx->tunnel_addr.port;
760      uint16_t port_num     = (uint16_t)atoi(port);
761      uint16_t port_net_num = htons(port_num);
762      int addr_header_len   = 0;
763      struct cork_ip ip;
764      if (cork_ip_init(&ip, host) != -1) {
765          if (ip.version == 4) {
766              struct in_addr host_addr;
767              memset(&host_addr, 0, sizeof(struct in_addr));
768              int host_len = sizeof(struct in_addr);
769              if (dns_pton(AF_INET, host, &host_addr) == -1) {
770                  FATAL("IP parser error");
771              }
772              addr_header[addr_header_len++] = 1;
773              memcpy(addr_header + addr_header_len, &host_addr, host_len);
774              addr_header_len += host_len;
775          } else if (ip.version == 6) {
776              struct in6_addr host_addr;
777              memset(&host_addr, 0, sizeof(struct in6_addr));
778              int host_len = sizeof(struct in6_addr);
779              if (dns_pton(AF_INET6, host, &host_addr) == -1) {
780                  FATAL("IP parser error");
781              }
782              addr_header[addr_header_len++] = 4;
783              memcpy(addr_header + addr_header_len, &host_addr, host_len);
784              addr_header_len += host_len;
785          } else {
786              FATAL("IP parser error");
787          }
788      } else {
789          int host_len = strlen(host);
790          addr_header[addr_header_len++] = 3;
791          addr_header[addr_header_len++] = host_len;
792          memcpy(addr_header + addr_header_len, host, host_len);
793          addr_header_len += host_len;
794      }
795      memcpy(addr_header + addr_header_len, &port_net_num, 2);
796      addr_header_len += 2;
797      brealloc(buf, buf->len + addr_header_len, buf_size);
798      memmove(buf->array + addr_header_len, buf->array, buf->len);
799      memcpy(buf->array, addr_header, addr_header_len);
800      buf->len += addr_header_len;
801  #else
802      char host[257] = { 0 };
803      char port[64]  = { 0 };
804      struct sockaddr_storage dst_addr;
805      memset(&dst_addr, 0, sizeof(struct sockaddr_storage));
806      int addr_header_len = parse_udprealy_header(buf->array + offset, buf->len - offset,
807                                                  host, port, &dst_addr);
808      if (addr_header_len == 0) {
809          goto CLEAN_UP;
810      }
811      char *addr_header = buf->array + offset;
812  #endif
813  #ifdef MODULE_LOCAL
814      char *key = hash_key(server_ctx->remote_addr->sa_family, &src_addr);
815  #else
816      char *key = hash_key(dst_addr.ss_family, &src_addr);
817  #endif
818      struct cache *conn_cache = server_ctx->conn_cache;
819      remote_ctx_t *remote_ctx = NULL;
820      cache_lookup(conn_cache, key, HASH_KEY_LEN, (void *)&remote_ctx);
821      if (remote_ctx != NULL) {
822          if (sockaddr_cmp(&src_addr, &remote_ctx->src_addr, sizeof(src_addr))) {
823              remote_ctx = NULL;
824          }
825      }
826      if (remote_ctx != NULL) {
827          ev_timer_again(EV_A_ & remote_ctx->watcher);
828      }
829      if (remote_ctx == NULL) {
830          if (verbose) {
831  #ifdef MODULE_REDIR
832              char src[SS_ADDRSTRLEN];
833              char dst[SS_ADDRSTRLEN];
834              strcpy(src, get_addr_str((struct sockaddr *)&src_addr));
835              strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr));
836              LOGI("[udp] cache miss: %s <-> %s", dst, src);
837  #else
838              LOGI("[udp] cache miss: %s:%s <-> %s", host, port,
839                   get_addr_str((struct sockaddr *)&src_addr));
840  #endif
841          }
842      } else {
843          if (verbose) {
844  #ifdef MODULE_REDIR
845              char src[SS_ADDRSTRLEN];
846              char dst[SS_ADDRSTRLEN];
847              strcpy(src, get_addr_str((struct sockaddr *)&src_addr));
848              strcpy(dst, get_addr_str((struct sockaddr *)&dst_addr));
849              LOGI("[udp] cache hit: %s <-> %s", dst, src);
850  #else
851              LOGI("[udp] cache hit: %s:%s <-> %s", host, port,
852                   get_addr_str((struct sockaddr *)&src_addr));
853  #endif
854          }
855      }
856  #ifdef MODULE_LOCAL
857  #if !defined(MODULE_TUNNEL) && !defined(MODULE_REDIR)
858      if (frag) {
859          LOGE("[udp] drop a message since frag is not 0, but %d", frag);
860          goto CLEAN_UP;
861      }
862  #endif
863      const struct sockaddr *remote_addr = server_ctx->remote_addr;
864      const int remote_addr_len          = server_ctx->remote_addr_len;
865      if (remote_ctx == NULL) {
866          int remotefd = create_remote_socket(remote_addr->sa_family == AF_INET6);
867          if (remotefd < 0) {
868              ERROR("[udp] udprelay bind() error");
869              goto CLEAN_UP;
870          }
871          setnonblocking(remotefd);
872  #ifdef SO_NOSIGPIPE
873          set_nosigpipe(remotefd);
874  #endif
875  #ifdef IP_TOS
876          int tos = 46;
877          setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
878  #endif
879  #ifdef SET_INTERFACE
880          if (server_ctx->iface) {
881              if (setinterface(remotefd, server_ctx->iface) == -1)
882                  ERROR("setinterface");
883          }
884  #endif
885  #ifdef ANDROID
886          if (vpn) {
887              if (protect_socket(remotefd) == -1) {
888                  ERROR("protect_socket");
889                  close(remotefd);
890                  goto CLEAN_UP;
891              }
892          }
893  #endif
894          remote_ctx                  = new_remote(remotefd, server_ctx);
895          remote_ctx->src_addr        = src_addr;
896          remote_ctx->af              = remote_addr->sa_family;
897          remote_ctx->addr_header_len = addr_header_len;
898          memcpy(remote_ctx->addr_header, addr_header, addr_header_len);
899          cache_insert(conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
900          ev_io_start(EV_A_ & remote_ctx->io);
901          ev_timer_start(EV_A_ & remote_ctx->watcher);
902      }
903      if (offset > 0) {
904          buf->len -= offset;
905          memmove(buf->array, buf->array + offset, buf->len);
906      }
907      if (server_ctx->auth) {
908          buf->array[0] |= ONETIMEAUTH_FLAG;
909      }
910      if (server_ctx->protocol_plugin) {
911          obfs_class *protocol_plugin = server_ctx->protocol_plugin;
912          if (protocol_plugin->client_udp_pre_encrypt) {
913              buf->len = protocol_plugin->client_udp_pre_encrypt(server_ctx->protocol, &buf->array, buf->len, &buf->capacity);
914          }
915      }
916      int err = ss_encrypt_all(buf, server_ctx->method, server_ctx->auth, buf->len);
917      if (err) {
918          goto CLEAN_UP;
919      }
920      if (buf->len > packet_size) {
921          LOGE("[udp] server_recv_sendto fragmentation");
922          goto CLEAN_UP;
923      }
924      int s = sendto(remote_ctx->fd, buf->array, buf->len, 0, remote_addr, remote_addr_len);
925      if (s == -1) {
926          ERROR("[udp] server_recv_sendto");
927      }
928  #else
929      int cache_hit  = 0;
930      int need_query = 0;
931      if (buf->len - addr_header_len > packet_size) {
932          LOGE("[udp] server_recv_sendto fragmentation");
933          goto CLEAN_UP;
934      }
935      if (remote_ctx != NULL) {
936          cache_hit = 1;
937          if (remote_ctx->addr_header_len != addr_header_len
938              || memcmp(addr_header, remote_ctx->addr_header, addr_header_len) != 0) {
939              if (dst_addr.ss_family != AF_INET && dst_addr.ss_family != AF_INET6) {
940                  need_query = 1;
941              }
942          } else {
943              memcpy(&dst_addr, &remote_ctx->dst_addr, sizeof(struct sockaddr_storage));
944          }
945      } else {
946          if (dst_addr.ss_family == AF_INET || dst_addr.ss_family == AF_INET6) {
947              int remotefd = create_remote_socket(dst_addr.ss_family == AF_INET6);
948              if (remotefd != -1) {
949                  setnonblocking(remotefd);
950  #ifdef SO_BROADCAST
951                  set_broadcast(remotefd);
952  #endif
953  #ifdef SO_NOSIGPIPE
954                  set_nosigpipe(remotefd);
955  #endif
956  #ifdef IP_TOS
957                  int tos = 46;
958                  setsockopt(remotefd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos));
959  #endif
960  #ifdef SET_INTERFACE
961                  if (server_ctx->iface) {
962                      if (setinterface(remotefd, server_ctx->iface) == -1)
963                          ERROR("setinterface");
964                  }
965  #endif
966                  remote_ctx                  = new_remote(remotefd, server_ctx);
967                  remote_ctx->src_addr        = src_addr;
968                  remote_ctx->server_ctx      = server_ctx;
969                  remote_ctx->addr_header_len = addr_header_len;
970                  memcpy(remote_ctx->addr_header, addr_header, addr_header_len);
971                  memcpy(&remote_ctx->dst_addr, &dst_addr, sizeof(struct sockaddr_storage));
972              } else {
973                  ERROR("[udp] bind() error");
974                  goto CLEAN_UP;
975              }
976          }
977      }
978      if (remote_ctx != NULL && !need_query) {
979          size_t addr_len = get_sockaddr_len((struct sockaddr *)&dst_addr);
980          int s           = sendto(remote_ctx->fd, buf->array + addr_header_len,
981                                   buf->len - addr_header_len, 0,
982                                   (struct sockaddr *)&dst_addr, addr_len);
983          if (s == -1) {
984              ERROR("[udp] sendto_remote");
985              if (!cache_hit) {
986                  close_and_free_remote(EV_A_ remote_ctx);
987              }
988          } else {
989              if (!cache_hit) {
990                  remote_ctx->af = dst_addr.ss_family;
991                  char *key = hash_key(remote_ctx->af, &remote_ctx->src_addr);
992                  cache_insert(server_ctx->conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
993                  ev_io_start(EV_A_ & remote_ctx->io);
994                  ev_timer_start(EV_A_ & remote_ctx->watcher);
995              }
996          }
997      } else {
998          struct addrinfo hints;
999          memset(&hints, 0, sizeof(struct addrinfo));
1000          hints.ai_family   = AF_UNSPEC;
1001          hints.ai_socktype = SOCK_DGRAM;
1002          hints.ai_protocol = IPPROTO_UDP;
1003          struct query_ctx *query_ctx = new_query_ctx(buf->array + addr_header_len,
1004                                                      buf->len - addr_header_len);
1005          query_ctx->server_ctx      = server_ctx;
1006          query_ctx->addr_header_len = addr_header_len;
1007          query_ctx->src_addr        = src_addr;
1008          memcpy(query_ctx->addr_header, addr_header, addr_header_len);
1009          if (need_query) {
1010              query_ctx->remote_ctx = remote_ctx;
1011          }
1012          struct ResolvQuery *query = resolv_query(host, query_resolve_cb,
1013                                                   NULL, query_ctx, htons(atoi(port)));
1014          if (query == NULL) {
1015              ERROR("[udp] unable to create DNS query");
1016              close_and_free_query(EV_A_ query_ctx);
1017              goto CLEAN_UP;
1018          }
1019          query_ctx->query = query;
1020      }
1021  #endif
1022  CLEAN_UP:
1023      bfree(buf);
1024      ss_free(buf);
1025  }
1026  void
1027  free_cb(void *key, void *element)
1028  {
1029      remote_ctx_t *remote_ctx = (remote_ctx_t *)element;
1030      if (verbose) {
1031          LOGI("[udp] one connection freed");
1032      }
1033      close_and_free_remote(EV_DEFAULT, remote_ctx);
1034  }
1035  int
1036  init_udprelay(const char *server_host, const char *server_port,
1037  #ifdef MODULE_LOCAL
1038                const struct sockaddr *remote_addr, const int remote_addr_len,
1039  #ifdef MODULE_TUNNEL
1040                const ss_addr_t tunnel_addr,
1041  #endif
1042  #endif
1043                int mtu, int method, int auth, int timeout, const char *iface, const char *protocol, const char *protocol_param)
1044  {
1045      struct ev_loop *loop = EV_DEFAULT;
1046      if (mtu > 0) {
1047          packet_size = mtu - 1 - 28 - 2 - 64;
1048          buf_size    = packet_size * 2;
1049      }
1050      struct cache *conn_cache;
1051      cache_create(&conn_cache, MAX_UDP_CONN_NUM, free_cb);
1052      int serverfd = create_server_socket(server_host, server_port);
1053      if (serverfd < 0) {
1054          FATAL("[udp] bind() error");
1055      }
1056      setnonblocking(serverfd);
1057      if (protocol != NULL && strcmp(protocol, "verify_sha1") == 0) {
1058          auth = 1;
1059          protocol = NULL;
1060      }
1061      server_ctx_t *server_ctx = new_server_ctx(serverfd);
1062  #ifdef MODULE_REMOTE
1063      server_ctx->loop = loop;
1064  #endif
1065      server_ctx->auth       = auth;
1066      server_ctx->timeout    = max(timeout, MIN_UDP_TIMEOUT);
1067      server_ctx->method     = method;
1068      server_ctx->iface      = iface;
1069      server_ctx->conn_cache = conn_cache;
1070  #ifdef MODULE_LOCAL
1071      server_ctx->remote_addr     = remote_addr;
1072      server_ctx->remote_addr_len = remote_addr_len;
1073      server_ctx->protocol_plugin = new_obfs_class((char *)protocol);
1074      if (server_ctx->protocol_plugin) {
1075          server_ctx->protocol = server_ctx->protocol_plugin->new_obfs();
1076          server_ctx->protocol_global = server_ctx->protocol_plugin->init_data();
1077      }
1078      server_info _server_info;
1079      memset(&_server_info, 0, sizeof(server_info));
1080      strcpy(_server_info.host, inet_ntoa(((struct sockaddr_in*)remote_addr)->sin_addr));
1081      _server_info.port = ((struct sockaddr_in*)remote_addr)->sin_port;
1082      _server_info.port = _server_info.port >> 8 | _server_info.port << 8;
1083      _server_info.g_data = server_ctx->protocol_global;
1084      _server_info.param = (char *)protocol_param;
1085      _server_info.key = enc_get_key();
1086      _server_info.key_len = enc_get_key_len();
1087      if (server_ctx->protocol_plugin)
1088          server_ctx->protocol_plugin->set_server_info(server_ctx->protocol, &_server_info);
1089  #ifdef MODULE_TUNNEL
1090      server_ctx->tunnel_addr = tunnel_addr;
1091  #endif
1092  #endif
1093      ev_io_start(loop, &server_ctx->io);
1094      server_ctx_list[server_num++] = server_ctx;
1095      return 0;
1096  }
1097  void
1098  free_udprelay()
1099  {
1100      struct ev_loop *loop = EV_DEFAULT;
1101      while (server_num-- > 0) {
1102          server_ctx_t *server_ctx = server_ctx_list[server_num];
1103  #ifdef MODULE_LOCAL
1104          if (server_ctx->protocol_plugin) {
1105              server_ctx->protocol_plugin->dispose(server_ctx->protocol);
1106              server_ctx->protocol = NULL;
1107              free_obfs_class(server_ctx->protocol_plugin);
1108              server_ctx->protocol_plugin = NULL;
1109          }
1110  #endif
1111          ev_io_stop(loop, &server_ctx->io);
1112          close(server_ctx->fd);
1113          cache_delete(server_ctx->conn_cache, 0);
1114          ss_free(server_ctx);
1115          server_ctx_list[server_num] = NULL;
1116      }
1117  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-mux_types.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-udprelay.c</div>
                </div>
                <div class="column column_space"><pre><code>34  static WEBP_INLINE void WebPDataClear(WebPData* webp_data) {
35    if (webp_data != NULL) {
36      WebPFree((void*)webp_data->bytes);
37      WebPDataInit(webp_data);
38    }
39  }
40  static WEBP_INLINE int WebPDataCopy(const WebPData* src, WebPData* dst) {
</pre></code></div>
                <div class="column column_space"><pre><code>429  {
430      if (ctx != NULL) {
431          ev_timer_stop(EV_A_ & ctx->watcher);
432          ev_io_stop(EV_A_ & ctx->io);
433          close(ctx->fd);
434          ss_free(ctx);
435      }
436  }
437  static void
438  remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    