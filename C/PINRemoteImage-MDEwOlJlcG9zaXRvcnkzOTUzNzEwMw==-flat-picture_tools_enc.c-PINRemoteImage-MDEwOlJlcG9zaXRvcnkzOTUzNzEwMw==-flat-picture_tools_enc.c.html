
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_tools_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/vp8i_enc.h"
3  #include "src/dsp/yuv.h"
4  #define SIZE 8
5  #define SIZE2 (SIZE / 2)
6  static int IsTransparentARGBArea(const uint32_t* ptr, int stride, int size) {
7    int y, x;
8    for (y = 0; y < size; ++y) {
9      for (x = 0; x < size; ++x) {
10        if (ptr[x] & 0xff000000u) {
11          return 0;
12        }
13      }
14      ptr += stride;
15    }
16    return 1;
17  }
18  static void Flatten(uint8_t* ptr, int v, int stride, int size) {
19    int y;
20    for (y = 0; y < size; ++y) {
21      memset(ptr, v, size);
22      ptr += stride;
23    }
24  }
25  static void FlattenARGB(uint32_t* ptr, uint32_t v, int stride, int size) {
26    int x, y;
27    for (y = 0; y < size; ++y) {
28      for (x = 0; x < size; ++x) ptr[x] = v;
29      ptr += stride;
30    }
31  }
32  static int SmoothenBlock(const uint8_t* a_ptr, int a_stride, uint8_t* y_ptr,
33                           int y_stride, int width, int height) {
34    int sum = 0, count = 0;
35    int x, y;
36    const uint8_t* alpha_ptr = a_ptr;
37    uint8_t* luma_ptr = y_ptr;
38    for (y = 0; y < height; ++y) {
39      for (x = 0; x < width; ++x) {
40        if (alpha_ptr[x] != 0) {
41          ++count;
42          sum += luma_ptr[x];
43        }
44      }
45      alpha_ptr += a_stride;
46      luma_ptr += y_stride;
47    }
48    if (count > 0 && count < width * height) {
49      const uint8_t avg_u8 = (uint8_t)(sum / count);
50      alpha_ptr = a_ptr;
51      luma_ptr = y_ptr;
52      for (y = 0; y < height; ++y) {
53        for (x = 0; x < width; ++x) {
54          if (alpha_ptr[x] == 0) luma_ptr[x] = avg_u8;
55        }
56        alpha_ptr += a_stride;
57        luma_ptr += y_stride;
58      }
59    }
60    return (count == 0);
61  }
62  void WebPCleanupTransparentArea(WebPPicture* pic) {
63    int x, y, w, h;
64    if (pic == NULL) return;
65    w = pic->width / SIZE;
66    h = pic->height / SIZE;
67    if (pic->use_argb) {
68      uint32_t argb_value = 0;
69      for (y = 0; y < h; ++y) {
70        int need_reset = 1;
71        for (x = 0; x < w; ++x) {
72          const int off = (y * pic->argb_stride + x) * SIZE;
73          if (IsTransparentARGBArea(pic->argb + off, pic->argb_stride, SIZE)) {
74            if (need_reset) {
75              argb_value = pic->argb[off];
76              need_reset = 0;
77            }
78            FlattenARGB(pic->argb + off, argb_value, pic->argb_stride, SIZE);
79          } else {
80            need_reset = 1;
81          }
82        }
83      }
84    } else {
85      const int width = pic->width;
86      const int height = pic->height;
87      const int y_stride = pic->y_stride;
88      const int uv_stride = pic->uv_stride;
89      const int a_stride = pic->a_stride;
90      uint8_t* y_ptr = pic->y;
91      uint8_t* u_ptr = pic->u;
92      uint8_t* v_ptr = pic->v;
93      const uint8_t* a_ptr = pic->a;
94      int values[3] = { 0 };
95      if (a_ptr == NULL || y_ptr == NULL || u_ptr == NULL || v_ptr == NULL) {
96        return;
97      }
98      for (y = 0; y + SIZE <= height; y += SIZE) {
99        int need_reset = 1;
100        for (x = 0; x + SIZE <= width; x += SIZE) {
101          if (SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
102                            SIZE, SIZE)) {
103            if (need_reset) {
104              values[0] = y_ptr[x];
105              values[1] = u_ptr[x >> 1];
106              values[2] = v_ptr[x >> 1];
107              need_reset = 0;
108            }
109            Flatten(y_ptr + x,        values[0], y_stride,  SIZE);
110            Flatten(u_ptr + (x >> 1), values[1], uv_stride, SIZE2);
111            Flatten(v_ptr + (x >> 1), values[2], uv_stride, SIZE2);
112          } else {
113            need_reset = 1;
114          }
115        }
116        if (x < width) {
117          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
118                        width - x, SIZE);
119        }
120        a_ptr += SIZE * a_stride;
121        y_ptr += SIZE * y_stride;
122        u_ptr += SIZE2 * uv_stride;
123        v_ptr += SIZE2 * uv_stride;
124      }
125      if (y < height) {
126        const int sub_height = height - y;
127        for (x = 0; x + SIZE <= width; x += SIZE) {
128          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
129                        SIZE, sub_height);
130        }
131        if (x < width) {
132          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
133                        width - x, sub_height);
134        }
135      }
136    }
137  }
138  #undef SIZE
139  #undef SIZE2
140  void WebPCleanupTransparentAreaLossless(WebPPicture* const pic) {
141    int x, y, w, h;
142    uint32_t* argb;
143    assert(pic != NULL && pic->use_argb);
144    w = pic->width;
145    h = pic->height;
146    argb = pic->argb;
147    for (y = 0; y < h; ++y) {
148      for (x = 0; x < w; ++x) {
149        if ((argb[x] & 0xff000000) == 0) {
150          argb[x] = 0x00000000;
151        }
152      }
153      argb += pic->argb_stride;
154    }
155  }
156  #define BLEND(V0, V1, ALPHA) \
157      ((((V0) * (255 - (ALPHA)) + (V1) * (ALPHA)) * 0x101 + 256) >> 16)
158  #define BLEND_10BIT(V0, V1, ALPHA) \
159      ((((V0) * (1020 - (ALPHA)) + (V1) * (ALPHA)) * 0x101 + 1024) >> 18)
160  static WEBP_INLINE uint32_t MakeARGB32(int r, int g, int b) {
161    return (0xff000000u | (r << 16) | (g << 8) | b);
162  }
163  void WebPBlendAlpha(WebPPicture* pic, uint32_t background_rgb) {
164    const int red = (background_rgb >> 16) & 0xff;
165    const int green = (background_rgb >> 8) & 0xff;
166    const int blue = (background_rgb >> 0) & 0xff;
167    int x, y;
168    if (pic == NULL) return;
169    if (!pic->use_argb) {
170      const int uv_width = (pic->width >> 1);  
171      const int Y0 = VP8RGBToY(red, green, blue, YUV_HALF);
172      const int U0 = VP8RGBToU(4 * red, 4 * green, 4 * blue, 4 * YUV_HALF);
173      const int V0 = VP8RGBToV(4 * red, 4 * green, 4 * blue, 4 * YUV_HALF);
174      const int has_alpha = pic->colorspace & WEBP_CSP_ALPHA_BIT;
175      uint8_t* y_ptr = pic->y;
176      uint8_t* u_ptr = pic->u;
177      uint8_t* v_ptr = pic->v;
178      uint8_t* a_ptr = pic->a;
179      if (!has_alpha || a_ptr == NULL) return;    
180      for (y = 0; y < pic->height; ++y) {
181        for (x = 0; x < pic->width; ++x) {
182          const uint8_t alpha = a_ptr[x];
183          if (alpha < 0xff) {
<span onclick='openModal()' class='match'>184            y_ptr[x] = BLEND(Y0, y_ptr[x], alpha);
185          }
</span>186        }
187        if ((y & 1) == 0) {
188          uint8_t* const a_ptr2 =
189              (y + 1 == pic->height) ? a_ptr : a_ptr + pic->a_stride;
190          for (x = 0; x < uv_width; ++x) {
191            const uint32_t alpha =
192                a_ptr[2 * x + 0] + a_ptr[2 * x + 1] +
193                a_ptr2[2 * x + 0] + a_ptr2[2 * x + 1];
194            u_ptr[x] = BLEND_10BIT(U0, u_ptr[x], alpha);
195            v_ptr[x] = BLEND_10BIT(V0, v_ptr[x], alpha);
196          }
197          if (pic->width & 1) {   
198            const uint32_t alpha = 2 * (a_ptr[2 * x + 0] + a_ptr2[2 * x + 0]);
199            u_ptr[x] = BLEND_10BIT(U0, u_ptr[x], alpha);
200            v_ptr[x] = BLEND_10BIT(V0, v_ptr[x], alpha);
201          }
202        } else {
203          u_ptr += pic->uv_stride;
204          v_ptr += pic->uv_stride;
205        }
206        memset(a_ptr, 0xff, pic->width);  
207        a_ptr += pic->a_stride;
208        y_ptr += pic->y_stride;
209      }
210    } else {
211      uint32_t* argb = pic->argb;
212      const uint32_t background = MakeARGB32(red, green, blue);
213      for (y = 0; y < pic->height; ++y) {
214        for (x = 0; x < pic->width; ++x) {
215          const int alpha = (argb[x] >> 24) & 0xff;
216          if (alpha != 0xff) {
217            if (alpha > 0) {
218              int r = (argb[x] >> 16) & 0xff;
219              int g = (argb[x] >>  8) & 0xff;
220              int b = (argb[x] >>  0) & 0xff;
221              r = BLEND(red, r, alpha);
222              g = BLEND(green, g, alpha);
223              b = BLEND(blue, b, alpha);
224              argb[x] = MakeARGB32(r, g, b);
225            } else {
226              argb[x] = background;
227            }
228          }
229        }
230        argb += pic->argb_stride;
231      }
232    }
233  }
234  #undef BLEND
235  #undef BLEND_10BIT
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_tools_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/vp8i_enc.h"
3  #include "src/dsp/yuv.h"
4  #define SIZE 8
5  #define SIZE2 (SIZE / 2)
6  static int IsTransparentARGBArea(const uint32_t* ptr, int stride, int size) {
7    int y, x;
8    for (y = 0; y < size; ++y) {
9      for (x = 0; x < size; ++x) {
10        if (ptr[x] & 0xff000000u) {
11          return 0;
12        }
13      }
14      ptr += stride;
15    }
16    return 1;
17  }
18  static void Flatten(uint8_t* ptr, int v, int stride, int size) {
19    int y;
20    for (y = 0; y < size; ++y) {
21      memset(ptr, v, size);
22      ptr += stride;
23    }
24  }
25  static void FlattenARGB(uint32_t* ptr, uint32_t v, int stride, int size) {
26    int x, y;
27    for (y = 0; y < size; ++y) {
28      for (x = 0; x < size; ++x) ptr[x] = v;
29      ptr += stride;
30    }
31  }
32  static int SmoothenBlock(const uint8_t* a_ptr, int a_stride, uint8_t* y_ptr,
33                           int y_stride, int width, int height) {
34    int sum = 0, count = 0;
35    int x, y;
36    const uint8_t* alpha_ptr = a_ptr;
37    uint8_t* luma_ptr = y_ptr;
38    for (y = 0; y < height; ++y) {
39      for (x = 0; x < width; ++x) {
40        if (alpha_ptr[x] != 0) {
41          ++count;
42          sum += luma_ptr[x];
43        }
44      }
45      alpha_ptr += a_stride;
46      luma_ptr += y_stride;
47    }
48    if (count > 0 && count < width * height) {
49      const uint8_t avg_u8 = (uint8_t)(sum / count);
50      alpha_ptr = a_ptr;
51      luma_ptr = y_ptr;
52      for (y = 0; y < height; ++y) {
53        for (x = 0; x < width; ++x) {
54          if (alpha_ptr[x] == 0) luma_ptr[x] = avg_u8;
55        }
56        alpha_ptr += a_stride;
57        luma_ptr += y_stride;
58      }
59    }
60    return (count == 0);
61  }
62  void WebPCleanupTransparentArea(WebPPicture* pic) {
63    int x, y, w, h;
64    if (pic == NULL) return;
65    w = pic->width / SIZE;
66    h = pic->height / SIZE;
67    if (pic->use_argb) {
68      uint32_t argb_value = 0;
69      for (y = 0; y < h; ++y) {
70        int need_reset = 1;
71        for (x = 0; x < w; ++x) {
72          const int off = (y * pic->argb_stride + x) * SIZE;
73          if (IsTransparentARGBArea(pic->argb + off, pic->argb_stride, SIZE)) {
74            if (need_reset) {
75              argb_value = pic->argb[off];
76              need_reset = 0;
77            }
78            FlattenARGB(pic->argb + off, argb_value, pic->argb_stride, SIZE);
79          } else {
80            need_reset = 1;
81          }
82        }
83      }
84    } else {
85      const int width = pic->width;
86      const int height = pic->height;
87      const int y_stride = pic->y_stride;
88      const int uv_stride = pic->uv_stride;
89      const int a_stride = pic->a_stride;
90      uint8_t* y_ptr = pic->y;
91      uint8_t* u_ptr = pic->u;
92      uint8_t* v_ptr = pic->v;
93      const uint8_t* a_ptr = pic->a;
94      int values[3] = { 0 };
95      if (a_ptr == NULL || y_ptr == NULL || u_ptr == NULL || v_ptr == NULL) {
96        return;
97      }
98      for (y = 0; y + SIZE <= height; y += SIZE) {
99        int need_reset = 1;
100        for (x = 0; x + SIZE <= width; x += SIZE) {
101          if (SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
102                            SIZE, SIZE)) {
103            if (need_reset) {
104              values[0] = y_ptr[x];
105              values[1] = u_ptr[x >> 1];
106              values[2] = v_ptr[x >> 1];
107              need_reset = 0;
108            }
109            Flatten(y_ptr + x,        values[0], y_stride,  SIZE);
110            Flatten(u_ptr + (x >> 1), values[1], uv_stride, SIZE2);
111            Flatten(v_ptr + (x >> 1), values[2], uv_stride, SIZE2);
112          } else {
113            need_reset = 1;
114          }
115        }
116        if (x < width) {
117          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
118                        width - x, SIZE);
119        }
120        a_ptr += SIZE * a_stride;
121        y_ptr += SIZE * y_stride;
122        u_ptr += SIZE2 * uv_stride;
123        v_ptr += SIZE2 * uv_stride;
124      }
125      if (y < height) {
126        const int sub_height = height - y;
127        for (x = 0; x + SIZE <= width; x += SIZE) {
128          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
129                        SIZE, sub_height);
130        }
131        if (x < width) {
132          SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride,
133                        width - x, sub_height);
134        }
135      }
136    }
137  }
138  #undef SIZE
139  #undef SIZE2
140  void WebPCleanupTransparentAreaLossless(WebPPicture* const pic) {
141    int x, y, w, h;
142    uint32_t* argb;
143    assert(pic != NULL && pic->use_argb);
144    w = pic->width;
145    h = pic->height;
146    argb = pic->argb;
147    for (y = 0; y < h; ++y) {
148      for (x = 0; x < w; ++x) {
149        if ((argb[x] & 0xff000000) == 0) {
150          argb[x] = 0x00000000;
151        }
152      }
153      argb += pic->argb_stride;
154    }
155  }
156  #define BLEND(V0, V1, ALPHA) \
157      ((((V0) * (255 - (ALPHA)) + (V1) * (ALPHA)) * 0x101 + 256) >> 16)
158  #define BLEND_10BIT(V0, V1, ALPHA) \
159      ((((V0) * (1020 - (ALPHA)) + (V1) * (ALPHA)) * 0x101 + 1024) >> 18)
160  static WEBP_INLINE uint32_t MakeARGB32(int r, int g, int b) {
161    return (0xff000000u | (r << 16) | (g << 8) | b);
162  }
163  void WebPBlendAlpha(WebPPicture* pic, uint32_t background_rgb) {
164    const int red = (background_rgb >> 16) & 0xff;
165    const int green = (background_rgb >> 8) & 0xff;
166    const int blue = (background_rgb >> 0) & 0xff;
167    int x, y;
168    if (pic == NULL) return;
169    if (!pic->use_argb) {
170      const int uv_width = (pic->width >> 1);  
171      const int Y0 = VP8RGBToY(red, green, blue, YUV_HALF);
172      const int U0 = VP8RGBToU(4 * red, 4 * green, 4 * blue, 4 * YUV_HALF);
173      const int V0 = VP8RGBToV(4 * red, 4 * green, 4 * blue, 4 * YUV_HALF);
174      const int has_alpha = pic->colorspace & WEBP_CSP_ALPHA_BIT;
175      uint8_t* y_ptr = pic->y;
176      uint8_t* u_ptr = pic->u;
177      uint8_t* v_ptr = pic->v;
178      uint8_t* a_ptr = pic->a;
179      if (!has_alpha || a_ptr == NULL) return;    
180      for (y = 0; y < pic->height; ++y) {
181        for (x = 0; x < pic->width; ++x) {
182          const uint8_t alpha = a_ptr[x];
183          if (alpha < 0xff) {
<span onclick='openModal()' class='match'>184            y_ptr[x] = BLEND(Y0, y_ptr[x], alpha);
185          }
</span>186        }
187        if ((y & 1) == 0) {
188          uint8_t* const a_ptr2 =
189              (y + 1 == pic->height) ? a_ptr : a_ptr + pic->a_stride;
190          for (x = 0; x < uv_width; ++x) {
191            const uint32_t alpha =
192                a_ptr[2 * x + 0] + a_ptr[2 * x + 1] +
193                a_ptr2[2 * x + 0] + a_ptr2[2 * x + 1];
194            u_ptr[x] = BLEND_10BIT(U0, u_ptr[x], alpha);
195            v_ptr[x] = BLEND_10BIT(V0, v_ptr[x], alpha);
196          }
197          if (pic->width & 1) {   
198            const uint32_t alpha = 2 * (a_ptr[2 * x + 0] + a_ptr2[2 * x + 0]);
199            u_ptr[x] = BLEND_10BIT(U0, u_ptr[x], alpha);
200            v_ptr[x] = BLEND_10BIT(V0, v_ptr[x], alpha);
201          }
202        } else {
203          u_ptr += pic->uv_stride;
204          v_ptr += pic->uv_stride;
205        }
206        memset(a_ptr, 0xff, pic->width);  
207        a_ptr += pic->a_stride;
208        y_ptr += pic->y_stride;
209      }
210    } else {
211      uint32_t* argb = pic->argb;
212      const uint32_t background = MakeARGB32(red, green, blue);
213      for (y = 0; y < pic->height; ++y) {
214        for (x = 0; x < pic->width; ++x) {
215          const int alpha = (argb[x] >> 24) & 0xff;
216          if (alpha != 0xff) {
217            if (alpha > 0) {
218              int r = (argb[x] >> 16) & 0xff;
219              int g = (argb[x] >>  8) & 0xff;
220              int b = (argb[x] >>  0) & 0xff;
221              r = BLEND(red, r, alpha);
222              g = BLEND(green, g, alpha);
223              b = BLEND(blue, b, alpha);
224              argb[x] = MakeARGB32(r, g, b);
225            } else {
226              argb[x] = background;
227            }
228          }
229        }
230        argb += pic->argb_stride;
231      }
232    }
233  }
234  #undef BLEND
235  #undef BLEND_10BIT
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_tools_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_tools_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>184            y_ptr[x] = BLEND(Y0, y_ptr[x], alpha);
185          }
</pre></code></div>
                <div class="column column_space"><pre><code>184            y_ptr[x] = BLEND(Y0, y_ptr[x], alpha);
185          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    