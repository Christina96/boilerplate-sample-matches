
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.796101949025487%, Tokens: 9</h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-verify.c</h3>
            <pre><code>1  #include "verify.h"
2  static int verify_simple_pack_unit_size = 2000;
3  typedef struct verify_simple_local_data {
4      char * recv_buffer;
5      int recv_buffer_size;
6  }verify_simple_local_data;
7  void verify_simple_local_data_init(verify_simple_local_data* local) {
8      local->recv_buffer = (char*)malloc(16384);
9      local->recv_buffer_size = 0;
10  }
11  obfs * verify_simple_new_obfs() {
12      obfs * self = new_obfs();
13      self->l_data = malloc(sizeof(verify_simple_local_data));
14      verify_simple_local_data_init((verify_simple_local_data*)self->l_data);
15      return self;
16  }
17  void verify_simple_dispose(obfs *self) {
18      verify_simple_local_data *local = (verify_simple_local_data*)self->l_data;
19      if (local->recv_buffer != NULL) {
20          free(local->recv_buffer);
21          local->recv_buffer = NULL;
22      }
23      free(local);
24      self->l_data = NULL;
25      dispose_obfs(self);
26  }
27  int verify_simple_pack_data(char *data, int datalength, char *outdata) {
28      unsigned char rand_len = (xorshift128plus() & 0xF) + 1;
29      int out_size = rand_len + datalength + 6;
30      outdata[0] = out_size >> 8;
31      outdata[1] = out_size;
32      outdata[2] = rand_len;
33      memmove(outdata + rand_len + 2, data, datalength);
34      fillcrc32((unsigned char *)outdata, out_size);
35      return out_size;
36  }
37  int verify_simple_client_pre_encrypt(obfs *self, char **pplaindata, int datalength, size_t *capacity) {
38      char *plaindata = *pplaindata;
39      char * out_buffer = (char*)malloc(datalength * 2 + 32);
40      char * buffer = out_buffer;
41      char * data = plaindata;
42      int len = datalength;
43      int pack_len;
44      while ( len > verify_simple_pack_unit_size ) {
45          pack_len = verify_simple_pack_data(data, verify_simple_pack_unit_size, buffer);
46          buffer += pack_len;
47          data += verify_simple_pack_unit_size;
48          len -= verify_simple_pack_unit_size;
49      }
50      if (len > 0) {
51          pack_len = verify_simple_pack_data(data, len, buffer);
52          buffer += pack_len;
53      }
54      len = buffer - out_buffer;
55      if (*capacity < len) {
56          *pplaindata = (char*)realloc(*pplaindata, *capacity = len * 2);
57          plaindata = *pplaindata;
58      }
59      memmove(plaindata, out_buffer, len);
60      free(out_buffer);
61      return len;
62  }
63  int verify_simple_client_post_decrypt(obfs *self, char **pplaindata, int datalength, size_t *capacity) {
64      char *plaindata = *pplaindata;
65      verify_simple_local_data *local = (verify_simple_local_data*)self->l_data;
66      uint8_t * recv_buffer = (uint8_t *)local->recv_buffer;
67      if (local->recv_buffer_size + datalength > 16384)
68          return -1;
69      memmove(recv_buffer + local->recv_buffer_size, plaindata, datalength);
70      local->recv_buffer_size += datalength;
71      char * out_buffer = (char*)malloc(local->recv_buffer_size);
72      char * buffer = out_buffer;
73      while (local->recv_buffer_size > 2) {
74          int length = ((int)recv_buffer[0] << 8) | recv_buffer[1];
75          if (length >= 8192 || length < 7) {
76              free(out_buffer);
77              local->recv_buffer_size = 0;
78              return -1;
79          }
80          if (length > local->recv_buffer_size)
81              break;
82          int crc = crc32((unsigned char*)recv_buffer, length);
83          if (crc != -1) {
84              free(out_buffer);
85              local->recv_buffer_size = 0;
86              return -1;
87          }
88          int data_size = length - recv_buffer[2] - 6;
89          memmove(buffer, recv_buffer + 2 + recv_buffer[2], data_size);
90          buffer += data_size;
91          memmove(recv_buffer, recv_buffer + length, local->recv_buffer_size -= length);
92      }
93      int len = buffer - out_buffer;
94      if (*capacity < len) {
95          *pplaindata = (char*)realloc(*pplaindata, *capacity = len * 2);
96          plaindata = *pplaindata;
97      }
98      memmove(plaindata, out_buffer, len);
99      free(out_buffer);
100      return len;
101  }
<span onclick='openModal()' class='match'>102  int verify_simple_server_pre_encrypt(obfs *self, char **pplaindata, int datalength, size_t *capacity) {
103      char *plaindata = *pplaindata;
104      char * out_buffer = (char*)malloc(datalength * 2 + 32);
</span>105      char * buffer = out_buffer;
106      char * data = plaindata;
107      int len = datalength;
108      int pack_len;
109      while ( len > verify_simple_pack_unit_size ) {
110          pack_len = verify_simple_pack_data(data, verify_simple_pack_unit_size, buffer);
111          buffer += pack_len;
112          data += verify_simple_pack_unit_size;
113          len -= verify_simple_pack_unit_size;
114      }
115      if (len > 0) {
116          pack_len = verify_simple_pack_data(data, len, buffer);
117          buffer += pack_len;
118      }
119      len = buffer - out_buffer;
120      if (*capacity < len) {
121          *pplaindata = (char*)realloc(*pplaindata, *capacity = len * 2);
122          plaindata = *pplaindata;
123      }
124      memmove(plaindata, out_buffer, len);
125      free(out_buffer);
126      return len;
127  }
128  int verify_simple_server_post_decrypt(obfs *self, char **pplaindata, int datalength, size_t *capacity) {
129      char *plaindata = *pplaindata;
130      verify_simple_local_data *local = (verify_simple_local_data*)self->l_data;
131      uint8_t * recv_buffer = (uint8_t *)local->recv_buffer;
132      if (local->recv_buffer_size + datalength > 16384)
133      {
134          LOGE("verify_simple: wrong buf length %d", local->recv_buffer_size + datalength);
135          return -1;
136      }
137      memmove(recv_buffer + local->recv_buffer_size, plaindata, datalength);
138      local->recv_buffer_size += datalength;
139      char * out_buffer = (char*)malloc(local->recv_buffer_size);
140      char * buffer = out_buffer;
141      while (local->recv_buffer_size > 2) {
142          int length = ((int)recv_buffer[0] << 8) | recv_buffer[1];
143          if (length >= 8192 || length < 7) {
144              free(out_buffer);
145              local->recv_buffer_size = 0;
146              LOGE("verify_simple: wrong length %d", length);
147              return -1;
148          }
149          if (length > local->recv_buffer_size)
150              break;
151          int crc = crc32((unsigned char*)recv_buffer, length);
152          if (crc != -1) {
153              free(out_buffer);
154              local->recv_buffer_size = 0;
155              LOGE("verify_simple: wrong crc");
156              return -1;
157          }
158          int data_size = length - recv_buffer[2] - 6;
159          memmove(buffer, recv_buffer + 2 + recv_buffer[2], data_size);
160          buffer += data_size;
161          memmove(recv_buffer, recv_buffer + length, local->recv_buffer_size -= length);
162      }
163      int len = buffer - out_buffer;
164      if (*capacity < len) {
165          *pplaindata = (char*)realloc(*pplaindata, *capacity = len * 2);
166          plaindata = *pplaindata;
167      }
168      memmove(plaindata, out_buffer, len);
169      free(out_buffer);
170      return len;
171  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-f77funcs_20.h</h3>
            <pre><code>1  FFTW_VOIDFUNC F77(execute, EXECUTE)(X(plan) * const p)
2  {
3       plan *pln = (*p)->pln;
4       pln->adt->solve(pln, (*p)->prb);
5  }
6  FFTW_VOIDFUNC F77(destroy_plan, DESTROY_PLAN)(X(plan) *p)
7  {
8       X(destroy_plan)(*p);
9  }
10  FFTW_VOIDFUNC F77(cleanup, CLEANUP)(void)
11  {
12       X(cleanup)();
13  }
14  FFTW_VOIDFUNC F77(forget_wisdom, FORGET_WISDOM)(void)
15  {
16       X(forget_wisdom)();
17  }
18  FFTW_VOIDFUNC F77(export_wisdom, EXPORT_WISDOM)(void (*f77_write_char)(char *, void *),
19  				       void *data)
20  {
21       write_char_data ad;
22       ad.f77_write_char = f77_write_char;
23       ad.data = data;
24       X(export_wisdom)(write_char, (void *) &ad);
25  }
26  FFTW_VOIDFUNC F77(import_wisdom, IMPORT_WISDOM)(int *isuccess,
27  				       void (*f77_read_char)(int *, void *),
28  				       void *data)
29  {
30       read_char_data ed;
31       ed.f77_read_char = f77_read_char;
32       ed.data = data;
33       *isuccess = X(import_wisdom)(read_char, (void *) &ed);
34  }
35  FFTW_VOIDFUNC F77(import_system_wisdom, IMPORT_SYSTEM_WISDOM)(int *isuccess)
36  {
37       *isuccess = X(import_system_wisdom)();
38  }
39  FFTW_VOIDFUNC F77(print_plan, PRINT_PLAN)(X(plan) * const p)
40  {
41       X(print_plan)(*p);
42       fflush(stdout);
43  }
44  FFTW_VOIDFUNC F77(flops,FLOPS)(X(plan) *p, double *add, double *mul, double *fma)
45  {
46       X(flops)(*p, add, mul, fma);
47  }
48  FFTW_VOIDFUNC F77(estimate_cost,ESTIMATE_COST)(double *cost, X(plan) * const p)
49  {
50       *cost = X(estimate_cost)(*p);
51  }
52  FFTW_VOIDFUNC F77(cost,COST)(double *cost, X(plan) * const p)
53  {
54       *cost = X(cost)(*p);
55  }
56  FFTW_VOIDFUNC F77(set_timelimit,SET_TIMELIMIT)(double *t)
57  {
58       X(set_timelimit)(*t);
59  }
60  FFTW_VOIDFUNC F77(plan_dft, PLAN_DFT)(X(plan) *p, int *rank, const int *n,
61  			     C *in, C *out, int *sign, int *flags)
62  {
63       int *nrev = reverse_n(*rank, n);
64       *p = X(plan_dft)(*rank, nrev, in, out, *sign, *flags);
65       X(ifree0)(nrev);
66  }
67  FFTW_VOIDFUNC F77(plan_dft_1d, PLAN_DFT_1D)(X(plan) *p, int *n, C *in, C *out,
68  				   int *sign, int *flags)
69  {
70       *p = X(plan_dft_1d)(*n, in, out, *sign, *flags);
71  }
72  FFTW_VOIDFUNC F77(plan_dft_2d, PLAN_DFT_2D)(X(plan) *p, int *nx, int *ny,
73  				   C *in, C *out, int *sign, int *flags)
74  {
75       *p = X(plan_dft_2d)(*ny, *nx, in, out, *sign, *flags);
76  }
77  FFTW_VOIDFUNC F77(plan_dft_3d, PLAN_DFT_3D)(X(plan) *p, int *nx, int *ny, int *nz,
78  				   C *in, C *out,
79  				   int *sign, int *flags)
80  {
81       *p = X(plan_dft_3d)(*nz, *ny, *nx, in, out, *sign, *flags);
82  }
83  FFTW_VOIDFUNC F77(plan_many_dft, PLAN_MANY_DFT)(X(plan) *p, int *rank, const int *n,
84  				       int *howmany,
85  				       C *in, const int *inembed,
86  				       int *istride, int *idist,
87  				       C *out, const int *onembed,
88  				       int *ostride, int *odist,
89  				       int *sign, int *flags)
90  {
91       int *nrev = reverse_n(*rank, n);
92       int *inembedrev = reverse_n(*rank, inembed);
93       int *onembedrev = reverse_n(*rank, onembed);
94       *p = X(plan_many_dft)(*rank, nrev, *howmany,
95  			   in, inembedrev, *istride, *idist,
96  			   out, onembedrev, *ostride, *odist,
97  			   *sign, *flags);
98       X(ifree0)(onembedrev);
99       X(ifree0)(inembedrev);
100       X(ifree0)(nrev);
101  }
102  FFTW_VOIDFUNC F77(plan_guru_dft, PLAN_GURU_DFT)(X(plan) *p, int *rank, const int *n,
103  				       const int *is, const int *os,
104  				       int *howmany_rank, const int *h_n,
105  				       const int *h_is, const int *h_os,
106  				       C *in, C *out, int *sign, int *flags)
107  {
108       X(iodim) *dims = make_dims(*rank, n, is, os);
109       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
110       *p = X(plan_guru_dft)(*rank, dims, *howmany_rank, howmany_dims,
111  			   in, out, *sign, *flags);
112       X(ifree0)(howmany_dims);
113       X(ifree0)(dims);
114  }
115  FFTW_VOIDFUNC F77(plan_guru_split_dft, PLAN_GURU_SPLIT_DFT)(X(plan) *p, int *rank, const int *n,
116  				       const int *is, const int *os,
117  				       int *howmany_rank, const int *h_n,
118  				       const int *h_is, const int *h_os,
119  				       R *ri, R *ii, R *ro, R *io, int *flags)
120  {
121       X(iodim) *dims = make_dims(*rank, n, is, os);
122       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
123       *p = X(plan_guru_split_dft)(*rank, dims, *howmany_rank, howmany_dims,
124  			   ri, ii, ro, io, *flags);
125       X(ifree0)(howmany_dims);
126       X(ifree0)(dims);
127  }
128  FFTW_VOIDFUNC F77(execute_dft, EXECUTE_DFT)(X(plan) * const p, C *in, C *out)
129  {
130       plan_dft *pln = (plan_dft *) (*p)->pln;
131       if ((*p)->sign == FFT_SIGN)
132            pln->apply((plan *) pln, in[0], in[0]+1, out[0], out[0]+1);
133       else
134            pln->apply((plan *) pln, in[0]+1, in[0], out[0]+1, out[0]);
135  }
136  FFTW_VOIDFUNC F77(execute_split_dft, EXECUTE_SPLIT_DFT)(X(plan) * const p,
137  					       R *ri, R *ii, R *ro, R *io)
138  {
139       plan_dft *pln = (plan_dft *) (*p)->pln;
140       pln->apply((plan *) pln, ri, ii, ro, io);
141  }
142  FFTW_VOIDFUNC F77(plan_dft_r2c, PLAN_DFT_R2C)(X(plan) *p, int *rank, const int *n,
143  				     R *in, C *out, int *flags)
144  {
145       int *nrev = reverse_n(*rank, n);
146       *p = X(plan_dft_r2c)(*rank, nrev, in, out, *flags);
147       X(ifree0)(nrev);
148  }
149  FFTW_VOIDFUNC F77(plan_dft_r2c_1d, PLAN_DFT_R2C_1D)(X(plan) *p, int *n, R *in, C *out,
150  					   int *flags)
151  {
152       *p = X(plan_dft_r2c_1d)(*n, in, out, *flags);
153  }
154  FFTW_VOIDFUNC F77(plan_dft_r2c_2d, PLAN_DFT_R2C_2D)(X(plan) *p, int *nx, int *ny,
155  					   R *in, C *out, int *flags)
156  {
157       *p = X(plan_dft_r2c_2d)(*ny, *nx, in, out, *flags);
158  }
159  FFTW_VOIDFUNC F77(plan_dft_r2c_3d, PLAN_DFT_R2C_3D)(X(plan) *p,
160  					   int *nx, int *ny, int *nz,
161  					   R *in, C *out,
162  					   int *flags)
163  {
164       *p = X(plan_dft_r2c_3d)(*nz, *ny, *nx, in, out, *flags);
165  }
166  FFTW_VOIDFUNC F77(plan_many_dft_r2c, PLAN_MANY_DFT_R2C)(
167       X(plan) *p, int *rank, const int *n,
168       int *howmany,
169       R *in, const int *inembed, int *istride, int *idist,
<span onclick='openModal()' class='match'>170       C *out, const int *onembed, int *ostride, int *odist,
171       int *flags)
172  {
173       int *nrev = reverse_n(*rank, n);
174       int *inembedrev = reverse_n(*rank, inembed);
175       int *onembedrev = reverse_n(*rank, onembed);
</span>176       *p = X(plan_many_dft_r2c)(*rank, nrev, *howmany,
177  			       in, inembedrev, *istride, *idist,
178  			       out, onembedrev, *ostride, *odist,
179  			       *flags);
180       X(ifree0)(onembedrev);
181       X(ifree0)(inembedrev);
182       X(ifree0)(nrev);
183  }
184  FFTW_VOIDFUNC F77(plan_guru_dft_r2c, PLAN_GURU_DFT_R2C)(
185       X(plan) *p, int *rank, const int *n,
186       const int *is, const int *os,
187       int *howmany_rank, const int *h_n,
188       const int *h_is, const int *h_os,
189       R *in, C *out, int *flags)
190  {
191       X(iodim) *dims = make_dims(*rank, n, is, os);
192       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
193       *p = X(plan_guru_dft_r2c)(*rank, dims, *howmany_rank, howmany_dims,
194  			       in, out, *flags);
195       X(ifree0)(howmany_dims);
196       X(ifree0)(dims);
197  }
198  FFTW_VOIDFUNC F77(plan_guru_split_dft_r2c, PLAN_GURU_SPLIT_DFT_R2C)(
199       X(plan) *p, int *rank, const int *n,
200       const int *is, const int *os,
201       int *howmany_rank, const int *h_n,
202       const int *h_is, const int *h_os,
203       R *in, R *ro, R *io, int *flags)
204  {
205       X(iodim) *dims = make_dims(*rank, n, is, os);
206       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
207       *p = X(plan_guru_split_dft_r2c)(*rank, dims, *howmany_rank, howmany_dims,
208  			       in, ro, io, *flags);
209       X(ifree0)(howmany_dims);
210       X(ifree0)(dims);
211  }
212  FFTW_VOIDFUNC F77(execute_dft_r2c, EXECUTE_DFT_R2C)(X(plan) * const p, R *in, C *out)
213  {
214       plan_rdft2 *pln = (plan_rdft2 *) (*p)->pln;
215       problem_rdft2 *prb = (problem_rdft2 *) (*p)->prb;
216       pln->apply((plan *) pln, in, in + (prb->r1 - prb->r0), out[0], out[0]+1);
217  }
218  FFTW_VOIDFUNC F77(execute_split_dft_r2c, EXECUTE_SPLIT_DFT_R2C)(X(plan) * const p,
219  						       R *in, R *ro, R *io)
220  {
221       plan_rdft2 *pln = (plan_rdft2 *) (*p)->pln;
222       problem_rdft2 *prb = (problem_rdft2 *) (*p)->prb;
223       pln->apply((plan *) pln, in, in + (prb->r1 - prb->r0), ro, io);
224  }
225  FFTW_VOIDFUNC F77(plan_dft_c2r, PLAN_DFT_C2R)(X(plan) *p, int *rank, const int *n,
226  				     C *in, R *out, int *flags)
227  {
228       int *nrev = reverse_n(*rank, n);
229       *p = X(plan_dft_c2r)(*rank, nrev, in, out, *flags);
230       X(ifree0)(nrev);
231  }
232  FFTW_VOIDFUNC F77(plan_dft_c2r_1d, PLAN_DFT_C2R_1D)(X(plan) *p, int *n, C *in, R *out,
233  					   int *flags)
234  {
235       *p = X(plan_dft_c2r_1d)(*n, in, out, *flags);
236  }
237  FFTW_VOIDFUNC F77(plan_dft_c2r_2d, PLAN_DFT_C2R_2D)(X(plan) *p, int *nx, int *ny,
238  					   C *in, R *out, int *flags)
239  {
240       *p = X(plan_dft_c2r_2d)(*ny, *nx, in, out, *flags);
241  }
242  FFTW_VOIDFUNC F77(plan_dft_c2r_3d, PLAN_DFT_C2R_3D)(X(plan) *p,
243  					   int *nx, int *ny, int *nz,
244  					   C *in, R *out,
245  					   int *flags)
246  {
247       *p = X(plan_dft_c2r_3d)(*nz, *ny, *nx, in, out, *flags);
248  }
249  FFTW_VOIDFUNC F77(plan_many_dft_c2r, PLAN_MANY_DFT_C2R)(
250       X(plan) *p, int *rank, const int *n,
251       int *howmany,
252       C *in, const int *inembed, int *istride, int *idist,
253       R *out, const int *onembed, int *ostride, int *odist,
254       int *flags)
255  {
256       int *nrev = reverse_n(*rank, n);
257       int *inembedrev = reverse_n(*rank, inembed);
258       int *onembedrev = reverse_n(*rank, onembed);
259       *p = X(plan_many_dft_c2r)(*rank, nrev, *howmany,
260  			       in, inembedrev, *istride, *idist,
261  			       out, onembedrev, *ostride, *odist,
262  			       *flags);
263       X(ifree0)(onembedrev);
264       X(ifree0)(inembedrev);
265       X(ifree0)(nrev);
266  }
267  FFTW_VOIDFUNC F77(plan_guru_dft_c2r, PLAN_GURU_DFT_C2R)(
268       X(plan) *p, int *rank, const int *n,
269       const int *is, const int *os,
270       int *howmany_rank, const int *h_n,
271       const int *h_is, const int *h_os,
272       C *in, R *out, int *flags)
273  {
274       X(iodim) *dims = make_dims(*rank, n, is, os);
275       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
276       *p = X(plan_guru_dft_c2r)(*rank, dims, *howmany_rank, howmany_dims,
277  			       in, out, *flags);
278       X(ifree0)(howmany_dims);
279       X(ifree0)(dims);
280  }
281  FFTW_VOIDFUNC F77(plan_guru_split_dft_c2r, PLAN_GURU_SPLIT_DFT_C2R)(
282       X(plan) *p, int *rank, const int *n,
283       const int *is, const int *os,
284       int *howmany_rank, const int *h_n,
285       const int *h_is, const int *h_os,
286       R *ri, R *ii, R *out, int *flags)
287  {
288       X(iodim) *dims = make_dims(*rank, n, is, os);
289       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
290       *p = X(plan_guru_split_dft_c2r)(*rank, dims, *howmany_rank, howmany_dims,
291  			       ri, ii, out, *flags);
292       X(ifree0)(howmany_dims);
293       X(ifree0)(dims);
294  }
295  FFTW_VOIDFUNC F77(execute_dft_c2r, EXECUTE_DFT_C2R)(X(plan) * const p, C *in, R *out)
296  {
297       plan_rdft2 *pln = (plan_rdft2 *) (*p)->pln;
298       problem_rdft2 *prb = (problem_rdft2 *) (*p)->prb;
299       pln->apply((plan *) pln, out, out + (prb->r1 - prb->r0), in[0], in[0]+1);
300  }
301  FFTW_VOIDFUNC F77(execute_split_dft_c2r, EXECUTE_SPLIT_DFT_C2R)(X(plan) * const p,
302  					   R *ri, R *ii, R *out)
303  {
304       plan_rdft2 *pln = (plan_rdft2 *) (*p)->pln;
305       problem_rdft2 *prb = (problem_rdft2 *) (*p)->prb;
306       pln->apply((plan *) pln, out, out + (prb->r1 - prb->r0), ri, ii);
307  }
308  FFTW_VOIDFUNC F77(plan_r2r, PLAN_R2R)(X(plan) *p, int *rank, const int *n,
309  			     R *in, R *out,
310  			     int *kind, int *flags)
311  {
312       int *nrev = reverse_n(*rank, n);
313       X(r2r_kind) *k = ints2kinds(*rank, kind);
314       *p = X(plan_r2r)(*rank, nrev, in, out, k, *flags);
315       X(ifree0)(k);
316       X(ifree0)(nrev);
317  }
318  FFTW_VOIDFUNC F77(plan_r2r_1d, PLAN_R2R_1D)(X(plan) *p, int *n, R *in, R *out,
319  				   int *kind, int *flags)
320  {
321       *p = X(plan_r2r_1d)(*n, in, out, (X(r2r_kind)) *kind, *flags);
322  }
323  FFTW_VOIDFUNC F77(plan_r2r_2d, PLAN_R2R_2D)(X(plan) *p, int *nx, int *ny,
324  				   R *in, R *out, 
325  				   int *kindx, int *kindy, int *flags)
326  {
327       *p = X(plan_r2r_2d)(*ny, *nx, in, out,
328  			 (X(r2r_kind)) *kindy, (X(r2r_kind)) *kindx, *flags);
329  }
330  FFTW_VOIDFUNC F77(plan_r2r_3d, PLAN_R2R_3D)(X(plan) *p,
331  				   int *nx, int *ny, int *nz,
332  				   R *in, R *out,
333  				   int *kindx, int *kindy, int *kindz,
334  				   int *flags)
335  {
336       *p = X(plan_r2r_3d)(*nz, *ny, *nx, in, out,
337  			 (X(r2r_kind)) *kindz, (X(r2r_kind)) *kindy, 
338  			 (X(r2r_kind)) *kindx, *flags);
339  }
340  FFTW_VOIDFUNC F77(plan_many_r2r, PLAN_MANY_R2R)(
341       X(plan) *p, int *rank, const int *n,
342       int *howmany,
343       R *in, const int *inembed, int *istride, int *idist,
344       R *out, const int *onembed, int *ostride, int *odist,
345       int *kind, int *flags)
346  {
347       int *nrev = reverse_n(*rank, n);
348       int *inembedrev = reverse_n(*rank, inembed);
349       int *onembedrev = reverse_n(*rank, onembed);
350       X(r2r_kind) *k = ints2kinds(*rank, kind);
351       *p = X(plan_many_r2r)(*rank, nrev, *howmany,
352  			       in, inembedrev, *istride, *idist,
353  			       out, onembedrev, *ostride, *odist,
354  			       k, *flags);
355       X(ifree0)(k);
356       X(ifree0)(onembedrev);
357       X(ifree0)(inembedrev);
358       X(ifree0)(nrev);
359  }
360  FFTW_VOIDFUNC F77(plan_guru_r2r, PLAN_GURU_R2R)(
361       X(plan) *p, int *rank, const int *n,
362       const int *is, const int *os,
363       int *howmany_rank, const int *h_n,
364       const int *h_is, const int *h_os,
365       R *in, R *out, int *kind, int *flags)
366  {
367       X(iodim) *dims = make_dims(*rank, n, is, os);
368       X(iodim) *howmany_dims = make_dims(*howmany_rank, h_n, h_is, h_os);
369       X(r2r_kind) *k = ints2kinds(*rank, kind);
370       *p = X(plan_guru_r2r)(*rank, dims, *howmany_rank, howmany_dims,
371  			       in, out, k, *flags);
372       X(ifree0)(k);
373       X(ifree0)(howmany_dims);
374       X(ifree0)(dims);
375  }
376  FFTW_VOIDFUNC F77(execute_r2r, EXECUTE_R2R)(X(plan) * const p, R *in, R *out)
377  {
378       plan_rdft *pln = (plan_rdft *) (*p)->pln;
379       pln->apply((plan *) pln, in, out);
380  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-verify.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-f77funcs_20.h</div>
                <div class="column column_space"><pre><code>102  int verify_simple_server_pre_encrypt(obfs *self, char **pplaindata, int datalength, size_t *capacity) {
103      char *plaindata = *pplaindata;
104      char * out_buffer = (char*)malloc(datalength * 2 + 32);
</pre></code></div>
                <div class="column column_space"><pre><code>170       C *out, const int *onembed, int *ostride, int *odist,
171       int *flags)
172  {
173       int *nrev = reverse_n(*rank, n);
174       int *inembedrev = reverse_n(*rank, inembed);
175       int *onembedrev = reverse_n(*rank, onembed);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    