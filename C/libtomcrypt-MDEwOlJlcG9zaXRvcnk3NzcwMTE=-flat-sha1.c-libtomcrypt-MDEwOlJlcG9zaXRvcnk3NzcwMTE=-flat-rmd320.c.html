
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha1.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SHA1
3  const struct ltc_hash_descriptor sha1_desc =
4  {
5      "sha1",
6      2,
7      20,
8      64,
9     { 1, 3, 14, 3, 2, 26,  },
10     6,
11      &sha1_init,
12      &sha1_process,
13      &sha1_done,
14      &sha1_test,
15      NULL
16  };
17  #define F0(x,y,z)  (z ^ (x & (y ^ z)))
18  #define F1(x,y,z)  (x ^ y ^ z)
19  #define F2(x,y,z)  ((x & y) | (z & (x | y)))
20  #define F3(x,y,z)  (x ^ y ^ z)
21  #ifdef LTC_CLEAN_STACK
22  static int ss_sha1_compress(hash_state *md, const unsigned char *buf)
23  #else
24  static int  s_sha1_compress(hash_state *md, const unsigned char *buf)
25  #endif
26  {
27      ulong32 a,b,c,d,e,W[80],i;
28  #ifdef LTC_SMALL_CODE
29      ulong32 t;
30  #endif
31      for (i = 0; i < 16; i++) {
32          LOAD32H(W[i], buf + (4*i));
33      }
34      a = md->sha1.state[0];
35      b = md->sha1.state[1];
36      c = md->sha1.state[2];
37      d = md->sha1.state[3];
38      e = md->sha1.state[4];
39      for (i = 16; i < 80; i++) {
40          W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);
41      }
42      #define FF0(a,b,c,d,e,i) e = (ROLc(a, 5) + F0(b,c,d) + e + W[i] + 0x5a827999UL); b = ROLc(b, 30);
43      #define FF1(a,b,c,d,e,i) e = (ROLc(a, 5) + F1(b,c,d) + e + W[i] + 0x6ed9eba1UL); b = ROLc(b, 30);
44      #define FF2(a,b,c,d,e,i) e = (ROLc(a, 5) + F2(b,c,d) + e + W[i] + 0x8f1bbcdcUL); b = ROLc(b, 30);
45      #define FF3(a,b,c,d,e,i) e = (ROLc(a, 5) + F3(b,c,d) + e + W[i] + 0xca62c1d6UL); b = ROLc(b, 30);
46  #ifdef LTC_SMALL_CODE
47      for (i = 0; i < 20; ) {
48         FF0(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
49      }
50      for (; i < 40; ) {
51         FF1(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
52      }
53      for (; i < 60; ) {
54         FF2(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
55      }
56      for (; i < 80; ) {
57         FF3(a,b,c,d,e,i++); t = e; e = d; d = c; c = b; b = a; a = t;
58      }
59  #else
60      for (i = 0; i < 20; ) {
61         FF0(a,b,c,d,e,i++);
62         FF0(e,a,b,c,d,i++);
63         FF0(d,e,a,b,c,i++);
64         FF0(c,d,e,a,b,i++);
65         FF0(b,c,d,e,a,i++);
66      }
67      for (; i < 40; )  {
68         FF1(a,b,c,d,e,i++);
69         FF1(e,a,b,c,d,i++);
70         FF1(d,e,a,b,c,i++);
71         FF1(c,d,e,a,b,i++);
72         FF1(b,c,d,e,a,i++);
73      }
74      for (; i < 60; )  {
75         FF2(a,b,c,d,e,i++);
76         FF2(e,a,b,c,d,i++);
77         FF2(d,e,a,b,c,i++);
78         FF2(c,d,e,a,b,i++);
79         FF2(b,c,d,e,a,i++);
80      }
81      for (; i < 80; )  {
82         FF3(a,b,c,d,e,i++);
83         FF3(e,a,b,c,d,i++);
84         FF3(d,e,a,b,c,i++);
85         FF3(c,d,e,a,b,i++);
86         FF3(b,c,d,e,a,i++);
87      }
88  #endif
89      #undef FF0
90      #undef FF1
91      #undef FF2
92      #undef FF3
93      md->sha1.state[0] = md->sha1.state[0] + a;
94      md->sha1.state[1] = md->sha1.state[1] + b;
95      md->sha1.state[2] = md->sha1.state[2] + c;
96      md->sha1.state[3] = md->sha1.state[3] + d;
97      md->sha1.state[4] = md->sha1.state[4] + e;
98      return CRYPT_OK;
99  }
100  #ifdef LTC_CLEAN_STACK
101  static int s_sha1_compress(hash_state *md, const unsigned char *buf)
102  {
103     int err;
104     err = ss_sha1_compress(md, buf);
105     burn_stack(sizeof(ulong32) * 87);
106     return err;
107  }
108  #endif
109  int sha1_init(hash_state * md)
110  {
111     LTC_ARGCHK(md != NULL);
112     md->sha1.state[0] = 0x67452301UL;
113     md->sha1.state[1] = 0xefcdab89UL;
114     md->sha1.state[2] = 0x98badcfeUL;
<span onclick='openModal()' class='match'>115     md->sha1.state[3] = 0x10325476UL;
116     md->sha1.state[4] = 0xc3d2e1f0UL;
117     md->sha1.curlen = 0;
</span>118     md->sha1.length = 0;
119     return CRYPT_OK;
120  }
121  HASH_PROCESS(sha1_process, s_sha1_compress, sha1, 64)
122  int sha1_done(hash_state * md, unsigned char *out)
123  {
124      int i;
125      LTC_ARGCHK(md  != NULL);
126      LTC_ARGCHK(out != NULL);
127      if (md->sha1.curlen >= sizeof(md->sha1.buf)) {
128         return CRYPT_INVALID_ARG;
129      }
130      md->sha1.length += md->sha1.curlen * 8;
131      md->sha1.buf[md->sha1.curlen++] = (unsigned char)0x80;
132      if (md->sha1.curlen > 56) {
133          while (md->sha1.curlen < 64) {
134              md->sha1.buf[md->sha1.curlen++] = (unsigned char)0;
135          }
136          s_sha1_compress(md, md->sha1.buf);
137          md->sha1.curlen = 0;
138      }
139      while (md->sha1.curlen < 56) {
140          md->sha1.buf[md->sha1.curlen++] = (unsigned char)0;
141      }
142      STORE64H(md->sha1.length, md->sha1.buf+56);
143      s_sha1_compress(md, md->sha1.buf);
144      for (i = 0; i < 5; i++) {
145          STORE32H(md->sha1.state[i], out+(4*i));
146      }
147  #ifdef LTC_CLEAN_STACK
148      zeromem(md, sizeof(hash_state));
149  #endif
150      return CRYPT_OK;
151  }
152  int  sha1_test(void)
153  {
154   #ifndef LTC_TEST
155      return CRYPT_NOP;
156   #else
157    static const struct {
158        const char *msg;
159        unsigned char hash[20];
160    } tests[] = {
161      { "abc",
162        { 0xa9, 0x99, 0x3e, 0x36, 0x47, 0x06, 0x81, 0x6a,
163          0xba, 0x3e, 0x25, 0x71, 0x78, 0x50, 0xc2, 0x6c,
164          0x9c, 0xd0, 0xd8, 0x9d }
165      },
166      { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
167        { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E,
168          0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5,
169          0xE5, 0x46, 0x70, 0xF1 }
170      }
171    };
172    int i;
173    unsigned char tmp[20];
174    hash_state md;
175    for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0]));  i++) {
176        sha1_init(&md);
177        sha1_process(&md, (unsigned char*)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
178        sha1_done(&md, tmp);
179        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "SHA1", i)) {
180           return CRYPT_FAIL_TESTVECTOR;
181        }
182    }
183    return CRYPT_OK;
184    #endif
185  }
186  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd320.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIPEMD320
3  const struct ltc_hash_descriptor rmd320_desc =
4  {
5      "rmd320",
6      14,
7      40,
8      64,
9     { 0 },
10     0,
11      &rmd320_init,
12      &rmd320_process,
13      &rmd320_done,
14      &rmd320_test,
15      NULL
16  };
17  #define F(x, y, z)        ((x) ^ (y) ^ (z))
18  #define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
19  #define H(x, y, z)        (((x) | ~(y)) ^ (z))
20  #define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
21  #define J(x, y, z)        ((x) ^ ((y) | ~(z)))
22  #define FF(a, b, c, d, e, x, s)        \
23        (a) += F((b), (c), (d)) + (x);\
24        (a) = ROLc((a), (s)) + (e);\
25        (c) = ROLc((c), 10);
26  #define GG(a, b, c, d, e, x, s)        \
27        (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
28        (a) = ROLc((a), (s)) + (e);\
29        (c) = ROLc((c), 10);
30  #define HH(a, b, c, d, e, x, s)        \
31        (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
32        (a) = ROLc((a), (s)) + (e);\
33        (c) = ROLc((c), 10);
34  #define II(a, b, c, d, e, x, s)        \
35        (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
36        (a) = ROLc((a), (s)) + (e);\
37        (c) = ROLc((c), 10);
38  #define JJ(a, b, c, d, e, x, s)        \
39        (a) += J((b), (c), (d)) + (x) + 0xa953fd4eUL;\
40        (a) = ROLc((a), (s)) + (e);\
41        (c) = ROLc((c), 10);
42  #define FFF(a, b, c, d, e, x, s)        \
43        (a) += F((b), (c), (d)) + (x);\
44        (a) = ROLc((a), (s)) + (e);\
45        (c) = ROLc((c), 10);
46  #define GGG(a, b, c, d, e, x, s)        \
47        (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9UL;\
48        (a) = ROLc((a), (s)) + (e);\
49        (c) = ROLc((c), 10);
50  #define HHH(a, b, c, d, e, x, s)        \
51        (a) += H((b), (c), (d)) + (x) + 0x6d703ef3UL;\
52        (a) = ROLc((a), (s)) + (e);\
53        (c) = ROLc((c), 10);
54  #define III(a, b, c, d, e, x, s)        \
55        (a) += I((b), (c), (d)) + (x) + 0x5c4dd124UL;\
56        (a) = ROLc((a), (s)) + (e);\
57        (c) = ROLc((c), 10);
58  #define JJJ(a, b, c, d, e, x, s)        \
59        (a) += J((b), (c), (d)) + (x) + 0x50a28be6UL;\
60        (a) = ROLc((a), (s)) + (e);\
61        (c) = ROLc((c), 10);
62  #ifdef LTC_CLEAN_STACK
63  static int ss_rmd320_compress(hash_state *md, const unsigned char *buf)
64  #else
65  static int  s_rmd320_compress(hash_state *md, const unsigned char *buf)
66  #endif
67  {
68     ulong32 aa,bb,cc,dd,ee,aaa,bbb,ccc,ddd,eee,tmp,X[16];
69     int i;
70     for (i = 0; i < 16; i++){
71        LOAD32L(X[i], buf + (4 * i));
72     }
73     aa = md->rmd320.state[0];
74     bb = md->rmd320.state[1];
75     cc = md->rmd320.state[2];
76     dd = md->rmd320.state[3];
77     ee = md->rmd320.state[4];
78     aaa = md->rmd320.state[5];
79     bbb = md->rmd320.state[6];
80     ccc = md->rmd320.state[7];
81     ddd = md->rmd320.state[8];
82     eee = md->rmd320.state[9];
83     FF(aa, bb, cc, dd, ee, X[ 0], 11);
84     FF(ee, aa, bb, cc, dd, X[ 1], 14);
85     FF(dd, ee, aa, bb, cc, X[ 2], 15);
86     FF(cc, dd, ee, aa, bb, X[ 3], 12);
87     FF(bb, cc, dd, ee, aa, X[ 4],  5);
88     FF(aa, bb, cc, dd, ee, X[ 5],  8);
89     FF(ee, aa, bb, cc, dd, X[ 6],  7);
90     FF(dd, ee, aa, bb, cc, X[ 7],  9);
91     FF(cc, dd, ee, aa, bb, X[ 8], 11);
92     FF(bb, cc, dd, ee, aa, X[ 9], 13);
93     FF(aa, bb, cc, dd, ee, X[10], 14);
94     FF(ee, aa, bb, cc, dd, X[11], 15);
95     FF(dd, ee, aa, bb, cc, X[12],  6);
96     FF(cc, dd, ee, aa, bb, X[13],  7);
97     FF(bb, cc, dd, ee, aa, X[14],  9);
98     FF(aa, bb, cc, dd, ee, X[15],  8);
99     JJJ(aaa, bbb, ccc, ddd, eee, X[ 5],  8);
100     JJJ(eee, aaa, bbb, ccc, ddd, X[14],  9);
101     JJJ(ddd, eee, aaa, bbb, ccc, X[ 7],  9);
102     JJJ(ccc, ddd, eee, aaa, bbb, X[ 0], 11);
103     JJJ(bbb, ccc, ddd, eee, aaa, X[ 9], 13);
104     JJJ(aaa, bbb, ccc, ddd, eee, X[ 2], 15);
105     JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
106     JJJ(ddd, eee, aaa, bbb, ccc, X[ 4],  5);
107     JJJ(ccc, ddd, eee, aaa, bbb, X[13],  7);
108     JJJ(bbb, ccc, ddd, eee, aaa, X[ 6],  7);
109     JJJ(aaa, bbb, ccc, ddd, eee, X[15],  8);
110     JJJ(eee, aaa, bbb, ccc, ddd, X[ 8], 11);
111     JJJ(ddd, eee, aaa, bbb, ccc, X[ 1], 14);
112     JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
113     JJJ(bbb, ccc, ddd, eee, aaa, X[ 3], 12);
114     JJJ(aaa, bbb, ccc, ddd, eee, X[12],  6);
115     tmp = aa; aa = aaa; aaa = tmp;
116     GG(ee, aa, bb, cc, dd, X[ 7],  7);
117     GG(dd, ee, aa, bb, cc, X[ 4],  6);
118     GG(cc, dd, ee, aa, bb, X[13],  8);
119     GG(bb, cc, dd, ee, aa, X[ 1], 13);
120     GG(aa, bb, cc, dd, ee, X[10], 11);
121     GG(ee, aa, bb, cc, dd, X[ 6],  9);
122     GG(dd, ee, aa, bb, cc, X[15],  7);
123     GG(cc, dd, ee, aa, bb, X[ 3], 15);
124     GG(bb, cc, dd, ee, aa, X[12],  7);
125     GG(aa, bb, cc, dd, ee, X[ 0], 12);
126     GG(ee, aa, bb, cc, dd, X[ 9], 15);
127     GG(dd, ee, aa, bb, cc, X[ 5],  9);
128     GG(cc, dd, ee, aa, bb, X[ 2], 11);
129     GG(bb, cc, dd, ee, aa, X[14],  7);
130     GG(aa, bb, cc, dd, ee, X[11], 13);
131     GG(ee, aa, bb, cc, dd, X[ 8], 12);
132     III(eee, aaa, bbb, ccc, ddd, X[ 6],  9);
133     III(ddd, eee, aaa, bbb, ccc, X[11], 13);
134     III(ccc, ddd, eee, aaa, bbb, X[ 3], 15);
135     III(bbb, ccc, ddd, eee, aaa, X[ 7],  7);
136     III(aaa, bbb, ccc, ddd, eee, X[ 0], 12);
137     III(eee, aaa, bbb, ccc, ddd, X[13],  8);
138     III(ddd, eee, aaa, bbb, ccc, X[ 5],  9);
139     III(ccc, ddd, eee, aaa, bbb, X[10], 11);
140     III(bbb, ccc, ddd, eee, aaa, X[14],  7);
141     III(aaa, bbb, ccc, ddd, eee, X[15],  7);
142     III(eee, aaa, bbb, ccc, ddd, X[ 8], 12);
143     III(ddd, eee, aaa, bbb, ccc, X[12],  7);
144     III(ccc, ddd, eee, aaa, bbb, X[ 4],  6);
145     III(bbb, ccc, ddd, eee, aaa, X[ 9], 15);
146     III(aaa, bbb, ccc, ddd, eee, X[ 1], 13);
147     III(eee, aaa, bbb, ccc, ddd, X[ 2], 11);
148     tmp = bb; bb = bbb; bbb = tmp;
149     HH(dd, ee, aa, bb, cc, X[ 3], 11);
150     HH(cc, dd, ee, aa, bb, X[10], 13);
151     HH(bb, cc, dd, ee, aa, X[14],  6);
152     HH(aa, bb, cc, dd, ee, X[ 4],  7);
153     HH(ee, aa, bb, cc, dd, X[ 9], 14);
154     HH(dd, ee, aa, bb, cc, X[15],  9);
155     HH(cc, dd, ee, aa, bb, X[ 8], 13);
156     HH(bb, cc, dd, ee, aa, X[ 1], 15);
157     HH(aa, bb, cc, dd, ee, X[ 2], 14);
158     HH(ee, aa, bb, cc, dd, X[ 7],  8);
159     HH(dd, ee, aa, bb, cc, X[ 0], 13);
160     HH(cc, dd, ee, aa, bb, X[ 6],  6);
161     HH(bb, cc, dd, ee, aa, X[13],  5);
162     HH(aa, bb, cc, dd, ee, X[11], 12);
163     HH(ee, aa, bb, cc, dd, X[ 5],  7);
164     HH(dd, ee, aa, bb, cc, X[12],  5);
165     HHH(ddd, eee, aaa, bbb, ccc, X[15],  9);
166     HHH(ccc, ddd, eee, aaa, bbb, X[ 5],  7);
167     HHH(bbb, ccc, ddd, eee, aaa, X[ 1], 15);
168     HHH(aaa, bbb, ccc, ddd, eee, X[ 3], 11);
169     HHH(eee, aaa, bbb, ccc, ddd, X[ 7],  8);
170     HHH(ddd, eee, aaa, bbb, ccc, X[14],  6);
171     HHH(ccc, ddd, eee, aaa, bbb, X[ 6],  6);
172     HHH(bbb, ccc, ddd, eee, aaa, X[ 9], 14);
173     HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
174     HHH(eee, aaa, bbb, ccc, ddd, X[ 8], 13);
175     HHH(ddd, eee, aaa, bbb, ccc, X[12],  5);
176     HHH(ccc, ddd, eee, aaa, bbb, X[ 2], 14);
177     HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
178     HHH(aaa, bbb, ccc, ddd, eee, X[ 0], 13);
179     HHH(eee, aaa, bbb, ccc, ddd, X[ 4],  7);
180     HHH(ddd, eee, aaa, bbb, ccc, X[13],  5);
181     tmp = cc; cc = ccc; ccc = tmp;
182     II(cc, dd, ee, aa, bb, X[ 1], 11);
183     II(bb, cc, dd, ee, aa, X[ 9], 12);
184     II(aa, bb, cc, dd, ee, X[11], 14);
185     II(ee, aa, bb, cc, dd, X[10], 15);
186     II(dd, ee, aa, bb, cc, X[ 0], 14);
187     II(cc, dd, ee, aa, bb, X[ 8], 15);
188     II(bb, cc, dd, ee, aa, X[12],  9);
189     II(aa, bb, cc, dd, ee, X[ 4],  8);
190     II(ee, aa, bb, cc, dd, X[13],  9);
191     II(dd, ee, aa, bb, cc, X[ 3], 14);
192     II(cc, dd, ee, aa, bb, X[ 7],  5);
193     II(bb, cc, dd, ee, aa, X[15],  6);
194     II(aa, bb, cc, dd, ee, X[14],  8);
195     II(ee, aa, bb, cc, dd, X[ 5],  6);
196     II(dd, ee, aa, bb, cc, X[ 6],  5);
197     II(cc, dd, ee, aa, bb, X[ 2], 12);
198     GGG(ccc, ddd, eee, aaa, bbb, X[ 8], 15);
199     GGG(bbb, ccc, ddd, eee, aaa, X[ 6],  5);
200     GGG(aaa, bbb, ccc, ddd, eee, X[ 4],  8);
201     GGG(eee, aaa, bbb, ccc, ddd, X[ 1], 11);
202     GGG(ddd, eee, aaa, bbb, ccc, X[ 3], 14);
203     GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
204     GGG(bbb, ccc, ddd, eee, aaa, X[15],  6);
205     GGG(aaa, bbb, ccc, ddd, eee, X[ 0], 14);
206     GGG(eee, aaa, bbb, ccc, ddd, X[ 5],  6);
207     GGG(ddd, eee, aaa, bbb, ccc, X[12],  9);
208     GGG(ccc, ddd, eee, aaa, bbb, X[ 2], 12);
209     GGG(bbb, ccc, ddd, eee, aaa, X[13],  9);
210     GGG(aaa, bbb, ccc, ddd, eee, X[ 9], 12);
211     GGG(eee, aaa, bbb, ccc, ddd, X[ 7],  5);
212     GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
213     GGG(ccc, ddd, eee, aaa, bbb, X[14],  8);
214     tmp = dd; dd = ddd; ddd = tmp;
215     JJ(bb, cc, dd, ee, aa, X[ 4],  9);
216     JJ(aa, bb, cc, dd, ee, X[ 0], 15);
217     JJ(ee, aa, bb, cc, dd, X[ 5],  5);
218     JJ(dd, ee, aa, bb, cc, X[ 9], 11);
219     JJ(cc, dd, ee, aa, bb, X[ 7],  6);
220     JJ(bb, cc, dd, ee, aa, X[12],  8);
221     JJ(aa, bb, cc, dd, ee, X[ 2], 13);
222     JJ(ee, aa, bb, cc, dd, X[10], 12);
223     JJ(dd, ee, aa, bb, cc, X[14],  5);
224     JJ(cc, dd, ee, aa, bb, X[ 1], 12);
225     JJ(bb, cc, dd, ee, aa, X[ 3], 13);
226     JJ(aa, bb, cc, dd, ee, X[ 8], 14);
227     JJ(ee, aa, bb, cc, dd, X[11], 11);
228     JJ(dd, ee, aa, bb, cc, X[ 6],  8);
229     JJ(cc, dd, ee, aa, bb, X[15],  5);
230     JJ(bb, cc, dd, ee, aa, X[13],  6);
231     FFF(bbb, ccc, ddd, eee, aaa, X[12] ,  8);
232     FFF(aaa, bbb, ccc, ddd, eee, X[15] ,  5);
233     FFF(eee, aaa, bbb, ccc, ddd, X[10] , 12);
234     FFF(ddd, eee, aaa, bbb, ccc, X[ 4] ,  9);
235     FFF(ccc, ddd, eee, aaa, bbb, X[ 1] , 12);
236     FFF(bbb, ccc, ddd, eee, aaa, X[ 5] ,  5);
237     FFF(aaa, bbb, ccc, ddd, eee, X[ 8] , 14);
238     FFF(eee, aaa, bbb, ccc, ddd, X[ 7] ,  6);
239     FFF(ddd, eee, aaa, bbb, ccc, X[ 6] ,  8);
240     FFF(ccc, ddd, eee, aaa, bbb, X[ 2] , 13);
241     FFF(bbb, ccc, ddd, eee, aaa, X[13] ,  6);
242     FFF(aaa, bbb, ccc, ddd, eee, X[14] ,  5);
243     FFF(eee, aaa, bbb, ccc, ddd, X[ 0] , 15);
244     FFF(ddd, eee, aaa, bbb, ccc, X[ 3] , 13);
245     FFF(ccc, ddd, eee, aaa, bbb, X[ 9] , 11);
246     FFF(bbb, ccc, ddd, eee, aaa, X[11] , 11);
247     tmp = ee; ee = eee; eee = tmp;
248     md->rmd320.state[0] += aa;
249     md->rmd320.state[1] += bb;
250     md->rmd320.state[2] += cc;
251     md->rmd320.state[3] += dd;
252     md->rmd320.state[4] += ee;
253     md->rmd320.state[5] += aaa;
254     md->rmd320.state[6] += bbb;
255     md->rmd320.state[7] += ccc;
256     md->rmd320.state[8] += ddd;
257     md->rmd320.state[9] += eee;
258     return CRYPT_OK;
259  }
260  #ifdef LTC_CLEAN_STACK
261  static int s_rmd320_compress(hash_state *md, const unsigned char *buf)
262  {
263     int err;
264     err = ss_rmd320_compress(md, buf);
265     burn_stack(sizeof(ulong32) * 27 + sizeof(int));
266     return err;
267  }
268  #endif
269  int rmd320_init(hash_state * md)
270  {
271     LTC_ARGCHK(md != NULL);
272     md->rmd320.state[0] = 0x67452301UL;
273     md->rmd320.state[1] = 0xefcdab89UL;
274     md->rmd320.state[2] = 0x98badcfeUL;
275     md->rmd320.state[3] = 0x10325476UL;
276     md->rmd320.state[4] = 0xc3d2e1f0UL;
277     md->rmd320.state[5] = 0x76543210UL;
278     md->rmd320.state[6] = 0xfedcba98UL;
<span onclick='openModal()' class='match'>279     md->rmd320.state[7] = 0x89abcdefUL;
280     md->rmd320.state[8] = 0x01234567UL;
281     md->rmd320.state[9] = 0x3c2d1e0fUL;
</span>282     md->rmd320.curlen   = 0;
283     md->rmd320.length   = 0;
284     return CRYPT_OK;
285  }
286  HASH_PROCESS(rmd320_process, s_rmd320_compress, rmd320, 64)
287  int rmd320_done(hash_state * md, unsigned char *out)
288  {
289      int i;
290      LTC_ARGCHK(md  != NULL);
291      LTC_ARGCHK(out != NULL);
292      if (md->rmd320.curlen >= sizeof(md->rmd320.buf)) {
293         return CRYPT_INVALID_ARG;
294      }
295      md->rmd320.length += md->rmd320.curlen * 8;
296      md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0x80;
297      if (md->rmd320.curlen > 56) {
298          while (md->rmd320.curlen < 64) {
299              md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0;
300          }
301          s_rmd320_compress(md, md->rmd320.buf);
302          md->rmd320.curlen = 0;
303      }
304      while (md->rmd320.curlen < 56) {
305          md->rmd320.buf[md->rmd320.curlen++] = (unsigned char)0;
306      }
307      STORE64L(md->rmd320.length, md->rmd320.buf+56);
308      s_rmd320_compress(md, md->rmd320.buf);
309      for (i = 0; i < 10; i++) {
310          STORE32L(md->rmd320.state[i], out+(4*i));
311      }
312  #ifdef LTC_CLEAN_STACK
313      zeromem(md, sizeof(hash_state));
314  #endif
315      return CRYPT_OK;
316  }
317  int rmd320_test(void)
318  {
319  #ifndef LTC_TEST
320     return CRYPT_NOP;
321  #else
322     static const struct {
323          const char *msg;
324          unsigned char hash[40];
325     } tests[] = {
326     { "",
327       { 0x22, 0xd6, 0x5d, 0x56, 0x61, 0x53, 0x6c, 0xdc, 0x75, 0xc1,
328         0xfd, 0xf5, 0xc6, 0xde, 0x7b, 0x41, 0xb9, 0xf2, 0x73, 0x25,
329         0xeb, 0xc6, 0x1e, 0x85, 0x57, 0x17, 0x7d, 0x70, 0x5a, 0x0e,
330         0xc8, 0x80, 0x15, 0x1c, 0x3a, 0x32, 0xa0, 0x08, 0x99, 0xb8 }
331     },
332     { "a",
333       { 0xce, 0x78, 0x85, 0x06, 0x38, 0xf9, 0x26, 0x58, 0xa5, 0xa5,
334         0x85, 0x09, 0x75, 0x79, 0x92, 0x6d, 0xda, 0x66, 0x7a, 0x57,
335         0x16, 0x56, 0x2c, 0xfc, 0xf6, 0xfb, 0xe7, 0x7f, 0x63, 0x54,
336         0x2f, 0x99, 0xb0, 0x47, 0x05, 0xd6, 0x97, 0x0d, 0xff, 0x5d }
337     },
338     { "abc",
339       { 0xde, 0x4c, 0x01, 0xb3, 0x05, 0x4f, 0x89, 0x30, 0xa7, 0x9d,
340         0x09, 0xae, 0x73, 0x8e, 0x92, 0x30, 0x1e, 0x5a, 0x17, 0x08,
341         0x5b, 0xef, 0xfd, 0xc1, 0xb8, 0xd1, 0x16, 0x71, 0x3e, 0x74,
342         0xf8, 0x2f, 0xa9, 0x42, 0xd6, 0x4c, 0xdb, 0xc4, 0x68, 0x2d }
343     },
344     { "message digest",
345       { 0x3a, 0x8e, 0x28, 0x50, 0x2e, 0xd4, 0x5d, 0x42, 0x2f, 0x68,
346         0x84, 0x4f, 0x9d, 0xd3, 0x16, 0xe7, 0xb9, 0x85, 0x33, 0xfa,
347         0x3f, 0x2a, 0x91, 0xd2, 0x9f, 0x84, 0xd4, 0x25, 0xc8, 0x8d,
348         0x6b, 0x4e, 0xff, 0x72, 0x7d, 0xf6, 0x6a, 0x7c, 0x01, 0x97 }
349     },
350     { "abcdefghijklmnopqrstuvwxyz",
351       { 0xca, 0xbd, 0xb1, 0x81, 0x0b, 0x92, 0x47, 0x0a, 0x20, 0x93,
352         0xaa, 0x6b, 0xce, 0x05, 0x95, 0x2c, 0x28, 0x34, 0x8c, 0xf4,
353         0x3f, 0xf6, 0x08, 0x41, 0x97, 0x51, 0x66, 0xbb, 0x40, 0xed,
354         0x23, 0x40, 0x04, 0xb8, 0x82, 0x44, 0x63, 0xe6, 0xb0, 0x09 }
355     },
356     { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
357       { 0xd0, 0x34, 0xa7, 0x95, 0x0c, 0xf7, 0x22, 0x02, 0x1b, 0xa4,
358         0xb8, 0x4d, 0xf7, 0x69, 0xa5, 0xde, 0x20, 0x60, 0xe2, 0x59,
359         0xdf, 0x4c, 0x9b, 0xb4, 0xa4, 0x26, 0x8c, 0x0e, 0x93, 0x5b,
360         0xbc, 0x74, 0x70, 0xa9, 0x69, 0xc9, 0xd0, 0x72, 0xa1, 0xac }
361     }
362     };
363     int i;
364     unsigned char tmp[40];
365     hash_state md;
366     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
367         rmd320_init(&md);
368         rmd320_process(&md, (unsigned char *)tests[i].msg, XSTRLEN(tests[i].msg));
369         rmd320_done(&md, tmp);
370         if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "RIPEMD320", i)) {
371            return CRYPT_FAIL_TESTVECTOR;
372         }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha1.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd320.c</div>
                </div>
                <div class="column column_space"><pre><code>115     md->sha1.state[3] = 0x10325476UL;
116     md->sha1.state[4] = 0xc3d2e1f0UL;
117     md->sha1.curlen = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>279     md->rmd320.state[7] = 0x89abcdefUL;
280     md->rmd320.state[8] = 0x01234567UL;
281     md->rmd320.state[9] = 0x3c2d1e0fUL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    