<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imfile.c &amp; omhttp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imfile.c &amp; omhttp.c
      </h3>
<h1 align="center">
        10.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imfile.c (9.079704%)<th>omhttp.c (12.93911%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(317-369)<td><a href="#" name="0">(185-228)</a><td align="center"><font color="#ff0000">77</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1944-1953)<td><a href="#" name="1">(1849-1858)</a><td align="center"><font color="#590000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1970-1979)<td><a href="#" name="2">(1890-1899)</a><td align="center"><font color="#560000">26</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1988-1997)<td><a href="#" name="3">(1874-1882)</a><td align="center"><font color="#450000">21</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1720-1736)<td><a href="#" name="4">(1758-1774)</a><td align="center"><font color="#450000">21</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1958-1966)<td><a href="#" name="5">(1862-1870)</a><td align="center"><font color="#3e0000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1998-2004)<td><a href="#" name="6">(1931-1936)</a><td align="center"><font color="#310000">15</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1938-1943)<td><a href="#" name="7">(1831-1836)</a><td align="center"><font color="#310000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imfile.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;pthread.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;time.h&gt;
12 #include &lt;glob.h&gt;
13 #include &lt;poll.h&gt;
14 #include &lt;json.h&gt;
15 #include &lt;fnmatch.h&gt;
16 #ifdef HAVE_SYS_INOTIFY_H
17 #include &lt;sys/inotify.h&gt;
18 #include &lt;linux/types.h&gt;
19 #endif
20 #ifdef HAVE_SYS_STAT_H
21 #	include &lt;sys/stat.h&gt;
22 #endif
23 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
24 #include &lt;port.h&gt;
25 #include &lt;sys/port.h&gt;
26 #endif
27 #include "rsyslog.h"		#include "dirty.h"
28 #include "cfsysline.h"		#include "module-template.h"	#include "srUtils.h"		#include "msg.h"
29 #include "stream.h"
30 #include "errmsg.h"
31 #include "glbl.h"
32 #include "unicode-helper.h"
33 #include "prop.h"
34 #include "stringbuf.h"
35 #include "ruleset.h"
36 #include "ratelimit.h"
37 #include "srUtils.h"
38 #include "parserif.h"
39 #include "datetime.h"
40 #include &lt;regex.h&gt;
41 #ifndef O_LARGEFILE
42 #  define O_LARGEFILE 0
43 #endif
44 #ifndef HAVE_LSEEK64
45 #  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
46 #endif
47 MODULE_TYPE_INPUT
48 MODULE_TYPE_NOKEEP
49 MODULE_CNFNAME("imfile")
50 #define FILE_ID_HASH_SIZE 20	#define FILE_ID_SIZE	512	
51 DEF_IMOD_STATIC_DATA	DEFobjCurrIf(glbl)
52 DEFobjCurrIf(strm)
53 DEFobjCurrIf(prop)
54 DEFobjCurrIf(ruleset)
55 DEFobjCurrIf(datetime)
56 extern int rs_siphash(const uint8_t *in, const size_t inlen, const uint8_t *k,
57 	uint8_t *out, const size_t outlen); 
58 static int bLegacyCnfModGlobalsPermitted;
59 #define NUM_MULTISUB 1024 #define DFLT_PollInterval 10
60 #define INIT_WDMAP_TAB_SIZE 1 #define ADD_METADATA_UNSPECIFIED -1
61 #define ULTRA_DEBUG 0
62 #ifndef GLOB_BRACE
63 	#define GLOB_BRACE 0
64 #endif
65 typedef struct per_minute_rate_limit_s per_minute_rate_limit_t;
66 struct per_minute_rate_limit_s {
67 	uint64_t maxBytesPerMinute;
68 	uint32_t maxLinesPerMinute;
69 	uint64_t bytesThisMinute; 	uint32_t linesThisMinute; 	time_t rateLimitingMinute; };
70 static struct configSettings_s {
71 	uchar *pszFileName;
72 	uchar *pszFileTag;
73 	uchar *pszStateFile;
74 	uchar *pszBindRuleset;
75 	int iPollInterval;
76 	int iPersistStateInterval;		int bPersistStateAfterSubmission;	int iFacility; 	int iSeverity;  	int readMode;  	int64 maxLinesAtOnce;		uint64_t maxBytesPerMinute; 	uint64_t maxLinesPerMinute; 	uint32_t trimLineOverBytes;  } cs;
77 struct instanceConf_s {
78 	uchar *pszFileName;
79 	uchar *pszFileName_forOldStateFile; 	uchar *pszDirName;
80 	uchar *pszFileBaseName;
81 	uchar *pszTag;
82 	size_t lenTag;
83 	uchar *pszStateFile;
84 	uchar *pszBindRuleset;
85 	int nMultiSub;
86 	per_minute_rate_limit_t perMinuteRateLimits;
87 	int iPersistStateInterval;
88 	int bPersistStateAfterSubmission;
89 	int iFacility;
90 	int iSeverity;
91 	int readTimeout;
92 	unsigned delay_perMsg;
93 	sbool bRMStateOnDel;
94 	uint8_t readMode;
95 	uchar *startRegex;
96 	uchar *endRegex;
97 	regex_t start_preg;		regex_t end_preg;		sbool discardTruncatedMsg;
98 	sbool msgDiscardingError;
99 	sbool escapeLF;
100 	sbool reopenOnTruncate;
101 	sbool addCeeTag;
102 	sbool addMetadata;
103 	sbool freshStartTail;
104 	sbool fileNotFoundError;
105 	int maxLinesAtOnce;
106 	uint32_t trimLineOverBytes;
107 	uint32_t ignoreOlderThan;
108 	int msgFlag;
109 	uchar *escapeLFString;
110 	ruleset_t *pBindRuleset;		struct instanceConf_s *next;
111 };
112 typedef struct fs_edge_s fs_edge_t;
113 typedef struct fs_node_s fs_node_t;
114 typedef struct act_obj_s act_obj_t;
115 struct act_obj_s {
116 	act_obj_t *prev;
117 	act_obj_t *next;
118 	fs_edge_t *edge;		char *name;			char *basename;			char *source_name;		int wd;
119 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
120 	struct fileinfo *pfinf;
121 	sbool bPortAssociated;
122 	int is_deleted;	#endif
123 	ratelimit_t *ratelimiter;
124 	multi_submit_t multiSub;
125 	int is_symlink;
126 };
127 struct fs_edge_s {
128 	fs_node_t *parent;		fs_node_t *node;		fs_edge_t *next;
129 	uchar *name;
130 	uchar *path;
131 	act_obj_t *active;
132 	int is_file;
133 	int ninst;			instanceConf_t **instarr;
134 };
135 struct fs_node_s {
136 	fs_edge_t *edges;		fs_node_t *root;	};
137 static rsRetVal persistStrmState(act_obj_t *);
138 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
139 static rsRetVal ATTR_NONNULL(1) pollFile(act_obj_t *act);
140 static int ATTR_NONNULL() getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path);
141 static void ATTR_NONNULL() act_obj_unlink(act_obj_t *act);
142 static uchar * ATTR_NONNULL(1, 2) getStateFileName(const act_obj_t *, uchar *, const size_t);
143 static int ATTR_NONNULL() getFullStateFileName(const uchar *const, const char *const,
144 	uchar *const pszout, const size_t ilenout);
145 #define OPMODE_POLLING 0
146 #define OPMODE_INOTIFY 1
147 #define OPMODE_FEN 2
148 struct modConfData_s {
149 	rsconf_t *pConf;		int iPollInterval;		int readTimeout;
150 	int timeoutGranularity;			instanceConf_t *root, *tail;
151 	fs_node_t *conf_tree;
152 	uint8_t opMode;
153 	sbool configSetViaV2Method;
154 	uchar *stateFileDirectory;
155 	sbool sortFiles;
156 };
157 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static modConfData_t *currModConf = NULL;
158 #ifdef HAVE_INOTIFY_INIT
159 struct wd_map_s {
160 	int wd;			act_obj_t *act; };
161 typedef struct wd_map_s wd_map_t;
162 static wd_map_t *wdmap = NULL;
163 static int nWdmap;
164 static int allocMaxWdmap;
165 static int ino_fd;	#endif 
166 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
167 struct fileinfo {
168 	struct file_obj fobj;
169 	int events;
170 	int port;
171 };
172 #endif 
173 static prop_t *pInputName = NULL;
174 static struct cnfparamdescr modpdescr[] = {
175 	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
176 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
177 	{ "timeoutgranularity", eCmdHdlrPositiveInt, 0 },
178 	{ "sortfiles", eCmdHdlrBinary, 0 },
179 	{ "statefile.directory", eCmdHdlrString, 0 },
180 	{ "normalizepath", eCmdHdlrBinary, 0 },
181 	{ "mode", eCmdHdlrGetWord, 0 }
182 };
183 static struct cnfparamblk modpblk =
184 <a name="0"></a>	{ CNFPARAMBLK_VERSION,
185 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
186 	  modpdescr
187 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	};
188 static struct cnfparamdescr inppdescr[] = {
189 	{ "file", eCmdHdlrString, CNFPARAM_REQUIRED },
190 	{ "tag", eCmdHdlrString, CNFPARAM_REQUIRED },
191 	{ "severity", eCmdHdlrSeverity, 0 },
192 	{ "facility", eCmdHdlrFacility, 0 },
193 	{ "ruleset", eCmdHdlrString, 0 },
194 	{ "readmode", eCmdHdlrInt, 0 },
195 	{ "startmsg.regex", eCmdHdlrString, 0 },
196 	{ "endmsg.regex", eCmdHdlrString, 0 },
197 	{ "discardtruncatedmsg", eCmdHdlrBinary, 0 },
198 	{ "msgdiscardingerror", eCmdHdlrBinary, 0 },
199 	{ "escapelf", eCmdHdlrBinary, 0 },
200 	{ "escapelf.replacement", eCmdHdlrString, 0 },
201 	{ "reopenontruncate", eCmdHdlrBinary, 0 },
202 	{ "maxlinesatonce", eCmdHdlrInt, 0 },
203 	{ "trimlineoverbytes", eCmdHdlrInt, 0 },
204 	{ "maxsubmitatonce", eCmdHdlrInt, 0 },
205 	{ "removestateondelete", eCmdHdlrBinary, 0 },
206 	{ "persiststateinterval", eCmdHdlrInt, 0 },
207 	{ "persiststateaftersubmission", eCmdHdlrBinary, 0 },
208 	{ "deletestateonfiledelete", eCmdHdlrBinary, 0 },
209 	{ "delay.message", eCmdHdlrNonNegInt, 0 },
210 	{ "addmetadata", eCmdHdlrBinary, 0 },
211 	{ "addceetag", eCmdHdlrBinary, 0 },
212 	{ "statefile", eCmdHdlrString, CNFPARAM_DEPRECATED },
213 	{ "readtimeout", eCmdHdlrNonNegInt, 0 },
214 	{ "freshstarttail", eCmdHdlrBinary, 0},
215 	{ "filenotfounderror", eCmdHdlrBinary, 0},
216 	{ "needparse", eCmdHdlrBinary, 0},
217 	{ "ignoreolderthan", eCmdHdlrInt, 0},
218 	{ "maxbytesperminute", eCmdHdlrInt, 0},
219 	{ "maxlinesperminute", eCmdHdlrInt, 0}
220 };
221 static struct cnfparamblk inppblk =
222 	{ CNFPARAMBLK_VERSION,
223 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
224 	  inppdescr
225 	};
226 #include "im-helper.h" 
227 #define ENABLE_V1_STATE_FILE_FORMAT_SUPPORT 1
228 #ifdef ENABLE_V1_STATE_FILE_FORMAT_SUPPORT
229 static uchar * ATTR_NONNULL(1, 2)</b></font>
230 OLD_getStateFileName(const instanceConf_t *const inst,
231 	 uchar *const __restrict__ buf,
232 	 const size_t lenbuf)
233 {
234 	DBGPRINTF("OLD_getStateFileName trying '%s'\n", inst-&gt;pszFileName_forOldStateFile);
235 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%s", inst-&gt;pszFileName_forOldStateFile);
236 	buf[lenbuf-1] = '\0'; 	uchar *p = buf;
237 	for( ; *p ; ++p) {
238 		if(*p == '/')
239 			*p = '-';
240 	}
241 	return buf;
242 }
243 static const uchar *
244 getStateFileDir(void)
245 {
246 	const uchar *wrkdir;
247 	assert(currModConf != NULL);
248 	if(currModConf-&gt;stateFileDirectory == NULL) {
249 		wrkdir = glblGetWorkDirRaw(currModConf-&gt;pConf);
250 	} else {
251 		wrkdir = currModConf-&gt;stateFileDirectory;
252 	}
253 	return(wrkdir);
254 }
255 static rsRetVal ATTR_NONNULL(1)
256 OLD_openFileWithStateFile(act_obj_t *const act)
257 {
258 	DEFiRet;
259 	strm_t *psSF = NULL;
260 	uchar pszSFNam[MAXFNAME];
261 	size_t lenSFNam;
262 	struct stat stat_buf;
263 	uchar statefile[MAXFNAME];
264 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
265 	uchar *const statefn = OLD_getStateFileName(inst, statefile, sizeof(statefile));
266 	DBGPRINTF("OLD_openFileWithStateFile: trying to open state for '%s', state file '%s'\n",
267 		  act-&gt;name, statefn);
268 	lenSFNam = getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
269 	if(stat((char*) pszSFNam, &amp;stat_buf) == -1) {
270 		if(errno == ENOENT) {
271 			DBGPRINTF("OLD_openFileWithStateFile: NO state file (%s) exists for '%s'\n",
272 				pszSFNam, act-&gt;name);
273 			ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
274 		} else {
275 			char errStr[1024];
276 			rs_strerror_r(errno, errStr, sizeof(errStr));
277 			DBGPRINTF("OLD_openFileWithStateFile: error trying to access state "
278 				"file for '%s':%s\n", act-&gt;name, errStr);
279 			ABORT_FINALIZE(RS_RET_IO_ERROR);
280 		}
281 	}
282 	DBGPRINTF("old state file found - instantiating from it\n");
283 	CHKiRet(strm.Construct(&amp;psSF));
284 	CHKiRet(strm.SettOperationsMode(psSF, STREAMMODE_READ));
285 	CHKiRet(strm.SetsType(psSF, STREAMTYPE_FILE_SINGLE));
286 	CHKiRet(strm.SetFName(psSF, pszSFNam, lenSFNam));
287 	CHKiRet(strm.SetFileNotFoundError(psSF, inst-&gt;fileNotFoundError));
288 	CHKiRet(strm.ConstructFinalize(psSF));
289 	CHKiRet(obj.Deserialize(&amp;act-&gt;pStrm, (uchar*) "strm", psSF, NULL, act));
290 	free(act-&gt;pStrm-&gt;pszFName);
291 	CHKmalloc(act-&gt;pStrm-&gt;pszFName = ustrdup(act-&gt;name));
292 	strm.CheckFileChange(act-&gt;pStrm);
293 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
294 	persistStrmState(act);
295 	unlink((char*)pszSFNam);
296 finalize_it:
297 	if(psSF != NULL)
298 		strm.Destruct(&amp;psSF);
299 	RETiRet;
300 }
301 #endif 
302 #if 0 static const char * ATTR_NONNULL()
303 gen_full_name(const char *const dirname, const char *const name)
304 {
305 	const size_t len_full_name = strlen(dirname) + 1 + strlen(name) + 1;
306 	char *const full_name = malloc(len_full_name);
307 	if(full_name == NULL)
308 		return NULL;
309 	snprintf(full_name, len_full_name, "%s/%s", dirname, name);
310 	return full_name;
311 }
312 #endif
313 #ifdef HAVE_INOTIFY_INIT
314 #if ULTRA_DEBUG == 1
315 static void
316 dbg_wdmapPrint(const char *msg)
317 {
318 	int i;
319 	DBGPRINTF("%s\n", msg);
320 	for(i = 0 ; i &lt; nWdmap ; ++i)
321 		DBGPRINTF("wdmap[%d]: wd: %d, act %p, name: %s\n",
322 			i, wdmap[i].wd, wdmap[i].act, wdmap[i].act-&gt;name);
323 }
324 #endif
325 static rsRetVal
326 wdmapInit(void)
327 {
328 	DEFiRet;
329 	free(wdmap);
330 	CHKmalloc(wdmap = malloc(sizeof(wd_map_t) * INIT_WDMAP_TAB_SIZE));
331 	allocMaxWdmap = INIT_WDMAP_TAB_SIZE;
332 	nWdmap = 0;
333 finalize_it:
334 	RETiRet;
335 }
336 static rsRetVal
337 wdmapAdd(int wd, act_obj_t *const act)
338 {
339 	wd_map_t *newmap;
340 	int newmapsize;
341 	int i;
342 	DEFiRet;
343 	for(i = nWdmap-1 ; i &gt;= 0 &amp;&amp; wdmap[i].wd &gt; wd ; --i)
344 		; 		if(i &gt;= 0 &amp;&amp; wdmap[i].wd == wd) {
345 		LogError(0, RS_RET_INTERNAL_ERROR, "imfile: wd %d already in wdmap!", wd);
346 		ABORT_FINALIZE(RS_RET_FILE_ALREADY_IN_TABLE);
347 	}
348 	++i;
349 	if(nWdmap == allocMaxWdmap) {
350 		newmapsize = 2 * allocMaxWdmap;
351 		CHKmalloc(newmap = realloc(wdmap, sizeof(wd_map_t) * newmapsize));
352 		wdmap = newmap;
353 		allocMaxWdmap = newmapsize;
354 	}
355 	if(i &lt; nWdmap) {
356 		memmove(wdmap + i + 1, wdmap + i, sizeof(wd_map_t) * (nWdmap - i));
357 	}
358 	wdmap[i].wd = wd;
359 	wdmap[i].act = act;
360 	++nWdmap;
361 	DBGPRINTF("add wdmap[%d]: wd %d, act obj %p, path %s\n", i, wd, act, act-&gt;name);
362 finalize_it:
363 	RETiRet;
364 }
365 static int
366 in_setupWatch(act_obj_t *const act, const int is_file)
367 {
368 	int wd = -1;
369 	if(runModConf-&gt;opMode != OPMODE_INOTIFY)
370 		goto done;
371 	wd = inotify_add_watch(ino_fd, act-&gt;name,
372 		(is_file) ? IN_MODIFY|IN_DONT_FOLLOW : IN_CREATE|IN_DELETE|IN_MOVED_FROM|IN_MOVED_TO);
373 	if(wd &lt; 0) {
374 		if (errno == EACCES) { 			DBGPRINTF("imfile: permission denied when adding watch for '%s'\n", act-&gt;name);
375 		} else {
376 			LogError(errno, RS_RET_IO_ERROR, "imfile: cannot watch object '%s'", act-&gt;name);
377 		}
378 		goto done;
379 	}
380 	wdmapAdd(wd, act);
381 	DBGPRINTF("in_setupWatch: watch %d added for %s(object %p)\n", wd, act-&gt;name, act);
382 done:	return wd;
383 }
384 static int
385 wdmap_cmp(const void *k, const void *a)
386 {
387 	int key = *((int*) k);
388 	wd_map_t *etry = (wd_map_t*) a;
389 	if(key &lt; etry-&gt;wd)
390 		return -1;
391 	else if(key &gt; etry-&gt;wd)
392 		return 1;
393 	else
394 		return 0;
395 }
396 static wd_map_t *
397 wdmapLookup(int wd)
398 {
399 	return bsearch(&amp;wd, wdmap, nWdmap, sizeof(wd_map_t), wdmap_cmp);
400 }
401 static rsRetVal
402 wdmapDel(const int wd)
403 {
404 	int i;
405 	DEFiRet;
406 	for(i = 0 ; i &lt; nWdmap &amp;&amp; wdmap[i].wd &lt; wd ; ++i)
407 		; 		if(i == nWdmap ||  wdmap[i].wd != wd) {
408 		DBGPRINTF("wd %d shall be deleted but not in wdmap!\n", wd);
409 		FINALIZE;
410 	}
411 	if(i &lt; nWdmap-1) {
412 		memmove(wdmap + i, wdmap + i + 1, sizeof(wd_map_t) * (nWdmap - i - 1));
413 	}
414 	--nWdmap;
415 	DBGPRINTF("wd %d deleted, was idx %d\n", wd, i);
416 finalize_it:
417 	RETiRet;
418 }
419 #endif 
420 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
421 static void ATTR_NONNULL()
422 fen_setupWatch(act_obj_t *const act)
423 {
424 	DBGPRINTF("fen_setupWatch: enter, opMode %d\n", runModConf-&gt;opMode);
425 	if(runModConf-&gt;opMode != OPMODE_FEN)
426 		goto done;
427 	DBGPRINTF("fen_setupWatch: %s\n", act-&gt;name);
428 	if(act-&gt;pfinf == NULL) {
429 		act-&gt;pfinf = malloc(sizeof(struct fileinfo));
430 		if (act-&gt;pfinf == NULL) {
431 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
432 				"for fileinfo failed ");
433 			goto done;
434 		}
435 		if ((act-&gt;pfinf-&gt;fobj.fo_name = strdup(act-&gt;name)) == NULL) {
436 			LogError(errno, RS_RET_OUT_OF_MEMORY, "imfile: fen_setupWatch alloc memory "
437 				"for strdup failed ");
438 			free(act-&gt;pfinf);
439 			act-&gt;pfinf = NULL;
440 			goto done;
441 		}
442 		act-&gt;pfinf-&gt;events = FILE_MODIFIED;
443 		act-&gt;pfinf-&gt;port = glport;
444 		act-&gt;bPortAssociated = 0;
445 	}
446 	DBGPRINTF("fen_setupWatch: bPortAssociated %d\n", act-&gt;bPortAssociated);
447 	if(act-&gt;bPortAssociated) {
448 		goto done;
449 	}
450 	struct stat fileInfo;
451 	const int r = stat(act-&gt;name, &amp;fileInfo);
452 	if(r == -1) { 		DBGPRINTF("fen_setupWatch: file gone away, no watch: '%s'\n", act-&gt;name);
453 		goto done;
454 	}
455 	act-&gt;pfinf-&gt;fobj.fo_atime = fileInfo.st_atim;
456 	act-&gt;pfinf-&gt;fobj.fo_mtime = fileInfo.st_mtim;
457 	act-&gt;pfinf-&gt;fobj.fo_ctime = fileInfo.st_ctim;
458 	if(port_associate(glport, PORT_SOURCE_FILE, (uintptr_t)&amp;(act-&gt;pfinf-&gt;fobj),
459 				act-&gt;pfinf-&gt;events, (void *)act) == -1) {
460 		LogError(errno, RS_RET_SYS_ERR, "fen_setupWatch: Failed to associate port for file "
461 			": %s\n", act-&gt;pfinf-&gt;fobj.fo_name);
462 		goto done;
463 	} else {
464 		DBGPRINTF("fen_setupWatch: associated port for file %s\n", act-&gt;name);
465 		act-&gt;bPortAssociated = 1;
466 	}
467 	DBGPRINTF("in_setupWatch: fen association added for %s\n", act-&gt;name);
468 done:	return;
469 }
470 #else
471 static void ATTR_NONNULL()
472 fen_setupWatch(act_obj_t *const act __attribute__((unused)))
473 {
474 	DBGPRINTF("fen_setupWatch: DUMMY CALLED - not on Solaris?\n");
475 }
476 #endif 
477 static void
478 fs_node_print(const fs_node_t *const node, const int level)
479 {
480 	fs_edge_t *chld;
481 	act_obj_t *act;
482 	dbgprintf("node print[%2.2d]: %p edges:\n", level, node);
483 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
484 		dbgprintf("node print[%2.2d]:     child %p '%s' isFile %d, path: '%s'\n",
485 			level, chld-&gt;node, chld-&gt;name, chld-&gt;is_file, chld-&gt;path);
486 		for(int i = 0 ; i &lt; chld-&gt;ninst ; ++i) {
487 			dbgprintf("\tinst: %p\n", chld-&gt;instarr[i]);
488 		}
489 		for(act = chld-&gt;active ; act != NULL ; act = act-&gt;next) {
490 			dbgprintf("\tact : %p\n", act);
491 			dbgprintf("\tact : %p: name '%s', wd: %d\n",
492 				act, act-&gt;name, act-&gt;wd);
493 		}
494 	}
495 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
496 		fs_node_print(chld-&gt;node, level+1);
497 	}
498 }
499 static sbool
500 isIgnoreOlderFile(const instanceConf_t *const inst, const char *const name)
501 {
502 	if (inst-&gt;ignoreOlderThan)
503 	{
504 		struct stat stat_buf;
505 		time_t tt;
506 		datetime.GetTime(&amp;tt);
507 		if (stat((char *)name, &amp;stat_buf) == 0 &amp;&amp; difftime(tt, stat_buf.st_mtime) &gt; inst-&gt;ignoreOlderThan) {
508 			return 1;
509 		}
510 	}
511 	return 0;
512 }
513 static rsRetVal ATTR_NONNULL(1,2)
514 act_obj_add(fs_edge_t *const edge, const char *const name, const int is_file,
515 	const ino_t ino, const int is_symlink, const char *const source)
516 {
517 	act_obj_t *act = NULL;
518 	char basename[MAXFNAME];
519 	DEFiRet;
520 	int fd = -1;
521 	DBGPRINTF("act_obj_add: edge %p, name '%s' (source '%s')\n", edge, name, source? source : "---");
522 	if (isIgnoreOlderFile(edge-&gt;instarr[0], name)) {
523 		ABORT_FINALIZE(RS_RET_ERR);
524 	}
525 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
526 		if(!strcmp(act-&gt;name, name)) {
527 			if (!source || !act-&gt;source_name || !strcmp(act-&gt;source_name, source)) {
528 				DBGPRINTF("active object '%s' already exists in '%s' - no need to add\n",
529 					name, edge-&gt;path);
530 				FINALIZE;
531 			}
532 		}
533 	}
534 	DBGPRINTF("need to add new active object '%s' in '%s' - checking if accessible\n", name, edge-&gt;path);
535 	fd = open(name, O_RDONLY | O_CLOEXEC);
536 	if(fd &lt; 0) {
537 		if (is_file) {
538 			LogError(errno, RS_RET_ERR, "imfile: error accessing file '%s'", name);
539 		} else { 			DBGPRINTF("imfile: error accessing directory '%s'", name);
540 		}
541 		ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
542 	}
543 	DBGPRINTF("add new active object '%s' in '%s'\n", name, edge-&gt;path);
544 	CHKmalloc(act = calloc(sizeof(act_obj_t), 1));
545 	CHKmalloc(act-&gt;name = strdup(name));
546 	if (-1 == getBasename((uchar*)basename, (uchar*)name)) {
547 		CHKmalloc(act-&gt;basename = strdup(name)); 	} else {
548 		CHKmalloc(act-&gt;basename = strdup(basename));
549 	}
550 	act-&gt;edge = edge;
551 	act-&gt;ino = ino;
552 	act-&gt;fd = fd;
553 	act-&gt;file_id[0] = '\0';
554 	act-&gt;file_id_prev[0] = '\0';
555 	act-&gt;is_symlink = is_symlink;
556 	act-&gt;ratelimiter = NULL;
557 	if (source) { 		CHKmalloc(act-&gt;source_name = strdup(source));
558 	} else {
559 		act-&gt;source_name = NULL;
560 	}
561 	#ifdef HAVE_INOTIFY_INIT
562 	act-&gt;wd = in_setupWatch(act, is_file);
563 	#endif
564 	fen_setupWatch(act);
565 	if(is_file &amp;&amp; !is_symlink) {
566 		const instanceConf_t *const inst = edge-&gt;instarr[0];		CHKiRet(ratelimitNew(&amp;act-&gt;ratelimiter, "imfile", name));
567 		CHKmalloc(act-&gt;multiSub.ppMsgs = malloc(inst-&gt;nMultiSub * sizeof(smsg_t *)));
568 		act-&gt;multiSub.maxElem = inst-&gt;nMultiSub;
569 		act-&gt;multiSub.nElem = 0;
570 		pollFile(act);
571 	}
572 	if(edge-&gt;active != NULL) {
573 		edge-&gt;active-&gt;prev = act;
574 	}
575 	act-&gt;next = edge-&gt;active;
576 	edge-&gt;active = act;
577 finalize_it:
578 	if(iRet != RS_RET_OK) {
579 		if(act != NULL) {
580 			if (act-&gt;ratelimiter != NULL)
581 				ratelimitDestruct(act-&gt;ratelimiter);
582 			free(act-&gt;name);
583 			free(act);
584 		}
585 		if(fd != -1) {
586 			close(fd);
587 		}
588 	}
589 	RETiRet;
590 }
591 static void
592 detect_updates(fs_edge_t *const edge)
593 {
594 	act_obj_t *act;
595 	struct stat fileInfo;
596 	int restart = 0;
597 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
598 		DBGPRINTF("detect_updates checking active obj '%s'\n", act-&gt;name);
599 		const int r = lstat(act-&gt;name, &amp;fileInfo);
600 		if(r == -1) { 			DBGPRINTF("object gone away, unlinking: '%s'\n", act-&gt;name);
601 			act_obj_unlink(act);
602 			restart = 1;
603 			break;
604 		} else if(fileInfo.st_ino != act-&gt;ino) {
605 			DBGPRINTF("file '%s' inode changed from %llu to %llu, unlinking from "
606 				"internal lists\n", act-&gt;name, (long long unsigned) act-&gt;ino,
607 				(long long unsigned) fileInfo.st_ino);
608 			if(act-&gt;pStrm != NULL) {
609 				strmSet_checkRotation(act-&gt;pStrm, STRM_ROTATION_DO_NOT_CHECK);
610 			}
611 			act_obj_unlink(act);
612 			restart = 1;
613 			break;
614 		}
615 	}
616 	if (restart) {
617 		detect_updates(edge);
618 	}
619 }
620 static void ATTR_NONNULL()
621 poll_active_files(fs_edge_t *const edge)
622 {
623 	if(   runModConf-&gt;opMode != OPMODE_POLLING
624 	   || !edge-&gt;is_file
625 	   || glbl.GetGlobalInputTermState() != 0) {
626 		return;
627 	}
628 	act_obj_t *act;
629 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
630 		fen_setupWatch(act);
631 		DBGPRINTF("poll_active_files: polling '%s'\n", act-&gt;name);
632 		pollFile(act);
633 	}
634 }
635 static rsRetVal ATTR_NONNULL()
636 process_symlink(fs_edge_t *const chld, const char *symlink)
637 {
638 	DEFiRet;
639 	char *target;
640 	CHKmalloc(target = realpath(symlink, NULL));
641 	struct stat fileInfo;
642 	if(lstat(target, &amp;fileInfo) != 0) {
643 		LogError(errno, RS_RET_ERR,	"imfile: process_symlink: cannot stat file '%s' - ignored", target);
644 		FINALIZE;
645 	}
646 	const int is_file = (S_ISREG(fileInfo.st_mode));
647 	DBGPRINTF("process_symlink:  found '%s', File: %d (config file: %d), symlink: %d\n",
648 		target, is_file, chld-&gt;is_file, 0);
649 	if (act_obj_add(chld, target, is_file, fileInfo.st_ino, 0, symlink) == RS_RET_OK) {
650 		uint idx = ustrlen(chld-&gt;active-&gt;name) - ustrlen(chld-&gt;active-&gt;basename);
651 		if (idx) { 			char parent[MAXFNAME];
652 			idx--; 			memcpy(parent, chld-&gt;active-&gt;name, idx);
653 			parent[idx] = '\0';
654 			if(lstat(parent, &amp;fileInfo) != 0) {
655 				LogError(errno, RS_RET_ERR,
656 					"imfile: process_symlink: cannot stat directory '%s' - ignored", parent);
657 				FINALIZE;
658 			}
659 			if (chld-&gt;parent-&gt;root-&gt;edges) {
660 				DBGPRINTF("process_symlink: adding parent '%s' of target '%s'\n", parent, target);
661 				act_obj_add(chld-&gt;parent-&gt;root-&gt;edges, parent, 0, fileInfo.st_ino, 0, NULL);
662 			}
663 		}
664 	}
665 finalize_it:
666 	free(target);
667 	RETiRet;
668 }
669 static void ATTR_NONNULL()
670 poll_tree(fs_edge_t *const chld)
671 {
672 	struct stat fileInfo;
673 	glob_t files;
674 	int need_globfree = 0;
675 	int issymlink;
676 	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld-&gt;name, chld-&gt;path);
677 	detect_updates(chld);
678 	const int ret = glob((char*)chld-&gt;path, runModConf-&gt;sortFiles|GLOB_BRACE, NULL, &amp;files);
679 	need_globfree = 1;
680 	DBGPRINTF("poll_tree: glob returned %d\n", ret);
681 	if(ret == 0) {
682 		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc);
683 		for(unsigned i = 0 ; i &lt; files.gl_pathc ; i++) {
684 			if(glbl.GetGlobalInputTermState() != 0) {
685 				goto done;
686 			}
687 			char *const file = files.gl_pathv[i];
688 			if(lstat(file, &amp;fileInfo) != 0) {
689 				LogError(errno, RS_RET_ERR,
690 					"imfile: poll_tree cannot stat file '%s' - ignored", file);
691 				continue;
692 			}
693 			if (S_ISLNK(fileInfo.st_mode)) {
694 				rsRetVal slink_ret = process_symlink(chld, file);
695 				if (slink_ret != RS_RET_OK) {
696 					continue;
697 				}
698 				issymlink = 1;
699 			} else {
700 				issymlink = 0;
701 			}
702 			const int is_file = (S_ISREG(fileInfo.st_mode) || issymlink);
703 			DBGPRINTF("poll_tree:  found '%s', File: %d (config file: %d), symlink: %d\n",
704 				file, is_file, chld-&gt;is_file, issymlink);
705 			if(!is_file &amp;&amp; S_ISREG(fileInfo.st_mode)) {
706 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
707 					"imfile: '%s' is neither a regular file, symlink, nor a "
708 					"directory - ignored", file);
709 				continue;
710 			}
711 			if(!issymlink &amp;&amp; (chld-&gt;is_file != is_file)) {
712 				LogMsg(0, RS_RET_ERR, LOG_WARNING,
713 					"imfile: '%s' is %s but %s expected - ignored",
714 					file, (is_file) ? "FILE" : "DIRECTORY",
715 					(chld-&gt;is_file) ? "FILE" : "DIRECTORY");
716 				continue;
717 			}
718 			act_obj_add(chld, file, is_file, fileInfo.st_ino, issymlink, NULL);
719 		}
720 	}
721 	poll_active_files(chld);
722 done:
723 	if(need_globfree) {
724 		globfree(&amp;files);
725 	}
726 	return;
727 }
728 #ifdef HAVE_INOTIFY_INIT static void ATTR_NONNULL()
729 poll_timeouts(fs_edge_t *const edge)
730 {
731 	if(edge-&gt;is_file) {
732 		act_obj_t *act;
733 		for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
734 			if(act-&gt;pStrm &amp;&amp; strmReadMultiLine_isTimedOut(act-&gt;pStrm)) {
735 				DBGPRINTF("timeout occurred on %s\n", act-&gt;name);
736 				pollFile(act);
737 			}
738 		}
739 	}
740 }
741 #endif
742 static void
743 act_obj_destroy(act_obj_t *const act, const int is_deleted)
744 {
745 	uchar *statefn;
746 	uchar statefile[MAXFNAME];
747 	uchar toDel[MAXFNAME];
748 	if(act == NULL)
749 		return;
750 	DBGPRINTF("act_obj_destroy: act %p '%s' (source '%s'), wd %d, pStrm %p, is_deleted %d, in_move %d\n",
751 		act, act-&gt;name, act-&gt;source_name? act-&gt;source_name : "---", act-&gt;wd, act-&gt;pStrm, is_deleted,
752 		act-&gt;in_move);
753 	if(act-&gt;is_symlink &amp;&amp; is_deleted) {
754 		act_obj_t *target_act;
755 		for(target_act = act-&gt;edge-&gt;active ; target_act != NULL ; target_act = target_act-&gt;next) {
756 			if(target_act-&gt;source_name &amp;&amp; !strcmp(target_act-&gt;source_name, act-&gt;name)) {
757 				DBGPRINTF("act_obj_destroy: unlinking slink target %s of %s "
758 						"symlink\n", target_act-&gt;name, act-&gt;name);
759 				act_obj_unlink(target_act);
760 				break;
761 			}
762 		}
763 	}
764 	if(act-&gt;pStrm != NULL) {
765 		const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];		pollFile(act); 		if(inst-&gt;bRMStateOnDel) {
766 			statefn = getStateFileName(act, statefile, sizeof(statefile));
767 			getFullStateFileName(statefn, act-&gt;file_id, toDel, sizeof(toDel)); 			statefn = toDel;
768 		}
769 		persistStrmState(act);
770 		strm.Destruct(&amp;act-&gt;pStrm);
771 		if(is_deleted &amp;&amp; !act-&gt;in_move &amp;&amp; inst-&gt;bRMStateOnDel) {
772 			DBGPRINTF("act_obj_destroy: deleting state file %s\n", statefn);
773 			unlink((char*)statefn);
774 		}
775 	}
776 	if(act-&gt;ratelimiter != NULL) {
777 		ratelimitDestruct(act-&gt;ratelimiter);
778 	}
779 	#ifdef HAVE_INOTIFY_INIT
780 	if(act-&gt;wd != -1) {
781 		inotify_rm_watch(ino_fd, act-&gt;wd);
782 		wdmapDel(act-&gt;wd);
783 	}
784 	#endif
785 	if(act-&gt;fd &gt;= 0) {
786 		close(act-&gt;fd);
787 	}
788 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
789 	if(act-&gt;pfinf != NULL) {
790 		free(act-&gt;pfinf-&gt;fobj.fo_name);
791 		free(act-&gt;pfinf);
792 	}
793 	#endif
794 	free(act-&gt;basename);
795 	free(act-&gt;source_name);
796 	free(act-&gt;multiSub.ppMsgs);
797 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE)
798 		act-&gt;is_deleted = 1;
799 	#else
800 		free(act-&gt;name);
801 		free(act);
802 	#endif
803 }
804 static void
805 act_obj_destroy_all(act_obj_t *act)
806 {
807 	if(act == NULL)
808 		return;
809 	DBGPRINTF("act_obj_destroy_all: act %p '%s', wd %d, pStrm %p\n", act, act-&gt;name, act-&gt;wd, act-&gt;pStrm);
810 	while(act != NULL) {
811 		act_obj_t *const toDel = act;
812 		act = act-&gt;next;
813 		act_obj_destroy(toDel, 0);
814 	}
815 }
816 #if 0
817 static void
818 chk_active(const act_obj_t *act, const act_obj_t *const deleted)
819 {
820 	while(act != NULL) {
821 		DBGPRINTF("chk_active %p vs %p\n", act, deleted);
822 		if(act-&gt;prev == deleted)
823 			DBGPRINTF("chk_active %p prev points to %p\n", act, deleted);
824 		if(act-&gt;next == deleted)
825 			DBGPRINTF("chk_active %p next points to %p\n", act, deleted);
826 		act = act-&gt;next;
827 		DBGPRINTF("chk_active next %p\n", act);
828 	}
829 }
830 #endif
831 static void ATTR_NONNULL()
832 act_obj_unlink(act_obj_t *act)
833 {
834 	DBGPRINTF("act_obj_unlink %p: %s, pStrm %p\n", act, act-&gt;name, act-&gt;pStrm);
835 	if(act-&gt;prev == NULL) {
836 		act-&gt;edge-&gt;active = act-&gt;next;
837 	} else {
838 		act-&gt;prev-&gt;next = act-&gt;next;
839 	}
840 	if(act-&gt;next != NULL) {
841 		act-&gt;next-&gt;prev = act-&gt;prev;
842 	}
843 	act_obj_destroy(act, 1);
844 	act = NULL;
845 }
846 static void
847 fs_node_destroy(fs_node_t *const node)
848 {
849 	fs_edge_t *edge;
850 	DBGPRINTF("node destroy: %p edges:\n", node);
851 	for(edge = node-&gt;edges ; edge != NULL ; ) {
852 		fs_node_destroy(edge-&gt;node);
853 		fs_edge_t *const toDel = edge;
854 		edge = edge-&gt;next;
855 		act_obj_destroy_all(toDel-&gt;active);
856 		free(toDel-&gt;name);
857 		free(toDel-&gt;path);
858 		free(toDel-&gt;instarr);
859 		free(toDel);
860 	}
861 	free(node);
862 }
863 static void ATTR_NONNULL(1, 2)
864 fs_node_walk(fs_node_t *const node,
865 	void (*f_usr)(fs_edge_t*const))
866 {
867 	DBGPRINTF("node walk: %p edges:\n", node);
868 	fs_edge_t *edge;
869 	for(edge = node-&gt;edges ; edge != NULL ; edge = edge-&gt;next) {
870 		DBGPRINTF("node walk: child %p '%s'\n", edge-&gt;node, edge-&gt;name);
871 		f_usr(edge);
872 		fs_node_walk(edge-&gt;node, f_usr);
873 	}
874 }
875 static rsRetVal
876 fs_node_add(fs_node_t *const node,
877 	fs_node_t *const source,
878 	const uchar *const toFind,
879 	const size_t pathIdx,
880 	instanceConf_t *const inst)
881 {
882 	DEFiRet;
883 	fs_edge_t *newchld = NULL;
884 	int i;
885 	DBGPRINTF("fs_node_add(%p, '%s') enter, idx %zd\n",
886 		node, toFind+pathIdx, pathIdx);
887 	assert(toFind[0] != '\0');
888 	for(i = pathIdx ; (toFind[i] != '\0') &amp;&amp; (toFind[i] != '/') ; ++i)
889 	const int isFile = (toFind[i] == '\0') ? 1 : 0;
890 	uchar ourPath[PATH_MAX];
891 	if(i == 0) {
892 		ourPath[0] = '/';
893 		ourPath[1] = '\0';
894 	} else {
895 		memcpy(ourPath, toFind, i);
896 		ourPath[i] = '\0';
897 	}
898 	const size_t nextPathIdx = i+1;
899 	const size_t len = i - pathIdx;
900 	uchar name[PATH_MAX];
901 	memcpy(name, toFind+pathIdx, len);
902 	name[len] = '\0';
903 	DBGPRINTF("fs_node_add: name '%s'\n", name);
904 	node-&gt;root = source;
905 	fs_edge_t *chld;
906 	for(chld = node-&gt;edges ; chld != NULL ; chld = chld-&gt;next) {
907 		if(!ustrcmp(chld-&gt;name, name)) {
908 			DBGPRINTF("fs_node_add(%p, '%s') found '%s'\n", chld-&gt;node, toFind, name);
909 			instanceConf_t **instarr_new = realloc(chld-&gt;instarr,
910 							sizeof(instanceConf_t*) * (chld-&gt;ninst+1));
911 			CHKmalloc(instarr_new);
912 			chld-&gt;instarr = instarr_new;
913 			chld-&gt;ninst++;
914 			chld-&gt;instarr[chld-&gt;ninst-1] = inst;
915 			if(!isFile) {
916 				CHKiRet(fs_node_add(chld-&gt;node, node, toFind, nextPathIdx, inst));
917 			}
918 			FINALIZE;
919 		}
920 	}
921 	DBGPRINTF("fs_node_add(%p, '%s') did not find '%s' - adding it\n",
922 		node, toFind, name);
923 	CHKmalloc(newchld = calloc(sizeof(fs_edge_t), 1));
924 	CHKmalloc(newchld-&gt;name = ustrdup(name));
925 	CHKmalloc(newchld-&gt;node = calloc(sizeof(fs_node_t), 1));
926 	CHKmalloc(newchld-&gt;path = ustrdup(ourPath));
927 	CHKmalloc(newchld-&gt;instarr = calloc(sizeof(instanceConf_t*), 1));
928 	newchld-&gt;instarr[0] = inst;
929 	newchld-&gt;is_file = isFile;
930 	newchld-&gt;ninst = 1;
931 	newchld-&gt;parent = node;
932 	DBGPRINTF("fs_node_add(%p, '%s') returns %p\n", node, toFind, newchld-&gt;node);
933 	if(!isFile) {
934 		CHKiRet(fs_node_add(newchld-&gt;node, node, toFind, nextPathIdx, inst));
935 	}
936 	newchld-&gt;next = node-&gt;edges;
937 	node-&gt;edges = newchld;
938 finalize_it:
939 	if(iRet != RS_RET_OK) {
940 		if(newchld != NULL) {
941 		free(newchld-&gt;name);
942 		free(newchld-&gt;node);
943 		free(newchld-&gt;path);
944 		free(newchld-&gt;instarr);
945 		free(newchld);
946 		}
947 	}
948 	RETiRet;
949 }
950 static int ATTR_NONNULL()
951 getFullStateFileName(const uchar *const pszstatefile,
952 	const char *const file_id,
953 	uchar *const pszout,
954 	const size_t ilenout)
955 {
956 	int lenout;
957 	const uchar* pszstatedir;
958 	pszstatedir = getStateFileDir();
959 	lenout = snprintf((char*)pszout, ilenout, "%s/%s%s%s",
960 		(char*) (pszstatedir == NULL ? "." : (char*) pszstatedir), (char*)pszstatefile,
961 		(*file_id == '\0') ? "" : ":", file_id);
962 	return lenout;
963 }
964 #if defined(__clang__)
965 #pragma GCC diagnostic ignored "-Wunknown-attributes"
966 #endif
967 static void __attribute__((nonnull(1,3)))
968 #if defined(__clang__)
969 __attribute__((no_sanitize("unsigned-integer-overflow")))
970 #endif
971 get_file_id_hash(const char *data, size_t lendata,
972 	char *const hash_str, const size_t len_hash_str)
973 {
974 	assert(len_hash_str &gt;= 17); 
975 	size_t i;
976 	uint8_t out[8], k[16];
977 	for (i = 0; i &lt; 16; ++i)
978 		k[i] = i;
979 	memset(out, 0, sizeof(out));
980 	rs_siphash((const uint8_t *)data, lendata, k, out, 8);
981 	for(i = 0 ; i &lt; 8 ; ++i) {
982 		if(2 * i+1 &gt;= len_hash_str)
983 			break;
984 		snprintf(hash_str+(2*i), 3, "%2.2x", out[i]);
985 	}
986 }
987 static void ATTR_NONNULL(1)
988 getFileID(act_obj_t *const act)
989 {
990 	char tmp_id[FILE_ID_HASH_SIZE];
991 	strncpy(tmp_id, (const char*)act-&gt;file_id, FILE_ID_HASH_SIZE);
992 	act-&gt;file_id[0] = '\0';
993 	assert(act-&gt;fd &gt;= 0); 	char filedata[FILE_ID_SIZE];
994 	lseek(act-&gt;fd, 0, SEEK_SET); 	const int r = read(act-&gt;fd, filedata, FILE_ID_SIZE);
995 	if(r == FILE_ID_SIZE) {
996 		get_file_id_hash(filedata, sizeof(filedata), act-&gt;file_id, sizeof(act-&gt;file_id));
997 	} else {
998 		DBGPRINTF("getFileID partial or error read, ret %d\n", r);
999 	}
1000 	if (strncmp(tmp_id, act-&gt;file_id, FILE_ID_HASH_SIZE)) {		strncpy(act-&gt;file_id_prev, tmp_id, FILE_ID_HASH_SIZE);
1001 	}
1002 	DBGPRINTF("getFileID for '%s', file_id_hash '%s'\n", act-&gt;name, act-&gt;file_id);
1003 }
1004 static uchar * ATTR_NONNULL(1, 2)
1005 getStateFileName(const act_obj_t *const act,
1006 	 	 uchar *const __restrict__ buf,
1007 		 const size_t lenbuf)
1008 {
1009 	DBGPRINTF("getStateFileName for '%s'\n", act-&gt;name);
1010 	snprintf((char*)buf, lenbuf - 1, "imfile-state:%lld", (long long) act-&gt;ino);
1011 	DBGPRINTF("getStateFileName:  state file name now is %s\n", buf);
1012 	return buf;
1013 }
1014 static rsRetVal
1015 checkPerMinuteRateLimits(per_minute_rate_limit_t *per_minute_rate_limits,
1016 			     const size_t msgLen)
1017 {
1018 	DEFiRet;
1019 	time_t current_minute = time(NULL)/60;
1020 	if(per_minute_rate_limits-&gt;maxBytesPerMinute) {
1021 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1022 			per_minute_rate_limits-&gt;bytesThisMinute += msgLen;
1023 			if (per_minute_rate_limits-&gt;bytesThisMinute &gt; per_minute_rate_limits-&gt;maxBytesPerMinute) {
1024 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1025 			}
1026 		} else {
1027 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1028 			per_minute_rate_limits-&gt;bytesThisMinute = msgLen; 		}
1029 	}
1030 	if(per_minute_rate_limits-&gt;maxLinesPerMinute) {
1031 		if (per_minute_rate_limits-&gt;rateLimitingMinute == current_minute) {
1032 			per_minute_rate_limits-&gt;linesThisMinute++;
1033 			if (per_minute_rate_limits-&gt;linesThisMinute &gt; per_minute_rate_limits-&gt;maxLinesPerMinute) {
1034 				ABORT_FINALIZE(RS_RET_RATE_LIMITED);
1035 			}
1036 		} else {
1037 			per_minute_rate_limits-&gt;rateLimitingMinute = current_minute;
1038 			per_minute_rate_limits-&gt;linesThisMinute = 1; 		}
1039 	}
1040 finalize_it:
1041 	RETiRet;
1042 }
1043 #define MAX_OFFSET_REPRESENTATION_NUM_BYTES 20
1044 static rsRetVal ATTR_NONNULL(1,2)
1045 enqLine(act_obj_t *const act,
1046 	cstr_t *const __restrict__ cstrLine,
1047 	const int64 strtOffs)
1048 {
1049 	DEFiRet;
1050 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];	smsg_t *pMsg;
1051 	uchar file_offset[MAX_OFFSET_REPRESENTATION_NUM_BYTES+1];
1052 	const uchar *metadata_names[2] = {(uchar *)"filename",(uchar *)"fileoffset"} ;
1053 	const uchar *metadata_values[2] ;
1054 	const size_t msgLen = cstrLen(cstrLine);
1055 	if(msgLen == 0) {
1056 		FINALIZE;
1057 	}
1058 	CHKiRet(msgConstruct(&amp;pMsg));
1059 	MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY);
1060 	MsgSetInputName(pMsg, pInputName);
1061 	if(inst-&gt;addCeeTag) {
1062 		size_t ceeMsgSize = msgLen + CONST_LEN_CEE_COOKIE + 1;
1063 		char *ceeMsg;
1064 		CHKmalloc(ceeMsg = malloc(ceeMsgSize));
1065 		strcpy(ceeMsg, CONST_CEE_COOKIE);
1066 		strcat(ceeMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine));
1067 		MsgSetRawMsg(pMsg, ceeMsg, ceeMsgSize);
1068 		free(ceeMsg);
1069 	} else {
1070 		MsgSetRawMsg(pMsg, (char*)rsCStrGetSzStrNoNULL(cstrLine), msgLen);
1071 	}
1072 	MsgSetMSGoffs(pMsg, 0);		MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
1073 	MsgSetTAG(pMsg, inst-&gt;pszTag, inst-&gt;lenTag);
1074 	msgSetPRI(pMsg, inst-&gt;iFacility | inst-&gt;iSeverity);
1075 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
1076 	if(inst-&gt;addMetadata) {
1077 		if (act-&gt;source_name) {
1078 			metadata_values[0] = (const uchar*)act-&gt;source_name;
1079 		} else {
1080 			metadata_values[0] = (const uchar*)act-&gt;name;
1081 		}
1082 		snprintf((char *)file_offset, MAX_OFFSET_REPRESENTATION_NUM_BYTES+1, "%lld", strtOffs);
1083 		metadata_values[1] = file_offset;
1084 		msgAddMultiMetadata(pMsg, metadata_names, metadata_values, 2);
1085 	}
1086 	if(inst-&gt;perMinuteRateLimits.maxBytesPerMinute || inst-&gt;perMinuteRateLimits.maxLinesPerMinute) {
1087 		CHKiRet(checkPerMinuteRateLimits((per_minute_rate_limit_t *)&amp;inst-&gt;perMinuteRateLimits, msgLen));
1088 	}
1089 	if(inst-&gt;delay_perMsg) {
1090 		srSleep(inst-&gt;delay_perMsg % 1000000, inst-&gt;delay_perMsg / 1000000);
1091 	}
1092 	pMsg-&gt;msgFlags = pMsg-&gt;msgFlags | inst-&gt;msgFlag;
1093 	ratelimitAddMsg(act-&gt;ratelimiter, &amp;act-&gt;multiSub, pMsg);
1094 finalize_it:
1095 	RETiRet;
1096 }
1097 static rsRetVal ATTR_NONNULL(1)
1098 openFileWithStateFile(act_obj_t *const act)
1099 {
1100 	DEFiRet;
1101 	uchar pszSFNam[MAXFNAME];
1102 	uchar statefile[MAXFNAME];
1103 	int fd = -1;
1104 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1105 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
1106 	getFileID(act);
1107 	getFullStateFileName(statefn, act-&gt;file_id, pszSFNam, sizeof(pszSFNam));
1108 	DBGPRINTF("trying to open state for '%s', state file '%s'\n", act-&gt;name, pszSFNam);
1109 	fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1110 	if(fd &lt; 0) {
1111 		if(errno == ENOENT) {
1112 			if(act-&gt;file_id[0] != '\0') {
1113 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1114 					"inode-only file exists\n", pszSFNam, act-&gt;name);
1115 				getFullStateFileName(statefn, "", pszSFNam, sizeof(pszSFNam));
1116 				fd = open((char*)pszSFNam, O_CLOEXEC | O_NOCTTY | O_RDONLY, 0600);
1117 				if(fd &gt;= 0) {
1118 					dbgprintf("found inode-only state file, will be renamed at next persist\n");
1119 				}
1120 			}
1121 			if(fd &lt; 0) {
1122 				DBGPRINTF("state file %s for %s does not exist - trying to see if "
1123 					"old-style file exists\n", pszSFNam, act-&gt;name);
1124 				CHKiRet(OLD_openFileWithStateFile(act));
1125 				FINALIZE;
1126 			}
1127 		} else {
1128 			LogError(errno, RS_RET_IO_ERROR,
1129 				"imfile error trying to access state file for '%s'",
1130 			        act-&gt;name);
1131 			ABORT_FINALIZE(RS_RET_IO_ERROR);
1132 		}
1133 	}
1134 	DBGPRINTF("opened state file %s for %s\n", pszSFNam, act-&gt;name);
1135 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1136 	struct json_object *jval;
1137 	struct json_object *json = fjson_object_from_fd(fd);
1138 	if(json == NULL) {
1139 		LogError(0, RS_RET_ERR, "imfile: error reading state file for '%s'", act-&gt;name);
1140 	}
1141 	fjson_object_object_get_ex(json, "prev_was_nl", &amp;jval);
1142 	act-&gt;pStrm-&gt;bPrevWasNL = fjson_object_get_int(jval);
1143 	fjson_object_object_get_ex(json, "curr_offs", &amp;jval);
1144 	act-&gt;pStrm-&gt;iCurrOffs = fjson_object_get_int64(jval);
1145 	fjson_object_object_get_ex(json, "strt_offs", &amp;jval);
1146 	act-&gt;pStrm-&gt;strtOffs = fjson_object_get_int64(jval);
1147 	fjson_object_object_get_ex(json, "prev_line_segment", &amp;jval);
1148 	const uchar *const prev_line_segment = (const uchar*)fjson_object_get_string(jval);
1149 	if(jval != NULL) {
1150 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevLineSegment, prev_line_segment));
1151 		cstrFinalize(act-&gt;pStrm-&gt;prevLineSegment);
1152 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevLineSegment);
1153 		DBGPRINTF("prev_line_segment present in state file 2, is: %s\n", ret);
1154 	}
1155 	fjson_object_object_get_ex(json, "prev_msg_segment", &amp;jval);
1156 	const uchar *const prev_msg_segment = (const uchar*)fjson_object_get_string(jval);
1157 	if(jval != NULL) {
1158 		CHKiRet(rsCStrConstructFromszStr(&amp;act-&gt;pStrm-&gt;prevMsgSegment, prev_msg_segment));
1159 		cstrFinalize(act-&gt;pStrm-&gt;prevMsgSegment);
1160 		uchar *ret = rsCStrGetSzStrNoNULL(act-&gt;pStrm-&gt;prevMsgSegment);
1161 		DBGPRINTF("prev_msg_segment present in state file 2, is: %s\n", ret);
1162 	}
1163 	fjson_object_put(json);
1164 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1165 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1166 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1167 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1168 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1169 	CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1170 finalize_it:
1171 	if(fd &gt;= 0) {
1172 		close(fd);
1173 	}
1174 	RETiRet;
1175 }
1176 static rsRetVal
1177 openFileWithoutStateFile(act_obj_t *const act)
1178 {
1179 	DEFiRet;
1180 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1181 	DBGPRINTF("clean startup withOUT state file for '%s'\n", act-&gt;name);
1182 	if(act-&gt;pStrm != NULL)
1183 		strm.Destruct(&amp;act-&gt;pStrm);
1184 	CHKiRet(strm.Construct(&amp;act-&gt;pStrm));
1185 	CHKiRet(strm.SettOperationsMode(act-&gt;pStrm, STREAMMODE_READ));
1186 	CHKiRet(strm.SetsType(act-&gt;pStrm, STREAMTYPE_FILE_MONITOR));
1187 	CHKiRet(strm.SetFName(act-&gt;pStrm, (uchar*)act-&gt;name, strlen(act-&gt;name)));
1188 	CHKiRet(strm.SetFileNotFoundError(act-&gt;pStrm, inst-&gt;fileNotFoundError));
1189 	CHKiRet(strm.ConstructFinalize(act-&gt;pStrm));
1190 	if(inst-&gt;freshStartTail) {
1191 		const int fd = open(act-&gt;name, O_RDONLY | O_CLOEXEC);
1192 		if(fd &gt;= 0) {
1193 			act-&gt;pStrm-&gt;iCurrOffs = lseek64(fd, 0, SEEK_END);
1194 			close(fd);
1195 			if(act-&gt;pStrm-&gt;iCurrOffs &lt; 0) {
1196 				act-&gt;pStrm-&gt;iCurrOffs = 0;
1197 				LogError(errno, RS_RET_ERR, "imfile: could not query current "
1198 					"file size for %s - 'freshStartTail' option will "
1199 					"be ignored, starting at begin of file", inst-&gt;pszFileName);
1200 			}
1201 			CHKiRet(strm.SeekCurrOffs(act-&gt;pStrm));
1202 		}
1203 	}
1204 finalize_it:
1205 	RETiRet;
1206 }
1207 static rsRetVal
1208 openFile(act_obj_t *const act)
1209 {
1210 	DEFiRet;
1211 	const instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1212 	CHKiRet_Hdlr(openFileWithStateFile(act)) {
1213 		CHKiRet(openFileWithoutStateFile(act));
1214 	}
1215 	DBGPRINTF("breopenOnTruncate %d for '%s'\n", inst-&gt;reopenOnTruncate, act-&gt;name);
1216 	CHKiRet(strm.SetbReopenOnTruncate(act-&gt;pStrm, inst-&gt;reopenOnTruncate));
1217 	strmSetReadTimeout(act-&gt;pStrm, inst-&gt;readTimeout);
1218 finalize_it:
1219 	RETiRet;
1220 }
1221 static void pollFileCancelCleanup(void *pArg)
1222 {
1223 	cstr_t **ppCStr = (cstr_t**) pArg;
1224 	if(*ppCStr != NULL)
1225 		rsCStrDestruct(ppCStr);
1226 }
1227 static rsRetVal ATTR_NONNULL()
1228 pollFileReal(act_obj_t *act, cstr_t **pCStr)
1229 {
1230 	int64 strtOffs;
1231 	DEFiRet;
1232 	int64_t startOffs = 0;
1233 	int nProcessed = 0;
1234 	regex_t *start_preg = NULL, *end_preg = NULL;
1235 	DBGPRINTF("pollFileReal enter, act %p, pStrm %p, name '%s'\n", act, act-&gt;pStrm, act-&gt;name);
1236 	DBGPRINTF("pollFileReal enter, edge %p\n", act-&gt;edge);
1237 	DBGPRINTF("pollFileReal enter, edge-&gt;instarr %p\n", act-&gt;edge-&gt;instarr);
1238 	instanceConf_t *const inst = act-&gt;edge-&gt;instarr[0];
1239 	if(act-&gt;pStrm == NULL) {
1240 		CHKiRet(openFile(act)); 	}
1241 	start_preg = (inst-&gt;startRegex == NULL) ? NULL : &amp;inst-&gt;start_preg;
1242 	end_preg = (inst-&gt;endRegex == NULL) ? NULL : &amp;inst-&gt;end_preg;
1243 	startOffs = act-&gt;pStrm-&gt;iCurrOffs;
1244 	while(glbl.GetGlobalInputTermState() == 0) {
1245 		if(inst-&gt;maxLinesAtOnce != 0 &amp;&amp; nProcessed &gt;= inst-&gt;maxLinesAtOnce)
1246 			break;
1247 		if((start_preg == NULL) &amp;&amp; (end_preg == NULL)) {
1248 			CHKiRet(strm.ReadLine(act-&gt;pStrm, pCStr, inst-&gt;readMode, inst-&gt;escapeLF, inst-&gt;escapeLFString,
1249 				inst-&gt;trimLineOverBytes, &amp;strtOffs));
1250 		} else {
1251 			CHKiRet(strmReadMultiLine(act-&gt;pStrm, pCStr, start_preg, end_preg,
1252 				inst-&gt;escapeLF, inst-&gt;escapeLFString, inst-&gt;discardTruncatedMsg,
1253 				inst-&gt;msgDiscardingError, &amp;strtOffs));
1254 		}
1255 		++nProcessed;
1256 		if(startOffs &lt; FILE_ID_SIZE &amp;&amp; act-&gt;pStrm-&gt;iCurrOffs &gt;= FILE_ID_SIZE) {
1257 			dbgprintf("initiating state file write as sufficient data is now present; file=%s\n",
1258 				act-&gt;name);
1259 			persistStrmState(act);
1260 			startOffs = act-&gt;pStrm-&gt;iCurrOffs; 		}
1261 		runModConf-&gt;bHadFileData = 1; 		CHKiRet(enqLine(act, *pCStr, strtOffs)); 		rsCStrDestruct(pCStr); 		if(inst-&gt;iPersistStateInterval &gt; 0 &amp;&amp; ++act-&gt;nRecords &gt;= inst-&gt;iPersistStateInterval) {
1262 			persistStrmState(act);
1263 			act-&gt;nRecords = 0;
1264 		}
1265 	}
1266 finalize_it:
1267 	multiSubmitFlush(&amp;act-&gt;multiSub);
1268 	if(inst-&gt;bPersistStateAfterSubmission) {
1269 		persistStrmState(act);
1270 	}
1271 	if(*pCStr != NULL) {
1272 		rsCStrDestruct(pCStr);
1273 	}
1274 	RETiRet;
1275 }
1276 static rsRetVal ATTR_NONNULL(1)
1277 pollFile(act_obj_t *const act)
1278 {
1279 	cstr_t *pCStr = NULL;
1280 	DEFiRet;
1281 	if (act-&gt;is_symlink) {
1282 		FINALIZE;    	}
1283 	pthread_cleanup_push(pollFileCancelCleanup, &amp;pCStr);
1284 	iRet = pollFileReal(act, &amp;pCStr);
1285 	pthread_cleanup_pop(0);
1286 finalize_it: RETiRet;
1287 }
1288 static rsRetVal ATTR_NONNULL(1)
1289 createInstance(instanceConf_t **const pinst)
1290 {
1291 	instanceConf_t *inst;
1292 	DEFiRet;
1293 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
1294 <a name="4"></a>	inst-&gt;next = NULL;
1295 	inst-&gt;pBindRuleset = NULL;
1296 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	inst-&gt;pszBindRuleset = NULL;
1297 	inst-&gt;pszFileName = NULL;
1298 	inst-&gt;pszTag = NULL;
1299 	inst-&gt;pszStateFile = NULL;
1300 	inst-&gt;nMultiSub = NUM_MULTISUB;
1301 	inst-&gt;iSeverity = 5;
1302 	inst-&gt;iFacility = 128;
1303 	inst-&gt;maxLinesAtOnce = 0;
1304 	inst-&gt;trimLineOverBytes = 0;
1305 	inst-&gt;iPersistStateInterval = 0;
1306 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = 0;
1307 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = 0;
1308 	inst-&gt;perMinuteRateLimits.rateLimitingMinute = 0;
1309 	inst-&gt;perMinuteRateLimits.linesThisMinute = 0;
1310 	inst-&gt;perMinuteRateLimits.bytesThisMinute = 0;
1311 	inst-&gt;bPersistStateAfterSubmission = 0;
1312 	inst-&gt;readMode = 0;</b></font>
1313 	inst-&gt;startRegex = NULL;
1314 	inst-&gt;endRegex = NULL;
1315 	inst-&gt;discardTruncatedMsg = 0;
1316 	inst-&gt;msgDiscardingError = 1;
1317 	inst-&gt;bRMStateOnDel = 1;
1318 	inst-&gt;escapeLF = 1;
1319 	inst-&gt;escapeLFString = NULL;
1320 	inst-&gt;reopenOnTruncate = 0;
1321 	inst-&gt;addMetadata = ADD_METADATA_UNSPECIFIED;
1322 	inst-&gt;addCeeTag = 0;
1323 	inst-&gt;freshStartTail = 0;
1324 	inst-&gt;fileNotFoundError = 1;
1325 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1326 	inst-&gt;delay_perMsg = 0;
1327 	inst-&gt;msgFlag = 0;
1328 	inst-&gt;ignoreOlderThan = 0;
1329 	if(loadModConf-&gt;tail == NULL) {
1330 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
1331 	} else {
1332 		loadModConf-&gt;tail-&gt;next = inst;
1333 		loadModConf-&gt;tail = inst;
1334 	}
1335 	*pinst = inst;
1336 finalize_it:
1337 	RETiRet;
1338 }
1339 static int ATTR_NONNULL()
1340 getBasename(uchar *const __restrict__ basen, uchar *const __restrict__ path)
1341 {
1342 	int i;
1343 	int found = 0;
1344 	const int lenName = ustrlen(path);
1345 	for(i = lenName ; i &gt;= 0 ; --i) {
1346 		if(path[i] == '/') {
1347 			found = 1;
1348 			if(i == lenName)
1349 				basen[0] = '\0';
1350 			else {
1351 				memcpy(basen, path+i+1, lenName-i);
1352 			}
1353 			break;
1354 		}
1355 	}
1356 	if (found == 1)
1357 		return i;
1358 	else {
1359 		return -1;
1360 	}
1361 }
1362 static rsRetVal ATTR_NONNULL()
1363 checkInstance(instanceConf_t *const inst)
1364 {
1365 	uchar curr_wd[MAXFNAME];
1366 	DEFiRet;
1367 	if(inst-&gt;pszFileName == NULL)
1368 		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
1369 	CHKmalloc(inst-&gt;pszFileName_forOldStateFile = ustrdup(inst-&gt;pszFileName));
1370 	if(loadModConf-&gt;normalizePath) {
1371 		if(inst-&gt;pszFileName[0] == '.' &amp;&amp; inst-&gt;pszFileName[1] == '/') {
1372 			DBGPRINTF("imfile: removing heading './' from name '%s'\n", inst-&gt;pszFileName);
1373 			memmove(inst-&gt;pszFileName, inst-&gt;pszFileName+2, ustrlen(inst-&gt;pszFileName) - 1);
1374 		}
1375 		if(inst-&gt;pszFileName[0] != '/') {
1376 			if(getcwd((char*)curr_wd, MAXFNAME) == NULL || curr_wd[0] != '/') {
1377 				LogError(errno, RS_RET_ERR, "imfile: error querying current working "
1378 					"directory - can not continue with %s", inst-&gt;pszFileName);
1379 				ABORT_FINALIZE(RS_RET_ERR);
1380 			}
1381 			const size_t len_curr_wd = ustrlen(curr_wd);
1382 			if(len_curr_wd + ustrlen(inst-&gt;pszFileName) + 1 &gt;= MAXFNAME) {
1383 				LogError(0, RS_RET_ERR, "imfile: length of configured file and current "
1384 					"working directory exceeds permitted size - ignoring %s",
1385 					inst-&gt;pszFileName);
1386 				ABORT_FINALIZE(RS_RET_ERR);
1387 			}
1388 			curr_wd[len_curr_wd] = '/';
1389 			strcpy((char*)curr_wd+len_curr_wd+1, (char*)inst-&gt;pszFileName);
1390 			free(inst-&gt;pszFileName);
1391 			CHKmalloc(inst-&gt;pszFileName = ustrdup(curr_wd));
1392 		}
1393 	}
1394 	dbgprintf("imfile: adding file monitor for '%s'\n", inst-&gt;pszFileName);
1395 	if(inst-&gt;pszTag != NULL) {
1396 		inst-&gt;lenTag = ustrlen(inst-&gt;pszTag);
1397 	}
1398 finalize_it:
1399 	RETiRet;
1400 }
1401 static rsRetVal
1402 addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
1403 {
1404 	instanceConf_t *inst;
1405 	DEFiRet;
1406 	if(cs.pszFileName == NULL) {
1407 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no file name given, file monitor can "
1408 					"not be created");
1409 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1410 	}
1411 	if(cs.pszFileTag == NULL) {
1412 		LogError(0, RS_RET_CONFIG_ERROR, "imfile error: no tag value given, file monitor can "
1413 					"not be created");
1414 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1415 	}
1416 	CHKiRet(createInstance(&amp;inst));
1417 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
1418 		inst-&gt;pszBindRuleset = NULL;
1419 	} else {
1420 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
1421 	}
1422 	CHKmalloc(inst-&gt;pszFileName = ustrdup((char*) cs.pszFileName));
1423 	CHKmalloc(inst-&gt;pszTag = ustrdup((char*) cs.pszFileTag));
1424 	if(cs.pszStateFile == NULL) {
1425 		inst-&gt;pszStateFile = NULL;
1426 	} else {
1427 		CHKmalloc(inst-&gt;pszStateFile = ustrdup(cs.pszStateFile));
1428 	}
1429 	inst-&gt;iSeverity = cs.iSeverity;
1430 	inst-&gt;iFacility = cs.iFacility;
1431 	if(cs.maxLinesAtOnce) {
1432 		if(loadModConf-&gt;opMode == OPMODE_INOTIFY) {
1433 			LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1434 				"parameter \"maxLinesAtOnce\" not "
1435 				"permited in inotify mode - ignored");
1436 		} else {
1437 			inst-&gt;maxLinesAtOnce = cs.maxLinesAtOnce;
1438 		}
1439 	}
1440 	inst-&gt;trimLineOverBytes = cs.trimLineOverBytes;
1441 	inst-&gt;ignoreOlderThan = 0;
1442 	inst-&gt;iPersistStateInterval = cs.iPersistStateInterval;
1443 	inst-&gt;perMinuteRateLimits.maxBytesPerMinute = cs.maxBytesPerMinute;
1444 	inst-&gt;perMinuteRateLimits.maxLinesPerMinute = cs.maxLinesPerMinute;
1445 	inst-&gt;bPersistStateAfterSubmission = 0;
1446 	inst-&gt;readMode = cs.readMode;
1447 	inst-&gt;escapeLF = 0;
1448 	inst-&gt;escapeLFString = NULL;
1449 	inst-&gt;reopenOnTruncate = 0;
1450 	inst-&gt;addMetadata = 0;
1451 	inst-&gt;addCeeTag = 0;
1452 	inst-&gt;bRMStateOnDel = 0;
1453 	inst-&gt;readTimeout = loadModConf-&gt;readTimeout;
1454 	inst-&gt;msgFlag = 0;
1455 	CHKiRet(checkInstance(inst));
1456 	cs.iPersistStateInterval = 0;
1457 	resetConfigVariables(NULL, NULL); 
1458 finalize_it:
1459 	free(pNewVal); 	RETiRet;
1460 }
1461 BEGINnewInpInst
1462 	struct cnfparamvals *pvals;
1463 	instanceConf_t *inst;
1464 	int i;
1465 CODESTARTnewInpInst
1466 	DBGPRINTF("newInpInst (imfile)\n");
1467 	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
1468 	if(pvals == NULL) {
1469 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1470 	}
1471 	if(Debug) {
1472 		DBGPRINTF("input param blk in imfile:\n");
1473 		cnfparamsPrint(&amp;inppblk, pvals);
1474 	}
1475 	CHKiRet(createInstance(&amp;inst));
1476 <a name="7"></a>	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
1477 		if(!pvals[i].bUsed)
1478 			continue;
1479 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		if(!strcmp(inppblk.descr[i].name, "file")) {
1480 			inst-&gt;pszFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1481 		} else if(!strcmp(inppblk.descr[i].name, "statefile")) {
1482 <a name="1"></a>			inst-&gt;pszStateFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1483 		} else if(!strcmp(inppblk.descr[i].name, "removestateondelete")) {
1484 			inst-&gt;bRMStateOnDel = (uint8_t) pvals[i].val.d.n; <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "tag")) {
1485 			inst-&gt;pszTag = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1486 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
1487 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1488 		} else if(!strcmp(inppblk.descr[i].name, "severity")) {
1489 			inst-&gt;iSeverity = pvals[i].val.d.n;
1490 		} else if(!strcmp(inppblk.descr[i].name, "facility")) {
1491 			inst-&gt;iFacility = pvals[i].val.d.n;
1492 		} else if(!strcmp(inppblk.descr[i].name, "readmode")) {
1493 			inst-&gt;readMode = (sbool) pvals[i].val.d.n;</b></font>
1494 		} else if(!strcmp(inppblk.descr[i].name, "startmsg.regex")) {
1495 <a name="5"></a>			inst-&gt;startRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1496 		} else if(!strcmp(inppblk.descr[i].name, "endmsg.regex")) {
1497 			inst-&gt;endRegex = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1498 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "discardtruncatedmsg")) {
1499 			inst-&gt;discardTruncatedMsg = (sbool) pvals[i].val.d.n;
1500 		} else if(!strcmp(inppblk.descr[i].name, "msgdiscardingerror")) {
1501 			inst-&gt;msgDiscardingError = (sbool) pvals[i].val.d.n;
1502 		} else if(!strcmp(inppblk.descr[i].name, "deletestateonfiledelete")) {
1503 			inst-&gt;bRMStateOnDel = (sbool) pvals[i].val.d.n; 		} else if(!strcmp(inppblk.descr[i].name, "addmetadata")) {
1504 			inst-&gt;addMetadata = (sbool) pvals[i].val.d.n;
1505 		} else if(!strcmp(inppblk.descr[i].name, "delay.message")) {</b></font>
1506 <a name="2"></a>			inst-&gt;delay_perMsg = (unsigned) pvals[i].val.d.n;
1507 		} else if (!strcmp(inppblk.descr[i].name, "addceetag")) {
1508 			inst-&gt;addCeeTag = (sbool) pvals[i].val.d.n;
1509 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "freshstarttail")) {
1510 			inst-&gt;freshStartTail = (sbool) pvals[i].val.d.n;
1511 		} else if(!strcmp(inppblk.descr[i].name, "filenotfounderror")) {
1512 			inst-&gt;fileNotFoundError = (sbool) pvals[i].val.d.n;
1513 		} else if(!strcmp(inppblk.descr[i].name, "escapelf")) {
1514 			inst-&gt;escapeLF = (sbool) pvals[i].val.d.n;
1515 		} else if(!strcmp(inppblk.descr[i].name, "escapelf.replacement")) {
1516 			inst-&gt;escapeLFString = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1517 		} else if(!strcmp(inppblk.descr[i].name, "reopenontruncate")) {
1518 			inst-&gt;reopenOnTruncate = (sbool) pvals[i].val.d.n;</b></font>
1519 		} else if(!strcmp(inppblk.descr[i].name, "maxlinesatonce")) {
1520 			if(   loadModConf-&gt;opMode == OPMODE_INOTIFY
1521 			   &amp;&amp; pvals[i].val.d.n &gt; 0) {
1522 				LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1523 					"parameter \"maxLinesAtOnce\" not "
1524 <a name="3"></a>					"permited in inotify mode - ignored");
1525 			} else {
1526 				inst-&gt;maxLinesAtOnce = pvals[i].val.d.n;
1527 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			}
1528 		} else if(!strcmp(inppblk.descr[i].name, "trimlineoverbytes")) {
1529 			inst-&gt;trimLineOverBytes = pvals[i].val.d.n;
1530 		} else if(!strcmp(inppblk.descr[i].name, "ignoreolderthan")) {
1531 			inst-&gt;ignoreOlderThan = pvals[i].val.d.n;
1532 		} else if(!strcmp(inppblk.descr[i].name, "persiststateinterval")) {
1533 			inst-&gt;iPersistStateInterval = pvals[i].val.d.n;
1534 <a name="6"></a>		} else if(!strcmp(inppblk.descr[i].name, "maxbytesperminute")) {
1535 			DBGPRINTF("imfile: enabling maxbytesperminute ratelimiting\n");
1536 			inst-&gt;perMinuteRateLimits.maxBytesPerMinute = pvals[i].val.d.n;</b></font>
1537 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(inppblk.descr[i].name, "maxlinesperminute")) {
1538 			DBGPRINTF("imfile: enabling maxlinesperminute ratelimiting\n");
1539 			inst-&gt;perMinuteRateLimits.maxLinesPerMinute = pvals[i].val.d.n;
1540 		} else if(!strcmp(inppblk.descr[i].name, "persiststateaftersubmission")) {
1541 			inst-&gt;bPersistStateAfterSubmission = pvals[i].val.d.n;
1542 		} else if(!strcmp(inppblk.descr[i].name, "maxsubmitatonce")) {
1543 			inst-&gt;nMultiSub = pvals[i].val.d.n;</b></font>
1544 		} else if(!strcmp(inppblk.descr[i].name, "readtimeout")) {
1545 			inst-&gt;readTimeout = pvals[i].val.d.n;
1546 		} else if(!strcmp(inppblk.descr[i].name, "needparse")) {
1547 			inst-&gt;msgFlag = pvals[i].val.d.n ? NEEDS_PARSING : 0;
1548 		} else {
1549 			DBGPRINTF("program error, non-handled "
1550 			  "param '%s'\n", inppblk.descr[i].name);
1551 		}
1552 	}
1553 	i = (inst-&gt;readMode &gt; 0) ? 1 : 0;
1554 	i = (NULL != inst-&gt;startRegex) ? (i+1) : i;
1555 	i = (NULL != inst-&gt;endRegex) ? (i+1) : i;
1556 	if(i &gt; 1) {
1557 		LogError(0, RS_RET_PARAM_NOT_PERMITTED,
1558 			"only one of readMode or startmsg.regex or endmsg.regex can be set "
1559 			"at the same time");
1560 			ABORT_FINALIZE(RS_RET_PARAM_NOT_PERMITTED);
1561 	}
1562 	if(inst-&gt;startRegex != NULL) {
1563 		const int errcode = regcomp(&amp;inst-&gt;start_preg, (char*)inst-&gt;startRegex, REG_EXTENDED);
1564 		if(errcode != 0) {
1565 			char errbuff[512];
1566 			regerror(errcode, &amp;inst-&gt;start_preg, errbuff, sizeof(errbuff));
1567 			parser_errmsg("imfile: error in startmsg.regex expansion: %s", errbuff);
1568 			ABORT_FINALIZE(RS_RET_ERR);
1569 		}
1570 	}
1571 	if(inst-&gt;endRegex != NULL) {
1572 		const int errcode = regcomp(&amp;inst-&gt;end_preg, (char*)inst-&gt;endRegex, REG_EXTENDED);
1573 		if(errcode != 0) {
1574 			char errbuff[512];
1575 			regerror(errcode, &amp;inst-&gt;end_preg, errbuff, sizeof(errbuff));
1576 			parser_errmsg("imfile: error in endmsg.regex expansion: %s", errbuff);
1577 			ABORT_FINALIZE(RS_RET_ERR);
1578 		}
1579 	}
1580 	if(inst-&gt;readTimeout != 0)
1581 		loadModConf-&gt;haveReadTimeouts = 1;
1582 	iRet = checkInstance(inst);
1583 finalize_it:
1584 CODE_STD_FINALIZERnewInpInst
1585 	cnfparamvalsDestruct(pvals, &amp;inppblk);
1586 ENDnewInpInst
1587 BEGINbeginCnfLoad
1588 CODESTARTbeginCnfLoad
1589 	loadModConf = pModConf;
1590 	currModConf = pModConf;
1591 	pModConf-&gt;pConf = pConf;
1592 	loadModConf-&gt;opMode = OPMODE_POLLING;
1593 	loadModConf-&gt;iPollInterval = DFLT_PollInterval;
1594 	loadModConf-&gt;configSetViaV2Method = 0;
1595 	loadModConf-&gt;readTimeout = 0; 	loadModConf-&gt;timeoutGranularity = 1000; 	loadModConf-&gt;haveReadTimeouts = 0; 	loadModConf-&gt;normalizePath = 1;
1596 	loadModConf-&gt;sortFiles = GLOB_NOSORT;
1597 	loadModConf-&gt;stateFileDirectory = NULL;
1598 	loadModConf-&gt;conf_tree = calloc(sizeof(fs_node_t), 1);
1599 	loadModConf-&gt;conf_tree-&gt;edges = NULL;
1600 	bLegacyCnfModGlobalsPermitted = 1;
1601 	cs.pszFileName = NULL;
1602 	cs.pszFileTag = NULL;
1603 	cs.pszStateFile = NULL;
1604 	cs.iPollInterval = DFLT_PollInterval;
1605 	cs.iPersistStateInterval = 0;
1606 	cs.iFacility = 128;
1607 	cs.iSeverity = 5;
1608 	cs.readMode = 0;
1609 	cs.maxLinesAtOnce = 10240;
1610 	cs.trimLineOverBytes = 0;
1611 ENDbeginCnfLoad
1612 BEGINsetModCnf
1613 	struct cnfparamvals *pvals = NULL;
1614 	int i;
1615 CODESTARTsetModCnf
1616 	#if defined(HAVE_PORT_SOURCE_FILE)
1617 		loadModConf-&gt;opMode = OPMODE_FEN;
1618 	#elif defined(HAVE_INOTIFY_INIT)
1619 		loadModConf-&gt;opMode = OPMODE_INOTIFY;
1620 	#else
1621 		loadModConf-&gt;opMode = OPMODE_POLLING;
1622 	#endif
1623 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
1624 	if(pvals == NULL) {
1625 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imfile: error processing module "
1626 				"config parameters [module(...)]");
1627 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1628 	}
1629 	if(Debug) {
1630 		DBGPRINTF("module (global) param blk for imfile:\n");
1631 		cnfparamsPrint(&amp;modpblk, pvals);
1632 	}
1633 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
1634 		if(!pvals[i].bUsed)
1635 			continue;
1636 		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
1637 			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
1638 		} else if(!strcmp(modpblk.descr[i].name, "readtimeout")) {
1639 			loadModConf-&gt;readTimeout = (int) pvals[i].val.d.n;
1640 		} else if(!strcmp(modpblk.descr[i].name, "timeoutgranularity")) {
1641 			loadModConf-&gt;timeoutGranularity = (int) pvals[i].val.d.n * 1000;
1642 		} else if(!strcmp(modpblk.descr[i].name, "sortfiles")) {
1643 			loadModConf-&gt;sortFiles = ((sbool) pvals[i].val.d.n) ? 0 : GLOB_NOSORT;
1644 		} else if(!strcmp(modpblk.descr[i].name, "statefile.directory")) {
1645 			loadModConf-&gt;stateFileDirectory = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1646 		} else if(!strcmp(modpblk.descr[i].name, "normalizepath")) {
1647 			loadModConf-&gt;normalizePath = (sbool) pvals[i].val.d.n;
1648 		} else if(!strcmp(modpblk.descr[i].name, "mode")) {
1649 			if(!es_strconstcmp(pvals[i].val.d.estr, "polling"))
1650 				loadModConf-&gt;opMode = OPMODE_POLLING;
1651 			else if(!es_strconstcmp(pvals[i].val.d.estr, "inotify")) {
1652 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 				loadModConf-&gt;opMode = OPMODE_FEN;
1653 				DBGPRINTF("inotify mode configured, but only FEN "
1654 					"is available on OS SOLARIS. Switching to FEN "
1655 					"Mode automatically\n");
1656 #else
1657 				#if defined(HAVE_INOTIFY_INIT)
1658 					loadModConf-&gt;opMode = OPMODE_INOTIFY;
1659 				#else
1660 					loadModConf-&gt;opMode = OPMODE_POLLING;
1661 				#endif
1662 #endif
1663 			} else if(!es_strconstcmp(pvals[i].val.d.estr, "fen"))
1664 				loadModConf-&gt;opMode = OPMODE_FEN;
1665 			else {
1666 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
1667 				LogError(0, RS_RET_PARAM_ERROR, "imfile: unknown "
1668 					"mode '%s'", cstr);
1669 				free(cstr);
1670 			}
1671 		} else {
1672 			DBGPRINTF("program error, non-handled "
1673 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
1674 		}
1675 	}
1676 	bLegacyCnfModGlobalsPermitted = 0;
1677 	loadModConf-&gt;configSetViaV2Method = 1;
1678 finalize_it:
1679 	if(pvals != NULL)
1680 		cnfparamvalsDestruct(pvals, &amp;modpblk);
1681 ENDsetModCnf
1682 BEGINendCnfLoad
1683 CODESTARTendCnfLoad
1684 	if(!loadModConf-&gt;configSetViaV2Method) {
1685 		loadModConf-&gt;iPollInterval = cs.iPollInterval;
1686 	}
1687 	DBGPRINTF("opmode is %d, polling interval is %d\n",
1688 		  loadModConf-&gt;opMode,
1689 		  loadModConf-&gt;iPollInterval);
1690 	loadModConf = NULL; 	free(cs.pszFileName);
1691 	free(cs.pszFileTag);
1692 	free(cs.pszStateFile);
1693 ENDendCnfLoad
1694 BEGINcheckCnf
1695 	instanceConf_t *inst;
1696 CODESTARTcheckCnf
1697 	if(getStateFileDir() == NULL) {
1698 		LogError(0, RS_RET_NO_WRKDIR_SET,
1699 			"imfile: no working or state file directory set, imfile will create "
1700 			"state files in the current working directory (probably "
1701 			"the root dir). Use global(workDirectory=\"/some/path\") "
1702 			"to set the working directory");
1703 	}
1704 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1705 		std_checkRuleset(pModConf, inst);
1706 	}
1707 	if(pModConf-&gt;root == NULL) {
1708 		LogError(0, RS_RET_NO_LISTNERS,
1709 				"imfile: no files configured to be monitored - "
1710 				"no input will be gathered");
1711 		iRet = RS_RET_NO_LISTNERS;
1712 	}
1713 ENDcheckCnf
1714 BEGINactivateCnf
1715 	instanceConf_t *inst;
1716 CODESTARTactivateCnf
1717 	runModConf = pModConf;
1718 	currModConf = pModConf;
1719 	if(runModConf-&gt;root == NULL) {
1720 		LogError(0, NO_ERRCODE, "imfile: no file monitors configured, "
1721 				"input not activated.\n");
1722 		ABORT_FINALIZE(RS_RET_NO_RUN);
1723 	}
1724 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1725 		if(!containsGlobWildcard((char*)inst-&gt;pszFileName)) {
1726 			if(access((char*)inst-&gt;pszFileName, R_OK) != 0) {
1727 				LogError(errno, RS_RET_ERR,
1728 					"imfile: on startup file '%s' does not exist "
1729 					"but is configured in static file monitor - this "
1730 					"may indicate a misconfiguration. If the file "
1731 					"appears at a later time, it will automatically "
1732 					"be processed. Reason", inst-&gt;pszFileName);
1733 			}
1734 		}
1735 		fs_node_add(runModConf-&gt;conf_tree, NULL, inst-&gt;pszFileName, 0, inst);
1736 	}
1737 	if(Debug) {
1738 		fs_node_print(runModConf-&gt;conf_tree, 0);
1739 	}
1740 finalize_it:
1741 ENDactivateCnf
1742 BEGINfreeCnf
1743 	instanceConf_t *inst, *del;
1744 CODESTARTfreeCnf
1745 	fs_node_destroy(pModConf-&gt;conf_tree);
1746 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
1747 		free(inst-&gt;pszBindRuleset);
1748 		free(inst-&gt;pszFileName);
1749 		free(inst-&gt;pszTag);
1750 		free(inst-&gt;pszStateFile);
1751 		free(inst-&gt;pszFileName_forOldStateFile);
1752 		if(inst-&gt;startRegex != NULL) {
1753 			regfree(&amp;inst-&gt;start_preg);
1754 			free(inst-&gt;startRegex);
1755 		}
1756 		if(inst-&gt;endRegex != NULL) {
1757 			regfree(&amp;inst-&gt;end_preg);
1758 			free(inst-&gt;endRegex);
1759 		}
1760 		del = inst;
1761 		inst = inst-&gt;next;
1762 		free(del);
1763 	}
1764 ENDfreeCnf
1765 static void
1766 do_initial_poll_run(void)
1767 {
1768 	fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1769 	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1770 		inst-&gt;freshStartTail = 0;
1771 	}
1772 }
1773 static rsRetVal
1774 doPolling(void)
1775 {
1776 	DEFiRet;
1777 	do_initial_poll_run();
1778 	while(glbl.GetGlobalInputTermState() == 0) {
1779 		DBGPRINTF("doPolling: new poll run\n");
1780 		do {
1781 			runModConf-&gt;bHadFileData = 0;
1782 			fs_node_walk(runModConf-&gt;conf_tree, poll_tree);
1783 			DBGPRINTF("doPolling: end poll walk, hadData %d\n", runModConf-&gt;bHadFileData);
1784 		} while(runModConf-&gt;bHadFileData); 
1785 		DBGPRINTF("doPolling: poll going to sleep\n");
1786 		if(glbl.GetGlobalInputTermState() == 0)
1787 			srSleep(runModConf-&gt;iPollInterval, 10);
1788 	}
1789 	RETiRet;
1790 }
1791 #if defined(HAVE_INOTIFY_INIT)
1792 static void ATTR_NONNULL(1)
1793 in_dbg_showEv(const struct inotify_event *ev)
1794 {
1795 	if(!Debug)
1796 		return;
1797 	if(ev-&gt;mask &amp; IN_IGNORED) {
1798 		dbgprintf("INOTIFY event: watch was REMOVED\n");
1799 	}
1800 	if(ev-&gt;mask &amp; IN_MODIFY) {
1801 		dbgprintf("INOTIFY event: watch was MODIFID\n");
1802 	}
1803 	if(ev-&gt;mask &amp; IN_ACCESS) {
1804 		dbgprintf("INOTIFY event: watch IN_ACCESS\n");
1805 	}
1806 	if(ev-&gt;mask &amp; IN_ATTRIB) {
1807 		dbgprintf("INOTIFY event: watch IN_ATTRIB\n");
1808 	}
1809 	if(ev-&gt;mask &amp; IN_CLOSE_WRITE) {
1810 		dbgprintf("INOTIFY event: watch IN_CLOSE_WRITE\n");
1811 	}
1812 	if(ev-&gt;mask &amp; IN_CLOSE_NOWRITE) {
1813 		dbgprintf("INOTIFY event: watch IN_CLOSE_NOWRITE\n");
1814 	}
1815 	if(ev-&gt;mask &amp; IN_CREATE) {
1816 		dbgprintf("INOTIFY event: file was CREATED: %s\n", ev-&gt;name);
1817 	}
1818 	if(ev-&gt;mask &amp; IN_DELETE) {
1819 		dbgprintf("INOTIFY event: watch IN_DELETE\n");
1820 	}
1821 	if(ev-&gt;mask &amp; IN_DELETE_SELF) {
1822 		dbgprintf("INOTIFY event: watch IN_DELETE_SELF\n");
1823 	}
1824 	if(ev-&gt;mask &amp; IN_MOVE_SELF) {
1825 		dbgprintf("INOTIFY event: watch IN_MOVE_SELF\n");
1826 	}
1827 	if(ev-&gt;mask &amp; IN_MOVED_FROM) {
1828 		dbgprintf("INOTIFY event: watch IN_MOVED_FROM, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1829 	}
1830 	if(ev-&gt;mask &amp; IN_MOVED_TO) {
1831 		dbgprintf("INOTIFY event: watch IN_MOVED_TO, cookie %u, name '%s'\n", ev-&gt;cookie, ev-&gt;name);
1832 	}
1833 	if(ev-&gt;mask &amp; IN_OPEN) {
1834 		dbgprintf("INOTIFY event: watch IN_OPEN\n");
1835 	}
1836 	if(ev-&gt;mask &amp; IN_ISDIR) {
1837 		dbgprintf("INOTIFY event: watch IN_ISDIR\n");
1838 	}
1839 }
1840 static void ATTR_NONNULL(1, 2)
1841 in_handleFileEvent(struct inotify_event *ev, const wd_map_t *const etry)
1842 {
1843 	if(ev-&gt;mask &amp; IN_MODIFY) {
1844 		DBGPRINTF("fs_node_notify_file_update: act-&gt;name '%s'\n", etry-&gt;act-&gt;name);
1845 		pollFile(etry-&gt;act);
1846 	} else {
1847 		DBGPRINTF("got non-expected inotify event:\n");
1848 		in_dbg_showEv(ev);
1849 	}
1850 }
1851 static void
1852 flag_in_move(fs_edge_t *const edge, const char *name_moved)
1853 {
1854 	act_obj_t *act;
1855 	for(act = edge-&gt;active ; act != NULL ; act = act-&gt;next) {
1856 		DBGPRINTF("checking active object %s\n", act-&gt;basename);
1857 		if(!strcmp(act-&gt;basename, name_moved)){
1858 			DBGPRINTF("found file\n");
1859 			act-&gt;in_move = 1;
1860 			break;
1861 		} else {
1862 			DBGPRINTF("name check fails, '%s' != '%s'\n", act-&gt;basename, name_moved);
1863 		}
1864 	}
1865 	if (!act &amp;&amp; edge-&gt;next) {
1866 		flag_in_move(edge-&gt;next, name_moved);
1867 	}
1868 }
1869 static void ATTR_NONNULL(1)
1870 in_processEvent(struct inotify_event *ev)
1871 {
1872 	if(ev-&gt;mask &amp; IN_IGNORED) {
1873 		DBGPRINTF("imfile: got IN_IGNORED event\n");
1874 		goto done;
1875 	}
1876 	DBGPRINTF("in_processEvent process Event %x for %s\n", ev-&gt;mask, ev-&gt;name);
1877 	const wd_map_t *const etry =  wdmapLookup(ev-&gt;wd);
1878 	if(etry == NULL) {
1879 		LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING, "imfile: internal error? "
1880 			"inotify provided watch descriptor %d which we could not find "
1881 			"in our tables - ignored", ev-&gt;wd);
1882 		goto done;
1883 	}
1884 	DBGPRINTF("in_processEvent process Event %x is_file %d, act-&gt;name '%s'\n",
1885 		ev-&gt;mask, etry-&gt;act-&gt;edge-&gt;is_file, etry-&gt;act-&gt;name);
1886 	if((ev-&gt;mask &amp; IN_MOVED_FROM)) {
1887 		flag_in_move(etry-&gt;act-&gt;edge-&gt;node-&gt;edges, ev-&gt;name);
1888 	}
1889 	if(ev-&gt;mask &amp; (IN_MOVED_FROM | IN_MOVED_TO))  {
1890 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1891 	} else if(etry-&gt;act-&gt;edge-&gt;is_file &amp;&amp; !(etry-&gt;act-&gt;is_symlink)) {
1892 		in_handleFileEvent(ev, etry); 	} else {
1893 		fs_node_walk(etry-&gt;act-&gt;edge-&gt;node, poll_tree);
1894 	}
1895 done:	return;
1896 }
1897 static rsRetVal
1898 do_inotify(void)
1899 {
1900 	char iobuf[8192];
1901 	int rd;
1902 	int currev;
1903 	static int last_timeout = 0;
1904 	struct pollfd pollfd;
1905 	DEFiRet;
1906 	CHKiRet(wdmapInit());
1907 	ino_fd = inotify_init1(IN_NONBLOCK);
1908 	if(ino_fd &lt; 0) {
1909 		LogError(errno, RS_RET_INOTIFY_INIT_FAILED, "imfile: Init inotify "
1910 			"instance failed ");
1911 		return RS_RET_INOTIFY_INIT_FAILED;
1912 	}
1913 	DBGPRINTF("inotify fd %d\n", ino_fd);
1914 	do_initial_poll_run();
1915 	while(glbl.GetGlobalInputTermState() == 0) {
1916 		int r;
1917 		pollfd.fd = ino_fd;
1918 		pollfd.events = POLLIN;
1919 		if (runModConf-&gt;haveReadTimeouts)
1920 			r = poll(&amp;pollfd, 1, runModConf-&gt;timeoutGranularity);
1921 		else
1922 			r = poll(&amp;pollfd, 1, -1);
1923 		if (r  == -1 &amp;&amp; errno == EINTR) {
1924 			DBGPRINTF("do_inotify interrupted while polling on ino_fd\n");
1925 			continue;
1926 		}
1927 		if(r == 0) {
1928 			DBGPRINTF("readTimeouts are configured, checking if some apply\n");
1929 			if (runModConf-&gt;haveReadTimeouts) {
1930 				fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1931 				last_timeout = time(NULL);
1932 			}
1933 			continue;
1934 		} else if (r == -1) {
1935 			LogError(errno, RS_RET_INTERNAL_ERROR,
1936 					"%s:%d: unexpected error during poll timeout wait",
1937 					__FILE__, __LINE__);
1938 			continue;
1939 		} else if(r != 1) {
1940 			LogError(errno, RS_RET_INTERNAL_ERROR,
1941 					"%s:%d: ERROR: poll returned more fds (%d) than given to it (1)",
1942 					__FILE__, __LINE__, r);
1943 			continue;
1944 		}
1945 		else {
1946 			if(runModConf-&gt;haveReadTimeouts) {
1947 				int now = time(NULL);
1948 				if(last_timeout + (runModConf-&gt;timeoutGranularity / 1000) &gt; now) {
1949 					fs_node_walk(runModConf-&gt;conf_tree, poll_timeouts);
1950 					last_timeout = time(NULL);
1951 				}
1952 			}
1953 			rd = read(ino_fd, iobuf, sizeof(iobuf));
1954 			if(rd == -1 &amp;&amp; errno == EINTR) {
1955 				DBGPRINTF("EINTR received during inotify, restarting poll\n");
1956 				continue;
1957 			}
1958 			if (rd == -1 &amp;&amp; errno == EWOULDBLOCK) {
1959 				continue;
1960 			}
1961 			if(rd &lt; 0) {
1962 				LogError(errno, RS_RET_IO_ERROR, "imfile: error during inotify - ignored");
1963 				continue;
1964 			}
1965 			currev = 0;
1966 			while(currev &lt; rd) {
1967 				union {
1968 					char *buf;
1969 					struct inotify_event *ev;
1970 				} savecast;
1971 				savecast.buf = iobuf+currev;
1972 				in_dbg_showEv(savecast.ev);
1973 				in_processEvent(savecast.ev);
1974 				currev += sizeof(struct inotify_event) + savecast.ev-&gt;len;
1975 			}
1976 		}
1977 	}
1978 finalize_it:
1979 	close(ino_fd);
1980 	RETiRet;
1981 }
1982 #else static rsRetVal
1983 do_inotify(void)
1984 {
1985 	LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: mode set to inotify, but the "
1986 			"platform does not support inotify");
1987 	return RS_RET_NOT_IMPLEMENTED;
1988 }
1989 #endif 
1990 #if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) static void
1991 fen_printevent(int event)
1992 {
1993 	if (event &amp; FILE_ACCESS) {
1994 		DBGPRINTF(" FILE_ACCESS");
1995 	}
1996 	if (event &amp; FILE_MODIFIED) {
1997 		DBGPRINTF(" FILE_MODIFIED");
1998 	}
1999 	if (event &amp; FILE_ATTRIB) {
2000 		DBGPRINTF(" FILE_ATTRIB");
2001 	}
2002 	if (event &amp; FILE_DELETE) {
2003 		DBGPRINTF(" FILE_DELETE");
2004 	}
2005 	if (event &amp; FILE_RENAME_TO) {
2006 		DBGPRINTF(" FILE_RENAME_TO");
2007 	}
2008 	if (event &amp; FILE_RENAME_FROM) {
2009 		DBGPRINTF(" FILE_RENAME_FROM");
2010 	}
2011 	if (event &amp; UNMOUNTED) {
2012 		DBGPRINTF(" UNMOUNTED");
2013 	}
2014 	if (event &amp; MOUNTEDOVER) {
2015 		DBGPRINTF(" MOUNTEDOVER");
2016 	}
2017 }
2018 static rsRetVal
2019 do_fen(void)
2020 {
2021 	port_event_t portEvent;
2022 	struct timespec timeout;
2023 	DEFiRet;
2024 	timeout.tv_sec = 300;
2025 	timeout.tv_nsec = 0;
2026 	if((glport = port_create()) == -1) {
2027 		LogError(errno, RS_RET_FEN_INIT_FAILED, "do_fen INIT Port failed ");
2028 		return RS_RET_FEN_INIT_FAILED;
2029 	}
2030 	do_initial_poll_run();
2031 	DBGPRINTF("do_fen ENTER monitoring loop \n");
2032 	while(glbl.GetGlobalInputTermState() == 0) {
2033 		DBGPRINTF("do_fen loop begin... \n");
2034 		while (!port_get(glport, &amp;portEvent, &amp;timeout)) { 			DBGPRINTF("do_fen: received port event with ");
2035 			fen_printevent((int) portEvent.portev_events);
2036 			DBGPRINTF("\n");
2037 			if(portEvent.portev_source != PORT_SOURCE_FILE) {
2038 				LogError(errno, RS_RET_SYS_ERR, "do_fen: Event from unexpected source "
2039 					": %d\n", portEvent.portev_source);
2040 				continue;
2041 			}
2042 			act_obj_t *const act = (act_obj_t*) portEvent.portev_user;
2043 			DBGPRINTF("do_fen event received: deleted %d, is_file %d, name '%s' foname '%s'\n",
2044 				act-&gt;is_deleted, act-&gt;edge-&gt;is_file, act-&gt;name,
2045 				((struct file_obj*)portEvent.portev_object)-&gt;fo_name);
2046 			if(act-&gt;is_deleted) {
2047 				free(act-&gt;name);
2048 				free(act);
2049 				continue;
2050 			}
2051 			act-&gt;bPortAssociated = 0;
2052 			fen_setupWatch(act);
2053 			if(act-&gt;edge-&gt;is_file) {
2054 				pollFile(act);
2055 			} else {
2056 				fs_node_walk(act-&gt;edge-&gt;node, poll_tree);
2057 			}
2058 		}
2059 	}
2060 	close(glport);
2061 	RETiRet;
2062 }
2063 #else static rsRetVal
2064 do_fen(void)
2065 {
2066 	LogError(0, RS_RET_NOT_IMPLEMENTED, "do_fen: mode set to fen, but the "
2067 			"platform does not support fen");
2068 	return RS_RET_NOT_IMPLEMENTED;
2069 }
2070 #endif 
2071 BEGINrunInput
2072 CODESTARTrunInput
2073 	#if defined(OS_SOLARIS) &amp;&amp; defined (HAVE_PORT_SOURCE_FILE) 	if(runModConf-&gt;opMode == OPMODE_INOTIFY) {
2074 		DBGPRINTF("auto-adjusting 'inotify' mode to 'fen' on Solaris\n");
2075 		runModConf-&gt;opMode = OPMODE_FEN;
2076 	}
2077 	#endif
2078 	DBGPRINTF("working in %s mode\n",
2079 		 (runModConf-&gt;opMode == OPMODE_POLLING) ? "polling" :
2080 			((runModConf-&gt;opMode == OPMODE_INOTIFY) ?"inotify" : "fen"));
2081 	if(runModConf-&gt;opMode == OPMODE_POLLING)
2082 		iRet = doPolling();
2083 	else if(runModConf-&gt;opMode == OPMODE_INOTIFY)
2084 		iRet = do_inotify();
2085 	else if(runModConf-&gt;opMode == OPMODE_FEN)
2086 		iRet = do_fen();
2087 	else {
2088 		LogError(0, RS_RET_NOT_IMPLEMENTED, "imfile: unknown mode %d set",
2089 			runModConf-&gt;opMode);
2090 		return RS_RET_NOT_IMPLEMENTED;
2091 	}
2092 	DBGPRINTF("terminating upon request of rsyslog core\n");
2093 ENDrunInput
2094 BEGINwillRun
2095 CODESTARTwillRun
2096 	CHKiRet(prop.Construct(&amp;pInputName));
2097 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imfile"), sizeof("imfile") - 1));
2098 	CHKiRet(prop.ConstructFinalize(pInputName));
2099 finalize_it:
2100 ENDwillRun
2101 static rsRetVal ATTR_NONNULL()
2102 atomicWriteStateFile(const char *fn, const char *content)
2103 {
2104 	DEFiRet;
2105 	const int fd = open(fn, O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC, 0600);
2106 	if(fd &lt; 0) {
2107 		LogError(errno, RS_RET_IO_ERROR, "imfile: cannot open state file '%s' for "
2108 			"persisting file state - some data will probably be duplicated "
2109 			"on next startup", fn);
2110 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2111 	}
2112 	const size_t toWrite = strlen(content);
2113 	const ssize_t w = write(fd, content, toWrite);
2114 	if(w != (ssize_t) toWrite) {
2115 		LogError(errno, RS_RET_IO_ERROR, "imfile: partial write to state file '%s' "
2116 			"this may cause trouble in the future. We will try to delete the "
2117 			"state file, as this provides most consistent state", fn);
2118 		unlink(fn);
2119 		ABORT_FINALIZE(RS_RET_IO_ERROR);
2120 	}
2121 finalize_it:
2122 	if(fd &gt;= 0) {
2123 		close(fd);
2124 	}
2125 	RETiRet;
2126 }
2127 static void
2128 removeOldStatefile(const uchar *statefn, const char *hashToDelete)
2129 {
2130 	int ret;
2131 	uchar statefname[MAXFNAME];
2132 	getFullStateFileName(statefn, hashToDelete, statefname, sizeof(statefname));
2133 	DBGPRINTF("removing old state file: '%s'\n", statefname);
2134 	ret = unlink((const char*)statefname);
2135 	if(ret != 0) {
2136 		if (errno != ENOENT) {
2137 			LogError(errno, RS_RET_IO_ERROR,
2138 				"imfile error trying to delete old state file: '%s' - ignoring this "
2139 				"error, usually this means a file no longer file is left over, but "
2140 				"this may also cause some real trouble. Still the best we can do ",
2141 				statefname);
2142 		} else {
2143 			DBGPRINTF("trying to delete no longer valid statefile '%s' which no "
2144 					  "longer exists (probably already deleted)\n", statefname);
2145 		}
2146 	}
2147 }
2148 static rsRetVal ATTR_NONNULL()
2149 persistStrmState(act_obj_t *const act)
2150 {
2151 	DEFiRet;
2152 	uchar statefile[MAXFNAME];
2153 	uchar statefname[MAXFNAME];
2154 	uchar *const statefn = getStateFileName(act, statefile, sizeof(statefile));
2155 	getFileID(act);
2156 	getFullStateFileName(statefn, act-&gt;file_id, statefname, sizeof(statefname));
2157 	DBGPRINTF("persisting state for '%s', state file '%s'\n", act-&gt;name, statefname);
2158 	struct json_object *jval = NULL;
2159 	struct json_object *json = NULL;
2160 	CHKmalloc(json = json_object_new_object());
2161 	jval = json_object_new_string((char*) act-&gt;name);
2162 	json_object_object_add(json, "filename", jval);
2163 	jval = json_object_new_int(strmGetPrevWasNL(act-&gt;pStrm));
2164 	json_object_object_add(json, "prev_was_nl", jval);
2165 	jval = json_object_new_int64(act-&gt;pStrm-&gt;iCurrOffs);
2166 	json_object_object_add(json, "curr_offs", jval);
2167 	jval = json_object_new_int64(act-&gt;pStrm-&gt;strtOffs);
2168 	json_object_object_add(json, "strt_offs", jval);
2169 	const uchar *const prevLineSegment = strmGetPrevLineSegment(act-&gt;pStrm);
2170 	if(prevLineSegment != NULL) {
2171 		jval = json_object_new_string((const char*) prevLineSegment);
2172 		json_object_object_add(json, "prev_line_segment", jval);
2173 	}
2174 	const uchar *const prevMsgSegment = strmGetPrevMsgSegment(act-&gt;pStrm);
2175 	if(prevMsgSegment != NULL) {
2176 		jval = json_object_new_string((const char*) prevMsgSegment);
2177 		json_object_object_add(json, "prev_msg_segment", jval);
2178 	}
2179 	const char *jstr =  json_object_to_json_string_ext(json, JSON_C_TO_STRING_SPACED);
2180 	CHKiRet(atomicWriteStateFile((const char*)statefname, jstr));
2181 	json_object_put(json);
2182 	if (strncmp((const char *)act-&gt;file_id_prev, (const char *)act-&gt;file_id, FILE_ID_HASH_SIZE)) {
2183 		removeOldStatefile(statefn, act-&gt;file_id_prev);
2184 	}
2185 finalize_it:
2186 	if(iRet != RS_RET_OK) {
2187 		LogError(0, iRet, "imfile: could not persist state "
2188 				"file %s - data may be repeated on next "
2189 				"startup. Is WorkDirectory set?",
2190 				statefname);
2191 	}
2192 	RETiRet;
2193 }
2194 BEGINafterRun
2195 CODESTARTafterRun
2196 	if(pInputName != NULL)
2197 		prop.Destruct(&amp;pInputName);
2198 ENDafterRun
2199 BEGINisCompatibleWithFeature
2200 CODESTARTisCompatibleWithFeature
2201 	if(eFeat == sFEATURENonCancelInputTermination)
2202 		iRet = RS_RET_OK;
2203 ENDisCompatibleWithFeature
2204 BEGINmodExit
2205 CODESTARTmodExit
2206 	objRelease(strm, CORE_COMPONENT);
2207 	objRelease(glbl, CORE_COMPONENT);
2208 	objRelease(prop, CORE_COMPONENT);
2209 	objRelease(ruleset, CORE_COMPONENT);
2210 	objRelease(datetime, CORE_COMPONENT);
2211 	#ifdef HAVE_INOTIFY_INIT
2212 	free(wdmap);
2213 	#endif
2214 ENDmodExit
2215 BEGINqueryEtryPt
2216 CODESTARTqueryEtryPt
2217 CODEqueryEtryPt_STD_IMOD_QUERIES
2218 CODEqueryEtryPt_STD_CONF2_QUERIES
2219 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
2220 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
2221 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
2222 ENDqueryEtryPt
2223 static rsRetVal
2224 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
2225 {
2226 	DEFiRet;
2227 	free(cs.pszFileName);
2228 	cs.pszFileName = NULL;
2229 	free(cs.pszFileTag);
2230 	cs.pszFileTag = NULL;
2231 	free(cs.pszStateFile);
2232 	cs.pszStateFile = NULL;
2233 	cs.iPollInterval = DFLT_PollInterval;
2234 	cs.iFacility = 128; 	cs.iSeverity = 5;  	cs.readMode = 0;
2235 	cs.maxLinesAtOnce = 10240;
2236 	cs.trimLineOverBytes = 0;
2237 	RETiRet;
2238 }
2239 static inline void
2240 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
2241 {
2242 	LogError(0, NO_ERRCODE, "imfile: ruleset '%s' for %s not found - "
2243 			"using default ruleset instead", inst-&gt;pszBindRuleset,
2244 			inst-&gt;pszFileName);
2245 }
2246 BEGINmodInit()
2247 CODESTARTmodInit
2248 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
2249 	CHKiRet(objUse(glbl, CORE_COMPONENT));
2250 	CHKiRet(objUse(strm, CORE_COMPONENT));
2251 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
2252 	CHKiRet(objUse(prop, CORE_COMPONENT));
2253 	CHKiRet(objUse(datetime, CORE_COMPONENT));
2254 	DBGPRINTF("version %s initializing\n", VERSION);
2255 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilename", 0, eCmdHdlrGetWord,
2256 	  	NULL, &amp;cs.pszFileName, STD_LOADABLE_MODULE_ID));
2257 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletag", 0, eCmdHdlrGetWord,
2258 	  	NULL, &amp;cs.pszFileTag, STD_LOADABLE_MODULE_ID));
2259 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilestatefile", 0, eCmdHdlrGetWord,
2260 	  	NULL, &amp;cs.pszStateFile, STD_LOADABLE_MODULE_ID));
2261 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfileseverity", 0, eCmdHdlrSeverity,
2262 	  	NULL, &amp;cs.iSeverity, STD_LOADABLE_MODULE_ID));
2263 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilefacility", 0, eCmdHdlrFacility,
2264 	  	NULL, &amp;cs.iFacility, STD_LOADABLE_MODULE_ID));
2265 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilereadmode", 0, eCmdHdlrInt,
2266 	  	NULL, &amp;cs.readMode, STD_LOADABLE_MODULE_ID));
2267 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilemaxlinesatonce", 0, eCmdHdlrSize,
2268 	  	NULL, &amp;cs.maxLinesAtOnce, STD_LOADABLE_MODULE_ID));
2269 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfiletrimlineoverbytes", 0, eCmdHdlrSize,
2270 	  	NULL, &amp;cs.trimLineOverBytes, STD_LOADABLE_MODULE_ID));
2271 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilepersiststateinterval", 0, eCmdHdlrInt,
2272 	  	NULL, &amp;cs.iPersistStateInterval, STD_LOADABLE_MODULE_ID));
2273 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputfilebindruleset", 0, eCmdHdlrGetWord,
2274 		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
2275 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputrunfilemonitor", 0, eCmdHdlrGetWord,
2276 		addInstance, NULL, STD_LOADABLE_MODULE_ID));
2277 	CHKiRet(regCfSysLineHdlr2((uchar *)"inputfilepollinterval", 0, eCmdHdlrInt,
2278 	  	NULL, &amp;cs.iPollInterval, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
2279 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
2280 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
2281 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;memory.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;curl/curl.h&gt;
9 #include &lt;curl/easy.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;errno.h&gt;
13 #include &lt;time.h&gt;
14 #include &lt;sys/types.h&gt;
15 #include &lt;sys/stat.h&gt;
16 #include &lt;fcntl.h&gt;
17 #if defined(__FreeBSD__)
18 #include &lt;unistd.h&gt;
19 #endif
20 #include &lt;json.h&gt;
21 #include &lt;zlib.h&gt;
22 #include "conf.h"
23 #include "syslogd-types.h"
24 #include "srUtils.h"
25 #include "template.h"
26 #include "module-template.h"
27 #include "errmsg.h"
28 #include "cfsysline.h"
29 #include "unicode-helper.h"
30 #include "obj-types.h"
31 #include "ratelimit.h"
32 #include "ruleset.h"
33 #include "statsobj.h"
34 #ifndef O_LARGEFILE
35 #  define O_LARGEFILE 0
36 #endif
37 MODULE_TYPE_OUTPUT
38 MODULE_TYPE_NOKEEP
39 MODULE_CNFNAME("omhttp")
40 DEF_OMOD_STATIC_DATA
41 DEFobjCurrIf(prop)
42 DEFobjCurrIf(ruleset)
43 DEFobjCurrIf(statsobj)
44 statsobj_t *httpStats;
45 STATSCOUNTER_DEF(ctrMessagesSubmitted, mutCtrMessagesSubmitted); STATSCOUNTER_DEF(ctrMessagesSuccess, mutCtrMessagesSuccess); STATSCOUNTER_DEF(ctrMessagesFail, mutCtrMessagesFail); STATSCOUNTER_DEF(ctrMessagesRetry, mutCtrMessagesRetry); STATSCOUNTER_DEF(ctrHttpRequestCount, mutCtrHttpRequestCount); STATSCOUNTER_DEF(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess); STATSCOUNTER_DEF(ctrHttpRequestFail, mutCtrHttpRequestFail); STATSCOUNTER_DEF(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess); STATSCOUNTER_DEF(ctrHttpStatusFail, mutCtrHttpStatusFail); 
46 static prop_t *pInputName = NULL;
47 #define WRKR_DATA_TYPE_ES 0xBADF0001
48 #define HTTP_HEADER_CONTENT_JSON "Content-Type: application/json; charset=utf-8"
49 #define HTTP_HEADER_CONTENT_TEXT "Content-Type: text/plain"
50 #define HTTP_HEADER_CONTENT_KAFKA "Content-Type: application/vnd.kafka.v1+json"
51 #define HTTP_HEADER_ENCODING_GZIP "Content-Encoding: gzip"
52 #define HTTP_HEADER_EXPECT_EMPTY "Expect:"
53 #define VALID_BATCH_FORMATS "newline jsonarray kafkarest lokirest"
54 typedef enum batchFormat_e {
55 	FMT_NEWLINE,
56 	FMT_JSONARRAY,
57 	FMT_KAFKAREST,
58 	FMT_LOKIREST
59 } batchFormat_t;
60 typedef struct curl_slist HEADER;
61 typedef struct instanceConf_s {
62 	int defaultPort;
63 	int fdErrFile;			pthread_mutex_t mutErrFile;
64 	uchar **serverBaseUrls;
65 	int numServers;
66 	long healthCheckTimeout;
67 	uchar *uid;
68 	uchar *pwd;
69 	uchar *authBuf;
70 	uchar *httpcontenttype;
71 	uchar *headerContentTypeBuf;
72 	uchar *httpheaderkey;
73 	uchar *httpheadervalue;
74 	uchar *headerBuf;
75 	uchar **httpHeaders;
76 	int nHttpHeaders;
77 	uchar *restPath;
78 	uchar *checkPath;
79 	uchar *tplName;
80 	uchar *errorFile;
81 	sbool batchMode;
82 	uchar *batchFormatName;
83 	batchFormat_t batchFormat;
84 	sbool bFreeBatchFormatName;
85 	sbool dynRestPath;
86 	size_t maxBatchBytes;
87 	size_t maxBatchSize;
88 	sbool compress;
89 	sbool useHttps;
90 	sbool allowUnsignedCerts;
91 	sbool skipVerifyHost;
92 	uchar *caCertFile;
93 	uchar *myCertFile;
94 	uchar *myPrivKeyFile;
95 	sbool reloadOnHup;
96 	sbool retryFailures;
97 	unsigned int ratelimitInterval;
98 	unsigned int ratelimitBurst;
99 	ratelimit_t *ratelimiter;
100 	uchar *retryRulesetName;
101 	ruleset_t *retryRuleset;
102 	struct instanceConf_s *next;
103 } instanceData;
104 struct modConfData_s {
105 	rsconf_t *pConf;			instanceConf_t *root, *tail;
106 };
107 static modConfData_t *loadModConf = NULL;	
108 typedef struct wrkrInstanceData {
109 	PTR_ASSERT_DEF
110 	instanceData *pData;
111 	int serverIndex;
112 	int replyLen;
113 	char *reply;
114 	long httpStatusCode;		CURL	*curlCheckConnHandle;		CURL	*curlPostHandle;		HEADER	*curlHeader;		uchar *restURL;			sbool bzInitDone;
115 	z_stream zstrm; 	struct {
116 		uchar **data;				uchar *restPath;			size_t sizeBytes;			size_t nmemb;		
117 	} batch;
118 	struct {
119 		uchar *buf;
120 <a name="0"></a>		size_t curLen;
121 		size_t len;
122 	} compressCtx;
123 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>} wrkrInstanceData_t;
124 static struct cnfparamdescr actpdescr[] = {
125 	{ "server", eCmdHdlrArray, 0 },
126 	{ "serverport", eCmdHdlrInt, 0 },
127 	{ "healthchecktimeout", eCmdHdlrInt, 0 },
128 	{ "httpcontenttype", eCmdHdlrGetWord, 0 },
129 	{ "httpheaderkey", eCmdHdlrGetWord, 0 },
130 	{ "httpheadervalue", eCmdHdlrString, 0 },
131 	{ "httpheaders", eCmdHdlrArray, 0 },
132 	{ "uid", eCmdHdlrGetWord, 0 },
133 	{ "pwd", eCmdHdlrGetWord, 0 },
134 	{ "restpath", eCmdHdlrGetWord, 0 },
135 	{ "checkpath", eCmdHdlrGetWord, 0 },
136 	{ "dynrestpath", eCmdHdlrBinary, 0 },
137 	{ "batch", eCmdHdlrBinary, 0 },
138 	{ "batch.format", eCmdHdlrGetWord, 0 },
139 	{ "batch.maxbytes", eCmdHdlrSize, 0 },
140 	{ "batch.maxsize", eCmdHdlrSize, 0 },
141 	{ "compress", eCmdHdlrBinary, 0 },
142 	{ "compress.level", eCmdHdlrInt, 0 },
143 	{ "usehttps", eCmdHdlrBinary, 0 },
144 	{ "errorfile", eCmdHdlrGetWord, 0 },
145 	{ "template", eCmdHdlrGetWord, 0 },
146 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
147 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
148 	{ "tls.cacert", eCmdHdlrString, 0 },
149 	{ "tls.mycert", eCmdHdlrString, 0 },
150 	{ "tls.myprivkey", eCmdHdlrString, 0 },
151 	{ "reloadonhup", eCmdHdlrBinary, 0 },
152 	{ "retry", eCmdHdlrBinary, 0 },
153 	{ "retry.ruleset", eCmdHdlrString, 0 },
154 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
155 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
156 };
157 static struct cnfparamblk actpblk =
158 	{ CNFPARAMBLK_VERSION,
159 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
160 	  actpdescr
161 	};
162 static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</b></font>
163 static void curlCleanup(wrkrInstanceData_t *pWrkrData);
164 static void curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData);
165 static void ATTR_NONNULL()
166 initCompressCtx(wrkrInstanceData_t *pWrkrData);
167 static void ATTR_NONNULL()
168 freeCompressCtx(wrkrInstanceData_t *pWrkrData);
169 static rsRetVal ATTR_NONNULL()
170 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len);
171 static rsRetVal ATTR_NONNULL()
172 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen);
173 static rsRetVal ATTR_NONNULL()
174 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen);
175 BEGINcreateInstance
176 CODESTARTcreateInstance
177 	pData-&gt;fdErrFile = -1;
178 	pthread_mutex_init(&amp;pData-&gt;mutErrFile, NULL);
179 	pData-&gt;caCertFile = NULL;
180 	pData-&gt;myCertFile = NULL;
181 	pData-&gt;myPrivKeyFile = NULL;
182 	pData-&gt;ratelimiter = NULL;
183 	pData-&gt;retryRulesetName = NULL;
184 	pData-&gt;retryRuleset = NULL;
185 ENDcreateInstance
186 BEGINcreateWrkrInstance
187 uchar **batchData;
188 CODESTARTcreateWrkrInstance
189 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
190 	pWrkrData-&gt;curlHeader = NULL;
191 	pWrkrData-&gt;curlPostHandle = NULL;
192 	pWrkrData-&gt;curlCheckConnHandle = NULL;
193 	pWrkrData-&gt;serverIndex = 0;
194 	pWrkrData-&gt;httpStatusCode = 0;
195 	pWrkrData-&gt;restURL = NULL;
196 	pWrkrData-&gt;bzInitDone = 0;
197 	if(pData-&gt;batchMode) {
198 		pWrkrData-&gt;batch.nmemb = 0;
199 		pWrkrData-&gt;batch.sizeBytes = 0;
200 		batchData = (uchar **) malloc(pData-&gt;maxBatchSize * sizeof(uchar *));
201 		if (batchData == NULL) {
202 			LogError(0, RS_RET_OUT_OF_MEMORY,
203 				"omhttp: cannot allocate memory for batch queue turning off batch mode\n");
204 			pData-&gt;batchMode = 0; 		} else {
205 			pWrkrData-&gt;batch.data = batchData;
206 			pWrkrData-&gt;batch.restPath = NULL;
207 		}
208 	}
209 	initCompressCtx(pWrkrData);
210 	iRet = curlSetup(pWrkrData);
211 ENDcreateWrkrInstance
212 BEGINisCompatibleWithFeature
213 CODESTARTisCompatibleWithFeature
214 	if(eFeat == sFEATURERepeatedMsgReduction)
215 		iRet = RS_RET_OK;
216 ENDisCompatibleWithFeature
217 BEGINfreeInstance
218 	int i;
219 CODESTARTfreeInstance
220 	if(pData-&gt;fdErrFile != -1)
221 		close(pData-&gt;fdErrFile);
222 	pthread_mutex_destroy(&amp;pData-&gt;mutErrFile);
223 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
224 		free(pData-&gt;serverBaseUrls[i]);
225 	free(pData-&gt;serverBaseUrls);
226 	free(pData-&gt;uid);
227 	free(pData-&gt;httpcontenttype);
228 	free(pData-&gt;headerContentTypeBuf);
229 	free(pData-&gt;httpheaderkey);
230 	free(pData-&gt;httpheadervalue);
231 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i) {
232 		free((void*) pData-&gt;httpHeaders[i]);
233 	}
234 	free(pData-&gt;httpHeaders);
235 	pData-&gt;nHttpHeaders = 0;
236 	free(pData-&gt;pwd);
237 	free(pData-&gt;authBuf);
238 	free(pData-&gt;headerBuf);
239 	free(pData-&gt;restPath);
240 	free(pData-&gt;checkPath);
241 	free(pData-&gt;tplName);
242 	free(pData-&gt;errorFile);
243 	free(pData-&gt;caCertFile);
244 	free(pData-&gt;myCertFile);
245 	free(pData-&gt;myPrivKeyFile);
246 	free(pData-&gt;retryRulesetName);
247 	if (pData-&gt;ratelimiter != NULL)
248 		ratelimitDestruct(pData-&gt;ratelimiter);
249 	if (pData-&gt;bFreeBatchFormatName)
250 		free(pData-&gt;batchFormatName);
251 ENDfreeInstance
252 BEGINfreeWrkrInstance
253 CODESTARTfreeWrkrInstance
254 	curlCleanup(pWrkrData);
255 	free(pWrkrData-&gt;restURL);
256 	pWrkrData-&gt;restURL = NULL;
257 	free(pWrkrData-&gt;batch.data);
258 	pWrkrData-&gt;batch.data = NULL;
259 	if (pWrkrData-&gt;batch.restPath != NULL)  {
260 		free(pWrkrData-&gt;batch.restPath);
261 		pWrkrData-&gt;batch.restPath = NULL;
262 	}
263 	if (pWrkrData-&gt;bzInitDone)
264 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
265 	freeCompressCtx(pWrkrData);
266 ENDfreeWrkrInstance
267 BEGINdbgPrintInstInfo
268 	int i;
269 CODESTARTdbgPrintInstInfo
270 	dbgprintf("omhttp\n");
271 	dbgprintf("\ttemplate='%s'\n", pData-&gt;tplName);
272 	dbgprintf("\tnumServers=%d\n", pData-&gt;numServers);
273 	dbgprintf("\thealthCheckTimeout=%lu\n", pData-&gt;healthCheckTimeout);
274 	dbgprintf("\tserverBaseUrls=");
275 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
276 		dbgprintf("%c'%s'", i == 0 ? '[' : ' ', pData-&gt;serverBaseUrls[i]);
277 	dbgprintf("]\n");
278 	dbgprintf("\tdefaultPort=%d\n", pData-&gt;defaultPort);
279 	dbgprintf("\tuid='%s'\n", pData-&gt;uid == NULL ? (uchar*)"(not configured)" : pData-&gt;uid);
280 	dbgprintf("\thttpcontenttype='%s'\n", pData-&gt;httpcontenttype == NULL ?
281 		(uchar*)"(not configured)" : pData-&gt;httpcontenttype);
282 	dbgprintf("\thttpheaderkey='%s'\n", pData-&gt;httpheaderkey == NULL ?
283 		(uchar*)"(not configured)" : pData-&gt;httpheaderkey);
284 	dbgprintf("\thttpheadervalue='%s'\n", pData-&gt;httpheadervalue == NULL ?
285 		(uchar*)"(not configured)" : pData-&gt;httpheadervalue);
286 	dbgprintf("\thttpHeaders=[");
287 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i)
288 		dbgprintf("\t%s\n",pData-&gt;httpHeaders[i]);
289 	dbgprintf("\t]\n");
290 	dbgprintf("\tpwd=(%sconfigured)\n", pData-&gt;pwd == NULL ? "not " : "");
291 	dbgprintf("\trest path='%s'\n", pData-&gt;restPath);
292 	dbgprintf("\tcheck path='%s'\n", pData-&gt;checkPath);
293 	dbgprintf("\tdynamic rest path=%d\n", pData-&gt;dynRestPath);
294 	dbgprintf("\tuse https=%d\n", pData-&gt;useHttps);
295 	dbgprintf("\tbatch=%d\n", pData-&gt;batchMode);
296 	dbgprintf("\tbatch.format='%s'\n", pData-&gt;batchFormatName);
297 	dbgprintf("\tbatch.maxbytes=%zu\n", pData-&gt;maxBatchBytes);
298 	dbgprintf("\tbatch.maxsize=%zu\n", pData-&gt;maxBatchSize);
299 	dbgprintf("\tcompress=%d\n", pData-&gt;compress);
300 	dbgprintf("\tcompress.level=%d\n", pData-&gt;compressionLevel);
301 	dbgprintf("\tallowUnsignedCerts=%d\n", pData-&gt;allowUnsignedCerts);
302 	dbgprintf("\tskipVerifyHost=%d\n", pData-&gt;skipVerifyHost);
303 	dbgprintf("\terrorfile='%s'\n", pData-&gt;errorFile == NULL ?
304 		(uchar*)"(not configured)" : pData-&gt;errorFile);
305 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
306 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
307 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
308 	dbgprintf("\treloadonhup='%d'\n", pData-&gt;reloadOnHup);
309 	dbgprintf("\tretry='%d'\n", pData-&gt;retryFailures);
310 	dbgprintf("\tretry.ruleset='%s'\n", pData-&gt;retryRulesetName);
311 	dbgprintf("\tratelimit.interval='%u'\n", pData-&gt;ratelimitInterval);
312 	dbgprintf("\tratelimit.burst='%u'\n", pData-&gt;ratelimitBurst);
313 ENDdbgPrintInstInfo
314 static size_t
315 curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
316 {
317 	char *p = (char *)ptr;
318 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
319 	char *buf;
320 	size_t newlen;
321 	PTR_ASSERT_CHK(pWrkrData, WRKR_DATA_TYPE_ES);
322 	newlen = pWrkrData-&gt;replyLen + size*nmemb;
323 	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
324 		LogError(errno, RS_RET_ERR, "omhttp: realloc failed in curlResult");
325 		return 0; 	}
326 	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
327 	pWrkrData-&gt;replyLen = newlen;
328 	pWrkrData-&gt;reply = buf;
329 	return size*nmemb;
330 }
331 static rsRetVal
332 computeBaseUrl(const char*const serverParam,
333 	const int defaultPort,
334 	const sbool useHttps,
335 	uchar **baseUrl)
336 {
337 #	define SCHEME_HTTPS "https://"
338 #	define SCHEME_HTTP "http://"
339 	char portBuf[64];
340 	int r = 0;
341 	const char *host = serverParam;
342 	DEFiRet;
343 	assert(serverParam[strlen(serverParam)-1] != '/');
344 	es_str_t *urlBuf = es_newStr(256);
345 	if (urlBuf == NULL) {
346 		LogError(0, RS_RET_OUT_OF_MEMORY,
347 		"omhttp: failed to allocate es_str urlBuf in computeBaseUrl");
348 		ABORT_FINALIZE(RS_RET_ERR);
349 	}
350 	if (strcasestr(serverParam, SCHEME_HTTP))
351 		host = serverParam + strlen(SCHEME_HTTP);
352 	else if (strcasestr(serverParam, SCHEME_HTTPS))
353 		host = serverParam + strlen(SCHEME_HTTPS);
354 	else
355 		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
356 			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
357 	if (r == 0) r = es_addBuf(&amp;urlBuf, (char *)serverParam, strlen(serverParam));
358 	if (r == 0 &amp;&amp; !strchr(host, ':')) {
359 		snprintf(portBuf, sizeof(portBuf), ":%d", defaultPort);
360 		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
361 	}
362 	if (r == 0) r = es_addChar(&amp;urlBuf, '/');
363 	if (r == 0) *baseUrl = (uchar*) es_str2cstr(urlBuf, NULL);
364 	if (r != 0 || baseUrl == NULL) {
365 		LogError(0, RS_RET_ERR,
366 			"omhttp: error occurred computing baseUrl from server %s", serverParam);
367 		ABORT_FINALIZE(RS_RET_ERR);
368 	}
369 finalize_it:
370 	if (urlBuf) {
371 		es_deleteStr(urlBuf);
372 	}
373 	RETiRet;
374 }
375 static inline void
376 incrementServerIndex(wrkrInstanceData_t *pWrkrData)
377 {
378 	pWrkrData-&gt;serverIndex = (pWrkrData-&gt;serverIndex + 1) % pWrkrData-&gt;pData-&gt;numServers;
379 }
380 static rsRetVal ATTR_NONNULL()
381 checkConn(wrkrInstanceData_t *const pWrkrData)
382 {
383 	CURL *curl;
384 	CURLcode res;
385 	es_str_t *urlBuf = NULL;
386 	char* healthUrl;
387 	char* serverUrl;
388 	char* checkPath;
389 	int i;
390 	int r;
391 	DEFiRet;
392 	if (pWrkrData-&gt;pData-&gt;checkPath == NULL) {
393 		DBGPRINTF("omhttp: checkConn no health check uri configured skipping it\n");
394 		FINALIZE;
395 	}
396 	pWrkrData-&gt;reply = NULL;
397 	pWrkrData-&gt;replyLen = 0;
398 	curl = pWrkrData-&gt;curlCheckConnHandle;
399 	urlBuf = es_newStr(256);
400 	if (urlBuf == NULL) {
401 		LogError(0, RS_RET_OUT_OF_MEMORY,
402 			"omhttp: unable to allocate buffer for health check uri.");
403 		ABORT_FINALIZE(RS_RET_SUSPENDED);
404 	}
405 	for(i = 0; i &lt; pWrkrData-&gt;pData-&gt;numServers; ++i) {
406 		serverUrl = (char*) pWrkrData-&gt;pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
407 		checkPath = (char*) pWrkrData-&gt;pData-&gt;checkPath;
408 		es_emptyStr(urlBuf);
409 		r = es_addBuf(&amp;urlBuf, serverUrl, strlen(serverUrl));
410 		if(r == 0 &amp;&amp; checkPath != NULL)
411 			r = es_addBuf(&amp;urlBuf, checkPath, strlen(checkPath));
412 		if(r == 0)
413 			healthUrl = es_str2cstr(urlBuf, NULL);
414 		if(r != 0 || healthUrl == NULL) {
415 			LogError(0, RS_RET_OUT_OF_MEMORY,
416 				"omhttp: unable to allocate buffer for health check uri.");
417 			ABORT_FINALIZE(RS_RET_SUSPENDED);
418 		}
419 		curlCheckConnSetup(pWrkrData);
420 		curl_easy_setopt(curl, CURLOPT_URL, healthUrl);
421 		res = curl_easy_perform(curl);
422 		free(healthUrl);
423 		if (res == CURLE_OK) {
424 			DBGPRINTF("omhttp: checkConn %s completed with success "
425 				"on attempt %d\n", serverUrl, i);
426 			ABORT_FINALIZE(RS_RET_OK);
427 		}
428 		DBGPRINTF("omhttp: checkConn %s failed on attempt %d: %s\n",
429 			serverUrl, i, curl_easy_strerror(res));
430 		incrementServerIndex(pWrkrData);
431 	}
432 	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
433 		"omhttp: checkConn failed after %d attempts.", i);
434 	ABORT_FINALIZE(RS_RET_SUSPENDED);
435 finalize_it:
436 	if(urlBuf != NULL)
437 		es_deleteStr(urlBuf);
438 	free(pWrkrData-&gt;reply);
439 	pWrkrData-&gt;reply = NULL; 	RETiRet;
440 }
441 BEGINtryResume
442 CODESTARTtryResume
443 	DBGPRINTF("omhttp: tryResume called\n");
444 	iRet = checkConn(pWrkrData);
445 ENDtryResume
446 static void ATTR_NONNULL(1)
447 getRestPath(const instanceData *const pData, uchar **const tpls,
448 		      uchar **const restPath)
449 {
450 	*restPath = pData-&gt;restPath;
451 	if(tpls == NULL) {
452 		goto done;
453 	}
454 	int iNumTpls = 1;
455 	if(pData-&gt;dynRestPath) {
456 		*restPath = tpls[iNumTpls];
457 		++iNumTpls;
458 	}
459 done:
460 	assert(restPath != NULL);
461 	return;
462 }
463 static rsRetVal ATTR_NONNULL(1)
464 setPostURL(wrkrInstanceData_t *const pWrkrData, uchar **const tpls)
465 {
466 	uchar *restPath;
467 	char* baseUrl;
468 	es_str_t *url;
469 	int r;
470 	DEFiRet;
471 	instanceData *const pData = pWrkrData-&gt;pData;
472 	baseUrl = (char*)pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
473 	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
474 	if (url == NULL) {
475 		LogError(0, RS_RET_OUT_OF_MEMORY,
476 			"omhttp: error allocating new estr for POST url.");
477 		ABORT_FINALIZE(RS_RET_ERR);
478 	}
479 	if (pWrkrData-&gt;batch.restPath != NULL) {
480 		restPath = pWrkrData-&gt;batch.restPath;
481 	} else {
482 		getRestPath(pData, tpls, &amp;restPath);
483 	}
484 	r = 0;
485 	if (restPath != NULL)
486 		r = es_addBuf(&amp;url, (char*)restPath, ustrlen(restPath));
487 	if(r != 0) {
488 		LogError(0, RS_RET_ERR, "omhttp: failure in creating restURL, "
489 				"error code: %d", r);
490 		ABORT_FINALIZE(RS_RET_ERR);
491 	}
492 	if(pWrkrData-&gt;restURL != NULL)
493 		free(pWrkrData-&gt;restURL);
494 	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
495 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
496 	DBGPRINTF("omhttp: using REST URL: '%s'\n", pWrkrData-&gt;restURL);
497 finalize_it:
498 	if (url != NULL)
499 		es_deleteStr(url);
500 	RETiRet;
501 }
502 static rsRetVal
503 renderJsonErrorMessage(wrkrInstanceData_t *pWrkrData, uchar *reqmsg, char **rendered)
504 {
505 	DEFiRet;
506 	fjson_object *req = NULL;
507 	fjson_object *res = NULL;
508 	fjson_object *errRoot = NULL;
509 	if ((req = fjson_object_new_object()) == NULL)
510 		ABORT_FINALIZE(RS_RET_ERR);
511 	fjson_object_object_add(req, "url", fjson_object_new_string((char *)pWrkrData-&gt;restURL));
512 	fjson_object_object_add(req, "postdata", fjson_object_new_string((char *)reqmsg));
513 	if ((res = fjson_object_new_object()) == NULL) {
514 		fjson_object_put(req); 		ABORT_FINALIZE(RS_RET_ERR);
515 	}
516 	#define ERR_MSG_NULL "NULL: curl request failed or no response"
517 	fjson_object_object_add(res, "status", fjson_object_new_int(pWrkrData-&gt;httpStatusCode));
518 	if (pWrkrData-&gt;reply == NULL) {
519 		fjson_object_object_add(res, "message",
520 			fjson_object_new_string_len(ERR_MSG_NULL, strlen(ERR_MSG_NULL)));
521 	} else {
522 		fjson_object_object_add(res, "message",
523 			fjson_object_new_string_len(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen));
524 	}
525 	if ((errRoot = fjson_object_new_object()) == NULL) {
526 		fjson_object_put(req); 		fjson_object_put(res); 		ABORT_FINALIZE(RS_RET_ERR);
527 	}
528 	fjson_object_object_add(errRoot, "request", req);
529 	fjson_object_object_add(errRoot, "response", res);
530 	*rendered = strdup((char *) fjson_object_to_json_string(errRoot));
531 finalize_it:
532 	if (errRoot != NULL)
533 		fjson_object_put(errRoot);
534 	RETiRet;
535 }
536 static rsRetVal ATTR_NONNULL()
537 writeDataError(wrkrInstanceData_t *const pWrkrData,
538 	instanceData *const pData, uchar *const reqmsg)
539 {
540 	char *rendered = NULL;
541 	size_t toWrite;
542 	ssize_t wrRet;
543 	sbool bMutLocked = 0;
544 	DEFiRet;
545 	if(pData-&gt;errorFile == NULL) {
546 		DBGPRINTF("omhttp: no local error logger defined - "
547 			"ignoring REST error information\n");
548 		FINALIZE;
549 	}
550 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
551 	bMutLocked = 1;
552 	CHKiRet(renderJsonErrorMessage(pWrkrData, reqmsg, &amp;rendered));
553 	if(pData-&gt;fdErrFile == -1) {
554 		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
555 					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
556 					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
557 		if(pData-&gt;fdErrFile == -1) {
558 			LogError(errno, RS_RET_ERR, "omhttp: error opening error file %s",
559 				pData-&gt;errorFile);
560 			ABORT_FINALIZE(RS_RET_ERR);
561 		}
562 	}
563 	DBGPRINTF("omhttp: error record: '%s'\n", rendered);
564 	toWrite = strlen(rendered) + 1;
565 	rendered[toWrite-1] = '\n'; 	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
566 	if(wrRet != (ssize_t) toWrite) {
567 		LogError(errno, RS_RET_IO_ERROR,
568 			"omhttp: error writing error file %s, write returned %lld",
569 			pData-&gt;errorFile, (long long) wrRet);
570 	}
571 finalize_it:
572 	if(bMutLocked)
573 		pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
574 	free(rendered);
575 	RETiRet;
576 }
577 static rsRetVal
578 queueBatchOnRetryRuleset(wrkrInstanceData_t *const pWrkrData, instanceData *const pData)
579 {
580 	uchar *msgData;
581 	smsg_t *pMsg;
582 	DEFiRet;
583 	if (pData-&gt;retryRuleset == NULL) {
584 		LogError(0, RS_RET_ERR, "omhttp: queueBatchOnRetryRuleset invalid call with a NULL retryRuleset");
585 		ABORT_FINALIZE(RS_RET_ERR);
586 	}
587 	for (size_t i = 0; i &lt; pWrkrData-&gt;batch.nmemb; i++) {
588 		msgData = pWrkrData-&gt;batch.data[i];
589 		DBGPRINTF("omhttp: queueBatchOnRetryRuleset putting message '%s' into retry ruleset '%s'\n",
590 			msgData, pData-&gt;retryRulesetName);
591 		CHKiRet(msgConstruct(&amp;pMsg));
592 		CHKiRet(MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY));
593 		MsgSetInputName(pMsg, pInputName);
594 		MsgSetRawMsg(pMsg, (const char *)msgData, ustrlen(msgData));
595 		MsgSetMSGoffs(pMsg, 0); 		MsgSetTAG(pMsg, (const uchar *)"omhttp-retry", 12);
596 		MsgSetRuleset(pMsg, pData-&gt;retryRuleset);
597 		ratelimitAddMsg(pData-&gt;ratelimiter, NULL, pMsg);
598 		STATSCOUNTER_INC(ctrMessagesRetry, mutCtrMessagesRetry);
599 	}
600 finalize_it:
601 	RETiRet;
602 }
603 static rsRetVal
604 checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
605 {
606 	instanceData *pData;
607 	long statusCode;
608 	size_t numMessages;
609 	DEFiRet;
610 	pData = pWrkrData-&gt;pData;
611 	statusCode = pWrkrData-&gt;httpStatusCode;
612 	if (pData-&gt;batchMode) {
613 		numMessages = pWrkrData-&gt;batch.nmemb;
614 	} else {
615 		numMessages = 1;
616 	}
617 	if (statusCode == 0) {
618 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
619 		iRet = RS_RET_SUSPENDED;
620 	} else if (statusCode &gt;= 500) {
621 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
622 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
623 		iRet = RS_RET_SUSPENDED;
624 	} else if (statusCode &gt;= 300) {
625 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
626 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
627 		iRet = RS_RET_DATAFAIL;
628 	} else {
629 		STATSCOUNTER_INC(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
630 		STATSCOUNTER_ADD(ctrMessagesSuccess, mutCtrMessagesSuccess, numMessages);
631 		iRet = RS_RET_OK;
632 	}
633 	if (iRet != RS_RET_OK) {
634 		LogMsg(0, iRet, LOG_ERR, "omhttp: checkResult error http status code: %ld reply: %s",
635 			statusCode, pWrkrData-&gt;reply != NULL ? pWrkrData-&gt;reply : "NULL");
636 		writeDataError(pWrkrData, pWrkrData-&gt;pData, reqmsg);
637 		if (iRet == RS_RET_DATAFAIL)
638 			ABORT_FINALIZE(iRet);
639 		if (pData-&gt;batchMode &amp;&amp; pData-&gt;maxBatchSize &gt; 1) {
640 			if (pData-&gt;retryFailures &amp;&amp; pData-&gt;retryRuleset != NULL) {
641 				iRet = queueBatchOnRetryRuleset(pWrkrData, pData);
642 				if (iRet != RS_RET_OK) {
643 					LogMsg(0, iRet, LOG_ERR,
644 						"omhttp: checkResult error while queueing to retry ruleset"
645 						"some messages may be lost");
646 				}
647 			}
648 			iRet = RS_RET_OK; 		}
649 	}
650 finalize_it:
651 	RETiRet;
652 }
653 static rsRetVal
654 compressHttpPayload(wrkrInstanceData_t *pWrkrData, uchar *message, unsigned len)
655 {
656 	int zRet;
657 	unsigned outavail;
658 	uchar zipBuf[32*1024];
659 	DEFiRet;
660 	if (!pWrkrData-&gt;bzInitDone) {
661 		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
662 		pWrkrData-&gt;zstrm.zfree = Z_NULL;
663 		pWrkrData-&gt;zstrm.opaque = Z_NULL;
664 		zRet = deflateInit2(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel,
665 			Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
666 		if (zRet != Z_OK) {
667 			DBGPRINTF("omhttp: compressHttpPayload error %d returned from zlib/deflateInit2()\n", zRet);
668 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
669 		}
670 		pWrkrData-&gt;bzInitDone = 1;
671 	}
672 	CHKiRet(resetCompressCtx(pWrkrData, len));
673 	pWrkrData-&gt;zstrm.next_in = (Bytef*) message;
674 	pWrkrData-&gt;zstrm.avail_in = len;
675 	do {
676 		DBGPRINTF("omhttp: compressHttpPayload in deflate() loop, avail_in %d, total_in %ld\n",
677 				pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in);
678 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
679 		pWrkrData-&gt;zstrm.next_out = zipBuf;
680 		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_NO_FLUSH);
681 		DBGPRINTF("omhttp: compressHttpPayload after deflate, ret %d, avail_out %d\n",
682 				zRet, pWrkrData-&gt;zstrm.avail_out);
683 		if (zRet != Z_OK)
684 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
685 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
686 		if (outavail != 0)
687 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
688 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
689 	pWrkrData-&gt;zstrm.avail_in = 0;
690 	do {
691 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
692 		pWrkrData-&gt;zstrm.next_out = zipBuf;
693 		deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH); 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
694 		if (outavail != 0)
695 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
696 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
697 finalize_it:
698 	if (pWrkrData-&gt;bzInitDone)
699 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
700 	pWrkrData-&gt;bzInitDone = 0;
701 	RETiRet;
702 }
703 static void ATTR_NONNULL()
704 initCompressCtx(wrkrInstanceData_t *pWrkrData)
705 {
706 	pWrkrData-&gt;compressCtx.buf = NULL;
707 	pWrkrData-&gt;compressCtx.curLen = 0;
708 	pWrkrData-&gt;compressCtx.len = 0;
709 }
710 static void ATTR_NONNULL()
711 freeCompressCtx(wrkrInstanceData_t *pWrkrData)
712 {
713 	if (pWrkrData-&gt;compressCtx.buf != NULL) {
714 		free(pWrkrData-&gt;compressCtx.buf);
715 		pWrkrData-&gt;compressCtx.buf = NULL;
716 	}
717 }
718 static rsRetVal ATTR_NONNULL()
719 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len)
720 {
721 	DEFiRet;
722 	pWrkrData-&gt;compressCtx.curLen = 0;
723 	pWrkrData-&gt;compressCtx.len = len;
724 	CHKiRet(growCompressCtx(pWrkrData, len));
725 finalize_it:
726 	if (iRet != RS_RET_OK)
727 		freeCompressCtx(pWrkrData);
728 	RETiRet;
729 }
730 static rsRetVal ATTR_NONNULL()
731 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen)
732 {
733 	DEFiRet;
734 	if (pWrkrData-&gt;compressCtx.buf == NULL) {
735 		CHKmalloc(pWrkrData-&gt;compressCtx.buf = (uchar *)malloc(sizeof(uchar)*newLen));
736 	} else {
737 		uchar *const newbuf = (uchar *)realloc(pWrkrData-&gt;compressCtx.buf, sizeof(uchar)*newLen);
738 		CHKmalloc(newbuf);
739 		pWrkrData-&gt;compressCtx.buf = newbuf;
740 	}
741 	pWrkrData-&gt;compressCtx.len = newLen;
742 finalize_it:
743 	RETiRet;
744 }
745 static rsRetVal ATTR_NONNULL()
746 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen)
747 {
748 	size_t newLen;
749 	DEFiRet;
750 	newLen = pWrkrData-&gt;compressCtx.curLen + srcLen;
751 	if (newLen &gt; pWrkrData-&gt;compressCtx.len)
752 		CHKiRet(growCompressCtx(pWrkrData, newLen));
753 	memcpy(pWrkrData-&gt;compressCtx.buf + pWrkrData-&gt;compressCtx.curLen,
754 		srcBuf, srcLen);
755 	pWrkrData-&gt;compressCtx.curLen = newLen;
756 finalize_it:
757 	if (iRet != RS_RET_OK)
758 		freeCompressCtx(pWrkrData);
759 	RETiRet;
760 }
761 static rsRetVal ATTR_NONNULL()
762 buildCurlHeaders(wrkrInstanceData_t *pWrkrData, sbool contentEncodeGzip)
763 {
764 	struct curl_slist *slist = NULL;
765 	DEFiRet;
766 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
767 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
768 	} else {
769 		if (pWrkrData-&gt;pData-&gt;batchMode) {
770 			switch (pWrkrData-&gt;pData-&gt;batchFormat) {
771 				case FMT_JSONARRAY:
772 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
773 					break;
774 				case FMT_KAFKAREST:
775 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_KAFKA);
776 					break;
777 				case FMT_NEWLINE:
778 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
779 					break;
780 				case FMT_LOKIREST:
781 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
782 					break;
783 				default:
784 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
785 			}
786 		} else {
787 			slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
788 		}
789 	}
790 	CHKmalloc(slist);
791 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
792 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
793 		CHKmalloc(slist);
794 	}
795 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
796 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
797 		CHKmalloc(slist);
798 	}
799 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
800 	CHKmalloc(slist);
801 	if (contentEncodeGzip) {
802 		slist = curl_slist_append(slist, HTTP_HEADER_ENCODING_GZIP);
803 		CHKmalloc(slist);
804 	}
805 	if (pWrkrData-&gt;curlHeader != NULL)
806 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
807 	pWrkrData-&gt;curlHeader = slist;
808 finalize_it:
809 	if (iRet != RS_RET_OK) {
810 		curl_slist_free_all(slist);
811 		LogError(0, iRet, "omhttp: error allocating curl header slist, using previous one");
812 	}
813 	RETiRet;
814 }
815 static rsRetVal ATTR_NONNULL(1, 2)
816 curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, uchar **tpls,
817 		const int nmsgs __attribute__((unused)))
818 {
819 	CURLcode curlCode;
820 	CURL *const curl = pWrkrData-&gt;curlPostHandle;
821 	char errbuf[CURL_ERROR_SIZE] = "";
822 	char *postData;
823 	int postLen;
824 	sbool compressed;
825 	DEFiRet;
826 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
827 	if(pWrkrData-&gt;pData-&gt;numServers &gt; 1) {
828 		CHKiRet(checkConn(pWrkrData));
829 	}
830 	CHKiRet(setPostURL(pWrkrData, tpls));
831 	pWrkrData-&gt;reply = NULL;
832 	pWrkrData-&gt;replyLen = 0;
833 	pWrkrData-&gt;httpStatusCode = 0;
834 	postData = (char *)message;
835 	postLen = msglen;
836 	compressed = 0;
837 	if (pWrkrData-&gt;pData-&gt;compress) {
838 		iRet = compressHttpPayload(pWrkrData, message, msglen);
839 		if (iRet != RS_RET_OK) {
840 			LogError(0, iRet, "omhttp: curlPost error while compressing, will default to uncompressed");
841 		} else {
842 			postData = (char *)pWrkrData-&gt;compressCtx.buf;
843 			postLen = pWrkrData-&gt;compressCtx.curLen;
844 			compressed = 1;
845 			DBGPRINTF("omhttp: curlPost compressed %d to %d bytes\n", msglen, postLen);
846 		}
847 	}
848 	buildCurlHeaders(pWrkrData, compressed);
849 	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);
850 	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, postLen);
851 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
852 	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
853 	curlCode = curl_easy_perform(curl);
854 	DBGPRINTF("omhttp: curlPost curl returned %lld\n", (long long) curlCode);
855 	STATSCOUNTER_INC(ctrHttpRequestCount, mutCtrHttpRequestCount);
856 	if (curlCode != CURLE_OK) {
857 		STATSCOUNTER_INC(ctrHttpRequestFail, mutCtrHttpRequestFail);
858 		LogError(0, RS_RET_SUSPENDED,
859 			"omhttp: suspending ourselves due to server failure %lld: %s",
860 			(long long) curlCode, errbuf);
861 		checkResult(pWrkrData, message);
862 		ABORT_FINALIZE(RS_RET_SUSPENDED);
863 	} else {
864 		STATSCOUNTER_INC(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
865 	}
866 	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;pWrkrData-&gt;httpStatusCode);
867 	if(pWrkrData-&gt;reply == NULL) {
868 		DBGPRINTF("omhttp: curlPost pWrkrData reply==NULL, replyLen = '%d'\n",
869 			pWrkrData-&gt;replyLen);
870 	} else {
871 		DBGPRINTF("omhttp: curlPost pWrkrData replyLen = '%d'\n", pWrkrData-&gt;replyLen);
872 		if(pWrkrData-&gt;replyLen &gt; 0) {
873 			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
874 		}
875 		DBGPRINTF("omhttp: curlPost pWrkrData reply: '%s'\n", pWrkrData-&gt;reply);
876 	}
877 	CHKiRet(checkResult(pWrkrData, message));
878 finalize_it:
879 	incrementServerIndex(pWrkrData);
880 	if (pWrkrData-&gt;reply != NULL) {
881 		free(pWrkrData-&gt;reply);
882 		pWrkrData-&gt;reply = NULL; 	}
883 	RETiRet;
884 }
885 static rsRetVal
886 serializeBatchKafkaRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
887 {
888 	fjson_object *batchArray = NULL;
889 	fjson_object *recordObj = NULL;
890 	fjson_object *valueObj = NULL;
891 	fjson_object *msgObj = NULL;
892 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
893 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchKafkaRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
894 	DEFiRet;
895 	batchArray = fjson_object_new_array();
896 	if (batchArray == NULL) {
897 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create array");
898 		ABORT_FINALIZE(RS_RET_ERR);
899 	}
900 	for (size_t i = 0; i &lt; numMessages; i++) {
901 		valueObj = fjson_object_new_object();
902 		if (valueObj == NULL) {
903 			fjson_object_put(batchArray); 			LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create value object");
904 			ABORT_FINALIZE(RS_RET_ERR);
905 		}
906 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
907 		if (msgObj == NULL) {
908 			LogError(0, NO_ERRCODE,
909 				"omhttp: serializeBatchKafkaRest failed to parse %s as json ignoring it",
910 				pWrkrData-&gt;batch.data[i]);
911 			continue;
912 		}
913 		fjson_object_object_add(valueObj, "value", msgObj);
914 		fjson_object_array_add(batchArray, valueObj);
915 	}
916 	recordObj = fjson_object_new_object();
917 	if (recordObj == NULL) {
918 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create record object");
919 		ABORT_FINALIZE(RS_RET_ERR);
920 	}
921 	fjson_object_object_add(recordObj, "records", batchArray);
922 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
923 	*batchBuf = strndup(batchString, strlen(batchString));
924 finalize_it:
925 	if (recordObj != NULL) {
926 		fjson_object_put(recordObj);
927 		recordObj = NULL;
928 	}
929 	RETiRet;
930 }
931 static rsRetVal
932 serializeBatchLokiRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
933 {
934 	fjson_object *batchArray = NULL;
935 	fjson_object *recordObj = NULL;
936 	fjson_object *msgObj = NULL;
937 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
938 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchLokiRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
939 	DEFiRet;
940 	batchArray = fjson_object_new_array();
941 	if (batchArray == NULL) {
942 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create array");
943 		ABORT_FINALIZE(RS_RET_ERR);
944 	}
945 	for (size_t i = 0; i &lt; numMessages; i++) {
946 		DBGPRINTF("omhttp: serializeBatchLokiRest parsing message [%s]\n",(char *) pWrkrData-&gt;batch.data[i]);
947 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
948 		if (msgObj == NULL) {
949 			LogError(0, NO_ERRCODE,
950 				"omhttp: serializeBatchLokiRest failed to parse %s as json ignoring it",
951 				pWrkrData-&gt;batch.data[i]);
952 			continue;
953 		}
954 		fjson_object_array_add(batchArray, msgObj);
955 	}
956 	recordObj = fjson_object_new_object();
957 	if (recordObj == NULL) {
958 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create record object");
959 		ABORT_FINALIZE(RS_RET_ERR);
960 	}
961 	fjson_object_object_add(recordObj, "streams", batchArray);
962 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
963 	*batchBuf = strndup(batchString, strlen(batchString));
964 finalize_it:
965 	if (recordObj != NULL) {
966 		fjson_object_put(recordObj);
967 		recordObj = NULL;
968 	}
969 	RETiRet;
970 }
971 static rsRetVal
972 serializeBatchJsonArray(wrkrInstanceData_t *pWrkrData, char **batchBuf)
973 {
974 	fjson_object *batchArray = NULL;
975 	fjson_object *msgObj = NULL;
976 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
977 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchJsonArray numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
978 	DEFiRet;
979 	batchArray = fjson_object_new_array();
980 	if (batchArray == NULL) {
981 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchJsonArray failed to create array");
982 		ABORT_FINALIZE(RS_RET_ERR);
983 	}
984 	for (size_t i = 0; i &lt; numMessages; i++) {
985 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
986 		if (msgObj == NULL) {
987 			LogError(0, NO_ERRCODE,
988 				"omhttp: serializeBatchJsonArray failed to parse %s as json, ignoring it",
989 				pWrkrData-&gt;batch.data[i]);
990 			continue;
991 		}
992 		fjson_object_array_add(batchArray, msgObj);
993 	}
994 	const char *batchString = fjson_object_to_json_string_ext(batchArray, FJSON_TO_STRING_PLAIN);
995 	*batchBuf = strndup(batchString, strlen(batchString));
996 finalize_it:
997 	if (batchArray != NULL) {
998 		fjson_object_put(batchArray);
999 		batchArray = NULL;
1000 	}
1001 	RETiRet;
1002 }
1003 static rsRetVal
1004 serializeBatchNewline(wrkrInstanceData_t *pWrkrData, char **batchBuf)
1005 {
1006 	DEFiRet;
1007 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1008 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages; 	int r = 0;
1009 	DBGPRINTF("omhttp: serializeBatchNewline numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
1010 	es_str_t *batchString = es_newStr(1024);
1011 	if (batchString == NULL)
1012 		ABORT_FINALIZE(RS_RET_ERR);
1013 	for (size_t i = 0; i &lt; numMessages; i++) {
1014 		size_t nToCopy = ustrlen(pWrkrData-&gt;batch.data[i]);
1015 		if (r == 0) r = es_addBuf(&amp;batchString, (char *)pWrkrData-&gt;batch.data[i], nToCopy);
1016 		if (i == numMessages - 1) break;
1017 		if (r == 0) r = es_addChar(&amp;batchString, '\n');
1018 	}
1019 	if (r == 0) *batchBuf = (char *) es_str2cstr(batchString, NULL);
1020 	if (r != 0 || *batchBuf== NULL) {
1021 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchNewline failed to build batch string");
1022 		ABORT_FINALIZE(RS_RET_ERR);
1023 	}
1024 finalize_it:
1025 	if (batchString != NULL)
1026 		es_deleteStr(batchString);
1027 	RETiRet;
1028 }
1029 static size_t
1030 computeBatchSize(wrkrInstanceData_t *pWrkrData)
1031 {
1032 	size_t extraBytes = 0;
1033 	size_t sizeBytes = pWrkrData-&gt;batch.sizeBytes;
1034 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1035 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1036 		case FMT_JSONARRAY:
1037 			extraBytes = numMessages &gt; 0 ? numMessages + 1 : 2;
1038 			break;
1039 		case FMT_KAFKAREST:
1040 			extraBytes = (numMessages * 10) + 14;
1041 			break;
1042 		case FMT_NEWLINE:
1043 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1044 			break;
1045 		case FMT_LOKIREST:
1046 			extraBytes = (numMessages * 2) + 14;
1047 			break;
1048 		default:
1049 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1050 	}
1051 	return sizeBytes + extraBytes + 1; }
1052 static void ATTR_NONNULL()
1053 initializeBatch(wrkrInstanceData_t *pWrkrData)
1054 {
1055 	pWrkrData-&gt;batch.sizeBytes = 0;
1056 	pWrkrData-&gt;batch.nmemb = 0;
1057 	if (pWrkrData-&gt;batch.restPath != NULL)  {
1058 		free(pWrkrData-&gt;batch.restPath);
1059 		pWrkrData-&gt;batch.restPath = NULL;
1060 	}
1061 }
1062 static rsRetVal
1063 buildBatch(wrkrInstanceData_t *pWrkrData, uchar *message)
1064 {
1065 	DEFiRet;
1066 	if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1067 		LogError(0, RS_RET_ERR, "omhttp: buildBatch something has gone wrong,"
1068 			"number of messages in batch is bigger than the max batch size, bailing");
1069 		ABORT_FINALIZE(RS_RET_ERR);
1070 	}
1071 	pWrkrData-&gt;batch.data[pWrkrData-&gt;batch.nmemb] = message;
1072 	pWrkrData-&gt;batch.sizeBytes += strlen((char *)message);
1073 	pWrkrData-&gt;batch.nmemb++;
1074 finalize_it:
1075 	RETiRet;
1076 }
1077 static rsRetVal
1078 submitBatch(wrkrInstanceData_t *pWrkrData, uchar **tpls)
1079 {
1080 	DEFiRet;
1081 	char *batchBuf = NULL;
1082 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1083 		case FMT_JSONARRAY:
1084 			iRet = serializeBatchJsonArray(pWrkrData, &amp;batchBuf);
1085 			break;
1086 		case FMT_KAFKAREST:
1087 			iRet = serializeBatchKafkaRest(pWrkrData, &amp;batchBuf);
1088 			break;
1089 		case FMT_LOKIREST:
1090 			iRet = serializeBatchLokiRest(pWrkrData, &amp;batchBuf);
1091 			break;
1092 		case FMT_NEWLINE:
1093 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1094 			break;
1095 		default:
1096 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1097 	}
1098 	if (iRet != RS_RET_OK || batchBuf == NULL)
1099 		ABORT_FINALIZE(iRet);
1100 	DBGPRINTF("omhttp: submitBatch, batch: '%s' tpls: '%p'\n", batchBuf, tpls);
1101 	CHKiRet(curlPost(pWrkrData, (uchar*) batchBuf, strlen(batchBuf),
1102 		tpls, pWrkrData-&gt;batch.nmemb));
1103 finalize_it:
1104 	if (batchBuf != NULL)
1105 		free(batchBuf);
1106 	RETiRet;
1107 }
1108 BEGINbeginTransaction
1109 CODESTARTbeginTransaction
1110 	if(!pWrkrData-&gt;pData-&gt;batchMode) {
1111 		FINALIZE;
1112 	}
1113 	initializeBatch(pWrkrData);
1114 finalize_it:
1115 ENDbeginTransaction
1116 BEGINdoAction
1117 size_t nBytes;
1118 sbool submit;
1119 CODESTARTdoAction
1120 	instanceData *const pData = pWrkrData-&gt;pData;
1121 	uchar *restPath = NULL;
1122 	STATSCOUNTER_INC(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1123 	if (pWrkrData-&gt;pData-&gt;batchMode) {
1124 		if(pData-&gt;dynRestPath) {
1125 			getRestPath(pData, ppString, &amp;restPath);
1126 			if (pWrkrData-&gt;batch.restPath == NULL) {
1127 				pWrkrData-&gt;batch.restPath = (uchar*)strdup((char*)restPath);
1128 			} else if (strcmp((char*)pWrkrData-&gt;batch.restPath, (char*)restPath) != 0) {
1129 				CHKiRet(submitBatch(pWrkrData, NULL));
1130 				initializeBatch(pWrkrData);
1131 			}
1132 		}
1133 		if (pWrkrData-&gt;pData-&gt;maxBatchSize == 1) {
1134 			initializeBatch(pWrkrData);
1135 			CHKiRet(buildBatch(pWrkrData, ppString[0]));
1136 			CHKiRet(submitBatch(pWrkrData, ppString));
1137 			FINALIZE;
1138 		}
1139 		nBytes = ustrlen((char *)ppString[0]) - 1 ;
1140 		submit = 0;
1141 		if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1142 			submit = 1;
1143 			DBGPRINTF("omhttp: maxbatchsize limit reached submitting batch of %zd elements.\n",
1144 				pWrkrData-&gt;batch.nmemb);
1145 		} else if (computeBatchSize(pWrkrData) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes) {
1146 			submit = 1;
1147 			DBGPRINTF("omhttp: maxbytes limit reached submitting partial batch of %zd elements.\n",
1148 				pWrkrData-&gt;batch.nmemb);
1149 		}
1150 		if (submit) {
1151 			CHKiRet(submitBatch(pWrkrData, ppString));
1152 			initializeBatch(pWrkrData);
1153 		}
1154 		CHKiRet(buildBatch(pWrkrData, ppString[0]));
1155 		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
1156 	} else {
1157 		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), ppString, 1));
1158 	}
1159 finalize_it:
1160 ENDdoAction
1161 BEGINendTransaction
1162 CODESTARTendTransaction
1163 	if (pWrkrData-&gt;batch.nmemb &gt; 0) {
1164 		CHKiRet(submitBatch(pWrkrData, NULL));
1165 	} else {
1166 		dbgprintf("omhttp: endTransaction, pWrkrData-&gt;batch.nmemb = 0, "
1167 			"nothing to send. \n");
1168 	}
1169 finalize_it:
1170 ENDendTransaction
1171 static rsRetVal
1172 computeAuthHeader(char* uid, char* pwd, uchar** authBuf)
1173 {
1174 	int r;
1175 	DEFiRet;
1176 	es_str_t* auth = es_newStr(1024);
1177 	if (auth == NULL) {
1178 		LogError(0, RS_RET_OUT_OF_MEMORY,
1179 			"omhttp: failed to allocate es_str auth for auth header construction");
1180 		ABORT_FINALIZE(RS_RET_ERR);
1181 	}
1182 	r = es_addBuf(&amp;auth, uid, strlen(uid));
1183 	if(r == 0) r = es_addChar(&amp;auth, ':');
1184 	if(r == 0 &amp;&amp; pwd != NULL) r = es_addBuf(&amp;auth, pwd, strlen(pwd));
1185 	if(r == 0) *authBuf = (uchar*) es_str2cstr(auth, NULL);
1186 	if (r != 0 || *authBuf == NULL) {
1187 		LogError(0, RS_RET_ERR, "omhttp: failed to build auth header\n");
1188 		ABORT_FINALIZE(RS_RET_ERR);
1189 	}
1190 finalize_it:
1191 	if (auth != NULL)
1192 		es_deleteStr(auth);
1193 	RETiRet;
1194 }
1195 static rsRetVal
1196 computeApiHeader(char* key, char* value, uchar** headerBuf)
1197 {
1198 	int r;
1199 	DEFiRet;
1200 	es_str_t* header = es_newStr(10240);
1201 	if (header == NULL) {
1202 		LogError(0, RS_RET_OUT_OF_MEMORY,
1203 		"omhttp: failed to allocate es_str auth for api header construction");
1204 		ABORT_FINALIZE(RS_RET_ERR);
1205 	}
1206 	r = es_addBuf(&amp;header, key, strlen(key));
1207 	if(r == 0) r = es_addChar(&amp;header, ':');
1208 	if(r == 0) r = es_addChar(&amp;header, ' ');
1209 	if(r == 0 &amp;&amp; value != NULL) r = es_addBuf(&amp;header, value, strlen(value));
1210 	if(r == 0) *headerBuf = (uchar*) es_str2cstr(header, NULL);
1211 	if (r != 0 || *headerBuf == NULL) {
1212 		LogError(0, RS_RET_ERR, "omhttp: failed to build http header\n");
1213 		ABORT_FINALIZE(RS_RET_ERR);
1214 	}
1215 finalize_it:
1216 	if (header != NULL)
1217 		es_deleteStr(header);
1218 	RETiRet;
1219 }
1220 static void ATTR_NONNULL()
1221 curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
1222 {
1223 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1224 	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
1225 	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
1226 	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
1227 	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
1228 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
1229 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
1230 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
1231 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
1232 	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
1233 		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
1234 		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
1235 	}
1236 	if(pWrkrData-&gt;pData-&gt;caCertFile)
1237 		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
1238 	if(pWrkrData-&gt;pData-&gt;myCertFile)
1239 		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
1240 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
1241 		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
1242 }
1243 static void ATTR_NONNULL()
1244 curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
1245 {
1246 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1247 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
1248 	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
1249 		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
1250 }
1251 static void ATTR_NONNULL(1)
1252 curlPostSetup(wrkrInstanceData_t *const pWrkrData)
1253 {
1254 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1255 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
1256 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
1257 	CURLcode cRet;
1258 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPALIVE, 1L);
1259 	if (cRet != CURLE_OK)
1260 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPALIVE\n");
1261 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPIDLE, 120L);
1262 	if (cRet != CURLE_OK)
1263 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPIDLE\n");
1264 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPINTVL, 60L);
1265 	if (cRet != CURLE_OK)
1266 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPINTVL\n");
1267 }
1268 static rsRetVal ATTR_NONNULL()
1269 curlSetup(wrkrInstanceData_t *const pWrkrData)
1270 {
1271 	struct curl_slist *slist = NULL;
1272 	DEFiRet;
1273 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
1274 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
1275 	} else {
1276 		slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
1277 	}
1278 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
1279 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
1280 		CHKmalloc(slist);
1281 	}
1282 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
1283 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
1284 		CHKmalloc(slist);
1285 	}
1286 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
1287 	pWrkrData-&gt;curlHeader = slist;
1288 	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
1289 	curlPostSetup(pWrkrData);
1290 	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
1291 	curlCheckConnSetup(pWrkrData);
1292 finalize_it:
1293 	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
1294 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1295 		pWrkrData-&gt;curlPostHandle = NULL;
1296 	}
1297 	RETiRet;
1298 }
1299 static void ATTR_NONNULL()
1300 curlCleanup(wrkrInstanceData_t *const pWrkrData)
1301 {
1302 	if (pWrkrData-&gt;curlHeader != NULL) {
1303 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
1304 		pWrkrData-&gt;curlHeader = NULL;
1305 	}
1306 	if (pWrkrData-&gt;curlCheckConnHandle != NULL) {
1307 		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
1308 		pWrkrData-&gt;curlCheckConnHandle = NULL;
1309 	}
1310 	if (pWrkrData-&gt;curlPostHandle != NULL) {
1311 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1312 		pWrkrData-&gt;curlPostHandle = NULL;
1313 	}
1314 }
1315 static void ATTR_NONNULL()
1316 setInstParamDefaults(instanceData *const pData)
1317 {
1318 	pData-&gt;serverBaseUrls = NULL;
1319 	pData-&gt;defaultPort = 443;
1320 	pData-&gt;healthCheckTimeout = 3500;
1321 	pData-&gt;uid = NULL;
1322 	pData-&gt;httpcontenttype = NULL;
1323 	pData-&gt;headerContentTypeBuf = NULL;
1324 	pData-&gt;httpheaderkey = NULL;
1325 <a name="4"></a>	pData-&gt;httpheadervalue = NULL;
1326 	pData-&gt;httpHeaders = NULL;
1327 	pData-&gt;nHttpHeaders = 0;
1328 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pData-&gt;pwd = NULL;
1329 	pData-&gt;authBuf = NULL;
1330 	pData-&gt;restPath = NULL;
1331 	pData-&gt;checkPath = NULL;
1332 	pData-&gt;dynRestPath = 0;
1333 	pData-&gt;batchMode = 0;
1334 	pData-&gt;batchFormatName = (uchar *)"newline";
1335 	pData-&gt;batchFormat = FMT_NEWLINE;
1336 	pData-&gt;bFreeBatchFormatName = 0;
1337 	pData-&gt;useHttps = 1;
1338 	pData-&gt;maxBatchBytes = 10485760; //i.e. 10 MB Is the default max message size for AWS API Gateway
1339 	pData-&gt;maxBatchSize = 100; 	pData-&gt;compress = 0; 	pData-&gt;compressionLevel = -1; 	pData-&gt;allowUnsignedCerts = 0;
1340 	pData-&gt;skipVerifyHost = 0;
1341 	pData-&gt;tplName = NULL;</b></font>
1342 	pData-&gt;errorFile = NULL;
1343 	pData-&gt;caCertFile = NULL;
1344 	pData-&gt;myCertFile = NULL;
1345 	pData-&gt;myPrivKeyFile = NULL;
1346 	pData-&gt;reloadOnHup= 0;
1347 	pData-&gt;retryFailures = 0;
1348 	pData-&gt;ratelimitBurst = 20000;
1349 	pData-&gt;ratelimitInterval = 600;
1350 	pData-&gt;ratelimiter = NULL;
1351 	pData-&gt;retryRulesetName = NULL;
1352 	pData-&gt;retryRuleset = NULL;
1353 }
1354 static rsRetVal
1355 checkHeaderParam(char *const param)
1356 {
1357 	DEFiRet;
1358 	char *val = strstr(param, ":");
1359 	if(val == NULL) {
1360 		LogError(0, RS_RET_PARAM_ERROR, "missing ':' delimiter in "
1361 				"parameter '%s'", param);
1362 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
1363 	}
1364 finalize_it:
1365 	RETiRet;
1366 }
1367 BEGINnewActInst
1368 	struct cnfparamvals *pvals;
1369 	char* serverParam = NULL;
1370 	struct cnfarray* servers = NULL;
1371 	int i;
1372 	int iNumTpls;
1373 	FILE *fp;
1374 	char errStr[1024];
1375 	char *batchFormatName;
1376 	int compressionLevel = -1;
1377 CODESTARTnewActInst
1378 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
1379 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1380 	}
1381 	CHKiRet(createInstance(&amp;pData));
1382 	setInstParamDefaults(pData);
1383 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1384 		if(!pvals[i].bUsed)
1385 			continue;
1386 		if(!strcmp(actpblk.descr[i].name, "server")) {
1387 			servers = pvals[i].val.d.ar;
1388 		} else if(!strcmp(actpblk.descr[i].name, "errorfile")) {
1389 			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1390 		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {
1391 <a name="7"></a>			pData-&gt;defaultPort = (int) pvals[i].val.d.n;
1392 		} else if(!strcmp(actpblk.descr[i].name, "healthchecktimeout")) {
1393 			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;
1394 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
1395 			pData-&gt;uid = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1396 		} else if(!strcmp(actpblk.descr[i].name, "httpcontenttype")) {
1397 			pData-&gt;httpcontenttype = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1398 		} else if(!strcmp(actpblk.descr[i].name, "httpheaderkey")) {
1399 			pData-&gt;httpheaderkey = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1400 		} else if(!strcmp(actpblk.descr[i].name, "httpheadervalue")) {
1401 			pData-&gt;httpheadervalue = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1402 		} else if(!strcmp(actpblk.descr[i].name, "httpheaders")) {
1403 			pData-&gt;nHttpHeaders = pvals[i].val.d.ar-&gt;nmemb;
1404 			CHKmalloc(pData-&gt;httpHeaders = malloc(sizeof(uchar *) * pvals[i].val.d.ar-&gt;nmemb ));
1405 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
1406 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
1407 				CHKiRet(checkHeaderParam(cstr));
1408 				pData-&gt;httpHeaders[j] = (uchar *)cstr;
1409 <a name="1"></a>			}
1410 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
1411 			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1412 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "restpath")) {
1413 			pData-&gt;restPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1414 		} else if(!strcmp(actpblk.descr[i].name, "checkpath")) {
1415 			pData-&gt;checkPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1416 		} else if(!strcmp(actpblk.descr[i].name, "dynrestpath")) {
1417 			pData-&gt;dynRestPath = pvals[i].val.d.n;
1418 		} else if(!strcmp(actpblk.descr[i].name, "batch")) {
1419 			pData-&gt;batchMode = pvals[i].val.d.n;
1420 		} else if(!strcmp(actpblk.descr[i].name, "batch.format")) {
1421 			batchFormatName = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1422 <a name="5"></a>			if (strstr(VALID_BATCH_FORMATS, batchFormatName) != NULL) {
1423 				pData-&gt;batchFormatName = (uchar *)batchFormatName;
1424 				pData-&gt;bFreeBatchFormatName = 1;
1425 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>				if (!strcmp(batchFormatName, "newline")) {
1426 					pData-&gt;batchFormat = FMT_NEWLINE;
1427 				} else if (!strcmp(batchFormatName, "jsonarray")) {
1428 					pData-&gt;batchFormat = FMT_JSONARRAY;
1429 				} else if (!strcmp(batchFormatName, "kafkarest")) {
1430 					pData-&gt;batchFormat = FMT_KAFKAREST;
1431 				} else if (!strcmp(batchFormatName, "lokirest")) {
1432 					pData-&gt;batchFormat = FMT_LOKIREST;
1433 				}</b></font>
1434 <a name="3"></a>			} else {
1435 				LogError(0, NO_ERRCODE, "error: 'batch.format' %s unknown defaulting to 'newline'",
1436 					batchFormatName);
1437 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
1438 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxbytes")) {
1439 			pData-&gt;maxBatchBytes = (size_t) pvals[i].val.d.n;
1440 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxsize")) {
1441 			pData-&gt;maxBatchSize = (size_t) pvals[i].val.d.n;
1442 		} else if(!strcmp(actpblk.descr[i].name, "compress")) {
1443 			pData-&gt;compress = pvals[i].val.d.n;
1444 		} else if(!strcmp(actpblk.descr[i].name, "compress.level")) {
1445 			compressionLevel = pvals[i].val.d.n;</b></font>
1446 			if (compressionLevel == -1 || (compressionLevel &gt;= 0 &amp;&amp; compressionLevel &lt; 10)) {
1447 				pData-&gt;compressionLevel = compressionLevel;
1448 			} else {
1449 				LogError(0, NO_ERRCODE, "omhttp: invalid compress.level %d using default instead,"
1450 <a name="2"></a>					"valid levels are -1 and 0-9",
1451 					compressionLevel);
1452 			}
1453 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1454 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1455 		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1456 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1457 		} else if(!strcmp(actpblk.descr[i].name, "usehttps")) {
1458 			pData-&gt;useHttps = pvals[i].val.d.n;
1459 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
1460 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1461 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1462 			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1463 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1464 			if(fp == NULL) {
1465 				rs_strerror_r(errno, errStr, sizeof(errStr));
1466 				LogError(0, RS_RET_NO_FILE_ACCESS,
1467 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
1468 						pData-&gt;caCertFile, errStr);
1469 			} else {
1470 				fclose(fp);
1471 			}
1472 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1473 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1474 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1475 			if(fp == NULL) {
1476 				rs_strerror_r(errno, errStr, sizeof(errStr));
1477 				LogError(0, RS_RET_NO_FILE_ACCESS,
1478 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1479 						pData-&gt;myCertFile, errStr);
1480 			} else {
1481 				fclose(fp);
1482 			}
1483 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1484 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1485 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1486 			if(fp == NULL) {
1487 				rs_strerror_r(errno, errStr, sizeof(errStr));
1488 				LogError(0, RS_RET_NO_FILE_ACCESS,
1489 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1490 						pData-&gt;myPrivKeyFile, errStr);
1491 <a name="6"></a>			} else {
1492 				fclose(fp);
1493 			}
1494 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
1495 			pData-&gt;reloadOnHup= pvals[i].val.d.n;
1496 		} else if(!strcmp(actpblk.descr[i].name, "retry")) {
1497 			pData-&gt;retryFailures = pvals[i].val.d.n;
1498 		} else if(!strcmp(actpblk.descr[i].name, "retry.ruleset")) {
1499 			pData-&gt;retryRulesetName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
1500 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.burst")) {
1501 			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
1502 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.interval")) {
1503 			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
1504 		} else {
1505 			LogError(0, RS_RET_INTERNAL_ERROR, "omhttp: program error, "
1506 				"non-handled param '%s'", actpblk.descr[i].name);
1507 		}
1508 	}
1509 	if(pData-&gt;pwd != NULL &amp;&amp; pData-&gt;uid == NULL) {
1510 		LogError(0, RS_RET_UID_MISSING,
1511 			"omhttp: password is provided, but no uid "
1512 			"- action definition invalid");
1513 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1514 	}
1515 	if(pData-&gt;httpheaderkey != NULL &amp;&amp; pData-&gt;httpheadervalue == NULL) {
1516 		LogError(0, RS_RET_UID_MISSING,
1517 			"omhttp: http header key is provided, but no http header value "
1518 			"- action definition invalid");
1519 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1520 	}
1521 	if(pData-&gt;dynRestPath &amp;&amp; pData-&gt;restPath == NULL) {
1522 		LogError(0, RS_RET_CONFIG_ERROR,
1523 			"omhttp: requested dynamic rest path, but no name for rest "
1524 			"path template given - action definition invalid");
1525 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1526 	}
1527 	if (pData-&gt;uid != NULL)
1528 		CHKiRet(computeAuthHeader((char*) pData-&gt;uid, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));
1529 	if (pData-&gt;httpcontenttype != NULL)
1530 		CHKiRet(computeApiHeader((char*) "Content-Type",
1531 				(char*) pData-&gt;httpcontenttype, &amp;pData-&gt;headerContentTypeBuf));
1532 	if (pData-&gt;httpheaderkey != NULL)
1533 		CHKiRet(computeApiHeader((char*) pData-&gt;httpheaderkey,
1534 				(char*) pData-&gt;httpheadervalue, &amp;pData-&gt;headerBuf));
1535 	iNumTpls = 1;
1536 	if(pData-&gt;dynRestPath) ++iNumTpls;
1537 	DBGPRINTF("omhttp: requesting %d templates\n", iNumTpls);
1538 	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
1539 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
1540 					    " StdJSONFmt" : (char*)pData-&gt;tplName),
1541 		OMSR_NO_RQD_TPL_OPTS));
1542 	iNumTpls = 1;
1543 	if(pData-&gt;dynRestPath) {
1544 		CHKiRet(OMSRsetEntry(*ppOMSR, iNumTpls, ustrdup(pData-&gt;restPath),
1545 			OMSR_NO_RQD_TPL_OPTS));
1546 		++iNumTpls;
1547 	}
1548 	if (servers != NULL) {
1549 		pData-&gt;numServers = servers-&gt;nmemb;
1550 		pData-&gt;serverBaseUrls = malloc(servers-&gt;nmemb * sizeof(uchar*));
1551 		if (pData-&gt;serverBaseUrls == NULL) {
1552 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1553 					"for http server configuration.");
1554 			ABORT_FINALIZE(RS_RET_ERR);
1555 		}
1556 		for(i = 0 ; i &lt; servers-&gt;nmemb ; ++i) {
1557 			serverParam = es_str2cstr(servers-&gt;arr[i], NULL);
1558 			if (serverParam == NULL) {
1559 				LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1560 					"for http server configuration.");
1561 				ABORT_FINALIZE(RS_RET_ERR);
1562 			}
1563 			const size_t serverParamLastChar = strlen(serverParam)-1;
1564 			if (serverParam[serverParamLastChar] == '/') {
1565 				serverParam[serverParamLastChar] = '\0';
1566 			}
1567 			CHKiRet(computeBaseUrl(serverParam, pData-&gt;defaultPort, pData-&gt;useHttps,
1568 				pData-&gt;serverBaseUrls + i));
1569 			free(serverParam);
1570 			serverParam = NULL;
1571 		}
1572 	} else {
1573 		LogMsg(0, RS_RET_OK, LOG_WARNING,
1574 			"omhttp: No servers specified, using localhost");
1575 		pData-&gt;numServers = 1;
1576 		pData-&gt;serverBaseUrls = malloc(sizeof(uchar*));
1577 		if (pData-&gt;serverBaseUrls == NULL) {
1578 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1579 					"for http server configuration.");
1580 			ABORT_FINALIZE(RS_RET_ERR);
1581 		}
1582 		CHKiRet(computeBaseUrl("localhost", pData-&gt;defaultPort, pData-&gt;useHttps, pData-&gt;serverBaseUrls));
1583 	}
1584 	if (pData-&gt;retryFailures) {
1585 		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, "omhttp", NULL));
1586 		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
1587 		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
1588 	}
1589 	if(loadModConf-&gt;tail == NULL) {
1590 		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
1591 	} else {
1592 		loadModConf-&gt;tail-&gt;next = pData;
1593 		loadModConf-&gt;tail = pData;
1594 	}
1595 CODE_STD_FINALIZERnewActInst
1596 	cnfparamvalsDestruct(pvals, &amp;actpblk);
1597 	if (serverParam)
1598 		free(serverParam);
1599 ENDnewActInst
1600 BEGINbeginCnfLoad
1601 CODESTARTbeginCnfLoad
1602 	loadModConf = pModConf;
1603 	pModConf-&gt;pConf = pConf;
1604 	pModConf-&gt;root = pModConf-&gt;tail = NULL;
1605 ENDbeginCnfLoad
1606 BEGINendCnfLoad
1607 CODESTARTendCnfLoad
1608 	loadModConf = NULL; ENDendCnfLoad
1609 BEGINcheckCnf
1610 	instanceConf_t *inst;
1611 CODESTARTcheckCnf
1612 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1613 		ruleset_t *pRuleset;
1614 		rsRetVal localRet;
1615 		if (inst-&gt;retryRulesetName) {
1616 			localRet = ruleset.GetRuleset(pModConf-&gt;pConf, &amp;pRuleset, inst-&gt;retryRulesetName);
1617 			if(localRet == RS_RET_NOT_FOUND) {
1618 				LogError(0, localRet, "omhttp: retry.ruleset '%s' not found - "
1619 						"no retry ruleset will be used", inst-&gt;retryRulesetName);
1620 			} else {
1621 				inst-&gt;retryRuleset = pRuleset;
1622 			}
1623 		}
1624 	}
1625 ENDcheckCnf
1626 BEGINactivateCnf
1627 CODESTARTactivateCnf
1628 ENDactivateCnf
1629 BEGINfreeCnf
1630 CODESTARTfreeCnf
1631 ENDfreeCnf
1632 BEGINdoHUP
1633 CODESTARTdoHUP
1634 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
1635 	if (pData-&gt;fdErrFile != -1) {
1636 		close(pData-&gt;fdErrFile);
1637 		pData-&gt;fdErrFile = -1;
1638 	}
1639 	pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
1640 ENDdoHUP
1641 BEGINdoHUPWrkr
1642 CODESTARTdoHUPWrkr
1643 	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
1644 		LogMsg(0, NO_ERRCODE, LOG_INFO, "omhttp: received HUP reloading curl handles");
1645 		curlCleanup(pWrkrData);
1646 		CHKiRet(curlSetup(pWrkrData));
1647 	}
1648 finalize_it:
1649 ENDdoHUPWrkr
1650 BEGINmodExit
1651 CODESTARTmodExit
1652 	if(pInputName != NULL)
1653 		prop.Destruct(&amp;pInputName);
1654 	curl_global_cleanup();
1655 	objRelease(prop, CORE_COMPONENT);
1656 	objRelease(ruleset, CORE_COMPONENT);
1657 	objRelease(statsobj, CORE_COMPONENT);
1658 	statsobj.Destruct(&amp;httpStats);
1659 ENDmodExit
1660 NO_LEGACY_CONF_parseSelectorAct
1661 BEGINqueryEtryPt
1662 CODESTARTqueryEtryPt
1663 CODEqueryEtryPt_STD_OMOD_QUERIES
1664 CODEqueryEtryPt_STD_OMOD8_QUERIES
1665 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1666 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1667 CODEqueryEtryPt_doHUP
1668 CODEqueryEtryPt_doHUPWrkr CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_STD_CONF2_QUERIES
1669 ENDqueryEtryPt
1670 BEGINmodInit()
1671 CODESTARTmodInit
1672 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1673 	CHKiRet(objUse(prop, CORE_COMPONENT));
1674 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1675 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1676 	CHKiRet(statsobj.Construct(&amp;httpStats));
1677 	CHKiRet(statsobj.SetName(httpStats, (uchar *)"omhttp"));
1678 	CHKiRet(statsobj.SetOrigin(httpStats, (uchar*)"omhttp"));
1679 	STATSCOUNTER_INIT(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1680 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.submitted",
1681 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSubmitted));
1682 	STATSCOUNTER_INIT(ctrMessagesSuccess, mutCtrMessagesSuccess);
1683 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.success",
1684 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSuccess));
1685 	STATSCOUNTER_INIT(ctrMessagesFail, mutCtrMessagesFail);
1686 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.fail",
1687 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesFail));
1688 	STATSCOUNTER_INIT(ctrMessagesRetry, mutCtrMessagesRetry);
1689 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.retry",
1690 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesRetry));
1691 	STATSCOUNTER_INIT(ctrHttpRequestCount, mutCtrHttpRequestCount);
1692 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.count",
1693 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestCount));
1694 	STATSCOUNTER_INIT(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
1695 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.success",
1696 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestSuccess));
1697 	STATSCOUNTER_INIT(ctrHttpRequestFail, mutCtrHttpRequestFail);
1698 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.fail",
1699 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestFail));
1700 	STATSCOUNTER_INIT(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
1701 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.success",
1702 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusSuccess));
1703 	STATSCOUNTER_INIT(ctrHttpStatusFail, mutCtrHttpStatusFail);
1704 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.fail",
1705 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusFail));
1706 	CHKiRet(statsobj.ConstructFinalize(httpStats));
1707 	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
1708 		LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -http disabled");
1709 		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
1710 	}
1711 	CHKiRet(prop.Construct(&amp;pInputName));
1712 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("omhttp"), sizeof("omhttp") - 1));
1713 	CHKiRet(prop.ConstructFinalize(pInputName));
1714 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
