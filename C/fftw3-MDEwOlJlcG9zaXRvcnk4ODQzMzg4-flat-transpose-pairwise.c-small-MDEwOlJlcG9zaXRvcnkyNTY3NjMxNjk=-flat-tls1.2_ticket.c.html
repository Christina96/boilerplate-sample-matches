
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.47112462006079%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-pairwise.c</h3>
            <pre><code>1  #include "mpi-transpose.h"
2  #include <string.h>
3  typedef struct {
4       solver super;
5       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
6  } S;
7  typedef struct {
8       plan_mpi_transpose super;
9       plan *cld1, *cld2, *cld2rest, *cld3;
10       INT rest_Ioff, rest_Ooff;
11       int n_pes, my_pe, *sched;
12       INT *send_block_sizes, *send_block_offsets;
13       INT *recv_block_sizes, *recv_block_offsets;
14       MPI_Comm comm;
15       int preserve_input;
16  } P;
17  static void transpose_chunks(int *sched, int n_pes, int my_pe,
18  			     INT *sbs, INT *sbo, INT *rbs, INT *rbo,
19  			     MPI_Comm comm,
20  			     R *I, R *O)
21  {
22       if (sched) {
23  	  int i;
24  	  MPI_Status status;
25  	  if (I == O) {
26  	       R *buf = (R*) MALLOC(sizeof(R) * sbs[0], BUFFERS);
27  	       for (i = 0; i < n_pes; ++i) {
28  		    int pe = sched[i];
29  		    if (my_pe == pe) {
30  			 if (rbo[pe] != sbo[pe])
31  			      memmove(O + rbo[pe], O + sbo[pe],
32  				      sbs[pe] * sizeof(R));
33  		    }
34  		    else {
35  			 memcpy(buf, O + sbo[pe], sbs[pe] * sizeof(R));
36  			 MPI_Sendrecv(buf, (int) (sbs[pe]), FFTW_MPI_TYPE,
37  				      pe, (my_pe * n_pes + pe) & 0x7fff,
38  				      O + rbo[pe], (int) (rbs[pe]),
39  				      FFTW_MPI_TYPE,
40  				      pe, (pe * n_pes + my_pe) & 0x7fff,
41  				      comm, &status);
42  		    }
43  	       }
44  	       X(ifree)(buf);
45  	  }
46  	  else { &bsol;* I != O */
47  	       for (i = 0; i < n_pes; ++i) {
48  		    int pe = sched[i];
49  		    if (my_pe == pe)
50  			 memcpy(O + rbo[pe], I + sbo[pe], sbs[pe] * sizeof(R));
51  		    else
52  			 MPI_Sendrecv(I + sbo[pe], (int) (sbs[pe]),
53  				      FFTW_MPI_TYPE,
54  				      pe, (my_pe * n_pes + pe) & 0x7fff,
55  				      O + rbo[pe], (int) (rbs[pe]),
56  				      FFTW_MPI_TYPE,
57  				      pe, (pe * n_pes + my_pe) & 0x7fff,
58  				      comm, &status);
59  	       }
60  	  }
61       }
62  }
63  static void apply(const plan *ego_, R *I, R *O)
64  {
65       const P *ego = (const P *) ego_;
66       plan_rdft *cld1, *cld2, *cld2rest, *cld3;
67       cld1 = (plan_rdft *) ego->cld1;
68       if (cld1) {
69  	  cld1->apply(ego->cld1, I, O);
70  	  if (ego->preserve_input) I = O;
71  	  transpose_chunks(ego->sched, ego->n_pes, ego->my_pe,
72  			   ego->send_block_sizes, ego->send_block_offsets,
73  			   ego->recv_block_sizes, ego->recv_block_offsets,
74  			   ego->comm, O, I);
75       }
76       else if (ego->preserve_input) {
77  	  transpose_chunks(ego->sched, ego->n_pes, ego->my_pe,
78  			   ego->send_block_sizes, ego->send_block_offsets,
79  			   ego->recv_block_sizes, ego->recv_block_offsets,
80  			   ego->comm, I, O);
81  	  I = O;
82       }
83       else {
84  	  transpose_chunks(ego->sched, ego->n_pes, ego->my_pe,
85  			   ego->send_block_sizes, ego->send_block_offsets,
86  			   ego->recv_block_sizes, ego->recv_block_offsets,
87  			   ego->comm, I, I);
88       }
89       cld2 = (plan_rdft *) ego->cld2;
90       cld2->apply(ego->cld2, I, O);
91       cld2rest = (plan_rdft *) ego->cld2rest;
92       if (cld2rest) {
93  	  cld2rest->apply(ego->cld2rest,
94  			  I + ego->rest_Ioff, O + ego->rest_Ooff);
95  	  cld3 = (plan_rdft *) ego->cld3;
96  	  if (cld3)
97  	       cld3->apply(ego->cld3, O, O);
98       }
99  }
100  static int applicable(const S *ego, const problem *p_,
101  		      const planner *plnr)
102  {
103       const problem_mpi_transpose *p = (const problem_mpi_transpose *) p_;
104       return (1
105  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
106  					  && p->I != p->O))
107  	     && ONLY_TRANSPOSEDP(p->flags));
108  }
109  static void awake(plan *ego_, enum wakefulness wakefulness)
110  {
111       P *ego = (P *) ego_;
112       X(plan_awake)(ego->cld1, wakefulness);
113       X(plan_awake)(ego->cld2, wakefulness);
114       X(plan_awake)(ego->cld2rest, wakefulness);
115       X(plan_awake)(ego->cld3, wakefulness);
116  }
117  static void destroy(plan *ego_)
118  {
119       P *ego = (P *) ego_;
120       X(ifree0)(ego->sched);
121       X(ifree0)(ego->send_block_sizes);
122       MPI_Comm_free(&ego->comm);
123       X(plan_destroy_internal)(ego->cld3);
124       X(plan_destroy_internal)(ego->cld2rest);
125       X(plan_destroy_internal)(ego->cld2);
126       X(plan_destroy_internal)(ego->cld1);
127  }
128  static void print(const plan *ego_, printer *p)
129  {
130       const P *ego = (const P *) ego_;
131       p->print(p, "(mpi-transpose-pairwise%s%(%p%)%(%p%)%(%p%)%(%p%))", 
132  	      ego->preserve_input==2 ?"/p":"",
133  	      ego->cld1, ego->cld2, ego->cld2rest, ego->cld3);
134  }
135  static void fill1_comm_sched(int *sched, int which_pe, int npes)
136  {
137       int pe, i, n, s = 0;
138       A(which_pe >= 0 && which_pe < npes);
139       if (npes % 2 == 0) {
140  	  n = npes;
141  	  sched[s++] = which_pe;
142       }
143       else
144  	  n = npes + 1;
145       for (pe = 0; pe < n - 1; ++pe) {
146  	  if (npes % 2 == 0) {
147  	       if (pe == which_pe) sched[s++] = npes - 1;
148  	       else if (npes - 1 == which_pe) sched[s++] = pe;
149  	  }
150  	  else if (pe == which_pe) sched[s++] = pe;
151  	  if (pe != which_pe && which_pe < n - 1) {
152  	       i = (pe - which_pe + (n - 1)) % (n - 1);
153  	       if (i < n/2)
154  		    sched[s++] = (pe + i) % (n - 1);
155  	       i = (which_pe - pe + (n - 1)) % (n - 1);
156  	       if (i < n/2)
157  		    sched[s++] = (pe - i + (n - 1)) % (n - 1);
158  	  }
159       }
160       A(s == npes);
161  }
162  static void sort1_comm_sched(int *sched, int npes, int sortpe, int ascending)
163  {
164       int *sortsched, i;
165       sortsched = (int *) MALLOC(npes * sizeof(int) * 2, OTHER);
166       fill1_comm_sched(sortsched, sortpe, npes);
167       if (ascending)
168  	  for (i = 0; i < npes; ++i)
169  	       sortsched[npes + sortsched[i]] = sched[i];
170       else
171  	  for (i = 0; i < npes; ++i)
172  	       sortsched[2*npes - 1 - sortsched[i]] = sched[i];
173       for (i = 0; i < npes; ++i)
174  	  sched[i] = sortsched[npes + i];
175       X(ifree)(sortsched);
176  }
177  int XM(mkplans_posttranspose)(const problem_mpi_transpose *p, planner *plnr,
178  			      R *I, R *O, int my_pe,
179  			      plan **cld2, plan **cld2rest, plan **cld3,
180  			      INT *rest_Ioff, INT *rest_Ooff)
181  {
182       INT vn = p->vn;
183       INT b = p->block;
184       INT bt = XM(block)(p->ny, p->tblock, my_pe);
185       INT nxb = p->nx / b; &bsol;* number of equal-sized blocks */
186       INT nxr = p->nx - nxb * b; &bsol;* leftover rows after equal blocks */
187       *cld2 = *cld2rest = *cld3 = NULL;
188       *rest_Ioff = *rest_Ooff = 0;
189       if (!(p->flags & TRANSPOSED_OUT) && (nxr == 0 || I != O)) {
190  	  INT nx = p->nx * vn;
191  	  b *= vn;
192  	  *cld2 = X(mkplan_f_d)(plnr, 
193  				X(mkproblem_rdft_0_d)(X(mktensor_3d)
194  						      (nxb, bt * b, b,
195  						       bt, b, nx,
196  						       b, 1, 1),
197  						      I, O),
198  				0, 0, NO_SLOW);
199  	  if (!*cld2) goto nada;
200  	  if (nxr > 0) {
201  	       *rest_Ioff = nxb * bt * b;
202  	       *rest_Ooff = nxb * b;
203  	       b = nxr * vn;
204  	       *cld2rest = X(mkplan_f_d)(plnr,
205  					 X(mkproblem_rdft_0_d)(X(mktensor_2d)
206  							       (bt, b, nx,
207  								b, 1, 1),
208  							       I + *rest_Ioff,
209  							       O + *rest_Ooff),
210                                          0, 0, NO_SLOW);
211                 if (!*cld2rest) goto nada;
212  	  }
213       }
214       else {
215  	  *cld2 = X(mkplan_f_d)(plnr,
216  				X(mkproblem_rdft_0_d)(
217  				     X(mktensor_4d)
218  				     (nxb, bt * b * vn, bt * b * vn,
219  				      bt, b * vn, vn,
220  				      b, vn, bt * vn,
221  				      vn, 1, 1),
222  				     I, O),
223  				0, 0, NO_SLOW);
224  	  if (!*cld2) goto nada;
225  	  *rest_Ioff = *rest_Ooff = nxb * bt * b * vn;
226  	  *cld2rest = X(mkplan_f_d)(plnr,
227  				    X(mkproblem_rdft_0_d)(
228  					 X(mktensor_3d)
229  					 (bt, nxr * vn, vn,
230  					  nxr, vn, bt * vn,
231  					  vn, 1, 1),
232  					 I + *rest_Ioff, O + *rest_Ooff),
233  				    0, 0, NO_SLOW);
234  	  if (!*cld2rest) goto nada;
235  	  if (!(p->flags & TRANSPOSED_OUT)) {
236  	       *cld3 = X(mkplan_f_d)(plnr,
237  				     X(mkproblem_rdft_0_d)(
238  					  X(mktensor_3d)
239  					  (p->nx, bt * vn, vn,
240  					   bt, vn, p->nx * vn,
241  					   vn, 1, 1),
242  					  O, O),
243  				     0, 0, NO_SLOW);
244  	       if (!*cld3) goto nada;
245  	  }
246       }
247       return 1;
248  nada:
249       X(plan_destroy_internal)(*cld3);
250       X(plan_destroy_internal)(*cld2rest);
251       X(plan_destroy_internal)(*cld2);
252       *cld2 = *cld2rest = *cld3 = NULL;
253       return 0;
254  }
255  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
256  {
257       const S *ego = (const S *) ego_;
258       const problem_mpi_transpose *p;
259       P *pln;
260       plan *cld1 = 0, *cld2 = 0, *cld2rest = 0, *cld3 = 0;
261       INT b, bt, vn, rest_Ioff, rest_Ooff;
262       INT *sbs, *sbo, *rbs, *rbo;
263       int pe, my_pe, n_pes, sort_pe = -1, ascending = 1;
264       R *I, *O;
265       static const plan_adt padt = {
266            XM(transpose_solve), awake, print, destroy
267       };
268       UNUSED(ego);
269       if (!applicable(ego, p_, plnr))
270            return (plan *) 0;
271       p = (const problem_mpi_transpose *) p_;
272       vn = p->vn;
273       I = p->I; O = p->O;
274       MPI_Comm_rank(p->comm, &my_pe);
275       MPI_Comm_size(p->comm, &n_pes);
276       b = XM(block)(p->nx, p->block, my_pe);
277       if (!(p->flags & TRANSPOSED_IN)) { &bsol;* b x ny x vn -> ny x b x vn */
278  	  cld1 = X(mkplan_f_d)(plnr, 
279  			       X(mkproblem_rdft_0_d)(X(mktensor_3d)
280  						     (b, p->ny * vn, vn,
281  						      p->ny, vn, b * vn,
282  						      vn, 1, 1),
283  						     I, O),
284  			       0, 0, NO_SLOW);
285  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
286       }
287       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) I = O;
288       if (XM(any_true)(!XM(mkplans_posttranspose)(p, plnr, I, O, my_pe,
289  						 &cld2, &cld2rest, &cld3,
290  						 &rest_Ioff, &rest_Ooff),
291  		      p->comm)) goto nada;
292       pln = MKPLAN_MPI_TRANSPOSE(P, &padt, apply);
293       pln->cld1 = cld1;
294       pln->cld2 = cld2;
295       pln->cld2rest = cld2rest;
296       pln->rest_Ioff = rest_Ioff;
297       pln->rest_Ooff = rest_Ooff;
298       pln->cld3 = cld3;
299       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
300       MPI_Comm_dup(p->comm, &pln->comm);
301       n_pes = (int) X(imax)(XM(num_blocks)(p->nx, p->block),
302  			   XM(num_blocks)(p->ny, p->tblock));
303       sbs = (INT *) MALLOC(4 * n_pes * sizeof(INT), PLANS);
304       sbo = sbs + n_pes;
305       rbs = sbo + n_pes;
306       rbo = rbs + n_pes;
307       b = XM(block)(p->nx, p->block, my_pe);
308       bt = XM(block)(p->ny, p->tblock, my_pe);
309       for (pe = 0; pe < n_pes; ++pe) {
<span onclick='openModal()' class='match'>310  	  INT db, dbt; &bsol;* destination block sizes */
311  	  db = XM(block)(p->nx, p->block, pe);
312  	  dbt = XM(block)(p->ny, p->tblock, pe);
313  	  sbs[pe] = b * dbt * vn;
314  	  sbo[pe] = pe * (b * p->tblock) * vn;
315  	  rbs[pe] = db * bt * vn;
316  	  rbo[pe] = pe * (p->block * bt) * vn;
317  	  if (db * dbt > 0 && db * p->tblock != p->block * dbt) {
</span>318  	       A(sort_pe == -1); &bsol;* only one process should need sorting */
319  	       sort_pe = pe;
320  	       ascending = db * p->tblock > p->block * dbt;
321  	  }
322       }
323       pln->n_pes = n_pes;
324       pln->my_pe = my_pe;
325       pln->send_block_sizes = sbs;
326       pln->send_block_offsets = sbo;
327       pln->recv_block_sizes = rbs;
328       pln->recv_block_offsets = rbo;
329       if (my_pe >= n_pes) {
330  	  pln->sched = 0; &bsol;* this process is not doing anything */
331       }
332       else {
333  	  pln->sched = (int *) MALLOC(n_pes * sizeof(int), PLANS);
334  	  fill1_comm_sched(pln->sched, my_pe, n_pes);
335  	  if (sort_pe >= 0)
336  	       sort1_comm_sched(pln->sched, n_pes, sort_pe, ascending);
337       }
338       X(ops_zero)(&pln->super.super.ops);
339       if (cld1) X(ops_add2)(&cld1->ops, &pln->super.super.ops);
340       if (cld2) X(ops_add2)(&cld2->ops, &pln->super.super.ops);
341       if (cld2rest) X(ops_add2)(&cld2rest->ops, &pln->super.super.ops);
342       if (cld3) X(ops_add2)(&cld3->ops, &pln->super.super.ops);
343       return &(pln->super.super);
344   nada:
345       X(plan_destroy_internal)(cld3);
346       X(plan_destroy_internal)(cld2rest);
347       X(plan_destroy_internal)(cld2);
348       X(plan_destroy_internal)(cld1);
349       return (plan *) 0;
350  }
351  static solver *mksolver(int preserve_input)
352  {
353       static const solver_adt sadt = { PROBLEM_MPI_TRANSPOSE, mkplan, 0 };
354       S *slv = MKSOLVER(S, &sadt);
355       slv->preserve_input = preserve_input;
356       return &(slv->super);
357  }
358  void XM(transpose_pairwise_register)(planner *p)
359  {
360       int preserve_input;
361       for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
362  	  REGISTER_SOLVER(p, mksolver(preserve_input));
363  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</h3>
            <pre><code>1  #include "tls1.2_ticket.h"
2  #include "list.c"
3  typedef struct tls12_ticket_auth_global_data {
4      uint8_t local_client_id[32];
5      List client_data;
6      time_t startup_time;
7  }tls12_ticket_auth_global_data;
8  typedef struct tls12_ticket_auth_local_data {
9      int handshake_status;
10      char *send_buffer;
11      int send_buffer_size;
12      char *recv_buffer;
13      int recv_buffer_size;
14  }tls12_ticket_auth_local_data;
15  void tls12_ticket_auth_local_data_init(tls12_ticket_auth_local_data* local) {
16      local->handshake_status = 0;
17      local->send_buffer = malloc(0);
18      local->send_buffer_size = 0;
19      local->recv_buffer = malloc(0);
20      local->recv_buffer_size = 0;
21  }
22  void * tls12_ticket_auth_init_data() {
23      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)malloc(sizeof(tls12_ticket_auth_global_data));
24      rand_bytes(global->local_client_id, 32);
25      global->client_data = list_init(22);
26      global->startup_time = time(NULL);
27      return global;
28  }
29  obfs * tls12_ticket_auth_new_obfs() {
30      obfs * self = new_obfs();
31      self->l_data = malloc(sizeof(tls12_ticket_auth_local_data));
32      tls12_ticket_auth_local_data_init((tls12_ticket_auth_local_data*)self->l_data);
33      return self;
34  }
35  void tls12_ticket_auth_dispose(obfs *self) {
36      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
37      if (local->send_buffer != NULL) {
38          free(local->send_buffer);
39          local->send_buffer = NULL;
40      }
41      if (local->recv_buffer != NULL) {
42          free(local->recv_buffer);
43          local->recv_buffer = NULL;
44      }
45      free(local);
46      dispose_obfs(self);
47  }
48  int tls12_ticket_pack_auth_data(tls12_ticket_auth_global_data *global, server_info *server, char *outdata) {
49      int out_size = 32;
50      time_t t = time(NULL);
51      outdata[0] = t >> 24;
52      outdata[1] = t >> 16;
53      outdata[2] = t >> 8;
54      outdata[3] = t;
55      rand_bytes((uint8_t*)outdata + 4, 18);
56      uint8_t *key = (uint8_t*)malloc(server->key_len + 32);
57      char hash[ONETIMEAUTH_BYTES * 2];
58      memcpy(key, server->key, server->key_len);
59      memcpy(key + server->key_len, global->local_client_id, 32);
60      ss_sha1_hmac_with_key(hash, outdata, out_size - OBFS_HMAC_SHA1_LEN, key, server->key_len + 32);
61      free(key);
62      memcpy(outdata + out_size - OBFS_HMAC_SHA1_LEN, hash, OBFS_HMAC_SHA1_LEN);
63      return out_size;
64  }
65  void tls12_ticket_auth_pack_data(char *encryptdata, int datalength, int start, int len, char *out_buffer, int outlength) {
66      out_buffer[outlength] = 0x17;
67      out_buffer[outlength + 1] = 0x3;
68      out_buffer[outlength + 2] = 0x3;
69      out_buffer[outlength + 3] = len >> 8;
70      out_buffer[outlength + 4] = len;
71      memcpy(out_buffer + outlength + 5, encryptdata + start, len);
72  }
73  int tls12_ticket_auth_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
74      char *encryptdata = *pencryptdata;
75      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
76      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
77      char * out_buffer = NULL;
78      if (local->handshake_status == 8) {
79          if (datalength < 1024) {
80              if (*capacity < datalength + 5) {
81                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
82                  encryptdata = *pencryptdata;
83              }
84              memmove(encryptdata + 5, encryptdata, datalength);
85              encryptdata[0] = 0x17;
86              encryptdata[1] = 0x3;
87              encryptdata[2] = 0x3;
88              encryptdata[3] = datalength >> 8;
89              encryptdata[4] = datalength;
90              return datalength + 5;
91          } else {
92              out_buffer = (char*)malloc(datalength + 2048);
93              int start = 0;
94              int outlength = 0;
95              int len;
96              while (datalength - start > 2048) {
97                  len = xorshift128plus() % 4096 + 100;
98                  if (len > datalength - start)
99                      len = datalength - start;
100                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
101                  outlength += len + 5;
102                  start += len;
103              }
104              if (datalength - start > 0) {
105                  len = datalength - start;
106                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
107                  outlength += len + 5;
108              }
109              if (*capacity < outlength) {
110                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
111                  encryptdata = *pencryptdata;
112              }
113              memcpy(encryptdata, out_buffer, outlength);
114              free(out_buffer);
115              return outlength;
116          }
117      }
<span onclick='openModal()' class='match'>118      local->send_buffer = (char*)realloc(local->send_buffer, local->send_buffer_size + datalength + 5);
119      memcpy(local->send_buffer + local->send_buffer_size + 5, encryptdata, datalength);
120      local->send_buffer[local->send_buffer_size] = 0x17;
121      local->send_buffer[local->send_buffer_size + 1] = 0x3;
122      local->send_buffer[local->send_buffer_size + 2] = 0x3;
123      local->send_buffer[local->send_buffer_size + 3] = datalength >> 8;
124      local->send_buffer[local->send_buffer_size + 4] = datalength;
125      local->send_buffer_size += datalength + 5;
126      if (local->handshake_status == 0) {
</span>127  #define CSTR_DECL(name, len, str) const char* name = str; const int len = sizeof(str) - 1;
128          CSTR_DECL(tls_data0, tls_data0_len, "\x00\x1c\xc0\x2b\xc0\x2f\xcc\xa9\xcc\xa8\xcc\x14\xcc\x13\xc0\x0a\xc0\x14\xc0\x09\xc0\x13\x00\x9c\x00\x35\x00\x2f\x00\x0a\x01\x00"
129                  );
130          CSTR_DECL(tls_data1, tls_data1_len, "\xff\x01\x00\x01\x00"
131                  );
132          CSTR_DECL(tls_data2, tls_data2_len, "\x00\x17\x00\x00\x00\x23\x00\xd0");
133          CSTR_DECL(tls_data3, tls_data3_len, "\x00\x0d\x00\x16\x00\x14\x06\x01\x06\x03\x05\x01\x05\x03\x04\x01\x04\x03\x03\x01\x03\x03\x02\x01\x02\x03\x00\x05\x00\x05\x01\x00\x00\x00\x00\x00\x12\x00\x00\x75\x50\x00\x00\x00\x0b\x00\x02\x01\x00\x00\x0a\x00\x06\x00\x04\x00\x17\x00\x18"
134                  );
135          uint8_t tls_data[2048];
136          int tls_data_len = 0;
137          memcpy(tls_data, tls_data1, tls_data1_len);
138          tls_data_len += tls_data1_len;
139          char hosts[1024];
140          char * phost[128];
141          int host_num = 0;
142          int pos;
143          char sni[256] = {0};
144          if (self->server.param && strlen(self->server.param) == 0)
145              self->server.param = NULL;
146          strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
147          phost[host_num++] = hosts;
148          for (pos = 0; hosts[pos]; ++pos) {
149              if (hosts[pos] == ',') {
150                  phost[host_num++] = &hosts[pos + 1];
151              }
152          }
153          host_num = xorshift128plus() % host_num;
154          sprintf(sni, "%s", phost[host_num]);
155          int sni_len = strlen(sni);
156          if (sni_len > 0 && sni[sni_len - 1] >= '0' && sni[sni_len - 1] <= '9')
157              sni_len = 0;
158          tls_data[tls_data_len] = '\0';
159          tls_data[tls_data_len + 1] = '\0';
160          tls_data[tls_data_len + 2] = (sni_len + 5) >> 8;
161          tls_data[tls_data_len + 3] = (sni_len + 5);
162          tls_data[tls_data_len + 4] = (sni_len + 3) >> 8;
163          tls_data[tls_data_len + 5] = (sni_len + 3);
164          tls_data[tls_data_len + 6] = '\0';
165          tls_data[tls_data_len + 7] = sni_len >> 8;
166          tls_data[tls_data_len + 8] = sni_len;
167          memcpy(tls_data + tls_data_len + 9, sni, sni_len);
168          tls_data_len += 9 + sni_len;
169          memcpy(tls_data + tls_data_len, tls_data2, tls_data2_len);
170          tls_data_len += tls_data2_len;
171          rand_bytes(tls_data + tls_data_len, 208);
172          tls_data_len += 208;
173          memcpy(tls_data + tls_data_len, tls_data3, tls_data3_len);
174          tls_data_len += tls_data3_len;
175          datalength = 11 + 32 + 1 + 32 + tls_data0_len + 2 + tls_data_len;
176          out_buffer = (char*)malloc(datalength);
177          char *pdata = out_buffer + datalength - tls_data_len;
178          int len = tls_data_len;
179          memcpy(pdata, tls_data, tls_data_len);
180          pdata[-1] = tls_data_len;
181          pdata[-2] = tls_data_len >> 8;
182          pdata -= 2; len += 2;
183          memcpy(pdata - tls_data0_len, tls_data0, tls_data0_len);
184          pdata -= tls_data0_len; len += tls_data0_len;
185          memcpy(pdata - 32, global->local_client_id, 32);
186          pdata -= 32; len += 32;
187          pdata[-1] = 0x20;
188          pdata -= 1; len += 1;
189          tls12_ticket_pack_auth_data(global, &self->server, pdata - 32);
190          pdata -= 32; len += 32;
191          pdata[-1] = 0x3;
192          pdata[-2] = 0x3; 
193          pdata -= 2; len += 2;
194          pdata[-1] = len;
195          pdata[-2] = len >> 8;
196          pdata[-3] = 0;
197          pdata[-4] = 1;
198          pdata -= 4; len += 4;
199          pdata[-1] = len;
200          pdata[-2] = len >> 8;
201          pdata -= 2; len += 2;
202          pdata[-1] = 0x1;
203          pdata[-2] = 0x3; 
204          pdata -= 2; len += 2;
205          pdata[-1] = 0x16; 
206          pdata -= 1; len += 1;
207          local->handshake_status = 1;
208      } else if (datalength == 0) {
209          datalength = local->send_buffer_size + 43;
210          out_buffer = (char*)malloc(datalength);
211          char *pdata = out_buffer;
212          memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
213          pdata += 6;
214          memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
215          pdata += 5;
216          rand_bytes((uint8_t*)pdata, 22);
217          pdata += 22;
218          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
219          char hash[ONETIMEAUTH_BYTES * 2];
220          memcpy(key, self->server.key, self->server.key_len);
221          memcpy(key + self->server.key_len, global->local_client_id, 32);
222          ss_sha1_hmac_with_key(hash, out_buffer, pdata - out_buffer, key, self->server.key_len + 32);
223          free(key);
224          memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
225          pdata += OBFS_HMAC_SHA1_LEN;
226          memcpy(pdata, local->send_buffer, local->send_buffer_size);
227          free(local->send_buffer);
228          local->send_buffer = NULL;
229          local->handshake_status = 8;
230      } else {
231          return 0;
232      }
233      if (*capacity < datalength) {
234          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = datalength * 2);
235          encryptdata = *pencryptdata;
236      }
237      memmove(encryptdata, out_buffer, datalength);
238      free(out_buffer);
239      return datalength;
240  }
241  int tls12_ticket_auth_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
242      char *encryptdata = *pencryptdata;
243      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
244      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
245      char * out_buffer = NULL;
246      if (local->handshake_status == 8) {
247          if (datalength < 1024) {
248              if (*capacity < datalength + 5) {
249                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
250                  encryptdata = *pencryptdata;
251              }
252              memmove(encryptdata + 5, encryptdata, datalength);
253              encryptdata[0] = 0x17;
254              encryptdata[1] = 0x3;
255              encryptdata[2] = 0x3;
256              encryptdata[3] = datalength >> 8;
257              encryptdata[4] = datalength;
258              return datalength + 5;
259          } else {
260              out_buffer = (char*)malloc(datalength + 2048);
261              int start = 0;
262              int outlength = 0;
263              int len;
264              while (datalength - start > 2048) {
265                  len = xorshift128plus() % 4096 + 100;
266                  if (len > datalength - start)
267                      len = datalength - start;
268                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
269                  outlength += len + 5;
270                  start += len;
271              }
272              if (datalength - start > 0) {
273                  len = datalength - start;
274                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
275                  outlength += len + 5;
276              }
277              if (*capacity < outlength) {
278                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
279                  encryptdata = *pencryptdata;
280              }
281              memcpy(encryptdata, out_buffer, outlength);
282              free(out_buffer);
283              return outlength;
284          }
285      }
286      local->handshake_status = 3;
287      out_buffer = (char*)malloc(43 + 86);
288      int data_len = 0;
289      char *p_data = out_buffer + 86;
290      memcpy(p_data - 10, "\xc0\x2f\x00\x00\x05\xff\x01\x00\x01\x00", 10);
291      p_data -= 10;data_len += 10;
292      memcpy(p_data - 32, global->local_client_id, 32);
293      p_data -= 32;data_len += 32;
294      p_data[-1] = 0x20;
295      p_data -= 1;data_len += 1;
296      tls12_ticket_pack_auth_data(global, &self->server, p_data - 32);
297      p_data -= 32;data_len += 32;
298      p_data[-1] = 0x3;
299      p_data[-2] = 0x3; 
300      p_data -= 2;data_len += 2;
301      p_data[-1] = data_len;
302      p_data[-2] = data_len >> 8;
303      p_data[-3] = 0x00;
304      p_data[-4] = 0x02;
305      p_data -= 4; data_len += 4;
306      p_data[-1] = data_len;
307      p_data[-2] = data_len >> 8;
308      p_data[-3] = 0x03;
309      p_data[-4] = 0x03;
310      p_data[-5] = 0x16;
311      p_data -= 5; data_len += 5;
312      memcpy(out_buffer, p_data, data_len);
313      char *pdata = out_buffer + 86;
314      memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
315      pdata += 6;
316      memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
317      pdata += 5;
318      rand_bytes((uint8_t*)pdata, 22);
319      pdata += 22;
320      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
321      char hash[ONETIMEAUTH_BYTES * 2];
322      memcpy(key, self->server.key, self->server.key_len);
323      memcpy(key + self->server.key_len, global->local_client_id, 32);
324      ss_sha1_hmac_with_key(hash, out_buffer, 43 + 86, key, self->server.key_len + 32);
325      free(key);
326      memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
327      memmove(encryptdata, out_buffer, 43 + 86);
328      free(out_buffer);
329      return 43 + 86;
330  }
331  int tls12_ticket_auth_client_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
332      char *encryptdata = *pencryptdata;
333      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
334      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
335      *needsendback = 0;
336      if (local->handshake_status == 8) {
337          local->recv_buffer_size += datalength;
338          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
339          memcpy(local->recv_buffer + local->recv_buffer_size - datalength, encryptdata, datalength);
340          datalength = 0;
341          while (local->recv_buffer_size > 5) {
342              if (local->recv_buffer[0] != 0x17)
343                  return -1;
344              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
345              if (size + 5 > local->recv_buffer_size)
346                  break;
347              if (*capacity < datalength + size) {
348                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + size) * 2);
349                  encryptdata = *pencryptdata;
350              }
351              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
352              datalength += size;
353              local->recv_buffer_size -= 5 + size;
354              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
355          }
356          return datalength;
357      }
358      if (datalength < 11 + 32 + 1 + 32) {
359          return -1;
360      }
361      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
362      char hash[ONETIMEAUTH_BYTES * 2];
363      memcpy(key, self->server.key, self->server.key_len);
364      memcpy(key + self->server.key_len, global->local_client_id, 32);
365      ss_sha1_hmac_with_key(hash, encryptdata + 11, 22, key, self->server.key_len + 32);
366      free(key);
367      if (memcmp(encryptdata + 33, hash, OBFS_HMAC_SHA1_LEN)) {
368          return -1;
369      }
370      *needsendback = 1;
371      return 0;
372  }
373  int tls12_ticket_auth_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
374      char *encryptdata = *pencryptdata;
375      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
376      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
377      *needsendback = 0;
378      if (local->handshake_status == 8) {
379          if(datalength != 0)
380          {
381              local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size + datalength);
382              memmove(local->recv_buffer + local->recv_buffer_size, encryptdata, datalength);
383              local->recv_buffer_size += datalength;
384          }
385          datalength = 0;
386          while (local->recv_buffer_size > 5) {
387              if (local->recv_buffer[0] != 0x17 || local->recv_buffer[1] != 0x03 || local->recv_buffer[2] != 0x03)
388              {
389                  LOGE("server_decode data error, wrong tls version 3");
390                  return -1;
391              }
392              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
393              if (size + 5 > local->recv_buffer_size)
394                  break;
395              if (*capacity < local->recv_buffer_size + size) {
396                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (local->recv_buffer_size + size) * 2);
397                  encryptdata = *pencryptdata;
398              }
399              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
400              datalength += size;
401              local->recv_buffer_size -= 5 + size;
402              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
403          }
404          return datalength;
405      }
406      if (local->handshake_status == 3) {
407          char *verify = encryptdata;
408          if(datalength < 43)
409          {
410              LOGE("server_decode data error, too short:%d", (int)datalength);
411              return -1;
412          }
413          if(encryptdata[0] != 0x14 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x01 || encryptdata[5] != 0x01)
414          {
415              LOGE("server_decode data error, wrong tls version");
416              return -1;
417          }
418          encryptdata += 6;
419          if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x20)
420          {
421              LOGE("server_decode data error, wrong tls version 2");
422              return -1;
423          }
424          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
425          char hash[ONETIMEAUTH_BYTES * 2];
426          memcpy(key, self->server.key, self->server.key_len);
427          memcpy(key + self->server.key_len, global->local_client_id, 32);
428          ss_sha1_hmac_with_key(hash, verify, 33, key, self->server.key_len + 32);
429          free(key);
430          if (memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN) != 0) {
431              LOGE("server_decode data error, hash Mismatch %d",(int)memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN));
432              return -1;
433          }
434          local->recv_buffer_size = datalength - 43;
435          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
436          memmove(local->recv_buffer, encryptdata + 37, datalength - 43);
437          local->handshake_status = 8;
438          return tls12_ticket_auth_server_decode(self, pencryptdata, 0, capacity, needsendback);
439      }
440      local->handshake_status = 2;
441      if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x01)
442      {
443          return -1;
444      }
445      encryptdata += 3;
446      {
447          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
448          if(size != datalength - 5)
449          {
450              LOGE("tls_auth wrong tls head size");
451              return -1;
452          }
453      }
454      encryptdata += 2;
455      if(encryptdata[0] != 0x01 || encryptdata[1] != 0x00)
456      {
457          LOGE("tls_auth not client hello message");
458          return -1;
459      }
460      encryptdata += 2;
461      {
462          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
463          if(size != datalength - 9)
464          {
465              LOGE("tls_auth wrong message size");
466              return -1;
467          }
468      }
469      encryptdata += 2;
470      if(encryptdata[0] != 0x03 || encryptdata[1] != 0x03)
471      {
472          LOGE("tls_auth wrong tls version");
473          return -1;
474      }
475      encryptdata += 2;
476      char *verifyid = encryptdata;
477      encryptdata += 32;
478      int sessionid_len = encryptdata[0];
479      if(sessionid_len < 32)
480      {
481          LOGE("tls_auth wrong sessionid_len");
482          return -1;
483      }
484      char *sessionid = encryptdata + 1;
485      memcpy(global->local_client_id , sessionid, sessionid_len);
486      uint8_t *key = (uint8_t*)malloc(self->server.key_len + sessionid_len);
487      char hash[ONETIMEAUTH_BYTES * 2];
488      memcpy(key, self->server.key, self->server.key_len);
489      memcpy(key + self->server.key_len, global->local_client_id, sessionid_len);
490      ss_sha1_hmac_with_key(hash, verifyid, 22, key, self->server.key_len + sessionid_len);
491      free(key);
492      encryptdata += (sessionid_len + 1);
493      long utc_time = ((int)(unsigned char)verifyid[0] << 24) + ((int)(unsigned char)verifyid[1] << 16) + ((int)(unsigned char)verifyid[2] << 8) + (unsigned char)verifyid[3];
494      time_t t = time(NULL);
495      if (self->server.param && strlen(self->server.param) == 0)
496      {
497          self->server.param = NULL;
498      }
499      int max_time_dif = 0;
500      int time_dif = utc_time - t;
501      if(self->server.param)
502      {
503          max_time_dif = atoi(self->server.param);
504      }
505      if(max_time_dif > 0 && (time_dif < -max_time_dif || time_dif > max_time_dif || utc_time - global->startup_time < -max_time_dif / 2))
506      {
507          LOGE("tls_auth wrong time");
508          return -1;
509      }
510      if (memcmp(verifyid + 22, hash, OBFS_HMAC_SHA1_LEN)) {
511          LOGE("tls_auth wrong sha1");
512          return -1;
513      }
514      int search_result = global->client_data->have_same_cmp(global->client_data, verifyid);
515      if(search_result != 0)
516      {
517          LOGE("replay attack detect!");
518          return -1;
519      }
520      global->client_data->add_back(global->client_data, verifyid);
521      encryptdata += 48;
522      *needsendback = 1;
523      return 0;
524  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-pairwise.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</div>
                </div>
                <div class="column column_space"><pre><code>310  	  INT db, dbt; &bsol;* destination block sizes */
311  	  db = XM(block)(p->nx, p->block, pe);
312  	  dbt = XM(block)(p->ny, p->tblock, pe);
313  	  sbs[pe] = b * dbt * vn;
314  	  sbo[pe] = pe * (b * p->tblock) * vn;
315  	  rbs[pe] = db * bt * vn;
316  	  rbo[pe] = pe * (p->block * bt) * vn;
317  	  if (db * dbt > 0 && db * p->tblock != p->block * dbt) {
</pre></code></div>
                <div class="column column_space"><pre><code>118      local->send_buffer = (char*)realloc(local->send_buffer, local->send_buffer_size + datalength + 5);
119      memcpy(local->send_buffer + local->send_buffer_size + 5, encryptdata, datalength);
120      local->send_buffer[local->send_buffer_size] = 0x17;
121      local->send_buffer[local->send_buffer_size + 1] = 0x3;
122      local->send_buffer[local->send_buffer_size + 2] = 0x3;
123      local->send_buffer[local->send_buffer_size + 3] = datalength >> 8;
124      local->send_buffer[local->send_buffer_size + 4] = datalength;
125      local->send_buffer_size += datalength + 5;
126      if (local->handshake_status == 0) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    