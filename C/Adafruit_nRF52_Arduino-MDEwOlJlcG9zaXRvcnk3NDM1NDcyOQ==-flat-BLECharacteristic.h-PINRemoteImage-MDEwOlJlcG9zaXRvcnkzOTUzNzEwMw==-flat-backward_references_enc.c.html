
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8169014084507045%, Tokens: 8</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLECharacteristic.h</h3>
            <pre><code>1  #ifndef BLECHARACTERISTIC_H_
2  #define BLECHARACTERISTIC_H_
3  #include "bluefruit_common.h"
4  #include "BLEUuid.h"
5  class AdafruitBluefruit;
6  class BLEService;
7  enum CharsProperties
<span onclick='openModal()' class='match'>8  {
9    CHR_PROPS_BROADCAST       = bit(0),
10    CHR_PROPS_READ            = bit(1),
11    CHR_PROPS_WRITE_WO_RESP   = bit(2),
12    CHR_PROPS_WRITE           = bit(3),
13    CHR_PROPS_NOTIFY          = bit(4),
14    CHR_PROPS_INDICATE        = bit(5)
15  };
</span>16  enum BLECharsProperties
17  {
18    BLEBroadcast            = 0x01,
19    BLERead                 = 0x02,
20    BLEWriteWithoutResponse = 0x04,
21    BLEWrite                = 0x08,
22    BLENotify               = 0x10,
23    BLEIndicate             = 0x20
24  };
25  class BLECharacteristic
26  {
27    public:
28      typedef void (*read_authorize_cb_t)  (uint16_t conn_hdl, BLECharacteristic* chr, ble_gatts_evt_read_t * request);
29      typedef void (*write_authorize_cb_t) (uint16_t conn_hdl, BLECharacteristic* chr, ble_gatts_evt_write_t* request);
30      typedef void (*write_cb_t)           (uint16_t conn_hdl, BLECharacteristic* chr, uint8_t* data, uint16_t len);
31      typedef void (*write_cccd_cb_t)      (uint16_t conn_hdl, BLECharacteristic* chr, uint16_t value);
32      BLEUuid uuid;
33      BLECharacteristic(void);
34      BLECharacteristic(BLEUuid bleuuid);
35      BLECharacteristic(BLEUuid bleuuid, uint8_t properties);
36      BLECharacteristic(BLEUuid bleuuid, uint8_t properties, int max_len, bool fixed_len = false);
37      virtual ~BLECharacteristic();
38      BLEService& parentService(void);
39      void setTempMemory(void);
40      void setUuid(BLEUuid bleuuid);
41      void setProperties(uint8_t prop);
42      void setPermission(SecureMode_t read_perm, SecureMode_t write_perm);
43      void setMaxLen(uint16_t max_len);
44      void setFixedLen(uint16_t fixed_len);
45      void setBuffer(void* buf, uint16_t bufsize);
46      uint16_t getMaxLen(void);
47      bool isFixedLen(void);
48      void setUserDescriptor(const char* descriptor); 
49      void setReportRefDescriptor(uint8_t id, uint8_t type); 
50      void setPresentationFormatDescriptor(uint8_t type, int8_t exponent, uint16_t unit, uint8_t name_space = 1, uint16_t descritpor = 0);
51      void setWriteCallback        (write_cb_t            fp, bool useAdaCallback = true);
52      void setCccdWriteCallback    (write_cccd_cb_t       fp, bool useAdaCallback = true);
53      void setReadAuthorizeCallback(read_authorize_cb_t   fp, bool useAdaCallback = true);
54      void setWriteAuthorizeCallback(write_authorize_cb_t fp, bool useAdaCallback = true);
55      virtual err_t begin(void);
56      err_t addDescriptor(BLEUuid bleuuid, void const * content, uint16_t len, SecureMode_t read_perm = SECMODE_OPEN, SecureMode_t write_perm = SECMODE_NO_ACCESS);
57      ble_gatts_char_handles_t handles(void);
58      uint16_t write   (const void* data, uint16_t len);
59      uint16_t write   (const char* str);
60      uint16_t write8     (uint8_t  num);
61      uint16_t write16    (uint16_t num);
62      uint16_t write32    (uint32_t num);
63      uint16_t write32    (int      num);
64      uint16_t writeFloat (float    num);
65      uint16_t read  (void* buffer, uint16_t bufsize, uint16_t offset = 0);
66      uint8_t  read8     (void);
67      uint16_t read16    (void);
68      uint32_t read32    (void);
69      float    readFloat (void);
70      uint16_t getCccd(uint16_t conn_hdl);
71      bool notifyEnabled(void);
72      bool notifyEnabled(uint16_t conn_hdl);
73      bool notify   (const void* data, uint16_t len);
74      bool notify   (const char* str);
75      bool notify8  (uint8_t  num);
76      bool notify16 (uint16_t num);
77      bool notify32 (uint32_t num);
78      bool notify32 (int      num);
79      bool notify32 (float    fnum);
80      bool notify   (uint16_t conn_hdl, const void* data, uint16_t len);
81      bool notify   (uint16_t conn_hdl, const char* str);
82      bool notify8  (uint16_t conn_hdl, uint8_t  num);
83      bool notify16 (uint16_t conn_hdl, uint16_t num);
84      bool notify32 (uint16_t conn_hdl, uint32_t num);
85      bool notify32 (uint16_t conn_hdl, int      num);
86      bool notify32 (uint16_t conn_hdl, float    num);
87      bool indicateEnabled(void);
88      bool indicateEnabled(uint16_t conn_hdl);
89      bool indicate   (const void* data, uint16_t len);
90      bool indicate   (const char* str);
91      bool indicate8  (uint8_t  num);
92      bool indicate16 (uint16_t num);
93      bool indicate32 (uint32_t num);
94      bool indicate32 (int      num);
95      bool indicate32 (float    num);
96      bool indicate   (uint16_t conn_hdl, const void* data, uint16_t len);
97      bool indicate   (uint16_t conn_hdl, const char* str);
98      bool indicate8  (uint16_t conn_hdl, uint8_t  num);
99      bool indicate16 (uint16_t conn_hdl, uint16_t num);
100      bool indicate32 (uint16_t conn_hdl, uint32_t num);
101      bool indicate32 (uint16_t conn_hdl, int      num);
102      bool indicate32 (uint16_t conn_hdl, float    num);
103      virtual void _eventHandler(ble_evt_t* event);
104    protected:
105      bool _is_temp;
106      uint16_t _max_len;
107      BLEService* _service; 
108      uint8_t* _userbuf;
109      const char* _usr_descriptor;
110      struct ATTR_PACKED {
111        uint8_t id;
112        uint8_t type;
113      }_report_ref_desc;
114      ble_gatts_char_pf_t       _format_desc;
115      ble_gatt_char_props_t     _properties;
116      ble_gatts_attr_md_t       _attr_meta;
117      ble_gatts_char_handles_t  _handles;
118      struct {
119          uint8_t* buffer;
120          uint16_t bufsize;
121          uint16_t count;
122      }_long_wr;
123      struct ATTR_PACKED {
124        uint8_t write           : 1;
125        uint8_t cccd_write      : 1;
126        uint8_t read_authorize  : 1;
127        uint8_t write_authorize : 1;
128      } _use_ada_cb;
129      read_authorize_cb_t   _rd_authorize_cb;
130      write_authorize_cb_t  _wr_authorize_cb;
131      write_cb_t            _wr_cb;
132      write_cccd_cb_t       _cccd_wr_cb;
133      void _init(void);
134  };
135  #endif &bsol;* BLECHARACTERISTIC_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <math.h>
3  #include "src/enc/backward_references_enc.h"
4  #include "src/enc/histogram_enc.h"
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/lossless_common.h"
7  #include "src/dsp/dsp.h"
8  #include "src/utils/color_cache_utils.h"
9  #include "src/utils/utils.h"
10  #define MIN_BLOCK_SIZE 256  
11  #define MAX_ENTROPY    (1e30f)
12  #define WINDOW_SIZE ((1 << WINDOW_SIZE_BITS) - 120)
13  #define MIN_LENGTH 4
14  static const uint8_t plane_to_code_lut[128] = {
15   96,   73,  55,  39,  23,  13,   5,  1,  255, 255, 255, 255, 255, 255, 255, 255,
16   101,  78,  58,  42,  26,  16,   8,  2,    0,   3,  9,   17,  27,  43,  59,  79,
17   102,  86,  62,  46,  32,  20,  10,  6,    4,   7,  11,  21,  33,  47,  63,  87,
18   105,  90,  70,  52,  37,  28,  18,  14,  12,  15,  19,  29,  38,  53,  71,  91,
19   110,  99,  82,  66,  48,  35,  30,  24,  22,  25,  31,  36,  49,  67,  83, 100,
20   115, 108,  94,  76,  64,  50,  44,  40,  34,  41,  45,  51,  65,  77,  95, 109,
21   118, 113, 103,  92,  80,  68,  60,  56,  54,  57,  61,  69,  81,  93, 104, 114,
22   119, 116, 111, 106,  97,  88,  84,  74,  72,  75,  85,  89,  98, 107, 112, 117
23  };
24  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
25  int VP8LDistanceToPlaneCode(int xsize, int dist) {
26    const int yoffset = dist / xsize;
27    const int xoffset = dist - yoffset * xsize;
28    if (xoffset <= 8 && yoffset < 8) {
29      return plane_to_code_lut[yoffset * 16 + 8 - xoffset] + 1;
30    } else if (xoffset > xsize - 8 && yoffset < 7) {
31      return plane_to_code_lut[(yoffset + 1) * 16 + 8 + (xsize - xoffset)] + 1;
32    }
33    return dist + 120;
34  }
35  static WEBP_INLINE int FindMatchLength(const uint32_t* const array1,
36                                         const uint32_t* const array2,
37                                         int best_len_match, int max_limit) {
38    if (array1[best_len_match] != array2[best_len_match]) return 0;
39    return VP8LVectorMismatch(array1, array2, max_limit);
40  }
41  struct PixOrCopyBlock {
42    PixOrCopyBlock* next_;   
43    PixOrCopy* start_;       
44    int size_;               
45  };
46  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
47  void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs) {
48    assert(refs != NULL);
49    if (refs->tail_ != NULL) {
50      *refs->tail_ = refs->free_blocks_;  
51    }
52    refs->free_blocks_ = refs->refs_;
53    refs->tail_ = &refs->refs_;
54    refs->last_block_ = NULL;
55    refs->refs_ = NULL;
56  }
57  void VP8LBackwardRefsClear(VP8LBackwardRefs* const refs) {
58    assert(refs != NULL);
59    VP8LClearBackwardRefs(refs);
60    while (refs->free_blocks_ != NULL) {
61      PixOrCopyBlock* const next = refs->free_blocks_->next_;
62      WebPSafeFree(refs->free_blocks_);
63      refs->free_blocks_ = next;
64    }
65  }
66  void VP8LBackwardRefsInit(VP8LBackwardRefs* const refs, int block_size) {
67    assert(refs != NULL);
68    memset(refs, 0, sizeof(*refs));
69    refs->tail_ = &refs->refs_;
70    refs->block_size_ =
71        (block_size < MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : block_size;
72  }
73  VP8LRefsCursor VP8LRefsCursorInit(const VP8LBackwardRefs* const refs) {
74    VP8LRefsCursor c;
75    c.cur_block_ = refs->refs_;
76    if (refs->refs_ != NULL) {
77      c.cur_pos = c.cur_block_->start_;
78      c.last_pos_ = c.cur_pos + c.cur_block_->size_;
79    } else {
80      c.cur_pos = NULL;
81      c.last_pos_ = NULL;
82    }
83    return c;
84  }
85  void VP8LRefsCursorNextBlock(VP8LRefsCursor* const c) {
86    PixOrCopyBlock* const b = c->cur_block_->next_;
87    c->cur_pos = (b == NULL) ? NULL : b->start_;
88    c->last_pos_ = (b == NULL) ? NULL : b->start_ + b->size_;
89    c->cur_block_ = b;
90  }
91  static PixOrCopyBlock* BackwardRefsNewBlock(VP8LBackwardRefs* const refs) {
92    PixOrCopyBlock* b = refs->free_blocks_;
93    if (b == NULL) {   
94      const size_t total_size =
95          sizeof(*b) + refs->block_size_ * sizeof(*b->start_);
96      b = (PixOrCopyBlock*)WebPSafeMalloc(1ULL, total_size);
97      if (b == NULL) {
98        refs->error_ |= 1;
99        return NULL;
100      }
101      b->start_ = (PixOrCopy*)((uint8_t*)b + sizeof(*b));  
102    } else {  
103      refs->free_blocks_ = b->next_;
104    }
105    *refs->tail_ = b;
106    refs->tail_ = &b->next_;
107    refs->last_block_ = b;
108    b->next_ = NULL;
109    b->size_ = 0;
110    return b;
111  }
112  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
113                                        const PixOrCopy v);
114  void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
115                                 const PixOrCopy v) {
116    PixOrCopyBlock* b = refs->last_block_;
117    if (b == NULL || b->size_ == refs->block_size_) {
118      b = BackwardRefsNewBlock(refs);
119      if (b == NULL) return;   
120    }
121    b->start_[b->size_++] = v;
122  }
123  int VP8LHashChainInit(VP8LHashChain* const p, int size) {
124    assert(p->size_ == 0);
125    assert(p->offset_length_ == NULL);
126    assert(size > 0);
127    p->offset_length_ =
128        (uint32_t*)WebPSafeMalloc(size, sizeof(*p->offset_length_));
129    if (p->offset_length_ == NULL) return 0;
130    p->size_ = size;
131    return 1;
132  }
133  void VP8LHashChainClear(VP8LHashChain* const p) {
134    assert(p != NULL);
135    WebPSafeFree(p->offset_length_);
136    p->size_ = 0;
137    p->offset_length_ = NULL;
138  }
139  static const uint32_t kHashMultiplierHi = 0xc6a4a793u;
140  static const uint32_t kHashMultiplierLo = 0x5bd1e996u;
141  static WEBP_UBSAN_IGNORE_UNSIGNED_OVERFLOW WEBP_INLINE
142  uint32_t GetPixPairHash64(const uint32_t* const argb) {
143    uint32_t key;
144    key  = argb[1] * kHashMultiplierHi;
145    key += argb[0] * kHashMultiplierLo;
146    key = key >> (32 - HASH_BITS);
147    return key;
148  }
149  static int GetMaxItersForQuality(int quality) {
150    return 8 + (quality * quality) / 128;
151  }
152  static int GetWindowSizeForHashChain(int quality, int xsize) {
153    const int max_window_size = (quality > 75) ? WINDOW_SIZE
154                              : (quality > 50) ? (xsize << 8)
155                              : (quality > 25) ? (xsize << 6)
156                              : (xsize << 4);
157    assert(xsize > 0);
158    return (max_window_size > WINDOW_SIZE) ? WINDOW_SIZE : max_window_size;
159  }
160  static WEBP_INLINE int MaxFindCopyLength(int len) {
161    return (len < MAX_LENGTH) ? len : MAX_LENGTH;
162  }
163  int VP8LHashChainFill(VP8LHashChain* const p, int quality,
164                        const uint32_t* const argb, int xsize, int ysize,
165                        int low_effort) {
166    const int size = xsize * ysize;
167    const int iter_max = GetMaxItersForQuality(quality);
168    const uint32_t window_size = GetWindowSizeForHashChain(quality, xsize);
169    int pos;
170    int argb_comp;
171    uint32_t base_position;
172    int32_t* hash_to_first_index;
173    int32_t* chain = (int32_t*)p->offset_length_;
174    assert(size > 0);
175    assert(p->size_ != 0);
176    assert(p->offset_length_ != NULL);
177    if (size <= 2) {
178      p->offset_length_[0] = p->offset_length_[size - 1] = 0;
179      return 1;
180    }
181    hash_to_first_index =
182        (int32_t*)WebPSafeMalloc(HASH_SIZE, sizeof(*hash_to_first_index));
183    if (hash_to_first_index == NULL) return 0;
184    memset(hash_to_first_index, 0xff, HASH_SIZE * sizeof(*hash_to_first_index));
185    argb_comp = (argb[0] == argb[1]);
186    for (pos = 0; pos < size - 2;) {
187      uint32_t hash_code;
188      const int argb_comp_next = (argb[pos + 1] == argb[pos + 2]);
189      if (argb_comp && argb_comp_next) {
190        uint32_t tmp[2];
191        uint32_t len = 1;
192        tmp[0] = argb[pos];
193        while (pos + (int)len + 2 < size && argb[pos + len + 2] == argb[pos]) {
194          ++len;
195        }
196        if (len > MAX_LENGTH) {
197          memset(chain + pos, 0xff, (len - MAX_LENGTH) * sizeof(*chain));
198          pos += len - MAX_LENGTH;
199          len = MAX_LENGTH;
200        }
<span onclick='openModal()' class='match'>201        while (len) {
202          tmp[1] = len--;
203          hash_code = GetPixPairHash64(tmp);
204          chain[pos] = hash_to_first_index[hash_code];
205          hash_to_first_index[hash_code] = pos++;
206        }
</span>207        argb_comp = 0;
208      } else {
209        hash_code = GetPixPairHash64(argb + pos);
210        chain[pos] = hash_to_first_index[hash_code];
211        hash_to_first_index[hash_code] = pos++;
212        argb_comp = argb_comp_next;
213      }
214    }
215    chain[pos] = hash_to_first_index[GetPixPairHash64(argb + pos)];
216    WebPSafeFree(hash_to_first_index);
217    assert(size > 2);
218    p->offset_length_[0] = p->offset_length_[size - 1] = 0;
219    for (base_position = size - 2; base_position > 0;) {
220      const int max_len = MaxFindCopyLength(size - 1 - base_position);
221      const uint32_t* const argb_start = argb + base_position;
222      int iter = iter_max;
223      int best_length = 0;
224      uint32_t best_distance = 0;
225      uint32_t best_argb;
226      const int min_pos =
227          (base_position > window_size) ? base_position - window_size : 0;
228      const int length_max = (max_len < 256) ? max_len : 256;
229      uint32_t max_base_position;
230      pos = chain[base_position];
231      if (!low_effort) {
232        int curr_length;
233        if (base_position >= (uint32_t)xsize) {
234          curr_length = FindMatchLength(argb_start - xsize, argb_start,
235                                        best_length, max_len);
236          if (curr_length > best_length) {
237            best_length = curr_length;
238            best_distance = xsize;
239          }
240          --iter;
241        }
242        curr_length =
243            FindMatchLength(argb_start - 1, argb_start, best_length, max_len);
244        if (curr_length > best_length) {
245          best_length = curr_length;
246          best_distance = 1;
247        }
248        --iter;
249        if (best_length == MAX_LENGTH) pos = min_pos - 1;
250      }
251      best_argb = argb_start[best_length];
252      for (; pos >= min_pos && --iter; pos = chain[pos]) {
253        int curr_length;
254        assert(base_position > (uint32_t)pos);
255        if (argb[pos + best_length] != best_argb) continue;
256        curr_length = VP8LVectorMismatch(argb + pos, argb_start, max_len);
257        if (best_length < curr_length) {
258          best_length = curr_length;
259          best_distance = base_position - pos;
260          best_argb = argb_start[best_length];
261          if (best_length >= length_max) break;
262        }
263      }
264      max_base_position = base_position;
265      while (1) {
266        assert(best_length <= MAX_LENGTH);
267        assert(best_distance <= WINDOW_SIZE);
268        p->offset_length_[base_position] =
269            (best_distance << MAX_LENGTH_BITS) | (uint32_t)best_length;
270        --base_position;
271        if (best_distance == 0 || base_position == 0) break;
272        if (base_position < best_distance ||
273            argb[base_position - best_distance] != argb[base_position]) {
274          break;
275        }
276        if (best_length == MAX_LENGTH && best_distance != 1 &&
277            base_position + MAX_LENGTH < max_base_position) {
278          break;
279        }
280        if (best_length < MAX_LENGTH) {
281          ++best_length;
282          max_base_position = base_position;
283        }
284      }
285    }
286    return 1;
287  }
288  static WEBP_INLINE void AddSingleLiteral(uint32_t pixel, int use_color_cache,
289                                           VP8LColorCache* const hashers,
290                                           VP8LBackwardRefs* const refs) {
291    PixOrCopy v;
292    if (use_color_cache) {
293      const uint32_t key = VP8LColorCacheGetIndex(hashers, pixel);
294      if (VP8LColorCacheLookup(hashers, key) == pixel) {
295        v = PixOrCopyCreateCacheIdx(key);
296      } else {
297        v = PixOrCopyCreateLiteral(pixel);
298        VP8LColorCacheSet(hashers, key, pixel);
299      }
300    } else {
301      v = PixOrCopyCreateLiteral(pixel);
302    }
303    VP8LBackwardRefsCursorAdd(refs, v);
304  }
305  static int BackwardReferencesRle(int xsize, int ysize,
306                                   const uint32_t* const argb,
307                                   int cache_bits, VP8LBackwardRefs* const refs) {
308    const int pix_count = xsize * ysize;
309    int i, k;
310    const int use_color_cache = (cache_bits > 0);
311    VP8LColorCache hashers;
312    if (use_color_cache && !VP8LColorCacheInit(&hashers, cache_bits)) {
313      return 0;
314    }
315    VP8LClearBackwardRefs(refs);
316    AddSingleLiteral(argb[0], use_color_cache, &hashers, refs);
317    i = 1;
318    while (i < pix_count) {
319      const int max_len = MaxFindCopyLength(pix_count - i);
320      const int rle_len = FindMatchLength(argb + i, argb + i - 1, 0, max_len);
321      const int prev_row_len = (i < xsize) ? 0 :
322          FindMatchLength(argb + i, argb + i - xsize, 0, max_len);
323      if (rle_len >= prev_row_len && rle_len >= MIN_LENGTH) {
324        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(1, rle_len));
325        i += rle_len;
326      } else if (prev_row_len >= MIN_LENGTH) {
327        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(xsize, prev_row_len));
328        if (use_color_cache) {
329          for (k = 0; k < prev_row_len; ++k) {
330            VP8LColorCacheInsert(&hashers, argb[i + k]);
331          }
332        }
333        i += prev_row_len;
334      } else {
335        AddSingleLiteral(argb[i], use_color_cache, &hashers, refs);
336        i++;
337      }
338    }
339    if (use_color_cache) VP8LColorCacheClear(&hashers);
340    return !refs->error_;
341  }
342  static int BackwardReferencesLz77(int xsize, int ysize,
343                                    const uint32_t* const argb, int cache_bits,
344                                    const VP8LHashChain* const hash_chain,
345                                    VP8LBackwardRefs* const refs) {
346    int i;
347    int i_last_check = -1;
348    int ok = 0;
349    int cc_init = 0;
350    const int use_color_cache = (cache_bits > 0);
351    const int pix_count = xsize * ysize;
352    VP8LColorCache hashers;
353    if (use_color_cache) {
354      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
355      if (!cc_init) goto Error;
356    }
357    VP8LClearBackwardRefs(refs);
358    for (i = 0; i < pix_count;) {
359      int offset = 0;
360      int len = 0;
361      int j;
362      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
363      if (len >= MIN_LENGTH) {
364        const int len_ini = len;
365        int max_reach = 0;
366        const int j_max =
367            (i + len_ini >= pix_count) ? pix_count - 1 : i + len_ini;
368        i_last_check = (i > i_last_check) ? i : i_last_check;
369        for (j = i_last_check + 1; j <= j_max; ++j) {
370          const int len_j = VP8LHashChainFindLength(hash_chain, j);
371          const int reach =
372              j + (len_j >= MIN_LENGTH ? len_j : 1);  
373          if (reach > max_reach) {
374            len = j - i;
375            max_reach = reach;
376            if (max_reach >= pix_count) break;
377          }
378        }
379      } else {
380        len = 1;
381      }
382      assert(len > 0);
383      if (len == 1) {
384        AddSingleLiteral(argb[i], use_color_cache, &hashers, refs);
385      } else {
386        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
387        if (use_color_cache) {
388          for (j = i; j < i + len; ++j) VP8LColorCacheInsert(&hashers, argb[j]);
389        }
390      }
391      i += len;
392    }
393    ok = !refs->error_;
394   Error:
395    if (cc_init) VP8LColorCacheClear(&hashers);
396    return ok;
397  }
398  #define WINDOW_OFFSETS_SIZE_MAX 32
399  static int BackwardReferencesLz77Box(int xsize, int ysize,
400                                       const uint32_t* const argb, int cache_bits,
401                                       const VP8LHashChain* const hash_chain_best,
402                                       VP8LHashChain* hash_chain,
403                                       VP8LBackwardRefs* const refs) {
404    int i;
405    const int pix_count = xsize * ysize;
406    uint16_t* counts;
407    int window_offsets[WINDOW_OFFSETS_SIZE_MAX] = {0};
408    int window_offsets_new[WINDOW_OFFSETS_SIZE_MAX] = {0};
409    int window_offsets_size = 0;
410    int window_offsets_new_size = 0;
411    uint16_t* const counts_ini =
412        (uint16_t*)WebPSafeMalloc(xsize * ysize, sizeof(*counts_ini));
413    int best_offset_prev = -1, best_length_prev = -1;
414    if (counts_ini == NULL) return 0;
415    i = pix_count - 2;
416    counts = counts_ini + i;
417    counts[1] = 1;
418    for (; i >= 0; --i, --counts) {
419      if (argb[i] == argb[i + 1]) {
420        counts[0] = counts[1] + (counts[1] != MAX_LENGTH);
421      } else {
422        counts[0] = 1;
423      }
424    }
425    {
426      int x, y;
427      for (y = 0; y <= 6; ++y) {
428        for (x = -6; x <= 6; ++x) {
429          const int offset = y * xsize + x;
430          int plane_code;
431          if (offset <= 0) continue;
432          plane_code = VP8LDistanceToPlaneCode(xsize, offset) - 1;
433          if (plane_code >= WINDOW_OFFSETS_SIZE_MAX) continue;
434          window_offsets[plane_code] = offset;
435        }
436      }
437      for (i = 0; i < WINDOW_OFFSETS_SIZE_MAX; ++i) {
438        if (window_offsets[i] == 0) continue;
439        window_offsets[window_offsets_size++] = window_offsets[i];
440      }
441      for (i = 0; i < window_offsets_size; ++i) {
442        int j;
443        int is_reachable = 0;
444        for (j = 0; j < window_offsets_size && !is_reachable; ++j) {
445          is_reachable |= (window_offsets[i] == window_offsets[j] + 1);
446        }
447        if (!is_reachable) {
448          window_offsets_new[window_offsets_new_size] = window_offsets[i];
449          ++window_offsets_new_size;
450        }
451      }
452    }
453    hash_chain->offset_length_[0] = 0;
454    for (i = 1; i < pix_count; ++i) {
455      int ind;
456      int best_length = VP8LHashChainFindLength(hash_chain_best, i);
457      int best_offset;
458      int do_compute = 1;
459      if (best_length >= MAX_LENGTH) {
460        best_offset = VP8LHashChainFindOffset(hash_chain_best, i);
461        for (ind = 0; ind < window_offsets_size; ++ind) {
462          if (best_offset == window_offsets[ind]) {
463            do_compute = 0;
464            break;
465          }
466        }
467      }
468      if (do_compute) {
469        const int use_prev =
470            (best_length_prev > 1) && (best_length_prev < MAX_LENGTH);
471        const int num_ind =
472            use_prev ? window_offsets_new_size : window_offsets_size;
473        best_length = use_prev ? best_length_prev - 1 : 0;
474        best_offset = use_prev ? best_offset_prev : 0;
475        for (ind = 0; ind < num_ind; ++ind) {
476          int curr_length = 0;
477          int j = i;
478          int j_offset =
479              use_prev ? i - window_offsets_new[ind] : i - window_offsets[ind];
480          if (j_offset < 0 || argb[j_offset] != argb[i]) continue;
481          do {
482            const int counts_j_offset = counts_ini[j_offset];
483            const int counts_j = counts_ini[j];
484            if (counts_j_offset != counts_j) {
485              curr_length +=
486                  (counts_j_offset < counts_j) ? counts_j_offset : counts_j;
487              break;
488            }
489            curr_length += counts_j_offset;
490            j_offset += counts_j_offset;
491            j += counts_j_offset;
492          } while (curr_length <= MAX_LENGTH && j < pix_count &&
493                   argb[j_offset] == argb[j]);
494          if (best_length < curr_length) {
495            best_offset =
496                use_prev ? window_offsets_new[ind] : window_offsets[ind];
497            if (curr_length >= MAX_LENGTH) {
498              best_length = MAX_LENGTH;
499              break;
500            } else {
501              best_length = curr_length;
502            }
503          }
504        }
505      }
506      assert(i + best_length <= pix_count);
507      assert(best_length <= MAX_LENGTH);
508      if (best_length <= MIN_LENGTH) {
509        hash_chain->offset_length_[i] = 0;
510        best_offset_prev = 0;
511        best_length_prev = 0;
512      } else {
513        hash_chain->offset_length_[i] =
514            (best_offset << MAX_LENGTH_BITS) | (uint32_t)best_length;
515        best_offset_prev = best_offset;
516        best_length_prev = best_length;
517      }
518    }
519    hash_chain->offset_length_[0] = 0;
520    WebPSafeFree(counts_ini);
521    return BackwardReferencesLz77(xsize, ysize, argb, cache_bits, hash_chain,
522                                  refs);
523  }
524  static void BackwardReferences2DLocality(int xsize,
525                                           const VP8LBackwardRefs* const refs) {
526    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
527    while (VP8LRefsCursorOk(&c)) {
528      if (PixOrCopyIsCopy(c.cur_pos)) {
529        const int dist = c.cur_pos->argb_or_distance;
530        const int transformed_dist = VP8LDistanceToPlaneCode(xsize, dist);
531        c.cur_pos->argb_or_distance = transformed_dist;
532      }
533      VP8LRefsCursorNext(&c);
534    }
535  }
536  static int CalculateBestCacheSize(const uint32_t* argb, int quality,
537                                    const VP8LBackwardRefs* const refs,
538                                    int* const best_cache_bits) {
539    int i;
540    const int cache_bits_max = (quality <= 25) ? 0 : *best_cache_bits;
541    double entropy_min = MAX_ENTROPY;
542    int cc_init[MAX_COLOR_CACHE_BITS + 1] = { 0 };
543    VP8LColorCache hashers[MAX_COLOR_CACHE_BITS + 1];
544    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
545    VP8LHistogram* histos[MAX_COLOR_CACHE_BITS + 1] = { NULL };
546    int ok = 0;
547    assert(cache_bits_max >= 0 && cache_bits_max <= MAX_COLOR_CACHE_BITS);
548    if (cache_bits_max == 0) {
549      *best_cache_bits = 0;
550      return 1;
551    }
552    for (i = 0; i <= cache_bits_max; ++i) {
553      histos[i] = VP8LAllocateHistogram(i);
554      if (histos[i] == NULL) goto Error;
555      VP8LHistogramInit(histos[i], i, &bsol;*init_arrays=*/ 1);
556      if (i == 0) continue;
557      cc_init[i] = VP8LColorCacheInit(&hashers[i], i);
558      if (!cc_init[i]) goto Error;
559    }
560    while (VP8LRefsCursorOk(&c)) {
561      const PixOrCopy* const v = c.cur_pos;
562      if (PixOrCopyIsLiteral(v)) {
563        const uint32_t pix = *argb++;
564        const uint32_t a = (pix >> 24) & 0xff;
565        const uint32_t r = (pix >> 16) & 0xff;
566        const uint32_t g = (pix >>  8) & 0xff;
567        const uint32_t b = (pix >>  0) & 0xff;
568        int key = VP8LHashPix(pix, 32 - cache_bits_max);
569        ++histos[0]->blue_[b];
570        ++histos[0]->literal_[g];
571        ++histos[0]->red_[r];
572        ++histos[0]->alpha_[a];
573        for (i = cache_bits_max; i >= 1; --i, key >>= 1) {
574          if (VP8LColorCacheLookup(&hashers[i], key) == pix) {
575            ++histos[i]->literal_[NUM_LITERAL_CODES + NUM_LENGTH_CODES + key];
576          } else {
577            VP8LColorCacheSet(&hashers[i], key, pix);
578            ++histos[i]->blue_[b];
579            ++histos[i]->literal_[g];
580            ++histos[i]->red_[r];
581            ++histos[i]->alpha_[a];
582          }
583        }
584      } else {
585        int len = PixOrCopyLength(v);
586        uint32_t argb_prev = *argb ^ 0xffffffffu;
587        do {
588          if (*argb != argb_prev) {
589            int key = VP8LHashPix(*argb, 32 - cache_bits_max);
590            for (i = cache_bits_max; i >= 1; --i, key >>= 1) {
591              hashers[i].colors_[key] = *argb;
592            }
593            argb_prev = *argb;
594          }
595          argb++;
596        } while (--len != 0);
597      }
598      VP8LRefsCursorNext(&c);
599    }
600    for (i = 0; i <= cache_bits_max; ++i) {
601      const double entropy = VP8LHistogramEstimateBits(histos[i]);
602      if (i == 0 || entropy < entropy_min) {
603        entropy_min = entropy;
604        *best_cache_bits = i;
605      }
606    }
607    ok = 1;
608  Error:
609    for (i = 0; i <= cache_bits_max; ++i) {
610      if (cc_init[i]) VP8LColorCacheClear(&hashers[i]);
611      VP8LFreeHistogram(histos[i]);
612    }
613    return ok;
614  }
615  static int BackwardRefsWithLocalCache(const uint32_t* const argb,
616                                        int cache_bits,
617                                        VP8LBackwardRefs* const refs) {
618    int pixel_index = 0;
619    VP8LColorCache hashers;
620    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
621    if (!VP8LColorCacheInit(&hashers, cache_bits)) return 0;
622    while (VP8LRefsCursorOk(&c)) {
623      PixOrCopy* const v = c.cur_pos;
624      if (PixOrCopyIsLiteral(v)) {
625        const uint32_t argb_literal = v->argb_or_distance;
626        const int ix = VP8LColorCacheContains(&hashers, argb_literal);
627        if (ix >= 0) {
628          *v = PixOrCopyCreateCacheIdx(ix);
629        } else {
630          VP8LColorCacheInsert(&hashers, argb_literal);
631        }
632        ++pixel_index;
633      } else {
634        int k;
635        assert(PixOrCopyIsCopy(v));
636        for (k = 0; k < v->len; ++k) {
637          VP8LColorCacheInsert(&hashers, argb[pixel_index++]);
638        }
639      }
640      VP8LRefsCursorNext(&c);
641    }
642    VP8LColorCacheClear(&hashers);
643    return 1;
644  }
645  static VP8LBackwardRefs* GetBackwardReferencesLowEffort(
646      int width, int height, const uint32_t* const argb,
647      int* const cache_bits, const VP8LHashChain* const hash_chain,
648      VP8LBackwardRefs* const refs_lz77) {
649    *cache_bits = 0;
650    if (!BackwardReferencesLz77(width, height, argb, 0, hash_chain, refs_lz77)) {
651      return NULL;
652    }
653    BackwardReferences2DLocality(width, refs_lz77);
654    return refs_lz77;
655  }
656  extern int VP8LBackwardReferencesTraceBackwards(
657      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
658      const VP8LHashChain* const hash_chain,
659      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
660  static VP8LBackwardRefs* GetBackwardReferences(
661      int width, int height, const uint32_t* const argb, int quality,
662      int lz77_types_to_try, int* const cache_bits,
663      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* best,
664      VP8LBackwardRefs* worst) {
665    const int cache_bits_initial = *cache_bits;
666    double bit_cost_best = -1;
667    VP8LHistogram* histo = NULL;
668    int lz77_type, lz77_type_best = 0;
669    VP8LHashChain hash_chain_box;
670    memset(&hash_chain_box, 0, sizeof(hash_chain_box));
671    histo = VP8LAllocateHistogram(MAX_COLOR_CACHE_BITS);
672    if (histo == NULL) goto Error;
673    for (lz77_type = 1; lz77_types_to_try;
674         lz77_types_to_try &= ~lz77_type, lz77_type <<= 1) {
675      int res = 0;
676      double bit_cost;
677      int cache_bits_tmp = cache_bits_initial;
678      if ((lz77_types_to_try & lz77_type) == 0) continue;
679      switch (lz77_type) {
680        case kLZ77RLE:
681          res = BackwardReferencesRle(width, height, argb, 0, worst);
682          break;
683        case kLZ77Standard:
684          res = BackwardReferencesLz77(width, height, argb, 0, hash_chain, worst);
685          break;
686        case kLZ77Box:
687          if (!VP8LHashChainInit(&hash_chain_box, width * height)) goto Error;
688          res = BackwardReferencesLz77Box(width, height, argb, 0, hash_chain,
689                                          &hash_chain_box, worst);
690          break;
691        default:
692          assert(0);
693      }
694      if (!res) goto Error;
695      if (!CalculateBestCacheSize(argb, quality, worst, &cache_bits_tmp)) {
696        goto Error;
697      }
698      if (cache_bits_tmp > 0) {
699        if (!BackwardRefsWithLocalCache(argb, cache_bits_tmp, worst)) {
700          goto Error;
701        }
702      }
703      VP8LHistogramCreate(histo, worst, cache_bits_tmp);
704      bit_cost = VP8LHistogramEstimateBits(histo);
705      if (lz77_type_best == 0 || bit_cost < bit_cost_best) {
706        VP8LBackwardRefs* const tmp = worst;
707        worst = best;
708        best = tmp;
709        bit_cost_best = bit_cost;
710        *cache_bits = cache_bits_tmp;
711        lz77_type_best = lz77_type;
712      }
713    }
714    assert(lz77_type_best > 0);
715    if ((lz77_type_best == kLZ77Standard || lz77_type_best == kLZ77Box) &&
716        quality >= 25) {
717      const VP8LHashChain* const hash_chain_tmp =
718          (lz77_type_best == kLZ77Standard) ? hash_chain : &hash_chain_box;
719      if (VP8LBackwardReferencesTraceBackwards(width, height, argb, *cache_bits,
720                                               hash_chain_tmp, best, worst)) {
721        double bit_cost_trace;
722        VP8LHistogramCreate(histo, worst, *cache_bits);
723        bit_cost_trace = VP8LHistogramEstimateBits(histo);
724        if (bit_cost_trace < bit_cost_best) best = worst;
725      }
726    }
727    BackwardReferences2DLocality(width, best);
728  Error:
729    VP8LHashChainClear(&hash_chain_box);
730    VP8LFreeHistogram(histo);
731    return best;
732  }
733  VP8LBackwardRefs* VP8LGetBackwardReferences(
734      int width, int height, const uint32_t* const argb, int quality,
735      int low_effort, int lz77_types_to_try, int* const cache_bits,
736      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_tmp1,
737      VP8LBackwardRefs* const refs_tmp2) {
738    if (low_effort) {
739      return GetBackwardReferencesLowEffort(width, height, argb, cache_bits,
740                                            hash_chain, refs_tmp1);
741    } else {
742      return GetBackwardReferences(width, height, argb, quality,
743                                   lz77_types_to_try, cache_bits, hash_chain,
744                                   refs_tmp1, refs_tmp2);
745    }
746  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-BLECharacteristic.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</div>
                <div class="column column_space"><pre><code>8  {
9    CHR_PROPS_BROADCAST       = bit(0),
10    CHR_PROPS_READ            = bit(1),
11    CHR_PROPS_WRITE_WO_RESP   = bit(2),
12    CHR_PROPS_WRITE           = bit(3),
13    CHR_PROPS_NOTIFY          = bit(4),
14    CHR_PROPS_INDICATE        = bit(5)
15  };
</pre></code></div>
                <div class="column column_space"><pre><code>201        while (len) {
202          tmp[1] = len--;
203          hash_code = GetPixPairHash64(tmp);
204          chain[pos] = hash_to_first_index[hash_code];
205          hash_to_first_index[hash_code] = pos++;
206        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    