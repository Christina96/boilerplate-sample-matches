
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.33898305084746%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ae_30.h</h3>
            <pre><code>1  #ifndef __AE_H__
2  #define __AE_H__
3  #include <time.h>
4  #define AE_OK 0
5  #define AE_ERR -1
6  #define AE_NONE 0       &bsol;* No events registered. */
7  #define AE_READABLE 1   &bsol;* Fire when descriptor is readable. */
8  #define AE_WRITABLE 2   &bsol;* Fire when descriptor is writable. */
9  #define AE_BARRIER 4    &bsol;* With WRITABLE, never fire the event if the
10                             READABLE event already fired in the same event
11                             loop iteration. Useful when you want to persist
12                             things to disk before sending replies, and want
13                             to do that in a group fashion. */
14  #define AE_FILE_EVENTS 1
15  #define AE_TIME_EVENTS 2
16  #define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)
17  #define AE_DONT_WAIT 4
18  #define AE_CALL_AFTER_SLEEP 8
19  #define AE_NOMORE -1
20  #define AE_DELETED_EVENT_ID -1
21  #define AE_NOTUSED(V) ((void) V)
22  struct aeEventLoop;
23  typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);
24  typedef int aeTimeProc(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData);
25  typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);
26  typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);
27  typedef struct aeFileEvent {
28      int mask; &bsol;* one of AE_(READABLE|WRITABLE|BARRIER) */
29      aeFileProc *rfileProc;
30      aeFileProc *wfileProc;
31      void *clientData;
32  } aeFileEvent;
33  typedef struct aeTimeEvent {
34      PORT_LONGLONG id; &bsol;* time event identifier. */
35      PORT_LONG when_sec; &bsol;* seconds */
36      PORT_LONG when_ms; &bsol;* milliseconds */
37      aeTimeProc *timeProc;
38      aeEventFinalizerProc *finalizerProc;
39      void *clientData;
40      struct aeTimeEvent *prev;
41      struct aeTimeEvent *next;
42  } aeTimeEvent;
43  typedef struct aeFiredEvent {
44      int fd;
45      int mask;
46  } aeFiredEvent;
47  typedef struct aeEventLoop {
48      int maxfd;   &bsol;* highest file descriptor currently registered */
49      int setsize; &bsol;* max number of file descriptors tracked */
50      PORT_LONGLONG timeEventNextId;
51      time_t lastTime;     &bsol;* Used to detect system clock skew */
52      aeFileEvent *events; &bsol;* Registered events */
53      aeFiredEvent *fired; &bsol;* Fired events */
54      aeTimeEvent *timeEventHead;
55      int stop;
56      void *apidata; &bsol;* This is used for polling API specific data */
57      aeBeforeSleepProc *beforesleep;
58      aeBeforeSleepProc *aftersleep;
59  } aeEventLoop;
60  aeEventLoop *aeCreateEventLoop(int setsize);
61  void aeDeleteEventLoop(aeEventLoop *eventLoop);
62  void aeStop(aeEventLoop *eventLoop);
63  int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
64          aeFileProc *proc, void *clientData);
65  void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);
66  int aeGetFileEvents(aeEventLoop *eventLoop, int fd);
67  PORT_LONGLONG aeCreateTimeEvent(aeEventLoop *eventLoop, PORT_LONGLONG milliseconds,
68          aeTimeProc *proc, void *clientData,
69          aeEventFinalizerProc *finalizerProc);
70  int aeDeleteTimeEvent(aeEventLoop *eventLoop, PORT_LONGLONG id);
<span onclick='openModal()' class='match'>71  int aeProcessEvents(aeEventLoop *eventLoop, int flags);
72  int aeWait(int fd, int mask, PORT_LONGLONG milliseconds);
73  void aeMain(aeEventLoop *eventLoop);
74  char *aeGetApiName(void);
75  void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);
76  void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep);
77  int aeGetSetSize(aeEventLoop *eventLoop);
78  int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);
</span>79  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-directsq.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       const ct_desc *desc;
5       kdftwsq k;
6  } S;
7  typedef struct {
8       plan_dftw super;
9       kdftwsq k;
10       INT r;
11       stride rs, vs;
12       INT m, ms, v, mb, me;
13       twid *td;
14       const S *slv;
15  } P;
16  static void apply(const plan *ego_, R *rio, R *iio)
17  {
18       const P *ego = (const P *) ego_;
19       INT mb = ego->mb, ms = ego->ms;
20       ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, ego->rs, ego->vs,
21  	    mb, ego->me, ms);
22  }
23  static void awake(plan *ego_, enum wakefulness wakefulness)
24  {
25       P *ego = (P *) ego_;
26       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw,
27  		      ego->r * ego->m, ego->r, ego->m);
28  }
29  static void destroy(plan *ego_)
30  {
31       P *ego = (P *) ego_;
32       X(stride_destroy)(ego->rs);
33       X(stride_destroy)(ego->vs);
34  }
35  static void print(const plan *ego_, printer *p)
36  {
37       const P *ego = (const P *) ego_;
38       const S *slv = ego->slv;
39       const ct_desc *e = slv->desc;
40       p->print(p, "(dftw-directsq-%D/%D%v \"%s\")",
41  	      ego->r, X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
42  }
43  static int applicable(const S *ego,
44  		      INT r, INT irs, INT ors,
45  		      INT m, INT ms,
46  		      INT v, INT ivs, INT ovs,
47  		      INT mb, INT me,
48  		      R *rio, R *iio,
49  		      const planner *plnr)
50  {
51       const ct_desc *e = ego->desc;
52       UNUSED(v);
53       return (
54  	  1
55  	  && r == e->radix
56  	  && r == v
57  	  && irs == ovs
58  	  && ivs == ors
59  	  && e->genus->okp(e, rio, iio, irs, ivs, m, mb, me, ms, plnr)
60  	  );
61  }
62  static plan *mkcldw(const ct_solver *ego_,
<span onclick='openModal()' class='match'>63  		    INT r, INT irs, INT ors,
64  		    INT m, INT ms,
65  		    INT v, INT ivs, INT ovs,
</span>66  		    INT mstart, INT mcount,
67  		    R *rio, R *iio,
68  		    planner *plnr)
69  {
70       const S *ego = (const S *) ego_;
71       P *pln;
72       const ct_desc *e = ego->desc;
73       static const plan_adt padt = {
74  	  0, awake, print, destroy
75       };
76       A(mstart >= 0 && mstart + mcount <= m);
77       if (!applicable(ego,
78  		     r, irs, ors, m, ms, v, ivs, ovs, mstart, mstart + mcount,
79  		     rio, iio, plnr))
80            return (plan *)0;
81       pln = MKPLAN_DFTW(P, &padt, apply);
82       pln->k = ego->k;
83       pln->rs = X(mkstride)(r, irs);
84       pln->vs = X(mkstride)(v, ivs);
85       pln->td = 0;
86       pln->r = r;
87       pln->m = m;
88       pln->ms = ms;
89       pln->v = v;
90       pln->mb = mstart;
91       pln->me = mstart + mcount;
92       pln->slv = ego;
93       X(ops_zero)(&pln->super.super.ops);
94       X(ops_madd2)(mcount/e->genus->vl, &e->ops, &pln->super.super.ops);
95       return &(pln->super.super);
96  }
97  static void regone(planner *plnr, kdftwsq codelet,
98  		   const ct_desc *desc, int dec)
99  {
100       S *slv = (S *)X(mksolver_ct)(sizeof(S), desc->radix, dec, mkcldw, 0);
101       slv->k = codelet;
102       slv->desc = desc;
103       REGISTER_SOLVER(plnr, &(slv->super.super));
104       if (X(mksolver_ct_hook)) {
105  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), desc->radix, dec,
106  					 mkcldw, 0);
107  	  slv->k = codelet;
108  	  slv->desc = desc;
109  	  REGISTER_SOLVER(plnr, &(slv->super.super));
110       }
111  }
112  void X(regsolver_ct_directwsq)(planner *plnr, kdftwsq codelet,
113  			       const ct_desc *desc, int dec)
114  {
115       regone(plnr, codelet, desc, dec+TRANSPOSE);
116  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ae_30.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-directsq.c</div>
                </div>
                <div class="column column_space"><pre><code>71  int aeProcessEvents(aeEventLoop *eventLoop, int flags);
72  int aeWait(int fd, int mask, PORT_LONGLONG milliseconds);
73  void aeMain(aeEventLoop *eventLoop);
74  char *aeGetApiName(void);
75  void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);
76  void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep);
77  int aeGetSetSize(aeEventLoop *eventLoop);
78  int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);
</pre></code></div>
                <div class="column column_space"><pre><code>63  		    INT r, INT irs, INT ors,
64  		    INT m, INT ms,
65  		    INT v, INT ivs, INT ovs,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    