<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmutf8fix.c &amp; mmdarwin.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmutf8fix.c &amp; mmdarwin.c
      </h3>
<h1 align="center">
        7.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmutf8fix.c (16.5%)<th>mmdarwin.c (5.21327%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-158)<td><a href="#" name="0">(643-668)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-76)<td><a href="#" name="1">(102-111)</a><td align="center"><font color="#a50000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmutf8fix.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include "conf.h"
13 #include "syslogd-types.h"
14 #include "srUtils.h"
15 #include "template.h"
16 #include "module-template.h"
17 #include "errmsg.h"
18 MODULE_TYPE_OUTPUT
19 MODULE_TYPE_NOKEEP
20 MODULE_CNFNAME("mmutf8fix")
21 DEF_OMOD_STATIC_DATA
22 #define MODE_CC 0	 #define MODE_UTF8 1	 
23 typedef struct _instanceData {
24 	uchar replChar;
25 	uint8_t mode;		} instanceData;
26 typedef struct wrkrInstanceData {
27 	instanceData *pData;
28 } wrkrInstanceData_t;
29 <a name="1"></a>
30 struct modConfData_s {
31 	rsconf_t *pConf;	<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
32 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
33 static struct cnfparamdescr actpdescr[] = {
34 	{ "mode", eCmdHdlrGetWord, 0 },</b></font>
35 	{ "replacementchar", eCmdHdlrGetChar, 0 }
36 };
37 static struct cnfparamblk actpblk =
38 	{ CNFPARAMBLK_VERSION,
39 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
40 	  actpdescr
41 	};
42 BEGINbeginCnfLoad
43 CODESTARTbeginCnfLoad
44 	loadModConf = pModConf;
45 	pModConf-&gt;pConf = pConf;
46 ENDbeginCnfLoad
47 BEGINendCnfLoad
48 CODESTARTendCnfLoad
49 ENDendCnfLoad
50 BEGINcheckCnf
51 CODESTARTcheckCnf
52 ENDcheckCnf
53 BEGINactivateCnf
54 CODESTARTactivateCnf
55 	runModConf = pModConf;
56 ENDactivateCnf
57 BEGINfreeCnf
58 CODESTARTfreeCnf
59 ENDfreeCnf
60 BEGINcreateInstance
61 CODESTARTcreateInstance
62 ENDcreateInstance
63 BEGINcreateWrkrInstance
64 CODESTARTcreateWrkrInstance
65 ENDcreateWrkrInstance
66 BEGINisCompatibleWithFeature
67 CODESTARTisCompatibleWithFeature
68 ENDisCompatibleWithFeature
69 BEGINfreeInstance
70 CODESTARTfreeInstance
71 ENDfreeInstance
72 BEGINfreeWrkrInstance
73 CODESTARTfreeWrkrInstance
74 ENDfreeWrkrInstance
75 <a name="0"></a>static inline void
76 setInstParamDefaults(instanceData *pData)
77 {
78 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pData-&gt;mode = MODE_UTF8;
79 	pData-&gt;replChar = ' ';
80 }
81 BEGINnewActInst
82 	struct cnfparamvals *pvals;
83 	int i;
84 CODESTARTnewActInst
85 	DBGPRINTF("newActInst (mmutf8fix)\n");
86 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
87 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
88 	}
89 	CODE_STD_STRING_REQUESTnewActInst(1)
90 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
91 	CHKiRet(createInstance(&amp;pData));
92 	setInstParamDefaults(pData);
93 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
94 		if(!pvals[i].bUsed)
95 			continue;
96 		if(!strcmp(actpblk.descr[i].name, "mode")) {</b></font>
97 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"utf-8",
98 					 sizeof("utf-8")-1)) {
99 				pData-&gt;mode = MODE_UTF8;
100 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"controlcharacters",
101 					 sizeof("controlcharacters")-1)) {
102 				pData-&gt;mode = MODE_CC;
103 			} else {
104 				char *cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
105 				LogError(0, RS_RET_INVLD_MODE,
106 					"mmutf8fix: invalid mode '%s' - ignored",
107 					cstr);
108 				free(cstr);
109 			}
110 		} else if(!strcmp(actpblk.descr[i].name, "replacementchar")) {
111 			pData-&gt;replChar = es_getBufAddr(pvals[i].val.d.estr)[0];
112 		} else {
113 			dbgprintf("mmutf8fix: program error, non-handled "
114 			  "param '%s'\n", actpblk.descr[i].name);
115 		}
116 	}
117 CODE_STD_FINALIZERnewActInst
118 	cnfparamvalsDestruct(pvals, &amp;actpblk);
119 ENDnewActInst
120 BEGINdbgPrintInstInfo
121 CODESTARTdbgPrintInstInfo
122 ENDdbgPrintInstInfo
123 BEGINtryResume
124 CODESTARTtryResume
125 ENDtryResume
126 static void
127 doCC(instanceData *pData, uchar *msg, int lenMsg)
128 {
129 	int i;
130 	for(i = 0 ; i &lt; lenMsg ; ++i) {
131 		if(msg[i] &lt; 32 || msg[i] &gt; 126) {
132 			msg[i] = pData-&gt;replChar;
133 		}
134 	}
135 }
136 static void
137 fixInvldMBSeq(instanceData *pData, uchar *msg, int lenMsg, int strtIdx, int cnt)
138 {
139 	int i, endIdx;
140 	endIdx = strtIdx + cnt;
141 	if(endIdx &gt; lenMsg)
142 		endIdx = lenMsg;
143 	for(i = strtIdx ; i &lt; endIdx ; ++i)
144 		msg[i] = pData-&gt;replChar;
145 }
146 static void
147 doUTF8(instanceData *pData, uchar *msg, int lenMsg)
148 {
149 	uchar c;
150 	int8_t bytesLeft = 0;
151 	uint32_t codepoint;
152 	int strtIdx = 0;
153 	int i;
154 	for(i = 0 ; i &lt; lenMsg ; ++i) {
155 		c = msg[i];
156 		if(bytesLeft) {
157 			if((c &amp; 0xc0) != 0x80) {
158 				fixInvldMBSeq(pData, msg, lenMsg, strtIdx, i - strtIdx);
159 				bytesLeft = 0;
160 				goto startOfSequence;
161 			} else {
162 				codepoint = (codepoint &lt;&lt; 6) | (c &amp; 0x3f);
163 				--bytesLeft;
164 				if(bytesLeft == 0) {
165 					int seqLen = i - strtIdx + 1;
166 					if (
167 					    (((2 == seqLen) &amp;&amp; (codepoint &lt; 0x80)) ||
168 					     ((3 == seqLen) &amp;&amp; (codepoint &lt; 0x800)) ||
169 					     ((4 == seqLen) &amp;&amp; (codepoint &lt; 0x10000)))
170 					    ||
171 					    ((codepoint &gt;= 0xD800) &amp;&amp; (codepoint &lt;= 0xDFFF))
172 					    ||
173 					    (codepoint &gt; 0x10FFFF)
174 					) {
175 						fixInvldMBSeq(pData, msg, lenMsg, strtIdx, seqLen);
176 					}
177 				}
178 			}
179 		} else {
180 startOfSequence:
181 			if((c &amp; 0x80) == 0) {
182 				; 			} else if((c &amp; 0xe0) == 0xc0) {
183 				strtIdx = i;
184 				bytesLeft = 1;
185 				codepoint = c &amp; 0x1f;
186 			} else if((c &amp; 0xf0) == 0xe0) {
187 				strtIdx = i;
188 				bytesLeft = 2;
189 				codepoint = c &amp; 0x0f;
190 			} else if((c &amp; 0xf8) == 0xf0) {
191 				strtIdx = i;
192 				bytesLeft = 3;
193 				codepoint = c &amp; 0x07;
194 				msg[i] = pData-&gt;replChar;
195 			}
196 		}
197 	}
198 	if (bytesLeft) {
199 		fixInvldMBSeq(pData, msg, lenMsg, strtIdx, i - strtIdx);
200 	}
201 }
202 BEGINdoAction_NoStrings
203 	smsg_t **ppMsg = (smsg_t **) pMsgData;
204 	smsg_t *pMsg = ppMsg[0];
205 	uchar *msg;
206 	int lenMsg;
207 CODESTARTdoAction
208 	lenMsg = getMSGLen(pMsg);
209 	msg = getMSG(pMsg);
210 	if(pWrkrData-&gt;pData-&gt;mode == MODE_CC) {
211 		doCC(pWrkrData-&gt;pData, msg, lenMsg);
212 	} else {
213 		doUTF8(pWrkrData-&gt;pData, msg, lenMsg);
214 	}
215 ENDdoAction
216 NO_LEGACY_CONF_parseSelectorAct
217 BEGINmodExit
218 CODESTARTmodExit
219 ENDmodExit
220 BEGINqueryEtryPt
221 CODESTARTqueryEtryPt
222 CODEqueryEtryPt_STD_OMOD_QUERIES
223 CODEqueryEtryPt_STD_OMOD8_QUERIES
224 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
225 CODEqueryEtryPt_STD_CONF2_QUERIES
226 ENDqueryEtryPt
227 BEGINmodInit()
228 CODESTARTmodInit
229 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
230 	DBGPRINTF("mmutf8fix: module compiled with rsyslog version %s.\n", VERSION);
231 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdarwin.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;pthread.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 #include &lt;stdio.h&gt;
21 #include &lt;stdlib.h&gt;
22 #include &lt;string.h&gt;
23 #include &lt;sys/un.h&gt;
24 #include &lt;sys/socket.h&gt;
25 #include &lt;uuid/uuid.h&gt;
26 #include &lt;json.h&gt;
27 #include "protocol.h" 
28 #define JSON_DEFAULT_CONTAINER "!mmdarwin"
29 #define JSON_DARWIN_ID "darwin_id"
30 #define INVLD_SOCK -1
31 #define INITIAL_BUFFER_SIZE 32
32 #define BUFFER_DEFAULT_MAX_SIZE 65536
33 MODULE_TYPE_OUTPUT
34 MODULE_TYPE_NOKEEP
35 MODULE_CNFNAME("mmdarwin")
36 DEFobjCurrIf(glbl)
37 DEF_OMOD_STATIC_DATA
38 typedef struct dyn_buffer_t
39 {
40 	char *buffer;
41 	size_t bufferAllocSize;
42 	size_t bufferMsgSize;
43 	size_t bufferMaxSize;
44 } dyn_buffer;
45 typedef struct _instanceData
46 {
47 	enum darwin_filter_response_type response;		struct
48 	{
49 		int nmemb;
50 		char **name;
51 		char **varname;
52 	} fieldList; 	unsigned int socketMaxUse;
53 	sbool sendPartial;
54 } instanceData;
55 typedef struct wrkrInstanceData
56 {
57 	instanceData *pData;
58 	int sock;				 	struct sockaddr_un addr; 	uint8_t pktSentSocket;
59 	dyn_buffer darwinBody; 	dyn_buffer fieldBuffer;
60 } wrkrInstanceData_t;
61 struct modConfData_s
62 {
63 <a name="1"></a>		rsconf_t *pConf;
64 	const char *container;
65 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
66 static modConfData_t *loadModConf = NULL;
67 static modConfData_t *runModConf = NULL;
68 static struct cnfparamdescr modpdescr[] = {
69 	{"container", eCmdHdlrGetWord, 0},</b></font>
70 };
71 static struct cnfparamblk modpblk =
72 	{CNFPARAMBLK_VERSION,
73 	 sizeof(modpdescr) / sizeof(struct cnfparamdescr),
74 	 modpdescr};
75 static struct cnfparamdescr actpdescr[] = {
76 	{"key", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
77 	{"socketpath", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
78 	{"fields", eCmdHdlrArray, CNFPARAM_REQUIRED},
79 	{"filtercode", eCmdHdlrGetWord, 0},				{"response", eCmdHdlrGetWord, 0},				{"send_partial", eCmdHdlrBinary, 0},			{"socket_max_use", eCmdHdlrNonNegInt, 0}, };
80 static struct cnfparamblk actpblk = {
81 	CNFPARAMBLK_VERSION,
82 	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
83 	actpdescr};
84 #define min(a, b) \
85 	({ __typeof__ (a) _a = (a); \
86 	__typeof__ (b) _b = (b); \
87 	_a &lt; _b ? _a : _b; })
88 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData);
89 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData);
90 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData);
91 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len);
92 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len);
93 const char* get_uuid_object(smsg_t *const pMsg);
94 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString);
95 int expand_buffer(dyn_buffer *pBody, size_t new_size);
96 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size);
97 int start_new_line(dyn_buffer *pBody);
98 int end_body(dyn_buffer *pBody);
99 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData)
100 {
101 	DEFiRet;
102 	assert(pWrkrData-&gt;sock == INVLD_SOCK);
103 	if ((pWrkrData-&gt;sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
104 	{
105 		char errStr[1024];
106 		int eno = errno;
107 		DBGPRINTF("mmdarwin::openSocket:: error %d creating AF_UNIX/SOCK_STREAM: %s.\n",
108 				  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
109 		pWrkrData-&gt;sock = INVLD_SOCK;
110 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
111 	}
112 	memset(&amp;pWrkrData-&gt;addr, 0, sizeof(struct sockaddr_un));
113 	pWrkrData-&gt;addr.sun_family = AF_UNIX;
114 	strncpy(pWrkrData-&gt;addr.sun_path, (char *)pWrkrData-&gt;pData-&gt;pSockName, sizeof(pWrkrData-&gt;addr.sun_path) - 1);
115 	DBGPRINTF("mmdarwin::openSocket:: connecting to Darwin...\n");
116 	if (connect(pWrkrData-&gt;sock, (struct sockaddr *)&amp;pWrkrData-&gt;addr, sizeof(struct sockaddr_un)) == -1)
117 	{
118 		LogError(errno, RS_RET_NO_SOCKET, "mmdarwin::openSocket:: error connecting to Darwin "
119 										  "via socket '%s'",
120 				 pWrkrData-&gt;pData-&gt;pSockName);
121 		pWrkrData-&gt;sock = INVLD_SOCK;
122 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
123 	}
124 	DBGPRINTF("mmdarwin::openSocket:: connected !\n");
125 finalize_it:
126 	if (iRet != RS_RET_OK)
127 	{
128 		closeSocket(pWrkrData);
129 	}
130 	RETiRet;
131 }
132 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData)
133 {
134 	DEFiRet;
135 	if (pWrkrData-&gt;sock != INVLD_SOCK)
136 	{
137 		if (close(pWrkrData-&gt;sock) != 0)
138 		{
139 			char errStr[1024];
140 			int eno = errno;
141 			DBGPRINTF("mmdarwin::closeSocket:: error %d closing the socket: %s.\n",
142 					  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
143 		}
144 		pWrkrData-&gt;sock = INVLD_SOCK;
145 	}
146 	RETiRet;
147 }
148 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
149 {
150 	DEFiRet;
151 	DBGPRINTF("mmdarwin::doTryResume:: trying to resume\n");
152 	closeSocket(pWrkrData);
153 	iRet = openSocket(pWrkrData);
154 	if (iRet != RS_RET_OK)
155 	{
156 		iRet = RS_RET_SUSPENDED;
157 	}
158 	RETiRet;
159 }
160 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len)
161 {
162 	DEFiRet;
163 	DBGPRINTF("mmdarwin::sendMsg:: sending message to Darwin...\n");
164 	if (pWrkrData-&gt;sock == INVLD_SOCK)
165 	{
166 		CHKiRet(doTryResume(pWrkrData));
167 	}
168 	if (pWrkrData-&gt;sock != INVLD_SOCK)
169 	{
170 		if (send(pWrkrData-&gt;sock, msg, len, 0) == -1)
171 		{
172 			char errStr[1024];
173 			DBGPRINTF("mmdarwin::sendData:: error while sending data: error[%d] -&gt; %s\n",
174 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
175 			iRet = RS_RET_SUSPENDED;
176 		}
177 	}
178 finalize_it:
179 	RETiRet;
180 }
181 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len)
182 {
183 	DEFiRet;
184 	DBGPRINTF("mmdarwin::receiveMsg:: receiving message from Darwin...\n");
185 	if (pWrkrData-&gt;sock == INVLD_SOCK)
186 	{
187 		CHKiRet(doTryResume(pWrkrData));
188 	}
189 	if (pWrkrData-&gt;sock != INVLD_SOCK)
190 	{
191 		if (recv(pWrkrData-&gt;sock, response, len, MSG_WAITALL) &lt;= 0)
192 		{
193 			char errStr[1024];
194 			DBGPRINTF("mmdarwin::receiveMsg:: error while receiving data: error[%d] -&gt; %s\n",
195 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
196 			iRet = RS_RET_NONE;
197 		}
198 	}
199 finalize_it:
200 	RETiRet;
201 }
202 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString)
203 {
204 	DBGPRINTF("mmdarwin::get_field:: getting key '%s' in msg\n", pFieldName);
205 	struct json_object *pJson = NULL;
206 	char *pFieldString = NULL;
207 	int retVal = 0;
208 	msgPropDescr_t propDesc;
209 	msgPropDescrFill(&amp;propDesc, (uchar *)pFieldName, strlen(pFieldName));
210 	msgGetJSONPropJSONorString(pMsg, &amp;propDesc, &amp;pJson, (uchar **)&amp;pFieldString);
211 	if (pFieldString)
212 	{
213 		*ppRetString = pFieldString;
214 		DBGPRINTF("mmdarwin::get_field:: got string\n");
215 		retVal = 1;
216 	}
217 	else if (pJson)
218 	{
219 		pFieldString = (char *)json_object_get_string(pJson);
220 		if (pFieldString)
221 		{
222 			*ppRetString = strdup(pFieldString);
223 			retVal = 1;
224 			DBGPRINTF("mmdarwin::get_field:: got string from json\n");
225 			json_object_put(pJson);
226 		}
227 	}
228 	msgPropDescrDestruct(&amp;propDesc);
229 	return retVal;
230 }
231 int expand_buffer(dyn_buffer *pBody, size_t new_size)
232 {
233 	if (new_size &gt; pBody-&gt;bufferMaxSize)
234 		return -1;
235 	while (pBody-&gt;bufferAllocSize &lt; new_size)
236 		pBody-&gt;bufferAllocSize += INITIAL_BUFFER_SIZE;
237 	DBGPRINTF("mmdarwin::expand_buffer:: expanding buffer to %zu\n", pBody-&gt;bufferAllocSize);
238 	char *tmp = realloc(pBody-&gt;buffer, pBody-&gt;bufferAllocSize * sizeof(char));
239 	if (!tmp)
240 	{
241 		DBGPRINTF("mmdarwin::expand_buffer:: could not resize buffer\n");
242 		return -1;
243 	}
244 	pBody-&gt;buffer = tmp;
245 	return 0;
246 }
247 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size)
248 {
249 	int beginning = (pBody-&gt;bufferMsgSize == 0) ? 2 : 0;
250 	size_t requiredBodySize = pBody-&gt;bufferMsgSize + size + 4 + beginning;
251 	if (requiredBodySize &gt; pBody-&gt;bufferAllocSize)
252 	{
253 		if (expand_buffer(pBody, requiredBodySize) != 0)
254 		{
255 			return -1;
256 		}
257 	}
258 	if (!pBody-&gt;bufferMsgSize)
259 	{
260 		pBody-&gt;buffer[0] = '[';
261 		pBody-&gt;buffer[1] = '[';
262 		pBody-&gt;bufferMsgSize += 2;
263 	}
264 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
265 	memcpy((void *)&amp;pBody-&gt;buffer[pBody-&gt;bufferMsgSize], (const void *)field, size);
266 	pBody-&gt;bufferMsgSize += size;
267 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
268 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
269 	return 0;
270 }
271 int start_new_line(dyn_buffer *pBody)
272 {
273 	if (!pBody-&gt;bufferMsgSize)
274 	{
275 		return -1;
276 	}
277 	DBGPRINTF("mmdarwin::start_new_line:: starting new line entry in body\n");
278 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
279 	{
280 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
281 		{
282 			return -1;
283 		}
284 	}
285 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
286 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
287 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '[';
288 	return 0;
289 }
290 int end_body(dyn_buffer *pBody)
291 {
292 	if (!pBody-&gt;bufferMsgSize)
293 	{
294 		return -1;
295 	}
296 	DBGPRINTF("mmdarwin::end_body:: finishing body structure\n");
297 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
298 	{
299 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
300 		{
301 			return -1;
302 		}
303 	}
304 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
305 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ']';
306 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\0';
307 	return 0;
308 }
309 const char* get_uuid_object(smsg_t *const pMsg) {
310 	struct json_object *mmdarwin_object = NULL;
311 	const char *result = NULL, *key = NULL;
312 	msgPropDescr_t propDesc;
313 	msgPropDescrFill(&amp;propDesc, (uchar *)runModConf-&gt;container, strlen(runModConf-&gt;container));
314 	msgGetJSONPropJSON(pMsg, &amp;propDesc, &amp;mmdarwin_object);
315 	if(mmdarwin_object) {
316 		struct json_object_iterator it = json_object_iter_begin(mmdarwin_object);
317 		struct json_object_iterator itEnd = json_object_iter_end(mmdarwin_object);
318 		while(!json_object_iter_equal(&amp;it, &amp;itEnd)) {
319 			key = json_object_iter_peek_name(&amp;it);
320 			if(!strcmp(key, JSON_DARWIN_ID)) {
321 				result = strdup(json_object_get_string(json_object_iter_peek_value(&amp;it)));
322 				break;
323 			}
324 			json_object_iter_next(&amp;it);
325 		}
326 		json_object_put(mmdarwin_object);
327 	}
328 	msgPropDescrDestruct(&amp;propDesc);
329 	return result;
330 }
331 BEGINbeginCnfLoad
332 CODESTARTbeginCnfLoad
333 	loadModConf = pModConf;
334 pModConf-&gt;pConf = pConf;
335 ENDbeginCnfLoad
336 BEGINendCnfLoad
337 CODESTARTendCnfLoad
338 ENDendCnfLoad
339 BEGINcheckCnf
340 CODESTARTcheckCnf
341 ENDcheckCnf
342 BEGINactivateCnf
343 CODESTARTactivateCnf
344 	runModConf = pModConf;
345 ENDactivateCnf
346 BEGINfreeCnf
347 CODESTARTfreeCnf
348 	free((void *)pModConf-&gt;container);
349 ENDfreeCnf
350 BEGINdbgPrintInstInfo
351 CODESTARTdbgPrintInstInfo
352 	DBGPRINTF("%s\n", pData-&gt;pSockName);
353 ENDdbgPrintInstInfo
354 BEGINcreateInstance
355 CODESTARTcreateInstance
356 ENDcreateInstance
357 BEGINcreateWrkrInstance
358 CODESTARTcreateWrkrInstance
359 	pWrkrData-&gt;pktSentSocket = 0;
360 	pWrkrData-&gt;darwinBody.bufferAllocSize = 0;
361 	pWrkrData-&gt;darwinBody.bufferMaxSize = BUFFER_DEFAULT_MAX_SIZE;
362 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
363 	pWrkrData-&gt;sock = INVLD_SOCK;
364 ENDcreateWrkrInstance
365 BEGINisCompatibleWithFeature
366 CODESTARTisCompatibleWithFeature
367 ENDisCompatibleWithFeature
368 BEGINfreeInstance
369 CODESTARTfreeInstance
370 	if (pData-&gt;fieldList.name != NULL)
371 	{
372 		for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; ++i)
373 		{
374 			free(pData-&gt;fieldList.name[i]);
375 			free(pData-&gt;fieldList.varname[i]);
376 		}
377 		free(pData-&gt;fieldList.name);
378 		free(pData-&gt;fieldList.varname);
379 	}
380 	free(pData-&gt;pUUIDKey);
381 	free(pData-&gt;pCertitudeKey);
382 	free(pData-&gt;pSockName);
383 ENDfreeInstance
384 BEGINfreeWrkrInstance
385 CODESTARTfreeWrkrInstance
386 	closeSocket(pWrkrData);
387 	free(pWrkrData-&gt;darwinBody.buffer);
388 ENDfreeWrkrInstance
389 BEGINsetModCnf
390 struct cnfparamvals *pvals = NULL;
391 int i;
392 CODESTARTsetModCnf
393 	loadModConf-&gt;container = NULL;
394 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
395 	if (pvals == NULL)
396 	{
397 		LogError(0, RS_RET_MISSING_CNFPARAMS,
398 				"mmdarwin: error processing module config parameters missing [module(...)]");
399 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
400 	}
401 	if (Debug)
402 	{
403 		DBGPRINTF("mmdarwin::setModCnf:: module (global) param blk for mmdarwin:\n");
404 		cnfparamsPrint(&amp;modpblk, pvals);
405 	}
406 	for (i = 0; i &lt; modpblk.nParams; ++i)
407 	{
408 		if (!pvals[i].bUsed)
409 			continue;
410 		if (!strcmp(modpblk.descr[i].name, "container"))
411 		{
412 			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);
413 			if(loadModConf-&gt;container[0] != '!' &amp;&amp; loadModConf-&gt;container[0] != '.') {
414 				LogError(0, RS_RET_INVALID_PARAMS, "mmdarwin: container should either"
415 					" begin with '!' or '.'\n");
416 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
417 			}
418 		}
419 		else
420 		{
421 			DBGPRINTF("mmdarwin::setModCnf:: program error, non-handled "
422 					"param '%s'\n",
423 					modpblk.descr[i].name);
424 		}
425 	}
426 	if (loadModConf-&gt;container == NULL)
427 	{
428 		CHKmalloc(loadModConf-&gt;container = strdup(JSON_DEFAULT_CONTAINER));
429 	}
430 finalize_it :
431 	if (pvals != NULL)
432 		cnfparamvalsDestruct(pvals, &amp;modpblk);
433 ENDsetModCnf
434 static inline void setInstParamDefaults(instanceData *pData)
435 {
436 	DBGPRINTF("mmdarwin::setInstParamDefaults::\n");
437 	pData-&gt;pUUIDKey = NULL;
438 	pData-&gt;pCertitudeKey = NULL;
439 	pData-&gt;pSockName = NULL;
440 <a name="0"></a>	pData-&gt;fieldList.nmemb = 0;
441 	pData-&gt;filterCode = DARWIN_FILTER_CODE_NO;
442 	pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
443 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pData-&gt;socketMaxUse = 0;
444 	pData-&gt;sendPartial = 0;
445 }
446 BEGINnewActInst
447 	struct cnfparamvals *pvals;
448 	int i;
449 CODESTARTnewActInst
450 	DBGPRINTF("mmdarwin::newActInst::\n");
451 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL)
452 	{
453 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
454 	}
455 	CODE_STD_STRING_REQUESTnewActInst(1)
456 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
457 	CHKiRet(createInstance(&amp;pData));
458 	setInstParamDefaults(pData);
459 	for (i = 0; i &lt; actpblk.nParams; ++i)
460 	{
461 		if (!pvals[i].bUsed)
462 			continue;
463 		if (!strcmp(actpblk.descr[i].name, "key"))
464 		{</b></font>
465 			char *key = es_str2cstr(pvals[i].val.d.estr, NULL);
466 			char vnamebuf[1024];
467 			snprintf(vnamebuf, sizeof(vnamebuf), "%s!%s", loadModConf-&gt;container, key);
468 			CHKmalloc(pData-&gt;pCertitudeKey = strdup(vnamebuf));
469 			free(key);
470 			DBGPRINTF("mmdarwin::newActInst:: certitudeKey is %s\n", pData-&gt;pCertitudeKey);
471 		}
472 		else if (!strcmp(actpblk.descr[i].name, "socketpath"))
473 		{
474 			pData-&gt;pSockName = (uchar *)es_str2cstr(pvals[i].val.d.estr, NULL);
475 			DBGPRINTF("mmdarwin::newActInst:: sockName is %s\n", pData-&gt;pSockName);
476 		}
477 		else if (!strcmp(actpblk.descr[i].name, "socket_max_use"))
478 		{
479 			pData-&gt;socketMaxUse = (uint32_t)pvals[i].val.d.n;
480 			DBGPRINTF("mmdarwin::newActInst:: socketMaxUse is %d\n", pData-&gt;socketMaxUse);
481 		}
482 		else if (!strcmp(actpblk.descr[i].name, "send_partial"))
483 		{
484 			pData-&gt;sendPartial = (sbool)pvals[i].val.d.n;
485 			if (pData-&gt;sendPartial)
486 			{
487 				DBGPRINTF("mmdarwin::newActInst:: sending bodies even if fields are missing\n");
488 			}
489 			else
490 			{
491 				DBGPRINTF("mmdarwin::newActInst:: only sending complete bodies\n");
492 			}
493 		}
494 		else if (!strcmp(actpblk.descr[i].name, "response"))
495 		{
496 			char *response = es_str2cstr(pvals[i].val.d.estr, NULL);
497 			if (!strcmp(response, "no"))
498 			{
499 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
500 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
501 			}
502 			else if (!strcmp(response, "back"))
503 			{
504 				pData-&gt;response = DARWIN_RESPONSE_SEND_BACK;
505 				DBGPRINTF("mmdarwin::newActInst:: response type is 'back'\n");
506 			}
507 			else if (!strcmp(response, "darwin"))
508 			{
509 				pData-&gt;response = DARWIN_RESPONSE_SEND_DARWIN;
510 				DBGPRINTF("mmdarwin::newActInst:: response type is 'darwin'\n");
511 			}
512 			else if (!strcmp(response, "both"))
513 			{
514 				pData-&gt;response = DARWIN_RESPONSE_SEND_BOTH;
515 				DBGPRINTF("mmdarwin::newActInst:: response type is 'both'\n");
516 			}
517 			else
518 			{
519 				DBGPRINTF(
520 					"mmdarwin::newActInst:: invalid 'response' value: %s. 'No response' set.\n",
521 					response);
522 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
523 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
524 			}
525 			free(response);
526 		}
527 		else if (!strcmp(actpblk.descr[i].name, "filtercode"))
528 		{
529 			char *filterCode = es_str2cstr(pvals[i].val.d.estr, NULL);
530 			pData-&gt;filterCode = strtoull(filterCode, NULL, 16);
531 			free(filterCode);
532 		}
533 		else if (!strcmp(actpblk.descr[i].name, "fields"))
534 		{
535 			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
536 			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
537 			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
538 			for (int j = 0; j &lt; pData-&gt;fieldList.nmemb; ++j)
539 			{
540 				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
541 				char *varname = NULL;
542 				char *name;
543 				if (*param == ':')
544 				{
545 					char *b = strchr(param + 1, ':');
546 					if (b == NULL)
547 					{
548 						parser_errmsg(
549 							"mmdarwin::newActInst:: missing closing colon: '%s'", param);
550 						ABORT_FINALIZE(RS_RET_ERR);
551 					}
552 					*b = '\0'; 					varname = param + 1;
553 					name = b + 1;
554 				}
555 				else
556 				{
557 					name = param;
558 				}
559 				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
560 				char vnamebuf[1024];
561 				snprintf(vnamebuf, sizeof(vnamebuf),
562 						"%s!%s", loadModConf-&gt;container,
563 						(varname == NULL) ? name : varname);
564 				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
565 				free(param);
566 				DBGPRINTF("mmdarwin::newActInst:: will look for field %s\n", pData-&gt;fieldList.name[j]);
567 			}
568 		}
569 		else
570 		{
571 			DBGPRINTF(
572 			"mmdarwin::newActInst:: program error, non-handled param '%s'\n", actpblk.descr[i].name);
573 		}
574 	}
575 	size_t sizeKey = strlen(loadModConf-&gt;container) + strlen(JSON_DARWIN_ID) + 2;
576 	pData-&gt;pUUIDKey = malloc(sizeKey);
577 	snprintf(pData-&gt;pUUIDKey, sizeKey, "%s!%s", loadModConf-&gt;container, JSON_DARWIN_ID);
578 	DBGPRINTF("mmdarwin:: uuid key is %s\n", pData-&gt;pUUIDKey);
579 CODE_STD_FINALIZERnewActInst
580 	cnfparamvalsDestruct(pvals, &amp;actpblk);
581 ENDnewActInst
582 BEGINtryResume
583 CODESTARTtryResume
584 	iRet = doTryResume(pWrkrData);
585 ENDtryResume
586 BEGINdoAction_NoStrings
587 	smsg_t **ppMsg = (smsg_t **)pMsgData; 	smsg_t *pMsg = ppMsg[0]; 	instanceData *pData = pWrkrData-&gt;pData; 	char *pFieldValue = NULL; 	int fieldsNum = 0; 
588 CODESTARTdoAction
589 	DBGPRINTF("mmdarwin::doAction:: beggining action\n");
590 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
591 	fieldsNum = 0;
592 	for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; i++)
593 	{
594 		DBGPRINTF("mmdarwin::doAction:: processing field '%s'\n", pData-&gt;fieldList.name[i]);
595 		pFieldValue = NULL;
596 		if (pData-&gt;fieldList.name[i][0] != '!' &amp;&amp; pData-&gt;fieldList.name[i][0] != '.')
597 		{
598 			pFieldValue = strdup(pData-&gt;fieldList.name[i]);
599 		}
600 		else
601 		{
602 			if (!get_field(pMsg, pData-&gt;fieldList.name[i], &amp;pFieldValue))
603 			{
604 				DBGPRINTF("mmdarwin::doAction:: \
605 could not extract field '%s' from message\n", pData-&gt;fieldList.name[i]);
606 				continue;
607 			}
608 		}
609 		DBGPRINTF(
610 			"mmdarwin::doAction:: got value of field '%s': '%s'\n", pData-&gt;fieldList.name[i], pFieldValue);
611 		if (add_field_to_body(&amp;(pWrkrData-&gt;darwinBody), pFieldValue, strlen(pFieldValue)) != 0)
612 		{
613 			DBGPRINTF("mmdarwin::doAction:: could not add field to body, aborting\n");
614 			free(pFieldValue);
615 			ABORT_FINALIZE(RS_RET_ERR);
616 		}
617 		fieldsNum++;
618 		free(pFieldValue);
619 	}
620 	if (fieldsNum)
621 	{
622 		if (!pData-&gt;sendPartial &amp;&amp; fieldsNum != pData-&gt;fieldList.nmemb)
623 		{
624 			DBGPRINTF("mmdarwin::doAction:: not all fields could be retrieved, not sending partial message."
625 	" (if you wish to send partial messages anyway, set 'send_partial' to 'on' in instance parameters)\n");
626 			FINALIZE;
627 		}
628 		if (end_body(&amp;(pWrkrData-&gt;darwinBody)) != 0)
629 			ABORT_FINALIZE(RS_RET_ERR);
630 	}
631 	else
632 	{
633 		DBGPRINTF("mmdarwin::doAction:: no fields retrieved, finalizing\n");
634 		FINALIZE;
635 	}
636 	DBGPRINTF("mmdarwin::doAction:: body to send: '%s'\n", pWrkrData-&gt;darwinBody.buffer);
637 	if (pData-&gt;socketMaxUse)
638 	{
639 		if (!pWrkrData-&gt;pktSentSocket)
640 		{
641 			DBGPRINTF("mmdarwin::doAction:: opening a new connection\n");
642 			CHKiRet(doTryResume(pWrkrData));
643 		}
644 		pWrkrData-&gt;pktSentSocket = (pWrkrData-&gt;pktSentSocket + 1) % pData-&gt;socketMaxUse;
645 	}
646 	darwin_filter_packet_t header = {
647 		.type = DARWIN_PACKET_OTHER,
648 		.response = pData-&gt;response,
649 		.filter_code = pData-&gt;filterCode,
650 		.body_size = pWrkrData-&gt;darwinBody.bufferMsgSize};
651 	const char *uuid = get_uuid_object(pMsg);
652 	if(uuid) {
653 		DBGPRINTF("mmdarwin: using existing UUID = %s\n", uuid);
654 		if(uuid_parse(uuid, header.evt_id))
655 			LogError(0, RS_RET_ERR, "mmdarwin:: failed to parse existing UUID: %s\n", uuid);
656 		free((void*)uuid);
657 	}
658 	else {
659 		uuid_generate(header.evt_id);
660 		char uuidStr[40];
661 		uuid_unparse(header.evt_id, uuidStr);
662 		DBGPRINTF("mmdarwin: generated new UUID = %s\n", uuidStr);
663 		msgAddJSON(pMsg, (uchar *)pData-&gt;pUUIDKey, json_object_new_string(uuidStr), 0, 0);
664 	}
665 	DBGPRINTF("mmdarwin::doAction:: sending header to Darwin\n");
666 	CHKiRet(sendMsg(pWrkrData, &amp;header, sizeof(darwin_filter_packet_t)));
667 	DBGPRINTF("mmdarwin::doAction:: sending body to Darwin\n");
668 	CHKiRet(sendMsg(pWrkrData, (void *)(pWrkrData-&gt;darwinBody.buffer), pWrkrData-&gt;darwinBody.bufferMsgSize));
669 	if (pData-&gt;response == DARWIN_RESPONSE_SEND_NO || pData-&gt;response == DARWIN_RESPONSE_SEND_DARWIN)
670 	{
671 		DBGPRINTF("mmdarwin::doAction:: no response will be sent back "
672 				"(darwin response type is set to 'no' or 'darwin')\n");
673 		goto finalize_it;
674 	}
675 	darwin_filter_packet_t response;
676 	memset(&amp;response, 0, sizeof(response));
677 	DBGPRINTF("mmdarwin::doAction:: receiving from Darwin\n");
678 	CHKiRet(receiveMsg(pWrkrData, &amp;response, sizeof(response)));
679 	unsigned int certitude = response.certitude_list[0];
680 	DBGPRINTF("mmdarwin::doAction:: end of the transaction, certitude is %d\n", certitude);
681 	msgAddJSON(pMsg, (uchar *)pData-&gt;pCertitudeKey, json_object_new_int(certitude), 0, 0);
682 finalize_it :
683 	DBGPRINTF("mmdarwin::doAction:: finished processing log line\n");
684 ENDdoAction
685 NO_LEGACY_CONF_parseSelectorAct
686 BEGINmodExit
687 CODESTARTmodExit
688 	objRelease(glbl, CORE_COMPONENT);
689 ENDmodExit
690 BEGINqueryEtryPt
691 CODESTARTqueryEtryPt
692 CODEqueryEtryPt_STD_OMOD_QUERIES
693 CODEqueryEtryPt_STD_OMOD8_QUERIES
694 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
695 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
696 CODEqueryEtryPt_STD_CONF2_QUERIES
697 ENDqueryEtryPt
698 BEGINmodInit()
699 CODESTARTmodInit
700 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
701 CODEmodInit_QueryRegCFSLineHdlr
702 	DBGPRINTF("mmdarwin::modInit:: module compiled with rsyslog version %s.\n", VERSION);
703 	CHKiRet(objUse(glbl, CORE_COMPONENT));
704 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
