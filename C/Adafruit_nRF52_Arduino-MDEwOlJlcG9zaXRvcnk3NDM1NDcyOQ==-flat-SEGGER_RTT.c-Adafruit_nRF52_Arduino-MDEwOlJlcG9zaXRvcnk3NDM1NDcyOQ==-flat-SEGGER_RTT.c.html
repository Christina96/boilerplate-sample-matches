
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.c</h3>
            <pre><code>1  #include "SEGGER_RTT.h"
2  #include <string.h>                 
3  #ifndef   BUFFER_SIZE_UP
4    #define BUFFER_SIZE_UP                                  1024  
5  #endif
6  #ifndef   BUFFER_SIZE_DOWN
7    #define BUFFER_SIZE_DOWN                                16    
8  #endif
9  #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
10    #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    
11  #endif
12  #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
13    #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    
14  #endif
15  #ifndef SEGGER_RTT_BUFFER_SECTION
16    #if defined(SEGGER_RTT_SECTION)
17      #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
18    #endif
19  #endif
20  #ifndef   SEGGER_RTT_ALIGNMENT
21    #define SEGGER_RTT_ALIGNMENT                            0
22  #endif
23  #ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
24    #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
25  #endif
26  #ifndef   SEGGER_RTT_MODE_DEFAULT
27    #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
28  #endif
29  #ifndef   SEGGER_RTT_LOCK
30    #define SEGGER_RTT_LOCK()
31  #endif
32  #ifndef   SEGGER_RTT_UNLOCK
33    #define SEGGER_RTT_UNLOCK()
34  #endif
35  #ifndef   STRLEN
36    #define STRLEN(a)                                       strlen((a))
37  #endif
38  #ifndef   STRCPY
39    #define STRCPY(pDest, pSrc, NumBytes)                   strcpy((pDest), (pSrc))
40  #endif
41  #ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
42    #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
43  #endif
44  #ifndef   SEGGER_RTT_MEMCPY
45    #ifdef  MEMCPY
46      #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
47    #else
48      #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
49    #endif
50  #endif
51  #ifndef   MIN
52    #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
53  #endif
54  #ifndef   MAX
55    #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
56  #endif
57  #ifndef NULL
58    #define NULL 0
59  #endif
60  #if (defined __ICCARM__) || (defined __ICCRX__)
61    #define RTT_PRAGMA(P) _Pragma(#P)
62  #endif
63  #if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
64    #if (defined __GNUC__)
65      #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
66    #elif (defined __ICCARM__) || (defined __ICCRX__)
67      #define PRAGMA(A) _Pragma(#A)
68  #define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
69                                    Var
70    #elif (defined __CC_ARM)
71      #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
72    #else
73      #error "Alignment not supported for this compiler."
74    #endif
75  #else
76    #define SEGGER_RTT_ALIGN(Var, Alignment) Var
77  #endif
78  #if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
79    #if (defined __GNUC__)
80      #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
81    #elif (defined __ICCARM__) || (defined __ICCRX__)
82  #define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
83                                          Var
84    #elif (defined __CC_ARM)
85      #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
86    #else
87      #error "Section placement not supported for this compiler."
88    #endif
89  #else
90    #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
91  #endif
92  #if SEGGER_RTT_ALIGNMENT
93    #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
94  #else
95    #define SEGGER_RTT_CB_ALIGN(Var)  Var
96  #endif
97  #if SEGGER_RTT_BUFFER_ALIGNMENT
98    #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
99  #else
100    #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
101  #endif
102  #if defined(SEGGER_RTT_SECTION)
103    #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
104  #else
105    #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
106  #endif
107  #if defined(SEGGER_RTT_BUFFER_SECTION)
108    #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
109  #else
110    #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
111  #endif
112  static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
113  SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
114  SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
115  SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
116  static unsigned char _ActiveTerminal;
117  #define INIT()  do {                                            \
118                    if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
119                  } while (0)
120  static void _DoInit(void) {
121    SEGGER_RTT_CB* p;
122    p = &_SEGGER_RTT;
123    p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
124    p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
125    p->aUp[0].sName         = "Terminal";
126    p->aUp[0].pBuffer       = _acUpBuffer;
127    p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
128    p->aUp[0].RdOff         = 0u;
129    p->aUp[0].WrOff         = 0u;
130    p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
131    p->aDown[0].sName         = "Terminal";
132    p->aDown[0].pBuffer       = _acDownBuffer;
133    p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
134    p->aDown[0].RdOff         = 0u;
135    p->aDown[0].WrOff         = 0u;
136    p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
137    STRCPY(&p->acID[7], "RTT", 9);
138    STRCPY(&p->acID[0], "SEGGER", 7);
139    p->acID[6] = ' ';
140  }
141  static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
142    unsigned NumBytesToWrite;
143    unsigned NumBytesWritten;
144    unsigned RdOff;
145    unsigned WrOff;
146  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
147    char*    pDst;
148  #endif
149    NumBytesWritten = 0u;
150    WrOff = pRing->WrOff;
151    do {
152      RdOff = pRing->RdOff;                         
153      if (RdOff > WrOff) {
154        NumBytesToWrite = RdOff - WrOff - 1u;
155      } else {
156        NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
157      }
158      NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      
159      NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
160  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
161      pDst = pRing->pBuffer + WrOff;
162      NumBytesWritten += NumBytesToWrite;
163      NumBytes        -= NumBytesToWrite;
164      WrOff           += NumBytesToWrite;
165      while (NumBytesToWrite--) {
166        *pDst++ = *pBuffer++;
167      };
168  #else
169      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
170      NumBytesWritten += NumBytesToWrite;
171      pBuffer         += NumBytesToWrite;
172      NumBytes        -= NumBytesToWrite;
173      WrOff           += NumBytesToWrite;
174  #endif
175      if (WrOff == pRing->SizeOfBuffer) {
176        WrOff = 0u;
177      }
178      pRing->WrOff = WrOff;
179    } while (NumBytes);
180    return NumBytesWritten;
181  }
182  static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
183    unsigned NumBytesAtOnce;
184    unsigned WrOff;
185    unsigned Rem;
186  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
187    char*    pDst;
188  #endif
189    WrOff = pRing->WrOff;
190    Rem = pRing->SizeOfBuffer - WrOff;
191    if (Rem > NumBytes) {
192  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
193      pDst = pRing->pBuffer + WrOff;
194      WrOff += NumBytes;
195      while (NumBytes--) {
196        *pDst++ = *pData++;
197      };
198      pRing->WrOff = WrOff;
199  #else
200      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
201      pRing->WrOff = WrOff + NumBytes;
202  #endif
203    } else {
204  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
205      pDst = pRing->pBuffer + WrOff;
206      NumBytesAtOnce = Rem;
207      while (NumBytesAtOnce--) {
208        *pDst++ = *pData++;
209      };
210      pDst = pRing->pBuffer;
211      NumBytesAtOnce = NumBytes - Rem;
212      while (NumBytesAtOnce--) {
213        *pDst++ = *pData++;
214      };
215      pRing->WrOff = NumBytes - Rem;
216  #else
217      NumBytesAtOnce = Rem;
218      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
219      NumBytesAtOnce = NumBytes - Rem;
220      SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
221      pRing->WrOff = NumBytesAtOnce;
222  #endif
223    }
224  }
225  static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
226    unsigned char ac[2];
227    ac[0] = 0xFFu;
228    ac[1] = _aTerminalId[TerminalId];  
229    _WriteBlocking(pRing, (const char*)ac, 2u);
230  }
231  static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
232    unsigned RdOff;
233    unsigned WrOff;
234    unsigned r;
235    RdOff = pRing->RdOff;
236    WrOff = pRing->WrOff;
237    if (RdOff <= WrOff) {
238      r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
239    } else {
240      r = RdOff - WrOff - 1u;
241    }
242    return r;
243  }
244  unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
245    unsigned                NumBytesRem;
246    unsigned                NumBytesRead;
247    unsigned                RdOff;
248    unsigned                WrOff;
249    unsigned char*          pBuffer;
250    SEGGER_RTT_BUFFER_UP*   pRing;
251  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
252    const char*             pSrc;
253  #endif
254    INIT();
255    pRing = &_SEGGER_RTT.aUp[BufferIndex];
256    pBuffer = (unsigned char*)pData;
257    RdOff = pRing->RdOff;
258    WrOff = pRing->WrOff;
259    NumBytesRead = 0u;
260    if (RdOff > WrOff) {
261      NumBytesRem = pRing->SizeOfBuffer - RdOff;
262      NumBytesRem = MIN(NumBytesRem, BufferSize);
263  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
264      pSrc = pRing->pBuffer + RdOff;
265      NumBytesRead += NumBytesRem;
266      BufferSize   -= NumBytesRem;
267      RdOff        += NumBytesRem;
268      while (NumBytesRem--) {
269        *pBuffer++ = *pSrc++;
270      };
271  #else
272      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
273      NumBytesRead += NumBytesRem;
274      pBuffer      += NumBytesRem;
275      BufferSize   -= NumBytesRem;
276      RdOff        += NumBytesRem;
277  #endif
278      if (RdOff == pRing->SizeOfBuffer) {
279        RdOff = 0u;
280      }
281    }
282    NumBytesRem = WrOff - RdOff;
283    NumBytesRem = MIN(NumBytesRem, BufferSize);
284    if (NumBytesRem > 0u) {
285  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
286      pSrc = pRing->pBuffer + RdOff;
287      NumBytesRead += NumBytesRem;
288      BufferSize   -= NumBytesRem;
289      RdOff        += NumBytesRem;
290      while (NumBytesRem--) {
291        *pBuffer++ = *pSrc++;
292      };
293  #else
294      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
295      NumBytesRead += NumBytesRem;
296      pBuffer      += NumBytesRem;
297      BufferSize   -= NumBytesRem;
298      RdOff        += NumBytesRem;
299  #endif
300    }
301    if (NumBytesRead) {
302      pRing->RdOff = RdOff;
303    }
304    return NumBytesRead;
305  }
306  unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
307    unsigned                NumBytesRem;
308    unsigned                NumBytesRead;
309    unsigned                RdOff;
310    unsigned                WrOff;
311    unsigned char*          pBuffer;
312    SEGGER_RTT_BUFFER_DOWN* pRing;
313  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
314    const char*             pSrc;
315  #endif
316    INIT();
317    pRing = &_SEGGER_RTT.aDown[BufferIndex];
318    pBuffer = (unsigned char*)pData;
319    RdOff = pRing->RdOff;
320    WrOff = pRing->WrOff;
321    NumBytesRead = 0u;
322    if (RdOff > WrOff) {
323      NumBytesRem = pRing->SizeOfBuffer - RdOff;
324      NumBytesRem = MIN(NumBytesRem, BufferSize);
325  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
326      pSrc = pRing->pBuffer + RdOff;
327      NumBytesRead += NumBytesRem;
328      BufferSize   -= NumBytesRem;
329      RdOff        += NumBytesRem;
330      while (NumBytesRem--) {
331        *pBuffer++ = *pSrc++;
332      };
333  #else
334      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
335      NumBytesRead += NumBytesRem;
336      pBuffer      += NumBytesRem;
<span onclick='openModal()' class='match'>337      BufferSize   -= NumBytesRem;
338      RdOff        += NumBytesRem;
339  #endif
340      if (RdOff == pRing->SizeOfBuffer) {
341        RdOff = 0u;
342      }
343    }
</span>344    NumBytesRem = WrOff - RdOff;
345    NumBytesRem = MIN(NumBytesRem, BufferSize);
346    if (NumBytesRem > 0u) {
347  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
348      pSrc = pRing->pBuffer + RdOff;
349      NumBytesRead += NumBytesRem;
350      BufferSize   -= NumBytesRem;
351      RdOff        += NumBytesRem;
352      while (NumBytesRem--) {
353        *pBuffer++ = *pSrc++;
354      };
355  #else
356      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
357      NumBytesRead += NumBytesRem;
358      pBuffer      += NumBytesRem;
359      BufferSize   -= NumBytesRem;
360      RdOff        += NumBytesRem;
361  #endif
362    }
363    if (NumBytesRead) {
364      pRing->RdOff = RdOff;
365    }
366    return NumBytesRead;
367  }
368  unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
369    unsigned NumBytesRead;
370    SEGGER_RTT_LOCK();
371    NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
372    SEGGER_RTT_UNLOCK();
373    return NumBytesRead;
374  }
375  unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
376    unsigned NumBytesRead;
377    SEGGER_RTT_LOCK();
378    NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
379    SEGGER_RTT_UNLOCK();
380    return NumBytesRead;
381  }
382  void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
383    const char*           pData;
384    SEGGER_RTT_BUFFER_UP* pRing;
385    unsigned              Avail;
386  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
387    char*                 pDst;
388  #endif
389    pData = (const char *)pBuffer;
390    pRing = &_SEGGER_RTT.aUp[BufferIndex];
391    if (pRing->WrOff == pRing->RdOff) {
392      Avail = pRing->SizeOfBuffer - 1u;
393    } else if ( pRing->WrOff < pRing->RdOff) {
394      Avail = pRing->RdOff - pRing->WrOff - 1u;
395    } else {
396      Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
397    }
398    if (NumBytes > Avail) {
399      pRing->RdOff += (NumBytes - Avail);
400      while (pRing->RdOff >= pRing->SizeOfBuffer) {
401        pRing->RdOff -= pRing->SizeOfBuffer;
402      }
403    }
404    Avail = pRing->SizeOfBuffer - pRing->WrOff;
405    do {
406      if (Avail > NumBytes) {
407  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
408        pDst = pRing->pBuffer + pRing->WrOff;
409        Avail = NumBytes;
410        while (NumBytes--) {
411          *pDst++ = *pData++;
412        };
413        pRing->WrOff += Avail;
414  #else
415        SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
416        pRing->WrOff += NumBytes;
417  #endif
418        break;
419      } else {
420  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
421        pDst = pRing->pBuffer + pRing->WrOff;
422        NumBytes -= Avail;
423        while (Avail--) {
424          *pDst++ = *pData++;
425        };
426        pRing->WrOff = 0;
427  #else
428        SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
429        pData += Avail;
430        pRing->WrOff = 0;
431        NumBytes -= Avail;
432  #endif
433        Avail = (pRing->SizeOfBuffer - 1);
434      }
435    } while (NumBytes);
436  }
437  #if (RTT_USE_ASM == 0)
438  unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
439    const char*           pData;
440    SEGGER_RTT_BUFFER_UP* pRing;
441    unsigned              Avail;
442    unsigned              RdOff;
443    unsigned              WrOff;
444    unsigned              Rem;
445    pData = (const char *)pBuffer;
446    pRing = &_SEGGER_RTT.aUp[BufferIndex];
447    RdOff = pRing->RdOff;
448    WrOff = pRing->WrOff;
449    if (RdOff <= WrOff) {                                 
450      Avail = pRing->SizeOfBuffer - WrOff - 1u;           
451      if (Avail >= NumBytes) {                            
452  CopyStraight:
453        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
454        pRing->WrOff = WrOff + NumBytes;
455        return 1;
456      }
457      Avail += RdOff;                                     
458      if (Avail >= NumBytes) {                            
459        Rem = pRing->SizeOfBuffer - WrOff;                
460        memcpy(pRing->pBuffer + WrOff, pData, Rem);       
461        NumBytes -= Rem;
462        if (NumBytes) {
463          memcpy(pRing->pBuffer, pData + Rem, NumBytes);
464        }
465        pRing->WrOff = NumBytes;
466        return 1;
467      }
468    } else {                                             
469      Avail = RdOff - WrOff - 1u;
470      if (Avail >= NumBytes) {                           
471        goto CopyStraight;
472      }
473    }
474    return 0;     
475  }
476  #endif
477  unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
478    unsigned                Status;
479    unsigned                Avail;
480    const char*             pData;
481    SEGGER_RTT_BUFFER_UP*   pRing;
482    pData = (const char *)pBuffer;
483    pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
484    switch (pRing->Flags) {
485    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
486      Avail = _GetAvailWriteSpace(pRing);
487      if (Avail < NumBytes) {
488        Status = 0u;
489      } else {
490        Status = NumBytes;
491        _WriteNoCheck(pRing, pData, NumBytes);
492      }
493      break;
494    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
495      Avail = _GetAvailWriteSpace(pRing);
496      Status = Avail < NumBytes ? Avail : NumBytes;
497      _WriteNoCheck(pRing, pData, Status);
498      break;
499    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
500      Status = _WriteBlocking(pRing, pData, NumBytes);
501      break;
502    default:
503      Status = 0u;
504      break;
505    }
506    return Status;
507  }
508  unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
509    unsigned              Status;
510    unsigned              Avail;
511    const char*           pData;
512    SEGGER_RTT_BUFFER_UP* pRing;
513    pData = (const char *)pBuffer;
514    pRing = &_SEGGER_RTT.aUp[BufferIndex];
515    switch (pRing->Flags) {
516    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
517      Avail = _GetAvailWriteSpace(pRing);
518      if (Avail < NumBytes) {
519        Status = 0u;
520      } else {
521        Status = NumBytes;
522        _WriteNoCheck(pRing, pData, NumBytes);
523      }
524      break;
525    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
526      Avail = _GetAvailWriteSpace(pRing);
527      Status = Avail < NumBytes ? Avail : NumBytes;
528      _WriteNoCheck(pRing, pData, Status);
529      break;
530    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
531      Status = _WriteBlocking(pRing, pData, NumBytes);
532      break;
533    default:
534      Status = 0u;
535      break;
536    }
537    return Status;
538  }
539  unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
540    unsigned Status;
541    INIT();
542    SEGGER_RTT_LOCK();
543    Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
544    SEGGER_RTT_UNLOCK();
545    return Status;
546  }
547  unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
548    unsigned Status;
549    INIT();
550    SEGGER_RTT_LOCK();
551    Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
552    SEGGER_RTT_UNLOCK();
553    return Status;
554  }
555  unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
556    unsigned Len;
557    Len = STRLEN(s);
558    return SEGGER_RTT_Write(BufferIndex, s, Len);
559  }
560  unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
561    SEGGER_RTT_BUFFER_UP* pRing;
562    unsigned              WrOff;
563    unsigned              Status;
564    pRing = &_SEGGER_RTT.aUp[BufferIndex];
565    WrOff = pRing->WrOff + 1;
566    if (WrOff == pRing->SizeOfBuffer) {
567      WrOff = 0;
568    }
569    if (WrOff != pRing->RdOff) {
570      pRing->pBuffer[pRing->WrOff] = c;
571      pRing->WrOff = WrOff;
572      Status = 1;
573    } else {
574      Status = 0;
575    }
576    return Status;
577  }
578  unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
579    SEGGER_RTT_BUFFER_UP* pRing;
580    unsigned              WrOff;
581    unsigned              Status;
582    INIT();
583    SEGGER_RTT_LOCK();
584    pRing = &_SEGGER_RTT.aUp[BufferIndex];
585    WrOff = pRing->WrOff + 1;
586    if (WrOff == pRing->SizeOfBuffer) {
587      WrOff = 0;
588    }
589    if (WrOff != pRing->RdOff) {
590      pRing->pBuffer[pRing->WrOff] = c;
591      pRing->WrOff = WrOff;
592      Status = 1;
593    } else {
594      Status = 0;
595    }
596    SEGGER_RTT_UNLOCK();
597    return Status;
598  }
599  unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
600    SEGGER_RTT_BUFFER_UP* pRing;
601    unsigned              WrOff;
602    unsigned              Status;
603    INIT();
604    SEGGER_RTT_LOCK();
605    pRing = &_SEGGER_RTT.aUp[BufferIndex];
606    WrOff = pRing->WrOff + 1;
607    if (WrOff == pRing->SizeOfBuffer) {
608      WrOff = 0;
609    }
610    if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
611      while (WrOff == pRing->RdOff) {
612        ;
613      }
614    }
615    if (WrOff != pRing->RdOff) {
616      pRing->pBuffer[pRing->WrOff] = c;
617      pRing->WrOff = WrOff;
618      Status = 1;
619    } else {
620      Status = 0;
621    }
622    SEGGER_RTT_UNLOCK();
623    return Status;
624  }
625  int SEGGER_RTT_GetKey(void) {
626    char c;
627    int r;
628    r = (int)SEGGER_RTT_Read(0u, &c, 1u);
629    if (r == 1) {
630      r = (int)(unsigned char)c;
631    } else {
632      r = -1;
633    }
634    return r;
635  }
636  int SEGGER_RTT_WaitKey(void) {
637    int r;
638    do {
639      r = SEGGER_RTT_GetKey();
640    } while (r < 0);
641    return r;
642  }
643  int SEGGER_RTT_HasKey(void) {
644    unsigned RdOff;
645    int r;
646    INIT();
647    RdOff = _SEGGER_RTT.aDown[0].RdOff;
648    if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
649      r = 1;
650    } else {
651      r = 0;
652    }
653    return r;
654  }
655  unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
656    SEGGER_RTT_BUFFER_DOWN* pRing;
657    unsigned                v;
658    pRing = &_SEGGER_RTT.aDown[BufferIndex];
659    v = pRing->WrOff;
660    return v - pRing->RdOff;
661  }
662  unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
663    SEGGER_RTT_BUFFER_UP* pRing;
664    unsigned                v;
665    pRing = &_SEGGER_RTT.aUp[BufferIndex];
666    v = pRing->RdOff;
667    return pRing->WrOff - v;
668  }
669  int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
670    int BufferIndex;
671    INIT();
672    SEGGER_RTT_LOCK();
673    BufferIndex = 0;
674    do {
675      if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
676        break;
677      }
678      BufferIndex++;
679    } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
680    if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
681      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
682      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
683      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
684      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
685      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
686      _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
687    } else {
688      BufferIndex = -1;
689    }
690    SEGGER_RTT_UNLOCK();
691    return BufferIndex;
692  }
693  int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
694    int BufferIndex;
695    INIT();
696    SEGGER_RTT_LOCK();
697    BufferIndex = 0;
698    do {
699      if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
700        break;
701      }
702      BufferIndex++;
703    } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
704    if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
705      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
706      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
707      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
708      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
709      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
710      _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
711    } else {
712      BufferIndex = -1;
713    }
714    SEGGER_RTT_UNLOCK();
715    return BufferIndex;
716  }
717  int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
718    int r;
719    INIT();
720    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
721      SEGGER_RTT_LOCK();
722      if (BufferIndex > 0u) {
723        _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
724        _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
725        _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
726        _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
727        _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
728      }
729      _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
730      SEGGER_RTT_UNLOCK();
731      r =  0;
732    } else {
733      r = -1;
734    }
735    return r;
736  }
737  int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
738    int r;
739    INIT();
740    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
741      SEGGER_RTT_LOCK();
742      if (BufferIndex > 0u) {
743        _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
744        _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
745        _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
746        _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
747        _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
748      }
749      _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
750      SEGGER_RTT_UNLOCK();
751      r =  0;
752    } else {
753      r = -1;
754    }
755    return r;
756  }
757  int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
758    int r;
759    INIT();
760    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
761      SEGGER_RTT_LOCK();
762      _SEGGER_RTT.aUp[BufferIndex].sName = sName;
763      SEGGER_RTT_UNLOCK();
764      r =  0;
765    } else {
766      r = -1;
767    }
768    return r;
769  }
770  int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
771    int r;
772    INIT();
773    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
774      SEGGER_RTT_LOCK();
775      _SEGGER_RTT.aDown[BufferIndex].sName = sName;
776      SEGGER_RTT_UNLOCK();
777      r =  0;
778    } else {
779      r = -1;
780    }
781    return r;
782  }
783  int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
784    int r;
785    INIT();
786    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
787      SEGGER_RTT_LOCK();
788      _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
789      SEGGER_RTT_UNLOCK();
790      r =  0;
791    } else {
792      r = -1;
793    }
794    return r;
795  }
796  int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
797    int r;
798    INIT();
799    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
800      SEGGER_RTT_LOCK();
801      _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
802      SEGGER_RTT_UNLOCK();
803      r =  0;
804    } else {
805      r = -1;
806    }
807    return r;
808  }
809  void SEGGER_RTT_Init (void) {
810    _DoInit();
811  }
812  int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
813    unsigned char         ac[2];
814    SEGGER_RTT_BUFFER_UP* pRing;
815    unsigned Avail;
816    int r;
817    INIT();
818    r = 0;
819    ac[0] = 0xFFu;
820    if (TerminalId < sizeof(_aTerminalId)) { 
821      ac[1] = _aTerminalId[TerminalId];
822      pRing = &_SEGGER_RTT.aUp[0];    
823      SEGGER_RTT_LOCK();    
824      if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
825        _ActiveTerminal = TerminalId;
826        _WriteBlocking(pRing, (const char*)ac, 2u);
827      } else {                                                                            
828        Avail = _GetAvailWriteSpace(pRing);
829        if (Avail >= 2) {
830          _ActiveTerminal = TerminalId;    
831          _WriteNoCheck(pRing, (const char*)ac, 2u);
832        } else {
833          r = -1;
834        }
835      }
836      SEGGER_RTT_UNLOCK();
837    } else {
838      r = -1;
839    }
840    return r;
841  }
842  int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
843    int                   Status;
844    unsigned              FragLen;
845    unsigned              Avail;
846    SEGGER_RTT_BUFFER_UP* pRing;
847    INIT();
848    if (TerminalId < (char)sizeof(_aTerminalId)) { 
849      pRing = &_SEGGER_RTT.aUp[0];
850      FragLen = STRLEN(s);
851      SEGGER_RTT_LOCK();
852      Avail = _GetAvailWriteSpace(pRing);
853      switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
854      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
855        if (Avail < (FragLen + 4u)) {
856          Status = 0;
857        } else {
858          _PostTerminalSwitch(pRing, TerminalId);
859          Status = (int)_WriteBlocking(pRing, s, FragLen);
860          _PostTerminalSwitch(pRing, _ActiveTerminal);
861        }
862        break;
863      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
864        if (Avail < 4u) {
865          Status = -1;
866        } else {
867          _PostTerminalSwitch(pRing, TerminalId);
868          Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
869          _PostTerminalSwitch(pRing, _ActiveTerminal);
870        }
871        break;
872      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
873        _PostTerminalSwitch(pRing, TerminalId);
874        Status = (int)_WriteBlocking(pRing, s, FragLen);
875        _PostTerminalSwitch(pRing, _ActiveTerminal);
876        break;
877      default:
878        Status = -1;
879        break;
880      }
881      SEGGER_RTT_UNLOCK();
882    } else {
883      Status = -1;
884    }
885    return Status;
886  }
887  unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
888    return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
889  }
890  unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
891    unsigned RdOff;
892    unsigned WrOff;
893    unsigned r;
894    RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
895    WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
896    if (RdOff <= WrOff) {
897      r = WrOff - RdOff;
898    } else {
899      r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
900    }
901    return r;
902  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.c</h3>
            <pre><code>1  #include "SEGGER_RTT.h"
2  #include <string.h>                 
3  #ifndef   BUFFER_SIZE_UP
4    #define BUFFER_SIZE_UP                                  1024  
5  #endif
6  #ifndef   BUFFER_SIZE_DOWN
7    #define BUFFER_SIZE_DOWN                                16    
8  #endif
9  #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
10    #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    
11  #endif
12  #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
13    #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    
14  #endif
15  #ifndef SEGGER_RTT_BUFFER_SECTION
16    #if defined(SEGGER_RTT_SECTION)
17      #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
18    #endif
19  #endif
20  #ifndef   SEGGER_RTT_ALIGNMENT
21    #define SEGGER_RTT_ALIGNMENT                            0
22  #endif
23  #ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
24    #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
25  #endif
26  #ifndef   SEGGER_RTT_MODE_DEFAULT
27    #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
28  #endif
29  #ifndef   SEGGER_RTT_LOCK
30    #define SEGGER_RTT_LOCK()
31  #endif
32  #ifndef   SEGGER_RTT_UNLOCK
33    #define SEGGER_RTT_UNLOCK()
34  #endif
35  #ifndef   STRLEN
36    #define STRLEN(a)                                       strlen((a))
37  #endif
38  #ifndef   STRCPY
39    #define STRCPY(pDest, pSrc, NumBytes)                   strcpy((pDest), (pSrc))
40  #endif
41  #ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
42    #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
43  #endif
44  #ifndef   SEGGER_RTT_MEMCPY
45    #ifdef  MEMCPY
46      #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
47    #else
48      #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
49    #endif
50  #endif
51  #ifndef   MIN
52    #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
53  #endif
54  #ifndef   MAX
55    #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
56  #endif
57  #ifndef NULL
58    #define NULL 0
59  #endif
60  #if (defined __ICCARM__) || (defined __ICCRX__)
61    #define RTT_PRAGMA(P) _Pragma(#P)
62  #endif
63  #if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
64    #if (defined __GNUC__)
65      #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
66    #elif (defined __ICCARM__) || (defined __ICCRX__)
67      #define PRAGMA(A) _Pragma(#A)
68  #define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
69                                    Var
70    #elif (defined __CC_ARM)
71      #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
72    #else
73      #error "Alignment not supported for this compiler."
74    #endif
75  #else
76    #define SEGGER_RTT_ALIGN(Var, Alignment) Var
77  #endif
78  #if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
79    #if (defined __GNUC__)
80      #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
81    #elif (defined __ICCARM__) || (defined __ICCRX__)
82  #define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
83                                          Var
84    #elif (defined __CC_ARM)
85      #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
86    #else
87      #error "Section placement not supported for this compiler."
88    #endif
89  #else
90    #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
91  #endif
92  #if SEGGER_RTT_ALIGNMENT
93    #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
94  #else
95    #define SEGGER_RTT_CB_ALIGN(Var)  Var
96  #endif
97  #if SEGGER_RTT_BUFFER_ALIGNMENT
98    #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
99  #else
100    #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
101  #endif
102  #if defined(SEGGER_RTT_SECTION)
103    #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
104  #else
105    #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
106  #endif
107  #if defined(SEGGER_RTT_BUFFER_SECTION)
108    #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
109  #else
110    #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
111  #endif
112  static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
113  SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
114  SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
115  SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
116  static unsigned char _ActiveTerminal;
117  #define INIT()  do {                                            \
118                    if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
119                  } while (0)
120  static void _DoInit(void) {
121    SEGGER_RTT_CB* p;
122    p = &_SEGGER_RTT;
123    p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
124    p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
125    p->aUp[0].sName         = "Terminal";
126    p->aUp[0].pBuffer       = _acUpBuffer;
127    p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
128    p->aUp[0].RdOff         = 0u;
129    p->aUp[0].WrOff         = 0u;
130    p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
131    p->aDown[0].sName         = "Terminal";
132    p->aDown[0].pBuffer       = _acDownBuffer;
133    p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
134    p->aDown[0].RdOff         = 0u;
135    p->aDown[0].WrOff         = 0u;
136    p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
137    STRCPY(&p->acID[7], "RTT", 9);
138    STRCPY(&p->acID[0], "SEGGER", 7);
139    p->acID[6] = ' ';
140  }
141  static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
142    unsigned NumBytesToWrite;
143    unsigned NumBytesWritten;
144    unsigned RdOff;
145    unsigned WrOff;
146  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
147    char*    pDst;
148  #endif
149    NumBytesWritten = 0u;
150    WrOff = pRing->WrOff;
151    do {
152      RdOff = pRing->RdOff;                         
153      if (RdOff > WrOff) {
154        NumBytesToWrite = RdOff - WrOff - 1u;
155      } else {
156        NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
157      }
158      NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      
159      NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
160  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
161      pDst = pRing->pBuffer + WrOff;
162      NumBytesWritten += NumBytesToWrite;
163      NumBytes        -= NumBytesToWrite;
164      WrOff           += NumBytesToWrite;
165      while (NumBytesToWrite--) {
166        *pDst++ = *pBuffer++;
167      };
168  #else
169      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
170      NumBytesWritten += NumBytesToWrite;
171      pBuffer         += NumBytesToWrite;
<span onclick='openModal()' class='match'>172      NumBytes        -= NumBytesToWrite;
173      WrOff           += NumBytesToWrite;
174  #endif
175      if (WrOff == pRing->SizeOfBuffer) {
176        WrOff = 0u;
177      }
178      pRing->WrOff = WrOff;
</span>179    } while (NumBytes);
180    return NumBytesWritten;
181  }
182  static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
183    unsigned NumBytesAtOnce;
184    unsigned WrOff;
185    unsigned Rem;
186  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
187    char*    pDst;
188  #endif
189    WrOff = pRing->WrOff;
190    Rem = pRing->SizeOfBuffer - WrOff;
191    if (Rem > NumBytes) {
192  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
193      pDst = pRing->pBuffer + WrOff;
194      WrOff += NumBytes;
195      while (NumBytes--) {
196        *pDst++ = *pData++;
197      };
198      pRing->WrOff = WrOff;
199  #else
200      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
201      pRing->WrOff = WrOff + NumBytes;
202  #endif
203    } else {
204  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
205      pDst = pRing->pBuffer + WrOff;
206      NumBytesAtOnce = Rem;
207      while (NumBytesAtOnce--) {
208        *pDst++ = *pData++;
209      };
210      pDst = pRing->pBuffer;
211      NumBytesAtOnce = NumBytes - Rem;
212      while (NumBytesAtOnce--) {
213        *pDst++ = *pData++;
214      };
215      pRing->WrOff = NumBytes - Rem;
216  #else
217      NumBytesAtOnce = Rem;
218      SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
219      NumBytesAtOnce = NumBytes - Rem;
220      SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
221      pRing->WrOff = NumBytesAtOnce;
222  #endif
223    }
224  }
225  static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
226    unsigned char ac[2];
227    ac[0] = 0xFFu;
228    ac[1] = _aTerminalId[TerminalId];  
229    _WriteBlocking(pRing, (const char*)ac, 2u);
230  }
231  static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
232    unsigned RdOff;
233    unsigned WrOff;
234    unsigned r;
235    RdOff = pRing->RdOff;
236    WrOff = pRing->WrOff;
237    if (RdOff <= WrOff) {
238      r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
239    } else {
240      r = RdOff - WrOff - 1u;
241    }
242    return r;
243  }
244  unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
245    unsigned                NumBytesRem;
246    unsigned                NumBytesRead;
247    unsigned                RdOff;
248    unsigned                WrOff;
249    unsigned char*          pBuffer;
250    SEGGER_RTT_BUFFER_UP*   pRing;
251  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
252    const char*             pSrc;
253  #endif
254    INIT();
255    pRing = &_SEGGER_RTT.aUp[BufferIndex];
256    pBuffer = (unsigned char*)pData;
257    RdOff = pRing->RdOff;
258    WrOff = pRing->WrOff;
259    NumBytesRead = 0u;
260    if (RdOff > WrOff) {
261      NumBytesRem = pRing->SizeOfBuffer - RdOff;
262      NumBytesRem = MIN(NumBytesRem, BufferSize);
263  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
264      pSrc = pRing->pBuffer + RdOff;
265      NumBytesRead += NumBytesRem;
266      BufferSize   -= NumBytesRem;
267      RdOff        += NumBytesRem;
268      while (NumBytesRem--) {
269        *pBuffer++ = *pSrc++;
270      };
271  #else
272      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
273      NumBytesRead += NumBytesRem;
274      pBuffer      += NumBytesRem;
275      BufferSize   -= NumBytesRem;
276      RdOff        += NumBytesRem;
277  #endif
278      if (RdOff == pRing->SizeOfBuffer) {
279        RdOff = 0u;
280      }
281    }
282    NumBytesRem = WrOff - RdOff;
283    NumBytesRem = MIN(NumBytesRem, BufferSize);
284    if (NumBytesRem > 0u) {
285  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
286      pSrc = pRing->pBuffer + RdOff;
287      NumBytesRead += NumBytesRem;
288      BufferSize   -= NumBytesRem;
289      RdOff        += NumBytesRem;
290      while (NumBytesRem--) {
291        *pBuffer++ = *pSrc++;
292      };
293  #else
294      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
295      NumBytesRead += NumBytesRem;
296      pBuffer      += NumBytesRem;
297      BufferSize   -= NumBytesRem;
298      RdOff        += NumBytesRem;
299  #endif
300    }
301    if (NumBytesRead) {
302      pRing->RdOff = RdOff;
303    }
304    return NumBytesRead;
305  }
306  unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
307    unsigned                NumBytesRem;
308    unsigned                NumBytesRead;
309    unsigned                RdOff;
310    unsigned                WrOff;
311    unsigned char*          pBuffer;
312    SEGGER_RTT_BUFFER_DOWN* pRing;
313  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
314    const char*             pSrc;
315  #endif
316    INIT();
317    pRing = &_SEGGER_RTT.aDown[BufferIndex];
318    pBuffer = (unsigned char*)pData;
319    RdOff = pRing->RdOff;
320    WrOff = pRing->WrOff;
321    NumBytesRead = 0u;
322    if (RdOff > WrOff) {
323      NumBytesRem = pRing->SizeOfBuffer - RdOff;
324      NumBytesRem = MIN(NumBytesRem, BufferSize);
325  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
326      pSrc = pRing->pBuffer + RdOff;
327      NumBytesRead += NumBytesRem;
328      BufferSize   -= NumBytesRem;
329      RdOff        += NumBytesRem;
330      while (NumBytesRem--) {
331        *pBuffer++ = *pSrc++;
332      };
333  #else
334      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
335      NumBytesRead += NumBytesRem;
336      pBuffer      += NumBytesRem;
337      BufferSize   -= NumBytesRem;
338      RdOff        += NumBytesRem;
339  #endif
340      if (RdOff == pRing->SizeOfBuffer) {
341        RdOff = 0u;
342      }
343    }
344    NumBytesRem = WrOff - RdOff;
345    NumBytesRem = MIN(NumBytesRem, BufferSize);
346    if (NumBytesRem > 0u) {
347  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
348      pSrc = pRing->pBuffer + RdOff;
349      NumBytesRead += NumBytesRem;
350      BufferSize   -= NumBytesRem;
351      RdOff        += NumBytesRem;
352      while (NumBytesRem--) {
353        *pBuffer++ = *pSrc++;
354      };
355  #else
356      SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
357      NumBytesRead += NumBytesRem;
358      pBuffer      += NumBytesRem;
359      BufferSize   -= NumBytesRem;
360      RdOff        += NumBytesRem;
361  #endif
362    }
363    if (NumBytesRead) {
364      pRing->RdOff = RdOff;
365    }
366    return NumBytesRead;
367  }
368  unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
369    unsigned NumBytesRead;
370    SEGGER_RTT_LOCK();
371    NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
372    SEGGER_RTT_UNLOCK();
373    return NumBytesRead;
374  }
375  unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
376    unsigned NumBytesRead;
377    SEGGER_RTT_LOCK();
378    NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
379    SEGGER_RTT_UNLOCK();
380    return NumBytesRead;
381  }
382  void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
383    const char*           pData;
384    SEGGER_RTT_BUFFER_UP* pRing;
385    unsigned              Avail;
386  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
387    char*                 pDst;
388  #endif
389    pData = (const char *)pBuffer;
390    pRing = &_SEGGER_RTT.aUp[BufferIndex];
391    if (pRing->WrOff == pRing->RdOff) {
392      Avail = pRing->SizeOfBuffer - 1u;
393    } else if ( pRing->WrOff < pRing->RdOff) {
394      Avail = pRing->RdOff - pRing->WrOff - 1u;
395    } else {
396      Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
397    }
398    if (NumBytes > Avail) {
399      pRing->RdOff += (NumBytes - Avail);
400      while (pRing->RdOff >= pRing->SizeOfBuffer) {
401        pRing->RdOff -= pRing->SizeOfBuffer;
402      }
403    }
404    Avail = pRing->SizeOfBuffer - pRing->WrOff;
405    do {
406      if (Avail > NumBytes) {
407  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
408        pDst = pRing->pBuffer + pRing->WrOff;
409        Avail = NumBytes;
410        while (NumBytes--) {
411          *pDst++ = *pData++;
412        };
413        pRing->WrOff += Avail;
414  #else
415        SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
416        pRing->WrOff += NumBytes;
417  #endif
418        break;
419      } else {
420  #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
421        pDst = pRing->pBuffer + pRing->WrOff;
422        NumBytes -= Avail;
423        while (Avail--) {
424          *pDst++ = *pData++;
425        };
426        pRing->WrOff = 0;
427  #else
428        SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
429        pData += Avail;
430        pRing->WrOff = 0;
431        NumBytes -= Avail;
432  #endif
433        Avail = (pRing->SizeOfBuffer - 1);
434      }
435    } while (NumBytes);
436  }
437  #if (RTT_USE_ASM == 0)
438  unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
439    const char*           pData;
440    SEGGER_RTT_BUFFER_UP* pRing;
441    unsigned              Avail;
442    unsigned              RdOff;
443    unsigned              WrOff;
444    unsigned              Rem;
445    pData = (const char *)pBuffer;
446    pRing = &_SEGGER_RTT.aUp[BufferIndex];
447    RdOff = pRing->RdOff;
448    WrOff = pRing->WrOff;
449    if (RdOff <= WrOff) {                                 
450      Avail = pRing->SizeOfBuffer - WrOff - 1u;           
451      if (Avail >= NumBytes) {                            
452  CopyStraight:
453        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
454        pRing->WrOff = WrOff + NumBytes;
455        return 1;
456      }
457      Avail += RdOff;                                     
458      if (Avail >= NumBytes) {                            
459        Rem = pRing->SizeOfBuffer - WrOff;                
460        memcpy(pRing->pBuffer + WrOff, pData, Rem);       
461        NumBytes -= Rem;
462        if (NumBytes) {
463          memcpy(pRing->pBuffer, pData + Rem, NumBytes);
464        }
465        pRing->WrOff = NumBytes;
466        return 1;
467      }
468    } else {                                             
469      Avail = RdOff - WrOff - 1u;
470      if (Avail >= NumBytes) {                           
471        goto CopyStraight;
472      }
473    }
474    return 0;     
475  }
476  #endif
477  unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
478    unsigned                Status;
479    unsigned                Avail;
480    const char*             pData;
481    SEGGER_RTT_BUFFER_UP*   pRing;
482    pData = (const char *)pBuffer;
483    pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
484    switch (pRing->Flags) {
485    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
486      Avail = _GetAvailWriteSpace(pRing);
487      if (Avail < NumBytes) {
488        Status = 0u;
489      } else {
490        Status = NumBytes;
491        _WriteNoCheck(pRing, pData, NumBytes);
492      }
493      break;
494    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
495      Avail = _GetAvailWriteSpace(pRing);
496      Status = Avail < NumBytes ? Avail : NumBytes;
497      _WriteNoCheck(pRing, pData, Status);
498      break;
499    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
500      Status = _WriteBlocking(pRing, pData, NumBytes);
501      break;
502    default:
503      Status = 0u;
504      break;
505    }
506    return Status;
507  }
508  unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
509    unsigned              Status;
510    unsigned              Avail;
511    const char*           pData;
512    SEGGER_RTT_BUFFER_UP* pRing;
513    pData = (const char *)pBuffer;
514    pRing = &_SEGGER_RTT.aUp[BufferIndex];
515    switch (pRing->Flags) {
516    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
517      Avail = _GetAvailWriteSpace(pRing);
518      if (Avail < NumBytes) {
519        Status = 0u;
520      } else {
521        Status = NumBytes;
522        _WriteNoCheck(pRing, pData, NumBytes);
523      }
524      break;
525    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
526      Avail = _GetAvailWriteSpace(pRing);
527      Status = Avail < NumBytes ? Avail : NumBytes;
528      _WriteNoCheck(pRing, pData, Status);
529      break;
530    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
531      Status = _WriteBlocking(pRing, pData, NumBytes);
532      break;
533    default:
534      Status = 0u;
535      break;
536    }
537    return Status;
538  }
539  unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
540    unsigned Status;
541    INIT();
542    SEGGER_RTT_LOCK();
543    Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
544    SEGGER_RTT_UNLOCK();
545    return Status;
546  }
547  unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
548    unsigned Status;
549    INIT();
550    SEGGER_RTT_LOCK();
551    Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
552    SEGGER_RTT_UNLOCK();
553    return Status;
554  }
555  unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
556    unsigned Len;
557    Len = STRLEN(s);
558    return SEGGER_RTT_Write(BufferIndex, s, Len);
559  }
560  unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
561    SEGGER_RTT_BUFFER_UP* pRing;
562    unsigned              WrOff;
563    unsigned              Status;
564    pRing = &_SEGGER_RTT.aUp[BufferIndex];
565    WrOff = pRing->WrOff + 1;
566    if (WrOff == pRing->SizeOfBuffer) {
567      WrOff = 0;
568    }
569    if (WrOff != pRing->RdOff) {
570      pRing->pBuffer[pRing->WrOff] = c;
571      pRing->WrOff = WrOff;
572      Status = 1;
573    } else {
574      Status = 0;
575    }
576    return Status;
577  }
578  unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
579    SEGGER_RTT_BUFFER_UP* pRing;
580    unsigned              WrOff;
581    unsigned              Status;
582    INIT();
583    SEGGER_RTT_LOCK();
584    pRing = &_SEGGER_RTT.aUp[BufferIndex];
585    WrOff = pRing->WrOff + 1;
586    if (WrOff == pRing->SizeOfBuffer) {
587      WrOff = 0;
588    }
589    if (WrOff != pRing->RdOff) {
590      pRing->pBuffer[pRing->WrOff] = c;
591      pRing->WrOff = WrOff;
592      Status = 1;
593    } else {
594      Status = 0;
595    }
596    SEGGER_RTT_UNLOCK();
597    return Status;
598  }
599  unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
600    SEGGER_RTT_BUFFER_UP* pRing;
601    unsigned              WrOff;
602    unsigned              Status;
603    INIT();
604    SEGGER_RTT_LOCK();
605    pRing = &_SEGGER_RTT.aUp[BufferIndex];
606    WrOff = pRing->WrOff + 1;
607    if (WrOff == pRing->SizeOfBuffer) {
608      WrOff = 0;
609    }
610    if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
611      while (WrOff == pRing->RdOff) {
612        ;
613      }
614    }
615    if (WrOff != pRing->RdOff) {
616      pRing->pBuffer[pRing->WrOff] = c;
617      pRing->WrOff = WrOff;
618      Status = 1;
619    } else {
620      Status = 0;
621    }
622    SEGGER_RTT_UNLOCK();
623    return Status;
624  }
625  int SEGGER_RTT_GetKey(void) {
626    char c;
627    int r;
628    r = (int)SEGGER_RTT_Read(0u, &c, 1u);
629    if (r == 1) {
630      r = (int)(unsigned char)c;
631    } else {
632      r = -1;
633    }
634    return r;
635  }
636  int SEGGER_RTT_WaitKey(void) {
637    int r;
638    do {
639      r = SEGGER_RTT_GetKey();
640    } while (r < 0);
641    return r;
642  }
643  int SEGGER_RTT_HasKey(void) {
644    unsigned RdOff;
645    int r;
646    INIT();
647    RdOff = _SEGGER_RTT.aDown[0].RdOff;
648    if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
649      r = 1;
650    } else {
651      r = 0;
652    }
653    return r;
654  }
655  unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
656    SEGGER_RTT_BUFFER_DOWN* pRing;
657    unsigned                v;
658    pRing = &_SEGGER_RTT.aDown[BufferIndex];
659    v = pRing->WrOff;
660    return v - pRing->RdOff;
661  }
662  unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
663    SEGGER_RTT_BUFFER_UP* pRing;
664    unsigned                v;
665    pRing = &_SEGGER_RTT.aUp[BufferIndex];
666    v = pRing->RdOff;
667    return pRing->WrOff - v;
668  }
669  int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
670    int BufferIndex;
671    INIT();
672    SEGGER_RTT_LOCK();
673    BufferIndex = 0;
674    do {
675      if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
676        break;
677      }
678      BufferIndex++;
679    } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
680    if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
681      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
682      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
683      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
684      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
685      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
686      _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
687    } else {
688      BufferIndex = -1;
689    }
690    SEGGER_RTT_UNLOCK();
691    return BufferIndex;
692  }
693  int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
694    int BufferIndex;
695    INIT();
696    SEGGER_RTT_LOCK();
697    BufferIndex = 0;
698    do {
699      if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
700        break;
701      }
702      BufferIndex++;
703    } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
704    if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
705      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
706      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
707      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
708      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
709      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
710      _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
711    } else {
712      BufferIndex = -1;
713    }
714    SEGGER_RTT_UNLOCK();
715    return BufferIndex;
716  }
717  int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
718    int r;
719    INIT();
720    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
721      SEGGER_RTT_LOCK();
722      if (BufferIndex > 0u) {
723        _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
724        _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
725        _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
726        _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
727        _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
728      }
729      _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
730      SEGGER_RTT_UNLOCK();
731      r =  0;
732    } else {
733      r = -1;
734    }
735    return r;
736  }
737  int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
738    int r;
739    INIT();
740    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
741      SEGGER_RTT_LOCK();
742      if (BufferIndex > 0u) {
743        _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
744        _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
745        _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
746        _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
747        _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
748      }
749      _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
750      SEGGER_RTT_UNLOCK();
751      r =  0;
752    } else {
753      r = -1;
754    }
755    return r;
756  }
757  int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
758    int r;
759    INIT();
760    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
761      SEGGER_RTT_LOCK();
762      _SEGGER_RTT.aUp[BufferIndex].sName = sName;
763      SEGGER_RTT_UNLOCK();
764      r =  0;
765    } else {
766      r = -1;
767    }
768    return r;
769  }
770  int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
771    int r;
772    INIT();
773    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
774      SEGGER_RTT_LOCK();
775      _SEGGER_RTT.aDown[BufferIndex].sName = sName;
776      SEGGER_RTT_UNLOCK();
777      r =  0;
778    } else {
779      r = -1;
780    }
781    return r;
782  }
783  int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
784    int r;
785    INIT();
786    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
787      SEGGER_RTT_LOCK();
788      _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
789      SEGGER_RTT_UNLOCK();
790      r =  0;
791    } else {
792      r = -1;
793    }
794    return r;
795  }
796  int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
797    int r;
798    INIT();
799    if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
800      SEGGER_RTT_LOCK();
801      _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
802      SEGGER_RTT_UNLOCK();
803      r =  0;
804    } else {
805      r = -1;
806    }
807    return r;
808  }
809  void SEGGER_RTT_Init (void) {
810    _DoInit();
811  }
812  int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
813    unsigned char         ac[2];
814    SEGGER_RTT_BUFFER_UP* pRing;
815    unsigned Avail;
816    int r;
817    INIT();
818    r = 0;
819    ac[0] = 0xFFu;
820    if (TerminalId < sizeof(_aTerminalId)) { 
821      ac[1] = _aTerminalId[TerminalId];
822      pRing = &_SEGGER_RTT.aUp[0];    
823      SEGGER_RTT_LOCK();    
824      if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
825        _ActiveTerminal = TerminalId;
826        _WriteBlocking(pRing, (const char*)ac, 2u);
827      } else {                                                                            
828        Avail = _GetAvailWriteSpace(pRing);
829        if (Avail >= 2) {
830          _ActiveTerminal = TerminalId;    
831          _WriteNoCheck(pRing, (const char*)ac, 2u);
832        } else {
833          r = -1;
834        }
835      }
836      SEGGER_RTT_UNLOCK();
837    } else {
838      r = -1;
839    }
840    return r;
841  }
842  int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
843    int                   Status;
844    unsigned              FragLen;
845    unsigned              Avail;
846    SEGGER_RTT_BUFFER_UP* pRing;
847    INIT();
848    if (TerminalId < (char)sizeof(_aTerminalId)) { 
849      pRing = &_SEGGER_RTT.aUp[0];
850      FragLen = STRLEN(s);
851      SEGGER_RTT_LOCK();
852      Avail = _GetAvailWriteSpace(pRing);
853      switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
854      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
855        if (Avail < (FragLen + 4u)) {
856          Status = 0;
857        } else {
858          _PostTerminalSwitch(pRing, TerminalId);
859          Status = (int)_WriteBlocking(pRing, s, FragLen);
860          _PostTerminalSwitch(pRing, _ActiveTerminal);
861        }
862        break;
863      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
864        if (Avail < 4u) {
865          Status = -1;
866        } else {
867          _PostTerminalSwitch(pRing, TerminalId);
868          Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
869          _PostTerminalSwitch(pRing, _ActiveTerminal);
870        }
871        break;
872      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
873        _PostTerminalSwitch(pRing, TerminalId);
874        Status = (int)_WriteBlocking(pRing, s, FragLen);
875        _PostTerminalSwitch(pRing, _ActiveTerminal);
876        break;
877      default:
878        Status = -1;
879        break;
880      }
881      SEGGER_RTT_UNLOCK();
882    } else {
883      Status = -1;
884    }
885    return Status;
886  }
887  unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
888    return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
889  }
890  unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
891    unsigned RdOff;
892    unsigned WrOff;
893    unsigned r;
894    RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
895    WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
896    if (RdOff <= WrOff) {
897      r = WrOff - RdOff;
898    } else {
899      r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
900    }
901    return r;
902  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_RTT.c</div>
                </div>
                <div class="column column_space"><pre><code>337      BufferSize   -= NumBytesRem;
338      RdOff        += NumBytesRem;
339  #endif
340      if (RdOff == pRing->SizeOfBuffer) {
341        RdOff = 0u;
342      }
343    }
</pre></code></div>
                <div class="column column_space"><pre><code>172      NumBytes        -= NumBytesToWrite;
173      WrOff           += NumBytesToWrite;
174  #endif
175      if (WrOff == pRing->SizeOfBuffer) {
176        WrOff = 0u;
177      }
178      pRing->WrOff = WrOff;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    