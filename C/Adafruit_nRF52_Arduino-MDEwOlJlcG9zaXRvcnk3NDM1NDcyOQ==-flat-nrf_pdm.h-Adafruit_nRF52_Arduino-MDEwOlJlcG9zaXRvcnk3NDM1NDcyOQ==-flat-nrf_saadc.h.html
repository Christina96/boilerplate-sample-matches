
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</h3>
            <pre><code>1  #ifndef NRF_PDM_H_
2  #define NRF_PDM_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #ifndef NRF_PDM0
8  #define NRF_PDM0 NRF_PDM
9  #endif
10  #if defined(PDM_MCLKCONFIG_SRC_Msk) || defined(__NRFX_DOXYGEN__)
11  #define NRF_PDM_HAS_MCLKCONFIG 1
12  #else
13  #define NRF_PDM_HAS_MCLKCONFIG 0
14  #endif
15  #if defined(PDM_RATIO_RATIO_Msk) || defined(__NRFX_DOXYGEN__)
16  #define NRF_PDM_HAS_RATIO_CONFIG 1
17  #else
18  #define NRF_PDM_HAS_RATIO_CONFIG 0
19  #endif
20  #define NRF_PDM_GAIN_MINIMUM  0x00
21  #define NRF_PDM_GAIN_DEFAULT  0x28
22  #define NRF_PDM_GAIN_MAXIMUM  0x50
23  typedef uint8_t nrf_pdm_gain_t;
24  typedef enum
25  {
26      NRF_PDM_TASK_START = offsetof(NRF_PDM_Type, TASKS_START), 
27      NRF_PDM_TASK_STOP  = offsetof(NRF_PDM_Type, TASKS_STOP)   
28  } nrf_pdm_task_t;
29  typedef enum
30  {
31      NRF_PDM_EVENT_STARTED = offsetof(NRF_PDM_Type, EVENTS_STARTED), 
32      NRF_PDM_EVENT_STOPPED = offsetof(NRF_PDM_Type, EVENTS_STOPPED), 
33      NRF_PDM_EVENT_END     = offsetof(NRF_PDM_Type, EVENTS_END)      
34  } nrf_pdm_event_t;
35  typedef enum
36  {
37      NRF_PDM_INT_STARTED = PDM_INTENSET_STARTED_Msk, 
38      NRF_PDM_INT_STOPPED = PDM_INTENSET_STOPPED_Msk, 
39      NRF_PDM_INT_END     = PDM_INTENSET_END_Msk      
40  } nrf_pdm_int_mask_t;
41  typedef enum
42  {
43      NRF_PDM_FREQ_1000K = PDM_PDMCLKCTRL_FREQ_1000K,   
44      NRF_PDM_FREQ_1032K = PDM_PDMCLKCTRL_FREQ_Default, 
45      NRF_PDM_FREQ_1067K = PDM_PDMCLKCTRL_FREQ_1067K,   
46  #if defined(PDM_PDMCLKCTRL_FREQ_1231K) || defined(__NRFX_DOXYGEN__)
47      NRF_PDM_FREQ_1231K = PDM_PDMCLKCTRL_FREQ_1231K,   
48  #endif
49  #if defined(PDM_PDMCLKCTRL_FREQ_1280K) || defined(__NRFX_DOXYGEN__)
50      NRF_PDM_FREQ_1280K = PDM_PDMCLKCTRL_FREQ_1280K,   
51  #endif
52  #if defined(PDM_PDMCLKCTRL_FREQ_1333K) || defined(__NRFX_DOXYGEN__)
53      NRF_PDM_FREQ_1333K = PDM_PDMCLKCTRL_FREQ_1333K    
54  #endif
55  } nrf_pdm_freq_t;
56  #if NRF_PDM_HAS_RATIO_CONFIG
57  typedef enum
58  {
59      NRF_PDM_RATIO_64X = PDM_RATIO_RATIO_Ratio64, 
60      NRF_PDM_RATIO_80X = PDM_RATIO_RATIO_Ratio80  
61  } nrf_pdm_ratio_t;
62  #endif
63  typedef enum
64  {
65      NRF_PDM_MODE_STEREO = PDM_MODE_OPERATION_Stereo,  
66      NRF_PDM_MODE_MONO   = PDM_MODE_OPERATION_Mono     
67  } nrf_pdm_mode_t;
68  typedef enum
69  {
70      NRF_PDM_EDGE_LEFTFALLING = PDM_MODE_EDGE_LeftFalling,  
71      NRF_PDM_EDGE_LEFTRISING  = PDM_MODE_EDGE_LeftRising    
72  } nrf_pdm_edge_t;
73  #if NRF_PDM_HAS_MCLKCONFIG
74  typedef enum
75  {
76      NRF_PDM_MCLKSRC_PCLK32M = PDM_MCLKCONFIG_SRC_PCLK32M, 
77      NRF_PDM_MCLKSRC_ACLK    = PDM_MCLKCONFIG_SRC_ACLK     
78  } nrf_pdm_mclksrc_t;
79  #endif
80  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
81  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg,
82                                                      nrf_pdm_task_t       task);
83  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event);
84  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
85  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
86                                                       nrf_pdm_event_t      event);
87  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask);
88  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask);
89  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask);
90  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
91  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
92                                               nrf_pdm_task_t task,
93                                               uint8_t        channel);
94  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
95  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
96                                             nrf_pdm_event_t event,
97                                             uint8_t         channel);
98  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
99  #endif 
100  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg);
101  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg);
102  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg);
103  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
104                                          nrf_pdm_mode_t pdm_mode,
105                                          nrf_pdm_edge_t pdm_edge);
106  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
107                                          nrf_pdm_mode_t *     p_pdm_mode,
108                                          nrf_pdm_edge_t *     p_pdm_edge);
109  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq);
<span onclick='openModal()' class='match'>110  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg);
111  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
112                                              uint32_t       psel_clk,
</span>113                                              uint32_t       psel_din);
114  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg);
115  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
116                                          nrf_pdm_gain_t gain_l,
117                                          nrf_pdm_gain_t gain_r);
118  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
119                                          nrf_pdm_gain_t *     p_gain_l,
120                                          nrf_pdm_gain_t *     p_gain_r);
121  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num);
122  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg);
123  #if NRF_PDM_HAS_RATIO_CONFIG
124  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio);
125  #endif
126  #if NRF_PDM_HAS_MCLKCONFIG
127  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc);
128  #endif
129  #ifndef NRF_DECLARE_ONLY
130  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
131  {
132      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
133  }
134  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg, nrf_pdm_task_t task)
135  {
136      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
137  }
138  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
141  }
142  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
143  {
144      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
145  #if __CORTEX_M == 0x04
146      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
147      (void)dummy;
148  #endif
149  }
150  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
151                                                       nrf_pdm_event_t      event)
152  {
153      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
154  }
155  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask)
160  {
161      return p_reg->INTENSET & mask;
162  }
163  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask)
164  {
165      p_reg->INTENCLR = mask;
166  }
167  #if defined(DPPI_PRESENT)
168  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
169                                               nrf_pdm_task_t task,
170                                               uint8_t        channel)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
173              ((uint32_t)channel | PDM_SUBSCRIBE_START_EN_Msk);
174  }
175  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
176  {
177      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
178  }
179  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
180                                             nrf_pdm_event_t event,
181                                             uint8_t         channel)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
184              ((uint32_t)channel | PDM_PUBLISH_STARTED_EN_Msk);
185  }
186  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
187  {
188      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
189  }
190  #endif 
191  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg)
192  {
193      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos);
194  }
195  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg)
196  {
197      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Disabled << PDM_ENABLE_ENABLE_Pos);
198  }
199  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg)
200  {
201      return (p_reg->ENABLE == (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos));
202  }
203  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
204                                          nrf_pdm_mode_t pdm_mode,
205                                          nrf_pdm_edge_t pdm_edge)
206  {
207      p_reg->MODE = ((pdm_mode << PDM_MODE_OPERATION_Pos) & PDM_MODE_OPERATION_Msk)
208                      | ((pdm_edge << PDM_MODE_EDGE_Pos) & PDM_MODE_EDGE_Msk);
209  }
210  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
211                                          nrf_pdm_mode_t * p_pdm_mode,
212                                          nrf_pdm_edge_t * p_pdm_edge)
213  {
214      uint32_t mode = p_reg->MODE;
215      *p_pdm_mode = (nrf_pdm_mode_t)((mode & PDM_MODE_OPERATION_Msk ) >> PDM_MODE_OPERATION_Pos);
216      *p_pdm_edge = (nrf_pdm_edge_t)((mode & PDM_MODE_EDGE_Msk ) >> PDM_MODE_EDGE_Pos);
217  }
218  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq)
219  {
220      p_reg->PDMCLKCTRL = ((pdm_freq << PDM_PDMCLKCTRL_FREQ_Pos) & PDM_PDMCLKCTRL_FREQ_Msk);
221  }
222  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg)
223  {
224       return (nrf_pdm_freq_t) ((p_reg->PDMCLKCTRL << PDM_PDMCLKCTRL_FREQ_Pos) &
225                                PDM_PDMCLKCTRL_FREQ_Msk);
226  }
227  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
228                                              uint32_t       psel_clk,
229                                              uint32_t       psel_din)
230  {
231      p_reg->PSEL.CLK = psel_clk;
232      p_reg->PSEL.DIN = psel_din;
233  }
234  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg)
235  {
236      p_reg->PSEL.CLK = ((PDM_PSEL_CLK_CONNECT_Disconnected << PDM_PSEL_CLK_CONNECT_Pos)
237                           & PDM_PSEL_CLK_CONNECT_Msk);
238      p_reg->PSEL.DIN = ((PDM_PSEL_DIN_CONNECT_Disconnected << PDM_PSEL_DIN_CONNECT_Pos)
239                           & PDM_PSEL_DIN_CONNECT_Msk);
240  }
241  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
242                                          nrf_pdm_gain_t gain_l,
243                                          nrf_pdm_gain_t gain_r)
244  {
245      p_reg->GAINL = gain_l;
246      p_reg->GAINR = gain_r;
247  }
248  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
249                                          nrf_pdm_gain_t *     p_gain_l,
250                                          nrf_pdm_gain_t *     p_gain_r)
251  {
252      *p_gain_l = p_reg->GAINL;
253      *p_gain_r = p_reg->GAINR;
254  }
255  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num)
256  {
257      p_reg->SAMPLE.PTR = (uint32_t)p_buffer;
258      p_reg->SAMPLE.MAXCNT = num;
259  }
260  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg)
261  {
262      return (uint32_t *)p_reg->SAMPLE.PTR;
263  }
264  #if NRF_PDM_HAS_RATIO_CONFIG
265  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio)
266  {
267      p_reg->RATIO = ratio;
268  }
269  #endif
270  #if NRF_PDM_HAS_MCLKCONFIG
271  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc)
272  {
273      p_reg->MCLKCONFIG = mclksrc;
274  }
275  #endif
276  #endif 
277  #ifdef __cplusplus
278  }
279  #endif
280  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</h3>
            <pre><code>1  #ifndef NRF_SAADC_H_
2  #define NRF_SAADC_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_SAADC_RESOLUTION_8BIT  = SAADC_RESOLUTION_VAL_8bit,  
10      NRF_SAADC_RESOLUTION_10BIT = SAADC_RESOLUTION_VAL_10bit, 
11      NRF_SAADC_RESOLUTION_12BIT = SAADC_RESOLUTION_VAL_12bit, 
12      NRF_SAADC_RESOLUTION_14BIT = SAADC_RESOLUTION_VAL_14bit  
13  } nrf_saadc_resolution_t;
14  typedef enum
15  {
16      NRF_SAADC_INPUT_DISABLED = SAADC_CH_PSELP_PSELP_NC,           
17      NRF_SAADC_INPUT_AIN0     = SAADC_CH_PSELP_PSELP_AnalogInput0, 
18      NRF_SAADC_INPUT_AIN1     = SAADC_CH_PSELP_PSELP_AnalogInput1, 
19      NRF_SAADC_INPUT_AIN2     = SAADC_CH_PSELP_PSELP_AnalogInput2, 
20      NRF_SAADC_INPUT_AIN3     = SAADC_CH_PSELP_PSELP_AnalogInput3, 
21      NRF_SAADC_INPUT_AIN4     = SAADC_CH_PSELP_PSELP_AnalogInput4, 
22      NRF_SAADC_INPUT_AIN5     = SAADC_CH_PSELP_PSELP_AnalogInput5, 
23      NRF_SAADC_INPUT_AIN6     = SAADC_CH_PSELP_PSELP_AnalogInput6, 
24      NRF_SAADC_INPUT_AIN7     = SAADC_CH_PSELP_PSELP_AnalogInput7, 
25      NRF_SAADC_INPUT_VDD      = SAADC_CH_PSELP_PSELP_VDD,          
26  #if defined(SAADC_CH_PSELP_PSELP_VDDHDIV5) || defined(__NRFX_DOXYGEN__)
27      NRF_SAADC_INPUT_VDDHDIV5 = SAADC_CH_PSELP_PSELP_VDDHDIV5      
28  #endif
29  } nrf_saadc_input_t;
30  typedef enum
31  {
32      NRF_SAADC_OVERSAMPLE_DISABLED = SAADC_OVERSAMPLE_OVERSAMPLE_Bypass,   
33      NRF_SAADC_OVERSAMPLE_2X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over2x,   
34      NRF_SAADC_OVERSAMPLE_4X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over4x,   
35      NRF_SAADC_OVERSAMPLE_8X       = SAADC_OVERSAMPLE_OVERSAMPLE_Over8x,   
36      NRF_SAADC_OVERSAMPLE_16X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over16x,  
37      NRF_SAADC_OVERSAMPLE_32X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over32x,  
38      NRF_SAADC_OVERSAMPLE_64X      = SAADC_OVERSAMPLE_OVERSAMPLE_Over64x,  
39      NRF_SAADC_OVERSAMPLE_128X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over128x, 
40      NRF_SAADC_OVERSAMPLE_256X     = SAADC_OVERSAMPLE_OVERSAMPLE_Over256x  
41  } nrf_saadc_oversample_t;
42  typedef enum
43  {
44      NRF_SAADC_RESISTOR_DISABLED = SAADC_CH_CONFIG_RESP_Bypass,   
45      NRF_SAADC_RESISTOR_PULLDOWN = SAADC_CH_CONFIG_RESP_Pulldown, 
46      NRF_SAADC_RESISTOR_PULLUP   = SAADC_CH_CONFIG_RESP_Pullup,   
47      NRF_SAADC_RESISTOR_VDD1_2   = SAADC_CH_CONFIG_RESP_VDD1_2    
48  } nrf_saadc_resistor_t;
49  typedef enum
50  {
51      NRF_SAADC_GAIN1_6 = SAADC_CH_CONFIG_GAIN_Gain1_6, 
52      NRF_SAADC_GAIN1_5 = SAADC_CH_CONFIG_GAIN_Gain1_5, 
53      NRF_SAADC_GAIN1_4 = SAADC_CH_CONFIG_GAIN_Gain1_4, 
54      NRF_SAADC_GAIN1_3 = SAADC_CH_CONFIG_GAIN_Gain1_3, 
55      NRF_SAADC_GAIN1_2 = SAADC_CH_CONFIG_GAIN_Gain1_2, 
56      NRF_SAADC_GAIN1   = SAADC_CH_CONFIG_GAIN_Gain1,   
57      NRF_SAADC_GAIN2   = SAADC_CH_CONFIG_GAIN_Gain2,   
58      NRF_SAADC_GAIN4   = SAADC_CH_CONFIG_GAIN_Gain4,   
59  } nrf_saadc_gain_t;
60  typedef enum
61  {
62      NRF_SAADC_REFERENCE_INTERNAL = SAADC_CH_CONFIG_REFSEL_Internal, 
63      NRF_SAADC_REFERENCE_VDD4     = SAADC_CH_CONFIG_REFSEL_VDD1_4    
64  } nrf_saadc_reference_t;
65  typedef enum
66  {
67      NRF_SAADC_ACQTIME_3US  = SAADC_CH_CONFIG_TACQ_3us,  
68      NRF_SAADC_ACQTIME_5US  = SAADC_CH_CONFIG_TACQ_5us,  
69      NRF_SAADC_ACQTIME_10US = SAADC_CH_CONFIG_TACQ_10us, 
70      NRF_SAADC_ACQTIME_15US = SAADC_CH_CONFIG_TACQ_15us, 
71      NRF_SAADC_ACQTIME_20US = SAADC_CH_CONFIG_TACQ_20us, 
72      NRF_SAADC_ACQTIME_40US = SAADC_CH_CONFIG_TACQ_40us  
73  } nrf_saadc_acqtime_t;
74  typedef enum
75  {
76      NRF_SAADC_MODE_SINGLE_ENDED = SAADC_CH_CONFIG_MODE_SE,  
77      NRF_SAADC_MODE_DIFFERENTIAL = SAADC_CH_CONFIG_MODE_Diff 
78  } nrf_saadc_mode_t;
79  typedef enum
80  {
81      NRF_SAADC_BURST_DISABLED = SAADC_CH_CONFIG_BURST_Disabled, 
82      NRF_SAADC_BURST_ENABLED  = SAADC_CH_CONFIG_BURST_Enabled   
83  } nrf_saadc_burst_t;
84  typedef enum
85  {
86      NRF_SAADC_TASK_START           = offsetof(NRF_SAADC_Type, TASKS_START),           
87      NRF_SAADC_TASK_SAMPLE          = offsetof(NRF_SAADC_Type, TASKS_SAMPLE),          
88      NRF_SAADC_TASK_STOP            = offsetof(NRF_SAADC_Type, TASKS_STOP),            
89      NRF_SAADC_TASK_CALIBRATEOFFSET = offsetof(NRF_SAADC_Type, TASKS_CALIBRATEOFFSET), 
90  } nrf_saadc_task_t;
91  typedef enum
92  {
93      NRF_SAADC_EVENT_STARTED       = offsetof(NRF_SAADC_Type, EVENTS_STARTED),       
94      NRF_SAADC_EVENT_END           = offsetof(NRF_SAADC_Type, EVENTS_END),           
95      NRF_SAADC_EVENT_DONE          = offsetof(NRF_SAADC_Type, EVENTS_DONE),          
96      NRF_SAADC_EVENT_RESULTDONE    = offsetof(NRF_SAADC_Type, EVENTS_RESULTDONE),    
97      NRF_SAADC_EVENT_CALIBRATEDONE = offsetof(NRF_SAADC_Type, EVENTS_CALIBRATEDONE), 
98      NRF_SAADC_EVENT_STOPPED       = offsetof(NRF_SAADC_Type, EVENTS_STOPPED),       
99      NRF_SAADC_EVENT_CH0_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITH),  
100      NRF_SAADC_EVENT_CH0_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[0].LIMITL),  
101      NRF_SAADC_EVENT_CH1_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITH),  
102      NRF_SAADC_EVENT_CH1_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[1].LIMITL),  
103      NRF_SAADC_EVENT_CH2_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITH),  
104      NRF_SAADC_EVENT_CH2_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[2].LIMITL),  
105      NRF_SAADC_EVENT_CH3_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITH),  
106      NRF_SAADC_EVENT_CH3_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[3].LIMITL),  
107      NRF_SAADC_EVENT_CH4_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITH),  
108      NRF_SAADC_EVENT_CH4_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[4].LIMITL),  
109      NRF_SAADC_EVENT_CH5_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITH),  
110      NRF_SAADC_EVENT_CH5_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[5].LIMITL),  
111      NRF_SAADC_EVENT_CH6_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITH),  
112      NRF_SAADC_EVENT_CH6_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[6].LIMITL),  
113      NRF_SAADC_EVENT_CH7_LIMITH    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITH),  
114      NRF_SAADC_EVENT_CH7_LIMITL    = offsetof(NRF_SAADC_Type, EVENTS_CH[7].LIMITL)   
115  } nrf_saadc_event_t;
116  typedef enum
117  {
118      NRF_SAADC_INT_STARTED       = SAADC_INTENSET_STARTED_Msk,       
119      NRF_SAADC_INT_END           = SAADC_INTENSET_END_Msk,           
120      NRF_SAADC_INT_DONE          = SAADC_INTENSET_DONE_Msk,          
121      NRF_SAADC_INT_RESULTDONE    = SAADC_INTENSET_RESULTDONE_Msk,    
122      NRF_SAADC_INT_CALIBRATEDONE = SAADC_INTENSET_CALIBRATEDONE_Msk, 
123      NRF_SAADC_INT_STOPPED       = SAADC_INTENSET_STOPPED_Msk,       
124      NRF_SAADC_INT_CH0LIMITH     = SAADC_INTENSET_CH0LIMITH_Msk,     
125      NRF_SAADC_INT_CH0LIMITL     = SAADC_INTENSET_CH0LIMITL_Msk,     
126      NRF_SAADC_INT_CH1LIMITH     = SAADC_INTENSET_CH1LIMITH_Msk,     
127      NRF_SAADC_INT_CH1LIMITL     = SAADC_INTENSET_CH1LIMITL_Msk,     
128      NRF_SAADC_INT_CH2LIMITH     = SAADC_INTENSET_CH2LIMITH_Msk,     
129      NRF_SAADC_INT_CH2LIMITL     = SAADC_INTENSET_CH2LIMITL_Msk,     
130      NRF_SAADC_INT_CH3LIMITH     = SAADC_INTENSET_CH3LIMITH_Msk,     
131      NRF_SAADC_INT_CH3LIMITL     = SAADC_INTENSET_CH3LIMITL_Msk,     
132      NRF_SAADC_INT_CH4LIMITH     = SAADC_INTENSET_CH4LIMITH_Msk,     
133      NRF_SAADC_INT_CH4LIMITL     = SAADC_INTENSET_CH4LIMITL_Msk,     
134      NRF_SAADC_INT_CH5LIMITH     = SAADC_INTENSET_CH5LIMITH_Msk,     
135      NRF_SAADC_INT_CH5LIMITL     = SAADC_INTENSET_CH5LIMITL_Msk,     
136      NRF_SAADC_INT_CH6LIMITH     = SAADC_INTENSET_CH6LIMITH_Msk,     
137      NRF_SAADC_INT_CH6LIMITL     = SAADC_INTENSET_CH6LIMITL_Msk,     
138      NRF_SAADC_INT_CH7LIMITH     = SAADC_INTENSET_CH7LIMITH_Msk,     
139      NRF_SAADC_INT_CH7LIMITL     = SAADC_INTENSET_CH7LIMITL_Msk,     
140      NRF_SAADC_INT_ALL           = 0x7FFFFFFFUL                      
141  } nrf_saadc_int_mask_t;
142  typedef enum
143  {
144      NRF_SAADC_LIMIT_LOW  = 0, 
145      NRF_SAADC_LIMIT_HIGH = 1  
146  } nrf_saadc_limit_t;
147  typedef int16_t nrf_saadc_value_t;
148  typedef struct
149  {
150      nrf_saadc_resolution_t resolution;  
151      nrf_saadc_oversample_t oversample;  
152      nrf_saadc_value_t *    buffer;      
153      uint32_t               buffer_size; 
154  } nrf_saadc_config_t;
155  typedef struct
156  {
157      nrf_saadc_resistor_t  resistor_p; 
158      nrf_saadc_resistor_t  resistor_n; 
159      nrf_saadc_gain_t      gain;       
160      nrf_saadc_reference_t reference;  
161      nrf_saadc_acqtime_t   acq_time;   
162      nrf_saadc_mode_t      mode;       
163      nrf_saadc_burst_t     burst;      
164  } nrf_saadc_channel_config_t;
165  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg,
166                                                nrf_saadc_task_t task);
167  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
168                                                        nrf_saadc_task_t       task);
169  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg,
170                                               nrf_saadc_event_t      event);
171  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type *  p_reg,
172                                               nrf_saadc_event_t event);
173  NRF_STATIC_INLINE uint32_t nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
174                                                         nrf_saadc_event_t      event);
175  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
176  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
177                                                 nrf_saadc_task_t task,
178                                                 uint8_t          channel);
179  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg,
180                                                   nrf_saadc_task_t task);
181  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
182                                               nrf_saadc_event_t event,
183                                               uint8_t           channel);
184  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type *  p_reg,
185                                                 nrf_saadc_event_t event);
186  #endif 
187  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
188                                                                nrf_saadc_limit_t limit_type);
189  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
190                                                     uint8_t           channel,
191                                                     nrf_saadc_input_t pselp,
192                                                     nrf_saadc_input_t pseln);
193  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
194                                                         uint8_t           channel,
195                                                         nrf_saadc_input_t pselp);
196  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
197                                                      uint8_t          channel,
198                                                      int16_t          low,
199                                                      int16_t          high);
200  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask);
201  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask);
202  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask);
203  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask);
204  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
205                                                     nrf_saadc_limit_t limit_type);
206  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg);
207  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg);
208  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg);
<span onclick='openModal()' class='match'>209  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg);
210  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
211                                               nrf_saadc_value_t * p_buffer,
</span>212                                               uint32_t            size);
213  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
214                                                      nrf_saadc_value_t * p_buffer);
215  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg);
216  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg);
217  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
218                                                  nrf_saadc_resolution_t resolution);
219  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg);
220  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
221                                                  nrf_saadc_oversample_t oversample);
222  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg);
223  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample);
224  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg,
225                                                          uint16_t         cc);
226  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg);
227  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg);
228  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
229                                                uint8_t                            channel,
230                                                nrf_saadc_channel_config_t const * config);
231  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
232                                             uint8_t           channel,
233                                             nrf_saadc_burst_t burst);
234  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution);
235  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution);
236  #ifndef NRF_DECLARE_ONLY
237  NRF_STATIC_INLINE void nrf_saadc_task_trigger(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
238  {
239      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
240  }
241  NRF_STATIC_INLINE uint32_t nrf_saadc_task_address_get(NRF_SAADC_Type const * p_reg,
242                                                        nrf_saadc_task_t       task)
243  {
244      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
245  }
246  NRF_STATIC_INLINE bool nrf_saadc_event_check(NRF_SAADC_Type const * p_reg, nrf_saadc_event_t event)
247  {
248      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
249  }
250  NRF_STATIC_INLINE void nrf_saadc_event_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
251  {
252      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
253  #if __CORTEX_M == 0x04
254      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
255      (void)dummy;
256  #endif
257  }
258  NRF_STATIC_INLINE uint32_t  nrf_saadc_event_address_get(NRF_SAADC_Type const * p_reg,
259                                                          nrf_saadc_event_t      event)
260  {
261      return (uint32_t )((uint8_t *)p_reg + (uint32_t)event);
262  }
263  #if defined(DPPI_PRESENT)
264  NRF_STATIC_INLINE void nrf_saadc_subscribe_set(NRF_SAADC_Type * p_reg,
265                                                 nrf_saadc_task_t task,
266                                                 uint8_t          channel)
267  {
268      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
269              ((uint32_t)channel | SAADC_SUBSCRIBE_START_EN_Msk);
270  }
271  NRF_STATIC_INLINE void nrf_saadc_subscribe_clear(NRF_SAADC_Type * p_reg, nrf_saadc_task_t task)
272  {
273      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
274  }
275  NRF_STATIC_INLINE void nrf_saadc_publish_set(NRF_SAADC_Type *  p_reg,
276                                               nrf_saadc_event_t event,
277                                               uint8_t           channel)
278  {
279      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
280              ((uint32_t)channel | SAADC_PUBLISH_STARTED_EN_Msk);
281  }
282  NRF_STATIC_INLINE void nrf_saadc_publish_clear(NRF_SAADC_Type * p_reg, nrf_saadc_event_t event)
283  {
284      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
285  }
286  #endif 
287  NRF_STATIC_INLINE nrf_saadc_event_t nrf_saadc_limit_event_get(uint8_t           channel,
288                                                                nrf_saadc_limit_t limit_type)
289  {
290      if (limit_type == NRF_SAADC_LIMIT_HIGH)
291      {
292          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITH);
293      }
294      else
295      {
296          return (nrf_saadc_event_t)NRFX_OFFSETOF(NRF_SAADC_Type, EVENTS_CH[channel].LIMITL);
297      }
298  }
299  NRF_STATIC_INLINE void nrf_saadc_channel_input_set(NRF_SAADC_Type *  p_reg,
300                                                     uint8_t           channel,
301                                                     nrf_saadc_input_t pselp,
302                                                     nrf_saadc_input_t pseln)
303  {
304      p_reg->CH[channel].PSELN = pseln;
305      p_reg->CH[channel].PSELP = pselp;
306  }
307  NRF_STATIC_INLINE void nrf_saadc_channel_pos_input_set(NRF_SAADC_Type *  p_reg,
308                                                         uint8_t           channel,
309                                                         nrf_saadc_input_t pselp)
310  {
311      p_reg->CH[channel].PSELP = pselp;
312  }
313  NRF_STATIC_INLINE void nrf_saadc_channel_limits_set(NRF_SAADC_Type * p_reg,
314                                                      uint8_t          channel,
315                                                      int16_t          low,
316                                                      int16_t          high)
317  {
318      p_reg->CH[channel].LIMIT = (
319              (((uint32_t) low << SAADC_CH_LIMIT_LOW_Pos) & SAADC_CH_LIMIT_LOW_Msk)
320            | (((uint32_t) high << SAADC_CH_LIMIT_HIGH_Pos) & SAADC_CH_LIMIT_HIGH_Msk));
321  }
322  NRF_STATIC_INLINE void nrf_saadc_int_set(NRF_SAADC_Type * p_reg, uint32_t mask)
323  {
324      p_reg->INTEN = mask;
325  }
326  NRF_STATIC_INLINE void nrf_saadc_int_enable(NRF_SAADC_Type * p_reg, uint32_t mask)
327  {
328      p_reg->INTENSET = mask;
329  }
330  NRF_STATIC_INLINE uint32_t nrf_saadc_int_enable_check(NRF_SAADC_Type const * p_reg, uint32_t mask)
331  {
332      return p_reg->INTENSET & mask;
333  }
334  NRF_STATIC_INLINE void nrf_saadc_int_disable(NRF_SAADC_Type * p_reg, uint32_t mask)
335  {
336      p_reg->INTENCLR = mask;
337  }
338  NRF_STATIC_INLINE uint32_t nrf_saadc_limit_int_get(uint8_t           channel,
339                                                     nrf_saadc_limit_t limit_type)
340  {
341      NRFX_ASSERT(channel < SAADC_CH_NUM);
342      uint32_t mask = (limit_type == NRF_SAADC_LIMIT_LOW) ?
343                       NRF_SAADC_INT_CH0LIMITL : NRF_SAADC_INT_CH0LIMITH;
344      return mask << (channel * 2);
345  }
346  NRF_STATIC_INLINE bool nrf_saadc_busy_check(NRF_SAADC_Type const * p_reg)
347  {
348      return (p_reg->STATUS == (SAADC_STATUS_STATUS_Busy << SAADC_STATUS_STATUS_Pos));
349  }
350  NRF_STATIC_INLINE void nrf_saadc_enable(NRF_SAADC_Type * p_reg)
351  {
352      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos);
353  }
354  NRF_STATIC_INLINE void nrf_saadc_disable(NRF_SAADC_Type * p_reg)
355  {
356      p_reg->ENABLE = (SAADC_ENABLE_ENABLE_Disabled << SAADC_ENABLE_ENABLE_Pos);
357  }
358  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg)
359  {
360      return (p_reg->ENABLE == (SAADC_ENABLE_ENABLE_Enabled << SAADC_ENABLE_ENABLE_Pos));
361  }
362  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
363                                               nrf_saadc_value_t * p_buffer,
364                                               uint32_t            size)
365  {
366      p_reg->RESULT.PTR = (uint32_t)p_buffer;
367      p_reg->RESULT.MAXCNT = size;
368  }
369  NRF_STATIC_INLINE void nrf_saadc_buffer_pointer_set(NRF_SAADC_Type *    p_reg,
370                                                      nrf_saadc_value_t * p_buffer)
371  {
372      p_reg->RESULT.PTR = (uint32_t)p_buffer;
373  }
374  NRF_STATIC_INLINE nrf_saadc_value_t * nrf_saadc_buffer_pointer_get(NRF_SAADC_Type const * p_reg)
375  {
376      return (nrf_saadc_value_t *)p_reg->RESULT.PTR;
377  }
378  NRF_STATIC_INLINE uint16_t nrf_saadc_amount_get(NRF_SAADC_Type const * p_reg)
379  {
380      return p_reg->RESULT.AMOUNT;
381  }
382  NRF_STATIC_INLINE void nrf_saadc_resolution_set(NRF_SAADC_Type *       p_reg,
383                                                  nrf_saadc_resolution_t resolution)
384  {
385      p_reg->RESOLUTION = resolution;
386  }
387  NRF_STATIC_INLINE nrf_saadc_resolution_t nrf_saadc_resolution_get(NRF_SAADC_Type const * p_reg)
388  {
389      return (nrf_saadc_resolution_t)p_reg->RESOLUTION;
390  }
391  NRF_STATIC_INLINE void nrf_saadc_oversample_set(NRF_SAADC_Type *       p_reg,
392                                                  nrf_saadc_oversample_t oversample)
393  {
394      p_reg->OVERSAMPLE = oversample;
395  }
396  NRF_STATIC_INLINE nrf_saadc_oversample_t nrf_saadc_oversample_get(NRF_SAADC_Type const * p_reg)
397  {
398      return (nrf_saadc_oversample_t)p_reg->OVERSAMPLE;
399  }
400  NRF_STATIC_INLINE uint32_t nrf_saadc_oversample_sample_count_get(nrf_saadc_oversample_t oversample)
401  {
402      return (1 << (uint32_t)oversample);
403  }
404  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_enable(NRF_SAADC_Type * p_reg, uint16_t cc)
405  {
406      NRFX_ASSERT((cc >= 80) && (cc <= 2047));
407      p_reg->SAMPLERATE = (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos)
408                          | ((uint32_t)cc << SAADC_SAMPLERATE_CC_Pos);
409  }
410  NRF_STATIC_INLINE bool nrf_saadc_continuous_mode_enable_check(NRF_SAADC_Type const * p_reg)
411  {
412      return (bool)((p_reg->SAMPLERATE & SAADC_SAMPLERATE_MODE_Msk)
413                     == (SAADC_SAMPLERATE_MODE_Timers << SAADC_SAMPLERATE_MODE_Pos));
414  }
415  NRF_STATIC_INLINE void nrf_saadc_continuous_mode_disable(NRF_SAADC_Type * p_reg)
416  {
417      p_reg->SAMPLERATE = SAADC_SAMPLERATE_MODE_Task << SAADC_SAMPLERATE_MODE_Pos;
418  }
419  NRF_STATIC_INLINE void nrf_saadc_channel_init(NRF_SAADC_Type *                   p_reg,
420                                                uint8_t                            channel,
421                                                nrf_saadc_channel_config_t const * config)
422  {
423      p_reg->CH[channel].CONFIG =
424              ((config->resistor_p   << SAADC_CH_CONFIG_RESP_Pos)   & SAADC_CH_CONFIG_RESP_Msk)
425              | ((config->resistor_n << SAADC_CH_CONFIG_RESN_Pos)   & SAADC_CH_CONFIG_RESN_Msk)
426              | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
427              | ((config->reference  << SAADC_CH_CONFIG_REFSEL_Pos) & SAADC_CH_CONFIG_REFSEL_Msk)
428              | ((config->acq_time   << SAADC_CH_CONFIG_TACQ_Pos)   & SAADC_CH_CONFIG_TACQ_Msk)
429              | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk)
430              | ((config->burst      << SAADC_CH_CONFIG_BURST_Pos)  & SAADC_CH_CONFIG_BURST_Msk);
431  }
432  NRF_STATIC_INLINE void nrf_saadc_burst_set(NRF_SAADC_Type *  p_reg,
433                                             uint8_t           channel,
434                                             nrf_saadc_burst_t burst)
435  {
436      p_reg->CH[channel].CONFIG = (p_reg->CH[channel].CONFIG & ~SAADC_CH_CONFIG_BURST_Msk) |
437                                  (burst << SAADC_CH_CONFIG_BURST_Pos);
438  }
439  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_min_get(nrf_saadc_resolution_t resolution)
440  {
441      uint8_t res_bits = 0;
442      switch (resolution)
443      {
444          case NRF_SAADC_RESOLUTION_8BIT:
445              res_bits = 8;
446              break;
447          case NRF_SAADC_RESOLUTION_10BIT:
448              res_bits = 10;
449              break;
450          case NRF_SAADC_RESOLUTION_12BIT:
451              res_bits = 12;
452              break;
453          case NRF_SAADC_RESOLUTION_14BIT:
454              res_bits = 14;
455              break;
456          default:
457              NRFX_ASSERT(false);
458      }
459      return (nrf_saadc_value_t)(-(1 << res_bits));
460  }
461  NRF_STATIC_INLINE nrf_saadc_value_t nrf_saadc_value_max_get(nrf_saadc_resolution_t resolution)
462  {
463      uint8_t res_bits = 0;
464      switch (resolution)
465      {
466          case NRF_SAADC_RESOLUTION_8BIT:
467              res_bits = 8;
468              break;
469          case NRF_SAADC_RESOLUTION_10BIT:
470              res_bits = 10;
471              break;
472          case NRF_SAADC_RESOLUTION_12BIT:
473              res_bits = 12;
474              break;
475          case NRF_SAADC_RESOLUTION_14BIT:
476              res_bits = 14;
477              break;
478          default:
479              NRFX_ASSERT(false);
480      }
481      return (nrf_saadc_value_t)((1 << res_bits) - 1);
482  }
483  #endif 
484  #ifdef __cplusplus
485  }
486  #endif
487  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_saadc.h</div>
                </div>
                <div class="column column_space"><pre><code>110  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg);
111  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
112                                              uint32_t       psel_clk,
</pre></code></div>
                <div class="column column_space"><pre><code>209  NRF_STATIC_INLINE bool nrf_saadc_enable_check(NRF_SAADC_Type const * p_reg);
210  NRF_STATIC_INLINE void nrf_saadc_buffer_init(NRF_SAADC_Type *    p_reg,
211                                               nrf_saadc_value_t * p_buffer,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    