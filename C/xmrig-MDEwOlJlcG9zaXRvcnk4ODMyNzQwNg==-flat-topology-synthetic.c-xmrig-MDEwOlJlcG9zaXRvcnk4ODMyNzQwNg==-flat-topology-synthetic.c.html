
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/misc.h"
5  #include "private/debug.h"
6  #include <limits.h>
7  #include <assert.h>
8  #ifdef HAVE_STRINGS_H
9  #include <strings.h>
10  #endif
11  struct hwloc_synthetic_attr_s {
12    hwloc_obj_type_t type;
13    unsigned depth; &bsol;* For caches/groups */
14    hwloc_obj_cache_type_t cachetype; &bsol;* For caches */
15    hwloc_uint64_t memorysize; &bsol;* For caches/memory */
16  };
17  struct hwloc_synthetic_indexes_s {
18    const char *string;
19    unsigned long string_length;
20    unsigned *array;
21    unsigned next; &bsol;* id of the next object for that level */
22  };
23  struct hwloc_synthetic_level_data_s {
24    unsigned arity;
25    unsigned long totalwidth;
26    struct hwloc_synthetic_attr_s attr;
27    struct hwloc_synthetic_indexes_s indexes;
28    struct hwloc_synthetic_attached_s {
29      struct hwloc_synthetic_attr_s attr;
30      struct hwloc_synthetic_attached_s *next;
31    } *attached;
32  };
33  struct hwloc_synthetic_backend_data_s {
34    char *string;
35    unsigned long numa_attached_nr;
36    struct hwloc_synthetic_indexes_s numa_attached_indexes;
37  #define HWLOC_SYNTHETIC_MAX_DEPTH 128
38    struct hwloc_synthetic_level_data_s level[HWLOC_SYNTHETIC_MAX_DEPTH];
39  };
40  struct hwloc_synthetic_intlv_loop_s {
41    unsigned step;
42    unsigned nb;
43    unsigned level_depth;
44  };
45  static void
46  hwloc_synthetic_process_indexes(struct hwloc_synthetic_backend_data_s *data,
47  				struct hwloc_synthetic_indexes_s *indexes,
48  				unsigned long total,
49  				int verbose)
50  {
51    const char *attr = indexes->string;
52    unsigned long length = indexes->string_length;
53    unsigned *array = NULL;
54    size_t i;
55    if (!attr)
56      return;
57    array = calloc(total, sizeof(*array));
58    if (!array) {
59      if (verbose)
60        fprintf(stderr, "Failed to allocate synthetic index array of size %lu\n", total);
61      goto out;
62    }
63    i = strspn(attr, "0123456789,");
64    if (i == length) {
65      for(i=0; i<total; i++) {
66        const char *next;
67        unsigned idx = strtoul(attr, (char **) &next, 10);
68        if (next == attr) {
69  	if (verbose)
70  	  fprintf(stderr, "Failed to read synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
71  	goto out_with_array;
72        }
73        array[i] = idx;
74        if (i != total-1) {
75  	if (*next != ',') {
76  	  if (verbose)
77  	    fprintf(stderr, "Missing comma after synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
78  	  goto out_with_array;
79  	}
80  	attr = next+1;
81        } else {
82  	attr = next;
83        }
84      }
85      indexes->array = array;
86    } else {
87      unsigned nr_loops = 1, cur_loop;
88      unsigned minstep = total;
89      unsigned long nbs = 1;
90      unsigned j, mul;
91      const char *tmp;
92      struct hwloc_synthetic_intlv_loop_s *loops;
93      tmp = attr;
94      while (tmp) {
95        tmp = strchr(tmp, ':');
96        if (!tmp || tmp >= attr+length)
97  	break;
98        nr_loops++;
99        tmp++;
100      }
101      loops = malloc((nr_loops+1) * sizeof(*loops));
102      if (!loops)
103        goto out_with_array;
104      if (*attr >= '0' && *attr <= '9') {
105        unsigned step, nb;
106        tmp = attr;
107        cur_loop = 0;
108        while (tmp) {
109  	char *tmp2, *tmp3;
110  	step = (unsigned) strtol(tmp, &tmp2, 0);
111  	if (tmp2 == tmp || *tmp2 != '*') {
112  	  if (verbose)
113  	    fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number before '*'\n", tmp);
114  	  free(loops);
115  	  goto out_with_array;
116  	}
117  	if (!step) {
118  	  if (verbose)
119  	    fprintf(stderr, "Invalid interleaving loop with step 0 at '%s'\n", tmp);
120  	  free(loops);
121  	  goto out_with_array;
122  	}
123  	tmp2++;
124  	nb = (unsigned) strtol(tmp2, &tmp3, 0);
125  	if (tmp3 == tmp2 || (*tmp3 && *tmp3 != ':' && *tmp3 != ')' && *tmp3 != ' ')) {
126  	  if (verbose)
127  	    fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number between '*' and ':'\n", tmp);
128  	  free(loops);
129  	  goto out_with_array;
130  	}
131  	if (!nb) {
132  	  if (verbose)
133  	    fprintf(stderr, "Invalid interleaving loop with number 0 at '%s'\n", tmp2);
134  	  free(loops);
135  	  goto out_with_array;
136  	}
137  	loops[cur_loop].step = step;
138  	loops[cur_loop].nb = nb;
139  	if (step < minstep)
140  	  minstep = step;
141  	nbs *= nb;
142  	cur_loop++;
143  	if (*tmp3 == ')' || *tmp3 == ' ')
144  	  break;
145  	tmp = (const char*) (tmp3+1);
146        }
147      } else {
148        hwloc_obj_type_t type;
149        union hwloc_obj_attr_u attrs;
150        int err;
151        tmp = attr;
152        cur_loop = 0;
153        while (tmp) {
154  	err = hwloc_type_sscanf(tmp, &type, &attrs, sizeof(attrs));
155  	if (err < 0) {
156  	  if (verbose)
157  	    fprintf(stderr, "Failed to read synthetic index interleaving loop type '%s'\n", tmp);
158  	  free(loops);
159  	  goto out_with_array;
160  	}
161  	if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
162  	  if (verbose)
163  	    fprintf(stderr, "Misc object type disallowed in synthetic index interleaving loop type '%s'\n", tmp);
164  	  free(loops);
165  	  goto out_with_array;
166  	}
167  	for(i=0; ; i++) {
168  	  if (!data->level[i].arity) {
169  	    loops[cur_loop].level_depth = (unsigned)-1;
170  	    break;
171  	  }
172  	  if (type != data->level[i].attr.type)
173  	    continue;
174  	  if (type == HWLOC_OBJ_GROUP
175  	      && attrs.group.depth != (unsigned) -1
176  	      && attrs.group.depth != data->level[i].attr.depth)
177  	    continue;
178  	  loops[cur_loop].level_depth = (unsigned)i;
179  	  break;
180  	}
181  	if (loops[cur_loop].level_depth == (unsigned)-1) {
182  	  if (verbose)
183  	    fprintf(stderr, "Failed to find level for synthetic index interleaving loop type '%s'\n",
184  		    tmp);
185  	  free(loops);
186  	  goto out_with_array;
187  	}
188  	tmp = strchr(tmp, ':');
189  	if (!tmp || tmp > attr+length)
190  	  break;
191  	tmp++;
192  	cur_loop++;
193        }
194        for(cur_loop=0; cur_loop<nr_loops; cur_loop++) {
195  	unsigned mydepth = loops[cur_loop].level_depth;
196  	unsigned prevdepth = 0;
197  	unsigned step, nb;
198  	for(i=0; i<nr_loops; i++) {
199  	  if (loops[i].level_depth == mydepth && i != cur_loop) {
200  	    if (verbose)
201  	      fprintf(stderr, "Invalid duplicate interleaving loop type in synthetic index '%s'\n", attr);
202  	    free(loops);
203  	    goto out_with_array;
204  	  }
205  	  if (loops[i].level_depth < mydepth
206  	      && loops[i].level_depth > prevdepth)
207  	    prevdepth = loops[i].level_depth;
208  	}
209  	step = total / data->level[mydepth].totalwidth; &bsol;* number of objects below us */
210  	nb = data->level[mydepth].totalwidth / data->level[prevdepth].totalwidth; &bsol;* number of us within parent */
211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
214  	assert(step);
215  	if (step < minstep)
216  	  minstep = step;
217  	nbs *= nb;
218        }
219      }
220      assert(nbs);
221      if (nbs != total) {
222        if (minstep == total/nbs) {
223  	loops[nr_loops].step = 1;
224  	loops[nr_loops].nb = total/nbs;
225  	nr_loops++;
226        } else {
227  	if (verbose)
228  	  fprintf(stderr, "Invalid index interleaving total width %lu instead of %lu\n", nbs, total);
229  	free(loops);
230  	goto out_with_array;
231        }
232      }
233      mul = 1;
234      for(i=0; i<nr_loops; i++) {
235        unsigned step = loops[i].step;
236        unsigned nb = loops[i].nb;
237        for(j=0; j<total; j++)
238  	array[j] += ((j / step) % nb) * mul;
239        mul *= nb;
240      }
241      free(loops);
242      for(j=0; j<total; j++) {
243        if (array[j] >= total) {
244  	if (verbose)
245  	  fprintf(stderr, "Invalid index interleaving generates out-of-range index %u\n", array[j]);
246  	goto out_with_array;
247        }
248        if (!array[j] && j) {
249  	if (verbose)
250  	  fprintf(stderr, "Invalid index interleaving generates duplicate index values\n");
251  	goto out_with_array;
252        }
253      }
254      indexes->array = array;
255    }
256    return;
257   out_with_array:
258    free(array);
259   out:
260    return;
261  }
262  static hwloc_uint64_t
263  hwloc_synthetic_parse_memory_attr(const char *attr, const char **endp)
264  {
265    const char *endptr;
266    hwloc_uint64_t size;
267    size = strtoull(attr, (char **) &endptr, 0);
268    if (!hwloc_strncasecmp(endptr, "TB", 2)) {
269      size *= 1000ULL*1000ULL*1000ULL*1000ULL;
270      endptr += 2;
271    } else if (!hwloc_strncasecmp(endptr, "TiB", 3)) {
272      size <<= 40;
<span onclick='openModal()' class='match'>273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, "GB", 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
</span>276      endptr += 2;
277    } else if (!hwloc_strncasecmp(endptr, "GiB", 3)) {
278      size <<= 30;
279      endptr += 3;
280    } else if (!hwloc_strncasecmp(endptr, "MB", 2)) {
281      size *= 1000ULL*1000ULL;
282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, "MiB", 3)) {
284      size <<= 20;
285      endptr += 3;
286    } else if (!hwloc_strncasecmp(endptr, "kB", 2)) {
287      size *= 1000ULL;
288      endptr += 2;
289    } else if (!hwloc_strncasecmp(endptr, "kiB", 3)) {
290      size <<= 10;
291      endptr += 3;
292    }
293    *endp = endptr;
294    return size;
295  }
296  static int
297  hwloc_synthetic_parse_attrs(const char *attrs, const char **next_posp,
298  			    struct hwloc_synthetic_attr_s *sattr,
299  			    struct hwloc_synthetic_indexes_s *sind,
300  			    int verbose)
301  {
302    hwloc_obj_type_t type = sattr->type;
303    const char *next_pos;
304    hwloc_uint64_t memorysize = 0;
305    const char *index_string = NULL;
306    size_t index_string_length = 0;
307    next_pos = (const char *) strchr(attrs, ')');
308    if (!next_pos) {
309      if (verbose)
310        fprintf(stderr, "Missing attribute closing bracket in synthetic string doesn't have a number of objects at '%s'\n", attrs);
311      errno = EINVAL;
312      return -1;
313    }
314    while (')' != *attrs) {
315      int iscache = hwloc__obj_type_is_cache(type);
316      if (iscache && !strncmp("size=", attrs, 5)) {
317        memorysize = hwloc_synthetic_parse_memory_attr(attrs+5, &attrs);
318      } else if (!iscache && !strncmp("memory=", attrs, 7)) {
319        memorysize = hwloc_synthetic_parse_memory_attr(attrs+7, &attrs);
320      } else if (!strncmp("indexes=", attrs, 8)) {
321        index_string = attrs+8;
322        attrs += 8;
323        index_string_length = strcspn(attrs, " )");
324        attrs += index_string_length;
325      } else {
326        if (verbose)
327  	fprintf(stderr, "Unknown attribute at '%s'\n", attrs);
328        errno = EINVAL;
329        return -1;
330      }
331      if (' ' == *attrs)
332        attrs++;
333      else if (')' != *attrs) {
334        if (verbose)
335  	fprintf(stderr, "Missing parameter separator at '%s'\n", attrs);
336        errno = EINVAL;
337        return -1;
338      }
339    }
340    sattr->memorysize = memorysize;
341    if (index_string) {
342      if (sind->string && verbose)
343        fprintf(stderr, "Overwriting duplicate indexes attribute with last occurence\n");
344      sind->string = index_string;
345      sind->string_length = (unsigned long)index_string_length;
346    }
347    *next_posp = next_pos+1;
348    return 0;
349  }
350  static void
351  hwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)
352  {
353    unsigned i;
354    for(i=0; i<HWLOC_SYNTHETIC_MAX_DEPTH; i++) {
355      struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];
356      struct hwloc_synthetic_attached_s **pprev = &curlevel->attached;
357      while (*pprev) {
358        struct hwloc_synthetic_attached_s *cur = *pprev;
359        *pprev = cur->next;
360        free(cur);
361      }
362      free(curlevel->indexes.array);
363      if (!curlevel->arity)
364        break;
365    }
366    free(data->numa_attached_indexes.array);
367  }
368  static int
369  hwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,
370  			     const char *description)
371  {
372    const char *pos, *next_pos;
373    unsigned long item, count;
374    unsigned i;
375    int type_count[HWLOC_OBJ_TYPE_MAX];
376    unsigned unset;
377    int verbose = 0;
378    const char *env = getenv("HWLOC_SYNTHETIC_VERBOSE");
379    int err;
380    unsigned long totalarity = 1;
381    if (env)
382      verbose = atoi(env);
383    data->numa_attached_nr = 0;
384    data->numa_attached_indexes.array = NULL;
385    data->level[0].totalwidth = 1;
386    data->level[0].attr.type = HWLOC_OBJ_MACHINE;
387    data->level[0].indexes.string = NULL;
388    data->level[0].indexes.array = NULL;
389    data->level[0].attr.memorysize = 0;
390    data->level[0].attached = NULL;
391    type_count[HWLOC_OBJ_MACHINE] = 1;
392    if (*description == '(') {
393      err = hwloc_synthetic_parse_attrs(description+1, &description, &data->level[0].attr, &data->level[0].indexes, verbose);
394      if (err < 0)
395        return err;
396    }
397    data->numa_attached_indexes.string = NULL;
398    data->numa_attached_indexes.array = NULL;
399    for (pos = description, count = 1; *pos; pos = next_pos) {
400      hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;
401      union hwloc_obj_attr_u attrs;
402      data->level[count-1].arity = 0;
403      while (*pos == ' ' || *pos == '\n')
404        pos++;
405      if (!*pos)
406        break;
407      if (*pos == '[') {
408        struct hwloc_synthetic_attached_s *attached, **pprev;
409        char *attr;
410        pos++;
411        if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {
412  	if (verbose)
413  	  fprintf(stderr, "Synthetic string with unknown attached object type at '%s'\n", pos);
414  	errno = EINVAL;
415  	goto error;
416        }
417        if (type != HWLOC_OBJ_NUMANODE) {
418  	if (verbose)
419  	  fprintf(stderr, "Synthetic string with disallowed attached object type at '%s'\n", pos);
420  	errno = EINVAL;
421  	goto error;
422        }
423        data->numa_attached_nr += data->level[count-1].totalwidth;
424        attached = malloc(sizeof(*attached));
425        if (attached) {
426  	attached->attr.type = type;
427  	attached->attr.memorysize = 0;
428  	attached->next = NULL;
429  	pprev = &data->level[count-1].attached;
430  	while (*pprev)
431  	  pprev = &((*pprev)->next);
432  	*pprev = attached;
433        }
434        next_pos = strchr(pos, ']');
435        if (!next_pos) {
436  	if (verbose)
437  	  fprintf(stderr,"Synthetic string doesn't have a closing `]' after attached object type at '%s'\n", pos);
438  	errno = EINVAL;
439  	goto error;
440        }
441        attr = strchr(pos, '(');
442        if (attr && attr < next_pos && attached) {
443  	const char *dummy;
444  	err = hwloc_synthetic_parse_attrs(attr+1, &dummy, &attached->attr, &data->numa_attached_indexes, verbose);
445  	if (err < 0)
446  	  goto error;
447        }
448        next_pos++;
449        continue;
450      }
451      data->level[count].indexes.string = NULL;
452      data->level[count].indexes.array = NULL;
453      data->level[count].attached = NULL;
454      if (*pos < '0' || *pos > '9') {
455        if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {
456  	if (!strncmp(pos, "Tile", 4) || !strncmp(pos, "Module", 6)) {
457  	  type = HWLOC_OBJ_GROUP;
458  	} else {
459  	  if (verbose)
460  	    fprintf(stderr, "Synthetic string with unknown object type at '%s'\n", pos);
461  	  errno = EINVAL;
462  	  goto error;
463  	}
464        }
465        if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
466  	if (verbose)
467  	  fprintf(stderr, "Synthetic string with disallowed object type at '%s'\n", pos);
468  	errno = EINVAL;
469  	goto error;
470        }
471        next_pos = strchr(pos, ':');
472        if (!next_pos) {
473  	if (verbose)
474  	  fprintf(stderr,"Synthetic string doesn't have a `:' after object type at '%s'\n", pos);
475  	errno = EINVAL;
476  	goto error;
477        }
478        pos = next_pos + 1;
479      }
480      data->level[count].attr.type = type;
481      data->level[count].attr.depth = (unsigned) -1;
482      data->level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;
483      if (hwloc__obj_type_is_cache(type)) {
484        data->level[count].attr.depth = attrs.cache.depth;
485        data->level[count].attr.cachetype = attrs.cache.type;
486      } else if (type == HWLOC_OBJ_GROUP) {
487        data->level[count].attr.depth = attrs.group.depth;
488      }
489      item = strtoul(pos, (char **)&next_pos, 0);
490      if (next_pos == pos) {
491        if (verbose)
492  	fprintf(stderr,"Synthetic string doesn't have a number of objects at '%s'\n", pos);
493        errno = EINVAL;
494        goto error;
495      }
496      if (!item) {
497        if (verbose)
498  	fprintf(stderr,"Synthetic string with disallow 0 number of objects at '%s'\n", pos);
499        errno = EINVAL;
500        goto error;
501      }
502      totalarity *= item;
503      data->level[count].totalwidth = totalarity;
504      data->level[count].indexes.string = NULL;
505      data->level[count].indexes.array = NULL;
506      data->level[count].attr.memorysize = 0;
507      if (*next_pos == '(') {
508        err = hwloc_synthetic_parse_attrs(next_pos+1, &next_pos, &data->level[count].attr, &data->level[count].indexes, verbose);
509        if (err < 0)
510  	goto error;
511      }
512      if (count + 1 >= HWLOC_SYNTHETIC_MAX_DEPTH) {
513        if (verbose)
514  	fprintf(stderr,"Too many synthetic levels, max %d\n", HWLOC_SYNTHETIC_MAX_DEPTH);
515        errno = EINVAL;
516        goto error;
517      }
518      if (item > UINT_MAX) {
519        if (verbose)
520  	fprintf(stderr,"Too big arity, max %u\n", UINT_MAX);
521        errno = EINVAL;
522        goto error;
523      }
524      data->level[count-1].arity = (unsigned)item;
525      count++;
526    }
527    if (data->level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE && data->level[count-1].attr.type != HWLOC_OBJ_PU) {
528      if (verbose)
529        fprintf(stderr, "Synthetic string cannot use non-PU type for last level\n");
530      errno = EINVAL;
531      return -1;
532    }
533    data->level[count-1].attr.type = HWLOC_OBJ_PU;
534    for(i=HWLOC_OBJ_TYPE_MIN; i<HWLOC_OBJ_TYPE_MAX; i++) {
535      type_count[i] = 0;
536    }
537    for(i=count-1; i>0; i--) {
538      hwloc_obj_type_t type = data->level[i].attr.type;
539      if (type != HWLOC_OBJ_TYPE_NONE) {
540        type_count[type]++;
541      }
542    }
543    if (!type_count[HWLOC_OBJ_PU]) {
544      if (verbose)
545        fprintf(stderr, "Synthetic string missing ending number of PUs\n");
546      errno = EINVAL;
547      return -1;
548    } else if (type_count[HWLOC_OBJ_PU] > 1) {
549      if (verbose)
550        fprintf(stderr, "Synthetic string cannot have several PU levels\n");
551      errno = EINVAL;
552      return -1;
553    }
554    if (type_count[HWLOC_OBJ_PACKAGE] > 1) {
555      if (verbose)
556        fprintf(stderr, "Synthetic string cannot have several package levels\n");
557      errno = EINVAL;
558      return -1;
559    }
560    if (type_count[HWLOC_OBJ_DIE] > 1) {
561      if (verbose)
562        fprintf(stderr, "Synthetic string cannot have several die levels\n");
563      errno = EINVAL;
564      return -1;
565    }
566    if (type_count[HWLOC_OBJ_NUMANODE] > 1) {
567      if (verbose)
568        fprintf(stderr, "Synthetic string cannot have several NUMA node levels\n");
569      errno = EINVAL;
570      return -1;
571    }
572    if (type_count[HWLOC_OBJ_NUMANODE] && data->numa_attached_nr) {
573      if (verbose)
574        fprintf(stderr,"Synthetic string cannot have NUMA nodes both as a level and attached\n");
575      errno = EINVAL;
576      return -1;
577    }
578    if (type_count[HWLOC_OBJ_CORE] > 1) {
579      if (verbose)
580        fprintf(stderr, "Synthetic string cannot have several core levels\n");
581      errno = EINVAL;
582      return -1;
583    }
584    unset = 0;
585    for(i=1; i<count-1; i++) {
586      if (data->level[i].attr.type == HWLOC_OBJ_TYPE_NONE)
587        unset++;
588    }
589    if (unset && unset != count-2) {
590      if (verbose)
591        fprintf(stderr, "Synthetic string cannot mix unspecified and specified types for levels\n");
592      errno = EINVAL;
593      return -1;
594    }
595    if (unset) {
596      unsigned _count = count;
597      unsigned neednuma = 0;
598      unsigned needpack = 0;
599      unsigned needcore = 0;
600      unsigned needcaches = 0;
601      unsigned needgroups = 0;
602      _count -= 2;
603      neednuma = (_count >= 1 && !data->numa_attached_nr);
604      _count -= neednuma;
605      needpack = (_count >= 1);
606      _count -= needpack;
607      needcore = (_count >= 1);
608      _count -= needcore;
609      needcaches = (_count > 4 ? 4 : _count);
610      _count -= needcaches;
611      needgroups = _count;
612      for(i = 0; i < needgroups; i++) {
613        unsigned depth = 1 + i;
614        data->level[depth].attr.type = HWLOC_OBJ_GROUP;
615        type_count[HWLOC_OBJ_GROUP]++;
616      }
617      if (needpack) {
618        unsigned depth = 1 + needgroups;
619        data->level[depth].attr.type = HWLOC_OBJ_PACKAGE;
620        type_count[HWLOC_OBJ_PACKAGE] = 1;
621      }
622      if (neednuma) {
623        unsigned depth = 1 + needgroups + needpack;
624        data->level[depth].attr.type = HWLOC_OBJ_NUMANODE;
625        type_count[HWLOC_OBJ_NUMANODE] = 1;
626      }
627      if (needcaches) {
628        unsigned l3depth = 1 + needgroups + needpack + neednuma;
629        unsigned l2depth = l3depth + (needcaches >= 3);
630        unsigned l1depth = l2depth + 1;
631        unsigned l1idepth = l1depth + 1;
632        if (needcaches >= 3) {
633  	data->level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;
634  	data->level[l3depth].attr.depth = 3;
635  	data->level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
636  	type_count[HWLOC_OBJ_L3CACHE] = 1;
637        }
638        data->level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;
639        data->level[l2depth].attr.depth = 2;
640        data->level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
641        type_count[HWLOC_OBJ_L2CACHE] = 1;
642        if (needcaches >= 2) {
643  	data->level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;
644  	data->level[l1depth].attr.depth = 1;
645  	data->level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;
646  	type_count[HWLOC_OBJ_L1CACHE] = 1;
647        }
648        if (needcaches >= 4) {
649  	data->level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;
650  	data->level[l1idepth].attr.depth = 1;
651  	data->level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;
652  	type_count[HWLOC_OBJ_L1ICACHE] = 1;
653        }
654      }
655      if (needcore) {
656        unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;
657        data->level[depth].attr.type = HWLOC_OBJ_CORE;
658        type_count[HWLOC_OBJ_CORE] = 1;
659      }
660    }
661    if (!type_count[HWLOC_OBJ_NUMANODE] && !data->numa_attached_nr) {
662      if (verbose)
663        fprintf(stderr, "Inserting a NUMA level with a single object at depth 1\n");
664      memmove(&data->level[2], &data->level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
665      data->level[1].attr.type = HWLOC_OBJ_NUMANODE;
666      data->level[1].indexes.string = NULL;
667      data->level[1].indexes.array = NULL;
668      data->level[1].attr.memorysize = 0;
669      data->level[1].totalwidth = data->level[0].totalwidth;
670      data->level[1].arity = data->level[0].arity;
671      data->level[0].arity = 1;
672      count++;
673    }
674    for (i=0; i<count; i++) {
675      struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];
676      hwloc_obj_type_t type = curlevel->attr.type;
677      if (type == HWLOC_OBJ_GROUP) {
678        if (curlevel->attr.depth == (unsigned)-1)
679  	curlevel->attr.depth = type_count[HWLOC_OBJ_GROUP]--;
680      } else if (hwloc__obj_type_is_cache(type)) {
681        if (!curlevel->attr.memorysize) {
682  	if (1 == curlevel->attr.depth)
683  	  curlevel->attr.memorysize = 32*1024;
684  	else
685  	  curlevel->attr.memorysize = 256ULL*1024 << (2*curlevel->attr.depth);
686        }
687      } else if (type == HWLOC_OBJ_NUMANODE && !curlevel->attr.memorysize) {
688        curlevel->attr.memorysize = 1024*1024*1024;
689      }
690      hwloc_synthetic_process_indexes(data, &data->level[i].indexes, data->level[i].totalwidth, verbose);
691    }
692    hwloc_synthetic_process_indexes(data, &data->numa_attached_indexes, data->numa_attached_nr, verbose);
693    data->string = strdup(description);
694    data->level[count-1].arity = 0;
695    return 0;
696   error:
697    hwloc_synthetic_free_levels(data);
698    return -1;
699  }
700  static void
701  hwloc_synthetic_set_attr(struct hwloc_synthetic_attr_s *sattr,
702  			 hwloc_obj_t obj)
703  {
704    switch (obj->type) {
705    case HWLOC_OBJ_GROUP:
706      obj->attr->group.kind = HWLOC_GROUP_KIND_SYNTHETIC;
707      obj->attr->group.subkind = sattr->depth-1;
708      break;
709    case HWLOC_OBJ_MACHINE:
710      break;
711    case HWLOC_OBJ_NUMANODE:
712      obj->attr->numanode.local_memory = sattr->memorysize;
713      obj->attr->numanode.page_types_len = 1;
714      obj->attr->numanode.page_types = malloc(sizeof(*obj->attr->numanode.page_types));
715      memset(obj->attr->numanode.page_types, 0, sizeof(*obj->attr->numanode.page_types));
716      obj->attr->numanode.page_types[0].size = 4096;
717      obj->attr->numanode.page_types[0].count = sattr->memorysize / 4096;
718      break;
719    case HWLOC_OBJ_PACKAGE:
720    case HWLOC_OBJ_DIE:
721      break;
722    case HWLOC_OBJ_L1CACHE:
723    case HWLOC_OBJ_L2CACHE:
724    case HWLOC_OBJ_L3CACHE:
725    case HWLOC_OBJ_L4CACHE:
726    case HWLOC_OBJ_L5CACHE:
727    case HWLOC_OBJ_L1ICACHE:
728    case HWLOC_OBJ_L2ICACHE:
729    case HWLOC_OBJ_L3ICACHE:
730      obj->attr->cache.depth = sattr->depth;
731      obj->attr->cache.linesize = 64;
732      obj->attr->cache.type = sattr->cachetype;
733      obj->attr->cache.size = sattr->memorysize;
734      break;
735    case HWLOC_OBJ_CORE:
736      break;
737    case HWLOC_OBJ_PU:
738      break;
739    default:
740      assert(0);
741      break;
742    }
743  }
744  static unsigned
745  hwloc_synthetic_next_index(struct hwloc_synthetic_indexes_s *indexes, hwloc_obj_type_t type)
746  {
747    unsigned os_index = indexes->next++;
748    if (indexes->array)
749      os_index = indexes->array[os_index];
750    else if (hwloc__obj_type_is_cache(type) || type == HWLOC_OBJ_GROUP)
751      os_index = HWLOC_UNKNOWN_INDEX;
752    return os_index;
753  }
754  static void
755  hwloc_synthetic_insert_attached(struct hwloc_topology *topology,
756  				struct hwloc_synthetic_backend_data_s *data,
757  				struct hwloc_synthetic_attached_s *attached,
758  				hwloc_bitmap_t set)
759  {
760    hwloc_obj_t child;
761    unsigned attached_os_index;
762    if (!attached)
763      return;
764    assert(attached->attr.type == HWLOC_OBJ_NUMANODE);
765    attached_os_index = hwloc_synthetic_next_index(&data->numa_attached_indexes, HWLOC_OBJ_NUMANODE);
766    child = hwloc_alloc_setup_object(topology, attached->attr.type, attached_os_index);
767    child->cpuset = hwloc_bitmap_dup(set);
768    child->nodeset = hwloc_bitmap_alloc();
769    hwloc_bitmap_set(child->nodeset, attached_os_index);
770    hwloc_synthetic_set_attr(&attached->attr, child);
771    hwloc__insert_object_by_cpuset(topology, NULL, child, "synthetic:attached");
772    hwloc_synthetic_insert_attached(topology, data, attached->next, set);
773  }
774  static void
775  hwloc__look_synthetic(struct hwloc_topology *topology,
776  		      struct hwloc_synthetic_backend_data_s *data,
777  		      int level,
778  		      hwloc_bitmap_t parent_cpuset)
779  {
780    hwloc_obj_t obj;
781    unsigned i;
782    struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];
783    hwloc_obj_type_t type = curlevel->attr.type;
784    hwloc_bitmap_t set;
785    unsigned os_index;
786    assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
787    assert(type != HWLOC_OBJ_MACHINE);
788    os_index = hwloc_synthetic_next_index(&curlevel->indexes, type);
789    set = hwloc_bitmap_alloc();
790    if (!curlevel->arity) {
791      hwloc_bitmap_set(set, os_index);
792    } else {
793      for (i = 0; i < curlevel->arity; i++)
794        hwloc__look_synthetic(topology, data, level + 1, set);
795    }
796    hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);
797    if (hwloc_filter_check_keep_object_type(topology, type)) {
798      obj = hwloc_alloc_setup_object(topology, type, os_index);
799      obj->cpuset = hwloc_bitmap_dup(set);
800      if (type == HWLOC_OBJ_NUMANODE) {
801        obj->nodeset = hwloc_bitmap_alloc();
802        hwloc_bitmap_set(obj->nodeset, os_index);
803      }
804      hwloc_synthetic_set_attr(&curlevel->attr, obj);
805      hwloc__insert_object_by_cpuset(topology, NULL, obj, "synthetic");
806    }
807    hwloc_synthetic_insert_attached(topology, data, curlevel->attached, set);
808    hwloc_bitmap_free(set);
809  }
810  static int
811  hwloc_look_synthetic(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
812  {
813    struct hwloc_topology *topology = backend->topology;
814    struct hwloc_synthetic_backend_data_s *data = backend->private_data;
815    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
816    unsigned i;
817    assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
818    assert(!topology->levels[0][0]->cpuset);
819    hwloc_alloc_root_sets(topology->levels[0][0]);
820    topology->support.discovery->pu = 1;
821    topology->support.discovery->numa = 1; &bsol;* we add a single NUMA node if none is given */
822    topology->support.discovery->numa_memory = 1; &bsol;* specified or default size */
823    for (i = 0; data->level[i].arity > 0; i++)
824      data->level[i].indexes.next = 0;
825    data->numa_attached_indexes.next = 0;
826    data->level[i].indexes.next = 0;
827    topology->levels[0][0]->type = data->level[0].attr.type;
828    hwloc_synthetic_set_attr(&data->level[0].attr, topology->levels[0][0]);
829    for (i = 0; i < data->level[0].arity; i++)
830      hwloc__look_synthetic(topology, data, 1, cpuset);
831    hwloc_synthetic_insert_attached(topology, data, data->level[0].attached, cpuset);
832    hwloc_bitmap_free(cpuset);
833    hwloc_obj_add_info(topology->levels[0][0], "Backend", "Synthetic");
834    hwloc_obj_add_info(topology->levels[0][0], "SyntheticDescription", data->string);
835    return 0;
836  }
837  static void
838  hwloc_synthetic_backend_disable(struct hwloc_backend *backend)
839  {
840    struct hwloc_synthetic_backend_data_s *data = backend->private_data;
841    hwloc_synthetic_free_levels(data);
842    free(data->string);
843    free(data);
844  }
845  static struct hwloc_backend *
846  hwloc_synthetic_component_instantiate(struct hwloc_topology *topology,
847  				      struct hwloc_disc_component *component,
848  				      unsigned excluded_phases __hwloc_attribute_unused,
849  				      const void *_data1,
850  				      const void *_data2 __hwloc_attribute_unused,
851  				      const void *_data3 __hwloc_attribute_unused)
852  {
853    struct hwloc_backend *backend;
854    struct hwloc_synthetic_backend_data_s *data;
855    int err;
856    if (!_data1) {
857      const char *env = getenv("HWLOC_SYNTHETIC");
858      if (env) {
859        _data1 = env;
860      } else {
861        errno = EINVAL;
862        goto out;
863      }
864    }
865    backend = hwloc_backend_alloc(topology, component);
866    if (!backend)
867      goto out;
868    data = malloc(sizeof(*data));
869    if (!data) {
870      errno = ENOMEM;
871      goto out_with_backend;
872    }
873    err = hwloc_backend_synthetic_init(data, (const char *) _data1);
874    if (err < 0)
875      goto out_with_data;
876    backend->private_data = data;
877    backend->discover = hwloc_look_synthetic;
878    backend->disable = hwloc_synthetic_backend_disable;
879    backend->is_thissystem = 0;
880    return backend;
881   out_with_data:
882    free(data);
883   out_with_backend:
884    free(backend);
885   out:
886    return NULL;
887  }
888  static struct hwloc_disc_component hwloc_synthetic_disc_component = {
889    "synthetic",
890    HWLOC_DISC_PHASE_GLOBAL,
891    ~0,
892    hwloc_synthetic_component_instantiate,
893    30,
894    1,
895    NULL
896  };
897  const struct hwloc_component hwloc_synthetic_component = {
898    HWLOC_COMPONENT_ABI,
899    NULL, NULL,
900    HWLOC_COMPONENT_TYPE_DISC,
901    0,
902    &hwloc_synthetic_disc_component
903  };
904  static __hwloc_inline int
905  hwloc__export_synthetic_update_status(int *ret, char **tmp, ssize_t *tmplen, int res)
906  {
907    if (res < 0)
908      return -1;
909    *ret += res;
910    if (res >= *tmplen)
911      res = *tmplen>0 ? (int)(*tmplen) - 1 : 0;
912    *tmp += res;
913    *tmplen -= res;
914    return 0;
915  }
916  static __hwloc_inline void
917  hwloc__export_synthetic_add_char(int *ret, char **tmp, ssize_t *tmplen, char c)
918  {
919    if (*tmplen > 1) {
920      (*tmp)[0] = c;
921      (*tmp)[1] = '\0';
922      (*tmp)++;
923      (*tmplen)--;
924    }
925    (*ret)++;
926  }
927  static int
928  hwloc__export_synthetic_indexes(hwloc_obj_t *level, unsigned total,
929  				char *buffer, size_t buflen)
930  {
931    unsigned step = 1;
932    unsigned nr_loops = 0;
933    struct hwloc_synthetic_intlv_loop_s *loops = NULL, *tmploops;
934    hwloc_obj_t cur;
935    unsigned i, j;
936    ssize_t tmplen = buflen;
937    char *tmp = buffer;
938    int res, ret = 0;
939    if (level[0]->os_index)
940      goto exportall;
941    while (step != total) {
942      if (total % step)
943        goto exportall;
944      for(i=1; i<total; i++)
945        if (level[i]->os_index == step)
946  	break;
947      if (i == total)
948        goto exportall;
949      for(j=2; j<total/i; j++)
950        if (level[i*j]->os_index != step*j)
951  	break;
952      nr_loops++;
953      tmploops = realloc(loops, nr_loops*sizeof(*loops));
954      if (!tmploops)
955        goto exportall;
956      loops = tmploops;
957      loops[nr_loops-1].step = i;
958      loops[nr_loops-1].nb = j;
959      step *= j;
960    }
961    for(i=0; i<total; i++) {
962      unsigned ind = 0;
963      unsigned mul = 1;
964      for(j=0; j<nr_loops; j++) {
965        ind += (i / loops[j].step) % loops[j].nb * mul;
966        mul *= loops[j].nb;
967      }
968      if (level[i]->os_index != ind)
969        goto exportall;
970    }
971    for(j=0; j<nr_loops; j++) {
972      res = hwloc_snprintf(tmp, tmplen, "%u*%u%s", loops[j].step, loops[j].nb,
973  			 j == nr_loops-1 ? ")" : ":");
974      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0) {
975        free(loops);
976        return -1;
977      }
978    }
979    free(loops);
980    return ret;
981   exportall:
982    free(loops);
983    cur = level[0];
984    while (cur) {
985      res = hwloc_snprintf(tmp, tmplen, "%u%s", cur->os_index,
986  			 cur->next_cousin ? "," : ")");
987      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
988        return -1;
989      cur = cur->next_cousin;
990    }
991    return ret;
992  }
993  static int
994  hwloc__export_synthetic_obj_attr(struct hwloc_topology * topology,
995  				 hwloc_obj_t obj,
996  				 char *buffer, size_t buflen)
997  {
998    const char * separator = " ";
999    const char * prefix = "(";
1000    char cachesize[64] = "";
1001    char memsize[64] = "";
1002    int needindexes = 0;
1003    if (hwloc__obj_type_is_cache(obj->type) && obj->attr->cache.size) {
1004      snprintf(cachesize, sizeof(cachesize), "%ssize=%llu",
1005  	     prefix, (unsigned long long) obj->attr->cache.size);
1006      prefix = separator;
1007    }
1008    if (obj->type == HWLOC_OBJ_NUMANODE && obj->attr->numanode.local_memory) {
1009      snprintf(memsize, sizeof(memsize), "%smemory=%llu",
1010  	     prefix, (unsigned long long) obj->attr->numanode.local_memory);
1011      prefix = separator;
1012    }
1013    if (!obj->logical_index &bsol;* only display indexes once per level (not for non-first NUMA children, etc.) */
1014        && (obj->type == HWLOC_OBJ_PU || obj->type == HWLOC_OBJ_NUMANODE)) {
1015      hwloc_obj_t cur = obj;
1016      while (cur) {
1017        if (cur->os_index != cur->logical_index) {
1018  	needindexes = 1;
1019  	break;
1020        }
1021        cur = cur->next_cousin;
1022      }
1023    }
1024    if (*cachesize || *memsize || needindexes) {
1025      ssize_t tmplen = buflen;
1026      char *tmp = buffer;
1027      int res, ret = 0;
1028      res = hwloc_snprintf(tmp, tmplen, "%s%s%s", cachesize, memsize, needindexes ? "" : ")");
1029      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1030        return -1;
1031      if (needindexes) {
1032        unsigned total;
1033        hwloc_obj_t *level;
1034        if (obj->depth < 0) {
1035  	assert(obj->depth == HWLOC_TYPE_DEPTH_NUMANODE);
1036  	total = topology->slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
1037  	level = topology->slevels[HWLOC_SLEVEL_NUMANODE].objs;
1038        } else {
1039  	total = topology->level_nbobjects[obj->depth];
1040  	level = topology->levels[obj->depth];
1041        }
1042        res = hwloc_snprintf(tmp, tmplen, "%sindexes=", prefix);
1043        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1044  	return -1;
1045        res = hwloc__export_synthetic_indexes(level, total, tmp, tmplen);
1046        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1047  	return -1;
1048      }
1049      return ret;
1050    } else {
1051      return 0;
1052    }
1053  }
1054  static int
1055  hwloc__export_synthetic_obj(struct hwloc_topology * topology, unsigned long flags,
1056  			    hwloc_obj_t obj, unsigned arity,
1057  			    char *buffer, size_t buflen)
1058  {
1059    char aritys[12] = "";
1060    ssize_t tmplen = buflen;
1061    char *tmp = buffer;
1062    int res, ret = 0;
1063    if (arity != (unsigned)-1)
1064      snprintf(aritys, sizeof(aritys), ":%u", arity);
1065    if (hwloc__obj_type_is_cache(obj->type)
1066        && (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES)) {
1067      res = hwloc_snprintf(tmp, tmplen, "Cache%s", aritys);
1068    } else if (obj->type == HWLOC_OBJ_PACKAGE
1069  	     && (flags & (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1070  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1071      res = hwloc_snprintf(tmp, tmplen, "Socket%s", aritys);
1072    } else if (obj->type == HWLOC_OBJ_DIE
1073  	     && (flags & (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1074  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1075      res = hwloc_snprintf(tmp, tmplen, "Group%s", aritys);
1076    } else if (obj->type == HWLOC_OBJ_GROUP &bsol;* don't export group depth */
1077        || flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES) {
1078      res = hwloc_snprintf(tmp, tmplen, "%s%s", hwloc_obj_type_string(obj->type), aritys);
1079    } else {
1080      char types[64];
1081      hwloc_obj_type_snprintf(types, sizeof(types), obj, 1);
1082      res = hwloc_snprintf(tmp, tmplen, "%s%s", types, aritys);
1083    }
1084    if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1085      return -1;
1086    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1087      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1088      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1089        return -1;
1090    }
1091    return ret;
1092  }
1093  static int
1094  hwloc__export_synthetic_memory_children(struct hwloc_topology * topology, unsigned long flags,
1095  					hwloc_obj_t parent,
1096  					char *buffer, size_t buflen,
1097  					int needprefix, int verbose)
1098  {
1099    hwloc_obj_t mchild;
1100    ssize_t tmplen = buflen;
1101    char *tmp = buffer;
1102    int res, ret = 0;
1103    mchild = parent->memory_first_child;
1104    if (!mchild)
1105      return 0;
1106    if (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1107      if (parent->memory_arity > 1 || mchild->type != HWLOC_OBJ_NUMANODE) {
1108        if (verbose)
1109  	fprintf(stderr, "Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n");
1110        errno = EINVAL;
1111        return -1;
1112      }
1113      if (needprefix)
1114        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1115      res = hwloc__export_synthetic_obj(topology, flags, mchild, 1, tmp, tmplen);
1116      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1117        return -1;
1118      return ret;
1119    }
1120    while (mchild) {
1121      hwloc_obj_t numanode = mchild;
1122      while (numanode && numanode->type != HWLOC_OBJ_NUMANODE) {
1123        assert(numanode->arity == 1);
1124        numanode = numanode->memory_first_child;
1125      }
1126      assert(numanode); &bsol;* there's always a numanode at the bottom of the memory tree */
1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1129      hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, '[');
1130      res = hwloc__export_synthetic_obj(topology, flags, numanode, (unsigned)-1, tmp, tmplen);
1131      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1132        return -1;
1133      hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ']');
1134      needprefix = 1;
1135      mchild = mchild->next_sibling;
1136    }
1137    return ret;
1138  }
1139  static int
1140  hwloc_check_memory_symmetric(struct hwloc_topology * topology)
1141  {
1142    hwloc_bitmap_t remaining_nodes;
1143    remaining_nodes = hwloc_bitmap_dup(hwloc_get_root_obj(topology)->nodeset);
1144    if (!remaining_nodes)
1145      return -1;
1146    while (!hwloc_bitmap_iszero(remaining_nodes)) {
1147      unsigned idx;
1148      hwloc_obj_t node;
1149      hwloc_obj_t first_parent;
1150      unsigned i;
1151      idx = hwloc_bitmap_first(remaining_nodes);
1152      node = hwloc_get_numanode_obj_by_os_index(topology, idx);
1153      assert(node);
1154      first_parent = node->parent;
1155      for(i=0; i<hwloc_get_nbobjs_by_depth(topology, first_parent->depth); i++) {
1156        hwloc_obj_t parent, mchild;
1157        parent = hwloc_get_obj_by_depth(topology, first_parent->depth, i);
1158        assert(parent);
1159        if (parent->memory_arity != first_parent->memory_arity)
1160  	goto out_with_bitmap;
1161        mchild = parent->memory_first_child;
1162        while (mchild) {
1163  	hwloc_bitmap_clr(remaining_nodes, mchild->os_index); &bsol;* cannot use parent->nodeset, some normal children may have other NUMA nodes */
1164  	mchild = mchild->next_sibling;
1165        }
1166      }
1167    }
1168    hwloc_bitmap_free(remaining_nodes);
1169    return 0;
1170   out_with_bitmap:
1171    hwloc_bitmap_free(remaining_nodes);
1172    return -1;
1173  }
1174  int
1175  hwloc_topology_export_synthetic(struct hwloc_topology * topology,
1176  				char *buffer, size_t buflen,
1177  				unsigned long flags)
1178  {
1179    hwloc_obj_t obj = hwloc_get_root_obj(topology);
1180    ssize_t tmplen = buflen;
1181    char *tmp = buffer;
1182    int res, ret = 0;
1183    unsigned arity;
1184    int needprefix = 0;
1185    int verbose = 0;
1186    const char *env = getenv("HWLOC_SYNTHETIC_VERBOSE");
1187    if (env)
1188      verbose = atoi(env);
1189    if (!topology->is_loaded) {
1190      errno = EINVAL;
1191      return -1;
1192    }
1193    if (flags & ~(HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1194  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS
1195  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1
1196  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1197      errno = EINVAL;
1198      return -1;
1199    }
1200    if (!obj->symmetric_subtree) {
1201      if (verbose)
1202        fprintf(stderr, "Cannot export to synthetic unless topology is symmetric (root->symmetric_subtree must be set).\n");
1203      errno = EINVAL;
1204      return -1;
1205    }
1206    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
1207        && hwloc_check_memory_symmetric(topology) < 0) {
1208      if (verbose)
1209        fprintf(stderr, "Cannot export to synthetic unless memory is attached symmetrically.\n");
1210      errno = EINVAL;
1211      return -1;
1212    }
1213    if (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1214      hwloc_obj_t node;
1215      signed pdepth;
1216      node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
1217      assert(node);
1218      assert(hwloc__obj_type_is_normal(node->parent->type)); &bsol;* only depth-1 memory children for now */
1219      pdepth = node->parent->depth;
1220      while ((node = node->next_cousin) != NULL) {
1221        assert(hwloc__obj_type_is_normal(node->parent->type)); &bsol;* only depth-1 memory children for now */
1222        if (node->parent->depth != pdepth) {
1223  	if (verbose)
1224  	  fprintf(stderr, "Cannot export to synthetic v1 if memory is attached to parents at different depths.\n");
1225  	errno = EINVAL;
1226  	return -1;
1227        }
1228      }
1229    }
1230    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1231      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1232      if (res > 0)
1233        needprefix = 1;
1234      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1235        return -1;
1236    }
1237    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1238      res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, needprefix, verbose);
1239      if (res > 0)
1240        needprefix = 1;
1241      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1242        return -1;
1243    }
1244    arity = obj->arity;
1245    while (arity) {
1246      obj = obj->first_child;
1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
1250      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1251        return -1;
1252      if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1253        res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, 1, verbose);
1254        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1255  	return -1;
1256      }
1257      needprefix = 1;
1258      arity = obj->arity;
1259    }
1260    return ret;
1261  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/misc.h"
5  #include "private/debug.h"
6  #include <limits.h>
7  #include <assert.h>
8  #ifdef HAVE_STRINGS_H
9  #include <strings.h>
10  #endif
11  struct hwloc_synthetic_attr_s {
12    hwloc_obj_type_t type;
13    unsigned depth; &bsol;* For caches/groups */
14    hwloc_obj_cache_type_t cachetype; &bsol;* For caches */
15    hwloc_uint64_t memorysize; &bsol;* For caches/memory */
16  };
17  struct hwloc_synthetic_indexes_s {
18    const char *string;
19    unsigned long string_length;
20    unsigned *array;
21    unsigned next; &bsol;* id of the next object for that level */
22  };
23  struct hwloc_synthetic_level_data_s {
24    unsigned arity;
25    unsigned long totalwidth;
26    struct hwloc_synthetic_attr_s attr;
27    struct hwloc_synthetic_indexes_s indexes;
28    struct hwloc_synthetic_attached_s {
29      struct hwloc_synthetic_attr_s attr;
30      struct hwloc_synthetic_attached_s *next;
31    } *attached;
32  };
33  struct hwloc_synthetic_backend_data_s {
34    char *string;
35    unsigned long numa_attached_nr;
36    struct hwloc_synthetic_indexes_s numa_attached_indexes;
37  #define HWLOC_SYNTHETIC_MAX_DEPTH 128
38    struct hwloc_synthetic_level_data_s level[HWLOC_SYNTHETIC_MAX_DEPTH];
39  };
40  struct hwloc_synthetic_intlv_loop_s {
41    unsigned step;
42    unsigned nb;
43    unsigned level_depth;
44  };
45  static void
46  hwloc_synthetic_process_indexes(struct hwloc_synthetic_backend_data_s *data,
47  				struct hwloc_synthetic_indexes_s *indexes,
48  				unsigned long total,
49  				int verbose)
50  {
51    const char *attr = indexes->string;
52    unsigned long length = indexes->string_length;
53    unsigned *array = NULL;
54    size_t i;
55    if (!attr)
56      return;
57    array = calloc(total, sizeof(*array));
58    if (!array) {
59      if (verbose)
60        fprintf(stderr, "Failed to allocate synthetic index array of size %lu\n", total);
61      goto out;
62    }
63    i = strspn(attr, "0123456789,");
64    if (i == length) {
65      for(i=0; i<total; i++) {
66        const char *next;
67        unsigned idx = strtoul(attr, (char **) &next, 10);
68        if (next == attr) {
69  	if (verbose)
70  	  fprintf(stderr, "Failed to read synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
71  	goto out_with_array;
72        }
73        array[i] = idx;
74        if (i != total-1) {
75  	if (*next != ',') {
76  	  if (verbose)
77  	    fprintf(stderr, "Missing comma after synthetic index #%lu at '%s'\n", (unsigned long) i, attr);
78  	  goto out_with_array;
79  	}
80  	attr = next+1;
81        } else {
82  	attr = next;
83        }
84      }
85      indexes->array = array;
86    } else {
87      unsigned nr_loops = 1, cur_loop;
88      unsigned minstep = total;
89      unsigned long nbs = 1;
90      unsigned j, mul;
91      const char *tmp;
92      struct hwloc_synthetic_intlv_loop_s *loops;
93      tmp = attr;
94      while (tmp) {
95        tmp = strchr(tmp, ':');
96        if (!tmp || tmp >= attr+length)
97  	break;
98        nr_loops++;
99        tmp++;
100      }
101      loops = malloc((nr_loops+1) * sizeof(*loops));
102      if (!loops)
103        goto out_with_array;
104      if (*attr >= '0' && *attr <= '9') {
105        unsigned step, nb;
106        tmp = attr;
107        cur_loop = 0;
108        while (tmp) {
109  	char *tmp2, *tmp3;
110  	step = (unsigned) strtol(tmp, &tmp2, 0);
111  	if (tmp2 == tmp || *tmp2 != '*') {
112  	  if (verbose)
113  	    fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number before '*'\n", tmp);
114  	  free(loops);
115  	  goto out_with_array;
116  	}
117  	if (!step) {
118  	  if (verbose)
119  	    fprintf(stderr, "Invalid interleaving loop with step 0 at '%s'\n", tmp);
120  	  free(loops);
121  	  goto out_with_array;
122  	}
123  	tmp2++;
124  	nb = (unsigned) strtol(tmp2, &tmp3, 0);
125  	if (tmp3 == tmp2 || (*tmp3 && *tmp3 != ':' && *tmp3 != ')' && *tmp3 != ' ')) {
126  	  if (verbose)
127  	    fprintf(stderr, "Failed to read synthetic index interleaving loop '%s' without number between '*' and ':'\n", tmp);
128  	  free(loops);
129  	  goto out_with_array;
130  	}
131  	if (!nb) {
132  	  if (verbose)
133  	    fprintf(stderr, "Invalid interleaving loop with number 0 at '%s'\n", tmp2);
134  	  free(loops);
135  	  goto out_with_array;
136  	}
137  	loops[cur_loop].step = step;
138  	loops[cur_loop].nb = nb;
139  	if (step < minstep)
140  	  minstep = step;
141  	nbs *= nb;
142  	cur_loop++;
143  	if (*tmp3 == ')' || *tmp3 == ' ')
144  	  break;
145  	tmp = (const char*) (tmp3+1);
146        }
147      } else {
148        hwloc_obj_type_t type;
149        union hwloc_obj_attr_u attrs;
150        int err;
151        tmp = attr;
152        cur_loop = 0;
153        while (tmp) {
154  	err = hwloc_type_sscanf(tmp, &type, &attrs, sizeof(attrs));
155  	if (err < 0) {
156  	  if (verbose)
157  	    fprintf(stderr, "Failed to read synthetic index interleaving loop type '%s'\n", tmp);
158  	  free(loops);
159  	  goto out_with_array;
160  	}
161  	if (type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
162  	  if (verbose)
163  	    fprintf(stderr, "Misc object type disallowed in synthetic index interleaving loop type '%s'\n", tmp);
164  	  free(loops);
165  	  goto out_with_array;
166  	}
167  	for(i=0; ; i++) {
168  	  if (!data->level[i].arity) {
169  	    loops[cur_loop].level_depth = (unsigned)-1;
170  	    break;
171  	  }
172  	  if (type != data->level[i].attr.type)
173  	    continue;
174  	  if (type == HWLOC_OBJ_GROUP
175  	      && attrs.group.depth != (unsigned) -1
176  	      && attrs.group.depth != data->level[i].attr.depth)
177  	    continue;
178  	  loops[cur_loop].level_depth = (unsigned)i;
179  	  break;
180  	}
181  	if (loops[cur_loop].level_depth == (unsigned)-1) {
182  	  if (verbose)
183  	    fprintf(stderr, "Failed to find level for synthetic index interleaving loop type '%s'\n",
184  		    tmp);
185  	  free(loops);
186  	  goto out_with_array;
187  	}
188  	tmp = strchr(tmp, ':');
189  	if (!tmp || tmp > attr+length)
190  	  break;
191  	tmp++;
192  	cur_loop++;
193        }
194        for(cur_loop=0; cur_loop<nr_loops; cur_loop++) {
195  	unsigned mydepth = loops[cur_loop].level_depth;
196  	unsigned prevdepth = 0;
197  	unsigned step, nb;
198  	for(i=0; i<nr_loops; i++) {
199  	  if (loops[i].level_depth == mydepth && i != cur_loop) {
200  	    if (verbose)
201  	      fprintf(stderr, "Invalid duplicate interleaving loop type in synthetic index '%s'\n", attr);
202  	    free(loops);
203  	    goto out_with_array;
204  	  }
205  	  if (loops[i].level_depth < mydepth
206  	      && loops[i].level_depth > prevdepth)
207  	    prevdepth = loops[i].level_depth;
208  	}
209  	step = total / data->level[mydepth].totalwidth; &bsol;* number of objects below us */
210  	nb = data->level[mydepth].totalwidth / data->level[prevdepth].totalwidth; &bsol;* number of us within parent */
211  	loops[cur_loop].step = step;
212  	loops[cur_loop].nb = nb;
213  	assert(nb);
214  	assert(step);
215  	if (step < minstep)
216  	  minstep = step;
217  	nbs *= nb;
218        }
219      }
220      assert(nbs);
221      if (nbs != total) {
222        if (minstep == total/nbs) {
223  	loops[nr_loops].step = 1;
224  	loops[nr_loops].nb = total/nbs;
225  	nr_loops++;
226        } else {
227  	if (verbose)
228  	  fprintf(stderr, "Invalid index interleaving total width %lu instead of %lu\n", nbs, total);
229  	free(loops);
230  	goto out_with_array;
231        }
232      }
233      mul = 1;
234      for(i=0; i<nr_loops; i++) {
235        unsigned step = loops[i].step;
236        unsigned nb = loops[i].nb;
237        for(j=0; j<total; j++)
238  	array[j] += ((j / step) % nb) * mul;
239        mul *= nb;
240      }
241      free(loops);
242      for(j=0; j<total; j++) {
243        if (array[j] >= total) {
244  	if (verbose)
245  	  fprintf(stderr, "Invalid index interleaving generates out-of-range index %u\n", array[j]);
246  	goto out_with_array;
247        }
248        if (!array[j] && j) {
249  	if (verbose)
250  	  fprintf(stderr, "Invalid index interleaving generates duplicate index values\n");
251  	goto out_with_array;
252        }
253      }
254      indexes->array = array;
255    }
256    return;
257   out_with_array:
258    free(array);
259   out:
260    return;
261  }
262  static hwloc_uint64_t
263  hwloc_synthetic_parse_memory_attr(const char *attr, const char **endp)
264  {
265    const char *endptr;
266    hwloc_uint64_t size;
267    size = strtoull(attr, (char **) &endptr, 0);
268    if (!hwloc_strncasecmp(endptr, "TB", 2)) {
269      size *= 1000ULL*1000ULL*1000ULL*1000ULL;
270      endptr += 2;
271    } else if (!hwloc_strncasecmp(endptr, "TiB", 3)) {
272      size <<= 40;
273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, "GB", 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
276      endptr += 2;
277    } else if (!hwloc_strncasecmp(endptr, "GiB", 3)) {
278      size <<= 30;
279      endptr += 3;
280    } else if (!hwloc_strncasecmp(endptr, "MB", 2)) {
281      size *= 1000ULL*1000ULL;
<span onclick='openModal()' class='match'>282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, "MiB", 3)) {
284      size <<= 20;
</span>285      endptr += 3;
286    } else if (!hwloc_strncasecmp(endptr, "kB", 2)) {
287      size *= 1000ULL;
288      endptr += 2;
289    } else if (!hwloc_strncasecmp(endptr, "kiB", 3)) {
290      size <<= 10;
291      endptr += 3;
292    }
293    *endp = endptr;
294    return size;
295  }
296  static int
297  hwloc_synthetic_parse_attrs(const char *attrs, const char **next_posp,
298  			    struct hwloc_synthetic_attr_s *sattr,
299  			    struct hwloc_synthetic_indexes_s *sind,
300  			    int verbose)
301  {
302    hwloc_obj_type_t type = sattr->type;
303    const char *next_pos;
304    hwloc_uint64_t memorysize = 0;
305    const char *index_string = NULL;
306    size_t index_string_length = 0;
307    next_pos = (const char *) strchr(attrs, ')');
308    if (!next_pos) {
309      if (verbose)
310        fprintf(stderr, "Missing attribute closing bracket in synthetic string doesn't have a number of objects at '%s'\n", attrs);
311      errno = EINVAL;
312      return -1;
313    }
314    while (')' != *attrs) {
315      int iscache = hwloc__obj_type_is_cache(type);
316      if (iscache && !strncmp("size=", attrs, 5)) {
317        memorysize = hwloc_synthetic_parse_memory_attr(attrs+5, &attrs);
318      } else if (!iscache && !strncmp("memory=", attrs, 7)) {
319        memorysize = hwloc_synthetic_parse_memory_attr(attrs+7, &attrs);
320      } else if (!strncmp("indexes=", attrs, 8)) {
321        index_string = attrs+8;
322        attrs += 8;
323        index_string_length = strcspn(attrs, " )");
324        attrs += index_string_length;
325      } else {
326        if (verbose)
327  	fprintf(stderr, "Unknown attribute at '%s'\n", attrs);
328        errno = EINVAL;
329        return -1;
330      }
331      if (' ' == *attrs)
332        attrs++;
333      else if (')' != *attrs) {
334        if (verbose)
335  	fprintf(stderr, "Missing parameter separator at '%s'\n", attrs);
336        errno = EINVAL;
337        return -1;
338      }
339    }
340    sattr->memorysize = memorysize;
341    if (index_string) {
342      if (sind->string && verbose)
343        fprintf(stderr, "Overwriting duplicate indexes attribute with last occurence\n");
344      sind->string = index_string;
345      sind->string_length = (unsigned long)index_string_length;
346    }
347    *next_posp = next_pos+1;
348    return 0;
349  }
350  static void
351  hwloc_synthetic_free_levels(struct hwloc_synthetic_backend_data_s *data)
352  {
353    unsigned i;
354    for(i=0; i<HWLOC_SYNTHETIC_MAX_DEPTH; i++) {
355      struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];
356      struct hwloc_synthetic_attached_s **pprev = &curlevel->attached;
357      while (*pprev) {
358        struct hwloc_synthetic_attached_s *cur = *pprev;
359        *pprev = cur->next;
360        free(cur);
361      }
362      free(curlevel->indexes.array);
363      if (!curlevel->arity)
364        break;
365    }
366    free(data->numa_attached_indexes.array);
367  }
368  static int
369  hwloc_backend_synthetic_init(struct hwloc_synthetic_backend_data_s *data,
370  			     const char *description)
371  {
372    const char *pos, *next_pos;
373    unsigned long item, count;
374    unsigned i;
375    int type_count[HWLOC_OBJ_TYPE_MAX];
376    unsigned unset;
377    int verbose = 0;
378    const char *env = getenv("HWLOC_SYNTHETIC_VERBOSE");
379    int err;
380    unsigned long totalarity = 1;
381    if (env)
382      verbose = atoi(env);
383    data->numa_attached_nr = 0;
384    data->numa_attached_indexes.array = NULL;
385    data->level[0].totalwidth = 1;
386    data->level[0].attr.type = HWLOC_OBJ_MACHINE;
387    data->level[0].indexes.string = NULL;
388    data->level[0].indexes.array = NULL;
389    data->level[0].attr.memorysize = 0;
390    data->level[0].attached = NULL;
391    type_count[HWLOC_OBJ_MACHINE] = 1;
392    if (*description == '(') {
393      err = hwloc_synthetic_parse_attrs(description+1, &description, &data->level[0].attr, &data->level[0].indexes, verbose);
394      if (err < 0)
395        return err;
396    }
397    data->numa_attached_indexes.string = NULL;
398    data->numa_attached_indexes.array = NULL;
399    for (pos = description, count = 1; *pos; pos = next_pos) {
400      hwloc_obj_type_t type = HWLOC_OBJ_TYPE_NONE;
401      union hwloc_obj_attr_u attrs;
402      data->level[count-1].arity = 0;
403      while (*pos == ' ' || *pos == '\n')
404        pos++;
405      if (!*pos)
406        break;
407      if (*pos == '[') {
408        struct hwloc_synthetic_attached_s *attached, **pprev;
409        char *attr;
410        pos++;
411        if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {
412  	if (verbose)
413  	  fprintf(stderr, "Synthetic string with unknown attached object type at '%s'\n", pos);
414  	errno = EINVAL;
415  	goto error;
416        }
417        if (type != HWLOC_OBJ_NUMANODE) {
418  	if (verbose)
419  	  fprintf(stderr, "Synthetic string with disallowed attached object type at '%s'\n", pos);
420  	errno = EINVAL;
421  	goto error;
422        }
423        data->numa_attached_nr += data->level[count-1].totalwidth;
424        attached = malloc(sizeof(*attached));
425        if (attached) {
426  	attached->attr.type = type;
427  	attached->attr.memorysize = 0;
428  	attached->next = NULL;
429  	pprev = &data->level[count-1].attached;
430  	while (*pprev)
431  	  pprev = &((*pprev)->next);
432  	*pprev = attached;
433        }
434        next_pos = strchr(pos, ']');
435        if (!next_pos) {
436  	if (verbose)
437  	  fprintf(stderr,"Synthetic string doesn't have a closing `]' after attached object type at '%s'\n", pos);
438  	errno = EINVAL;
439  	goto error;
440        }
441        attr = strchr(pos, '(');
442        if (attr && attr < next_pos && attached) {
443  	const char *dummy;
444  	err = hwloc_synthetic_parse_attrs(attr+1, &dummy, &attached->attr, &data->numa_attached_indexes, verbose);
445  	if (err < 0)
446  	  goto error;
447        }
448        next_pos++;
449        continue;
450      }
451      data->level[count].indexes.string = NULL;
452      data->level[count].indexes.array = NULL;
453      data->level[count].attached = NULL;
454      if (*pos < '0' || *pos > '9') {
455        if (hwloc_type_sscanf(pos, &type, &attrs, sizeof(attrs)) < 0) {
456  	if (!strncmp(pos, "Tile", 4) || !strncmp(pos, "Module", 6)) {
457  	  type = HWLOC_OBJ_GROUP;
458  	} else {
459  	  if (verbose)
460  	    fprintf(stderr, "Synthetic string with unknown object type at '%s'\n", pos);
461  	  errno = EINVAL;
462  	  goto error;
463  	}
464        }
465        if (type == HWLOC_OBJ_MACHINE || type == HWLOC_OBJ_MISC || type == HWLOC_OBJ_BRIDGE || type == HWLOC_OBJ_PCI_DEVICE || type == HWLOC_OBJ_OS_DEVICE) {
466  	if (verbose)
467  	  fprintf(stderr, "Synthetic string with disallowed object type at '%s'\n", pos);
468  	errno = EINVAL;
469  	goto error;
470        }
471        next_pos = strchr(pos, ':');
472        if (!next_pos) {
473  	if (verbose)
474  	  fprintf(stderr,"Synthetic string doesn't have a `:' after object type at '%s'\n", pos);
475  	errno = EINVAL;
476  	goto error;
477        }
478        pos = next_pos + 1;
479      }
480      data->level[count].attr.type = type;
481      data->level[count].attr.depth = (unsigned) -1;
482      data->level[count].attr.cachetype = (hwloc_obj_cache_type_t) -1;
483      if (hwloc__obj_type_is_cache(type)) {
484        data->level[count].attr.depth = attrs.cache.depth;
485        data->level[count].attr.cachetype = attrs.cache.type;
486      } else if (type == HWLOC_OBJ_GROUP) {
487        data->level[count].attr.depth = attrs.group.depth;
488      }
489      item = strtoul(pos, (char **)&next_pos, 0);
490      if (next_pos == pos) {
491        if (verbose)
492  	fprintf(stderr,"Synthetic string doesn't have a number of objects at '%s'\n", pos);
493        errno = EINVAL;
494        goto error;
495      }
496      if (!item) {
497        if (verbose)
498  	fprintf(stderr,"Synthetic string with disallow 0 number of objects at '%s'\n", pos);
499        errno = EINVAL;
500        goto error;
501      }
502      totalarity *= item;
503      data->level[count].totalwidth = totalarity;
504      data->level[count].indexes.string = NULL;
505      data->level[count].indexes.array = NULL;
506      data->level[count].attr.memorysize = 0;
507      if (*next_pos == '(') {
508        err = hwloc_synthetic_parse_attrs(next_pos+1, &next_pos, &data->level[count].attr, &data->level[count].indexes, verbose);
509        if (err < 0)
510  	goto error;
511      }
512      if (count + 1 >= HWLOC_SYNTHETIC_MAX_DEPTH) {
513        if (verbose)
514  	fprintf(stderr,"Too many synthetic levels, max %d\n", HWLOC_SYNTHETIC_MAX_DEPTH);
515        errno = EINVAL;
516        goto error;
517      }
518      if (item > UINT_MAX) {
519        if (verbose)
520  	fprintf(stderr,"Too big arity, max %u\n", UINT_MAX);
521        errno = EINVAL;
522        goto error;
523      }
524      data->level[count-1].arity = (unsigned)item;
525      count++;
526    }
527    if (data->level[count-1].attr.type != HWLOC_OBJ_TYPE_NONE && data->level[count-1].attr.type != HWLOC_OBJ_PU) {
528      if (verbose)
529        fprintf(stderr, "Synthetic string cannot use non-PU type for last level\n");
530      errno = EINVAL;
531      return -1;
532    }
533    data->level[count-1].attr.type = HWLOC_OBJ_PU;
534    for(i=HWLOC_OBJ_TYPE_MIN; i<HWLOC_OBJ_TYPE_MAX; i++) {
535      type_count[i] = 0;
536    }
537    for(i=count-1; i>0; i--) {
538      hwloc_obj_type_t type = data->level[i].attr.type;
539      if (type != HWLOC_OBJ_TYPE_NONE) {
540        type_count[type]++;
541      }
542    }
543    if (!type_count[HWLOC_OBJ_PU]) {
544      if (verbose)
545        fprintf(stderr, "Synthetic string missing ending number of PUs\n");
546      errno = EINVAL;
547      return -1;
548    } else if (type_count[HWLOC_OBJ_PU] > 1) {
549      if (verbose)
550        fprintf(stderr, "Synthetic string cannot have several PU levels\n");
551      errno = EINVAL;
552      return -1;
553    }
554    if (type_count[HWLOC_OBJ_PACKAGE] > 1) {
555      if (verbose)
556        fprintf(stderr, "Synthetic string cannot have several package levels\n");
557      errno = EINVAL;
558      return -1;
559    }
560    if (type_count[HWLOC_OBJ_DIE] > 1) {
561      if (verbose)
562        fprintf(stderr, "Synthetic string cannot have several die levels\n");
563      errno = EINVAL;
564      return -1;
565    }
566    if (type_count[HWLOC_OBJ_NUMANODE] > 1) {
567      if (verbose)
568        fprintf(stderr, "Synthetic string cannot have several NUMA node levels\n");
569      errno = EINVAL;
570      return -1;
571    }
572    if (type_count[HWLOC_OBJ_NUMANODE] && data->numa_attached_nr) {
573      if (verbose)
574        fprintf(stderr,"Synthetic string cannot have NUMA nodes both as a level and attached\n");
575      errno = EINVAL;
576      return -1;
577    }
578    if (type_count[HWLOC_OBJ_CORE] > 1) {
579      if (verbose)
580        fprintf(stderr, "Synthetic string cannot have several core levels\n");
581      errno = EINVAL;
582      return -1;
583    }
584    unset = 0;
585    for(i=1; i<count-1; i++) {
586      if (data->level[i].attr.type == HWLOC_OBJ_TYPE_NONE)
587        unset++;
588    }
589    if (unset && unset != count-2) {
590      if (verbose)
591        fprintf(stderr, "Synthetic string cannot mix unspecified and specified types for levels\n");
592      errno = EINVAL;
593      return -1;
594    }
595    if (unset) {
596      unsigned _count = count;
597      unsigned neednuma = 0;
598      unsigned needpack = 0;
599      unsigned needcore = 0;
600      unsigned needcaches = 0;
601      unsigned needgroups = 0;
602      _count -= 2;
603      neednuma = (_count >= 1 && !data->numa_attached_nr);
604      _count -= neednuma;
605      needpack = (_count >= 1);
606      _count -= needpack;
607      needcore = (_count >= 1);
608      _count -= needcore;
609      needcaches = (_count > 4 ? 4 : _count);
610      _count -= needcaches;
611      needgroups = _count;
612      for(i = 0; i < needgroups; i++) {
613        unsigned depth = 1 + i;
614        data->level[depth].attr.type = HWLOC_OBJ_GROUP;
615        type_count[HWLOC_OBJ_GROUP]++;
616      }
617      if (needpack) {
618        unsigned depth = 1 + needgroups;
619        data->level[depth].attr.type = HWLOC_OBJ_PACKAGE;
620        type_count[HWLOC_OBJ_PACKAGE] = 1;
621      }
622      if (neednuma) {
623        unsigned depth = 1 + needgroups + needpack;
624        data->level[depth].attr.type = HWLOC_OBJ_NUMANODE;
625        type_count[HWLOC_OBJ_NUMANODE] = 1;
626      }
627      if (needcaches) {
628        unsigned l3depth = 1 + needgroups + needpack + neednuma;
629        unsigned l2depth = l3depth + (needcaches >= 3);
630        unsigned l1depth = l2depth + 1;
631        unsigned l1idepth = l1depth + 1;
632        if (needcaches >= 3) {
633  	data->level[l3depth].attr.type = HWLOC_OBJ_L3CACHE;
634  	data->level[l3depth].attr.depth = 3;
635  	data->level[l3depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
636  	type_count[HWLOC_OBJ_L3CACHE] = 1;
637        }
638        data->level[l2depth].attr.type = HWLOC_OBJ_L2CACHE;
639        data->level[l2depth].attr.depth = 2;
640        data->level[l2depth].attr.cachetype = HWLOC_OBJ_CACHE_UNIFIED;
641        type_count[HWLOC_OBJ_L2CACHE] = 1;
642        if (needcaches >= 2) {
643  	data->level[l1depth].attr.type = HWLOC_OBJ_L1CACHE;
644  	data->level[l1depth].attr.depth = 1;
645  	data->level[l1depth].attr.cachetype = HWLOC_OBJ_CACHE_DATA;
646  	type_count[HWLOC_OBJ_L1CACHE] = 1;
647        }
648        if (needcaches >= 4) {
649  	data->level[l1idepth].attr.type = HWLOC_OBJ_L1ICACHE;
650  	data->level[l1idepth].attr.depth = 1;
651  	data->level[l1idepth].attr.cachetype = HWLOC_OBJ_CACHE_INSTRUCTION;
652  	type_count[HWLOC_OBJ_L1ICACHE] = 1;
653        }
654      }
655      if (needcore) {
656        unsigned depth = 1 + needgroups + needpack + neednuma + needcaches;
657        data->level[depth].attr.type = HWLOC_OBJ_CORE;
658        type_count[HWLOC_OBJ_CORE] = 1;
659      }
660    }
661    if (!type_count[HWLOC_OBJ_NUMANODE] && !data->numa_attached_nr) {
662      if (verbose)
663        fprintf(stderr, "Inserting a NUMA level with a single object at depth 1\n");
664      memmove(&data->level[2], &data->level[1], count*sizeof(struct hwloc_synthetic_level_data_s));
665      data->level[1].attr.type = HWLOC_OBJ_NUMANODE;
666      data->level[1].indexes.string = NULL;
667      data->level[1].indexes.array = NULL;
668      data->level[1].attr.memorysize = 0;
669      data->level[1].totalwidth = data->level[0].totalwidth;
670      data->level[1].arity = data->level[0].arity;
671      data->level[0].arity = 1;
672      count++;
673    }
674    for (i=0; i<count; i++) {
675      struct hwloc_synthetic_level_data_s *curlevel = &data->level[i];
676      hwloc_obj_type_t type = curlevel->attr.type;
677      if (type == HWLOC_OBJ_GROUP) {
678        if (curlevel->attr.depth == (unsigned)-1)
679  	curlevel->attr.depth = type_count[HWLOC_OBJ_GROUP]--;
680      } else if (hwloc__obj_type_is_cache(type)) {
681        if (!curlevel->attr.memorysize) {
682  	if (1 == curlevel->attr.depth)
683  	  curlevel->attr.memorysize = 32*1024;
684  	else
685  	  curlevel->attr.memorysize = 256ULL*1024 << (2*curlevel->attr.depth);
686        }
687      } else if (type == HWLOC_OBJ_NUMANODE && !curlevel->attr.memorysize) {
688        curlevel->attr.memorysize = 1024*1024*1024;
689      }
690      hwloc_synthetic_process_indexes(data, &data->level[i].indexes, data->level[i].totalwidth, verbose);
691    }
692    hwloc_synthetic_process_indexes(data, &data->numa_attached_indexes, data->numa_attached_nr, verbose);
693    data->string = strdup(description);
694    data->level[count-1].arity = 0;
695    return 0;
696   error:
697    hwloc_synthetic_free_levels(data);
698    return -1;
699  }
700  static void
701  hwloc_synthetic_set_attr(struct hwloc_synthetic_attr_s *sattr,
702  			 hwloc_obj_t obj)
703  {
704    switch (obj->type) {
705    case HWLOC_OBJ_GROUP:
706      obj->attr->group.kind = HWLOC_GROUP_KIND_SYNTHETIC;
707      obj->attr->group.subkind = sattr->depth-1;
708      break;
709    case HWLOC_OBJ_MACHINE:
710      break;
711    case HWLOC_OBJ_NUMANODE:
712      obj->attr->numanode.local_memory = sattr->memorysize;
713      obj->attr->numanode.page_types_len = 1;
714      obj->attr->numanode.page_types = malloc(sizeof(*obj->attr->numanode.page_types));
715      memset(obj->attr->numanode.page_types, 0, sizeof(*obj->attr->numanode.page_types));
716      obj->attr->numanode.page_types[0].size = 4096;
717      obj->attr->numanode.page_types[0].count = sattr->memorysize / 4096;
718      break;
719    case HWLOC_OBJ_PACKAGE:
720    case HWLOC_OBJ_DIE:
721      break;
722    case HWLOC_OBJ_L1CACHE:
723    case HWLOC_OBJ_L2CACHE:
724    case HWLOC_OBJ_L3CACHE:
725    case HWLOC_OBJ_L4CACHE:
726    case HWLOC_OBJ_L5CACHE:
727    case HWLOC_OBJ_L1ICACHE:
728    case HWLOC_OBJ_L2ICACHE:
729    case HWLOC_OBJ_L3ICACHE:
730      obj->attr->cache.depth = sattr->depth;
731      obj->attr->cache.linesize = 64;
732      obj->attr->cache.type = sattr->cachetype;
733      obj->attr->cache.size = sattr->memorysize;
734      break;
735    case HWLOC_OBJ_CORE:
736      break;
737    case HWLOC_OBJ_PU:
738      break;
739    default:
740      assert(0);
741      break;
742    }
743  }
744  static unsigned
745  hwloc_synthetic_next_index(struct hwloc_synthetic_indexes_s *indexes, hwloc_obj_type_t type)
746  {
747    unsigned os_index = indexes->next++;
748    if (indexes->array)
749      os_index = indexes->array[os_index];
750    else if (hwloc__obj_type_is_cache(type) || type == HWLOC_OBJ_GROUP)
751      os_index = HWLOC_UNKNOWN_INDEX;
752    return os_index;
753  }
754  static void
755  hwloc_synthetic_insert_attached(struct hwloc_topology *topology,
756  				struct hwloc_synthetic_backend_data_s *data,
757  				struct hwloc_synthetic_attached_s *attached,
758  				hwloc_bitmap_t set)
759  {
760    hwloc_obj_t child;
761    unsigned attached_os_index;
762    if (!attached)
763      return;
764    assert(attached->attr.type == HWLOC_OBJ_NUMANODE);
765    attached_os_index = hwloc_synthetic_next_index(&data->numa_attached_indexes, HWLOC_OBJ_NUMANODE);
766    child = hwloc_alloc_setup_object(topology, attached->attr.type, attached_os_index);
767    child->cpuset = hwloc_bitmap_dup(set);
768    child->nodeset = hwloc_bitmap_alloc();
769    hwloc_bitmap_set(child->nodeset, attached_os_index);
770    hwloc_synthetic_set_attr(&attached->attr, child);
771    hwloc__insert_object_by_cpuset(topology, NULL, child, "synthetic:attached");
772    hwloc_synthetic_insert_attached(topology, data, attached->next, set);
773  }
774  static void
775  hwloc__look_synthetic(struct hwloc_topology *topology,
776  		      struct hwloc_synthetic_backend_data_s *data,
777  		      int level,
778  		      hwloc_bitmap_t parent_cpuset)
779  {
780    hwloc_obj_t obj;
781    unsigned i;
782    struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];
783    hwloc_obj_type_t type = curlevel->attr.type;
784    hwloc_bitmap_t set;
785    unsigned os_index;
786    assert(hwloc__obj_type_is_normal(type) || type == HWLOC_OBJ_NUMANODE);
787    assert(type != HWLOC_OBJ_MACHINE);
788    os_index = hwloc_synthetic_next_index(&curlevel->indexes, type);
789    set = hwloc_bitmap_alloc();
790    if (!curlevel->arity) {
791      hwloc_bitmap_set(set, os_index);
792    } else {
793      for (i = 0; i < curlevel->arity; i++)
794        hwloc__look_synthetic(topology, data, level + 1, set);
795    }
796    hwloc_bitmap_or(parent_cpuset, parent_cpuset, set);
797    if (hwloc_filter_check_keep_object_type(topology, type)) {
798      obj = hwloc_alloc_setup_object(topology, type, os_index);
799      obj->cpuset = hwloc_bitmap_dup(set);
800      if (type == HWLOC_OBJ_NUMANODE) {
801        obj->nodeset = hwloc_bitmap_alloc();
802        hwloc_bitmap_set(obj->nodeset, os_index);
803      }
804      hwloc_synthetic_set_attr(&curlevel->attr, obj);
805      hwloc__insert_object_by_cpuset(topology, NULL, obj, "synthetic");
806    }
807    hwloc_synthetic_insert_attached(topology, data, curlevel->attached, set);
808    hwloc_bitmap_free(set);
809  }
810  static int
811  hwloc_look_synthetic(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
812  {
813    struct hwloc_topology *topology = backend->topology;
814    struct hwloc_synthetic_backend_data_s *data = backend->private_data;
815    hwloc_bitmap_t cpuset = hwloc_bitmap_alloc();
816    unsigned i;
817    assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
818    assert(!topology->levels[0][0]->cpuset);
819    hwloc_alloc_root_sets(topology->levels[0][0]);
820    topology->support.discovery->pu = 1;
821    topology->support.discovery->numa = 1; &bsol;* we add a single NUMA node if none is given */
822    topology->support.discovery->numa_memory = 1; &bsol;* specified or default size */
823    for (i = 0; data->level[i].arity > 0; i++)
824      data->level[i].indexes.next = 0;
825    data->numa_attached_indexes.next = 0;
826    data->level[i].indexes.next = 0;
827    topology->levels[0][0]->type = data->level[0].attr.type;
828    hwloc_synthetic_set_attr(&data->level[0].attr, topology->levels[0][0]);
829    for (i = 0; i < data->level[0].arity; i++)
830      hwloc__look_synthetic(topology, data, 1, cpuset);
831    hwloc_synthetic_insert_attached(topology, data, data->level[0].attached, cpuset);
832    hwloc_bitmap_free(cpuset);
833    hwloc_obj_add_info(topology->levels[0][0], "Backend", "Synthetic");
834    hwloc_obj_add_info(topology->levels[0][0], "SyntheticDescription", data->string);
835    return 0;
836  }
837  static void
838  hwloc_synthetic_backend_disable(struct hwloc_backend *backend)
839  {
840    struct hwloc_synthetic_backend_data_s *data = backend->private_data;
841    hwloc_synthetic_free_levels(data);
842    free(data->string);
843    free(data);
844  }
845  static struct hwloc_backend *
846  hwloc_synthetic_component_instantiate(struct hwloc_topology *topology,
847  				      struct hwloc_disc_component *component,
848  				      unsigned excluded_phases __hwloc_attribute_unused,
849  				      const void *_data1,
850  				      const void *_data2 __hwloc_attribute_unused,
851  				      const void *_data3 __hwloc_attribute_unused)
852  {
853    struct hwloc_backend *backend;
854    struct hwloc_synthetic_backend_data_s *data;
855    int err;
856    if (!_data1) {
857      const char *env = getenv("HWLOC_SYNTHETIC");
858      if (env) {
859        _data1 = env;
860      } else {
861        errno = EINVAL;
862        goto out;
863      }
864    }
865    backend = hwloc_backend_alloc(topology, component);
866    if (!backend)
867      goto out;
868    data = malloc(sizeof(*data));
869    if (!data) {
870      errno = ENOMEM;
871      goto out_with_backend;
872    }
873    err = hwloc_backend_synthetic_init(data, (const char *) _data1);
874    if (err < 0)
875      goto out_with_data;
876    backend->private_data = data;
877    backend->discover = hwloc_look_synthetic;
878    backend->disable = hwloc_synthetic_backend_disable;
879    backend->is_thissystem = 0;
880    return backend;
881   out_with_data:
882    free(data);
883   out_with_backend:
884    free(backend);
885   out:
886    return NULL;
887  }
888  static struct hwloc_disc_component hwloc_synthetic_disc_component = {
889    "synthetic",
890    HWLOC_DISC_PHASE_GLOBAL,
891    ~0,
892    hwloc_synthetic_component_instantiate,
893    30,
894    1,
895    NULL
896  };
897  const struct hwloc_component hwloc_synthetic_component = {
898    HWLOC_COMPONENT_ABI,
899    NULL, NULL,
900    HWLOC_COMPONENT_TYPE_DISC,
901    0,
902    &hwloc_synthetic_disc_component
903  };
904  static __hwloc_inline int
905  hwloc__export_synthetic_update_status(int *ret, char **tmp, ssize_t *tmplen, int res)
906  {
907    if (res < 0)
908      return -1;
909    *ret += res;
910    if (res >= *tmplen)
911      res = *tmplen>0 ? (int)(*tmplen) - 1 : 0;
912    *tmp += res;
913    *tmplen -= res;
914    return 0;
915  }
916  static __hwloc_inline void
917  hwloc__export_synthetic_add_char(int *ret, char **tmp, ssize_t *tmplen, char c)
918  {
919    if (*tmplen > 1) {
920      (*tmp)[0] = c;
921      (*tmp)[1] = '\0';
922      (*tmp)++;
923      (*tmplen)--;
924    }
925    (*ret)++;
926  }
927  static int
928  hwloc__export_synthetic_indexes(hwloc_obj_t *level, unsigned total,
929  				char *buffer, size_t buflen)
930  {
931    unsigned step = 1;
932    unsigned nr_loops = 0;
933    struct hwloc_synthetic_intlv_loop_s *loops = NULL, *tmploops;
934    hwloc_obj_t cur;
935    unsigned i, j;
936    ssize_t tmplen = buflen;
937    char *tmp = buffer;
938    int res, ret = 0;
939    if (level[0]->os_index)
940      goto exportall;
941    while (step != total) {
942      if (total % step)
943        goto exportall;
944      for(i=1; i<total; i++)
945        if (level[i]->os_index == step)
946  	break;
947      if (i == total)
948        goto exportall;
949      for(j=2; j<total/i; j++)
950        if (level[i*j]->os_index != step*j)
951  	break;
952      nr_loops++;
953      tmploops = realloc(loops, nr_loops*sizeof(*loops));
954      if (!tmploops)
955        goto exportall;
956      loops = tmploops;
957      loops[nr_loops-1].step = i;
958      loops[nr_loops-1].nb = j;
959      step *= j;
960    }
961    for(i=0; i<total; i++) {
962      unsigned ind = 0;
963      unsigned mul = 1;
964      for(j=0; j<nr_loops; j++) {
965        ind += (i / loops[j].step) % loops[j].nb * mul;
966        mul *= loops[j].nb;
967      }
968      if (level[i]->os_index != ind)
969        goto exportall;
970    }
971    for(j=0; j<nr_loops; j++) {
972      res = hwloc_snprintf(tmp, tmplen, "%u*%u%s", loops[j].step, loops[j].nb,
973  			 j == nr_loops-1 ? ")" : ":");
974      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0) {
975        free(loops);
976        return -1;
977      }
978    }
979    free(loops);
980    return ret;
981   exportall:
982    free(loops);
983    cur = level[0];
984    while (cur) {
985      res = hwloc_snprintf(tmp, tmplen, "%u%s", cur->os_index,
986  			 cur->next_cousin ? "," : ")");
987      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
988        return -1;
989      cur = cur->next_cousin;
990    }
991    return ret;
992  }
993  static int
994  hwloc__export_synthetic_obj_attr(struct hwloc_topology * topology,
995  				 hwloc_obj_t obj,
996  				 char *buffer, size_t buflen)
997  {
998    const char * separator = " ";
999    const char * prefix = "(";
1000    char cachesize[64] = "";
1001    char memsize[64] = "";
1002    int needindexes = 0;
1003    if (hwloc__obj_type_is_cache(obj->type) && obj->attr->cache.size) {
1004      snprintf(cachesize, sizeof(cachesize), "%ssize=%llu",
1005  	     prefix, (unsigned long long) obj->attr->cache.size);
1006      prefix = separator;
1007    }
1008    if (obj->type == HWLOC_OBJ_NUMANODE && obj->attr->numanode.local_memory) {
1009      snprintf(memsize, sizeof(memsize), "%smemory=%llu",
1010  	     prefix, (unsigned long long) obj->attr->numanode.local_memory);
1011      prefix = separator;
1012    }
1013    if (!obj->logical_index &bsol;* only display indexes once per level (not for non-first NUMA children, etc.) */
1014        && (obj->type == HWLOC_OBJ_PU || obj->type == HWLOC_OBJ_NUMANODE)) {
1015      hwloc_obj_t cur = obj;
1016      while (cur) {
1017        if (cur->os_index != cur->logical_index) {
1018  	needindexes = 1;
1019  	break;
1020        }
1021        cur = cur->next_cousin;
1022      }
1023    }
1024    if (*cachesize || *memsize || needindexes) {
1025      ssize_t tmplen = buflen;
1026      char *tmp = buffer;
1027      int res, ret = 0;
1028      res = hwloc_snprintf(tmp, tmplen, "%s%s%s", cachesize, memsize, needindexes ? "" : ")");
1029      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1030        return -1;
1031      if (needindexes) {
1032        unsigned total;
1033        hwloc_obj_t *level;
1034        if (obj->depth < 0) {
1035  	assert(obj->depth == HWLOC_TYPE_DEPTH_NUMANODE);
1036  	total = topology->slevels[HWLOC_SLEVEL_NUMANODE].nbobjs;
1037  	level = topology->slevels[HWLOC_SLEVEL_NUMANODE].objs;
1038        } else {
1039  	total = topology->level_nbobjects[obj->depth];
1040  	level = topology->levels[obj->depth];
1041        }
1042        res = hwloc_snprintf(tmp, tmplen, "%sindexes=", prefix);
1043        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1044  	return -1;
1045        res = hwloc__export_synthetic_indexes(level, total, tmp, tmplen);
1046        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1047  	return -1;
1048      }
1049      return ret;
1050    } else {
1051      return 0;
1052    }
1053  }
1054  static int
1055  hwloc__export_synthetic_obj(struct hwloc_topology * topology, unsigned long flags,
1056  			    hwloc_obj_t obj, unsigned arity,
1057  			    char *buffer, size_t buflen)
1058  {
1059    char aritys[12] = "";
1060    ssize_t tmplen = buflen;
1061    char *tmp = buffer;
1062    int res, ret = 0;
1063    if (arity != (unsigned)-1)
1064      snprintf(aritys, sizeof(aritys), ":%u", arity);
1065    if (hwloc__obj_type_is_cache(obj->type)
1066        && (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES)) {
1067      res = hwloc_snprintf(tmp, tmplen, "Cache%s", aritys);
1068    } else if (obj->type == HWLOC_OBJ_PACKAGE
1069  	     && (flags & (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1070  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1071      res = hwloc_snprintf(tmp, tmplen, "Socket%s", aritys);
1072    } else if (obj->type == HWLOC_OBJ_DIE
1073  	     && (flags & (HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1074  			  |HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1))) {
1075      res = hwloc_snprintf(tmp, tmplen, "Group%s", aritys);
1076    } else if (obj->type == HWLOC_OBJ_GROUP &bsol;* don't export group depth */
1077        || flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES) {
1078      res = hwloc_snprintf(tmp, tmplen, "%s%s", hwloc_obj_type_string(obj->type), aritys);
1079    } else {
1080      char types[64];
1081      hwloc_obj_type_snprintf(types, sizeof(types), obj, 1);
1082      res = hwloc_snprintf(tmp, tmplen, "%s%s", types, aritys);
1083    }
1084    if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1085      return -1;
1086    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1087      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1088      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1089        return -1;
1090    }
1091    return ret;
1092  }
1093  static int
1094  hwloc__export_synthetic_memory_children(struct hwloc_topology * topology, unsigned long flags,
1095  					hwloc_obj_t parent,
1096  					char *buffer, size_t buflen,
1097  					int needprefix, int verbose)
1098  {
1099    hwloc_obj_t mchild;
1100    ssize_t tmplen = buflen;
1101    char *tmp = buffer;
1102    int res, ret = 0;
1103    mchild = parent->memory_first_child;
1104    if (!mchild)
1105      return 0;
1106    if (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1107      if (parent->memory_arity > 1 || mchild->type != HWLOC_OBJ_NUMANODE) {
1108        if (verbose)
1109  	fprintf(stderr, "Cannot export to synthetic v1 if multiple memory children are attached to the same location.\n");
1110        errno = EINVAL;
1111        return -1;
1112      }
1113      if (needprefix)
1114        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1115      res = hwloc__export_synthetic_obj(topology, flags, mchild, 1, tmp, tmplen);
1116      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1117        return -1;
1118      return ret;
1119    }
1120    while (mchild) {
1121      hwloc_obj_t numanode = mchild;
1122      while (numanode && numanode->type != HWLOC_OBJ_NUMANODE) {
1123        assert(numanode->arity == 1);
1124        numanode = numanode->memory_first_child;
1125      }
1126      assert(numanode); &bsol;* there's always a numanode at the bottom of the memory tree */
1127      if (needprefix)
1128        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1129      hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, '[');
1130      res = hwloc__export_synthetic_obj(topology, flags, numanode, (unsigned)-1, tmp, tmplen);
1131      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1132        return -1;
1133      hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ']');
1134      needprefix = 1;
1135      mchild = mchild->next_sibling;
1136    }
1137    return ret;
1138  }
1139  static int
1140  hwloc_check_memory_symmetric(struct hwloc_topology * topology)
1141  {
1142    hwloc_bitmap_t remaining_nodes;
1143    remaining_nodes = hwloc_bitmap_dup(hwloc_get_root_obj(topology)->nodeset);
1144    if (!remaining_nodes)
1145      return -1;
1146    while (!hwloc_bitmap_iszero(remaining_nodes)) {
1147      unsigned idx;
1148      hwloc_obj_t node;
1149      hwloc_obj_t first_parent;
1150      unsigned i;
1151      idx = hwloc_bitmap_first(remaining_nodes);
1152      node = hwloc_get_numanode_obj_by_os_index(topology, idx);
1153      assert(node);
1154      first_parent = node->parent;
1155      for(i=0; i<hwloc_get_nbobjs_by_depth(topology, first_parent->depth); i++) {
1156        hwloc_obj_t parent, mchild;
1157        parent = hwloc_get_obj_by_depth(topology, first_parent->depth, i);
1158        assert(parent);
1159        if (parent->memory_arity != first_parent->memory_arity)
1160  	goto out_with_bitmap;
1161        mchild = parent->memory_first_child;
1162        while (mchild) {
1163  	hwloc_bitmap_clr(remaining_nodes, mchild->os_index); &bsol;* cannot use parent->nodeset, some normal children may have other NUMA nodes */
1164  	mchild = mchild->next_sibling;
1165        }
1166      }
1167    }
1168    hwloc_bitmap_free(remaining_nodes);
1169    return 0;
1170   out_with_bitmap:
1171    hwloc_bitmap_free(remaining_nodes);
1172    return -1;
1173  }
1174  int
1175  hwloc_topology_export_synthetic(struct hwloc_topology * topology,
1176  				char *buffer, size_t buflen,
1177  				unsigned long flags)
1178  {
1179    hwloc_obj_t obj = hwloc_get_root_obj(topology);
1180    ssize_t tmplen = buflen;
1181    char *tmp = buffer;
1182    int res, ret = 0;
1183    unsigned arity;
1184    int needprefix = 0;
1185    int verbose = 0;
1186    const char *env = getenv("HWLOC_SYNTHETIC_VERBOSE");
1187    if (env)
1188      verbose = atoi(env);
1189    if (!topology->is_loaded) {
1190      errno = EINVAL;
1191      return -1;
1192    }
1193    if (flags & ~(HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES
1194  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS
1195  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1
1196  		|HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1197      errno = EINVAL;
1198      return -1;
1199    }
1200    if (!obj->symmetric_subtree) {
1201      if (verbose)
1202        fprintf(stderr, "Cannot export to synthetic unless topology is symmetric (root->symmetric_subtree must be set).\n");
1203      errno = EINVAL;
1204      return -1;
1205    }
1206    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)
1207        && hwloc_check_memory_symmetric(topology) < 0) {
1208      if (verbose)
1209        fprintf(stderr, "Cannot export to synthetic unless memory is attached symmetrically.\n");
1210      errno = EINVAL;
1211      return -1;
1212    }
1213    if (flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1) {
1214      hwloc_obj_t node;
1215      signed pdepth;
1216      node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
1217      assert(node);
1218      assert(hwloc__obj_type_is_normal(node->parent->type)); &bsol;* only depth-1 memory children for now */
1219      pdepth = node->parent->depth;
1220      while ((node = node->next_cousin) != NULL) {
1221        assert(hwloc__obj_type_is_normal(node->parent->type)); &bsol;* only depth-1 memory children for now */
1222        if (node->parent->depth != pdepth) {
1223  	if (verbose)
1224  	  fprintf(stderr, "Cannot export to synthetic v1 if memory is attached to parents at different depths.\n");
1225  	errno = EINVAL;
1226  	return -1;
1227        }
1228      }
1229    }
1230    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS)) {
1231      res = hwloc__export_synthetic_obj_attr(topology, obj, tmp, tmplen);
1232      if (res > 0)
1233        needprefix = 1;
1234      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1235        return -1;
1236    }
1237    if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1238      res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, needprefix, verbose);
1239      if (res > 0)
1240        needprefix = 1;
1241      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1242        return -1;
1243    }
1244    arity = obj->arity;
1245    while (arity) {
1246      obj = obj->first_child;
1247      if (needprefix)
1248        hwloc__export_synthetic_add_char(&ret, &tmp, &tmplen, ' ');
1249      res = hwloc__export_synthetic_obj(topology, flags, obj, arity, tmp, tmplen);
1250      if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1251        return -1;
1252      if (!(flags & HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY)) {
1253        res = hwloc__export_synthetic_memory_children(topology, flags, obj, tmp, tmplen, 1, verbose);
1254        if (hwloc__export_synthetic_update_status(&ret, &tmp, &tmplen, res) < 0)
1255  	return -1;
1256      }
1257      needprefix = 1;
1258      arity = obj->arity;
1259    }
1260    return ret;
1261  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-synthetic.c</div>
                </div>
                <div class="column column_space"><pre><code>273      endptr += 3;
274    } else if (!hwloc_strncasecmp(endptr, "GB", 2)) {
275      size *= 1000ULL*1000ULL*1000ULL;
</pre></code></div>
                <div class="column column_space"><pre><code>282      endptr += 2;
283    } else if (!hwloc_strncasecmp(endptr, "MiB", 3)) {
284      size <<= 20;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    