<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for im_gfadd.c &amp; vips7compat.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for im_gfadd.c &amp; vips7compat.c
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>im_gfadd.c (11.068703%)<th>vips7compat.c (0.71165645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(67-73)<td><a href="#" name="0">(829-836)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(139-150)<td><a href="#" name="1">(5150-5167)</a><td align="center"><font color="#cf0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>im_gfadd.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 <a name="0"></a>#include &lt;vips/vips7compat.h&gt;
9 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static int array[8][8] = {
10 	};
11 #define select_outdouble(IN2, OUT)\
12 	switch(tmp1-&gt;BandFmt) {\
13 		case IM_BANDFMT_DOUBLE:	loop(double, IN2, OUT); break;\
14 		default:       im_error("im_gfadd","Wrong tmp1 format(d)");\
15 				free( line); return( -1 );\
16 	}
17 #define outfloat_2uchar(IN2, OUT)\
18 		case IM_BANDFMT_UCHAR:	loop(unsigned char, IN2, OUT); break;\
19 		case IM_BANDFMT_CHAR:	loop(signed char, IN2, OUT); break;\
20 		case IM_BANDFMT_USHORT:	loop(unsigned short, IN2, OUT); break;\
21 		case IM_BANDFMT_SHORT:	loop(signed short, IN2, OUT); break;\
22 		case IM_BANDFMT_UINT:	loop(unsigned int, IN2, OUT); break;\
23 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
24 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
25 #define outfloat_2char(IN2, OUT)\
26 		case IM_BANDFMT_CHAR:	loop(signed char, IN2, OUT); break;\
27 		case IM_BANDFMT_USHORT:	loop(unsigned short, IN2, OUT); break;\
28 		case IM_BANDFMT_SHORT:	loop(signed short, IN2, OUT); break;\
29 		case IM_BANDFMT_UINT:	loop(unsigned int, IN2, OUT); break;\
30 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
31 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
32 #define outfloat_2ushort(IN2, OUT)\
33 		case IM_BANDFMT_USHORT:	loop(unsigned short, IN2, OUT); break;\
34 		case IM_BANDFMT_SHORT:	loop(signed short, IN2, OUT); break;\
35 		case IM_BANDFMT_UINT:	loop(unsigned int, IN2, OUT); break;\
36 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
37 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
38 #define outfloat_2short(IN2, OUT)\
39 		case IM_BANDFMT_SHORT:	loop(signed short, IN2, OUT); break;\
40 		case IM_BANDFMT_UINT:	loop(unsigned int, IN2, OUT); break;\
41 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
42 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
43 #define outfloat_2uint(IN2, OUT)\
44 		case IM_BANDFMT_UINT:	loop(unsigned int, IN2, OUT); break;\
45 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
46 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
47 #define outfloat_2int(IN2, OUT)\
48 		case IM_BANDFMT_INT:	loop(signed int, IN2, OUT); break;\
49 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
50 #define outfloat_2float(IN2, OUT)\
51 		case IM_BANDFMT_FLOAT:	loop(float, IN2, OUT); break; 
52 int im_gfadd(double a, IMAGE *in1, double b, IMAGE *in2, double c, IMAGE *out)
53 {
54 	static int fmt[] = { IM_BANDFMT_FLOAT, IM_BANDFMT_DOUBLE };
55 	int y, x;
56 <a name="1"></a>	int first, second, result;
57 	IMAGE *tmp1, *tmp2;
58 	PEL *line;
59 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int os; 	
60         if ((im_iocheck(in1, out) == -1) || (im_iocheck(in2, out) == -1))
61 		{ im_error("im_gfadd"," im_iocheck failed"); return( -1 ); }
62 	if ( (in1-&gt;Xsize != in2-&gt;Xsize) || (in1-&gt;Ysize != in2-&gt;Ysize) ||
63 	     (in1-&gt;Bands != in2-&gt;Bands) || (in1-&gt;Coding != in2-&gt;Coding) )
64 		{ im_error("im_gfadd"," Input images differ"); return( -1 );}
65 	if (in1-&gt;Coding != IM_CODING_NONE)
66 		{ im_error("im_gfadd"," images are coded"); return( -1 ); }</b></font>
67 	switch(in1-&gt;BandFmt) {
68 		case IM_BANDFMT_UCHAR:	first = 0; break;
69 		case IM_BANDFMT_CHAR:	first = 1; break;
70 		case IM_BANDFMT_USHORT:	first = 2; break;
71 		case IM_BANDFMT_SHORT:	first = 3; break;
72 		case IM_BANDFMT_UINT:	first = 4; break;
73 		case IM_BANDFMT_INT:	first = 5; break;
74 		case IM_BANDFMT_FLOAT:	first = 6; break;
75 		case IM_BANDFMT_DOUBLE:	first = 7; break;
76 		default: im_error("im_gfadd"," unable to accept image1");
77 				return( -1 );
78 		}
79 	switch(in2-&gt;BandFmt) {
80 		case IM_BANDFMT_UCHAR:	second = 0; break;
81 		case IM_BANDFMT_CHAR:	second = 1; break;
82 		case IM_BANDFMT_USHORT:	second = 2; break;
83 		case IM_BANDFMT_SHORT:	second = 3; break;
84 		case IM_BANDFMT_UINT:	second = 4; break;
85 		case IM_BANDFMT_INT:	second = 5; break;
86 		case IM_BANDFMT_FLOAT:	second = 6; break;
87 		case IM_BANDFMT_DOUBLE:	second = 7; break;
88 		default: im_error("im_gfadd"," unable to accept image2");
89 			return( -1 );
90 		}
91 	result = array[first][second];
92 	if ( im_cp_desc(out, in1) == -1)
93 		{ im_error("im_gfadd"," im_cp_desc failed"); return( -1 ); }
94 	out-&gt;BandFmt = fmt[result];
95 	if( im_setupout(out) == -1)
96 		{ im_error("im_gfadd"," im_setupout failed"); return( -1 ); }
97 	if ( first &gt;= second )
98 		{ tmp1 = in1; tmp2 = in2; }
99 	else
100 		{ tmp1 = in2; tmp2 = in1; }
101 #define loop(IN1, IN2, OUT)\
102 	{	IN1 *input1 = (IN1 *) tmp1-&gt;data;\
103 	 	IN2 *input2 = (IN2 *) tmp2-&gt;data;\
104 		\
105 		for (y=0; y &lt;out-&gt;Ysize; y++) {\
106 			OUT *cpline = (OUT*)line;\
107 			for (x=0; x&lt;os; x++)\
108 				*cpline++ = (a*((OUT)*input1++) + \
109 					b*((OUT)*input2++) + c);\
110 			if (im_writeline(y, out, line) ) {\
111 				im_error("im_gfadd"," im_writeline failed");\
112 				free( line);\
113 				return( -1 );\
114 			}\
115 		}\
116 	}
117 	os = out-&gt;Xsize * out-&gt;Bands;
118 	line = (PEL *) calloc ( (unsigned)os, sizeof(double) );
119 	if (line == NULL)
120 		{ im_error("im_gfadd"," unable to calloc"); return( -1 ); }
121 	switch (out-&gt;BandFmt)	{
122 		case IM_BANDFMT_DOUBLE: 
123 			switch (tmp2-&gt;BandFmt)	{
124 			case IM_BANDFMT_UCHAR:	
125 				select_outdouble(unsigned char, double); 
126 				break;
127 			case IM_BANDFMT_CHAR:	
128 				select_outdouble(signed char, double); 
129 				break;
130 			case IM_BANDFMT_USHORT:	
131 				select_outdouble(unsigned short, double); 
132 				break;
133 			case IM_BANDFMT_SHORT:	
134 				select_outdouble(signed short, double); 
135 				break;
136 			case IM_BANDFMT_UINT:	
137 				select_outdouble(unsigned int, double); 
138 				break;
139 			case IM_BANDFMT_INT:	
140 				select_outdouble(signed int, double); 
141 				break;
142 			case IM_BANDFMT_FLOAT:	
143 				select_outdouble(float, double); 
144 				break;
145 			case IM_BANDFMT_DOUBLE:	
146 				select_outdouble(double, double); 
147 				break;
148 			default:	
149 				im_error("im_gfadd","Wrong tmp2 format(d)");
150 				free( line ); 
151 				return( -1 );
152 			}
153 			break;
154 		case IM_BANDFMT_FLOAT :
155 			switch (tmp2-&gt;BandFmt)	{
156 			case IM_BANDFMT_UCHAR:	
157 				switch (tmp1-&gt;BandFmt) {
158 				outfloat_2uchar(unsigned char, float);
159 				default:
160 					im_error("im_gfadd"," Error (a)");
161 					free( line ); 
162 					return( -1 );
163 				}
164 				break;
165 			case IM_BANDFMT_CHAR:	
166 				switch (tmp1-&gt;BandFmt) {
167 				outfloat_2char(signed char, float);
168 				default:
169 					im_error("im_gfadd"," Error (b)");
170 					free( line); return( -1 );
171 				}
172 				break;
173 			case IM_BANDFMT_USHORT:	
174 				switch (tmp1-&gt;BandFmt) {
175 				outfloat_2ushort(unsigned short, float);
176 				default:
177 					im_error("im_gfadd"," Error (c)");
178 					free( line); return( -1 );
179 				}
180 				break;
181 			case IM_BANDFMT_SHORT:	
182 				switch (tmp1-&gt;BandFmt) {
183 				outfloat_2short(signed short, float);
184 				default:
185 					im_error("im_gfadd"," Error (d)");
186 					free( line); return( -1 );
187 				}
188 				break;
189 			case IM_BANDFMT_UINT:	
190 				switch (tmp1-&gt;BandFmt) {
191 				outfloat_2uint(unsigned int, float);
192 				default:
193 					im_error("im_gfadd"," Error (e)");
194 					free( line); return( -1 );
195 				}
196 				break;
197 			case IM_BANDFMT_INT:	
198 				switch (tmp1-&gt;BandFmt) {
199 				outfloat_2int(signed int,  float);
200 				default:
201 					im_error("im_gfadd"," Error (f)");
202 					free( line ); 
203 					return( -1 );
204 				}
205 				break;
206 			case IM_BANDFMT_FLOAT:	
207 				switch (tmp1-&gt;BandFmt) {
208 				outfloat_2float(float,  float);
209 				default:
210 					im_error("im_gfadd"," Error (g)");
211 					free( line ); 
212 					return( -1 );
213 				}
214 				break;
215 			default:	
216 				im_error("im_gfadd"," Wrong tmp2 format(f)");
217 				free( line ); 
218 				return( -1 );
219 			}
220 			break;
221 		default:
222 			im_error("im_gfadd"," Impossible output state");
223 			free( line ); 
224 			return( -1 );
225 		}
226 	free( line );
227 	return( 0 );
228 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vips7compat.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;ctype.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/vips7compat.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include &lt;vips/debug.h&gt;
12 #include &lt;vips/vector.h&gt;
13 #include &lt;vips/transform.h&gt;
14 void
15 im_filename_split( const char *path, char *name, char *mode )
16 {
17         char *p;
18 	size_t len;
19         vips_strncpy( name, path, FILENAME_MAX );
20 	strcpy( mode, "" );
21 	if( (len = strlen( name )) == 0 ) 
22 	       return;	
23 	for( p = name + len - 1; p &gt; name; p -= 1 )
24 		if( *p == ':' ) {
25 			char *q;
26 			for( q = p - 1; isalnum( *q ) &amp;&amp; q &gt; name; q -= 1 )
27 				;
28 			if( *q == '.' ) {
29 				break;
30 			}
31 			if( q == name )
32 				break;
33 			if( *q == '/' || 
34 				*q == '\\' )
35 				break;
36 		}
37 	if( *p == ':' &amp;&amp;
38 		p - name != 1 ) {
39                 vips_strncpy( mode, p + 1, FILENAME_MAX );
40                 *p = '\0';
41         }
42 }
43 char *
44 vips_path_filename7( const char *path )
45 {
46 	char name[FILENAME_MAX];
47 	char mode[FILENAME_MAX];
48 	im_filename_split( path, name, mode );
49 	return( g_strdup( name ) );
50 }
51 char *
52 vips_path_mode7( const char *path )
53 {
54 	char name[FILENAME_MAX];
55 	char mode[FILENAME_MAX];
56 	im_filename_split( path, name, mode );
57 	return( g_strdup( mode ) );
58 }
59 const char *
60 im_skip_dir( const char *path )
61 {
62 	char name[FILENAME_MAX];
63 	char mode[FILENAME_MAX];
64         const char *p;
65         const char *q;
66 	const char native_dir_sep = G_DIR_SEPARATOR;
67 	const char non_native_dir_sep = native_dir_sep == '/' ? '\\' : '/';
68 	im_filename_split( path, name, mode );
69 	p = name + strlen( name );
70 	for( q = p; q &gt; name &amp;&amp; q[-1] != native_dir_sep; q-- )
71 		;
72 	if( q == name )
73 		for( q = p; q &gt; name &amp;&amp; q[-1] != non_native_dir_sep; q-- )
74 			;
75         return( path + (q - name) );
76 }
77 void
78 im_filename_suffix( const char *path, char *suffix )
79 {
80 	char name[FILENAME_MAX];
81 	char mode[FILENAME_MAX];
82         char *p;
83 	im_filename_split( path, name, mode );
84         if( (p = strrchr( name, '.' )) ) 
85                 strcpy( suffix, p );
86         else
87                 strcpy( suffix, "" );
88 }
89 int
90 im_filename_suffix_match( const char *path, const char *suffixes[] )
91 {
92 	char suffix[FILENAME_MAX];
93 	const char **p;
94 	im_filename_suffix( path, suffix );
95 	for( p = suffixes; *p; p++ )
96 		if( g_ascii_strcasecmp( suffix, *p ) == 0 )
97 			return( 1 );
98 	return( 0 );
99 }
100 char *
101 im_getnextoption( char **in )
102 {
103         char *p;
104         char *q;
105         p = *in;
106         q = p;
107         if( !p || !*p )
108                 return( NULL );
109 	for(;;) {
110 		if( !(p = strchr( p, ',' )) )
111 			break;
112 		if( p == q )
113 			break;
114 		if( p[-1] != '\\' )
115 			break;
116 		p += 1;
117 	}
118         if( p ) {
119                 *p = '\0';
120                 *in = p + 1;
121         }
122         else {
123                 *in = NULL;
124         }
125         if( strlen( q ) &gt; 0 )
126                 return( q );
127         else
128                 return( NULL );
129 }
130 char *
131 im_getsuboption( const char *buf )
132 {
133         char *p, *q, *r;
134         if( !(p = strchr( buf, ':' )) ) 
135 		return( NULL );
136 	p += 1;
137 	for( q = p; *q; q++ ) 
138 		if( q[0] == '\\' &amp;&amp; q[1] == ',' )
139 			for( r = q; *r; r++ )
140 				r[0] = r[1];
141         return( p );
142 }
143 VipsImage *
144 im_open( const char *filename, const char *mode )
145 {
146 	VipsImage *image;
147 	vips_check_init(); 
148 	if( strcmp( mode, "r" ) == 0 ||
149 		strcmp( mode, "rd" ) == 0 ) {
150 		if( !(image = vips__deprecated_open_read( filename, FALSE )) )
151 			return( NULL );
152 	}
153 	else if( strcmp( mode, "rs" ) == 0 ) { 
154 		if( !(image = vips__deprecated_open_read( filename, TRUE )) )
155 			return( NULL );
156 	}
157 	else if( strcmp( mode, "w" ) == 0 ) {
158 		if( !(image = vips__deprecated_open_write( filename )) )
159 			return( NULL );
160 	}
161 	else {
162 		if( !(image = vips_image_new_mode( filename, mode )) )
163 			return( NULL );
164 	}
165 	return( image );
166 }
167 VipsImage *
168 im_open_local( VipsImage *parent, 
169 	const char *filename, const char *mode )
170 {
171 	VipsImage *image;
172 	if( !(image = im_open( filename, mode )) )
173 		return( NULL );
174 	vips_object_local( parent, image );
175 	return( image );
176 }
177 int
178 im_open_local_array( VipsImage *parent, 
179 	VipsImage **images, int n,
180 	const char *filename, const char *mode )
181 {
182 	int i;
183 	for( i = 0; i &lt; n; i++ )
184 		if( !(images[i] = im_open_local( parent, filename, mode )) )
185 			return( -1 );
186 	return( 0 );
187 }
188 typedef struct {
189 	im_callback_fn fn;
190 	void *a;
191 	void *b;
192 } Callback;
193 static void
194 im_add_callback_cb( VipsImage *im, Callback *callback )
195 {
196 	if( callback-&gt;fn( callback-&gt;a, callback-&gt;b ) )
197 		vips_image_set_kill( im, TRUE );
198 }
199 int 
200 im_add_callback( VipsImage *im, 
201 	const char *name, im_callback_fn fn, void *a, void *b )
202 {
203 	Callback *callback;
204 	callback = VIPS_NEW( VIPS_OBJECT( im ), Callback );
205 	callback-&gt;fn = fn;
206 	callback-&gt;a = a;
207 	callback-&gt;b = b;
208 	g_signal_connect( im, name,
209 		G_CALLBACK( im_add_callback_cb ), callback );
210 	return( 0 );
211 }
212 static void
213 im_add_callback_cb1( VipsImage *im, void *x, Callback *callback )
214 {
215 	if( callback-&gt;fn( callback-&gt;a, callback-&gt;b ) )
216 		vips_image_set_kill( im, TRUE );
217 }
218 int 
219 im_add_callback1( VipsImage *im, 
220 	const char *name, im_callback_fn fn, void *a, void *b )
221 {
222 	Callback *callback;
223 	callback = VIPS_NEW( VIPS_OBJECT( im ), Callback );
224 	callback-&gt;fn = fn;
225 	callback-&gt;a = a;
226 	callback-&gt;b = b;
227 	g_signal_connect( im, name,
228 		G_CALLBACK( im_add_callback_cb1 ), callback );
229 	return( 0 );
230 }
231 void *
232 im_local( IMAGE *im, 
233 	im_construct_fn cons, im_callback_fn dest, void *a, void *b, void *c )
234 {
235 	void *obj;
236 	if( !im ) {
237 		im_error( "im_local", "%s", _( "NULL image descriptor" ) );
238 		return( NULL );
239 	}
240         if( !(obj = cons( a, b, c )) )
241                 return( NULL );
242         if( im_add_close_callback( im, (im_callback_fn) dest, obj, a ) ) {
243                 dest( obj, a );
244                 return( NULL );
245         }
246         return( obj );
247 }
248 int
249 im_local_array( IMAGE *im, void **out, int n,
250 	im_construct_fn cons, im_callback_fn dest, void *a, void *b, void *c )
251 {
252 	int i;
253 	for( i = 0; i &lt; n; i++ )
254 		if( !(out[i] = im_local( im, cons, dest, a, b, c )) )
255 			return( -1 );
256 	return( 0 );
257 }
258 int
259 im_close( VipsImage *im )
260 {
261 	g_object_unref( im );
262 	return( 0 );
263 }
264 VipsImage *
265 im_init( const char *filename )
266 {
267 	VipsImage *image;
268 	image = vips_image_new();
269 	IM_SETSTR( image-&gt;filename, filename );
270 	return( image );
271 }
272 int
273 im_init_world( const char *argv0 )
274 {
275 	return( vips_init( argv0 ) );
276 }
277 const char *im_Type2char( VipsInterpretation type ) 
278 	{ return( vips_enum_string( VIPS_TYPE_INTERPRETATION, type ) ); }
279 const char *im_BandFmt2char( VipsBandFormat format ) 
280 	{ return( vips_enum_string( VIPS_TYPE_BAND_FORMAT, format ) ); }
281 const char *im_Coding2char( VipsCoding coding ) 
282 	{ return( vips_enum_string( VIPS_TYPE_CODING, coding ) ); }
283 const char *im_dtype2char( VipsImageType n ) 
284 	{ return( vips_enum_string( VIPS_TYPE_IMAGE_TYPE, n ) ); }
285 const char *im_dhint2char( VipsDemandStyle style ) 
286 	{ return( vips_enum_string( VIPS_TYPE_DEMAND_STYLE, style ) ); }
287 static const char *im_Type[] = {
288 	"IM_TYPE_MULTIBAND", 			"IM_TYPE_B_W", 				"LUMINACE", 				"XRAY", 				"IR", 					"YUV", 					"RED_ONLY", 				"GREEN_ONLY", 				"BLUE_ONLY", 				"POWER_SPECTRUM", 			"IM_TYPE_HISTOGRAM", 			"LUT", 					"IM_TYPE_XYZ",				"IM_TYPE_LAB", 				"CMC", 					"IM_TYPE_CMYK", 			"IM_TYPE_LABQ", 			"IM_TYPE_RGB", 				"IM_TYPE_UCS", 				"IM_TYPE_LCH", 				"IM_TYPE_LABS",				"&lt;unknown&gt;", 				"IM_TYPE_sRGB", 			"IM_TYPE_YXY", 				"IM_TYPE_FOURIER",			"IM_TYPE_RGB16",			"IM_TYPE_GREY16",			NULL
289 };
290 static const char *im_BandFmt[] = {
291 	"IM_BANDFMT_UCHAR", 
292 	"IM_BANDFMT_CHAR", 
293 	"IM_BANDFMT_USHORT", 
294 	"IM_BANDFMT_SHORT", 
295 	"IM_BANDFMT_UINT", 
296 	"IM_BANDFMT_INT", 
297 	"IM_BANDFMT_FLOAT", 
298 	"IM_BANDFMT_COMPLEX", 
299 	"IM_BANDFMT_DOUBLE", 
300 	"IM_BANDFMT_DPCOMPLEX",
301 	NULL
302 };
303 static const char *im_Coding[] = {
304 	"IM_CODING_NONE", 
305 	"COLQUANT8", 
306 	"IM_CODING_LABQ", 
307 	"IM_CODING_LABQ_COMPRESSED",
308 	"RGB_COMPRESSED",
309 	"LUM_COMPRESSED",
310 	"IM_CODING_RAD",
311 	NULL
312 };
313 static const char *im_dtype[] = {
314 	"IM_NONE", 
315 	"IM_SETBUF", 
316 	"IM_SETBUF_FOREIGN", 
317 	"IM_OPENIN", 
318 	"IM_MMAPIN", 
319 	"IM_MMAPINRW", 
320 	"IM_OPENOUT", 
321 	"IM_PARTIAL",
322 	NULL
323 };
324 static const char *im_dhint[] = {
325 	"IM_SMALLTILE", 
326 	"IM_FATSTRIP", 
327 	"IM_THINSTRIP", 
328 	"IM_ANY",
329 	NULL
330 };
331 static int
332 lookup_enum( GType type, const char *names[], const char *name )
333 {
334 	GEnumClass *class;
335 	GEnumValue *value;
336 	int i;
337 	class = g_type_class_ref( type );
338 	if( (value = g_enum_get_value_by_nick( class, name )) )
339 		return( value-&gt;value );
340 	if( (value = g_enum_get_value_by_name( class, name )) )
341 		return( value-&gt;value );
342 	for( i = 0; names[i]; i++ )
343 		if( g_ascii_strcasecmp( names[i], name ) == 0 )
344 			return( i );
345 	return( -1 );
346 }
347 VipsInterpretation im_char2Type( const char *str ) 
348 	{ return( lookup_enum( VIPS_TYPE_INTERPRETATION, im_Type, str ) ); }
349 VipsBandFormat im_char2BandFmt( const char *str ) 
350 	{ return( lookup_enum( VIPS_TYPE_BAND_FORMAT, im_BandFmt, str ) ); }
351 VipsCoding im_char2Coding( const char *str ) 
352 	{ return( lookup_enum( VIPS_TYPE_CODING, im_Coding, str ) ); }
353 VipsImageType im_char2dtype( const char *str ) 
354 	{ return( lookup_enum( VIPS_TYPE_IMAGE_TYPE, im_dtype, str ) ); }
355 VipsDemandStyle im_char2dhint( const char *str ) 
356 	{ return( lookup_enum( VIPS_TYPE_DEMAND_STYLE, im_dhint, str ) ); }
357 const char *im_Compression2char( int n ) { return( "NONE" ); }
358 int im_char2Compression( const char *str ) { return( -1 ); }
359 typedef struct {
360 	im_wrapmany_fn fn;		void *a, *b;		} Bundle;
361 #define MAX_INPUT_IMAGES (64)
362 static int
363 process_region( VipsRegion *or, void *seq, void *a, void *b )
364 {
365 	VipsRegion **ir = (VipsRegion **) seq;
366 	Bundle *bun = (Bundle *) b;
367 	PEL *p[MAX_INPUT_IMAGES], *q;
368 	int i, y;
369 	if( vips_reorder_prepare_many( or-&gt;im, ir, &amp;or-&gt;valid ) ) 
370 		return( -1 );
371 	for( i = 0; ir[i]; i++ ) 
372 		p[i] = (PEL *) VIPS_REGION_ADDR( ir[i], 
373 			or-&gt;valid.left, or-&gt;valid.top );
374 	p[i] = NULL;
375 	q = (PEL *) VIPS_REGION_ADDR( or, or-&gt;valid.left, or-&gt;valid.top );
376 	for( y = 0; y &lt; or-&gt;valid.height; y++ ) {
377 		PEL *p1[MAX_INPUT_IMAGES];
378 		for( i = 0; ir[i]; i++ )
379 			p1[i] = p[i];
380 		bun-&gt;fn( (void **) ((void *)p1), q, 
381 			or-&gt;valid.width, bun-&gt;a, bun-&gt;b );
382 		for( i = 0; ir[i]; i++ )
383 			p[i] += VIPS_REGION_LSKIP( ir[i] );
384 		q += VIPS_REGION_LSKIP( or );
385 	}
386 	return( 0 );
387 }
388 static IMAGE **
389 dupims( IMAGE *out, IMAGE **in )
390 {
391 	IMAGE **new;
392 	int i, n;
393 	for( n = 0; in[n]; n++ )
394 		;
395 	new = VIPS_ARRAY( VIPS_OBJECT( out ), n + 1, IMAGE * );
396 	for( i = 0; i &lt; n; i++ )
397 		new[i] = in[i];
398 	new[n] = NULL;
399 	return( new );
400 }
401 int
402 im_wrapmany( IMAGE **in, IMAGE *out, im_wrapmany_fn fn, void *a, void *b )
403 {
404 	Bundle *bun;
405 	int i, n;
406 	for( n = 0; in[n]; n++ )
407 		;
408 	if( n &gt;= MAX_INPUT_IMAGES - 1 ) {
409 		vips_error( "im_wrapmany", "%s", _( "too many input images" ) );
410 		return( -1 );
411 	}
412 	bun = VIPS_NEW( VIPS_OBJECT( out ), Bundle );
413 	if( !(in = dupims( out, in )) )
414 		return( -1 );
415 	bun-&gt;fn = fn;
416 	bun-&gt;a = a;
417 	bun-&gt;b = b;
418 	for( i = 0; i &lt; n; i++ ) {
419 		if( in[i]-&gt;Xsize != out-&gt;Xsize || in[i]-&gt;Ysize != out-&gt;Ysize ) {
420 			vips_error( "im_wrapmany", 
421 				"%s", _( "descriptors differ in size" ) );
422 			return( -1 );
423 		}
424 		if( vips_image_pio_input( in[i] ) )
425 			return( -1 );
426 	}
427 	vips__demand_hint_array( out, VIPS_DEMAND_STYLE_THINSTRIP, in );
428 	if( vips__reorder_set_input( out, in ) )
429 		return( -1 ); 
430 	if( vips_image_generate( out,
431 		vips_start_many, (VipsGenerateFn) process_region, 
432 		vips_stop_many, in, bun ) )
433 		return( -1 );
434 	return( 0 );
435 }
436 static void
437 wrapone_gen( void **ins, void *out, int width, Bundle *bun, void *dummy )
438 {
439 	((im_wrapone_fn) (bun-&gt;fn)) (ins[0], out, width, bun-&gt;a, bun-&gt;b );
440 }
441 int
442 im_wrapone( IMAGE *in, IMAGE *out, im_wrapone_fn fn, void *a, void *b )
443 {
444 	Bundle *bun;
445 	IMAGE *invec[2];
446 	bun = VIPS_NEW( VIPS_OBJECT( out ), Bundle );
447 	bun-&gt;fn = (im_wrapmany_fn) fn;
448 	bun-&gt;a = a;
449 	bun-&gt;b = b;
450 	invec[0] = in; invec[1] = NULL;
451 	return( im_wrapmany( invec, out, 
452 		(im_wrapmany_fn) wrapone_gen, bun, NULL ) );
453 }
454 static void
455 wraptwo_gen( void **ins, void *out, int width, Bundle *bun, void *dummy )
456 {
457 	((im_wraptwo_fn) (bun-&gt;fn)) (ins[0], ins[1], out, 
458 		width, bun-&gt;a, bun-&gt;b );
459 }
460 int
461 im_wraptwo( IMAGE *in1, IMAGE *in2, IMAGE *out, 
462 	im_wraptwo_fn fn, void *a, void *b )
463 {
464 	Bundle *bun;
465 	IMAGE *invec[3];
466 	bun = VIPS_NEW( VIPS_OBJECT( out ), Bundle );
467 	bun-&gt;fn = (im_wrapmany_fn) fn;
468 	bun-&gt;a = a;
469 	bun-&gt;b = b;
470 	invec[0] = in1; invec[1] = in2; invec[2] = NULL;
471 	return( im_wrapmany( invec, out, 
472 		(im_wrapmany_fn) wraptwo_gen, bun, NULL ) );
473 }
474 #define UC IM_BANDFMT_UCHAR
475 #define C IM_BANDFMT_CHAR
476 #define US IM_BANDFMT_USHORT
477 #define S IM_BANDFMT_SHORT
478 #define UI IM_BANDFMT_UINT
479 #define I IM_BANDFMT_INT
480 #define F IM_BANDFMT_FLOAT
481 #define X IM_BANDFMT_COMPLEX
482 #define D IM_BANDFMT_DOUBLE
483 #define DX IM_BANDFMT_DPCOMPLEX
484 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int bandfmt_largest[6][6] = {
485 };
486 static VipsBandFmt
487 im__format_common( VipsBandFmt in1, VipsBandFmt in2 )
488 {
489 	if( vips_band_format_iscomplex( in1 ) || 
490 		vips_band_format_iscomplex( in2 ) ) {
491 		if( in1 == IM_BANDFMT_DPCOMPLEX || in2 == IM_BANDFMT_DPCOMPLEX )
492 			return( IM_BANDFMT_DPCOMPLEX );
493 		else
494 			return( IM_BANDFMT_COMPLEX );
495 	}
496 	else if( vips_bandfmt_isfloat( in1 ) || 
497 		vips_bandfmt_isfloat( in2 ) ) {
498 		if( in1 == IM_BANDFMT_DOUBLE || in2 == IM_BANDFMT_DOUBLE )
499 			return( IM_BANDFMT_DOUBLE );
500 		else
501 			return( IM_BANDFMT_FLOAT );
502 	}
503 	else 
504 		return( bandfmt_largest[in1][in2] );
505 }
506 int
507 im__formatalike_vec( IMAGE **in, IMAGE **out, int n )
508 {
509 	int i;
510 	VipsBandFmt fmt;
511 	g_assert( n &gt;= 1 );
512 	fmt = in[0]-&gt;BandFmt;
513 	for( i = 1; i &lt; n; i++ )
514 		fmt = im__format_common( fmt, in[i]-&gt;BandFmt );
515 	for( i = 0; i &lt; n; i++ )
516 		if( im_clip2fmt( in[i], out[i], fmt ) )
517 			return( -1 );
518 	return( 0 );
519 }
520 int
521 im__formatalike( IMAGE *in1, IMAGE *in2, IMAGE *out1, IMAGE *out2 )
522 {
523 	IMAGE *in[2];
524 	IMAGE *out[2];
525 	in[0] = in1;
526 	in[1] = in2;
527 	out[0] = out1;
528 	out[1] = out2;
529 	return( im__formatalike_vec( in, out, 2 ) );
530 }
531 int
532 im__bandup( const char *domain, IMAGE *in, IMAGE *out, int n )
533 {
534 	IMAGE *bands[256];
535 	int i;
536 	if( in-&gt;Bands == n ) 
537 		return( vips_image_write( in, out ) );
538 	if( in-&gt;Bands != 1 ) {
539 		im_error( domain, _( "not one band or %d bands" ), n );
540 		return( -1 );
541 	}
542 	if( n &gt; 256 || n &lt; 1 ) {
543 		im_error( domain, "%s", _( "bad bands" ) );
544 		return( -1 );
545 	}
546 	for( i = 0; i &lt; n; i++ )
547 		bands[i] = in;
548 	return( im_gbandjoin( bands, out, n ) );
549 }
550 int
551 im__bandalike_vec( const char *domain, IMAGE **in, IMAGE **out, int n )
552 {
553 	int i;
554 	int max_bands;
555 	g_assert( n &gt;= 1 );
556 	max_bands = in[0]-&gt;Bands;
557 	for( i = 1; i &lt; n; i++ )
558 		max_bands = IM_MAX( max_bands, in[i]-&gt;Bands );
559 	for( i = 0; i &lt; n; i++ )
560 		if( im__bandup( domain, in[i], out[i], max_bands ) )
561 			return( -1 );
562 	return( 0 );
563 }
564 int
565 im__bandalike( const char *domain, 
566 	IMAGE *in1, IMAGE *in2, IMAGE *out1, IMAGE *out2 )
567 {
568 	IMAGE *in[2];
569 	IMAGE *out[2];
570 	in[0] = in1;
571 	in[1] = in2;
572 	out[0] = out1;
573 	out[1] = out2;
574 	if( im__bandalike_vec( domain, in, out, 2 ) )
575 		return( -1 );
576 	return( 0 );
577 }
578 VipsVector *
579 im__init_program( VipsVector *vectors[IM_BANDFMT_LAST], 
580 	VipsBandFmt format_table[IM_BANDFMT_LAST], VipsBandFmt fmt )
581 {
582 	int isize = im__sizeof_bandfmt[fmt];
583 	int osize = im__sizeof_bandfmt[format_table[fmt]];
584 	VipsVector *v;
585 	v = vips_vector_new( "binary arith", osize );
586 	vips_vector_source_name( v, "s1", isize );
587 	vips_vector_source_name( v, "s2", isize );
588 	vips_vector_temporary( v, "t1", osize );
589 	vips_vector_temporary( v, "t2", osize );
590 	vectors[fmt] = v;
591 	return( v );
592 }
593 void
594 im__compile_programs( VipsVector *vectors[IM_BANDFMT_LAST] )
595 {
596 	int fmt;
597 	for( fmt = 0; fmt &lt; IM_BANDFMT_LAST; fmt++ ) {
598 		if( vectors[fmt] &amp;&amp;
599 			!vips_vector_compile( vectors[fmt] ) )
600 			IM_FREEF( vips_vector_free, vectors[fmt] );
601 	}
602 #ifdef DEBUG
603 	printf( "im__compile_programs: " );
604 	for( fmt = 0; fmt &lt; IM_BANDFMT_LAST; fmt++ ) 
605 		if( vectors[fmt] )
606 			printf( "%s ", im_BandFmt2char( fmt ) );
607 	printf( "\n" );
608 }
609 int 
610 im_add( IMAGE *in1, IMAGE *in2, IMAGE *out )
611 {
612 	VipsImage *x;
613 	if( vips_call( "add", in1, in2, &amp;x, NULL ) )
614 		return( -1 );
615 	if( vips_image_write( x, out ) ) {
616 		g_object_unref( x );
617 		return( -1 );
618 	}
619 	g_object_unref( x );
620 	return( 0 );
621 }
622 int 
623 im_subtract( IMAGE *in1, IMAGE *in2, IMAGE *out )
624 {
625 	VipsImage *x;
626 	if( vips_call( "subtract", in1, in2, &amp;x, NULL ) )
627 		return( -1 );
628 	if( vips_image_write( x, out ) ) {
629 		g_object_unref( x );
630 		return( -1 );
631 	}
632 	g_object_unref( x );
633 	return( 0 );
634 }
635 int 
636 im_multiply( IMAGE *in1, IMAGE *in2, IMAGE *out )
637 {
638 	VipsImage *x;
639 	if( vips_call( "multiply", in1, in2, &amp;x, NULL ) )
640 		return( -1 );
641 	if( vips_image_write( x, out ) ) {
642 		g_object_unref( x );
643 		return( -1 );
644 	}
645 	g_object_unref( x );
646 	return( 0 );
647 }
648 int 
649 im_divide( IMAGE *in1, IMAGE *in2, IMAGE *out )
650 {
651 	VipsImage *x;
652 	if( vips_call( "divide", in1, in2, &amp;x, NULL ) )
653 		return( -1 );
654 	if( vips_image_write( x, out ) ) {
655 		g_object_unref( x );
656 		return( -1 );
657 	}
658 	g_object_unref( x );
659 	return( 0 );
660 }
661 int
662 im_avg( IMAGE *in, double *out )
663 {
664 	return( vips_avg( in, out, NULL ) ); 
665 }
666 int
667 im_deviate( IMAGE *in, double *out )
668 {
669 	return( vips_deviate( in, out, NULL ) ); 
670 }
671 int im_generate( VipsImage *im,
672 	im_start_fn start, im_generate_fn generate, im_stop_fn stop,
673 	void *a, void *b )
674 {
675 	return( vips_image_generate( im, 
676 		start, (VipsGenerateFn) generate, stop, a, b ) );
677 }
678 int
679 im_minpos( IMAGE *in, int *xpos, int *ypos, double *out )
680 {
681 	return( vips_min( in, out, "x", xpos, "y", ypos, NULL ) );
682 }
683 int
684 im_min( IMAGE *in, double *out )
685 {
686 	return( im_minpos( in, NULL, NULL, out ) );
687 }
688 int
689 im_maxpos( IMAGE *in, int *xpos, int *ypos, double *out )
690 {
691 	return( vips_max( in, out, "x", xpos, "y", ypos, NULL ) );
692 }
693 int
694 im_max( IMAGE *in, double *out )
695 {
696 	return( im_maxpos( in, NULL, NULL, out ) );
697 }
698 #define MAX_IMAGES 100
699 int
700 im_demand_hint (IMAGE * im, VipsDemandStyle hint, ...)
701 {
702   va_list ap;
703   int i;
704   IMAGE *ar[MAX_IMAGES];
705   va_start (ap, hint);
706   for (i = 0; i &lt; MAX_IMAGES &amp;&amp; (ar[i] = va_arg (ap, IMAGE *)); i++)
707     ;
708   va_end (ap);
709   if (i == MAX_IMAGES)
710     {
711       im_error ("im_demand_hint", "%s", _("too many images"));
712       return (-1);
713     }
714   vips__demand_hint_array (im, hint, ar);
715   return (0);
716 }
717 int
718 im_cp_descv (IMAGE * im, ...)
719 {
720   va_list ap;
721   int i;
722   IMAGE *ar[MAX_IMAGES];
723   va_start (ap, im);
724   for (i = 0; i &lt; MAX_IMAGES &amp;&amp; (ar[i] = va_arg (ap, IMAGE *)); i++)
725     ;
726   va_end (ap);
727   if (i == MAX_IMAGES)
728     {
729       im_error ("im_cp_descv", "%s", _("too many images"));
730       return (-1);
731     }
732   return (vips__image_copy_fields_array (im, ar));
733 }
734 int
735 im_cp_desc(IMAGE *out, IMAGE *in )
736 {
737 	return( im_cp_descv( out, in, NULL)); 
738 }
739 int 
740 im_copy_set( IMAGE *in, IMAGE *out, 
741 	VipsType type, float xres, float yres, int xoffset, int yoffset )
742 {
743 	VipsImage *x;
744 	if( vips_copy( in, &amp;x, 
745 		"interpretation", type, 
746 		"xres", xres, 
747 		"yres", yres, 
748 		"xoffset", xoffset, 
749 		"yoffset", yoffset, 
750 		NULL ) )
751 		return( -1 );
752 	if( vips_image_write( x, out ) ) {
753 		g_object_unref( x );
754 		return( -1 );
755 	}
756 	g_object_unref( x );
757 	return( 0 );
758 }
759 int 
760 im_copy_morph( IMAGE *in, IMAGE *out, 
761 	int bands, VipsBandFmt bandfmt, VipsCoding coding )
762 {
763 	VipsImage *x;
764 	if( vips_copy( in, &amp;x, 
765 		"bands", bands, 
766 		"format", bandfmt, 
767 		"coding", coding, 
768 		NULL ) )
769 		return( -1 );
770 	if( vips_image_write( x, out ) ) {
771 		g_object_unref( x );
772 		return( -1 );
773 	}
774 	g_object_unref( x );
775 	return( 0 );
776 }
777 int
778 im_copy( IMAGE *in, IMAGE *out )
779 {
780 	return( vips_image_write( in, out ) ); 
781 }
782 int
783 im_copy_swap( IMAGE *in, IMAGE *out )
784 {
785 	VipsImage *x;
786 	if( vips_byteswap( in, &amp;x, NULL ) )
787 		return( -1 );
788 	if( vips_image_write( x, out ) ) {
789 		g_object_unref( x );
790 		return( -1 );
791 	}
792 	g_object_unref( x );
793 	return( 0 );
794 }
795 int
796 im_copy_set_meta( IMAGE *in, IMAGE *out, const char *field, GValue *value )
797 {
798 	if( vips_image_write( in, out ) )
799 		return( -1 );
800 	(void) im_meta_set( out, field, value );
801 	return( 0 );
802 }
803 int
804 im_copy_native( IMAGE *in, IMAGE *out, gboolean is_msb_first )
805 {
806 	if( is_msb_first != im_amiMSBfirst() )
807 		return( im_copy_swap( in, out ) );
808 	else
809 		return( vips_image_write( in, out ) );
810 }
811 int
812 im_embed( IMAGE *in, IMAGE *out, int type, int x, int y, int width, int height )
813 {
814 	VipsImage *t;
815 	if( vips_embed( in, &amp;t, x, y, width, height,
816 		"extend", type, 
817 		NULL ) )
818 		return( -1 );
819 	if( vips_image_write( t, out ) ) {
820 		g_object_unref( t );
821 		return( -1 );
822 	}
823 	g_object_unref( t );
824 	return( 0 );
825 }
826 int 
827 im_fliphor( IMAGE *in, IMAGE *out )
828 {
829 	VipsImage *t;
830 	if( vips_flip( in, &amp;t, VIPS_DIRECTION_HORIZONTAL, NULL ) )
831 		return( -1 );
832 	if( vips_image_write( t, out ) ) {
833 		g_object_unref( t );
834 		return( -1 );
835 	}
836 	g_object_unref( t );
837 	return( 0 );
838 }
839 int 
840 im_rot90( IMAGE *in, IMAGE *out )
841 {
842 	VipsImage *t;
843 	if( vips_rot( in, &amp;t, VIPS_ANGLE_D90, NULL ) )
844 		return( -1 );
845 	if( vips_image_write( t, out ) ) {
846 		g_object_unref( t );
847 		return( -1 );
848 	}
849 	g_object_unref( t );
850 	return( 0 );
851 }
852 int 
853 im_rot180( IMAGE *in, IMAGE *out )
854 {
855 	VipsImage *t;
856 	if( vips_rot( in, &amp;t, VIPS_ANGLE_D180, NULL ) )
857 		return( -1 );
858 	if( vips_image_write( t, out ) ) {
859 		g_object_unref( t );
860 		return( -1 );
861 	}
862 	g_object_unref( t );
863 	return( 0 );
864 }
865 int 
866 im_rot270( IMAGE *in, IMAGE *out )
867 {
868 	VipsImage *t;
869 	if( vips_rot( in, &amp;t, VIPS_ANGLE_D270, NULL ) )
870 		return( -1 );
871 	if( vips_image_write( t, out ) ) {
872 		g_object_unref( t );
873 		return( -1 );
874 	}
875 	g_object_unref( t );
876 	return( 0 );
877 }
878 int 
879 im_flipver( IMAGE *in, IMAGE *out )
880 {
881 	VipsImage *t;
882 	if( vips_flip( in, &amp;t, VIPS_DIRECTION_VERTICAL, NULL ) )
883 		return( -1 );
884 	if( vips_image_write( t, out ) ) {
885 		g_object_unref( t );
886 		return( -1 );
887 	}
888 	g_object_unref( t );
889 	return( 0 );
890 }
891 int 
892 im_insert( IMAGE *main, IMAGE *sub, IMAGE *out, int x, int y )
893 {
894 	VipsImage *t;
895 	if( vips_insert( main, sub, &amp;t, x, y, 
896 		"expand", TRUE, 
897 		NULL ) )
898 		return( -1 );
899 	if( vips_image_write( t, out ) ) {
900 		g_object_unref( t );
901 		return( -1 );
902 	}
903 	g_object_unref( t );
904 	return( 0 );
905 }
906 int 
907 im_insert_noexpand( IMAGE *main, IMAGE *sub, IMAGE *out, int x, int y )
908 {
909 	VipsImage *t;
910 	if( vips_insert( main, sub, &amp;t, x, y, NULL ) )
911 		return( -1 );
912 	if( vips_image_write( t, out ) ) {
913 		g_object_unref( t );
914 		return( -1 );
915 	}
916 	g_object_unref( t );
917 	return( 0 );
918 }
919 int 
920 im_lrjoin( IMAGE *left, IMAGE *right, IMAGE *out )
921 {
922 	VipsImage *t;
923 	if( vips_join( left, right, &amp;t, VIPS_DIRECTION_HORIZONTAL,
924 		NULL ) )
925 		return( -1 );
926 	if( vips_image_write( t, out ) ) {
927 		g_object_unref( t );
928 		return( -1 );
929 	}
930 	g_object_unref( t );
931 	return( 0 );
932 }
933 int 
934 im_tbjoin( IMAGE *left, IMAGE *right, IMAGE *out )
935 {
936 	VipsImage *t;
937 	if( vips_join( left, right, &amp;t, VIPS_DIRECTION_VERTICAL,
938 		NULL ) )
939 		return( -1 );
940 	if( vips_image_write( t, out ) ) {
941 		g_object_unref( t );
942 		return( -1 );
943 	}
944 	g_object_unref( t );
945 	return( 0 );
946 }
947 int
948 im_extract_area( IMAGE *in, IMAGE *out, 
949 	int left, int top, int width, int height )
950 {
951 	VipsImage *t;
952 	if( vips_extract_area( in, &amp;t, left, top, width, height,
953 		NULL ) )
954 		return( -1 );
955 	if( vips_image_write( t, out ) ) {
956 		g_object_unref( t );
957 		return( -1 );
958 	}
959 	g_object_unref( t );
960 	return( 0 );
961 }
962 int 
963 im_extract_bands( IMAGE *in, IMAGE *out, int band, int nbands )
964 {
965 	VipsImage *t;
966 	if( vips_extract_band( in, &amp;t, band,
967 		"n", nbands,
968 		NULL ) )
969 		return( -1 );
970 	if( vips_image_write( t, out ) ) {
971 		g_object_unref( t );
972 		return( -1 );
973 	}
974 	g_object_unref( t );
975 	return( 0 );
976 }
977 int 
978 im_extract_band( IMAGE *in, IMAGE *out, int band )
979 {
980 	return( im_extract_bands( in, out, band, 1 ) ); 
981 }
982 int
983 im_extract_areabands( IMAGE *in, IMAGE *out, 
984 	int left, int top, int width, int height, int band, int nbands )
985 {
986 	VipsImage *t1, *t2;
987 	if( vips_extract_area( in, &amp;t1, left, top, width, height,
988 		NULL ) )
989 		return( -1 );
990 	if( vips_extract_band( t1, &amp;t2, band,
991 		"n", nbands,
992 		NULL ) ) {
993 		g_object_unref( t1 );
994 		return( -1 );
995 	}
996 	g_object_unref( t1 );
997 	if( vips_image_write( t2, out ) ) {
998 		g_object_unref( t2 );
999 		return( -1 );
1000 	}
1001 	g_object_unref( t2 );
1002 	return( 0 );
1003 }
1004 int 
1005 im_replicate( IMAGE *in, IMAGE *out, int across, int down )
1006 {
1007 	VipsImage *t;
1008 	if( vips_replicate( in, &amp;t, across, down,
1009 		NULL ) )
1010 		return( -1 );
1011 	if( vips_image_write( t, out ) ) {
1012 		g_object_unref( t );
1013 		return( -1 );
1014 	}
1015 	g_object_unref( t );
1016 	return( 0 );
1017 }
1018 int 
1019 im_clip2fmt( IMAGE *in, IMAGE *out, VipsBandFmt fmt ) 
1020 {
1021 	VipsImage *t;
1022 	if( vips_cast( in, &amp;t, fmt,
1023 		NULL ) )
1024 		return( -1 );
1025 	if( vips_image_write( t, out ) ) {
1026 		g_object_unref( t );
1027 		return( -1 );
1028 	}
1029 	g_object_unref( t );
1030 	return( 0 );
1031 }
1032 size_t 
1033 im_ref_string_get_length( const GValue *value )
1034 {
1035 	size_t length;
1036 	(void) vips_value_get_ref_string( value, &amp;length );
1037 	return( length );
1038 }
1039 int 
1040 im_bandjoin( VipsImage *in1, VipsImage *in2, VipsImage *out )
1041 {
1042 	VipsImage *t;
1043 	if( vips_bandjoin2( in1, in2, &amp;t, 
1044 		NULL ) )
1045 		return( -1 );
1046 	if( vips_image_write( t, out ) ) {
1047 		g_object_unref( t );
1048 		return( -1 );
1049 	}
1050 	g_object_unref( t );
1051 	return( 0 );
1052 }
1053 int 
1054 im_gbandjoin( VipsImage **in, VipsImage *out, int n )
1055 {
1056 	VipsImage *t;
1057 	if( vips_bandjoin( in, &amp;t, n,
1058 		NULL ) )
1059 		return( -1 );
1060 	if( vips_image_write( t, out ) ) {
1061 		g_object_unref( t );
1062 		return( -1 );
1063 	}
1064 	g_object_unref( t );
1065 	return( 0 );
1066 }
1067 int
1068 im_rank_image( VipsImage **in, VipsImage *out, int n, int index )
1069 {
1070 	VipsImage *t;
1071 	if( vips_bandrank( in, &amp;t, n,
1072 		"index", index,
1073 		NULL ) )
1074 		return( -1 );
1075 	if( vips_image_write( t, out ) ) {
1076 		g_object_unref( t );
1077 		return( -1 );
1078 	}
1079 	g_object_unref( t );
1080 	return( 0 );
1081 }
1082 int
1083 im_maxvalue( IMAGE **in, IMAGE *out, int n )
1084 {
1085 	return( im_rank_image( in, out, n, n - 1 ) );
1086 }
1087 int 
1088 im_invert( IMAGE *in, IMAGE *out )
1089 {
1090 	VipsImage *t;
1091 	if( vips_invert( in, &amp;t, 
1092 		NULL ) )
1093 		return( -1 );
1094 	if( vips_image_write( t, out ) ) {
1095 		g_object_unref( t );
1096 		return( -1 );
1097 	}
1098 	g_object_unref( t );
1099 	return( 0 );
1100 }
1101 int 
1102 im_sign( IMAGE *in, IMAGE *out )
1103 {
1104 	VipsImage *t;
1105 	if( vips_sign( in, &amp;t, 
1106 		NULL ) )
1107 		return( -1 );
1108 	if( vips_image_write( t, out ) ) {
1109 		g_object_unref( t );
1110 		return( -1 );
1111 	}
1112 	g_object_unref( t );
1113 	return( 0 );
1114 }
1115 int 
1116 im_abs( IMAGE *in, IMAGE *out )
1117 {
1118 	VipsImage *t;
1119 	if( vips_abs( in, &amp;t, 
1120 		NULL ) )
1121 		return( -1 );
1122 	if( vips_image_write( t, out ) ) {
1123 		g_object_unref( t );
1124 		return( -1 );
1125 	}
1126 	g_object_unref( t );
1127 	return( 0 );
1128 }
1129 int 
1130 im_bandmean( IMAGE *in, IMAGE *out )
1131 {
1132 	VipsImage *t;
1133 	if( vips_bandmean( in, &amp;t, 
1134 		NULL ) )
1135 		return( -1 );
1136 	if( vips_image_write( t, out ) ) {
1137 		g_object_unref( t );
1138 		return( -1 );
1139 	}
1140 	g_object_unref( t );
1141 	return( 0 );
1142 }
1143 int 
1144 im_lintra( double a, IMAGE *in, double b, IMAGE *out )
1145 {
1146 	VipsImage *t;
1147 	if( vips_linear1( in, &amp;t, a, b,
1148 		NULL ) )
1149 		return( -1 );
1150 	if( vips_image_write( t, out ) ) {
1151 		g_object_unref( t );
1152 		return( -1 );
1153 	}
1154 	g_object_unref( t );
1155 	return( 0 );
1156 }
1157 int 
1158 im_lintra_vec( int n, double *a, IMAGE *in, double *b, IMAGE *out )
1159 {
1160 	VipsImage *t;
1161 	if( vips_linear( in, &amp;t, a, b, n,
1162 		NULL ) )
1163 		return( -1 );
1164 	if( vips_image_write( t, out ) ) {
1165 		g_object_unref( t );
1166 		return( -1 );
1167 	}
1168 	g_object_unref( t );
1169 	return( 0 );
1170 }
1171 int 
1172 im_black( IMAGE *out, int x, int y, int bands )
1173 {
1174 	VipsImage *t;
1175 	if( vips_black( &amp;t, x, y,
1176 		"bands", bands,
1177 		NULL ) )
1178 		return( -1 );
1179 	if( vips_image_write( t, out ) ) {
1180 		g_object_unref( t );
1181 		return( -1 );
1182 	}
1183 	g_object_unref( t );
1184 	return( 0 );
1185 }
1186 int 
1187 im_identity_ushort( VipsImage *lut, int bands, int sz )
1188 {
1189 	VipsImage *t;
1190 	if( vips_identity( &amp;t, 
1191 		"bands", bands,
1192 		"ushort", TRUE,
1193 		"size", sz,
1194 		NULL ) )
1195 		return( -1 );
1196 	if( vips_image_write( t, lut ) ) {
1197 		g_object_unref( t );
1198 		return( -1 );
1199 	}
1200 	g_object_unref( t );
1201 	return( 0 );
1202 }
1203 int 
1204 im_identity( VipsImage *lut, int bands )
1205 {
1206 	VipsImage *t;
1207 	if( vips_identity( &amp;t, 
1208 		"bands", bands,
1209 		NULL ) )
1210 		return( -1 );
1211 	if( vips_image_write( t, lut ) ) {
1212 		g_object_unref( t );
1213 		return( -1 );
1214 	}
1215 	g_object_unref( t );
1216 	return( 0 );
1217 }
1218 int 
1219 im_gaussnoise( VipsImage *out, int x, int y, double mean, double sigma )
1220 {
1221 	VipsImage *t;
1222 	if( vips_gaussnoise( &amp;t, x, y,
1223 		"mean", mean,
1224 		"sigma", sigma,
1225 		NULL ) )
1226 		return( -1 );
1227 	if( vips_image_write( t, out ) ) {
1228 		g_object_unref( t );
1229 		return( -1 );
1230 	}
1231 	g_object_unref( t );
1232 	return( 0 );
1233 }
1234 int 
1235 im_grid( VipsImage *in, VipsImage *out, int tile_height, int across, int down )
1236 {
1237 	VipsImage *t;
1238 	if( vips_grid( in, &amp;t, tile_height, across, down, NULL ) )
1239 		return( -1 );
1240 	if( vips_image_write( t, out ) ) {
1241 		g_object_unref( t );
1242 		return( -1 );
1243 	}
1244 	g_object_unref( t );
1245 	return( 0 );
1246 }
1247 int 
1248 im_scale( VipsImage *in, VipsImage *out )
1249 {
1250 	VipsImage *t;
1251 	if( vips_scale( in, &amp;t, NULL ) )
1252 		return( -1 );
1253 	if( vips_image_write( t, out ) ) {
1254 		g_object_unref( t );
1255 		return( -1 );
1256 	}
1257 	g_object_unref( t );
1258 	return( 0 );
1259 }
1260 int 
1261 im_msb( VipsImage *in, VipsImage *out )
1262 {
1263 	VipsImage *t;
1264 	if( vips_msb( in, &amp;t, NULL ) )
1265 		return( -1 );
1266 	if( vips_image_write( t, out ) ) {
1267 		g_object_unref( t );
1268 		return( -1 );
1269 	}
1270 	g_object_unref( t );
1271 	return( 0 );
1272 }
1273 int 
1274 im_msb_band( VipsImage *in, VipsImage *out, int band )
1275 {
1276 	VipsImage *t;
1277 	if( vips_msb( in, &amp;t, "band", band, NULL ) )
1278 		return( -1 );
1279 	if( vips_image_write( t, out ) ) {
1280 		g_object_unref( t );
1281 		return( -1 );
1282 	}
1283 	g_object_unref( t );
1284 	return( 0 );
1285 }
1286 int
1287 im_make_xy( IMAGE *out, const int xsize, const int ysize )
1288 {
1289 	VipsImage *t;
1290 	if( vips_xyz( &amp;t, xsize, ysize, NULL ) )
1291 		return( -1 );
1292 	if( vips_image_write( t, out ) ) {
1293 		g_object_unref( t );
1294 		return( -1 );
1295 	}
1296 	g_object_unref( t );
1297 	return( 0 );
1298 }
1299 int
1300 im_zone( IMAGE *out, int size )
1301 {
1302 	VipsImage *t;
1303 	if( vips_zone( &amp;t, size, size, 
1304 		"uchar", TRUE,
1305 		NULL ) )
1306 		return( -1 );
1307 	if( vips_image_write( t, out ) ) {
1308 		g_object_unref( t );
1309 		return( -1 );
1310 	}
1311 	g_object_unref( t );
1312 	return( 0 );
1313 }
1314 int
1315 im_fzone( IMAGE *out, int size )
1316 {
1317 	VipsImage *t;
1318 	if( vips_zone( &amp;t, size, size, NULL ) )
1319 		return( -1 );
1320 	if( vips_image_write( t, out ) ) {
1321 		g_object_unref( t );
1322 		return( -1 );
1323 	}
1324 	g_object_unref( t );
1325 	return( 0 );
1326 }
1327 int 
1328 im_sines( IMAGE *out, int xsize, int ysize, double horfreq, double verfreq )
1329 {
1330 	VipsImage *t;
1331 	if( vips_sines( &amp;t, xsize, ysize, 
1332 		"hfreq", horfreq, 
1333 		"vfreq", verfreq, 
1334 		NULL ) )
1335 		return( -1 );
1336 	if( vips_image_write( t, out ) ) {
1337 		g_object_unref( t );
1338 		return( -1 );
1339 	}
1340 	g_object_unref( t );
1341 	return( 0 );
1342 }
1343 int 
1344 im_text( IMAGE *out, const char *text, const char *font, 
1345 	int width, int align, int dpi )
1346 {
1347 	VipsImage *t;
1348 	if( vips_text( &amp;t, text,
1349 		"font", font, 
1350 		"width", width, 
1351 		"align", align, 
1352 		"dpi", dpi, 
1353 		NULL ) )
1354 		return( -1 );
1355 	if( vips_image_write( t, out ) ) {
1356 		g_object_unref( t );
1357 		return( -1 );
1358 	}
1359 	g_object_unref( t );
1360 	return( 0 );
1361 }
1362 int 
1363 im_system( VipsImage *im, const char *cmd, char **out )
1364 {
1365 	VipsArea *area;
1366 	VipsImage **array;
1367 	char *str;
1368 	area = vips_area_new_array_object( 1 );
1369 	array = (VipsImage **) area-&gt;data;
1370 	array[0] = im;
1371 	if( vips_system( cmd, 
1372 		"in", area,
1373 		"in_format", "%s.v",
1374 		"log", &amp;str,
1375 		NULL ) ) {
1376 		vips_area_unref( area );
1377 		return( -1 );
1378 	}
1379 	vips_area_unref( area );
1380 	if( out )
1381 		*out = str;
1382 	return( 0 );
1383 }
1384 VipsImage *
1385 im_system_image( VipsImage *im,
1386 	const char *in_format, const char *out_format, const char *cmd_format,
1387 	char **log )
1388 {
1389 	VipsArrayImage *array;
1390 	char *str;
1391 	VipsImage *out; 
1392 	array = vips_array_image_newv( 1, im );
1393 	g_object_ref( im ); 
1394 	if( vips_system( cmd_format, 
1395 		"in", array,
1396 		"out", &amp;out,
1397 		"in_format", in_format,
1398 		"out_format", out_format,
1399 		"log", &amp;str,
1400 		NULL ) ) {
1401 		vips_area_unref( VIPS_AREA( array ) );
1402 		return( NULL );
1403 	}
1404 	vips_area_unref( VIPS_AREA( array ) );
1405 	if( log )
1406 		*log = str;
1407 	else
1408 		g_free( str ); 
1409 	return( out );
1410 }
1411 int
1412 im_wrap( IMAGE *in, IMAGE *out, int x, int y )
1413 {
1414 	VipsImage *t;
1415 	if( vips_wrap( in, &amp;t, "x", x, "y", y, NULL ) )
1416 		return( -1 );
1417 	if( vips_image_write( t, out ) ) {
1418 		g_object_unref( t );
1419 		return( -1 );
1420 	}
1421 	g_object_unref( t );
1422 	return( 0 );
1423 }
1424 int
1425 im_rotquad( IMAGE *in, IMAGE *out )
1426 {
1427 	return( im_wrap( in, out, in-&gt;Xsize / 2, in-&gt;Ysize / 2 ) );
1428 }
1429 int 
1430 im_scaleps( VipsImage *in, VipsImage *out )
1431 {
1432 	VipsImage *t;
1433 	if( vips_scale( in, &amp;t, "log", TRUE, NULL ) )
1434 		return( -1 );
1435 	if( vips_image_write( t, out ) ) {
1436 		g_object_unref( t );
1437 		return( -1 );
1438 	}
1439 	g_object_unref( t );
1440 	return( 0 );
1441 }
1442 int 
1443 im_zoom( VipsImage *in, VipsImage *out, int xfac, int yfac )
1444 {
1445 	VipsImage *t;
1446 	if( vips_zoom( in, &amp;t, xfac, yfac, NULL ) )
1447 		return( -1 );
1448 	if( vips_image_write( t, out ) ) {
1449 		g_object_unref( t );
1450 		return( -1 );
1451 	}
1452 	g_object_unref( t );
1453 	return( 0 );
1454 }
1455 int 
1456 im_subsample( VipsImage *in, VipsImage *out, int xfac, int yfac )
1457 {
1458 	VipsImage *t;
1459 	if( vips_subsample( in, &amp;t, xfac, yfac, NULL ) )
1460 		return( -1 );
1461 	if( vips_image_write( t, out ) ) {
1462 		g_object_unref( t );
1463 		return( -1 );
1464 	}
1465 	g_object_unref( t );
1466 	return( 0 );
1467 }
1468 static int
1469 vips__math( VipsImage *in, VipsImage *out, VipsOperationMath math )
1470 {
1471 	VipsImage *t;
1472 	if( vips_math( in, &amp;t, math,
1473 		NULL ) )
1474 		return( -1 );
1475 	if( vips_image_write( t, out ) ) {
1476 		g_object_unref( t );
1477 		return( -1 );
1478 	}
1479 	g_object_unref( t );
1480 	return( 0 );
1481 }
1482 int 
1483 im_sintra( IMAGE *in, IMAGE *out )
1484 {
1485 	return( vips__math( in, out, VIPS_OPERATION_MATH_SIN ) );
1486 }
1487 int 
1488 im_costra( IMAGE *in, IMAGE *out )
1489 {
1490 	return( vips__math( in, out, VIPS_OPERATION_MATH_COS ) );
1491 }
1492 int 
1493 im_tantra( IMAGE *in, IMAGE *out )
1494 {
1495 	return( vips__math( in, out, VIPS_OPERATION_MATH_TAN ) );
1496 }
1497 int 
1498 im_asintra( IMAGE *in, IMAGE *out )
1499 {
1500 	return( vips__math( in, out, VIPS_OPERATION_MATH_ASIN ) );
1501 }
1502 int 
1503 im_acostra( IMAGE *in, IMAGE *out )
1504 {
1505 	return( vips__math( in, out, VIPS_OPERATION_MATH_ACOS ) );
1506 }
1507 int 
1508 im_atantra( IMAGE *in, IMAGE *out )
1509 {
1510 	return( vips__math( in, out, VIPS_OPERATION_MATH_ATAN ) );
1511 }
1512 int 
1513 im_logtra( IMAGE *in, IMAGE *out )
1514 {
1515 	return( vips__math( in, out, VIPS_OPERATION_MATH_LOG ) );
1516 }
1517 int 
1518 im_log10tra( IMAGE *in, IMAGE *out )
1519 {
1520 	return( vips__math( in, out, VIPS_OPERATION_MATH_LOG10 ) );
1521 }
1522 int 
1523 im_exptra( IMAGE *in, IMAGE *out )
1524 {
1525 	return( vips__math( in, out, VIPS_OPERATION_MATH_EXP ) );
1526 }
1527 int 
1528 im_exp10tra( IMAGE *in, IMAGE *out )
1529 {
1530 	return( vips__math( in, out, VIPS_OPERATION_MATH_EXP10 ) );
1531 }
1532 DOUBLEMASK *
1533 im_stats( VipsImage *in )
1534 {
1535 	VipsImage *t;
1536 	DOUBLEMASK *msk;
1537 	if( vips_stats( in, &amp;t,
1538 		NULL ) )
1539 		return( NULL );
1540 	if( !(msk = im_vips2mask( t, "im_stats" )) ) {
1541 		g_object_unref( t );
1542 		return( NULL );
1543 	}
1544 	g_object_unref( t );
1545 	return( msk );
1546 }
1547 DOUBLEMASK *
1548 im_gauss_dmask( const char *filename, double sigma, double min_ampl )
1549 {
1550 	VipsImage *t;
1551 	DOUBLEMASK *msk;
1552 	if( vips_gaussmat( &amp;t, sigma, min_ampl,
1553 		"precision", VIPS_PRECISION_FLOAT,
1554 		NULL ) )
1555 		return( NULL );
1556 	if( !(msk = im_vips2mask( t, filename )) ) {
1557 		g_object_unref( t );
1558 		return( NULL );
1559 	}
1560 	g_object_unref( t );
1561 	return( msk );
1562 }
1563 DOUBLEMASK *
1564 im_gauss_dmask_sep( const char *filename, double sigma, double min_ampl )
1565 {
1566 	VipsImage *t;
1567 	DOUBLEMASK *msk;
1568 	if( vips_gaussmat( &amp;t, sigma, min_ampl,
1569 		"precision", VIPS_PRECISION_FLOAT,
1570 		"separable", TRUE,
1571 		NULL ) )
1572 		return( NULL );
1573 	if( !(msk = im_vips2mask( t, filename )) ) {
1574 		g_object_unref( t );
1575 		return( NULL );
1576 	}
1577 	g_object_unref( t );
1578 	return( msk );
1579 }
1580 INTMASK *
1581 im_gauss_imask( const char *filename, double sigma, double min_ampl )
1582 {
1583 	VipsImage *t;
1584 	INTMASK *msk;
1585 	if( vips_gaussmat( &amp;t, sigma, min_ampl, NULL ) )
1586 		return( NULL );
1587 	if( !(msk = im_vips2imask( t, filename )) ) {
1588 		g_object_unref( t );
1589 		return( NULL );
1590 	}
1591 	g_object_unref( t );
1592 	return( msk );
1593 }
1594 INTMASK *
1595 im_gauss_imask_sep( const char *filename, double sigma, double min_ampl )
1596 {
1597 	VipsImage *t;
1598 	INTMASK *msk;
1599 	if( vips_gaussmat( &amp;t, sigma, min_ampl,
1600 		"separable", TRUE,
1601 		NULL ) )
1602 		return( NULL );
1603 	if( !(msk = im_vips2imask( t, filename )) ) {
1604 		g_object_unref( t );
1605 		return( NULL );
1606 	}
1607 	g_object_unref( t );
1608 	return( msk );
1609 }
1610 INTMASK *
1611 im_log_imask( const char *filename, double sigma, double min_ampl )
1612 {
1613 	VipsImage *t;
1614 	INTMASK *msk;
1615 	if( vips_logmat( &amp;t, sigma, min_ampl, NULL ) )
1616 		return( NULL );
1617 	if( !(msk = im_vips2imask( t, filename )) ) {
1618 		g_object_unref( t );
1619 		return( NULL );
1620 	}
1621 	g_object_unref( t );
1622 	return( msk );
1623 }
1624 DOUBLEMASK *
1625 im_log_dmask( const char *filename, double sigma, double min_ampl )
1626 {
1627 	VipsImage *t;
1628 	DOUBLEMASK *msk;
1629 	if( vips_logmat( &amp;t, sigma, min_ampl,
1630 		"precision", VIPS_PRECISION_FLOAT,
1631 		NULL ) )
1632 		return( NULL );
1633 	if( !(msk = im_vips2mask( t, filename )) ) {
1634 		g_object_unref( t );
1635 		return( NULL );
1636 	}
1637 	g_object_unref( t );
1638 	return( msk );
1639 }
1640 int 
1641 im_recomb( IMAGE *in, IMAGE *out, DOUBLEMASK *recomb )
1642 {
1643 	VipsImage *t1, *t2;
1644 	if( !(t1 = vips_image_new()) ||
1645 		im_mask2vips( recomb, t1 ) )
1646 		return( -1 );
1647 	if( vips_recomb( in, &amp;t2, t1, 
1648 		NULL ) ) {
1649 		g_object_unref( t1 );
1650 		return( -1 );
1651 	}
1652 	g_object_unref( t1 );
1653 	if( vips_image_write( t2, out ) ) {
1654 		g_object_unref( t2 );
1655 		return( -1 );
1656 	}
1657 	g_object_unref( t2 );
1658 	return( 0 );
1659 }
1660 int 
1661 im_compass( VipsImage *in, VipsImage *out, INTMASK *mask )
1662 {
1663 	VipsImage *t1, *t2;
1664 	if( !(t1 = vips_image_new()) ||
1665 		im_imask2vips( mask, t1 ) )
1666 		return( -1 );
1667 	if( vips_compass( in, &amp;t2, t1, 
1668 		"times", 8, 
1669 		"angle", VIPS_ANGLE45_D45, 
1670 		"precision", VIPS_PRECISION_INTEGER,
1671 		NULL ) ) {
1672 		g_object_unref( t1 );
1673 		return( -1 );
1674 	}
1675 	g_object_unref( t1 );
1676 	if( vips_image_write( t2, out ) ) {
1677 		g_object_unref( t2 );
1678 		return( -1 );
1679 	}
1680 	g_object_unref( t2 );
1681 	return( 0 );
1682 }
1683 int 
1684 im_lindetect( IMAGE *in, IMAGE *out, INTMASK *mask )
1685 {
1686 	VipsImage *t1, *t2;
1687 	if( !(t1 = vips_image_new()) ||
1688 		im_imask2vips( mask, t1 ) )
1689 		return( -1 );
1690 	if( vips_compass( in, &amp;t2, t1, 
1691 		"times", 4, 
1692 		"angle", VIPS_ANGLE45_D45, 
1693 		"precision", VIPS_PRECISION_INTEGER,
1694 		NULL ) ) {
1695 		g_object_unref( t1 );
1696 		return( -1 );
1697 	}
1698 	g_object_unref( t1 );
1699 	if( vips_image_write( t2, out ) ) {
1700 		g_object_unref( t2 );
1701 		return( -1 );
1702 	}
1703 	g_object_unref( t2 );
1704 	return( 0 );
1705 }
1706 int
1707 im_gradient( IMAGE *in, IMAGE *out, INTMASK *mask )
1708 {
1709 	VipsImage *t1, *t2;
1710 	if( !(t1 = vips_image_new()) ||
1711 		im_imask2vips( mask, t1 ) )
1712 		return( -1 );
1713 	if( vips_compass( in, &amp;t2, t1, 
1714 		"times", 2, 
1715 		"angle", VIPS_ANGLE45_D90, 
1716 		"combine", VIPS_COMBINE_SUM, 
1717 		"precision", VIPS_PRECISION_INTEGER,
1718 		NULL ) ) {
1719 		g_object_unref( t1 );
1720 		return( -1 );
1721 	}
1722 	g_object_unref( t1 );
1723 	if( vips_image_write( t2, out ) ) {
1724 		g_object_unref( t2 );
1725 		return( -1 );
1726 	}
1727 	g_object_unref( t2 );
1728 	return( 0 );
1729 }
1730 int
1731 im_convsep_raw( IMAGE *in, IMAGE *out, INTMASK *mask )
1732 {
1733 	im_error( "im_convsep_raw", "no compat function" );
1734 	return( -1 );
1735 }
1736 int 
1737 im_convsep( IMAGE *in, IMAGE *out, INTMASK *mask )
1738 {
1739 	VipsImage *t1, *t2;
1740 	if( !(t1 = vips_image_new()) ||
1741 		im_imask2vips( mask, t1 ) )
1742 		return( -1 );
1743 	if( vips_convsep( in, &amp;t2, t1, 
1744 		"precision", VIPS_PRECISION_INTEGER,
1745 		NULL ) ) {
1746 		g_object_unref( t1 );
1747 		return( -1 );
1748 	}
1749 	g_object_unref( t1 );
1750 	if( vips_image_write( t2, out ) ) {
1751 		g_object_unref( t2 );
1752 		return( -1 );
1753 	}
1754 	g_object_unref( t2 );
1755 	return( 0 );
1756 }
1757 int
1758 im_convsep_f_raw( IMAGE *in, IMAGE *out, DOUBLEMASK *mask )
1759 {
1760 	im_error( "im_convsep_raw", "no compat function" );
1761 	return( -1 );
1762 }
1763 int 
1764 im_convsep_f( IMAGE *in, IMAGE *out, DOUBLEMASK *mask )
1765 {
1766 	VipsImage *t1, *t2;
1767 	if( !(t1 = vips_image_new()) ||
1768 		im_mask2vips( mask, t1 ) )
1769 		return( -1 );
1770 	if( vips_convsep( in, &amp;t2, t1, NULL ) ) {
1771 		g_object_unref( t1 );
1772 		return( -1 );
1773 	}
1774 	g_object_unref( t1 );
1775 	if( vips_image_write( t2, out ) ) {
1776 		g_object_unref( t2 );
1777 		return( -1 );
1778 	}
1779 	g_object_unref( t2 );
1780 	return( 0 );
1781 }
1782 int 
1783 im_conv( VipsImage *in, VipsImage *out, INTMASK *mask )
1784 {
1785 	VipsImage *t1, *t2;
1786 	if( !(t1 = vips_image_new()) ||
1787 		im_imask2vips( mask, t1 ) )
1788 		return( -1 );
1789 	if( vips_convi( in, &amp;t2, t1, 
1790 		NULL ) ) {
1791 		g_object_unref( t1 );
1792 		return( -1 );
1793 	}
1794 	g_object_unref( t1 );
1795 	if( vips_image_write( t2, out ) ) {
1796 		g_object_unref( t2 );
1797 		return( -1 );
1798 	}
1799 	g_object_unref( t2 );
1800 	return( 0 );
1801 }
1802 int
1803 im_conv_raw( VipsImage *in, VipsImage *out, INTMASK *mask )
1804 {
1805 	im_error( "im_conv_raw", "no compat function" );
1806 	return( -1 );
1807 }
1808 int 
1809 im_conv_f( VipsImage *in, VipsImage *out, DOUBLEMASK *mask )
1810 {
1811 	VipsImage *t1, *t2;
1812 	if( !(t1 = vips_image_new()) ||
1813 		im_mask2vips( mask, t1 ) )
1814 		return( -1 );
1815 	if( vips_convf( in, &amp;t2, t1, 
1816 		NULL ) ) {
1817 		g_object_unref( t1 );
1818 		return( -1 );
1819 	}
1820 	g_object_unref( t1 );
1821 	if( vips_image_write( t2, out ) ) {
1822 		g_object_unref( t2 );
1823 		return( -1 );
1824 	}
1825 	g_object_unref( t2 );
1826 	return( 0 );
1827 }
1828 int 
1829 im_aconvsep( VipsImage *in, VipsImage *out, DOUBLEMASK *mask, int n_layers )
1830 {
1831 	VipsImage *t1, *t2;
1832 	if( !(t1 = vips_image_new()) ||
1833 		im_mask2vips( mask, t1 ) )
1834 		return( -1 );
1835 	if( vips_convasep( in, &amp;t2, t1, 
1836 		"layers", n_layers,
1837 		NULL ) ) {
1838 		g_object_unref( t1 );
1839 		return( -1 );
1840 	}
1841 	g_object_unref( t1 );
1842 	if( vips_image_write( t2, out ) ) {
1843 		g_object_unref( t2 );
1844 		return( -1 );
1845 	}
1846 	g_object_unref( t2 );
1847 	return( 0 );
1848 }
1849 int 
1850 im_aconv( VipsImage *in, VipsImage *out, 
1851 	DOUBLEMASK *mask, int n_layers, int cluster )
1852 {
1853 	VipsImage *t1, *t2;
1854 	if( !(t1 = vips_image_new()) ||
1855 		im_mask2vips( mask, t1 ) )
1856 		return( -1 );
1857 	if( vips_conva( in, &amp;t2, t1, 
1858 		"layers", n_layers,
1859 		"cluster", cluster,
1860 		NULL ) ) {
1861 		g_object_unref( t1 );
1862 		return( -1 );
1863 	}
1864 	g_object_unref( t1 );
1865 	if( vips_image_write( t2, out ) ) {
1866 		g_object_unref( t2 );
1867 		return( -1 );
1868 	}
1869 	g_object_unref( t2 );
1870 	return( 0 );
1871 }
1872 int
1873 im_conv_f_raw( VipsImage *in, VipsImage *out, DOUBLEMASK *mask )
1874 {
1875 	im_error( "im_conv_f_raw", "no compat function" );
1876 	return( -1 );
1877 }
1878 int
1879 im_addgnoise( IMAGE *in, IMAGE *out, double sigma )
1880 {
1881 	IMAGE *t;
1882 	if( !(t = im_open_local( out, "im_addgnoise", "p" )) ||
1883 		im_gaussnoise( t, in-&gt;Xsize, in-&gt;Ysize, 0, sigma ) ||
1884 		im_add( in, t, out ) )
1885 		return( -1 );
1886 	return( 0 );
1887 }
1888 int
1889 im_contrast_surface_raw( IMAGE *in, IMAGE *out, int half_win_size, int spacing )
1890 {
1891 	im_error( "im_contrast_surface_raw", "no compat function" );
1892 	return( -1 );
1893 }
1894 int
1895 im_contrast_surface( IMAGE *in, IMAGE *out, int half_win_size, int spacing )
1896 {
1897 	VipsImage **t = (VipsImage **) 
1898 		vips_object_local_array( VIPS_OBJECT( out ), 10 );
1899 	int size = half_win_size * 2; 
1900 	int x, y;
1901 	t[0] = vips_image_new_matrixv( 1, 2, -1.0, 1.0 );
1902 	t[1] = vips_image_new_matrixv( 2, 1, -1.0, 1.0 );
1903 	t[8] = vips_image_new_matrix( size, size ); 
1904 	for( y = 0; y &lt; size; y++ )
1905 		for( x = 0; x &lt; size; x++ )
1906 			*VIPS_MATRIX( t[8], x, y ) = 1.0;
1907 	if( vips_conv( in, &amp;t[2], t[0], 
1908 			"precision", VIPS_PRECISION_INTEGER,
1909 			NULL ) ||
1910 		vips_conv( in, &amp;t[3], t[1], 
1911 			"precision", VIPS_PRECISION_INTEGER,
1912 			NULL ) ||
1913 		vips_abs( t[2], &amp;t[4], NULL ) ||
1914 		vips_abs( t[3], &amp;t[5], NULL ) ||
1915 		vips_add( t[4], t[5], &amp;t[6], NULL ) ||
1916 		vips_conv( t[6], &amp;t[7], t[8], 
1917 			"precision", VIPS_PRECISION_INTEGER,
1918 			NULL ) ||
1919 		vips_subsample( t[7], &amp;t[9], spacing, spacing, NULL ) ||
1920 		vips_image_write( t[9], out ) )
1921 		return( -1 ); 
1922 	return( 0 );
1923 }
1924 int
1925 im_spcor_raw( IMAGE *in, IMAGE *ref, IMAGE *out )
1926 {
1927 	im_error( "im_spcor_raw", "no compat function" );
1928 	return( -1 );
1929 }
1930 int
1931 im_spcor( IMAGE *in, IMAGE *ref, IMAGE *out )
1932 {
1933 	VipsImage *x;
1934 	if( vips_call( "spcor", in, ref, &amp;x, NULL ) )
1935 		return( -1 );
1936 	if( vips_image_write( x, out ) ) {
1937 		g_object_unref( x );
1938 		return( -1 );
1939 	}
1940 	g_object_unref( x );
1941 	return( 0 );
1942 }
1943 int
1944 im_fastcor_raw( IMAGE *in, IMAGE *ref, IMAGE *out )
1945 {
1946 	im_error( "im_fastcor_raw", "no compat function" );
1947 	return( -1 );
1948 }
1949 int
1950 im_fastcor( IMAGE *in, IMAGE *ref, IMAGE *out )
1951 {
1952 	VipsImage *x;
1953 	if( vips_call( "fastcor", in, ref, &amp;x, NULL ) )
1954 		return( -1 );
1955 	if( vips_image_write( x, out ) ) {
1956 		g_object_unref( x );
1957 		return( -1 );
1958 	}
1959 	g_object_unref( x );
1960 	return( 0 );
1961 }
1962 int
1963 im_sharpen( IMAGE *in, IMAGE *out, 
1964 	int mask_size, 
1965 	double x1, double y2, double y3, 
1966 	double m1, double m2 )
1967 {
1968 	VipsImage **t = (VipsImage **) 
1969 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
1970 	if( vips_call( "sharpen", in, &amp;t[0], 
1971 		"sigma", mask_size / 4.0,
1972 		"x1", x1,
1973 		"y2", y2,
1974 		"y3", y3,
1975 		"m1", m1,
1976 		"m2", m2,
1977 		NULL ) ||
1978 		vips_colourspace( t[0], &amp;t[1], 
1979 			VIPS_INTERPRETATION_LABQ, NULL ) ||
1980 		vips_image_write( t[1], out ) ) 
1981 		return( -1 );
1982 	return( 0 );
1983 }
1984 static int
1985 vips__round( VipsImage *in, VipsImage *out, VipsOperationRound round )
1986 {
1987 	VipsImage *t;
1988 	if( vips_round( in, &amp;t, round,
1989 		NULL ) )
1990 		return( -1 );
1991 	if( vips_image_write( t, out ) ) {
1992 		g_object_unref( t );
1993 		return( -1 );
1994 	}
1995 	g_object_unref( t );
1996 	return( 0 );
1997 }
1998 int 
1999 im_rint( IMAGE *in, IMAGE *out )
2000 {
2001 	return( vips__round( in, out, VIPS_OPERATION_ROUND_RINT ) );
2002 }
2003 int 
2004 im_floor( IMAGE *in, IMAGE *out )
2005 {
2006 	return( vips__round( in, out, VIPS_OPERATION_ROUND_FLOOR ) );
2007 }
2008 int 
2009 im_ceil( IMAGE *in, IMAGE *out )
2010 {
2011 	return( vips__round( in, out, VIPS_OPERATION_ROUND_CEIL ) );
2012 }
2013 static int 
2014 vips__relational( IMAGE *in1, IMAGE *in2, IMAGE *out, 
2015 	VipsOperationRelational relational )
2016 {
2017 	VipsImage *t;
2018 	if( vips_relational( in1, in2, &amp;t, relational,
2019 		NULL ) )
2020 		return( -1 );
2021 	if( vips_image_write( t, out ) ) {
2022 		g_object_unref( t );
2023 		return( -1 );
2024 	}
2025 	g_object_unref( t );
2026 	return( 0 );
2027 }
2028 int 
2029 im_equal( IMAGE *in1, IMAGE *in2, IMAGE *out )
2030 {
2031 	return( vips__relational( in1, in2, out, 
2032 		VIPS_OPERATION_RELATIONAL_EQUAL ) );
2033 }
2034 int 
2035 im_notequal( IMAGE *in1, IMAGE *in2, IMAGE *out )
2036 {
2037 	return( vips__relational( in1, in2, out, 
2038 		VIPS_OPERATION_RELATIONAL_NOTEQ ) );
2039 }
2040 int 
2041 im_less( IMAGE *in1, IMAGE *in2, IMAGE *out )
2042 {
2043 	return( vips__relational( in1, in2, out, 
2044 		VIPS_OPERATION_RELATIONAL_LESS ) );
2045 }
2046 int 
2047 im_lesseq( IMAGE *in1, IMAGE *in2, IMAGE *out )
2048 {
2049 	return( vips__relational( in1, in2, out, 
2050 		VIPS_OPERATION_RELATIONAL_LESSEQ ) );
2051 }
2052 int 
2053 im_more( IMAGE *in1, IMAGE *in2, IMAGE *out )
2054 {
2055 	return( vips__relational( in1, in2, out, 
2056 		VIPS_OPERATION_RELATIONAL_MORE ) );
2057 }
2058 int 
2059 im_moreeq( IMAGE *in1, IMAGE *in2, IMAGE *out )
2060 {
2061 	return( vips__relational( in1, in2, out, 
2062 		VIPS_OPERATION_RELATIONAL_MOREEQ ) );
2063 }
2064 static int 
2065 vips__relational_vec( IMAGE *in, IMAGE *out, 
2066 	VipsOperationRelational relational, double *c, int n )
2067 {
2068 	VipsImage *t;
2069 	if( vips_relational_const( in, &amp;t, relational, c, n, 
2070 		NULL ) )
2071 		return( -1 );
2072 	if( vips_image_write( t, out ) ) {
2073 		g_object_unref( t );
2074 		return( -1 );
2075 	}
2076 	g_object_unref( t );
2077 	return( 0 );
2078 }
2079 int 
2080 im_equal_vec( VipsImage *in, VipsImage *out, int n, double *c )
2081 {
2082 	return( vips__relational_vec( in, out, 
2083 		VIPS_OPERATION_RELATIONAL_EQUAL, c, n ) );
2084 }
2085 int 
2086 im_notequal_vec( VipsImage *in, VipsImage *out, int n, double *c )
2087 {
2088 	return( vips__relational_vec( in, out, 
2089 		VIPS_OPERATION_RELATIONAL_NOTEQ, c, n ) );
2090 }
2091 int 
2092 im_less_vec( VipsImage *in, VipsImage *out, int n, double *c )
2093 {
2094 	return( vips__relational_vec( in, out, 
2095 		VIPS_OPERATION_RELATIONAL_LESS, c, n ) );
2096 }
2097 int 
2098 im_lesseq_vec( VipsImage *in, VipsImage *out, int n, double *c )
2099 {
2100 	return( vips__relational_vec( in, out, 
2101 		VIPS_OPERATION_RELATIONAL_LESSEQ, c, n ) );
2102 }
2103 int 
2104 im_more_vec( VipsImage *in, VipsImage *out, int n, double *c )
2105 {
2106 	return( vips__relational_vec( in, out, 
2107 		VIPS_OPERATION_RELATIONAL_MORE, c, n ) );
2108 }
2109 int 
2110 im_moreeq_vec( VipsImage *in, VipsImage *out, int n, double *c )
2111 {
2112 	return( vips__relational_vec( in, out, 
2113 		VIPS_OPERATION_RELATIONAL_MOREEQ, c, n ) );
2114 }
2115 int 
2116 im_equalconst( IMAGE *in, IMAGE *out, double c )
2117 {
2118 	return( im_equal_vec( in, out, 1, &amp;c ) );
2119 }
2120 int
2121 im_notequalconst( IMAGE *in, IMAGE *out, double c )
2122 {
2123 	return( im_notequal_vec( in, out, 1, &amp;c ) );
2124 }
2125 int
2126 im_lessconst( IMAGE *in, IMAGE *out, double c )
2127 {
2128 	return( im_less_vec( in, out, 1, &amp;c ) );
2129 }
2130 int
2131 im_lesseqconst( IMAGE *in, IMAGE *out, double c )
2132 {
2133 	return( im_lesseq_vec( in, out, 1, &amp;c ) );
2134 }
2135 int
2136 im_moreconst( IMAGE *in, IMAGE *out, double c )
2137 {
2138 	return( im_more_vec( in, out, 1, &amp;c ) );
2139 }
2140 int
2141 im_moreeqconst( IMAGE *in, IMAGE *out, double c )
2142 {
2143 	return( im_moreeq_vec( in, out, 1, &amp;c ) );
2144 }
2145 int 
2146 im_remainder( IMAGE *in1, IMAGE *in2, IMAGE *out )
2147 {
2148 	VipsImage *t;
2149 	if( vips_remainder( in1, in2, &amp;t, 
2150 		NULL ) )
2151 		return( -1 );
2152 	if( vips_image_write( t, out ) ) {
2153 		g_object_unref( t );
2154 		return( -1 );
2155 	}
2156 	g_object_unref( t );
2157 	return( 0 );
2158 }
2159 int 
2160 im_remainder_vec( IMAGE *in, IMAGE *out, int n, double *c )
2161 {
2162 	VipsImage *t;
2163 	if( vips_remainder_const( in, &amp;t, c, n,
2164 		NULL ) )
2165 		return( -1 );
2166 	if( vips_image_write( t, out ) ) {
2167 		g_object_unref( t );
2168 		return( -1 );
2169 	}
2170 	g_object_unref( t );
2171 	return( 0 );
2172 }
2173 int 
2174 im_remainderconst( IMAGE *in, IMAGE *out, double c )
2175 {
2176 	return( im_remainder_vec( in, out, 1, &amp;c ) );
2177 }
2178 static int 
2179 vips__boolean( IMAGE *in1, IMAGE *in2, IMAGE *out, 
2180 	VipsOperationBoolean boolean )
2181 {
2182 	VipsImage *t;
2183 	if( vips_boolean( in1, in2, &amp;t, boolean,
2184 		NULL ) )
2185 		return( -1 );
2186 	if( vips_image_write( t, out ) ) {
2187 		g_object_unref( t );
2188 		return( -1 );
2189 	}
2190 	g_object_unref( t );
2191 	return( 0 );
2192 }
2193 int 
2194 im_andimage( VipsImage *in1, VipsImage *in2, VipsImage *out )
2195 {
2196 	return( vips__boolean( in1, in2, out, VIPS_OPERATION_BOOLEAN_AND ) );
2197 }
2198 int 
2199 im_orimage( VipsImage *in1, VipsImage *in2, VipsImage *out )
2200 {
2201 	return( vips__boolean( in1, in2, out, VIPS_OPERATION_BOOLEAN_OR ) );
2202 }
2203 int 
2204 im_eorimage( VipsImage *in1, VipsImage *in2, VipsImage *out )
2205 {
2206 	return( vips__boolean( in1, in2, out, VIPS_OPERATION_BOOLEAN_EOR ) );
2207 }
2208 static int 
2209 vips__boolean_vec( IMAGE *in, IMAGE *out, 
2210 	VipsOperationBoolean boolean, double *c, int n )
2211 {
2212 	VipsImage *t;
2213 	if( vips_boolean_const( in, &amp;t, boolean, c, n, 
2214 		NULL ) )
2215 		return( -1 );
2216 	if( vips_image_write( t, out ) ) {
2217 		g_object_unref( t );
2218 		return( -1 );
2219 	}
2220 	g_object_unref( t );
2221 	return( 0 );
2222 }
2223 int 
2224 im_andimage_vec( VipsImage *in, VipsImage *out, int n, double *c )
2225 {
2226 	return( vips__boolean_vec( in, out, 
2227 		VIPS_OPERATION_BOOLEAN_AND, c, n ) );
2228 }
2229 int 
2230 im_orimage_vec( VipsImage *in, VipsImage *out, int n, double *c )
2231 {
2232 	return( vips__boolean_vec( in, out, 
2233 		VIPS_OPERATION_BOOLEAN_OR, c, n ) );
2234 }
2235 int 
2236 im_eorimage_vec( VipsImage *in, VipsImage *out, int n, double *c )
2237 {
2238 	return( vips__boolean_vec( in, out, 
2239 		VIPS_OPERATION_BOOLEAN_EOR, c, n ) );
2240 }
2241 int 
2242 im_shiftleft_vec( IMAGE *in, IMAGE *out, int n, double *c )
2243 {
2244 	return( vips__boolean_vec( in, out, 
2245 		VIPS_OPERATION_BOOLEAN_LSHIFT, c, n ) );
2246 }
2247 int 
2248 im_shiftright_vec( IMAGE *in, IMAGE *out, int n, double *c )
2249 {
2250 	return( vips__boolean_vec( in, out, 
2251 		VIPS_OPERATION_BOOLEAN_RSHIFT, c, n ) );
2252 }
2253 int 
2254 im_andimageconst( IMAGE *in, IMAGE *out, double c )
2255 {
2256 	return( im_andimage_vec( in, out, 1, &amp;c ) ); 
2257 }
2258 int 
2259 im_orimageconst( IMAGE *in, IMAGE *out, double c )
2260 {
2261 	return( im_orimage_vec( in, out, 1, &amp;c ) );
2262 }
2263 int 
2264 im_eorimageconst( IMAGE *in, IMAGE *out, double c )
2265 {
2266 	return( im_eorimage_vec( in, out, 1, &amp;c ) );
2267 }
2268 int 
2269 im_shiftleft( IMAGE *in, IMAGE *out, int n )
2270 {
2271 	double c = n;
2272 	return( im_shiftleft_vec( in, out, 1, &amp;c ) );
2273 }
2274 int 
2275 im_shiftright( IMAGE *in, IMAGE *out, int n )
2276 {
2277 	double c = n;
2278 	return( im_shiftright_vec( in, out, 1, &amp;c ) );
2279 }
2280 static int 
2281 vips__math2_vec( IMAGE *in, IMAGE *out, 
2282 	VipsOperationMath2 math2, double *c, int n )
2283 {
2284 	VipsImage *t;
2285 	if( vips_math2_const( in, &amp;t, math2, c, n, 
2286 		NULL ) )
2287 		return( -1 );
2288 	if( vips_image_write( t, out ) ) {
2289 		g_object_unref( t );
2290 		return( -1 );
2291 	}
2292 	g_object_unref( t );
2293 	return( 0 );
2294 }
2295 int 
2296 im_powtra_vec( VipsImage *in, VipsImage *out, int n, double *c )
2297 {
2298 	return( vips__math2_vec( in, out, VIPS_OPERATION_MATH2_POW, c, n ) );
2299 }
2300 int 
2301 im_powtra( IMAGE *in, IMAGE *out, double c )
2302 {
2303 	return( im_powtra_vec( in, out, 1, &amp;c ) );
2304 }
2305 int 
2306 im_expntra_vec( IMAGE *in, IMAGE *out, int n, double *c )
2307 {
2308 	return( vips__math2_vec( in, out, VIPS_OPERATION_MATH2_WOP, c, n ) );
2309 }
2310 int 
2311 im_expntra( IMAGE *in, IMAGE *out, double c )
2312 {
2313 	return( im_expntra_vec( in, out, 1, &amp;c ) );
2314 }
2315 int 
2316 im_ifthenelse( VipsImage *c, VipsImage *a, VipsImage *b, VipsImage *out )
2317 {
2318 	VipsImage *t;
2319 	if( vips_ifthenelse( c, a, b, &amp;t, 
2320 		NULL ) )
2321 		return( -1 );
2322 	if( vips_image_write( t, out ) ) {
2323 		g_object_unref( t );
2324 		return( -1 );
2325 	}
2326 	g_object_unref( t );
2327 	return( 0 );
2328 }
2329 int 
2330 im_blend( VipsImage *c, VipsImage *a, VipsImage *b, VipsImage *out )
2331 {
2332 	VipsImage *t;
2333 	if( vips_ifthenelse( c, a, b, &amp;t, 
2334 		"blend", TRUE,
2335 		NULL ) )
2336 		return( -1 );
2337 	if( vips_image_write( t, out ) ) {
2338 		g_object_unref( t );
2339 		return( -1 );
2340 	}
2341 	g_object_unref( t );
2342 	return( 0 );
2343 }
2344 static int
2345 vips__complex( VipsImage *in, VipsImage *out, VipsOperationComplex cmplx )
2346 {
2347 	VipsImage *t;
2348 	if( vips_complex( in, &amp;t, cmplx,
2349 		NULL ) )
2350 		return( -1 );
2351 	if( vips_image_write( t, out ) ) {
2352 		g_object_unref( t );
2353 		return( -1 );
2354 	}
2355 	g_object_unref( t );
2356 	return( 0 );
2357 }
2358 int 
2359 im_c2amph( IMAGE *in, IMAGE *out )
2360 {
2361 	return( vips__complex( in, out, VIPS_OPERATION_COMPLEX_POLAR ) );
2362 }
2363 int 
2364 im_c2rect( IMAGE *in, IMAGE *out )
2365 {
2366 	return( vips__complex( in, out, VIPS_OPERATION_COMPLEX_RECT ) );
2367 }
2368 static int
2369 vips__complexget( VipsImage *in, VipsImage *out, VipsOperationComplexget get )
2370 {
2371 	VipsImage *t;
2372 	if( vips_complexget( in, &amp;t, get,
2373 		NULL ) )
2374 		return( -1 );
2375 	if( vips_image_write( t, out ) ) {
2376 		g_object_unref( t );
2377 		return( -1 );
2378 	}
2379 	g_object_unref( t );
2380 	return( 0 );
2381 }
2382 int 
2383 im_c2real( IMAGE *in, IMAGE *out )
2384 {
2385 	return( vips__complexget( in, out, VIPS_OPERATION_COMPLEXGET_REAL ) );
2386 }
2387 int 
2388 im_c2imag( IMAGE *in, IMAGE *out )
2389 {
2390 	return( vips__complexget( in, out, VIPS_OPERATION_COMPLEXGET_IMAG ) );
2391 }
2392 int 
2393 im_ri2c( IMAGE *in1, IMAGE *in2, IMAGE *out )
2394 {
2395 	VipsImage *x;
2396 	if( vips_call( "complexform", in1, in2, &amp;x, NULL ) )
2397 		return( -1 );
2398 	if( vips_image_write( x, out ) ) {
2399 		g_object_unref( x );
2400 		return( -1 );
2401 	}
2402 	g_object_unref( x );
2403 	return( 0 );
2404 }
2405 int
2406 im_cache( VipsImage *in, VipsImage *out, 
2407 	int width, int height, int max )
2408 {
2409 	return( vips_sink_screen( in, out, NULL, 
2410 		width, height, max, 0, NULL, NULL ) );
2411 }
2412 int
2413 im_argb2rgba( VipsImage *in, VipsImage *out )
2414 {
2415 	return( vips_image_write( in, out ) );
2416 }
2417 int
2418 im_shrink( VipsImage *in, VipsImage *out, double xshrink, double yshrink )
2419 {
2420 	VipsImage *x;
2421 	if( vips_shrink( in, &amp;x, xshrink, yshrink, NULL ) )
2422 		return( -1 );
2423 	if( vips_image_write( x, out ) ) {
2424 		g_object_unref( x );
2425 		return( -1 );
2426 	}
2427 	g_object_unref( x );
2428 	return( 0 );
2429 }
2430 int
2431 im_eye( IMAGE *out, const int xsize, const int ysize, const double factor )
2432 {
2433 	VipsImage *x;
2434 	if( vips_eye( &amp;x, xsize, ysize, 
2435 		"factor", factor,
2436 		"uchar", TRUE,
2437 		NULL ) )
2438 		return( -1 );
2439 	if( vips_image_write( x, out ) ) {
2440 		g_object_unref( x );
2441 		return( -1 );
2442 	}
2443 	g_object_unref( x );
2444 	return( 0 );
2445 }
2446 int
2447 im_feye( IMAGE *out, const int xsize, const int ysize, const double factor )
2448 {
2449 	VipsImage *x;
2450 	if( vips_eye( &amp;x, xsize, ysize, 
2451 		"factor", factor,
2452 		NULL ) )
2453 		return( -1 );
2454 	if( vips_image_write( x, out ) ) {
2455 		g_object_unref( x );
2456 		return( -1 );
2457 	}
2458 	g_object_unref( x );
2459 	return( 0 );
2460 }
2461 int
2462 im_grey( IMAGE *out, const int xsize, const int ysize )
2463 {
2464 	VipsImage *x;
2465 	if( vips_grey( &amp;x, xsize, ysize, 
2466 		"uchar", TRUE,
2467 		NULL ) )
2468 		return( -1 );
2469 	if( vips_image_write( x, out ) ) {
2470 		g_object_unref( x );
2471 		return( -1 );
2472 	}
2473 	g_object_unref( x );
2474 	return( 0 );
2475 }
2476 int
2477 im_fgrey( IMAGE *out, const int xsize, const int ysize )
2478 {
2479 	VipsImage *x;
2480 	if( vips_grey( &amp;x, xsize, ysize, 
2481 		NULL ) )
2482 		return( -1 );
2483 	if( vips_image_write( x, out ) ) {
2484 		g_object_unref( x );
2485 		return( -1 );
2486 	}
2487 	g_object_unref( x );
2488 	return( 0 );
2489 }
2490 int
2491 im_buildlut( DOUBLEMASK *input, VipsImage *out )
2492 {
2493 	VipsImage *mat;
2494 	VipsImage *x;
2495 	mat = vips_image_new();
2496 	if( im_mask2vips( input, mat ) )
2497 		return( -1 );
2498 	if( vips_buildlut( mat, &amp;x, 
2499 		NULL ) ) {
2500 		g_object_unref( mat );
2501 		return( -1 );
2502 	}
2503 	g_object_unref( mat );
2504 	if( vips_image_write( x, out ) ) {
2505 		g_object_unref( x );
2506 		return( -1 );
2507 	}
2508 	g_object_unref( x );
2509 	return( 0 );
2510 }
2511 int
2512 im_invertlut( DOUBLEMASK *input, VipsImage *out, int size )
2513 {
2514 	VipsImage *mat;
2515 	VipsImage *x;
2516 	mat = vips_image_new();
2517 	if( im_mask2vips( input, mat ) )
2518 		return( -1 );
2519 	if( vips_invertlut( mat, &amp;x, 
2520 		"size", size, 
2521 		NULL ) ) {
2522 		g_object_unref( mat );
2523 		return( -1 );
2524 	}
2525 	g_object_unref( mat );
2526 	if( vips_image_write( x, out ) ) {
2527 		g_object_unref( x );
2528 		return( -1 );
2529 	}
2530 	g_object_unref( x );
2531 	return( 0 );
2532 }
2533 int 
2534 im_tone_build_range( IMAGE *out, 
2535 	int in_max, int out_max,
2536 	double Lb, double Lw,
2537 	double Ps, double Pm, double Ph, 
2538 	double S, double M, double H )
2539 {
2540 	VipsImage *t;
2541 	if( vips_tonelut( &amp;t, 
2542 		"in_max", in_max,
2543 		"out_max", out_max,
2544 		"Lb", Lb,
2545 		"Lw", Lw,
2546 		"Ps", Ps,
2547 		"Pm", Pm,
2548 		"Ph", Ph,
2549 		"S", S,
2550 		"M", M,
2551 		"H", H,
2552 		NULL ) )
2553 		return( -1 );
2554 	if( vips_image_write( t, out ) ) {
2555 		g_object_unref( t );
2556 		return( -1 );
2557 	}
2558 	g_object_unref( t );
2559 	return( 0 );
2560 }
2561 int 
2562 im_tone_build( IMAGE *out, 
2563 	double Lb, double Lw,
2564 	double Ps, double Pm, double Ph, 
2565 	double S, double M, double H )
2566 {
2567 	IMAGE *t1;
2568 	if( !(t1 = im_open_local( out, "im_tone_build", "p" )) ||
2569 		im_tone_build_range( t1, 32767, 32767,
2570 			Lb, Lw, Ps, Pm, Ph, S, M, H ) ||
2571 		im_clip2fmt( t1, out, IM_BANDFMT_SHORT ) )
2572 		return( -1 );
2573 	return( 0 );
2574 }
2575 int
2576 im_rightshift_size( IMAGE *in, IMAGE *out, 
2577 	int xshift, int yshift, int band_fmt )
2578 {
2579 	VipsImage **t = (VipsImage **) 
2580 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
2581 	if( vips_shrink( in, &amp;t[0], 1 &lt;&lt; xshift, 1 &lt;&lt; yshift, NULL ) ||
2582 		vips_cast( t[0], &amp;t[1], band_fmt, NULL ) ||
2583 		vips_image_write( t[1], out ) ) 
2584 		return( -1 );
2585 	return( 0 );
2586 }
2587 int 
2588 im_Lab2XYZ_temp( IMAGE *in, IMAGE *out, double X0, double Y0, double Z0 )
2589 {
2590 	VipsArea *temp;
2591 	VipsImage *x;
2592 	temp = VIPS_AREA( vips_array_double_newv( 3, X0, Y0, Z0 ) );
2593 	if( vips_Lab2XYZ( in, &amp;x, "temp", temp, NULL ) ) {
2594 		vips_area_unref( temp );
2595 		return( -1 );
2596 	}
2597 	vips_area_unref( temp );
2598 	if( vips_image_write( x, out ) ) {
2599 		g_object_unref( x );
2600 		return( -1 );
2601 	}
2602 	g_object_unref( x );
2603 	return( 0 );
2604 }
2605 int 
2606 im_Lab2XYZ( IMAGE *in, IMAGE *out )
2607 {
2608 	VipsImage *x;
2609 	if( vips_Lab2XYZ( in, &amp;x, NULL ) )
2610 		return( -1 );
2611 	if( vips_image_write( x, out ) ) {
2612 		g_object_unref( x );
2613 		return( -1 );
2614 	}
2615 	g_object_unref( x );
2616 	return( 0 );
2617 }
2618 int 
2619 im_XYZ2Lab_temp( IMAGE *in, IMAGE *out, double X0, double Y0, double Z0 )
2620 {
2621 	double ary[3];
2622 	VipsArea *temp;
2623 	VipsImage *x;
2624 	ary[0] = X0;
2625 	ary[1] = Y0;
2626 	ary[2] = Z0;
2627 	temp = VIPS_AREA( vips_array_double_new( ary, 3 ) ); 
2628 	if( vips_XYZ2Lab( in, &amp;x, "temp", temp, NULL ) ) {
2629 		vips_area_unref( temp );
2630 		return( -1 );
2631 	}
2632 	vips_area_unref( temp );
2633 	if( vips_image_write( x, out ) ) {
2634 		g_object_unref( x );
2635 		return( -1 );
2636 	}
2637 	g_object_unref( x );
2638 	return( 0 );
2639 }
2640 int 
2641 im_XYZ2Lab( IMAGE *in, IMAGE *out )
2642 {
2643 	VipsImage *x;
2644 	if( vips_XYZ2Lab( in, &amp;x, NULL ) )
2645 		return( -1 );
2646 	if( vips_image_write( x, out ) ) {
2647 		g_object_unref( x );
2648 		return( -1 );
2649 	}
2650 	g_object_unref( x );
2651 	return( 0 );
2652 }
2653 int 
2654 im_Lab2LCh( IMAGE *in, IMAGE *out )
2655 {
2656 	VipsImage *x;
2657 	if( vips_Lab2LCh( in, &amp;x, NULL ) )
2658 		return( -1 );
2659 	if( vips_image_write( x, out ) ) {
2660 		g_object_unref( x );
2661 		return( -1 );
2662 	}
2663 	g_object_unref( x );
2664 	return( 0 );
2665 }
2666 int 
2667 im_LCh2Lab( IMAGE *in, IMAGE *out )
2668 {
2669 	VipsImage *x;
2670 	if( vips_LCh2Lab( in, &amp;x, NULL ) )
2671 		return( -1 );
2672 	if( vips_image_write( x, out ) ) {
2673 		g_object_unref( x );
2674 		return( -1 );
2675 	}
2676 	g_object_unref( x );
2677 	return( 0 );
2678 }
2679 int 
2680 im_LCh2UCS( IMAGE *in, IMAGE *out )
2681 {
2682 	VipsImage *x;
2683 	if( vips_LCh2CMC( in, &amp;x, NULL ) )
2684 		return( -1 );
2685 	if( vips_image_write( x, out ) ) {
2686 		g_object_unref( x );
2687 		return( -1 );
2688 	}
2689 	g_object_unref( x );
2690 	return( 0 );
2691 }
2692 int 
2693 im_UCS2LCh( IMAGE *in, IMAGE *out )
2694 {
2695 	VipsImage *x;
2696 	if( vips_CMC2LCh( in, &amp;x, NULL ) )
2697 		return( -1 );
2698 	if( vips_image_write( x, out ) ) {
2699 		g_object_unref( x );
2700 		return( -1 );
2701 	}
2702 	g_object_unref( x );
2703 	return( 0 );
2704 }
2705 int 
2706 im_XYZ2Yxy( IMAGE *in, IMAGE *out )
2707 {
2708 	VipsImage *x;
2709 	if( vips_XYZ2Yxy( in, &amp;x, NULL ) )
2710 		return( -1 );
2711 	if( vips_image_write( x, out ) ) {
2712 		g_object_unref( x );
2713 		return( -1 );
2714 	}
2715 	g_object_unref( x );
2716 	return( 0 );
2717 }
2718 int 
2719 im_Yxy2XYZ( IMAGE *in, IMAGE *out )
2720 {
2721 	VipsImage *x;
2722 	if( vips_Yxy2XYZ( in, &amp;x, NULL ) )
2723 		return( -1 );
2724 	if( vips_image_write( x, out ) ) {
2725 		g_object_unref( x );
2726 		return( -1 );
2727 	}
2728 	g_object_unref( x );
2729 	return( 0 );
2730 }
2731 int 
2732 im_float2rad( IMAGE *in, IMAGE *out )
2733 {
2734 	VipsImage *x;
2735 	if( vips_float2rad( in, &amp;x, NULL ) )
2736 		return( -1 );
2737 	if( vips_image_write( x, out ) ) {
2738 		g_object_unref( x );
2739 		return( -1 );
2740 	}
2741 	g_object_unref( x );
2742 	return( 0 );
2743 }
2744 int 
2745 im_rad2float( IMAGE *in, IMAGE *out )
2746 {
2747 	VipsImage *x;
2748 	if( vips_rad2float( in, &amp;x, NULL ) )
2749 		return( -1 );
2750 	if( vips_image_write( x, out ) ) {
2751 		g_object_unref( x );
2752 		return( -1 );
2753 	}
2754 	g_object_unref( x );
2755 	return( 0 );
2756 }
2757 int 
2758 im_Lab2LabQ( IMAGE *in, IMAGE *out )
2759 {
2760 	VipsImage *x;
2761 	if( vips_Lab2LabQ( in, &amp;x, NULL ) )
2762 		return( -1 );
2763 	if( vips_image_write( x, out ) ) {
2764 		g_object_unref( x );
2765 		return( -1 );
2766 	}
2767 	g_object_unref( x );
2768 	return( 0 );
2769 }
2770 int 
2771 im_LabQ2Lab( IMAGE *in, IMAGE *out )
2772 {
2773 	VipsImage *x;
2774 	if( vips_LabQ2Lab( in, &amp;x, NULL ) )
2775 		return( -1 );
2776 	if( vips_image_write( x, out ) ) {
2777 		g_object_unref( x );
2778 		return( -1 );
2779 	}
2780 	g_object_unref( x );
2781 	return( 0 );
2782 }
2783 int 
2784 im_Lab2LabS( IMAGE *in, IMAGE *out )
2785 {
2786 	VipsImage *x;
2787 	if( vips_Lab2LabS( in, &amp;x, NULL ) )
2788 		return( -1 );
2789 	if( vips_image_write( x, out ) ) {
2790 		g_object_unref( x );
2791 		return( -1 );
2792 	}
2793 	g_object_unref( x );
2794 	return( 0 );
2795 }
2796 int 
2797 im_LabS2Lab( IMAGE *in, IMAGE *out )
2798 {
2799 	VipsImage *x;
2800 	if( vips_LabS2Lab( in, &amp;x, NULL ) )
2801 		return( -1 );
2802 	if( vips_image_write( x, out ) ) {
2803 		g_object_unref( x );
2804 		return( -1 );
2805 	}
2806 	g_object_unref( x );
2807 	return( 0 );
2808 }
2809 int 
2810 im_LabQ2LabS( IMAGE *in, IMAGE *out )
2811 {
2812 	VipsImage *x;
2813 	if( vips_LabQ2LabS( in, &amp;x, NULL ) )
2814 		return( -1 );
2815 	if( vips_image_write( x, out ) ) {
2816 		g_object_unref( x );
2817 		return( -1 );
2818 	}
2819 	g_object_unref( x );
2820 	return( 0 );
2821 }
2822 int 
2823 im_LabS2LabQ( IMAGE *in, IMAGE *out )
2824 {
2825 	VipsImage *x;
2826 	if( vips_LabS2LabQ( in, &amp;x, NULL ) )
2827 		return( -1 );
2828 	if( vips_image_write( x, out ) ) {
2829 		g_object_unref( x );
2830 		return( -1 );
2831 	}
2832 	g_object_unref( x );
2833 	return( 0 );
2834 }
2835 int 
2836 im_Lab2disp( IMAGE *in, IMAGE *out, struct im_col_display *disp )
2837 {	
2838 	IMAGE *t[1];
2839 	if( im_open_local_array( out, t, 1, "im_Lab2disp:1", "p" ) ||
2840 		im_Lab2XYZ( in, t[0] ) ||
2841 		im_XYZ2disp( t[0], out, disp ) )
2842 		return( -1 );
2843 	return( 0 );
2844 }
2845 int 
2846 im_dECMC_fromdisp( IMAGE *im1, IMAGE *im2, 
2847 	IMAGE *out, struct im_col_display *d )
2848 {	
2849 	IMAGE *t[4];
2850 	if( im_open_local_array( out, t, 4, "im_dECMC_fromdisp:1", "p" ) ||
2851 		im_disp2XYZ( im1, t[0], d ) ||
2852 		im_XYZ2Lab( t[0], t[1] ) ||
2853 		im_disp2XYZ( im2, t[2], d ) ||
2854 		im_XYZ2Lab( t[2], t[3] ) ||
2855 		im_dECMC_fromLab( t[1], t[3], out ) )
2856 		return( -1 );
2857 	return( 0 );
2858 }
2859 int 
2860 im_dE_fromdisp( IMAGE *im1, IMAGE *im2, IMAGE *out, struct im_col_display *d )
2861 {
2862 	IMAGE *t[2];
2863 	if( im_open_local_array( out, t, 2, "im_dE_fromdisp:1", "p" ) ||
2864 		im_disp2XYZ( im1, t[0], d ) ||
2865 		im_disp2XYZ( im2, t[1], d ) ||
2866 		im_dE_fromXYZ( t[0], t[1], out ) )
2867 		return( -1 );
2868 	return( 0 );
2869 }
2870 int 
2871 im_disp2Lab( IMAGE *in, IMAGE *out, struct im_col_display *d )
2872 {
2873 	VipsImage *t[1];
2874 	if( im_open_local_array( out, t, 1, "im_disp2Lab:1", "p" ) ||
2875 		im_disp2XYZ( in, t[0], d ) ||
2876 		im_XYZ2Lab( t[0], out ) )
2877 		return( -1 );
2878 	return( 0 );
2879 }
2880 int 
2881 im_sRGB2XYZ( IMAGE *in, IMAGE *out )
2882 {
2883 	VipsImage **t = (VipsImage **) 
2884 		vips_object_local_array( (VipsObject *) out, 2 );
2885 	if( vips_sRGB2scRGB( in, &amp;t[0], NULL ) ||
2886 		vips_scRGB2XYZ( t[0], &amp;t[1], NULL ) ||
2887 		vips_image_write( t[1], out ) ) 
2888 		return( -1 );
2889 	return( 0 );
2890 }
2891 int 
2892 im_XYZ2sRGB( IMAGE *in, IMAGE *out )
2893 {
2894 	VipsImage **t = (VipsImage **) 
2895 		vips_object_local_array( (VipsObject *) out, 2 );
2896 	if( vips_XYZ2scRGB( in, &amp;t[0], NULL ) ||
2897 		vips_scRGB2sRGB( t[0], &amp;t[1], NULL ) ||
2898 		vips_image_write( t[1], out ) ) 
2899 		return( -1 );
2900 	return( 0 );
2901 }
2902 int 
2903 im_LabQ2sRGB( IMAGE *in, IMAGE *out )
2904 {
2905 	VipsImage *x;
2906 	if( vips_LabQ2sRGB( in, &amp;x, NULL ) )
2907 		return( -1 );
2908 	if( vips_image_write( x, out ) ) {
2909 		g_object_unref( x );
2910 		return( -1 );
2911 	}
2912 	g_object_unref( x );
2913 	return( 0 );
2914 }
2915 int 
2916 im_icc_transform( VipsImage *in, VipsImage *out, 
2917 	const char *input_profile_filename,
2918 	const char *output_profile_filename,
2919 	VipsIntent intent )
2920 {
2921 	VipsImage *x;
2922 	if( vips_icc_transform( in, &amp;x, output_profile_filename,
2923 		"input_profile", input_profile_filename,
2924 		"intent", intent,
2925 		NULL ) )
2926 		return( -1 );
2927 	if( vips_image_write( x, out ) ) {
2928 		g_object_unref( x );
2929 		return( -1 );
2930 	}
2931 	g_object_unref( x );
2932 	return( 0 );
2933 }
2934 int 
2935 im_icc_import( VipsImage *in, VipsImage *out, 
2936 	const char *input_profile_filename, VipsIntent intent )
2937 {
2938 	VipsImage *x;
2939 	if( vips_icc_import( in, &amp;x, 
2940 		"input_profile", input_profile_filename,
2941 		"intent", intent,
2942 		NULL ) )
2943 		return( -1 );
2944 	if( vips_image_write( x, out ) ) {
2945 		g_object_unref( x );
2946 		return( -1 );
2947 	}
2948 	g_object_unref( x );
2949 	return( 0 );
2950 }
2951 int 
2952 im_icc_import_embedded( VipsImage *in, VipsImage *out, VipsIntent intent )
2953 {
2954 	VipsImage *x;
2955 	if( vips_icc_import( in, &amp;x, 
2956 		"embedded", TRUE,
2957 		"intent", intent,
2958 		NULL ) )
2959 		return( -1 );
2960 	if( vips_image_write( x, out ) ) {
2961 		g_object_unref( x );
2962 		return( -1 );
2963 	}
2964 	g_object_unref( x );
2965 	return( 0 );
2966 }
2967 int 
2968 im_icc_export_depth( VipsImage *in, VipsImage *out, int depth,
2969 	const char *output_profile_filename, VipsIntent intent )
2970 {
2971 	VipsImage *x;
2972 	if( vips_icc_export( in, &amp;x, 
2973 		"output_profile", output_profile_filename,
2974 		"depth", depth,
2975 		"intent", intent,
2976 		NULL ) )
2977 		return( -1 );
2978 	if( vips_image_write( x, out ) ) {
2979 		g_object_unref( x );
2980 		return( -1 );
2981 	}
2982 	g_object_unref( x );
2983 	return( 0 );
2984 }
2985 int 
2986 im_LabQ2XYZ( IMAGE *in, IMAGE *out )
2987 {	
2988 	IMAGE *t[1];
2989 	if( im_open_local_array( out, t, 1, "im_LabQ2XYZ:1", "p" ) ||
2990 		im_LabQ2Lab( in, t[0] ) ||
2991 		im_Lab2XYZ( t[0], out ) )
2992 		return( -1 );
2993 	return( 0 );
2994 }
2995 int 
2996 im_Lab2UCS( IMAGE *in, IMAGE *out )
2997 {	
2998 	IMAGE *t[1];
2999 	if( im_open_local_array( out, t, 1, "im_Lab2UCS:1", "p" ) ||
3000 		im_Lab2LCh( in, t[0] ) ||
3001 		im_LCh2UCS( t[0], out ) )
3002 		return( -1 );
3003 	return( 0 );
3004 }
3005 int 
3006 im_UCS2Lab( IMAGE *in, IMAGE *out )
3007 {	
3008 	IMAGE *t[1];
3009 	if( im_open_local_array( out, t, 1, "im_UCS2Lab:1", "p" ) ||
3010 		im_UCS2LCh( in, t[0] ) ||
3011 		im_LCh2Lab( t[0], out ) )
3012 		return( -1 );
3013 	return( 0 );
3014 }
3015 int 
3016 im_UCS2XYZ( IMAGE *in, IMAGE *out )
3017 {
3018 	IMAGE *t[1];
3019 	if( im_open_local_array( out, t, 1, "im_UCS2XYZ:1", "p" ) ||
3020 		im_UCS2Lab( in, t[0] ) ||
3021 		im_Lab2XYZ( t[0], out ) )
3022 		return( -1 );
3023 	return( 0 );
3024 }
3025 int 
3026 im_XYZ2UCS( IMAGE *in, IMAGE *out )
3027 {	
3028 	IMAGE *t[1];
3029 	if( im_open_local_array( out, t, 1, "im_XYZ2UCS:1", "p" ) ||
3030 		im_XYZ2Lab( in, t[0] ) ||
3031 		im_Lab2UCS( t[0], out ) )
3032 		return( -1 );
3033 	return( 0 );
3034 }
3035 int 
3036 im_dE_fromXYZ( IMAGE *in1, IMAGE *in2, IMAGE *out )
3037 {	
3038 	IMAGE *t[2];
3039 	if( im_open_local_array( out, t, 2, "im_dE_fromXYZ:1", "p" ) ||
3040 		im_XYZ2Lab( in1, t[0] ) ||
3041 		im_XYZ2Lab( in2, t[1] ) ||
3042 		im_dE_fromLab( t[0], t[1], out ) )
3043 		return( -1 );
3044 	return( 0 );
3045 }
3046 int 
3047 im_dE_fromLab( IMAGE *in1, IMAGE *in2, IMAGE *out )
3048 {
3049 	VipsImage *x;
3050 	if( vips_dE76( in1, in2, &amp;x, 
3051 		NULL ) )
3052 		return( -1 );
3053 	if( vips_image_write( x, out ) ) {
3054 		g_object_unref( x );
3055 		return( -1 );
3056 	}
3057 	g_object_unref( x );
3058 	return( 0 );
3059 }
3060 int 
3061 im_dECMC_fromLab( IMAGE *in1, IMAGE *in2, IMAGE *out )
3062 {
3063 	VipsImage *x;
3064 	if( vips_dECMC( in1, in2, &amp;x, 
3065 		NULL ) )
3066 		return( -1 );
3067 	if( vips_image_write( x, out ) ) {
3068 		g_object_unref( x );
3069 		return( -1 );
3070 	}
3071 	g_object_unref( x );
3072 	return( 0 );
3073 }
3074 int 
3075 im_dE00_fromLab( IMAGE *in1, IMAGE *in2, IMAGE *out )
3076 {
3077 	VipsImage *x;
3078 	if( vips_dE00( in1, in2, &amp;x, 
3079 		NULL ) )
3080 		return( -1 );
3081 	if( vips_image_write( x, out ) ) {
3082 		g_object_unref( x );
3083 		return( -1 );
3084 	}
3085 	g_object_unref( x );
3086 	return( 0 );
3087 }
3088 int
3089 im_icc_ac2rc( VipsImage *in, VipsImage *out, const char *profile_filename )
3090 {
3091 	VipsImage *x;
3092 	if( vips_icc_ac2rc( in, &amp;x, profile_filename ) )
3093 		return( -1 );
3094 	if( vips_image_write( x, out ) ) {
3095 		g_object_unref( x );
3096 		return( -1 );
3097 	}
3098 	g_object_unref( x );
3099 	return( 0 );
3100 }
3101 int 
3102 im_quadratic( IMAGE *in, IMAGE *out, IMAGE *coeff )
3103 {
3104 	VipsImage *x;
3105 	if( vips_quadratic( in, &amp;x, coeff, 
3106 		NULL ) )
3107 		return( -1 );
3108 	if( vips_image_write( x, out ) ) {
3109 		g_object_unref( x );
3110 		return( -1 );
3111 	}
3112 	g_object_unref( x );
3113 	return( 0 );
3114 }
3115 int 
3116 im_maxpos_vec( VipsImage *im, int *xpos, int *ypos, double *maxima, int n )
3117 {
3118 	double max;
3119 	VipsArrayDouble *out_array;
3120 	VipsArrayInt *x_array;
3121 	VipsArrayInt *y_array;
3122 	if( vips_max( im, &amp;max, 
3123 		"size", n,
3124 		"out_array", &amp;out_array, 
3125 		"x_array", &amp;x_array, 
3126 		"y_array", &amp;y_array, 
3127 		NULL ) )
3128 		return( -1 );
3129 	memcpy( xpos, VIPS_ARRAY_ADDR( x_array, 0 ), n * sizeof( int ) );
3130 	memcpy( ypos, VIPS_ARRAY_ADDR( y_array, 0 ), n * sizeof( int ) );
3131 	memcpy( maxima, VIPS_ARRAY_ADDR( out_array, 0 ), n * sizeof( double ) );
3132 	vips_area_unref( VIPS_AREA( out_array ) );
3133 	vips_area_unref( VIPS_AREA( x_array ) );
3134 	vips_area_unref( VIPS_AREA( y_array ) );
3135 	return( 0 );
3136 }
3137 int 
3138 im_minpos_vec( VipsImage *im, int *xpos, int *ypos, double *minima, int n )
3139 {
3140 	double min;
3141 	VipsArrayDouble *out_array;
3142 	VipsArrayInt *x_array;
3143 	VipsArrayInt *y_array;
3144 	if( vips_min( im, &amp;min, 
3145 		"size", n,
3146 		"out_array", &amp;out_array, 
3147 		"x_array", &amp;x_array, 
3148 		"y_array", &amp;y_array, 
3149 		NULL ) )
3150 		return( -1 );
3151 	memcpy( xpos, VIPS_ARRAY_ADDR( x_array, 0 ), n * sizeof( int ) );
3152 	memcpy( ypos, VIPS_ARRAY_ADDR( y_array, 0 ), n * sizeof( int ) );
3153 	memcpy( minima, VIPS_ARRAY_ADDR( out_array, 0 ), n * sizeof( double ) );
3154 	vips_area_unref( VIPS_AREA( out_array ) );
3155 	vips_area_unref( VIPS_AREA( x_array ) );
3156 	vips_area_unref( VIPS_AREA( y_array ) );
3157 	return( 0 );
3158 }
3159 int 
3160 im_cross_phase( IMAGE *in1, IMAGE *in2, IMAGE *out )
3161 {
3162 	VipsImage *x;
3163 	if( vips_call( "cross_phase", in1, in2, &amp;x, NULL ) )
3164 		return( -1 );
3165 	if( vips_image_write( x, out ) ) {
3166 		g_object_unref( x );
3167 		return( -1 );
3168 	}
3169 	g_object_unref( x );
3170 	return( 0 );
3171 }
3172 int 
3173 im_maplut( IMAGE *in, IMAGE *out, IMAGE *lut )
3174 {
3175 	VipsImage *x;
3176 	if( vips_maplut( in, &amp;x, lut, NULL ) )
3177 		return( -1 );
3178 	if( vips_image_write( x, out ) ) {
3179 		g_object_unref( x );
3180 		return( -1 );
3181 	}
3182 	g_object_unref( x );
3183 	return( 0 );
3184 }
3185 int
3186 im_ismonotonic( IMAGE *lut, int *out )
3187 {
3188 	gboolean monotonic;
3189 	if( vips_hist_ismonotonic( lut, &amp;monotonic, NULL ) )
3190 		return( -1 );
3191 	*out = monotonic ? 255 : 0; 
3192 	return( 0 );
3193 }
3194 int 
3195 im_histcum( IMAGE *in, IMAGE *out )
3196 {
3197 	VipsImage *x;
3198 	if( vips_hist_cum( in, &amp;x, NULL ) )
3199 		return( -1 );
3200 	if( vips_image_write( x, out ) ) {
3201 		g_object_unref( x );
3202 		return( -1 );
3203 	}
3204 	g_object_unref( x );
3205 	return( 0 );
3206 }
3207 int 
3208 im_histnorm( IMAGE *in, IMAGE *out )
3209 {
3210 	VipsImage *x;
3211 	if( vips_hist_norm( in, &amp;x, NULL ) )
3212 		return( -1 );
3213 	if( vips_image_write( x, out ) ) {
3214 		g_object_unref( x );
3215 		return( -1 );
3216 	}
3217 	g_object_unref( x );
3218 	return( 0 );
3219 }
3220 int 
3221 im_histeq( IMAGE *in, IMAGE *out )
3222 {
3223 	IMAGE *t1;
3224 	if( !(t1 = im_open_local( out, "im_histeq", "p" )) ||
3225 		im_histcum( in, t1 ) || 
3226 		im_histnorm( t1, out ) )
3227 		return( -1 );
3228 	return( 0 );
3229 }
3230 int 
3231 im_heq( VipsImage *in, VipsImage *out, int bandno )
3232 {
3233 	VipsImage *x;
3234 	if( vips_hist_equal( in, &amp;x, "band", bandno, NULL ) )
3235 		return( -1 );
3236 	if( vips_image_write( x, out ) ) {
3237 		g_object_unref( x );
3238 		return( -1 );
3239 	}
3240 	g_object_unref( x );
3241 	return( 0 ); 
3242 }
3243 int 
3244 im_hist( IMAGE *in, IMAGE *out, int bandno )
3245 {
3246 	IMAGE *hist;
3247 	if( !(hist = im_open_local( out, "im_hist", "p" )) ||
3248 		im_histgr( in, hist, bandno ) ||
3249 		im_histplot( hist, out ) )
3250 		return( -1 );
3251 	return( 0 );
3252 }
3253 int 
3254 im_histgr( IMAGE *in, IMAGE *out, int bandno )
3255 {
3256 	VipsImage *x;
3257 	if( vips_hist_find( in, &amp;x, 
3258 		"band", bandno,
3259 		NULL ) )
3260 		return( -1 );
3261 	if( vips_image_write( x, out ) ) {
3262 		g_object_unref( x );
3263 		return( -1 );
3264 	}
3265 	g_object_unref( x );
3266 	return( 0 );
3267 }
3268 int 
3269 im_stdif( IMAGE *in, IMAGE *out, 
3270 	double a, double m0, double b, double s0, 
3271 	int width, int height )
3272 {
3273 	VipsImage *x;
3274 	if( vips_stdif( in, &amp;x, width, height, 
3275 		"a", a,
3276 		"b", b,
3277 		"m0", m0,
3278 		"s0", s0,
3279 		NULL ) )
3280 		return( -1 );
3281 	if( vips_image_write( x, out ) ) {
3282 		g_object_unref( x );
3283 		return( -1 );
3284 	}
3285 	g_object_unref( x );
3286 	return( 0 );
3287 }
3288 int 
3289 im_lhisteq( VipsImage *in, VipsImage *out, int width, int height )
3290 {
3291 	VipsImage *x;
3292 	if( vips_hist_local( in, &amp;x, width, height, NULL ) )
3293 		return( -1 );
3294 	if( vips_image_write( x, out ) ) {
3295 		g_object_unref( x );
3296 		return( -1 );
3297 	}
3298 	g_object_unref( x );
3299 	return( 0 );
3300 }
3301 int 
3302 im_histnD( VipsImage *in, VipsImage *out, int bins )
3303 {
3304 	VipsImage *x;
3305 	if( vips_hist_find_ndim( in, &amp;x, 
3306 		"bins", bins,
3307 		NULL ) )
3308 		return( -1 );
3309 	if( vips_image_write( x, out ) ) {
3310 		g_object_unref( x );
3311 		return( -1 );
3312 	}
3313 	g_object_unref( x );
3314 	return( 0 );
3315 }
3316 int 
3317 im_hist_indexed( VipsImage *index, VipsImage *value, VipsImage *out )
3318 {
3319 	VipsImage *x;
3320 	if( vips_hist_find_indexed( value, index, &amp;x, NULL ) )
3321 		return( -1 );
3322 	if( vips_image_write( x, out ) ) {
3323 		g_object_unref( x );
3324 		return( -1 );
3325 	}
3326 	g_object_unref( x );
3327 	return( 0 );
3328 }
3329 int 
3330 im_project( IMAGE *in, IMAGE *hout, IMAGE *vout )
3331 {
3332 	VipsImage *x, *y;
3333 	if( vips_project( in, &amp;x, &amp;y, NULL ) )
3334 		return( -1 );
3335 	if( vips_image_write( x, hout ) ) {
3336 		g_object_unref( x );
3337 		g_object_unref( y );
3338 		return( -1 );
3339 	}
3340 	g_object_unref( x );
3341 	if( vips_image_write( y, vout ) ) {
3342 		g_object_unref( y );
3343 		return( -1 );
3344 	}
3345 	g_object_unref( y );
3346 	return( 0 );
3347 }
3348 int 
3349 im_profile( IMAGE *in, IMAGE *out, int dir )
3350 {
3351 	VipsImage *columns, *rows;
3352 	VipsImage *t1, *t2;
3353 	if( vips_profile( in, &amp;columns, &amp;rows, NULL ) )
3354 		return( -1 );
3355 	if( dir == 0 ) {
3356 		t1 = columns;
3357 		g_object_unref( rows );
3358 	}
3359 	else {
3360 		t1 = rows;
3361 		g_object_unref( columns );
3362 	}
3363 	if( vips_cast( t1, &amp;t2, VIPS_FORMAT_USHORT, NULL ) ) {
3364 		g_object_unref( t1 );
3365 		return( -1 );
3366 	}
3367 	g_object_unref( t1 );
3368 	if( vips_image_write( t2, out ) ) {
3369 		g_object_unref( t2 );
3370 		return( -1 );
3371 	}
3372 	g_object_unref( t2 );
3373 	return( 0 ); 
3374 }
3375 int
3376 im_erode( IMAGE *in, IMAGE *out, INTMASK *mask )
3377 {
3378 	VipsImage *t1, *t2;
3379 	if( !(t1 = vips_image_new()) ||
3380 		im_imask2vips( mask, t1 ) )
3381 		return( -1 );
3382 	if( vips_morph( in, &amp;t2, t1, VIPS_OPERATION_MORPHOLOGY_ERODE,
3383 		NULL ) ) {
3384 		g_object_unref( t1 );
3385 		return( -1 );
3386 	}
3387 	g_object_unref( t1 );
3388 	if( vips_image_write( t2, out ) ) {
3389 		g_object_unref( t2 );
3390 		return( -1 );
3391 	}
3392 	g_object_unref( t2 );
3393 	return( 0 );
3394 }
3395 int
3396 im_erode_raw( IMAGE *in, IMAGE *out, INTMASK *m )
3397 {
3398 	return( im_erode( in, out, m ) );
3399 }
3400 int
3401 im_dilate( IMAGE *in, IMAGE *out, INTMASK *mask )
3402 {
3403 	VipsImage *t1, *t2;
3404 	if( !(t1 = vips_image_new()) ||
3405 		im_imask2vips( mask, t1 ) )
3406 		return( -1 );
3407 	if( vips_morph( in, &amp;t2, t1, VIPS_OPERATION_MORPHOLOGY_DILATE,
3408 		NULL ) ) {
3409 		g_object_unref( t1 );
3410 		return( -1 );
3411 	}
3412 	g_object_unref( t1 );
3413 	if( vips_image_write( t2, out ) ) {
3414 		g_object_unref( t2 );
3415 		return( -1 );
3416 	}
3417 	g_object_unref( t2 );
3418 	return( 0 );
3419 }
3420 int
3421 im_dilate_raw( IMAGE *in, IMAGE *out, INTMASK *m )
3422 {
3423 	return( im_dilate( in, out, m ) );
3424 }
3425 int
3426 im_mpercent( IMAGE *in, double percent, int *out )
3427 {
3428 	if( vips_percent( in, percent * 100.0, out, NULL ) )
3429 		return( -1 ); 
3430 	return( 0 );
3431 }
3432 int
3433 im_mpercent_hist( IMAGE *in, double percent, int *out )
3434 {
3435 	vips_error( "im_mpercent_hist", "%s", _( "no compat implemented" ) ); 
3436 	return( -1 ); 
3437 }
3438 int 
3439 im_hsp( IMAGE *in, IMAGE *ref, IMAGE *out )
3440 {
3441 	IMAGE *t[3];
3442 	if( im_open_local_array( out, t, 3, "im_hsp", "p" ) ||
3443 		im_histgr( in, t[0], -1 ) || 
3444 		im_histgr( ref, t[1], -1 ) ||
3445 		im_histspec( t[0], t[1], t[2] ) ||
3446 		im_maplut( in, out, t[2] ) )
3447 		return( -1 );
3448 	return( 0 );
3449 }
3450 static int
3451 match( VipsImage *in, VipsImage *ref, VipsImage *out )
3452 {
3453 	VipsImage *x;
3454 	if( vips_hist_match( in, ref, &amp;x, NULL ) )
3455 		return( -1 );
3456 	if( vips_image_write( x, out ) ) {
3457 		g_object_unref( x );
3458 		return( -1 );
3459 	}
3460 	g_object_unref( x );
3461 	return( 0 );
3462 }
3463 int 
3464 im_histspec( IMAGE *in, IMAGE *ref, IMAGE *out )
3465 {
3466 	IMAGE *t[5];
3467 	guint64 px;
3468 	int fmt;
3469 	if( im_check_uint( "im_histspec", in ) ||
3470 		im_check_uint( "im_histspec", ref ) )
3471 		return( -1 );
3472 	if( im_open_local_array( out, t, 5, "im_histspec", "p" ) ||
3473 		im_histeq( in, t[0] ) || 
3474 		im_histeq( ref, t[2] ) ||
3475 		match( t[0], t[2], t[4] ) )
3476 		return( -1 );
3477 	px = VIPS_IMAGE_N_PELS( t[4] );
3478 	if( px &lt;= 256 ) 
3479 		fmt = IM_BANDFMT_UCHAR;
3480 	else if( px &lt;= 65536 ) 
3481 		fmt = IM_BANDFMT_USHORT;
3482 	else 
3483 		fmt = IM_BANDFMT_UINT;
3484 	if( im_clip2fmt( t[4], out, fmt ) )
3485 		return( -1 );
3486         return( 0 );
3487 }
3488 int 
3489 im_falsecolour( IMAGE *in, IMAGE *out )
3490 {
3491 	VipsImage *x;
3492 	if( vips_falsecolour( in, &amp;x, NULL ) )
3493 		return( -1 );
3494 	if( vips_image_write( x, out ) ) {
3495 		g_object_unref( x );
3496 		return( -1 );
3497 	}
3498 	g_object_unref( x );
3499 	return( 0 );
3500 }
3501 int 
3502 im_gammacorrect( IMAGE *in, IMAGE *out, double exponent )
3503 {
3504 	VipsImage *x;
3505 	if( vips_gamma( in, &amp;x, 
3506 		"exponent", 1.0 / exponent,
3507 		NULL ) )
3508 		return( -1 );
3509 	if( vips_image_write( x, out ) ) {
3510 		g_object_unref( x );
3511 		return( -1 );
3512 	}
3513 	g_object_unref( x );
3514 	return( 0 );
3515 }
3516 int
3517 im_tile_cache( IMAGE *in, IMAGE *out,
3518 	int tile_width, int tile_height, int max_tiles )
3519 {
3520 	VipsImage *x;
3521 	if( vips_tilecache( in, &amp;x, 
3522 		"tile_width", tile_width, 
3523 		"tile_height", tile_height, 
3524 		"max_tiles", max_tiles, 
3525 		"access", VIPS_ACCESS_SEQUENTIAL,
3526 		"threaded", TRUE, 
3527 		NULL ) )
3528 		return( -1 );
3529 	if( vips_image_write( x, out ) ) {
3530 		g_object_unref( x );
3531 		return( -1 );
3532 	}
3533 	g_object_unref( x );
3534 	return( 0 );
3535 }
3536 int
3537 im_tile_cache_random( IMAGE *in, IMAGE *out,
3538 	int tile_width, int tile_height, int max_tiles )
3539 {
3540 	VipsImage *x;
3541 	if( vips_tilecache( in, &amp;x, 
3542 		"tile_width", tile_width, 
3543 		"tile_height", tile_height, 
3544 		"max_tiles", max_tiles, 
3545 		"access", VIPS_ACCESS_RANDOM,
3546 		"persistent", TRUE,
3547 		"threaded", TRUE, 
3548 		NULL ) )
3549 		return( -1 );
3550 	if( vips_image_write( x, out ) ) {
3551 		g_object_unref( x );
3552 		return( -1 );
3553 	}
3554 	g_object_unref( x );
3555 	return( 0 );
3556 }
3557 static int 
3558 im__affinei( VipsImage *in, VipsImage *out, 
3559 	VipsInterpolate *interpolate, VipsTransformation *trn )
3560 {
3561 	VipsImage **t = (VipsImage **) 
3562 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
3563 	VipsArea *oarea;
3564 	gboolean repack;
3565 	oarea = VIPS_AREA( vips_array_int_newv( 4, 
3566 		trn-&gt;oarea.left, trn-&gt;oarea.top,
3567 		trn-&gt;oarea.width, trn-&gt;oarea.height ) );
3568 	repack = in-&gt;Coding == IM_CODING_LABQ;
3569 	if( vips_affine( in, &amp;t[0], 
3570 		trn-&gt;a, trn-&gt;b, trn-&gt;c, trn-&gt;d,
3571 		"interpolate", interpolate,
3572 		"oarea", oarea,
3573 		"odx", trn-&gt;odx,
3574 		"ody", trn-&gt;ody,
3575 		NULL ) ) {
3576 		vips_area_unref( oarea );
3577 		return( -1 );
3578 	}
3579 	vips_area_unref( oarea );
3580 	in = t[0];
3581 	if( repack ) {
3582 		if( vips_colourspace( in, &amp;t[1], 
3583 			VIPS_INTERPRETATION_LABQ, NULL ) )
3584 			return( -1 );
3585 		in = t[1];
3586 	}
3587 	if( vips_image_write( in, out ) ) 
3588 		return( -1 );
3589 	return( 0 );
3590 }
3591 int 
3592 im_affinei( VipsImage *in, VipsImage *out, VipsInterpolate *interpolate,
3593 	double a, double b, double c, double d, double odx, double ody, 
3594 	int ox, int oy, int ow, int oh )
3595 {
3596 	VipsTransformation trn;
3597 	trn.iarea.left = 0;
3598 	trn.iarea.top = 0;
3599 	trn.iarea.width = in-&gt;Xsize;
3600 	trn.iarea.height = in-&gt;Ysize;
3601 	trn.oarea.left = ox;
3602 	trn.oarea.top = oy;
3603 	trn.oarea.width = ow;
3604 	trn.oarea.height = oh;
3605 	trn.a = a;
3606 	trn.b = b;
3607 	trn.c = c;
3608 	trn.d = d;
3609 	trn.idx = 0;
3610 	trn.idy = 0;
3611 	trn.odx = odx;
3612 	trn.ody = ody;
3613 	return( im__affinei( in, out, interpolate, &amp;trn ) );
3614 }
3615 int 
3616 im_affinei_all( VipsImage *in, VipsImage *out, VipsInterpolate *interpolate,
3617 	double a, double b, double c, double d, double odx, double ody ) 
3618 {
3619 	VipsTransformation trn;
3620 	trn.iarea.left = 0;
3621 	trn.iarea.top = 0;
3622 	trn.iarea.width = in-&gt;Xsize;
3623 	trn.iarea.height = in-&gt;Ysize;
3624 	trn.a = a;
3625 	trn.b = b;
3626 	trn.c = c;
3627 	trn.d = d;
3628 	trn.idx = 0;
3629 	trn.idy = 0;
3630 	trn.odx = odx;
3631 	trn.ody = ody;
3632 	vips__transform_set_area( &amp;trn );
3633 	return( im__affinei( in, out, interpolate, &amp;trn ) );
3634 }
3635 int 
3636 vips__affine( VipsImage *in, VipsImage *out, VipsTransformation *trn )
3637 {
3638 	return( im__affinei( in, out, 
3639 		vips_interpolate_bilinear_static(), trn ) );
3640 }
3641 int
3642 im_copy_file( IMAGE *in, IMAGE *out )
3643 {
3644 	VipsImage *x;
3645 	if( vips_copy_file( in, &amp;x, NULL ) )
3646 		return( -1 );
3647 	if( vips_image_write( x, out ) ) {
3648 		g_object_unref( x );
3649 		return( -1 );
3650 	}
3651 	g_object_unref( x );
3652 	return( 0 );
3653 }
3654 int
3655 im_video_v4l1( IMAGE *im, const char *device,
3656 	int channel, int brightness, int colour, int contrast, int hue, 
3657 	int ngrabs )
3658 {
3659 	im_error( "im_video_v4l1", 
3660 		"%s", _( "compiled without im_video_v4l1 support" ) );
3661 	return( -1 );
3662 }
3663 int 
3664 im_fwfft( IMAGE *in, IMAGE *out )
3665 {
3666 	VipsImage *x;
3667 	if( vips_fwfft( in, &amp;x, NULL ) )
3668 		return( -1 );
3669 	if( vips_image_write( x, out ) ) {
3670 		g_object_unref( x );
3671 		return( -1 );
3672 	}
3673 	g_object_unref( x );
3674 	return( 0 );
3675 }
3676 int 
3677 im_invfft( IMAGE *in, IMAGE *out )
3678 {
3679 	VipsImage *x;
3680 	if( vips_invfft( in, &amp;x, NULL ) )
3681 		return( -1 );
3682 	if( vips_image_write( x, out ) ) {
3683 		g_object_unref( x );
3684 		return( -1 );
3685 	}
3686 	g_object_unref( x );
3687 	return( 0 );
3688 }
3689 int 
3690 im_invfftr( IMAGE *in, IMAGE *out )
3691 {
3692 	VipsImage *x;
3693 	if( vips_invfft( in, &amp;x, 
3694 		"real", TRUE,
3695 		NULL ) )
3696 		return( -1 );
3697 	if( vips_image_write( x, out ) ) {
3698 		g_object_unref( x );
3699 		return( -1 );
3700 	}
3701 	g_object_unref( x );
3702 	return( 0 );
3703 }
3704 int 
3705 im_freqflt( IMAGE *in, IMAGE *mask, IMAGE *out )
3706 {
3707 	VipsImage *x;
3708 	if( vips_freqmult( in, mask, &amp;x, NULL ) )
3709 		return( -1 );
3710 	if( vips_image_write( x, out ) ) {
3711 		g_object_unref( x );
3712 		return( -1 );
3713 	}
3714 	g_object_unref( x );
3715 	return( 0 );
3716 }
3717 int 
3718 im_disp_ps( IMAGE *in, IMAGE *out )
3719 {
3720 	VipsImage *t;
3721 	if( vips_spectrum( in, &amp;t, NULL ) )
3722 		return( -1 );
3723 	if( vips_image_write( t, out ) ) {
3724 		g_object_unref( t );
3725 		return( -1 );
3726 	}
3727 	g_object_unref( t );
3728 	return( 0 );
3729 }
3730 int 
3731 im_fractsurf( IMAGE *out, int size, double frd )
3732 {
3733 	VipsImage *t;
3734 	if( vips_fractsurf( &amp;t, size, size, frd, NULL ) )
3735 		return( -1 );
3736 	if( vips_image_write( t, out ) ) {
3737 		g_object_unref( t );
3738 		return( -1 );
3739 	}
3740 	g_object_unref( t );
3741 	return( 0 );
3742 }
3743 int 
3744 im_phasecor_fft( IMAGE *in1, IMAGE *in2, IMAGE *out )
3745 {
3746 	VipsImage *x;
3747 	if( vips_phasecor( in1, in2, &amp;x, NULL ) )
3748 		return( -1 );
3749 	if( vips_image_write( x, out ) ) {
3750 		g_object_unref( x );
3751 		return( -1 );
3752 	}
3753 	g_object_unref( x );
3754 	return( 0 );
3755 }
3756 int 
3757 im_cntlines( VipsImage *im, double *nolines, int flag )
3758 {
3759 	return( vips_countlines( im, nolines, 
3760 		flag == 0 ? 
3761 			VIPS_DIRECTION_HORIZONTAL : VIPS_DIRECTION_VERTICAL,
3762 		NULL ) );
3763 }
3764 int
3765 im_label_regions( IMAGE *test, IMAGE *mask, int *segments )
3766 {
3767 	VipsImage *x;
3768 	if( vips_labelregions( test, &amp;x, "segments", segments, NULL ) )
3769 		return( -1 );
3770 	if( vips_image_write( x, mask ) ) {
3771 		g_object_unref( x );
3772 		return( -1 );
3773 	}
3774 	g_object_unref( x );
3775 	return( 0 );
3776 }
3777 int 
3778 im_rank( IMAGE *in, IMAGE *out, int width, int height, int index )
3779 {
3780 	VipsImage *x;
3781 	if( vips_rank( in, &amp;x, width, height, index, NULL ) )
3782 		return( -1 );
3783 	if( vips_image_write( x, out ) ) {
3784 		g_object_unref( x );
3785 		return( -1 );
3786 	}
3787 	g_object_unref( x );
3788 	return( 0 );
3789 }
3790 int
3791 im_rank_raw( IMAGE *in, IMAGE *out, int width, int height, int index )
3792 {
3793 	im_error( "im_rank_raw", "no compat function" );
3794 	return( -1 );
3795 }
3796 int
3797 im_draw_circle( VipsImage *image, 
3798 	int x, int y, int radius, gboolean fill, VipsPel *ink )
3799 {
3800 	double *vec;
3801 	int n;
3802 	if( !(vec = vips__ink_to_vector( "im_draw_circle", image, ink, &amp;n )) )
3803 		return( -1 ); 
3804 	return( vips_draw_circle( image, vec, n, x, y, radius,
3805 		"fill", fill,
3806 		NULL ) ); 
3807 }
3808 int 
3809 im_draw_line( VipsImage *image, int x1, int y1, int x2, int y2, VipsPel *ink )
3810 {
3811 	double *vec;
3812 	int n;
3813 	if( !(vec = vips__ink_to_vector( "im_draw_line", image, ink, &amp;n )) )
3814 		return( -1 ); 
3815 	return( vips_draw_line( image, vec, n, x1, y1, x2, y2, NULL ) ); 
3816 }
3817 typedef struct _Line {
3818 	VipsPlotFn plot;
3819 	void *a;
3820 	void *b;
3821 	void *c;
3822 } Line;
3823 static void
3824 draw_line_wrapper( VipsImage *image, int x, int y, void *client )
3825 {
3826 	Line *line = (Line *) client;
3827 	line-&gt;plot( image, x, y, line-&gt;a, line-&gt;b, line-&gt;c ); 
3828 }
3829 int 
3830 im_draw_line_user( VipsImage *image, 
3831 	int x1, int y1, int x2, int y2, 
3832 	VipsPlotFn plot, void *a, void *b, void *c )
3833 {
3834 	Line line;
3835 	line.plot = plot;
3836 	line.a = a;
3837 	line.b = b;
3838 	line.c = c;
3839 	vips__draw_line_direct( image, x1, y1, x2, y2, 
3840 		draw_line_wrapper, &amp;line ); 
3841 	return( 0 );
3842 }
3843 int
3844 im_draw_mask( VipsImage *image, VipsImage *mask, int x, int y, VipsPel *ink )
3845 {
3846 	return( vips__draw_mask_direct( image, mask, ink, x, y ) ); 
3847 }
3848 int
3849 im_draw_image( VipsImage *image, VipsImage *sub, int x, int y )
3850 {
3851 	return( vips_draw_image( image, sub, x, y, NULL ) ); 
3852 }
3853 int
3854 im_draw_rect( IMAGE *image, 
3855 	int left, int top, int width, int height, int fill, VipsPel *ink )
3856 {
3857 	double *vec;
3858 	int n;
3859 	if( !(vec = vips__ink_to_vector( "im_draw_rect", image, ink, &amp;n )) )
3860 		return( -1 ); 
3861 	return( vips_draw_rect( image, vec, n, left, top, width, height,
3862 		"fill", fill, 
3863 		NULL ) ); 
3864 }
3865 int
3866 im_draw_point( VipsImage *image, int x, int y, VipsPel *ink )
3867 {
3868 	double *vec;
3869 	int n;
3870 	if( !(vec = vips__ink_to_vector( "im_draw_rect", image, ink, &amp;n )) )
3871 		return( -1 ); 
3872 	return( vips_draw_point( image, vec, n, x, y, NULL ) ); 
3873 }
3874 int
3875 im_draw_smudge( VipsImage *im, int left, int top, int width, int height )
3876 {
3877 	return( vips_draw_smudge( im, left, top, width, height, NULL ) ); 
3878 }
3879 int
3880 im_read_point( VipsImage *image, int x, int y, VipsPel *ink )
3881 {
3882 	double *vector;
3883 	int n;
3884 	VipsPel *pixel_vector;
3885 	if( vips_getpoint( image, &amp;vector, &amp;n, x, y, NULL ) )
3886 		return( -1 );
3887 	if( !(pixel_vector = vips__vector_to_ink( "im_read_point", 
3888 		image, vector, NULL, n )) ) {
3889 		g_free( vector );
3890 		return( -1 );
3891 	}
3892 	memcpy( ink, pixel_vector, VIPS_IMAGE_SIZEOF_PEL( image ) ); 
3893 	g_free( vector );
3894 	return( 0 );
3895 }
3896 int
3897 im_draw_flood( IMAGE *image, int x, int y, VipsPel *ink, Rect *dout )
3898 {
3899 	double *vec;
3900 	int n;
3901 	int left;
3902 	int top;
3903 	int width;
3904 	int height;
3905 	if( !(vec = vips__ink_to_vector( "im_draw_flood", image, ink, &amp;n )) )
3906 		return( -1 ); 
3907 	if( vips_draw_flood( image, vec, n, x, y,
3908 		"left", &amp;left,
3909 		"top", &amp;top,
3910 		"width", &amp;width,
3911 		"height", &amp;height,
3912 		NULL ) )
3913 		return( -1 ); 
3914 	if( dout ) { 
3915 		dout-&gt;left = left; 
3916 		dout-&gt;top = top; 
3917 		dout-&gt;width = width; 
3918 		dout-&gt;height = height; 
3919 	}
3920 	return( 0 ); 
3921 }
3922 int
3923 im_draw_flood_blob( IMAGE *image, int x, int y, VipsPel *ink, Rect *dout )
3924 {
3925 	double *vec;
3926 	int n;
3927 	int left;
3928 	int top;
3929 	int width;
3930 	int height;
3931 	if( !(vec = vips__ink_to_vector( "im_draw_flood", image, ink, &amp;n )) )
3932 		return( -1 ); 
3933 	if( vips_draw_flood( image, vec, n, x, y,
3934 		"equal", TRUE,
3935 		"left", &amp;left,
3936 		"top", &amp;top,
3937 		"width", &amp;width,
3938 		"height", &amp;height,
3939 		NULL ) )
3940 		return( -1 ); 
3941 	if( dout ) { 
3942 		dout-&gt;left = left; 
3943 		dout-&gt;top = top; 
3944 		dout-&gt;width = width; 
3945 		dout-&gt;height = height; 
3946 	}
3947 	return( 0 ); 
3948 }
3949 int
3950 im_draw_flood_other( IMAGE *image, 
3951 	IMAGE *test, int x, int y, int serial, Rect *dout )
3952 {
3953 	int left;
3954 	int top;
3955 	int width;
3956 	int height;
3957 	if( vips_draw_flood1( image, serial, x, y,
3958 		"test", test,
3959 		"equal", TRUE,
3960 		"left", &amp;left,
3961 		"top", &amp;top,
3962 		"width", &amp;width,
3963 		"height", &amp;height,
3964 		NULL ) )
3965 		return( -1 ); 
3966 	if( dout ) { 
3967 		dout-&gt;left = left; 
3968 		dout-&gt;top = top; 
3969 		dout-&gt;width = width; 
3970 		dout-&gt;height = height; 
3971 	} 
3972 	return( 0 ); 
3973 }
3974 int
3975 im_lineset( IMAGE *in, IMAGE *out, IMAGE *mask, IMAGE *ink,
3976 <a name="1"></a>	int n, int *x1v, int *y1v, int *x2v, int *y2v )
3977 {
3978 	Rect mask_rect;
3979 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int i;
3980 	if( mask-&gt;Bands != 1 || mask-&gt;BandFmt != IM_BANDFMT_UCHAR ||
3981 		mask-&gt;Coding != IM_CODING_NONE ) {
3982 		im_error( "im_lineset", 
3983 			"%s", _( "mask image not 1 band 8 bit uncoded" ) );
3984 		return( -1 );
3985 	}
3986 	if( ink-&gt;Bands != in-&gt;Bands || ink-&gt;BandFmt != in-&gt;BandFmt ||
3987 		ink-&gt;Coding != in-&gt;Coding ) {
3988 		im_error( "im_lineset", 
3989 			"%s", _( "ink image does not match in image" ) );
3990 		return( -1 );
3991 	}
3992 	if( ink-&gt;Xsize != 1 || ink-&gt;Ysize != 1 ) {
3993 		im_error( "im_lineset", "%s", _( "ink image not 1x1 pixels" ) );
3994 		return( -1 );
3995 	}</b></font>
3996 	if( vips_image_write( in, out ) )
3997 		return( -1 );
3998 	mask_rect.left = mask-&gt;Xsize / 2;
3999 	mask_rect.top = mask-&gt;Ysize / 2;
4000 	mask_rect.width = mask-&gt;Xsize;
4001 	mask_rect.height = mask-&gt;Ysize;
4002 	if( im_incheck( ink ) ||
4003 		im_incheck( mask ) )
4004 		return( -1 );
4005 	for( i = 0; i &lt; n; i++ ) {
4006 		if( im_fastlineuser( out, x1v[i], y1v[i], x2v[i], y2v[i], 
4007 			(VipsPlotFn) im_plotmask, ink-&gt;data, mask-&gt;data, &amp;mask_rect ) )
4008 			return( -1 );
4009 	}
4010 	return( 0 );
4011 }
4012 int
4013 im_match_linear_search( IMAGE *ref, IMAGE *sec, IMAGE *out,
4014 	int xr1, int yr1, int xs1, int ys1, 
4015 	int xr2, int yr2, int xs2, int ys2,
4016 	int hwindowsize, int hsearchsize )
4017 {
4018 	VipsImage *x;
4019 	if( vips_match( ref, sec, &amp;x,
4020 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4021 		"search", TRUE,
4022 		"hwindow", hwindowsize,
4023 		"harea", hsearchsize,
4024 		NULL ) )
4025 		return( -1 );
4026 	if( vips_image_write( x, out ) ) {
4027 		g_object_unref( x );
4028 		return( -1 );
4029 	}
4030 	g_object_unref( x );
4031 	return( 0 );
4032 }
4033 int
4034 im_match_linear( IMAGE *ref, IMAGE *sec, IMAGE *out,
4035 	int xr1, int yr1, int xs1, int ys1, 
4036 	int xr2, int yr2, int xs2, int ys2 )
4037 { 
4038 	VipsImage *x;
4039 	if( vips_match( ref, sec, &amp;x,
4040 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4041 		NULL ) )
4042 		return( -1 );
4043 	if( vips_image_write( x, out ) ) {
4044 		g_object_unref( x );
4045 		return( -1 );
4046 	}
4047 	g_object_unref( x );
4048 	return( 0 );
4049 }
4050 int
4051 im_global_balance( IMAGE *in, IMAGE *out, double gamma )
4052 {
4053 	VipsImage *x;
4054 	if( vips_globalbalance( in, &amp;x,
4055 		"gamma", gamma,
4056 		"int_output", TRUE,
4057 		NULL ) )
4058 		return( -1 );
4059 	if( vips_image_write( x, out ) ) {
4060 		g_object_unref( x );
4061 		return( -1 );
4062 	}
4063 	g_object_unref( x );
4064 	return( 0 );
4065 }
4066 int 
4067 im_histplot( IMAGE *in, IMAGE *out )
4068 {
4069 	VipsImage *x;
4070 	if( vips_hist_plot( in, &amp;x, NULL ) )
4071 		return( -1 );
4072 	if( vips_image_write( x, out ) ) {
4073 		g_object_unref( x );
4074 		return( -1 );
4075 	}
4076 	g_object_unref( x );
4077 	return( 0 );
4078 }
4079 int
4080 im_global_balancef( IMAGE *in, IMAGE *out, double gamma )
4081 {
4082 	VipsImage *x;
4083 	if( vips_globalbalance( in, &amp;x,
4084 		"gamma", gamma,
4085 		NULL ) )
4086 		return( -1 );
4087 	if( vips_image_write( x, out ) ) {
4088 		g_object_unref( x );
4089 		return( -1 );
4090 	}
4091 	g_object_unref( x );
4092 	return( 0 );
4093 }
4094 int
4095 im_remosaic( IMAGE *in, IMAGE *out, const char *old_str, const char *new_str )
4096 {
4097 	VipsImage *x;
4098 	if( vips_remosaic( in, &amp;x, old_str, new_str, NULL ) ) 
4099 		return( -1 );
4100 	if( vips_image_write( x, out ) ) {
4101 		g_object_unref( x );
4102 		return( -1 );
4103 	}
4104 	g_object_unref( x );
4105 	return( 0 );
4106 }
4107 int
4108 im_lrmosaic( IMAGE *ref, IMAGE *sec, IMAGE *out,
4109 	int bandno,
4110 	int xref, int yref, int xsec, int ysec,
4111  	int hwindowsize, int hsearchsize,
4112 	int balancetype,
4113 	int mwidth )
4114 {
4115 	VipsImage *x;
4116 	if( vips_mosaic( ref, sec, &amp;x, VIPS_DIRECTION_HORIZONTAL,
4117 		xref, yref, xsec, ysec,
4118 		"hwindow", hwindowsize,
4119 		"harea", hsearchsize,
4120 		"mblend", mwidth,
4121 		NULL ) ) 
4122 		return( -1 );
4123 	if( vips_image_write( x, out ) ) {
4124 		g_object_unref( x );
4125 		return( -1 );
4126 	}
4127 	g_object_unref( x );
4128 	return( 0 );
4129 }
4130 int
4131 im_lrmosaic1( IMAGE *ref, IMAGE *sec, IMAGE *out, 
4132 	int bandno,
4133 	int xr1, int yr1, int xs1, int ys1, 
4134 	int xr2, int yr2, int xs2, int ys2,
4135 	int hwindowsize, int hsearchsize,
4136 	int balancetype,
4137 	int mwidth )
4138 { 
4139 	VipsImage *x;
4140 	if( vips_mosaic1( ref, sec, &amp;x, VIPS_DIRECTION_HORIZONTAL,
4141 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4142 		"search", TRUE,
4143 		"bandno", bandno,
4144 		"hwindow", hwindowsize,
4145 		"harea", hsearchsize,
4146 		"mblend", mwidth,
4147 		NULL ) ) 
4148 		return( -1 );
4149 	if( vips_image_write( x, out ) ) {
4150 		g_object_unref( x );
4151 		return( -1 );
4152 	}
4153 	g_object_unref( x );
4154 	return( 0 );
4155 }
4156 int
4157 im_tbmosaic( IMAGE *ref, IMAGE *sec, IMAGE *out,
4158 	int bandno,
4159 	int xref, int yref, int xsec, int ysec,
4160  	int hwindowsize, int hsearchsize,
4161 	int balancetype,
4162 	int mwidth )
4163 {
4164 	VipsImage *x;
4165 	if( vips_mosaic( ref, sec, &amp;x, VIPS_DIRECTION_VERTICAL,
4166 		xref, yref, xsec, ysec,
4167 		"hwindow", hwindowsize,
4168 		"harea", hsearchsize,
4169 		"mblend", mwidth,
4170 		NULL ) ) 
4171 		return( -1 );
4172 	if( vips_image_write( x, out ) ) {
4173 		g_object_unref( x );
4174 		return( -1 );
4175 	}
4176 	g_object_unref( x );
4177 	return( 0 );
4178 }
4179 int
4180 im_tbmosaic1( IMAGE *ref, IMAGE *sec, IMAGE *out,
4181 	int bandno,
4182 	int xr1, int yr1, int xs1, int ys1, 
4183 	int xr2, int yr2, int xs2, int ys2,
4184 	int hwindowsize, int hsearchsize,
4185 	int balancetype,
4186 	int mwidth )
4187 { 
4188 	VipsImage *x;
4189 	if( vips_mosaic1( ref, sec, &amp;x, VIPS_DIRECTION_VERTICAL,
4190 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4191 		"search", TRUE,
4192 		"bandno", bandno,
4193 		"hwindow", hwindowsize,
4194 		"harea", hsearchsize,
4195 		"mblend", mwidth,
4196 		NULL ) ) 
4197 		return( -1 );
4198 	if( vips_image_write( x, out ) ) {
4199 		g_object_unref( x );
4200 		return( -1 );
4201 	}
4202 	g_object_unref( x );
4203 	return( 0 );
4204 }
4205 int
4206 im_correl( VipsImage *ref, VipsImage *sec,
4207 	int xref, int yref, int xsec, int ysec,
4208 	int hwindowsize, int hsearchsize,
4209 	double *correlation, int *x, int *y )
4210 {
4211 	return( vips__correl( ref, sec, xref, yref, xsec, ysec,
4212 		hwindowsize, hsearchsize, correlation, x, y ) );
4213 }
4214 int
4215 im_lrmerge( IMAGE *ref, IMAGE *sec, IMAGE *out,
4216 	int dx, int dy, int mwidth )
4217 {
4218 	VipsImage *x;
4219 	if( vips_merge( ref, sec, &amp;x, VIPS_DIRECTION_HORIZONTAL, dx, dy,
4220 		"mblend", mwidth,
4221 		NULL ) ) 
4222 		return( -1 );
4223 	if( vips_image_write( x, out ) ) {
4224 		g_object_unref( x );
4225 		return( -1 );
4226 	}
4227 	g_object_unref( x );
4228 	return( 0 );
4229 }
4230 int
4231 im_lrmerge1( IMAGE *ref, IMAGE *sec, IMAGE *out,
4232 	int xr1, int yr1, int xs1, int ys1, 
4233 	int xr2, int yr2, int xs2, int ys2,
4234 	int mwidth )
4235 {
4236 	VipsImage *x;
4237 	if( vips_mosaic1( ref, sec, &amp;x, VIPS_DIRECTION_HORIZONTAL,
4238 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4239 		"mblend", mwidth,
4240 		NULL ) ) 
4241 		return( -1 );
4242 	if( vips_image_write( x, out ) ) {
4243 		g_object_unref( x );
4244 		return( -1 );
4245 	}
4246 	g_object_unref( x );
4247 	return( 0 );
4248 }
4249 int
4250 im_tbmerge( IMAGE *ref, IMAGE *sec, IMAGE *out,
4251 	int dx, int dy, int mwidth )
4252 {
4253 	VipsImage *x;
4254 	if( vips_merge( ref, sec, &amp;x, VIPS_DIRECTION_VERTICAL, dx, dy,
4255 		"mblend", mwidth,
4256 		NULL ) ) 
4257 		return( -1 );
4258 	if( vips_image_write( x, out ) ) {
4259 		g_object_unref( x );
4260 		return( -1 );
4261 	}
4262 	g_object_unref( x );
4263 	return( 0 );
4264 }
4265 int
4266 im_tbmerge1( IMAGE *ref, IMAGE *sec, IMAGE *out,
4267 	int xr1, int yr1, int xs1, int ys1, 
4268 	int xr2, int yr2, int xs2, int ys2,
4269 	int mwidth )
4270 {
4271 	VipsImage *x;
4272 	if( vips_mosaic1( ref, sec, &amp;x, VIPS_DIRECTION_VERTICAL,
4273 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2,
4274 		"mblend", mwidth,
4275 		NULL ) ) 
4276 		return( -1 );
4277 	if( vips_image_write( x, out ) ) {
4278 		g_object_unref( x );
4279 		return( -1 );
4280 	}
4281 	g_object_unref( x );
4282 	return( 0 );
4283 }
4284 IMAGE **
4285 im__insert_base( const char *domain, 
4286 	IMAGE *in1, IMAGE *in2, IMAGE *out ) 
4287 {
4288 	IMAGE *t[4];
4289 	IMAGE **vec;
4290 	if( im_piocheck( in1, out ) || 
4291 		im_pincheck( in2 ) ||
4292 		im_check_bands_1orn( domain, in1, in2 ) ||
4293 		im_check_coding_known( domain, in1 ) ||
4294 		im_check_coding_same( domain, in1, in2 ) )
4295 		return( NULL );
4296 	if( im_open_local_array( out, t, 4, domain, "p" ) ||
4297 		im__formatalike( in1, in2, t[0], t[1] ) ||
4298 		im__bandalike( domain, t[0], t[1], t[2], t[3] ) ||
4299 		!(vec = im_allocate_input_array( out, t[2], t[3], NULL )) )
4300 		return( NULL );
4301 	if( im_cp_descv( out, vec[0], vec[1], NULL ) ||
4302 		im_demand_hint_array( out, IM_SMALLTILE, vec ) )
4303 		return( NULL );
4304 	return( vec );
4305 }
4306 int
4307 im_insertset( IMAGE *main, IMAGE *sub, IMAGE *out, int n, int *x, int *y )
4308 {
4309 	IMAGE **vec;
4310 	IMAGE *t;
4311 	int i;
4312 	if( !(vec = im__insert_base( "im_insert", main, sub, out )) )
4313 		return( -1 );
4314 	if( !(t = im_open_local( out, "im_insertset", "t" )) ||
4315 		im_copy( vec[0], t ) )
4316 		return( -1 );
4317 	for( i = 0; i &lt; n; i++ ) 
4318 		if( im_insertplace( t, vec[1], x[i], y[i] ) )
4319 			return( -1 );
4320 	if( im_copy( t, out ) )
4321 		return( -1 );
4322 	return( 0 );
4323 }
4324 int
4325 vips__init( const char *argv0 )
4326 {
4327 	return( vips_init( argv0 ) );
4328 }
4329 int
4330 im_greyc_mask( IMAGE *in, IMAGE *out, IMAGE *mask,
4331 	int iterations,
4332 	float amplitude, float sharpness, float anisotropy,
4333 	float alpha, float sigma,
4334 	float dl, float da, float gauss_prec,
4335 	int interpolation, int fast_approx )
4336 {
4337 	vips_error( "im_greyc_mask", 
4338 		"This function is no longer in the core library" ); 
4339 	return( -1 ); 
4340 }
4341 int
4342 vips_check_imask( const char *domain, INTMASK *mask )
4343 {
4344 	if( !mask || 
4345 		mask-&gt;xsize &gt; 1000 || 
4346 		mask-&gt;ysize &gt; 1000 || 
4347 		mask-&gt;xsize &lt;= 0 || 
4348 		mask-&gt;ysize &lt;= 0 || 
4349 		mask-&gt;scale == 0 || 
4350 		!mask-&gt;coeff ) {
4351 		vips_error( domain, "%s", _( "nonsense mask parameters" ) );
4352 		return( -1 );
4353 	}
4354 	return( 0 );
4355 }
4356 int
4357 vips_check_dmask( const char *domain, DOUBLEMASK *mask )
4358 {
4359 	if( !mask || 
4360 		mask-&gt;xsize &gt; 1000 || 
4361 		mask-&gt;ysize &gt; 1000 || 
4362 		mask-&gt;xsize &lt;= 0 || 
4363 		mask-&gt;ysize &lt;= 0 || 
4364 		mask-&gt;scale == 0 || 
4365 		!mask-&gt;coeff ) {
4366 		vips_error( domain, "%s", _( "nonsense mask parameters" ) );
4367 		return( -1 );
4368 	}
4369 	return( 0 );
4370 }
4371 int
4372 vips_check_dmask_1d( const char *domain, DOUBLEMASK *mask )
4373 {
4374 	if( vips_check_dmask( domain, mask ) )
4375 		return( -1 );
4376 	if( mask-&gt;xsize != 1 &amp;&amp;
4377 		mask-&gt;ysize != 1 ) {
4378 		vips_error( domain, "%s", _( "mask must be 1D" ) );
4379 		return( -1 );
4380 	}
4381 	return( 0 );
4382 }
4383 GOptionGroup *
4384 vips_get_option_group( void )
4385 {
4386 	static GOptionGroup *option_group = NULL;
4387 	if( !option_group ) {
4388 		option_group = g_option_group_new( "vips", 
4389 				_( "VIPS Options" ), _( "Show VIPS options" ),
4390 				NULL, NULL );
4391 		vips_add_option_entries( option_group ); 
4392 	}
4393 	return( option_group );
4394 }
4395 FILE *
4396 vips_popenf( const char *fmt, const char *mode, ... )
4397 {
4398         vips_error( "popenf", "%s", _( "deprecated" ) );
4399         return( NULL );
4400 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
