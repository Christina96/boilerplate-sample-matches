<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for jpegload.c &amp; heifload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for jpegload.c &amp; heifload.c
      </h3>
<h1 align="center">
        25.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>jpegload.c (47.430832%)<th>heifload.c (17.857143%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(328-370)<td><a href="#" name="0">(1134-1179)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(205-240)<td><a href="#" name="1">(1226-1263)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(241-259)<td><a href="#" name="2">(941-957)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(394-410)<td><a href="#" name="3">(1195-1212)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(154-165)<td><a href="#" name="4">(1121-1132)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(273-293)<td><a href="#" name="5">(1081-1103)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(317-325)<td><a href="#" name="6">(1268-1278)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>jpegload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;setjmp.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #ifdef HAVE_JPEG
13 #ifdef HAVE_EXIF
14 #ifdef UNTAGGED_EXIF
15 #include &lt;exif-data.h&gt;
16 #include &lt;exif-loader.h&gt;
17 #include &lt;exif-ifd.h&gt;
18 #include &lt;exif-utils.h&gt;
19 #include &lt;libexif/exif-data.h&gt;
20 #include &lt;libexif/exif-loader.h&gt;
21 #include &lt;libexif/exif-ifd.h&gt;
22 #include &lt;libexif/exif-utils.h&gt;
23 typedef struct _VipsForeignLoadJpeg {
24 	VipsForeignLoad parent_object;
25 	VipsSource *source;
26 	int shrink;
27 	gboolean autorotate;
28 } VipsForeignLoadJpeg;
29 typedef VipsForeignLoadClass VipsForeignLoadJpegClass;
30 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadJpeg, vips_foreign_load_jpeg, 
31 	VIPS_TYPE_FOREIGN_LOAD );
32 static void
33 vips_foreign_load_jpeg_dispose( GObject *gobject )
34 {
35 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) gobject;
36 	VIPS_UNREF( jpeg-&gt;source );
37 	G_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
38 		dispose( gobject );
39 }
40 static int
41 vips_foreign_load_jpeg_build( VipsObject *object )
42 {
43 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
44 	if( jpeg-&gt;shrink != 1 &amp;&amp; 
45 		jpeg-&gt;shrink != 2 &amp;&amp; 
46 		jpeg-&gt;shrink != 4 &amp;&amp; 
47 		jpeg-&gt;shrink != 8 ) {
48 		vips_error( "VipsFormatLoadJpeg", 
49 			_( "bad shrink factor %d" ), jpeg-&gt;shrink );
50 		return( -1 );
51 	}
52 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
53 		build( object ) )
54 		return( -1 );
55 	return( 0 );
56 }
57 static VipsForeignFlags
58 vips_foreign_load_jpeg_get_flags( VipsForeignLoad *load )
59 {
60 	return( VIPS_FOREIGN_SEQUENTIAL );
61 }
62 static VipsForeignFlags
63 vips_foreign_load_jpeg_get_flags_filename( const char *filename )
64 {
65 	return( VIPS_FOREIGN_SEQUENTIAL );
66 }
67 static int
68 vips_foreign_load_jpeg_header( VipsForeignLoad *load )
69 {
70 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
71 	if( vips__jpeg_read_source( jpeg-&gt;source, 
72 		load-&gt;out, TRUE, jpeg-&gt;shrink, load-&gt;fail, jpeg-&gt;autorotate ) )
73 		return( -1 );
74 	return( 0 );
75 }
76 static int
77 vips_foreign_load_jpeg_load( VipsForeignLoad *load )
78 {
79 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
80 <a name="4"></a>	if( vips__jpeg_read_source( jpeg-&gt;source,
81 		load-&gt;real, FALSE, jpeg-&gt;shrink, load-&gt;fail, 
82 		jpeg-&gt;autorotate ) )
83 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
84 	return( 0 );
85 }
86 static void
87 vips_foreign_load_jpeg_class_init( VipsForeignLoadJpegClass *class )
88 {
89 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
90 	VipsObjectClass *object_class = (VipsObjectClass *) class;
91 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
92 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
93 	gobject_class-&gt;dispose = vips_foreign_load_jpeg_dispose;
94 	gobject_class-&gt;set_property = vips_object_set_property;
95 	gobject_class-&gt;get_property = vips_object_get_property;
96 	object_class-&gt;nickname = "jpegload_base";
97 	object_class-&gt;description = _( "load jpeg" );
98 	object_class-&gt;build = vips_foreign_load_jpeg_build;
99 	foreign_class-&gt;priority = 50;
100 	load_class-&gt;get_flags_filename = 
101 		vips_foreign_load_jpeg_get_flags_filename;
102 	load_class-&gt;get_flags = vips_foreign_load_jpeg_get_flags;
103 	load_class-&gt;header = vips_foreign_load_jpeg_header;
104 	load_class-&gt;load = vips_foreign_load_jpeg_load;
105 	VIPS_ARG_INT( class, "shrink", 20, 
106 		_( "Shrink" ), 
107 		_( "Shrink factor on load" ),
108 		VIPS_ARGUMENT_OPTIONAL_INPUT,
109 		G_STRUCT_OFFSET( VipsForeignLoadJpeg, shrink ),
110 		1, 16, 1 );
111 	VIPS_ARG_BOOL( class, "autorotate", 21, 
112 		_( "Autorotate" ), 
113 		_( "Rotate image using exif orientation" ),
114 		VIPS_ARGUMENT_OPTIONAL_INPUT,
115 		G_STRUCT_OFFSET( VipsForeignLoadJpeg, autorotate ),
116 		FALSE );
117 }
118 static void
119 <a name="1"></a>vips_foreign_load_jpeg_init( VipsForeignLoadJpeg *jpeg )
120 {
121 	jpeg-&gt;shrink = 1;
122 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
123 typedef struct _VipsForeignLoadJpegSource {
124 	VipsForeignLoadJpeg parent_object;
125 	VipsSource *source;
126 } VipsForeignLoadJpegSource;
127 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegSourceClass;
128 G_DEFINE_TYPE( VipsForeignLoadJpegSource, vips_foreign_load_jpeg_source, 
129 	vips_foreign_load_jpeg_get_type() );
130 static int
131 vips_foreign_load_jpeg_source_build( VipsObject *object )
132 {
133 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
134 	VipsForeignLoadJpegSource *source = 
135 		(VipsForeignLoadJpegSource *) object;
136 	if( source-&gt;source ) {
137 		jpeg-&gt;source = source-&gt;source;
138 		g_object_ref( jpeg-&gt;source );
139 	}
140 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_source_parent_class )-&gt;
141 		build( object ) )
142 		return( -1 );
143 	return( 0 );
144 }
145 <a name="2"></a>static gboolean
146 vips_foreign_load_jpeg_source_is_a_source( VipsSource *source )
147 {</b></font>
148 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( vips__isjpeg_source( source ) );
149 }
150 static void
151 vips_foreign_load_jpeg_source_class_init( 
152 	VipsForeignLoadJpegSourceClass *class )
153 {
154 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
155 	VipsObjectClass *object_class = (VipsObjectClass *) class;
156 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
157 	gobject_class-&gt;set_property = vips_object_set_property;
158 	gobject_class-&gt;get_property = vips_object_get_property;
159 	object_class-&gt;nickname = "jpegload_source";
160 	object_class-&gt;description = _( "load image from jpeg source" );
161 	object_class-&gt;build = vips_foreign_load_jpeg_source_build;
162 	load_class-&gt;is_a_source = vips_foreign_load_jpeg_source_is_a_source;</b></font>
163 	VIPS_ARG_OBJECT( class, "source", 1,
164 		_( "Source" ),
165 		_( "Source to load from" ),
166 		VIPS_ARGUMENT_REQUIRED_INPUT, 
167 		G_STRUCT_OFFSET( VipsForeignLoadJpegSource, source ),
168 		VIPS_TYPE_SOURCE );
169 }
170 <a name="5"></a>static void
171 vips_foreign_load_jpeg_source_init( VipsForeignLoadJpegSource *source )
172 {
173 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
174 typedef struct _VipsForeignLoadJpegFile {
175 	VipsForeignLoadJpeg parent_object;
176 	char *filename; 
177 } VipsForeignLoadJpegFile;
178 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegFileClass;
179 G_DEFINE_TYPE( VipsForeignLoadJpegFile, vips_foreign_load_jpeg_file, 
180 	vips_foreign_load_jpeg_get_type() );
181 static int
182 vips_foreign_load_jpeg_file_build( VipsObject *object )
183 {
184 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
185 	VipsForeignLoadJpegFile *file = (VipsForeignLoadJpegFile *) object;
186 	if( file-&gt;filename &amp;&amp;</b></font>
187 		!(jpeg-&gt;source = 
188 			vips_source_new_from_file( file-&gt;filename )) )
189 		return( -1 );
190 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_file_parent_class )-&gt;
191 		build( object ) )
192 		return( -1 );
193 	return( 0 );
194 }
195 static gboolean
196 vips_foreign_load_jpeg_file_is_a( const char *filename )
197 {
198 	VipsSource *source;
199 	gboolean result;
200 	if( !(source = vips_source_new_from_file( filename )) ) 
201 		return( FALSE );
202 	result = vips_foreign_load_jpeg_source_is_a_source( source );
203 <a name="6"></a>	VIPS_UNREF( source );
204 	return( result );
205 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
206 static void
207 vips_foreign_load_jpeg_file_class_init( VipsForeignLoadJpegFileClass *class )
208 {
209 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
210 	VipsObjectClass *object_class = (VipsObjectClass *) class;
211 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
212 <a name="0"></a>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
213 	gobject_class-&gt;set_property = vips_object_set_property;
214 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;get_property = vips_object_get_property;
215 	object_class-&gt;nickname = "jpegload";
216 	object_class-&gt;description = _( "load jpeg from file" );
217 	object_class-&gt;build = vips_foreign_load_jpeg_file_build;
218 	foreign_class-&gt;suffs = vips__jpeg_suffs;
219 	load_class-&gt;is_a = vips_foreign_load_jpeg_file_is_a;
220 	VIPS_ARG_STRING( class, "filename", 1, 
221 		_( "Filename" ),
222 		_( "Filename to load from" ),
223 		VIPS_ARGUMENT_REQUIRED_INPUT, 
224 		G_STRUCT_OFFSET( VipsForeignLoadJpegFile, filename ),
225 		NULL );
226 }
227 static void
228 vips_foreign_load_jpeg_file_init( VipsForeignLoadJpegFile *file )
229 {
230 }
231 typedef struct _VipsForeignLoadJpegBuffer {
232 	VipsForeignLoadJpeg parent_object;
233 	VipsBlob *blob;
234 } VipsForeignLoadJpegBuffer;
235 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegBufferClass;
236 G_DEFINE_TYPE( VipsForeignLoadJpegBuffer, vips_foreign_load_jpeg_buffer, 
237 	vips_foreign_load_jpeg_get_type() );
238 static int
239 vips_foreign_load_jpeg_buffer_build( VipsObject *object )
240 {
241 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
242 	VipsForeignLoadJpegBuffer *buffer = 
243 		(VipsForeignLoadJpegBuffer *) object;
244 	if( buffer-&gt;blob &amp;&amp;</b></font>
245 		!(jpeg-&gt;source = vips_source_new_from_memory( 
246 			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
247 			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
248 		return( -1 );
249 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_buffer_parent_class )-&gt;
250 		build( object ) )
251 		return( -1 );
252 	return( 0 );
253 }
254 static gboolean
255 vips_foreign_load_jpeg_buffer_is_a_buffer( const void *buf, size_t len )
256 {
257 	VipsSource *source;
258 	gboolean result;
259 	if( !(source = vips_source_new_from_memory( buf, len )) ) 
260 		return( FALSE );
261 <a name="3"></a>	result = vips_foreign_load_jpeg_source_is_a_source( source );
262 	VIPS_UNREF( source );
263 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( result );
264 }
265 static void
266 vips_foreign_load_jpeg_buffer_class_init( 
267 	VipsForeignLoadJpegBufferClass *class )
268 {
269 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
270 	VipsObjectClass *object_class = (VipsObjectClass *) class;
271 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
272 	gobject_class-&gt;set_property = vips_object_set_property;
273 	gobject_class-&gt;get_property = vips_object_get_property;
274 	object_class-&gt;nickname = "jpegload_buffer";
275 	object_class-&gt;description = _( "load jpeg from buffer" );
276 	object_class-&gt;build = vips_foreign_load_jpeg_buffer_build;</b></font>
277 	load_class-&gt;is_a_buffer = vips_foreign_load_jpeg_buffer_is_a_buffer;
278 	VIPS_ARG_BOXED( class, "buffer", 1, 
279 		_( "Buffer" ),
280 		_( "Buffer to load from" ),
281 		VIPS_ARGUMENT_REQUIRED_INPUT, 
282 		G_STRUCT_OFFSET( VipsForeignLoadJpegBuffer, blob ),
283 		VIPS_TYPE_BLOB );
284 }
285 static void
286 vips_foreign_load_jpeg_buffer_init( VipsForeignLoadJpegBuffer *buffer )
287 {
288 }
289 int
290 vips_jpegload( const char *filename, VipsImage **out, ... )
291 {
292 	va_list ap;
293 	int result;
294 	va_start( ap, out );
295 	result = vips_call_split( "jpegload", ap, filename, out );
296 	va_end( ap );
297 	return( result );
298 }
299 int
300 vips_jpegload_buffer( void *buf, size_t len, VipsImage **out, ... )
301 {
302 	va_list ap;
303 	VipsBlob *blob;
304 	int result;
305 	blob = vips_blob_new( NULL, buf, len );
306 	va_start( ap, out );
307 	result = vips_call_split( "jpegload_buffer", ap, blob, out );
308 	va_end( ap );
309 	vips_area_unref( VIPS_AREA( blob ) );
310 	return( result );
311 }
312 int
313 vips_jpegload_source( VipsSource *source, VipsImage **out, ... )
314 {
315 	va_list ap;
316 	int result;
317 	va_start( ap, out );
318 	result = vips_call_split( "jpegload_source", ap, source, out );
319 	va_end( ap );
320 	return( result );
321 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #if defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)
11 #include "pforeign.h"
12 const char *vips__heif_suffs[] = { 
13 	".heic",
14 	".heif",
15 	".avif",
16 	NULL 
17 };
18 #ifdef HAVE_HEIF_DECODER
19 #include &lt;libheif/heif.h&gt;
20 #define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
21 #define VIPS_FOREIGN_LOAD_HEIF( obj ) \
22 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
23 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
24 #define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
25 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
26 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
27 #define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
28 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
29 #define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
30 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
31 #define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
32 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
33 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))
34 typedef struct _VipsForeignLoadHeif {
35 	VipsForeignLoad parent_object;
36 	int page;
37 	int n;
38 	gboolean thumbnail;
39 	gboolean autorotate;
40 	struct heif_context *ctx;
41 	int n_top;
42 	gboolean has_alpha;
43 	int width;
44 	int height;
45 	int page_width;
46 	int page_height;
47 	int page_no;
48 	gboolean thumbnail_set;
49 	int primary_page;
50 	heif_item_id *id;
51 	struct heif_image_handle *handle;
52 	struct heif_image *img;
53 	int stride;
54 	const uint8_t *data;
55 	VipsSource *source;
56 	struct heif_reader *reader;
57 } VipsForeignLoadHeif;
58 void
59 vips__heif_error( struct heif_error *error )
60 {
61 	if( error-&gt;code ) 
62 		vips_error( "heif", "%s (%d.%d)", error-&gt;message, error-&gt;code,
63 			error-&gt;subcode );
64 }
65 typedef struct _VipsForeignLoadHeifClass {
66 	VipsForeignLoadClass parent_class;
67 } VipsForeignLoadHeifClass;
68 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
69 	VIPS_TYPE_FOREIGN_LOAD );
70 static void
71 vips_foreign_load_heif_dispose( GObject *gobject )
72 {
73 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
74 	heif-&gt;data = NULL;
75 	VIPS_FREEF( heif_image_release, heif-&gt;img );
76 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
77 	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
78 	VIPS_FREE( heif-&gt;id );
79 	VIPS_FREE( heif-&gt;reader );
80 	VIPS_UNREF( heif-&gt;source );
81 	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
82 		dispose( gobject );
83 }
84 static int
85 vips_foreign_load_heif_build( VipsObject *object )
86 {
87 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
88 #ifdef DEBUG
89 	printf( "vips_foreign_load_heif_build:\n" );
90 	if( heif-&gt;source &amp;&amp;
91 		vips_source_rewind( heif-&gt;source ) )
92 		return( -1 );
93 	if( !heif-&gt;ctx ) {
94 		struct heif_error error;
95 		heif-&gt;ctx = heif_context_alloc();
96 		error = heif_context_read_from_reader( heif-&gt;ctx, 
97 			heif-&gt;reader, heif, NULL );
98 		if( error.code ) {
99 			vips__heif_error( &amp;error );
100 			return( -1 );
101 		}
102 	}
103 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
104 		build( object ) )
105 		return( -1 );
106 	return( 0 );
107 }
108 static const char *heif_magic[] = {
109 	"ftypheic",		"ftypheix",		"ftyphevc",		"ftypheim",		"ftypheis",		"ftyphevm",		"ftyphevs",		"ftypmif1",		"ftypmsf1",		"ftypavif"	};
110 static int
111 vips_foreign_load_heif_is_a( const char *buf, int len )
112 {
113 	if( len &gt;= 12 ) {
114 		const guint32 chunk_len = 
115 			(guint32) buf[0] &lt;&lt; 24 |
116 			(guint32) buf[1] &lt;&lt; 16 |
117 			(guint32) buf[2] &lt;&lt; 8 |
118 			(guint32) buf[3];
119 		int i;
120 		if( chunk_len &gt; 64 || 
121 			chunk_len % 4 != 0 )
122 			return( 0 );
123 		for( i = 0; i &lt; VIPS_NUMBER( heif_magic ); i++ )
124 			if( strncmp( buf + 4, heif_magic[i], 8 ) == 0 )
125 				return( 1 );
126 	}
127 	return( 0 );
128 }
129 static VipsForeignFlags
130 vips_foreign_load_heif_get_flags( VipsForeignLoad *load )
131 {
132 	return( VIPS_FOREIGN_SEQUENTIAL );
133 }
134 static int
135 vips_foreign_load_heif_set_thumbnail( VipsForeignLoadHeif *heif )
136 {
137 	heif_item_id thumb_ids[1];
138 	int n_thumbs;
139 	struct heif_image_handle *thumb_handle;
140 	struct heif_image *thumb_img;
141 	struct heif_error error;
142 	double main_aspect;
143 	double thumb_aspect;
144 #ifdef DEBUG
145 	printf( "vips_foreign_load_heif_set_thumbnail:\n" );
146 	n_thumbs = heif_image_handle_get_list_of_thumbnail_IDs( 
147 		heif-&gt;handle, thumb_ids, 1 );
148 	if( n_thumbs == 0 )
149 		return( 0 );
150 	error = heif_image_handle_get_thumbnail( heif-&gt;handle,
151 		thumb_ids[0], &amp;thumb_handle );
152 	if( error.code ) {
153 		vips__heif_error( &amp;error );
154 		return( -1 );
155 	}
156 	error = heif_decode_image( thumb_handle, &amp;thumb_img,
157 		heif_colorspace_RGB, 
158 		heif_chroma_interleaved_RGB,
159 		NULL );
160 	if( error.code ) {
161 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
162 		vips__heif_error( &amp;error );
163 		return( -1 );
164 	}
165 	thumb_aspect = (double) 
166 		heif_image_get_width( thumb_img, heif_channel_interleaved ) /
167 		heif_image_get_height( thumb_img, heif_channel_interleaved );
168 	VIPS_FREEF( heif_image_release, thumb_img );
169 	main_aspect = (double) 
170 		heif_image_handle_get_width( heif-&gt;handle ) /
171 		heif_image_handle_get_height( heif-&gt;handle );
172 	if( fabs( main_aspect - thumb_aspect ) &gt; 0.1 ) {
173 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
174 		return( 0 );
175 	}
176 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
177 	heif-&gt;handle = thumb_handle;
178 	return( 0 );
179 }
180 static int
181 vips_foreign_load_heif_set_page( VipsForeignLoadHeif *heif, 
182 	int page_no, gboolean thumbnail )
183 {
184 	if( !heif-&gt;handle ||
185 		page_no != heif-&gt;page_no ||
186 		thumbnail != heif-&gt;thumbnail_set ) {
187 		struct heif_error error;
188 #ifdef DEBUG
189 		printf( "vips_foreign_load_heif_set_page: %d, thumbnail = %d\n",
190 			page_no, thumbnail );
191 		VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
192 		VIPS_FREEF( heif_image_release, heif-&gt;img );
193 		heif-&gt;data = NULL;
194 		heif-&gt;thumbnail_set = FALSE;
195 		error = heif_context_get_image_handle( heif-&gt;ctx, 
196 			heif-&gt;id[page_no], &amp;heif-&gt;handle );
197 		if( error.code ) {
198 			vips__heif_error( &amp;error );
199 			return( -1 );
200 		}
201 		if( thumbnail ) {
202 			if( vips_foreign_load_heif_set_thumbnail( heif ) )
203 				return( -1 );
204 			heif-&gt;thumbnail_set = TRUE;
205 		}
206 		heif-&gt;page_no = page_no;
207 	}
208 	return( 0 );
209 }
210 static int
211 vips_foreign_load_heif_set_header( VipsForeignLoadHeif *heif, VipsImage *out )
212 {
213 	VipsForeignLoad *load = (VipsForeignLoad *) heif;
214 	int bands;
215 	int i;
216 	heif_item_id id[16];
217 	int n_metadata;
218 	struct heif_error error;
219 	VipsForeignHeifCompression compression;
220 	if( vips_foreign_load_heif_set_page( heif, heif-&gt;page, FALSE ) )
221 		return( -1 );
222 	if ( heif-&gt;page_width &lt; 1 || heif-&gt;page_height &lt; 1 ) {
223 		vips_error( "heifload", "%s", _( "bad dimensions" ) );
224 		return( -1 );
225 	}
226 	heif-&gt;has_alpha = heif_image_handle_has_alpha_channel( heif-&gt;handle );
227 #ifdef DEBUG
228 	printf( "heif_image_handle_has_alpha_channel() = %d\n", 
229 		heif-&gt;has_alpha );
230 	bands = heif-&gt;has_alpha ? 4 : 3;
231 	n_metadata = heif_image_handle_get_list_of_metadata_block_IDs( 
232 		heif-&gt;handle, NULL, id, VIPS_NUMBER( id ) );
233 	for( i = 0; i &lt; n_metadata; i++ ) {
234 		size_t length = heif_image_handle_get_metadata_size( 
235 			heif-&gt;handle, id[i] );
236 		const char *type = heif_image_handle_get_metadata_type( 
237 			heif-&gt;handle, id[i] );
238 		unsigned char *data;
239 		char name[256];
240 #ifdef DEBUG
241 		printf( "metadata type = %s, length = %zu\n", type, length ); 
242 		if( !length )
243 			continue;
244 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
245 			return( -1 );
246 		error = heif_image_handle_get_metadata( 
247 			heif-&gt;handle, id[i], data );
248 		if( error.code ) {
249 			vips__heif_error( &amp;error );
250 			return( -1 );
251 		}
252 		if( length &gt; 4 &amp;&amp;
253 			g_ascii_strcasecmp( type, "exif" ) == 0 ) {
254 			data += 4;
255 			length -= 4;
256 		}
257 		if( g_ascii_strcasecmp( type, "exif" ) == 0 )
258 			vips_snprintf( name, 256, VIPS_META_EXIF_NAME );
259 		else if( g_ascii_strcasecmp( type, "mime" ) == 0 &amp;&amp;
260 			length &gt; 10 &amp;&amp;
261 			vips_isprefix( "&lt;x:xmpmeta", (const char *) data ) ) 
262 			vips_snprintf( name, 256, VIPS_META_XMP_NAME );
263 		else
264 			vips_snprintf( name, 256, "heif-%s-%d", type, i );
265 		vips_image_set_blob( out, name, 
266 			(VipsCallbackFn) NULL, data, length );
267 	}
268 	vips_autorot_remove_angle( out );
269 #ifdef HAVE_HEIF_COLOR_PROFILE
270 	enum heif_color_profile_type profile_type = 
271 		heif_image_handle_get_color_profile_type( heif-&gt;handle );
272 #ifdef DEBUG
273 {
274 	printf( "profile type = " ); 
275 	switch( profile_type ) {
276 	case heif_color_profile_type_not_present: 
277 		printf( "none" ); 
278 		break;
279 	case heif_color_profile_type_nclx: 
280 		printf( "nclx" ); 
281 		break;
282 	case heif_color_profile_type_rICC: 
283 		printf( "rICC" ); 
284 		break;
285 	case heif_color_profile_type_prof: 
286 		printf( "prof" ); 
287 		break;
288 	default:
289 		printf( "unknown" ); 
290 		break;
291 	}
292 	printf( "\n" ); 
293 }
294 	if( profile_type == heif_color_profile_type_prof ||
295 		profile_type == heif_color_profile_type_rICC ) {
296 		size_t length = heif_image_handle_get_raw_color_profile_size( 
297 			heif-&gt;handle );
298 		unsigned char *data;
299 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
300 			return( -1 );
301 		error = heif_image_handle_get_raw_color_profile( 
302 			heif-&gt;handle, data );
303 		if( error.code ) {
304 			vips__heif_error( &amp;error );
305 			return( -1 );
306 		}
307 #ifdef DEBUG
308 		printf( "profile data, length = %zd\n", length ); 
309 		vips_image_set_blob( out, VIPS_META_ICC_NAME, 
310 			(VipsCallbackFn) NULL, data, length );
311 	}
312 	else if( profile_type == heif_color_profile_type_nclx ) {
313 		g_warning( "heifload: ignoring nclx profile" );
314 	}
315 	vips_image_set_int( out, "heif-primary", heif-&gt;primary_page );
316 	vips_image_set_int( out, "n-pages", heif-&gt;n_top );
317 	if( vips_object_argument_isset( VIPS_OBJECT( heif ), "n" ) )
318 		vips_image_set_int( out, 
319 			VIPS_META_PAGE_HEIGHT, heif-&gt;page_height );
320 	compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;
321 #ifdef HAVE_HEIF_AVIF
322 {
323 	const unsigned char *brand_data;
324 	if( (brand_data = vips_source_sniff( heif-&gt;source, 12 )) ) {
325 		enum heif_brand brand;
326 		brand = heif_main_brand( brand_data, 12 );
327 		if( brand == heif_avif || 
328 			brand == heif_avis )
329 			compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
330 	}
331 }
332 	vips_image_set_string( out, "heif-compression",
333 		vips_enum_nick( VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
334 			compression ) );
335 	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
336 		return( -1 );
337 	vips_image_init_fields( out,
338 		heif-&gt;page_width, heif-&gt;page_height * heif-&gt;n, bands, 
339 		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 
340 		1.0, 1.0 );
341 	VIPS_SETSTR( load-&gt;out-&gt;filename, 
342 		vips_connection_filename( VIPS_CONNECTION( heif-&gt;source ) ) );
343 	return( 0 );
344 }
345 static int
346 vips_foreign_load_heif_header( VipsForeignLoad *load )
347 {
348 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
349 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
350 	struct heif_error error;
351 	heif_item_id primary_id;
352 	int i;
353 #ifdef DEBUG
354 	printf( "vips_foreign_load_heif_header:\n" );
355 	heif-&gt;n_top = heif_context_get_number_of_top_level_images( heif-&gt;ctx );
356 	heif-&gt;id = VIPS_ARRAY( NULL, heif-&gt;n_top, heif_item_id );
357 	heif_context_get_list_of_top_level_image_IDs( heif-&gt;ctx, 
358 		heif-&gt;id, heif-&gt;n_top );
359 	error = heif_context_get_primary_image_ID( heif-&gt;ctx, &amp;primary_id );
360 	if( error.code ) {
361 		vips__heif_error( &amp;error );
362 		return( -1 );
363 	}
364 	for( i = 0; i &lt; heif-&gt;n_top; i++ )
365 		if( heif-&gt;id[i] == primary_id )
366 			heif-&gt;primary_page = i;
367 	if( !vips_object_argument_isset( VIPS_OBJECT( load ), "page" ) &amp;&amp;
368 		!vips_object_argument_isset( VIPS_OBJECT( load ), "n" ) )
369 		heif-&gt;page = heif-&gt;primary_page;
370 	if( heif-&gt;n == -1 )
371 		heif-&gt;n = heif-&gt;n_top - heif-&gt;page;
372 	if( heif-&gt;page &lt; 0 ||
373 		heif-&gt;n &lt;= 0 ||
374 		heif-&gt;page + heif-&gt;n &gt; heif-&gt;n_top ) {
375 		vips_error( class-&gt;nickname, "%s", _( "bad page number" ) ); 
376 		return( -1 ); 
377 	}
378 #ifdef DEBUG
379 	for( i = heif-&gt;page; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
380 		heif_item_id thumb_ids[1];
381 		int n_items;
382 		int n_thumbs;
383 		int j;
384 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
385 			return( -1 );
386 		n_thumbs = heif_image_handle_get_number_of_thumbnails( 
387 			heif-&gt;handle );
388 		n_items = heif_image_handle_get_list_of_thumbnail_IDs( 
389 			heif-&gt;handle, thumb_ids, 1 );
390 		printf( "page = %d\n", i );
391 		printf( "n_thumbs = %d\n", n_thumbs );
392 		printf( "n_items = %d\n", n_items );
393 		for( j = 0; j &lt; n_items; j++ ) {
394 			struct heif_image_handle *thumb_handle;
395 			error = heif_image_handle_get_thumbnail( heif-&gt;handle,
396 				thumb_ids[j], &amp;thumb_handle );
397 			if( error.code ) {
398 				vips__heif_error( &amp;error );
399 				return( -1 );
400 			}
401 			printf( "  thumb %d\n", j );
402 			printf( "    width = %d\n", 
403 				heif_image_handle_get_width( thumb_handle ) );
404 			printf( "    height = %d\n", 
405 				heif_image_handle_get_height( thumb_handle ) );
406 		}
407 	}
408 	if( vips_foreign_load_heif_set_page( heif, 
409 		heif-&gt;page, heif-&gt;thumbnail ) )
410 		return( -1 );
411 	heif-&gt;page_width = heif_image_handle_get_width( heif-&gt;handle );
412 	heif-&gt;page_height = heif_image_handle_get_height( heif-&gt;handle );
413 	for( i = heif-&gt;page + 1; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
414 		if( vips_foreign_load_heif_set_page( heif, 
415 			i, heif-&gt;thumbnail ) )
416 			return( -1 );
417 		if( heif_image_handle_get_width( heif-&gt;handle ) 
418 				!= heif-&gt;page_width ||
419 			heif_image_handle_get_height( heif-&gt;handle ) 
420 				!= heif-&gt;page_height ) {
421 			vips_error( class-&gt;nickname, "%s", 
422 				_( "not all pages are the same size" ) ); 
423 			return( -1 ); 
424 		}
425 	}
426 #ifdef DEBUG
427 	printf( "page_width = %d\n", heif-&gt;page_width );
428 	printf( "page_height = %d\n", heif-&gt;page_height );
429 	printf( "n_top = %d\n", heif-&gt;n_top );
430 	for( i = 0; i &lt; heif-&gt;n_top; i++ ) {
431 		printf( "  id[%d] = %d\n", i, heif-&gt;id[i] );
432 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
433 			return( -1 );
434 		printf( "    width = %d\n", 
435 			heif_image_handle_get_width( heif-&gt;handle ) );
436 		printf( "    height = %d\n", 
437 			heif_image_handle_get_height( heif-&gt;handle ) );
438 		printf( "    has_depth = %d\n", 
439 			heif_image_handle_has_depth_image( heif-&gt;handle ) );
440 		printf( "    has_alpha = %d\n", 
441 			heif_image_handle_has_alpha_channel( heif-&gt;handle ) );
442 		printf( "    n_metadata = %d\n", 
443 			heif_image_handle_get_number_of_metadata_blocks( 
444 				heif-&gt;handle, NULL ) );
445 #ifdef HAVE_HEIF_COLOR_PROFILE
446 		printf( "    colour profile type = 0x%xd\n", 
447 			heif_image_handle_get_color_profile_type( 
448 				heif-&gt;handle ) );
449 	}
450 	if( vips_foreign_load_heif_set_header( heif, load-&gt;out ) )
451 		return( -1 );
452 	vips_source_minimise( heif-&gt;source );
453 	return( 0 );
454 }
455 #ifdef DEBUG
456 void
457 vips__heif_image_print( struct heif_image *img )
458 {
459 	const static enum heif_channel channel[] = {
460 		heif_channel_Y,
461 		heif_channel_Cb,
462 		heif_channel_Cr,
463 		heif_channel_R,
464 		heif_channel_G,
465 		heif_channel_B,
466 		heif_channel_Alpha,
467 		heif_channel_interleaved
468 	};
469 	const static char *channel_name[] = {
470 		"heif_channel_Y",
471 		"heif_channel_Cb",
472 		"heif_channel_Cr",
473 		"heif_channel_R",
474 		"heif_channel_G",
475 		"heif_channel_B",
476 		"heif_channel_Alpha",
477 		"heif_channel_interleaved"
478 	};
479 	int i;
480 	printf( "vips__heif_image_print:\n" );
481 	for( i = 0; i &lt; VIPS_NUMBER( channel ); i++ ) {
482 		if( !heif_image_has_channel( img, channel[i] ) )
483 			continue;
484 		printf( "\t%s:\n", channel_name[i] ); 
485 		printf( "\t\twidth = %d\n", 
486 			heif_image_get_width( img, channel[i] ) );
487 		printf( "\t\theight = %d\n", 
488 			heif_image_get_height( img, channel[i] ) );
489 		printf( "\t\tbits = %d\n", 
490 			heif_image_get_bits_per_pixel( img, channel[i] ) );
491 	}
492 }
493 static int
494 vips_foreign_load_heif_generate( VipsRegion *or, 
495 	void *seq, void *a, void *b, gboolean *stop )
496 {
497 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
498 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
499         VipsRect *r = &amp;or-&gt;valid;
500 	int page = r-&gt;top / heif-&gt;page_height + heif-&gt;page;
501 	int line = r-&gt;top % heif-&gt;page_height;
502 #ifdef DEBUG_VERBOSE
503 	printf( "vips_foreign_load_heif_generate: line %d\n", r-&gt;top );
504 	g_assert( r-&gt;height == 1 );
505 	if( vips_foreign_load_heif_set_page( heif, page, heif-&gt;thumbnail ) )
506 		return( -1 );
507 	if( !heif-&gt;img ) {
508 		struct heif_error error;
509 		struct heif_decoding_options *options;
510 		enum heif_chroma chroma = heif-&gt;has_alpha ? 
511 			heif_chroma_interleaved_RGBA :
512 			heif_chroma_interleaved_RGB;
513 		options = heif_decoding_options_alloc();
514 #ifdef HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT
515 		options-&gt;convert_hdr_to_8bit = TRUE;
516 		error = heif_decode_image( heif-&gt;handle, &amp;heif-&gt;img, 
517 			heif_colorspace_RGB, chroma, 
518 			options );
519 		heif_decoding_options_free( options );
520 		if( error.code ) {
521 			vips__heif_error( &amp;error );
522 			return( -1 );
523 		}
524 #ifdef DEBUG
525 		vips__heif_image_print( heif-&gt;img );
526 	}
527 	if( !heif-&gt;data ) {
528 		int image_width = heif_image_get_width( heif-&gt;img, 
529 			heif_channel_interleaved );
530 		int image_height = heif_image_get_height( heif-&gt;img, 
531 			heif_channel_interleaved );
532 		if( image_width != heif-&gt;page_width ||
533 			image_height != heif-&gt;page_height ) {
534 			vips_error( class-&gt;nickname, 
535 				"%s", _( "bad image dimensions on decode" ) );
536 			return( -1 );
537 		}
538 		if( !(heif-&gt;data = heif_image_get_plane_readonly( heif-&gt;img, 
539 			heif_channel_interleaved, &amp;heif-&gt;stride )) ) {
540 			vips_error( class-&gt;nickname, 
541 				"%s", _( "unable to get image data" ) );
542 			return( -1 );
543 		}
544 	}
545 	memcpy( VIPS_REGION_ADDR( or, 0, r-&gt;top ),
546 		heif-&gt;data + heif-&gt;stride * line, 
547 		VIPS_IMAGE_SIZEOF_LINE( or-&gt;im ) );
548 	return( 0 );
549 }
550 static void
551 vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
552 {
553 	vips_source_minimise( heif-&gt;source );
554 }
555 static int
556 vips_foreign_load_heif_load( VipsForeignLoad *load )
557 {
558 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
559 	VipsImage **t = (VipsImage **) 
560 		vips_object_local_array( VIPS_OBJECT( load ), 3 );
561 #ifdef DEBUG
562 	printf( "vips_foreign_load_heif_load: loading image\n" );
563 	t[0] = vips_image_new();
564 	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
565 		return( -1 );
566 	g_signal_connect( t[0], "minimise", 
567 		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
568 	if( vips_image_generate( t[0],
569 		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
570 		vips_sequential( t[0], &amp;t[1], NULL ) ||
571 		vips_image_write( t[1], load-&gt;real ) )
572 		return( -1 );
573 <a name="2"></a>	if( vips_source_decode( heif-&gt;source ) )
574 		return( -1 );
575 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
576 }
577 static void
578 vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
579 {
580 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
581 	VipsObjectClass *object_class = (VipsObjectClass *) class;
582 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
583 	gobject_class-&gt;dispose = vips_foreign_load_heif_dispose;
584 	gobject_class-&gt;set_property = vips_object_set_property;
585 	gobject_class-&gt;get_property = vips_object_get_property;
586 	object_class-&gt;nickname = "heifload_base";
587 	object_class-&gt;description = _( "load a HEIF image" );
588 	object_class-&gt;build = vips_foreign_load_heif_build;</b></font>
589 	load_class-&gt;get_flags = vips_foreign_load_heif_get_flags;
590 	load_class-&gt;header = vips_foreign_load_heif_header;
591 	load_class-&gt;load = vips_foreign_load_heif_load;
592 	VIPS_ARG_INT( class, "page", 2,
593 		_( "Page" ),
594 		_( "Load this page from the file" ),
595 		VIPS_ARGUMENT_OPTIONAL_INPUT,
596 		G_STRUCT_OFFSET( VipsForeignLoadHeif, page ),
597 		0, 100000, 0 );
598 	VIPS_ARG_INT( class, "n", 3,
599 		_( "n" ),
600 		_( "Load this many pages" ),
601 		VIPS_ARGUMENT_OPTIONAL_INPUT,
602 		G_STRUCT_OFFSET( VipsForeignLoadHeif, n ),
603 		-1, 100000, 1 );
604 	VIPS_ARG_BOOL( class, "thumbnail", 4, 
605 		_( "Thumbnail" ), 
606 		_( "Fetch thumbnail image" ),
607 		VIPS_ARGUMENT_OPTIONAL_INPUT,
608 		G_STRUCT_OFFSET( VipsForeignLoadHeif, thumbnail ),
609 		FALSE );
610 	VIPS_ARG_BOOL( class, "autorotate", 21, 
611 		_( "Autorotate" ), 
612 		_( "Rotate image using exif orientation" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
614 		G_STRUCT_OFFSET( VipsForeignLoadHeif, autorotate ),
615 		FALSE );
616 }
617 static gint64
618 vips_foreign_load_heif_get_position( void *userdata )
619 {
620 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
621 	return( vips_source_seek( heif-&gt;source, 0L, SEEK_CUR ) );
622 }
623 static int
624 vips_foreign_load_heif_read( void *data, size_t size, void *userdata )
625 {
626 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
627 	while( size &gt; 0 ) {
628 		gint64 bytes_read;
629 		bytes_read = vips_source_read( heif-&gt;source, data, size );
630 		if( bytes_read &lt;= 0 ) 
631 			return( -1 );
632 		size -= bytes_read;
633 		data += bytes_read;
634 	}
635 	return( 0 );
636 }
637 static int
638 vips_foreign_load_heif_seek( gint64 position, void *userdata )
639 {
640 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
641 	return( vips_source_seek( heif-&gt;source, position, SEEK_SET ) == -1 );
642 }
643 static enum heif_reader_grow_status 
644 vips_foreign_load_heif_wait_for_file_size( gint64 target_size, void *userdata )
645 {
646 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
647 	gint64 old_position;
648 	gint64 result;
649 	enum heif_reader_grow_status status;
650 	old_position = vips_source_seek( heif-&gt;source, 0L, SEEK_CUR );
651 	result = vips_source_seek( heif-&gt;source, target_size, SEEK_SET );
652 	vips_source_seek( heif-&gt;source, old_position, SEEK_SET );
653 	if( result &lt; 0 )
654 		status = heif_reader_grow_status_size_beyond_eof;
655 	else
656 		status = heif_reader_grow_status_size_reached;
657 	return( status );
658 }
659 static void
660 vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
661 {
662 	heif-&gt;n = 1;
663 	heif-&gt;reader = VIPS_ARRAY( NULL, 1, struct heif_reader );
664 	heif-&gt;reader-&gt;reader_api_version = 1;
665 	heif-&gt;reader-&gt;get_position = vips_foreign_load_heif_get_position;
666 	heif-&gt;reader-&gt;read = vips_foreign_load_heif_read;
667 <a name="5"></a>	heif-&gt;reader-&gt;seek = vips_foreign_load_heif_seek;
668 	heif-&gt;reader-&gt;wait_for_file_size = 
669 		vips_foreign_load_heif_wait_for_file_size;
670 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
671 typedef struct _VipsForeignLoadHeifFile {
672 	VipsForeignLoadHeif parent_object;
673 	char *filename; 
674 } VipsForeignLoadHeifFile;
675 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifFileClass;
676 G_DEFINE_TYPE( VipsForeignLoadHeifFile, vips_foreign_load_heif_file, 
677 	vips_foreign_load_heif_get_type() );
678 static int
679 vips_foreign_load_heif_file_build( VipsObject *object )
680 {
681 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
682 	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) object;
683 	if( file-&gt;filename ) </b></font>
684 		if( !(heif-&gt;source = 
685 			vips_source_new_from_file( file-&gt;filename )) )
686 			return( -1 );
687 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
688 		build( object ) )
689 		return( -1 );
690 	return( 0 );
691 }
692 static int
693 vips_foreign_load_heif_file_is_a( const char *filename )
694 {
695 <a name="4"></a>	char buf[12];
696 	if( vips__get_bytes( filename, (unsigned char *) buf, 12 ) != 12 )
697 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( 0 );
698 	return( vips_foreign_load_heif_is_a( buf, 12 ) );
699 }
700 static void
701 vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
702 {
703 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
704 	VipsObjectClass *object_class = (VipsObjectClass *) class;
705 <a name="0"></a>	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
706 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
707 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;set_property = vips_object_set_property;
708 	gobject_class-&gt;get_property = vips_object_get_property;
709 	object_class-&gt;nickname = "heifload";
710 	object_class-&gt;build = vips_foreign_load_heif_file_build;
711 	foreign_class-&gt;suffs = vips__heif_suffs;
712 	load_class-&gt;is_a = vips_foreign_load_heif_file_is_a;
713 	VIPS_ARG_STRING( class, "filename", 1, 
714 		_( "Filename" ),
715 		_( "Filename to load from" ),
716 		VIPS_ARGUMENT_REQUIRED_INPUT, 
717 		G_STRUCT_OFFSET( VipsForeignLoadHeifFile, filename ),
718 		NULL );
719 }
720 static void
721 vips_foreign_load_heif_file_init( VipsForeignLoadHeifFile *file )
722 {
723 }
724 typedef struct _VipsForeignLoadHeifBuffer {
725 	VipsForeignLoadHeif parent_object;
726 	VipsArea *buf;
727 } VipsForeignLoadHeifBuffer;
728 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifBufferClass;
729 G_DEFINE_TYPE( VipsForeignLoadHeifBuffer, vips_foreign_load_heif_buffer, 
730 	vips_foreign_load_heif_get_type() );
731 static int
732 vips_foreign_load_heif_buffer_build( VipsObject *object )
733 {
734 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
735 	VipsForeignLoadHeifBuffer *buffer = 
736 		(VipsForeignLoadHeifBuffer *) object;
737 	if( buffer-&gt;buf )</b></font>
738 		if( !(heif-&gt;source = vips_source_new_from_memory( 
739 			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
740 			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
741 			return( -1 );
742 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
743 		build( object ) )
744 		return( -1 );
745 	return( 0 );
746 }
747 <a name="3"></a>static gboolean
748 vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
749 {
750 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( vips_foreign_load_heif_is_a( buf, len ) );
751 }
752 static void
753 vips_foreign_load_heif_buffer_class_init( 
754 	VipsForeignLoadHeifBufferClass *class )
755 {
756 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
757 	VipsObjectClass *object_class = (VipsObjectClass *) class;
758 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
759 	gobject_class-&gt;set_property = vips_object_set_property;
760 	gobject_class-&gt;get_property = vips_object_get_property;
761 	object_class-&gt;nickname = "heifload_buffer";
762 	object_class-&gt;build = vips_foreign_load_heif_buffer_build;
763 	load_class-&gt;is_a_buffer = vips_foreign_load_heif_buffer_is_a;</b></font>
764 	VIPS_ARG_BOXED( class, "buffer", 1, 
765 		_( "Buffer" ),
766 		_( "Buffer to load from" ),
767 		VIPS_ARGUMENT_REQUIRED_INPUT, 
768 		G_STRUCT_OFFSET( VipsForeignLoadHeifBuffer, buf ),
769 		VIPS_TYPE_BLOB );
770 }
771 <a name="1"></a>static void
772 vips_foreign_load_heif_buffer_init( VipsForeignLoadHeifBuffer *buffer )
773 {
774 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
775 typedef struct _VipsForeignLoadHeifSource {
776 	VipsForeignLoadHeif parent_object;
777 	VipsSource *source;
778 } VipsForeignLoadHeifSource;
779 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifSourceClass;
780 G_DEFINE_TYPE( VipsForeignLoadHeifSource, vips_foreign_load_heif_source, 
781 	vips_foreign_load_heif_get_type() );
782 static int
783 vips_foreign_load_heif_source_build( VipsObject *object )
784 {
785 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
786 	VipsForeignLoadHeifSource *source = 
787 		(VipsForeignLoadHeifSource *) object;
788 	if( source-&gt;source ) {
789 		heif-&gt;source = source-&gt;source;
790 		g_object_ref( heif-&gt;source );
791 	}
792 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_source_parent_class )-&gt;
793 		build( object ) )
794 		return( -1 );
795 	return( 0 );
796 }
797 static gboolean
798 vips_foreign_load_heif_source_is_a_source( VipsSource *source )
799 {</b></font>
800 	const char *p;
801 <a name="6"></a>
802 	return( (p = (const char *) vips_source_sniff( source, 12 )) &amp;&amp;
803 		vips_foreign_load_heif_is_a( p, 12 ) );
804 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
805 static void
806 vips_foreign_load_heif_source_class_init( 
807 	VipsForeignLoadHeifSourceClass *class )
808 {
809 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
810 	VipsObjectClass *object_class = (VipsObjectClass *) class;
811 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
812 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
813 	gobject_class-&gt;get_property = vips_object_get_property;
814 	object_class-&gt;nickname = "heifload_source";
815 	object_class-&gt;build = vips_foreign_load_heif_source_build;
816 	load_class-&gt;is_a_source = vips_foreign_load_heif_source_is_a_source;
817 	VIPS_ARG_OBJECT( class, "source", 1,
818 		_( "Source" ),
819 		_( "Source to load from" ),
820 		VIPS_ARGUMENT_REQUIRED_INPUT, 
821 		G_STRUCT_OFFSET( VipsForeignLoadHeifSource, source ),
822 		VIPS_TYPE_SOURCE );
823 }
824 static void
825 vips_foreign_load_heif_source_init( VipsForeignLoadHeifSource *source )
826 {
827 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
