<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for jpegload.c &amp; heifload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for jpegload.c &amp; heifload.c
      </h3>
<h1 align="center">
        25.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>jpegload.c (47.430832%)<th>heifload.c (17.857143%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(328-370)<td><a href="#" name="0">(1134-1179)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(205-240)<td><a href="#" name="1">(1226-1263)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(241-259)<td><a href="#" name="2">(941-957)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(394-410)<td><a href="#" name="3">(1195-1212)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(154-165)<td><a href="#" name="4">(1121-1132)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(273-293)<td><a href="#" name="5">(1081-1103)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(317-325)<td><a href="#" name="6">(1268-1278)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>jpegload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/buf.h&gt;
#include &lt;vips/internal.h&gt;
#include "pforeign.h"
#ifdef HAVE_JPEG
#ifdef HAVE_EXIF
#ifdef UNTAGGED_EXIF
#include &lt;exif-data.h&gt;
#include &lt;exif-loader.h&gt;
#include &lt;exif-ifd.h&gt;
#include &lt;exif-utils.h&gt;
#include &lt;libexif/exif-data.h&gt;
#include &lt;libexif/exif-loader.h&gt;
#include &lt;libexif/exif-ifd.h&gt;
#include &lt;libexif/exif-utils.h&gt;
typedef struct _VipsForeignLoadJpeg {
	VipsForeignLoad parent_object;
	VipsSource *source;
	int shrink;
	gboolean autorotate;
} VipsForeignLoadJpeg;
typedef VipsForeignLoadClass VipsForeignLoadJpegClass;
G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadJpeg, vips_foreign_load_jpeg, 
	VIPS_TYPE_FOREIGN_LOAD );
static void
vips_foreign_load_jpeg_dispose( GObject *gobject )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) gobject;
	VIPS_UNREF( jpeg-&gt;source );
	G_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
		dispose( gobject );
}
static int
vips_foreign_load_jpeg_build( VipsObject *object )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
	if( jpeg-&gt;shrink != 1 &amp;&amp; 
		jpeg-&gt;shrink != 2 &amp;&amp; 
		jpeg-&gt;shrink != 4 &amp;&amp; 
		jpeg-&gt;shrink != 8 ) {
		vips_error( "VipsFormatLoadJpeg", 
			_( "bad shrink factor %d" ), jpeg-&gt;shrink );
		return( -1 );
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static VipsForeignFlags
vips_foreign_load_jpeg_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_SEQUENTIAL );
}
static VipsForeignFlags
vips_foreign_load_jpeg_get_flags_filename( const char *filename )
{
	return( VIPS_FOREIGN_SEQUENTIAL );
}
static int
vips_foreign_load_jpeg_header( VipsForeignLoad *load )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
	if( vips__jpeg_read_source( jpeg-&gt;source, 
		load-&gt;out, TRUE, jpeg-&gt;shrink, load-&gt;fail, jpeg-&gt;autorotate ) )
		return( -1 );
	return( 0 );
}
static int
vips_foreign_load_jpeg_load( VipsForeignLoad *load )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
<a name="4"></a>	if( vips__jpeg_read_source( jpeg-&gt;source,
		load-&gt;real, FALSE, jpeg-&gt;shrink, load-&gt;fail, 
		jpeg-&gt;autorotate ) )
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
	return( 0 );
}
static void
vips_foreign_load_jpeg_class_init( VipsForeignLoadJpegClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
	gobject_class-&gt;dispose = vips_foreign_load_jpeg_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "jpegload_base";
	object_class-&gt;description = _( "load jpeg" );
	object_class-&gt;build = vips_foreign_load_jpeg_build;
	foreign_class-&gt;priority = 50;
	load_class-&gt;get_flags_filename = 
		vips_foreign_load_jpeg_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_jpeg_get_flags;
	load_class-&gt;header = vips_foreign_load_jpeg_header;
	load_class-&gt;load = vips_foreign_load_jpeg_load;
	VIPS_ARG_INT( class, "shrink", 20, 
		_( "Shrink" ), 
		_( "Shrink factor on load" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadJpeg, shrink ),
		1, 16, 1 );
	VIPS_ARG_BOOL( class, "autorotate", 21, 
		_( "Autorotate" ), 
		_( "Rotate image using exif orientation" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadJpeg, autorotate ),
		FALSE );
}
static void
<a name="1"></a>vips_foreign_load_jpeg_init( VipsForeignLoadJpeg *jpeg )
{
	jpeg-&gt;shrink = 1;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
typedef struct _VipsForeignLoadJpegSource {
	VipsForeignLoadJpeg parent_object;
	VipsSource *source;
} VipsForeignLoadJpegSource;
typedef VipsForeignLoadJpegClass VipsForeignLoadJpegSourceClass;
G_DEFINE_TYPE( VipsForeignLoadJpegSource, vips_foreign_load_jpeg_source, 
	vips_foreign_load_jpeg_get_type() );
static int
vips_foreign_load_jpeg_source_build( VipsObject *object )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
	VipsForeignLoadJpegSource *source = 
		(VipsForeignLoadJpegSource *) object;
	if( source-&gt;source ) {
		jpeg-&gt;source = source-&gt;source;
		g_object_ref( jpeg-&gt;source );
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_source_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
<a name="2"></a>static gboolean
vips_foreign_load_jpeg_source_is_a_source( VipsSource *source )
{</b></font>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( vips__isjpeg_source( source ) );
}
static void
vips_foreign_load_jpeg_source_class_init( 
	VipsForeignLoadJpegSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "jpegload_source";
	object_class-&gt;description = _( "load image from jpeg source" );
	object_class-&gt;build = vips_foreign_load_jpeg_source_build;
	load_class-&gt;is_a_source = vips_foreign_load_jpeg_source_is_a_source;</b></font>
	VIPS_ARG_OBJECT( class, "source", 1,
		_( "Source" ),
		_( "Source to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadJpegSource, source ),
		VIPS_TYPE_SOURCE );
}
<a name="5"></a>static void
vips_foreign_load_jpeg_source_init( VipsForeignLoadJpegSource *source )
{
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
typedef struct _VipsForeignLoadJpegFile {
	VipsForeignLoadJpeg parent_object;
	char *filename; 
} VipsForeignLoadJpegFile;
typedef VipsForeignLoadJpegClass VipsForeignLoadJpegFileClass;
G_DEFINE_TYPE( VipsForeignLoadJpegFile, vips_foreign_load_jpeg_file, 
	vips_foreign_load_jpeg_get_type() );
static int
vips_foreign_load_jpeg_file_build( VipsObject *object )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
	VipsForeignLoadJpegFile *file = (VipsForeignLoadJpegFile *) object;
	if( file-&gt;filename &amp;&amp;</b></font>
		!(jpeg-&gt;source = 
			vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );
	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_file_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static gboolean
vips_foreign_load_jpeg_file_is_a( const char *filename )
{
	VipsSource *source;
	gboolean result;
	if( !(source = vips_source_new_from_file( filename )) ) 
		return( FALSE );
	result = vips_foreign_load_jpeg_source_is_a_source( source );
<a name="6"></a>	VIPS_UNREF( source );
	return( result );
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
vips_foreign_load_jpeg_file_class_init( VipsForeignLoadJpegFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
<a name="0"></a>	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
	gobject_class-&gt;set_property = vips_object_set_property;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "jpegload";
	object_class-&gt;description = _( "load jpeg from file" );
	object_class-&gt;build = vips_foreign_load_jpeg_file_build;
	foreign_class-&gt;suffs = vips__jpeg_suffs;
	load_class-&gt;is_a = vips_foreign_load_jpeg_file_is_a;
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadJpegFile, filename ),
		NULL );
}
static void
vips_foreign_load_jpeg_file_init( VipsForeignLoadJpegFile *file )
{
}
typedef struct _VipsForeignLoadJpegBuffer {
	VipsForeignLoadJpeg parent_object;
	VipsBlob *blob;
} VipsForeignLoadJpegBuffer;
typedef VipsForeignLoadJpegClass VipsForeignLoadJpegBufferClass;
G_DEFINE_TYPE( VipsForeignLoadJpegBuffer, vips_foreign_load_jpeg_buffer, 
	vips_foreign_load_jpeg_get_type() );
static int
vips_foreign_load_jpeg_buffer_build( VipsObject *object )
{
	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
	VipsForeignLoadJpegBuffer *buffer = 
		(VipsForeignLoadJpegBuffer *) object;
	if( buffer-&gt;blob &amp;&amp;</b></font>
		!(jpeg-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
		return( -1 );
	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_buffer_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static gboolean
vips_foreign_load_jpeg_buffer_is_a_buffer( const void *buf, size_t len )
{
	VipsSource *source;
	gboolean result;
	if( !(source = vips_source_new_from_memory( buf, len )) ) 
		return( FALSE );
<a name="3"></a>	result = vips_foreign_load_jpeg_source_is_a_source( source );
	VIPS_UNREF( source );
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( result );
}
static void
vips_foreign_load_jpeg_buffer_class_init( 
	VipsForeignLoadJpegBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "jpegload_buffer";
	object_class-&gt;description = _( "load jpeg from buffer" );
	object_class-&gt;build = vips_foreign_load_jpeg_buffer_build;</b></font>
	load_class-&gt;is_a_buffer = vips_foreign_load_jpeg_buffer_is_a_buffer;
	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadJpegBuffer, blob ),
		VIPS_TYPE_BLOB );
}
static void
vips_foreign_load_jpeg_buffer_init( VipsForeignLoadJpegBuffer *buffer )
{
}
int
vips_jpegload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "jpegload", ap, filename, out );
	va_end( ap );
	return( result );
}
int
vips_jpegload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;
	blob = vips_blob_new( NULL, buf, len );
	va_start( ap, out );
	result = vips_call_split( "jpegload_buffer", ap, blob, out );
	va_end( ap );
	vips_area_unref( VIPS_AREA( blob ) );
	return( result );
}
int
vips_jpegload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "jpegload_source", ap, source, out );
	va_end( ap );
	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/debug.h&gt;
#include &lt;vips/internal.h&gt;
#if defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)
#include "pforeign.h"
const char *vips__heif_suffs[] = { 
	".heic",
	".heif",
	".avif",
	NULL 
};
#ifdef HAVE_HEIF_DECODER
#include &lt;libheif/heif.h&gt;
#define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
#define VIPS_FOREIGN_LOAD_HEIF( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
#define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
#define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
#define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
#define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))
typedef struct _VipsForeignLoadHeif {
	VipsForeignLoad parent_object;
	int page;
	int n;
	gboolean thumbnail;
	gboolean autorotate;
	struct heif_context *ctx;
	int n_top;
	gboolean has_alpha;
	int width;
	int height;
	int page_width;
	int page_height;
	int page_no;
	gboolean thumbnail_set;
	int primary_page;
	heif_item_id *id;
	struct heif_image_handle *handle;
	struct heif_image *img;
	int stride;
	const uint8_t *data;
	VipsSource *source;
	struct heif_reader *reader;
} VipsForeignLoadHeif;
void
vips__heif_error( struct heif_error *error )
{
	if( error-&gt;code ) 
		vips_error( "heif", "%s (%d.%d)", error-&gt;message, error-&gt;code,
			error-&gt;subcode );
}
typedef struct _VipsForeignLoadHeifClass {
	VipsForeignLoadClass parent_class;
} VipsForeignLoadHeifClass;
G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
	VIPS_TYPE_FOREIGN_LOAD );
static void
vips_foreign_load_heif_dispose( GObject *gobject )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
	heif-&gt;data = NULL;
	VIPS_FREEF( heif_image_release, heif-&gt;img );
	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
	VIPS_FREE( heif-&gt;id );
	VIPS_FREE( heif-&gt;reader );
	VIPS_UNREF( heif-&gt;source );
	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
		dispose( gobject );
}
static int
vips_foreign_load_heif_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
#ifdef DEBUG
	printf( "vips_foreign_load_heif_build:\n" );
	if( heif-&gt;source &amp;&amp;
		vips_source_rewind( heif-&gt;source ) )
		return( -1 );
	if( !heif-&gt;ctx ) {
		struct heif_error error;
		heif-&gt;ctx = heif_context_alloc();
		error = heif_context_read_from_reader( heif-&gt;ctx, 
			heif-&gt;reader, heif, NULL );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static const char *heif_magic[] = {
	"ftypheic",		"ftypheix",		"ftyphevc",		"ftypheim",		"ftypheis",		"ftyphevm",		"ftyphevs",		"ftypmif1",		"ftypmsf1",		"ftypavif"	};
static int
vips_foreign_load_heif_is_a( const char *buf, int len )
{
	if( len &gt;= 12 ) {
		const guint32 chunk_len = 
			(guint32) buf[0] &lt;&lt; 24 |
			(guint32) buf[1] &lt;&lt; 16 |
			(guint32) buf[2] &lt;&lt; 8 |
			(guint32) buf[3];
		int i;
		if( chunk_len &gt; 64 || 
			chunk_len % 4 != 0 )
			return( 0 );
		for( i = 0; i &lt; VIPS_NUMBER( heif_magic ); i++ )
			if( strncmp( buf + 4, heif_magic[i], 8 ) == 0 )
				return( 1 );
	}
	return( 0 );
}
static VipsForeignFlags
vips_foreign_load_heif_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_SEQUENTIAL );
}
static int
vips_foreign_load_heif_set_thumbnail( VipsForeignLoadHeif *heif )
{
	heif_item_id thumb_ids[1];
	int n_thumbs;
	struct heif_image_handle *thumb_handle;
	struct heif_image *thumb_img;
	struct heif_error error;
	double main_aspect;
	double thumb_aspect;
#ifdef DEBUG
	printf( "vips_foreign_load_heif_set_thumbnail:\n" );
	n_thumbs = heif_image_handle_get_list_of_thumbnail_IDs( 
		heif-&gt;handle, thumb_ids, 1 );
	if( n_thumbs == 0 )
		return( 0 );
	error = heif_image_handle_get_thumbnail( heif-&gt;handle,
		thumb_ids[0], &amp;thumb_handle );
	if( error.code ) {
		vips__heif_error( &amp;error );
		return( -1 );
	}
	error = heif_decode_image( thumb_handle, &amp;thumb_img,
		heif_colorspace_RGB, 
		heif_chroma_interleaved_RGB,
		NULL );
	if( error.code ) {
		VIPS_FREEF( heif_image_handle_release, thumb_handle );
		vips__heif_error( &amp;error );
		return( -1 );
	}
	thumb_aspect = (double) 
		heif_image_get_width( thumb_img, heif_channel_interleaved ) /
		heif_image_get_height( thumb_img, heif_channel_interleaved );
	VIPS_FREEF( heif_image_release, thumb_img );
	main_aspect = (double) 
		heif_image_handle_get_width( heif-&gt;handle ) /
		heif_image_handle_get_height( heif-&gt;handle );
	if( fabs( main_aspect - thumb_aspect ) &gt; 0.1 ) {
		VIPS_FREEF( heif_image_handle_release, thumb_handle );
		return( 0 );
	}
	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
	heif-&gt;handle = thumb_handle;
	return( 0 );
}
static int
vips_foreign_load_heif_set_page( VipsForeignLoadHeif *heif, 
	int page_no, gboolean thumbnail )
{
	if( !heif-&gt;handle ||
		page_no != heif-&gt;page_no ||
		thumbnail != heif-&gt;thumbnail_set ) {
		struct heif_error error;
#ifdef DEBUG
		printf( "vips_foreign_load_heif_set_page: %d, thumbnail = %d\n",
			page_no, thumbnail );
		VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
		VIPS_FREEF( heif_image_release, heif-&gt;img );
		heif-&gt;data = NULL;
		heif-&gt;thumbnail_set = FALSE;
		error = heif_context_get_image_handle( heif-&gt;ctx, 
			heif-&gt;id[page_no], &amp;heif-&gt;handle );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
		if( thumbnail ) {
			if( vips_foreign_load_heif_set_thumbnail( heif ) )
				return( -1 );
			heif-&gt;thumbnail_set = TRUE;
		}
		heif-&gt;page_no = page_no;
	}
	return( 0 );
}
static int
vips_foreign_load_heif_set_header( VipsForeignLoadHeif *heif, VipsImage *out )
{
	VipsForeignLoad *load = (VipsForeignLoad *) heif;
	int bands;
	int i;
	heif_item_id id[16];
	int n_metadata;
	struct heif_error error;
	VipsForeignHeifCompression compression;
	if( vips_foreign_load_heif_set_page( heif, heif-&gt;page, FALSE ) )
		return( -1 );
	if ( heif-&gt;page_width &lt; 1 || heif-&gt;page_height &lt; 1 ) {
		vips_error( "heifload", "%s", _( "bad dimensions" ) );
		return( -1 );
	}
	heif-&gt;has_alpha = heif_image_handle_has_alpha_channel( heif-&gt;handle );
#ifdef DEBUG
	printf( "heif_image_handle_has_alpha_channel() = %d\n", 
		heif-&gt;has_alpha );
	bands = heif-&gt;has_alpha ? 4 : 3;
	n_metadata = heif_image_handle_get_list_of_metadata_block_IDs( 
		heif-&gt;handle, NULL, id, VIPS_NUMBER( id ) );
	for( i = 0; i &lt; n_metadata; i++ ) {
		size_t length = heif_image_handle_get_metadata_size( 
			heif-&gt;handle, id[i] );
		const char *type = heif_image_handle_get_metadata_type( 
			heif-&gt;handle, id[i] );
		unsigned char *data;
		char name[256];
#ifdef DEBUG
		printf( "metadata type = %s, length = %zu\n", type, length ); 
		if( !length )
			continue;
		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
			return( -1 );
		error = heif_image_handle_get_metadata( 
			heif-&gt;handle, id[i], data );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
		if( length &gt; 4 &amp;&amp;
			g_ascii_strcasecmp( type, "exif" ) == 0 ) {
			data += 4;
			length -= 4;
		}
		if( g_ascii_strcasecmp( type, "exif" ) == 0 )
			vips_snprintf( name, 256, VIPS_META_EXIF_NAME );
		else if( g_ascii_strcasecmp( type, "mime" ) == 0 &amp;&amp;
			length &gt; 10 &amp;&amp;
			vips_isprefix( "&lt;x:xmpmeta", (const char *) data ) ) 
			vips_snprintf( name, 256, VIPS_META_XMP_NAME );
		else
			vips_snprintf( name, 256, "heif-%s-%d", type, i );
		vips_image_set_blob( out, name, 
			(VipsCallbackFn) NULL, data, length );
	}
	vips_autorot_remove_angle( out );
#ifdef HAVE_HEIF_COLOR_PROFILE
	enum heif_color_profile_type profile_type = 
		heif_image_handle_get_color_profile_type( heif-&gt;handle );
#ifdef DEBUG
{
	printf( "profile type = " ); 
	switch( profile_type ) {
	case heif_color_profile_type_not_present: 
		printf( "none" ); 
		break;
	case heif_color_profile_type_nclx: 
		printf( "nclx" ); 
		break;
	case heif_color_profile_type_rICC: 
		printf( "rICC" ); 
		break;
	case heif_color_profile_type_prof: 
		printf( "prof" ); 
		break;
	default:
		printf( "unknown" ); 
		break;
	}
	printf( "\n" ); 
}
	if( profile_type == heif_color_profile_type_prof ||
		profile_type == heif_color_profile_type_rICC ) {
		size_t length = heif_image_handle_get_raw_color_profile_size( 
			heif-&gt;handle );
		unsigned char *data;
		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
			return( -1 );
		error = heif_image_handle_get_raw_color_profile( 
			heif-&gt;handle, data );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
#ifdef DEBUG
		printf( "profile data, length = %zd\n", length ); 
		vips_image_set_blob( out, VIPS_META_ICC_NAME, 
			(VipsCallbackFn) NULL, data, length );
	}
	else if( profile_type == heif_color_profile_type_nclx ) {
		g_warning( "heifload: ignoring nclx profile" );
	}
	vips_image_set_int( out, "heif-primary", heif-&gt;primary_page );
	vips_image_set_int( out, "n-pages", heif-&gt;n_top );
	if( vips_object_argument_isset( VIPS_OBJECT( heif ), "n" ) )
		vips_image_set_int( out, 
			VIPS_META_PAGE_HEIGHT, heif-&gt;page_height );
	compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;
#ifdef HAVE_HEIF_AVIF
{
	const unsigned char *brand_data;
	if( (brand_data = vips_source_sniff( heif-&gt;source, 12 )) ) {
		enum heif_brand brand;
		brand = heif_main_brand( brand_data, 12 );
		if( brand == heif_avif || 
			brand == heif_avis )
			compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
	}
}
	vips_image_set_string( out, "heif-compression",
		vips_enum_nick( VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
			compression ) );
	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
		return( -1 );
	vips_image_init_fields( out,
		heif-&gt;page_width, heif-&gt;page_height * heif-&gt;n, bands, 
		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 
		1.0, 1.0 );
	VIPS_SETSTR( load-&gt;out-&gt;filename, 
		vips_connection_filename( VIPS_CONNECTION( heif-&gt;source ) ) );
	return( 0 );
}
static int
vips_foreign_load_heif_header( VipsForeignLoad *load )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
	struct heif_error error;
	heif_item_id primary_id;
	int i;
#ifdef DEBUG
	printf( "vips_foreign_load_heif_header:\n" );
	heif-&gt;n_top = heif_context_get_number_of_top_level_images( heif-&gt;ctx );
	heif-&gt;id = VIPS_ARRAY( NULL, heif-&gt;n_top, heif_item_id );
	heif_context_get_list_of_top_level_image_IDs( heif-&gt;ctx, 
		heif-&gt;id, heif-&gt;n_top );
	error = heif_context_get_primary_image_ID( heif-&gt;ctx, &amp;primary_id );
	if( error.code ) {
		vips__heif_error( &amp;error );
		return( -1 );
	}
	for( i = 0; i &lt; heif-&gt;n_top; i++ )
		if( heif-&gt;id[i] == primary_id )
			heif-&gt;primary_page = i;
	if( !vips_object_argument_isset( VIPS_OBJECT( load ), "page" ) &amp;&amp;
		!vips_object_argument_isset( VIPS_OBJECT( load ), "n" ) )
		heif-&gt;page = heif-&gt;primary_page;
	if( heif-&gt;n == -1 )
		heif-&gt;n = heif-&gt;n_top - heif-&gt;page;
	if( heif-&gt;page &lt; 0 ||
		heif-&gt;n &lt;= 0 ||
		heif-&gt;page + heif-&gt;n &gt; heif-&gt;n_top ) {
		vips_error( class-&gt;nickname, "%s", _( "bad page number" ) ); 
		return( -1 ); 
	}
#ifdef DEBUG
	for( i = heif-&gt;page; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
		heif_item_id thumb_ids[1];
		int n_items;
		int n_thumbs;
		int j;
		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
			return( -1 );
		n_thumbs = heif_image_handle_get_number_of_thumbnails( 
			heif-&gt;handle );
		n_items = heif_image_handle_get_list_of_thumbnail_IDs( 
			heif-&gt;handle, thumb_ids, 1 );
		printf( "page = %d\n", i );
		printf( "n_thumbs = %d\n", n_thumbs );
		printf( "n_items = %d\n", n_items );
		for( j = 0; j &lt; n_items; j++ ) {
			struct heif_image_handle *thumb_handle;
			error = heif_image_handle_get_thumbnail( heif-&gt;handle,
				thumb_ids[j], &amp;thumb_handle );
			if( error.code ) {
				vips__heif_error( &amp;error );
				return( -1 );
			}
			printf( "  thumb %d\n", j );
			printf( "    width = %d\n", 
				heif_image_handle_get_width( thumb_handle ) );
			printf( "    height = %d\n", 
				heif_image_handle_get_height( thumb_handle ) );
		}
	}
	if( vips_foreign_load_heif_set_page( heif, 
		heif-&gt;page, heif-&gt;thumbnail ) )
		return( -1 );
	heif-&gt;page_width = heif_image_handle_get_width( heif-&gt;handle );
	heif-&gt;page_height = heif_image_handle_get_height( heif-&gt;handle );
	for( i = heif-&gt;page + 1; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
		if( vips_foreign_load_heif_set_page( heif, 
			i, heif-&gt;thumbnail ) )
			return( -1 );
		if( heif_image_handle_get_width( heif-&gt;handle ) 
				!= heif-&gt;page_width ||
			heif_image_handle_get_height( heif-&gt;handle ) 
				!= heif-&gt;page_height ) {
			vips_error( class-&gt;nickname, "%s", 
				_( "not all pages are the same size" ) ); 
			return( -1 ); 
		}
	}
#ifdef DEBUG
	printf( "page_width = %d\n", heif-&gt;page_width );
	printf( "page_height = %d\n", heif-&gt;page_height );
	printf( "n_top = %d\n", heif-&gt;n_top );
	for( i = 0; i &lt; heif-&gt;n_top; i++ ) {
		printf( "  id[%d] = %d\n", i, heif-&gt;id[i] );
		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
			return( -1 );
		printf( "    width = %d\n", 
			heif_image_handle_get_width( heif-&gt;handle ) );
		printf( "    height = %d\n", 
			heif_image_handle_get_height( heif-&gt;handle ) );
		printf( "    has_depth = %d\n", 
			heif_image_handle_has_depth_image( heif-&gt;handle ) );
		printf( "    has_alpha = %d\n", 
			heif_image_handle_has_alpha_channel( heif-&gt;handle ) );
		printf( "    n_metadata = %d\n", 
			heif_image_handle_get_number_of_metadata_blocks( 
				heif-&gt;handle, NULL ) );
#ifdef HAVE_HEIF_COLOR_PROFILE
		printf( "    colour profile type = 0x%xd\n", 
			heif_image_handle_get_color_profile_type( 
				heif-&gt;handle ) );
	}
	if( vips_foreign_load_heif_set_header( heif, load-&gt;out ) )
		return( -1 );
	vips_source_minimise( heif-&gt;source );
	return( 0 );
}
#ifdef DEBUG
void
vips__heif_image_print( struct heif_image *img )
{
	const static enum heif_channel channel[] = {
		heif_channel_Y,
		heif_channel_Cb,
		heif_channel_Cr,
		heif_channel_R,
		heif_channel_G,
		heif_channel_B,
		heif_channel_Alpha,
		heif_channel_interleaved
	};
	const static char *channel_name[] = {
		"heif_channel_Y",
		"heif_channel_Cb",
		"heif_channel_Cr",
		"heif_channel_R",
		"heif_channel_G",
		"heif_channel_B",
		"heif_channel_Alpha",
		"heif_channel_interleaved"
	};
	int i;
	printf( "vips__heif_image_print:\n" );
	for( i = 0; i &lt; VIPS_NUMBER( channel ); i++ ) {
		if( !heif_image_has_channel( img, channel[i] ) )
			continue;
		printf( "\t%s:\n", channel_name[i] ); 
		printf( "\t\twidth = %d\n", 
			heif_image_get_width( img, channel[i] ) );
		printf( "\t\theight = %d\n", 
			heif_image_get_height( img, channel[i] ) );
		printf( "\t\tbits = %d\n", 
			heif_image_get_bits_per_pixel( img, channel[i] ) );
	}
}
static int
vips_foreign_load_heif_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
        VipsRect *r = &amp;or-&gt;valid;
	int page = r-&gt;top / heif-&gt;page_height + heif-&gt;page;
	int line = r-&gt;top % heif-&gt;page_height;
#ifdef DEBUG_VERBOSE
	printf( "vips_foreign_load_heif_generate: line %d\n", r-&gt;top );
	g_assert( r-&gt;height == 1 );
	if( vips_foreign_load_heif_set_page( heif, page, heif-&gt;thumbnail ) )
		return( -1 );
	if( !heif-&gt;img ) {
		struct heif_error error;
		struct heif_decoding_options *options;
		enum heif_chroma chroma = heif-&gt;has_alpha ? 
			heif_chroma_interleaved_RGBA :
			heif_chroma_interleaved_RGB;
		options = heif_decoding_options_alloc();
#ifdef HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT
		options-&gt;convert_hdr_to_8bit = TRUE;
		error = heif_decode_image( heif-&gt;handle, &amp;heif-&gt;img, 
			heif_colorspace_RGB, chroma, 
			options );
		heif_decoding_options_free( options );
		if( error.code ) {
			vips__heif_error( &amp;error );
			return( -1 );
		}
#ifdef DEBUG
		vips__heif_image_print( heif-&gt;img );
	}
	if( !heif-&gt;data ) {
		int image_width = heif_image_get_width( heif-&gt;img, 
			heif_channel_interleaved );
		int image_height = heif_image_get_height( heif-&gt;img, 
			heif_channel_interleaved );
		if( image_width != heif-&gt;page_width ||
			image_height != heif-&gt;page_height ) {
			vips_error( class-&gt;nickname, 
				"%s", _( "bad image dimensions on decode" ) );
			return( -1 );
		}
		if( !(heif-&gt;data = heif_image_get_plane_readonly( heif-&gt;img, 
			heif_channel_interleaved, &amp;heif-&gt;stride )) ) {
			vips_error( class-&gt;nickname, 
				"%s", _( "unable to get image data" ) );
			return( -1 );
		}
	}
	memcpy( VIPS_REGION_ADDR( or, 0, r-&gt;top ),
		heif-&gt;data + heif-&gt;stride * line, 
		VIPS_IMAGE_SIZEOF_LINE( or-&gt;im ) );
	return( 0 );
}
static void
vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
{
	vips_source_minimise( heif-&gt;source );
}
static int
vips_foreign_load_heif_load( VipsForeignLoad *load )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( load ), 3 );
#ifdef DEBUG
	printf( "vips_foreign_load_heif_load: loading image\n" );
	t[0] = vips_image_new();
	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
		return( -1 );
	g_signal_connect( t[0], "minimise", 
		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
	if( vips_image_generate( t[0],
		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
		vips_sequential( t[0], &amp;t[1], NULL ) ||
		vips_image_write( t[1], load-&gt;real ) )
		return( -1 );
<a name="2"></a>	if( vips_source_decode( heif-&gt;source ) )
		return( -1 );
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}
static void
vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;dispose = vips_foreign_load_heif_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "heifload_base";
	object_class-&gt;description = _( "load a HEIF image" );
	object_class-&gt;build = vips_foreign_load_heif_build;</b></font>
	load_class-&gt;get_flags = vips_foreign_load_heif_get_flags;
	load_class-&gt;header = vips_foreign_load_heif_header;
	load_class-&gt;load = vips_foreign_load_heif_load;
	VIPS_ARG_INT( class, "page", 2,
		_( "Page" ),
		_( "Load this page from the file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, page ),
		0, 100000, 0 );
	VIPS_ARG_INT( class, "n", 3,
		_( "n" ),
		_( "Load this many pages" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, n ),
		-1, 100000, 1 );
	VIPS_ARG_BOOL( class, "thumbnail", 4, 
		_( "Thumbnail" ), 
		_( "Fetch thumbnail image" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, thumbnail ),
		FALSE );
	VIPS_ARG_BOOL( class, "autorotate", 21, 
		_( "Autorotate" ), 
		_( "Rotate image using exif orientation" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoadHeif, autorotate ),
		FALSE );
}
static gint64
vips_foreign_load_heif_get_position( void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
	return( vips_source_seek( heif-&gt;source, 0L, SEEK_CUR ) );
}
static int
vips_foreign_load_heif_read( void *data, size_t size, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
	while( size &gt; 0 ) {
		gint64 bytes_read;
		bytes_read = vips_source_read( heif-&gt;source, data, size );
		if( bytes_read &lt;= 0 ) 
			return( -1 );
		size -= bytes_read;
		data += bytes_read;
	}
	return( 0 );
}
static int
vips_foreign_load_heif_seek( gint64 position, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
	return( vips_source_seek( heif-&gt;source, position, SEEK_SET ) == -1 );
}
static enum heif_reader_grow_status 
vips_foreign_load_heif_wait_for_file_size( gint64 target_size, void *userdata )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
	gint64 old_position;
	gint64 result;
	enum heif_reader_grow_status status;
	old_position = vips_source_seek( heif-&gt;source, 0L, SEEK_CUR );
	result = vips_source_seek( heif-&gt;source, target_size, SEEK_SET );
	vips_source_seek( heif-&gt;source, old_position, SEEK_SET );
	if( result &lt; 0 )
		status = heif_reader_grow_status_size_beyond_eof;
	else
		status = heif_reader_grow_status_size_reached;
	return( status );
}
static void
vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
{
	heif-&gt;n = 1;
	heif-&gt;reader = VIPS_ARRAY( NULL, 1, struct heif_reader );
	heif-&gt;reader-&gt;reader_api_version = 1;
	heif-&gt;reader-&gt;get_position = vips_foreign_load_heif_get_position;
	heif-&gt;reader-&gt;read = vips_foreign_load_heif_read;
<a name="5"></a>	heif-&gt;reader-&gt;seek = vips_foreign_load_heif_seek;
	heif-&gt;reader-&gt;wait_for_file_size = 
		vips_foreign_load_heif_wait_for_file_size;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
typedef struct _VipsForeignLoadHeifFile {
	VipsForeignLoadHeif parent_object;
	char *filename; 
} VipsForeignLoadHeifFile;
typedef VipsForeignLoadHeifClass VipsForeignLoadHeifFileClass;
G_DEFINE_TYPE( VipsForeignLoadHeifFile, vips_foreign_load_heif_file, 
	vips_foreign_load_heif_get_type() );
static int
vips_foreign_load_heif_file_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) object;
	if( file-&gt;filename ) </b></font>
		if( !(heif-&gt;source = 
			vips_source_new_from_file( file-&gt;filename )) )
			return( -1 );
	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static int
vips_foreign_load_heif_file_is_a( const char *filename )
{
<a name="4"></a>	char buf[12];
	if( vips__get_bytes( filename, (unsigned char *) buf, 12 ) != 12 )
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( 0 );
	return( vips_foreign_load_heif_is_a( buf, 12 ) );
}
static void
vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
<a name="0"></a>	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;</b></font>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "heifload";
	object_class-&gt;build = vips_foreign_load_heif_file_build;
	foreign_class-&gt;suffs = vips__heif_suffs;
	load_class-&gt;is_a = vips_foreign_load_heif_file_is_a;
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifFile, filename ),
		NULL );
}
static void
vips_foreign_load_heif_file_init( VipsForeignLoadHeifFile *file )
{
}
typedef struct _VipsForeignLoadHeifBuffer {
	VipsForeignLoadHeif parent_object;
	VipsArea *buf;
} VipsForeignLoadHeifBuffer;
typedef VipsForeignLoadHeifClass VipsForeignLoadHeifBufferClass;
G_DEFINE_TYPE( VipsForeignLoadHeifBuffer, vips_foreign_load_heif_buffer, 
	vips_foreign_load_heif_get_type() );
static int
vips_foreign_load_heif_buffer_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifBuffer *buffer = 
		(VipsForeignLoadHeifBuffer *) object;
	if( buffer-&gt;buf )</b></font>
		if( !(heif-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
			return( -1 );
	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
<a name="3"></a>static gboolean
vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
{
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( vips_foreign_load_heif_is_a( buf, len ) );
}
static void
vips_foreign_load_heif_buffer_class_init( 
	VipsForeignLoadHeifBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "heifload_buffer";
	object_class-&gt;build = vips_foreign_load_heif_buffer_build;
	load_class-&gt;is_a_buffer = vips_foreign_load_heif_buffer_is_a;</b></font>
	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifBuffer, buf ),
		VIPS_TYPE_BLOB );
}
<a name="1"></a>static void
vips_foreign_load_heif_buffer_init( VipsForeignLoadHeifBuffer *buffer )
{
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
typedef struct _VipsForeignLoadHeifSource {
	VipsForeignLoadHeif parent_object;
	VipsSource *source;
} VipsForeignLoadHeifSource;
typedef VipsForeignLoadHeifClass VipsForeignLoadHeifSourceClass;
G_DEFINE_TYPE( VipsForeignLoadHeifSource, vips_foreign_load_heif_source, 
	vips_foreign_load_heif_get_type() );
static int
vips_foreign_load_heif_source_build( VipsObject *object )
{
	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
	VipsForeignLoadHeifSource *source = 
		(VipsForeignLoadHeifSource *) object;
	if( source-&gt;source ) {
		heif-&gt;source = source-&gt;source;
		g_object_ref( heif-&gt;source );
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_source_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static gboolean
vips_foreign_load_heif_source_is_a_source( VipsSource *source )
{</b></font>
	const char *p;
<a name="6"></a>
	return( (p = (const char *) vips_source_sniff( source, 12 )) &amp;&amp;
		vips_foreign_load_heif_is_a( p, 12 ) );
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
vips_foreign_load_heif_source_class_init( 
	VipsForeignLoadHeifSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "heifload_source";
	object_class-&gt;build = vips_foreign_load_heif_source_build;
	load_class-&gt;is_a_source = vips_foreign_load_heif_source_is_a_source;
	VIPS_ARG_OBJECT( class, "source", 1,
		_( "Source" ),
		_( "Source to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadHeifSource, source ),
		VIPS_TYPE_SOURCE );
}
static void
vips_foreign_load_heif_source_init( VipsForeignLoadHeifSource *source )
{
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
