
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/emitter.h"
3  static bool print_raw = false;
4  static bool print_escaped = false;
5  typedef struct buf_descriptor_s buf_descriptor_t;
6  struct buf_descriptor_s {
7  	char *buf;
8  	size_t len;
9  	bool mid_quote;
10  };
11  static void
12  forwarding_cb(void *buf_descriptor_v, const char *str) {
13  	buf_descriptor_t *buf_descriptor = (buf_descriptor_t *)buf_descriptor_v;
14  	if (print_raw) {
15  		malloc_printf("%s", str);
16  	}
17  	if (print_escaped) {
18  		const char *it = str;
19  		while (*it != '\0') {
20  			if (!buf_descriptor->mid_quote) {
21  				malloc_printf("\"");
22  				buf_descriptor->mid_quote = true;
23  			}
24  			switch (*it) {
25  			case '\\':
26  				malloc_printf("\\");
27  				break;
28  			case '\"':
29  				malloc_printf("\\\"");
30  				break;
31  			case '\t':
32  				malloc_printf("\\t");
33  				break;
34  			case '\n':
35  				malloc_printf("\\n\"\n");
36  				buf_descriptor->mid_quote = false;
37  				break;
38  			default:
39  				malloc_printf("%c", *it);
40  			}
41  			it++;
42  		}
43  	}
44  	size_t written = malloc_snprintf(buf_descriptor->buf,
45  	    buf_descriptor->len, "%s", str);
46  	assert_zu_eq(written, strlen(str), "Buffer overflow!");
47  	buf_descriptor->buf += written;
48  	buf_descriptor->len -= written;
49  	assert_zu_gt(buf_descriptor->len, 0, "Buffer out of space!");
50  }
51  static void
52  assert_emit_output(void (*emit_fn)(emitter_t *),
53      const char *expected_json_output, const char *expected_table_output) {
54  	emitter_t emitter;
55  	char buf[MALLOC_PRINTF_BUFSIZE];
56  	buf_descriptor_t buf_descriptor;
57  	buf_descriptor.buf = buf;
58  	buf_descriptor.len = MALLOC_PRINTF_BUFSIZE;
59  	buf_descriptor.mid_quote = false;
60  	emitter_init(&emitter, emitter_output_json, &forwarding_cb,
61  	    &buf_descriptor);
62  	(*emit_fn)(&emitter);
63  	assert_str_eq(expected_json_output, buf, "json output failure");
64  	buf_descriptor.buf = buf;
65  	buf_descriptor.len = MALLOC_PRINTF_BUFSIZE;
66  	buf_descriptor.mid_quote = false;
67  	emitter_init(&emitter, emitter_output_table, &forwarding_cb,
68  	    &buf_descriptor);
69  	(*emit_fn)(&emitter);
70  	assert_str_eq(expected_table_output, buf, "table output failure");
71  }
72  static void
73  emit_dict(emitter_t *emitter) {
74  	bool b_false = false;
75  	bool b_true = true;
76  	int i_123 = 123;
77  	const char *str = "a string";
78  	emitter_begin(emitter);
79  	emitter_dict_begin(emitter, "foo", "This is the foo table:");
80  	emitter_kv(emitter, "abc", "ABC", emitter_type_bool, &b_false);
81  	emitter_kv(emitter, "def", "DEF", emitter_type_bool, &b_true);
82  	emitter_kv_note(emitter, "ghi", "GHI", emitter_type_int, &i_123,
83  	    "note_key1", emitter_type_string, &str);
84  	emitter_kv_note(emitter, "jkl", "JKL", emitter_type_string, &str,
85  	    "note_key2", emitter_type_bool, &b_false);
86  	emitter_dict_end(emitter);
87  	emitter_end(emitter);
88  }
89  static const char *dict_json =
90  "{\n"
91  "\t\"foo\": {\n"
92  "\t\t\"abc\": false,\n"
93  "\t\t\"def\": true,\n"
94  "\t\t\"ghi\": 123,\n"
95  "\t\t\"jkl\": \"a string\"\n"
96  "\t}\n"
97  "}\n";
98  static const char *dict_table =
99  "This is the foo table:\n"
100  "  ABC: false\n"
101  "  DEF: true\n"
102  "  GHI: 123 (note_key1: \"a string\")\n"
103  "  JKL: \"a string\" (note_key2: false)\n";
104  TEST_BEGIN(test_dict) {
105  	assert_emit_output(&emit_dict, dict_json, dict_table);
106  }
107  TEST_END
108  static void
109  emit_table_printf(emitter_t *emitter) {
110  	emitter_begin(emitter);
111  	emitter_table_printf(emitter, "Table note 1\n");
112  	emitter_table_printf(emitter, "Table note 2 %s\n",
113  	    "with format string");
114  	emitter_end(emitter);
115  }
116  static const char *table_printf_json =
117  "{\n"
118  "}\n";
119  static const char *table_printf_table =
120  "Table note 1\n"
121  "Table note 2 with format string\n";
122  TEST_BEGIN(test_table_printf) {
123  	assert_emit_output(&emit_table_printf, table_printf_json,
124  	    table_printf_table);
125  }
126  TEST_END
127  static void emit_nested_dict(emitter_t *emitter) {
128  	int val = 123;
129  	emitter_begin(emitter);
130  	emitter_dict_begin(emitter, "json1", "Dict 1");
131  	emitter_dict_begin(emitter, "json2", "Dict 2");
132  	emitter_kv(emitter, "primitive", "A primitive", emitter_type_int, &val);
133  	emitter_dict_end(emitter); &bsol;* Close 2 */
134  	emitter_dict_begin(emitter, "json3", "Dict 3");
135  	emitter_dict_end(emitter); &bsol;* Close 3 */
136  	emitter_dict_end(emitter); &bsol;* Close 1 */
137  	emitter_dict_begin(emitter, "json4", "Dict 4");
138  	emitter_kv(emitter, "primitive", "Another primitive",
139  	    emitter_type_int, &val);
140  	emitter_dict_end(emitter); &bsol;* Close 4 */
141  	emitter_end(emitter);
142  }
143  static const char *nested_object_json =
144  "{\n"
145  "\t\"json1\": {\n"
146  "\t\t\"json2\": {\n"
147  "\t\t\t\"primitive\": 123\n"
148  "\t\t},\n"
149  "\t\t\"json3\": {\n"
150  "\t\t}\n"
151  "\t},\n"
152  "\t\"json4\": {\n"
153  "\t\t\"primitive\": 123\n"
154  "\t}\n"
155  "}\n";
156  static const char *nested_object_table =
157  "Dict 1\n"
158  "  Dict 2\n"
159  "    A primitive: 123\n"
160  "  Dict 3\n"
161  "Dict 4\n"
162  "  Another primitive: 123\n";
163  TEST_BEGIN(test_nested_dict) {
164  	assert_emit_output(&emit_nested_dict, nested_object_json,
165  	    nested_object_table);
166  }
167  TEST_END
168  static void
169  emit_types(emitter_t *emitter) {
170  	bool b = false;
171  	int i = -123;
172  	unsigned u = 123;
173  	ssize_t zd = -456;
174  	size_t zu = 456;
175  	const char *str = "string";
176  	uint32_t u32 = 789;
177  	uint64_t u64 = 10000000000ULL;
178  	emitter_begin(emitter);
179  	emitter_kv(emitter, "k1", "K1", emitter_type_bool, &b);
180  	emitter_kv(emitter, "k2", "K2", emitter_type_int, &i);
181  	emitter_kv(emitter, "k3", "K3", emitter_type_unsigned, &u);
182  	emitter_kv(emitter, "k4", "K4", emitter_type_ssize, &zd);
<span onclick='openModal()' class='match'>183  	emitter_kv(emitter, "k5", "K5", emitter_type_size, &zu);
184  	emitter_kv(emitter, "k6", "K6", emitter_type_string, &str);
185  	emitter_kv(emitter, "k7", "K7", emitter_type_uint32, &u32);
</span>186  	emitter_kv(emitter, "k8", "K8", emitter_type_uint64, &u64);
187  	emitter_end(emitter);
188  }
189  static const char *types_json =
190  "{\n"
191  "\t\"k1\": false,\n"
192  "\t\"k2\": -123,\n"
193  "\t\"k3\": 123,\n"
194  "\t\"k4\": -456,\n"
195  "\t\"k5\": 456,\n"
196  "\t\"k6\": \"string\",\n"
197  "\t\"k7\": 789,\n"
198  "\t\"k8\": 10000000000\n"
199  "}\n";
200  static const char *types_table =
201  "K1: false\n"
202  "K2: -123\n"
203  "K3: 123\n"
204  "K4: -456\n"
205  "K5: 456\n"
206  "K6: \"string\"\n"
207  "K7: 789\n"
208  "K8: 10000000000\n";
209  TEST_BEGIN(test_types) {
210  	assert_emit_output(&emit_types, types_json, types_table);
211  }
212  TEST_END
213  static void
214  emit_modal(emitter_t *emitter) {
215  	int val = 123;
216  	emitter_begin(emitter);
217  	emitter_dict_begin(emitter, "j0", "T0");
218  	emitter_json_key(emitter, "j1");
219  	emitter_json_object_begin(emitter);
220  	emitter_kv(emitter, "i1", "I1", emitter_type_int, &val);
221  	emitter_json_kv(emitter, "i2", emitter_type_int, &val);
222  	emitter_table_kv(emitter, "I3", emitter_type_int, &val);
223  	emitter_table_dict_begin(emitter, "T1");
224  	emitter_kv(emitter, "i4", "I4", emitter_type_int, &val);
225  	emitter_json_object_end(emitter); &bsol;* Close j1 */
226  	emitter_kv(emitter, "i5", "I5", emitter_type_int, &val);
227  	emitter_table_dict_end(emitter); &bsol;* Close T1 */
228  	emitter_kv(emitter, "i6", "I6", emitter_type_int, &val);
229  	emitter_dict_end(emitter); &bsol;* Close j0 / T0 */
230  	emitter_end(emitter);
231  }
232  const char *modal_json =
233  "{\n"
234  "\t\"j0\": {\n"
235  "\t\t\"j1\": {\n"
236  "\t\t\t\"i1\": 123,\n"
237  "\t\t\t\"i2\": 123,\n"
238  "\t\t\t\"i4\": 123\n"
239  "\t\t},\n"
240  "\t\t\"i5\": 123,\n"
241  "\t\t\"i6\": 123\n"
242  "\t}\n"
243  "}\n";
244  const char *modal_table =
245  "T0\n"
246  "  I1: 123\n"
247  "  I3: 123\n"
248  "  T1\n"
249  "    I4: 123\n"
250  "    I5: 123\n"
251  "  I6: 123\n";
252  TEST_BEGIN(test_modal) {
253  	assert_emit_output(&emit_modal, modal_json, modal_table);
254  }
255  TEST_END
256  static void
257  emit_json_arr(emitter_t *emitter) {
258  	int ival = 123;
259  	emitter_begin(emitter);
260  	emitter_json_key(emitter, "dict");
261  	emitter_json_object_begin(emitter);
262  	emitter_json_key(emitter, "arr");
263  	emitter_json_array_begin(emitter);
264  	emitter_json_object_begin(emitter);
265  	emitter_json_kv(emitter, "foo", emitter_type_int, &ival);
266  	emitter_json_object_end(emitter); &bsol;* Close arr[0] */
267  	emitter_json_value(emitter, emitter_type_int, &ival);
268  	emitter_json_value(emitter, emitter_type_int, &ival);
269  	emitter_json_object_begin(emitter);
270  	emitter_json_kv(emitter, "bar", emitter_type_int, &ival);
271  	emitter_json_kv(emitter, "baz", emitter_type_int, &ival);
272  	emitter_json_object_end(emitter); &bsol;* Close arr[3]. */
273  	emitter_json_array_end(emitter); &bsol;* Close arr. */
274  	emitter_json_object_end(emitter); &bsol;* Close dict. */
275  	emitter_end(emitter);
276  }
277  static const char *json_array_json =
278  "{\n"
279  "\t\"dict\": {\n"
280  "\t\t\"arr\": [\n"
281  "\t\t\t{\n"
282  "\t\t\t\t\"foo\": 123\n"
283  "\t\t\t},\n"
284  "\t\t\t123,\n"
285  "\t\t\t123,\n"
286  "\t\t\t{\n"
287  "\t\t\t\t\"bar\": 123,\n"
288  "\t\t\t\t\"baz\": 123\n"
289  "\t\t\t}\n"
290  "\t\t]\n"
291  "\t}\n"
292  "}\n";
293  static const char *json_array_table = "";
294  TEST_BEGIN(test_json_arr) {
295  	assert_emit_output(&emit_json_arr, json_array_json, json_array_table);
296  }
297  TEST_END
298  static void
299  emit_json_nested_array(emitter_t *emitter) {
300  	int ival = 123;
301  	char *sval = "foo";
302  	emitter_begin(emitter);
303  	emitter_json_array_begin(emitter);
304  		emitter_json_array_begin(emitter);
305  		emitter_json_value(emitter, emitter_type_int, &ival);
306  		emitter_json_value(emitter, emitter_type_string, &sval);
307  		emitter_json_value(emitter, emitter_type_int, &ival);
308  		emitter_json_value(emitter, emitter_type_string, &sval);
309  		emitter_json_array_end(emitter);
310  		emitter_json_array_begin(emitter);
311  		emitter_json_value(emitter, emitter_type_int, &ival);
312  		emitter_json_array_end(emitter);
313  		emitter_json_array_begin(emitter);
314  		emitter_json_value(emitter, emitter_type_string, &sval);
315  		emitter_json_value(emitter, emitter_type_int, &ival);
316  		emitter_json_array_end(emitter);
317  		emitter_json_array_begin(emitter);
318  		emitter_json_array_end(emitter);
319  	emitter_json_array_end(emitter);
320  	emitter_end(emitter);
321  }
322  static const char *json_nested_array_json =
323  "{\n"
324  "\t[\n"
325  "\t\t[\n"
326  "\t\t\t123,\n"
327  "\t\t\t\"foo\",\n"
328  "\t\t\t123,\n"
329  "\t\t\t\"foo\"\n"
330  "\t\t],\n"
331  "\t\t[\n"
332  "\t\t\t123\n"
333  "\t\t],\n"
334  "\t\t[\n"
335  "\t\t\t\"foo\",\n"
336  "\t\t\t123\n"
337  "\t\t],\n"
338  "\t\t[\n"
339  "\t\t]\n"
340  "\t]\n"
341  "}\n";
342  TEST_BEGIN(test_json_nested_arr) {
343  	assert_emit_output(&emit_json_nested_array, json_nested_array_json,
344  	    json_array_table);
345  }
346  TEST_END
347  static void
348  emit_table_row(emitter_t *emitter) {
349  	emitter_begin(emitter);
350  	emitter_row_t row;
351  	emitter_col_t abc = {emitter_justify_left, 10, emitter_type_title, {0}, {0, 0}};
352  	abc.str_val = "ABC title";
353  	emitter_col_t def = {emitter_justify_right, 15, emitter_type_title, {0}, {0, 0}};
354  	def.str_val = "DEF title";
355  	emitter_col_t ghi = {emitter_justify_right, 5, emitter_type_title, {0}, {0, 0}};
356  	ghi.str_val = "GHI";
357  	emitter_row_init(&row);
358  	emitter_col_init(&abc, &row);
359  	emitter_col_init(&def, &row);
360  	emitter_col_init(&ghi, &row);
361  	emitter_table_row(emitter, &row);
362  	abc.type = emitter_type_int;
363  	def.type = emitter_type_bool;
364  	ghi.type = emitter_type_int;
365  	abc.int_val = 123;
366  	def.bool_val = true;
367  	ghi.int_val = 456;
368  	emitter_table_row(emitter, &row);
369  	abc.int_val = 789;
370  	def.bool_val = false;
371  	ghi.int_val = 1011;
372  	emitter_table_row(emitter, &row);
373  	abc.type = emitter_type_string;
374  	abc.str_val = "a string";
375  	def.bool_val = false;
376  	ghi.type = emitter_type_title;
377  	ghi.str_val = "ghi";
378  	emitter_table_row(emitter, &row);
379  	emitter_end(emitter);
380  }
381  static const char *table_row_json =
382  "{\n"
383  "}\n";
384  static const char *table_row_table =
385  "ABC title       DEF title  GHI\n"
386  "123                  true  456\n"
387  "789                 false 1011\n"
388  "\"a string\"          false  ghi\n";
389  TEST_BEGIN(test_table_row) {
390  	assert_emit_output(&emit_table_row, table_row_json, table_row_table);
391  }
392  TEST_END
393  int
394  main(void) {
395  	return test_no_reentrancy(
396  	    test_dict,
397  	    test_table_printf,
398  	    test_nested_dict,
399  	    test_types,
400  	    test_modal,
401  	    test_json_arr,
402  	    test_json_nested_arr,
403  	    test_table_row);
404  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/emitter.h"
3  static bool print_raw = false;
4  static bool print_escaped = false;
5  typedef struct buf_descriptor_s buf_descriptor_t;
6  struct buf_descriptor_s {
7  	char *buf;
8  	size_t len;
9  	bool mid_quote;
10  };
11  static void
12  forwarding_cb(void *buf_descriptor_v, const char *str) {
13  	buf_descriptor_t *buf_descriptor = (buf_descriptor_t *)buf_descriptor_v;
14  	if (print_raw) {
15  		malloc_printf("%s", str);
16  	}
17  	if (print_escaped) {
18  		const char *it = str;
19  		while (*it != '\0') {
20  			if (!buf_descriptor->mid_quote) {
21  				malloc_printf("\"");
22  				buf_descriptor->mid_quote = true;
23  			}
24  			switch (*it) {
25  			case '\\':
26  				malloc_printf("\\");
27  				break;
28  			case '\"':
29  				malloc_printf("\\\"");
30  				break;
31  			case '\t':
32  				malloc_printf("\\t");
33  				break;
34  			case '\n':
35  				malloc_printf("\\n\"\n");
36  				buf_descriptor->mid_quote = false;
37  				break;
38  			default:
39  				malloc_printf("%c", *it);
40  			}
41  			it++;
42  		}
43  	}
44  	size_t written = malloc_snprintf(buf_descriptor->buf,
45  	    buf_descriptor->len, "%s", str);
46  	assert_zu_eq(written, strlen(str), "Buffer overflow!");
47  	buf_descriptor->buf += written;
48  	buf_descriptor->len -= written;
49  	assert_zu_gt(buf_descriptor->len, 0, "Buffer out of space!");
50  }
51  static void
52  assert_emit_output(void (*emit_fn)(emitter_t *),
53      const char *expected_json_output, const char *expected_table_output) {
54  	emitter_t emitter;
55  	char buf[MALLOC_PRINTF_BUFSIZE];
56  	buf_descriptor_t buf_descriptor;
57  	buf_descriptor.buf = buf;
58  	buf_descriptor.len = MALLOC_PRINTF_BUFSIZE;
59  	buf_descriptor.mid_quote = false;
60  	emitter_init(&emitter, emitter_output_json, &forwarding_cb,
61  	    &buf_descriptor);
62  	(*emit_fn)(&emitter);
63  	assert_str_eq(expected_json_output, buf, "json output failure");
64  	buf_descriptor.buf = buf;
65  	buf_descriptor.len = MALLOC_PRINTF_BUFSIZE;
66  	buf_descriptor.mid_quote = false;
67  	emitter_init(&emitter, emitter_output_table, &forwarding_cb,
68  	    &buf_descriptor);
69  	(*emit_fn)(&emitter);
70  	assert_str_eq(expected_table_output, buf, "table output failure");
71  }
72  static void
73  emit_dict(emitter_t *emitter) {
74  	bool b_false = false;
75  	bool b_true = true;
76  	int i_123 = 123;
77  	const char *str = "a string";
78  	emitter_begin(emitter);
79  	emitter_dict_begin(emitter, "foo", "This is the foo table:");
80  	emitter_kv(emitter, "abc", "ABC", emitter_type_bool, &b_false);
81  	emitter_kv(emitter, "def", "DEF", emitter_type_bool, &b_true);
82  	emitter_kv_note(emitter, "ghi", "GHI", emitter_type_int, &i_123,
83  	    "note_key1", emitter_type_string, &str);
84  	emitter_kv_note(emitter, "jkl", "JKL", emitter_type_string, &str,
85  	    "note_key2", emitter_type_bool, &b_false);
86  	emitter_dict_end(emitter);
87  	emitter_end(emitter);
88  }
89  static const char *dict_json =
90  "{\n"
91  "\t\"foo\": {\n"
92  "\t\t\"abc\": false,\n"
93  "\t\t\"def\": true,\n"
94  "\t\t\"ghi\": 123,\n"
95  "\t\t\"jkl\": \"a string\"\n"
96  "\t}\n"
97  "}\n";
98  static const char *dict_table =
99  "This is the foo table:\n"
100  "  ABC: false\n"
101  "  DEF: true\n"
102  "  GHI: 123 (note_key1: \"a string\")\n"
103  "  JKL: \"a string\" (note_key2: false)\n";
104  TEST_BEGIN(test_dict) {
105  	assert_emit_output(&emit_dict, dict_json, dict_table);
106  }
107  TEST_END
108  static void
109  emit_table_printf(emitter_t *emitter) {
110  	emitter_begin(emitter);
111  	emitter_table_printf(emitter, "Table note 1\n");
112  	emitter_table_printf(emitter, "Table note 2 %s\n",
113  	    "with format string");
114  	emitter_end(emitter);
115  }
116  static const char *table_printf_json =
117  "{\n"
118  "}\n";
119  static const char *table_printf_table =
120  "Table note 1\n"
121  "Table note 2 with format string\n";
122  TEST_BEGIN(test_table_printf) {
123  	assert_emit_output(&emit_table_printf, table_printf_json,
124  	    table_printf_table);
125  }
126  TEST_END
127  static void emit_nested_dict(emitter_t *emitter) {
128  	int val = 123;
129  	emitter_begin(emitter);
130  	emitter_dict_begin(emitter, "json1", "Dict 1");
131  	emitter_dict_begin(emitter, "json2", "Dict 2");
132  	emitter_kv(emitter, "primitive", "A primitive", emitter_type_int, &val);
133  	emitter_dict_end(emitter); &bsol;* Close 2 */
134  	emitter_dict_begin(emitter, "json3", "Dict 3");
135  	emitter_dict_end(emitter); &bsol;* Close 3 */
136  	emitter_dict_end(emitter); &bsol;* Close 1 */
137  	emitter_dict_begin(emitter, "json4", "Dict 4");
138  	emitter_kv(emitter, "primitive", "Another primitive",
139  	    emitter_type_int, &val);
140  	emitter_dict_end(emitter); &bsol;* Close 4 */
141  	emitter_end(emitter);
142  }
143  static const char *nested_object_json =
144  "{\n"
145  "\t\"json1\": {\n"
146  "\t\t\"json2\": {\n"
147  "\t\t\t\"primitive\": 123\n"
148  "\t\t},\n"
149  "\t\t\"json3\": {\n"
150  "\t\t}\n"
151  "\t},\n"
152  "\t\"json4\": {\n"
153  "\t\t\"primitive\": 123\n"
154  "\t}\n"
155  "}\n";
156  static const char *nested_object_table =
157  "Dict 1\n"
158  "  Dict 2\n"
159  "    A primitive: 123\n"
160  "  Dict 3\n"
161  "Dict 4\n"
162  "  Another primitive: 123\n";
163  TEST_BEGIN(test_nested_dict) {
164  	assert_emit_output(&emit_nested_dict, nested_object_json,
165  	    nested_object_table);
166  }
167  TEST_END
168  static void
169  emit_types(emitter_t *emitter) {
170  	bool b = false;
171  	int i = -123;
172  	unsigned u = 123;
173  	ssize_t zd = -456;
174  	size_t zu = 456;
175  	const char *str = "string";
176  	uint32_t u32 = 789;
177  	uint64_t u64 = 10000000000ULL;
178  	emitter_begin(emitter);
179  	emitter_kv(emitter, "k1", "K1", emitter_type_bool, &b);
180  	emitter_kv(emitter, "k2", "K2", emitter_type_int, &i);
181  	emitter_kv(emitter, "k3", "K3", emitter_type_unsigned, &u);
182  	emitter_kv(emitter, "k4", "K4", emitter_type_ssize, &zd);
183  	emitter_kv(emitter, "k5", "K5", emitter_type_size, &zu);
184  	emitter_kv(emitter, "k6", "K6", emitter_type_string, &str);
<span onclick='openModal()' class='match'>185  	emitter_kv(emitter, "k7", "K7", emitter_type_uint32, &u32);
186  	emitter_kv(emitter, "k8", "K8", emitter_type_uint64, &u64);
187  	emitter_end(emitter);
</span>188  }
189  static const char *types_json =
190  "{\n"
191  "\t\"k1\": false,\n"
192  "\t\"k2\": -123,\n"
193  "\t\"k3\": 123,\n"
194  "\t\"k4\": -456,\n"
195  "\t\"k5\": 456,\n"
196  "\t\"k6\": \"string\",\n"
197  "\t\"k7\": 789,\n"
198  "\t\"k8\": 10000000000\n"
199  "}\n";
200  static const char *types_table =
201  "K1: false\n"
202  "K2: -123\n"
203  "K3: 123\n"
204  "K4: -456\n"
205  "K5: 456\n"
206  "K6: \"string\"\n"
207  "K7: 789\n"
208  "K8: 10000000000\n";
209  TEST_BEGIN(test_types) {
210  	assert_emit_output(&emit_types, types_json, types_table);
211  }
212  TEST_END
213  static void
214  emit_modal(emitter_t *emitter) {
215  	int val = 123;
216  	emitter_begin(emitter);
217  	emitter_dict_begin(emitter, "j0", "T0");
218  	emitter_json_key(emitter, "j1");
219  	emitter_json_object_begin(emitter);
220  	emitter_kv(emitter, "i1", "I1", emitter_type_int, &val);
221  	emitter_json_kv(emitter, "i2", emitter_type_int, &val);
222  	emitter_table_kv(emitter, "I3", emitter_type_int, &val);
223  	emitter_table_dict_begin(emitter, "T1");
224  	emitter_kv(emitter, "i4", "I4", emitter_type_int, &val);
225  	emitter_json_object_end(emitter); &bsol;* Close j1 */
226  	emitter_kv(emitter, "i5", "I5", emitter_type_int, &val);
227  	emitter_table_dict_end(emitter); &bsol;* Close T1 */
228  	emitter_kv(emitter, "i6", "I6", emitter_type_int, &val);
229  	emitter_dict_end(emitter); &bsol;* Close j0 / T0 */
230  	emitter_end(emitter);
231  }
232  const char *modal_json =
233  "{\n"
234  "\t\"j0\": {\n"
235  "\t\t\"j1\": {\n"
236  "\t\t\t\"i1\": 123,\n"
237  "\t\t\t\"i2\": 123,\n"
238  "\t\t\t\"i4\": 123\n"
239  "\t\t},\n"
240  "\t\t\"i5\": 123,\n"
241  "\t\t\"i6\": 123\n"
242  "\t}\n"
243  "}\n";
244  const char *modal_table =
245  "T0\n"
246  "  I1: 123\n"
247  "  I3: 123\n"
248  "  T1\n"
249  "    I4: 123\n"
250  "    I5: 123\n"
251  "  I6: 123\n";
252  TEST_BEGIN(test_modal) {
253  	assert_emit_output(&emit_modal, modal_json, modal_table);
254  }
255  TEST_END
256  static void
257  emit_json_arr(emitter_t *emitter) {
258  	int ival = 123;
259  	emitter_begin(emitter);
260  	emitter_json_key(emitter, "dict");
261  	emitter_json_object_begin(emitter);
262  	emitter_json_key(emitter, "arr");
263  	emitter_json_array_begin(emitter);
264  	emitter_json_object_begin(emitter);
265  	emitter_json_kv(emitter, "foo", emitter_type_int, &ival);
266  	emitter_json_object_end(emitter); &bsol;* Close arr[0] */
267  	emitter_json_value(emitter, emitter_type_int, &ival);
268  	emitter_json_value(emitter, emitter_type_int, &ival);
269  	emitter_json_object_begin(emitter);
270  	emitter_json_kv(emitter, "bar", emitter_type_int, &ival);
271  	emitter_json_kv(emitter, "baz", emitter_type_int, &ival);
272  	emitter_json_object_end(emitter); &bsol;* Close arr[3]. */
273  	emitter_json_array_end(emitter); &bsol;* Close arr. */
274  	emitter_json_object_end(emitter); &bsol;* Close dict. */
275  	emitter_end(emitter);
276  }
277  static const char *json_array_json =
278  "{\n"
279  "\t\"dict\": {\n"
280  "\t\t\"arr\": [\n"
281  "\t\t\t{\n"
282  "\t\t\t\t\"foo\": 123\n"
283  "\t\t\t},\n"
284  "\t\t\t123,\n"
285  "\t\t\t123,\n"
286  "\t\t\t{\n"
287  "\t\t\t\t\"bar\": 123,\n"
288  "\t\t\t\t\"baz\": 123\n"
289  "\t\t\t}\n"
290  "\t\t]\n"
291  "\t}\n"
292  "}\n";
293  static const char *json_array_table = "";
294  TEST_BEGIN(test_json_arr) {
295  	assert_emit_output(&emit_json_arr, json_array_json, json_array_table);
296  }
297  TEST_END
298  static void
299  emit_json_nested_array(emitter_t *emitter) {
300  	int ival = 123;
301  	char *sval = "foo";
302  	emitter_begin(emitter);
303  	emitter_json_array_begin(emitter);
304  		emitter_json_array_begin(emitter);
305  		emitter_json_value(emitter, emitter_type_int, &ival);
306  		emitter_json_value(emitter, emitter_type_string, &sval);
307  		emitter_json_value(emitter, emitter_type_int, &ival);
308  		emitter_json_value(emitter, emitter_type_string, &sval);
309  		emitter_json_array_end(emitter);
310  		emitter_json_array_begin(emitter);
311  		emitter_json_value(emitter, emitter_type_int, &ival);
312  		emitter_json_array_end(emitter);
313  		emitter_json_array_begin(emitter);
314  		emitter_json_value(emitter, emitter_type_string, &sval);
315  		emitter_json_value(emitter, emitter_type_int, &ival);
316  		emitter_json_array_end(emitter);
317  		emitter_json_array_begin(emitter);
318  		emitter_json_array_end(emitter);
319  	emitter_json_array_end(emitter);
320  	emitter_end(emitter);
321  }
322  static const char *json_nested_array_json =
323  "{\n"
324  "\t[\n"
325  "\t\t[\n"
326  "\t\t\t123,\n"
327  "\t\t\t\"foo\",\n"
328  "\t\t\t123,\n"
329  "\t\t\t\"foo\"\n"
330  "\t\t],\n"
331  "\t\t[\n"
332  "\t\t\t123\n"
333  "\t\t],\n"
334  "\t\t[\n"
335  "\t\t\t\"foo\",\n"
336  "\t\t\t123\n"
337  "\t\t],\n"
338  "\t\t[\n"
339  "\t\t]\n"
340  "\t]\n"
341  "}\n";
342  TEST_BEGIN(test_json_nested_arr) {
343  	assert_emit_output(&emit_json_nested_array, json_nested_array_json,
344  	    json_array_table);
345  }
346  TEST_END
347  static void
348  emit_table_row(emitter_t *emitter) {
349  	emitter_begin(emitter);
350  	emitter_row_t row;
351  	emitter_col_t abc = {emitter_justify_left, 10, emitter_type_title, {0}, {0, 0}};
352  	abc.str_val = "ABC title";
353  	emitter_col_t def = {emitter_justify_right, 15, emitter_type_title, {0}, {0, 0}};
354  	def.str_val = "DEF title";
355  	emitter_col_t ghi = {emitter_justify_right, 5, emitter_type_title, {0}, {0, 0}};
356  	ghi.str_val = "GHI";
357  	emitter_row_init(&row);
358  	emitter_col_init(&abc, &row);
359  	emitter_col_init(&def, &row);
360  	emitter_col_init(&ghi, &row);
361  	emitter_table_row(emitter, &row);
362  	abc.type = emitter_type_int;
363  	def.type = emitter_type_bool;
364  	ghi.type = emitter_type_int;
365  	abc.int_val = 123;
366  	def.bool_val = true;
367  	ghi.int_val = 456;
368  	emitter_table_row(emitter, &row);
369  	abc.int_val = 789;
370  	def.bool_val = false;
371  	ghi.int_val = 1011;
372  	emitter_table_row(emitter, &row);
373  	abc.type = emitter_type_string;
374  	abc.str_val = "a string";
375  	def.bool_val = false;
376  	ghi.type = emitter_type_title;
377  	ghi.str_val = "ghi";
378  	emitter_table_row(emitter, &row);
379  	emitter_end(emitter);
380  }
381  static const char *table_row_json =
382  "{\n"
383  "}\n";
384  static const char *table_row_table =
385  "ABC title       DEF title  GHI\n"
386  "123                  true  456\n"
387  "789                 false 1011\n"
388  "\"a string\"          false  ghi\n";
389  TEST_BEGIN(test_table_row) {
390  	assert_emit_output(&emit_table_row, table_row_json, table_row_table);
391  }
392  TEST_END
393  int
394  main(void) {
395  	return test_no_reentrancy(
396  	    test_dict,
397  	    test_table_printf,
398  	    test_nested_dict,
399  	    test_types,
400  	    test_modal,
401  	    test_json_arr,
402  	    test_json_nested_arr,
403  	    test_table_row);
404  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.c</div>
                </div>
                <div class="column column_space"><pre><code>183  	emitter_kv(emitter, "k5", "K5", emitter_type_size, &zu);
184  	emitter_kv(emitter, "k6", "K6", emitter_type_string, &str);
185  	emitter_kv(emitter, "k7", "K7", emitter_type_uint32, &u32);
</pre></code></div>
                <div class="column column_space"><pre><code>185  	emitter_kv(emitter, "k7", "K7", emitter_type_uint32, &u32);
186  	emitter_kv(emitter, "k8", "K8", emitter_type_uint64, &u64);
187  	emitter_end(emitter);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    