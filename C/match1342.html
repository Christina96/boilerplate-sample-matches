<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mcell_react_out.c &amp; chkpt.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mcell_react_out.c &amp; chkpt.c
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mcell_react_out.c (2.097902%)<th>chkpt.c (1.182266%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(39-50)<td><a href="#" name="0">(202-207)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_react_out.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include "sym_table.h"
6 #include "logging.h"
7 #include "react_output.h"
8 #include "mcell_misc.h"
9 #include "mcell_react_out.h"
10 #include "mdlparse_util.h"
11 #include "dyngeom_parse_extras.h"
12 #include "strfunc.h"
13 #include "count_util.h"
14 static struct output_column *new_output_column(void);
15 static struct output_block *new_output_block(int buffersize);
16 static void set_reaction_output_timer_step(MCELL_STATE *state,
17 <a name="0"></a>                                           struct output_block *obp,
18                                            double step);
19 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static int
20 set_reaction_output_timer_iterations(MCELL_STATE *state,
21                                      struct output_block *obp,
22                                      struct num_expr_list_head *step_values);
23 static int
24 set_reaction_output_timer_times(MCELL_STATE *state, struct output_block *obp,
25                                 struct num_expr_list_head *step_values);
26 static int output_block_finalize(struct output_block *obp);
27 static long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,</b></font>
28                                   long long n_output);
29 static struct output_column *
30 get_counter_trigger_column(MCELL_STATE *state, const char *counter_name,
31                            int column_id);
32 int mcell_get_count(char *mol_name, char *reg_name, struct volume *world) {
33   struct sym_entry *mol_sym = NULL;  
34   mol_sym = retrieve_sym(mol_name, world-&gt;mol_sym_table);
35   if (mol_sym == NULL)
36     return -5;
37   struct species *mol = (struct species *)mol_sym-&gt;value;
38   u_int mol_hashval = mol-&gt;hashval;
39   struct sym_entry *reg_sym = NULL;  
40   reg_sym = retrieve_sym(reg_name, world-&gt;reg_sym_table);
41   if (reg_sym == NULL)
42     return -6;  
43   struct region *reg = (struct region *)reg_sym-&gt;value;
44   u_int reg_hashval = reg-&gt; hashval;
45   int hash_bin = (mol_hashval + reg_hashval) &amp; world-&gt;count_hashmask;
46   if (world-&gt;count_hash[hash_bin] == NULL)
47     return -7;
48   int mol_count_vol = world-&gt;count_hash[hash_bin]-&gt;data.move.n_enclosed;
49   int mol_count_sur = world-&gt;count_hash[hash_bin]-&gt;data.move.n_at;
50   return mol_count_vol + mol_count_sur;
51 }
52 struct output_request *mcell_new_output_request(MCELL_STATE *state,
53                                                 struct sym_entry *target,
54                                                 short orientation,
55                                                 struct sym_entry *location,
56                                                 struct periodic_image *img,
57                                                 int report_flags) {
58   struct output_request *orq;
59   struct output_expression *oe;
60   orq = (struct output_request *)CHECKED_MEM_GET(state-&gt;outp_request_mem, "count request");
61   if (orq == NULL)
62     return NULL;
63   oe = new_output_expr(state-&gt;oexpr_mem);
64   if (oe == NULL) {
65     mem_put(state-&gt;outp_request_mem, orq);
66     mcell_allocfailed("Failed to allocate a count expression.");
67     return NULL;
68   }
69   orq-&gt;next = NULL;
70   orq-&gt;requester = oe;
71   orq-&gt;count_target = target;
72   orq-&gt;count_orientation = orientation;
73   orq-&gt;count_location = location;
74   orq-&gt;report_type = report_flags;
75   orq-&gt;periodic_box = img;
76   oe-&gt;left = orq;
77   oe-&gt;oper = '#';
78   oe-&gt;expr_flags = OEXPR_LEFT_REQUEST;
79   struct sym_entry *sym = NULL;
80   if (location) {
81     char *name = location-&gt;name;
82     if (strchr(location-&gt;name, ',')) {
83       sym = retrieve_sym(name, state-&gt;reg_sym_table);
84     }
85     else {
86       sym = retrieve_sym(name, state-&gt;obj_sym_table);
87     }
88   }
89   if (sym &amp;&amp; !(is_object_instantiated(sym, state-&gt;root_instance))) 
90     oe-&gt;expr_flags = OEXPR_TYPE_UNDEF;
91   else if (orq-&gt;report_type &amp; REPORT_TRIGGER)
92     oe-&gt;expr_flags |= OEXPR_TYPE_TRIG;
93   else if ((orq-&gt;report_type &amp; REPORT_TYPE_MASK) != REPORT_CONTENTS)
94     oe-&gt;expr_flags |= OEXPR_TYPE_DBL;
95   else
96     oe-&gt;expr_flags |= OEXPR_TYPE_INT;
97   return orq;
98 }
99 MCELL_STATUS
100 mcell_create_count(MCELL_STATE *state, struct sym_entry *target,
101                    short orientation, struct sym_entry *location,
102                    int report_flags, char *custom_header,
103                    struct output_column_list *count_list) {
104   struct output_request *output_A = NULL;
105   if ((output_A = mcell_new_output_request(state, target, orientation, location,
106     NULL, report_flags)) == NULL) {
107     return MCELL_FAIL;
108   }
109   output_A-&gt;next = state-&gt;output_request_head;
110   state-&gt;output_request_head = output_A;
111   return mcell_prepare_single_count_expr(count_list, output_A-&gt;requester,
112                                          custom_header);
113 }
114 struct output_set *mcell_create_new_output_set(const char *comment, int exact_time,
115                                                struct output_column *col_head,
116                                                int file_flags,
117                                                const char *outfile_name) {
118   struct output_set *os =
119       CHECKED_MALLOC_STRUCT(struct output_set, "reaction data output set");
120   if (os == NULL) {
121     return NULL;
122   }
123   os-&gt;outfile_name = CHECKED_STRDUP(outfile_name, "count outfile_name");
124   os-&gt;file_flags = (enum overwrite_policy_t)file_flags;
125   os-&gt;exact_time_flag = exact_time;
126   os-&gt;chunk_count = 0;
127   os-&gt;block = NULL;
128   os-&gt;next = NULL;
129   struct output_column *oc = col_head;
130   os-&gt;column_head = oc;
131   if (comment == NULL)
132     os-&gt;header_comment = NULL;
133   else if (comment[0] == '\0')
134     os-&gt;header_comment = "";
135   else {
136     os-&gt;header_comment = strdup(comment);
137     if (os-&gt;header_comment == NULL) {
138       free(os);
139       return NULL;
140     }
141   }
142   for (; oc != NULL; oc = oc-&gt;next)
143     oc-&gt;set = os;
144   if (check_reaction_output_file(os)) {
145     free(os);
146     return NULL;
147   }
148   return os;
149 }
150 MCELL_STATUS
151 mcell_prepare_single_count_expr(struct output_column_list *list,
152                                 struct output_expression *expr,
153                                 char *custom_header) {
154   list-&gt;column_head = NULL;
155   list-&gt;column_tail = NULL;
156   if (custom_header != NULL) {
157     expr-&gt;title = custom_header;
158   }
159   struct output_expression *oe;
160   struct output_column *oc;
161   for (oe = first_oexpr_tree(expr); oe != NULL; oe = next_oexpr_tree(oe)) {
162     if ((oc = new_output_column()) == NULL)
163       return MCELL_FAIL;
164     if (!list-&gt;column_head)
165       list-&gt;column_head = list-&gt;column_tail = oc;
166     else
167       list-&gt;column_tail = list-&gt;column_tail-&gt;next = oc;
168     oc-&gt;expr = oe;
169     set_oexpr_column(oe, oc);
170   }
171   return MCELL_SUCCESS;
172 }
173 MCELL_STATUS
174 mcell_add_reaction_output_block(MCELL_STATE *state,
175                                 struct output_set_list *osets, int buffer_size,
176                                 struct output_times_inlist *otimes) {
177   struct output_block *obp;
178   struct output_set *os;
179   if ((obp = new_output_block(buffer_size)) == NULL)
180     return 1;
181   if (otimes-&gt;type == OUTPUT_BY_STEP)
182     set_reaction_output_timer_step(state, obp, otimes-&gt;step);
183   else if (otimes-&gt;type == OUTPUT_BY_ITERATION_LIST) {
184     if (set_reaction_output_timer_iterations(state, obp, &amp;otimes-&gt;values)) {
185       free(obp);
186       return MCELL_FAIL;
187     }
188   } else if (otimes-&gt;type == OUTPUT_BY_TIME_LIST) {
189     if (set_reaction_output_timer_times(state, obp, &amp;otimes-&gt;values)) {
190       free(obp);
191       return MCELL_FAIL;
192     }
193   } else {
194     mcell_error("Internal error: Invalid output timer def (%d)", otimes-&gt;type);
195     free(obp);
196     return MCELL_FAIL;
197   }
198   obp-&gt;data_set_head = osets-&gt;set_head;
199   for (os = obp-&gt;data_set_head; os != NULL; os = os-&gt;next)
200     os-&gt;block = obp;
201   if (output_block_finalize(obp))
202     return 1;
203   obp-&gt;next = state-&gt;output_block_head;
204   state-&gt;output_block_head = obp;
205   return MCELL_SUCCESS;
206 }
207 MCELL_STATUS
208 mcell_get_counter_value(MCELL_STATE *state,
209                         const char *counter_name,
210                         int column_id,
211                         double *count_data,
212                         enum count_type_t *count_data_type) {
213   struct output_column *column = NULL;
214   if ((column = get_counter_trigger_column(state, counter_name, column_id)) ==
215       NULL) {
216     return MCELL_FAIL;
217   }
218   if (column-&gt;buffer[0].data_type == COUNT_TRIG_STRUCT) {
219     return MCELL_FAIL;
220   }
221   eval_oexpr_tree(column-&gt;expr, 1);
222   *count_data = (double)column-&gt;expr-&gt;value;
223   *count_data_type = column-&gt;buffer[0].data_type;
224   return MCELL_SUCCESS;
225 }
226 struct output_column *new_output_column() {
227   struct output_column *oc;
228   oc = CHECKED_MALLOC_STRUCT(struct output_column,
229                              "reaction data output column");
230   if (oc == NULL)
231     return NULL;
232   oc-&gt;initial_value = 0.0;
233   oc-&gt;buffer = NULL;
234   oc-&gt;expr = NULL;
235   oc-&gt;next = NULL;
236   return oc;
237 }
238 struct output_block *new_output_block(int buffersize) {
239   struct output_block *obp;
240   obp =
241       CHECKED_MALLOC_STRUCT(struct output_block, "reaction data output block");
242   if (obp == NULL)
243     return NULL;
244   obp-&gt;t = 0.0;
245   obp-&gt;timer_type = OUTPUT_BY_STEP;
246   obp-&gt;step_time = FOREVER;
247   obp-&gt;time_list_head = NULL;
248   obp-&gt;time_now = NULL;
249   obp-&gt;buffersize = 0;
250   obp-&gt;trig_bufsize = 0;
251   obp-&gt;buf_index = 0;
252   obp-&gt;data_set_head = NULL;
253   obp-&gt;buffersize = buffersize;
254   obp-&gt;trig_bufsize = obp-&gt;buffersize;
255   obp-&gt;time_array = CHECKED_MALLOC_ARRAY(double, obp-&gt;buffersize,
256                                          "reaction data output times array");
257   if (obp-&gt;time_array == NULL) {
258     free(obp);
259     return NULL;
260   }
261   return obp;
262 }
263 void set_reaction_output_timer_step(MCELL_STATE *state,
264                                     struct output_block *obp, double step) {
265   long long output_freq;
266   obp-&gt;timer_type = OUTPUT_BY_STEP;
267   obp-&gt;step_time = step;
268   output_freq = (long long)(obp-&gt;step_time / state-&gt;time_unit);
269   if (output_freq &gt; state-&gt;iterations &amp;&amp; output_freq &gt; 1) {
270     output_freq = (state-&gt;iterations &gt; 1) ? state-&gt;iterations : 1;
271     obp-&gt;step_time = output_freq * state-&gt;time_unit;
272     if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
273       mcell_warn("output step time too long.\n  Setting output step time to "
274                  "%g seconds.", obp-&gt;step_time);
275   } else if (output_freq &lt; 1) {
276     output_freq = 1;
277     obp-&gt;step_time = output_freq * state-&gt;time_unit;
278     if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
279       mcell_warn("output step time too short.\n  Setting output step time to "
280                  "%g seconds.", obp-&gt;step_time);
281   }
282   long long n_output;
283   if (state-&gt;chkpt_iterations)
284     n_output = (long long)(state-&gt;chkpt_iterations / output_freq + 1);
285   else
286     n_output = (long long)(state-&gt;iterations / output_freq + 1);
287   obp-&gt;buffersize = pick_buffer_size(state, obp, n_output);
288   no_printf("Default output step time definition:\n");
289   no_printf("  output step time = %g\n", obp-&gt;step_time);
290   no_printf("  output buffersize = %u\n", obp-&gt;buffersize);
291 }
292 long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,
293                            long long n_output) {
294   if (state-&gt;chkpt_iterations)
295     return min3ll(state-&gt;chkpt_iterations - state-&gt;start_iterations + 1, n_output,
296                   obp-&gt;buffersize);
297   else
298     return min3ll(state-&gt;iterations - state-&gt;start_iterations + 1, n_output,
299                   obp-&gt;buffersize);
300 }
301 int
302 set_reaction_output_timer_iterations(MCELL_STATE *state,
303                                      struct output_block *obp,
304                                      struct num_expr_list_head *step_values) {
305   obp-&gt;timer_type = OUTPUT_BY_ITERATION_LIST;
306   obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
307   if (step_values-&gt;shared) {
308     obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
309     if (obp-&gt;time_list_head == NULL)
310       return 1;
311   } else {
312     mcell_sort_numeric_list(step_values-&gt;value_head);
313     obp-&gt;time_list_head = step_values-&gt;value_head;
314   }
315   obp-&gt;time_now = NULL;
316   return 0;
317 }
318 int set_reaction_output_timer_times(MCELL_STATE *state,
319                                     struct output_block *obp,
320                                     struct num_expr_list_head *step_values) {
321   obp-&gt;timer_type = OUTPUT_BY_TIME_LIST;
322   obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
323   if (step_values-&gt;shared) {
324     obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
325     if (obp-&gt;time_list_head == NULL)
326       return 1;
327   } else {
328     mcell_sort_numeric_list(step_values-&gt;value_head);
329     obp-&gt;time_list_head = step_values-&gt;value_head;
330   }
331   obp-&gt;time_now = NULL;
332   return 0;
333 }
334 int output_block_finalize(struct output_block *obp) {
335   struct output_set *os1;
336   for (os1 = obp-&gt;data_set_head; os1 != NULL; os1 = os1-&gt;next) {
337     struct output_set *os2;
338     for (os2 = os1-&gt;next; os2 != NULL; os2 = os2-&gt;next) {
339       if (strcmp(os1-&gt;outfile_name, os2-&gt;outfile_name) == 0) {
340         mcell_error("COUNT statements in the same reaction data "
341                     "output block should have unique output file "
342                     "names (\"%s\" appears more than once)",
343                     os1-&gt;outfile_name);
344         return MCELL_FAIL;
345       }
346     }
347     struct output_column *oc;
348     for (oc = os1-&gt;column_head; oc != NULL; oc = oc-&gt;next) {
349       switch (oc-&gt;expr-&gt;expr_flags &amp; OEXPR_TYPE_MASK) {
350       case OEXPR_TYPE_UNDEF:
351         oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
352                                           obp-&gt;buffersize,
353                                           "reaction data output buffer");
354         for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
355           oc-&gt;buffer[i].data_type = COUNT_UNSET;
356           oc-&gt;buffer[i].val.cval = 'X';
357         }
358         break;
359       case OEXPR_TYPE_INT:
360         oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
361                                           obp-&gt;buffersize,
362                                           "reaction data output buffer");
363         for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
364           oc-&gt;buffer[i].data_type = COUNT_INT;
365           oc-&gt;buffer[i].val.ival = 0;
366         }
367         break;
368       case OEXPR_TYPE_DBL:
369         oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
370                                           obp-&gt;buffersize,
371                                           "reaction data output buffer");
372         for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
373           oc-&gt;buffer[i].data_type = COUNT_DBL;
374           oc-&gt;buffer[i].val.dval = 0.0;
375         }
376         break;
377       case OEXPR_TYPE_TRIG:
378         oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
379                                           obp-&gt;trig_bufsize,
380                                           "reaction data output buffer");
381         for (u_int i = 0; i &lt; obp-&gt;trig_bufsize; ++i) {
382           oc-&gt;buffer[i].data_type = COUNT_TRIG_STRUCT;
383           oc-&gt;buffer[i].val.tval = CHECKED_MALLOC_STRUCT(
384               struct output_trigger_data,
385               "reaction data output buffer");
386           oc-&gt;buffer[i].val.tval-&gt;name = NULL;
387         }
388         break;
389       default:
390         mcell_error("Could not figure out what type of count data to store");
391         return MCELL_FAIL;
392       }
393       if (oc-&gt;buffer == NULL)
394         return MCELL_FAIL;
395     }
396   }
397   return MCELL_SUCCESS;
398 }
399 struct output_column *get_counter_trigger_column(MCELL_STATE *state,
400                                                  const char *counter_name,
401                                                  int column_id) {
402   struct sym_entry *counter_sym =
403       retrieve_sym(counter_name, state-&gt;counter_by_name);
404   if (counter_sym == NULL) {
405     mcell_log("Failed to retrieve symbol for counter %s.", counter_name);
406     return NULL;
407   }
408   struct output_set *counter = (struct output_set *)(counter_sym-&gt;value);
409   struct output_column *column = counter-&gt;column_head;
410   int count = 0;
411   while (count &lt; column_id &amp;&amp; column != NULL) {
412     count++;
413     column = column-&gt;next;
414   }
415   if (count != column_id || column == NULL) {
416     return NULL;
417   }
418   return column;
419 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chkpt.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;errno.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;signal.h&gt;
7 #include &lt;sys/stat.h&gt;
8 #include &lt;string.h&gt;
9 #include "mcell_structs.h"
10 #include "mcell_reactions.h"
11 #include "nfsim_func.h"
12 #include "logging.h"
13 #include "vol_util.h"
14 #include "chkpt.h"
15 #include "grid_util.h"
16 #include "count_util.h"
17 #include "react.h"
18 #include "strfunc.h"
19 #define CHECKPOINT_API 1
20 #define MCELL_BIG_ENDIAN 16
21 #define MCELL_LITTLE_ENDIAN 17
22 #define CURRENT_TIME_CMD 1
23 #define CURRENT_ITERATION_CMD 2
24 #define CHKPT_SEQ_NUM_CMD 3
25 #define RNG_STATE_CMD 4
26 #define MCELL_VERSION_CMD 5
27 #define SPECIES_TABLE_CMD 6
28 #define MOL_SCHEDULER_STATE_CMD 7
29 #define BYTE_ORDER_CMD 8
30 #define NUM_CHKPT_CMDS 9
31 #define CHECKPOINT_API_CMD 10
32 #define HAS_ACT_NEWBIE 1
33 #define HAS_NOT_ACT_NEWBIE 0
34 #define HAS_ACT_CHANGE 1
35 #define HAS_NOT_ACT_CHANGE 0
36 int *chkpt_continue_after_checkpoint;
37 const char **chkpt_initialization_state;
38 enum checkpoint_request_type_t *chkpt_checkpoint_requested;
39 #define DATACHECK(op, msg, ...)                                                \
40   do {                                                                         \
41     if (op) {                                                                  \
42       mcell_warn("Corrupted checkpoint data: " msg, ##__VA_ARGS__);            \
43       return 1;                                                                \
44     }                                                                          \
45   } while (0)
46 #define INTERNALCHECK(op, msg, ...)                                            \
47   do {                                                                         \
48     if (op) {                                                                  \
49       mcell_warn("%s internal: " msg, __func__, ##__VA_ARGS__);                \
50       return 1;                                                                \
51     }                                                                          \
52   } while (0)
53 #define WRITECHECK(op, sect)                                                   \
54   do {                                                                         \
55     if (op) {                                                                  \
56       mcell_perror_nodie(errno, "Error while writing '%s' to checkpoint file", \
57                          SECTNAME);                                            \
58       return 1;                                                                \
59     }                                                                          \
60   } while (0)
61 #define WRITEFIELD(f) WRITECHECK(fwrite(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)
62 #define WRITEARRAY(f, len)                                                     \
63   WRITECHECK(fwrite(f, sizeof(f[0]), (len), fs) != (len), SECTNAME)
64 #define WRITEUINT(f) WRITECHECK(write_varint(fs, (f)), SECTNAME)
65 #define WRITEINT(f) WRITECHECK(write_svarint(fs, (f)), SECTNAME)
66 #define WRITEUINT64(f) WRITECHECK(write_varintl(fs, (f)), SECTNAME)
67 #define WRITESTRING(f)                                                         \
68   do {                                                                         \
69     uint32_t len = (uint32_t)strlen(f);                                        \
70     WRITEUINT(len);                                                            \
71     WRITEARRAY(f, len);                                                        \
72   } while (0)
73 #define READCHECK(op, sect)                                                    \
74   do {                                                                         \
75     if (op) {                                                                  \
76       mcell_perror_nodie(                                                      \
77           errno, "Error while reading '%s' from checkpoint file", SECTNAME);   \
78       return 1;                                                                \
79     }                                                                          \
80   } while (0)
81 #define READFIELDRAW(f) READCHECK(fread(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)
82 #define READBSWAP(f)                                                           \
83   do {                                                                         \
84     if (state-&gt;byte_order_mismatch)                                            \
85       byte_swap(&amp;(f), sizeof(f));                                              \
86   } while (0)
87 #define READFIELD(f)                                                           \
88   do {                                                                         \
89     READFIELDRAW(f);                                                           \
90     READBSWAP(f);                                                              \
91   } while (0)
92 #define READSTRING(f, len)                                                     \
93   do {                                                                         \
94     READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
95     f[len] = '\0';                                                             \
96   } while (0)
97 #define READARRAY(f, len)                                                      \
98   do {                                                                         \
99     int i;                                                                     \
100     READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
101     for (i = 0; i &lt; len; ++i)                                                  \
102       READBSWAP(f[i]);                                                         \
103   } while (0)
104 #define READUINT(f) READCHECK(read_varint(fs, &amp;(f)), SECTNAME)
105 #define READINT(f) READCHECK(read_svarint(fs, &amp;(f)), SECTNAME)
106 #define READUINT64(f) READCHECK(read_varintl(fs, &amp;(f)), SECTNAME)
107 struct chkpt_read_state {
108   byte byte_order_mismatch;
109 };
110 static int read_current_time_seconds(struct volume *world, FILE *fs,
111 <a name="0"></a>                                     struct chkpt_read_state *state);
112 static int read_current_iteration(struct volume *world, FILE *fs,
113                                   struct chkpt_read_state *state);
114 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int read_chkpt_seq_num(struct volume *world, FILE *fs,
115                               struct chkpt_read_state *state);
116 static int read_rng_state(struct volume *world, FILE *fs,
117                           struct chkpt_read_state *state);
118 static int read_byte_order(FILE *fs, struct chkpt_read_state *state);
119 static int read_mcell_version(FILE *fs, struct chkpt_read_state *state);</b></font>
120 static int read_api_version(FILE *fs, struct chkpt_read_state *state,
121   uint32_t *api_version);
122 static int read_species_table(struct volume *world, FILE *fs);
123 static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
124                                          struct chkpt_read_state *state,
125                                          uint32_t api_version);
126 static int write_mcell_version(FILE *fs, const char *mcell_version);
127 static int write_current_time_seconds(FILE *fs, double current_time_seconds);
128 static int write_current_iteration(FILE *fs, long long current_iterations,
129                                    double current_time_seconds);
130 static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num);
131 static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng);
132 static int write_species_table(FILE *fs, int n_species,
133                                struct species **species_list);
134 static int write_mol_scheduler_state_real(FILE *fs,
135                                           struct storage_list *storage_head,
136                                           double simulation_start_seconds,
137                                           double start_iterations,
138                                           double time_unit);
139 static int write_byte_order(FILE *fs);
140 static int write_api_version(FILE *fs);
141 static int create_molecule_scheduler(struct storage_list *storage_head,
142                                      long long start_iterations);
143 int set_checkpoint_state(struct volume *world) {
144   chkpt_continue_after_checkpoint = &amp;world-&gt;continue_after_checkpoint;
145   chkpt_initialization_state = &amp;world-&gt;initialization_state;
146   chkpt_checkpoint_requested = &amp;world-&gt;checkpoint_requested;
147   return 0;
148 }
149 void chkpt_signal_handler(int signo) {
150   if (*chkpt_initialization_state) {
151     if (signo != SIGALRM || !*chkpt_continue_after_checkpoint) {
152       mcell_warn("Checkpoint requested while %s.  Exiting.",
153                  *chkpt_initialization_state);
154       exit(EXIT_FAILURE);
155     }
156   }
157 #ifndef _WIN64   if (signo == SIGUSR1)
158     *chkpt_checkpoint_requested = CHKPT_SIGNAL_CONT;
159   else if (signo == SIGUSR2)
160     *chkpt_checkpoint_requested = CHKPT_SIGNAL_EXIT;
161   else
162 #endif
163       if (signo == SIGALRM) {
164     if (*chkpt_continue_after_checkpoint)
165       *chkpt_checkpoint_requested = CHKPT_ALARM_CONT;
166     else
167       *chkpt_checkpoint_requested = CHKPT_ALARM_EXIT;
168   }
169 }
170 int create_chkpt(struct volume *world, char const *filename) {
171   FILE *outfs = NULL;
172   char *tmpname = alloc_sprintf("%s.tmp", filename);
173   if (tmpname == NULL)
174     mcell_allocfailed("Out of memory creating temporary checkpoint filename "
175                       "for checkpoint '%s'.",
176                       filename);
177   if ((outfs = fopen(tmpname, "wb")) == NULL)
178     mcell_perror(errno, "Failed to write checkpoint file '%s'", tmpname);
179   world-&gt;current_time_seconds = world-&gt;current_time_seconds +
180       (world-&gt;current_iterations - world-&gt;start_iterations) * world-&gt;time_unit;
181   world-&gt;start_iterations = world-&gt;current_iterations;
182   world-&gt;simulation_start_seconds = world-&gt;current_time_seconds;
183   if (write_chkpt(world, outfs))
184     mcell_error("Failed to write checkpoint file %s\n", filename);
185   fclose(outfs);
186   if (world-&gt;keep_chkpts) {
187     struct stat buf;
188     if (stat(filename, &amp;buf) == 0) {
189       char *keepName = alloc_sprintf("%s.%lld", filename, world-&gt;current_iterations);
190       if (keepName == NULL) {
191         mcell_allocfailed("Out of memory creating filename for checkpoint");
192       }
193       if (rename(filename, keepName) != 0) {
194         mcell_error("Failed to save previous checkpoint file %s to %s",
195                     filename, keepName);
196       }
197       free(keepName);
198     }
199   }
200   if (rename(tmpname, filename) != 0)
201     mcell_error("Successfully wrote checkpoint to file '%s', but failed to "
202                 "atomically replace checkpoint file '%s'.\nThe simulation may "
203                 "be resumed from '%s'.",
204                 tmpname, filename, tmpname);
205   free(tmpname);
206   return 0;
207 }
208 static int write_varintl(FILE *fs, unsigned long long val) {
209   unsigned char buffer[40];
210   size_t len = 0;
211   buffer[sizeof(buffer) - 1 - len] = val &amp; 0x7f;
212   val &gt;&gt;= 7;
213   ++len;
214   while (val != 0) {
215     buffer[sizeof(buffer) - 1 - len] = (val &amp; 0x7f) | 0x80;
216     val &gt;&gt;= 7;
217     ++len;
218   }
219   if (fwrite(buffer + sizeof(buffer) - len, 1, len, fs) != len)
220     return 1;
221   return 0;
222 }
223 static int write_svarintl(FILE *fs, long long val) {
224   if (val &lt; 0)
225     return write_varintl(fs, (unsigned long long)(((-val) &lt;&lt; 1) | 1));
226   else
227     return write_varintl(fs, (unsigned long long)(((val) &lt;&lt; 1)));
228 }
229 static int read_varintl(FILE *fs, unsigned long long *dest) {
230   unsigned long long accum = 0;
231   unsigned char ch;
232   do {
233     if (fread(&amp;ch, 1, 1, fs) != 1)
234       return 1;
235     accum &lt;&lt;= 7;
236     accum |= ch &amp; 0x7f;
237   } while (ch &amp; 0x80);
238   *dest = accum;
239   return 0;
240 }
241 static int read_svarintl(FILE *fs, long long *dest) {
242   unsigned long long tmp = 0;
243   if (read_varintl(fs, &amp;tmp))
244     return 1;
245   if (tmp &amp; 1)
246     *dest = (long long)-(tmp &gt;&gt; 1);
247   else
248     *dest = (long long)(tmp &gt;&gt; 1);
249   return 0;
250 }
251 static int write_varint(FILE *fs, unsigned int val) {
252   return write_varintl(fs, (unsigned long long)val);
253 }
254 static int write_svarint(FILE *fs, int val) {
255   return write_svarintl(fs, (long long)val);
256 }
257 static int read_varint(FILE *fs, unsigned int *dest) {
258   unsigned long long val;
259   if (read_varintl(fs, &amp;val))
260     return 1;
261   *dest = val;
262   if ((unsigned long long)*dest != val)
263     return 1;
264   return 0;
265 }
266 static int read_svarint(FILE *fs, int *dest) {
267   long long val;
268   if (read_svarintl(fs, &amp;val))
269     return 1;
270   *dest = val;
271   if ((long long)*dest != val)
272     return 1;
273   return 0;
274 }
275 int write_chkpt(struct volume *world, FILE *fs) {
276   return (write_byte_order(fs) ||
277           write_api_version(fs) ||
278           write_mcell_version(fs, world-&gt;mcell_version) ||
279           write_current_time_seconds(fs, world-&gt;current_time_seconds) ||
280           write_current_iteration(fs, world-&gt;current_iterations,
281                                   world-&gt;current_time_seconds) ||
282           write_chkpt_seq_num(fs, world-&gt;chkpt_seq_num) ||
283           write_rng_state(fs, world-&gt;seed_seq, world-&gt;rng) ||
284           write_species_table(fs, world-&gt;n_species, world-&gt;species_list) ||
285           write_mol_scheduler_state_real(fs, world-&gt;storage_head,
286               world-&gt;simulation_start_seconds, world-&gt;start_iterations,
287               world-&gt;time_unit));
288 }
289 static int read_preamble(FILE *fs, struct chkpt_read_state *state, uint32_t *api_version) {
290   byte cmd;
291   size_t count = fread(&amp;cmd, 1, sizeof(cmd), fs);
292   DATACHECK(feof(fs), "Checkpoint file is empty.");
293   if (count != sizeof(cmd)) {
294     return 1; 
295   }
296   DATACHECK(cmd != BYTE_ORDER_CMD,
297             "Checkpoint file does not have the required byte-order command.");
298   if (read_byte_order(fs, state))
299     return 1;
300   count = fread(&amp;cmd, 1, sizeof(cmd), fs);
301   DATACHECK(feof(fs), "Checkpoint file is too short (no api or version info).");
302   if (count != sizeof(cmd)) {
303     return 1; 
304   }
305   if (cmd != CHECKPOINT_API_CMD) {
306     *api_version = 0;
307   } else {
308     read_api_version(fs, state, api_version);
309     count = fread(&amp;cmd, 1, sizeof(cmd), fs);
310   }
311   DATACHECK(feof(fs), "Checkpoint file is too short (no version info).");
312   if (count != sizeof(cmd)) {
313     return 1; 
314   }
315   DATACHECK(cmd != MCELL_VERSION_CMD,
316             "Checkpoint file does not contain required MCell version command.");
317   return read_mcell_version(fs, state);
318 }
319 int read_chkpt(struct volume *world, FILE *fs, bool only_time_and_iter) {
320   byte cmd;
321   int seen_section[NUM_CHKPT_CMDS];
322   memset(seen_section, 0, sizeof(int)*NUM_CHKPT_CMDS);
323   struct chkpt_read_state state;
324   state.byte_order_mismatch = 0;
325   uint32_t api_version;
326   if (read_preamble(fs, &amp;state, &amp;api_version))
327     return 1;
328   seen_section[BYTE_ORDER_CMD] = 1;
329   seen_section[MCELL_VERSION_CMD] = 1;
330   bool time_read = false;
331   bool iteration_read = false;
332   while (1) {
333     size_t count = fread(&amp;cmd, sizeof(cmd), 1, fs);
334     if (feof(fs)) {
335       break;
336     }
337     if (count != sizeof(cmd)) {
338       return 1; 
339     }
340     DATACHECK(cmd &lt; 1 || cmd &gt;= NUM_CHKPT_CMDS,
341               "Unrecognized command-type in checkpoint file.  "
342               "Checkpoint file cannot be loaded.");
343     DATACHECK(seen_section[cmd], "Duplicate command-type in checkpoint file.");
344     seen_section[cmd] = 1;
345     switch (cmd) {
346     case CURRENT_TIME_CMD:
347       if (read_current_time_seconds(world, fs, &amp;state)) {
348         return 1;
349       }
350       time_read = true;
351       if (only_time_and_iter &amp;&amp; iteration_read) {
352         return 0;
353       }
354       break;
355     case CURRENT_ITERATION_CMD:
356       if (read_current_iteration(world, fs, &amp;state)) {
357         return 1;
358       }
359       iteration_read = true;
360       if (only_time_and_iter &amp;&amp; time_read) {
361         return 0;
362       }
363       if (!only_time_and_iter) {
364         if (create_molecule_scheduler(world-&gt;storage_head, world-&gt;start_iterations)) {
365           return 1;
366         }
367       }
368       break;
369     case CHKPT_SEQ_NUM_CMD:
370       if (read_chkpt_seq_num(world, fs, &amp;state))
371         return 1;
372       break;
373     case RNG_STATE_CMD:
374       if (read_rng_state(world, fs, &amp;state))
375         return 1;
376       break;
377     case SPECIES_TABLE_CMD:
378       if (read_species_table(world, fs))
379         return 1;
380       break;
381     case MOL_SCHEDULER_STATE_CMD:
382       DATACHECK(
383           !seen_section[CURRENT_ITERATION_CMD],
384           "Current iteration command must precede molecule scheduler command.");
385       DATACHECK(
386           !seen_section[SPECIES_TABLE_CMD],
387           "Species table command must precede molecule scheduler command.");
388       if (read_mol_scheduler_state_real(world, fs, &amp;state, api_version))
389         return 1;
390       break;
391     case BYTE_ORDER_CMD:
392     case MCELL_VERSION_CMD:
393     default:
394       assert(0);
395       break;
396     }
397   }
398   DATACHECK(!seen_section[CURRENT_TIME_CMD],
399             "Current time command is not present.");
400   DATACHECK(!seen_section[CHKPT_SEQ_NUM_CMD],
401             "Checkpoint sequence number command is not present.");
402   DATACHECK(!seen_section[RNG_STATE_CMD], "RNG state command is not present.");
403   DATACHECK(!seen_section[MOL_SCHEDULER_STATE_CMD],
404             " Molecule scheduler state command is not present.");
405   return 0;
406 }
407 static int write_byte_order(FILE *fs) {
408   static const char SECTNAME[] = "byte order";
409   static const byte cmd = BYTE_ORDER_CMD;
410 #ifdef WORDS_BIGENDIAN
411   static const unsigned int byte_order = MCELL_BIG_ENDIAN;
412 #else
413   static const unsigned int byte_order = MCELL_LITTLE_ENDIAN;
414 #endif
415   WRITEFIELD(cmd);
416   WRITEFIELD(byte_order);
417   return 0;
418 }
419 static int read_byte_order(FILE *fs, struct chkpt_read_state *state) {
420   static const char SECTNAME[] = "byte order";
421 #ifdef WORDS_BIGENDIAN
422   static const unsigned int byte_order_present = MCELL_BIG_ENDIAN;
423 #else
424   static const unsigned int byte_order_present = MCELL_LITTLE_ENDIAN;
425 #endif
426   unsigned int byte_order_read;
427   READFIELDRAW(byte_order_read);
428   state-&gt;byte_order_mismatch = (byte_order_read != byte_order_present);
429   return 0;
430 }
431 static int write_api_version(FILE *fs) {
432   static const char SECTNAME[] = "api version";
433   static const byte cmd = CHECKPOINT_API_CMD;
434   uint32_t api_version = CHECKPOINT_API;
435   WRITEFIELD(cmd);
436   WRITEFIELD(api_version);
437   return 0;
438 }
439 static int read_api_version(FILE *fs, struct chkpt_read_state *state,
440   uint32_t *api_version) {
441   static const char SECTNAME[] = "api version";
442   READFIELD(*api_version);
443   return 0;
444 }
445 static int write_mcell_version(FILE *fs, const char *mcell_version) {
446   static const char SECTNAME[] = "MCell version";
447   static const byte cmd = MCELL_VERSION_CMD;
448   uint32_t len = (uint32_t)strlen(mcell_version);
449   WRITEFIELD(cmd);
450   WRITEFIELD(len);
451   WRITEARRAY(mcell_version, len);
452   return 0;
453 }
454 static int read_mcell_version(FILE *fs, struct chkpt_read_state *state) {
455   static const char SECTNAME[] = "MCell version";
456   unsigned int version_length;
457   READFIELD(version_length);
458   DATACHECK(version_length &gt;= 100000,
459             "Length field for MCell version is too long (%u).", version_length);
460   char* mcell_version = new char[version_length + 1];
461   READSTRING(mcell_version, version_length);
462   mcell_log("Checkpoint file was created with MCell Version %s.",
463             mcell_version);
464   delete mcell_version;
465   return 0;
466 }
467 static int write_current_time_seconds(FILE *fs, double current_time_seconds) {
468   static const char SECTNAME[] = "current real time";
469   static const byte cmd = CURRENT_TIME_CMD;
470   WRITEFIELD(cmd);
471   WRITEFIELD(current_time_seconds);
472   return 0;
473 }
474 static int read_current_time_seconds(struct volume *world, FILE *fs,
475                                   struct chkpt_read_state *state) {
476   static const char SECTNAME[] = "current real time";
477   READFIELD(world-&gt;simulation_start_seconds);
478   return 0;
479 }
480 static int create_molecule_scheduler(struct storage_list *storage_head,
481                                      long long start_iterations) {
482   struct storage_list *stg;
483   for (stg = storage_head; stg != NULL; stg = stg-&gt;next) {
484     if ((stg-&gt;store-&gt;timer = create_scheduler(1.0, 100.0, 100, start_iterations)) ==
485         NULL) {
486       mcell_error("Out of memory while creating molecule scheduler.");
487     }
488     stg-&gt;store-&gt;current_time = start_iterations;
489   }
490   return 0;
491 }
492 static int write_current_iteration(FILE *fs, long long current_iterations,
493                                    double current_time_seconds) {
494   static const char SECTNAME[] = "current iteration";
495   static const byte cmd = CURRENT_ITERATION_CMD;
496   WRITEFIELD(cmd);
497   WRITEFIELD(current_iterations);
498   WRITEFIELD(current_time_seconds);
499   return 0;
500 }
501 static int read_current_iteration(struct volume *world, FILE *fs,
502                                   struct chkpt_read_state *state) {
503   static const char SECTNAME[] = "current iteration";
504   READFIELD(world-&gt;start_iterations);
505   READFIELD(world-&gt;chkpt_start_time_seconds);
506   world-&gt;current_time_seconds = world-&gt;chkpt_start_time_seconds;
507   return 0;
508 }
509 static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num) {
510   static const char SECTNAME[] = "checkpoint sequence number";
511   static const byte cmd = CHKPT_SEQ_NUM_CMD;
512   WRITEFIELD(cmd);
513   WRITEFIELD(chkpt_seq_num);
514   return 0;
515 }
516 static int read_chkpt_seq_num(struct volume *world, FILE *fs,
517                               struct chkpt_read_state *state) {
518   static const char SECTNAME[] = "checkpoint sequence number";
519   READFIELD(world-&gt;chkpt_seq_num);
520   ++world-&gt;chkpt_seq_num;
521   return 0;
522 }
523 static int write_an_rng_state(FILE *fs, struct rng_state *rng) {
524   static const char SECTNAME[] = "RNG state";
525 #ifdef USE_MINIMAL_RNG
526   static const char RNG_MINRNG = 'M';
527   WRITEFIELD(RNG_MINRNG);
528   WRITEFIELD(rng-&gt;a);
529   WRITEFIELD(rng-&gt;b);
530   WRITEFIELD(rng-&gt;c);
531   WRITEFIELD(rng-&gt;d);
532 #else
533   static const char RNG_ISAAC = 'I';
534   WRITEFIELD(RNG_ISAAC);
535   WRITEUINT(rng-&gt;randcnt);
536   WRITEFIELD(rng-&gt;aa);
537   WRITEFIELD(rng-&gt;bb);
538   WRITEFIELD(rng-&gt;cc);
539   WRITEARRAY(rng-&gt;randrsl, RANDSIZ);
540   WRITEARRAY(rng-&gt;mm, RANDSIZ);
541 #endif
542   return 0;
543 }
544 static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng) {
545   static const char SECTNAME[] = "RNG state";
546   static const byte cmd = RNG_STATE_CMD;
547   WRITEFIELD(cmd);
548   WRITEUINT(seed_seq);
549   if (write_an_rng_state(fs, rng))
550     return 1;
551   return 0;
552 }
553 static int read_an_rng_state(FILE *fs, struct chkpt_read_state *state,
554                              struct rng_state *rng) {
555   static const char SECTNAME[] = "RNG state";
556 #ifdef USE_MINIMAL_RNG
557   static const char RNG_MINRNG = 'M';
558   char rngtype;
559   READFIELD(rngtype);
560   DATACHECK(rngtype != RNG_MINRNG, "Invalid RNG type stored in checkpoint file "
561                                    "(in this version of MCell, only Bob "
562                                    "Jenkins' \"small PRNG\" is supported).");
563   READFIELD(rng-&gt;a);
564   READFIELD(rng-&gt;b);
565   READFIELD(rng-&gt;c);
566   READFIELD(rng-&gt;d);
567 #else
568   static const char RNG_ISAAC = 'I';
569   char rngtype;
570   READFIELD(rngtype);
571   DATACHECK(rngtype != RNG_ISAAC, "Invalid RNG type stored in checkpoint file "
572                                   "(in this version of MCell, only ISAAC64 is "
573                                   "supported).");
574   READUINT(rng-&gt;randcnt);
575   READFIELD(rng-&gt;aa);
576   READFIELD(rng-&gt;bb);
577   READFIELD(rng-&gt;cc);
578   READARRAY(rng-&gt;randrsl, RANDSIZ);
579   READARRAY(rng-&gt;mm, RANDSIZ);
580   rng-&gt;rngblocks = 1;
581 #endif
582   return 0;
583 }
584 static int read_rng_state(struct volume *world, FILE *fs,
585                           struct chkpt_read_state *state) {
586   static const char SECTNAME[] = "RNG state";
587   unsigned int old_seed;
588   READUINT(old_seed);
589   if (read_an_rng_state(fs, state, world-&gt;rng))
590     return 1;
591   if (world-&gt;seed_seq != old_seed)
592     rng_init(world-&gt;rng, world-&gt;seed_seq);
593   return 0;
594 }
595 static int write_species_table(FILE *fs, int n_species,
596                                struct species **species_list) {
597   static const char SECTNAME[] = "species table";
598   static const byte cmd = SPECIES_TABLE_CMD;
599   WRITEFIELD(cmd);
600   unsigned int non_empty_species_count = 0;
601   int i;
602   for (i = 0; i &lt; n_species; i++) {
603     if (species_list[i]-&gt;population &gt; 0)
604       ++non_empty_species_count;
605   }
606   WRITEUINT(non_empty_species_count);
607   unsigned int external_species_id = 0;
608   for (i = 0; i &lt; n_species; i++) {
609     if (species_list[i]-&gt;population == 0)
610       continue;
611     WRITESTRING(species_list[i]-&gt;sym-&gt;name);
612     WRITEUINT(external_species_id);
613     species_list[i]-&gt;chkpt_species_id = external_species_id++;
614   }
615   return 0;
616 }
617 static int read_species_table(struct volume *world, FILE *fs) {
618   static const char SECTNAME[] = "species table";
619   unsigned int total_species;
620   READUINT(total_species);
621   for (unsigned int i = 0; i &lt; total_species; i++) {
622     unsigned int species_name_length;
623     READUINT(species_name_length);
624     DATACHECK(
625         species_name_length &gt;= 100000,
626         "Species table has species name greater than 100000 characters (%u).",
627         species_name_length);
628     char* species_name = new char[species_name_length + 1];
629     unsigned int external_species_id;
630     READSTRING(species_name, species_name_length);
631     READUINT(external_species_id);
632     int j;
633     for (j = 0; j &lt; world-&gt;n_species; j++) {
634       if ((strcmp(world-&gt;species_list[j]-&gt;sym-&gt;name, species_name) == 0)) {
635         world-&gt;species_list[j]-&gt;chkpt_species_id = external_species_id;
636         break;
637       }
638     }
639     DATACHECK(j == world-&gt;n_species, "Checkpoint file contains data for "
640                                      "species '%s', which does not exist in "
641                                      "this simulation.",
642               species_name);
643     delete species_name;
644   }
645   return 0;
646 }
647 unsigned long long
648 count_items_in_scheduler(struct storage_list *storage_head) {
649   unsigned long long total_items = 0;
650   for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
651     for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
652          shp = shp-&gt;next_scale) {
653       for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
654         for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
655                                                     : shp-&gt;circ_buf_head[i];
656              aep != NULL; aep = aep-&gt;next) {
657           struct abstract_molecule *amp = (struct abstract_molecule *)aep;
658           if (amp-&gt;properties == NULL)
659             continue;
660           assert(!(amp-&gt;properties-&gt;flags &amp; IS_SURFACE));
661           ++total_items;
662         }
663       }
664     }
665   }
666   return total_items;
667 }
668 static int write_mol_scheduler_state_real(FILE *fs,
669                                           struct storage_list *storage_head,
670                                           double simulation_start_seconds,
671                                           double start_iterations,
672                                           double time_unit) {
673   static const char SECTNAME[] = "molecule scheduler state";
674   static const byte cmd = MOL_SCHEDULER_STATE_CMD;
675   WRITEFIELD(cmd);
676   unsigned long long total_items = count_items_in_scheduler(storage_head);
677   WRITEUINT64(total_items);
678   for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
679     for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
680          shp = shp-&gt;next_scale) {
681       for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
682         for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
683                                                     : shp-&gt;circ_buf_head[i];
684              aep != NULL; aep = aep-&gt;next) {
685           struct abstract_molecule *amp = (struct abstract_molecule *)aep;
686           if (amp-&gt;properties == NULL)
687             continue;
688           struct vector3 where;
689           short orient = 0;
690           byte act_newbie_flag =
691               (amp-&gt;flags &amp; ACT_NEWBIE) ? HAS_ACT_NEWBIE : HAS_NOT_ACT_NEWBIE;
692           byte act_change_flag =
693               (amp-&gt;flags &amp; ACT_CHANGE) ? HAS_ACT_CHANGE : HAS_NOT_ACT_CHANGE;
694           if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
695             struct volume_molecule *vmp = (struct volume_molecule *)amp;
696             INTERNALCHECK(vmp-&gt;previous_wall != NULL &amp;&amp; vmp-&gt;index &gt;= 0,
697                           "The value of 'previous_grid' is not NULL.");
698             where.x = vmp-&gt;pos.x;
699             where.y = vmp-&gt;pos.y;
700             where.z = vmp-&gt;pos.z;
701             orient = 0;
702           } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
703             struct surface_molecule *smp = (struct surface_molecule *)amp;
704             uv2xyz(&amp;smp-&gt;s_pos, smp-&gt;grid-&gt;surface, &amp;where);
705             orient = smp-&gt;orient;
706           } else
707             continue;
708           INTERNALCHECK(amp-&gt;properties-&gt;chkpt_species_id == UINT_MAX,
709                         "Attempted to write out a molecule of species '%s', "
710                         "which has not been assigned a checkpoint species id.",
711                         amp-&gt;properties-&gt;sym-&gt;name);
712           WRITEUINT(amp-&gt;properties-&gt;chkpt_species_id);
713           WRITEFIELD(act_newbie_flag);
714           WRITEFIELD(act_change_flag);
715           double t = convert_iterations_to_seconds(
716               start_iterations, time_unit, simulation_start_seconds, amp-&gt;t);
717           WRITEFIELD(t);
718           double t2 = amp-&gt;t2 * time_unit;
719           WRITEFIELD(t2);
720           double bday = amp-&gt;birthday;
721           WRITEFIELD(bday);
722           WRITEFIELD(where);
723           WRITEINT(orient);
724           static const unsigned char NON_COMPLEX = '\0';
725           WRITEFIELD(NON_COMPLEX);
726         }
727       }
728     }
729   }
730   return 0;
731 }
732 static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
733                                          struct chkpt_read_state *state,
734                                          uint32_t api_version) {
735   static const char SECTNAME[] = "molecule scheduler state";
736   struct volume_molecule vm;
737   struct volume_molecule *vmp = NULL;
738   struct abstract_molecule *amp = NULL;
739   struct volume_molecule *guess = NULL;
740   memset(&amp;vm, 0, sizeof(struct volume_molecule));
741   vmp = &amp;vm;
742   amp = (struct abstract_molecule *)vmp;
743   unsigned long long total_items;
744   READUINT64(total_items);
745   for (unsigned long long n_mol = 0; n_mol &lt; total_items; n_mol++) {
746     unsigned int external_species_id;
747     byte act_newbie_flag;
748     byte act_change_flag;
749     double sched_time;
750     double lifetime;
751     double birthday;
752     double x_coord, y_coord, z_coord;
753     int orient;
754     READUINT(external_species_id);
755     READFIELDRAW(act_newbie_flag);
756     READFIELDRAW(act_change_flag);
757     READFIELD(sched_time);
758     READFIELD(lifetime);
759     READFIELD(birthday);
760     READFIELD(x_coord);
761     READFIELD(y_coord);
762     READFIELD(z_coord);
763     READINT(orient);
764     if (api_version &gt;= 1) {
765       lifetime = 0;
766       sched_time = world-&gt;start_iterations;
767       act_change_flag = HAS_ACT_CHANGE;
768     }
769     unsigned int complex_no = 0;
770     READUINT(complex_no);
771     struct species *properties = NULL;
772     for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
773       if (world-&gt;species_list[species_idx]-&gt;chkpt_species_id ==
774           external_species_id) {
775         properties = world-&gt;species_list[species_idx];
776         break;
777       }
778     }
779     DATACHECK(properties == NULL,
780               "Found molecule with unknown species id (%d).",
781               external_species_id);
782     struct periodic_image periodic_box = {  0, 0, 0 };
783     if ((properties-&gt;flags &amp; NOT_FREE) == 0) { 
784       amp-&gt;t = sched_time;
785       amp-&gt;t2 = lifetime;
786       amp-&gt;birthday = birthday;
787       amp-&gt;properties = properties;
788       initialize_diffusion_function(amp);
789       if(amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES)
790         properties_nfsim(world, amp);
791       vmp-&gt;previous_wall = NULL;
792       vmp-&gt;index = -1;
793       vmp-&gt;pos.x = x_coord;
794       vmp-&gt;pos.y = y_coord;
795       vmp-&gt;pos.z = z_coord;
796       amp-&gt;periodic_box = &amp;periodic_box;
797       amp-&gt;flags = TYPE_VOL | IN_VOLUME;
798       if (act_newbie_flag == HAS_ACT_NEWBIE)
799         amp-&gt;flags |= ACT_NEWBIE;
800       if (act_change_flag == HAS_ACT_CHANGE)
801         amp-&gt;flags |= ACT_CHANGE;
802       amp-&gt;flags |= IN_SCHEDULE;
803       if ((amp-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0 ||
804           trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
805                                amp-&gt;properties-&gt;hashval, amp) != NULL)
806         amp-&gt;flags |= ACT_REACT;
807       if (amp-&gt;get_space_step(amp) &gt; 0.0)
808         amp-&gt;flags |= ACT_DIFFUSE;
809       guess = insert_volume_molecule(world, vmp, guess);
810       if (guess == NULL) {
811         mcell_error("Cannot insert copy of molecule of species '%s' into "
812                     "world.\nThis may be caused by a shortage of memory.",
813                     vmp-&gt;properties-&gt;sym-&gt;name);
814       }
815     } else {       struct vector3 where;
816       where.x = x_coord;
817       where.y = y_coord;
818       where.z = z_coord;
819       struct surface_molecule *smp = insert_surface_molecule(
820           world, properties, &amp;where, orient, CHKPT_GRID_TOLERANCE, sched_time,
821           NULL, NULL, NULL, &amp;periodic_box);
822       if (smp == NULL) {
823         mcell_warn("Could not place molecule %s at (%f,%f,%f).",
824                    properties-&gt;sym-&gt;name, where.x * world-&gt;length_unit,
825                    where.y * world-&gt;length_unit,
826                    where.z * world-&gt;length_unit);
827         continue;
828       }
829       smp-&gt;t2 = lifetime;
830       smp-&gt;birthday = birthday;
831       if (act_newbie_flag == HAS_NOT_ACT_NEWBIE)
832         smp-&gt;flags &amp;= ~ACT_NEWBIE;
833       if (act_change_flag == HAS_ACT_CHANGE) {
834         smp-&gt;flags |= ACT_CHANGE;
835       }
836     }
837   }
838   return 0;
839 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
