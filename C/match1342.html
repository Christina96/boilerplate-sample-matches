<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mcell_react_out.c &amp; chkpt.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mcell_react_out.c &amp; chkpt.c
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mcell_react_out.c (2.097902%)<th>chkpt.c (1.182266%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(39-50)<td><a href="#" name="0">(202-207)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_react_out.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "sym_table.h"
#include "logging.h"
#include "react_output.h"
#include "mcell_misc.h"
#include "mcell_react_out.h"
#include "mdlparse_util.h"
#include "dyngeom_parse_extras.h"
#include "strfunc.h"
#include "count_util.h"
static struct output_column *new_output_column(void);
static struct output_block *new_output_block(int buffersize);
static void set_reaction_output_timer_step(MCELL_STATE *state,
<a name="0"></a>                                           struct output_block *obp,
                                           double step);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static int
set_reaction_output_timer_iterations(MCELL_STATE *state,
                                     struct output_block *obp,
                                     struct num_expr_list_head *step_values);
static int
set_reaction_output_timer_times(MCELL_STATE *state, struct output_block *obp,
                                struct num_expr_list_head *step_values);
static int output_block_finalize(struct output_block *obp);
static long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,</b></font>
                                  long long n_output);
static struct output_column *
get_counter_trigger_column(MCELL_STATE *state, const char *counter_name,
                           int column_id);
int mcell_get_count(char *mol_name, char *reg_name, struct volume *world) {
  struct sym_entry *mol_sym = NULL;  
  mol_sym = retrieve_sym(mol_name, world-&gt;mol_sym_table);
  if (mol_sym == NULL)
    return -5;
  struct species *mol = (struct species *)mol_sym-&gt;value;
  u_int mol_hashval = mol-&gt;hashval;
  struct sym_entry *reg_sym = NULL;  
  reg_sym = retrieve_sym(reg_name, world-&gt;reg_sym_table);
  if (reg_sym == NULL)
    return -6;  
  struct region *reg = (struct region *)reg_sym-&gt;value;
  u_int reg_hashval = reg-&gt; hashval;
  int hash_bin = (mol_hashval + reg_hashval) &amp; world-&gt;count_hashmask;
  if (world-&gt;count_hash[hash_bin] == NULL)
    return -7;
  int mol_count_vol = world-&gt;count_hash[hash_bin]-&gt;data.move.n_enclosed;
  int mol_count_sur = world-&gt;count_hash[hash_bin]-&gt;data.move.n_at;
  return mol_count_vol + mol_count_sur;
}
struct output_request *mcell_new_output_request(MCELL_STATE *state,
                                                struct sym_entry *target,
                                                short orientation,
                                                struct sym_entry *location,
                                                struct periodic_image *img,
                                                int report_flags) {
  struct output_request *orq;
  struct output_expression *oe;
  orq = (struct output_request *)CHECKED_MEM_GET(state-&gt;outp_request_mem, "count request");
  if (orq == NULL)
    return NULL;
  oe = new_output_expr(state-&gt;oexpr_mem);
  if (oe == NULL) {
    mem_put(state-&gt;outp_request_mem, orq);
    mcell_allocfailed("Failed to allocate a count expression.");
    return NULL;
  }
  orq-&gt;next = NULL;
  orq-&gt;requester = oe;
  orq-&gt;count_target = target;
  orq-&gt;count_orientation = orientation;
  orq-&gt;count_location = location;
  orq-&gt;report_type = report_flags;
  orq-&gt;periodic_box = img;
  oe-&gt;left = orq;
  oe-&gt;oper = '#';
  oe-&gt;expr_flags = OEXPR_LEFT_REQUEST;
  struct sym_entry *sym = NULL;
  if (location) {
    char *name = location-&gt;name;
    if (strchr(location-&gt;name, ',')) {
      sym = retrieve_sym(name, state-&gt;reg_sym_table);
    }
    else {
      sym = retrieve_sym(name, state-&gt;obj_sym_table);
    }
  }
  if (sym &amp;&amp; !(is_object_instantiated(sym, state-&gt;root_instance))) 
    oe-&gt;expr_flags = OEXPR_TYPE_UNDEF;
  else if (orq-&gt;report_type &amp; REPORT_TRIGGER)
    oe-&gt;expr_flags |= OEXPR_TYPE_TRIG;
  else if ((orq-&gt;report_type &amp; REPORT_TYPE_MASK) != REPORT_CONTENTS)
    oe-&gt;expr_flags |= OEXPR_TYPE_DBL;
  else
    oe-&gt;expr_flags |= OEXPR_TYPE_INT;
  return orq;
}
MCELL_STATUS
mcell_create_count(MCELL_STATE *state, struct sym_entry *target,
                   short orientation, struct sym_entry *location,
                   int report_flags, char *custom_header,
                   struct output_column_list *count_list) {
  struct output_request *output_A = NULL;
  if ((output_A = mcell_new_output_request(state, target, orientation, location,
    NULL, report_flags)) == NULL) {
    return MCELL_FAIL;
  }
  output_A-&gt;next = state-&gt;output_request_head;
  state-&gt;output_request_head = output_A;
  return mcell_prepare_single_count_expr(count_list, output_A-&gt;requester,
                                         custom_header);
}
struct output_set *mcell_create_new_output_set(const char *comment, int exact_time,
                                               struct output_column *col_head,
                                               int file_flags,
                                               const char *outfile_name) {
  struct output_set *os =
      CHECKED_MALLOC_STRUCT(struct output_set, "reaction data output set");
  if (os == NULL) {
    return NULL;
  }
  os-&gt;outfile_name = CHECKED_STRDUP(outfile_name, "count outfile_name");
  os-&gt;file_flags = (enum overwrite_policy_t)file_flags;
  os-&gt;exact_time_flag = exact_time;
  os-&gt;chunk_count = 0;
  os-&gt;block = NULL;
  os-&gt;next = NULL;
  struct output_column *oc = col_head;
  os-&gt;column_head = oc;
  if (comment == NULL)
    os-&gt;header_comment = NULL;
  else if (comment[0] == '\0')
    os-&gt;header_comment = "";
  else {
    os-&gt;header_comment = strdup(comment);
    if (os-&gt;header_comment == NULL) {
      free(os);
      return NULL;
    }
  }
  for (; oc != NULL; oc = oc-&gt;next)
    oc-&gt;set = os;
  if (check_reaction_output_file(os)) {
    free(os);
    return NULL;
  }
  return os;
}
MCELL_STATUS
mcell_prepare_single_count_expr(struct output_column_list *list,
                                struct output_expression *expr,
                                char *custom_header) {
  list-&gt;column_head = NULL;
  list-&gt;column_tail = NULL;
  if (custom_header != NULL) {
    expr-&gt;title = custom_header;
  }
  struct output_expression *oe;
  struct output_column *oc;
  for (oe = first_oexpr_tree(expr); oe != NULL; oe = next_oexpr_tree(oe)) {
    if ((oc = new_output_column()) == NULL)
      return MCELL_FAIL;
    if (!list-&gt;column_head)
      list-&gt;column_head = list-&gt;column_tail = oc;
    else
      list-&gt;column_tail = list-&gt;column_tail-&gt;next = oc;
    oc-&gt;expr = oe;
    set_oexpr_column(oe, oc);
  }
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_add_reaction_output_block(MCELL_STATE *state,
                                struct output_set_list *osets, int buffer_size,
                                struct output_times_inlist *otimes) {
  struct output_block *obp;
  struct output_set *os;
  if ((obp = new_output_block(buffer_size)) == NULL)
    return 1;
  if (otimes-&gt;type == OUTPUT_BY_STEP)
    set_reaction_output_timer_step(state, obp, otimes-&gt;step);
  else if (otimes-&gt;type == OUTPUT_BY_ITERATION_LIST) {
    if (set_reaction_output_timer_iterations(state, obp, &amp;otimes-&gt;values)) {
      free(obp);
      return MCELL_FAIL;
    }
  } else if (otimes-&gt;type == OUTPUT_BY_TIME_LIST) {
    if (set_reaction_output_timer_times(state, obp, &amp;otimes-&gt;values)) {
      free(obp);
      return MCELL_FAIL;
    }
  } else {
    mcell_error("Internal error: Invalid output timer def (%d)", otimes-&gt;type);
    free(obp);
    return MCELL_FAIL;
  }
  obp-&gt;data_set_head = osets-&gt;set_head;
  for (os = obp-&gt;data_set_head; os != NULL; os = os-&gt;next)
    os-&gt;block = obp;
  if (output_block_finalize(obp))
    return 1;
  obp-&gt;next = state-&gt;output_block_head;
  state-&gt;output_block_head = obp;
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_get_counter_value(MCELL_STATE *state,
                        const char *counter_name,
                        int column_id,
                        double *count_data,
                        enum count_type_t *count_data_type) {
  struct output_column *column = NULL;
  if ((column = get_counter_trigger_column(state, counter_name, column_id)) ==
      NULL) {
    return MCELL_FAIL;
  }
  if (column-&gt;buffer[0].data_type == COUNT_TRIG_STRUCT) {
    return MCELL_FAIL;
  }
  eval_oexpr_tree(column-&gt;expr, 1);
  *count_data = (double)column-&gt;expr-&gt;value;
  *count_data_type = column-&gt;buffer[0].data_type;
  return MCELL_SUCCESS;
}
struct output_column *new_output_column() {
  struct output_column *oc;
  oc = CHECKED_MALLOC_STRUCT(struct output_column,
                             "reaction data output column");
  if (oc == NULL)
    return NULL;
  oc-&gt;initial_value = 0.0;
  oc-&gt;buffer = NULL;
  oc-&gt;expr = NULL;
  oc-&gt;next = NULL;
  return oc;
}
struct output_block *new_output_block(int buffersize) {
  struct output_block *obp;
  obp =
      CHECKED_MALLOC_STRUCT(struct output_block, "reaction data output block");
  if (obp == NULL)
    return NULL;
  obp-&gt;t = 0.0;
  obp-&gt;timer_type = OUTPUT_BY_STEP;
  obp-&gt;step_time = FOREVER;
  obp-&gt;time_list_head = NULL;
  obp-&gt;time_now = NULL;
  obp-&gt;buffersize = 0;
  obp-&gt;trig_bufsize = 0;
  obp-&gt;buf_index = 0;
  obp-&gt;data_set_head = NULL;
  obp-&gt;buffersize = buffersize;
  obp-&gt;trig_bufsize = obp-&gt;buffersize;
  obp-&gt;time_array = CHECKED_MALLOC_ARRAY(double, obp-&gt;buffersize,
                                         "reaction data output times array");
  if (obp-&gt;time_array == NULL) {
    free(obp);
    return NULL;
  }
  return obp;
}
void set_reaction_output_timer_step(MCELL_STATE *state,
                                    struct output_block *obp, double step) {
  long long output_freq;
  obp-&gt;timer_type = OUTPUT_BY_STEP;
  obp-&gt;step_time = step;
  output_freq = (long long)(obp-&gt;step_time / state-&gt;time_unit);
  if (output_freq &gt; state-&gt;iterations &amp;&amp; output_freq &gt; 1) {
    output_freq = (state-&gt;iterations &gt; 1) ? state-&gt;iterations : 1;
    obp-&gt;step_time = output_freq * state-&gt;time_unit;
    if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
      mcell_warn("output step time too long.\n  Setting output step time to "
                 "%g seconds.", obp-&gt;step_time);
  } else if (output_freq &lt; 1) {
    output_freq = 1;
    obp-&gt;step_time = output_freq * state-&gt;time_unit;
    if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
      mcell_warn("output step time too short.\n  Setting output step time to "
                 "%g seconds.", obp-&gt;step_time);
  }
  long long n_output;
  if (state-&gt;chkpt_iterations)
    n_output = (long long)(state-&gt;chkpt_iterations / output_freq + 1);
  else
    n_output = (long long)(state-&gt;iterations / output_freq + 1);
  obp-&gt;buffersize = pick_buffer_size(state, obp, n_output);
  no_printf("Default output step time definition:\n");
  no_printf("  output step time = %g\n", obp-&gt;step_time);
  no_printf("  output buffersize = %u\n", obp-&gt;buffersize);
}
long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,
                           long long n_output) {
  if (state-&gt;chkpt_iterations)
    return min3ll(state-&gt;chkpt_iterations - state-&gt;start_iterations + 1, n_output,
                  obp-&gt;buffersize);
  else
    return min3ll(state-&gt;iterations - state-&gt;start_iterations + 1, n_output,
                  obp-&gt;buffersize);
}
int
set_reaction_output_timer_iterations(MCELL_STATE *state,
                                     struct output_block *obp,
                                     struct num_expr_list_head *step_values) {
  obp-&gt;timer_type = OUTPUT_BY_ITERATION_LIST;
  obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
  if (step_values-&gt;shared) {
    obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
    if (obp-&gt;time_list_head == NULL)
      return 1;
  } else {
    mcell_sort_numeric_list(step_values-&gt;value_head);
    obp-&gt;time_list_head = step_values-&gt;value_head;
  }
  obp-&gt;time_now = NULL;
  return 0;
}
int set_reaction_output_timer_times(MCELL_STATE *state,
                                    struct output_block *obp,
                                    struct num_expr_list_head *step_values) {
  obp-&gt;timer_type = OUTPUT_BY_TIME_LIST;
  obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
  if (step_values-&gt;shared) {
    obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
    if (obp-&gt;time_list_head == NULL)
      return 1;
  } else {
    mcell_sort_numeric_list(step_values-&gt;value_head);
    obp-&gt;time_list_head = step_values-&gt;value_head;
  }
  obp-&gt;time_now = NULL;
  return 0;
}
int output_block_finalize(struct output_block *obp) {
  struct output_set *os1;
  for (os1 = obp-&gt;data_set_head; os1 != NULL; os1 = os1-&gt;next) {
    struct output_set *os2;
    for (os2 = os1-&gt;next; os2 != NULL; os2 = os2-&gt;next) {
      if (strcmp(os1-&gt;outfile_name, os2-&gt;outfile_name) == 0) {
        mcell_error("COUNT statements in the same reaction data "
                    "output block should have unique output file "
                    "names (\"%s\" appears more than once)",
                    os1-&gt;outfile_name);
        return MCELL_FAIL;
      }
    }
    struct output_column *oc;
    for (oc = os1-&gt;column_head; oc != NULL; oc = oc-&gt;next) {
      switch (oc-&gt;expr-&gt;expr_flags &amp; OEXPR_TYPE_MASK) {
      case OEXPR_TYPE_UNDEF:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          "reaction data output buffer");
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_UNSET;
          oc-&gt;buffer[i].val.cval = 'X';
        }
        break;
      case OEXPR_TYPE_INT:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          "reaction data output buffer");
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_INT;
          oc-&gt;buffer[i].val.ival = 0;
        }
        break;
      case OEXPR_TYPE_DBL:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          "reaction data output buffer");
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_DBL;
          oc-&gt;buffer[i].val.dval = 0.0;
        }
        break;
      case OEXPR_TYPE_TRIG:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;trig_bufsize,
                                          "reaction data output buffer");
        for (u_int i = 0; i &lt; obp-&gt;trig_bufsize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_TRIG_STRUCT;
          oc-&gt;buffer[i].val.tval = CHECKED_MALLOC_STRUCT(
              struct output_trigger_data,
              "reaction data output buffer");
          oc-&gt;buffer[i].val.tval-&gt;name = NULL;
        }
        break;
      default:
        mcell_error("Could not figure out what type of count data to store");
        return MCELL_FAIL;
      }
      if (oc-&gt;buffer == NULL)
        return MCELL_FAIL;
    }
  }
  return MCELL_SUCCESS;
}
struct output_column *get_counter_trigger_column(MCELL_STATE *state,
                                                 const char *counter_name,
                                                 int column_id) {
  struct sym_entry *counter_sym =
      retrieve_sym(counter_name, state-&gt;counter_by_name);
  if (counter_sym == NULL) {
    mcell_log("Failed to retrieve symbol for counter %s.", counter_name);
    return NULL;
  }
  struct output_set *counter = (struct output_set *)(counter_sym-&gt;value);
  struct output_column *column = counter-&gt;column_head;
  int count = 0;
  while (count &lt; column_id &amp;&amp; column != NULL) {
    count++;
    column = column-&gt;next;
  }
  if (count != column_id || column == NULL) {
    return NULL;
  }
  return column;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chkpt.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include "mcell_structs.h"
#include "mcell_reactions.h"
#include "nfsim_func.h"
#include "logging.h"
#include "vol_util.h"
#include "chkpt.h"
#include "grid_util.h"
#include "count_util.h"
#include "react.h"
#include "strfunc.h"
#define CHECKPOINT_API 1
#define MCELL_BIG_ENDIAN 16
#define MCELL_LITTLE_ENDIAN 17
#define CURRENT_TIME_CMD 1
#define CURRENT_ITERATION_CMD 2
#define CHKPT_SEQ_NUM_CMD 3
#define RNG_STATE_CMD 4
#define MCELL_VERSION_CMD 5
#define SPECIES_TABLE_CMD 6
#define MOL_SCHEDULER_STATE_CMD 7
#define BYTE_ORDER_CMD 8
#define NUM_CHKPT_CMDS 9
#define CHECKPOINT_API_CMD 10
#define HAS_ACT_NEWBIE 1
#define HAS_NOT_ACT_NEWBIE 0
#define HAS_ACT_CHANGE 1
#define HAS_NOT_ACT_CHANGE 0
int *chkpt_continue_after_checkpoint;
const char **chkpt_initialization_state;
enum checkpoint_request_type_t *chkpt_checkpoint_requested;
#define DATACHECK(op, msg, ...)                                                \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_warn("Corrupted checkpoint data: " msg, ##__VA_ARGS__);            \
      return 1;                                                                \
    }                                                                          \
  } while (0)
#define INTERNALCHECK(op, msg, ...)                                            \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_warn("%s internal: " msg, __func__, ##__VA_ARGS__);                \
      return 1;                                                                \
    }                                                                          \
  } while (0)
#define WRITECHECK(op, sect)                                                   \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_perror_nodie(errno, "Error while writing '%s' to checkpoint file", \
                         SECTNAME);                                            \
      return 1;                                                                \
    }                                                                          \
  } while (0)
#define WRITEFIELD(f) WRITECHECK(fwrite(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)
#define WRITEARRAY(f, len)                                                     \
  WRITECHECK(fwrite(f, sizeof(f[0]), (len), fs) != (len), SECTNAME)
#define WRITEUINT(f) WRITECHECK(write_varint(fs, (f)), SECTNAME)
#define WRITEINT(f) WRITECHECK(write_svarint(fs, (f)), SECTNAME)
#define WRITEUINT64(f) WRITECHECK(write_varintl(fs, (f)), SECTNAME)
#define WRITESTRING(f)                                                         \
  do {                                                                         \
    uint32_t len = (uint32_t)strlen(f);                                        \
    WRITEUINT(len);                                                            \
    WRITEARRAY(f, len);                                                        \
  } while (0)
#define READCHECK(op, sect)                                                    \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_perror_nodie(                                                      \
          errno, "Error while reading '%s' from checkpoint file", SECTNAME);   \
      return 1;                                                                \
    }                                                                          \
  } while (0)
#define READFIELDRAW(f) READCHECK(fread(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)
#define READBSWAP(f)                                                           \
  do {                                                                         \
    if (state-&gt;byte_order_mismatch)                                            \
      byte_swap(&amp;(f), sizeof(f));                                              \
  } while (0)
#define READFIELD(f)                                                           \
  do {                                                                         \
    READFIELDRAW(f);                                                           \
    READBSWAP(f);                                                              \
  } while (0)
#define READSTRING(f, len)                                                     \
  do {                                                                         \
    READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
    f[len] = '\0';                                                             \
  } while (0)
#define READARRAY(f, len)                                                      \
  do {                                                                         \
    int i;                                                                     \
    READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
    for (i = 0; i &lt; len; ++i)                                                  \
      READBSWAP(f[i]);                                                         \
  } while (0)
#define READUINT(f) READCHECK(read_varint(fs, &amp;(f)), SECTNAME)
#define READINT(f) READCHECK(read_svarint(fs, &amp;(f)), SECTNAME)
#define READUINT64(f) READCHECK(read_varintl(fs, &amp;(f)), SECTNAME)
struct chkpt_read_state {
  byte byte_order_mismatch;
};
static int read_current_time_seconds(struct volume *world, FILE *fs,
<a name="0"></a>                                     struct chkpt_read_state *state);
static int read_current_iteration(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int read_chkpt_seq_num(struct volume *world, FILE *fs,
                              struct chkpt_read_state *state);
static int read_rng_state(struct volume *world, FILE *fs,
                          struct chkpt_read_state *state);
static int read_byte_order(FILE *fs, struct chkpt_read_state *state);
static int read_mcell_version(FILE *fs, struct chkpt_read_state *state);</b></font>
static int read_api_version(FILE *fs, struct chkpt_read_state *state,
  uint32_t *api_version);
static int read_species_table(struct volume *world, FILE *fs);
static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
                                         struct chkpt_read_state *state,
                                         uint32_t api_version);
static int write_mcell_version(FILE *fs, const char *mcell_version);
static int write_current_time_seconds(FILE *fs, double current_time_seconds);
static int write_current_iteration(FILE *fs, long long current_iterations,
                                   double current_time_seconds);
static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num);
static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng);
static int write_species_table(FILE *fs, int n_species,
                               struct species **species_list);
static int write_mol_scheduler_state_real(FILE *fs,
                                          struct storage_list *storage_head,
                                          double simulation_start_seconds,
                                          double start_iterations,
                                          double time_unit);
static int write_byte_order(FILE *fs);
static int write_api_version(FILE *fs);
static int create_molecule_scheduler(struct storage_list *storage_head,
                                     long long start_iterations);
int set_checkpoint_state(struct volume *world) {
  chkpt_continue_after_checkpoint = &amp;world-&gt;continue_after_checkpoint;
  chkpt_initialization_state = &amp;world-&gt;initialization_state;
  chkpt_checkpoint_requested = &amp;world-&gt;checkpoint_requested;
  return 0;
}
void chkpt_signal_handler(int signo) {
  if (*chkpt_initialization_state) {
    if (signo != SIGALRM || !*chkpt_continue_after_checkpoint) {
      mcell_warn("Checkpoint requested while %s.  Exiting.",
                 *chkpt_initialization_state);
      exit(EXIT_FAILURE);
    }
  }
#ifndef _WIN64   if (signo == SIGUSR1)
    *chkpt_checkpoint_requested = CHKPT_SIGNAL_CONT;
  else if (signo == SIGUSR2)
    *chkpt_checkpoint_requested = CHKPT_SIGNAL_EXIT;
  else
#endif
      if (signo == SIGALRM) {
    if (*chkpt_continue_after_checkpoint)
      *chkpt_checkpoint_requested = CHKPT_ALARM_CONT;
    else
      *chkpt_checkpoint_requested = CHKPT_ALARM_EXIT;
  }
}
int create_chkpt(struct volume *world, char const *filename) {
  FILE *outfs = NULL;
  char *tmpname = alloc_sprintf("%s.tmp", filename);
  if (tmpname == NULL)
    mcell_allocfailed("Out of memory creating temporary checkpoint filename "
                      "for checkpoint '%s'.",
                      filename);
  if ((outfs = fopen(tmpname, "wb")) == NULL)
    mcell_perror(errno, "Failed to write checkpoint file '%s'", tmpname);
  world-&gt;current_time_seconds = world-&gt;current_time_seconds +
      (world-&gt;current_iterations - world-&gt;start_iterations) * world-&gt;time_unit;
  world-&gt;start_iterations = world-&gt;current_iterations;
  world-&gt;simulation_start_seconds = world-&gt;current_time_seconds;
  if (write_chkpt(world, outfs))
    mcell_error("Failed to write checkpoint file %s\n", filename);
  fclose(outfs);
  if (world-&gt;keep_chkpts) {
    struct stat buf;
    if (stat(filename, &amp;buf) == 0) {
      char *keepName = alloc_sprintf("%s.%lld", filename, world-&gt;current_iterations);
      if (keepName == NULL) {
        mcell_allocfailed("Out of memory creating filename for checkpoint");
      }
      if (rename(filename, keepName) != 0) {
        mcell_error("Failed to save previous checkpoint file %s to %s",
                    filename, keepName);
      }
      free(keepName);
    }
  }
  if (rename(tmpname, filename) != 0)
    mcell_error("Successfully wrote checkpoint to file '%s', but failed to "
                "atomically replace checkpoint file '%s'.\nThe simulation may "
                "be resumed from '%s'.",
                tmpname, filename, tmpname);
  free(tmpname);
  return 0;
}
static int write_varintl(FILE *fs, unsigned long long val) {
  unsigned char buffer[40];
  size_t len = 0;
  buffer[sizeof(buffer) - 1 - len] = val &amp; 0x7f;
  val &gt;&gt;= 7;
  ++len;
  while (val != 0) {
    buffer[sizeof(buffer) - 1 - len] = (val &amp; 0x7f) | 0x80;
    val &gt;&gt;= 7;
    ++len;
  }
  if (fwrite(buffer + sizeof(buffer) - len, 1, len, fs) != len)
    return 1;
  return 0;
}
static int write_svarintl(FILE *fs, long long val) {
  if (val &lt; 0)
    return write_varintl(fs, (unsigned long long)(((-val) &lt;&lt; 1) | 1));
  else
    return write_varintl(fs, (unsigned long long)(((val) &lt;&lt; 1)));
}
static int read_varintl(FILE *fs, unsigned long long *dest) {
  unsigned long long accum = 0;
  unsigned char ch;
  do {
    if (fread(&amp;ch, 1, 1, fs) != 1)
      return 1;
    accum &lt;&lt;= 7;
    accum |= ch &amp; 0x7f;
  } while (ch &amp; 0x80);
  *dest = accum;
  return 0;
}
static int read_svarintl(FILE *fs, long long *dest) {
  unsigned long long tmp = 0;
  if (read_varintl(fs, &amp;tmp))
    return 1;
  if (tmp &amp; 1)
    *dest = (long long)-(tmp &gt;&gt; 1);
  else
    *dest = (long long)(tmp &gt;&gt; 1);
  return 0;
}
static int write_varint(FILE *fs, unsigned int val) {
  return write_varintl(fs, (unsigned long long)val);
}
static int write_svarint(FILE *fs, int val) {
  return write_svarintl(fs, (long long)val);
}
static int read_varint(FILE *fs, unsigned int *dest) {
  unsigned long long val;
  if (read_varintl(fs, &amp;val))
    return 1;
  *dest = val;
  if ((unsigned long long)*dest != val)
    return 1;
  return 0;
}
static int read_svarint(FILE *fs, int *dest) {
  long long val;
  if (read_svarintl(fs, &amp;val))
    return 1;
  *dest = val;
  if ((long long)*dest != val)
    return 1;
  return 0;
}
int write_chkpt(struct volume *world, FILE *fs) {
  return (write_byte_order(fs) ||
          write_api_version(fs) ||
          write_mcell_version(fs, world-&gt;mcell_version) ||
          write_current_time_seconds(fs, world-&gt;current_time_seconds) ||
          write_current_iteration(fs, world-&gt;current_iterations,
                                  world-&gt;current_time_seconds) ||
          write_chkpt_seq_num(fs, world-&gt;chkpt_seq_num) ||
          write_rng_state(fs, world-&gt;seed_seq, world-&gt;rng) ||
          write_species_table(fs, world-&gt;n_species, world-&gt;species_list) ||
          write_mol_scheduler_state_real(fs, world-&gt;storage_head,
              world-&gt;simulation_start_seconds, world-&gt;start_iterations,
              world-&gt;time_unit));
}
static int read_preamble(FILE *fs, struct chkpt_read_state *state, uint32_t *api_version) {
  byte cmd;
  size_t count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  DATACHECK(feof(fs), "Checkpoint file is empty.");
  if (count != sizeof(cmd)) {
    return 1; 
  }
  DATACHECK(cmd != BYTE_ORDER_CMD,
            "Checkpoint file does not have the required byte-order command.");
  if (read_byte_order(fs, state))
    return 1;
  count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  DATACHECK(feof(fs), "Checkpoint file is too short (no api or version info).");
  if (count != sizeof(cmd)) {
    return 1; 
  }
  if (cmd != CHECKPOINT_API_CMD) {
    *api_version = 0;
  } else {
    read_api_version(fs, state, api_version);
    count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  }
  DATACHECK(feof(fs), "Checkpoint file is too short (no version info).");
  if (count != sizeof(cmd)) {
    return 1; 
  }
  DATACHECK(cmd != MCELL_VERSION_CMD,
            "Checkpoint file does not contain required MCell version command.");
  return read_mcell_version(fs, state);
}
int read_chkpt(struct volume *world, FILE *fs, bool only_time_and_iter) {
  byte cmd;
  int seen_section[NUM_CHKPT_CMDS];
  memset(seen_section, 0, sizeof(int)*NUM_CHKPT_CMDS);
  struct chkpt_read_state state;
  state.byte_order_mismatch = 0;
  uint32_t api_version;
  if (read_preamble(fs, &amp;state, &amp;api_version))
    return 1;
  seen_section[BYTE_ORDER_CMD] = 1;
  seen_section[MCELL_VERSION_CMD] = 1;
  bool time_read = false;
  bool iteration_read = false;
  while (1) {
    size_t count = fread(&amp;cmd, sizeof(cmd), 1, fs);
    if (feof(fs)) {
      break;
    }
    if (count != sizeof(cmd)) {
      return 1; 
    }
    DATACHECK(cmd &lt; 1 || cmd &gt;= NUM_CHKPT_CMDS,
              "Unrecognized command-type in checkpoint file.  "
              "Checkpoint file cannot be loaded.");
    DATACHECK(seen_section[cmd], "Duplicate command-type in checkpoint file.");
    seen_section[cmd] = 1;
    switch (cmd) {
    case CURRENT_TIME_CMD:
      if (read_current_time_seconds(world, fs, &amp;state)) {
        return 1;
      }
      time_read = true;
      if (only_time_and_iter &amp;&amp; iteration_read) {
        return 0;
      }
      break;
    case CURRENT_ITERATION_CMD:
      if (read_current_iteration(world, fs, &amp;state)) {
        return 1;
      }
      iteration_read = true;
      if (only_time_and_iter &amp;&amp; time_read) {
        return 0;
      }
      if (!only_time_and_iter) {
        if (create_molecule_scheduler(world-&gt;storage_head, world-&gt;start_iterations)) {
          return 1;
        }
      }
      break;
    case CHKPT_SEQ_NUM_CMD:
      if (read_chkpt_seq_num(world, fs, &amp;state))
        return 1;
      break;
    case RNG_STATE_CMD:
      if (read_rng_state(world, fs, &amp;state))
        return 1;
      break;
    case SPECIES_TABLE_CMD:
      if (read_species_table(world, fs))
        return 1;
      break;
    case MOL_SCHEDULER_STATE_CMD:
      DATACHECK(
          !seen_section[CURRENT_ITERATION_CMD],
          "Current iteration command must precede molecule scheduler command.");
      DATACHECK(
          !seen_section[SPECIES_TABLE_CMD],
          "Species table command must precede molecule scheduler command.");
      if (read_mol_scheduler_state_real(world, fs, &amp;state, api_version))
        return 1;
      break;
    case BYTE_ORDER_CMD:
    case MCELL_VERSION_CMD:
    default:
      assert(0);
      break;
    }
  }
  DATACHECK(!seen_section[CURRENT_TIME_CMD],
            "Current time command is not present.");
  DATACHECK(!seen_section[CHKPT_SEQ_NUM_CMD],
            "Checkpoint sequence number command is not present.");
  DATACHECK(!seen_section[RNG_STATE_CMD], "RNG state command is not present.");
  DATACHECK(!seen_section[MOL_SCHEDULER_STATE_CMD],
            " Molecule scheduler state command is not present.");
  return 0;
}
static int write_byte_order(FILE *fs) {
  static const char SECTNAME[] = "byte order";
  static const byte cmd = BYTE_ORDER_CMD;
#ifdef WORDS_BIGENDIAN
  static const unsigned int byte_order = MCELL_BIG_ENDIAN;
#else
  static const unsigned int byte_order = MCELL_LITTLE_ENDIAN;
#endif
  WRITEFIELD(cmd);
  WRITEFIELD(byte_order);
  return 0;
}
static int read_byte_order(FILE *fs, struct chkpt_read_state *state) {
  static const char SECTNAME[] = "byte order";
#ifdef WORDS_BIGENDIAN
  static const unsigned int byte_order_present = MCELL_BIG_ENDIAN;
#else
  static const unsigned int byte_order_present = MCELL_LITTLE_ENDIAN;
#endif
  unsigned int byte_order_read;
  READFIELDRAW(byte_order_read);
  state-&gt;byte_order_mismatch = (byte_order_read != byte_order_present);
  return 0;
}
static int write_api_version(FILE *fs) {
  static const char SECTNAME[] = "api version";
  static const byte cmd = CHECKPOINT_API_CMD;
  uint32_t api_version = CHECKPOINT_API;
  WRITEFIELD(cmd);
  WRITEFIELD(api_version);
  return 0;
}
static int read_api_version(FILE *fs, struct chkpt_read_state *state,
  uint32_t *api_version) {
  static const char SECTNAME[] = "api version";
  READFIELD(*api_version);
  return 0;
}
static int write_mcell_version(FILE *fs, const char *mcell_version) {
  static const char SECTNAME[] = "MCell version";
  static const byte cmd = MCELL_VERSION_CMD;
  uint32_t len = (uint32_t)strlen(mcell_version);
  WRITEFIELD(cmd);
  WRITEFIELD(len);
  WRITEARRAY(mcell_version, len);
  return 0;
}
static int read_mcell_version(FILE *fs, struct chkpt_read_state *state) {
  static const char SECTNAME[] = "MCell version";
  unsigned int version_length;
  READFIELD(version_length);
  DATACHECK(version_length &gt;= 100000,
            "Length field for MCell version is too long (%u).", version_length);
  char* mcell_version = new char[version_length + 1];
  READSTRING(mcell_version, version_length);
  mcell_log("Checkpoint file was created with MCell Version %s.",
            mcell_version);
  delete mcell_version;
  return 0;
}
static int write_current_time_seconds(FILE *fs, double current_time_seconds) {
  static const char SECTNAME[] = "current real time";
  static const byte cmd = CURRENT_TIME_CMD;
  WRITEFIELD(cmd);
  WRITEFIELD(current_time_seconds);
  return 0;
}
static int read_current_time_seconds(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state) {
  static const char SECTNAME[] = "current real time";
  READFIELD(world-&gt;simulation_start_seconds);
  return 0;
}
static int create_molecule_scheduler(struct storage_list *storage_head,
                                     long long start_iterations) {
  struct storage_list *stg;
  for (stg = storage_head; stg != NULL; stg = stg-&gt;next) {
    if ((stg-&gt;store-&gt;timer = create_scheduler(1.0, 100.0, 100, start_iterations)) ==
        NULL) {
      mcell_error("Out of memory while creating molecule scheduler.");
    }
    stg-&gt;store-&gt;current_time = start_iterations;
  }
  return 0;
}
static int write_current_iteration(FILE *fs, long long current_iterations,
                                   double current_time_seconds) {
  static const char SECTNAME[] = "current iteration";
  static const byte cmd = CURRENT_ITERATION_CMD;
  WRITEFIELD(cmd);
  WRITEFIELD(current_iterations);
  WRITEFIELD(current_time_seconds);
  return 0;
}
static int read_current_iteration(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state) {
  static const char SECTNAME[] = "current iteration";
  READFIELD(world-&gt;start_iterations);
  READFIELD(world-&gt;chkpt_start_time_seconds);
  world-&gt;current_time_seconds = world-&gt;chkpt_start_time_seconds;
  return 0;
}
static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num) {
  static const char SECTNAME[] = "checkpoint sequence number";
  static const byte cmd = CHKPT_SEQ_NUM_CMD;
  WRITEFIELD(cmd);
  WRITEFIELD(chkpt_seq_num);
  return 0;
}
static int read_chkpt_seq_num(struct volume *world, FILE *fs,
                              struct chkpt_read_state *state) {
  static const char SECTNAME[] = "checkpoint sequence number";
  READFIELD(world-&gt;chkpt_seq_num);
  ++world-&gt;chkpt_seq_num;
  return 0;
}
static int write_an_rng_state(FILE *fs, struct rng_state *rng) {
  static const char SECTNAME[] = "RNG state";
#ifdef USE_MINIMAL_RNG
  static const char RNG_MINRNG = 'M';
  WRITEFIELD(RNG_MINRNG);
  WRITEFIELD(rng-&gt;a);
  WRITEFIELD(rng-&gt;b);
  WRITEFIELD(rng-&gt;c);
  WRITEFIELD(rng-&gt;d);
#else
  static const char RNG_ISAAC = 'I';
  WRITEFIELD(RNG_ISAAC);
  WRITEUINT(rng-&gt;randcnt);
  WRITEFIELD(rng-&gt;aa);
  WRITEFIELD(rng-&gt;bb);
  WRITEFIELD(rng-&gt;cc);
  WRITEARRAY(rng-&gt;randrsl, RANDSIZ);
  WRITEARRAY(rng-&gt;mm, RANDSIZ);
#endif
  return 0;
}
static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng) {
  static const char SECTNAME[] = "RNG state";
  static const byte cmd = RNG_STATE_CMD;
  WRITEFIELD(cmd);
  WRITEUINT(seed_seq);
  if (write_an_rng_state(fs, rng))
    return 1;
  return 0;
}
static int read_an_rng_state(FILE *fs, struct chkpt_read_state *state,
                             struct rng_state *rng) {
  static const char SECTNAME[] = "RNG state";
#ifdef USE_MINIMAL_RNG
  static const char RNG_MINRNG = 'M';
  char rngtype;
  READFIELD(rngtype);
  DATACHECK(rngtype != RNG_MINRNG, "Invalid RNG type stored in checkpoint file "
                                   "(in this version of MCell, only Bob "
                                   "Jenkins' \"small PRNG\" is supported).");
  READFIELD(rng-&gt;a);
  READFIELD(rng-&gt;b);
  READFIELD(rng-&gt;c);
  READFIELD(rng-&gt;d);
#else
  static const char RNG_ISAAC = 'I';
  char rngtype;
  READFIELD(rngtype);
  DATACHECK(rngtype != RNG_ISAAC, "Invalid RNG type stored in checkpoint file "
                                  "(in this version of MCell, only ISAAC64 is "
                                  "supported).");
  READUINT(rng-&gt;randcnt);
  READFIELD(rng-&gt;aa);
  READFIELD(rng-&gt;bb);
  READFIELD(rng-&gt;cc);
  READARRAY(rng-&gt;randrsl, RANDSIZ);
  READARRAY(rng-&gt;mm, RANDSIZ);
  rng-&gt;rngblocks = 1;
#endif
  return 0;
}
static int read_rng_state(struct volume *world, FILE *fs,
                          struct chkpt_read_state *state) {
  static const char SECTNAME[] = "RNG state";
  unsigned int old_seed;
  READUINT(old_seed);
  if (read_an_rng_state(fs, state, world-&gt;rng))
    return 1;
  if (world-&gt;seed_seq != old_seed)
    rng_init(world-&gt;rng, world-&gt;seed_seq);
  return 0;
}
static int write_species_table(FILE *fs, int n_species,
                               struct species **species_list) {
  static const char SECTNAME[] = "species table";
  static const byte cmd = SPECIES_TABLE_CMD;
  WRITEFIELD(cmd);
  unsigned int non_empty_species_count = 0;
  int i;
  for (i = 0; i &lt; n_species; i++) {
    if (species_list[i]-&gt;population &gt; 0)
      ++non_empty_species_count;
  }
  WRITEUINT(non_empty_species_count);
  unsigned int external_species_id = 0;
  for (i = 0; i &lt; n_species; i++) {
    if (species_list[i]-&gt;population == 0)
      continue;
    WRITESTRING(species_list[i]-&gt;sym-&gt;name);
    WRITEUINT(external_species_id);
    species_list[i]-&gt;chkpt_species_id = external_species_id++;
  }
  return 0;
}
static int read_species_table(struct volume *world, FILE *fs) {
  static const char SECTNAME[] = "species table";
  unsigned int total_species;
  READUINT(total_species);
  for (unsigned int i = 0; i &lt; total_species; i++) {
    unsigned int species_name_length;
    READUINT(species_name_length);
    DATACHECK(
        species_name_length &gt;= 100000,
        "Species table has species name greater than 100000 characters (%u).",
        species_name_length);
    char* species_name = new char[species_name_length + 1];
    unsigned int external_species_id;
    READSTRING(species_name, species_name_length);
    READUINT(external_species_id);
    int j;
    for (j = 0; j &lt; world-&gt;n_species; j++) {
      if ((strcmp(world-&gt;species_list[j]-&gt;sym-&gt;name, species_name) == 0)) {
        world-&gt;species_list[j]-&gt;chkpt_species_id = external_species_id;
        break;
      }
    }
    DATACHECK(j == world-&gt;n_species, "Checkpoint file contains data for "
                                     "species '%s', which does not exist in "
                                     "this simulation.",
              species_name);
    delete species_name;
  }
  return 0;
}
unsigned long long
count_items_in_scheduler(struct storage_list *storage_head) {
  unsigned long long total_items = 0;
  for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
    for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
         shp = shp-&gt;next_scale) {
      for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
        for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head[i];
             aep != NULL; aep = aep-&gt;next) {
          struct abstract_molecule *amp = (struct abstract_molecule *)aep;
          if (amp-&gt;properties == NULL)
            continue;
          assert(!(amp-&gt;properties-&gt;flags &amp; IS_SURFACE));
          ++total_items;
        }
      }
    }
  }
  return total_items;
}
static int write_mol_scheduler_state_real(FILE *fs,
                                          struct storage_list *storage_head,
                                          double simulation_start_seconds,
                                          double start_iterations,
                                          double time_unit) {
  static const char SECTNAME[] = "molecule scheduler state";
  static const byte cmd = MOL_SCHEDULER_STATE_CMD;
  WRITEFIELD(cmd);
  unsigned long long total_items = count_items_in_scheduler(storage_head);
  WRITEUINT64(total_items);
  for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
    for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
         shp = shp-&gt;next_scale) {
      for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
        for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head[i];
             aep != NULL; aep = aep-&gt;next) {
          struct abstract_molecule *amp = (struct abstract_molecule *)aep;
          if (amp-&gt;properties == NULL)
            continue;
          struct vector3 where;
          short orient = 0;
          byte act_newbie_flag =
              (amp-&gt;flags &amp; ACT_NEWBIE) ? HAS_ACT_NEWBIE : HAS_NOT_ACT_NEWBIE;
          byte act_change_flag =
              (amp-&gt;flags &amp; ACT_CHANGE) ? HAS_ACT_CHANGE : HAS_NOT_ACT_CHANGE;
          if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
            struct volume_molecule *vmp = (struct volume_molecule *)amp;
            INTERNALCHECK(vmp-&gt;previous_wall != NULL &amp;&amp; vmp-&gt;index &gt;= 0,
                          "The value of 'previous_grid' is not NULL.");
            where.x = vmp-&gt;pos.x;
            where.y = vmp-&gt;pos.y;
            where.z = vmp-&gt;pos.z;
            orient = 0;
          } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
            struct surface_molecule *smp = (struct surface_molecule *)amp;
            uv2xyz(&amp;smp-&gt;s_pos, smp-&gt;grid-&gt;surface, &amp;where);
            orient = smp-&gt;orient;
          } else
            continue;
          INTERNALCHECK(amp-&gt;properties-&gt;chkpt_species_id == UINT_MAX,
                        "Attempted to write out a molecule of species '%s', "
                        "which has not been assigned a checkpoint species id.",
                        amp-&gt;properties-&gt;sym-&gt;name);
          WRITEUINT(amp-&gt;properties-&gt;chkpt_species_id);
          WRITEFIELD(act_newbie_flag);
          WRITEFIELD(act_change_flag);
          double t = convert_iterations_to_seconds(
              start_iterations, time_unit, simulation_start_seconds, amp-&gt;t);
          WRITEFIELD(t);
          double t2 = amp-&gt;t2 * time_unit;
          WRITEFIELD(t2);
          double bday = amp-&gt;birthday;
          WRITEFIELD(bday);
          WRITEFIELD(where);
          WRITEINT(orient);
          static const unsigned char NON_COMPLEX = '\0';
          WRITEFIELD(NON_COMPLEX);
        }
      }
    }
  }
  return 0;
}
static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
                                         struct chkpt_read_state *state,
                                         uint32_t api_version) {
  static const char SECTNAME[] = "molecule scheduler state";
  struct volume_molecule vm;
  struct volume_molecule *vmp = NULL;
  struct abstract_molecule *amp = NULL;
  struct volume_molecule *guess = NULL;
  memset(&amp;vm, 0, sizeof(struct volume_molecule));
  vmp = &amp;vm;
  amp = (struct abstract_molecule *)vmp;
  unsigned long long total_items;
  READUINT64(total_items);
  for (unsigned long long n_mol = 0; n_mol &lt; total_items; n_mol++) {
    unsigned int external_species_id;
    byte act_newbie_flag;
    byte act_change_flag;
    double sched_time;
    double lifetime;
    double birthday;
    double x_coord, y_coord, z_coord;
    int orient;
    READUINT(external_species_id);
    READFIELDRAW(act_newbie_flag);
    READFIELDRAW(act_change_flag);
    READFIELD(sched_time);
    READFIELD(lifetime);
    READFIELD(birthday);
    READFIELD(x_coord);
    READFIELD(y_coord);
    READFIELD(z_coord);
    READINT(orient);
    if (api_version &gt;= 1) {
      lifetime = 0;
      sched_time = world-&gt;start_iterations;
      act_change_flag = HAS_ACT_CHANGE;
    }
    unsigned int complex_no = 0;
    READUINT(complex_no);
    struct species *properties = NULL;
    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
      if (world-&gt;species_list[species_idx]-&gt;chkpt_species_id ==
          external_species_id) {
        properties = world-&gt;species_list[species_idx];
        break;
      }
    }
    DATACHECK(properties == NULL,
              "Found molecule with unknown species id (%d).",
              external_species_id);
    struct periodic_image periodic_box = {  0, 0, 0 };
    if ((properties-&gt;flags &amp; NOT_FREE) == 0) { 
      amp-&gt;t = sched_time;
      amp-&gt;t2 = lifetime;
      amp-&gt;birthday = birthday;
      amp-&gt;properties = properties;
      initialize_diffusion_function(amp);
      if(amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES)
        properties_nfsim(world, amp);
      vmp-&gt;previous_wall = NULL;
      vmp-&gt;index = -1;
      vmp-&gt;pos.x = x_coord;
      vmp-&gt;pos.y = y_coord;
      vmp-&gt;pos.z = z_coord;
      amp-&gt;periodic_box = &amp;periodic_box;
      amp-&gt;flags = TYPE_VOL | IN_VOLUME;
      if (act_newbie_flag == HAS_ACT_NEWBIE)
        amp-&gt;flags |= ACT_NEWBIE;
      if (act_change_flag == HAS_ACT_CHANGE)
        amp-&gt;flags |= ACT_CHANGE;
      amp-&gt;flags |= IN_SCHEDULE;
      if ((amp-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0 ||
          trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                               amp-&gt;properties-&gt;hashval, amp) != NULL)
        amp-&gt;flags |= ACT_REACT;
      if (amp-&gt;get_space_step(amp) &gt; 0.0)
        amp-&gt;flags |= ACT_DIFFUSE;
      guess = insert_volume_molecule(world, vmp, guess);
      if (guess == NULL) {
        mcell_error("Cannot insert copy of molecule of species '%s' into "
                    "world.\nThis may be caused by a shortage of memory.",
                    vmp-&gt;properties-&gt;sym-&gt;name);
      }
    } else {       struct vector3 where;
      where.x = x_coord;
      where.y = y_coord;
      where.z = z_coord;
      struct surface_molecule *smp = insert_surface_molecule(
          world, properties, &amp;where, orient, CHKPT_GRID_TOLERANCE, sched_time,
          NULL, NULL, NULL, &amp;periodic_box);
      if (smp == NULL) {
        mcell_warn("Could not place molecule %s at (%f,%f,%f).",
                   properties-&gt;sym-&gt;name, where.x * world-&gt;length_unit,
                   where.y * world-&gt;length_unit,
                   where.z * world-&gt;length_unit);
        continue;
      }
      smp-&gt;t2 = lifetime;
      smp-&gt;birthday = birthday;
      if (act_newbie_flag == HAS_NOT_ACT_NEWBIE)
        smp-&gt;flags &amp;= ~ACT_NEWBIE;
      if (act_change_flag == HAS_ACT_CHANGE) {
        smp-&gt;flags |= ACT_CHANGE;
      }
    }
  }
  return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
