<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mcell_react_out.c & chkpt.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mcell_react_out.c & chkpt.c
      </h3>
      <h1 align="center">
        1.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mcell_react_out.c (2.097902%)<TH>chkpt.c (1.182266%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1342-0.html#0',2,'match1342-1.html#0',3)" NAME="0">(39-50)<TD><A HREF="javascript:ZweiFrames('match1342-0.html#0',2,'match1342-1.html#0',3)" NAME="0">(202-207)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_react_out.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include &quot;config.h&quot;

#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;sym_table.h&quot;
#include &quot;logging.h&quot;
#include &quot;react_output.h&quot;
#include &quot;mcell_misc.h&quot;
#include &quot;mcell_react_out.h&quot;
#include &quot;mdlparse_util.h&quot;

#include &quot;dyngeom_parse_extras.h&quot;
#include &quot;strfunc.h&quot;
#include &quot;count_util.h&quot;

/* static helper functions */
static struct output_column *new_output_column(void);

static struct output_block *new_output_block(int buffersize);

static void set_reaction_output_timer_step(MCELL_STATE *state,
<A NAME="0"></A>                                           struct output_block *obp,
                                           double step);

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1342-1.html#0',3,'match1342-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static int
set_reaction_output_timer_iterations(MCELL_STATE *state,
                                     struct output_block *obp,
                                     struct num_expr_list_head *step_values);

static int
set_reaction_output_timer_times(MCELL_STATE *state, struct output_block *obp,
                                struct num_expr_list_head *step_values);

static int output_block_finalize(struct output_block *obp);

static long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,</B></FONT>
                                  long long n_output);

static struct output_column *
get_counter_trigger_column(MCELL_STATE *state, const char *counter_name,
                           int column_id);

/*************************************************************************
 mcell_get_count:
  Get the count of a molecule in a certain region..
 
 In:  mol_name - molecule you want the count of
      reg_name - region where you want the count
      world - the instance world of the object volume.
Out: int mol_count - count of molecule in the region
*************************************************************************/
int mcell_get_count(char *mol_name, char *reg_name, struct volume *world) {
  // Get the hash values for mol and reg---------------// 

  // Get hash value for molecule  

  struct sym_entry *mol_sym = NULL;  
  mol_sym = retrieve_sym(mol_name, world-&gt;mol_sym_table);

  // Make sure mol_sym has been initialized. If not, return error code.
  if (mol_sym == NULL)
    return -5;

  // Cast mol_sym (sym_entry, void pointer) to a species pointer
  struct species *mol = (struct species *)mol_sym-&gt;value;
  // Get hash value for molecule 
  u_int mol_hashval = mol-&gt;hashval;

  // Get hash value for region

  struct sym_entry *reg_sym = NULL;  
  reg_sym = retrieve_sym(reg_name, world-&gt;reg_sym_table);

  // Make sure reg_sym has been initialized, if not return garbage

  if (reg_sym == NULL)
    return -6;  
 
  // Cast mol_sym (sym_entry,void pointer) to a species pointer 
  struct region *reg = (struct region *)reg_sym-&gt;value;
  // Get hash value for region
  u_int reg_hashval = reg-&gt; hashval;

  //---------------------------------------------------//

  // Use the hash values to get the molecule count in the region from the count
  // hash //

  // Combine hash values for molecule in that region
  int hash_bin = (mol_hashval + reg_hashval) &amp; world-&gt;count_hashmask;
 
  // Make sure hash_bin exists
  if (world-&gt;count_hash[hash_bin] == NULL)
    return -7;

  // Get the count of molecule in and on the region  
  int mol_count_vol = world-&gt;count_hash[hash_bin]-&gt;data.move.n_enclosed;
  int mol_count_sur = world-&gt;count_hash[hash_bin]-&gt;data.move.n_at;

  return mol_count_vol + mol_count_sur;

}


/*************************************************************************
 mcell_new_output_request:
    Create a new output request.

 In:  state: MCell state
      target: what are we counting
      orientation: how is it oriented?
      location: where are we counting?
      report_flags: what type of events are we counting?
 Out: output request item, or NULL if an error occurred
*************************************************************************/
struct output_request *mcell_new_output_request(MCELL_STATE *state,
                                                struct sym_entry *target,
                                                short orientation,
                                                struct sym_entry *location,
                                                struct periodic_image *img,
                                                int report_flags) {
  struct output_request *orq;
  struct output_expression *oe;

  orq = (struct output_request *)CHECKED_MEM_GET(state-&gt;outp_request_mem, &quot;count request&quot;);
  if (orq == NULL)
    return NULL;

  oe = new_output_expr(state-&gt;oexpr_mem);
  if (oe == NULL) {
    mem_put(state-&gt;outp_request_mem, orq);
    mcell_allocfailed(&quot;Failed to allocate a count expression.&quot;);
    return NULL;
  }
  orq-&gt;next = NULL;
  orq-&gt;requester = oe;
  orq-&gt;count_target = target;
  orq-&gt;count_orientation = orientation;
  orq-&gt;count_location = location;
  orq-&gt;report_type = report_flags;
  orq-&gt;periodic_box = img;

  oe-&gt;left = orq;
  oe-&gt;oper = '#';
  oe-&gt;expr_flags = OEXPR_LEFT_REQUEST;
  struct sym_entry *sym = NULL;
  if (location) {
    char *name = location-&gt;name;
    // Counting in/on a region. XXX: Using strchr seems inefficient
    if (strchr(location-&gt;name, ',')) {
      sym = retrieve_sym(name, state-&gt;reg_sym_table);
    }
    // Counting in/on an object
    else {
      sym = retrieve_sym(name, state-&gt;obj_sym_table);
    }
  }

  // If the object/region will exist at some point in the future, but not at
  // the beginning of the simulation.
  if (sym &amp;&amp; !(is_object_instantiated(sym, state-&gt;root_instance))) 
    oe-&gt;expr_flags = OEXPR_TYPE_UNDEF;
  else if (orq-&gt;report_type &amp; REPORT_TRIGGER)
    oe-&gt;expr_flags |= OEXPR_TYPE_TRIG;
  else if ((orq-&gt;report_type &amp; REPORT_TYPE_MASK) != REPORT_CONTENTS)
    oe-&gt;expr_flags |= OEXPR_TYPE_DBL;
  else
    oe-&gt;expr_flags |= OEXPR_TYPE_INT;
  return orq;
}

/******************************************************************************
 *
 * mcell_create_count creates a single count expression and returns it as a
 * output_column_list.
 * Inputs are:
 *    - symbol table entry for target (molecule or reaction)
 *    - orientation for molecule counts
 *    - symbol table entry for count location (NULL implies WORLD)
 *    - report flags (REPORT_WORLD, REPORT_CONTENTS, ...)
 *    - custom header (or NULL if not wanted)
 *    - pointer to empty count list to which count expression will be added
 *
 *****************************************************************************/
MCELL_STATUS
mcell_create_count(MCELL_STATE *state, struct sym_entry *target,
                   short orientation, struct sym_entry *location,
                   int report_flags, char *custom_header,
                   struct output_column_list *count_list) {

  struct output_request *output_A = NULL;
  if ((output_A = mcell_new_output_request(state, target, orientation, location,
    NULL, report_flags)) == NULL) {
    return MCELL_FAIL;
  }
  output_A-&gt;next = state-&gt;output_request_head;
  state-&gt;output_request_head = output_A;

  return mcell_prepare_single_count_expr(count_list, output_A-&gt;requester,
                                         custom_header);
}

/*************************************************************************
 mcell_create_new_output_set
    Create a new output set. Here output set refers to a count/trigger
    block which goes to a single data output file.

 In:  comment: textual comment describing the data set or NULL
      exact_time: request exact_time output for trigger statements
      col_head: head of linked list of output columns
      file_flags: file creation flags for output file
      outfile_name: name of output file
 Out: output request item, or NULL if an error occurred
*************************************************************************/
struct output_set *mcell_create_new_output_set(const char *comment, int exact_time,
                                               struct output_column *col_head,
                                               int file_flags,
                                               const char *outfile_name) {

  struct output_set *os =
      CHECKED_MALLOC_STRUCT(struct output_set, &quot;reaction data output set&quot;);
  if (os == NULL) {
    return NULL;
  }

  os-&gt;outfile_name = CHECKED_STRDUP(outfile_name, &quot;count outfile_name&quot;);
  os-&gt;file_flags = (enum overwrite_policy_t)file_flags;
  os-&gt;exact_time_flag = exact_time;
  os-&gt;chunk_count = 0;
  os-&gt;block = NULL;
  os-&gt;next = NULL;

  struct output_column *oc = col_head;
  os-&gt;column_head = oc;

  if (comment == NULL)
    os-&gt;header_comment = NULL;
  else if (comment[0] == '\0')
    os-&gt;header_comment = &quot;&quot;;
  else {
    os-&gt;header_comment = strdup(comment);
    if (os-&gt;header_comment == NULL) {
      free(os);
      return NULL;
    }
  }

  for (; oc != NULL; oc = oc-&gt;next)
    oc-&gt;set = os;

  if (check_reaction_output_file(os)) {
    free(os);
    return NULL;
  }

  return os;
}

/*****************************************************************************
 *
 * mcell_prepare_single_count_expression prepares a count expression for
 * inclusion in an output set
 *
 *****************************************************************************/
MCELL_STATUS
mcell_prepare_single_count_expr(struct output_column_list *list,
                                struct output_expression *expr,
                                char *custom_header) {
  list-&gt;column_head = NULL;
  list-&gt;column_tail = NULL;

  if (custom_header != NULL) {
    expr-&gt;title = custom_header;
  }

  /* If we have a list of results, go through to build column stack */
  struct output_expression *oe;
  struct output_column *oc;
  for (oe = first_oexpr_tree(expr); oe != NULL; oe = next_oexpr_tree(oe)) {
    if ((oc = new_output_column()) == NULL)
      return MCELL_FAIL;

    if (!list-&gt;column_head)
      list-&gt;column_head = list-&gt;column_tail = oc;
    else
      list-&gt;column_tail = list-&gt;column_tail-&gt;next = oc;

    oc-&gt;expr = oe;
    set_oexpr_column(oe, oc);
  }

  return MCELL_SUCCESS;
}

/*****************************************************************************
 *
 * mcell_add_reaction_output_block creates a new reaction data output block
 * and adds it to the world.
 *
 *****************************************************************************/
MCELL_STATUS
mcell_add_reaction_output_block(MCELL_STATE *state,
                                struct output_set_list *osets, int buffer_size,
                                struct output_times_inlist *otimes) {

  struct output_block *obp;
  struct output_set *os;

  if ((obp = new_output_block(buffer_size)) == NULL)
    return 1;

  if (otimes-&gt;type == OUTPUT_BY_STEP)
    set_reaction_output_timer_step(state, obp, otimes-&gt;step);
  else if (otimes-&gt;type == OUTPUT_BY_ITERATION_LIST) {
    if (set_reaction_output_timer_iterations(state, obp, &amp;otimes-&gt;values)) {
      free(obp);
      return MCELL_FAIL;
    }
  } else if (otimes-&gt;type == OUTPUT_BY_TIME_LIST) {
    if (set_reaction_output_timer_times(state, obp, &amp;otimes-&gt;values)) {
      free(obp);
      return MCELL_FAIL;
    }
  } else {
    mcell_error(&quot;Internal error: Invalid output timer def (%d)&quot;, otimes-&gt;type);
    free(obp);
    return MCELL_FAIL;
  }
  obp-&gt;data_set_head = osets-&gt;set_head;
  for (os = obp-&gt;data_set_head; os != NULL; os = os-&gt;next)
    os-&gt;block = obp;
  if (output_block_finalize(obp))
    return 1;
  obp-&gt;next = state-&gt;output_block_head;
  state-&gt;output_block_head = obp;
  return MCELL_SUCCESS;
}

/************************************************************************
 *
 * function for retrieving the current value of a given count
 * expression
 *
 * The call expects:
 *
 * - MCELL_STATE
 * - counter_name: a string containing the name of the count statement to
 *   be retrieved. Currently, the name is identical to the full path to which
 *   the corresponding reaction output will be written but this may change
 *   in the future
 * - column: int describing the column to be retrieved
 * - count_data: a *double which will receive the actual value
 * - count_data_type: a *count_type_t which will receive the type of the
 *   data (for casting of count_data)
 *
 * NOTE: This function can be called anytime after the
 *       REACTION_DATA_OUTPUT has been either parsed or
 *       set up with API calls.
 *
 * Returns 1 on error and 0 on success
 *
 ************************************************************************/
MCELL_STATUS
mcell_get_counter_value(MCELL_STATE *state,
                        const char *counter_name,
                        int column_id,
                        double *count_data,
                        enum count_type_t *count_data_type) {
  struct output_column *column = NULL;
  if ((column = get_counter_trigger_column(state, counter_name, column_id)) ==
      NULL) {
    return MCELL_FAIL;
  }

  // if we happen to encounter trigger data we bail
  if (column-&gt;buffer[0].data_type == COUNT_TRIG_STRUCT) {
    return MCELL_FAIL;
  }

  // evaluate the expression and retrieve it
  eval_oexpr_tree(column-&gt;expr, 1);
  *count_data = (double)column-&gt;expr-&gt;value;
  *count_data_type = column-&gt;buffer[0].data_type;

  return MCELL_SUCCESS;
}

/******************************************************************************
 *
 * static helper functions
 *
 *****************************************************************************/

/**************************************************************************
 new_output_column:
    Create a new output column for an output set.

 In: Nothing
 Out: output column, or NULL if allocation fails
**************************************************************************/
struct output_column *new_output_column() {

  struct output_column *oc;
  oc = CHECKED_MALLOC_STRUCT(struct output_column,
                             &quot;reaction data output column&quot;);
  if (oc == NULL)
    return NULL;

  oc-&gt;initial_value = 0.0;
  oc-&gt;buffer = NULL;
  oc-&gt;expr = NULL;
  oc-&gt;next = NULL;

  return oc;
}

/**************************************************************************
 new_output_block:
    Allocate a new reaction data output block, with a specified buffer size.

 In: buffersize: requested buffer size
 Out: output block, or NULL if an error occurs
**************************************************************************/
struct output_block *new_output_block(int buffersize) {

  struct output_block *obp;
  obp =
      CHECKED_MALLOC_STRUCT(struct output_block, &quot;reaction data output block&quot;);
  if (obp == NULL)
    return NULL;

  obp-&gt;t = 0.0;
  obp-&gt;timer_type = OUTPUT_BY_STEP;
  obp-&gt;step_time = FOREVER;
  obp-&gt;time_list_head = NULL;
  obp-&gt;time_now = NULL;
  obp-&gt;buffersize = 0;
  obp-&gt;trig_bufsize = 0;
  obp-&gt;buf_index = 0;
  obp-&gt;data_set_head = NULL;

  /* COUNT buffer size might get modified later if there isn't that much to
   * output */
  /* TRIGGER buffer size won't get modified since we can't know what to expect
   */
  obp-&gt;buffersize = buffersize;
  obp-&gt;trig_bufsize = obp-&gt;buffersize;

  obp-&gt;time_array = CHECKED_MALLOC_ARRAY(double, obp-&gt;buffersize,
                                         &quot;reaction data output times array&quot;);
  if (obp-&gt;time_array == NULL) {
    free(obp);
    return NULL;
  }

  return obp;
}

/**************************************************************************
 set_reaction_output_timer_step:
    Set the output timer for reaction data output to a time step.

 In: parse_state: parser state
     obp:  output block whose timer is to be set
     step: time step interval
 Out: output timer is updated
**************************************************************************/
void set_reaction_output_timer_step(MCELL_STATE *state,
                                    struct output_block *obp, double step) {

  long long output_freq;
  obp-&gt;timer_type = OUTPUT_BY_STEP;

  obp-&gt;step_time = step;
  output_freq = (long long)(obp-&gt;step_time / state-&gt;time_unit);

  /* Clip the step time to a good range */
  if (output_freq &gt; state-&gt;iterations &amp;&amp; output_freq &gt; 1) {
    output_freq = (state-&gt;iterations &gt; 1) ? state-&gt;iterations : 1;
    obp-&gt;step_time = output_freq * state-&gt;time_unit;
    if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
      mcell_warn(&quot;output step time too long.\n  Setting output step time to &quot;
                 &quot;%g seconds.&quot;, obp-&gt;step_time);
  } else if (output_freq &lt; 1) {
    output_freq = 1;
    obp-&gt;step_time = output_freq * state-&gt;time_unit;
    if (state-&gt;notify-&gt;invalid_output_step_time != WARN_COPE)
      mcell_warn(&quot;output step time too short.\n  Setting output step time to &quot;
                 &quot;%g seconds.&quot;, obp-&gt;step_time);
  }

  /* Pick a good buffer size */
  long long n_output;
  if (state-&gt;chkpt_iterations)
    n_output = (long long)(state-&gt;chkpt_iterations / output_freq + 1);
  else
    n_output = (long long)(state-&gt;iterations / output_freq + 1);
  obp-&gt;buffersize = pick_buffer_size(state, obp, n_output);

  no_printf(&quot;Default output step time definition:\n&quot;);
  no_printf(&quot;  output step time = %g\n&quot;, obp-&gt;step_time);
  no_printf(&quot;  output buffersize = %u\n&quot;, obp-&gt;buffersize);
}

/**************************************************************************
 pick_buffer_size:
    Choose an appropriate output buffer size for our reaction output data,
    based on the total number of outputs expected and the requested buffer
    size.

 In: parse_state: parser state
     obp:  output block whose buffer_size to set
     n_output: maximum number of outputs expected
 Out: 0 on success, 1 on failure
**************************************************************************/
long long pick_buffer_size(MCELL_STATE *state, struct output_block *obp,
                           long long n_output) {
  if (state-&gt;chkpt_iterations)
    return min3ll(state-&gt;chkpt_iterations - state-&gt;start_iterations + 1, n_output,
                  obp-&gt;buffersize);
  else
    return min3ll(state-&gt;iterations - state-&gt;start_iterations + 1, n_output,
                  obp-&gt;buffersize);
}

/**************************************************************************
 set_reaction_output_timer_iterations:
    Set the output timer for reaction data output to a list of iterations.

 In: parse_state: parser state
     obp:  output block whose timer is to be set
     step_values: list of iterations
 Out: 0 on success, 1 on failure; output timer is updated
**************************************************************************/
int
set_reaction_output_timer_iterations(MCELL_STATE *state,
                                     struct output_block *obp,
                                     struct num_expr_list_head *step_values) {
  obp-&gt;timer_type = OUTPUT_BY_ITERATION_LIST;
  obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
  if (step_values-&gt;shared) {
    obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
    if (obp-&gt;time_list_head == NULL)
      return 1;
  } else {
    mcell_sort_numeric_list(step_values-&gt;value_head);
    obp-&gt;time_list_head = step_values-&gt;value_head;
  }
  obp-&gt;time_now = NULL;
  return 0;
}

/**************************************************************************
 set_reaction_output_timer_times:
    Set the output timer for reaction data output to a list of times.

 In: parse_state: parser state
     obp:  output block whose timer is to be set
     nstep: number of times
     step_values: list of times
 Out: output timer is updated
**************************************************************************/
int set_reaction_output_timer_times(MCELL_STATE *state,
                                    struct output_block *obp,
                                    struct num_expr_list_head *step_values) {
  obp-&gt;timer_type = OUTPUT_BY_TIME_LIST;
  obp-&gt;buffersize = pick_buffer_size(state, obp, step_values-&gt;value_count);
  if (step_values-&gt;shared) {
    obp-&gt;time_list_head = mcell_copysort_numeric_list(step_values-&gt;value_head);
    if (obp-&gt;time_list_head == NULL)
      return 1;
  } else {
    mcell_sort_numeric_list(step_values-&gt;value_head);
    obp-&gt;time_list_head = step_values-&gt;value_head;
  }
  obp-&gt;time_now = NULL;
  return 0;
}

/**************************************************************************
 output_block_finalize:
    Finalizes a reaction data output block, checking for errors, and allocating
    the output buffer.

 In: obp:  the output block to finalize
 Out: 0 on success, 1 on failure
**************************************************************************/
int output_block_finalize(struct output_block *obp) {
  struct output_set *os1;
  for (os1 = obp-&gt;data_set_head; os1 != NULL; os1 = os1-&gt;next) {
    /* Check for duplicated filenames */
    struct output_set *os2;
    for (os2 = os1-&gt;next; os2 != NULL; os2 = os2-&gt;next) {
      if (strcmp(os1-&gt;outfile_name, os2-&gt;outfile_name) == 0) {
        mcell_error(&quot;COUNT statements in the same reaction data &quot;
                    &quot;output block should have unique output file &quot;
                    &quot;names (\&quot;%s\&quot; appears more than once)&quot;,
                    os1-&gt;outfile_name);
        return MCELL_FAIL;
      }
    }

    /* Allocate buffers */
    struct output_column *oc;
    for (oc = os1-&gt;column_head; oc != NULL; oc = oc-&gt;next) {
      
      switch (oc-&gt;expr-&gt;expr_flags &amp; OEXPR_TYPE_MASK) {
      // Counting on meshes that don't exist at the beginning of the sim.
      case OEXPR_TYPE_UNDEF:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          &quot;reaction data output buffer&quot;);
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_UNSET;
          oc-&gt;buffer[i].val.cval = 'X';
        }
        break;
      case OEXPR_TYPE_INT:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          &quot;reaction data output buffer&quot;);
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_INT;
          oc-&gt;buffer[i].val.ival = 0;
        }
        break;

      case OEXPR_TYPE_DBL:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;buffersize,
                                          &quot;reaction data output buffer&quot;);
        for (u_int i = 0; i &lt; obp-&gt;buffersize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_DBL;
          oc-&gt;buffer[i].val.dval = 0.0;
        }
        break;

      case OEXPR_TYPE_TRIG:
        oc-&gt;buffer = CHECKED_MALLOC_ARRAY(struct output_buffer,
                                          obp-&gt;trig_bufsize,
                                          &quot;reaction data output buffer&quot;);
        for (u_int i = 0; i &lt; obp-&gt;trig_bufsize; ++i) {
          oc-&gt;buffer[i].data_type = COUNT_TRIG_STRUCT;
          oc-&gt;buffer[i].val.tval = CHECKED_MALLOC_STRUCT(
              struct output_trigger_data,
              &quot;reaction data output buffer&quot;);
          oc-&gt;buffer[i].val.tval-&gt;name = NULL;
        }
        break;

      default:
        mcell_error(&quot;Could not figure out what type of count data to store&quot;);
        return MCELL_FAIL;
      }
      if (oc-&gt;buffer == NULL)
        return MCELL_FAIL;
    }
  }

  return MCELL_SUCCESS;
}

/************************************************************************
 *
 * get_counter_trigger_column retrieves the output_column corresponding
 * to a given count or trigger statement.
 *
 ************************************************************************/
struct output_column *get_counter_trigger_column(MCELL_STATE *state,
                                                 const char *counter_name,
                                                 int column_id) {
  // retrieve the counter for the requested counter_name
  struct sym_entry *counter_sym =
      retrieve_sym(counter_name, state-&gt;counter_by_name);
  if (counter_sym == NULL) {
    mcell_log(&quot;Failed to retrieve symbol for counter %s.&quot;, counter_name);
    return NULL;
  }
  struct output_set *counter = (struct output_set *)(counter_sym-&gt;value);

  // retrieve the requested column
  struct output_column *column = counter-&gt;column_head;
  int count = 0;
  while (count &lt; column_id &amp;&amp; column != NULL) {
    count++;
    column = column-&gt;next;
  }
  if (count != column_id || column == NULL) {
    return NULL;
  }

  return column;
}


</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>chkpt.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

/**************************************************************************\
** File: chkpt.c
**
** Purpose: Writes and reads MCell checkpoint files.
**
*/

#include &quot;config.h&quot;

#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;

#include &quot;mcell_structs.h&quot;
#include &quot;mcell_reactions.h&quot;
#include &quot;nfsim_func.h&quot;
#include &quot;logging.h&quot;
#include &quot;vol_util.h&quot;
#include &quot;chkpt.h&quot;
#include &quot;grid_util.h&quot;
#include &quot;count_util.h&quot;
#include &quot;react.h&quot;
#include &quot;strfunc.h&quot;

/* MCell checkpoint API version */
#define CHECKPOINT_API 1

/* Endian-ness markers */
#define MCELL_BIG_ENDIAN 16
#define MCELL_LITTLE_ENDIAN 17

/* Checkpoint section commands */
#define CURRENT_TIME_CMD 1
#define CURRENT_ITERATION_CMD 2
#define CHKPT_SEQ_NUM_CMD 3
#define RNG_STATE_CMD 4
#define MCELL_VERSION_CMD 5
#define SPECIES_TABLE_CMD 6
#define MOL_SCHEDULER_STATE_CMD 7
#define BYTE_ORDER_CMD 8
#define NUM_CHKPT_CMDS 9
#define CHECKPOINT_API_CMD 10

/* Newbie flags */
#define HAS_ACT_NEWBIE 1
#define HAS_NOT_ACT_NEWBIE 0

#define HAS_ACT_CHANGE 1
#define HAS_NOT_ACT_CHANGE 0

/* these are needed for the chkpt signal handler */
int *chkpt_continue_after_checkpoint;
const char **chkpt_initialization_state;
enum checkpoint_request_type_t *chkpt_checkpoint_requested;

/* ============================= */
/* General error-checking macros */

/* If 'op' is true, fail with a message about corrupt checkpoint data.  msg,
 * ... are printf-style. */
#define DATACHECK(op, msg, ...)                                                \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_warn(&quot;Corrupted checkpoint data: &quot; msg, ##__VA_ARGS__);            \
      return 1;                                                                \
    }                                                                          \
  } while (0)

/* If 'op' is true, fail with a message about an internal error.  msg, ... are
 * printf-style. */
#define INTERNALCHECK(op, msg, ...)                                            \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_warn(&quot;%s internal: &quot; msg, __func__, ##__VA_ARGS__);                \
      return 1;                                                                \
    }                                                                          \
  } while (0)

/* Wrapper for an I/O (write) operation to print out appropriate error messages
 * in case of failure. */
#define WRITECHECK(op, sect)                                                   \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_perror_nodie(errno, &quot;Error while writing '%s' to checkpoint file&quot;, \
                         SECTNAME);                                            \
      return 1;                                                                \
    }                                                                          \
  } while (0)

/* Write a raw field to the output stream. */
#define WRITEFIELD(f) WRITECHECK(fwrite(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)

/* Write a raw array of fields to the output stream. */
#define WRITEARRAY(f, len)                                                     \
  WRITECHECK(fwrite(f, sizeof(f[0]), (len), fs) != (len), SECTNAME)

/* Write an unsigned integer to the output stream in endian- and
 * size-independent format. */
#define WRITEUINT(f) WRITECHECK(write_varint(fs, (f)), SECTNAME)

/* Write a signed integer to the output stream in endian- and size-independent
 * format. */
#define WRITEINT(f) WRITECHECK(write_svarint(fs, (f)), SECTNAME)

/* Write an unsigned 64-bit niteger to the output stream in endian- and
 * size-independent format. */
#define WRITEUINT64(f) WRITECHECK(write_varintl(fs, (f)), SECTNAME)

/* Write a string to the output stream as a count followed by raw ASCII
 * character data. */
#define WRITESTRING(f)                                                         \
  do {                                                                         \
    uint32_t len = (uint32_t)strlen(f);                                        \
    WRITEUINT(len);                                                            \
    WRITEARRAY(f, len);                                                        \
  } while (0)

/* Wrapper for an I/O (read) operation to print out appropriate error messages
 * in case of failure. */
#define READCHECK(op, sect)                                                    \
  do {                                                                         \
    if (op) {                                                                  \
      mcell_perror_nodie(                                                      \
          errno, &quot;Error while reading '%s' from checkpoint file&quot;, SECTNAME);   \
      return 1;                                                                \
    }                                                                          \
  } while (0)

/* Read a raw field from the input stream (i.e. never byteswap). */
#define READFIELDRAW(f) READCHECK(fread(&amp;(f), sizeof(f), 1, fs) != 1, SECTNAME)

/* Maybe byteswap a field. */
#define READBSWAP(f)                                                           \
  do {                                                                         \
    if (state-&gt;byte_order_mismatch)                                            \
      byte_swap(&amp;(f), sizeof(f));                                              \
  } while (0)

/* Read a field from the input stream, byteswapping if needed. */
#define READFIELD(f)                                                           \
  do {                                                                         \
    READFIELDRAW(f);                                                           \
    READBSWAP(f);                                                              \
  } while (0)

/* Read a raw array of chars from the input stream. */
#define READSTRING(f, len)                                                     \
  do {                                                                         \
    READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
    f[len] = '\0';                                                             \
  } while (0)

/* Read an array of items from the input stream, byteswapping if needed. */
#define READARRAY(f, len)                                                      \
  do {                                                                         \
    int i;                                                                     \
    READCHECK(fread(f, sizeof(f[0]), (len), fs) != (len), SECTNAME);           \
    for (i = 0; i &lt; len; ++i)                                                  \
      READBSWAP(f[i]);                                                         \
  } while (0)

/* Read an unsigned integer from the input stream in endian- and
 * size-independent format. */
#define READUINT(f) READCHECK(read_varint(fs, &amp;(f)), SECTNAME)

/* Read a signed integer from the input stream in endian- and size-independent
 * format. */
#define READINT(f) READCHECK(read_svarint(fs, &amp;(f)), SECTNAME)

/* Read an unsigned 64-bit niteger from the input stream in endian- and
 * size-independent format. */
#define READUINT64(f) READCHECK(read_varintl(fs, &amp;(f)), SECTNAME)

/**
 * Structure to hold any requisite state during the checkpoint read process.
 */
struct chkpt_read_state {
  byte byte_order_mismatch;
};

/* Handlers for individual checkpoint commands */
static int read_current_time_seconds(struct volume *world, FILE *fs,
<A NAME="0"></A>                                     struct chkpt_read_state *state);
static int read_current_iteration(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1342-0.html#0',2,'match1342-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static int read_chkpt_seq_num(struct volume *world, FILE *fs,
                              struct chkpt_read_state *state);
static int read_rng_state(struct volume *world, FILE *fs,
                          struct chkpt_read_state *state);
static int read_byte_order(FILE *fs, struct chkpt_read_state *state);
static int read_mcell_version(FILE *fs, struct chkpt_read_state *state);</B></FONT>
static int read_api_version(FILE *fs, struct chkpt_read_state *state,
  uint32_t *api_version);
static int read_species_table(struct volume *world, FILE *fs);
static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
                                         struct chkpt_read_state *state,
                                         uint32_t api_version);
static int write_mcell_version(FILE *fs, const char *mcell_version);
static int write_current_time_seconds(FILE *fs, double current_time_seconds);
static int write_current_iteration(FILE *fs, long long current_iterations,
                                   double current_time_seconds);
static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num);
static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng);
static int write_species_table(FILE *fs, int n_species,
                               struct species **species_list);
static int write_mol_scheduler_state_real(FILE *fs,
                                          struct storage_list *storage_head,
                                          double simulation_start_seconds,
                                          double start_iterations,
                                          double time_unit);
static int write_byte_order(FILE *fs);

static int write_api_version(FILE *fs);

static int create_molecule_scheduler(struct storage_list *storage_head,
                                     long long start_iterations);

/********************************************************************
 * this function initializes to global variables
 *
 *     int chkpt_continue_after_checkpoint
 *     char *chkpt_initialization_state
 *     enum checkpoint_request_type_t chkpt_checkpoint_requested
 *
 * needed by the signal handler chkpt_signal_handler
*********************************************************************/
int set_checkpoint_state(struct volume *world) {
  chkpt_continue_after_checkpoint = &amp;world-&gt;continue_after_checkpoint;
  chkpt_initialization_state = &amp;world-&gt;initialization_state;
  chkpt_checkpoint_requested = &amp;world-&gt;checkpoint_requested;

  return 0;
}

/***************************************************************************
 chkpt_signal_handler:
 In:  signo - the signal number that triggered the checkpoint
 Out: Records the checkpoint request

 Note: This function is not to be called during normal program execution.  It is
 registered as a signal handler for SIGUSR1, SIGUSR2, and possibly SIGALRM
 signals.
***************************************************************************/
void chkpt_signal_handler(int signo) {
  if (*chkpt_initialization_state) {
    if (signo != SIGALRM || !*chkpt_continue_after_checkpoint) {
      mcell_warn(&quot;Checkpoint requested while %s.  Exiting.&quot;,
                 *chkpt_initialization_state);
      exit(EXIT_FAILURE);
    }
  }

#ifndef _WIN64 /* fixme: Windows does not support USR signals */
  if (signo == SIGUSR1)
    *chkpt_checkpoint_requested = CHKPT_SIGNAL_CONT;
  else if (signo == SIGUSR2)
    *chkpt_checkpoint_requested = CHKPT_SIGNAL_EXIT;
  else
#endif
      if (signo == SIGALRM) {
    if (*chkpt_continue_after_checkpoint)
      *chkpt_checkpoint_requested = CHKPT_ALARM_CONT;
    else
      *chkpt_checkpoint_requested = CHKPT_ALARM_EXIT;
  }
}

/***************************************************************************
 create_chkpt:
 In:  filename - the name of the checkpoint file to create
 Out: returns 1 on failure, 0 on success.  On success, checkpoint file is
      written to the appropriate filename.  On failure, the old checkpoint file
      is left unmolested.
***************************************************************************/
int create_chkpt(struct volume *world, char const *filename) {
  FILE *outfs = NULL;

  /* Create temporary filename */
  char *tmpname = alloc_sprintf(&quot;%s.tmp&quot;, filename);
  if (tmpname == NULL)
    mcell_allocfailed(&quot;Out of memory creating temporary checkpoint filename &quot;
                      &quot;for checkpoint '%s'.&quot;,
                      filename);

  /* Open the file */
  if ((outfs = fopen(tmpname, &quot;wb&quot;)) == NULL)
    mcell_perror(errno, &quot;Failed to write checkpoint file '%s'&quot;, tmpname);

  /* Write checkpoint */
  world-&gt;current_time_seconds = world-&gt;current_time_seconds +
      (world-&gt;current_iterations - world-&gt;start_iterations) * world-&gt;time_unit;
  // These are normally set when reading a checkpoint. They need to be set here
  // in case we checkpoint without exiting (i.e. using NOEXIT). Otherwise,
  // world-&gt;current_time_seconds will be set incorrectly upon subsequent calls
  // to create_chkpt
  world-&gt;start_iterations = world-&gt;current_iterations;
  world-&gt;simulation_start_seconds = world-&gt;current_time_seconds;
  if (write_chkpt(world, outfs))
    mcell_error(&quot;Failed to write checkpoint file %s\n&quot;, filename);
  fclose(outfs);

  /* keep previous checkpoint file if requested by appending the current
   * iteration */
  if (world-&gt;keep_chkpts) {
    /* check if previous checkpoint file exists - may not exist initially */
    struct stat buf;
    if (stat(filename, &amp;buf) == 0) {
      char *keepName = alloc_sprintf(&quot;%s.%lld&quot;, filename, world-&gt;current_iterations);
      if (keepName == NULL) {
        mcell_allocfailed(&quot;Out of memory creating filename for checkpoint&quot;);
      }

      if (rename(filename, keepName) != 0) {
        mcell_error(&quot;Failed to save previous checkpoint file %s to %s&quot;,
                    filename, keepName);
      }
      free(keepName);
    }
  }

  /* Move it into place */
  if (rename(tmpname, filename) != 0)
    mcell_error(&quot;Successfully wrote checkpoint to file '%s', but failed to &quot;
                &quot;atomically replace checkpoint file '%s'.\nThe simulation may &quot;
                &quot;be resumed from '%s'.&quot;,
                tmpname, filename, tmpname);

  free(tmpname);
  return 0;
}

/***************************************************************************
 write_varintl: Size- and endian-agnostic saving of unsigned long long values.
 In:  fs - file handle to which to write
      val - value to write to file
 Out: returns 1 on failure, 0 on success.  On success, value is written to file.
***************************************************************************/
static int write_varintl(FILE *fs, unsigned long long val) {
  unsigned char buffer[40];
  size_t len = 0;

  buffer[sizeof(buffer) - 1 - len] = val &amp; 0x7f;
  val &gt;&gt;= 7;
  ++len;

  while (val != 0) {
    buffer[sizeof(buffer) - 1 - len] = (val &amp; 0x7f) | 0x80;
    val &gt;&gt;= 7;
    ++len;
  }

  if (fwrite(buffer + sizeof(buffer) - len, 1, len, fs) != len)
    return 1;
  return 0;
}

/***************************************************************************
 write_svarintl: Size- and endian-agnostic saving of signed long long values.
 In:  fs - file handle to which to write
      val - value to write to file
 Out: returns 1 on failure, 0 on success.  On success, value is written to file.
***************************************************************************/
static int write_svarintl(FILE *fs, long long val) {
  if (val &lt; 0)
    return write_varintl(fs, (unsigned long long)(((-val) &lt;&lt; 1) | 1));
  else
    return write_varintl(fs, (unsigned long long)(((val) &lt;&lt; 1)));
}

/***************************************************************************
 read_varintl: Size- and endian-agnostic loading of unsigned long long values.
 In:  fs - file handle from which to read
      dest - pointer to value to receive data from file
 Out: returns 1 on failure, 0 on success.  On success, value is read from file.
***************************************************************************/
static int read_varintl(FILE *fs, unsigned long long *dest) {
  unsigned long long accum = 0;
  unsigned char ch;
  do {
    if (fread(&amp;ch, 1, 1, fs) != 1)
      return 1;
    accum &lt;&lt;= 7;
    accum |= ch &amp; 0x7f;
  } while (ch &amp; 0x80);

  *dest = accum;
  return 0;
}

/***************************************************************************
 read_svarintl: Size- and endian-agnostic loading of signed long long values.
 In:  fs - file handle from which to read
      dest - pointer to value to receive data from file
 Out: returns 1 on failure, 0 on success.  On success, value is read from file.
***************************************************************************/
static int read_svarintl(FILE *fs, long long *dest) {
  unsigned long long tmp = 0;
  if (read_varintl(fs, &amp;tmp))
    return 1;

  if (tmp &amp; 1)
    *dest = (long long)-(tmp &gt;&gt; 1);
  else
    *dest = (long long)(tmp &gt;&gt; 1);
  return 0;
}

/***************************************************************************
 write_varint: Size- and endian-agnostic saving of unsigned int values.
 In:  fs - file handle to which to write
      val - value to write to file
 Out: returns 1 on failure, 0 on success.  On success, value is written to file.
***************************************************************************/
static int write_varint(FILE *fs, unsigned int val) {
  return write_varintl(fs, (unsigned long long)val);
}

/***************************************************************************
 write_svarint: Size- and endian-agnostic saving of signed int values.
 In:  fs - file handle to which to write
      val - value to write to file
 Out: returns 1 on failure, 0 on success.  On success, value is written to file.
***************************************************************************/
static int write_svarint(FILE *fs, int val) {
  return write_svarintl(fs, (long long)val);
}

/***************************************************************************
 read_varint: Size- and endian-agnostic loading of unsigned int values.
 In:  fs - file handle from which to read
      dest - pointer to value to receive data from file
 Out: returns 1 on failure, 0 on success.  On success, value is read from file.
***************************************************************************/
static int read_varint(FILE *fs, unsigned int *dest) {
  unsigned long long val;
  if (read_varintl(fs, &amp;val))
    return 1;

  *dest = val;
  if ((unsigned long long)*dest != val)
    return 1;

  return 0;
}

/***************************************************************************
 read_svarint: Size- and endian-agnostic loading of signed int values.
 In:  fs - file handle from which to read
      dest - pointer to value to receive data from file
 Out: returns 1 on failure, 0 on success.  On success, value is read from file.
***************************************************************************/
static int read_svarint(FILE *fs, int *dest) {
  long long val;
  if (read_svarintl(fs, &amp;val))
    return 1;

  *dest = val;
  if ((long long)*dest != val)
    return 1;

  return 0;
}

/***************************************************************************
 write_chkpt:
 In:  fs - checkpoint file to write to.
 Out: Writes the checkpoint file with all information needed for the
      simulation to restart.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
int write_chkpt(struct volume *world, FILE *fs) {
  return (write_byte_order(fs) ||
          write_api_version(fs) ||
          write_mcell_version(fs, world-&gt;mcell_version) ||
          write_current_time_seconds(fs, world-&gt;current_time_seconds) ||
          write_current_iteration(fs, world-&gt;current_iterations,
                                  world-&gt;current_time_seconds) ||
          write_chkpt_seq_num(fs, world-&gt;chkpt_seq_num) ||
          write_rng_state(fs, world-&gt;seed_seq, world-&gt;rng) ||
          write_species_table(fs, world-&gt;n_species, world-&gt;species_list) ||
          write_mol_scheduler_state_real(fs, world-&gt;storage_head,
              world-&gt;simulation_start_seconds, world-&gt;start_iterations,
              world-&gt;time_unit));
}

/***************************************************************************
 read_preamble:
    Read the required first two sections of an MCell checkpoint file.

 In:  fs:  checkpoint file to read from.
 Out: Reads preamble from checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_preamble(FILE *fs, struct chkpt_read_state *state, uint32_t *api_version) {
  byte cmd;

  /* Read and handle required first command (byte order). */
  size_t count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  DATACHECK(feof(fs), &quot;Checkpoint file is empty.&quot;);
  if (count != sizeof(cmd)) {
    return 1; 
  }
  DATACHECK(cmd != BYTE_ORDER_CMD,
            &quot;Checkpoint file does not have the required byte-order command.&quot;);
  if (read_byte_order(fs, state))
    return 1;

  /* Read the checkpoint API version if present. If it is missing we assume
   * the lagacy API version 0 */
  count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  DATACHECK(feof(fs), &quot;Checkpoint file is too short (no api or version info).&quot;);
  if (count != sizeof(cmd)) {
    return 1; 
  }
  if (cmd != CHECKPOINT_API_CMD) {
    *api_version = 0;
  } else {
    read_api_version(fs, state, api_version);
    count = fread(&amp;cmd, 1, sizeof(cmd), fs);
  }

  /* Read and handle required second command (version). */
  DATACHECK(feof(fs), &quot;Checkpoint file is too short (no version info).&quot;);
  if (count != sizeof(cmd)) {
    return 1; 
  }
  DATACHECK(cmd != MCELL_VERSION_CMD,
            &quot;Checkpoint file does not contain required MCell version command.&quot;);
  return read_mcell_version(fs, state);
}

/***************************************************************************
 read_chkpt:
 In:  fs - checkpoint file to read from.
 Out: Reads checkpoint file.  Sets the values of multiple parameters
      in the simulation.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
int read_chkpt(struct volume *world, FILE *fs, bool only_time_and_iter) {
  byte cmd;

  int seen_section[NUM_CHKPT_CMDS];
  memset(seen_section, 0, sizeof(int)*NUM_CHKPT_CMDS);

  struct chkpt_read_state state;
  state.byte_order_mismatch = 0;

  /* Read the required pre-amble sections */
  uint32_t api_version;
  if (read_preamble(fs, &amp;state, &amp;api_version))
    return 1;
  seen_section[BYTE_ORDER_CMD] = 1;
  seen_section[MCELL_VERSION_CMD] = 1;

  bool time_read = false;
  bool iteration_read = false;

  /* Handle all other commands */
  while (1) {
    size_t count = fread(&amp;cmd, sizeof(cmd), 1, fs);
    if (feof(fs)) {
      break;
    }
    if (count != sizeof(cmd)) {
      return 1; 
    }

    /* Check that it's a valid command-type */
    DATACHECK(cmd &lt; 1 || cmd &gt;= NUM_CHKPT_CMDS,
              &quot;Unrecognized command-type in checkpoint file.  &quot;
              &quot;Checkpoint file cannot be loaded.&quot;);

    /* Check that we haven't seen it already */
    DATACHECK(seen_section[cmd], &quot;Duplicate command-type in checkpoint file.&quot;);
    seen_section[cmd] = 1;

    /* Process normal commands */
    switch (cmd) {
    case CURRENT_TIME_CMD:
      if (read_current_time_seconds(world, fs, &amp;state)) {
        return 1;
      }
      time_read = true;
      if (only_time_and_iter &amp;&amp; iteration_read) {
        return 0;
      }
      break;

    case CURRENT_ITERATION_CMD:
      if (read_current_iteration(world, fs, &amp;state)) {
        return 1;
      }
      iteration_read = true;
      if (only_time_and_iter &amp;&amp; time_read) {
        return 0;
      }
      // do not create scheduler if we are reading just time and iteration
      if (!only_time_and_iter) {
        if (create_molecule_scheduler(world-&gt;storage_head, world-&gt;start_iterations)) {
          return 1;
        }
      }
      break;

    case CHKPT_SEQ_NUM_CMD:
      if (read_chkpt_seq_num(world, fs, &amp;state))
        return 1;
      break;

    case RNG_STATE_CMD:
      if (read_rng_state(world, fs, &amp;state))
        return 1;
      break;

    case SPECIES_TABLE_CMD:
      if (read_species_table(world, fs))
        return 1;
      break;

    case MOL_SCHEDULER_STATE_CMD:
      DATACHECK(
          !seen_section[CURRENT_ITERATION_CMD],
          &quot;Current iteration command must precede molecule scheduler command.&quot;);
      DATACHECK(
          !seen_section[SPECIES_TABLE_CMD],
          &quot;Species table command must precede molecule scheduler command.&quot;);
      if (read_mol_scheduler_state_real(world, fs, &amp;state, api_version))
        return 1;
      break;

    case BYTE_ORDER_CMD:
    case MCELL_VERSION_CMD:
    default:
      /* We should have already filtered out these cases, so if we get here,
       * an internal error has occurred. */
      assert(0);
      break;
    }
  }

  /* Check for required sections */
  DATACHECK(!seen_section[CURRENT_TIME_CMD],
            &quot;Current time command is not present.&quot;);
  DATACHECK(!seen_section[CHKPT_SEQ_NUM_CMD],
            &quot;Checkpoint sequence number command is not present.&quot;);
  DATACHECK(!seen_section[RNG_STATE_CMD], &quot;RNG state command is not present.&quot;);
  DATACHECK(!seen_section[MOL_SCHEDULER_STATE_CMD],
            &quot; Molecule scheduler state command is not present.&quot;);

  return 0;
}

/***************************************************************************
 write_byte_order:
 In:  fs - checkpoint file to write to.
 Out: Writes byte order of the machine that creates checkpoint file
         to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_byte_order(FILE *fs) {
  static const char SECTNAME[] = &quot;byte order&quot;;
  static const byte cmd = BYTE_ORDER_CMD;
#ifdef WORDS_BIGENDIAN
  static const unsigned int byte_order = MCELL_BIG_ENDIAN;
#else
  static const unsigned int byte_order = MCELL_LITTLE_ENDIAN;
#endif

  WRITEFIELD(cmd);
  WRITEFIELD(byte_order);
  return 0;
}

/***************************************************************************
 read_byte_order:
 In:  fs - checkpoint file to read from.
 Out: Reads byte order  from the checkpoint file.
      Returns 1 on error, and 0 - on success.
      Reports byte order mismatch between the machines that writes to and
        reads from the checkpoint file,
***************************************************************************/
static int read_byte_order(FILE *fs, struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;byte order&quot;;
#ifdef WORDS_BIGENDIAN
  static const unsigned int byte_order_present = MCELL_BIG_ENDIAN;
#else
  static const unsigned int byte_order_present = MCELL_LITTLE_ENDIAN;
#endif

  unsigned int byte_order_read;
  READFIELDRAW(byte_order_read);

  /* find whether there is mismatch between two machines */
  state-&gt;byte_order_mismatch = (byte_order_read != byte_order_present);

  return 0;
}

/***************************************************************************
 write_api_version:
 In:  fs - checkpoint file to write to.
 Out: Writes the current checkpoint file api version to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_api_version(FILE *fs) {
  static const char SECTNAME[] = &quot;api version&quot;;
  static const byte cmd = CHECKPOINT_API_CMD;
  uint32_t api_version = CHECKPOINT_API;

  WRITEFIELD(cmd);
  WRITEFIELD(api_version);
  return 0;
}

/***************************************************************************
 read_api_version:
 In:  fs - checkpoint file to read from.
 Out: Reads the api version of the current checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_api_version(FILE *fs, struct chkpt_read_state *state,
  uint32_t *api_version) {
  static const char SECTNAME[] = &quot;api version&quot;;
  READFIELD(*api_version);
  return 0;
}

/***************************************************************************
 write_mcell_version:
 In:  fs - checkpoint file to write to.
 Out: MCell3 software version is written to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_mcell_version(FILE *fs, const char *mcell_version) {
  static const char SECTNAME[] = &quot;MCell version&quot;;
  static const byte cmd = MCELL_VERSION_CMD;

  uint32_t len = (uint32_t)strlen(mcell_version);

  WRITEFIELD(cmd);
  WRITEFIELD(len);
  WRITEARRAY(mcell_version, len);
  return 0;
}

/***************************************************************************
 read_mcell_version:
 In:  fs - checkpoint file to read from.
 Out: MCell3 software version is read from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_mcell_version(FILE *fs, struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;MCell version&quot;;

  /* Read and error-check the MCell version string length */
  unsigned int version_length;
  READFIELD(version_length);
  DATACHECK(version_length &gt;= 100000,
            &quot;Length field for MCell version is too long (%u).&quot;, version_length);

  char* mcell_version = new char[version_length + 1];
  READSTRING(mcell_version, version_length);

  mcell_log(&quot;Checkpoint file was created with MCell Version %s.&quot;,
            mcell_version);
  delete mcell_version;

  return 0;
}

/***************************************************************************
 write_current_time_seconds:
 In:  fs - checkpoint file to write to.
 Out: Writes current real time (in the terms of sec) in the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_current_time_seconds(FILE *fs, double current_time_seconds) {
  static const char SECTNAME[] = &quot;current real time&quot;;
  static const byte cmd = CURRENT_TIME_CMD;

  WRITEFIELD(cmd);
  WRITEFIELD(current_time_seconds);
  return 0;
}

/***************************************************************************
 read_current_time_seconds:
 In:  fs - checkpoint file to read from.
 Out: Reads current real time (in the terms of sec) from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_current_time_seconds(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;current real time&quot;;
  READFIELD(world-&gt;simulation_start_seconds);
  return 0;
}

/***************************************************************************
 create_molecule_scheduler:
 In:  none.
 Out: Creates global molecule scheduler using checkpoint file values.
      Returns 0 on success. Error message and exit on failure.
***************************************************************************/
static int create_molecule_scheduler(struct storage_list *storage_head,
                                     long long start_iterations) {
  struct storage_list *stg;
  for (stg = storage_head; stg != NULL; stg = stg-&gt;next) {
    if ((stg-&gt;store-&gt;timer = create_scheduler(1.0, 100.0, 100, start_iterations)) ==
        NULL) {
      mcell_error(&quot;Out of memory while creating molecule scheduler.&quot;);
    }
    stg-&gt;store-&gt;current_time = start_iterations;
  }

  return 0;
}

/***************************************************************************
 write_current_iteration:
 In:  fs - checkpoint file to write to.
 Out: Writes current iteration number to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_current_iteration(FILE *fs, long long current_iterations,
                                   double current_time_seconds) {
  static const char SECTNAME[] = &quot;current iteration&quot;;
  static const byte cmd = CURRENT_ITERATION_CMD;

  WRITEFIELD(cmd);
  WRITEFIELD(current_iterations);
  WRITEFIELD(current_time_seconds);
  return 0;
}

/***************************************************************************
 read_current_iteration:
 In:  fs - checkpoint file to read from.
 Out: Reads current iteration number from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_current_iteration(struct volume *world, FILE *fs,
                                  struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;current iteration&quot;;
  READFIELD(world-&gt;start_iterations);
  READFIELD(world-&gt;chkpt_start_time_seconds);
  world-&gt;current_time_seconds = world-&gt;chkpt_start_time_seconds;
  return 0;
}

/***************************************************************************
 write_chkpt_seq_num:
 In:  fs - checkpoint file to write to.
 Out: Writes checkpoint sequence number to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_chkpt_seq_num(FILE *fs, u_int chkpt_seq_num) {
  static const char SECTNAME[] = &quot;checkpoint sequence number&quot;;
  static const byte cmd = CHKPT_SEQ_NUM_CMD;

  WRITEFIELD(cmd);
  WRITEFIELD(chkpt_seq_num);
  return 0;
}

/***************************************************************************
 read_chkpt_seq_num:
 In:  fs - checkpoint file to read from.
 Out: Reads checkpoint sequence number from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_chkpt_seq_num(struct volume *world, FILE *fs,
                              struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;checkpoint sequence number&quot;;
  READFIELD(world-&gt;chkpt_seq_num);
  ++world-&gt;chkpt_seq_num;
  return 0;
}

/***************************************************************************
 write_an_rng_state:

  In:  fs: checkpoint file to write to.
       rng: rng whose state to write
  Out: Writes random number generator state to the checkpoint file.
       Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_an_rng_state(FILE *fs, struct rng_state *rng) {
  static const char SECTNAME[] = &quot;RNG state&quot;;

#ifdef USE_MINIMAL_RNG
  static const char RNG_MINRNG = 'M';
  WRITEFIELD(RNG_MINRNG);
  WRITEFIELD(rng-&gt;a);
  WRITEFIELD(rng-&gt;b);
  WRITEFIELD(rng-&gt;c);
  WRITEFIELD(rng-&gt;d);
#else
  static const char RNG_ISAAC = 'I';
  WRITEFIELD(RNG_ISAAC);
  WRITEUINT(rng-&gt;randcnt);
  WRITEFIELD(rng-&gt;aa);
  WRITEFIELD(rng-&gt;bb);
  WRITEFIELD(rng-&gt;cc);
  WRITEARRAY(rng-&gt;randrsl, RANDSIZ);
  WRITEARRAY(rng-&gt;mm, RANDSIZ);
#endif
  return 0;
}

/***************************************************************************
 write_rng_state:
 In:  fs - checkpoint file to write to.
 Out: Writes random number generator state to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_rng_state(FILE *fs, u_int seed_seq, struct rng_state *rng) {
  static const char SECTNAME[] = &quot;RNG state&quot;;
  static const byte cmd = RNG_STATE_CMD;

  WRITEFIELD(cmd);
  WRITEUINT(seed_seq);
  if (write_an_rng_state(fs, rng))
    return 1;
  return 0;
}

/***************************************************************************
 read_an_rng_state:
 In:  fs: checkpoint file to read from.
      state: contextual state for reading checkpoint file
      rng: pointer to RNG state to read
 Out: Reads random number generator state from the checkpoint file.
     Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_an_rng_state(FILE *fs, struct chkpt_read_state *state,
                             struct rng_state *rng) {
  static const char SECTNAME[] = &quot;RNG state&quot;;

#ifdef USE_MINIMAL_RNG
  static const char RNG_MINRNG = 'M';
  char rngtype;
  READFIELD(rngtype);
  DATACHECK(rngtype != RNG_MINRNG, &quot;Invalid RNG type stored in checkpoint file &quot;
                                   &quot;(in this version of MCell, only Bob &quot;
                                   &quot;Jenkins' \&quot;small PRNG\&quot; is supported).&quot;);
  READFIELD(rng-&gt;a);
  READFIELD(rng-&gt;b);
  READFIELD(rng-&gt;c);
  READFIELD(rng-&gt;d);

#else
  static const char RNG_ISAAC = 'I';
  char rngtype;
  READFIELD(rngtype);
  DATACHECK(rngtype != RNG_ISAAC, &quot;Invalid RNG type stored in checkpoint file &quot;
                                  &quot;(in this version of MCell, only ISAAC64 is &quot;
                                  &quot;supported).&quot;);

  READUINT(rng-&gt;randcnt);
  READFIELD(rng-&gt;aa);
  READFIELD(rng-&gt;bb);
  READFIELD(rng-&gt;cc);
  READARRAY(rng-&gt;randrsl, RANDSIZ);
  READARRAY(rng-&gt;mm, RANDSIZ);
  rng-&gt;rngblocks = 1;
#endif

  return 0;
}

/***************************************************************************
 read_rng_state:
 In:  fs - checkpoint file to read from.
 Out: Reads random number generator state from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_rng_state(struct volume *world, FILE *fs,
                          struct chkpt_read_state *state) {
  static const char SECTNAME[] = &quot;RNG state&quot;;

  /* Load seed_seq from chkpt file to compare with seed_seq from command line.
   * If seeds match, we will continue with the saved RNG state from the chkpt
   * file, otherwise, we'll reinitialize rng to beginning of new seed sequence.
   */
  unsigned int old_seed;
  READUINT(old_seed);

  /* Whether we're going to use it or not, we need to read the RNG state in
   * order to advance to the next cmd in the chkpt file.
   */
  if (read_an_rng_state(fs, state, world-&gt;rng))
    return 1;

  /* Reinitialize rngs to beginning of new seed sequence, if necessary. */
  if (world-&gt;seed_seq != old_seed)
    rng_init(world-&gt;rng, world-&gt;seed_seq);

  return 0;
}

/***************************************************************************
 write_species_table:
 In:  fs - checkpoint file to write to.
 Out: Writes species data to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_species_table(FILE *fs, int n_species,
                               struct species **species_list) {
  static const char SECTNAME[] = &quot;species table&quot;;
  static const byte cmd = SPECIES_TABLE_CMD;

  WRITEFIELD(cmd);

  /* Write total number of existing species with at least one representative. */
  unsigned int non_empty_species_count = 0;
  int i;
  for (i = 0; i &lt; n_species; i++) {
    if (species_list[i]-&gt;population &gt; 0)
      ++non_empty_species_count;
  }
  WRITEUINT(non_empty_species_count);

  /* Write out all species which have at least one representative. */
  unsigned int external_species_id = 0;
  for (i = 0; i &lt; n_species; i++) {
    if (species_list[i]-&gt;population == 0)
      continue;

    /* Write species name and external id. */
    WRITESTRING(species_list[i]-&gt;sym-&gt;name);
    WRITEUINT(external_species_id);

    /* Allocate and write the external species id for this species.  Stored
     * value is used in wrote_mol_scheduler_state to assign external species
     * ids to mols as they are written out. */
    species_list[i]-&gt;chkpt_species_id = external_species_id++;
  }

  return 0;
}

/***************************************************************************
 read_species_table:
 In:  fs - checkpoint file to read from.
 Out: Reads species data from the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int read_species_table(struct volume *world, FILE *fs) {
  static const char SECTNAME[] = &quot;species table&quot;;

  /* Read total number of species contained in checkpoint file. */
  unsigned int total_species;
  READUINT(total_species);

  /* Scan over species table, reading in species data */
  for (unsigned int i = 0; i &lt; total_species; i++) {
    unsigned int species_name_length;
    READUINT(species_name_length);

    /* Jed, 2007-07-05: This check guards against the security flaw caused by
     * allocating a variable-length array on the stack.  We should have
     * similar checks whenever we allocate a stack buffer based upon a
     * user-supplied value rather than upon an actual count.
     */
    DATACHECK(
        species_name_length &gt;= 100000,
        &quot;Species table has species name greater than 100000 characters (%u).&quot;,
        species_name_length);

    /* Read species fields. */
    char* species_name = new char[species_name_length + 1];
    unsigned int external_species_id;

    READSTRING(species_name, species_name_length);
    READUINT(external_species_id);

    /* find this species among world-&gt;species */
    int j;
    for (j = 0; j &lt; world-&gt;n_species; j++) {
      if ((strcmp(world-&gt;species_list[j]-&gt;sym-&gt;name, species_name) == 0)) {
        world-&gt;species_list[j]-&gt;chkpt_species_id = external_species_id;
        break;
      }
    }
    DATACHECK(j == world-&gt;n_species, &quot;Checkpoint file contains data for &quot;
                                     &quot;species '%s', which does not exist in &quot;
                                     &quot;this simulation.&quot;,
              species_name);

    delete species_name;
  }

  return 0;
}

/***************************************************************************
 count_items_in_scheduler:
 In:  None
 Out: Number of non-defunct molecules in the molecule scheduler
***************************************************************************/
unsigned long long
count_items_in_scheduler(struct storage_list *storage_head) {
  unsigned long long total_items = 0;

  for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
    for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
         shp = shp-&gt;next_scale) {
      for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
        for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head[i];
             aep != NULL; aep = aep-&gt;next) {
          struct abstract_molecule *amp = (struct abstract_molecule *)aep;
          if (amp-&gt;properties == NULL)
            continue;

          /* There should never be a surface class in the scheduler... */
          assert(!(amp-&gt;properties-&gt;flags &amp; IS_SURFACE));
          ++total_items;
        }
      }
    }
  }

  return total_items;
}

/***************************************************************************
 write_mol_scheduler_state_real:
 In:  fs - checkpoint file to write to.
 Out: Writes molecule scheduler data to the checkpoint file.
      Returns 1 on error, and 0 - on success.
***************************************************************************/
static int write_mol_scheduler_state_real(FILE *fs,
                                          struct storage_list *storage_head,
                                          double simulation_start_seconds,
                                          double start_iterations,
                                          double time_unit) {
  static const char SECTNAME[] = &quot;molecule scheduler state&quot;;
  static const byte cmd = MOL_SCHEDULER_STATE_CMD;

  WRITEFIELD(cmd);

  /* write total number of items in the scheduler */
  unsigned long long total_items = count_items_in_scheduler(storage_head);
  WRITEUINT64(total_items);

  /* Iterate over all molecules in the scheduler to produce checkpoint */
  for (struct storage_list *slp = storage_head; slp != NULL; slp = slp-&gt;next) {
    for (struct schedule_helper *shp = slp-&gt;store-&gt;timer; shp != NULL;
         shp = shp-&gt;next_scale) {
      for (int i = -1; i &lt; shp-&gt;buf_len; i++) {
        for (struct abstract_element *aep = (i &lt; 0) ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head[i];
             aep != NULL; aep = aep-&gt;next) {
          struct abstract_molecule *amp = (struct abstract_molecule *)aep;
          if (amp-&gt;properties == NULL)
            continue;

          /* Grab the location and orientation for this molecule */
          struct vector3 where;
          short orient = 0;
          byte act_newbie_flag =
              (amp-&gt;flags &amp; ACT_NEWBIE) ? HAS_ACT_NEWBIE : HAS_NOT_ACT_NEWBIE;
          byte act_change_flag =
              (amp-&gt;flags &amp; ACT_CHANGE) ? HAS_ACT_CHANGE : HAS_NOT_ACT_CHANGE;
          if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
            struct volume_molecule *vmp = (struct volume_molecule *)amp;
            INTERNALCHECK(vmp-&gt;previous_wall != NULL &amp;&amp; vmp-&gt;index &gt;= 0,
                          &quot;The value of 'previous_grid' is not NULL.&quot;);
            where.x = vmp-&gt;pos.x;
            where.y = vmp-&gt;pos.y;
            where.z = vmp-&gt;pos.z;
            orient = 0;
          } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
            struct surface_molecule *smp = (struct surface_molecule *)amp;
            uv2xyz(&amp;smp-&gt;s_pos, smp-&gt;grid-&gt;surface, &amp;where);
            orient = smp-&gt;orient;
          } else
            continue;

          /* Check for valid chkpt_species ID. */
          INTERNALCHECK(amp-&gt;properties-&gt;chkpt_species_id == UINT_MAX,
                        &quot;Attempted to write out a molecule of species '%s', &quot;
                        &quot;which has not been assigned a checkpoint species id.&quot;,
                        amp-&gt;properties-&gt;sym-&gt;name);

          /* write molecule fields */
          WRITEUINT(amp-&gt;properties-&gt;chkpt_species_id);
          WRITEFIELD(act_newbie_flag);
          WRITEFIELD(act_change_flag);

          // NOTE: we write all times as real times (seconds) *not* as
          // &quot;iterations&quot; (or &quot;scaled times&quot;) in order to be able to
          // re-schedule them properly upon restart

          // The scheduling time (t) is essentially iterations, and since time
          // steps can change when checkpointing, we can't directly convert
          // iterations to real time (seconds). We need to correct for this by
          // only converting the iterations of the current simulation
          // [(t-start_iterations)*time_unit] and adding the real time at the
          // start of the simulation (simulation_start_seconds).
          double t = convert_iterations_to_seconds(
              start_iterations, time_unit, simulation_start_seconds, amp-&gt;t);
          WRITEFIELD(t);
          // We do a simple conversion for the lifetime t2, since this
          // corresponds to some event in the future and can be directly
          // computed without using an offset.
          double t2 = amp-&gt;t2 * time_unit;
          WRITEFIELD(t2);
          // Birthday is now always treated as real time in seconds, not
          // &quot;scaled&quot; time or iterations.
          double bday = amp-&gt;birthday;
          WRITEFIELD(bday);
          WRITEFIELD(where);
          WRITEINT(orient);

          static const unsigned char NON_COMPLEX = '\0';
          WRITEFIELD(NON_COMPLEX);
        }
      }
    }
  }

  return 0;
}

/***************************************************************************
 read_mol_scheduler_state_real:
 In:  fs - checkpoint file to read from.
 Out: Reads molecule scheduler data from the checkpoint file.
      Returns 0 on success. Error message and exit on failure.
***************************************************************************/
static int read_mol_scheduler_state_real(struct volume *world, FILE *fs,
                                         struct chkpt_read_state *state,
                                         uint32_t api_version) {
  static const char SECTNAME[] = &quot;molecule scheduler state&quot;;

  struct volume_molecule vm;
  struct volume_molecule *vmp = NULL;
  struct abstract_molecule *amp = NULL;
  struct volume_molecule *guess = NULL;

  /* Clear template vol mol structure */
  memset(&amp;vm, 0, sizeof(struct volume_molecule));
  vmp = &amp;vm;
  amp = (struct abstract_molecule *)vmp;

  /* read total number of items in the scheduler. */
  unsigned long long total_items;
  READUINT64(total_items);

  for (unsigned long long n_mol = 0; n_mol &lt; total_items; n_mol++) {
    /* Normal molecule fields */
    unsigned int external_species_id;
    byte act_newbie_flag;
    byte act_change_flag;
    double sched_time;
    double lifetime;
    double birthday;
    double x_coord, y_coord, z_coord;
    int orient;

    /* read molecule fields */
    READUINT(external_species_id);
    READFIELDRAW(act_newbie_flag);
    READFIELDRAW(act_change_flag);
    READFIELD(sched_time);
    READFIELD(lifetime);
    READFIELD(birthday);
    READFIELD(x_coord);
    READFIELD(y_coord);
    READFIELD(z_coord);
    READINT(orient);

    // starting with API version 1, convert the sched_time, lifetime and
    // birthday into scaled time based on the current timestep
    if (api_version &gt;= 1) {
      // This will force lifetimes to be recomputed. This is necessary if
      // unimolecular rate constants change between checkpoints.
      lifetime = 0;
      sched_time = world-&gt;start_iterations;
      act_change_flag = HAS_ACT_CHANGE;
    }

    unsigned int complex_no = 0;
    READUINT(complex_no);

    /* Find this species by its external species id */
    struct species *properties = NULL;
    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
      if (world-&gt;species_list[species_idx]-&gt;chkpt_species_id ==
          external_species_id) {
        properties = world-&gt;species_list[species_idx];
        break;
      }
    }
    DATACHECK(properties == NULL,
              &quot;Found molecule with unknown species id (%d).&quot;,
              external_species_id);

    /* Create and add molecule to scheduler */
    struct periodic_image periodic_box = {  0, 0, 0 };

    if ((properties-&gt;flags &amp; NOT_FREE) == 0) { /* 3D molecule */

      /* set molecule characteristics */
      amp-&gt;t = sched_time;
      amp-&gt;t2 = lifetime;
      amp-&gt;birthday = birthday;
      amp-&gt;properties = properties;
      initialize_diffusion_function(amp);
      if(amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES)
        properties_nfsim(world, amp);
      vmp-&gt;previous_wall = NULL;
      vmp-&gt;index = -1;
      vmp-&gt;pos.x = x_coord;
      vmp-&gt;pos.y = y_coord;
      vmp-&gt;pos.z = z_coord;
      amp-&gt;periodic_box = &amp;periodic_box;

      /* Set molecule flags */
      amp-&gt;flags = TYPE_VOL | IN_VOLUME;
      if (act_newbie_flag == HAS_ACT_NEWBIE)
        amp-&gt;flags |= ACT_NEWBIE;

      if (act_change_flag == HAS_ACT_CHANGE)
        amp-&gt;flags |= ACT_CHANGE;

      amp-&gt;flags |= IN_SCHEDULE;
      if ((amp-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0 ||
          trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                               amp-&gt;properties-&gt;hashval, amp) != NULL)
        amp-&gt;flags |= ACT_REACT;
      if (amp-&gt;get_space_step(amp) &gt; 0.0)
        amp-&gt;flags |= ACT_DIFFUSE;

      /* Insert copy of vm into world */
      guess = insert_volume_molecule(world, vmp, guess);
      if (guess == NULL) {
        mcell_error(&quot;Cannot insert copy of molecule of species '%s' into &quot;
                    &quot;world.\nThis may be caused by a shortage of memory.&quot;,
                    vmp-&gt;properties-&gt;sym-&gt;name);
      }

    } else { /* surface_molecule */
      struct vector3 where;

      where.x = x_coord;
      where.y = y_coord;
      where.z = z_coord;


      struct surface_molecule *smp = insert_surface_molecule(
          world, properties, &amp;where, orient, CHKPT_GRID_TOLERANCE, sched_time,
          NULL, NULL, NULL, &amp;periodic_box);

      if (smp == NULL) {
        mcell_warn(&quot;Could not place molecule %s at (%f,%f,%f).&quot;,
                   properties-&gt;sym-&gt;name, where.x * world-&gt;length_unit,
                   where.y * world-&gt;length_unit,
                   where.z * world-&gt;length_unit);
        continue;
      }

      smp-&gt;t2 = lifetime;
      smp-&gt;birthday = birthday;
      if (act_newbie_flag == HAS_NOT_ACT_NEWBIE)
        smp-&gt;flags &amp;= ~ACT_NEWBIE;

      if (act_change_flag == HAS_ACT_CHANGE) {
        smp-&gt;flags |= ACT_CHANGE;
      }
    }
  }

  return 0;
}
</PRE>
</div>
  </div>
</body>
</html>
