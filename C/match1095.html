<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-session.c &amp; inf-text-gtk-buffer.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-session.c &amp; inf-text-gtk-buffer.c
      </h3>
<h1 align="center">
        9.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-session.c (10.797546%)<th>inf-text-gtk-buffer.c (9.090909%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1748-1778)<td><a href="#" name="0">(2131-2151)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(843-871)<td><a href="#" name="1">(1362-1392)</a><td align="center"><font color="#cc0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(873-896)<td><a href="#" name="2">(1436-1459)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(276-305)<td><a href="#" name="3">(153-175)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(42-60)<td><a href="#" name="4">(84-125)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1211-1242)<td><a href="#" name="5">(1210-1320)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-session.h&gt;
2 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
5 #include &lt;libinftext/inf-text-insert-operation.h&gt;
6 #include &lt;libinftext/inf-text-delete-operation.h&gt;
7 #include &lt;libinftext/inf-text-move-operation.h&gt;
8 #include &lt;libinftext/inf-text-chunk.h&gt;
9 #include &lt;libinftext/inf-text-user.h&gt;
10 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
11 #include &lt;libinfinity/common/inf-xml-util.h&gt;
12 #include &lt;libinfinity/common/inf-error.h&gt;
13 #include &lt;libinfinity/inf-i18n.h&gt;
14 #include &lt;libinfinity/inf-signals.h&gt;
15 #include &lt;libxml/tree.h&gt;
16 #include &lt;string.h&gt;
17 #include &lt;errno.h&gt;
18 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
19 struct _InfTextSessionLocalUser {
20   InfTextSession* session;
21   InfTextUser* user;
22   GTimeVal last_caret_update;
23   InfIoTimeout* caret_timeout;
24 };
25 typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
26 struct _InfTextSessionPrivate {
27   guint caret_update_interval;
28   GSList* local_users;
29 };
30 enum {
31   PROP_0,
32   PROP_CARET_UPDATE_INTERVAL
33 };</b></font>
34 typedef struct _InfTextSessionInsertForeachData
35   InfTextSessionInsertForeachData;
36 typedef struct _InfTextSessionEraseForeachData
37   InfTextSessionEraseForeachData;
38 struct _InfTextSessionInsertForeachData {
39   guint position;
40   InfTextChunk* chunk;
41   InfUser* user;
42 };
43 struct _InfTextSessionEraseForeachData {
44   guint position;
45   guint length;
46   InfUser* user;
47 };
48 #define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))
49 static GQuark inf_text_session_error_quark;
50 G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
51   G_ADD_PRIVATE(InfTextSession))
52 static guint
53 inf_text_session_timeval_diff(GTimeVal* first,
54                               GTimeVal* second)
55 {
56   g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
57            (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
58             first-&gt;tv_usec &gt;= second-&gt;tv_usec));
59   return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
60          (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
61 }
62 static void
63 inf_text_session_segment_to_xml(GIConv* cd,
64                                 xmlNodePtr xml,
65                                 gconstpointer text,
66                                 gsize* bytes,                                 guint author)
67 {
68   gchar utf8_text[1024];
69   gsize result;
70   gsize bytes_left;
71   gchar* inbuf;
72   gchar* outbuf;
73   bytes_left = 1024;
74   inbuf = *(gchar**)(gpointer)&amp;text;   outbuf = utf8_text;
75   result = g_iconv(
76     *cd,
77     &amp;inbuf,
78     bytes,
79     &amp;outbuf,
80     &amp;bytes_left
81   );
82   g_assert(result == 0 || errno == E2BIG);
83   inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
84   inf_xml_util_set_attribute_uint(xml, "author", author);
85 }
86 static gpointer
87 inf_text_session_segment_from_xml(GIConv* cd,
88                                   xmlNodePtr xml,
89                                   guint* length,
90                                   gsize* bytes,
91                                   guint* author,
92                                   GError** error)
93 {
94   gsize bytes_read;
95   gchar* utf8_text;
96   gpointer text;
97   if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
98     return NULL;
99   utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
100   if(!utf8_text)
101     return NULL;
102   text = g_convert_with_iconv(
103     utf8_text,
104     bytes_read,
105     *cd,
106     NULL,
107     bytes,
108     error
109   );
110   g_free(utf8_text);
111   return text;
112 }
113 static InfTextSessionLocalUser*
114 inf_text_session_find_local_user(InfTextSession* session,
115                                  InfTextUser* user)
116 {
117   InfTextSessionPrivate* priv;
118   GSList* item;
119   InfTextSessionLocalUser* local;
120   priv = INF_TEXT_SESSION_PRIVATE(session);
121   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
122   {
123     local = (InfTextSessionLocalUser*)item-&gt;data;
124     if(local-&gt;user == user)
125       return local;
126   }
127   return NULL;
128 }
129 static void
130 inf_text_session_broadcast_caret_selection(InfTextSession* session,
131                                            InfTextSessionLocalUser* local)
132 {
133   InfAdoptedOperation* operation;
134   InfAdoptedAlgorithm* algorithm;
135   InfAdoptedRequest* request;
136   guint buf_len;
137   guint position;
138   int sel;
139   guint end;
140   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
141   position = inf_text_user_get_caret_position(local-&gt;user);
142   sel = inf_text_user_get_selection_length(local-&gt;user);
143   end = position + sel;
144   buf_len = inf_text_buffer_get_length(
145     INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
146   );
147   if(position &gt; buf_len)
148     position = buf_len;
149   if(end &gt; buf_len)
150     end = buf_len;
151   if(end &gt;= position)
152     sel = (int)(end - position);
153   else
154     sel = -(int)(position - end);
155   operation = INF_ADOPTED_OPERATION(
156     inf_text_move_operation_new(position, sel)
157   );
158   request = inf_adopted_algorithm_generate_request(
159     algorithm,
160     INF_ADOPTED_REQUEST_DO,
161     INF_ADOPTED_USER(local-&gt;user),
162     operation
163   );
164   inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
165   g_object_unref(operation);
166   inf_adopted_session_broadcast_request(
167     INF_ADOPTED_SESSION(session),
168     request
169   );
170   g_object_unref(request);
171   g_get_current_time(&amp;local-&gt;last_caret_update);
172   if(local-&gt;caret_timeout != NULL)
173   {
174     inf_io_remove_timeout(
175       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
176       local-&gt;caret_timeout
177     );
178     local-&gt;caret_timeout = NULL;
179   }
180 }
181 static void
182 <a name="3"></a>inf_text_session_caret_update_timeout_func(gpointer user_data)
183 {
184   InfTextSessionLocalUser* local;
185 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  local = (InfTextSessionLocalUser*)user_data;
186   local-&gt;caret_timeout = NULL;
187   inf_text_session_broadcast_caret_selection(local-&gt;session, local);
188 }
189 static void
190 inf_text_session_selection_changed_cb(InfTextUser* user,
191                                       guint position,
192                                       gint sel,
193                                       gboolean by_request,
194                                       gpointer user_data)
195 {
196   InfTextSession* session;
197   InfTextSessionPrivate* priv;
198   InfAdoptedAlgorithm* algorithm;
199   InfAdoptedRequest* execute_request;
200   InfTextSessionLocalUser* local;
201   GTimeVal current;
202   guint diff;
203   session = INF_TEXT_SESSION(user_data);
204   priv = INF_TEXT_SESSION_PRIVATE(session);
205   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
206   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
207   g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
208             (execute_request == NULL &amp;&amp; by_request == TRUE));</b></font>
209   if(execute_request == NULL)
210   {
211     local = inf_text_session_find_local_user(session, user);
212     g_assert(local != NULL);
213     g_get_current_time(&amp;current);
214     diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);
215     if(diff &lt; priv-&gt;caret_update_interval)
216     {
217       if(local-&gt;caret_timeout == NULL)
218       {
219         local-&gt;caret_timeout = inf_io_add_timeout(
220           inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
221           priv-&gt;caret_update_interval - diff,
222           inf_text_session_caret_update_timeout_func,
223           local,
224           NULL
225         );
226       }
227     }
228     else
229     {
230       inf_text_session_broadcast_caret_selection(session, local);
231     }
232   }
233 }
234 static void
235 inf_text_session_add_local_user(InfTextSession* session,
236                                 InfTextUser* user)
237 {
238   InfTextSessionPrivate* priv;
239   InfTextSessionLocalUser* local;
240   priv = INF_TEXT_SESSION_PRIVATE(session);
241   local = g_slice_new(InfTextSessionLocalUser);
242   local-&gt;session = session;
243   local-&gt;user = user;
244   g_get_current_time(&amp;local-&gt;last_caret_update);
245   local-&gt;caret_timeout = NULL;
246   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
247   g_signal_connect_after(
248     G_OBJECT(user),
249     "selection-changed",
250     G_CALLBACK(inf_text_session_selection_changed_cb),
251     session
252   );
253 }
254 static void
255 inf_text_session_remove_local_user(InfTextSession* session,
256                                    InfTextSessionLocalUser* local)
257 {
258   InfTextSessionPrivate* priv;
259   priv = INF_TEXT_SESSION_PRIVATE(session);
260   if(local-&gt;caret_timeout != NULL)
261   {
262     inf_io_remove_timeout(
263       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
264       local-&gt;caret_timeout
265     );
266   }
267   inf_signal_handlers_disconnect_by_func(
268     G_OBJECT(local-&gt;user),
269     G_CALLBACK(inf_text_session_selection_changed_cb),
270     session
271   );
272   g_slice_free(InfTextSessionLocalUser, local);
273   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
274 }
275 static void
276 inf_text_session_local_user_added_cb(InfUserTable* user_table,
277                                      InfUser* user,
278                                      gpointer user_data)
279 {
280   g_assert(INF_TEXT_IS_USER(user));
281   inf_text_session_add_local_user(
282     INF_TEXT_SESSION(user_data),
283     INF_TEXT_USER(user)
284   );
285 }
286 static void
287 inf_text_session_local_user_removed_cb(InfUserTable* user_table,
288                                        InfUser* user,
289                                        gpointer user_data)
290 {
291   InfTextSession* session;
292   InfTextSessionLocalUser* local;
293   g_assert(INF_TEXT_IS_USER(user));
294   session = INF_TEXT_SESSION(user_data);
295   local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
296   g_assert(local != NULL);
297   inf_text_session_remove_local_user(session, local);
298 }
299 static void
300 inf_text_session_block_local_users_selection_changed(InfTextSession* session)
301 {
302   InfTextSessionPrivate* priv;
303   GSList* item;
304   InfTextSessionLocalUser* local;
305   priv = INF_TEXT_SESSION_PRIVATE(session);
306   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
307   {
308     local = (InfTextSessionLocalUser*)item-&gt;data;
309     inf_signal_handlers_block_by_func(
310       G_OBJECT(local-&gt;user),
311       G_CALLBACK(inf_text_session_selection_changed_cb),
312       session
313     );
314   }
315 }
316 static void
317 inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
318 {
319   InfTextSessionPrivate* priv;
320   GSList* item;
321   InfTextSessionLocalUser* local;
322   priv = INF_TEXT_SESSION_PRIVATE(sess);
323   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
324   {
325     local = (InfTextSessionLocalUser*)item-&gt;data;
326     inf_signal_handlers_unblock_by_func(
327       G_OBJECT(local-&gt;user),
328       G_CALLBACK(inf_text_session_selection_changed_cb),
329       sess
330     );
331   }
332 }
333 static void
334 inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
335                                                       gpointer user_data)
336 {
337   InfTextSessionInsertForeachData* data;
338   guint position;
339   gint length;
340   data = (InfTextSessionInsertForeachData*)user_data;
341   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
342   {
343     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
344     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
345     inf_text_move_operation_transform_insert(
346       data-&gt;position,
347       inf_text_chunk_get_length(data-&gt;chunk),
348       &amp;position,
349       &amp;length,
350       user == data-&gt;user ? FALSE : TRUE
351     );
352     inf_text_user_set_selection(
353       INF_TEXT_USER(user),
354       position,
355       length,
356       user == data-&gt;user ? TRUE : FALSE
357     );
358   }
359 }
360 static void
361 inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
362                                                     gpointer user_data)
363 {
364   InfTextSessionEraseForeachData* data;
365   guint position;
366   gint length;
367   data = (InfTextSessionEraseForeachData*)user_data;
368   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
369   {
370     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
371     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
372     inf_text_move_operation_transform_delete(
373       data-&gt;position,
374       data-&gt;length,
375       &amp;position,
376       &amp;length
377     );
378     inf_text_user_set_selection(
379       INF_TEXT_USER(user),
380       position,
381       length,
382       user == data-&gt;user ? TRUE : FALSE
383     );
384   }
385 }
386 static void
387 inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
388                                          guint pos,
389                                          InfTextChunk* chunk,
390                                          InfUser* user,
391                                          gpointer user_data)
392 {
393   InfTextSession* session;
394   InfTextSessionPrivate* priv;
395   InfUserTable* user_table;
396   InfAdoptedAlgorithm* algorithm;
397   InfAdoptedRequest* execute_request;
398   InfAdoptedOperation* operation;
399   InfAdoptedRequest* request;
400   InfTextSessionInsertForeachData data;
401   g_assert(INF_TEXT_IS_USER(user));
402   session = INF_TEXT_SESSION(user_data);
403   priv = INF_TEXT_SESSION_PRIVATE(session);
404   user_table = inf_session_get_user_table(INF_SESSION(session));
405   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
406   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
407   if(execute_request == NULL)
408   {
409     operation = INF_ADOPTED_OPERATION(
410       inf_text_default_insert_operation_new(pos, chunk)
411     );
412     request = inf_adopted_algorithm_generate_request(
413       algorithm,
414       INF_ADOPTED_REQUEST_DO,
415       INF_ADOPTED_USER(user),
416       operation
417     );
418     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
419     inf_adopted_session_broadcast_request(
420       INF_ADOPTED_SESSION(session),
421       request
422     );
423     g_object_unref(request);
424     g_object_unref(operation);
425   }
426   data.position = pos;
427   data.chunk = chunk;
428   data.user = user;
429   inf_text_session_block_local_users_selection_changed(session);
430   inf_user_table_foreach_user(
431     user_table,
432     inf_text_session_buffer_text_inserted_cb_foreach_func,
433     &amp;data
434   );
435 #if 0
436   if(user != NULL)
437   {
438     inf_text_user_set_selection(
439       INF_TEXT_USER(user),
440       pos + inf_text_chunk_get_length(chunk),
441       0,
442       TRUE
443     );
444   }
445 #endif
446   inf_text_session_unblock_local_users_selection_changed(session);
447 }
448 static void
449 inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
450                                        guint pos,
451                                        InfTextChunk* chunk,
452                                        InfUser* user,
453                                        gpointer user_data)
454 {
455   InfTextSession* session;
456   InfTextSessionPrivate* priv;
457   InfUserTable* user_table;
458   InfAdoptedAlgorithm* algorithm;
459   InfAdoptedRequest* execute_request;
460   InfAdoptedOperation* operation;
461   InfAdoptedRequest* request;
462   InfTextSessionEraseForeachData data;
463   g_assert(INF_TEXT_IS_USER(user));
464   session = INF_TEXT_SESSION(user_data);
465   priv = INF_TEXT_SESSION_PRIVATE(session);
466   user_table = inf_session_get_user_table(INF_SESSION(session));
467   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
468   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
469   if(execute_request == NULL)
470   {
471     operation = INF_ADOPTED_OPERATION(
472       inf_text_default_delete_operation_new(pos, chunk)
473     );
474     request = inf_adopted_algorithm_generate_request(
475       algorithm,
476       INF_ADOPTED_REQUEST_DO,
477       INF_ADOPTED_USER(user),
478       operation
479     );
480     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
481     inf_adopted_session_broadcast_request(
482       INF_ADOPTED_SESSION(session),
483       request
484     );
485     g_object_unref(request);
486     g_object_unref(operation);
487   }
488   data.position = pos;
489   data.length = inf_text_chunk_get_length(chunk);
490   data.user = user;
491   inf_text_session_block_local_users_selection_changed(session);
492   inf_user_table_foreach_user(
493     user_table,
494     inf_text_session_buffer_text_erased_cb_foreach_func,
495     &amp;data
496   );
497 #if 0
498   if(user != NULL)
499     inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
500 #endif
501   inf_text_session_unblock_local_users_selection_changed(session);
502 }
503 static void
504 inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
505                                                       gpointer user_data)
506 {
507   g_assert(INF_TEXT_IS_USER(user));
508   inf_text_session_add_local_user(
509     INF_TEXT_SESSION(user_data),
510     INF_TEXT_USER(user)
511   );
512 }
513 static void
514 inf_text_session_init_text_handlers(InfTextSession* session)
515 {
516   InfTextBuffer* buffer;
517   InfAdoptedAlgorithm* algorithm;
518   InfUserTable* user_table;
519   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
520   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
521   user_table = inf_session_get_user_table(INF_SESSION(session));
522   g_signal_connect(
523     G_OBJECT(buffer),
524     "text-inserted",
525     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
526     session
527   );
528   g_signal_connect(
529     G_OBJECT(buffer),
530     "text-erased",
531     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
532     session
533   );
534   g_signal_connect(
535     G_OBJECT(user_table),
536     "add-local-user",
537     G_CALLBACK(inf_text_session_local_user_added_cb),
538     session
539   );
540   g_signal_connect(
541     G_OBJECT(user_table),
542     "remove-local-user",
543     G_CALLBACK(inf_text_session_local_user_removed_cb),
544     session
545   );
546   inf_user_table_foreach_local_user(
547     user_table,
548     inf_text_session_init_text_handlers_user_foreach_func,
549     session
550   );
551 }
552 static void
553 inf_text_session_init(InfTextSession* session)
554 {
555   InfTextSessionPrivate* priv;
556   priv = INF_TEXT_SESSION_PRIVATE(session);
557   priv-&gt;caret_update_interval = 500;
558 }
559 static void
560 inf_text_session_constructed(GObject* object)
561 {
562   InfTextSession* session;
563   InfTextSessionPrivate* priv;
564   InfTextBuffer* buffer;
565   InfSessionStatus status;
566   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);
567   session = INF_TEXT_SESSION(object);
568   priv = INF_TEXT_SESSION_PRIVATE(session);
569   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
570   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
571   g_assert(
572     status == INF_SESSION_RUNNING ||
573     inf_text_buffer_get_length(buffer) == 0
574   );
575   if(status == INF_SESSION_RUNNING)
576     inf_text_session_init_text_handlers(session);
577 }
578 static void
579 inf_text_session_dispose(GObject* object)
580 {
581   InfTextSession* session;
582   InfTextSessionPrivate* priv;
583   InfTextBuffer* buffer;
584   InfUserTable* user_table;
585   InfAdoptedAlgorithm* algorithm;
586   session = INF_TEXT_SESSION(object);
587   priv = INF_TEXT_SESSION_PRIVATE(session);
588   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
589   user_table = inf_session_get_user_table(INF_SESSION(session));
590   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
591   while(priv-&gt;local_users != NULL)
592   {
593     inf_text_session_remove_local_user(
594       session,
595       (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
596     );
597   }
598   inf_signal_handlers_disconnect_by_func(
599     G_OBJECT(buffer),
600     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
601     session
602   );
603   inf_signal_handlers_disconnect_by_func(
604     G_OBJECT(buffer),
605     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
606     session
607   );
608   inf_signal_handlers_disconnect_by_func(
609     G_OBJECT(user_table),
610     G_CALLBACK(inf_text_session_local_user_added_cb),
611     session
612   );
613   inf_signal_handlers_disconnect_by_func(
614     G_OBJECT(user_table),
615     G_CALLBACK(inf_text_session_local_user_removed_cb),
616     session
617 <a name="1"></a>  );
618   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
619 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
620 static void
621 inf_text_session_finalize(GObject* object)
622 {
623   InfTextSession* session;
624   InfTextSessionPrivate* priv;
625   session = INF_TEXT_SESSION(object);
626   priv = INF_TEXT_SESSION_PRIVATE(session);
627   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
628 }
629 static void
630 inf_text_session_set_property(GObject* object,
631                               guint prop_id,
632                               const GValue* value,
633                               GParamSpec* pspec)
634 {
635   InfTextSession* session;
636   InfTextSessionPrivate* priv;
637   session = INF_TEXT_SESSION(object);
638   priv = INF_TEXT_SESSION_PRIVATE(session);
639   switch(prop_id)
640 <a name="2"></a>  {
641   case PROP_CARET_UPDATE_INTERVAL:</b></font>
642     priv-&gt;caret_update_interval = g_value_get_uint(value);
643 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
644   default:
645     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
646     break;
647   }
648 }
649 static void
650 inf_text_session_get_property(GObject* object,
651                               guint prop_id,
652                               GValue* value,
653                               GParamSpec* pspec)
654 {
655   InfTextSession* session;
656   InfTextSessionPrivate* priv;
657   session = INF_TEXT_SESSION(object);
658   priv = INF_TEXT_SESSION_PRIVATE(session);
659   switch(prop_id)
660   {
661   case PROP_CARET_UPDATE_INTERVAL:
662     g_value_set_uint(value, priv-&gt;caret_update_interval);
663     break;</b></font>
664   default:
665     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
666     break;
667   }
668 }
669 static InfCommunicationScope
670 inf_text_session_handle_user_color_change(InfTextSession* session,
671                                           InfXmlConnection* connection,
672                                           xmlNodePtr xml,
673                                           GError** error)
674 {
675   InfUserTable* user_table;
676   guint user_id;
677   InfUser* user;
678   gdouble hue;
679   user_table = inf_session_get_user_table(INF_SESSION(session));
680   if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
681     return INF_COMMUNICATION_SCOPE_PTP;
682   if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
683     return INF_COMMUNICATION_SCOPE_PTP;
684   user = inf_user_table_lookup_user_by_id(user_table, user_id);
685   if(user == NULL)
686   {
687     g_set_error(
688       error,
689       inf_user_error_quark(),
690       INF_USER_ERROR_NO_SUCH_USER,
691       _("No such user with ID '%u'"),
692       user_id
693     );
694     return INF_COMMUNICATION_SCOPE_PTP;
695   }
696   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
697      inf_user_get_connection(user) != connection)
698   {
699     g_set_error_literal(
700       error,
701       inf_user_error_quark(),
702       INF_USER_ERROR_NOT_JOINED,
703       _("User did not join from this connection")
704     );
705     return INF_COMMUNICATION_SCOPE_PTP;
706   }
707   g_assert(INF_TEXT_IS_USER(user));
708   if(hue &lt; 0.0 || hue &gt; 1.0)
709   {
710     g_set_error(
711       error,
712       inf_text_session_error_quark,
713       INF_TEXT_SESSION_ERROR_INVALID_HUE,
714       _("Invalid hue value: '%g'"),
715       hue
716     );
717     return INF_COMMUNICATION_SCOPE_PTP;
718   }
719   g_object_set(G_OBJECT(user), "hue", hue, NULL);
720   return INF_COMMUNICATION_SCOPE_GROUP;
721 }
722 static void
723 inf_text_session_to_xml_sync(InfSession* session,
724                              xmlNodePtr parent)
725 {
726   InfTextBuffer* buffer;
727   InfTextBufferIter* iter;
728   xmlNodePtr xml;
729   gboolean result;
730   gchar* text;
731   gsize total_bytes;
732   gsize bytes_left;
733   GIConv cd;
734   INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
735     session,
736     parent
737   );
738   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
739   cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));
740   iter = inf_text_buffer_create_begin_iter(buffer);
741   if(iter != NULL)
742   {
743     result = TRUE;
744     while(result == TRUE)
745     {
746       text = inf_text_buffer_iter_get_text(buffer, iter);
747       total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
748       bytes_left = total_bytes;
749       while(bytes_left &gt; 0)
750       {
751         xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
752         inf_text_session_segment_to_xml(
753           &amp;cd,
754           xml,
755           text + total_bytes - bytes_left,
756           &amp;bytes_left,
757           inf_text_buffer_iter_get_author(buffer, iter)
758         );
759       }
760       g_free(text);
761       result = inf_text_buffer_iter_next(buffer, iter);
762     }
763     inf_text_buffer_destroy_iter(buffer, iter);
764   }
765   g_iconv_close(cd);
766 }
767 static gboolean
768 inf_text_session_process_xml_sync(InfSession* session,
769                                   InfXmlConnection* connection,
770                                   const xmlNodePtr xml,
771                                   GError** error)
772 {
773   InfTextBuffer* buffer;
774   GIConv cd;
775   gpointer text;
776   gsize bytes;
777   guint length;
778   guint author;
779   InfUser* user;
780   if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
781   {
782     buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
783     cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
784     text = inf_text_session_segment_from_xml(
785       &amp;cd,
786       xml,
787       &amp;length,
788       &amp;bytes,
789       &amp;author,
790       error
791     );
792     g_iconv_close(cd);
793     if(text == NULL) return FALSE;
794     if(author != 0)
795     {
796       user = inf_user_table_lookup_user_by_id(
797         inf_session_get_user_table(session),
798         author
799       );
800       if(user == NULL)
801       {
802         g_free(text);
803         g_set_error(
804           error,
805           inf_user_error_quark(),
806           INF_USER_ERROR_NO_SUCH_USER,
807           _("No such user with ID '%u'"),
808           author
809         );
810         return FALSE;
811       }
812     }
813     else
814     {
815       user = NULL;
816     }
817     inf_text_buffer_insert_text(
818       buffer,
819       inf_text_buffer_get_length(buffer),
820       text,
821       bytes,
822       length,
823       user
824     );
825     g_free(text);
826     return TRUE;
827   }
828   else
829   {
830     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
831       session,
832       connection,
833       xml,
834       error
835     );
836   }
837 }
838 static InfCommunicationScope
839 inf_text_session_process_xml_run(InfSession* session,
840                                  InfXmlConnection* connection,
841                                  const xmlNodePtr xml,
842                                  GError** error)
843 {
844   if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
845   {
846     return inf_text_session_handle_user_color_change(
847       INF_TEXT_SESSION(session),
848       connection,
849       xml,
850       error
851     );
852   }
853   else
854   {
855     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
856       session,
857       connection,
858       xml,
859       error
860     );
861   }
862 }
863 static GArray*
864 inf_text_session_get_xml_user_props(InfSession* session,
865                                     InfXmlConnection* connection,
866                                     const xmlNodePtr xml)
867 {
868   InfSessionClass* parent_class;
869   GArray* array;
870   GParameter* parameter;
871   guint caret;
872   gint selection;
873   gdouble hue;
874   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
875   array = parent_class-&gt;get_xml_user_props(session, connection, xml);
876   if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
877   {
878     parameter = inf_session_get_user_property(array, "caret-position");
879     g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
880     g_value_set_uint(&amp;parameter-&gt;value, caret);
881   }
882   parameter = inf_session_get_user_property(array, "selection-length");
883   g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
884   if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
885     g_value_set_int(&amp;parameter-&gt;value, selection);
886   else
887     g_value_set_int(&amp;parameter-&gt;value, 0);
888   parameter = inf_session_get_user_property(array, "hue");
889   g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);
890   if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
891     g_value_set_double(&amp;parameter-&gt;value, hue);
892   else
893     g_value_set_double(&amp;parameter-&gt;value, g_random_double());
894   return array;
895 }
896 static void
897 inf_text_session_set_xml_user_props(InfSession* session,
898                                     const GParameter* params,
899                                     guint n_params,
900                                     xmlNodePtr xml)
901 {
902   InfSessionClass* parent_class;
903   const GParameter* param;
904   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
905   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
906   param = inf_session_lookup_user_property(
907     params,
908     n_params,
909     "caret-position"
910   );
911   if(param != NULL)
912   {
913     inf_xml_util_set_attribute_uint(
914       xml,
915       "caret",
916       g_value_get_uint(&amp;param-&gt;value)
917 <a name="5"></a>    );
918   }
919 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  param = inf_session_lookup_user_property(
920     params,
921     n_params,
922     "selection-length"
923   );
924   if(param != NULL)
925   {
926     inf_xml_util_set_attribute_int(
927       xml,
928       "selection",
929       g_value_get_int(&amp;param-&gt;value)
930     );
931   }
932   param = inf_session_lookup_user_property(
933     params,
934     n_params,
935     "hue"
936   );
937   if(param != NULL)
938   {
939     inf_xml_util_set_attribute_double(
940       xml,
941       "hue",
942       g_value_get_double(&amp;param-&gt;value)
943     );
944   }
945 }
946 static gboolean</b></font>
947 inf_text_session_validate_user_props(InfSession* session,
948                                      const GParameter* params,
949                                      guint n_params,
950                                      InfUser* exclude,
951                                      GError** error)
952 {
953   InfSessionClass* parent_class;
954   const GParameter* caret;
955   gboolean result;
956   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
957   result = parent_class-&gt;validate_user_props(
958     session,
959     params,
960     n_params,
961     exclude,
962     error
963   );
964   if(result == FALSE) return FALSE;
965   caret = inf_session_lookup_user_property(
966     params,
967     n_params,
968     "caret-position"
969   );
970   if(caret == NULL)
971   {
972     g_set_error_literal(
973       error,
974       inf_request_error_quark(),
975       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
976       _("\"caret\" attribute in user message is missing")
977     );
978     return FALSE;
979   }
980   return result;
981 }
982 static InfUser*
983 inf_text_session_user_new(InfSession* session,
984                           GParameter* params,
985                           guint n_params)
986 {
987   GObject* object;
988   object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
989   return INF_USER(object);
990 }
991 static void
992 inf_text_session_synchronization_complete(InfSession* session,
993                                           InfXmlConnection* connection)
994 {
995   InfSessionClass* parent_class;
996   InfSessionStatus status;
997   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
998   status = inf_session_get_status(session);
999   parent_class-&gt;synchronization_complete(session, connection);
1000   if(status == INF_SESSION_SYNCHRONIZING)
1001     inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
1002 }
1003 static void
1004 inf_text_session_request_to_xml(InfAdoptedSession* session,
1005                                 xmlNodePtr xml,
1006                                 InfAdoptedRequest* request,
1007                                 InfAdoptedStateVector* diff_vec,
1008                                 gboolean for_sync)
1009 {
1010   InfTextChunk* chunk;
1011   InfTextChunkIter iter;
1012   gboolean result;
1013   xmlNodePtr op_xml;
1014   gchar* utf8_text;
1015   gsize bytes_read;
1016   gsize bytes_written;
1017   GIConv cd;
1018   xmlNodePtr child;
1019   const gchar* text;
1020   gsize total_bytes;
1021   gsize bytes_left;
1022   InfAdoptedOperation* operation;
1023   switch(inf_adopted_request_get_request_type(request))
1024   {
1025   case INF_ADOPTED_REQUEST_DO:
1026     operation = inf_adopted_request_get_operation(request);
1027     if(INF_TEXT_IS_INSERT_OPERATION(operation))
1028     {
1029       op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");
1030       inf_xml_util_set_attribute_uint(
1031         op_xml,
1032         "pos",
1033         inf_text_insert_operation_get_position(
1034           INF_TEXT_INSERT_OPERATION(operation)
1035         )
1036       );
1037       g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
1038       chunk = inf_text_default_insert_operation_get_chunk(
1039         INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
1040       );
1041       result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1042       g_assert(result == TRUE);
1043       utf8_text = g_convert(
1044         inf_text_chunk_iter_get_text(&amp;iter),
1045         inf_text_chunk_iter_get_bytes(&amp;iter),
1046         "UTF-8",
1047         inf_text_chunk_get_encoding(chunk),
1048         &amp;bytes_read,
1049         &amp;bytes_written,
1050         NULL
1051       );
1052       g_assert(utf8_text != NULL);
1053       g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));
1054       inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
1055       g_free(utf8_text);
1056       g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
1057     }
1058     else if(INF_TEXT_IS_DELETE_OPERATION(operation))
1059     {
1060       op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");
1061       inf_xml_util_set_attribute_uint(
1062         op_xml,
1063         "pos",
1064         inf_text_delete_operation_get_position(
1065           INF_TEXT_DELETE_OPERATION(operation)
1066         )
1067       );
1068       if(for_sync == TRUE)
1069       {
1070         g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));
1071         chunk = inf_text_default_delete_operation_get_chunk(
1072           INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
1073         );
1074         cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
1075         result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1076         while(result == TRUE)
1077         {
1078           text = inf_text_chunk_iter_get_text(&amp;iter);
1079           total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
1080           bytes_left = total_bytes;
1081           child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);
1082           while(bytes_left &gt; 0)
1083           {
1084             inf_text_session_segment_to_xml(
1085               &amp;cd,
1086               child,
1087               text + total_bytes - bytes_left,
1088               &amp;bytes_left,
1089               inf_text_chunk_iter_get_author(&amp;iter)
1090             );
1091           }
1092           result = inf_text_chunk_iter_next(&amp;iter);
1093         }
1094         g_iconv_close(cd);
1095       }
1096       else
1097       {
1098         inf_xml_util_set_attribute_uint(
1099           op_xml,
1100           "len",
1101           inf_text_delete_operation_get_length(
1102             INF_TEXT_DELETE_OPERATION(operation)
1103           )
1104         );
1105       }
1106     }
1107     else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
1108     {
1109       op_xml = xmlNewNode(NULL, (const xmlChar*)"move");
1110       inf_xml_util_set_attribute_uint(
1111         op_xml,
1112         "caret",
1113         inf_text_move_operation_get_position(
1114           INF_TEXT_MOVE_OPERATION(operation)
1115         )
1116       );
1117       inf_xml_util_set_attribute_int(
1118         op_xml,
1119         "selection",
1120         inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
1121       );
1122     }
1123     else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
1124     {
1125       op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
1126     }
1127     else
1128     {
1129       g_assert_not_reached();
1130     }
1131     break;
1132   case INF_ADOPTED_REQUEST_UNDO:
1133     op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
1134     break;
1135   case INF_ADOPTED_REQUEST_REDO:
1136     op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
1137     break;
1138   default:
1139     g_assert_not_reached();
1140     break;
1141   }
1142   g_assert(op_xml != NULL);
1143   inf_adopted_session_write_request_info(
1144     session,
1145     request,
1146     diff_vec,
1147     xml,
1148     op_xml
1149   );
1150 }
1151 static InfAdoptedRequest*
1152 inf_text_session_xml_to_request(InfAdoptedSession* session,
1153                                 xmlNodePtr xml,
1154                                 InfAdoptedStateVector* diff_vec,
1155                                 gboolean for_sync,
1156                                 GError** error)
1157 {
1158   InfTextBuffer* buffer;
1159   InfAdoptedUser* user;
1160   guint user_id;
1161   InfAdoptedStateVector* vector;
1162   xmlNodePtr op_xml;
1163   InfAdoptedOperation* operation;
1164   InfAdoptedRequestType type;
1165   InfAdoptedRequest* request;
1166   guint pos;
1167   gchar* text;
1168   gsize bytes;
1169   InfTextChunk* chunk;
1170   gchar* utf8_text;
1171   gsize in_bytes;
1172   guint length;
1173   xmlNodePtr child;
1174   GIConv cd;
1175   guint author;
1176   gboolean cmp;
1177   gint selection;
1178   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
1179   cmp = inf_adopted_session_read_request_info(
1180     session,
1181     xml,
1182     diff_vec,
1183     &amp;user,
1184     &amp;vector,
1185     &amp;op_xml,
1186     error
1187   );
1188   if(cmp == FALSE) return FALSE;
1189   user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));
1190   if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
1191      strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
1192   {
1193     type = INF_ADOPTED_REQUEST_DO;
1194     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1195       goto fail;
1196     utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
1197     if(!utf8_text)
1198       goto fail;
1199     text = g_convert(
1200       utf8_text,
1201       in_bytes,
1202       inf_text_buffer_get_encoding(buffer),
1203       "UTF-8",
1204       NULL,
1205       &amp;bytes,
1206       error
1207     );
1208     g_free(utf8_text);
1209     if(text == NULL) goto fail;
1210     chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1211     inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
1212     g_free(text);
1213     operation = INF_ADOPTED_OPERATION(
1214       inf_text_default_insert_operation_new(pos, chunk)
1215     );
1216     inf_text_chunk_free(chunk);
1217   }
1218   else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
1219           strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
1220   {
1221     type = INF_ADOPTED_REQUEST_DO;
1222     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1223       goto fail;
1224     if(for_sync == TRUE)
1225     {
1226       chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1227       cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
1228       g_assert(cd != (GIConv)(-1));
1229       for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
1230       {
1231         if(strcmp((const char*)child-&gt;name, "segment") == 0)
1232         {
1233           text = inf_text_session_segment_from_xml(
1234             &amp;cd,
1235             child,
1236             &amp;length,
1237             &amp;bytes,
1238             &amp;author,
1239             error
1240           );
1241           if(text == NULL)
1242           {
1243             inf_text_chunk_free(chunk);
1244             g_iconv_close(cd);
1245             goto fail;
1246           }
1247           else
1248           {
1249             inf_text_chunk_insert_text(
1250               chunk,
1251               inf_text_chunk_get_length(chunk),
1252               text,
1253               bytes,
1254               length,
1255               author
1256             );
1257             g_free(text);
1258           }
1259         }
1260         else
1261         {
1262         }
1263       }
1264       g_iconv_close(cd);
1265       operation = INF_ADOPTED_OPERATION(
1266         inf_text_default_delete_operation_new(pos, chunk)
1267       );
1268       inf_text_chunk_free(chunk);
1269     }
1270     else
1271     {
1272       cmp = inf_xml_util_get_attribute_uint_required(
1273         op_xml,
1274         "len",
1275         &amp;length,
1276         error
1277       );
1278       if(cmp == FALSE) goto fail;
1279       operation = INF_ADOPTED_OPERATION(
1280         inf_text_remote_delete_operation_new(pos, length)
1281       );
1282     }
1283   }
1284   else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
1285   {
1286     type = INF_ADOPTED_REQUEST_DO;
1287     cmp = inf_xml_util_get_attribute_uint_required(
1288       op_xml,
1289       "caret",
1290       &amp;pos,
1291       error
1292     );
1293     if(cmp == FALSE) goto fail;
1294     cmp = inf_xml_util_get_attribute_int_required(
1295       op_xml,
1296       "selection",
1297       &amp;selection,
1298       error
1299     );
1300     if(cmp == FALSE) goto fail;
1301     operation = INF_ADOPTED_OPERATION(
1302       inf_text_move_operation_new(pos, selection)
1303     );
1304   }
1305   else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
1306   {
1307     type = INF_ADOPTED_REQUEST_DO;
1308     operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
1309   }
1310   else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
1311           strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
1312   {
1313     type = INF_ADOPTED_REQUEST_UNDO;
1314   }
1315   else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
1316           strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
1317   {
1318     type = INF_ADOPTED_REQUEST_REDO;
1319   }
1320   else
1321   {
1322     goto fail;
1323   }
1324   switch(type)
1325   {
1326   case INF_ADOPTED_REQUEST_DO:
1327     g_assert(operation != NULL);
1328     request = inf_adopted_request_new_do(
1329       vector,
1330       user_id,
1331       operation,
1332       g_get_real_time()
1333     );
1334     g_object_unref(operation);
1335     break;
1336   case INF_ADOPTED_REQUEST_UNDO:
1337     request = inf_adopted_request_new_undo(
1338       vector,
1339       user_id,
1340       g_get_real_time()
1341     );
1342     break;
1343   case INF_ADOPTED_REQUEST_REDO:
1344     request = inf_adopted_request_new_redo(
1345       vector,
1346       user_id,
1347       g_get_real_time()
1348     );
1349     break;
1350   default:
1351     g_assert_not_reached();
1352     break;
1353   }
1354   inf_adopted_state_vector_free(vector);
1355   return request;
1356 <a name="0"></a>fail:
1357   inf_adopted_state_vector_free(vector);
1358   return NULL;
1359 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
1360 static void
1361 inf_text_session_class_init(InfTextSessionClass* text_session_class)
1362 {
1363   GObjectClass* object_class;
1364   InfSessionClass* session_class;
1365   InfAdoptedSessionClass* adopted_session_class;
1366   object_class = G_OBJECT_CLASS(text_session_class);
1367   session_class = INF_SESSION_CLASS(text_session_class);
1368   adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);
1369   object_class-&gt;constructed = inf_text_session_constructed;
1370   object_class-&gt;dispose = inf_text_session_dispose;
1371   object_class-&gt;finalize = inf_text_session_finalize;
1372   object_class-&gt;set_property = inf_text_session_set_property;
1373   object_class-&gt;get_property = inf_text_session_get_property;
1374   session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
1375   session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;
1376   session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
1377   session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
1378   session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
1379   session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
1380   session_class-&gt;user_new = inf_text_session_user_new;
1381   session_class-&gt;synchronization_complete =</b></font>
1382     inf_text_session_synchronization_complete;
1383   adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
1384   adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;
1385   inf_text_session_error_quark = g_quark_from_static_string(
1386     "INF_TEXT_SESSION_ERROR"
1387   );
1388   g_object_class_install_property(
1389     object_class,
1390     PROP_CARET_UPDATE_INTERVAL,
1391     g_param_spec_uint(
1392       "caret-update-interval",
1393       "Caret update interval",
1394       "Minimum number of milliseconds between caret update broadcasts",
1395       0,
1396       G_MAXUINT,
1397       500,
1398       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
1399     )
1400   );
1401 }
1402 InfTextSession*
1403 inf_text_session_new(InfCommunicationManager* manager,
1404                      InfTextBuffer* buffer,
1405                      InfIo* io,
1406                      InfSessionStatus status,
1407                      InfCommunicationGroup* sync_group,
1408                      InfXmlConnection* sync_connection)
1409 {
1410   GObject* object;
1411   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1412   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1413   g_return_val_if_fail(INF_IS_IO(io), NULL);
1414   g_return_val_if_fail(
1415     (status == INF_SESSION_RUNNING &amp;&amp;
1416      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1417     (status != INF_SESSION_RUNNING &amp;&amp;
1418      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1419      INF_IS_XML_CONNECTION(sync_connection)),
1420     NULL
1421   );
1422   object = g_object_new(
1423     INF_TEXT_TYPE_SESSION,
1424     "communication-manager", manager,
1425     "buffer", buffer,
1426     "status", status,
1427     "sync-group", sync_group,
1428     "sync-connection", sync_connection,
1429     "io", io,
1430     NULL
1431   );
1432   return INF_TEXT_SESSION(object);
1433 }
1434 InfTextSession*
1435 inf_text_session_new_with_user_table(InfCommunicationManager* manager,
1436                                      InfTextBuffer* buffer,
1437                                      InfIo* io,
1438                                      InfUserTable* user_table,
1439                                      InfSessionStatus status,
1440                                      InfCommunicationGroup* sync_group,
1441                                      InfXmlConnection* sync_connection)
1442 {
1443   GObject* object;
1444   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1445   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1446   g_return_val_if_fail(INF_IS_IO(io), NULL);
1447   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1448   g_return_val_if_fail(
1449     (status == INF_SESSION_RUNNING &amp;&amp;
1450      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1451     (status != INF_SESSION_RUNNING &amp;&amp;
1452      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1453      INF_IS_XML_CONNECTION(sync_connection)),
1454     NULL
1455   );
1456   object = g_object_new(
1457     INF_TEXT_TYPE_SESSION,
1458     "communication-manager", manager,
1459     "buffer", buffer,
1460     "user-table", user_table,
1461     "status", status,
1462     "sync-group", sync_group,
1463     "sync-connection", sync_connection,
1464     "io", io,
1465     NULL
1466   );
1467   return INF_TEXT_SESSION(object);
1468 }
1469 void
1470 inf_text_session_set_user_color(InfTextSession* session,
1471                                 InfTextUser* user,
1472                                 gdouble hue)
1473 {
1474   xmlNodePtr xml;
1475   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1476   g_return_if_fail(INF_TEXT_IS_USER(user));
1477   g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);
1478   g_return_if_fail(
1479     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1480   );
1481   g_return_if_fail(
1482     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1483   );
1484   xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
1485   inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
1486   inf_xml_util_set_attribute_double(xml, "hue", hue);
1487   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
1488   g_object_set(G_OBJECT(user), "hue", hue, NULL);
1489 }
1490 void
1491 inf_text_session_flush_requests_for_user(InfTextSession* session,
1492                                          InfTextUser* user)
1493 {
1494   InfTextSessionLocalUser* local;
1495   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1496   g_return_if_fail(INF_TEXT_IS_USER(user));
1497   local = inf_text_session_find_local_user(session, user);
1498   g_assert(local != NULL);
1499   if(local-&gt;caret_timeout != NULL)
1500   {
1501     inf_text_session_broadcast_caret_selection(session, local);
1502   }
1503 }
1504 InfRequest*
1505 inf_text_session_join_user(InfSessionProxy* proxy,
1506                            const gchar* name,
1507                            InfUserStatus status,
1508                            gdouble hue,
1509                            guint caret_position,
1510                            int selection_length,
1511                            InfRequestFunc func,
1512                            gpointer user_data)
1513 {
1514 #define N_PARAMS 6u
1515   GParameter params[N_PARAMS] = {
1516     { "hue", { 0 } },
1517     { "vector", { 0 } },
1518     { "caret-position", { 0 } },
1519     { "selection-length", { 0 } },
1520     { "name", { 0 } },
1521     { "status", { 0 } }
1522   };
1523   InfSession* session;
1524   InfRequest* request;
1525   guint i;
1526   g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
1527   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
1528   g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);
1529   g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
1530   g_value_set_double(&amp;params[0].value, hue);
1531   g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
1532   g_value_set_boxed(
1533     &amp;params[1].value,
1534     inf_adopted_algorithm_get_current(
1535       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
1536     )
1537   );
1538   g_value_init(&amp;params[2].value, G_TYPE_UINT);
1539   g_value_set_uint(&amp;params[2].value, caret_position);
1540   g_value_init(&amp;params[3].value, G_TYPE_INT);
1541   g_value_set_int(&amp;params[3].value, selection_length);
1542   g_value_init(&amp;params[4].value, G_TYPE_STRING);
1543   g_value_set_string(&amp;params[4].value, name); 
1544   g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
1545   g_value_set_enum(&amp;params[5].value, status);
1546   request = inf_session_proxy_join_user(
1547     proxy,
1548     N_PARAMS,
1549     params,
1550     func,
1551     user_data
1552   );
1553   for(i = 0; i &lt; N_PARAMS; ++i)
1554     g_value_unset(&amp;params[i].value);
1555 #undef N_PARAMS
1556   g_object_unref(session);
1557   return request;
1558 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
2 #include &lt;libinftext/inf-text-buffer.h&gt;
3 #include &lt;libinfinity/inf-signals.h&gt;
4 #include &lt;string.h&gt; 
5 struct _InfTextBufferIter {
6   GtkTextIter begin;
7   GtkTextIter end;
8   InfTextUser* user;
9 };
10 typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
11 struct _InfTextGtkBufferRecord {
12   gboolean insert;
13   guint char_count;
14   guint position;
15   InfTextChunk* chunk;
16   gboolean applied;
17   InfTextGtkBufferRecord* next;
18 };
19 typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
20 struct _InfTextGtkBufferUserTags {
21   InfTextGtkBuffer* buffer;
22   InfTextUser* user;
23   GtkTextTag* colored_tag;
24 <a name="4"></a>  GtkTextTag* colorless_tag;
25 };
26 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
27 struct _InfTextGtkBufferTagRemove {
28   GtkTextBuffer* buffer;
29   GtkTextIter begin_iter;
30   GtkTextIter end_iter;
31   InfTextGtkBufferUserTags* ignore_tags;
32 };
33 typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
34 struct _InfTextGtkBufferPrivate {
35   GtkTextBuffer* buffer;
36   InfUserTable* user_table;
37   GHashTable* user_tags;
38   InfTextGtkBufferRecord* record;
39   gboolean show_user_colors;
40   InfTextUser* active_user;
41   gboolean wake_on_cursor_movement;
42   gdouble saturation;
43   gdouble value;
44   gdouble alpha;
45 };
46 enum {
47   PROP_0,
48   PROP_BUFFER,
49   PROP_USER_TABLE,
50   PROP_ACTIVE_USER,
51   PROP_WAKE_ON_CURSOR_MOVEMENT,
52   PROP_SHOW_USER_COLORS,
53   PROP_SATURATION,
54   PROP_VALUE,
55   PROP_ALPHA,
56   PROP_MODIFIED
57 };</b></font>
58 #define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))
59 static GQuark inf_text_gtk_buffer_tag_user_quark;
60 static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
61 static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
62 G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
63   G_ADD_PRIVATE(InfTextGtkBuffer)
64   G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
65   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))
66 static void
67 inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
68                               GtkTextTag* tag,
69                               InfTextUser* user)
70 {
71   InfTextGtkBufferPrivate* priv;
72   gdouble hue;
73   gdouble saturation;
74   gdouble value;
75   GdkRGBA rgba;
76   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
77 <a name="3"></a>
78   hue = inf_text_user_get_hue(user);
79   saturation = priv-&gt;saturation;
80 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  value = priv-&gt;value;
81   gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
82   rgba.alpha = priv-&gt;alpha;
83   g_object_set(G_OBJECT(tag), "background-rgba", &amp;rgba, NULL);
84 }
85 static void
86 inf_text_gtk_user_notify_hue_cb(GObject* object,
87                                 GParamSpec* pspec,
88                                 gpointer user_data)
89 {
90   InfTextGtkBuffer* buffer;
91   InfTextGtkBufferPrivate* priv;
92   guint user_id;
93   InfTextGtkBufferUserTags* tags;
94   buffer = INF_TEXT_GTK_BUFFER(user_data);
95   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
96   user_id = inf_user_get_id(INF_USER(object));
97   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
98   g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);</b></font>
99   inf_text_gtk_update_tag_color(
100     buffer,
101     tags-&gt;colored_tag,
102     INF_TEXT_USER(object)
103   );
104 }
105 static void
106 inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
107 {
108   InfTextGtkBufferUserTags* tags;
109   tags = (InfTextGtkBufferUserTags*)user_tags;
110   if(tags-&gt;colored_tag)
111   {
112     inf_signal_handlers_disconnect_by_func(
113       tags-&gt;user,
114       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
115       tags-&gt;buffer
116     );
117     g_object_unref(tags-&gt;colored_tag);
118   }
119   if(tags-&gt;colorless_tag)
120     g_object_unref(tags-&gt;colorless_tag);
121   g_slice_free(InfTextGtkBufferUserTags, tags);
122 }
123 static InfTextGtkBufferUserTags*
124 inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
125                                   guint user_id)
126 {
127   InfTextGtkBufferPrivate* priv;
128   InfTextGtkBufferUserTags* tags;
129   InfUser* user;
130   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
131   if(user_id == 0)
132     return NULL;
133   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
134   if(tags != NULL)
135   {
136     return tags;
137   }
138   else
139   {
140     user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
141     g_assert(INF_TEXT_IS_USER(user));
142     tags = g_slice_new(InfTextGtkBufferUserTags);
143     tags-&gt;buffer = buffer;
144     tags-&gt;user = INF_TEXT_USER(user);
145     tags-&gt;colored_tag = NULL;
146     tags-&gt;colorless_tag = NULL;
147     g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
148     return tags;
149   }
150 }
151 static GtkTextTag*
152 inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
153                                  InfTextGtkBufferUserTags* user_tags,
154                                  gboolean colored)
155 {
156   InfTextGtkBufferPrivate* priv;
157   GtkTextTagTable* table;
158   GtkTextTag** tag;
159   gchar* tag_name;
160   guint user_id;
161   const gchar* colorstr;
162   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
163   tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
164   if(*tag != NULL) return *tag;
165   user_id = 0;
166   if(user_tags-&gt;user != NULL)
167     user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
168   colorstr = colored ? "colored" : "colorless";
169   tag_name = g_strdup_printf("inftextgtk-user-%s-%u", colorstr, user_id);
170   *tag = gtk_text_tag_new(tag_name);
171   g_free(tag_name);
172   table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
173   gtk_text_tag_table_add(table, *tag);
174   gtk_text_tag_set_priority(*tag, 0);
175   g_object_set_qdata(
176     G_OBJECT(*tag),
177     inf_text_gtk_buffer_tag_user_quark,
178     user_tags-&gt;user
179   );
180   if(colored)
181   {
182     g_signal_connect(
183       G_OBJECT(user_tags-&gt;user),
184       "notify::hue",
185       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
186       buffer
187     );
188     inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
189   }
190   return *tag;
191 }
192 static InfTextUser*
193 inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
194 {
195   gpointer author_ptr;
196   author_ptr = g_object_get_qdata(
197     G_OBJECT(tag),
198     inf_text_gtk_buffer_tag_user_quark
199   );
200   return INF_TEXT_USER(author_ptr);
201 }
202 static InfTextUser*
203 inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
204 {
205   GSList* item;
206   InfTextUser* author;
207   for(item = tag_list; item != NULL; item = g_slist_next(item))
208   {
209     author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
210     if(author != NULL) return author;
211   }
212   return NULL;
213 }
214 static InfTextUser*
215 inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
216 {
217   GSList* tag_list;
218   InfTextUser* author;
219   tag_list = gtk_text_iter_get_tags(location);
220   author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
221   g_slist_free(tag_list);
222   return author;
223 }
224 static gboolean
225 inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
226                                           InfTextUser** toggled_on,
227                                           InfTextUser** toggled_off)
228 {
229   GSList* tag_list;
230   InfTextUser* author_on;
231   InfTextUser* author_off;
232   tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
233   author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
234   g_slist_free(tag_list);
235   if(author_on == NULL || toggled_off != NULL)
236   {
237     tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
238     author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
239     g_slist_free(tag_list);
240   }
241   if(author_on == NULL &amp;&amp; author_off == NULL)
242     if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
243       return FALSE;
244   if(toggled_on) *toggled_on = author_on;
245   if(toggled_off) *toggled_off = author_off;
246   return TRUE;
247 }
248 static void
249 inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
250                                             InfTextUser** user_on,
251                                             InfTextUser** user_off)
252 {
253   gboolean is_author_toggle;
254   do
255   {
256     gtk_text_iter_forward_to_tag_toggle(iter, NULL);
257     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
258       iter,
259       user_on,
260       user_off
261     );
262   } while(!is_author_toggle);
263 }
264 static void
265 inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
266                                             InfTextUser** user_on,
267                                             InfTextUser** user_off)
268 {
269   gboolean is_author_toggle;
270   do
271   {
272     gtk_text_iter_backward_to_tag_toggle(iter, NULL);
273     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
274       iter,
275       user_on,
276       user_off
277     );
278   } while(!is_author_toggle);
279 }
280 static void
281 inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
282                                                              gpointer data)
283 {
284   InfTextUser* author;
285   author = inf_text_gtk_buffer_author_from_tag(tag);
286   if(author != NULL)
287     gtk_text_tag_set_priority(tag, 0);
288 }
289 static void
290 inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
291                                                              gpointer data)
292 {
293   InfTextGtkBuffer* buffer;
294   InfTextGtkBufferPrivate* priv;
295   InfTextUser* author;
296   buffer = INF_TEXT_GTK_BUFFER(data);
297   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
298   author = inf_text_gtk_buffer_author_from_tag(tag);
299   if(author != NULL)
300     inf_text_gtk_update_tag_color(buffer, tag, author);
301 }
302 static void
303 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
304                                                      guint position,
305                                                      gint length,
306                                                      gboolean by_request,
307                                                      gpointer user_data);
308 static void
309 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
310                                                  GParamSpec* pspec,
311                                                  gpointer user_data);
312 static void
313 inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
314                                  GtkTextTag* tag,
315                                  GtkTextIter* start,
316                                  GtkTextIter* end,
317                                  gpointer user_data)
318 {
319   if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
320     g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), "apply-tag");
321 }
322 static void
323 inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
324                                                               gpointer data)
325 {
326   InfTextGtkBufferTagRemove* tag_remove;
327   tag_remove = (InfTextGtkBufferTagRemove*)data;
328   if(tag_remove-&gt;ignore_tags == NULL ||
329      (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
330       tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
331   {
332     gtk_text_buffer_remove_tag(
333       tag_remove-&gt;buffer,
334       tag,
335       &amp;tag_remove-&gt;begin_iter,
336       &amp;tag_remove-&gt;end_iter
337     );
338   }
339 }
340 #ifndef G_DISABLE_ASSERT
341 static gboolean
342 inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
343                                  InfTextGtkBufferRecord* record)
344 {
345   InfTextGtkBufferPrivate* priv;
346   InfTextChunk* chunk;
347   guint text_len;
348   guint buf_len;
349   gpointer buf_text;
350   gpointer chunk_text;
351   gsize buf_bytes;
352   gsize chunk_bytes;
353   int result;
354   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
355   text_len = inf_text_chunk_get_length(record-&gt;chunk);
356   buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);
357   if(record-&gt;insert)
358   {
359     if(record-&gt;char_count + text_len != buf_len)
360       return FALSE;
361     if(record-&gt;position + text_len &gt; buf_len)
362       return FALSE;
363     chunk = inf_text_buffer_get_slice(
364       INF_TEXT_BUFFER(buffer),
365       record-&gt;position,
366       text_len
367     );
368     buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
369     chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
370     inf_text_chunk_free(chunk);
371     if(buf_bytes == chunk_bytes)
372       result = memcmp(buf_text, chunk_text, buf_bytes);
373     else
374       result = -1;
375     g_free(buf_text);
376     g_free(chunk_text);
377     if(result != 0) return FALSE;
378   }
379   else
380   {
381     if(text_len &gt; record-&gt;char_count)
382       return FALSE;
383     if(record-&gt;char_count - text_len != buf_len)
384       return FALSE;
385   }
386   return TRUE;
387 }
388 #endif
389 static void
390 inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
391                                      InfTextGtkBufferRecord* against)
392 {
393   guint record_len;
394   guint against_len;
395   g_assert(record-&gt;applied == FALSE);
396   g_assert(against-&gt;applied == TRUE);
397   record_len = inf_text_chunk_get_length(record-&gt;chunk);
398   against_len = inf_text_chunk_get_length(against-&gt;chunk);
399   if(record-&gt;insert &amp;&amp; against-&gt;insert)
400   {
401     if(record-&gt;position &gt;= against-&gt;position)
402       record-&gt;position += against_len;
403   }
404   else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
405   {
406     if(record-&gt;position &gt;= against-&gt;position + against_len)
407       record-&gt;position -= against_len;
408     else if(record-&gt;position &gt;= against-&gt;position)
409       record-&gt;position = against-&gt;position;
410   }
411   else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
412   {
413     if(record-&gt;position &gt;= against-&gt;position)
414     {
415       record-&gt;position += against-&gt;position;
416     }
417     else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
418             record-&gt;position + record_len &gt; against-&gt;position)
419     {
420       inf_text_chunk_insert_chunk(
421         record-&gt;chunk,
422         against-&gt;position - record-&gt;position,
423         against-&gt;chunk
424       );
425     }
426   }
427   else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
428   {
429     if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
430     {
431       record-&gt;position -= against_len;
432     }
433     else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
434             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
435     {
436       record-&gt;position = against-&gt;position;
437       inf_text_chunk_erase(
438         record-&gt;chunk,
439         0,
440         against-&gt;position + against_len - record-&gt;position
441       );
442     }
443     else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
444             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
445     {
446       record-&gt;position = against-&gt;position;
447       inf_text_chunk_erase(
448         record-&gt;chunk,
449         0,
450         inf_text_chunk_get_length(record-&gt;chunk)
451       );
452     }
453     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
454             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
455     {
456       inf_text_chunk_erase(
457         record-&gt;chunk,
458         against-&gt;position - record-&gt;position,
459         inf_text_chunk_get_length(against-&gt;chunk)
460       );
461     }
462     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
463             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
464     {
465       inf_text_chunk_erase(
466         record-&gt;chunk,
467         against-&gt;position - record-&gt;position,
468         record-&gt;position + record_len - against-&gt;position
469       );
470     }
471   }
472   if(against-&gt;insert)
473   {
474     record-&gt;char_count += against_len;
475   }
476   else
477   {
478     g_assert(record-&gt;char_count &gt;= against_len);
479     record-&gt;char_count -= against_len;
480   }
481 }
482 static void
483 inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
484                                   InfTextGtkBufferRecord* record)
485 {
486   InfTextGtkBufferPrivate* priv;
487   InfTextGtkBufferRecord* rec;
488   InfTextGtkBufferTagRemove tag_remove;
489   GtkTextTag* tag;
490   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
491   g_assert(priv-&gt;active_user != NULL);
492   g_assert(record-&gt;applied == FALSE);
493   g_assert(inf_text_gtk_buffer_record_check(buffer, record));
494   record-&gt;applied = TRUE;
495   for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
496     if(!rec-&gt;applied)
497       inf_text_gtk_buffer_record_transform(rec-&gt;next, record);
498   if(record-&gt;insert)
499   {
500     inf_signal_handlers_block_by_func(
501       G_OBJECT(priv-&gt;buffer),
502       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
503       buffer
504     );
505     tag_remove.buffer = priv-&gt;buffer;
506     tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
507       buffer,
508       inf_user_get_id(INF_USER(priv-&gt;active_user))
509     );
510     g_assert(tag_remove.ignore_tags != NULL);
511     tag = inf_text_gtk_buffer_get_user_tag(
512       buffer,
513       tag_remove.ignore_tags,
514       priv-&gt;show_user_colors
515     );
516     gtk_text_buffer_get_iter_at_offset(
517       priv-&gt;buffer,
518       &amp;tag_remove.begin_iter,
519       record-&gt;position
520     );
521     gtk_text_buffer_get_iter_at_offset(
522       priv-&gt;buffer,
523       &amp;tag_remove.end_iter,
524       record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
525     );
526     gtk_text_tag_table_foreach(
527       gtk_text_buffer_get_tag_table(tag_remove.buffer),
528       inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
529       &amp;tag_remove
530     );
531     gtk_text_buffer_apply_tag(
532       priv-&gt;buffer,
533       tag,
534       &amp;tag_remove.begin_iter,
535       &amp;tag_remove.end_iter
536     );
537     inf_signal_handlers_unblock_by_func(
538       G_OBJECT(priv-&gt;buffer),
539       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
540       buffer
541     );
542   }
543   inf_signal_handlers_block_by_func(
544     G_OBJECT(priv-&gt;active_user),
545     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
546     buffer
547   );
548   inf_signal_handlers_block_by_func(
549     G_OBJECT(priv-&gt;active_user),
550     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
551     buffer
552   );
553   if(record-&gt;insert)
554   {
555     inf_text_buffer_text_inserted(
556       INF_TEXT_BUFFER(buffer),
557       record-&gt;position,
558       record-&gt;chunk,
559       INF_USER(priv-&gt;active_user)
560     );
561   }
562   else
563   {
564     inf_text_buffer_text_erased(
565       INF_TEXT_BUFFER(buffer),
566       record-&gt;position,
567       record-&gt;chunk,
568       INF_USER(priv-&gt;active_user)
569     );
570   }
571   inf_signal_handlers_unblock_by_func(
572     G_OBJECT(priv-&gt;active_user),
573     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
574     buffer
575   );
576   inf_signal_handlers_unblock_by_func(
577     G_OBJECT(priv-&gt;active_user),
578     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
579     buffer
580   );
581 }
582 static void
583 inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
584                                 gboolean insert,
585                                 guint position,
586                                 InfTextChunk* chunk)
587 {
588   InfTextGtkBufferPrivate* priv;
589   InfTextGtkBufferRecord* rec;
590   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
591   rec = priv-&gt;record;
592   priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
593   priv-&gt;record-&gt;insert = insert;
594   priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
595   priv-&gt;record-&gt;position = position;
596   priv-&gt;record-&gt;chunk = chunk;
597   priv-&gt;record-&gt;applied = FALSE;
598   priv-&gt;record-&gt;next = rec;
599   if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
600   {
601     if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
602     {
603       inf_text_gtk_buffer_record_signal(buffer, rec);
604 #ifndef G_ASSERT_DISABLED
605       for(; rec != NULL; rec = rec-&gt;next)
606       {
607         g_assert(
608           rec-&gt;applied == TRUE ||
609           rec-&gt;char_count ==
610             (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
611         );
612       }
613 #endif
614     }
615   }
616 }
617 static void
618 inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
619 {
620   InfTextGtkBufferPrivate* priv;
621   InfTextGtkBufferRecord* rec;
622   guint char_count;
623   guint length;
624   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
625   g_assert(priv-&gt;record != NULL);
626   if(!priv-&gt;record-&gt;applied)
627   {
628     length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
629     char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
630     if(priv-&gt;record-&gt;insert)
631     {
632       g_assert(priv-&gt;record-&gt;char_count + length == char_count);
633     }
634     else
635     {
636       g_assert(priv-&gt;record-&gt;char_count &gt;= length);
637       g_assert(priv-&gt;record-&gt;char_count - length == char_count);
638     }
639     inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
640   }
641   rec = priv-&gt;record;
642   priv-&gt;record = rec-&gt;next;
643   inf_text_chunk_free(rec-&gt;chunk);
644   g_slice_free(InfTextGtkBufferRecord, rec);
645 }
646 static void
647 inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
648                                           GtkTextIter* location,
649                                           gchar* text,
650                                           gint len,
651                                           gpointer user_data)
652 {
653   InfTextGtkBuffer* buffer;
654   InfTextGtkBufferPrivate* priv;
655   InfTextChunk* chunk;
656   buffer = INF_TEXT_GTK_BUFFER(user_data);
657   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
658   g_assert(priv-&gt;active_user != NULL);
659   chunk = inf_text_chunk_new("UTF-8");
660   inf_text_chunk_insert_text(
661     chunk,
662     0,
663     text,
664     len,
665     g_utf8_strlen(text, len),
666     inf_user_get_id(INF_USER(priv-&gt;active_user))
667   );
668   inf_text_gtk_buffer_push_record(
669     buffer,
670     TRUE,
671     gtk_text_iter_get_offset(location),
672     chunk
673   );
674 }
675 static void
676 inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
677                                          GtkTextIter* location,
678                                          gchar* text,
679                                          gint len,
680                                          gpointer user_data)
681 {
682   InfTextGtkBuffer* buffer;
683   InfTextGtkBufferPrivate* priv;
684   gpointer rec_text;
685   gsize bytes;
686   buffer = INF_TEXT_GTK_BUFFER(user_data);
687   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
688   g_assert(priv-&gt;record != NULL);
689   g_assert(priv-&gt;record-&gt;insert == TRUE);
690 #ifndef G_ASSERT_DISABLED
691   if(priv-&gt;record-&gt;applied == FALSE)
692   {
693     g_assert(
694       priv-&gt;record-&gt;position +
695         inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
696       (guint)gtk_text_iter_get_offset(location)
697     );
698     rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
699     g_assert(bytes == (gsize)len);
700     g_assert(memcmp(text, rec_text, bytes) == 0);
701     g_free(rec_text);
702   }
703 #endif
704   inf_text_gtk_buffer_pop_record(buffer);
705 }
706 static void
707 inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
708                                            GtkTextIter* begin,
709                                            GtkTextIter* end,
710                                            gpointer user_data)
711 {
712   InfTextGtkBuffer* buffer;
713   InfTextGtkBufferPrivate* priv;
714   guint begin_offset;
715   guint end_offset;
716   InfTextChunk* chunk;
717   buffer = INF_TEXT_GTK_BUFFER(user_data);
718   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
719   begin_offset = gtk_text_iter_get_offset(begin);
720   end_offset = gtk_text_iter_get_offset(end);
721   chunk = inf_text_buffer_get_slice(
722     INF_TEXT_BUFFER(buffer),
723     begin_offset,
724     end_offset - begin_offset
725   );
726   inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
727 }
728 static void
729 inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
730                                           GtkTextIter* begin,
731                                           GtkTextIter* end,
732                                           gpointer user_data)
733 {
734   InfTextGtkBuffer* buffer;
735   InfTextGtkBufferPrivate* priv;
736   buffer = INF_TEXT_GTK_BUFFER(user_data);
737   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
738   g_assert(priv-&gt;record != NULL);
739   g_assert(priv-&gt;record-&gt;insert == FALSE);
740   g_assert(priv-&gt;record-&gt;applied == TRUE ||
741            priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));
742   inf_text_gtk_buffer_pop_record(buffer);
743 }
744 static void
745 inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
746                                 GtkTextIter* location,
747                                 GtkTextMark* mark,
748                                 gpointer user_data)
749 {
750   InfTextGtkBuffer* buffer;
751   InfTextGtkBufferPrivate* priv;
752   GtkTextMark* insert_mark;
753   GtkTextMark* sel_mark;
754   GtkTextIter insert_iter;
755   GtkTextIter sel_iter;
756   guint offset;
757   int sel;
758   buffer = INF_TEXT_GTK_BUFFER(user_data);
759   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
760   insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
761   sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);
762   if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
763   {
764     if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
765        priv-&gt;wake_on_cursor_movement == TRUE)
766     {
767       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
768       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);
769       offset = gtk_text_iter_get_offset(&amp;insert_iter);
770       sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
771       if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
772          inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
773       {
774         inf_signal_handlers_block_by_func(
775           G_OBJECT(priv-&gt;active_user),
776           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
777           buffer
778         );
779         inf_signal_handlers_block_by_func(
780           G_OBJECT(priv-&gt;active_user),
781           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
782           buffer
783         );
784         inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
785         inf_signal_handlers_unblock_by_func(
786           G_OBJECT(priv-&gt;active_user),
787           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
788           buffer
789         );
790         inf_signal_handlers_unblock_by_func(
791           G_OBJECT(priv-&gt;active_user),
792           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
793           buffer
794         );
795       }
796     }
797   }
798 }
799 static void
800 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
801                                                  GParamSpec* pspec,
802                                                  gpointer user_data)
803 {
804   InfTextGtkBuffer* buffer;
805   InfTextGtkBufferPrivate* priv;
806   GtkTextMark* insert_mark;
807   GtkTextMark* sel_mark;
808   GtkTextIter insert_iter;
809   GtkTextIter sel_iter;
810   guint offset;
811   int sel;
812   buffer = INF_TEXT_GTK_BUFFER(user_data);
813   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
814   g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);
815   switch(inf_user_get_status(INF_USER(object)))
816   {
817   case INF_USER_ACTIVE:
818     insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
819     sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
820     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
821     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);
822     offset = gtk_text_iter_get_offset(&amp;insert_iter);
823     sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
824     if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
825        inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
826     {
827       inf_signal_handlers_block_by_func(
828         G_OBJECT(priv-&gt;active_user),
829         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
830         buffer
831       );
832       inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
833       inf_signal_handlers_unblock_by_func(
834         G_OBJECT(priv-&gt;active_user),
835         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
836         buffer
837       );
838     }
839     break;
840   case INF_USER_UNAVAILABLE:
841     break;
842   default:
843     break;
844   }
845 }
846 static void
847 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
848                                                      guint position,
849                                                      gint selection_length,
850                                                      gboolean by_request,
851                                                      gpointer user_data)
852 {
853   InfTextGtkBuffer* buffer;
854   InfTextGtkBufferPrivate* priv;
855   GtkTextIter insert;
856   GtkTextIter selection_bound;
857   buffer = INF_TEXT_GTK_BUFFER(user_data);
858   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
859   inf_signal_handlers_block_by_func(
860     G_OBJECT(priv-&gt;buffer),
861     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
862     buffer
863   );
864   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);
865   gtk_text_buffer_get_iter_at_offset(
866     priv-&gt;buffer,
867     &amp;selection_bound,
868     position + selection_length
869   );
870   gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);
871   inf_signal_handlers_unblock_by_func(
872     G_OBJECT(priv-&gt;buffer),
873     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
874     buffer
875   );
876 }
877 static void
878 inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
879                                         gpointer user_data)
880 {
881   g_object_notify(G_OBJECT(user_data), "modified");
882 }
883 static void
884 inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
885                                  gboolean modified)
886 {
887   InfTextGtkBufferPrivate* priv;
888   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
889   if(priv-&gt;buffer != NULL)
890   {
891     inf_signal_handlers_block_by_func(
892       G_OBJECT(priv-&gt;buffer),
893       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
894       buffer
895     );
896     gtk_text_buffer_set_modified(priv-&gt;buffer, modified);
897     inf_signal_handlers_unblock_by_func(
898       G_OBJECT(priv-&gt;buffer),
899       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
900       buffer
901     );
902     g_object_notify(G_OBJECT(buffer), "modified");
903   }
904 }
905 static void
906 inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
907 <a name="5"></a>                               GtkTextBuffer* gtk_buffer)
908 {
909   InfTextGtkBufferPrivate* priv;
910 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
911   if(priv-&gt;buffer != NULL)
912   {
913     inf_signal_handlers_disconnect_by_func(
914       G_OBJECT(priv-&gt;buffer),
915       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
916       buffer
917     );
918     inf_signal_handlers_disconnect_by_func(
919       G_OBJECT(priv-&gt;buffer),
920       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
921       buffer
922     );
923     inf_signal_handlers_disconnect_by_func(
924       G_OBJECT(priv-&gt;buffer),
925       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
926       buffer
927     );
928     inf_signal_handlers_disconnect_by_func(
929       G_OBJECT(priv-&gt;buffer),
930       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
931       buffer
932     );
933     inf_signal_handlers_disconnect_by_func(
934       G_OBJECT(priv-&gt;buffer),
935       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
936       buffer
937     );
938     inf_signal_handlers_disconnect_by_func(
939       G_OBJECT(priv-&gt;buffer),
940       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
941       buffer
942     );
943     inf_signal_handlers_disconnect_by_func(
944       G_OBJECT(priv-&gt;buffer),
945       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
946       buffer
947     );
948     g_object_unref(G_OBJECT(priv-&gt;buffer));
949   }
950   priv-&gt;buffer = gtk_buffer;
951   if(gtk_buffer != NULL)
952   {
953     g_object_ref(G_OBJECT(gtk_buffer));
954     g_signal_connect(
955       G_OBJECT(gtk_buffer),
956       "apply-tag",
957       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
958       buffer
959     );
960     g_signal_connect(
961       G_OBJECT(gtk_buffer),
962       "insert-text",
963       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
964       buffer
965     );
966     g_signal_connect_after(
967       G_OBJECT(gtk_buffer),
968       "insert-text",
969       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
970       buffer
971     );
972     g_signal_connect(
973       G_OBJECT(gtk_buffer),
974       "delete-range",
975       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
976       buffer
977     );
978     g_signal_connect_after(
979       G_OBJECT(gtk_buffer),
980       "delete-range",
981       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
982       buffer
983     );
984     g_signal_connect_after(
985       G_OBJECT(gtk_buffer),
986       "mark-set",
987       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
988       buffer
989     );
990     g_signal_connect_after(
991       G_OBJECT(gtk_buffer),
992       "modified-changed",
993       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
994       buffer
995     );
996   }
997   g_object_notify(G_OBJECT(buffer), "buffer");
998 }
999 static void</b></font>
1000 inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
1001 {
1002   InfTextGtkBufferPrivate* priv;
1003   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1004   priv-&gt;buffer = NULL;
1005   priv-&gt;user_table = NULL;
1006   priv-&gt;user_tags = g_hash_table_new_full(
1007     NULL,
1008     NULL,
1009     NULL,
1010     inf_text_gtk_buffer_user_tags_free
1011   );
1012   priv-&gt;show_user_colors = TRUE;
1013   priv-&gt;active_user = NULL;
1014   priv-&gt;wake_on_cursor_movement = FALSE;
1015   priv-&gt;saturation = 0.35;
1016   priv-&gt;value = 1.0;
1017   priv-&gt;alpha = 1.0;
1018 }
1019 static void
1020 inf_text_gtk_buffer_dispose(GObject* object)
1021 {
1022   InfTextGtkBuffer* buffer;
1023   InfTextGtkBufferPrivate* priv;
1024   buffer = INF_TEXT_GTK_BUFFER(object);
1025   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1026   g_hash_table_remove_all(priv-&gt;user_tags);
1027   inf_text_gtk_buffer_set_buffer(buffer, NULL);
1028   inf_text_gtk_buffer_set_active_user(buffer, NULL);
1029 <a name="1"></a>  g_object_unref(priv-&gt;user_table);
1030   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
1031 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1032 static void
1033 inf_text_gtk_buffer_finalize(GObject* object)
1034 {
1035   InfTextGtkBuffer* buffer;
1036   InfTextGtkBufferPrivate* priv;
1037   buffer = INF_TEXT_GTK_BUFFER(object);
1038   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1039   g_hash_table_unref(priv-&gt;user_tags);
1040   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
1041 }
1042 static void
1043 inf_text_gtk_buffer_set_property(GObject* object,
1044                                  guint prop_id,
1045                                  const GValue* value,
1046                                  GParamSpec* pspec)
1047 {
1048   InfTextGtkBuffer* buffer;
1049   InfTextGtkBufferPrivate* priv;
1050   buffer = INF_TEXT_GTK_BUFFER(object);
1051   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1052   switch(prop_id)
1053   {
1054   case PROP_BUFFER:</b></font>
1055     g_assert(priv-&gt;buffer == NULL);     inf_text_gtk_buffer_set_buffer(
1056       buffer,
1057       GTK_TEXT_BUFFER(g_value_get_object(value))
1058     );
1059     break;
1060   case PROP_USER_TABLE:
1061     g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
1062     break;
1063   case PROP_ACTIVE_USER:
1064     inf_text_gtk_buffer_set_active_user(
1065       buffer,
1066       INF_TEXT_USER(g_value_get_object(value))
1067     );
1068     break;
1069   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1070     priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
1071     break;
1072   case PROP_SHOW_USER_COLORS:
1073     priv-&gt;show_user_colors = g_value_get_boolean(value);
1074     break;
1075   case PROP_MODIFIED:
1076     inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
1077     break;
1078   case PROP_SATURATION:
1079     inf_text_gtk_buffer_set_saturation_value(
1080       buffer,
1081       g_value_get_double(value),
1082       priv-&gt;value
1083     );
1084     break;
1085   case PROP_VALUE:
1086     inf_text_gtk_buffer_set_saturation_value(
1087       buffer,
1088       priv-&gt;saturation,
1089       g_value_get_double(value)
1090     );
1091 <a name="2"></a>    break;
1092   case PROP_ALPHA:
1093     inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
1094 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
1095   default:
1096     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1097     break;
1098   }
1099 }
1100 static void
1101 inf_text_gtk_buffer_get_property(GObject* object,
1102                                  guint prop_id,
1103                                  GValue* value,
1104                                  GParamSpec* pspec)
1105 {
1106   InfTextGtkBuffer* buffer;
1107   InfTextGtkBufferPrivate* priv;
1108   buffer = INF_TEXT_GTK_BUFFER(object);
1109   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1110   switch(prop_id)
1111   {
1112   case PROP_BUFFER:
1113     g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
1114     break;</b></font>
1115   case PROP_USER_TABLE:
1116     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1117     break;
1118   case PROP_ACTIVE_USER:
1119     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1120     break;
1121   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1122     g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
1123     break;
1124   case PROP_SHOW_USER_COLORS:
1125     g_value_set_boolean(value, priv-&gt;show_user_colors);
1126     break;
1127   case PROP_MODIFIED:
1128     if(priv-&gt;buffer != NULL)
1129       g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
1130     else
1131       g_value_set_boolean(value, FALSE);
1132     break;
1133   case PROP_SATURATION:
1134     g_value_set_double(value, priv-&gt;saturation);
1135     break;
1136   case PROP_VALUE:
1137     g_value_set_double(value, priv-&gt;value);
1138     break;
1139   case PROP_ALPHA:
1140     g_value_set_double(value, priv-&gt;alpha);
1141     break;
1142   default:
1143     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1144     break;
1145   }
1146 }
1147 static gboolean
1148 inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
1149 {
1150   InfTextGtkBuffer* gtk_buffer;
1151   InfTextGtkBufferPrivate* priv;
1152   gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
1153   priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);
1154   if(priv-&gt;buffer != NULL)
1155     return gtk_text_buffer_get_modified(priv-&gt;buffer);
1156   else
1157     return FALSE;
1158 }
1159 static void
1160 inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
1161                                         gboolean modified)
1162 {
1163   inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
1164 }
1165 static const gchar*
1166 inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
1167 {
1168   return "UTF-8";
1169 }
1170 static guint
1171 inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
1172 {
1173   InfTextGtkBufferPrivate* priv;
1174   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1175   return gtk_text_buffer_get_char_count(priv-&gt;buffer);
1176 }
1177 static InfTextChunk*
1178 inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
1179                                      guint pos,
1180                                      guint len)
1181 {
1182   InfTextGtkBufferPrivate* priv;
1183   GtkTextIter begin;
1184   GtkTextIter iter;
1185   InfTextChunk* result;
1186   guint remaining;
1187   guint size;
1188   InfTextUser* author;
1189   gchar* text;
1190   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1191   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
1192   result = inf_text_chunk_new("UTF-8");
1193   remaining = len;
1194   while(remaining &gt; 0)
1195   {
1196     g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);
1197     begin = iter;
1198     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);
1199     size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);
1200     if(size &gt; remaining)
1201     {
1202       size = remaining;
1203       iter = begin;
1204       gtk_text_iter_forward_chars(&amp;iter, size);
1205     }
1206     text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);
1207     inf_text_chunk_insert_text(
1208       result,
1209       len - remaining,
1210       text,
1211       strlen(text),       size,
1212       (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
1213     );
1214     remaining -= size;
1215     g_free(text);
1216   }
1217   return result;
1218 }
1219 static void
1220 inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
1221                                        guint pos,
1222                                        InfTextChunk* chunk,
1223                                        InfUser* user)
1224 {
1225   InfTextGtkBufferPrivate* priv;
1226   InfTextChunkIter chunk_iter;
1227   InfTextGtkBufferTagRemove tag_remove;
1228   GtkTextTag* tag;
1229   GtkTextMark* mark;
1230   GtkTextIter insert_iter;
1231   gboolean insert_at_cursor;
1232   gboolean insert_at_selection_bound;
1233   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1234   tag_remove.buffer = priv-&gt;buffer;
1235   g_assert(priv-&gt;record == NULL);
1236   inf_signal_handlers_block_by_func(
1237     G_OBJECT(priv-&gt;buffer),
1238     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1239     buffer
1240   );
1241   inf_signal_handlers_block_by_func(
1242     G_OBJECT(priv-&gt;buffer),
1243     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1244     buffer
1245   );
1246   inf_signal_handlers_block_by_func(
1247     G_OBJECT(priv-&gt;buffer),
1248     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1249     buffer
1250   );
1251   if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
1252   {
1253     gtk_text_buffer_get_iter_at_offset(
1254       priv-&gt;buffer,
1255       &amp;tag_remove.end_iter,
1256       pos
1257     );
1258     do
1259     {
1260       tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
1261         INF_TEXT_GTK_BUFFER(buffer),
1262         inf_text_chunk_iter_get_author(&amp;chunk_iter)
1263       );
1264       if(tag_remove.ignore_tags)
1265       {
1266         tag = inf_text_gtk_buffer_get_user_tag(
1267           INF_TEXT_GTK_BUFFER(buffer),
1268           tag_remove.ignore_tags,
1269           priv-&gt;show_user_colors
1270         );
1271       }
1272       else
1273       {
1274         tag = NULL;
1275       }
1276       gtk_text_buffer_insert_with_tags(
1277         tag_remove.buffer,
1278         &amp;tag_remove.end_iter,
1279         inf_text_chunk_iter_get_text(&amp;chunk_iter),
1280         inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
1281         tag,
1282         NULL
1283       );
1284       tag_remove.begin_iter = tag_remove.end_iter;
1285       gtk_text_iter_backward_chars(
1286         &amp;tag_remove.begin_iter,
1287         inf_text_chunk_iter_get_length(&amp;chunk_iter)
1288       );
1289       gtk_text_tag_table_foreach(
1290         gtk_text_buffer_get_tag_table(tag_remove.buffer),
1291         inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
1292         &amp;tag_remove
1293       );
1294     } while(inf_text_chunk_iter_next(&amp;chunk_iter));
1295     if(user != INF_USER(priv-&gt;active_user) || user == NULL)
1296     {
1297       mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
1298       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1299       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1300         insert_at_cursor = TRUE;
1301       else
1302         insert_at_cursor = FALSE;
1303       mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
1304       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1305       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1306         insert_at_selection_bound = TRUE;
1307       else
1308         insert_at_selection_bound = FALSE;
1309       if(insert_at_cursor || insert_at_selection_bound)
1310       {
1311         inf_signal_handlers_block_by_func(
1312           G_OBJECT(priv-&gt;buffer),
1313           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1314           buffer
1315         );
1316         gtk_text_iter_backward_chars(
1317           &amp;tag_remove.end_iter,
1318           inf_text_chunk_get_length(chunk)
1319         );
1320         if(insert_at_cursor)
1321         {
1322           gtk_text_buffer_move_mark(
1323             priv-&gt;buffer,
1324             gtk_text_buffer_get_insert(priv-&gt;buffer),
1325             &amp;tag_remove.end_iter
1326           );
1327         }
1328         if(insert_at_selection_bound)
1329         {
1330           gtk_text_buffer_move_mark(
1331             priv-&gt;buffer,
1332             gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
1333             &amp;tag_remove.end_iter
1334           );
1335         }
1336         inf_signal_handlers_unblock_by_func(
1337           G_OBJECT(priv-&gt;buffer),
1338           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1339           buffer
1340         );
1341       }
1342     }
1343   }
1344   inf_signal_handlers_unblock_by_func(
1345     G_OBJECT(priv-&gt;buffer),
1346     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1347     buffer
1348   );
1349   inf_signal_handlers_unblock_by_func(
1350     G_OBJECT(priv-&gt;buffer),
1351     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1352     buffer
1353   );
1354   inf_signal_handlers_unblock_by_func(
1355     G_OBJECT(priv-&gt;buffer),
1356     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1357     buffer
1358   );
1359   inf_text_buffer_text_inserted(buffer, pos, chunk, user);
1360 }
1361 static void
1362 inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
1363                                       guint pos,
1364                                       guint len,
1365                                       InfUser* user)
1366 {
1367   InfTextGtkBufferPrivate* priv;
1368   InfTextChunk* chunk;
1369   GtkTextIter begin;
1370   GtkTextIter end;
1371   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1372   g_assert(priv-&gt;record == NULL);
1373   chunk = inf_text_buffer_get_slice(buffer, pos, len);
1374   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
1375   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);
1376   inf_signal_handlers_block_by_func(
1377     G_OBJECT(priv-&gt;buffer),
1378     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1379     buffer
1380   );
1381   inf_signal_handlers_block_by_func(
1382     G_OBJECT(priv-&gt;buffer),
1383     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1384     buffer
1385   );
1386   gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);
1387   inf_signal_handlers_unblock_by_func(
1388     G_OBJECT(priv-&gt;buffer),
1389     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1390     buffer
1391   );
1392   inf_signal_handlers_unblock_by_func(
1393     G_OBJECT(priv-&gt;buffer),
1394     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1395     buffer
1396   );
1397   inf_text_buffer_text_erased(buffer, pos, chunk, user);
1398   inf_text_chunk_free(chunk);
1399 }
1400 static InfTextBufferIter*
1401 inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
1402 {
1403   InfTextGtkBufferPrivate* priv;
1404   InfTextBufferIter* iter;
1405   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1406   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1407   {
1408     return NULL;
1409   }
1410   else
1411   {
1412     iter = g_slice_new(InfTextBufferIter);
1413     gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);
1414     iter-&gt;end = iter-&gt;begin;
1415     inf_text_gtk_buffer_iter_next_author_toggle(
1416       &amp;iter-&gt;end,
1417       NULL,
1418       &amp;iter-&gt;user
1419     );
1420     return iter;
1421   }
1422 }
1423 static InfTextBufferIter*
1424 inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
1425 {
1426   InfTextGtkBufferPrivate* priv;
1427   InfTextBufferIter* iter;
1428   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1429   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1430   {
1431     return NULL;
1432   }
1433   else
1434   {
1435     iter = g_slice_new(InfTextBufferIter);
1436     gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);
1437     iter-&gt;begin = iter-&gt;end;
1438     inf_text_gtk_buffer_iter_prev_author_toggle(
1439       &amp;iter-&gt;begin,
1440       &amp;iter-&gt;user,
1441       NULL
1442     );
1443     return iter;
1444   }
1445 }
1446 static void
1447 inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
1448                                         InfTextBufferIter* iter)
1449 {
1450   g_slice_free(InfTextBufferIter, iter);
1451 }
1452 static gboolean
1453 inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
1454                                      InfTextBufferIter* iter)
1455 {
1456   if(gtk_text_iter_is_end(&amp;iter-&gt;end))
1457     return FALSE;
1458   iter-&gt;begin = iter-&gt;end;
1459   inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
1460   return TRUE;
1461 }
1462 static gboolean
1463 inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
1464                                      InfTextBufferIter* iter)
1465 {
1466   if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
1467     return FALSE;
1468   iter-&gt;end = iter-&gt;begin;
1469   inf_text_gtk_buffer_iter_prev_author_toggle(
1470     &amp;iter-&gt;begin,
1471     &amp;iter-&gt;user,
1472     NULL
1473   );
1474   return TRUE;
1475 }
1476 static gpointer
1477 inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
1478                                          InfTextBufferIter* iter)
1479 {
1480   InfTextGtkBufferPrivate* priv;
1481   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1482   return gtk_text_buffer_get_slice(
1483     priv-&gt;buffer,
1484     &amp;iter-&gt;begin,
1485     &amp;iter-&gt;end,
1486     TRUE
1487   );
1488 }
1489 static guint
1490 inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
1491                                            InfTextBufferIter* iter)
1492 {
1493   return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1494 }
1495 static guint
1496 inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
1497                                            InfTextBufferIter* iter)
1498 {
1499   return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1500     gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1501 }
1502 static gsize
1503 inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
1504                                           InfTextBufferIter* iter)
1505 {
1506   GtkTextIter walk;
1507   gsize bytes;
1508   guint remaining;
1509   guint end;
1510   guint line_chars;
1511   guint line_bytes;
1512   gboolean result;
1513   walk = iter-&gt;begin;
1514   bytes = 0;
1515   remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1516     gtk_text_iter_get_offset(&amp;walk);
1517   end = gtk_text_iter_get_offset(&amp;iter-&gt;end);
1518   while(remaining &gt; 0)
1519   {
1520     line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
1521       gtk_text_iter_get_line_offset(&amp;walk);
1522     if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
1523     {
1524       line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
1525         gtk_text_iter_get_line_index(&amp;walk);
1526       remaining -= line_chars;
1527       bytes += line_bytes;
1528       result = gtk_text_iter_forward_line(&amp;walk);
1529       g_assert(remaining == 0 || result == TRUE);
1530     }
1531     else
1532     {
1533       line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
1534         gtk_text_iter_get_line_index(&amp;walk);
1535       remaining = 0;
1536       bytes += line_bytes;
1537     }
1538   }
1539   return bytes;
1540 }
1541 static guint
1542 inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
1543                                            InfTextBufferIter* iter)
1544 {
1545   return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
1546 }
1547 static void
1548 inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
1549 {
1550   GObjectClass* object_class;
1551   object_class = G_OBJECT_CLASS(text_gtk_buffer_class);
1552   object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
1553   object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
1554   object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
1555   object_class-&gt;get_property = inf_text_gtk_buffer_get_property;
1556   inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
1557     "inf-text-gtk-buffer-tag-user"
1558   );
1559   g_object_class_install_property(
1560     object_class,
1561     PROP_BUFFER,
1562     g_param_spec_object(
1563       "buffer",
1564       "Buffer",
1565       "The underlaying GtkTextBuffer",
1566       GTK_TYPE_TEXT_BUFFER,
1567       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1568     )
1569   );
1570   g_object_class_install_property(
1571     object_class,
1572     PROP_USER_TABLE,
1573     g_param_spec_object(
1574       "user-table",
1575       "User table",
1576       "A user table of the participating users",
1577       INF_TYPE_USER_TABLE,
1578       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1579     )
1580   );
1581   g_object_class_install_property(
1582     object_class,
1583     PROP_ACTIVE_USER,
1584     g_param_spec_object(
1585       "active-user",
1586       "Active user",
1587       "The user currently inserting text locally",
1588       INF_TEXT_TYPE_USER,
1589       G_PARAM_READWRITE
1590     )
1591   );
1592   g_object_class_install_property(
1593     object_class,
1594     PROP_WAKE_ON_CURSOR_MOVEMENT,
1595     g_param_spec_boolean(
1596       "wake-on-cursor-movement",
1597       "Wake on cursor movement",
1598       "Whether to make inactive users active when the insertion mark in the "
1599       "TextBuffer moves",
1600       FALSE,
1601       G_PARAM_READWRITE
1602     )
1603   );
1604   g_object_class_install_property(
1605     object_class,
1606     PROP_SHOW_USER_COLORS,
1607     g_param_spec_boolean(
1608       "show-user-colors",
1609       "Show user colors",
1610       "Whether to show user colors initially for newly written text",
1611       TRUE,
1612       G_PARAM_READWRITE
1613     )
1614   );
1615   g_object_class_install_property(
1616     object_class,
1617     PROP_SATURATION,
1618     g_param_spec_double(
1619       "saturation",
1620       "Saturation",
1621       "Saturation of user colors in a HSV color model",
1622       0.0,
1623       1.0,
1624       0.35,
1625       G_PARAM_READWRITE
1626     )
1627   );
1628   g_object_class_install_property(
1629     object_class,
1630     PROP_VALUE,
1631     g_param_spec_double(
1632       "value",
1633       "Value",
1634       "Value of user colors in a HSV color model",
1635       0.0,
1636       1.0,
1637       1.0,
1638       G_PARAM_READWRITE
1639     )
1640   );
1641   g_object_class_install_property(
1642     object_class,
1643     PROP_VALUE,
1644     g_param_spec_double(
1645       "alpha",
1646       "Alpha",
1647       "The translucency of the user color",
1648       0.0,
1649       1.0,
1650       1.0,
1651       G_PARAM_READWRITE
1652     )
1653   );
1654   g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
1655 }
1656 static void
1657 inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
1658 <a name="0"></a>{
1659   iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
1660   iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
1661 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1662 static void
1663 inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
1664 {
1665   iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
1666   iface-&gt;get_length = inf_text_gtk_buffer_get_length;
1667   iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
1668   iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
1669   iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
1670   iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
1671   iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
1672   iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
1673   iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
1674   iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
1675   iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
1676   iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
1677   iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
1678   iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
1679   iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
1680   iface-&gt;text_inserted = NULL;</b></font>
1681   iface-&gt;text_erased = NULL;
1682 }
1683 InfTextGtkBuffer*
1684 inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
1685                         InfUserTable* user_table)
1686 {
1687   GObject* object;
1688   g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
1689   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1690   object = g_object_new(
1691     INF_TEXT_GTK_TYPE_BUFFER,
1692     "buffer", buffer,
1693     "user-table", user_table,
1694     NULL
1695   );
1696   return INF_TEXT_GTK_BUFFER(object);
1697 }
1698 GtkTextBuffer*
1699 inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
1700 {
1701   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1702   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
1703 }
1704 void
1705 inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
1706                                     InfTextUser* user)
1707 {
1708   InfTextGtkBufferPrivate* priv;
1709   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1710   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1711   g_return_if_fail(
1712     user == NULL ||
1713     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1714   );
1715   g_return_if_fail(
1716     user == NULL ||
1717     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1718   );
1719   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1720   if(priv-&gt;active_user != NULL)
1721   {
1722     inf_signal_handlers_disconnect_by_func(
1723       G_OBJECT(priv-&gt;active_user),
1724       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1725       buffer
1726     );
1727     inf_signal_handlers_disconnect_by_func(
1728       G_OBJECT(priv-&gt;active_user),
1729       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1730       buffer
1731     );
1732     g_object_unref(G_OBJECT(priv-&gt;active_user));
1733   }
1734   priv-&gt;active_user = user;
1735   if(user != NULL)
1736   {
1737     g_object_ref(G_OBJECT(user));
1738     g_signal_connect(
1739       G_OBJECT(user),
1740       "notify::status",
1741       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1742       buffer
1743     );
1744     g_signal_connect(
1745       G_OBJECT(user),
1746       "selection-changed",
1747       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1748       buffer
1749     );
1750   }
1751   g_object_notify(G_OBJECT(buffer), "active-user");
1752 }
1753 InfTextUser*
1754 inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
1755 {
1756   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1757   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
1758 }
1759 InfTextUser*
1760 inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
1761                                GtkTextIter* location)
1762 {
1763   InfTextGtkBufferPrivate* priv;
1764   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1765   g_return_val_if_fail(
1766     location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
1767     NULL
1768   );
1769   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1770   return inf_text_gtk_buffer_iter_get_author(location);
1771 }
1772 InfTextUser*
1773 inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
1774                                      GtkTextTag* tag)
1775 {
1776   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1777   g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);
1778   return inf_text_gtk_buffer_author_from_tag(tag);
1779 }
1780 gboolean
1781 inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
1782                                      const GtkTextIter* iter,
1783                                      InfTextUser** user_on,
1784                                      InfTextUser** user_off)
1785 {
1786   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1787   g_return_val_if_fail(iter != NULL, FALSE);
1788   return inf_text_gtk_buffer_iter_is_author_toggle(
1789     iter,
1790     user_on,
1791     user_off
1792   );
1793 }
1794 gboolean
1795 inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
1796                                              GtkTextIter* iter,
1797                                              InfTextUser** user_on,
1798                                              InfTextUser** user_off)
1799 {
1800   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1801   g_return_val_if_fail(iter != NULL, FALSE);
1802   if(gtk_text_iter_is_end(iter))
1803     return FALSE;
1804   inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
1805   return TRUE;
1806 }
1807 gboolean
1808 inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
1809                                               GtkTextIter* iter,
1810                                               InfTextUser** user_on,
1811                                               InfTextUser** user_off)
1812 {
1813   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1814   g_return_val_if_fail(iter != NULL, FALSE);
1815   if(gtk_text_iter_is_start(iter))
1816     return FALSE;
1817   inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
1818   return TRUE;
1819 }
1820 void
1821 inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
1822                                                 gboolean wake)
1823 {
1824   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1825   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
1826   g_object_notify(G_OBJECT(buffer), "wake-on-cursor-movement");
1827 }
1828 gboolean
1829 inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
1830 {
1831   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1832   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
1833 }
1834 void
1835 inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
1836 {
1837   InfTextGtkBufferPrivate* priv;
1838   GtkTextTagTable* tag_table;
1839   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1840   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1841   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1842   gtk_text_tag_table_foreach(
1843     tag_table,
1844     inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
1845     buffer
1846   );
1847 }
1848 void
1849 inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
1850                                          gdouble saturation,
1851                                          gdouble value)
1852 {
1853   InfTextGtkBufferPrivate* priv;
1854   GtkTextTagTable* tag_table;
1855   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1856   g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
1857   g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);
1858   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1859   if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
1860     return;
1861   g_object_freeze_notify(G_OBJECT(buffer));
1862   if(saturation != priv-&gt;saturation)
1863   {
1864     priv-&gt;saturation = saturation;
1865     g_object_notify(G_OBJECT(buffer), "saturation");
1866   }
1867   if(value != priv-&gt;value)
1868   {
1869     priv-&gt;value = value;
1870     g_object_notify(G_OBJECT(buffer), "value");
1871   }
1872   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1873   gtk_text_tag_table_foreach(
1874     tag_table,
1875     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1876     buffer
1877   );
1878   g_object_thaw_notify(G_OBJECT(buffer));
1879 }
1880 void
1881 inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
1882                              gdouble alpha)
1883 {
1884   InfTextGtkBufferPrivate* priv;
1885   GtkTextTagTable* tag_table;
1886   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1887   g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);
1888   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1889   g_object_freeze_notify(G_OBJECT(buffer));
1890   if(alpha != priv-&gt;alpha)
1891   {
1892     priv-&gt;alpha = alpha;
1893     g_object_notify(G_OBJECT(buffer), "alpha");
1894   }
1895   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1896   gtk_text_tag_table_foreach(
1897     tag_table,
1898     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1899     buffer
1900   );
1901   g_object_thaw_notify(G_OBJECT(buffer));
1902 }
1903 gdouble
1904 inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
1905 {
1906   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1907   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
1908 }
1909 gdouble
1910 inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
1911 {
1912   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1913   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
1914 }
1915 void
1916 inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
1917                                          gboolean show)
1918 {
1919   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1920   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
1921   g_object_notify(G_OBJECT(buffer), "show-user-colors");
1922 }
1923 gboolean
1924 inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
1925 {
1926   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1927   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
1928 }
1929 void
1930 inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
1931                                      gboolean show,
1932                                      GtkTextIter* start,
1933                                      GtkTextIter* end)
1934 {
1935   InfTextGtkBufferPrivate* priv;
1936   GtkTextIter iter;
1937   GtkTextIter prev;
1938   InfTextUser* user;
1939   InfTextGtkBufferUserTags* tags;
1940   GtkTextTag* hide_tag;
1941   GtkTextTag* show_tag;
1942   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1943   g_return_if_fail(start != NULL);
1944   g_return_if_fail(end != NULL);
1945   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1946   iter = *start;
1947   prev = iter;
1948   while(!gtk_text_iter_equal(&amp;iter, end))
1949   {
1950     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
1951     if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
1952       iter = *end;
1953     if(user != NULL)
1954     {
1955       tags = g_hash_table_lookup(
1956         priv-&gt;user_tags,
1957         GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
1958       );
1959       g_assert(tags != NULL);
1960       if(show)
1961       {
1962         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1963         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1964       }
1965       else
1966       {
1967         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1968         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1969       }
1970       inf_signal_handlers_block_by_func(
1971         priv-&gt;buffer,
1972         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1973         buffer
1974       );
1975       gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
1976       gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);
1977       inf_signal_handlers_unblock_by_func(
1978         priv-&gt;buffer,
1979         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1980         buffer
1981       );
1982     }
1983     prev = iter;
1984   }
1985 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
