<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-text-session.c &amp; inf-text-gtk-buffer.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-session.c &amp; inf-text-gtk-buffer.c
      </h3>
<h1 align="center">
        9.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-session.c (10.797546%)<th>inf-text-gtk-buffer.c (9.090909%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1748-1778)<td><a href="#" name="0">(2131-2151)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(843-871)<td><a href="#" name="1">(1362-1392)</a><td align="center"><font color="#cc0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(873-896)<td><a href="#" name="2">(1436-1459)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(276-305)<td><a href="#" name="3">(153-175)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(42-60)<td><a href="#" name="4">(84-125)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1211-1242)<td><a href="#" name="5">(1210-1320)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-move-operation.h&gt;
#include &lt;libinftext/inf-text-chunk.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;libxml/tree.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

<a name="4"></a>/* TODO: Optionally broadcast operations delayed to merge adjacent operations
 * and send as a single request. */

<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
struct _InfTextSessionLocalUser {
  InfTextSession* session;
  InfTextUser* user;
  GTimeVal last_caret_update;
  InfIoTimeout* caret_timeout;
};

typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
struct _InfTextSessionPrivate {
  guint caret_update_interval;
  GSList* local_users;
};

enum {
  PROP_0,

  PROP_CARET_UPDATE_INTERVAL
};</b></font>

typedef struct _InfTextSessionInsertForeachData
  InfTextSessionInsertForeachData;
typedef struct _InfTextSessionEraseForeachData
  InfTextSessionEraseForeachData;

struct _InfTextSessionInsertForeachData {
  guint position;
  InfTextChunk* chunk;
  InfUser* user;
};

struct _InfTextSessionEraseForeachData {
  guint position;
  guint length;
  InfUser* user;
};

#define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))

static GQuark inf_text_session_error_quark;

G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
  G_ADD_PRIVATE(InfTextSession))

/*
 * Utility functions
 */

/* Returns the difference between two GTimeVal, in milliseconds */
static guint
inf_text_session_timeval_diff(GTimeVal* first,
                              GTimeVal* second)
{
  g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
           (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
            first-&gt;tv_usec &gt;= second-&gt;tv_usec));

  /* Don't risk overflow, don't need to convert to signed int */
  return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
         (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
}

/* Converts at most *bytes bytes with cd and writes the result, which are
 * at most 1024 bytes, into xml, setting the given author. *bytes will be
 * set to the number of bytes not yet processed. */
static void
inf_text_session_segment_to_xml(GIConv* cd,
                                xmlNodePtr xml,
                                gconstpointer text,
                                gsize* bytes, /* in/out */
                                guint author)
{
  gchar utf8_text[1024];
  gsize result;

  gsize bytes_left;

  gchar* inbuf;
  gchar* outbuf;

  bytes_left = 1024;

  inbuf = *(gchar**)(gpointer)&amp;text; /* cast const away without warning */
  outbuf = utf8_text;

  result = g_iconv(
    *cd,
    &amp;inbuf,
    bytes,
    &amp;outbuf,
    &amp;bytes_left
  );

  /* Conversion into UTF-8 should always succeed */
  g_assert(result == 0 || errno == E2BIG);

  inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
  inf_xml_util_set_attribute_uint(xml, "author", author);
}

static gpointer
inf_text_session_segment_from_xml(GIConv* cd,
                                  xmlNodePtr xml,
                                  guint* length,
                                  gsize* bytes,
                                  guint* author,
                                  GError** error)
{
  gsize bytes_read;
  gchar* utf8_text;
  gpointer text;

  if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
    return NULL;

  utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
  if(!utf8_text)
    return NULL;

  text = g_convert_with_iconv(
    utf8_text,
    bytes_read,
    *cd,
    NULL,
    bytes,
    error
  );

  g_free(utf8_text);
  return text;
}

/*
 * Caret/Selection handling
 */

static InfTextSessionLocalUser*
inf_text_session_find_local_user(InfTextSession* session,
                                 InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;
    if(local-&gt;user == user)
      return local;
  }

  return NULL;
}

static void
inf_text_session_broadcast_caret_selection(InfTextSession* session,
                                           InfTextSessionLocalUser* local)
{
  InfAdoptedOperation* operation;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* request;
  guint buf_len;
  guint position;
  int sel;
  guint end;

  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  position = inf_text_user_get_caret_position(local-&gt;user);
  sel = inf_text_user_get_selection_length(local-&gt;user);
  end = position + sel;

  /* Clamp position and selection to buffer length. The only case when this is
   * needed is when a local user's position is beyond the end of the document
   * since there are some local document modifications. This can happen with
   * for example InfTextFixlineBuffer. */
  /* TODO: This should be handled more cleverly, by propagating the user
   * position and selection through the buffer, to make sure that at this
   * point it is always consistent with the infinote view of the buffer. */
  buf_len = inf_text_buffer_get_length(
    INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
  );

  if(position &gt; buf_len)
    position = buf_len;
  if(end &gt; buf_len)
    end = buf_len;

  if(end &gt;= position)
    sel = (int)(end - position);
  else
    sel = -(int)(position - end);

  operation = INF_ADOPTED_OPERATION(
    inf_text_move_operation_new(position, sel)
  );

  request = inf_adopted_algorithm_generate_request(
    algorithm,
    INF_ADOPTED_REQUEST_DO,
    INF_ADOPTED_USER(local-&gt;user),
    operation
  );

  /* This cannot fail since operation is not applied */
  inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

  g_object_unref(operation);

  inf_adopted_session_broadcast_request(
    INF_ADOPTED_SESSION(session),
    request
  );

  g_object_unref(request);

  g_get_current_time(&amp;local-&gt;last_caret_update);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );

    local-&gt;caret_timeout = NULL;
  }
}

static void
<a name="3"></a>inf_text_session_caret_update_timeout_func(gpointer user_data)
{
  InfTextSessionLocalUser* local;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  local = (InfTextSessionLocalUser*)user_data;

  local-&gt;caret_timeout = NULL;
  inf_text_session_broadcast_caret_selection(local-&gt;session, local);
}

static void
inf_text_session_selection_changed_cb(InfTextUser* user,
                                      guint position,
                                      gint sel,
                                      gboolean by_request,
                                      gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;
  InfTextSessionLocalUser* local;
  GTimeVal current;
  guint diff;

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  /* We should block all changes that have by_request set to FALSE... breaks
   * if someone else does that... should maybe emit a warning instead. */
  g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
            (execute_request == NULL &amp;&amp; by_request == TRUE));</b></font>

  if(execute_request == NULL)
  {
    local = inf_text_session_find_local_user(session, user);
    g_assert(local != NULL);

    g_get_current_time(&amp;current);
    diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);

    if(diff &lt; priv-&gt;caret_update_interval)
    {
      if(local-&gt;caret_timeout == NULL)
      {
        /* TODO: Interrupt timeout if a -caret request is sent from that
         * local user. */
        local-&gt;caret_timeout = inf_io_add_timeout(
          inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
          priv-&gt;caret_update_interval - diff,
          inf_text_session_caret_update_timeout_func,
          local,
          NULL
        );
      }
    }
    else
    {
      inf_text_session_broadcast_caret_selection(session, local);
    }
  }
}

static void
inf_text_session_add_local_user(InfTextSession* session,
                                InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  local = g_slice_new(InfTextSessionLocalUser);
  local-&gt;session = session;
  local-&gt;user = user;
  g_get_current_time(&amp;local-&gt;last_caret_update);
  local-&gt;caret_timeout = NULL;

  priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);

  g_signal_connect_after(
    G_OBJECT(user),
    "selection-changed",
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );
}

static void
inf_text_session_remove_local_user(InfTextSession* session,
                                   InfTextSessionLocalUser* local)
{
  InfTextSessionPrivate* priv;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );
  }

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(local-&gt;user),
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );

  g_slice_free(InfTextSessionLocalUser, local);
  priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
}

static void
inf_text_session_local_user_added_cb(InfUserTable* user_table,
                                     InfUser* user,
                                     gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}

static void
inf_text_session_local_user_removed_cb(InfUserTable* user_table,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionLocalUser* local;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
  g_assert(local != NULL);

  inf_text_session_remove_local_user(session, local);
}

static void
inf_text_session_block_local_users_selection_changed(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;

    inf_signal_handlers_block_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      session
    );
  }
}

static void
inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(sess);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      sess
    );
  }
}

static void
inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  InfTextSessionInsertForeachData* data;
  guint position;
  gint length;

  data = (InfTextSessionInsertForeachData*)user_data;
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    /* TODO: Handle separately if insert-caret */
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));

    inf_text_move_operation_transform_insert(
      data-&gt;position,
      inf_text_chunk_get_length(data-&gt;chunk),
      &amp;position,
      &amp;length,
      /* Right gravity for local insertions, left gravity for remote ones */
      user == data-&gt;user ? FALSE : TRUE
    );

    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
      user == data-&gt;user ? TRUE : FALSE
    );
  }
}

static void
inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
                                                    gpointer user_data)
{
  InfTextSessionEraseForeachData* data;
  guint position;
  gint length;

  data = (InfTextSessionEraseForeachData*)user_data;
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    /* TODO: Handle separately if erase-caret */
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));

    inf_text_move_operation_transform_delete(
      data-&gt;position,
      data-&gt;length,
      &amp;position,
      &amp;length
    );

    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
      user == data-&gt;user ? TRUE : FALSE
    );
  }
}

/* The after handlers readjust the caret and selection properties of the
 * users. Block handlers so we don't broadcast this. */
static void
inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
                                         guint pos,
                                         InfTextChunk* chunk,
                                         InfUser* user,
                                         gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;

  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionInsertForeachData data;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  if(execute_request == NULL)
  {
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );

    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );

    /* This cannot fail since operation is not applied */
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );

    g_object_unref(request);
    g_object_unref(operation);
  }

  data.position = pos;
  data.chunk = chunk;
  data.user = user;

  inf_text_session_block_local_users_selection_changed(session);

  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_inserted_cb_foreach_func,
    &amp;data
  );

#if 0
  /* TODO: If that was an insert-caret request, then do this: */
  if(user != NULL)
  {
    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      pos + inf_text_chunk_get_length(chunk),
      0,
      TRUE
    );
  }
#endif

  inf_text_session_unblock_local_users_selection_changed(session);
}

static void
inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;

  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionEraseForeachData data;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  if(execute_request == NULL)
  {
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_delete_operation_new(pos, chunk)
    );

    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );

    /* This cannot fail since operation is not applied */
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );

    g_object_unref(request);
    g_object_unref(operation);
  }

  data.position = pos;
  data.length = inf_text_chunk_get_length(chunk);
  data.user = user;

  inf_text_session_block_local_users_selection_changed(session);

  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_erased_cb_foreach_func,
    &amp;data
  );

  /* TODO: If that was an erase-caret request, then do this: */
#if 0
  if(user != NULL)
    inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
#endif

  inf_text_session_unblock_local_users_selection_changed(session);
}

static void
inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}

static void
inf_text_session_init_text_handlers(InfTextSession* session)
{
  InfTextBuffer* buffer;
  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  user_table = inf_session_get_user_table(INF_SESSION(session));

  g_signal_connect(
    G_OBJECT(buffer),
    "text-inserted",
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(buffer),
    "text-erased",
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(user_table),
    "add-local-user",
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(user_table),
    "remove-local-user",
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
  );

  inf_user_table_foreach_local_user(
    user_table,
    inf_text_session_init_text_handlers_user_foreach_func,
    session
  );
}

/*
 * GObject overrides.
 */

static void
inf_text_session_init(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
  priv = INF_TEXT_SESSION_PRIVATE(session);

  priv-&gt;caret_update_interval = 500;
}

static void
inf_text_session_constructed(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfSessionStatus status;

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);

  /* We can either be already synchronized in which case we use the given
   * buffer as initial buffer. This is used to initiate a new session with
   * predefined content. In that case, we can directly start through. In the
   * other case we are getting synchronized in which case the buffer must be
   * empty (we will fill it during synchronization). Text handlers are
   * connected when synchronization is complete. */
  g_assert(
    status == INF_SESSION_RUNNING ||
    inf_text_buffer_get_length(buffer) == 0
  );

  if(status == INF_SESSION_RUNNING)
    inf_text_session_init_text_handlers(session);
}

/*static void
inf_text_session_dispose_foreach_local_user_func(InfUser* user,
                                                 gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  g_signal_handlers_disconnect_matched(
    G_OBJECT(user),
    G_SIGNAL_MATCH_FUNC,
    0,
    0,
    NULL,
    G_CALLBACK(inf_text_session_selection_changed_cb),
    NULL
  );
}*/

static void
inf_text_session_dispose(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));

  while(priv-&gt;local_users != NULL)
  {
    inf_text_session_remove_local_user(
      session,
      (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
    );
  }

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
<a name="1"></a>  );

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
inf_text_session_finalize(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
}

static void
inf_text_session_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  switch(prop_id)
<a name="2"></a>  {
  case PROP_CARET_UPDATE_INTERVAL:</b></font>
    priv-&gt;caret_update_interval = g_value_get_uint(value);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_session_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_CARET_UPDATE_INTERVAL:
    g_value_set_uint(value, priv-&gt;caret_update_interval);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * Network command handlers
 */

static InfCommunicationScope
inf_text_session_handle_user_color_change(InfTextSession* session,
                                          InfXmlConnection* connection,
                                          xmlNodePtr xml,
                                          GError** error)
{
  InfUserTable* user_table;
  guint user_id;
  InfUser* user;
  gdouble hue;

  user_table = inf_session_get_user_table(INF_SESSION(session));

  if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
    return INF_COMMUNICATION_SCOPE_PTP;
  if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
    return INF_COMMUNICATION_SCOPE_PTP;

  /* TODO: A public function in InfSession that does the following two checks
   * (and returns the user). This can also be used in
   * inf_session_handle_user_status_change */
  user = inf_user_table_lookup_user_by_id(user_table, user_id);
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _("No such user with ID '%u'"),
      user_id
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
     inf_user_get_connection(user) != connection)
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _("User did not join from this connection")
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  g_assert(INF_TEXT_IS_USER(user));

  if(hue &lt; 0.0 || hue &gt; 1.0)
  {
    g_set_error(
      error,
      inf_text_session_error_quark,
      INF_TEXT_SESSION_ERROR_INVALID_HUE,
      _("Invalid hue value: '%g'"),
      hue
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  g_object_set(G_OBJECT(user), "hue", hue, NULL);
  return INF_COMMUNICATION_SCOPE_GROUP;
}

/*
 * InfSession overrides
 */

static void
inf_text_session_to_xml_sync(InfSession* session,
                             xmlNodePtr parent)
{
  InfTextBuffer* buffer;
  InfTextBufferIter* iter;
  xmlNodePtr xml;
  gboolean result;

  gchar* text;
  gsize total_bytes;
  gsize bytes_left;
  GIConv cd;

  INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
    session,
    parent
  );

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
  cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));

  iter = inf_text_buffer_create_begin_iter(buffer);
  if(iter != NULL)
  {
    result = TRUE;
    while(result == TRUE)
    {
      /* Write segment in 1024 byte chunks */
      text = inf_text_buffer_iter_get_text(buffer, iter);
      total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
      bytes_left = total_bytes;

      while(bytes_left &gt; 0)
      {
        xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
        inf_text_session_segment_to_xml(
          &amp;cd,
          xml,
          text + total_bytes - bytes_left,
          &amp;bytes_left,
          inf_text_buffer_iter_get_author(buffer, iter)
        );
      }

      g_free(text);
      result = inf_text_buffer_iter_next(buffer, iter);
    }

    inf_text_buffer_destroy_iter(buffer, iter);
  }

  g_iconv_close(cd);
}

static gboolean
inf_text_session_process_xml_sync(InfSession* session,
                                  InfXmlConnection* connection,
                                  const xmlNodePtr xml,
                                  GError** error)
{
  InfTextBuffer* buffer;
  GIConv cd;

  gpointer text;
  gsize bytes;
  guint length;
  guint author;
  InfUser* user;

  if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
  {
    buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
    cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");

    text = inf_text_session_segment_from_xml(
      &amp;cd,
      xml,
      &amp;length,
      &amp;bytes,
      &amp;author,
      error
    );

    g_iconv_close(cd);
    if(text == NULL) return FALSE;

    if(author != 0)
    {
      /* TODO: inf_user_table_lookup_user_by_id_required, with error. */
      user = inf_user_table_lookup_user_by_id(
        inf_session_get_user_table(session),
        author
      );

      if(user == NULL)
      {
        g_free(text);

        g_set_error(
          error,
          inf_user_error_quark(),
          INF_USER_ERROR_NO_SUCH_USER,
          _("No such user with ID '%u'"),
          author
        );

        return FALSE;
      }
    }
    else
    {
      user = NULL;
    }

    inf_text_buffer_insert_text(
      buffer,
      inf_text_buffer_get_length(buffer),
      text,
      bytes,
      length,
      user
    );

    g_free(text);
    return TRUE;
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
      session,
      connection,
      xml,
      error
    );
  }
}

static InfCommunicationScope
inf_text_session_process_xml_run(InfSession* session,
                                 InfXmlConnection* connection,
                                 const xmlNodePtr xml,
                                 GError** error)
{
  if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
  {
    return inf_text_session_handle_user_color_change(
      INF_TEXT_SESSION(session),
      connection,
      xml,
      error
    );
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
      session,
      connection,
      xml,
      error
    );
  }
}

static GArray*
inf_text_session_get_xml_user_props(InfSession* session,
                                    InfXmlConnection* connection,
                                    const xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  GArray* array;
  GParameter* parameter;
  guint caret;
  gint selection;
  gdouble hue;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  array = parent_class-&gt;get_xml_user_props(session, connection, xml);

  /* TODO: Error reporting for get_xml_user_props */
  if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
  {
    parameter = inf_session_get_user_property(array, "caret-position");
    g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
    g_value_set_uint(&amp;parameter-&gt;value, caret);
  }

  parameter = inf_session_get_user_property(array, "selection-length");
  g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
  if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
    g_value_set_int(&amp;parameter-&gt;value, selection);
  else
    g_value_set_int(&amp;parameter-&gt;value, 0);

  parameter = inf_session_get_user_property(array, "hue");
  g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);

  /* Use a random hue if none set */
  if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
    g_value_set_double(&amp;parameter-&gt;value, hue);
  else
    g_value_set_double(&amp;parameter-&gt;value, g_random_double());

  return array;
}

static void
inf_text_session_set_xml_user_props(InfSession* session,
                                    const GParameter* params,
                                    guint n_params,
                                    xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  const GParameter* param;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  parent_class-&gt;set_xml_user_props(session, params, n_params, xml);

  param = inf_session_lookup_user_property(
    params,
    n_params,
    "caret-position"
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_uint(
      xml,
      "caret",
      g_value_get_uint(&amp;param-&gt;value)
<a name="5"></a>    );
  }

<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  param = inf_session_lookup_user_property(
    params,
    n_params,
    "selection-length"
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_int(
      xml,
      "selection",
      g_value_get_int(&amp;param-&gt;value)
    );
  }

  param = inf_session_lookup_user_property(
    params,
    n_params,
    "hue"
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_double(
      xml,
      "hue",
      g_value_get_double(&amp;param-&gt;value)
    );
  }
}

static gboolean</b></font>
inf_text_session_validate_user_props(InfSession* session,
                                     const GParameter* params,
                                     guint n_params,
                                     InfUser* exclude,
                                     GError** error)
{
  InfSessionClass* parent_class;
  const GParameter* caret;
  gboolean result;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  result = parent_class-&gt;validate_user_props(
    session,
    params,
    n_params,
    exclude,
    error
  );

  if(result == FALSE) return FALSE;

  caret = inf_session_lookup_user_property(
    params,
    n_params,
    "caret-position"
  );

  if(caret == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("\"caret\" attribute in user message is missing")
    );

    return FALSE;
  }

  /* Selection is optional and 0 if not given */

  return result;
}

static InfUser*
inf_text_session_user_new(InfSession* session,
                          GParameter* params,
                          guint n_params)
{
  GObject* object;
  object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
  return INF_USER(object);
}

static void
inf_text_session_synchronization_complete(InfSession* session,
                                          InfXmlConnection* connection)
{
  InfSessionClass* parent_class;
  InfSessionStatus status;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  status = inf_session_get_status(session);

  parent_class-&gt;synchronization_complete(session, connection);

  /* init_text_handlers needs to access the algorithm which is created in the
   * parent class default signal handler which is why we call this afterwards.
   * Note that we need to query status before, so we know whether the session
   * itself was synchronized (status == SYNCHRONIZING) or whether we just
   * synchronized the session to someone else (status == RUNNING). */
  if(status == INF_SESSION_SYNCHRONIZING)
    inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
}

/*
 * InfAdoptedSession overrides
 */

static void
inf_text_session_request_to_xml(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedRequest* request,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync)
{
  InfTextChunk* chunk;
  InfTextChunkIter iter;
  gboolean result;
  xmlNodePtr op_xml;

  gchar* utf8_text;
  gsize bytes_read;
  gsize bytes_written;

  GIConv cd;
  xmlNodePtr child;
  const gchar* text;
  gsize total_bytes;
  gsize bytes_left;

  InfAdoptedOperation* operation;

  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    operation = inf_adopted_request_get_operation(request);
    if(INF_TEXT_IS_INSERT_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");

      inf_xml_util_set_attribute_uint(
        op_xml,
        "pos",
        inf_text_insert_operation_get_position(
          INF_TEXT_INSERT_OPERATION(operation)
        )
      );

      /* Must be default insert operation so we get the inserted text */
      g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

      chunk = inf_text_default_insert_operation_get_chunk(
        INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
      );

      result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
      g_assert(result == TRUE);

      utf8_text = g_convert(
        inf_text_chunk_iter_get_text(&amp;iter),
        inf_text_chunk_iter_get_bytes(&amp;iter),
        "UTF-8",
        inf_text_chunk_get_encoding(chunk),
        &amp;bytes_read,
        &amp;bytes_written,
        NULL
      );

      /* Conversion to UTF-8 should always succeed */
      g_assert(utf8_text != NULL);
      g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));

      inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
      g_free(utf8_text);

      /* We only allow a single segment because the whole inserted text must
       * be written by a single user. */
      g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
    }
    else if(INF_TEXT_IS_DELETE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");

      inf_xml_util_set_attribute_uint(
        op_xml,
        "pos",
        inf_text_delete_operation_get_position(
          INF_TEXT_DELETE_OPERATION(operation)
        )
      );

      if(for_sync == TRUE)
      {
        /* Must be default delete operation so we get chunk */
        g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));

        chunk = inf_text_default_delete_operation_get_chunk(
          INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
        );

        /* Need to transmit all deleted data */
        cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
        result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);

        while(result == TRUE)
        {
          text = inf_text_chunk_iter_get_text(&amp;iter);
          total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
          bytes_left = total_bytes;
          child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);

          while(bytes_left &gt; 0)
          {
            inf_text_session_segment_to_xml(
              &amp;cd,
              child,
              text + total_bytes - bytes_left,
              &amp;bytes_left,
              inf_text_chunk_iter_get_author(&amp;iter)
            );
          }

          result = inf_text_chunk_iter_next(&amp;iter);
        }

        g_iconv_close(cd);
      }
      else
      {
        /* Just transmit position and length, the other site generates a
         * InfTextRemoteDeleteOperation from that and is able to restore the
         * deleted text for potential Undo. */
        inf_xml_util_set_attribute_uint(
          op_xml,
          "len",
          inf_text_delete_operation_get_length(
            INF_TEXT_DELETE_OPERATION(operation)
          )
        );
      }
    }
    else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"move");

      inf_xml_util_set_attribute_uint(
        op_xml,
        "caret",
        inf_text_move_operation_get_position(
          INF_TEXT_MOVE_OPERATION(operation)
        )
      );

      inf_xml_util_set_attribute_int(
        op_xml,
        "selection",
        inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
      );
    }
    else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
    }
    else
    {
      g_assert_not_reached();
    }

    break;
  case INF_ADOPTED_REQUEST_UNDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
    break;
  case INF_ADOPTED_REQUEST_REDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
    break;
  default:
    g_assert_not_reached();
    break;
  }

  g_assert(op_xml != NULL);

  inf_adopted_session_write_request_info(
    session,
    request,
    diff_vec,
    xml,
    op_xml
  );
}

static InfAdoptedRequest*
inf_text_session_xml_to_request(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync,
                                GError** error)
{
  InfTextBuffer* buffer;
  InfAdoptedUser* user;
  guint user_id;
  InfAdoptedStateVector* vector;
  xmlNodePtr op_xml;
  InfAdoptedOperation* operation;
  InfAdoptedRequestType type;
  InfAdoptedRequest* request;

  guint pos;
  gchar* text;
  gsize bytes;
  InfTextChunk* chunk;

  gchar* utf8_text;
  gsize in_bytes;
  guint length;

  xmlNodePtr child;
  GIConv cd;
  guint author;
  gboolean cmp;

  gint selection;

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  cmp = inf_adopted_session_read_request_info(
    session,
    xml,
    diff_vec,
    &amp;user,
    &amp;vector,
    &amp;op_xml,
    error
  );

  if(cmp == FALSE) return FALSE;
  user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));

  if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
     strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
      goto fail;

    utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
    if(!utf8_text)
      goto fail;

    text = g_convert(
      utf8_text,
      in_bytes,
      inf_text_buffer_get_encoding(buffer),
      "UTF-8",
      NULL,
      &amp;bytes,
      error
    );

    g_free(utf8_text);
    if(text == NULL) goto fail;

    chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
    inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
    g_free(text);

    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );

    inf_text_chunk_free(chunk);
  }
  else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
      goto fail;

    if(for_sync == TRUE)
    {
      chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
      cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
      g_assert(cd != (GIConv)(-1));

      for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
      {
        if(strcmp((const char*)child-&gt;name, "segment") == 0)
        {
          text = inf_text_session_segment_from_xml(
            &amp;cd,
            child,
            &amp;length,
            &amp;bytes,
            &amp;author,
            error
          );

          if(text == NULL)
          {
            inf_text_chunk_free(chunk);
            g_iconv_close(cd);
            goto fail;
          }
          else
          {
            inf_text_chunk_insert_text(
              chunk,
              inf_text_chunk_get_length(chunk),
              text,
              bytes,
              length,
              author
            );

            g_free(text);
          }
        }
        else
        {
          /* TODO: Error */
        }
      }

      g_iconv_close(cd);

      operation = INF_ADOPTED_OPERATION(
        inf_text_default_delete_operation_new(pos, chunk)
      );

      inf_text_chunk_free(chunk);
    }
    else
    {
      cmp = inf_xml_util_get_attribute_uint_required(
        op_xml,
        "len",
        &amp;length,
        error
      );

      if(cmp == FALSE) goto fail;

      operation = INF_ADOPTED_OPERATION(
        inf_text_remote_delete_operation_new(pos, length)
      );
    }
  }
  else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    cmp = inf_xml_util_get_attribute_uint_required(
      op_xml,
      "caret",
      &amp;pos,
      error
    );

    if(cmp == FALSE) goto fail;

    cmp = inf_xml_util_get_attribute_int_required(
      op_xml,
      "selection",
      &amp;selection,
      error
    );

    if(cmp == FALSE) goto fail;

    operation = INF_ADOPTED_OPERATION(
      inf_text_move_operation_new(pos, selection)
    );
  }
  else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
  }
  else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_UNDO;
  }
  else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_REDO;
  }
  else
  {
    /* TODO: Error */
    goto fail;
  }

  switch(type)
  {
  case INF_ADOPTED_REQUEST_DO:
    g_assert(operation != NULL);
    request = inf_adopted_request_new_do(
      vector,
      user_id,
      operation,
      g_get_real_time()
    );
    g_object_unref(operation);
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    request = inf_adopted_request_new_undo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  case INF_ADOPTED_REQUEST_REDO:
    request = inf_adopted_request_new_redo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }

  inf_adopted_state_vector_free(vector);
  return request;

<a name="0"></a>fail:
  inf_adopted_state_vector_free(vector);
  return NULL;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

/*
 * Gype registration.
 */

static void
inf_text_session_class_init(InfTextSessionClass* text_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;
  InfAdoptedSessionClass* adopted_session_class;

  object_class = G_OBJECT_CLASS(text_session_class);
  session_class = INF_SESSION_CLASS(text_session_class);
  adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);

  object_class-&gt;constructed = inf_text_session_constructed;
  object_class-&gt;dispose = inf_text_session_dispose;
  object_class-&gt;finalize = inf_text_session_finalize;
  object_class-&gt;set_property = inf_text_session_set_property;
  object_class-&gt;get_property = inf_text_session_get_property;

  session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;
  session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
  session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
  session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
  session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
  session_class-&gt;user_new = inf_text_session_user_new;
  session_class-&gt;synchronization_complete =</b></font>
    inf_text_session_synchronization_complete;

  adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
  adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;

  inf_text_session_error_quark = g_quark_from_static_string(
    "INF_TEXT_SESSION_ERROR"
  );

  g_object_class_install_property(
    object_class,
    PROP_CARET_UPDATE_INTERVAL,
    g_param_spec_uint(
      "caret-update-interval",
      "Caret update interval",
      "Minimum number of milliseconds between caret update broadcasts",
      0,
      G_MAXUINT,
      500,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
}

/*
 * Public API.
 */

/**
 * inf_text_session_new: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: An initial #InfTextBuffer.
 * @io: A #InfIo object.
 * @status: The initial status of the session.
 * @sync_group: (allow-none): A group in which the session is synchronized.
 * Ignored if @status is %INF_SESSION_RUNNING.
 * @sync_connection: (allow-none): A connection to synchronize the session
 * from. Ignored if @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfTextSession. The communication manager is used to send
 * and receive requests from subscription and synchronization. @buffer will be
 * set to be initially empty if the session is initially synchronized
 * (see below). @io is required to trigger timeouts.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be sychronized, meaning the initial content is
 * retrieved from @sync_connection. If you are subscribed to the session, set
 * the subscription group via inf_session_set_subscription_group().
 *
 * Returns: (transfer full): A new #InfTextSession.
 **/
InfTextSession*
inf_text_session_new(InfCommunicationManager* manager,
                     InfTextBuffer* buffer,
                     InfIo* io,
                     InfSessionStatus status,
                     InfCommunicationGroup* sync_group,
                     InfXmlConnection* sync_connection)
{
  GObject* object;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    "communication-manager", manager,
    "buffer", buffer,
    "status", status,
    "sync-group", sync_group,
    "sync-connection", sync_connection,
    "io", io,
    NULL
  );

  return INF_TEXT_SESSION(object);
}

/**
 * inf_text_session_new_with_user_table: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: An initial #InfTextBuffer.
 * @io: A #InfIo object.
 * @user_table: A #InfUserTable.
 * @status: The initial status for the session.
 * @sync_group: (allow-none): A group in which the session is synchronized.
 * Ignored if @status is %INF_SESSION_RUNNING.
 * @sync_connection: (allow-none): A connection to synchronize the session
 * from. Ignored if @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfTextSession. The connection manager is used to send and
 * receive requests from subscription and synchronization. @buffer will be
 * set to be initially empty if the session is initially synchronized
 * (see below). @io is required to trigger timeouts.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be sychronized, meaning the initial content is
 * retrieved from @sync_connection. If you are subscribed to the session, set
 * the subscription group via inf_session_set_subscription_group().
 *
 * @user_table is used as an initial user table. The user table should only
 * contain unavailable users, if any, that may rejoin during the session. If
 * there was an available user in the user table, it would probably belong
 * to another session, but different sessions cannot share the same user
 * object.
 *
 * Returns: (transfer full): A new #InfTextSession.
 **/
InfTextSession*
inf_text_session_new_with_user_table(InfCommunicationManager* manager,
                                     InfTextBuffer* buffer,
                                     InfIo* io,
                                     InfUserTable* user_table,
                                     InfSessionStatus status,
                                     InfCommunicationGroup* sync_group,
                                     InfXmlConnection* sync_connection)
{
  /* TODO: Can it happen that the user_table is set explicitely PLUS the
   * session is synchronized? If not then this function can be simplified */

  GObject* object;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    "communication-manager", manager,
    "buffer", buffer,
    "user-table", user_table,
    "status", status,
    "sync-group", sync_group,
    "sync-connection", sync_connection,
    "io", io,
    NULL
  );

  return INF_TEXT_SESSION(object);
}

/**
 * inf_text_session_set_user_color:
 * @session: A #InfTextSession.
 * @user: A local #InfTextUser from @session's user table.
 * @hue: New hue value for @user's color. Ranges from 0.0 (red) to 1.0 (red).
 *
 * Changes the user color of @user. @user must have the %INF_USER_LOCAL flag
 * set.
 */
void
inf_text_session_set_user_color(InfTextSession* session,
                                InfTextUser* user,
                                gdouble hue)
{
  xmlNodePtr xml;

  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));
  g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);

  g_return_if_fail(
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );
  g_return_if_fail(
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );

  xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
  inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
  inf_xml_util_set_attribute_double(xml, "hue", hue);

  inf_session_send_to_subscriptions(INF_SESSION(session), xml);
  g_object_set(G_OBJECT(user), "hue", hue, NULL);
}

/**
 * inf_text_session_flush_requests_for_user:
 * @session: A #InfTextSession.
 * @user: The #InfTextUser for which to flush messages.
 *
 * This function sends all pending requests for @user immediately. Requests
 * that modify the buffer are not queued normally, but cursor movement
 * requests are delayed in case are issued frequently, to save bandwidth.
 *
 * The main purpose of this function is to send all pending requests before
 * changing a user's status to inactive or unavailable since inactive users
 * are automatically activated as soon as they issue a request.
 *
 * TODO: We should probably detect this automatically, without requiring
 * people to call this function, i.e. flush requests for local users just
 * before they become inactive.
 *
 * @user must have the %INF_USER_LOCAL flag set.
 */
void
inf_text_session_flush_requests_for_user(InfTextSession* session,
                                         InfTextUser* user)
{
  InfTextSessionLocalUser* local;

  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));

  local = inf_text_session_find_local_user(session, user);
  g_assert(local != NULL);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_text_session_broadcast_caret_selection(session, local);
  }
}

/**
 * inf_text_session_join_user:
 * @proxy: A #InfSessionProxy with a #InfTextSession session.
 * @name: The name of the user to join.
 * @status: The initial status of the user to join. Must not be
 * @INF_USER_UNAVAILABLE.
 * @hue: The user color of the user to join.
 * @caret_position: The initial position of the new user's cursor.
 * @selection_length: The initial length of the new user's selection.
 * @func: (scope async): Function to call after completion of the request,
 * or %NULL.
 * @user_data: Additional data to pass to @func.
 *
 * This functions creates a user join request for an #InfTextSession. This is
 * a shortcut for inf_session_proxy_join_user().
 *
 * Returns: (transfer full): A #InfRequest, or %NULL.
 */
InfRequest*
inf_text_session_join_user(InfSessionProxy* proxy,
                           const gchar* name,
                           InfUserStatus status,
                           gdouble hue,
                           guint caret_position,
                           int selection_length,
                           InfRequestFunc func,
                           gpointer user_data)
{
#define N_PARAMS 6u
  GParameter params[N_PARAMS] = {
    { "hue", { 0 } },
    { "vector", { 0 } },
    { "caret-position", { 0 } },
    { "selection-length", { 0 } },
    { "name", { 0 } },
    { "status", { 0 } }
  };

  InfSession* session;
  InfRequest* request;
  guint i;

  g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
  
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);

  g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
  g_value_set_double(&amp;params[0].value, hue);

  g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
  g_value_set_boxed(
    &amp;params[1].value,
    inf_adopted_algorithm_get_current(
      inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
    )
  );

  g_value_init(&amp;params[2].value, G_TYPE_UINT);
  g_value_set_uint(&amp;params[2].value, caret_position);

  g_value_init(&amp;params[3].value, G_TYPE_INT);
  g_value_set_int(&amp;params[3].value, selection_length);

  g_value_init(&amp;params[4].value, G_TYPE_STRING);
  g_value_set_string(&amp;params[4].value, name); /* TODO: set_static_string? */

  g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
  g_value_set_enum(&amp;params[5].value, status);

  request = inf_session_proxy_join_user(
    proxy,
    N_PARAMS,
    params,
    func,
    user_data
  );

  for(i = 0; i &lt; N_PARAMS; ++i)
    g_value_unset(&amp;params[i].value);
#undef N_PARAMS

  g_object_unref(session);
  return request;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:inf-text-gtk-buffer
 * @title: InfTextGtkBuffer
 * @short_description: Synchronizing a text session with a #GtkTextBuffer
 * @include: libinftextgtk/inf-text-gtk-buffer.h
 * @see_also: #InfTextBuffer
 * @stability: Unstable
 *
 * #InfTextGtkBuffer is an implementation of the #InfTextBuffer interface. It
 * can therefore be used as a backend for #InfTextSession&lt;!-- --&gt;s to store
 * their text. The buffer is implemented by using a #GtkTextBuffer as
 * storage. This way the text document can be displayed using a #GtkTextView
 * such that only one copy of the text is held in memory, which is used both
 * by the user interface toolkit and the text synchronization functionality.
 *
 * If external changes are made to the #GtkTextBuffer, for example by a user
 * typing into a #GtkTextView, then the text is synchronized to other
 * participants of the session. For this purpose,
 * inf_text_gtk_buffer_set_active_user() should be called with a user that
 * was previously joined into the session using inf_session_proxy_join_user().
 * If there is no local user in the session, no modifications to the buffer
 * must be made because they cannot be synchronized to other participants.
 *
 * This class also takes care of setting background colors for the text to
 * indicate which user wrote what text, by adding corresponding
 * #GtkTextTag&lt;!-- --&gt;s to the document. The function
 * inf_text_gtk_buffer_set_show_user_colors() to turn on or off the colored
 * background. Even if background coloring is turned off, the text is still
 * tagged according to the authorship, so that coloring can be turned on at a
 * later point or so that the authorship can still be queried for other means,
 * such as in a "blame" kind of functionality.
 */

#include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;

#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;string.h&gt; /* for strlen() */

struct _InfTextBufferIter {
  GtkTextIter begin;
  GtkTextIter end;
  InfTextUser* user;
};

typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
struct _InfTextGtkBufferRecord {
  gboolean insert;
  guint char_count;
  guint position;
  InfTextChunk* chunk;
  gboolean applied;
  InfTextGtkBufferRecord* next;
};

typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
struct _InfTextGtkBufferUserTags {
  InfTextGtkBuffer* buffer;
  InfTextUser* user;
  GtkTextTag* colored_tag;
<a name="4"></a>  GtkTextTag* colorless_tag;
};

<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
struct _InfTextGtkBufferTagRemove {
  GtkTextBuffer* buffer;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  InfTextGtkBufferUserTags* ignore_tags;
};

typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
struct _InfTextGtkBufferPrivate {
  GtkTextBuffer* buffer;
  InfUserTable* user_table;
  GHashTable* user_tags;

  InfTextGtkBufferRecord* record;

  gboolean show_user_colors;

  InfTextUser* active_user;
  gboolean wake_on_cursor_movement;

  gdouble saturation;
  gdouble value;
  gdouble alpha;
};

enum {
  PROP_0,

  PROP_BUFFER,
  PROP_USER_TABLE,
  PROP_ACTIVE_USER,
  PROP_WAKE_ON_CURSOR_MOVEMENT,
  PROP_SHOW_USER_COLORS,

  PROP_SATURATION,
  PROP_VALUE,
  PROP_ALPHA,

  /* overriden */
  PROP_MODIFIED
};</b></font>

#define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))

static GQuark inf_text_gtk_buffer_tag_user_quark;

static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkBuffer)
  G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))

static void
inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
                              GtkTextTag* tag,
                              InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;
  gdouble hue;
  gdouble saturation;
  gdouble value;
  GdkRGBA rgba;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
<a name="3"></a>
  hue = inf_text_user_get_hue(user);
  saturation = priv-&gt;saturation;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  value = priv-&gt;value;

  gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
  rgba.alpha = priv-&gt;alpha;

  g_object_set(G_OBJECT(tag), "background-rgba", &amp;rgba, NULL);
}

static void
inf_text_gtk_user_notify_hue_cb(GObject* object,
                                GParamSpec* pspec,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint user_id;
  InfTextGtkBufferUserTags* tags;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  user_id = inf_user_get_id(INF_USER(object));
  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
  g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);</b></font>

  inf_text_gtk_update_tag_color(
    buffer,
    tags-&gt;colored_tag,
    INF_TEXT_USER(object)
  );
}

static void
inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
{
  InfTextGtkBufferUserTags* tags;
  tags = (InfTextGtkBufferUserTags*)user_tags;

  if(tags-&gt;colored_tag)
  {
    inf_signal_handlers_disconnect_by_func(
      tags-&gt;user,
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      tags-&gt;buffer
    );

    g_object_unref(tags-&gt;colored_tag);
  }

  if(tags-&gt;colorless_tag)
    g_object_unref(tags-&gt;colorless_tag);
  g_slice_free(InfTextGtkBufferUserTags, tags);
}

static InfTextGtkBufferUserTags*
inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
                                  guint user_id)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferUserTags* tags;
  InfUser* user;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(user_id == 0)
    return NULL;

  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));

  if(tags != NULL)
  {
    return tags;
  }
  else
  {
    user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
    g_assert(INF_TEXT_IS_USER(user));

    tags = g_slice_new(InfTextGtkBufferUserTags);
    tags-&gt;buffer = buffer;
    tags-&gt;user = INF_TEXT_USER(user);
    tags-&gt;colored_tag = NULL;
    tags-&gt;colorless_tag = NULL;
    g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
    return tags;
  }
}

static GtkTextTag*
inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferUserTags* user_tags,
                                 gboolean colored)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* table;
  GtkTextTag** tag;
  gchar* tag_name;
  guint user_id;
  const gchar* colorstr;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
  if(*tag != NULL) return *tag;

  user_id = 0;
  if(user_tags-&gt;user != NULL)
    user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
  colorstr = colored ? "colored" : "colorless";

  tag_name = g_strdup_printf("inftextgtk-user-%s-%u", colorstr, user_id);
  *tag = gtk_text_tag_new(tag_name);
  g_free(tag_name);

  table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_add(table, *tag);

  /* Set lowest priority for author tags, so GtkSourceView's bracket
   * matching highlight tags and highlight of FIXME and such in comments is
   * shown instead of the user color. */
  gtk_text_tag_set_priority(*tag, 0);

  g_object_set_qdata(
    G_OBJECT(*tag),
    inf_text_gtk_buffer_tag_user_quark,
    user_tags-&gt;user
  );

  if(colored)
  {
    g_signal_connect(
      G_OBJECT(user_tags-&gt;user),
      "notify::hue",
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      buffer
    );

    inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
  }

  return *tag;
}

static InfTextUser*
inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
{
  gpointer author_ptr;

  author_ptr = g_object_get_qdata(
    G_OBJECT(tag),
    inf_text_gtk_buffer_tag_user_quark
  );

  return INF_TEXT_USER(author_ptr);
}

static InfTextUser*
inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
{
  GSList* item;
  InfTextUser* author;

  for(item = tag_list; item != NULL; item = g_slist_next(item))
  {
    author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
    if(author != NULL) return author;
  }

  return NULL;
}

static InfTextUser*
inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
{
  GSList* tag_list;
  InfTextUser* author;

  tag_list = gtk_text_iter_get_tags(location);
  author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);

  return author;
}

static gboolean
inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
                                          InfTextUser** toggled_on,
                                          InfTextUser** toggled_off)
{
  GSList* tag_list;
  InfTextUser* author_on;
  InfTextUser* author_off;

  tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
  author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);

  /* We need to check both the tags that are toggled on and the tags that
   * are toggled off at this point, because text that is not written by
   * anyone specific (author NULL) does not count as author tag. */
  if(author_on == NULL || toggled_off != NULL)
  {
    tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
    author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
    g_slist_free(tag_list);
  }

  if(author_on == NULL &amp;&amp; author_off == NULL)
    if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
      return FALSE;

  if(toggled_on) *toggled_on = author_on;
  if(toggled_off) *toggled_off = author_off;
  return TRUE;
}

static void
inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;

  do
  {
    gtk_text_iter_forward_to_tag_toggle(iter, NULL);

    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}

static void
inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;

  do
  {
    gtk_text_iter_backward_to_tag_toggle(iter, NULL);

    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}

static void
inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextUser* author;
  author = inf_text_gtk_buffer_author_from_tag(tag);

  if(author != NULL)
    gtk_text_tag_set_priority(tag, 0);
}

static void
inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextUser* author;

  buffer = INF_TEXT_GTK_BUFFER(data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  author = inf_text_gtk_buffer_author_from_tag(tag);

  if(author != NULL)
    inf_text_gtk_update_tag_color(buffer, tag, author);
}

/* Required by inf_text_gtk_buffer_record_signal() and
 * inf_text_gtk_buffer_mark_set_cb() */
static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint length,
                                                     gboolean by_request,
                                                     gpointer user_data);

/* Required by inf_text_gtk_buffer_record_signal() and
 * inf_text_gtk_buffer_mark_set_cb() */
static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data);

static void
inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
                                 GtkTextTag* tag,
                                 GtkTextIter* start,
                                 GtkTextIter* end,
                                 gpointer user_data)
{
  /* Don't allow author tags to be applied by default. GTK+ seems to do this
   * when copy+pasting text from the text buffer itself, but we want to make
   * sure that a given segment of text has always a unique author set. */
  if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
    g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), "apply-tag");
}

static void
inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
                                                              gpointer data)
{
  InfTextGtkBufferTagRemove* tag_remove;
  tag_remove = (InfTextGtkBufferTagRemove*)data;

  if(tag_remove-&gt;ignore_tags == NULL ||
     (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
      tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
  {
    gtk_text_buffer_remove_tag(
      tag_remove-&gt;buffer,
      tag,
      &amp;tag_remove-&gt;begin_iter,
      &amp;tag_remove-&gt;end_iter
    );
  }
}

/* Record tracking:
 * This is to allow and correctly handle nested emissions of GtkTextBuffer's
 * insert-text/delete-range signals. The text-inserted and text-erased
 * signals of InfTextBuffer need to be emitted right after the operation was
 * applied to the buffer which is why we need some bookkeeping here. */

#ifndef G_DISABLE_ASSERT
/* Check whether the top record has been applied correctly to the buffer */
static gboolean
inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;
  guint text_len;
  guint buf_len;
  gpointer buf_text;
  gpointer chunk_text;
  gsize buf_bytes;
  gsize chunk_bytes;
  int result;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  text_len = inf_text_chunk_get_length(record-&gt;chunk);
  buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);

  /* We can only check insertions */
  if(record-&gt;insert)
  {
    if(record-&gt;char_count + text_len != buf_len)
      return FALSE;
    if(record-&gt;position + text_len &gt; buf_len)
      return FALSE;

    chunk = inf_text_buffer_get_slice(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      text_len
    );

    buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
    chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
    inf_text_chunk_free(chunk);

    if(buf_bytes == chunk_bytes)
      result = memcmp(buf_text, chunk_text, buf_bytes);
    else
      result = -1;

    g_free(buf_text);
    g_free(chunk_text);
    
    if(result != 0) return FALSE;
  }
  else
  {
    if(text_len &gt; record-&gt;char_count)
      return FALSE;
    if(record-&gt;char_count - text_len != buf_len)
      return FALSE;
  }

  return TRUE;
}
#endif

static void
inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
                                     InfTextGtkBufferRecord* against)
{
  guint record_len;
  guint against_len;

  /* What we do here is common sense; in fact this depends on how
   * insert-text/delete-range signal handlers do revalidation of iters if
   * they insert/erase text themselves. We rely on them doing it exactly
   * this way currently, otherwise we cannot identify new/erased text to
   * emit text-inserted/text-erased for, resulting in new/erased text not
   * being transmitted to remote users, in turn resulting in lost session
   * consistency. This is why the inf_text_gtk_buffer_record_check()
   * check will fail if this happens. */
  g_assert(record-&gt;applied == FALSE);
  g_assert(against-&gt;applied == TRUE);

  record_len = inf_text_chunk_get_length(record-&gt;chunk);
  against_len = inf_text_chunk_get_length(against-&gt;chunk);

  if(record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position += against_len;
  }
  else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position + against_len)
      record-&gt;position -= against_len;
    else if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position = against-&gt;position;
  }
  else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
    {
      record-&gt;position += against-&gt;position;
    }
    else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
            record-&gt;position + record_len &gt; against-&gt;position)
    {
      /* Add text right into deletion range... */
      inf_text_chunk_insert_chunk(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        against-&gt;chunk
      );
    }
  }
  else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position -= against_len;
    }
    else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        against-&gt;position + against_len - record-&gt;position
      );
    }
    else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        inf_text_chunk_get_length(record-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        inf_text_chunk_get_length(against-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        record-&gt;position + record_len - against-&gt;position
      );
    }
  }

  /* Revalidate char count */
  if(against-&gt;insert)
  {
    record-&gt;char_count += against_len;
  }
  else
  {
    g_assert(record-&gt;char_count &gt;= against_len);
    record-&gt;char_count -= against_len;
  }
}

static void
inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
                                  InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;active_user != NULL);
  g_assert(record-&gt;applied == FALSE);

  g_assert(inf_text_gtk_buffer_record_check(buffer, record));

  record-&gt;applied = TRUE;
  for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
    if(!rec-&gt;applied)
      inf_text_gtk_buffer_record_transform(rec-&gt;next, record);

  if(record-&gt;insert)
  {
    /* Allow author tag changes within this function: */
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    /* Tag the inserted text with the user's color */
    tag_remove.buffer = priv-&gt;buffer;

    tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
      buffer,
      inf_user_get_id(INF_USER(priv-&gt;active_user))
    );
    g_assert(tag_remove.ignore_tags != NULL);

    tag = inf_text_gtk_buffer_get_user_tag(
      buffer,
      tag_remove.ignore_tags,
      priv-&gt;show_user_colors
    );

    /* Remove other user tags, if any */
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.begin_iter,
      record-&gt;position
    );

    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
    );

    gtk_text_tag_table_foreach(
      gtk_text_buffer_get_tag_table(tag_remove.buffer),
      inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
      &amp;tag_remove
    );

    /* Apply tag for this particular user */
    gtk_text_buffer_apply_tag(
      priv-&gt;buffer,
      tag,
      &amp;tag_remove.begin_iter,
      &amp;tag_remove.end_iter
    );

    /* Allow author tag changes within this function: */
    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
  }

  /* Block the notify_status signal handler of the active user. That signal
   * handler syncs the cursor position of the user to the insertion mark of
   * the TextBuffer when the user becomes active again. However, when we
   * insert or erase text, then this will be updated anyway. */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );

  /* Block selection-changed of active user. This would try to resync the 
   * buffer markers, but GtkTextBuffer already did this for us. */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );

  if(record-&gt;insert)
  {
    inf_text_buffer_text_inserted(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }
  else
  {
    inf_text_buffer_text_erased(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );
}

static void
inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
                                gboolean insert,
                                guint position,
                                InfTextChunk* chunk)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  rec = priv-&gt;record;

  priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
  priv-&gt;record-&gt;insert = insert;
  priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
  priv-&gt;record-&gt;position = position;
  priv-&gt;record-&gt;chunk = chunk;
  priv-&gt;record-&gt;applied = FALSE;
  priv-&gt;record-&gt;next = rec;

  /* It is enough to check whether the top record was applied to the buffer,
   * since, for previous records we would have been notified in a previous
   * callback already. */
  if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
  {
    /* If char count differs then the previous record has already been applied
     * (that is the default handler ran but not our after handler, so
     * probably another after handler inserted new text). */
    /* TODO: This does not work if length of record is zero */
    if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
    {
      /* This record has been applied already, so signal. */
      inf_text_gtk_buffer_record_signal(buffer, rec);

#ifndef G_ASSERT_DISABLED
      /* Outer records would already have been signalled by previous signal
       * handler invocations if they were applied. */
      for(; rec != NULL; rec = rec-&gt;next)
      {
        g_assert(
          rec-&gt;applied == TRUE ||
          rec-&gt;char_count ==
            (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
        );
      }
#endif
    }
  }
}

static void
inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  guint char_count;
  guint length;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;record != NULL);
  if(!priv-&gt;record-&gt;applied)
  {
    length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
    char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);

    if(priv-&gt;record-&gt;insert)
    {
      g_assert(priv-&gt;record-&gt;char_count + length == char_count);
    }
    else
    {
      g_assert(priv-&gt;record-&gt;char_count &gt;= length);
      g_assert(priv-&gt;record-&gt;char_count - length == char_count);
    }

    /* Signal application */
    inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
  }

  rec = priv-&gt;record;
  priv-&gt;record = rec-&gt;next;

  inf_text_chunk_free(rec-&gt;chunk);
  g_slice_free(InfTextGtkBufferRecord, rec);
}

static void
inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* location,
                                          gchar* text,
                                          gint len,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;active_user != NULL);
  chunk = inf_text_chunk_new("UTF-8");

  inf_text_chunk_insert_text(
    chunk,
    0,
    text,
    len,
    g_utf8_strlen(text, len),
    inf_user_get_id(INF_USER(priv-&gt;active_user))
  );

  inf_text_gtk_buffer_push_record(
    buffer,
    TRUE,
    gtk_text_iter_get_offset(location),
    chunk
  );
}

static void
inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
                                         GtkTextIter* location,
                                         gchar* text,
                                         gint len,
                                         gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  gpointer rec_text;
  gsize bytes;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == TRUE);

#ifndef G_ASSERT_DISABLED
  if(priv-&gt;record-&gt;applied == FALSE)
  {
    g_assert(
      priv-&gt;record-&gt;position +
        inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
      (guint)gtk_text_iter_get_offset(location)
    );

    rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
    g_assert(bytes == (gsize)len);
    g_assert(memcmp(text, rec_text, bytes) == 0);
    g_free(rec_text);
  }
#endif

  inf_text_gtk_buffer_pop_record(buffer);
}

static void
inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
                                           GtkTextIter* begin,
                                           GtkTextIter* end,
                                           gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint begin_offset;
  guint end_offset;
  InfTextChunk* chunk;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  begin_offset = gtk_text_iter_get_offset(begin);
  end_offset = gtk_text_iter_get_offset(end);

  chunk = inf_text_buffer_get_slice(
    INF_TEXT_BUFFER(buffer),
    begin_offset,
    end_offset - begin_offset
  );

  inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
}

static void
inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* begin,
                                          GtkTextIter* end,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  
  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == FALSE);
  
  g_assert(priv-&gt;record-&gt;applied == TRUE ||
           priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));

  inf_text_gtk_buffer_pop_record(buffer);
}

static void
inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
                                GtkTextIter* location,
                                GtkTextMark* mark,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;

  guint offset;
  int sel;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
  sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);

  if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
  {
    /* Don't send status updates for inactive users as these would make it
     * active. Instead, we send one update when the user becomes active
     * again. */
    if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
       priv-&gt;wake_on_cursor_movement == TRUE)
    {
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);

      offset = gtk_text_iter_get_offset(&amp;insert_iter);
      sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;

      if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
         inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
      {
        /* Block the notify_status signal handler of the active user. That
         * signal handler syncs the cursor position of the user to the
         * insertion mark of the TextBuffer when the user becomes active
         * again. However, when we move the cursor, then this will be updated
         * anyway. */
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );

        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );

        inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );
      }
    }
  }
}

static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;
  guint offset;
  int sel;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);

  switch(inf_user_get_status(INF_USER(object)))
  {
  case INF_USER_ACTIVE:
    /* User became active: Sync user selection and the insertion mark of the
     * TextBuffer. They can get out of sync while the user is inactive, and
     * wake-on-cursor-movement is FALSE. For example text can be selected in
     * an inactive document, and then the user decides to select something
     * else, erasing the previous selection. */

    insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
    sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);

    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);

    offset = gtk_text_iter_get_offset(&amp;insert_iter);
    sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;

    if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
       inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
    {
      inf_signal_handlers_block_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
      );

      inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);

      inf_signal_handlers_unblock_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
      );
    }

    break;
  case INF_USER_UNAVAILABLE:
    /* TODO: Do we want to unset the active-user automatically here? */
    break;
  default:
    /* Not of interest. */
    break;
  }
}

static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint selection_length,
                                                     gboolean by_request,
                                                     gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextIter insert;
  GtkTextIter selection_bound;

  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );

  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);

  gtk_text_buffer_get_iter_at_offset(
    priv-&gt;buffer,
    &amp;selection_bound,
    position + selection_length
  );

  gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );
}

static void
inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
                                        gpointer user_data)
{
  g_object_notify(G_OBJECT(user_data), "modified");
}

static void
inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
                                 gboolean modified)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

    gtk_text_buffer_set_modified(priv-&gt;buffer, modified);

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

    g_object_notify(G_OBJECT(buffer), "modified");
  }
}

static void
inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
<a name="5"></a>                               GtkTextBuffer* gtk_buffer)
{
  InfTextGtkBufferPrivate* priv;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );

    g_object_unref(G_OBJECT(priv-&gt;buffer));
  }

  priv-&gt;buffer = gtk_buffer;

  if(gtk_buffer != NULL)
  {
    g_object_ref(G_OBJECT(gtk_buffer));

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "apply-tag",
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "insert-text",
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "insert-text",
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );

    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "delete-range",
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "delete-range",
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "mark-set",
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );

    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "modified-changed",
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
  }

  g_object_notify(G_OBJECT(buffer), "buffer");

  /* TODO: Notify modified, if it changed */
}

static void</b></font>
inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  priv-&gt;buffer = NULL;
  priv-&gt;user_table = NULL;

  priv-&gt;user_tags = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    inf_text_gtk_buffer_user_tags_free
  );

  priv-&gt;show_user_colors = TRUE;

  priv-&gt;active_user = NULL;
  priv-&gt;wake_on_cursor_movement = FALSE;

  priv-&gt;saturation = 0.35;
  priv-&gt;value = 1.0;
  priv-&gt;alpha = 1.0;
}

static void
inf_text_gtk_buffer_dispose(GObject* object)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_hash_table_remove_all(priv-&gt;user_tags);

  inf_text_gtk_buffer_set_buffer(buffer, NULL);
  inf_text_gtk_buffer_set_active_user(buffer, NULL);
<a name="1"></a>  g_object_unref(priv-&gt;user_table);

  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_text_gtk_buffer_finalize(GObject* object)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_hash_table_unref(priv-&gt;user_tags);

  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
}

static void
inf_text_gtk_buffer_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  switch(prop_id)
  {
  case PROP_BUFFER:</b></font>
    g_assert(priv-&gt;buffer == NULL); /* construct only */
    inf_text_gtk_buffer_set_buffer(
      buffer,
      GTK_TEXT_BUFFER(g_value_get_object(value))
    );

    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); /* construct/only */
    priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_buffer_set_active_user(
      buffer,
      INF_TEXT_USER(g_value_get_object(value))
    );

    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
    break;
  case PROP_SHOW_USER_COLORS:
    priv-&gt;show_user_colors = g_value_get_boolean(value);
    break;
  case PROP_MODIFIED:
    inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
    break;
  case PROP_SATURATION:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      g_value_get_double(value),
      priv-&gt;value
    );
    break;
  case PROP_VALUE:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      priv-&gt;saturation,
      g_value_get_double(value)
    );
<a name="2"></a>    break;
  case PROP_ALPHA:
    inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_buffer_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;

  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  switch(prop_id)
  {
  case PROP_BUFFER:
    g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
    break;</b></font>
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
    break;
  case PROP_SHOW_USER_COLORS:
    g_value_set_boolean(value, priv-&gt;show_user_colors);
    break;
  case PROP_MODIFIED:
    if(priv-&gt;buffer != NULL)
      g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
    else
      g_value_set_boolean(value, FALSE);

    break;
  case PROP_SATURATION:
    g_value_set_double(value, priv-&gt;saturation);
    break;
  case PROP_VALUE:
    g_value_set_double(value, priv-&gt;value);
    break;
  case PROP_ALPHA:
    g_value_set_double(value, priv-&gt;alpha);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
{
  InfTextGtkBuffer* gtk_buffer;
  InfTextGtkBufferPrivate* priv;

  gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);

  if(priv-&gt;buffer != NULL)
    return gtk_text_buffer_get_modified(priv-&gt;buffer);
  else
    return FALSE;
}

static void
inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
                                        gboolean modified)
{
  inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
}

static const gchar*
inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
{
  return "UTF-8";
}

static guint
inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return gtk_text_buffer_get_char_count(priv-&gt;buffer);
}

static InfTextChunk*
inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
                                     guint pos,
                                     guint len)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter begin;
  GtkTextIter iter;
  InfTextChunk* result;
  guint remaining;

  guint size;
  InfTextUser* author;
  gchar* text;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
  result = inf_text_chunk_new("UTF-8");
  remaining = len;

  while(remaining &gt; 0)
  {
    /* This indicates invalid length */
    g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);

    begin = iter;
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);

    size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);

    /* Not the whole segment if region to slice ends before segment end */
    if(size &gt; remaining)
    {
      size = remaining;
      iter = begin;
      gtk_text_iter_forward_chars(&amp;iter, size);
    }

    text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);

    /* TODO: Faster inf_text_chunk_append that optionally eats text */
    inf_text_chunk_insert_text(
      result,
      len - remaining,
      text,
      strlen(text), /* I hate strlen. GTK+ should tell us how many bytes. */
      size,
      (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
    );

    remaining -= size;
    g_free(text);
  }

  return result;
}

static void
inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunkIter chunk_iter;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;

  GtkTextMark* mark;
  GtkTextIter insert_iter;
  gboolean insert_at_cursor;
  gboolean insert_at_selection_bound;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_remove.buffer = priv-&gt;buffer;

  /* This would have to be handled separately, but I think this is unlikely
   * to happen anyway. If it does happen then we would again need to rely on
   * iterator revalidation to happen in the way we expect it. */
  g_assert(priv-&gt;record == NULL);

  /* Allow author tag changes within this function: */
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );

  if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
  {
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      pos
    );

    do
    {
      tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
        INF_TEXT_GTK_BUFFER(buffer),
        inf_text_chunk_iter_get_author(&amp;chunk_iter)
      );

      if(tag_remove.ignore_tags)
      {
        tag = inf_text_gtk_buffer_get_user_tag(
          INF_TEXT_GTK_BUFFER(buffer),
          tag_remove.ignore_tags,
          priv-&gt;show_user_colors
        );
      }
      else
      {
        tag = NULL;
      }

      gtk_text_buffer_insert_with_tags(
        tag_remove.buffer,
        &amp;tag_remove.end_iter,
        inf_text_chunk_iter_get_text(&amp;chunk_iter),
        inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
        tag,
        NULL
      );

      /* Remove other user tags. If we inserted the new text within another
       * user's text, GtkTextBuffer automatically applies that tag to the
       * new text. */

      /* TODO: We could probably look for the tag that we have to remove
       * before inserting text, to optimize this a bit. */
      tag_remove.begin_iter = tag_remove.end_iter;
      gtk_text_iter_backward_chars(
        &amp;tag_remove.begin_iter,
        inf_text_chunk_iter_get_length(&amp;chunk_iter)
      );

      gtk_text_tag_table_foreach(
        gtk_text_buffer_get_tag_table(tag_remove.buffer),
        inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
        &amp;tag_remove
      );
    } while(inf_text_chunk_iter_next(&amp;chunk_iter));

    /* Fix left gravity of own cursor on remote insert */

    /* TODO: We could also do this by simply resyncing the text buffer marks
     * to the active user's caret and selection properties. But then we
     * wouldn't have left gravtiy if no active user was present. */
    if(user != INF_USER(priv-&gt;active_user) || user == NULL)
    {
      mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);

      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_cursor = TRUE;
      else
        insert_at_cursor = FALSE;

      mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);

      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_selection_bound = TRUE;
      else
        insert_at_selection_bound = FALSE;

      if(insert_at_cursor || insert_at_selection_bound)
      {
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );

        gtk_text_iter_backward_chars(
          &amp;tag_remove.end_iter,
          inf_text_chunk_get_length(chunk)
        );

        if(insert_at_cursor)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_insert(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }

        if(insert_at_selection_bound)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }

        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );
      }
    }
  }

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );

  inf_text_buffer_text_inserted(buffer, pos, chunk, user);
}

static void
inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
                                      guint pos,
                                      guint len,
                                      InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;

  GtkTextIter begin;
  GtkTextIter end;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  /* This would have to be handled separately, but I think this is unlikely
   * to happen anyway. If it does happen then we would again need to rely on
   * iterator revalidation to happen in the way we expect it. */
  g_assert(priv-&gt;record == NULL);

  chunk = inf_text_buffer_get_slice(buffer, pos, len);

  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );

  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );

  gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );

  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );

  inf_text_buffer_text_erased(buffer, pos, chunk, user);
  inf_text_chunk_free(chunk);
}

static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);

    iter-&gt;end = iter-&gt;begin;
    inf_text_gtk_buffer_iter_next_author_toggle(
      &amp;iter-&gt;end,
      NULL,
      &amp;iter-&gt;user
    );

    return iter;
  }
}

static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);

    iter-&gt;begin = iter-&gt;end;
    inf_text_gtk_buffer_iter_prev_author_toggle(
      &amp;iter-&gt;begin,
      &amp;iter-&gt;user,
      NULL
    );

    return iter;
  }
}

static void
inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
                                        InfTextBufferIter* iter)
{
  g_slice_free(InfTextBufferIter, iter);
}

static gboolean
inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_end(&amp;iter-&gt;end))
    return FALSE;

  iter-&gt;begin = iter-&gt;end;
  inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
  return TRUE;
}

static gboolean
inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
    return FALSE;

  iter-&gt;end = iter-&gt;begin;
  inf_text_gtk_buffer_iter_prev_author_toggle(
    &amp;iter-&gt;begin,
    &amp;iter-&gt;user,
    NULL
  );

  return TRUE;
}

static gpointer
inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
                                         InfTextBufferIter* iter)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  return gtk_text_buffer_get_slice(
    priv-&gt;buffer,
    &amp;iter-&gt;begin,
    &amp;iter-&gt;end,
    TRUE
  );
}

static guint
inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}

static guint
inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}

static gsize
inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
                                          InfTextBufferIter* iter)
{
  GtkTextIter walk;
  gsize bytes;
  guint remaining;
  guint end;

  guint line_chars;
  guint line_bytes;
  gboolean result;

  walk = iter-&gt;begin;
  bytes = 0;
  remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;walk);
  end = gtk_text_iter_get_offset(&amp;iter-&gt;end);

  while(remaining &gt; 0)
  {
    line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
      gtk_text_iter_get_line_offset(&amp;walk);

    if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
    {
      /* Need whole line */
      line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
        gtk_text_iter_get_line_index(&amp;walk);

      remaining -= line_chars;
      bytes += line_bytes;

      result = gtk_text_iter_forward_line(&amp;walk);
      /* We cannot be in last line, because the end iterator would have to
       * be past the last line then. */
      g_assert(remaining == 0 || result == TRUE);
    }
    else
    {
      /* End iterator is in this line */
      line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
        gtk_text_iter_get_line_index(&amp;walk);

      remaining = 0;
      bytes += line_bytes;
    }
  }

  return bytes;
}

static guint
inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
}

static void
inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(text_gtk_buffer_class);

  object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
  object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
  object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
  object_class-&gt;get_property = inf_text_gtk_buffer_get_property;

  inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
    "inf-text-gtk-buffer-tag-user"
  );

  g_object_class_install_property(
    object_class,
    PROP_BUFFER,
    g_param_spec_object(
      "buffer",
      "Buffer",
      "The underlaying GtkTextBuffer",
      GTK_TYPE_TEXT_BUFFER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "A user table of the participating users",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      "active-user",
      "Active user",
      "The user currently inserting text locally",
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_WAKE_ON_CURSOR_MOVEMENT,
    g_param_spec_boolean(
      "wake-on-cursor-movement",
      "Wake on cursor movement",
      "Whether to make inactive users active when the insertion mark in the "
      "TextBuffer moves",
      FALSE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_USER_COLORS,
    g_param_spec_boolean(
      "show-user-colors",
      "Show user colors",
      "Whether to show user colors initially for newly written text",
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SATURATION,
    g_param_spec_double(
      "saturation",
      "Saturation",
      "Saturation of user colors in a HSV color model",
      0.0,
      1.0,
      0.35,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      "value",
      "Value",
      "Value of user colors in a HSV color model",
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      "alpha",
      "Alpha",
      "The translucency of the user color",
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
}

static void
inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
<a name="0"></a>{
  iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
  iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
{
  iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
  iface-&gt;get_length = inf_text_gtk_buffer_get_length;
  iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
  iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
  iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
  iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
  iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
  iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
  iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
  iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
  iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
  iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
  iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
  iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
  iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
  iface-&gt;text_inserted = NULL;</b></font>
  iface-&gt;text_erased = NULL;
}

/**
 * inf_text_gtk_buffer_new: (constructor)
 * @buffer: The underlaying #GtkTextBuffer.
 * @user_table: The #InfUserTable containing the participating users.
 *
 * Creates a new #InfTextGtkBuffer wrapping @buffer. It implements the
 * #InfTextBuffer interface by using @buffer to store the text. User colors
 * are read from the users from @user_table.
 *
 * Returns: (transfer full): A #InfTextGtkBuffer.
 **/
InfTextGtkBuffer*
inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
                        InfUserTable* user_table)
{
  GObject* object;

  g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  object = g_object_new(
    INF_TEXT_GTK_TYPE_BUFFER,
    "buffer", buffer,
    "user-table", user_table,
    NULL
  );

  return INF_TEXT_GTK_BUFFER(object);
}

/**
 * inf_text_gtk_buffer_get_text_buffer:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the underlaying #GtkTextBuffer.
 *
 * Returns: (transfer none): A #GtkTextBuffer.
 **/
GtkTextBuffer*
inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
}

/**
 * inf_text_gtk_buffer_set_active_user:
 * @buffer: A #InfTextGtkBuffer.
 * @user: (allow-none): A #InfTextUser, or %NULL.
 *
 * Sets the active user for @buffer. The active user is the user by which
 * edits not issued through the #InfTextBuffer interface are performed (for
 * example, edits by the user when the underlaying buffer is displayed in
 * a #GtkTextView).
 *
 * Note that such modifications should not be performed when no active user is
 * set. Note also the active user must be available and have the
 * %INF_USER_LOCAL flag set.
 **/
void
inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
                                    InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
  
  g_return_if_fail(
    user == NULL ||
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );

  g_return_if_fail(
    user == NULL ||
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(priv-&gt;active_user != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );

    g_object_unref(G_OBJECT(priv-&gt;active_user));
  }

  priv-&gt;active_user = user;

  if(user != NULL)
  {
    /* TODO: Set cursor and selection of new user */

    g_object_ref(G_OBJECT(user));

    g_signal_connect(
      G_OBJECT(user),
      "notify::status",
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );

    g_signal_connect(
      G_OBJECT(user),
      "selection-changed",
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );
  }

  g_object_notify(G_OBJECT(buffer), "active-user");
}

/**
 * inf_text_gtk_buffer_get_active_user:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the current active user for @buffer.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser.
 **/
InfTextUser*
inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
}

/**
 * inf_text_gtk_buffer_get_author:
 * @buffer: A #InfTextGtkBuffer.
 * @location: A #GtkTextIter which is not the end iterator.
 *
 * Returns the #InfTextUser which wrote the character at @location. If there
 * is no such user, then %NULL is returned.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser, or %NULL.
 */
InfTextUser*
inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
                               GtkTextIter* location)
{
  InfTextGtkBufferPrivate* priv;

  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);

  g_return_val_if_fail(
    location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
    NULL
  );

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return inf_text_gtk_buffer_iter_get_author(location);
}

/**
 * inf_text_gtk_buffer_get_user_for_tag:
 * @buffer: A #InfTextGtkBuffer.
 * @tag: A #GtkTextTag from @buffer's underlying #GtkTextBuffer's tag table.
 *
 * If @tag is an author tag, i.e. used by @buffer to mark text that a certain
 * user has written, then this function returns the #InfTextUser whose text is
 * marked by @tag. If @tag is not an author tag then the function returns
 * %NULL.
 *
 * Returns: (transfer none) (allow-none): A #InfTextUser, or %NULL.
 */
InfTextUser*
inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
                                     GtkTextTag* tag)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);

  return inf_text_gtk_buffer_author_from_tag(tag);
}

/**
 * inf_text_gtk_buffer_is_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * This function returns %TRUE if the author of the text in @buffer changes
 * at @iter, or %FALSE otherwise. If it returns %TRUE, then the user who
 * authored the text to the right hand side of @iter is stored in @user_on (if
 * non-%NULL) and the author of the text to the left hand side of @iter is
 * stored in @user_off (if non-%NULL). Both can also be set to %NULL if there
 * is unowned text in the buffer or if @iter is at the start or end of the
 * buffer.
 *
 * Returns: Whether text attribution changes at @iter.
 */
gboolean
inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
                                     const GtkTextIter* iter,
                                     InfTextUser** user_on,
                                     InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  return inf_text_gtk_buffer_iter_is_author_toggle(
    iter,
    user_on,
    user_off
  );
}

/**
 * inf_text_gtk_buffer_forward_to_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * Moves @iter to the next point in @buffer's underlying #GtkTextBuffer where
 * the text has been written by another user. If @iter points to the end of
 * the buffer, then the function does nothing and returns %FALSE. Otherwise
 * it returns %TRUE and sets @user_on to the user which has written the text
 * on the right hand side of the location @iter has been moved to (if
 * non-%NULL) and @user_off to the user which has written the left hand side
 * of the location @iter has been moved to.
 *
 * Returns: %TRUE if @iter was moved, or %FALSE otherwise.
 */
gboolean
inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
                                             GtkTextIter* iter,
                                             InfTextUser** user_on,
                                             InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  if(gtk_text_iter_is_end(iter))
    return FALSE;

  inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
  return TRUE;
}

/**
 * inf_text_gtk_buffer_backward_to_author_toggle:
 * @buffer: A #InfTextGtkBuffer.
 * @iter: A #GtkTextIter pointing into @buffer's underlying #GtkTextBuffer.
 * @user_on: (out) (allow-none): A location to store a #InfTextUser, or %NULL.
 * @user_off: (out) (allow-none): Another location to store a #InfTextUser,
 * or %NULL.
 *
 * Moves @iter to the previous point in @buffer's underlying #GtkTextBuffer
 * where the text has been written by another user. If @iter points to the
 * beginning of the buffer, then the function does nothing and returns %FALSE.
 * Otherwise it returns %TRUE and sets @user_on to the user which has written
 * the text on the right hand side of the location @iter has been moved to (if
 * non-%NULL) and @user_off to the user which has written the left hand side
 * of the location @iter has been moved to.
 *
 * Returns: %TRUE if @iter was moved, or %FALSE otherwise.
 */
gboolean
inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
                                              GtkTextIter* iter,
                                              InfTextUser** user_on,
                                              InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);

  if(gtk_text_iter_is_start(iter))
    return FALSE;

  inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
  return TRUE;
}

/**
 * inf_text_gtk_buffer_set_wake_on_cursor_movement:
 * @buffer: A #InfTextGtkBuffer.
 * @wake: Whether to make inactive users active on cursor movement.
 *
 * This function spcecifies whether movement of the insertion point or
 * selection bound of the underlying text buffer causes the active user
 * (see inf_text_gtk_buffer_set_active_user()) to become active when its
 * status is %INF_USER_INACTIVE.
 *
 * If @wake is %TRUE, then the user status changes to %INF_USER_ACTIVE
 * in that case. If @wake is %FALSE, then the user status stays
 * %INF_USER_INACTIVE, and its caret-position and selection-length
 * properties will be no longer be synchronized to the buffer marks until
 * the user is set active again.
 */

void
inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
                                                gboolean wake)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
  g_object_notify(G_OBJECT(buffer), "wake-on-cursor-movement");
}

/**
 * inf_text_gtk_buffer_get_wake_on_cursor_movement:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns whether movement of the insertion point or selection bound of the
 * underlying text buffer causes whether the active user (see
 * inf_text_gtk_buffer_set_active_user()) to become active when its status
 * is %INF_USER_INACTIVE. See also
 * inf_text_gtk_buffer_set_wake_on_cursor_movement().
 *
 * Returns: Whether to make inactive users active when the insertion mark
 * is moved.
 */
gboolean
inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
}

/**
 * inf_text_gtk_buffer_ensure_author_tags_priority:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Ensures that all author tags have the lowest priority of all tags in the
 * underlying #GtkTextBuffer's tag table. Normally you do not need to use
 * this function if you do not set the priority for your tags explicitely.
 * However, if you do (or are forced to do, because you are using a library
 * that does this, such as GtkSourceView), then you can call this function
 * afterwards to make sure all the user tags have the lowest priority.
 */
void
inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
    buffer
  );
}

/**
 * inf_text_gtk_buffer_set_saturation_value:
 * @buffer: A #InfTextGtkBuffer.
 * @saturation: Saturation to use for user colors.
 * @value: Value to use for user colors.
 *
 * Sets the saturation and value to use for user colors in a HSV color model.
 * The hue is defined by each user's individual color. The reason why S and V
 * are set locally the same for all users is that they can be adjusted
 * depending on one's theme: Dark themes want dark user colors, bright themes
 * want bright ones.
 */
void
inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
                                         gdouble saturation,
                                         gdouble value)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
  g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
    return;

  g_object_freeze_notify(G_OBJECT(buffer));
  if(saturation != priv-&gt;saturation)
  {
    priv-&gt;saturation = saturation;
    g_object_notify(G_OBJECT(buffer), "saturation");
  }

  if(value != priv-&gt;value)
  {
    priv-&gt;value = value;
    g_object_notify(G_OBJECT(buffer), "value");
  }

  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );
  g_object_thaw_notify(G_OBJECT(buffer));
}

/**
 * inf_text_gtk_buffer_set_fade:
 * @buffer: A #InfTextGtkBuffer.
 * @alpha: An alpha value between 0.0 and 1.0.
 *
 * This functions can be used to show the user background color with limited
 * intensity, such that the background of the #GtkTextView showing the buffer
 * partly shines through.
 *
 * An @alpha value of 1.0 means to fully show the user background color, a
 * value of 0.0 means to show the given background color. Values inbetween
 * interpolate linearly between the two colors in RGB color space.
 *
 * The default value for @alpha is 1.0.
 */
void
inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
                             gdouble alpha)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);

  g_object_freeze_notify(G_OBJECT(buffer));
  if(alpha != priv-&gt;alpha)
  {
    priv-&gt;alpha = alpha;
    g_object_notify(G_OBJECT(buffer), "alpha");
  }

  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);

  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );

  g_object_thaw_notify(G_OBJECT(buffer));
}

/**
 * inf_text_gtk_buffer_get_saturation:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the saturation part of the HSV user color.
 *
 * Returns: The saturation used for user colors.
 */
gdouble
inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
}

/**
 * inf_text_gtk_buffer_get_value:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns the value part of the HSV user color.
 *
 * Returns: The value used for user colors.
 */
gdouble
inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
}

/**
 * inf_text_gtk_buffer_set_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 * @show: Whether to show user colors or not.
 *
 * If @show is %TRUE (the default), then the user color is used as background
 * for newly written text by that user. Otherwise, newly written text has no
 * background color.
 *
 * Note that this setting is for newly written text only. If you want to show
 * or hide user colors for existing text use
 * inf_text_gtk_buffer_show_user_colors().
 */
void
inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
                                         gboolean show)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
  g_object_notify(G_OBJECT(buffer), "show-user-colors");
}

/**
 * inf_text_gtk_buffer_get_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 *
 * Returns whether newly written text is attributed with the author's user
 * color or not.
 *
 * Returns: %TRUE if user color is applied to newly written text, or %FALSE
 * otherwise.
 */
gboolean
inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
}

/**
 * inf_text_gtk_buffer_show_user_colors:
 * @buffer: A #InfTextGtkBuffer.
 * @show: Whether to show or hide user colors.
 * @start: (in) (transfer none): Beginning of the range for which to show
 * or hide user colors.
 * @end: (in) (transfer none): End of the range for which to show or hide
 * user colors.
 *
 * If @show is %FALSE, then don't show user colors (which user wrote what
 * text) as the background of the text, in the range from @start to @end.
 * If @show is %TRUE, show user colors if they have previously been hidden
 * via a call to this function with @show being %FALSE.
 */
void
inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
                                     gboolean show,
                                     GtkTextIter* start,
                                     GtkTextIter* end)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter iter;
  GtkTextIter prev;
  InfTextUser* user;
  InfTextGtkBufferUserTags* tags;
  GtkTextTag* hide_tag;
  GtkTextTag* show_tag;

  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(start != NULL);
  g_return_if_fail(end != NULL);

  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  iter = *start;
  prev = iter;

  while(!gtk_text_iter_equal(&amp;iter, end))
  {
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
    if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
      iter = *end;

    if(user != NULL)
    {
      tags = g_hash_table_lookup(
        priv-&gt;user_tags,
        GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
      );
      g_assert(tags != NULL);

      if(show)
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
      }
      else
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
      }

      inf_signal_handlers_block_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );

      gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
      gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);

      inf_signal_handlers_unblock_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );
    }

    prev = iter;
  }
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
