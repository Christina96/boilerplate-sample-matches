
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.755244755244755%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-slowlog.c</h3>
            <pre><code>1  #include "server.h"
2  #include "slowlog.h"
3  slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, PORT_LONGLONG duration) {
4      slowlogEntry *se = zmalloc(sizeof(*se));
5      int j, slargc = argc;
6      if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
7      se->argc = slargc;
8      se->argv = zmalloc(sizeof(robj*)*slargc);
<span onclick='openModal()' class='match'>9      for (j = 0; j < slargc; j++) {
10          if (slargc != argc && j == slargc-1) {
11              se->argv[j] = createObject(OBJ_STRING,
12                  sdscatprintf(sdsempty(),"... (%d more arguments)",
13                  argc-slargc+1));
14          } else {
</span>15              if (argv[j]->type == OBJ_STRING &&
16                  sdsEncodedObject(argv[j]) &&
17                  sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
18              {
19                  sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);
20                  s = sdscatprintf(s,"... (%Iu more bytes)",                      WIN_PORT_FIX &bsol;* %lu -> %Iu */
21                      (PORT_ULONG)
22                      sdslen(argv[j]->ptr) - SLOWLOG_ENTRY_MAX_STRING);
23                  se->argv[j] = createObject(OBJ_STRING,s);
24              } else if (argv[j]->refcount == OBJ_SHARED_REFCOUNT) {
25                  se->argv[j] = argv[j];
26              } else {
27                  se->argv[j] = dupStringObject(argv[j]);
28              }
29          }
30      }
31      se->time = time(NULL);
32      se->duration = duration;
33      se->id = server.slowlog_entry_id++;
34      se->peerid = sdsnew(getClientPeerId(c));
35      se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();
36      return se;
37  }
38  void slowlogFreeEntry(void *septr) {
39      slowlogEntry *se = septr;
40      int j;
41      for (j = 0; j < se->argc; j++)
42          decrRefCount(se->argv[j]);
43      zfree(se->argv);
44      sdsfree(se->peerid);
45      sdsfree(se->cname);
46      zfree(se);
47  }
48  void slowlogInit(void) {
49      server.slowlog = listCreate();
50      server.slowlog_entry_id = 0;
51      listSetFreeMethod(server.slowlog,slowlogFreeEntry);
52  }
53  void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, PORT_LONGLONG duration) {
54      if (server.slowlog_log_slower_than < 0) return; &bsol;* Slowlog disabled */
55      if (duration >= server.slowlog_log_slower_than)
56          listAddNodeHead(server.slowlog,
57                          slowlogCreateEntry(c,argv,argc,duration));
58      while (listLength(server.slowlog) > server.slowlog_max_len)
59          listDelNode(server.slowlog,listLast(server.slowlog));
60  }
61  void slowlogReset(void) {
62      while (listLength(server.slowlog) > 0)
63          listDelNode(server.slowlog,listLast(server.slowlog));
64  }
65  void slowlogCommand(client *c) {
66      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
67          const char *help[] = {
68  "GET [count] -- Return top entries from the slowlog (default: 10)."
69  "    Entries are made of:",
70  "    id, timestamp, time in microseconds, arguments array, client IP and port, client name",
71  "LEN -- Return the length of the slowlog.",
72  "RESET -- Reset the slowlog.",
73  NULL
74          };
75          addReplyHelp(c, help);
76      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"reset")) {
77          slowlogReset();
78          addReply(c,shared.ok);
79      } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"len")) {
80          addReplyLongLong(c,listLength(server.slowlog));
81      } else if ((c->argc == 2 || c->argc == 3) &&
82                 !strcasecmp(c->argv[1]->ptr,"get"))
83      {
84          PORT_LONG count = 10, sent = 0;
85          listIter li;
86          void *totentries;
87          listNode *ln;
88          slowlogEntry *se;
89          if (c->argc == 3 &&
90              getLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK)
91              return;
92          listRewind(server.slowlog,&li);
93          totentries = addDeferredMultiBulkLength(c);
94          while(count-- && (ln = listNext(&li))) {
95              int j;
96              se = ln->value;
97              addReplyMultiBulkLen(c,6);
98              addReplyLongLong(c,se->id);
99              addReplyLongLong(c,se->time);
100              addReplyLongLong(c,se->duration);
101              addReplyMultiBulkLen(c,se->argc);
102              for (j = 0; j < se->argc; j++)
103                  addReplyBulk(c,se->argv[j]);
104              addReplyBulkCBuffer(c,se->peerid,sdslen(se->peerid));
105              addReplyBulkCBuffer(c,se->cname,sdslen(se->cname));
106              sent++;
107          }
108          setDeferredMultiBulkLength(c,totentries,sent);
109      } else {
110          addReplySubcommandSyntaxError(c);
111      }
112  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_list.c</h3>
            <pre><code>1  #include "server.h"
2  void listTypePush(robj *subject, robj *value, int where) {
3      if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
4          int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
5          value = getDecodedObject(value);
6          size_t len = sdslen(value->ptr);
7          quicklistPush(subject->ptr, value->ptr, len, pos);
8          decrRefCount(value);
9      } else {
10          serverPanic("Unknown list encoding");
11      }
12  }
13  void *listPopSaver(unsigned char *data, unsigned int sz) {
14      return createStringObject((char*)data,sz);
15  }
16  robj *listTypePop(robj *subject, int where) {
17      PORT_LONGLONG vlong;
18      robj *value = NULL;
19      int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;
20      if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
21          if (quicklistPopCustom(subject->ptr, ql_where, (unsigned char **)&value,
22                                 NULL, &vlong, listPopSaver)) {
23              if (!value)
24                  value = createStringObjectFromLongLong(vlong);
25          }
26      } else {
27          serverPanic("Unknown list encoding");
28      }
29      return value;
30  }
31  PORT_ULONG listTypeLength(const robj *subject) {
32      if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
33          return quicklistCount(subject->ptr);
34      } else {
35          serverPanic("Unknown list encoding");
36      }
37  }
38  listTypeIterator *listTypeInitIterator(robj *subject, PORT_LONG index,
39                                         unsigned char direction) {
40      listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
41      li->subject = subject;
42      li->encoding = subject->encoding;
43      li->direction = direction;
44      li->iter = NULL;
45      int iter_direction =
46          direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
47      if (li->encoding == OBJ_ENCODING_QUICKLIST) {
48          li->iter = quicklistGetIteratorAtIdx(li->subject->ptr,
49                                               iter_direction, index);
50      } else {
51          serverPanic("Unknown list encoding");
52      }
53      return li;
54  }
55  void listTypeReleaseIterator(listTypeIterator *li) {
56      zfree(li->iter);
57      zfree(li);
58  }
59  int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
60      serverAssert(li->subject->encoding == li->encoding);
61      entry->li = li;
62      if (li->encoding == OBJ_ENCODING_QUICKLIST) {
63          return quicklistNext(li->iter, &entry->entry);
64      } else {
65          serverPanic("Unknown list encoding");
66      }
67      return 0;
68  }
69  robj *listTypeGet(listTypeEntry *entry) {
70      robj *value = NULL;
71      if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
72          if (entry->entry.value) {
73              value = createStringObject((char *)entry->entry.value,
74                                         entry->entry.sz);
75          } else {
76              value = createStringObjectFromLongLong(entry->entry.longval);
77          }
78      } else {
79          serverPanic("Unknown list encoding");
80      }
81      return value;
82  }
83  void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
84      if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
85          value = getDecodedObject(value);
86          sds str = value->ptr;
87          size_t len = sdslen(str);
88          if (where == LIST_TAIL) {
89              quicklistInsertAfter((quicklist *)entry->entry.quicklist,
90                                   &entry->entry, str, len);
91          } else if (where == LIST_HEAD) {
92              quicklistInsertBefore((quicklist *)entry->entry.quicklist,
93                                    &entry->entry, str, len);
94          }
95          decrRefCount(value);
96      } else {
97          serverPanic("Unknown list encoding");
98      }
99  }
100  int listTypeEqual(listTypeEntry *entry, robj *o) {
101      if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
102          serverAssertWithInfo(NULL,o,sdsEncodedObject(o));
103          return quicklistCompare(entry->entry.zi,o->ptr,sdslen(o->ptr));
104      } else {
105          serverPanic("Unknown list encoding");
106      }
107  }
108  void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
109      if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
110          quicklistDelEntry(iter->iter, &entry->entry);
111      } else {
112          serverPanic("Unknown list encoding");
113      }
114  }
115  void listTypeConvert(robj *subject, int enc) {
116      serverAssertWithInfo(NULL,subject,subject->type==OBJ_LIST);
117      serverAssertWithInfo(NULL,subject,subject->encoding==OBJ_ENCODING_ZIPLIST);
118      if (enc == OBJ_ENCODING_QUICKLIST) {
119          size_t zlen = server.list_max_ziplist_size;
120          int depth = server.list_compress_depth;
121          subject->ptr = quicklistCreateFromZiplist(zlen, depth, subject->ptr);
122          subject->encoding = OBJ_ENCODING_QUICKLIST;
123      } else {
124          serverPanic("Unsupported list conversion");
125      }
126  }
127  void pushGenericCommand(client *c, int where) {
128      int j, pushed = 0;
129      robj *lobj = lookupKeyWrite(c->db,c->argv[1]);
130      if (lobj && lobj->type != OBJ_LIST) {
131          addReply(c,shared.wrongtypeerr);
132          return;
133      }
<span onclick='openModal()' class='match'>134      for (j = 2; j < c->argc; j++) {
135          if (!lobj) {
136              lobj = createQuicklistObject();
137              quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,
138                                  server.list_compress_depth);
139              dbAdd(c->db,c->argv[1],lobj);
140          }
</span>141          listTypePush(lobj,c->argv[j],where);
142          pushed++;
143      }
144      addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));
145      if (pushed) {
146          char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
147          signalModifiedKey(c->db,c->argv[1]);
148          notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
149      }
150      server.dirty += pushed;
151  }
152  void lpushCommand(client *c) {
153      pushGenericCommand(c,LIST_HEAD);
154  }
155  void rpushCommand(client *c) {
156      pushGenericCommand(c,LIST_TAIL);
157  }
158  void pushxGenericCommand(client *c, int where) {
159      int j, pushed = 0;
160      robj *subject;
161      if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
162          checkType(c,subject,OBJ_LIST)) return;
163      for (j = 2; j < c->argc; j++) {
164          listTypePush(subject,c->argv[j],where);
165          pushed++;
166      }
167      addReplyLongLong(c,listTypeLength(subject));
168      if (pushed) {
169          char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
170          signalModifiedKey(c->db,c->argv[1]);
171          notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
172      }
173      server.dirty += pushed;
174  }
175  void lpushxCommand(client *c) {
176      pushxGenericCommand(c,LIST_HEAD);
177  }
178  void rpushxCommand(client *c) {
179      pushxGenericCommand(c,LIST_TAIL);
180  }
181  void linsertCommand(client *c) {
182      int where;
183      robj *subject;
184      listTypeIterator *iter;
185      listTypeEntry entry;
186      int inserted = 0;
187      if (strcasecmp(c->argv[2]->ptr,"after") == 0) {
188          where = LIST_TAIL;
189      } else if (strcasecmp(c->argv[2]->ptr,"before") == 0) {
190          where = LIST_HEAD;
191      } else {
192          addReply(c,shared.syntaxerr);
193          return;
194      }
195      if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
196          checkType(c,subject,OBJ_LIST)) return;
197      iter = listTypeInitIterator(subject,0,LIST_TAIL);
198      while (listTypeNext(iter,&entry)) {
199          if (listTypeEqual(&entry,c->argv[3])) {
200              listTypeInsert(&entry,c->argv[4],where);
201              inserted = 1;
202              break;
203          }
204      }
205      listTypeReleaseIterator(iter);
206      if (inserted) {
207          signalModifiedKey(c->db,c->argv[1]);
208          notifyKeyspaceEvent(NOTIFY_LIST,"linsert",
209                              c->argv[1],c->db->id);
210          server.dirty++;
211      } else {
212          addReply(c,shared.cnegone);
213          return;
214      }
215      addReplyLongLong(c,listTypeLength(subject));
216  }
217  void llenCommand(client *c) {
218      robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
219      if (o == NULL || checkType(c,o,OBJ_LIST)) return;
220      addReplyLongLong(c,listTypeLength(o));
221  }
222  void lindexCommand(client *c) {
223      robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);
224      if (o == NULL || checkType(c,o,OBJ_LIST)) return;
225      PORT_LONG index;
226      robj *value = NULL;
227      if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
228          return;
229      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
230          quicklistEntry entry;
231          if (quicklistIndex(o->ptr, index, &entry)) {
232              if (entry.value) {
233                  value = createStringObject((char*)entry.value,entry.sz);
234              } else {
235                  value = createStringObjectFromLongLong(entry.longval);
236              }
237              addReplyBulk(c,value);
238              decrRefCount(value);
239          } else {
240              addReply(c,shared.nullbulk);
241          }
242      } else {
243          serverPanic("Unknown list encoding");
244      }
245  }
246  void lsetCommand(client *c) {
247      robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
248      if (o == NULL || checkType(c,o,OBJ_LIST)) return;
249      PORT_LONG index;
250      robj *value = c->argv[3];
251      if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
252          return;
253      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
254          quicklist *ql = o->ptr;
255          int replaced = quicklistReplaceAtIndex(ql, index,
256                                                 value->ptr, sdslen(value->ptr));
257          if (!replaced) {
258              addReply(c,shared.outofrangeerr);
259          } else {
260              addReply(c,shared.ok);
261              signalModifiedKey(c->db,c->argv[1]);
262              notifyKeyspaceEvent(NOTIFY_LIST,"lset",c->argv[1],c->db->id);
263              server.dirty++;
264          }
265      } else {
266          serverPanic("Unknown list encoding");
267      }
268  }
269  void popGenericCommand(client *c, int where) {
270      robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);
271      if (o == NULL || checkType(c,o,OBJ_LIST)) return;
272      robj *value = listTypePop(o,where);
273      if (value == NULL) {
274          addReply(c,shared.nullbulk);
275      } else {
276          char *event = (where == LIST_HEAD) ? "lpop" : "rpop";
277          addReplyBulk(c,value);
278          decrRefCount(value);
279          notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
280          if (listTypeLength(o) == 0) {
281              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
282                                  c->argv[1],c->db->id);
283              dbDelete(c->db,c->argv[1]);
284          }
285          signalModifiedKey(c->db,c->argv[1]);
286          server.dirty++;
287      }
288  }
289  void lpopCommand(client *c) {
290      popGenericCommand(c,LIST_HEAD);
291  }
292  void rpopCommand(client *c) {
293      popGenericCommand(c,LIST_TAIL);
294  }
295  void lrangeCommand(client *c) {
296      robj *o;
297      PORT_LONG start, end, llen, rangelen;
298      if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
299          (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
300      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
301           || checkType(c,o,OBJ_LIST)) return;
302      llen = listTypeLength(o);
303      if (start < 0) start = llen+start;
304      if (end < 0) end = llen+end;
305      if (start < 0) start = 0;
306      if (start > end || start >= llen) {
307          addReply(c,shared.emptymultibulk);
308          return;
309      }
310      if (end >= llen) end = llen-1;
311      rangelen = (end-start)+1;
312      addReplyMultiBulkLen(c,rangelen);
313      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
314          listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);
315          while(rangelen--) {
316              listTypeEntry entry;
317              listTypeNext(iter, &entry);
318              quicklistEntry *qe = &entry.entry;
319              if (qe->value) {
320                  addReplyBulkCBuffer(c,qe->value,qe->sz);
321              } else {
322                  addReplyBulkLongLong(c,qe->longval);
323              }
324          }
325          listTypeReleaseIterator(iter);
326      } else {
327          serverPanic("List encoding is not QUICKLIST!");
328      }
329  }
330  void ltrimCommand(client *c) {
331      robj *o;
332      PORT_LONG start, end, llen, ltrim, rtrim;
333      if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
334          (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
335      if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
336          checkType(c,o,OBJ_LIST)) return;
337      llen = listTypeLength(o);
338      if (start < 0) start = llen+start;
339      if (end < 0) end = llen+end;
340      if (start < 0) start = 0;
341      if (start > end || start >= llen) {
342          ltrim = llen;
343          rtrim = 0;
344      } else {
345          if (end >= llen) end = llen-1;
346          ltrim = start;
347          rtrim = llen-end-1;
348      }
349      if (o->encoding == OBJ_ENCODING_QUICKLIST) {
350          quicklistDelRange(o->ptr,0,ltrim);
351          quicklistDelRange(o->ptr,-rtrim,rtrim);
352      } else {
353          serverPanic("Unknown list encoding");
354      }
355      notifyKeyspaceEvent(NOTIFY_LIST,"ltrim",c->argv[1],c->db->id);
356      if (listTypeLength(o) == 0) {
357          dbDelete(c->db,c->argv[1]);
358          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
359      }
360      signalModifiedKey(c->db,c->argv[1]);
361      server.dirty++;
362      addReply(c,shared.ok);
363  }
364  void lremCommand(client *c) {
365      robj *subject, *obj;
366      obj = c->argv[3];
367      PORT_LONG toremove;
368      PORT_LONG removed = 0;
369      if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
370          return;
371      subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
372      if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;
373      listTypeIterator *li;
374      if (toremove < 0) {
375          toremove = -toremove;
376          li = listTypeInitIterator(subject,-1,LIST_HEAD);
377      } else {
378          li = listTypeInitIterator(subject,0,LIST_TAIL);
379      }
380      listTypeEntry entry;
381      while (listTypeNext(li,&entry)) {
382          if (listTypeEqual(&entry,obj)) {
383              listTypeDelete(li, &entry);
384              server.dirty++;
385              removed++;
386              if (toremove && removed == toremove) break;
387          }
388      }
389      listTypeReleaseIterator(li);
390      if (removed) {
391          signalModifiedKey(c->db,c->argv[1]);
392          notifyKeyspaceEvent(NOTIFY_LIST,"lrem",c->argv[1],c->db->id);
393      }
394      if (listTypeLength(subject) == 0) {
395          dbDelete(c->db,c->argv[1]);
396          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
397      }
398      addReplyLongLong(c,removed);
399  }
400  void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {
401      if (!dstobj) {
402          dstobj = createQuicklistObject();
403          quicklistSetOptions(dstobj->ptr, server.list_max_ziplist_size,
404                              server.list_compress_depth);
405          dbAdd(c->db,dstkey,dstobj);
406      }
407      signalModifiedKey(c->db,dstkey);
408      listTypePush(dstobj,value,LIST_HEAD);
409      notifyKeyspaceEvent(NOTIFY_LIST,"lpush",dstkey,c->db->id);
410      addReplyBulk(c,value);
411  }
412  void rpoplpushCommand(client *c) {
413      robj *sobj, *value;
414      if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
415          checkType(c,sobj,OBJ_LIST)) return;
416      if (listTypeLength(sobj) == 0) {
417          addReply(c,shared.nullbulk);
418      } else {
419          robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
420          robj *touchedkey = c->argv[1];
421          if (dobj && checkType(c,dobj,OBJ_LIST)) return;
422          value = listTypePop(sobj,LIST_TAIL);
423          incrRefCount(touchedkey);
424          rpoplpushHandlePush(c,c->argv[2],dobj,value);
425          decrRefCount(value);
426          notifyKeyspaceEvent(NOTIFY_LIST,"rpop",touchedkey,c->db->id);
427          if (listTypeLength(sobj) == 0) {
428              dbDelete(c->db,touchedkey);
429              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
430                                  touchedkey,c->db->id);
431          }
432          signalModifiedKey(c->db,touchedkey);
433          decrRefCount(touchedkey);
434          server.dirty++;
435          if (c->cmd->proc == brpoplpushCommand) {
436              rewriteClientCommandVector(c,3,shared.rpoplpush,c->argv[1],c->argv[2]);
437          }
438      }
439  }
440  int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)
441  {
442      robj *argv[3];
443      if (dstkey == NULL) {
444          argv[0] = (where == LIST_HEAD) ? shared.lpop :
445                                            shared.rpop;
446          argv[1] = key;
447          propagate((where == LIST_HEAD) ?
448              server.lpopCommand : server.rpopCommand,
449              db->id,argv,2,PROPAGATE_AOF|PROPAGATE_REPL);
450          addReplyMultiBulkLen(receiver,2);
451          addReplyBulk(receiver,key);
452          addReplyBulk(receiver,value);
453          char *event = (where == LIST_HEAD) ? "lpop" : "rpop";
454          notifyKeyspaceEvent(NOTIFY_LIST,event,key,receiver->db->id);
455      } else {
456          robj *dstobj =
457              lookupKeyWrite(receiver->db,dstkey);
458          if (!(dstobj &&
459               checkType(receiver,dstobj,OBJ_LIST)))
460          {
461              argv[0] = shared.rpop;
462              argv[1] = key;
463              propagate(server.rpopCommand,
464                  db->id,argv,2,
465                  PROPAGATE_AOF|
466                  PROPAGATE_REPL);
467              rpoplpushHandlePush(receiver,dstkey,dstobj,
468                  value);
469              argv[0] = shared.lpush;
470              argv[1] = dstkey;
471              argv[2] = value;
472              propagate(server.lpushCommand,
473                  db->id,argv,3,
474                  PROPAGATE_AOF|
475                  PROPAGATE_REPL);
476              notifyKeyspaceEvent(NOTIFY_LIST,"rpop",key,receiver->db->id);
477          } else {
478              return C_ERR;
479          }
480      }
481      return C_OK;
482  }
483  void blockingPopGenericCommand(client *c, int where) {
484      robj *o;
485      mstime_t timeout;
486      int j;
487      if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
488          != C_OK) return;
489      for (j = 1; j < c->argc-1; j++) {
490          o = lookupKeyWrite(c->db,c->argv[j]);
491          if (o != NULL) {
492              if (o->type != OBJ_LIST) {
493                  addReply(c,shared.wrongtypeerr);
494                  return;
495              } else {
496                  if (listTypeLength(o) != 0) {
497                      char *event = (where == LIST_HEAD) ? "lpop" : "rpop";
498                      robj *value = listTypePop(o,where);
499                      serverAssert(value != NULL);
500                      addReplyMultiBulkLen(c,2);
501                      addReplyBulk(c,c->argv[j]);
502                      addReplyBulk(c,value);
503                      decrRefCount(value);
504                      notifyKeyspaceEvent(NOTIFY_LIST,event,
505                                          c->argv[j],c->db->id);
506                      if (listTypeLength(o) == 0) {
507                          dbDelete(c->db,c->argv[j]);
508                          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
509                                              c->argv[j],c->db->id);
510                      }
511                      signalModifiedKey(c->db,c->argv[j]);
512                      server.dirty++;
513                      rewriteClientCommandVector(c,2,
514                          (where == LIST_HEAD) ? shared.lpop : shared.rpop,
515                          c->argv[j]);
516                      return;
517                  }
518              }
519          }
520      }
521      if (c->flags & CLIENT_MULTI) {
522          addReply(c,shared.nullmultibulk);
523          return;
524      }
525      blockForKeys(c,BLOCKED_LIST,c->argv + 1,c->argc - 2,timeout,NULL,NULL);
526  }
527  void blpopCommand(client *c) {
528      blockingPopGenericCommand(c,LIST_HEAD);
529  }
530  void brpopCommand(client *c) {
531      blockingPopGenericCommand(c,LIST_TAIL);
532  }
533  void brpoplpushCommand(client *c) {
534      mstime_t timeout;
535      if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
536          != C_OK) return;
537      robj *key = lookupKeyWrite(c->db, c->argv[1]);
538      if (key == NULL) {
539          if (c->flags & CLIENT_MULTI) {
540              addReply(c, shared.nullbulk);
541          } else {
542              blockForKeys(c,BLOCKED_LIST,c->argv + 1,1,timeout,c->argv[2],NULL);
543          }
544      } else {
545          if (key->type != OBJ_LIST) {
546              addReply(c, shared.wrongtypeerr);
547          } else {
548              serverAssertWithInfo(c,key,listTypeLength(key) > 0);
549              rpoplpushCommand(c);
550          }
551      }
552  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-slowlog.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_list.c</div>
                </div>
                <div class="column column_space"><pre><code>9      for (j = 0; j < slargc; j++) {
10          if (slargc != argc && j == slargc-1) {
11              se->argv[j] = createObject(OBJ_STRING,
12                  sdscatprintf(sdsempty(),"... (%d more arguments)",
13                  argc-slargc+1));
14          } else {
</pre></code></div>
                <div class="column column_space"><pre><code>134      for (j = 2; j < c->argc; j++) {
135          if (!lobj) {
136              lobj = createQuicklistObject();
137              quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,
138                                  server.list_compress_depth);
139              dbAdd(c->db,c->argv[1],lobj);
140          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    