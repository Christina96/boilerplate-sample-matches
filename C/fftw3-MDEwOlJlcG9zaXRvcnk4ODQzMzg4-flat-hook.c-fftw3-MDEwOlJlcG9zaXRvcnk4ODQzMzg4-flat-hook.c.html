
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hook.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include "libbench2/bench-user.h"
3  #define CALLING_FFTW &bsol;* hack for Windows DLL nonsense */
4  #include "api/api.h"
5  #include "dft/dft.h"
6  #include "rdft/rdft.h"
7  extern int paranoid; &bsol;* in bench.c */
8  extern X(plan) the_plan; &bsol;* in bench.c */
9  static bench_tensor *fftw_tensor_to_bench_tensor(tensor *t)
10  {
11       bench_tensor *bt = mktensor(t->rnk);
12       if (FINITE_RNK(t->rnk)) {
13  	  int i;
14  	  for (i = 0; i < t->rnk; ++i) {
15  	       bt->dims[i].n = t->dims[i].n;
16  	       bt->dims[i].is = t->dims[i].is;
17  	       bt->dims[i].os = t->dims[i].os;
18  	       BENCH_ASSERT(bt->dims[i].n == t->dims[i].n);
19  	       BENCH_ASSERT(bt->dims[i].is == t->dims[i].is);
20  	       BENCH_ASSERT(bt->dims[i].os == t->dims[i].os);
21  	  }
22       }
23       return bt;
24  }
25  static bench_problem *fftw_problem_to_bench_problem(planner *plnr,
26  						    const problem *p_)
27  {
28       bench_problem *bp = 0;
29       switch (p_->adt->problem_kind) {
30  	 case PROBLEM_DFT:
31  	 {
32  	      const problem_dft *p = (const problem_dft *) p_;
33  	      if (!p->ri || !p->ii)
34  		   abort();
35  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
36  	      bp->kind = PROBLEM_COMPLEX;
37  	      bp->sign = FFT_SIGN;
38  	      bp->split = 1; &bsol;* tensor strides are in R's, not C's */
39  	      bp->in = UNTAINT(p->ri);
40  	      bp->out = UNTAINT(p->ro);
41  	      bp->ini = UNTAINT(p->ii);
42  	      bp->outi = UNTAINT(p->io);
43  	      bp->inphys = bp->outphys = 0;
44  	      bp->iphyssz = bp->ophyssz = 0;
45  	      bp->in_place = p->ri == p->ro;
46  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
47  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
48  	      bp->k = 0;
49  	      break;
50  	 }
51  	 case PROBLEM_RDFT:
52  	 {
53  	      const problem_rdft *p = (const problem_rdft *) p_;
54  	      int i;
55  	      if (!p->I || !p->O)
56  		   abort();
57  	      for (i = 0; i < p->sz->rnk; ++i)
58  		   switch (p->kind[i]) {
59  		       case R2HC01:
60  		       case R2HC10:
61  		       case R2HC11:
62  		       case HC2R01:
63  		       case HC2R10:
64  		       case HC2R11:
65  			    return bp;
66  		       default:
67  			    ;
68  		   }
69  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
70  	      bp->kind = PROBLEM_R2R;
71  	      bp->sign = FFT_SIGN;
72  	      bp->split = 0;
73  	      bp->in = UNTAINT(p->I);
74  	      bp->out = UNTAINT(p->O);
75  	      bp->ini = bp->outi = 0;
76  	      bp->inphys = bp->outphys = 0;
77  	      bp->iphyssz = bp->ophyssz = 0;
78  	      bp->in_place = p->I == p->O;
79  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
80  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
81  	      bp->k = (r2r_kind_t *) bench_malloc(sizeof(r2r_kind_t) * p->sz->rnk);
82  	      for (i = 0; i < p->sz->rnk; ++i)
83  		   switch (p->kind[i]) {
84  		       case R2HC: bp->k[i] = R2R_R2HC; break;
85  		       case HC2R: bp->k[i] = R2R_HC2R; break;
86  		       case DHT: bp->k[i] = R2R_DHT; break;
87  		       case REDFT00: bp->k[i] = R2R_REDFT00; break;
88  		       case REDFT01: bp->k[i] = R2R_REDFT01; break;
89  		       case REDFT10: bp->k[i] = R2R_REDFT10; break;
90  		       case REDFT11: bp->k[i] = R2R_REDFT11; break;
91  		       case RODFT00: bp->k[i] = R2R_RODFT00; break;
92  		       case RODFT01: bp->k[i] = R2R_RODFT01; break;
93  		       case RODFT10: bp->k[i] = R2R_RODFT10; break;
94  		       case RODFT11: bp->k[i] = R2R_RODFT11; break;
95  		       default: CK(0);
96  		   }
97  	      break;
98  	 }
99  	 case PROBLEM_RDFT2:
100  	 {
101  	      const problem_rdft2 *p = (const problem_rdft2 *) p_;
102  	      int rnk = p->sz->rnk;
103  	      if (!p->r0 || !p->r1 || !p->cr || !p->ci)
104  		   abort();
105  	      if (p->kind != R2HC && p->kind != HC2R)
106  		   return bp;
107  	      if (rnk > 0) {
108  		   if (2 * (p->r1 - p->r0) !=
109  		       ((p->kind == R2HC) ? 
110  			p->sz->dims[rnk-1].is : p->sz->dims[rnk-1].os))
111  			return bp;
112  	      }
113  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
114  	      bp->kind = PROBLEM_REAL;
115  	      bp->sign = p->kind == R2HC ? FFT_SIGN : -FFT_SIGN;
116  	      bp->split = 1; &bsol;* tensor strides are in R's, not C's */
117  	      if (p->kind == R2HC) {
118  		   bp->sign = FFT_SIGN;
119  		   bp->in = UNTAINT(p->r0);
120  		   bp->out = UNTAINT(p->cr);
121  		   bp->ini = 0;
122  		   bp->outi = UNTAINT(p->ci);
123  	      }
124  	      else {
125  		   bp->sign = -FFT_SIGN;
126  		   bp->out = UNTAINT(p->r0);
127  		   bp->in = UNTAINT(p->cr);
128  		   bp->outi = 0;
129  		   bp->ini = UNTAINT(p->ci);
130  	      }
131  	      bp->inphys = bp->outphys = 0;
132  	      bp->iphyssz = bp->ophyssz = 0;
133  	      bp->in_place = p->r0 == p->cr;
134  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
135  	      if (rnk > 0) {
136  		   if (p->kind == R2HC)
137  			bp->sz->dims[rnk-1].is /= 2;
138  		   else 
139  			bp->sz->dims[rnk-1].os /= 2;
140  	      }
141  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
142  	      bp->k = 0;
143  	      break;
144  	 }
145  	 default: 
146  	      abort();
147       }
148       bp->userinfo = 0;
149       bp->pstring = 0;
150       bp->destroy_input = !NO_DESTROY_INPUTP(plnr);
151       return bp;
152  }
153  static void hook(planner *plnr, plan *pln, const problem *p_, int optimalp)
154  {
155       int rounds = 5;
156       double tol = SINGLE_PRECISION ? 1.0e-3 : 1.0e-10;
157       UNUSED(optimalp);
158       if (verbose > 5) {
159  	  printer *pr = X(mkprinter_file)(stdout);
160  	  pr->print(pr, "%P:%(%p%)\n", p_, pln);
161  	  X(printer_destroy)(pr);
162  	  printf("cost %g  \n\n", pln->pcost);
163       }
164       if (paranoid) {
165  	  bench_problem *bp;
166  	  bp = fftw_problem_to_bench_problem(plnr, p_);
167  	  if (bp) {
168  	       X(plan) the_plan_save = the_plan;
169  	       the_plan = (apiplan *) MALLOC(sizeof(apiplan), PLANS);
170  	       the_plan->pln = pln;
171  	       the_plan->prb = (problem *) p_;
172  	       X(plan_awake)(pln, AWAKE_SQRTN_TABLE);
173  	       verify_problem(bp, rounds, tol);
174  	       X(plan_awake)(pln, SLEEPY);
175  	       X(ifree)(the_plan);
176  	       the_plan = the_plan_save;
<span onclick='openModal()' class='match'>177  	       problem_destroy(bp);
178  	  }
179       }
180  }
181  static void paranoid_checks(void)
182  {
183  #if 0
</span>184       CK(sizeof(flags_t) == 8);
185       CK(sizeof(md5uint) >= 4);
186  #endif
187       CK(sizeof(uintptr_t) >= sizeof(R *));
188       CK(sizeof(INT) >= sizeof(R *));
189  }
190  void install_hook(void)
191  {
192       planner *plnr = X(the_planner)();
193       plnr->hook = hook;
194       paranoid_checks();
195  }
196  void uninstall_hook(void)
197  {
198       planner *plnr = X(the_planner)();
199       plnr->hook = 0;
200  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hook.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include "libbench2/bench-user.h"
3  #define CALLING_FFTW &bsol;* hack for Windows DLL nonsense */
4  #include "api/api.h"
5  #include "dft/dft.h"
6  #include "rdft/rdft.h"
7  extern int paranoid; &bsol;* in bench.c */
8  extern X(plan) the_plan; &bsol;* in bench.c */
9  static bench_tensor *fftw_tensor_to_bench_tensor(tensor *t)
10  {
11       bench_tensor *bt = mktensor(t->rnk);
12       if (FINITE_RNK(t->rnk)) {
13  	  int i;
14  	  for (i = 0; i < t->rnk; ++i) {
15  	       bt->dims[i].n = t->dims[i].n;
16  	       bt->dims[i].is = t->dims[i].is;
17  	       bt->dims[i].os = t->dims[i].os;
18  	       BENCH_ASSERT(bt->dims[i].n == t->dims[i].n);
19  	       BENCH_ASSERT(bt->dims[i].is == t->dims[i].is);
20  	       BENCH_ASSERT(bt->dims[i].os == t->dims[i].os);
21  	  }
22       }
23       return bt;
24  }
25  static bench_problem *fftw_problem_to_bench_problem(planner *plnr,
26  						    const problem *p_)
27  {
28       bench_problem *bp = 0;
29       switch (p_->adt->problem_kind) {
30  	 case PROBLEM_DFT:
31  	 {
32  	      const problem_dft *p = (const problem_dft *) p_;
33  	      if (!p->ri || !p->ii)
34  		   abort();
35  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
36  	      bp->kind = PROBLEM_COMPLEX;
37  	      bp->sign = FFT_SIGN;
38  	      bp->split = 1; &bsol;* tensor strides are in R's, not C's */
39  	      bp->in = UNTAINT(p->ri);
40  	      bp->out = UNTAINT(p->ro);
41  	      bp->ini = UNTAINT(p->ii);
42  	      bp->outi = UNTAINT(p->io);
43  	      bp->inphys = bp->outphys = 0;
44  	      bp->iphyssz = bp->ophyssz = 0;
45  	      bp->in_place = p->ri == p->ro;
46  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
47  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
48  	      bp->k = 0;
49  	      break;
50  	 }
51  	 case PROBLEM_RDFT:
52  	 {
53  	      const problem_rdft *p = (const problem_rdft *) p_;
54  	      int i;
55  	      if (!p->I || !p->O)
56  		   abort();
57  	      for (i = 0; i < p->sz->rnk; ++i)
58  		   switch (p->kind[i]) {
59  		       case R2HC01:
60  		       case R2HC10:
61  		       case R2HC11:
62  		       case HC2R01:
63  		       case HC2R10:
64  		       case HC2R11:
65  			    return bp;
66  		       default:
67  			    ;
68  		   }
69  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
70  	      bp->kind = PROBLEM_R2R;
71  	      bp->sign = FFT_SIGN;
72  	      bp->split = 0;
73  	      bp->in = UNTAINT(p->I);
74  	      bp->out = UNTAINT(p->O);
75  	      bp->ini = bp->outi = 0;
76  	      bp->inphys = bp->outphys = 0;
77  	      bp->iphyssz = bp->ophyssz = 0;
78  	      bp->in_place = p->I == p->O;
79  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
80  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
81  	      bp->k = (r2r_kind_t *) bench_malloc(sizeof(r2r_kind_t) * p->sz->rnk);
82  	      for (i = 0; i < p->sz->rnk; ++i)
83  		   switch (p->kind[i]) {
84  		       case R2HC: bp->k[i] = R2R_R2HC; break;
85  		       case HC2R: bp->k[i] = R2R_HC2R; break;
86  		       case DHT: bp->k[i] = R2R_DHT; break;
87  		       case REDFT00: bp->k[i] = R2R_REDFT00; break;
88  		       case REDFT01: bp->k[i] = R2R_REDFT01; break;
89  		       case REDFT10: bp->k[i] = R2R_REDFT10; break;
90  		       case REDFT11: bp->k[i] = R2R_REDFT11; break;
91  		       case RODFT00: bp->k[i] = R2R_RODFT00; break;
92  		       case RODFT01: bp->k[i] = R2R_RODFT01; break;
93  		       case RODFT10: bp->k[i] = R2R_RODFT10; break;
94  		       case RODFT11: bp->k[i] = R2R_RODFT11; break;
95  		       default: CK(0);
96  		   }
97  	      break;
98  	 }
99  	 case PROBLEM_RDFT2:
100  	 {
101  	      const problem_rdft2 *p = (const problem_rdft2 *) p_;
102  	      int rnk = p->sz->rnk;
103  	      if (!p->r0 || !p->r1 || !p->cr || !p->ci)
104  		   abort();
105  	      if (p->kind != R2HC && p->kind != HC2R)
106  		   return bp;
107  	      if (rnk > 0) {
108  		   if (2 * (p->r1 - p->r0) !=
109  		       ((p->kind == R2HC) ? 
110  			p->sz->dims[rnk-1].is : p->sz->dims[rnk-1].os))
111  			return bp;
112  	      }
113  	      bp = (bench_problem *) bench_malloc(sizeof(bench_problem));
114  	      bp->kind = PROBLEM_REAL;
115  	      bp->sign = p->kind == R2HC ? FFT_SIGN : -FFT_SIGN;
116  	      bp->split = 1; &bsol;* tensor strides are in R's, not C's */
117  	      if (p->kind == R2HC) {
118  		   bp->sign = FFT_SIGN;
119  		   bp->in = UNTAINT(p->r0);
120  		   bp->out = UNTAINT(p->cr);
121  		   bp->ini = 0;
122  		   bp->outi = UNTAINT(p->ci);
123  	      }
124  	      else {
125  		   bp->sign = -FFT_SIGN;
126  		   bp->out = UNTAINT(p->r0);
127  		   bp->in = UNTAINT(p->cr);
128  		   bp->outi = 0;
129  		   bp->ini = UNTAINT(p->ci);
130  	      }
131  	      bp->inphys = bp->outphys = 0;
132  	      bp->iphyssz = bp->ophyssz = 0;
133  	      bp->in_place = p->r0 == p->cr;
134  	      bp->sz = fftw_tensor_to_bench_tensor(p->sz);
135  	      if (rnk > 0) {
136  		   if (p->kind == R2HC)
137  			bp->sz->dims[rnk-1].is /= 2;
138  		   else 
139  			bp->sz->dims[rnk-1].os /= 2;
140  	      }
141  	      bp->vecsz = fftw_tensor_to_bench_tensor(p->vecsz);
142  	      bp->k = 0;
143  	      break;
144  	 }
145  	 default: 
146  	      abort();
147       }
148       bp->userinfo = 0;
149       bp->pstring = 0;
150       bp->destroy_input = !NO_DESTROY_INPUTP(plnr);
151       return bp;
152  }
153  static void hook(planner *plnr, plan *pln, const problem *p_, int optimalp)
154  {
155       int rounds = 5;
156       double tol = SINGLE_PRECISION ? 1.0e-3 : 1.0e-10;
157       UNUSED(optimalp);
158       if (verbose > 5) {
159  	  printer *pr = X(mkprinter_file)(stdout);
160  	  pr->print(pr, "%P:%(%p%)\n", p_, pln);
161  	  X(printer_destroy)(pr);
162  	  printf("cost %g  \n\n", pln->pcost);
163       }
164       if (paranoid) {
165  	  bench_problem *bp;
166  	  bp = fftw_problem_to_bench_problem(plnr, p_);
167  	  if (bp) {
168  	       X(plan) the_plan_save = the_plan;
169  	       the_plan = (apiplan *) MALLOC(sizeof(apiplan), PLANS);
170  	       the_plan->pln = pln;
171  	       the_plan->prb = (problem *) p_;
172  	       X(plan_awake)(pln, AWAKE_SQRTN_TABLE);
173  	       verify_problem(bp, rounds, tol);
174  	       X(plan_awake)(pln, SLEEPY);
175  	       X(ifree)(the_plan);
176  	       the_plan = the_plan_save;
<span onclick='openModal()' class='match'>177  	       problem_destroy(bp);
178  	  }
179       }
180  }
181  static void paranoid_checks(void)
182  {
183  #if 0
</span>184       CK(sizeof(flags_t) == 8);
185       CK(sizeof(md5uint) >= 4);
186  #endif
187       CK(sizeof(uintptr_t) >= sizeof(R *));
188       CK(sizeof(INT) >= sizeof(R *));
189  }
190  void install_hook(void)
191  {
192       planner *plnr = X(the_planner)();
193       plnr->hook = hook;
194       paranoid_checks();
195  }
196  void uninstall_hook(void)
197  {
198       planner *plnr = X(the_planner)();
199       plnr->hook = 0;
200  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hook.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hook.c</div>
                </div>
                <div class="column column_space"><pre><code>177  	       problem_destroy(bp);
178  	  }
179       }
180  }
181  static void paranoid_checks(void)
182  {
183  #if 0
</pre></code></div>
                <div class="column column_space"><pre><code>177  	       problem_destroy(bp);
178  	  }
179       }
180  }
181  static void paranoid_checks(void)
182  {
183  #if 0
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    