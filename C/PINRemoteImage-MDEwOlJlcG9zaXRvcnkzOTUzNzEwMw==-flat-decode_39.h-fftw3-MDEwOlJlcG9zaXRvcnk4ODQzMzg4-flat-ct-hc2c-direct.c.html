
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.678936605316974%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-decode_39.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_DECODE_H_
2  #define WEBP_WEBP_DECODE_H_
3  #include "./types.h"
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define WEBP_DECODER_ABI_VERSION 0x0209    
8  typedef struct WebPRGBABuffer WebPRGBABuffer;
9  typedef struct WebPYUVABuffer WebPYUVABuffer;
10  typedef struct WebPDecBuffer WebPDecBuffer;
11  typedef struct WebPIDecoder WebPIDecoder;
12  typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
13  typedef struct WebPDecoderOptions WebPDecoderOptions;
14  typedef struct WebPDecoderConfig WebPDecoderConfig;
15  WEBP_EXTERN int WebPGetDecoderVersion(void);
16  WEBP_EXTERN int WebPGetInfo(const uint8_t* data, size_t data_size,
17                              int* width, int* height);
18  WEBP_EXTERN uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size,
19                                      int* width, int* height);
20  WEBP_EXTERN uint8_t* WebPDecodeARGB(const uint8_t* data, size_t data_size,
21                                      int* width, int* height);
22  WEBP_EXTERN uint8_t* WebPDecodeBGRA(const uint8_t* data, size_t data_size,
23                                      int* width, int* height);
24  WEBP_EXTERN uint8_t* WebPDecodeRGB(const uint8_t* data, size_t data_size,
25                                     int* width, int* height);
26  WEBP_EXTERN uint8_t* WebPDecodeBGR(const uint8_t* data, size_t data_size,
27                                     int* width, int* height);
28  WEBP_EXTERN uint8_t* WebPDecodeYUV(const uint8_t* data, size_t data_size,
29                                     int* width, int* height,
30                                     uint8_t** u, uint8_t** v,
31                                     int* stride, int* uv_stride);
32  WEBP_EXTERN uint8_t* WebPDecodeRGBAInto(
33      const uint8_t* data, size_t data_size,
34      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
35  WEBP_EXTERN uint8_t* WebPDecodeARGBInto(
36      const uint8_t* data, size_t data_size,
37      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
38  WEBP_EXTERN uint8_t* WebPDecodeBGRAInto(
39      const uint8_t* data, size_t data_size,
40      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
41  WEBP_EXTERN uint8_t* WebPDecodeRGBInto(
42      const uint8_t* data, size_t data_size,
43      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
44  WEBP_EXTERN uint8_t* WebPDecodeBGRInto(
45      const uint8_t* data, size_t data_size,
46      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
47  WEBP_EXTERN uint8_t* WebPDecodeYUVInto(
48      const uint8_t* data, size_t data_size,
49      uint8_t* luma, size_t luma_size, int luma_stride,
50      uint8_t* u, size_t u_size, int u_stride,
51      uint8_t* v, size_t v_size, int v_stride);
52  typedef enum WEBP_CSP_MODE {
<span onclick='openModal()' class='match'>53    MODE_RGB = 0, MODE_RGBA = 1,
54    MODE_BGR = 2, MODE_BGRA = 3,
55    MODE_ARGB = 4, MODE_RGBA_4444 = 5,
56    MODE_RGB_565 = 6,
57    MODE_rgbA = 7,
58    MODE_bgrA = 8,
59    MODE_Argb = 9,
60    MODE_rgbA_4444 = 10,
61    MODE_YUV = 11, MODE_YUVA = 12,  
</span>62    MODE_LAST = 13
63  } WEBP_CSP_MODE;
64  static WEBP_INLINE int WebPIsPremultipliedMode(WEBP_CSP_MODE mode) {
65    return (mode == MODE_rgbA || mode == MODE_bgrA || mode == MODE_Argb ||
66            mode == MODE_rgbA_4444);
67  }
68  static WEBP_INLINE int WebPIsAlphaMode(WEBP_CSP_MODE mode) {
69    return (mode == MODE_RGBA || mode == MODE_BGRA || mode == MODE_ARGB ||
70            mode == MODE_RGBA_4444 || mode == MODE_YUVA ||
71            WebPIsPremultipliedMode(mode));
72  }
73  static WEBP_INLINE int WebPIsRGBMode(WEBP_CSP_MODE mode) {
74    return (mode < MODE_YUV);
75  }
76  struct WebPRGBABuffer {    
77    uint8_t* rgba;    
78    int stride;       
79    size_t size;      
80  };
81  struct WebPYUVABuffer {              
82    uint8_t* y, *u, *v, *a;     
83    int y_stride;               
84    int u_stride, v_stride;     
85    int a_stride;               
86    size_t y_size;              
87    size_t u_size, v_size;      
88    size_t a_size;              
89  };
90  struct WebPDecBuffer {
91    WEBP_CSP_MODE colorspace;  
92    int width, height;         
93    int is_external_memory;    
94    union {
95      WebPRGBABuffer RGBA;
96      WebPYUVABuffer YUVA;
97    } u;                       
98    uint32_t       pad[4];     
99    uint8_t* private_memory;   
100  };
101  WEBP_EXTERN int WebPInitDecBufferInternal(WebPDecBuffer*, int);
102  static WEBP_INLINE int WebPInitDecBuffer(WebPDecBuffer* buffer) {
103    return WebPInitDecBufferInternal(buffer, WEBP_DECODER_ABI_VERSION);
104  }
105  WEBP_EXTERN void WebPFreeDecBuffer(WebPDecBuffer* buffer);
106  typedef enum VP8StatusCode {
107    VP8_STATUS_OK = 0,
108    VP8_STATUS_OUT_OF_MEMORY,
109    VP8_STATUS_INVALID_PARAM,
110    VP8_STATUS_BITSTREAM_ERROR,
111    VP8_STATUS_UNSUPPORTED_FEATURE,
112    VP8_STATUS_SUSPENDED,
113    VP8_STATUS_USER_ABORT,
114    VP8_STATUS_NOT_ENOUGH_DATA
115  } VP8StatusCode;
116  WEBP_EXTERN WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer);
117  WEBP_EXTERN WebPIDecoder* WebPINewRGB(
118      WEBP_CSP_MODE csp,
119      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
120  WEBP_EXTERN WebPIDecoder* WebPINewYUVA(
121      uint8_t* luma, size_t luma_size, int luma_stride,
122      uint8_t* u, size_t u_size, int u_stride,
123      uint8_t* v, size_t v_size, int v_stride,
124      uint8_t* a, size_t a_size, int a_stride);
125  WEBP_EXTERN WebPIDecoder* WebPINewYUV(
126      uint8_t* luma, size_t luma_size, int luma_stride,
127      uint8_t* u, size_t u_size, int u_stride,
128      uint8_t* v, size_t v_size, int v_stride);
129  WEBP_EXTERN void WebPIDelete(WebPIDecoder* idec);
130  WEBP_EXTERN VP8StatusCode WebPIAppend(
131      WebPIDecoder* idec, const uint8_t* data, size_t data_size);
132  WEBP_EXTERN VP8StatusCode WebPIUpdate(
133      WebPIDecoder* idec, const uint8_t* data, size_t data_size);
134  WEBP_EXTERN uint8_t* WebPIDecGetRGB(
135      const WebPIDecoder* idec, int* last_y,
136      int* width, int* height, int* stride);
137  WEBP_EXTERN uint8_t* WebPIDecGetYUVA(
138      const WebPIDecoder* idec, int* last_y,
139      uint8_t** u, uint8_t** v, uint8_t** a,
140      int* width, int* height, int* stride, int* uv_stride, int* a_stride);
141  static WEBP_INLINE uint8_t* WebPIDecGetYUV(
142      const WebPIDecoder* idec, int* last_y, uint8_t** u, uint8_t** v,
143      int* width, int* height, int* stride, int* uv_stride) {
144    return WebPIDecGetYUVA(idec, last_y, u, v, NULL, width, height,
145                           stride, uv_stride, NULL);
146  }
147  WEBP_EXTERN const WebPDecBuffer* WebPIDecodedArea(
148      const WebPIDecoder* idec, int* left, int* top, int* width, int* height);
149  struct WebPBitstreamFeatures {
150    int width;          
151    int height;         
152    int has_alpha;      
153    int has_animation;  
154    int format;         
155    uint32_t pad[5];    
156  };
157  WEBP_EXTERN VP8StatusCode WebPGetFeaturesInternal(
158      const uint8_t*, size_t, WebPBitstreamFeatures*, int);
159  static WEBP_INLINE VP8StatusCode WebPGetFeatures(
160      const uint8_t* data, size_t data_size,
161      WebPBitstreamFeatures* features) {
162    return WebPGetFeaturesInternal(data, data_size, features,
163                                   WEBP_DECODER_ABI_VERSION);
164  }
165  struct WebPDecoderOptions {
166    int bypass_filtering;               
167    int no_fancy_upsampling;            
168    int use_cropping;                   
169    int crop_left, crop_top;            
170    int crop_width, crop_height;        
171    int use_scaling;                    
172    int scaled_width, scaled_height;    
173    int use_threads;                    
174    int dithering_strength;             
175    int flip;                           
176    int alpha_dithering_strength;       
177    uint32_t pad[5];                    
178  };
179  struct WebPDecoderConfig {
180    WebPBitstreamFeatures input;  
181    WebPDecBuffer output;         
182    WebPDecoderOptions options;   
183  };
184  WEBP_EXTERN int WebPInitDecoderConfigInternal(WebPDecoderConfig*, int);
185  static WEBP_INLINE int WebPInitDecoderConfig(WebPDecoderConfig* config) {
186    return WebPInitDecoderConfigInternal(config, WEBP_DECODER_ABI_VERSION);
187  }
188  WEBP_EXTERN WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
189                                        WebPDecoderConfig* config);
190  WEBP_EXTERN VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size,
191                                       WebPDecoderConfig* config);
192  #ifdef __cplusplus
193  }    
194  #endif
195  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct-hc2c-direct.c</h3>
            <pre><code>1  #include "ct-hc2c.h"
2  typedef struct {
3       hc2c_solver super;
4       const hc2c_desc *desc;
5       int bufferedp;
6       khc2c k;
7  } S;
8  typedef struct {
9       plan_hc2c super;
10       khc2c k;
11       plan *cld0, *cldm; &bsol;* children for 0th and middle butterflies */
12       INT r, m, v, extra_iter;
13       INT ms, vs;
14       stride rs, brs;
15       twid *td;
16       const S *slv;
17  } P;
18  static void apply(const plan *ego_, R *cr, R *ci)
19  {
20       const P *ego = (const P *) ego_;
21       plan_rdft2 *cld0 = (plan_rdft2 *) ego->cld0;
22       plan_rdft2 *cldm = (plan_rdft2 *) ego->cldm;
23       INT i, m = ego->m, v = ego->v;
24       INT ms = ego->ms, vs = ego->vs;
25       for (i = 0; i < v; ++i, cr += vs, ci += vs) {
26  	  cld0->apply((plan *) cld0, cr, ci, cr, ci);
27  	  ego->k(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
28  		 ego->td->W, ego->rs, 1, (m+1)/2, ms);
29  	  cldm->apply((plan *) cldm, cr + (m/2)*ms, ci + (m/2)*ms, 
30  		      cr + (m/2)*ms, ci + (m/2)*ms);
31       }
32  }
33  static void apply_extra_iter(const plan *ego_, R *cr, R *ci)
34  {
35       const P *ego = (const P *) ego_;
36       plan_rdft2 *cld0 = (plan_rdft2 *) ego->cld0;
37       plan_rdft2 *cldm = (plan_rdft2 *) ego->cldm;
38       INT i, m = ego->m, v = ego->v;
39       INT ms = ego->ms, vs = ego->vs;
40       INT mm = (m-1)/2;
41       for (i = 0; i < v; ++i, cr += vs, ci += vs) {
42  	  cld0->apply((plan *) cld0, cr, ci, cr, ci);
43  	  ego->k(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
44  		 ego->td->W, ego->rs, 1, mm, ms);
45  	  ego->k(cr + mm*ms, ci + mm*ms, cr + (m-mm)*ms, ci + (m-mm)*ms,
46  		 ego->td->W, ego->rs, mm, mm+2, 0);
47  	  cldm->apply((plan *) cldm, cr + (m/2)*ms, ci + (m/2)*ms, 
48  		      cr + (m/2)*ms, ci + (m/2)*ms);
49       }
50  }
51  static INT compute_batchsize(INT radix)
52  {
53       radix += 3;
54       radix &= -4;
55       return (radix + 2);
56  }
57  static void dobatch(const P *ego, R *Rp, R *Ip, R *Rm, R *Im,
58  		    INT mb, INT me, INT extra_iter, R *bufp)
59  {
60       INT b = WS(ego->brs, 1);
61       INT rs = WS(ego->rs, 1);
62       INT ms = ego->ms;
63       R *bufm = bufp + b - 2;
64       INT n = me - mb;
65       X(cpy2d_pair_ci)(Rp + mb * ms, Ip + mb * ms, bufp, bufp + 1,
66  		      ego->r / 2, rs, b,
67  		      n, ms, 2);
68       X(cpy2d_pair_ci)(Rm - mb * ms, Im - mb * ms, bufm, bufm + 1,
69  		      ego->r / 2, rs, b,
70  		      n, -ms, -2);
71       if (extra_iter) {
72            A(n < compute_batchsize(ego->r));
73            X(zero1d_pair)(bufp + 2*n, bufp + 1 + 2*n, ego->r / 2, b);
74            X(zero1d_pair)(bufm - 2*n, bufm + 1 - 2*n, ego->r / 2, b);
75       }
76       ego->k(bufp, bufp + 1, bufm, bufm + 1, ego->td->W, 
77  	    ego->brs, mb, me + extra_iter, 2);
78       X(cpy2d_pair_co)(bufp, bufp + 1, Rp + mb * ms, Ip + mb * ms, 
79  		      ego->r / 2, b, rs,
80  		      n, 2, ms);
81       X(cpy2d_pair_co)(bufm, bufm + 1, Rm - mb * ms, Im - mb * ms,
82  		      ego->r / 2, b, rs,
83  		      n, -2, -ms);
84  }
85  static void apply_buf(const plan *ego_, R *cr, R *ci)
86  {
87       const P *ego = (const P *) ego_;
88       plan_rdft2 *cld0 = (plan_rdft2 *) ego->cld0;
89       plan_rdft2 *cldm = (plan_rdft2 *) ego->cldm;
90       INT i, j, ms = ego->ms, v = ego->v;
91       INT batchsz = compute_batchsize(ego->r);
92       R *buf;
93       INT mb = 1, me = (ego->m+1) / 2;
94       size_t bufsz = ego->r * batchsz * 2 * sizeof(R);
95       BUF_ALLOC(R *, buf, bufsz);
96       for (i = 0; i < v; ++i, cr += ego->vs, ci += ego->vs) {
97  	  R *Rp = cr;
98  	  R *Ip = ci;
99  	  R *Rm = cr + ego->m * ms;
100  	  R *Im = ci + ego->m * ms;
101  	  cld0->apply((plan *) cld0, Rp, Ip, Rp, Ip);
102  	  for (j = mb; j + batchsz < me; j += batchsz) 
103  	       dobatch(ego, Rp, Ip, Rm, Im, j, j + batchsz, 0, buf);
104  	  dobatch(ego, Rp, Ip, Rm, Im, j, me, ego->extra_iter, buf);
105  	  cldm->apply((plan *) cldm, 
106  		      Rp + me * ms, Ip + me * ms,
107  		      Rp + me * ms, Ip + me * ms);
108       }
109       BUF_FREE(buf, bufsz);
110  }
111  static void awake(plan *ego_, enum wakefulness wakefulness)
112  {
113       P *ego = (P *) ego_;
114       X(plan_awake)(ego->cld0, wakefulness);
115       X(plan_awake)(ego->cldm, wakefulness);
116       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw, 
117  		      ego->r * ego->m, ego->r, 
118  		      (ego->m - 1) / 2 + ego->extra_iter);
119  }
120  static void destroy(plan *ego_)
121  {
122       P *ego = (P *) ego_;
123       X(plan_destroy_internal)(ego->cld0);
124       X(plan_destroy_internal)(ego->cldm);
125       X(stride_destroy)(ego->rs);
126       X(stride_destroy)(ego->brs);
127  }
128  static void print(const plan *ego_, printer *p)
129  {
130       const P *ego = (const P *) ego_;
131       const S *slv = ego->slv;
132       const hc2c_desc *e = slv->desc;
133       if (slv->bufferedp)
134  	  p->print(p, "(hc2c-directbuf/%D-%D/%D/%D%v \"%s\"%(%p%)%(%p%))",
135  		   compute_batchsize(ego->r),
136  		   ego->r, X(twiddle_length)(ego->r, e->tw),
137  		   ego->extra_iter, ego->v, e->nam, 
138  		   ego->cld0, ego->cldm);
139       else
140  	  p->print(p, "(hc2c-direct-%D/%D/%D%v \"%s\"%(%p%)%(%p%))",
141  		   ego->r, X(twiddle_length)(ego->r, e->tw), 
142  		   ego->extra_iter, ego->v, e->nam, 
143  		   ego->cld0, ego->cldm);
144  }
145  static int applicable0(const S *ego, rdft_kind kind,
146  		       INT r, INT rs,
147  		       INT m, INT ms, 
148  		       INT v, INT vs,
149  		       const R *cr, const R *ci,
150  		       const planner *plnr,
151  		       INT *extra_iter)
152  {
153       const hc2c_desc *e = ego->desc;
154       UNUSED(v);
155       return (
156  	  1
157  	  && r == e->radix
158  	  && kind == e->genus->kind
159  	  && ((*extra_iter = 0,
160  	       e->genus->okp(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
161  			     rs, 1, (m+1)/2, ms, plnr))
162                ||
163  	      (*extra_iter = 1,
164  	       ((e->genus->okp(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
165  			       rs, 1, (m-1)/2, ms, plnr))
166  		&&
167  		(e->genus->okp(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
168  			       rs, (m-1)/2, (m-1)/2 + 2, 0, plnr)))))
169  	  && (cr += vs, ci += vs, 1)
170  	  && e->genus->okp(cr + ms, ci + ms, cr + (m-1)*ms, ci + (m-1)*ms,
171  			   rs, 1, (m+1)/2 - *extra_iter, ms, plnr)
172  	  );
173  }
174  static int applicable0_buf(const S *ego, rdft_kind kind,
175  			   INT r, INT rs,
176  			   INT m, INT ms, 
177  			   INT v, INT vs,
178  			   const R *cr, const R *ci,
179  			   const planner *plnr, INT *extra_iter)
180  {
181       const hc2c_desc *e = ego->desc;
182       INT batchsz, brs;
183       UNUSED(v); UNUSED(rs); UNUSED(ms); UNUSED(vs);
184       return (
185  	  1
186  	  && r == e->radix
187  	  && kind == e->genus->kind
188  	  && (cr = (const R *)0, ci = cr + 1, 
189  	      batchsz = compute_batchsize(r), 
190  	      brs = 4 * batchsz, 1)
191  	  && e->genus->okp(cr, ci, cr + brs - 2, ci + brs - 2, 
192  			   brs, 1, 1+batchsz, 2, plnr)
193  	  && ((*extra_iter = 0,
194  	       e->genus->okp(cr, ci, cr + brs - 2, ci + brs - 2, 
195  			     brs, 1, 1 + (((m-1)/2) % batchsz), 2, plnr))
196  	      ||
197  	      (*extra_iter = 1,
198  	       e->genus->okp(cr, ci, cr + brs - 2, ci + brs - 2, 
199  			     brs, 1, 1 + 1 + (((m-1)/2) % batchsz), 2, plnr)))
200  	  );
201  }
202  static int applicable(const S *ego, rdft_kind kind,
203  		      INT r, INT rs,
204  		      INT m, INT ms, 
205  		      INT v, INT vs,
206  		      R *cr, R *ci,
207  		      const planner *plnr, INT *extra_iter)
208  {
209       if (ego->bufferedp) {
210  	  if (!applicable0_buf(ego, kind, r, rs, m, ms, v, vs, cr, ci, plnr,
211  			       extra_iter))
212  	       return 0;
213       } else {
214  	  if (!applicable0(ego, kind, r, rs, m, ms, v, vs, cr, ci, plnr,
215  			   extra_iter))
216  	       return 0;
217       }
218       if (NO_UGLYP(plnr) && X(ct_uglyp)((ego->bufferedp? (INT)512 : (INT)16),
219  				       v, m * r, r))
220  	  return 0;
221       return 1;
222  }
223  static plan *mkcldw(const hc2c_solver *ego_, rdft_kind kind,
224  		    INT r, INT rs,
225  		    INT m, INT ms, 
226  		    INT v, INT vs,
227  		    R *cr, R *ci,
228  		    planner *plnr)
229  {
230       const S *ego = (const S *) ego_;
231       P *pln;
232       const hc2c_desc *e = ego->desc;
233       plan *cld0 = 0, *cldm = 0;
234       INT imid = (m / 2) * ms;
235       INT extra_iter;
236       static const plan_adt padt = {
237  	  0, awake, print, destroy
238       };
239       if (!applicable(ego, kind, r, rs, m, ms, v, vs, cr, ci, plnr, 
240  		     &extra_iter))
241            return (plan *)0;
242       cld0 = X(mkplan_d)(
243  	  plnr, 
244  	  X(mkproblem_rdft2_d)(X(mktensor_1d)(r, rs, rs),
245  			       X(mktensor_0d)(),
246  			       TAINT(cr, vs), TAINT(ci, vs),
247  			       TAINT(cr, vs), TAINT(ci, vs),
248  			       kind));
249       if (!cld0) goto nada;
250       cldm = X(mkplan_d)(
251  	  plnr, 
252  	  X(mkproblem_rdft2_d)(((m % 2) ?
253  				X(mktensor_0d)() : X(mktensor_1d)(r, rs, rs) ),
254  			       X(mktensor_0d)(),
255  			       TAINT(cr + imid, vs), TAINT(ci + imid, vs),
256  			       TAINT(cr + imid, vs), TAINT(ci + imid, vs),
257  			       kind == R2HC ? R2HCII : HC2RIII));
258       if (!cldm) goto nada;
259       if (ego->bufferedp)
260  	  pln = MKPLAN_HC2C(P, &padt, apply_buf);
261       else
262  	  pln = MKPLAN_HC2C(P, &padt, extra_iter ? apply_extra_iter : apply);
<span onclick='openModal()' class='match'>263       pln->k = ego->k;
264       pln->td = 0;
265       pln->r = r; pln->rs = X(mkstride)(r, rs);
266       pln->m = m; pln->ms = ms;
267       pln->v = v; pln->vs = vs;
268       pln->slv = ego;
269       pln->brs = X(mkstride)(r, 4 * compute_batchsize(r));
270       pln->cld0 = cld0;
271       pln->cldm = cldm;
272       pln->extra_iter = extra_iter;
</span>273       X(ops_zero)(&pln->super.super.ops);
274       X(ops_madd2)(v * (((m - 1) / 2) / e->genus->vl),
275  		  &e->ops, &pln->super.super.ops);
276       X(ops_madd2)(v, &cld0->ops, &pln->super.super.ops);
277       X(ops_madd2)(v, &cldm->ops, &pln->super.super.ops);
278       if (ego->bufferedp) 
279  	  pln->super.super.ops.other += 4 * r * m * v;
280       return &(pln->super.super);
281   nada:
282       X(plan_destroy_internal)(cld0);
283       X(plan_destroy_internal)(cldm);
284       return 0;
285  }
286  static void regone(planner *plnr, khc2c codelet,
287  		   const hc2c_desc *desc, 
288  		   hc2c_kind hc2ckind, 
289  		   int bufferedp)
290  {
291       S *slv = (S *)X(mksolver_hc2c)(sizeof(S), desc->radix, hc2ckind, mkcldw);
292       slv->k = codelet;
293       slv->desc = desc;
294       slv->bufferedp = bufferedp;
295       REGISTER_SOLVER(plnr, &(slv->super.super));
296  }
297  void X(regsolver_hc2c_direct)(planner *plnr, khc2c codelet,
298  			      const hc2c_desc *desc,
299  			      hc2c_kind hc2ckind)
300  {
301       regone(plnr, codelet, desc, hc2ckind, &bsol;* bufferedp */0);
302       regone(plnr, codelet, desc, hc2ckind, &bsol;* bufferedp */1);
303  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-decode_39.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct-hc2c-direct.c</div>
                </div>
                <div class="column column_space"><pre><code>53    MODE_RGB = 0, MODE_RGBA = 1,
54    MODE_BGR = 2, MODE_BGRA = 3,
55    MODE_ARGB = 4, MODE_RGBA_4444 = 5,
56    MODE_RGB_565 = 6,
57    MODE_rgbA = 7,
58    MODE_bgrA = 8,
59    MODE_Argb = 9,
60    MODE_rgbA_4444 = 10,
61    MODE_YUV = 11, MODE_YUVA = 12,  
</pre></code></div>
                <div class="column column_space"><pre><code>263       pln->k = ego->k;
264       pln->td = 0;
265       pln->r = r; pln->rs = X(mkstride)(r, rs);
266       pln->m = m; pln->ms = ms;
267       pln->v = v; pln->vs = vs;
268       pln->slv = ego;
269       pln->brs = X(mkstride)(r, 4 * compute_batchsize(r));
270       pln->cld0 = cld0;
271       pln->cldm = cldm;
272       pln->extra_iter = extra_iter;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    