
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.297297297297296%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_psnr_enc.c</h3>
            <pre><code>1  #include "src/webp/encode.h"
2  #if !(defined(WEBP_DISABLE_STATS) || defined(WEBP_REDUCE_SIZE))
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dsp/dsp.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/utils/utils.h"
8  typedef double (*AccumulateFunc)(const uint8_t* src, int src_stride,
9                                   const uint8_t* ref, int ref_stride,
10                                   int w, int h);
11  #define RADIUS 2  
12  static double AccumulateLSIM(const uint8_t* src, int src_stride,
13                               const uint8_t* ref, int ref_stride,
14                               int w, int h) {
15    int x, y;
16    double total_sse = 0.;
17    for (y = 0; y < h; ++y) {
18      const int y_0 = (y - RADIUS < 0) ? 0 : y - RADIUS;
19      const int y_1 = (y + RADIUS + 1 >= h) ? h : y + RADIUS + 1;
20      for (x = 0; x < w; ++x) {
21        const int x_0 = (x - RADIUS < 0) ? 0 : x - RADIUS;
22        const int x_1 = (x + RADIUS + 1 >= w) ? w : x + RADIUS + 1;
23        double best_sse = 255. * 255.;
24        const double value = (double)ref[y * ref_stride + x];
25        int i, j;
26        for (j = y_0; j < y_1; ++j) {
27          const uint8_t* const s = src + j * src_stride;
28          for (i = x_0; i < x_1; ++i) {
29            const double diff = s[i] - value;
30            const double sse = diff * diff;
31            if (sse < best_sse) best_sse = sse;
32          }
33        }
34        total_sse += best_sse;
35      }
36    }
37    return total_sse;
38  }
39  #undef RADIUS
40  static double AccumulateSSE(const uint8_t* src, int src_stride,
41                              const uint8_t* ref, int ref_stride,
42                              int w, int h) {
43    int y;
44    double total_sse = 0.;
45    for (y = 0; y < h; ++y) {
46      total_sse += VP8AccumulateSSE(src, ref, w);
47      src += src_stride;
48      ref += ref_stride;
49    }
50    return total_sse;
51  }
52  static double AccumulateSSIM(const uint8_t* src, int src_stride,
53                               const uint8_t* ref, int ref_stride,
54                               int w, int h) {
55    const int w0 = (w < VP8_SSIM_KERNEL) ? w : VP8_SSIM_KERNEL;
56    const int w1 = w - VP8_SSIM_KERNEL - 1;
57    const int h0 = (h < VP8_SSIM_KERNEL) ? h : VP8_SSIM_KERNEL;
58    const int h1 = h - VP8_SSIM_KERNEL - 1;
59    int x, y;
60    double sum = 0.;
61    for (y = 0; y < h0; ++y) {
62      for (x = 0; x < w; ++x) {
63        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
64      }
65    }
66    for (; y < h1; ++y) {
67      for (x = 0; x < w0; ++x) {
68        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
69      }
70      for (; x < w1; ++x) {
71        const int off1 = x - VP8_SSIM_KERNEL + (y - VP8_SSIM_KERNEL) * src_stride;
72        const int off2 = x - VP8_SSIM_KERNEL + (y - VP8_SSIM_KERNEL) * ref_stride;
73        sum += VP8SSIMGet(src + off1, src_stride, ref + off2, ref_stride);
74      }
75      for (; x < w; ++x) {
76        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
77      }
78    }
79    for (; y < h; ++y) {
80      for (x = 0; x < w; ++x) {
<span onclick='openModal()' class='match'>81        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
82      }
83    }
84    return sum;
85  }
86  static const double kMinDistortion_dB = 99.;
</span>87  static double GetPSNR(double v, double size) {
88    return (v > 0. && size > 0.) ? -4.3429448 * log(v / (size * 255 * 255.))
89                                 : kMinDistortion_dB;
90  }
91  static double GetLogSSIM(double v, double size) {
92    v = (size > 0.) ? v / size : 1.;
93    return (v < 1.) ? -10.0 * log10(1. - v) : kMinDistortion_dB;
94  }
95  int WebPPlaneDistortion(const uint8_t* src, size_t src_stride,
96                          const uint8_t* ref, size_t ref_stride,
97                          int width, int height, size_t x_step,
98                          int type, float* distortion, float* result) {
99    uint8_t* allocated = NULL;
100    const AccumulateFunc metric = (type == 0) ? AccumulateSSE :
101                                  (type == 1) ? AccumulateSSIM :
102                                                AccumulateLSIM;
103    if (src == NULL || ref == NULL ||
104        src_stride < x_step * width || ref_stride < x_step * width ||
105        result == NULL || distortion == NULL) {
106      return 0;
107    }
108    VP8SSIMDspInit();
109    if (x_step != 1) {   
110      int x, y;
111      uint8_t* tmp1;
112      uint8_t* tmp2;
113      allocated =
114          (uint8_t*)WebPSafeMalloc(2ULL * width * height, sizeof(*allocated));
115      if (allocated == NULL) return 0;
116      tmp1 = allocated;
117      tmp2 = tmp1 + (size_t)width * height;
118      for (y = 0; y < height; ++y) {
119        for (x = 0; x < width; ++x) {
120          tmp1[x + y * width] = src[x * x_step + y * src_stride];
121          tmp2[x + y * width] = ref[x * x_step + y * ref_stride];
122        }
123      }
124      src = tmp1;
125      ref = tmp2;
126    }
127    *distortion = (float)metric(src, width, ref, width, width, height);
128    WebPSafeFree(allocated);
129    *result = (type == 1) ? (float)GetLogSSIM(*distortion, (double)width * height)
130                          : (float)GetPSNR(*distortion, (double)width * height);
131    return 1;
132  }
133  #ifdef WORDS_BIGENDIAN
134  #define BLUE_OFFSET 3   
135  #else
136  #define BLUE_OFFSET 0   
137  #endif
138  int WebPPictureDistortion(const WebPPicture* src, const WebPPicture* ref,
139                            int type, float results[5]) {
140    int w, h, c;
141    int ok = 0;
142    WebPPicture p0, p1;
143    double total_size = 0., total_distortion = 0.;
144    if (src == NULL || ref == NULL ||
145        src->width != ref->width || src->height != ref->height ||
146        results == NULL) {
147      return 0;
148    }
149    VP8SSIMDspInit();
150    if (!WebPPictureInit(&p0) || !WebPPictureInit(&p1)) return 0;
151    w = src->width;
152    h = src->height;
153    if (!WebPPictureView(src, 0, 0, w, h, &p0)) goto Error;
154    if (!WebPPictureView(ref, 0, 0, w, h, &p1)) goto Error;
155    if (p0.use_argb == 0 && !WebPPictureYUVAToARGB(&p0)) goto Error;
156    if (p1.use_argb == 0 && !WebPPictureYUVAToARGB(&p1)) goto Error;
157    for (c = 0; c < 4; ++c) {
158      float distortion;
159      const size_t stride0 = 4 * (size_t)p0.argb_stride;
160      const size_t stride1 = 4 * (size_t)p1.argb_stride;
161      const int offset = c ^ BLUE_OFFSET;
162      if (!WebPPlaneDistortion((const uint8_t*)p0.argb + offset, stride0,
163                               (const uint8_t*)p1.argb + offset, stride1,
164                               w, h, 4, type, &distortion, results + c)) {
165        goto Error;
166      }
167      total_distortion += distortion;
168      total_size += w * h;
169    }
170    results[4] = (type == 1) ? (float)GetLogSSIM(total_distortion, total_size)
171                             : (float)GetPSNR(total_distortion, total_size);
172    ok = 1;
173   Error:
174    WebPPictureFree(&p0);
175    WebPPictureFree(&p1);
176    return ok;
177  }
178  #undef BLUE_OFFSET
179  #else  
180  int WebPPlaneDistortion(const uint8_t* src, size_t src_stride,
181                          const uint8_t* ref, size_t ref_stride,
182                          int width, int height, size_t x_step,
183                          int type, float* distortion, float* result) {
184    (void)src;
185    (void)src_stride;
186    (void)ref;
187    (void)ref_stride;
188    (void)width;
189    (void)height;
190    (void)x_step;
191    (void)type;
192    if (distortion == NULL || result == NULL) return 0;
193    *distortion = 0.f;
194    *result = 0.f;
195    return 1;
196  }
197  int WebPPictureDistortion(const WebPPicture* src, const WebPPicture* ref,
198                            int type, float results[5]) {
199    int i;
200    (void)src;
201    (void)ref;
202    (void)type;
203    if (results == NULL) return 0;
204    for (i = 0; i < 5; ++i) results[i] = 0.f;
205    return 1;
206  }
207  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-analysis_enc.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <assert.h>
4  #include "src/enc/vp8i_enc.h"
5  #include "src/enc/cost_enc.h"
6  #include "src/utils/utils.h"
7  #define MAX_ITERS_K_MEANS  6
8  static void SmoothSegmentMap(VP8Encoder* const enc) {
9    int n, x, y;
10    const int w = enc->mb_w_;
11    const int h = enc->mb_h_;
12    const int majority_cnt_3_x_3_grid = 5;
13    uint8_t* const tmp = (uint8_t*)WebPSafeMalloc(w * h, sizeof(*tmp));
14    assert((uint64_t)(w * h) == (uint64_t)w * h);   
15    if (tmp == NULL) return;
16    for (y = 1; y < h - 1; ++y) {
17      for (x = 1; x < w - 1; ++x) {
18        int cnt[NUM_MB_SEGMENTS] = { 0 };
19        const VP8MBInfo* const mb = &enc->mb_info_[x + w * y];
20        int majority_seg = mb->segment_;
21        cnt[mb[-w - 1].segment_]++;  
22        cnt[mb[-w + 0].segment_]++;  
23        cnt[mb[-w + 1].segment_]++;  
24        cnt[mb[   - 1].segment_]++;  
25        cnt[mb[   + 1].segment_]++;  
26        cnt[mb[ w - 1].segment_]++;  
27        cnt[mb[ w + 0].segment_]++;  
28        cnt[mb[ w + 1].segment_]++;  
29        for (n = 0; n < NUM_MB_SEGMENTS; ++n) {
30          if (cnt[n] >= majority_cnt_3_x_3_grid) {
31            majority_seg = n;
32            break;
33          }
34        }
35        tmp[x + y * w] = majority_seg;
36      }
37    }
38    for (y = 1; y < h - 1; ++y) {
39      for (x = 1; x < w - 1; ++x) {
40        VP8MBInfo* const mb = &enc->mb_info_[x + w * y];
41        mb->segment_ = tmp[x + y * w];
42      }
43    }
44    WebPSafeFree(tmp);
45  }
46  static WEBP_INLINE int clip(int v, int m, int M) {
47    return (v < m) ? m : (v > M) ? M : v;
48  }
49  static void SetSegmentAlphas(VP8Encoder* const enc,
50                               const int centers[NUM_MB_SEGMENTS],
51                               int mid) {
52    const int nb = enc->segment_hdr_.num_segments_;
53    int min = centers[0], max = centers[0];
54    int n;
55    if (nb > 1) {
56      for (n = 0; n < nb; ++n) {
57        if (min > centers[n]) min = centers[n];
58        if (max < centers[n]) max = centers[n];
59      }
60    }
61    if (max == min) max = min + 1;
62    assert(mid <= max && mid >= min);
63    for (n = 0; n < nb; ++n) {
64      const int alpha = 255 * (centers[n] - mid) / (max - min);
65      const int beta = 255 * (centers[n] - min) / (max - min);
66      enc->dqm_[n].alpha_ = clip(alpha, -127, 127);
67      enc->dqm_[n].beta_ = clip(beta, 0, 255);
68    }
69  }
70  #define MAX_ALPHA 255                
71  #define ALPHA_SCALE (2 * MAX_ALPHA)  
72  #define DEFAULT_ALPHA (-1)
73  #define IS_BETTER_ALPHA(alpha, best_alpha) ((alpha) > (best_alpha))
74  static int FinalAlphaValue(int alpha) {
75    alpha = MAX_ALPHA - alpha;
76    return clip(alpha, 0, MAX_ALPHA);
77  }
78  static int GetAlpha(const VP8Histogram* const histo) {
79    const int max_value = histo->max_value;
80    const int last_non_zero = histo->last_non_zero;
81    const int alpha =
82        (max_value > 1) ? ALPHA_SCALE * last_non_zero / max_value : 0;
83    return alpha;
84  }
85  static void InitHistogram(VP8Histogram* const histo) {
86    histo->max_value = 0;
87    histo->last_non_zero = 1;
88  }
89  static void MergeHistograms(const VP8Histogram* const in,
90                              VP8Histogram* const out) {
91    if (in->max_value > out->max_value) {
92      out->max_value = in->max_value;
93    }
94    if (in->last_non_zero > out->last_non_zero) {
95      out->last_non_zero = in->last_non_zero;
96    }
97  }
98  static void AssignSegments(VP8Encoder* const enc,
99                             const int alphas[MAX_ALPHA + 1]) {
100    const int nb = (enc->segment_hdr_.num_segments_ < NUM_MB_SEGMENTS) ?
101                   enc->segment_hdr_.num_segments_ : NUM_MB_SEGMENTS;
102    int centers[NUM_MB_SEGMENTS];
103    int weighted_average = 0;
104    int map[MAX_ALPHA + 1];
105    int a, n, k;
106    int min_a = 0, max_a = MAX_ALPHA, range_a;
107    int accum[NUM_MB_SEGMENTS], dist_accum[NUM_MB_SEGMENTS];
108    assert(nb >= 1);
109    assert(nb <= NUM_MB_SEGMENTS);
110    for (n = 0; n <= MAX_ALPHA && alphas[n] == 0; ++n) {}
111    min_a = n;
112    for (n = MAX_ALPHA; n > min_a && alphas[n] == 0; --n) {}
113    max_a = n;
114    range_a = max_a - min_a;
115    for (k = 0, n = 1; k < nb; ++k, n += 2) {
116      assert(n < 2 * nb);
117      centers[k] = min_a + (n * range_a) / (2 * nb);
118    }
119    for (k = 0; k < MAX_ITERS_K_MEANS; ++k) {     
120      int total_weight;
121      int displaced;
122      for (n = 0; n < nb; ++n) {
123        accum[n] = 0;
124        dist_accum[n] = 0;
125      }
126      n = 0;    
127      for (a = min_a; a <= max_a; ++a) {
128        if (alphas[a]) {
129          while (n + 1 < nb && abs(a - centers[n + 1]) < abs(a - centers[n])) {
130            n++;
131          }
132          map[a] = n;
133          dist_accum[n] += a * alphas[a];
134          accum[n] += alphas[a];
135        }
136      }
137      displaced = 0;
138      weighted_average = 0;
139      total_weight = 0;
140      for (n = 0; n < nb; ++n) {
141        if (accum[n]) {
142          const int new_center = (dist_accum[n] + accum[n] / 2) / accum[n];
143          displaced += abs(centers[n] - new_center);
144          centers[n] = new_center;
145          weighted_average += new_center * accum[n];
146          total_weight += accum[n];
147        }
148      }
149      weighted_average = (weighted_average + total_weight / 2) / total_weight;
150      if (displaced < 5) break;   
151    }
152    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
153      VP8MBInfo* const mb = &enc->mb_info_[n];
154      const int alpha = mb->alpha_;
155      mb->segment_ = map[alpha];
156      mb->alpha_ = centers[map[alpha]];  
157    }
158    if (nb > 1) {
159      const int smooth = (enc->config_->preprocessing & 1);
160      if (smooth) SmoothSegmentMap(enc);
161    }
162    SetSegmentAlphas(enc, centers, weighted_average);  
163  }
164  #define MAX_INTRA16_MODE 2
165  #define MAX_INTRA4_MODE  2
166  #define MAX_UV_MODE      2
167  static int MBAnalyzeBestIntra16Mode(VP8EncIterator* const it) {
168    const int max_mode = MAX_INTRA16_MODE;
169    int mode;
170    int best_alpha = DEFAULT_ALPHA;
171    int best_mode = 0;
172    VP8MakeLuma16Preds(it);
173    for (mode = 0; mode < max_mode; ++mode) {
174      VP8Histogram histo;
175      int alpha;
176      InitHistogram(&histo);
177      VP8CollectHistogram(it->yuv_in_ + Y_OFF_ENC,
178                          it->yuv_p_ + VP8I16ModeOffsets[mode],
179                          0, 16, &histo);
180      alpha = GetAlpha(&histo);
181      if (IS_BETTER_ALPHA(alpha, best_alpha)) {
182        best_alpha = alpha;
183        best_mode = mode;
184      }
185    }
186    VP8SetIntra16Mode(it, best_mode);
187    return best_alpha;
188  }
189  static int FastMBAnalyze(VP8EncIterator* const it) {
190    const int q = (int)it->enc_->config_->quality;
191    const uint32_t kThreshold = 8 + (17 - 8) * q / 100;
192    int k;
193    uint32_t dc[16], m, m2;
194    for (k = 0; k < 16; k += 4) {
195      VP8Mean16x4(it->yuv_in_ + Y_OFF_ENC + k * BPS, &dc[k]);
196    }
197    for (m = 0, m2 = 0, k = 0; k < 16; ++k) {
198      m += dc[k];
199      m2 += dc[k] * dc[k];
200    }
201    if (kThreshold * m2 < m * m) {
202      VP8SetIntra16Mode(it, 0);   
203    } else {
204      const uint8_t modes[16] = { 0 };  
205      VP8SetIntra4Mode(it, modes);
206    }
207    return 0;
208  }
209  static int MBAnalyzeBestIntra4Mode(VP8EncIterator* const it,
210                                     int best_alpha) {
211    uint8_t modes[16];
212    const int max_mode = MAX_INTRA4_MODE;
213    int i4_alpha;
214    VP8Histogram total_histo;
215    int cur_histo = 0;
216    InitHistogram(&total_histo);
217    VP8IteratorStartI4(it);
218    do {
219      int mode;
220      int best_mode_alpha = DEFAULT_ALPHA;
221      VP8Histogram histos[2];
222      const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
223      VP8MakeIntra4Preds(it);
224      for (mode = 0; mode < max_mode; ++mode) {
225        int alpha;
226        InitHistogram(&histos[cur_histo]);
227        VP8CollectHistogram(src, it->yuv_p_ + VP8I4ModeOffsets[mode],
228                            0, 1, &histos[cur_histo]);
229        alpha = GetAlpha(&histos[cur_histo]);
230        if (IS_BETTER_ALPHA(alpha, best_mode_alpha)) {
231          best_mode_alpha = alpha;
232          modes[it->i4_] = mode;
233          cur_histo ^= 1;   
234        }
235      }
236      MergeHistograms(&histos[cur_histo ^ 1], &total_histo);
237    } while (VP8IteratorRotateI4(it, it->yuv_in_ + Y_OFF_ENC));
238    i4_alpha = GetAlpha(&total_histo);
239    if (IS_BETTER_ALPHA(i4_alpha, best_alpha)) {
240      VP8SetIntra4Mode(it, modes);
241      best_alpha = i4_alpha;
242    }
243    return best_alpha;
244  }
245  static int MBAnalyzeBestUVMode(VP8EncIterator* const it) {
246    int best_alpha = DEFAULT_ALPHA;
247    int smallest_alpha = 0;
248    int best_mode = 0;
249    const int max_mode = MAX_UV_MODE;
250    int mode;
251    VP8MakeChroma8Preds(it);
252    for (mode = 0; mode < max_mode; ++mode) {
253      VP8Histogram histo;
254      int alpha;
255      InitHistogram(&histo);
256      VP8CollectHistogram(it->yuv_in_ + U_OFF_ENC,
257                          it->yuv_p_ + VP8UVModeOffsets[mode],
258                          16, 16 + 4 + 4, &histo);
259      alpha = GetAlpha(&histo);
260      if (IS_BETTER_ALPHA(alpha, best_alpha)) {
261        best_alpha = alpha;
262      }
263      if (mode == 0 || alpha < smallest_alpha) {
264        smallest_alpha = alpha;
<span onclick='openModal()' class='match'>265        best_mode = mode;
266      }
267    }
268    VP8SetIntraUVMode(it, best_mode);
269    return best_alpha;
270  }
271  static void MBAnalyze(VP8EncIterator* const it,
272                        int alphas[MAX_ALPHA + 1],
</span>273                        int* const alpha, int* const uv_alpha) {
274    const VP8Encoder* const enc = it->enc_;
275    int best_alpha, best_uv_alpha;
276    VP8SetIntra16Mode(it, 0);  
277    VP8SetSkip(it, 0);         
278    VP8SetSegment(it, 0);      
279    if (enc->method_ <= 1) {
280      best_alpha = FastMBAnalyze(it);
281    } else {
282      best_alpha = MBAnalyzeBestIntra16Mode(it);
283      if (enc->method_ >= 5) {
284        best_alpha = MBAnalyzeBestIntra4Mode(it, best_alpha);
285      }
286    }
287    best_uv_alpha = MBAnalyzeBestUVMode(it);
288    best_alpha = (3 * best_alpha + best_uv_alpha + 2) >> 2;
289    best_alpha = FinalAlphaValue(best_alpha);
290    alphas[best_alpha]++;
291    it->mb_->alpha_ = best_alpha;   
292    *alpha += best_alpha;   
293    *uv_alpha += best_uv_alpha;
294  }
295  static void DefaultMBInfo(VP8MBInfo* const mb) {
296    mb->type_ = 1;     
297    mb->uv_mode_ = 0;
298    mb->skip_ = 0;     
299    mb->segment_ = 0;  
300    mb->alpha_ = 0;
301  }
302  static void ResetAllMBInfo(VP8Encoder* const enc) {
303    int n;
304    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
305      DefaultMBInfo(&enc->mb_info_[n]);
306    }
307    enc->dqm_[0].alpha_ = 0;
308    enc->dqm_[0].beta_ = 0;
309    enc->alpha_ = 0;
310    enc->uv_alpha_ = 0;
311    WebPReportProgress(enc->pic_, enc->percent_ + 20, &enc->percent_);
312  }
313  typedef struct {
314    WebPWorker worker;
315    int alphas[MAX_ALPHA + 1];
316    int alpha, uv_alpha;
317    VP8EncIterator it;
318    int delta_progress;
319  } SegmentJob;
320  static int DoSegmentsJob(void* arg1, void* arg2) {
321    SegmentJob* const job = (SegmentJob*)arg1;
322    VP8EncIterator* const it = (VP8EncIterator*)arg2;
323    int ok = 1;
324    if (!VP8IteratorIsDone(it)) {
325      uint8_t tmp[32 + WEBP_ALIGN_CST];
326      uint8_t* const scratch = (uint8_t*)WEBP_ALIGN(tmp);
327      do {
328        VP8IteratorImport(it, scratch);
329        MBAnalyze(it, job->alphas, &job->alpha, &job->uv_alpha);
330        ok = VP8IteratorProgress(it, job->delta_progress);
331      } while (ok && VP8IteratorNext(it));
332    }
333    return ok;
334  }
335  static void MergeJobs(const SegmentJob* const src, SegmentJob* const dst) {
336    int i;
337    for (i = 0; i <= MAX_ALPHA; ++i) dst->alphas[i] += src->alphas[i];
338    dst->alpha += src->alpha;
339    dst->uv_alpha += src->uv_alpha;
340  }
341  static void InitSegmentJob(VP8Encoder* const enc, SegmentJob* const job,
342                             int start_row, int end_row) {
343    WebPGetWorkerInterface()->Init(&job->worker);
344    job->worker.data1 = job;
345    job->worker.data2 = &job->it;
346    job->worker.hook = DoSegmentsJob;
347    VP8IteratorInit(enc, &job->it);
348    VP8IteratorSetRow(&job->it, start_row);
349    VP8IteratorSetCountDown(&job->it, (end_row - start_row) * enc->mb_w_);
350    memset(job->alphas, 0, sizeof(job->alphas));
351    job->alpha = 0;
352    job->uv_alpha = 0;
353    job->delta_progress = (start_row == 0) ? 20 : 0;
354  }
355  int VP8EncAnalyze(VP8Encoder* const enc) {
356    int ok = 1;
357    const int do_segments =
358        enc->config_->emulate_jpeg_size ||   
359        (enc->segment_hdr_.num_segments_ > 1) ||
360        (enc->method_ <= 1);  
361    if (do_segments) {
362      const int last_row = enc->mb_h_;
363      const int split_row = (9 * last_row + 15) >> 4;
364      const int total_mb = last_row * enc->mb_w_;
365  #ifdef WEBP_USE_THREAD
366      const int kMinSplitRow = 2;  
367      const int do_mt = (enc->thread_level_ > 0) && (split_row >= kMinSplitRow);
368  #else
369      const int do_mt = 0;
370  #endif
371      const WebPWorkerInterface* const worker_interface =
372          WebPGetWorkerInterface();
373      SegmentJob main_job;
374      if (do_mt) {
375        SegmentJob side_job;
376        InitSegmentJob(enc, &main_job, 0, split_row);
377        InitSegmentJob(enc, &side_job, split_row, last_row);
378        ok &= worker_interface->Reset(&side_job.worker);
379        if (ok) {
380          worker_interface->Launch(&side_job.worker);
381          worker_interface->Execute(&main_job.worker);
382          ok &= worker_interface->Sync(&side_job.worker);
383          ok &= worker_interface->Sync(&main_job.worker);
384        }
385        worker_interface->End(&side_job.worker);
386        if (ok) MergeJobs(&side_job, &main_job);  
387      } else {
388        InitSegmentJob(enc, &main_job, 0, last_row);
389        worker_interface->Execute(&main_job.worker);
390        ok &= worker_interface->Sync(&main_job.worker);
391      }
392      worker_interface->End(&main_job.worker);
393      if (ok) {
394        enc->alpha_ = main_job.alpha / total_mb;
395        enc->uv_alpha_ = main_job.uv_alpha / total_mb;
396        AssignSegments(enc, main_job.alphas);
397      }
398    } else {   
399      ResetAllMBInfo(enc);
400    }
401    return ok;
402  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_psnr_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-analysis_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>81        sum += VP8SSIMGetClipped(src, src_stride, ref, ref_stride, x, y, w, h);
82      }
83    }
84    return sum;
85  }
86  static const double kMinDistortion_dB = 99.;
</pre></code></div>
                <div class="column column_space"><pre><code>265        best_mode = mode;
266      }
267    }
268    VP8SetIntraUVMode(it, best_mode);
269    return best_alpha;
270  }
271  static void MBAnalyze(VP8EncIterator* const it,
272                        int alphas[MAX_ALPHA + 1],
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    