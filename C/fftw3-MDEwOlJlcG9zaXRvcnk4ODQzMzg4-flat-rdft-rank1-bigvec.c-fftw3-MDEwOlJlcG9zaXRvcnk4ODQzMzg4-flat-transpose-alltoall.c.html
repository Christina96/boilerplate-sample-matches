
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 50.314465408805034%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank1-bigvec.c</h3>
            <pre><code>1  #include "mpi-rdft.h"
2  #include "mpi-transpose.h"
3  typedef struct {
4       solver super;
5       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
6       rearrangement rearrange;
7  } S;
8  typedef struct {
9       plan_mpi_rdft super;
10       plan *cldt_before, *cld, *cldt_after;
11       int preserve_input;
12       rearrangement rearrange;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       plan_rdft *cld, *cldt_before, *cldt_after;
18       cldt_before = (plan_rdft *) ego->cldt_before;
19       cldt_before->apply(ego->cldt_before, I, O);
20       if (ego->preserve_input) I = O;
21       cld = (plan_rdft *) ego->cld;
22       cld->apply(ego->cld, O, I);
23       cldt_after = (plan_rdft *) ego->cldt_after;
24       cldt_after->apply(ego->cldt_after, I, O);
25  }
26  static int applicable(const S *ego, const problem *p_,
27  		      const planner *plnr)
28  {
29       const problem_mpi_rdft *p = (const problem_mpi_rdft *) p_;
30       int n_pes;
31       MPI_Comm_size(p->comm, &n_pes);
32       return (1
33  	     && p->sz->rnk == 1
34  	     && !(p->flags & ~RANK1_BIGVEC_ONLY)
35  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
36  					  && p->I != p->O))
37  #if 0 &bsol;* don't need this check since no other rank-1 rdft solver */
38  	     && (p->vn >= n_pes &bsol;* TODO: relax this, using more memory? */
39  		 || (p->flags & RANK1_BIGVEC_ONLY))
40  #endif
41  	     && XM(rearrange_applicable)(ego->rearrange,
42  					 p->sz->dims[0], p->vn, n_pes)
43  	     && (!NO_SLOWP(plnr) &bsol;* slow if rdft-serial is applicable */
44                   || !XM(rdft_serial_applicable)(p))
45  	  );
<span onclick='openModal()' class='match'>46  }
47  static void awake(plan *ego_, enum wakefulness wakefulness)
48  {
49       P *ego = (P *) ego_;
50       X(plan_awake)(ego->cldt_before, wakefulness);
51       X(plan_awake)(ego->cld, wakefulness);
52       X(plan_awake)(ego->cldt_after, wakefulness);
53  }
54  static void destroy(plan *ego_)
55  {
56       P *ego = (P *) ego_;
57       X(plan_destroy_internal)(ego->cldt_after);
58       X(plan_destroy_internal)(ego->cld);
59       X(plan_destroy_internal)(ego->cldt_before);
60  }
61  static void print(const plan *ego_, printer *p)
62  {
63       const P *ego = (const P *) ego_;
</span>64       const char descrip[][16] = { "contig", "discontig", "square-after",
65  				  "square-middle", "square-before" };
66       p->print(p, "(mpi-rdft-rank1-bigvec/%s%s %(%p%) %(%p%) %(%p%))",
67  	      descrip[ego->rearrange], ego->preserve_input==2 ?"/p":"",
68  	      ego->cldt_before, ego->cld, ego->cldt_after);
69  }
70  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
71  {
72       const S *ego = (const S *) ego_;
73       const problem_mpi_rdft *p;
74       P *pln;
75       plan *cld = 0, *cldt_before = 0, *cldt_after = 0;
76       R *I, *O;
77       INT yblock, yb, nx, ny, vn;
78       int my_pe, n_pes;
79       static const plan_adt padt = {
80            XM(rdft_solve), awake, print, destroy
81       };
82       UNUSED(ego);
83       if (!applicable(ego, p_, plnr))
84            return (plan *) 0;
85       p = (const problem_mpi_rdft *) p_;
86       MPI_Comm_rank(p->comm, &my_pe);
87       MPI_Comm_size(p->comm, &n_pes);
88       nx = p->sz->dims[0].n;
89       if (!(ny = XM(rearrange_ny)(ego->rearrange, p->sz->dims[0],p->vn,n_pes)))
90  	  return (plan *) 0;
91       vn = p->vn / ny;
92       A(ny * vn == p->vn);
93       yblock = XM(default_block)(ny, n_pes);
94       cldt_before = X(mkplan_d)(plnr,
95  			       XM(mkproblem_transpose)(
96  				    nx, ny, vn,
97  				    I = p->I, O = p->O,
98  				    p->sz->dims[0].b[IB], yblock,
99  				    p->comm, 0));
100       if (XM(any_true)(!cldt_before, p->comm)) goto nada;	  
101       if (ego->preserve_input || NO_DESTROY_INPUTP(plnr)) { I = O; }
102       yb = XM(block)(ny, yblock, my_pe);
103       cld = X(mkplan_d)(plnr,
104  		       X(mkproblem_rdft_1_d)(X(mktensor_1d)(nx, vn, vn),
105  					     X(mktensor_2d)(yb, vn*nx, vn*nx,
106  							    vn, 1, 1),
107  					     O, I, p->kind[0]));
108       if (XM(any_true)(!cld, p->comm)) goto nada;	  
109       cldt_after = X(mkplan_d)(plnr,
110  			      XM(mkproblem_transpose)(
111  				   ny, nx, vn,
112  				   I, O,
113  				   yblock, p->sz->dims[0].b[OB], 
114  				   p->comm, 0));
115       if (XM(any_true)(!cldt_after, p->comm)) goto nada;	  
116       pln = MKPLAN_MPI_RDFT(P, &padt, apply);
117       pln->cldt_before = cldt_before;
118       pln->cld = cld;
119       pln->cldt_after = cldt_after;
120       pln->preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
121       pln->rearrange = ego->rearrange;
122       X(ops_add)(&cldt_before->ops, &cld->ops, &pln->super.super.ops);
123       X(ops_add2)(&cldt_after->ops, &pln->super.super.ops);
124       return &(pln->super.super);
125   nada:
126       X(plan_destroy_internal)(cldt_after);
127       X(plan_destroy_internal)(cld);
128       X(plan_destroy_internal)(cldt_before);
129       return (plan *) 0;
130  }
131  static solver *mksolver(rearrangement rearrange, int preserve_input)
132  {
133       static const solver_adt sadt = { PROBLEM_MPI_RDFT, mkplan, 0 };
134       S *slv = MKSOLVER(S, &sadt);
135       slv->rearrange = rearrange;
136       slv->preserve_input = preserve_input;
137       return &(slv->super);
138  }
139  void XM(rdft_rank1_bigvec_register)(planner *p)
140  {
141       rearrangement rearrange;
142       int preserve_input;
143       FORALL_REARRANGE(rearrange)
144  	  for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
145  	       REGISTER_SOLVER(p, mksolver(rearrange, preserve_input));
146  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-alltoall.c</h3>
            <pre><code>1  #include "mpi-transpose.h"
2  #include <string.h>
3  typedef struct {
4       solver super;
5       int copy_transposed_in; &bsol;* whether to copy the input for TRANSPOSED_IN,
6  				which makes the final transpose out-of-place
7  				but costs an extra copy and requires us
8  				to destroy the input */
9  } S;
10  typedef struct {
11       plan_mpi_transpose super;
12       plan *cld1, *cld2, *cld2rest, *cld3;
13       MPI_Comm comm;
14       int *send_block_sizes, *send_block_offsets;
15       int *recv_block_sizes, *recv_block_offsets;
16       INT rest_Ioff, rest_Ooff;
17       int equal_blocks;
18  } P;
19  static void apply(const plan *ego_, R *I, R *O)
20  {
21       const P *ego = (const P *) ego_;
22       plan_rdft *cld1, *cld2, *cld2rest, *cld3;
23       cld1 = (plan_rdft *) ego->cld1;
24       if (cld1) {
25  	  cld1->apply(ego->cld1, I, O);
26  	  if (ego->equal_blocks)
27  	       MPI_Alltoall(O, ego->send_block_sizes[0], FFTW_MPI_TYPE,
28  			    I, ego->recv_block_sizes[0], FFTW_MPI_TYPE,
29  			    ego->comm);
30  	  else
31  	       MPI_Alltoallv(O, ego->send_block_sizes, ego->send_block_offsets,
32  			     FFTW_MPI_TYPE,
33  			     I, ego->recv_block_sizes, ego->recv_block_offsets,
34  			     FFTW_MPI_TYPE,
35  			     ego->comm);
36       }
37       else { &bsol;* TRANSPOSED_IN, no need to destroy input */
38  	  if (ego->equal_blocks)
39  	       MPI_Alltoall(I, ego->send_block_sizes[0], FFTW_MPI_TYPE,
40  			    O, ego->recv_block_sizes[0], FFTW_MPI_TYPE,
41  			    ego->comm);
42  	  else
43  	       MPI_Alltoallv(I, ego->send_block_sizes, ego->send_block_offsets,
44  			     FFTW_MPI_TYPE,
45  			     O, ego->recv_block_sizes, ego->recv_block_offsets,
46  			     FFTW_MPI_TYPE,
47  			     ego->comm);
48  	  I = O; &bsol;* final transpose (if any) is in-place */
49       }
50       cld2 = (plan_rdft *) ego->cld2;
51       if (cld2) {
52  	  cld2->apply(ego->cld2, I, O);
53  	  cld2rest = (plan_rdft *) ego->cld2rest;
54  	  if (cld2rest) { &bsol;* leftover from unequal block sizes */
55  	       cld2rest->apply(ego->cld2rest,
56  			       I + ego->rest_Ioff, O + ego->rest_Ooff);
57  	       cld3 = (plan_rdft *) ego->cld3;
58  	       if (cld3)
59  		    cld3->apply(ego->cld3, O, O);
60  	  }
61       }
62  }
63  static int applicable(const S *ego, const problem *p_,
64  		      const planner *plnr)
65  {
66       const problem_mpi_transpose *p = (const problem_mpi_transpose *) p_;
67       return (1
68  	     && p->I != p->O
69  	     && (!NO_DESTROY_INPUTP(plnr) || 
70  		 ((p->flags & TRANSPOSED_IN) && !ego->copy_transposed_in))
71  	     && ((p->flags & TRANSPOSED_IN) || !ego->copy_transposed_in)
72  	     && ONLY_TRANSPOSEDP(p->flags)
73  	  );
<span onclick='openModal()' class='match'>74  }
75  static void awake(plan *ego_, enum wakefulness wakefulness)
76  {
77       P *ego = (P *) ego_;
78       X(plan_awake)(ego->cld1, wakefulness);
79       X(plan_awake)(ego->cld2, wakefulness);
80       X(plan_awake)(ego->cld2rest, wakefulness);
81       X(plan_awake)(ego->cld3, wakefulness);
82  }
83  static void destroy(plan *ego_)
84  {
85       P *ego = (P *) ego_;
86       X(ifree0)(ego->send_block_sizes);
87       MPI_Comm_free(&ego->comm);
88       X(plan_destroy_internal)(ego->cld3);
89       X(plan_destroy_internal)(ego->cld2rest);
90       X(plan_destroy_internal)(ego->cld2);
91       X(plan_destroy_internal)(ego->cld1);
92  }
93  static void print(const plan *ego_, printer *p)
94  {
95       const P *ego = (const P *) ego_;
</span>96       p->print(p, "(mpi-transpose-alltoall%s%(%p%)%(%p%)%(%p%)%(%p%))",
97  	      ego->equal_blocks ? "/e" : "",
98  	      ego->cld1, ego->cld2, ego->cld2rest, ego->cld3);
99  }
100  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
101  {
102       const S *ego = (const S *) ego_;
103       const problem_mpi_transpose *p;
104       P *pln;
105       plan *cld1 = 0, *cld2 = 0, *cld2rest = 0, *cld3 = 0;
106       INT b, bt, vn, rest_Ioff, rest_Ooff;
107       R *I;
108       int *sbs, *sbo, *rbs, *rbo;
109       int pe, my_pe, n_pes;
110       int equal_blocks = 1;
111       static const plan_adt padt = {
112            XM(transpose_solve), awake, print, destroy
113       };
114       if (!applicable(ego, p_, plnr))
115            return (plan *) 0;
116       p = (const problem_mpi_transpose *) p_;
117       vn = p->vn;
118       MPI_Comm_rank(p->comm, &my_pe);
119       MPI_Comm_size(p->comm, &n_pes);
120       b = XM(block)(p->nx, p->block, my_pe);
121       if (p->flags & TRANSPOSED_IN) { &bsol;* I is already transposed */
122  	  if (ego->copy_transposed_in) {
123  	       cld1 = X(mkplan_f_d)(plnr,
124  				  X(mkproblem_rdft_0_d)(X(mktensor_1d)
125  							(b * p->ny * vn, 1, 1),
126  							I = p->I, p->O),
127  				    0, 0, NO_SLOW);
128  	       if (XM(any_true)(!cld1, p->comm)) goto nada;
129  	  }
130  	  else
131  	       I = p->O; &bsol;* final transpose is in-place */
132       }
133       else { &bsol;* transpose b x ny x vn -> ny x b x vn */
134  	  cld1 = X(mkplan_f_d)(plnr, 
135  			       X(mkproblem_rdft_0_d)(X(mktensor_3d)
136  						     (b, p->ny * vn, vn,
137  						      p->ny, vn, b * vn,
138  						      vn, 1, 1),
139  						     I = p->I, p->O),
140  			       0, 0, NO_SLOW);
141  	  if (XM(any_true)(!cld1, p->comm)) goto nada;
142       }
143       if (XM(any_true)(!XM(mkplans_posttranspose)(p, plnr, I, p->O, my_pe,
144  						 &cld2, &cld2rest, &cld3,
145  						 &rest_Ioff, &rest_Ooff),
146  		      p->comm)) goto nada;
147       pln = MKPLAN_MPI_TRANSPOSE(P, &padt, apply);
148       pln->cld1 = cld1;
149       pln->cld2 = cld2;
150       pln->cld2rest = cld2rest;
151       pln->rest_Ioff = rest_Ioff;
152       pln->rest_Ooff = rest_Ooff;
153       pln->cld3 = cld3;
154       MPI_Comm_dup(p->comm, &pln->comm);
155       sbs = (int *) MALLOC(4 * n_pes * sizeof(int), PLANS);
156       sbo = sbs + n_pes;
157       rbs = sbo + n_pes;
158       rbo = rbs + n_pes;
159       b = XM(block)(p->nx, p->block, my_pe);
160       bt = XM(block)(p->ny, p->tblock, my_pe);
161       for (pe = 0; pe < n_pes; ++pe) {
162  	  INT db, dbt; &bsol;* destination block sizes */
163  	  db = XM(block)(p->nx, p->block, pe);
164  	  dbt = XM(block)(p->ny, p->tblock, pe);
165  	  if (db != p->block || dbt != p->tblock)
166  	       equal_blocks = 0;
167  	  sbs[pe] = (int) (b * dbt * vn);
168  	  sbo[pe] = (int) (pe * (b * p->tblock) * vn);
169  	  rbs[pe] = (int) (db * bt * vn);
170  	  rbo[pe] = (int) (pe * (p->block * bt) * vn);
171       }
172       pln->send_block_sizes = sbs;
173       pln->send_block_offsets = sbo;
174       pln->recv_block_sizes = rbs;
175       pln->recv_block_offsets = rbo;
176       pln->equal_blocks = equal_blocks;
177       X(ops_zero)(&pln->super.super.ops);
178       if (cld1) X(ops_add2)(&cld1->ops, &pln->super.super.ops);
179       if (cld2) X(ops_add2)(&cld2->ops, &pln->super.super.ops);
180       if (cld2rest) X(ops_add2)(&cld2rest->ops, &pln->super.super.ops);
181       if (cld3) X(ops_add2)(&cld3->ops, &pln->super.super.ops);
182       return &(pln->super.super);
183   nada:
184       X(plan_destroy_internal)(cld3);
185       X(plan_destroy_internal)(cld2rest);
186       X(plan_destroy_internal)(cld2);
187       X(plan_destroy_internal)(cld1);
188       return (plan *) 0;
189  }
190  static solver *mksolver(int copy_transposed_in)
191  {
192       static const solver_adt sadt = { PROBLEM_MPI_TRANSPOSE, mkplan, 0 };
193       S *slv = MKSOLVER(S, &sadt);
194       slv->copy_transposed_in = copy_transposed_in;
195       return &(slv->super);
196  }
197  void XM(transpose_alltoall_register)(planner *p)
198  {
199       int cti;
200       for (cti = 0; cti <= 1; ++cti)
201  	  REGISTER_SOLVER(p, mksolver(cti));
202  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rdft-rank1-bigvec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-transpose-alltoall.c</div>
                </div>
                <div class="column column_space"><pre><code>46  }
47  static void awake(plan *ego_, enum wakefulness wakefulness)
48  {
49       P *ego = (P *) ego_;
50       X(plan_awake)(ego->cldt_before, wakefulness);
51       X(plan_awake)(ego->cld, wakefulness);
52       X(plan_awake)(ego->cldt_after, wakefulness);
53  }
54  static void destroy(plan *ego_)
55  {
56       P *ego = (P *) ego_;
57       X(plan_destroy_internal)(ego->cldt_after);
58       X(plan_destroy_internal)(ego->cld);
59       X(plan_destroy_internal)(ego->cldt_before);
60  }
61  static void print(const plan *ego_, printer *p)
62  {
63       const P *ego = (const P *) ego_;
</pre></code></div>
                <div class="column column_space"><pre><code>74  }
75  static void awake(plan *ego_, enum wakefulness wakefulness)
76  {
77       P *ego = (P *) ego_;
78       X(plan_awake)(ego->cld1, wakefulness);
79       X(plan_awake)(ego->cld2, wakefulness);
80       X(plan_awake)(ego->cld2rest, wakefulness);
81       X(plan_awake)(ego->cld3, wakefulness);
82  }
83  static void destroy(plan *ego_)
84  {
85       P *ego = (P *) ego_;
86       X(ifree0)(ego->send_block_sizes);
87       MPI_Comm_free(&ego->comm);
88       X(plan_destroy_internal)(ego->cld3);
89       X(plan_destroy_internal)(ego->cld2rest);
90       X(plan_destroy_internal)(ego->cld2);
91       X(plan_destroy_internal)(ego->cld1);
92  }
93  static void print(const plan *ego_, printer *p)
94  {
95       const P *ego = (const P *) ego_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    