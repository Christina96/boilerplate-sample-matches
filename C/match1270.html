<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-tcp-server.c &amp; inf-text-move-operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-tcp-server.c &amp; inf-text-move-operation.c
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-tcp-server.c (7.0%)<th>inf-text-move-operation.c (10.810811%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(365-391)<td><a href="#" name="0">(78-104)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(432-446)<td><a href="#" name="1">(283-295)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-tcp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-tcp-server.h&gt;
2 #include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
3 #include &lt;libinfinity/common/inf-ip-address.h&gt;
4 #include &lt;libinfinity/common/inf-io.h&gt;
5 #include &lt;libinfinity/common/inf-native-socket.h&gt;
6 #include &lt;libinfinity/inf-define-enum.h&gt;
7 #include &lt;config.h&gt;
8 #ifndef G_OS_WIN32
9 # include &lt;sys/types.h&gt;
10 # include &lt;sys/socket.h&gt;
11 # include &lt;netinet/in.h&gt;
12 # include &lt;arpa/inet.h&gt;
13 # include &lt;unistd.h&gt;
14 # include &lt;fcntl.h&gt;
15 # include &lt;errno.h&gt;
16 # include &lt;string.h&gt;
17 #else
18 # include &lt;ws2tcpip.h&gt;
19 #endif
20 static const GEnumValue infd_tcp_server_status_values[] = {
21   {
22     INFD_TCP_SERVER_CLOSED,
23     "INFD_TCP_SERVER_CLOSED",
24     "closed"
25   }, {
26     INFD_TCP_SERVER_OPEN,
27     "INFD_TCP_SERVER_OPEN",
28     "open"
29   }, {
30     0,
31     NULL,
32     NULL
33   }
34 };
35 typedef struct _InfdTcpServerPrivate InfdTcpServerPrivate;
36 struct _InfdTcpServerPrivate {
37   InfIo* io;
38   InfIoWatch* watch;
39   InfNativeSocket socket;
40   InfdTcpServerStatus status;
41   InfIpAddress* local_address;
42   guint local_port;
43   InfKeepalive keepalive;
44 };
45 enum {
46   PROP_0,
47   PROP_IO,
48   PROP_STATUS,
49   PROP_LOCAL_ADDRESS,
50   PROP_LOCAL_PORT,
51   PROP_KEEPALIVE
52 };
53 enum {
54   NEW_CONNECTION,
55   ERROR_, 
56   LAST_SIGNAL
57 };
58 #define INFD_TCP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_TCP_SERVER, InfdTcpServerPrivate))
59 static guint tcp_server_signals[LAST_SIGNAL];
60 INF_DEFINE_ENUM_TYPE(InfdTcpServerStatus, infd_tcp_server_status, infd_tcp_server_status_values)
61 G_DEFINE_TYPE_WITH_CODE(InfdTcpServer, infd_tcp_server, G_TYPE_OBJECT,
62   G_ADD_PRIVATE(InfdTcpServer))
63 static void
64 infd_tcp_server_addr_info(InfNativeSocket socket,
65                           gboolean local,
66                           InfIpAddress** address,
67                           guint* port)
68 {
69   union {
70     struct sockaddr in_generic;
71     struct sockaddr_in in;
72     struct sockaddr_in6 in6;
73   } native_addr;
74   socklen_t len;
75   len = sizeof(native_addr);
76   if(local == TRUE)
77     getsockname(socket, &amp;native_addr.in_generic, &amp;len);
78   else
79     getpeername(socket, &amp;native_addr.in_generic, &amp;len);
80   switch(native_addr.in_generic.sa_family)
81   {
82   case AF_INET:
83     if(address != NULL)
84       *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
85     if(port != NULL)
86       *port = ntohs(native_addr.in.sin_port);
87     break;
88   case AF_INET6:
89     if(address != NULL)
90       *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
91     if(port != NULL)
92       *port = ntohs(native_addr.in6.sin6_port);
93     break;
94   default:
95     g_assert_not_reached();
96     break;
97   }
98 }
99 static void
100 infd_tcp_server_system_error(InfdTcpServer* server,
101                              int code)
102 {
103   GError* error;
104   error = NULL;
105   inf_native_socket_make_error(code, &amp;error);
106   g_signal_emit(G_OBJECT(server), tcp_server_signals[ERROR_], 0, error);
107   g_error_free(error);
108 }
109 static void
110 infd_tcp_server_io(InfNativeSocket* socket,
111                    InfIoEvent events,
112                    gpointer user_data)
113 {
114   InfdTcpServer* server;
115   InfdTcpServerPrivate* priv;
116   socklen_t len;
117   InfNativeSocket new_socket;
118   int errcode;
119   InfTcpConnection* connection;
120   GError* error;
121   union {
122     struct sockaddr in_generic;
123     struct sockaddr_in in;
124     struct sockaddr_in6 in6;
125   } native_addr;
126   InfIpAddress* address;
127   guint port;
128   server = INFD_TCP_SERVER(user_data);
129   priv = INFD_TCP_SERVER_PRIVATE(server);
130   g_object_ref(G_OBJECT(server));
131   if(events &amp; INF_IO_ERROR)
132   {
133     len = sizeof(int);
134 #ifdef G_OS_WIN32
135     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
136 #else
137     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
138 #endif
139     infd_tcp_server_system_error(server, errcode);
140   }
141   else if(events &amp; INF_IO_INCOMING)
142   {
143     do
144     {
145 #ifndef G_OS_WIN32
146       errno = 0;
147 #endif
148       len = sizeof(native_addr);
149       new_socket = accept(priv-&gt;socket, &amp;native_addr.in_generic, &amp;len);
150       errcode = INF_NATIVE_SOCKET_LAST_ERROR;
151       if(new_socket == INVALID_SOCKET &amp;&amp;
152          errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
153          errcode != INF_NATIVE_SOCKET_EAGAIN)
154       {
155         infd_tcp_server_system_error(server, errcode);
156       }
157       else if(new_socket != INVALID_SOCKET)
158       {
159         switch(native_addr.in_generic.sa_family)
160         {
161         case AF_INET:
162           address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
163           port = ntohs(native_addr.in.sin_port);
164           break;
165         case AF_INET6:
166           address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
167           port = ntohs(native_addr.in6.sin6_port);
168           break;
169         default:
170           g_assert_not_reached();
171           break;
172         }
173         error = NULL;
174         connection = _inf_tcp_connection_accepted(
175           priv-&gt;io,
176           new_socket,
177           address,
178           port,
179           &amp;priv-&gt;keepalive,
180           &amp;error
181         );
182         if(connection != NULL)
183         {
184           g_signal_emit(
185             G_OBJECT(server),
186             tcp_server_signals[NEW_CONNECTION],
187             0,
188             connection
189           );
190           g_object_unref(connection);
191         }
192         else
193         {
194           g_signal_emit(
195             G_OBJECT(server),
196             tcp_server_signals[ERROR_],
197             0,
198             error
199           );
200           g_error_free(error);
201           closesocket(new_socket);
202         }
203       }
204     } while( (new_socket != INVALID_SOCKET ||
205               (new_socket == INVALID_SOCKET &amp;&amp;
206                errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
207              (priv-&gt;socket != INVALID_SOCKET));
208   }
209   g_object_unref(G_OBJECT(server));
210 }
211 static void
212 infd_tcp_server_init(InfdTcpServer* server)
213 {
214   InfdTcpServerPrivate* priv;
215   priv = INFD_TCP_SERVER_PRIVATE(server);
216   priv-&gt;io = NULL;
217   priv-&gt;socket = INVALID_SOCKET;
218   priv-&gt;status = INFD_TCP_SERVER_CLOSED;
219   priv-&gt;local_address = NULL;
220   priv-&gt;local_port = 0;
221   priv-&gt;keepalive.mask = 0;
222 }
223 static void
224 infd_tcp_server_dispose(GObject* object)
225 {
226   InfdTcpServer* server;
227   InfdTcpServerPrivate* priv;
228   server = INFD_TCP_SERVER(object);
229   priv = INFD_TCP_SERVER_PRIVATE(server);
230   if(priv-&gt;status != INFD_TCP_SERVER_CLOSED)
231     infd_tcp_server_close(server);
232   if(priv-&gt;io  != NULL)
233   {
234     g_object_unref(G_OBJECT(priv-&gt;io));
235     priv-&gt;io = NULL;
236   }
237   G_OBJECT_CLASS(infd_tcp_server_parent_class)-&gt;dispose(object);
238 }
239 static void
240 infd_tcp_server_finalize(GObject* object)
241 {
242   InfdTcpServer* server;
243   InfdTcpServerPrivate* priv;
244   server = INFD_TCP_SERVER(object);
245   priv = INFD_TCP_SERVER_PRIVATE(server);
246   if(priv-&gt;local_address != NULL)
247     inf_ip_address_free(priv-&gt;local_address);
248   G_OBJECT_CLASS(infd_tcp_server_parent_class)-&gt;finalize(object);
249 }
250 static void
251 infd_tcp_server_set_property(GObject* object,
252                              guint prop_id,
253                              const GValue* value,
254                              GParamSpec* pspec)
255 {
256   InfdTcpServer* server;
257   InfdTcpServerPrivate* priv;
258   server = INFD_TCP_SERVER(object);
259   priv = INFD_TCP_SERVER_PRIVATE(server);
260   switch(prop_id)
261   {
262   case PROP_IO:
263     g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
264     if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
265     priv-&gt;io = INF_IO(g_value_dup_object(value));
266     break;
267   case PROP_LOCAL_ADDRESS:
268     g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
269     if(priv-&gt;local_address != NULL)
270       inf_ip_address_free(priv-&gt;local_address);
271     priv-&gt;local_address = (InfIpAddress*)g_value_dup_boxed(value);
272     break;
273   case PROP_LOCAL_PORT:
274     g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
275     priv-&gt;local_port = g_value_get_uint(value);
276     break;
277 <a name="0"></a>  case PROP_KEEPALIVE:
278     g_assert(g_value_get_boxed(value) != NULL);
279     priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
280 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
281   default:
282     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
283     break;
284   }
285 }
286 static void
287 infd_tcp_server_get_property(GObject* object,
288                              guint prop_id,
289                              GValue* value,
290                              GParamSpec* pspec)
291 {
292   InfdTcpServer* server;
293   InfdTcpServerPrivate* priv;
294   server = INFD_TCP_SERVER(object);
295   priv = INFD_TCP_SERVER_PRIVATE(server);
296   switch(prop_id)
297   {
298   case PROP_IO:
299     g_value_set_object(value, G_OBJECT(priv-&gt;io));
300     break;
301   case PROP_STATUS:
302     g_value_set_enum(value, priv-&gt;status);
303     break;</b></font>
304   case PROP_LOCAL_ADDRESS:
305     g_value_set_static_boxed(value, priv-&gt;local_address);
306     break;
307   case PROP_LOCAL_PORT:
308     g_value_set_uint(value, priv-&gt;local_port);
309     break;
310   case PROP_KEEPALIVE:
311     g_value_set_boxed(value, &amp;priv-&gt;keepalive);
312     break;
313   default:
314     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
315     break;
316   }
317 }
318 static void
319 infd_tcp_server_error(InfdTcpServer* server,
320                       GError* error)
321 {
322   InfdTcpServerPrivate* priv;
323   priv = INFD_TCP_SERVER_PRIVATE(server);
324   if(priv-&gt;status == INFD_TCP_SERVER_OPEN)
325   {
326     g_assert(priv-&gt;watch != NULL);
327     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
328     priv-&gt;watch = NULL;
329   }
330   if(priv-&gt;socket != INVALID_SOCKET)
331   {
332     closesocket(priv-&gt;socket);
333     priv-&gt;socket = INVALID_SOCKET;
334   }
335   if(priv-&gt;status != INFD_TCP_SERVER_CLOSED)
336   {
337 <a name="1"></a>    priv-&gt;status = INFD_TCP_SERVER_CLOSED;
338     g_object_notify(G_OBJECT(server), "status");
339   }
340 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
341 static void
342 infd_tcp_server_class_init(InfdTcpServerClass* tcp_server_class)
343 {
344   GObjectClass* object_class;
345   object_class = G_OBJECT_CLASS(tcp_server_class);
346   object_class-&gt;dispose = infd_tcp_server_dispose;
347   object_class-&gt;finalize = infd_tcp_server_finalize;
348   object_class-&gt;set_property = infd_tcp_server_set_property;
349   object_class-&gt;get_property = infd_tcp_server_get_property;
350   tcp_server_class-&gt;new_connection = NULL;
351   tcp_server_class-&gt;error = infd_tcp_server_error;</b></font>
352   g_object_class_install_property(
353     object_class,
354     PROP_IO,
355     g_param_spec_object(
356       "io",
357       "IO",
358       "I/O handler",
359       INF_TYPE_IO,
360       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
361     )
362   );
363   g_object_class_install_property(
364     object_class,
365     PROP_STATUS,
366     g_param_spec_enum(
367       "status",
368       "Status",
369       "Status of the TCP server",
370       INFD_TYPE_TCP_SERVER_STATUS,
371       INFD_TCP_SERVER_CLOSED,
372       G_PARAM_READABLE
373     )
374   );
375   g_object_class_install_property(
376     object_class,
377     PROP_LOCAL_ADDRESS,
378     g_param_spec_boxed(
379       "local-address",
380       "Local address",
381       "Address to bind to",
382       INF_TYPE_IP_ADDRESS,
383       G_PARAM_READWRITE
384     )
385   );
386   g_object_class_install_property(
387     object_class,
388     PROP_LOCAL_PORT,
389     g_param_spec_uint(
390       "local-port",
391       "Local port",
392       "Port to bind to",
393       0,
394       65535,
395       0,
396       G_PARAM_READWRITE
397     )
398   );
399   g_object_class_install_property(
400     object_class,
401     PROP_KEEPALIVE,
402     g_param_spec_boxed(
403       "keepalive",
404       "Keepalive",
405       "Keepalive settings for accepted connections",
406       INF_TYPE_KEEPALIVE,
407       G_PARAM_READWRITE
408     )
409   );
410   tcp_server_signals[NEW_CONNECTION] = g_signal_new(
411     "new-connection",
412     G_OBJECT_CLASS_TYPE(object_class),
413     G_SIGNAL_RUN_LAST,
414     G_STRUCT_OFFSET(InfdTcpServerClass, new_connection),
415     NULL, NULL,
416     g_cclosure_marshal_VOID__OBJECT,
417     G_TYPE_NONE,
418     1,
419     INF_TYPE_TCP_CONNECTION
420   );
421   tcp_server_signals[ERROR_] = g_signal_new(
422     "error",
423     G_OBJECT_CLASS_TYPE(object_class),
424     G_SIGNAL_RUN_LAST,
425     G_STRUCT_OFFSET(InfdTcpServerClass, error),
426     NULL, NULL,
427     g_cclosure_marshal_VOID__BOXED,
428     G_TYPE_NONE,
429     1,
430     G_TYPE_ERROR
431   );
432 }
433 gboolean
434 infd_tcp_server_bind(InfdTcpServer* server,
435                      GError** error)
436 {
437   InfdTcpServerPrivate* priv;
438   union {
439     struct sockaddr_in in;
440     struct sockaddr_in6 in6;
441   } native_address;
442   struct sockaddr* addr;
443   socklen_t addrlen;
444 #if !defined(G_OS_WIN32) &amp;&amp; defined(HAVE_SO_REUSEADDR)
445   int value;
446 #endif
447   g_return_val_if_fail(INFD_IS_TCP_SERVER(server), FALSE);
448   priv = INFD_TCP_SERVER_PRIVATE(server);
449   g_return_val_if_fail(priv-&gt;status == INFD_TCP_SERVER_CLOSED, FALSE);
450   if(priv-&gt;local_address == NULL)
451   {
452     priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
453     addr = (struct sockaddr*)&amp;native_address.in;
454     addrlen = sizeof(struct sockaddr_in);
455     native_address.in.sin_addr.s_addr = INADDR_ANY;
456     native_address.in.sin_family = AF_INET;
457     native_address.in.sin_port = htons(priv-&gt;local_port);
458   }
459   else
460   {
461     switch(inf_ip_address_get_family(priv-&gt;local_address))
462     {
463     case INF_IP_ADDRESS_IPV4:
464       priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
465       addr = (struct sockaddr*)&amp;native_address.in;
466       addrlen = sizeof(struct sockaddr_in);
467       memcpy(
468         &amp;native_address.in.sin_addr,
469         inf_ip_address_get_raw(priv-&gt;local_address),
470         sizeof(struct in_addr)
471       );
472       native_address.in.sin_family = AF_INET;
473       native_address.in.sin_port = htons(priv-&gt;local_port);
474       break;
475     case INF_IP_ADDRESS_IPV6:
476       priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
477       addr = (struct sockaddr*)&amp;native_address.in6;
478       addrlen = sizeof(struct sockaddr_in6);
479       memcpy(
480         &amp;native_address.in6.sin6_addr,
481         inf_ip_address_get_raw(priv-&gt;local_address),
482         sizeof(struct in6_addr)
483       );
484       native_address.in6.sin6_family = AF_INET6;
485       native_address.in6.sin6_port = htons(priv-&gt;local_port);
486       native_address.in6.sin6_flowinfo = 0;
487       native_address.in6.sin6_scope_id = 0;
488       break;
489     default:
490       g_assert_not_reached();
491       break;
492     }
493   }
494   if(priv-&gt;socket == INVALID_SOCKET)
495   {
496     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
497     return FALSE;
498   }
499 #if !defined(G_OS_WIN32) &amp;&amp; defined(HAVE_SO_REUSEADDR)
500   value = 1;
501   if(setsockopt(priv-&gt;socket, SOL_SOCKET, SO_REUSEADDR, &amp;value,
502       sizeof(int)) == -1)
503   {
504     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
505     closesocket(priv-&gt;socket);
506     priv-&gt;socket = INVALID_SOCKET;
507     return FALSE;
508   }
509 #endif
510   if(bind(priv-&gt;socket, addr, addrlen) == -1)
511   {
512     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
513     closesocket(priv-&gt;socket);
514     priv-&gt;socket = INVALID_SOCKET;
515     return FALSE;
516   }
517   g_object_freeze_notify(G_OBJECT(server));
518   if(priv-&gt;local_port == 0) g_object_notify(G_OBJECT(server), "local-port");
519   if(priv-&gt;local_address != NULL)
520   {
521     infd_tcp_server_addr_info(
522       priv-&gt;socket,
523       TRUE,
524       NULL,
525       &amp;priv-&gt;local_port
526     );
527   }
528   else
529   {
530     infd_tcp_server_addr_info(
531       priv-&gt;socket,
532       TRUE,
533       &amp;priv-&gt;local_address,
534       &amp;priv-&gt;local_port
535     );
536     g_object_notify(G_OBJECT(server), "local-address");
537   }
538   g_object_notify(G_OBJECT(server), "local-port");
539   priv-&gt;status = INFD_TCP_SERVER_BOUND;
540   g_object_notify(G_OBJECT(server), "status");
541   g_object_thaw_notify(G_OBJECT(server));
542   return TRUE;
543 }
544 gboolean
545 infd_tcp_server_open(InfdTcpServer* server,
546                      GError** error)
547 {
548   InfdTcpServerPrivate* priv;
549   gboolean was_bound;
550 #ifdef G_OS_WIN32
551   u_long argp;
552 #else
553   int result;
554 #endif
555   g_return_val_if_fail(INFD_IS_TCP_SERVER(server), FALSE);
556   priv = INFD_TCP_SERVER_PRIVATE(server);
557   g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
558   g_return_val_if_fail(priv-&gt;status != INFD_TCP_SERVER_OPEN, FALSE);
559   g_assert(priv-&gt;watch == NULL);
560   g_object_freeze_notify(G_OBJECT(server));
561   was_bound = (priv-&gt;status != INFD_TCP_SERVER_CLOSED);
562   if(!was_bound)
563   {
564     if(!infd_tcp_server_bind(server, error))
565     {
566       g_object_thaw_notify(G_OBJECT(server));
567       return FALSE;
568     }
569   }
570 #ifndef G_OS_WIN32
571   result = fcntl(priv-&gt;socket, F_GETFL);
572   if(result == -1)
573   {
574     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
575     if(!was_bound)
576       infd_tcp_server_close(server);
577     g_object_thaw_notify(G_OBJECT(server));
578     return FALSE;
579   }
580   if(fcntl(priv-&gt;socket, F_SETFL, result | O_NONBLOCK) == -1)
581   {
582     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
583     if(!was_bound)
584       infd_tcp_server_close(server);
585     g_object_thaw_notify(G_OBJECT(server));
586     return FALSE;
587   }
588 #else
589   argp = 1;
590   if(ioctlsocket(priv-&gt;socket, FIONBIO, &amp;argp) != 0)
591   {
592     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
593     if(!was_bound)
594       infd_tcp_server_close(server);
595     g_object_thaw_notify(G_OBJECT(server));
596     return FALSE;
597   }
598 #endif
599   if(listen(priv-&gt;socket, 5) == -1)
600   {
601     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
602     if(!was_bound)
603       infd_tcp_server_close(server);
604     g_object_thaw_notify(G_OBJECT(server));
605     return FALSE;
606   }
607   priv-&gt;watch = inf_io_add_watch(
608     priv-&gt;io,
609     &amp;priv-&gt;socket,
610     INF_IO_INCOMING | INF_IO_ERROR,
611     infd_tcp_server_io,
612     server,
613     NULL
614   );
615   priv-&gt;status = INFD_TCP_SERVER_OPEN;
616   g_object_notify(G_OBJECT(server), "status");
617   g_object_thaw_notify(G_OBJECT(server));
618   return TRUE;
619 }
620 void
621 infd_tcp_server_close(InfdTcpServer* server)
622 {
623   InfdTcpServerPrivate* priv;
624   g_return_if_fail(INFD_IS_TCP_SERVER(server));
625   priv = INFD_TCP_SERVER_PRIVATE(server);
626   g_return_if_fail(priv-&gt;status != INFD_TCP_SERVER_CLOSED);
627   if(priv-&gt;status == INFD_TCP_SERVER_OPEN)
628   {
629     g_assert(priv-&gt;watch != NULL);
630     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
631     priv-&gt;watch = NULL;
632   }
633   closesocket(priv-&gt;socket);
634   priv-&gt;socket = INVALID_SOCKET;
635   priv-&gt;status = INFD_TCP_SERVER_CLOSED;
636   g_object_notify(G_OBJECT(server), "status");
637 }
638 void
639 infd_tcp_server_set_keepalive(InfdTcpServer* server,
640                               const InfKeepalive* keepalive)
641 {
642   g_return_if_fail(INFD_IS_TCP_SERVER(server));
643   g_return_if_fail(keepalive != NULL);
644   INFD_TCP_SERVER_PRIVATE(server)-&gt;keepalive = *keepalive;
645 }
646 const InfKeepalive*
647 infd_tcp_server_get_keepalive(InfdTcpServer* server)
648 {
649   g_return_val_if_fail(INFD_IS_TCP_SERVER(server), NULL);
650   return &amp;INFD_TCP_SERVER_PRIVATE(server)-&gt;keepalive;
651 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-move-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-move-operation.h&gt;
2 #include &lt;libinftext/inf-text-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-buffer.h&gt;
5 #include &lt;libinftext/inf-text-user.h&gt;
6 #include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
7 #include &lt;libinfinity/inf-i18n.h&gt;
8 typedef struct _InfTextMoveOperationPrivate InfTextMoveOperationPrivate;
9 struct _InfTextMoveOperationPrivate {
10   guint position;
11   gint length;
12 };
13 enum {
14   PROP_0,
15   PROP_POSITION,
16   PROP_LENGTH
17 };
18 #define INF_TEXT_MOVE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_MOVE_OPERATION, InfTextMoveOperationPrivate))
19 static void inf_text_move_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
20 G_DEFINE_TYPE_WITH_CODE(InfTextMoveOperation, inf_text_move_operation, G_TYPE_OBJECT,
21   G_ADD_PRIVATE(InfTextMoveOperation)
22   G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_move_operation_operation_iface_init))
23 static void
24 inf_text_move_operation_init(InfTextMoveOperation* operation)
25 {
26   InfTextMoveOperationPrivate* priv;
27   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
28   priv-&gt;position = 0;
29   priv-&gt;length = 0;
30 }
31 static void
32 inf_text_move_operation_set_property(GObject* object,
33                                      guint prop_id,
34                                      const GValue* value,
35                                      GParamSpec* pspec)
36 {
37   InfTextMoveOperation* operation;
38   InfTextMoveOperationPrivate* priv;
39   operation = INF_TEXT_MOVE_OPERATION(object);
40   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
41   switch(prop_id)
42   {
43   case PROP_POSITION:
44     priv-&gt;position = g_value_get_uint(value);
45 <a name="0"></a>    break;
46   case PROP_LENGTH:
47     priv-&gt;length = g_value_get_int(value);
48 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
49   default:
50     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
51     break;
52   }
53 }
54 static void
55 inf_text_move_operation_get_property(GObject* object,
56                                      guint prop_id,
57                                      GValue* value,
58                                      GParamSpec* pspec)
59 {
60   InfTextMoveOperation* operation;
61   InfTextMoveOperationPrivate* priv;
62   operation = INF_TEXT_MOVE_OPERATION(object);
63   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
64   switch(prop_id)
65   {
66   case PROP_POSITION:
67     g_value_set_uint(value, priv-&gt;position);
68     break;
69   case PROP_LENGTH:
70     g_value_set_int(value, priv-&gt;length);
71     break;</b></font>
72   default:
73     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
74     break;
75   }
76 }
77 static gboolean
78 inf_text_move_operation_need_concurrency_id(InfAdoptedOperation* operation,
79                                             InfAdoptedOperation* against)
80 {
81   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
82   return FALSE;
83 }
84 static InfAdoptedOperation*
85 inf_text_move_operation_transform(InfAdoptedOperation* operation,
86                                   InfAdoptedOperation* against,
87                                   InfAdoptedOperation* operation_lcs,
88                                   InfAdoptedOperation* against_lcs,
89                                   gint concurrency_id)
90 {
91   InfTextMoveOperationPrivate* priv;
92   guint new_pos;
93   gint new_len;
94   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
95   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
96   new_pos = priv-&gt;position;
97   new_len = priv-&gt;length;
98   if(INF_TEXT_IS_INSERT_OPERATION(against))
99   {
100     inf_text_move_operation_transform_insert(
101       inf_text_insert_operation_get_position(
102         INF_TEXT_INSERT_OPERATION(against)
103       ),
104       inf_text_insert_operation_get_length(
105         INF_TEXT_INSERT_OPERATION(against)
106       ),
107       &amp;new_pos,
108       &amp;new_len,
109       TRUE     );
110   }
111   else if(INF_TEXT_IS_DELETE_OPERATION(against))
112   {
113     inf_text_move_operation_transform_delete(
114       inf_text_delete_operation_get_position(
115         INF_TEXT_DELETE_OPERATION(against)
116       ),
117       inf_text_delete_operation_get_length(
118         INF_TEXT_DELETE_OPERATION(against)
119       ),
120       &amp;new_pos,
121       &amp;new_len
122     );
123   }
124   else
125   {
126     g_assert_not_reached();
127     return NULL;
128   }
129   return INF_ADOPTED_OPERATION(
130     g_object_new(
131       INF_TEXT_TYPE_MOVE_OPERATION,
132       "position", new_pos,
133       "length", new_len,
134       NULL
135     )
136   );
137 }
138 static InfAdoptedOperation*
139 inf_text_move_operation_copy(InfAdoptedOperation* operation)
140 {
141   InfTextMoveOperationPrivate* priv;
142   GObject* object;
143   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
144   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
145   object = g_object_new(
146     INF_TEXT_TYPE_MOVE_OPERATION,
147     "position", priv-&gt;position,
148     "length", priv-&gt;length,
149     NULL
150   );
151   return INF_ADOPTED_OPERATION(object);
152 }
153 static InfAdoptedOperationFlags
154 inf_text_move_operation_get_flags(InfAdoptedOperation* operation)
155 {
156   return 0;
157 }
158 static gboolean
159 inf_text_move_operation_apply(InfAdoptedOperation* operation,
160                               InfAdoptedUser* by,
161                               InfBuffer* buffer,
162                               GError** error)
163 {
164   InfTextMoveOperationPrivate* priv;
165   guint length;
166   g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
167   g_assert(INF_TEXT_IS_USER(by));
168   priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);  
169   length = inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer));
170   if(priv-&gt;position &gt; length ||
171      priv-&gt;position + priv-&gt;length &gt; length)
172   {
173     g_set_error_literal(
174       error,
175       g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
176       INF_TEXT_OPERATION_ERROR_INVALID_MOVE,
177       _("Attempt to move cursor or selection beyond the end of the document")
178     );
179     return FALSE;
180   }
181   else
182   {
183     inf_text_user_set_selection(
184       INF_TEXT_USER(by),
185       priv-&gt;position,
186       priv-&gt;length,
187       TRUE     );
188     return TRUE;
189   }
190 }
191 static void
192 inf_text_move_operation_class_init(
193   InfTextMoveOperationClass* move_operation_class)
194 {
195   GObjectClass* object_class;
196   object_class = G_OBJECT_CLASS(move_operation_class);
197   object_class-&gt;set_property = inf_text_move_operation_set_property;
198   object_class-&gt;get_property = inf_text_move_operation_get_property;
199   g_object_class_install_property(
200     object_class,
201     PROP_POSITION,
202     g_param_spec_uint(
203       "position",
204       "Position",
205       "Position where to place the user's caret at",
206       0,
207       G_MAXUINT,
208       0,
209       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
210     )
211   );
212   g_object_class_install_property(
213     object_class,
214     PROP_LENGTH,
215     g_param_spec_int(
216       "length",
217       "Length",
218       "The number of characters of the selected text",
219       G_MININT,
220       G_MAXINT,
221       0,
222 <a name="1"></a>      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
223     )
224   );
225 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
226 static void
227 inf_text_move_operation_operation_iface_init(
228   InfAdoptedOperationInterface* iface)
229 {
230   iface-&gt;need_concurrency_id = inf_text_move_operation_need_concurrency_id;
231   iface-&gt;transform = inf_text_move_operation_transform;
232   iface-&gt;copy = inf_text_move_operation_copy;
233   iface-&gt;get_flags = inf_text_move_operation_get_flags;
234   iface-&gt;apply = inf_text_move_operation_apply;
235   iface-&gt;apply_transformed = NULL;
236   iface-&gt;revert = NULL;</b></font>
237 }
238 InfTextMoveOperation*
239 inf_text_move_operation_new(guint position,
240                             gint length)
241 {
242   GObject* object;
243   object = g_object_new(
244     INF_TEXT_TYPE_MOVE_OPERATION,
245     "position", position,
246     "length", length,
247     NULL
248   );
249   return INF_TEXT_MOVE_OPERATION(object);
250 }
251 guint
252 inf_text_move_operation_get_position(InfTextMoveOperation* operation)
253 {
254   g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
255   return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;position;
256 }
257 gint
258 inf_text_move_operation_get_length(InfTextMoveOperation* operation)
259 {
260   g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
261   return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;length;
262 }
263 void
264 inf_text_move_operation_transform_insert(guint insert_position,
265                                          guint insert_length,
266                                          guint* move_position,
267                                          gint* move_length,
268                                          gboolean left_gravity)
269 {
270   guint cur_pos;
271   guint cur_bound;
272   g_return_if_fail(move_position != NULL);
273   g_return_if_fail(move_length != NULL);
274   cur_pos = *move_position;
275   cur_bound = *move_position + *move_length;
276   if(cur_pos == cur_bound)
277   {
278     if( (insert_position &lt; cur_pos) ||
279         (insert_position == cur_pos &amp;&amp; !left_gravity))
280     {
281       cur_pos += insert_length;
282       cur_bound += insert_length;
283     }
284   }
285   else
286   {
287     if(cur_bound &gt; cur_pos)
288     {
289       if(insert_position &lt;= cur_pos)
290       {
291         cur_pos += insert_length;
292         cur_bound += insert_length;
293       }
294       else if(insert_position &lt; cur_bound)
295       {
296         cur_bound += insert_length;
297       }
298     }
299     else
300     {
301       if(insert_position &lt;= cur_bound)
302       {
303         cur_pos += insert_length;
304         cur_bound += insert_length;
305       }
306       else if(insert_position &lt; cur_pos)
307       {
308         cur_pos += insert_length;
309       }
310     }
311   }
312   *move_position = cur_pos;
313   *move_length = (gint)cur_bound - (gint)cur_pos;
314 }
315 void
316 inf_text_move_operation_transform_delete(guint delete_position,
317                                          guint delete_length,
318                                          guint* move_position,
319                                          gint* move_length)
320 {
321   guint cur_pos;
322   gint cur_len;
323   g_return_if_fail(move_position != NULL);
324   g_return_if_fail(move_length != NULL);
325   cur_pos = *move_position;
326   cur_len = *move_length;
327   if(cur_pos &gt;= delete_position + delete_length)
328     *move_position = cur_pos - delete_length;
329   else if(cur_pos &gt; delete_position)
330     *move_position = delete_position;
331   else
332     *move_position = cur_pos;
333   if(cur_len &lt; 0)
334   {
335     if(delete_position + delete_length &lt;= cur_pos + cur_len)
336     {
337       *move_length = cur_len;
338     }
339     else if(delete_position &gt;= cur_pos)
340     {
341       *move_length = cur_len;
342     }
343     else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
344             delete_position + delete_length &gt;= cur_pos)
345     {
346       *move_length = 0;
347     }
348     else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
349             delete_position + delete_length &gt; cur_pos + cur_len)
350     {
351       *move_length = -(gint)(cur_pos - (delete_position + delete_length));
352     }
353     else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
354             delete_position + delete_length &gt; cur_pos)
355     {
356       *move_length = delete_position - (cur_pos + cur_len);
357     }
358     else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
359             delete_position + delete_length &lt;= cur_pos)
360     {
361       *move_length = cur_len + (gint)delete_length;
362     }
363     else
364     {
365       g_assert_not_reached();
366     }
367   }
368   else
369   {
370     if(delete_position + delete_length &lt;= cur_pos)
371     {
372       *move_length = cur_len;
373     }
374     else if(delete_position &gt;= cur_pos + cur_len)
375     {
376       *move_length = cur_len;
377     }
378     else if(delete_position &lt;= cur_pos &amp;&amp;
379             delete_position + delete_length &gt;= cur_pos + cur_len)
380     {
381       *move_length = 0;
382     }
383     else if(delete_position &lt;= cur_pos &amp;&amp;
384             delete_position + delete_length &gt; cur_pos)
385     {
386       *move_length = cur_pos + cur_len - (delete_position + delete_length);
387     }
388     else if(delete_position &gt; cur_pos &amp;&amp;
389              delete_position + delete_length &gt; cur_pos + cur_len)
390     {
391       *move_length = cur_pos - delete_position;
392     }
393     else if(delete_position &gt; cur_pos &amp;&amp;
394             delete_position + delete_length &lt;= cur_pos + cur_len)
395     {
396       *move_length = cur_len - delete_length;
397     }
398     else
399     {
400       g_assert_not_reached();
401     }
402   }
403 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
