<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for infd-tcp-server.c & inf-text-move-operation.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for infd-tcp-server.c & inf-text-move-operation.c
      </h3>
      <h1 align="center">
        8.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>infd-tcp-server.c (7.0%)<TH>inf-text-move-operation.c (10.810811%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1270-0.html#0',2,'match1270-1.html#0',3)" NAME="0">(365-391)<TD><A HREF="javascript:ZweiFrames('match1270-0.html#0',2,'match1270-1.html#0',3)" NAME="0">(78-104)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1270-0.html#1',2,'match1270-1.html#1',3)" NAME="1">(432-446)<TD><A HREF="javascript:ZweiFrames('match1270-0.html#1',2,'match1270-1.html#1',3)" NAME="1">(283-295)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-tcp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/server/infd-tcp-server.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-native-socket.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
#include &lt;config.h&gt;

#ifndef G_OS_WIN32
# include &lt;sys/types.h&gt;
# include &lt;sys/socket.h&gt;
# include &lt;netinet/in.h&gt;
# include &lt;arpa/inet.h&gt;
# include &lt;unistd.h&gt;
# include &lt;fcntl.h&gt;

# include &lt;errno.h&gt;
# include &lt;string.h&gt;
#else
# include &lt;ws2tcpip.h&gt;
#endif

static const GEnumValue infd_tcp_server_status_values[] = {
  {
    INFD_TCP_SERVER_CLOSED,
    &quot;INFD_TCP_SERVER_CLOSED&quot;,
    &quot;closed&quot;
  }, {
    INFD_TCP_SERVER_OPEN,
    &quot;INFD_TCP_SERVER_OPEN&quot;,
    &quot;open&quot;
  }, {
    0,
    NULL,
    NULL
  }
};

typedef struct _InfdTcpServerPrivate InfdTcpServerPrivate;
struct _InfdTcpServerPrivate {
  InfIo* io;
  InfIoWatch* watch;

  InfNativeSocket socket;
  InfdTcpServerStatus status;

  InfIpAddress* local_address;
  guint local_port;

  InfKeepalive keepalive;
};

enum {
  PROP_0,

  PROP_IO,

  PROP_STATUS,

  PROP_LOCAL_ADDRESS,
  PROP_LOCAL_PORT,

  PROP_KEEPALIVE
};

enum {
  NEW_CONNECTION,
  ERROR_, /* ERROR is a #define on WIN32 */

  LAST_SIGNAL
};

#define INFD_TCP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_TCP_SERVER, InfdTcpServerPrivate))

static guint tcp_server_signals[LAST_SIGNAL];

INF_DEFINE_ENUM_TYPE(InfdTcpServerStatus, infd_tcp_server_status, infd_tcp_server_status_values)
G_DEFINE_TYPE_WITH_CODE(InfdTcpServer, infd_tcp_server, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdTcpServer))

/* TODO: The following functions are merely copied from inf-tcp-connection.c.
 * Probably they should belong into some inf-net-util.c file in
 * libinfinity/common. */

static void
infd_tcp_server_addr_info(InfNativeSocket socket,
                          gboolean local,
                          InfIpAddress** address,
                          guint* port)
{
  union {
    struct sockaddr in_generic;
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_addr;
  socklen_t len;

  len = sizeof(native_addr);

  if(local == TRUE)
    getsockname(socket, &amp;native_addr.in_generic, &amp;len);
  else
    getpeername(socket, &amp;native_addr.in_generic, &amp;len);

  switch(native_addr.in_generic.sa_family)
  {
  case AF_INET:
    if(address != NULL)
      *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in.sin_port);
    break;
  case AF_INET6:
    if(address != NULL)
      *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in6.sin6_port);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
infd_tcp_server_system_error(InfdTcpServer* server,
                             int code)
{
  GError* error;
  error = NULL;

  inf_native_socket_make_error(code, &amp;error);

  g_signal_emit(G_OBJECT(server), tcp_server_signals[ERROR_], 0, error);
  g_error_free(error);
}

static void
infd_tcp_server_io(InfNativeSocket* socket,
                   InfIoEvent events,
                   gpointer user_data)
{
  InfdTcpServer* server;
  InfdTcpServerPrivate* priv;
  socklen_t len;
  InfNativeSocket new_socket;
  int errcode;
  InfTcpConnection* connection;
  GError* error;

  union {
    struct sockaddr in_generic;
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_addr;

  InfIpAddress* address;
  guint port;

  server = INFD_TCP_SERVER(user_data);
  priv = INFD_TCP_SERVER_PRIVATE(server);
  g_object_ref(G_OBJECT(server));

  if(events &amp; INF_IO_ERROR)
  {
    len = sizeof(int);
#ifdef G_OS_WIN32
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
#else
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
#endif
    /* TODO: Verify that we get senseful error codes here */
    infd_tcp_server_system_error(server, errcode);
  }
  else if(events &amp; INF_IO_INCOMING)
  {
    do
    {
      /* Note that we do not do anything with native_addr and len. This is
       * currently only for debugging purposes since there seemingly was a
       * case where accept returned a valid but socket and errno was set to
       * EAGAIN (which might have been resulted from a previous call however
       * since the errno = 0 line was not there yet before that either).
       * I hope to get some more information this way in case this occurs
       * again. */
#ifndef G_OS_WIN32
      errno = 0;
#endif
      len = sizeof(native_addr);
      new_socket = accept(priv-&gt;socket, &amp;native_addr.in_generic, &amp;len);
      errcode = INF_NATIVE_SOCKET_LAST_ERROR;

      if(new_socket == INVALID_SOCKET &amp;&amp;
         errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
         errcode != INF_NATIVE_SOCKET_EAGAIN)
      {
        infd_tcp_server_system_error(server, errcode);
      }
      else if(new_socket != INVALID_SOCKET)
      {
        switch(native_addr.in_generic.sa_family)
        {
        case AF_INET:
          address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
          port = ntohs(native_addr.in.sin_port);
          break;
        case AF_INET6:
          address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
          port = ntohs(native_addr.in6.sin6_port);
          break;
        default:
          g_assert_not_reached();
          break;
        }

        error = NULL;
        connection = _inf_tcp_connection_accepted(
          priv-&gt;io,
          new_socket,
          address,
          port,
          &amp;priv-&gt;keepalive,
          &amp;error
        );

        /* _inf_tcp_connection_accepted() takes ownership of address */

        if(connection != NULL)
        {
          g_signal_emit(
            G_OBJECT(server),
            tcp_server_signals[NEW_CONNECTION],
            0,
            connection
          );

          g_object_unref(connection);
        }
        else
        {
          g_signal_emit(
            G_OBJECT(server),
            tcp_server_signals[ERROR_],
            0,
            error
          );

          g_error_free(error);
          closesocket(new_socket);
        }
      }
    } while( (new_socket != INVALID_SOCKET ||
              (new_socket == INVALID_SOCKET &amp;&amp;
               errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
             (priv-&gt;socket != INVALID_SOCKET));
  }

  g_object_unref(G_OBJECT(server));
}

static void
infd_tcp_server_init(InfdTcpServer* server)
{
  InfdTcpServerPrivate* priv;
  priv = INFD_TCP_SERVER_PRIVATE(server);

  priv-&gt;io = NULL;

  priv-&gt;socket = INVALID_SOCKET;
  priv-&gt;status = INFD_TCP_SERVER_CLOSED;

  priv-&gt;local_address = NULL;
  priv-&gt;local_port = 0;

  priv-&gt;keepalive.mask = 0;
}

static void
infd_tcp_server_dispose(GObject* object)
{
  InfdTcpServer* server;
  InfdTcpServerPrivate* priv;

  server = INFD_TCP_SERVER(object);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  if(priv-&gt;status != INFD_TCP_SERVER_CLOSED)
    infd_tcp_server_close(server);

  if(priv-&gt;io  != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(infd_tcp_server_parent_class)-&gt;dispose(object);
}

static void
infd_tcp_server_finalize(GObject* object)
{
  InfdTcpServer* server;
  InfdTcpServerPrivate* priv;

  server = INFD_TCP_SERVER(object);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  if(priv-&gt;local_address != NULL)
    inf_ip_address_free(priv-&gt;local_address);

  G_OBJECT_CLASS(infd_tcp_server_parent_class)-&gt;finalize(object);
}

static void
infd_tcp_server_set_property(GObject* object,
                             guint prop_id,
                             const GValue* value,
                             GParamSpec* pspec)
{
  InfdTcpServer* server;
  InfdTcpServerPrivate* priv;

  server = INFD_TCP_SERVER(object);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
    if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_LOCAL_ADDRESS:
    g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
    if(priv-&gt;local_address != NULL)
      inf_ip_address_free(priv-&gt;local_address);
    priv-&gt;local_address = (InfIpAddress*)g_value_dup_boxed(value);
    break;
  case PROP_LOCAL_PORT:
    g_assert(priv-&gt;status == INFD_TCP_SERVER_CLOSED);
    priv-&gt;local_port = g_value_get_uint(value);
    break;
<A NAME="0"></A>  case PROP_KEEPALIVE:
    g_assert(g_value_get_boxed(value) != NULL);
    priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1270-1.html#0',3,'match1270-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infd_tcp_server_get_property(GObject* object,
                             guint prop_id,
                             GValue* value,
                             GParamSpec* pspec)
{
  InfdTcpServer* server;
  InfdTcpServerPrivate* priv;

  server = INFD_TCP_SERVER(object);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;</B></FONT>
  case PROP_LOCAL_ADDRESS:
    g_value_set_static_boxed(value, priv-&gt;local_address);
    break;
  case PROP_LOCAL_PORT:
    g_value_set_uint(value, priv-&gt;local_port);
    break;
  case PROP_KEEPALIVE:
    g_value_set_boxed(value, &amp;priv-&gt;keepalive);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infd_tcp_server_error(InfdTcpServer* server,
                      GError* error)
{
  InfdTcpServerPrivate* priv;
  priv = INFD_TCP_SERVER_PRIVATE(server);

  if(priv-&gt;status == INFD_TCP_SERVER_OPEN)
  {
    g_assert(priv-&gt;watch != NULL);
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }

  if(priv-&gt;socket != INVALID_SOCKET)
  {
    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
  }

  if(priv-&gt;status != INFD_TCP_SERVER_CLOSED)
  {
<A NAME="1"></A>    priv-&gt;status = INFD_TCP_SERVER_CLOSED;
    g_object_notify(G_OBJECT(server), &quot;status&quot;);
  }
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1270-1.html#1',3,'match1270-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
infd_tcp_server_class_init(InfdTcpServerClass* tcp_server_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(tcp_server_class);

  object_class-&gt;dispose = infd_tcp_server_dispose;
  object_class-&gt;finalize = infd_tcp_server_finalize;
  object_class-&gt;set_property = infd_tcp_server_set_property;
  object_class-&gt;get_property = infd_tcp_server_get_property;

  tcp_server_class-&gt;new_connection = NULL;
  tcp_server_class-&gt;error = infd_tcp_server_error;</B></FONT>

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;IO&quot;,
      &quot;I/O handler&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      &quot;status&quot;,
      &quot;Status&quot;,
      &quot;Status of the TCP server&quot;,
      INFD_TYPE_TCP_SERVER_STATUS,
      INFD_TCP_SERVER_CLOSED,
      G_PARAM_READABLE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LOCAL_ADDRESS,
    g_param_spec_boxed(
      &quot;local-address&quot;,
      &quot;Local address&quot;,
      &quot;Address to bind to&quot;,
      INF_TYPE_IP_ADDRESS,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LOCAL_PORT,
    g_param_spec_uint(
      &quot;local-port&quot;,
      &quot;Local port&quot;,
      &quot;Port to bind to&quot;,
      0,
      65535,
      0,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_KEEPALIVE,
    g_param_spec_boxed(
      &quot;keepalive&quot;,
      &quot;Keepalive&quot;,
      &quot;Keepalive settings for accepted connections&quot;,
      INF_TYPE_KEEPALIVE,
      G_PARAM_READWRITE
    )
  );

  tcp_server_signals[NEW_CONNECTION] = g_signal_new(
    &quot;new-connection&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdTcpServerClass, new_connection),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_TCP_CONNECTION
  );

  tcp_server_signals[ERROR_] = g_signal_new(
    &quot;error&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdTcpServerClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}

/**
 * infd_tcp_server_bind:
 * @server: A #InfdTcpServer.
 * @error: Location to store error information, if any.
 *
 * Binds the server to the address and port given by the
 * #InfdTcpServer:local-address and #InfdTcpServer:local-port properties. If
 * the former is %NULL, it will bind on all interfaces on IPv4. If the latter
 * is 0, a random available port will be assigned. If the function fails,
 * %FALSE is returned and an error is set.
 *
 * @server must be in %INFD_TCP_SERVER_CLOSED state for this function to be
 * called.
 *
 * Returns: %TRUE on success, or %FALSE if an error occurred.
 */
gboolean
infd_tcp_server_bind(InfdTcpServer* server,
                     GError** error)
{
  InfdTcpServerPrivate* priv;

  union {
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_address;

  struct sockaddr* addr;
  socklen_t addrlen;

#if !defined(G_OS_WIN32) &amp;&amp; defined(HAVE_SO_REUSEADDR)
  int value;
#endif

  g_return_val_if_fail(INFD_IS_TCP_SERVER(server), FALSE);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  g_return_val_if_fail(priv-&gt;status == INFD_TCP_SERVER_CLOSED, FALSE);

  if(priv-&gt;local_address == NULL)
  {
    priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    addr = (struct sockaddr*)&amp;native_address.in;
    addrlen = sizeof(struct sockaddr_in);

    native_address.in.sin_addr.s_addr = INADDR_ANY;
    native_address.in.sin_family = AF_INET;
    native_address.in.sin_port = htons(priv-&gt;local_port);
  }
  else
  {
    switch(inf_ip_address_get_family(priv-&gt;local_address))
    {
    case INF_IP_ADDRESS_IPV4:
      priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
      addr = (struct sockaddr*)&amp;native_address.in;
      addrlen = sizeof(struct sockaddr_in);

      memcpy(
        &amp;native_address.in.sin_addr,
        inf_ip_address_get_raw(priv-&gt;local_address),
        sizeof(struct in_addr)
      );

      native_address.in.sin_family = AF_INET;
      native_address.in.sin_port = htons(priv-&gt;local_port);
      break;
    case INF_IP_ADDRESS_IPV6:
      priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
      addr = (struct sockaddr*)&amp;native_address.in6;
      addrlen = sizeof(struct sockaddr_in6);

      memcpy(
        &amp;native_address.in6.sin6_addr,
        inf_ip_address_get_raw(priv-&gt;local_address),
        sizeof(struct in6_addr)
      );

      native_address.in6.sin6_family = AF_INET6;
      native_address.in6.sin6_port = htons(priv-&gt;local_port);
      native_address.in6.sin6_flowinfo = 0;
      native_address.in6.sin6_scope_id = 0;
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }

  if(priv-&gt;socket == INVALID_SOCKET)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    return FALSE;
  }

#if !defined(G_OS_WIN32) &amp;&amp; defined(HAVE_SO_REUSEADDR)
  /* Allow fast restarts of servers by enabling SO_REUSEADDR */
  value = 1;

  if(setsockopt(priv-&gt;socket, SOL_SOCKET, SO_REUSEADDR, &amp;value,
      sizeof(int)) == -1)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);

    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
    return FALSE;
  }
#endif

  if(bind(priv-&gt;socket, addr, addrlen) == -1)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);

    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
    return FALSE;
  }

  g_object_freeze_notify(G_OBJECT(server));

  /* Is assigned a few lines below, but notifications are frozen currently
   * anyway... this saves us a temporary variable here. */
  if(priv-&gt;local_port == 0) g_object_notify(G_OBJECT(server), &quot;local-port&quot;);

  if(priv-&gt;local_address != NULL)
  {
    infd_tcp_server_addr_info(
      priv-&gt;socket,
      TRUE,
      NULL,
      &amp;priv-&gt;local_port
    );
  }
  else
  {
    infd_tcp_server_addr_info(
      priv-&gt;socket,
      TRUE,
      &amp;priv-&gt;local_address,
      &amp;priv-&gt;local_port
    );

    g_object_notify(G_OBJECT(server), &quot;local-address&quot;);
  }

  g_object_notify(G_OBJECT(server), &quot;local-port&quot;);

  priv-&gt;status = INFD_TCP_SERVER_BOUND;
  g_object_notify(G_OBJECT(server), &quot;status&quot;);

  g_object_thaw_notify(G_OBJECT(server));
  return TRUE;
}

/**
 * infd_tcp_server_open:
 * @server: A #InfdTcpServer.
 * @error: Location to store error information.
 *
 * Attempts to open @server. This means binding its local address and port
 * if not already (see infd_tcp_server_bind()) and accepting incoming
 * connections.
 *
 * @server needs to be in %INFD_TCP_SERVER_CLOSED or %INFD_TCP_SERVER_BOUND
 * status for this function to be called. If @server's status is
 * %INFD_TCP_SERVER_CLOSED, then infd_tcp_server_bind() is called before
 * actually opening the server.
 *
 * Returns: %TRUE on success, or %FALSE if an error occurred.
 **/
gboolean
infd_tcp_server_open(InfdTcpServer* server,
                     GError** error)
{
  InfdTcpServerPrivate* priv;
  gboolean was_bound;

#ifdef G_OS_WIN32
  u_long argp;
#else
  int result;
#endif

  g_return_val_if_fail(INFD_IS_TCP_SERVER(server), FALSE);
  priv = INFD_TCP_SERVER_PRIVATE(server);

  g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
  g_return_val_if_fail(priv-&gt;status != INFD_TCP_SERVER_OPEN, FALSE);
  g_assert(priv-&gt;watch == NULL);

  g_object_freeze_notify(G_OBJECT(server));

  was_bound = (priv-&gt;status != INFD_TCP_SERVER_CLOSED);
  if(!was_bound)
  {
    if(!infd_tcp_server_bind(server, error))
    {
      g_object_thaw_notify(G_OBJECT(server));
      return FALSE;
    }
  }

  /* TODO: Should move this code to InfNativeSocket, so that it can be
   * shared with InfTcpConnection */
#ifndef G_OS_WIN32
  result = fcntl(priv-&gt;socket, F_GETFL);
  if(result == -1)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    if(!was_bound)
      infd_tcp_server_close(server);
    g_object_thaw_notify(G_OBJECT(server));
    return FALSE;
  }

  if(fcntl(priv-&gt;socket, F_SETFL, result | O_NONBLOCK) == -1)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    if(!was_bound)
      infd_tcp_server_close(server);
    g_object_thaw_notify(G_OBJECT(server));
    return FALSE;
  }
#else
  argp = 1;
  if(ioctlsocket(priv-&gt;socket, FIONBIO, &amp;argp) != 0)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    if(!was_bound)
      infd_tcp_server_close(server);
    g_object_thaw_notify(G_OBJECT(server));
    return FALSE;
  }
#endif

  if(listen(priv-&gt;socket, 5) == -1)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    if(!was_bound)
      infd_tcp_server_close(server);
    g_object_thaw_notify(G_OBJECT(server));
    return FALSE;
  }

  priv-&gt;watch = inf_io_add_watch(
    priv-&gt;io,
    &amp;priv-&gt;socket,
    INF_IO_INCOMING | INF_IO_ERROR,
    infd_tcp_server_io,
    server,
    NULL
  );

  priv-&gt;status = INFD_TCP_SERVER_OPEN;

  g_object_notify(G_OBJECT(server), &quot;status&quot;);
  g_object_thaw_notify(G_OBJECT(server));

  return TRUE;
}

/**
 * infd_tcp_server_close:
 * @server: A #InfdTcpServer.
 *
 * Closes a TCP server that is open or bound.
 **/
void
infd_tcp_server_close(InfdTcpServer* server)
{
  InfdTcpServerPrivate* priv;

  g_return_if_fail(INFD_IS_TCP_SERVER(server));

  priv = INFD_TCP_SERVER_PRIVATE(server);
  g_return_if_fail(priv-&gt;status != INFD_TCP_SERVER_CLOSED);

  if(priv-&gt;status == INFD_TCP_SERVER_OPEN)
  {
    g_assert(priv-&gt;watch != NULL);
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }

  closesocket(priv-&gt;socket);
  priv-&gt;socket = INVALID_SOCKET;

  priv-&gt;status = INFD_TCP_SERVER_CLOSED;
  g_object_notify(G_OBJECT(server), &quot;status&quot;);
}

/**
 * infd_tcp_server_set_keepalive:
 * @server: A #InfdTcpServer.
 * @keepalive: The keepalive settings for accepted connections.
 *
 * Sets the keepalive settings for new connections accepted by the server.
 */
void
infd_tcp_server_set_keepalive(InfdTcpServer* server,
                              const InfKeepalive* keepalive)
{
  g_return_if_fail(INFD_IS_TCP_SERVER(server));
  g_return_if_fail(keepalive != NULL);

  INFD_TCP_SERVER_PRIVATE(server)-&gt;keepalive = *keepalive;
}

/**
 * infd_tcp_server_get_keepalive:
 * @server: A #InfdTcpServer.
 *
 * Obtains the current keepalive settings for accepted connections.
 *
 * Returns: A #InfKeepalive representing the keepalive configuration for
 * accepted connections, owned by @server.
 */
const InfKeepalive*
infd_tcp_server_get_keepalive(InfdTcpServer* server)
{
  g_return_val_if_fail(INFD_IS_TCP_SERVER(server), NULL);
  return &amp;INFD_TCP_SERVER_PRIVATE(server)-&gt;keepalive;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-move-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-move-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;

#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

typedef struct _InfTextMoveOperationPrivate InfTextMoveOperationPrivate;
struct _InfTextMoveOperationPrivate {
  guint position;
  gint length;
};

enum {
  PROP_0,

  PROP_POSITION,
  PROP_LENGTH
};

#define INF_TEXT_MOVE_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_MOVE_OPERATION, InfTextMoveOperationPrivate))

static void inf_text_move_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextMoveOperation, inf_text_move_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextMoveOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_move_operation_operation_iface_init))

static void
inf_text_move_operation_init(InfTextMoveOperation* operation)
{
  InfTextMoveOperationPrivate* priv;
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  priv-&gt;position = 0;
  priv-&gt;length = 0;
}

static void
inf_text_move_operation_set_property(GObject* object,
                                     guint prop_id,
                                     const GValue* value,
                                     GParamSpec* pspec)
{
  InfTextMoveOperation* operation;
  InfTextMoveOperationPrivate* priv;

  operation = INF_TEXT_MOVE_OPERATION(object);
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    priv-&gt;position = g_value_get_uint(value);
<A NAME="0"></A>    break;
  case PROP_LENGTH:
    priv-&gt;length = g_value_get_int(value);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1270-0.html#0',2,'match1270-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_move_operation_get_property(GObject* object,
                                     guint prop_id,
                                     GValue* value,
                                     GParamSpec* pspec)
{
  InfTextMoveOperation* operation;
  InfTextMoveOperationPrivate* priv;

  operation = INF_TEXT_MOVE_OPERATION(object);
  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_LENGTH:
    g_value_set_int(value, priv-&gt;length);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_move_operation_need_concurrency_id(InfAdoptedOperation* operation,
                                            InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
  return FALSE;
}

static InfAdoptedOperation*
inf_text_move_operation_transform(InfAdoptedOperation* operation,
                                  InfAdoptedOperation* against,
                                  InfAdoptedOperation* operation_lcs,
                                  InfAdoptedOperation* against_lcs,
                                  gint concurrency_id)
{
  InfTextMoveOperationPrivate* priv;
  guint new_pos;
  gint new_len;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);
  new_pos = priv-&gt;position;
  new_len = priv-&gt;length;

  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    inf_text_move_operation_transform_insert(
      inf_text_insert_operation_get_position(
        INF_TEXT_INSERT_OPERATION(against)
      ),
      inf_text_insert_operation_get_length(
        INF_TEXT_INSERT_OPERATION(against)
      ),
      &amp;new_pos,
      &amp;new_len,
      TRUE /* left gravity */
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    inf_text_move_operation_transform_delete(
      inf_text_delete_operation_get_position(
        INF_TEXT_DELETE_OPERATION(against)
      ),
      inf_text_delete_operation_get_length(
        INF_TEXT_DELETE_OPERATION(against)
      ),
      &amp;new_pos,
      &amp;new_len
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }

  return INF_ADOPTED_OPERATION(
    g_object_new(
      INF_TEXT_TYPE_MOVE_OPERATION,
      &quot;position&quot;, new_pos,
      &quot;length&quot;, new_len,
      NULL
    )
  );
}

static InfAdoptedOperation*
inf_text_move_operation_copy(InfAdoptedOperation* operation)
{
  InfTextMoveOperationPrivate* priv;
  GObject* object;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);

  object = g_object_new(
    INF_TEXT_TYPE_MOVE_OPERATION,
    &quot;position&quot;, priv-&gt;position,
    &quot;length&quot;, priv-&gt;length,
    NULL
  );

  return INF_ADOPTED_OPERATION(object);
}

static InfAdoptedOperationFlags
inf_text_move_operation_get_flags(InfAdoptedOperation* operation)
{
  /* Does not affect the buffer */
  return 0;
}

static gboolean
inf_text_move_operation_apply(InfAdoptedOperation* operation,
                              InfAdoptedUser* by,
                              InfBuffer* buffer,
                              GError** error)
{
  InfTextMoveOperationPrivate* priv;
  guint length;

  g_assert(INF_TEXT_IS_MOVE_OPERATION(operation));
  g_assert(INF_TEXT_IS_USER(by));

  priv = INF_TEXT_MOVE_OPERATION_PRIVATE(operation);  
  length = inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer));

  if(priv-&gt;position &gt; length ||
     priv-&gt;position + priv-&gt;length &gt; length)
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string(&quot;INF_TEXT_OPERATION_ERROR&quot;),
      INF_TEXT_OPERATION_ERROR_INVALID_MOVE,
      _(&quot;Attempt to move cursor or selection beyond the end of the document&quot;)
    );

    return FALSE;
  }
  else
  {
    inf_text_user_set_selection(
      INF_TEXT_USER(by),
      priv-&gt;position,
      priv-&gt;length,
      TRUE /* explicit move request */
    );

    return TRUE;
  }
}

static void
inf_text_move_operation_class_init(
  InfTextMoveOperationClass* move_operation_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(move_operation_class);

  object_class-&gt;set_property = inf_text_move_operation_set_property;
  object_class-&gt;get_property = inf_text_move_operation_get_property;

  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      &quot;position&quot;,
      &quot;Position&quot;,
      &quot;Position where to place the user's caret at&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_LENGTH,
    g_param_spec_int(
      &quot;length&quot;,
      &quot;Length&quot;,
      &quot;The number of characters of the selected text&quot;,
      G_MININT,
      G_MAXINT,
      0,
<A NAME="1"></A>      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1270-0.html#1',2,'match1270-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

static void
inf_text_move_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id = inf_text_move_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_move_operation_transform;
  iface-&gt;copy = inf_text_move_operation_copy;
  iface-&gt;get_flags = inf_text_move_operation_get_flags;
  iface-&gt;apply = inf_text_move_operation_apply;
  iface-&gt;apply_transformed = NULL;
  iface-&gt;revert = NULL;</B></FONT>
}

/**
 * inf_text_move_operation_new: (constructor)
 * @position: The position to place the user's caret at.
 * @length: The number of characters to select. Negative means selection
 * towards the beginning of the buffer.
 *
 * Creates a new move operation that, when applied, changes the caret and
 * selection of the applying user.
 *
 * Returns: (transfer full): A new #InfTextMoveOperation.
 **/
InfTextMoveOperation*
inf_text_move_operation_new(guint position,
                            gint length)
{
  GObject* object;

  object = g_object_new(
    INF_TEXT_TYPE_MOVE_OPERATION,
    &quot;position&quot;, position,
    &quot;length&quot;, length,
    NULL
  );

  return INF_TEXT_MOVE_OPERATION(object);
}

/**
 * inf_text_move_operation_get_position:
 * @operation: A #InfTextMoveOperation.
 *
 * Returns the position at which @operation places the user's cursor.
 *
 * Returns: The position of @operation.
 **/
guint
inf_text_move_operation_get_position(InfTextMoveOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
  return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;position;
}

/**
 * inf_text_move_operation_get_length:
 * @operation: A #InfTextMoveOperation.
 *
 * Returns the length to which @operation changes the user's selection.
 * Negative means selection towards the beginning of the buffer.
 *
 * Returns: The length of @operation.
 **/
gint
inf_text_move_operation_get_length(InfTextMoveOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_MOVE_OPERATION(operation), 0);
  return INF_TEXT_MOVE_OPERATION_PRIVATE(operation)-&gt;length;
}

/**
 * inf_text_move_operation_transform_insert:
 * @insert_position: The position at which text is inserted.
 * @insert_length: The number of inserted characters.
 * @move_position: (inout): Points to the character offset to which the caret
 * is moved.
 * @move_length: (inout): Points to the number of characters selected.
 * Negative means towards the beginning.
 * @left_gravity: Whether the move position and length have left gravity.
 *
 * Changes *@move_position and *@move_length so that they point to the same
 * region when @insert_length characters are inserted at @insert_position.
 *
 * If text is inserted at the same position as @move_position, then
 * @move_position is kept at the position it currently is if @left_gravity is
 * %TRUE, otherwise it is shifted to the right.
 *
 * If *@move_length is nonzero, then the selection length is never enlarged if
 * text is inserted at the selection bounds, not depending on whether
 * @left_gravity is set or not.
 **/
void
inf_text_move_operation_transform_insert(guint insert_position,
                                         guint insert_length,
                                         guint* move_position,
                                         gint* move_length,
                                         gboolean left_gravity)
{
  guint cur_pos;
  guint cur_bound;
  
  g_return_if_fail(move_position != NULL);
  g_return_if_fail(move_length != NULL);

  cur_pos = *move_position;
  cur_bound = *move_position + *move_length;

  if(cur_pos == cur_bound)
  {
    if( (insert_position &lt; cur_pos) ||
        (insert_position == cur_pos &amp;&amp; !left_gravity))
    {
      cur_pos += insert_length;
      cur_bound += insert_length;
    }
  }
  else
  {
    if(cur_bound &gt; cur_pos)
    {
      if(insert_position &lt;= cur_pos)
      {
        cur_pos += insert_length;
        cur_bound += insert_length;
      }
      else if(insert_position &lt; cur_bound)
      {
        cur_bound += insert_length;
      }
    }
    else
    {
      if(insert_position &lt;= cur_bound)
      {
        cur_pos += insert_length;
        cur_bound += insert_length;
      }
      else if(insert_position &lt; cur_pos)
      {
        cur_pos += insert_length;
      }
    }
  }

  *move_position = cur_pos;
  *move_length = (gint)cur_bound - (gint)cur_pos;
}

/**
 * inf_text_move_operation_transform_delete:
 * @delete_position: The position at which text is deleted.
 * @delete_length: The number of deleted characters.
 * @move_position: (inout): Points to the character offset to which the caret
 * is moved.
 * @move_length: (inout): Points to the number of characters selected.
 * Negative means towards the beginning.
 *
 * Changes *@move_position and *@move_length so that they point to the same
 * region when @delete_length characters are deleted starting from
 * @delete_position.
 **/
void
inf_text_move_operation_transform_delete(guint delete_position,
                                         guint delete_length,
                                         guint* move_position,
                                         gint* move_length)
{
  guint cur_pos;
  gint cur_len;

  g_return_if_fail(move_position != NULL);
  g_return_if_fail(move_length != NULL);

  cur_pos = *move_position;
  cur_len = *move_length;

  if(cur_pos &gt;= delete_position + delete_length)
    *move_position = cur_pos - delete_length;
  else if(cur_pos &gt; delete_position)
    *move_position = delete_position;
  else
    *move_position = cur_pos;

  if(cur_len &lt; 0)
  {
    if(delete_position + delete_length &lt;= cur_pos + cur_len)
    {
      *move_length = cur_len;
    }
    else if(delete_position &gt;= cur_pos)
    {
      *move_length = cur_len;
    }
    else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt;= cur_pos)
    {
      *move_length = 0;
    }
    else if(delete_position &lt;= cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt; cur_pos + cur_len)
    {
      *move_length = -(gint)(cur_pos - (delete_position + delete_length));
    }
    else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &gt; cur_pos)
    {
      *move_length = delete_position - (cur_pos + cur_len);
    }
    else if(delete_position &gt; cur_pos + cur_len &amp;&amp;
            delete_position + delete_length &lt;= cur_pos)
    {
      *move_length = cur_len + (gint)delete_length;
    }
    else
    {
      g_assert_not_reached();
    }
  }
  else
  {
    if(delete_position + delete_length &lt;= cur_pos)
    {
      *move_length = cur_len;
    }
    else if(delete_position &gt;= cur_pos + cur_len)
    {
      *move_length = cur_len;
    }
    else if(delete_position &lt;= cur_pos &amp;&amp;
            delete_position + delete_length &gt;= cur_pos + cur_len)
    {
      *move_length = 0;
    }
    else if(delete_position &lt;= cur_pos &amp;&amp;
            delete_position + delete_length &gt; cur_pos)
    {
      *move_length = cur_pos + cur_len - (delete_position + delete_length);
    }
    else if(delete_position &gt; cur_pos &amp;&amp;
             delete_position + delete_length &gt; cur_pos + cur_len)
    {
      *move_length = cur_pos - delete_position;
    }
    else if(delete_position &gt; cur_pos &amp;&amp;
            delete_position + delete_length &lt;= cur_pos + cur_len)
    {
      *move_length = cur_len - delete_length;
    }
    else
    {
      g_assert_not_reached();
    }
  }
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
