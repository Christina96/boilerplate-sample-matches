
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/xml.h"
4  #include "private/private.h"
5  #include "private/misc.h"
6  #include "private/debug.h"
7  #include <math.h>
8  int
9  hwloc__xml_verbose(void)
10  {
11    static int checked = 0;
12    static int verbose = 0;
13    if (!checked) {
14      const char *env = getenv("HWLOC_XML_VERBOSE");
15      if (env)
16        verbose = atoi(env);
17      checked = 1;
18    }
19    return verbose;
20  }
21  static int
22  hwloc_nolibxml_import(void)
23  {
24    static int checked = 0;
25    static int nolibxml = 0;
26    if (!checked) {
27      const char *env = getenv("HWLOC_LIBXML");
28      if (env) {
29        nolibxml = !atoi(env);
30      } else {
31        env = getenv("HWLOC_LIBXML_IMPORT");
32        if (env)
33  	nolibxml = !atoi(env);
34      }
35      checked = 1;
36    }
37    return nolibxml;
38  }
39  static int
40  hwloc_nolibxml_export(void)
41  {
42    static int checked = 0;
43    static int nolibxml = 0;
44    if (!checked) {
45      const char *env = getenv("HWLOC_LIBXML");
46      if (env) {
47        nolibxml = !atoi(env);
48      } else {
49        env = getenv("HWLOC_LIBXML_EXPORT");
50        if (env)
51  	nolibxml = !atoi(env);
52      }
53      checked = 1;
54    }
55    return nolibxml;
56  }
57  #define BASE64_ENCODED_LENGTH(length) (4*(((length)+2)/3))
58  static struct hwloc_xml_callbacks *hwloc_nolibxml_callbacks = NULL, *hwloc_libxml_callbacks = NULL;
59  void
60  hwloc_xml_callbacks_register(struct hwloc_xml_component *comp)
61  {
62    if (!hwloc_nolibxml_callbacks)
63      hwloc_nolibxml_callbacks = comp->nolibxml_callbacks;
64    if (!hwloc_libxml_callbacks)
65      hwloc_libxml_callbacks = comp->libxml_callbacks;
66  }
67  void
68  hwloc_xml_callbacks_reset(void)
69  {
70    hwloc_nolibxml_callbacks = NULL;
71    hwloc_libxml_callbacks = NULL;
72  }
73  #define _HWLOC_OBJ_CACHE_OLD (HWLOC_OBJ_TYPE_MAX+1) &bsol;* temporarily used when importing pre-v2.0 attribute-less cache types */
74  #define _HWLOC_OBJ_FUTURE    (HWLOC_OBJ_TYPE_MAX+2) &bsol;* temporarily used when ignoring future types */
75  static void
76  hwloc__xml_import_object_attr(struct hwloc_topology *topology,
77  			      struct hwloc_xml_backend_data_s *data,
78  			      struct hwloc_obj *obj,
79  			      const char *name, const char *value,
80  			      hwloc__xml_import_state_t state,
81  			      int *ignore)
82  {
83    if (!strcmp(name, "type")) {
84      return;
85    }
86    else if (!strcmp(name, "os_index"))
87      obj->os_index = strtoul(value, NULL, 10);
88    else if (!strcmp(name, "gp_index")) {
89      obj->gp_index = strtoull(value, NULL, 10);
90      if (!obj->gp_index && hwloc__xml_verbose())
91        fprintf(stderr, "%s: unexpected zero gp_index, topology may be invalid\n", state->global->msgprefix);
92      if (obj->gp_index >= topology->next_gp_index)
93        topology->next_gp_index = obj->gp_index + 1;
94    } else if (!strcmp(name, "id")) { &bsol;* forward compat */
95      if (!strncmp(value, "obj", 3)) {
96        obj->gp_index = strtoull(value+3, NULL, 10);
97        if (!obj->gp_index && hwloc__xml_verbose())
98          fprintf(stderr, "%s: unexpected zero id, topology may be invalid\n", state->global->msgprefix);
99        if (obj->gp_index >= topology->next_gp_index)
100          topology->next_gp_index = obj->gp_index + 1;
101      } else {
102        if (hwloc__xml_verbose())
103          fprintf(stderr, "%s: unexpected id `%s' not-starting with `obj', ignoring\n", state->global->msgprefix, value);
104      }
105    } else if (!strcmp(name, "cpuset")) {
106      if (!obj->cpuset)
107        obj->cpuset = hwloc_bitmap_alloc();
108      hwloc_bitmap_sscanf(obj->cpuset, value);
109    } else if (!strcmp(name, "complete_cpuset")) {
110      if (!obj->complete_cpuset)
111        obj->complete_cpuset = hwloc_bitmap_alloc();
112      hwloc_bitmap_sscanf(obj->complete_cpuset, value);
113    } else if (!strcmp(name, "allowed_cpuset")) {
114      if (!obj->parent)
115        hwloc_bitmap_sscanf(topology->allowed_cpuset, value);
116    } else if (!strcmp(name, "nodeset")) {
117      if (!obj->nodeset)
118        obj->nodeset = hwloc_bitmap_alloc();
119      hwloc_bitmap_sscanf(obj->nodeset, value);
120    } else if (!strcmp(name, "complete_nodeset")) {
121      if (!obj->complete_nodeset)
122        obj->complete_nodeset = hwloc_bitmap_alloc();
123      hwloc_bitmap_sscanf(obj->complete_nodeset, value);
124    } else if (!strcmp(name, "allowed_nodeset")) {
125      if (!obj->parent)
126        hwloc_bitmap_sscanf(topology->allowed_nodeset, value);
127    } else if (!strcmp(name, "name")) {
128      if (obj->name)
129        free(obj->name);
130      obj->name = strdup(value);
131    } else if (!strcmp(name, "subtype")) {
132      if (obj->subtype)
133        free(obj->subtype);
134      obj->subtype = strdup(value);
135    }
136    else if (!strcmp(name, "cache_size")) {
137      unsigned long long lvalue = strtoull(value, NULL, 10);
138      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
139        obj->attr->cache.size = lvalue;
140      else if (hwloc__xml_verbose())
141        fprintf(stderr, "%s: ignoring cache_size attribute for non-cache object type\n",
142  	      state->global->msgprefix);
143    }
144    else if (!strcmp(name, "cache_linesize")) {
145      unsigned long lvalue = strtoul(value, NULL, 10);
146      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
147        obj->attr->cache.linesize = lvalue;
148      else if (hwloc__xml_verbose())
149        fprintf(stderr, "%s: ignoring cache_linesize attribute for non-cache object type\n",
150  	      state->global->msgprefix);
151    }
152    else if (!strcmp(name, "cache_associativity")) {
153      int lvalue = atoi(value);
154      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
155        obj->attr->cache.associativity = lvalue;
156      else if (hwloc__xml_verbose())
157        fprintf(stderr, "%s: ignoring cache_associativity attribute for non-cache object type\n",
158  	      state->global->msgprefix);
159    }
160    else if (!strcmp(name, "cache_type")) {
161      unsigned long lvalue = strtoul(value, NULL, 10);
162      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE) {
163        if (lvalue == HWLOC_OBJ_CACHE_UNIFIED
164  	  || lvalue == HWLOC_OBJ_CACHE_DATA
165  	  || lvalue == HWLOC_OBJ_CACHE_INSTRUCTION)
166  	obj->attr->cache.type = (hwloc_obj_cache_type_t) lvalue;
167        else
168          if (hwloc__xml_verbose())
169            fprintf(stderr, "%s: ignoring invalid cache_type attribute %lu\n",
170                    state->global->msgprefix, lvalue);
171      } else if (hwloc__xml_verbose())
172        fprintf(stderr, "%s: ignoring cache_type attribute for non-cache object type\n",
173  	      state->global->msgprefix);
174    }
175    else if (!strcmp(name, "local_memory")) {
176      unsigned long long lvalue = strtoull(value, NULL, 10);
177      if (obj->type == HWLOC_OBJ_NUMANODE)
178        obj->attr->numanode.local_memory = lvalue;
179      else if (!obj->parent)
180        topology->machine_memory.local_memory = lvalue;
181      else if (hwloc__xml_verbose())
182        fprintf(stderr, "%s: ignoring local_memory attribute for non-NUMAnode non-root object\n",
183  	      state->global->msgprefix);
184    }
185    else if (!strcmp(name, "depth")) {
186      unsigned long lvalue = strtoul(value, NULL, 10);
187       if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE) {
188  	obj->attr->cache.depth = lvalue;
189       } else if (obj->type == HWLOC_OBJ_GROUP || obj->type == HWLOC_OBJ_BRIDGE) {
190       } else if (hwloc__xml_verbose())
191         fprintf(stderr, "%s: ignoring depth attribute for object type without depth\n",
192  	       state->global->msgprefix);
193    }
194    else if (!strcmp(name, "kind")) {
195      unsigned long lvalue = strtoul(value, NULL, 10);
196      if (obj->type == HWLOC_OBJ_GROUP)
197        obj->attr->group.kind = lvalue;
198      else if (hwloc__xml_verbose())
199        fprintf(stderr, "%s: ignoring kind attribute for non-group object type\n",
200  	      state->global->msgprefix);
201    }
202    else if (!strcmp(name, "subkind")) {
203      unsigned long lvalue = strtoul(value, NULL, 10);
204      if (obj->type == HWLOC_OBJ_GROUP)
205        obj->attr->group.subkind = lvalue;
206      else if (hwloc__xml_verbose())
207        fprintf(stderr, "%s: ignoring subkind attribute for non-group object type\n",
208  	      state->global->msgprefix);
209    }
210    else if (!strcmp(name, "dont_merge")) {
211      unsigned long lvalue = strtoul(value, NULL, 10);
212      if (obj->type == HWLOC_OBJ_GROUP)
213        obj->attr->group.dont_merge = (unsigned char) lvalue;
214      else if (hwloc__xml_verbose())
215        fprintf(stderr, "%s: ignoring dont_merge attribute for non-group object type\n",
216  	      state->global->msgprefix);
217    }
218    else if (!strcmp(name, "pci_busid")) {
219      switch (obj->type) {
220      case HWLOC_OBJ_PCI_DEVICE:
221      case HWLOC_OBJ_BRIDGE: {
222        unsigned domain, bus, dev, func;
223        if (sscanf(value, "%x:%02x:%02x.%01x",
224  		 &domain, &bus, &dev, &func) != 4) {
225  	if (hwloc__xml_verbose())
226  	  fprintf(stderr, "%s: ignoring invalid pci_busid format string %s\n",
227  		  state->global->msgprefix, value);
228  	*ignore = 1;
229  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
230        } else if (domain > 0xffff) {
231  	static int warned = 0;
232  	if (!warned && HWLOC_SHOW_ALL_ERRORS())
233  	  fprintf(stderr, "hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
234  	warned = 1;
235  	*ignore = 1;
236  #endif
237        } else {
238  	obj->attr->pcidev.domain = domain;
239  	obj->attr->pcidev.bus = bus;
240  	obj->attr->pcidev.dev = dev;
241  	obj->attr->pcidev.func = func;
242        }
243        break;
244      }
245      default:
246        if (hwloc__xml_verbose())
247  	fprintf(stderr, "%s: ignoring pci_busid attribute for non-PCI object\n",
248  		state->global->msgprefix);
249        break;
250      }
251    }
252    else if (!strcmp(name, "pci_type")) {
253      switch (obj->type) {
254      case HWLOC_OBJ_PCI_DEVICE:
255      case HWLOC_OBJ_BRIDGE: {
256        unsigned classid, vendor, device, subvendor, subdevice, revision;
257        if (sscanf(value, "%x [%04x:%04x] [%04x:%04x] %02x",
258  		 &classid, &vendor, &device, &subvendor, &subdevice, &revision) != 6) {
259  	if (hwloc__xml_verbose())
260  	  fprintf(stderr, "%s: ignoring invalid pci_type format string %s\n",
261  		  state->global->msgprefix, value);
262        } else {
263  	obj->attr->pcidev.class_id = classid;
264  	obj->attr->pcidev.vendor_id = vendor;
265  	obj->attr->pcidev.device_id = device;
266  	obj->attr->pcidev.subvendor_id = subvendor;
267  	obj->attr->pcidev.subdevice_id = subdevice;
268  	obj->attr->pcidev.revision = revision;
269        }
270        break;
271      }
272      default:
273        if (hwloc__xml_verbose())
274  	fprintf(stderr, "%s: ignoring pci_type attribute for non-PCI object\n",
275  		state->global->msgprefix);
276        break;
277      }
278    }
279    else if (!strcmp(name, "pci_link_speed")) {
280      switch (obj->type) {
281      case HWLOC_OBJ_PCI_DEVICE:
282      case HWLOC_OBJ_BRIDGE: {
283        obj->attr->pcidev.linkspeed = (float) atof(value);
284        break;
285      }
286      default:
287        if (hwloc__xml_verbose())
288  	fprintf(stderr, "%s: ignoring pci_link_speed attribute for non-PCI object\n",
289  		state->global->msgprefix);
290        break;
291      }
292    }
293    else if (!strcmp(name, "bridge_type")) {
294      switch (obj->type) {
295      case HWLOC_OBJ_BRIDGE: {
296        unsigned upstream_type, downstream_type;
297        if (sscanf(value, "%u-%u", &upstream_type, &downstream_type) != 2) {
298  	if (hwloc__xml_verbose())
299  	  fprintf(stderr, "%s: ignoring invalid bridge_type format string %s\n",
300  		  state->global->msgprefix, value);
301        } else {
302  	obj->attr->bridge.upstream_type = (hwloc_obj_bridge_type_t) upstream_type;
303  	obj->attr->bridge.downstream_type = (hwloc_obj_bridge_type_t) downstream_type;
304        };
305        break;
306      }
307      default:
308        if (hwloc__xml_verbose())
309  	fprintf(stderr, "%s: ignoring bridge_type attribute for non-bridge object\n",
310  		state->global->msgprefix);
311        break;
312      }
313    }
314    else if (!strcmp(name, "bridge_pci")) {
315      switch (obj->type) {
316      case HWLOC_OBJ_BRIDGE: {
317        unsigned domain, secbus, subbus;
318        if (sscanf(value, "%x:[%02x-%02x]",
319  		 &domain, &secbus, &subbus) != 3) {
320  	if (hwloc__xml_verbose())
321  	  fprintf(stderr, "%s: ignoring invalid bridge_pci format string %s\n",
322  		  state->global->msgprefix, value);
323  	*ignore = 1;
324  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
325        } else if (domain > 0xffff) {
326  	static int warned = 0;
327  	if (!warned && HWLOC_SHOW_ALL_ERRORS())
328  	  fprintf(stderr, "hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
329  	warned = 1;
330  	*ignore = 1;
331  #endif
332        } else {
333  	obj->attr->bridge.downstream.pci.domain = domain;
334  	obj->attr->bridge.downstream.pci.secondary_bus = secbus;
335  	obj->attr->bridge.downstream.pci.subordinate_bus = subbus;
336        }
337        break;
338      }
339      default:
340        if (hwloc__xml_verbose())
341  	fprintf(stderr, "%s: ignoring bridge_pci attribute for non-bridge object\n",
342  		state->global->msgprefix);
343        break;
344      }
345    }
346    else if (!strcmp(name, "osdev_type")) {
347      switch (obj->type) {
348      case HWLOC_OBJ_OS_DEVICE: {
349        unsigned osdev_type;
350        if (sscanf(value, "%u", &osdev_type) != 1) {
351  	if (hwloc__xml_verbose())
352  	  fprintf(stderr, "%s: ignoring invalid osdev_type format string %s\n",
353  		  state->global->msgprefix, value);
354        } else
355  	obj->attr->osdev.type = (hwloc_obj_osdev_type_t) osdev_type;
356        break;
357      }
358      default:
359        if (hwloc__xml_verbose())
360  	fprintf(stderr, "%s: ignoring osdev_type attribute for non-osdev object\n",
361  		state->global->msgprefix);
362        break;
363      }
364    }
365    else if (data->version_major < 2) {
366      if (!strcmp(name, "os_level")
367  	|| !strcmp(name, "online_cpuset"))
368        { &bsol;* ignored */ }
369      else if (!strcmp(name, "dmi_board_vendor")) {
370        if (value[0])
371  	hwloc_obj_add_info(obj, "DMIBoardVendor", value);
372      }
373      else if (!strcmp(name, "dmi_board_name")) {
374        if (value[0])
375  	hwloc_obj_add_info(obj, "DMIBoardName", value);
376      }
377      else if (data->version_major < 1) {
378        if (!strcmp(name, "memory_kB")) {
379  	unsigned long long lvalue = strtoull(value, NULL, 10);
380  	if (obj->type == _HWLOC_OBJ_CACHE_OLD)
381  	  obj->attr->cache.size = lvalue << 10;
382  	else if (obj->type == HWLOC_OBJ_NUMANODE)
383  	  obj->attr->numanode.local_memory = lvalue << 10;
384  	else if (!obj->parent)
385  	  topology->machine_memory.local_memory = lvalue << 10;
386  	else if (hwloc__xml_verbose())
387  	  fprintf(stderr, "%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n",
388  		  state->global->msgprefix);
389        }
390        else if (!strcmp(name, "huge_page_size_kB")) {
391  	unsigned long lvalue = strtoul(value, NULL, 10);
392  	if (obj->type == HWLOC_OBJ_NUMANODE || !obj->parent) {
393  	  struct hwloc_numanode_attr_s *memory = obj->type == HWLOC_OBJ_NUMANODE ? &obj->attr->numanode : &topology->machine_memory;
394  	  if (!memory->page_types) {
395  	    memory->page_types = malloc(sizeof(*memory->page_types));
396  	    memory->page_types_len = 1;
397  	  }
398  	  assert(memory->page_types);
399  	  memory->page_types[0].size = lvalue << 10;
400  	} else if (hwloc__xml_verbose()) {
401  	  fprintf(stderr, "%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n",
402  		  state->global->msgprefix);
403  	}
404        }
405        else if (!strcmp(name, "huge_page_free")) {
406  	unsigned long lvalue = strtoul(value, NULL, 10);
407  	if (obj->type == HWLOC_OBJ_NUMANODE || !obj->parent) {
408  	  struct hwloc_numanode_attr_s *memory = obj->type == HWLOC_OBJ_NUMANODE ? &obj->attr->numanode : &topology->machine_memory;
409  	  if (!memory->page_types) {
410  	    memory->page_types = malloc(sizeof(*memory->page_types));
411  	    memory->page_types_len = 1;
412  	  }
413  	  assert(memory->page_types);
414  	  memory->page_types[0].count = lvalue;
415  	} else if (hwloc__xml_verbose()) {
416  	  fprintf(stderr, "%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n",
417  		  state->global->msgprefix);
418  	}
419        }
420        else goto unknown;
421      }
422      else goto unknown;
423    }
424    else {
425    unknown:
426      if (hwloc__xml_verbose())
427        fprintf(stderr, "%s: ignoring unknown object attribute %s\n",
428  	      state->global->msgprefix, name);
429    }
430  }
431  static int
432  hwloc___xml_import_info(char **infonamep, char **infovaluep,
433                          hwloc__xml_import_state_t state)
434  {
435    char *infoname = NULL;
436    char *infovalue = NULL;
437    while (1) {
438      char *attrname, *attrvalue;
439      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
440        break;
441      if (!strcmp(attrname, "name"))
442        infoname = attrvalue;
443      else if (!strcmp(attrname, "value"))
444        infovalue = attrvalue;
445      else
446        return -1;
447    }
448    *infonamep = infoname;
449    *infovaluep = infovalue;
450    return state->global->close_tag(state);
451  }
452  static int
453  hwloc__xml_import_obj_info(struct hwloc_xml_backend_data_s *data,
454                             hwloc_obj_t obj,
455                             hwloc__xml_import_state_t state)
456  {
457    char *infoname = NULL;
458    char *infovalue = NULL;
459    int err;
460    err = hwloc___xml_import_info(&infoname, &infovalue, state);
461    if (err < 0)
462      return err;
463    if (infoname) {
464      if (data->version_major < 2 &&
465  	(!strcmp(infoname, "Type") || !strcmp(infoname, "CoProcType"))) {
466        if (infovalue) {
467  	if (obj->subtype)
468  	  free(obj->subtype);
469  	obj->subtype = strdup(infovalue);
470        }
471      } else {
472        if (infovalue)
473  	hwloc_obj_add_info(obj, infoname, infovalue);
474      }
475    }
476    return err;
477  }
478  static int
479  hwloc__xml_import_pagetype(hwloc_topology_t topology __hwloc_attribute_unused, struct hwloc_numanode_attr_s *memory,
480  			   hwloc__xml_import_state_t state)
481  {
482    uint64_t size = 0, count = 0;
483    while (1) {
484      char *attrname, *attrvalue;
485      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
486        break;
487      if (!strcmp(attrname, "size"))
488        size = strtoull(attrvalue, NULL, 10);
489      else if (!strcmp(attrname, "count"))
490        count = strtoull(attrvalue, NULL, 10);
491      else
492        return -1;
493    }
494    if (size) {
495      unsigned idx = memory->page_types_len;
496      struct hwloc_memory_page_type_s *tmp;
497      tmp = realloc(memory->page_types, (idx+1)*sizeof(*memory->page_types));
498      if (tmp) { &bsol;* if failed to allocate, ignore this page_type entry */
499        memory->page_types = tmp;
500        memory->page_types_len = idx+1;
501        memory->page_types[idx].size = size;
502        memory->page_types[idx].count = count;
503      }
504    }
505    return state->global->close_tag(state);
506  }
507  static int
508  hwloc__xml_v1import_distances(struct hwloc_xml_backend_data_s *data,
509  			      hwloc_obj_t obj,
510  			      hwloc__xml_import_state_t state)
511  {
512    unsigned long reldepth = 0, nbobjs = 0;
513    float latbase = 0;
514    char *tag;
515    int ret;
516    while (1) {
517      char *attrname, *attrvalue;
518      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
519        break;
520      if (!strcmp(attrname, "nbobjs"))
521        nbobjs = strtoul(attrvalue, NULL, 10);
522      else if (!strcmp(attrname, "relative_depth"))
523        reldepth = strtoul(attrvalue, NULL, 10);
524      else if (!strcmp(attrname, "latency_base"))
525        latbase = (float) atof(attrvalue);
526      else
527        return -1;
528    }
529    if (nbobjs && reldepth && latbase) {
530      unsigned i;
531      float *matrix;
532      struct hwloc__xml_imported_v1distances_s *v1dist;
533      matrix = malloc(nbobjs*nbobjs*sizeof(float));
534      v1dist = malloc(sizeof(*v1dist));
535      if (!matrix || !v1dist) {
536        if (hwloc__xml_verbose())
537  	fprintf(stderr, "%s: failed to allocate v1distance matrix for %lu objects\n",
538  		state->global->msgprefix, nbobjs);
539        free(v1dist);
540        free(matrix);
541        return -1;
542      }
543      v1dist->kind = HWLOC_DISTANCES_KIND_FROM_OS|HWLOC_DISTANCES_KIND_MEANS_LATENCY;
544      v1dist->nbobjs = nbobjs;
545      v1dist->floats = matrix;
546      for(i=0; i<nbobjs*nbobjs; i++) {
547        struct hwloc__xml_import_state_s childstate;
548        char *attrname, *attrvalue;
549        float val;
550        ret = state->global->find_child(state, &childstate, &tag);
551        if (ret <= 0 || strcmp(tag, "latency")) {
552  	free(matrix);
553  	free(v1dist);
554  	return -1;
555        }
556        ret = state->global->next_attr(&childstate, &attrname, &attrvalue);
557        if (ret < 0 || strcmp(attrname, "value")) {
558  	free(matrix);
559  	free(v1dist);
560  	return -1;
561        }
562        val = (float) atof((char *) attrvalue);
563        matrix[i] = val * latbase;
564        ret = state->global->close_tag(&childstate);
565        if (ret < 0) {
566  	free(matrix);
567  	free(v1dist);
568  	return -1;
569        }
570        state->global->close_child(&childstate);
571      }
572      if (nbobjs < 2) {
573        assert(nbobjs == 1);
574        if (hwloc__xml_verbose())
575  	fprintf(stderr, "%s: ignoring invalid distance matrix with only 1 object\n",
576  		state->global->msgprefix);
577        free(matrix);
578        free(v1dist);
579      } else if (obj->parent) {
580        free(matrix);
581        free(v1dist);
582      } else {
583        v1dist->prev = data->last_v1dist;
584        v1dist->next = NULL;
585        if (data->last_v1dist)
586  	data->last_v1dist->next = v1dist;
587        else
588  	data->first_v1dist = v1dist;
589        data->last_v1dist = v1dist;
590      }
591    }
592    return state->global->close_tag(state);
593  }
594  static int
595  hwloc__xml_import_userdata(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj,
596  			   hwloc__xml_import_state_t state)
597  {
598    size_t length = 0;
599    int encoded = 0;
600    char *name = NULL; &bsol;* optional */
601    int ret;
602    while (1) {
603      char *attrname, *attrvalue;
604      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
605        break;
606      if (!strcmp(attrname, "length"))
607        length = strtoul(attrvalue, NULL, 10);
608      else if (!strcmp(attrname, "encoding"))
609        encoded = !strcmp(attrvalue, "base64");
610      else if (!strcmp(attrname, "name"))
611        name = attrvalue;
612      else
613        return -1;
614    }
615    if (!topology->userdata_import_cb) {
616      const char *buffer;
617      size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
618      ret = state->global->get_content(state, &buffer, reallength);
619      if (ret < 0)
620        return -1;
621    } else if (topology->userdata_not_decoded) {
622        const char *buffer;
623        char *fakename;
624        size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
625        ret = state->global->get_content(state, &buffer, reallength);
626        if (ret < 0)
627          return -1;
628        fakename = malloc(6 + 1 + (name ? strlen(name) : 4) + 1);
629        if (!fakename)
630  	return -1;
631        sprintf(fakename, encoded ? "base64%c%s" : "normal%c%s", name ? ':' : '-', name ? name : "anon");
632        topology->userdata_import_cb(topology, obj, fakename, buffer, length);
633        free(fakename);
634    } else if (encoded && length) {
635        const char *encoded_buffer;
636        size_t encoded_length = BASE64_ENCODED_LENGTH(length);
637        ret = state->global->get_content(state, &encoded_buffer, encoded_length);
638        if (ret < 0)
639          return -1;
640        if (ret) {
641  	char *decoded_buffer = malloc(length+1);
642  	if (!decoded_buffer)
643  	  return -1;
644  	assert(encoded_buffer[encoded_length] == 0);
645  	ret = hwloc_decode_from_base64(encoded_buffer, decoded_buffer, length+1);
646  	if (ret != (int) length) {
647  	  free(decoded_buffer);
648  	  return -1;
649  	}
650  	topology->userdata_import_cb(topology, obj, name, decoded_buffer, length);
651  	free(decoded_buffer);
652        }
653    } else { &bsol;* always handle length==0 in the non-encoded case */
654        const char *buffer = "";
655        if (length) {
656  	ret = state->global->get_content(state, &buffer, length);
657  	if (ret < 0)
658  	  return -1;
659        }
660        topology->userdata_import_cb(topology, obj, name, buffer, length);
661    }
662    state->global->close_content(state);
663    return state->global->close_tag(state);
664  }
665  static void hwloc__xml_import_report_outoforder(hwloc_topology_t topology, hwloc_obj_t new, hwloc_obj_t old)
666  {
667    char *progname = hwloc_progname(topology);
668    const char *origversion = hwloc_obj_get_info_by_name(topology->levels[0][0], "hwlocVersion");
669    const char *origprogname = hwloc_obj_get_info_by_name(topology->levels[0][0], "ProcessName");
670    char *c1, *cc1, t1[64];
671    char *c2 = NULL, *cc2 = NULL, t2[64];
672    hwloc_bitmap_asprintf(&c1, new->cpuset);
673    hwloc_bitmap_asprintf(&cc1, new->complete_cpuset);
674    hwloc_obj_type_snprintf(t1, sizeof(t1), new, 0);
675    if (old->cpuset)
676      hwloc_bitmap_asprintf(&c2, old->cpuset);
677    if (old->complete_cpuset)
678      hwloc_bitmap_asprintf(&cc2, old->complete_cpuset);
679    hwloc_obj_type_snprintf(t2, sizeof(t2), old, 0);
680    fprintf(stderr, "****************************************************************************\n");
681    fprintf(stderr, "* hwloc has encountered an out-of-order XML topology load.\n");
682    fprintf(stderr, "* Object %s cpuset %s complete %s\n",
683  	  t1, c1, cc1);
684    fprintf(stderr, "* was inserted after object %s with %s and %s.\n",
685  	  t2, c2 ? c2 : "none", cc2 ? cc2 : "none");
686    fprintf(stderr, "* The error occured in hwloc %s inside process `%s', while\n",
687  	  HWLOC_VERSION,
688  	  progname ? progname : "<unknown>");
689    if (origversion || origprogname)
690      fprintf(stderr, "* the input XML was generated by hwloc %s inside process `%s'.\n",
691  	    origversion ? origversion : "(unknown version)",
692  	    origprogname ? origprogname : "<unknown>");
693    else
694      fprintf(stderr, "* the input XML was generated by an unspecified ancient hwloc release.\n");
695    fprintf(stderr, "* Please check that your input topology XML file is valid.\n");
696    fprintf(stderr, "* Set HWLOC_DEBUG_CHECK=1 in the environment to detect further issues.\n");
697    fprintf(stderr, "****************************************************************************\n");
698    free(c1);
699    free(cc1);
700    free(c2);
701    free(cc2);
702    free(progname);
703  }
704  static int
705  hwloc__xml_import_object(hwloc_topology_t topology,
706  			 struct hwloc_xml_backend_data_s *data,
707  			 hwloc_obj_t parent, hwloc_obj_t obj, int *gotignored,
708  			 hwloc__xml_import_state_t state)
709  {
710    int ignored = 0;
711    int childrengotignored = 0;
712    int attribute_less_cache = 0;
713    int numa_was_root = 0;
714    char *tag;
715    struct hwloc__xml_import_state_s childstate;
716    obj->parent = parent;
717    while (1) {
718      char *attrname, *attrvalue;
719      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
720        break;
721      if (!strcmp(attrname, "type")) {
722        if (hwloc_type_sscanf(attrvalue, &obj->type, NULL, 0) < 0) {
723  	if (!strcasecmp(attrvalue, "Cache")) {
724  	  obj->type = _HWLOC_OBJ_CACHE_OLD; &bsol;* will be fixed below */
725  	  attribute_less_cache = 1;
726  	} else if (!strcasecmp(attrvalue, "System")) {
727  	  if (!parent)
728  	    obj->type = HWLOC_OBJ_MACHINE;
729  	  else {
730  	    if (hwloc__xml_verbose())
731  	      fprintf(stderr, "%s: obsolete System object only allowed at root\n",
732  		      state->global->msgprefix);
733  	    goto error_with_object;
734  	  }
735  	} else if (!strcasecmp(attrvalue, "Tile")) {
736  	  obj->type = HWLOC_OBJ_GROUP;
737  	  obj->attr->group.kind = HWLOC_GROUP_KIND_INTEL_TILE;
738  	} else if (!strcasecmp(attrvalue, "Module")) {
739  	  obj->type = HWLOC_OBJ_GROUP;
740  	  obj->attr->group.kind = HWLOC_GROUP_KIND_INTEL_MODULE;
741  	} else if (!strcasecmp(attrvalue, "MemCache")) {
742  	  obj->type = _HWLOC_OBJ_FUTURE;
743  	  ignored = 1;
744  	  if (hwloc__xml_verbose())
745  	    fprintf(stderr, "%s: %s object not-supported, will be ignored\n",
746  		    state->global->msgprefix, attrvalue);
747  	} else {
748  	  if (hwloc__xml_verbose())
749  	    fprintf(stderr, "%s: unrecognized object type string %s\n",
750  		    state->global->msgprefix, attrvalue);
751  	  goto error_with_object;
752  	}
753        }
754      } else {
755        if (obj->type == HWLOC_OBJ_TYPE_NONE) {
756  	if (hwloc__xml_verbose())
757  	  fprintf(stderr, "%s: object attribute %s found before type\n",
758  		  state->global->msgprefix,  attrname);
759  	goto error_with_object;
760        }
761        hwloc__xml_import_object_attr(topology, data, obj, attrname, attrvalue, state, &ignored);
762      }
763    }
764    while (1) {
765      int ret;
766      tag = NULL;
767      ret = state->global->find_child(state, &childstate, &tag);
768      if (ret < 0)
769        goto error;
770      if (!ret)
771        break;
772      if (!strcmp(tag, "object")) {
773        break;
774      } else if (!strcmp(tag, "page_type")) {
775        if (obj->type == HWLOC_OBJ_NUMANODE) {
776  	ret = hwloc__xml_import_pagetype(topology, &obj->attr->numanode, &childstate);
777        } else if (!parent) {
778  	ret = hwloc__xml_import_pagetype(topology, &topology->machine_memory, &childstate);
779        } else {
780  	if (hwloc__xml_verbose())
781  	  fprintf(stderr, "%s: invalid non-NUMAnode object child %s\n",
782  		  state->global->msgprefix, tag);
783  	ret = -1;
784        }
785      } else if (!strcmp(tag, "info")) {
786        ret = hwloc__xml_import_obj_info(data, obj, &childstate);
787      } else if (data->version_major < 2 && !strcmp(tag, "distances")) {
788        ret = hwloc__xml_v1import_distances(data, obj, &childstate);
789      } else if (!strcmp(tag, "userdata")) {
790        ret = hwloc__xml_import_userdata(topology, obj, &childstate);
791      } else {
792        if (hwloc__xml_verbose())
793  	fprintf(stderr, "%s: invalid special object child %s\n",
794  		state->global->msgprefix, tag);
795        ret = -1;
796      }
797      if (ret < 0)
798        goto error;
799      state->global->close_child(&childstate);
800    }
801    if (parent && obj->type == HWLOC_OBJ_MACHINE) {
802      obj->type = HWLOC_OBJ_GROUP;
803    }
804    if (parent && data->version_major >= 2) {
805      if (hwloc__obj_type_is_normal(obj->type)) {
806        if (!hwloc__obj_type_is_normal(parent->type)) {
807  	if (hwloc__xml_verbose())
808  	  fprintf(stderr, "normal object %s cannot be child of non-normal parent %s\n",
809  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
810  	goto error_with_object;
811        }
812      } else if (hwloc__obj_type_is_memory(obj->type)) {
813        if (hwloc__obj_type_is_io(parent->type) || HWLOC_OBJ_MISC == parent->type) {
814  	if (hwloc__xml_verbose())
815  	  fprintf(stderr, "Memory object %s cannot be child of non-normal-or-memory parent %s\n",
816  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
817  	goto error_with_object;
818        }
819      } else if (hwloc__obj_type_is_io(obj->type)) {
820        if (hwloc__obj_type_is_memory(parent->type) || HWLOC_OBJ_MISC == parent->type) {
821  	if (hwloc__xml_verbose())
822  	  fprintf(stderr, "I/O object %s cannot be child of non-normal-or-I/O parent %s\n",
823  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
824  	goto error_with_object;
825        }
826      }
827    } else if (parent && data->version_major < 2) {
828      if (hwloc__obj_type_is_normal(obj->type) || HWLOC_OBJ_NUMANODE == obj->type) {
829        if (hwloc__obj_type_is_special(parent->type)) {
830  	if (hwloc__xml_verbose())
831  	  fprintf(stderr, "v1.x normal v1.x object %s cannot be child of special parent %s\n",
832  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
833  	goto error_with_object;
834        }
835      } else if (hwloc__obj_type_is_io(obj->type)) {
836        if (HWLOC_OBJ_MISC == parent->type) {
837  	if (hwloc__xml_verbose())
838  	  fprintf(stderr, "I/O object %s cannot be child of Misc parent\n",
839  		  hwloc_obj_type_string(obj->type));
840  	goto error_with_object;
841        }
842      }
843    }
844    if (data->version_major < 2) {
845      if (parent && parent->type == HWLOC_OBJ_NUMANODE) {
846        parent = parent->parent;
847        assert(parent);
848      }
849      if (obj->type == HWLOC_OBJ_NUMANODE) {
850        if (!parent) {
851  	hwloc_obj_t machine = hwloc_alloc_setup_object(topology, HWLOC_OBJ_MACHINE, HWLOC_UNKNOWN_INDEX);
852  	machine->cpuset = hwloc_bitmap_dup(obj->cpuset);
853  	machine->complete_cpuset = hwloc_bitmap_dup(obj->cpuset);
854  	machine->nodeset = hwloc_bitmap_dup(obj->nodeset);
855  	machine->complete_nodeset = hwloc_bitmap_dup(obj->complete_nodeset);
856  	topology->levels[0][0] = machine;
857  	parent = machine;
858  	numa_was_root = 1;
859        } else if (!hwloc_bitmap_isequal(obj->complete_cpuset, parent->complete_cpuset)) {
860  	int needgroup = 1;
861  	hwloc_obj_t sibling;
862  	sibling = parent->memory_first_child;
863  	if (sibling && !sibling->subtype
864  	    && !sibling->next_sibling
865  	    && obj->subtype && !strcmp(obj->subtype, "MCDRAM")
866  	    && hwloc_bitmap_iszero(obj->complete_cpuset)) {
867  	  needgroup = 0;
868  	}
869  	if (needgroup
870  	    && hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
871  	  hwloc_obj_t group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
872  	  group->gp_index = 0; &bsol;* will be initialized at the end of the discovery once we know the max */
873  	  group->cpuset = hwloc_bitmap_dup(obj->cpuset);
874  	  group->complete_cpuset = hwloc_bitmap_dup(obj->cpuset);
875  	  group->nodeset = hwloc_bitmap_dup(obj->nodeset);
876  	  group->complete_nodeset = hwloc_bitmap_dup(obj->complete_nodeset);
877  	  group->attr->group.kind = HWLOC_GROUP_KIND_MEMORY;
878  	  hwloc_insert_object_by_parent(topology, parent, group);
879  	  parent = group;
880  	}
881        }
882      }
883      if (attribute_less_cache) {
884        assert(obj->type == _HWLOC_OBJ_CACHE_OLD);
885        obj->type = hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type);
886      }
887      if (obj->type == HWLOC_OBJ_MISC && obj->cpuset)
888        obj->type = HWLOC_OBJ_GROUP;
889      if (!obj->cpuset != !obj->complete_cpuset) {
890        if (obj->type == HWLOC_OBJ_GROUP) {
891  	ignored = 1;
892        } else {
893  	if (hwloc__xml_verbose())
894  	  fprintf(stderr, "%s: invalid object %s P#%u with some missing cpusets\n",
895  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
896  	goto error_with_object;
897        }
898      } else if (!obj->nodeset != !obj->complete_nodeset) {
899        if (obj->type == HWLOC_OBJ_GROUP) {
900  	ignored = 1;
901        } else {
902  	if (hwloc__xml_verbose())
903  	  fprintf(stderr, "%s: invalid object %s P#%u with some missing nodesets\n",
904  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
905  	goto error_with_object;
906        }
907      } else if (obj->nodeset && !obj->cpuset) {
908        if (obj->type == HWLOC_OBJ_GROUP) {
909  	ignored = 1;
910        } else {
911  	if (hwloc__xml_verbose())
912  	  fprintf(stderr, "%s: invalid object %s P#%u with either cpuset or nodeset missing\n",
913  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
914  	goto error_with_object;
915        }
916      }
917    }
918    if (obj->type == HWLOC_OBJ_GROUP) {
919      if (obj->attr->group.kind == HWLOC_GROUP_KIND_INTEL_DIE
920  	|| (obj->subtype && !strcmp(obj->subtype, "Die")))
921        obj->type = HWLOC_OBJ_DIE;
922    }
923    if (hwloc__obj_type_is_cache(obj->type)
924        && obj->type != hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type)) {
925      if (hwloc__xml_verbose())
926        fprintf(stderr, "%s: invalid cache type %s with attribute depth %u and type %d\n",
927  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->attr->cache.depth, (int) obj->attr->cache.type);
928      goto error_with_object;
929    }
930    if (!obj->cpuset && !hwloc__obj_type_is_special(obj->type)) {
931      if (hwloc__xml_verbose())
932        fprintf(stderr, "%s: invalid normal object %s P#%u without cpuset\n",
933  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
934      goto error_with_object;
935    }
936    if (obj->cpuset && hwloc__obj_type_is_special(obj->type)) {
937      if (hwloc__xml_verbose())
938        fprintf(stderr, "%s: invalid special object %s with cpuset\n",
939  	      state->global->msgprefix, hwloc_obj_type_string(obj->type));
940      goto error_with_object;
941    }
942    if (obj->cpuset && parent && !parent->cpuset) {
943      if (hwloc__xml_verbose())
944        fprintf(stderr, "%s: invalid object %s P#%u with cpuset while parent has none\n",
945  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
946      goto error_with_object;
947    }
948    if (obj->nodeset && parent && !parent->nodeset) {
949      if (hwloc__xml_verbose())
950        fprintf(stderr, "%s: invalid object %s P#%u with nodeset while parent has none\n",
951  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
952      goto error_with_object;
953    }
954    if (obj->type == HWLOC_OBJ_NUMANODE) {
955      if (!obj->nodeset) {
956        if (hwloc__xml_verbose())
957  	fprintf(stderr, "%s: invalid NUMA node object P#%u without nodeset\n",
958  		state->global->msgprefix, obj->os_index);
959        goto error_with_object;
960      }
961      data->nbnumanodes++;
962      obj->prev_cousin = data->last_numanode;
963      obj->next_cousin = NULL;
964      if (data->last_numanode)
965        data->last_numanode->next_cousin = obj;
966      else
967        data->first_numanode = obj;
968      data->last_numanode = obj;
969    }
970    if (!hwloc_filter_check_keep_object(topology, obj)) {
971      if (parent)
972        ignored = 1;
973    }
974    if (parent && !ignored) {
975      hwloc_insert_object_by_parent(topology, parent, obj);
976    }
977    while (tag) {
978      int ret;
979      if (!strcmp(tag, "object")) {
980        hwloc_obj_t childobj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_TYPE_MAX, HWLOC_UNKNOWN_INDEX);
981        childobj->parent = ignored ? parent : obj;
982        ret = hwloc__xml_import_object(topology, data, ignored ? parent : obj, childobj,
983  				     &childrengotignored,
984  				     &childstate);
985      } else {
986        if (hwloc__xml_verbose())
987  	fprintf(stderr, "%s: invalid special object child %s while looking for objects\n",
988  		state->global->msgprefix, tag);
989        ret = -1;
990      }
991      if (ret < 0) {
992        if (parent && !ignored)
993          goto error;
994        else
995          goto error_with_object;
996      }
997      state->global->close_child(&childstate);
998      tag = NULL;
999      ret = state->global->find_child(state, &childstate, &tag);
1000      if (ret < 0) {
1001        if (parent && !ignored)
1002          goto error;
1003        else
1004          goto error_with_object;
1005      }
1006      if (!ret)
1007        break;
1008    }
1009    if (numa_was_root) {
1010      unsigned i;
1011      for(i=0; i<obj->infos_count; i++) {
1012        struct hwloc_info_s *info = &obj->infos[i];
1013        hwloc_obj_add_info(parent, info->name, info->value);
1014      }
1015    }
1016    if (ignored) {
1017      hwloc_free_unlinked_object(obj);
1018      *gotignored = 1;
1019    } else if (obj->first_child) {
1020      hwloc_obj_t cur, next;
1021      for(cur = obj->first_child, next = cur->next_sibling;
1022  	next;
1023  	cur = next, next = next->next_sibling) {
1024        if (hwloc_bitmap_compare_first(next->complete_cpuset, cur->complete_cpuset) < 0) {
1025  	if (!childrengotignored) {
1026  	  static int reported = 0;
1027  	  if (!reported && HWLOC_SHOW_CRITICAL_ERRORS()) {
1028  	    hwloc__xml_import_report_outoforder(topology, next, cur);
1029  	    reported = 1;
1030  	  }
1031  	}
1032  	hwloc__reorder_children(obj);
1033  	break;
1034        }
1035      }
1036    }
1037    return state->global->close_tag(state);
1038   error_with_object:
1039    if (parent)
1040      hwloc_free_unlinked_object(obj);
1041   error:
1042    return -1;
1043  }
1044  static int
1045  hwloc__xml_v2import_support(hwloc_topology_t topology,
1046                              hwloc__xml_import_state_t state)
1047  {
1048    char *name = NULL;
1049    int value = 1; &bsol;* value is optional */
1050    while (1) {
1051      char *attrname, *attrvalue;
1052      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1053        break;
1054      if (!strcmp(attrname, "name"))
1055        name = attrvalue;
1056      else if (!strcmp(attrname, "value"))
1057        value = atoi(attrvalue);
1058      else {
1059        if (hwloc__xml_verbose())
1060  	fprintf(stderr, "%s: ignoring unknown support attribute %s\n",
1061  		state->global->msgprefix, attrname);
1062      }
1063    }
1064    if (name && topology->flags & HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT) {
1065  #ifdef HWLOC_DEBUG
1066      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
1067      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
1068      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
1069      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
1070      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
1071  #endif
1072  #define DO(_cat,_name) if (!strcmp(#_cat "." #_name, name)) topology->support._cat->_name = value
1073      DO(discovery,pu);
1074      else DO(discovery,numa);
1075      else DO(discovery,numa_memory);
1076      else DO(discovery,disallowed_pu);
1077      else DO(discovery,disallowed_numa);
1078      else DO(discovery,cpukind_efficiency);
1079      else DO(cpubind,set_thisproc_cpubind);
1080      else DO(cpubind,get_thisproc_cpubind);
1081      else DO(cpubind,set_proc_cpubind);
1082      else DO(cpubind,get_proc_cpubind);
1083      else DO(cpubind,set_thisthread_cpubind);
1084      else DO(cpubind,get_thisthread_cpubind);
1085      else DO(cpubind,set_thread_cpubind);
1086      else DO(cpubind,get_thread_cpubind);
1087      else DO(cpubind,get_thisproc_last_cpu_location);
1088      else DO(cpubind,get_proc_last_cpu_location);
1089      else DO(cpubind,get_thisthread_last_cpu_location);
1090      else DO(membind,set_thisproc_membind);
1091      else DO(membind,get_thisproc_membind);
1092      else DO(membind,set_proc_membind);
1093      else DO(membind,get_proc_membind);
1094      else DO(membind,set_thisthread_membind);
1095      else DO(membind,get_thisthread_membind);
1096      else DO(membind,set_area_membind);
1097      else DO(membind,get_area_membind);
1098      else DO(membind,alloc_membind);
1099      else DO(membind,firsttouch_membind);
1100      else DO(membind,bind_membind);
1101      else DO(membind,interleave_membind);
1102      else DO(membind,nexttouch_membind);
1103      else DO(membind,migrate_membind);
1104      else DO(membind,get_area_memlocation);
1105      else if (!strcmp("custom.exported_support", name))
1106        topology->support.misc->imported_support = 1;
1107  #undef DO
1108    }
1109    return 0;
1110  }
1111  static int
1112  hwloc__xml_v2import_distances(hwloc_topology_t topology,
1113  			      hwloc__xml_import_state_t state,
1114  			      int heterotypes)
1115  {
1116    hwloc_obj_type_t unique_type = HWLOC_OBJ_TYPE_NONE;
1117    hwloc_obj_type_t *different_types = NULL;
1118    unsigned nbobjs = 0;
1119    int indexing = heterotypes;
1120    int os_indexing = 0;
1121    int gp_indexing = heterotypes;
1122    char *name = NULL;
1123    unsigned long kind = 0;
1124    unsigned nr_indexes, nr_u64values;
1125    uint64_t *indexes;
1126    uint64_t *u64values;
1127    int ret;
1128  #define _TAG_NAME (heterotypes ? "distances2hetero" : "distances2")
1129    while (1) {
1130      char *attrname, *attrvalue;
1131      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1132        break;
1133      if (!strcmp(attrname, "nbobjs"))
1134        nbobjs = strtoul(attrvalue, NULL, 10);
1135      else if (!strcmp(attrname, "type")) {
1136        if (hwloc_type_sscanf(attrvalue, &unique_type, NULL, 0) < 0) {
1137  	if (hwloc__xml_verbose())
1138  	  fprintf(stderr, "%s: unrecognized %s type %s\n",
1139  		  state->global->msgprefix, _TAG_NAME, attrvalue);
1140  	goto out;
1141        }
1142      }
1143      else if (!strcmp(attrname, "indexing")) {
1144        indexing = 1;
1145        if (!strcmp(attrvalue, "os"))
1146  	os_indexing = 1;
1147        else if (!strcmp(attrvalue, "gp"))
1148  	gp_indexing = 1;
1149      }
1150      else if (!strcmp(attrname, "kind")) {
1151        kind = strtoul(attrvalue, NULL, 10);
1152      }
1153      else if (!strcmp(attrname, "name")) {
1154        name = attrvalue;
1155      }
1156      else {
1157        if (hwloc__xml_verbose())
1158  	fprintf(stderr, "%s: ignoring unknown %s attribute %s\n",
1159  		state->global->msgprefix, _TAG_NAME, attrname);
1160      }
1161    }
1162    if (!nbobjs || (!heterotypes && unique_type == HWLOC_OBJ_TYPE_NONE) || !indexing || !kind) {
1163      if (hwloc__xml_verbose())
1164        fprintf(stderr, "%s: %s missing some attributes\n",
1165  	      state->global->msgprefix, _TAG_NAME);
1166      goto out;
1167    }
1168    indexes = malloc(nbobjs*sizeof(*indexes));
1169    u64values = malloc(nbobjs*nbobjs*sizeof(*u64values));
1170    if (heterotypes)
1171      different_types = malloc(nbobjs*sizeof(*different_types));
1172    if (!indexes || !u64values || (heterotypes && !different_types)) {
1173      if (hwloc__xml_verbose())
1174        fprintf(stderr, "%s: failed to allocate %s arrays for %u objects\n",
<span onclick='openModal()' class='match'>1175  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
</span>1179    nr_u64values = 0;
1180    while (1) {
1181      struct hwloc__xml_import_state_s childstate;
1182      char *attrname, *attrvalue, *tag;
1183      const char *buffer;
1184      int length;
1185      int is_index = 0;
1186      int is_u64values = 0;
1187      ret = state->global->find_child(state, &childstate, &tag);
1188      if (ret <= 0)
1189        break;
1190      if (!strcmp(tag, "indexes"))
1191        is_index = 1;
1192      else if (!strcmp(tag, "u64values"))
1193        is_u64values = 1;
1194      if (!is_index && !is_u64values) {
1195        if (hwloc__xml_verbose())
1196  	fprintf(stderr, "%s: %s with unrecognized child %s\n",
1197  		state->global->msgprefix, _TAG_NAME, tag);
1198        goto out_with_arrays;
1199      }
1200      if (state->global->next_attr(&childstate, &attrname, &attrvalue) < 0
1201  	|| strcmp(attrname, "length")) {
1202        if (hwloc__xml_verbose())
1203  	fprintf(stderr, "%s: %s child must have length attribute\n",
1204  		state->global->msgprefix, _TAG_NAME);
1205        goto out_with_arrays;
1206      }
1207      length = atoi(attrvalue);
1208      ret = state->global->get_content(&childstate, &buffer, length);
1209      if (ret < 0) {
1210        if (hwloc__xml_verbose())
1211  	fprintf(stderr, "%s: %s child needs content of length %d\n",
1212  		state->global->msgprefix, _TAG_NAME, length);
1213        goto out_with_arrays;
1214      }
1215      if (is_index) {
1216        const char *tmp, *tmp2;
1217        if (nr_indexes >= nbobjs) {
1218  	if (hwloc__xml_verbose())
1219  	  fprintf(stderr, "%s: %s with more than %u indexes\n",
1220  		  state->global->msgprefix, _TAG_NAME, nbobjs);
1221  	goto out_with_arrays;
1222        }
1223        tmp = buffer;
1224        while (1) {
1225  	char *next;
1226  	unsigned long long u;
1227  	if (heterotypes) {
1228  	  hwloc_obj_type_t t = HWLOC_OBJ_TYPE_NONE;
1229            if (!*tmp)
1230              break;
1231  	  if (hwloc_type_sscanf(tmp, &t, NULL, 0) < 0) {
1232  	    if (hwloc__xml_verbose())
1233  	      fprintf(stderr, "%s: %s with unrecognized heterogeneous type %s\n",
1234  		      state->global->msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, ':');
1238  	  if (!tmp2) {
1239  	    if (hwloc__xml_verbose())
1240  	      fprintf(stderr, "%s: %s with missing colon after heterogeneous type %s\n",
1241  		      state->global->msgprefix, _TAG_NAME, tmp);
1242  	    goto out_with_arrays;
1243  	  }
1244  	  tmp = tmp2+1;
1245  	  different_types[nr_indexes] = t;
1246  	}
1247  	u = strtoull(tmp, &next, 0);
1248  	if (next == tmp)
1249  	  break;
1250  	indexes[nr_indexes++] = u;
1251  	if (*next != ' ')
1252  	  break;
1253  	if (nr_indexes == nbobjs)
1254  	  break;
1255  	tmp = next+1;
1256        }
1257      } else if (is_u64values) {
1258        const char *tmp;
1259        if (nr_u64values >= nbobjs*nbobjs) {
1260  	if (hwloc__xml_verbose())
1261  	  fprintf(stderr, "%s: %s with more than %u u64values\n",
1262  		  state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
1263  	goto out_with_arrays;
1264        }
1265        tmp = buffer;
1266        while (1) {
1267  	char *next;
1268  	unsigned long long u = strtoull(tmp, &next, 0);
1269  	if (next == tmp)
1270  	  break;
1271  	u64values[nr_u64values++] = u;
1272  	if (*next != ' ')
1273  	  break;
1274  	if (nr_u64values == nbobjs*nbobjs)
1275  	  break;
1276  	tmp = next+1;
1277        }
1278      }
1279      state->global->close_content(&childstate);
1280      ret = state->global->close_tag(&childstate);
1281      if (ret < 0) {
1282        if (hwloc__xml_verbose())
1283  	fprintf(stderr, "%s: %s with more than %u indexes\n",
1284  		state->global->msgprefix, _TAG_NAME, nbobjs);
1285        goto out_with_arrays;
1286      }
1287      state->global->close_child(&childstate);
1288    }
1289    if (nr_indexes != nbobjs) {
1290      if (hwloc__xml_verbose())
1291        fprintf(stderr, "%s: %s with less than %u indexes\n",
1292  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1293      goto out_with_arrays;
1294    }
1295    if (nr_u64values != nbobjs*nbobjs) {
1296      if (hwloc__xml_verbose())
1297        fprintf(stderr, "%s: %s with less than %u u64values\n",
1298  	      state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
1299      goto out_with_arrays;
1300    }
1301    if (nbobjs < 2) {
1302      if (hwloc__xml_verbose())
1303        fprintf(stderr, "%s: ignoring %s with only %u objects\n",
1304  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1305      goto out_ignore;
1306    }
1307    if (unique_type == HWLOC_OBJ_PU || unique_type == HWLOC_OBJ_NUMANODE) {
1308      if (!os_indexing) {
1309        if (hwloc__xml_verbose())
1310  	fprintf(stderr, "%s: ignoring PU or NUMA %s without os_indexing\n",
1311  		state->global->msgprefix, _TAG_NAME);
1312        goto out_ignore;
1313      }
1314    } else {
1315      if (!gp_indexing) {
1316        if (hwloc__xml_verbose())
1317  	fprintf(stderr, "%s: ignoring !PU or !NUMA %s without gp_indexing\n",
1318  		state->global->msgprefix, _TAG_NAME);
1319        goto out_ignore;
1320      }
1321    }
1322    if (topology->flags & HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)
1323      goto out_ignore;
1324    hwloc_internal_distances_add_by_index(topology, name, unique_type, different_types, nbobjs, indexes, u64values, kind, 0 &bsol;* assume grouping was applied when this matrix was discovered before exporting to XML */);
1325    indexes = NULL;
1326    u64values = NULL;
1327    different_types = NULL;
1328   out_ignore:
1329    free(different_types);
1330    free(indexes);
1331    free(u64values);
1332    return state->global->close_tag(state);
1333   out_with_arrays:
1334    free(different_types);
1335    free(indexes);
1336    free(u64values);
1337   out:
1338    return -1;
1339  #undef _TAG_NAME
1340  }
1341  static int
1342  hwloc__xml_import_memattr_value(hwloc_topology_t topology,
1343                                  hwloc_memattr_id_t id,
1344                                  unsigned long flags,
1345                                  hwloc__xml_import_state_t state)
1346  {
1347    char *target_obj_gp_index_s = NULL;
1348    char *target_obj_type_s = NULL;
1349    hwloc_uint64_t target_obj_gp_index;
1350    char *value_s = NULL;
1351    hwloc_uint64_t value;
1352    char *initiator_cpuset_s = NULL;
1353    char *initiator_obj_gp_index_s = NULL;
1354    char *initiator_obj_type_s = NULL;
1355    hwloc_obj_type_t target_obj_type = HWLOC_OBJ_TYPE_NONE;
1356    while (1) {
1357      char *attrname, *attrvalue;
1358      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1359        break;
1360      if (!strcmp(attrname, "target_obj_gp_index"))
1361        target_obj_gp_index_s = attrvalue;
1362      else if (!strcmp(attrname, "target_obj_type"))
1363        target_obj_type_s = attrvalue;
1364      else if (!strcmp(attrname, "value"))
1365        value_s = attrvalue;
1366      else if (!strcmp(attrname, "initiator_cpuset"))
1367        initiator_cpuset_s = attrvalue;
1368      else if (!strcmp(attrname, "initiator_obj_gp_index"))
1369        initiator_obj_gp_index_s = attrvalue;
1370      else if (!strcmp(attrname, "initiator_obj_type"))
1371        initiator_obj_type_s = attrvalue;
1372      else {
1373        if (hwloc__xml_verbose())
1374          fprintf(stderr, "%s: ignoring unknown memattr_value attribute %s\n",
1375                  state->global->msgprefix, attrname);
1376        return -1;
1377      }
1378    }
1379    if (!target_obj_type_s) {
1380      if (hwloc__xml_verbose())
1381        fprintf(stderr, "%s: ignoring memattr_value without target_obj_type.\n",
1382                state->global->msgprefix);
1383      return -1;
1384    }
1385    if (hwloc_type_sscanf(target_obj_type_s, &target_obj_type, NULL, 0) < 0) {
1386      if (hwloc__xml_verbose())
1387        fprintf(stderr, "%s: failed to identify memattr_value target object type %s\n",
1388                state->global->msgprefix, target_obj_type_s);
1389      return -1;
1390    }
1391    if (!value_s || !target_obj_gp_index_s) {
1392      if (hwloc__xml_verbose())
1393        fprintf(stderr, "%s: ignoring memattr_value without value and target_obj_gp_index\n",
1394                state->global->msgprefix);
1395      return -1;
1396    }
1397    target_obj_gp_index = strtoull(target_obj_gp_index_s, NULL, 10);
1398    value = strtoull(value_s, NULL, 10);
1399    if (flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
1400      struct hwloc_internal_location_s loc;
1401      if (!initiator_cpuset_s && (!initiator_obj_gp_index_s || !initiator_obj_type_s)) {
1402        if (hwloc__xml_verbose())
1403          fprintf(stderr, "%s: ignoring memattr_value without initiator attributes\n",
1404                  state->global->msgprefix);
1405        return -1;
1406      }
1407      if (initiator_cpuset_s) {
1408        loc.type = HWLOC_LOCATION_TYPE_CPUSET;
1409        loc.location.cpuset = hwloc_bitmap_alloc();
1410        if (!loc.location.cpuset) {
1411          if (hwloc__xml_verbose())
1412            fprintf(stderr, "%s: failed to allocated memattr_value initiator cpuset\n",
1413                    state->global->msgprefix);
1414          return -1;
1415        }
1416        hwloc_bitmap_sscanf(loc.location.cpuset, initiator_cpuset_s);
1417      } else {
1418        loc.type = HWLOC_LOCATION_TYPE_OBJECT;
1419        loc.location.object.gp_index = strtoull(initiator_obj_gp_index_s, NULL, 10);
1420        if (hwloc_type_sscanf(initiator_obj_type_s, &loc.location.object.type, NULL, 0) < 0) {
1421          if (hwloc__xml_verbose())
1422            fprintf(stderr, "%s: failed to identify memattr_value initiator object type %s\n",
1423                    state->global->msgprefix, initiator_obj_type_s);
1424          return -1;
1425        }
1426      }
1427      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, &loc, value);
1428      if (loc.type == HWLOC_LOCATION_TYPE_CPUSET)
1429        hwloc_bitmap_free(loc.location.cpuset);
1430    } else {
1431      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, NULL, value);
1432    }
1433    return 0;
1434  }
1435  static int
1436  hwloc__xml_import_memattr(hwloc_topology_t topology,
1437                            hwloc__xml_import_state_t state)
1438  {
1439    char *name = NULL;
1440    unsigned long flags = (unsigned long) -1;
1441    hwloc_memattr_id_t id = (hwloc_memattr_id_t) -1;
1442    int ret;
1443    while (1) {
1444      char *attrname, *attrvalue;
1445      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1446        break;
1447      if (!strcmp(attrname, "name"))
1448        name = attrvalue;
1449      else if (!strcmp(attrname, "flags"))
1450        flags = strtoul(attrvalue, NULL, 10);
1451      else {
1452        if (hwloc__xml_verbose())
1453          fprintf(stderr, "%s: ignoring unknown memattr attribute %s\n",
1454                  state->global->msgprefix, attrname);
1455        return -1;
1456      }
1457    }
1458    if (name && flags != (unsigned long) -1
1459        && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS)) {
1460      hwloc_memattr_id_t _id;
1461      ret = hwloc_memattr_get_by_name(topology, name, &_id);
1462      if (ret < 0) {
1463        ret = hwloc_memattr_register(topology, name, flags, &_id);
1464        if (!ret)
1465          id = _id;
1466      } else {
1467        unsigned long mflags;
1468        ret = hwloc_memattr_get_flags(topology, _id, &mflags);
1469        if (!ret && mflags == flags)
1470          id = _id;
1471      }
1472    }
1473    while (1) {
1474      struct hwloc__xml_import_state_s childstate;
1475      char *tag;
1476      ret = state->global->find_child(state, &childstate, &tag);
1477      if (ret <= 0)
1478        break;
1479      if (!strcmp(tag, "memattr_value")) {
1480        ret = hwloc__xml_import_memattr_value(topology, id, flags, &childstate);
1481      } else {
1482        if (hwloc__xml_verbose())
1483          fprintf(stderr, "%s: memattr with unrecognized child %s\n",
1484                  state->global->msgprefix, tag);
1485        ret = -1;
1486      }
1487      if (ret < 0)
1488        goto error;
1489      state->global->close_child(&childstate);
1490    }
1491    return state->global->close_tag(state);
1492   error:
1493    return -1;
1494  }
1495  static int
1496  hwloc__xml_import_cpukind(hwloc_topology_t topology,
1497                            hwloc__xml_import_state_t state)
1498  {
1499    hwloc_bitmap_t cpuset = NULL;
1500    int forced_efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
1501    unsigned nr_infos = 0;
1502    struct hwloc_info_s *infos = NULL;
1503    int ret;
1504    while (1) {
1505      char *attrname, *attrvalue;
1506      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1507        break;
1508      if (!strcmp(attrname, "cpuset")) {
1509        if (!cpuset)
1510          cpuset = hwloc_bitmap_alloc();
1511        hwloc_bitmap_sscanf(cpuset, attrvalue);
1512      } else if (!strcmp(attrname, "forced_efficiency")) {
1513        forced_efficiency = atoi(attrvalue);
1514      } else {
1515        if (hwloc__xml_verbose())
1516          fprintf(stderr, "%s: ignoring unknown cpukind attribute %s\n",
1517                  state->global->msgprefix, attrname);
1518        hwloc_bitmap_free(cpuset);
1519        return -1;
1520      }
1521    }
1522    while (1) {
1523      struct hwloc__xml_import_state_s childstate;
1524      char *tag;
1525      ret = state->global->find_child(state, &childstate, &tag);
1526      if (ret <= 0)
1527        break;
1528      if (!strcmp(tag, "info")) {
1529        char *infoname = NULL;
1530        char *infovalue = NULL;
1531        ret = hwloc___xml_import_info(&infoname, &infovalue, &childstate);
1532        if (!ret && infoname && infovalue)
1533          hwloc__add_info(&infos, &nr_infos, infoname, infovalue);
1534      } else {
1535        if (hwloc__xml_verbose())
1536          fprintf(stderr, "%s: cpukind with unrecognized child %s\n",
1537                  state->global->msgprefix, tag);
1538        ret = -1;
1539      }
1540      if (ret < 0)
1541        goto error;
1542      state->global->close_child(&childstate);
1543    }
1544    if (!cpuset) {
1545      if (hwloc__xml_verbose())
1546        fprintf(stderr, "%s: ignoring cpukind without cpuset\n",
1547                state->global->msgprefix);
1548      goto error;
1549    }
1550    if (topology->flags & HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS) {
1551      hwloc__free_infos(infos, nr_infos);
1552      hwloc_bitmap_free(cpuset);
1553    } else {
1554      hwloc_internal_cpukinds_register(topology, cpuset, forced_efficiency, infos, nr_infos, HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY);
1555      hwloc__free_infos(infos, nr_infos);
1556    }
1557    return state->global->close_tag(state);
1558   error:
1559    hwloc__free_infos(infos, nr_infos);
1560    hwloc_bitmap_free(cpuset);
1561    return -1;
1562  }
1563  static int
1564  hwloc__xml_import_diff_one(hwloc__xml_import_state_t state,
1565  			   hwloc_topology_diff_t *firstdiffp,
1566  			   hwloc_topology_diff_t *lastdiffp)
1567  {
1568    char *type_s = NULL;
1569    char *obj_depth_s = NULL;
1570    char *obj_index_s = NULL;
1571    char *obj_attr_type_s = NULL;
1572    char *obj_attr_name_s = NULL;
1573    char *obj_attr_oldvalue_s = NULL;
1574    char *obj_attr_newvalue_s = NULL;
1575    while (1) {
1576      char *attrname, *attrvalue;
1577      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1578        break;
1579      if (!strcmp(attrname, "type"))
1580        type_s = attrvalue;
1581      else if (!strcmp(attrname, "obj_depth"))
1582        obj_depth_s = attrvalue;
1583      else if (!strcmp(attrname, "obj_index"))
1584        obj_index_s = attrvalue;
1585      else if (!strcmp(attrname, "obj_attr_type"))
1586        obj_attr_type_s = attrvalue;
1587      else if (!strcmp(attrname, "obj_attr_index"))
1588        { &bsol;* obj_attr_index_s = attrvalue; unused for now */ }
1589      else if (!strcmp(attrname, "obj_attr_name"))
1590        obj_attr_name_s = attrvalue;
1591      else if (!strcmp(attrname, "obj_attr_oldvalue"))
1592        obj_attr_oldvalue_s = attrvalue;
1593      else if (!strcmp(attrname, "obj_attr_newvalue"))
1594        obj_attr_newvalue_s = attrvalue;
1595      else {
1596        if (hwloc__xml_verbose())
1597  	fprintf(stderr, "%s: ignoring unknown diff attribute %s\n",
1598  		state->global->msgprefix, attrname);
1599        return -1;
1600      }
1601    }
1602    if (type_s) {
1603      switch (atoi(type_s)) {
1604      default:
1605        break;
1606      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: {
1607        hwloc_topology_diff_obj_attr_type_t obj_attr_type;
1608        hwloc_topology_diff_t diff;
1609        if (!obj_depth_s || !obj_index_s || !obj_attr_type_s) {
1610  	if (hwloc__xml_verbose())
1611  	  fprintf(stderr, "%s: missing mandatory obj attr generic attributes\n",
1612  		  state->global->msgprefix);
1613  	break;
1614        }
1615        if (!obj_attr_oldvalue_s || !obj_attr_newvalue_s) {
1616  	if (hwloc__xml_verbose())
1617  	  fprintf(stderr, "%s: missing mandatory obj attr value attributes\n",
1618  		  state->global->msgprefix);
1619  	break;
1620        }
1621        obj_attr_type = atoi(obj_attr_type_s);
1622        if (obj_attr_type == HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO && !obj_attr_name_s) {
1623  	if (hwloc__xml_verbose())
1624  	  fprintf(stderr, "%s: missing mandatory obj attr info name attribute\n",
1625  		  state->global->msgprefix);
1626  	break;
1627        }
1628        diff = malloc(sizeof(*diff));
1629        if (!diff)
1630  	return -1;
1631        diff->obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
1632        diff->obj_attr.obj_depth = atoi(obj_depth_s);
1633        diff->obj_attr.obj_index = atoi(obj_index_s);
1634        memset(&diff->obj_attr.diff, 0, sizeof(diff->obj_attr.diff));
1635        diff->obj_attr.diff.generic.type = obj_attr_type;
1636        switch (obj_attr_type) {
1637        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
1638  	diff->obj_attr.diff.uint64.oldvalue = strtoull(obj_attr_oldvalue_s, NULL, 0);
1639  	diff->obj_attr.diff.uint64.newvalue = strtoull(obj_attr_newvalue_s, NULL, 0);
1640  	break;
1641        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
1642  	diff->obj_attr.diff.string.name = strdup(obj_attr_name_s);
1643        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
1644  	diff->obj_attr.diff.string.oldvalue = strdup(obj_attr_oldvalue_s);
1645  	diff->obj_attr.diff.string.newvalue = strdup(obj_attr_newvalue_s);
1646  	break;
1647        }
1648        if (*firstdiffp)
1649  	(*lastdiffp)->generic.next = diff;
1650        else
1651          *firstdiffp = diff;
1652        *lastdiffp = diff;
1653        diff->generic.next = NULL;
1654      }
1655      }
1656    }
1657    return state->global->close_tag(state);
1658  }
1659  int
1660  hwloc__xml_import_diff(hwloc__xml_import_state_t state,
1661  		       hwloc_topology_diff_t *firstdiffp)
1662  {
1663    hwloc_topology_diff_t firstdiff = NULL, lastdiff = NULL;
1664    *firstdiffp = NULL;
1665    while (1) {
1666      struct hwloc__xml_import_state_s childstate;
1667      char *tag;
1668      int ret;
1669      ret = state->global->find_child(state, &childstate, &tag);
1670      if (ret < 0)
1671        return -1;
1672      if (!ret)
1673        break;
1674      if (!strcmp(tag, "diff")) {
1675        ret = hwloc__xml_import_diff_one(&childstate, &firstdiff, &lastdiff);
1676      } else
1677        ret = -1;
1678      if (ret < 0)
1679        return ret;
1680      state->global->close_child(&childstate);
1681    }
1682    *firstdiffp = firstdiff;
1683    return 0;
1684  }
1685  static void
1686  hwloc_convert_from_v1dist_floats(hwloc_topology_t topology, unsigned nbobjs, float *floats, uint64_t *u64s)
1687  {
1688    unsigned i;
1689    int is_uint;
1690    char *env;
1691    float scale = 1000.f;
1692    char scalestring[20];
1693    env = getenv("HWLOC_XML_V1DIST_SCALE");
1694    if (env) {
1695      scale = (float) atof(env);
1696      goto scale;
1697    }
1698    is_uint = 1;
1699    for(i=0; i<nbobjs*nbobjs; i++) {
1700      float f, iptr, fptr;
1701      f = floats[i];
1702      if (f < 0.f) {
1703        is_uint = 0;
1704        break;
1705      }
1706      fptr = modff(f, &iptr);
1707      if (fptr > .001f && fptr < .999f) {
1708        is_uint = 0;
1709        break;
1710      }
1711      u64s[i] = (int)(f+.5f);
1712    }
1713    if (is_uint)
1714      return;
1715   scale:
1716    for(i=0; i<nbobjs*nbobjs; i++)
1717      u64s[i] = (uint64_t)(scale * floats[i]);
1718    sprintf(scalestring, "%f", scale);
1719    hwloc_obj_add_info(hwloc_get_root_obj(topology), "xmlv1DistancesScale", scalestring);
1720  }
1721  static int
1722  hwloc_look_xml(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1723  {
1724    struct hwloc_topology *topology = backend->topology;
1725    struct hwloc_xml_backend_data_s *data = backend->private_data;
1726    struct hwloc__xml_import_state_s state, childstate;
1727    struct hwloc_obj *root = topology->levels[0][0];
1728    char *tag;
1729    int gotignored = 0;
1730    hwloc_localeswitch_declare;
1731    int ret;
1732    assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
1733    state.global = data;
1734    assert(!root->cpuset);
1735    hwloc_localeswitch_init();
1736    data->nbnumanodes = 0;
1737    data->first_numanode = data->last_numanode = NULL;
1738    data->first_v1dist = data->last_v1dist = NULL;
1739    ret = data->look_init(data, &state);
1740    if (ret < 0)
1741      goto failed;
1742    if (data->version_major > 2) {
1743      if (hwloc__xml_verbose())
1744        fprintf(stderr, "%s: cannot import XML version %u.%u > 2\n",
1745  	      data->msgprefix, data->version_major, data->version_minor);
1746      goto err;
1747    }
1748    ret = state.global->find_child(&state, &childstate, &tag);
1749    if (ret < 0 || !ret || strcmp(tag, "object"))
1750      goto failed;
1751    ret = hwloc__xml_import_object(topology, data, NULL &bsol;*  no parent */, root,
1752  				 &gotignored,
1753  				 &childstate);
1754    if (ret < 0)
1755      goto failed;
1756    state.global->close_child(&childstate);
1757    assert(!gotignored);
1758    root = topology->levels[0][0];
1759    if (data->version_major >= 2) {
1760      while (1) {
1761        ret = state.global->find_child(&state, &childstate, &tag);
1762        if (ret < 0)
1763  	goto failed;
1764        if (!ret)
1765  	break;
1766        if (!strcmp(tag, "distances2")) {
1767  	ret = hwloc__xml_v2import_distances(topology, &childstate, 0);
1768  	if (ret < 0)
1769  	  goto failed;
1770        } else if (!strcmp(tag, "distances2hetero")) {
1771  	ret = hwloc__xml_v2import_distances(topology, &childstate, 1);
1772  	if (ret < 0)
1773  	  goto failed;
1774        } else if (!strcmp(tag, "support")) {
1775  	ret = hwloc__xml_v2import_support(topology, &childstate);
1776  	if (ret < 0)
1777  	  goto failed;
1778        } else if (!strcmp(tag, "memattr")) {
1779          ret = hwloc__xml_import_memattr(topology, &childstate);
1780          if (ret < 0)
1781            goto failed;
1782        } else if (!strcmp(tag, "cpukind")) {
1783          ret = hwloc__xml_import_cpukind(topology, &childstate);
1784          if (ret < 0)
1785            goto failed;
1786        } else {
1787  	if (hwloc__xml_verbose())
1788  	  fprintf(stderr, "%s: ignoring unknown tag `%s' after root object.\n",
1789  		  data->msgprefix, tag);
1790  	goto done;
1791        }
1792        state.global->close_child(&childstate);
1793      }
1794    }
1795    state.global->close_tag(&state);
1796  done:
1797    if (!root->cpuset) {
1798      if (hwloc__xml_verbose())
1799        fprintf(stderr, "%s: invalid root object without cpuset\n",
1800  	      data->msgprefix);
1801      goto err;
1802    }
1803    if (data->version_major < 2 && data->first_numanode) {
1804      hwloc_obj_t node = data->first_numanode;
1805      do {
1806        if (node->parent->type == HWLOC_OBJ_GROUP
1807  	  && !node->parent->gp_index)
1808  	node->parent->gp_index = topology->next_gp_index++;
1809        node = node->next_cousin;
1810      } while (node);
1811    }
1812    if (data->version_major < 2 && data->first_v1dist) {
1813      struct hwloc__xml_imported_v1distances_s *v1dist, *v1next = data->first_v1dist;
1814      while ((v1dist = v1next) != NULL) {
1815        unsigned nbobjs = v1dist->nbobjs;
1816        v1next = v1dist->next;
1817        if (nbobjs == data->nbnumanodes
1818            && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)) {
1819  	hwloc_obj_t *objs = malloc(nbobjs*sizeof(hwloc_obj_t));
1820  	uint64_t *values = malloc(nbobjs*nbobjs*sizeof(*values));
1821          assert(data->nbnumanodes > 0); &bsol;* v1dist->nbobjs is >0 after import */
1822          assert(data->first_numanode);
1823  	if (objs && values) {
1824  	  hwloc_obj_t node;
1825  	  unsigned i;
1826  	  for(i=0, node = data->first_numanode;
1827  	      i<nbobjs;
1828  	      i++, node = node->next_cousin)
1829  	    objs[i] = node;
1830  	  hwloc_convert_from_v1dist_floats(topology, nbobjs, v1dist->floats, values);
1831  	  hwloc_internal_distances_add(topology, NULL, nbobjs, objs, values, v1dist->kind, 0);
1832  	} else {
1833  	  free(objs);
1834  	  free(values);
1835  	}
1836        }
1837        free(v1dist->floats);
1838        free(v1dist);
1839      }
1840      data->first_v1dist = data->last_v1dist = NULL;
1841    }
1842    if (data->version_major >= 2) {
1843      if (!root->nodeset) {
1844        if (hwloc__xml_verbose())
1845  	fprintf(stderr, "%s: invalid root object without nodeset\n",
1846  		data->msgprefix);
1847        goto err;
1848      }
1849      if (hwloc_bitmap_iszero(root->nodeset)) {
1850        if (hwloc__xml_verbose())
1851  	fprintf(stderr, "%s: invalid root object with empty nodeset\n",
1852  		data->msgprefix);
1853        goto err;
1854      }
1855    } else {
1856    }
1857    hwloc_alloc_root_sets(root);
1858    if (!(topology->flags & HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT)) {
1859      topology->support.discovery->pu = 1;
1860      topology->support.discovery->disallowed_pu = 1;
1861      if (data->nbnumanodes) {
1862        topology->support.discovery->numa = 1;
1863        topology->support.discovery->numa_memory = 1; 
1864        topology->support.discovery->disallowed_numa = 1;
1865      }
1866    }
1867    if (data->look_done)
1868      data->look_done(data, 0);
1869    hwloc_localeswitch_fini();
1870    return 0;
1871   failed:
1872    if (data->look_done)
1873      data->look_done(data, -1);
1874    if (hwloc__xml_verbose())
1875      fprintf(stderr, "%s: XML component discovery failed.\n",
1876  	    data->msgprefix);
1877   err:
1878    hwloc_free_object_siblings_and_children(root->first_child);
1879    root->first_child = NULL;
1880    hwloc_free_object_siblings_and_children(root->memory_first_child);
1881    root->memory_first_child = NULL;
1882    hwloc_free_object_siblings_and_children(root->io_first_child);
1883    root->io_first_child = NULL;
1884    hwloc_free_object_siblings_and_children(root->misc_first_child);
1885    root->misc_first_child = NULL;
1886    if (root->cpuset)
1887      hwloc_bitmap_zero(root->cpuset);
1888    if (root->nodeset)
1889      hwloc_bitmap_zero(root->nodeset);
1890    hwloc_localeswitch_fini();
1891    return -1;
1892  }
1893  int
1894  hwloc_topology_diff_load_xml(const char *xmlpath,
1895  			     hwloc_topology_diff_t *firstdiffp, char **refnamep)
1896  {
1897    struct hwloc__xml_import_state_s state;
1898    struct hwloc_xml_backend_data_s fakedata; &bsol;* only for storing global info during parsing */
1899    hwloc_localeswitch_declare;
1900    const char *local_basename;
1901    int force_nolibxml;
1902    int ret;
1903    state.global = &fakedata;
1904    local_basename = strrchr(xmlpath, '/');
1905    if (local_basename)
1906      local_basename++;
1907    else
1908      local_basename = xmlpath;
1909    fakedata.msgprefix = strdup(local_basename);
1910    hwloc_components_init();
1911    assert(hwloc_nolibxml_callbacks);
1912    hwloc_localeswitch_init();
1913    *firstdiffp = NULL;
1914    force_nolibxml = hwloc_nolibxml_import();
1915  retry:
1916    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
1917      ret = hwloc_nolibxml_callbacks->import_diff(&state, xmlpath, NULL, 0, firstdiffp, refnamep);
1918    else {
1919      ret = hwloc_libxml_callbacks->import_diff(&state, xmlpath, NULL, 0, firstdiffp, refnamep);
1920      if (ret < 0 && errno == ENOSYS) {
1921        hwloc_libxml_callbacks = NULL;
1922        goto retry;
1923      }
1924    }
1925    hwloc_localeswitch_fini();
1926    hwloc_components_fini();
1927    free(fakedata.msgprefix);
1928    return ret;
1929  }
1930  int
1931  hwloc_topology_diff_load_xmlbuffer(const char *xmlbuffer, int buflen,
1932  				   hwloc_topology_diff_t *firstdiffp, char **refnamep)
1933  {
1934    struct hwloc__xml_import_state_s state;
1935    struct hwloc_xml_backend_data_s fakedata; &bsol;* only for storing global info during parsing */
1936    hwloc_localeswitch_declare;
1937    int force_nolibxml;
1938    int ret;
1939    state.global = &fakedata;
1940    fakedata.msgprefix = strdup("xmldiffbuffer");
1941    hwloc_components_init();
1942    assert(hwloc_nolibxml_callbacks);
1943    hwloc_localeswitch_init();
1944    *firstdiffp = NULL;
1945    force_nolibxml = hwloc_nolibxml_import();
1946   retry:
1947    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
1948      ret = hwloc_nolibxml_callbacks->import_diff(&state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1949    else {
1950      ret = hwloc_libxml_callbacks->import_diff(&state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1951      if (ret < 0 && errno == ENOSYS) {
1952        hwloc_libxml_callbacks = NULL;
1953        goto retry;
1954      }
1955    }
1956    hwloc_localeswitch_fini();
1957    hwloc_components_fini();
1958    free(fakedata.msgprefix);
1959    return ret;
1960  }
1961  #define HWLOC_XML_CHAR_VALID(c) (((c) >= 32 && (c) <= 126) || (c) == '\t' || (c) == '\n' || (c) == '\r')
1962  static int
1963  hwloc__xml_export_check_buffer(const char *buf, size_t length)
1964  {
1965    unsigned i;
1966    for(i=0; i<length; i++)
1967      if (!HWLOC_XML_CHAR_VALID(buf[i]))
1968        return -1;
1969    return 0;
1970  }
1971  static char*
1972  hwloc__xml_export_safestrdup(const char *old)
1973  {
1974    char *new = malloc(strlen(old)+1);
1975    char *dst = new;
1976    const char *src = old;
1977    if (!new)
1978      return NULL;
1979    while (*src) {
1980      if (HWLOC_XML_CHAR_VALID(*src))
1981        *(dst++) = *src;
1982      src++;
1983    }
1984    *dst = '\0';
1985    return new;
1986  }
1987  static void
1988  hwloc__xml_export_object_contents (hwloc__xml_export_state_t state, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
1989  {
1990    char *setstring = NULL, *setstring2 = NULL;
1991    char tmp[255];
1992    int v1export = flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1;
1993    unsigned i,j;
1994    if (v1export && obj->type == HWLOC_OBJ_PACKAGE)
1995      state->new_prop(state, "type", "Socket");
1996    else if (v1export && obj->type == HWLOC_OBJ_DIE)
1997      state->new_prop(state, "type", "Group");
1998    else if (v1export && hwloc__obj_type_is_cache(obj->type))
1999      state->new_prop(state, "type", "Cache");
2000    else
2001      state->new_prop(state, "type", hwloc_obj_type_string(obj->type));
2002    if (obj->os_index != HWLOC_UNKNOWN_INDEX) {
2003      sprintf(tmp, "%u", obj->os_index);
2004      state->new_prop(state, "os_index", tmp);
2005    }
2006    if (obj->cpuset) {
2007      int empty_cpusets = 0;
2008      if (v1export && obj->type == HWLOC_OBJ_NUMANODE) {
2009        hwloc_obj_t parent = obj;
2010        while (!hwloc_obj_type_is_normal(parent->type)) {
2011  	if (parent->sibling_rank > 0) {
2012  	  empty_cpusets = 1;
2013  	  break;
2014  	}
2015  	parent = parent->parent;
2016        }
2017      }
2018      if (empty_cpusets) {
2019        state->new_prop(state, "cpuset", "0x0");
2020        state->new_prop(state, "online_cpuset", "0x0");
2021        state->new_prop(state, "complete_cpuset", "0x0");
2022        state->new_prop(state, "allowed_cpuset", "0x0");
2023      } else {
2024        hwloc_bitmap_asprintf(&setstring, obj->cpuset);
2025        state->new_prop(state, "cpuset", setstring);
2026        hwloc_bitmap_asprintf(&setstring2, obj->complete_cpuset);
2027        state->new_prop(state, "complete_cpuset", setstring2);
2028        free(setstring2);
2029        if (v1export)
2030  	state->new_prop(state, "online_cpuset", setstring);
2031        free(setstring);
2032        if (v1export) {
2033  	hwloc_bitmap_t allowed_cpuset = hwloc_bitmap_dup(obj->cpuset);
2034  	hwloc_bitmap_and(allowed_cpuset, allowed_cpuset, topology->allowed_cpuset);
2035  	hwloc_bitmap_asprintf(&setstring, allowed_cpuset);
2036  	state->new_prop(state, "allowed_cpuset", setstring);
2037  	free(setstring);
2038  	hwloc_bitmap_free(allowed_cpuset);
2039        } else if (!obj->parent) {
2040  	hwloc_bitmap_asprintf(&setstring, topology->allowed_cpuset);
2041  	state->new_prop(state, "allowed_cpuset", setstring);
2042  	free(setstring);
2043        }
2044      }
2045      hwloc_bitmap_asprintf(&setstring, obj->nodeset);
2046      state->new_prop(state, "nodeset", setstring);
2047      free(setstring);
2048      hwloc_bitmap_asprintf(&setstring, obj->complete_nodeset);
2049      state->new_prop(state, "complete_nodeset", setstring);
2050      free(setstring);
2051      if (v1export) {
2052        hwloc_bitmap_t allowed_nodeset = hwloc_bitmap_dup(obj->nodeset);
2053        hwloc_bitmap_and(allowed_nodeset, allowed_nodeset, topology->allowed_nodeset);
2054        hwloc_bitmap_asprintf(&setstring, allowed_nodeset);
2055        state->new_prop(state, "allowed_nodeset", setstring);
2056        free(setstring);
2057        hwloc_bitmap_free(allowed_nodeset);
2058      } else if (!obj->parent) {
2059        hwloc_bitmap_asprintf(&setstring, topology->allowed_nodeset);
2060        state->new_prop(state, "allowed_nodeset", setstring);
2061        free(setstring);
2062      }
2063    }
2064    if (!v1export) {
2065      sprintf(tmp, "%llu", (unsigned long long) obj->gp_index);
2066      state->new_prop(state, "gp_index", tmp);
2067    }
2068    if (obj->name) {
2069      char *name = hwloc__xml_export_safestrdup(obj->name);
2070      if (name) {
2071        state->new_prop(state, "name", name);
2072        free(name);
2073      }
2074    }
2075    if (!v1export && obj->subtype) {
2076      char *subtype = hwloc__xml_export_safestrdup(obj->subtype);
2077      if (subtype) {
2078        state->new_prop(state, "subtype", subtype);
2079        free(subtype);
2080      }
2081    }
2082    switch (obj->type) {
2083    case HWLOC_OBJ_NUMANODE:
2084      if (obj->attr->numanode.local_memory) {
2085        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.local_memory);
2086        state->new_prop(state, "local_memory", tmp);
2087      }
2088      for(i=0; i<obj->attr->numanode.page_types_len; i++) {
2089        struct hwloc__xml_export_state_s childstate;
2090        state->new_child(state, &childstate, "page_type");
2091        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].size);
2092        childstate.new_prop(&childstate, "size", tmp);
2093        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].count);
2094        childstate.new_prop(&childstate, "count", tmp);
2095        childstate.end_object(&childstate, "page_type");
2096      }
2097      break;
2098    case HWLOC_OBJ_L1CACHE:
2099    case HWLOC_OBJ_L2CACHE:
2100    case HWLOC_OBJ_L3CACHE:
2101    case HWLOC_OBJ_L4CACHE:
2102    case HWLOC_OBJ_L5CACHE:
2103    case HWLOC_OBJ_L1ICACHE:
2104    case HWLOC_OBJ_L2ICACHE:
2105    case HWLOC_OBJ_L3ICACHE:
2106    case HWLOC_OBJ_MEMCACHE:
2107      sprintf(tmp, "%llu", (unsigned long long) obj->attr->cache.size);
2108      state->new_prop(state, "cache_size", tmp);
2109      sprintf(tmp, "%u", obj->attr->cache.depth);
2110      state->new_prop(state, "depth", tmp);
2111      sprintf(tmp, "%u", (unsigned) obj->attr->cache.linesize);
2112      state->new_prop(state, "cache_linesize", tmp);
2113      sprintf(tmp, "%d", obj->attr->cache.associativity);
2114      state->new_prop(state, "cache_associativity", tmp);
2115      sprintf(tmp, "%d", (int) obj->attr->cache.type);
2116      state->new_prop(state, "cache_type", tmp);
2117      break;
2118    case HWLOC_OBJ_GROUP:
2119      if (v1export) {
2120        sprintf(tmp, "%u", obj->attr->group.depth);
2121        state->new_prop(state, "depth", tmp);
2122        if (obj->attr->group.dont_merge)
2123          state->new_prop(state, "dont_merge", "1");
2124      } else {
2125        sprintf(tmp, "%u", obj->attr->group.kind);
2126        state->new_prop(state, "kind", tmp);
2127        sprintf(tmp, "%u", obj->attr->group.subkind);
2128        state->new_prop(state, "subkind", tmp);
2129        if (obj->attr->group.dont_merge)
2130          state->new_prop(state, "dont_merge", "1");
2131      }
2132      break;
2133    case HWLOC_OBJ_BRIDGE:
2134      sprintf(tmp, "%d-%d", (int) obj->attr->bridge.upstream_type, (int) obj->attr->bridge.downstream_type);
2135      state->new_prop(state, "bridge_type", tmp);
2136      sprintf(tmp, "%u", obj->attr->bridge.depth);
2137      state->new_prop(state, "depth", tmp);
2138      if (obj->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
2139        sprintf(tmp, "%04x:[%02x-%02x]",
2140  	      (unsigned) obj->attr->bridge.downstream.pci.domain,
2141  	      (unsigned) obj->attr->bridge.downstream.pci.secondary_bus,
2142  	      (unsigned) obj->attr->bridge.downstream.pci.subordinate_bus);
2143        state->new_prop(state, "bridge_pci", tmp);
2144      }
2145      if (obj->attr->bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI)
2146        break;
2147    case HWLOC_OBJ_PCI_DEVICE:
2148      sprintf(tmp, "%04x:%02x:%02x.%01x",
2149  	    (unsigned) obj->attr->pcidev.domain,
2150  	    (unsigned) obj->attr->pcidev.bus,
2151  	    (unsigned) obj->attr->pcidev.dev,
2152  	    (unsigned) obj->attr->pcidev.func);
2153      state->new_prop(state, "pci_busid", tmp);
2154      sprintf(tmp, "%04x [%04x:%04x] [%04x:%04x] %02x",
2155  	    (unsigned) obj->attr->pcidev.class_id,
2156  	    (unsigned) obj->attr->pcidev.vendor_id, (unsigned) obj->attr->pcidev.device_id,
2157  	    (unsigned) obj->attr->pcidev.subvendor_id, (unsigned) obj->attr->pcidev.subdevice_id,
2158  	    (unsigned) obj->attr->pcidev.revision);
2159      state->new_prop(state, "pci_type", tmp);
2160      sprintf(tmp, "%f", obj->attr->pcidev.linkspeed);
2161      state->new_prop(state, "pci_link_speed", tmp);
2162      break;
2163    case HWLOC_OBJ_OS_DEVICE:
2164      sprintf(tmp, "%d", (int) obj->attr->osdev.type);
2165      state->new_prop(state, "osdev_type", tmp);
2166      break;
2167    default:
2168      break;
2169    }
2170    for(i=0; i<obj->infos_count; i++) {
2171      char *name = hwloc__xml_export_safestrdup(obj->infos[i].name);
2172      char *value = hwloc__xml_export_safestrdup(obj->infos[i].value);
2173      if (name && value) {
2174        struct hwloc__xml_export_state_s childstate;
2175        state->new_child(state, &childstate, "info");
2176        childstate.new_prop(&childstate, "name", name);
2177        childstate.new_prop(&childstate, "value", value);
2178        childstate.end_object(&childstate, "info");
2179      }
2180      free(name);
2181      free(value);
2182    }
2183    if (v1export && obj->subtype) {
2184      char *subtype = hwloc__xml_export_safestrdup(obj->subtype);
2185      if (subtype) {
2186        struct hwloc__xml_export_state_s childstate;
2187        int is_coproctype = (obj->type == HWLOC_OBJ_OS_DEVICE && obj->attr->osdev.type == HWLOC_OBJ_OSDEV_COPROC);
2188        state->new_child(state, &childstate, "info");
2189        childstate.new_prop(&childstate, "name", is_coproctype ? "CoProcType" : "Type");
2190        childstate.new_prop(&childstate, "value", subtype);
2191        childstate.end_object(&childstate, "info");
2192        free(subtype);
2193      }
2194    }
2195    if (v1export && obj->type == HWLOC_OBJ_DIE) {
2196      struct hwloc__xml_export_state_s childstate;
2197      state->new_child(state, &childstate, "info");
2198      childstate.new_prop(&childstate, "name", "Type");
2199      childstate.new_prop(&childstate, "value", "Die");
2200      childstate.end_object(&childstate, "info");
2201    }
2202    if (v1export && !obj->parent) {
2203      struct hwloc_internal_distances_s *dist;
2204      hwloc_internal_distances_refresh(topology);
2205      for(dist = topology->first_dist; dist; dist = dist->next) {
2206        struct hwloc__xml_export_state_s childstate;
2207        unsigned nbobjs = dist->nbobjs;
2208        unsigned *logical_to_v2array;
2209        int depth;
2210        if (nbobjs != (unsigned) hwloc_get_nbobjs_by_type(topology, dist->unique_type))
2211  	continue;
2212        if (!(dist->kind & HWLOC_DISTANCES_KIND_MEANS_LATENCY))
2213  	continue;
2214        if (dist->kind & HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES)
2215  	continue;
2216        logical_to_v2array = malloc(nbobjs * sizeof(*logical_to_v2array));
2217        if (!logical_to_v2array) {
2218          if (HWLOC_SHOW_ALL_ERRORS())
2219            fprintf(stderr, "hwloc/xml/export/v1: failed to allocated logical_to_v2array\n");
2220  	continue;
2221        }
2222        for(i=0; i<nbobjs; i++)
2223  	logical_to_v2array[dist->objs[i]->logical_index] = i;
2224        if (dist->unique_type == HWLOC_OBJ_NUMANODE) {
2225  	depth = -1;
2226  	for(i=0; i<nbobjs; i++) {
2227  	  hwloc_obj_t parent = dist->objs[i]->parent;
2228  	  while (hwloc__obj_type_is_memory(parent->type))
2229  	    parent = parent->parent;
2230  	  if (parent->depth+1 > depth)
2231  	    depth = parent->depth+1;
2232  	}
2233        } else {
2234  	int parent_with_memory = 0;
2235  	for(i=0; i<nbobjs; i++) {
2236  	  hwloc_obj_t parent = dist->objs[i]->parent;
2237  	  while (parent) {
2238  	    if (parent->memory_first_child) {
2239  	      parent_with_memory = 1;
2240  	      goto done;
2241  	    }
2242  	    parent = parent->parent;
2243  	  }
2244  	}
2245        done:
2246  	depth = hwloc_get_type_depth(topology, dist->unique_type) + parent_with_memory;
2247        }
2248        state->new_child(state, &childstate, "distances");
2249        sprintf(tmp, "%u", nbobjs);
2250        childstate.new_prop(&childstate, "nbobjs", tmp);
2251        sprintf(tmp, "%d", depth);
2252        childstate.new_prop(&childstate, "relative_depth", tmp);
2253        sprintf(tmp, "%f", 1.f);
2254        childstate.new_prop(&childstate, "latency_base", tmp);
2255        for(i=0; i<nbobjs; i++) {
2256          for(j=0; j<nbobjs; j++) {
2257  	  unsigned k = logical_to_v2array[i]*nbobjs+logical_to_v2array[j];
2258  	  struct hwloc__xml_export_state_s greatchildstate;
2259  	  childstate.new_child(&childstate, &greatchildstate, "latency");
2260  	  sprintf(tmp, "%f", (float) dist->values[k]);
2261  	  greatchildstate.new_prop(&greatchildstate, "value", tmp);
2262  	  greatchildstate.end_object(&greatchildstate, "latency");
2263  	}
2264        }
2265        childstate.end_object(&childstate, "distances");
2266        free(logical_to_v2array);
2267      }
2268    }
2269    if (obj->userdata && topology->userdata_export_cb)
2270      topology->userdata_export_cb((void*) state, topology, obj);
2271  }
2272  static void
2273  hwloc__xml_v2export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2274  {
2275    struct hwloc__xml_export_state_s state;
2276    hwloc_obj_t child;
2277    parentstate->new_child(parentstate, &state, "object");
2278    hwloc__xml_export_object_contents(&state, topology, obj, flags);
2279    for_each_memory_child(child, obj)
2280      hwloc__xml_v2export_object (&state, topology, child, flags);
2281    for_each_child(child, obj)
2282      hwloc__xml_v2export_object (&state, topology, child, flags);
2283    for_each_io_child(child, obj)
2284      hwloc__xml_v2export_object (&state, topology, child, flags);
2285    for_each_misc_child(child, obj)
2286      hwloc__xml_v2export_object (&state, topology, child, flags);
2287    state.end_object(&state, "object");
2288  }
2289  static void
2290  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags);
2291  static hwloc_obj_t
2292  hwloc__xml_v1export_object_next_numanode(hwloc_obj_t obj, hwloc_obj_t cur)
2293  {
2294    hwloc_obj_t parent;
2295    if (!cur) {
2296      cur = obj->memory_first_child;
2297      goto find_first;
2298    }
2299    parent = cur;
2300    while (1) {
2301      if (parent->next_sibling) {
2302        cur = parent->next_sibling;
2303        break;
2304      }
2305      parent = parent->parent;
2306      if (parent == obj)
2307        return NULL;
2308    }
2309   find_first:
2310    while (cur->type != HWLOC_OBJ_NUMANODE)
2311      cur = cur->memory_first_child;
2312    assert(cur);
2313    return cur;
2314  }
2315  static unsigned
2316  hwloc__xml_v1export_object_list_numanodes(hwloc_obj_t obj, hwloc_obj_t *first_p, hwloc_obj_t **nodes_p)
2317  {
2318    hwloc_obj_t *nodes, cur;
2319    int nr;
2320    if (!obj->memory_first_child) {
2321      *first_p = NULL;
2322      *nodes_p = NULL;
2323      return 0;
2324    }
2325    nr = hwloc_bitmap_weight(obj->nodeset);
2326    assert(nr > 0);
2327    nodes = calloc(nr, sizeof(*nodes));
2328    if (!nodes) {
2329      cur = hwloc__xml_v1export_object_next_numanode(obj, NULL);
2330      assert(cur);
2331      *first_p = cur;
2332      *nodes_p = NULL;
2333      return 1;
2334    }
2335    nr = 0;
2336    cur = NULL;
2337    while (1) {
2338      cur = hwloc__xml_v1export_object_next_numanode(obj, cur);
2339      if (!cur)
2340        break;
2341      nodes[nr++] = cur;
2342    }
2343    *first_p = nodes[0];
2344    *nodes_p = nodes;
2345    return nr;
2346  }
2347  static void
2348  hwloc__xml_v1export_object_with_memory(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2349  {
2350    struct hwloc__xml_export_state_s gstate, mstate, ostate, *state = parentstate;
2351    hwloc_obj_t child;
2352    unsigned nr_numanodes;
2353    hwloc_obj_t *numanodes, first_numanode;
2354    unsigned i;
2355    nr_numanodes = hwloc__xml_v1export_object_list_numanodes(obj, &first_numanode, &numanodes);
2356    if (obj->parent->arity > 1 && nr_numanodes > 1 && parentstate->global->v1_memory_group) {
2357      hwloc_obj_t group = parentstate->global->v1_memory_group;
2358      parentstate->new_child(parentstate, &gstate, "object");
2359      group->parent = obj->parent;
2360      group->cpuset = obj->cpuset;
2361      group->complete_cpuset = obj->complete_cpuset;
2362      group->nodeset = obj->nodeset;
2363      group->complete_nodeset = obj->complete_nodeset;
2364      hwloc__xml_export_object_contents (&gstate, topology, group, flags);
2365      group->cpuset = NULL;
2366      group->complete_cpuset = NULL;
2367      group->nodeset = NULL;
2368      group->complete_nodeset = NULL;
2369      state = &gstate;
2370    }
2371    state->new_child(state, &mstate, "object");
2372    hwloc__xml_export_object_contents (&mstate, topology, first_numanode, flags);
2373    mstate.new_child(&mstate, &ostate, "object");
2374    hwloc__xml_export_object_contents (&ostate, topology, obj, flags);
2375    for_each_child(child, obj)
2376      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2377    for_each_io_child(child, obj)
2378      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2379    for_each_misc_child(child, obj)
2380      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2381    ostate.end_object(&ostate, "object");
2382    mstate.end_object(&mstate, "object");
2383    for(i=1; i<nr_numanodes; i++)
2384      hwloc__xml_v1export_object (state, topology, numanodes[i], flags);
2385    free(numanodes);
2386    if (state == &gstate) {
2387      gstate.end_object(&gstate, "object");
2388    }
2389  }
2390  static void
2391  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2392  {
2393    struct hwloc__xml_export_state_s state;
2394    hwloc_obj_t child;
2395    parentstate->new_child(parentstate, &state, "object");
2396    hwloc__xml_export_object_contents(&state, topology, obj, flags);
2397    for_each_child(child, obj) {
2398      if (!child->memory_arity) {
2399        hwloc__xml_v1export_object (&state, topology, child, flags);
2400      } else {
2401        hwloc__xml_v1export_object_with_memory(&state, topology, child, flags);
2402      }
2403    }
2404    for_each_io_child(child, obj)
2405      hwloc__xml_v1export_object (&state, topology, child, flags);
2406    for_each_misc_child(child, obj)
2407      hwloc__xml_v1export_object (&state, topology, child, flags);
2408    state.end_object(&state, "object");
2409  }
2410  #define EXPORT_ARRAY(state, type, nr, values, tagname, format, maxperline) do { \
2411    unsigned _i = 0; \
2412    while (_i<(nr)) { \
2413      char _tmp[255]; &bsol;* enough for (snprintf(format)+space) x maxperline */ \
2414      char _tmp2[16]; \
2415      size_t _len = 0; \
2416      unsigned _j; \
2417      struct hwloc__xml_export_state_s _childstate; \
2418      (state)->new_child(state, &_childstate, tagname); \
2419      for(_j=0; \
2420  	_i+_j<(nr) && _j<maxperline; \
2421  	_j++) \
2422        _len += sprintf(_tmp+_len, format " ", (type) (values)[_i+_j]); \
2423      _i += _j; \
2424      sprintf(_tmp2, "%lu", (unsigned long) _len); \
2425      _childstate.new_prop(&_childstate, "length", _tmp2); \
2426      _childstate.add_content(&_childstate, _tmp, _len); \
2427      _childstate.end_object(&_childstate, tagname); \
2428    } \
2429  } while (0)
2430  #define EXPORT_TYPE_GPINDEX_ARRAY(state, nr, objs, tagname, maxperline) do { \
2431    unsigned _i = 0; \
2432    while (_i<(nr)) { \
2433      char _tmp[255]; &bsol;* enough for (snprintf(type+index)+space) x maxperline */ \
2434      char _tmp2[16]; \
2435      size_t _len = 0; \
2436      unsigned _j; \
2437      struct hwloc__xml_export_state_s _childstate; \
2438      (state)->new_child(state, &_childstate, tagname); \
2439      for(_j=0; \
2440  	_i+_j<(nr) && _j<maxperline; \
2441  	_j++) \
2442        _len += sprintf(_tmp+_len, "%s:%llu ", hwloc_obj_type_string((objs)[_i+_j]->type), (unsigned long long) (objs)[_i+_j]->gp_index); \
2443      _i += _j; \
2444      sprintf(_tmp2, "%lu", (unsigned long) _len); \
2445      _childstate.new_prop(&_childstate, "length", _tmp2); \
2446      _childstate.add_content(&_childstate, _tmp, _len); \
2447      _childstate.end_object(&_childstate, tagname); \
2448    } \
2449  } while (0)
2450  static void
2451  hwloc___xml_v2export_distances(hwloc__xml_export_state_t parentstate, struct hwloc_internal_distances_s *dist)
2452  {
2453    char tmp[255];
2454    unsigned nbobjs = dist->nbobjs;
2455    struct hwloc__xml_export_state_s state;
2456    if (dist->different_types) {
2457      parentstate->new_child(parentstate, &state, "distances2hetero");
2458    } else {
2459      parentstate->new_child(parentstate, &state, "distances2");
2460      state.new_prop(&state, "type", hwloc_obj_type_string(dist->unique_type));
2461    }
2462    sprintf(tmp, "%u", nbobjs);
2463    state.new_prop(&state, "nbobjs", tmp);
2464    sprintf(tmp, "%lu", dist->kind);
2465    state.new_prop(&state, "kind", tmp);
2466    if (dist->name)
2467      state.new_prop(&state, "name", dist->name);
2468    if (!dist->different_types) {
2469      state.new_prop(&state, "indexing",
2470  		   HWLOC_DIST_TYPE_USE_OS_INDEX(dist->unique_type) ? "os" : "gp");
2471    }
2472    if (dist->different_types) {
2473      EXPORT_TYPE_GPINDEX_ARRAY(&state, nbobjs, dist->objs, "indexes", 10);
2474    } else {
2475      EXPORT_ARRAY(&state, unsigned long long, nbobjs, dist->indexes, "indexes", "%llu", 10);
2476    }
2477    EXPORT_ARRAY(&state, unsigned long long, nbobjs*nbobjs, dist->values, "u64values", "%llu", 10);
2478    state.end_object(&state, dist->different_types ? "distances2hetero" : "distances2");
2479  }
2480  static void
2481  hwloc__xml_v2export_distances(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2482  {
2483    struct hwloc_internal_distances_s *dist;
2484    for(dist = topology->first_dist; dist; dist = dist->next)
2485      if (!dist->different_types)
2486        hwloc___xml_v2export_distances(parentstate, dist);
2487    for(dist = topology->first_dist; dist; dist = dist->next)
2488      if (dist->different_types)
2489        hwloc___xml_v2export_distances(parentstate, dist);
2490  }
2491  static void
2492  hwloc__xml_v2export_support(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2493  {
2494    struct hwloc__xml_export_state_s state;
2495    char tmp[11];
2496  #ifdef HWLOC_DEBUG
2497    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
2498    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
2499    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
2500    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
2501    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
2502  #endif
2503  #define DO(_cat,_name) do {                                     \
2504      if (topology->support._cat->_name) {                        \
2505        parentstate->new_child(parentstate, &state, "support");   \
2506        state.new_prop(&state, "name", #_cat "." #_name);         \
2507        if (topology->support._cat->_name != 1) {                 \
2508          sprintf(tmp, "%u", topology->support._cat->_name); \
2509          state.new_prop(&state, "value", tmp);                   \
2510        }                                                         \
2511        state.end_object(&state, "support");                      \
2512      }                                                           \
2513    } while (0)
2514    DO(discovery,pu);
2515    DO(discovery,numa);
2516    DO(discovery,numa_memory);
2517    DO(discovery,disallowed_pu);
2518    DO(discovery,disallowed_numa);
2519    DO(discovery,cpukind_efficiency);
2520    DO(cpubind,set_thisproc_cpubind);
2521    DO(cpubind,get_thisproc_cpubind);
2522    DO(cpubind,set_proc_cpubind);
2523    DO(cpubind,get_proc_cpubind);
2524    DO(cpubind,set_thisthread_cpubind);
2525    DO(cpubind,get_thisthread_cpubind);
2526    DO(cpubind,set_thread_cpubind);
2527    DO(cpubind,get_thread_cpubind);
2528    DO(cpubind,get_thisproc_last_cpu_location);
2529    DO(cpubind,get_proc_last_cpu_location);
2530    DO(cpubind,get_thisthread_last_cpu_location);
2531    DO(membind,set_thisproc_membind);
2532    DO(membind,get_thisproc_membind);
2533    DO(membind,set_proc_membind);
2534    DO(membind,get_proc_membind);
2535    DO(membind,set_thisthread_membind);
2536    DO(membind,get_thisthread_membind);
2537    DO(membind,set_area_membind);
2538    DO(membind,get_area_membind);
2539    DO(membind,alloc_membind);
2540    DO(membind,firsttouch_membind);
2541    DO(membind,bind_membind);
2542    DO(membind,interleave_membind);
2543    DO(membind,nexttouch_membind);
2544    DO(membind,migrate_membind);
2545    DO(membind,get_area_memlocation);
2546    parentstate->new_child(parentstate, &state, "support");
2547    state.new_prop(&state, "name", "custom.exported_support");
2548    state.end_object(&state, "support");
2549  #undef DO
2550  }
2551  static void
2552  hwloc__xml_export_memattr_target(hwloc__xml_export_state_t state,
2553                                   struct hwloc_internal_memattr_s *imattr,
2554                                   struct hwloc_internal_memattr_target_s *imtg)
2555  {
2556    struct hwloc__xml_export_state_s vstate;
2557    char tmp[255];
2558    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
2559      unsigned k;
2560      for(k=0; k<imtg->nr_initiators; k++) {
2561        struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[k];
2562        state->new_child(state, &vstate, "memattr_value");
2563        vstate.new_prop(&vstate, "target_obj_type", hwloc_obj_type_string(imtg->type));
2564        snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->gp_index);
2565        vstate.new_prop(&vstate, "target_obj_gp_index", tmp);
2566        snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imi->value);
2567        vstate.new_prop(&vstate, "value", tmp);
2568        switch (imi->initiator.type) {
2569        case HWLOC_LOCATION_TYPE_OBJECT:
2570          snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imi->initiator.location.object.gp_index);
2571          vstate.new_prop(&vstate, "initiator_obj_gp_index", tmp);
2572          vstate.new_prop(&vstate, "initiator_obj_type", hwloc_obj_type_string(imi->initiator.location.object.type));
2573          break;
2574        case HWLOC_LOCATION_TYPE_CPUSET: {
2575          char *setstring;
2576          hwloc_bitmap_asprintf(&setstring, imi->initiator.location.cpuset);
2577          if (setstring)
2578            vstate.new_prop(&vstate, "initiator_cpuset", setstring);
2579          free(setstring);
2580          break;
2581        }
2582        default:
2583          assert(0);
2584        }
2585        vstate.end_object(&vstate, "memattr_value");
2586      }
2587    } else {
2588      state->new_child(state, &vstate, "memattr_value");
2589      vstate.new_prop(&vstate, "target_obj_type", hwloc_obj_type_string(imtg->type));
2590      snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->gp_index);
2591      vstate.new_prop(&vstate, "target_obj_gp_index", tmp);
2592      snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->noinitiator_value);
2593      vstate.new_prop(&vstate, "value", tmp);
2594      vstate.end_object(&vstate, "memattr_value");
2595    }
2596  }
2597  static void
2598  hwloc__xml_export_memattrs(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2599  {
2600    unsigned id;
2601    for(id=0; id<topology->nr_memattrs; id++) {
2602      struct hwloc_internal_memattr_s *imattr;
2603      struct hwloc__xml_export_state_s mstate;
2604      char tmp[255];
2605      unsigned j;
2606      if (id == HWLOC_MEMATTR_ID_CAPACITY || id == HWLOC_MEMATTR_ID_LOCALITY)
2607        continue;
2608      imattr = &topology->memattrs[id];
2609      if (id < HWLOC_MEMATTR_ID_MAX && !imattr->nr_targets)
2610        continue;
2611      state->new_child(state, &mstate, "memattr");
2612      mstate.new_prop(&mstate, "name", imattr->name);
2613      snprintf(tmp, sizeof(tmp), "%lu", imattr->flags);
2614      mstate.new_prop(&mstate, "flags", tmp);
2615      for(j=0; j<imattr->nr_targets; j++)
2616        hwloc__xml_export_memattr_target(&mstate, imattr, &imattr->targets[j]);
2617      mstate.end_object(&mstate, "memattr");
2618    }
2619  }
2620  static void
2621  hwloc__xml_export_cpukinds(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2622  {
2623    unsigned i;
2624    for(i=0; i<topology->nr_cpukinds; i++) {
2625      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
2626      struct hwloc__xml_export_state_s cstate;
2627      char *setstring;
2628      unsigned j;
2629      state->new_child(state, &cstate, "cpukind");
2630      hwloc_bitmap_asprintf(&setstring, kind->cpuset);
2631      cstate.new_prop(&cstate, "cpuset", setstring);
2632      free(setstring);
2633      if (kind->forced_efficiency != HWLOC_CPUKIND_EFFICIENCY_UNKNOWN) {
2634        char tmp[11];
2635        snprintf(tmp, sizeof(tmp), "%d", kind->forced_efficiency);
2636        cstate.new_prop(&cstate, "forced_efficiency", tmp);
2637      }
2638      for(j=0; j<kind->nr_infos; j++) {
2639        char *name = hwloc__xml_export_safestrdup(kind->infos[j].name);
2640        char *value = hwloc__xml_export_safestrdup(kind->infos[j].value);
2641        struct hwloc__xml_export_state_s istate;
2642        cstate.new_child(&cstate, &istate, "info");
2643        istate.new_prop(&istate, "name", name);
2644        istate.new_prop(&istate, "value", value);
2645        istate.end_object(&istate, "info");
2646        free(name);
2647        free(value);
2648      }
2649      cstate.end_object(&cstate, "cpukind");
2650    }
2651  }
2652  void
2653  hwloc__xml_export_topology(hwloc__xml_export_state_t state, hwloc_topology_t topology, unsigned long flags)
2654  {
2655    char *env;
2656    hwloc_obj_t root = hwloc_get_root_obj(topology);
2657    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2658      hwloc_obj_t *numanodes, first_numanode;
2659      unsigned nr_numanodes;
2660      nr_numanodes = hwloc__xml_v1export_object_list_numanodes(root, &first_numanode, &numanodes);
2661      if (nr_numanodes) {
2662        struct hwloc__xml_export_state_s rstate, mstate;
2663        hwloc_obj_t child;
2664        unsigned i;
2665        state->new_child(state, &rstate, "object");
2666        hwloc__xml_export_object_contents (&rstate, topology, root, flags);
2667        rstate.new_child(&rstate, &mstate, "object");
2668        hwloc__xml_export_object_contents (&mstate, topology, first_numanode, flags);
2669        for_each_child(child, root)
2670  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2671        for_each_io_child(child, root)
2672  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2673        for_each_misc_child(child, root)
2674  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2675        mstate.end_object(&mstate, "object");
2676        for(i=1; i<nr_numanodes; i++)
2677  	hwloc__xml_v1export_object (&rstate, topology, numanodes[i], flags);
2678        rstate.end_object(&rstate, "object");
2679      } else {
2680        hwloc__xml_v1export_object(state, topology, root, flags);
2681      }
2682      free(numanodes);
2683    } else {
2684      hwloc__xml_v2export_object (state, topology, root, flags);
2685      hwloc__xml_v2export_distances (state, topology);
2686      env = getenv("HWLOC_XML_EXPORT_SUPPORT");
2687      if (!env || atoi(env))
2688        hwloc__xml_v2export_support(state, topology);
2689      hwloc__xml_export_memattrs(state, topology);
2690      hwloc__xml_export_cpukinds(state, topology);
2691    }
2692  }
2693  void
2694  hwloc__xml_export_diff(hwloc__xml_export_state_t parentstate, hwloc_topology_diff_t diff)
2695  {
2696    while (diff) {
2697      struct hwloc__xml_export_state_s state;
2698      char tmp[255];
2699      parentstate->new_child(parentstate, &state, "diff");
2700      sprintf(tmp, "%d", (int) diff->generic.type);
2701      state.new_prop(&state, "type", tmp);
2702      switch (diff->generic.type) {
2703      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
2704        sprintf(tmp, "%d", diff->obj_attr.obj_depth);
2705        state.new_prop(&state, "obj_depth", tmp);
2706        sprintf(tmp, "%u", diff->obj_attr.obj_index);
2707        state.new_prop(&state, "obj_index", tmp);
2708        sprintf(tmp, "%d", (int) diff->obj_attr.diff.generic.type);
2709        state.new_prop(&state, "obj_attr_type", tmp);
2710        switch (diff->obj_attr.diff.generic.type) {
2711        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
2712  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.index);
2713  	state.new_prop(&state, "obj_attr_index", tmp);
2714  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.oldvalue);
2715  	state.new_prop(&state, "obj_attr_oldvalue", tmp);
2716  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.newvalue);
2717  	state.new_prop(&state, "obj_attr_newvalue", tmp);
2718  	break;
2719        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
2720        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
2721  	if (diff->obj_attr.diff.string.name)
2722  	  state.new_prop(&state, "obj_attr_name", diff->obj_attr.diff.string.name);
2723  	state.new_prop(&state, "obj_attr_oldvalue", diff->obj_attr.diff.string.oldvalue);
2724  	state.new_prop(&state, "obj_attr_newvalue", diff->obj_attr.diff.string.newvalue);
2725  	break;
2726        }
2727        break;
2728      default:
2729        assert(0);
2730      }
2731      state.end_object(&state, "diff");
2732      diff = diff->generic.next;
2733    }
2734  }
2735  int hwloc_topology_export_xml(hwloc_topology_t topology, const char *filename, unsigned long flags)
2736  {
2737    hwloc_localeswitch_declare;
2738    struct hwloc__xml_export_data_s edata;
2739    int force_nolibxml;
2740    int ret;
2741    if (!topology->is_loaded) {
2742      errno = EINVAL;
2743      return -1;
2744    }
2745    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2746    if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2747      errno = EINVAL;
2748      return -1;
2749    }
2750    hwloc_internal_distances_refresh(topology);
2751    hwloc_localeswitch_init();
2752    edata.v1_memory_group = NULL;
2753    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2754      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2755    force_nolibxml = hwloc_nolibxml_export();
2756  retry:
2757    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2758      ret = hwloc_nolibxml_callbacks->export_file(topology, &edata, filename, flags);
2759    else {
2760      ret = hwloc_libxml_callbacks->export_file(topology, &edata, filename, flags);
2761      if (ret < 0 && errno == ENOSYS) {
2762        hwloc_libxml_callbacks = NULL;
2763        goto retry;
2764      }
2765    }
2766    if (edata.v1_memory_group)
2767      hwloc_free_unlinked_object(edata.v1_memory_group);
2768    hwloc_localeswitch_fini();
2769    return ret;
2770  }
2771  int hwloc_topology_export_xmlbuffer(hwloc_topology_t topology, char **xmlbuffer, int *buflen, unsigned long flags)
2772  {
2773    hwloc_localeswitch_declare;
2774    struct hwloc__xml_export_data_s edata;
2775    int force_nolibxml;
2776    int ret;
2777    if (!topology->is_loaded) {
2778      errno = EINVAL;
2779      return -1;
2780    }
2781    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2782    if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2783      errno = EINVAL;
2784      return -1;
2785    }
2786    hwloc_internal_distances_refresh(topology);
2787    hwloc_localeswitch_init();
2788    edata.v1_memory_group = NULL;
2789    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2790      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2791    force_nolibxml = hwloc_nolibxml_export();
2792  retry:
2793    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2794      ret = hwloc_nolibxml_callbacks->export_buffer(topology, &edata, xmlbuffer, buflen, flags);
2795    else {
2796      ret = hwloc_libxml_callbacks->export_buffer(topology, &edata, xmlbuffer, buflen, flags);
2797      if (ret < 0 && errno == ENOSYS) {
2798        hwloc_libxml_callbacks = NULL;
2799        goto retry;
2800      }
2801    }
2802    if (edata.v1_memory_group)
2803      hwloc_free_unlinked_object(edata.v1_memory_group);
2804    hwloc_localeswitch_fini();
2805    return ret;
2806  }
2807  int
2808  hwloc_topology_diff_export_xml(hwloc_topology_diff_t diff, const char *refname,
2809  			       const char *filename)
2810  {
2811    hwloc_localeswitch_declare;
2812    hwloc_topology_diff_t tmpdiff;
2813    int force_nolibxml;
2814    int ret;
2815    tmpdiff = diff;
2816    while (tmpdiff) {
2817      if (tmpdiff->generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2818        errno = EINVAL;
2819        return -1;
2820      }
2821      tmpdiff = tmpdiff->generic.next;
2822    }
2823    hwloc_components_init();
2824    assert(hwloc_nolibxml_callbacks);
2825    hwloc_localeswitch_init();
2826    force_nolibxml = hwloc_nolibxml_export();
2827  retry:
2828    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2829      ret = hwloc_nolibxml_callbacks->export_diff_file(diff, refname, filename);
2830    else {
2831      ret = hwloc_libxml_callbacks->export_diff_file(diff, refname, filename);
2832      if (ret < 0 && errno == ENOSYS) {
2833        hwloc_libxml_callbacks = NULL;
2834        goto retry;
2835      }
2836    }
2837    hwloc_localeswitch_fini();
2838    hwloc_components_fini();
2839    return ret;
2840  }
2841  int
2842  hwloc_topology_diff_export_xmlbuffer(hwloc_topology_diff_t diff, const char *refname,
2843  				     char **xmlbuffer, int *buflen)
2844  {
2845    hwloc_localeswitch_declare;
2846    hwloc_topology_diff_t tmpdiff;
2847    int force_nolibxml;
2848    int ret;
2849    tmpdiff = diff;
2850    while (tmpdiff) {
2851      if (tmpdiff->generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2852        errno = EINVAL;
2853        return -1;
2854      }
2855      tmpdiff = tmpdiff->generic.next;
2856    }
2857    hwloc_components_init();
2858    assert(hwloc_nolibxml_callbacks);
2859    hwloc_localeswitch_init();
2860    force_nolibxml = hwloc_nolibxml_export();
2861  retry:
2862    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2863      ret = hwloc_nolibxml_callbacks->export_diff_buffer(diff, refname, xmlbuffer, buflen);
2864    else {
2865      ret = hwloc_libxml_callbacks->export_diff_buffer(diff, refname, xmlbuffer, buflen);
2866      if (ret < 0 && errno == ENOSYS) {
2867        hwloc_libxml_callbacks = NULL;
2868        goto retry;
2869      }
2870    }
2871    hwloc_localeswitch_fini();
2872    hwloc_components_fini();
2873    return ret;
2874  }
2875  void hwloc_free_xmlbuffer(hwloc_topology_t topology __hwloc_attribute_unused, char *xmlbuffer)
2876  {
2877    int force_nolibxml;
2878    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2879    force_nolibxml = hwloc_nolibxml_export();
2880    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2881      hwloc_nolibxml_callbacks->free_buffer(xmlbuffer);
2882    else
2883      hwloc_libxml_callbacks->free_buffer(xmlbuffer);
2884  }
2885  void
2886  hwloc_topology_set_userdata_export_callback(hwloc_topology_t topology,
2887  					    void (*export)(void *reserved, struct hwloc_topology *topology, struct hwloc_obj *obj))
2888  {
2889    topology->userdata_export_cb = export;
2890  }
2891  static void
2892  hwloc__export_obj_userdata(hwloc__xml_export_state_t parentstate, int encoded,
2893  			   const char *name, size_t length, const void *buffer, size_t encoded_length)
2894  {
2895    struct hwloc__xml_export_state_s state;
2896    char tmp[255];
2897    parentstate->new_child(parentstate, &state, "userdata");
2898    if (name)
2899      state.new_prop(&state, "name", name);
2900    sprintf(tmp, "%lu", (unsigned long) length);
2901    state.new_prop(&state, "length", tmp);
2902    if (encoded)
2903      state.new_prop(&state, "encoding", "base64");
2904    if (encoded_length)
2905      state.add_content(&state, buffer, encoded ? encoded_length : length);
2906    state.end_object(&state, "userdata");
2907  }
2908  int
2909  hwloc_export_obj_userdata(void *reserved,
2910  			  struct hwloc_topology *topology, struct hwloc_obj *obj __hwloc_attribute_unused,
2911  			  const char *name, const void *buffer, size_t length)
2912  {
2913    hwloc__xml_export_state_t state = reserved;
2914    if (!buffer) {
2915      errno = EINVAL;
2916      return -1;
2917    }
2918    if ((name && hwloc__xml_export_check_buffer(name, strlen(name)) < 0)
2919        || hwloc__xml_export_check_buffer(buffer, length) < 0) {
2920      errno = EINVAL;
2921      return -1;
2922    }
2923    if (topology->userdata_not_decoded) {
2924      int encoded;
2925      size_t encoded_length;
2926      const char *realname;
2927      assert(name);
2928      if (!strncmp(name, "base64", 6)) {
2929        encoded = 1;
2930        encoded_length = BASE64_ENCODED_LENGTH(length);
2931      } else {
2932        assert(!strncmp(name, "normal", 6));
2933        encoded = 0;
2934        encoded_length = length;
2935      }
2936      if (name[6] == ':')
2937        realname = name+7;
2938      else {
2939        assert(!strcmp(name+6, "-anon"));
2940        realname = NULL;
2941      }
2942      hwloc__export_obj_userdata(state, encoded, realname, length, buffer, encoded_length);
2943    } else
2944      hwloc__export_obj_userdata(state, 0, name, length, buffer, length);
2945    return 0;
2946  }
2947  int
2948  hwloc_export_obj_userdata_base64(void *reserved,
2949  				 struct hwloc_topology *topology __hwloc_attribute_unused, struct hwloc_obj *obj __hwloc_attribute_unused,
2950  				 const char *name, const void *buffer, size_t length)
2951  {
2952    hwloc__xml_export_state_t state = reserved;
2953    size_t encoded_length;
2954    char *encoded_buffer;
2955    int ret __hwloc_attribute_unused;
2956    if (!buffer) {
2957      errno = EINVAL;
2958      return -1;
2959    }
2960    assert(!topology->userdata_not_decoded);
2961    if (name && hwloc__xml_export_check_buffer(name, strlen(name)) < 0) {
2962      errno = EINVAL;
2963      return -1;
2964    }
2965    encoded_length = BASE64_ENCODED_LENGTH(length);
2966    encoded_buffer = malloc(encoded_length+1);
2967    if (!encoded_buffer) {
2968      errno = ENOMEM;
2969      return -1;
2970    }
2971    ret = hwloc_encode_to_base64(buffer, length, encoded_buffer, encoded_length+1);
2972    assert(ret == (int) encoded_length);
2973    hwloc__export_obj_userdata(state, 1, name, length, encoded_buffer, encoded_length);
2974    free(encoded_buffer);
2975    return 0;
2976  }
2977  void
2978  hwloc_topology_set_userdata_import_callback(hwloc_topology_t topology,
2979  					    void (*import)(struct hwloc_topology *topology, struct hwloc_obj *obj, const char *name, const void *buffer, size_t length))
2980  {
2981    topology->userdata_import_cb = import;
2982  }
2983  static void
2984  hwloc_xml_backend_disable(struct hwloc_backend *backend)
2985  {
2986    struct hwloc_xml_backend_data_s *data = backend->private_data;
2987    data->backend_exit(data);
2988    free(data->msgprefix);
2989    free(data);
2990  }
2991  static struct hwloc_backend *
2992  hwloc_xml_component_instantiate(struct hwloc_topology *topology,
2993  				struct hwloc_disc_component *component,
2994  				unsigned excluded_phases __hwloc_attribute_unused,
2995  				const void *_data1,
2996  				const void *_data2,
2997  				const void *_data3)
2998  {
2999    struct hwloc_xml_backend_data_s *data;
3000    struct hwloc_backend *backend;
3001    const char *env;
3002    int force_nolibxml;
3003    const char * xmlpath = (const char *) _data1;
3004    const char * xmlbuffer = (const char *) _data2;
3005    int xmlbuflen = (int)(uintptr_t) _data3;
3006    const char *local_basename;
3007    int err;
3008    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the component's topology */
3009    if (!xmlpath && !xmlbuffer) {
3010      env = getenv("HWLOC_XMLFILE");
3011      if (env) {
3012        xmlpath = env;
3013      } else {
3014        errno = EINVAL;
3015        goto out;
3016      }
3017    }
3018    backend = hwloc_backend_alloc(topology, component);
3019    if (!backend)
3020      goto out;
3021    data = malloc(sizeof(*data));
3022    if (!data) {
3023      errno = ENOMEM;
3024      goto out_with_backend;
3025    }
3026    backend->private_data = data;
3027    backend->discover = hwloc_look_xml;
3028    backend->disable = hwloc_xml_backend_disable;
3029    backend->is_thissystem = 0;
3030    if (xmlpath) {
3031      local_basename = strrchr(xmlpath, '/');
3032      if (local_basename)
3033        local_basename++;
3034      else
3035        local_basename = xmlpath;
3036    } else {
3037      local_basename = "xmlbuffer";
3038    }
3039    data->msgprefix = strdup(local_basename);
3040    force_nolibxml = hwloc_nolibxml_import();
3041  retry:
3042    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
3043      err = hwloc_nolibxml_callbacks->backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3044    else {
3045      err = hwloc_libxml_callbacks->backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3046      if (err < 0 && errno == ENOSYS) {
3047        hwloc_libxml_callbacks = NULL;
3048        goto retry;
3049      }
3050    }
3051    if (err < 0)
3052      goto out_with_data;
3053    return backend;
3054   out_with_data:
3055    free(data->msgprefix);
3056    free(data);
3057   out_with_backend:
3058    free(backend);
3059   out:
3060    return NULL;
3061  }
3062  static struct hwloc_disc_component hwloc_xml_disc_component = {
3063    "xml",
3064    HWLOC_DISC_PHASE_GLOBAL,
3065    ~0,
3066    hwloc_xml_component_instantiate,
3067    30,
3068    1,
3069    NULL
3070  };
3071  const struct hwloc_component hwloc_xml_component = {
3072    HWLOC_COMPONENT_ABI,
3073    NULL, NULL,
3074    HWLOC_COMPONENT_TYPE_DISC,
3075    0,
3076    &hwloc_xml_disc_component
3077  };
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/xml.h"
4  #include "private/private.h"
5  #include "private/misc.h"
6  #include "private/debug.h"
7  #include <math.h>
8  int
9  hwloc__xml_verbose(void)
10  {
11    static int checked = 0;
12    static int verbose = 0;
13    if (!checked) {
14      const char *env = getenv("HWLOC_XML_VERBOSE");
15      if (env)
16        verbose = atoi(env);
17      checked = 1;
18    }
19    return verbose;
20  }
21  static int
22  hwloc_nolibxml_import(void)
23  {
24    static int checked = 0;
25    static int nolibxml = 0;
26    if (!checked) {
27      const char *env = getenv("HWLOC_LIBXML");
28      if (env) {
29        nolibxml = !atoi(env);
30      } else {
31        env = getenv("HWLOC_LIBXML_IMPORT");
32        if (env)
33  	nolibxml = !atoi(env);
34      }
35      checked = 1;
36    }
37    return nolibxml;
38  }
39  static int
40  hwloc_nolibxml_export(void)
41  {
42    static int checked = 0;
43    static int nolibxml = 0;
44    if (!checked) {
45      const char *env = getenv("HWLOC_LIBXML");
46      if (env) {
47        nolibxml = !atoi(env);
48      } else {
49        env = getenv("HWLOC_LIBXML_EXPORT");
50        if (env)
51  	nolibxml = !atoi(env);
52      }
53      checked = 1;
54    }
55    return nolibxml;
56  }
57  #define BASE64_ENCODED_LENGTH(length) (4*(((length)+2)/3))
58  static struct hwloc_xml_callbacks *hwloc_nolibxml_callbacks = NULL, *hwloc_libxml_callbacks = NULL;
59  void
60  hwloc_xml_callbacks_register(struct hwloc_xml_component *comp)
61  {
62    if (!hwloc_nolibxml_callbacks)
63      hwloc_nolibxml_callbacks = comp->nolibxml_callbacks;
64    if (!hwloc_libxml_callbacks)
65      hwloc_libxml_callbacks = comp->libxml_callbacks;
66  }
67  void
68  hwloc_xml_callbacks_reset(void)
69  {
70    hwloc_nolibxml_callbacks = NULL;
71    hwloc_libxml_callbacks = NULL;
72  }
73  #define _HWLOC_OBJ_CACHE_OLD (HWLOC_OBJ_TYPE_MAX+1) &bsol;* temporarily used when importing pre-v2.0 attribute-less cache types */
74  #define _HWLOC_OBJ_FUTURE    (HWLOC_OBJ_TYPE_MAX+2) &bsol;* temporarily used when ignoring future types */
75  static void
76  hwloc__xml_import_object_attr(struct hwloc_topology *topology,
77  			      struct hwloc_xml_backend_data_s *data,
78  			      struct hwloc_obj *obj,
79  			      const char *name, const char *value,
80  			      hwloc__xml_import_state_t state,
81  			      int *ignore)
82  {
83    if (!strcmp(name, "type")) {
84      return;
85    }
86    else if (!strcmp(name, "os_index"))
87      obj->os_index = strtoul(value, NULL, 10);
88    else if (!strcmp(name, "gp_index")) {
89      obj->gp_index = strtoull(value, NULL, 10);
90      if (!obj->gp_index && hwloc__xml_verbose())
91        fprintf(stderr, "%s: unexpected zero gp_index, topology may be invalid\n", state->global->msgprefix);
92      if (obj->gp_index >= topology->next_gp_index)
93        topology->next_gp_index = obj->gp_index + 1;
94    } else if (!strcmp(name, "id")) { &bsol;* forward compat */
95      if (!strncmp(value, "obj", 3)) {
96        obj->gp_index = strtoull(value+3, NULL, 10);
97        if (!obj->gp_index && hwloc__xml_verbose())
98          fprintf(stderr, "%s: unexpected zero id, topology may be invalid\n", state->global->msgprefix);
99        if (obj->gp_index >= topology->next_gp_index)
100          topology->next_gp_index = obj->gp_index + 1;
101      } else {
102        if (hwloc__xml_verbose())
103          fprintf(stderr, "%s: unexpected id `%s' not-starting with `obj', ignoring\n", state->global->msgprefix, value);
104      }
105    } else if (!strcmp(name, "cpuset")) {
106      if (!obj->cpuset)
107        obj->cpuset = hwloc_bitmap_alloc();
108      hwloc_bitmap_sscanf(obj->cpuset, value);
109    } else if (!strcmp(name, "complete_cpuset")) {
110      if (!obj->complete_cpuset)
111        obj->complete_cpuset = hwloc_bitmap_alloc();
112      hwloc_bitmap_sscanf(obj->complete_cpuset, value);
113    } else if (!strcmp(name, "allowed_cpuset")) {
114      if (!obj->parent)
115        hwloc_bitmap_sscanf(topology->allowed_cpuset, value);
116    } else if (!strcmp(name, "nodeset")) {
117      if (!obj->nodeset)
118        obj->nodeset = hwloc_bitmap_alloc();
119      hwloc_bitmap_sscanf(obj->nodeset, value);
120    } else if (!strcmp(name, "complete_nodeset")) {
121      if (!obj->complete_nodeset)
122        obj->complete_nodeset = hwloc_bitmap_alloc();
123      hwloc_bitmap_sscanf(obj->complete_nodeset, value);
124    } else if (!strcmp(name, "allowed_nodeset")) {
125      if (!obj->parent)
126        hwloc_bitmap_sscanf(topology->allowed_nodeset, value);
127    } else if (!strcmp(name, "name")) {
128      if (obj->name)
129        free(obj->name);
130      obj->name = strdup(value);
131    } else if (!strcmp(name, "subtype")) {
132      if (obj->subtype)
133        free(obj->subtype);
134      obj->subtype = strdup(value);
135    }
136    else if (!strcmp(name, "cache_size")) {
137      unsigned long long lvalue = strtoull(value, NULL, 10);
138      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
139        obj->attr->cache.size = lvalue;
140      else if (hwloc__xml_verbose())
141        fprintf(stderr, "%s: ignoring cache_size attribute for non-cache object type\n",
142  	      state->global->msgprefix);
143    }
144    else if (!strcmp(name, "cache_linesize")) {
145      unsigned long lvalue = strtoul(value, NULL, 10);
146      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
147        obj->attr->cache.linesize = lvalue;
148      else if (hwloc__xml_verbose())
149        fprintf(stderr, "%s: ignoring cache_linesize attribute for non-cache object type\n",
150  	      state->global->msgprefix);
151    }
152    else if (!strcmp(name, "cache_associativity")) {
153      int lvalue = atoi(value);
154      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE)
155        obj->attr->cache.associativity = lvalue;
156      else if (hwloc__xml_verbose())
157        fprintf(stderr, "%s: ignoring cache_associativity attribute for non-cache object type\n",
158  	      state->global->msgprefix);
159    }
160    else if (!strcmp(name, "cache_type")) {
161      unsigned long lvalue = strtoul(value, NULL, 10);
162      if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE) {
163        if (lvalue == HWLOC_OBJ_CACHE_UNIFIED
164  	  || lvalue == HWLOC_OBJ_CACHE_DATA
165  	  || lvalue == HWLOC_OBJ_CACHE_INSTRUCTION)
166  	obj->attr->cache.type = (hwloc_obj_cache_type_t) lvalue;
167        else
168          if (hwloc__xml_verbose())
169            fprintf(stderr, "%s: ignoring invalid cache_type attribute %lu\n",
170                    state->global->msgprefix, lvalue);
171      } else if (hwloc__xml_verbose())
172        fprintf(stderr, "%s: ignoring cache_type attribute for non-cache object type\n",
173  	      state->global->msgprefix);
174    }
175    else if (!strcmp(name, "local_memory")) {
176      unsigned long long lvalue = strtoull(value, NULL, 10);
177      if (obj->type == HWLOC_OBJ_NUMANODE)
178        obj->attr->numanode.local_memory = lvalue;
179      else if (!obj->parent)
180        topology->machine_memory.local_memory = lvalue;
181      else if (hwloc__xml_verbose())
182        fprintf(stderr, "%s: ignoring local_memory attribute for non-NUMAnode non-root object\n",
183  	      state->global->msgprefix);
184    }
185    else if (!strcmp(name, "depth")) {
186      unsigned long lvalue = strtoul(value, NULL, 10);
187       if (hwloc__obj_type_is_cache(obj->type) || obj->type == _HWLOC_OBJ_CACHE_OLD || obj->type == HWLOC_OBJ_MEMCACHE) {
188  	obj->attr->cache.depth = lvalue;
189       } else if (obj->type == HWLOC_OBJ_GROUP || obj->type == HWLOC_OBJ_BRIDGE) {
190       } else if (hwloc__xml_verbose())
191         fprintf(stderr, "%s: ignoring depth attribute for object type without depth\n",
192  	       state->global->msgprefix);
193    }
194    else if (!strcmp(name, "kind")) {
195      unsigned long lvalue = strtoul(value, NULL, 10);
196      if (obj->type == HWLOC_OBJ_GROUP)
197        obj->attr->group.kind = lvalue;
198      else if (hwloc__xml_verbose())
199        fprintf(stderr, "%s: ignoring kind attribute for non-group object type\n",
200  	      state->global->msgprefix);
201    }
202    else if (!strcmp(name, "subkind")) {
203      unsigned long lvalue = strtoul(value, NULL, 10);
204      if (obj->type == HWLOC_OBJ_GROUP)
205        obj->attr->group.subkind = lvalue;
206      else if (hwloc__xml_verbose())
207        fprintf(stderr, "%s: ignoring subkind attribute for non-group object type\n",
208  	      state->global->msgprefix);
209    }
210    else if (!strcmp(name, "dont_merge")) {
211      unsigned long lvalue = strtoul(value, NULL, 10);
212      if (obj->type == HWLOC_OBJ_GROUP)
213        obj->attr->group.dont_merge = (unsigned char) lvalue;
214      else if (hwloc__xml_verbose())
215        fprintf(stderr, "%s: ignoring dont_merge attribute for non-group object type\n",
216  	      state->global->msgprefix);
217    }
218    else if (!strcmp(name, "pci_busid")) {
219      switch (obj->type) {
220      case HWLOC_OBJ_PCI_DEVICE:
221      case HWLOC_OBJ_BRIDGE: {
222        unsigned domain, bus, dev, func;
223        if (sscanf(value, "%x:%02x:%02x.%01x",
224  		 &domain, &bus, &dev, &func) != 4) {
225  	if (hwloc__xml_verbose())
226  	  fprintf(stderr, "%s: ignoring invalid pci_busid format string %s\n",
227  		  state->global->msgprefix, value);
228  	*ignore = 1;
229  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
230        } else if (domain > 0xffff) {
231  	static int warned = 0;
232  	if (!warned && HWLOC_SHOW_ALL_ERRORS())
233  	  fprintf(stderr, "hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
234  	warned = 1;
235  	*ignore = 1;
236  #endif
237        } else {
238  	obj->attr->pcidev.domain = domain;
239  	obj->attr->pcidev.bus = bus;
240  	obj->attr->pcidev.dev = dev;
241  	obj->attr->pcidev.func = func;
242        }
243        break;
244      }
245      default:
246        if (hwloc__xml_verbose())
247  	fprintf(stderr, "%s: ignoring pci_busid attribute for non-PCI object\n",
248  		state->global->msgprefix);
249        break;
250      }
251    }
252    else if (!strcmp(name, "pci_type")) {
253      switch (obj->type) {
254      case HWLOC_OBJ_PCI_DEVICE:
255      case HWLOC_OBJ_BRIDGE: {
256        unsigned classid, vendor, device, subvendor, subdevice, revision;
257        if (sscanf(value, "%x [%04x:%04x] [%04x:%04x] %02x",
258  		 &classid, &vendor, &device, &subvendor, &subdevice, &revision) != 6) {
259  	if (hwloc__xml_verbose())
260  	  fprintf(stderr, "%s: ignoring invalid pci_type format string %s\n",
261  		  state->global->msgprefix, value);
262        } else {
263  	obj->attr->pcidev.class_id = classid;
264  	obj->attr->pcidev.vendor_id = vendor;
265  	obj->attr->pcidev.device_id = device;
266  	obj->attr->pcidev.subvendor_id = subvendor;
267  	obj->attr->pcidev.subdevice_id = subdevice;
268  	obj->attr->pcidev.revision = revision;
269        }
270        break;
271      }
272      default:
273        if (hwloc__xml_verbose())
274  	fprintf(stderr, "%s: ignoring pci_type attribute for non-PCI object\n",
275  		state->global->msgprefix);
276        break;
277      }
278    }
279    else if (!strcmp(name, "pci_link_speed")) {
280      switch (obj->type) {
281      case HWLOC_OBJ_PCI_DEVICE:
282      case HWLOC_OBJ_BRIDGE: {
283        obj->attr->pcidev.linkspeed = (float) atof(value);
284        break;
285      }
286      default:
287        if (hwloc__xml_verbose())
288  	fprintf(stderr, "%s: ignoring pci_link_speed attribute for non-PCI object\n",
289  		state->global->msgprefix);
290        break;
291      }
292    }
293    else if (!strcmp(name, "bridge_type")) {
294      switch (obj->type) {
295      case HWLOC_OBJ_BRIDGE: {
296        unsigned upstream_type, downstream_type;
297        if (sscanf(value, "%u-%u", &upstream_type, &downstream_type) != 2) {
298  	if (hwloc__xml_verbose())
299  	  fprintf(stderr, "%s: ignoring invalid bridge_type format string %s\n",
300  		  state->global->msgprefix, value);
301        } else {
302  	obj->attr->bridge.upstream_type = (hwloc_obj_bridge_type_t) upstream_type;
303  	obj->attr->bridge.downstream_type = (hwloc_obj_bridge_type_t) downstream_type;
304        };
305        break;
306      }
307      default:
308        if (hwloc__xml_verbose())
309  	fprintf(stderr, "%s: ignoring bridge_type attribute for non-bridge object\n",
310  		state->global->msgprefix);
311        break;
312      }
313    }
314    else if (!strcmp(name, "bridge_pci")) {
315      switch (obj->type) {
316      case HWLOC_OBJ_BRIDGE: {
317        unsigned domain, secbus, subbus;
318        if (sscanf(value, "%x:[%02x-%02x]",
319  		 &domain, &secbus, &subbus) != 3) {
320  	if (hwloc__xml_verbose())
321  	  fprintf(stderr, "%s: ignoring invalid bridge_pci format string %s\n",
322  		  state->global->msgprefix, value);
323  	*ignore = 1;
324  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
325        } else if (domain > 0xffff) {
326  	static int warned = 0;
327  	if (!warned && HWLOC_SHOW_ALL_ERRORS())
328  	  fprintf(stderr, "hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don't enable unless really needed).\n");
329  	warned = 1;
330  	*ignore = 1;
331  #endif
332        } else {
333  	obj->attr->bridge.downstream.pci.domain = domain;
334  	obj->attr->bridge.downstream.pci.secondary_bus = secbus;
335  	obj->attr->bridge.downstream.pci.subordinate_bus = subbus;
336        }
337        break;
338      }
339      default:
340        if (hwloc__xml_verbose())
341  	fprintf(stderr, "%s: ignoring bridge_pci attribute for non-bridge object\n",
342  		state->global->msgprefix);
343        break;
344      }
345    }
346    else if (!strcmp(name, "osdev_type")) {
347      switch (obj->type) {
348      case HWLOC_OBJ_OS_DEVICE: {
349        unsigned osdev_type;
350        if (sscanf(value, "%u", &osdev_type) != 1) {
351  	if (hwloc__xml_verbose())
352  	  fprintf(stderr, "%s: ignoring invalid osdev_type format string %s\n",
353  		  state->global->msgprefix, value);
354        } else
355  	obj->attr->osdev.type = (hwloc_obj_osdev_type_t) osdev_type;
356        break;
357      }
358      default:
359        if (hwloc__xml_verbose())
360  	fprintf(stderr, "%s: ignoring osdev_type attribute for non-osdev object\n",
361  		state->global->msgprefix);
362        break;
363      }
364    }
365    else if (data->version_major < 2) {
366      if (!strcmp(name, "os_level")
367  	|| !strcmp(name, "online_cpuset"))
368        { &bsol;* ignored */ }
369      else if (!strcmp(name, "dmi_board_vendor")) {
370        if (value[0])
371  	hwloc_obj_add_info(obj, "DMIBoardVendor", value);
372      }
373      else if (!strcmp(name, "dmi_board_name")) {
374        if (value[0])
375  	hwloc_obj_add_info(obj, "DMIBoardName", value);
376      }
377      else if (data->version_major < 1) {
378        if (!strcmp(name, "memory_kB")) {
379  	unsigned long long lvalue = strtoull(value, NULL, 10);
380  	if (obj->type == _HWLOC_OBJ_CACHE_OLD)
381  	  obj->attr->cache.size = lvalue << 10;
382  	else if (obj->type == HWLOC_OBJ_NUMANODE)
383  	  obj->attr->numanode.local_memory = lvalue << 10;
384  	else if (!obj->parent)
385  	  topology->machine_memory.local_memory = lvalue << 10;
386  	else if (hwloc__xml_verbose())
387  	  fprintf(stderr, "%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n",
388  		  state->global->msgprefix);
389        }
390        else if (!strcmp(name, "huge_page_size_kB")) {
391  	unsigned long lvalue = strtoul(value, NULL, 10);
392  	if (obj->type == HWLOC_OBJ_NUMANODE || !obj->parent) {
393  	  struct hwloc_numanode_attr_s *memory = obj->type == HWLOC_OBJ_NUMANODE ? &obj->attr->numanode : &topology->machine_memory;
394  	  if (!memory->page_types) {
395  	    memory->page_types = malloc(sizeof(*memory->page_types));
396  	    memory->page_types_len = 1;
397  	  }
398  	  assert(memory->page_types);
399  	  memory->page_types[0].size = lvalue << 10;
400  	} else if (hwloc__xml_verbose()) {
401  	  fprintf(stderr, "%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n",
402  		  state->global->msgprefix);
403  	}
404        }
405        else if (!strcmp(name, "huge_page_free")) {
406  	unsigned long lvalue = strtoul(value, NULL, 10);
407  	if (obj->type == HWLOC_OBJ_NUMANODE || !obj->parent) {
408  	  struct hwloc_numanode_attr_s *memory = obj->type == HWLOC_OBJ_NUMANODE ? &obj->attr->numanode : &topology->machine_memory;
409  	  if (!memory->page_types) {
410  	    memory->page_types = malloc(sizeof(*memory->page_types));
411  	    memory->page_types_len = 1;
412  	  }
413  	  assert(memory->page_types);
414  	  memory->page_types[0].count = lvalue;
415  	} else if (hwloc__xml_verbose()) {
416  	  fprintf(stderr, "%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n",
417  		  state->global->msgprefix);
418  	}
419        }
420        else goto unknown;
421      }
422      else goto unknown;
423    }
424    else {
425    unknown:
426      if (hwloc__xml_verbose())
427        fprintf(stderr, "%s: ignoring unknown object attribute %s\n",
428  	      state->global->msgprefix, name);
429    }
430  }
431  static int
432  hwloc___xml_import_info(char **infonamep, char **infovaluep,
433                          hwloc__xml_import_state_t state)
434  {
435    char *infoname = NULL;
436    char *infovalue = NULL;
437    while (1) {
438      char *attrname, *attrvalue;
439      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
440        break;
441      if (!strcmp(attrname, "name"))
442        infoname = attrvalue;
443      else if (!strcmp(attrname, "value"))
444        infovalue = attrvalue;
445      else
446        return -1;
447    }
448    *infonamep = infoname;
449    *infovaluep = infovalue;
450    return state->global->close_tag(state);
451  }
452  static int
453  hwloc__xml_import_obj_info(struct hwloc_xml_backend_data_s *data,
454                             hwloc_obj_t obj,
455                             hwloc__xml_import_state_t state)
456  {
457    char *infoname = NULL;
458    char *infovalue = NULL;
459    int err;
460    err = hwloc___xml_import_info(&infoname, &infovalue, state);
461    if (err < 0)
462      return err;
463    if (infoname) {
464      if (data->version_major < 2 &&
465  	(!strcmp(infoname, "Type") || !strcmp(infoname, "CoProcType"))) {
466        if (infovalue) {
467  	if (obj->subtype)
468  	  free(obj->subtype);
469  	obj->subtype = strdup(infovalue);
470        }
471      } else {
472        if (infovalue)
473  	hwloc_obj_add_info(obj, infoname, infovalue);
474      }
475    }
476    return err;
477  }
478  static int
479  hwloc__xml_import_pagetype(hwloc_topology_t topology __hwloc_attribute_unused, struct hwloc_numanode_attr_s *memory,
480  			   hwloc__xml_import_state_t state)
481  {
482    uint64_t size = 0, count = 0;
483    while (1) {
484      char *attrname, *attrvalue;
485      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
486        break;
487      if (!strcmp(attrname, "size"))
488        size = strtoull(attrvalue, NULL, 10);
489      else if (!strcmp(attrname, "count"))
490        count = strtoull(attrvalue, NULL, 10);
491      else
492        return -1;
493    }
494    if (size) {
495      unsigned idx = memory->page_types_len;
496      struct hwloc_memory_page_type_s *tmp;
497      tmp = realloc(memory->page_types, (idx+1)*sizeof(*memory->page_types));
498      if (tmp) { &bsol;* if failed to allocate, ignore this page_type entry */
499        memory->page_types = tmp;
500        memory->page_types_len = idx+1;
501        memory->page_types[idx].size = size;
502        memory->page_types[idx].count = count;
503      }
504    }
505    return state->global->close_tag(state);
506  }
507  static int
508  hwloc__xml_v1import_distances(struct hwloc_xml_backend_data_s *data,
509  			      hwloc_obj_t obj,
510  			      hwloc__xml_import_state_t state)
511  {
512    unsigned long reldepth = 0, nbobjs = 0;
513    float latbase = 0;
514    char *tag;
515    int ret;
516    while (1) {
517      char *attrname, *attrvalue;
518      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
519        break;
520      if (!strcmp(attrname, "nbobjs"))
521        nbobjs = strtoul(attrvalue, NULL, 10);
522      else if (!strcmp(attrname, "relative_depth"))
523        reldepth = strtoul(attrvalue, NULL, 10);
524      else if (!strcmp(attrname, "latency_base"))
525        latbase = (float) atof(attrvalue);
526      else
527        return -1;
528    }
529    if (nbobjs && reldepth && latbase) {
530      unsigned i;
531      float *matrix;
532      struct hwloc__xml_imported_v1distances_s *v1dist;
533      matrix = malloc(nbobjs*nbobjs*sizeof(float));
534      v1dist = malloc(sizeof(*v1dist));
535      if (!matrix || !v1dist) {
536        if (hwloc__xml_verbose())
537  	fprintf(stderr, "%s: failed to allocate v1distance matrix for %lu objects\n",
538  		state->global->msgprefix, nbobjs);
539        free(v1dist);
540        free(matrix);
541        return -1;
542      }
543      v1dist->kind = HWLOC_DISTANCES_KIND_FROM_OS|HWLOC_DISTANCES_KIND_MEANS_LATENCY;
544      v1dist->nbobjs = nbobjs;
545      v1dist->floats = matrix;
546      for(i=0; i<nbobjs*nbobjs; i++) {
547        struct hwloc__xml_import_state_s childstate;
548        char *attrname, *attrvalue;
549        float val;
550        ret = state->global->find_child(state, &childstate, &tag);
551        if (ret <= 0 || strcmp(tag, "latency")) {
552  	free(matrix);
553  	free(v1dist);
554  	return -1;
555        }
556        ret = state->global->next_attr(&childstate, &attrname, &attrvalue);
557        if (ret < 0 || strcmp(attrname, "value")) {
558  	free(matrix);
559  	free(v1dist);
560  	return -1;
561        }
562        val = (float) atof((char *) attrvalue);
563        matrix[i] = val * latbase;
564        ret = state->global->close_tag(&childstate);
565        if (ret < 0) {
566  	free(matrix);
567  	free(v1dist);
568  	return -1;
569        }
570        state->global->close_child(&childstate);
571      }
572      if (nbobjs < 2) {
573        assert(nbobjs == 1);
574        if (hwloc__xml_verbose())
575  	fprintf(stderr, "%s: ignoring invalid distance matrix with only 1 object\n",
576  		state->global->msgprefix);
577        free(matrix);
578        free(v1dist);
579      } else if (obj->parent) {
580        free(matrix);
581        free(v1dist);
582      } else {
583        v1dist->prev = data->last_v1dist;
584        v1dist->next = NULL;
585        if (data->last_v1dist)
586  	data->last_v1dist->next = v1dist;
587        else
588  	data->first_v1dist = v1dist;
589        data->last_v1dist = v1dist;
590      }
591    }
592    return state->global->close_tag(state);
593  }
594  static int
595  hwloc__xml_import_userdata(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj,
596  			   hwloc__xml_import_state_t state)
597  {
598    size_t length = 0;
599    int encoded = 0;
600    char *name = NULL; &bsol;* optional */
601    int ret;
602    while (1) {
603      char *attrname, *attrvalue;
604      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
605        break;
606      if (!strcmp(attrname, "length"))
607        length = strtoul(attrvalue, NULL, 10);
608      else if (!strcmp(attrname, "encoding"))
609        encoded = !strcmp(attrvalue, "base64");
610      else if (!strcmp(attrname, "name"))
611        name = attrvalue;
612      else
613        return -1;
614    }
615    if (!topology->userdata_import_cb) {
616      const char *buffer;
617      size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
618      ret = state->global->get_content(state, &buffer, reallength);
619      if (ret < 0)
620        return -1;
621    } else if (topology->userdata_not_decoded) {
622        const char *buffer;
623        char *fakename;
624        size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
625        ret = state->global->get_content(state, &buffer, reallength);
626        if (ret < 0)
627          return -1;
628        fakename = malloc(6 + 1 + (name ? strlen(name) : 4) + 1);
629        if (!fakename)
630  	return -1;
631        sprintf(fakename, encoded ? "base64%c%s" : "normal%c%s", name ? ':' : '-', name ? name : "anon");
632        topology->userdata_import_cb(topology, obj, fakename, buffer, length);
633        free(fakename);
634    } else if (encoded && length) {
635        const char *encoded_buffer;
636        size_t encoded_length = BASE64_ENCODED_LENGTH(length);
637        ret = state->global->get_content(state, &encoded_buffer, encoded_length);
638        if (ret < 0)
639          return -1;
640        if (ret) {
641  	char *decoded_buffer = malloc(length+1);
642  	if (!decoded_buffer)
643  	  return -1;
644  	assert(encoded_buffer[encoded_length] == 0);
645  	ret = hwloc_decode_from_base64(encoded_buffer, decoded_buffer, length+1);
646  	if (ret != (int) length) {
647  	  free(decoded_buffer);
648  	  return -1;
649  	}
650  	topology->userdata_import_cb(topology, obj, name, decoded_buffer, length);
651  	free(decoded_buffer);
652        }
653    } else { &bsol;* always handle length==0 in the non-encoded case */
654        const char *buffer = "";
655        if (length) {
656  	ret = state->global->get_content(state, &buffer, length);
657  	if (ret < 0)
658  	  return -1;
659        }
660        topology->userdata_import_cb(topology, obj, name, buffer, length);
661    }
662    state->global->close_content(state);
663    return state->global->close_tag(state);
664  }
665  static void hwloc__xml_import_report_outoforder(hwloc_topology_t topology, hwloc_obj_t new, hwloc_obj_t old)
666  {
667    char *progname = hwloc_progname(topology);
668    const char *origversion = hwloc_obj_get_info_by_name(topology->levels[0][0], "hwlocVersion");
669    const char *origprogname = hwloc_obj_get_info_by_name(topology->levels[0][0], "ProcessName");
670    char *c1, *cc1, t1[64];
671    char *c2 = NULL, *cc2 = NULL, t2[64];
672    hwloc_bitmap_asprintf(&c1, new->cpuset);
673    hwloc_bitmap_asprintf(&cc1, new->complete_cpuset);
674    hwloc_obj_type_snprintf(t1, sizeof(t1), new, 0);
675    if (old->cpuset)
676      hwloc_bitmap_asprintf(&c2, old->cpuset);
677    if (old->complete_cpuset)
678      hwloc_bitmap_asprintf(&cc2, old->complete_cpuset);
679    hwloc_obj_type_snprintf(t2, sizeof(t2), old, 0);
680    fprintf(stderr, "****************************************************************************\n");
681    fprintf(stderr, "* hwloc has encountered an out-of-order XML topology load.\n");
682    fprintf(stderr, "* Object %s cpuset %s complete %s\n",
683  	  t1, c1, cc1);
684    fprintf(stderr, "* was inserted after object %s with %s and %s.\n",
685  	  t2, c2 ? c2 : "none", cc2 ? cc2 : "none");
686    fprintf(stderr, "* The error occured in hwloc %s inside process `%s', while\n",
687  	  HWLOC_VERSION,
688  	  progname ? progname : "<unknown>");
689    if (origversion || origprogname)
690      fprintf(stderr, "* the input XML was generated by hwloc %s inside process `%s'.\n",
691  	    origversion ? origversion : "(unknown version)",
692  	    origprogname ? origprogname : "<unknown>");
693    else
694      fprintf(stderr, "* the input XML was generated by an unspecified ancient hwloc release.\n");
695    fprintf(stderr, "* Please check that your input topology XML file is valid.\n");
696    fprintf(stderr, "* Set HWLOC_DEBUG_CHECK=1 in the environment to detect further issues.\n");
697    fprintf(stderr, "****************************************************************************\n");
698    free(c1);
699    free(cc1);
700    free(c2);
701    free(cc2);
702    free(progname);
703  }
704  static int
705  hwloc__xml_import_object(hwloc_topology_t topology,
706  			 struct hwloc_xml_backend_data_s *data,
707  			 hwloc_obj_t parent, hwloc_obj_t obj, int *gotignored,
708  			 hwloc__xml_import_state_t state)
709  {
710    int ignored = 0;
711    int childrengotignored = 0;
712    int attribute_less_cache = 0;
713    int numa_was_root = 0;
714    char *tag;
715    struct hwloc__xml_import_state_s childstate;
716    obj->parent = parent;
717    while (1) {
718      char *attrname, *attrvalue;
719      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
720        break;
721      if (!strcmp(attrname, "type")) {
722        if (hwloc_type_sscanf(attrvalue, &obj->type, NULL, 0) < 0) {
723  	if (!strcasecmp(attrvalue, "Cache")) {
724  	  obj->type = _HWLOC_OBJ_CACHE_OLD; &bsol;* will be fixed below */
725  	  attribute_less_cache = 1;
726  	} else if (!strcasecmp(attrvalue, "System")) {
727  	  if (!parent)
728  	    obj->type = HWLOC_OBJ_MACHINE;
729  	  else {
730  	    if (hwloc__xml_verbose())
731  	      fprintf(stderr, "%s: obsolete System object only allowed at root\n",
732  		      state->global->msgprefix);
733  	    goto error_with_object;
734  	  }
735  	} else if (!strcasecmp(attrvalue, "Tile")) {
736  	  obj->type = HWLOC_OBJ_GROUP;
737  	  obj->attr->group.kind = HWLOC_GROUP_KIND_INTEL_TILE;
738  	} else if (!strcasecmp(attrvalue, "Module")) {
739  	  obj->type = HWLOC_OBJ_GROUP;
740  	  obj->attr->group.kind = HWLOC_GROUP_KIND_INTEL_MODULE;
741  	} else if (!strcasecmp(attrvalue, "MemCache")) {
742  	  obj->type = _HWLOC_OBJ_FUTURE;
743  	  ignored = 1;
744  	  if (hwloc__xml_verbose())
745  	    fprintf(stderr, "%s: %s object not-supported, will be ignored\n",
746  		    state->global->msgprefix, attrvalue);
747  	} else {
748  	  if (hwloc__xml_verbose())
749  	    fprintf(stderr, "%s: unrecognized object type string %s\n",
750  		    state->global->msgprefix, attrvalue);
751  	  goto error_with_object;
752  	}
753        }
754      } else {
755        if (obj->type == HWLOC_OBJ_TYPE_NONE) {
756  	if (hwloc__xml_verbose())
757  	  fprintf(stderr, "%s: object attribute %s found before type\n",
758  		  state->global->msgprefix,  attrname);
759  	goto error_with_object;
760        }
761        hwloc__xml_import_object_attr(topology, data, obj, attrname, attrvalue, state, &ignored);
762      }
763    }
764    while (1) {
765      int ret;
766      tag = NULL;
767      ret = state->global->find_child(state, &childstate, &tag);
768      if (ret < 0)
769        goto error;
770      if (!ret)
771        break;
772      if (!strcmp(tag, "object")) {
773        break;
774      } else if (!strcmp(tag, "page_type")) {
775        if (obj->type == HWLOC_OBJ_NUMANODE) {
776  	ret = hwloc__xml_import_pagetype(topology, &obj->attr->numanode, &childstate);
777        } else if (!parent) {
778  	ret = hwloc__xml_import_pagetype(topology, &topology->machine_memory, &childstate);
779        } else {
780  	if (hwloc__xml_verbose())
781  	  fprintf(stderr, "%s: invalid non-NUMAnode object child %s\n",
782  		  state->global->msgprefix, tag);
783  	ret = -1;
784        }
785      } else if (!strcmp(tag, "info")) {
786        ret = hwloc__xml_import_obj_info(data, obj, &childstate);
787      } else if (data->version_major < 2 && !strcmp(tag, "distances")) {
788        ret = hwloc__xml_v1import_distances(data, obj, &childstate);
789      } else if (!strcmp(tag, "userdata")) {
790        ret = hwloc__xml_import_userdata(topology, obj, &childstate);
791      } else {
792        if (hwloc__xml_verbose())
793  	fprintf(stderr, "%s: invalid special object child %s\n",
794  		state->global->msgprefix, tag);
795        ret = -1;
796      }
797      if (ret < 0)
798        goto error;
799      state->global->close_child(&childstate);
800    }
801    if (parent && obj->type == HWLOC_OBJ_MACHINE) {
802      obj->type = HWLOC_OBJ_GROUP;
803    }
804    if (parent && data->version_major >= 2) {
805      if (hwloc__obj_type_is_normal(obj->type)) {
806        if (!hwloc__obj_type_is_normal(parent->type)) {
807  	if (hwloc__xml_verbose())
808  	  fprintf(stderr, "normal object %s cannot be child of non-normal parent %s\n",
809  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
810  	goto error_with_object;
811        }
812      } else if (hwloc__obj_type_is_memory(obj->type)) {
813        if (hwloc__obj_type_is_io(parent->type) || HWLOC_OBJ_MISC == parent->type) {
814  	if (hwloc__xml_verbose())
815  	  fprintf(stderr, "Memory object %s cannot be child of non-normal-or-memory parent %s\n",
816  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
817  	goto error_with_object;
818        }
819      } else if (hwloc__obj_type_is_io(obj->type)) {
820        if (hwloc__obj_type_is_memory(parent->type) || HWLOC_OBJ_MISC == parent->type) {
821  	if (hwloc__xml_verbose())
822  	  fprintf(stderr, "I/O object %s cannot be child of non-normal-or-I/O parent %s\n",
823  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
824  	goto error_with_object;
825        }
826      }
827    } else if (parent && data->version_major < 2) {
828      if (hwloc__obj_type_is_normal(obj->type) || HWLOC_OBJ_NUMANODE == obj->type) {
829        if (hwloc__obj_type_is_special(parent->type)) {
830  	if (hwloc__xml_verbose())
831  	  fprintf(stderr, "v1.x normal v1.x object %s cannot be child of special parent %s\n",
832  		  hwloc_obj_type_string(obj->type), hwloc_obj_type_string(parent->type));
833  	goto error_with_object;
834        }
835      } else if (hwloc__obj_type_is_io(obj->type)) {
836        if (HWLOC_OBJ_MISC == parent->type) {
837  	if (hwloc__xml_verbose())
838  	  fprintf(stderr, "I/O object %s cannot be child of Misc parent\n",
839  		  hwloc_obj_type_string(obj->type));
840  	goto error_with_object;
841        }
842      }
843    }
844    if (data->version_major < 2) {
845      if (parent && parent->type == HWLOC_OBJ_NUMANODE) {
846        parent = parent->parent;
847        assert(parent);
848      }
849      if (obj->type == HWLOC_OBJ_NUMANODE) {
850        if (!parent) {
851  	hwloc_obj_t machine = hwloc_alloc_setup_object(topology, HWLOC_OBJ_MACHINE, HWLOC_UNKNOWN_INDEX);
852  	machine->cpuset = hwloc_bitmap_dup(obj->cpuset);
853  	machine->complete_cpuset = hwloc_bitmap_dup(obj->cpuset);
854  	machine->nodeset = hwloc_bitmap_dup(obj->nodeset);
855  	machine->complete_nodeset = hwloc_bitmap_dup(obj->complete_nodeset);
856  	topology->levels[0][0] = machine;
857  	parent = machine;
858  	numa_was_root = 1;
859        } else if (!hwloc_bitmap_isequal(obj->complete_cpuset, parent->complete_cpuset)) {
860  	int needgroup = 1;
861  	hwloc_obj_t sibling;
862  	sibling = parent->memory_first_child;
863  	if (sibling && !sibling->subtype
864  	    && !sibling->next_sibling
865  	    && obj->subtype && !strcmp(obj->subtype, "MCDRAM")
866  	    && hwloc_bitmap_iszero(obj->complete_cpuset)) {
867  	  needgroup = 0;
868  	}
869  	if (needgroup
870  	    && hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
871  	  hwloc_obj_t group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
872  	  group->gp_index = 0; &bsol;* will be initialized at the end of the discovery once we know the max */
873  	  group->cpuset = hwloc_bitmap_dup(obj->cpuset);
874  	  group->complete_cpuset = hwloc_bitmap_dup(obj->cpuset);
875  	  group->nodeset = hwloc_bitmap_dup(obj->nodeset);
876  	  group->complete_nodeset = hwloc_bitmap_dup(obj->complete_nodeset);
877  	  group->attr->group.kind = HWLOC_GROUP_KIND_MEMORY;
878  	  hwloc_insert_object_by_parent(topology, parent, group);
879  	  parent = group;
880  	}
881        }
882      }
883      if (attribute_less_cache) {
884        assert(obj->type == _HWLOC_OBJ_CACHE_OLD);
885        obj->type = hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type);
886      }
887      if (obj->type == HWLOC_OBJ_MISC && obj->cpuset)
888        obj->type = HWLOC_OBJ_GROUP;
889      if (!obj->cpuset != !obj->complete_cpuset) {
890        if (obj->type == HWLOC_OBJ_GROUP) {
891  	ignored = 1;
892        } else {
893  	if (hwloc__xml_verbose())
894  	  fprintf(stderr, "%s: invalid object %s P#%u with some missing cpusets\n",
895  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
896  	goto error_with_object;
897        }
898      } else if (!obj->nodeset != !obj->complete_nodeset) {
899        if (obj->type == HWLOC_OBJ_GROUP) {
900  	ignored = 1;
901        } else {
902  	if (hwloc__xml_verbose())
903  	  fprintf(stderr, "%s: invalid object %s P#%u with some missing nodesets\n",
904  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
905  	goto error_with_object;
906        }
907      } else if (obj->nodeset && !obj->cpuset) {
908        if (obj->type == HWLOC_OBJ_GROUP) {
909  	ignored = 1;
910        } else {
911  	if (hwloc__xml_verbose())
912  	  fprintf(stderr, "%s: invalid object %s P#%u with either cpuset or nodeset missing\n",
913  		  state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
914  	goto error_with_object;
915        }
916      }
917    }
918    if (obj->type == HWLOC_OBJ_GROUP) {
919      if (obj->attr->group.kind == HWLOC_GROUP_KIND_INTEL_DIE
920  	|| (obj->subtype && !strcmp(obj->subtype, "Die")))
921        obj->type = HWLOC_OBJ_DIE;
922    }
923    if (hwloc__obj_type_is_cache(obj->type)
924        && obj->type != hwloc_cache_type_by_depth_type(obj->attr->cache.depth, obj->attr->cache.type)) {
925      if (hwloc__xml_verbose())
926        fprintf(stderr, "%s: invalid cache type %s with attribute depth %u and type %d\n",
927  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->attr->cache.depth, (int) obj->attr->cache.type);
928      goto error_with_object;
929    }
930    if (!obj->cpuset && !hwloc__obj_type_is_special(obj->type)) {
931      if (hwloc__xml_verbose())
932        fprintf(stderr, "%s: invalid normal object %s P#%u without cpuset\n",
933  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
934      goto error_with_object;
935    }
936    if (obj->cpuset && hwloc__obj_type_is_special(obj->type)) {
937      if (hwloc__xml_verbose())
938        fprintf(stderr, "%s: invalid special object %s with cpuset\n",
939  	      state->global->msgprefix, hwloc_obj_type_string(obj->type));
940      goto error_with_object;
941    }
942    if (obj->cpuset && parent && !parent->cpuset) {
943      if (hwloc__xml_verbose())
944        fprintf(stderr, "%s: invalid object %s P#%u with cpuset while parent has none\n",
945  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
946      goto error_with_object;
947    }
948    if (obj->nodeset && parent && !parent->nodeset) {
949      if (hwloc__xml_verbose())
950        fprintf(stderr, "%s: invalid object %s P#%u with nodeset while parent has none\n",
951  	      state->global->msgprefix, hwloc_obj_type_string(obj->type), obj->os_index);
952      goto error_with_object;
953    }
954    if (obj->type == HWLOC_OBJ_NUMANODE) {
955      if (!obj->nodeset) {
956        if (hwloc__xml_verbose())
957  	fprintf(stderr, "%s: invalid NUMA node object P#%u without nodeset\n",
958  		state->global->msgprefix, obj->os_index);
959        goto error_with_object;
960      }
961      data->nbnumanodes++;
962      obj->prev_cousin = data->last_numanode;
963      obj->next_cousin = NULL;
964      if (data->last_numanode)
965        data->last_numanode->next_cousin = obj;
966      else
967        data->first_numanode = obj;
968      data->last_numanode = obj;
969    }
970    if (!hwloc_filter_check_keep_object(topology, obj)) {
971      if (parent)
972        ignored = 1;
973    }
974    if (parent && !ignored) {
975      hwloc_insert_object_by_parent(topology, parent, obj);
976    }
977    while (tag) {
978      int ret;
979      if (!strcmp(tag, "object")) {
980        hwloc_obj_t childobj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_TYPE_MAX, HWLOC_UNKNOWN_INDEX);
981        childobj->parent = ignored ? parent : obj;
982        ret = hwloc__xml_import_object(topology, data, ignored ? parent : obj, childobj,
983  				     &childrengotignored,
984  				     &childstate);
985      } else {
986        if (hwloc__xml_verbose())
987  	fprintf(stderr, "%s: invalid special object child %s while looking for objects\n",
988  		state->global->msgprefix, tag);
989        ret = -1;
990      }
991      if (ret < 0) {
992        if (parent && !ignored)
993          goto error;
994        else
995          goto error_with_object;
996      }
997      state->global->close_child(&childstate);
998      tag = NULL;
999      ret = state->global->find_child(state, &childstate, &tag);
1000      if (ret < 0) {
1001        if (parent && !ignored)
1002          goto error;
1003        else
1004          goto error_with_object;
1005      }
1006      if (!ret)
1007        break;
1008    }
1009    if (numa_was_root) {
1010      unsigned i;
1011      for(i=0; i<obj->infos_count; i++) {
1012        struct hwloc_info_s *info = &obj->infos[i];
1013        hwloc_obj_add_info(parent, info->name, info->value);
1014      }
1015    }
1016    if (ignored) {
1017      hwloc_free_unlinked_object(obj);
1018      *gotignored = 1;
1019    } else if (obj->first_child) {
1020      hwloc_obj_t cur, next;
1021      for(cur = obj->first_child, next = cur->next_sibling;
1022  	next;
1023  	cur = next, next = next->next_sibling) {
1024        if (hwloc_bitmap_compare_first(next->complete_cpuset, cur->complete_cpuset) < 0) {
1025  	if (!childrengotignored) {
1026  	  static int reported = 0;
1027  	  if (!reported && HWLOC_SHOW_CRITICAL_ERRORS()) {
1028  	    hwloc__xml_import_report_outoforder(topology, next, cur);
1029  	    reported = 1;
1030  	  }
1031  	}
1032  	hwloc__reorder_children(obj);
1033  	break;
1034        }
1035      }
1036    }
1037    return state->global->close_tag(state);
1038   error_with_object:
1039    if (parent)
1040      hwloc_free_unlinked_object(obj);
1041   error:
1042    return -1;
1043  }
1044  static int
1045  hwloc__xml_v2import_support(hwloc_topology_t topology,
1046                              hwloc__xml_import_state_t state)
1047  {
1048    char *name = NULL;
1049    int value = 1; &bsol;* value is optional */
1050    while (1) {
1051      char *attrname, *attrvalue;
1052      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1053        break;
1054      if (!strcmp(attrname, "name"))
1055        name = attrvalue;
1056      else if (!strcmp(attrname, "value"))
1057        value = atoi(attrvalue);
1058      else {
1059        if (hwloc__xml_verbose())
1060  	fprintf(stderr, "%s: ignoring unknown support attribute %s\n",
1061  		state->global->msgprefix, attrname);
1062      }
1063    }
1064    if (name && topology->flags & HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT) {
1065  #ifdef HWLOC_DEBUG
1066      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
1067      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
1068      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
1069      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
1070      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
1071  #endif
1072  #define DO(_cat,_name) if (!strcmp(#_cat "." #_name, name)) topology->support._cat->_name = value
1073      DO(discovery,pu);
1074      else DO(discovery,numa);
1075      else DO(discovery,numa_memory);
1076      else DO(discovery,disallowed_pu);
1077      else DO(discovery,disallowed_numa);
1078      else DO(discovery,cpukind_efficiency);
1079      else DO(cpubind,set_thisproc_cpubind);
1080      else DO(cpubind,get_thisproc_cpubind);
1081      else DO(cpubind,set_proc_cpubind);
1082      else DO(cpubind,get_proc_cpubind);
1083      else DO(cpubind,set_thisthread_cpubind);
1084      else DO(cpubind,get_thisthread_cpubind);
1085      else DO(cpubind,set_thread_cpubind);
1086      else DO(cpubind,get_thread_cpubind);
1087      else DO(cpubind,get_thisproc_last_cpu_location);
1088      else DO(cpubind,get_proc_last_cpu_location);
1089      else DO(cpubind,get_thisthread_last_cpu_location);
1090      else DO(membind,set_thisproc_membind);
1091      else DO(membind,get_thisproc_membind);
1092      else DO(membind,set_proc_membind);
1093      else DO(membind,get_proc_membind);
1094      else DO(membind,set_thisthread_membind);
1095      else DO(membind,get_thisthread_membind);
1096      else DO(membind,set_area_membind);
1097      else DO(membind,get_area_membind);
1098      else DO(membind,alloc_membind);
1099      else DO(membind,firsttouch_membind);
1100      else DO(membind,bind_membind);
1101      else DO(membind,interleave_membind);
1102      else DO(membind,nexttouch_membind);
1103      else DO(membind,migrate_membind);
1104      else DO(membind,get_area_memlocation);
1105      else if (!strcmp("custom.exported_support", name))
1106        topology->support.misc->imported_support = 1;
1107  #undef DO
1108    }
1109    return 0;
1110  }
1111  static int
1112  hwloc__xml_v2import_distances(hwloc_topology_t topology,
1113  			      hwloc__xml_import_state_t state,
1114  			      int heterotypes)
1115  {
1116    hwloc_obj_type_t unique_type = HWLOC_OBJ_TYPE_NONE;
1117    hwloc_obj_type_t *different_types = NULL;
1118    unsigned nbobjs = 0;
1119    int indexing = heterotypes;
1120    int os_indexing = 0;
1121    int gp_indexing = heterotypes;
1122    char *name = NULL;
1123    unsigned long kind = 0;
1124    unsigned nr_indexes, nr_u64values;
1125    uint64_t *indexes;
1126    uint64_t *u64values;
1127    int ret;
1128  #define _TAG_NAME (heterotypes ? "distances2hetero" : "distances2")
1129    while (1) {
1130      char *attrname, *attrvalue;
1131      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1132        break;
1133      if (!strcmp(attrname, "nbobjs"))
1134        nbobjs = strtoul(attrvalue, NULL, 10);
1135      else if (!strcmp(attrname, "type")) {
1136        if (hwloc_type_sscanf(attrvalue, &unique_type, NULL, 0) < 0) {
1137  	if (hwloc__xml_verbose())
1138  	  fprintf(stderr, "%s: unrecognized %s type %s\n",
1139  		  state->global->msgprefix, _TAG_NAME, attrvalue);
1140  	goto out;
1141        }
1142      }
1143      else if (!strcmp(attrname, "indexing")) {
1144        indexing = 1;
1145        if (!strcmp(attrvalue, "os"))
1146  	os_indexing = 1;
1147        else if (!strcmp(attrvalue, "gp"))
1148  	gp_indexing = 1;
1149      }
1150      else if (!strcmp(attrname, "kind")) {
1151        kind = strtoul(attrvalue, NULL, 10);
1152      }
1153      else if (!strcmp(attrname, "name")) {
1154        name = attrvalue;
1155      }
1156      else {
1157        if (hwloc__xml_verbose())
1158  	fprintf(stderr, "%s: ignoring unknown %s attribute %s\n",
1159  		state->global->msgprefix, _TAG_NAME, attrname);
1160      }
1161    }
1162    if (!nbobjs || (!heterotypes && unique_type == HWLOC_OBJ_TYPE_NONE) || !indexing || !kind) {
1163      if (hwloc__xml_verbose())
1164        fprintf(stderr, "%s: %s missing some attributes\n",
1165  	      state->global->msgprefix, _TAG_NAME);
1166      goto out;
1167    }
1168    indexes = malloc(nbobjs*sizeof(*indexes));
1169    u64values = malloc(nbobjs*nbobjs*sizeof(*u64values));
1170    if (heterotypes)
1171      different_types = malloc(nbobjs*sizeof(*different_types));
1172    if (!indexes || !u64values || (heterotypes && !different_types)) {
1173      if (hwloc__xml_verbose())
1174        fprintf(stderr, "%s: failed to allocate %s arrays for %u objects\n",
1175  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
1179    nr_u64values = 0;
1180    while (1) {
1181      struct hwloc__xml_import_state_s childstate;
1182      char *attrname, *attrvalue, *tag;
1183      const char *buffer;
1184      int length;
1185      int is_index = 0;
1186      int is_u64values = 0;
1187      ret = state->global->find_child(state, &childstate, &tag);
1188      if (ret <= 0)
1189        break;
1190      if (!strcmp(tag, "indexes"))
1191        is_index = 1;
1192      else if (!strcmp(tag, "u64values"))
1193        is_u64values = 1;
1194      if (!is_index && !is_u64values) {
1195        if (hwloc__xml_verbose())
1196  	fprintf(stderr, "%s: %s with unrecognized child %s\n",
1197  		state->global->msgprefix, _TAG_NAME, tag);
1198        goto out_with_arrays;
1199      }
1200      if (state->global->next_attr(&childstate, &attrname, &attrvalue) < 0
1201  	|| strcmp(attrname, "length")) {
1202        if (hwloc__xml_verbose())
1203  	fprintf(stderr, "%s: %s child must have length attribute\n",
1204  		state->global->msgprefix, _TAG_NAME);
1205        goto out_with_arrays;
1206      }
1207      length = atoi(attrvalue);
1208      ret = state->global->get_content(&childstate, &buffer, length);
1209      if (ret < 0) {
1210        if (hwloc__xml_verbose())
1211  	fprintf(stderr, "%s: %s child needs content of length %d\n",
1212  		state->global->msgprefix, _TAG_NAME, length);
1213        goto out_with_arrays;
1214      }
1215      if (is_index) {
1216        const char *tmp, *tmp2;
1217        if (nr_indexes >= nbobjs) {
1218  	if (hwloc__xml_verbose())
1219  	  fprintf(stderr, "%s: %s with more than %u indexes\n",
1220  		  state->global->msgprefix, _TAG_NAME, nbobjs);
1221  	goto out_with_arrays;
1222        }
1223        tmp = buffer;
1224        while (1) {
1225  	char *next;
1226  	unsigned long long u;
1227  	if (heterotypes) {
1228  	  hwloc_obj_type_t t = HWLOC_OBJ_TYPE_NONE;
1229            if (!*tmp)
1230              break;
1231  	  if (hwloc_type_sscanf(tmp, &t, NULL, 0) < 0) {
1232  	    if (hwloc__xml_verbose())
1233  	      fprintf(stderr, "%s: %s with unrecognized heterogeneous type %s\n",
<span onclick='openModal()' class='match'>1234  		      state->global->msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, ':');
</span>1238  	  if (!tmp2) {
1239  	    if (hwloc__xml_verbose())
1240  	      fprintf(stderr, "%s: %s with missing colon after heterogeneous type %s\n",
1241  		      state->global->msgprefix, _TAG_NAME, tmp);
1242  	    goto out_with_arrays;
1243  	  }
1244  	  tmp = tmp2+1;
1245  	  different_types[nr_indexes] = t;
1246  	}
1247  	u = strtoull(tmp, &next, 0);
1248  	if (next == tmp)
1249  	  break;
1250  	indexes[nr_indexes++] = u;
1251  	if (*next != ' ')
1252  	  break;
1253  	if (nr_indexes == nbobjs)
1254  	  break;
1255  	tmp = next+1;
1256        }
1257      } else if (is_u64values) {
1258        const char *tmp;
1259        if (nr_u64values >= nbobjs*nbobjs) {
1260  	if (hwloc__xml_verbose())
1261  	  fprintf(stderr, "%s: %s with more than %u u64values\n",
1262  		  state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
1263  	goto out_with_arrays;
1264        }
1265        tmp = buffer;
1266        while (1) {
1267  	char *next;
1268  	unsigned long long u = strtoull(tmp, &next, 0);
1269  	if (next == tmp)
1270  	  break;
1271  	u64values[nr_u64values++] = u;
1272  	if (*next != ' ')
1273  	  break;
1274  	if (nr_u64values == nbobjs*nbobjs)
1275  	  break;
1276  	tmp = next+1;
1277        }
1278      }
1279      state->global->close_content(&childstate);
1280      ret = state->global->close_tag(&childstate);
1281      if (ret < 0) {
1282        if (hwloc__xml_verbose())
1283  	fprintf(stderr, "%s: %s with more than %u indexes\n",
1284  		state->global->msgprefix, _TAG_NAME, nbobjs);
1285        goto out_with_arrays;
1286      }
1287      state->global->close_child(&childstate);
1288    }
1289    if (nr_indexes != nbobjs) {
1290      if (hwloc__xml_verbose())
1291        fprintf(stderr, "%s: %s with less than %u indexes\n",
1292  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1293      goto out_with_arrays;
1294    }
1295    if (nr_u64values != nbobjs*nbobjs) {
1296      if (hwloc__xml_verbose())
1297        fprintf(stderr, "%s: %s with less than %u u64values\n",
1298  	      state->global->msgprefix, _TAG_NAME, nbobjs*nbobjs);
1299      goto out_with_arrays;
1300    }
1301    if (nbobjs < 2) {
1302      if (hwloc__xml_verbose())
1303        fprintf(stderr, "%s: ignoring %s with only %u objects\n",
1304  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1305      goto out_ignore;
1306    }
1307    if (unique_type == HWLOC_OBJ_PU || unique_type == HWLOC_OBJ_NUMANODE) {
1308      if (!os_indexing) {
1309        if (hwloc__xml_verbose())
1310  	fprintf(stderr, "%s: ignoring PU or NUMA %s without os_indexing\n",
1311  		state->global->msgprefix, _TAG_NAME);
1312        goto out_ignore;
1313      }
1314    } else {
1315      if (!gp_indexing) {
1316        if (hwloc__xml_verbose())
1317  	fprintf(stderr, "%s: ignoring !PU or !NUMA %s without gp_indexing\n",
1318  		state->global->msgprefix, _TAG_NAME);
1319        goto out_ignore;
1320      }
1321    }
1322    if (topology->flags & HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)
1323      goto out_ignore;
1324    hwloc_internal_distances_add_by_index(topology, name, unique_type, different_types, nbobjs, indexes, u64values, kind, 0 &bsol;* assume grouping was applied when this matrix was discovered before exporting to XML */);
1325    indexes = NULL;
1326    u64values = NULL;
1327    different_types = NULL;
1328   out_ignore:
1329    free(different_types);
1330    free(indexes);
1331    free(u64values);
1332    return state->global->close_tag(state);
1333   out_with_arrays:
1334    free(different_types);
1335    free(indexes);
1336    free(u64values);
1337   out:
1338    return -1;
1339  #undef _TAG_NAME
1340  }
1341  static int
1342  hwloc__xml_import_memattr_value(hwloc_topology_t topology,
1343                                  hwloc_memattr_id_t id,
1344                                  unsigned long flags,
1345                                  hwloc__xml_import_state_t state)
1346  {
1347    char *target_obj_gp_index_s = NULL;
1348    char *target_obj_type_s = NULL;
1349    hwloc_uint64_t target_obj_gp_index;
1350    char *value_s = NULL;
1351    hwloc_uint64_t value;
1352    char *initiator_cpuset_s = NULL;
1353    char *initiator_obj_gp_index_s = NULL;
1354    char *initiator_obj_type_s = NULL;
1355    hwloc_obj_type_t target_obj_type = HWLOC_OBJ_TYPE_NONE;
1356    while (1) {
1357      char *attrname, *attrvalue;
1358      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1359        break;
1360      if (!strcmp(attrname, "target_obj_gp_index"))
1361        target_obj_gp_index_s = attrvalue;
1362      else if (!strcmp(attrname, "target_obj_type"))
1363        target_obj_type_s = attrvalue;
1364      else if (!strcmp(attrname, "value"))
1365        value_s = attrvalue;
1366      else if (!strcmp(attrname, "initiator_cpuset"))
1367        initiator_cpuset_s = attrvalue;
1368      else if (!strcmp(attrname, "initiator_obj_gp_index"))
1369        initiator_obj_gp_index_s = attrvalue;
1370      else if (!strcmp(attrname, "initiator_obj_type"))
1371        initiator_obj_type_s = attrvalue;
1372      else {
1373        if (hwloc__xml_verbose())
1374          fprintf(stderr, "%s: ignoring unknown memattr_value attribute %s\n",
1375                  state->global->msgprefix, attrname);
1376        return -1;
1377      }
1378    }
1379    if (!target_obj_type_s) {
1380      if (hwloc__xml_verbose())
1381        fprintf(stderr, "%s: ignoring memattr_value without target_obj_type.\n",
1382                state->global->msgprefix);
1383      return -1;
1384    }
1385    if (hwloc_type_sscanf(target_obj_type_s, &target_obj_type, NULL, 0) < 0) {
1386      if (hwloc__xml_verbose())
1387        fprintf(stderr, "%s: failed to identify memattr_value target object type %s\n",
1388                state->global->msgprefix, target_obj_type_s);
1389      return -1;
1390    }
1391    if (!value_s || !target_obj_gp_index_s) {
1392      if (hwloc__xml_verbose())
1393        fprintf(stderr, "%s: ignoring memattr_value without value and target_obj_gp_index\n",
1394                state->global->msgprefix);
1395      return -1;
1396    }
1397    target_obj_gp_index = strtoull(target_obj_gp_index_s, NULL, 10);
1398    value = strtoull(value_s, NULL, 10);
1399    if (flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
1400      struct hwloc_internal_location_s loc;
1401      if (!initiator_cpuset_s && (!initiator_obj_gp_index_s || !initiator_obj_type_s)) {
1402        if (hwloc__xml_verbose())
1403          fprintf(stderr, "%s: ignoring memattr_value without initiator attributes\n",
1404                  state->global->msgprefix);
1405        return -1;
1406      }
1407      if (initiator_cpuset_s) {
1408        loc.type = HWLOC_LOCATION_TYPE_CPUSET;
1409        loc.location.cpuset = hwloc_bitmap_alloc();
1410        if (!loc.location.cpuset) {
1411          if (hwloc__xml_verbose())
1412            fprintf(stderr, "%s: failed to allocated memattr_value initiator cpuset\n",
1413                    state->global->msgprefix);
1414          return -1;
1415        }
1416        hwloc_bitmap_sscanf(loc.location.cpuset, initiator_cpuset_s);
1417      } else {
1418        loc.type = HWLOC_LOCATION_TYPE_OBJECT;
1419        loc.location.object.gp_index = strtoull(initiator_obj_gp_index_s, NULL, 10);
1420        if (hwloc_type_sscanf(initiator_obj_type_s, &loc.location.object.type, NULL, 0) < 0) {
1421          if (hwloc__xml_verbose())
1422            fprintf(stderr, "%s: failed to identify memattr_value initiator object type %s\n",
1423                    state->global->msgprefix, initiator_obj_type_s);
1424          return -1;
1425        }
1426      }
1427      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, &loc, value);
1428      if (loc.type == HWLOC_LOCATION_TYPE_CPUSET)
1429        hwloc_bitmap_free(loc.location.cpuset);
1430    } else {
1431      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, NULL, value);
1432    }
1433    return 0;
1434  }
1435  static int
1436  hwloc__xml_import_memattr(hwloc_topology_t topology,
1437                            hwloc__xml_import_state_t state)
1438  {
1439    char *name = NULL;
1440    unsigned long flags = (unsigned long) -1;
1441    hwloc_memattr_id_t id = (hwloc_memattr_id_t) -1;
1442    int ret;
1443    while (1) {
1444      char *attrname, *attrvalue;
1445      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1446        break;
1447      if (!strcmp(attrname, "name"))
1448        name = attrvalue;
1449      else if (!strcmp(attrname, "flags"))
1450        flags = strtoul(attrvalue, NULL, 10);
1451      else {
1452        if (hwloc__xml_verbose())
1453          fprintf(stderr, "%s: ignoring unknown memattr attribute %s\n",
1454                  state->global->msgprefix, attrname);
1455        return -1;
1456      }
1457    }
1458    if (name && flags != (unsigned long) -1
1459        && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS)) {
1460      hwloc_memattr_id_t _id;
1461      ret = hwloc_memattr_get_by_name(topology, name, &_id);
1462      if (ret < 0) {
1463        ret = hwloc_memattr_register(topology, name, flags, &_id);
1464        if (!ret)
1465          id = _id;
1466      } else {
1467        unsigned long mflags;
1468        ret = hwloc_memattr_get_flags(topology, _id, &mflags);
1469        if (!ret && mflags == flags)
1470          id = _id;
1471      }
1472    }
1473    while (1) {
1474      struct hwloc__xml_import_state_s childstate;
1475      char *tag;
1476      ret = state->global->find_child(state, &childstate, &tag);
1477      if (ret <= 0)
1478        break;
1479      if (!strcmp(tag, "memattr_value")) {
1480        ret = hwloc__xml_import_memattr_value(topology, id, flags, &childstate);
1481      } else {
1482        if (hwloc__xml_verbose())
1483          fprintf(stderr, "%s: memattr with unrecognized child %s\n",
1484                  state->global->msgprefix, tag);
1485        ret = -1;
1486      }
1487      if (ret < 0)
1488        goto error;
1489      state->global->close_child(&childstate);
1490    }
1491    return state->global->close_tag(state);
1492   error:
1493    return -1;
1494  }
1495  static int
1496  hwloc__xml_import_cpukind(hwloc_topology_t topology,
1497                            hwloc__xml_import_state_t state)
1498  {
1499    hwloc_bitmap_t cpuset = NULL;
1500    int forced_efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
1501    unsigned nr_infos = 0;
1502    struct hwloc_info_s *infos = NULL;
1503    int ret;
1504    while (1) {
1505      char *attrname, *attrvalue;
1506      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1507        break;
1508      if (!strcmp(attrname, "cpuset")) {
1509        if (!cpuset)
1510          cpuset = hwloc_bitmap_alloc();
1511        hwloc_bitmap_sscanf(cpuset, attrvalue);
1512      } else if (!strcmp(attrname, "forced_efficiency")) {
1513        forced_efficiency = atoi(attrvalue);
1514      } else {
1515        if (hwloc__xml_verbose())
1516          fprintf(stderr, "%s: ignoring unknown cpukind attribute %s\n",
1517                  state->global->msgprefix, attrname);
1518        hwloc_bitmap_free(cpuset);
1519        return -1;
1520      }
1521    }
1522    while (1) {
1523      struct hwloc__xml_import_state_s childstate;
1524      char *tag;
1525      ret = state->global->find_child(state, &childstate, &tag);
1526      if (ret <= 0)
1527        break;
1528      if (!strcmp(tag, "info")) {
1529        char *infoname = NULL;
1530        char *infovalue = NULL;
1531        ret = hwloc___xml_import_info(&infoname, &infovalue, &childstate);
1532        if (!ret && infoname && infovalue)
1533          hwloc__add_info(&infos, &nr_infos, infoname, infovalue);
1534      } else {
1535        if (hwloc__xml_verbose())
1536          fprintf(stderr, "%s: cpukind with unrecognized child %s\n",
1537                  state->global->msgprefix, tag);
1538        ret = -1;
1539      }
1540      if (ret < 0)
1541        goto error;
1542      state->global->close_child(&childstate);
1543    }
1544    if (!cpuset) {
1545      if (hwloc__xml_verbose())
1546        fprintf(stderr, "%s: ignoring cpukind without cpuset\n",
1547                state->global->msgprefix);
1548      goto error;
1549    }
1550    if (topology->flags & HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS) {
1551      hwloc__free_infos(infos, nr_infos);
1552      hwloc_bitmap_free(cpuset);
1553    } else {
1554      hwloc_internal_cpukinds_register(topology, cpuset, forced_efficiency, infos, nr_infos, HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY);
1555      hwloc__free_infos(infos, nr_infos);
1556    }
1557    return state->global->close_tag(state);
1558   error:
1559    hwloc__free_infos(infos, nr_infos);
1560    hwloc_bitmap_free(cpuset);
1561    return -1;
1562  }
1563  static int
1564  hwloc__xml_import_diff_one(hwloc__xml_import_state_t state,
1565  			   hwloc_topology_diff_t *firstdiffp,
1566  			   hwloc_topology_diff_t *lastdiffp)
1567  {
1568    char *type_s = NULL;
1569    char *obj_depth_s = NULL;
1570    char *obj_index_s = NULL;
1571    char *obj_attr_type_s = NULL;
1572    char *obj_attr_name_s = NULL;
1573    char *obj_attr_oldvalue_s = NULL;
1574    char *obj_attr_newvalue_s = NULL;
1575    while (1) {
1576      char *attrname, *attrvalue;
1577      if (state->global->next_attr(state, &attrname, &attrvalue) < 0)
1578        break;
1579      if (!strcmp(attrname, "type"))
1580        type_s = attrvalue;
1581      else if (!strcmp(attrname, "obj_depth"))
1582        obj_depth_s = attrvalue;
1583      else if (!strcmp(attrname, "obj_index"))
1584        obj_index_s = attrvalue;
1585      else if (!strcmp(attrname, "obj_attr_type"))
1586        obj_attr_type_s = attrvalue;
1587      else if (!strcmp(attrname, "obj_attr_index"))
1588        { &bsol;* obj_attr_index_s = attrvalue; unused for now */ }
1589      else if (!strcmp(attrname, "obj_attr_name"))
1590        obj_attr_name_s = attrvalue;
1591      else if (!strcmp(attrname, "obj_attr_oldvalue"))
1592        obj_attr_oldvalue_s = attrvalue;
1593      else if (!strcmp(attrname, "obj_attr_newvalue"))
1594        obj_attr_newvalue_s = attrvalue;
1595      else {
1596        if (hwloc__xml_verbose())
1597  	fprintf(stderr, "%s: ignoring unknown diff attribute %s\n",
1598  		state->global->msgprefix, attrname);
1599        return -1;
1600      }
1601    }
1602    if (type_s) {
1603      switch (atoi(type_s)) {
1604      default:
1605        break;
1606      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: {
1607        hwloc_topology_diff_obj_attr_type_t obj_attr_type;
1608        hwloc_topology_diff_t diff;
1609        if (!obj_depth_s || !obj_index_s || !obj_attr_type_s) {
1610  	if (hwloc__xml_verbose())
1611  	  fprintf(stderr, "%s: missing mandatory obj attr generic attributes\n",
1612  		  state->global->msgprefix);
1613  	break;
1614        }
1615        if (!obj_attr_oldvalue_s || !obj_attr_newvalue_s) {
1616  	if (hwloc__xml_verbose())
1617  	  fprintf(stderr, "%s: missing mandatory obj attr value attributes\n",
1618  		  state->global->msgprefix);
1619  	break;
1620        }
1621        obj_attr_type = atoi(obj_attr_type_s);
1622        if (obj_attr_type == HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO && !obj_attr_name_s) {
1623  	if (hwloc__xml_verbose())
1624  	  fprintf(stderr, "%s: missing mandatory obj attr info name attribute\n",
1625  		  state->global->msgprefix);
1626  	break;
1627        }
1628        diff = malloc(sizeof(*diff));
1629        if (!diff)
1630  	return -1;
1631        diff->obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
1632        diff->obj_attr.obj_depth = atoi(obj_depth_s);
1633        diff->obj_attr.obj_index = atoi(obj_index_s);
1634        memset(&diff->obj_attr.diff, 0, sizeof(diff->obj_attr.diff));
1635        diff->obj_attr.diff.generic.type = obj_attr_type;
1636        switch (obj_attr_type) {
1637        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
1638  	diff->obj_attr.diff.uint64.oldvalue = strtoull(obj_attr_oldvalue_s, NULL, 0);
1639  	diff->obj_attr.diff.uint64.newvalue = strtoull(obj_attr_newvalue_s, NULL, 0);
1640  	break;
1641        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
1642  	diff->obj_attr.diff.string.name = strdup(obj_attr_name_s);
1643        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
1644  	diff->obj_attr.diff.string.oldvalue = strdup(obj_attr_oldvalue_s);
1645  	diff->obj_attr.diff.string.newvalue = strdup(obj_attr_newvalue_s);
1646  	break;
1647        }
1648        if (*firstdiffp)
1649  	(*lastdiffp)->generic.next = diff;
1650        else
1651          *firstdiffp = diff;
1652        *lastdiffp = diff;
1653        diff->generic.next = NULL;
1654      }
1655      }
1656    }
1657    return state->global->close_tag(state);
1658  }
1659  int
1660  hwloc__xml_import_diff(hwloc__xml_import_state_t state,
1661  		       hwloc_topology_diff_t *firstdiffp)
1662  {
1663    hwloc_topology_diff_t firstdiff = NULL, lastdiff = NULL;
1664    *firstdiffp = NULL;
1665    while (1) {
1666      struct hwloc__xml_import_state_s childstate;
1667      char *tag;
1668      int ret;
1669      ret = state->global->find_child(state, &childstate, &tag);
1670      if (ret < 0)
1671        return -1;
1672      if (!ret)
1673        break;
1674      if (!strcmp(tag, "diff")) {
1675        ret = hwloc__xml_import_diff_one(&childstate, &firstdiff, &lastdiff);
1676      } else
1677        ret = -1;
1678      if (ret < 0)
1679        return ret;
1680      state->global->close_child(&childstate);
1681    }
1682    *firstdiffp = firstdiff;
1683    return 0;
1684  }
1685  static void
1686  hwloc_convert_from_v1dist_floats(hwloc_topology_t topology, unsigned nbobjs, float *floats, uint64_t *u64s)
1687  {
1688    unsigned i;
1689    int is_uint;
1690    char *env;
1691    float scale = 1000.f;
1692    char scalestring[20];
1693    env = getenv("HWLOC_XML_V1DIST_SCALE");
1694    if (env) {
1695      scale = (float) atof(env);
1696      goto scale;
1697    }
1698    is_uint = 1;
1699    for(i=0; i<nbobjs*nbobjs; i++) {
1700      float f, iptr, fptr;
1701      f = floats[i];
1702      if (f < 0.f) {
1703        is_uint = 0;
1704        break;
1705      }
1706      fptr = modff(f, &iptr);
1707      if (fptr > .001f && fptr < .999f) {
1708        is_uint = 0;
1709        break;
1710      }
1711      u64s[i] = (int)(f+.5f);
1712    }
1713    if (is_uint)
1714      return;
1715   scale:
1716    for(i=0; i<nbobjs*nbobjs; i++)
1717      u64s[i] = (uint64_t)(scale * floats[i]);
1718    sprintf(scalestring, "%f", scale);
1719    hwloc_obj_add_info(hwloc_get_root_obj(topology), "xmlv1DistancesScale", scalestring);
1720  }
1721  static int
1722  hwloc_look_xml(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1723  {
1724    struct hwloc_topology *topology = backend->topology;
1725    struct hwloc_xml_backend_data_s *data = backend->private_data;
1726    struct hwloc__xml_import_state_s state, childstate;
1727    struct hwloc_obj *root = topology->levels[0][0];
1728    char *tag;
1729    int gotignored = 0;
1730    hwloc_localeswitch_declare;
1731    int ret;
1732    assert(dstatus->phase == HWLOC_DISC_PHASE_GLOBAL);
1733    state.global = data;
1734    assert(!root->cpuset);
1735    hwloc_localeswitch_init();
1736    data->nbnumanodes = 0;
1737    data->first_numanode = data->last_numanode = NULL;
1738    data->first_v1dist = data->last_v1dist = NULL;
1739    ret = data->look_init(data, &state);
1740    if (ret < 0)
1741      goto failed;
1742    if (data->version_major > 2) {
1743      if (hwloc__xml_verbose())
1744        fprintf(stderr, "%s: cannot import XML version %u.%u > 2\n",
1745  	      data->msgprefix, data->version_major, data->version_minor);
1746      goto err;
1747    }
1748    ret = state.global->find_child(&state, &childstate, &tag);
1749    if (ret < 0 || !ret || strcmp(tag, "object"))
1750      goto failed;
1751    ret = hwloc__xml_import_object(topology, data, NULL &bsol;*  no parent */, root,
1752  				 &gotignored,
1753  				 &childstate);
1754    if (ret < 0)
1755      goto failed;
1756    state.global->close_child(&childstate);
1757    assert(!gotignored);
1758    root = topology->levels[0][0];
1759    if (data->version_major >= 2) {
1760      while (1) {
1761        ret = state.global->find_child(&state, &childstate, &tag);
1762        if (ret < 0)
1763  	goto failed;
1764        if (!ret)
1765  	break;
1766        if (!strcmp(tag, "distances2")) {
1767  	ret = hwloc__xml_v2import_distances(topology, &childstate, 0);
1768  	if (ret < 0)
1769  	  goto failed;
1770        } else if (!strcmp(tag, "distances2hetero")) {
1771  	ret = hwloc__xml_v2import_distances(topology, &childstate, 1);
1772  	if (ret < 0)
1773  	  goto failed;
1774        } else if (!strcmp(tag, "support")) {
1775  	ret = hwloc__xml_v2import_support(topology, &childstate);
1776  	if (ret < 0)
1777  	  goto failed;
1778        } else if (!strcmp(tag, "memattr")) {
1779          ret = hwloc__xml_import_memattr(topology, &childstate);
1780          if (ret < 0)
1781            goto failed;
1782        } else if (!strcmp(tag, "cpukind")) {
1783          ret = hwloc__xml_import_cpukind(topology, &childstate);
1784          if (ret < 0)
1785            goto failed;
1786        } else {
1787  	if (hwloc__xml_verbose())
1788  	  fprintf(stderr, "%s: ignoring unknown tag `%s' after root object.\n",
1789  		  data->msgprefix, tag);
1790  	goto done;
1791        }
1792        state.global->close_child(&childstate);
1793      }
1794    }
1795    state.global->close_tag(&state);
1796  done:
1797    if (!root->cpuset) {
1798      if (hwloc__xml_verbose())
1799        fprintf(stderr, "%s: invalid root object without cpuset\n",
1800  	      data->msgprefix);
1801      goto err;
1802    }
1803    if (data->version_major < 2 && data->first_numanode) {
1804      hwloc_obj_t node = data->first_numanode;
1805      do {
1806        if (node->parent->type == HWLOC_OBJ_GROUP
1807  	  && !node->parent->gp_index)
1808  	node->parent->gp_index = topology->next_gp_index++;
1809        node = node->next_cousin;
1810      } while (node);
1811    }
1812    if (data->version_major < 2 && data->first_v1dist) {
1813      struct hwloc__xml_imported_v1distances_s *v1dist, *v1next = data->first_v1dist;
1814      while ((v1dist = v1next) != NULL) {
1815        unsigned nbobjs = v1dist->nbobjs;
1816        v1next = v1dist->next;
1817        if (nbobjs == data->nbnumanodes
1818            && !(topology->flags & HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)) {
1819  	hwloc_obj_t *objs = malloc(nbobjs*sizeof(hwloc_obj_t));
1820  	uint64_t *values = malloc(nbobjs*nbobjs*sizeof(*values));
1821          assert(data->nbnumanodes > 0); &bsol;* v1dist->nbobjs is >0 after import */
1822          assert(data->first_numanode);
1823  	if (objs && values) {
1824  	  hwloc_obj_t node;
1825  	  unsigned i;
1826  	  for(i=0, node = data->first_numanode;
1827  	      i<nbobjs;
1828  	      i++, node = node->next_cousin)
1829  	    objs[i] = node;
1830  	  hwloc_convert_from_v1dist_floats(topology, nbobjs, v1dist->floats, values);
1831  	  hwloc_internal_distances_add(topology, NULL, nbobjs, objs, values, v1dist->kind, 0);
1832  	} else {
1833  	  free(objs);
1834  	  free(values);
1835  	}
1836        }
1837        free(v1dist->floats);
1838        free(v1dist);
1839      }
1840      data->first_v1dist = data->last_v1dist = NULL;
1841    }
1842    if (data->version_major >= 2) {
1843      if (!root->nodeset) {
1844        if (hwloc__xml_verbose())
1845  	fprintf(stderr, "%s: invalid root object without nodeset\n",
1846  		data->msgprefix);
1847        goto err;
1848      }
1849      if (hwloc_bitmap_iszero(root->nodeset)) {
1850        if (hwloc__xml_verbose())
1851  	fprintf(stderr, "%s: invalid root object with empty nodeset\n",
1852  		data->msgprefix);
1853        goto err;
1854      }
1855    } else {
1856    }
1857    hwloc_alloc_root_sets(root);
1858    if (!(topology->flags & HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT)) {
1859      topology->support.discovery->pu = 1;
1860      topology->support.discovery->disallowed_pu = 1;
1861      if (data->nbnumanodes) {
1862        topology->support.discovery->numa = 1;
1863        topology->support.discovery->numa_memory = 1; 
1864        topology->support.discovery->disallowed_numa = 1;
1865      }
1866    }
1867    if (data->look_done)
1868      data->look_done(data, 0);
1869    hwloc_localeswitch_fini();
1870    return 0;
1871   failed:
1872    if (data->look_done)
1873      data->look_done(data, -1);
1874    if (hwloc__xml_verbose())
1875      fprintf(stderr, "%s: XML component discovery failed.\n",
1876  	    data->msgprefix);
1877   err:
1878    hwloc_free_object_siblings_and_children(root->first_child);
1879    root->first_child = NULL;
1880    hwloc_free_object_siblings_and_children(root->memory_first_child);
1881    root->memory_first_child = NULL;
1882    hwloc_free_object_siblings_and_children(root->io_first_child);
1883    root->io_first_child = NULL;
1884    hwloc_free_object_siblings_and_children(root->misc_first_child);
1885    root->misc_first_child = NULL;
1886    if (root->cpuset)
1887      hwloc_bitmap_zero(root->cpuset);
1888    if (root->nodeset)
1889      hwloc_bitmap_zero(root->nodeset);
1890    hwloc_localeswitch_fini();
1891    return -1;
1892  }
1893  int
1894  hwloc_topology_diff_load_xml(const char *xmlpath,
1895  			     hwloc_topology_diff_t *firstdiffp, char **refnamep)
1896  {
1897    struct hwloc__xml_import_state_s state;
1898    struct hwloc_xml_backend_data_s fakedata; &bsol;* only for storing global info during parsing */
1899    hwloc_localeswitch_declare;
1900    const char *local_basename;
1901    int force_nolibxml;
1902    int ret;
1903    state.global = &fakedata;
1904    local_basename = strrchr(xmlpath, '/');
1905    if (local_basename)
1906      local_basename++;
1907    else
1908      local_basename = xmlpath;
1909    fakedata.msgprefix = strdup(local_basename);
1910    hwloc_components_init();
1911    assert(hwloc_nolibxml_callbacks);
1912    hwloc_localeswitch_init();
1913    *firstdiffp = NULL;
1914    force_nolibxml = hwloc_nolibxml_import();
1915  retry:
1916    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
1917      ret = hwloc_nolibxml_callbacks->import_diff(&state, xmlpath, NULL, 0, firstdiffp, refnamep);
1918    else {
1919      ret = hwloc_libxml_callbacks->import_diff(&state, xmlpath, NULL, 0, firstdiffp, refnamep);
1920      if (ret < 0 && errno == ENOSYS) {
1921        hwloc_libxml_callbacks = NULL;
1922        goto retry;
1923      }
1924    }
1925    hwloc_localeswitch_fini();
1926    hwloc_components_fini();
1927    free(fakedata.msgprefix);
1928    return ret;
1929  }
1930  int
1931  hwloc_topology_diff_load_xmlbuffer(const char *xmlbuffer, int buflen,
1932  				   hwloc_topology_diff_t *firstdiffp, char **refnamep)
1933  {
1934    struct hwloc__xml_import_state_s state;
1935    struct hwloc_xml_backend_data_s fakedata; &bsol;* only for storing global info during parsing */
1936    hwloc_localeswitch_declare;
1937    int force_nolibxml;
1938    int ret;
1939    state.global = &fakedata;
1940    fakedata.msgprefix = strdup("xmldiffbuffer");
1941    hwloc_components_init();
1942    assert(hwloc_nolibxml_callbacks);
1943    hwloc_localeswitch_init();
1944    *firstdiffp = NULL;
1945    force_nolibxml = hwloc_nolibxml_import();
1946   retry:
1947    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
1948      ret = hwloc_nolibxml_callbacks->import_diff(&state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1949    else {
1950      ret = hwloc_libxml_callbacks->import_diff(&state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1951      if (ret < 0 && errno == ENOSYS) {
1952        hwloc_libxml_callbacks = NULL;
1953        goto retry;
1954      }
1955    }
1956    hwloc_localeswitch_fini();
1957    hwloc_components_fini();
1958    free(fakedata.msgprefix);
1959    return ret;
1960  }
1961  #define HWLOC_XML_CHAR_VALID(c) (((c) >= 32 && (c) <= 126) || (c) == '\t' || (c) == '\n' || (c) == '\r')
1962  static int
1963  hwloc__xml_export_check_buffer(const char *buf, size_t length)
1964  {
1965    unsigned i;
1966    for(i=0; i<length; i++)
1967      if (!HWLOC_XML_CHAR_VALID(buf[i]))
1968        return -1;
1969    return 0;
1970  }
1971  static char*
1972  hwloc__xml_export_safestrdup(const char *old)
1973  {
1974    char *new = malloc(strlen(old)+1);
1975    char *dst = new;
1976    const char *src = old;
1977    if (!new)
1978      return NULL;
1979    while (*src) {
1980      if (HWLOC_XML_CHAR_VALID(*src))
1981        *(dst++) = *src;
1982      src++;
1983    }
1984    *dst = '\0';
1985    return new;
1986  }
1987  static void
1988  hwloc__xml_export_object_contents (hwloc__xml_export_state_t state, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
1989  {
1990    char *setstring = NULL, *setstring2 = NULL;
1991    char tmp[255];
1992    int v1export = flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1;
1993    unsigned i,j;
1994    if (v1export && obj->type == HWLOC_OBJ_PACKAGE)
1995      state->new_prop(state, "type", "Socket");
1996    else if (v1export && obj->type == HWLOC_OBJ_DIE)
1997      state->new_prop(state, "type", "Group");
1998    else if (v1export && hwloc__obj_type_is_cache(obj->type))
1999      state->new_prop(state, "type", "Cache");
2000    else
2001      state->new_prop(state, "type", hwloc_obj_type_string(obj->type));
2002    if (obj->os_index != HWLOC_UNKNOWN_INDEX) {
2003      sprintf(tmp, "%u", obj->os_index);
2004      state->new_prop(state, "os_index", tmp);
2005    }
2006    if (obj->cpuset) {
2007      int empty_cpusets = 0;
2008      if (v1export && obj->type == HWLOC_OBJ_NUMANODE) {
2009        hwloc_obj_t parent = obj;
2010        while (!hwloc_obj_type_is_normal(parent->type)) {
2011  	if (parent->sibling_rank > 0) {
2012  	  empty_cpusets = 1;
2013  	  break;
2014  	}
2015  	parent = parent->parent;
2016        }
2017      }
2018      if (empty_cpusets) {
2019        state->new_prop(state, "cpuset", "0x0");
2020        state->new_prop(state, "online_cpuset", "0x0");
2021        state->new_prop(state, "complete_cpuset", "0x0");
2022        state->new_prop(state, "allowed_cpuset", "0x0");
2023      } else {
2024        hwloc_bitmap_asprintf(&setstring, obj->cpuset);
2025        state->new_prop(state, "cpuset", setstring);
2026        hwloc_bitmap_asprintf(&setstring2, obj->complete_cpuset);
2027        state->new_prop(state, "complete_cpuset", setstring2);
2028        free(setstring2);
2029        if (v1export)
2030  	state->new_prop(state, "online_cpuset", setstring);
2031        free(setstring);
2032        if (v1export) {
2033  	hwloc_bitmap_t allowed_cpuset = hwloc_bitmap_dup(obj->cpuset);
2034  	hwloc_bitmap_and(allowed_cpuset, allowed_cpuset, topology->allowed_cpuset);
2035  	hwloc_bitmap_asprintf(&setstring, allowed_cpuset);
2036  	state->new_prop(state, "allowed_cpuset", setstring);
2037  	free(setstring);
2038  	hwloc_bitmap_free(allowed_cpuset);
2039        } else if (!obj->parent) {
2040  	hwloc_bitmap_asprintf(&setstring, topology->allowed_cpuset);
2041  	state->new_prop(state, "allowed_cpuset", setstring);
2042  	free(setstring);
2043        }
2044      }
2045      hwloc_bitmap_asprintf(&setstring, obj->nodeset);
2046      state->new_prop(state, "nodeset", setstring);
2047      free(setstring);
2048      hwloc_bitmap_asprintf(&setstring, obj->complete_nodeset);
2049      state->new_prop(state, "complete_nodeset", setstring);
2050      free(setstring);
2051      if (v1export) {
2052        hwloc_bitmap_t allowed_nodeset = hwloc_bitmap_dup(obj->nodeset);
2053        hwloc_bitmap_and(allowed_nodeset, allowed_nodeset, topology->allowed_nodeset);
2054        hwloc_bitmap_asprintf(&setstring, allowed_nodeset);
2055        state->new_prop(state, "allowed_nodeset", setstring);
2056        free(setstring);
2057        hwloc_bitmap_free(allowed_nodeset);
2058      } else if (!obj->parent) {
2059        hwloc_bitmap_asprintf(&setstring, topology->allowed_nodeset);
2060        state->new_prop(state, "allowed_nodeset", setstring);
2061        free(setstring);
2062      }
2063    }
2064    if (!v1export) {
2065      sprintf(tmp, "%llu", (unsigned long long) obj->gp_index);
2066      state->new_prop(state, "gp_index", tmp);
2067    }
2068    if (obj->name) {
2069      char *name = hwloc__xml_export_safestrdup(obj->name);
2070      if (name) {
2071        state->new_prop(state, "name", name);
2072        free(name);
2073      }
2074    }
2075    if (!v1export && obj->subtype) {
2076      char *subtype = hwloc__xml_export_safestrdup(obj->subtype);
2077      if (subtype) {
2078        state->new_prop(state, "subtype", subtype);
2079        free(subtype);
2080      }
2081    }
2082    switch (obj->type) {
2083    case HWLOC_OBJ_NUMANODE:
2084      if (obj->attr->numanode.local_memory) {
2085        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.local_memory);
2086        state->new_prop(state, "local_memory", tmp);
2087      }
2088      for(i=0; i<obj->attr->numanode.page_types_len; i++) {
2089        struct hwloc__xml_export_state_s childstate;
2090        state->new_child(state, &childstate, "page_type");
2091        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].size);
2092        childstate.new_prop(&childstate, "size", tmp);
2093        sprintf(tmp, "%llu", (unsigned long long) obj->attr->numanode.page_types[i].count);
2094        childstate.new_prop(&childstate, "count", tmp);
2095        childstate.end_object(&childstate, "page_type");
2096      }
2097      break;
2098    case HWLOC_OBJ_L1CACHE:
2099    case HWLOC_OBJ_L2CACHE:
2100    case HWLOC_OBJ_L3CACHE:
2101    case HWLOC_OBJ_L4CACHE:
2102    case HWLOC_OBJ_L5CACHE:
2103    case HWLOC_OBJ_L1ICACHE:
2104    case HWLOC_OBJ_L2ICACHE:
2105    case HWLOC_OBJ_L3ICACHE:
2106    case HWLOC_OBJ_MEMCACHE:
2107      sprintf(tmp, "%llu", (unsigned long long) obj->attr->cache.size);
2108      state->new_prop(state, "cache_size", tmp);
2109      sprintf(tmp, "%u", obj->attr->cache.depth);
2110      state->new_prop(state, "depth", tmp);
2111      sprintf(tmp, "%u", (unsigned) obj->attr->cache.linesize);
2112      state->new_prop(state, "cache_linesize", tmp);
2113      sprintf(tmp, "%d", obj->attr->cache.associativity);
2114      state->new_prop(state, "cache_associativity", tmp);
2115      sprintf(tmp, "%d", (int) obj->attr->cache.type);
2116      state->new_prop(state, "cache_type", tmp);
2117      break;
2118    case HWLOC_OBJ_GROUP:
2119      if (v1export) {
2120        sprintf(tmp, "%u", obj->attr->group.depth);
2121        state->new_prop(state, "depth", tmp);
2122        if (obj->attr->group.dont_merge)
2123          state->new_prop(state, "dont_merge", "1");
2124      } else {
2125        sprintf(tmp, "%u", obj->attr->group.kind);
2126        state->new_prop(state, "kind", tmp);
2127        sprintf(tmp, "%u", obj->attr->group.subkind);
2128        state->new_prop(state, "subkind", tmp);
2129        if (obj->attr->group.dont_merge)
2130          state->new_prop(state, "dont_merge", "1");
2131      }
2132      break;
2133    case HWLOC_OBJ_BRIDGE:
2134      sprintf(tmp, "%d-%d", (int) obj->attr->bridge.upstream_type, (int) obj->attr->bridge.downstream_type);
2135      state->new_prop(state, "bridge_type", tmp);
2136      sprintf(tmp, "%u", obj->attr->bridge.depth);
2137      state->new_prop(state, "depth", tmp);
2138      if (obj->attr->bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
2139        sprintf(tmp, "%04x:[%02x-%02x]",
2140  	      (unsigned) obj->attr->bridge.downstream.pci.domain,
2141  	      (unsigned) obj->attr->bridge.downstream.pci.secondary_bus,
2142  	      (unsigned) obj->attr->bridge.downstream.pci.subordinate_bus);
2143        state->new_prop(state, "bridge_pci", tmp);
2144      }
2145      if (obj->attr->bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI)
2146        break;
2147    case HWLOC_OBJ_PCI_DEVICE:
2148      sprintf(tmp, "%04x:%02x:%02x.%01x",
2149  	    (unsigned) obj->attr->pcidev.domain,
2150  	    (unsigned) obj->attr->pcidev.bus,
2151  	    (unsigned) obj->attr->pcidev.dev,
2152  	    (unsigned) obj->attr->pcidev.func);
2153      state->new_prop(state, "pci_busid", tmp);
2154      sprintf(tmp, "%04x [%04x:%04x] [%04x:%04x] %02x",
2155  	    (unsigned) obj->attr->pcidev.class_id,
2156  	    (unsigned) obj->attr->pcidev.vendor_id, (unsigned) obj->attr->pcidev.device_id,
2157  	    (unsigned) obj->attr->pcidev.subvendor_id, (unsigned) obj->attr->pcidev.subdevice_id,
2158  	    (unsigned) obj->attr->pcidev.revision);
2159      state->new_prop(state, "pci_type", tmp);
2160      sprintf(tmp, "%f", obj->attr->pcidev.linkspeed);
2161      state->new_prop(state, "pci_link_speed", tmp);
2162      break;
2163    case HWLOC_OBJ_OS_DEVICE:
2164      sprintf(tmp, "%d", (int) obj->attr->osdev.type);
2165      state->new_prop(state, "osdev_type", tmp);
2166      break;
2167    default:
2168      break;
2169    }
2170    for(i=0; i<obj->infos_count; i++) {
2171      char *name = hwloc__xml_export_safestrdup(obj->infos[i].name);
2172      char *value = hwloc__xml_export_safestrdup(obj->infos[i].value);
2173      if (name && value) {
2174        struct hwloc__xml_export_state_s childstate;
2175        state->new_child(state, &childstate, "info");
2176        childstate.new_prop(&childstate, "name", name);
2177        childstate.new_prop(&childstate, "value", value);
2178        childstate.end_object(&childstate, "info");
2179      }
2180      free(name);
2181      free(value);
2182    }
2183    if (v1export && obj->subtype) {
2184      char *subtype = hwloc__xml_export_safestrdup(obj->subtype);
2185      if (subtype) {
2186        struct hwloc__xml_export_state_s childstate;
2187        int is_coproctype = (obj->type == HWLOC_OBJ_OS_DEVICE && obj->attr->osdev.type == HWLOC_OBJ_OSDEV_COPROC);
2188        state->new_child(state, &childstate, "info");
2189        childstate.new_prop(&childstate, "name", is_coproctype ? "CoProcType" : "Type");
2190        childstate.new_prop(&childstate, "value", subtype);
2191        childstate.end_object(&childstate, "info");
2192        free(subtype);
2193      }
2194    }
2195    if (v1export && obj->type == HWLOC_OBJ_DIE) {
2196      struct hwloc__xml_export_state_s childstate;
2197      state->new_child(state, &childstate, "info");
2198      childstate.new_prop(&childstate, "name", "Type");
2199      childstate.new_prop(&childstate, "value", "Die");
2200      childstate.end_object(&childstate, "info");
2201    }
2202    if (v1export && !obj->parent) {
2203      struct hwloc_internal_distances_s *dist;
2204      hwloc_internal_distances_refresh(topology);
2205      for(dist = topology->first_dist; dist; dist = dist->next) {
2206        struct hwloc__xml_export_state_s childstate;
2207        unsigned nbobjs = dist->nbobjs;
2208        unsigned *logical_to_v2array;
2209        int depth;
2210        if (nbobjs != (unsigned) hwloc_get_nbobjs_by_type(topology, dist->unique_type))
2211  	continue;
2212        if (!(dist->kind & HWLOC_DISTANCES_KIND_MEANS_LATENCY))
2213  	continue;
2214        if (dist->kind & HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES)
2215  	continue;
2216        logical_to_v2array = malloc(nbobjs * sizeof(*logical_to_v2array));
2217        if (!logical_to_v2array) {
2218          if (HWLOC_SHOW_ALL_ERRORS())
2219            fprintf(stderr, "hwloc/xml/export/v1: failed to allocated logical_to_v2array\n");
2220  	continue;
2221        }
2222        for(i=0; i<nbobjs; i++)
2223  	logical_to_v2array[dist->objs[i]->logical_index] = i;
2224        if (dist->unique_type == HWLOC_OBJ_NUMANODE) {
2225  	depth = -1;
2226  	for(i=0; i<nbobjs; i++) {
2227  	  hwloc_obj_t parent = dist->objs[i]->parent;
2228  	  while (hwloc__obj_type_is_memory(parent->type))
2229  	    parent = parent->parent;
2230  	  if (parent->depth+1 > depth)
2231  	    depth = parent->depth+1;
2232  	}
2233        } else {
2234  	int parent_with_memory = 0;
2235  	for(i=0; i<nbobjs; i++) {
2236  	  hwloc_obj_t parent = dist->objs[i]->parent;
2237  	  while (parent) {
2238  	    if (parent->memory_first_child) {
2239  	      parent_with_memory = 1;
2240  	      goto done;
2241  	    }
2242  	    parent = parent->parent;
2243  	  }
2244  	}
2245        done:
2246  	depth = hwloc_get_type_depth(topology, dist->unique_type) + parent_with_memory;
2247        }
2248        state->new_child(state, &childstate, "distances");
2249        sprintf(tmp, "%u", nbobjs);
2250        childstate.new_prop(&childstate, "nbobjs", tmp);
2251        sprintf(tmp, "%d", depth);
2252        childstate.new_prop(&childstate, "relative_depth", tmp);
2253        sprintf(tmp, "%f", 1.f);
2254        childstate.new_prop(&childstate, "latency_base", tmp);
2255        for(i=0; i<nbobjs; i++) {
2256          for(j=0; j<nbobjs; j++) {
2257  	  unsigned k = logical_to_v2array[i]*nbobjs+logical_to_v2array[j];
2258  	  struct hwloc__xml_export_state_s greatchildstate;
2259  	  childstate.new_child(&childstate, &greatchildstate, "latency");
2260  	  sprintf(tmp, "%f", (float) dist->values[k]);
2261  	  greatchildstate.new_prop(&greatchildstate, "value", tmp);
2262  	  greatchildstate.end_object(&greatchildstate, "latency");
2263  	}
2264        }
2265        childstate.end_object(&childstate, "distances");
2266        free(logical_to_v2array);
2267      }
2268    }
2269    if (obj->userdata && topology->userdata_export_cb)
2270      topology->userdata_export_cb((void*) state, topology, obj);
2271  }
2272  static void
2273  hwloc__xml_v2export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2274  {
2275    struct hwloc__xml_export_state_s state;
2276    hwloc_obj_t child;
2277    parentstate->new_child(parentstate, &state, "object");
2278    hwloc__xml_export_object_contents(&state, topology, obj, flags);
2279    for_each_memory_child(child, obj)
2280      hwloc__xml_v2export_object (&state, topology, child, flags);
2281    for_each_child(child, obj)
2282      hwloc__xml_v2export_object (&state, topology, child, flags);
2283    for_each_io_child(child, obj)
2284      hwloc__xml_v2export_object (&state, topology, child, flags);
2285    for_each_misc_child(child, obj)
2286      hwloc__xml_v2export_object (&state, topology, child, flags);
2287    state.end_object(&state, "object");
2288  }
2289  static void
2290  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags);
2291  static hwloc_obj_t
2292  hwloc__xml_v1export_object_next_numanode(hwloc_obj_t obj, hwloc_obj_t cur)
2293  {
2294    hwloc_obj_t parent;
2295    if (!cur) {
2296      cur = obj->memory_first_child;
2297      goto find_first;
2298    }
2299    parent = cur;
2300    while (1) {
2301      if (parent->next_sibling) {
2302        cur = parent->next_sibling;
2303        break;
2304      }
2305      parent = parent->parent;
2306      if (parent == obj)
2307        return NULL;
2308    }
2309   find_first:
2310    while (cur->type != HWLOC_OBJ_NUMANODE)
2311      cur = cur->memory_first_child;
2312    assert(cur);
2313    return cur;
2314  }
2315  static unsigned
2316  hwloc__xml_v1export_object_list_numanodes(hwloc_obj_t obj, hwloc_obj_t *first_p, hwloc_obj_t **nodes_p)
2317  {
2318    hwloc_obj_t *nodes, cur;
2319    int nr;
2320    if (!obj->memory_first_child) {
2321      *first_p = NULL;
2322      *nodes_p = NULL;
2323      return 0;
2324    }
2325    nr = hwloc_bitmap_weight(obj->nodeset);
2326    assert(nr > 0);
2327    nodes = calloc(nr, sizeof(*nodes));
2328    if (!nodes) {
2329      cur = hwloc__xml_v1export_object_next_numanode(obj, NULL);
2330      assert(cur);
2331      *first_p = cur;
2332      *nodes_p = NULL;
2333      return 1;
2334    }
2335    nr = 0;
2336    cur = NULL;
2337    while (1) {
2338      cur = hwloc__xml_v1export_object_next_numanode(obj, cur);
2339      if (!cur)
2340        break;
2341      nodes[nr++] = cur;
2342    }
2343    *first_p = nodes[0];
2344    *nodes_p = nodes;
2345    return nr;
2346  }
2347  static void
2348  hwloc__xml_v1export_object_with_memory(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2349  {
2350    struct hwloc__xml_export_state_s gstate, mstate, ostate, *state = parentstate;
2351    hwloc_obj_t child;
2352    unsigned nr_numanodes;
2353    hwloc_obj_t *numanodes, first_numanode;
2354    unsigned i;
2355    nr_numanodes = hwloc__xml_v1export_object_list_numanodes(obj, &first_numanode, &numanodes);
2356    if (obj->parent->arity > 1 && nr_numanodes > 1 && parentstate->global->v1_memory_group) {
2357      hwloc_obj_t group = parentstate->global->v1_memory_group;
2358      parentstate->new_child(parentstate, &gstate, "object");
2359      group->parent = obj->parent;
2360      group->cpuset = obj->cpuset;
2361      group->complete_cpuset = obj->complete_cpuset;
2362      group->nodeset = obj->nodeset;
2363      group->complete_nodeset = obj->complete_nodeset;
2364      hwloc__xml_export_object_contents (&gstate, topology, group, flags);
2365      group->cpuset = NULL;
2366      group->complete_cpuset = NULL;
2367      group->nodeset = NULL;
2368      group->complete_nodeset = NULL;
2369      state = &gstate;
2370    }
2371    state->new_child(state, &mstate, "object");
2372    hwloc__xml_export_object_contents (&mstate, topology, first_numanode, flags);
2373    mstate.new_child(&mstate, &ostate, "object");
2374    hwloc__xml_export_object_contents (&ostate, topology, obj, flags);
2375    for_each_child(child, obj)
2376      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2377    for_each_io_child(child, obj)
2378      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2379    for_each_misc_child(child, obj)
2380      hwloc__xml_v1export_object (&ostate, topology, child, flags);
2381    ostate.end_object(&ostate, "object");
2382    mstate.end_object(&mstate, "object");
2383    for(i=1; i<nr_numanodes; i++)
2384      hwloc__xml_v1export_object (state, topology, numanodes[i], flags);
2385    free(numanodes);
2386    if (state == &gstate) {
2387      gstate.end_object(&gstate, "object");
2388    }
2389  }
2390  static void
2391  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2392  {
2393    struct hwloc__xml_export_state_s state;
2394    hwloc_obj_t child;
2395    parentstate->new_child(parentstate, &state, "object");
2396    hwloc__xml_export_object_contents(&state, topology, obj, flags);
2397    for_each_child(child, obj) {
2398      if (!child->memory_arity) {
2399        hwloc__xml_v1export_object (&state, topology, child, flags);
2400      } else {
2401        hwloc__xml_v1export_object_with_memory(&state, topology, child, flags);
2402      }
2403    }
2404    for_each_io_child(child, obj)
2405      hwloc__xml_v1export_object (&state, topology, child, flags);
2406    for_each_misc_child(child, obj)
2407      hwloc__xml_v1export_object (&state, topology, child, flags);
2408    state.end_object(&state, "object");
2409  }
2410  #define EXPORT_ARRAY(state, type, nr, values, tagname, format, maxperline) do { \
2411    unsigned _i = 0; \
2412    while (_i<(nr)) { \
2413      char _tmp[255]; &bsol;* enough for (snprintf(format)+space) x maxperline */ \
2414      char _tmp2[16]; \
2415      size_t _len = 0; \
2416      unsigned _j; \
2417      struct hwloc__xml_export_state_s _childstate; \
2418      (state)->new_child(state, &_childstate, tagname); \
2419      for(_j=0; \
2420  	_i+_j<(nr) && _j<maxperline; \
2421  	_j++) \
2422        _len += sprintf(_tmp+_len, format " ", (type) (values)[_i+_j]); \
2423      _i += _j; \
2424      sprintf(_tmp2, "%lu", (unsigned long) _len); \
2425      _childstate.new_prop(&_childstate, "length", _tmp2); \
2426      _childstate.add_content(&_childstate, _tmp, _len); \
2427      _childstate.end_object(&_childstate, tagname); \
2428    } \
2429  } while (0)
2430  #define EXPORT_TYPE_GPINDEX_ARRAY(state, nr, objs, tagname, maxperline) do { \
2431    unsigned _i = 0; \
2432    while (_i<(nr)) { \
2433      char _tmp[255]; &bsol;* enough for (snprintf(type+index)+space) x maxperline */ \
2434      char _tmp2[16]; \
2435      size_t _len = 0; \
2436      unsigned _j; \
2437      struct hwloc__xml_export_state_s _childstate; \
2438      (state)->new_child(state, &_childstate, tagname); \
2439      for(_j=0; \
2440  	_i+_j<(nr) && _j<maxperline; \
2441  	_j++) \
2442        _len += sprintf(_tmp+_len, "%s:%llu ", hwloc_obj_type_string((objs)[_i+_j]->type), (unsigned long long) (objs)[_i+_j]->gp_index); \
2443      _i += _j; \
2444      sprintf(_tmp2, "%lu", (unsigned long) _len); \
2445      _childstate.new_prop(&_childstate, "length", _tmp2); \
2446      _childstate.add_content(&_childstate, _tmp, _len); \
2447      _childstate.end_object(&_childstate, tagname); \
2448    } \
2449  } while (0)
2450  static void
2451  hwloc___xml_v2export_distances(hwloc__xml_export_state_t parentstate, struct hwloc_internal_distances_s *dist)
2452  {
2453    char tmp[255];
2454    unsigned nbobjs = dist->nbobjs;
2455    struct hwloc__xml_export_state_s state;
2456    if (dist->different_types) {
2457      parentstate->new_child(parentstate, &state, "distances2hetero");
2458    } else {
2459      parentstate->new_child(parentstate, &state, "distances2");
2460      state.new_prop(&state, "type", hwloc_obj_type_string(dist->unique_type));
2461    }
2462    sprintf(tmp, "%u", nbobjs);
2463    state.new_prop(&state, "nbobjs", tmp);
2464    sprintf(tmp, "%lu", dist->kind);
2465    state.new_prop(&state, "kind", tmp);
2466    if (dist->name)
2467      state.new_prop(&state, "name", dist->name);
2468    if (!dist->different_types) {
2469      state.new_prop(&state, "indexing",
2470  		   HWLOC_DIST_TYPE_USE_OS_INDEX(dist->unique_type) ? "os" : "gp");
2471    }
2472    if (dist->different_types) {
2473      EXPORT_TYPE_GPINDEX_ARRAY(&state, nbobjs, dist->objs, "indexes", 10);
2474    } else {
2475      EXPORT_ARRAY(&state, unsigned long long, nbobjs, dist->indexes, "indexes", "%llu", 10);
2476    }
2477    EXPORT_ARRAY(&state, unsigned long long, nbobjs*nbobjs, dist->values, "u64values", "%llu", 10);
2478    state.end_object(&state, dist->different_types ? "distances2hetero" : "distances2");
2479  }
2480  static void
2481  hwloc__xml_v2export_distances(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2482  {
2483    struct hwloc_internal_distances_s *dist;
2484    for(dist = topology->first_dist; dist; dist = dist->next)
2485      if (!dist->different_types)
2486        hwloc___xml_v2export_distances(parentstate, dist);
2487    for(dist = topology->first_dist; dist; dist = dist->next)
2488      if (dist->different_types)
2489        hwloc___xml_v2export_distances(parentstate, dist);
2490  }
2491  static void
2492  hwloc__xml_v2export_support(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2493  {
2494    struct hwloc__xml_export_state_s state;
2495    char tmp[11];
2496  #ifdef HWLOC_DEBUG
2497    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
2498    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
2499    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
2500    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
2501    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
2502  #endif
2503  #define DO(_cat,_name) do {                                     \
2504      if (topology->support._cat->_name) {                        \
2505        parentstate->new_child(parentstate, &state, "support");   \
2506        state.new_prop(&state, "name", #_cat "." #_name);         \
2507        if (topology->support._cat->_name != 1) {                 \
2508          sprintf(tmp, "%u", topology->support._cat->_name); \
2509          state.new_prop(&state, "value", tmp);                   \
2510        }                                                         \
2511        state.end_object(&state, "support");                      \
2512      }                                                           \
2513    } while (0)
2514    DO(discovery,pu);
2515    DO(discovery,numa);
2516    DO(discovery,numa_memory);
2517    DO(discovery,disallowed_pu);
2518    DO(discovery,disallowed_numa);
2519    DO(discovery,cpukind_efficiency);
2520    DO(cpubind,set_thisproc_cpubind);
2521    DO(cpubind,get_thisproc_cpubind);
2522    DO(cpubind,set_proc_cpubind);
2523    DO(cpubind,get_proc_cpubind);
2524    DO(cpubind,set_thisthread_cpubind);
2525    DO(cpubind,get_thisthread_cpubind);
2526    DO(cpubind,set_thread_cpubind);
2527    DO(cpubind,get_thread_cpubind);
2528    DO(cpubind,get_thisproc_last_cpu_location);
2529    DO(cpubind,get_proc_last_cpu_location);
2530    DO(cpubind,get_thisthread_last_cpu_location);
2531    DO(membind,set_thisproc_membind);
2532    DO(membind,get_thisproc_membind);
2533    DO(membind,set_proc_membind);
2534    DO(membind,get_proc_membind);
2535    DO(membind,set_thisthread_membind);
2536    DO(membind,get_thisthread_membind);
2537    DO(membind,set_area_membind);
2538    DO(membind,get_area_membind);
2539    DO(membind,alloc_membind);
2540    DO(membind,firsttouch_membind);
2541    DO(membind,bind_membind);
2542    DO(membind,interleave_membind);
2543    DO(membind,nexttouch_membind);
2544    DO(membind,migrate_membind);
2545    DO(membind,get_area_memlocation);
2546    parentstate->new_child(parentstate, &state, "support");
2547    state.new_prop(&state, "name", "custom.exported_support");
2548    state.end_object(&state, "support");
2549  #undef DO
2550  }
2551  static void
2552  hwloc__xml_export_memattr_target(hwloc__xml_export_state_t state,
2553                                   struct hwloc_internal_memattr_s *imattr,
2554                                   struct hwloc_internal_memattr_target_s *imtg)
2555  {
2556    struct hwloc__xml_export_state_s vstate;
2557    char tmp[255];
2558    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
2559      unsigned k;
2560      for(k=0; k<imtg->nr_initiators; k++) {
2561        struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[k];
2562        state->new_child(state, &vstate, "memattr_value");
2563        vstate.new_prop(&vstate, "target_obj_type", hwloc_obj_type_string(imtg->type));
2564        snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->gp_index);
2565        vstate.new_prop(&vstate, "target_obj_gp_index", tmp);
2566        snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imi->value);
2567        vstate.new_prop(&vstate, "value", tmp);
2568        switch (imi->initiator.type) {
2569        case HWLOC_LOCATION_TYPE_OBJECT:
2570          snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imi->initiator.location.object.gp_index);
2571          vstate.new_prop(&vstate, "initiator_obj_gp_index", tmp);
2572          vstate.new_prop(&vstate, "initiator_obj_type", hwloc_obj_type_string(imi->initiator.location.object.type));
2573          break;
2574        case HWLOC_LOCATION_TYPE_CPUSET: {
2575          char *setstring;
2576          hwloc_bitmap_asprintf(&setstring, imi->initiator.location.cpuset);
2577          if (setstring)
2578            vstate.new_prop(&vstate, "initiator_cpuset", setstring);
2579          free(setstring);
2580          break;
2581        }
2582        default:
2583          assert(0);
2584        }
2585        vstate.end_object(&vstate, "memattr_value");
2586      }
2587    } else {
2588      state->new_child(state, &vstate, "memattr_value");
2589      vstate.new_prop(&vstate, "target_obj_type", hwloc_obj_type_string(imtg->type));
2590      snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->gp_index);
2591      vstate.new_prop(&vstate, "target_obj_gp_index", tmp);
2592      snprintf(tmp, sizeof(tmp), "%llu", (unsigned long long) imtg->noinitiator_value);
2593      vstate.new_prop(&vstate, "value", tmp);
2594      vstate.end_object(&vstate, "memattr_value");
2595    }
2596  }
2597  static void
2598  hwloc__xml_export_memattrs(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2599  {
2600    unsigned id;
2601    for(id=0; id<topology->nr_memattrs; id++) {
2602      struct hwloc_internal_memattr_s *imattr;
2603      struct hwloc__xml_export_state_s mstate;
2604      char tmp[255];
2605      unsigned j;
2606      if (id == HWLOC_MEMATTR_ID_CAPACITY || id == HWLOC_MEMATTR_ID_LOCALITY)
2607        continue;
2608      imattr = &topology->memattrs[id];
2609      if (id < HWLOC_MEMATTR_ID_MAX && !imattr->nr_targets)
2610        continue;
2611      state->new_child(state, &mstate, "memattr");
2612      mstate.new_prop(&mstate, "name", imattr->name);
2613      snprintf(tmp, sizeof(tmp), "%lu", imattr->flags);
2614      mstate.new_prop(&mstate, "flags", tmp);
2615      for(j=0; j<imattr->nr_targets; j++)
2616        hwloc__xml_export_memattr_target(&mstate, imattr, &imattr->targets[j]);
2617      mstate.end_object(&mstate, "memattr");
2618    }
2619  }
2620  static void
2621  hwloc__xml_export_cpukinds(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2622  {
2623    unsigned i;
2624    for(i=0; i<topology->nr_cpukinds; i++) {
2625      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
2626      struct hwloc__xml_export_state_s cstate;
2627      char *setstring;
2628      unsigned j;
2629      state->new_child(state, &cstate, "cpukind");
2630      hwloc_bitmap_asprintf(&setstring, kind->cpuset);
2631      cstate.new_prop(&cstate, "cpuset", setstring);
2632      free(setstring);
2633      if (kind->forced_efficiency != HWLOC_CPUKIND_EFFICIENCY_UNKNOWN) {
2634        char tmp[11];
2635        snprintf(tmp, sizeof(tmp), "%d", kind->forced_efficiency);
2636        cstate.new_prop(&cstate, "forced_efficiency", tmp);
2637      }
2638      for(j=0; j<kind->nr_infos; j++) {
2639        char *name = hwloc__xml_export_safestrdup(kind->infos[j].name);
2640        char *value = hwloc__xml_export_safestrdup(kind->infos[j].value);
2641        struct hwloc__xml_export_state_s istate;
2642        cstate.new_child(&cstate, &istate, "info");
2643        istate.new_prop(&istate, "name", name);
2644        istate.new_prop(&istate, "value", value);
2645        istate.end_object(&istate, "info");
2646        free(name);
2647        free(value);
2648      }
2649      cstate.end_object(&cstate, "cpukind");
2650    }
2651  }
2652  void
2653  hwloc__xml_export_topology(hwloc__xml_export_state_t state, hwloc_topology_t topology, unsigned long flags)
2654  {
2655    char *env;
2656    hwloc_obj_t root = hwloc_get_root_obj(topology);
2657    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2658      hwloc_obj_t *numanodes, first_numanode;
2659      unsigned nr_numanodes;
2660      nr_numanodes = hwloc__xml_v1export_object_list_numanodes(root, &first_numanode, &numanodes);
2661      if (nr_numanodes) {
2662        struct hwloc__xml_export_state_s rstate, mstate;
2663        hwloc_obj_t child;
2664        unsigned i;
2665        state->new_child(state, &rstate, "object");
2666        hwloc__xml_export_object_contents (&rstate, topology, root, flags);
2667        rstate.new_child(&rstate, &mstate, "object");
2668        hwloc__xml_export_object_contents (&mstate, topology, first_numanode, flags);
2669        for_each_child(child, root)
2670  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2671        for_each_io_child(child, root)
2672  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2673        for_each_misc_child(child, root)
2674  	hwloc__xml_v1export_object (&mstate, topology, child, flags);
2675        mstate.end_object(&mstate, "object");
2676        for(i=1; i<nr_numanodes; i++)
2677  	hwloc__xml_v1export_object (&rstate, topology, numanodes[i], flags);
2678        rstate.end_object(&rstate, "object");
2679      } else {
2680        hwloc__xml_v1export_object(state, topology, root, flags);
2681      }
2682      free(numanodes);
2683    } else {
2684      hwloc__xml_v2export_object (state, topology, root, flags);
2685      hwloc__xml_v2export_distances (state, topology);
2686      env = getenv("HWLOC_XML_EXPORT_SUPPORT");
2687      if (!env || atoi(env))
2688        hwloc__xml_v2export_support(state, topology);
2689      hwloc__xml_export_memattrs(state, topology);
2690      hwloc__xml_export_cpukinds(state, topology);
2691    }
2692  }
2693  void
2694  hwloc__xml_export_diff(hwloc__xml_export_state_t parentstate, hwloc_topology_diff_t diff)
2695  {
2696    while (diff) {
2697      struct hwloc__xml_export_state_s state;
2698      char tmp[255];
2699      parentstate->new_child(parentstate, &state, "diff");
2700      sprintf(tmp, "%d", (int) diff->generic.type);
2701      state.new_prop(&state, "type", tmp);
2702      switch (diff->generic.type) {
2703      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
2704        sprintf(tmp, "%d", diff->obj_attr.obj_depth);
2705        state.new_prop(&state, "obj_depth", tmp);
2706        sprintf(tmp, "%u", diff->obj_attr.obj_index);
2707        state.new_prop(&state, "obj_index", tmp);
2708        sprintf(tmp, "%d", (int) diff->obj_attr.diff.generic.type);
2709        state.new_prop(&state, "obj_attr_type", tmp);
2710        switch (diff->obj_attr.diff.generic.type) {
2711        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
2712  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.index);
2713  	state.new_prop(&state, "obj_attr_index", tmp);
2714  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.oldvalue);
2715  	state.new_prop(&state, "obj_attr_oldvalue", tmp);
2716  	sprintf(tmp, "%llu", (unsigned long long) diff->obj_attr.diff.uint64.newvalue);
2717  	state.new_prop(&state, "obj_attr_newvalue", tmp);
2718  	break;
2719        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
2720        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
2721  	if (diff->obj_attr.diff.string.name)
2722  	  state.new_prop(&state, "obj_attr_name", diff->obj_attr.diff.string.name);
2723  	state.new_prop(&state, "obj_attr_oldvalue", diff->obj_attr.diff.string.oldvalue);
2724  	state.new_prop(&state, "obj_attr_newvalue", diff->obj_attr.diff.string.newvalue);
2725  	break;
2726        }
2727        break;
2728      default:
2729        assert(0);
2730      }
2731      state.end_object(&state, "diff");
2732      diff = diff->generic.next;
2733    }
2734  }
2735  int hwloc_topology_export_xml(hwloc_topology_t topology, const char *filename, unsigned long flags)
2736  {
2737    hwloc_localeswitch_declare;
2738    struct hwloc__xml_export_data_s edata;
2739    int force_nolibxml;
2740    int ret;
2741    if (!topology->is_loaded) {
2742      errno = EINVAL;
2743      return -1;
2744    }
2745    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2746    if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2747      errno = EINVAL;
2748      return -1;
2749    }
2750    hwloc_internal_distances_refresh(topology);
2751    hwloc_localeswitch_init();
2752    edata.v1_memory_group = NULL;
2753    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2754      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2755    force_nolibxml = hwloc_nolibxml_export();
2756  retry:
2757    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2758      ret = hwloc_nolibxml_callbacks->export_file(topology, &edata, filename, flags);
2759    else {
2760      ret = hwloc_libxml_callbacks->export_file(topology, &edata, filename, flags);
2761      if (ret < 0 && errno == ENOSYS) {
2762        hwloc_libxml_callbacks = NULL;
2763        goto retry;
2764      }
2765    }
2766    if (edata.v1_memory_group)
2767      hwloc_free_unlinked_object(edata.v1_memory_group);
2768    hwloc_localeswitch_fini();
2769    return ret;
2770  }
2771  int hwloc_topology_export_xmlbuffer(hwloc_topology_t topology, char **xmlbuffer, int *buflen, unsigned long flags)
2772  {
2773    hwloc_localeswitch_declare;
2774    struct hwloc__xml_export_data_s edata;
2775    int force_nolibxml;
2776    int ret;
2777    if (!topology->is_loaded) {
2778      errno = EINVAL;
2779      return -1;
2780    }
2781    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2782    if (flags & ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2783      errno = EINVAL;
2784      return -1;
2785    }
2786    hwloc_internal_distances_refresh(topology);
2787    hwloc_localeswitch_init();
2788    edata.v1_memory_group = NULL;
2789    if (flags & HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2790      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2791    force_nolibxml = hwloc_nolibxml_export();
2792  retry:
2793    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2794      ret = hwloc_nolibxml_callbacks->export_buffer(topology, &edata, xmlbuffer, buflen, flags);
2795    else {
2796      ret = hwloc_libxml_callbacks->export_buffer(topology, &edata, xmlbuffer, buflen, flags);
2797      if (ret < 0 && errno == ENOSYS) {
2798        hwloc_libxml_callbacks = NULL;
2799        goto retry;
2800      }
2801    }
2802    if (edata.v1_memory_group)
2803      hwloc_free_unlinked_object(edata.v1_memory_group);
2804    hwloc_localeswitch_fini();
2805    return ret;
2806  }
2807  int
2808  hwloc_topology_diff_export_xml(hwloc_topology_diff_t diff, const char *refname,
2809  			       const char *filename)
2810  {
2811    hwloc_localeswitch_declare;
2812    hwloc_topology_diff_t tmpdiff;
2813    int force_nolibxml;
2814    int ret;
2815    tmpdiff = diff;
2816    while (tmpdiff) {
2817      if (tmpdiff->generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2818        errno = EINVAL;
2819        return -1;
2820      }
2821      tmpdiff = tmpdiff->generic.next;
2822    }
2823    hwloc_components_init();
2824    assert(hwloc_nolibxml_callbacks);
2825    hwloc_localeswitch_init();
2826    force_nolibxml = hwloc_nolibxml_export();
2827  retry:
2828    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2829      ret = hwloc_nolibxml_callbacks->export_diff_file(diff, refname, filename);
2830    else {
2831      ret = hwloc_libxml_callbacks->export_diff_file(diff, refname, filename);
2832      if (ret < 0 && errno == ENOSYS) {
2833        hwloc_libxml_callbacks = NULL;
2834        goto retry;
2835      }
2836    }
2837    hwloc_localeswitch_fini();
2838    hwloc_components_fini();
2839    return ret;
2840  }
2841  int
2842  hwloc_topology_diff_export_xmlbuffer(hwloc_topology_diff_t diff, const char *refname,
2843  				     char **xmlbuffer, int *buflen)
2844  {
2845    hwloc_localeswitch_declare;
2846    hwloc_topology_diff_t tmpdiff;
2847    int force_nolibxml;
2848    int ret;
2849    tmpdiff = diff;
2850    while (tmpdiff) {
2851      if (tmpdiff->generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2852        errno = EINVAL;
2853        return -1;
2854      }
2855      tmpdiff = tmpdiff->generic.next;
2856    }
2857    hwloc_components_init();
2858    assert(hwloc_nolibxml_callbacks);
2859    hwloc_localeswitch_init();
2860    force_nolibxml = hwloc_nolibxml_export();
2861  retry:
2862    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2863      ret = hwloc_nolibxml_callbacks->export_diff_buffer(diff, refname, xmlbuffer, buflen);
2864    else {
2865      ret = hwloc_libxml_callbacks->export_diff_buffer(diff, refname, xmlbuffer, buflen);
2866      if (ret < 0 && errno == ENOSYS) {
2867        hwloc_libxml_callbacks = NULL;
2868        goto retry;
2869      }
2870    }
2871    hwloc_localeswitch_fini();
2872    hwloc_components_fini();
2873    return ret;
2874  }
2875  void hwloc_free_xmlbuffer(hwloc_topology_t topology __hwloc_attribute_unused, char *xmlbuffer)
2876  {
2877    int force_nolibxml;
2878    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the topology */
2879    force_nolibxml = hwloc_nolibxml_export();
2880    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
2881      hwloc_nolibxml_callbacks->free_buffer(xmlbuffer);
2882    else
2883      hwloc_libxml_callbacks->free_buffer(xmlbuffer);
2884  }
2885  void
2886  hwloc_topology_set_userdata_export_callback(hwloc_topology_t topology,
2887  					    void (*export)(void *reserved, struct hwloc_topology *topology, struct hwloc_obj *obj))
2888  {
2889    topology->userdata_export_cb = export;
2890  }
2891  static void
2892  hwloc__export_obj_userdata(hwloc__xml_export_state_t parentstate, int encoded,
2893  			   const char *name, size_t length, const void *buffer, size_t encoded_length)
2894  {
2895    struct hwloc__xml_export_state_s state;
2896    char tmp[255];
2897    parentstate->new_child(parentstate, &state, "userdata");
2898    if (name)
2899      state.new_prop(&state, "name", name);
2900    sprintf(tmp, "%lu", (unsigned long) length);
2901    state.new_prop(&state, "length", tmp);
2902    if (encoded)
2903      state.new_prop(&state, "encoding", "base64");
2904    if (encoded_length)
2905      state.add_content(&state, buffer, encoded ? encoded_length : length);
2906    state.end_object(&state, "userdata");
2907  }
2908  int
2909  hwloc_export_obj_userdata(void *reserved,
2910  			  struct hwloc_topology *topology, struct hwloc_obj *obj __hwloc_attribute_unused,
2911  			  const char *name, const void *buffer, size_t length)
2912  {
2913    hwloc__xml_export_state_t state = reserved;
2914    if (!buffer) {
2915      errno = EINVAL;
2916      return -1;
2917    }
2918    if ((name && hwloc__xml_export_check_buffer(name, strlen(name)) < 0)
2919        || hwloc__xml_export_check_buffer(buffer, length) < 0) {
2920      errno = EINVAL;
2921      return -1;
2922    }
2923    if (topology->userdata_not_decoded) {
2924      int encoded;
2925      size_t encoded_length;
2926      const char *realname;
2927      assert(name);
2928      if (!strncmp(name, "base64", 6)) {
2929        encoded = 1;
2930        encoded_length = BASE64_ENCODED_LENGTH(length);
2931      } else {
2932        assert(!strncmp(name, "normal", 6));
2933        encoded = 0;
2934        encoded_length = length;
2935      }
2936      if (name[6] == ':')
2937        realname = name+7;
2938      else {
2939        assert(!strcmp(name+6, "-anon"));
2940        realname = NULL;
2941      }
2942      hwloc__export_obj_userdata(state, encoded, realname, length, buffer, encoded_length);
2943    } else
2944      hwloc__export_obj_userdata(state, 0, name, length, buffer, length);
2945    return 0;
2946  }
2947  int
2948  hwloc_export_obj_userdata_base64(void *reserved,
2949  				 struct hwloc_topology *topology __hwloc_attribute_unused, struct hwloc_obj *obj __hwloc_attribute_unused,
2950  				 const char *name, const void *buffer, size_t length)
2951  {
2952    hwloc__xml_export_state_t state = reserved;
2953    size_t encoded_length;
2954    char *encoded_buffer;
2955    int ret __hwloc_attribute_unused;
2956    if (!buffer) {
2957      errno = EINVAL;
2958      return -1;
2959    }
2960    assert(!topology->userdata_not_decoded);
2961    if (name && hwloc__xml_export_check_buffer(name, strlen(name)) < 0) {
2962      errno = EINVAL;
2963      return -1;
2964    }
2965    encoded_length = BASE64_ENCODED_LENGTH(length);
2966    encoded_buffer = malloc(encoded_length+1);
2967    if (!encoded_buffer) {
2968      errno = ENOMEM;
2969      return -1;
2970    }
2971    ret = hwloc_encode_to_base64(buffer, length, encoded_buffer, encoded_length+1);
2972    assert(ret == (int) encoded_length);
2973    hwloc__export_obj_userdata(state, 1, name, length, encoded_buffer, encoded_length);
2974    free(encoded_buffer);
2975    return 0;
2976  }
2977  void
2978  hwloc_topology_set_userdata_import_callback(hwloc_topology_t topology,
2979  					    void (*import)(struct hwloc_topology *topology, struct hwloc_obj *obj, const char *name, const void *buffer, size_t length))
2980  {
2981    topology->userdata_import_cb = import;
2982  }
2983  static void
2984  hwloc_xml_backend_disable(struct hwloc_backend *backend)
2985  {
2986    struct hwloc_xml_backend_data_s *data = backend->private_data;
2987    data->backend_exit(data);
2988    free(data->msgprefix);
2989    free(data);
2990  }
2991  static struct hwloc_backend *
2992  hwloc_xml_component_instantiate(struct hwloc_topology *topology,
2993  				struct hwloc_disc_component *component,
2994  				unsigned excluded_phases __hwloc_attribute_unused,
2995  				const void *_data1,
2996  				const void *_data2,
2997  				const void *_data3)
2998  {
2999    struct hwloc_xml_backend_data_s *data;
3000    struct hwloc_backend *backend;
3001    const char *env;
3002    int force_nolibxml;
3003    const char * xmlpath = (const char *) _data1;
3004    const char * xmlbuffer = (const char *) _data2;
3005    int xmlbuflen = (int)(uintptr_t) _data3;
3006    const char *local_basename;
3007    int err;
3008    assert(hwloc_nolibxml_callbacks); &bsol;* the core called components_init() for the component's topology */
3009    if (!xmlpath && !xmlbuffer) {
3010      env = getenv("HWLOC_XMLFILE");
3011      if (env) {
3012        xmlpath = env;
3013      } else {
3014        errno = EINVAL;
3015        goto out;
3016      }
3017    }
3018    backend = hwloc_backend_alloc(topology, component);
3019    if (!backend)
3020      goto out;
3021    data = malloc(sizeof(*data));
3022    if (!data) {
3023      errno = ENOMEM;
3024      goto out_with_backend;
3025    }
3026    backend->private_data = data;
3027    backend->discover = hwloc_look_xml;
3028    backend->disable = hwloc_xml_backend_disable;
3029    backend->is_thissystem = 0;
3030    if (xmlpath) {
3031      local_basename = strrchr(xmlpath, '/');
3032      if (local_basename)
3033        local_basename++;
3034      else
3035        local_basename = xmlpath;
3036    } else {
3037      local_basename = "xmlbuffer";
3038    }
3039    data->msgprefix = strdup(local_basename);
3040    force_nolibxml = hwloc_nolibxml_import();
3041  retry:
3042    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks && force_nolibxml))
3043      err = hwloc_nolibxml_callbacks->backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3044    else {
3045      err = hwloc_libxml_callbacks->backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3046      if (err < 0 && errno == ENOSYS) {
3047        hwloc_libxml_callbacks = NULL;
3048        goto retry;
3049      }
3050    }
3051    if (err < 0)
3052      goto out_with_data;
3053    return backend;
3054   out_with_data:
3055    free(data->msgprefix);
3056    free(data);
3057   out_with_backend:
3058    free(backend);
3059   out:
3060    return NULL;
3061  }
3062  static struct hwloc_disc_component hwloc_xml_disc_component = {
3063    "xml",
3064    HWLOC_DISC_PHASE_GLOBAL,
3065    ~0,
3066    hwloc_xml_component_instantiate,
3067    30,
3068    1,
3069    NULL
3070  };
3071  const struct hwloc_component hwloc_xml_component = {
3072    HWLOC_COMPONENT_ABI,
3073    NULL, NULL,
3074    HWLOC_COMPONENT_TYPE_DISC,
3075    0,
3076    &hwloc_xml_disc_component
3077  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</div>
                </div>
                <div class="column column_space"><pre><code>1175  	      state->global->msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>1234  		      state->global->msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, ':');
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    