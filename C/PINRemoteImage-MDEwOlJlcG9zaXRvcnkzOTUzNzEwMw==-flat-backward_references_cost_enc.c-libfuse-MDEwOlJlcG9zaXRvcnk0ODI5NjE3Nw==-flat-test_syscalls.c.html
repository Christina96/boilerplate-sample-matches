
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8561476837338904%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/backward_references_enc.h"
3  #include "src/enc/histogram_enc.h"
4  #include "src/dsp/lossless_common.h"
5  #include "src/utils/color_cache_utils.h"
6  #include "src/utils/utils.h"
7  #define VALUES_IN_BYTE 256
8  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
9  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
10  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
11                                        const PixOrCopy v);
12  typedef struct {
13    double alpha_[VALUES_IN_BYTE];
14    double red_[VALUES_IN_BYTE];
15    double blue_[VALUES_IN_BYTE];
16    double distance_[NUM_DISTANCE_CODES];
17    double* literal_;
18  } CostModel;
19  static void ConvertPopulationCountTableToBitEstimates(
20      int num_symbols, const uint32_t population_counts[], double output[]) {
21    uint32_t sum = 0;
22    int nonzeros = 0;
23    int i;
24    for (i = 0; i < num_symbols; ++i) {
25      sum += population_counts[i];
26      if (population_counts[i] > 0) {
27        ++nonzeros;
28      }
29    }
30    if (nonzeros <= 1) {
31      memset(output, 0, num_symbols * sizeof(*output));
32    } else {
33      const double logsum = VP8LFastLog2(sum);
34      for (i = 0; i < num_symbols; ++i) {
35        output[i] = logsum - VP8LFastLog2(population_counts[i]);
36      }
37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
42    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
43    VP8LHistogram* const histo = VP8LAllocateHistogram(cache_bits);
44    if (histo == NULL) goto Error;
45    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 1);
46    while (VP8LRefsCursorOk(&c)) {
47      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, VP8LDistanceToPlaneCode,
48                                      xsize);
49      VP8LRefsCursorNext(&c);
50    }
51    ConvertPopulationCountTableToBitEstimates(
52        VP8LHistogramNumCodes(histo->palette_code_bits_),
53        histo->literal_, m->literal_);
54    ConvertPopulationCountTableToBitEstimates(
55        VALUES_IN_BYTE, histo->red_, m->red_);
56    ConvertPopulationCountTableToBitEstimates(
57        VALUES_IN_BYTE, histo->blue_, m->blue_);
58    ConvertPopulationCountTableToBitEstimates(
59        VALUES_IN_BYTE, histo->alpha_, m->alpha_);
60    ConvertPopulationCountTableToBitEstimates(
61        NUM_DISTANCE_CODES, histo->distance_, m->distance_);
62    ok = 1;
63   Error:
64    VP8LFreeHistogram(histo);
65    return ok;
66  }
67  static WEBP_INLINE double GetLiteralCost(const CostModel* const m, uint32_t v) {
68    return m->alpha_[v >> 24] +
69           m->red_[(v >> 16) & 0xff] +
70           m->literal_[(v >> 8) & 0xff] +
71           m->blue_[v & 0xff];
72  }
73  static WEBP_INLINE double GetCacheCost(const CostModel* const m, uint32_t idx) {
74    const int literal_idx = VALUES_IN_BYTE + NUM_LENGTH_CODES + idx;
75    return m->literal_[literal_idx];
76  }
77  static WEBP_INLINE double GetLengthCost(const CostModel* const m,
78                                          uint32_t length) {
79    int code, extra_bits;
80    VP8LPrefixEncodeBits(length, &code, &extra_bits);
81    return m->literal_[VALUES_IN_BYTE + code] + extra_bits;
82  }
83  static WEBP_INLINE double GetDistanceCost(const CostModel* const m,
84                                            uint32_t distance) {
85    int code, extra_bits;
86    VP8LPrefixEncodeBits(distance, &code, &extra_bits);
87    return m->distance_[code] + extra_bits;
88  }
89  static WEBP_INLINE void AddSingleLiteralWithCostModel(
90      const uint32_t* const argb, VP8LColorCache* const hashers,
91      const CostModel* const cost_model, int idx, int use_color_cache,
92      float prev_cost, float* const cost, uint16_t* const dist_array) {
93    double cost_val = prev_cost;
94    const uint32_t color = argb[idx];
95    const int ix = use_color_cache ? VP8LColorCacheContains(hashers, color) : -1;
96    if (ix >= 0) {
97      const double mul0 = 0.68;
98      cost_val += GetCacheCost(cost_model, ix) * mul0;
99    } else {
100      const double mul1 = 0.82;
101      if (use_color_cache) VP8LColorCacheInsert(hashers, color);
102      cost_val += GetLiteralCost(cost_model, color) * mul1;
103    }
104    if (cost[idx] > cost_val) {
105      cost[idx] = (float)cost_val;
106      dist_array[idx] = 1;  
107    }
108  }
109  #define COST_CACHE_INTERVAL_SIZE_MAX 500
110  typedef struct CostInterval CostInterval;
111  struct CostInterval {
112    float cost_;
113    int start_;
114    int end_;
115    int index_;
116    CostInterval* previous_;
117    CostInterval* next_;
118  };
119  typedef struct {
120    double cost_;
121    int start_;
122    int end_;       
123  } CostCacheInterval;
124  #define COST_MANAGER_MAX_FREE_LIST 10
125  typedef struct {
126    CostInterval* head_;
127    int count_;  
128    CostCacheInterval* cache_intervals_;
129    size_t cache_intervals_size_;
130    double cost_cache_[MAX_LENGTH];  
131    float* costs_;
132    uint16_t* dist_array_;
133    CostInterval intervals_[COST_MANAGER_MAX_FREE_LIST];
134    CostInterval* free_intervals_;
135    CostInterval* recycled_intervals_;
136  } CostManager;
137  static void CostIntervalAddToFreeList(CostManager* const manager,
138                                        CostInterval* const interval) {
139    interval->next_ = manager->free_intervals_;
140    manager->free_intervals_ = interval;
141  }
142  static int CostIntervalIsInFreeList(const CostManager* const manager,
143                                      const CostInterval* const interval) {
144    return (interval >= &manager->intervals_[0] &&
145            interval <= &manager->intervals_[COST_MANAGER_MAX_FREE_LIST - 1]);
146  }
147  static void CostManagerInitFreeList(CostManager* const manager) {
148    int i;
149    manager->free_intervals_ = NULL;
150    for (i = 0; i < COST_MANAGER_MAX_FREE_LIST; ++i) {
151      CostIntervalAddToFreeList(manager, &manager->intervals_[i]);
152    }
153  }
154  static void DeleteIntervalList(CostManager* const manager,
155                                 const CostInterval* interval) {
156    while (interval != NULL) {
157      const CostInterval* const next = interval->next_;
158      if (!CostIntervalIsInFreeList(manager, interval)) {
159        WebPSafeFree((void*)interval);
160      }  
161      interval = next;
162    }
163  }
164  static void CostManagerClear(CostManager* const manager) {
165    if (manager == NULL) return;
166    WebPSafeFree(manager->costs_);
167    WebPSafeFree(manager->cache_intervals_);
168    DeleteIntervalList(manager, manager->head_);
169    manager->head_ = NULL;
170    DeleteIntervalList(manager, manager->recycled_intervals_);
171    manager->recycled_intervals_ = NULL;
172    memset(manager, 0, sizeof(*manager));
173    CostManagerInitFreeList(manager);
174  }
175  static int CostManagerInit(CostManager* const manager,
176                             uint16_t* const dist_array, int pix_count,
177                             const CostModel* const cost_model) {
178    int i;
179    const int cost_cache_size = (pix_count > MAX_LENGTH) ? MAX_LENGTH : pix_count;
180    manager->costs_ = NULL;
181    manager->cache_intervals_ = NULL;
182    manager->head_ = NULL;
183    manager->recycled_intervals_ = NULL;
184    manager->count_ = 0;
185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
192        ++manager->cache_intervals_size_;
193      }
194    }
195    assert(manager->cache_intervals_size_ <= MAX_LENGTH);
196    manager->cache_intervals_ = (CostCacheInterval*)WebPSafeMalloc(
197        manager->cache_intervals_size_, sizeof(*manager->cache_intervals_));
198    if (manager->cache_intervals_ == NULL) {
199      CostManagerClear(manager);
200      return 0;
201    }
202    {
203      CostCacheInterval* cur = manager->cache_intervals_;
204      cur->start_ = 0;
205      cur->end_ = 1;
206      cur->cost_ = manager->cost_cache_[0];
207      for (i = 1; i < cost_cache_size; ++i) {
208        const double cost_val = manager->cost_cache_[i];
209        if (cost_val != cur->cost_) {
210          ++cur;
211          cur->start_ = i;
212          cur->cost_ = cost_val;
213        }
214        cur->end_ = i + 1;
215      }
216    }
217    manager->costs_ = (float*)WebPSafeMalloc(pix_count, sizeof(*manager->costs_));
<span onclick='openModal()' class='match'>218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
</span>223    return 1;
224  }
225  static WEBP_INLINE void UpdateCost(CostManager* const manager, int i,
226                                     int position, float cost) {
227    const int k = i - position;
228    assert(k >= 0 && k < MAX_LENGTH);
229    if (manager->costs_[i] > cost) {
230      manager->costs_[i] = cost;
231      manager->dist_array_[i] = k + 1;
232    }
233  }
234  static WEBP_INLINE void UpdateCostPerInterval(CostManager* const manager,
235                                                int start, int end, int position,
236                                                float cost) {
237    int i;
238    for (i = start; i < end; ++i) UpdateCost(manager, i, position, cost);
239  }
240  static WEBP_INLINE void ConnectIntervals(CostManager* const manager,
241                                           CostInterval* const prev,
242                                           CostInterval* const next) {
243    if (prev != NULL) {
244      prev->next_ = next;
245    } else {
246      manager->head_ = next;
247    }
248    if (next != NULL) next->previous_ = prev;
249  }
250  static WEBP_INLINE void PopInterval(CostManager* const manager,
251                                      CostInterval* const interval) {
252    if (interval == NULL) return;
253    ConnectIntervals(manager, interval->previous_, interval->next_);
254    if (CostIntervalIsInFreeList(manager, interval)) {
255      CostIntervalAddToFreeList(manager, interval);
256    } else {  
257      interval->next_ = manager->recycled_intervals_;
258      manager->recycled_intervals_ = interval;
259    }
260    --manager->count_;
261    assert(manager->count_ >= 0);
262  }
263  static WEBP_INLINE void UpdateCostAtIndex(CostManager* const manager, int i,
264                                            int do_clean_intervals) {
265    CostInterval* current = manager->head_;
266    while (current != NULL && current->start_ <= i) {
267      CostInterval* const next = current->next_;
268      if (current->end_ <= i) {
269        if (do_clean_intervals) {
270          PopInterval(manager, current);
271        }
272      } else {
273        UpdateCost(manager, i, current->index_, current->cost_);
274      }
275      current = next;
276    }
277  }
278  static WEBP_INLINE void PositionOrphanInterval(CostManager* const manager,
279                                                 CostInterval* const current,
280                                                 CostInterval* previous) {
281    assert(current != NULL);
282    if (previous == NULL) previous = manager->head_;
283    while (previous != NULL && current->start_ < previous->start_) {
284      previous = previous->previous_;
285    }
286    while (previous != NULL && previous->next_ != NULL &&
287           previous->next_->start_ < current->start_) {
288      previous = previous->next_;
289    }
290    if (previous != NULL) {
291      ConnectIntervals(manager, current, previous->next_);
292    } else {
293      ConnectIntervals(manager, current, manager->head_);
294    }
295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
300                                         int end) {
301    CostInterval* interval_new;
302    if (start >= end) return;
303    if (manager->count_ >= COST_CACHE_INTERVAL_SIZE_MAX) {
304      UpdateCostPerInterval(manager, start, end, position, cost);
305      return;
306    }
307    if (manager->free_intervals_ != NULL) {
308      interval_new = manager->free_intervals_;
309      manager->free_intervals_ = interval_new->next_;
310    } else if (manager->recycled_intervals_ != NULL) {
311      interval_new = manager->recycled_intervals_;
312      manager->recycled_intervals_ = interval_new->next_;
313    } else {  
314      interval_new = (CostInterval*)WebPSafeMalloc(1, sizeof(*interval_new));
315      if (interval_new == NULL) {
316        UpdateCostPerInterval(manager, start, end, position, cost);
317        return;
318      }
319    }
320    interval_new->cost_ = cost;
321    interval_new->index_ = position;
322    interval_new->start_ = start;
323    interval_new->end_ = end;
324    PositionOrphanInterval(manager, interval_new, interval_in);
325    ++manager->count_;
326  }
327  static WEBP_INLINE void PushInterval(CostManager* const manager,
328                                       double distance_cost, int position,
329                                       int len) {
330    size_t i;
331    CostInterval* interval = manager->head_;
332    CostInterval* interval_next;
333    const CostCacheInterval* const cost_cache_intervals =
334        manager->cache_intervals_;
335    const int kSkipDistance = 10;
336    if (len < kSkipDistance) {
337      int j;
338      for (j = position; j < position + len; ++j) {
339        const int k = j - position;
340        float cost_tmp;
341        assert(k >= 0 && k < MAX_LENGTH);
342        cost_tmp = (float)(distance_cost + manager->cost_cache_[k]);
343        if (manager->costs_[j] > cost_tmp) {
344          manager->costs_[j] = cost_tmp;
345          manager->dist_array_[j] = k + 1;
346        }
347      }
348      return;
349    }
350    for (i = 0; i < manager->cache_intervals_size_ &&
351                cost_cache_intervals[i].start_ < len;
352         ++i) {
353      int start = position + cost_cache_intervals[i].start_;
354      const int end = position + (cost_cache_intervals[i].end_ > len
355                                   ? len
356                                   : cost_cache_intervals[i].end_);
357      const float cost = (float)(distance_cost + cost_cache_intervals[i].cost_);
358      for (; interval != NULL && interval->start_ < end;
359           interval = interval_next) {
360        interval_next = interval->next_;
361        if (start >= interval->end_) continue;
362        if (cost >= interval->cost_) {
363          const int start_new = interval->end_;
364          InsertInterval(manager, interval, cost, position, start,
365                         interval->start_);
366          start = start_new;
367          if (start >= end) break;
368          continue;
369        }
370        if (start <= interval->start_) {
371          if (interval->end_ <= end) {
372            PopInterval(manager, interval);
373          } else {
374            interval->start_ = end;
375            break;
376          }
377        } else {
378          if (end < interval->end_) {
379            const int end_original = interval->end_;
380            interval->end_ = start;
381            InsertInterval(manager, interval, interval->cost_, interval->index_,
382                           end, end_original);
383            interval = interval->next_;
384            break;
385          } else {
386            interval->end_ = start;
387          }
388        }
389      }
390      InsertInterval(manager, interval, cost, position, start, end);
391    }
392  }
393  static int BackwardReferencesHashChainDistanceOnly(
394      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
395      const VP8LHashChain* const hash_chain, const VP8LBackwardRefs* const refs,
396      uint16_t* const dist_array) {
397    int i;
398    int ok = 0;
399    int cc_init = 0;
400    const int pix_count = xsize * ysize;
401    const int use_color_cache = (cache_bits > 0);
402    const size_t literal_array_size =
403        sizeof(double) * (NUM_LITERAL_CODES + NUM_LENGTH_CODES +
404                          ((cache_bits > 0) ? (1 << cache_bits) : 0));
405    const size_t cost_model_size = sizeof(CostModel) + literal_array_size;
406    CostModel* const cost_model =
407        (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
408    VP8LColorCache hashers;
409    CostManager* cost_manager =
410        (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
411    int offset_prev = -1, len_prev = -1;
412    double offset_cost = -1;
413    int first_offset_is_constant = -1;  
414    int reach = 0;
415    if (cost_model == NULL || cost_manager == NULL) goto Error;
416    cost_model->literal_ = (double*)(cost_model + 1);
417    if (use_color_cache) {
418      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
419      if (!cc_init) goto Error;
420    }
421    if (!CostModelBuild(cost_model, xsize, cache_bits, refs)) {
422      goto Error;
423    }
424    if (!CostManagerInit(cost_manager, dist_array, pix_count, cost_model)) {
425      goto Error;
426    }
427    dist_array[0] = 0;
428    AddSingleLiteralWithCostModel(argb, &hashers, cost_model, 0, use_color_cache,
429                                  0.f, cost_manager->costs_, dist_array);
430    for (i = 1; i < pix_count; ++i) {
431      const float prev_cost = cost_manager->costs_[i - 1];
432      int offset, len;
433      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
434      AddSingleLiteralWithCostModel(argb, &hashers, cost_model, i,
435                                    use_color_cache, prev_cost,
436                                    cost_manager->costs_, dist_array);
437      if (len >= 2) {
438        if (offset != offset_prev) {
439          const int code = VP8LDistanceToPlaneCode(xsize, offset);
440          offset_cost = GetDistanceCost(cost_model, code);
441          first_offset_is_constant = 1;
442          PushInterval(cost_manager, prev_cost + offset_cost, i, len);
443        } else {
444          assert(offset_cost >= 0);
445          assert(len_prev >= 0);
446          assert(first_offset_is_constant == 0 || first_offset_is_constant == 1);
447          if (first_offset_is_constant) {
448            reach = i - 1 + len_prev - 1;
449            first_offset_is_constant = 0;
450          }
451          if (i + len - 1 > reach) {
452            int offset_j, len_j = 0;
453            int j;
454            assert(len == MAX_LENGTH || len == pix_count - i);
455            for (j = i; j <= reach; ++j) {
456              VP8LHashChainFindCopy(hash_chain, j + 1, &offset_j, &len_j);
457              if (offset_j != offset) {
458                VP8LHashChainFindCopy(hash_chain, j, &offset_j, &len_j);
459                break;
460              }
461            }
462            UpdateCostAtIndex(cost_manager, j - 1, 0);
463            UpdateCostAtIndex(cost_manager, j, 0);
464            PushInterval(cost_manager, cost_manager->costs_[j - 1] + offset_cost,
465                         j, len_j);
466            reach = j + len_j - 1;
467          }
468        }
469      }
470      UpdateCostAtIndex(cost_manager, i, 1);
471      offset_prev = offset;
472      len_prev = len;
473    }
474    ok = !refs->error_;
475  Error:
476    if (cc_init) VP8LColorCacheClear(&hashers);
477    CostManagerClear(cost_manager);
478    WebPSafeFree(cost_model);
479    WebPSafeFree(cost_manager);
480    return ok;
481  }
482  static void TraceBackwards(uint16_t* const dist_array,
483                             int dist_array_size,
484                             uint16_t** const chosen_path,
485                             int* const chosen_path_size) {
486    uint16_t* path = dist_array + dist_array_size;
487    uint16_t* cur = dist_array + dist_array_size - 1;
488    while (cur >= dist_array) {
489      const int k = *cur;
490      --path;
491      *path = k;
492      cur -= k;
493    }
494    *chosen_path = path;
495    *chosen_path_size = (int)(dist_array + dist_array_size - path);
496  }
497  static int BackwardReferencesHashChainFollowChosenPath(
498      const uint32_t* const argb, int cache_bits,
499      const uint16_t* const chosen_path, int chosen_path_size,
500      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs) {
501    const int use_color_cache = (cache_bits > 0);
502    int ix;
503    int i = 0;
504    int ok = 0;
505    int cc_init = 0;
506    VP8LColorCache hashers;
507    if (use_color_cache) {
508      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
509      if (!cc_init) goto Error;
510    }
511    VP8LClearBackwardRefs(refs);
512    for (ix = 0; ix < chosen_path_size; ++ix) {
513      const int len = chosen_path[ix];
514      if (len != 1) {
515        int k;
516        const int offset = VP8LHashChainFindOffset(hash_chain, i);
517        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
518        if (use_color_cache) {
519          for (k = 0; k < len; ++k) {
520            VP8LColorCacheInsert(&hashers, argb[i + k]);
521          }
522        }
523        i += len;
524      } else {
525        PixOrCopy v;
526        const int idx =
527            use_color_cache ? VP8LColorCacheContains(&hashers, argb[i]) : -1;
528        if (idx >= 0) {
529          v = PixOrCopyCreateCacheIdx(idx);
530        } else {
531          if (use_color_cache) VP8LColorCacheInsert(&hashers, argb[i]);
532          v = PixOrCopyCreateLiteral(argb[i]);
533        }
534        VP8LBackwardRefsCursorAdd(refs, v);
535        ++i;
536      }
537    }
538    ok = !refs->error_;
539   Error:
540    if (cc_init) VP8LColorCacheClear(&hashers);
541    return ok;
542  }
543  extern int VP8LBackwardReferencesTraceBackwards(
544      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
545      const VP8LHashChain* const hash_chain,
546      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
547  int VP8LBackwardReferencesTraceBackwards(int xsize, int ysize,
548                                           const uint32_t* const argb,
549                                           int cache_bits,
550                                           const VP8LHashChain* const hash_chain,
551                                           const VP8LBackwardRefs* const refs_src,
552                                           VP8LBackwardRefs* const refs_dst) {
553    int ok = 0;
554    const int dist_array_size = xsize * ysize;
555    uint16_t* chosen_path = NULL;
556    int chosen_path_size = 0;
557    uint16_t* dist_array =
558        (uint16_t*)WebPSafeMalloc(dist_array_size, sizeof(*dist_array));
559    if (dist_array == NULL) goto Error;
560    if (!BackwardReferencesHashChainDistanceOnly(
561            xsize, ysize, argb, cache_bits, hash_chain, refs_src, dist_array)) {
562      goto Error;
563    }
564    TraceBackwards(dist_array, dist_array_size, &chosen_path, &chosen_path_size);
565    if (!BackwardReferencesHashChainFollowChosenPath(
566            argb, cache_bits, chosen_path, chosen_path_size, hash_chain,
567            refs_dst)) {
568      goto Error;
569    }
570    ok = 1;
571   Error:
572    WebPSafeFree(dist_array);
573    return ok;
574  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include "fuse_config.h"
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <stdarg.h>
6  #include <string.h>
7  #include <unistd.h>
8  #include <fcntl.h>
9  #include <dirent.h>
10  #include <utime.h>
11  #include <errno.h>
12  #include <assert.h>
13  #include <sys/socket.h>
14  #include <sys/types.h>
15  #include <sys/stat.h>
16  #include <sys/un.h>
17  #ifndef ALLPERMS
18  # define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)&bsol;* 07777 */
19  #endif
20  static const char *basepath;
21  static const char *basepath_r;
22  static char testfile[1024];
23  static char testfile2[1024];
24  static char testdir[1024];
25  static char testdir2[1024];
26  static char testsock[1024];
27  static char subfile[1280];
28  static char testfile_r[1024];
29  static char testfile2_r[1024];
30  static char testdir_r[1024];
31  static char testdir2_r[1024];
32  static char subfile_r[1280];
33  static char testname[256];
34  static char testdata[] = "abcdefghijklmnopqrstuvwxyz";
35  static char testdata2[] = "1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./";
36  static const char *testdir_files[] = { "f1", "f2", NULL};
37  static long seekdir_offsets[4];
38  static char zerodata[4096];
39  static int testdatalen = sizeof(testdata) - 1;
40  static int testdata2len = sizeof(testdata2) - 1;
41  static unsigned int testnum = 0;
42  static unsigned int select_test = 0;
43  static unsigned int skip_test = 0;
44  static unsigned int unlinked_test = 0;
45  #define MAX_ENTRIES 1024
46  #define MAX_TESTS 100
47  static struct test {
48  	int fd;
49  	struct stat stat;
50  } tests[MAX_TESTS];
51  static void test_perror(const char *func, const char *msg)
52  {
53  	fprintf(stderr, "%s %s() - %s: %s\n", testname, func, msg,
54  		strerror(errno));
55  }
56  static void test_error(const char *func, const char *msg, ...)
57  	__attribute__ ((format (printf, 2, 3)));
58  static void __start_test(const char *fmt, ...)
59  	__attribute__ ((format (printf, 1, 2)));
60  static void test_error(const char *func, const char *msg, ...)
61  {
62  	va_list ap;
63  	fprintf(stderr, "%s %s() - ", testname, func);
64  	va_start(ap, msg);
65  	vfprintf(stderr, msg, ap);
66  	va_end(ap);
67  	fprintf(stderr, "\n");
68  }
69  static int is_dot_or_dotdot(const char *name) {
70      return name[0] == '.' &&
71             (name[1] == '\0' || (name[1] == '.' && name[2] == '\0'));
72  }
73  static void success(void)
74  {
75  	fprintf(stderr, "%s OK\n", testname);
76  }
77  #define this_test (&tests[testnum-1])
78  #define next_test (&tests[testnum])
79  static void __start_test(const char *fmt, ...)
80  {
81  	unsigned int n;
82  	va_list ap;
83  	n = sprintf(testname, "%3i [", testnum);
84  	va_start(ap, fmt);
85  	n += vsprintf(testname + n, fmt, ap);
86  	va_end(ap);
87  	sprintf(testname + n, "]");
88  	sprintf(testfile, "%s/testfile.%d", basepath, testnum);
89  	sprintf(testfile_r, "%s/testfile.%d", basepath_r, testnum);
90  	if (testnum > MAX_TESTS) {
91  		fprintf(stderr, "%s - too many tests\n", testname);
92  		exit(1);
93  	}
94  	this_test->fd = -1;
95  }
96  #define start_test(msg, args...) { \
97  	testnum++; \
98  	if ((select_test && testnum != select_test) || \
99  	    (testnum == skip_test)) { \
100  		return 0; \
101  	} \
102  	__start_test(msg, ##args);		\
103  }
104  #define PERROR(msg) test_perror(__FUNCTION__, msg)
105  #define ERROR(msg, args...) test_error(__FUNCTION__, msg, ##args)
106  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
107  static int st_check_size(struct stat *st, int len)
108  {
109  	if (st->st_size != len) {
110  		ERROR("length %u instead of %u", (int) st->st_size,
111  		      (int) len);
112  		return -1;
113  	}
114  	return 0;
115  }
116  static int check_size(const char *path, int len)
117  {
118  	struct stat stbuf;
119  	int res = stat(path, &stbuf);
120  	if (res == -1) {
121  		PERROR("stat");
122  		return -1;
123  	}
124  	return st_check_size(&stbuf, len);
125  }
126  static int check_testfile_size(const char *path, int len)
127  {
128  	this_test->stat.st_size = len;
129  	return check_size(path, len);
130  }
131  static int st_check_type(struct stat *st, mode_t type)
132  {
133  	if ((st->st_mode & S_IFMT) != type) {
134  		ERROR("type 0%o instead of 0%o", st->st_mode & S_IFMT, type);
135  		return -1;
136  	}
137  	return 0;
138  }
139  static int check_type(const char *path, mode_t type)
140  {
141  	struct stat stbuf;
142  	int res = lstat(path, &stbuf);
143  	if (res == -1) {
144  		PERROR("lstat");
145  		return -1;
146  	}
147  	return st_check_type(&stbuf, type);
148  }
149  static int st_check_mode(struct stat *st, mode_t mode)
150  {
151  	if ((st->st_mode & ALLPERMS) != mode) {
152  		ERROR("mode 0%o instead of 0%o", st->st_mode & ALLPERMS,
153  		      mode);
154  		return -1;
155  	}
156  	return 0;
157  }
158  static int check_mode(const char *path, mode_t mode)
159  {
160  	struct stat stbuf;
161  	int res = lstat(path, &stbuf);
162  	if (res == -1) {
163  		PERROR("lstat");
164  		return -1;
165  	}
166  	return st_check_mode(&stbuf, mode);
167  }
168  static int check_testfile_mode(const char *path, mode_t mode)
169  {
170  	this_test->stat.st_mode &= ~ALLPERMS;
171  	this_test->stat.st_mode |= mode;
172  	return check_mode(path, mode);
173  }
174  static int check_times(const char *path, time_t atime, time_t mtime)
175  {
176  	int err = 0;
177  	struct stat stbuf;
178  	int res = lstat(path, &stbuf);
179  	if (res == -1) {
180  		PERROR("lstat");
181  		return -1;
182  	}
183  	if (stbuf.st_atime != atime) {
184  		ERROR("atime %li instead of %li", stbuf.st_atime, atime);
185  		err--;
186  	}
187  	if (stbuf.st_mtime != mtime) {
188  		ERROR("mtime %li instead of %li", stbuf.st_mtime, mtime);
189  		err--;
190  	}
191  	if (err)
192  		return -1;
193  	return 0;
194  }
195  #if 0
196  static int fcheck_times(int fd, time_t atime, time_t mtime)
197  {
198  	int err = 0;
199  	struct stat stbuf;
200  	int res = fstat(fd, &stbuf);
201  	if (res == -1) {
202  		PERROR("fstat");
203  		return -1;
204  	}
205  	if (stbuf.st_atime != atime) {
206  		ERROR("atime %li instead of %li", stbuf.st_atime, atime);
207  		err--;
208  	}
209  	if (stbuf.st_mtime != mtime) {
210  		ERROR("mtime %li instead of %li", stbuf.st_mtime, mtime);
211  		err--;
212  	}
213  	if (err)
214  		return -1;
215  	return 0;
216  }
217  #endif
218  static int st_check_nlink(struct stat *st, nlink_t nlink)
219  {
220  	if (st->st_nlink != nlink) {
221  		ERROR("nlink %li instead of %li", (long) st->st_nlink,
222  		      (long) nlink);
223  		return -1;
224  	}
225  	return 0;
226  }
227  static int check_nlink(const char *path, nlink_t nlink)
228  {
229  	struct stat stbuf;
230  	int res = lstat(path, &stbuf);
231  	if (res == -1) {
232  		PERROR("lstat");
233  		return -1;
234  	}
235  	return st_check_nlink(&stbuf, nlink);
236  }
237  static int fcheck_stat(int fd, int flags, struct stat *st)
238  {
239  	struct stat stbuf;
240  	int res = fstat(fd, &stbuf);
241  	if (res == -1) {
242  		if (flags & O_PATH) {
243  			if (errno == ESTALE || errno == EIO ||
244  			    errno == ENOENT || errno == EBADF)
245  				return 0;
246  		}
247  		PERROR("fstat");
248  		return -1;
249  	}
250  	int err = 0;
251  	err += st_check_type(&stbuf, st->st_mode & S_IFMT);
252  	err += st_check_mode(&stbuf, st->st_mode & ALLPERMS);
253  	err += st_check_size(&stbuf, st->st_size);
254  	err += st_check_nlink(&stbuf, st->st_nlink);
255  	return err;
256  }
257  static int check_nonexist(const char *path)
258  {
259  	struct stat stbuf;
260  	int res = lstat(path, &stbuf);
261  	if (res == 0) {
262  		ERROR("file should not exist");
263  		return -1;
264  	}
265  	if (errno != ENOENT) {
266  		ERROR("file should not exist: %s", strerror(errno));
267  		return -1;
268  	}
269  	return 0;
270  }
271  static int check_buffer(const char *buf, const char *data, unsigned len)
272  {
273  	if (memcmp(buf, data, len) != 0) {
274  		ERROR("data mismatch");
275  		return -1;
276  	}
277  	return 0;
278  }
279  static int check_data(const char *path, const char *data, int offset,
280  		      unsigned len)
281  {
282  	char buf[4096];
283  	int res;
284  	int fd = open(path, O_RDONLY);
285  	if (fd == -1) {
286  		PERROR("open");
287  		return -1;
288  	}
289  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
290  		PERROR("lseek");
291  		close(fd);
292  		return -1;
293  	}
294  	while (len) {
295  		int rdlen = len < sizeof(buf) ? len : sizeof(buf);
296  		res = read(fd, buf, rdlen);
297  		if (res == -1) {
298  			PERROR("read");
299  			close(fd);
300  			return -1;
301  		}
302  		if (res != rdlen) {
303  			ERROR("short read: %u instead of %u", res, rdlen);
304  			close(fd);
305  			return -1;
306  		}
307  		if (check_buffer(buf, data, rdlen) != 0) {
308  			close(fd);
309  			return -1;
310  		}
311  		data += rdlen;
312  		len -= rdlen;
313  	}
314  	res = close(fd);
315  	if (res == -1) {
316  		PERROR("close");
317  		return -1;
318  	}
319  	return 0;
320  }
321  static int fcheck_data(int fd, const char *data, int offset,
322  		       unsigned len)
323  {
324  	char buf[4096];
325  	int res;
326  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
327  		PERROR("lseek");
328  		return -1;
329  	}
330  	while (len) {
331  		int rdlen = len < sizeof(buf) ? len : sizeof(buf);
332  		res = read(fd, buf, rdlen);
333  		if (res == -1) {
334  			PERROR("read");
335  			return -1;
336  		}
337  		if (res != rdlen) {
338  			ERROR("short read: %u instead of %u", res, rdlen);
339  			return -1;
340  		}
341  		if (check_buffer(buf, data, rdlen) != 0) {
342  			return -1;
343  		}
344  		data += rdlen;
345  		len -= rdlen;
346  	}
347  	return 0;
348  }
349  static int check_dir_contents(const char *path, const char **contents)
350  {
351  	int i;
352  	int res;
353  	int err = 0;
354  	int found[MAX_ENTRIES];
355  	const char *cont[MAX_ENTRIES];
356  	DIR *dp;
357  	for (i = 0; contents[i]; i++) {
358  		assert(i < MAX_ENTRIES - 3);
359  		found[i] = 0;
360  		cont[i] = contents[i];
361  	}
362  	cont[i] = NULL;
363  	dp = opendir(path);
364  	if (dp == NULL) {
365  		PERROR("opendir");
366  		return -1;
367  	}
368  	memset(found, 0, sizeof(found));
369  	while(1) {
370  		struct dirent *de;
371  		errno = 0;
372  		de = readdir(dp);
373  		if (de == NULL) {
374  			if (errno) {
375  				PERROR("readdir");
376  				closedir(dp);
377  				return -1;
378  			}
379  			break;
380  		}
381  		if (is_dot_or_dotdot(de->d_name))
382  			continue;
383  		for (i = 0; cont[i] != NULL; i++) {
384  			assert(i < MAX_ENTRIES);
385  			if (strcmp(cont[i], de->d_name) == 0) {
386  				if (found[i]) {
387  					ERROR("duplicate entry <%s>",
388  					      de->d_name);
389  					err--;
390  				} else
391  					found[i] = 1;
392  				break;
393  			}
394  		}
395  		if (!cont[i]) {
396  			ERROR("unexpected entry <%s>", de->d_name);
397  			err --;
398  		}
399  	}
400  	for (i = 0; cont[i] != NULL; i++) {
401  		if (!found[i]) {
402  			ERROR("missing entry <%s>", cont[i]);
403  			err--;
404  		}
405  	}
406  	res = closedir(dp);
407  	if (res == -1) {
408  		PERROR("closedir");
409  		return -1;
410  	}
411  	if (err)
412  		return -1;
413  	return 0;
414  }
415  static int create_file(const char *path, const char *data, int len)
416  {
417  	int res;
418  	int fd;
419  	unlink(path);
420  	fd = creat(path, 0644);
421  	if (fd == -1) {
422  		PERROR("creat");
423  		return -1;
424  	}
425  	if (len) {
426  		res = write(fd, data, len);
427  		if (res == -1) {
428  			PERROR("write");
429  			close(fd);
430  			return -1;
431  		}
432  		if (res != len) {
433  			ERROR("write is short: %u instead of %u", res, len);
434  			close(fd);
435  			return -1;
436  		}
437  	}
438  	res = close(fd);
439  	if (res == -1) {
440  		PERROR("close");
441  		return -1;
442  	}
443  	res = check_type(path, S_IFREG);
444  	if (res == -1)
445  		return -1;
446  	res = check_mode(path, 0644);
447  	if (res == -1)
448  		return -1;
449  	res = check_nlink(path, 1);
450  	if (res == -1)
451  		return -1;
452  	res = check_size(path, len);
453  	if (res == -1)
454  		return -1;
455  	if (len) {
456  		res = check_data(path, data, 0, len);
457  		if (res == -1)
458  			return -1;
459  	}
460  	return 0;
461  }
462  static int create_path_fd(const char *path, const char *data, int len)
463  {
464  	int path_fd;
465  	int res;
466  	res = create_file(path, data, len);
467  	if (res == -1)
468  		return -1;
469  	path_fd = open(path, O_PATH);
470  	if (path_fd == -1)
471  		PERROR("open(O_PATH)");
472  	return path_fd;
473  }
474  static int create_testfile(const char *path, const char *data, int len)
475  {
476  	struct test *t = this_test;
477  	struct stat *st = &t->stat;
478  	int res, fd;
479  	if (t->fd > 0) {
480  		ERROR("testfile already created");
481  		return -1;
482  	}
483  	fd = create_path_fd(path, data, len);
484  	if (fd == -1)
485  		return -1;
486  	t->fd = fd;
487  	res = fstat(fd, st);
488  	if (res == -1) {
489  		PERROR("fstat");
490  		return -1;
491  	}
492  	return 0;
493  }
494  static int check_unlinked_testfile(int fd)
495  {
496  	struct stat *st = &this_test->stat;
497  	st->st_nlink = 0;
498  	return fcheck_stat(fd, O_PATH, st);
499  }
500  static int check_unlinked_testfiles(void)
501  {
502  	int fd;
503  	int res, err = 0;
504  	int num = testnum;
505  	if (!unlinked_test)
506  		return 0;
507  	testnum = 0;
508  	while (testnum < num) {
509  		fd = next_test->fd;
510  		start_test("check_unlinked_testfile");
511  		if (fd == -1)
512  			continue;
513  		err += check_unlinked_testfile(fd);
514  		res = close(fd);
515  		if (res == -1) {
516  			PERROR("close(test_fd)");
517  			err--;
518  		}
519  	}
520  	if (err) {
521  		fprintf(stderr, "%i unlinked testfile checks failed\n", -err);
522  		return 1;
523  	}
524  	return err;
525  }
526  static int cleanup_dir(const char *path, const char **dir_files, int quiet)
527  {
528  	int i;
529  	int err = 0;
530  	for (i = 0; dir_files[i]; i++) {
531  		int res;
532  		char fpath[1280];
533  		sprintf(fpath, "%s/%s", path, dir_files[i]);
534  		res = unlink(fpath);
535  		if (res == -1 && !quiet) {
536  			PERROR("unlink");
537  			err --;
538  		}
539  	}
540  	if (err)
541  		return -1;
542  	return 0;
543  }
544  static int create_dir(const char *path, const char **dir_files)
545  {
546  	int res;
547  	int i;
548  	rmdir(path);
549  	res = mkdir(path, 0755);
550  	if (res == -1) {
551  		PERROR("mkdir");
552  		return -1;
553  	}
554  	res = check_type(path, S_IFDIR);
555  	if (res == -1)
556  		return -1;
557  	res = check_mode(path, 0755);
558  	if (res == -1)
559  		return -1;
560  	for (i = 0; dir_files[i]; i++) {
561  		char fpath[1280];
562  		sprintf(fpath, "%s/%s", path, dir_files[i]);
563  		res = create_file(fpath, "", 0);
564  		if (res == -1) {
565  			cleanup_dir(path, dir_files, 1);
566  			return -1;
567  		}
568  	}
569  	res = check_dir_contents(path, dir_files);
570  	if (res == -1) {
571  		cleanup_dir(path, dir_files, 1);
572  		return -1;
573  	}
574  	return 0;
575  }
576  static int test_truncate(int len)
577  {
578  	const char *data = testdata;
579  	int datalen = testdatalen;
580  	int res;
581  	start_test("truncate(%u)", (int) len);
582  	res = create_testfile(testfile, data, datalen);
583  	if (res == -1)
584  		return -1;
585  	res = truncate(testfile, len);
586  	if (res == -1) {
587  		PERROR("truncate");
588  		return -1;
589  	}
590  	res = check_testfile_size(testfile, len);
591  	if (res == -1)
592  		return -1;
593  	if (len > 0) {
594  		if (len <= datalen) {
595  			res = check_data(testfile, data, 0, len);
596  			if (res == -1)
597  				return -1;
598  		} else {
599  			res = check_data(testfile, data, 0, datalen);
600  			if (res == -1)
601  				return -1;
602  			res = check_data(testfile, zerodata, datalen,
603  					 len - datalen);
604  			if (res == -1)
605  				return -1;
606  		}
607  	}
608  	res = unlink(testfile);
609  	if (res == -1) {
610  		PERROR("unlink");
611  		return -1;
612  	}
613  	res = check_nonexist(testfile);
614  	if (res == -1)
615  		return -1;
616  	success();
617  	return 0;
618  }
619  static int test_ftruncate(int len, int mode)
620  {
621  	const char *data = testdata;
622  	int datalen = testdatalen;
623  	int res;
624  	int fd;
625  	start_test("ftruncate(%u) mode: 0%03o", len, mode);
626  	res = create_testfile(testfile, data, datalen);
627  	if (res == -1)
628  		return -1;
629  	fd = open(testfile, O_WRONLY);
630  	if (fd == -1) {
631  		PERROR("open");
632  		return -1;
633  	}
634  	res = fchmod(fd, mode);
635  	if (res == -1) {
636  		PERROR("fchmod");
637  		close(fd);
638  		return -1;
639  	}
640  	res = check_testfile_mode(testfile, mode);
641  	if (res == -1) {
642  		close(fd);
643  		return -1;
644  	}
645  	res = ftruncate(fd, len);
646  	if (res == -1) {
647  		PERROR("ftruncate");
648  		close(fd);
649  		return -1;
650  	}
651  	close(fd);
652  	res = check_testfile_size(testfile, len);
653  	if (res == -1)
654  		return -1;
655  	if (len > 0) {
656  		if (len <= datalen) {
657  			res = check_data(testfile, data, 0, len);
658  			if (res == -1)
659  				return -1;
660  		} else {
661  			res = check_data(testfile, data, 0, datalen);
662  			if (res == -1)
663  				return -1;
664  			res = check_data(testfile, zerodata, datalen,
665  					 len - datalen);
666  			if (res == -1)
667  				return -1;
668  		}
669  	}
670  	res = unlink(testfile);
671  	if (res == -1) {
672  		PERROR("unlink");
673  		return -1;
674  	}
675  	res = check_nonexist(testfile);
676  	if (res == -1)
677  		return -1;
678  	success();
679  	return 0;
680  }
681  static int test_seekdir(void)
682  {
683  	int i;
684  	int res;
685  	DIR *dp;
686  	struct dirent *de;
687  	start_test("seekdir");
688  	res = create_dir(testdir, testdir_files);
689  	if (res == -1)
690  		return res;
691  	dp = opendir(testdir);
<span onclick='openModal()' class='match'>692  	if (dp == NULL) {
693  		PERROR("opendir");
694  		return -1;
695  	}
696  	for (i = 0; i < ARRAY_SIZE(seekdir_offsets); i++) {
</span>697  		seekdir_offsets[i] = telldir(dp);
698  		errno = 0;
699  		de = readdir(dp);
700  		if (de == NULL) {
701  			if (errno) {
702  				PERROR("readdir");
703  				goto fail;
704  			}
705  			break;
706  		}
707  	}
708  	while (de)
709  		de = readdir(dp);
710  	for (i--; i >= 0; i--) {
711  		seekdir(dp, seekdir_offsets[i]);
712  		de = readdir(dp);
713  		if (de == NULL) {
714  			ERROR("Unexpected end of directory after seekdir()");
715  			goto fail;
716  		}
717  	}
718  	closedir(dp);
719  	res = cleanup_dir(testdir, testdir_files, 0);
720  	if (!res)
721  		success();
722  	return res;
723  fail:
724  	closedir(dp);
725  	cleanup_dir(testdir, testdir_files, 1);
726  	return -1;
727  }
728  #ifdef HAVE_COPY_FILE_RANGE
729  static int test_copy_file_range(void)
730  {
731  	const char *data = testdata;
732  	int datalen = testdatalen;
733  	int err = 0;
734  	int res;
735  	int fd_in, fd_out;
736  	off_t pos_in = 0, pos_out = 0;
737  	start_test("copy_file_range");
738  	unlink(testfile);
739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR("creat");
742  		return -1;
743  	}
744  	res = write(fd_in, data, datalen);
745  	if (res == -1) {
746  		PERROR("write");
747  		close(fd_in);
748  		return -1;
749  	}
750  	if (res != datalen) {
751  		ERROR("write is short: %u instead of %u", res, datalen);
752  		close(fd_in);
753  		return -1;
754  	}
755  	unlink(testfile2);
756  	fd_out = creat(testfile2, 0644);
757  	if (fd_out == -1) {
758  		PERROR("creat");
759  		close(fd_in);
760  		return -1;
761  	}
762  	res = copy_file_range(fd_in, &pos_in, fd_out, &pos_out, datalen, 0);
763  	if (res == -1) {
764  		PERROR("copy_file_range");
765  		close(fd_in);
766  		close(fd_out);
767  		return -1;
768  	}
769  	if (res != datalen) {
770  		ERROR("copy is short: %u instead of %u", res, datalen);
771  		close(fd_in);
772  		close(fd_out);
773  		return -1;
774  	}
775  	res = close(fd_in);
776  	if (res == -1) {
777  		PERROR("close");
778  		close(fd_out);
779  		return -1;
780  	}
781  	res = close(fd_out);
782  	if (res == -1) {
783  		PERROR("close");
784  		return -1;
785  	}
786  	err = check_data(testfile2, data, 0, datalen);
787  	res = unlink(testfile);
788  	if (res == -1) {
789  		PERROR("unlink");
790  		return -1;
791  	}
792  	res = check_nonexist(testfile);
793  	if (res == -1)
794  		return -1;
795  	if (err)
796  		return -1;
797  	res = unlink(testfile2);
798  	if (res == -1) {
799  		PERROR("unlink");
800  		return -1;
801  	}
802  	res = check_nonexist(testfile2);
803  	if (res == -1)
804  		return -1;
805  	if (err)
806  		return -1;
807  	success();
808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
817  {
818  	struct utimbuf utm;
819  	time_t atime = 987631200;
820  	time_t mtime = 123116400;
821  	int res;
822  	start_test("utime");
823  	res = create_testfile(testfile, NULL, 0);
824  	if (res == -1)
825  		return -1;
826  	utm.actime = atime;
827  	utm.modtime = mtime;
828  	res = utime(testfile, &utm);
829  	if (res == -1) {
830  		PERROR("utime");
831  		return -1;
832  	}
833  	res = check_times(testfile, atime, mtime);
834  	if (res == -1) {
835  		return -1;
836  	}
837  	res = unlink(testfile);
838  	if (res == -1) {
839  		PERROR("unlink");
840  		return -1;
841  	}
842  	res = check_nonexist(testfile);
843  	if (res == -1)
844  		return -1;
845  	success();
846  	return 0;
847  }
848  static int test_create(void)
849  {
850  	const char *data = testdata;
851  	int datalen = testdatalen;
852  	int err = 0;
853  	int res;
854  	int fd;
855  	start_test("create");
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
858  	if (fd == -1) {
859  		PERROR("creat");
860  		return -1;
861  	}
862  	res = write(fd, data, datalen);
863  	if (res == -1) {
864  		PERROR("write");
865  		close(fd);
866  		return -1;
867  	}
868  	if (res != datalen) {
869  		ERROR("write is short: %u instead of %u", res, datalen);
870  		close(fd);
871  		return -1;
872  	}
873  	res = close(fd);
874  	if (res == -1) {
875  		PERROR("close");
876  		return -1;
877  	}
878  	res = check_type(testfile, S_IFREG);
879  	if (res == -1)
880  		return -1;
881  	err += check_mode(testfile, 0644);
882  	err += check_nlink(testfile, 1);
883  	err += check_size(testfile, datalen);
884  	err += check_data(testfile, data, 0, datalen);
885  	res = unlink(testfile);
886  	if (res == -1) {
887  		PERROR("unlink");
888  		return -1;
889  	}
890  	res = check_nonexist(testfile);
891  	if (res == -1)
892  		return -1;
893  	if (err)
894  		return -1;
895  	success();
896  	return 0;
897  }
898  static int test_create_unlink(void)
899  {
900  	const char *data = testdata;
901  	int datalen = testdatalen;
902  	int err = 0;
903  	int res;
904  	int fd;
905  	start_test("create+unlink");
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
908  	if (fd == -1) {
909  		PERROR("creat");
910  		return -1;
911  	}
912  	res = unlink(testfile);
913  	if (res == -1) {
914  		PERROR("unlink");
915  		close(fd);
916  		return -1;
917  	}
918  	res = check_nonexist(testfile);
919  	if (res == -1) {
920  		close(fd);
921  		return -1;
922  	}
923  	res = write(fd, data, datalen);
924  	if (res == -1) {
925  		PERROR("write");
926  		close(fd);
927  		return -1;
928  	}
929  	if (res != datalen) {
930  		ERROR("write is short: %u instead of %u", res, datalen);
931  		close(fd);
932  		return -1;
933  	}
934  	struct stat st = {
935  		.st_mode = S_IFREG | 0644,
936  		.st_size = datalen,
937  	};
938  	err = fcheck_stat(fd, O_RDWR, &st);
939  	err += fcheck_data(fd, data, 0, datalen);
940  	res = close(fd);
941  	if (res == -1) {
942  		PERROR("close");
943  		err--;
944  	}
945  	if (err)
946  		return -1;
947  	success();
948  	return 0;
949  }
950  #ifndef __FreeBSD__
951  static int test_mknod(void)
952  {
953  	int err = 0;
954  	int res;
955  	start_test("mknod");
956  	unlink(testfile);
957  	res = mknod(testfile, 0644, 0);
958  	if (res == -1) {
959  		PERROR("mknod");
960  		return -1;
961  	}
962  	res = check_type(testfile, S_IFREG);
963  	if (res == -1)
964  		return -1;
965  	err += check_mode(testfile, 0644);
966  	err += check_nlink(testfile, 1);
967  	err += check_size(testfile, 0);
968  	res = unlink(testfile);
969  	if (res == -1) {
970  		PERROR("unlink");
971  		return -1;
972  	}
973  	res = check_nonexist(testfile);
974  	if (res == -1)
975  		return -1;
976  	if (err)
977  		return -1;
978  	success();
979  	return 0;
980  }
981  #endif
982  #define test_open(exist, flags, mode)  do_test_open(exist, flags, #flags, mode)
983  static int do_test_open(int exist, int flags, const char *flags_str, int mode)
984  {
985  	char buf[4096];
986  	const char *data = testdata;
987  	int datalen = testdatalen;
988  	unsigned currlen = 0;
989  	int err = 0;
990  	int res;
991  	int fd;
992  	off_t off;
993  	start_test("open(%s, %s, 0%03o)", exist ? "+" : "-", flags_str, mode);
994  	unlink(testfile);
995  	if (exist) {
996  		res = create_file(testfile_r, testdata2, testdata2len);
997  		if (res == -1)
998  			return -1;
999  		currlen = testdata2len;
1000  	}
1001  	fd = open(testfile, flags, mode);
1002  	if ((flags & O_CREAT) && (flags & O_EXCL) && exist) {
1003  		if (fd != -1) {
1004  			ERROR("open should have failed");
1005  			close(fd);
1006  			return -1;
1007  		} else if (errno == EEXIST)
1008  			goto succ;
1009  	}
1010  	if (!(flags & O_CREAT) && !exist) {
1011  		if (fd != -1) {
1012  			ERROR("open should have failed");
1013  			close(fd);
1014  			return -1;
1015  		} else if (errno == ENOENT)
1016  			goto succ;
1017  	}
1018  	if (fd == -1) {
1019  		PERROR("open");
1020  		return -1;
1021  	}
1022  	if (flags & O_TRUNC)
1023  		currlen = 0;
1024  	err += check_type(testfile, S_IFREG);
1025  	if (exist)
1026  		err += check_mode(testfile, 0644);
1027  	else
1028  		err += check_mode(testfile, mode);
1029  	err += check_nlink(testfile, 1);
1030  	err += check_size(testfile, currlen);
1031  	if (exist && !(flags & O_TRUNC) && (mode & S_IRUSR))
1032  		err += check_data(testfile, testdata2, 0, testdata2len);
1033  	res = write(fd, data, datalen);
1034  	if ((flags & O_ACCMODE) != O_RDONLY) {
1035  		if (res == -1) {
1036  			PERROR("write");
1037  			err --;
1038  		} else if (res != datalen) {
1039  			ERROR("write is short: %u instead of %u", res, datalen);
1040  			err --;
1041  		} else {
1042  			if (datalen > (int) currlen)
1043  				currlen = datalen;
1044  			err += check_size(testfile, currlen);
1045  			if (mode & S_IRUSR) {
1046  				err += check_data(testfile, data, 0, datalen);
1047  				if (exist && !(flags & O_TRUNC) &&
1048  				    testdata2len > datalen)
1049  					err += check_data(testfile,
1050  							  testdata2 + datalen,
1051  							  datalen,
1052  							  testdata2len - datalen);
1053  			}
1054  		}
1055  	} else {
1056  		if (res != -1) {
1057  			ERROR("write should have failed");
1058  			err --;
1059  		} else if (errno != EBADF) {
1060  			PERROR("write");
1061  			err --;
1062  		}
1063  	}
1064  	off = lseek(fd, SEEK_SET, 0);
1065  	if (off == (off_t) -1) {
1066  		PERROR("lseek");
1067  		err--;
1068  	} else if (off != 0) {
1069  		ERROR("offset should have returned 0");
1070  		err --;
1071  	}
1072  	res = read(fd, buf, sizeof(buf));
1073  	if ((flags & O_ACCMODE) != O_WRONLY) {
1074  		if (res == -1) {
1075  			PERROR("read");
1076  			err--;
1077  		} else {
1078  			int readsize =
1079  				currlen < sizeof(buf) ? currlen : sizeof(buf);
1080  			if (res != readsize) {
1081  				ERROR("read is short: %i instead of %u",
1082  				      res, readsize);
1083  				err--;
1084  			} else {
1085  				if ((flags & O_ACCMODE) != O_RDONLY) {
1086  					err += check_buffer(buf, data, datalen);
1087  					if (exist && !(flags & O_TRUNC) &&
1088  					    testdata2len > datalen)
1089  						err += check_buffer(buf + datalen,
1090  								    testdata2 + datalen,
1091  								    testdata2len - datalen);
1092  				} else if (exist)
1093  					err += check_buffer(buf, testdata2,
1094  							    testdata2len);
1095  			}
1096  		}
1097  	} else {
1098  		if (res != -1) {
1099  			ERROR("read should have failed");
1100  			err --;
1101  		} else if (errno != EBADF) {
1102  			PERROR("read");
1103  			err --;
1104  		}
1105  	}
1106  	res = close(fd);
1107  	if (res == -1) {
1108  		PERROR("close");
1109  		return -1;
1110  	}
1111  	res = unlink(testfile);
1112  	if (res == -1) {
1113  		PERROR("unlink");
1114  		return -1;
1115  	}
1116  	res = check_nonexist(testfile);
1117  	if (res == -1)
1118  		return -1;
1119  	res = check_nonexist(testfile_r);
1120  	if (res == -1)
1121  		return -1;
1122  	if (err)
1123  		return -1;
1124  succ:
1125  	success();
1126  	return 0;
1127  }
1128  #define test_open_acc(flags, mode, err)	 \
1129  	do_test_open_acc(flags, #flags, mode, err)
1130  static int do_test_open_acc(int flags, const char *flags_str, int mode, int err)
1131  {
1132  	const char *data = testdata;
1133  	int datalen = testdatalen;
1134  	int res;
1135  	int fd;
1136  	start_test("open_acc(%s) mode: 0%03o message: '%s'", flags_str, mode,
1137  		   strerror(err));
1138  	unlink(testfile);
1139  	res = create_testfile(testfile, data, datalen);
1140  	if (res == -1)
1141  		return -1;
1142  	res = chmod(testfile, mode);
1143  	if (res == -1) {
1144  		PERROR("chmod");
1145  		return -1;
1146  	}
1147  	res = check_testfile_mode(testfile, mode);
1148  	if (res == -1)
1149  		return -1;
1150  	fd = open(testfile, flags);
1151  	if (fd == -1) {
1152  		if (err != errno) {
1153  			PERROR("open");
1154  			return -1;
1155  		}
1156  	} else {
1157  		if (err) {
1158  			ERROR("open should have failed");
1159  			close(fd);
1160  			return -1;
1161  		}
1162  		close(fd);
1163  	}
1164  	res = unlink(testfile);
1165  	if (res == -1) {
1166  		PERROR("unlink");
1167  		return -1;
1168  	}
1169  	res = check_nonexist(testfile);
1170  	if (res == -1)
1171  		return -1;
1172  	res = check_nonexist(testfile_r);
1173  	if (res == -1)
1174  		return -1;
1175  	success();
1176  	return 0;
1177  }
1178  static int test_symlink(void)
1179  {
1180  	char buf[1024];
1181  	const char *data = testdata;
1182  	int datalen = testdatalen;
1183  	int linklen = strlen(testfile);
1184  	int err = 0;
1185  	int res;
1186  	start_test("symlink");
1187  	res = create_testfile(testfile, data, datalen);
1188  	if (res == -1)
1189  		return -1;
1190  	unlink(testfile2);
1191  	res = symlink(testfile, testfile2);
1192  	if (res == -1) {
1193  		PERROR("symlink");
1194  		return -1;
1195  	}
1196  	res = check_type(testfile2, S_IFLNK);
1197  	if (res == -1)
1198  		return -1;
1199  	err += check_mode(testfile2, 0777);
1200  	err += check_nlink(testfile2, 1);
1201  	res = readlink(testfile2, buf, sizeof(buf));
1202  	if (res == -1) {
1203  		PERROR("readlink");
1204  		err--;
1205  	}
1206  	if (res != linklen) {
1207  		ERROR("short readlink: %u instead of %u", res, linklen);
1208  		err--;
1209  	}
1210  	if (memcmp(buf, testfile, linklen) != 0) {
1211  		ERROR("link mismatch");
1212  		err--;
1213  	}
1214  	err += check_size(testfile2, datalen);
1215  	err += check_data(testfile2, data, 0, datalen);
1216  	res = unlink(testfile2);
1217  	if (res == -1) {
1218  		PERROR("unlink");
1219  		return -1;
1220  	}
1221  	res = check_nonexist(testfile2);
1222  	if (res == -1)
1223  		return -1;
1224  	if (err)
1225  		return -1;
1226  	res = unlink(testfile);
1227  	if (res == -1) {
1228  		PERROR("unlink");
1229  		return -1;
1230  	}
1231  	res = check_nonexist(testfile);
1232  	if (res == -1)
1233  		return -1;
1234  	success();
1235  	return 0;
1236  }
1237  static int test_link(void)
1238  {
1239  	const char *data = testdata;
1240  	int datalen = testdatalen;
1241  	int err = 0;
1242  	int res;
1243  	start_test("link");
1244  	res = create_testfile(testfile, data, datalen);
1245  	if (res == -1)
1246  		return -1;
1247  	unlink(testfile2);
1248  	res = link(testfile, testfile2);
1249  	if (res == -1) {
1250  		PERROR("link");
1251  		return -1;
1252  	}
1253  	res = check_type(testfile2, S_IFREG);
1254  	if (res == -1)
1255  		return -1;
1256  	err += check_mode(testfile2, 0644);
1257  	err += check_nlink(testfile2, 2);
1258  	err += check_size(testfile2, datalen);
1259  	err += check_data(testfile2, data, 0, datalen);
1260  	res = unlink(testfile);
1261  	if (res == -1) {
1262  		PERROR("unlink");
1263  		return -1;
1264  	}
1265  	res = check_nonexist(testfile);
1266  	if (res == -1)
1267  		return -1;
1268  	err += check_nlink(testfile2, 1);
1269  	res = unlink(testfile2);
1270  	if (res == -1) {
1271  		PERROR("unlink");
1272  		return -1;
1273  	}
1274  	res = check_nonexist(testfile2);
1275  	if (res == -1)
1276  		return -1;
1277  	if (err)
1278  		return -1;
1279  	success();
1280  	return 0;
1281  }
1282  static int test_link2(void)
1283  {
1284  	const char *data = testdata;
1285  	int datalen = testdatalen;
1286  	int err = 0;
1287  	int res;
1288  	start_test("link-unlink-link");
1289  	res = create_testfile(testfile, data, datalen);
1290  	if (res == -1)
1291  		return -1;
1292  	unlink(testfile2);
1293  	res = link(testfile, testfile2);
1294  	if (res == -1) {
1295  		PERROR("link");
1296  		return -1;
1297  	}
1298  	res = unlink(testfile);
1299  	if (res == -1) {
1300  		PERROR("unlink");
1301  		return -1;
1302  	}
1303  	res = check_nonexist(testfile);
1304  	if (res == -1)
1305  		return -1;
1306  	res = link(testfile2, testfile);
1307  	if (res == -1) {
1308  		PERROR("link");
1309  	}
1310  	res = check_type(testfile, S_IFREG);
1311  	if (res == -1)
1312  		return -1;
1313  	err += check_mode(testfile, 0644);
1314  	err += check_nlink(testfile, 2);
1315  	err += check_size(testfile, datalen);
1316  	err += check_data(testfile, data, 0, datalen);
1317  	res = unlink(testfile2);
1318  	if (res == -1) {
1319  		PERROR("unlink");
1320  		return -1;
1321  	}
1322  	err += check_nlink(testfile, 1);
1323  	res = unlink(testfile);
1324  	if (res == -1) {
1325  		PERROR("unlink");
1326  		return -1;
1327  	}
1328  	res = check_nonexist(testfile);
1329  	if (res == -1)
1330  		return -1;
1331  	if (err)
1332  		return -1;
1333  	success();
1334  	return 0;
1335  }
1336  static int test_rename_file(void)
1337  {
1338  	const char *data = testdata;
1339  	int datalen = testdatalen;
1340  	int err = 0;
1341  	int res;
1342  	start_test("rename file");
1343  	res = create_testfile(testfile, data, datalen);
1344  	if (res == -1)
1345  		return -1;
1346  	unlink(testfile2);
1347  	res = rename(testfile, testfile2);
1348  	if (res == -1) {
1349  		PERROR("rename");
1350  		return -1;
1351  	}
1352  	res = check_nonexist(testfile);
1353  	if (res == -1)
1354  		return -1;
1355  	res = check_type(testfile2, S_IFREG);
1356  	if (res == -1)
1357  		return -1;
1358  	err += check_mode(testfile2, 0644);
1359  	err += check_nlink(testfile2, 1);
1360  	err += check_size(testfile2, datalen);
1361  	err += check_data(testfile2, data, 0, datalen);
1362  	res = unlink(testfile2);
1363  	if (res == -1) {
1364  		PERROR("unlink");
1365  		return -1;
1366  	}
1367  	res = check_nonexist(testfile2);
1368  	if (res == -1)
1369  		return -1;
1370  	if (err)
1371  		return -1;
1372  	success();
1373  	return 0;
1374  }
1375  static int test_rename_dir(void)
1376  {
1377  	int err = 0;
1378  	int res;
1379  	start_test("rename dir");
1380  	res = create_dir(testdir, testdir_files);
1381  	if (res == -1)
1382  		return -1;
1383  	rmdir(testdir2);
1384  	res = rename(testdir, testdir2);
1385  	if (res == -1) {
1386  		PERROR("rename");
1387  		cleanup_dir(testdir, testdir_files, 1);
1388  		return -1;
1389  	}
1390  	res = check_nonexist(testdir);
1391  	if (res == -1) {
1392  		cleanup_dir(testdir, testdir_files, 1);
1393  		return -1;
1394  	}
1395  	res = check_type(testdir2, S_IFDIR);
1396  	if (res == -1) {
1397  		cleanup_dir(testdir2, testdir_files, 1);
1398  		return -1;
1399  	}
1400  	err += check_mode(testdir2, 0755);
1401  	err += check_dir_contents(testdir2, testdir_files);
1402  	err += cleanup_dir(testdir2, testdir_files, 0);
1403  	res = rmdir(testdir2);
1404  	if (res == -1) {
1405  		PERROR("rmdir");
1406  		return -1;
1407  	}
1408  	res = check_nonexist(testdir2);
1409  	if (res == -1)
1410  		return -1;
1411  	if (err)
1412  		return -1;
1413  	success();
1414  	return 0;
1415  }
1416  static int test_rename_dir_loop(void)
1417  {
1418  #define PATH(p)		(snprintf(path, sizeof path, "%s/%s", testdir, p), path)
1419  #define PATH2(p)	(snprintf(path2, sizeof path2, "%s/%s", testdir, p), path2)
1420  	char path[1280], path2[1280];
1421  	int err = 0;
1422  	int res;
1423  	start_test("rename dir loop");
1424  	res = create_dir(testdir, testdir_files);
1425  	if (res == -1)
1426  		return -1;
1427  	res = mkdir(PATH("a"), 0755);
1428  	if (res == -1) {
1429  		PERROR("mkdir");
1430  		goto fail;
1431  	}
1432  	res = rename(PATH("a"), PATH2("a"));
1433  	if (res == -1) {
1434  		PERROR("rename");
1435  		goto fail;
1436  	}
1437  	errno = 0;
1438  	res = rename(PATH("a"), PATH2("a/b"));
1439  	if (res == 0 || errno != EINVAL) {
1440  		PERROR("rename");
1441  		goto fail;
1442  	}
1443  	res = mkdir(PATH("a/b"), 0755);
1444  	if (res == -1) {
1445  		PERROR("mkdir");
1446  		goto fail;
1447  	}
1448  	res = mkdir(PATH("a/b/c"), 0755);
1449  	if (res == -1) {
1450  		PERROR("mkdir");
1451  		goto fail;
1452  	}
1453  	errno = 0;
1454  	res = rename(PATH("a"), PATH2("a/b/c"));
1455  	if (res == 0 || errno != EINVAL) {
1456  		PERROR("rename");
1457  		goto fail;
1458  	}
1459  	errno = 0;
1460  	res = rename(PATH("a"), PATH2("a/b/c/a"));
1461  	if (res == 0 || errno != EINVAL) {
1462  		PERROR("rename");
1463  		goto fail;
1464  	}
1465  	errno = 0;
1466  	res = rename(PATH("a/b/c"), PATH2("a"));
1467  	if (res == 0 || errno != ENOTEMPTY) {
1468  		PERROR("rename");
1469  		goto fail;
1470  	}
1471  	res = open(PATH("a/foo"), O_CREAT, 0644);
1472  	if (res == -1) {
1473  		PERROR("open");
1474  		goto fail;
1475  	}
1476  	close(res);
1477  	res = rename(PATH("a/foo"), PATH2("a/bar"));
1478  	if (res == -1) {
1479  		PERROR("rename");
1480  		goto fail;
1481  	}
1482  	res = rename(PATH("a/bar"), PATH2("a/foo"));
1483  	if (res == -1) {
1484  		PERROR("rename");
1485  		goto fail;
1486  	}
1487  	res = rename(PATH("a/foo"), PATH2("a/b/bar"));
1488  	if (res == -1) {
1489  		PERROR("rename");
1490  		goto fail;
1491  	}
1492  	res = rename(PATH("a/b/bar"), PATH2("a/foo"));
1493  	if (res == -1) {
1494  		PERROR("rename");
1495  		goto fail;
1496  	}
1497  	res = rename(PATH("a/foo"), PATH2("a/b/c/bar"));
1498  	if (res == -1) {
1499  		PERROR("rename");
1500  		goto fail;
1501  	}
1502  	res = rename(PATH("a/b/c/bar"), PATH2("a/foo"));
1503  	if (res == -1) {
1504  		PERROR("rename");
1505  		goto fail;
1506  	}
1507  	res = open(PATH("a/bar"), O_CREAT, 0644);
1508  	if (res == -1) {
1509  		PERROR("open");
1510  		goto fail;
1511  	}
1512  	close(res);
1513  	res = rename(PATH("a/foo"), PATH2("a/bar"));
1514  	if (res == -1) {
1515  		PERROR("rename");
1516  		goto fail;
1517  	}
1518  	unlink(PATH("a/bar"));
1519  	res = rename(PATH("a/b"), PATH2("a/d"));
1520  	if (res == -1) {
1521  		PERROR("rename");
1522  		goto fail;
1523  	}
1524  	res = rename(PATH("a/d"), PATH2("a/b"));
1525  	if (res == -1) {
1526  		PERROR("rename");
1527  		goto fail;
1528  	}
1529  	res = mkdir(PATH("a/d"), 0755);
1530  	if (res == -1) {
1531  		PERROR("mkdir");
1532  		goto fail;
1533  	}
1534  	res = rename(PATH("a/b"), PATH2("a/d"));
1535  	if (res == -1) {
1536  		PERROR("rename");
1537  		goto fail;
1538  	}
1539  	res = rename(PATH("a/d"), PATH2("a/b"));
1540  	if (res == -1) {
1541  		PERROR("rename");
1542  		goto fail;
1543  	}
1544  	res = mkdir(PATH("a/d"), 0755);
1545  	if (res == -1) {
1546  		PERROR("mkdir");
1547  		goto fail;
1548  	}
1549  	res = mkdir(PATH("a/d/e"), 0755);
1550  	if (res == -1) {
1551  		PERROR("mkdir");
1552  		goto fail;
1553  	}
1554  	errno = 0;
1555  	res = rename(PATH("a/b"), PATH2("a/d"));
1556  	if (res == 0 || (errno != ENOTEMPTY && errno != EEXIST)) {
1557  		PERROR("rename");
1558  		goto fail;
1559  	}
1560  	rmdir(PATH("a/d/e"));
1561  	rmdir(PATH("a/d"));
1562   	rmdir(PATH("a/b/c"));
1563  	rmdir(PATH("a/b"));
1564  	rmdir(PATH("a"));
1565  	err += cleanup_dir(testdir, testdir_files, 0);
1566  	res = rmdir(testdir);
1567  	if (res == -1) {
1568  		PERROR("rmdir");
1569  		goto fail;
1570  	}
1571  	res = check_nonexist(testdir);
1572  	if (res == -1)
1573  		return -1;
1574  	if (err)
1575  		return -1;
1576  	success();
1577  	return 0;
1578  fail:
1579  	unlink(PATH("a/bar"));
1580  	rmdir(PATH("a/d/e"));
1581  	rmdir(PATH("a/d"));
1582   	rmdir(PATH("a/b/c"));
1583  	rmdir(PATH("a/b"));
1584  	rmdir(PATH("a"));
1585  	cleanup_dir(testdir, testdir_files, 1);
1586  	rmdir(testdir);
1587  	return -1;
1588  #undef PATH2
1589  #undef PATH
1590  }
1591  #ifndef __FreeBSD__
1592  static int test_mkfifo(void)
1593  {
1594  	int res;
1595  	int err = 0;
1596  	start_test("mkfifo");
1597  	unlink(testfile);
1598  	res = mkfifo(testfile, 0644);
1599  	if (res == -1) {
1600  		PERROR("mkfifo");
1601  		return -1;
1602  	}
1603  	res = check_type(testfile, S_IFIFO);
1604  	if (res == -1)
1605  		return -1;
1606  	err += check_mode(testfile, 0644);
1607  	err += check_nlink(testfile, 1);
1608  	res = unlink(testfile);
1609  	if (res == -1) {
1610  		PERROR("unlink");
1611  		return -1;
1612  	}
1613  	res = check_nonexist(testfile);
1614  	if (res == -1)
1615  		return -1;
1616  	if (err)
1617  		return -1;
1618  	success();
1619  	return 0;
1620  }
1621  #endif
1622  static int test_mkdir(void)
1623  {
1624  	int res;
1625  	int err = 0;
1626  	const char *dir_contents[] = {NULL};
1627  	start_test("mkdir");
1628  	rmdir(testdir);
1629  	res = mkdir(testdir, 0755);
1630  	if (res == -1) {
1631  		PERROR("mkdir");
1632  		return -1;
1633  	}
1634  	res = check_type(testdir, S_IFDIR);
1635  	if (res == -1)
1636  		return -1;
1637  	err += check_mode(testdir, 0755);
1638  	err += check_dir_contents(testdir, dir_contents);
1639  	res = rmdir(testdir);
1640  	if (res == -1) {
1641  		PERROR("rmdir");
1642  		return -1;
1643  	}
1644  	res = check_nonexist(testdir);
1645  	if (res == -1)
1646  		return -1;
1647  	if (err)
1648  		return -1;
1649  	success();
1650  	return 0;
1651  }
1652  static int test_socket(void)
1653  {
1654  	struct sockaddr_un su;
1655  	int fd;
1656  	int res;
1657  	int err = 0;
1658      const size_t test_sock_len = strlen(testsock) + 1;
1659  	start_test("socket");
1660  	if (test_sock_len > sizeof(su.sun_path)) {
1661  		fprintf(stderr, "Need to shorten mount point by %zu chars\n",
1662  			strlen(testsock) + 1 - sizeof(su.sun_path));
1663  		return -1;
1664  	}
1665  	unlink(testsock);
1666  	fd = socket(AF_UNIX, SOCK_STREAM, 0);
1667  	if (fd < 0) {
1668  		PERROR("socket");
1669  		return -1;
1670  	}
1671  	su.sun_family = AF_UNIX;
1672  	strncpy(su.sun_path, testsock, test_sock_len);
1673  	su.sun_path[sizeof(su.sun_path) - 1] = '\0';
1674  	res = bind(fd, (struct sockaddr*)&su, sizeof(su));
1675  	if (res == -1) {
1676  		PERROR("bind");
1677  		return -1;
1678  	}
1679  	res = check_type(testsock, S_IFSOCK);
1680  	if (res == -1) {
1681  		close(fd);
1682  		return -1;
1683  	}
1684  	err += check_nlink(testsock, 1);
1685  	close(fd);
1686  	res = unlink(testsock);
1687  	if (res == -1) {
1688  		PERROR("unlink");
1689  		return -1;
1690  	}
1691  	res = check_nonexist(testsock);
1692  	if (res == -1)
1693  		return -1;
1694  	if (err)
1695  		return -1;
1696  	success();
1697  	return 0;
1698  }
1699  #define test_create_ro_dir(flags)	 \
1700  	do_test_create_ro_dir(flags, #flags)
1701  static int do_test_create_ro_dir(int flags, const char *flags_str)
1702  {
1703  	int res;
1704  	int err = 0;
1705  	int fd;
1706  	start_test("open(%s) in read-only directory", flags_str);
1707  	rmdir(testdir);
1708  	res = mkdir(testdir, 0555);
1709  	if (res == -1) {
1710  		PERROR("mkdir");
1711  		return -1;
1712  	}
1713  	fd = open(subfile, flags, 0644);
1714  	if (fd != -1) {
1715  		close(fd);
1716  		unlink(subfile);
1717  		ERROR("open should have failed");
1718  		err--;
1719  	} else {
1720  		res = check_nonexist(subfile);
1721  		if (res == -1)
1722  			err--;
1723  	}
1724  	unlink(subfile);
1725  	res = rmdir(testdir);
1726  	if (res == -1) {
1727  		PERROR("rmdir");
1728  		return -1;
1729  	}
1730  	res = check_nonexist(testdir);
1731  	if (res == -1)
1732  		return -1;
1733  	if (err)
1734  		return -1;
1735  	success();
1736  	return 0;
1737  }
1738  int main(int argc, char *argv[])
1739  {
1740  	int err = 0;
1741  	int a;
1742  	int is_root;
1743  	umask(0);
1744  	if (argc < 2 || argc > 4) {
1745  		fprintf(stderr, "usage: %s testdir [:realdir] [[-]test#] [-u]\n", argv[0]);
1746  		return 1;
1747  	}
1748  	basepath = argv[1];
1749  	basepath_r = basepath;
1750  	for (a = 2; a < argc; a++) {
1751  		char *endptr;
1752  		char *arg = argv[a];
1753  		if (arg[0] == ':') {
1754  			basepath_r = arg + 1;
1755  		} else {
1756  			if (arg[0] == '-') {
1757  				arg++;
1758  				if (arg[0] == 'u') {
1759  					unlinked_test = 1;
1760  					endptr = arg + 1;
1761  				} else {
1762  					skip_test = strtoul(arg, &endptr, 10);
1763  				}
1764  			} else {
1765  				select_test = strtoul(arg, &endptr, 10);
1766  			}
1767  			if (arg[0] == '\0' || *endptr != '\0') {
1768  				fprintf(stderr, "invalid option: '%s'\n", argv[a]);
1769  				return 1;
1770  			}
1771  		}
1772  	}
1773  	assert(strlen(basepath) < 512);
1774  	assert(strlen(basepath_r) < 512);
1775  	if (basepath[0] != '/') {
1776  		fprintf(stderr, "testdir must be an absolute path\n");
1777  		return 1;
1778  	}
1779  	sprintf(testfile, "%s/testfile", basepath);
1780  	sprintf(testfile2, "%s/testfile2", basepath);
1781  	sprintf(testdir, "%s/testdir", basepath);
1782  	sprintf(testdir2, "%s/testdir2", basepath);
1783  	sprintf(subfile, "%s/subfile", testdir2);
1784  	sprintf(testsock, "%s/testsock", basepath);
1785  	sprintf(testfile_r, "%s/testfile", basepath_r);
1786  	sprintf(testfile2_r, "%s/testfile2", basepath_r);
1787  	sprintf(testdir_r, "%s/testdir", basepath_r);
1788  	sprintf(testdir2_r, "%s/testdir2", basepath_r);
1789  	sprintf(subfile_r, "%s/subfile", testdir2_r);
1790  	is_root = (geteuid() == 0);
1791  	err += test_create();
1792  	err += test_create_unlink();
1793  	err += test_symlink();
1794  	err += test_link();
1795  	err += test_link2();
1796  #ifndef __FreeBSD__	
1797  	err += test_mknod();
1798  	err += test_mkfifo();
1799  #endif
1800  	err += test_mkdir();
1801  	err += test_rename_file();
1802  	err += test_rename_dir();
1803  	err += test_rename_dir_loop();
1804  	err += test_seekdir();
1805  	err += test_socket();
1806  	err += test_utime();
1807  	err += test_truncate(0);
1808  	err += test_truncate(testdatalen / 2);
1809  	err += test_truncate(testdatalen);
1810  	err += test_truncate(testdatalen + 100);
1811  	err += test_ftruncate(0, 0600);
1812  	err += test_ftruncate(testdatalen / 2, 0600);
1813  	err += test_ftruncate(testdatalen, 0600);
1814  	err += test_ftruncate(testdatalen + 100, 0600);
1815  	err += test_ftruncate(0, 0400);
1816  	err += test_ftruncate(0, 0200);
1817  	err += test_ftruncate(0, 0000);
1818  	err += test_open(0, O_RDONLY, 0);
1819  	err += test_open(1, O_RDONLY, 0);
1820  	err += test_open(1, O_RDWR, 0);
1821  	err += test_open(1, O_WRONLY, 0);
1822  	err += test_open(0, O_RDWR | O_CREAT, 0600);
1823  	err += test_open(1, O_RDWR | O_CREAT, 0600);
1824  	err += test_open(0, O_RDWR | O_CREAT | O_TRUNC, 0600);
1825  	err += test_open(1, O_RDWR | O_CREAT | O_TRUNC, 0600);
1826  	err += test_open(0, O_RDONLY | O_CREAT, 0600);
1827  	err += test_open(0, O_RDONLY | O_CREAT, 0400);
1828  	err += test_open(0, O_RDONLY | O_CREAT, 0200);
1829  	err += test_open(0, O_RDONLY | O_CREAT, 0000);
1830  	err += test_open(0, O_WRONLY | O_CREAT, 0600);
1831  	err += test_open(0, O_WRONLY | O_CREAT, 0400);
1832  	err += test_open(0, O_WRONLY | O_CREAT, 0200);
1833  	err += test_open(0, O_WRONLY | O_CREAT, 0000);
1834  	err += test_open(0, O_RDWR | O_CREAT, 0400);
1835  	err += test_open(0, O_RDWR | O_CREAT, 0200);
1836  	err += test_open(0, O_RDWR | O_CREAT, 0000);
1837  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0600);
1838  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0600);
1839  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0000);
1840  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0000);
1841  	err += test_open_acc(O_RDONLY, 0600, 0);
1842  	err += test_open_acc(O_WRONLY, 0600, 0);
1843  	err += test_open_acc(O_RDWR,   0600, 0);
1844  	err += test_open_acc(O_RDONLY, 0400, 0);
1845  	err += test_open_acc(O_WRONLY, 0200, 0);
1846  	if(!is_root) {
1847  		err += test_open_acc(O_RDONLY | O_TRUNC, 0400, EACCES);
1848  		err += test_open_acc(O_WRONLY, 0400, EACCES);
1849  		err += test_open_acc(O_RDWR,   0400, EACCES);
1850  		err += test_open_acc(O_RDONLY, 0200, EACCES);
1851  		err += test_open_acc(O_RDWR,   0200, EACCES);
1852  		err += test_open_acc(O_RDONLY, 0000, EACCES);
1853  		err += test_open_acc(O_WRONLY, 0000, EACCES);
1854  		err += test_open_acc(O_RDWR,   0000, EACCES);
1855  	}
1856  	err += test_create_ro_dir(O_CREAT);
1857  	err += test_create_ro_dir(O_CREAT | O_EXCL);
1858  	err += test_create_ro_dir(O_CREAT | O_WRONLY);
1859  	err += test_create_ro_dir(O_CREAT | O_TRUNC);
1860  	err += test_copy_file_range();
1861  	unlink(testfile2);
1862  	unlink(testsock);
1863  	rmdir(testdir);
1864  	rmdir(testdir2);
1865  	if (err) {
1866  		fprintf(stderr, "%i tests failed\n", -err);
1867  		return 1;
1868  	}
1869  	return check_unlinked_testfiles();
1870  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</div>
                </div>
                <div class="column column_space"><pre><code>218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
</pre></code></div>
                <div class="column column_space"><pre><code>692  	if (dp == NULL) {
693  		PERROR("opendir");
694  		return -1;
695  	}
696  	for (i = 0; i < ARRAY_SIZE(seekdir_offsets); i++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    