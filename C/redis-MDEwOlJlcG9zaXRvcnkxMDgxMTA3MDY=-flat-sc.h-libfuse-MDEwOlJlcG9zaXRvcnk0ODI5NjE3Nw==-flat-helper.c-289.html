
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_SC_H
2  #define JEMALLOC_INTERNAL_SC_H
3  #include &quot;jemalloc/internal/jemalloc_internal_types.h&quot;
4  #define SC_LG_NGROUP 2
5  #define SC_LG_TINY_MIN 3
6  #if SC_LG_TINY_MIN == 0
7  #error &quot;Unsupported LG_TINY_MIN&quot;
8  #endif
9  #define SC_NGROUP (1ULL &lt;&lt; SC_LG_NGROUP)
10  #define SC_PTR_BITS ((1ULL &lt;&lt; LG_SIZEOF_PTR) * 8)
11  #define SC_NTINY (LG_QUANTUM - SC_LG_TINY_MIN)
12  #define SC_LG_TINY_MAXCLASS (LG_QUANTUM &gt; SC_LG_TINY_MIN ? LG_QUANTUM - 1 : -1)
13  #define SC_NPSEUDO SC_NGROUP
14  #define SC_LG_FIRST_REGULAR_BASE (LG_QUANTUM + SC_LG_NGROUP)
15  #define SC_LG_BASE_MAX (SC_PTR_BITS - 2)
16  #define SC_NREGULAR (SC_NGROUP * 					\
17      (SC_LG_BASE_MAX - SC_LG_FIRST_REGULAR_BASE + 1) - 1)
18  #define SC_NSIZES (SC_NTINY + SC_NPSEUDO + SC_NREGULAR)
19  #define SC_NPSIZES (							\
20      				\
21      SC_NSIZES								\
22      		\
23      - (LG_PAGE - 1 - SC_LG_FIRST_REGULAR_BASE) * SC_NGROUP		\
24      						\
25      - SC_NPSEUDO							\
26      						\
27      - SC_NTINY								\
28      	\
29      - (SC_LG_NGROUP * SC_NGROUP))
30  #define SC_NBINS (							\
31      					\
32      SC_NTINY + SC_NPSEUDO						\
33      	\
34      + SC_NGROUP * (LG_PAGE + SC_LG_NGROUP - SC_LG_FIRST_REGULAR_BASE)	\
35      	\
36      - 1)
37  #if (SC_NBINS &gt; 256)
38  #  error &quot;Too many small size classes&quot;
39  #endif
40  #define SC_LOOKUP_MAXCLASS ((size_t)1 &lt;&lt; 12)
41  #define SC_SMALL_MAX_BASE ((size_t)1 &lt;&lt; (LG_PAGE + SC_LG_NGROUP - 1))
42  #define SC_SMALL_MAX_DELTA ((size_t)1 &lt;&lt; (LG_PAGE - 1))
43  #define SC_SMALL_MAXCLASS (SC_SMALL_MAX_BASE				\
44      + (SC_NGROUP - 1) * SC_SMALL_MAX_DELTA)
45  #define SC_LARGE_MINCLASS ((size_t)1ULL &lt;&lt; (LG_PAGE + SC_LG_NGROUP))
46  #define SC_LG_LARGE_MINCLASS (LG_PAGE + SC_LG_NGROUP)
47  #define SC_MAX_BASE ((size_t)1 &lt;&lt; (SC_PTR_BITS - 2))
48  #define SC_MAX_DELTA ((size_t)1 &lt;&lt; (SC_PTR_BITS - 2 - SC_LG_NGROUP))
49  #define SC_LARGE_MAXCLASS (SC_MAX_BASE + (SC_NGROUP - 1) * SC_MAX_DELTA)
50  typedef struct sc_s sc_t;
51  struct sc_s {
52  	int index;
53  	int lg_base;
54  	int lg_delta;
55  	int ndelta;
56  	bool psz;
57  	bool bin;
58  	int pgs;
59  	int lg_delta_lookup;
60  };
61  typedef struct sc_data_s sc_data_t;
62  struct sc_data_s {
<span onclick='openModal()' class='match'>63  	unsigned ntiny;
64  	int nlbins;
65  	int nbins;
66  	int nsizes;
67  	int lg_ceil_nsizes;
68  	unsigned npsizes;
</span>69  	int lg_tiny_maxclass;
70  	size_t lookup_maxclass;
71  	size_t small_maxclass;
72  	int lg_large_minclass;
73  	size_t large_minclass;
74  	size_t large_maxclass;
75  	bool initialized;
76  	sc_t sc[SC_NSIZES];
77  };
78  void sc_data_init(sc_data_t *data);
79  void sc_data_update_slab_size(sc_data_t *data, size_t begin, size_t end,
80      int pgs);
81  void sc_boot(sc_data_t *data);
82  #endif &amp;bsol;* JEMALLOC_INTERNAL_SC_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</h3>
            <pre><code>1  #include &quot;fuse_config.h&quot;
2  #include &quot;fuse_i.h&quot;
3  #include &quot;fuse_misc.h&quot;
4  #include &quot;fuse_opt.h&quot;
5  #include &quot;fuse_lowlevel.h&quot;
6  #include &quot;mount_util.h&quot;
7  #include &lt;stdio.h&gt;
8  #include &lt;stdlib.h&gt;
9  #include &lt;stddef.h&gt;
10  #include &lt;unistd.h&gt;
11  #include &lt;string.h&gt;
12  #include &lt;limits.h&gt;
13  #include &lt;errno.h&gt;
14  #include &lt;sys/param.h&gt;
15  #define FUSE_HELPER_OPT(t, p) \
16  	{ t, offsetof(struct fuse_cmdline_opts, p), 1 }
17  static const struct fuse_opt fuse_helper_opts[] = {
18  	FUSE_HELPER_OPT(&quot;-h&quot;,		show_help),
19  	FUSE_HELPER_OPT(&quot;--help&quot;,	show_help),
20  	FUSE_HELPER_OPT(&quot;-V&quot;,		show_version),
21  	FUSE_HELPER_OPT(&quot;--version&quot;,	show_version),
22  	FUSE_HELPER_OPT(&quot;-d&quot;,		debug),
23  	FUSE_HELPER_OPT(&quot;debug&quot;,	debug),
24  	FUSE_HELPER_OPT(&quot;-d&quot;,		foreground),
25  	FUSE_HELPER_OPT(&quot;debug&quot;,	foreground),
26  	FUSE_OPT_KEY(&quot;-d&quot;,		FUSE_OPT_KEY_KEEP),
27  	FUSE_OPT_KEY(&quot;debug&quot;,		FUSE_OPT_KEY_KEEP),
28  	FUSE_HELPER_OPT(&quot;-f&quot;,		foreground),
29  	FUSE_HELPER_OPT(&quot;-s&quot;,		singlethread),
30  	FUSE_HELPER_OPT(&quot;fsname=&quot;,	nodefault_subtype),
31  	FUSE_OPT_KEY(&quot;fsname=&quot;,		FUSE_OPT_KEY_KEEP),
32  #ifndef __FreeBSD__
33  	FUSE_HELPER_OPT(&quot;subtype=&quot;,	nodefault_subtype),
34  	FUSE_OPT_KEY(&quot;subtype=&quot;,	FUSE_OPT_KEY_KEEP),
35  #endif
36  	FUSE_HELPER_OPT(&quot;clone_fd&quot;,	clone_fd),
37  	FUSE_HELPER_OPT(&quot;max_idle_threads=%u&quot;, max_idle_threads),
38  	FUSE_HELPER_OPT(&quot;max_threads=%u&quot;, max_threads),
39  	FUSE_OPT_END
40  };
41  struct fuse_conn_info_opts {
42  	int atomic_o_trunc;
43  	int no_remote_posix_lock;
44  	int no_remote_flock;
45  	int splice_write;
46  	int splice_move;
47  	int splice_read;
48  	int no_splice_write;
49  	int no_splice_move;
50  	int no_splice_read;
51  	int auto_inval_data;
52  	int no_auto_inval_data;
53  	int no_readdirplus;
54  	int no_readdirplus_auto;
55  	int async_dio;
56  	int no_async_dio;
57  	int writeback_cache;
58  	int no_writeback_cache;
59  	int async_read;
60  	int sync_read;
61  	unsigned max_write;
62  	unsigned max_readahead;
63  	unsigned max_background;
64  	unsigned congestion_threshold;
<span onclick='openModal()' class='match'>65  	unsigned time_gran;
66  	int set_max_write;
67  	int set_max_readahead;
68  	int set_max_background;
69  	int set_congestion_threshold;
70  	int set_time_gran;
</span>71  };
72  #define CONN_OPTION(t, p, v)					\
73  	{ t, offsetof(struct fuse_conn_info_opts, p), v }
74  static const struct fuse_opt conn_info_opt_spec[] = {
75  	CONN_OPTION(&quot;max_write=%u&quot;, max_write, 0),
76  	CONN_OPTION(&quot;max_write=&quot;, set_max_write, 1),
77  	CONN_OPTION(&quot;max_readahead=%u&quot;, max_readahead, 0),
78  	CONN_OPTION(&quot;max_readahead=&quot;, set_max_readahead, 1),
79  	CONN_OPTION(&quot;max_background=%u&quot;, max_background, 0),
80  	CONN_OPTION(&quot;max_background=&quot;, set_max_background, 1),
81  	CONN_OPTION(&quot;congestion_threshold=%u&quot;, congestion_threshold, 0),
82  	CONN_OPTION(&quot;congestion_threshold=&quot;, set_congestion_threshold, 1),
83  	CONN_OPTION(&quot;sync_read&quot;, sync_read, 1),
84  	CONN_OPTION(&quot;async_read&quot;, async_read, 1),
85  	CONN_OPTION(&quot;atomic_o_trunc&quot;, atomic_o_trunc, 1),
86  	CONN_OPTION(&quot;no_remote_lock&quot;, no_remote_posix_lock, 1),
87  	CONN_OPTION(&quot;no_remote_lock&quot;, no_remote_flock, 1),
88  	CONN_OPTION(&quot;no_remote_flock&quot;, no_remote_flock, 1),
89  	CONN_OPTION(&quot;no_remote_posix_lock&quot;, no_remote_posix_lock, 1),
90  	CONN_OPTION(&quot;splice_write&quot;, splice_write, 1),
91  	CONN_OPTION(&quot;no_splice_write&quot;, no_splice_write, 1),
92  	CONN_OPTION(&quot;splice_move&quot;, splice_move, 1),
93  	CONN_OPTION(&quot;no_splice_move&quot;, no_splice_move, 1),
94  	CONN_OPTION(&quot;splice_read&quot;, splice_read, 1),
95  	CONN_OPTION(&quot;no_splice_read&quot;, no_splice_read, 1),
96  	CONN_OPTION(&quot;auto_inval_data&quot;, auto_inval_data, 1),
97  	CONN_OPTION(&quot;no_auto_inval_data&quot;, no_auto_inval_data, 1),
98  	CONN_OPTION(&quot;readdirplus=no&quot;, no_readdirplus, 1),
99  	CONN_OPTION(&quot;readdirplus=yes&quot;, no_readdirplus, 0),
100  	CONN_OPTION(&quot;readdirplus=yes&quot;, no_readdirplus_auto, 1),
101  	CONN_OPTION(&quot;readdirplus=auto&quot;, no_readdirplus, 0),
102  	CONN_OPTION(&quot;readdirplus=auto&quot;, no_readdirplus_auto, 0),
103  	CONN_OPTION(&quot;async_dio&quot;, async_dio, 1),
104  	CONN_OPTION(&quot;no_async_dio&quot;, no_async_dio, 1),
105  	CONN_OPTION(&quot;writeback_cache&quot;, writeback_cache, 1),
106  	CONN_OPTION(&quot;no_writeback_cache&quot;, no_writeback_cache, 1),
107  	CONN_OPTION(&quot;time_gran=%u&quot;, time_gran, 0),
108  	CONN_OPTION(&quot;time_gran=&quot;, set_time_gran, 1),
109  	FUSE_OPT_END
110  };
111  void fuse_cmdline_help(void)
112  {
113  	printf(&quot;    -h   --help            print help\n&quot;
114  	       &quot;    -V   --version         print version\n&quot;
115  	       &quot;    -d   -o debug          enable debug output (implies -f)\n&quot;
116  	       &quot;    -f                     foreground operation\n&quot;
117  	       &quot;    -s                     disable multi-threaded operation\n&quot;
118  	       &quot;    -o clone_fd            use separate fuse device fd for each thread\n&quot;
119  	       &quot;                           (may improve performance)\n&quot;
120  	       &quot;    -o max_idle_threads    the maximum number of idle worker threads\n&quot;
121  	       &quot;                           allowed (default: -1)\n&quot;
122  	       &quot;    -o max_threads         the maximum number of worker threads\n&quot;
123  	       &quot;                           allowed (default: 10)\n&quot;);
124  }
125  static int fuse_helper_opt_proc(void *data, const char *arg, int key,
126  				struct fuse_args *outargs)
127  {
128  	(void) outargs;
129  	struct fuse_cmdline_opts *opts = data;
130  	switch (key) {
131  	case FUSE_OPT_KEY_NONOPT:
132  		if (!opts-&gt;mountpoint) {
133  			if (fuse_mnt_parse_fuse_fd(arg) != -1) {
134  				return fuse_opt_add_opt(&amp;opts-&gt;mountpoint, arg);
135  			}
136  			char mountpoint[PATH_MAX] = &quot;&quot;;
137  			if (realpath(arg, mountpoint) == NULL) {
138  				fuse_log(FUSE_LOG_ERR,
139  					&quot;fuse: bad mount point `%s&#x27;: %s\n&quot;,
140  					arg, strerror(errno));
141  				return -1;
142  			}
143  			return fuse_opt_add_opt(&amp;opts-&gt;mountpoint, mountpoint);
144  		} else {
145  			fuse_log(FUSE_LOG_ERR, &quot;fuse: invalid argument `%s&#x27;\n&quot;, arg);
146  			return -1;
147  		}
148  	default:
149  		return 1;
150  	}
151  }
152  static int add_default_subtype(const char *progname, struct fuse_args *args)
153  {
154  	int res;
155  	char *subtype_opt;
156  	const char *basename = strrchr(progname, &#x27;/&#x27;);
157  	if (basename == NULL)
158  		basename = progname;
159  	else if (basename[1] != &#x27;\0&#x27;)
160  		basename++;
161  	subtype_opt = (char *) malloc(strlen(basename) + 64);
162  	if (subtype_opt == NULL) {
163  		fuse_log(FUSE_LOG_ERR, &quot;fuse: memory allocation failed\n&quot;);
164  		return -1;
165  	}
166  #ifdef __FreeBSD__
167  	sprintf(subtype_opt, &quot;-ofsname=%s&quot;, basename);
168  #else
169  	sprintf(subtype_opt, &quot;-osubtype=%s&quot;, basename);
170  #endif
171  	res = fuse_opt_add_arg(args, subtype_opt);
172  	free(subtype_opt);
173  	return res;
174  }
175  int fuse_parse_cmdline_312(struct fuse_args *args,
176  			   struct fuse_cmdline_opts *opts);
177  FUSE_SYMVER(&quot;fuse_parse_cmdline_312&quot;, &quot;fuse_parse_cmdline@@FUSE_3.12&quot;)
178  int fuse_parse_cmdline_312(struct fuse_args *args,
179  			   struct fuse_cmdline_opts *opts)
180  {
181  	memset(opts, 0, sizeof(struct fuse_cmdline_opts));
182  	opts-&gt;max_idle_threads = UINT_MAX; &amp;bsol;* new default in fuse version 3.12 */
183  	opts-&gt;max_threads = 10;
184  	if (fuse_opt_parse(args, opts, fuse_helper_opts,
185  			   fuse_helper_opt_proc) == -1)
186  		return -1;
187  	if (!opts-&gt;nodefault_subtype)
188  		if (add_default_subtype(args-&gt;argv[0], args) == -1)
189  			return -1;
190  	return 0;
191  }
192  int fuse_parse_cmdline_30(struct fuse_args *args,
193  		       struct fuse_cmdline_opts *opts);
194  FUSE_SYMVER(&quot;fuse_parse_cmdline_30&quot;, &quot;fuse_parse_cmdline@FUSE_3.0&quot;)
195  int fuse_parse_cmdline_30(struct fuse_args *args,
196  			  struct fuse_cmdline_opts *out_opts)
197  {
198  	struct fuse_cmdline_opts opts;
199  	int rc = fuse_parse_cmdline_312(args, &amp;opts);
200  	if (rc == 0) {
201  		memcpy(out_opts, &amp;opts,
202  		       offsetof(struct fuse_cmdline_opts, max_idle_threads) +
203  		       sizeof(opts.max_idle_threads));
204  	}
205  	return rc;
206  }
207  int fuse_daemonize(int foreground)
208  {
209  	if (!foreground) {
210  		int nullfd;
211  		int waiter[2];
212  		char completed;
213  		if (pipe(waiter)) {
214  			perror(&quot;fuse_daemonize: pipe&quot;);
215  			return -1;
216  		}
217  		switch(fork()) {
218  		case -1:
219  			perror(&quot;fuse_daemonize: fork&quot;);
220  			return -1;
221  		case 0:
222  			break;
223  		default:
224  			(void) read(waiter[0], &amp;completed, sizeof(completed));
225  			_exit(0);
226  		}
227  		if (setsid() == -1) {
228  			perror(&quot;fuse_daemonize: setsid&quot;);
229  			return -1;
230  		}
231  		(void) chdir(&quot;/&quot;);
232  		nullfd = open(&quot;/dev/null&quot;, O_RDWR, 0);
233  		if (nullfd != -1) {
234  			(void) dup2(nullfd, 0);
235  			(void) dup2(nullfd, 1);
236  			(void) dup2(nullfd, 2);
237  			if (nullfd &gt; 2)
238  				close(nullfd);
239  		}
240  		completed = 1;
241  		(void) write(waiter[1], &amp;completed, sizeof(completed));
242  		close(waiter[0]);
243  		close(waiter[1]);
244  	} else {
245  		(void) chdir(&quot;/&quot;);
246  	}
247  	return 0;
248  }
249  int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
250  		   size_t op_size, void *user_data)
251  {
252  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
253  	struct fuse *fuse;
254  	struct fuse_cmdline_opts opts;
255  	int res;
256  	struct fuse_loop_config *loop_config = NULL;
257  	if (fuse_parse_cmdline(&amp;args, &amp;opts) != 0)
258  		return 1;
259  	if (opts.show_version) {
260  		printf(&quot;FUSE library version %s\n&quot;, PACKAGE_VERSION);
261  		fuse_lowlevel_version();
262  		res = 0;
263  		goto out1;
264  	}
265  	if (opts.show_help) {
266  		if(args.argv[0][0] != &#x27;\0&#x27;)
267  			printf(&quot;usage: %s [options] &lt;mountpoint&gt;\n\n&quot;,
268  			       args.argv[0]);
269  		printf(&quot;FUSE options:\n&quot;);
270  		fuse_cmdline_help();
271  		fuse_lib_help(&amp;args);
272  		res = 0;
273  		goto out1;
274  	}
275  	if (!opts.show_help &amp;&amp;
276  	    !opts.mountpoint) {
277  		fuse_log(FUSE_LOG_ERR, &quot;error: no mountpoint specified\n&quot;);
278  		res = 2;
279  		goto out1;
280  	}
281  	fuse = fuse_new_31(&amp;args, op, op_size, user_data);
282  	if (fuse == NULL) {
283  		res = 3;
284  		goto out1;
285  	}
286  	if (fuse_mount(fuse,opts.mountpoint) != 0) {
287  		res = 4;
288  		goto out2;
289  	}
290  	if (fuse_daemonize(opts.foreground) != 0) {
291  		res = 5;
292  		goto out3;
293  	}
294  	struct fuse_session *se = fuse_get_session(fuse);
295  	if (fuse_set_signal_handlers(se) != 0) {
296  		res = 6;
297  		goto out3;
298  	}
299  	if (opts.singlethread)
300  		res = fuse_loop(fuse);
301  	else {
302  		loop_config = fuse_loop_cfg_create();
303  		if (loop_config == NULL) {
304  			res = 7;
305  			goto out3;
306  		}
307  		fuse_loop_cfg_set_clone_fd(loop_config, opts.clone_fd);
308  		fuse_loop_cfg_set_idle_threads(loop_config, opts.max_idle_threads);
309  		fuse_loop_cfg_set_max_threads(loop_config, opts.max_threads);
310  		res = fuse_loop_mt(fuse, loop_config);
311  	}
312  	if (res)
313  		res = 8;
314  	fuse_remove_signal_handlers(se);
315  out3:
316  	fuse_unmount(fuse);
317  out2:
318  	fuse_destroy(fuse);
319  out1:
320  	fuse_loop_cfg_destroy(loop_config);
321  	free(opts.mountpoint);
322  	fuse_opt_free_args(&amp;args);
323  	return res;
324  }
325  void fuse_apply_conn_info_opts(struct fuse_conn_info_opts *opts,
326  			       struct fuse_conn_info *conn)
327  {
328  	if(opts-&gt;set_max_write)
329  		conn-&gt;max_write = opts-&gt;max_write;
330  	if(opts-&gt;set_max_background)
331  		conn-&gt;max_background = opts-&gt;max_background;
332  	if(opts-&gt;set_congestion_threshold)
333  		conn-&gt;congestion_threshold = opts-&gt;congestion_threshold;
334  	if(opts-&gt;set_time_gran)
335  		conn-&gt;time_gran = opts-&gt;time_gran;
336  	if(opts-&gt;set_max_readahead)
337  		conn-&gt;max_readahead = opts-&gt;max_readahead;
338  #define LL_ENABLE(cond,cap) \
339  	if (cond) conn-&gt;want |= (cap)
340  #define LL_DISABLE(cond,cap) \
341  	if (cond) conn-&gt;want &amp;= ~(cap)
342  	LL_ENABLE(opts-&gt;splice_read, FUSE_CAP_SPLICE_READ);
343  	LL_DISABLE(opts-&gt;no_splice_read, FUSE_CAP_SPLICE_READ);
344  	LL_ENABLE(opts-&gt;splice_write, FUSE_CAP_SPLICE_WRITE);
345  	LL_DISABLE(opts-&gt;no_splice_write, FUSE_CAP_SPLICE_WRITE);
346  	LL_ENABLE(opts-&gt;splice_move, FUSE_CAP_SPLICE_MOVE);
347  	LL_DISABLE(opts-&gt;no_splice_move, FUSE_CAP_SPLICE_MOVE);
348  	LL_ENABLE(opts-&gt;auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
349  	LL_DISABLE(opts-&gt;no_auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
350  	LL_DISABLE(opts-&gt;no_readdirplus, FUSE_CAP_READDIRPLUS);
351  	LL_DISABLE(opts-&gt;no_readdirplus_auto, FUSE_CAP_READDIRPLUS_AUTO);
352  	LL_ENABLE(opts-&gt;async_dio, FUSE_CAP_ASYNC_DIO);
353  	LL_DISABLE(opts-&gt;no_async_dio, FUSE_CAP_ASYNC_DIO);
354  	LL_ENABLE(opts-&gt;writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
355  	LL_DISABLE(opts-&gt;no_writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
356  	LL_ENABLE(opts-&gt;async_read, FUSE_CAP_ASYNC_READ);
357  	LL_DISABLE(opts-&gt;sync_read, FUSE_CAP_ASYNC_READ);
358  	LL_DISABLE(opts-&gt;no_remote_posix_lock, FUSE_CAP_POSIX_LOCKS);
359  	LL_DISABLE(opts-&gt;no_remote_flock, FUSE_CAP_FLOCK_LOCKS);
360  }
361  struct fuse_conn_info_opts* fuse_parse_conn_info_opts(struct fuse_args *args)
362  {
363  	struct fuse_conn_info_opts *opts;
364  	opts = calloc(1, sizeof(struct fuse_conn_info_opts));
365  	if(opts == NULL) {
366  		fuse_log(FUSE_LOG_ERR, &quot;calloc failed\n&quot;);
367  		return NULL;
368  	}
369  	if(fuse_opt_parse(args, opts, conn_info_opt_spec, NULL) == -1) {
370  		free(opts);
371  		return NULL;
372  	}
373  	return opts;
374  }
375  int fuse_open_channel(const char *mountpoint, const char* options)
376  {
377  	struct mount_opts *opts = NULL;
378  	int fd = -1;
379  	const char *argv[] = { &quot;&quot;, &quot;-o&quot;, options };
380  	int argc = sizeof(argv) / sizeof(argv[0]);
381  	struct fuse_args args = FUSE_ARGS_INIT(argc, (char**) argv);
382  	opts = parse_mount_opts(&amp;args);
383  	if (opts == NULL)
384  		return -1;
385  	fd = fuse_kern_mount(mountpoint, opts);
386  	destroy_mount_opts(opts);
387  	return fd;
388  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-sc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</div>
                </div>
                <div class="column column_space"><pre><code>63  	unsigned ntiny;
64  	int nlbins;
65  	int nbins;
66  	int nsizes;
67  	int lg_ceil_nsizes;
68  	unsigned npsizes;
</pre></code></div>
                <div class="column column_space"><pre><code>65  	unsigned time_gran;
66  	int set_max_write;
67  	int set_max_readahead;
68  	int set_max_background;
69  	int set_congestion_threshold;
70  	int set_time_gran;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    