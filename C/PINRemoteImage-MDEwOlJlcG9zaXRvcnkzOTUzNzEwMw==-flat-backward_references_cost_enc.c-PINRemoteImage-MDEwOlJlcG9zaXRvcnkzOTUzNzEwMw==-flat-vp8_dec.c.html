
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.159904534606206%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/backward_references_enc.h"
3  #include "src/enc/histogram_enc.h"
4  #include "src/dsp/lossless_common.h"
5  #include "src/utils/color_cache_utils.h"
6  #include "src/utils/utils.h"
7  #define VALUES_IN_BYTE 256
8  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
9  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
10  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
11                                        const PixOrCopy v);
12  typedef struct {
13    double alpha_[VALUES_IN_BYTE];
14    double red_[VALUES_IN_BYTE];
15    double blue_[VALUES_IN_BYTE];
16    double distance_[NUM_DISTANCE_CODES];
17    double* literal_;
18  } CostModel;
19  static void ConvertPopulationCountTableToBitEstimates(
20      int num_symbols, const uint32_t population_counts[], double output[]) {
21    uint32_t sum = 0;
22    int nonzeros = 0;
23    int i;
24    for (i = 0; i < num_symbols; ++i) {
25      sum += population_counts[i];
26      if (population_counts[i] > 0) {
27        ++nonzeros;
28      }
29    }
30    if (nonzeros <= 1) {
31      memset(output, 0, num_symbols * sizeof(*output));
32    } else {
33      const double logsum = VP8LFastLog2(sum);
34      for (i = 0; i < num_symbols; ++i) {
35        output[i] = logsum - VP8LFastLog2(population_counts[i]);
36      }
37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
42    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
43    VP8LHistogram* const histo = VP8LAllocateHistogram(cache_bits);
44    if (histo == NULL) goto Error;
45    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 1);
46    while (VP8LRefsCursorOk(&c)) {
47      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, VP8LDistanceToPlaneCode,
48                                      xsize);
49      VP8LRefsCursorNext(&c);
50    }
51    ConvertPopulationCountTableToBitEstimates(
52        VP8LHistogramNumCodes(histo->palette_code_bits_),
53        histo->literal_, m->literal_);
54    ConvertPopulationCountTableToBitEstimates(
55        VALUES_IN_BYTE, histo->red_, m->red_);
56    ConvertPopulationCountTableToBitEstimates(
57        VALUES_IN_BYTE, histo->blue_, m->blue_);
58    ConvertPopulationCountTableToBitEstimates(
59        VALUES_IN_BYTE, histo->alpha_, m->alpha_);
60    ConvertPopulationCountTableToBitEstimates(
61        NUM_DISTANCE_CODES, histo->distance_, m->distance_);
62    ok = 1;
63   Error:
64    VP8LFreeHistogram(histo);
65    return ok;
66  }
67  static WEBP_INLINE double GetLiteralCost(const CostModel* const m, uint32_t v) {
68    return m->alpha_[v >> 24] +
69           m->red_[(v >> 16) & 0xff] +
70           m->literal_[(v >> 8) & 0xff] +
71           m->blue_[v & 0xff];
72  }
73  static WEBP_INLINE double GetCacheCost(const CostModel* const m, uint32_t idx) {
74    const int literal_idx = VALUES_IN_BYTE + NUM_LENGTH_CODES + idx;
75    return m->literal_[literal_idx];
76  }
77  static WEBP_INLINE double GetLengthCost(const CostModel* const m,
78                                          uint32_t length) {
79    int code, extra_bits;
80    VP8LPrefixEncodeBits(length, &code, &extra_bits);
81    return m->literal_[VALUES_IN_BYTE + code] + extra_bits;
82  }
83  static WEBP_INLINE double GetDistanceCost(const CostModel* const m,
84                                            uint32_t distance) {
85    int code, extra_bits;
86    VP8LPrefixEncodeBits(distance, &code, &extra_bits);
87    return m->distance_[code] + extra_bits;
88  }
89  static WEBP_INLINE void AddSingleLiteralWithCostModel(
90      const uint32_t* const argb, VP8LColorCache* const hashers,
91      const CostModel* const cost_model, int idx, int use_color_cache,
92      float prev_cost, float* const cost, uint16_t* const dist_array) {
93    double cost_val = prev_cost;
94    const uint32_t color = argb[idx];
95    const int ix = use_color_cache ? VP8LColorCacheContains(hashers, color) : -1;
96    if (ix >= 0) {
97      const double mul0 = 0.68;
98      cost_val += GetCacheCost(cost_model, ix) * mul0;
99    } else {
100      const double mul1 = 0.82;
101      if (use_color_cache) VP8LColorCacheInsert(hashers, color);
102      cost_val += GetLiteralCost(cost_model, color) * mul1;
103    }
104    if (cost[idx] > cost_val) {
105      cost[idx] = (float)cost_val;
106      dist_array[idx] = 1;  
107    }
108  }
109  #define COST_CACHE_INTERVAL_SIZE_MAX 500
110  typedef struct CostInterval CostInterval;
111  struct CostInterval {
112    float cost_;
113    int start_;
114    int end_;
115    int index_;
116    CostInterval* previous_;
117    CostInterval* next_;
118  };
119  typedef struct {
120    double cost_;
121    int start_;
122    int end_;       
123  } CostCacheInterval;
124  #define COST_MANAGER_MAX_FREE_LIST 10
125  typedef struct {
126    CostInterval* head_;
127    int count_;  
128    CostCacheInterval* cache_intervals_;
129    size_t cache_intervals_size_;
130    double cost_cache_[MAX_LENGTH];  
131    float* costs_;
132    uint16_t* dist_array_;
133    CostInterval intervals_[COST_MANAGER_MAX_FREE_LIST];
134    CostInterval* free_intervals_;
135    CostInterval* recycled_intervals_;
136  } CostManager;
137  static void CostIntervalAddToFreeList(CostManager* const manager,
138                                        CostInterval* const interval) {
139    interval->next_ = manager->free_intervals_;
140    manager->free_intervals_ = interval;
141  }
142  static int CostIntervalIsInFreeList(const CostManager* const manager,
143                                      const CostInterval* const interval) {
144    return (interval >= &manager->intervals_[0] &&
145            interval <= &manager->intervals_[COST_MANAGER_MAX_FREE_LIST - 1]);
146  }
147  static void CostManagerInitFreeList(CostManager* const manager) {
148    int i;
149    manager->free_intervals_ = NULL;
150    for (i = 0; i < COST_MANAGER_MAX_FREE_LIST; ++i) {
151      CostIntervalAddToFreeList(manager, &manager->intervals_[i]);
152    }
153  }
154  static void DeleteIntervalList(CostManager* const manager,
155                                 const CostInterval* interval) {
156    while (interval != NULL) {
157      const CostInterval* const next = interval->next_;
158      if (!CostIntervalIsInFreeList(manager, interval)) {
159        WebPSafeFree((void*)interval);
160      }  
161      interval = next;
162    }
163  }
164  static void CostManagerClear(CostManager* const manager) {
165    if (manager == NULL) return;
166    WebPSafeFree(manager->costs_);
167    WebPSafeFree(manager->cache_intervals_);
168    DeleteIntervalList(manager, manager->head_);
169    manager->head_ = NULL;
170    DeleteIntervalList(manager, manager->recycled_intervals_);
171    manager->recycled_intervals_ = NULL;
172    memset(manager, 0, sizeof(*manager));
173    CostManagerInitFreeList(manager);
174  }
175  static int CostManagerInit(CostManager* const manager,
176                             uint16_t* const dist_array, int pix_count,
177                             const CostModel* const cost_model) {
178    int i;
179    const int cost_cache_size = (pix_count > MAX_LENGTH) ? MAX_LENGTH : pix_count;
180    manager->costs_ = NULL;
181    manager->cache_intervals_ = NULL;
182    manager->head_ = NULL;
183    manager->recycled_intervals_ = NULL;
184    manager->count_ = 0;
185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
<span onclick='openModal()' class='match'>187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
</span>192        ++manager->cache_intervals_size_;
193      }
194    }
195    assert(manager->cache_intervals_size_ <= MAX_LENGTH);
196    manager->cache_intervals_ = (CostCacheInterval*)WebPSafeMalloc(
197        manager->cache_intervals_size_, sizeof(*manager->cache_intervals_));
198    if (manager->cache_intervals_ == NULL) {
199      CostManagerClear(manager);
200      return 0;
201    }
202    {
203      CostCacheInterval* cur = manager->cache_intervals_;
204      cur->start_ = 0;
205      cur->end_ = 1;
206      cur->cost_ = manager->cost_cache_[0];
207      for (i = 1; i < cost_cache_size; ++i) {
208        const double cost_val = manager->cost_cache_[i];
209        if (cost_val != cur->cost_) {
210          ++cur;
211          cur->start_ = i;
212          cur->cost_ = cost_val;
213        }
214        cur->end_ = i + 1;
215      }
216    }
217    manager->costs_ = (float*)WebPSafeMalloc(pix_count, sizeof(*manager->costs_));
218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
223    return 1;
224  }
225  static WEBP_INLINE void UpdateCost(CostManager* const manager, int i,
226                                     int position, float cost) {
227    const int k = i - position;
228    assert(k >= 0 && k < MAX_LENGTH);
229    if (manager->costs_[i] > cost) {
230      manager->costs_[i] = cost;
231      manager->dist_array_[i] = k + 1;
232    }
233  }
234  static WEBP_INLINE void UpdateCostPerInterval(CostManager* const manager,
235                                                int start, int end, int position,
236                                                float cost) {
237    int i;
238    for (i = start; i < end; ++i) UpdateCost(manager, i, position, cost);
239  }
240  static WEBP_INLINE void ConnectIntervals(CostManager* const manager,
241                                           CostInterval* const prev,
242                                           CostInterval* const next) {
243    if (prev != NULL) {
244      prev->next_ = next;
245    } else {
246      manager->head_ = next;
247    }
248    if (next != NULL) next->previous_ = prev;
249  }
250  static WEBP_INLINE void PopInterval(CostManager* const manager,
251                                      CostInterval* const interval) {
252    if (interval == NULL) return;
253    ConnectIntervals(manager, interval->previous_, interval->next_);
254    if (CostIntervalIsInFreeList(manager, interval)) {
255      CostIntervalAddToFreeList(manager, interval);
256    } else {  
257      interval->next_ = manager->recycled_intervals_;
258      manager->recycled_intervals_ = interval;
259    }
260    --manager->count_;
261    assert(manager->count_ >= 0);
262  }
263  static WEBP_INLINE void UpdateCostAtIndex(CostManager* const manager, int i,
264                                            int do_clean_intervals) {
265    CostInterval* current = manager->head_;
266    while (current != NULL && current->start_ <= i) {
267      CostInterval* const next = current->next_;
268      if (current->end_ <= i) {
269        if (do_clean_intervals) {
270          PopInterval(manager, current);
271        }
272      } else {
273        UpdateCost(manager, i, current->index_, current->cost_);
274      }
275      current = next;
276    }
277  }
278  static WEBP_INLINE void PositionOrphanInterval(CostManager* const manager,
279                                                 CostInterval* const current,
280                                                 CostInterval* previous) {
281    assert(current != NULL);
282    if (previous == NULL) previous = manager->head_;
283    while (previous != NULL && current->start_ < previous->start_) {
284      previous = previous->previous_;
285    }
286    while (previous != NULL && previous->next_ != NULL &&
287           previous->next_->start_ < current->start_) {
288      previous = previous->next_;
289    }
290    if (previous != NULL) {
291      ConnectIntervals(manager, current, previous->next_);
292    } else {
293      ConnectIntervals(manager, current, manager->head_);
294    }
295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
300                                         int end) {
301    CostInterval* interval_new;
302    if (start >= end) return;
303    if (manager->count_ >= COST_CACHE_INTERVAL_SIZE_MAX) {
304      UpdateCostPerInterval(manager, start, end, position, cost);
305      return;
306    }
307    if (manager->free_intervals_ != NULL) {
308      interval_new = manager->free_intervals_;
309      manager->free_intervals_ = interval_new->next_;
310    } else if (manager->recycled_intervals_ != NULL) {
311      interval_new = manager->recycled_intervals_;
312      manager->recycled_intervals_ = interval_new->next_;
313    } else {  
314      interval_new = (CostInterval*)WebPSafeMalloc(1, sizeof(*interval_new));
315      if (interval_new == NULL) {
316        UpdateCostPerInterval(manager, start, end, position, cost);
317        return;
318      }
319    }
320    interval_new->cost_ = cost;
321    interval_new->index_ = position;
322    interval_new->start_ = start;
323    interval_new->end_ = end;
324    PositionOrphanInterval(manager, interval_new, interval_in);
325    ++manager->count_;
326  }
327  static WEBP_INLINE void PushInterval(CostManager* const manager,
328                                       double distance_cost, int position,
329                                       int len) {
330    size_t i;
331    CostInterval* interval = manager->head_;
332    CostInterval* interval_next;
333    const CostCacheInterval* const cost_cache_intervals =
334        manager->cache_intervals_;
335    const int kSkipDistance = 10;
336    if (len < kSkipDistance) {
337      int j;
338      for (j = position; j < position + len; ++j) {
339        const int k = j - position;
340        float cost_tmp;
341        assert(k >= 0 && k < MAX_LENGTH);
342        cost_tmp = (float)(distance_cost + manager->cost_cache_[k]);
343        if (manager->costs_[j] > cost_tmp) {
344          manager->costs_[j] = cost_tmp;
345          manager->dist_array_[j] = k + 1;
346        }
347      }
348      return;
349    }
350    for (i = 0; i < manager->cache_intervals_size_ &&
351                cost_cache_intervals[i].start_ < len;
352         ++i) {
353      int start = position + cost_cache_intervals[i].start_;
354      const int end = position + (cost_cache_intervals[i].end_ > len
355                                   ? len
356                                   : cost_cache_intervals[i].end_);
357      const float cost = (float)(distance_cost + cost_cache_intervals[i].cost_);
358      for (; interval != NULL && interval->start_ < end;
359           interval = interval_next) {
360        interval_next = interval->next_;
361        if (start >= interval->end_) continue;
362        if (cost >= interval->cost_) {
363          const int start_new = interval->end_;
364          InsertInterval(manager, interval, cost, position, start,
365                         interval->start_);
366          start = start_new;
367          if (start >= end) break;
368          continue;
369        }
370        if (start <= interval->start_) {
371          if (interval->end_ <= end) {
372            PopInterval(manager, interval);
373          } else {
374            interval->start_ = end;
375            break;
376          }
377        } else {
378          if (end < interval->end_) {
379            const int end_original = interval->end_;
380            interval->end_ = start;
381            InsertInterval(manager, interval, interval->cost_, interval->index_,
382                           end, end_original);
383            interval = interval->next_;
384            break;
385          } else {
386            interval->end_ = start;
387          }
388        }
389      }
390      InsertInterval(manager, interval, cost, position, start, end);
391    }
392  }
393  static int BackwardReferencesHashChainDistanceOnly(
394      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
395      const VP8LHashChain* const hash_chain, const VP8LBackwardRefs* const refs,
396      uint16_t* const dist_array) {
397    int i;
398    int ok = 0;
399    int cc_init = 0;
400    const int pix_count = xsize * ysize;
401    const int use_color_cache = (cache_bits > 0);
402    const size_t literal_array_size =
403        sizeof(double) * (NUM_LITERAL_CODES + NUM_LENGTH_CODES +
404                          ((cache_bits > 0) ? (1 << cache_bits) : 0));
405    const size_t cost_model_size = sizeof(CostModel) + literal_array_size;
406    CostModel* const cost_model =
407        (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
408    VP8LColorCache hashers;
409    CostManager* cost_manager =
410        (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
411    int offset_prev = -1, len_prev = -1;
412    double offset_cost = -1;
413    int first_offset_is_constant = -1;  
414    int reach = 0;
415    if (cost_model == NULL || cost_manager == NULL) goto Error;
416    cost_model->literal_ = (double*)(cost_model + 1);
417    if (use_color_cache) {
418      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
419      if (!cc_init) goto Error;
420    }
421    if (!CostModelBuild(cost_model, xsize, cache_bits, refs)) {
422      goto Error;
423    }
424    if (!CostManagerInit(cost_manager, dist_array, pix_count, cost_model)) {
425      goto Error;
426    }
427    dist_array[0] = 0;
428    AddSingleLiteralWithCostModel(argb, &hashers, cost_model, 0, use_color_cache,
429                                  0.f, cost_manager->costs_, dist_array);
430    for (i = 1; i < pix_count; ++i) {
431      const float prev_cost = cost_manager->costs_[i - 1];
432      int offset, len;
433      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
434      AddSingleLiteralWithCostModel(argb, &hashers, cost_model, i,
435                                    use_color_cache, prev_cost,
436                                    cost_manager->costs_, dist_array);
437      if (len >= 2) {
438        if (offset != offset_prev) {
439          const int code = VP8LDistanceToPlaneCode(xsize, offset);
440          offset_cost = GetDistanceCost(cost_model, code);
441          first_offset_is_constant = 1;
442          PushInterval(cost_manager, prev_cost + offset_cost, i, len);
443        } else {
444          assert(offset_cost >= 0);
445          assert(len_prev >= 0);
446          assert(first_offset_is_constant == 0 || first_offset_is_constant == 1);
447          if (first_offset_is_constant) {
448            reach = i - 1 + len_prev - 1;
449            first_offset_is_constant = 0;
450          }
451          if (i + len - 1 > reach) {
452            int offset_j, len_j = 0;
453            int j;
454            assert(len == MAX_LENGTH || len == pix_count - i);
455            for (j = i; j <= reach; ++j) {
456              VP8LHashChainFindCopy(hash_chain, j + 1, &offset_j, &len_j);
457              if (offset_j != offset) {
458                VP8LHashChainFindCopy(hash_chain, j, &offset_j, &len_j);
459                break;
460              }
461            }
462            UpdateCostAtIndex(cost_manager, j - 1, 0);
463            UpdateCostAtIndex(cost_manager, j, 0);
464            PushInterval(cost_manager, cost_manager->costs_[j - 1] + offset_cost,
465                         j, len_j);
466            reach = j + len_j - 1;
467          }
468        }
469      }
470      UpdateCostAtIndex(cost_manager, i, 1);
471      offset_prev = offset;
472      len_prev = len;
473    }
474    ok = !refs->error_;
475  Error:
476    if (cc_init) VP8LColorCacheClear(&hashers);
477    CostManagerClear(cost_manager);
478    WebPSafeFree(cost_model);
479    WebPSafeFree(cost_manager);
480    return ok;
481  }
482  static void TraceBackwards(uint16_t* const dist_array,
483                             int dist_array_size,
484                             uint16_t** const chosen_path,
485                             int* const chosen_path_size) {
486    uint16_t* path = dist_array + dist_array_size;
487    uint16_t* cur = dist_array + dist_array_size - 1;
488    while (cur >= dist_array) {
489      const int k = *cur;
490      --path;
491      *path = k;
492      cur -= k;
493    }
494    *chosen_path = path;
495    *chosen_path_size = (int)(dist_array + dist_array_size - path);
496  }
497  static int BackwardReferencesHashChainFollowChosenPath(
498      const uint32_t* const argb, int cache_bits,
499      const uint16_t* const chosen_path, int chosen_path_size,
500      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs) {
501    const int use_color_cache = (cache_bits > 0);
502    int ix;
503    int i = 0;
504    int ok = 0;
505    int cc_init = 0;
506    VP8LColorCache hashers;
507    if (use_color_cache) {
508      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
509      if (!cc_init) goto Error;
510    }
511    VP8LClearBackwardRefs(refs);
512    for (ix = 0; ix < chosen_path_size; ++ix) {
513      const int len = chosen_path[ix];
514      if (len != 1) {
515        int k;
516        const int offset = VP8LHashChainFindOffset(hash_chain, i);
517        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
518        if (use_color_cache) {
519          for (k = 0; k < len; ++k) {
520            VP8LColorCacheInsert(&hashers, argb[i + k]);
521          }
522        }
523        i += len;
524      } else {
525        PixOrCopy v;
526        const int idx =
527            use_color_cache ? VP8LColorCacheContains(&hashers, argb[i]) : -1;
528        if (idx >= 0) {
529          v = PixOrCopyCreateCacheIdx(idx);
530        } else {
531          if (use_color_cache) VP8LColorCacheInsert(&hashers, argb[i]);
532          v = PixOrCopyCreateLiteral(argb[i]);
533        }
534        VP8LBackwardRefsCursorAdd(refs, v);
535        ++i;
536      }
537    }
538    ok = !refs->error_;
539   Error:
540    if (cc_init) VP8LColorCacheClear(&hashers);
541    return ok;
542  }
543  extern int VP8LBackwardReferencesTraceBackwards(
544      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
545      const VP8LHashChain* const hash_chain,
546      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
547  int VP8LBackwardReferencesTraceBackwards(int xsize, int ysize,
548                                           const uint32_t* const argb,
549                                           int cache_bits,
550                                           const VP8LHashChain* const hash_chain,
551                                           const VP8LBackwardRefs* const refs_src,
552                                           VP8LBackwardRefs* const refs_dst) {
553    int ok = 0;
554    const int dist_array_size = xsize * ysize;
555    uint16_t* chosen_path = NULL;
556    int chosen_path_size = 0;
557    uint16_t* dist_array =
558        (uint16_t*)WebPSafeMalloc(dist_array_size, sizeof(*dist_array));
559    if (dist_array == NULL) goto Error;
560    if (!BackwardReferencesHashChainDistanceOnly(
561            xsize, ysize, argb, cache_bits, hash_chain, refs_src, dist_array)) {
562      goto Error;
563    }
564    TraceBackwards(dist_array, dist_array_size, &chosen_path, &chosen_path_size);
565    if (!BackwardReferencesHashChainFollowChosenPath(
566            argb, cache_bits, chosen_path, chosen_path_size, hash_chain,
567            refs_dst)) {
568      goto Error;
569    }
570    ok = 1;
571   Error:
572    WebPSafeFree(dist_array);
573    return ok;
574  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/alphai_dec.h"
3  #include "src/dec/vp8i_dec.h"
4  #include "src/dec/vp8li_dec.h"
5  #include "src/dec/webpi_dec.h"
6  #include "src/utils/bit_reader_inl_utils.h"
7  #include "src/utils/utils.h"
8  int WebPGetDecoderVersion(void) {
9    return (DEC_MAJ_VERSION << 16) | (DEC_MIN_VERSION << 8) | DEC_REV_VERSION;
10  }
11  typedef int (*GetCoeffsFunc)(VP8BitReader* const br,
12                               const VP8BandProbas* const prob[],
13                               int ctx, const quant_t dq, int n, int16_t* out);
14  static volatile GetCoeffsFunc GetCoeffs = NULL;
15  static void InitGetCoeffs(void);
16  static void SetOk(VP8Decoder* const dec) {
17    dec->status_ = VP8_STATUS_OK;
18    dec->error_msg_ = "OK";
19  }
20  int VP8InitIoInternal(VP8Io* const io, int version) {
21    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DECODER_ABI_VERSION)) {
22      return 0;  
23    }
24    if (io != NULL) {
25      memset(io, 0, sizeof(*io));
26    }
27    return 1;
28  }
29  VP8Decoder* VP8New(void) {
30    VP8Decoder* const dec = (VP8Decoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
31    if (dec != NULL) {
32      SetOk(dec);
33      WebPGetWorkerInterface()->Init(&dec->worker_);
34      dec->ready_ = 0;
35      dec->num_parts_minus_one_ = 0;
36      InitGetCoeffs();
37    }
38    return dec;
39  }
40  VP8StatusCode VP8Status(VP8Decoder* const dec) {
41    if (!dec) return VP8_STATUS_INVALID_PARAM;
42    return dec->status_;
43  }
44  const char* VP8StatusMessage(VP8Decoder* const dec) {
45    if (dec == NULL) return "no object";
46    if (!dec->error_msg_) return "OK";
47    return dec->error_msg_;
48  }
49  void VP8Delete(VP8Decoder* const dec) {
50    if (dec != NULL) {
51      VP8Clear(dec);
52      WebPSafeFree(dec);
53    }
54  }
55  int VP8SetError(VP8Decoder* const dec,
56                  VP8StatusCode error, const char* const msg) {
57    if (dec->status_ == VP8_STATUS_OK) {
58      dec->status_ = error;
59      dec->error_msg_ = msg;
60      dec->ready_ = 0;
61    }
62    return 0;
63  }
64  int VP8CheckSignature(const uint8_t* const data, size_t data_size) {
65    return (data_size >= 3 &&
66            data[0] == 0x9d && data[1] == 0x01 && data[2] == 0x2a);
67  }
68  int VP8GetInfo(const uint8_t* data, size_t data_size, size_t chunk_size,
69                 int* const width, int* const height) {
70    if (data == NULL || data_size < VP8_FRAME_HEADER_SIZE) {
71      return 0;         
72    }
73    if (!VP8CheckSignature(data + 3, data_size - 3)) {
74      return 0;         
75    } else {
76      const uint32_t bits = data[0] | (data[1] << 8) | (data[2] << 16);
77      const int key_frame = !(bits & 1);
78      const int w = ((data[7] << 8) | data[6]) & 0x3fff;
79      const int h = ((data[9] << 8) | data[8]) & 0x3fff;
80      if (!key_frame) {   
81        return 0;
82      }
83      if (((bits >> 1) & 7) > 3) {
84        return 0;         
85      }
86      if (!((bits >> 4) & 1)) {
87        return 0;         
88      }
89      if (((bits >> 5)) >= chunk_size) {  
90        return 0;         
91      }
92      if (w == 0 || h == 0) {
93        return 0;         
94      }
95      if (width) {
96        *width = w;
97      }
98      if (height) {
99        *height = h;
100      }
101      return 1;
102    }
103  }
104  static void ResetSegmentHeader(VP8SegmentHeader* const hdr) {
105    assert(hdr != NULL);
106    hdr->use_segment_ = 0;
107    hdr->update_map_ = 0;
108    hdr->absolute_delta_ = 1;
109    memset(hdr->quantizer_, 0, sizeof(hdr->quantizer_));
110    memset(hdr->filter_strength_, 0, sizeof(hdr->filter_strength_));
111  }
112  static int ParseSegmentHeader(VP8BitReader* br,
113                                VP8SegmentHeader* hdr, VP8Proba* proba) {
114    assert(br != NULL);
115    assert(hdr != NULL);
116    hdr->use_segment_ = VP8Get(br, "global-header");
117    if (hdr->use_segment_) {
118      hdr->update_map_ = VP8Get(br, "global-header");
119      if (VP8Get(br, "global-header")) {   
120        int s;
121        hdr->absolute_delta_ = VP8Get(br, "global-header");
122        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
123          hdr->quantizer_[s] = VP8Get(br, "global-header") ?
124              VP8GetSignedValue(br, 7, "global-header") : 0;
125        }
126        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
127          hdr->filter_strength_[s] = VP8Get(br, "global-header") ?
128              VP8GetSignedValue(br, 6, "global-header") : 0;
129        }
130      }
131      if (hdr->update_map_) {
132        int s;
133        for (s = 0; s < MB_FEATURE_TREE_PROBS; ++s) {
134          proba->segments_[s] = VP8Get(br, "global-header") ?
135              VP8GetValue(br, 8, "global-header") : 255u;
136        }
137      }
138    } else {
139      hdr->update_map_ = 0;
140    }
141    return !br->eof_;
142  }
143  static VP8StatusCode ParsePartitions(VP8Decoder* const dec,
144                                       const uint8_t* buf, size_t size) {
145    VP8BitReader* const br = &dec->br_;
146    const uint8_t* sz = buf;
147    const uint8_t* buf_end = buf + size;
148    const uint8_t* part_start;
149    size_t size_left = size;
150    size_t last_part;
151    size_t p;
152    dec->num_parts_minus_one_ = (1 << VP8GetValue(br, 2, "global-header")) - 1;
153    last_part = dec->num_parts_minus_one_;
154    if (size < 3 * last_part) {
155      return VP8_STATUS_NOT_ENOUGH_DATA;
156    }
<span onclick='openModal()' class='match'>157    part_start = buf + last_part * 3;
158    size_left -= last_part * 3;
159    for (p = 0; p < last_part; ++p) {
160      size_t psize = sz[0] | (sz[1] << 8) | (sz[2] << 16);
161      if (psize > size_left) psize = size_left;
</span>162      VP8InitBitReader(dec->parts_ + p, part_start, psize);
163      part_start += psize;
164      size_left -= psize;
165      sz += 3;
166    }
167    VP8InitBitReader(dec->parts_ + last_part, part_start, size_left);
168    return (part_start < buf_end) ? VP8_STATUS_OK :
169             VP8_STATUS_SUSPENDED;   
170  }
171  static int ParseFilterHeader(VP8BitReader* br, VP8Decoder* const dec) {
172    VP8FilterHeader* const hdr = &dec->filter_hdr_;
173    hdr->simple_    = VP8Get(br, "global-header");
174    hdr->level_     = VP8GetValue(br, 6, "global-header");
175    hdr->sharpness_ = VP8GetValue(br, 3, "global-header");
176    hdr->use_lf_delta_ = VP8Get(br, "global-header");
177    if (hdr->use_lf_delta_) {
178      if (VP8Get(br, "global-header")) {   
179        int i;
180        for (i = 0; i < NUM_REF_LF_DELTAS; ++i) {
181          if (VP8Get(br, "global-header")) {
182            hdr->ref_lf_delta_[i] = VP8GetSignedValue(br, 6, "global-header");
183          }
184        }
185        for (i = 0; i < NUM_MODE_LF_DELTAS; ++i) {
186          if (VP8Get(br, "global-header")) {
187            hdr->mode_lf_delta_[i] = VP8GetSignedValue(br, 6, "global-header");
188          }
189        }
190      }
191    }
192    dec->filter_type_ = (hdr->level_ == 0) ? 0 : hdr->simple_ ? 1 : 2;
193    return !br->eof_;
194  }
195  int VP8GetHeaders(VP8Decoder* const dec, VP8Io* const io) {
196    const uint8_t* buf;
197    size_t buf_size;
198    VP8FrameHeader* frm_hdr;
199    VP8PictureHeader* pic_hdr;
200    VP8BitReader* br;
201    VP8StatusCode status;
202    if (dec == NULL) {
203      return 0;
204    }
205    SetOk(dec);
206    if (io == NULL) {
207      return VP8SetError(dec, VP8_STATUS_INVALID_PARAM,
208                         "null VP8Io passed to VP8GetHeaders()");
209    }
210    buf = io->data;
211    buf_size = io->data_size;
212    if (buf_size < 4) {
213      return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
214                         "Truncated header.");
215    }
216    {
217      const uint32_t bits = buf[0] | (buf[1] << 8) | (buf[2] << 16);
218      frm_hdr = &dec->frm_hdr_;
219      frm_hdr->key_frame_ = !(bits & 1);
220      frm_hdr->profile_ = (bits >> 1) & 7;
221      frm_hdr->show_ = (bits >> 4) & 1;
222      frm_hdr->partition_length_ = (bits >> 5);
223      if (frm_hdr->profile_ > 3) {
224        return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
225                           "Incorrect keyframe parameters.");
226      }
227      if (!frm_hdr->show_) {
228        return VP8SetError(dec, VP8_STATUS_UNSUPPORTED_FEATURE,
229                           "Frame not displayable.");
230      }
231      buf += 3;
232      buf_size -= 3;
233    }
234    pic_hdr = &dec->pic_hdr_;
235    if (frm_hdr->key_frame_) {
236      if (buf_size < 7) {
237        return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
238                           "cannot parse picture header");
239      }
240      if (!VP8CheckSignature(buf, buf_size)) {
241        return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
242                           "Bad code word");
243      }
244      pic_hdr->width_ = ((buf[4] << 8) | buf[3]) & 0x3fff;
245      pic_hdr->xscale_ = buf[4] >> 6;   
246      pic_hdr->height_ = ((buf[6] << 8) | buf[5]) & 0x3fff;
247      pic_hdr->yscale_ = buf[6] >> 6;
248      buf += 7;
249      buf_size -= 7;
250      dec->mb_w_ = (pic_hdr->width_ + 15) >> 4;
251      dec->mb_h_ = (pic_hdr->height_ + 15) >> 4;
252      io->width = pic_hdr->width_;
253      io->height = pic_hdr->height_;
254      io->use_cropping = 0;
255      io->crop_top  = 0;
256      io->crop_left = 0;
257      io->crop_right  = io->width;
258      io->crop_bottom = io->height;
259      io->use_scaling  = 0;
260      io->scaled_width = io->width;
261      io->scaled_height = io->height;
262      io->mb_w = io->width;   
263      io->mb_h = io->height;  
264      VP8ResetProba(&dec->proba_);
265      ResetSegmentHeader(&dec->segment_hdr_);
266    }
267    if (frm_hdr->partition_length_ > buf_size) {
268      return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
269                         "bad partition length");
270    }
271    br = &dec->br_;
272    VP8InitBitReader(br, buf, frm_hdr->partition_length_);
273    buf += frm_hdr->partition_length_;
274    buf_size -= frm_hdr->partition_length_;
275    if (frm_hdr->key_frame_) {
276      pic_hdr->colorspace_ = VP8Get(br, "global-header");
277      pic_hdr->clamp_type_ = VP8Get(br, "global-header");
278    }
279    if (!ParseSegmentHeader(br, &dec->segment_hdr_, &dec->proba_)) {
280      return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
281                         "cannot parse segment header");
282    }
283    if (!ParseFilterHeader(br, dec)) {
284      return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
285                         "cannot parse filter header");
286    }
287    status = ParsePartitions(dec, buf, buf_size);
288    if (status != VP8_STATUS_OK) {
289      return VP8SetError(dec, status, "cannot parse partitions");
290    }
291    VP8ParseQuant(dec);
292    if (!frm_hdr->key_frame_) {
293      return VP8SetError(dec, VP8_STATUS_UNSUPPORTED_FEATURE,
294                         "Not a key frame.");
295    }
296    VP8Get(br, "global-header");   
297    VP8ParseProba(br, dec);
298    dec->ready_ = 1;
299    return 1;
300  }
301  static const uint8_t kCat3[] = { 173, 148, 140, 0 };
302  static const uint8_t kCat4[] = { 176, 155, 140, 135, 0 };
303  static const uint8_t kCat5[] = { 180, 157, 141, 134, 130, 0 };
304  static const uint8_t kCat6[] =
305    { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0 };
306  static const uint8_t* const kCat3456[] = { kCat3, kCat4, kCat5, kCat6 };
307  static const uint8_t kZigzag[16] = {
308    0, 1, 4, 8,  5, 2, 3, 6,  9, 12, 13, 10,  7, 11, 14, 15
309  };
310  static int GetLargeValue(VP8BitReader* const br, const uint8_t* const p) {
311    int v;
312    if (!VP8GetBit(br, p[3], "coeffs")) {
313      if (!VP8GetBit(br, p[4], "coeffs")) {
314        v = 2;
315      } else {
316        v = 3 + VP8GetBit(br, p[5], "coeffs");
317      }
318    } else {
319      if (!VP8GetBit(br, p[6], "coeffs")) {
320        if (!VP8GetBit(br, p[7], "coeffs")) {
321          v = 5 + VP8GetBit(br, 159, "coeffs");
322        } else {
323          v = 7 + 2 * VP8GetBit(br, 165, "coeffs");
324          v += VP8GetBit(br, 145, "coeffs");
325        }
326      } else {
327        const uint8_t* tab;
328        const int bit1 = VP8GetBit(br, p[8], "coeffs");
329        const int bit0 = VP8GetBit(br, p[9 + bit1], "coeffs");
330        const int cat = 2 * bit1 + bit0;
331        v = 0;
332        for (tab = kCat3456[cat]; *tab; ++tab) {
333          v += v + VP8GetBit(br, *tab, "coeffs");
334        }
335        v += 3 + (8 << cat);
336      }
337    }
338    return v;
339  }
340  static int GetCoeffsFast(VP8BitReader* const br,
341                           const VP8BandProbas* const prob[],
342                           int ctx, const quant_t dq, int n, int16_t* out) {
343    const uint8_t* p = prob[n]->probas_[ctx];
344    for (; n < 16; ++n) {
345      if (!VP8GetBit(br, p[0], "coeffs")) {
346        return n;  
347      }
348      while (!VP8GetBit(br, p[1], "coeffs")) {       
349        p = prob[++n]->probas_[0];
350        if (n == 16) return 16;
351      }
352      {        
353        const VP8ProbaArray* const p_ctx = &prob[n + 1]->probas_[0];
354        int v;
355        if (!VP8GetBit(br, p[2], "coeffs")) {
356          v = 1;
357          p = p_ctx[1];
358        } else {
359          v = GetLargeValue(br, p);
360          p = p_ctx[2];
361        }
362        out[kZigzag[n]] = VP8GetSigned(br, v, "coeffs") * dq[n > 0];
363      }
364    }
365    return 16;
366  }
367  static int GetCoeffsAlt(VP8BitReader* const br,
368                          const VP8BandProbas* const prob[],
369                          int ctx, const quant_t dq, int n, int16_t* out) {
370    const uint8_t* p = prob[n]->probas_[ctx];
371    for (; n < 16; ++n) {
372      if (!VP8GetBitAlt(br, p[0], "coeffs")) {
373        return n;  
374      }
375      while (!VP8GetBitAlt(br, p[1], "coeffs")) {       
376        p = prob[++n]->probas_[0];
377        if (n == 16) return 16;
378      }
379      {        
380        const VP8ProbaArray* const p_ctx = &prob[n + 1]->probas_[0];
381        int v;
382        if (!VP8GetBitAlt(br, p[2], "coeffs")) {
383          v = 1;
384          p = p_ctx[1];
385        } else {
386          v = GetLargeValue(br, p);
387          p = p_ctx[2];
388        }
389        out[kZigzag[n]] = VP8GetSigned(br, v, "coeffs") * dq[n > 0];
390      }
391    }
392    return 16;
393  }
394  static WEBP_TSAN_IGNORE_FUNCTION void InitGetCoeffs(void) {
395    if (GetCoeffs == NULL) {
396      if (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kSlowSSSE3)) {
397        GetCoeffs = GetCoeffsAlt;
398      } else {
399        GetCoeffs = GetCoeffsFast;
400      }
401    }
402  }
403  static WEBP_INLINE uint32_t NzCodeBits(uint32_t nz_coeffs, int nz, int dc_nz) {
404    nz_coeffs <<= 2;
405    nz_coeffs |= (nz > 3) ? 3 : (nz > 1) ? 2 : dc_nz;
406    return nz_coeffs;
407  }
408  static int ParseResiduals(VP8Decoder* const dec,
409                            VP8MB* const mb, VP8BitReader* const token_br) {
410    const VP8BandProbas* (* const bands)[16 + 1] = dec->proba_.bands_ptr_;
411    const VP8BandProbas* const * ac_proba;
412    VP8MBData* const block = dec->mb_data_ + dec->mb_x_;
413    const VP8QuantMatrix* const q = &dec->dqm_[block->segment_];
414    int16_t* dst = block->coeffs_;
415    VP8MB* const left_mb = dec->mb_info_ - 1;
416    uint8_t tnz, lnz;
417    uint32_t non_zero_y = 0;
418    uint32_t non_zero_uv = 0;
419    int x, y, ch;
420    uint32_t out_t_nz, out_l_nz;
421    int first;
422    memset(dst, 0, 384 * sizeof(*dst));
423    if (!block->is_i4x4_) {    
424      int16_t dc[16] = { 0 };
425      const int ctx = mb->nz_dc_ + left_mb->nz_dc_;
426      const int nz = GetCoeffs(token_br, bands[1], ctx, q->y2_mat_, 0, dc);
427      mb->nz_dc_ = left_mb->nz_dc_ = (nz > 0);
428      if (nz > 1) {   
429        VP8TransformWHT(dc, dst);
430      } else {        
431        int i;
432        const int dc0 = (dc[0] + 3) >> 3;
433        for (i = 0; i < 16 * 16; i += 16) dst[i] = dc0;
434      }
435      first = 1;
436      ac_proba = bands[0];
437    } else {
438      first = 0;
439      ac_proba = bands[3];
440    }
441    tnz = mb->nz_ & 0x0f;
442    lnz = left_mb->nz_ & 0x0f;
443    for (y = 0; y < 4; ++y) {
444      int l = lnz & 1;
445      uint32_t nz_coeffs = 0;
446      for (x = 0; x < 4; ++x) {
447        const int ctx = l + (tnz & 1);
448        const int nz = GetCoeffs(token_br, ac_proba, ctx, q->y1_mat_, first, dst);
449        l = (nz > first);
450        tnz = (tnz >> 1) | (l << 7);
451        nz_coeffs = NzCodeBits(nz_coeffs, nz, dst[0] != 0);
452        dst += 16;
453      }
454      tnz >>= 4;
455      lnz = (lnz >> 1) | (l << 7);
456      non_zero_y = (non_zero_y << 8) | nz_coeffs;
457    }
458    out_t_nz = tnz;
459    out_l_nz = lnz >> 4;
460    for (ch = 0; ch < 4; ch += 2) {
461      uint32_t nz_coeffs = 0;
462      tnz = mb->nz_ >> (4 + ch);
463      lnz = left_mb->nz_ >> (4 + ch);
464      for (y = 0; y < 2; ++y) {
465        int l = lnz & 1;
466        for (x = 0; x < 2; ++x) {
467          const int ctx = l + (tnz & 1);
468          const int nz = GetCoeffs(token_br, bands[2], ctx, q->uv_mat_, 0, dst);
469          l = (nz > 0);
470          tnz = (tnz >> 1) | (l << 3);
471          nz_coeffs = NzCodeBits(nz_coeffs, nz, dst[0] != 0);
472          dst += 16;
473        }
474        tnz >>= 2;
475        lnz = (lnz >> 1) | (l << 5);
476      }
477      non_zero_uv |= nz_coeffs << (4 * ch);
478      out_t_nz |= (tnz << 4) << ch;
479      out_l_nz |= (lnz & 0xf0) << ch;
480    }
481    mb->nz_ = out_t_nz;
482    left_mb->nz_ = out_l_nz;
483    block->non_zero_y_ = non_zero_y;
484    block->non_zero_uv_ = non_zero_uv;
485    block->dither_ = (non_zero_uv & 0xaaaa) ? 0 : q->dither_;
486    return !(non_zero_y | non_zero_uv);  
487  }
488  int VP8DecodeMB(VP8Decoder* const dec, VP8BitReader* const token_br) {
489    VP8MB* const left = dec->mb_info_ - 1;
490    VP8MB* const mb = dec->mb_info_ + dec->mb_x_;
491    VP8MBData* const block = dec->mb_data_ + dec->mb_x_;
492    int skip = dec->use_skip_proba_ ? block->skip_ : 0;
493    if (!skip) {
494      skip = ParseResiduals(dec, mb, token_br);
495    } else {
496      left->nz_ = mb->nz_ = 0;
497      if (!block->is_i4x4_) {
498        left->nz_dc_ = mb->nz_dc_ = 0;
499      }
500      block->non_zero_y_ = 0;
501      block->non_zero_uv_ = 0;
502      block->dither_ = 0;
503    }
504    if (dec->filter_type_ > 0) {  
505      VP8FInfo* const finfo = dec->f_info_ + dec->mb_x_;
506      *finfo = dec->fstrengths_[block->segment_][block->is_i4x4_];
507      finfo->f_inner_ |= !skip;
508    }
509    return !token_br->eof_;
510  }
511  void VP8InitScanline(VP8Decoder* const dec) {
512    VP8MB* const left = dec->mb_info_ - 1;
513    left->nz_ = 0;
514    left->nz_dc_ = 0;
515    memset(dec->intra_l_, B_DC_PRED, sizeof(dec->intra_l_));
516    dec->mb_x_ = 0;
517  }
518  static int ParseFrame(VP8Decoder* const dec, VP8Io* io) {
519    for (dec->mb_y_ = 0; dec->mb_y_ < dec->br_mb_y_; ++dec->mb_y_) {
520      VP8BitReader* const token_br =
521          &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
522      if (!VP8ParseIntraModeRow(&dec->br_, dec)) {
523        return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
524                           "Premature end-of-partition0 encountered.");
525      }
526      for (; dec->mb_x_ < dec->mb_w_; ++dec->mb_x_) {
527        if (!VP8DecodeMB(dec, token_br)) {
528          return VP8SetError(dec, VP8_STATUS_NOT_ENOUGH_DATA,
529                             "Premature end-of-file encountered.");
530        }
531      }
532      VP8InitScanline(dec);   
533      if (!VP8ProcessRow(dec, io)) {
534        return VP8SetError(dec, VP8_STATUS_USER_ABORT, "Output aborted.");
535      }
536    }
537    if (dec->mt_method_ > 0) {
538      if (!WebPGetWorkerInterface()->Sync(&dec->worker_)) return 0;
539    }
540    return 1;
541  }
542  int VP8Decode(VP8Decoder* const dec, VP8Io* const io) {
543    int ok = 0;
544    if (dec == NULL) {
545      return 0;
546    }
547    if (io == NULL) {
548      return VP8SetError(dec, VP8_STATUS_INVALID_PARAM,
549                         "NULL VP8Io parameter in VP8Decode().");
550    }
551    if (!dec->ready_) {
552      if (!VP8GetHeaders(dec, io)) {
553        return 0;
554      }
555    }
556    assert(dec->ready_);
557    ok = (VP8EnterCritical(dec, io) == VP8_STATUS_OK);
558    if (ok) {   
559      if (ok) ok = VP8InitFrame(dec, io);
560      if (ok) ok = ParseFrame(dec, io);
561      ok &= VP8ExitCritical(dec, io);
562    }
563    if (!ok) {
564      VP8Clear(dec);
565      return 0;
566    }
567    dec->ready_ = 0;
568    return ok;
569  }
570  void VP8Clear(VP8Decoder* const dec) {
571    if (dec == NULL) {
572      return;
573    }
574    WebPGetWorkerInterface()->End(&dec->worker_);
575    WebPDeallocateAlphaMemory(dec);
576    WebPSafeFree(dec->mem_);
577    dec->mem_ = NULL;
578    dec->mem_size_ = 0;
579    memset(&dec->br_, 0, sizeof(dec->br_));
580    dec->ready_ = 0;
581  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
</pre></code></div>
                <div class="column column_space"><pre><code>157    part_start = buf + last_part * 3;
158    size_left -= last_part * 3;
159    for (p = 0; p < last_part; ++p) {
160      size_t psize = sz[0] | (sz[1] << 8) | (sz[2] << 16);
161      if (psize > size_left) psize = size_left;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    