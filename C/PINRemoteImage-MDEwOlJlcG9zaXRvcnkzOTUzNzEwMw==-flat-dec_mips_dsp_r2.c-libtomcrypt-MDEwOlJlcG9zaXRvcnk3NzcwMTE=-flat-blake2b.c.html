
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.59493670886076%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include "src/dsp/mips_macro.h"
4  static const int kC1 = 20091 + (1 << 16);
5  static const int kC2 = 35468;
6  #define MUL(a, b) (((a) * (b)) >> 16)
7  static void TransformDC(const int16_t* in, uint8_t* dst) {
8    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9, temp10;
9    __asm__ volatile (
10      LOAD_WITH_OFFSET_X4(temp1, temp2, temp3, temp4, dst,
11                          0, 0, 0, 0,
12                          0, 1, 2, 3,
13                          BPS)
14      "lh               %[temp5],  0(%[in])               \n\t"
15      "addiu            %[temp5],  %[temp5],  4           \n\t"
16      "ins              %[temp5],  %[temp5],  16, 16      \n\t"
17      "shra.ph          %[temp5],  %[temp5],  3           \n\t"
18      CONVERT_2_BYTES_TO_HALF(temp6, temp7, temp8, temp9, temp10, temp1, temp2,
19                              temp3, temp1, temp2, temp3, temp4)
20      STORE_SAT_SUM_X2(temp6, temp7, temp8, temp9, temp10, temp1, temp2, temp3,
21                       temp5, temp5, temp5, temp5, temp5, temp5, temp5, temp5,
22                       dst, 0, 1, 2, 3, BPS)
23      OUTPUT_EARLY_CLOBBER_REGS_10()
24      : [in]"r"(in), [dst]"r"(dst)
25      : "memory"
26    );
27  }
28  static void TransformAC3(const int16_t* in, uint8_t* dst) {
29    const int a = in[0] + 4;
30    int c4 = MUL(in[4], kC2);
31    const int d4 = MUL(in[4], kC1);
32    const int c1 = MUL(in[1], kC2);
33    const int d1 = MUL(in[1], kC1);
34    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
35    int temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17, temp18;
36    __asm__ volatile (
37      "ins              %[c4],      %[d4],     16,       16    \n\t"
38      "replv.ph         %[temp1],   %[a]                       \n\t"
39      "replv.ph         %[temp4],   %[d1]                      \n\t"
40      ADD_SUB_HALVES(temp2, temp3, temp1, c4)
41      "replv.ph         %[temp5],   %[c1]                      \n\t"
42      SHIFT_R_SUM_X2(temp1, temp6, temp7, temp8, temp2, temp9, temp10, temp4,
43                     temp2, temp2, temp3, temp3, temp4, temp5, temp4, temp5)
44      LOAD_WITH_OFFSET_X4(temp3, temp5, temp11, temp12, dst,
45                          0, 0, 0, 0,
46                          0, 1, 2, 3,
47                          BPS)
48      CONVERT_2_BYTES_TO_HALF(temp13, temp14, temp3, temp15, temp5, temp16,
49                              temp11, temp17, temp3, temp5, temp11, temp12)
50      PACK_2_HALVES_TO_WORD(temp12, temp18, temp7, temp6, temp1, temp8, temp2,
51                            temp4, temp7, temp6, temp10, temp9)
52      STORE_SAT_SUM_X2(temp13, temp14, temp3, temp15, temp5, temp16, temp11,
53                       temp17, temp12, temp18, temp1, temp8, temp2, temp4,
54                       temp7, temp6, dst, 0, 1, 2, 3, BPS)
55      OUTPUT_EARLY_CLOBBER_REGS_18(),
56        [c4]"+&r"(c4)
57      : [dst]"r"(dst), [a]"r"(a), [d1]"r"(d1), [d4]"r"(d4), [c1]"r"(c1)
58      : "memory"
59    );
60  }
61  static void TransformOne(const int16_t* in, uint8_t* dst) {
62    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
63    int temp10, temp11, temp12, temp13, temp14, temp15, temp16, temp17, temp18;
64    __asm__ volatile (
65      "ulw              %[temp1],   0(%[in])                 \n\t"
66      "ulw              %[temp2],   16(%[in])                \n\t"
67      LOAD_IN_X2(temp5, temp6, 24, 26)
68      ADD_SUB_HALVES(temp3, temp4, temp1, temp2)
69      LOAD_IN_X2(temp1, temp2, 8, 10)
70      MUL_SHIFT_SUM(temp7, temp8, temp9, temp10, temp11, temp12, temp13, temp14,
71                    temp10, temp8, temp9, temp7, temp1, temp2, temp5, temp6,
72                    temp13, temp11, temp14, temp12)
73      INSERT_HALF_X2(temp8, temp7, temp10, temp9)
74      "ulw              %[temp17],  4(%[in])                 \n\t"
75      "ulw              %[temp18],  20(%[in])                \n\t"
76      ADD_SUB_HALVES(temp1, temp2, temp3, temp8)
77      ADD_SUB_HALVES(temp5, temp6, temp4, temp7)
78      ADD_SUB_HALVES(temp7, temp8, temp17, temp18)
79      LOAD_IN_X2(temp17, temp18, 12, 14)
80      LOAD_IN_X2(temp9, temp10, 28, 30)
81      MUL_SHIFT_SUM(temp11, temp12, temp13, temp14, temp15, temp16, temp4, temp17,
82                    temp12, temp14, temp11, temp13, temp17, temp18, temp9, temp10,
83                    temp15, temp4, temp16, temp17)
84      INSERT_HALF_X2(temp11, temp12, temp13, temp14)
85      ADD_SUB_HALVES(temp17, temp8, temp8, temp11)
86      ADD_SUB_HALVES(temp3, temp4, temp7, temp12)
87      SRA_16(temp9, temp10, temp11, temp12, temp1, temp2, temp5, temp6)
88      INSERT_HALF_X2(temp1, temp6, temp5, temp2)
89      SRA_16(temp13, temp14, temp15, temp16, temp3, temp4, temp17, temp8)
90      "repl.ph          %[temp2],   0x4                      \n\t"
91      INSERT_HALF_X2(temp3, temp8, temp17, temp4)
92      "addq.ph          %[temp1],   %[temp1],  %[temp2]      \n\t"
93      "addq.ph          %[temp6],   %[temp6],  %[temp2]      \n\t"
94      ADD_SUB_HALVES(temp2, temp4, temp1, temp3)
95      ADD_SUB_HALVES(temp5, temp7, temp6, temp8)
96      MUL_SHIFT_SUM(temp1, temp3, temp6, temp8, temp9, temp13, temp17, temp18,
97                    temp3, temp13, temp1, temp9, temp9, temp13, temp11, temp15,
98                    temp6, temp17, temp8, temp18)
99      MUL_SHIFT_SUM(temp6, temp8, temp18, temp17, temp11, temp15, temp12, temp16,
100                    temp8, temp15, temp6, temp11, temp12, temp16, temp10, temp14,
101                    temp18, temp12, temp17, temp16)
102      INSERT_HALF_X2(temp1, temp3, temp9, temp13)
103      INSERT_HALF_X2(temp6, temp8, temp11, temp15)
104      SHIFT_R_SUM_X2(temp9, temp10, temp11, temp12, temp13, temp14, temp15,
105                     temp16, temp2, temp4, temp5, temp7, temp3, temp1, temp8,
106                     temp6)
107      PACK_2_HALVES_TO_WORD(temp1, temp2, temp3, temp4, temp9, temp12, temp13,
108                            temp16, temp11, temp10, temp15, temp14)
109      LOAD_WITH_OFFSET_X4(temp10, temp11, temp14, temp15, dst,
110                          0, 0, 0, 0,
111                          0, 1, 2, 3,
112                          BPS)
113      CONVERT_2_BYTES_TO_HALF(temp5, temp6, temp7, temp8, temp17, temp18, temp10,
114                              temp11, temp10, temp11, temp14, temp15)
115      STORE_SAT_SUM_X2(temp5, temp6, temp7, temp8, temp17, temp18, temp10, temp11,
116                       temp9, temp12, temp1, temp2, temp13, temp16, temp3, temp4,
117                       dst, 0, 1, 2, 3, BPS)
118      OUTPUT_EARLY_CLOBBER_REGS_18()
119      : [dst]"r"(dst), [in]"r"(in), [kC1]"r"(kC1), [kC2]"r"(kC2)
120      : "memory", "hi", "lo"
121    );
122  }
123  static void TransformTwo(const int16_t* in, uint8_t* dst, int do_two) {
124    TransformOne(in, dst);
125    if (do_two) {
126      TransformOne(in + 16, dst + 4);
127    }
128  }
129  static WEBP_INLINE void FilterLoop26(uint8_t* p,
130                                       int hstride, int vstride, int size,
131                                       int thresh, int ithresh, int hev_thresh) {
132    const int thresh2 = 2 * thresh + 1;
133    int temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
134    int temp10, temp11, temp12, temp13, temp14, temp15;
135    __asm__ volatile (
136      ".set      push                                      \n\t"
137      ".set      noreorder                                 \n\t"
138    "1:                                                    \n\t"
139      "negu      %[temp1],  %[hstride]                     \n\t"
140      "addiu     %[size],   %[size],        -1             \n\t"
141      "sll       %[temp2],  %[hstride],     1              \n\t"
142      "sll       %[temp3],  %[temp1],       1              \n\t"
143      "addu      %[temp4],  %[temp2],       %[hstride]     \n\t"
144      "addu      %[temp5],  %[temp3],       %[temp1]       \n\t"
145      "lbu       %[temp7],  0(%[p])                        \n\t"
146      "sll       %[temp6],  %[temp3],       1              \n\t"
147      "lbux      %[temp8],  %[temp5](%[p])                 \n\t"
148      "lbux      %[temp9],  %[temp3](%[p])                 \n\t"
149      "lbux      %[temp10], %[temp1](%[p])                 \n\t"
150      "lbux      %[temp11], %[temp6](%[p])                 \n\t"
151      "lbux      %[temp12], %[hstride](%[p])               \n\t"
152      "lbux      %[temp13], %[temp2](%[p])                 \n\t"
153      "lbux      %[temp14], %[temp4](%[p])                 \n\t"
154      "subu      %[temp1],  %[temp10],      %[temp7]       \n\t"
155      "subu      %[temp2],  %[temp9],       %[temp12]      \n\t"
156      "absq_s.w  %[temp3],  %[temp1]                       \n\t"
157      "absq_s.w  %[temp4],  %[temp2]                       \n\t"
158      "negu      %[temp1],  %[temp1]                       \n\t"
159      "sll       %[temp3],  %[temp3],       2              \n\t"
160      "addu      %[temp15], %[temp3],       %[temp4]       \n\t"
161      "subu      %[temp3],  %[temp15],      %[thresh2]     \n\t"
162      "sll       %[temp6],  %[temp1],       1              \n\t"
163      "bgtz      %[temp3],  3f                             \n\t"
164      " subu     %[temp4],  %[temp11],      %[temp8]       \n\t"
165      "absq_s.w  %[temp4],  %[temp4]                       \n\t"
166      "shll_s.w  %[temp2],  %[temp2],       24             \n\t"
167      "subu      %[temp4],  %[temp4],       %[ithresh]     \n\t"
168      "bgtz      %[temp4],  3f                             \n\t"
169      " subu     %[temp3],  %[temp8],       %[temp9]       \n\t"
170      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
171      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
172      "bgtz      %[temp3],  3f                             \n\t"
173      " subu     %[temp5],  %[temp9],       %[temp10]      \n\t"
174      "absq_s.w  %[temp3],  %[temp5]                       \n\t"
175      "absq_s.w  %[temp5],  %[temp5]                       \n\t"
176      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
177      "bgtz      %[temp3],  3f                             \n\t"
178      " subu     %[temp3],  %[temp14],      %[temp13]      \n\t"
179      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
180      "slt       %[temp5],  %[hev_thresh],  %[temp5]       \n\t"
181      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
182      "bgtz      %[temp3],  3f                             \n\t"
183      " subu     %[temp3],  %[temp13],      %[temp12]      \n\t"
184      "absq_s.w  %[temp3],  %[temp3]                       \n\t"
185      "sra       %[temp4],  %[temp2],       24             \n\t"
186      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
187      "bgtz      %[temp3],  3f                             \n\t"
188      " subu     %[temp15], %[temp12],      %[temp7]       \n\t"
189      "absq_s.w  %[temp3],  %[temp15]                      \n\t"
190      "absq_s.w  %[temp15], %[temp15]                      \n\t"
191      "subu      %[temp3],  %[temp3],       %[ithresh]     \n\t"
192      "bgtz      %[temp3],  3f                             \n\t"
193      " slt      %[temp15], %[hev_thresh],  %[temp15]      \n\t"
194      "addu      %[temp3],  %[temp6],       %[temp1]       \n\t"
195      "or        %[temp2],  %[temp5],       %[temp15]      \n\t"
196      "addu      %[temp5],  %[temp4],       %[temp3]       \n\t"
197      "beqz      %[temp2],  4f                             \n\t"
198      " shra_r.w %[temp1],  %[temp5],       3              \n\t"
199      "addiu     %[temp2],  %[temp5],       3              \n\t"
200      "sra       %[temp2],  %[temp2],       3              \n\t"
201      "shll_s.w  %[temp1],  %[temp1],       27             \n\t"
202      "shll_s.w  %[temp2],  %[temp2],       27             \n\t"
203      "subu      %[temp3],  %[p],           %[hstride]     \n\t"
204      "sra       %[temp1],  %[temp1],       27             \n\t"
205      "sra       %[temp2],  %[temp2],       27             \n\t"
206      "subu      %[temp1],  %[temp7],       %[temp1]       \n\t"
207      "addu      %[temp2],  %[temp10],      %[temp2]       \n\t"
208      "lbux      %[temp2],  %[temp2](%[VP8kclip1])         \n\t"
209      "lbux      %[temp1],  %[temp1](%[VP8kclip1])         \n\t"
210      "sb        %[temp2],  0(%[temp3])                    \n\t"
211      "j         3f                                        \n\t"
212      " sb       %[temp1],  0(%[p])                        \n\t"
213    "4:                                                    \n\t"
214      "shll_s.w  %[temp5],  %[temp5],       24             \n\t"
215      "subu      %[temp14], %[p],           %[hstride]     \n\t"
216      "subu      %[temp11], %[temp14],      %[hstride]     \n\t"
217      "sra       %[temp6],  %[temp5],       24             \n\t"
218      "sll       %[temp1],  %[temp6],       3              \n\t"
219      "subu      %[temp15], %[temp11],      %[hstride]     \n\t"
220      "addu      %[temp2],  %[temp6],       %[temp1]       \n\t"
221      "sll       %[temp3],  %[temp2],       1              \n\t"
222      "addu      %[temp4],  %[temp3],       %[temp2]       \n\t"
223      "addiu     %[temp2],  %[temp2],       63             \n\t"
224      "addiu     %[temp3],  %[temp3],       63             \n\t"
225      "addiu     %[temp4],  %[temp4],       63             \n\t"
226      "sra       %[temp2],  %[temp2],       7              \n\t"
227      "sra       %[temp3],  %[temp3],       7              \n\t"
228      "sra       %[temp4],  %[temp4],       7              \n\t"
229      "addu      %[temp1],  %[temp8],       %[temp2]       \n\t"
230      "addu      %[temp5],  %[temp9],       %[temp3]       \n\t"
231      "addu      %[temp6],  %[temp10],      %[temp4]       \n\t"
232      "subu      %[temp8],  %[temp7],       %[temp4]       \n\t"
233      "subu      %[temp7],  %[temp12],      %[temp3]       \n\t"
234      "addu      %[temp10], %[p],           %[hstride]     \n\t"
235      "subu      %[temp9],  %[temp13],      %[temp2]       \n\t"
236      "addu      %[temp12], %[temp10],      %[hstride]     \n\t"
237      "lbux      %[temp2],  %[temp1](%[VP8kclip1])         \n\t"
238      "lbux      %[temp3],  %[temp5](%[VP8kclip1])         \n\t"
239      "lbux      %[temp4],  %[temp6](%[VP8kclip1])         \n\t"
240      "lbux      %[temp5],  %[temp8](%[VP8kclip1])         \n\t"
241      "lbux      %[temp6],  %[temp7](%[VP8kclip1])         \n\t"
242      "lbux      %[temp8],  %[temp9](%[VP8kclip1])         \n\t"
243      "sb        %[temp2],  0(%[temp15])                   \n\t"
244      "sb        %[temp3],  0(%[temp11])                   \n\t"
245      "sb        %[temp4],  0(%[temp14])                   \n\t"
246      "sb        %[temp5],  0(%[p])                        \n\t"
247      "sb        %[temp6],  0(%[temp10])                   \n\t"
248      "sb        %[temp8],  0(%[temp12])                   \n\t"
249    "3:                                                    \n\t"
250      "bgtz      %[size],   1b                             \n\t"
251      " addu     %[p],      %[p],           %[vstride]     \n\t"
252      ".set      pop                                       \n\t"
253      : [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),[temp3]"=&r"(temp3),
254        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [temp6]"=&r"(temp6),
255        [temp7]"=&r"(temp7),[temp8]"=&r"(temp8),[temp9]"=&r"(temp9),
256        [temp10]"=&r"(temp10),[temp11]"=&r"(temp11),[temp12]"=&r"(temp12),
257        [temp13]"=&r"(temp13),[temp14]"=&r"(temp14),[temp15]"=&r"(temp15),
258        [size]"+&r"(size), [p]"+&r"(p)
259      : [hstride]"r"(hstride), [thresh2]"r"(thresh2),
260        [ithresh]"r"(ithresh),[vstride]"r"(vstride), [hev_thresh]"r"(hev_thresh),
261        [VP8kclip1]"r"(VP8kclip1)
262      : "memory"
263    );
264  }
265  static WEBP_INLINE void FilterLoop24(uint8_t* p,
266                                       int hstride, int vstride, int size,
267                                       int thresh, int ithresh, int hev_thresh) {
268    int p0, q0, p1, q1, p2, q2, p3, q3;
269    int step1, step2, temp1, temp2, temp3, temp4;
270    uint8_t* pTemp0;
271    uint8_t* pTemp1;
272    const int thresh2 = 2 * thresh + 1;
273    __asm__ volatile (
274      ".set      push                                   \n\t"
275      ".set      noreorder                              \n\t"
276      "bltz      %[size],    3f                         \n\t"
277      " nop                                             \n\t"
278    "2:                                                 \n\t"
279      "negu      %[step1],   %[hstride]                 \n\t"
280      "lbu       %[q0],      0(%[p])                    \n\t"
281      "lbux      %[p0],      %[step1](%[p])             \n\t"
282      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
283      "lbux      %[q1],      %[hstride](%[p])           \n\t"
284      "subu      %[temp1],   %[p0],         %[q0]       \n\t"
285      "lbux      %[p1],      %[step1](%[p])             \n\t"
286      "addu      %[step2],   %[hstride],    %[hstride]  \n\t"
287      "absq_s.w  %[temp2],   %[temp1]                   \n\t"
288      "subu      %[temp3],   %[p1],         %[q1]       \n\t"
289      "absq_s.w  %[temp4],   %[temp3]                   \n\t"
290      "sll       %[temp2],   %[temp2],      2           \n\t"
291      "addu      %[temp2],   %[temp2],      %[temp4]    \n\t"
292      "subu      %[temp4],   %[temp2],      %[thresh2]  \n\t"
293      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
294      "bgtz      %[temp4],   0f                         \n\t"
295      " lbux     %[p2],      %[step1](%[p])             \n\t"
296      "subu      %[step1],   %[step1],      %[hstride]  \n\t"
297      "lbux      %[q2],      %[step2](%[p])             \n\t"
298      "lbux      %[p3],      %[step1](%[p])             \n\t"
299      "subu      %[temp4],   %[p2],         %[p1]       \n\t"
300      "addu      %[step2],   %[step2],      %[hstride]  \n\t"
301      "subu      %[temp2],   %[p3],         %[p2]       \n\t"
302      "absq_s.w  %[temp4],   %[temp4]                   \n\t"
303      "absq_s.w  %[temp2],   %[temp2]                   \n\t"
304      "lbux      %[q3],      %[step2](%[p])             \n\t"
305      "subu      %[temp4],   %[temp4],      %[ithresh]  \n\t"
306      "negu      %[temp1],   %[temp1]                   \n\t"
307      "bgtz      %[temp4],   0f                         \n\t"
308      " subu     %[temp2],   %[temp2],      %[ithresh]  \n\t"
309      "subu      %[p3],      %[p1],         %[p0]       \n\t"
310      "bgtz      %[temp2],   0f                         \n\t"
311      " absq_s.w %[p3],      %[p3]                      \n\t"
312      "subu      %[temp4],   %[q3],         %[q2]       \n\t"
313      "subu      %[pTemp0],  %[p],          %[hstride]  \n\t"
314      "absq_s.w  %[temp4],   %[temp4]                   \n\t"
315      "subu      %[temp2],   %[p3],         %[ithresh]  \n\t"
316      "sll       %[step1],   %[temp1],      1           \n\t"
317      "bgtz      %[temp2],   0f                         \n\t"
318      " subu     %[temp4],   %[temp4],      %[ithresh]  \n\t"
319      "subu      %[temp2],   %[q2],         %[q1]       \n\t"
320      "bgtz      %[temp4],   0f                         \n\t"
321      " absq_s.w %[temp2],   %[temp2]                   \n\t"
322      "subu      %[q3],      %[q1],         %[q0]       \n\t"
323      "absq_s.w  %[q3],      %[q3]                      \n\t"
324      "subu      %[temp2],   %[temp2],      %[ithresh]  \n\t"
325      "addu      %[temp1],   %[temp1],      %[step1]    \n\t"
326      "bgtz      %[temp2],   0f                         \n\t"
327      " subu     %[temp4],   %[q3],         %[ithresh]  \n\t"
328      "slt       %[p3],      %[hev_thresh], %[p3]       \n\t"
329      "bgtz      %[temp4],   0f                         \n\t"
330      " slt      %[q3],      %[hev_thresh], %[q3]       \n\t"
331      "or        %[q3],      %[q3],         %[p3]       \n\t"
332      "bgtz      %[q3],      1f                         \n\t"
333      " shra_r.w %[temp2],   %[temp1],      3           \n\t"
334      "addiu     %[temp1],   %[temp1],      3           \n\t"
335      "sra       %[temp1],   %[temp1],      3           \n\t"
336      "shll_s.w  %[temp2],   %[temp2],      27          \n\t"
337      "shll_s.w  %[temp1],   %[temp1],      27          \n\t"
338      "addu      %[pTemp1],  %[p],          %[hstride]  \n\t"
339      "sra       %[temp2],   %[temp2],      27          \n\t"
340      "sra       %[temp1],   %[temp1],      27          \n\t"
341      "addiu     %[step1],   %[temp2],      1           \n\t"
342      "sra       %[step1],   %[step1],      1           \n\t"
343      "addu      %[p0],      %[p0],         %[temp1]    \n\t"
344      "addu      %[p1],      %[p1],         %[step1]    \n\t"
345      "subu      %[q0],      %[q0],         %[temp2]    \n\t"
346      "subu      %[q1],      %[q1],         %[step1]    \n\t"
347      "lbux      %[temp2],   %[p0](%[VP8kclip1])        \n\t"
348      "lbux      %[temp3],   %[q0](%[VP8kclip1])        \n\t"
349      "lbux      %[temp4],   %[q1](%[VP8kclip1])        \n\t"
350      "sb        %[temp2],   0(%[pTemp0])               \n\t"
351      "lbux      %[temp1],   %[p1](%[VP8kclip1])        \n\t"
352      "subu      %[pTemp0],  %[pTemp0],    %[hstride]   \n\t"
353      "sb        %[temp3],   0(%[p])                    \n\t"
354      "sb        %[temp4],   0(%[pTemp1])               \n\t"
355      "j         0f                                     \n\t"
356      " sb       %[temp1],   0(%[pTemp0])               \n\t"
357    "1:                                                 \n\t"
358      "shll_s.w  %[temp3],   %[temp3],      24          \n\t"
359      "sra       %[temp3],   %[temp3],      24          \n\t"
360      "addu      %[temp1],   %[temp1],      %[temp3]    \n\t"
361      "shra_r.w  %[temp2],   %[temp1],      3           \n\t"
362      "addiu     %[temp1],   %[temp1],      3           \n\t"
363      "shll_s.w  %[temp2],   %[temp2],      27          \n\t"
364      "sra       %[temp1],   %[temp1],      3           \n\t"
365      "shll_s.w  %[temp1],   %[temp1],      27          \n\t"
366      "sra       %[temp2],   %[temp2],      27          \n\t"
367      "sra       %[temp1],   %[temp1],      27          \n\t"
368      "addu      %[p0],      %[p0],         %[temp1]    \n\t"
369      "subu      %[q0],      %[q0],         %[temp2]    \n\t"
370      "lbux      %[temp1],   %[p0](%[VP8kclip1])        \n\t"
371      "lbux      %[temp2],   %[q0](%[VP8kclip1])        \n\t"
372      "sb        %[temp2],   0(%[p])                    \n\t"
373      "sb        %[temp1],   0(%[pTemp0])               \n\t"
374    "0:                                                 \n\t"
375      "subu      %[size],    %[size],       1           \n\t"
376      "bgtz      %[size],    2b                         \n\t"
377      " addu     %[p],       %[p],          %[vstride]  \n\t"
378    "3:                                                 \n\t"
379      ".set      pop                                    \n\t"
380      : [p0]"=&r"(p0), [q0]"=&r"(q0), [p1]"=&r"(p1), [q1]"=&r"(q1),
381        [p2]"=&r"(p2), [q2]"=&r"(q2), [p3]"=&r"(p3), [q3]"=&r"(q3),
382        [step2]"=&r"(step2), [step1]"=&r"(step1), [temp1]"=&r"(temp1),
383        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3), [temp4]"=&r"(temp4),
384        [pTemp0]"=&r"(pTemp0), [pTemp1]"=&r"(pTemp1), [p]"+&r"(p),
385        [size]"+&r"(size)
386      : [vstride]"r"(vstride), [ithresh]"r"(ithresh),
387        [hev_thresh]"r"(hev_thresh), [hstride]"r"(hstride),
388        [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
389      : "memory"
390    );
391  }
392  static void VFilter16(uint8_t* p, int stride,
393                        int thresh, int ithresh, int hev_thresh) {
394    FilterLoop26(p, stride, 1, 16, thresh, ithresh, hev_thresh);
395  }
396  static void HFilter16(uint8_t* p, int stride,
397                        int thresh, int ithresh, int hev_thresh) {
398    FilterLoop26(p, 1, stride, 16, thresh, ithresh, hev_thresh);
399  }
400  static void VFilter8(uint8_t* u, uint8_t* v, int stride,
401                       int thresh, int ithresh, int hev_thresh) {
402    FilterLoop26(u, stride, 1, 8, thresh, ithresh, hev_thresh);
403    FilterLoop26(v, stride, 1, 8, thresh, ithresh, hev_thresh);
404  }
405  static void HFilter8(uint8_t* u, uint8_t* v, int stride,
406                       int thresh, int ithresh, int hev_thresh) {
407    FilterLoop26(u, 1, stride, 8, thresh, ithresh, hev_thresh);
408    FilterLoop26(v, 1, stride, 8, thresh, ithresh, hev_thresh);
409  }
410  static void VFilter16i(uint8_t* p, int stride,
411                         int thresh, int ithresh, int hev_thresh) {
412    int k;
<span onclick='openModal()' class='match'>413    for (k = 3; k > 0; --k) {
414      p += 4 * stride;
415      FilterLoop24(p, stride, 1, 16, thresh, ithresh, hev_thresh);
416    }
417  }
418  static void HFilter16i(uint8_t* p, int stride,
</span>419                         int thresh, int ithresh, int hev_thresh) {
420    int k;
421    for (k = 3; k > 0; --k) {
422      p += 4;
423      FilterLoop24(p, 1, stride, 16, thresh, ithresh, hev_thresh);
424    }
425  }
426  static void VFilter8i(uint8_t* u, uint8_t* v, int stride,
427                        int thresh, int ithresh, int hev_thresh) {
428    FilterLoop24(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
429    FilterLoop24(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
430  }
431  static void HFilter8i(uint8_t* u, uint8_t* v, int stride,
432                        int thresh, int ithresh, int hev_thresh) {
433    FilterLoop24(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
434    FilterLoop24(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
435  }
436  #undef MUL
437  static void SimpleVFilter16(uint8_t* p, int stride, int thresh) {
438    int i;
439    const int thresh2 = 2 * thresh + 1;
440    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
441    uint8_t* p1 = p - stride;
442    __asm__ volatile (
443      ".set      push                                      \n\t"
444      ".set      noreorder                                 \n\t"
445      "li        %[i],        16                           \n\t"
446    "0:                                                    \n\t"
447      "negu      %[temp4],    %[stride]                    \n\t"
448      "sll       %[temp5],    %[temp4],       1            \n\t"
449      "lbu       %[temp2],    0(%[p])                      \n\t"
450      "lbux      %[temp3],    %[stride](%[p])              \n\t"
451      "lbux      %[temp1],    %[temp4](%[p])               \n\t"
452      "lbux      %[temp0],    %[temp5](%[p])               \n\t"
453      "subu      %[temp7],    %[temp1],       %[temp2]     \n\t"
454      "subu      %[temp6],    %[temp0],       %[temp3]     \n\t"
455      "absq_s.w  %[temp4],    %[temp7]                     \n\t"
456      "absq_s.w  %[temp5],    %[temp6]                     \n\t"
457      "sll       %[temp4],    %[temp4],       2            \n\t"
458      "subu      %[temp5],    %[temp5],       %[thresh2]   \n\t"
459      "addu      %[temp5],    %[temp4],       %[temp5]     \n\t"
460      "negu      %[temp8],    %[temp7]                     \n\t"
461      "bgtz      %[temp5],    1f                           \n\t"
462      " addiu    %[i],        %[i],           -1           \n\t"
463      "sll       %[temp4],    %[temp8],       1            \n\t"
464      "shll_s.w  %[temp5],    %[temp6],       24           \n\t"
465      "addu      %[temp3],    %[temp4],       %[temp8]     \n\t"
466      "sra       %[temp5],    %[temp5],       24           \n\t"
467      "addu      %[temp3],    %[temp3],       %[temp5]     \n\t"
468      "addiu     %[temp7],    %[temp3],       3            \n\t"
469      "sra       %[temp7],    %[temp7],       3            \n\t"
470      "shra_r.w  %[temp8],    %[temp3],       3            \n\t"
471      "shll_s.w  %[temp0],    %[temp7],       27           \n\t"
472      "shll_s.w  %[temp4],    %[temp8],       27           \n\t"
473      "sra       %[temp0],    %[temp0],       27           \n\t"
474      "sra       %[temp4],    %[temp4],       27           \n\t"
475      "addu      %[temp7],    %[temp1],       %[temp0]     \n\t"
476      "subu      %[temp2],    %[temp2],       %[temp4]     \n\t"
477      "lbux      %[temp3],    %[temp7](%[VP8kclip1])       \n\t"
478      "lbux      %[temp4],    %[temp2](%[VP8kclip1])       \n\t"
479      "sb        %[temp3],    0(%[p1])                     \n\t"
480      "sb        %[temp4],    0(%[p])                      \n\t"
481    "1:                                                    \n\t"
482      "addiu     %[p1],       %[p1],          1            \n\t"
483      "bgtz      %[i],        0b                           \n\t"
484      " addiu    %[p],        %[p],           1            \n\t"
485      " .set     pop                                       \n\t"
486      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
487        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
488        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
489        [p]"+&r"(p), [i]"=&r"(i), [p1]"+&r"(p1)
490      : [stride]"r"(stride), [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
491      : "memory"
492    );
493  }
494  #define LOAD_4_BYTES(TEMP0, TEMP1, TEMP2, TEMP3,                               \
495                       A, A1, B, B1, C, C1, D, D1, SRC)                          \
496    "lbu      %[" #TEMP0 "],   " #A "+" #A1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
497    "lbu      %[" #TEMP1 "],   " #B "+" #B1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
498    "lbu      %[" #TEMP2 "],   " #C "+" #C1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
499    "lbu      %[" #TEMP3 "],   " #D "+" #D1 "*" XSTR(BPS) "(%[" #SRC "]) \n\t"   \
500  
501  static void SimpleHFilter16(uint8_t* p, int stride, int thresh) {
502    int i;
503    const int thresh2 = 2 * thresh + 1;
504    int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;
505    __asm__ volatile (
506      ".set      push                                     \n\t"
507      ".set      noreorder                                \n\t"
508      "li        %[i],       16                           \n\t"
509    "0:                                                   \n\t"
510      LOAD_4_BYTES(temp0, temp1, temp2, temp3, -2, 0, -1, 0, 0, 0, 1, 0, p)
511      "subu      %[temp7],    %[temp1],       %[temp2]    \n\t"
512      "subu      %[temp6],    %[temp0],       %[temp3]    \n\t"
513      "absq_s.w  %[temp4],    %[temp7]                    \n\t"
514      "absq_s.w  %[temp5],    %[temp6]                    \n\t"
515      "sll       %[temp4],    %[temp4],       2           \n\t"
516      "addu      %[temp5],    %[temp4],       %[temp5]    \n\t"
517      "subu      %[temp5],    %[temp5],       %[thresh2]  \n\t"
518      "negu      %[temp8],    %[temp7]                    \n\t"
519      "bgtz      %[temp5],    1f                          \n\t"
520      " addiu    %[i],        %[i],           -1          \n\t"
521      "sll       %[temp4],    %[temp8],       1           \n\t"
522      "shll_s.w  %[temp5],    %[temp6],       24          \n\t"
523      "addu      %[temp3],    %[temp4],       %[temp8]    \n\t"
524      "sra       %[temp5],    %[temp5],       24          \n\t"
525      "addu      %[temp3],    %[temp3],       %[temp5]    \n\t"
526      "addiu     %[temp7],    %[temp3],       3           \n\t"
527      "sra       %[temp7],    %[temp7],       3           \n\t"
528      "shra_r.w  %[temp8],    %[temp3],       3           \n\t"
529      "shll_s.w  %[temp0],    %[temp7],       27          \n\t"
530      "shll_s.w  %[temp4],    %[temp8],       27          \n\t"
531      "sra       %[temp0],    %[temp0],       27          \n\t"
532      "sra       %[temp4],    %[temp4],       27          \n\t"
533      "addu      %[temp7],    %[temp1],       %[temp0]    \n\t"
534      "subu      %[temp2],    %[temp2],       %[temp4]    \n\t"
535      "lbux      %[temp3],    %[temp7](%[VP8kclip1])      \n\t"
536      "lbux      %[temp4],    %[temp2](%[VP8kclip1])      \n\t"
537      "sb        %[temp3],    -1(%[p])                    \n\t"
538      "sb        %[temp4],    0(%[p])                     \n\t"
539    "1:                                                   \n\t"
540      "bgtz      %[i],        0b                          \n\t"
541      " addu     %[p],        %[p],           %[stride]   \n\t"
542      ".set      pop                                      \n\t"
543      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
544        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
545        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
546        [p]"+&r"(p), [i]"=&r"(i)
547      : [stride]"r"(stride), [VP8kclip1]"r"(VP8kclip1), [thresh2]"r"(thresh2)
548      : "memory"
549    );
550  }
551  static void SimpleVFilter16i(uint8_t* p, int stride, int thresh) {
552    int k;
553    for (k = 3; k > 0; --k) {
554      p += 4 * stride;
555      SimpleVFilter16(p, stride, thresh);
556    }
557  }
558  static void SimpleHFilter16i(uint8_t* p, int stride, int thresh) {
559    int k;
560    for (k = 3; k > 0; --k) {
561      p += 4;
562      SimpleHFilter16(p, stride, thresh);
563    }
564  }
565  #define STORE_8_BYTES(TEMP0, TEMP1, A, B, C, DST)                              \
566    "usw    %[" #TEMP0 "],   " #A "*" XSTR(BPS) "(%[" #DST "])         \n\t"     \
567    "usw    %[" #TEMP1 "],   " #B "+" #C "*" XSTR(BPS) "(%[" #DST "])  \n\t"
568  static void VE4(uint8_t* dst) {    
569    const uint8_t* top = dst - BPS;
570    int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
571    __asm__ volatile (
572      "ulw             %[temp0],   -1(%[top])              \n\t"
573      "ulh             %[temp1],   3(%[top])               \n\t"
574      "preceu.ph.qbr   %[temp2],   %[temp0]                \n\t"
575      "preceu.ph.qbl   %[temp3],   %[temp0]                \n\t"
576      "preceu.ph.qbr   %[temp4],   %[temp1]                \n\t"
577      "packrl.ph       %[temp5],   %[temp3],    %[temp2]   \n\t"
578      "packrl.ph       %[temp6],   %[temp4],    %[temp3]   \n\t"
579      "shll.ph         %[temp5],   %[temp5],    1          \n\t"
580      "shll.ph         %[temp6],   %[temp6],    1          \n\t"
581      "addq.ph         %[temp2],   %[temp5],    %[temp2]   \n\t"
582      "addq.ph         %[temp6],   %[temp6],    %[temp4]   \n\t"
583      "addq.ph         %[temp2],   %[temp2],    %[temp3]   \n\t"
584      "addq.ph         %[temp6],   %[temp6],    %[temp3]   \n\t"
585      "shra_r.ph       %[temp2],   %[temp2],    2          \n\t"
586      "shra_r.ph       %[temp6],   %[temp6],    2          \n\t"
587      "precr.qb.ph     %[temp4],   %[temp6],    %[temp2]   \n\t"
588      STORE_8_BYTES(temp4, temp4, 0, 0, 1, dst)
589      STORE_8_BYTES(temp4, temp4, 2, 0, 3, dst)
590      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
591        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
592        [temp6]"=&r"(temp6)
593      : [top]"r"(top), [dst]"r"(dst)
594      : "memory"
595    );
596  }
597  static void DC4(uint8_t* dst) {   
598    int temp0, temp1, temp2, temp3, temp4;
599    __asm__ volatile (
600      "ulw          %[temp0],   -1*" XSTR(BPS) "(%[dst]) \n\t"
601      LOAD_4_BYTES(temp1, temp2, temp3, temp4, -1, 0, -1, 1, -1, 2, -1, 3, dst)
602      "ins          %[temp1],   %[temp2],    8,     8    \n\t"
603      "ins          %[temp1],   %[temp3],    16,    8    \n\t"
604      "ins          %[temp1],   %[temp4],    24,    8    \n\t"
605      "raddu.w.qb   %[temp0],   %[temp0]                 \n\t"
606      "raddu.w.qb   %[temp1],   %[temp1]                 \n\t"
607      "addu         %[temp0],   %[temp0],    %[temp1]    \n\t"
608      "shra_r.w     %[temp0],   %[temp0],    3           \n\t"
609      "replv.qb     %[temp0],   %[temp0]                 \n\t"
610      STORE_8_BYTES(temp0, temp0, 0, 0, 1, dst)
611      STORE_8_BYTES(temp0, temp0, 2, 0, 3, dst)
612      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
613        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4)
614      : [dst]"r"(dst)
615      : "memory"
616    );
617  }
618  static void RD4(uint8_t* dst) {   
619    int temp0, temp1, temp2, temp3, temp4;
620    int temp5, temp6, temp7, temp8;
621    __asm__ volatile (
622      LOAD_4_BYTES(temp0, temp1, temp2, temp3, -1, 0, -1, 1, -1, 2, -1, 3, dst)
623      "ulw            %[temp7],   -1-" XSTR(BPS) "(%[dst])       \n\t"
624      "ins            %[temp1],   %[temp0], 16, 16               \n\t"
625      "preceu.ph.qbr  %[temp5],   %[temp7]                       \n\t"
626      "ins            %[temp2],   %[temp1], 16, 16               \n\t"
627      "preceu.ph.qbl  %[temp4],   %[temp7]                       \n\t"
628      "ins            %[temp3],   %[temp2], 16, 16               \n\t"
629      "shll.ph        %[temp2],   %[temp2], 1                    \n\t"
630      "addq.ph        %[temp3],   %[temp3], %[temp1]             \n\t"
631      "packrl.ph      %[temp6],   %[temp5], %[temp1]             \n\t"
632      "addq.ph        %[temp3],   %[temp3], %[temp2]             \n\t"
633      "addq.ph        %[temp1],   %[temp1], %[temp5]             \n\t"
634      "shll.ph        %[temp6],   %[temp6], 1                    \n\t"
635      "addq.ph        %[temp1],   %[temp1], %[temp6]             \n\t"
636      "packrl.ph      %[temp0],   %[temp4], %[temp5]             \n\t"
637      "addq.ph        %[temp8],   %[temp5], %[temp4]             \n\t"
638      "shra_r.ph      %[temp3],   %[temp3], 2                    \n\t"
639      "shll.ph        %[temp0],   %[temp0], 1                    \n\t"
640      "shra_r.ph      %[temp1],   %[temp1], 2                    \n\t"
641      "addq.ph        %[temp8],   %[temp0], %[temp8]             \n\t"
642      "lbu            %[temp5],   3-" XSTR(BPS) "(%[dst])        \n\t"
643      "precrq.ph.w    %[temp7],   %[temp7], %[temp7]             \n\t"
644      "shra_r.ph      %[temp8],   %[temp8], 2                    \n\t"
645      "ins            %[temp7],   %[temp5], 0,  8                \n\t"
646      "precr.qb.ph    %[temp2],   %[temp1], %[temp3]             \n\t"
647      "raddu.w.qb     %[temp4],   %[temp7]                       \n\t"
648      "precr.qb.ph    %[temp6],   %[temp8], %[temp1]             \n\t"
649      "shra_r.w       %[temp4],   %[temp4], 2                    \n\t"
650      STORE_8_BYTES(temp2, temp6, 3, 0, 1, dst)
651      "prepend        %[temp2],   %[temp8], 8                    \n\t"
652      "prepend        %[temp6],   %[temp4], 8                    \n\t"
653      STORE_8_BYTES(temp2, temp6, 2, 0, 0, dst)
654      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
655        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
656        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8)
657      : [dst]"r"(dst)
658      : "memory"
659    );
660  }
661  #define LOAD_8_BYTES(TEMP0, TEMP1, A, B, C, SRC)                               \
662    "ulw    %[" #TEMP0 "],   " #A "*" XSTR(BPS) "(%[" #SRC "])         \n\t"     \
663    "ulw    %[" #TEMP1 "],   " #B "+" #C "*" XSTR(BPS) "(%[" #SRC "])  \n\t"
664  static void LD4(uint8_t* dst) {   
665    int temp0, temp1, temp2, temp3, temp4;
666    int temp5, temp6, temp7, temp8, temp9;
667    __asm__ volatile (
668      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
669      "preceu.ph.qbl   %[temp2],    %[temp0]                     \n\t"
670      "preceu.ph.qbr   %[temp3],    %[temp0]                     \n\t"
671      "preceu.ph.qbr   %[temp4],    %[temp1]                     \n\t"
672      "preceu.ph.qbl   %[temp5],    %[temp1]                     \n\t"
673      "packrl.ph       %[temp6],    %[temp2],    %[temp3]        \n\t"
674      "packrl.ph       %[temp7],    %[temp4],    %[temp2]        \n\t"
675      "packrl.ph       %[temp8],    %[temp5],    %[temp4]        \n\t"
676      "shll.ph         %[temp6],    %[temp6],    1               \n\t"
677      "addq.ph         %[temp9],    %[temp2],    %[temp6]        \n\t"
678      "shll.ph         %[temp7],    %[temp7],    1               \n\t"
679      "addq.ph         %[temp9],    %[temp9],    %[temp3]        \n\t"
680      "shll.ph         %[temp8],    %[temp8],    1               \n\t"
681      "shra_r.ph       %[temp9],    %[temp9],    2               \n\t"
682      "addq.ph         %[temp3],    %[temp4],    %[temp7]        \n\t"
683      "addq.ph         %[temp0],    %[temp5],    %[temp8]        \n\t"
684      "addq.ph         %[temp3],    %[temp3],    %[temp2]        \n\t"
685      "addq.ph         %[temp0],    %[temp0],    %[temp4]        \n\t"
686      "shra_r.ph       %[temp3],    %[temp3],    2               \n\t"
687      "shra_r.ph       %[temp0],    %[temp0],    2               \n\t"
688      "srl             %[temp1],    %[temp1],    24              \n\t"
689      "sll             %[temp1],    %[temp1],    1               \n\t"
690      "raddu.w.qb      %[temp5],    %[temp5]                     \n\t"
691      "precr.qb.ph     %[temp9],    %[temp3],    %[temp9]        \n\t"
692      "precr.qb.ph     %[temp3],    %[temp0],    %[temp3]        \n\t"
693      "addu            %[temp1],    %[temp1],    %[temp5]        \n\t"
694      "shra_r.w        %[temp1],    %[temp1],    2               \n\t"
695      STORE_8_BYTES(temp9, temp3, 0, 0, 2, dst)
696      "prepend         %[temp9],    %[temp0],    8               \n\t"
697      "prepend         %[temp3],    %[temp1],    8               \n\t"
698      STORE_8_BYTES(temp9, temp3, 1, 0, 3, dst)
699      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
700        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
701        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
702        [temp9]"=&r"(temp9)
703      : [dst]"r"(dst)
704      : "memory"
705    );
706  }
707  static void DC8uv(uint8_t* dst) {     
708    int temp0, temp1, temp2, temp3, temp4;
709    int temp5, temp6, temp7, temp8, temp9;
710    __asm__ volatile (
711      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
712      LOAD_4_BYTES(temp2, temp3, temp4, temp5, -1, 0, -1, 1, -1, 2, -1, 3, dst)
713      LOAD_4_BYTES(temp6, temp7, temp8, temp9, -1, 4, -1, 5, -1, 6, -1, 7, dst)
714      "raddu.w.qb   %[temp0],   %[temp0]                   \n\t"
715      "raddu.w.qb   %[temp1],   %[temp1]                   \n\t"
716      "addu         %[temp2],   %[temp2],    %[temp3]      \n\t"
717      "addu         %[temp4],   %[temp4],    %[temp5]      \n\t"
718      "addu         %[temp6],   %[temp6],    %[temp7]      \n\t"
719      "addu         %[temp8],   %[temp8],    %[temp9]      \n\t"
720      "addu         %[temp0],   %[temp0],    %[temp1]      \n\t"
721      "addu         %[temp2],   %[temp2],    %[temp4]      \n\t"
722      "addu         %[temp6],   %[temp6],    %[temp8]      \n\t"
723      "addu         %[temp0],   %[temp0],    %[temp2]      \n\t"
724      "addu         %[temp0],   %[temp0],    %[temp6]      \n\t"
725      "shra_r.w     %[temp0],   %[temp0],    4             \n\t"
726      "replv.qb     %[temp0],   %[temp0]                   \n\t"
727      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
728      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
729      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
730      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
731      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
732      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
733      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
734      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
735      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
736        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
737        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8),
738        [temp9]"=&r"(temp9)
739      : [dst]"r"(dst)
740      : "memory"
741    );
742  }
743  static void DC8uvNoLeft(uint8_t* dst) {   
744    int temp0, temp1;
745    __asm__ volatile (
746      LOAD_8_BYTES(temp0, temp1, -1, 4, -1, dst)
747      "raddu.w.qb   %[temp0],   %[temp0]                   \n\t"
748      "raddu.w.qb   %[temp1],   %[temp1]                   \n\t"
749      "addu         %[temp0],   %[temp0],    %[temp1]      \n\t"
750      "shra_r.w     %[temp0],   %[temp0],    3             \n\t"
751      "replv.qb     %[temp0],   %[temp0]                   \n\t"
752      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
753      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
754      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
755      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
756      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
757      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
758      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
759      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
760      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1)
761      : [dst]"r"(dst)
762      : "memory"
763    );
764  }
765  static void DC8uvNoTop(uint8_t* dst) {  
766    int temp0, temp1, temp2, temp3, temp4;
767    int temp5, temp6, temp7, temp8;
768    __asm__ volatile (
769      LOAD_4_BYTES(temp2, temp3, temp4, temp5, -1, 0, -1, 1, -1, 2, -1, 3, dst)
770      LOAD_4_BYTES(temp6, temp7, temp8, temp1, -1, 4, -1, 5, -1, 6, -1, 7, dst)
771      "addu         %[temp2],   %[temp2],    %[temp3]      \n\t"
772      "addu         %[temp4],   %[temp4],    %[temp5]      \n\t"
773      "addu         %[temp6],   %[temp6],    %[temp7]      \n\t"
774      "addu         %[temp8],   %[temp8],    %[temp1]      \n\t"
775      "addu         %[temp2],   %[temp2],    %[temp4]      \n\t"
776      "addu         %[temp6],   %[temp6],    %[temp8]      \n\t"
777      "addu         %[temp0],   %[temp6],    %[temp2]      \n\t"
778      "shra_r.w     %[temp0],   %[temp0],    3             \n\t"
779      "replv.qb     %[temp0],   %[temp0]                   \n\t"
780      STORE_8_BYTES(temp0, temp0, 0, 4, 0, dst)
781      STORE_8_BYTES(temp0, temp0, 1, 4, 1, dst)
782      STORE_8_BYTES(temp0, temp0, 2, 4, 2, dst)
783      STORE_8_BYTES(temp0, temp0, 3, 4, 3, dst)
784      STORE_8_BYTES(temp0, temp0, 4, 4, 4, dst)
785      STORE_8_BYTES(temp0, temp0, 5, 4, 5, dst)
786      STORE_8_BYTES(temp0, temp0, 6, 4, 6, dst)
787      STORE_8_BYTES(temp0, temp0, 7, 4, 7, dst)
788      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
789        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
790        [temp6]"=&r"(temp6), [temp7]"=&r"(temp7), [temp8]"=&r"(temp8)
791      : [dst]"r"(dst)
792      : "memory"
793    );
794  }
795  #undef LOAD_8_BYTES
796  #undef STORE_8_BYTES
797  #undef LOAD_4_BYTES
798  #define CLIPPING(SIZE)                                                         \
799    "preceu.ph.qbl   %[temp2],   %[temp0]                  \n\t"                 \
800    "preceu.ph.qbr   %[temp0],   %[temp0]                  \n\t"                 \
801  ".if " #SIZE " == 8                                      \n\t"                 \
802    "preceu.ph.qbl   %[temp3],   %[temp1]                  \n\t"                 \
803    "preceu.ph.qbr   %[temp1],   %[temp1]                  \n\t"                 \
804  ".endif                                                  \n\t"                 \
805    "addu.ph         %[temp2],   %[temp2],   %[dst_1]      \n\t"                 \
806    "addu.ph         %[temp0],   %[temp0],   %[dst_1]      \n\t"                 \
807  ".if " #SIZE " == 8                                      \n\t"                 \
808    "addu.ph         %[temp3],   %[temp3],   %[dst_1]      \n\t"                 \
809    "addu.ph         %[temp1],   %[temp1],   %[dst_1]      \n\t"                 \
810  ".endif                                                  \n\t"                 \
811    "shll_s.ph       %[temp2],   %[temp2],   7             \n\t"                 \
812    "shll_s.ph       %[temp0],   %[temp0],   7             \n\t"                 \
813  ".if " #SIZE " == 8                                      \n\t"                 \
814    "shll_s.ph       %[temp3],   %[temp3],   7             \n\t"                 \
815    "shll_s.ph       %[temp1],   %[temp1],   7             \n\t"                 \
816  ".endif                                                  \n\t"                 \
817    "precrqu_s.qb.ph %[temp0],   %[temp2],   %[temp0]      \n\t"                 \
818  ".if " #SIZE " == 8                                      \n\t"                 \
819    "precrqu_s.qb.ph %[temp1],   %[temp3],   %[temp1]      \n\t"                 \
820  ".endif                                                  \n\t"
821  #define CLIP_8B_TO_DST(DST, TOP, SIZE) do {                                    \
822    int dst_1 = ((int)(DST)[-1] << 16) + (DST)[-1];                              \
823    int temp0, temp1, temp2, temp3;                                              \
824    __asm__ volatile (                                                           \
825    ".if " #SIZE " < 8                                     \n\t"                 \
826      "ulw             %[temp0],   0(%[top])               \n\t"                 \
827      "subu.ph         %[dst_1],   %[dst_1],    %[top_1]   \n\t"                 \
828      CLIPPING(4)                                                                \
829      "usw             %[temp0],   0(%[dst])               \n\t"                 \
830    ".else                                                 \n\t"                 \
831      "ulw             %[temp0],   0(%[top])               \n\t"                 \
832      "ulw             %[temp1],   4(%[top])               \n\t"                 \
833      "subu.ph         %[dst_1],   %[dst_1],    %[top_1]   \n\t"                 \
834      CLIPPING(8)                                                                \
835      "usw             %[temp0],   0(%[dst])               \n\t"                 \
836      "usw             %[temp1],   4(%[dst])               \n\t"                 \
837    ".if " #SIZE " == 16                                   \n\t"                 \
838      "ulw             %[temp0],   8(%[top])               \n\t"                 \
839      "ulw             %[temp1],   12(%[top])              \n\t"                 \
840      CLIPPING(8)                                                                \
841      "usw             %[temp0],   8(%[dst])               \n\t"                 \
842      "usw             %[temp1],   12(%[dst])              \n\t"                 \
843    ".endif                                                \n\t"                 \
844    ".endif                                                \n\t"                 \
845      : [dst_1]"+&r"(dst_1), [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),           \
846        [temp2]"=&r"(temp2), [temp3]"=&r"(temp3)                                 \
847      : [top_1]"r"(top_1), [top]"r"((TOP)), [dst]"r"((DST))                      \
848      : "memory"                                                                 \
849    );                                                                           \
850  } while (0)
851  #define CLIP_TO_DST(DST, SIZE) do {                                            \
852    int y;                                                                       \
853    const uint8_t* top = (DST) - BPS;                                            \
854    const int top_1 = ((int)top[-1] << 16) + top[-1];                            \
855    for (y = 0; y < (SIZE); ++y) {                                               \
856      CLIP_8B_TO_DST((DST), top, (SIZE));                                        \
857      (DST) += BPS;                                                              \
858    }                                                                            \
859  } while (0)
860  #define TRUE_MOTION(DST, SIZE)                                                 \
861  static void TrueMotion##SIZE(uint8_t* (DST)) {                                 \
862    CLIP_TO_DST((DST), (SIZE));                                                  \
863  }
864  TRUE_MOTION(dst, 4)
865  TRUE_MOTION(dst, 8)
866  TRUE_MOTION(dst, 16)
867  #undef TRUE_MOTION
868  #undef CLIP_TO_DST
869  #undef CLIP_8B_TO_DST
870  #undef CLIPPING
871  extern void VP8DspInitMIPSdspR2(void);
872  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitMIPSdspR2(void) {
873    VP8TransformDC = TransformDC;
874    VP8TransformAC3 = TransformAC3;
875    VP8Transform = TransformTwo;
876    VP8VFilter16 = VFilter16;
877    VP8HFilter16 = HFilter16;
878    VP8VFilter8 = VFilter8;
879    VP8HFilter8 = HFilter8;
880    VP8VFilter16i = VFilter16i;
881    VP8HFilter16i = HFilter16i;
882    VP8VFilter8i = VFilter8i;
883    VP8HFilter8i = HFilter8i;
884    VP8SimpleVFilter16 = SimpleVFilter16;
885    VP8SimpleHFilter16 = SimpleHFilter16;
886    VP8SimpleVFilter16i = SimpleVFilter16i;
887    VP8SimpleHFilter16i = SimpleHFilter16i;
888    VP8PredLuma4[0] = DC4;
889    VP8PredLuma4[1] = TrueMotion4;
890    VP8PredLuma4[2] = VE4;
891    VP8PredLuma4[4] = RD4;
892    VP8PredLuma4[6] = LD4;
893    VP8PredChroma8[0] = DC8uv;
894    VP8PredChroma8[1] = TrueMotion8;
895    VP8PredChroma8[4] = DC8uvNoTop;
896    VP8PredChroma8[5] = DC8uvNoLeft;
897    VP8PredLuma16[1] = TrueMotion16;
898  }
899  #else  
900  WEBP_DSP_INIT_STUB(VP8DspInitMIPSdspR2)
901  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2B
3  enum blake2b_constant {
4     BLAKE2B_BLOCKBYTES = 128,
5     BLAKE2B_OUTBYTES = 64,
6     BLAKE2B_KEYBYTES = 64,
7     BLAKE2B_SALTBYTES = 16,
8     BLAKE2B_PERSONALBYTES = 16,
9     BLAKE2B_PARAM_SIZE = 64
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 16,
20     O_INNER_LENGTH = 17,
21     O_RESERVED = 18,
22     O_SALT = 32,
23     O_PERSONAL = 48
24  };
25  const struct ltc_hash_descriptor blake2b_160_desc =
26  {
27      "blake2b-160",
28      25,
29      20,
30      128,
31      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 5 },
32      11,
33      &blake2b_160_init,
34      &blake2b_process,
35      &blake2b_done,
36      &blake2b_160_test,
37      NULL
38  };
39  const struct ltc_hash_descriptor blake2b_256_desc =
40  {
41      "blake2b-256",
42      26,
43      32,
44      128,
45      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 8 },
46      11,
47      &blake2b_256_init,
48      &blake2b_process,
49      &blake2b_done,
50      &blake2b_256_test,
51      NULL
52  };
53  const struct ltc_hash_descriptor blake2b_384_desc =
54  {
55      "blake2b-384",
56      27,
57      48,
58      128,
59      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 12 },
60      11,
61      &blake2b_384_init,
62      &blake2b_process,
63      &blake2b_done,
64      &blake2b_384_test,
65      NULL
66  };
67  const struct ltc_hash_descriptor blake2b_512_desc =
68  {
69      "blake2b-512",
70      28,
71      64,
72      128,
73      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 1, 16 },
74      11,
75      &blake2b_512_init,
76      &blake2b_process,
77      &blake2b_done,
78      &blake2b_512_test,
79      NULL
80  };
81  static const ulong64 blake2b_IV[8] =
82  {
83    CONST64(0x6a09e667f3bcc908), CONST64(0xbb67ae8584caa73b),
84    CONST64(0x3c6ef372fe94f82b), CONST64(0xa54ff53a5f1d36f1),
85    CONST64(0x510e527fade682d1), CONST64(0x9b05688c2b3e6c1f),
86    CONST64(0x1f83d9abfb41bd6b), CONST64(0x5be0cd19137e2179)
87  };
88  static const unsigned char blake2b_sigma[12][16] =
89  {
90    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
91    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,
92    { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,
93    {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,
94    {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,
95    {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,
96    { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,
97    { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,
98    {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,
99    { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,
100    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,
101    { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }
102  };
103  static void s_blake2b_set_lastnode(hash_state *md) { md->blake2b.f[1] = CONST64(0xffffffffffffffff); }
104  static int s_blake2b_is_lastblock(const hash_state *md) { return md->blake2b.f[0] != 0; }
105  static void s_blake2b_set_lastblock(hash_state *md)
106  {
107     if (md->blake2b.last_node) {
108        s_blake2b_set_lastnode(md);
109     }
110     md->blake2b.f[0] = CONST64(0xffffffffffffffff);
111  }
112  static void s_blake2b_increment_counter(hash_state *md, ulong64 inc)
113  {
114     md->blake2b.t[0] += inc;
115     if (md->blake2b.t[0] < inc) md->blake2b.t[1]++;
116  }
117  static void s_blake2b_init0(hash_state *md)
118  {
119     unsigned long i;
120     XMEMSET(&md->blake2b, 0, sizeof(md->blake2b));
<span onclick='openModal()' class='match'>121     for (i = 0; i < 8; ++i) {
122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
125  static int s_blake2b_init_param(hash_state *md, const unsigned char *P)
</span>126  {
127     unsigned long i;
128     s_blake2b_init0(md);
129     for (i = 0; i < 8; ++i) {
130        ulong64 tmp;
131        LOAD64L(tmp, P + i * 8);
132        md->blake2b.h[i] ^= tmp;
133     }
134     md->blake2b.outlen = P[O_DIGEST_LENGTH];
135     return CRYPT_OK;
136  }
137  int blake2b_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
138  {
139     unsigned char P[BLAKE2B_PARAM_SIZE];
140     int err;
141     LTC_ARGCHK(md != NULL);
142     if ((!outlen) || (outlen > BLAKE2B_OUTBYTES)) {
143        return CRYPT_INVALID_ARG;
144     }
145     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2B_KEYBYTES)) {
146        return CRYPT_INVALID_ARG;
147     }
148     XMEMSET(P, 0, sizeof(P));
149     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
150     P[O_KEY_LENGTH] = (unsigned char)keylen;
151     P[O_FANOUT] = 1;
152     P[O_DEPTH] = 1;
153     err = s_blake2b_init_param(md, P);
154     if (err != CRYPT_OK) return err;
155     if (key) {
156        unsigned char block[BLAKE2B_BLOCKBYTES];
157        XMEMSET(block, 0, BLAKE2B_BLOCKBYTES);
158        XMEMCPY(block, key, keylen);
159        blake2b_process(md, block, BLAKE2B_BLOCKBYTES);
160  #ifdef LTC_CLEAN_STACK
161        zeromem(block, sizeof(block));
162  #endif
163     }
164     return CRYPT_OK;
165  }
166  int blake2b_160_init(hash_state *md) { return blake2b_init(md, 20, NULL, 0); }
167  int blake2b_256_init(hash_state *md) { return blake2b_init(md, 32, NULL, 0); }
168  int blake2b_384_init(hash_state *md) { return blake2b_init(md, 48, NULL, 0); }
169  int blake2b_512_init(hash_state *md) { return blake2b_init(md, 64, NULL, 0); }
170  #define G(r, i, a, b, c, d)                                                                                            \
171     do {                                                                                                                \
172        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                                                                      \
173        d = ROR64(d ^ a, 32);                                                                                            \
174        c = c + d;                                                                                                       \
175        b = ROR64(b ^ c, 24);                                                                                            \
176        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                                                                      \
177        d = ROR64(d ^ a, 16);                                                                                            \
178        c = c + d;                                                                                                       \
179        b = ROR64(b ^ c, 63);                                                                                            \
180     } while (0)
181  #define ROUND(r)                                                                                                       \
182     do {                                                                                                                \
183        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
184        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
185        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
186        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
187        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
188        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
189        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
190        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
191     } while (0)
192  #ifdef LTC_CLEAN_STACK
193  static int ss_blake2b_compress(hash_state *md, const unsigned char *buf)
194  #else
195  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
196  #endif
197  {
198     ulong64 m[16];
199     ulong64 v[16];
200     unsigned long i;
201     for (i = 0; i < 16; ++i) {
202        LOAD64L(m[i], buf + i * sizeof(m[i]));
203     }
204     for (i = 0; i < 8; ++i) {
205        v[i] = md->blake2b.h[i];
206     }
207     v[8] = blake2b_IV[0];
208     v[9] = blake2b_IV[1];
209     v[10] = blake2b_IV[2];
210     v[11] = blake2b_IV[3];
211     v[12] = blake2b_IV[4] ^ md->blake2b.t[0];
212     v[13] = blake2b_IV[5] ^ md->blake2b.t[1];
213     v[14] = blake2b_IV[6] ^ md->blake2b.f[0];
214     v[15] = blake2b_IV[7] ^ md->blake2b.f[1];
215     ROUND(0);
216     ROUND(1);
217     ROUND(2);
218     ROUND(3);
219     ROUND(4);
220     ROUND(5);
221     ROUND(6);
222     ROUND(7);
223     ROUND(8);
224     ROUND(9);
225     ROUND(10);
226     ROUND(11);
227     for (i = 0; i < 8; ++i) {
228        md->blake2b.h[i] = md->blake2b.h[i] ^ v[i] ^ v[i + 8];
229     }
230     return CRYPT_OK;
231  }
232  #undef G
233  #undef ROUND
234  #ifdef LTC_CLEAN_STACK
235  static int s_blake2b_compress(hash_state *md, const unsigned char *buf)
236  {
237     int err;
238     err = ss_blake2b_compress(md, buf);
239     burn_stack(sizeof(ulong64) * 32 + sizeof(unsigned long));
240     return err;
241  }
242  #endif
243  int blake2b_process(hash_state *md, const unsigned char *in, unsigned long inlen)
244  {
245     LTC_ARGCHK(md != NULL);
246     LTC_ARGCHK(in != NULL);
247     if (md->blake2b.curlen > sizeof(md->blake2b.buf)) {
248        return CRYPT_INVALID_ARG;
249     }
250     if (inlen > 0) {
251        unsigned long left = md->blake2b.curlen;
252        unsigned long fill = BLAKE2B_BLOCKBYTES - left;
253        if (inlen > fill) {
254           md->blake2b.curlen = 0;
255           XMEMCPY(md->blake2b.buf + (left % sizeof(md->blake2b.buf)), in, fill); &bsol;* Fill buffer */
256           s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
257           s_blake2b_compress(md, md->blake2b.buf); &bsol;* Compress */
258           in += fill;
259           inlen -= fill;
260           while (inlen > BLAKE2B_BLOCKBYTES) {
261              s_blake2b_increment_counter(md, BLAKE2B_BLOCKBYTES);
262              s_blake2b_compress(md, in);
263              in += BLAKE2B_BLOCKBYTES;
264              inlen -= BLAKE2B_BLOCKBYTES;
265           }
266        }
267        XMEMCPY(md->blake2b.buf + md->blake2b.curlen, in, inlen);
268        md->blake2b.curlen += inlen;
269     }
270     return CRYPT_OK;
271  }
272  int blake2b_done(hash_state *md, unsigned char *out)
273  {
274     unsigned char buffer[BLAKE2B_OUTBYTES] = { 0 };
275     unsigned long i;
276     LTC_ARGCHK(md != NULL);
277     LTC_ARGCHK(out != NULL);
278     if (s_blake2b_is_lastblock(md)) {
279        return CRYPT_ERROR;
280     }
281     s_blake2b_increment_counter(md, md->blake2b.curlen);
282     s_blake2b_set_lastblock(md);
283     XMEMSET(md->blake2b.buf + md->blake2b.curlen, 0, BLAKE2B_BLOCKBYTES - md->blake2b.curlen); &bsol;* Padding */
284     s_blake2b_compress(md, md->blake2b.buf);
285     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
286        STORE64L(md->blake2b.h[i], buffer + i * 8);
287     }
288     XMEMCPY(out, buffer, md->blake2b.outlen);
289     zeromem(md, sizeof(hash_state));
290  #ifdef LTC_CLEAN_STACK
291     zeromem(buffer, sizeof(buffer));
292  #endif
293     return CRYPT_OK;
294  }
295  int blake2b_512_test(void)
296  {
297  #ifndef LTC_TEST
298     return CRYPT_NOP;
299  #else
300     static const struct {
301        const char *msg;
302        unsigned char hash[64];
303    } tests[] = {
304      { "",
305        { 0x78, 0x6a, 0x02, 0xf7, 0x42, 0x01, 0x59, 0x03,
306          0xc6, 0xc6, 0xfd, 0x85, 0x25, 0x52, 0xd2, 0x72,
307          0x91, 0x2f, 0x47, 0x40, 0xe1, 0x58, 0x47, 0x61,
308          0x8a, 0x86, 0xe2, 0x17, 0xf7, 0x1f, 0x54, 0x19,
309          0xd2, 0x5e, 0x10, 0x31, 0xaf, 0xee, 0x58, 0x53,
310          0x13, 0x89, 0x64, 0x44, 0x93, 0x4e, 0xb0, 0x4b,
311          0x90, 0x3a, 0x68, 0x5b, 0x14, 0x48, 0xb7, 0x55,
312          0xd5, 0x6f, 0x70, 0x1a, 0xfe, 0x9b, 0xe2, 0xce } },
313      { "abc",
314        { 0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d,
315          0x6a, 0x27, 0x97, 0xb6, 0x9f, 0x12, 0xf6, 0xe9,
316          0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a, 0xc4, 0xb7,
317          0x4b, 0x12, 0xbb, 0x6f, 0xdb, 0xff, 0xa2, 0xd1,
318          0x7d, 0x87, 0xc5, 0x39, 0x2a, 0xab, 0x79, 0x2d,
319          0xc2, 0x52, 0xd5, 0xde, 0x45, 0x33, 0xcc, 0x95,
320          0x18, 0xd3, 0x8a, 0xa8, 0xdb, 0xf1, 0x92, 0x5a,
321          0xb9, 0x23, 0x86, 0xed, 0xd4, 0x00, 0x99, 0x23 } },
322      { NULL, { 0 } }
323    };
324     int i;
325     unsigned char tmp[64];
326     hash_state md;
327     for (i = 0; tests[i].msg != NULL; i++) {
328        blake2b_512_init(&md);
329        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
330        blake2b_done(&md, tmp);
331        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_512", i)) {
332           return CRYPT_FAIL_TESTVECTOR;
333        }
334     }
335     return CRYPT_OK;
336  #endif
337  }
338  int blake2b_384_test(void)
339  {
340  #ifndef LTC_TEST
341     return CRYPT_NOP;
342  #else
343     static const struct {
344        const char *msg;
345        unsigned char hash[48];
346    } tests[] = {
347      { "",
348        { 0xb3, 0x28, 0x11, 0x42, 0x33, 0x77, 0xf5, 0x2d,
349          0x78, 0x62, 0x28, 0x6e, 0xe1, 0xa7, 0x2e, 0xe5,
350          0x40, 0x52, 0x43, 0x80, 0xfd, 0xa1, 0x72, 0x4a,
351          0x6f, 0x25, 0xd7, 0x97, 0x8c, 0x6f, 0xd3, 0x24,
352          0x4a, 0x6c, 0xaf, 0x04, 0x98, 0x81, 0x26, 0x73,
353          0xc5, 0xe0, 0x5e, 0xf5, 0x83, 0x82, 0x51, 0x00 } },
354      { "abc",
355        { 0x6f, 0x56, 0xa8, 0x2c, 0x8e, 0x7e, 0xf5, 0x26,
356          0xdf, 0xe1, 0x82, 0xeb, 0x52, 0x12, 0xf7, 0xdb,
357          0x9d, 0xf1, 0x31, 0x7e, 0x57, 0x81, 0x5d, 0xbd,
358          0xa4, 0x60, 0x83, 0xfc, 0x30, 0xf5, 0x4e, 0xe6,
359          0xc6, 0x6b, 0xa8, 0x3b, 0xe6, 0x4b, 0x30, 0x2d,
360          0x7c, 0xba, 0x6c, 0xe1, 0x5b, 0xb5, 0x56, 0xf4 } },
361      { NULL, { 0 } }
362    };
363     int i;
364     unsigned char tmp[48];
365     hash_state md;
366     for (i = 0; tests[i].msg != NULL; i++) {
367        blake2b_384_init(&md);
368        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
369        blake2b_done(&md, tmp);
370        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_384", i)) {
371           return CRYPT_FAIL_TESTVECTOR;
372        }
373     }
374     return CRYPT_OK;
375  #endif
376  }
377  int blake2b_256_test(void)
378  {
379  #ifndef LTC_TEST
380     return CRYPT_NOP;
381  #else
382     static const struct {
383        const char *msg;
384        unsigned char hash[32];
385    } tests[] = {
386      { "",
387        { 0x0e, 0x57, 0x51, 0xc0, 0x26, 0xe5, 0x43, 0xb2,
388          0xe8, 0xab, 0x2e, 0xb0, 0x60, 0x99, 0xda, 0xa1,
389          0xd1, 0xe5, 0xdf, 0x47, 0x77, 0x8f, 0x77, 0x87,
390          0xfa, 0xab, 0x45, 0xcd, 0xf1, 0x2f, 0xe3, 0xa8 } },
391      { "abc",
392        { 0xbd, 0xdd, 0x81, 0x3c, 0x63, 0x42, 0x39, 0x72,
393          0x31, 0x71, 0xef, 0x3f, 0xee, 0x98, 0x57, 0x9b,
394          0x94, 0x96, 0x4e, 0x3b, 0xb1, 0xcb, 0x3e, 0x42,
395          0x72, 0x62, 0xc8, 0xc0, 0x68, 0xd5, 0x23, 0x19 } },
396      { "12345678901234567890123456789012345678901234567890"
397        "12345678901234567890123456789012345678901234567890"
398        "12345678901234567890123456789012345678901234567890"
399        "12345678901234567890123456789012345678901234567890"
400        "12345678901234567890123456789012345678901234567890"
401        "12345678901234567890123456789012345678901234567890",
402        { 0x0f, 0x6e, 0x01, 0x8d, 0x38, 0xd6, 0x3f, 0x08,
403          0x4d, 0x58, 0xe3, 0x0c, 0x90, 0xfb, 0xa2, 0x41,
404          0x5f, 0xca, 0x17, 0xfa, 0x66, 0x26, 0x49, 0xf3,
405          0x8a, 0x30, 0x41, 0x7c, 0x57, 0xcd, 0xa8, 0x14 } },
406      { NULL, { 0 } }
407    };
408     int i;
409     unsigned char tmp[32];
410     hash_state md;
411     for (i = 0; tests[i].msg != NULL; i++) {
412        blake2b_256_init(&md);
413        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
414        blake2b_done(&md, tmp);
415        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_256", i)) {
416           return CRYPT_FAIL_TESTVECTOR;
417        }
418     }
419     return CRYPT_OK;
420  #endif
421  }
422  int blake2b_160_test(void)
423  {
424  #ifndef LTC_TEST
425     return CRYPT_NOP;
426  #else
427     static const struct {
428        const char *msg;
429        unsigned char hash[20];
430    } tests[] = {
431      { "",
432        { 0x33, 0x45, 0x52, 0x4a, 0xbf, 0x6b, 0xbe, 0x18,
433          0x09, 0x44, 0x92, 0x24, 0xb5, 0x97, 0x2c, 0x41,
434          0x79, 0x0b, 0x6c, 0xf2 } },
435      { "abc",
436        { 0x38, 0x42, 0x64, 0xf6, 0x76, 0xf3, 0x95, 0x36,
437          0x84, 0x05, 0x23, 0xf2, 0x84, 0x92, 0x1c, 0xdc,
438          0x68, 0xb6, 0x84, 0x6b } },
439      { NULL, { 0 } }
440    };
441     int i;
442     unsigned char tmp[20];
443     hash_state md;
444     for (i = 0; tests[i].msg != NULL; i++) {
445        blake2b_160_init(&md);
446        blake2b_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
447        blake2b_done(&md, tmp);
448        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2B_160", i)) {
449           return CRYPT_FAIL_TESTVECTOR;
450        }
451     }
452     return CRYPT_OK;
453  #endif
454  }
455  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_mips_dsp_r2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2b.c</div>
                </div>
                <div class="column column_space"><pre><code>413    for (k = 3; k > 0; --k) {
414      p += 4 * stride;
415      FilterLoop24(p, stride, 1, 16, thresh, ithresh, hev_thresh);
416    }
417  }
418  static void HFilter16i(uint8_t* p, int stride,
</pre></code></div>
                <div class="column column_space"><pre><code>121     for (i = 0; i < 8; ++i) {
122        md->blake2b.h[i] = blake2b_IV[i];
123     }
124  }
125  static int s_blake2b_init_param(hash_state *md, const unsigned char *P)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    