
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcapng.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap/pcap-inttypes.h>
5  #include <errno.h>
6  #include <memory.h>
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include "pcap-int.h"
11  #include "pcap-util.h"
12  #include "pcap-common.h"
13  #ifdef HAVE_OS_PROTO_H
14  #include "os-proto.h"
15  #endif
16  #include "sf-pcapng.h"
17  struct block_header {
18  	bpf_u_int32	block_type;
19  	bpf_u_int32	total_length;
20  };
21  struct block_trailer {
<span onclick='openModal()' class='match'>22  	bpf_u_int32	total_length;
23  };
24  #define OPT_ENDOFOPT	0	&bsol;* end of options */
25  #define OPT_COMMENT	1	&bsol;* comment string */
</span>26  struct option_header {
27  	u_short		option_code;
28  	u_short		option_length;
29  };
30  #define BT_SHB			0x0A0D0D0A
31  #define BT_SHB_INSANE_MAX       1024U*1024U*1U  &bsol;* 1MB should be enough */
32  struct section_header_block {
33  	bpf_u_int32	byte_order_magic;
34  	u_short		major_version;
35  	u_short		minor_version;
36  	uint64_t	section_length;
37  };
38  #define BYTE_ORDER_MAGIC	0x1A2B3C4D
39  #define PCAP_NG_VERSION_MAJOR	1
40  #define PCAP_NG_VERSION_MINOR	0
41  #define BT_IDB			0x00000001
42  struct interface_description_block {
43  	u_short		linktype;
44  	u_short		reserved;
45  	bpf_u_int32	snaplen;
46  };
47  #define IF_NAME		2	&bsol;* interface name string */
48  #define IF_DESCRIPTION	3	&bsol;* interface description string */
49  #define IF_IPV4ADDR	4	&bsol;* interface's IPv4 address and netmask */
50  #define IF_IPV6ADDR	5	&bsol;* interface's IPv6 address and prefix length */
51  #define IF_MACADDR	6	&bsol;* interface's MAC address */
52  #define IF_EUIADDR	7	&bsol;* interface's EUI address */
53  #define IF_SPEED	8	&bsol;* interface's speed, in bits/s */
54  #define IF_TSRESOL	9	&bsol;* interface's time stamp resolution */
55  #define IF_TZONE	10	&bsol;* interface's time zone */
56  #define IF_FILTER	11	&bsol;* filter used when capturing on interface */
57  #define IF_OS		12	&bsol;* string OS on which capture on this interface was done */
58  #define IF_FCSLEN	13	&bsol;* FCS length for this interface */
59  #define IF_TSOFFSET	14	&bsol;* time stamp offset for this interface */
60  #define BT_EPB			0x00000006
61  struct enhanced_packet_block {
62  	bpf_u_int32	interface_id;
63  	bpf_u_int32	timestamp_high;
64  	bpf_u_int32	timestamp_low;
65  	bpf_u_int32	caplen;
66  	bpf_u_int32	len;
67  };
68  #define BT_SPB			0x00000003
69  struct simple_packet_block {
70  	bpf_u_int32	len;
71  };
72  #define BT_PB			0x00000002
73  struct packet_block {
74  	u_short		interface_id;
75  	u_short		drops_count;
76  	bpf_u_int32	timestamp_high;
77  	bpf_u_int32	timestamp_low;
78  	bpf_u_int32	caplen;
79  	bpf_u_int32	len;
80  };
81  struct block_cursor {
82  	u_char		*data;
83  	size_t		data_remaining;
84  	bpf_u_int32	block_type;
85  };
86  typedef enum {
87  	PASS_THROUGH,
88  	SCALE_UP_DEC,
89  	SCALE_DOWN_DEC,
90  	SCALE_UP_BIN,
91  	SCALE_DOWN_BIN
92  } tstamp_scale_type_t;
93  struct pcap_ng_if {
94  	uint32_t snaplen;		&bsol;* snapshot length */
95  	uint64_t tsresol;		&bsol;* time stamp resolution */
96  	tstamp_scale_type_t scale_type;	&bsol;* how to scale */
97  	uint64_t scale_factor;		&bsol;* time stamp scale factor for power-of-10 tsresol */
98  	uint64_t tsoffset;		&bsol;* time stamp offset */
99  };
100  struct pcap_ng_sf {
101  	uint64_t user_tsresol;		&bsol;* time stamp resolution requested by the user */
102  	u_int max_blocksize;		&bsol;* don't grow buffer size past this */
103  	bpf_u_int32 ifcount;		&bsol;* number of interfaces seen in this capture */
104  	bpf_u_int32 ifaces_size;	&bsol;* size of array below */
105  	struct pcap_ng_if *ifaces;	&bsol;* array of interface information */
106  };
107  #define INITIAL_MAX_BLOCKSIZE	(16*1024*1024)
108  #define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \
109  	(sizeof (struct block_header) + \
110  	 sizeof (struct enhanced_packet_block) + \
111  	 (max_snaplen) + 131072 + \
112  	 sizeof (struct block_trailer))
113  static void pcap_ng_cleanup(pcap_t *p);
114  static int pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,
115      u_char **data);
116  static int
117  read_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,
118      char *errbuf)
119  {
120  	size_t amt_read;
121  	amt_read = fread(buf, 1, bytes_to_read, fp);
122  	if (amt_read != bytes_to_read) {
123  		if (ferror(fp)) {
124  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
125  			    errno, "error reading dump file");
126  		} else {
127  			if (amt_read == 0 && !fail_on_eof)
128  				return (0);	&bsol;* EOF */
129  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
130  			    "truncated pcapng dump file; tried to read %zu bytes, only got %zu",
131  			    bytes_to_read, amt_read);
132  		}
133  		return (-1);
134  	}
135  	return (1);
136  }
137  static int
138  read_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)
139  {
140  	struct pcap_ng_sf *ps;
141  	int status;
142  	struct block_header bhdr;
143  	struct block_trailer *btrlr;
144  	u_char *bdata;
145  	size_t data_remaining;
146  	ps = p->priv;
147  	status = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);
148  	if (status <= 0)
149  		return (status);	&bsol;* error or EOF */
150  	if (p->swapped) {
151  		bhdr.block_type = SWAPLONG(bhdr.block_type);
152  		bhdr.total_length = SWAPLONG(bhdr.total_length);
153  	}
154  	if (bhdr.total_length < sizeof(struct block_header) +
155  	    sizeof(struct block_trailer)) {
156  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
157  		    "block in pcapng dump file has a length of %u < %zu",
158  		    bhdr.total_length,
159  		    sizeof(struct block_header) + sizeof(struct block_trailer));
160  		return (-1);
161  	}
162  	if ((bhdr.total_length % 4) != 0) {
163  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
164  		    "block in pcapng dump file has a length of %u that is not a multiple of 4",
165  		    bhdr.total_length);
166  		return (-1);
167  	}
168  	if (p->bufsize < bhdr.total_length) {
169  		void *bigger_buffer;
170  		if (bhdr.total_length > ps->max_blocksize) {
171  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "pcapng block size %u > maximum %u", bhdr.total_length,
172  			    ps->max_blocksize);
173  			return (-1);
174  		}
175  		bigger_buffer = realloc(p->buffer, bhdr.total_length);
176  		if (bigger_buffer == NULL) {
177  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
178  			return (-1);
179  		}
180  		p->buffer = bigger_buffer;
181  	}
182  	memcpy(p->buffer, &bhdr, sizeof(bhdr));
183  	bdata = p->buffer + sizeof(bhdr);
184  	data_remaining = bhdr.total_length - sizeof(bhdr);
185  	if (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)
186  		return (-1);
187  	btrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));
188  	if (p->swapped)
189  		btrlr->total_length = SWAPLONG(btrlr->total_length);
190  	if (bhdr.total_length != btrlr->total_length) {
191  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
192  		    "block total length in header and trailer don't match");
193  		return (-1);
194  	}
195  	cursor->data = bdata;
196  	cursor->data_remaining = data_remaining - sizeof(struct block_trailer);
197  	cursor->block_type = bhdr.block_type;
198  	return (1);
199  }
200  static void *
201  get_from_block_data(struct block_cursor *cursor, size_t chunk_size,
202      char *errbuf)
203  {
204  	void *data;
205  	if (cursor->data_remaining < chunk_size) {
206  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
207  		    "block of type %u in pcapng dump file is too short",
208  		    cursor->block_type);
209  		return (NULL);
210  	}
211  	data = cursor->data;
212  	cursor->data += chunk_size;
213  	cursor->data_remaining -= chunk_size;
214  	return (data);
215  }
216  static struct option_header *
217  get_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)
218  {
219  	struct option_header *opthdr;
220  	opthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);
221  	if (opthdr == NULL) {
222  		return (NULL);
223  	}
224  	if (p->swapped) {
225  		opthdr->option_code = SWAPSHORT(opthdr->option_code);
226  		opthdr->option_length = SWAPSHORT(opthdr->option_length);
227  	}
228  	return (opthdr);
229  }
230  static void *
231  get_optvalue_from_block_data(struct block_cursor *cursor,
232      struct option_header *opthdr, char *errbuf)
233  {
234  	size_t padded_option_len;
235  	void *optvalue;
236  	padded_option_len = opthdr->option_length;
237  	padded_option_len = ((padded_option_len + 3)/4)*4;
238  	optvalue = get_from_block_data(cursor, padded_option_len, errbuf);
239  	if (optvalue == NULL) {
240  		return (NULL);
241  	}
242  	return (optvalue);
243  }
244  static int
245  process_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,
246      uint64_t *tsoffset, int *is_binary, char *errbuf)
247  {
248  	struct option_header *opthdr;
249  	void *optvalue;
250  	int saw_tsresol, saw_tsoffset;
251  	uint8_t tsresol_opt;
252  	u_int i;
253  	saw_tsresol = 0;
254  	saw_tsoffset = 0;
255  	while (cursor->data_remaining != 0) {
256  		opthdr = get_opthdr_from_block_data(p, cursor, errbuf);
257  		if (opthdr == NULL) {
258  			return (-1);
259  		}
260  		optvalue = get_optvalue_from_block_data(cursor, opthdr,
261  		    errbuf);
262  		if (optvalue == NULL) {
263  			return (-1);
264  		}
265  		switch (opthdr->option_code) {
266  		case OPT_ENDOFOPT:
267  			if (opthdr->option_length != 0) {
268  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
269  				    "Interface Description Block has opt_endofopt option with length %u != 0",
270  				    opthdr->option_length);
271  				return (-1);
272  			}
273  			goto done;
274  		case IF_TSRESOL:
275  			if (opthdr->option_length != 1) {
276  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
277  				    "Interface Description Block has if_tsresol option with length %u != 1",
278  				    opthdr->option_length);
279  				return (-1);
280  			}
281  			if (saw_tsresol) {
282  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
283  				    "Interface Description Block has more than one if_tsresol option");
284  				return (-1);
285  			}
286  			saw_tsresol = 1;
287  			memcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));
288  			if (tsresol_opt & 0x80) {
289  				uint8_t tsresol_shift = (tsresol_opt & 0x7F);
290  				if (tsresol_shift > 63) {
291  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
292  					    "Interface Description Block if_tsresol option resolution 2^-%u is too high",
293  					    tsresol_shift);
294  					return (-1);
295  				}
296  				*is_binary = 1;
297  				*tsresol = ((uint64_t)1) << tsresol_shift;
298  			} else {
299  				if (tsresol_opt > 19) {
300  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
301  					    "Interface Description Block if_tsresol option resolution 10^-%u is too high",
302  					    tsresol_opt);
303  					return (-1);
304  				}
305  				*is_binary = 0;
306  				*tsresol = 1;
307  				for (i = 0; i < tsresol_opt; i++)
308  					*tsresol *= 10;
309  			}
310  			break;
311  		case IF_TSOFFSET:
312  			if (opthdr->option_length != 8) {
313  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
314  				    "Interface Description Block has if_tsoffset option with length %u != 8",
315  				    opthdr->option_length);
316  				return (-1);
317  			}
318  			if (saw_tsoffset) {
319  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
320  				    "Interface Description Block has more than one if_tsoffset option");
321  				return (-1);
322  			}
323  			saw_tsoffset = 1;
324  			memcpy(tsoffset, optvalue, sizeof(*tsoffset));
325  			if (p->swapped)
326  				*tsoffset = SWAPLL(*tsoffset);
327  			break;
328  		default:
329  			break;
330  		}
331  	}
332  done:
333  	return (0);
334  }
335  static int
336  add_interface(pcap_t *p, struct interface_description_block *idbp,
337      struct block_cursor *cursor, char *errbuf)
338  {
339  	struct pcap_ng_sf *ps;
340  	uint64_t tsresol;
341  	uint64_t tsoffset;
342  	int is_binary;
343  	ps = p->priv;
344  	ps->ifcount++;
345  	if (ps->ifcount > ps->ifaces_size) {
346  		bpf_u_int32 new_ifaces_size;
347  		struct pcap_ng_if *new_ifaces;
348  		if (ps->ifaces_size == 0) {
349  			new_ifaces_size = 1;
350  			new_ifaces = malloc(sizeof (struct pcap_ng_if));
351  		} else {
352  			if (ps->ifaces_size * 2 < ps->ifaces_size) {
353  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
354  				    "more than %u interfaces in the file",
355  				    0x80000000U);
356  				return (0);
357  			}
358  			new_ifaces_size = ps->ifaces_size * 2;
359  			if (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {
360  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
361  				    "more than %u interfaces in the file",
362  				    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));
363  				return (0);
364  			}
365  			new_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));
366  		}
367  		if (new_ifaces == NULL) {
368  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
369  			    "out of memory for per-interface information (%u interfaces)",
370  			    ps->ifcount);
371  			return (0);
372  		}
373  		ps->ifaces_size = new_ifaces_size;
374  		ps->ifaces = new_ifaces;
375  	}
376  	ps->ifaces[ps->ifcount - 1].snaplen = idbp->snaplen;
377  	tsresol = 1000000;	&bsol;* microsecond resolution */
378  	is_binary = 0;		&bsol;* which is a power of 10 */
379  	tsoffset = 0;		&bsol;* absolute timestamps */
380  	if (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,
381  	    errbuf) == -1)
382  		return (0);
383  	ps->ifaces[ps->ifcount - 1].tsresol = tsresol;
384  	ps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;
385  	if (tsresol == ps->user_tsresol) {
386  		ps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;
387  	} else if (tsresol > ps->user_tsresol) {
388  		if (is_binary)
389  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;
390  		else {
391  			ps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;
392  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;
393  		}
394  	} else {
395  		if (is_binary)
396  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;
397  		else {
398  			ps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;
399  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;
400  		}
401  	}
402  	return (1);
403  }
404  pcap_t *
405  pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
406      char *errbuf, int *err)
407  {
408  	bpf_u_int32 magic_int;
409  	size_t amt_read;
410  	bpf_u_int32 total_length;
411  	bpf_u_int32 byte_order_magic;
412  	struct block_header *bhdrp;
413  	struct section_header_block *shbp;
414  	pcap_t *p;
415  	int swapped = 0;
416  	struct pcap_ng_sf *ps;
417  	int status;
418  	struct block_cursor cursor;
419  	struct interface_description_block *idbp;
420  	*err = 0;
421  	memcpy(&magic_int, magic, sizeof(magic_int));
422  	if (magic_int != BT_SHB) {
423  		return (NULL);	&bsol;* nope */
424  	}
425  	amt_read = fread(&total_length, 1, sizeof(total_length), fp);
426  	if (amt_read < sizeof(total_length)) {
427  		if (ferror(fp)) {
428  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
429  			    errno, "error reading dump file");
430  			*err = 1;
431  			return (NULL);	&bsol;* fail */
432  		}
433  		return (NULL);
434  	}
435  	amt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);
436  	if (amt_read < sizeof(byte_order_magic)) {
437  		if (ferror(fp)) {
438  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
439  			    errno, "error reading dump file");
440  			*err = 1;
441  			return (NULL);	&bsol;* fail */
442  		}
443  		return (NULL);
444  	}
445  	if (byte_order_magic != BYTE_ORDER_MAGIC) {
446  		byte_order_magic = SWAPLONG(byte_order_magic);
447  		if (byte_order_magic != BYTE_ORDER_MAGIC) {
448  			return (NULL);
449  		}
450  		swapped = 1;
451  		total_length = SWAPLONG(total_length);
452  	}
453  	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
454              (total_length > BT_SHB_INSANE_MAX)) {
455  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
456  		    "Section Header Block in pcapng dump file has invalid length %zu < _%u_ < %u (BT_SHB_INSANE_MAX)",
457  		    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
458  		    total_length,
459  		    BT_SHB_INSANE_MAX);
460  		*err = 1;
461  		return (NULL);
462  	}
463  	p = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_ng_sf);
464  	if (p == NULL) {
465  		*err = 1;
466  		return (NULL);
467  	}
468  	p->swapped = swapped;
469  	ps = p->priv;
470  	switch (precision) {
471  	case PCAP_TSTAMP_PRECISION_MICRO:
472  		ps->user_tsresol = 1000000;
473  		break;
474  	case PCAP_TSTAMP_PRECISION_NANO:
475  		ps->user_tsresol = 1000000000;
476  		break;
477  	default:
478  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
479  		    "unknown time stamp resolution %u", precision);
480  		free(p);
481  		*err = 1;
482  		return (NULL);
483  	}
484  	p->opt.tstamp_precision = precision;
485  	p->bufsize = 2048;
486  	if (p->bufsize < total_length)
487  		p->bufsize = total_length;
488  	p->buffer = malloc(p->bufsize);
489  	if (p->buffer == NULL) {
490  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
491  		free(p);
492  		*err = 1;
493  		return (NULL);
494  	}
495  	ps->max_blocksize = INITIAL_MAX_BLOCKSIZE;
496  	bhdrp = (struct block_header *)p->buffer;
497  	shbp = (struct section_header_block *)(p->buffer + sizeof(struct block_header));
498  	bhdrp->block_type = magic_int;
499  	bhdrp->total_length = total_length;
500  	shbp->byte_order_magic = byte_order_magic;
501  	if (read_bytes(fp,
502  	    p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
503  	    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
504  	    1, errbuf) == -1)
505  		goto fail;
506  	if (p->swapped) {
507  		shbp->major_version = SWAPSHORT(shbp->major_version);
508  		shbp->minor_version = SWAPSHORT(shbp->minor_version);
509  	}
510  	if (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&
511  	       (shbp->minor_version == PCAP_NG_VERSION_MINOR ||
512  	        shbp->minor_version == 2))) {
513  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
514  		    "unsupported pcapng savefile version %u.%u",
515  		    shbp->major_version, shbp->minor_version);
516  		goto fail;
517  	}
518  	p->version_major = shbp->major_version;
519  	p->version_minor = shbp->minor_version;
520  	p->opt.tstamp_precision = precision;
521  	for (;;) {
522  		status = read_block(fp, p, &cursor, errbuf);
523  		if (status == 0) {
524  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
525  			    "the capture file has no Interface Description Blocks");
526  			goto fail;
527  		}
528  		if (status == -1)
529  			goto fail;	&bsol;* error */
530  		switch (cursor.block_type) {
531  		case BT_IDB:
532  			idbp = get_from_block_data(&cursor, sizeof(*idbp),
533  			    errbuf);
534  			if (idbp == NULL)
535  				goto fail;	&bsol;* error */
536  			if (p->swapped) {
537  				idbp->linktype = SWAPSHORT(idbp->linktype);
538  				idbp->snaplen = SWAPLONG(idbp->snaplen);
539  			}
540  			if (!add_interface(p, idbp, &cursor, errbuf))
541  				goto fail;
542  			goto done;
543  		case BT_EPB:
544  		case BT_SPB:
545  		case BT_PB:
546  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
547  			    "the capture file has a packet block before any Interface Description Blocks");
548  			goto fail;
549  		default:
550  			break;
551  		}
552  	}
553  done:
554  	p->linktype = linktype_to_dlt(idbp->linktype);
555  	p->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);
556  	p->linktype_ext = 0;
557  	if (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)
558  		ps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));
559  	p->next_packet_op = pcap_ng_next_packet;
560  	p->cleanup_op = pcap_ng_cleanup;
561  	return (p);
562  fail:
563  	free(ps->ifaces);
564  	free(p->buffer);
565  	free(p);
566  	*err = 1;
567  	return (NULL);
568  }
569  static void
570  pcap_ng_cleanup(pcap_t *p)
571  {
572  	struct pcap_ng_sf *ps = p->priv;
573  	free(ps->ifaces);
574  	pcap_sf_cleanup(p);
575  }
576  static int
577  pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
578  {
579  	struct pcap_ng_sf *ps = p->priv;
580  	struct block_cursor cursor;
581  	int status;
582  	struct enhanced_packet_block *epbp;
583  	struct simple_packet_block *spbp;
584  	struct packet_block *pbp;
585  	bpf_u_int32 interface_id = 0xFFFFFFFF;
586  	struct interface_description_block *idbp;
587  	struct section_header_block *shbp;
588  	FILE *fp = p->rfile;
589  	uint64_t t, sec, frac;
590  	for (;;) {
591  		status = read_block(fp, p, &cursor, p->errbuf);
592  		if (status == 0)
593  			return (0);	&bsol;* EOF */
594  		if (status == -1)
595  			return (-1);	&bsol;* error */
596  		switch (cursor.block_type) {
597  		case BT_EPB:
598  			epbp = get_from_block_data(&cursor, sizeof(*epbp),
599  			    p->errbuf);
600  			if (epbp == NULL)
601  				return (-1);	&bsol;* error */
602  			if (p->swapped) {
603  				interface_id = SWAPLONG(epbp->interface_id);
604  				hdr->caplen = SWAPLONG(epbp->caplen);
605  				hdr->len = SWAPLONG(epbp->len);
606  				t = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |
607  				    SWAPLONG(epbp->timestamp_low);
608  			} else {
609  				interface_id = epbp->interface_id;
610  				hdr->caplen = epbp->caplen;
611  				hdr->len = epbp->len;
612  				t = ((uint64_t)epbp->timestamp_high) << 32 |
613  				    epbp->timestamp_low;
614  			}
615  			goto found;
616  		case BT_SPB:
617  			spbp = get_from_block_data(&cursor, sizeof(*spbp),
618  			    p->errbuf);
619  			if (spbp == NULL)
620  				return (-1);	&bsol;* error */
621  			interface_id = 0;
622  			if (p->swapped) {
623  				hdr->len = SWAPLONG(spbp->len);
624  			} else
625  				hdr->len = spbp->len;
626  			hdr->caplen = hdr->len;
627  			if (hdr->caplen > (bpf_u_int32)p->snapshot)
628  				hdr->caplen = p->snapshot;
629  			t = 0;	&bsol;* no time stamps */
630  			goto found;
631  		case BT_PB:
632  			pbp = get_from_block_data(&cursor, sizeof(*pbp),
633  			    p->errbuf);
634  			if (pbp == NULL)
635  				return (-1);	&bsol;* error */
636  			if (p->swapped) {
637  				interface_id = SWAPSHORT(pbp->interface_id);
638  				hdr->caplen = SWAPLONG(pbp->caplen);
639  				hdr->len = SWAPLONG(pbp->len);
640  				t = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |
641  				    SWAPLONG(pbp->timestamp_low);
642  			} else {
643  				interface_id = pbp->interface_id;
644  				hdr->caplen = pbp->caplen;
645  				hdr->len = pbp->len;
646  				t = ((uint64_t)pbp->timestamp_high) << 32 |
647  				    pbp->timestamp_low;
648  			}
649  			goto found;
650  		case BT_IDB:
651  			idbp = get_from_block_data(&cursor, sizeof(*idbp),
652  			    p->errbuf);
653  			if (idbp == NULL)
654  				return (-1);	&bsol;* error */
655  			if (p->swapped) {
656  				idbp->linktype = SWAPSHORT(idbp->linktype);
657  				idbp->snaplen = SWAPLONG(idbp->snaplen);
658  			}
659  			if (p->linktype != idbp->linktype) {
660  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
661  				    "an interface has a type %u different from the type of the first interface",
662  				    idbp->linktype);
663  				return (-1);
664  			}
665  			if ((bpf_u_int32)p->snapshot !=
666  			    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {
667  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
668  				    "an interface has a snapshot length %u different from the snapshot length of the first interface",
669  				    idbp->snaplen);
670  				return (-1);
671  			}
672  			if (!add_interface(p, idbp, &cursor, p->errbuf))
673  				return (-1);
674  			break;
675  		case BT_SHB:
676  			shbp = get_from_block_data(&cursor, sizeof(*shbp),
677  			    p->errbuf);
678  			if (shbp == NULL)
679  				return (-1);	&bsol;* error */
680  			if (p->swapped) {
681  				shbp->byte_order_magic =
682  				    SWAPLONG(shbp->byte_order_magic);
683  				shbp->major_version =
684  				    SWAPSHORT(shbp->major_version);
685  			}
686  			switch (shbp->byte_order_magic) {
687  			case BYTE_ORDER_MAGIC:
688  				break;
689  			case SWAPLONG(BYTE_ORDER_MAGIC):
690  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
691  				    "the file has sections with different byte orders");
692  				return (-1);
693  			default:
694  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
695  				    "the file has a section with a bad byte order magic field");
696  				return (-1);
697  			}
698  			if (shbp->major_version != PCAP_NG_VERSION_MAJOR) {
699  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
700  				    "unknown pcapng savefile major version number %u",
701  				    shbp->major_version);
702  				return (-1);
703  			}
704  			ps->ifcount = 0;
705  			break;
706  		default:
707  			break;
708  		}
709  	}
710  found:
711  	if (interface_id >= ps->ifcount) {
712  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
713  		    "a packet arrived on interface %u, but there's no Interface Description Block for that interface",
714  		    interface_id);
715  		return (-1);
716  	}
717  	if (hdr->caplen > (bpf_u_int32)p->snapshot) {
718  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
719  		    "invalid packet capture length %u, bigger than "
720  		    "snaplen of %d", hdr->caplen, p->snapshot);
721  		return (-1);
722  	}
723  	sec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;
724  	frac = t % ps->ifaces[interface_id].tsresol;
725  	switch (ps->ifaces[interface_id].scale_type) {
726  	case PASS_THROUGH:
727  		break;
728  	case SCALE_UP_DEC:
729  		frac *= ps->ifaces[interface_id].scale_factor;
730  		break;
731  	case SCALE_UP_BIN:
732  		frac *= ps->user_tsresol;
733  		frac /= ps->ifaces[interface_id].tsresol;
734  		break;
735  	case SCALE_DOWN_DEC:
736  		frac /= ps->ifaces[interface_id].scale_factor;
737  		break;
738  	case SCALE_DOWN_BIN:
739  		frac *= ps->user_tsresol;
740  		frac /= ps->ifaces[interface_id].tsresol;
741  		break;
742  	}
743  #ifdef _WIN32
744  	hdr->ts.tv_sec = (long)sec;
745  	hdr->ts.tv_usec = (long)frac;
746  #else
747  	hdr->ts.tv_sec = (time_t)sec;
748  	hdr->ts.tv_usec = (int)frac;
749  #endif
750  	*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);
751  	if (*data == NULL)
752  		return (-1);
753  	pcap_post_process(p->linktype, p->swapped, hdr, *data);
754  	return (1);
755  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcapng.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap/pcap-inttypes.h>
5  #include <errno.h>
6  #include <memory.h>
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include "pcap-int.h"
11  #include "pcap-util.h"
12  #include "pcap-common.h"
13  #ifdef HAVE_OS_PROTO_H
14  #include "os-proto.h"
15  #endif
16  #include "sf-pcapng.h"
17  struct block_header {
18  	bpf_u_int32	block_type;
19  	bpf_u_int32	total_length;
20  };
21  struct block_trailer {
22  	bpf_u_int32	total_length;
23  };
24  #define OPT_ENDOFOPT	0	&bsol;* end of options */
25  #define OPT_COMMENT	1	&bsol;* comment string */
26  struct option_header {
27  	u_short		option_code;
28  	u_short		option_length;
29  };
30  #define BT_SHB			0x0A0D0D0A
31  #define BT_SHB_INSANE_MAX       1024U*1024U*1U  &bsol;* 1MB should be enough */
32  struct section_header_block {
33  	bpf_u_int32	byte_order_magic;
34  	u_short		major_version;
35  	u_short		minor_version;
36  	uint64_t	section_length;
37  };
38  #define BYTE_ORDER_MAGIC	0x1A2B3C4D
39  #define PCAP_NG_VERSION_MAJOR	1
40  #define PCAP_NG_VERSION_MINOR	0
41  #define BT_IDB			0x00000001
42  struct interface_description_block {
43  	u_short		linktype;
44  	u_short		reserved;
<span onclick='openModal()' class='match'>45  	bpf_u_int32	snaplen;
46  };
47  #define IF_NAME		2	&bsol;* interface name string */
48  #define IF_DESCRIPTION	3	&bsol;* interface description string */
</span>49  #define IF_IPV4ADDR	4	&bsol;* interface's IPv4 address and netmask */
50  #define IF_IPV6ADDR	5	&bsol;* interface's IPv6 address and prefix length */
51  #define IF_MACADDR	6	&bsol;* interface's MAC address */
52  #define IF_EUIADDR	7	&bsol;* interface's EUI address */
53  #define IF_SPEED	8	&bsol;* interface's speed, in bits/s */
54  #define IF_TSRESOL	9	&bsol;* interface's time stamp resolution */
55  #define IF_TZONE	10	&bsol;* interface's time zone */
56  #define IF_FILTER	11	&bsol;* filter used when capturing on interface */
57  #define IF_OS		12	&bsol;* string OS on which capture on this interface was done */
58  #define IF_FCSLEN	13	&bsol;* FCS length for this interface */
59  #define IF_TSOFFSET	14	&bsol;* time stamp offset for this interface */
60  #define BT_EPB			0x00000006
61  struct enhanced_packet_block {
62  	bpf_u_int32	interface_id;
63  	bpf_u_int32	timestamp_high;
64  	bpf_u_int32	timestamp_low;
65  	bpf_u_int32	caplen;
66  	bpf_u_int32	len;
67  };
68  #define BT_SPB			0x00000003
69  struct simple_packet_block {
70  	bpf_u_int32	len;
71  };
72  #define BT_PB			0x00000002
73  struct packet_block {
74  	u_short		interface_id;
75  	u_short		drops_count;
76  	bpf_u_int32	timestamp_high;
77  	bpf_u_int32	timestamp_low;
78  	bpf_u_int32	caplen;
79  	bpf_u_int32	len;
80  };
81  struct block_cursor {
82  	u_char		*data;
83  	size_t		data_remaining;
84  	bpf_u_int32	block_type;
85  };
86  typedef enum {
87  	PASS_THROUGH,
88  	SCALE_UP_DEC,
89  	SCALE_DOWN_DEC,
90  	SCALE_UP_BIN,
91  	SCALE_DOWN_BIN
92  } tstamp_scale_type_t;
93  struct pcap_ng_if {
94  	uint32_t snaplen;		&bsol;* snapshot length */
95  	uint64_t tsresol;		&bsol;* time stamp resolution */
96  	tstamp_scale_type_t scale_type;	&bsol;* how to scale */
97  	uint64_t scale_factor;		&bsol;* time stamp scale factor for power-of-10 tsresol */
98  	uint64_t tsoffset;		&bsol;* time stamp offset */
99  };
100  struct pcap_ng_sf {
101  	uint64_t user_tsresol;		&bsol;* time stamp resolution requested by the user */
102  	u_int max_blocksize;		&bsol;* don't grow buffer size past this */
103  	bpf_u_int32 ifcount;		&bsol;* number of interfaces seen in this capture */
104  	bpf_u_int32 ifaces_size;	&bsol;* size of array below */
105  	struct pcap_ng_if *ifaces;	&bsol;* array of interface information */
106  };
107  #define INITIAL_MAX_BLOCKSIZE	(16*1024*1024)
108  #define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \
109  	(sizeof (struct block_header) + \
110  	 sizeof (struct enhanced_packet_block) + \
111  	 (max_snaplen) + 131072 + \
112  	 sizeof (struct block_trailer))
113  static void pcap_ng_cleanup(pcap_t *p);
114  static int pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,
115      u_char **data);
116  static int
117  read_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,
118      char *errbuf)
119  {
120  	size_t amt_read;
121  	amt_read = fread(buf, 1, bytes_to_read, fp);
122  	if (amt_read != bytes_to_read) {
123  		if (ferror(fp)) {
124  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
125  			    errno, "error reading dump file");
126  		} else {
127  			if (amt_read == 0 && !fail_on_eof)
128  				return (0);	&bsol;* EOF */
129  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
130  			    "truncated pcapng dump file; tried to read %zu bytes, only got %zu",
131  			    bytes_to_read, amt_read);
132  		}
133  		return (-1);
134  	}
135  	return (1);
136  }
137  static int
138  read_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)
139  {
140  	struct pcap_ng_sf *ps;
141  	int status;
142  	struct block_header bhdr;
143  	struct block_trailer *btrlr;
144  	u_char *bdata;
145  	size_t data_remaining;
146  	ps = p->priv;
147  	status = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);
148  	if (status <= 0)
149  		return (status);	&bsol;* error or EOF */
150  	if (p->swapped) {
151  		bhdr.block_type = SWAPLONG(bhdr.block_type);
152  		bhdr.total_length = SWAPLONG(bhdr.total_length);
153  	}
154  	if (bhdr.total_length < sizeof(struct block_header) +
155  	    sizeof(struct block_trailer)) {
156  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
157  		    "block in pcapng dump file has a length of %u < %zu",
158  		    bhdr.total_length,
159  		    sizeof(struct block_header) + sizeof(struct block_trailer));
160  		return (-1);
161  	}
162  	if ((bhdr.total_length % 4) != 0) {
163  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
164  		    "block in pcapng dump file has a length of %u that is not a multiple of 4",
165  		    bhdr.total_length);
166  		return (-1);
167  	}
168  	if (p->bufsize < bhdr.total_length) {
169  		void *bigger_buffer;
170  		if (bhdr.total_length > ps->max_blocksize) {
171  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "pcapng block size %u > maximum %u", bhdr.total_length,
172  			    ps->max_blocksize);
173  			return (-1);
174  		}
175  		bigger_buffer = realloc(p->buffer, bhdr.total_length);
176  		if (bigger_buffer == NULL) {
177  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
178  			return (-1);
179  		}
180  		p->buffer = bigger_buffer;
181  	}
182  	memcpy(p->buffer, &bhdr, sizeof(bhdr));
183  	bdata = p->buffer + sizeof(bhdr);
184  	data_remaining = bhdr.total_length - sizeof(bhdr);
185  	if (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)
186  		return (-1);
187  	btrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));
188  	if (p->swapped)
189  		btrlr->total_length = SWAPLONG(btrlr->total_length);
190  	if (bhdr.total_length != btrlr->total_length) {
191  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
192  		    "block total length in header and trailer don't match");
193  		return (-1);
194  	}
195  	cursor->data = bdata;
196  	cursor->data_remaining = data_remaining - sizeof(struct block_trailer);
197  	cursor->block_type = bhdr.block_type;
198  	return (1);
199  }
200  static void *
201  get_from_block_data(struct block_cursor *cursor, size_t chunk_size,
202      char *errbuf)
203  {
204  	void *data;
205  	if (cursor->data_remaining < chunk_size) {
206  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
207  		    "block of type %u in pcapng dump file is too short",
208  		    cursor->block_type);
209  		return (NULL);
210  	}
211  	data = cursor->data;
212  	cursor->data += chunk_size;
213  	cursor->data_remaining -= chunk_size;
214  	return (data);
215  }
216  static struct option_header *
217  get_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)
218  {
219  	struct option_header *opthdr;
220  	opthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);
221  	if (opthdr == NULL) {
222  		return (NULL);
223  	}
224  	if (p->swapped) {
225  		opthdr->option_code = SWAPSHORT(opthdr->option_code);
226  		opthdr->option_length = SWAPSHORT(opthdr->option_length);
227  	}
228  	return (opthdr);
229  }
230  static void *
231  get_optvalue_from_block_data(struct block_cursor *cursor,
232      struct option_header *opthdr, char *errbuf)
233  {
234  	size_t padded_option_len;
235  	void *optvalue;
236  	padded_option_len = opthdr->option_length;
237  	padded_option_len = ((padded_option_len + 3)/4)*4;
238  	optvalue = get_from_block_data(cursor, padded_option_len, errbuf);
239  	if (optvalue == NULL) {
240  		return (NULL);
241  	}
242  	return (optvalue);
243  }
244  static int
245  process_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,
246      uint64_t *tsoffset, int *is_binary, char *errbuf)
247  {
248  	struct option_header *opthdr;
249  	void *optvalue;
250  	int saw_tsresol, saw_tsoffset;
251  	uint8_t tsresol_opt;
252  	u_int i;
253  	saw_tsresol = 0;
254  	saw_tsoffset = 0;
255  	while (cursor->data_remaining != 0) {
256  		opthdr = get_opthdr_from_block_data(p, cursor, errbuf);
257  		if (opthdr == NULL) {
258  			return (-1);
259  		}
260  		optvalue = get_optvalue_from_block_data(cursor, opthdr,
261  		    errbuf);
262  		if (optvalue == NULL) {
263  			return (-1);
264  		}
265  		switch (opthdr->option_code) {
266  		case OPT_ENDOFOPT:
267  			if (opthdr->option_length != 0) {
268  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
269  				    "Interface Description Block has opt_endofopt option with length %u != 0",
270  				    opthdr->option_length);
271  				return (-1);
272  			}
273  			goto done;
274  		case IF_TSRESOL:
275  			if (opthdr->option_length != 1) {
276  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
277  				    "Interface Description Block has if_tsresol option with length %u != 1",
278  				    opthdr->option_length);
279  				return (-1);
280  			}
281  			if (saw_tsresol) {
282  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
283  				    "Interface Description Block has more than one if_tsresol option");
284  				return (-1);
285  			}
286  			saw_tsresol = 1;
287  			memcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));
288  			if (tsresol_opt & 0x80) {
289  				uint8_t tsresol_shift = (tsresol_opt & 0x7F);
290  				if (tsresol_shift > 63) {
291  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
292  					    "Interface Description Block if_tsresol option resolution 2^-%u is too high",
293  					    tsresol_shift);
294  					return (-1);
295  				}
296  				*is_binary = 1;
297  				*tsresol = ((uint64_t)1) << tsresol_shift;
298  			} else {
299  				if (tsresol_opt > 19) {
300  					snprintf(errbuf, PCAP_ERRBUF_SIZE,
301  					    "Interface Description Block if_tsresol option resolution 10^-%u is too high",
302  					    tsresol_opt);
303  					return (-1);
304  				}
305  				*is_binary = 0;
306  				*tsresol = 1;
307  				for (i = 0; i < tsresol_opt; i++)
308  					*tsresol *= 10;
309  			}
310  			break;
311  		case IF_TSOFFSET:
312  			if (opthdr->option_length != 8) {
313  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
314  				    "Interface Description Block has if_tsoffset option with length %u != 8",
315  				    opthdr->option_length);
316  				return (-1);
317  			}
318  			if (saw_tsoffset) {
319  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
320  				    "Interface Description Block has more than one if_tsoffset option");
321  				return (-1);
322  			}
323  			saw_tsoffset = 1;
324  			memcpy(tsoffset, optvalue, sizeof(*tsoffset));
325  			if (p->swapped)
326  				*tsoffset = SWAPLL(*tsoffset);
327  			break;
328  		default:
329  			break;
330  		}
331  	}
332  done:
333  	return (0);
334  }
335  static int
336  add_interface(pcap_t *p, struct interface_description_block *idbp,
337      struct block_cursor *cursor, char *errbuf)
338  {
339  	struct pcap_ng_sf *ps;
340  	uint64_t tsresol;
341  	uint64_t tsoffset;
342  	int is_binary;
343  	ps = p->priv;
344  	ps->ifcount++;
345  	if (ps->ifcount > ps->ifaces_size) {
346  		bpf_u_int32 new_ifaces_size;
347  		struct pcap_ng_if *new_ifaces;
348  		if (ps->ifaces_size == 0) {
349  			new_ifaces_size = 1;
350  			new_ifaces = malloc(sizeof (struct pcap_ng_if));
351  		} else {
352  			if (ps->ifaces_size * 2 < ps->ifaces_size) {
353  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
354  				    "more than %u interfaces in the file",
355  				    0x80000000U);
356  				return (0);
357  			}
358  			new_ifaces_size = ps->ifaces_size * 2;
359  			if (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {
360  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
361  				    "more than %u interfaces in the file",
362  				    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));
363  				return (0);
364  			}
365  			new_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));
366  		}
367  		if (new_ifaces == NULL) {
368  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
369  			    "out of memory for per-interface information (%u interfaces)",
370  			    ps->ifcount);
371  			return (0);
372  		}
373  		ps->ifaces_size = new_ifaces_size;
374  		ps->ifaces = new_ifaces;
375  	}
376  	ps->ifaces[ps->ifcount - 1].snaplen = idbp->snaplen;
377  	tsresol = 1000000;	&bsol;* microsecond resolution */
378  	is_binary = 0;		&bsol;* which is a power of 10 */
379  	tsoffset = 0;		&bsol;* absolute timestamps */
380  	if (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,
381  	    errbuf) == -1)
382  		return (0);
383  	ps->ifaces[ps->ifcount - 1].tsresol = tsresol;
384  	ps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;
385  	if (tsresol == ps->user_tsresol) {
386  		ps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;
387  	} else if (tsresol > ps->user_tsresol) {
388  		if (is_binary)
389  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;
390  		else {
391  			ps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;
392  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;
393  		}
394  	} else {
395  		if (is_binary)
396  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;
397  		else {
398  			ps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;
399  			ps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;
400  		}
401  	}
402  	return (1);
403  }
404  pcap_t *
405  pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
406      char *errbuf, int *err)
407  {
408  	bpf_u_int32 magic_int;
409  	size_t amt_read;
410  	bpf_u_int32 total_length;
411  	bpf_u_int32 byte_order_magic;
412  	struct block_header *bhdrp;
413  	struct section_header_block *shbp;
414  	pcap_t *p;
415  	int swapped = 0;
416  	struct pcap_ng_sf *ps;
417  	int status;
418  	struct block_cursor cursor;
419  	struct interface_description_block *idbp;
420  	*err = 0;
421  	memcpy(&magic_int, magic, sizeof(magic_int));
422  	if (magic_int != BT_SHB) {
423  		return (NULL);	&bsol;* nope */
424  	}
425  	amt_read = fread(&total_length, 1, sizeof(total_length), fp);
426  	if (amt_read < sizeof(total_length)) {
427  		if (ferror(fp)) {
428  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
429  			    errno, "error reading dump file");
430  			*err = 1;
431  			return (NULL);	&bsol;* fail */
432  		}
433  		return (NULL);
434  	}
435  	amt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);
436  	if (amt_read < sizeof(byte_order_magic)) {
437  		if (ferror(fp)) {
438  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
439  			    errno, "error reading dump file");
440  			*err = 1;
441  			return (NULL);	&bsol;* fail */
442  		}
443  		return (NULL);
444  	}
445  	if (byte_order_magic != BYTE_ORDER_MAGIC) {
446  		byte_order_magic = SWAPLONG(byte_order_magic);
447  		if (byte_order_magic != BYTE_ORDER_MAGIC) {
448  			return (NULL);
449  		}
450  		swapped = 1;
451  		total_length = SWAPLONG(total_length);
452  	}
453  	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
454              (total_length > BT_SHB_INSANE_MAX)) {
455  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
456  		    "Section Header Block in pcapng dump file has invalid length %zu < _%u_ < %u (BT_SHB_INSANE_MAX)",
457  		    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
458  		    total_length,
459  		    BT_SHB_INSANE_MAX);
460  		*err = 1;
461  		return (NULL);
462  	}
463  	p = PCAP_OPEN_OFFLINE_COMMON(errbuf, struct pcap_ng_sf);
464  	if (p == NULL) {
465  		*err = 1;
466  		return (NULL);
467  	}
468  	p->swapped = swapped;
469  	ps = p->priv;
470  	switch (precision) {
471  	case PCAP_TSTAMP_PRECISION_MICRO:
472  		ps->user_tsresol = 1000000;
473  		break;
474  	case PCAP_TSTAMP_PRECISION_NANO:
475  		ps->user_tsresol = 1000000000;
476  		break;
477  	default:
478  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
479  		    "unknown time stamp resolution %u", precision);
480  		free(p);
481  		*err = 1;
482  		return (NULL);
483  	}
484  	p->opt.tstamp_precision = precision;
485  	p->bufsize = 2048;
486  	if (p->bufsize < total_length)
487  		p->bufsize = total_length;
488  	p->buffer = malloc(p->bufsize);
489  	if (p->buffer == NULL) {
490  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "out of memory");
491  		free(p);
492  		*err = 1;
493  		return (NULL);
494  	}
495  	ps->max_blocksize = INITIAL_MAX_BLOCKSIZE;
496  	bhdrp = (struct block_header *)p->buffer;
497  	shbp = (struct section_header_block *)(p->buffer + sizeof(struct block_header));
498  	bhdrp->block_type = magic_int;
499  	bhdrp->total_length = total_length;
500  	shbp->byte_order_magic = byte_order_magic;
501  	if (read_bytes(fp,
502  	    p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
503  	    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
504  	    1, errbuf) == -1)
505  		goto fail;
506  	if (p->swapped) {
507  		shbp->major_version = SWAPSHORT(shbp->major_version);
508  		shbp->minor_version = SWAPSHORT(shbp->minor_version);
509  	}
510  	if (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&
511  	       (shbp->minor_version == PCAP_NG_VERSION_MINOR ||
512  	        shbp->minor_version == 2))) {
513  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
514  		    "unsupported pcapng savefile version %u.%u",
515  		    shbp->major_version, shbp->minor_version);
516  		goto fail;
517  	}
518  	p->version_major = shbp->major_version;
519  	p->version_minor = shbp->minor_version;
520  	p->opt.tstamp_precision = precision;
521  	for (;;) {
522  		status = read_block(fp, p, &cursor, errbuf);
523  		if (status == 0) {
524  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
525  			    "the capture file has no Interface Description Blocks");
526  			goto fail;
527  		}
528  		if (status == -1)
529  			goto fail;	&bsol;* error */
530  		switch (cursor.block_type) {
531  		case BT_IDB:
532  			idbp = get_from_block_data(&cursor, sizeof(*idbp),
533  			    errbuf);
534  			if (idbp == NULL)
535  				goto fail;	&bsol;* error */
536  			if (p->swapped) {
537  				idbp->linktype = SWAPSHORT(idbp->linktype);
538  				idbp->snaplen = SWAPLONG(idbp->snaplen);
539  			}
540  			if (!add_interface(p, idbp, &cursor, errbuf))
541  				goto fail;
542  			goto done;
543  		case BT_EPB:
544  		case BT_SPB:
545  		case BT_PB:
546  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
547  			    "the capture file has a packet block before any Interface Description Blocks");
548  			goto fail;
549  		default:
550  			break;
551  		}
552  	}
553  done:
554  	p->linktype = linktype_to_dlt(idbp->linktype);
555  	p->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);
556  	p->linktype_ext = 0;
557  	if (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)
558  		ps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));
559  	p->next_packet_op = pcap_ng_next_packet;
560  	p->cleanup_op = pcap_ng_cleanup;
561  	return (p);
562  fail:
563  	free(ps->ifaces);
564  	free(p->buffer);
565  	free(p);
566  	*err = 1;
567  	return (NULL);
568  }
569  static void
570  pcap_ng_cleanup(pcap_t *p)
571  {
572  	struct pcap_ng_sf *ps = p->priv;
573  	free(ps->ifaces);
574  	pcap_sf_cleanup(p);
575  }
576  static int
577  pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)
578  {
579  	struct pcap_ng_sf *ps = p->priv;
580  	struct block_cursor cursor;
581  	int status;
582  	struct enhanced_packet_block *epbp;
583  	struct simple_packet_block *spbp;
584  	struct packet_block *pbp;
585  	bpf_u_int32 interface_id = 0xFFFFFFFF;
586  	struct interface_description_block *idbp;
587  	struct section_header_block *shbp;
588  	FILE *fp = p->rfile;
589  	uint64_t t, sec, frac;
590  	for (;;) {
591  		status = read_block(fp, p, &cursor, p->errbuf);
592  		if (status == 0)
593  			return (0);	&bsol;* EOF */
594  		if (status == -1)
595  			return (-1);	&bsol;* error */
596  		switch (cursor.block_type) {
597  		case BT_EPB:
598  			epbp = get_from_block_data(&cursor, sizeof(*epbp),
599  			    p->errbuf);
600  			if (epbp == NULL)
601  				return (-1);	&bsol;* error */
602  			if (p->swapped) {
603  				interface_id = SWAPLONG(epbp->interface_id);
604  				hdr->caplen = SWAPLONG(epbp->caplen);
605  				hdr->len = SWAPLONG(epbp->len);
606  				t = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |
607  				    SWAPLONG(epbp->timestamp_low);
608  			} else {
609  				interface_id = epbp->interface_id;
610  				hdr->caplen = epbp->caplen;
611  				hdr->len = epbp->len;
612  				t = ((uint64_t)epbp->timestamp_high) << 32 |
613  				    epbp->timestamp_low;
614  			}
615  			goto found;
616  		case BT_SPB:
617  			spbp = get_from_block_data(&cursor, sizeof(*spbp),
618  			    p->errbuf);
619  			if (spbp == NULL)
620  				return (-1);	&bsol;* error */
621  			interface_id = 0;
622  			if (p->swapped) {
623  				hdr->len = SWAPLONG(spbp->len);
624  			} else
625  				hdr->len = spbp->len;
626  			hdr->caplen = hdr->len;
627  			if (hdr->caplen > (bpf_u_int32)p->snapshot)
628  				hdr->caplen = p->snapshot;
629  			t = 0;	&bsol;* no time stamps */
630  			goto found;
631  		case BT_PB:
632  			pbp = get_from_block_data(&cursor, sizeof(*pbp),
633  			    p->errbuf);
634  			if (pbp == NULL)
635  				return (-1);	&bsol;* error */
636  			if (p->swapped) {
637  				interface_id = SWAPSHORT(pbp->interface_id);
638  				hdr->caplen = SWAPLONG(pbp->caplen);
639  				hdr->len = SWAPLONG(pbp->len);
640  				t = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |
641  				    SWAPLONG(pbp->timestamp_low);
642  			} else {
643  				interface_id = pbp->interface_id;
644  				hdr->caplen = pbp->caplen;
645  				hdr->len = pbp->len;
646  				t = ((uint64_t)pbp->timestamp_high) << 32 |
647  				    pbp->timestamp_low;
648  			}
649  			goto found;
650  		case BT_IDB:
651  			idbp = get_from_block_data(&cursor, sizeof(*idbp),
652  			    p->errbuf);
653  			if (idbp == NULL)
654  				return (-1);	&bsol;* error */
655  			if (p->swapped) {
656  				idbp->linktype = SWAPSHORT(idbp->linktype);
657  				idbp->snaplen = SWAPLONG(idbp->snaplen);
658  			}
659  			if (p->linktype != idbp->linktype) {
660  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
661  				    "an interface has a type %u different from the type of the first interface",
662  				    idbp->linktype);
663  				return (-1);
664  			}
665  			if ((bpf_u_int32)p->snapshot !=
666  			    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {
667  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
668  				    "an interface has a snapshot length %u different from the snapshot length of the first interface",
669  				    idbp->snaplen);
670  				return (-1);
671  			}
672  			if (!add_interface(p, idbp, &cursor, p->errbuf))
673  				return (-1);
674  			break;
675  		case BT_SHB:
676  			shbp = get_from_block_data(&cursor, sizeof(*shbp),
677  			    p->errbuf);
678  			if (shbp == NULL)
679  				return (-1);	&bsol;* error */
680  			if (p->swapped) {
681  				shbp->byte_order_magic =
682  				    SWAPLONG(shbp->byte_order_magic);
683  				shbp->major_version =
684  				    SWAPSHORT(shbp->major_version);
685  			}
686  			switch (shbp->byte_order_magic) {
687  			case BYTE_ORDER_MAGIC:
688  				break;
689  			case SWAPLONG(BYTE_ORDER_MAGIC):
690  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
691  				    "the file has sections with different byte orders");
692  				return (-1);
693  			default:
694  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
695  				    "the file has a section with a bad byte order magic field");
696  				return (-1);
697  			}
698  			if (shbp->major_version != PCAP_NG_VERSION_MAJOR) {
699  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
700  				    "unknown pcapng savefile major version number %u",
701  				    shbp->major_version);
702  				return (-1);
703  			}
704  			ps->ifcount = 0;
705  			break;
706  		default:
707  			break;
708  		}
709  	}
710  found:
711  	if (interface_id >= ps->ifcount) {
712  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
713  		    "a packet arrived on interface %u, but there's no Interface Description Block for that interface",
714  		    interface_id);
715  		return (-1);
716  	}
717  	if (hdr->caplen > (bpf_u_int32)p->snapshot) {
718  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
719  		    "invalid packet capture length %u, bigger than "
720  		    "snaplen of %d", hdr->caplen, p->snapshot);
721  		return (-1);
722  	}
723  	sec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;
724  	frac = t % ps->ifaces[interface_id].tsresol;
725  	switch (ps->ifaces[interface_id].scale_type) {
726  	case PASS_THROUGH:
727  		break;
728  	case SCALE_UP_DEC:
729  		frac *= ps->ifaces[interface_id].scale_factor;
730  		break;
731  	case SCALE_UP_BIN:
732  		frac *= ps->user_tsresol;
733  		frac /= ps->ifaces[interface_id].tsresol;
734  		break;
735  	case SCALE_DOWN_DEC:
736  		frac /= ps->ifaces[interface_id].scale_factor;
737  		break;
738  	case SCALE_DOWN_BIN:
739  		frac *= ps->user_tsresol;
740  		frac /= ps->ifaces[interface_id].tsresol;
741  		break;
742  	}
743  #ifdef _WIN32
744  	hdr->ts.tv_sec = (long)sec;
745  	hdr->ts.tv_usec = (long)frac;
746  #else
747  	hdr->ts.tv_sec = (time_t)sec;
748  	hdr->ts.tv_usec = (int)frac;
749  #endif
750  	*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);
751  	if (*data == NULL)
752  		return (-1);
753  	pcap_post_process(p->linktype, p->swapped, hdr, *data);
754  	return (1);
755  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcapng.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-sf-pcapng.c</div>
                </div>
                <div class="column column_space"><pre><code>22  	bpf_u_int32	total_length;
23  };
24  #define OPT_ENDOFOPT	0	&bsol;* end of options */
25  #define OPT_COMMENT	1	&bsol;* comment string */
</pre></code></div>
                <div class="column column_space"><pre><code>45  	bpf_u_int32	snaplen;
46  };
47  #define IF_NAME		2	&bsol;* interface name string */
48  #define IF_DESCRIPTION	3	&bsol;* interface description string */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    