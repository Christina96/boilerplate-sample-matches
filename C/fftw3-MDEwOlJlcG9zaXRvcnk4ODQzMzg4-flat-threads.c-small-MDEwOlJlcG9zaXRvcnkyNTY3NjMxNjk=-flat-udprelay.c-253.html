
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</h3>
            <pre><code>1  #include &quot;threads/threads.h&quot;
2  #include &quot;api/api.h&quot;
3  #if defined(USING_POSIX_THREADS)
4  #include &lt;pthread.h&gt;
5  #ifdef HAVE_UNISTD_H
6  #  include &lt;unistd.h&gt;
7  #endif
8  #if (defined(_POSIX_SEMAPHORES) &amp;&amp; (_POSIX_SEMAPHORES &gt;= 200112L))
9  #  include &lt;semaphore.h&gt;
10  #  include &lt;errno.h&gt;
11     typedef sem_t os_sem_t;
12     static void os_sem_init(os_sem_t *s) { sem_init(s, 0, 0); }
13     static void os_sem_destroy(os_sem_t *s) { sem_destroy(s); }
14     static void os_sem_down(os_sem_t *s)
15     {
16  	int err;
17  	do {
18  	     err = sem_wait(s);
19  	} while (err == -1 &amp;&amp; errno == EINTR);
20  	CK(err == 0);
21     }
22     static void os_sem_up(os_sem_t *s) { sem_post(s); }
23     typedef sem_t os_mutex_t;
24     static void os_mutex_init(os_mutex_t *s) { sem_init(s, 0, 1); }
25     #define os_mutex_destroy os_sem_destroy
26     #define os_mutex_lock os_sem_down
27     #define os_mutex_unlock os_sem_up
28  #else
29     typedef pthread_mutex_t os_mutex_t;
30     static void os_mutex_init(os_mutex_t *s)
31     {
32  	pthread_mutex_init(s, (pthread_mutexattr_t *)0);
33     }
34     static void os_mutex_destroy(os_mutex_t *s) { pthread_mutex_destroy(s); }
35     static void os_mutex_lock(os_mutex_t *s) { pthread_mutex_lock(s); }
36     static void os_mutex_unlock(os_mutex_t *s) { pthread_mutex_unlock(s); }
37     typedef struct {
38  	pthread_mutex_t m;
39  	pthread_cond_t c;
40  	volatile int x;
41     } os_sem_t;
42     static void os_sem_init(os_sem_t *s)
43     {
44  	pthread_mutex_init(&amp;s-&gt;m, (pthread_mutexattr_t *)0);
45  	pthread_cond_init(&amp;s-&gt;c, (pthread_condattr_t *)0);
46  	pthread_mutex_lock(&amp;s-&gt;m);
47  	s-&gt;x = 0;
48  	pthread_mutex_unlock(&amp;s-&gt;m);
49     }
50     static void os_sem_destroy(os_sem_t *s)
51     {
52  	pthread_mutex_destroy(&amp;s-&gt;m);
53  	pthread_cond_destroy(&amp;s-&gt;c);
54     }
55     static void os_sem_down(os_sem_t *s)
56     {
57  	pthread_mutex_lock(&amp;s-&gt;m);
58  	while (s-&gt;x &lt;= 0)
59  	     pthread_cond_wait(&amp;s-&gt;c, &amp;s-&gt;m);
60  	--s-&gt;x;
61  	pthread_mutex_unlock(&amp;s-&gt;m);
62     }
63     static void os_sem_up(os_sem_t *s)
64     {
65  	pthread_mutex_lock(&amp;s-&gt;m);
66  	++s-&gt;x;
67  	pthread_cond_signal(&amp;s-&gt;c);
68  	pthread_mutex_unlock(&amp;s-&gt;m);
69     }
70  #endif
71  #define FFTW_WORKER void *
72  static void os_create_thread(FFTW_WORKER (*worker)(void *arg),
73  			     void *arg)
74  {
75       pthread_attr_t attr;
76       pthread_t tid;
77       pthread_attr_init(&amp;attr);
78       pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);
79       pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
80       pthread_create(&amp;tid, &amp;attr, worker, (void *)arg);
81       pthread_attr_destroy(&amp;attr);
82  }
83  static void os_destroy_thread(void)
84  {
85       pthread_exit((void *)0);
86  }
87  typedef pthread_mutex_t os_static_mutex_t;
88  #define OS_STATIC_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
89  static void os_static_mutex_lock(os_static_mutex_t *s) { pthread_mutex_lock(s); }
90  static void os_static_mutex_unlock(os_static_mutex_t *s) { pthread_mutex_unlock(s); }
91  #elif defined(__WIN32__) || defined(_WIN32) || defined(_WINDOWS)
92  #define INT magnus_ab_INTegro_seclorum_nascitur_ordo
93  #include &lt;windows.h&gt;
94  #include &lt;process.h&gt;
95  #include &lt;intrin.h&gt;
96  #undef INT
97  typedef HANDLE os_mutex_t;
98  static void os_mutex_init(os_mutex_t *s)
99  {
100       *s = CreateMutex(NULL, FALSE, NULL);
101  }
102  static void os_mutex_destroy(os_mutex_t *s)
103  {
104       CloseHandle(*s);
105  }
106  static void os_mutex_lock(os_mutex_t *s)
107  {
108       WaitForSingleObject(*s, INFINITE);
109  }
110  static void os_mutex_unlock(os_mutex_t *s)
111  {
112       ReleaseMutex(*s);
113  }
114  typedef HANDLE os_sem_t;
115  static void os_sem_init(os_sem_t *s)
116  {
117       *s = CreateSemaphore(NULL, 0, 0x7FFFFFFFL, NULL);
118  }
119  static void os_sem_destroy(os_sem_t *s)
120  {
121       CloseHandle(*s);
122  }
123  static void os_sem_down(os_sem_t *s)
124  {
125       WaitForSingleObject(*s, INFINITE);
126  }
127  static void os_sem_up(os_sem_t *s)
128  {
129       ReleaseSemaphore(*s, 1, NULL);
130  }
131  #define FFTW_WORKER unsigned __stdcall
132  typedef unsigned (__stdcall *winthread_start) (void *);
133  static void os_create_thread(winthread_start worker,
134  			     void *arg)
135  {
136       _beginthreadex((void *)NULL,               &amp;bsol;* security attrib */
137  		    0,				&amp;bsol;* stack size */
138  		    worker,                     &amp;bsol;* start address */
139  		    arg,			&amp;bsol;* parameters */
140  		    0,				&amp;bsol;* creation flags */
141  		    (unsigned *)NULL);		&amp;bsol;* tid */
142  }
143  static void os_destroy_thread(void)
144  {
145       _endthreadex(0);
146  }
147  typedef volatile LONG os_static_mutex_t;
148  #define OS_STATIC_MUTEX_INITIALIZER 0
149  static void os_static_mutex_lock(os_static_mutex_t *s)
150  {
151       while (InterlockedExchange(s, 1) == 1) {
152            YieldProcessor();
153            Sleep(0);
154       }
155  }
156  static void os_static_mutex_unlock(os_static_mutex_t *s)
157  {
158       LONG old = InterlockedExchange(s, 0);
159       A(old == 1);
160  }
161  #else
162  #error &quot;No threading layer defined&quot;
163  #endif
164  struct worker {
165       os_sem_t ready;
166       os_sem_t done;
167       struct work *w;
168       struct worker *cdr;
169  };
170  static struct worker *make_worker(void)
171  {
172       struct worker *q = (struct worker *)MALLOC(sizeof(*q), OTHER);
173       os_sem_init(&amp;q-&gt;ready);
174       os_sem_init(&amp;q-&gt;done);
175       return q;
176  }
177  static void unmake_worker(struct worker *q)
178  {
179       os_sem_destroy(&amp;q-&gt;done);
180       os_sem_destroy(&amp;q-&gt;ready);
181       X(ifree)(q);
182  }
183  struct work {
184       spawn_function proc;
185       spawn_data d;
186       struct worker *q; &amp;bsol;* the worker responsible for performing this work */
187  };
188  static os_mutex_t queue_lock;
189  static os_sem_t termination_semaphore;
190  static struct worker *worker_queue;
191  #define WITH_QUEUE_LOCK(what)			\
192  {						\
193       os_mutex_lock(&amp;queue_lock);		\
194       what;					\
195       os_mutex_unlock(&amp;queue_lock);		\
196  }
197  static FFTW_WORKER worker(void *arg)
198  {
199       struct worker *ego = (struct worker *)arg;
200       struct work *w;
201       for (;;) {
202  	  os_sem_down(&amp;ego-&gt;ready);
203  	  w = ego-&gt;w;
204  	  if (!w-&gt;proc) break;
205            w-&gt;proc(&amp;w-&gt;d);
206  	  os_sem_up(&amp;ego-&gt;done);
207       }
208       os_sem_up(&amp;termination_semaphore);
209       os_destroy_thread();
210       return 0;
211  }
212  static void enqueue(struct worker *q)
213  {
214       WITH_QUEUE_LOCK({
215  	  q-&gt;cdr = worker_queue;
216  	  worker_queue = q;
217       });
218  }
219  static struct worker *dequeue(void)
220  {
221       struct worker *q;
222       WITH_QUEUE_LOCK({
223  	  q = worker_queue;
224  	  if (q)
225  	       worker_queue = q-&gt;cdr;
226       });
227       if (!q) {
228  	  q = make_worker();
229  	  os_create_thread(worker, q);
230       }
231       return q;
232  }
233  static void kill_workforce(void)
234  {
235       struct work w;
236       w.proc = 0;
237       WITH_QUEUE_LOCK({
238  	  while (worker_queue) {
239  	       struct worker *q = worker_queue;
240  	       worker_queue = q-&gt;cdr;
241  	       q-&gt;w = &amp;w;
242  	       os_sem_up(&amp;q-&gt;ready);
243  	       os_sem_down(&amp;termination_semaphore);
244  	       unmake_worker(q);
245  	  }
246       });
247  }
248  static os_static_mutex_t initialization_mutex = OS_STATIC_MUTEX_INITIALIZER;
249  int X(ithreads_init)(void)
250  {
251       os_static_mutex_lock(&amp;initialization_mutex); {
252            os_mutex_init(&amp;queue_lock);
253            os_sem_init(&amp;termination_semaphore);
254            WITH_QUEUE_LOCK({
255                 worker_queue = 0;
256            });
257       } os_static_mutex_unlock(&amp;initialization_mutex);
258       return 0; &amp;bsol;* no error */
259  }
260  void X(spawn_loop)(int loopmax, int nthr, spawn_function proc, void *data)
261  {
262       int block_size;
263       int i;
264       A(loopmax &gt;= 0);
265       A(nthr &gt; 0);
266       A(proc);
267       if (!loopmax) return;
268       block_size = (loopmax + nthr - 1) / nthr;
269       nthr = (loopmax + block_size - 1) / block_size;
270       if (X(spawnloop_callback)) { &amp;bsol;* user-defined spawnloop backend */
271            spawn_data *sdata;
272            STACK_MALLOC(spawn_data *, sdata, sizeof(spawn_data) * nthr);
273            for (i = 0; i &lt; nthr; ++i) {
274                 spawn_data *d = &amp;sdata[i];
275                 d-&gt;max = (d-&gt;min = i * block_size) + block_size;
276                 if (d-&gt;max &gt; loopmax)
277                      d-&gt;max = loopmax;
278                 d-&gt;thr_num = i;
279                 d-&gt;data = data;
280            }
281            X(spawnloop_callback)(proc, sdata, sizeof(spawn_data), nthr, X(spawnloop_callback_data));
282            STACK_FREE(sdata);
283       }
284       else {
285            struct work *r;
286            STACK_MALLOC(struct work *, r, sizeof(struct work) * nthr);
287            for (i = 0; i &lt; nthr; ++i) {
288                 struct work *w = &amp;r[i];
289                 spawn_data *d = &amp;w-&gt;d;
290                 d-&gt;max = (d-&gt;min = i * block_size) + block_size;
291                 if (d-&gt;max &gt; loopmax)
292                      d-&gt;max = loopmax;
293                 d-&gt;thr_num = i;
294                 d-&gt;data = data;
295                 w-&gt;proc = proc;
296                 if (i == nthr - 1) {
297                      proc(d);
298                 } else {
299                      w-&gt;q = dequeue();
300                      w-&gt;q-&gt;w = w; &amp;bsol;* Dirac could have written this */
301                      os_sem_up(&amp;w-&gt;q-&gt;ready);
302                 }
303            }
304            for (i = 0; i &lt; nthr - 1; ++i) {
305                 struct work *w = &amp;r[i];
306                 os_sem_down(&amp;w-&gt;q-&gt;done);
<span onclick='openModal()' class='match'>307                 enqueue(w-&gt;q);
308            }
309            STACK_FREE(r);
310       }
311  }
312  void X(threads_cleanup)(void)
</span>313  {
314       kill_workforce();
315       os_mutex_destroy(&amp;queue_lock);
316       os_sem_destroy(&amp;termination_semaphore);
317  }
318  static os_static_mutex_t install_planner_hooks_mutex = OS_STATIC_MUTEX_INITIALIZER;
319  static os_mutex_t planner_mutex;
320  static int planner_hooks_installed = 0;
321  static void lock_planner_mutex(void)
322  {
323       os_mutex_lock(&amp;planner_mutex);
324  }
325  static void unlock_planner_mutex(void)
326  {
327       os_mutex_unlock(&amp;planner_mutex);
328  }
329  void X(threads_register_planner_hooks)(void)
330  {
331       os_static_mutex_lock(&amp;install_planner_hooks_mutex); {
332            if (!planner_hooks_installed) {
333                 os_mutex_init(&amp;planner_mutex);
334                 X(set_planner_hooks)(lock_planner_mutex, unlock_planner_mutex);
335                 planner_hooks_installed = 1;
336            }
337       } os_static_mutex_unlock(&amp;install_planner_hooks_mutex);
338  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-udprelay.c</h3>
            <pre><code>1  #include &lt;sys/stat.h&gt;
2  #include &lt;sys/types.h&gt;
3  #include &lt;fcntl.h&gt;
4  #include &lt;locale.h&gt;
5  #include &lt;signal.h&gt;
6  #include &lt;string.h&gt;
7  #include &lt;strings.h&gt;
8  #include &lt;time.h&gt;
9  #include &lt;unistd.h&gt;
10  #ifndef __MINGW32__
11  #include &lt;arpa/inet.h&gt;
12  #include &lt;errno.h&gt;
13  #include &lt;netdb.h&gt;
14  #include &lt;netinet/in.h&gt;
15  #include &lt;pthread.h&gt;
16  #endif
17  #ifdef HAVE_CONFIG_H
18  #include &quot;config.h&quot;
19  #endif
20  #if defined(HAVE_SYS_IOCTL_H) &amp;&amp; defined(HAVE_NET_IF_H) &amp;&amp; defined(__linux__)
21  #include &lt;net/if.h&gt;
22  #include &lt;sys/ioctl.h&gt;
23  #define SET_INTERFACE
24  #endif
25  #ifdef __MINGW32__
26  #include &quot;win32.h&quot;
27  #endif
28  #include &lt;libcork/core.h&gt;
29  #include &lt;udns.h&gt;
30  #include &quot;utils.h&quot;
31  #include &quot;netutils.h&quot;
32  #include &quot;cache.h&quot;
33  #include &quot;udprelay.h&quot;
34  #ifdef MODULE_REMOTE
35  #define MAX_UDP_CONN_NUM 512
36  #else
37  #define MAX_UDP_CONN_NUM 256
38  #endif
39  #ifdef MODULE_REMOTE
40  #ifdef MODULE_
41  #error &quot;MODULE_REMOTE and MODULE_LOCAL should not be both defined&quot;
42  #endif
43  #endif
44  #ifndef EAGAIN
45  #define EAGAIN EWOULDBLOCK
46  #endif
47  #ifndef EWOULDBLOCK
48  #define EWOULDBLOCK EAGAIN
49  #endif
50  static void server_recv_cb(EV_P_ ev_io *w, int revents);
51  static void remote_recv_cb(EV_P_ ev_io *w, int revents);
52  static void remote_timeout_cb(EV_P_ ev_timer *watcher, int revents);
53  static char *hash_key(const int af, const struct sockaddr_storage *addr);
54  #ifdef MODULE_REMOTE
55  static void query_resolve_cb(struct sockaddr *addr, void *data);
56  #endif
57  static void close_and_free_remote(EV_P_ remote_ctx_t *ctx);
58  static remote_ctx_t *new_remote(int fd, server_ctx_t *server_ctx);
59  #ifdef ANDROID
60  extern uint64_t tx;
61  extern uint64_t rx;
62  extern int vpn;
63  #endif
64  extern int verbose;
65  #ifdef MODULE_REMOTE
66  extern uint64_t tx;
67  extern uint64_t rx;
68  #endif
69  static int packet_size                               = DEFAULT_PACKET_SIZE;
70  static int buf_size                                  = DEFAULT_PACKET_SIZE * 2;
71  static int server_num                                = 0;
72  static server_ctx_t *server_ctx_list[MAX_REMOTE_NUM] = { NULL };
73  #ifndef __MINGW32__
74  static int
75  setnonblocking(int fd)
76  {
77      int flags;
78      if (-1 == (flags = fcntl(fd, F_GETFL, 0))) {
79          flags = 0;
80      }
81      return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
82  }
83  #endif
84  #if defined(MODULE_REMOTE) &amp;&amp; defined(SO_BROADCAST)
85  static int
86  set_broadcast(int socket_fd)
87  {
88      int opt = 1;
89      return setsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &amp;opt, sizeof(opt));
90  }
91  #endif
92  #ifdef SO_NOSIGPIPE
93  static int
94  set_nosigpipe(int socket_fd)
95  {
96      int opt = 1;
97      return setsockopt(socket_fd, SOL_SOCKET, SO_NOSIGPIPE, &amp;opt, sizeof(opt));
98  }
99  #endif
100  #ifdef MODULE_REDIR
101  #ifndef IP_TRANSPARENT
102  #define IP_TRANSPARENT       19
103  #endif
104  #ifndef IP_RECVORIGDSTADDR
105  #define IP_RECVORIGDSTADDR   20
106  #endif
107  static int
108  get_dstaddr(struct msghdr *msg, struct sockaddr_storage *dstaddr)
109  {
110      struct cmsghdr *cmsg;
111      for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
112          if (cmsg-&gt;cmsg_level == SOL_IP &amp;&amp; cmsg-&gt;cmsg_type == IP_RECVORIGDSTADDR) {
113              memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in));
114              dstaddr-&gt;ss_family = AF_INET;
115              return 0;
116          } else if (cmsg-&gt;cmsg_level == SOL_IPV6 &amp;&amp; cmsg-&gt;cmsg_type == IP_RECVORIGDSTADDR) {
117              memcpy(dstaddr, CMSG_DATA(cmsg), sizeof(struct sockaddr_in6));
118              dstaddr-&gt;ss_family = AF_INET6;
119              return 0;
120          }
121      }
122      return 1;
123  }
124  #endif
125  #define HASH_KEY_LEN sizeof(struct sockaddr_storage) + sizeof(int)
126  static char *
127  hash_key(const int af, const struct sockaddr_storage *addr)
128  {
129      size_t addr_len = sizeof(struct sockaddr_storage);
130      static char key[HASH_KEY_LEN];
131      memset(key, 0, HASH_KEY_LEN);
132      memcpy(key, &amp;af, sizeof(int));
133      memcpy(key + sizeof(int), (const uint8_t *)addr, addr_len);
134      return key;
135  }
136  #if defined(MODULE_REDIR) || defined(MODULE_REMOTE)
137  static int
138  construct_udprealy_header(const struct sockaddr_storage *in_addr,
139                            char *addr_header)
140  {
141      int addr_header_len = 0;
142      if (in_addr-&gt;ss_family == AF_INET) {
143          struct sockaddr_in *addr = (struct sockaddr_in *)in_addr;
144          size_t addr_len          = sizeof(struct in_addr);
145          addr_header[addr_header_len++] = 1;
146          memcpy(addr_header + addr_header_len, &amp;addr-&gt;sin_addr, addr_len);
147          addr_header_len += addr_len;
148          memcpy(addr_header + addr_header_len, &amp;addr-&gt;sin_port, 2);
149          addr_header_len += 2;
150      } else if (in_addr-&gt;ss_family == AF_INET6) {
151          struct sockaddr_in6 *addr = (struct sockaddr_in6 *)in_addr;
152          size_t addr_len           = sizeof(struct in6_addr);
153          addr_header[addr_header_len++] = 4;
154          memcpy(addr_header + addr_header_len, &amp;addr-&gt;sin6_addr, addr_len);
155          addr_header_len += addr_len;
156          memcpy(addr_header + addr_header_len, &amp;addr-&gt;sin6_port, 2);
157          addr_header_len += 2;
158      } else {
159          return 0;
160      }
161      return addr_header_len;
162  }
163  #endif
164  static int
165  parse_udprealy_header(const char *buf, const size_t buf_len,
166                        char *host, char *port, struct sockaddr_storage *storage)
167  {
168      const uint8_t atyp = *(uint8_t *)buf;
169      int offset         = 1;
170      if ((atyp &amp; ADDRTYPE_MASK) == 1) {
171          size_t in_addr_len = sizeof(struct in_addr);
172          if (buf_len &gt;= in_addr_len + 3) {
173              if (storage != NULL) {
174                  struct sockaddr_in *addr = (struct sockaddr_in *)storage;
175                  addr-&gt;sin_family = AF_INET;
176                  addr-&gt;sin_addr   = *(struct in_addr *)(buf + offset);
177                  addr-&gt;sin_port   = *(uint16_t *)(buf + offset + in_addr_len);
178              }
179              if (host != NULL) {
180                  dns_ntop(AF_INET, (const void *)(buf + offset),
181                           host, INET_ADDRSTRLEN);
182              }
183              offset += in_addr_len;
184          }
185      } else if ((atyp &amp; ADDRTYPE_MASK) == 3) {
186          uint8_t name_len = *(uint8_t *)(buf + offset);
187          if (name_len + 4 &lt;= buf_len) {
188              if (storage != NULL) {
189                  char tmp[257] = { 0 };
190                  struct cork_ip ip;
191                  memcpy(tmp, buf + offset + 1, name_len);
192                  if (cork_ip_init(&amp;ip, tmp) != -1) {
193                      if (ip.version == 4) {
194                          struct sockaddr_in *addr = (struct sockaddr_in *)storage;
195                          dns_pton(AF_INET, tmp, &amp;(addr-&gt;sin_addr));
196                          addr-&gt;sin_port   = *(uint16_t *)(buf + offset + 1 + name_len);
197                          addr-&gt;sin_family = AF_INET;
198                      } else if (ip.version == 6) {
199                          struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
200                          dns_pton(AF_INET, tmp, &amp;(addr-&gt;sin6_addr));
201                          addr-&gt;sin6_port   = *(uint16_t *)(buf + offset + 1 + name_len);
202                          addr-&gt;sin6_family = AF_INET6;
203                      }
204                  }
205              }
206              if (host != NULL) {
207                  memcpy(host, buf + offset + 1, name_len);
208              }
209              offset += 1 + name_len;
210          }
211      } else if ((atyp &amp; ADDRTYPE_MASK) == 4) {
212          size_t in6_addr_len = sizeof(struct in6_addr);
213          if (buf_len &gt;= in6_addr_len + 3) {
214              if (storage != NULL) {
215                  struct sockaddr_in6 *addr = (struct sockaddr_in6 *)storage;
216                  addr-&gt;sin6_family = AF_INET6;
217                  addr-&gt;sin6_addr   = *(struct in6_addr *)(buf + offset);
218                  addr-&gt;sin6_port   = *(uint16_t *)(buf + offset + in6_addr_len);
219              }
220              if (host != NULL) {
221                  dns_ntop(AF_INET6, (const void *)(buf + offset),
222                           host, INET6_ADDRSTRLEN);
223              }
224              offset += in6_addr_len;
225          }
226      }
227      if (offset == 1) {
228          LOGE(&quot;[udp] invalid header with addr type %d&quot;, atyp);
229          return 0;
230      }
231      if (port != NULL) {
232          sprintf(port, &quot;%d&quot;, ntohs(*(uint16_t *)(buf + offset)));
233      }
234      offset += 2;
235      return offset;
236  }
237  static char *
238  get_addr_str(const struct sockaddr *sa)
239  {
240      static char s[SS_ADDRSTRLEN];
241      memset(s, 0, SS_ADDRSTRLEN);
242      char addr[INET6_ADDRSTRLEN] = { 0 };
243      char port[PORTSTRLEN]       = { 0 };
244      uint16_t p;
245      switch (sa-&gt;sa_family) {
246      case AF_INET:
247          dns_ntop(AF_INET, &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr),
248                   addr, INET_ADDRSTRLEN);
249          p = ntohs(((struct sockaddr_in *)sa)-&gt;sin_port);
250          sprintf(port, &quot;%d&quot;, p);
251          break;
252      case AF_INET6:
253          dns_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr),
254                   addr, INET6_ADDRSTRLEN);
255          p = ntohs(((struct sockaddr_in *)sa)-&gt;sin_port);
256          sprintf(port, &quot;%d&quot;, p);
257          break;
258      default:
259          strncpy(s, &quot;Unknown AF&quot;, SS_ADDRSTRLEN);
260      }
261      int addr_len = strlen(addr);
262      int port_len = strlen(port);
263      memcpy(s, addr, addr_len);
264      memcpy(s + addr_len + 1, port, port_len);
265      s[addr_len] = &#x27;:&#x27;;
266      return s;
267  }
268  int
269  create_remote_socket(int ipv6)
270  {
271      int remote_sock;
272      if (ipv6) {
273          struct sockaddr_in6 addr;
274          memset(&amp;addr, 0, sizeof(struct sockaddr_in6));
275          addr.sin6_family = AF_INET6;
276          addr.sin6_addr   = in6addr_any;
277          addr.sin6_port   = 0;
278          remote_sock      = socket(AF_INET6, SOCK_DGRAM, 0);
279          if (remote_sock == -1) {
280              ERROR(&quot;[udp] cannot create socket&quot;);
281              return -1;
282          }
283          if (bind(remote_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) != 0) {
284              FATAL(&quot;[udp] cannot bind remote&quot;);
285              return -1;
286          }
287      } else {
288          struct sockaddr_in addr;
289          memset(&amp;addr, 0, sizeof(struct sockaddr_in));
290          addr.sin_family      = AF_INET;
291          addr.sin_addr.s_addr = INADDR_ANY;
292          addr.sin_port        = 0;
293          remote_sock          = socket(AF_INET, SOCK_DGRAM, 0);
294          if (remote_sock == -1) {
295              ERROR(&quot;[udp] cannot create socket&quot;);
296              return -1;
297          }
298          if (bind(remote_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) != 0) {
299              FATAL(&quot;[udp] cannot bind remote&quot;);
300              return -1;
301          }
302      }
303      return remote_sock;
304  }
305  int
306  create_server_socket(const char *host, const char *port)
307  {
308      struct addrinfo hints;
309      struct addrinfo *result, *rp, *ipv4v6bindall;
310      int s, server_sock;
311      memset(&amp;hints, 0, sizeof(struct addrinfo));
312      hints.ai_family   = AF_UNSPEC;               &amp;bsol;* Return IPv4 and IPv6 choices */
313      hints.ai_socktype = SOCK_DGRAM;              &amp;bsol;* We want a UDP socket */
314      hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG; &amp;bsol;* For wildcard IP address */
315      hints.ai_protocol = IPPROTO_UDP;
316      s = getaddrinfo(host, port, &amp;hints, &amp;result);
317      if (s != 0) {
318          LOGE(&quot;[udp] getaddrinfo: %s&quot;, gai_strerror(s));
319          return -1;
320      }
321      rp = result;
322      if (!host) {
323          ipv4v6bindall = result;
324          while (ipv4v6bindall) {
325              if (ipv4v6bindall-&gt;ai_family == AF_INET6) {
326                  rp = ipv4v6bindall; &amp;bsol;* Take first IPV6 address available */
327                  break;
328              }
329              ipv4v6bindall = ipv4v6bindall-&gt;ai_next; &amp;bsol;* Get next address info, if any */
330          }
331      }
332      for (&amp;bsol;*rp = result*/; rp != NULL; rp = rp-&gt;ai_next) {
333          server_sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
334          if (server_sock == -1) {
335              continue;
336          }
337          if (rp-&gt;ai_family == AF_INET6) {
338              int ipv6only = host ? 1 : 0;
339              setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &amp;ipv6only, sizeof(ipv6only));
340          }
341          int opt = 1;
342          setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
343  #ifdef SO_NOSIGPIPE
344          set_nosigpipe(server_sock);
345  #endif
346          int err = set_reuseport(server_sock);
347          if (err == 0) {
348              LOGI(&quot;udp port reuse enabled&quot;);
349          }
350  #ifdef IP_TOS
351          int tos = 46;
352          setsockopt(server_sock, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));
353  #endif
354  #ifdef MODULE_REDIR
355          if (setsockopt(server_sock, SOL_IP, IP_TRANSPARENT, &amp;opt, sizeof(opt))) {
356              ERROR(&quot;[udp] setsockopt IP_TRANSPARENT&quot;);
357              exit(EXIT_FAILURE);
358          }
359          if (setsockopt(server_sock, IPPROTO_IP, IP_RECVORIGDSTADDR, &amp;opt, sizeof(opt))) {
360              FATAL(&quot;[udp] setsockopt IP_RECVORIGDSTADDR&quot;);
361          }
362  #endif
363          s = bind(server_sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen);
364          if (s == 0) {
365              break;
366          } else {
367              ERROR(&quot;[udp] bind&quot;);
368          }
369          close(server_sock);
370      }
371      if (rp == NULL) {
372          LOGE(&quot;[udp] cannot bind&quot;);
373          return -1;
374      }
375      freeaddrinfo(result);
376      return server_sock;
377  }
378  remote_ctx_t *
379  new_remote(int fd, server_ctx_t *server_ctx)
380  {
381      remote_ctx_t *ctx = ss_malloc(sizeof(remote_ctx_t));
382      memset(ctx, 0, sizeof(remote_ctx_t));
383      ctx-&gt;fd         = fd;
384      ctx-&gt;server_ctx = server_ctx;
385      ev_io_init(&amp;ctx-&gt;io, remote_recv_cb, fd, EV_READ);
386      ev_timer_init(&amp;ctx-&gt;watcher, remote_timeout_cb, server_ctx-&gt;timeout,
387                    server_ctx-&gt;timeout);
388      return ctx;
389  }
390  server_ctx_t *
391  new_server_ctx(int fd)
392  {
393      server_ctx_t *ctx = ss_malloc(sizeof(server_ctx_t));
394      memset(ctx, 0, sizeof(server_ctx_t));
395      ctx-&gt;fd = fd;
396      ev_io_init(&amp;ctx-&gt;io, server_recv_cb, fd, EV_READ);
397      return ctx;
398  }
399  #ifdef MODULE_REMOTE
400  struct query_ctx *
401  new_query_ctx(char *buf, size_t len)
402  {
403      struct query_ctx *ctx = ss_malloc(sizeof(struct query_ctx));
404      memset(ctx, 0, sizeof(struct query_ctx));
405      ctx-&gt;buf = ss_malloc(sizeof(buffer_t));
406      balloc(ctx-&gt;buf, len);
407      memcpy(ctx-&gt;buf-&gt;array, buf, len);
408      ctx-&gt;buf-&gt;len = len;
409      return ctx;
410  }
411  void
412  close_and_free_query(EV_P_ struct query_ctx *ctx)
413  {
414      if (ctx != NULL) {
415          if (ctx-&gt;query != NULL) {
416              resolv_cancel(ctx-&gt;query);
417              ctx-&gt;query = NULL;
418          }
419          if (ctx-&gt;buf != NULL) {
420              bfree(ctx-&gt;buf);
<span onclick='openModal()' class='match'>421              ss_free(ctx-&gt;buf);
422          }
423          ss_free(ctx);
424      }
425  }
426  #endif
</span>427  void
428  close_and_free_remote(EV_P_ remote_ctx_t *ctx)
429  {
430      if (ctx != NULL) {
431          ev_timer_stop(EV_A_ &amp; ctx-&gt;watcher);
432          ev_io_stop(EV_A_ &amp; ctx-&gt;io);
433          close(ctx-&gt;fd);
434          ss_free(ctx);
435      }
436  }
437  static void
438  remote_timeout_cb(EV_P_ ev_timer *watcher, int revents)
439  {
440      remote_ctx_t *remote_ctx
441          = cork_container_of(watcher, remote_ctx_t, watcher);
442      if (verbose) {
443          LOGI(&quot;[udp] connection timeout&quot;);
444      }
445      char *key = hash_key(remote_ctx-&gt;af, &amp;remote_ctx-&gt;src_addr);
446      cache_remove(remote_ctx-&gt;server_ctx-&gt;conn_cache, key, HASH_KEY_LEN);
447  }
448  #ifdef MODULE_REMOTE
449  static void
450  query_resolve_cb(struct sockaddr *addr, void *data)
451  {
452      struct query_ctx *query_ctx = (struct query_ctx *)data;
453      struct ev_loop *loop        = query_ctx-&gt;server_ctx-&gt;loop;
454      if (verbose) {
455          LOGI(&quot;[udp] udns resolved&quot;);
456      }
457      query_ctx-&gt;query = NULL;
458      if (addr == NULL) {
459          LOGE(&quot;[udp] udns returned an error&quot;);
460      } else {
461          remote_ctx_t *remote_ctx = query_ctx-&gt;remote_ctx;
462          int cache_hit            = 0;
463          if (remote_ctx == NULL) {
464              char *key = hash_key(AF_UNSPEC, &amp;query_ctx-&gt;src_addr);
465              cache_lookup(query_ctx-&gt;server_ctx-&gt;conn_cache, key, HASH_KEY_LEN, (void *)&amp;remote_ctx);
466          }
467          if (remote_ctx == NULL) {
468              int remotefd = create_remote_socket(addr-&gt;sa_family == AF_INET6);
469              if (remotefd != -1) {
470                  setnonblocking(remotefd);
471  #ifdef SO_BROADCAST
472                  set_broadcast(remotefd);
473  #endif
474  #ifdef SO_NOSIGPIPE
475                  set_nosigpipe(remotefd);
476  #endif
477  #ifdef IP_TOS
478                  int tos = 46;
479                  setsockopt(remotefd, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));
480  #endif
481  #ifdef SET_INTERFACE
482                  if (query_ctx-&gt;server_ctx-&gt;iface) {
483                      if (setinterface(remotefd, query_ctx-&gt;server_ctx-&gt;iface) == -1)
484                          ERROR(&quot;setinterface&quot;);
485                  }
486  #endif
487                  remote_ctx                  = new_remote(remotefd, query_ctx-&gt;server_ctx);
488                  remote_ctx-&gt;src_addr        = query_ctx-&gt;src_addr;
489                  remote_ctx-&gt;server_ctx      = query_ctx-&gt;server_ctx;
490                  remote_ctx-&gt;addr_header_len = query_ctx-&gt;addr_header_len;
491                  memcpy(remote_ctx-&gt;addr_header, query_ctx-&gt;addr_header,
492                         query_ctx-&gt;addr_header_len);
493              } else {
494                  ERROR(&quot;[udp] bind() error&quot;);
495              }
496          } else {
497              cache_hit = 1;
498          }
499          if (remote_ctx != NULL) {
500              memcpy(&amp;remote_ctx-&gt;dst_addr, addr, sizeof(struct sockaddr_storage));
501              size_t addr_len = get_sockaddr_len(addr);
502              int s           = sendto(remote_ctx-&gt;fd, query_ctx-&gt;buf-&gt;array, query_ctx-&gt;buf-&gt;len,
503                                       0, addr, addr_len);
504              if (s == -1) {
505                  ERROR(&quot;[udp] sendto_remote&quot;);
506                  if (!cache_hit) {
507                      close_and_free_remote(EV_A_ remote_ctx);
508                  }
509              } else {
510                  if (!cache_hit) {
511                      char *key = hash_key(AF_UNSPEC, &amp;remote_ctx-&gt;src_addr);
512                      cache_insert(query_ctx-&gt;server_ctx-&gt;conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
513                      ev_io_start(EV_A_ &amp; remote_ctx-&gt;io);
514                      ev_timer_start(EV_A_ &amp; remote_ctx-&gt;watcher);
515                  }
516              }
517          }
518      }
519      close_and_free_query(EV_A_ query_ctx);
520  }
521  #endif
522  static void
523  remote_recv_cb(EV_P_ ev_io *w, int revents)
524  {
525      ssize_t r;
526      remote_ctx_t *remote_ctx = (remote_ctx_t *)w;
527      server_ctx_t *server_ctx = remote_ctx-&gt;server_ctx;
528      if (server_ctx == NULL) {
529          LOGE(&quot;[udp] invalid server&quot;);
530          close_and_free_remote(EV_A_ remote_ctx);
531          return;
532      }
533      struct sockaddr_storage src_addr;
534      socklen_t src_addr_len = sizeof(struct sockaddr_storage);
535      memset(&amp;src_addr, 0, src_addr_len);
536      buffer_t *buf = ss_malloc(sizeof(buffer_t));
537      balloc(buf, buf_size);
538      r = recvfrom(remote_ctx-&gt;fd, buf-&gt;array, buf_size, 0, (struct sockaddr *)&amp;src_addr, &amp;src_addr_len);
539      if (r == -1) {
540          ERROR(&quot;[udp] remote_recv_recvfrom&quot;);
541          goto CLEAN_UP;
542      } else if (r &gt; packet_size) {
543          LOGE(&quot;[udp] remote_recv_recvfrom fragmentation&quot;);
544          goto CLEAN_UP;
545      }
546      buf-&gt;len = r;
547  #ifdef MODULE_LOCAL
548      int err = ss_decrypt_all(buf, server_ctx-&gt;method, 0, buf_size);
549      if (err) {
550          goto CLEAN_UP;
551      }
552      if (server_ctx-&gt;protocol_plugin) {
553          obfs_class *protocol_plugin = server_ctx-&gt;protocol_plugin;
554          if (protocol_plugin-&gt;client_udp_post_decrypt) {
555              buf-&gt;len = protocol_plugin-&gt;client_udp_post_decrypt(server_ctx-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
556              if ((int)buf-&gt;len &lt; 0) {
557                  LOGE(&quot;client_udp_post_decrypt&quot;);
558                  close_and_free_remote(EV_A_ remote_ctx);
559                  return;
560              }
561              if ( buf-&gt;len == 0 )
562                  return;
563          }
564      }
565  #ifdef MODULE_REDIR
566      struct sockaddr_storage dst_addr;
567      memset(&amp;dst_addr, 0, sizeof(struct sockaddr_storage));
568      int len = parse_udprealy_header(buf-&gt;array, buf-&gt;len, NULL, NULL, &amp;dst_addr);
569      if (dst_addr.ss_family != AF_INET &amp;&amp; dst_addr.ss_family != AF_INET6) {
570          LOGI(&quot;[udp] ss-redir does not support domain name&quot;);
571          goto CLEAN_UP;
572      }
573      if (verbose) {
574          char src[SS_ADDRSTRLEN];
575          char dst[SS_ADDRSTRLEN];
576          strcpy(src, get_addr_str((struct sockaddr *)&amp;src_addr));
577          strcpy(dst, get_addr_str((struct sockaddr *)&amp;dst_addr));
578          LOGI(&quot;[udp] recv %s via %s&quot;, dst, src);
579      }
580  #else
581      int len = parse_udprealy_header(buf-&gt;array, buf-&gt;len, NULL, NULL, NULL);
582  #endif
583      if (len == 0) {
584          LOGI(&quot;[udp] error in parse header&quot;);
585          goto CLEAN_UP;
586      }
587  #if defined(MODULE_TUNNEL) || defined(MODULE_REDIR)
588      buf-&gt;len -= len;
589      memmove(buf-&gt;array, buf-&gt;array + len, buf-&gt;len);
590  #else
591  #ifdef ANDROID
592      rx += buf-&gt;len;
593  #endif
594      brealloc(buf, buf-&gt;len + 3, buf_size);
595      memmove(buf-&gt;array + 3, buf-&gt;array, buf-&gt;len);
596      memset(buf-&gt;array, 0, 3);
597      buf-&gt;len += 3;
598  #endif
599  #endif
600  #ifdef MODULE_REMOTE
601      rx += buf-&gt;len;
602      char addr_header_buf[512];
603      char *addr_header   = remote_ctx-&gt;addr_header;
604      int addr_header_len = remote_ctx-&gt;addr_header_len;
605      if (remote_ctx-&gt;af == AF_INET || remote_ctx-&gt;af == AF_INET6) {
606          addr_header_len = construct_udprealy_header(&amp;src_addr, addr_header_buf);
607          addr_header     = addr_header_buf;
608      }
609      brealloc(buf, buf-&gt;len + addr_header_len, buf_size);
610      memmove(buf-&gt;array + addr_header_len, buf-&gt;array, buf-&gt;len);
611      memcpy(buf-&gt;array, addr_header, addr_header_len);
612      buf-&gt;len += addr_header_len;
613      int err = ss_encrypt_all(buf, server_ctx-&gt;method, 0, buf_size);
614      if (err) {
615          goto CLEAN_UP;
616      }
617  #endif
618      if (buf-&gt;len &gt; packet_size) {
619          LOGE(&quot;[udp] remote_recv_sendto fragmentation&quot;);
620          goto CLEAN_UP;
621      }
622      size_t remote_src_addr_len = get_sockaddr_len((struct sockaddr *)&amp;remote_ctx-&gt;src_addr);
623  #ifdef MODULE_REDIR
624      size_t remote_dst_addr_len = get_sockaddr_len((struct sockaddr *)&amp;dst_addr);
625      int src_fd = socket(remote_ctx-&gt;src_addr.ss_family, SOCK_DGRAM, 0);
626      if (src_fd &lt; 0) {
627          ERROR(&quot;[udp] remote_recv_socket&quot;);
628          goto CLEAN_UP;
629      }
630      int opt = 1;
631      if (setsockopt(src_fd, SOL_IP, IP_TRANSPARENT, &amp;opt, sizeof(opt))) {
632          ERROR(&quot;[udp] remote_recv_setsockopt&quot;);
633          close(src_fd);
634          goto CLEAN_UP;
635      }
636      if (setsockopt(src_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt))) {
637          ERROR(&quot;[udp] remote_recv_setsockopt&quot;);
638          close(src_fd);
639          goto CLEAN_UP;
640      }
641  #ifdef IP_TOS
642      int tos = 46;
643      setsockopt(src_fd, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));
644  #endif
645      if (bind(src_fd, (struct sockaddr *)&amp;dst_addr, remote_dst_addr_len) != 0) {
646          ERROR(&quot;[udp] remote_recv_bind&quot;);
647          close(src_fd);
648          goto CLEAN_UP;
649      }
650      int s = sendto(src_fd, buf-&gt;array, buf-&gt;len, 0,
651                     (struct sockaddr *)&amp;remote_ctx-&gt;src_addr, remote_src_addr_len);
652      if (s == -1) {
653          ERROR(&quot;[udp] remote_recv_sendto&quot;);
654          close(src_fd);
655          goto CLEAN_UP;
656      }
657      close(src_fd);
658  #else
659      int s = sendto(server_ctx-&gt;fd, buf-&gt;array, buf-&gt;len, 0,
660                     (struct sockaddr *)&amp;remote_ctx-&gt;src_addr, remote_src_addr_len);
661      if (s == -1) {
662          ERROR(&quot;[udp] remote_recv_sendto&quot;);
663          goto CLEAN_UP;
664      }
665  #endif
666      ev_timer_again(EV_A_ &amp; remote_ctx-&gt;watcher);
667  CLEAN_UP:
668      bfree(buf);
669      ss_free(buf);
670  }
671  static void
672  server_recv_cb(EV_P_ ev_io *w, int revents)
673  {
674      server_ctx_t *server_ctx = (server_ctx_t *)w;
675      struct sockaddr_storage src_addr;
676      memset(&amp;src_addr, 0, sizeof(struct sockaddr_storage));
677      buffer_t *buf = ss_malloc(sizeof(buffer_t));
678      balloc(buf, buf_size);
679      socklen_t src_addr_len = sizeof(struct sockaddr_storage);
680      unsigned int offset    = 0;
681  #ifdef MODULE_REDIR
682      char control_buffer[64] = { 0 };
683      struct msghdr msg;
684      memset(&amp;msg, 0, sizeof(struct msghdr));
685      struct iovec iov[1];
686      struct sockaddr_storage dst_addr;
687      memset(&amp;dst_addr, 0, sizeof(struct sockaddr_storage));
688      msg.msg_name       = &amp;src_addr;
689      msg.msg_namelen    = src_addr_len;
690      msg.msg_control    = control_buffer;
691      msg.msg_controllen = sizeof(control_buffer);
692      iov[0].iov_base = buf-&gt;array;
693      iov[0].iov_len  = buf_size;
694      msg.msg_iov     = iov;
695      msg.msg_iovlen  = 1;
696      buf-&gt;len = recvmsg(server_ctx-&gt;fd, &amp;msg, 0);
697      if (buf-&gt;len == -1) {
698          ERROR(&quot;[udp] server_recvmsg&quot;);
699          goto CLEAN_UP;
700      } else if (buf-&gt;len &gt; packet_size) {
701          ERROR(&quot;[udp] UDP server_recv_recvmsg fragmentation&quot;);
702          goto CLEAN_UP;
703      }
704      if (get_dstaddr(&amp;msg, &amp;dst_addr)) {
705          LOGE(&quot;[udp] unable to get dest addr&quot;);
706          goto CLEAN_UP;
707      }
708      src_addr_len = msg.msg_namelen;
709  #else
710      ssize_t r;
711      r = recvfrom(server_ctx-&gt;fd, buf-&gt;array, buf_size,
712                   0, (struct sockaddr *)&amp;src_addr, &amp;src_addr_len);
713      if (r == -1) {
714          ERROR(&quot;[udp] server_recv_recvfrom&quot;);
715          goto CLEAN_UP;
716      } else if (r &gt; packet_size) {
717          ERROR(&quot;[udp] server_recv_recvfrom fragmentation&quot;);
718          goto CLEAN_UP;
719      }
720      buf-&gt;len = r;
721  #endif
722  #ifdef MODULE_REMOTE
723      tx += buf-&gt;len;
724      int err = ss_decrypt_all(buf, server_ctx-&gt;method, server_ctx-&gt;auth, buf_size);
725      if (err) {
726          goto CLEAN_UP;
727      }
728  #endif
729  #ifdef MODULE_LOCAL
730  #if !defined(MODULE_TUNNEL) &amp;&amp; !defined(MODULE_REDIR)
731  #ifdef ANDROID
732      tx += buf-&gt;len;
733  #endif
734      uint8_t frag = *(uint8_t *)(buf-&gt;array + 2);
735      offset += 3;
736  #endif
737  #endif
738  #ifdef MODULE_REDIR
739      if (verbose) {
740          char src[SS_ADDRSTRLEN];
741          char dst[SS_ADDRSTRLEN];
742          strcpy(src, get_addr_str((struct sockaddr *)&amp;src_addr));
743          strcpy(dst, get_addr_str((struct sockaddr *)&amp;dst_addr));
744          LOGI(&quot;[udp] redir to %s from %s&quot;, dst, src);
745      }
746      char addr_header[512] = { 0 };
747      int addr_header_len   = construct_udprealy_header(&amp;dst_addr, addr_header);
748      if (addr_header_len == 0) {
749          LOGE(&quot;[udp] failed to parse tproxy addr&quot;);
750          goto CLEAN_UP;
751      }
752      brealloc(buf, buf-&gt;len + addr_header_len, buf_size);
753      memmove(buf-&gt;array + addr_header_len, buf-&gt;array, buf-&gt;len);
754      memcpy(buf-&gt;array, addr_header, addr_header_len);
755      buf-&gt;len += addr_header_len;
756  #elif MODULE_TUNNEL
757      char addr_header[512] = { 0 };
758      char *host            = server_ctx-&gt;tunnel_addr.host;
759      char *port            = server_ctx-&gt;tunnel_addr.port;
760      uint16_t port_num     = (uint16_t)atoi(port);
761      uint16_t port_net_num = htons(port_num);
762      int addr_header_len   = 0;
763      struct cork_ip ip;
764      if (cork_ip_init(&amp;ip, host) != -1) {
765          if (ip.version == 4) {
766              struct in_addr host_addr;
767              memset(&amp;host_addr, 0, sizeof(struct in_addr));
768              int host_len = sizeof(struct in_addr);
769              if (dns_pton(AF_INET, host, &amp;host_addr) == -1) {
770                  FATAL(&quot;IP parser error&quot;);
771              }
772              addr_header[addr_header_len++] = 1;
773              memcpy(addr_header + addr_header_len, &amp;host_addr, host_len);
774              addr_header_len += host_len;
775          } else if (ip.version == 6) {
776              struct in6_addr host_addr;
777              memset(&amp;host_addr, 0, sizeof(struct in6_addr));
778              int host_len = sizeof(struct in6_addr);
779              if (dns_pton(AF_INET6, host, &amp;host_addr) == -1) {
780                  FATAL(&quot;IP parser error&quot;);
781              }
782              addr_header[addr_header_len++] = 4;
783              memcpy(addr_header + addr_header_len, &amp;host_addr, host_len);
784              addr_header_len += host_len;
785          } else {
786              FATAL(&quot;IP parser error&quot;);
787          }
788      } else {
789          int host_len = strlen(host);
790          addr_header[addr_header_len++] = 3;
791          addr_header[addr_header_len++] = host_len;
792          memcpy(addr_header + addr_header_len, host, host_len);
793          addr_header_len += host_len;
794      }
795      memcpy(addr_header + addr_header_len, &amp;port_net_num, 2);
796      addr_header_len += 2;
797      brealloc(buf, buf-&gt;len + addr_header_len, buf_size);
798      memmove(buf-&gt;array + addr_header_len, buf-&gt;array, buf-&gt;len);
799      memcpy(buf-&gt;array, addr_header, addr_header_len);
800      buf-&gt;len += addr_header_len;
801  #else
802      char host[257] = { 0 };
803      char port[64]  = { 0 };
804      struct sockaddr_storage dst_addr;
805      memset(&amp;dst_addr, 0, sizeof(struct sockaddr_storage));
806      int addr_header_len = parse_udprealy_header(buf-&gt;array + offset, buf-&gt;len - offset,
807                                                  host, port, &amp;dst_addr);
808      if (addr_header_len == 0) {
809          goto CLEAN_UP;
810      }
811      char *addr_header = buf-&gt;array + offset;
812  #endif
813  #ifdef MODULE_LOCAL
814      char *key = hash_key(server_ctx-&gt;remote_addr-&gt;sa_family, &amp;src_addr);
815  #else
816      char *key = hash_key(dst_addr.ss_family, &amp;src_addr);
817  #endif
818      struct cache *conn_cache = server_ctx-&gt;conn_cache;
819      remote_ctx_t *remote_ctx = NULL;
820      cache_lookup(conn_cache, key, HASH_KEY_LEN, (void *)&amp;remote_ctx);
821      if (remote_ctx != NULL) {
822          if (sockaddr_cmp(&amp;src_addr, &amp;remote_ctx-&gt;src_addr, sizeof(src_addr))) {
823              remote_ctx = NULL;
824          }
825      }
826      if (remote_ctx != NULL) {
827          ev_timer_again(EV_A_ &amp; remote_ctx-&gt;watcher);
828      }
829      if (remote_ctx == NULL) {
830          if (verbose) {
831  #ifdef MODULE_REDIR
832              char src[SS_ADDRSTRLEN];
833              char dst[SS_ADDRSTRLEN];
834              strcpy(src, get_addr_str((struct sockaddr *)&amp;src_addr));
835              strcpy(dst, get_addr_str((struct sockaddr *)&amp;dst_addr));
836              LOGI(&quot;[udp] cache miss: %s &lt;-&gt; %s&quot;, dst, src);
837  #else
838              LOGI(&quot;[udp] cache miss: %s:%s &lt;-&gt; %s&quot;, host, port,
839                   get_addr_str((struct sockaddr *)&amp;src_addr));
840  #endif
841          }
842      } else {
843          if (verbose) {
844  #ifdef MODULE_REDIR
845              char src[SS_ADDRSTRLEN];
846              char dst[SS_ADDRSTRLEN];
847              strcpy(src, get_addr_str((struct sockaddr *)&amp;src_addr));
848              strcpy(dst, get_addr_str((struct sockaddr *)&amp;dst_addr));
849              LOGI(&quot;[udp] cache hit: %s &lt;-&gt; %s&quot;, dst, src);
850  #else
851              LOGI(&quot;[udp] cache hit: %s:%s &lt;-&gt; %s&quot;, host, port,
852                   get_addr_str((struct sockaddr *)&amp;src_addr));
853  #endif
854          }
855      }
856  #ifdef MODULE_LOCAL
857  #if !defined(MODULE_TUNNEL) &amp;&amp; !defined(MODULE_REDIR)
858      if (frag) {
859          LOGE(&quot;[udp] drop a message since frag is not 0, but %d&quot;, frag);
860          goto CLEAN_UP;
861      }
862  #endif
863      const struct sockaddr *remote_addr = server_ctx-&gt;remote_addr;
864      const int remote_addr_len          = server_ctx-&gt;remote_addr_len;
865      if (remote_ctx == NULL) {
866          int remotefd = create_remote_socket(remote_addr-&gt;sa_family == AF_INET6);
867          if (remotefd &lt; 0) {
868              ERROR(&quot;[udp] udprelay bind() error&quot;);
869              goto CLEAN_UP;
870          }
871          setnonblocking(remotefd);
872  #ifdef SO_NOSIGPIPE
873          set_nosigpipe(remotefd);
874  #endif
875  #ifdef IP_TOS
876          int tos = 46;
877          setsockopt(remotefd, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));
878  #endif
879  #ifdef SET_INTERFACE
880          if (server_ctx-&gt;iface) {
881              if (setinterface(remotefd, server_ctx-&gt;iface) == -1)
882                  ERROR(&quot;setinterface&quot;);
883          }
884  #endif
885  #ifdef ANDROID
886          if (vpn) {
887              if (protect_socket(remotefd) == -1) {
888                  ERROR(&quot;protect_socket&quot;);
889                  close(remotefd);
890                  goto CLEAN_UP;
891              }
892          }
893  #endif
894          remote_ctx                  = new_remote(remotefd, server_ctx);
895          remote_ctx-&gt;src_addr        = src_addr;
896          remote_ctx-&gt;af              = remote_addr-&gt;sa_family;
897          remote_ctx-&gt;addr_header_len = addr_header_len;
898          memcpy(remote_ctx-&gt;addr_header, addr_header, addr_header_len);
899          cache_insert(conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
900          ev_io_start(EV_A_ &amp; remote_ctx-&gt;io);
901          ev_timer_start(EV_A_ &amp; remote_ctx-&gt;watcher);
902      }
903      if (offset &gt; 0) {
904          buf-&gt;len -= offset;
905          memmove(buf-&gt;array, buf-&gt;array + offset, buf-&gt;len);
906      }
907      if (server_ctx-&gt;auth) {
908          buf-&gt;array[0] |= ONETIMEAUTH_FLAG;
909      }
910      if (server_ctx-&gt;protocol_plugin) {
911          obfs_class *protocol_plugin = server_ctx-&gt;protocol_plugin;
912          if (protocol_plugin-&gt;client_udp_pre_encrypt) {
913              buf-&gt;len = protocol_plugin-&gt;client_udp_pre_encrypt(server_ctx-&gt;protocol, &amp;buf-&gt;array, buf-&gt;len, &amp;buf-&gt;capacity);
914          }
915      }
916      int err = ss_encrypt_all(buf, server_ctx-&gt;method, server_ctx-&gt;auth, buf-&gt;len);
917      if (err) {
918          goto CLEAN_UP;
919      }
920      if (buf-&gt;len &gt; packet_size) {
921          LOGE(&quot;[udp] server_recv_sendto fragmentation&quot;);
922          goto CLEAN_UP;
923      }
924      int s = sendto(remote_ctx-&gt;fd, buf-&gt;array, buf-&gt;len, 0, remote_addr, remote_addr_len);
925      if (s == -1) {
926          ERROR(&quot;[udp] server_recv_sendto&quot;);
927      }
928  #else
929      int cache_hit  = 0;
930      int need_query = 0;
931      if (buf-&gt;len - addr_header_len &gt; packet_size) {
932          LOGE(&quot;[udp] server_recv_sendto fragmentation&quot;);
933          goto CLEAN_UP;
934      }
935      if (remote_ctx != NULL) {
936          cache_hit = 1;
937          if (remote_ctx-&gt;addr_header_len != addr_header_len
938              || memcmp(addr_header, remote_ctx-&gt;addr_header, addr_header_len) != 0) {
939              if (dst_addr.ss_family != AF_INET &amp;&amp; dst_addr.ss_family != AF_INET6) {
940                  need_query = 1;
941              }
942          } else {
943              memcpy(&amp;dst_addr, &amp;remote_ctx-&gt;dst_addr, sizeof(struct sockaddr_storage));
944          }
945      } else {
946          if (dst_addr.ss_family == AF_INET || dst_addr.ss_family == AF_INET6) {
947              int remotefd = create_remote_socket(dst_addr.ss_family == AF_INET6);
948              if (remotefd != -1) {
949                  setnonblocking(remotefd);
950  #ifdef SO_BROADCAST
951                  set_broadcast(remotefd);
952  #endif
953  #ifdef SO_NOSIGPIPE
954                  set_nosigpipe(remotefd);
955  #endif
956  #ifdef IP_TOS
957                  int tos = 46;
958                  setsockopt(remotefd, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));
959  #endif
960  #ifdef SET_INTERFACE
961                  if (server_ctx-&gt;iface) {
962                      if (setinterface(remotefd, server_ctx-&gt;iface) == -1)
963                          ERROR(&quot;setinterface&quot;);
964                  }
965  #endif
966                  remote_ctx                  = new_remote(remotefd, server_ctx);
967                  remote_ctx-&gt;src_addr        = src_addr;
968                  remote_ctx-&gt;server_ctx      = server_ctx;
969                  remote_ctx-&gt;addr_header_len = addr_header_len;
970                  memcpy(remote_ctx-&gt;addr_header, addr_header, addr_header_len);
971                  memcpy(&amp;remote_ctx-&gt;dst_addr, &amp;dst_addr, sizeof(struct sockaddr_storage));
972              } else {
973                  ERROR(&quot;[udp] bind() error&quot;);
974                  goto CLEAN_UP;
975              }
976          }
977      }
978      if (remote_ctx != NULL &amp;&amp; !need_query) {
979          size_t addr_len = get_sockaddr_len((struct sockaddr *)&amp;dst_addr);
980          int s           = sendto(remote_ctx-&gt;fd, buf-&gt;array + addr_header_len,
981                                   buf-&gt;len - addr_header_len, 0,
982                                   (struct sockaddr *)&amp;dst_addr, addr_len);
983          if (s == -1) {
984              ERROR(&quot;[udp] sendto_remote&quot;);
985              if (!cache_hit) {
986                  close_and_free_remote(EV_A_ remote_ctx);
987              }
988          } else {
989              if (!cache_hit) {
990                  remote_ctx-&gt;af = dst_addr.ss_family;
991                  char *key = hash_key(remote_ctx-&gt;af, &amp;remote_ctx-&gt;src_addr);
992                  cache_insert(server_ctx-&gt;conn_cache, key, HASH_KEY_LEN, (void *)remote_ctx);
993                  ev_io_start(EV_A_ &amp; remote_ctx-&gt;io);
994                  ev_timer_start(EV_A_ &amp; remote_ctx-&gt;watcher);
995              }
996          }
997      } else {
998          struct addrinfo hints;
999          memset(&amp;hints, 0, sizeof(struct addrinfo));
1000          hints.ai_family   = AF_UNSPEC;
1001          hints.ai_socktype = SOCK_DGRAM;
1002          hints.ai_protocol = IPPROTO_UDP;
1003          struct query_ctx *query_ctx = new_query_ctx(buf-&gt;array + addr_header_len,
1004                                                      buf-&gt;len - addr_header_len);
1005          query_ctx-&gt;server_ctx      = server_ctx;
1006          query_ctx-&gt;addr_header_len = addr_header_len;
1007          query_ctx-&gt;src_addr        = src_addr;
1008          memcpy(query_ctx-&gt;addr_header, addr_header, addr_header_len);
1009          if (need_query) {
1010              query_ctx-&gt;remote_ctx = remote_ctx;
1011          }
1012          struct ResolvQuery *query = resolv_query(host, query_resolve_cb,
1013                                                   NULL, query_ctx, htons(atoi(port)));
1014          if (query == NULL) {
1015              ERROR(&quot;[udp] unable to create DNS query&quot;);
1016              close_and_free_query(EV_A_ query_ctx);
1017              goto CLEAN_UP;
1018          }
1019          query_ctx-&gt;query = query;
1020      }
1021  #endif
1022  CLEAN_UP:
1023      bfree(buf);
1024      ss_free(buf);
1025  }
1026  void
1027  free_cb(void *key, void *element)
1028  {
1029      remote_ctx_t *remote_ctx = (remote_ctx_t *)element;
1030      if (verbose) {
1031          LOGI(&quot;[udp] one connection freed&quot;);
1032      }
1033      close_and_free_remote(EV_DEFAULT, remote_ctx);
1034  }
1035  int
1036  init_udprelay(const char *server_host, const char *server_port,
1037  #ifdef MODULE_LOCAL
1038                const struct sockaddr *remote_addr, const int remote_addr_len,
1039  #ifdef MODULE_TUNNEL
1040                const ss_addr_t tunnel_addr,
1041  #endif
1042  #endif
1043                int mtu, int method, int auth, int timeout, const char *iface, const char *protocol, const char *protocol_param)
1044  {
1045      struct ev_loop *loop = EV_DEFAULT;
1046      if (mtu &gt; 0) {
1047          packet_size = mtu - 1 - 28 - 2 - 64;
1048          buf_size    = packet_size * 2;
1049      }
1050      struct cache *conn_cache;
1051      cache_create(&amp;conn_cache, MAX_UDP_CONN_NUM, free_cb);
1052      int serverfd = create_server_socket(server_host, server_port);
1053      if (serverfd &lt; 0) {
1054          FATAL(&quot;[udp] bind() error&quot;);
1055      }
1056      setnonblocking(serverfd);
1057      if (protocol != NULL &amp;&amp; strcmp(protocol, &quot;verify_sha1&quot;) == 0) {
1058          auth = 1;
1059          protocol = NULL;
1060      }
1061      server_ctx_t *server_ctx = new_server_ctx(serverfd);
1062  #ifdef MODULE_REMOTE
1063      server_ctx-&gt;loop = loop;
1064  #endif
1065      server_ctx-&gt;auth       = auth;
1066      server_ctx-&gt;timeout    = max(timeout, MIN_UDP_TIMEOUT);
1067      server_ctx-&gt;method     = method;
1068      server_ctx-&gt;iface      = iface;
1069      server_ctx-&gt;conn_cache = conn_cache;
1070  #ifdef MODULE_LOCAL
1071      server_ctx-&gt;remote_addr     = remote_addr;
1072      server_ctx-&gt;remote_addr_len = remote_addr_len;
1073      server_ctx-&gt;protocol_plugin = new_obfs_class((char *)protocol);
1074      if (server_ctx-&gt;protocol_plugin) {
1075          server_ctx-&gt;protocol = server_ctx-&gt;protocol_plugin-&gt;new_obfs();
1076          server_ctx-&gt;protocol_global = server_ctx-&gt;protocol_plugin-&gt;init_data();
1077      }
1078      server_info _server_info;
1079      memset(&amp;_server_info, 0, sizeof(server_info));
1080      strcpy(_server_info.host, inet_ntoa(((struct sockaddr_in*)remote_addr)-&gt;sin_addr));
1081      _server_info.port = ((struct sockaddr_in*)remote_addr)-&gt;sin_port;
1082      _server_info.port = _server_info.port &gt;&gt; 8 | _server_info.port &lt;&lt; 8;
1083      _server_info.g_data = server_ctx-&gt;protocol_global;
1084      _server_info.param = (char *)protocol_param;
1085      _server_info.key = enc_get_key();
1086      _server_info.key_len = enc_get_key_len();
1087      if (server_ctx-&gt;protocol_plugin)
1088          server_ctx-&gt;protocol_plugin-&gt;set_server_info(server_ctx-&gt;protocol, &amp;_server_info);
1089  #ifdef MODULE_TUNNEL
1090      server_ctx-&gt;tunnel_addr = tunnel_addr;
1091  #endif
1092  #endif
1093      ev_io_start(loop, &amp;server_ctx-&gt;io);
1094      server_ctx_list[server_num++] = server_ctx;
1095      return 0;
1096  }
1097  void
1098  free_udprelay()
1099  {
1100      struct ev_loop *loop = EV_DEFAULT;
1101      while (server_num-- &gt; 0) {
1102          server_ctx_t *server_ctx = server_ctx_list[server_num];
1103  #ifdef MODULE_LOCAL
1104          if (server_ctx-&gt;protocol_plugin) {
1105              server_ctx-&gt;protocol_plugin-&gt;dispose(server_ctx-&gt;protocol);
1106              server_ctx-&gt;protocol = NULL;
1107              free_obfs_class(server_ctx-&gt;protocol_plugin);
1108              server_ctx-&gt;protocol_plugin = NULL;
1109          }
1110  #endif
1111          ev_io_stop(loop, &amp;server_ctx-&gt;io);
1112          close(server_ctx-&gt;fd);
1113          cache_delete(server_ctx-&gt;conn_cache, 0);
1114          ss_free(server_ctx);
1115          server_ctx_list[server_num] = NULL;
1116      }
1117  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-threads.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-udprelay.c</div>
                </div>
                <div class="column column_space"><pre><code>307                 enqueue(w-&gt;q);
308            }
309            STACK_FREE(r);
310       }
311  }
312  void X(threads_cleanup)(void)
</pre></code></div>
                <div class="column column_space"><pre><code>421              ss_free(ctx-&gt;buf);
422          }
423          ss_free(ctx);
424      }
425  }
426  #endif
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    