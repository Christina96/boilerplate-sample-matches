<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for global_balance.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for global_balance.c &amp; dzsave.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>global_balance.c (2.5389025%)<th>dzsave.c (2.3610053%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1896-1916)<td><a href="#" name="0">(2635-2655)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(497-512)<td><a href="#" name="1">(1357-1377)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>global_balance.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;math.h&gt;
9 #include &lt;vips/vips.h&gt;
10 #include &lt;vips/transform.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include "pmosaicing.h"
13 #include "global_balance.h"
14 #define MAX_ITEMS (50)
15 #define TRIVIAL (20 * 20)
16 static int
17 break_items( char *line, char **out )
18 {
19 	int i;
20 	char *p;
21 	for( i = 0; i &lt; MAX_ITEMS; i++ ) {
22 		if( !(p = strchr( line, '&lt;' )) )
23 			break;
24 		out[i] = line = p + 1;
25 		if( !(p = strchr( line, '&gt;' )) ) {
26 			vips_error( "break_files", "%s", _( "no matching '&gt;'" ) );
27 			return( -1 );
28 		}
29 		*p = '\0';
30 		line = p + 1;
31 	}
32 	if( i == MAX_ITEMS ) {
33 		vips_error( "break_files", "%s", _( "too many items" ) );
34 		return( -1 );
35 	}
36 	return( i );
37 }
38 VipsImage *
39 vips__global_open_image( SymbolTable *st, char *name )
40 {
41 	char *basename;
42 	VipsImage *image;
43 	if( !(image = vips_image_new_from_file( name, NULL ))) {
44 		basename = g_path_get_basename( name );
45 		if( !(image = vips_image_new_from_file( basename, NULL ))) {
46 			g_free( basename );
47 			return( NULL );
48 		}
49 		g_free( basename );
50 	}
51 	vips_object_local( st-&gt;im, image );
52 	return( image );
53 }
54 static void
55 junk_node( VipsImage *image, JoinNode *node )
56 {
57 	VIPS_FREEF( g_slist_free, node-&gt;overlaps );
58 }
59 static int
60 hash( char *n )
61 {
62 	int i;
63 	int r = 0;
64 	int l = strlen( n );
65 	for( i = 0; i &lt; l; i++ )
66 		r = ((r + n[i]) * 43) &amp; 0xffffff;
67 	return( r % SYM_TAB_SIZE );
68 }
69 static JoinNode *
70 build_node( SymbolTable *st, char *name )
71 {
72 	JoinNode *node = VIPS_NEW( st-&gt;im, JoinNode );
73 	int n = hash( name );
74 	if( !node || !(node-&gt;name = 
75 		vips_strdup( VIPS_OBJECT( st-&gt;im ), name )) )
76 		return( NULL );
77 	node-&gt;type = JOIN_LEAF;
78 	node-&gt;dirty = 0;
79 	node-&gt;mwidth = -2;
80 	node-&gt;st = st;
81 	vips__transform_init( &amp;node-&gt;cumtrn );
82 	node-&gt;trnim = NULL;
83 	node-&gt;arg1 = NULL;
84 	node-&gt;arg2 = NULL;
85 	node-&gt;overlaps = NULL;
86 	node-&gt;im = NULL;
87 	node-&gt;index = 0;
88 	g_signal_connect( st-&gt;im, "close",
89 		G_CALLBACK( junk_node ), node );
90 	if( (node-&gt;im = vips__global_open_image( st, name )) ) {
91 		node-&gt;cumtrn.oarea.width = node-&gt;im-&gt;Xsize;
92 		node-&gt;cumtrn.oarea.height = node-&gt;im-&gt;Ysize;
93 	}
94 	else {
95 		vips_error_clear();
96 	}
97 	st-&gt;table[n] = g_slist_prepend( st-&gt;table[n], node );
98 	return( node );
99 }
100 static OverlapInfo *
101 build_overlap( JoinNode *node, JoinNode *other, VipsRect *overlap )
102 {
103 	OverlapInfo *lap = VIPS_NEW( node-&gt;st-&gt;im, OverlapInfo );
104 	if( !lap )
105 		return( NULL );
106 	lap-&gt;node = node;
107 	lap-&gt;other = other;
108 	lap-&gt;overlap = *overlap;
109 	lap-&gt;nstats = NULL;
110 	lap-&gt;ostats = NULL;
111 	node-&gt;overlaps = g_slist_prepend( node-&gt;overlaps, lap );
112 	node-&gt;st-&gt;novl++;
113 	return( lap );
114 }
115 static void
116 overlap_destroy( OverlapInfo *lap )
117 {
118 	JoinNode *node = lap-&gt;node;
119 	node-&gt;overlaps = g_slist_remove( node-&gt;overlaps, lap );
120 	g_assert( node-&gt;st-&gt;novl &gt; 0 );
121 	node-&gt;st-&gt;novl--;
122 }
123 static void
124 junk_table( VipsImage *image, SymbolTable *st ) {
125 	int i;
126 	for( i = 0; i &lt; st-&gt;sz; i++ )
127 		VIPS_FREEF( g_slist_free, st-&gt;table[i] );
128 }
129 SymbolTable *
130 vips__build_symtab( VipsImage *out, int sz )
131 {
132 	SymbolTable *st = VIPS_NEW( out, SymbolTable );
133 	int i;
134 	if( !st ||
135 		!(st-&gt;table = VIPS_ARRAY( out, sz, GSList * )) )
136 		return( NULL );
137 	st-&gt;sz = sz;
138 	st-&gt;im = out;
139 	st-&gt;novl = 0;
140 	st-&gt;nim = 0;
141 	st-&gt;njoin = 0;
142 	st-&gt;root = NULL;
143 	st-&gt;leaf = NULL;
144 	st-&gt;fac = NULL;
145 	g_signal_connect( out, "close", 
146 		G_CALLBACK( junk_table ), st );
147 	for( i = 0; i &lt; sz; i++ )
148 		st-&gt;table[i] = NULL;
149 	return( st );
150 }
151 static JoinNode *
152 test_name( JoinNode *node, char *name, void *b )
153 {
154 	if( strcmp( node-&gt;name, name ) == 0 )
155 		return( node );
156 	else
157 		return( NULL );
158 }
159 static JoinNode *
160 find_node( SymbolTable *st, char *name ) 
161 {
162 	return( vips_slist_map2( st-&gt;table[hash( name )],
163 		(VipsSListMap2Fn) test_name, name, NULL ) );
164 }
165 static JoinNode *
166 add_node( SymbolTable *st, char *name )
167 {
168 	JoinNode *node;
169 	if( !(node = find_node( st, name )) &amp;&amp; 
170 		!(node = build_node( st, name )) )
171 		return( NULL );
172 	return( node );
173 }
174 void *
175 vips__map_table( SymbolTable *st, VipsSListMap2Fn fn, void *a, void *b )
176 {
177 	int i;
178 	void *r;
179 	for( i = 0; i &lt; st-&gt;sz; i++ )
180 		if( (r = vips_slist_map2( st-&gt;table[i], fn, a, b )) )
181 			return( r );
182 	return( NULL );
183 }
184 static void *
185 set_dirty( JoinNode *node, int state, void *b )
186 {	
187 	node-&gt;dirty = state;
188 	return( NULL );
189 }
190 static void
191 clean_table( SymbolTable *st )
192 {
193 	(void) vips__map_table( st, 
194 		(VipsSListMap2Fn) set_dirty, (void *) 0, NULL );
195 }
196 static void
197 calc_geometry( JoinNode *node )
198 {
199 	VipsRect um;
200 	switch( node-&gt;type ) {
201 	case JOIN_LR:
202 	case JOIN_TB:
203 	case JOIN_LRROTSCALE:
204 	case JOIN_TBROTSCALE:
205 		vips_rect_unionrect( &amp;node-&gt;arg1-&gt;cumtrn.oarea,
206 			&amp;node-&gt;arg2-&gt;cumtrn.oarea, &amp;um );
207 		node-&gt;cumtrn.iarea.left = 0;
208 		node-&gt;cumtrn.iarea.top = 0;
209 		node-&gt;cumtrn.iarea.width = um.width;
210 		node-&gt;cumtrn.iarea.height = um.height;
211 		vips__transform_set_area( &amp;node-&gt;cumtrn );
212 		break;
213 	case JOIN_CP:
214 		node-&gt;cumtrn = node-&gt;arg1-&gt;cumtrn;
215 		break;
216 	case JOIN_LEAF:
217 		if( node-&gt;im ) {
218 			node-&gt;cumtrn.iarea.left = 0;
219 			node-&gt;cumtrn.iarea.top = 0;
220 			node-&gt;cumtrn.iarea.width = node-&gt;im-&gt;Xsize;
221 			node-&gt;cumtrn.iarea.height = node-&gt;im-&gt;Ysize;
222 			vips__transform_set_area( &amp;node-&gt;cumtrn );
223 		}
224 		break;
225 	default:
226 		vips_error_exit( "internal error #98356" );
227 	}
228 }
229 static int
230 propagate_transform( JoinNode *node, VipsTransformation *trn )
231 {
232 	if( !node )
233 		return( 0 );
234 	if( node-&gt;dirty &amp;&amp; node-&gt;arg1 &amp;&amp; node-&gt;arg2 ) {
235 		vips_error( "vips_global_balance", 
236 			"%s", _( "circularity detected" ) );
237 		return( -1 );
238 	}
239 	node-&gt;dirty = 1;
240 	if( propagate_transform( node-&gt;arg1, trn ) ||
241 		propagate_transform( node-&gt;arg2, trn ) )
242 		return( -1 );
243 	vips__transform_add( &amp;node-&gt;cumtrn, trn, &amp;node-&gt;cumtrn );
244 	calc_geometry( node );
245 	return( 0 );
246 }
247 static int
248 make_join( SymbolTable *st, JoinType type, 
249 	JoinNode *arg1, JoinNode *arg2, JoinNode *out, 
250 	double a, double b, double dx, double dy, int mwidth )
251 {
252 	VipsTransformation trn;
253 <a name="1"></a>	if( out-&gt;type != JOIN_LEAF ) {
254 		vips_error( "vips_global_balance", 
255 			_( "image \"%s\" used twice as output" ), out-&gt;name );
256 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
257 	}
258 	out-&gt;type = type;
259 	out-&gt;mwidth = mwidth;
260 	out-&gt;a = a;
261 	out-&gt;b = b;
262 	out-&gt;dx = dx;
263 	out-&gt;dy = dy;
264 	out-&gt;arg1 = arg1;
265 	out-&gt;arg2 = arg2;
266 	out-&gt;thistrn.a = a;
267 	out-&gt;thistrn.b = -b;
268 	out-&gt;thistrn.c = b;</b></font>
269 	out-&gt;thistrn.d = a;
270 	out-&gt;thistrn.idx = 0;
271 	out-&gt;thistrn.idy = 0;
272 	out-&gt;thistrn.odx = dx;
273 	out-&gt;thistrn.ody = dy;
274 	clean_table( st );
275 	if( propagate_transform( arg2, &amp;out-&gt;thistrn ) )
276 		return( -1 );
277 	calc_geometry( out );
278 	trn.a = 1.0;
279 	trn.b = 0.0;
280 	trn.c = 0.0;
281 	trn.d = 1.0;
282 	trn.idx = 0;
283 	trn.idy = 0;
284 	trn.odx = -out-&gt;cumtrn.oarea.left;
285 	trn.ody = -out-&gt;cumtrn.oarea.top;
286 	clean_table( st );
287 	if( propagate_transform( out, &amp;trn ) )
288 		return( -1 );
289 	return( 0 );
290 }
291 static int
292 make_copy( SymbolTable *st, JoinNode *before, JoinNode *after )
293 {
294 	if( after-&gt;type != JOIN_LEAF ) {
295 		vips_error( "vips_global_balance", 
296 			_( "image \"%s\" used twice as output" ), after-&gt;name );
297 		return( -1 );
298 	}
299 	after-&gt;type = JOIN_CP;
300 	after-&gt;arg1 = before;
301 	after-&gt;arg2 = NULL;
302 	calc_geometry( after ); 
303 	return( 0 );
304 }
305 static int
306 process_line( SymbolTable *st, const char *text )
307 {
308 	char line[1024];
309 #ifdef DEBUG
310 	printf( "read: %s\n", text );
311 	vips_strncpy( line, text, 1024 );
312 	if( vips_isprefix( "#LRJOIN ", line ) ||
313 		vips_isprefix( "#TBJOIN ", line ) ) {
314 		char *item[MAX_ITEMS];
315 		int nitems;
316 		JoinType type;
317 		JoinNode *arg1, *arg2, *join;
318 		int dx, dy, mwidth;
319 		if( (nitems = break_items( line, item )) &lt; 0 )
320 			return( -1 );
321 		if( nitems != 5 &amp;&amp; nitems != 6 ) {
322 			vips_error( "global_balance", 
323 				"%s", _( "bad number of args in join line" ) );
324 			return( -1 );
325 		}
326 		if( !(arg1 = add_node( st, item[0] )) ||
327 			!(arg2 = add_node( st, item[1] )) ||
328 			!(join = add_node( st, item[2] )) )
329 			return( -1 );
330 		dx = atoi( item[3] );
331 		dy = atoi( item[4] );
332 		if( nitems == 6 ) 
333 			mwidth = atoi( item[5] );
334 		else
335 			mwidth = -1;
336 		if( vips_isprefix( "#LRJOIN ", line ) )
337 			type = JOIN_LR;
338 		else
339 			type = JOIN_TB;
340 		if( make_join( st, type, arg1, arg2, 
341 			join, 1.0, 0.0, dx, dy, mwidth ) )
342 			return( -1 );
343 	}
344 	else if( vips_isprefix( "#LRROTSCALE ", line ) ||
345 		vips_isprefix( "#TBROTSCALE ", line ) ) {
346 		char *item[MAX_ITEMS];
347 		int nitems;
348 		JoinType type;
349 		JoinNode *arg1, *arg2, *join;
350 		double a, b, dx, dy;
351 		int mwidth;
352 		if( (nitems = break_items( line, item )) &lt; 0 )
353 			return( -1 );
354 		if( nitems != 7 &amp;&amp; nitems != 8 ) {
355 			vips_error( "global_balance", 
356 				"%s", _( "bad number of args in join1 line" ) );
357 			return( -1 );
358 		}
359 		if( !(arg1 = add_node( st, item[0] )) ||
360 			!(arg2 = add_node( st, item[1] )) ||
361 			!(join = add_node( st, item[2] )) )
362 			return( -1 );
363 		a = g_ascii_strtod( item[3], NULL );
364 		b = g_ascii_strtod( item[4], NULL );
365 		dx = g_ascii_strtod( item[5], NULL );
366 		dy = g_ascii_strtod( item[6], NULL );
367 		if( nitems == 8 )
368 			mwidth = atoi( item[7] );
369 		else
370 			mwidth = -1;
371 		if( vips_isprefix( "#LRROTSCALE ", line ) )
372 			type = JOIN_LRROTSCALE;
373 		else
374 			type = JOIN_TBROTSCALE;
375 		if( make_join( st, type, arg1, arg2, 
376 			join, a, b, dx, dy, mwidth ) )
377 			return( -1 );
378 	}
379 	else if( vips_isprefix( "copy ", line ) ) {
380 		char *item[MAX_ITEMS];
381 		int nitems;
382 		JoinNode *before, *after;
383 		if( (nitems = break_items( line, item )) &lt; 0 )
384 			return( -1 );
385 		if( nitems != 2 ) {
386 			vips_error( "global_balance", 
387 				"%s", _( "bad number of args in copy line" ) );
388 			return( -1 );
389 		}
390 		if( !(before = add_node( st, item[0] )) ||
391 			!(after = add_node( st, item[1] )) ||
392 			make_copy( st, before, after ) )
393 			return( -1 );
394 	}
395 	return( 0 );
396 }
397 static void *
398 set_referenced( JoinNode *node, void *a, void *b )
399 {
400 	if( node-&gt;arg1 )
401 		node-&gt;arg1-&gt;dirty = 1;
402 	if( node-&gt;arg2 )
403 		node-&gt;arg2-&gt;dirty = 1;
404 	return( NULL );
405 }
406 static void *
407 is_root( JoinNode *node, void *a, void *b )
408 {
409 	if( !node-&gt;dirty )
410 		return( (void *) node );
411 	else
412 		return( NULL );
413 }
414 static JoinNode *
415 find_root( SymbolTable *st )
416 {
417 	JoinNode *root;
418 	clean_table( st );
419 	vips__map_table( st, (VipsSListMap2Fn) set_referenced, NULL, NULL );
420 	root = (JoinNode *) vips__map_table( st, 
421 		(VipsSListMap2Fn) is_root, NULL, NULL );
422 	if( !root ) {
423 		vips_error( "vips_global_balance", 
424 			"%s", _( "mosaic root not found in desc file\n"
425 			"is this really a mosaiced image?" ) );
426 		return( NULL );
427 	}
428 	root-&gt;dirty = 1;
429 	if( vips__map_table( st, (VipsSListMap2Fn) is_root, NULL, NULL ) ) {
430 		vips_error( "vips_global_balance", 
431 			"%s", _( "more than one root" ) );
432 		return( NULL );
433 	}
434 	return( root );
435 }
436 int
437 vips__parse_desc( SymbolTable *st, VipsImage *in )
438 {
439 	GSList *p;
440 	for( p = in-&gt;history_list; p; p = p-&gt;next ) {
441 		GValue *value = (GValue *) p-&gt;data;
442 		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
443 		if( process_line( st, vips_value_get_ref_string( value, NULL ) ) )
444 			return( -1 );
445 	}
446 	if( !(st-&gt;root = find_root( st )) )
447 		return( -1 );
448 	return( 0 );
449 }
450 static void *
451 count_leaves( JoinNode *node, void *a, void *b )
452 {
453 	if( node-&gt;type == JOIN_LEAF ) {
454 		node-&gt;index = node-&gt;st-&gt;nim;
455 		node-&gt;st-&gt;nim++;
456 	}
457 	return( NULL );
458 }
459 #ifdef DEBUG
460 static void
461 print_node( JoinNode *node )
462 {
463 	char *basename = g_path_get_basename( node-&gt;name );
464 	printf( "%s, position %dx%d, size %dx%d, index %d\n",
465 		basename,
466 		node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top,
467 		node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
468 		node-&gt;index );
469 	g_free( basename );
470 }
471 #ifdef DEBUG
472 static void *
473 print_leaf( JoinNode *node, void *a, void *b )
474 {
475 	if( node-&gt;type == JOIN_LEAF ) 
476 		print_node( node );
477 	return( NULL );
478 }
479 static void *
480 count_joins( JoinNode *node, void *a, void *b )
481 {
482 	if( node-&gt;type == JOIN_TB ||
483 		node-&gt;type == JOIN_LR ||
484 		node-&gt;type == JOIN_LRROTSCALE ||
485 		node-&gt;type == JOIN_TBROTSCALE )
486 		node-&gt;st-&gt;njoin++;
487 	return( NULL );
488 }
489 #ifdef DEBUG
490 static void
491 spc( int n )
492 {
493 	int i;
494 	for( i = 0; i &lt; n; i++ )
495 		printf( " " );
496 }
497 #ifdef DEBUG
498 static char *
499 JoinType2char( JoinType type )
500 {
501 	switch( type ) {
502 	case JOIN_LR: 		return( "JOIN_LR" );
503 	case JOIN_TB: 		return( "JOIN_TB" );
504 	case JOIN_LRROTSCALE: 	return( "JOIN_LRROTSCALE" );
505 	case JOIN_TBROTSCALE: 	return( "JOIN_TBROTSCALE" );
506 	case JOIN_CP: 		return( "JOIN_CP" );
507 	case JOIN_LEAF: 	return( "JOIN_LEAF" );
508 	default:
509 		vips_error_exit( "internal error #9275" );
510 		return( NULL );
511 	}
512 }
513 #ifdef DEBUG
514 static void *
515 print_joins( JoinNode *node, int indent )
516 {
517 	char *basename = g_path_get_basename( node-&gt;name );
518 	switch( node-&gt;type ) {
519 	case JOIN_TB:
520 	case JOIN_LR:
521 	case JOIN_TBROTSCALE:
522 	case JOIN_LRROTSCALE:
523 		spc( indent );
524 		printf( "%s to make %s, size %dx%d, pos. %dx%d, of:\n", 
525 			JoinType2char( node-&gt;type ), 
526 			basename,
527 			node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
528 			node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top );
529 		spc( indent );
530 		printf( "reference:\n" );
531 		print_joins( node-&gt;arg1, indent + 2 );
532 		spc( indent );
533 		printf( "secondary:\n" );
534 		print_joins( node-&gt;arg2, indent + 2 );
535 		break;
536 	case JOIN_CP:
537 		spc( indent );
538 		printf( "copy to make %s of:\n", basename );
539 		print_joins( node-&gt;arg1, indent + 2 );
540 		break;
541 	case JOIN_LEAF:
542 		spc( indent );
543 		printf( "input image %s\n", basename );
544 		break;
545 	}
546 	g_free( basename );
547 	return( NULL );
548 }
549 #ifdef DEBUG
550 static void *
551 print_overlap( OverlapInfo *lap, void *a, void *b )
552 {
553 	char *basename_node = g_path_get_basename( lap-&gt;node-&gt;name );
554 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
555 	printf( "-&gt; %s overlaps with %s; (this, other) = (%.4G, %.4G)\n",
556 		basename_node,
557 		basename_other,
558 		*VIPS_MATRIX( lap-&gt;nstats, 4, 0 ),
559 		*VIPS_MATRIX( lap-&gt;ostats, 4, 0 ) );
560 	g_free( basename_node );
561 	g_free( basename_other );
562 	return( NULL );
563 }
564 #ifdef DEBUG
565 static void *
566 print_overlaps( JoinNode *node, void *a, void *b )
567 {
568 	char *basename;
569 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
570 		basename = g_path_get_basename( node-&gt;name );
571 		printf( "overlap of %s with:\n", basename );
572 		g_free( basename );
573 		vips_slist_map2( node-&gt;overlaps, 
574 			(VipsSListMap2Fn) print_overlap, NULL, NULL );
575 	}
576 	return( NULL );
577 }
578 #ifdef DEBUG
579 static void *
580 print_overlap_error( OverlapInfo *lap, double *fac, double *total )
581 {
582 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
583 	double na = *VIPS_MATRIX( lap-&gt;nstats, 4, 0 );
584 	double oa = *VIPS_MATRIX( lap-&gt;ostats, 4, 0 );
585 	double err;
586 	if( fac ) {
587 		na *= fac[lap-&gt;node-&gt;index];
588 		oa *= fac[lap-&gt;other-&gt;index];
589 	}
590 	err = na - oa;
591 	printf( "-&gt; file %s, error = %g\n",
592 		basename_other, err );
593 	*total += err * err;
594 	g_free( basename_other );
595 	return( NULL );
596 }
597 #ifdef DEBUG
598 static void *
599 print_overlap_errors( JoinNode *node, double *fac, double *total )
600 {
601 	char *basename;
602 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
603 		basename = g_path_get_basename( node-&gt;name );
604 		printf( "overlap of %s (index %d) with:\n", basename, 
605 			node-&gt;index );
606 		g_free( basename );
607 		vips_slist_map2( node-&gt;overlaps, 
608 			(VipsSListMap2Fn) print_overlap_error, fac, total );
609 	}
610 	return( NULL );
611 }
612 static int
613 extract_rect( VipsImage *in, VipsImage **out, VipsRect *r )
614 {
615 	return( vips_extract_area( in, out, 
616 		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height, NULL ) );
617 }
618 static int
619 make_overlap_mask( VipsImage *mem, 
620 	VipsImage *ref, VipsImage *sec, VipsImage **mask, 
621 	VipsRect *rarea, VipsRect *sarea )
622 {
623 	VipsImage **t = (VipsImage **) 
624 		vips_object_local_array( VIPS_OBJECT( mem ), 6 );
625 	if( extract_rect( ref, &amp;t[0], rarea ) ||
626 		extract_rect( sec, &amp;t[1], sarea ) ||
627 		vips_extract_band( t[0], &amp;t[2], 0, NULL ) ||
628 		vips_extract_band( t[1], &amp;t[3], 0, NULL ) ||
629 		vips_notequal_const1( t[2], &amp;t[4], 0.0, NULL ) ||
630 		vips_notequal_const1( t[3], &amp;t[5], 0.0, NULL ) ||
631 		vips_andimage( t[4], t[5], mask, NULL ) ) 
632 		return( -1 );
633 	return( 0 );
634 }
635 static int
636 count_nonzero( VipsImage *in, gint64 *count )
637 {
638 	double avg;
639 	if( vips_avg( in, &amp;avg, NULL ) )
640 		return( -1 );
641 	*count = (avg * VIPS_IMAGE_N_PELS( in )) / 255.0;
642 	return( 0 );
643 }
644 static VipsImage *
645 find_image_stats( VipsImage *mem, 
646 	VipsImage *in, VipsImage *mask, VipsRect *area )
647 {
648 	VipsImage **t = (VipsImage **) 
649 		vips_object_local_array( VIPS_OBJECT( mem ), 5 );
650 	gint64 count;
651 	if( extract_rect( in, &amp;t[0], area ) ||
652 		vips_black( &amp;t[1], t[0]-&gt;Xsize, t[0]-&gt;Ysize, 
653 			"bands", t[0]-&gt;Bands, 
654 			NULL ) ||
655 		vips_cast( t[1], &amp;t[2], t[0]-&gt;BandFmt, NULL ) ||
656 		vips_ifthenelse( mask, t[0], t[2], &amp;t[3], NULL ) )
657 		return( NULL );
658 	if( vips_stats( t[3], &amp;t[4], NULL ) )
659 		return( NULL );
660 	if( count_nonzero( mask, &amp;count ) )
661 		return( NULL );
662 	*VIPS_MATRIX( t[4], 4, 0 ) *= 
663 		(double) count / VIPS_IMAGE_N_PELS( mask );
664 	*VIPS_MATRIX( t[4], 5, 0 )  = count;
665 #ifdef DEBUG
666 	if( count == 0 )
667 		g_warning( "global_balance %s", _( "empty overlap!" ) );
668 	return( t[4] );
669 }
670 static int
671 find_overlap_stats( OverlapInfo *lap )
672 {
673 	VipsImage *mem = lap-&gt;node-&gt;st-&gt;im;
674 	VipsImage **t = (VipsImage **) 
675 		vips_object_local_array( VIPS_OBJECT( mem ), 1 );
676 	VipsRect rarea, sarea;
677 	rarea = lap-&gt;overlap;
678 	rarea.left -= lap-&gt;node-&gt;cumtrn.oarea.left;
679 	rarea.top -= lap-&gt;node-&gt;cumtrn.oarea.top;
680 	sarea = lap-&gt;overlap;
681 	sarea.left -= lap-&gt;other-&gt;cumtrn.oarea.left;
682 	sarea.top -= lap-&gt;other-&gt;cumtrn.oarea.top;
683 	if( make_overlap_mask( mem, 
684 		lap-&gt;node-&gt;trnim, lap-&gt;other-&gt;trnim, &amp;t[0], &amp;rarea, &amp;sarea ) )
685 		return( -1 );
686 	if( !(lap-&gt;nstats = find_image_stats( mem, 
687 		lap-&gt;node-&gt;trnim, t[0], &amp;rarea )) )
688 		return( -1 );
689 	if( !(lap-&gt;ostats = find_image_stats( mem, 
690 		lap-&gt;other-&gt;trnim, t[0], &amp;sarea )) )
691 		return( -1 );
692 	return( 0 );
693 }
694 static void *
695 overlap_eq( OverlapInfo *this, JoinNode *node, void *b )
696 {
697 	if( this-&gt;other == node )
698 		return( this );
699 	else
700 		return( NULL );
701 }
702 static void *
703 test_overlap( JoinNode *other, JoinNode *node, void *b )
704 {
705 	VipsRect overlap;
706 	OverlapInfo *lap;
707 	if( other-&gt;type != JOIN_LEAF || node == other ) 
708 		return( NULL );
709 	vips_rect_intersectrect( &amp;node-&gt;cumtrn.oarea, &amp;other-&gt;cumtrn.oarea, 
710 		&amp;overlap );
711 	if( vips_rect_isempty( &amp;overlap ) ) 
712 		return( NULL );
713 	if( overlap.width * overlap.height &lt; TRIVIAL )
714 		return( NULL );
715 	if( vips_slist_map2( other-&gt;overlaps, 
716 		(VipsSListMap2Fn) overlap_eq, node, NULL ) )
717 		return( NULL );
718 	if( !(lap = build_overlap( node, other, &amp;overlap )) )
719 		return( node );
720 	if( find_overlap_stats( lap ) ) 
721 		return( node );
722 	if( *VIPS_MATRIX( lap-&gt;nstats, 5, 0 ) &lt; TRIVIAL ||
723 		*VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) &lt; TRIVIAL ) {
724 #ifdef DEBUG
725 		printf( "trivial overlap ... junking\n" );
726 		printf( "nstats count = %g, ostats count = %g\n",
727 			*VIPS_MATRIX( lap-&gt;nstats, 5, 0 ), *VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) );
728 		print_overlap( lap, NULL, NULL );
729 		overlap_destroy( lap );
730 	}
731 	return( NULL );
732 }
733 static void *
734 find_overlaps( JoinNode *node, SymbolTable *st, void *b )
735 {
736 	if( node-&gt;type == JOIN_LEAF ) {
737 		if( !node-&gt;im ) {
738 			vips_error( "vips_global_balance", 
739 				_( "unable to open \"%s\"" ), node-&gt;name );
740 			return( node );
741 		}
742 		if( !node-&gt;trnim ) 
743 			vips_error_exit( "global_balance: sanity failure #9834" );
744 		return( vips__map_table( st, 
745 			(VipsSListMap2Fn) test_overlap, node, NULL ) );
746 	}
747 	return( NULL );
748 }
749 typedef struct {
750 	SymbolTable *st;			JoinNode *leaf;				VipsImage *K;				VipsImage *M;				int row;			} MatrixBundle;
751 static void *
752 add_nominated( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
753 {
754 	double ns = pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
755 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
756 	*VIPS_MATRIX( bun-&gt;K, 0, bun-&gt;row ) = ns;
757 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
758 	bun-&gt;row++;
759 	return( NULL );
760 }
761 static void *
762 add_other( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
763 {
764 	double ns = -pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
765 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
766 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;node-&gt;index - 1, bun-&gt;row ) = ns;
767 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
768 	bun-&gt;row++;
769 	return( NULL );
770 }
771 static void *
772 add_row( JoinNode *node, MatrixBundle *bun, double *gamma )
773 {
774 	if( node == bun-&gt;leaf )
775 		vips_slist_map2( node-&gt;overlaps, 
776 			(VipsSListMap2Fn) add_nominated, bun, gamma );
777 	else
778 		vips_slist_map2( node-&gt;overlaps, 
779 			(VipsSListMap2Fn) add_other, bun, gamma );
780 	return( NULL );
781 }
782 static void
783 fill_matrices( SymbolTable *st, double gamma, VipsImage *K, VipsImage *M )
784 {
785 	MatrixBundle bun;
786 	bun.st = st;
787 	bun.leaf = st-&gt;leaf;
788 	bun.K = K;
789 	bun.M = M;
790 	bun.row = 0;
791 	vips__map_table( st, (VipsSListMap2Fn) add_row, &amp;bun, &amp;gamma );
792 }
793 static void *
794 choose_leaf( JoinNode *node, void *a, void *b )
795 {
796 	if( node-&gt;type == JOIN_LEAF )
797 		return( node );
798 	return( NULL );
799 }
800 static VipsImage *
801 make_mos_image( SymbolTable *st, JoinNode *node, transform_fn tfn, void *a )
802 {
803 	VipsImage *im1, *im2, *out;
804 	switch( node-&gt;type ) {
805 	case JOIN_LR:
806 	case JOIN_TB:
807 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
808 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
809 			return( NULL );
810 		if( vips_merge( im1, im2, &amp;out, 
811 			node-&gt;type == JOIN_LR ? 
812 				VIPS_DIRECTION_HORIZONTAL : 
813 				VIPS_DIRECTION_VERTICAL,
814 			-node-&gt;dx, -node-&gt;dy, 
815 			"mblend", node-&gt;mwidth,
816 			NULL ) )
817 			return( NULL );
818 		vips_object_local( st-&gt;im, out );
819 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
820 		break;
821 	case JOIN_LRROTSCALE:
822 	case JOIN_TBROTSCALE:
823 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
824 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
825 			return( NULL );
826 		out = vips_image_new();
827 		vips_object_local( st-&gt;im, out );
828 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
829 		if( node-&gt;type == JOIN_LRROTSCALE ) {
830 			if( vips__lrmerge1( im1, im2, out, 
831 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
832 				node-&gt;mwidth ) )
833 				return( NULL );
834 		}
835 		else {
836 			if( vips__tbmerge1( im1, im2, out, 
837 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
838 				node-&gt;mwidth ) )
839 				return( NULL );
840 		}
841 		break;
842 	case JOIN_LEAF:
843 		if( !(out = tfn( node, a )) )
844 			return( NULL );
845 		break;
846 	case JOIN_CP:
847 		out = make_mos_image( st, node-&gt;arg1, tfn, a );
848 		break;
849 	default:
850 		vips_error_exit( "internal error #982369824375987" );
851 		return( NULL );
852 	}
853 	return( out );
854 }
855 int
856 vips__build_mosaic( SymbolTable *st, VipsImage *out, transform_fn tfn, void *a )
857 {
858 	JoinNode *root = st-&gt;root;
859 	VipsImage *im1, *im2;
860 	VipsImage *x;
861 	switch( root-&gt;type ) {
862 	case JOIN_LR:
863 	case JOIN_TB:
864 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
865 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
866 			return( -1 );
867 		if( vips_merge( im1, im2, &amp;x, 
868 			root-&gt;type == JOIN_LR ? 
869 				VIPS_DIRECTION_HORIZONTAL : 
870 				VIPS_DIRECTION_VERTICAL,
871 			-root-&gt;dx, -root-&gt;dy, 
872 			"mblend", root-&gt;mwidth,
873 			NULL ) )
874 			return( -1 );
875 		if( vips_image_write( x, out ) ) {
876 			g_object_unref( x );
877 			return( -1 );
878 		}
879 		g_object_unref( x );
880 		break;
881 	case JOIN_LRROTSCALE:
882 	case JOIN_TBROTSCALE:
883 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
884 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
885 			return( -1 );
886 		if( root-&gt;type == JOIN_LRROTSCALE ) {
887 			if( vips__lrmerge1( im1, im2, out, 
888 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
889 				root-&gt;mwidth ) )
890 				return( -1 );
891 		}
892 		else {
893 			if( vips__tbmerge1( im1, im2, out, 
894 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
895 				root-&gt;mwidth ) )
896 				return( -1 );
897 		}
898 		break;
899 	case JOIN_LEAF:
900 		if( !(im1 = tfn( root, a )) || 
901 			vips_image_write( im1, out ) )
902 			return( -1 );
903 		break;
904 	case JOIN_CP:
905 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
906 			vips_image_write( im1, out ) )
907 			return( -1 );
908 		break;
909 	default:
910 		vips_error_exit( "internal error #982369824375987" );
911 	}
912 	return( 0 );
913 }
914 static int
915 vips__matrixtranspose( VipsImage *in, VipsImage **out )
916 {
917 	int yc, xc;
918 	if( !(*out = vips_image_new_matrix( in-&gt;Ysize, in-&gt;Xsize )) )
919 		return( -1 );
920 	for( yc = 0; yc &lt; (*out)-&gt;Ysize; ++yc )
921 		for( xc = 0; xc &lt; (*out)-&gt;Xsize; ++xc )
922 			*VIPS_MATRIX( *out, xc, yc ) = *VIPS_MATRIX( in, yc, xc );
923 	return( 0 );
924 }
925 static int
926 vips__matrixmultiply( VipsImage *in1, VipsImage *in2, VipsImage **out )
927 {
928 	int xc, yc, col;
929 	double sum;
930 	double *mat, *a, *b;
931 	double *s1, *s2;
932 	if( in1-&gt;Xsize != in2-&gt;Ysize ) {
933 		vips_error( "vips__matrixmultiply", "%s", _( "bad sizes" ) );
934 		return( -1 );
935 	}
936 	if( !(*out = vips_image_new_matrix( in2-&gt;Xsize, in1-&gt;Ysize  )) )
937 		return( -1 );
938 	mat = VIPS_MATRIX( *out, 0, 0 );
939 	s1 = VIPS_MATRIX( in1, 0, 0 );
940 	for( yc = 0; yc &lt; in1-&gt;Ysize; yc++ ) {
941 		s2 = VIPS_MATRIX( in2, 0, 0 );
942 		for( col = 0; col &lt; in2-&gt;Xsize; col++ ) {
943 			a = s1;
944 			b = s2;
945 			for( sum = 0.0, xc = 0; xc &lt; in1-&gt;Xsize; xc++ ) {
946 				sum += *a++ * *b;
947 				b += in2-&gt;Xsize;
948 			}
949 			*mat++ = sum;
950 			s2++;
951 		}
952 		s1 += in1-&gt;Xsize;
953 	}
954 	return( 0 );
955 }
956 static int
957 find_factors( SymbolTable *st, double gamma )
958 {
959 	VipsImage **t = (VipsImage **) 
960 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 7 );
961 	double total;
962 	double avg;
963 	int i;
964 	if( !(t[0] = vips_image_new_matrix( 1, st-&gt;novl )) ||
965 		!(t[1] = vips_image_new_matrix( st-&gt;nim - 1, st-&gt;novl )) )
966 		return( -1 );
967 	fill_matrices( st, gamma, t[0], t[1] );
968 #ifdef DEBUG
969 	vips_image_write_to_file( t[0], "K.mat", NULL ); 
970 	vips_image_write_to_file( t[1], "M.mat", NULL );
971 	if( vips__matrixtranspose( t[1], &amp;t[2] ) ||
972 		vips__matrixmultiply( t[2], t[1], &amp;t[3] ) ||
973 		vips_matrixinvert( t[3], &amp;t[4], NULL ) ||
974 		vips__matrixmultiply( t[4], t[2], &amp;t[5] ) ||
975 		vips__matrixmultiply( t[5], t[0], &amp;t[6] ) )
976 		return( -1 );
977 	if( !(st-&gt;fac = VIPS_ARRAY( st-&gt;im, st-&gt;nim, double )) )
978 		return( -1 );
979 	for( i = 0; i &lt; t[6]-&gt;Ysize; i++ )
980 		st-&gt;fac[i + 1] = *VIPS_MATRIX( t[6], 0, i );
981 	st-&gt;fac[0] = 1.0;
982 	total = 0.0;
983 	for( i = 0; i &lt; st-&gt;nim; i++ )
984 		total += st-&gt;fac[i];
985 	avg = total / st-&gt;nim;
986 	for( i = 0; i &lt; st-&gt;nim; i++ )
987 		st-&gt;fac[i] /= avg;
988 #ifdef DEBUG
989 	printf( "debugging output for vips_global_balance():\n" );
990 	for( i = 0; i &lt; st-&gt;nim; i++ )
991 		printf( "balance factor %d = %g\n", i, st-&gt;fac[i] );
992 	total = 0.0;
993 	printf( "Overlap errors:\n" );
994 	vips__map_table( st, 
995 		(VipsSListMap2Fn) print_overlap_errors, NULL, &amp;total );
996 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
997 	total = 0.0;
998 	printf( "Overlap errors after adjustment:\n" );
999 	vips__map_table( st, 
1000 		(VipsSListMap2Fn) print_overlap_errors, st-&gt;fac, &amp;total );
1001 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
1002 	return( 0 );
1003 }
1004 int
1005 vips__affinei( VipsImage *in, VipsImage *out, VipsTransformation *trn )
1006 {
1007 	VipsImage **t = (VipsImage **)
1008 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
1009 	VipsArea *oarea;
1010 	gboolean repack;
1011 	oarea = VIPS_AREA( vips_array_int_newv( 4,
1012 		trn-&gt;oarea.left, trn-&gt;oarea.top,
1013 		trn-&gt;oarea.width, trn-&gt;oarea.height ) );
1014 	repack = in-&gt;Coding == VIPS_CODING_LABQ;
1015 	if( vips_affine( in, &amp;t[0],
1016 		trn-&gt;a, trn-&gt;b, trn-&gt;c, trn-&gt;d,
1017 		"oarea", oarea,
1018 		"odx", trn-&gt;odx,
1019 		"ody", trn-&gt;ody,
1020 		NULL ) ) {
1021 		vips_area_unref( oarea );
1022 		return( -1 );
1023 	}
1024 	vips_area_unref( oarea );
1025 	in = t[0];
1026 	if( repack ) {
1027 		if (vips_colourspace( in, &amp;t[1],
1028 			VIPS_INTERPRETATION_LABQ, NULL ) )
1029 			return ( -1 );
1030 		in = t[1];
1031 	}
1032 	if( vips_image_write( in, out ) )
1033 		return( -1 );
1034 	return( 0 );
1035 }
1036 static void *
1037 generate_trn_leaves( JoinNode *node, SymbolTable *st, void *b )
1038 {
1039 	if( node-&gt;type == JOIN_LEAF ) {
1040 		if( !node-&gt;im ) {
1041 			vips_error( "vips_global_balance", 
1042 				_( "unable to open \"%s\"" ), node-&gt;name );
1043 			return( node );
1044 		}
1045 		if( node-&gt;trnim ) 
1046 			vips_error_exit( "global_balance: sanity failure #765" );
1047 		if( vips__transform_isidentity( &amp;node-&gt;cumtrn ) )
1048 			node-&gt;trnim = node-&gt;im;
1049 		else {
1050 			node-&gt;trnim = vips_image_new();
1051 			vips_object_local( node-&gt;st-&gt;im, node-&gt;trnim );
1052 			if ( vips__affinei( node-&gt;im, node-&gt;trnim, &amp;node-&gt;cumtrn ) )
1053 				return( node );
1054 		}
1055 	}
1056 	return( NULL );
1057 }
1058 static int
1059 analyse_mosaic( SymbolTable *st, VipsImage *in )
1060 {
1061 	if( vips__parse_desc( st, in ) )
1062 		return( -1 );
1063 #ifdef DEBUG
1064 	printf( "Input files:\n" );
1065 	vips__map_table( st, (VipsSListMap2Fn) print_leaf, NULL, NULL );
1066 	printf( "\nOutput file:\n" );
1067 	print_node( st-&gt;root );
1068 	printf( "\nJoin commands:\n" );
1069 	print_joins( st-&gt;root, 0 );
1070 	if( vips__map_table( st, 
1071 		(VipsSListMap2Fn) generate_trn_leaves, st, NULL ) )
1072 		return( -1 );
1073 	if( vips__map_table( st, (VipsSListMap2Fn) find_overlaps, st, NULL ) )
1074 		return( -1 );
1075 	vips__map_table( st, (VipsSListMap2Fn) count_leaves, NULL, NULL );
1076 	vips__map_table( st, (VipsSListMap2Fn) count_joins, NULL, NULL );
1077 	st-&gt;leaf = vips__map_table( st, 
1078 		(VipsSListMap2Fn) choose_leaf, NULL, NULL );
1079 #ifdef DEBUG
1080 	printf( "\nLeaf to be 1.000:\n" );
1081 	print_node( st-&gt;leaf );
1082 	printf( "\nOverlaps:\n" );
1083 	vips__map_table( st, (VipsSListMap2Fn) print_overlaps, NULL, NULL );
1084 	printf( "\n%d input files, %d unique overlaps, %d joins\n", 
1085 		st-&gt;nim, st-&gt;novl, st-&gt;njoin );
1086 	return( 0 );
1087 }
1088 static VipsImage *
1089 transform( JoinNode *node, double *gamma )
1090 {
1091 	SymbolTable *st = node-&gt;st;
1092 	VipsImage *in = node-&gt;im;
1093 	double fac = st-&gt;fac[node-&gt;index];
1094 	VipsImage **t = (VipsImage **)
1095 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 8 );
1096 	VipsImage *out;
1097 	if( fac == 1.0 ) {
1098 		out = in;
1099 	}
1100 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1101 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1102 		if( vips_identity( &amp;t[0],
1103 				"bands", 1,
1104 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1105 				NULL ) ||
1106 			vips_pow_const1( t[0], &amp;t[1],
1107 				1.0 / (*gamma), NULL ) ||
1108 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1109 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1110 			vips_cast( t[3], &amp;t[4], in-&gt;BandFmt, NULL ) ||
1111 			vips_maplut( in, &amp;t[5], t[4], NULL ) )
1112 			return( NULL );
1113 		out = t[5];
1114 	}
1115 	else {
1116 		if( vips_linear1( in, &amp;t[6], fac, 0.0, NULL ) ||
1117 			vips_cast( t[6], &amp;t[7], in-&gt;BandFmt, NULL ) )
1118 			return( NULL );
1119 		out = t[7];
1120 	}
1121 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1122 	return( out );
1123 }
1124 static VipsImage *
1125 transformf( JoinNode *node, double *gamma )
1126 {
1127 	SymbolTable *st = node-&gt;st;
1128 	VipsImage *in = node-&gt;im;
1129 	double fac = node-&gt;st-&gt;fac[node-&gt;index];
1130 	VipsImage **t = (VipsImage **) 
1131 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 6 );
1132 	VipsImage *out;
1133 	if( fac == 1.0 ) {
1134 		out = in;
1135 	}
1136 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1137 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1138 		if( vips_identity( &amp;t[0],
1139 				"bands", 1,
1140 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1141 				NULL ) ||
1142 			vips_pow_const1( t[0], &amp;t[1],
1143 				1.0 / (*gamma), NULL ) ||
1144 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1145 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1146 			vips_maplut( in, &amp;t[4], t[3], NULL ) )
1147 			return( NULL );
1148 		out = t[4];
1149 	}
1150 	else {
1151 		if( vips_linear1( in, &amp;t[5], fac, 0.0, NULL ) )
1152 			return( NULL );
1153 		out = t[5];
1154 	}
1155 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1156 	return( out );
1157 }
1158 typedef struct {
1159 	VipsOperation parent_instance;
1160 	VipsImage *in;
1161 	VipsImage *out;
1162 	gboolean int_output;
1163 	double gamma;
1164 } VipsGlobalbalance;
1165 typedef VipsOperationClass VipsGlobalbalanceClass;
1166 G_DEFINE_TYPE( VipsGlobalbalance, vips_globalbalance, VIPS_TYPE_OPERATION );
1167 static int
1168 vips_globalbalance_build( VipsObject *object )
1169 {
1170 	VipsGlobalbalance *globalbalance = (VipsGlobalbalance *) object;
1171 	SymbolTable *st;
1172 	transform_fn trn;
1173 	g_object_set( globalbalance, "out", vips_image_new(), NULL ); 
1174 	if( VIPS_OBJECT_CLASS( vips_globalbalance_parent_class )-&gt;
1175 		build( object ) )
1176 		return( -1 );
1177 	if( !(st = vips__build_symtab( globalbalance-&gt;out, SYM_TAB_SIZE )) ||
1178 		analyse_mosaic( st, globalbalance-&gt;in ) ||
1179 		find_factors( st, globalbalance-&gt;gamma ) )
1180 		return( -1 );
1181 <a name="0"></a>
1182 	trn = globalbalance-&gt;int_output ? 
1183 		(transform_fn) transform : (transform_fn) transformf; 
1184 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( vips__build_mosaic( st, globalbalance-&gt;out, 
1185 		trn, &amp;globalbalance-&gt;gamma ) )
1186 		return( -1 );
1187 	return( 0 );
1188 }
1189 static void
1190 vips_globalbalance_class_init( VipsGlobalbalanceClass *class )
1191 {
1192 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1193 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1194 	gobject_class-&gt;set_property = vips_object_set_property;
1195 	gobject_class-&gt;get_property = vips_object_get_property;
1196 	object_class-&gt;nickname = "globalbalance";
1197 	object_class-&gt;description = _( "global balance an image mosaic" );
1198 	object_class-&gt;build = vips_globalbalance_build;
1199 	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
1200 		_( "Input" ), 
1201 		_( "Input image" ),
1202 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1203 		G_STRUCT_OFFSET( VipsGlobalbalance, in ) );
1204 	VIPS_ARG_IMAGE( class, "out", 2, 
1205 		_( "Output" ), 
1206 		_( "Output image" ),
1207 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1208 		G_STRUCT_OFFSET( VipsGlobalbalance, out ) );
1209 	VIPS_ARG_DOUBLE( class, "gamma", 5, 
1210 		_( "gamma" ), 
1211 		_( "Image gamma" ),
1212 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1213 		G_STRUCT_OFFSET( VipsGlobalbalance, gamma ),
1214 		0.00001, 10, 1.6 );
1215 	VIPS_ARG_BOOL( class, "int_output", 7, 
1216 		_( "Int output" ), 
1217 		_( "Integer output" ),
1218 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1219 		G_STRUCT_OFFSET( VipsGlobalbalance, int_output ),
1220 		FALSE ); 
1221 }
1222 static void
1223 vips_globalbalance_init( VipsGlobalbalance *globalbalance )
1224 {
1225 	globalbalance-&gt;gamma = 1.6;
1226 }
1227 int 
1228 vips_globalbalance( VipsImage *in, VipsImage **out, ... )
1229 {
1230 	va_list ap;
1231 	int result;
1232 	va_start( ap, out );
1233 	result = vips_call_split( "globalbalance", ap, in, out );
1234 	va_end( ap );
1235 	return( result );
1236 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_GSF
10 #pragma GCC diagnostic push
11 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
12 #include &lt;gsf/gsf.h&gt;
13 #pragma GCC diagnostic pop
14 typedef struct _VipsGsfDirectory { 
15 	struct _VipsGsfDirectory *parent;
16 	char *name;
17 	GSList *children;
18 	GsfOutput *out;
19         GsfOutput *container;
20 	size_t file_count;
21 	size_t filename_lengths;
22 	gint deflate_level;
23 } VipsGsfDirectory; 
24 static void *vips_gsf_tree_close( VipsGsfDirectory *tree );
25 static void *
26 vips_gsf_tree_close_cb( void *item, void *a, void *b )
27 {
28 	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;
29 	return( vips_gsf_tree_close( tree ) );
30 }
31 static void *
32 vips_gsf_tree_close( VipsGsfDirectory *tree )
33 {
34 	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );
35 	if( tree-&gt;out ) {
36 		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
37 			!gsf_output_close( tree-&gt;out ) ) {
38 			vips_error( "vips_gsf", 
39 				"%s", _( "unable to close stream" ) ); 
40 			return( tree );
41 		}
42 		VIPS_UNREF( tree-&gt;out );
43 	}
44 	if( tree-&gt;container ) { 
45 		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
46 			!gsf_output_close( tree-&gt;container ) ) {
47 			vips_error( "vips_gsf", 
48 				"%s", _( "unable to close stream" ) ); 
49 			return( tree );
50 		}
51 		VIPS_UNREF( tree-&gt;container );
52 	}
53 	VIPS_FREEF( g_slist_free, tree-&gt;children );
54 	VIPS_FREE( tree-&gt;name );
55 	VIPS_FREE( tree );
56 	return( NULL ); 
57 }
58 static VipsGsfDirectory *
59 vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
60 {
61 	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );
62 	tree-&gt;parent = NULL;
63 	tree-&gt;name = NULL;
64 	tree-&gt;children = NULL;
65 	tree-&gt;out = out;
66 	tree-&gt;container = NULL;
67 	tree-&gt;file_count = 0;
68 	tree-&gt;filename_lengths = 0;
69 	tree-&gt;deflate_level = deflate_level;
70 	return( tree ); 
71 }
72 static void *
73 vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
74 {
75 	if( strcmp( dir-&gt;name, name ) == 0 )
76 		return( dir );
77 	return( NULL ); 
78 }
79 static VipsGsfDirectory *
80 vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
81 {
82 	return( vips_slist_map2( dir-&gt;children, 
83 		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
84 		(char *) name, NULL ) );
85 }
86 static VipsGsfDirectory *
87 vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
88 {
89 	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );
90 	g_assert( !vips_gsf_child_by_name( parent, name ) ); 
91 	dir-&gt;parent = parent;
92 	dir-&gt;name = g_strdup( name );
93 	dir-&gt;children = NULL;
94 	dir-&gt;container = NULL;
95 	dir-&gt;file_count = 0;
96 	dir-&gt;filename_lengths = 0;
97 	dir-&gt;deflate_level = parent-&gt;deflate_level;
98 	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
99 		dir-&gt;out = gsf_outfile_new_child_full( 
100 			(GsfOutfile *) parent-&gt;out, 
101 			name, TRUE,
102 			"compression-level", GSF_ZIP_STORED,
103 			NULL );
104 	else
105 		dir-&gt;out = gsf_outfile_new_child( 
106 			(GsfOutfile *) parent-&gt;out, 
107 			name, TRUE ); 
108 	g_assert( dir-&gt;out ); 
109 	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 
110 	return( dir ); 
111 }
112 static GsfOutput *
113 vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
114 {
115 	va_list ap;
116 	VipsGsfDirectory *dir;
117 	VipsGsfDirectory *child;
118 	char *dir_name;
119 	GsfOutput *obj;
120 	tree-&gt;file_count += 1;
121 	tree-&gt;filename_lengths += 
122 		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;
123 	dir = tree; 
124 	va_start( ap, name );
125 	while( (dir_name = va_arg( ap, char * )) ) {
126 		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
127 			dir = child;
128 		else 
129 			dir = vips_gsf_dir_new( dir, dir_name );
130 		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
131 	}
132 	va_end( ap );
133 	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
134 		if( dir-&gt;deflate_level == 0 )
135 			obj = gsf_outfile_new_child_full(
136 				(GsfOutfile *) dir-&gt;out,
137 				name, FALSE,
138 				"compression-level", GSF_ZIP_STORED,
139 				NULL );
140 		else if( dir-&gt;deflate_level == -1 )
141 			obj = gsf_outfile_new_child_full(
142 				(GsfOutfile *) dir-&gt;out,
143 				name, FALSE,
144 				"compression-level", GSF_ZIP_DEFLATED,
145 				NULL );
146 		else
147 			obj = gsf_outfile_new_child_full(
148 				(GsfOutfile *) dir-&gt;out,
149 				name, FALSE,
150 				"compression-level", GSF_ZIP_DEFLATED,
151 				"deflate-level", dir-&gt;deflate_level,
152 				NULL );
153 	}
154 	else
155 		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
156 			name, FALSE ); 
157 	return( obj ); 
158 }
159 typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
160 typedef struct _Layer Layer;
161 struct _Layer {
162 	VipsForeignSaveDz *dz;
163 	int width;
164 	int height;
165 	int tiles_across;
166 	int tiles_down;
167 	VipsRect real_pixels; 
168 	VipsImage *image;
169 	int y;
170 	int write_y;
171 	VipsRegion *strip;			VipsRegion *copy;		
172 	int sub;				int n;				
173 	Layer *below;				Layer *above;			};
174 struct _VipsForeignSaveDz {
175 	VipsForeignSave parent_object;
176 	char *suffix;
177 	int overlap;
178 	int tile_size;
179 	VipsForeignDzLayout layout;
180 	VipsForeignDzDepth depth;
181 	gboolean centre;
182 	gboolean properties;
183 	VipsAngle angle;
184 	VipsForeignDzContainer container; 
185 	int compression;
186 	VipsRegionShrink region_shrink;
187 	int skip_blanks;
188 	gboolean no_strip;
189 	char *id;
190 	int tile_margin;
191 	int tile_step;
192 	Layer *layer;			
193 	int tile_count;
194 	VipsGsfDirectory *tree;
195 	GsfOutput *out;
196 	char *basename; 
197 	char *dirname; 
198 	char *tempdir;
199 	char *root_name; 
200 	char *file_suffix;
201 	size_t bytes_written;
202 	VipsPel *ink;
203 };
204 typedef VipsForeignSaveClass VipsForeignSaveDzClass;
205 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
206 	VIPS_TYPE_FOREIGN_SAVE );
207 static gboolean
208 iszip( VipsForeignDzContainer container )
209 {
210 	switch( container ) {
211 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
212 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
213 		return( TRUE );
214 	default:
215 		return( FALSE );
216 	}
217 }
218 #define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
219 #define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
220 #define VIPS_ZIP_EOCD_SIZE 22
221 #ifndef HAVE_GSF_ZIP64
222 static size_t
223 estimate_zip_size( VipsForeignSaveDz *dz )
224 {
225 	size_t estimated_zip_size = dz-&gt;bytes_written +
226 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
227 		dz-&gt;tree-&gt;filename_lengths +
228 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
229 		dz-&gt;tree-&gt;filename_lengths +
230 		VIPS_ZIP_EOCD_SIZE;
231 #ifdef DEBUG_VERBOSE
232 	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
233 	return( estimated_zip_size );
234 }
235 static int
236 write_image( VipsForeignSaveDz *dz,
237 	GsfOutput *out, VipsImage *image, const char *format )
238 {
239 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );
240 	VipsImage *t;
241 	void *buf;
242 	size_t len;
243 	if( vips_copy( image, &amp;t, NULL ) ) 
244 		return( -1 );
245 	vips_image_set_int( t, "hide-progress", 1 );
246 	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
247 		"strip", !dz-&gt;no_strip,
248 		NULL ) ) {
249 		VIPS_UNREF( t );
250 		return( -1 );
251 	}
252 	VIPS_UNREF( t );
253 	g_mutex_lock( vips__global_lock );
254 	if( !gsf_output_write( out, len, buf ) ) {
255 		gsf_output_close( out );
256 		g_mutex_unlock( vips__global_lock );
257 		g_free( buf );
258 		vips_error( class-&gt;nickname,
259 			"%s", gsf_output_error( out )-&gt;message );
260 		return( -1 );
261 	}
262 	dz-&gt;bytes_written += len;
263 	gsf_output_close( out );
264 #ifndef HAVE_GSF_ZIP64
265 	if( iszip( dz-&gt;container ) ) {
266 		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
267 			g_mutex_unlock( vips__global_lock );
268 			vips_error( class-&gt;nickname,
269 				"%s", _( "too many files in zip" ) );
270 			return( -1 );
271 		}
272 		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
273 			g_mutex_unlock( vips__global_lock );
274 			vips_error( class-&gt;nickname,
275 				"%s", _( "output file too large" ) ); 
276 			return( -1 ); 
277 		}
278 	}
279 	g_mutex_unlock( vips__global_lock );
280 	g_free( buf );
281 	return( 0 );
282 }
283 static void
284 layer_free( Layer *layer )
285 {
286 	VIPS_FREEF( g_object_unref, layer-&gt;strip );
287 	VIPS_FREEF( g_object_unref, layer-&gt;copy );
288 	VIPS_FREEF( g_object_unref, layer-&gt;image );
289 	VIPS_FREEF( layer_free, layer-&gt;below ); 
290 }
291 static void
292 vips_foreign_save_dz_dispose( GObject *gobject )
293 {
294 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;
295 	VIPS_FREEF( layer_free, dz-&gt;layer );
296 	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
297 	VIPS_FREEF( g_object_unref, dz-&gt;out );
298 	VIPS_FREE( dz-&gt;basename );
299 	VIPS_FREE( dz-&gt;dirname );
300 	VIPS_FREE( dz-&gt;tempdir );
301 	VIPS_FREE( dz-&gt;root_name );
302 	VIPS_FREE( dz-&gt;file_suffix );
303 	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
304 		dispose( gobject );
305 }
306 static Layer *
307 pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
308 	int width, int height, VipsRect *real_pixels )
309 {
310 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
311 	Layer *layer = VIPS_NEW( dz, Layer );
312 	VipsRect strip;
313 	int limit; 
314 	layer-&gt;dz = dz;
315 	layer-&gt;width = width;
316 	layer-&gt;height = height;
317 	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
318 		dz-&gt;tile_step;
319 	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
320 		dz-&gt;tile_step;
321 	layer-&gt;real_pixels = *real_pixels; 
322 	layer-&gt;image = NULL;
323 	layer-&gt;strip = NULL;
324 	layer-&gt;copy = NULL;
325 	if( !above )
326 		layer-&gt;sub = 1;	
327 	else
328 		layer-&gt;sub = above-&gt;sub * 2;
329 	layer-&gt;below = NULL;
330 	layer-&gt;above = above;
331 	layer-&gt;image = vips_image_new();
332 	if( vips_image_pipelinev( layer-&gt;image, 
333 		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
334 		layer_free( layer );
335 		return( NULL );
336 	}
337 	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
338 	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);
339 	layer-&gt;strip = vips_region_new( layer-&gt;image );
340 	layer-&gt;copy = vips_region_new( layer-&gt;image );
341 	vips__region_no_ownership( layer-&gt;strip );
342 	vips__region_no_ownership( layer-&gt;copy );
343 	layer-&gt;y = 0;
344 	layer-&gt;write_y = 0;
345 	strip.left = 0;
346 	strip.top = 0;
347 	strip.width = layer-&gt;image-&gt;Xsize;
348 	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
349 	if( (strip.height &amp; 1) == 1 )
350 		strip.height += 1;
351 	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
352 		layer_free( layer );
353 		return( NULL );
354 	}
355 	switch( dz-&gt;depth ) {
356 	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
357 		limit = 1;
358 		break;
359 	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
360 		limit = dz-&gt;tile_size;
361 		break;
362 	case VIPS_FOREIGN_DZ_DEPTH_ONE:
363 		limit = VIPS_MAX( width, height );
364 		break;
365 	default:
366 		g_assert_not_reached();
367 		limit = 1;
368 	}
369 	if( width &gt; limit || 
370 		height &gt; limit ) {
371 		VipsRect halfrect;
372 		halfrect.left = real_pixels-&gt;left / 2;
373 		halfrect.top = real_pixels-&gt;top / 2;
374 		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
375 			halfrect.left;
376 		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
377 			halfrect.top;
378 		if( !(layer-&gt;below = pyramid_build( dz, layer, 
379 			(width + 1) / 2, (height + 1) / 2,
380 			&amp;halfrect )) ) { 
381 			layer_free( layer );
382 			return( NULL );
383 		}
384 		layer-&gt;n = layer-&gt;below-&gt;n + 1;
385 	}
386 	else
387 		layer-&gt;n = 0;
388 #ifdef DEBUG
389 	printf( "pyramid_build:\n" );
390 	printf( "\tn = %d\n", layer-&gt;n );
391 	printf( "\twidth = %d, height = %d\n", width, height );
392 	printf( "\tXsize = %d, Ysize = %d\n", 
393 		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
394 	printf( "\ttiles_across = %d, tiles_down = %d\n", 
395 		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
396 	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
397 		real_pixels-&gt;left, real_pixels-&gt;top ); 
398 	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
399 		real_pixels-&gt;width, real_pixels-&gt;height ); 
400 	return( layer );
401 }
402 static int
403 write_dzi( VipsForeignSaveDz *dz )
404 {
405 	GsfOutput *out;
406 	char buf[VIPS_PATH_MAX];
407 	char *p;
408 	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
409 	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 
410 	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
411 	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
412 		*p = '\0';
413 	gsf_output_printf( out, "&lt;?xml "
414 		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
415 	gsf_output_printf( out, "&lt;Image "
416 		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
417 	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
418 	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
419 	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
420 	gsf_output_printf( out, "  &gt;\n" ); 
421 	gsf_output_printf( out, "  &lt;Size \n" );
422 	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
423 	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
424 	gsf_output_printf( out, "  /&gt;\n" ); 
425 	gsf_output_printf( out, "&lt;/Image&gt;\n" );
426 	(void) gsf_output_close( out );
427 	g_object_unref( out );
428 	return( 0 );
429 }
430 static int
431 write_properties( VipsForeignSaveDz *dz )
432 {
433 	GsfOutput *out;
434 	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 
435 	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
436 		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
437 		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
438 		dz-&gt;layer-&gt;width,
439 		dz-&gt;layer-&gt;height,
440 		dz-&gt;tile_count,
441 		dz-&gt;tile_size );
442 	(void) gsf_output_close( out );
443 	g_object_unref( out );
444 	return( 0 );
445 }
446 static int
447 write_blank( VipsForeignSaveDz *dz )
448 {
449 	VipsForeignSave *save = (VipsForeignSave *) dz;
450 	VipsImage *x, *t;
451 	int n;
452 	VipsArea *ones;
453 	double *d;
454 	double *bg;
455 	int i;
456 	GsfOutput *out; 
457 	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
458 		NULL, &amp;n, NULL, NULL );
459 	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
460 		return( -1 );
461 	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
462 	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
463 	for( i = 0; i &lt; n; i++ )
464 		d[i] = 1.0; 
465 	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
466 		vips_area_unref( ones );
467 		g_object_unref( x );
468 		return( -1 );
469 	}
470 	vips_area_unref( ones );
471 	g_object_unref( x );
472 	x = t;
473 	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 
474 	if( write_image( dz, out, x, ".png" ) ) {
475 		g_object_unref( out );
476 		g_object_unref( x );
477 		return( -1 );
478 	}
479 	g_object_unref( out );
480 	g_object_unref( x );
481 	return( 0 );
482 }
483 static int
484 write_json( VipsForeignSaveDz *dz )
485 {
486 	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";
487 	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
488 		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;
489 	GsfOutput *out;
490 	int i;
491 	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 
492 	gsf_output_printf( out, 
493 		"{\n"
494 		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
495 		"  \"@id\": \"%s/%s\",\n" 
496 		"  \"profile\": [\n"
497 		"    \"http://iiif.io/api/image/2/level0.json\",\n"
498 		"    {\n" 
499 		"      \"formats\": [\n"
500 		"        \"%s\"\n"
501 		"      ],\n"
502 		"      \"qualities\": [\n"
503 		"        \"default\"\n"
504 		"      ]\n"
505 		"    }\n"
506 		"  ],\n"
507 		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
508 		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
509 		name, 
510 		suffix );
511 	gsf_output_printf( out, 
512 		"  \"tiles\": [\n"
513 		"    {\n"
514 		"      \"scaleFactors\": [\n" );
515 	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
516 		gsf_output_printf( out, 
517 			"        %d",
518 				1 &lt;&lt; i );
519 		if( i != dz-&gt;layer-&gt;n - 1 )
520 			gsf_output_printf( out, "," );
521 		gsf_output_printf( out, "\n" );
522 	}
523 	gsf_output_printf( out, 
524 		"      ],\n"
525 		"      \"width\": %d\n"
526 		"    }\n"
527 		"  ],\n", dz-&gt;tile_size );
528 	gsf_output_printf( out, 
529 		"  \"width\": %d,\n"
530 		"  \"height\": %d\n", 
531 			dz-&gt;layer-&gt;width,
532 			dz-&gt;layer-&gt;height );
533 	gsf_output_printf( out, 
534 		"}\n" );
535 	(void) gsf_output_close( out );
536 	g_object_unref( out );
537 	return( 0 );
538 }
539 static int
540 write_vips_meta( VipsForeignSaveDz *dz )
541 {
542 	VipsForeignSave *save = (VipsForeignSave *) dz;
543 	char *dump;
544 	GsfOutput *out;
545 	if( !(dump = vips__xml_properties( save-&gt;ready )) )
546                 return( -1 );
547 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
548 		out = vips_gsf_path( dz-&gt;tree, 
549 			"vips-properties.xml", dz-&gt;root_name, NULL );
550 	else
551 		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );
552 	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
553 	(void) gsf_output_close( out );
554 	g_object_unref( out );
555 	g_free( dump );
556 	return( 0 );
557 }
558 static void
559 build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
560 	const char *vips_name, const char *szi_name )
561 {
562 	const char *str;
563 	GValue value = { 0 };
564 	GValue save_value = { 0 };
565 	GType type;
566 	if( !vips_image_get_typeof( image, vips_name ) )
567 		return;
568 	if( vips_image_get( image, vips_name, &amp;value ) )
569 		return;
570 	type = G_VALUE_TYPE( &amp;value );
571 	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
572 		g_value_unset( &amp;value );
573 		return;
574 	}
575 	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
576 	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
577 		g_value_unset( &amp;value );
578 		return;
579 	}
580 	g_value_unset( &amp;value );
581 	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
582 		g_value_unset( &amp;save_value );
583 		return;
584 	}
585 	if( !g_utf8_validate( str, -1, NULL ) ) {
586 		g_value_unset( &amp;save_value );
587 		return;
588 	}
589 	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
590 	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
591 	vips_dbuf_write_amp( dbuf, szi_name );
592 	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
593 	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
594 		g_type_name( type )  );
595 	vips_dbuf_write_amp( dbuf, str );
596 	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
597 	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );
598 	g_value_unset( &amp;save_value );
599 }
600 static char *scan_property_names[][2] = {
601 	{ "openslide.vendor", "Vendor" },
602 	{ "openslide.objective-power", "ObjectiveMagnification" },
603 	{ "openslide.mpp-x", "MicronsPerPixelX" },
604 	{ "openslide.mpp-y", "MicronsPerPixelY" },
605 	{ "width", "ImageWidth" },
606 	{ "height", "ImageHeight" }
607 };
608 char *
609 build_scan_properties( VipsImage *image )
610 {
611 	VipsDbuf dbuf;
612 	char *date;
613 	int i;
614 	date = vips__get_iso8601();
615 	vips_dbuf_init( &amp;dbuf );
616 	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
617 	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
618 		" date=\"%s\" version=\"1.0\"&gt;\n", date );
619 	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  
620 	g_free( date ); 
621 	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
622 		build_scan_property( &amp;dbuf, image,
623 			scan_property_names[i][0],
624 			scan_property_names[i][1] );
625 	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
626 	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );
627 	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
628 }
629 static int
630 write_scan_properties( VipsForeignSaveDz *dz )
631 {
632 	VipsForeignSave *save = (VipsForeignSave *) dz;
633 	char *dump;
634 	GsfOutput *out;
635 	if( !(dump = build_scan_properties( save-&gt;ready )) )
636                 return( -1 );
637 	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
638 	gsf_output_write( out, strlen( dump ), (guchar *) dump );
639 	(void) gsf_output_close( out );
640 	g_object_unref( out );
641 	g_free( dump );
642 	return( 0 );
643 }
644 static void *
645 write_associated_images( VipsImage *image,
646 	const char *field, GValue *value, void *a )
647 {
648 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
649 	if( vips_isprefix( "openslide.associated.", field ) ) {
650 		VipsImage *associated;
651 		const char *p;
652 		const char *q;
653 		GsfOutput *out;
654 		char buf[VIPS_PATH_MAX];
655 		p = field + strlen( "openslide.associated." );
656 		if( (q = strrchr( p, '/' )) )
657 			p = q + 1;
658 		if( vips_image_get_image( image, field, &amp;associated ) )
659 			return( image );
660 		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
661 		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );
662 		if( write_image( dz, out, associated, ".jpg" ) ) {
663 			g_object_unref( out );
664 			g_object_unref( associated );
665 			return( image );
666 		}
667 		g_object_unref( out );
668 		g_object_unref( associated );
669 	}
670 	return( NULL );
671 }
672 static int
673 write_associated( VipsForeignSaveDz *dz )
674 {
675 	VipsForeignSave *save = (VipsForeignSave *) dz;
676 	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
677 		return( -1 );
678 	return( 0 );
679 }
680 typedef struct _Strip {
681 	Layer *layer; 
682 	VipsImage *image;
683 	int x;
684 } Strip;
685 static void
686 strip_free( Strip *strip )
687 {
688 	g_object_unref( strip-&gt;image );
689 }
690 static void
691 strip_init( Strip *strip, Layer *layer )
692 {
693 	VipsForeignSaveDz *dz = layer-&gt;dz;
694 	VipsRect line, image;
695 	strip-&gt;layer = layer;
696 	strip-&gt;image = NULL;
697 	strip-&gt;x = 0;
698 	image.left = 0;
699 	image.top = 0;
700 	image.width = layer-&gt;image-&gt;Xsize;
701 	image.height = layer-&gt;height;
702 	line.left = 0;
703 	line.top = layer-&gt;y;
704 	line.width = image.width;
705 	line.height = dz-&gt;tile_size;
706 	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );
707 	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );
708 	if( !(strip-&gt;image = vips_image_new_from_memory( 
709 		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
710 		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
711 		line.width, line.height, 
712 		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
713 		strip_free( strip );
714 		return;
715 	}
716 	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
717 		strip_free( strip );
718 		return;
719 	}
720 	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
721 }
722 static int
723 strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
724 {
725 	Strip *strip = (Strip *) a;
726 	Layer *layer = strip-&gt;layer;
727 	VipsForeignSaveDz *dz = layer-&gt;dz;
728 	VipsRect image;
729 #ifdef DEBUG_VERBOSE
730 	printf( "strip_allocate\n" );
731 	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
732 		*stop = TRUE;
733 #ifdef DEBUG_VERBOSE
734 <a name="1"></a>		printf( "strip_allocate: done\n" );
735 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( 0 );
736 	}
737 	image.left = 0;
738 	image.top = 0;
739 	image.width = layer-&gt;width;
740 	image.height = layer-&gt;height;
741 	state-&gt;pos.left = strip-&gt;x;
742 	state-&gt;pos.top = layer-&gt;y;
743 	state-&gt;pos.width = dz-&gt;tile_size;
744 	state-&gt;pos.height = dz-&gt;tile_size;
745 	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );
746 	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
747 	state-&gt;x = strip-&gt;x;
748 	state-&gt;y = layer-&gt;y;
749 	strip-&gt;x += dz-&gt;tile_step;</b></font>
750 	return( 0 );
751 }
752 static GsfOutput *
753 tile_name( Layer *layer, int x, int y )
754 {
755 	VipsForeignSaveDz *dz = layer-&gt;dz;
756 	VipsForeignSave *save = (VipsForeignSave *) dz;
757 	GsfOutput *out; 
758 	char name[VIPS_PATH_MAX];
759 	char dirname[VIPS_PATH_MAX];
760 	char dirname2[VIPS_PATH_MAX];
761 	Layer *p;
762 	int n;
763 	switch( dz-&gt;layout ) {
764 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
765 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
766 		vips_snprintf( name, VIPS_PATH_MAX, 
767 			"%d_%d%s", x, y, dz-&gt;file_suffix );
768 		out = vips_gsf_path( dz-&gt;tree, name, 
769 			dz-&gt;root_name, dirname, NULL );
770 		break;
771 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
772 		n = 0;
773 		for( p = layer-&gt;below; p; p = p-&gt;below )
774 			n += p-&gt;tiles_across * p-&gt;tiles_down;
775 		n += y * layer-&gt;tiles_across + x;
776 		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
777 		vips_snprintf( name, VIPS_PATH_MAX, 
778 			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );
779 		dz-&gt;tile_count += 1;
780 		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );
781 		break;
782 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
783 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
784 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
785 		vips_snprintf( name, VIPS_PATH_MAX, 
786 			"%d%s", x, dz-&gt;file_suffix );
787 		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );
788 		break;
789 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
790 {
791 		int left = x * dz-&gt;tile_size * layer-&gt;sub;
792 		int top = y * dz-&gt;tile_size * layer-&gt;sub;
793 		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
794 			save-&gt;ready-&gt;Xsize - left );
795 		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
796 			save-&gt;ready-&gt;Ysize - top );
797 		int size = VIPS_MIN( dz-&gt;tile_size, 
798 			layer-&gt;width - x * dz-&gt;tile_size );
799 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
800 			left, top, width, height );
801 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
802 		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
803 			dz-&gt;file_suffix );
804 		out = vips_gsf_path( dz-&gt;tree, 
805 			name, dirname, dirname2, "0", NULL );
806 }
807 		break;
808 	default:
809 		g_assert_not_reached();
810 		out = NULL;
811 	}
812 #ifdef DEBUG_VERBOSE
813 	printf( "tile_name: writing to %s\n", name );
814 	return( out );
815 }
816 static gboolean
817 tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
818 {
819 	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );
820 	VipsRect rect;
821 	VipsRegion *region;
822 	int x, y, b;
823 	region = vips_region_new( image ); 
824 	rect.left = 0;
825 	rect.top = 0;
826 	rect.width = image-&gt;Xsize;
827 	rect.height = image-&gt;Ysize;
828 	if( vips_region_prepare( region, &amp;rect ) ) {
829 		g_object_unref( region );
830 		return( FALSE ); 
831 	}
832 	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
833 		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 
834 		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
835 			for( b = 0; b &lt; bytes; b++ ) 
836 				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
837 					g_object_unref( region );
838 					return( FALSE ); 
839 				}
840 			p += bytes;
841 		}
842 	}
843 	g_object_unref( region );
844 	return( TRUE );
845 }
846 static int
847 strip_work( VipsThreadState *state, void *a )
848 {
849 	Strip *strip = (Strip *) a;
850 	Layer *layer = strip-&gt;layer;
851 	VipsForeignSaveDz *dz = layer-&gt;dz;
852 	VipsForeignSave *save = (VipsForeignSave *) dz;
853 	VipsImage *x;
854 	VipsImage *t;
855 	GsfOutput *out; 
856 #ifdef DEBUG_VERBOSE
857 	printf( "strip_work\n" );
858 	if( dz-&gt;centre ) {
859 		VipsRect tile; 
860 		tile.left = state-&gt;x;
861 		tile.top = state-&gt;y;
862 		tile.width = dz-&gt;tile_size;
863 		tile.height = dz-&gt;tile_size;
864 		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
865 #ifdef DEBUG_VERBOSE
866 			printf( "strip_work: skipping tile %d x %d\n", 
867 				state-&gt;x / dz-&gt;tile_size, 
868 				state-&gt;y / dz-&gt;tile_size ); 
869 			return( 0 ); 
870 		}
871 	}
872 	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );
873 	if( vips_extract_area( strip-&gt;image, &amp;x, 
874 		state-&gt;pos.left, 0, 
875 		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
876 		return( -1 );
877 	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
878 		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
879 		g_object_unref( x );
880 #ifdef DEBUG_VERBOSE
881 		printf( "strip_work: skipping blank tile %d x %d\n", 
882 			state-&gt;x / dz-&gt;tile_size, 
883 			state-&gt;y / dz-&gt;tile_size ); 
884 		return( 0 ); 
885 	}
886 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
887 		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
888 			"background", save-&gt;background,
889 			NULL ) ) {
890 			g_object_unref( x );
891 			return( -1 );
892 		}
893 		g_object_unref( x );
894 		x = t;
895 	}
896 	g_mutex_lock( vips__global_lock );
897 	out = tile_name( layer, 
898 		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );
899 	g_mutex_unlock( vips__global_lock );
900 	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
901 		g_object_unref( out );
902 		g_object_unref( x );
903 		return( -1 );
904 	}
905 	g_object_unref( out );
906 	g_object_unref( x );
907 #ifdef DEBUG_VERBOSE
908 	printf( "strip_work: success\n" );
909 	return( 0 );
910 }
911 static int
912 strip_save( Layer *layer )
913 {
914 	Strip strip;
915 #ifdef DEBUG
916 	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
917 	strip_init( &amp;strip, layer );
918 	if( vips_threadpool_run( strip.image, 
919 		vips_thread_state_new, strip_allocate, strip_work, NULL, 
920 		&amp;strip ) ) {
921 		strip_free( &amp;strip );
922 		return( -1 );
923 	}
924 	strip_free( &amp;strip );
925 #ifdef DEBUG
926 	printf( "strip_save: success\n" ); 
927 	return( 0 );
928 }
929 static void
930 layer_generate_extras( Layer *layer )
931 {
932 	VipsRegion *strip = layer-&gt;strip;
933 	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );
934 	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
935 		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );
936 		int b, y;
937 		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
938 			VipsPel *p = VIPS_REGION_ADDR( strip, 
939 				layer-&gt;width - 1, strip-&gt;valid.top + y );
940 			VipsPel *q = p + ps;
941 			for( b = 0; b &lt; ps; b++ )
942 				q[b] = p[b];
943 		}
944 	}
945 	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
946 		VipsRect last;
947 		last.left = 0;
948 		last.top = layer-&gt;image-&gt;Ysize - 2;
949 		last.width = layer-&gt;image-&gt;Xsize;
950 		last.height = 2;
951 		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
952 		if( last.height == 2 ) {
953 			last.height = 1;
954 			vips_region_copy( strip, strip, &amp;last, 
955 				0, last.top + 1 );
956 		}
957 	}
958 }
959 static int strip_arrived( Layer *layer );
960 static int
961 strip_shrink( Layer *layer )
962 {
963 	Layer *below = layer-&gt;below;
964 	VipsRegion *from = layer-&gt;strip;
965 	VipsRegion *to = below-&gt;strip;
966 	VipsForeignSaveDz *dz = layer-&gt;dz;
967 	VipsRegionShrink region_shrink = dz-&gt;region_shrink;
968 	VipsRect target;
969 	VipsRect source;
970 #ifdef DEBUG
971 	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
972 		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
973 	layer_generate_extras( layer );
974 	for(;;) {
975 		target.left = 0;
976 		target.top = below-&gt;write_y;
977 		target.width = below-&gt;image-&gt;Xsize;
978 		target.height = to-&gt;valid.height;
979 		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
980 		source.left = target.left * 2;
981 		source.top = target.top * 2;
982 		source.width = target.width * 2;
983 		source.height = target.height * 2;
984 		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
985 		target.left = source.left / 2;
986 		target.top = source.top / 2;
987 		target.width = source.width / 2;
988 		target.height = source.height / 2;
989 		if( vips_rect_isempty( &amp;target ) )
990 			break;
991 		(void) vips_region_shrink_method( from, to, 
992 			&amp;target, region_shrink );
993 		below-&gt;write_y += target.height;
994 		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
995 			below-&gt;write_y == below-&gt;height ) {
996 			if( strip_arrived( below ) )
997 				return( -1 );
998 		}
999 	}
1000 	return( 0 );
1001 }
1002 static int
1003 strip_arrived( Layer *layer )
1004 {
1005 	VipsForeignSaveDz *dz = layer-&gt;dz;
1006 	VipsRect new_strip;
1007 	VipsRect overlap;
1008 	VipsRect image_area;
1009 #ifdef DEBUG
1010 	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
1011 		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
1012 	if( strip_save( layer ) )
1013 		return( -1 );
1014 	if( layer-&gt;below &amp;&amp;
1015 		strip_shrink( layer ) )
1016 		return( -1 );
1017 	layer-&gt;y += dz-&gt;tile_step;
1018 	new_strip.left = 0;
1019 	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
1020 	new_strip.width = layer-&gt;image-&gt;Xsize;
1021 	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;
1022 	image_area.left = 0;
1023 	image_area.top = 0;
1024 	image_area.width = layer-&gt;image-&gt;Xsize;
1025 	image_area.height = layer-&gt;image-&gt;Ysize;
1026 	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
1027 	if( (new_strip.height &amp; 1) == 1 )
1028 		new_strip.height += 1;
1029 	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )
1030 		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;
1031 	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
1032 	if( !vips_rect_isempty( &amp;overlap ) ) {
1033 		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
1034 			return( -1 );
1035 		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
1036 			&amp;overlap, overlap.left, overlap.top );
1037 	}
1038 	if( !vips_rect_isempty( &amp;new_strip ) ) {
1039 		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
1040 			return( -1 );
1041 		if( !vips_rect_isempty( &amp;overlap ) ) 
1042 			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
1043 				&amp;overlap, overlap.left, overlap.top );
1044 	}
1045 	return( 0 );
1046 }
1047 static int
1048 strip_flush( Layer *layer )
1049 {
1050 	if( layer-&gt;y &lt; layer-&gt;height )
1051 		if( strip_save( layer ) )
1052 			return( -1 );
1053 	if( layer-&gt;below )
1054 		if( strip_flush( layer-&gt;below ) )
1055 			return( -1 );
1056 	return( 0 );
1057 }
1058 static int
1059 pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
1060 {
1061 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
1062 	Layer *layer = dz-&gt;layer;
1063 #ifdef DEBUG
1064 	printf( "pyramid_strip: strip at %d, height %d\n", 
1065 		area-&gt;top, area-&gt;height );
1066 	for(;;) {
1067 		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
1068 		VipsRect target;
1069 		target.left = 0;
1070 		target.top = layer-&gt;write_y;
1071 		target.width = layer-&gt;image-&gt;Xsize;
1072 		target.height = to-&gt;height;
1073 		vips_rect_intersectrect( &amp;target, to, &amp;target );
1074 		vips_rect_intersectrect( &amp;target, area, &amp;target );
1075 		if( vips_rect_isempty( &amp;target ) ) 
1076 			break;
1077 		vips_region_copy( region, layer-&gt;strip, 
1078 			&amp;target, target.left, target.top );
1079 		layer-&gt;write_y += target.height;
1080 		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
1081 			layer-&gt;write_y == layer-&gt;height ) {
1082 			if( strip_arrived( layer ) ) 
1083 				return( -1 );
1084 		}
1085 	}
1086 	if( layer-&gt;write_y == layer-&gt;height ) {
1087 #ifdef DEBUG
1088 		printf( "pyramid_strip: flushing ..\n" ); 
1089 		if( strip_flush( layer ) )
1090 			return( -1 );
1091 	}
1092 	return( 0 );
1093 }
1094 static int
1095 vips_foreign_save_dz_build( VipsObject *object )
1096 {
1097 	VipsForeignSave *save = (VipsForeignSave *) object;
1098 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1099 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
1100 	VipsRect real_pixels; 
1101 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1102 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
1103 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1104 		if( !vips_object_argument_isset( object, "overlap" ) )
1105 			dz-&gt;overlap = 0;
1106 		if( !vips_object_argument_isset( object, "suffix" ) )
1107 			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
1108 	}
1109 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1110 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
1111 		if( !vips_object_argument_isset( object, "tile_size" ) )
1112 			dz-&gt;tile_size = 256;
1113 	}
1114 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1115 		if( !vips_object_argument_isset( object, "tile_size" ) )
1116 			dz-&gt;tile_size = 512;
1117 	}
1118 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1119 		!vips_object_argument_isset( object, "skip_blanks" ) )
1120 		dz-&gt;skip_blanks = 5;
1121 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
1122 		dz-&gt;tile_margin = dz-&gt;overlap;
1123 		dz-&gt;tile_step = dz-&gt;tile_size; 
1124 	}
1125 	else {
1126 		dz-&gt;tile_margin = 0;
1127 		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
1128 	}
1129 	if( dz-&gt;tile_step &lt;= 0 ) {
1130 		vips_error( "dzsave", "%s", _( "overlap too large" ) );
1131 		return( -1 );
1132 	}
1133 	if( !vips_object_argument_isset( object, "background" ) ) {
1134 		VipsArrayDouble *background; 
1135 		background = vips_array_double_newv( 1, 255.0 );
1136 		g_object_set( object, "background", background, NULL );
1137 		vips_area_unref( VIPS_AREA( background ) ); 
1138 	}
1139 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1140 		if( !vips_object_argument_isset( object, "depth" ) )
1141 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
1142 	}
1143 	else
1144 		if( !vips_object_argument_isset( object, "depth" ) )
1145 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;
1146 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
1147 		build( object ) )
1148 		return( -1 );
1149 {
1150 	VipsImage *z;
1151 	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
1152 		return( -1 );
1153 	VIPS_UNREF( save-&gt;ready );
1154 	save-&gt;ready = z;
1155 }
1156 	if( dz-&gt;skip_blanks &gt;= 0 ) {
1157 		if( !(dz-&gt;ink = vips__vector_to_ink( 
1158 			class-&gt;nickname, save-&gt;ready,
1159 			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
1160 			VIPS_AREA( save-&gt;background )-&gt;n )) )
1161 			return( -1 );
1162 	}
1163 	real_pixels.left = 0;
1164 	real_pixels.top = 0;
1165 	real_pixels.width = save-&gt;ready-&gt;Xsize;
1166 	real_pixels.height = save-&gt;ready-&gt;Ysize;
1167 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1168 		dz-&gt;centre ) {
1169 		VipsImage *z;
1170 		Layer *layer;
1171 		int n_layers;
1172 		int size;
1173 		if( !(layer = pyramid_build( dz, NULL, 
1174 			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
1175 			&amp;real_pixels )) )
1176 			return( -1 );
1177 		n_layers = layer-&gt;n;
1178 		g_assert( n_layers &lt; 30 );
1179 		layer_free( layer );
1180 		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);
1181 		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
1182 		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;
1183 		if( vips_embed( save-&gt;ready, &amp;z, 
1184 			real_pixels.left, real_pixels.top,
1185 			size, size,
1186 			"background", save-&gt;background,
1187 			NULL ) ) 
1188 			return( -1 );
1189 		VIPS_UNREF( save-&gt;ready );
1190 		save-&gt;ready = z;
1191 #ifdef DEBUG
1192 		printf( "centre: centring within a %d x %d image\n", 
1193 			size, size );
1194 	}
1195 #ifdef DEBUG
1196 	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
1197 		dz-&gt;tile_size );
1198 	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
1199 		dz-&gt;overlap );
1200 	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
1201 		dz-&gt;tile_margin );
1202 	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
1203 		dz-&gt;tile_step );
1204 	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
1205 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
1206 		return( -1 );
1207 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
1208 		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
1209 	else
1210 		dz-&gt;root_name = g_strdup( dz-&gt;basename );
1211 {
1212 	char filename[VIPS_PATH_MAX];
1213 	char option_string[VIPS_PATH_MAX];
1214 	vips__filename_split8( dz-&gt;suffix, filename, option_string );
1215 	dz-&gt;file_suffix = g_strdup( filename ); 
1216 }
1217 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1218 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
1219 		dz-&gt;dirname &amp;&amp;
1220 		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
1221 		vips_error( "dzsave", 
1222 			_( "output directory %s/%s_files exists" ),
1223 			dz-&gt;dirname, dz-&gt;basename );
1224 		return( -1 ); 
1225 	}
1226 	switch( dz-&gt;container ) {
1227 	case VIPS_FOREIGN_DZ_CONTAINER_FS:
1228 		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1229 			char name[VIPS_PATH_MAX];
1230 			int fd;
1231 			GsfOutput *out;
1232 			GError *error = NULL;
1233 			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
1234 				dz-&gt;basename ); 
1235 			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
1236 				name, NULL );
1237 			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
1238 				vips_error(  class-&gt;nickname,
1239 					_( "unable to make temporary file %s" ),
1240 					dz-&gt;tempdir );
1241 				return( -1 );
1242 			}
1243 			close( fd );
1244 			g_unlink( dz-&gt;tempdir );
1245 			if( !(out = (GsfOutput *) 
1246 				gsf_outfile_stdio_new( dz-&gt;tempdir, 
1247 					&amp;error )) ) {
1248 				vips_g_error( &amp;error );
1249 				return( -1 );
1250 			}
1251 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1252 		}
1253 		else { 
1254 			GsfOutput *out;
1255 			GError *error = NULL;
1256 			char name[VIPS_PATH_MAX];
1257 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
1258 				dz-&gt;dirname, dz-&gt;basename ); 
1259 			if( !(out = (GsfOutput *) 
1260 				gsf_outfile_stdio_new( name, &amp;error )) ) {
1261 				vips_g_error( &amp;error );
1262 				return( -1 );
1263 			}
1264 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1265 		}
1266 		break;
1267 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
1268 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
1269 {
1270 		GsfOutput *zip;
1271 		GsfOutput *out2;
1272 		GError *error = NULL;
1273 		char name[VIPS_PATH_MAX];
1274 		if( dz-&gt;dirname ) { 
1275 			const char *suffix =
1276 				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
1277 					"szi" : "zip";
1278 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
1279 				dz-&gt;dirname, dz-&gt;basename, suffix );
1280 			if( !(dz-&gt;out =
1281 				gsf_output_stdio_new( name, &amp;error )) ) {
1282 				vips_g_error( &amp;error );
1283 				return( -1 );
1284 			}
1285 		}
1286 		else
1287 			dz-&gt;out = gsf_output_memory_new();
1288 		if( !(zip = (GsfOutput *) 
1289 			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
1290 			vips_g_error( &amp;error );
1291 			return( -1 );
1292 		}
1293 		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
1294 			dz-&gt;basename, TRUE,
1295 			"compression-level", GSF_ZIP_STORED, 
1296 			NULL );
1297 #ifndef HAVE_GSF_DEFLATE_LEVEL
1298 		if( dz-&gt;compression &gt; 0 ) {
1299 			g_warning( "%s", 
1300 				_( "deflate-level not supported by libgsf, "
1301 				"using default compression" ) ); 
1302 			dz-&gt;compression = -1;
1303 		}
1304 		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );
1305 		dz-&gt;tree-&gt;container = zip; 
1306 }
1307 		break;
1308 	default:
1309 		g_assert_not_reached();
1310 	}
1311 	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
1312 		return( -1 );
1313 	switch( dz-&gt;layout ) {
1314 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
1315 		if( write_dzi( dz ) )
1316 			return( -1 );
1317 		break;
1318 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
1319 		if( write_properties( dz ) )
1320 			return( -1 );
1321 		break;
1322 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
1323 		if( write_blank( dz ) )
1324 			return( -1 );
1325 		break;
1326 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
1327 		if( write_json( dz ) )
1328 			return( -1 );
1329 		break;
1330 	default:
1331 		g_assert_not_reached();
1332 	}
1333 	if( dz-&gt;properties &amp;&amp;
1334 		write_vips_meta( dz ) )
1335 		return( -1 );
1336 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1337 		write_scan_properties( dz ) )
1338 		return( -1 );
1339 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1340 		write_associated( dz ) )
1341 		return( -1 );
1342 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1343 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
1344 		char old_name[VIPS_PATH_MAX];
1345 		char new_name[VIPS_PATH_MAX];
1346 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1347 			dz-&gt;tempdir, dz-&gt;basename );
1348 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1349 			dz-&gt;dirname, dz-&gt;basename );
1350 		if( vips_rename( old_name, new_name ) )
1351 			return( -1 ); 
1352 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
1353 			dz-&gt;tempdir, dz-&gt;basename );
1354 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
1355 			dz-&gt;dirname, dz-&gt;basename );
1356 		if( vips_rename( old_name, new_name ) )
1357 			return( -1 ); 
1358 		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
1359 			return( -1 ); 
1360 	}
1361 	if( vips_gsf_tree_close( dz-&gt;tree ) )
1362 		return( -1 ); 
1363 	dz-&gt;tree = NULL; 
1364 	if( iszip( dz-&gt;container ) &amp;&amp;
1365 		dz-&gt;dirname != NULL ) 
1366 		VIPS_FREEF( g_object_unref, dz-&gt;out );
1367 	return( 0 );
1368 }
1369 #define UC VIPS_FORMAT_UCHAR
1370 #define C VIPS_FORMAT_CHAR
1371 #define US VIPS_FORMAT_USHORT
1372 #define S VIPS_FORMAT_SHORT
1373 #define UI VIPS_FORMAT_UINT
1374 #define I VIPS_FORMAT_INT
1375 #define F VIPS_FORMAT_FLOAT
1376 #define X VIPS_FORMAT_COMPLEX
1377 #define D VIPS_FORMAT_DOUBLE
1378 #define DX VIPS_FORMAT_DPCOMPLEX
1379 static int bandfmt_dz[10] = {
1380    UC, C,  US, S,  UI, I,  F,  F,  D,  D
1381 };
1382 static const char *dz_suffs[] = { ".dz", NULL };
1383 static void
1384 vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
1385 {
1386 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1387 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1388 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
1389 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
1390 	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
1391 	gobject_class-&gt;set_property = vips_object_set_property;
1392 	gobject_class-&gt;get_property = vips_object_get_property;
1393 	object_class-&gt;nickname = "dzsave_base";
1394 	object_class-&gt;description = _( "save image to deep zoom format" );
1395 	object_class-&gt;build = vips_foreign_save_dz_build;
1396 	foreign_class-&gt;suffs = dz_suffs;
1397 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
1398 	save_class-&gt;format_table = bandfmt_dz;
1399 	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;
1400 	VIPS_ARG_STRING( class, "basename", 2, 
1401 		_( "Base name" ),
1402 		_( "Base name to save to" ),
1403 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1404 		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
1405 		NULL );
1406 	VIPS_ARG_ENUM( class, "layout", 8, 
1407 		_( "Layout" ), 
1408 		_( "Directory layout" ),
1409 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1410 		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
1411 		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 
1412 	VIPS_ARG_STRING( class, "suffix", 9, 
1413 		_( "suffix" ), 
1414 		_( "Filename suffix for tiles" ),
1415 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1416 		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
1417 		".jpeg" );
1418 	VIPS_ARG_INT( class, "overlap", 10, 
1419 		_( "Overlap" ), 
1420 		_( "Tile overlap in pixels" ),
1421 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1422 		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
1423 		0, 8192, 1 );
1424 	VIPS_ARG_INT( class, "tile_size", 11, 
1425 		_( "Tile size" ), 
1426 		_( "Tile size in pixels" ),
1427 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1428 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1429 		1, 8192, 254 );
1430 	VIPS_ARG_ENUM( class, "depth", 13, 
1431 		_( "Depth" ), 
1432 		_( "Pyramid depth" ),
1433 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1434 		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
1435 		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 
1436 	VIPS_ARG_BOOL( class, "centre", 13, 
1437 		_( "Center" ), 
1438 		_( "Center image in tile" ),
1439 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1440 		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
1441 		FALSE );
1442 	VIPS_ARG_ENUM( class, "angle", 14, 
1443 		_( "Angle" ), 
1444 		_( "Rotate image during save" ),
1445 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1446 		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
1447 		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 
1448 	VIPS_ARG_ENUM( class, "container", 15, 
1449 		_( "Container" ), 
1450 		_( "Pyramid container type" ),
1451 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1452 		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
1453 		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 
1454 	VIPS_ARG_BOOL( class, "properties", 16, 
1455 		_( "Properties" ), 
1456 		_( "Write a properties file to the output directory" ),
1457 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1458 		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
1459 		FALSE );
1460 	VIPS_ARG_INT( class, "compression", 17, 
1461 		_( "Compression" ), 
1462 		_( "ZIP deflate compression level" ),
1463 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1464 		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
1465 		-1, 9, 0 );
1466 	VIPS_ARG_ENUM( class, "region_shrink", 18, 
1467 		_( "Region shrink" ), 
1468 		_( "Method to shrink regions" ),
1469 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1470 		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
1471 		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
1472 	VIPS_ARG_INT( class, "skip_blanks", 19, 
1473 		_( "Skip blanks" ), 
1474 		_( "Skip tiles which are nearly equal to the background" ),
1475 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1476 		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
1477 		-1, 65535, -1 );
1478 	VIPS_ARG_BOOL( class, "no_strip", 20, 
1479 		_( "No strip" ), 
1480 		_( "Don't strip tile metadata" ),
1481 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1482 		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
1483 		FALSE );
1484 	VIPS_ARG_STRING( class, "id", 21, 
1485 		_( "id" ), 
1486 		_( "Resource ID" ),
1487 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1488 		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
1489 		"https://example.com/iiif" );
1490 	VIPS_ARG_STRING( class, "dirname", 1, 
1491 		_( "Directory name" ),
1492 		_( "Directory name to save to" ),
1493 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1494 		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
1495 		NULL );
1496 	VIPS_ARG_INT( class, "tile_width", 12, 
1497 		_( "Tile width" ), 
1498 		_( "Tile width in pixels" ),
1499 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1500 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1501 		1, 8192, 254 );
1502 	VIPS_ARG_INT( class, "tile_height", 12, 
1503 		_( "Tile height" ), 
1504 		_( "Tile height in pixels" ),
1505 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1506 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1507 		1, 8192, 254 );
1508 }
1509 static void
1510 vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
1511 {
1512 	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
1513 	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
1514 	dz-&gt;overlap = 1;
1515 	dz-&gt;tile_size = 254;
1516 	dz-&gt;tile_count = 0;
1517 	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
1518 	dz-&gt;angle = VIPS_ANGLE_D0; 
1519 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
1520 	dz-&gt;compression = 0;
1521 	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
1522 	dz-&gt;skip_blanks = -1;
1523 }
1524 typedef struct _VipsForeignSaveDzFile {
1525 	VipsForeignSaveDz parent_object;
1526 	char *filename; 
1527 } VipsForeignSaveDzFile;
1528 typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;
1529 G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
1530 	vips_foreign_save_dz_get_type() );
1531 static int
1532 vips_foreign_save_dz_file_build( VipsObject *object )
1533 {
1534 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1535 	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;
1536 	char *p;
1537 	if( !vips_object_argument_isset( object, "basename" ) ) 
1538 		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
1539 	if( !vips_object_argument_isset( object, "dirname" ) ) 
1540 		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 
1541 	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
1542 		*p = '\0';
1543 	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
1544 		if( !vips_object_argument_isset( object, "container" ) ) {
1545 			if( strcasecmp( p + 1, "zip" ) == 0 )
1546 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1547 			if( strcasecmp( p + 1, "szi" ) == 0 ) 
1548 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
1549 		}
1550 		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
1551 			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
1552 			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
1553 <a name="0"></a>			*p = '\0';
1554 	}
1555 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
1556 		build( object ) )
1557 		return( -1 );
1558 	return( 0 );
1559 }
1560 static void
1561 vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
1562 {
1563 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1564 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1565 	gobject_class-&gt;set_property = vips_object_set_property;
1566 	gobject_class-&gt;get_property = vips_object_get_property;
1567 	object_class-&gt;nickname = "dzsave";
1568 	object_class-&gt;description = _( "save image to deepzoom file" );
1569 	object_class-&gt;build = vips_foreign_save_dz_file_build;
1570 	VIPS_ARG_STRING( class, "filename", 1, </b></font>
1571 		_( "Filename" ),
1572 		_( "Filename to save to" ),
1573 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1574 		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
1575 		NULL );
1576 }
1577 static void
1578 vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
1579 {
1580 }
1581 typedef struct _VipsForeignSaveDzBuffer {
1582 	VipsForeignSaveDz parent_object;
1583 	VipsArea *buf;
1584 } VipsForeignSaveDzBuffer;
1585 typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;
1586 G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
1587 	vips_foreign_save_dz_get_type() );
1588 static int
1589 vips_foreign_save_dz_buffer_build( VipsObject *object )
1590 {
1591 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1592 	void *obuf;
1593 	size_t olen;
1594 	VipsBlob *blob;
1595 	if( !vips_object_argument_isset( object, "basename" ) ) 
1596 		dz-&gt;basename = g_strdup( "untitled" ); 
1597 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
1598 		build( object ) )
1599 		return( -1 );
1600 	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );
1601 	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
1602 	if( !(obuf = g_try_malloc( olen )) ) {
1603 		vips_error( "vips_tracked", 
1604 			_( "out of memory --- size == %dMB" ), 
1605 			(int) (olen / (1024.0 * 1024.0))  );
1606 		return( -1 );
1607 	}
1608 	memcpy( obuf, 
1609 		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
1610 		olen ); 
1611 	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
1612 	g_object_set( object, "buffer", blob, NULL );
1613 	vips_area_unref( VIPS_AREA( blob ) );
1614 	return( 0 );
1615 }
1616 static void
1617 vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
1618 {
1619 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1620 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1621 	gobject_class-&gt;set_property = vips_object_set_property;
1622 	gobject_class-&gt;get_property = vips_object_get_property;
1623 	object_class-&gt;nickname = "dzsave_buffer";
1624 	object_class-&gt;description = _( "save image to dz buffer" );
1625 	object_class-&gt;build = vips_foreign_save_dz_buffer_build;
1626 	VIPS_ARG_BOXED( class, "buffer", 1, 
1627 		_( "Buffer" ),
1628 		_( "Buffer to save to" ),
1629 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1630 		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
1631 		VIPS_TYPE_BLOB );
1632 }
1633 static void
1634 vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
1635 {
1636 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;
1637 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1638 }
1639 int
1640 vips_dzsave( VipsImage *in, const char *name, ... )
1641 {
1642 	va_list ap;
1643 	int result;
1644 	va_start( ap, name );
1645 	result = vips_call_split( "dzsave", ap, in, name ); 
1646 	va_end( ap );
1647 	return( result );
1648 }
1649 int
1650 vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1651 {
1652 	va_list ap;
1653 	VipsArea *area;
1654 	int result;
1655 	area = NULL; 
1656 	va_start( ap, len );
1657 	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
1658 	va_end( ap );
1659 	if( !result &amp;&amp;
1660 		area ) { 
1661 		if( buf ) {
1662 			*buf = area-&gt;data;
1663 			area-&gt;free_fn = NULL;
1664 		}
1665 		if( len ) 
1666 			*len = area-&gt;length;
1667 		vips_area_unref( area );
1668 	}
1669 	return( result );
1670 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
