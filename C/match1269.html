<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; diffuse.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; diffuse.c
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (3.4313726%)<th>diffuse.c (1.2841419%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1691-1708)<td><a href="#" name="0">(1103-1111)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1726-1738)<td><a href="#" name="1">(1148-1160)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1796-1804)<td><a href="#" name="2">(5228-5235)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1582-1592)<td><a href="#" name="3">(2007-2018)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(642-648)<td><a href="#" name="4">(4625-4629)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;
#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"
#include "nfsim_func.h"
#include "mcell_reactions.h"
#include "diffuse.h"
#include "debug_config.h"
#include "debug.h"
#include "dump_state.h"
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB);
static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
int is_compatible_surface(void *req_species, struct wall *w) {
  struct surf_class_list *scl, *scl2;
  struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
  if (rs_head == NULL)
    return 1;
  for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
    for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
      if (scl-&gt;surf_class == scl2-&gt;surf_class)
        return 1;
    }
  }
  return 0;
}
void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
  struct abstract_molecule *reacB, struct abstract_molecule *reacC,
  struct abstract_molecule **player, char *player_type) {
  player[0] = reacA;
  player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
  if (rx-&gt;n_reactants &gt; 1) {
    if (reacB == NULL) {
      assert(rx-&gt;n_reactants == 2);
      player[1] = NULL;
      player_type[1] = PLAYER_WALL;
    } else {        player[1] = reacB;
      player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
    }
    if (rx-&gt;n_reactants &gt; 2) {
      if (reacC == NULL) {
        player[2] = NULL;
        player_type[2] = PLAYER_WALL;
      } else {
        player[2] = reacC;
        player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
      }
    }
  }
}
static bool is_rxn_unimol(struct rxn *rx) {
  if (rx-&gt;n_reactants == 1)
    return true;
  if (rx-&gt;n_reactants != 2)
    return false;
  if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
    return false;
  return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
}
void tiny_diffuse_3D(
    struct volume *world,
    struct subvolume *subvol,
    struct vector3 *displacement,
    struct vector3 *pos,
    struct wall *w) {
  struct vector3 temp_displacement = {
    displacement-&gt;x,
    displacement-&gt;y,
    displacement-&gt;z
  };
  struct collision *shead = ray_trace(
      world, pos, NULL, subvol, &amp;temp_displacement, w);
  if (shead-&gt;next != NULL) {
    shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
  }
  struct collision *smash = NULL;
  for (smash = shead; smash != NULL; smash = smash-&gt;next) {
    if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
      vectorize(pos, &amp;(smash-&gt;loc), displacement);
      scalar_prod(displacement, 0.5, displacement);
      break;
    }
  }
  pos-&gt;x += displacement-&gt;x;
  pos-&gt;y += displacement-&gt;y;
  pos-&gt;z += displacement-&gt;z;
  subvol = find_subvolume(world, pos, subvol);
}
struct volume_molecule *
place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                     struct surface_molecule *sm_reactant, struct wall *w,
                     struct subvolume *subvol, struct vector3 *hitpt,
                     short orient, double t, struct periodic_image *periodic_box) {
  struct vector3 pos = *hitpt;
  if (w) {
    double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
    struct vector3 displacement = {2 * bump * w-&gt;normal.x,
                                   2 * bump * w-&gt;normal.y,
                                   2 * bump * w-&gt;normal.z,
                                  };
    tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
  }
  struct volume_molecule *new_volume_mol;
  new_volume_mol =
      (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
  new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
  new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_volume_mol-&gt;id = world-&gt;current_mol_id++;
  new_volume_mol-&gt;t = t;
  new_volume_mol-&gt;t2 = 0.0;
  new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_volume_mol-&gt;properties = product_species;
  new_volume_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
  new_volume_mol-&gt;prev_v = NULL;
  new_volume_mol-&gt;next_v = NULL;
  new_volume_mol-&gt;pos = pos;
  new_volume_mol-&gt;subvol = subvol;
  new_volume_mol-&gt;index = 0;
  new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
  if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
    new_volume_mol-&gt;flags |= ACT_DIFFUSE;
  if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
    new_volume_mol-&gt;flags |= COUNT_ME;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_volume_mol) != NULL)
    new_volume_mol-&gt;flags |= ACT_REACT;
  if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
    new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
    new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
  }
  else {
    new_volume_mol-&gt;previous_wall = NULL;
    new_volume_mol-&gt;index = -1;
  }
  if (w) {
    if (world-&gt;surface_reversibility) {
      new_volume_mol-&gt;previous_wall = w;
      new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
      new_volume_mol-&gt;flags |= ACT_CLAMPED;
    }
  } else if (world-&gt;volume_reversibility) {
    new_volume_mol-&gt;index = world-&gt;dissociation_index;
    new_volume_mol-&gt;flags |= ACT_CLAMPED;
  }
  ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
                          new_volume_mol);
  ++new_volume_mol-&gt;subvol-&gt;mol_count;
  if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_volume_mol;
}
struct surface_molecule *
place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                 struct surface_grid *grid, int grid_index,
                 struct vector2 *mol_uv_pos, short orient, double t,
                 struct periodic_image *periodic_box) {
  struct vector3 mol_xyz_pos;
  uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
  struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
  struct surface_molecule *new_surf_mol;
  new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
  new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
  new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_surf_mol-&gt;id = world-&gt;current_mol_id++;
  new_surf_mol-&gt;t = t;
  new_surf_mol-&gt;t2 = 0.0;
  new_surf_mol-&gt;properties = product_species;
  new_surf_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
  new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
  if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
    new_surf_mol-&gt;flags |= ACT_DIFFUSE;
  if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
    new_surf_mol-&gt;flags |= COUNT_ME;
  new_surf_mol-&gt;grid = grid;
  new_surf_mol-&gt;grid_index = grid_index;
  new_surf_mol-&gt;s_pos = *mol_uv_pos;
  new_surf_mol-&gt;orient = orient;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_surf_mol) != NULL ||
      (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
    new_surf_mol-&gt;flags |= ACT_REACT;
  ++grid-&gt;n_occupied;
  if (grid-&gt;sm_list[grid_index]) {
    remove_surfmol_from_list(
        &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
  }
  grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
    grid-&gt;sm_list[grid_index], new_surf_mol);
  if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_surf_mol;
}
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB) {
#ifdef DEBUG_RXNS
  DUMP_CONDITION3(
    dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
    dump_molecule_species(reacA);
    if (reacB != nullptr) {
      mcell_log(" + ");
      dump_molecule_species(reacB);
    }
    mcell_log("\nreaction_index: %d\n", path);
    dump_rxn(rx, "", true);
  );
#endif
  bool cross_wall = false; 
  int const i0 = rx-&gt;product_idx[path]; 
  int const iN = rx-&gt;product_idx[path + 1]; 
  assert(iN &gt; i0);
  struct species **rx_players = rx-&gt;players + i0; 
  int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
  bool const is_unimol = is_rxn_unimol(rx);
  struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
  unsigned int reac_idx = UINT_MAX;
  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
  int sm_bitmask = determine_molecule_region_topology(
      world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
      &amp;rlp_head_obj_2, is_unimol);
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;
  assert(reacA != NULL);
  if (reacA-&gt;properties != rx-&gt;players[0]) {
    struct abstract_molecule *tmp_mol = reacA;
    reacA = reacB;
    reacB = tmp_mol;
    short tmp_orient = orientA;
    orientA = orientB;
    orientB = tmp_orient;
  }
  assert(reacA != NULL);
  add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
  int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
  int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
                                           rx_players[1] == NULL);
  struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
    if (sm_reactant) {
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    } else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }
    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }
    rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
    if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
      num_surface_static_reactants++;
    }
    if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
      num_surface_static_reactants++;
    }
  }
  int num_surface_products = 0;
  int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL) {
      continue;
    }
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }
  int mol_idx = INT_MAX;
  struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
  struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
    if (num_surface_products &gt; 0) {
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;tile_nbr_list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;tile_nbr_list_length);
      }
      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
        }
      }
    }
    int num_recycled_tiles = 0;
    if (replace_p1 &amp;&amp; replace_p2) {
      num_recycled_tiles = 2;
    } else if (replace_p1 || replace_p2) {
      num_recycled_tiles = 1;
    }
    if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
      return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
    }
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product] == NULL) {
        continue;
      }
      int this_geometry = rx-&gt;geometries[i0 + n_product];
      int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
      this_geometry = abs(this_geometry);
      if (this_geometry == 0) {
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      } else {
        if (this_geometry &gt; (int)rx-&gt;n_reactants) {
          product_orient[n_product] = relative_orient *
              product_orient[this_geometry - rx-&gt;n_reactants - 1];
        } else if (this_geometry == 1) {
          product_orient[n_product] = relative_orient * orientA;
        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
          product_orient[n_product] = relative_orient * orientB;
        } else {
          product_orient[n_product] = relative_orient * 1;
        }
      }
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];
          if (sm-&gt;orient != product_orient[n_product]) {
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
            }
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
              sm-&gt;t2 = 0;
            }
            sm-&gt;orient = product_orient[n_product];
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
            }
          }
        } else if (!is_unimol) {           if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }
    if (num_surface_products == 1) {
      if (is_unimol &amp;&amp; replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
             (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
<a name="4"></a>            break;
          }
        }
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
          &amp;&amp; (replace_p1 || replace_p2)) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
              distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {</b></font>
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            }
            break;
          }
        }
      } else if (replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if (replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) |
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            break;
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      if (num_surface_static_reactants &gt; 0) {
        bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
        bool replace_reacB =
            (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
        if (replace_reacA || replace_reacB) {
          int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
            ? num_surface_static_products : num_surface_static_reactants;
          int count = 0;
          while (count &lt; max_static_count) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
                distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
              continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_reacA) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
                replace_reacA = 0;
              } else if (replace_reacB) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                count++;
                replace_p2 = 0;
                replace_reacB = 0;
              }
            }
          }         }
      }
      if (replace_p1 || replace_p2) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            surf_prod_left++;
          }
        }
        if (replace_p1) {
          surf_reactant_left++;
        }
        if (replace_p2) {
          surf_reactant_left++;
        }
        if (surf_prod_left &gt; 0) {
          int num_to_place = surf_prod_left;
          if (surf_prod_left &gt;= surf_reactant_left) {
            num_to_place = surf_reactant_left;
          }
          int count = 0;
          while (count &lt; num_to_place) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
             continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
              } else if (replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
              }
            }
          }         }
      }
    }
    if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
      assert(!IS_SURF_MOL(reacA));
      assert(rxn_uv_idx != -1);
      while (true) {
        unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
        if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
            (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
          continue;
        }
        if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
          product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
          product_grid[rnd_num] = w-&gt;grid;
          product_grid_idx[rnd_num] = rxn_uv_idx;
          break;
        }
      }
    }
    if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
      reac_idx = sm_reactant-&gt;grid_index;
      reac_grid = sm_reactant-&gt;grid;
    }
    int do_it_once = 0;     int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
          continue;
        }
        if (num_vacant_tiles == 0) {
          return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
        }
        num_attempts = 0;
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          int tile_idx = -1;           tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          if (tile_idx &lt; 0) {
            continue;           }
          assert(tile_grid != NULL);
          if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
            rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
            uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
            num_attempts++;
            continue;
          }
          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
            mol_idx = tile_idx;
            mol_grid = tile_grid;
            do_it_once = 1;
          }
          break;
        }       }
    }
  } 
  struct vector3 count_pos_xyz;
  struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
  if (hitpt != NULL) {
    count_pos_xyz = *hitpt;
  } else if (sm_reactant) {
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  } else {
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
  }
  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  bool update_dissociation_index = false; 
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    struct graph_data* g_data = NULL;
    if (rx-&gt;product_graph_data != NULL)
      g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:
          if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
            if (mol_grid == NULL) {
              mcell_internal_error("Error in surface product placement for the "
                                   "unimolecular reaction.");
            }
            find_closest_position(product_grid[n_product], product_grid_idx[n_product],
              mol_grid, mol_idx, &amp;prod_uv_pos);
          } else {
            prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          }
          break;
        case PRODUCT_FLAG_USE_REACB_UV:
          assert(reacB != NULL);
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_UV_LOC:
          prod_uv_pos = rxn_uv_pos;
          break;
        case PRODUCT_FLAG_USE_RANDOM:
          if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
            find_closest_position(product_grid[n_product],
                                  product_grid_idx[n_product], reac_grid,
                                  reac_idx, &amp;prod_uv_pos);
          } else {
            grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                           &amp;prod_uv_pos, world-&gt;rng);
          }
          break;
        default:
          UNHANDLED_CASE(product_flag[n_product]);
        }
      } else {
        grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
      }
      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, g_data, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
          dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 w, &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
        } else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else if (product_subvol == NULL) {
        product_subvol = find_subvolume(world, hitpt, NULL);
      }
      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
      		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }
    if(rx-&gt;product_graph_data != NULL){
      this_product-&gt;graph_data = g_data;
    }
    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
#ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
    if (is_unimol &amp;&amp; (n_players == 1)) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--;       continue;
    }
    if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--;       continue;
    }
#endif
  }
  if (update_dissociation_index) {
    ASSERT_FOR_MCELL4(false);
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }
  if (rx-&gt;info[path].pathname != NULL) {
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,
                                &amp;count_pos_xyz, w, t, periodic_box);
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }
  delete_tile_neighbor_list(tile_nbr_head);
  delete_tile_neighbor_list(tile_vacant_nbr_head);
  delete_region_list(rlp_head_wall_1);
  delete_region_list(rlp_head_wall_2);
  delete_region_list(rlp_head_obj_1);
  delete_region_list(rlp_head_obj_2);
  return cross_wall ? RX_FLIP : RX_A_OK;
}
int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reac, double t) {
  struct species *who_was_i = reac-&gt;properties;
  int result = RX_A_OK;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    vm = (struct volume_molecule *)reac;
    if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
#if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
        outcome_nfsim(world, rx, path, reac, NULL, t);
      }
#else
      outcome_nfsim(world, rx, path, reac, NULL, t);
#endif
    }
    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
                                       NULL, 0, 0);
  } else {
    sm = (struct surface_molecule *)reac;
      if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
          (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
      } else {
        if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          outcome_nfsim(world, rx, path, reac, NULL, t);
        }
        result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
                                         path, reac, NULL, sm-&gt;orient, 0);
      }
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  if (result != RX_BLOCKED) {
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if(rx-&gt;product_graph_data != NULL){
      logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
    }
  }
  struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
  if (who_am_i == NULL) {
    if (vm != NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE)
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
      }
    } else {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
      );
#endif
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
                                  -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
      }
    }
    free(reac-&gt;periodic_box);
    who_was_i-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
    who_was_i-&gt;population--;
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else {
      reac-&gt;properties = NULL;
      mem_put(reac-&gt;birthplace, reac);
    }
    return RX_DESTROY;
  } else if (who_am_i != who_was_i) {
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else
      reac-&gt;properties = NULL;
    return RX_DESTROY;
  } else
    return result;
}
int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
                        struct abstract_molecule *reacA,
                        struct abstract_molecule *reacB, short orientA,
                        short orientB, double t, struct vector3 *hitpt,
                        struct vector3 *loc_okay) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_outcome_bimolecular_timing(t);
  );
#endif
  assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
  struct surface_molecule *sm = NULL;
  struct volume_molecule *vm = NULL;
  struct wall *w = NULL;
  int result;
  int reacB_was_free = 0;
  int killA, killB;
  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      w = sm-&gt;grid-&gt;surface;
    }
  } else {     sm = (struct surface_molecule *)reacA;
    w = sm-&gt;grid-&gt;surface;
  }
  if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    result = outcome_nfsim(world, rx, path, reacA, reacB, t);
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  else {
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if(rx-&gt;product_graph_data != NULL){
    logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
  }
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
  } else {
    killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
  }
  if (killB) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif
    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      reacB_was_free = 1;
    }
    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
    }
    free(reacB-&gt;periodic_box);
    reacB-&gt;periodic_box = NULL;
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacB-&gt;properties = NULL;
  }
  if (killA) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif
    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0)     {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK)       {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);
      }
    } else if (reacA-&gt;flags &amp; COUNT_ME) {
      if (hitpt == NULL || reacB_was_free ||
          (reacB-&gt;properties != NULL &amp;&amp;
           (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
      {
        struct vector3 fake_hitpt;
        vm = (struct volume_molecule *)reacA;
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);
      }
    }
    free(reacA-&gt;periodic_box);
    reacA-&gt;periodic_box = NULL;
    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;
    return RX_DESTROY;
  }
  return result;
}
int outcome_intersect(struct volume *world, struct rxn *rx, int path,
                      struct wall *surface, struct abstract_molecule *reac,
                      short orient, double t, struct vector3 *hitpt,
                      struct vector3 *loc_okay) {
  if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
    rx-&gt;n_occurred++;
    if (rx-&gt;n_pathways == RX_REFLEC)
      return RX_A_OK;
    else
      return RX_FLIP;   }
  int idx = rx-&gt;product_idx[path];
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    struct volume_molecule *vm = (struct volume_molecule *)reac;
    int result;
    if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
        (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
      result = RX_DESTROY;
    } else {
      result = outcome_products_random(world, surface, hitpt, t, rx, path,
                                       reac, NULL, orient, 0);
    }
    if (result == RX_BLOCKED)
      return RX_A_OK; 
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if (rx-&gt;players[idx] == NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
        if (hitpt == NULL) {
          count_region_from_scratch(
            world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
        } else {
          struct vector3 fake_hitpt;
          if (loc_okay == NULL)
            loc_okay = &amp;(vm-&gt;pos);
          fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
          fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
          fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
          count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
                                    t, reac-&gt;periodic_box);
        }
      }
      free(reac-&gt;periodic_box);
      reac-&gt;properties-&gt;n_deceased++;
      double t_time = convert_iterations_to_seconds(
          world-&gt;start_iterations, world-&gt;time_unit,
          world-&gt;simulation_start_seconds, t);
      reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
      reac-&gt;properties-&gt;population--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
         dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
      );
#endif
      collect_molecule(vm);
      return RX_DESTROY;
    } else
      return result;   } else {
    return RX_A_OK;
  }
}
int reaction_wizardry(struct volume *world, struct magic_list *incantation,
                      struct wall *surface, struct vector3 *hitpt, double t) {
  struct release_event_queue req; 
  req.next = NULL;
  req.event_time = t;
  req.train_counter = 0;
  req.train_high_time = t;
  if (hitpt == NULL) {
    init_matrix(req.t_matrix);
  } else if (surface == NULL ||
             !distinguishable(surface-&gt;normal.z, 1.0,
                              EPS_C))   {
    init_matrix(req.t_matrix);
    req.t_matrix[3][0] = hitpt-&gt;x;
    req.t_matrix[3][1] = hitpt-&gt;y;
    req.t_matrix[3][2] = hitpt-&gt;z;
  {
    struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };  <a name="3"></a>    double cos_theta;
    double degrees;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
      degrees = 180.0;     } else {
      axis.x = -surface-&gt;normal.y;
      axis.y = surface-&gt;normal.x;
      axis.z = 0.0;
      degrees = acos(cos_theta) * 180.0 / MY_PI;
    }</b></font>
    tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
  }
  for (; incantation != NULL; incantation = incantation-&gt;next) {
    if (incantation-&gt;type != magic_release)
      continue; 
    req.release_site = (struct release_site_obj *)incantation-&gt;data;
    if (release_molecules(world, &amp;req))
      return 1;
  }
  return 0;
}
int determine_molecule_region_topology(
    struct volume *world, struct surface_molecule *sm_1,
    struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
    struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
  int sm_bitmask = 0;
  struct wall *w_1, *w_2;
  struct region_list *rlp_head_wall_1 = NULL;
  struct region_list *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL;
  struct region_list *rlp_head_obj_2 = NULL;
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        sm_bitmask |= ALL_INSIDE;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= ALL_OUTSIDE;
      }
      else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF1_IN_SURF2_OUT;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT_SURF2_IN;
      }
    }
    else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
             (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
<a name="0"></a>      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= SURF1_IN;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT;
      }
    }
    else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
             (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL) {</b></font>
        sm_bitmask |= SURF2_IN;
      } else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF2_OUT;
      }
    }
  }
  else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
<a name="1"></a>      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= ALL_INSIDE;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= ALL_OUTSIDE;
      }
    }
  }
  *rlp_wall_1_ptr = rlp_head_wall_1;
  *rlp_wall_2_ptr = rlp_head_wall_2;
  *rlp_obj_1_ptr = rlp_head_obj_1;
  *rlp_obj_2_ptr = rlp_head_obj_2;</b></font>
  return sm_bitmask;
}
bool product_tile_can_be_reached(struct wall *target,
                                 struct region_list *rlp_head_wall_1,
                                 struct region_list *rlp_head_wall_2,
                                 struct region_list *rlp_head_obj_1,
                                 struct region_list *rlp_head_obj_2,
                                 int sm_bitmask, bool is_unimol) {
  bool status = true;
  if (sm_bitmask &amp; ALL_INSIDE) {
    if (is_unimol) {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1)) {
        status = false;
      }
    } else {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1) ||
          !wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; ALL_OUTSIDE) {
    if (is_unimol) {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
        status = false;
      }
    } else {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
          wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
        status = false;
      }
<a name="2"></a>    }
  } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
        !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_IN) {</b></font>
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  }
  return status;
}
int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
  if (tn1 != NULL) {
    delete_tile_neighbor_list(tn1);
  }
  if (tn2 != NULL) {
    delete_tile_neighbor_list(tn2);
  }
  return RX_BLOCKED;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>diffuse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "diffuse.h"
#include "logging.h"
#include "mcell_structs.h"
#include "count_util.h"
#include "grid_util.h"
#include "vol_util.h"
#include "wall_util.h"
#include "react.h"
#include "react_nfsim.h"
#include "nfsim_func.h"
#include "debug_config.h"
#include "debug.h"
#include "dump_state.h"
#ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
#include &lt;vector&gt;
#endif
#define FREE_COLLISION_LISTS()                                                 \
  do {                                                                         \
    if (shead2 != NULL)                                                        \
      mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);                           \
    if (shead != NULL)                                                         \
      mem_put_list(sv-&gt;local_storage-&gt;coll, shead);                            \
  } while (0)
static const int inert_to_mol = 1;
static const int inert_to_all = 2;
int move_sm_on_same_triangle(
    struct volume *state,
    struct surface_molecule *sm,
    struct vector2 *new_loc,
    struct periodic_image *previous_box,
    struct wall *new_wall,
    struct hit_data *hd_info);
static void redo_collision_list(struct volume* world, struct collision** shead,
  struct collision** stail, struct collision** shead_exp,
  struct volume_molecule* m, struct vector3* displacement, struct subvolume* sv);
static int collide_and_react_with_vol_mol(
  struct volume* world, struct collision* smash, struct volume_molecule* vm,
  struct collision** tentative, struct vector3* displacement,
  struct vector3* loc_certain, double t_steps, double r_rate_factor);
static int collide_and_react_with_surf_mol(
  struct volume* world, struct collision* smash, struct volume_molecule* vm,
  struct collision** tentative, struct vector3** loc_certain, double t_steps,
  int mol_grid_flag, int mol_mol_grid_flag, double r_rate_factor);
static int collide_and_react_with_walls(
  struct volume* world, struct collision* smash, struct volume_molecule* vm,
  struct collision** tentative, struct vector3** loc_certain, double t_steps,
  int inertness, double r_rate_factor);
static int reflect_or_periodic_bc(
  struct volume* world, struct collision* smash, struct vector3* displacement,
  struct volume_molecule** mol, struct wall** reflectee,
  struct collision** tentative, double* t_steps);
static void reflect_absorb_inside_out(
    struct volume *world, struct surface_molecule *sm, struct hit_data *hd_head,
    struct rxn **rx, struct rxn *matching_rxns[], struct vector2 boundary_pos,
    struct wall *this_wall, int index_edge_was_hit, int *reflect_now,
    int *absorb_now, int *this_wall_edge_region_border);
int reflect_absorb_outside_in( 
    struct volume *world,
    struct surface_molecule *sm,
    struct hit_data **hd_head,
    struct rxn **rx,
    struct rxn *matching_rxns[],
    struct vector2 boundary_pos,
    struct wall *target_wall,
    struct wall *this_wall,
    int *reflect_now,
    int *absorb_now,
    int this_wall_edge_region_border);
void collide_and_react_with_subvol(
  struct volume* world, struct collision *smash, struct vector3* displacement,
  struct volume_molecule** mol, struct collision** tentative, double* t_steps);
void compute_displacement(
  struct volume* world, struct collision* shead, struct volume_molecule* vm,
  struct vector3* displacement, struct vector3* displacement2,
  double* rate_factor, double* r_rate_factor, double* steps, double* t_steps,
  double max_time);
void determine_mol_mol_reactions(
  struct volume* world, struct volume_molecule* vm, struct collision** shead,
  struct collision** stail, int interness);
void set_inertness_and_maxtime(
  struct volume* world, struct volume_molecule* vm, double* maxtime,
  int* inertness);
void register_hits(
  struct volume* world, struct volume_molecule* m,
  struct collision** tentative, struct wall** reflect_w, double* reflect_t,
  struct vector3* displacement, struct collision* smash, double* t_steps);
void count_tentative_collisions(
  struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
  struct species *spec, double t_confident, int destroy_flag,
  struct periodic_image *box, u_long id);
void change_boxes_2D(
    bool periodic_traditional,
    struct surface_molecule *sm,
    struct geom_object *periodic_box_obj,
    struct vector3 *hit_xyz,
    struct vector3 *teleport_xyz);
void pick_2D_displacement(struct vector2 *v, double scale,
                          struct rng_state *rng) {
  static const double one_over_2_to_16th = 1.52587890625e-5;
  struct vector2 a;
  double f;
  do {
    unsigned int n = rng_uint(rng);
    a.u = 2.0 * one_over_2_to_16th * (n &amp; 0xFFFF) - 1.0;
    a.v = 2.0 * one_over_2_to_16th * (n &gt;&gt; 16) - 1.0;
    f = a.u * a.u + a.v * a.v;
  } while ((f &lt; EPS_C) || (f &gt; 1.0));
  double normalFactor = sqrt(-log(f) / f);
  v-&gt;u = a.u * normalFactor * scale;
  v-&gt;v = a.v * normalFactor * scale;
}
void pick_clamped_displacement(struct vector3 *v, struct volume_molecule *vm,
                               double *r_step_surface, struct rng_state *rng,
                               u_int radial_subdivisions) {
  static const double one_over_2_to_20th = 9.5367431640625e-7;
  struct wall *w = vm-&gt;previous_wall;
  unsigned int n = rng_uint(rng);
  double r_n = r_step_surface[n &amp; (radial_subdivisions - 1)];
  double p = one_over_2_to_20th * ((n &gt;&gt; 12) + 0.5);
  double t = r_n / erfcinv(p * erfc(r_n));
  struct vector2 r_uv;
  pick_2D_displacement(&amp;r_uv, sqrt(t) * vm-&gt;get_space_step(vm), rng);
  r_n *= vm-&gt;index * vm-&gt;get_space_step(vm);
  v-&gt;x = r_n * w-&gt;normal.x + r_uv.u * w-&gt;unit_u.x + r_uv.v * w-&gt;unit_v.x;
  v-&gt;y = r_n * w-&gt;normal.y + r_uv.u * w-&gt;unit_u.y + r_uv.v * w-&gt;unit_v.y;
  v-&gt;z = r_n * w-&gt;normal.z + r_uv.u * w-&gt;unit_u.z + r_uv.v * w-&gt;unit_v.z;
}
void pick_release_displacement(struct vector3 *in_disk, struct vector3 *away,
                               double scale, double *r_step_release,
                               double *d_step, u_int radial_subdivisions,
                               int directions_mask, u_int num_directions,
                               double rx_radius_3d, struct rng_state *rng) {
  static const double one_over_2_to_16th = 1.52587890625e-5;
  struct vector2 disk;
  struct vector3 orth, axo;
  u_int bits = rng_uint(rng);
  u_int x_bit = (bits &amp; 0x80000000);
  u_int y_bit = (bits &amp; 0x40000000);
  u_int z_bit = (bits &amp; 0x20000000);
  u_int thetaphi_bits = (bits &amp; 0x1FFFF000) &gt;&gt; 12;
  u_int r_bits = (bits &amp; 0x00000FFF);
  double r = scale * r_step_release[r_bits &amp; (radial_subdivisions - 1)];
  u_int idx = thetaphi_bits &amp; directions_mask;
  while (idx &gt;= num_directions) {
    idx = rng_uint(rng) &amp; directions_mask;
  }
  if (x_bit)
    away-&gt;x = d_step[idx];
  else
    away-&gt;x = -d_step[idx];
  if (y_bit)
    away-&gt;y = d_step[idx + 1];
  else
    away-&gt;y = -d_step[idx + 1];
  if (z_bit)
    away-&gt;z = d_step[idx + 2];
  else
    away-&gt;z = -d_step[idx + 2];
  if (d_step[idx] &lt; d_step[idx + 1]) {
    if (d_step[idx] &lt; d_step[idx + 2]) {
      orth.x = 0;
      orth.y = away-&gt;z;
      orth.z = -away-&gt;y;
    } else {
      orth.x = away-&gt;y;
      orth.y = -away-&gt;x;
      orth.z = 0;
    }
  } else if (d_step[idx + 1] &lt; d_step[idx + 2]) {
    orth.x = away-&gt;z;
    orth.y = 0;
    orth.z = -away-&gt;x;
  } else {
    orth.x = away-&gt;y;
    orth.y = -away-&gt;x;
    orth.z = 0;
  }
  normalize(&amp;orth);
  cross_prod(away, &amp;orth, &amp;axo);
  double f;
  do {
    bits = rng_uint(rng);
    disk.u = 2.0 * one_over_2_to_16th * (bits &amp; 0xFFFF) - 1.0;
    disk.v = 2.0 * one_over_2_to_16th * (bits &gt;&gt; 16) - 1.0;
    f = disk.u * disk.u + disk.v * disk.v;
  } while (f &lt; 0.01 || f &gt; 1.0);
  in_disk-&gt;x = (disk.u * orth.x + disk.v * axo.x) * rx_radius_3d;
  in_disk-&gt;y = (disk.u * orth.y + disk.v * axo.y) * rx_radius_3d;
  in_disk-&gt;z = (disk.u * orth.z + disk.v * axo.z) * rx_radius_3d;
  away-&gt;x *= r;
  away-&gt;y *= r;
  away-&gt;z *= r;
}
void pick_displacement(struct vector3 *v, double scale, struct rng_state *rng) {
  v-&gt;x = scale * rng_gauss(rng) * .70710678118654752440;
  v-&gt;y = scale * rng_gauss(rng) * .70710678118654752440;
  v-&gt;z = scale * rng_gauss(rng) * .70710678118654752440;
}
struct vector3* reflect_periodic_2D(
    struct volume *state,
    int index_edge_was_hit,
    struct vector2 *origin_uv,
    struct wall *curr_wall,
    struct vector2 *disp_uv,
    struct vector2 *boundary_uv,
    struct vector3 *origin_xyz) {
  struct vector3 target_xyz;
  struct vector2 target_uv = {
    origin_uv-&gt;u + disp_uv-&gt;u,
    origin_uv-&gt;v + disp_uv-&gt;v
  };
  if (index_edge_was_hit == -1) {
    uv2xyz(&amp;target_uv, curr_wall, &amp;target_xyz);
  }
  else if (index_edge_was_hit == 0 || 
           index_edge_was_hit == 1 ||
           index_edge_was_hit == 2) {
    uv2xyz(boundary_uv, curr_wall, &amp;target_xyz);
  }
  else {
    return NULL;
  }
  struct vector3 delta_xyz = {target_xyz.x - origin_xyz-&gt;x,
                              target_xyz.y - origin_xyz-&gt;y,
                              target_xyz.z - origin_xyz-&gt;z};
  struct vector3 updated_xyz = *origin_xyz;
  for (struct subvolume *sv = find_subvolume(state, origin_xyz, NULL);
       sv != NULL; sv = next_subvol(
          &amp;updated_xyz, &amp;delta_xyz, sv, state-&gt;x_fineparts, state-&gt;y_fineparts,
          state-&gt;z_fineparts, state-&gt;ny_parts,
          state-&gt;nz_parts)) {
    for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
      if (wl-&gt;this_wall-&gt;parent_object != state-&gt;periodic_box_obj) {
        continue;
      }
      struct vector3 *hit_xyz = (struct vector3 *)malloc(sizeof(*hit_xyz));
      double t = 0.0;
      int i = collide_wall(
          &amp;updated_xyz, &amp;delta_xyz, wl-&gt;this_wall, &amp;t, hit_xyz, 0, state-&gt;rng,
          state-&gt;notify, &amp;(state-&gt;ray_polygon_tests));
      if (i != COLLIDE_MISS &amp;&amp;
          (hit_xyz-&gt;x - target_xyz.x) * delta_xyz.x +
          (hit_xyz-&gt;y - target_xyz.y) * delta_xyz.y +
          (hit_xyz-&gt;z - target_xyz.z) * delta_xyz.z &lt; 0) {
        if (!state-&gt;periodic_traditional) {
          struct vector2 hit_uv;
          xyz2uv(hit_xyz, curr_wall, &amp;hit_uv);
          disp_uv-&gt;u = -(target_uv.u-hit_uv.u);
          disp_uv-&gt;v = -(target_uv.v-hit_uv.v);
          origin_uv-&gt;u = hit_uv.u;
          origin_uv-&gt;v = hit_uv.v;
        }
        return hit_xyz;
      }
      free(hit_xyz);
    }
  }
  return NULL;
}
void change_boxes_2D(
    bool periodic_traditional,
    struct surface_molecule *sm,
    struct geom_object *periodic_box_obj,
    struct vector3 *hit_xyz,
    struct vector3 *teleport_xyz) {
  assert(periodic_box_obj-&gt;object_type == BOX_OBJ);
  struct polygon_object* p = (struct polygon_object*)(periodic_box_obj-&gt;contents);
  struct subdivided_box* sb = p-&gt;sb;
  double llx = sb-&gt;x[0];
  double urx = sb-&gt;x[1];
  double lly = sb-&gt;y[0];
  double ury = sb-&gt;y[1];
  double llz = sb-&gt;z[0];
  double urz = sb-&gt;z[1];
  int x_inc = (sm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
  int y_inc = (sm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
  int z_inc = (sm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
  int box_inc_x = 0;
  int box_inc_y = 0;
  int box_inc_z = 0;
  double x_pos = 0;
  double y_pos = 0;
  double z_pos = 0;
  if (!distinguishable(hit_xyz-&gt;x, llx, EPS_C)) {
    x_pos = urx - EPS_C;
    box_inc_x = -x_inc;
  } else if (!distinguishable(hit_xyz-&gt;x, urx, EPS_C)) {
    x_pos = llx + EPS_C;
    box_inc_x = x_inc;
  }
  if (periodic_traditional &amp;&amp; x_pos) {
    teleport_xyz-&gt;x = x_pos;
  }
  if (!distinguishable(hit_xyz-&gt;y, lly, EPS_C)) {
    y_pos = ury - EPS_C;
    box_inc_y = -y_inc;
  } else if (!distinguishable(hit_xyz-&gt;y, ury, EPS_C)) {
    y_pos = lly + EPS_C;
    box_inc_y = y_inc;
  }
  if (periodic_traditional &amp;&amp; y_pos) {
    teleport_xyz-&gt;y = y_pos;
  }
  if (!distinguishable(hit_xyz-&gt;z, llz, EPS_C)) {
    z_pos = urz - EPS_C;
    box_inc_z = -z_inc;
  } else if (!distinguishable(hit_xyz-&gt;z, urz, EPS_C)) {
    z_pos = llz + EPS_C;
    box_inc_z = z_inc;
  }
  if (periodic_traditional &amp;&amp; z_pos) {
    teleport_xyz-&gt;z = z_pos;
  }
  if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
    sm-&gt;periodic_box-&gt;x += box_inc_x;
    sm-&gt;periodic_box-&gt;y += box_inc_y;
    sm-&gt;periodic_box-&gt;z += box_inc_z;
  }
}
void reflect_absorb_inside_out(
    struct volume *world,
    struct surface_molecule *sm,
    struct hit_data *hd_head,
    struct rxn **rx,
    struct rxn *matching_rxns[],
    struct vector2 boundary_pos,
    struct wall *this_wall,
    int index_edge_was_hit,
    int *reflect_now,
    int *absorb_now,
    int *this_wall_edge_region_border) {
  struct edge *this_edge = this_wall-&gt;edges[index_edge_was_hit];
  if (is_wall_edge_region_border(this_wall, this_edge)) {
    *this_wall_edge_region_border = 1;
  }
  struct wall *nbr_wall = NULL;
  int nbr_edge_ind = -1;
  find_neighbor_wall_and_edge(this_wall, index_edge_was_hit, &amp;nbr_wall, &amp;nbr_edge_ind);
  int nbr_wall_edge_region_border = 0;
  if (nbr_wall != NULL) {
    if (is_wall_edge_region_border(nbr_wall, nbr_wall-&gt;edges[nbr_edge_ind])) {
      nbr_wall_edge_region_border = 1;
    }
  }
  if (is_wall_edge_restricted_region_border(world, this_wall, this_edge, sm)) {
    int num_matching_rxns = trigger_intersect(
        world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
        world-&gt;all_volume_mols, world-&gt;all_surface_mols,
        sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm, sm-&gt;orient,
        this_wall, matching_rxns, 1, 1, 1);
    for (int i = 0; i &lt; num_matching_rxns; i++) {
      *rx = matching_rxns[i];
      if ((*rx)-&gt;n_pathways == RX_REFLEC) {
        *reflect_now = 1;
        break;
      } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
        *absorb_now = 1;
        break;
      }
    }
    if (reflect_now || absorb_now) {
      if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
        update_hit_data(&amp;hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
      }
      if (nbr_wall != NULL &amp;&amp; nbr_wall_edge_region_border) {
        if (nbr_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
          update_hit_data(&amp;hd_head, this_wall, nbr_wall, sm, boundary_pos, 0, 0);
        }
      }
    }
  }
}
int reflect_absorb_outside_in( 
    struct volume *world,
    struct surface_molecule *sm,
    struct hit_data **hd_head,
    struct rxn **rx,
    struct rxn *matching_rxns[],
    struct vector2 boundary_pos,
    struct wall *target_wall,
    struct wall *this_wall,
    int *reflect_now,
    int *absorb_now,
    int this_wall_edge_region_border) {
  int target_edge_ind = find_shared_edge_index_of_neighbor_wall(this_wall, target_wall);
  int target_wall_edge_region_border = 0;
  if (is_wall_edge_region_border(target_wall, target_wall-&gt;edges[target_edge_ind])) {
    target_wall_edge_region_border = 1;
  }
  if (is_wall_edge_restricted_region_border(world, target_wall, target_wall-&gt;edges[target_edge_ind], sm)) {
    *reflect_now = 0;
    *absorb_now = 0;
    int num_matching_rxns = trigger_intersect(
        world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
        world-&gt;all_volume_mols, world-&gt;all_surface_mols,
        sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
        sm-&gt;orient, target_wall, matching_rxns, 1, 1, 1);
    for (int i = 0; i &lt; num_matching_rxns; i++) {
      *rx = matching_rxns[i];
      if ((*rx)-&gt;n_pathways == RX_REFLEC) {
        *reflect_now = 1;
        break;
      } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
        *absorb_now = 1;
        break;
      }
    }
    if (*reflect_now || *absorb_now) {
      if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
        update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 0);
        update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
      }
    }
    if (*reflect_now || *absorb_now) {
      return 1; 
    }
  }
  if (this_wall_edge_region_border) {
    if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
      update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 1);
    }
  }
  if (target_wall_edge_region_border) {
    if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
      update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 1);
    }
  }
  return 0;
}
struct wall *ray_trace_2D(
    struct volume *world,
    struct surface_molecule *sm,
    struct vector2 *disp,
    struct vector2 *pos,
    int *kill_me,
    struct rxn **rxp,
    struct hit_data **hit_data_info) {
  struct hit_data *hit_data_head = NULL;
  struct wall *this_wall = sm-&gt;grid-&gt;surface;
  struct vector2 orig_pos = { sm-&gt;s_pos.u,
                              sm-&gt;s_pos.v
                            };
  struct vector2 this_pos = { sm-&gt;s_pos.u,
                             sm-&gt;s_pos.v
                            };
  struct vector2 this_disp = { disp-&gt;u,
                              disp-&gt;v
                             };
  struct periodic_image orig_box = {sm-&gt;periodic_box-&gt;x,
                                    sm-&gt;periodic_box-&gt;y,
                                    sm-&gt;periodic_box-&gt;z
                                   };
  struct vector3 origin_xyz;
  uv2xyz(&amp;this_pos, this_wall, &amp;origin_xyz);
  struct rxn *rx = NULL;
  while (1) {
    int this_wall_edge_region_border = 0;
    int absorb_now = 0;
    int reflect_now = 0;
    struct vector2 boundary_pos;
    int index_edge_was_hit =
        find_edge_point(this_wall, &amp;this_pos, &amp;this_disp, &amp;boundary_pos);
    if (world-&gt;periodic_box_obj) {
      struct vector3 *hit_xyz = reflect_periodic_2D(
          world,
          index_edge_was_hit,
          &amp;this_pos,
          this_wall,
          &amp;this_disp,
          &amp;boundary_pos,
          &amp;origin_xyz);
      if (hit_xyz) {
        struct vector3 teleport_xyz = {hit_xyz-&gt;x,
                                       hit_xyz-&gt;y,
                                       hit_xyz-&gt;z
                                      };
        change_boxes_2D(
          world-&gt;periodic_traditional, sm, world-&gt;periodic_box_obj, hit_xyz,
          &amp;teleport_xyz);
        if (world-&gt;periodic_traditional) {
          struct vector2 target_uv = { this_pos.u + this_disp.u,
                                      this_pos.v + this_disp.v
                                     };
          struct vector3 target_xyz;
          uv2xyz(&amp;target_uv, this_wall, &amp;target_xyz);
          struct vector3 remaining_disp_xyz = {target_xyz.x - hit_xyz-&gt;x,
                                               target_xyz.y - hit_xyz-&gt;y,
                                               target_xyz.z - hit_xyz-&gt;z
                                              };
          struct vector3 new_target_xyz = {teleport_xyz.x + remaining_disp_xyz.x,
                                           teleport_xyz.y + remaining_disp_xyz.y,
                                           teleport_xyz.z + remaining_disp_xyz.z,
                                          };
          int grid_index = 0;
          int *grid_index_p = &amp;grid_index;
          struct wall *prev_wall = this_wall;
          this_wall = find_closest_wall(
            world, &amp;teleport_xyz, 0.0, &amp;this_pos, grid_index_p, sm-&gt;properties, NULL, NULL, NULL);
          if ((this_wall == NULL) ||
              (this_wall-&gt;parent_object != prev_wall-&gt;parent_object) ) {
            *hit_data_info = hit_data_head;
            free(hit_xyz);
            return NULL;
          }
          struct vector2 new_target_uv;
          xyz2uv(&amp;new_target_xyz, this_wall, &amp;new_target_uv);
          this_disp.u = new_target_uv.u - this_pos.u;
          this_disp.v = new_target_uv.v - this_pos.v;
        }
        else {
          origin_xyz.x = hit_xyz-&gt;x;
          origin_xyz.y = hit_xyz-&gt;y;
          origin_xyz.z = hit_xyz-&gt;z;
        }
        free(hit_xyz);
        continue;
      }
    }
    if (index_edge_was_hit == -2) {
      sm-&gt;s_pos.u = orig_pos.u;
      sm-&gt;s_pos.v = orig_pos.v;
      sm-&gt;periodic_box-&gt;x = orig_box.x;
      sm-&gt;periodic_box-&gt;y = orig_box.y;
      sm-&gt;periodic_box-&gt;z = orig_box.z;
      *hit_data_info = hit_data_head;
      return NULL;
    }
    else if (index_edge_was_hit == -1) {
      pos-&gt;u = this_pos.u + this_disp.u;
      pos-&gt;v = this_pos.v + this_disp.v;
      sm-&gt;s_pos.u = orig_pos.u;
      sm-&gt;s_pos.v = orig_pos.v;
      *hit_data_info = hit_data_head;
      return this_wall;
    }
    struct vector2 old_pos = {this_pos.u,
                             this_pos.v
                             };
    struct rxn *matching_rxns[MAX_MATCHING_RXNS];
    if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
      reflect_absorb_inside_out(
          world, sm, hit_data_head, &amp;rx, matching_rxns, boundary_pos, this_wall,
          index_edge_was_hit, &amp;reflect_now, &amp;absorb_now,
          &amp;this_wall_edge_region_border);
      if (absorb_now) {
        *kill_me = 1;
        *rxp = rx;
        *hit_data_info = hit_data_head;
        return NULL;
      }
    }
    struct vector2 new_disp;
    if (!reflect_now) {
      struct wall *target_wall =
          traverse_surface(this_wall, &amp;old_pos, index_edge_was_hit, &amp;this_pos);
      if (target_wall != NULL) {
        if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
          if (reflect_absorb_outside_in(
              world, sm, &amp;hit_data_head, &amp;rx, matching_rxns, boundary_pos,
              target_wall, this_wall, &amp;reflect_now, &amp;absorb_now,
              this_wall_edge_region_border)) {
            if (absorb_now) {
              *kill_me = 1;
              *rxp = rx;
              *hit_data_info = hit_data_head;
              return NULL;
            }
          }
        }
        if (!reflect_now) {
          this_disp.u = old_pos.u + this_disp.u;
          this_disp.v = old_pos.v + this_disp.v;
          traverse_surface(this_wall, &amp;this_disp, index_edge_was_hit, &amp;new_disp);
          this_disp.u = new_disp.u - this_pos.u;
          this_disp.v = new_disp.v - this_pos.v;
          this_wall = target_wall;
          continue;
        }
      }
    }
    if (!reflect_now) {
      *hit_data_info = hit_data_head;
    }
    new_disp.u = this_disp.u - (boundary_pos.u - old_pos.u);
    new_disp.v = this_disp.v - (boundary_pos.v - old_pos.v);
    double f;
    struct vector2 reflector;
    switch (index_edge_was_hit) {
    case 0:
      new_disp.v *= -1.0;
      break;
    case 1:
      reflector.u = -this_wall-&gt;uv_vert2.v;
      reflector.v = this_wall-&gt;uv_vert2.u - this_wall-&gt;uv_vert1_u;
      f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
      reflector.u *= f;
      reflector.v *= f;
      f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
      new_disp.u -= f * reflector.u;
      new_disp.v -= f * reflector.v;
      break;
    case 2:
      reflector.u = this_wall-&gt;uv_vert2.v;
      reflector.v = -this_wall-&gt;uv_vert2.u;
      f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
      reflector.u *= f;
      reflector.v *= f;
      f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
      new_disp.u -= f * reflector.u;
      new_disp.v -= f * reflector.v;
      break;
    default:
      UNHANDLED_CASE(index_edge_was_hit);
    }
    this_pos.u = boundary_pos.u;
    this_pos.v = boundary_pos.v;
    this_disp.u = new_disp.u;
    this_disp.v = new_disp.v;
  } 
  sm-&gt;s_pos.u = orig_pos.u;
  sm-&gt;s_pos.v = orig_pos.v;
  *hit_data_info = hit_data_head;
  return NULL;
}
struct collision *ray_trace(struct volume *world, struct vector3 *init_pos,
                            struct collision *c, struct subvolume *sv,
                            struct vector3 *v, struct wall *reflectee) {
  double tx, ty, tz;
  world-&gt;ray_voxel_tests++;
  struct collision *shead = NULL;
  struct collision *smash = (struct collision *)CHECKED_MEM_GET(
      sv-&gt;local_storage-&gt;coll, "collision structure");
#ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
  std::vector&lt;wall_list*&gt; sorted_walls;
  for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
    sorted_walls.insert(sorted_walls.begin(), wlp);
  }
#endif
  struct wall_list fake_wlp;
  fake_wlp.next = sv-&gt;wall_head;
#ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
  for (unsigned wall_array_index = 0; wall_array_index &lt; sorted_walls.size(); wall_array_index++) {
    struct wall_list *wlp = sorted_walls[wall_array_index];
#else
  for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
#endif
    if (wlp-&gt;this_wall == reflectee)
      continue;
#ifdef DEBUG_COLLISIONS_WALL_EXTRA
    DUMP_CONDITION3(
        std::cout &lt;&lt; "Checking wall:\n";
        dump_wall(wlp-&gt;this_wall, "", true);
    );
#endif
    int i = collide_wall(init_pos, v, wlp-&gt;this_wall, &amp;(smash-&gt;t), &amp;(smash-&gt;loc),
                     1, world-&gt;rng, world-&gt;notify, &amp;(world-&gt;ray_polygon_tests));
#ifdef DEBUG_COLLISIONS_WALL_EXTRA
    DUMP_CONDITION3(
        if (i == COLLIDE_REDO || i == COLLIDE_FRONT || i == COLLIDE_BACK) {
          std::cout &lt;&lt; "Collide wall: vm pos: " &lt;&lt; *init_pos  &lt;&lt; ", displacement: " &lt;&lt; *v &lt;&lt; "\n";
          dump_wall(wlp-&gt;this_wall, "", true);
          std::cout &lt;&lt; "collision time: " &lt;&lt; smash-&gt;t &lt;&lt; ", collision pos: " &lt;&lt; smash-&gt;loc &lt;&lt; "\n";
        }
    );
#endif
    if (i == COLLIDE_REDO) {
      if (shead != NULL)
        mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
      shead = NULL;
      wlp = &amp;fake_wlp;
#ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
      wall_array_index = 0;
#endif
      continue;
    } else if (i != COLLIDE_MISS) {
      world-&gt;ray_polygon_colls++;
      smash-&gt;what = COLLIDE_WALL + i;
      smash-&gt;target = (void *)wlp-&gt;this_wall;
      smash-&gt;next = shead;
      shead = smash;
      smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
                                                  "collision structure");
    }
  }
  double dx, dy, dz;
  dx = dy = dz = 0.0;
  int i = -10;
  if (v-&gt;x &lt; 0.0) {
    dx = world-&gt;x_fineparts[sv-&gt;llf.x] - init_pos-&gt;x;
    i = 0;
  } else if (v-&gt;x &gt; 0.0) {
    dx = world-&gt;x_fineparts[sv-&gt;urb.x] - init_pos-&gt;x;
    i = 1;
  }
  int j = -10;
  if (v-&gt;y &lt; 0.0) {
    dy = world-&gt;y_fineparts[sv-&gt;llf.y] - init_pos-&gt;y;
    j = 0;
  } else if (v-&gt;y &gt; 0.0) {
    dy = world-&gt;y_fineparts[sv-&gt;urb.y] - init_pos-&gt;y;
    j = 1;
  }
  int k = -10;
  if (v-&gt;z &lt; 0.0) {
    dz = world-&gt;z_fineparts[sv-&gt;llf.z] - init_pos-&gt;z;
    k = 0;
  } else if (v-&gt;z &gt; 0.0) {
    dz = world-&gt;z_fineparts[sv-&gt;urb.z] - init_pos-&gt;z;
    k = 1;
  }
  if (i + j + k &lt; 0)   {
    if (i + j + k &lt; -15)     {
      if (i &gt;= 0)       {
        smash-&gt;t = dx / v-&gt;x;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
      } else if (j &gt;= 0)       {
        smash-&gt;t = dy / v-&gt;y;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
      } else if (k &gt;= 0)       {
        smash-&gt;t = dz / v-&gt;z;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
      } else {
        smash-&gt;t = FOREVER;
        smash-&gt;what =
      }
    } else     {
      if (i &lt; 0) {
        ty = fabs(dy * v-&gt;z);
<a name="0"></a>        tz = fabs(v-&gt;y * dz);
        if (ty &lt; tz) {
          smash-&gt;t = dy / v-&gt;y;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
        } else {
          smash-&gt;t = dz / v-&gt;z;
          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
        }
      } else if (j &lt; 0) {
        tx = fabs(dx * v-&gt;z);
        tz = fabs(v-&gt;x * dz);
        if (tx &lt; tz) {</b></font>
          smash-&gt;t = dx / v-&gt;x;
          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
        } else 
{          smash-&gt;t = dz / v-&gt;z;
          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k
;        }
      } else       {
        tx = fabs(dx * v-&gt;y);
        ty = fabs(v-&gt;x * dy);
        if (tx &lt; ty) {
          smash-&gt;t = dx / v-&gt;x;
          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
        } else {
          smash-&gt;t = dy / v-&gt;y;
          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
        }
      }
    }
  } else   {
    tx = fabs(dx * v-&gt;y * v-&gt;z);
    ty = fabs(v-&gt;x * dy * v-&gt;z);
    tz = fabs(v-&gt;x * v-&gt;y * dz);
    if (tx &lt; ty) {
      if (tx &lt; tz) {
        smash-&gt;t = dx / v-&gt;x;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
      } else {
        smash-&gt;t = dz / v-&gt;z;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
      }
<a name="1"></a>    } else {
      if (ty &lt; tz) {
        smash-&gt;t = dy / v-&gt;y;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
      } else {
        smash-&gt;t = dz / v-&gt;z;
        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
      }
    }
  }
  smash-&gt;loc.x = init_pos-&gt;x + smash-&gt;t * v-&gt;x;
  smash-&gt;loc.y = init_pos-&gt;y + smash-&gt;t * v-&gt;y;
  smash-&gt;loc.z = init_pos-&gt;z + smash-&gt;t * v-&gt;z;
  smash-&gt;target = sv;</b></font>
  smash-&gt;next = shead;
  shead = smash;
  for (; c != NULL; c = c-&gt;next) {
    struct abstract_molecule *a = (struct abstract_molecule *)c-&gt;target;
    if (a-&gt;properties == NULL)
      continue;
    i = collide_mol(init_pos, v, a, &amp;(c-&gt;t), &amp;(c-&gt;loc), world-&gt;rx_radius_3d);
    if (i != COLLIDE_MISS) {
      smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
                                                  "collision structure");
      memcpy(smash, c, sizeof(struct collision));
      smash-&gt;what = COLLIDE_VOL + i;
      smash-&gt;next = shead;
      shead = smash;
    }
  }
  return shead;
}
struct exd_vector3 {
  double m, u, v;
};
static double exd_zetize(double y, double x) {
  if (y &gt;= 0.0) {
    if (x &gt;= 0) {
      if (x &lt; y)
        return 1.0 - 0.5 * x / y;
      else
        return 0.5 * y / x;
    } else {
      if (-x &lt; y)
        return 1.0 - 0.5 * x / y;
      else
        return 2.0 + 0.5 * y / x;
    }
  } else {
    if (x &lt;= 0) {
      if (y &lt; x)
        return 3.0 - 0.5 * x / y;
      else
        return 2.0 + 0.5 * y / x;
    } else {
      if (x &lt; -y)
        return 3.0 - 0.5 * x / y;
      else
        return 4.0 + 0.5 * y / x;
    }
  }
}
static void exd_coordize(struct vector3 *mv, struct vector3 *m,
                         struct vector3 *u, struct vector3 *v) {
  double a;
  a = 1.0 / sqrt(mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
  m-&gt;x = a * mv-&gt;x;
  m-&gt;y = a * mv-&gt;y;
  m-&gt;z = a * mv-&gt;z;
  if (m-&gt;x * m-&gt;x &gt; m-&gt;y * m-&gt;y) {
    if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
      if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
        u-&gt;x = m-&gt;y;
        u-&gt;y = -m-&gt;x;
        u-&gt;z = 0.0;
        a = 1.0 - m-&gt;z * m-&gt;z;
        v-&gt;x = m-&gt;z * m-&gt;x;
        v-&gt;y = m-&gt;z * m-&gt;y;
        v-&gt;z = -a;
      } else {
        u-&gt;x = m-&gt;z;
        u-&gt;y = 0.0;
        u-&gt;z = -m-&gt;x;
        a = 1.0 - m-&gt;y * m-&gt;y;
        v-&gt;x = -m-&gt;y * m-&gt;x;
        v-&gt;y = a;
        v-&gt;z = -m-&gt;y * m-&gt;z;
      }
    } else {
      u-&gt;x = -m-&gt;z;
      u-&gt;y = 0.0;
      u-&gt;z = m-&gt;x;
      a = 1.0 - m-&gt;y * m-&gt;y;
      v-&gt;x = m-&gt;y * m-&gt;x;
      v-&gt;y = -a;
      v-&gt;z = m-&gt;y * m-&gt;z;
    }
  } else {
    if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
      if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
        u-&gt;x = -m-&gt;y;
        u-&gt;y = m-&gt;x;
        u-&gt;z = 0.0;
        a = 1.0 - m-&gt;z * m-&gt;z;
        v-&gt;x = -m-&gt;z * m-&gt;x;
        v-&gt;y = -m-&gt;z * m-&gt;y;
        v-&gt;z = a;
      } else {
        u-&gt;x = 0.0;
        u-&gt;y = m-&gt;z;
        u-&gt;z = -m-&gt;y;
        a = 1.0 - m-&gt;x * m-&gt;x;
        v-&gt;x = -a;
        v-&gt;y = m-&gt;x * m-&gt;y;
        v-&gt;z = m-&gt;x * m-&gt;z;
      }
    } else {
      u-&gt;x = 0.0;
      u-&gt;y = -m-&gt;z;
      u-&gt;z = m-&gt;y;
      a = 1.0 - m-&gt;x * m-&gt;x;
      v-&gt;x = a;
      v-&gt;y = -m-&gt;x * m-&gt;y;
      v-&gt;z = -m-&gt;x * m-&gt;z;
    }
  }
  a = 1 / sqrt(a);
  u-&gt;x *= a;
  u-&gt;y *= a;
  u-&gt;z *= a;
  v-&gt;x *= a;
  v-&gt;y *= a;
  v-&gt;z *= a;
}
enum {
  EXD_HEAD,
  EXD_TAIL,
  EXD_CROSS,
  EXD_SPAN,
  EXD_OTHER
};
#define TARGET_OCCLUDED -1
double exact_disk(struct volume *world, struct vector3 *loc, struct vector3 *mv,
                  double R, struct subvolume *sv,
                  struct volume_molecule *moving,
                  struct volume_molecule *target, int use_expanded_list,
                  double *x_fineparts, double *y_fineparts,
                  double *z_fineparts) {
#define EXD_SPAN_CALC(v1, v2, p)                                               \
  ((v1)-&gt;u - (p)-&gt;u) * ((v2)-&gt;v - (p)-&gt;v) -                                    \
      ((v2)-&gt;u - (p)-&gt;u) * ((v1)-&gt;v - (p)-&gt;v)
#define EXD_TIME_CALC(v1, v2, p)                                               \
  ((p)-&gt;u *(v1)-&gt;v - (p)-&gt;v *(v1)-&gt;u) /                                        \
      ((p)-&gt;v *((v2)-&gt;u - (v1)-&gt;u) - (p)-&gt;u *((v2)-&gt;v - (v1)-&gt;v))
  struct wall_list *wl;
  struct wall *w;
  struct vector3 llf, urb;
  struct exd_vector3 v0muv, v1muv, v2muv;
  struct exd_vertex pa, pb;
  struct exd_vertex *ppa, *ppb, *pqa, *pqb, *vertex_head, *vp, *vq, *vr, *vs;
  double pa_pb;
  int n_verts, n_edges;
  int p_flags;
  double R2;
  struct vector3 m, u, v;
  struct exd_vector3 Lmuv;
  struct exd_vertex sm;
  double m2_i;
  double l_n, m_n;
  double a, b, c, d, r, s, t, A, zeta, last_zeta;
  int i;
  int num_matching_rxns = 0;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  vertex_head = NULL;
  n_verts = 0;
  n_edges = 0;
  R2 = R * R;
  m2_i = 1.0 / (mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
  Lmuv.m = Lmuv.u = Lmuv.v = 0.0;        sm.u = sm.v = sm.r2 = sm.zeta = 0.0; 
  exd_coordize(mv, &amp;m, &amp;u, &amp;v);
  Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
  Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
  Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
  if (!distinguishable_vec3(loc, &amp;(target-&gt;pos), EPS_C)) {     sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
  } else {     sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
           (target-&gt;pos.z - loc-&gt;z) * u.z;
    sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
           (target-&gt;pos.z - loc-&gt;z) * v.z;
    sm.r2 = sm.u * sm.u + sm.v * sm.v;
    sm.zeta = exd_zetize(sm.v, sm.u);
  }
  for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
    w = wl-&gt;this_wall;
    l_n = loc-&gt;x * w-&gt;normal.x + loc-&gt;y * w-&gt;normal.y + loc-&gt;z * w-&gt;normal.z;
    d = w-&gt;d - l_n;
    m_n = mv-&gt;x * w-&gt;normal.x + mv-&gt;y * w-&gt;normal.y + mv-&gt;z * w-&gt;normal.z;
    if (d * d &gt;= R2 * (1 - m2_i * m_n * m_n))
      continue;
    urb.x = llf.x = w-&gt;vert[0]-&gt;x;
    if (w-&gt;vert[1]-&gt;x &lt; llf.x)
      llf.x = w-&gt;vert[1]-&gt;x;
    else
      urb.x = w-&gt;vert[1]-&gt;x;
    if (w-&gt;vert[2]-&gt;x &lt; llf.x)
      llf.x = w-&gt;vert[2]-&gt;x;
    else if (w-&gt;vert[2]-&gt;x &gt; urb.x)
      urb.x = w-&gt;vert[2]-&gt;x;
    urb.y = llf.y = w-&gt;vert[0]-&gt;y;
    if (w-&gt;vert[1]-&gt;y &lt; llf.y)
      llf.y = w-&gt;vert[1]-&gt;y;
    else
      urb.y = w-&gt;vert[1]-&gt;y;
    if (w-&gt;vert[2]-&gt;y &lt; llf.y)
      llf.y = w-&gt;vert[2]-&gt;y;
    else if (w-&gt;vert[2]-&gt;y &gt; urb.y)
      urb.y = w-&gt;vert[2]-&gt;y;
    urb.z = llf.z = w-&gt;vert[0]-&gt;z;
    if (w-&gt;vert[1]-&gt;z &lt; llf.z)
      llf.z = w-&gt;vert[1]-&gt;z;
    else
      urb.z = w-&gt;vert[1]-&gt;z;
    if (w-&gt;vert[2]-&gt;z &lt; llf.z)
      llf.z = w-&gt;vert[2]-&gt;z;
    else if (w-&gt;vert[2]-&gt;z &gt; urb.z)
      urb.z = w-&gt;vert[2]-&gt;z;
    b = R2 * (1.0 - mv-&gt;x * mv-&gt;x * m2_i);
    a = llf.x - loc-&gt;x;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    a = loc-&gt;x - urb.x;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    b = R2 * (1.0 - mv-&gt;y * mv-&gt;y * m2_i);
    a = llf.y - loc-&gt;y;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    a = loc-&gt;y - urb.y;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    b = R2 * (1.0 - mv-&gt;z * mv-&gt;z * m2_i);
    a = llf.z - loc-&gt;z;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    a = loc-&gt;z - urb.z;
    if (a &gt; 0 &amp;&amp; a * a &gt;= b)
      continue;
    if ((moving-&gt;properties-&gt;flags &amp; CAN_VOLWALL) != 0) {
      num_matching_rxns = trigger_intersect(
          world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
          world-&gt;all_volume_mols, world-&gt;all_surface_mols,
          moving-&gt;properties-&gt;hashval, (struct abstract_molecule *)moving, 0, w,
          matching_rxns, 1, 1, 0);
      if (num_matching_rxns != 0) {
        bool all_transparent = true;
        for (i = 0; i &lt; num_matching_rxns; i++) {
          if (matching_rxns[i]-&gt;n_pathways != RX_TRANSP) {
            all_transparent = false;
            break;
          }
        }
        if (all_transparent) {
          continue;
        }
      }
    }
#if 0
    if (uncoordinated) {
      exd_coordize(mv, &amp;m, &amp;u, &amp;v);
      Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
      Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
      Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
      if (!distinguishable_vec3(loc, &amp;(target-&gt;pos),
                                EPS_C))       {
        sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
      } else       {
        sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
               (target-&gt;pos.z - loc-&gt;z) * u.z;
        sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
               (target-&gt;pos.z - loc-&gt;z) * v.z;
        sm.r2 = sm.u * sm.u + sm.v * sm.v;
        sm.zeta = exd_zetize(sm.v, sm.u);
      }
      uncoordinated = 0;
    }
#endif
    v0muv.m = w-&gt;vert[0]-&gt;x * m.x + w-&gt;vert[0]-&gt;y * m.y + w-&gt;vert[0]-&gt;z * m.z -
              Lmuv.m;
    v0muv.u = w-&gt;vert[0]-&gt;x * u.x + w-&gt;vert[0]-&gt;y * u.y + w-&gt;vert[0]-&gt;z * u.z -
              Lmuv.u;
    v0muv.v = w-&gt;vert[0]-&gt;x * v.x + w-&gt;vert[0]-&gt;y * v.y + w-&gt;vert[0]-&gt;z * v.z -
              Lmuv.v;
    v1muv.m = w-&gt;vert[1]-&gt;x * m.x + w-&gt;vert[1]-&gt;y * m.y + w-&gt;vert[1]-&gt;z * m.z -
              Lmuv.m;
    v1muv.u = w-&gt;vert[1]-&gt;x * u.x + w-&gt;vert[1]-&gt;y * u.y + w-&gt;vert[1]-&gt;z * u.z -
              Lmuv.u;
    v1muv.v = w-&gt;vert[1]-&gt;x * v.x + w-&gt;vert[1]-&gt;y * v.y + w-&gt;vert[1]-&gt;z * v.z -
              Lmuv.v;
    v2muv.m = w-&gt;vert[2]-&gt;x * m.x + w-&gt;vert[2]-&gt;y * m.y + w-&gt;vert[2]-&gt;z * m.z -
              Lmuv.m;
    v2muv.u = w-&gt;vert[2]-&gt;x * u.x + w-&gt;vert[2]-&gt;y * u.y + w-&gt;vert[2]-&gt;z * u.z -
              Lmuv.u;
    v2muv.v = w-&gt;vert[2]-&gt;x * v.x + w-&gt;vert[2]-&gt;y * v.y + w-&gt;vert[2]-&gt;z * v.z -
              Lmuv.v;
    if ((v0muv.m &lt; 0) == (v1muv.m &lt; 0))     {
      if ((v2muv.m &lt; 0) == (v1muv.m &lt; 0))
        continue;
      t = v0muv.m / (v0muv.m - v2muv.m);
      pa.u = v0muv.u + (v2muv.u - v0muv.u) * t;
      pa.v = v0muv.v + (v2muv.v - v0muv.v) * t;
      t = v1muv.m / (v1muv.m - v2muv.m);
      pb.u = v1muv.u + (v2muv.u - v1muv.u) * t;
      pb.v = v1muv.v + (v2muv.v - v1muv.v) * t;
    } else if ((v0muv.m &lt; 0) == (v2muv.m &lt; 0))     {
      t = v0muv.m / (v0muv.m - v1muv.m);
      pa.u = v0muv.u + (v1muv.u - v0muv.u) * t;
      pa.v = v0muv.v + (v1muv.v - v0muv.v) * t;
      t = v2muv.m / (v2muv.m - v1muv.m);
      pb.u = v2muv.u + (v1muv.u - v2muv.u) * t;
      pb.v = v2muv.v + (v1muv.v - v2muv.v) * t;
    } else     {
      t = v1muv.m / (v1muv.m - v0muv.m);
      pa.u = v1muv.u + (v0muv.u - v1muv.u) * t;
      pa.v = v1muv.v + (v0muv.v - v1muv.v) * t;
      t = v2muv.m / (v2muv.m - v0muv.m);
      pb.u = v2muv.u + (v0muv.u - v2muv.u) * t;
      pb.v = v2muv.v + (v0muv.v - v2muv.v) * t;
    }
    pa.r2 = pa.u * pa.u + pa.v * pa.v;
    pb.r2 = pb.u * pb.u + pb.v * pb.v;
    if (pa.r2 &lt; EPS_C * R2 ||
    {
      if (vertex_head != NULL)
        mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
      return TARGET_OCCLUDED;
    }
    if (!distinguishable(pa.u * pb.v, pb.u * pa.v, EPS_C) &amp;&amp;
        pa.u * pb.u + pa.v * pb.v &lt;
            0)     {
      if (vertex_head != NULL)
        mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
      return TARGET_OCCLUDED;
    }
    t = 0;
    s = 1;
    if (pa.r2 &gt; R2 || pb.r2 &gt; R2) {
      pa_pb = pa.u * pb.u + pa.v * pb.v;
      if (!distinguishable(pa.r2 + pb.r2, 2 * pa_pb,
      {
        if (sm.r2 &lt; pa.r2 &amp;&amp; sm.r2 &lt; pb.r2 &amp;&amp;
            distinguishable(sm.r2, pa.r2, EPS_C) &amp;&amp;
            distinguishable(sm.r2, pa.r2, EPS_C))
          continue;
        if (!distinguishable(sm.u * pa.v, sm.v * pa.u, SQRT_EPS_C) ||
            !distinguishable(sm.u * pb.v, sm.v * pb.u, SQRT_EPS_C)) {
          if (vertex_head != NULL)
            mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
          return TARGET_OCCLUDED;
        }
        continue;
      }
      a = 1.0 / (pa.r2 + pb.r2 - 2 * pa_pb);
      b = (pa_pb - pa.r2) * a;
      c = (R2 - pa.r2) * a;
      d = b * b + c;
      if (d &lt;= 0)
        continue;
      d = sqrt(d);
      t = -b - d;
      if (t &gt;= 1)
        continue;
      if (t &lt; 0)
        t = 0;
      s = -b + d;
      if (s &lt;= 0)
        continue;
      if (s &gt; 1)
        s = 1;
    }
    ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                               "exact disk vertex");
    ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                               "exact disk vertex");
    if (t &gt; 0) {
      ppa-&gt;u = pa.u + t * (pb.u - pa.u);
      ppa-&gt;v = pa.v + t * (pb.v - pa.v);
      ppa-&gt;r2 = ppa-&gt;u * ppa-&gt;u + ppa-&gt;v * ppa-&gt;v;
      ppa-&gt;zeta = exd_zetize(ppa-&gt;v, ppa-&gt;u);
    } else {
      ppa-&gt;u = pa.u;
      ppa-&gt;v = pa.v;
      ppa-&gt;r2 = pa.r2;
      ppa-&gt;zeta = exd_zetize(pa.v, pa.u);
    }
    if (s &lt; 1) {
      ppb-&gt;u = pa.u + s * (pb.u - pa.u);
      ppb-&gt;v = pa.v + s * (pb.v - pa.v);
      ppb-&gt;r2 = ppb-&gt;u * ppb-&gt;u + ppb-&gt;v * ppb-&gt;v;
      ppb-&gt;zeta = exd_zetize(ppb-&gt;v, ppb-&gt;u);
    } else {
      ppb-&gt;u = pb.u;
      ppb-&gt;v = pb.v;
      ppb-&gt;r2 = pb.r2;
      ppb-&gt;zeta = exd_zetize(pb.v, pb.u);
    }
    a = (ppb-&gt;zeta - ppa-&gt;zeta);
    if (a &lt; 0)
      a += 4.0;
    if (a &gt;= 2.0) {
      vp = ppb;
      ppb = ppa;
      ppa = vp;
      a = 4.0 - a;
    }
    b = (sm.zeta - ppa-&gt;zeta);
    if (b &lt; 0)
      b += 4.0;
    if (b &lt; a) {
      c = (ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v) - (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u);
      if (c &lt; 0 || !distinguishable((ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v),
                                    (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u),
                                    EPS_C))       {
        ppa-&gt;next = ppb;
        ppb-&gt;next = vertex_head;
        mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
        return TARGET_OCCLUDED;
      }
    }
    ppa-&gt;role = EXD_HEAD;
    ppb-&gt;role = EXD_TAIL;
    ppa-&gt;e = ppb;
    ppb-&gt;e = NULL;
    ppb-&gt;next = vertex_head;
    ppa-&gt;next = ppb;
    vertex_head = ppa;
    n_verts += 2;
    n_edges++;
  }
  if (!use_expanded_list)   {
    p_flags = 0;
    d = loc-&gt;x - x_fineparts[sv-&gt;llf.x];
    if (d &lt; R) {
      c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i;
      if (d * d &lt; c)
        p_flags |= X_NEG_BIT;
      d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
      if (d * d &lt; c)
        p_flags |= X_POS_BIT;
    } else {
      d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
      if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i)
        p_flags |= X_POS_BIT;
    }
    d = loc-&gt;y - y_fineparts[sv-&gt;llf.y];
    if (d &lt; R) {
      c = R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i;
      if (d * d &lt; c)
        p_flags |= Y_NEG_BIT;
      d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
      if (d * d &lt; c)
        p_flags |= Y_POS_BIT;
    } else {
      d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
      if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i)
        p_flags |= Y_POS_BIT;
    }
    d = loc-&gt;z - z_fineparts[sv-&gt;llf.z];
    if (d &lt; R) {
      c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i;
      if (d * d &lt; c)
        p_flags |= Z_NEG_BIT;
      d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
      if (d * d &lt; c)
        p_flags |= Z_POS_BIT;
    } else {
      d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
      if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i)
        p_flags |= Z_POS_BIT;
    }
    if (p_flags) {
      for (i = 1; i &lt;= p_flags; i *= 2) {
        if ((i &amp; p_flags) != 0) {
          switch (i) {
          case X_NEG_BIT:
            d = x_fineparts[sv-&gt;llf.x] - loc-&gt;x;
            a = u.x;
            b = v.x;
            break;
          case X_POS_BIT:
            d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
            a = u.x;
            b = v.x;
            break;
          case Y_NEG_BIT:
            d = y_fineparts[sv-&gt;llf.y] - loc-&gt;y;
            a = u.y;
            b = v.y;
            break;
          case Y_POS_BIT:
            d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
            a = u.y;
            b = v.y;
            break;
          case Z_NEG_BIT:
            d = z_fineparts[sv-&gt;llf.z] - loc-&gt;z;
            a = u.z;
            b = v.z;
            break;
          case Z_POS_BIT:
            d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
            a = u.z;
            b = v.z;
            break;
          default:
            continue;
          }
          if (!distinguishable(a, 0, EPS_C)) {
            s = d / b;
            if (s * s &gt; R2) {
              mcell_internal_error(
                  "Unexpected results in exact disk: s=%.2f s^2=%.2f R2=%.2f\n",
                  s, s * s, R2);
            }
            t = sqrt(R2 - s * s);
            pa.u = t;
            pa.v = s;
            pb.u = -t;
            pb.v = s;
          } else if (!distinguishable(b, 0, EPS_C)) {
            t = d / a;
            if (t * t &gt; R2) {
              mcell_internal_error(
                  "Unexpected results in exact disk: t=%.2f t^2=%.2f R2=%.2f\n",
                  t, t * t, R2);
            }
            s = sqrt(R2 - t * t);
            pa.u = t;
            pa.v = s;
            pb.u = t;
            pb.v = -s;
          } else {
            c = a * a + b * b;
            s = d * b;
            if (d * d &gt; R2 * c) {
              mcell_internal_error("Unexpected results in exact disk: d=%.2f "
                                   "d^2=%.2f R2=%.2f c=%.2f R2*c=%.2f\n",
                                   d, d * d, R2, c, R2 * c);
            }
            t = sqrt(R2 * c - d * d);
            c = 1.0 / c;
            r = 1.0 / a;
            pa.v = c * (s + t * a);
            pa.u = (d - b * pa.v) * r;
            pb.v = c * (s - t * a);
            pb.u = (d - b * pb.v) * r;
          }
          ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                                     "exact disk vertex");
          ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                                     "exact disk vertex");
          a = exd_zetize(pa.v, pa.u);
          b = exd_zetize(pb.v, pb.u);
          c = b - a;
          if (c &lt; 0)
            c += 4;
          if (c &lt; 2) {
            ppa-&gt;u = pa.u;
            ppa-&gt;v = pa.v;
            ppa-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
            ppa-&gt;zeta = a;
            ppb-&gt;u = pb.u;
            ppb-&gt;v = pb.v;
            ppb-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
            ppb-&gt;zeta = b;
          } else {
            ppb-&gt;u = pa.u;
            ppb-&gt;v = pa.v;
            ppb-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
            ppb-&gt;zeta = a;
            ppa-&gt;u = pb.u;
            ppa-&gt;v = pb.v;
            ppa-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
            ppa-&gt;zeta = b;
          }
          ppa-&gt;role = EXD_HEAD;
          ppb-&gt;role = EXD_TAIL;
          ppa-&gt;e = ppb;
          ppb-&gt;e = NULL;
          ppb-&gt;next = vertex_head;
          ppa-&gt;next = ppb;
          vertex_head = ppa;
          n_verts += 2;
          n_edges++;
        }
      }
    }
  }
  if (n_edges == 0) {
    return 1.0;
  }
  else if (n_edges == 1) {
    ppa = vertex_head;
    ppb = ppa-&gt;e;
    a = ppa-&gt;u * ppb-&gt;u + ppa-&gt;v * ppb-&gt;v;
    b = ppa-&gt;u * ppb-&gt;v - ppa-&gt;v * ppb-&gt;u;
    if (a &lt;= 0)     {
      s = atan(-a / b) + 0.5 * MY_PI;
    } else {
      s = atan(b / a);
    }
    A = (0.5 * b + R2 * (MY_PI - 0.5 * s)) / (MY_PI * R2);
    mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
    return A;
  }
  vp = vertex_head-&gt;next;
  ppa = ppb = vertex_head;
  ppa-&gt;next = NULL;
  ppa-&gt;span = NULL;
  while (vp != NULL) {
    vp-&gt;span = NULL;
    vq = vp-&gt;next;
    if (vp-&gt;zeta &lt; ppa-&gt;zeta) {
      vp-&gt;next = ppa;
      ppa = vp;
    } else {
      for (pqa = ppa; pqa-&gt;next != NULL; pqa = pqa-&gt;next) {
        if (vp-&gt;zeta &lt; pqa-&gt;next-&gt;zeta)
          break;
      }
      vp-&gt;next = pqa-&gt;next;
      pqa-&gt;next = vp;
      if (vp-&gt;next == NULL)
        ppb = vp;
    }
    vp = vq;
  }
  vertex_head = ppa;
  ppb-&gt;next = ppa;
  ppb = NULL;
  for (ppa = vertex_head; ppa != vertex_head || ppb == NULL; ppa = ppa-&gt;next) {
    if (ppa-&gt;role != EXD_HEAD)
      continue;
    ppb = ppa-&gt;e;
    for (pqa = ppa-&gt;next; pqa != ppb; pqa = pqa-&gt;next) {
      if (pqa-&gt;role != EXD_HEAD)
        continue;
      pqb = pqa-&gt;e;
      pa.u = ppb-&gt;u - ppa-&gt;u;
      pa.v = ppb-&gt;v - ppa-&gt;v;
      pb.u = pqb-&gt;u - pqa-&gt;u;
      pb.v = pqb-&gt;v - pqa-&gt;v;
      r = pb.u * pa.v - pa.u * pb.v;
      if (r * r &lt;
          EPS_C * (pa.u * pa.u + pa.v * pa.v) * (pb.u * pb.u + pb.v * pb.v)) {
        pqa-&gt;e = NULL;
        pqa-&gt;role = EXD_OTHER;
<a name="3"></a>
        a = pqb-&gt;zeta - ppb-&gt;zeta;
        if (a &lt; 0)
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          a += 4.0;
        if (a &gt; 2)         {
          pqb-&gt;role = EXD_OTHER;
        } else         {
          ppa-&gt;e = pqb;
          ppb-&gt;role = EXD_OTHER;
          ppb = pqb;
          pqa = ppa;
        }</b></font>
        continue;
      }
      s = (ppa-&gt;u - pqa-&gt;u) * pa.v - (ppa-&gt;v - pqa-&gt;v) * pa.u;
      if (s * r &lt;= EPS_C * R2 * R2)
        continue;
      t = s / r;
      if (t &gt;= 1 - EPS_C)
        continue;
      if (pa.u * pa.u &gt; pa.v * pa.v) {
        s = (pqa-&gt;u - ppa-&gt;u + t * pb.u) * pa.u;
        if (s &lt;= EPS_C * R2 || s &gt;= pa.u * pa.u * (1.0 - EPS_C))
          continue;
      } else {
        s = (pqa-&gt;v - ppa-&gt;v + t * pb.v) * pa.v;
        if (s &lt;= EPS_C * R2 || s &gt;= pa.v * pa.v * (1.0 - EPS_C))
          continue;
      }
      vq = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                                "exact disk vertex");
      vq-&gt;u = pqa-&gt;u + t * pb.u;
      vq-&gt;v = pqa-&gt;v + t * pb.v;
      vq-&gt;r2 = vq-&gt;u * vq-&gt;u + vq-&gt;v * vq-&gt;v;
      vq-&gt;zeta = exd_zetize(vq-&gt;v, vq-&gt;u);
      vq-&gt;e = ppb;
      vq-&gt;span = NULL;
      vq-&gt;role = EXD_CROSS;
      for (vp = ppa; vp != ppb; vp = vp-&gt;next) {
        a = vq-&gt;zeta - vp-&gt;next-&gt;zeta;
        if (a &gt; 2.0)
          a -= 4.0;
        else if (a &lt; -2.0)
          a += 4.0;
        if (a &lt; 0)
          break;
      }
      vq-&gt;next = vp-&gt;next;
      vp-&gt;next = vq;
      if (vq-&gt;zeta &lt; vertex_head-&gt;zeta)
        vertex_head = vq;
    }
  }
  for (vp = vertex_head, vq = NULL; vq != vertex_head; vp = vq) {
    for (vq = vp-&gt;next; vq != vertex_head; vq = vq-&gt;next) {
      if (vq-&gt;zeta - vp-&gt;zeta &lt; EPS_C) {
        vq-&gt;zeta = vp-&gt;zeta;
        if (-EPS_C &lt; vq-&gt;r2 - vp-&gt;r2 &amp;&amp; EPS_C &gt; vq-&gt;r2 - vp-&gt;r2) {
          vq-&gt;r2 = vp-&gt;r2;
        }
      } else
        break;
    }
  }
  vq = NULL;
  for (vp = vertex_head; vp != vertex_head || vq == NULL; vp = vp-&gt;next) {
    if (vp-&gt;role != EXD_HEAD)
      continue;
    for (vq = vp-&gt;next; vq != vp-&gt;e; vq = vq-&gt;next) {
      if (!distinguishable(vq-&gt;zeta, vp-&gt;zeta, EPS_C))
        continue;
      if (!distinguishable(vq-&gt;zeta, vp-&gt;e-&gt;zeta, EPS_C))
        break;
      if (vq-&gt;role == EXD_OTHER)
        continue;
      vr = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
                                                "exact disk vertex");
      vr-&gt;next = vq-&gt;span;
      vq-&gt;span = vr;
      vr-&gt;e = vp;
      vr-&gt;zeta = vq-&gt;zeta;
      vr-&gt;role = EXD_SPAN;
    }
  }
  A = 0.0;
  zeta = 0.0;
  last_zeta = -1;
  vs = NULL;
  for (vp = vertex_head; zeta &lt; 4.0 - EPS_C; vp = vp-&gt;next) {
    if (vp-&gt;role == EXD_OTHER)
      continue;
    if (!distinguishable(vp-&gt;zeta, last_zeta, EPS_C))
      continue;
    last_zeta = vp-&gt;zeta;
    if (vs == &amp;pa)
      vr = &amp;pb;
    else
      vr = &amp;pa;
    vr-&gt;u = vp-&gt;u;
    vr-&gt;v = vp-&gt;v;
    vr-&gt;zeta = vp-&gt;zeta;
    if (vp-&gt;role == EXD_TAIL) {
      vr-&gt;r2 = R2 * (1.0 + EPS_C);
      vr-&gt;e = NULL;
    } else {
      vr-&gt;r2 = vp-&gt;r2;
      vr-&gt;e = vp-&gt;e;
    }
    for (vq = vp-&gt;next; (!distinguishable(vq-&gt;zeta, last_zeta, EPS_C));
         vq = vq-&gt;next) {
      if (vq-&gt;role == EXD_HEAD) {
        if (vq-&gt;r2 &lt; vp-&gt;r2 || vr-&gt;e == NULL) {
          vr-&gt;u = vq-&gt;u;
          vr-&gt;v = vq-&gt;v;
          vr-&gt;r2 = vq-&gt;r2;
          vr-&gt;e = vq-&gt;e;
        } else if (!distinguishable(vq-&gt;r2, vr-&gt;r2, EPS_C)) {
          b = EXD_SPAN_CALC(vr, vr-&gt;e, vq-&gt;e);
          if (b &gt; 0)
            vr-&gt;e = vq-&gt;e;
        }
      }
    }
    for (vq = vp-&gt;span; vq != NULL; vq = vq-&gt;next) {
      ppa = vq-&gt;e;
      ppb = ppa-&gt;e;
      b = EXD_SPAN_CALC(ppa, ppb, vr);
      c = b * b;
      if (c &lt; R2 * R2 * EPS_C)       {
        if (vr-&gt;e == NULL) {
          vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
          vr-&gt;e = ppb;
        } else {
          b = EXD_SPAN_CALC(vr, vr-&gt;e, ppb);
          if (b &gt; 0)
            vr-&gt;e = ppb;
        }
      } else if (b &lt; 0 ||
                 vr-&gt;e == NULL)       {
        t = EXD_TIME_CALC(ppa, ppb, vp);
        vr-&gt;u = ppa-&gt;u + t * (ppb-&gt;u - ppa-&gt;u);
        vr-&gt;v = ppa-&gt;v + t * (ppb-&gt;v - ppa-&gt;v);
        vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
        vr-&gt;e = ppb;
      }
    }
    if (vs == NULL)     {
      vs = vr;
    } else {
      c = vr-&gt;zeta - vs-&gt;zeta;
      if (c &lt; 0)
        c += 4.0;
        zeta += c;
        if (vs-&gt;e == NULL ||
            (vs-&gt;e-&gt;zeta - vs-&gt;zeta) * (vs-&gt;e-&gt;zeta - vs-&gt;zeta) &lt;
                EPS_C * EPS_C) {
          if (c &gt;= 2.0)           {
            vs-&gt;u = -vs-&gt;u;
            vs-&gt;v = -vs-&gt;v;
            A += 0.5 * MY_PI * R2;
          }
          a = vs-&gt;u * vr-&gt;u + vs-&gt;v * vr-&gt;v;
          b = vs-&gt;u * vr-&gt;v - vs-&gt;v * vr-&gt;u;
          if (a &lt;= 0)           {
            s = atan(-a / b) + 0.5 * MY_PI;
          } else {
            s = atan(b / a);
          }
          A += 0.5 * s * R2;
        } else {
          if (!distinguishable(vs-&gt;e-&gt;zeta, vr-&gt;zeta, EPS_C)) {
            A += 0.5 * (vs-&gt;u * vs-&gt;e-&gt;v - vs-&gt;v * vs-&gt;e-&gt;u);
          } else {
            t = EXD_TIME_CALC(vs, vs-&gt;e, vr);
            b = vs-&gt;u + (vs-&gt;e-&gt;u - vs-&gt;u) * t;
            c = vs-&gt;v + (vs-&gt;e-&gt;v - vs-&gt;v) * t;
            A += 0.5 * (vs-&gt;u * c - vs-&gt;v * b);
          }
        }
        vs = vr;
      } else {
        if (vr-&gt;e != NULL)
          vs = vr;
      }
    }
  }
  ppa = vertex_head-&gt;next;
  vertex_head-&gt;next = NULL;
  for (ppb = ppa; ppb != NULL; ppb = ppb-&gt;next) {
    if (ppb-&gt;span != NULL) {
      struct exd_vertex *next = ppb-&gt;next;
      ppb-&gt;next = ppb-&gt;span;
      ppb-&gt;span = NULL;
      while (ppb-&gt;next != NULL)
        ppb = ppb-&gt;next;
      ppb-&gt;next = next;
    }
  }
  mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
  return A / (MY_PI * R2);
#undef EXD_TIME_CALC
#undef EXD_SPAN_CALC
}
double safe_diffusion_step(struct volume_molecule *vm, struct collision *shead,
                           u_int radial_subdivisions, double *r_step,
                           double *x_fineparts, double *y_fineparts,
                           double *z_fineparts) {
  double d2;
  double d2_nearmax;
  double d2min = GIGANTIC;
  struct subvolume *sv = vm-&gt;subvol;
  struct wall *w;
  struct wall_list *wl;
  struct collision *smash;
  double steps;
  struct volume_molecule *mp;
  d2_nearmax = vm-&gt;get_space_step(vm) *
               r_step[(int)(radial_subdivisions * MULTISTEP_PERCENTILE)];
  d2_nearmax *= d2_nearmax;
  if ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
    for (smash = shead; smash != NULL; smash = smash-&gt;next) {
      mp = (struct volume_molecule *)smash-&gt;target;
      d2 = (vm-&gt;pos.x - mp-&gt;pos.x) * (vm-&gt;pos.x - mp-&gt;pos.x) +
           (vm-&gt;pos.y - mp-&gt;pos.y) * (vm-&gt;pos.y - mp-&gt;pos.y) +
           (vm-&gt;pos.z - mp-&gt;pos.z) * (vm-&gt;pos.z - mp-&gt;pos.z);
      if (d2 &lt; d2min)
        d2min = d2;
    }
  }
  for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
    w = wl-&gt;this_wall;
    d2 = (w-&gt;normal.x * vm-&gt;pos.x + w-&gt;normal.y * vm-&gt;pos.y +
          w-&gt;normal.z * vm-&gt;pos.z) -
         w-&gt;d;
    d2 *= d2;
    if (d2 &lt; d2min)
      d2min = d2;
  }
  d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;llf.x]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
  d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;urb.x]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
  d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;llf.y]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
  d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;urb.y]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
  d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;llf.z]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
  d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;urb.z]);
  d2 *= d2;
  if (d2 &lt; d2min)
    d2min = d2;
#ifdef MCELL3_4_SAFE_DIFF_STEP_RETURNS_CONSTANT
  return 1;
#else
  if (d2min &lt; d2_nearmax)
    steps = 1.0;
  else {
    double steps_sq = d2min / d2_nearmax;
    if (steps_sq &lt; MULTISTEP_WORTHWHILE * MULTISTEP_WORTHWHILE)
      steps = 1.0;
    else
      steps = sqrt(steps_sq);
  }
  return steps;
#endif
}
static struct collision *expand_collision_list_for_neighbor(struct volume *world,
    struct subvolume *sv, struct volume_molecule *vm, struct subvolume *new_sv,
    struct vector3 *path_llf, struct vector3 *path_urb,
    struct collision *shead1, double trim_x, double trim_y, double trim_z,
    double *x_fineparts, double *y_fineparts, double *z_fineparts,
    int rx_hashsize, struct rxn **reaction_hash) {
  int num_matching_rxns = 0;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  struct vector3 new_sv_llf, new_sv_urb;
  new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
  new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
  new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
  new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
  new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
  new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
  if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
    return shead1;
  double x_min, x_max;
  double y_min, y_max;
  double z_min, z_max;
  if (trim_x &lt; 0.0) {
    x_min = new_sv_urb.x + trim_x;
    x_max = new_sv_urb.x + EPS_C;
  } else if (trim_x &gt; 0.0) {
    x_min = new_sv_llf.x - EPS_C;
    x_max = new_sv_llf.x + trim_x;
  } else {
    x_min = new_sv_llf.x - EPS_C;
    x_max = new_sv_urb.x + EPS_C;
  }
  if (trim_y &lt; 0.0) {
    y_min = new_sv_urb.y + trim_y;
    y_max = new_sv_urb.y + EPS_C;
  } else if (trim_y &gt; 0.0) {
    y_min = new_sv_llf.y - EPS_C;
    y_max = new_sv_llf.y + trim_y;
  } else {
    y_min = new_sv_llf.y - EPS_C;
    y_max = new_sv_urb.y + EPS_C;
  }
  if (trim_z &lt; 0.0) {
    z_min = new_sv_urb.z + trim_z;
    z_max = new_sv_urb.z + EPS_C;
  } else if (trim_z &gt; 0.0) {
    z_min = new_sv_llf.z - EPS_C;
    z_max = new_sv_llf.z + trim_z;
  } else {
    z_min = new_sv_llf.z - EPS_C;
    z_max = new_sv_urb.z + EPS_C;
  }
  struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
  for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
    psl_next = psl-&gt;next;
    if (psl-&gt;properties == NULL) {
      psl_head = &amp;psl-&gt;next;
      continue;
    }
    if (psl-&gt;head == NULL) {
      *psl_head = psl-&gt;next;
      ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
      mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
      continue;
    } else
      psl_head = &amp;psl-&gt;next;
    if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
      if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, (struct abstract_molecule *)psl-&gt;head))
        continue;
    }
    else{
    if (!trigger_bimolecular_preliminary(
             reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
             psl-&gt;properties-&gt;hashval, vm-&gt;properties, psl-&gt;properties))
      continue;
    }
    for (struct volume_molecule *mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
      if (mp-&gt;properties == NULL)
        continue;
      if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
        continue;
      if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
        continue;
      if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
        continue;
      if (!periodic_boxes_are_identical(vm-&gt;periodic_box, mp-&gt;periodic_box)) {
        continue;
      }
        if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)vm,
            (struct abstract_molecule *)mp, 0, 0, matching_rxns);
        } 
        else{     
          num_matching_rxns = trigger_bimolecular(
              reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
              mp-&gt;properties-&gt;hashval, (struct abstract_molecule *)vm,
              (struct abstract_molecule *)mp, 0, 0, matching_rxns);
        }
      if (num_matching_rxns &lt;= 0)
        continue;
      for (int i = 0; i &lt; num_matching_rxns; i++) {
        struct collision *smash = (struct collision *)CHECKED_MEM_GET(
            sv-&gt;local_storage-&gt;coll, "collision data");
        smash-&gt;target = (void *)mp;
        smash-&gt;intermediate = matching_rxns[i];
        smash-&gt;next = shead1;
        smash-&gt;what = 0;
        smash-&gt;what |= COLLIDE_VOL;
        shead1 = smash;
      }
    }
  }
  return shead1;
}
static struct collision *
expand_collision_list(struct volume *world, struct volume_molecule *vm, struct vector3 *mv,
                      struct subvolume *sv, double rx_radius_3d,
                      int ny_parts, int nz_parts, double *x_fineparts,
                      double *y_fineparts, double *z_fineparts, int rx_hashsize,
                      struct rxn **reaction_hash) {
  struct collision *shead1 = NULL;
  struct vector3 path_llf, path_urb;
  double R = (rx_radius_3d);
  path_bounding_box(&amp;vm-&gt;pos, mv, &amp;path_llf, &amp;path_urb, rx_radius_3d);
  int x_neg = 0, x_pos = 0, y_neg = 0, y_pos = 0, z_neg = 0, z_pos = 0;
  if (!(sv-&gt;world_edge &amp; X_POS_BIT) &amp;&amp; path_urb.x + R &gt; x_fineparts[sv-&gt;urb.x])
    x_pos = 1;
  if (!(sv-&gt;world_edge &amp; X_NEG_BIT) &amp;&amp; path_llf.x - R &lt; x_fineparts[sv-&gt;llf.x])
    x_neg = 1;
  if (!(sv-&gt;world_edge &amp; Y_POS_BIT) &amp;&amp; path_urb.y + R &gt; y_fineparts[sv-&gt;urb.y])
    y_pos = 1;
  if (!(sv-&gt;world_edge &amp; Y_NEG_BIT) &amp;&amp; path_llf.y - R &lt; y_fineparts[sv-&gt;llf.y])
    y_neg = 1;
  if (!(sv-&gt;world_edge &amp; Z_POS_BIT) &amp;&amp; path_urb.z + R &gt; z_fineparts[sv-&gt;urb.z])
    z_pos = 1;
  if (!(sv-&gt;world_edge &amp; Z_NEG_BIT) &amp;&amp; path_llf.z - R &lt; z_fineparts[sv-&gt;llf.z])
    z_neg = 1;
  if (x_pos) {
    struct subvolume *new_sv = sv + (nz_parts - 1) * (ny_parts - 1);
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, 0.0, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (y_pos) {
      struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, R, 0.0, x_fineparts,
          y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_pos)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, R, R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_neg)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, R, -R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    }
    if (y_neg) {
      struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, -R, 0.0,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_pos)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_neg)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, -R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    }
    if (z_pos)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_neg)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, -R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  }
  if (x_neg) {
    struct subvolume *new_sv = sv - (nz_parts - 1) * (ny_parts - 1);
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, 0.0, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (y_pos) {
      struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, R, 0.0,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_pos)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_neg)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, -R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    }
    if (y_neg) {
      struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, -R, 0.0,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_pos)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
      if (z_neg)
        shead1 = expand_collision_list_for_neighbor(world,
            sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, -R,
            x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    }
    if (z_pos)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_neg)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, -R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  }
  if (y_pos) {
    struct subvolume *new_sv = sv + (nz_parts - 1);
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, 0.0, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_pos)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_neg)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, -R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  }
  if (y_neg) {
    struct subvolume *new_sv = sv - (nz_parts - 1);
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, 0.0, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_pos)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
    if (z_neg)
      shead1 = expand_collision_list_for_neighbor(world,
          sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, -R,
          x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  }
  if (z_pos)
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, R, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  if (z_neg)
    shead1 = expand_collision_list_for_neighbor(world,
        sv, vm, sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, -R, x_fineparts,
        y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
  return shead1;
}
struct sp_collision *expand_collision_partner_list_for_neighbor(
    struct subvolume *sv, struct volume_molecule *vm, struct vector3 *mv,
    struct subvolume *new_sv, struct vector3 *path_llf,
    struct vector3 *path_urb, struct sp_collision *shead1, double trim_x,
    double trim_y, double trim_z, double *x_fineparts, double *y_fineparts,
    double *z_fineparts, int rx_hashsize, struct rxn **reaction_hash) {
  struct species *spec = vm-&gt;properties;
  struct sp_collision *smash;
  struct vector3 new_sv_llf, new_sv_urb;
  new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
  new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
  new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
  new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
  new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
  new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
  if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
    return shead1;
  int moving_tri_molecular_flag = 0, moving_bi_molecular_flag = 0,
      moving_mol_mol_grid_flag = 0;
  int col_tri_molecular_flag = 0, col_bi_molecular_flag = 0,
      col_mol_mol_grid_flag = 0;
  moving_tri_molecular_flag =
      ((spec-&gt;flags &amp; (CAN_VOLVOLVOL | CANT_INITIATE)) == CAN_VOLVOLVOL);
  moving_bi_molecular_flag =
      ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL);
  moving_mol_mol_grid_flag =
      ((spec-&gt;flags &amp; (CAN_VOLVOLSURF | CANT_INITIATE)) == CAN_VOLVOLSURF);
  double x_min, x_max;
  double y_min, y_max;
  double z_min, z_max;
  if (trim_x &lt; 0.0) {
    x_min = new_sv_urb.x + trim_x;
    x_max = new_sv_urb.x + EPS_C;
  } else if (trim_x &gt; 0.0) {
    x_min = new_sv_llf.x - EPS_C;
    x_max = new_sv_llf.x + trim_x;
  } else {
    x_min = new_sv_llf.x - EPS_C;
    x_max = new_sv_urb.x + EPS_C;
  }
  if (trim_y &lt; 0.0) {
    y_min = new_sv_urb.y + trim_y;
    y_max = new_sv_urb.y + EPS_C;
  } else if (trim_y &gt; 0.0) {
    y_min = new_sv_llf.y - EPS_C;
    y_max = new_sv_llf.y + trim_y;
  } else {
    y_min = new_sv_llf.y - EPS_C;
    y_max = new_sv_urb.y + EPS_C;
  }
  if (trim_z &lt; 0.0) {
    z_min = new_sv_urb.z + trim_z;
    z_max = new_sv_urb.z + EPS_C;
  } else if (trim_z &gt; 0.0) {
    z_min = new_sv_llf.z - EPS_C;
    z_max = new_sv_llf.z + trim_z;
  } else {
    z_min = new_sv_llf.z - EPS_C;
    z_max = new_sv_urb.z + EPS_C;
  }
  struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
  for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
    psl_next = psl-&gt;next;
    if (psl-&gt;properties == NULL) {
      psl_head = &amp;psl-&gt;next;
      continue;
    }
    if (psl-&gt;head == NULL) {
      *psl_head = psl-&gt;next;
      ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
      mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
      continue;
    } else
      psl_head = &amp;psl-&gt;next;
    int preliminary_check = 0;
    if(spec-&gt;flags &amp; EXTERNAL_SPECIES){
        preliminary_check =trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, 
                                                                 (struct abstract_molecule *)psl-&gt;head);
    }
    else{
        preliminary_check = trigger_bimolecular_preliminary(reaction_hash, rx_hashsize,
                                        spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
                                        spec, psl-&gt;properties);
    }
    col_tri_molecular_flag =
        moving_tri_molecular_flag &amp;&amp;
        ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLVOL) == CAN_VOLVOLVOL);
    col_bi_molecular_flag =
        moving_bi_molecular_flag &amp;&amp;
        ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOL) == CAN_VOLVOL) &amp;&amp; preliminary_check;
    col_mol_mol_grid_flag =
        moving_mol_mol_grid_flag &amp;&amp;
        ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLSURF) == CAN_VOLVOLSURF);
    if (col_bi_molecular_flag || col_tri_molecular_flag ||
        col_mol_mol_grid_flag) {
      struct volume_molecule *mp;
      for (mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
        if (mp-&gt;properties == NULL)
          continue;
        if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
          continue;
        if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
          continue;
        if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
          continue;
        smash = (struct sp_collision *)CHECKED_MEM_GET(
            sv-&gt;local_storage-&gt;sp_coll, "collision data");
        smash-&gt;t = 0.0;
        smash-&gt;t_start = 0.0;
        smash-&gt;pos_start.x = vm-&gt;pos.x;
        smash-&gt;pos_start.y = vm-&gt;pos.y;
        smash-&gt;pos_start.z = vm-&gt;pos.z;
        smash-&gt;sv_start = sv;
        smash-&gt;disp.x = mv-&gt;x;
        smash-&gt;disp.y = mv-&gt;y;
        smash-&gt;disp.z = mv-&gt;z;
        smash-&gt;loc.x = 0.0;
        smash-&gt;loc.y = 0.0;
        smash-&gt;loc.z = 0.0;
        smash-&gt;moving = spec;
        smash-&gt;target = (void *)mp;
        smash-&gt;what = 0;
        if (col_bi_molecular_flag) {
          smash-&gt;what |= COLLIDE_VOL;
        }
        if (col_tri_molecular_flag) {
          smash-&gt;what |= COLLIDE_VOL_VOL;
        }
        if (col_mol_mol_grid_flag) {
          smash-&gt;what |= COLLIDE_VOL_SURF;
        }
        smash-&gt;next = shead1;
        shead1 = smash;
      }
    }
  }
  return shead1;
}
struct volume_molecule *diffuse_3D(
    struct volume *world,
    struct volume_molecule *vm,
    double max_time) {
  world-&gt;diffuse_3d_calls++;
  struct species* spec = vm-&gt;properties;
  if (spec == NULL) {
    mcell_internal_error(
        "Attempted to take a diffusion step for a defunct molecule.");
  }
  int mol_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURF) == CAN_VOLSURF);
  int mol_grid_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURFSURF) == CAN_VOLSURFSURF);
  if (vm-&gt;get_space_step(vm) &lt;= 0.0) {
    vm-&gt;t += max_time;
    return vm;
  }
#ifdef DEBUG_DIFFUSION
  DUMP_CONDITION3(
  		dump_volume_molecule(vm, "", true, "Diffusing vm:", world-&gt;current_iterations, vm-&gt;t, true);
  );
#endif
  int inertness = 0;
  set_inertness_and_maxtime(world, vm, &amp;max_time, &amp;inertness);
  ASSERT_FOR_MCELL4(inertness == 0);
  int calculate_displacement = 1;
  int redo_expand_collision_list_flag = 0;
  double steps = 1.0;
  double t_steps = 1.0;
  double rate_factor = 1.0;
  double r_rate_factor = 1.0;
  struct vector3 displacement;    struct vector3 displacement2; 
  bool displacement_printed = false;   bool timing_printed = false; 
pretend_to_call_diffuse_3D: ; 
  struct subvolume *sv = vm-&gt;subvol;
  if ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL &amp;&amp;
      inertness &lt; inert_to_all) {
    determine_mol_mol_reactions(world, vm, &amp;shead, &amp;stail, inertness);
  }
  if (calculate_displacement) {
    compute_displacement(world, shead, vm, &amp;displacement, &amp;displacement2,
      &amp;rate_factor, &amp;r_rate_factor, &amp;steps, &amp;t_steps, max_time);
  }
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      if (!timing_printed) {
        MCell::dump_vol_mol_timing(
            "- Timing vm", world-&gt;current_iterations, vm-&gt;id,
            vm-&gt;t, max_time, vm-&gt;t + vm-&gt;t2,
            rate_factor, r_rate_factor, steps, t_steps
        );
        timing_printed = true;
      }
  );
#endif
#ifdef DEBUG_DIFFUSION
  DUMP_CONDITION3(
		if (!displacement_printed) {
			dump_vector3(displacement, "  displacement:");
            std::cout &lt;&lt; "t_steps: " &lt;&lt; t_steps &lt;&lt; "\n";
			displacement_printed = true;
		}
  );
#endif
  if (world-&gt;use_expanded_list &amp;&amp;
      ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) &amp;&amp;
      !inertness) {
    shead_exp = expand_collision_list(world,
      vm, &amp;displacement, sv, world-&gt;rx_radius_3d, world-&gt;ny_parts,
      world-&gt;nz_parts, world-&gt;x_fineparts, world-&gt;y_fineparts,
      world-&gt;z_fineparts, world-&gt;rx_hashsize, world-&gt;reaction_hash);
    if (stail != NULL)
      stail-&gt;next = shead_exp;
    else {
      if (shead != NULL)
        mcell_internal_error("Collision lists corrupted.  While expanding the "
                             "collision lists, expected shead to be NULL, but "
                             "it wasn't.");
      shead = shead_exp;
    }
  }
  struct wall* reflectee = NULL;
  struct collision *smash;        do {
    if (world-&gt;use_expanded_list &amp;&amp; redo_expand_collision_list_flag) {
      redo_collision_list(world, &amp;shead, &amp;stail, &amp;shead_exp, vm, &amp;displacement, sv);
    }
    struct collision* shead2 = ray_trace(world, &amp;(vm-&gt;pos), shead, sv, &amp;displacement, reflectee);
    if (shead2 == NULL) {
      mcell_internal_error("ray_trace returned NULL.");
    }
    if (shead2-&gt;next != NULL) {
      shead2 =
          (struct collision *)ae_list_sort((struct abstract_element *)shead2);
    }
#ifdef DEBUG_COLLISIONS
    DUMP_CONDITION3(
    		dump_collisions(shead2);
    );
#endif
    struct vector3* loc_certain = NULL;
    struct collision *tentative = shead2;
    for (smash = shead2; smash != NULL; smash = smash-&gt;next) {
      if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
        if (((smash-&gt;what &amp; COLLIDE_VOL) != 0) &amp;&amp;
            (world-&gt;rxn_flags.vol_vol_reaction_flag)) {
          world-&gt;vol_vol_colls++;
        }
      }
      if (smash-&gt;t &gt;= 1.0 || smash-&gt;t &lt; 0.0) {
        if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
          mcell_internal_error(
              "Detected a mol-mol collision outside of the 0.0...1.0 time "
              "window.  Iteration %lld, time of collision %.8e, mol1=%s, "
              "mol2=%s",
              world-&gt;current_iterations, smash-&gt;t, vm-&gt;properties-&gt;sym-&gt;name,
              ((struct volume_molecule *)smash-&gt;target)-&gt;properties-&gt;sym-&gt;name);
        }
        smash = NULL;
        break;
      }
      if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
        if (smash-&gt;t &lt; EPS_C) {
          continue;
        }
        if (collide_and_react_with_vol_mol(world, smash, vm, &amp;tentative,
          &amp;displacement, loc_certain, t_steps, r_rate_factor) == 1) {
          FREE_COLLISION_LISTS();
          return NULL;
        } else {
          continue;
        }
      } else if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
        struct wall* w = (struct wall *)smash-&gt;target;
        if (w-&gt;grid != NULL &amp;&amp; (mol_grid_flag || mol_grid_grid_flag) &amp;&amp;
          inertness &lt; inert_to_all) {
          int destroyed = collide_and_react_with_surf_mol(world, smash, vm,
            &amp;tentative, &amp;loc_certain, t_steps, mol_grid_flag, mol_grid_grid_flag,
            r_rate_factor);
          if (destroyed == 1) {
            FREE_COLLISION_LISTS();
            return NULL;
          } else if (destroyed == 0) {
            continue;
          }
        }
        if ((spec-&gt;flags &amp; CAN_VOLWALL) != 0) {
          int destroyed = collide_and_react_with_walls(world, smash, vm,
            &amp;tentative, &amp;loc_certain, t_steps, inertness, r_rate_factor);
          if (destroyed == 1) {
            FREE_COLLISION_LISTS();
            return NULL;
          } else if (destroyed == 0) {
            continue;
          }
        }
        if (reflect_or_periodic_bc(world, smash, &amp;displacement, &amp;vm, &amp;reflectee,
            &amp;tentative, &amp;t_steps) == 1) {
          FREE_COLLISION_LISTS();
          calculate_displacement = 0;
          if (vm-&gt;properties == NULL) {
            mcell_internal_error("A defunct molecule is diffusing.");
          }
          goto pretend_to_call_diffuse_3D;
        }
        redo_expand_collision_list_flag = 1; 
        break;
      } else if ((smash-&gt;what &amp; COLLIDE_SUBVOL) != 0) {
        collide_and_react_with_subvol(
          world, smash, &amp;displacement, &amp;vm, &amp;tentative, &amp;t_steps);
        FREE_COLLISION_LISTS();
        calculate_displacement = 0;
        if (vm-&gt;properties == NULL) {
          mcell_internal_error("A defunct molecule is diffusing.");
        }
        goto pretend_to_call_diffuse_3D;
      }
    }
    if (shead2 != NULL) {
      mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);
    }
  } while (smash != NULL);
  vm-&gt;pos.x += displacement.x;
  vm-&gt;pos.y += displacement.y;
  vm-&gt;pos.z += displacement.z;
  vm-&gt;t += t_steps;
  if (inertness == inert_to_all) 
  {
    inertness = inert_to_mol;
    t_steps = vm-&gt;get_time_step(vm);
    displacement = displacement2;
    calculate_displacement = 0;
    goto pretend_to_call_diffuse_3D;
  }
  vm-&gt;index = -1;
  vm-&gt;previous_wall = NULL;
  if (shead != NULL)
    mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
#ifdef DEBUG_DIFFUSION
  if (vm-&gt;properties != NULL) {
    DUMP_CONDITION3(
    );
  }
#endif
  return vm;
}
int move_sm_on_same_triangle(
    struct volume *state,
    struct surface_molecule *sm,
    struct vector2 *new_loc,
    struct periodic_image *previous_box,
    struct wall *new_wall,
    struct hit_data *hd_info) {
  unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
  if (new_idx &gt;= sm-&gt;grid-&gt;n_tiles) {
    mcell_internal_error("After ray_trace_2D, selected u, v coordinates "
                         "map to an out-of-bounds grid cell.  uv=(%.2f, "
                         "%.2f) sm=%d/%d",
                         new_loc-&gt;u, new_loc-&gt;v, new_idx, sm-&gt;grid-&gt;n_tiles);
  }
  struct surface_molecule_list *sm_list = sm-&gt;grid-&gt;sm_list[new_idx];
  if (new_idx != sm-&gt;grid_index) {
    if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
        (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
      if (hd_info != NULL) {
        delete_void_list((struct void_list *)hd_info);
        hd_info = NULL;
      }
      return 1;     }
    remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
    sm-&gt;grid_index = new_idx;
    sm-&gt;grid-&gt;sm_list[new_idx] = add_surfmol_with_unique_pb_to_list(
      sm-&gt;grid-&gt;sm_list[new_idx], sm);
    assert(sm-&gt;grid-&gt;sm_list[new_idx] != NULL);
    count_moved_surface_mol(
      state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
      state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
  } else {
    count_moved_surface_mol(
      state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
      state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
  }
  sm-&gt;s_pos.u = new_loc-&gt;u;
  sm-&gt;s_pos.v = new_loc-&gt;v;
  return 0;
}
int move_sm_to_new_triangle(
    struct volume *state,
    struct surface_molecule *sm,
    struct vector2 *new_loc,
    struct periodic_image *previous_box,
    struct wall *new_wall,
    struct hit_data *hd_info) {
  if (new_wall-&gt;grid == NULL) {
    if (create_grid(state, new_wall, NULL))
      mcell_allocfailed("Failed to create a grid for a wall.");
  }
  unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
  if (new_idx &gt;= new_wall-&gt;grid-&gt;n_tiles) {
    mcell_internal_error(
        "After ray_trace_2D to a new wall, selected u, v coordinates map "
        "to an out-of-bounds grid cell.  uv=(%.2f, %.2f) sm=%d/%d",
        new_loc-&gt;u, new_loc-&gt;v, new_idx, new_wall-&gt;grid-&gt;n_tiles);
  }
  struct surface_molecule_list *sm_list = new_wall-&gt;grid-&gt;sm_list[new_idx];
  if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
      (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
    if (hd_info != NULL) {
      delete_void_list((struct void_list *)hd_info);
      hd_info = NULL;
    }
    return 1;   }
  count_moved_surface_mol(
    state, sm, new_wall-&gt;grid, new_loc, state-&gt;count_hashmask,
    state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
  remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
  sm-&gt;grid-&gt;n_occupied--;
  sm-&gt;grid = new_wall-&gt;grid;
  sm-&gt;grid_index = new_idx;
  sm_list = add_surfmol_with_unique_pb_to_list(sm-&gt;grid-&gt;sm_list[new_idx], sm);
  assert(sm_list != NULL);
  sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] = sm_list;
  sm-&gt;grid-&gt;n_occupied++;
  sm-&gt;s_pos.u = new_loc-&gt;u;
  sm-&gt;s_pos.v = new_loc-&gt;v;
  return 0;
}
struct surface_molecule *diffuse_2D(
    struct volume *world,
    struct surface_molecule *sm,
    double max_time,
    double *advance_time) {
  struct species *spec = sm-&gt;properties;
  if (spec == NULL) {
    mcell_internal_error(
        "Attempted to take a 2-D diffusion step for a defunct molecule.");
  }
#ifdef DEBUG_DIFFUSION
  DUMP_CONDITION3(
      dump_surface_molecule(sm, "", true, "Diffusing sm:", world-&gt;current_iterations, sm-&gt;t, true);
  );
#endif
  if (sm-&gt;get_space_step(sm) &lt;= 0.0) {
    sm-&gt;t += max_time;
    return sm;
  }
  if (sm-&gt;get_time_step(sm) &gt; 1.0) {
    double sched_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, sm-&gt;t);
    double f = 1 + 0.2 * ((sched_time - sm-&gt;birthday)/world-&gt;time_unit);
    if (f &lt; 1)
      mcell_internal_error("A %s molecule is scheduled to move before it was "
                           "born [birthday=%.15g, t=%.15g]",
                           spec-&gt;sym-&gt;name, sm-&gt;birthday, sched_time);
    if (max_time &gt; f)
      max_time = f;
  }
  double steps = 0.0;
  double t_steps = 0.0;
  double space_factor = 0.0;
  if (sm-&gt;get_time_step(sm) &gt; max_time) {
    t_steps = max_time;
    steps = max_time / sm-&gt;get_time_step(sm);
  } else {
    t_steps = sm-&gt;get_time_step(sm);
    steps = 1.0;
  }
  if (steps &lt; EPS_C) {
    steps = EPS_C;
    t_steps = EPS_C * sm-&gt;get_time_step(sm);
  }
  if (steps == 1.0)
    space_factor = sm-&gt;get_space_step(sm);
  else
    space_factor = sm-&gt;get_space_step(sm) * sqrt(steps);
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_surf_mol_timing(
          "- Timing sm", world-&gt;current_iterations, sm-&gt;id,
          sm-&gt;t, max_time, sm-&gt;t + sm-&gt;t2,
          space_factor, steps, t_steps
      );   );
#endif
  world-&gt;diffusion_number++;
  world-&gt;diffusion_cumtime += steps;
  struct periodic_image previous_box = {sm-&gt;periodic_box-&gt;x,
                                        sm-&gt;periodic_box-&gt;y,
                                        sm-&gt;periodic_box-&gt;z
                                       };
  struct hit_data *hd_info = NULL;
  for (int find_new_position = (SURFACE_DIFFUSION_RETRIES + 1);
       find_new_position &gt; 0; find_new_position--) {
    hd_info = NULL;
    struct vector2 displacement;
    pick_2D_displacement(&amp;displacement, space_factor, world-&gt;rng);
#ifdef DEBUG_DIFFUSION
    DUMP_CONDITION3(
        dump_vector2(displacement, "  displacement:")
    );
#endif
    if (sm-&gt;properties-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
      double disp_length = sqrt(displacement.u * displacement.u +
                         displacement.v * displacement.v);
      if (disp_length &gt; sm-&gt;properties-&gt;max_step_length) {
        displacement.u *= (sm-&gt;properties-&gt;max_step_length / disp_length);
        displacement.v *= (sm-&gt;properties-&gt;max_step_length / disp_length);
      }
    }
    struct vector2 new_loc;
    struct rxn *rxp = NULL;
    int kill_me = 0;
    struct wall *new_wall = ray_trace_2D(world, sm, &amp;displacement, &amp;new_loc,
      &amp;kill_me, &amp;rxp, &amp;hd_info);
    if (new_wall == NULL) {
      if (kill_me == 1) {
        if (rxp == NULL) {
          mcell_internal_error("Error in 'ray_trace_2D()' after hitting "
                               "ABSORPTIVE region border.");
        }
        if (hd_info != NULL) {
          count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
        }
        int result = outcome_unimolecular(world, rxp, 0,
                                      (struct abstract_molecule *)sm, sm-&gt;t);
        if (result != RX_DESTROY) {
          mcell_internal_error("Molecule should disappear after hitting "
                               "ABSORPTIVE region border.");
        }
        delete_void_list((struct void_list *)hd_info);
        hd_info = NULL;
        return NULL;
      }
      if (hd_info != NULL) {
        delete_void_list((struct void_list *)hd_info);
        hd_info = NULL;
      }
      continue;     }
    if (new_wall == sm-&gt;grid-&gt;surface) {
      if (move_sm_on_same_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
        continue; 
      }
    }
    else {
      if (move_sm_to_new_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
        continue;
      }
    }
    find_new_position = 0;
  }
  if (hd_info != NULL) {
    count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
    delete_void_list((struct void_list *)hd_info);
    hd_info = NULL;
  }
  *advance_time = t_steps;
  return sm;
}
struct surface_molecule *
react_2D_all_neighbors(struct volume *world, struct surface_molecule *sm,
                       double t, enum notify_level_t molecule_collision_report,
                       int grid_grid_reaction_flag,
                       long long *surf_surf_colls) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_react_2D_all_neighbors_timing(t, sm-&gt;t);
  );
#endif
  int l = 0;
  int num_matching_rxns = 0;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  struct tile_neighbor *tile_nbr_head = NULL, *curr;
  int list_length = 0; 
  if ((u_int)sm-&gt;grid_index &gt;= sm-&gt;grid-&gt;n_tiles) {
    mcell_internal_error("tile index %u is greater or equal number_of_tiles %u",
                         (u_int)sm-&gt;grid_index, sm-&gt;grid-&gt;n_tiles);
  }
  find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1, &amp;tile_nbr_head,
                      &amp;list_length);
  if (tile_nbr_head == NULL)
    return sm; 
  const int num_nbrs = list_length;
  int max_size = num_nbrs * MAX_MATCHING_RXNS;
  std::vector&lt;struct rxn *&gt; rxn_array(max_size);
  std::vector&lt;double&gt; cf(max_size); 
  std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
  local_prob_factor = 3.0 / num_nbrs;
  for (int kk = 0; kk &lt; max_size; kk++) {     rxn_array[kk] = NULL;
    smol[kk] = NULL;
    cf[kk] = 0;
  }
  for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
    struct surface_molecule_list *sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]; 
    if (sm_list == NULL || sm_list-&gt;sm == NULL)
      continue;
    struct surface_molecule *smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
        dump_surface_molecule(smp, "", true, "  checking in react_2D_all_neighbors: ", world-&gt;current_iterations, 0.0, true);
    );
#endif
    if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
        (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
      if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
        if (walls_belong_to_at_least_one_different_restricted_region(
                world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp))
          continue;
        if (walls_belong_to_at_least_one_different_restricted_region(
                world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm))
          continue;
      }
    }
    if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
      num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)sm,
        (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient, matching_rxns);
    } 
    else{     
    num_matching_rxns = trigger_bimolecular(
        world-&gt;reaction_hash, world-&gt;rx_hashsize, sm-&gt;properties-&gt;hashval,
        smp-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
        (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient,
        matching_rxns);
    }
    if (num_matching_rxns &gt; 0) {
      if (molecule_collision_report == NOTIFY_FULL) {
        if (grid_grid_reaction_flag)
          surf_surf_colls++;
      }
      for (int jj = 0; jj &lt; num_matching_rxns; jj++) {
        if (matching_rxns[jj] != NULL) {
          if (matching_rxns[jj]-&gt;prob_t != NULL)
            update_probs(world, matching_rxns[jj], sm-&gt;t);
          rxn_array[l] = matching_rxns[jj];
          cf[l] = t / (curr-&gt;grid-&gt;binding_factor);
          smol[l] = smp;
          l++;
        }
      }
      n += num_matching_rxns;
    }
  }
  delete_tile_neighbor_list(tile_nbr_head);
  if (n == 0) {
    return sm;   } else if (n == 1) {
    i = test_bimolecular(rxn_array[0], cf[0], local_prob_factor, NULL, NULL,
                         world-&gt;rng);
    j = 0;
  } else {
    int all_neighbors_flag = 1;
    j = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor, n, &amp;(i),
                              world-&gt;rng, all_neighbors_flag);
  }
  if ((j == RX_NO_RX) || (i &lt; RX_LEAST_VALID_PATHWAY)) {
    return sm;   }
  int outcome_bimol_result = outcome_bimolecular(
      world, rxn_array[j], i, (struct abstract_molecule *)sm,
      (struct abstract_molecule *)smol[j], sm-&gt;orient, smol[j]-&gt;orient, sm-&gt;t,
      NULL, NULL);
  if (outcome_bimol_result == RX_DESTROY) {
    mem_put(sm-&gt;birthplace, sm);
    return NULL;
  }
  return sm;
}
void clean_up_old_molecules(struct storage *local) {
  if (local-&gt;timer-&gt;defunct_count &gt; MIN_DEFUNCT_FOR_GC &amp;&amp;
      MAX_DEFUNCT_FRAC * (local-&gt;timer-&gt;count) &lt; local-&gt;timer-&gt;defunct_count) {
    struct abstract_molecule *am;
    am = (struct abstract_molecule *)schedule_cleanup(local-&gt;timer,
                                                      *is_defunct_molecule);
    while (am != NULL) {
      struct abstract_molecule *temp = am;
      am = am-&gt;next;
      if ((temp-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
        temp-&gt;next = NULL;
        mem_put(temp-&gt;birthplace, temp);
      } else {
        temp-&gt;flags &amp;= ~IN_SCHEDULE;
      }
    }
  }
}
void reschedule_surface_molecules(
    struct volume *state, struct storage *local,
    struct abstract_molecule *am) {
  struct vector3 pos3d;
  struct surface_molecule *sm = (struct surface_molecule *)(void *)am;
  uv2xyz(&amp;sm-&gt;s_pos, sm-&gt;grid-&gt;surface, &amp;pos3d);
  struct subvolume *sv = find_subvolume(state, &amp;pos3d, sm-&gt;grid-&gt;subvol);
  if (sv-&gt;local_storage != local) {
    struct surface_molecule *sm_new =
        (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol,
                                                   "surface molecule");
    memcpy(sm_new, sm, sizeof(struct surface_molecule));
    sm_new-&gt;next = NULL;
    sm_new-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
    if (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] &amp;&amp; 
        (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm == sm)) {
      sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm = sm_new;
      sm-&gt;grid = NULL;
      sm-&gt;grid_index = 0;
    }
    mem_put(sm-&gt;birthplace, sm);
    if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, sm_new))
      mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
                        "after migrating to a new memory store.",
                        am-&gt;properties-&gt;sym-&gt;name);
  } else {
    if (schedule_add_mol(local-&gt;timer, am))
      mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
                        "after taking a diffusion step.",
                        am-&gt;properties-&gt;sym-&gt;name);
  }
}
void run_timestep(struct volume *state, struct storage *local,
                  double release_time, double checkpt_time) {
  struct abstract_molecule *am;
  clean_up_old_molecules(local);
#ifdef MCELL3_SORTED_MOLS_ON_RUN_TIMESTEP
  #ifdef DUMP_LOCAL_SCHEDULE_HELPER
    dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
  #endif
  sort_schedule_by_time_and_id(local-&gt;timer);
  #ifdef DUMP_LOCAL_SCHEDULE_HELPER
    dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
  #endif
#endif
  while (local-&gt;timer-&gt;current != NULL) {
#ifdef DUMP_LOCAL_SCHEDULE_HELPER
    dump_schedule_helper(local-&gt;timer, "local", "", "", true);
#endif
#ifdef MCELL3_4_ALWAYS_SORT_MOLS_BY_TIME_AND_ID
#ifdef DUMP_LOCAL_SCHEDULE_HELPER
  dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
#endif
  sort_schedule_by_time_and_id(local-&gt;timer);
#ifdef DUMP_LOCAL_SCHEDULE_HELPER
  dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
#endif
#endif
    am = (struct abstract_molecule *)schedule_next(local-&gt;timer);
    if (am-&gt;properties == NULL)     {
      if ((am-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
        am-&gt;next = NULL;
        mem_put(am-&gt;birthplace, am);
      } else
        am-&gt;flags &amp;= ~IN_SCHEDULE;
      if (local-&gt;timer-&gt;defunct_count &gt; 0)
        local-&gt;timer-&gt;defunct_count--;
      continue;
    }
#ifdef DEBUG_SCHEDULER
    {
      struct volume *world = state;
      DUMP_CONDITION3(
          struct volume_molecule* vm = (struct volume_molecule*)am;
          dump_volume_molecule(vm, "", true, "\n* Running scheduled action: ", world-&gt;current_iterations, vm-&gt;t, true);
      );
    }
#endif
    am-&gt;flags &amp;= ~IN_SCHEDULE;
    if (am-&gt;t2 &lt; EPS_C || am-&gt;t2 &lt; EPS_C * am-&gt;t) {
      if (!check_for_unimolecular_reaction(state, am)) {
        continue;
      }
    }
    double surface_mol_advance_time = 0;
    struct wall *current_wall = NULL;
    double max_time;
#ifdef MCELL_ALWAYS_DIFFUSE
    int can_diffuse = 1;
#else
    int can_diffuse = ((am-&gt;flags &amp; ACT_DIFFUSE) != 0);
#endif
    if (can_diffuse) {
      max_time = checkpt_time - am-&gt;t;
      if (local-&gt;max_timestep &lt; max_time)
        max_time = local-&gt;max_timestep;
      if ((am-&gt;flags &amp; (ACT_REACT)) != 0 &amp;&amp; am-&gt;t2 &lt; max_time)
        max_time = am-&gt;t2;
      if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
        double save_sched_time = am-&gt;t;
        if (max_time &gt; release_time - am-&gt;t)
          max_time = release_time - am-&gt;t;
        if (am-&gt;properties-&gt;flags &amp; (CAN_VOLVOLVOL | CAN_VOLVOLSURF))
          am = (struct abstract_molecule *)diffuse_3D_big_list(
              state, (struct volume_molecule *)am, max_time);
        else
          am = (struct abstract_molecule *)diffuse_3D(
              state, (struct volume_molecule *)am, max_time);
        if (am != NULL)         {
          if ((am-&gt;flags &amp; ACT_REACT) != 0) {
            am-&gt;t2 -= am-&gt;t - save_sched_time;
            if (am-&gt;t2 &lt; 0)
              am-&gt;t2 = 0;
          }
        } else
          continue;
      } else {
        if (max_time &gt; release_time - am-&gt;t) {
          max_time = release_time - am-&gt;t;
        }
        current_wall = ((struct surface_molecule *)am)-&gt;grid-&gt;surface;
        am = (struct abstract_molecule *)diffuse_2D(
            state, (struct surface_molecule *)am, max_time,
            &amp;surface_mol_advance_time);
        if (am == NULL) {
          continue;
        }
      }
    }
    else {
#ifdef DEBUG_DIFFUSION
      struct volume *world = state;
      if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
        DUMP_CONDITION3(
            dump_volume_molecule((struct volume_molecule *)am, "", true, "Not diffusing vm:", world-&gt;current_iterations, am-&gt;t, true);
        );
      }
      else {
        DUMP_CONDITION3(
            dump_surface_molecule((struct surface_molecule *)am, "", true, "Not diffusing sm:", world-&gt;current_iterations, am-&gt;t, true);
        );
      }
#endif
    }
    int can_surface_mol_react = (am-&gt;get_flags(am) &amp; (CAN_SURFSURFSURF | CAN_SURFSURF));
    if (((am-&gt;flags &amp; TYPE_SURF) != 0) &amp;&amp; can_surface_mol_react) {
      if (!can_diffuse) 
      {
        max_time = checkpt_time - am-&gt;t;
        if (am-&gt;t2 &lt; max_time &amp;&amp; (am-&gt;flags &amp; (ACT_REACT)) != 0)
          max_time = am-&gt;t2;
        if (max_time &gt; release_time - am-&gt;t)
          max_time = release_time - am-&gt;t;
        if (am-&gt;get_time_step(am) &lt; max_time)
          max_time = am-&gt;get_time_step(am);
        surface_mol_advance_time = max_time;
      } else
        max_time = surface_mol_advance_time;
      if (can_surface_mol_react) {
        if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURF)) ==
            CAN_SURFSURF) {
          am = (struct abstract_molecule *)react_2D_all_neighbors(
              state, (struct surface_molecule *)am, max_time,
              state-&gt;notify-&gt;molecule_collision_report,
              state-&gt;rxn_flags.surf_surf_reaction_flag,
              &amp;(state-&gt;surf_surf_colls));
          if (am == NULL)
            continue;
        }
        if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURFSURF)) ==
            CAN_SURFSURFSURF) {
          am = (struct abstract_molecule *)react_2D_trimol_all_neighbors(
              state, (struct surface_molecule *)am, max_time,
              state-&gt;notify-&gt;molecule_collision_report,
              state-&gt;notify-&gt;final_summary,
              state-&gt;rxn_flags.surf_surf_surf_reaction_flag,
              &amp;(state-&gt;surf_surf_surf_colls));
          if (am == NULL)
            continue;
        }
      }
    }
    if ((am-&gt;flags &amp; TYPE_SURF) != 0 &amp;&amp; (can_diffuse || can_surface_mol_react)) {
      am-&gt;t += surface_mol_advance_time;
      if ((am-&gt;flags &amp; ACT_REACT) != 0) {
        int can_surf_react = ((am-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0);
        if (can_surf_react &amp;&amp; !distinguishable(am-&gt;t2, (double)FOREVER, EPS_C)) {
          am-&gt;t2 = 0;
          am-&gt;flags |= ACT_CHANGE;         }
        else {
          am-&gt;t2 -= surface_mol_advance_time;
          if (am-&gt;t2 &lt; 0) {
            am-&gt;t2 = 0;
          }
          if ((current_wall !=
              ((struct surface_molecule *)am)-&gt;grid-&gt;surface) &amp;&amp;
              (am-&gt;t2 &gt; EPS_C || am-&gt;t2 &gt; EPS_C * am-&gt;t)) {
            am-&gt;t2 = 0;
            am-&gt;flags |= ACT_CHANGE;           }
        }
      }
    } else if (!can_diffuse) {
      if (am-&gt;t2 == 0)
        am-&gt;t += MAX_UNI_TIMESKIP;
      else {
        am-&gt;t += am-&gt;t2;
        am-&gt;t2 = 0;
      }
    }
    am-&gt;flags |= IN_SCHEDULE;
    double t = ceil(am-&gt;t) * (1.0 + 0.1 * EPS_C);
    if (!distinguishable(t, am-&gt;t, EPS_C))
      am-&gt;t = t;
    if (am-&gt;flags &amp; TYPE_SURF) {
      reschedule_surface_molecules(state, local, am);
    } else {
      if (schedule_add(
              ((struct volume_molecule *)am)-&gt;subvol-&gt;local_storage-&gt;timer, am))
        mcell_allocfailed("Failed to add a '%s' volume molecule to scheduler "
                          "after taking a diffusion step.",
                          am-&gt;properties-&gt;sym-&gt;name);
    }
  }
  if (local-&gt;timer-&gt;error)
    mcell_internal_error("Scheduler reported an out-of-memory error while "
                         "retrieving molecules, but this should never happen.");
}
void run_clamp(struct volume *world, double t_now) {
  int this_count = 0;
  static int total_count = 0;
  for (struct clamp_data *cdp = world-&gt;clamp_list; cdp != NULL; cdp = cdp-&gt;next) {
    if (cdp-&gt;objp == NULL) {
      continue;
    }
    for (struct clamp_data *cdpo = cdp; cdpo != NULL; cdpo = cdpo-&gt;next_obj) {
      for (struct clamp_data *cdpm = cdpo; cdpm != NULL; cdpm = cdpm-&gt;next_mol) {
        double n_collisions = cdpo-&gt;scaling_factor * cdpm-&gt;mol-&gt;space_step *
                       cdpm-&gt;clamp_value / cdpm-&gt;mol-&gt;time_step;
        if (cdpm-&gt;orient != 0) {
          n_collisions *= 0.5;
        }
        int n_emitted = poisson_dist(n_collisions, rng_dbl(world-&gt;rng));
        if (n_emitted == 0)
          continue;
        struct volume_molecule vm;
        vm.t = t_now + 0.5;
        vm.t2 = 0;
        vm.flags = IN_SCHEDULE | ACT_NEWBIE | TYPE_VOL | IN_VOLUME |
                  ACT_CLAMPED | ACT_DIFFUSE;
        vm.properties = cdpm-&gt;mol;
        initialize_diffusion_function((struct abstract_molecule*)&amp;vm);
        vm.mesh_name = NULL;
        vm.birthplace = NULL;
        vm.birthday = convert_iterations_to_seconds(
            world-&gt;start_iterations, world-&gt;time_unit,
            world-&gt;simulation_start_seconds, t_now);
        vm.subvol = NULL;
        vm.previous_wall = NULL;
        vm.index = 0;
        struct volume_molecule *vmp = NULL;
        this_count += n_emitted;
        while (n_emitted &gt; 0) {
          int idx = bisect_high(cdpo-&gt;cum_area, cdpo-&gt;n_sides,
                            rng_dbl(world-&gt;rng) *
                                cdpo-&gt;cum_area[cdp-&gt;n_sides - 1]);
          struct wall *w = cdpo-&gt;objp-&gt;wall_p[cdpo-&gt;side_idx[idx]];
          double s1 = sqrt(rng_dbl(world-&gt;rng));
          double s2 = rng_dbl(world-&gt;rng) * s1;
          struct vector3 v;
          v.x = w-&gt;vert[0]-&gt;x + s1 * (w-&gt;vert[1]-&gt;x - w-&gt;vert[0]-&gt;x) +
                s2 * (w-&gt;vert[2]-&gt;x - w-&gt;vert[1]-&gt;x);
          v.y = w-&gt;vert[0]-&gt;y + s1 * (w-&gt;vert[1]-&gt;y - w-&gt;vert[0]-&gt;y) +
                s2 * (w-&gt;vert[2]-&gt;y - w-&gt;vert[1]-&gt;y);
          v.z = w-&gt;vert[0]-&gt;z + s1 * (w-&gt;vert[1]-&gt;z - w-&gt;vert[0]-&gt;z) +
                s2 * (w-&gt;vert[2]-&gt;z - w-&gt;vert[1]-&gt;z);
          if (cdpm-&gt;orient == 1) {
            vm.index = 1;
          }
          else if (cdpm-&gt;orient == -1) {
            vm.index = -1;
          }
          else {
            vm.index = (rng_uint(world-&gt;rng) &amp; 2) - 1;
          }
          double eps = EPS_C * vm.index;
          s1 = fabs(v.x);
          s2 = fabs(v.y);
          if (s1 &lt; s2) {
            s1 = s2;
          }
          s2 = fabs(v.z);
          if (s1 &lt; s2) {
            s1 = s2;
          }
          if (s1 &gt; 1.0){
            eps *= s1;
          }
          vm.pos.x = v.x + w-&gt;normal.x * eps;
          vm.pos.y = v.y + w-&gt;normal.y * eps;
          vm.pos.z = v.z + w-&gt;normal.z * eps;
          vm.previous_wall = w;
          struct periodic_image periodic_box = {0, 0, 0};
          vm.periodic_box = &amp;periodic_box;
          if (vmp == NULL) {
            vmp = insert_volume_molecule(world, &amp;vm, vmp);
            if (vmp == NULL)
              mcell_allocfailed("Failed to insert a '%s' volume molecule while "
                                "concentration/flux clamping.",
                                vm.properties-&gt;sym-&gt;name);
            if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                                     cdpm-&gt;mol-&gt;hashval,
                                     (struct abstract_molecule *)vmp) != NULL) {
              vm.flags |= ACT_REACT;
              vmp-&gt;flags |= ACT_REACT;
            }
          } else {
            vmp = insert_volume_molecule(world, &amp;vm, vmp);
            if (vmp == NULL)
              mcell_allocfailed("Failed to insert a '%s' volume molecule while "
                                "concentration/flux clamping.",
                                vm.properties-&gt;sym-&gt;name);
          }
          n_emitted--;
        }
      }
    }
  }
  total_count += this_count;
}
void redo_collision_list(struct volume* world, struct collision** shead,
  struct collision** stail, struct collision** shead_exp, struct volume_molecule* m,
  struct vector3* displacement, struct subvolume* sv) {
  struct collision* st = *stail;
  struct collision* sh = *shead_exp;
  if (st != NULL) {
    st-&gt;next = NULL;
    if (sh != NULL) {
      mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
      sh = NULL;
    }
  } else if (sh != NULL) {
    mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
    sh = NULL;
    *shead = NULL;
  }
  if ((m-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
    sh = expand_collision_list(world, m, displacement, sv, world-&gt;rx_radius_3d,
      world-&gt;ny_parts, world-&gt;nz_parts, world-&gt;x_fineparts,
      world-&gt;y_fineparts, world-&gt;z_fineparts, world-&gt;rx_hashsize,
      world-&gt;reaction_hash);
    if (st != NULL)
      st-&gt;next = sh;
    else {
      if (*shead != NULL)
        mcell_internal_error("Collision lists corrupted.  While expanding "
                             "the collision lists, expected shead to be "
                             "NULL, but it wasn't.");
      *shead = sh;
    }
  }
  *stail = st;
  *shead_exp = sh;
}
static int collide_and_react_with_vol_mol(struct volume* world,
  struct collision* smash, struct volume_molecule* m, struct collision**
  tentative, struct vector3* displacement, struct vector3* loc_certain, double
  t_steps, double r_rate_factor) {
  struct abstract_molecule* am = (struct abstract_molecule *)smash-&gt;target;
  double factor = exact_disk(
      world, &amp;(smash-&gt;loc), displacement, world-&gt;rx_radius_3d, m-&gt;subvol,
      m, (struct volume_molecule *)am, world-&gt;use_expanded_list,
      world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
  if (factor &lt; 0) {     return 0;   }
  double scaling = factor * r_rate_factor;
  struct rxn* rx = smash-&gt;intermediate;
  if ((rx != NULL) &amp;&amp; (rx-&gt;prob_t != NULL)) {
    update_probs(world, rx, m-&gt;t);
  }
  struct species *spec = m-&gt;properties;
  struct periodic_image *periodic_box = m-&gt;periodic_box;
  int i = test_bimolecular(
    rx, scaling, 0, am, (struct abstract_molecule *)m, world-&gt;rng);
  if (i &lt; RX_LEAST_VALID_PATHWAY) {
    return 0;
  }
  if (loc_certain != NULL) {
  }
  int j = outcome_bimolecular(world, rx, i, (struct abstract_molecule *)m, am,
    0, 0, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc_certain);
  if (j != RX_DESTROY) {
    return 0;
  } else {
    struct collision* ttv = *tentative;
    for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
      if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
        continue;
      }
      if (m-&gt;properties == NULL) {
        continue;
      }
      if (!(m-&gt;properties-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
            COUNT_SOME_MASK)) {
        continue;
      }
      count_region_update(world, m, spec, m-&gt;id, periodic_box,
        ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
        ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
      if (ttv == smash) {
        break;
      }
    }
    *tentative = ttv;
  }
  return 1;
}
int collide_and_react_with_surf_mol(struct volume* world, struct collision* smash,
  struct volume_molecule* m, struct collision** tentative,
  struct vector3** loc_certain, double t_steps, int mol_grid_flag,
  int mol_grid_grid_flag, double r_rate_factor) {
  ASSERT_FOR_MCELL4(mol_grid_flag == 1);
  struct collision* ttv = *tentative;
  struct vector3* loc = *loc_certain;
  struct wall* w = (struct wall *)smash-&gt;target;
  double t_confident = 0.0;
  if (smash-&gt;next == NULL) {
    t_confident = smash-&gt;t;
  } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
    t_confident = smash-&gt;t;
  } else {
	  ASSERT_FOR_MCELL4(false);
    t_confident = smash-&gt;t * (1.0 - EPS_C);
  }
  int k = -1;
  if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
    k = 1;
  }
  int j = xyz2grid(&amp;(smash-&gt;loc), w-&gt;grid);
  struct surface_molecule_list *sm_list = w-&gt;grid-&gt;sm_list[j]; 
  if (sm_list == NULL || sm_list-&gt;sm == NULL) {
    return -1;
  }
  struct surface_molecule* sm = w-&gt;grid-&gt;sm_list[j]-&gt;sm;
  if (m-&gt;index == j &amp;&amp; m-&gt;previous_wall == w) {
    m-&gt;index = -1;     return -1;
  }
  int num_matching_rxns = 0;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  double scaling_coef[MAX_MATCHING_RXNS];
  struct species* spec = m-&gt;properties;
  struct periodic_image *periodic_box = m-&gt;periodic_box;
  int ii = 0, jj = 0;
  if (mol_grid_flag) {
    if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
      num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
        (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
    }
    else{
    num_matching_rxns = trigger_bimolecular(
      world-&gt;reaction_hash, world-&gt;rx_hashsize, spec-&gt;hashval,
      sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)m,
      (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
    }
    if (num_matching_rxns &gt; 0) {
      if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
        if (world-&gt;rxn_flags.vol_surf_reaction_flag)
          world-&gt;vol_surf_colls++;
      }
      for (int l = 0; l &lt; num_matching_rxns; l++) {
        if (matching_rxns[l]-&gt;prob_t != NULL) { 
	        ASSERT_FOR_MCELL4(false);
          update_probs(world, matching_rxns[l], m-&gt;t); 
        }
        scaling_coef[l] = r_rate_factor / w-&gt;grid-&gt;binding_factor;
      }
      if (num_matching_rxns == 1) {
        ii = test_bimolecular(matching_rxns[0], scaling_coef[0], 0,
          (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
          world-&gt;rng);
        jj = 0;
      } else {
        ASSERT_FOR_MCELL4(false);      
        jj = test_many_bimolecular(matching_rxns, scaling_coef, 0,
          num_matching_rxns, &amp;(ii), world-&gt;rng, 0);
      }
      if ((jj &gt; RX_NO_RX) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY)) {
        short mflags = m-&gt;flags;
        int l = outcome_bimolecular(world, matching_rxns[jj], ii,
          (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
          k, sm-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
        if (l == RX_FLIP) {
          if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
            int destroy_flag = 0;
            count_tentative_collisions(
              world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
              periodic_box, m-&gt;id);
          }
          *tentative = ttv;
          *loc_certain = &amp;(ttv-&gt;loc);
          return 0;         } else if (l == RX_DESTROY) {
          if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
            int destroy_flag = 0;
            count_tentative_collisions(
              world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
              periodic_box, m-&gt;id);
          }
          *tentative = ttv;
          return 1;
        }
      }
    }
  }
  if (mol_grid_grid_flag) {
    struct surface_molecule *smp;     struct tile_neighbor *tile_nbr_head = NULL, *curr;
    int list_length = 0;
    find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1,
      &amp;tile_nbr_head, &amp;list_length);
    if (tile_nbr_head != NULL) {
      const int num_nbrs = (int)list_length;
      int max_size = num_nbrs * MAX_MATCHING_RXNS;
      std::vector&lt;struct rxn *&gt; rxn_array(max_size);
      std::vector&lt;double&gt; cf(max_size); 
      std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
      local_prob_factor = 3.0 / num_nbrs;
      jj = RX_NO_RX;
      ii = RX_LEAST_VALID_PATHWAY - 1;
      for (int kk = 0; kk &lt; max_size; kk++) {
        smol[kk] = NULL;
        rxn_array[kk] = NULL;
        cf[kk] = 0;
      }
      int ll = 0;
      for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
        sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx];
        if (sm_list == NULL || sm_list-&gt;sm == NULL)
          continue;
        smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
        if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
            (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
          if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
            if (walls_belong_to_at_least_one_different_restricted_region(
                    world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp)) {
              continue;
            }
            if (walls_belong_to_at_least_one_different_restricted_region(
                    world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm)) {
              continue;
            }
          }
        }
        num_matching_rxns = trigger_trimolecular(world-&gt;reaction_hash,
          world-&gt;rx_hashsize, spec-&gt;hashval, sm-&gt;properties-&gt;hashval,
          smp-&gt;properties-&gt;hashval, spec, sm-&gt;properties, smp-&gt;properties,
          k, sm-&gt;orient, smp-&gt;orient, matching_rxns);
        if (num_matching_rxns &gt; 0) {
          if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL &amp;&amp;
              world-&gt;rxn_flags.vol_surf_surf_reaction_flag) {
              world-&gt;vol_surf_surf_colls++;
          }
          for (j = 0; j &lt; num_matching_rxns; j++) {
            if (matching_rxns[j]-&gt;prob_t != NULL) {
              update_probs(world, matching_rxns[j], m-&gt;t);
            }
            rxn_array[ll] = matching_rxns[j];
            cf[ll] = r_rate_factor / (w-&gt;grid-&gt;binding_factor *
                                      curr-&gt;grid-&gt;binding_factor);
            smol[ll] = smp;
            ll++;
          }
          n += num_matching_rxns;
        }
      }
      delete_tile_neighbor_list(tile_nbr_head);
      if (n == 1) {
        ii = test_bimolecular(rxn_array[0], cf[0], local_prob_factor,
          NULL, NULL, world-&gt;rng);
        jj = 0;
      } else if (n &gt; 1) {
        int all_neighbors_flag = 1;
        jj = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor,
          n, &amp;(ii), world-&gt;rng, all_neighbors_flag);
      }
      if (n &gt; max_size)
        mcell_internal_error(
            "The size of the reactions array is not sufficient.");
      if ((n &gt; 0) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
        int mflags = m-&gt;flags;
        int l = outcome_trimolecular(world, rxn_array[jj], ii,
          (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
          (struct abstract_molecule *)smol[jj], k, sm-&gt;orient,
          smol[jj]-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;smash-&gt;loc, &amp;m-&gt;pos);
        if (l == RX_FLIP) {
          if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
            int destroy_flag = 0;
            count_tentative_collisions(
              world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
              periodic_box, m-&gt;id);
          }
          *loc_certain = &amp;(ttv-&gt;loc);
          *tentative = ttv;
          return 0;         } else if (l == RX_DESTROY) {
          if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
            int destroy_flag = 0;
            count_tentative_collisions(
              world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
              periodic_box, m-&gt;id);
          }
          *tentative = ttv;
          return 1;
        }
      }
    }
  }
  return -1;
}
int collide_and_react_with_walls(struct volume* world, struct collision* smash,
  struct volume_molecule* m, struct collision** tentative,
  struct vector3** loc_certain, double t_steps, int inertness,
  double r_rate_factor) {
  struct collision *ttv = *tentative;
  struct vector3 *loc = *loc_certain;
  double t_confident = 0.0;
  if (smash-&gt;next == NULL) {
    t_confident = smash-&gt;t;
  } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
    t_confident = smash-&gt;t;
  } else {
    t_confident = smash-&gt;t * (1.0 - EPS_C);
  }
  int k = -1;
  if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
    k = 1;
  }
  m-&gt;index = -1;
  int num_matching_rxns = 0;
  struct rxn* rx = NULL;
  struct species* spec = m-&gt;properties;
  struct wall* w = (struct wall *)smash-&gt;target;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  num_matching_rxns = trigger_intersect(world-&gt;reaction_hash,
    world-&gt;rx_hashsize, world-&gt;all_mols, world-&gt;all_volume_mols,
    world-&gt;all_surface_mols, spec-&gt;hashval, (struct abstract_molecule *)m, k, w,
    matching_rxns, 1, 0, 0);
  if (num_matching_rxns == 0) {
    return -1;
  }
  int is_transp_flag = 0;
  struct rxn *transp_rx = NULL;
  for (int ii = 0; ii &lt; num_matching_rxns; ii++) {
    rx = matching_rxns[ii];
    if (rx-&gt;n_pathways == RX_TRANSP) {
      is_transp_flag = 1;
      transp_rx = matching_rxns[ii];
      break;
    }
  }
  if ((!is_transp_flag) &amp;&amp; (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) &amp;&amp;
       world-&gt;rxn_flags.vol_wall_reaction_flag) {
    world-&gt;vol_wall_colls++;
  }
  struct periodic_image *periodic_box = m-&gt;periodic_box;
  if (is_transp_flag) {
    transp_rx-&gt;n_occurred++;
    if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
      int destroy_flag = 0;
      count_tentative_collisions(
        world, tentative, smash, m, spec, smash-&gt;t, destroy_flag, periodic_box,
        m-&gt;id);
      for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
        *loc_certain = &amp;(ttv-&gt;loc);
      }
    }
#ifdef DEBUG_TRANSPARENT_SURFACES
  std::cout &lt;&lt; "Crossed a transparent wall, side: " &lt;&lt; ((wall*)smash-&gt;target)-&gt;side &lt;&lt; "\n";
<a name="4"></a>#endif
    return 0; <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  } else if (inertness &lt; inert_to_all) {
    for (int l = 0; l &lt; num_matching_rxns; l++) {
      if (matching_rxns[l]-&gt;prob_t != NULL) {</b></font>
        update_probs(world, matching_rxns[l], m-&gt;t);
      }
    }
    int jj = 0;
    int i = 0;
    if (num_matching_rxns == 1) {
      i = test_intersect(matching_rxns[0], r_rate_factor, world-&gt;rng);
      jj = 0;
    } else {
      jj = test_many_intersect(matching_rxns, r_rate_factor,
                               num_matching_rxns, &amp;(i), world-&gt;rng);
    }
    if ((i &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
      rx = matching_rxns[jj];
      int mflags = m-&gt;flags;
      int j = outcome_intersect(world, rx, i, w, (struct abstract_molecule *)m, k,
        m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
      if (j == RX_FLIP) {
        if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
          int destroy_flag = 0;
          count_tentative_collisions(
            world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
            periodic_box, m-&gt;id);
        }
        *loc_certain = &amp;(ttv-&gt;loc);
        *tentative = ttv;
        return 0;       } else if (j == RX_DESTROY) {
        if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
          int destroy_flag = 1;
          count_tentative_collisions(
            world, tentative, smash, m, spec, smash-&gt;t, destroy_flag,
            periodic_box, m-&gt;id);
        }
        return 1;
      }
    }
  }
  return -1;
}
int reflect_or_periodic_bc(
    struct volume* world, struct collision* smash,
    struct vector3* displacement, struct volume_molecule** mol,
    struct wall** reflectee, struct collision** tentative, double* t_steps) {
  struct wall* w = (struct wall*)smash-&gt;target;
  struct wall *reflect_w = w;
  double reflect_t = smash-&gt;t;
  struct volume_molecule* vm = *mol;
  bool periodic_traditional = world-&gt;periodic_traditional; 
  ASSERT_FOR_MCELL4(!periodic_traditional);
  register_hits(world, vm, tentative, &amp;reflect_w, &amp;reflect_t, displacement,
    smash, t_steps);
  struct vector3 orig_pos = {vm-&gt;pos.x, vm-&gt;pos.y, vm-&gt;pos.z};
  (*reflectee) = reflect_w;
  int k = -1;
  if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
    k = 1;
  }
  bool periodic_x = w-&gt;parent_object-&gt;periodic_x &amp;&amp; (k == -1);
  bool periodic_y = w-&gt;parent_object-&gt;periodic_y &amp;&amp; (k == -1);
  bool periodic_z = w-&gt;parent_object-&gt;periodic_z &amp;&amp; (k == -1);
  double llx = 0.0;
  double urx = 0.0;
  double lly = 0.0;
  double ury = 0.0;
  double llz = 0.0;
  double urz = 0.0;
  if (periodic_x || periodic_y || periodic_z) {
    struct geom_object* o = w-&gt;parent_object;
    assert(o-&gt;object_type == BOX_OBJ);
    struct polygon_object* p = (struct polygon_object*)(o-&gt;contents);
    struct subdivided_box* sb = p-&gt;sb;
    llx = sb-&gt;x[0];
    urx = sb-&gt;x[1];
    lly = sb-&gt;y[0];
    ury = sb-&gt;y[1];
    llz = sb-&gt;z[0];
    urz = sb-&gt;z[1];
  }
  double reflectFactor = -2.0 * (displacement-&gt;x * reflect_w-&gt;normal.x +
    displacement-&gt;y * reflect_w-&gt;normal.y + displacement-&gt;z *
    reflect_w-&gt;normal.z);
  int box_inc_x = 0;
  int box_inc_y = 0;
  int box_inc_z = 0;
  double x_pos = 0;
  double y_pos = 0;
  double z_pos = 0;
  if (periodic_x) {
    int x_inc = (vm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
    if (!distinguishable(vm-&gt;pos.x, llx, EPS_C)) {
      x_pos = urx - EPS_C;
      box_inc_x = -x_inc;
    } else if (!distinguishable(vm-&gt;pos.x, urx, EPS_C)) {
      x_pos = llx + EPS_C;
      box_inc_x = x_inc;
    }
    if (periodic_traditional &amp;&amp; x_pos) {
      vm-&gt;pos.x = x_pos;
    }
  }
  if ((!periodic_x) || (periodic_x &amp;&amp; !periodic_traditional)) {
    displacement-&gt;x = (displacement-&gt;x + reflectFactor * reflect_w-&gt;normal.x) *
      (1.0 - reflect_t);
  }
  else {
    displacement-&gt;x *= (1.0 - reflect_t);
  }
  if (periodic_y) {
    int y_inc = (vm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
    if (!distinguishable(vm-&gt;pos.y, lly, EPS_C)) {
      y_pos = ury - EPS_C;
      box_inc_y = -y_inc;
    } else if (!distinguishable(vm-&gt;pos.y, ury, EPS_C)) {
      y_pos = lly + EPS_C;
      box_inc_y = y_inc;
    }
    if (periodic_traditional &amp;&amp; y_pos) {
      vm-&gt;pos.y = y_pos;
    }
  }
  if ((!periodic_y) || (periodic_y &amp;&amp; !periodic_traditional)) {
    displacement-&gt;y = (displacement-&gt;y + reflectFactor * reflect_w-&gt;normal.y) *
      (1.0 - reflect_t);
  }
  else {
    displacement-&gt;y *= (1.0 - reflect_t);
  }
  if (periodic_z) {
    int z_inc = (vm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
    if (!distinguishable(vm-&gt;pos.z, llz, EPS_C)) {
      z_pos = urz - EPS_C;
      box_inc_z = -z_inc;
    } else if (!distinguishable(vm-&gt;pos.z, urz, EPS_C)) {
      z_pos = llz + EPS_C;
      box_inc_z = z_inc;
    }
    if (periodic_traditional &amp;&amp; z_pos) {
      vm-&gt;pos.z =  z_pos;
    }
  }
  if ((!periodic_z) || (periodic_z &amp;&amp; !periodic_traditional)) {
    displacement-&gt;z = (displacement-&gt;z + reflectFactor * reflect_w-&gt;normal.z) *
      (1.0 - reflect_t);
  }
  else {
    displacement-&gt;z *= (1.0 - reflect_t);
  }
  if ((periodic_traditional) &amp;&amp; (periodic_x || periodic_y || periodic_z)) {
    (*reflectee) = NULL;
    struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
    if (nsv == NULL) {
      struct species* spec = vm-&gt;properties;
      mcell_internal_error(
          "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
          spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
          vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
    } else {
      if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(orig_pos), NULL, reflect_t, NULL);
      }
      struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
      if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
      count_region_from_scratch(world, (struct abstract_molecule *)new_m, NULL, 1,
                                &amp;(new_m-&gt;pos), NULL, reflect_t, NULL);
      }
      *mol = new_m;
    }
    return 1;
  }
  if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
    (*reflectee) = NULL;
    struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
    if (nsv == NULL) {
      struct species* spec = vm-&gt;properties;
      mcell_internal_error(
          "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
          spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
          vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
    } else {
      if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(orig_pos), NULL, reflect_t,
                                  vm-&gt;periodic_box);
      }
      struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
      vm-&gt;periodic_box-&gt;x += box_inc_x;
      vm-&gt;periodic_box-&gt;y += box_inc_y;
      vm-&gt;periodic_box-&gt;z += box_inc_z;
      if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
        count_region_from_scratch(world, (struct abstract_molecule *)new_m,
                                  NULL, 1, &amp;(new_m-&gt;pos), NULL, reflect_t,
                                  new_m-&gt;periodic_box);
      }
      *mol = new_m;
    }
    return 1;
  }
  *mol = vm;
  return 0;
}
 void register_hits(struct volume* world, struct volume_molecule* m,
  struct collision** tentative, struct wall** reflect_w, double* reflect_t,
  struct vector3* displacement, struct collision* smash, double* t_steps) {
  struct collision* ttv = *tentative;
  struct species* spec = m-&gt;properties;
  struct vector3 reflect_pt = smash-&gt;loc;
  if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
    while (ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t &amp;&amp;
           !(ttv-&gt;what &amp; COLLIDE_WALL)) {
      ttv = ttv-&gt;next;
    }
    assert(ttv != NULL);
    (*reflect_w) = ((struct wall *)ttv-&gt;target);
    reflect_pt = ttv-&gt;loc;
    (*reflect_t) = ttv-&gt;t * (1 - EPS_C);
    for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
      if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
        continue;
      }
      if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
            COUNT_SOME_MASK)) {
        continue;
      }
      count_region_update(world, m, m-&gt;properties, m-&gt;id, m-&gt;periodic_box,
        ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
        ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
      if (ttv == smash)
        break;
    }
  }
  *tentative = ttv;
  m-&gt;pos = reflect_pt;
  m-&gt;t += *t_steps * (*reflect_t);
  *t_steps *= (1.0 - (*reflect_t));
}
void collide_and_react_with_subvol(struct volume* world, struct collision *smash,
  struct vector3* displacement, struct volume_molecule** mol,
  struct collision** tentative, double* t_steps) {
  struct collision* ttv = *tentative;
  struct volume_molecule* m = *mol;
  struct species* spec = m-&gt;properties;
  if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
    for (; ttv != NULL &amp;&amp; ttv != smash; ttv = ttv-&gt;next) {
      if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
        continue;
      }
      if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
        continue;
      }
      count_region_update(world, m, spec, m-&gt;id, m-&gt;periodic_box,
          ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
          ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 1, &amp;(ttv-&gt;loc), ttv-&gt;t);
    }
  }
  m-&gt;pos.x = smash-&gt;loc.x;
  m-&gt;pos.y = smash-&gt;loc.y;
  m-&gt;pos.z = smash-&gt;loc.z;
  displacement-&gt;x *= (1.0 - smash-&gt;t);
  displacement-&gt;y *= (1.0 - smash-&gt;t);
  displacement-&gt;z *= (1.0 - smash-&gt;t);
  m-&gt;t += (*t_steps) * smash-&gt;t;
  (*t_steps) *= (1.0 - smash-&gt;t);
  if (*t_steps &lt; EPS_C) {
    *t_steps = EPS_C;
  }
  struct subvolume *nsv = traverse_subvol(
    m-&gt;subvol, smash-&gt;what - COLLIDE_SV_NX - COLLIDE_SUBVOL, world-&gt;ny_parts,
    world-&gt;nz_parts);
  if (nsv == NULL) {
    mcell_internal_error(
        "A %s molecule escaped the world at [%.2f, %.2f, %.2f]",
        spec-&gt;sym-&gt;name, m-&gt;pos.x * world-&gt;length_unit,
        m-&gt;pos.y * world-&gt;length_unit, m-&gt;pos.z * world-&gt;length_unit);
  } else {
    m = migrate_volume_molecule(m, nsv);
  }
  *mol = m;
  *tentative = ttv;
}
void compute_displacement(struct volume* world, struct collision* shead,
  struct volume_molecule* m, struct vector3* displacement,
  struct vector3* displacement2, double* rate_factor, double* r_rate_factor,
  double* steps, double* t_steps, double max_time) {
  struct species* spec = m-&gt;properties;
  if (m-&gt;flags &amp; ACT_CLAMPED) {     if (m-&gt;index &lt;= DISSOCIATION_MAX) {       pick_release_displacement(displacement, displacement2, m-&gt;get_space_step(m),
        world-&gt;r_step_release, world-&gt;d_step, world-&gt;radial_subdivisions,
        world-&gt;directions_mask, world-&gt;num_directions, world-&gt;rx_radius_3d,
        world-&gt;rng);
      *t_steps = 0;
    } else {       pick_clamped_displacement(displacement, m, world-&gt;r_step_surface,
        world-&gt;rng, world-&gt;radial_subdivisions);
      *t_steps = m-&gt;get_time_step(m);
      m-&gt;previous_wall = NULL;
      m-&gt;index = -1;
    }
    m-&gt;flags -= ACT_CLAMPED;
    *r_rate_factor = *rate_factor = 1.0;
    *steps = 1.0;
  } else {
    if (max_time &gt; MULTISTEP_WORTHWHILE) {
      *steps = safe_diffusion_step(m, shead, world-&gt;radial_subdivisions,
        world-&gt;r_step, world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
    } else {
      *steps = 1.0;
    }
    *t_steps = *steps * m-&gt;get_time_step(m);
    if (*t_steps &gt; max_time) {
      *t_steps = max_time;
      *steps = max_time / m-&gt;get_time_step(m);
      #ifdef MCELL3_ROUND_TSTEPS
        if (*t_steps &gt; 1.0 - EPS_C &amp;&amp; *t_steps &lt; 1.0 + EPS_C) {
          *t_steps = 1.0;
        }
        if (*steps &gt; 1.0 - EPS_C &amp;&amp; *steps &lt; 1.0 + EPS_C) {
          *steps = 1.0;
        }
      #endif
    }
    if (*steps &lt; EPS_C) {
      *steps = EPS_C;
      *t_steps = EPS_C * m-&gt;get_time_step(m);
    }
    if (*steps == 1.0) {
      pick_displacement(displacement, m-&gt;get_space_step(m), world-&gt;rng);
      *r_rate_factor = *rate_factor = 1.0;
    } else {
      *rate_factor = sqrt(*steps);
      *r_rate_factor = 1.0 / *rate_factor;
      pick_displacement(displacement, *rate_factor * m-&gt;get_space_step(m), world-&gt;rng);
    }
  }
  if (spec-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
    double disp_length = vect_length(displacement);
    if (disp_length &gt; spec-&gt;max_step_length) {
      displacement-&gt;x *= (spec-&gt;max_step_length / disp_length);
      displacement-&gt;y *= (spec-&gt;max_step_length / disp_length);
      displacement-&gt;z *= (spec-&gt;max_step_length / disp_length);
    }
  }
  world-&gt;diffusion_number++;
  world-&gt;diffusion_cumtime += *steps;
}
void determine_mol_mol_reactions(struct volume* world, struct volume_molecule* m,
  struct collision** shead, struct collision** stail, int inertness) {
  struct subvolume* sv = m-&gt;subvol;
  struct rxn *matching_rxns[MAX_MATCHING_RXNS];
  int num_matching_rxns = 0;
  struct species* spec = m-&gt;properties;
  struct per_species_list *psl_next, *psl, **psl_head = &amp;sv-&gt;species_head;
  for (psl = sv-&gt;species_head; psl != NULL; psl = psl_next) {
    psl_next = psl-&gt;next;
    if (psl-&gt;properties == NULL) {
      psl_head = &amp;psl-&gt;next;
      continue;
    }
    if (psl-&gt;head == NULL) {
      *psl_head = psl-&gt;next;
      ht_remove(&amp;sv-&gt;mol_by_species, psl);
      mem_put(sv-&gt;local_storage-&gt;pslv, psl);
      continue;
    } else
      psl_head = &amp;psl-&gt;next;
    if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
      if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)m, 
                                                (struct abstract_molecule *)psl-&gt;head)){
        continue;
      }
    }
    else{
      if (!trigger_bimolecular_preliminary(world-&gt;reaction_hash, world-&gt;rx_hashsize,
        m-&gt;properties-&gt;hashval, psl-&gt;properties-&gt;hashval, m-&gt;properties, psl-&gt;properties)) {
        continue;
      }
    }
    for (struct volume_molecule* mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
      if (mp == m) {
        continue;
      }
      if (inertness == inert_to_mol &amp;&amp; m-&gt;index == mp-&gt;index) {
        continue;
      }
      if (!periodic_boxes_are_identical(m-&gt;periodic_box, mp-&gt;periodic_box)) {
        continue;
      }
      if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
        num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
          (struct abstract_molecule *)mp,0, 0, matching_rxns);
      } 
      else{
        num_matching_rxns = trigger_bimolecular(world-&gt;reaction_hash,
          world-&gt;rx_hashsize, spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
          (struct abstract_molecule *)m, (struct abstract_molecule *)mp, 0, 0,
          matching_rxns);
      }
      if (num_matching_rxns &gt; 0) {
        for (int i = 0; i &lt; num_matching_rxns; i++) {
          struct collision* smash =
           (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
            "collision data");
          smash-&gt;target = (void *)mp;
          smash-&gt;what = COLLIDE_VOL;
          smash-&gt;intermediate = matching_rxns[i];
          smash-&gt;next = *shead;
          *shead = smash;
          if (*stail == NULL)
            *stail = *shead;
        }
      }
    }
  }
}
void set_inertness_and_maxtime(
    struct volume* world, struct volume_molecule* m, double* max_time,
    int* inertness) {
  struct species* spec = m-&gt;properties;
  if (world-&gt;volume_reversibility || world-&gt;surface_reversibility) {
    if (world-&gt;volume_reversibility &amp;&amp;
<a name="2"></a>        m-&gt;index &lt;= DISSOCIATION_MAX) {       if ((m-&gt;flags &amp; ACT_CLAMPED) != 0) {
        *inertness = inert_to_all;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      } else {
        m-&gt;index = -1;
      }
    } else if (!world-&gt;surface_reversibility) {
      if (m-&gt;flags &amp; ACT_CLAMPED) {         m-&gt;birthday -= 5 * m-&gt;get_time_step(m);       }
    }</b></font>
  } else {
    if (m-&gt;flags &amp; ACT_CLAMPED) {       m-&gt;birthday -= 5 * m-&gt;get_time_step(m);     } else if ((m-&gt;flags &amp; MATURE_MOLECULE) == 0) {
    #ifndef MCELL3_MOLECULE_MOVES_WITH_MAXIMUM_TIMESTEP
      if (m-&gt;get_time_step(m) &gt; 1.0) {
        double f = 1.0 + 0.2 * (m-&gt;t - m-&gt;birthday / world-&gt;time_unit);
        if (f &lt; 1 - EPS_C)
          mcell_internal_error("A %s molecule is scheduled to move before it "
                               "was born [birthday=%.15g, t=%.15g]",
                               spec-&gt;sym-&gt;name, m-&gt;birthday,
                               m-&gt;t * world-&gt;time_unit);
        if (*max_time &gt; f) {
          *max_time = f;
        }
        if (f &gt; m-&gt;subvol-&gt;local_storage-&gt;max_timestep) {
          m-&gt;flags |= MATURE_MOLECULE;
        }
      }
    #else
      m-&gt;flags |= MATURE_MOLECULE;
    #endif     }
  }
}
void count_tentative_collisions(
  struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
  struct species *spec, double t_confident, int destroy_flag,
  struct periodic_image *box, u_long id) {
  int crossed_flag = 1;
  if (destroy_flag == 1) {
    crossed_flag = 0; 
  }
  struct collision *ttv = *tc;
  for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
    if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
      continue;
    }
    if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
      continue;
    }
    count_region_update(
      world, m, spec, id, box, ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
      ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, crossed_flag,
      &amp;(ttv-&gt;loc), ttv-&gt;t);
    if ((destroy_flag) &amp;&amp; (ttv == smash)) {
      break;
    }
  }
  *tc = ttv;
}
bool periodicbox_in_surfmol_list(
    struct periodic_image *periodic_box,
    struct surface_molecule_list *sml) {
  for (struct surface_molecule_list *sml_curr = sml;
       sml_curr != NULL;
       sml_curr = sml_curr-&gt;next) {
    struct surface_molecule *sm = sml_curr-&gt;sm;
    if (sm &amp;&amp; periodic_boxes_are_identical(periodic_box, sm-&gt;periodic_box)) {
      return true;
    }
  }
  return false;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
