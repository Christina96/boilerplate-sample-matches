<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; diffuse.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; diffuse.c
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (3.4313726%)<th>diffuse.c (1.2841419%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1691-1708)<td><a href="#" name="0">(1103-1111)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1726-1738)<td><a href="#" name="1">(1148-1160)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1796-1804)<td><a href="#" name="2">(5228-5235)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1582-1592)<td><a href="#" name="3">(2007-2018)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(642-648)<td><a href="#" name="4">(4625-4629)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;string.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;vector&gt;
7 #include "logging.h"
8 #include "rng.h"
9 #include "util.h"
10 #include "grid_util.h"
11 #include "count_util.h"
12 #include "react.h"
13 #include "vol_util.h"
14 #include "wall_util.h"
15 #include "nfsim_func.h"
16 #include "mcell_reactions.h"
17 #include "diffuse.h"
18 #include "debug_config.h"
19 #include "debug.h"
20 #include "dump_state.h"
21 static int outcome_products_random(struct volume *world, struct wall *w,
22                                    struct vector3 *hitpt, double t,
23                                    struct rxn *rx, int path,
24                                    struct abstract_molecule *reacA,
25                                    struct abstract_molecule *reacB,
26                                    short orientA, short orientB);
27 static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
28 int is_compatible_surface(void *req_species, struct wall *w) {
29   struct surf_class_list *scl, *scl2;
30   struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
31   if (rs_head == NULL)
32     return 1;
33   for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
34     for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
35       if (scl-&gt;surf_class == scl2-&gt;surf_class)
36         return 1;
37     }
38   }
39   return 0;
40 }
41 void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
42   struct abstract_molecule *reacB, struct abstract_molecule *reacC,
43   struct abstract_molecule **player, char *player_type) {
44   player[0] = reacA;
45   player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
46   if (rx-&gt;n_reactants &gt; 1) {
47     if (reacB == NULL) {
48       assert(rx-&gt;n_reactants == 2);
49       player[1] = NULL;
50       player_type[1] = PLAYER_WALL;
51     } else {        player[1] = reacB;
52       player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
53     }
54     if (rx-&gt;n_reactants &gt; 2) {
55       if (reacC == NULL) {
56         player[2] = NULL;
57         player_type[2] = PLAYER_WALL;
58       } else {
59         player[2] = reacC;
60         player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
61       }
62     }
63   }
64 }
65 static bool is_rxn_unimol(struct rxn *rx) {
66   if (rx-&gt;n_reactants == 1)
67     return true;
68   if (rx-&gt;n_reactants != 2)
69     return false;
70   if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
71     return false;
72   return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
73 }
74 void tiny_diffuse_3D(
75     struct volume *world,
76     struct subvolume *subvol,
77     struct vector3 *displacement,
78     struct vector3 *pos,
79     struct wall *w) {
80   struct vector3 temp_displacement = {
81     displacement-&gt;x,
82     displacement-&gt;y,
83     displacement-&gt;z
84   };
85   struct collision *shead = ray_trace(
86       world, pos, NULL, subvol, &amp;temp_displacement, w);
87   if (shead-&gt;next != NULL) {
88     shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
89   }
90   struct collision *smash = NULL;
91   for (smash = shead; smash != NULL; smash = smash-&gt;next) {
92     if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
93       vectorize(pos, &amp;(smash-&gt;loc), displacement);
94       scalar_prod(displacement, 0.5, displacement);
95       break;
96     }
97   }
98   pos-&gt;x += displacement-&gt;x;
99   pos-&gt;y += displacement-&gt;y;
100   pos-&gt;z += displacement-&gt;z;
101   subvol = find_subvolume(world, pos, subvol);
102 }
103 struct volume_molecule *
104 place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
105                      struct surface_molecule *sm_reactant, struct wall *w,
106                      struct subvolume *subvol, struct vector3 *hitpt,
107                      short orient, double t, struct periodic_image *periodic_box) {
108   struct vector3 pos = *hitpt;
109   if (w) {
110     double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
111     struct vector3 displacement = {2 * bump * w-&gt;normal.x,
112                                    2 * bump * w-&gt;normal.y,
113                                    2 * bump * w-&gt;normal.z,
114                                   };
115     tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
116   }
117   struct volume_molecule *new_volume_mol;
118   new_volume_mol =
119       (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
120   new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
121   new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
122       world-&gt;start_iterations, world-&gt;time_unit,
123       world-&gt;simulation_start_seconds, t);
124   new_volume_mol-&gt;id = world-&gt;current_mol_id++;
125   new_volume_mol-&gt;t = t;
126   new_volume_mol-&gt;t2 = 0.0;
127   new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
128     "periodic image descriptor");
129   new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
130   new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
131   new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
132   new_volume_mol-&gt;properties = product_species;
133   new_volume_mol-&gt;graph_data = graph;
134   initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
135   new_volume_mol-&gt;prev_v = NULL;
136   new_volume_mol-&gt;next_v = NULL;
137   new_volume_mol-&gt;pos = pos;
138   new_volume_mol-&gt;subvol = subvol;
139   new_volume_mol-&gt;index = 0;
140   new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
141   if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
142     new_volume_mol-&gt;flags |= ACT_DIFFUSE;
143   if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
144     new_volume_mol-&gt;flags |= COUNT_ME;
145   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
146                            product_species-&gt;hashval,
147                            (struct abstract_molecule *)new_volume_mol) != NULL)
148     new_volume_mol-&gt;flags |= ACT_REACT;
149   if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
150     new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
151     new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
152   }
153   else {
154     new_volume_mol-&gt;previous_wall = NULL;
155     new_volume_mol-&gt;index = -1;
156   }
157   if (w) {
158     if (world-&gt;surface_reversibility) {
159       new_volume_mol-&gt;previous_wall = w;
160       new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
161       new_volume_mol-&gt;flags |= ACT_CLAMPED;
162     }
163   } else if (world-&gt;volume_reversibility) {
164     new_volume_mol-&gt;index = world-&gt;dissociation_index;
165     new_volume_mol-&gt;flags |= ACT_CLAMPED;
166   }
167   ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
168                           new_volume_mol);
169   ++new_volume_mol-&gt;subvol-&gt;mol_count;
170   if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
171     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
172                       product_species-&gt;sym-&gt;name);
173   return new_volume_mol;
174 }
175 struct surface_molecule *
176 place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
177                  struct surface_grid *grid, int grid_index,
178                  struct vector2 *mol_uv_pos, short orient, double t,
179                  struct periodic_image *periodic_box) {
180   struct vector3 mol_xyz_pos;
181   uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
182   struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
183   struct surface_molecule *new_surf_mol;
184   new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
185   new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
186   new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
187       world-&gt;start_iterations, world-&gt;time_unit,
188       world-&gt;simulation_start_seconds, t);
189   new_surf_mol-&gt;id = world-&gt;current_mol_id++;
190   new_surf_mol-&gt;t = t;
191   new_surf_mol-&gt;t2 = 0.0;
192   new_surf_mol-&gt;properties = product_species;
193   new_surf_mol-&gt;graph_data = graph;
194   initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
195   new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
196     "periodic image descriptor");
197   new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
198   new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
199   new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
200   new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
201   if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
202     new_surf_mol-&gt;flags |= ACT_DIFFUSE;
203   if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
204     new_surf_mol-&gt;flags |= COUNT_ME;
205   new_surf_mol-&gt;grid = grid;
206   new_surf_mol-&gt;grid_index = grid_index;
207   new_surf_mol-&gt;s_pos = *mol_uv_pos;
208   new_surf_mol-&gt;orient = orient;
209   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
210                            product_species-&gt;hashval,
211                            (struct abstract_molecule *)new_surf_mol) != NULL ||
212       (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
213     new_surf_mol-&gt;flags |= ACT_REACT;
214   ++grid-&gt;n_occupied;
215   if (grid-&gt;sm_list[grid_index]) {
216     remove_surfmol_from_list(
217         &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
218   }
219   grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
220     grid-&gt;sm_list[grid_index], new_surf_mol);
221   if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
222     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
223                       product_species-&gt;sym-&gt;name);
224   return new_surf_mol;
225 }
226 static int outcome_products_random(struct volume *world, struct wall *w,
227                                    struct vector3 *hitpt, double t,
228                                    struct rxn *rx, int path,
229                                    struct abstract_molecule *reacA,
230                                    struct abstract_molecule *reacB,
231                                    short orientA, short orientB) {
232 #ifdef DEBUG_RXNS
233   DUMP_CONDITION3(
234     dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
235     dump_molecule_species(reacA);
236     if (reacB != nullptr) {
237       mcell_log(" + ");
238       dump_molecule_species(reacB);
239     }
240     mcell_log("\nreaction_index: %d\n", path);
241     dump_rxn(rx, "", true);
242   );
243 #endif
244   bool cross_wall = false; 
245   int const i0 = rx-&gt;product_idx[path]; 
246   int const iN = rx-&gt;product_idx[path + 1]; 
247   assert(iN &gt; i0);
248   struct species **rx_players = rx-&gt;players + i0; 
249   int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
250   std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
251   std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
252   bool const is_unimol = is_rxn_unimol(rx);
253   struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
254   unsigned int reac_idx = UINT_MAX;
255   struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
256   for (int i = 0; i &lt; n_players; ++i) {
257     product[i] = NULL;
258     product_type[i] = PLAYER_NONE;
259     product_orient[i] = 0;
260     product_grid[i] = NULL;
261     product_grid_idx[i] = -1;
262     product_flag[i] = PRODUCT_FLAG_NOT_SET;
263   }
264   struct surface_molecule *const sm_1 =
265       IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
266   struct surface_molecule *const sm_2 =
267       IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
268   struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;
269   bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
270   struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
271   struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
272   int sm_bitmask = determine_molecule_region_topology(
273       world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
274       &amp;rlp_head_obj_2, is_unimol);
275   struct abstract_molecule *const initiator = reacA;
276   short const initiatorOrient = orientA;
277   assert(reacA != NULL);
278   if (reacA-&gt;properties != rx-&gt;players[0]) {
279     struct abstract_molecule *tmp_mol = reacA;
280     reacA = reacB;
281     reacB = tmp_mol;
282     short tmp_orient = orientA;
283     orientA = orientB;
284     orientB = tmp_orient;
285   }
286   assert(reacA != NULL);
287   add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
288   int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
289   int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
290                                            rx_players[1] == NULL);
291   struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
292     if (sm_reactant) {
293       rxn_uv_pos = sm_reactant-&gt;s_pos;
294     } else {
295       xyz2uv(hitpt, w, &amp;rxn_uv_pos);
296     }
297     assert(w != NULL);
298     if (w-&gt;grid == NULL) {
299       assert(!IS_SURF_MOL(reacA));
300       if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
301         mcell_allocfailed("Failed to create a grid for a wall.");
302     }
303     rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
304     if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
305       num_surface_static_reactants++;
306     }
307     if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
308       num_surface_static_reactants++;
309     }
310   }
311   int num_surface_products = 0;
312   int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
313     if (rx_players[n_product] == NULL) {
314       continue;
315     }
316     if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
317       num_surface_products++;
318       if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
319         num_surface_static_products++;
320     }
321   }
322   int mol_idx = INT_MAX;
323   struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
324   struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
325     if (num_surface_products &gt; 0) {
326       if (sm_reactant != NULL) {
327         find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
328                             sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
329                             &amp;tile_nbr_list_length);
330       } else {
331         find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
332                             &amp;tile_nbr_head, &amp;tile_nbr_list_length);
333       }
334       for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
335            tile_nbr = tile_nbr-&gt;next) {
336         struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
337         if (sm_list == NULL || sm_list-&gt;sm == NULL) {
338           num_vacant_tiles++;
339           push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
340         }
341       }
342     }
343     int num_recycled_tiles = 0;
344     if (replace_p1 &amp;&amp; replace_p2) {
345       num_recycled_tiles = 2;
346     } else if (replace_p1 || replace_p2) {
347       num_recycled_tiles = 1;
348     }
349     if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
350       return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
351     }
352     for (int n_product = 0; n_product &lt; n_players; ++n_product) {
353       if (rx_players[n_product] == NULL) {
354         continue;
355       }
356       int this_geometry = rx-&gt;geometries[i0 + n_product];
357       int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
358       this_geometry = abs(this_geometry);
359       if (this_geometry == 0) {
360         product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
361       } else {
362         if (this_geometry &gt; (int)rx-&gt;n_reactants) {
363           product_orient[n_product] = relative_orient *
364               product_orient[this_geometry - rx-&gt;n_reactants - 1];
365         } else if (this_geometry == 1) {
366           product_orient[n_product] = relative_orient * orientA;
367         } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
368           product_orient[n_product] = relative_orient * orientB;
369         } else {
370           product_orient[n_product] = relative_orient * 1;
371         }
372       }
373       if (n_product &lt; (int)rx-&gt;n_reactants) {
374         if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
375           assert(IS_SURF_MOL(product[n_product]));
376           struct surface_molecule *sm =
377               (struct surface_molecule *)product[n_product];
378           if (sm-&gt;orient != product_orient[n_product]) {
379             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
380               count_region_from_scratch(world,
381                                         product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
382             }
383             if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
384                 ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
385               sm-&gt;t2 = 0;
386             }
387             sm-&gt;orient = product_orient[n_product];
388             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
389               count_region_from_scratch(world,
390                                         product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
391             }
392           }
393         } else if (!is_unimol) {           if (product[n_product] == initiator) {
394             if (product_orient[n_product] != initiatorOrient)
395               cross_wall = true;
396           }
397         }
398       }
399     }
400     if (num_surface_products == 1) {
401       if (is_unimol &amp;&amp; replace_p1) {
402         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
403           if (rx_players[n_product] == NULL ||
404              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
405             continue;
406           }
407           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
408             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
409             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
410             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
411             replace_p1 = 0;
412 <a name="4"></a>            break;
413           }
414         }
415 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
416           &amp;&amp; (replace_p1 || replace_p2)) {
417         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
418           if (rx_players[n_product] == NULL ||
419               (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
420               distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {</b></font>
421             continue;
422           }
423           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
424             if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
425               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
426               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
427               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
428               replace_p1 = 0;
429               break;
430             } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
431               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
432               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
433               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
434               break;
435             }
436           }
437         }
438       } else if (replace_p1 &amp;&amp; replace_p2) {
439         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
440           if ((rx_players[n_product] == NULL) ||
441               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
442             continue;
443           }
444           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
445             if (reacA == initiator) {
446               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
447               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
448               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
449               replace_p1 = 0;
450             } else {
451               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
452               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
453               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
454             }
455             break;
456           }
457         }
458       } else if (replace_p1) {
459         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
460           if ((rx_players[n_product] == NULL) ||
461               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
462             continue;
463           }
464           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
465             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
466             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
467             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
468             replace_p1 = 0;
469             break;
470           }
471         }
472       } else if (replace_p2) {
473         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
474           if ((rx_players[n_product] == NULL) |
475               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
476             continue;
477           }
478           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
479             product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
480             product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
481             product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
482             break;
483           }
484         }
485       }
486     } else if (num_surface_products &gt; 1) {
487       if (num_surface_static_reactants &gt; 0) {
488         bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
489         bool replace_reacB =
490             (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
491         if (replace_reacA || replace_reacB) {
492           int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
493             ? num_surface_static_products : num_surface_static_reactants;
494           int count = 0;
495           while (count &lt; max_static_count) {
496             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
497             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
498                 ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
499                 distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
500               continue;
501             }
502             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
503               if (replace_reacA) {
504                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
505                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
506                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
507                 count++;
508                 replace_p1 = 0;
509                 replace_reacA = 0;
510               } else if (replace_reacB) {
511                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
512                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
513                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
514                 count++;
515                 replace_p2 = 0;
516                 replace_reacB = 0;
517               }
518             }
519           }         }
520       }
521       if (replace_p1 || replace_p2) {
522         int surf_prod_left = 0, surf_reactant_left = 0;
523         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
524           if ((rx_players[n_product] == NULL) ||
525               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
526             continue;
527           }
528           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
529             surf_prod_left++;
530           }
531         }
532         if (replace_p1) {
533           surf_reactant_left++;
534         }
535         if (replace_p2) {
536           surf_reactant_left++;
537         }
538         if (surf_prod_left &gt; 0) {
539           int num_to_place = surf_prod_left;
540           if (surf_prod_left &gt;= surf_reactant_left) {
541             num_to_place = surf_reactant_left;
542           }
543           int count = 0;
544           while (count &lt; num_to_place) {
545             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
546             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
547                 (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
548              continue;
549             }
550             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
551               if (replace_p1) {
552                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
553                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
554                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
555                 count++;
556                 replace_p1 = 0;
557               } else if (replace_p2) {
558                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
559                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
560                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
561                 replace_p2 = 0;
562                 count++;
563               }
564             }
565           }         }
566       }
567     }
568     if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
569       assert(!IS_SURF_MOL(reacA));
570       assert(rxn_uv_idx != -1);
571       while (true) {
572         unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
573         if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
574             (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
575           continue;
576         }
577         if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
578           product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
579           product_grid[rnd_num] = w-&gt;grid;
580           product_grid_idx[rnd_num] = rxn_uv_idx;
581           break;
582         }
583       }
584     }
585     if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
586       reac_idx = sm_reactant-&gt;grid_index;
587       reac_grid = sm_reactant-&gt;grid;
588     }
589     int do_it_once = 0;     int num_attempts = 0;
590     for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
591       if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
592         if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
593           continue;
594         }
595         if (num_vacant_tiles == 0) {
596           return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
597         }
598         num_attempts = 0;
599         while (true) {
600           if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
601             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
602           }
603           unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
604           int tile_idx = -1;           tile_grid = NULL;
605           if (get_tile_neighbor_from_list_of_vacant_neighbors(
606                   tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
607             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
608           }
609           if (tile_idx &lt; 0) {
610             continue;           }
611           assert(tile_grid != NULL);
612           if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
613             rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
614             uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
615             num_attempts++;
616             continue;
617           }
618           product_grid[n_product] = tile_grid;
619           product_grid_idx[n_product] = tile_idx;
620           product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
621           if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
622             mol_idx = tile_idx;
623             mol_grid = tile_grid;
624             do_it_once = 1;
625           }
626           break;
627         }       }
628     }
629   } 
630   struct vector3 count_pos_xyz;
631   struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
632   if (hitpt != NULL) {
633     count_pos_xyz = *hitpt;
634   } else if (sm_reactant) {
635     uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
636   } else {
637     count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
638   }
639   struct vector3 mol_pos_tmp;
640   struct subvolume *product_subvol = NULL;
641   bool update_dissociation_index = false; 
642   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
643     struct graph_data* g_data = NULL;
644     if (rx-&gt;product_graph_data != NULL)
645       g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
646     struct abstract_molecule *this_product = NULL;
647     struct species *const product_species = rx_players[n_product];
648     if (product_species-&gt;flags &amp; ON_GRID) {
649       struct vector2 prod_uv_pos;
650       if (world-&gt;randomize_smol_pos) {
651         switch (product_flag[n_product]) {
652         case PRODUCT_FLAG_USE_REACA_UV:
653           if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
654             if (mol_grid == NULL) {
655               mcell_internal_error("Error in surface product placement for the "
656                                    "unimolecular reaction.");
657             }
658             find_closest_position(product_grid[n_product], product_grid_idx[n_product],
659               mol_grid, mol_idx, &amp;prod_uv_pos);
660           } else {
661             prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
662           }
663           break;
664         case PRODUCT_FLAG_USE_REACB_UV:
665           assert(reacB != NULL);
666           prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
667           break;
668         case PRODUCT_FLAG_USE_UV_LOC:
669           prod_uv_pos = rxn_uv_pos;
670           break;
671         case PRODUCT_FLAG_USE_RANDOM:
672           if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
673             find_closest_position(product_grid[n_product],
674                                   product_grid_idx[n_product], reac_grid,
675                                   reac_idx, &amp;prod_uv_pos);
676           } else {
677             grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
678                            &amp;prod_uv_pos, world-&gt;rng);
679           }
680           break;
681         default:
682           UNHANDLED_CASE(product_flag[n_product]);
683         }
684       } else {
685         grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
686       }
687       this_product = (struct abstract_molecule *)place_sm_product(
688           world, product_species, g_data, product_grid[n_product],
689           product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
690           t, reacA-&gt;periodic_box);
691 #ifdef DEBUG_RXNS
692       DUMP_CONDITION3(
693           dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
694       );
695 #endif
696       if (!hitpt) {
697         if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
698           w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
699           uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
700                  w, &amp;mol_pos_tmp);
701           product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
702         } else {
703           mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
704           product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
705         }
706         hitpt = &amp;mol_pos_tmp;
707       } else if (product_subvol == NULL) {
708         product_subvol = find_subvolume(world, hitpt, NULL);
709       }
710       this_product = (struct abstract_molecule *)place_volume_product(
711           world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
712           product_orient[n_product], t, reacA-&gt;periodic_box);
713 #ifdef DEBUG_RXNS
714       DUMP_CONDITION3(
715       		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
716       );
717 #endif
718       if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
719         update_dissociation_index = true;
720     }
721     if(rx-&gt;product_graph_data != NULL){
722       this_product-&gt;graph_data = g_data;
723     }
724     ++product_species-&gt;population;
725     if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
726       count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
727 #ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
728     if (is_unimol &amp;&amp; (n_players == 1)) {
729       this_product-&gt;id = reacA-&gt;id;
730       world-&gt;current_mol_id--;       continue;
731     }
732     if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
733       this_product-&gt;id = reacA-&gt;id;
734       world-&gt;current_mol_id--;       continue;
735     }
736 #endif
737   }
738   if (update_dissociation_index) {
739     ASSERT_FOR_MCELL4(false);
740     if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
741       world-&gt;dissociation_index = DISSOCIATION_MAX;
742   }
743   if (rx-&gt;info[path].pathname != NULL) {
744     if (world-&gt;place_waypoints_flag)
745       count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,
746                                 &amp;count_pos_xyz, w, t, periodic_box);
747     if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
748       if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
749                             &amp;count_pos_xyz, t))
750         mcell_allocfailed("Failed to complete reaction triggered release after "
751                           "a '%s' reaction.",
752                           rx-&gt;info[path].pathname-&gt;sym-&gt;name);
753     }
754   }
755   delete_tile_neighbor_list(tile_nbr_head);
756   delete_tile_neighbor_list(tile_vacant_nbr_head);
757   delete_region_list(rlp_head_wall_1);
758   delete_region_list(rlp_head_wall_2);
759   delete_region_list(rlp_head_obj_1);
760   delete_region_list(rlp_head_obj_2);
761   return cross_wall ? RX_FLIP : RX_A_OK;
762 }
763 int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
764                          struct abstract_molecule *reac, double t) {
765   struct species *who_was_i = reac-&gt;properties;
766   int result = RX_A_OK;
767   struct volume_molecule *vm = NULL;
768   struct surface_molecule *sm = NULL;
769   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
770     vm = (struct volume_molecule *)reac;
771     if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
772 #if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
773         outcome_nfsim(world, rx, path, reac, NULL, t);
774       }
775 #else
776       outcome_nfsim(world, rx, path, reac, NULL, t);
777 #endif
778     }
779     result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
780                                        NULL, 0, 0);
781   } else {
782     sm = (struct surface_molecule *)reac;
783       if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
784           (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
785       } else {
786         if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
787           outcome_nfsim(world, rx, path, reac, NULL, t);
788         }
789         result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
790                                          path, reac, NULL, sm-&gt;orient, 0);
791       }
792   }
793   if (result == RX_BLOCKED)
794     return RX_BLOCKED;
795   if (result != RX_BLOCKED) {
796     rx-&gt;info[path].count++;
797     rx-&gt;n_occurred++;
798     if(rx-&gt;product_graph_data != NULL){
799       logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
800     }
801   }
802   struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
803   if (who_am_i == NULL) {
804     if (vm != NULL) {
805       vm-&gt;subvol-&gt;mol_count--;
806       if (vm-&gt;flags &amp; IN_SCHEDULE)
807         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
808       if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
809         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
810                                   -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
811       }
812     } else {
813 #ifdef DEBUG_RXNS
814       DUMP_CONDITION3(
815         dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
816       );
817 #endif
818       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
819       sm-&gt;grid-&gt;n_occupied--;
820       if (sm-&gt;flags &amp; IN_SCHEDULE) {
821         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
822       }
823       if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
824         count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
825                                   -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
826       }
827     }
828     free(reac-&gt;periodic_box);
829     who_was_i-&gt;n_deceased++;
830     double t_time = convert_iterations_to_seconds(
831         world-&gt;start_iterations, world-&gt;time_unit,
832         world-&gt;simulation_start_seconds, t);
833     who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
834     who_was_i-&gt;population--;
835     if (vm != NULL) {
836 #ifdef DEBUG_RXNS
837       DUMP_CONDITION3(
838         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
839       );
840 #endif
841       collect_molecule(vm);
842     }
843     else {
844       reac-&gt;properties = NULL;
845       mem_put(reac-&gt;birthplace, reac);
846     }
847     return RX_DESTROY;
848   } else if (who_am_i != who_was_i) {
849     if (vm != NULL) {
850 #ifdef DEBUG_RXNS
851       DUMP_CONDITION3(
852         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
853       );
854 #endif
855       collect_molecule(vm);
856     }
857     else
858       reac-&gt;properties = NULL;
859     return RX_DESTROY;
860   } else
861     return result;
862 }
863 int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
864                         struct abstract_molecule *reacA,
865                         struct abstract_molecule *reacB, short orientA,
866                         short orientB, double t, struct vector3 *hitpt,
867                         struct vector3 *loc_okay) {
868 #ifdef DEBUG_TIMING
869   DUMP_CONDITION3(
870       MCell::dump_outcome_bimolecular_timing(t);
871   );
872 #endif
873   assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
874   struct surface_molecule *sm = NULL;
875   struct volume_molecule *vm = NULL;
876   struct wall *w = NULL;
877   int result;
878   int reacB_was_free = 0;
879   int killA, killB;
880   if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
881     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
882       sm = (struct surface_molecule *)reacB;
883       w = sm-&gt;grid-&gt;surface;
884     }
885   } else {     sm = (struct surface_molecule *)reacA;
886     w = sm-&gt;grid-&gt;surface;
887   }
888   if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
889     result = outcome_nfsim(world, rx, path, reacA, reacB, t);
890     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
891                                      orientA, orientB);
892   }
893   else {
894     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
895                                      orientA, orientB);
896   }
897   if (result == RX_BLOCKED)
898     return RX_BLOCKED;
899   rx-&gt;n_occurred++;
900   rx-&gt;info[path].count++;
901   if(rx-&gt;product_graph_data != NULL){
902     logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
903   }
904   if (rx-&gt;players[0] == reacA-&gt;properties) {
905     killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
906     killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
907   } else {
908     killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
909     killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
910   }
911   if (killB) {
912 #ifdef DEBUG_RXNS
913     DUMP_CONDITION3(
914       dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
915     );
916 #endif
917     vm = NULL;
918     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
919       sm = (struct surface_molecule *)reacB;
920       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
921       sm-&gt;grid-&gt;n_occupied--;
922       if (sm-&gt;flags &amp; IN_SURFACE)
923         sm-&gt;flags -= IN_SURFACE;
924       if (sm-&gt;flags &amp; IN_SCHEDULE) {
925         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
926       }
927     } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
928       vm = (struct volume_molecule *)reacB;
929       vm-&gt;subvol-&gt;mol_count--;
930       if (vm-&gt;flags &amp; IN_SCHEDULE) {
931         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
932       }
933       reacB_was_free = 1;
934     }
935     if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
936       count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
937     }
938     free(reacB-&gt;periodic_box);
939     reacB-&gt;periodic_box = NULL;
940     reacB-&gt;properties-&gt;n_deceased++;
941     double t_time = convert_iterations_to_seconds(
942         world-&gt;start_iterations, world-&gt;time_unit,
943         world-&gt;simulation_start_seconds, t);
944     reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
945     reacB-&gt;properties-&gt;population--;
946     if (vm != NULL)
947       collect_molecule(vm);
948     else
949       reacB-&gt;properties = NULL;
950   }
951   if (killA) {
952 #ifdef DEBUG_RXNS
953     DUMP_CONDITION3(
954       dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
955     );
956 #endif
957     vm = NULL;
958     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
959       sm = (struct surface_molecule *)reacA;
960       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
961       sm-&gt;grid-&gt;n_occupied--;
962       if (sm-&gt;flags &amp; IN_SCHEDULE) {
963         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
964       }
965     } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
966       vm = (struct volume_molecule *)reacA;
967       vm-&gt;subvol-&gt;mol_count--;
968       if (vm-&gt;flags &amp; IN_SCHEDULE) {
969         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
970       }
971     }
972     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
973         0)     {
974       if (reacA-&gt;properties-&gt;flags &amp;
975           COUNT_SOME_MASK)       {
976         count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);
977       }
978     } else if (reacA-&gt;flags &amp; COUNT_ME) {
979       if (hitpt == NULL || reacB_was_free ||
980           (reacB-&gt;properties != NULL &amp;&amp;
981            (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
982         count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
983       {
984         struct vector3 fake_hitpt;
985         vm = (struct volume_molecule *)reacA;
986         if (loc_okay == NULL)
987           loc_okay = &amp;(vm-&gt;pos);
988         fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
989         fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
990         fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
991         count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);
992       }
993     }
994     free(reacA-&gt;periodic_box);
995     reacA-&gt;periodic_box = NULL;
996     reacA-&gt;properties-&gt;n_deceased++;
997     double t_time = convert_iterations_to_seconds(
998         world-&gt;start_iterations, world-&gt;time_unit,
999         world-&gt;simulation_start_seconds, t);
1000     reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
1001     reacA-&gt;properties-&gt;population--;
1002     if (vm != NULL)
1003       collect_molecule(vm);
1004     else
1005       reacA-&gt;properties = NULL;
1006     return RX_DESTROY;
1007   }
1008   return result;
1009 }
1010 int outcome_intersect(struct volume *world, struct rxn *rx, int path,
1011                       struct wall *surface, struct abstract_molecule *reac,
1012                       short orient, double t, struct vector3 *hitpt,
1013                       struct vector3 *loc_okay) {
1014   if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
1015     rx-&gt;n_occurred++;
1016     if (rx-&gt;n_pathways == RX_REFLEC)
1017       return RX_A_OK;
1018     else
1019       return RX_FLIP;   }
1020   int idx = rx-&gt;product_idx[path];
1021   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1022     struct volume_molecule *vm = (struct volume_molecule *)reac;
1023     int result;
1024     if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
1025         (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
1026       result = RX_DESTROY;
1027     } else {
1028       result = outcome_products_random(world, surface, hitpt, t, rx, path,
1029                                        reac, NULL, orient, 0);
1030     }
1031     if (result == RX_BLOCKED)
1032       return RX_A_OK; 
1033     rx-&gt;info[path].count++;
1034     rx-&gt;n_occurred++;
1035     if (rx-&gt;players[idx] == NULL) {
1036       vm-&gt;subvol-&gt;mol_count--;
1037       if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
1038         if (hitpt == NULL) {
1039           count_region_from_scratch(
1040             world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
1041         } else {
1042           struct vector3 fake_hitpt;
1043           if (loc_okay == NULL)
1044             loc_okay = &amp;(vm-&gt;pos);
1045           fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
1046           fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
1047           fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
1048           count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
1049                                     t, reac-&gt;periodic_box);
1050         }
1051       }
1052       free(reac-&gt;periodic_box);
1053       reac-&gt;properties-&gt;n_deceased++;
1054       double t_time = convert_iterations_to_seconds(
1055           world-&gt;start_iterations, world-&gt;time_unit,
1056           world-&gt;simulation_start_seconds, t);
1057       reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
1058       reac-&gt;properties-&gt;population--;
1059       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1060         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1061       }
1062 #ifdef DEBUG_RXNS
1063       DUMP_CONDITION3(
1064          dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
1065       );
1066 #endif
1067       collect_molecule(vm);
1068       return RX_DESTROY;
1069     } else
1070       return result;   } else {
1071     return RX_A_OK;
1072   }
1073 }
1074 int reaction_wizardry(struct volume *world, struct magic_list *incantation,
1075                       struct wall *surface, struct vector3 *hitpt, double t) {
1076   struct release_event_queue req; 
1077   req.next = NULL;
1078   req.event_time = t;
1079   req.train_counter = 0;
1080   req.train_high_time = t;
1081   if (hitpt == NULL) {
1082     init_matrix(req.t_matrix);
1083   } else if (surface == NULL ||
1084              !distinguishable(surface-&gt;normal.z, 1.0,
1085                               EPS_C))   {
1086     init_matrix(req.t_matrix);
1087     req.t_matrix[3][0] = hitpt-&gt;x;
1088     req.t_matrix[3][1] = hitpt-&gt;y;
1089     req.t_matrix[3][2] = hitpt-&gt;z;
1090   {
1091     struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };  <a name="3"></a>    double cos_theta;
1092     double degrees;
1093 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
1094       degrees = 180.0;     } else {
1095       axis.x = -surface-&gt;normal.y;
1096       axis.y = surface-&gt;normal.x;
1097       axis.z = 0.0;
1098       degrees = acos(cos_theta) * 180.0 / MY_PI;
1099     }</b></font>
1100     tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
1101   }
1102   for (; incantation != NULL; incantation = incantation-&gt;next) {
1103     if (incantation-&gt;type != magic_release)
1104       continue; 
1105     req.release_site = (struct release_site_obj *)incantation-&gt;data;
1106     if (release_molecules(world, &amp;req))
1107       return 1;
1108   }
1109   return 0;
1110 }
1111 int determine_molecule_region_topology(
1112     struct volume *world, struct surface_molecule *sm_1,
1113     struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
1114     struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
1115     struct region_list **rlp_obj_2_ptr, bool is_unimol) {
1116   int sm_bitmask = 0;
1117   struct wall *w_1, *w_2;
1118   struct region_list *rlp_head_wall_1 = NULL;
1119   struct region_list *rlp_head_wall_2 = NULL;
1120   struct region_list *rlp_head_obj_1 = NULL;
1121   struct region_list *rlp_head_obj_2 = NULL;
1122   if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
1123     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1124         (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1125         are_restricted_regions_for_species_on_object(
1126             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1127         are_restricted_regions_for_species_on_object(
1128             world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
1129       w_1 = sm_1-&gt;grid-&gt;surface;
1130       w_2 = sm_2-&gt;grid-&gt;surface;
1131       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1132       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1133       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
1134         sm_bitmask |= ALL_INSIDE;
1135       }
1136       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1137         rlp_head_obj_1 =
1138             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1139         rlp_head_obj_2 =
1140             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1141         sm_bitmask |= ALL_OUTSIDE;
1142       }
1143       else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1144         rlp_head_obj_2 =
1145             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1146         sm_bitmask |= SURF1_IN_SURF2_OUT;
1147       }
1148       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
1149         rlp_head_obj_1 =
1150             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1151         sm_bitmask |= SURF1_OUT_SURF2_IN;
1152       }
1153     }
1154     else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1155              are_restricted_regions_for_species_on_object(
1156                  world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1157              (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1158               !are_restricted_regions_for_species_on_object(
1159                    world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
1160 <a name="0"></a>      w_1 = sm_1-&gt;grid-&gt;surface;
1161       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1162       if (rlp_head_wall_1 != NULL) {
1163 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= SURF1_IN;
1164       } else {
1165         rlp_head_obj_1 =
1166             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1167         sm_bitmask |= SURF1_OUT;
1168       }
1169     }
1170     else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1171              are_restricted_regions_for_species_on_object(
1172                  world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
1173              (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1174               !are_restricted_regions_for_species_on_object(
1175                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {
1176       w_2 = sm_2-&gt;grid-&gt;surface;
1177       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1178       if (rlp_head_wall_2 != NULL) {</b></font>
1179         sm_bitmask |= SURF2_IN;
1180       } else {
1181         rlp_head_obj_2 =
1182             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1183         sm_bitmask |= SURF2_OUT;
1184       }
1185     }
1186   }
1187   else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
1188     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1189         are_restricted_regions_for_species_on_object(
1190             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
1191 <a name="1"></a>      w_1 = sm_1-&gt;grid-&gt;surface;
1192       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1193       if (rlp_head_wall_1 != NULL) {
1194 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= ALL_INSIDE;
1195       } else {
1196         rlp_head_obj_1 =
1197             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1198         sm_bitmask |= ALL_OUTSIDE;
1199       }
1200     }
1201   }
1202   *rlp_wall_1_ptr = rlp_head_wall_1;
1203   *rlp_wall_2_ptr = rlp_head_wall_2;
1204   *rlp_obj_1_ptr = rlp_head_obj_1;
1205   *rlp_obj_2_ptr = rlp_head_obj_2;</b></font>
1206   return sm_bitmask;
1207 }
1208 bool product_tile_can_be_reached(struct wall *target,
1209                                  struct region_list *rlp_head_wall_1,
1210                                  struct region_list *rlp_head_wall_2,
1211                                  struct region_list *rlp_head_obj_1,
1212                                  struct region_list *rlp_head_obj_2,
1213                                  int sm_bitmask, bool is_unimol) {
1214   bool status = true;
1215   if (sm_bitmask &amp; ALL_INSIDE) {
1216     if (is_unimol) {
1217       if (!wall_belongs_to_all_regions_in_region_list(target,
1218                                                       rlp_head_wall_1)) {
1219         status = false;
1220       }
1221     } else {
1222       if (!wall_belongs_to_all_regions_in_region_list(target,
1223                                                       rlp_head_wall_1) ||
1224           !wall_belongs_to_all_regions_in_region_list(target,
1225                                                       rlp_head_wall_2)) {
1226         status = false;
1227       }
1228     }
1229   } else if (sm_bitmask &amp; ALL_OUTSIDE) {
1230     if (is_unimol) {
1231       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1232         status = false;
1233       }
1234     } else {
1235       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1236           wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1237         status = false;
1238       }
1239 <a name="2"></a>    }
1240   } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
1241     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
1242 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1243       status = false;
1244     }
1245   } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
1246     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1247         !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1248       status = false;
1249     }
1250   } else if (sm_bitmask &amp; SURF1_IN) {</b></font>
1251     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
1252       status = false;
1253     }
1254   } else if (sm_bitmask &amp; SURF1_OUT) {
1255     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1256       status = false;
1257     }
1258   } else if (sm_bitmask &amp; SURF2_IN) {
1259     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1260       status = false;
1261     }
1262   } else if (sm_bitmask &amp; SURF2_OUT) {
1263     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1264       status = false;
1265     }
1266   }
1267   return status;
1268 }
1269 int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
1270   if (tn1 != NULL) {
1271     delete_tile_neighbor_list(tn1);
1272   }
1273   if (tn2 != NULL) {
1274     delete_tile_neighbor_list(tn2);
1275   }
1276   return RX_BLOCKED;
1277 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>diffuse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include "diffuse.h"
7 #include "logging.h"
8 #include "mcell_structs.h"
9 #include "count_util.h"
10 #include "grid_util.h"
11 #include "vol_util.h"
12 #include "wall_util.h"
13 #include "react.h"
14 #include "react_nfsim.h"
15 #include "nfsim_func.h"
16 #include "debug_config.h"
17 #include "debug.h"
18 #include "dump_state.h"
19 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
20 #include &lt;vector&gt;
21 #endif
22 #define FREE_COLLISION_LISTS()                                                 \
23   do {                                                                         \
24     if (shead2 != NULL)                                                        \
25       mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);                           \
26     if (shead != NULL)                                                         \
27       mem_put_list(sv-&gt;local_storage-&gt;coll, shead);                            \
28   } while (0)
29 static const int inert_to_mol = 1;
30 static const int inert_to_all = 2;
31 int move_sm_on_same_triangle(
32     struct volume *state,
33     struct surface_molecule *sm,
34     struct vector2 *new_loc,
35     struct periodic_image *previous_box,
36     struct wall *new_wall,
37     struct hit_data *hd_info);
38 static void redo_collision_list(struct volume* world, struct collision** shead,
39   struct collision** stail, struct collision** shead_exp,
40   struct volume_molecule* m, struct vector3* displacement, struct subvolume* sv);
41 static int collide_and_react_with_vol_mol(
42   struct volume* world, struct collision* smash, struct volume_molecule* vm,
43   struct collision** tentative, struct vector3* displacement,
44   struct vector3* loc_certain, double t_steps, double r_rate_factor);
45 static int collide_and_react_with_surf_mol(
46   struct volume* world, struct collision* smash, struct volume_molecule* vm,
47   struct collision** tentative, struct vector3** loc_certain, double t_steps,
48   int mol_grid_flag, int mol_mol_grid_flag, double r_rate_factor);
49 static int collide_and_react_with_walls(
50   struct volume* world, struct collision* smash, struct volume_molecule* vm,
51   struct collision** tentative, struct vector3** loc_certain, double t_steps,
52   int inertness, double r_rate_factor);
53 static int reflect_or_periodic_bc(
54   struct volume* world, struct collision* smash, struct vector3* displacement,
55   struct volume_molecule** mol, struct wall** reflectee,
56   struct collision** tentative, double* t_steps);
57 static void reflect_absorb_inside_out(
58     struct volume *world, struct surface_molecule *sm, struct hit_data *hd_head,
59     struct rxn **rx, struct rxn *matching_rxns[], struct vector2 boundary_pos,
60     struct wall *this_wall, int index_edge_was_hit, int *reflect_now,
61     int *absorb_now, int *this_wall_edge_region_border);
62 int reflect_absorb_outside_in( 
63     struct volume *world,
64     struct surface_molecule *sm,
65     struct hit_data **hd_head,
66     struct rxn **rx,
67     struct rxn *matching_rxns[],
68     struct vector2 boundary_pos,
69     struct wall *target_wall,
70     struct wall *this_wall,
71     int *reflect_now,
72     int *absorb_now,
73     int this_wall_edge_region_border);
74 void collide_and_react_with_subvol(
75   struct volume* world, struct collision *smash, struct vector3* displacement,
76   struct volume_molecule** mol, struct collision** tentative, double* t_steps);
77 void compute_displacement(
78   struct volume* world, struct collision* shead, struct volume_molecule* vm,
79   struct vector3* displacement, struct vector3* displacement2,
80   double* rate_factor, double* r_rate_factor, double* steps, double* t_steps,
81   double max_time);
82 void determine_mol_mol_reactions(
83   struct volume* world, struct volume_molecule* vm, struct collision** shead,
84   struct collision** stail, int interness);
85 void set_inertness_and_maxtime(
86   struct volume* world, struct volume_molecule* vm, double* maxtime,
87   int* inertness);
88 void register_hits(
89   struct volume* world, struct volume_molecule* m,
90   struct collision** tentative, struct wall** reflect_w, double* reflect_t,
91   struct vector3* displacement, struct collision* smash, double* t_steps);
92 void count_tentative_collisions(
93   struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
94   struct species *spec, double t_confident, int destroy_flag,
95   struct periodic_image *box, u_long id);
96 void change_boxes_2D(
97     bool periodic_traditional,
98     struct surface_molecule *sm,
99     struct geom_object *periodic_box_obj,
100     struct vector3 *hit_xyz,
101     struct vector3 *teleport_xyz);
102 void pick_2D_displacement(struct vector2 *v, double scale,
103                           struct rng_state *rng) {
104   static const double one_over_2_to_16th = 1.52587890625e-5;
105   struct vector2 a;
106   double f;
107   do {
108     unsigned int n = rng_uint(rng);
109     a.u = 2.0 * one_over_2_to_16th * (n &amp; 0xFFFF) - 1.0;
110     a.v = 2.0 * one_over_2_to_16th * (n &gt;&gt; 16) - 1.0;
111     f = a.u * a.u + a.v * a.v;
112   } while ((f &lt; EPS_C) || (f &gt; 1.0));
113   double normalFactor = sqrt(-log(f) / f);
114   v-&gt;u = a.u * normalFactor * scale;
115   v-&gt;v = a.v * normalFactor * scale;
116 }
117 void pick_clamped_displacement(struct vector3 *v, struct volume_molecule *vm,
118                                double *r_step_surface, struct rng_state *rng,
119                                u_int radial_subdivisions) {
120   static const double one_over_2_to_20th = 9.5367431640625e-7;
121   struct wall *w = vm-&gt;previous_wall;
122   unsigned int n = rng_uint(rng);
123   double r_n = r_step_surface[n &amp; (radial_subdivisions - 1)];
124   double p = one_over_2_to_20th * ((n &gt;&gt; 12) + 0.5);
125   double t = r_n / erfcinv(p * erfc(r_n));
126   struct vector2 r_uv;
127   pick_2D_displacement(&amp;r_uv, sqrt(t) * vm-&gt;get_space_step(vm), rng);
128   r_n *= vm-&gt;index * vm-&gt;get_space_step(vm);
129   v-&gt;x = r_n * w-&gt;normal.x + r_uv.u * w-&gt;unit_u.x + r_uv.v * w-&gt;unit_v.x;
130   v-&gt;y = r_n * w-&gt;normal.y + r_uv.u * w-&gt;unit_u.y + r_uv.v * w-&gt;unit_v.y;
131   v-&gt;z = r_n * w-&gt;normal.z + r_uv.u * w-&gt;unit_u.z + r_uv.v * w-&gt;unit_v.z;
132 }
133 void pick_release_displacement(struct vector3 *in_disk, struct vector3 *away,
134                                double scale, double *r_step_release,
135                                double *d_step, u_int radial_subdivisions,
136                                int directions_mask, u_int num_directions,
137                                double rx_radius_3d, struct rng_state *rng) {
138   static const double one_over_2_to_16th = 1.52587890625e-5;
139   struct vector2 disk;
140   struct vector3 orth, axo;
141   u_int bits = rng_uint(rng);
142   u_int x_bit = (bits &amp; 0x80000000);
143   u_int y_bit = (bits &amp; 0x40000000);
144   u_int z_bit = (bits &amp; 0x20000000);
145   u_int thetaphi_bits = (bits &amp; 0x1FFFF000) &gt;&gt; 12;
146   u_int r_bits = (bits &amp; 0x00000FFF);
147   double r = scale * r_step_release[r_bits &amp; (radial_subdivisions - 1)];
148   u_int idx = thetaphi_bits &amp; directions_mask;
149   while (idx &gt;= num_directions) {
150     idx = rng_uint(rng) &amp; directions_mask;
151   }
152   if (x_bit)
153     away-&gt;x = d_step[idx];
154   else
155     away-&gt;x = -d_step[idx];
156   if (y_bit)
157     away-&gt;y = d_step[idx + 1];
158   else
159     away-&gt;y = -d_step[idx + 1];
160   if (z_bit)
161     away-&gt;z = d_step[idx + 2];
162   else
163     away-&gt;z = -d_step[idx + 2];
164   if (d_step[idx] &lt; d_step[idx + 1]) {
165     if (d_step[idx] &lt; d_step[idx + 2]) {
166       orth.x = 0;
167       orth.y = away-&gt;z;
168       orth.z = -away-&gt;y;
169     } else {
170       orth.x = away-&gt;y;
171       orth.y = -away-&gt;x;
172       orth.z = 0;
173     }
174   } else if (d_step[idx + 1] &lt; d_step[idx + 2]) {
175     orth.x = away-&gt;z;
176     orth.y = 0;
177     orth.z = -away-&gt;x;
178   } else {
179     orth.x = away-&gt;y;
180     orth.y = -away-&gt;x;
181     orth.z = 0;
182   }
183   normalize(&amp;orth);
184   cross_prod(away, &amp;orth, &amp;axo);
185   double f;
186   do {
187     bits = rng_uint(rng);
188     disk.u = 2.0 * one_over_2_to_16th * (bits &amp; 0xFFFF) - 1.0;
189     disk.v = 2.0 * one_over_2_to_16th * (bits &gt;&gt; 16) - 1.0;
190     f = disk.u * disk.u + disk.v * disk.v;
191   } while (f &lt; 0.01 || f &gt; 1.0);
192   in_disk-&gt;x = (disk.u * orth.x + disk.v * axo.x) * rx_radius_3d;
193   in_disk-&gt;y = (disk.u * orth.y + disk.v * axo.y) * rx_radius_3d;
194   in_disk-&gt;z = (disk.u * orth.z + disk.v * axo.z) * rx_radius_3d;
195   away-&gt;x *= r;
196   away-&gt;y *= r;
197   away-&gt;z *= r;
198 }
199 void pick_displacement(struct vector3 *v, double scale, struct rng_state *rng) {
200   v-&gt;x = scale * rng_gauss(rng) * .70710678118654752440;
201   v-&gt;y = scale * rng_gauss(rng) * .70710678118654752440;
202   v-&gt;z = scale * rng_gauss(rng) * .70710678118654752440;
203 }
204 struct vector3* reflect_periodic_2D(
205     struct volume *state,
206     int index_edge_was_hit,
207     struct vector2 *origin_uv,
208     struct wall *curr_wall,
209     struct vector2 *disp_uv,
210     struct vector2 *boundary_uv,
211     struct vector3 *origin_xyz) {
212   struct vector3 target_xyz;
213   struct vector2 target_uv = {
214     origin_uv-&gt;u + disp_uv-&gt;u,
215     origin_uv-&gt;v + disp_uv-&gt;v
216   };
217   if (index_edge_was_hit == -1) {
218     uv2xyz(&amp;target_uv, curr_wall, &amp;target_xyz);
219   }
220   else if (index_edge_was_hit == 0 || 
221            index_edge_was_hit == 1 ||
222            index_edge_was_hit == 2) {
223     uv2xyz(boundary_uv, curr_wall, &amp;target_xyz);
224   }
225   else {
226     return NULL;
227   }
228   struct vector3 delta_xyz = {target_xyz.x - origin_xyz-&gt;x,
229                               target_xyz.y - origin_xyz-&gt;y,
230                               target_xyz.z - origin_xyz-&gt;z};
231   struct vector3 updated_xyz = *origin_xyz;
232   for (struct subvolume *sv = find_subvolume(state, origin_xyz, NULL);
233        sv != NULL; sv = next_subvol(
234           &amp;updated_xyz, &amp;delta_xyz, sv, state-&gt;x_fineparts, state-&gt;y_fineparts,
235           state-&gt;z_fineparts, state-&gt;ny_parts,
236           state-&gt;nz_parts)) {
237     for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
238       if (wl-&gt;this_wall-&gt;parent_object != state-&gt;periodic_box_obj) {
239         continue;
240       }
241       struct vector3 *hit_xyz = (struct vector3 *)malloc(sizeof(*hit_xyz));
242       double t = 0.0;
243       int i = collide_wall(
244           &amp;updated_xyz, &amp;delta_xyz, wl-&gt;this_wall, &amp;t, hit_xyz, 0, state-&gt;rng,
245           state-&gt;notify, &amp;(state-&gt;ray_polygon_tests));
246       if (i != COLLIDE_MISS &amp;&amp;
247           (hit_xyz-&gt;x - target_xyz.x) * delta_xyz.x +
248           (hit_xyz-&gt;y - target_xyz.y) * delta_xyz.y +
249           (hit_xyz-&gt;z - target_xyz.z) * delta_xyz.z &lt; 0) {
250         if (!state-&gt;periodic_traditional) {
251           struct vector2 hit_uv;
252           xyz2uv(hit_xyz, curr_wall, &amp;hit_uv);
253           disp_uv-&gt;u = -(target_uv.u-hit_uv.u);
254           disp_uv-&gt;v = -(target_uv.v-hit_uv.v);
255           origin_uv-&gt;u = hit_uv.u;
256           origin_uv-&gt;v = hit_uv.v;
257         }
258         return hit_xyz;
259       }
260       free(hit_xyz);
261     }
262   }
263   return NULL;
264 }
265 void change_boxes_2D(
266     bool periodic_traditional,
267     struct surface_molecule *sm,
268     struct geom_object *periodic_box_obj,
269     struct vector3 *hit_xyz,
270     struct vector3 *teleport_xyz) {
271   assert(periodic_box_obj-&gt;object_type == BOX_OBJ);
272   struct polygon_object* p = (struct polygon_object*)(periodic_box_obj-&gt;contents);
273   struct subdivided_box* sb = p-&gt;sb;
274   double llx = sb-&gt;x[0];
275   double urx = sb-&gt;x[1];
276   double lly = sb-&gt;y[0];
277   double ury = sb-&gt;y[1];
278   double llz = sb-&gt;z[0];
279   double urz = sb-&gt;z[1];
280   int x_inc = (sm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
281   int y_inc = (sm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
282   int z_inc = (sm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
283   int box_inc_x = 0;
284   int box_inc_y = 0;
285   int box_inc_z = 0;
286   double x_pos = 0;
287   double y_pos = 0;
288   double z_pos = 0;
289   if (!distinguishable(hit_xyz-&gt;x, llx, EPS_C)) {
290     x_pos = urx - EPS_C;
291     box_inc_x = -x_inc;
292   } else if (!distinguishable(hit_xyz-&gt;x, urx, EPS_C)) {
293     x_pos = llx + EPS_C;
294     box_inc_x = x_inc;
295   }
296   if (periodic_traditional &amp;&amp; x_pos) {
297     teleport_xyz-&gt;x = x_pos;
298   }
299   if (!distinguishable(hit_xyz-&gt;y, lly, EPS_C)) {
300     y_pos = ury - EPS_C;
301     box_inc_y = -y_inc;
302   } else if (!distinguishable(hit_xyz-&gt;y, ury, EPS_C)) {
303     y_pos = lly + EPS_C;
304     box_inc_y = y_inc;
305   }
306   if (periodic_traditional &amp;&amp; y_pos) {
307     teleport_xyz-&gt;y = y_pos;
308   }
309   if (!distinguishable(hit_xyz-&gt;z, llz, EPS_C)) {
310     z_pos = urz - EPS_C;
311     box_inc_z = -z_inc;
312   } else if (!distinguishable(hit_xyz-&gt;z, urz, EPS_C)) {
313     z_pos = llz + EPS_C;
314     box_inc_z = z_inc;
315   }
316   if (periodic_traditional &amp;&amp; z_pos) {
317     teleport_xyz-&gt;z = z_pos;
318   }
319   if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
320     sm-&gt;periodic_box-&gt;x += box_inc_x;
321     sm-&gt;periodic_box-&gt;y += box_inc_y;
322     sm-&gt;periodic_box-&gt;z += box_inc_z;
323   }
324 }
325 void reflect_absorb_inside_out(
326     struct volume *world,
327     struct surface_molecule *sm,
328     struct hit_data *hd_head,
329     struct rxn **rx,
330     struct rxn *matching_rxns[],
331     struct vector2 boundary_pos,
332     struct wall *this_wall,
333     int index_edge_was_hit,
334     int *reflect_now,
335     int *absorb_now,
336     int *this_wall_edge_region_border) {
337   struct edge *this_edge = this_wall-&gt;edges[index_edge_was_hit];
338   if (is_wall_edge_region_border(this_wall, this_edge)) {
339     *this_wall_edge_region_border = 1;
340   }
341   struct wall *nbr_wall = NULL;
342   int nbr_edge_ind = -1;
343   find_neighbor_wall_and_edge(this_wall, index_edge_was_hit, &amp;nbr_wall, &amp;nbr_edge_ind);
344   int nbr_wall_edge_region_border = 0;
345   if (nbr_wall != NULL) {
346     if (is_wall_edge_region_border(nbr_wall, nbr_wall-&gt;edges[nbr_edge_ind])) {
347       nbr_wall_edge_region_border = 1;
348     }
349   }
350   if (is_wall_edge_restricted_region_border(world, this_wall, this_edge, sm)) {
351     int num_matching_rxns = trigger_intersect(
352         world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
353         world-&gt;all_volume_mols, world-&gt;all_surface_mols,
354         sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm, sm-&gt;orient,
355         this_wall, matching_rxns, 1, 1, 1);
356     for (int i = 0; i &lt; num_matching_rxns; i++) {
357       *rx = matching_rxns[i];
358       if ((*rx)-&gt;n_pathways == RX_REFLEC) {
359         *reflect_now = 1;
360         break;
361       } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
362         *absorb_now = 1;
363         break;
364       }
365     }
366     if (reflect_now || absorb_now) {
367       if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
368         update_hit_data(&amp;hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
369       }
370       if (nbr_wall != NULL &amp;&amp; nbr_wall_edge_region_border) {
371         if (nbr_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
372           update_hit_data(&amp;hd_head, this_wall, nbr_wall, sm, boundary_pos, 0, 0);
373         }
374       }
375     }
376   }
377 }
378 int reflect_absorb_outside_in( 
379     struct volume *world,
380     struct surface_molecule *sm,
381     struct hit_data **hd_head,
382     struct rxn **rx,
383     struct rxn *matching_rxns[],
384     struct vector2 boundary_pos,
385     struct wall *target_wall,
386     struct wall *this_wall,
387     int *reflect_now,
388     int *absorb_now,
389     int this_wall_edge_region_border) {
390   int target_edge_ind = find_shared_edge_index_of_neighbor_wall(this_wall, target_wall);
391   int target_wall_edge_region_border = 0;
392   if (is_wall_edge_region_border(target_wall, target_wall-&gt;edges[target_edge_ind])) {
393     target_wall_edge_region_border = 1;
394   }
395   if (is_wall_edge_restricted_region_border(world, target_wall, target_wall-&gt;edges[target_edge_ind], sm)) {
396     *reflect_now = 0;
397     *absorb_now = 0;
398     int num_matching_rxns = trigger_intersect(
399         world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
400         world-&gt;all_volume_mols, world-&gt;all_surface_mols,
401         sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
402         sm-&gt;orient, target_wall, matching_rxns, 1, 1, 1);
403     for (int i = 0; i &lt; num_matching_rxns; i++) {
404       *rx = matching_rxns[i];
405       if ((*rx)-&gt;n_pathways == RX_REFLEC) {
406         *reflect_now = 1;
407         break;
408       } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
409         *absorb_now = 1;
410         break;
411       }
412     }
413     if (*reflect_now || *absorb_now) {
414       if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
415         update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 0);
416         update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
417       }
418     }
419     if (*reflect_now || *absorb_now) {
420       return 1; 
421     }
422   }
423   if (this_wall_edge_region_border) {
424     if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
425       update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 1);
426     }
427   }
428   if (target_wall_edge_region_border) {
429     if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
430       update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 1);
431     }
432   }
433   return 0;
434 }
435 struct wall *ray_trace_2D(
436     struct volume *world,
437     struct surface_molecule *sm,
438     struct vector2 *disp,
439     struct vector2 *pos,
440     int *kill_me,
441     struct rxn **rxp,
442     struct hit_data **hit_data_info) {
443   struct hit_data *hit_data_head = NULL;
444   struct wall *this_wall = sm-&gt;grid-&gt;surface;
445   struct vector2 orig_pos = { sm-&gt;s_pos.u,
446                               sm-&gt;s_pos.v
447                             };
448   struct vector2 this_pos = { sm-&gt;s_pos.u,
449                              sm-&gt;s_pos.v
450                             };
451   struct vector2 this_disp = { disp-&gt;u,
452                               disp-&gt;v
453                              };
454   struct periodic_image orig_box = {sm-&gt;periodic_box-&gt;x,
455                                     sm-&gt;periodic_box-&gt;y,
456                                     sm-&gt;periodic_box-&gt;z
457                                    };
458   struct vector3 origin_xyz;
459   uv2xyz(&amp;this_pos, this_wall, &amp;origin_xyz);
460   struct rxn *rx = NULL;
461   while (1) {
462     int this_wall_edge_region_border = 0;
463     int absorb_now = 0;
464     int reflect_now = 0;
465     struct vector2 boundary_pos;
466     int index_edge_was_hit =
467         find_edge_point(this_wall, &amp;this_pos, &amp;this_disp, &amp;boundary_pos);
468     if (world-&gt;periodic_box_obj) {
469       struct vector3 *hit_xyz = reflect_periodic_2D(
470           world,
471           index_edge_was_hit,
472           &amp;this_pos,
473           this_wall,
474           &amp;this_disp,
475           &amp;boundary_pos,
476           &amp;origin_xyz);
477       if (hit_xyz) {
478         struct vector3 teleport_xyz = {hit_xyz-&gt;x,
479                                        hit_xyz-&gt;y,
480                                        hit_xyz-&gt;z
481                                       };
482         change_boxes_2D(
483           world-&gt;periodic_traditional, sm, world-&gt;periodic_box_obj, hit_xyz,
484           &amp;teleport_xyz);
485         if (world-&gt;periodic_traditional) {
486           struct vector2 target_uv = { this_pos.u + this_disp.u,
487                                       this_pos.v + this_disp.v
488                                      };
489           struct vector3 target_xyz;
490           uv2xyz(&amp;target_uv, this_wall, &amp;target_xyz);
491           struct vector3 remaining_disp_xyz = {target_xyz.x - hit_xyz-&gt;x,
492                                                target_xyz.y - hit_xyz-&gt;y,
493                                                target_xyz.z - hit_xyz-&gt;z
494                                               };
495           struct vector3 new_target_xyz = {teleport_xyz.x + remaining_disp_xyz.x,
496                                            teleport_xyz.y + remaining_disp_xyz.y,
497                                            teleport_xyz.z + remaining_disp_xyz.z,
498                                           };
499           int grid_index = 0;
500           int *grid_index_p = &amp;grid_index;
501           struct wall *prev_wall = this_wall;
502           this_wall = find_closest_wall(
503             world, &amp;teleport_xyz, 0.0, &amp;this_pos, grid_index_p, sm-&gt;properties, NULL, NULL, NULL);
504           if ((this_wall == NULL) ||
505               (this_wall-&gt;parent_object != prev_wall-&gt;parent_object) ) {
506             *hit_data_info = hit_data_head;
507             free(hit_xyz);
508             return NULL;
509           }
510           struct vector2 new_target_uv;
511           xyz2uv(&amp;new_target_xyz, this_wall, &amp;new_target_uv);
512           this_disp.u = new_target_uv.u - this_pos.u;
513           this_disp.v = new_target_uv.v - this_pos.v;
514         }
515         else {
516           origin_xyz.x = hit_xyz-&gt;x;
517           origin_xyz.y = hit_xyz-&gt;y;
518           origin_xyz.z = hit_xyz-&gt;z;
519         }
520         free(hit_xyz);
521         continue;
522       }
523     }
524     if (index_edge_was_hit == -2) {
525       sm-&gt;s_pos.u = orig_pos.u;
526       sm-&gt;s_pos.v = orig_pos.v;
527       sm-&gt;periodic_box-&gt;x = orig_box.x;
528       sm-&gt;periodic_box-&gt;y = orig_box.y;
529       sm-&gt;periodic_box-&gt;z = orig_box.z;
530       *hit_data_info = hit_data_head;
531       return NULL;
532     }
533     else if (index_edge_was_hit == -1) {
534       pos-&gt;u = this_pos.u + this_disp.u;
535       pos-&gt;v = this_pos.v + this_disp.v;
536       sm-&gt;s_pos.u = orig_pos.u;
537       sm-&gt;s_pos.v = orig_pos.v;
538       *hit_data_info = hit_data_head;
539       return this_wall;
540     }
541     struct vector2 old_pos = {this_pos.u,
542                              this_pos.v
543                              };
544     struct rxn *matching_rxns[MAX_MATCHING_RXNS];
545     if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
546       reflect_absorb_inside_out(
547           world, sm, hit_data_head, &amp;rx, matching_rxns, boundary_pos, this_wall,
548           index_edge_was_hit, &amp;reflect_now, &amp;absorb_now,
549           &amp;this_wall_edge_region_border);
550       if (absorb_now) {
551         *kill_me = 1;
552         *rxp = rx;
553         *hit_data_info = hit_data_head;
554         return NULL;
555       }
556     }
557     struct vector2 new_disp;
558     if (!reflect_now) {
559       struct wall *target_wall =
560           traverse_surface(this_wall, &amp;old_pos, index_edge_was_hit, &amp;this_pos);
561       if (target_wall != NULL) {
562         if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
563           if (reflect_absorb_outside_in(
564               world, sm, &amp;hit_data_head, &amp;rx, matching_rxns, boundary_pos,
565               target_wall, this_wall, &amp;reflect_now, &amp;absorb_now,
566               this_wall_edge_region_border)) {
567             if (absorb_now) {
568               *kill_me = 1;
569               *rxp = rx;
570               *hit_data_info = hit_data_head;
571               return NULL;
572             }
573           }
574         }
575         if (!reflect_now) {
576           this_disp.u = old_pos.u + this_disp.u;
577           this_disp.v = old_pos.v + this_disp.v;
578           traverse_surface(this_wall, &amp;this_disp, index_edge_was_hit, &amp;new_disp);
579           this_disp.u = new_disp.u - this_pos.u;
580           this_disp.v = new_disp.v - this_pos.v;
581           this_wall = target_wall;
582           continue;
583         }
584       }
585     }
586     if (!reflect_now) {
587       *hit_data_info = hit_data_head;
588     }
589     new_disp.u = this_disp.u - (boundary_pos.u - old_pos.u);
590     new_disp.v = this_disp.v - (boundary_pos.v - old_pos.v);
591     double f;
592     struct vector2 reflector;
593     switch (index_edge_was_hit) {
594     case 0:
595       new_disp.v *= -1.0;
596       break;
597     case 1:
598       reflector.u = -this_wall-&gt;uv_vert2.v;
599       reflector.v = this_wall-&gt;uv_vert2.u - this_wall-&gt;uv_vert1_u;
600       f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
601       reflector.u *= f;
602       reflector.v *= f;
603       f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
604       new_disp.u -= f * reflector.u;
605       new_disp.v -= f * reflector.v;
606       break;
607     case 2:
608       reflector.u = this_wall-&gt;uv_vert2.v;
609       reflector.v = -this_wall-&gt;uv_vert2.u;
610       f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
611       reflector.u *= f;
612       reflector.v *= f;
613       f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
614       new_disp.u -= f * reflector.u;
615       new_disp.v -= f * reflector.v;
616       break;
617     default:
618       UNHANDLED_CASE(index_edge_was_hit);
619     }
620     this_pos.u = boundary_pos.u;
621     this_pos.v = boundary_pos.v;
622     this_disp.u = new_disp.u;
623     this_disp.v = new_disp.v;
624   } 
625   sm-&gt;s_pos.u = orig_pos.u;
626   sm-&gt;s_pos.v = orig_pos.v;
627   *hit_data_info = hit_data_head;
628   return NULL;
629 }
630 struct collision *ray_trace(struct volume *world, struct vector3 *init_pos,
631                             struct collision *c, struct subvolume *sv,
632                             struct vector3 *v, struct wall *reflectee) {
633   double tx, ty, tz;
634   world-&gt;ray_voxel_tests++;
635   struct collision *shead = NULL;
636   struct collision *smash = (struct collision *)CHECKED_MEM_GET(
637       sv-&gt;local_storage-&gt;coll, "collision structure");
638 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
639   std::vector&lt;wall_list*&gt; sorted_walls;
640   for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
641     sorted_walls.insert(sorted_walls.begin(), wlp);
642   }
643 #endif
644   struct wall_list fake_wlp;
645   fake_wlp.next = sv-&gt;wall_head;
646 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
647   for (unsigned wall_array_index = 0; wall_array_index &lt; sorted_walls.size(); wall_array_index++) {
648     struct wall_list *wlp = sorted_walls[wall_array_index];
649 #else
650   for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
651 #endif
652     if (wlp-&gt;this_wall == reflectee)
653       continue;
654 #ifdef DEBUG_COLLISIONS_WALL_EXTRA
655     DUMP_CONDITION3(
656         std::cout &lt;&lt; "Checking wall:\n";
657         dump_wall(wlp-&gt;this_wall, "", true);
658     );
659 #endif
660     int i = collide_wall(init_pos, v, wlp-&gt;this_wall, &amp;(smash-&gt;t), &amp;(smash-&gt;loc),
661                      1, world-&gt;rng, world-&gt;notify, &amp;(world-&gt;ray_polygon_tests));
662 #ifdef DEBUG_COLLISIONS_WALL_EXTRA
663     DUMP_CONDITION3(
664         if (i == COLLIDE_REDO || i == COLLIDE_FRONT || i == COLLIDE_BACK) {
665           std::cout &lt;&lt; "Collide wall: vm pos: " &lt;&lt; *init_pos  &lt;&lt; ", displacement: " &lt;&lt; *v &lt;&lt; "\n";
666           dump_wall(wlp-&gt;this_wall, "", true);
667           std::cout &lt;&lt; "collision time: " &lt;&lt; smash-&gt;t &lt;&lt; ", collision pos: " &lt;&lt; smash-&gt;loc &lt;&lt; "\n";
668         }
669     );
670 #endif
671     if (i == COLLIDE_REDO) {
672       if (shead != NULL)
673         mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
674       shead = NULL;
675       wlp = &amp;fake_wlp;
676 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
677       wall_array_index = 0;
678 #endif
679       continue;
680     } else if (i != COLLIDE_MISS) {
681       world-&gt;ray_polygon_colls++;
682       smash-&gt;what = COLLIDE_WALL + i;
683       smash-&gt;target = (void *)wlp-&gt;this_wall;
684       smash-&gt;next = shead;
685       shead = smash;
686       smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
687                                                   "collision structure");
688     }
689   }
690   double dx, dy, dz;
691   dx = dy = dz = 0.0;
692   int i = -10;
693   if (v-&gt;x &lt; 0.0) {
694     dx = world-&gt;x_fineparts[sv-&gt;llf.x] - init_pos-&gt;x;
695     i = 0;
696   } else if (v-&gt;x &gt; 0.0) {
697     dx = world-&gt;x_fineparts[sv-&gt;urb.x] - init_pos-&gt;x;
698     i = 1;
699   }
700   int j = -10;
701   if (v-&gt;y &lt; 0.0) {
702     dy = world-&gt;y_fineparts[sv-&gt;llf.y] - init_pos-&gt;y;
703     j = 0;
704   } else if (v-&gt;y &gt; 0.0) {
705     dy = world-&gt;y_fineparts[sv-&gt;urb.y] - init_pos-&gt;y;
706     j = 1;
707   }
708   int k = -10;
709   if (v-&gt;z &lt; 0.0) {
710     dz = world-&gt;z_fineparts[sv-&gt;llf.z] - init_pos-&gt;z;
711     k = 0;
712   } else if (v-&gt;z &gt; 0.0) {
713     dz = world-&gt;z_fineparts[sv-&gt;urb.z] - init_pos-&gt;z;
714     k = 1;
715   }
716   if (i + j + k &lt; 0)   {
717     if (i + j + k &lt; -15)     {
718       if (i &gt;= 0)       {
719         smash-&gt;t = dx / v-&gt;x;
720         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
721       } else if (j &gt;= 0)       {
722         smash-&gt;t = dy / v-&gt;y;
723         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
724       } else if (k &gt;= 0)       {
725         smash-&gt;t = dz / v-&gt;z;
726         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
727       } else {
728         smash-&gt;t = FOREVER;
729         smash-&gt;what =
730       }
731     } else     {
732       if (i &lt; 0) {
733         ty = fabs(dy * v-&gt;z);
734 <a name="0"></a>        tz = fabs(v-&gt;y * dz);
735         if (ty &lt; tz) {
736           smash-&gt;t = dy / v-&gt;y;
737 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
738         } else {
739           smash-&gt;t = dz / v-&gt;z;
740           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
741         }
742       } else if (j &lt; 0) {
743         tx = fabs(dx * v-&gt;z);
744         tz = fabs(v-&gt;x * dz);
745         if (tx &lt; tz) {</b></font>
746           smash-&gt;t = dx / v-&gt;x;
747           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
748         } else 
749 {          smash-&gt;t = dz / v-&gt;z;
750           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k
751 ;        }
752       } else       {
753         tx = fabs(dx * v-&gt;y);
754         ty = fabs(v-&gt;x * dy);
755         if (tx &lt; ty) {
756           smash-&gt;t = dx / v-&gt;x;
757           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
758         } else {
759           smash-&gt;t = dy / v-&gt;y;
760           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
761         }
762       }
763     }
764   } else   {
765     tx = fabs(dx * v-&gt;y * v-&gt;z);
766     ty = fabs(v-&gt;x * dy * v-&gt;z);
767     tz = fabs(v-&gt;x * v-&gt;y * dz);
768     if (tx &lt; ty) {
769       if (tx &lt; tz) {
770         smash-&gt;t = dx / v-&gt;x;
771         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
772       } else {
773         smash-&gt;t = dz / v-&gt;z;
774         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
775       }
776 <a name="1"></a>    } else {
777       if (ty &lt; tz) {
778         smash-&gt;t = dy / v-&gt;y;
779 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
780       } else {
781         smash-&gt;t = dz / v-&gt;z;
782         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
783       }
784     }
785   }
786   smash-&gt;loc.x = init_pos-&gt;x + smash-&gt;t * v-&gt;x;
787   smash-&gt;loc.y = init_pos-&gt;y + smash-&gt;t * v-&gt;y;
788   smash-&gt;loc.z = init_pos-&gt;z + smash-&gt;t * v-&gt;z;
789   smash-&gt;target = sv;</b></font>
790   smash-&gt;next = shead;
791   shead = smash;
792   for (; c != NULL; c = c-&gt;next) {
793     struct abstract_molecule *a = (struct abstract_molecule *)c-&gt;target;
794     if (a-&gt;properties == NULL)
795       continue;
796     i = collide_mol(init_pos, v, a, &amp;(c-&gt;t), &amp;(c-&gt;loc), world-&gt;rx_radius_3d);
797     if (i != COLLIDE_MISS) {
798       smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
799                                                   "collision structure");
800       memcpy(smash, c, sizeof(struct collision));
801       smash-&gt;what = COLLIDE_VOL + i;
802       smash-&gt;next = shead;
803       shead = smash;
804     }
805   }
806   return shead;
807 }
808 struct exd_vector3 {
809   double m, u, v;
810 };
811 static double exd_zetize(double y, double x) {
812   if (y &gt;= 0.0) {
813     if (x &gt;= 0) {
814       if (x &lt; y)
815         return 1.0 - 0.5 * x / y;
816       else
817         return 0.5 * y / x;
818     } else {
819       if (-x &lt; y)
820         return 1.0 - 0.5 * x / y;
821       else
822         return 2.0 + 0.5 * y / x;
823     }
824   } else {
825     if (x &lt;= 0) {
826       if (y &lt; x)
827         return 3.0 - 0.5 * x / y;
828       else
829         return 2.0 + 0.5 * y / x;
830     } else {
831       if (x &lt; -y)
832         return 3.0 - 0.5 * x / y;
833       else
834         return 4.0 + 0.5 * y / x;
835     }
836   }
837 }
838 static void exd_coordize(struct vector3 *mv, struct vector3 *m,
839                          struct vector3 *u, struct vector3 *v) {
840   double a;
841   a = 1.0 / sqrt(mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
842   m-&gt;x = a * mv-&gt;x;
843   m-&gt;y = a * mv-&gt;y;
844   m-&gt;z = a * mv-&gt;z;
845   if (m-&gt;x * m-&gt;x &gt; m-&gt;y * m-&gt;y) {
846     if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
847       if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
848         u-&gt;x = m-&gt;y;
849         u-&gt;y = -m-&gt;x;
850         u-&gt;z = 0.0;
851         a = 1.0 - m-&gt;z * m-&gt;z;
852         v-&gt;x = m-&gt;z * m-&gt;x;
853         v-&gt;y = m-&gt;z * m-&gt;y;
854         v-&gt;z = -a;
855       } else {
856         u-&gt;x = m-&gt;z;
857         u-&gt;y = 0.0;
858         u-&gt;z = -m-&gt;x;
859         a = 1.0 - m-&gt;y * m-&gt;y;
860         v-&gt;x = -m-&gt;y * m-&gt;x;
861         v-&gt;y = a;
862         v-&gt;z = -m-&gt;y * m-&gt;z;
863       }
864     } else {
865       u-&gt;x = -m-&gt;z;
866       u-&gt;y = 0.0;
867       u-&gt;z = m-&gt;x;
868       a = 1.0 - m-&gt;y * m-&gt;y;
869       v-&gt;x = m-&gt;y * m-&gt;x;
870       v-&gt;y = -a;
871       v-&gt;z = m-&gt;y * m-&gt;z;
872     }
873   } else {
874     if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
875       if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
876         u-&gt;x = -m-&gt;y;
877         u-&gt;y = m-&gt;x;
878         u-&gt;z = 0.0;
879         a = 1.0 - m-&gt;z * m-&gt;z;
880         v-&gt;x = -m-&gt;z * m-&gt;x;
881         v-&gt;y = -m-&gt;z * m-&gt;y;
882         v-&gt;z = a;
883       } else {
884         u-&gt;x = 0.0;
885         u-&gt;y = m-&gt;z;
886         u-&gt;z = -m-&gt;y;
887         a = 1.0 - m-&gt;x * m-&gt;x;
888         v-&gt;x = -a;
889         v-&gt;y = m-&gt;x * m-&gt;y;
890         v-&gt;z = m-&gt;x * m-&gt;z;
891       }
892     } else {
893       u-&gt;x = 0.0;
894       u-&gt;y = -m-&gt;z;
895       u-&gt;z = m-&gt;y;
896       a = 1.0 - m-&gt;x * m-&gt;x;
897       v-&gt;x = a;
898       v-&gt;y = -m-&gt;x * m-&gt;y;
899       v-&gt;z = -m-&gt;x * m-&gt;z;
900     }
901   }
902   a = 1 / sqrt(a);
903   u-&gt;x *= a;
904   u-&gt;y *= a;
905   u-&gt;z *= a;
906   v-&gt;x *= a;
907   v-&gt;y *= a;
908   v-&gt;z *= a;
909 }
910 enum {
911   EXD_HEAD,
912   EXD_TAIL,
913   EXD_CROSS,
914   EXD_SPAN,
915   EXD_OTHER
916 };
917 #define TARGET_OCCLUDED -1
918 double exact_disk(struct volume *world, struct vector3 *loc, struct vector3 *mv,
919                   double R, struct subvolume *sv,
920                   struct volume_molecule *moving,
921                   struct volume_molecule *target, int use_expanded_list,
922                   double *x_fineparts, double *y_fineparts,
923                   double *z_fineparts) {
924 #define EXD_SPAN_CALC(v1, v2, p)                                               \
925   ((v1)-&gt;u - (p)-&gt;u) * ((v2)-&gt;v - (p)-&gt;v) -                                    \
926       ((v2)-&gt;u - (p)-&gt;u) * ((v1)-&gt;v - (p)-&gt;v)
927 #define EXD_TIME_CALC(v1, v2, p)                                               \
928   ((p)-&gt;u *(v1)-&gt;v - (p)-&gt;v *(v1)-&gt;u) /                                        \
929       ((p)-&gt;v *((v2)-&gt;u - (v1)-&gt;u) - (p)-&gt;u *((v2)-&gt;v - (v1)-&gt;v))
930   struct wall_list *wl;
931   struct wall *w;
932   struct vector3 llf, urb;
933   struct exd_vector3 v0muv, v1muv, v2muv;
934   struct exd_vertex pa, pb;
935   struct exd_vertex *ppa, *ppb, *pqa, *pqb, *vertex_head, *vp, *vq, *vr, *vs;
936   double pa_pb;
937   int n_verts, n_edges;
938   int p_flags;
939   double R2;
940   struct vector3 m, u, v;
941   struct exd_vector3 Lmuv;
942   struct exd_vertex sm;
943   double m2_i;
944   double l_n, m_n;
945   double a, b, c, d, r, s, t, A, zeta, last_zeta;
946   int i;
947   int num_matching_rxns = 0;
948   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
949   vertex_head = NULL;
950   n_verts = 0;
951   n_edges = 0;
952   R2 = R * R;
953   m2_i = 1.0 / (mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
954   Lmuv.m = Lmuv.u = Lmuv.v = 0.0;        sm.u = sm.v = sm.r2 = sm.zeta = 0.0; 
955   exd_coordize(mv, &amp;m, &amp;u, &amp;v);
956   Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
957   Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
958   Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
959   if (!distinguishable_vec3(loc, &amp;(target-&gt;pos), EPS_C)) {     sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
960   } else {     sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
961            (target-&gt;pos.z - loc-&gt;z) * u.z;
962     sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
963            (target-&gt;pos.z - loc-&gt;z) * v.z;
964     sm.r2 = sm.u * sm.u + sm.v * sm.v;
965     sm.zeta = exd_zetize(sm.v, sm.u);
966   }
967   for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
968     w = wl-&gt;this_wall;
969     l_n = loc-&gt;x * w-&gt;normal.x + loc-&gt;y * w-&gt;normal.y + loc-&gt;z * w-&gt;normal.z;
970     d = w-&gt;d - l_n;
971     m_n = mv-&gt;x * w-&gt;normal.x + mv-&gt;y * w-&gt;normal.y + mv-&gt;z * w-&gt;normal.z;
972     if (d * d &gt;= R2 * (1 - m2_i * m_n * m_n))
973       continue;
974     urb.x = llf.x = w-&gt;vert[0]-&gt;x;
975     if (w-&gt;vert[1]-&gt;x &lt; llf.x)
976       llf.x = w-&gt;vert[1]-&gt;x;
977     else
978       urb.x = w-&gt;vert[1]-&gt;x;
979     if (w-&gt;vert[2]-&gt;x &lt; llf.x)
980       llf.x = w-&gt;vert[2]-&gt;x;
981     else if (w-&gt;vert[2]-&gt;x &gt; urb.x)
982       urb.x = w-&gt;vert[2]-&gt;x;
983     urb.y = llf.y = w-&gt;vert[0]-&gt;y;
984     if (w-&gt;vert[1]-&gt;y &lt; llf.y)
985       llf.y = w-&gt;vert[1]-&gt;y;
986     else
987       urb.y = w-&gt;vert[1]-&gt;y;
988     if (w-&gt;vert[2]-&gt;y &lt; llf.y)
989       llf.y = w-&gt;vert[2]-&gt;y;
990     else if (w-&gt;vert[2]-&gt;y &gt; urb.y)
991       urb.y = w-&gt;vert[2]-&gt;y;
992     urb.z = llf.z = w-&gt;vert[0]-&gt;z;
993     if (w-&gt;vert[1]-&gt;z &lt; llf.z)
994       llf.z = w-&gt;vert[1]-&gt;z;
995     else
996       urb.z = w-&gt;vert[1]-&gt;z;
997     if (w-&gt;vert[2]-&gt;z &lt; llf.z)
998       llf.z = w-&gt;vert[2]-&gt;z;
999     else if (w-&gt;vert[2]-&gt;z &gt; urb.z)
1000       urb.z = w-&gt;vert[2]-&gt;z;
1001     b = R2 * (1.0 - mv-&gt;x * mv-&gt;x * m2_i);
1002     a = llf.x - loc-&gt;x;
1003     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1004       continue;
1005     a = loc-&gt;x - urb.x;
1006     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1007       continue;
1008     b = R2 * (1.0 - mv-&gt;y * mv-&gt;y * m2_i);
1009     a = llf.y - loc-&gt;y;
1010     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1011       continue;
1012     a = loc-&gt;y - urb.y;
1013     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1014       continue;
1015     b = R2 * (1.0 - mv-&gt;z * mv-&gt;z * m2_i);
1016     a = llf.z - loc-&gt;z;
1017     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1018       continue;
1019     a = loc-&gt;z - urb.z;
1020     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1021       continue;
1022     if ((moving-&gt;properties-&gt;flags &amp; CAN_VOLWALL) != 0) {
1023       num_matching_rxns = trigger_intersect(
1024           world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
1025           world-&gt;all_volume_mols, world-&gt;all_surface_mols,
1026           moving-&gt;properties-&gt;hashval, (struct abstract_molecule *)moving, 0, w,
1027           matching_rxns, 1, 1, 0);
1028       if (num_matching_rxns != 0) {
1029         bool all_transparent = true;
1030         for (i = 0; i &lt; num_matching_rxns; i++) {
1031           if (matching_rxns[i]-&gt;n_pathways != RX_TRANSP) {
1032             all_transparent = false;
1033             break;
1034           }
1035         }
1036         if (all_transparent) {
1037           continue;
1038         }
1039       }
1040     }
1041 #if 0
1042     if (uncoordinated) {
1043       exd_coordize(mv, &amp;m, &amp;u, &amp;v);
1044       Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
1045       Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
1046       Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
1047       if (!distinguishable_vec3(loc, &amp;(target-&gt;pos),
1048                                 EPS_C))       {
1049         sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
1050       } else       {
1051         sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
1052                (target-&gt;pos.z - loc-&gt;z) * u.z;
1053         sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
1054                (target-&gt;pos.z - loc-&gt;z) * v.z;
1055         sm.r2 = sm.u * sm.u + sm.v * sm.v;
1056         sm.zeta = exd_zetize(sm.v, sm.u);
1057       }
1058       uncoordinated = 0;
1059     }
1060 #endif
1061     v0muv.m = w-&gt;vert[0]-&gt;x * m.x + w-&gt;vert[0]-&gt;y * m.y + w-&gt;vert[0]-&gt;z * m.z -
1062               Lmuv.m;
1063     v0muv.u = w-&gt;vert[0]-&gt;x * u.x + w-&gt;vert[0]-&gt;y * u.y + w-&gt;vert[0]-&gt;z * u.z -
1064               Lmuv.u;
1065     v0muv.v = w-&gt;vert[0]-&gt;x * v.x + w-&gt;vert[0]-&gt;y * v.y + w-&gt;vert[0]-&gt;z * v.z -
1066               Lmuv.v;
1067     v1muv.m = w-&gt;vert[1]-&gt;x * m.x + w-&gt;vert[1]-&gt;y * m.y + w-&gt;vert[1]-&gt;z * m.z -
1068               Lmuv.m;
1069     v1muv.u = w-&gt;vert[1]-&gt;x * u.x + w-&gt;vert[1]-&gt;y * u.y + w-&gt;vert[1]-&gt;z * u.z -
1070               Lmuv.u;
1071     v1muv.v = w-&gt;vert[1]-&gt;x * v.x + w-&gt;vert[1]-&gt;y * v.y + w-&gt;vert[1]-&gt;z * v.z -
1072               Lmuv.v;
1073     v2muv.m = w-&gt;vert[2]-&gt;x * m.x + w-&gt;vert[2]-&gt;y * m.y + w-&gt;vert[2]-&gt;z * m.z -
1074               Lmuv.m;
1075     v2muv.u = w-&gt;vert[2]-&gt;x * u.x + w-&gt;vert[2]-&gt;y * u.y + w-&gt;vert[2]-&gt;z * u.z -
1076               Lmuv.u;
1077     v2muv.v = w-&gt;vert[2]-&gt;x * v.x + w-&gt;vert[2]-&gt;y * v.y + w-&gt;vert[2]-&gt;z * v.z -
1078               Lmuv.v;
1079     if ((v0muv.m &lt; 0) == (v1muv.m &lt; 0))     {
1080       if ((v2muv.m &lt; 0) == (v1muv.m &lt; 0))
1081         continue;
1082       t = v0muv.m / (v0muv.m - v2muv.m);
1083       pa.u = v0muv.u + (v2muv.u - v0muv.u) * t;
1084       pa.v = v0muv.v + (v2muv.v - v0muv.v) * t;
1085       t = v1muv.m / (v1muv.m - v2muv.m);
1086       pb.u = v1muv.u + (v2muv.u - v1muv.u) * t;
1087       pb.v = v1muv.v + (v2muv.v - v1muv.v) * t;
1088     } else if ((v0muv.m &lt; 0) == (v2muv.m &lt; 0))     {
1089       t = v0muv.m / (v0muv.m - v1muv.m);
1090       pa.u = v0muv.u + (v1muv.u - v0muv.u) * t;
1091       pa.v = v0muv.v + (v1muv.v - v0muv.v) * t;
1092       t = v2muv.m / (v2muv.m - v1muv.m);
1093       pb.u = v2muv.u + (v1muv.u - v2muv.u) * t;
1094       pb.v = v2muv.v + (v1muv.v - v2muv.v) * t;
1095     } else     {
1096       t = v1muv.m / (v1muv.m - v0muv.m);
1097       pa.u = v1muv.u + (v0muv.u - v1muv.u) * t;
1098       pa.v = v1muv.v + (v0muv.v - v1muv.v) * t;
1099       t = v2muv.m / (v2muv.m - v0muv.m);
1100       pb.u = v2muv.u + (v0muv.u - v2muv.u) * t;
1101       pb.v = v2muv.v + (v0muv.v - v2muv.v) * t;
1102     }
1103     pa.r2 = pa.u * pa.u + pa.v * pa.v;
1104     pb.r2 = pb.u * pb.u + pb.v * pb.v;
1105     if (pa.r2 &lt; EPS_C * R2 ||
1106     {
1107       if (vertex_head != NULL)
1108         mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1109       return TARGET_OCCLUDED;
1110     }
1111     if (!distinguishable(pa.u * pb.v, pb.u * pa.v, EPS_C) &amp;&amp;
1112         pa.u * pb.u + pa.v * pb.v &lt;
1113             0)     {
1114       if (vertex_head != NULL)
1115         mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1116       return TARGET_OCCLUDED;
1117     }
1118     t = 0;
1119     s = 1;
1120     if (pa.r2 &gt; R2 || pb.r2 &gt; R2) {
1121       pa_pb = pa.u * pb.u + pa.v * pb.v;
1122       if (!distinguishable(pa.r2 + pb.r2, 2 * pa_pb,
1123       {
1124         if (sm.r2 &lt; pa.r2 &amp;&amp; sm.r2 &lt; pb.r2 &amp;&amp;
1125             distinguishable(sm.r2, pa.r2, EPS_C) &amp;&amp;
1126             distinguishable(sm.r2, pa.r2, EPS_C))
1127           continue;
1128         if (!distinguishable(sm.u * pa.v, sm.v * pa.u, SQRT_EPS_C) ||
1129             !distinguishable(sm.u * pb.v, sm.v * pb.u, SQRT_EPS_C)) {
1130           if (vertex_head != NULL)
1131             mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1132           return TARGET_OCCLUDED;
1133         }
1134         continue;
1135       }
1136       a = 1.0 / (pa.r2 + pb.r2 - 2 * pa_pb);
1137       b = (pa_pb - pa.r2) * a;
1138       c = (R2 - pa.r2) * a;
1139       d = b * b + c;
1140       if (d &lt;= 0)
1141         continue;
1142       d = sqrt(d);
1143       t = -b - d;
1144       if (t &gt;= 1)
1145         continue;
1146       if (t &lt; 0)
1147         t = 0;
1148       s = -b + d;
1149       if (s &lt;= 0)
1150         continue;
1151       if (s &gt; 1)
1152         s = 1;
1153     }
1154     ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1155                                                "exact disk vertex");
1156     ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1157                                                "exact disk vertex");
1158     if (t &gt; 0) {
1159       ppa-&gt;u = pa.u + t * (pb.u - pa.u);
1160       ppa-&gt;v = pa.v + t * (pb.v - pa.v);
1161       ppa-&gt;r2 = ppa-&gt;u * ppa-&gt;u + ppa-&gt;v * ppa-&gt;v;
1162       ppa-&gt;zeta = exd_zetize(ppa-&gt;v, ppa-&gt;u);
1163     } else {
1164       ppa-&gt;u = pa.u;
1165       ppa-&gt;v = pa.v;
1166       ppa-&gt;r2 = pa.r2;
1167       ppa-&gt;zeta = exd_zetize(pa.v, pa.u);
1168     }
1169     if (s &lt; 1) {
1170       ppb-&gt;u = pa.u + s * (pb.u - pa.u);
1171       ppb-&gt;v = pa.v + s * (pb.v - pa.v);
1172       ppb-&gt;r2 = ppb-&gt;u * ppb-&gt;u + ppb-&gt;v * ppb-&gt;v;
1173       ppb-&gt;zeta = exd_zetize(ppb-&gt;v, ppb-&gt;u);
1174     } else {
1175       ppb-&gt;u = pb.u;
1176       ppb-&gt;v = pb.v;
1177       ppb-&gt;r2 = pb.r2;
1178       ppb-&gt;zeta = exd_zetize(pb.v, pb.u);
1179     }
1180     a = (ppb-&gt;zeta - ppa-&gt;zeta);
1181     if (a &lt; 0)
1182       a += 4.0;
1183     if (a &gt;= 2.0) {
1184       vp = ppb;
1185       ppb = ppa;
1186       ppa = vp;
1187       a = 4.0 - a;
1188     }
1189     b = (sm.zeta - ppa-&gt;zeta);
1190     if (b &lt; 0)
1191       b += 4.0;
1192     if (b &lt; a) {
1193       c = (ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v) - (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u);
1194       if (c &lt; 0 || !distinguishable((ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v),
1195                                     (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u),
1196                                     EPS_C))       {
1197         ppa-&gt;next = ppb;
1198         ppb-&gt;next = vertex_head;
1199         mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
1200         return TARGET_OCCLUDED;
1201       }
1202     }
1203     ppa-&gt;role = EXD_HEAD;
1204     ppb-&gt;role = EXD_TAIL;
1205     ppa-&gt;e = ppb;
1206     ppb-&gt;e = NULL;
1207     ppb-&gt;next = vertex_head;
1208     ppa-&gt;next = ppb;
1209     vertex_head = ppa;
1210     n_verts += 2;
1211     n_edges++;
1212   }
1213   if (!use_expanded_list)   {
1214     p_flags = 0;
1215     d = loc-&gt;x - x_fineparts[sv-&gt;llf.x];
1216     if (d &lt; R) {
1217       c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i;
1218       if (d * d &lt; c)
1219         p_flags |= X_NEG_BIT;
1220       d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1221       if (d * d &lt; c)
1222         p_flags |= X_POS_BIT;
1223     } else {
1224       d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1225       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i)
1226         p_flags |= X_POS_BIT;
1227     }
1228     d = loc-&gt;y - y_fineparts[sv-&gt;llf.y];
1229     if (d &lt; R) {
1230       c = R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i;
1231       if (d * d &lt; c)
1232         p_flags |= Y_NEG_BIT;
1233       d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1234       if (d * d &lt; c)
1235         p_flags |= Y_POS_BIT;
1236     } else {
1237       d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1238       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i)
1239         p_flags |= Y_POS_BIT;
1240     }
1241     d = loc-&gt;z - z_fineparts[sv-&gt;llf.z];
1242     if (d &lt; R) {
1243       c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i;
1244       if (d * d &lt; c)
1245         p_flags |= Z_NEG_BIT;
1246       d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1247       if (d * d &lt; c)
1248         p_flags |= Z_POS_BIT;
1249     } else {
1250       d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1251       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i)
1252         p_flags |= Z_POS_BIT;
1253     }
1254     if (p_flags) {
1255       for (i = 1; i &lt;= p_flags; i *= 2) {
1256         if ((i &amp; p_flags) != 0) {
1257           switch (i) {
1258           case X_NEG_BIT:
1259             d = x_fineparts[sv-&gt;llf.x] - loc-&gt;x;
1260             a = u.x;
1261             b = v.x;
1262             break;
1263           case X_POS_BIT:
1264             d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1265             a = u.x;
1266             b = v.x;
1267             break;
1268           case Y_NEG_BIT:
1269             d = y_fineparts[sv-&gt;llf.y] - loc-&gt;y;
1270             a = u.y;
1271             b = v.y;
1272             break;
1273           case Y_POS_BIT:
1274             d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1275             a = u.y;
1276             b = v.y;
1277             break;
1278           case Z_NEG_BIT:
1279             d = z_fineparts[sv-&gt;llf.z] - loc-&gt;z;
1280             a = u.z;
1281             b = v.z;
1282             break;
1283           case Z_POS_BIT:
1284             d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1285             a = u.z;
1286             b = v.z;
1287             break;
1288           default:
1289             continue;
1290           }
1291           if (!distinguishable(a, 0, EPS_C)) {
1292             s = d / b;
1293             if (s * s &gt; R2) {
1294               mcell_internal_error(
1295                   "Unexpected results in exact disk: s=%.2f s^2=%.2f R2=%.2f\n",
1296                   s, s * s, R2);
1297             }
1298             t = sqrt(R2 - s * s);
1299             pa.u = t;
1300             pa.v = s;
1301             pb.u = -t;
1302             pb.v = s;
1303           } else if (!distinguishable(b, 0, EPS_C)) {
1304             t = d / a;
1305             if (t * t &gt; R2) {
1306               mcell_internal_error(
1307                   "Unexpected results in exact disk: t=%.2f t^2=%.2f R2=%.2f\n",
1308                   t, t * t, R2);
1309             }
1310             s = sqrt(R2 - t * t);
1311             pa.u = t;
1312             pa.v = s;
1313             pb.u = t;
1314             pb.v = -s;
1315           } else {
1316             c = a * a + b * b;
1317             s = d * b;
1318             if (d * d &gt; R2 * c) {
1319               mcell_internal_error("Unexpected results in exact disk: d=%.2f "
1320                                    "d^2=%.2f R2=%.2f c=%.2f R2*c=%.2f\n",
1321                                    d, d * d, R2, c, R2 * c);
1322             }
1323             t = sqrt(R2 * c - d * d);
1324             c = 1.0 / c;
1325             r = 1.0 / a;
1326             pa.v = c * (s + t * a);
1327             pa.u = (d - b * pa.v) * r;
1328             pb.v = c * (s - t * a);
1329             pb.u = (d - b * pb.v) * r;
1330           }
1331           ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1332                                                      "exact disk vertex");
1333           ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1334                                                      "exact disk vertex");
1335           a = exd_zetize(pa.v, pa.u);
1336           b = exd_zetize(pb.v, pb.u);
1337           c = b - a;
1338           if (c &lt; 0)
1339             c += 4;
1340           if (c &lt; 2) {
1341             ppa-&gt;u = pa.u;
1342             ppa-&gt;v = pa.v;
1343             ppa-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
1344             ppa-&gt;zeta = a;
1345             ppb-&gt;u = pb.u;
1346             ppb-&gt;v = pb.v;
1347             ppb-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
1348             ppb-&gt;zeta = b;
1349           } else {
1350             ppb-&gt;u = pa.u;
1351             ppb-&gt;v = pa.v;
1352             ppb-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
1353             ppb-&gt;zeta = a;
1354             ppa-&gt;u = pb.u;
1355             ppa-&gt;v = pb.v;
1356             ppa-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
1357             ppa-&gt;zeta = b;
1358           }
1359           ppa-&gt;role = EXD_HEAD;
1360           ppb-&gt;role = EXD_TAIL;
1361           ppa-&gt;e = ppb;
1362           ppb-&gt;e = NULL;
1363           ppb-&gt;next = vertex_head;
1364           ppa-&gt;next = ppb;
1365           vertex_head = ppa;
1366           n_verts += 2;
1367           n_edges++;
1368         }
1369       }
1370     }
1371   }
1372   if (n_edges == 0) {
1373     return 1.0;
1374   }
1375   else if (n_edges == 1) {
1376     ppa = vertex_head;
1377     ppb = ppa-&gt;e;
1378     a = ppa-&gt;u * ppb-&gt;u + ppa-&gt;v * ppb-&gt;v;
1379     b = ppa-&gt;u * ppb-&gt;v - ppa-&gt;v * ppb-&gt;u;
1380     if (a &lt;= 0)     {
1381       s = atan(-a / b) + 0.5 * MY_PI;
1382     } else {
1383       s = atan(b / a);
1384     }
1385     A = (0.5 * b + R2 * (MY_PI - 0.5 * s)) / (MY_PI * R2);
1386     mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1387     return A;
1388   }
1389   vp = vertex_head-&gt;next;
1390   ppa = ppb = vertex_head;
1391   ppa-&gt;next = NULL;
1392   ppa-&gt;span = NULL;
1393   while (vp != NULL) {
1394     vp-&gt;span = NULL;
1395     vq = vp-&gt;next;
1396     if (vp-&gt;zeta &lt; ppa-&gt;zeta) {
1397       vp-&gt;next = ppa;
1398       ppa = vp;
1399     } else {
1400       for (pqa = ppa; pqa-&gt;next != NULL; pqa = pqa-&gt;next) {
1401         if (vp-&gt;zeta &lt; pqa-&gt;next-&gt;zeta)
1402           break;
1403       }
1404       vp-&gt;next = pqa-&gt;next;
1405       pqa-&gt;next = vp;
1406       if (vp-&gt;next == NULL)
1407         ppb = vp;
1408     }
1409     vp = vq;
1410   }
1411   vertex_head = ppa;
1412   ppb-&gt;next = ppa;
1413   ppb = NULL;
1414   for (ppa = vertex_head; ppa != vertex_head || ppb == NULL; ppa = ppa-&gt;next) {
1415     if (ppa-&gt;role != EXD_HEAD)
1416       continue;
1417     ppb = ppa-&gt;e;
1418     for (pqa = ppa-&gt;next; pqa != ppb; pqa = pqa-&gt;next) {
1419       if (pqa-&gt;role != EXD_HEAD)
1420         continue;
1421       pqb = pqa-&gt;e;
1422       pa.u = ppb-&gt;u - ppa-&gt;u;
1423       pa.v = ppb-&gt;v - ppa-&gt;v;
1424       pb.u = pqb-&gt;u - pqa-&gt;u;
1425       pb.v = pqb-&gt;v - pqa-&gt;v;
1426       r = pb.u * pa.v - pa.u * pb.v;
1427       if (r * r &lt;
1428           EPS_C * (pa.u * pa.u + pa.v * pa.v) * (pb.u * pb.u + pb.v * pb.v)) {
1429         pqa-&gt;e = NULL;
1430         pqa-&gt;role = EXD_OTHER;
1431 <a name="3"></a>
1432         a = pqb-&gt;zeta - ppb-&gt;zeta;
1433         if (a &lt; 0)
1434 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          a += 4.0;
1435         if (a &gt; 2)         {
1436           pqb-&gt;role = EXD_OTHER;
1437         } else         {
1438           ppa-&gt;e = pqb;
1439           ppb-&gt;role = EXD_OTHER;
1440           ppb = pqb;
1441           pqa = ppa;
1442         }</b></font>
1443         continue;
1444       }
1445       s = (ppa-&gt;u - pqa-&gt;u) * pa.v - (ppa-&gt;v - pqa-&gt;v) * pa.u;
1446       if (s * r &lt;= EPS_C * R2 * R2)
1447         continue;
1448       t = s / r;
1449       if (t &gt;= 1 - EPS_C)
1450         continue;
1451       if (pa.u * pa.u &gt; pa.v * pa.v) {
1452         s = (pqa-&gt;u - ppa-&gt;u + t * pb.u) * pa.u;
1453         if (s &lt;= EPS_C * R2 || s &gt;= pa.u * pa.u * (1.0 - EPS_C))
1454           continue;
1455       } else {
1456         s = (pqa-&gt;v - ppa-&gt;v + t * pb.v) * pa.v;
1457         if (s &lt;= EPS_C * R2 || s &gt;= pa.v * pa.v * (1.0 - EPS_C))
1458           continue;
1459       }
1460       vq = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1461                                                 "exact disk vertex");
1462       vq-&gt;u = pqa-&gt;u + t * pb.u;
1463       vq-&gt;v = pqa-&gt;v + t * pb.v;
1464       vq-&gt;r2 = vq-&gt;u * vq-&gt;u + vq-&gt;v * vq-&gt;v;
1465       vq-&gt;zeta = exd_zetize(vq-&gt;v, vq-&gt;u);
1466       vq-&gt;e = ppb;
1467       vq-&gt;span = NULL;
1468       vq-&gt;role = EXD_CROSS;
1469       for (vp = ppa; vp != ppb; vp = vp-&gt;next) {
1470         a = vq-&gt;zeta - vp-&gt;next-&gt;zeta;
1471         if (a &gt; 2.0)
1472           a -= 4.0;
1473         else if (a &lt; -2.0)
1474           a += 4.0;
1475         if (a &lt; 0)
1476           break;
1477       }
1478       vq-&gt;next = vp-&gt;next;
1479       vp-&gt;next = vq;
1480       if (vq-&gt;zeta &lt; vertex_head-&gt;zeta)
1481         vertex_head = vq;
1482     }
1483   }
1484   for (vp = vertex_head, vq = NULL; vq != vertex_head; vp = vq) {
1485     for (vq = vp-&gt;next; vq != vertex_head; vq = vq-&gt;next) {
1486       if (vq-&gt;zeta - vp-&gt;zeta &lt; EPS_C) {
1487         vq-&gt;zeta = vp-&gt;zeta;
1488         if (-EPS_C &lt; vq-&gt;r2 - vp-&gt;r2 &amp;&amp; EPS_C &gt; vq-&gt;r2 - vp-&gt;r2) {
1489           vq-&gt;r2 = vp-&gt;r2;
1490         }
1491       } else
1492         break;
1493     }
1494   }
1495   vq = NULL;
1496   for (vp = vertex_head; vp != vertex_head || vq == NULL; vp = vp-&gt;next) {
1497     if (vp-&gt;role != EXD_HEAD)
1498       continue;
1499     for (vq = vp-&gt;next; vq != vp-&gt;e; vq = vq-&gt;next) {
1500       if (!distinguishable(vq-&gt;zeta, vp-&gt;zeta, EPS_C))
1501         continue;
1502       if (!distinguishable(vq-&gt;zeta, vp-&gt;e-&gt;zeta, EPS_C))
1503         break;
1504       if (vq-&gt;role == EXD_OTHER)
1505         continue;
1506       vr = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1507                                                 "exact disk vertex");
1508       vr-&gt;next = vq-&gt;span;
1509       vq-&gt;span = vr;
1510       vr-&gt;e = vp;
1511       vr-&gt;zeta = vq-&gt;zeta;
1512       vr-&gt;role = EXD_SPAN;
1513     }
1514   }
1515   A = 0.0;
1516   zeta = 0.0;
1517   last_zeta = -1;
1518   vs = NULL;
1519   for (vp = vertex_head; zeta &lt; 4.0 - EPS_C; vp = vp-&gt;next) {
1520     if (vp-&gt;role == EXD_OTHER)
1521       continue;
1522     if (!distinguishable(vp-&gt;zeta, last_zeta, EPS_C))
1523       continue;
1524     last_zeta = vp-&gt;zeta;
1525     if (vs == &amp;pa)
1526       vr = &amp;pb;
1527     else
1528       vr = &amp;pa;
1529     vr-&gt;u = vp-&gt;u;
1530     vr-&gt;v = vp-&gt;v;
1531     vr-&gt;zeta = vp-&gt;zeta;
1532     if (vp-&gt;role == EXD_TAIL) {
1533       vr-&gt;r2 = R2 * (1.0 + EPS_C);
1534       vr-&gt;e = NULL;
1535     } else {
1536       vr-&gt;r2 = vp-&gt;r2;
1537       vr-&gt;e = vp-&gt;e;
1538     }
1539     for (vq = vp-&gt;next; (!distinguishable(vq-&gt;zeta, last_zeta, EPS_C));
1540          vq = vq-&gt;next) {
1541       if (vq-&gt;role == EXD_HEAD) {
1542         if (vq-&gt;r2 &lt; vp-&gt;r2 || vr-&gt;e == NULL) {
1543           vr-&gt;u = vq-&gt;u;
1544           vr-&gt;v = vq-&gt;v;
1545           vr-&gt;r2 = vq-&gt;r2;
1546           vr-&gt;e = vq-&gt;e;
1547         } else if (!distinguishable(vq-&gt;r2, vr-&gt;r2, EPS_C)) {
1548           b = EXD_SPAN_CALC(vr, vr-&gt;e, vq-&gt;e);
1549           if (b &gt; 0)
1550             vr-&gt;e = vq-&gt;e;
1551         }
1552       }
1553     }
1554     for (vq = vp-&gt;span; vq != NULL; vq = vq-&gt;next) {
1555       ppa = vq-&gt;e;
1556       ppb = ppa-&gt;e;
1557       b = EXD_SPAN_CALC(ppa, ppb, vr);
1558       c = b * b;
1559       if (c &lt; R2 * R2 * EPS_C)       {
1560         if (vr-&gt;e == NULL) {
1561           vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
1562           vr-&gt;e = ppb;
1563         } else {
1564           b = EXD_SPAN_CALC(vr, vr-&gt;e, ppb);
1565           if (b &gt; 0)
1566             vr-&gt;e = ppb;
1567         }
1568       } else if (b &lt; 0 ||
1569                  vr-&gt;e == NULL)       {
1570         t = EXD_TIME_CALC(ppa, ppb, vp);
1571         vr-&gt;u = ppa-&gt;u + t * (ppb-&gt;u - ppa-&gt;u);
1572         vr-&gt;v = ppa-&gt;v + t * (ppb-&gt;v - ppa-&gt;v);
1573         vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
1574         vr-&gt;e = ppb;
1575       }
1576     }
1577     if (vs == NULL)     {
1578       vs = vr;
1579     } else {
1580       c = vr-&gt;zeta - vs-&gt;zeta;
1581       if (c &lt; 0)
1582         c += 4.0;
1583         zeta += c;
1584         if (vs-&gt;e == NULL ||
1585             (vs-&gt;e-&gt;zeta - vs-&gt;zeta) * (vs-&gt;e-&gt;zeta - vs-&gt;zeta) &lt;
1586                 EPS_C * EPS_C) {
1587           if (c &gt;= 2.0)           {
1588             vs-&gt;u = -vs-&gt;u;
1589             vs-&gt;v = -vs-&gt;v;
1590             A += 0.5 * MY_PI * R2;
1591           }
1592           a = vs-&gt;u * vr-&gt;u + vs-&gt;v * vr-&gt;v;
1593           b = vs-&gt;u * vr-&gt;v - vs-&gt;v * vr-&gt;u;
1594           if (a &lt;= 0)           {
1595             s = atan(-a / b) + 0.5 * MY_PI;
1596           } else {
1597             s = atan(b / a);
1598           }
1599           A += 0.5 * s * R2;
1600         } else {
1601           if (!distinguishable(vs-&gt;e-&gt;zeta, vr-&gt;zeta, EPS_C)) {
1602             A += 0.5 * (vs-&gt;u * vs-&gt;e-&gt;v - vs-&gt;v * vs-&gt;e-&gt;u);
1603           } else {
1604             t = EXD_TIME_CALC(vs, vs-&gt;e, vr);
1605             b = vs-&gt;u + (vs-&gt;e-&gt;u - vs-&gt;u) * t;
1606             c = vs-&gt;v + (vs-&gt;e-&gt;v - vs-&gt;v) * t;
1607             A += 0.5 * (vs-&gt;u * c - vs-&gt;v * b);
1608           }
1609         }
1610         vs = vr;
1611       } else {
1612         if (vr-&gt;e != NULL)
1613           vs = vr;
1614       }
1615     }
1616   }
1617   ppa = vertex_head-&gt;next;
1618   vertex_head-&gt;next = NULL;
1619   for (ppb = ppa; ppb != NULL; ppb = ppb-&gt;next) {
1620     if (ppb-&gt;span != NULL) {
1621       struct exd_vertex *next = ppb-&gt;next;
1622       ppb-&gt;next = ppb-&gt;span;
1623       ppb-&gt;span = NULL;
1624       while (ppb-&gt;next != NULL)
1625         ppb = ppb-&gt;next;
1626       ppb-&gt;next = next;
1627     }
1628   }
1629   mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
1630   return A / (MY_PI * R2);
1631 #undef EXD_TIME_CALC
1632 #undef EXD_SPAN_CALC
1633 }
1634 double safe_diffusion_step(struct volume_molecule *vm, struct collision *shead,
1635                            u_int radial_subdivisions, double *r_step,
1636                            double *x_fineparts, double *y_fineparts,
1637                            double *z_fineparts) {
1638   double d2;
1639   double d2_nearmax;
1640   double d2min = GIGANTIC;
1641   struct subvolume *sv = vm-&gt;subvol;
1642   struct wall *w;
1643   struct wall_list *wl;
1644   struct collision *smash;
1645   double steps;
1646   struct volume_molecule *mp;
1647   d2_nearmax = vm-&gt;get_space_step(vm) *
1648                r_step[(int)(radial_subdivisions * MULTISTEP_PERCENTILE)];
1649   d2_nearmax *= d2_nearmax;
1650   if ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
1651     for (smash = shead; smash != NULL; smash = smash-&gt;next) {
1652       mp = (struct volume_molecule *)smash-&gt;target;
1653       d2 = (vm-&gt;pos.x - mp-&gt;pos.x) * (vm-&gt;pos.x - mp-&gt;pos.x) +
1654            (vm-&gt;pos.y - mp-&gt;pos.y) * (vm-&gt;pos.y - mp-&gt;pos.y) +
1655            (vm-&gt;pos.z - mp-&gt;pos.z) * (vm-&gt;pos.z - mp-&gt;pos.z);
1656       if (d2 &lt; d2min)
1657         d2min = d2;
1658     }
1659   }
1660   for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
1661     w = wl-&gt;this_wall;
1662     d2 = (w-&gt;normal.x * vm-&gt;pos.x + w-&gt;normal.y * vm-&gt;pos.y +
1663           w-&gt;normal.z * vm-&gt;pos.z) -
1664          w-&gt;d;
1665     d2 *= d2;
1666     if (d2 &lt; d2min)
1667       d2min = d2;
1668   }
1669   d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;llf.x]);
1670   d2 *= d2;
1671   if (d2 &lt; d2min)
1672     d2min = d2;
1673   d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;urb.x]);
1674   d2 *= d2;
1675   if (d2 &lt; d2min)
1676     d2min = d2;
1677   d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;llf.y]);
1678   d2 *= d2;
1679   if (d2 &lt; d2min)
1680     d2min = d2;
1681   d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;urb.y]);
1682   d2 *= d2;
1683   if (d2 &lt; d2min)
1684     d2min = d2;
1685   d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;llf.z]);
1686   d2 *= d2;
1687   if (d2 &lt; d2min)
1688     d2min = d2;
1689   d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;urb.z]);
1690   d2 *= d2;
1691   if (d2 &lt; d2min)
1692     d2min = d2;
1693 #ifdef MCELL3_4_SAFE_DIFF_STEP_RETURNS_CONSTANT
1694   return 1;
1695 #else
1696   if (d2min &lt; d2_nearmax)
1697     steps = 1.0;
1698   else {
1699     double steps_sq = d2min / d2_nearmax;
1700     if (steps_sq &lt; MULTISTEP_WORTHWHILE * MULTISTEP_WORTHWHILE)
1701       steps = 1.0;
1702     else
1703       steps = sqrt(steps_sq);
1704   }
1705   return steps;
1706 #endif
1707 }
1708 static struct collision *expand_collision_list_for_neighbor(struct volume *world,
1709     struct subvolume *sv, struct volume_molecule *vm, struct subvolume *new_sv,
1710     struct vector3 *path_llf, struct vector3 *path_urb,
1711     struct collision *shead1, double trim_x, double trim_y, double trim_z,
1712     double *x_fineparts, double *y_fineparts, double *z_fineparts,
1713     int rx_hashsize, struct rxn **reaction_hash) {
1714   int num_matching_rxns = 0;
1715   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
1716   struct vector3 new_sv_llf, new_sv_urb;
1717   new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
1718   new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
1719   new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
1720   new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
1721   new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
1722   new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
1723   if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
1724     return shead1;
1725   double x_min, x_max;
1726   double y_min, y_max;
1727   double z_min, z_max;
1728   if (trim_x &lt; 0.0) {
1729     x_min = new_sv_urb.x + trim_x;
1730     x_max = new_sv_urb.x + EPS_C;
1731   } else if (trim_x &gt; 0.0) {
1732     x_min = new_sv_llf.x - EPS_C;
1733     x_max = new_sv_llf.x + trim_x;
1734   } else {
1735     x_min = new_sv_llf.x - EPS_C;
1736     x_max = new_sv_urb.x + EPS_C;
1737   }
1738   if (trim_y &lt; 0.0) {
1739     y_min = new_sv_urb.y + trim_y;
1740     y_max = new_sv_urb.y + EPS_C;
1741   } else if (trim_y &gt; 0.0) {
1742     y_min = new_sv_llf.y - EPS_C;
1743     y_max = new_sv_llf.y + trim_y;
1744   } else {
1745     y_min = new_sv_llf.y - EPS_C;
1746     y_max = new_sv_urb.y + EPS_C;
1747   }
1748   if (trim_z &lt; 0.0) {
1749     z_min = new_sv_urb.z + trim_z;
1750     z_max = new_sv_urb.z + EPS_C;
1751   } else if (trim_z &gt; 0.0) {
1752     z_min = new_sv_llf.z - EPS_C;
1753     z_max = new_sv_llf.z + trim_z;
1754   } else {
1755     z_min = new_sv_llf.z - EPS_C;
1756     z_max = new_sv_urb.z + EPS_C;
1757   }
1758   struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
1759   for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
1760     psl_next = psl-&gt;next;
1761     if (psl-&gt;properties == NULL) {
1762       psl_head = &amp;psl-&gt;next;
1763       continue;
1764     }
1765     if (psl-&gt;head == NULL) {
1766       *psl_head = psl-&gt;next;
1767       ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
1768       mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
1769       continue;
1770     } else
1771       psl_head = &amp;psl-&gt;next;
1772     if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
1773       if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, (struct abstract_molecule *)psl-&gt;head))
1774         continue;
1775     }
1776     else{
1777     if (!trigger_bimolecular_preliminary(
1778              reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
1779              psl-&gt;properties-&gt;hashval, vm-&gt;properties, psl-&gt;properties))
1780       continue;
1781     }
1782     for (struct volume_molecule *mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
1783       if (mp-&gt;properties == NULL)
1784         continue;
1785       if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
1786         continue;
1787       if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
1788         continue;
1789       if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
1790         continue;
1791       if (!periodic_boxes_are_identical(vm-&gt;periodic_box, mp-&gt;periodic_box)) {
1792         continue;
1793       }
1794         if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
1795           num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)vm,
1796             (struct abstract_molecule *)mp, 0, 0, matching_rxns);
1797         } 
1798         else{     
1799           num_matching_rxns = trigger_bimolecular(
1800               reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
1801               mp-&gt;properties-&gt;hashval, (struct abstract_molecule *)vm,
1802               (struct abstract_molecule *)mp, 0, 0, matching_rxns);
1803         }
1804       if (num_matching_rxns &lt;= 0)
1805         continue;
1806       for (int i = 0; i &lt; num_matching_rxns; i++) {
1807         struct collision *smash = (struct collision *)CHECKED_MEM_GET(
1808             sv-&gt;local_storage-&gt;coll, "collision data");
1809         smash-&gt;target = (void *)mp;
1810         smash-&gt;intermediate = matching_rxns[i];
1811         smash-&gt;next = shead1;
1812         smash-&gt;what = 0;
1813         smash-&gt;what |= COLLIDE_VOL;
1814         shead1 = smash;
1815       }
1816     }
1817   }
1818   return shead1;
1819 }
1820 static struct collision *
1821 expand_collision_list(struct volume *world, struct volume_molecule *vm, struct vector3 *mv,
1822                       struct subvolume *sv, double rx_radius_3d,
1823                       int ny_parts, int nz_parts, double *x_fineparts,
1824                       double *y_fineparts, double *z_fineparts, int rx_hashsize,
1825                       struct rxn **reaction_hash) {
1826   struct collision *shead1 = NULL;
1827   struct vector3 path_llf, path_urb;
1828   double R = (rx_radius_3d);
1829   path_bounding_box(&amp;vm-&gt;pos, mv, &amp;path_llf, &amp;path_urb, rx_radius_3d);
1830   int x_neg = 0, x_pos = 0, y_neg = 0, y_pos = 0, z_neg = 0, z_pos = 0;
1831   if (!(sv-&gt;world_edge &amp; X_POS_BIT) &amp;&amp; path_urb.x + R &gt; x_fineparts[sv-&gt;urb.x])
1832     x_pos = 1;
1833   if (!(sv-&gt;world_edge &amp; X_NEG_BIT) &amp;&amp; path_llf.x - R &lt; x_fineparts[sv-&gt;llf.x])
1834     x_neg = 1;
1835   if (!(sv-&gt;world_edge &amp; Y_POS_BIT) &amp;&amp; path_urb.y + R &gt; y_fineparts[sv-&gt;urb.y])
1836     y_pos = 1;
1837   if (!(sv-&gt;world_edge &amp; Y_NEG_BIT) &amp;&amp; path_llf.y - R &lt; y_fineparts[sv-&gt;llf.y])
1838     y_neg = 1;
1839   if (!(sv-&gt;world_edge &amp; Z_POS_BIT) &amp;&amp; path_urb.z + R &gt; z_fineparts[sv-&gt;urb.z])
1840     z_pos = 1;
1841   if (!(sv-&gt;world_edge &amp; Z_NEG_BIT) &amp;&amp; path_llf.z - R &lt; z_fineparts[sv-&gt;llf.z])
1842     z_neg = 1;
1843   if (x_pos) {
1844     struct subvolume *new_sv = sv + (nz_parts - 1) * (ny_parts - 1);
1845     shead1 = expand_collision_list_for_neighbor(world,
1846         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, 0.0, x_fineparts,
1847         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1848     if (y_pos) {
1849       struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
1850       shead1 = expand_collision_list_for_neighbor(world,
1851           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, R, 0.0, x_fineparts,
1852           y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1853       if (z_pos)
1854         shead1 = expand_collision_list_for_neighbor(world,
1855             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, R, R,
1856             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1857       if (z_neg)
1858         shead1 = expand_collision_list_for_neighbor(world,
1859             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, R, -R,
1860             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1861     }
1862     if (y_neg) {
1863       struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
1864       shead1 = expand_collision_list_for_neighbor(world,
1865           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, -R, 0.0,
1866           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1867       if (z_pos)
1868         shead1 = expand_collision_list_for_neighbor(world,
1869             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, R,
1870             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1871       if (z_neg)
1872         shead1 = expand_collision_list_for_neighbor(world,
1873             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, -R,
1874             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1875     }
1876     if (z_pos)
1877       shead1 = expand_collision_list_for_neighbor(world,
1878           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, R,
1879           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1880     if (z_neg)
1881       shead1 = expand_collision_list_for_neighbor(world,
1882           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, -R,
1883           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1884   }
1885   if (x_neg) {
1886     struct subvolume *new_sv = sv - (nz_parts - 1) * (ny_parts - 1);
1887     shead1 = expand_collision_list_for_neighbor(world,
1888         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, 0.0, x_fineparts,
1889         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1890     if (y_pos) {
1891       struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
1892       shead1 = expand_collision_list_for_neighbor(world,
1893           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, R, 0.0,
1894           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1895       if (z_pos)
1896         shead1 = expand_collision_list_for_neighbor(world,
1897             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, R,
1898             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1899       if (z_neg)
1900         shead1 = expand_collision_list_for_neighbor(world,
1901             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, -R,
1902             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1903     }
1904     if (y_neg) {
1905       struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
1906       shead1 = expand_collision_list_for_neighbor(world,
1907           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, -R, 0.0,
1908           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1909       if (z_pos)
1910         shead1 = expand_collision_list_for_neighbor(world,
1911             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, R,
1912             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1913       if (z_neg)
1914         shead1 = expand_collision_list_for_neighbor(world,
1915             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, -R,
1916             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1917     }
1918     if (z_pos)
1919       shead1 = expand_collision_list_for_neighbor(world,
1920           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, R,
1921           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1922     if (z_neg)
1923       shead1 = expand_collision_list_for_neighbor(world,
1924           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, -R,
1925           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1926   }
1927   if (y_pos) {
1928     struct subvolume *new_sv = sv + (nz_parts - 1);
1929     shead1 = expand_collision_list_for_neighbor(world,
1930         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, 0.0, x_fineparts,
1931         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1932     if (z_pos)
1933       shead1 = expand_collision_list_for_neighbor(world,
1934           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, R,
1935           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1936     if (z_neg)
1937       shead1 = expand_collision_list_for_neighbor(world,
1938           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, -R,
1939           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1940   }
1941   if (y_neg) {
1942     struct subvolume *new_sv = sv - (nz_parts - 1);
1943     shead1 = expand_collision_list_for_neighbor(world,
1944         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, 0.0, x_fineparts,
1945         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1946     if (z_pos)
1947       shead1 = expand_collision_list_for_neighbor(world,
1948           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, R,
1949           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1950     if (z_neg)
1951       shead1 = expand_collision_list_for_neighbor(world,
1952           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, -R,
1953           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1954   }
1955   if (z_pos)
1956     shead1 = expand_collision_list_for_neighbor(world,
1957         sv, vm, sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, R, x_fineparts,
1958         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1959   if (z_neg)
1960     shead1 = expand_collision_list_for_neighbor(world,
1961         sv, vm, sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, -R, x_fineparts,
1962         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1963   return shead1;
1964 }
1965 struct sp_collision *expand_collision_partner_list_for_neighbor(
1966     struct subvolume *sv, struct volume_molecule *vm, struct vector3 *mv,
1967     struct subvolume *new_sv, struct vector3 *path_llf,
1968     struct vector3 *path_urb, struct sp_collision *shead1, double trim_x,
1969     double trim_y, double trim_z, double *x_fineparts, double *y_fineparts,
1970     double *z_fineparts, int rx_hashsize, struct rxn **reaction_hash) {
1971   struct species *spec = vm-&gt;properties;
1972   struct sp_collision *smash;
1973   struct vector3 new_sv_llf, new_sv_urb;
1974   new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
1975   new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
1976   new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
1977   new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
1978   new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
1979   new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
1980   if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
1981     return shead1;
1982   int moving_tri_molecular_flag = 0, moving_bi_molecular_flag = 0,
1983       moving_mol_mol_grid_flag = 0;
1984   int col_tri_molecular_flag = 0, col_bi_molecular_flag = 0,
1985       col_mol_mol_grid_flag = 0;
1986   moving_tri_molecular_flag =
1987       ((spec-&gt;flags &amp; (CAN_VOLVOLVOL | CANT_INITIATE)) == CAN_VOLVOLVOL);
1988   moving_bi_molecular_flag =
1989       ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL);
1990   moving_mol_mol_grid_flag =
1991       ((spec-&gt;flags &amp; (CAN_VOLVOLSURF | CANT_INITIATE)) == CAN_VOLVOLSURF);
1992   double x_min, x_max;
1993   double y_min, y_max;
1994   double z_min, z_max;
1995   if (trim_x &lt; 0.0) {
1996     x_min = new_sv_urb.x + trim_x;
1997     x_max = new_sv_urb.x + EPS_C;
1998   } else if (trim_x &gt; 0.0) {
1999     x_min = new_sv_llf.x - EPS_C;
2000     x_max = new_sv_llf.x + trim_x;
2001   } else {
2002     x_min = new_sv_llf.x - EPS_C;
2003     x_max = new_sv_urb.x + EPS_C;
2004   }
2005   if (trim_y &lt; 0.0) {
2006     y_min = new_sv_urb.y + trim_y;
2007     y_max = new_sv_urb.y + EPS_C;
2008   } else if (trim_y &gt; 0.0) {
2009     y_min = new_sv_llf.y - EPS_C;
2010     y_max = new_sv_llf.y + trim_y;
2011   } else {
2012     y_min = new_sv_llf.y - EPS_C;
2013     y_max = new_sv_urb.y + EPS_C;
2014   }
2015   if (trim_z &lt; 0.0) {
2016     z_min = new_sv_urb.z + trim_z;
2017     z_max = new_sv_urb.z + EPS_C;
2018   } else if (trim_z &gt; 0.0) {
2019     z_min = new_sv_llf.z - EPS_C;
2020     z_max = new_sv_llf.z + trim_z;
2021   } else {
2022     z_min = new_sv_llf.z - EPS_C;
2023     z_max = new_sv_urb.z + EPS_C;
2024   }
2025   struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
2026   for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
2027     psl_next = psl-&gt;next;
2028     if (psl-&gt;properties == NULL) {
2029       psl_head = &amp;psl-&gt;next;
2030       continue;
2031     }
2032     if (psl-&gt;head == NULL) {
2033       *psl_head = psl-&gt;next;
2034       ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
2035       mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
2036       continue;
2037     } else
2038       psl_head = &amp;psl-&gt;next;
2039     int preliminary_check = 0;
2040     if(spec-&gt;flags &amp; EXTERNAL_SPECIES){
2041         preliminary_check =trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, 
2042                                                                  (struct abstract_molecule *)psl-&gt;head);
2043     }
2044     else{
2045         preliminary_check = trigger_bimolecular_preliminary(reaction_hash, rx_hashsize,
2046                                         spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
2047                                         spec, psl-&gt;properties);
2048     }
2049     col_tri_molecular_flag =
2050         moving_tri_molecular_flag &amp;&amp;
2051         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLVOL) == CAN_VOLVOLVOL);
2052     col_bi_molecular_flag =
2053         moving_bi_molecular_flag &amp;&amp;
2054         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOL) == CAN_VOLVOL) &amp;&amp; preliminary_check;
2055     col_mol_mol_grid_flag =
2056         moving_mol_mol_grid_flag &amp;&amp;
2057         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLSURF) == CAN_VOLVOLSURF);
2058     if (col_bi_molecular_flag || col_tri_molecular_flag ||
2059         col_mol_mol_grid_flag) {
2060       struct volume_molecule *mp;
2061       for (mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
2062         if (mp-&gt;properties == NULL)
2063           continue;
2064         if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
2065           continue;
2066         if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
2067           continue;
2068         if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
2069           continue;
2070         smash = (struct sp_collision *)CHECKED_MEM_GET(
2071             sv-&gt;local_storage-&gt;sp_coll, "collision data");
2072         smash-&gt;t = 0.0;
2073         smash-&gt;t_start = 0.0;
2074         smash-&gt;pos_start.x = vm-&gt;pos.x;
2075         smash-&gt;pos_start.y = vm-&gt;pos.y;
2076         smash-&gt;pos_start.z = vm-&gt;pos.z;
2077         smash-&gt;sv_start = sv;
2078         smash-&gt;disp.x = mv-&gt;x;
2079         smash-&gt;disp.y = mv-&gt;y;
2080         smash-&gt;disp.z = mv-&gt;z;
2081         smash-&gt;loc.x = 0.0;
2082         smash-&gt;loc.y = 0.0;
2083         smash-&gt;loc.z = 0.0;
2084         smash-&gt;moving = spec;
2085         smash-&gt;target = (void *)mp;
2086         smash-&gt;what = 0;
2087         if (col_bi_molecular_flag) {
2088           smash-&gt;what |= COLLIDE_VOL;
2089         }
2090         if (col_tri_molecular_flag) {
2091           smash-&gt;what |= COLLIDE_VOL_VOL;
2092         }
2093         if (col_mol_mol_grid_flag) {
2094           smash-&gt;what |= COLLIDE_VOL_SURF;
2095         }
2096         smash-&gt;next = shead1;
2097         shead1 = smash;
2098       }
2099     }
2100   }
2101   return shead1;
2102 }
2103 struct volume_molecule *diffuse_3D(
2104     struct volume *world,
2105     struct volume_molecule *vm,
2106     double max_time) {
2107   world-&gt;diffuse_3d_calls++;
2108   struct species* spec = vm-&gt;properties;
2109   if (spec == NULL) {
2110     mcell_internal_error(
2111         "Attempted to take a diffusion step for a defunct molecule.");
2112   }
2113   int mol_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURF) == CAN_VOLSURF);
2114   int mol_grid_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURFSURF) == CAN_VOLSURFSURF);
2115   if (vm-&gt;get_space_step(vm) &lt;= 0.0) {
2116     vm-&gt;t += max_time;
2117     return vm;
2118   }
2119 #ifdef DEBUG_DIFFUSION
2120   DUMP_CONDITION3(
2121   		dump_volume_molecule(vm, "", true, "Diffusing vm:", world-&gt;current_iterations, vm-&gt;t, true);
2122   );
2123 #endif
2124   int inertness = 0;
2125   set_inertness_and_maxtime(world, vm, &amp;max_time, &amp;inertness);
2126   ASSERT_FOR_MCELL4(inertness == 0);
2127   int calculate_displacement = 1;
2128   int redo_expand_collision_list_flag = 0;
2129   double steps = 1.0;
2130   double t_steps = 1.0;
2131   double rate_factor = 1.0;
2132   double r_rate_factor = 1.0;
2133   struct vector3 displacement;    struct vector3 displacement2; 
2134   bool displacement_printed = false;   bool timing_printed = false; 
2135 pretend_to_call_diffuse_3D: ; 
2136   struct subvolume *sv = vm-&gt;subvol;
2137   if ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL &amp;&amp;
2138       inertness &lt; inert_to_all) {
2139     determine_mol_mol_reactions(world, vm, &amp;shead, &amp;stail, inertness);
2140   }
2141   if (calculate_displacement) {
2142     compute_displacement(world, shead, vm, &amp;displacement, &amp;displacement2,
2143       &amp;rate_factor, &amp;r_rate_factor, &amp;steps, &amp;t_steps, max_time);
2144   }
2145 #ifdef DEBUG_TIMING
2146   DUMP_CONDITION3(
2147       if (!timing_printed) {
2148         MCell::dump_vol_mol_timing(
2149             "- Timing vm", world-&gt;current_iterations, vm-&gt;id,
2150             vm-&gt;t, max_time, vm-&gt;t + vm-&gt;t2,
2151             rate_factor, r_rate_factor, steps, t_steps
2152         );
2153         timing_printed = true;
2154       }
2155   );
2156 #endif
2157 #ifdef DEBUG_DIFFUSION
2158   DUMP_CONDITION3(
2159 		if (!displacement_printed) {
2160 			dump_vector3(displacement, "  displacement:");
2161             std::cout &lt;&lt; "t_steps: " &lt;&lt; t_steps &lt;&lt; "\n";
2162 			displacement_printed = true;
2163 		}
2164   );
2165 #endif
2166   if (world-&gt;use_expanded_list &amp;&amp;
2167       ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) &amp;&amp;
2168       !inertness) {
2169     shead_exp = expand_collision_list(world,
2170       vm, &amp;displacement, sv, world-&gt;rx_radius_3d, world-&gt;ny_parts,
2171       world-&gt;nz_parts, world-&gt;x_fineparts, world-&gt;y_fineparts,
2172       world-&gt;z_fineparts, world-&gt;rx_hashsize, world-&gt;reaction_hash);
2173     if (stail != NULL)
2174       stail-&gt;next = shead_exp;
2175     else {
2176       if (shead != NULL)
2177         mcell_internal_error("Collision lists corrupted.  While expanding the "
2178                              "collision lists, expected shead to be NULL, but "
2179                              "it wasn't.");
2180       shead = shead_exp;
2181     }
2182   }
2183   struct wall* reflectee = NULL;
2184   struct collision *smash;        do {
2185     if (world-&gt;use_expanded_list &amp;&amp; redo_expand_collision_list_flag) {
2186       redo_collision_list(world, &amp;shead, &amp;stail, &amp;shead_exp, vm, &amp;displacement, sv);
2187     }
2188     struct collision* shead2 = ray_trace(world, &amp;(vm-&gt;pos), shead, sv, &amp;displacement, reflectee);
2189     if (shead2 == NULL) {
2190       mcell_internal_error("ray_trace returned NULL.");
2191     }
2192     if (shead2-&gt;next != NULL) {
2193       shead2 =
2194           (struct collision *)ae_list_sort((struct abstract_element *)shead2);
2195     }
2196 #ifdef DEBUG_COLLISIONS
2197     DUMP_CONDITION3(
2198     		dump_collisions(shead2);
2199     );
2200 #endif
2201     struct vector3* loc_certain = NULL;
2202     struct collision *tentative = shead2;
2203     for (smash = shead2; smash != NULL; smash = smash-&gt;next) {
2204       if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
2205         if (((smash-&gt;what &amp; COLLIDE_VOL) != 0) &amp;&amp;
2206             (world-&gt;rxn_flags.vol_vol_reaction_flag)) {
2207           world-&gt;vol_vol_colls++;
2208         }
2209       }
2210       if (smash-&gt;t &gt;= 1.0 || smash-&gt;t &lt; 0.0) {
2211         if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
2212           mcell_internal_error(
2213               "Detected a mol-mol collision outside of the 0.0...1.0 time "
2214               "window.  Iteration %lld, time of collision %.8e, mol1=%s, "
2215               "mol2=%s",
2216               world-&gt;current_iterations, smash-&gt;t, vm-&gt;properties-&gt;sym-&gt;name,
2217               ((struct volume_molecule *)smash-&gt;target)-&gt;properties-&gt;sym-&gt;name);
2218         }
2219         smash = NULL;
2220         break;
2221       }
2222       if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
2223         if (smash-&gt;t &lt; EPS_C) {
2224           continue;
2225         }
2226         if (collide_and_react_with_vol_mol(world, smash, vm, &amp;tentative,
2227           &amp;displacement, loc_certain, t_steps, r_rate_factor) == 1) {
2228           FREE_COLLISION_LISTS();
2229           return NULL;
2230         } else {
2231           continue;
2232         }
2233       } else if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
2234         struct wall* w = (struct wall *)smash-&gt;target;
2235         if (w-&gt;grid != NULL &amp;&amp; (mol_grid_flag || mol_grid_grid_flag) &amp;&amp;
2236           inertness &lt; inert_to_all) {
2237           int destroyed = collide_and_react_with_surf_mol(world, smash, vm,
2238             &amp;tentative, &amp;loc_certain, t_steps, mol_grid_flag, mol_grid_grid_flag,
2239             r_rate_factor);
2240           if (destroyed == 1) {
2241             FREE_COLLISION_LISTS();
2242             return NULL;
2243           } else if (destroyed == 0) {
2244             continue;
2245           }
2246         }
2247         if ((spec-&gt;flags &amp; CAN_VOLWALL) != 0) {
2248           int destroyed = collide_and_react_with_walls(world, smash, vm,
2249             &amp;tentative, &amp;loc_certain, t_steps, inertness, r_rate_factor);
2250           if (destroyed == 1) {
2251             FREE_COLLISION_LISTS();
2252             return NULL;
2253           } else if (destroyed == 0) {
2254             continue;
2255           }
2256         }
2257         if (reflect_or_periodic_bc(world, smash, &amp;displacement, &amp;vm, &amp;reflectee,
2258             &amp;tentative, &amp;t_steps) == 1) {
2259           FREE_COLLISION_LISTS();
2260           calculate_displacement = 0;
2261           if (vm-&gt;properties == NULL) {
2262             mcell_internal_error("A defunct molecule is diffusing.");
2263           }
2264           goto pretend_to_call_diffuse_3D;
2265         }
2266         redo_expand_collision_list_flag = 1; 
2267         break;
2268       } else if ((smash-&gt;what &amp; COLLIDE_SUBVOL) != 0) {
2269         collide_and_react_with_subvol(
2270           world, smash, &amp;displacement, &amp;vm, &amp;tentative, &amp;t_steps);
2271         FREE_COLLISION_LISTS();
2272         calculate_displacement = 0;
2273         if (vm-&gt;properties == NULL) {
2274           mcell_internal_error("A defunct molecule is diffusing.");
2275         }
2276         goto pretend_to_call_diffuse_3D;
2277       }
2278     }
2279     if (shead2 != NULL) {
2280       mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);
2281     }
2282   } while (smash != NULL);
2283   vm-&gt;pos.x += displacement.x;
2284   vm-&gt;pos.y += displacement.y;
2285   vm-&gt;pos.z += displacement.z;
2286   vm-&gt;t += t_steps;
2287   if (inertness == inert_to_all) 
2288   {
2289     inertness = inert_to_mol;
2290     t_steps = vm-&gt;get_time_step(vm);
2291     displacement = displacement2;
2292     calculate_displacement = 0;
2293     goto pretend_to_call_diffuse_3D;
2294   }
2295   vm-&gt;index = -1;
2296   vm-&gt;previous_wall = NULL;
2297   if (shead != NULL)
2298     mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
2299 #ifdef DEBUG_DIFFUSION
2300   if (vm-&gt;properties != NULL) {
2301     DUMP_CONDITION3(
2302     );
2303   }
2304 #endif
2305   return vm;
2306 }
2307 int move_sm_on_same_triangle(
2308     struct volume *state,
2309     struct surface_molecule *sm,
2310     struct vector2 *new_loc,
2311     struct periodic_image *previous_box,
2312     struct wall *new_wall,
2313     struct hit_data *hd_info) {
2314   unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
2315   if (new_idx &gt;= sm-&gt;grid-&gt;n_tiles) {
2316     mcell_internal_error("After ray_trace_2D, selected u, v coordinates "
2317                          "map to an out-of-bounds grid cell.  uv=(%.2f, "
2318                          "%.2f) sm=%d/%d",
2319                          new_loc-&gt;u, new_loc-&gt;v, new_idx, sm-&gt;grid-&gt;n_tiles);
2320   }
2321   struct surface_molecule_list *sm_list = sm-&gt;grid-&gt;sm_list[new_idx];
2322   if (new_idx != sm-&gt;grid_index) {
2323     if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
2324         (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
2325       if (hd_info != NULL) {
2326         delete_void_list((struct void_list *)hd_info);
2327         hd_info = NULL;
2328       }
2329       return 1;     }
2330     remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
2331     sm-&gt;grid_index = new_idx;
2332     sm-&gt;grid-&gt;sm_list[new_idx] = add_surfmol_with_unique_pb_to_list(
2333       sm-&gt;grid-&gt;sm_list[new_idx], sm);
2334     assert(sm-&gt;grid-&gt;sm_list[new_idx] != NULL);
2335     count_moved_surface_mol(
2336       state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
2337       state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2338   } else {
2339     count_moved_surface_mol(
2340       state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
2341       state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2342   }
2343   sm-&gt;s_pos.u = new_loc-&gt;u;
2344   sm-&gt;s_pos.v = new_loc-&gt;v;
2345   return 0;
2346 }
2347 int move_sm_to_new_triangle(
2348     struct volume *state,
2349     struct surface_molecule *sm,
2350     struct vector2 *new_loc,
2351     struct periodic_image *previous_box,
2352     struct wall *new_wall,
2353     struct hit_data *hd_info) {
2354   if (new_wall-&gt;grid == NULL) {
2355     if (create_grid(state, new_wall, NULL))
2356       mcell_allocfailed("Failed to create a grid for a wall.");
2357   }
2358   unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
2359   if (new_idx &gt;= new_wall-&gt;grid-&gt;n_tiles) {
2360     mcell_internal_error(
2361         "After ray_trace_2D to a new wall, selected u, v coordinates map "
2362         "to an out-of-bounds grid cell.  uv=(%.2f, %.2f) sm=%d/%d",
2363         new_loc-&gt;u, new_loc-&gt;v, new_idx, new_wall-&gt;grid-&gt;n_tiles);
2364   }
2365   struct surface_molecule_list *sm_list = new_wall-&gt;grid-&gt;sm_list[new_idx];
2366   if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
2367       (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
2368     if (hd_info != NULL) {
2369       delete_void_list((struct void_list *)hd_info);
2370       hd_info = NULL;
2371     }
2372     return 1;   }
2373   count_moved_surface_mol(
2374     state, sm, new_wall-&gt;grid, new_loc, state-&gt;count_hashmask,
2375     state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2376   remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
2377   sm-&gt;grid-&gt;n_occupied--;
2378   sm-&gt;grid = new_wall-&gt;grid;
2379   sm-&gt;grid_index = new_idx;
2380   sm_list = add_surfmol_with_unique_pb_to_list(sm-&gt;grid-&gt;sm_list[new_idx], sm);
2381   assert(sm_list != NULL);
2382   sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] = sm_list;
2383   sm-&gt;grid-&gt;n_occupied++;
2384   sm-&gt;s_pos.u = new_loc-&gt;u;
2385   sm-&gt;s_pos.v = new_loc-&gt;v;
2386   return 0;
2387 }
2388 struct surface_molecule *diffuse_2D(
2389     struct volume *world,
2390     struct surface_molecule *sm,
2391     double max_time,
2392     double *advance_time) {
2393   struct species *spec = sm-&gt;properties;
2394   if (spec == NULL) {
2395     mcell_internal_error(
2396         "Attempted to take a 2-D diffusion step for a defunct molecule.");
2397   }
2398 #ifdef DEBUG_DIFFUSION
2399   DUMP_CONDITION3(
2400       dump_surface_molecule(sm, "", true, "Diffusing sm:", world-&gt;current_iterations, sm-&gt;t, true);
2401   );
2402 #endif
2403   if (sm-&gt;get_space_step(sm) &lt;= 0.0) {
2404     sm-&gt;t += max_time;
2405     return sm;
2406   }
2407   if (sm-&gt;get_time_step(sm) &gt; 1.0) {
2408     double sched_time = convert_iterations_to_seconds(
2409         world-&gt;start_iterations, world-&gt;time_unit,
2410         world-&gt;simulation_start_seconds, sm-&gt;t);
2411     double f = 1 + 0.2 * ((sched_time - sm-&gt;birthday)/world-&gt;time_unit);
2412     if (f &lt; 1)
2413       mcell_internal_error("A %s molecule is scheduled to move before it was "
2414                            "born [birthday=%.15g, t=%.15g]",
2415                            spec-&gt;sym-&gt;name, sm-&gt;birthday, sched_time);
2416     if (max_time &gt; f)
2417       max_time = f;
2418   }
2419   double steps = 0.0;
2420   double t_steps = 0.0;
2421   double space_factor = 0.0;
2422   if (sm-&gt;get_time_step(sm) &gt; max_time) {
2423     t_steps = max_time;
2424     steps = max_time / sm-&gt;get_time_step(sm);
2425   } else {
2426     t_steps = sm-&gt;get_time_step(sm);
2427     steps = 1.0;
2428   }
2429   if (steps &lt; EPS_C) {
2430     steps = EPS_C;
2431     t_steps = EPS_C * sm-&gt;get_time_step(sm);
2432   }
2433   if (steps == 1.0)
2434     space_factor = sm-&gt;get_space_step(sm);
2435   else
2436     space_factor = sm-&gt;get_space_step(sm) * sqrt(steps);
2437 #ifdef DEBUG_TIMING
2438   DUMP_CONDITION3(
2439       MCell::dump_surf_mol_timing(
2440           "- Timing sm", world-&gt;current_iterations, sm-&gt;id,
2441           sm-&gt;t, max_time, sm-&gt;t + sm-&gt;t2,
2442           space_factor, steps, t_steps
2443       );   );
2444 #endif
2445   world-&gt;diffusion_number++;
2446   world-&gt;diffusion_cumtime += steps;
2447   struct periodic_image previous_box = {sm-&gt;periodic_box-&gt;x,
2448                                         sm-&gt;periodic_box-&gt;y,
2449                                         sm-&gt;periodic_box-&gt;z
2450                                        };
2451   struct hit_data *hd_info = NULL;
2452   for (int find_new_position = (SURFACE_DIFFUSION_RETRIES + 1);
2453        find_new_position &gt; 0; find_new_position--) {
2454     hd_info = NULL;
2455     struct vector2 displacement;
2456     pick_2D_displacement(&amp;displacement, space_factor, world-&gt;rng);
2457 #ifdef DEBUG_DIFFUSION
2458     DUMP_CONDITION3(
2459         dump_vector2(displacement, "  displacement:")
2460     );
2461 #endif
2462     if (sm-&gt;properties-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
2463       double disp_length = sqrt(displacement.u * displacement.u +
2464                          displacement.v * displacement.v);
2465       if (disp_length &gt; sm-&gt;properties-&gt;max_step_length) {
2466         displacement.u *= (sm-&gt;properties-&gt;max_step_length / disp_length);
2467         displacement.v *= (sm-&gt;properties-&gt;max_step_length / disp_length);
2468       }
2469     }
2470     struct vector2 new_loc;
2471     struct rxn *rxp = NULL;
2472     int kill_me = 0;
2473     struct wall *new_wall = ray_trace_2D(world, sm, &amp;displacement, &amp;new_loc,
2474       &amp;kill_me, &amp;rxp, &amp;hd_info);
2475     if (new_wall == NULL) {
2476       if (kill_me == 1) {
2477         if (rxp == NULL) {
2478           mcell_internal_error("Error in 'ray_trace_2D()' after hitting "
2479                                "ABSORPTIVE region border.");
2480         }
2481         if (hd_info != NULL) {
2482           count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
2483         }
2484         int result = outcome_unimolecular(world, rxp, 0,
2485                                       (struct abstract_molecule *)sm, sm-&gt;t);
2486         if (result != RX_DESTROY) {
2487           mcell_internal_error("Molecule should disappear after hitting "
2488                                "ABSORPTIVE region border.");
2489         }
2490         delete_void_list((struct void_list *)hd_info);
2491         hd_info = NULL;
2492         return NULL;
2493       }
2494       if (hd_info != NULL) {
2495         delete_void_list((struct void_list *)hd_info);
2496         hd_info = NULL;
2497       }
2498       continue;     }
2499     if (new_wall == sm-&gt;grid-&gt;surface) {
2500       if (move_sm_on_same_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
2501         continue; 
2502       }
2503     }
2504     else {
2505       if (move_sm_to_new_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
2506         continue;
2507       }
2508     }
2509     find_new_position = 0;
2510   }
2511   if (hd_info != NULL) {
2512     count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
2513     delete_void_list((struct void_list *)hd_info);
2514     hd_info = NULL;
2515   }
2516   *advance_time = t_steps;
2517   return sm;
2518 }
2519 struct surface_molecule *
2520 react_2D_all_neighbors(struct volume *world, struct surface_molecule *sm,
2521                        double t, enum notify_level_t molecule_collision_report,
2522                        int grid_grid_reaction_flag,
2523                        long long *surf_surf_colls) {
2524 #ifdef DEBUG_TIMING
2525   DUMP_CONDITION3(
2526       MCell::dump_react_2D_all_neighbors_timing(t, sm-&gt;t);
2527   );
2528 #endif
2529   int l = 0;
2530   int num_matching_rxns = 0;
2531   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
2532   struct tile_neighbor *tile_nbr_head = NULL, *curr;
2533   int list_length = 0; 
2534   if ((u_int)sm-&gt;grid_index &gt;= sm-&gt;grid-&gt;n_tiles) {
2535     mcell_internal_error("tile index %u is greater or equal number_of_tiles %u",
2536                          (u_int)sm-&gt;grid_index, sm-&gt;grid-&gt;n_tiles);
2537   }
2538   find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1, &amp;tile_nbr_head,
2539                       &amp;list_length);
2540   if (tile_nbr_head == NULL)
2541     return sm; 
2542   const int num_nbrs = list_length;
2543   int max_size = num_nbrs * MAX_MATCHING_RXNS;
2544   std::vector&lt;struct rxn *&gt; rxn_array(max_size);
2545   std::vector&lt;double&gt; cf(max_size); 
2546   std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
2547   local_prob_factor = 3.0 / num_nbrs;
2548   for (int kk = 0; kk &lt; max_size; kk++) {     rxn_array[kk] = NULL;
2549     smol[kk] = NULL;
2550     cf[kk] = 0;
2551   }
2552   for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
2553     struct surface_molecule_list *sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]; 
2554     if (sm_list == NULL || sm_list-&gt;sm == NULL)
2555       continue;
2556     struct surface_molecule *smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
2557 #ifdef DEBUG_RXNS
2558     DUMP_CONDITION3(
2559         dump_surface_molecule(smp, "", true, "  checking in react_2D_all_neighbors: ", world-&gt;current_iterations, 0.0, true);
2560     );
2561 #endif
2562     if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
2563         (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
2564       if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
2565         if (walls_belong_to_at_least_one_different_restricted_region(
2566                 world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp))
2567           continue;
2568         if (walls_belong_to_at_least_one_different_restricted_region(
2569                 world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm))
2570           continue;
2571       }
2572     }
2573     if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
2574       num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)sm,
2575         (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient, matching_rxns);
2576     } 
2577     else{     
2578     num_matching_rxns = trigger_bimolecular(
2579         world-&gt;reaction_hash, world-&gt;rx_hashsize, sm-&gt;properties-&gt;hashval,
2580         smp-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
2581         (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient,
2582         matching_rxns);
2583     }
2584     if (num_matching_rxns &gt; 0) {
2585       if (molecule_collision_report == NOTIFY_FULL) {
2586         if (grid_grid_reaction_flag)
2587           surf_surf_colls++;
2588       }
2589       for (int jj = 0; jj &lt; num_matching_rxns; jj++) {
2590         if (matching_rxns[jj] != NULL) {
2591           if (matching_rxns[jj]-&gt;prob_t != NULL)
2592             update_probs(world, matching_rxns[jj], sm-&gt;t);
2593           rxn_array[l] = matching_rxns[jj];
2594           cf[l] = t / (curr-&gt;grid-&gt;binding_factor);
2595           smol[l] = smp;
2596           l++;
2597         }
2598       }
2599       n += num_matching_rxns;
2600     }
2601   }
2602   delete_tile_neighbor_list(tile_nbr_head);
2603   if (n == 0) {
2604     return sm;   } else if (n == 1) {
2605     i = test_bimolecular(rxn_array[0], cf[0], local_prob_factor, NULL, NULL,
2606                          world-&gt;rng);
2607     j = 0;
2608   } else {
2609     int all_neighbors_flag = 1;
2610     j = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor, n, &amp;(i),
2611                               world-&gt;rng, all_neighbors_flag);
2612   }
2613   if ((j == RX_NO_RX) || (i &lt; RX_LEAST_VALID_PATHWAY)) {
2614     return sm;   }
2615   int outcome_bimol_result = outcome_bimolecular(
2616       world, rxn_array[j], i, (struct abstract_molecule *)sm,
2617       (struct abstract_molecule *)smol[j], sm-&gt;orient, smol[j]-&gt;orient, sm-&gt;t,
2618       NULL, NULL);
2619   if (outcome_bimol_result == RX_DESTROY) {
2620     mem_put(sm-&gt;birthplace, sm);
2621     return NULL;
2622   }
2623   return sm;
2624 }
2625 void clean_up_old_molecules(struct storage *local) {
2626   if (local-&gt;timer-&gt;defunct_count &gt; MIN_DEFUNCT_FOR_GC &amp;&amp;
2627       MAX_DEFUNCT_FRAC * (local-&gt;timer-&gt;count) &lt; local-&gt;timer-&gt;defunct_count) {
2628     struct abstract_molecule *am;
2629     am = (struct abstract_molecule *)schedule_cleanup(local-&gt;timer,
2630                                                       *is_defunct_molecule);
2631     while (am != NULL) {
2632       struct abstract_molecule *temp = am;
2633       am = am-&gt;next;
2634       if ((temp-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
2635         temp-&gt;next = NULL;
2636         mem_put(temp-&gt;birthplace, temp);
2637       } else {
2638         temp-&gt;flags &amp;= ~IN_SCHEDULE;
2639       }
2640     }
2641   }
2642 }
2643 void reschedule_surface_molecules(
2644     struct volume *state, struct storage *local,
2645     struct abstract_molecule *am) {
2646   struct vector3 pos3d;
2647   struct surface_molecule *sm = (struct surface_molecule *)(void *)am;
2648   uv2xyz(&amp;sm-&gt;s_pos, sm-&gt;grid-&gt;surface, &amp;pos3d);
2649   struct subvolume *sv = find_subvolume(state, &amp;pos3d, sm-&gt;grid-&gt;subvol);
2650   if (sv-&gt;local_storage != local) {
2651     struct surface_molecule *sm_new =
2652         (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol,
2653                                                    "surface molecule");
2654     memcpy(sm_new, sm, sizeof(struct surface_molecule));
2655     sm_new-&gt;next = NULL;
2656     sm_new-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
2657     if (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] &amp;&amp; 
2658         (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm == sm)) {
2659       sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm = sm_new;
2660       sm-&gt;grid = NULL;
2661       sm-&gt;grid_index = 0;
2662     }
2663     mem_put(sm-&gt;birthplace, sm);
2664     if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, sm_new))
2665       mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
2666                         "after migrating to a new memory store.",
2667                         am-&gt;properties-&gt;sym-&gt;name);
2668   } else {
2669     if (schedule_add_mol(local-&gt;timer, am))
2670       mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
2671                         "after taking a diffusion step.",
2672                         am-&gt;properties-&gt;sym-&gt;name);
2673   }
2674 }
2675 void run_timestep(struct volume *state, struct storage *local,
2676                   double release_time, double checkpt_time) {
2677   struct abstract_molecule *am;
2678   clean_up_old_molecules(local);
2679 #ifdef MCELL3_SORTED_MOLS_ON_RUN_TIMESTEP
2680   #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2681     dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
2682   #endif
2683   sort_schedule_by_time_and_id(local-&gt;timer);
2684   #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2685     dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
2686   #endif
2687 #endif
2688   while (local-&gt;timer-&gt;current != NULL) {
2689 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2690     dump_schedule_helper(local-&gt;timer, "local", "", "", true);
2691 #endif
2692 #ifdef MCELL3_4_ALWAYS_SORT_MOLS_BY_TIME_AND_ID
2693 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2694   dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
2695 #endif
2696   sort_schedule_by_time_and_id(local-&gt;timer);
2697 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2698   dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
2699 #endif
2700 #endif
2701     am = (struct abstract_molecule *)schedule_next(local-&gt;timer);
2702     if (am-&gt;properties == NULL)     {
2703       if ((am-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
2704         am-&gt;next = NULL;
2705         mem_put(am-&gt;birthplace, am);
2706       } else
2707         am-&gt;flags &amp;= ~IN_SCHEDULE;
2708       if (local-&gt;timer-&gt;defunct_count &gt; 0)
2709         local-&gt;timer-&gt;defunct_count--;
2710       continue;
2711     }
2712 #ifdef DEBUG_SCHEDULER
2713     {
2714       struct volume *world = state;
2715       DUMP_CONDITION3(
2716           struct volume_molecule* vm = (struct volume_molecule*)am;
2717           dump_volume_molecule(vm, "", true, "\n* Running scheduled action: ", world-&gt;current_iterations, vm-&gt;t, true);
2718       );
2719     }
2720 #endif
2721     am-&gt;flags &amp;= ~IN_SCHEDULE;
2722     if (am-&gt;t2 &lt; EPS_C || am-&gt;t2 &lt; EPS_C * am-&gt;t) {
2723       if (!check_for_unimolecular_reaction(state, am)) {
2724         continue;
2725       }
2726     }
2727     double surface_mol_advance_time = 0;
2728     struct wall *current_wall = NULL;
2729     double max_time;
2730 #ifdef MCELL_ALWAYS_DIFFUSE
2731     int can_diffuse = 1;
2732 #else
2733     int can_diffuse = ((am-&gt;flags &amp; ACT_DIFFUSE) != 0);
2734 #endif
2735     if (can_diffuse) {
2736       max_time = checkpt_time - am-&gt;t;
2737       if (local-&gt;max_timestep &lt; max_time)
2738         max_time = local-&gt;max_timestep;
2739       if ((am-&gt;flags &amp; (ACT_REACT)) != 0 &amp;&amp; am-&gt;t2 &lt; max_time)
2740         max_time = am-&gt;t2;
2741       if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
2742         double save_sched_time = am-&gt;t;
2743         if (max_time &gt; release_time - am-&gt;t)
2744           max_time = release_time - am-&gt;t;
2745         if (am-&gt;properties-&gt;flags &amp; (CAN_VOLVOLVOL | CAN_VOLVOLSURF))
2746           am = (struct abstract_molecule *)diffuse_3D_big_list(
2747               state, (struct volume_molecule *)am, max_time);
2748         else
2749           am = (struct abstract_molecule *)diffuse_3D(
2750               state, (struct volume_molecule *)am, max_time);
2751         if (am != NULL)         {
2752           if ((am-&gt;flags &amp; ACT_REACT) != 0) {
2753             am-&gt;t2 -= am-&gt;t - save_sched_time;
2754             if (am-&gt;t2 &lt; 0)
2755               am-&gt;t2 = 0;
2756           }
2757         } else
2758           continue;
2759       } else {
2760         if (max_time &gt; release_time - am-&gt;t) {
2761           max_time = release_time - am-&gt;t;
2762         }
2763         current_wall = ((struct surface_molecule *)am)-&gt;grid-&gt;surface;
2764         am = (struct abstract_molecule *)diffuse_2D(
2765             state, (struct surface_molecule *)am, max_time,
2766             &amp;surface_mol_advance_time);
2767         if (am == NULL) {
2768           continue;
2769         }
2770       }
2771     }
2772     else {
2773 #ifdef DEBUG_DIFFUSION
2774       struct volume *world = state;
2775       if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
2776         DUMP_CONDITION3(
2777             dump_volume_molecule((struct volume_molecule *)am, "", true, "Not diffusing vm:", world-&gt;current_iterations, am-&gt;t, true);
2778         );
2779       }
2780       else {
2781         DUMP_CONDITION3(
2782             dump_surface_molecule((struct surface_molecule *)am, "", true, "Not diffusing sm:", world-&gt;current_iterations, am-&gt;t, true);
2783         );
2784       }
2785 #endif
2786     }
2787     int can_surface_mol_react = (am-&gt;get_flags(am) &amp; (CAN_SURFSURFSURF | CAN_SURFSURF));
2788     if (((am-&gt;flags &amp; TYPE_SURF) != 0) &amp;&amp; can_surface_mol_react) {
2789       if (!can_diffuse) 
2790       {
2791         max_time = checkpt_time - am-&gt;t;
2792         if (am-&gt;t2 &lt; max_time &amp;&amp; (am-&gt;flags &amp; (ACT_REACT)) != 0)
2793           max_time = am-&gt;t2;
2794         if (max_time &gt; release_time - am-&gt;t)
2795           max_time = release_time - am-&gt;t;
2796         if (am-&gt;get_time_step(am) &lt; max_time)
2797           max_time = am-&gt;get_time_step(am);
2798         surface_mol_advance_time = max_time;
2799       } else
2800         max_time = surface_mol_advance_time;
2801       if (can_surface_mol_react) {
2802         if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURF)) ==
2803             CAN_SURFSURF) {
2804           am = (struct abstract_molecule *)react_2D_all_neighbors(
2805               state, (struct surface_molecule *)am, max_time,
2806               state-&gt;notify-&gt;molecule_collision_report,
2807               state-&gt;rxn_flags.surf_surf_reaction_flag,
2808               &amp;(state-&gt;surf_surf_colls));
2809           if (am == NULL)
2810             continue;
2811         }
2812         if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURFSURF)) ==
2813             CAN_SURFSURFSURF) {
2814           am = (struct abstract_molecule *)react_2D_trimol_all_neighbors(
2815               state, (struct surface_molecule *)am, max_time,
2816               state-&gt;notify-&gt;molecule_collision_report,
2817               state-&gt;notify-&gt;final_summary,
2818               state-&gt;rxn_flags.surf_surf_surf_reaction_flag,
2819               &amp;(state-&gt;surf_surf_surf_colls));
2820           if (am == NULL)
2821             continue;
2822         }
2823       }
2824     }
2825     if ((am-&gt;flags &amp; TYPE_SURF) != 0 &amp;&amp; (can_diffuse || can_surface_mol_react)) {
2826       am-&gt;t += surface_mol_advance_time;
2827       if ((am-&gt;flags &amp; ACT_REACT) != 0) {
2828         int can_surf_react = ((am-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0);
2829         if (can_surf_react &amp;&amp; !distinguishable(am-&gt;t2, (double)FOREVER, EPS_C)) {
2830           am-&gt;t2 = 0;
2831           am-&gt;flags |= ACT_CHANGE;         }
2832         else {
2833           am-&gt;t2 -= surface_mol_advance_time;
2834           if (am-&gt;t2 &lt; 0) {
2835             am-&gt;t2 = 0;
2836           }
2837           if ((current_wall !=
2838               ((struct surface_molecule *)am)-&gt;grid-&gt;surface) &amp;&amp;
2839               (am-&gt;t2 &gt; EPS_C || am-&gt;t2 &gt; EPS_C * am-&gt;t)) {
2840             am-&gt;t2 = 0;
2841             am-&gt;flags |= ACT_CHANGE;           }
2842         }
2843       }
2844     } else if (!can_diffuse) {
2845       if (am-&gt;t2 == 0)
2846         am-&gt;t += MAX_UNI_TIMESKIP;
2847       else {
2848         am-&gt;t += am-&gt;t2;
2849         am-&gt;t2 = 0;
2850       }
2851     }
2852     am-&gt;flags |= IN_SCHEDULE;
2853     double t = ceil(am-&gt;t) * (1.0 + 0.1 * EPS_C);
2854     if (!distinguishable(t, am-&gt;t, EPS_C))
2855       am-&gt;t = t;
2856     if (am-&gt;flags &amp; TYPE_SURF) {
2857       reschedule_surface_molecules(state, local, am);
2858     } else {
2859       if (schedule_add(
2860               ((struct volume_molecule *)am)-&gt;subvol-&gt;local_storage-&gt;timer, am))
2861         mcell_allocfailed("Failed to add a '%s' volume molecule to scheduler "
2862                           "after taking a diffusion step.",
2863                           am-&gt;properties-&gt;sym-&gt;name);
2864     }
2865   }
2866   if (local-&gt;timer-&gt;error)
2867     mcell_internal_error("Scheduler reported an out-of-memory error while "
2868                          "retrieving molecules, but this should never happen.");
2869 }
2870 void run_clamp(struct volume *world, double t_now) {
2871   int this_count = 0;
2872   static int total_count = 0;
2873   for (struct clamp_data *cdp = world-&gt;clamp_list; cdp != NULL; cdp = cdp-&gt;next) {
2874     if (cdp-&gt;objp == NULL) {
2875       continue;
2876     }
2877     for (struct clamp_data *cdpo = cdp; cdpo != NULL; cdpo = cdpo-&gt;next_obj) {
2878       for (struct clamp_data *cdpm = cdpo; cdpm != NULL; cdpm = cdpm-&gt;next_mol) {
2879         double n_collisions = cdpo-&gt;scaling_factor * cdpm-&gt;mol-&gt;space_step *
2880                        cdpm-&gt;clamp_value / cdpm-&gt;mol-&gt;time_step;
2881         if (cdpm-&gt;orient != 0) {
2882           n_collisions *= 0.5;
2883         }
2884         int n_emitted = poisson_dist(n_collisions, rng_dbl(world-&gt;rng));
2885         if (n_emitted == 0)
2886           continue;
2887         struct volume_molecule vm;
2888         vm.t = t_now + 0.5;
2889         vm.t2 = 0;
2890         vm.flags = IN_SCHEDULE | ACT_NEWBIE | TYPE_VOL | IN_VOLUME |
2891                   ACT_CLAMPED | ACT_DIFFUSE;
2892         vm.properties = cdpm-&gt;mol;
2893         initialize_diffusion_function((struct abstract_molecule*)&amp;vm);
2894         vm.mesh_name = NULL;
2895         vm.birthplace = NULL;
2896         vm.birthday = convert_iterations_to_seconds(
2897             world-&gt;start_iterations, world-&gt;time_unit,
2898             world-&gt;simulation_start_seconds, t_now);
2899         vm.subvol = NULL;
2900         vm.previous_wall = NULL;
2901         vm.index = 0;
2902         struct volume_molecule *vmp = NULL;
2903         this_count += n_emitted;
2904         while (n_emitted &gt; 0) {
2905           int idx = bisect_high(cdpo-&gt;cum_area, cdpo-&gt;n_sides,
2906                             rng_dbl(world-&gt;rng) *
2907                                 cdpo-&gt;cum_area[cdp-&gt;n_sides - 1]);
2908           struct wall *w = cdpo-&gt;objp-&gt;wall_p[cdpo-&gt;side_idx[idx]];
2909           double s1 = sqrt(rng_dbl(world-&gt;rng));
2910           double s2 = rng_dbl(world-&gt;rng) * s1;
2911           struct vector3 v;
2912           v.x = w-&gt;vert[0]-&gt;x + s1 * (w-&gt;vert[1]-&gt;x - w-&gt;vert[0]-&gt;x) +
2913                 s2 * (w-&gt;vert[2]-&gt;x - w-&gt;vert[1]-&gt;x);
2914           v.y = w-&gt;vert[0]-&gt;y + s1 * (w-&gt;vert[1]-&gt;y - w-&gt;vert[0]-&gt;y) +
2915                 s2 * (w-&gt;vert[2]-&gt;y - w-&gt;vert[1]-&gt;y);
2916           v.z = w-&gt;vert[0]-&gt;z + s1 * (w-&gt;vert[1]-&gt;z - w-&gt;vert[0]-&gt;z) +
2917                 s2 * (w-&gt;vert[2]-&gt;z - w-&gt;vert[1]-&gt;z);
2918           if (cdpm-&gt;orient == 1) {
2919             vm.index = 1;
2920           }
2921           else if (cdpm-&gt;orient == -1) {
2922             vm.index = -1;
2923           }
2924           else {
2925             vm.index = (rng_uint(world-&gt;rng) &amp; 2) - 1;
2926           }
2927           double eps = EPS_C * vm.index;
2928           s1 = fabs(v.x);
2929           s2 = fabs(v.y);
2930           if (s1 &lt; s2) {
2931             s1 = s2;
2932           }
2933           s2 = fabs(v.z);
2934           if (s1 &lt; s2) {
2935             s1 = s2;
2936           }
2937           if (s1 &gt; 1.0){
2938             eps *= s1;
2939           }
2940           vm.pos.x = v.x + w-&gt;normal.x * eps;
2941           vm.pos.y = v.y + w-&gt;normal.y * eps;
2942           vm.pos.z = v.z + w-&gt;normal.z * eps;
2943           vm.previous_wall = w;
2944           struct periodic_image periodic_box = {0, 0, 0};
2945           vm.periodic_box = &amp;periodic_box;
2946           if (vmp == NULL) {
2947             vmp = insert_volume_molecule(world, &amp;vm, vmp);
2948             if (vmp == NULL)
2949               mcell_allocfailed("Failed to insert a '%s' volume molecule while "
2950                                 "concentration/flux clamping.",
2951                                 vm.properties-&gt;sym-&gt;name);
2952             if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
2953                                      cdpm-&gt;mol-&gt;hashval,
2954                                      (struct abstract_molecule *)vmp) != NULL) {
2955               vm.flags |= ACT_REACT;
2956               vmp-&gt;flags |= ACT_REACT;
2957             }
2958           } else {
2959             vmp = insert_volume_molecule(world, &amp;vm, vmp);
2960             if (vmp == NULL)
2961               mcell_allocfailed("Failed to insert a '%s' volume molecule while "
2962                                 "concentration/flux clamping.",
2963                                 vm.properties-&gt;sym-&gt;name);
2964           }
2965           n_emitted--;
2966         }
2967       }
2968     }
2969   }
2970   total_count += this_count;
2971 }
2972 void redo_collision_list(struct volume* world, struct collision** shead,
2973   struct collision** stail, struct collision** shead_exp, struct volume_molecule* m,
2974   struct vector3* displacement, struct subvolume* sv) {
2975   struct collision* st = *stail;
2976   struct collision* sh = *shead_exp;
2977   if (st != NULL) {
2978     st-&gt;next = NULL;
2979     if (sh != NULL) {
2980       mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
2981       sh = NULL;
2982     }
2983   } else if (sh != NULL) {
2984     mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
2985     sh = NULL;
2986     *shead = NULL;
2987   }
2988   if ((m-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
2989     sh = expand_collision_list(world, m, displacement, sv, world-&gt;rx_radius_3d,
2990       world-&gt;ny_parts, world-&gt;nz_parts, world-&gt;x_fineparts,
2991       world-&gt;y_fineparts, world-&gt;z_fineparts, world-&gt;rx_hashsize,
2992       world-&gt;reaction_hash);
2993     if (st != NULL)
2994       st-&gt;next = sh;
2995     else {
2996       if (*shead != NULL)
2997         mcell_internal_error("Collision lists corrupted.  While expanding "
2998                              "the collision lists, expected shead to be "
2999                              "NULL, but it wasn't.");
3000       *shead = sh;
3001     }
3002   }
3003   *stail = st;
3004   *shead_exp = sh;
3005 }
3006 static int collide_and_react_with_vol_mol(struct volume* world,
3007   struct collision* smash, struct volume_molecule* m, struct collision**
3008   tentative, struct vector3* displacement, struct vector3* loc_certain, double
3009   t_steps, double r_rate_factor) {
3010   struct abstract_molecule* am = (struct abstract_molecule *)smash-&gt;target;
3011   double factor = exact_disk(
3012       world, &amp;(smash-&gt;loc), displacement, world-&gt;rx_radius_3d, m-&gt;subvol,
3013       m, (struct volume_molecule *)am, world-&gt;use_expanded_list,
3014       world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
3015   if (factor &lt; 0) {     return 0;   }
3016   double scaling = factor * r_rate_factor;
3017   struct rxn* rx = smash-&gt;intermediate;
3018   if ((rx != NULL) &amp;&amp; (rx-&gt;prob_t != NULL)) {
3019     update_probs(world, rx, m-&gt;t);
3020   }
3021   struct species *spec = m-&gt;properties;
3022   struct periodic_image *periodic_box = m-&gt;periodic_box;
3023   int i = test_bimolecular(
3024     rx, scaling, 0, am, (struct abstract_molecule *)m, world-&gt;rng);
3025   if (i &lt; RX_LEAST_VALID_PATHWAY) {
3026     return 0;
3027   }
3028   if (loc_certain != NULL) {
3029   }
3030   int j = outcome_bimolecular(world, rx, i, (struct abstract_molecule *)m, am,
3031     0, 0, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc_certain);
3032   if (j != RX_DESTROY) {
3033     return 0;
3034   } else {
3035     struct collision* ttv = *tentative;
3036     for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
3037       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3038         continue;
3039       }
3040       if (m-&gt;properties == NULL) {
3041         continue;
3042       }
3043       if (!(m-&gt;properties-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
3044             COUNT_SOME_MASK)) {
3045         continue;
3046       }
3047       count_region_update(world, m, spec, m-&gt;id, periodic_box,
3048         ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3049         ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
3050       if (ttv == smash) {
3051         break;
3052       }
3053     }
3054     *tentative = ttv;
3055   }
3056   return 1;
3057 }
3058 int collide_and_react_with_surf_mol(struct volume* world, struct collision* smash,
3059   struct volume_molecule* m, struct collision** tentative,
3060   struct vector3** loc_certain, double t_steps, int mol_grid_flag,
3061   int mol_grid_grid_flag, double r_rate_factor) {
3062   ASSERT_FOR_MCELL4(mol_grid_flag == 1);
3063   struct collision* ttv = *tentative;
3064   struct vector3* loc = *loc_certain;
3065   struct wall* w = (struct wall *)smash-&gt;target;
3066   double t_confident = 0.0;
3067   if (smash-&gt;next == NULL) {
3068     t_confident = smash-&gt;t;
3069   } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
3070     t_confident = smash-&gt;t;
3071   } else {
3072 	  ASSERT_FOR_MCELL4(false);
3073     t_confident = smash-&gt;t * (1.0 - EPS_C);
3074   }
3075   int k = -1;
3076   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3077     k = 1;
3078   }
3079   int j = xyz2grid(&amp;(smash-&gt;loc), w-&gt;grid);
3080   struct surface_molecule_list *sm_list = w-&gt;grid-&gt;sm_list[j]; 
3081   if (sm_list == NULL || sm_list-&gt;sm == NULL) {
3082     return -1;
3083   }
3084   struct surface_molecule* sm = w-&gt;grid-&gt;sm_list[j]-&gt;sm;
3085   if (m-&gt;index == j &amp;&amp; m-&gt;previous_wall == w) {
3086     m-&gt;index = -1;     return -1;
3087   }
3088   int num_matching_rxns = 0;
3089   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3090   double scaling_coef[MAX_MATCHING_RXNS];
3091   struct species* spec = m-&gt;properties;
3092   struct periodic_image *periodic_box = m-&gt;periodic_box;
3093   int ii = 0, jj = 0;
3094   if (mol_grid_flag) {
3095     if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3096       num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
3097         (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
3098     }
3099     else{
3100     num_matching_rxns = trigger_bimolecular(
3101       world-&gt;reaction_hash, world-&gt;rx_hashsize, spec-&gt;hashval,
3102       sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)m,
3103       (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
3104     }
3105     if (num_matching_rxns &gt; 0) {
3106       if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
3107         if (world-&gt;rxn_flags.vol_surf_reaction_flag)
3108           world-&gt;vol_surf_colls++;
3109       }
3110       for (int l = 0; l &lt; num_matching_rxns; l++) {
3111         if (matching_rxns[l]-&gt;prob_t != NULL) { 
3112 	        ASSERT_FOR_MCELL4(false);
3113           update_probs(world, matching_rxns[l], m-&gt;t); 
3114         }
3115         scaling_coef[l] = r_rate_factor / w-&gt;grid-&gt;binding_factor;
3116       }
3117       if (num_matching_rxns == 1) {
3118         ii = test_bimolecular(matching_rxns[0], scaling_coef[0], 0,
3119           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3120           world-&gt;rng);
3121         jj = 0;
3122       } else {
3123         ASSERT_FOR_MCELL4(false);      
3124         jj = test_many_bimolecular(matching_rxns, scaling_coef, 0,
3125           num_matching_rxns, &amp;(ii), world-&gt;rng, 0);
3126       }
3127       if ((jj &gt; RX_NO_RX) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY)) {
3128         short mflags = m-&gt;flags;
3129         int l = outcome_bimolecular(world, matching_rxns[jj], ii,
3130           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3131           k, sm-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
3132         if (l == RX_FLIP) {
3133           if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3134             int destroy_flag = 0;
3135             count_tentative_collisions(
3136               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3137               periodic_box, m-&gt;id);
3138           }
3139           *tentative = ttv;
3140           *loc_certain = &amp;(ttv-&gt;loc);
3141           return 0;         } else if (l == RX_DESTROY) {
3142           if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3143             int destroy_flag = 0;
3144             count_tentative_collisions(
3145               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3146               periodic_box, m-&gt;id);
3147           }
3148           *tentative = ttv;
3149           return 1;
3150         }
3151       }
3152     }
3153   }
3154   if (mol_grid_grid_flag) {
3155     struct surface_molecule *smp;     struct tile_neighbor *tile_nbr_head = NULL, *curr;
3156     int list_length = 0;
3157     find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1,
3158       &amp;tile_nbr_head, &amp;list_length);
3159     if (tile_nbr_head != NULL) {
3160       const int num_nbrs = (int)list_length;
3161       int max_size = num_nbrs * MAX_MATCHING_RXNS;
3162       std::vector&lt;struct rxn *&gt; rxn_array(max_size);
3163       std::vector&lt;double&gt; cf(max_size); 
3164       std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
3165       local_prob_factor = 3.0 / num_nbrs;
3166       jj = RX_NO_RX;
3167       ii = RX_LEAST_VALID_PATHWAY - 1;
3168       for (int kk = 0; kk &lt; max_size; kk++) {
3169         smol[kk] = NULL;
3170         rxn_array[kk] = NULL;
3171         cf[kk] = 0;
3172       }
3173       int ll = 0;
3174       for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
3175         sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx];
3176         if (sm_list == NULL || sm_list-&gt;sm == NULL)
3177           continue;
3178         smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
3179         if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
3180             (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
3181           if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
3182             if (walls_belong_to_at_least_one_different_restricted_region(
3183                     world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp)) {
3184               continue;
3185             }
3186             if (walls_belong_to_at_least_one_different_restricted_region(
3187                     world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm)) {
3188               continue;
3189             }
3190           }
3191         }
3192         num_matching_rxns = trigger_trimolecular(world-&gt;reaction_hash,
3193           world-&gt;rx_hashsize, spec-&gt;hashval, sm-&gt;properties-&gt;hashval,
3194           smp-&gt;properties-&gt;hashval, spec, sm-&gt;properties, smp-&gt;properties,
3195           k, sm-&gt;orient, smp-&gt;orient, matching_rxns);
3196         if (num_matching_rxns &gt; 0) {
3197           if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL &amp;&amp;
3198               world-&gt;rxn_flags.vol_surf_surf_reaction_flag) {
3199               world-&gt;vol_surf_surf_colls++;
3200           }
3201           for (j = 0; j &lt; num_matching_rxns; j++) {
3202             if (matching_rxns[j]-&gt;prob_t != NULL) {
3203               update_probs(world, matching_rxns[j], m-&gt;t);
3204             }
3205             rxn_array[ll] = matching_rxns[j];
3206             cf[ll] = r_rate_factor / (w-&gt;grid-&gt;binding_factor *
3207                                       curr-&gt;grid-&gt;binding_factor);
3208             smol[ll] = smp;
3209             ll++;
3210           }
3211           n += num_matching_rxns;
3212         }
3213       }
3214       delete_tile_neighbor_list(tile_nbr_head);
3215       if (n == 1) {
3216         ii = test_bimolecular(rxn_array[0], cf[0], local_prob_factor,
3217           NULL, NULL, world-&gt;rng);
3218         jj = 0;
3219       } else if (n &gt; 1) {
3220         int all_neighbors_flag = 1;
3221         jj = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor,
3222           n, &amp;(ii), world-&gt;rng, all_neighbors_flag);
3223       }
3224       if (n &gt; max_size)
3225         mcell_internal_error(
3226             "The size of the reactions array is not sufficient.");
3227       if ((n &gt; 0) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
3228         int mflags = m-&gt;flags;
3229         int l = outcome_trimolecular(world, rxn_array[jj], ii,
3230           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3231           (struct abstract_molecule *)smol[jj], k, sm-&gt;orient,
3232           smol[jj]-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;smash-&gt;loc, &amp;m-&gt;pos);
3233         if (l == RX_FLIP) {
3234           if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3235             int destroy_flag = 0;
3236             count_tentative_collisions(
3237               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3238               periodic_box, m-&gt;id);
3239           }
3240           *loc_certain = &amp;(ttv-&gt;loc);
3241           *tentative = ttv;
3242           return 0;         } else if (l == RX_DESTROY) {
3243           if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3244             int destroy_flag = 0;
3245             count_tentative_collisions(
3246               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3247               periodic_box, m-&gt;id);
3248           }
3249           *tentative = ttv;
3250           return 1;
3251         }
3252       }
3253     }
3254   }
3255   return -1;
3256 }
3257 int collide_and_react_with_walls(struct volume* world, struct collision* smash,
3258   struct volume_molecule* m, struct collision** tentative,
3259   struct vector3** loc_certain, double t_steps, int inertness,
3260   double r_rate_factor) {
3261   struct collision *ttv = *tentative;
3262   struct vector3 *loc = *loc_certain;
3263   double t_confident = 0.0;
3264   if (smash-&gt;next == NULL) {
3265     t_confident = smash-&gt;t;
3266   } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
3267     t_confident = smash-&gt;t;
3268   } else {
3269     t_confident = smash-&gt;t * (1.0 - EPS_C);
3270   }
3271   int k = -1;
3272   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3273     k = 1;
3274   }
3275   m-&gt;index = -1;
3276   int num_matching_rxns = 0;
3277   struct rxn* rx = NULL;
3278   struct species* spec = m-&gt;properties;
3279   struct wall* w = (struct wall *)smash-&gt;target;
3280   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3281   num_matching_rxns = trigger_intersect(world-&gt;reaction_hash,
3282     world-&gt;rx_hashsize, world-&gt;all_mols, world-&gt;all_volume_mols,
3283     world-&gt;all_surface_mols, spec-&gt;hashval, (struct abstract_molecule *)m, k, w,
3284     matching_rxns, 1, 0, 0);
3285   if (num_matching_rxns == 0) {
3286     return -1;
3287   }
3288   int is_transp_flag = 0;
3289   struct rxn *transp_rx = NULL;
3290   for (int ii = 0; ii &lt; num_matching_rxns; ii++) {
3291     rx = matching_rxns[ii];
3292     if (rx-&gt;n_pathways == RX_TRANSP) {
3293       is_transp_flag = 1;
3294       transp_rx = matching_rxns[ii];
3295       break;
3296     }
3297   }
3298   if ((!is_transp_flag) &amp;&amp; (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) &amp;&amp;
3299        world-&gt;rxn_flags.vol_wall_reaction_flag) {
3300     world-&gt;vol_wall_colls++;
3301   }
3302   struct periodic_image *periodic_box = m-&gt;periodic_box;
3303   if (is_transp_flag) {
3304     transp_rx-&gt;n_occurred++;
3305     if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3306       int destroy_flag = 0;
3307       count_tentative_collisions(
3308         world, tentative, smash, m, spec, smash-&gt;t, destroy_flag, periodic_box,
3309         m-&gt;id);
3310       for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
3311         *loc_certain = &amp;(ttv-&gt;loc);
3312       }
3313     }
3314 #ifdef DEBUG_TRANSPARENT_SURFACES
3315   std::cout &lt;&lt; "Crossed a transparent wall, side: " &lt;&lt; ((wall*)smash-&gt;target)-&gt;side &lt;&lt; "\n";
3316 <a name="4"></a>#endif
3317     return 0; <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  } else if (inertness &lt; inert_to_all) {
3318     for (int l = 0; l &lt; num_matching_rxns; l++) {
3319       if (matching_rxns[l]-&gt;prob_t != NULL) {</b></font>
3320         update_probs(world, matching_rxns[l], m-&gt;t);
3321       }
3322     }
3323     int jj = 0;
3324     int i = 0;
3325     if (num_matching_rxns == 1) {
3326       i = test_intersect(matching_rxns[0], r_rate_factor, world-&gt;rng);
3327       jj = 0;
3328     } else {
3329       jj = test_many_intersect(matching_rxns, r_rate_factor,
3330                                num_matching_rxns, &amp;(i), world-&gt;rng);
3331     }
3332     if ((i &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
3333       rx = matching_rxns[jj];
3334       int mflags = m-&gt;flags;
3335       int j = outcome_intersect(world, rx, i, w, (struct abstract_molecule *)m, k,
3336         m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
3337       if (j == RX_FLIP) {
3338         if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3339           int destroy_flag = 0;
3340           count_tentative_collisions(
3341             world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3342             periodic_box, m-&gt;id);
3343         }
3344         *loc_certain = &amp;(ttv-&gt;loc);
3345         *tentative = ttv;
3346         return 0;       } else if (j == RX_DESTROY) {
3347         if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3348           int destroy_flag = 1;
3349           count_tentative_collisions(
3350             world, tentative, smash, m, spec, smash-&gt;t, destroy_flag,
3351             periodic_box, m-&gt;id);
3352         }
3353         return 1;
3354       }
3355     }
3356   }
3357   return -1;
3358 }
3359 int reflect_or_periodic_bc(
3360     struct volume* world, struct collision* smash,
3361     struct vector3* displacement, struct volume_molecule** mol,
3362     struct wall** reflectee, struct collision** tentative, double* t_steps) {
3363   struct wall* w = (struct wall*)smash-&gt;target;
3364   struct wall *reflect_w = w;
3365   double reflect_t = smash-&gt;t;
3366   struct volume_molecule* vm = *mol;
3367   bool periodic_traditional = world-&gt;periodic_traditional; 
3368   ASSERT_FOR_MCELL4(!periodic_traditional);
3369   register_hits(world, vm, tentative, &amp;reflect_w, &amp;reflect_t, displacement,
3370     smash, t_steps);
3371   struct vector3 orig_pos = {vm-&gt;pos.x, vm-&gt;pos.y, vm-&gt;pos.z};
3372   (*reflectee) = reflect_w;
3373   int k = -1;
3374   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3375     k = 1;
3376   }
3377   bool periodic_x = w-&gt;parent_object-&gt;periodic_x &amp;&amp; (k == -1);
3378   bool periodic_y = w-&gt;parent_object-&gt;periodic_y &amp;&amp; (k == -1);
3379   bool periodic_z = w-&gt;parent_object-&gt;periodic_z &amp;&amp; (k == -1);
3380   double llx = 0.0;
3381   double urx = 0.0;
3382   double lly = 0.0;
3383   double ury = 0.0;
3384   double llz = 0.0;
3385   double urz = 0.0;
3386   if (periodic_x || periodic_y || periodic_z) {
3387     struct geom_object* o = w-&gt;parent_object;
3388     assert(o-&gt;object_type == BOX_OBJ);
3389     struct polygon_object* p = (struct polygon_object*)(o-&gt;contents);
3390     struct subdivided_box* sb = p-&gt;sb;
3391     llx = sb-&gt;x[0];
3392     urx = sb-&gt;x[1];
3393     lly = sb-&gt;y[0];
3394     ury = sb-&gt;y[1];
3395     llz = sb-&gt;z[0];
3396     urz = sb-&gt;z[1];
3397   }
3398   double reflectFactor = -2.0 * (displacement-&gt;x * reflect_w-&gt;normal.x +
3399     displacement-&gt;y * reflect_w-&gt;normal.y + displacement-&gt;z *
3400     reflect_w-&gt;normal.z);
3401   int box_inc_x = 0;
3402   int box_inc_y = 0;
3403   int box_inc_z = 0;
3404   double x_pos = 0;
3405   double y_pos = 0;
3406   double z_pos = 0;
3407   if (periodic_x) {
3408     int x_inc = (vm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
3409     if (!distinguishable(vm-&gt;pos.x, llx, EPS_C)) {
3410       x_pos = urx - EPS_C;
3411       box_inc_x = -x_inc;
3412     } else if (!distinguishable(vm-&gt;pos.x, urx, EPS_C)) {
3413       x_pos = llx + EPS_C;
3414       box_inc_x = x_inc;
3415     }
3416     if (periodic_traditional &amp;&amp; x_pos) {
3417       vm-&gt;pos.x = x_pos;
3418     }
3419   }
3420   if ((!periodic_x) || (periodic_x &amp;&amp; !periodic_traditional)) {
3421     displacement-&gt;x = (displacement-&gt;x + reflectFactor * reflect_w-&gt;normal.x) *
3422       (1.0 - reflect_t);
3423   }
3424   else {
3425     displacement-&gt;x *= (1.0 - reflect_t);
3426   }
3427   if (periodic_y) {
3428     int y_inc = (vm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
3429     if (!distinguishable(vm-&gt;pos.y, lly, EPS_C)) {
3430       y_pos = ury - EPS_C;
3431       box_inc_y = -y_inc;
3432     } else if (!distinguishable(vm-&gt;pos.y, ury, EPS_C)) {
3433       y_pos = lly + EPS_C;
3434       box_inc_y = y_inc;
3435     }
3436     if (periodic_traditional &amp;&amp; y_pos) {
3437       vm-&gt;pos.y = y_pos;
3438     }
3439   }
3440   if ((!periodic_y) || (periodic_y &amp;&amp; !periodic_traditional)) {
3441     displacement-&gt;y = (displacement-&gt;y + reflectFactor * reflect_w-&gt;normal.y) *
3442       (1.0 - reflect_t);
3443   }
3444   else {
3445     displacement-&gt;y *= (1.0 - reflect_t);
3446   }
3447   if (periodic_z) {
3448     int z_inc = (vm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
3449     if (!distinguishable(vm-&gt;pos.z, llz, EPS_C)) {
3450       z_pos = urz - EPS_C;
3451       box_inc_z = -z_inc;
3452     } else if (!distinguishable(vm-&gt;pos.z, urz, EPS_C)) {
3453       z_pos = llz + EPS_C;
3454       box_inc_z = z_inc;
3455     }
3456     if (periodic_traditional &amp;&amp; z_pos) {
3457       vm-&gt;pos.z =  z_pos;
3458     }
3459   }
3460   if ((!periodic_z) || (periodic_z &amp;&amp; !periodic_traditional)) {
3461     displacement-&gt;z = (displacement-&gt;z + reflectFactor * reflect_w-&gt;normal.z) *
3462       (1.0 - reflect_t);
3463   }
3464   else {
3465     displacement-&gt;z *= (1.0 - reflect_t);
3466   }
3467   if ((periodic_traditional) &amp;&amp; (periodic_x || periodic_y || periodic_z)) {
3468     (*reflectee) = NULL;
3469     struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
3470     if (nsv == NULL) {
3471       struct species* spec = vm-&gt;properties;
3472       mcell_internal_error(
3473           "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
3474           spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
3475           vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
3476     } else {
3477       if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3478         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
3479                                   -1, &amp;(orig_pos), NULL, reflect_t, NULL);
3480       }
3481       struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
3482       if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3483       count_region_from_scratch(world, (struct abstract_molecule *)new_m, NULL, 1,
3484                                 &amp;(new_m-&gt;pos), NULL, reflect_t, NULL);
3485       }
3486       *mol = new_m;
3487     }
3488     return 1;
3489   }
3490   if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
3491     (*reflectee) = NULL;
3492     struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
3493     if (nsv == NULL) {
3494       struct species* spec = vm-&gt;properties;
3495       mcell_internal_error(
3496           "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
3497           spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
3498           vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
3499     } else {
3500       if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3501         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
3502                                   -1, &amp;(orig_pos), NULL, reflect_t,
3503                                   vm-&gt;periodic_box);
3504       }
3505       struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
3506       vm-&gt;periodic_box-&gt;x += box_inc_x;
3507       vm-&gt;periodic_box-&gt;y += box_inc_y;
3508       vm-&gt;periodic_box-&gt;z += box_inc_z;
3509       if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3510         count_region_from_scratch(world, (struct abstract_molecule *)new_m,
3511                                   NULL, 1, &amp;(new_m-&gt;pos), NULL, reflect_t,
3512                                   new_m-&gt;periodic_box);
3513       }
3514       *mol = new_m;
3515     }
3516     return 1;
3517   }
3518   *mol = vm;
3519   return 0;
3520 }
3521  void register_hits(struct volume* world, struct volume_molecule* m,
3522   struct collision** tentative, struct wall** reflect_w, double* reflect_t,
3523   struct vector3* displacement, struct collision* smash, double* t_steps) {
3524   struct collision* ttv = *tentative;
3525   struct species* spec = m-&gt;properties;
3526   struct vector3 reflect_pt = smash-&gt;loc;
3527   if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3528     while (ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t &amp;&amp;
3529            !(ttv-&gt;what &amp; COLLIDE_WALL)) {
3530       ttv = ttv-&gt;next;
3531     }
3532     assert(ttv != NULL);
3533     (*reflect_w) = ((struct wall *)ttv-&gt;target);
3534     reflect_pt = ttv-&gt;loc;
3535     (*reflect_t) = ttv-&gt;t * (1 - EPS_C);
3536     for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
3537       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3538         continue;
3539       }
3540       if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
3541             COUNT_SOME_MASK)) {
3542         continue;
3543       }
3544       count_region_update(world, m, m-&gt;properties, m-&gt;id, m-&gt;periodic_box,
3545         ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3546         ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
3547       if (ttv == smash)
3548         break;
3549     }
3550   }
3551   *tentative = ttv;
3552   m-&gt;pos = reflect_pt;
3553   m-&gt;t += *t_steps * (*reflect_t);
3554   *t_steps *= (1.0 - (*reflect_t));
3555 }
3556 void collide_and_react_with_subvol(struct volume* world, struct collision *smash,
3557   struct vector3* displacement, struct volume_molecule** mol,
3558   struct collision** tentative, double* t_steps) {
3559   struct collision* ttv = *tentative;
3560   struct volume_molecule* m = *mol;
3561   struct species* spec = m-&gt;properties;
3562   if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3563     for (; ttv != NULL &amp;&amp; ttv != smash; ttv = ttv-&gt;next) {
3564       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3565         continue;
3566       }
3567       if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
3568         continue;
3569       }
3570       count_region_update(world, m, spec, m-&gt;id, m-&gt;periodic_box,
3571           ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3572           ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 1, &amp;(ttv-&gt;loc), ttv-&gt;t);
3573     }
3574   }
3575   m-&gt;pos.x = smash-&gt;loc.x;
3576   m-&gt;pos.y = smash-&gt;loc.y;
3577   m-&gt;pos.z = smash-&gt;loc.z;
3578   displacement-&gt;x *= (1.0 - smash-&gt;t);
3579   displacement-&gt;y *= (1.0 - smash-&gt;t);
3580   displacement-&gt;z *= (1.0 - smash-&gt;t);
3581   m-&gt;t += (*t_steps) * smash-&gt;t;
3582   (*t_steps) *= (1.0 - smash-&gt;t);
3583   if (*t_steps &lt; EPS_C) {
3584     *t_steps = EPS_C;
3585   }
3586   struct subvolume *nsv = traverse_subvol(
3587     m-&gt;subvol, smash-&gt;what - COLLIDE_SV_NX - COLLIDE_SUBVOL, world-&gt;ny_parts,
3588     world-&gt;nz_parts);
3589   if (nsv == NULL) {
3590     mcell_internal_error(
3591         "A %s molecule escaped the world at [%.2f, %.2f, %.2f]",
3592         spec-&gt;sym-&gt;name, m-&gt;pos.x * world-&gt;length_unit,
3593         m-&gt;pos.y * world-&gt;length_unit, m-&gt;pos.z * world-&gt;length_unit);
3594   } else {
3595     m = migrate_volume_molecule(m, nsv);
3596   }
3597   *mol = m;
3598   *tentative = ttv;
3599 }
3600 void compute_displacement(struct volume* world, struct collision* shead,
3601   struct volume_molecule* m, struct vector3* displacement,
3602   struct vector3* displacement2, double* rate_factor, double* r_rate_factor,
3603   double* steps, double* t_steps, double max_time) {
3604   struct species* spec = m-&gt;properties;
3605   if (m-&gt;flags &amp; ACT_CLAMPED) {     if (m-&gt;index &lt;= DISSOCIATION_MAX) {       pick_release_displacement(displacement, displacement2, m-&gt;get_space_step(m),
3606         world-&gt;r_step_release, world-&gt;d_step, world-&gt;radial_subdivisions,
3607         world-&gt;directions_mask, world-&gt;num_directions, world-&gt;rx_radius_3d,
3608         world-&gt;rng);
3609       *t_steps = 0;
3610     } else {       pick_clamped_displacement(displacement, m, world-&gt;r_step_surface,
3611         world-&gt;rng, world-&gt;radial_subdivisions);
3612       *t_steps = m-&gt;get_time_step(m);
3613       m-&gt;previous_wall = NULL;
3614       m-&gt;index = -1;
3615     }
3616     m-&gt;flags -= ACT_CLAMPED;
3617     *r_rate_factor = *rate_factor = 1.0;
3618     *steps = 1.0;
3619   } else {
3620     if (max_time &gt; MULTISTEP_WORTHWHILE) {
3621       *steps = safe_diffusion_step(m, shead, world-&gt;radial_subdivisions,
3622         world-&gt;r_step, world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
3623     } else {
3624       *steps = 1.0;
3625     }
3626     *t_steps = *steps * m-&gt;get_time_step(m);
3627     if (*t_steps &gt; max_time) {
3628       *t_steps = max_time;
3629       *steps = max_time / m-&gt;get_time_step(m);
3630       #ifdef MCELL3_ROUND_TSTEPS
3631         if (*t_steps &gt; 1.0 - EPS_C &amp;&amp; *t_steps &lt; 1.0 + EPS_C) {
3632           *t_steps = 1.0;
3633         }
3634         if (*steps &gt; 1.0 - EPS_C &amp;&amp; *steps &lt; 1.0 + EPS_C) {
3635           *steps = 1.0;
3636         }
3637       #endif
3638     }
3639     if (*steps &lt; EPS_C) {
3640       *steps = EPS_C;
3641       *t_steps = EPS_C * m-&gt;get_time_step(m);
3642     }
3643     if (*steps == 1.0) {
3644       pick_displacement(displacement, m-&gt;get_space_step(m), world-&gt;rng);
3645       *r_rate_factor = *rate_factor = 1.0;
3646     } else {
3647       *rate_factor = sqrt(*steps);
3648       *r_rate_factor = 1.0 / *rate_factor;
3649       pick_displacement(displacement, *rate_factor * m-&gt;get_space_step(m), world-&gt;rng);
3650     }
3651   }
3652   if (spec-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
3653     double disp_length = vect_length(displacement);
3654     if (disp_length &gt; spec-&gt;max_step_length) {
3655       displacement-&gt;x *= (spec-&gt;max_step_length / disp_length);
3656       displacement-&gt;y *= (spec-&gt;max_step_length / disp_length);
3657       displacement-&gt;z *= (spec-&gt;max_step_length / disp_length);
3658     }
3659   }
3660   world-&gt;diffusion_number++;
3661   world-&gt;diffusion_cumtime += *steps;
3662 }
3663 void determine_mol_mol_reactions(struct volume* world, struct volume_molecule* m,
3664   struct collision** shead, struct collision** stail, int inertness) {
3665   struct subvolume* sv = m-&gt;subvol;
3666   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3667   int num_matching_rxns = 0;
3668   struct species* spec = m-&gt;properties;
3669   struct per_species_list *psl_next, *psl, **psl_head = &amp;sv-&gt;species_head;
3670   for (psl = sv-&gt;species_head; psl != NULL; psl = psl_next) {
3671     psl_next = psl-&gt;next;
3672     if (psl-&gt;properties == NULL) {
3673       psl_head = &amp;psl-&gt;next;
3674       continue;
3675     }
3676     if (psl-&gt;head == NULL) {
3677       *psl_head = psl-&gt;next;
3678       ht_remove(&amp;sv-&gt;mol_by_species, psl);
3679       mem_put(sv-&gt;local_storage-&gt;pslv, psl);
3680       continue;
3681     } else
3682       psl_head = &amp;psl-&gt;next;
3683     if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3684       if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)m, 
3685                                                 (struct abstract_molecule *)psl-&gt;head)){
3686         continue;
3687       }
3688     }
3689     else{
3690       if (!trigger_bimolecular_preliminary(world-&gt;reaction_hash, world-&gt;rx_hashsize,
3691         m-&gt;properties-&gt;hashval, psl-&gt;properties-&gt;hashval, m-&gt;properties, psl-&gt;properties)) {
3692         continue;
3693       }
3694     }
3695     for (struct volume_molecule* mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
3696       if (mp == m) {
3697         continue;
3698       }
3699       if (inertness == inert_to_mol &amp;&amp; m-&gt;index == mp-&gt;index) {
3700         continue;
3701       }
3702       if (!periodic_boxes_are_identical(m-&gt;periodic_box, mp-&gt;periodic_box)) {
3703         continue;
3704       }
3705       if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3706         num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
3707           (struct abstract_molecule *)mp,0, 0, matching_rxns);
3708       } 
3709       else{
3710         num_matching_rxns = trigger_bimolecular(world-&gt;reaction_hash,
3711           world-&gt;rx_hashsize, spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
3712           (struct abstract_molecule *)m, (struct abstract_molecule *)mp, 0, 0,
3713           matching_rxns);
3714       }
3715       if (num_matching_rxns &gt; 0) {
3716         for (int i = 0; i &lt; num_matching_rxns; i++) {
3717           struct collision* smash =
3718            (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
3719             "collision data");
3720           smash-&gt;target = (void *)mp;
3721           smash-&gt;what = COLLIDE_VOL;
3722           smash-&gt;intermediate = matching_rxns[i];
3723           smash-&gt;next = *shead;
3724           *shead = smash;
3725           if (*stail == NULL)
3726             *stail = *shead;
3727         }
3728       }
3729     }
3730   }
3731 }
3732 void set_inertness_and_maxtime(
3733     struct volume* world, struct volume_molecule* m, double* max_time,
3734     int* inertness) {
3735   struct species* spec = m-&gt;properties;
3736   if (world-&gt;volume_reversibility || world-&gt;surface_reversibility) {
3737     if (world-&gt;volume_reversibility &amp;&amp;
3738 <a name="2"></a>        m-&gt;index &lt;= DISSOCIATION_MAX) {       if ((m-&gt;flags &amp; ACT_CLAMPED) != 0) {
3739         *inertness = inert_to_all;
3740 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      } else {
3741         m-&gt;index = -1;
3742       }
3743     } else if (!world-&gt;surface_reversibility) {
3744       if (m-&gt;flags &amp; ACT_CLAMPED) {         m-&gt;birthday -= 5 * m-&gt;get_time_step(m);       }
3745     }</b></font>
3746   } else {
3747     if (m-&gt;flags &amp; ACT_CLAMPED) {       m-&gt;birthday -= 5 * m-&gt;get_time_step(m);     } else if ((m-&gt;flags &amp; MATURE_MOLECULE) == 0) {
3748     #ifndef MCELL3_MOLECULE_MOVES_WITH_MAXIMUM_TIMESTEP
3749       if (m-&gt;get_time_step(m) &gt; 1.0) {
3750         double f = 1.0 + 0.2 * (m-&gt;t - m-&gt;birthday / world-&gt;time_unit);
3751         if (f &lt; 1 - EPS_C)
3752           mcell_internal_error("A %s molecule is scheduled to move before it "
3753                                "was born [birthday=%.15g, t=%.15g]",
3754                                spec-&gt;sym-&gt;name, m-&gt;birthday,
3755                                m-&gt;t * world-&gt;time_unit);
3756         if (*max_time &gt; f) {
3757           *max_time = f;
3758         }
3759         if (f &gt; m-&gt;subvol-&gt;local_storage-&gt;max_timestep) {
3760           m-&gt;flags |= MATURE_MOLECULE;
3761         }
3762       }
3763     #else
3764       m-&gt;flags |= MATURE_MOLECULE;
3765     #endif     }
3766   }
3767 }
3768 void count_tentative_collisions(
3769   struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
3770   struct species *spec, double t_confident, int destroy_flag,
3771   struct periodic_image *box, u_long id) {
3772   int crossed_flag = 1;
3773   if (destroy_flag == 1) {
3774     crossed_flag = 0; 
3775   }
3776   struct collision *ttv = *tc;
3777   for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
3778     if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3779       continue;
3780     }
3781     if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
3782       continue;
3783     }
3784     count_region_update(
3785       world, m, spec, id, box, ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3786       ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, crossed_flag,
3787       &amp;(ttv-&gt;loc), ttv-&gt;t);
3788     if ((destroy_flag) &amp;&amp; (ttv == smash)) {
3789       break;
3790     }
3791   }
3792   *tc = ttv;
3793 }
3794 bool periodicbox_in_surfmol_list(
3795     struct periodic_image *periodic_box,
3796     struct surface_molecule_list *sml) {
3797   for (struct surface_molecule_list *sml_curr = sml;
3798        sml_curr != NULL;
3799        sml_curr = sml_curr-&gt;next) {
3800     struct surface_molecule *sm = sml_curr-&gt;sm;
3801     if (sm &amp;&amp; periodic_boxes_are_identical(periodic_box, sm-&gt;periodic_box)) {
3802       return true;
3803     }
3804   }
3805   return false;
3806 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
