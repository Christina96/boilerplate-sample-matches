
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5360983102918586%, Tokens: 10</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/vp8i_enc.h"
4  #include "src/dsp/dsp.h"
5  #include "src/utils/utils.h"
6  static int DummyWriter(const uint8_t* data, size_t data_size,
7                         const WebPPicture* const picture) {
8    (void)data;
9    (void)data_size;
10    (void)picture;
11    return 1;
12  }
13  int WebPPictureInitInternal(WebPPicture* picture, int version) {
14    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_ENCODER_ABI_VERSION)) {
15      return 0;   
16    }
17    if (picture != NULL) {
18      memset(picture, 0, sizeof(*picture));
19      picture->writer = DummyWriter;
20      WebPEncodingSetError(picture, VP8_ENC_OK);
21    }
22    return 1;
23  }
24  static void WebPPictureResetBufferARGB(WebPPicture* const picture) {
25    picture->memory_argb_ = NULL;
26    picture->argb = NULL;
27    picture->argb_stride = 0;
28  }
29  static void WebPPictureResetBufferYUVA(WebPPicture* const picture) {
30    picture->memory_ = NULL;
31    picture->y = picture->u = picture->v = picture->a = NULL;
32    picture->y_stride = picture->uv_stride = 0;
33    picture->a_stride = 0;
34  }
35  void WebPPictureResetBuffers(WebPPicture* const picture) {
36    WebPPictureResetBufferARGB(picture);
37    WebPPictureResetBufferYUVA(picture);
38  }
39  int WebPPictureAllocARGB(WebPPicture* const picture, int width, int height) {
40    void* memory;
41    const uint64_t argb_size = (uint64_t)width * height;
42    assert(picture != NULL);
43    WebPSafeFree(picture->memory_argb_);
44    WebPPictureResetBufferARGB(picture);
45    if (width <= 0 || height <= 0) {
46      return WebPEncodingSetError(picture, VP8_ENC_ERROR_BAD_DIMENSION);
47    }
48    memory = WebPSafeMalloc(argb_size + WEBP_ALIGN_CST, sizeof(*picture->argb));
49    if (memory == NULL) {
50      return WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
51    }
52    picture->memory_argb_ = memory;
53    picture->argb = (uint32_t*)WEBP_ALIGN(memory);
54    picture->argb_stride = width;
55    return 1;
56  }
57  int WebPPictureAllocYUVA(WebPPicture* const picture, int width, int height) {
58    const WebPEncCSP uv_csp =
59        (WebPEncCSP)((int)picture->colorspace & WEBP_CSP_UV_MASK);
60    const int has_alpha = (int)picture->colorspace & WEBP_CSP_ALPHA_BIT;
61    const int y_stride = width;
62    const int uv_width = (int)(((int64_t)width + 1) >> 1);
63    const int uv_height = (int)(((int64_t)height + 1) >> 1);
64    const int uv_stride = uv_width;
65    int a_width, a_stride;
66    uint64_t y_size, uv_size, a_size, total_size;
67    uint8_t* mem;
68    assert(picture != NULL);
69    WebPSafeFree(picture->memory_);
70    WebPPictureResetBufferYUVA(picture);
71    if (uv_csp != WEBP_YUV420) {
72      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
73    }
74    a_width = has_alpha ? width : 0;
75    a_stride = a_width;
76    y_size = (uint64_t)y_stride * height;
77    uv_size = (uint64_t)uv_stride * uv_height;
78    a_size =  (uint64_t)a_stride * height;
79    total_size = y_size + a_size + 2 * uv_size;
80    if (width <= 0 || height <= 0 ||           
81        uv_width <= 0 || uv_height <= 0) {     
82      return WebPEncodingSetError(picture, VP8_ENC_ERROR_BAD_DIMENSION);
83    }
84    mem = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*mem));
85    if (mem == NULL) {
86      return WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
87    }
88    picture->memory_ = (void*)mem;
89    picture->y_stride  = y_stride;
90    picture->uv_stride = uv_stride;
91    picture->a_stride  = a_stride;
92    picture->y = mem;
93    mem += y_size;
94    picture->u = mem;
<span onclick='openModal()' class='match'>95    mem += uv_size;
96    picture->v = mem;
97    mem += uv_size;
98    if (a_size > 0) {
99      picture->a = mem;
100      mem += a_size;
101    }
102    (void)mem;  
103    return 1;
104  }
</span>105  int WebPPictureAlloc(WebPPicture* picture) {
106    if (picture != NULL) {
107      const int width = picture->width;
108      const int height = picture->height;
109      WebPPictureFree(picture);   
110      if (!picture->use_argb) {
111        return WebPPictureAllocYUVA(picture, width, height);
112      } else {
113        return WebPPictureAllocARGB(picture, width, height);
114      }
115    }
116    return 1;
117  }
118  void WebPPictureFree(WebPPicture* picture) {
119    if (picture != NULL) {
120      WebPSafeFree(picture->memory_);
121      WebPSafeFree(picture->memory_argb_);
122      WebPPictureResetBuffers(picture);
123    }
124  }
125  void WebPMemoryWriterInit(WebPMemoryWriter* writer) {
126    writer->mem = NULL;
127    writer->size = 0;
128    writer->max_size = 0;
129  }
130  int WebPMemoryWrite(const uint8_t* data, size_t data_size,
131                      const WebPPicture* picture) {
132    WebPMemoryWriter* const w = (WebPMemoryWriter*)picture->custom_ptr;
133    uint64_t next_size;
134    if (w == NULL) {
135      return 1;
136    }
137    next_size = (uint64_t)w->size + data_size;
138    if (next_size > w->max_size) {
139      uint8_t* new_mem;
140      uint64_t next_max_size = 2ULL * w->max_size;
141      if (next_max_size < next_size) next_max_size = next_size;
142      if (next_max_size < 8192ULL) next_max_size = 8192ULL;
143      new_mem = (uint8_t*)WebPSafeMalloc(next_max_size, 1);
144      if (new_mem == NULL) {
145        return 0;
146      }
147      if (w->size > 0) {
148        memcpy(new_mem, w->mem, w->size);
149      }
150      WebPSafeFree(w->mem);
151      w->mem = new_mem;
152      w->max_size = (size_t)next_max_size;
153    }
154    if (data_size > 0) {
155      memcpy(w->mem + w->size, data, data_size);
156      w->size += data_size;
157    }
158    return 1;
159  }
160  void WebPMemoryWriterClear(WebPMemoryWriter* writer) {
161    if (writer != NULL) {
162      WebPSafeFree(writer->mem);
163      writer->mem = NULL;
164      writer->size = 0;
165      writer->max_size = 0;
166    }
167  }
168  typedef int (*Importer)(WebPPicture* const, const uint8_t* const, int);
169  static size_t Encode(const uint8_t* rgba, int width, int height, int stride,
170                       Importer import, float quality_factor, int lossless,
171                       uint8_t** output) {
172    WebPPicture pic;
173    WebPConfig config;
174    WebPMemoryWriter wrt;
175    int ok;
176    if (output == NULL) return 0;
177    if (!WebPConfigPreset(&config, WEBP_PRESET_DEFAULT, quality_factor) ||
178        !WebPPictureInit(&pic)) {
179      return 0;  
180    }
181    config.lossless = !!lossless;
182    pic.use_argb = !!lossless;
183    pic.width = width;
184    pic.height = height;
185    pic.writer = WebPMemoryWrite;
186    pic.custom_ptr = &wrt;
187    WebPMemoryWriterInit(&wrt);
188    ok = import(&pic, rgba, stride) && WebPEncode(&config, &pic);
189    WebPPictureFree(&pic);
190    if (!ok) {
191      WebPMemoryWriterClear(&wrt);
192      *output = NULL;
193      return 0;
194    }
195    *output = wrt.mem;
196    return wrt.size;
197  }
198  #define ENCODE_FUNC(NAME, IMPORTER)                                     \
199  size_t NAME(const uint8_t* in, int w, int h, int bps, float q,          \
200              uint8_t** out) {                                            \
201    return Encode(in, w, h, bps, IMPORTER, q, 0, out);                    \
202  }
203  ENCODE_FUNC(WebPEncodeRGB, WebPPictureImportRGB)
204  ENCODE_FUNC(WebPEncodeRGBA, WebPPictureImportRGBA)
205  #if !defined(WEBP_REDUCE_CSP)
206  ENCODE_FUNC(WebPEncodeBGR, WebPPictureImportBGR)
207  ENCODE_FUNC(WebPEncodeBGRA, WebPPictureImportBGRA)
208  #endif  
209  #undef ENCODE_FUNC
210  #define LOSSLESS_DEFAULT_QUALITY 70.
211  #define LOSSLESS_ENCODE_FUNC(NAME, IMPORTER)                                 \
212  size_t NAME(const uint8_t* in, int w, int h, int bps, uint8_t** out) {       \
213    return Encode(in, w, h, bps, IMPORTER, LOSSLESS_DEFAULT_QUALITY, 1, out);  \
214  }
215  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessRGB, WebPPictureImportRGB)
216  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessRGBA, WebPPictureImportRGBA)
217  #if !defined(WEBP_REDUCE_CSP)
218  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessBGR, WebPPictureImportBGR)
219  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessBGRA, WebPPictureImportBGRA)
220  #endif  
221  #undef LOSSLESS_ENCODE_FUNC
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_enc.c</h3>
            <pre><code>1  #include <string.h>
2  #include <math.h>
3  #include "src/enc/cost_enc.h"
4  #include "src/enc/vp8i_enc.h"
5  #include "src/dsp/dsp.h"
6  #include "src/webp/format_constants.h"  
7  #define SEGMENT_VISU 0
8  #define DEBUG_SEARCH 0    
9  #define HEADER_SIZE_ESTIMATE (RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE +  \
10                                VP8_FRAME_HEADER_SIZE)
11  #define DQ_LIMIT 0.4  
12  #define PARTITION0_SIZE_LIMIT ((VP8_MAX_PARTITION0_SIZE - 2048ULL) << 11)
13  typedef struct {  
14    int is_first;
15    float dq;
16    float q, last_q;
17    double value, last_value;   
18    double target;
19    int do_size_search;
20  } PassStats;
21  static int InitPassStats(const VP8Encoder* const enc, PassStats* const s) {
22    const uint64_t target_size = (uint64_t)enc->config_->target_size;
23    const int do_size_search = (target_size != 0);
24    const float target_PSNR = enc->config_->target_PSNR;
25    s->is_first = 1;
26    s->dq = 10.f;
27    s->q = s->last_q = enc->config_->quality;
28    s->target = do_size_search ? (double)target_size
29              : (target_PSNR > 0.) ? target_PSNR
30              : 40.;   
31    s->value = s->last_value = 0.;
32    s->do_size_search = do_size_search;
33    return do_size_search;
34  }
35  static float Clamp(float v, float min, float max) {
36    return (v < min) ? min : (v > max) ? max : v;
37  }
38  static float ComputeNextQ(PassStats* const s) {
39    float dq;
40    if (s->is_first) {
41      dq = (s->value > s->target) ? -s->dq : s->dq;
42      s->is_first = 0;
43    } else if (s->value != s->last_value) {
44      const double slope = (s->target - s->value) / (s->last_value - s->value);
45      dq = (float)(slope * (s->last_q - s->q));
46    } else {
47      dq = 0.;  
48    }
49    s->dq = Clamp(dq, -30.f, 30.f);
50    s->last_q = s->q;
51    s->last_value = s->value;
52    s->q = Clamp(s->q + s->dq, 0.f, 100.f);
53    return s->q;
54  }
55  const uint8_t VP8Cat3[] = { 173, 148, 140 };
56  const uint8_t VP8Cat4[] = { 176, 155, 140, 135 };
57  const uint8_t VP8Cat5[] = { 180, 157, 141, 134, 130 };
58  const uint8_t VP8Cat6[] =
59      { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129 };
60  static void ResetStats(VP8Encoder* const enc) {
61    VP8EncProba* const proba = &enc->proba_;
62    VP8CalculateLevelCosts(proba);
63    proba->nb_skip_ = 0;
64  }
65  #define SKIP_PROBA_THRESHOLD 250  
66  static int CalcSkipProba(uint64_t nb, uint64_t total) {
67    return (int)(total ? (total - nb) * 255 / total : 255);
68  }
69  static int FinalizeSkipProba(VP8Encoder* const enc) {
70    VP8EncProba* const proba = &enc->proba_;
71    const int nb_mbs = enc->mb_w_ * enc->mb_h_;
72    const int nb_events = proba->nb_skip_;
73    int size;
<span onclick='openModal()' class='match'>74    proba->skip_proba_ = CalcSkipProba(nb_events, nb_mbs);
75    proba->use_skip_proba_ = (proba->skip_proba_ < SKIP_PROBA_THRESHOLD);
76    size = 256;   
77    if (proba->use_skip_proba_) {
78      size +=  nb_events * VP8BitCost(1, proba->skip_proba_)
79           + (nb_mbs - nb_events) * VP8BitCost(0, proba->skip_proba_);
80      size += 8 * 256;   
81    }
82    return size;
83  }
</span>84  static int CalcTokenProba(int nb, int total) {
85    assert(nb <= total);
86    return nb ? (255 - nb * 255 / total) : 255;
87  }
88  static int BranchCost(int nb, int total, int proba) {
89    return nb * VP8BitCost(1, proba) + (total - nb) * VP8BitCost(0, proba);
90  }
91  static void ResetTokenStats(VP8Encoder* const enc) {
92    VP8EncProba* const proba = &enc->proba_;
93    memset(proba->stats_, 0, sizeof(proba->stats_));
94  }
95  static int FinalizeTokenProbas(VP8EncProba* const proba) {
96    int has_changed = 0;
97    int size = 0;
98    int t, b, c, p;
99    for (t = 0; t < NUM_TYPES; ++t) {
100      for (b = 0; b < NUM_BANDS; ++b) {
101        for (c = 0; c < NUM_CTX; ++c) {
102          for (p = 0; p < NUM_PROBAS; ++p) {
103            const proba_t stats = proba->stats_[t][b][c][p];
104            const int nb = (stats >> 0) & 0xffff;
105            const int total = (stats >> 16) & 0xffff;
106            const int update_proba = VP8CoeffsUpdateProba[t][b][c][p];
107            const int old_p = VP8CoeffsProba0[t][b][c][p];
108            const int new_p = CalcTokenProba(nb, total);
109            const int old_cost = BranchCost(nb, total, old_p)
110                               + VP8BitCost(0, update_proba);
111            const int new_cost = BranchCost(nb, total, new_p)
112                               + VP8BitCost(1, update_proba)
113                               + 8 * 256;
114            const int use_new_p = (old_cost > new_cost);
115            size += VP8BitCost(use_new_p, update_proba);
116            if (use_new_p) {  
117              proba->coeffs_[t][b][c][p] = new_p;
118              has_changed |= (new_p != old_p);
119              size += 8 * 256;
120            } else {
121              proba->coeffs_[t][b][c][p] = old_p;
122            }
123          }
124        }
125      }
126    }
127    proba->dirty_ = has_changed;
128    return size;
129  }
130  static int GetProba(int a, int b) {
131    const int total = a + b;
132    return (total == 0) ? 255     
133                        : (255 * a + total / 2) / total;  
134  }
135  static void ResetSegments(VP8Encoder* const enc) {
136    int n;
137    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
138      enc->mb_info_[n].segment_ = 0;
139    }
140  }
141  static void SetSegmentProbas(VP8Encoder* const enc) {
142    int p[NUM_MB_SEGMENTS] = { 0 };
143    int n;
144    for (n = 0; n < enc->mb_w_ * enc->mb_h_; ++n) {
145      const VP8MBInfo* const mb = &enc->mb_info_[n];
146      ++p[mb->segment_];
147    }
148  #if !defined(WEBP_DISABLE_STATS)
149    if (enc->pic_->stats != NULL) {
150      for (n = 0; n < NUM_MB_SEGMENTS; ++n) {
151        enc->pic_->stats->segment_size[n] = p[n];
152      }
153    }
154  #endif
155    if (enc->segment_hdr_.num_segments_ > 1) {
156      uint8_t* const probas = enc->proba_.segments_;
157      probas[0] = GetProba(p[0] + p[1], p[2] + p[3]);
158      probas[1] = GetProba(p[0], p[1]);
159      probas[2] = GetProba(p[2], p[3]);
160      enc->segment_hdr_.update_map_ =
161          (probas[0] != 255) || (probas[1] != 255) || (probas[2] != 255);
162      if (!enc->segment_hdr_.update_map_) ResetSegments(enc);
163      enc->segment_hdr_.size_ =
164          p[0] * (VP8BitCost(0, probas[0]) + VP8BitCost(0, probas[1])) +
165          p[1] * (VP8BitCost(0, probas[0]) + VP8BitCost(1, probas[1])) +
166          p[2] * (VP8BitCost(1, probas[0]) + VP8BitCost(0, probas[2])) +
167          p[3] * (VP8BitCost(1, probas[0]) + VP8BitCost(1, probas[2]));
168    } else {
169      enc->segment_hdr_.update_map_ = 0;
170      enc->segment_hdr_.size_ = 0;
171    }
172  }
173  static int PutCoeffs(VP8BitWriter* const bw, int ctx, const VP8Residual* res) {
174    int n = res->first;
175    const uint8_t* p = res->prob[n][ctx];
176    if (!VP8PutBit(bw, res->last >= 0, p[0])) {
177      return 0;
178    }
179    while (n < 16) {
180      const int c = res->coeffs[n++];
181      const int sign = c < 0;
182      int v = sign ? -c : c;
183      if (!VP8PutBit(bw, v != 0, p[1])) {
184        p = res->prob[VP8EncBands[n]][0];
185        continue;
186      }
187      if (!VP8PutBit(bw, v > 1, p[2])) {
188        p = res->prob[VP8EncBands[n]][1];
189      } else {
190        if (!VP8PutBit(bw, v > 4, p[3])) {
191          if (VP8PutBit(bw, v != 2, p[4])) {
192            VP8PutBit(bw, v == 4, p[5]);
193          }
194        } else if (!VP8PutBit(bw, v > 10, p[6])) {
195          if (!VP8PutBit(bw, v > 6, p[7])) {
196            VP8PutBit(bw, v == 6, 159);
197          } else {
198            VP8PutBit(bw, v >= 9, 165);
199            VP8PutBit(bw, !(v & 1), 145);
200          }
201        } else {
202          int mask;
203          const uint8_t* tab;
204          if (v < 3 + (8 << 1)) {          
205            VP8PutBit(bw, 0, p[8]);
206            VP8PutBit(bw, 0, p[9]);
207            v -= 3 + (8 << 0);
208            mask = 1 << 2;
209            tab = VP8Cat3;
210          } else if (v < 3 + (8 << 2)) {   
211            VP8PutBit(bw, 0, p[8]);
212            VP8PutBit(bw, 1, p[9]);
213            v -= 3 + (8 << 1);
214            mask = 1 << 3;
215            tab = VP8Cat4;
216          } else if (v < 3 + (8 << 3)) {   
217            VP8PutBit(bw, 1, p[8]);
218            VP8PutBit(bw, 0, p[10]);
219            v -= 3 + (8 << 2);
220            mask = 1 << 4;
221            tab = VP8Cat5;
222          } else {                         
223            VP8PutBit(bw, 1, p[8]);
224            VP8PutBit(bw, 1, p[10]);
225            v -= 3 + (8 << 3);
226            mask = 1 << 10;
227            tab = VP8Cat6;
228          }
229          while (mask) {
230            VP8PutBit(bw, !!(v & mask), *tab++);
231            mask >>= 1;
232          }
233        }
234        p = res->prob[VP8EncBands[n]][2];
235      }
236      VP8PutBitUniform(bw, sign);
237      if (n == 16 || !VP8PutBit(bw, n <= res->last, p[0])) {
238        return 1;   
239      }
240    }
241    return 1;
242  }
243  static void CodeResiduals(VP8BitWriter* const bw, VP8EncIterator* const it,
244                            const VP8ModeScore* const rd) {
245    int x, y, ch;
246    VP8Residual res;
247    uint64_t pos1, pos2, pos3;
248    const int i16 = (it->mb_->type_ == 1);
249    const int segment = it->mb_->segment_;
250    VP8Encoder* const enc = it->enc_;
251    VP8IteratorNzToBytes(it);
252    pos1 = VP8BitWriterPos(bw);
253    if (i16) {
254      VP8InitResidual(0, 1, enc, &res);
255      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
256      it->top_nz_[8] = it->left_nz_[8] =
257        PutCoeffs(bw, it->top_nz_[8] + it->left_nz_[8], &res);
258      VP8InitResidual(1, 0, enc, &res);
259    } else {
260      VP8InitResidual(0, 3, enc, &res);
261    }
262    for (y = 0; y < 4; ++y) {
263      for (x = 0; x < 4; ++x) {
264        const int ctx = it->top_nz_[x] + it->left_nz_[y];
265        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
266        it->top_nz_[x] = it->left_nz_[y] = PutCoeffs(bw, ctx, &res);
267      }
268    }
269    pos2 = VP8BitWriterPos(bw);
270    VP8InitResidual(0, 2, enc, &res);
271    for (ch = 0; ch <= 2; ch += 2) {
272      for (y = 0; y < 2; ++y) {
273        for (x = 0; x < 2; ++x) {
274          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
275          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
276          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
277              PutCoeffs(bw, ctx, &res);
278        }
279      }
280    }
281    pos3 = VP8BitWriterPos(bw);
282    it->luma_bits_ = pos2 - pos1;
283    it->uv_bits_ = pos3 - pos2;
284    it->bit_count_[segment][i16] += it->luma_bits_;
285    it->bit_count_[segment][2] += it->uv_bits_;
286    VP8IteratorBytesToNz(it);
287  }
288  static void RecordResiduals(VP8EncIterator* const it,
289                              const VP8ModeScore* const rd) {
290    int x, y, ch;
291    VP8Residual res;
292    VP8Encoder* const enc = it->enc_;
293    VP8IteratorNzToBytes(it);
294    if (it->mb_->type_ == 1) {   
295      VP8InitResidual(0, 1, enc, &res);
296      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
297      it->top_nz_[8] = it->left_nz_[8] =
298        VP8RecordCoeffs(it->top_nz_[8] + it->left_nz_[8], &res);
299      VP8InitResidual(1, 0, enc, &res);
300    } else {
301      VP8InitResidual(0, 3, enc, &res);
302    }
303    for (y = 0; y < 4; ++y) {
304      for (x = 0; x < 4; ++x) {
305        const int ctx = it->top_nz_[x] + it->left_nz_[y];
306        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
307        it->top_nz_[x] = it->left_nz_[y] = VP8RecordCoeffs(ctx, &res);
308      }
309    }
310    VP8InitResidual(0, 2, enc, &res);
311    for (ch = 0; ch <= 2; ch += 2) {
312      for (y = 0; y < 2; ++y) {
313        for (x = 0; x < 2; ++x) {
314          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
315          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
316          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
317              VP8RecordCoeffs(ctx, &res);
318        }
319      }
320    }
321    VP8IteratorBytesToNz(it);
322  }
323  #if !defined(DISABLE_TOKEN_BUFFER)
324  static int RecordTokens(VP8EncIterator* const it, const VP8ModeScore* const rd,
325                          VP8TBuffer* const tokens) {
326    int x, y, ch;
327    VP8Residual res;
328    VP8Encoder* const enc = it->enc_;
329    VP8IteratorNzToBytes(it);
330    if (it->mb_->type_ == 1) {   
331      const int ctx = it->top_nz_[8] + it->left_nz_[8];
332      VP8InitResidual(0, 1, enc, &res);
333      VP8SetResidualCoeffs(rd->y_dc_levels, &res);
334      it->top_nz_[8] = it->left_nz_[8] =
335          VP8RecordCoeffTokens(ctx, &res, tokens);
336      VP8InitResidual(1, 0, enc, &res);
337    } else {
338      VP8InitResidual(0, 3, enc, &res);
339    }
340    for (y = 0; y < 4; ++y) {
341      for (x = 0; x < 4; ++x) {
342        const int ctx = it->top_nz_[x] + it->left_nz_[y];
343        VP8SetResidualCoeffs(rd->y_ac_levels[x + y * 4], &res);
344        it->top_nz_[x] = it->left_nz_[y] =
345            VP8RecordCoeffTokens(ctx, &res, tokens);
346      }
347    }
348    VP8InitResidual(0, 2, enc, &res);
349    for (ch = 0; ch <= 2; ch += 2) {
350      for (y = 0; y < 2; ++y) {
351        for (x = 0; x < 2; ++x) {
352          const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
353          VP8SetResidualCoeffs(rd->uv_levels[ch * 2 + x + y * 2], &res);
354          it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] =
355              VP8RecordCoeffTokens(ctx, &res, tokens);
356        }
357      }
358    }
359    VP8IteratorBytesToNz(it);
360    return !tokens->error_;
361  }
362  #endif    
363  #if !defined(WEBP_DISABLE_STATS)
364  #if SEGMENT_VISU
365  static void SetBlock(uint8_t* p, int value, int size) {
366    int y;
367    for (y = 0; y < size; ++y) {
368      memset(p, value, size);
369      p += BPS;
370    }
371  }
372  #endif
373  static void ResetSSE(VP8Encoder* const enc) {
374    enc->sse_[0] = 0;
375    enc->sse_[1] = 0;
376    enc->sse_[2] = 0;
377    enc->sse_count_ = 0;
378  }
379  static void StoreSSE(const VP8EncIterator* const it) {
380    VP8Encoder* const enc = it->enc_;
381    const uint8_t* const in = it->yuv_in_;
382    const uint8_t* const out = it->yuv_out_;
383    enc->sse_[0] += VP8SSE16x16(in + Y_OFF_ENC, out + Y_OFF_ENC);
384    enc->sse_[1] += VP8SSE8x8(in + U_OFF_ENC, out + U_OFF_ENC);
385    enc->sse_[2] += VP8SSE8x8(in + V_OFF_ENC, out + V_OFF_ENC);
386    enc->sse_count_ += 16 * 16;
387  }
388  static void StoreSideInfo(const VP8EncIterator* const it) {
389    VP8Encoder* const enc = it->enc_;
390    const VP8MBInfo* const mb = it->mb_;
391    WebPPicture* const pic = enc->pic_;
392    if (pic->stats != NULL) {
393      StoreSSE(it);
394      enc->block_count_[0] += (mb->type_ == 0);
395      enc->block_count_[1] += (mb->type_ == 1);
396      enc->block_count_[2] += (mb->skip_ != 0);
397    }
398    if (pic->extra_info != NULL) {
399      uint8_t* const info = &pic->extra_info[it->x_ + it->y_ * enc->mb_w_];
400      switch (pic->extra_info_type) {
401        case 1: *info = mb->type_; break;
402        case 2: *info = mb->segment_; break;
403        case 3: *info = enc->dqm_[mb->segment_].quant_; break;
404        case 4: *info = (mb->type_ == 1) ? it->preds_[0] : 0xff; break;
405        case 5: *info = mb->uv_mode_; break;
406        case 6: {
407          const int b = (int)((it->luma_bits_ + it->uv_bits_ + 7) >> 3);
408          *info = (b > 255) ? 255 : b; break;
409        }
410        case 7: *info = mb->alpha_; break;
411        default: *info = 0; break;
412      }
413    }
414  #if SEGMENT_VISU  
415    SetBlock(it->yuv_out_ + Y_OFF_ENC, mb->segment_ * 64, 16);
416    SetBlock(it->yuv_out_ + U_OFF_ENC, it->preds_[0] * 64, 8);
417    SetBlock(it->yuv_out_ + V_OFF_ENC, mb->uv_mode_ * 64, 8);
418  #endif
419  }
420  static void ResetSideInfo(const VP8EncIterator* const it) {
421    VP8Encoder* const enc = it->enc_;
422    WebPPicture* const pic = enc->pic_;
423    if (pic->stats != NULL) {
424      memset(enc->block_count_, 0, sizeof(enc->block_count_));
425    }
426    ResetSSE(enc);
427  }
428  #else  
429  static void ResetSSE(VP8Encoder* const enc) {
430    (void)enc;
431  }
432  static void StoreSideInfo(const VP8EncIterator* const it) {
433    VP8Encoder* const enc = it->enc_;
434    WebPPicture* const pic = enc->pic_;
435    if (pic->extra_info != NULL) {
436      if (it->x_ == 0 && it->y_ == 0) {   
437        memset(pic->extra_info, 0,
438               enc->mb_w_ * enc->mb_h_ * sizeof(*pic->extra_info));
439      }
440    }
441  }
442  static void ResetSideInfo(const VP8EncIterator* const it) {
443    (void)it;
444  }
445  #endif  
446  static double GetPSNR(uint64_t mse, uint64_t size) {
447    return (mse > 0 && size > 0) ? 10. * log10(255. * 255. * size / mse) : 99;
448  }
449  static void SetLoopParams(VP8Encoder* const enc, float q) {
450    q = Clamp(q, 0.f, 100.f);
451    VP8SetSegmentParams(enc, q);      
452    SetSegmentProbas(enc);            
453    ResetStats(enc);
454    ResetSSE(enc);
455  }
456  static uint64_t OneStatPass(VP8Encoder* const enc, VP8RDLevel rd_opt,
457                              int nb_mbs, int percent_delta,
458                              PassStats* const s) {
459    VP8EncIterator it;
460    uint64_t size = 0;
461    uint64_t size_p0 = 0;
462    uint64_t distortion = 0;
463    const uint64_t pixel_count = nb_mbs * 384;
464    VP8IteratorInit(enc, &it);
465    SetLoopParams(enc, s->q);
466    do {
467      VP8ModeScore info;
468      VP8IteratorImport(&it, NULL);
469      if (VP8Decimate(&it, &info, rd_opt)) {
470        ++enc->proba_.nb_skip_;
471      }
472      RecordResiduals(&it, &info);
473      size += info.R + info.H;
474      size_p0 += info.H;
475      distortion += info.D;
476      if (percent_delta && !VP8IteratorProgress(&it, percent_delta)) {
477        return 0;
478      }
479      VP8IteratorSaveBoundary(&it);
480    } while (VP8IteratorNext(&it) && --nb_mbs > 0);
481    size_p0 += enc->segment_hdr_.size_;
482    if (s->do_size_search) {
483      size += FinalizeSkipProba(enc);
484      size += FinalizeTokenProbas(&enc->proba_);
485      size = ((size + size_p0 + 1024) >> 11) + HEADER_SIZE_ESTIMATE;
486      s->value = (double)size;
487    } else {
488      s->value = GetPSNR(distortion, pixel_count);
489    }
490    return size_p0;
491  }
492  static int StatLoop(VP8Encoder* const enc) {
493    const int method = enc->method_;
494    const int do_search = enc->do_search_;
495    const int fast_probe = ((method == 0 || method == 3) && !do_search);
496    int num_pass_left = enc->config_->pass;
497    const int task_percent = 20;
498    const int percent_per_pass =
499        (task_percent + num_pass_left / 2) / num_pass_left;
500    const int final_percent = enc->percent_ + task_percent;
501    const VP8RDLevel rd_opt =
502        (method >= 3 || do_search) ? RD_OPT_BASIC : RD_OPT_NONE;
503    int nb_mbs = enc->mb_w_ * enc->mb_h_;
504    PassStats stats;
505    InitPassStats(enc, &stats);
506    ResetTokenStats(enc);
507    if (fast_probe) {
508      if (method == 3) {  
509        nb_mbs = (nb_mbs > 200) ? nb_mbs >> 1 : 100;
510      } else {
511        nb_mbs = (nb_mbs > 200) ? nb_mbs >> 2 : 50;
512      }
513    }
514    while (num_pass_left-- > 0) {
515      const int is_last_pass = (fabs(stats.dq) <= DQ_LIMIT) ||
516                               (num_pass_left == 0) ||
517                               (enc->max_i4_header_bits_ == 0);
518      const uint64_t size_p0 =
519          OneStatPass(enc, rd_opt, nb_mbs, percent_per_pass, &stats);
520      if (size_p0 == 0) return 0;
521  #if (DEBUG_SEARCH > 0)
522      printf("#%d value:%.1lf -> %.1lf   q:%.2f -> %.2f\n",
523             num_pass_left, stats.last_value, stats.value, stats.last_q, stats.q);
524  #endif
525      if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
526        ++num_pass_left;
527        enc->max_i4_header_bits_ >>= 1;  
528        continue;                        
529      }
530      if (is_last_pass) {
531        break;
532      }
533      if (do_search) {
534        ComputeNextQ(&stats);
535        if (fabs(stats.dq) <= DQ_LIMIT) break;
536      }
537    }
538    if (!do_search || !stats.do_size_search) {
539      FinalizeSkipProba(enc);
540      FinalizeTokenProbas(&enc->proba_);
541    }
542    VP8CalculateLevelCosts(&enc->proba_);  
543    return WebPReportProgress(enc->pic_, final_percent, &enc->percent_);
544  }
545  static const uint8_t kAverageBytesPerMB[8] = { 50, 24, 16, 9, 7, 5, 3, 2 };
546  static int PreLoopInitialize(VP8Encoder* const enc) {
547    int p;
548    int ok = 1;
549    const int average_bytes_per_MB = kAverageBytesPerMB[enc->base_quant_ >> 4];
550    const int bytes_per_parts =
551        enc->mb_w_ * enc->mb_h_ * average_bytes_per_MB / enc->num_parts_;
552    for (p = 0; ok && p < enc->num_parts_; ++p) {
553      ok = VP8BitWriterInit(enc->parts_ + p, bytes_per_parts);
554    }
555    if (!ok) {
556      VP8EncFreeBitWriters(enc);  
557      WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
558    }
559    return ok;
560  }
561  static int PostLoopFinalize(VP8EncIterator* const it, int ok) {
562    VP8Encoder* const enc = it->enc_;
563    if (ok) {      
564      int p;
565      for (p = 0; p < enc->num_parts_; ++p) {
566        VP8BitWriterFinish(enc->parts_ + p);
567        ok &= !enc->parts_[p].error_;
568      }
569    }
570    if (ok) {      
571  #if !defined(WEBP_DISABLE_STATS)
572      if (enc->pic_->stats != NULL) {  
573        int i, s;
574        for (i = 0; i <= 2; ++i) {
575          for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
576            enc->residual_bytes_[i][s] = (int)((it->bit_count_[s][i] + 7) >> 3);
577          }
578        }
579      }
580  #endif
581      VP8AdjustFilterStrength(it);     
582    } else {
583      VP8EncFreeBitWriters(enc);
584    }
585    return ok;
586  }
587  static void ResetAfterSkip(VP8EncIterator* const it) {
588    if (it->mb_->type_ == 1) {
589      *it->nz_ = 0;  
590      it->left_nz_[8] = 0;
591    } else {
592      *it->nz_ &= (1 << 24);  
593    }
594  }
595  int VP8EncLoop(VP8Encoder* const enc) {
596    VP8EncIterator it;
597    int ok = PreLoopInitialize(enc);
598    if (!ok) return 0;
599    StatLoop(enc);  
600    VP8IteratorInit(enc, &it);
601    VP8InitFilter(&it);
602    do {
603      VP8ModeScore info;
604      const int dont_use_skip = !enc->proba_.use_skip_proba_;
605      const VP8RDLevel rd_opt = enc->rd_opt_level_;
606      VP8IteratorImport(&it, NULL);
607      if (!VP8Decimate(&it, &info, rd_opt) || dont_use_skip) {
608        CodeResiduals(it.bw_, &it, &info);
609      } else {   
610        ResetAfterSkip(&it);
611      }
612      StoreSideInfo(&it);
613      VP8StoreFilterStats(&it);
614      VP8IteratorExport(&it);
615      ok = VP8IteratorProgress(&it, 20);
616      VP8IteratorSaveBoundary(&it);
617    } while (ok && VP8IteratorNext(&it));
618    return PostLoopFinalize(&it, ok);
619  }
620  #if !defined(DISABLE_TOKEN_BUFFER)
621  #define MIN_COUNT 96  
622  int VP8EncTokenLoop(VP8Encoder* const enc) {
623    int max_count = (enc->mb_w_ * enc->mb_h_) >> 3;
624    int num_pass_left = enc->config_->pass;
625    const int do_search = enc->do_search_;
626    VP8EncIterator it;
627    VP8EncProba* const proba = &enc->proba_;
628    const VP8RDLevel rd_opt = enc->rd_opt_level_;
629    const uint64_t pixel_count = enc->mb_w_ * enc->mb_h_ * 384;
630    PassStats stats;
631    int ok;
632    InitPassStats(enc, &stats);
633    ok = PreLoopInitialize(enc);
634    if (!ok) return 0;
635    if (max_count < MIN_COUNT) max_count = MIN_COUNT;
636    assert(enc->num_parts_ == 1);
637    assert(enc->use_tokens_);
638    assert(proba->use_skip_proba_ == 0);
639    assert(rd_opt >= RD_OPT_BASIC);   
640    assert(num_pass_left > 0);
641    while (ok && num_pass_left-- > 0) {
642      const int is_last_pass = (fabs(stats.dq) <= DQ_LIMIT) ||
643                               (num_pass_left == 0) ||
644                               (enc->max_i4_header_bits_ == 0);
645      uint64_t size_p0 = 0;
646      uint64_t distortion = 0;
647      int cnt = max_count;
648      VP8IteratorInit(enc, &it);
649      SetLoopParams(enc, stats.q);
650      if (is_last_pass) {
651        ResetTokenStats(enc);
652        VP8InitFilter(&it);  
653      }
654      VP8TBufferClear(&enc->tokens_);
655      do {
656        VP8ModeScore info;
657        VP8IteratorImport(&it, NULL);
658        if (--cnt < 0) {
659          FinalizeTokenProbas(proba);
660          VP8CalculateLevelCosts(proba);  
661          cnt = max_count;
662        }
663        VP8Decimate(&it, &info, rd_opt);
664        ok = RecordTokens(&it, &info, &enc->tokens_);
665        if (!ok) {
666          WebPEncodingSetError(enc->pic_, VP8_ENC_ERROR_OUT_OF_MEMORY);
667          break;
668        }
669        size_p0 += info.H;
670        distortion += info.D;
671        if (is_last_pass) {
672          StoreSideInfo(&it);
673          VP8StoreFilterStats(&it);
674          VP8IteratorExport(&it);
675          ok = VP8IteratorProgress(&it, 20);
676        }
677        VP8IteratorSaveBoundary(&it);
678      } while (ok && VP8IteratorNext(&it));
679      if (!ok) break;
680      size_p0 += enc->segment_hdr_.size_;
681      if (stats.do_size_search) {
682        uint64_t size = FinalizeTokenProbas(&enc->proba_);
683        size += VP8EstimateTokenSize(&enc->tokens_,
684                                     (const uint8_t*)proba->coeffs_);
685        size = (size + size_p0 + 1024) >> 11;  
686        size += HEADER_SIZE_ESTIMATE;
687        stats.value = (double)size;
688      } else {  
689        stats.value = GetPSNR(distortion, pixel_count);
690      }
691  #if (DEBUG_SEARCH > 0)
692      printf("#%2d metric:%.1lf -> %.1lf   last_q=%.2lf q=%.2lf dq=%.2lf\n",
693             num_pass_left, stats.last_value, stats.value,
694             stats.last_q, stats.q, stats.dq);
695  #endif
696      if (enc->max_i4_header_bits_ > 0 && size_p0 > PARTITION0_SIZE_LIMIT) {
697        ++num_pass_left;
698        enc->max_i4_header_bits_ >>= 1;  
699        if (is_last_pass) {
700          ResetSideInfo(&it);
701        }
702        continue;                        
703      }
704      if (is_last_pass) {
705        break;   
706      }
707      if (do_search) {
708        ComputeNextQ(&stats);  
709      }
710    }
711    if (ok) {
712      if (!stats.do_size_search) {
713        FinalizeTokenProbas(&enc->proba_);
714      }
715      ok = VP8EmitTokens(&enc->tokens_, enc->parts_ + 0,
716                         (const uint8_t*)proba->coeffs_, 1);
717    }
718    ok = ok && WebPReportProgress(enc->pic_, enc->percent_ + 20, &enc->percent_);
719    return PostLoopFinalize(&it, ok);
720  }
721  #else
722  int VP8EncTokenLoop(VP8Encoder* const enc) {
723    (void)enc;
724    return 0;   
725  }
726  #endif    
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_enc.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_enc.c</div>
                <div class="column column_space"><pre><code>95    mem += uv_size;
96    picture->v = mem;
97    mem += uv_size;
98    if (a_size > 0) {
99      picture->a = mem;
100      mem += a_size;
101    }
102    (void)mem;  
103    return 1;
104  }
</pre></code></div>
                <div class="column column_space"><pre><code>74    proba->skip_proba_ = CalcSkipProba(nb_events, nb_mbs);
75    proba->use_skip_proba_ = (proba->skip_proba_ < SKIP_PROBA_THRESHOLD);
76    size = 256;   
77    if (proba->use_skip_proba_) {
78      size +=  nb_events * VP8BitCost(1, proba->skip_proba_)
79           + (nb_mbs - nb_events) * VP8BitCost(0, proba->skip_proba_);
80      size += 8 * 256;   
81    }
82    return size;
83  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    