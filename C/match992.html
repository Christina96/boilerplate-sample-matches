<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-test-text-recover.c &amp; inf-test-mass-join.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-text-recover.c &amp; inf-test-mass-join.c
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-text-recover.c (17.777779%)<th>inf-test-mass-join.c (7.6923075%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(47-79)<td><a href="#" name="0">(52-84)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-recover.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-session-replay.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

static void
inf_test_util_print_buffer(InfTextBuffer* buffer)
{
  InfTextChunk* chunk;
  gchar* text;
  gsize bytes;

  chunk = inf_text_buffer_get_slice(
    buffer,
    0,
    inf_text_buffer_get_length(buffer)
  );

  text = inf_text_chunk_get_text(chunk, &amp;bytes);
  inf_text_chunk_free(chunk);
<a name="0"></a>
  printf("%.*s\n", (int)bytes, text);
  g_free(text);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static InfSession*
inf_test_text_recover_session_new(InfIo* io,
                                  InfCommunicationManager* manager,
                                  InfSessionStatus status,
                                  InfCommunicationGroup* sync_group,
                                  InfXmlConnection* sync_connection,
                                  const gchar* path,
                                  gpointer user_data)
{
  InfTextDefaultBuffer* buffer;
  InfTextSession* session;

  buffer = inf_text_default_buffer_new("UTF-8");
  session = inf_text_session_new(
    manager,
    INF_TEXT_BUFFER(buffer),
    io,
    status,
    sync_group,
    sync_connection
  );
  g_object_unref(buffer);

  return INF_SESSION(session);
}

static const InfcNotePlugin INF_TEST_TEXT_RECOVER_TEXT_PLUGIN = {
  NULL, "InfText", inf_test_text_recover_session_new
};

static void</b></font>
inf_test_text_recover_text_erased_cb(InfTextBuffer* buffer,
                                     guint pos,
                                     InfTextChunk* chunk,
                                     InfUser* user,
                                     gpointer user_data)
{
  InfAdoptedOperation* operation;
  guint len;

  InfTextChunk* print_chunk;
  gsize print_bytes;
  gpointer print_text;

  /* If the document has substantial content and this deletes most of it,
   * then print out the document here. */
  len = inf_text_chunk_get_length(chunk);
  if(inf_text_buffer_get_length(buffer) + len &gt;= 50)
  {
    if(len &gt;= (inf_text_buffer_get_length(buffer) + len)*75/100)
    {
      if(*(int*)user_data == 0)
      {
        print_chunk = inf_text_buffer_get_slice(
          buffer,
          0,
          inf_text_buffer_get_length(buffer)
        );

        inf_text_chunk_insert_chunk(print_chunk, pos, chunk);
        print_text = inf_text_chunk_get_text(print_chunk, &amp;print_bytes);
        inf_text_chunk_free(print_chunk);

        printf("%.*s\n", (int)print_bytes, (gchar*)print_text);
        g_free(print_text);
      }

      --*(int*)user_data;
    }
  }

  g_object_unref(buffer);
}

/*
 * Entry point
 */

int main(int argc, char* argv[])
{
  InfAdoptedSessionReplay* replay;
  InfAdoptedSession* session;
  GError* error;
  int i;
  int ret;

  InfBuffer* buffer;
  GSList* item;
  gint counter;

  if(argc &lt; 2)
  {
    fprintf(stderr, "Usage: %s &lt;record-file&gt; [index]\n", argv[0]);
    return -1;
  }

  counter = 0;
  if(argc &gt; 2) counter = atoi(argv[2]);

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    g_error_free(error);
    return -1;
  }

  ret = 0;
  for(i = 1; i &lt; 2; ++ i)
  {
    replay = inf_adopted_session_replay_new();
    inf_adopted_session_replay_set_record(
      replay,
      argv[i],
      &amp;INF_TEST_TEXT_RECOVER_TEXT_PLUGIN,
      &amp;error
    );

    if(error != NULL)
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      error = NULL;

      ret = -1;
    }
    else
    {
      session = inf_adopted_session_replay_get_session(replay);
      buffer = inf_session_get_buffer(INF_SESSION(session));

      g_signal_connect(
        buffer,
        "text-erased",
        G_CALLBACK(inf_test_text_recover_text_erased_cb),
        &amp;counter
      );

      if(!inf_adopted_session_replay_play_to_end(replay, &amp;error))
      {
        fprintf(stderr, "%s\n", error-&gt;message);
        g_error_free(error);
        error = NULL;

        ret = -1;
      }
      else if(counter == 0)
      {
        inf_test_util_print_buffer(INF_TEXT_BUFFER(buffer));
      }
    }

    g_object_unref(replay);
  }

  return ret;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-mass-join.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/client/infc-session-proxy.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-algorithm.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-state-vector.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

typedef struct _InfTestMassJoiner InfTestMassJoiner;
struct _InfTestMassJoiner {
  InfCommunicationManager* communication_manager;
  InfcBrowser* browser;
  InfcSessionProxy* session;

  gchar* document;
  gchar* username;
};

typedef struct _InfTestMassJoin InfTestMassJoin;
<a name="0"></a>struct _InfTestMassJoin {
  InfIo* io;
  GSList* joiners;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};

static InfSession*
inf_test_mass_join_session_new(InfIo* io,
                               InfCommunicationManager* manager,
                               InfSessionStatus status,
                               InfCommunicationGroup* sync_group,
                               InfXmlConnection* sync_connection,
                               const gchar* path,
                               gpointer user_data)
{
  InfTextDefaultBuffer* buffer;
  InfTextSession* session;

  buffer = inf_text_default_buffer_new("UTF-8");
  session = inf_text_session_new(
    manager,
    INF_TEXT_BUFFER(buffer),
    io,
    status,
    sync_group,
    sync_connection
  );
  g_object_unref(buffer);

  return INF_SESSION(session);
}

static const InfcNotePlugin INF_TEST_MASS_JOIN_TEXT_PLUGIN = {
  NULL, "InfText", inf_test_mass_join_session_new
};

static void</b></font>
inf_test_mass_join_user_join_finished_cb(InfRequest* request,
                                         const InfRequestResult* result,
                                         const GError* error,
                                         gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;

  if(error == NULL)
  {
    fprintf(stdout, "Joiner %s: User joined!\n", joiner-&gt;username);
  }
  else
  {
    fprintf(
      stderr,
      "Joiner %s: User join failed: %s\n",
      joiner-&gt;username,
      error-&gt;message
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }
}

static void
inf_test_mass_join_join_user(InfTestMassJoiner* joiner)
{
  InfSession* session;
  InfAdoptedStateVector* v;
  GParameter params[3] = {
    { "name", { 0 } },
    { "vector", { 0 } },
    { "caret-position", { 0 } }
  };

  g_value_init(&amp;params[0].value, G_TYPE_STRING);
  g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
  g_value_init(&amp;params[2].value, G_TYPE_UINT);

  g_value_set_static_string(&amp;params[0].value, joiner-&gt;username);

  g_object_get(G_OBJECT(joiner-&gt;session), "session", &amp;session, NULL);
  v = inf_adopted_algorithm_get_current(
    inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
  );
  g_object_unref(session);

  g_value_set_boxed(&amp;params[1].value, v);
  g_value_set_uint(&amp;params[2].value, 0u);

  inf_session_proxy_join_user(
    INF_SESSION_PROXY(joiner-&gt;session),
    3,
    params,
    inf_test_mass_join_user_join_finished_cb,
    joiner
  );

  g_value_unset(&amp;params[2].value);
  g_value_unset(&amp;params[1].value);
  g_value_unset(&amp;params[0].value);
}

static void
inf_test_mass_join_session_synchronization_failed_cb(InfSession* session,
                                                     InfXmlConnection* connection,
                                                     const GError* error,
                                                     gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;

  fprintf(
    stderr,
    "Joiner %s: Session synchronization failed: %s\n",
    joiner-&gt;username,
    error-&gt;message
  );

  inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
}

static void
inf_test_mass_join_session_synchronization_complete_cb(InfSession* session,
                                                       InfXmlConnection* connection,
                                                       gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;
 
  inf_test_mass_join_join_user(joiner);
}

static void
inf_test_mass_join_subscribe_finished_cb(InfRequest* request,
                                         const InfRequestResult* result,
                                         const GError* error,
                                         gpointer user_data)
{
  InfTestMassJoiner* joiner;
  const InfBrowserIter* iter;
  InfSession* session;

  joiner = (InfTestMassJoiner*)user_data;
  inf_request_result_get_subscribe_session(result, NULL, &amp;iter, NULL);

  joiner-&gt;session = INFC_SESSION_PROXY(
    inf_browser_get_session(
      INF_BROWSER(joiner-&gt;browser),
      iter
    )
  );

  g_assert(joiner-&gt;session != NULL);

  g_object_get(G_OBJECT(joiner-&gt;session), "session", &amp;session, NULL);
  switch(inf_session_get_status(session))
  {
  case INF_SESSION_PRESYNC:
  case INF_SESSION_SYNCHRONIZING:
    g_signal_connect_after(
      G_OBJECT(session),
      "synchronization-failed",
      G_CALLBACK(inf_test_mass_join_session_synchronization_failed_cb),
      joiner
    );

    g_signal_connect_after(
      G_OBJECT(session),
      "synchronization-complete",
      G_CALLBACK(inf_test_mass_join_session_synchronization_complete_cb),
      joiner
    );

    break;
  case INF_SESSION_RUNNING:
    inf_test_mass_join_join_user(joiner);
    break;
  case INF_SESSION_CLOSED:
    fprintf(
      stderr,
      "Joiner %s: Session closed after subscription\n",
      joiner-&gt;username
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
    break;
  }

  g_object_unref(session);
}

static void
inf_test_mass_join_explore_finished_cb(InfRequest* request,
                                       const InfRequestResult* result,
                                       const GError* error,
                                       gpointer user_data)
{
  InfTestMassJoiner* joiner;
  InfBrowser* browser;
  InfBrowserIter iter;
  const char* name;
  gboolean document_exists;

  joiner = (InfTestMassJoiner*)user_data;
  browser = INF_BROWSER(joiner-&gt;browser);
  inf_browser_get_root(browser, &amp;iter);
  if(inf_browser_get_child(browser, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      "Joiner %s: Document %s does not exist\n",
      joiner-&gt;username,
      joiner-&gt;document
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }

  document_exists = FALSE;

  do
  {
    name = inf_browser_get_node_name(browser, &amp;iter);
    if(strcmp(name, joiner-&gt;document) == 0)
    {
      document_exists = TRUE;

      inf_browser_subscribe(
        browser,
        &amp;iter,
        inf_test_mass_join_subscribe_finished_cb,
        joiner
      );

      break;
    }
  } while(inf_browser_get_next(browser, &amp;iter) == TRUE);

  if(!document_exists)
  {
    fprintf(
      stderr,
      "Joiner %s: Document %s does not exist\n",
      joiner-&gt;username,
      joiner-&gt;document
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }
}

static void
inf_test_mass_join_browser_notify_status_cb(GObject* object,
                                            const GParamSpec* pspec,
                                            gpointer user_data)
{
  InfBrowser* browser;
  InfBrowserStatus status;
  InfBrowserIter iter;

  InfTestMassJoin* massjoin;
  InfTestMassJoiner* joiner;
  GSList* item;

  browser = INF_BROWSER(object);
  massjoin = (InfTestMassJoin*)user_data;
  joiner = NULL;
  for(item = massjoin-&gt;joiners; item != NULL; item = item-&gt;next)
  {
    joiner = (InfTestMassJoiner*)item-&gt;data;
    if(INF_BROWSER(joiner-&gt;browser) == browser)
      break;
  }

  g_assert(joiner != NULL);

  g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);
  switch(status)
  {
  case INF_BROWSER_OPENING:
    /* nothing to do */
    break;
  case INF_BROWSER_OPEN:
    fprintf(stdout, "Joiner %s: Connected\n", joiner-&gt;username);

    inf_browser_get_root(browser, &amp;iter);

    inf_browser_explore(
      browser,
      &amp;iter,
      inf_test_mass_join_explore_finished_cb,
      joiner
    );

    break;
  case INF_BROWSER_CLOSED:
    fprintf(stdout, "Joiner %s: Disconnected\n", joiner-&gt;username);
    massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);
    if(massjoin-&gt;joiners == NULL)
      inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
inf_test_mass_join_connect(InfTestMassJoin* massjoin,
                           const char* hostname,
                           guint port,
                           const char* document,
                           const char* username)
{
  InfIpAddress* addr;
  InfTcpConnection* tcp;
  InfXmppConnection* xmpp;
  InfTestMassJoiner* joiner;
  InfXmlConnection* xml;
  GError* error;

  addr = inf_ip_address_new_from_string(hostname);
  tcp = inf_tcp_connection_new(massjoin-&gt;io, addr, port);
  xmpp = inf_xmpp_connection_new(
    tcp,
    INF_XMPP_CONNECTION_CLIENT,
    g_get_host_name(),
    hostname,
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
    NULL,
    NULL,
    NULL
  );

  joiner = g_slice_new(InfTestMassJoiner);
  joiner-&gt;communication_manager = inf_communication_manager_new();
  joiner-&gt;browser = infc_browser_new(
    massjoin-&gt;io,
    joiner-&gt;communication_manager,
    INF_XML_CONNECTION(xmpp)
  );
  joiner-&gt;session = NULL;
  joiner-&gt;document = g_strdup(document);
  joiner-&gt;username = g_strdup(username);

  g_object_unref(xmpp);
  g_object_unref(tcp);
  inf_ip_address_free(addr);

  massjoin-&gt;joiners = g_slist_prepend(massjoin-&gt;joiners, joiner);
  infc_browser_add_plugin(joiner-&gt;browser, &amp;INF_TEST_MASS_JOIN_TEXT_PLUGIN);

  g_signal_connect(
    G_OBJECT(joiner-&gt;browser),
    "notify::status",
    G_CALLBACK(inf_test_mass_join_browser_notify_status_cb),
    massjoin
  );

  error = NULL;
  xml = infc_browser_get_connection(joiner-&gt;browser);
  if(inf_xml_connection_open(xml, &amp;error) == FALSE)
  {
    fprintf(
      stderr,
      "Joiner %s: Failed to connect to %s: %s\n",
      joiner-&gt;username,
      hostname,
      error-&gt;message
    );

    g_error_free(error);
    massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);

    if(massjoin-&gt;joiners == NULL)
      inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
  }
}

int
main(int argc,
     char* argv[])
{
  InfTestMassJoin massjoin;
  GError* error;
  int i;
  gchar* name;

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return -1;
  }

  massjoin.io = INF_IO(inf_standalone_io_new());
  massjoin.joiners = NULL;

  for(i = 0; i &lt; 128; ++i)
  {
    name = g_strdup_printf("MassJoin%03d", i);

    inf_test_mass_join_connect(
      &amp;massjoin,
      "127.0.0.1",
      inf_protocol_get_default_port(),
      "Test",
      name
    );

    g_free(name);
    //g_usleep(100000);
  }

  inf_standalone_io_loop(INF_STANDALONE_IO(massjoin.io));
  return 0;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
