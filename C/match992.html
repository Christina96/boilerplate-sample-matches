<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-text-recover.c &amp; inf-test-mass-join.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-text-recover.c &amp; inf-test-mass-join.c
      </h3>
<h1 align="center">
        10.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-text-recover.c (17.777779%)<th>inf-test-mass-join.c (7.6923075%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(47-79)<td><a href="#" name="0">(52-84)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-recover.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-session.h&gt;
2 #include &lt;libinftext/inf-text-default-buffer.h&gt;
3 #include &lt;libinftext/inf-text-insert-operation.h&gt;
4 #include &lt;libinftext/inf-text-delete-operation.h&gt;
5 #include &lt;libinfinity/adopted/inf-adopted-session-replay.h&gt;
6 #include &lt;libinfinity/common/inf-init.h&gt;
7 #include &lt;string.h&gt;
8 static void
9 inf_test_util_print_buffer(InfTextBuffer* buffer)
10 {
11   InfTextChunk* chunk;
12   gchar* text;
13   gsize bytes;
14   chunk = inf_text_buffer_get_slice(
15     buffer,
16     0,
17     inf_text_buffer_get_length(buffer)
18   );
19   text = inf_text_chunk_get_text(chunk, &amp;bytes);
20   inf_text_chunk_free(chunk);
21 <a name="0"></a>
22   printf("%.*s\n", (int)bytes, text);
23   g_free(text);
24 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
25 static InfSession*
26 inf_test_text_recover_session_new(InfIo* io,
27                                   InfCommunicationManager* manager,
28                                   InfSessionStatus status,
29                                   InfCommunicationGroup* sync_group,
30                                   InfXmlConnection* sync_connection,
31                                   const gchar* path,
32                                   gpointer user_data)
33 {
34   InfTextDefaultBuffer* buffer;
35   InfTextSession* session;
36   buffer = inf_text_default_buffer_new("UTF-8");
37   session = inf_text_session_new(
38     manager,
39     INF_TEXT_BUFFER(buffer),
40     io,
41     status,
42     sync_group,
43     sync_connection
44   );
45   g_object_unref(buffer);
46   return INF_SESSION(session);
47 }
48 static const InfcNotePlugin INF_TEST_TEXT_RECOVER_TEXT_PLUGIN = {
49   NULL, "InfText", inf_test_text_recover_session_new
50 };
51 static void</b></font>
52 inf_test_text_recover_text_erased_cb(InfTextBuffer* buffer,
53                                      guint pos,
54                                      InfTextChunk* chunk,
55                                      InfUser* user,
56                                      gpointer user_data)
57 {
58   InfAdoptedOperation* operation;
59   guint len;
60   InfTextChunk* print_chunk;
61   gsize print_bytes;
62   gpointer print_text;
63   len = inf_text_chunk_get_length(chunk);
64   if(inf_text_buffer_get_length(buffer) + len &gt;= 50)
65   {
66     if(len &gt;= (inf_text_buffer_get_length(buffer) + len)*75/100)
67     {
68       if(*(int*)user_data == 0)
69       {
70         print_chunk = inf_text_buffer_get_slice(
71           buffer,
72           0,
73           inf_text_buffer_get_length(buffer)
74         );
75         inf_text_chunk_insert_chunk(print_chunk, pos, chunk);
76         print_text = inf_text_chunk_get_text(print_chunk, &amp;print_bytes);
77         inf_text_chunk_free(print_chunk);
78         printf("%.*s\n", (int)print_bytes, (gchar*)print_text);
79         g_free(print_text);
80       }
81       --*(int*)user_data;
82     }
83   }
84   g_object_unref(buffer);
85 }
86 int main(int argc, char* argv[])
87 {
88   InfAdoptedSessionReplay* replay;
89   InfAdoptedSession* session;
90   GError* error;
91   int i;
92   int ret;
93   InfBuffer* buffer;
94   GSList* item;
95   gint counter;
96   if(argc &lt; 2)
97   {
98     fprintf(stderr, "Usage: %s &lt;record-file&gt; [index]\n", argv[0]);
99     return -1;
100   }
101   counter = 0;
102   if(argc &gt; 2) counter = atoi(argv[2]);
103   error = NULL;
104   if(!inf_init(&amp;error))
105   {
106     fprintf(stderr, "%s\n", error-&gt;message);
107     g_error_free(error);
108     return -1;
109   }
110   ret = 0;
111   for(i = 1; i &lt; 2; ++ i)
112   {
113     replay = inf_adopted_session_replay_new();
114     inf_adopted_session_replay_set_record(
115       replay,
116       argv[i],
117       &amp;INF_TEST_TEXT_RECOVER_TEXT_PLUGIN,
118       &amp;error
119     );
120     if(error != NULL)
121     {
122       fprintf(stderr, "%s\n", error-&gt;message);
123       g_error_free(error);
124       error = NULL;
125       ret = -1;
126     }
127     else
128     {
129       session = inf_adopted_session_replay_get_session(replay);
130       buffer = inf_session_get_buffer(INF_SESSION(session));
131       g_signal_connect(
132         buffer,
133         "text-erased",
134         G_CALLBACK(inf_test_text_recover_text_erased_cb),
135         &amp;counter
136       );
137       if(!inf_adopted_session_replay_play_to_end(replay, &amp;error))
138       {
139         fprintf(stderr, "%s\n", error-&gt;message);
140         g_error_free(error);
141         error = NULL;
142         ret = -1;
143       }
144       else if(counter == 0)
145       {
146         inf_test_util_print_buffer(INF_TEXT_BUFFER(buffer));
147       }
148     }
149     g_object_unref(replay);
150   }
151   return ret;
152 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-mass-join.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-default-buffer.h&gt;
2 #include &lt;libinftext/inf-text-session.h&gt;
3 #include &lt;libinfinity/client/infc-browser.h&gt;
4 #include &lt;libinfinity/client/infc-session-proxy.h&gt;
5 #include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
6 #include &lt;libinfinity/adopted/inf-adopted-algorithm.h&gt;
7 #include &lt;libinfinity/adopted/inf-adopted-state-vector.h&gt;
8 #include &lt;libinfinity/common/inf-request-result.h&gt;
9 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
10 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
11 #include &lt;libinfinity/common/inf-ip-address.h&gt;
12 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
13 #include &lt;libinfinity/common/inf-error.h&gt;
14 #include &lt;libinfinity/common/inf-protocol.h&gt;
15 #include &lt;libinfinity/common/inf-init.h&gt;
16 #include &lt;string.h&gt;
17 typedef struct _InfTestMassJoiner InfTestMassJoiner;
18 struct _InfTestMassJoiner {
19   InfCommunicationManager* communication_manager;
20   InfcBrowser* browser;
21   InfcSessionProxy* session;
22   gchar* document;
23   gchar* username;
24 };
25 typedef struct _InfTestMassJoin InfTestMassJoin;
26 <a name="0"></a>struct _InfTestMassJoin {
27   InfIo* io;
28   GSList* joiners;
29 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
30 static InfSession*
31 inf_test_mass_join_session_new(InfIo* io,
32                                InfCommunicationManager* manager,
33                                InfSessionStatus status,
34                                InfCommunicationGroup* sync_group,
35                                InfXmlConnection* sync_connection,
36                                const gchar* path,
37                                gpointer user_data)
38 {
39   InfTextDefaultBuffer* buffer;
40   InfTextSession* session;
41   buffer = inf_text_default_buffer_new("UTF-8");
42   session = inf_text_session_new(
43     manager,
44     INF_TEXT_BUFFER(buffer),
45     io,
46     status,
47     sync_group,
48     sync_connection
49   );
50   g_object_unref(buffer);
51   return INF_SESSION(session);
52 }
53 static const InfcNotePlugin INF_TEST_MASS_JOIN_TEXT_PLUGIN = {
54   NULL, "InfText", inf_test_mass_join_session_new
55 };
56 static void</b></font>
57 inf_test_mass_join_user_join_finished_cb(InfRequest* request,
58                                          const InfRequestResult* result,
59                                          const GError* error,
60                                          gpointer user_data)
61 {
62   InfTestMassJoiner* joiner;
63   joiner = (InfTestMassJoiner*)user_data;
64   if(error == NULL)
65   {
66     fprintf(stdout, "Joiner %s: User joined!\n", joiner-&gt;username);
67   }
68   else
69   {
70     fprintf(
71       stderr,
72       "Joiner %s: User join failed: %s\n",
73       joiner-&gt;username,
74       error-&gt;message
75     );
76     inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
77   }
78 }
79 static void
80 inf_test_mass_join_join_user(InfTestMassJoiner* joiner)
81 {
82   InfSession* session;
83   InfAdoptedStateVector* v;
84   GParameter params[3] = {
85     { "name", { 0 } },
86     { "vector", { 0 } },
87     { "caret-position", { 0 } }
88   };
89   g_value_init(&amp;params[0].value, G_TYPE_STRING);
90   g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
91   g_value_init(&amp;params[2].value, G_TYPE_UINT);
92   g_value_set_static_string(&amp;params[0].value, joiner-&gt;username);
93   g_object_get(G_OBJECT(joiner-&gt;session), "session", &amp;session, NULL);
94   v = inf_adopted_algorithm_get_current(
95     inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
96   );
97   g_object_unref(session);
98   g_value_set_boxed(&amp;params[1].value, v);
99   g_value_set_uint(&amp;params[2].value, 0u);
100   inf_session_proxy_join_user(
101     INF_SESSION_PROXY(joiner-&gt;session),
102     3,
103     params,
104     inf_test_mass_join_user_join_finished_cb,
105     joiner
106   );
107   g_value_unset(&amp;params[2].value);
108   g_value_unset(&amp;params[1].value);
109   g_value_unset(&amp;params[0].value);
110 }
111 static void
112 inf_test_mass_join_session_synchronization_failed_cb(InfSession* session,
113                                                      InfXmlConnection* connection,
114                                                      const GError* error,
115                                                      gpointer user_data)
116 {
117   InfTestMassJoiner* joiner;
118   joiner = (InfTestMassJoiner*)user_data;
119   fprintf(
120     stderr,
121     "Joiner %s: Session synchronization failed: %s\n",
122     joiner-&gt;username,
123     error-&gt;message
124   );
125   inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
126 }
127 static void
128 inf_test_mass_join_session_synchronization_complete_cb(InfSession* session,
129                                                        InfXmlConnection* connection,
130                                                        gpointer user_data)
131 {
132   InfTestMassJoiner* joiner;
133   joiner = (InfTestMassJoiner*)user_data;
134   inf_test_mass_join_join_user(joiner);
135 }
136 static void
137 inf_test_mass_join_subscribe_finished_cb(InfRequest* request,
138                                          const InfRequestResult* result,
139                                          const GError* error,
140                                          gpointer user_data)
141 {
142   InfTestMassJoiner* joiner;
143   const InfBrowserIter* iter;
144   InfSession* session;
145   joiner = (InfTestMassJoiner*)user_data;
146   inf_request_result_get_subscribe_session(result, NULL, &amp;iter, NULL);
147   joiner-&gt;session = INFC_SESSION_PROXY(
148     inf_browser_get_session(
149       INF_BROWSER(joiner-&gt;browser),
150       iter
151     )
152   );
153   g_assert(joiner-&gt;session != NULL);
154   g_object_get(G_OBJECT(joiner-&gt;session), "session", &amp;session, NULL);
155   switch(inf_session_get_status(session))
156   {
157   case INF_SESSION_PRESYNC:
158   case INF_SESSION_SYNCHRONIZING:
159     g_signal_connect_after(
160       G_OBJECT(session),
161       "synchronization-failed",
162       G_CALLBACK(inf_test_mass_join_session_synchronization_failed_cb),
163       joiner
164     );
165     g_signal_connect_after(
166       G_OBJECT(session),
167       "synchronization-complete",
168       G_CALLBACK(inf_test_mass_join_session_synchronization_complete_cb),
169       joiner
170     );
171     break;
172   case INF_SESSION_RUNNING:
173     inf_test_mass_join_join_user(joiner);
174     break;
175   case INF_SESSION_CLOSED:
176     fprintf(
177       stderr,
178       "Joiner %s: Session closed after subscription\n",
179       joiner-&gt;username
180     );
181     inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
182     break;
183   }
184   g_object_unref(session);
185 }
186 static void
187 inf_test_mass_join_explore_finished_cb(InfRequest* request,
188                                        const InfRequestResult* result,
189                                        const GError* error,
190                                        gpointer user_data)
191 {
192   InfTestMassJoiner* joiner;
193   InfBrowser* browser;
194   InfBrowserIter iter;
195   const char* name;
196   gboolean document_exists;
197   joiner = (InfTestMassJoiner*)user_data;
198   browser = INF_BROWSER(joiner-&gt;browser);
199   inf_browser_get_root(browser, &amp;iter);
200   if(inf_browser_get_child(browser, &amp;iter) == FALSE)
201   {
202     fprintf(
203       stderr,
204       "Joiner %s: Document %s does not exist\n",
205       joiner-&gt;username,
206       joiner-&gt;document
207     );
208     inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
209   }
210   document_exists = FALSE;
211   do
212   {
213     name = inf_browser_get_node_name(browser, &amp;iter);
214     if(strcmp(name, joiner-&gt;document) == 0)
215     {
216       document_exists = TRUE;
217       inf_browser_subscribe(
218         browser,
219         &amp;iter,
220         inf_test_mass_join_subscribe_finished_cb,
221         joiner
222       );
223       break;
224     }
225   } while(inf_browser_get_next(browser, &amp;iter) == TRUE);
226   if(!document_exists)
227   {
228     fprintf(
229       stderr,
230       "Joiner %s: Document %s does not exist\n",
231       joiner-&gt;username,
232       joiner-&gt;document
233     );
234     inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
235   }
236 }
237 static void
238 inf_test_mass_join_browser_notify_status_cb(GObject* object,
239                                             const GParamSpec* pspec,
240                                             gpointer user_data)
241 {
242   InfBrowser* browser;
243   InfBrowserStatus status;
244   InfBrowserIter iter;
245   InfTestMassJoin* massjoin;
246   InfTestMassJoiner* joiner;
247   GSList* item;
248   browser = INF_BROWSER(object);
249   massjoin = (InfTestMassJoin*)user_data;
250   joiner = NULL;
251   for(item = massjoin-&gt;joiners; item != NULL; item = item-&gt;next)
252   {
253     joiner = (InfTestMassJoiner*)item-&gt;data;
254     if(INF_BROWSER(joiner-&gt;browser) == browser)
255       break;
256   }
257   g_assert(joiner != NULL);
258   g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);
259   switch(status)
260   {
261   case INF_BROWSER_OPENING:
262     break;
263   case INF_BROWSER_OPEN:
264     fprintf(stdout, "Joiner %s: Connected\n", joiner-&gt;username);
265     inf_browser_get_root(browser, &amp;iter);
266     inf_browser_explore(
267       browser,
268       &amp;iter,
269       inf_test_mass_join_explore_finished_cb,
270       joiner
271     );
272     break;
273   case INF_BROWSER_CLOSED:
274     fprintf(stdout, "Joiner %s: Disconnected\n", joiner-&gt;username);
275     massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);
276     if(massjoin-&gt;joiners == NULL)
277       inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
278     break;
279   default:
280     g_assert_not_reached();
281     break;
282   }
283 }
284 static void
285 inf_test_mass_join_connect(InfTestMassJoin* massjoin,
286                            const char* hostname,
287                            guint port,
288                            const char* document,
289                            const char* username)
290 {
291   InfIpAddress* addr;
292   InfTcpConnection* tcp;
293   InfXmppConnection* xmpp;
294   InfTestMassJoiner* joiner;
295   InfXmlConnection* xml;
296   GError* error;
297   addr = inf_ip_address_new_from_string(hostname);
298   tcp = inf_tcp_connection_new(massjoin-&gt;io, addr, port);
299   xmpp = inf_xmpp_connection_new(
300     tcp,
301     INF_XMPP_CONNECTION_CLIENT,
302     g_get_host_name(),
303     hostname,
304     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
305     NULL,
306     NULL,
307     NULL
308   );
309   joiner = g_slice_new(InfTestMassJoiner);
310   joiner-&gt;communication_manager = inf_communication_manager_new();
311   joiner-&gt;browser = infc_browser_new(
312     massjoin-&gt;io,
313     joiner-&gt;communication_manager,
314     INF_XML_CONNECTION(xmpp)
315   );
316   joiner-&gt;session = NULL;
317   joiner-&gt;document = g_strdup(document);
318   joiner-&gt;username = g_strdup(username);
319   g_object_unref(xmpp);
320   g_object_unref(tcp);
321   inf_ip_address_free(addr);
322   massjoin-&gt;joiners = g_slist_prepend(massjoin-&gt;joiners, joiner);
323   infc_browser_add_plugin(joiner-&gt;browser, &amp;INF_TEST_MASS_JOIN_TEXT_PLUGIN);
324   g_signal_connect(
325     G_OBJECT(joiner-&gt;browser),
326     "notify::status",
327     G_CALLBACK(inf_test_mass_join_browser_notify_status_cb),
328     massjoin
329   );
330   error = NULL;
331   xml = infc_browser_get_connection(joiner-&gt;browser);
332   if(inf_xml_connection_open(xml, &amp;error) == FALSE)
333   {
334     fprintf(
335       stderr,
336       "Joiner %s: Failed to connect to %s: %s\n",
337       joiner-&gt;username,
338       hostname,
339       error-&gt;message
340     );
341     g_error_free(error);
342     massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);
343     if(massjoin-&gt;joiners == NULL)
344       inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
345   }
346 }
347 int
348 main(int argc,
349      char* argv[])
350 {
351   InfTestMassJoin massjoin;
352   GError* error;
353   int i;
354   gchar* name;
355   error = NULL;
356   if(!inf_init(&amp;error))
357   {
358     fprintf(stderr, "%s\n", error-&gt;message);
359     return -1;
360   }
361   massjoin.io = INF_IO(inf_standalone_io_new());
362   massjoin.joiners = NULL;
363   for(i = 0; i &lt; 128; ++i)
364   {
365     name = g_strdup_printf("MassJoin%03d", i);
366     inf_test_mass_join_connect(
367       &amp;massjoin,
368       "127.0.0.1",
369       inf_protocol_get_default_port(),
370       "Test",
371       name
372     );
373     g_free(name);
374   }
375   inf_standalone_io_loop(INF_STANDALONE_IO(massjoin.io));
376   return 0;
377 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
