<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-test-text-recover.c & inf-test-mass-join.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-test-text-recover.c & inf-test-mass-join.c
      </h3>
      <h1 align="center">
        10.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-test-text-recover.c (17.777779%)<TH>inf-test-mass-join.c (7.6923075%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match992-0.html#0',2,'match992-1.html#0',3)" NAME="0">(47-79)<TD><A HREF="javascript:ZweiFrames('match992-0.html#0',2,'match992-1.html#0',3)" NAME="0">(52-84)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-text-recover.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-session-replay.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

static void
inf_test_util_print_buffer(InfTextBuffer* buffer)
{
  InfTextChunk* chunk;
  gchar* text;
  gsize bytes;

  chunk = inf_text_buffer_get_slice(
    buffer,
    0,
    inf_text_buffer_get_length(buffer)
  );

  text = inf_text_chunk_get_text(chunk, &amp;bytes);
  inf_text_chunk_free(chunk);
<A NAME="0"></A>
  printf(&quot;%.*s\n&quot;, (int)bytes, text);
  g_free(text);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match992-1.html#0',3,'match992-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static InfSession*
inf_test_text_recover_session_new(InfIo* io,
                                  InfCommunicationManager* manager,
                                  InfSessionStatus status,
                                  InfCommunicationGroup* sync_group,
                                  InfXmlConnection* sync_connection,
                                  const gchar* path,
                                  gpointer user_data)
{
  InfTextDefaultBuffer* buffer;
  InfTextSession* session;

  buffer = inf_text_default_buffer_new(&quot;UTF-8&quot;);
  session = inf_text_session_new(
    manager,
    INF_TEXT_BUFFER(buffer),
    io,
    status,
    sync_group,
    sync_connection
  );
  g_object_unref(buffer);

  return INF_SESSION(session);
}

static const InfcNotePlugin INF_TEST_TEXT_RECOVER_TEXT_PLUGIN = {
  NULL, &quot;InfText&quot;, inf_test_text_recover_session_new
};

static void</B></FONT>
inf_test_text_recover_text_erased_cb(InfTextBuffer* buffer,
                                     guint pos,
                                     InfTextChunk* chunk,
                                     InfUser* user,
                                     gpointer user_data)
{
  InfAdoptedOperation* operation;
  guint len;

  InfTextChunk* print_chunk;
  gsize print_bytes;
  gpointer print_text;

  /* If the document has substantial content and this deletes most of it,
   * then print out the document here. */
  len = inf_text_chunk_get_length(chunk);
  if(inf_text_buffer_get_length(buffer) + len &gt;= 50)
  {
    if(len &gt;= (inf_text_buffer_get_length(buffer) + len)*75/100)
    {
      if(*(int*)user_data == 0)
      {
        print_chunk = inf_text_buffer_get_slice(
          buffer,
          0,
          inf_text_buffer_get_length(buffer)
        );

        inf_text_chunk_insert_chunk(print_chunk, pos, chunk);
        print_text = inf_text_chunk_get_text(print_chunk, &amp;print_bytes);
        inf_text_chunk_free(print_chunk);

        printf(&quot;%.*s\n&quot;, (int)print_bytes, (gchar*)print_text);
        g_free(print_text);
      }

      --*(int*)user_data;
    }
  }

  g_object_unref(buffer);
}

/*
 * Entry point
 */

int main(int argc, char* argv[])
{
  InfAdoptedSessionReplay* replay;
  InfAdoptedSession* session;
  GError* error;
  int i;
  int ret;

  InfBuffer* buffer;
  GSList* item;
  gint counter;

  if(argc &lt; 2)
  {
    fprintf(stderr, &quot;Usage: %s &lt;record-file&gt; [index]\n&quot;, argv[0]);
    return -1;
  }

  counter = 0;
  if(argc &gt; 2) counter = atoi(argv[2]);

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    g_error_free(error);
    return -1;
  }

  ret = 0;
  for(i = 1; i &lt; 2; ++ i)
  {
    replay = inf_adopted_session_replay_new();
    inf_adopted_session_replay_set_record(
      replay,
      argv[i],
      &amp;INF_TEST_TEXT_RECOVER_TEXT_PLUGIN,
      &amp;error
    );

    if(error != NULL)
    {
      fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
      g_error_free(error);
      error = NULL;

      ret = -1;
    }
    else
    {
      session = inf_adopted_session_replay_get_session(replay);
      buffer = inf_session_get_buffer(INF_SESSION(session));

      g_signal_connect(
        buffer,
        &quot;text-erased&quot;,
        G_CALLBACK(inf_test_text_recover_text_erased_cb),
        &amp;counter
      );

      if(!inf_adopted_session_replay_play_to_end(replay, &amp;error))
      {
        fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
        g_error_free(error);
        error = NULL;

        ret = -1;
      }
      else if(counter == 0)
      {
        inf_test_util_print_buffer(INF_TEXT_BUFFER(buffer));
      }
    }

    g_object_unref(replay);
  }

  return ret;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-mass-join.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-default-buffer.h&gt;
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/client/infc-session-proxy.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-algorithm.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-state-vector.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

typedef struct _InfTestMassJoiner InfTestMassJoiner;
struct _InfTestMassJoiner {
  InfCommunicationManager* communication_manager;
  InfcBrowser* browser;
  InfcSessionProxy* session;

  gchar* document;
  gchar* username;
};

typedef struct _InfTestMassJoin InfTestMassJoin;
<A NAME="0"></A>struct _InfTestMassJoin {
  InfIo* io;
  GSList* joiners;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match992-0.html#0',2,'match992-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};

static InfSession*
inf_test_mass_join_session_new(InfIo* io,
                               InfCommunicationManager* manager,
                               InfSessionStatus status,
                               InfCommunicationGroup* sync_group,
                               InfXmlConnection* sync_connection,
                               const gchar* path,
                               gpointer user_data)
{
  InfTextDefaultBuffer* buffer;
  InfTextSession* session;

  buffer = inf_text_default_buffer_new(&quot;UTF-8&quot;);
  session = inf_text_session_new(
    manager,
    INF_TEXT_BUFFER(buffer),
    io,
    status,
    sync_group,
    sync_connection
  );
  g_object_unref(buffer);

  return INF_SESSION(session);
}

static const InfcNotePlugin INF_TEST_MASS_JOIN_TEXT_PLUGIN = {
  NULL, &quot;InfText&quot;, inf_test_mass_join_session_new
};

static void</B></FONT>
inf_test_mass_join_user_join_finished_cb(InfRequest* request,
                                         const InfRequestResult* result,
                                         const GError* error,
                                         gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;

  if(error == NULL)
  {
    fprintf(stdout, &quot;Joiner %s: User joined!\n&quot;, joiner-&gt;username);
  }
  else
  {
    fprintf(
      stderr,
      &quot;Joiner %s: User join failed: %s\n&quot;,
      joiner-&gt;username,
      error-&gt;message
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }
}

static void
inf_test_mass_join_join_user(InfTestMassJoiner* joiner)
{
  InfSession* session;
  InfAdoptedStateVector* v;
  GParameter params[3] = {
    { &quot;name&quot;, { 0 } },
    { &quot;vector&quot;, { 0 } },
    { &quot;caret-position&quot;, { 0 } }
  };

  g_value_init(&amp;params[0].value, G_TYPE_STRING);
  g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
  g_value_init(&amp;params[2].value, G_TYPE_UINT);

  g_value_set_static_string(&amp;params[0].value, joiner-&gt;username);

  g_object_get(G_OBJECT(joiner-&gt;session), &quot;session&quot;, &amp;session, NULL);
  v = inf_adopted_algorithm_get_current(
    inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
  );
  g_object_unref(session);

  g_value_set_boxed(&amp;params[1].value, v);
  g_value_set_uint(&amp;params[2].value, 0u);

  inf_session_proxy_join_user(
    INF_SESSION_PROXY(joiner-&gt;session),
    3,
    params,
    inf_test_mass_join_user_join_finished_cb,
    joiner
  );

  g_value_unset(&amp;params[2].value);
  g_value_unset(&amp;params[1].value);
  g_value_unset(&amp;params[0].value);
}

static void
inf_test_mass_join_session_synchronization_failed_cb(InfSession* session,
                                                     InfXmlConnection* connection,
                                                     const GError* error,
                                                     gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;

  fprintf(
    stderr,
    &quot;Joiner %s: Session synchronization failed: %s\n&quot;,
    joiner-&gt;username,
    error-&gt;message
  );

  inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
}

static void
inf_test_mass_join_session_synchronization_complete_cb(InfSession* session,
                                                       InfXmlConnection* connection,
                                                       gpointer user_data)
{
  InfTestMassJoiner* joiner;
  joiner = (InfTestMassJoiner*)user_data;
 
  inf_test_mass_join_join_user(joiner);
}

static void
inf_test_mass_join_subscribe_finished_cb(InfRequest* request,
                                         const InfRequestResult* result,
                                         const GError* error,
                                         gpointer user_data)
{
  InfTestMassJoiner* joiner;
  const InfBrowserIter* iter;
  InfSession* session;

  joiner = (InfTestMassJoiner*)user_data;
  inf_request_result_get_subscribe_session(result, NULL, &amp;iter, NULL);

  joiner-&gt;session = INFC_SESSION_PROXY(
    inf_browser_get_session(
      INF_BROWSER(joiner-&gt;browser),
      iter
    )
  );

  g_assert(joiner-&gt;session != NULL);

  g_object_get(G_OBJECT(joiner-&gt;session), &quot;session&quot;, &amp;session, NULL);
  switch(inf_session_get_status(session))
  {
  case INF_SESSION_PRESYNC:
  case INF_SESSION_SYNCHRONIZING:
    g_signal_connect_after(
      G_OBJECT(session),
      &quot;synchronization-failed&quot;,
      G_CALLBACK(inf_test_mass_join_session_synchronization_failed_cb),
      joiner
    );

    g_signal_connect_after(
      G_OBJECT(session),
      &quot;synchronization-complete&quot;,
      G_CALLBACK(inf_test_mass_join_session_synchronization_complete_cb),
      joiner
    );

    break;
  case INF_SESSION_RUNNING:
    inf_test_mass_join_join_user(joiner);
    break;
  case INF_SESSION_CLOSED:
    fprintf(
      stderr,
      &quot;Joiner %s: Session closed after subscription\n&quot;,
      joiner-&gt;username
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
    break;
  }

  g_object_unref(session);
}

static void
inf_test_mass_join_explore_finished_cb(InfRequest* request,
                                       const InfRequestResult* result,
                                       const GError* error,
                                       gpointer user_data)
{
  InfTestMassJoiner* joiner;
  InfBrowser* browser;
  InfBrowserIter iter;
  const char* name;
  gboolean document_exists;

  joiner = (InfTestMassJoiner*)user_data;
  browser = INF_BROWSER(joiner-&gt;browser);
  inf_browser_get_root(browser, &amp;iter);
  if(inf_browser_get_child(browser, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      &quot;Joiner %s: Document %s does not exist\n&quot;,
      joiner-&gt;username,
      joiner-&gt;document
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }

  document_exists = FALSE;

  do
  {
    name = inf_browser_get_node_name(browser, &amp;iter);
    if(strcmp(name, joiner-&gt;document) == 0)
    {
      document_exists = TRUE;

      inf_browser_subscribe(
        browser,
        &amp;iter,
        inf_test_mass_join_subscribe_finished_cb,
        joiner
      );

      break;
    }
  } while(inf_browser_get_next(browser, &amp;iter) == TRUE);

  if(!document_exists)
  {
    fprintf(
      stderr,
      &quot;Joiner %s: Document %s does not exist\n&quot;,
      joiner-&gt;username,
      joiner-&gt;document
    );

    inf_xml_connection_close(infc_browser_get_connection(joiner-&gt;browser));
  }
}

static void
inf_test_mass_join_browser_notify_status_cb(GObject* object,
                                            const GParamSpec* pspec,
                                            gpointer user_data)
{
  InfBrowser* browser;
  InfBrowserStatus status;
  InfBrowserIter iter;

  InfTestMassJoin* massjoin;
  InfTestMassJoiner* joiner;
  GSList* item;

  browser = INF_BROWSER(object);
  massjoin = (InfTestMassJoin*)user_data;
  joiner = NULL;
  for(item = massjoin-&gt;joiners; item != NULL; item = item-&gt;next)
  {
    joiner = (InfTestMassJoiner*)item-&gt;data;
    if(INF_BROWSER(joiner-&gt;browser) == browser)
      break;
  }

  g_assert(joiner != NULL);

  g_object_get(G_OBJECT(browser), &quot;status&quot;, &amp;status, NULL);
  switch(status)
  {
  case INF_BROWSER_OPENING:
    /* nothing to do */
    break;
  case INF_BROWSER_OPEN:
    fprintf(stdout, &quot;Joiner %s: Connected\n&quot;, joiner-&gt;username);

    inf_browser_get_root(browser, &amp;iter);

    inf_browser_explore(
      browser,
      &amp;iter,
      inf_test_mass_join_explore_finished_cb,
      joiner
    );

    break;
  case INF_BROWSER_CLOSED:
    fprintf(stdout, &quot;Joiner %s: Disconnected\n&quot;, joiner-&gt;username);
    massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);
    if(massjoin-&gt;joiners == NULL)
      inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static void
inf_test_mass_join_connect(InfTestMassJoin* massjoin,
                           const char* hostname,
                           guint port,
                           const char* document,
                           const char* username)
{
  InfIpAddress* addr;
  InfTcpConnection* tcp;
  InfXmppConnection* xmpp;
  InfTestMassJoiner* joiner;
  InfXmlConnection* xml;
  GError* error;

  addr = inf_ip_address_new_from_string(hostname);
  tcp = inf_tcp_connection_new(massjoin-&gt;io, addr, port);
  xmpp = inf_xmpp_connection_new(
    tcp,
    INF_XMPP_CONNECTION_CLIENT,
    g_get_host_name(),
    hostname,
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
    NULL,
    NULL,
    NULL
  );

  joiner = g_slice_new(InfTestMassJoiner);
  joiner-&gt;communication_manager = inf_communication_manager_new();
  joiner-&gt;browser = infc_browser_new(
    massjoin-&gt;io,
    joiner-&gt;communication_manager,
    INF_XML_CONNECTION(xmpp)
  );
  joiner-&gt;session = NULL;
  joiner-&gt;document = g_strdup(document);
  joiner-&gt;username = g_strdup(username);

  g_object_unref(xmpp);
  g_object_unref(tcp);
  inf_ip_address_free(addr);

  massjoin-&gt;joiners = g_slist_prepend(massjoin-&gt;joiners, joiner);
  infc_browser_add_plugin(joiner-&gt;browser, &amp;INF_TEST_MASS_JOIN_TEXT_PLUGIN);

  g_signal_connect(
    G_OBJECT(joiner-&gt;browser),
    &quot;notify::status&quot;,
    G_CALLBACK(inf_test_mass_join_browser_notify_status_cb),
    massjoin
  );

  error = NULL;
  xml = infc_browser_get_connection(joiner-&gt;browser);
  if(inf_xml_connection_open(xml, &amp;error) == FALSE)
  {
    fprintf(
      stderr,
      &quot;Joiner %s: Failed to connect to %s: %s\n&quot;,
      joiner-&gt;username,
      hostname,
      error-&gt;message
    );

    g_error_free(error);
    massjoin-&gt;joiners = g_slist_remove(massjoin-&gt;joiners, joiner);

    if(massjoin-&gt;joiners == NULL)
      inf_standalone_io_loop_quit(INF_STANDALONE_IO(massjoin-&gt;io));
  }
}

int
main(int argc,
     char* argv[])
{
  InfTestMassJoin massjoin;
  GError* error;
  int i;
  gchar* name;

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, &quot;%s\n&quot;, error-&gt;message);
    return -1;
  }

  massjoin.io = INF_IO(inf_standalone_io_new());
  massjoin.joiners = NULL;

  for(i = 0; i &lt; 128; ++i)
  {
    name = g_strdup_printf(&quot;MassJoin%03d&quot;, i);

    inf_test_mass_join_connect(
      &amp;massjoin,
      &quot;127.0.0.1&quot;,
      inf_protocol_get_default_port(),
      &quot;Test&quot;,
      name
    );

    g_free(name);
    //g_usleep(100000);
  }

  inf_standalone_io_loop(INF_STANDALONE_IO(massjoin.io));
  return 0;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
