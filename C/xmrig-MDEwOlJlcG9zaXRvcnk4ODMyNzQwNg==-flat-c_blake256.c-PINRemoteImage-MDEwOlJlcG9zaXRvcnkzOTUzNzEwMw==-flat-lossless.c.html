
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.805708013172337%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_blake256.c</h3>
            <pre><code>1  #include <string.h>
2  #include <stdio.h>
3  #include <stdint.h>
4  #include "c_blake256.h"
5  #define U8TO32(p) \
6      (((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) |    \
7       ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))
8  #define U32TO8(p, v) \
9      (p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
10      (p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );
11  const uint8_t sigma[][16] = {
12      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},
13      {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},
14      {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},
15      { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8},
16      { 9, 0, 5, 7, 2, 4,10,15,14, 1,11,12, 6, 8, 3,13},
17      { 2,12, 6,10, 0,11, 8, 3, 4,13, 7, 5,15,14, 1, 9},
18      {12, 5, 1,15,14,13, 4,10, 0, 7, 6, 3, 9, 2, 8,11},
19      {13,11, 7,14,12, 1, 3, 9, 5, 0,15, 4, 8, 6, 2,10},
20      { 6,15,14, 9,11, 3, 0, 8,12, 2,13, 7, 1, 4,10, 5},
21      {10, 2, 8, 4, 7, 6, 1, 5,15,11, 9,14, 3,12,13, 0},
22      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},
23      {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},
24      {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},
25      { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8}
26  };
27  const uint32_t cst[16] = {
28      0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
29      0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
30      0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
31      0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
32  };
33  static const uint8_t padding[] = {
34      0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
35      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
36  };
37  void blake256_compress(state *S, const uint8_t *block) {
38      uint32_t v[16], m[16], i;
39  #define ROT(x,n) (((x)<<(32-n))|((x)>>(n)))
40  #define G(a,b,c,d,e)                                      \
41      v[a] += (m[sigma[i][e]] ^ cst[sigma[i][e+1]]) + v[b]; \
42      v[d] = ROT(v[d] ^ v[a],16);                           \
43      v[c] += v[d];                                         \
44      v[b] = ROT(v[b] ^ v[c],12);                           \
45      v[a] += (m[sigma[i][e+1]] ^ cst[sigma[i][e]])+v[b];   \
46      v[d] = ROT(v[d] ^ v[a], 8);                           \
47      v[c] += v[d];                                         \
48      v[b] = ROT(v[b] ^ v[c], 7);
49      for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);
50      for (i = 0; i < 8;  ++i) v[i] = S->h[i];
51      v[ 8] = S->s[0] ^ 0x243F6A88;
52      v[ 9] = S->s[1] ^ 0x85A308D3;
53      v[10] = S->s[2] ^ 0x13198A2E;
54      v[11] = S->s[3] ^ 0x03707344;
55      v[12] = 0xA4093822;
56      v[13] = 0x299F31D0;
57      v[14] = 0x082EFA98;
58      v[15] = 0xEC4E6C89;
59      if (S->nullt == 0) {
60          v[12] ^= S->t[0];
61          v[13] ^= S->t[0];
62          v[14] ^= S->t[1];
63          v[15] ^= S->t[1];
64      }
65      for (i = 0; i < 14; ++i) {
66          G(0, 4,  8, 12,  0);
67          G(1, 5,  9, 13,  2);
68          G(2, 6, 10, 14,  4);
69          G(3, 7, 11, 15,  6);
70          G(3, 4,  9, 14, 14);
71          G(2, 7,  8, 13, 12);
72          G(0, 5, 10, 15,  8);
73          G(1, 6, 11, 12, 10);
74      }
75      for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];
76      for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];
77  }
78  void blake256_init(state *S) {
79      S->h[0] = 0x6A09E667;
80      S->h[1] = 0xBB67AE85;
81      S->h[2] = 0x3C6EF372;
82      S->h[3] = 0xA54FF53A;
83      S->h[4] = 0x510E527F;
84      S->h[5] = 0x9B05688C;
<span onclick='openModal()' class='match'>85      S->h[6] = 0x1F83D9AB;
86      S->h[7] = 0x5BE0CD19;
87      S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
88      S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
89  }
</span>90  void blake224_init(state *S) {
91      S->h[0] = 0xC1059ED8;
92      S->h[1] = 0x367CD507;
93      S->h[2] = 0x3070DD17;
94      S->h[3] = 0xF70E5939;
95      S->h[4] = 0xFFC00B31;
96      S->h[5] = 0x68581511;
97      S->h[6] = 0x64F98FA7;
98      S->h[7] = 0xBEFA4FA4;
99      S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
100      S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
101  }
102  void blake256_update(state *S, const uint8_t *data, uint64_t datalen) {
103      int left = S->buflen >> 3;
104      int fill = 64 - left;
105      if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {
106          memcpy((void *) (S->buf + left), (void *) data, fill);
107          S->t[0] += 512;
108          if (S->t[0] == 0) S->t[1]++;
109          blake256_compress(S, S->buf);
110          data += fill;
111          datalen -= (fill << 3);
112          left = 0;
113      }
114      while (datalen >= 512) {
115          S->t[0] += 512;
116          if (S->t[0] == 0) S->t[1]++;
117          blake256_compress(S, data);
118          data += 64;
119          datalen -= 512;
120      }
121      if (datalen > 0) {
122          memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);
123          S->buflen = (left << 3) + (int) datalen;
124      } else {
125          S->buflen = 0;
126      }
127  }
128  void blake224_update(state *S, const uint8_t *data, uint64_t datalen) {
129      blake256_update(S, data, datalen);
130  }
131  void blake256_final_h(state *S, uint8_t *digest, uint8_t pa, uint8_t pb) {
132      uint8_t msglen[8];
133      uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];
134      if (lo < (unsigned) S->buflen) hi++;
135      U32TO8(msglen + 0, hi);
136      U32TO8(msglen + 4, lo);
137      if (S->buflen == 440) { &bsol;* one padding byte */
138          S->t[0] -= 8;
139          blake256_update(S, &pa, 8);
140      } else {
141          if (S->buflen < 440) { &bsol;* enough space to fill the block  */
142              if (S->buflen == 0) S->nullt = 1;
143              S->t[0] -= 440 - S->buflen;
144              blake256_update(S, padding, 440 - S->buflen);
145          } else { &bsol;* need 2 compressions */
146              S->t[0] -= 512 - S->buflen;
147              blake256_update(S, padding, 512 - S->buflen);
148              S->t[0] -= 440;
149              blake256_update(S, padding + 1, 440);
150              S->nullt = 1;
151          }
152          blake256_update(S, &pb, 8);
153          S->t[0] -= 8;
154      }
155      S->t[0] -= 64;
156      blake256_update(S, msglen, 64);
157      U32TO8(digest +  0, S->h[0]);
158      U32TO8(digest +  4, S->h[1]);
159      U32TO8(digest +  8, S->h[2]);
160      U32TO8(digest + 12, S->h[3]);
161      U32TO8(digest + 16, S->h[4]);
162      U32TO8(digest + 20, S->h[5]);
163      U32TO8(digest + 24, S->h[6]);
164      U32TO8(digest + 28, S->h[7]);
165  }
166  void blake256_final(state *S, uint8_t *digest) {
167      blake256_final_h(S, digest, 0x81, 0x01);
168  }
169  void blake224_final(state *S, uint8_t *digest) {
170      blake256_final_h(S, digest, 0x80, 0x00);
171  }
172  void blake256_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {
173      state S;
174      blake256_init(&S);
175      blake256_update(&S, in, inlen * 8);
176      blake256_final(&S, out);
177  }
178  void blake224_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {
179      state S;
180      blake224_init(&S);
181      blake224_update(&S, in, inlen * 8);
182      blake224_final(&S, out);
183  }
184  void hmac_blake256_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {
185      const uint8_t *key = _key;
186      uint8_t keyhash[32];
187      uint8_t pad[64];
188      uint64_t i;
189      if (keylen > 64) {
190          blake256_hash(keyhash, key, keylen);
191          key = keyhash;
192          keylen = 32;
193      }
194      blake256_init(&S->inner);
195      memset(pad, 0x36, 64);
196      for (i = 0; i < keylen; ++i) {
197          pad[i] ^= key[i];
198      }
199      blake256_update(&S->inner, pad, 512);
200      blake256_init(&S->outer);
201      memset(pad, 0x5c, 64);
202      for (i = 0; i < keylen; ++i) {
203          pad[i] ^= key[i];
204      }
205      blake256_update(&S->outer, pad, 512);
206      memset(keyhash, 0, 32);
207  }
208  void hmac_blake224_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {
209      const uint8_t *key = _key;
210      uint8_t keyhash[32];
211      uint8_t pad[64];
212      uint64_t i;
213      if (keylen > 64) {
214          blake256_hash(keyhash, key, keylen);
215          key = keyhash;
216          keylen = 28;
217      }
218      blake224_init(&S->inner);
219      memset(pad, 0x36, 64);
220      for (i = 0; i < keylen; ++i) {
221          pad[i] ^= key[i];
222      }
223      blake224_update(&S->inner, pad, 512);
224      blake224_init(&S->outer);
225      memset(pad, 0x5c, 64);
226      for (i = 0; i < keylen; ++i) {
227          pad[i] ^= key[i];
228      }
229      blake224_update(&S->outer, pad, 512);
230      memset(keyhash, 0, 32);
231  }
232  void hmac_blake256_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {
233    blake256_update(&S->inner, data, datalen);
234  }
235  void hmac_blake224_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {
236    blake224_update(&S->inner, data, datalen);
237  }
238  void hmac_blake256_final(hmac_state *S, uint8_t *digest) {
239      uint8_t ihash[32];
240      blake256_final(&S->inner, ihash);
241      blake256_update(&S->outer, ihash, 256);
242      blake256_final(&S->outer, digest);
243      memset(ihash, 0, 32);
244  }
245  void hmac_blake224_final(hmac_state *S, uint8_t *digest) {
246      uint8_t ihash[32];
247      blake224_final(&S->inner, ihash);
248      blake224_update(&S->outer, ihash, 224);
249      blake224_final(&S->outer, digest);
250      memset(ihash, 0, 32);
251  }
252  void hmac_blake256_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {
253      hmac_state S;
254      hmac_blake256_init(&S, key, keylen);
255      hmac_blake256_update(&S, in, inlen * 8);
256      hmac_blake256_final(&S, out);
257  }
258  void hmac_blake224_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {
259      hmac_state S;
260      hmac_blake224_init(&S, key, keylen);
261      hmac_blake224_update(&S, in, inlen * 8);
262      hmac_blake224_final(&S, out);
263  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include <assert.h>
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dec/vp8li_dec.h"
6  #include "src/utils/endian_inl_utils.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
10    return (((a0 ^ a1) & 0xfefefefeu) >> 1) + (a0 & a1);
11  }
12  static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
13    return Average2(Average2(a0, a2), a1);
14  }
15  static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
16                                       uint32_t a2, uint32_t a3) {
17    return Average2(Average2(a0, a1), Average2(a2, a3));
18  }
19  static WEBP_INLINE uint32_t Clip255(uint32_t a) {
20    if (a < 256) {
21      return a;
22    }
23    return ~a >> 24;
24  }
25  static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
26    return Clip255(a + b - c);
27  }
28  static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
29                                                     uint32_t c2) {
30    const int a = AddSubtractComponentFull(c0 >> 24, c1 >> 24, c2 >> 24);
31    const int r = AddSubtractComponentFull((c0 >> 16) & 0xff,
32                                           (c1 >> 16) & 0xff,
33                                           (c2 >> 16) & 0xff);
34    const int g = AddSubtractComponentFull((c0 >> 8) & 0xff,
35                                           (c1 >> 8) & 0xff,
36                                           (c2 >> 8) & 0xff);
37    const int b = AddSubtractComponentFull(c0 & 0xff, c1 & 0xff, c2 & 0xff);
38    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
39  }
40  static WEBP_INLINE int AddSubtractComponentHalf(int a, int b) {
41    return Clip255(a + (a - b) / 2);
42  }
43  static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
44                                                     uint32_t c2) {
45    const uint32_t ave = Average2(c0, c1);
46    const int a = AddSubtractComponentHalf(ave >> 24, c2 >> 24);
47    const int r = AddSubtractComponentHalf((ave >> 16) & 0xff, (c2 >> 16) & 0xff);
48    const int g = AddSubtractComponentHalf((ave >> 8) & 0xff, (c2 >> 8) & 0xff);
49    const int b = AddSubtractComponentHalf((ave >> 0) & 0xff, (c2 >> 0) & 0xff);
50    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
51  }
52  #if defined(__arm__) && defined(__GNUC__) && LOCAL_GCC_VERSION <= 0x409
53  # define LOCAL_INLINE __attribute__ ((noinline))
54  #else
55  # define LOCAL_INLINE WEBP_INLINE
56  #endif
57  static LOCAL_INLINE int Sub3(int a, int b, int c) {
58    const int pb = b - c;
59    const int pa = a - c;
60    return abs(pb) - abs(pa);
61  }
62  #undef LOCAL_INLINE
63  static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
64    const int pa_minus_pb =
65        Sub3((a >> 24)       , (b >> 24)       , (c >> 24)       ) +
66        Sub3((a >> 16) & 0xff, (b >> 16) & 0xff, (c >> 16) & 0xff) +
67        Sub3((a >>  8) & 0xff, (b >>  8) & 0xff, (c >>  8) & 0xff) +
68        Sub3((a      ) & 0xff, (b      ) & 0xff, (c      ) & 0xff);
69    return (pa_minus_pb <= 0) ? a : b;
70  }
71  static uint32_t Predictor0_C(uint32_t left, const uint32_t* const top) {
72    (void)top;
73    (void)left;
74    return ARGB_BLACK;
75  }
76  static uint32_t Predictor1_C(uint32_t left, const uint32_t* const top) {
77    (void)top;
78    return left;
79  }
80  static uint32_t Predictor2_C(uint32_t left, const uint32_t* const top) {
81    (void)left;
82    return top[0];
83  }
84  static uint32_t Predictor3_C(uint32_t left, const uint32_t* const top) {
85    (void)left;
86    return top[1];
87  }
88  static uint32_t Predictor4_C(uint32_t left, const uint32_t* const top) {
89    (void)left;
90    return top[-1];
91  }
92  static uint32_t Predictor5_C(uint32_t left, const uint32_t* const top) {
93    const uint32_t pred = Average3(left, top[0], top[1]);
94    return pred;
95  }
96  static uint32_t Predictor6_C(uint32_t left, const uint32_t* const top) {
97    const uint32_t pred = Average2(left, top[-1]);
98    return pred;
99  }
100  static uint32_t Predictor7_C(uint32_t left, const uint32_t* const top) {
101    const uint32_t pred = Average2(left, top[0]);
102    return pred;
103  }
104  static uint32_t Predictor8_C(uint32_t left, const uint32_t* const top) {
105    const uint32_t pred = Average2(top[-1], top[0]);
106    (void)left;
107    return pred;
108  }
109  static uint32_t Predictor9_C(uint32_t left, const uint32_t* const top) {
110    const uint32_t pred = Average2(top[0], top[1]);
111    (void)left;
112    return pred;
113  }
114  static uint32_t Predictor10_C(uint32_t left, const uint32_t* const top) {
115    const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
116    return pred;
117  }
118  static uint32_t Predictor11_C(uint32_t left, const uint32_t* const top) {
119    const uint32_t pred = Select(top[0], left, top[-1]);
120    return pred;
121  }
122  static uint32_t Predictor12_C(uint32_t left, const uint32_t* const top) {
123    const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
124    return pred;
125  }
126  static uint32_t Predictor13_C(uint32_t left, const uint32_t* const top) {
127    const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
128    return pred;
129  }
130  static void PredictorAdd0_C(const uint32_t* in, const uint32_t* upper,
131                              int num_pixels, uint32_t* out) {
132    int x;
133    (void)upper;
134    for (x = 0; x < num_pixels; ++x) out[x] = VP8LAddPixels(in[x], ARGB_BLACK);
135  }
136  static void PredictorAdd1_C(const uint32_t* in, const uint32_t* upper,
137                              int num_pixels, uint32_t* out) {
138    int i;
139    uint32_t left = out[-1];
140    (void)upper;
141    for (i = 0; i < num_pixels; ++i) {
142      out[i] = left = VP8LAddPixels(in[i], left);
143    }
144  }
145  GENERATE_PREDICTOR_ADD(Predictor2_C, PredictorAdd2_C)
146  GENERATE_PREDICTOR_ADD(Predictor3_C, PredictorAdd3_C)
147  GENERATE_PREDICTOR_ADD(Predictor4_C, PredictorAdd4_C)
148  GENERATE_PREDICTOR_ADD(Predictor5_C, PredictorAdd5_C)
149  GENERATE_PREDICTOR_ADD(Predictor6_C, PredictorAdd6_C)
150  GENERATE_PREDICTOR_ADD(Predictor7_C, PredictorAdd7_C)
151  GENERATE_PREDICTOR_ADD(Predictor8_C, PredictorAdd8_C)
152  GENERATE_PREDICTOR_ADD(Predictor9_C, PredictorAdd9_C)
153  GENERATE_PREDICTOR_ADD(Predictor10_C, PredictorAdd10_C)
154  GENERATE_PREDICTOR_ADD(Predictor11_C, PredictorAdd11_C)
155  GENERATE_PREDICTOR_ADD(Predictor12_C, PredictorAdd12_C)
156  GENERATE_PREDICTOR_ADD(Predictor13_C, PredictorAdd13_C)
157  static void PredictorInverseTransform_C(const VP8LTransform* const transform,
158                                          int y_start, int y_end,
159                                          const uint32_t* in, uint32_t* out) {
160    const int width = transform->xsize_;
161    if (y_start == 0) {  
162      PredictorAdd0_C(in, NULL, 1, out);
163      PredictorAdd1_C(in + 1, NULL, width - 1, out + 1);
164      in += width;
165      out += width;
166      ++y_start;
167    }
168    {
169      int y = y_start;
170      const int tile_width = 1 << transform->bits_;
171      const int mask = tile_width - 1;
172      const int tiles_per_row = VP8LSubSampleSize(width, transform->bits_);
173      const uint32_t* pred_mode_base =
174          transform->data_ + (y >> transform->bits_) * tiles_per_row;
175      while (y < y_end) {
176        const uint32_t* pred_mode_src = pred_mode_base;
177        int x = 1;
178        PredictorAdd2_C(in, out - width, 1, out);
179        while (x < width) {
180          const VP8LPredictorAddSubFunc pred_func =
181              VP8LPredictorsAdd[((*pred_mode_src++) >> 8) & 0xf];
182          int x_end = (x & ~mask) + tile_width;
183          if (x_end > width) x_end = width;
184          pred_func(in + x, out + x - width, x_end - x, out + x);
185          x = x_end;
186        }
187        in += width;
188        out += width;
189        ++y;
190        if ((y & mask) == 0) {   
191          pred_mode_base += tiles_per_row;
192        }
193      }
194    }
195  }
196  void VP8LAddGreenToBlueAndRed_C(const uint32_t* src, int num_pixels,
197                                  uint32_t* dst) {
198    int i;
199    for (i = 0; i < num_pixels; ++i) {
200      const uint32_t argb = src[i];
201      const uint32_t green = ((argb >> 8) & 0xff);
202      uint32_t red_blue = (argb & 0x00ff00ffu);
203      red_blue += (green << 16) | green;
204      red_blue &= 0x00ff00ffu;
205      dst[i] = (argb & 0xff00ff00u) | red_blue;
206    }
207  }
208  static WEBP_INLINE int ColorTransformDelta(int8_t color_pred,
209                                             int8_t color) {
210    return ((int)color_pred * color) >> 5;
211  }
212  static WEBP_INLINE void ColorCodeToMultipliers(uint32_t color_code,
213                                                 VP8LMultipliers* const m) {
214    m->green_to_red_  = (color_code >>  0) & 0xff;
215    m->green_to_blue_ = (color_code >>  8) & 0xff;
216    m->red_to_blue_   = (color_code >> 16) & 0xff;
217  }
218  void VP8LTransformColorInverse_C(const VP8LMultipliers* const m,
219                                   const uint32_t* src, int num_pixels,
220                                   uint32_t* dst) {
221    int i;
222    for (i = 0; i < num_pixels; ++i) {
223      const uint32_t argb = src[i];
224      const int8_t green = (int8_t)(argb >> 8);
225      const uint32_t red = argb >> 16;
226      int new_red = red & 0xff;
227      int new_blue = argb & 0xff;
228      new_red += ColorTransformDelta(m->green_to_red_, green);
229      new_red &= 0xff;
230      new_blue += ColorTransformDelta(m->green_to_blue_, green);
231      new_blue += ColorTransformDelta(m->red_to_blue_, (int8_t)new_red);
232      new_blue &= 0xff;
233      dst[i] = (argb & 0xff00ff00u) | (new_red << 16) | (new_blue);
234    }
235  }
236  static void ColorSpaceInverseTransform_C(const VP8LTransform* const transform,
237                                           int y_start, int y_end,
238                                           const uint32_t* src, uint32_t* dst) {
239    const int width = transform->xsize_;
240    const int tile_width = 1 << transform->bits_;
241    const int mask = tile_width - 1;
242    const int safe_width = width & ~mask;
243    const int remaining_width = width - safe_width;
244    const int tiles_per_row = VP8LSubSampleSize(width, transform->bits_);
245    int y = y_start;
246    const uint32_t* pred_row =
247        transform->data_ + (y >> transform->bits_) * tiles_per_row;
248    while (y < y_end) {
249      const uint32_t* pred = pred_row;
250      VP8LMultipliers m = { 0, 0, 0 };
251      const uint32_t* const src_safe_end = src + safe_width;
252      const uint32_t* const src_end = src + width;
253      while (src < src_safe_end) {
254        ColorCodeToMultipliers(*pred++, &m);
255        VP8LTransformColorInverse(&m, src, tile_width, dst);
256        src += tile_width;
257        dst += tile_width;
258      }
259      if (src < src_end) {  
260        ColorCodeToMultipliers(*pred++, &m);
261        VP8LTransformColorInverse(&m, src, remaining_width, dst);
262        src += remaining_width;
263        dst += remaining_width;
264      }
265      ++y;
266      if ((y & mask) == 0) pred_row += tiles_per_row;
267    }
268  }
269  #define COLOR_INDEX_INVERSE(FUNC_NAME, F_NAME, STATIC_DECL, TYPE, BIT_SUFFIX,  \
270                              GET_INDEX, GET_VALUE)                              \
271  static void F_NAME(const TYPE* src, const uint32_t* const color_map,           \
272                     TYPE* dst, int y_start, int y_end, int width) {             \
273    int y;                                                                       \
274    for (y = y_start; y < y_end; ++y) {                                          \
275      int x;                                                                     \
276      for (x = 0; x < width; ++x) {                                              \
277        *dst++ = GET_VALUE(color_map[GET_INDEX(*src++)]);                        \
278      }                                                                          \
279    }                                                                            \
280  }                                                                              \
281  STATIC_DECL void FUNC_NAME(const VP8LTransform* const transform,               \
282                             int y_start, int y_end, const TYPE* src,            \
283                             TYPE* dst) {                                        \
284    int y;                                                                       \
285    const int bits_per_pixel = 8 >> transform->bits_;                            \
286    const int width = transform->xsize_;                                         \
287    const uint32_t* const color_map = transform->data_;                          \
288    if (bits_per_pixel < 8) {                                                    \
289      const int pixels_per_byte = 1 << transform->bits_;                         \
290      const int count_mask = pixels_per_byte - 1;                                \
291      const uint32_t bit_mask = (1 << bits_per_pixel) - 1;                       \
292      for (y = y_start; y < y_end; ++y) {                                        \
293        uint32_t packed_pixels = 0;                                              \
294        int x;                                                                   \
295        for (x = 0; x < width; ++x) {                                            \
296            \
297            \
298            \
299            \
300          if ((x & count_mask) == 0) packed_pixels = GET_INDEX(*src++);          \
301          *dst++ = GET_VALUE(color_map[packed_pixels & bit_mask]);               \
302          packed_pixels >>= bits_per_pixel;                                      \
303        }                                                                        \
304      }                                                                          \
305    } else {                                                                     \
306      VP8LMapColor##BIT_SUFFIX(src, color_map, dst, y_start, y_end, width);      \
307    }                                                                            \
308  }
309  COLOR_INDEX_INVERSE(ColorIndexInverseTransform_C, MapARGB_C, static,
310                      uint32_t, 32b, VP8GetARGBIndex, VP8GetARGBValue)
311  COLOR_INDEX_INVERSE(VP8LColorIndexInverseTransformAlpha, MapAlpha_C, ,
312                      uint8_t, 8b, VP8GetAlphaIndex, VP8GetAlphaValue)
313  #undef COLOR_INDEX_INVERSE
314  void VP8LInverseTransform(const VP8LTransform* const transform,
315                            int row_start, int row_end,
316                            const uint32_t* const in, uint32_t* const out) {
317    const int width = transform->xsize_;
318    assert(row_start < row_end);
319    assert(row_end <= transform->ysize_);
320    switch (transform->type_) {
321      case SUBTRACT_GREEN:
322        VP8LAddGreenToBlueAndRed(in, (row_end - row_start) * width, out);
323        break;
324      case PREDICTOR_TRANSFORM:
325        PredictorInverseTransform_C(transform, row_start, row_end, in, out);
326        if (row_end != transform->ysize_) {
327          memcpy(out - width, out + (row_end - row_start - 1) * width,
328                 width * sizeof(*out));
329        }
330        break;
331      case CROSS_COLOR_TRANSFORM:
332        ColorSpaceInverseTransform_C(transform, row_start, row_end, in, out);
333        break;
334      case COLOR_INDEXING_TRANSFORM:
335        if (in == out && transform->bits_ > 0) {
336          const int out_stride = (row_end - row_start) * width;
337          const int in_stride = (row_end - row_start) *
338              VP8LSubSampleSize(transform->xsize_, transform->bits_);
339          uint32_t* const src = out + out_stride - in_stride;
340          memmove(src, out, in_stride * sizeof(*src));
341          ColorIndexInverseTransform_C(transform, row_start, row_end, src, out);
342        } else {
343          ColorIndexInverseTransform_C(transform, row_start, row_end, in, out);
344        }
345        break;
346    }
347  }
348  static int is_big_endian(void) {
349    static const union {
350      uint16_t w;
351      uint8_t b[2];
352    } tmp = { 1 };
353    return (tmp.b[0] != 1);
354  }
355  void VP8LConvertBGRAToRGB_C(const uint32_t* src,
356                              int num_pixels, uint8_t* dst) {
357    const uint32_t* const src_end = src + num_pixels;
358    while (src < src_end) {
359      const uint32_t argb = *src++;
360      *dst++ = (argb >> 16) & 0xff;
361      *dst++ = (argb >>  8) & 0xff;
362      *dst++ = (argb >>  0) & 0xff;
363    }
364  }
365  void VP8LConvertBGRAToRGBA_C(const uint32_t* src,
366                               int num_pixels, uint8_t* dst) {
367    const uint32_t* const src_end = src + num_pixels;
368    while (src < src_end) {
<span onclick='openModal()' class='match'>369      const uint32_t argb = *src++;
370      *dst++ = (argb >> 16) & 0xff;
371      *dst++ = (argb >>  8) & 0xff;
372      *dst++ = (argb >>  0) & 0xff;
373      *dst++ = (argb >> 24) & 0xff;
374    }
</span>375  }
376  void VP8LConvertBGRAToRGBA4444_C(const uint32_t* src,
377                                   int num_pixels, uint8_t* dst) {
378    const uint32_t* const src_end = src + num_pixels;
379    while (src < src_end) {
380      const uint32_t argb = *src++;
381      const uint8_t rg = ((argb >> 16) & 0xf0) | ((argb >> 12) & 0xf);
382      const uint8_t ba = ((argb >>  0) & 0xf0) | ((argb >> 28) & 0xf);
383  #if (WEBP_SWAP_16BIT_CSP == 1)
384      *dst++ = ba;
385      *dst++ = rg;
386  #else
387      *dst++ = rg;
388      *dst++ = ba;
389  #endif
390    }
391  }
392  void VP8LConvertBGRAToRGB565_C(const uint32_t* src,
393                                 int num_pixels, uint8_t* dst) {
394    const uint32_t* const src_end = src + num_pixels;
395    while (src < src_end) {
396      const uint32_t argb = *src++;
397      const uint8_t rg = ((argb >> 16) & 0xf8) | ((argb >> 13) & 0x7);
398      const uint8_t gb = ((argb >>  5) & 0xe0) | ((argb >>  3) & 0x1f);
399  #if (WEBP_SWAP_16BIT_CSP == 1)
400      *dst++ = gb;
401      *dst++ = rg;
402  #else
403      *dst++ = rg;
404      *dst++ = gb;
405  #endif
406    }
407  }
408  void VP8LConvertBGRAToBGR_C(const uint32_t* src,
409                              int num_pixels, uint8_t* dst) {
410    const uint32_t* const src_end = src + num_pixels;
411    while (src < src_end) {
412      const uint32_t argb = *src++;
413      *dst++ = (argb >>  0) & 0xff;
414      *dst++ = (argb >>  8) & 0xff;
415      *dst++ = (argb >> 16) & 0xff;
416    }
417  }
418  static void CopyOrSwap(const uint32_t* src, int num_pixels, uint8_t* dst,
419                         int swap_on_big_endian) {
420    if (is_big_endian() == swap_on_big_endian) {
421      const uint32_t* const src_end = src + num_pixels;
422      while (src < src_end) {
423        const uint32_t argb = *src++;
424        WebPUint32ToMem(dst, BSwap32(argb));
425        dst += sizeof(argb);
426      }
427    } else {
428      memcpy(dst, src, num_pixels * sizeof(*src));
429    }
430  }
431  void VP8LConvertFromBGRA(const uint32_t* const in_data, int num_pixels,
432                           WEBP_CSP_MODE out_colorspace, uint8_t* const rgba) {
433    switch (out_colorspace) {
434      case MODE_RGB:
435        VP8LConvertBGRAToRGB(in_data, num_pixels, rgba);
436        break;
437      case MODE_RGBA:
438        VP8LConvertBGRAToRGBA(in_data, num_pixels, rgba);
439        break;
440      case MODE_rgbA:
441        VP8LConvertBGRAToRGBA(in_data, num_pixels, rgba);
442        WebPApplyAlphaMultiply(rgba, 0, num_pixels, 1, 0);
443        break;
444      case MODE_BGR:
445        VP8LConvertBGRAToBGR(in_data, num_pixels, rgba);
446        break;
447      case MODE_BGRA:
448        CopyOrSwap(in_data, num_pixels, rgba, 1);
449        break;
450      case MODE_bgrA:
451        CopyOrSwap(in_data, num_pixels, rgba, 1);
452        WebPApplyAlphaMultiply(rgba, 0, num_pixels, 1, 0);
453        break;
454      case MODE_ARGB:
455        CopyOrSwap(in_data, num_pixels, rgba, 0);
456        break;
457      case MODE_Argb:
458        CopyOrSwap(in_data, num_pixels, rgba, 0);
459        WebPApplyAlphaMultiply(rgba, 1, num_pixels, 1, 0);
460        break;
461      case MODE_RGBA_4444:
462        VP8LConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
463        break;
464      case MODE_rgbA_4444:
465        VP8LConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
466        WebPApplyAlphaMultiply4444(rgba, num_pixels, 1, 0);
467        break;
468      case MODE_RGB_565:
469        VP8LConvertBGRAToRGB565(in_data, num_pixels, rgba);
470        break;
471      default:
472        assert(0);          
473    }
474  }
475  VP8LProcessDecBlueAndRedFunc VP8LAddGreenToBlueAndRed;
476  VP8LPredictorAddSubFunc VP8LPredictorsAdd[16];
477  VP8LPredictorFunc VP8LPredictors[16];
478  VP8LPredictorAddSubFunc VP8LPredictorsAdd_C[16];
479  VP8LPredictorFunc VP8LPredictors_C[16];
480  VP8LTransformColorInverseFunc VP8LTransformColorInverse;
481  VP8LConvertFunc VP8LConvertBGRAToRGB;
482  VP8LConvertFunc VP8LConvertBGRAToRGBA;
483  VP8LConvertFunc VP8LConvertBGRAToRGBA4444;
484  VP8LConvertFunc VP8LConvertBGRAToRGB565;
485  VP8LConvertFunc VP8LConvertBGRAToBGR;
486  VP8LMapARGBFunc VP8LMapColor32b;
487  VP8LMapAlphaFunc VP8LMapColor8b;
488  extern void VP8LDspInitSSE2(void);
489  extern void VP8LDspInitNEON(void);
490  extern void VP8LDspInitMIPSdspR2(void);
491  extern void VP8LDspInitMSA(void);
492  #define COPY_PREDICTOR_ARRAY(IN, OUT) do {                \
493    (OUT)[0] = IN##0_C;                                     \
494    (OUT)[1] = IN##1_C;                                     \
495    (OUT)[2] = IN##2_C;                                     \
496    (OUT)[3] = IN##3_C;                                     \
497    (OUT)[4] = IN##4_C;                                     \
498    (OUT)[5] = IN##5_C;                                     \
499    (OUT)[6] = IN##6_C;                                     \
500    (OUT)[7] = IN##7_C;                                     \
501    (OUT)[8] = IN##8_C;                                     \
502    (OUT)[9] = IN##9_C;                                     \
503    (OUT)[10] = IN##10_C;                                   \
504    (OUT)[11] = IN##11_C;                                   \
505    (OUT)[12] = IN##12_C;                                   \
506    (OUT)[13] = IN##13_C;                                   \
507    (OUT)[14] = IN##0_C; &bsol;* <- padding security sentinels*/ \
508    (OUT)[15] = IN##0_C;                                    \
509  } while (0);
510  WEBP_DSP_INIT_FUNC(VP8LDspInit) {
511    COPY_PREDICTOR_ARRAY(Predictor, VP8LPredictors)
512    COPY_PREDICTOR_ARRAY(Predictor, VP8LPredictors_C)
513    COPY_PREDICTOR_ARRAY(PredictorAdd, VP8LPredictorsAdd)
514    COPY_PREDICTOR_ARRAY(PredictorAdd, VP8LPredictorsAdd_C)
515  #if !WEBP_NEON_OMIT_C_CODE
516    VP8LAddGreenToBlueAndRed = VP8LAddGreenToBlueAndRed_C;
517    VP8LTransformColorInverse = VP8LTransformColorInverse_C;
518    VP8LConvertBGRAToRGBA = VP8LConvertBGRAToRGBA_C;
519    VP8LConvertBGRAToRGB = VP8LConvertBGRAToRGB_C;
520    VP8LConvertBGRAToBGR = VP8LConvertBGRAToBGR_C;
521  #endif
522    VP8LConvertBGRAToRGBA4444 = VP8LConvertBGRAToRGBA4444_C;
523    VP8LConvertBGRAToRGB565 = VP8LConvertBGRAToRGB565_C;
524    VP8LMapColor32b = MapARGB_C;
525    VP8LMapColor8b = MapAlpha_C;
526    if (VP8GetCPUInfo != NULL) {
527  #if defined(WEBP_USE_SSE2)
528      if (VP8GetCPUInfo(kSSE2)) {
529        VP8LDspInitSSE2();
530      }
531  #endif
532  #if defined(WEBP_USE_MIPS_DSP_R2)
533      if (VP8GetCPUInfo(kMIPSdspR2)) {
534        VP8LDspInitMIPSdspR2();
535      }
536  #endif
537  #if defined(WEBP_USE_MSA)
538      if (VP8GetCPUInfo(kMSA)) {
539        VP8LDspInitMSA();
540      }
541  #endif
542    }
543  #if defined(WEBP_USE_NEON)
544    if (WEBP_NEON_OMIT_C_CODE ||
545        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
546      VP8LDspInitNEON();
547    }
548  #endif
549    assert(VP8LAddGreenToBlueAndRed != NULL);
550    assert(VP8LTransformColorInverse != NULL);
551    assert(VP8LConvertBGRAToRGBA != NULL);
552    assert(VP8LConvertBGRAToRGB != NULL);
553    assert(VP8LConvertBGRAToBGR != NULL);
554    assert(VP8LConvertBGRAToRGBA4444 != NULL);
555    assert(VP8LConvertBGRAToRGB565 != NULL);
556    assert(VP8LMapColor32b != NULL);
557    assert(VP8LMapColor8b != NULL);
558  }
559  #undef COPY_PREDICTOR_ARRAY
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-c_blake256.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless.c</div>
                </div>
                <div class="column column_space"><pre><code>85      S->h[6] = 0x1F83D9AB;
86      S->h[7] = 0x5BE0CD19;
87      S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
88      S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
89  }
</pre></code></div>
                <div class="column column_space"><pre><code>369      const uint32_t argb = *src++;
370      *dst++ = (argb >> 16) & 0xff;
371      *dst++ = (argb >>  8) & 0xff;
372      *dst++ = (argb >>  0) & 0xff;
373      *dst++ = (argb >> 24) & 0xff;
374    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    