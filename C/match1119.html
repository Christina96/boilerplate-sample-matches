<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-request.c &amp; inf-adopted-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-request.c &amp; inf-adopted-session.c
      </h3>
<h1 align="center">
        9.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-request.c (40.0%)<th>inf-adopted-session.c (5.5354996%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(129-161)<td><a href="#" name="0">(967-999)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(103-123)<td><a href="#" name="1">(946-966)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(82-98)<td><a href="#" name="2">(926-940)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-request.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/server/infd-request.h&gt;
#include &lt;libinfinity/common/inf-request.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
typedef struct _InfdRequestPrivate InfdRequestPrivate;
struct _InfdRequestPrivate {
  gchar* type;
  guint node_id;
  InfXmlConnection* requestor;
  gboolean finished;
};
enum {
  PROP_0,
  PROP_TYPE,
  PROP_NODE_ID,
  PROP_REQUESTOR,
  PROP_PROGRESS
};
#define INFD_REQUEST_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_REQUEST, InfdRequestPrivate))
static void infd_request_request_iface_init(InfRequestInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfdRequest, infd_request, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdRequest)
  G_IMPLEMENT_INTERFACE(INF_TYPE_REQUEST, infd_request_request_iface_init))
static void
infd_request_init(InfdRequest* request)
{
  InfdRequestPrivate* priv;
  priv = INFD_REQUEST_PRIVATE(request);
  priv-&gt;type = NULL;
  priv-&gt;node_id = G_MAXUINT;
  priv-&gt;requestor = NULL;
  priv-&gt;finished = FALSE;
}
static void
infd_request_dispose(GObject* object)
{
  InfdRequest* request;
  InfdRequestPrivate* priv;
<a name="2"></a>  request = INFD_REQUEST(object);
  priv = INFD_REQUEST_PRIVATE(request);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(priv-&gt;requestor != NULL)
  {
    g_object_unref(priv-&gt;requestor);
    priv-&gt;requestor = NULL;
  }
  G_OBJECT_CLASS(infd_request_parent_class)-&gt;dispose(object);
}
static void
infd_request_finalize(GObject* object)
{
  InfdRequest* request;
  InfdRequestPrivate* priv;
  request = INFD_REQUEST(object);
  priv = INFD_REQUEST_PRIVATE(request);</b></font>
<a name="1"></a>  g_free(priv-&gt;type);
  G_OBJECT_CLASS(infd_request_parent_class)-&gt;finalize(object);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
infd_request_set_property(GObject* object,
                          guint prop_id,
                          const GValue* value,
                          GParamSpec* pspec)
{
  InfdRequest* request;
  InfdRequestPrivate* priv;
  request = INFD_REQUEST(object);
  priv = INFD_REQUEST_PRIVATE(request);
  switch(prop_id)
  {
  case PROP_TYPE:
    g_assert(priv-&gt;type == NULL);     priv-&gt;type = g_value_dup_string(value);
    break;
  case PROP_NODE_ID:</b></font>
    g_assert(priv-&gt;node_id == G_MAXUINT);     priv-&gt;node_id = g_value_get_uint(value);
<a name="0"></a>    break;
  case PROP_REQUESTOR:
    g_assert(priv-&gt;requestor == NULL); <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;requestor = g_value_dup_object(value);
    break;
  case PROP_PROGRESS:
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_request_get_property(GObject* object,
                          guint prop_id,
                          GValue* value,
                          GParamSpec* pspec)
{
  InfdRequest* request;
  InfdRequestPrivate* priv;
  request = INFD_REQUEST(object);
  priv = INFD_REQUEST_PRIVATE(request);
  switch(prop_id)
  {
  case PROP_TYPE:
    g_value_set_string(value, priv-&gt;type);
    break;
  case PROP_NODE_ID:
    g_value_set_uint(value, priv-&gt;node_id);
    break;
  case PROP_REQUESTOR:
    g_value_set_object(value, priv-&gt;requestor);
    break;</b></font>
  case PROP_PROGRESS:
    if(priv-&gt;finished == TRUE)
      g_value_set_double(value, 1.0);
    else
      g_value_set_double(value, 0.0);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_request_request_finished(InfRequest* request,
                              const InfRequestResult* result,
                              const GError* error)
{
  InfdRequestPrivate* priv;
  priv = INFD_REQUEST_PRIVATE(request);
  priv-&gt;finished = TRUE;
  g_object_notify(G_OBJECT(request), "progress");
}
static gboolean
infd_request_request_is_local(InfRequest* request)
{
  InfdRequestPrivate* priv;
  priv = INFD_REQUEST_PRIVATE(request);
  if(priv-&gt;requestor != NULL)
    return FALSE;
  return TRUE;
}
static void
infd_request_class_init(InfdRequestClass* request_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(request_class);
  object_class-&gt;dispose = infd_request_dispose;
  object_class-&gt;finalize = infd_request_finalize;
  object_class-&gt;set_property = infd_request_set_property;
  object_class-&gt;get_property = infd_request_get_property;
  g_object_class_install_property(
    object_class,
    PROP_REQUESTOR,
    g_param_spec_object(
      "requestor",
      "Requestor",
      "The connection making the request",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_NODE_ID,
    g_param_spec_uint(
      "node-id",
      "Node ID",
      "The ID of the node affected by the request",
      0,
      G_MAXUINT,
      G_MAXUINT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_override_property(object_class, PROP_TYPE, "type");
  g_object_class_override_property(object_class, PROP_PROGRESS, "progress");
}
static void
infd_request_request_iface_init(InfRequestInterface* iface)
{
  iface-&gt;finished = infd_request_request_finished;
  iface-&gt;is_local = infd_request_request_is_local;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
typedef struct _InfAdoptedSessionToXmlSyncForeachData
  InfAdoptedSessionToXmlSyncForeachData;
struct _InfAdoptedSessionToXmlSyncForeachData {
  InfAdoptedSession* session;
  xmlNodePtr parent_xml;
};
typedef struct _InfAdoptedSessionLocalUser InfAdoptedSessionLocalUser;
struct _InfAdoptedSessionLocalUser {
  InfAdoptedUser* user;
  InfAdoptedStateVector* last_send_vector;
  time_t noop_time; };
typedef struct _InfAdoptedSessionPrivate InfAdoptedSessionPrivate;
struct _InfAdoptedSessionPrivate {
  InfIo* io;
  guint max_total_log_size;
  InfAdoptedAlgorithm* algorithm;
  GSList* local_users; 
  InfIoTimeout* noop_timeout;
  InfAdoptedSessionLocalUser* next_noop_user;
  GPtrArray* request_buffer;
};
enum {
  PROP_0,
  PROP_IO,
  PROP_MAX_TOTAL_LOG_SIZE,
  PROP_ALGORITHM
};
enum {
  CHECK_REQUEST,
  LAST_SIGNAL
};
#define INF_ADOPTED_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_SESSION, InfAdoptedSessionPrivate))
static guint session_signals[LAST_SIGNAL];
static GQuark inf_adopted_session_error_quark;
static const int INF_ADOPTED_SESSION_NOOP_INTERVAL = 30;
G_DEFINE_TYPE_WITH_CODE(InfAdoptedSession, inf_adopted_session, INF_TYPE_SESSION,
  G_ADD_PRIVATE(InfAdoptedSession))
static InfAdoptedSessionLocalUser*
inf_adopted_session_lookup_local_user(InfAdoptedSession* session,
                                      InfAdoptedUser* user)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionLocalUser* local;
  GSList* item;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfAdoptedSessionLocalUser*)item-&gt;data;
    if(local-&gt;user == user)
      return local;
  }
  return NULL;
}
static gboolean
inf_adopted_session_validate_request(InfAdoptedRequestLog* log,
                                     InfAdoptedRequest* request,
                                     GError** error)
{
  InfAdoptedStateVector* vector;
  guint user_id;
  guint n;
  guint begin;
  guint end;
  vector = inf_adopted_request_get_vector(request);
  user_id = inf_adopted_request_get_user_id(request);
  n = inf_adopted_state_vector_get(vector, user_id);
  begin = inf_adopted_request_log_get_begin(log);
  end = inf_adopted_request_log_get_end(log);
  if(end != n &amp;&amp; begin != end)
  {
    g_set_error(
      error,
      inf_adopted_session_error_quark,
      INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
      _("Request has index '%u', but index '%u' was expected"),
      n,
      inf_adopted_request_log_get_end(log)
    );
    return FALSE;
  }
  else
  {
    switch(inf_adopted_request_get_request_type(request))
    {
    case INF_ADOPTED_REQUEST_DO:
      return TRUE;
    case INF_ADOPTED_REQUEST_UNDO:
      if(inf_adopted_request_log_next_undo(log) == NULL)
      {
        g_set_error_literal(
          error,
          inf_adopted_session_error_quark,
          INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
          _("Undo received, but no previous request found")
        );
        return FALSE;
      }
      else
      {
        return TRUE;
      }
    case INF_ADOPTED_REQUEST_REDO:
      if(inf_adopted_request_log_next_redo(log) == NULL)
      {
        g_set_error_literal(
          error,
          inf_adopted_session_error_quark,
          INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
          _("Redo received, but no previous request found")
        );
        return FALSE;
      }
      else
      {
        return TRUE;
      }
    default:
      g_assert_not_reached();
      return FALSE;
    }
  }
}
static InfAdoptedUser*
inf_adopted_session_user_from_request_xml(InfAdoptedSession* session,
                                          xmlNodePtr xml,
                                          GError** error)
{
  InfUserTable* user_table;
  InfUser* user;
  guint user_id;
  user_table = inf_session_get_user_table(INF_SESSION(session));
  if(!inf_xml_util_get_attribute_uint_required(xml, "user", &amp;user_id, error))
    return FALSE;
  if(user_id == 0) return NULL;
  user = inf_user_table_lookup_user_by_id(user_table, user_id);
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_adopted_session_error_quark,
      INF_ADOPTED_SESSION_ERROR_NO_SUCH_USER,
      _("No such user with user ID '%u'"),
      user_id
    );
    return NULL;
  }
  g_assert(INF_ADOPTED_IS_USER(user));
  return INF_ADOPTED_USER(user);
}
static void
inf_adopted_session_noop_timeout_func(gpointer user_data)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  InfAdoptedOperation* op;
  InfAdoptedRequest* request;
  session = INF_ADOPTED_SESSION(user_data);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  priv-&gt;noop_timeout = NULL;
  g_assert(priv-&gt;next_noop_user != NULL);
  op = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
  request = inf_adopted_algorithm_generate_request(
    priv-&gt;algorithm,
    INF_ADOPTED_REQUEST_DO,
    priv-&gt;next_noop_user-&gt;user,
    op
  );
  g_object_unref(op);
  inf_adopted_session_broadcast_request(session, request);
  g_object_unref(request);
}
static InfAdoptedSessionLocalUser*
inf_adopted_session_find_next_noop_user(InfAdoptedSession* session)
{
  InfAdoptedSessionPrivate* priv;
  GSList* item;
  InfAdoptedSessionLocalUser* local;
  InfAdoptedSessionLocalUser* next_user;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  next_user = NULL;
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfAdoptedSessionLocalUser*)item-&gt;data;
    if(local-&gt;noop_time != 0)
      if(next_user == NULL || local-&gt;noop_time &lt; next_user-&gt;noop_time)
        next_user = local;
  }
  return next_user;
}
static void
inf_adopted_session_schedule_noop_timer(InfAdoptedSession* session)
{
  InfAdoptedSessionPrivate* priv;
  time_t current;
  time_t sched;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  if(priv-&gt;noop_timeout != NULL)
  {
    inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
    priv-&gt;noop_timeout = NULL;
  }
  if(priv-&gt;next_noop_user != NULL)
  {
    current = time(NULL);
    sched =
      priv-&gt;next_noop_user-&gt;noop_time + INF_ADOPTED_SESSION_NOOP_INTERVAL;
    if(sched &gt;= current)
      sched -= current;
    else
      sched = 0;
    priv-&gt;noop_timeout = inf_io_add_timeout(
      priv-&gt;io,
      sched * 1000,
      inf_adopted_session_noop_timeout_func,
      session,
      NULL
    );
  }
}
static void
inf_adopted_session_start_noop_timer(InfAdoptedSession* session,
                                     InfAdoptedSessionLocalUser* local)
{
  InfAdoptedSessionPrivate* priv;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  g_assert(local-&gt;noop_time == 0);
  local-&gt;noop_time = time(NULL);
  if(priv-&gt;noop_timeout == NULL)
  {
    priv-&gt;next_noop_user = inf_adopted_session_find_next_noop_user(session);
    g_assert(priv-&gt;next_noop_user != NULL);
    inf_adopted_session_schedule_noop_timer(session);
  }
}
static void
inf_adopted_session_stop_noop_timer(InfAdoptedSession* session,
                                    InfAdoptedSessionLocalUser* local)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionLocalUser* next_noop_user;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  if(local-&gt;noop_time &gt; 0)
  {
    local-&gt;noop_time = 0;
    next_noop_user = inf_adopted_session_find_next_noop_user(session);
    if(next_noop_user != priv-&gt;next_noop_user)
    {
      priv-&gt;next_noop_user = next_noop_user;
      inf_adopted_session_schedule_noop_timer(session);
    }
  }
}
static void
inf_adopted_session_broadcast_n_requests(InfAdoptedSession* session,
                                         InfAdoptedRequest* request,
                                         guint n)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionClass* session_class;
  InfUserTable* user_table;
  guint user_id;
  InfUser* user;
  InfAdoptedSessionLocalUser* local;
  xmlNodePtr xml;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
  g_assert(session_class-&gt;request_to_xml != NULL);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  user_id = inf_adopted_request_get_user_id(request);
  user = inf_user_table_lookup_user_by_id(user_table, user_id);
  g_assert(user != NULL);
  local = inf_adopted_session_lookup_local_user(
    session,
    INF_ADOPTED_USER(user)
  );
  g_assert(local != NULL);
  xml = xmlNewNode(NULL, (const xmlChar*)"request");
  session_class-&gt;request_to_xml(
    session,
    xml,
    request,
    local-&gt;last_send_vector,
    FALSE
  );
  if(n &gt; 1) inf_xml_util_set_attribute_uint(xml, "num", n);
  inf_session_send_to_subscriptions(INF_SESSION(session), xml);
  inf_adopted_state_vector_free(local-&gt;last_send_vector);
  local-&gt;last_send_vector = inf_adopted_state_vector_copy(
    inf_adopted_request_get_vector(request)
  );
  if(inf_adopted_request_affects_buffer(request) == TRUE)
    inf_adopted_state_vector_add(local-&gt;last_send_vector, user_id, n);
  inf_adopted_session_stop_noop_timer(session, local);
}
static gboolean
inf_adopted_session_process_request(InfAdoptedSession* session,
                                    InfAdoptedRequest* request,
                                    InfAdoptedUser* user,
                                    GError** error)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedStateVector* request_vector;
  InfAdoptedStateVector* current_vector;
  gboolean reject_request;
  GError* local_error;
  gboolean execute_result;
  xmlNodePtr reply_xml;
  gchar* request_str;
  gchar* current_str;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  request_vector = inf_adopted_request_get_vector(request);
  current_vector = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
  if(inf_adopted_state_vector_causally_before(request_vector, current_vector))
  {
    g_signal_emit(
      G_OBJECT(session),
      session_signals[CHECK_REQUEST],
      0,
      request,
      user,
      &amp;reject_request
    );
    local_error = NULL;
    if(reject_request)
    {
      g_set_error_literal(
        &amp;local_error,
        inf_adopted_session_error_quark,
        INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
        _("The request was rejected via the API")
      );
      execute_result = FALSE;
    }
    else
    {
      execute_result = inf_adopted_algorithm_execute_request(
        priv-&gt;algorithm,
        request,
        TRUE,
        &amp;local_error
      );
    }
    if(local_error != NULL)
    {
      if(inf_user_get_connection(INF_USER(user)) != NULL)
      {
        request_str = inf_adopted_state_vector_to_string(request_vector);
        current_str = inf_adopted_state_vector_to_string(current_vector);
        reply_xml = xmlNewNode(NULL, (const xmlChar*)"invalid-request");
        inf_xml_util_set_attribute(
          reply_xml,
          "request",
          request_str
        );
        inf_xml_util_set_attribute(
          reply_xml,
          "state",
          current_str
        );
        inf_xml_util_set_attribute_uint(
          reply_xml,
          "user",
          inf_user_get_id(INF_USER(user))
        );
        xmlNewChild(
          reply_xml,
          NULL,
          (const xmlChar*)"reason",
          (const xmlChar*)local_error-&gt;message
        );
        g_free(request_str);
        g_free(current_str);
        inf_communication_group_send_message(
          inf_session_get_subscription_group(INF_SESSION(session)),
          inf_user_get_connection(INF_USER(user)),
          reply_xml
        );
      }
      g_propagate_error(error, local_error);
    }
    return execute_result;
  }
  else
  {
    if(priv-&gt;request_buffer == NULL)
      priv-&gt;request_buffer = g_ptr_array_new();
    g_ptr_array_add(priv-&gt;request_buffer, request);
    g_object_ref(request);
    return TRUE;
  }
}
static void
inf_adopted_session_process_buffered_requests(InfAdoptedSession* session)
{
  InfAdoptedSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedStateVector* current;
  guint i;
  InfAdoptedRequest* request;
  InfAdoptedStateVector* vector;
  guint user_id;
  InfUser* user;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  if(priv-&gt;request_buffer != NULL)
  {
    user_table = inf_session_get_user_table(INF_SESSION(session));
    current = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
    for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
    {
      request =
        INF_ADOPTED_REQUEST(g_ptr_array_index(priv-&gt;request_buffer, i));
      vector = inf_adopted_request_get_vector(request);
      if(inf_adopted_state_vector_causally_before(vector, current))
      {
        g_ptr_array_remove_index_fast(priv-&gt;request_buffer, i);
        user_id = inf_adopted_request_get_user_id(request);
        user = inf_user_table_lookup_user_by_id(user_table, user_id);
        g_assert(INF_ADOPTED_IS_USER(user));
        inf_adopted_session_process_request(
          session,
          request,
          INF_ADOPTED_USER(user),
          NULL
        );
        g_object_unref(request);
        return inf_adopted_session_process_buffered_requests(session);
      }
    }
  }
}
static void
inf_adopted_session_local_user_added(InfAdoptedSession* session,
                                     InfAdoptedUser* user)
{
  InfAdoptedSessionPrivate* priv;
  InfSessionStatus status;
  InfAdoptedSessionLocalUser* local;
  InfAdoptedStateVector* current_state;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  status = inf_session_get_status(INF_SESSION(session));
  g_assert(status == INF_SESSION_RUNNING);
  local = g_slice_new(InfAdoptedSessionLocalUser);
  local-&gt;user = user;
  local-&gt;last_send_vector = inf_adopted_state_vector_copy(
    inf_adopted_user_get_vector(user)
  );
  inf_adopted_user_set_vector(
    user,
    inf_adopted_state_vector_copy(
      inf_adopted_algorithm_get_current(priv-&gt;algorithm)
    )
  );
  local-&gt;noop_time = 0;
  priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
  current_state = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
  if(inf_adopted_state_vector_compare(current_state, local-&gt;last_send_vector))
    inf_adopted_session_start_noop_timer(session, local);
}
static void
inf_adopted_session_remove_local_user_cb(InfUserTable* user_table,
                                         InfUser* user,
                                         gpointer user_data)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionLocalUser* local;
  session = INF_ADOPTED_SESSION(user_data);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  local = inf_adopted_session_lookup_local_user(
    session,
    INF_ADOPTED_USER(user)
  );
  g_assert(local != NULL);
  inf_adopted_session_stop_noop_timer(session, local);
  inf_adopted_state_vector_free(local-&gt;last_send_vector);
  priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
  g_slice_free(InfAdoptedSessionLocalUser, local);
}
static void
inf_adopted_session_add_local_user_cb(InfUserTable* user_table,
                                      InfUser* user,
                                      gpointer user_data)
{
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_session_local_user_added(
    INF_ADOPTED_SESSION(user_data),
    INF_ADOPTED_USER(user)
  );
}
static void
inf_adopted_session_constructed_foreach_local_user_func(InfUser* user,
                                                        gpointer user_data)
{
  g_assert(INF_ADOPTED_IS_USER(user));
  inf_adopted_session_local_user_added(
    INF_ADOPTED_SESSION(user_data),
    INF_ADOPTED_USER(user)
  );
}
static void
inf_adopted_session_end_execute_request_cb(InfAdoptedAlgorithm* algorithm,
                                          InfAdoptedUser* user,
                                          InfAdoptedRequest* request,
                                          InfAdoptedRequest* translated,
                                          const GError* error,
                                          gpointer user_data)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  GSList* item;
  InfAdoptedSessionLocalUser* local;
  guint id;
  InfAdoptedOperation* operation;
  session = INF_ADOPTED_SESSION(user_data);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  if(translated != NULL)
  {
    if(inf_adopted_request_affects_buffer(translated))
    {
      id = inf_adopted_request_get_user_id(translated);
      for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
      {
        local = (InfAdoptedSessionLocalUser*)item-&gt;data;
        if(local-&gt;noop_time == 0)
          if(inf_user_get_id(INF_USER(local-&gt;user)) != id)
            inf_adopted_session_start_noop_timer(session, local);
      }
    }
    operation = inf_adopted_request_get_operation(translated);
    if(!INF_ADOPTED_IS_NO_OPERATION(operation))
    {
      if(inf_user_get_status(INF_USER(user)) == INF_USER_INACTIVE)
        g_object_set(G_OBJECT(user), "status", INF_USER_ACTIVE, NULL);
    }
  }
}
static void
inf_adopted_session_create_algorithm(InfAdoptedSession* session)
{
  InfAdoptedSessionPrivate* priv;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  g_assert(priv-&gt;algorithm == NULL);
  g_assert(
    inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING
  );
  priv-&gt;algorithm = inf_adopted_algorithm_new_full(
    inf_session_get_user_table(INF_SESSION(session)),
    inf_session_get_buffer(INF_SESSION(session)),
    priv-&gt;max_total_log_size
  );
  g_signal_connect(
    G_OBJECT(priv-&gt;algorithm),
    "end-execute-request",
    G_CALLBACK(inf_adopted_session_end_execute_request_cb),
    session
  );
  g_object_notify(G_OBJECT(session), "algorithm");
}
static void
inf_adopted_session_init(InfAdoptedSession* session)
{
  InfAdoptedSessionPrivate* priv;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  priv-&gt;io = NULL;
  priv-&gt;max_total_log_size = 2048;
  priv-&gt;algorithm = NULL;
  priv-&gt;local_users = NULL;
  priv-&gt;noop_timeout = NULL;
  priv-&gt;next_noop_user = NULL;
  priv-&gt;request_buffer = NULL;
}
static void
inf_adopted_session_constructed(GObject* object)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  InfSessionStatus status;
  InfUserTable* user_table;
  G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;constructed(object);
  session = INF_ADOPTED_SESSION(object);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  g_assert(priv-&gt;io != NULL);
  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  g_signal_connect(
    G_OBJECT(user_table),
    "add-local-user",
    G_CALLBACK(inf_adopted_session_add_local_user_cb),
    session
  );
  g_signal_connect(
    G_OBJECT(user_table),
    "remove-local-user",
    G_CALLBACK(inf_adopted_session_remove_local_user_cb),
    session
  );
  switch(status)
  {
  case INF_SESSION_PRESYNC:
  case INF_SESSION_SYNCHRONIZING:
    break;
  case INF_SESSION_RUNNING:
    g_assert(inf_session_get_buffer(INF_SESSION(session)) != NULL);
    inf_adopted_session_create_algorithm(session);
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
  inf_user_table_foreach_local_user(
    user_table,
    inf_adopted_session_constructed_foreach_local_user_func,
    session
  );
}
static void
inf_adopted_session_dispose(GObject* object)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  InfUserTable* user_table;
  guint i;
  session = INF_ADOPTED_SESSION(object);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_adopted_session_add_local_user_cb),
    session
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_adopted_session_remove_local_user_cb),
    session
  );
  if(priv-&gt;noop_timeout != NULL)
  {
    inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
    priv-&gt;noop_timeout = NULL;
  }
  G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;dispose(object);
  g_assert(priv-&gt;local_users == NULL);
  if(priv-&gt;request_buffer != NULL)
  {
    for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
      g_object_unref(g_ptr_array_index(priv-&gt;request_buffer, i));
    g_ptr_array_free(priv-&gt;request_buffer, TRUE);
    priv-&gt;request_buffer = NULL;
  }
  if(priv-&gt;algorithm != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;algorithm),
      G_CALLBACK(inf_adopted_session_end_execute_request_cb),
      session
    );
    g_object_unref(G_OBJECT(priv-&gt;algorithm));
<a name="2"></a>    priv-&gt;algorithm = NULL;
  }
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }
}
static void
inf_adopted_session_finalize(GObject* object)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  session = INF_ADOPTED_SESSION(object);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);</b></font>
<a name="1"></a>  g_assert(priv-&gt;local_users == NULL);
  G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;finalize(object);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
inf_adopted_session_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  session = INF_ADOPTED_SESSION(object);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); <a name="0"></a>    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_MAX_TOTAL_LOG_SIZE:</b></font>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;max_total_log_size = g_value_get_uint(value);
    break;
  case PROP_ALGORITHM:
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_session_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfAdoptedSession* session;
  InfAdoptedSessionPrivate* priv;
  session = INF_ADOPTED_SESSION(object);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_MAX_TOTAL_LOG_SIZE:
    g_value_set_uint(value, priv-&gt;max_total_log_size);
    break;
  case PROP_ALGORITHM:
    g_value_set_object(value, G_OBJECT(priv-&gt;algorithm));
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_session_to_xml_sync_foreach_user_func(InfUser* user,
                                                  gpointer user_data)
{
  InfAdoptedRequestLog* log;
  InfAdoptedSessionToXmlSyncForeachData* data;
  InfAdoptedSessionClass* session_class;
  guint i;
  guint end;
  xmlNodePtr xml;
  InfAdoptedRequest* request;
  g_assert(INF_ADOPTED_IS_USER(user));
  data = (InfAdoptedSessionToXmlSyncForeachData*)user_data;
  log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
  end = inf_adopted_request_log_get_end(log);
  session_class = INF_ADOPTED_SESSION_GET_CLASS(data-&gt;session);
  g_assert(session_class-&gt;request_to_xml != NULL);
  for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++ i)
  {
    request = inf_adopted_request_log_get_request(log, i);
    xml = xmlNewChild(
      data-&gt;parent_xml,
      NULL,
      (const xmlChar*)"sync-request",
      NULL
    );
    session_class-&gt;request_to_xml(data-&gt;session, xml, request, NULL, TRUE);
    xmlAddChild(data-&gt;parent_xml, xml);
  }
}
static void
inf_adopted_session_to_xml_sync(InfSession* session,
                                xmlNodePtr parent)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionToXmlSyncForeachData foreach_data;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  g_assert(priv-&gt;algorithm != NULL);
  INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;to_xml_sync(
    session,
    parent
  );
  foreach_data.session = INF_ADOPTED_SESSION(session);
  foreach_data.parent_xml = parent;
  inf_user_table_foreach_user(
    inf_session_get_user_table(session),
    inf_adopted_session_to_xml_sync_foreach_user_func,
    &amp;foreach_data
  );
}
static gboolean
inf_adopted_session_process_xml_sync(InfSession* session,
                                     InfXmlConnection* connection,
                                     const xmlNodePtr xml,
                                     GError** error)
{
  InfAdoptedSessionClass* session_class;
  InfAdoptedRequest* request;
  InfAdoptedUser* user;
  InfAdoptedRequestLog* log;
  InfSessionClass* parent_class;
  if(strcmp((const char*)xml-&gt;name, "sync-request") == 0)
  {
    session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
    g_assert(session_class-&gt;xml_to_request != NULL);
    request = session_class-&gt;xml_to_request(
      INF_ADOPTED_SESSION(session),
      xml,
      NULL,       TRUE,
      error
    );
    if(request == NULL) return FALSE;
    user = INF_ADOPTED_USER(
      inf_user_table_lookup_user_by_id(
        inf_session_get_user_table(session),
        inf_adopted_request_get_user_id(request)
      )
    );
    log = inf_adopted_user_get_request_log(user);
    if(inf_adopted_session_validate_request(log, request, error) == FALSE)
    {
      g_object_unref(request);
      return FALSE;
    }
    inf_adopted_request_log_add_request(log, request);
    g_object_unref(request);
    return TRUE;
  }
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  return parent_class-&gt;process_xml_sync(session, connection, xml, error);
}
static InfCommunicationScope
inf_adopted_session_process_xml_run(InfSession* session,
                                    InfXmlConnection* connection,
                                    const xmlNodePtr xml,
                                    GError** error)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionClass* session_class;
  InfAdoptedRequest* request;
  InfAdoptedUser* user;
  guint user_id;
  InfAdoptedStateVector* user_vector;
  InfAdoptedStateVector* request_vector;
  gboolean has_num;
  gboolean process_request;
  guint num;
  GError* local_error;
  InfAdoptedRequest* copy_req;
  guint i;
  gchar* request_str;
  gchar* user_str;
  InfSessionClass* parent_class;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  if(strcmp((const char*)xml-&gt;name, "request") == 0)
  {
    session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
    g_assert(session_class-&gt;xml_to_request != NULL);
    user = inf_adopted_session_user_from_request_xml(
      INF_ADOPTED_SESSION(session),
      xml,
      error
    );
    if(user == NULL)
      return INF_COMMUNICATION_SCOPE_PTP;
    if(inf_user_get_status(INF_USER(user)) == INF_USER_UNAVAILABLE ||
       inf_user_get_connection(INF_USER(user)) != connection)
    {
      g_set_error_literal(
        error,
        inf_user_error_quark(),
        INF_USER_ERROR_NOT_JOINED,
        _("User did not join from this connection")
      );
      return INF_COMMUNICATION_SCOPE_PTP;
    }
    local_error = NULL;
    has_num = inf_xml_util_get_attribute_uint(xml, "num", &amp;num, &amp;local_error);
    if(local_error != NULL)
    {
      g_propagate_error(error, local_error);
      return INF_COMMUNICATION_SCOPE_PTP;
    }
    if(has_num == FALSE)
      num = 1;
    user_id = inf_user_get_id(INF_USER(user));
    user_vector = inf_adopted_user_get_vector(user);
    request = session_class-&gt;xml_to_request(
      INF_ADOPTED_SESSION(session),
      xml,
      user_vector,
      FALSE,
      error
    );
    if(request == NULL)
      return INF_COMMUNICATION_SCOPE_PTP;
    request_vector = inf_adopted_request_get_vector(request);
    if(!inf_adopted_state_vector_causally_before(user_vector, request_vector))
    {
      g_assert_not_reached();
    }
    else if(inf_adopted_request_get_index(request) !=
            inf_adopted_state_vector_get(user_vector, user_id))
    {
      request_str = inf_adopted_state_vector_to_string(request_vector);
      user_str = inf_adopted_state_vector_to_string(user_vector);
      g_set_error(
        error,
        inf_adopted_session_error_quark,
        INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
        _("Request \"%s\" by user \"%s\" is not consecutive with respect to "
          "previously received request \"%s\""),
        request_str,
        inf_user_get_name(INF_USER(user)),
        user_str
      );
      g_free(request_str);
      g_free(user_str);
      g_object_unref(request);
      return INF_COMMUNICATION_SCOPE_PTP;
    }
    user_vector = inf_adopted_state_vector_copy(request_vector);
    inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
    for(i = 0; i &lt; num; ++i)
    {
      if(i == 0)
      {
        copy_req = request;
        g_object_ref(copy_req);
      }
      else
      {
        copy_req = inf_adopted_request_copy(request);
        inf_adopted_state_vector_add(
          inf_adopted_request_get_vector(copy_req),
          inf_user_get_id(INF_USER(user)),
          i
        );
      }
      process_request = inf_adopted_session_process_request(
        INF_ADOPTED_SESSION(session),
        copy_req,
        user,
        error
      );
      g_object_unref(copy_req);
      if(inf_adopted_request_affects_buffer(request))
      {
        user_vector = inf_adopted_state_vector_copy(
          inf_adopted_request_get_vector(copy_req)
        );
        inf_adopted_state_vector_add(user_vector, user_id, 1);
        inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
      }
      if(process_request == FALSE)
        break;
    }
    g_object_unref(request);
    if(i &gt; 0)
    {
      inf_adopted_session_process_buffered_requests(
        INF_ADOPTED_SESSION(session)
      );
    }
    inf_adopted_algorithm_cleanup(
      inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
    );
    return INF_COMMUNICATION_SCOPE_GROUP;
  }
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  return parent_class-&gt;process_xml_run(session, connection, xml, error);
}
static GArray*
inf_adopted_session_get_xml_user_props(InfSession* session,
                                       InfXmlConnection* conn,
                                       const xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  GArray* array;
  GParameter* parameter;
  InfAdoptedStateVector* vector;
  xmlChar* time;
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  array = parent_class-&gt;get_xml_user_props(session, conn, xml);
  time = inf_xml_util_get_attribute(xml, "time");
  if(time != NULL)
  {
    vector = inf_adopted_state_vector_from_string((const gchar*)time, NULL);
    xmlFree(time);
    if(vector != NULL)
    {
      parameter = inf_session_get_user_property(array, "vector");
      g_value_init(&amp;parameter-&gt;value, INF_ADOPTED_TYPE_STATE_VECTOR);
      g_value_take_boxed(&amp;parameter-&gt;value, vector);
    }
  }
  return array;
}
static void
inf_adopted_session_set_xml_user_props(InfSession* session,
                                       const GParameter* params,
                                       guint n_params,
                                       xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  InfAdoptedSessionPrivate* priv;
  const GParameter* time;
  InfAdoptedStateVector* vector;
  gchar* time_string;
  const GParameter* id_param;
  guint id;
  GSList* item;
  InfAdoptedSessionLocalUser* local_user;
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
  priv = INF_ADOPTED_SESSION_PRIVATE(INF_ADOPTED_SESSION(session));
  time = inf_session_lookup_user_property(params, n_params, "vector");
  if(time != NULL)
  {
    vector = NULL;
    id_param = inf_session_lookup_user_property(params, n_params, "id");
    if(id_param != NULL)
    {
      id = g_value_get_uint(&amp;id_param-&gt;value);
      for(item = priv-&gt;local_users; item != NULL; item = item-&gt;next)
      {
        local_user = (InfAdoptedSessionLocalUser*)item-&gt;data;
        if(inf_user_get_id(INF_USER(local_user-&gt;user)) == id)
        {
          vector = local_user-&gt;last_send_vector;
          break;
        }
      }
    }
    if(vector == NULL)
    {
      vector = (InfAdoptedStateVector*)g_value_get_boxed(&amp;time-&gt;value);
    }
    time_string = inf_adopted_state_vector_to_string(vector);
    inf_xml_util_set_attribute(xml, "time", time_string);
    g_free(time_string);
  }
}
static gboolean
inf_adopted_session_validate_user_props(InfSession* session,
                                        const GParameter* params,
                                        guint n_params,
                                        InfUser* exclude,
                                        GError** error)
{
  InfSessionClass* parent_class;
  const GParameter* time;
  gboolean result;
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  result = parent_class-&gt;validate_user_props(
    session,
    params,
    n_params,
    exclude,
    error
  );
  if(result == FALSE) return FALSE;
  time = inf_session_lookup_user_property(params, n_params, "vector");
  if(time == NULL)
  {
    g_set_error_literal(
      error,
      inf_adopted_session_error_quark,
      INF_ADOPTED_SESSION_ERROR_MISSING_STATE_VECTOR,
      _("\"time\" attribute in user message is missing")
    );
    return FALSE;
  }
  return TRUE;
}
static void
inf_adopted_session_close(InfSession* session)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedSessionLocalUser* local;
  GSList* item;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfAdoptedSessionLocalUser*)item-&gt;data;
    inf_adopted_state_vector_free(local-&gt;last_send_vector);
    g_slice_free(InfAdoptedSessionLocalUser, local);
  }
  g_slist_free(priv-&gt;local_users);
  priv-&gt;local_users = NULL;
  INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;close(session);
}
static void
inf_adopted_session_synchronization_complete_foreach_user_func(InfUser* user,
                                                               gpointer data)
{
  InfAdoptedRequestLog* log;
  log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
  if(inf_adopted_request_log_is_empty(log))
  {
    inf_adopted_request_log_set_begin(
      log,
      inf_adopted_state_vector_get(
        inf_adopted_user_get_vector(INF_ADOPTED_USER(user)),
        inf_user_get_id(user)
      )
    );
  }
}
static void
inf_adopted_session_synchronization_complete(InfSession* session,
                                             InfXmlConnection* connection)
{
  InfSessionClass* parent_class;
  InfAdoptedSessionPrivate* priv;
  InfSessionStatus status;
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  status = inf_session_get_status(session);
  g_object_freeze_notify(G_OBJECT(session));
  parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
  parent_class-&gt;synchronization_complete(session, connection);
  if(status == INF_SESSION_SYNCHRONIZING)
  {
    inf_user_table_foreach_user(
      inf_session_get_user_table(session),
      inf_adopted_session_synchronization_complete_foreach_user_func,
      NULL
    );
    g_assert(priv-&gt;algorithm == NULL);
    inf_adopted_session_create_algorithm(INF_ADOPTED_SESSION(session));
  }
  g_object_thaw_notify(G_OBJECT(session));
}
static gboolean
inf_adopted_session_check_request(InfAdoptedSession* session,
                                  InfAdoptedRequest* request,
                                  InfAdoptedUser* user)
{
  return FALSE;
}
static void
inf_adopted_session_class_init(InfAdoptedSessionClass* adopted_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;
  object_class = G_OBJECT_CLASS(adopted_session_class);
  session_class = INF_SESSION_CLASS(adopted_session_class);
  object_class-&gt;constructed = inf_adopted_session_constructed;
  object_class-&gt;dispose = inf_adopted_session_dispose;
  object_class-&gt;finalize = inf_adopted_session_finalize;
  object_class-&gt;set_property = inf_adopted_session_set_property;
  object_class-&gt;get_property = inf_adopted_session_get_property;
  session_class-&gt;to_xml_sync = inf_adopted_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_adopted_session_process_xml_sync;
  session_class-&gt;process_xml_run = inf_adopted_session_process_xml_run;
  session_class-&gt;get_xml_user_props = inf_adopted_session_get_xml_user_props;
  session_class-&gt;set_xml_user_props = inf_adopted_session_set_xml_user_props;
  session_class-&gt;validate_user_props =
    inf_adopted_session_validate_user_props;
  session_class-&gt;close = inf_adopted_session_close;
  session_class-&gt;synchronization_complete =
    inf_adopted_session_synchronization_complete;
  adopted_session_class-&gt;xml_to_request = NULL;
  adopted_session_class-&gt;request_to_xml = NULL;
  adopted_session_class-&gt;check_request = inf_adopted_session_check_request;
  inf_adopted_session_error_quark = g_quark_from_static_string(
    "INF_ADOPTED_SESSION_ERROR"
  );
  session_signals[CHECK_REQUEST] = g_signal_new(
    "check-request",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedSessionClass, check_request),
    g_signal_accumulator_true_handled, NULL,
    NULL,
    G_TYPE_BOOLEAN,
    2,
    INF_ADOPTED_TYPE_REQUEST,
    INF_ADOPTED_TYPE_USER
  );
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object used for timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_MAX_TOTAL_LOG_SIZE,
    g_param_spec_uint(
      "max-total-log-size",
      "Maxmimum total log size",
      "The maximum number of requests to keep in all user's logs",
      0,
      G_MAXUINT,
      2048,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_ALGORITHM,
    g_param_spec_object(
      "algorithm",
      "Algorithm",
      "The adOPTed algorithm used for translating incoming requests",
      INF_ADOPTED_TYPE_ALGORITHM,
      G_PARAM_READABLE
    )
  );
}
InfIo*
inf_adopted_session_get_io(InfAdoptedSession* session)
{
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
  return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;io;
}
InfAdoptedAlgorithm*
inf_adopted_session_get_algorithm(InfAdoptedSession* session)
{
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
  return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;algorithm;
}
void
inf_adopted_session_broadcast_request(InfAdoptedSession* session,
                                      InfAdoptedRequest* request)
{
  g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
  g_return_if_fail(INF_ADOPTED_IS_REQUEST(request));
  inf_adopted_session_broadcast_n_requests(session, request, 1);
}
void
inf_adopted_session_undo(InfAdoptedSession* session,
                         InfAdoptedUser* user,
                         guint n)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedRequest* first_request;
  InfAdoptedRequest* request;
  guint i;
  gboolean result;
  g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
  g_return_if_fail(INF_ADOPTED_IS_USER(user));
  g_return_if_fail(n &gt;= 1);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  first_request = NULL;
  for(i = 0; i &lt; n; ++i)
  {
    request = inf_adopted_algorithm_generate_request(
      priv-&gt;algorithm,
      INF_ADOPTED_REQUEST_UNDO,
      user,
      NULL
    );
    result = inf_adopted_algorithm_execute_request(
      priv-&gt;algorithm,
      request,
      TRUE,
      NULL
    );
    g_assert(result == TRUE);
    if(first_request == NULL)
      first_request = request;
    else
      g_object_unref(request);
  }
  inf_adopted_session_broadcast_n_requests(session, first_request, n);
  g_object_unref(first_request);
}
void
inf_adopted_session_redo(InfAdoptedSession* session,
                         InfAdoptedUser* user,
                         guint n)
{
  InfAdoptedSessionPrivate* priv;
  InfAdoptedRequest* first_request;
  InfAdoptedRequest* request;
  guint i;
  gboolean result;
  g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
  g_return_if_fail(INF_ADOPTED_IS_USER(user));
  g_return_if_fail(n &gt;= 1);
  priv = INF_ADOPTED_SESSION_PRIVATE(session);
  first_request = NULL;
  for(i = 0; i &lt; n; ++i)
  {
    request = inf_adopted_algorithm_generate_request(
      priv-&gt;algorithm,
      INF_ADOPTED_REQUEST_REDO,
      user,
      NULL
    );
    result = inf_adopted_algorithm_execute_request(
      priv-&gt;algorithm,
      request,
      TRUE,
      NULL
    );
    g_assert(result == TRUE);
    if(first_request == NULL)
      first_request = request;
    else
      g_object_unref(request);
  }
  inf_adopted_session_broadcast_n_requests(session, first_request, n);
  g_object_unref(first_request);
}
gboolean
inf_adopted_session_read_request_info(InfAdoptedSession* session,
                                      xmlNodePtr xml,
                                      InfAdoptedStateVector* diff_vec,
                                      InfAdoptedUser** user,
                                      InfAdoptedStateVector** time,
                                      xmlNodePtr* operation,
                                      GError** error)
{
  xmlChar* attr;
  xmlNodePtr child;
  if(user != NULL)
  {
    *user = inf_adopted_session_user_from_request_xml(session, xml, error);
    if(*user == NULL) return FALSE;
  }
  if(time != NULL)
  {
    attr = inf_xml_util_get_attribute_required(xml, "time", error);
    if(attr == NULL) return FALSE;
    if(diff_vec == NULL)
    {
      *time = inf_adopted_state_vector_from_string((const gchar*)attr, error);
    }
    else
    {
      *time = inf_adopted_state_vector_from_string_diff(
        (const gchar*)attr,
        diff_vec,
        error
      );
    }
    xmlFree(attr);
    if(*time == NULL) return FALSE;
  }
  if(operation != NULL)
  {
    child = xml-&gt;children;
    while(child != NULL &amp;&amp; child-&gt;type != XML_ELEMENT_NODE)
      child = child-&gt;next;
    if(child == NULL)
    {
      g_set_error_literal(
        error,
        inf_adopted_session_error_quark,
        INF_ADOPTED_SESSION_ERROR_MISSING_OPERATION,
        _("Operation for request missing")
      );
      if(time) inf_adopted_state_vector_free(*time);
      return FALSE;
    }
    *operation = child;
  }
  return TRUE;
}
void
inf_adopted_session_write_request_info(InfAdoptedSession* session,
                                       InfAdoptedRequest* request,
                                       InfAdoptedStateVector* diff_vec,
                                       xmlNodePtr xml,
                                       xmlNodePtr operation)
{
  InfAdoptedStateVector* vector;
  guint user_id;
  gchar* vec_str;
  vector = inf_adopted_request_get_vector(request);
  user_id = inf_adopted_request_get_user_id(request);
  inf_xml_util_set_attribute_uint(xml, "user", user_id);
  if(diff_vec == NULL)
    vec_str = inf_adopted_state_vector_to_string(vector);
  else
    vec_str = inf_adopted_state_vector_to_string_diff(vector, diff_vec);
  inf_xml_util_set_attribute(xml, "time", vec_str);
  g_free(vec_str);
  if(operation != NULL)
    xmlAddChild(xml, operation);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
