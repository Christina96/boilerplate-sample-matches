<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-request.c &amp; inf-adopted-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-request.c &amp; inf-adopted-session.c
      </h3>
<h1 align="center">
        9.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-request.c (40.0%)<th>inf-adopted-session.c (5.5354996%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(129-161)<td><a href="#" name="0">(967-999)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(103-123)<td><a href="#" name="1">(946-966)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(82-98)<td><a href="#" name="2">(926-940)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-request.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-request.h&gt;
2 #include &lt;libinfinity/common/inf-request.h&gt;
3 #include &lt;libinfinity/common/inf-xml-connection.h&gt;
4 typedef struct _InfdRequestPrivate InfdRequestPrivate;
5 struct _InfdRequestPrivate {
6   gchar* type;
7   guint node_id;
8   InfXmlConnection* requestor;
9   gboolean finished;
10 };
11 enum {
12   PROP_0,
13   PROP_TYPE,
14   PROP_NODE_ID,
15   PROP_REQUESTOR,
16   PROP_PROGRESS
17 };
18 #define INFD_REQUEST_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_REQUEST, InfdRequestPrivate))
19 static void infd_request_request_iface_init(InfRequestInterface* iface);
20 G_DEFINE_TYPE_WITH_CODE(InfdRequest, infd_request, G_TYPE_OBJECT,
21   G_ADD_PRIVATE(InfdRequest)
22   G_IMPLEMENT_INTERFACE(INF_TYPE_REQUEST, infd_request_request_iface_init))
23 static void
24 infd_request_init(InfdRequest* request)
25 {
26   InfdRequestPrivate* priv;
27   priv = INFD_REQUEST_PRIVATE(request);
28   priv-&gt;type = NULL;
29   priv-&gt;node_id = G_MAXUINT;
30   priv-&gt;requestor = NULL;
31   priv-&gt;finished = FALSE;
32 }
33 static void
34 infd_request_dispose(GObject* object)
35 {
36   InfdRequest* request;
37   InfdRequestPrivate* priv;
38 <a name="2"></a>  request = INFD_REQUEST(object);
39   priv = INFD_REQUEST_PRIVATE(request);
40 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(priv-&gt;requestor != NULL)
41   {
42     g_object_unref(priv-&gt;requestor);
43     priv-&gt;requestor = NULL;
44   }
45   G_OBJECT_CLASS(infd_request_parent_class)-&gt;dispose(object);
46 }
47 static void
48 infd_request_finalize(GObject* object)
49 {
50   InfdRequest* request;
51   InfdRequestPrivate* priv;
52   request = INFD_REQUEST(object);
53   priv = INFD_REQUEST_PRIVATE(request);</b></font>
54 <a name="1"></a>  g_free(priv-&gt;type);
55   G_OBJECT_CLASS(infd_request_parent_class)-&gt;finalize(object);
56 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
57 static void
58 infd_request_set_property(GObject* object,
59                           guint prop_id,
60                           const GValue* value,
61                           GParamSpec* pspec)
62 {
63   InfdRequest* request;
64   InfdRequestPrivate* priv;
65   request = INFD_REQUEST(object);
66   priv = INFD_REQUEST_PRIVATE(request);
67   switch(prop_id)
68   {
69   case PROP_TYPE:
70     g_assert(priv-&gt;type == NULL);     priv-&gt;type = g_value_dup_string(value);
71     break;
72   case PROP_NODE_ID:</b></font>
73     g_assert(priv-&gt;node_id == G_MAXUINT);     priv-&gt;node_id = g_value_get_uint(value);
74 <a name="0"></a>    break;
75   case PROP_REQUESTOR:
76     g_assert(priv-&gt;requestor == NULL); <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;requestor = g_value_dup_object(value);
77     break;
78   case PROP_PROGRESS:
79   default:
80     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
81     break;
82   }
83 }
84 static void
85 infd_request_get_property(GObject* object,
86                           guint prop_id,
87                           GValue* value,
88                           GParamSpec* pspec)
89 {
90   InfdRequest* request;
91   InfdRequestPrivate* priv;
92   request = INFD_REQUEST(object);
93   priv = INFD_REQUEST_PRIVATE(request);
94   switch(prop_id)
95   {
96   case PROP_TYPE:
97     g_value_set_string(value, priv-&gt;type);
98     break;
99   case PROP_NODE_ID:
100     g_value_set_uint(value, priv-&gt;node_id);
101     break;
102   case PROP_REQUESTOR:
103     g_value_set_object(value, priv-&gt;requestor);
104     break;</b></font>
105   case PROP_PROGRESS:
106     if(priv-&gt;finished == TRUE)
107       g_value_set_double(value, 1.0);
108     else
109       g_value_set_double(value, 0.0);
110     break;
111   default:
112     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
113     break;
114   }
115 }
116 static void
117 infd_request_request_finished(InfRequest* request,
118                               const InfRequestResult* result,
119                               const GError* error)
120 {
121   InfdRequestPrivate* priv;
122   priv = INFD_REQUEST_PRIVATE(request);
123   priv-&gt;finished = TRUE;
124   g_object_notify(G_OBJECT(request), "progress");
125 }
126 static gboolean
127 infd_request_request_is_local(InfRequest* request)
128 {
129   InfdRequestPrivate* priv;
130   priv = INFD_REQUEST_PRIVATE(request);
131   if(priv-&gt;requestor != NULL)
132     return FALSE;
133   return TRUE;
134 }
135 static void
136 infd_request_class_init(InfdRequestClass* request_class)
137 {
138   GObjectClass* object_class;
139   object_class = G_OBJECT_CLASS(request_class);
140   object_class-&gt;dispose = infd_request_dispose;
141   object_class-&gt;finalize = infd_request_finalize;
142   object_class-&gt;set_property = infd_request_set_property;
143   object_class-&gt;get_property = infd_request_get_property;
144   g_object_class_install_property(
145     object_class,
146     PROP_REQUESTOR,
147     g_param_spec_object(
148       "requestor",
149       "Requestor",
150       "The connection making the request",
151       INF_TYPE_XML_CONNECTION,
152       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
153     )
154   );
155   g_object_class_install_property(
156     object_class,
157     PROP_NODE_ID,
158     g_param_spec_uint(
159       "node-id",
160       "Node ID",
161       "The ID of the node affected by the request",
162       0,
163       G_MAXUINT,
164       G_MAXUINT,
165       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
166     )
167   );
168   g_object_class_override_property(object_class, PROP_TYPE, "type");
169   g_object_class_override_property(object_class, PROP_PROGRESS, "progress");
170 }
171 static void
172 infd_request_request_iface_init(InfRequestInterface* iface)
173 {
174   iface-&gt;finished = infd_request_request_finished;
175   iface-&gt;is_local = infd_request_request_is_local;
176 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
2 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
3 #include &lt;libinfinity/common/inf-xml-util.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;time.h&gt;
9 typedef struct _InfAdoptedSessionToXmlSyncForeachData
10   InfAdoptedSessionToXmlSyncForeachData;
11 struct _InfAdoptedSessionToXmlSyncForeachData {
12   InfAdoptedSession* session;
13   xmlNodePtr parent_xml;
14 };
15 typedef struct _InfAdoptedSessionLocalUser InfAdoptedSessionLocalUser;
16 struct _InfAdoptedSessionLocalUser {
17   InfAdoptedUser* user;
18   InfAdoptedStateVector* last_send_vector;
19   time_t noop_time; };
20 typedef struct _InfAdoptedSessionPrivate InfAdoptedSessionPrivate;
21 struct _InfAdoptedSessionPrivate {
22   InfIo* io;
23   guint max_total_log_size;
24   InfAdoptedAlgorithm* algorithm;
25   GSList* local_users; 
26   InfIoTimeout* noop_timeout;
27   InfAdoptedSessionLocalUser* next_noop_user;
28   GPtrArray* request_buffer;
29 };
30 enum {
31   PROP_0,
32   PROP_IO,
33   PROP_MAX_TOTAL_LOG_SIZE,
34   PROP_ALGORITHM
35 };
36 enum {
37   CHECK_REQUEST,
38   LAST_SIGNAL
39 };
40 #define INF_ADOPTED_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_SESSION, InfAdoptedSessionPrivate))
41 static guint session_signals[LAST_SIGNAL];
42 static GQuark inf_adopted_session_error_quark;
43 static const int INF_ADOPTED_SESSION_NOOP_INTERVAL = 30;
44 G_DEFINE_TYPE_WITH_CODE(InfAdoptedSession, inf_adopted_session, INF_TYPE_SESSION,
45   G_ADD_PRIVATE(InfAdoptedSession))
46 static InfAdoptedSessionLocalUser*
47 inf_adopted_session_lookup_local_user(InfAdoptedSession* session,
48                                       InfAdoptedUser* user)
49 {
50   InfAdoptedSessionPrivate* priv;
51   InfAdoptedSessionLocalUser* local;
52   GSList* item;
53   priv = INF_ADOPTED_SESSION_PRIVATE(session);
54   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
55   {
56     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
57     if(local-&gt;user == user)
58       return local;
59   }
60   return NULL;
61 }
62 static gboolean
63 inf_adopted_session_validate_request(InfAdoptedRequestLog* log,
64                                      InfAdoptedRequest* request,
65                                      GError** error)
66 {
67   InfAdoptedStateVector* vector;
68   guint user_id;
69   guint n;
70   guint begin;
71   guint end;
72   vector = inf_adopted_request_get_vector(request);
73   user_id = inf_adopted_request_get_user_id(request);
74   n = inf_adopted_state_vector_get(vector, user_id);
75   begin = inf_adopted_request_log_get_begin(log);
76   end = inf_adopted_request_log_get_end(log);
77   if(end != n &amp;&amp; begin != end)
78   {
79     g_set_error(
80       error,
81       inf_adopted_session_error_quark,
82       INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
83       _("Request has index '%u', but index '%u' was expected"),
84       n,
85       inf_adopted_request_log_get_end(log)
86     );
87     return FALSE;
88   }
89   else
90   {
91     switch(inf_adopted_request_get_request_type(request))
92     {
93     case INF_ADOPTED_REQUEST_DO:
94       return TRUE;
95     case INF_ADOPTED_REQUEST_UNDO:
96       if(inf_adopted_request_log_next_undo(log) == NULL)
97       {
98         g_set_error_literal(
99           error,
100           inf_adopted_session_error_quark,
101           INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
102           _("Undo received, but no previous request found")
103         );
104         return FALSE;
105       }
106       else
107       {
108         return TRUE;
109       }
110     case INF_ADOPTED_REQUEST_REDO:
111       if(inf_adopted_request_log_next_redo(log) == NULL)
112       {
113         g_set_error_literal(
114           error,
115           inf_adopted_session_error_quark,
116           INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
117           _("Redo received, but no previous request found")
118         );
119         return FALSE;
120       }
121       else
122       {
123         return TRUE;
124       }
125     default:
126       g_assert_not_reached();
127       return FALSE;
128     }
129   }
130 }
131 static InfAdoptedUser*
132 inf_adopted_session_user_from_request_xml(InfAdoptedSession* session,
133                                           xmlNodePtr xml,
134                                           GError** error)
135 {
136   InfUserTable* user_table;
137   InfUser* user;
138   guint user_id;
139   user_table = inf_session_get_user_table(INF_SESSION(session));
140   if(!inf_xml_util_get_attribute_uint_required(xml, "user", &amp;user_id, error))
141     return FALSE;
142   if(user_id == 0) return NULL;
143   user = inf_user_table_lookup_user_by_id(user_table, user_id);
144   if(user == NULL)
145   {
146     g_set_error(
147       error,
148       inf_adopted_session_error_quark,
149       INF_ADOPTED_SESSION_ERROR_NO_SUCH_USER,
150       _("No such user with user ID '%u'"),
151       user_id
152     );
153     return NULL;
154   }
155   g_assert(INF_ADOPTED_IS_USER(user));
156   return INF_ADOPTED_USER(user);
157 }
158 static void
159 inf_adopted_session_noop_timeout_func(gpointer user_data)
160 {
161   InfAdoptedSession* session;
162   InfAdoptedSessionPrivate* priv;
163   InfAdoptedOperation* op;
164   InfAdoptedRequest* request;
165   session = INF_ADOPTED_SESSION(user_data);
166   priv = INF_ADOPTED_SESSION_PRIVATE(session);
167   priv-&gt;noop_timeout = NULL;
168   g_assert(priv-&gt;next_noop_user != NULL);
169   op = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
170   request = inf_adopted_algorithm_generate_request(
171     priv-&gt;algorithm,
172     INF_ADOPTED_REQUEST_DO,
173     priv-&gt;next_noop_user-&gt;user,
174     op
175   );
176   g_object_unref(op);
177   inf_adopted_session_broadcast_request(session, request);
178   g_object_unref(request);
179 }
180 static InfAdoptedSessionLocalUser*
181 inf_adopted_session_find_next_noop_user(InfAdoptedSession* session)
182 {
183   InfAdoptedSessionPrivate* priv;
184   GSList* item;
185   InfAdoptedSessionLocalUser* local;
186   InfAdoptedSessionLocalUser* next_user;
187   priv = INF_ADOPTED_SESSION_PRIVATE(session);
188   next_user = NULL;
189   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
190   {
191     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
192     if(local-&gt;noop_time != 0)
193       if(next_user == NULL || local-&gt;noop_time &lt; next_user-&gt;noop_time)
194         next_user = local;
195   }
196   return next_user;
197 }
198 static void
199 inf_adopted_session_schedule_noop_timer(InfAdoptedSession* session)
200 {
201   InfAdoptedSessionPrivate* priv;
202   time_t current;
203   time_t sched;
204   priv = INF_ADOPTED_SESSION_PRIVATE(session);
205   if(priv-&gt;noop_timeout != NULL)
206   {
207     inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
208     priv-&gt;noop_timeout = NULL;
209   }
210   if(priv-&gt;next_noop_user != NULL)
211   {
212     current = time(NULL);
213     sched =
214       priv-&gt;next_noop_user-&gt;noop_time + INF_ADOPTED_SESSION_NOOP_INTERVAL;
215     if(sched &gt;= current)
216       sched -= current;
217     else
218       sched = 0;
219     priv-&gt;noop_timeout = inf_io_add_timeout(
220       priv-&gt;io,
221       sched * 1000,
222       inf_adopted_session_noop_timeout_func,
223       session,
224       NULL
225     );
226   }
227 }
228 static void
229 inf_adopted_session_start_noop_timer(InfAdoptedSession* session,
230                                      InfAdoptedSessionLocalUser* local)
231 {
232   InfAdoptedSessionPrivate* priv;
233   priv = INF_ADOPTED_SESSION_PRIVATE(session);
234   g_assert(local-&gt;noop_time == 0);
235   local-&gt;noop_time = time(NULL);
236   if(priv-&gt;noop_timeout == NULL)
237   {
238     priv-&gt;next_noop_user = inf_adopted_session_find_next_noop_user(session);
239     g_assert(priv-&gt;next_noop_user != NULL);
240     inf_adopted_session_schedule_noop_timer(session);
241   }
242 }
243 static void
244 inf_adopted_session_stop_noop_timer(InfAdoptedSession* session,
245                                     InfAdoptedSessionLocalUser* local)
246 {
247   InfAdoptedSessionPrivate* priv;
248   InfAdoptedSessionLocalUser* next_noop_user;
249   priv = INF_ADOPTED_SESSION_PRIVATE(session);
250   if(local-&gt;noop_time &gt; 0)
251   {
252     local-&gt;noop_time = 0;
253     next_noop_user = inf_adopted_session_find_next_noop_user(session);
254     if(next_noop_user != priv-&gt;next_noop_user)
255     {
256       priv-&gt;next_noop_user = next_noop_user;
257       inf_adopted_session_schedule_noop_timer(session);
258     }
259   }
260 }
261 static void
262 inf_adopted_session_broadcast_n_requests(InfAdoptedSession* session,
263                                          InfAdoptedRequest* request,
264                                          guint n)
265 {
266   InfAdoptedSessionPrivate* priv;
267   InfAdoptedSessionClass* session_class;
268   InfUserTable* user_table;
269   guint user_id;
270   InfUser* user;
271   InfAdoptedSessionLocalUser* local;
272   xmlNodePtr xml;
273   priv = INF_ADOPTED_SESSION_PRIVATE(session);
274   session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
275   g_assert(session_class-&gt;request_to_xml != NULL);
276   user_table = inf_session_get_user_table(INF_SESSION(session));
277   user_id = inf_adopted_request_get_user_id(request);
278   user = inf_user_table_lookup_user_by_id(user_table, user_id);
279   g_assert(user != NULL);
280   local = inf_adopted_session_lookup_local_user(
281     session,
282     INF_ADOPTED_USER(user)
283   );
284   g_assert(local != NULL);
285   xml = xmlNewNode(NULL, (const xmlChar*)"request");
286   session_class-&gt;request_to_xml(
287     session,
288     xml,
289     request,
290     local-&gt;last_send_vector,
291     FALSE
292   );
293   if(n &gt; 1) inf_xml_util_set_attribute_uint(xml, "num", n);
294   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
295   inf_adopted_state_vector_free(local-&gt;last_send_vector);
296   local-&gt;last_send_vector = inf_adopted_state_vector_copy(
297     inf_adopted_request_get_vector(request)
298   );
299   if(inf_adopted_request_affects_buffer(request) == TRUE)
300     inf_adopted_state_vector_add(local-&gt;last_send_vector, user_id, n);
301   inf_adopted_session_stop_noop_timer(session, local);
302 }
303 static gboolean
304 inf_adopted_session_process_request(InfAdoptedSession* session,
305                                     InfAdoptedRequest* request,
306                                     InfAdoptedUser* user,
307                                     GError** error)
308 {
309   InfAdoptedSessionPrivate* priv;
310   InfAdoptedStateVector* request_vector;
311   InfAdoptedStateVector* current_vector;
312   gboolean reject_request;
313   GError* local_error;
314   gboolean execute_result;
315   xmlNodePtr reply_xml;
316   gchar* request_str;
317   gchar* current_str;
318   priv = INF_ADOPTED_SESSION_PRIVATE(session);
319   request_vector = inf_adopted_request_get_vector(request);
320   current_vector = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
321   if(inf_adopted_state_vector_causally_before(request_vector, current_vector))
322   {
323     g_signal_emit(
324       G_OBJECT(session),
325       session_signals[CHECK_REQUEST],
326       0,
327       request,
328       user,
329       &amp;reject_request
330     );
331     local_error = NULL;
332     if(reject_request)
333     {
334       g_set_error_literal(
335         &amp;local_error,
336         inf_adopted_session_error_quark,
337         INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
338         _("The request was rejected via the API")
339       );
340       execute_result = FALSE;
341     }
342     else
343     {
344       execute_result = inf_adopted_algorithm_execute_request(
345         priv-&gt;algorithm,
346         request,
347         TRUE,
348         &amp;local_error
349       );
350     }
351     if(local_error != NULL)
352     {
353       if(inf_user_get_connection(INF_USER(user)) != NULL)
354       {
355         request_str = inf_adopted_state_vector_to_string(request_vector);
356         current_str = inf_adopted_state_vector_to_string(current_vector);
357         reply_xml = xmlNewNode(NULL, (const xmlChar*)"invalid-request");
358         inf_xml_util_set_attribute(
359           reply_xml,
360           "request",
361           request_str
362         );
363         inf_xml_util_set_attribute(
364           reply_xml,
365           "state",
366           current_str
367         );
368         inf_xml_util_set_attribute_uint(
369           reply_xml,
370           "user",
371           inf_user_get_id(INF_USER(user))
372         );
373         xmlNewChild(
374           reply_xml,
375           NULL,
376           (const xmlChar*)"reason",
377           (const xmlChar*)local_error-&gt;message
378         );
379         g_free(request_str);
380         g_free(current_str);
381         inf_communication_group_send_message(
382           inf_session_get_subscription_group(INF_SESSION(session)),
383           inf_user_get_connection(INF_USER(user)),
384           reply_xml
385         );
386       }
387       g_propagate_error(error, local_error);
388     }
389     return execute_result;
390   }
391   else
392   {
393     if(priv-&gt;request_buffer == NULL)
394       priv-&gt;request_buffer = g_ptr_array_new();
395     g_ptr_array_add(priv-&gt;request_buffer, request);
396     g_object_ref(request);
397     return TRUE;
398   }
399 }
400 static void
401 inf_adopted_session_process_buffered_requests(InfAdoptedSession* session)
402 {
403   InfAdoptedSessionPrivate* priv;
404   InfUserTable* user_table;
405   InfAdoptedStateVector* current;
406   guint i;
407   InfAdoptedRequest* request;
408   InfAdoptedStateVector* vector;
409   guint user_id;
410   InfUser* user;
411   priv = INF_ADOPTED_SESSION_PRIVATE(session);
412   if(priv-&gt;request_buffer != NULL)
413   {
414     user_table = inf_session_get_user_table(INF_SESSION(session));
415     current = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
416     for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
417     {
418       request =
419         INF_ADOPTED_REQUEST(g_ptr_array_index(priv-&gt;request_buffer, i));
420       vector = inf_adopted_request_get_vector(request);
421       if(inf_adopted_state_vector_causally_before(vector, current))
422       {
423         g_ptr_array_remove_index_fast(priv-&gt;request_buffer, i);
424         user_id = inf_adopted_request_get_user_id(request);
425         user = inf_user_table_lookup_user_by_id(user_table, user_id);
426         g_assert(INF_ADOPTED_IS_USER(user));
427         inf_adopted_session_process_request(
428           session,
429           request,
430           INF_ADOPTED_USER(user),
431           NULL
432         );
433         g_object_unref(request);
434         return inf_adopted_session_process_buffered_requests(session);
435       }
436     }
437   }
438 }
439 static void
440 inf_adopted_session_local_user_added(InfAdoptedSession* session,
441                                      InfAdoptedUser* user)
442 {
443   InfAdoptedSessionPrivate* priv;
444   InfSessionStatus status;
445   InfAdoptedSessionLocalUser* local;
446   InfAdoptedStateVector* current_state;
447   priv = INF_ADOPTED_SESSION_PRIVATE(session);
448   status = inf_session_get_status(INF_SESSION(session));
449   g_assert(status == INF_SESSION_RUNNING);
450   local = g_slice_new(InfAdoptedSessionLocalUser);
451   local-&gt;user = user;
452   local-&gt;last_send_vector = inf_adopted_state_vector_copy(
453     inf_adopted_user_get_vector(user)
454   );
455   inf_adopted_user_set_vector(
456     user,
457     inf_adopted_state_vector_copy(
458       inf_adopted_algorithm_get_current(priv-&gt;algorithm)
459     )
460   );
461   local-&gt;noop_time = 0;
462   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
463   current_state = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
464   if(inf_adopted_state_vector_compare(current_state, local-&gt;last_send_vector))
465     inf_adopted_session_start_noop_timer(session, local);
466 }
467 static void
468 inf_adopted_session_remove_local_user_cb(InfUserTable* user_table,
469                                          InfUser* user,
470                                          gpointer user_data)
471 {
472   InfAdoptedSession* session;
473   InfAdoptedSessionPrivate* priv;
474   InfAdoptedSessionLocalUser* local;
475   session = INF_ADOPTED_SESSION(user_data);
476   priv = INF_ADOPTED_SESSION_PRIVATE(session);
477   local = inf_adopted_session_lookup_local_user(
478     session,
479     INF_ADOPTED_USER(user)
480   );
481   g_assert(local != NULL);
482   inf_adopted_session_stop_noop_timer(session, local);
483   inf_adopted_state_vector_free(local-&gt;last_send_vector);
484   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
485   g_slice_free(InfAdoptedSessionLocalUser, local);
486 }
487 static void
488 inf_adopted_session_add_local_user_cb(InfUserTable* user_table,
489                                       InfUser* user,
490                                       gpointer user_data)
491 {
492   g_assert(INF_ADOPTED_IS_USER(user));
493   inf_adopted_session_local_user_added(
494     INF_ADOPTED_SESSION(user_data),
495     INF_ADOPTED_USER(user)
496   );
497 }
498 static void
499 inf_adopted_session_constructed_foreach_local_user_func(InfUser* user,
500                                                         gpointer user_data)
501 {
502   g_assert(INF_ADOPTED_IS_USER(user));
503   inf_adopted_session_local_user_added(
504     INF_ADOPTED_SESSION(user_data),
505     INF_ADOPTED_USER(user)
506   );
507 }
508 static void
509 inf_adopted_session_end_execute_request_cb(InfAdoptedAlgorithm* algorithm,
510                                           InfAdoptedUser* user,
511                                           InfAdoptedRequest* request,
512                                           InfAdoptedRequest* translated,
513                                           const GError* error,
514                                           gpointer user_data)
515 {
516   InfAdoptedSession* session;
517   InfAdoptedSessionPrivate* priv;
518   GSList* item;
519   InfAdoptedSessionLocalUser* local;
520   guint id;
521   InfAdoptedOperation* operation;
522   session = INF_ADOPTED_SESSION(user_data);
523   priv = INF_ADOPTED_SESSION_PRIVATE(session);
524   if(translated != NULL)
525   {
526     if(inf_adopted_request_affects_buffer(translated))
527     {
528       id = inf_adopted_request_get_user_id(translated);
529       for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
530       {
531         local = (InfAdoptedSessionLocalUser*)item-&gt;data;
532         if(local-&gt;noop_time == 0)
533           if(inf_user_get_id(INF_USER(local-&gt;user)) != id)
534             inf_adopted_session_start_noop_timer(session, local);
535       }
536     }
537     operation = inf_adopted_request_get_operation(translated);
538     if(!INF_ADOPTED_IS_NO_OPERATION(operation))
539     {
540       if(inf_user_get_status(INF_USER(user)) == INF_USER_INACTIVE)
541         g_object_set(G_OBJECT(user), "status", INF_USER_ACTIVE, NULL);
542     }
543   }
544 }
545 static void
546 inf_adopted_session_create_algorithm(InfAdoptedSession* session)
547 {
548   InfAdoptedSessionPrivate* priv;
549   priv = INF_ADOPTED_SESSION_PRIVATE(session);
550   g_assert(priv-&gt;algorithm == NULL);
551   g_assert(
552     inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING
553   );
554   priv-&gt;algorithm = inf_adopted_algorithm_new_full(
555     inf_session_get_user_table(INF_SESSION(session)),
556     inf_session_get_buffer(INF_SESSION(session)),
557     priv-&gt;max_total_log_size
558   );
559   g_signal_connect(
560     G_OBJECT(priv-&gt;algorithm),
561     "end-execute-request",
562     G_CALLBACK(inf_adopted_session_end_execute_request_cb),
563     session
564   );
565   g_object_notify(G_OBJECT(session), "algorithm");
566 }
567 static void
568 inf_adopted_session_init(InfAdoptedSession* session)
569 {
570   InfAdoptedSessionPrivate* priv;
571   priv = INF_ADOPTED_SESSION_PRIVATE(session);
572   priv-&gt;io = NULL;
573   priv-&gt;max_total_log_size = 2048;
574   priv-&gt;algorithm = NULL;
575   priv-&gt;local_users = NULL;
576   priv-&gt;noop_timeout = NULL;
577   priv-&gt;next_noop_user = NULL;
578   priv-&gt;request_buffer = NULL;
579 }
580 static void
581 inf_adopted_session_constructed(GObject* object)
582 {
583   InfAdoptedSession* session;
584   InfAdoptedSessionPrivate* priv;
585   InfSessionStatus status;
586   InfUserTable* user_table;
587   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;constructed(object);
588   session = INF_ADOPTED_SESSION(object);
589   priv = INF_ADOPTED_SESSION_PRIVATE(session);
590   g_assert(priv-&gt;io != NULL);
591   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
592   user_table = inf_session_get_user_table(INF_SESSION(session));
593   g_signal_connect(
594     G_OBJECT(user_table),
595     "add-local-user",
596     G_CALLBACK(inf_adopted_session_add_local_user_cb),
597     session
598   );
599   g_signal_connect(
600     G_OBJECT(user_table),
601     "remove-local-user",
602     G_CALLBACK(inf_adopted_session_remove_local_user_cb),
603     session
604   );
605   switch(status)
606   {
607   case INF_SESSION_PRESYNC:
608   case INF_SESSION_SYNCHRONIZING:
609     break;
610   case INF_SESSION_RUNNING:
611     g_assert(inf_session_get_buffer(INF_SESSION(session)) != NULL);
612     inf_adopted_session_create_algorithm(session);
613     break;
614   case INF_SESSION_CLOSED:
615   default:
616     g_assert_not_reached();
617     break;
618   }
619   inf_user_table_foreach_local_user(
620     user_table,
621     inf_adopted_session_constructed_foreach_local_user_func,
622     session
623   );
624 }
625 static void
626 inf_adopted_session_dispose(GObject* object)
627 {
628   InfAdoptedSession* session;
629   InfAdoptedSessionPrivate* priv;
630   InfUserTable* user_table;
631   guint i;
632   session = INF_ADOPTED_SESSION(object);
633   priv = INF_ADOPTED_SESSION_PRIVATE(session);
634   user_table = inf_session_get_user_table(INF_SESSION(session));
635   inf_signal_handlers_disconnect_by_func(
636     G_OBJECT(user_table),
637     G_CALLBACK(inf_adopted_session_add_local_user_cb),
638     session
639   );
640   inf_signal_handlers_disconnect_by_func(
641     G_OBJECT(user_table),
642     G_CALLBACK(inf_adopted_session_remove_local_user_cb),
643     session
644   );
645   if(priv-&gt;noop_timeout != NULL)
646   {
647     inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
648     priv-&gt;noop_timeout = NULL;
649   }
650   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;dispose(object);
651   g_assert(priv-&gt;local_users == NULL);
652   if(priv-&gt;request_buffer != NULL)
653   {
654     for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
655       g_object_unref(g_ptr_array_index(priv-&gt;request_buffer, i));
656     g_ptr_array_free(priv-&gt;request_buffer, TRUE);
657     priv-&gt;request_buffer = NULL;
658   }
659   if(priv-&gt;algorithm != NULL)
660   {
661     inf_signal_handlers_disconnect_by_func(
662       G_OBJECT(priv-&gt;algorithm),
663       G_CALLBACK(inf_adopted_session_end_execute_request_cb),
664       session
665     );
666     g_object_unref(G_OBJECT(priv-&gt;algorithm));
667 <a name="2"></a>    priv-&gt;algorithm = NULL;
668   }
669 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;io != NULL)
670   {
671     g_object_unref(G_OBJECT(priv-&gt;io));
672     priv-&gt;io = NULL;
673   }
674 }
675 static void
676 inf_adopted_session_finalize(GObject* object)
677 {
678   InfAdoptedSession* session;
679   InfAdoptedSessionPrivate* priv;
680   session = INF_ADOPTED_SESSION(object);
681   priv = INF_ADOPTED_SESSION_PRIVATE(session);</b></font>
682 <a name="1"></a>  g_assert(priv-&gt;local_users == NULL);
683   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;finalize(object);
684 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
685 static void
686 inf_adopted_session_set_property(GObject* object,
687                                  guint prop_id,
688                                  const GValue* value,
689                                  GParamSpec* pspec)
690 {
691   InfAdoptedSession* session;
692   InfAdoptedSessionPrivate* priv;
693   session = INF_ADOPTED_SESSION(object);
694   priv = INF_ADOPTED_SESSION_PRIVATE(session);
695   switch(prop_id)
696   {
697   case PROP_IO:
698     g_assert(priv-&gt;io == NULL); <a name="0"></a>    priv-&gt;io = INF_IO(g_value_dup_object(value));
699     break;
700   case PROP_MAX_TOTAL_LOG_SIZE:</b></font>
701 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;max_total_log_size = g_value_get_uint(value);
702     break;
703   case PROP_ALGORITHM:
704   default:
705     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
706     break;
707   }
708 }
709 static void
710 inf_adopted_session_get_property(GObject* object,
711                                  guint prop_id,
712                                  GValue* value,
713                                  GParamSpec* pspec)
714 {
715   InfAdoptedSession* session;
716   InfAdoptedSessionPrivate* priv;
717   session = INF_ADOPTED_SESSION(object);
718   priv = INF_ADOPTED_SESSION_PRIVATE(session);
719   switch(prop_id)
720   {
721   case PROP_IO:
722     g_value_set_object(value, G_OBJECT(priv-&gt;io));
723     break;
724   case PROP_MAX_TOTAL_LOG_SIZE:
725     g_value_set_uint(value, priv-&gt;max_total_log_size);
726     break;
727   case PROP_ALGORITHM:
728     g_value_set_object(value, G_OBJECT(priv-&gt;algorithm));
729     break;</b></font>
730   default:
731     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
732     break;
733   }
734 }
735 static void
736 inf_adopted_session_to_xml_sync_foreach_user_func(InfUser* user,
737                                                   gpointer user_data)
738 {
739   InfAdoptedRequestLog* log;
740   InfAdoptedSessionToXmlSyncForeachData* data;
741   InfAdoptedSessionClass* session_class;
742   guint i;
743   guint end;
744   xmlNodePtr xml;
745   InfAdoptedRequest* request;
746   g_assert(INF_ADOPTED_IS_USER(user));
747   data = (InfAdoptedSessionToXmlSyncForeachData*)user_data;
748   log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
749   end = inf_adopted_request_log_get_end(log);
750   session_class = INF_ADOPTED_SESSION_GET_CLASS(data-&gt;session);
751   g_assert(session_class-&gt;request_to_xml != NULL);
752   for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++ i)
753   {
754     request = inf_adopted_request_log_get_request(log, i);
755     xml = xmlNewChild(
756       data-&gt;parent_xml,
757       NULL,
758       (const xmlChar*)"sync-request",
759       NULL
760     );
761     session_class-&gt;request_to_xml(data-&gt;session, xml, request, NULL, TRUE);
762     xmlAddChild(data-&gt;parent_xml, xml);
763   }
764 }
765 static void
766 inf_adopted_session_to_xml_sync(InfSession* session,
767                                 xmlNodePtr parent)
768 {
769   InfAdoptedSessionPrivate* priv;
770   InfAdoptedSessionToXmlSyncForeachData foreach_data;
771   priv = INF_ADOPTED_SESSION_PRIVATE(session);
772   g_assert(priv-&gt;algorithm != NULL);
773   INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;to_xml_sync(
774     session,
775     parent
776   );
777   foreach_data.session = INF_ADOPTED_SESSION(session);
778   foreach_data.parent_xml = parent;
779   inf_user_table_foreach_user(
780     inf_session_get_user_table(session),
781     inf_adopted_session_to_xml_sync_foreach_user_func,
782     &amp;foreach_data
783   );
784 }
785 static gboolean
786 inf_adopted_session_process_xml_sync(InfSession* session,
787                                      InfXmlConnection* connection,
788                                      const xmlNodePtr xml,
789                                      GError** error)
790 {
791   InfAdoptedSessionClass* session_class;
792   InfAdoptedRequest* request;
793   InfAdoptedUser* user;
794   InfAdoptedRequestLog* log;
795   InfSessionClass* parent_class;
796   if(strcmp((const char*)xml-&gt;name, "sync-request") == 0)
797   {
798     session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
799     g_assert(session_class-&gt;xml_to_request != NULL);
800     request = session_class-&gt;xml_to_request(
801       INF_ADOPTED_SESSION(session),
802       xml,
803       NULL,       TRUE,
804       error
805     );
806     if(request == NULL) return FALSE;
807     user = INF_ADOPTED_USER(
808       inf_user_table_lookup_user_by_id(
809         inf_session_get_user_table(session),
810         inf_adopted_request_get_user_id(request)
811       )
812     );
813     log = inf_adopted_user_get_request_log(user);
814     if(inf_adopted_session_validate_request(log, request, error) == FALSE)
815     {
816       g_object_unref(request);
817       return FALSE;
818     }
819     inf_adopted_request_log_add_request(log, request);
820     g_object_unref(request);
821     return TRUE;
822   }
823   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
824   return parent_class-&gt;process_xml_sync(session, connection, xml, error);
825 }
826 static InfCommunicationScope
827 inf_adopted_session_process_xml_run(InfSession* session,
828                                     InfXmlConnection* connection,
829                                     const xmlNodePtr xml,
830                                     GError** error)
831 {
832   InfAdoptedSessionPrivate* priv;
833   InfAdoptedSessionClass* session_class;
834   InfAdoptedRequest* request;
835   InfAdoptedUser* user;
836   guint user_id;
837   InfAdoptedStateVector* user_vector;
838   InfAdoptedStateVector* request_vector;
839   gboolean has_num;
840   gboolean process_request;
841   guint num;
842   GError* local_error;
843   InfAdoptedRequest* copy_req;
844   guint i;
845   gchar* request_str;
846   gchar* user_str;
847   InfSessionClass* parent_class;
848   priv = INF_ADOPTED_SESSION_PRIVATE(session);
849   if(strcmp((const char*)xml-&gt;name, "request") == 0)
850   {
851     session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
852     g_assert(session_class-&gt;xml_to_request != NULL);
853     user = inf_adopted_session_user_from_request_xml(
854       INF_ADOPTED_SESSION(session),
855       xml,
856       error
857     );
858     if(user == NULL)
859       return INF_COMMUNICATION_SCOPE_PTP;
860     if(inf_user_get_status(INF_USER(user)) == INF_USER_UNAVAILABLE ||
861        inf_user_get_connection(INF_USER(user)) != connection)
862     {
863       g_set_error_literal(
864         error,
865         inf_user_error_quark(),
866         INF_USER_ERROR_NOT_JOINED,
867         _("User did not join from this connection")
868       );
869       return INF_COMMUNICATION_SCOPE_PTP;
870     }
871     local_error = NULL;
872     has_num = inf_xml_util_get_attribute_uint(xml, "num", &amp;num, &amp;local_error);
873     if(local_error != NULL)
874     {
875       g_propagate_error(error, local_error);
876       return INF_COMMUNICATION_SCOPE_PTP;
877     }
878     if(has_num == FALSE)
879       num = 1;
880     user_id = inf_user_get_id(INF_USER(user));
881     user_vector = inf_adopted_user_get_vector(user);
882     request = session_class-&gt;xml_to_request(
883       INF_ADOPTED_SESSION(session),
884       xml,
885       user_vector,
886       FALSE,
887       error
888     );
889     if(request == NULL)
890       return INF_COMMUNICATION_SCOPE_PTP;
891     request_vector = inf_adopted_request_get_vector(request);
892     if(!inf_adopted_state_vector_causally_before(user_vector, request_vector))
893     {
894       g_assert_not_reached();
895     }
896     else if(inf_adopted_request_get_index(request) !=
897             inf_adopted_state_vector_get(user_vector, user_id))
898     {
899       request_str = inf_adopted_state_vector_to_string(request_vector);
900       user_str = inf_adopted_state_vector_to_string(user_vector);
901       g_set_error(
902         error,
903         inf_adopted_session_error_quark,
904         INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
905         _("Request \"%s\" by user \"%s\" is not consecutive with respect to "
906           "previously received request \"%s\""),
907         request_str,
908         inf_user_get_name(INF_USER(user)),
909         user_str
910       );
911       g_free(request_str);
912       g_free(user_str);
913       g_object_unref(request);
914       return INF_COMMUNICATION_SCOPE_PTP;
915     }
916     user_vector = inf_adopted_state_vector_copy(request_vector);
917     inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
918     for(i = 0; i &lt; num; ++i)
919     {
920       if(i == 0)
921       {
922         copy_req = request;
923         g_object_ref(copy_req);
924       }
925       else
926       {
927         copy_req = inf_adopted_request_copy(request);
928         inf_adopted_state_vector_add(
929           inf_adopted_request_get_vector(copy_req),
930           inf_user_get_id(INF_USER(user)),
931           i
932         );
933       }
934       process_request = inf_adopted_session_process_request(
935         INF_ADOPTED_SESSION(session),
936         copy_req,
937         user,
938         error
939       );
940       g_object_unref(copy_req);
941       if(inf_adopted_request_affects_buffer(request))
942       {
943         user_vector = inf_adopted_state_vector_copy(
944           inf_adopted_request_get_vector(copy_req)
945         );
946         inf_adopted_state_vector_add(user_vector, user_id, 1);
947         inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
948       }
949       if(process_request == FALSE)
950         break;
951     }
952     g_object_unref(request);
953     if(i &gt; 0)
954     {
955       inf_adopted_session_process_buffered_requests(
956         INF_ADOPTED_SESSION(session)
957       );
958     }
959     inf_adopted_algorithm_cleanup(
960       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
961     );
962     return INF_COMMUNICATION_SCOPE_GROUP;
963   }
964   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
965   return parent_class-&gt;process_xml_run(session, connection, xml, error);
966 }
967 static GArray*
968 inf_adopted_session_get_xml_user_props(InfSession* session,
969                                        InfXmlConnection* conn,
970                                        const xmlNodePtr xml)
971 {
972   InfSessionClass* parent_class;
973   GArray* array;
974   GParameter* parameter;
975   InfAdoptedStateVector* vector;
976   xmlChar* time;
977   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
978   array = parent_class-&gt;get_xml_user_props(session, conn, xml);
979   time = inf_xml_util_get_attribute(xml, "time");
980   if(time != NULL)
981   {
982     vector = inf_adopted_state_vector_from_string((const gchar*)time, NULL);
983     xmlFree(time);
984     if(vector != NULL)
985     {
986       parameter = inf_session_get_user_property(array, "vector");
987       g_value_init(&amp;parameter-&gt;value, INF_ADOPTED_TYPE_STATE_VECTOR);
988       g_value_take_boxed(&amp;parameter-&gt;value, vector);
989     }
990   }
991   return array;
992 }
993 static void
994 inf_adopted_session_set_xml_user_props(InfSession* session,
995                                        const GParameter* params,
996                                        guint n_params,
997                                        xmlNodePtr xml)
998 {
999   InfSessionClass* parent_class;
1000   InfAdoptedSessionPrivate* priv;
1001   const GParameter* time;
1002   InfAdoptedStateVector* vector;
1003   gchar* time_string;
1004   const GParameter* id_param;
1005   guint id;
1006   GSList* item;
1007   InfAdoptedSessionLocalUser* local_user;
1008   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1009   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
1010   priv = INF_ADOPTED_SESSION_PRIVATE(INF_ADOPTED_SESSION(session));
1011   time = inf_session_lookup_user_property(params, n_params, "vector");
1012   if(time != NULL)
1013   {
1014     vector = NULL;
1015     id_param = inf_session_lookup_user_property(params, n_params, "id");
1016     if(id_param != NULL)
1017     {
1018       id = g_value_get_uint(&amp;id_param-&gt;value);
1019       for(item = priv-&gt;local_users; item != NULL; item = item-&gt;next)
1020       {
1021         local_user = (InfAdoptedSessionLocalUser*)item-&gt;data;
1022         if(inf_user_get_id(INF_USER(local_user-&gt;user)) == id)
1023         {
1024           vector = local_user-&gt;last_send_vector;
1025           break;
1026         }
1027       }
1028     }
1029     if(vector == NULL)
1030     {
1031       vector = (InfAdoptedStateVector*)g_value_get_boxed(&amp;time-&gt;value);
1032     }
1033     time_string = inf_adopted_state_vector_to_string(vector);
1034     inf_xml_util_set_attribute(xml, "time", time_string);
1035     g_free(time_string);
1036   }
1037 }
1038 static gboolean
1039 inf_adopted_session_validate_user_props(InfSession* session,
1040                                         const GParameter* params,
1041                                         guint n_params,
1042                                         InfUser* exclude,
1043                                         GError** error)
1044 {
1045   InfSessionClass* parent_class;
1046   const GParameter* time;
1047   gboolean result;
1048   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1049   result = parent_class-&gt;validate_user_props(
1050     session,
1051     params,
1052     n_params,
1053     exclude,
1054     error
1055   );
1056   if(result == FALSE) return FALSE;
1057   time = inf_session_lookup_user_property(params, n_params, "vector");
1058   if(time == NULL)
1059   {
1060     g_set_error_literal(
1061       error,
1062       inf_adopted_session_error_quark,
1063       INF_ADOPTED_SESSION_ERROR_MISSING_STATE_VECTOR,
1064       _("\"time\" attribute in user message is missing")
1065     );
1066     return FALSE;
1067   }
1068   return TRUE;
1069 }
1070 static void
1071 inf_adopted_session_close(InfSession* session)
1072 {
1073   InfAdoptedSessionPrivate* priv;
1074   InfAdoptedSessionLocalUser* local;
1075   GSList* item;
1076   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1077   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
1078   {
1079     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
1080     inf_adopted_state_vector_free(local-&gt;last_send_vector);
1081     g_slice_free(InfAdoptedSessionLocalUser, local);
1082   }
1083   g_slist_free(priv-&gt;local_users);
1084   priv-&gt;local_users = NULL;
1085   INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;close(session);
1086 }
1087 static void
1088 inf_adopted_session_synchronization_complete_foreach_user_func(InfUser* user,
1089                                                                gpointer data)
1090 {
1091   InfAdoptedRequestLog* log;
1092   log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
1093   if(inf_adopted_request_log_is_empty(log))
1094   {
1095     inf_adopted_request_log_set_begin(
1096       log,
1097       inf_adopted_state_vector_get(
1098         inf_adopted_user_get_vector(INF_ADOPTED_USER(user)),
1099         inf_user_get_id(user)
1100       )
1101     );
1102   }
1103 }
1104 static void
1105 inf_adopted_session_synchronization_complete(InfSession* session,
1106                                              InfXmlConnection* connection)
1107 {
1108   InfSessionClass* parent_class;
1109   InfAdoptedSessionPrivate* priv;
1110   InfSessionStatus status;
1111   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1112   status = inf_session_get_status(session);
1113   g_object_freeze_notify(G_OBJECT(session));
1114   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1115   parent_class-&gt;synchronization_complete(session, connection);
1116   if(status == INF_SESSION_SYNCHRONIZING)
1117   {
1118     inf_user_table_foreach_user(
1119       inf_session_get_user_table(session),
1120       inf_adopted_session_synchronization_complete_foreach_user_func,
1121       NULL
1122     );
1123     g_assert(priv-&gt;algorithm == NULL);
1124     inf_adopted_session_create_algorithm(INF_ADOPTED_SESSION(session));
1125   }
1126   g_object_thaw_notify(G_OBJECT(session));
1127 }
1128 static gboolean
1129 inf_adopted_session_check_request(InfAdoptedSession* session,
1130                                   InfAdoptedRequest* request,
1131                                   InfAdoptedUser* user)
1132 {
1133   return FALSE;
1134 }
1135 static void
1136 inf_adopted_session_class_init(InfAdoptedSessionClass* adopted_session_class)
1137 {
1138   GObjectClass* object_class;
1139   InfSessionClass* session_class;
1140   object_class = G_OBJECT_CLASS(adopted_session_class);
1141   session_class = INF_SESSION_CLASS(adopted_session_class);
1142   object_class-&gt;constructed = inf_adopted_session_constructed;
1143   object_class-&gt;dispose = inf_adopted_session_dispose;
1144   object_class-&gt;finalize = inf_adopted_session_finalize;
1145   object_class-&gt;set_property = inf_adopted_session_set_property;
1146   object_class-&gt;get_property = inf_adopted_session_get_property;
1147   session_class-&gt;to_xml_sync = inf_adopted_session_to_xml_sync;
1148   session_class-&gt;process_xml_sync = inf_adopted_session_process_xml_sync;
1149   session_class-&gt;process_xml_run = inf_adopted_session_process_xml_run;
1150   session_class-&gt;get_xml_user_props = inf_adopted_session_get_xml_user_props;
1151   session_class-&gt;set_xml_user_props = inf_adopted_session_set_xml_user_props;
1152   session_class-&gt;validate_user_props =
1153     inf_adopted_session_validate_user_props;
1154   session_class-&gt;close = inf_adopted_session_close;
1155   session_class-&gt;synchronization_complete =
1156     inf_adopted_session_synchronization_complete;
1157   adopted_session_class-&gt;xml_to_request = NULL;
1158   adopted_session_class-&gt;request_to_xml = NULL;
1159   adopted_session_class-&gt;check_request = inf_adopted_session_check_request;
1160   inf_adopted_session_error_quark = g_quark_from_static_string(
1161     "INF_ADOPTED_SESSION_ERROR"
1162   );
1163   session_signals[CHECK_REQUEST] = g_signal_new(
1164     "check-request",
1165     G_OBJECT_CLASS_TYPE(object_class),
1166     G_SIGNAL_RUN_LAST,
1167     G_STRUCT_OFFSET(InfAdoptedSessionClass, check_request),
1168     g_signal_accumulator_true_handled, NULL,
1169     NULL,
1170     G_TYPE_BOOLEAN,
1171     2,
1172     INF_ADOPTED_TYPE_REQUEST,
1173     INF_ADOPTED_TYPE_USER
1174   );
1175   g_object_class_install_property(
1176     object_class,
1177     PROP_IO,
1178     g_param_spec_object(
1179       "io",
1180       "IO",
1181       "The IO object used for timeouts",
1182       INF_TYPE_IO,
1183       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1184     )
1185   );
1186   g_object_class_install_property(
1187     object_class,
1188     PROP_MAX_TOTAL_LOG_SIZE,
1189     g_param_spec_uint(
1190       "max-total-log-size",
1191       "Maxmimum total log size",
1192       "The maximum number of requests to keep in all user's logs",
1193       0,
1194       G_MAXUINT,
1195       2048,
1196       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1197     )
1198   );
1199   g_object_class_install_property(
1200     object_class,
1201     PROP_ALGORITHM,
1202     g_param_spec_object(
1203       "algorithm",
1204       "Algorithm",
1205       "The adOPTed algorithm used for translating incoming requests",
1206       INF_ADOPTED_TYPE_ALGORITHM,
1207       G_PARAM_READABLE
1208     )
1209   );
1210 }
1211 InfIo*
1212 inf_adopted_session_get_io(InfAdoptedSession* session)
1213 {
1214   g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
1215   return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;io;
1216 }
1217 InfAdoptedAlgorithm*
1218 inf_adopted_session_get_algorithm(InfAdoptedSession* session)
1219 {
1220   g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
1221   return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;algorithm;
1222 }
1223 void
1224 inf_adopted_session_broadcast_request(InfAdoptedSession* session,
1225                                       InfAdoptedRequest* request)
1226 {
1227   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1228   g_return_if_fail(INF_ADOPTED_IS_REQUEST(request));
1229   inf_adopted_session_broadcast_n_requests(session, request, 1);
1230 }
1231 void
1232 inf_adopted_session_undo(InfAdoptedSession* session,
1233                          InfAdoptedUser* user,
1234                          guint n)
1235 {
1236   InfAdoptedSessionPrivate* priv;
1237   InfAdoptedRequest* first_request;
1238   InfAdoptedRequest* request;
1239   guint i;
1240   gboolean result;
1241   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1242   g_return_if_fail(INF_ADOPTED_IS_USER(user));
1243   g_return_if_fail(n &gt;= 1);
1244   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1245   first_request = NULL;
1246   for(i = 0; i &lt; n; ++i)
1247   {
1248     request = inf_adopted_algorithm_generate_request(
1249       priv-&gt;algorithm,
1250       INF_ADOPTED_REQUEST_UNDO,
1251       user,
1252       NULL
1253     );
1254     result = inf_adopted_algorithm_execute_request(
1255       priv-&gt;algorithm,
1256       request,
1257       TRUE,
1258       NULL
1259     );
1260     g_assert(result == TRUE);
1261     if(first_request == NULL)
1262       first_request = request;
1263     else
1264       g_object_unref(request);
1265   }
1266   inf_adopted_session_broadcast_n_requests(session, first_request, n);
1267   g_object_unref(first_request);
1268 }
1269 void
1270 inf_adopted_session_redo(InfAdoptedSession* session,
1271                          InfAdoptedUser* user,
1272                          guint n)
1273 {
1274   InfAdoptedSessionPrivate* priv;
1275   InfAdoptedRequest* first_request;
1276   InfAdoptedRequest* request;
1277   guint i;
1278   gboolean result;
1279   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1280   g_return_if_fail(INF_ADOPTED_IS_USER(user));
1281   g_return_if_fail(n &gt;= 1);
1282   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1283   first_request = NULL;
1284   for(i = 0; i &lt; n; ++i)
1285   {
1286     request = inf_adopted_algorithm_generate_request(
1287       priv-&gt;algorithm,
1288       INF_ADOPTED_REQUEST_REDO,
1289       user,
1290       NULL
1291     );
1292     result = inf_adopted_algorithm_execute_request(
1293       priv-&gt;algorithm,
1294       request,
1295       TRUE,
1296       NULL
1297     );
1298     g_assert(result == TRUE);
1299     if(first_request == NULL)
1300       first_request = request;
1301     else
1302       g_object_unref(request);
1303   }
1304   inf_adopted_session_broadcast_n_requests(session, first_request, n);
1305   g_object_unref(first_request);
1306 }
1307 gboolean
1308 inf_adopted_session_read_request_info(InfAdoptedSession* session,
1309                                       xmlNodePtr xml,
1310                                       InfAdoptedStateVector* diff_vec,
1311                                       InfAdoptedUser** user,
1312                                       InfAdoptedStateVector** time,
1313                                       xmlNodePtr* operation,
1314                                       GError** error)
1315 {
1316   xmlChar* attr;
1317   xmlNodePtr child;
1318   if(user != NULL)
1319   {
1320     *user = inf_adopted_session_user_from_request_xml(session, xml, error);
1321     if(*user == NULL) return FALSE;
1322   }
1323   if(time != NULL)
1324   {
1325     attr = inf_xml_util_get_attribute_required(xml, "time", error);
1326     if(attr == NULL) return FALSE;
1327     if(diff_vec == NULL)
1328     {
1329       *time = inf_adopted_state_vector_from_string((const gchar*)attr, error);
1330     }
1331     else
1332     {
1333       *time = inf_adopted_state_vector_from_string_diff(
1334         (const gchar*)attr,
1335         diff_vec,
1336         error
1337       );
1338     }
1339     xmlFree(attr);
1340     if(*time == NULL) return FALSE;
1341   }
1342   if(operation != NULL)
1343   {
1344     child = xml-&gt;children;
1345     while(child != NULL &amp;&amp; child-&gt;type != XML_ELEMENT_NODE)
1346       child = child-&gt;next;
1347     if(child == NULL)
1348     {
1349       g_set_error_literal(
1350         error,
1351         inf_adopted_session_error_quark,
1352         INF_ADOPTED_SESSION_ERROR_MISSING_OPERATION,
1353         _("Operation for request missing")
1354       );
1355       if(time) inf_adopted_state_vector_free(*time);
1356       return FALSE;
1357     }
1358     *operation = child;
1359   }
1360   return TRUE;
1361 }
1362 void
1363 inf_adopted_session_write_request_info(InfAdoptedSession* session,
1364                                        InfAdoptedRequest* request,
1365                                        InfAdoptedStateVector* diff_vec,
1366                                        xmlNodePtr xml,
1367                                        xmlNodePtr operation)
1368 {
1369   InfAdoptedStateVector* vector;
1370   guint user_id;
1371   gchar* vec_str;
1372   vector = inf_adopted_request_get_vector(request);
1373   user_id = inf_adopted_request_get_user_id(request);
1374   inf_xml_util_set_attribute_uint(xml, "user", user_id);
1375   if(diff_vec == NULL)
1376     vec_str = inf_adopted_state_vector_to_string(vector);
1377   else
1378     vec_str = inf_adopted_state_vector_to_string_diff(vector, diff_vec);
1379   inf_xml_util_set_attribute(xml, "time", vec_str);
1380   g_free(vec_str);
1381   if(operation != NULL)
1382     xmlAddChild(xml, operation);
1383 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
