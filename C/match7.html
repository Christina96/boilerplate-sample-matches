<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for index.c &amp; blob.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for index.c &amp; blob.c
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>index.c (8.5161295%)<th>blob.c (2.862099%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(83-89)<td><a href="#" name="0">(765-777)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(276-288)<td><a href="#" name="1">(879-889)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(830-849)<td><a href="#" name="2">(2260-2277)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(706-716)<td><a href="#" name="3">(148-158)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(415-431)<td><a href="#" name="4">(77-93)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>index.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "features.h"
2 #include &lt;sys/types.h&gt;
3 #include &lt;sys/stat.h&gt;
4 #include &lt;sys/socket.h&gt;
5 #include &lt;sys/mman.h&gt;
6 #include &lt;sys/wait.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;errno.h&gt;
9 #include &lt;fcntl.h&gt;
10 #include &lt;inttypes.h&gt;
11 #include &lt;pthread.h&gt;
12 #include &lt;stdio.h&gt;
13 #include &lt;stdlib.h&gt;
14 #include &lt;string.h&gt;
15 #include &lt;unistd.h&gt;
16 #include "blob.h"
17 #include "measure_points.h"
18 int eblob_key_sort(const void *key1, const void *key2)
19 {
20 	return eblob_id_cmp(((struct eblob_key *)key1)-&gt;id, ((struct eblob_key *)key2)-&gt;id);
21 }
22 int eblob_disk_control_sort(const void *d1, const void *d2)
23 {
24 	const struct eblob_disk_control *dc1 = d1;
25 	const struct eblob_disk_control *dc2 = d2;
26 	return eblob_id_cmp(dc1-&gt;key.id, dc2-&gt;key.id);
27 }
28 int eblob_disk_control_sort_with_flags(const void *d1, const void *d2)
29 {
30 	const struct eblob_disk_control *dc1 = d1;
31 	const struct eblob_disk_control *dc2 = d2;
32 	int cmp = eblob_id_cmp(dc1-&gt;key.id, dc2-&gt;key.id);
33 	if (cmp == 0) {
34 		if ((dc1-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp; !(dc2-&gt;flags &amp; BLOB_DISK_CTL_REMOVE))
35 			cmp = -1;
36 		if (!(dc1-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp; (dc2-&gt;flags &amp; BLOB_DISK_CTL_REMOVE))
37 <a name="0"></a>			cmp = 1;
38 	}
39 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return cmp;
40 }
41 static int eblob_key_range_cmp(const void *k1, const void *k2)
42 {
43 	const struct eblob_key *key = k1;
44 	const struct eblob_index_block *index = k2;</b></font>
45 	int cmp;
46 	cmp = eblob_id_cmp(key-&gt;id, index-&gt;start_key.id);
47 	if (cmp &lt; 0)
48 		return -1;
49 	if (cmp == 0)
50 		return 0;
51 	cmp = eblob_id_cmp(key-&gt;id, index-&gt;end_key.id);
52 	if (cmp &lt; 0)
53 		return 0;
54 	if (cmp == 0)
55 		return 0;
56 	return 1;
57 }
58 int eblob_index_block_cmp(const void *k1, const void *k2)
59 {
60 	const struct eblob_index_block *k = k1;
61 	return eblob_key_range_cmp(&amp;k-&gt;start_key, k2);
62 }
63 static int eblob_find_non_removed_callback(struct eblob_disk_control *sorted,
64 		struct eblob_disk_control *dc __attribute_unused__)
65 {
66 	uint64_t rem = eblob_bswap64(BLOB_DISK_CTL_REMOVE);
67 	return !(sorted-&gt;flags &amp; rem);
68 }
69 int eblob_index_blocks_destroy(struct eblob_base_ctl *bctl)
70 {
71 	pthread_rwlock_wrlock(&amp;bctl-&gt;index_blocks_lock);
72 	free(bctl-&gt;index_blocks);
73 	free(bctl-&gt;bloom);
74 	bctl-&gt;index_blocks = NULL;
75 	bctl-&gt;bloom = NULL;
76 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_BLOOM_SIZE, 0);
77 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE, 0);
78 	pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
79 	return 0;
80 }
81 struct eblob_index_block *eblob_index_blocks_search_nolock_bsearch_nobloom(struct eblob_base_ctl *bctl, struct eblob_disk_control *dc,
82 		struct eblob_disk_search_stat *st)
83 {
84 	struct eblob_index_block *t = NULL;
85 	t = bsearch(&amp;dc-&gt;key, bctl-&gt;index_blocks,
86 		eblob_stat_get(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE) / sizeof(struct eblob_index_block),
87 		sizeof(struct eblob_index_block), eblob_key_range_cmp);
88 	if (t)
89 		st-&gt;found_index_block++;
90 	return t;
91 }
92 struct eblob_index_block *eblob_index_blocks_search_nolock(struct eblob_base_ctl *bctl, struct eblob_disk_control *dc,
93 		struct eblob_disk_search_stat *st)
94 {
95 	struct eblob_index_block *t = NULL;
96 	if (!eblob_bloom_get(bctl, &amp;dc-&gt;key)) {
97 		st-&gt;bloom_null++;
98 		return NULL;
99 	}
100 	t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, dc, st);
101 	if (!t)
102 		st-&gt;no_block++;
103 	return t;
104 }
105 static uint64_t eblob_bloom_size(const struct eblob_base_ctl *bctl)
106 {
107 	uint64_t bloom_size = 0;
108 	bloom_size += bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control);
109 	bloom_size /= bctl-&gt;back-&gt;cfg.index_block_size;
110 	bloom_size += 1;
111 	bloom_size *= bctl-&gt;back-&gt;cfg.index_block_bloom_length;
112 	bloom_size /= 8;
113 	return bloom_size;
114 }
115 static uint8_t eblob_bloom_func_num(const struct eblob_base_ctl *bctl)
116 {
117 	uint64_t bits_per_key;
118 	uint8_t func_num = 0;
119 	bits_per_key = 8 * bctl-&gt;bloom_size /
120 		(bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control));
121 	func_num = bits_per_key * 0.69;
122 	if (func_num == 0)
123 		return 1;
124 	if (func_num &gt; 20)
125 		return 20;
126 	return func_num;
127 }
128 int eblob_index_blocks_fill(struct eblob_base_ctl *bctl)
129 {
130 	struct eblob_index_block *block = NULL;
131 	struct eblob_disk_control dc, prev;
132 	uint64_t block_count, block_id = 0, err_count = 0, offset = 0, prev_offset = 0;
133 	int64_t removed = 0;
134 	int64_t removed_size = 0;
135 	unsigned int i;
136 	int err = 0;
137 	int prev_filled = 0;
138 	bctl-&gt;bloom_size = eblob_bloom_size(bctl);
139 	EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_NOTICE,
140 			"index: bloom filter size: %" PRIu64, bctl-&gt;bloom_size);
141 	bctl-&gt;bloom_func_num = eblob_bloom_func_num(bctl);
142 	bctl-&gt;bloom = calloc(1, bctl-&gt;bloom_size);
143 	if (bctl-&gt;bloom == NULL) {
144 		err = -err;
145 		goto err_out_exit;
146 	}
147 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_BLOOM_SIZE, bctl-&gt;bloom_size);
148 	block_count = howmany(bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control),
149 			bctl-&gt;back-&gt;cfg.index_block_size);
150 	bctl-&gt;index_blocks = calloc(block_count, sizeof(struct eblob_index_block));
151 	if (bctl-&gt;index_blocks == NULL) {
152 		err = -ENOMEM;
153 		goto err_out_exit;
154 	}
155 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE,
156 			block_count * sizeof(struct eblob_index_block));
157 	while (offset &lt; bctl-&gt;index_ctl.size) {
158 		block = &amp;bctl-&gt;index_blocks[block_id++];
159 		block-&gt;start_offset = offset;
160 		for (i = 0; i &lt; bctl-&gt;back-&gt;cfg.index_block_size &amp;&amp; offset &lt; bctl-&gt;index_ctl.size; ++i) {
161 			err = pread(bctl-&gt;index_ctl.fd, &amp;dc, sizeof(struct eblob_disk_control), offset);
162 			if (err != sizeof(struct eblob_disk_control)) {
163 				if (err &lt; 0)
164 					err = -errno;
165 				goto err_out_drop_tree;
166 <a name="1"></a>			}
167 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			err = eblob_check_record(bctl, &amp;dc);
168 			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: eblob_index_blocks_fill: %s: index: %d, "
169 				"index position: %llu, data position: %llu, "
170 				"data size: %llu, disk size: %llu, flags: %s, check-error: %d\n",
171 				eblob_dump_id_len(dc.key.id, EBLOB_ID_SIZE),
172 				bctl-&gt;index,
173 				(unsigned long long)offset, (unsigned long long)dc.position,
174 				(unsigned long long)dc.data_size, (unsigned long long)dc.disk_size,
175 				eblob_dump_dctl_flags(dc.flags), err);
176 			if (err != 0) {</b></font>
177 				eblob_stat_inc(bctl-&gt;stat, EBLOB_LST_INDEX_CORRUPTED_ENTRIES);
178 				if (err_count++ &gt; EBLOB_BLOB_INDEX_CORRUPT_MAX
179 						|| i == 0 || i == bctl-&gt;back-&gt;cfg.index_block_size - 1) {
180 					EBLOB_WARNC(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
181 							"EB0001: too many index corruptions: %" PRIu64
182 							", can not continue", err_count);
183 					EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
184 							"running `eblob_merge` on '%s' should help:", bctl-&gt;name);
185 					EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
186 							"http://doc.reverbrain.com/kb:eblob:eb0001-index-corruption");
187 					goto err_out_drop_tree;
188 				}
189 				offset += sizeof(struct eblob_disk_control);
190 				continue;
191 			}
192 			if (prev_filled) {
193 				int cmp = eblob_id_cmp(prev.key.id, dc.key.id);
194 				if (cmp &gt; 0) {
195 					char prev_str[256];
196 					char cur_str[256];
197 					err = -ECHRNG;
198 					eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob_index_blocks_fill: order mismatch: "
199 						"index: %d, "
200 						"prev: index position: %llu, %s, current index position: %llu, %s, check-error: %d: "
201 						"you have to remove sorted index and regenerate it from data using `eblob_to_index` tool "
202 						"on '%s'\n",
203 						bctl-&gt;index,
204 						(unsigned long long)prev_offset, eblob_dump_dc(&amp;prev, prev_str, sizeof(prev_str)),
205 						(unsigned long long)offset, eblob_dump_dc(&amp;dc, cur_str, sizeof(cur_str)),
206 						err, bctl-&gt;name);
207 					goto err_out_drop_tree;
208 				}
209 			}
210 			prev = dc;
211 			prev_offset = offset;
212 			prev_filled = 1;
213 			if (i == 0)
214 				block-&gt;start_key = dc.key;
215 			if (dc.flags &amp; eblob_bswap64(BLOB_DISK_CTL_REMOVE)) {
216 				removed++;
217 				removed_size += dc.disk_size + sizeof(struct eblob_disk_control);
218 			} else {
219 				eblob_bloom_set(bctl, &amp;dc.key);
220 			}
221 			offset += sizeof(struct eblob_disk_control);
222 		}
223 		block-&gt;end_offset = offset;
224 		block-&gt;end_key = dc.key;
225 	}
226 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_RECORDS_REMOVED, removed);
227 	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_REMOVED_SIZE, removed_size);
228 	return 0;
229 err_out_drop_tree:
230 	eblob_index_blocks_destroy(bctl);
231 err_out_exit:
232 	return err;
233 }
234 static int eblob_find_on_disk(struct eblob_backend *b,
235 		struct eblob_base_ctl *bctl, struct eblob_disk_control *dc, uint64_t *hdr_offset,
236 		int (* callback)(struct eblob_disk_control *sorted, struct eblob_disk_control *dc),
237 		struct eblob_disk_search_stat *st)
238 {
239 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.lookup.one", b-&gt;cfg.stat_id));
240 	struct eblob_disk_control *sorted, *end, *sorted_orig, *found = NULL;
241 	struct eblob_disk_control *hdr_block, *search_start, *search_end;
242 	struct eblob_index_block *block;
243 	size_t num;
244 	ssize_t hdr_block_size;
245 	uint64_t hdr_block_offset, saved_hdr_block_offset;
246 	const size_t hdr_size = sizeof(struct eblob_disk_control);
247 	int read_err, err = -ENOENT;
248 	st-&gt;search_on_disk++;
249 	pthread_rwlock_rdlock(&amp;bctl-&gt;index_blocks_lock);
250 	block = eblob_index_blocks_search_nolock(bctl, dc, st);
251 	if (block) {
252 		assert((bctl-&gt;index_ctl.size - block-&gt;start_offset) / hdr_size &gt; 0);
253 		assert((bctl-&gt;index_ctl.size - block-&gt;start_offset) % hdr_size == 0);
254 		num = (bctl-&gt;index_ctl.size - block-&gt;start_offset) / hdr_size;
255 		if (num &gt; b-&gt;cfg.index_block_size)
256 			num = b-&gt;cfg.index_block_size;
257 		hdr_block_size = num * hdr_size;
258 		saved_hdr_block_offset = hdr_block_offset = block-&gt;start_offset;
259 	} else {
260 		pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
261 		goto err_out_exit;
262 	}
263 	pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
264 <a name="4"></a>
265 	st-&gt;bsearch_reached++;
266 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	hdr_block = malloc(hdr_block_size);
267 	if (!hdr_block) {
268 		err = -ENOMEM;
269 		goto err_out_exit;
270 	}
271 	read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
272 	if (read_err &lt; 0) {
273 		err = read_err;
274 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
275 				", block_size: %zu, blob_size: %" PRIu64
276 				", num: %zu, FAILED: %s: %d.\n",
277 			  eblob_dump_id(dc-&gt;key.id),
278 			  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
279 			  bctl-&gt;index_ctl.size, num, strerror(-err), err);
280 		goto err_out_free_index;
281 	}</b></font>
282 	search_start = hdr_block;
283 	search_end = search_start + (num - 1);
284 	sorted_orig = bsearch(dc, search_start, num, sizeof(struct eblob_disk_control), eblob_disk_control_sort);
285 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_SPAM, "%s: position: %" PRIu64 ", block_size: %zd, index_size: %" PRIu64 ", num: %zu\n",
286 			eblob_dump_id(dc-&gt;key.id),
287 			hdr_block_offset, hdr_block_size, bctl-&gt;index_ctl.size, num);
288 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_SPAM, "%s: bsearch range: start: %s, end: %s, num: %zd\n",
289 			eblob_dump_id(dc-&gt;key.id),
290 			eblob_dump_id(search_start-&gt;key.id),
291 			eblob_dump_id(search_end-&gt;key.id), num);
292 	if (!sorted_orig)
293 		goto err_out_free_index;
294 	st-&gt;bsearch_found++;
295 	sorted = sorted_orig;
296 	end = search_end;
297 	while (eblob_disk_control_sort(sorted, dc) == 0) {
298 		if (callback(sorted, dc)) {
299 			found = sorted;
300 			break;
301 		}
302 		st-&gt;additional_reads++;
303 		if (++sorted &gt; end) {
304 			hdr_block_offset += hdr_block_size;
305 			if (hdr_block_offset &gt;= bctl-&gt;index_ctl.size)
306 				break;
307 			num = (bctl-&gt;index_ctl.size - hdr_block_offset) / hdr_size;
308 			if (num &gt; b-&gt;cfg.index_block_size)
309 				num = b-&gt;cfg.index_block_size;
310 			hdr_block_size = num * hdr_size;
311 			sorted = hdr_block;
312 			end = sorted + (num - 1);
313 			read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
314 			if (read_err &lt; 0) {
315 				err = read_err;
316 				eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
317 						", block_size: %zd, blob_size: %" PRIu64 ", num: %zu, FAILED: %s: %d.\n",
318 					  eblob_dump_id(dc-&gt;key.id),
319 					  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
320 					  bctl-&gt;index_ctl.size, num, strerror(-err), err);
321 				break;
322 			}
323 		}
324 	}
325 	if (found) {
326 		err = 0;
327 		memcpy(dc, found, hdr_size);
328 		*hdr_offset = hdr_block_offset + ((void *)found - (void *)hdr_block);
329 		goto err_out_free_index;
330 	}
331 	hdr_block_offset = saved_hdr_block_offset + hdr_block_size;
332 	sorted = hdr_block - 1;
333 	while (1) {
334 	    if (sorted &gt;= hdr_block) {
335 		st-&gt;additional_reads++;
336 		if (eblob_disk_control_sort(sorted, dc))
337 			break;
338 		if (callback(sorted, dc)) {
339 			found = sorted;
340 			break;
341 		}
342 		sorted--;
343 	    } else {
344 		if (!hdr_block_offset)
345 			break;
346 		if (hdr_block_offset &lt; (uint64_t)hdr_block_size) {
347 			hdr_block_size = hdr_block_offset;
348 			num = hdr_block_size / hdr_size;
349 			hdr_block_offset = 0;
350 		} else {
351 			hdr_block_offset -= hdr_block_size;
352 		}
353 		read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
354 		if (read_err &lt; 0) {
355 			err = read_err;
356 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
357 					", block_size: %zd, blob_size: %" PRIu64 ", num: %zu, FAILED: %s: %d.\n",
358 				  eblob_dump_id(dc-&gt;key.id),
359 				  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
360 				  bctl-&gt;index_ctl.size, num, strerror(-err), err);
361 			break;
362 		}
363 		if (hdr_block_offset == saved_hdr_block_offset) {
364 			sorted = sorted_orig - 1;
365 		} else {
366 			sorted = hdr_block + (num - 1);
367 		}
368 	    }
369 	}
370 	if (found) {
371 		err = 0;
372 		memcpy(dc, found, hdr_size);
373 		*hdr_offset = hdr_block_offset + ((void *)found - (void *)hdr_block);
374 		goto err_out_free_index;
375 	}
376 err_out_free_index:
377 	free(hdr_block);
378 err_out_exit:
379 	return err;
380 }
381 ssize_t eblob_get_actual_size(int fd)
382 {
383 	struct stat st;
384 	ssize_t err;
385 	err = fstat(fd, &amp;st);
386 	if (err &lt; 0)
387 		return err;
388 	return st.st_size;
389 }
390 static int indexsort_binlog_start(struct eblob_backend *b, struct eblob_base_ctl *bctl) {
391 	int err = 0;
392 	pthread_mutex_lock(&amp;b-&gt;lock);
393 	eblob_base_wait_locked(bctl);
394 	err = eblob_binlog_start(&amp;bctl-&gt;binlog);
395 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
396 	pthread_mutex_unlock(&amp;b-&gt;lock);
397 	return err;
398 }
399 static int indexsort_binlog_apply(struct eblob_base_ctl *bctl, void *sorted_index, ssize_t index_size) {
400 	const struct eblob_binlog_entry *it = NULL;
401 	const struct eblob_binlog_cfg * const bcfg = &amp;bctl-&gt;binlog;
402 	static const size_t hdr_size = sizeof(struct eblob_disk_control);
403 	struct eblob_disk_control *dc;
404 	int err = 0;
405 	while ((it = eblob_binlog_iterate(bcfg, it)) != NULL) {
406 		const uint64_t index = sorted_index_bsearch_raw(&amp;it-&gt;key,
407 				sorted_index,
408 				index_size / sizeof(struct eblob_disk_control));
409 		if (index == -1ULL) {
410 			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: skipped",
411 						eblob_dump_id(it-&gt;key.id));
412 			continue;
413 		}
414 		dc = sorted_index + index * hdr_size;
415 		while (((void*)dc &lt; sorted_index + index_size) &amp;&amp; (eblob_id_cmp(it-&gt;key.id, dc-&gt;key.id) == 0)) {
416 			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: indexsort: removing: dc: flags: %s, data_size: %" PRIu64,
417 			            eblob_dump_id(dc-&gt;key.id), eblob_dump_dctl_flags(dc-&gt;flags), dc-&gt;data_size);
418 			dc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
419 			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: indexsort: removing: fd: %d, offset: %" PRIu64,
420 			            eblob_dump_id(it-&gt;key.id), bctl-&gt;data_ctl.fd, dc-&gt;position);
421 			err = eblob_mark_index_removed(bctl-&gt;data_ctl.fd, dc-&gt;position);
422 			if (err != 0) {
423 				EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
424 						"%s: indexsort: eblob_mark_index_removed: FAILED: data, fd: %d, err: %d",
425 						eblob_dump_id(it-&gt;key.id), bctl-&gt;data_ctl.fd, err);
426 				goto err_out_exit;
427 			}
428 			dc += 1;
429 		}
430 	}
431 err_out_exit:
432 	return err;
433 }
434 static int indexsort_flush_cache(struct eblob_backend *b, void *sorted_index, uint64_t index_size) {
435 	int err = 0;
436 	static const size_t hdr_size = sizeof(struct eblob_disk_control);
437 	uint64_t offset;
438 	if (b-&gt;cfg.blob_flags &amp; EBLOB_L2HASH) {
439 		err = eblob_l2hash_empty(&amp;b-&gt;l2hash);
440 	} else {
441 		err = eblob_hash_empty(&amp;b-&gt;hash);
442 	}
443 	if (err) {
444 		return 0;
445 	}
446 	for (offset = 0; offset &lt; index_size; offset += hdr_size) {
447 		struct eblob_disk_control *dc = sorted_index + offset;
448 		if (dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)
449 			continue;
450 		err = eblob_cache_remove_nolock(b, &amp;dc-&gt;key);
451 		if (err) {
452 			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_DEBUG, -err,
453 			            "indexsort: eblob_hash_remove_nolock: %s, offset: %" PRIu64,
454 			            eblob_dump_id(dc-&gt;key.id), offset);
455 		}
456 	}
457 	return 0;
458 }
459 int eblob_generate_sorted_index(struct eblob_backend *b, struct eblob_base_ctl *bctl) {
460 	int fd, old_fd, err, len;
461 	char *file, *dst_file;
462 	ssize_t index_size;
463 	void *sorted_index;
464 	if (b == NULL || bctl == NULL)
465 		return -EINVAL;
466 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "defrag: indexsort: sorting: %s, index: %d",
467 			bctl-&gt;name, bctl-&gt;index);
468 <a name="3"></a>
469 	len = strlen(b-&gt;cfg.file) + sizeof(".index") + sizeof(".sorted") + 256;
470 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	file = malloc(len);
471 	if (!file) {
472 		err = -ENOMEM;
473 		goto err_out_exit;
474 	}
475 	dst_file = malloc(len);
476 	if (!dst_file) {
477 		err = -ENOMEM;
478 		goto err_out_free_file;
479 	}</b></font>
480 	snprintf(file, len, "%s-0.%d.index.tmp", b-&gt;cfg.file, bctl-&gt;index);
481 	snprintf(dst_file, len, "%s-0.%d.index.sorted", b-&gt;cfg.file, bctl-&gt;index);
482 	err = access(dst_file, R_OK);
483 	if (!err) {
484 		err = 0;
485 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: %d: sorted index already exists\n",
486 				bctl-&gt;index);
487 		goto err_out_free_dst_file;
488 	}
489 	fd = open(file, O_RDWR | O_TRUNC | O_CREAT | O_CLOEXEC, 0644);
490 	if (fd &lt; 0) {
491 		err = -errno;
492 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: open: index: %d: %s",
493 				bctl-&gt;index, file);
494 		goto err_out_free_dst_file;
495 	}
496 	index_size = eblob_get_actual_size(bctl-&gt;index_ctl.fd);
497 	if (index_size &lt;= 0) {
498 		err = index_size ? -errno : 0;
499 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: actual-size: index: %d: %s",
500 				bctl-&gt;index, file);
501 		goto err_out_close;
502 	}
503 	err = eblob_preallocate(fd, 0, index_size);
504 	if (err) {
505 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: eblob_preallocate: index: %d, offset: %llu: %s",
506 				bctl-&gt;index, (unsigned long long)index_size, file);
507 		goto err_out_close;
508 	}
509 	sorted_index = malloc(index_size);
510 	if (!sorted_index) {
511 		err = -ENOMEM;
512 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: malloc: index: %d, size: %llu: %s",
513 				bctl-&gt;index, (unsigned long long)index_size, file);
514 		goto err_out_close;
515 	}
516 	err = indexsort_binlog_start(b, bctl);
517 	if (err != 0) {
518 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_binlog_start: index: %d",
519 			    bctl-&gt;index);
520 		goto err_out_free_index;
521 	}
522 	err = __eblob_read_ll(bctl-&gt;index_ctl.fd, sorted_index, index_size, 0);
523 	if (err) {
524 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: read: index: %d, size: %llu: %s",
525 					bctl-&gt;index, (unsigned long long)index_size, file);
526 		goto err_out_stop_binlog;
527 	}
528 	qsort(sorted_index, index_size / sizeof(struct eblob_disk_control), sizeof(struct eblob_disk_control),
529 			eblob_disk_control_sort_with_flags);
530 	pthread_mutex_lock(&amp;b-&gt;lock);
531 	eblob_base_wait_locked(bctl);
532 	old_fd = bctl-&gt;index_ctl.fd;
533 	if ((err = pthread_rwlock_wrlock(&amp;b-&gt;hash.root_lock)) != 0) {
534 		err = -err;
535 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: pthread_rwlock_wrlock: index: %d: FAILED",
536 				bctl-&gt;index);
537 		goto err_unlock_bctl;
538 	}
539 	err = indexsort_binlog_apply(bctl, sorted_index, index_size);
540 	if (err != 0) {
541 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_binlog_apply: index: %d: FAILED",
542 			    bctl-&gt;index);
543 		goto err_unlock_hash;
544 	}
545 	err = __eblob_write_ll(fd, sorted_index, index_size, 0);
546 	if (err) {
547 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: write after binlog apply: index: %d, size: %llu: %s",
548 			    bctl-&gt;index, (unsigned long long)index_size, file);
549 		goto err_unlock_hash;
550 	}
551 	err = fsync(fd);
552 	if (err == -1) {
553 		err = -errno;
554 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: fsync after binlog apply: index: %d, size: %llu: %s",
555 			    bctl-&gt;index, (unsigned long long)index_size, file);
556 		goto err_unlock_hash;
557 	}
558 	err = indexsort_flush_cache(b, sorted_index, index_size);
559 	if (err) {
560 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_flush_cache: index: %d: FAILED",
561 			    bctl-&gt;index);
562 <a name="2"></a>		goto err_unlock_hash;
563 	}
564 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	bctl-&gt;index_ctl.fd = fd;
565 	bctl-&gt;index_ctl.offset = 0;
566 	bctl-&gt;index_ctl.size = index_size;
567 	err = eblob_index_blocks_fill(bctl);
568 	if (err) {
569 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: eblob_index_blocks_fill: index: %d: FAILED",
570 				bctl-&gt;index);
571 		goto err_unlock_hash;
572 	}
573 	rename(file, dst_file);
574 	err = eblob_binlog_stop(&amp;bctl-&gt;binlog);
575 	if (err != 0) {
576 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: eblob_binlog_stop: index: %d: FAILED",
577 				bctl-&gt;index);
578 		goto err_unlock_hash;
579 	}</b></font>
580 	bctl-&gt;index_ctl.sorted = 1;
581 	b-&gt;defrag_generation += 1;
582 	pthread_rwlock_unlock(&amp;b-&gt;hash.root_lock);
583 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
584 	pthread_mutex_unlock(&amp;b-&gt;lock);
585 	snprintf(file, len, "%s-0.%d.index", b-&gt;cfg.file, bctl-&gt;index);
586 	unlink(file);
587 	close(old_fd);
588 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: generated sorted: index: %d, "
589 			"index-size: %llu, data-size: %" PRIu64 ", file: %s\n",
590 			bctl-&gt;index, (unsigned long long)index_size, bctl-&gt;data_ctl.offset, dst_file);
591 	free(sorted_index);
592 	free(file);
593 	free(dst_file);
594 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: success\n");
595 	return 0;
596 err_unlock_hash:
597 	pthread_rwlock_unlock(&amp;b-&gt;hash.root_lock);
598 err_unlock_bctl:
599 	bctl-&gt;index_ctl.fd = old_fd;
600 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
601 	pthread_mutex_unlock(&amp;b-&gt;lock);
602 err_out_stop_binlog:
603 	(void)eblob_binlog_stop(&amp;bctl-&gt;binlog);
604 err_out_free_index:
605 	free(sorted_index);
606 err_out_close:
607 	unlink(file);
608 	close(fd);
609 err_out_free_dst_file:
610 	free(dst_file);
611 err_out_free_file:
612 	free(file);
613 err_out_exit:
614 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "defrag: indexsort: FAILED\n");
615 	return err;
616 }
617 static char *eblob_dump_search_stat(const struct eblob_disk_search_stat *st, int err)
618 {
619 	static __thread char ss[1024];
620 	snprintf(ss, sizeof(ss), "bctls: %d, no-sorted-index: %d, search-on-disk: %d, bloom-no-key: %d, "
621 			"found-index-block: %d, no-index-block: %d, bsearch-reached: %d, bsearch-found: %d, "
622 			"additional-reads: %d, err: %d",
623 			 st-&gt;loops, st-&gt;no_sort, st-&gt;search_on_disk, st-&gt;bloom_null,
624 			 st-&gt;found_index_block, st-&gt;no_block, st-&gt;bsearch_reached, st-&gt;bsearch_found,
625 			 st-&gt;additional_reads, err);
626 	return ss;
627 }
628 int eblob_disk_index_lookup(struct eblob_backend *b, struct eblob_key *key,
629 		struct eblob_ram_control *rctl)
630 {
631 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.lookup", b-&gt;cfg.stat_id));
632 	struct eblob_base_ctl *bctl;
633 	struct eblob_disk_control dc = { .key = *key, };
634 	struct eblob_disk_search_stat st = { .bloom_null = 0, };
635 	static const int max_tries = 10;
636 	int err = -ENOENT, tries = 0;
637 	uint64_t hdr_offset = 0;
638 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: %s: index: disk.\n", eblob_dump_id(key-&gt;id));
639 again:
640 	list_for_each_entry_reverse(bctl, &amp;b-&gt;bases, base_entry) {
641 		++st.loops;
642 		eblob_bctl_hold(bctl);
643 		if (bctl-&gt;index_ctl.fd &lt; 0) {
644 			eblob_bctl_release(bctl);
645 			if (tries++ &gt; max_tries)
646 				return -EDEADLK;
647 			goto again;
648 		}
649 		if (!bctl-&gt;index_ctl.sorted) {
650 			st.no_sort++;
651 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
652 					"blob: %s: index: disk: index: %d: no sorted index\n",
653 					eblob_dump_id(key-&gt;id), bctl-&gt;index);
654 			eblob_bctl_release(bctl);
655 			continue;
656 		}
657 		err = eblob_find_on_disk(b, bctl, &amp;dc, &amp;hdr_offset, eblob_find_non_removed_callback, &amp;st);
658 		if (err) {
659 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
660 					"blob: %s: index: disk: index: %d: NO DATA\n",
661 					eblob_dump_id(key-&gt;id), bctl-&gt;index);
662 			eblob_bctl_release(bctl);
663 			continue;
664 		}
665 		eblob_convert_disk_control(&amp;dc);
666 		memset(rctl, 0, sizeof(*rctl));
667 		rctl-&gt;data_offset = dc.position;
668 		rctl-&gt;index_offset = hdr_offset;
669 		rctl-&gt;size = dc.data_size;
670 		rctl-&gt;bctl = bctl;
671 		eblob_bctl_release(bctl);
672 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE, eblob_dump_id(key-&gt;id),
673 				"blob: %s: index: %d, position: %" PRIu64
674 				", data_size: %" PRIu64 ": %s\n", eblob_dump_id(key-&gt;id),
675 				rctl-&gt;bctl-&gt;index, rctl-&gt;data_offset, rctl-&gt;size, eblob_dump_search_stat(&amp;st, 0));
676 		break;
677 	}
678 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "blob: %s: stat: %s\n", eblob_dump_id(key-&gt;id), eblob_dump_search_stat(&amp;st, err));
679 	eblob_stat_add(b-&gt;stat, EBLOB_GST_INDEX_READS, st.loops);
680 	return err;
681 }
682 uint64_t sorted_index_bsearch_raw(const struct eblob_key *key,
683                                   const struct eblob_disk_control *base, uint64_t nel) {
684 	const struct eblob_disk_control dc = { .key = *key };
685 	const struct eblob_disk_control * const found =
686 		bsearch(&amp;dc, base, nel, sizeof(dc), eblob_disk_control_sort);
687 	uint64_t index = -1;
688 	if (found != NULL)
689 		index = found - base;
690 	return index;
691 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>blob.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "features.h"
2 #include "blob.h"
3 #include "crypto/sha512.h"
4 #include "footer.h"
5 #include &lt;sys/types.h&gt;
6 #include &lt;sys/stat.h&gt;
7 #include &lt;sys/statvfs.h&gt;
8 #include &lt;sys/socket.h&gt;
9 #include &lt;sys/mman.h&gt;
10 #include &lt;sys/wait.h&gt;
11 #include &lt;sys/time.h&gt;
12 #include &lt;assert.h&gt;
13 #include &lt;errno.h&gt;
14 #include &lt;fcntl.h&gt;
15 #include &lt;inttypes.h&gt;
16 #include &lt;libgen.h&gt;
17 #include &lt;limits.h&gt;
18 #include &lt;pthread.h&gt;
19 #include &lt;stdio.h&gt;
20 #include &lt;stdlib.h&gt;
21 #include &lt;string.h&gt;
22 #include &lt;time.h&gt;
23 #include &lt;unistd.h&gt;
24 #include "measure_points.h"
25 #define DIFF(s, e) ((e).tv_sec - (s).tv_sec) * 1000000 + ((e).tv_usec - (s).tv_usec)
26 struct eblob_iterate_priv {
27 	struct eblob_iterate_control *ctl;
28 	void *thread_priv;
29 };
30 struct eblob_iterate_local {
31 	struct eblob_iterate_priv	*iter_priv;
32 	struct eblob_disk_control	*dc, *last_valid_dc;
33 	int				num, pos;
34 	long long			index_offset, last_valid_offset;
35 };
36 int eblob_mutex_init(pthread_mutex_t *mutex)
37 {
38 <a name="4"></a>	pthread_mutexattr_t attr;
39 	int err;
40 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	err = pthread_mutexattr_init(&amp;attr);
41 	if (err != 0) {
42 		err = -err;
43 		goto err_out_exit;
44 	}
45 #ifdef PTHREAD_MUTEX_ADAPTIVE_NP
46 	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ADAPTIVE_NP);
47 #else
48 	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);
49 #endif
50 	err = pthread_mutex_init(mutex, &amp;attr);
51 	if (err) {
52 		err = -err;
53 		goto err_out_destroy;
54 	}</b></font>
55 err_out_destroy:
56 	pthread_mutexattr_destroy(&amp;attr);
57 err_out_exit:
58 	return err;
59 }
60 int eblob_cond_init(pthread_cond_t *cond)
61 {
62 	int err;
63 	err = pthread_cond_init(cond, NULL);
64 	if (err != 0) {
65 		err = -err;
66 		goto err_out_exit;
67 	}
68 err_out_exit:
69 	return err;
70 }
71 int eblob_event_init(struct eblob_event *event)
72 {
73 	int err;
74 	err = eblob_mutex_init(&amp;event-&gt;lock);
75 	if (err != 0)
76 		goto err_out_exit;
77 	err = eblob_cond_init(&amp;event-&gt;cond);
78 	if (err != 0)
79 		goto err_out_exit;
80 	err = eblob_event_reset(event);
81 	if (err != 0)
82 		goto err_out_exit;
83 err_out_exit:
84 	return err;
85 }
86 int eblob_event_destroy(struct eblob_event *event)
87 <a name="3"></a>{
88 	int err;
89 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	err = pthread_cond_destroy(&amp;event-&gt;cond);
90 	if (err != 0) {
91 		err = -err;
92 		goto err_out_exit;
93 	}
94 	err = pthread_mutex_destroy(&amp;event-&gt;lock);
95 	if (err != 0) {
96 		err = -err;
97 		goto err_out_exit;
98 	}</b></font>
99 err_out_exit:
100 	return err;
101 }
102 int eblob_event_get(struct eblob_event *event)
103 {
104 	return event-&gt;data;
105 }
106 int eblob_event_set(struct eblob_event *event)
107 {
108 	int err;
109 	err = pthread_mutex_lock(&amp;event-&gt;lock);
110 	if (err != 0) {
111 		err = -err;
112 		goto err_out_exit;
113 	}
114 	event-&gt;data = 1;
115 	err = pthread_cond_broadcast(&amp;event-&gt;cond);
116 	if (err != 0) {
117 		err = -err;
118 		goto err_out_unlock;
119 	}
120 err_out_unlock:
121 	pthread_mutex_unlock(&amp;event-&gt;lock);
122 err_out_exit:
123 	return err;
124 }
125 int eblob_event_reset(struct eblob_event *event)
126 {
127 	int err;
128 	err = pthread_mutex_lock(&amp;event-&gt;lock);
129 	if (err != 0) {
130 		err = -err;
131 		goto err_out_exit;
132 	}
133 	event-&gt;data = 0;
134 	pthread_mutex_unlock(&amp;event-&gt;lock);
135 err_out_exit:
136 	return err;
137 }
138 int eblob_event_wait(struct eblob_event *event, long timeout)
139 {
140 	int err;
141 	struct timespec end_time;
142 	clock_gettime(CLOCK_REALTIME, &amp;end_time);
143 	if (end_time.tv_sec + timeout &lt; end_time.tv_sec)
144 		end_time.tv_sec = LONG_MAX;
145 	else
146 		end_time.tv_sec += timeout;
147 	err = pthread_mutex_lock(&amp;event-&gt;lock);
148 	if (err != 0) {
149 		err = -err;
150 		goto err_out_exit;
151 	}
152 	while (event-&gt;data == 0) {
153 		err = pthread_cond_timedwait(&amp;event-&gt;cond, &amp;event-&gt;lock, &amp;end_time);
154 		if (err != 0) {
155 			err = -err;
156 			goto err_out_unlock;
157 		}
158 	}
159 err_out_unlock:
160 	pthread_mutex_unlock(&amp;event-&gt;lock);
161 err_out_exit:
162 	return err;
163 }
164 void eblob_base_wait_locked(struct eblob_base_ctl *bctl)
165 {
166 	assert(bctl != NULL);
167 	pthread_mutex_lock(&amp;bctl-&gt;lock);
168 	while (bctl-&gt;critness != 0) {
169 		pthread_cond_wait(&amp;bctl-&gt;critness_wait, &amp;bctl-&gt;lock);
170 	}
171 }
172 void eblob_base_wait(struct eblob_base_ctl *bctl)
173 {
174 	eblob_base_wait_locked(bctl);
175 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
176 }
177 void eblob_bctl_hold(struct eblob_base_ctl *bctl)
178 {
179 	assert(bctl != NULL);
180 	assert(bctl-&gt;critness &gt;= 0);
181 	pthread_mutex_lock(&amp;bctl-&gt;lock);
182 	bctl-&gt;critness++;
183 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
184 }
185 void eblob_bctl_release(struct eblob_base_ctl *bctl)
186 {
187 	assert(bctl != NULL);
188 	assert(bctl-&gt;critness &gt; 0);
189 	pthread_mutex_lock(&amp;bctl-&gt;lock);
190 	bctl-&gt;critness--;
191 	if (bctl-&gt;critness == 0)
192 		pthread_cond_broadcast(&amp;bctl-&gt;critness_wait);
193 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
194 }
195 inline static uint64_t eblob_validate_ctl_flags(struct eblob_backend *b, uint64_t flags) {
196 	if (b-&gt;cfg.blob_flags &amp; EBLOB_NO_FOOTER)
197 		flags |= BLOB_DISK_CTL_NOCSUM;
198 	flags |= BLOB_DISK_CTL_CHUNKED_CSUM;
199 	return flags;
200 }
201 static int eblob_writev_raw(struct eblob_key *key, struct eblob_write_control *wc,
202 		const struct eblob_iovec *iov, uint16_t iovcnt)
203 {
204 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.raw", wc-&gt;bctl-&gt;back-&gt;cfg.stat_id));
205 	const uint64_t offset_min = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control);
206 	const uint64_t offset_max = wc-&gt;ctl_data_offset + wc-&gt;total_size;
207 	const struct eblob_iovec *tmp;
208 	int err = -EFAULT;
209 	assert(wc != NULL);
210 	assert(wc-&gt;bctl != NULL);
211 	assert(key != NULL);
212 	assert(iov != NULL);
213 	if ((wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)
214 			&amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)) {
215 		if (wc-&gt;total_data_size &lt; iov-&gt;size)
216 			return -ERANGE;
217 		wc-&gt;data_offset -= iov-&gt;size;
218 		wc-&gt;total_data_size -= iov-&gt;size;
219 	}
220 	for (tmp = iov; tmp &lt; iov + iovcnt; ++tmp) {
221 		uint64_t offset = wc-&gt;data_offset + tmp-&gt;offset;
222 		if ((tmp == iov) &amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR))
223 			offset = offset_min;
224 		EBLOB_WARNX(wc-&gt;bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: writev: fd: %d"
225 				", iov_size: %" PRIu64 ", iov_offset: %" PRIu64
226 				", offset: %" PRIu64, eblob_dump_id(key-&gt;id),
227 				wc-&gt;bctl-&gt;data_ctl.fd, tmp-&gt;size, tmp-&gt;offset, offset);
228 		if (offset + tmp-&gt;size &gt; offset_max || offset &lt; offset_min) {
229 			err = -ERANGE;
230 			goto err_exit;
231 		}
232 		err = __eblob_write_ll(wc-&gt;bctl-&gt;data_ctl.fd, tmp-&gt;base, tmp-&gt;size, offset);
233 		if (err != 0)
234 			goto err_exit;
235 	}
236 err_exit:
237 	return err;
238 }
239 char *eblob_dump_dc(const struct eblob_disk_control *dc, char *buffer, size_t size)
240 {
241 	char key_str[2 * EBLOB_ID_SIZE + 1];
242 	eblob_dump_id_len_raw(dc-&gt;key.id, EBLOB_ID_SIZE, key_str);
243 	snprintf(buffer, size, "key: %s, position: %llu, data size: %llu, disk size: %llu, flags: %s",
244 		key_str,
245 		(unsigned long long)dc-&gt;position,
246 		(unsigned long long)dc-&gt;data_size, (unsigned long long)dc-&gt;disk_size,
247 		eblob_dump_dctl_flags(dc-&gt;flags));
248 	return buffer;
249 }
250 static void eblob_dump_wc_raw(struct eblob_backend *b, int log_level, struct eblob_key *key, struct eblob_write_control *wc, const char *str, int err) {
251 	eblob_log(b-&gt;cfg.log, log_level, "blob: %s: i%d: %s: position: %" PRIu64 ", "
252 			"offset: %" PRIu64 ", size: %" PRIu64 ", flags: %s, "
253 			"total data size: %" PRIu64 ", disk-size: %" PRIu64 ", "
254 			"data_fd: %d, index_fd: %d, bctl: %p: %d\n",
255 			eblob_dump_id(key-&gt;id), wc-&gt;index, str, wc-&gt;ctl_data_offset,
256 			wc-&gt;offset, wc-&gt;size, eblob_dump_dctl_flags(wc-&gt;flags), wc-&gt;total_data_size, wc-&gt;total_size,
257 			wc-&gt;data_fd, wc-&gt;index_fd, wc-&gt;bctl, err);
258 }
259 static void eblob_dump_wc(struct eblob_backend *b, struct eblob_key *key, struct eblob_write_control *wc, const char *str, int err)
260 {
261 	int log_level = EBLOB_LOG_NOTICE;
262 	if (err &lt; 0)
263 		log_level = EBLOB_LOG_ERROR;
264 	eblob_dump_wc_raw(b, log_level, key, wc, str, err);
265 }
266 static void eblob_rctl_to_wc(const struct eblob_ram_control *rctl, struct eblob_write_control *wc)
267 {
268 	wc-&gt;data_fd = rctl-&gt;bctl-&gt;data_ctl.fd;
269 	wc-&gt;index_fd = rctl-&gt;bctl-&gt;index_ctl.fd;
270 	wc-&gt;index = rctl-&gt;bctl-&gt;index;
271 	wc-&gt;ctl_index_offset = rctl-&gt;index_offset;
272 	wc-&gt;ctl_data_offset = rctl-&gt;data_offset;
273 	wc-&gt;data_offset = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control) + wc-&gt;offset;
274 	wc-&gt;bctl = rctl-&gt;bctl;
275 }
276 static void eblob_dc_to_wc(const struct eblob_disk_control *dc, struct eblob_write_control *wc)
277 {
278 	wc-&gt;flags = dc-&gt;flags;
279 	wc-&gt;total_size = dc-&gt;disk_size;
280 	if (dc-&gt;data_size &lt; wc-&gt;offset + wc-&gt;size)
281 		wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
282 	else
283 		wc-&gt;total_data_size = dc-&gt;data_size;
284 	if (!wc-&gt;size)
285 		wc-&gt;size = dc-&gt;data_size;
286 }
287 static int eblob_index_data_mismatch(const struct eblob_base_ctl *bctl,
288 		const struct eblob_disk_control *index_dc,
289 		const struct eblob_disk_control *data_dc)
290 {
291 	if (memcmp(data_dc, index_dc, sizeof(struct eblob_disk_control))) {
292 		char data_str[512];
293 		char index_str[512];
294 		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "blob i%d: eblob_index_data_equal: index/data headers mismatch: "
295 			"data header: %s, index header: %s"
296 			" you have to remove sorted index and regenerate it from data using `eblob_to_index` tool on '%s'\n",
297 			bctl-&gt;index,
298 			eblob_dump_dc(data_dc, data_str, sizeof(data_str)),
299 			eblob_dump_dc(index_dc, index_str, sizeof(index_str)),
300 			bctl-&gt;name);
301 		return 1;
302 	}
303 	return 0;
304 }
305 int eblob_check_record(const struct eblob_base_ctl *bctl,
306 		const struct eblob_disk_control *dc)
307 {
308 	const uint64_t hdr_size = sizeof(struct eblob_disk_control);
309 	assert(dc != NULL);
310 	assert(bctl != NULL);
311 	assert(bctl-&gt;back != NULL);
312 	const uint64_t bctl_size = bctl-&gt;data_ctl.size &gt; bctl-&gt;data_ctl.offset ?
313 		bctl-&gt;data_ctl.size : bctl-&gt;data_ctl.offset;
314 	if (dc-&gt;disk_size &lt; dc-&gt;data_size + hdr_size) {
315 		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
316 				"blob i%d: %s: malformed entry: disk_size is less than data_size + hdr_size: "
317 				"pos: %" PRIu64 ", data_size: %" PRIu64 ", disk_size: %" PRIu64 "\n",
318 				bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), dc-&gt;position, dc-&gt;data_size, dc-&gt;disk_size);
319 		if (dc-&gt;disk_size == 0 &amp;&amp; dc-&gt;data_size == 0) {
320 			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
321 					"blob i%d: %s: zero-sized entry: key: %s, pos: %" PRIu64 "\n",
322 					bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), eblob_dump_id(dc-&gt;key.id), dc-&gt;position);
323 			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
324 					"blob i%d: %s: running `eblob_merge` on '%s' should help\n",
325 					bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), bctl-&gt;name);
326 		} else {
327 			return -ESPIPE;
328 		}
329 	}
330 	if (dc-&gt;position + dc-&gt;disk_size &gt; bctl_size) {
331 		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
332 				"blob i%d: %s: malformed entry: position + disk_size is outside of blob: "
333 				"pos: %" PRIu64 ", disk_size: %" PRIu64 ", bctl_size: %" PRIu64 "\n",
334 				bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), dc-&gt;position, dc-&gt;disk_size, bctl_size);
335 		return -ESPIPE;
336 	}
337 	if (!(dc-&gt;flags &amp; BLOB_DISK_CTL_NOCSUM)) {
338 		long footer_min_size = sizeof(struct eblob_disk_footer);
339 		if (dc-&gt;flags &amp; BLOB_DISK_CTL_CHUNKED_CSUM) {
340 			footer_min_size = 0;
341 			if (dc-&gt;data_size)
342 				footer_min_size = ((dc-&gt;data_size - 1) / EBLOB_CSUM_CHUNK_SIZE + 1) * sizeof(uint64_t);
343 		}
344 		if (dc-&gt;disk_size &lt; dc-&gt;data_size + footer_min_size) {
345 			char dc_str[256];
346 			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
347 				"blob i%d: malformed entry: disk_size is too small to fit data+checksum "
348 				"and there is no no-checksum bit: %s, min-footer-size: %ld\n",
349 				bctl-&gt;index, eblob_dump_dc(dc, dc_str, sizeof(dc_str)), footer_min_size);
350 			return -ESPIPE;
351 		}
352 	}
353 	return 0;
354 }
355 static int eblob_check_disk_one(struct eblob_iterate_local *loc)
356 {
357 	struct eblob_iterate_priv *iter_priv = loc-&gt;iter_priv;
358 	struct eblob_iterate_control *ctl = iter_priv-&gt;ctl;
359 	struct eblob_base_ctl *bc = ctl-&gt;base;
360 	struct eblob_disk_control *dc = &amp;loc-&gt;dc[loc-&gt;pos];
361 	struct eblob_disk_control dc_data;
362 	struct eblob_ram_control rc;
363 	int err;
364 	if (bc-&gt;data_ctl.size == 0)
365 		return -EAGAIN;
366 	memset(&amp;rc, 0, sizeof(rc));
367 	eblob_convert_disk_control(dc);
368 	err = eblob_check_record(bc, dc);
369 	if (err != 0) {
370 		eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
371 				"blob: eblob_check_record: offset: %llu\n",
372 				loc-&gt;index_offset);
373 		goto err_out_exit;
374 	}
375 	loc-&gt;last_valid_offset = loc-&gt;index_offset;
376 	loc-&gt;last_valid_dc = dc;
377 	rc.index_offset = loc-&gt;index_offset;
378 	rc.data_offset = dc-&gt;position;
379 	rc.size = dc-&gt;data_size;
380 	rc.bctl = bc;
381 	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL)
382 			&amp;&amp; !(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_READONLY)
383 			&amp;&amp; !(dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)) {
384 		err = __eblob_read_ll(bc-&gt;data_ctl.fd, &amp;dc_data, sizeof(struct eblob_disk_control), dc-&gt;position);
385 		if (err)
386 			goto err_out_exit;
387 		if (dc_data.flags &amp; BLOB_DISK_CTL_REMOVE) {
388 			eblob_log(ctl-&gt;log, EBLOB_LOG_INFO,
389 					"blob: %s: key removed(%s) in blob(%d), but not in index(%d), fixing\n",
390 					eblob_dump_id(dc-&gt;key.id), eblob_dump_dctl_flags(dc_data.flags), bc-&gt;data_ctl.fd, bc-&gt;index_ctl.fd);
391 			dc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
392 			err = __eblob_write_ll(bc-&gt;index_ctl.fd, dc,
393 					sizeof(struct eblob_disk_control), loc-&gt;index_offset);
394 			if (err)
395 				goto err_out_exit;
396 		}
397 	}
398 	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_VERIFY_CHECKSUM) &amp;&amp;
399 	    !(dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp;
400 	    !(dc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
401 		struct eblob_write_control wc;
402 		memset(&amp;wc, 0, sizeof(wc));
403 		eblob_rctl_to_wc(&amp;rc, &amp;wc);
404 		eblob_dc_to_wc(dc, &amp;wc);
405 		err = eblob_verify_checksum(bc-&gt;back, &amp;dc-&gt;key, &amp;wc);
406 		if (err) {
407 			eblob_dump_wc(bc-&gt;back, &amp;dc-&gt;key, &amp;wc, "eblob_check_disk_one: checksum verification failed", err);
408 			err = 0;
409 			goto err_out_exit;
410 		}
411 	}
412 	eblob_log(ctl-&gt;log, EBLOB_LOG_DEBUG, "blob: %s: pos: %" PRIu64 ", disk_size: %" PRIu64
413 			", data_size: %" PRIu64 ", flags: %s\n",
414 			eblob_dump_id(dc-&gt;key.id), dc-&gt;position,
415 			dc-&gt;disk_size, dc-&gt;data_size, eblob_dump_dctl_flags(dc-&gt;flags));
416 	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_INITIAL_LOAD)
417 			&amp;&amp; (dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)) {
418 		const int64_t record_size = dc-&gt;disk_size + sizeof(struct eblob_disk_control);
419 		eblob_stat_inc(bc-&gt;stat, EBLOB_LST_RECORDS_REMOVED);
420 		eblob_stat_add(bc-&gt;stat, EBLOB_LST_REMOVED_SIZE, record_size);
421 		eblob_stat_inc(ctl-&gt;b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
422 		eblob_stat_add(ctl-&gt;b-&gt;stat_summary, EBLOB_LST_REMOVED_SIZE, record_size);
423 	}
424 	if ((dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) ||
425 			(bc-&gt;index_ctl.sorted &amp;&amp; !(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL))) {
426 		err = 0;
427 		goto err_out_exit;
428 	}
429 	err = ctl-&gt;iterator_cb.iterator(dc, &amp;rc, bc-&gt;data_ctl.fd, dc-&gt;position + sizeof(struct eblob_disk_control),
430 			ctl-&gt;priv, iter_priv-&gt;thread_priv);
431 err_out_exit:
432 	return err;
433 }
434 static int eblob_check_disk(struct eblob_iterate_local *loc)
435 {
436 	int err;
437 	for (loc-&gt;pos = 0; loc-&gt;pos &lt; loc-&gt;num; ++loc-&gt;pos) {
438 		err = eblob_check_disk_one(loc);
439 		if (err &lt; 0)
440 			return err;
441 		loc-&gt;index_offset += sizeof(struct eblob_disk_control);
442 	}
443 	return 0;
444 }
445 static int eblob_fill_range_offsets(struct eblob_base_ctl *bctl, struct eblob_iterate_control *ctl)
446 {
447 	int i;
448 	struct eblob_index_block *t;
449 	struct eblob_disk_search_stat st;
450 	struct eblob_disk_control local_dc;
451 	char start_key_str[2*EBLOB_ID_SIZE+1];
452 	char end_key_str[2*EBLOB_ID_SIZE+1];
453 	if (!bctl-&gt;index_ctl.sorted)
454 		return -1;
455 	if (ctl-&gt;range_num == 0)
456 		return -1;
457 	memset(&amp;st, 0, sizeof(struct eblob_disk_search_stat));
458 	memset(&amp;local_dc, 0, sizeof(struct eblob_disk_control));
459 	for (i = 0; i &lt; ctl-&gt;range_num; ++i) {
460 		struct eblob_index_block *range = &amp;ctl-&gt;range[i];
461 		local_dc.key = range-&gt;start_key;
462 		t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, &amp;local_dc, &amp;st);
463 		if (!t) {
464 			range-&gt;start_offset = 0;
465 		} else {
466 			range-&gt;start_offset = t-&gt;start_offset;
467 		}
468 		local_dc.key = range-&gt;end_key;
469 		t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, &amp;local_dc, &amp;st);
470 		if (!t) {
471 			range-&gt;end_offset = ctl-&gt;index_size;
472 		} else {
473 			range-&gt;end_offset = t-&gt;end_offset;
474 		}
475 		eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "iterator-range: blob: index: %d, data-fd: %d, index-fd: %d, data-size: %" PRIu64
476 				", index-size: %" PRIu64 ", keys: %s..%s, index offsets: %llu..%llu\n",
477 				bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, bctl-&gt;data_ctl.size, bctl-&gt;index_ctl.size,
478 				eblob_dump_id_len_raw(range-&gt;start_key.id, EBLOB_ID_SIZE, start_key_str),
479 				eblob_dump_id_len_raw(range-&gt;end_key.id, EBLOB_ID_SIZE, end_key_str),
480 				(unsigned long long)range-&gt;start_offset,
481 				(unsigned long long)range-&gt;end_offset);
482 <a name="0"></a>	}
483 	ctl-&gt;index_offset = ctl-&gt;range[0].start_offset;
484 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return 0;
485 }
486 static int eblob_key_range_compare(const void *k, const void *r) {
487 	const struct eblob_key *key = k;
488 	const struct eblob_index_block *range = r;</b></font>
489 	if (eblob_id_cmp(key-&gt;id, range-&gt;start_key.id) &lt; 0)
490 		return -1;
491 	if (eblob_id_cmp(key-&gt;id, range-&gt;end_key.id) &gt; 0)
492 		return 1;
493 	return 0;
494 }
495 static int eblob_local_ranges_check(struct eblob_iterate_control *ctl, int current_range_index, struct eblob_iterate_local *loc)
496 {
497 	int i, out_pos = 0, err, bases_num;
498 	struct eblob_disk_control *out;
499 	struct eblob_index_block *bases;
500 	if (current_range_index &lt; 0) {
501 		current_range_index = 0;
502 	}
503 	bases_num = ctl-&gt;range_num - current_range_index;
504 	if (bases_num &lt;= 0) {
505 		err = loc-&gt;num;
506 		goto err_out_exit;
507 	}
508 	bases = &amp;ctl-&gt;range[current_range_index];
509 	out = calloc(loc-&gt;num, sizeof(struct eblob_disk_control));
510 	if (!out) {
511 		err = -ENOMEM;
512 		goto err_out_exit;
513 	}
514 	for (i = loc-&gt;pos; i &lt; loc-&gt;num; ++i) {
515 		struct eblob_disk_control *dc = &amp;loc-&gt;dc[i];
516 		if (bsearch(&amp;dc-&gt;key, bases, bases_num, sizeof(struct eblob_index_block), eblob_key_range_compare) != NULL) {
517 			out[out_pos++] = *dc;
518 		}
519 	}
520 	for (i = loc-&gt;pos; i &lt; out_pos; ++i) {
521 		loc-&gt;dc[i] = out[i];
522 	}
523 	loc-&gt;num = out_pos;
524 	free(out);
525 	err = out_pos;
526 err_out_exit:
527 	return err;
528 }
529 static int eblob_blob_iterator(struct eblob_iterate_priv *iter_priv)
530 {
531 	struct eblob_iterate_control *ctl = iter_priv-&gt;ctl;
532 	struct eblob_base_ctl *bctl = ctl-&gt;base;
533 	int batch_size = 1024;
534 	struct eblob_disk_control dc[batch_size];
535 	struct eblob_iterate_local loc;
536 	int err = 0;
537 	int current_range_index = -1;
538 	static const int hdr_size = sizeof(struct eblob_disk_control);
539 	memset(&amp;loc, 0, sizeof(loc));
540 	loc.iter_priv = iter_priv;
541 	pthread_mutex_lock(&amp;bctl-&gt;lock);
542 	current_range_index = eblob_fill_range_offsets(bctl, ctl);
543 	pthread_mutex_unlock(&amp;bctl-&gt;lock);
544 	while (ctl-&gt;index_offset &lt; ctl-&gt;index_size) {
545 		if (ctl-&gt;range_num &amp;&amp; current_range_index &gt;= 0) {
546 			struct eblob_index_block *range = &amp;ctl-&gt;range[current_range_index];
547 			if (ctl-&gt;index_offset &gt; range-&gt;end_offset) {
548 				while (1) {
549 					++current_range_index;
550 					if (current_range_index &gt;= ctl-&gt;range_num) {
551 						eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "blob: index: %d, iterator reached end of the requested range "
552 								"[%llu, %llu], index-offset: %llu: switching to the next blob\n",
553 								bctl-&gt;index, (unsigned long long)range-&gt;start_offset, (unsigned long long)range-&gt;end_offset,
554 								ctl-&gt;index_offset);
555 <a name="1"></a>						err = 0;
556 						goto err_out_check;
557 					} else {
558 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>						struct eblob_index_block *next = &amp;ctl-&gt;range[current_range_index];
559 						eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "blob: index: %d, iterator reached end of the requested ranges "
560 								"(last range: [%llu, %llu]), index-offset: %llu: switching to the next range [%llu, %llu]\n",
561 								bctl-&gt;index, (unsigned long long)range-&gt;start_offset, (unsigned long long)range-&gt;end_offset,
562 								ctl-&gt;index_offset, (unsigned long long)next-&gt;start_offset, (unsigned long long)next-&gt;end_offset);
563 						if (ctl-&gt;index_offset &gt; next-&gt;end_offset)</b></font>
564 							continue;
565 						ctl-&gt;index_offset = EBLOB_MAX(next-&gt;start_offset, ctl-&gt;index_offset);
566 						break;
567 					}
568 				}
569 			}
570 		}
571 		if (ctl-&gt;index_offset + hdr_size * batch_size &gt; ctl-&gt;index_size){
572 			batch_size = (ctl-&gt;index_size - ctl-&gt;index_offset) / hdr_size;
573 			if (batch_size == 0) {
574 				err = 0;
575 				goto err_out_check;
576 			}
577 		}
578 		pthread_mutex_lock(&amp;bctl-&gt;lock);
579 		err = __eblob_read_ll(bctl-&gt;index_ctl.fd, dc, batch_size * hdr_size, ctl-&gt;index_offset);
580 		if (err) {
581 			pthread_mutex_unlock(&amp;bctl-&gt;lock);
582 			goto err_out_check;
583 		}
584 		pthread_mutex_unlock(&amp;bctl-&gt;lock);
585 		if (ctl-&gt;index_offset + batch_size * hdr_size &gt; ctl-&gt;index_size) {
586 			eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: index grew under us, iteration stops: "
587 					"index_offset: %llu, index_size: %llu, eblob_data_size: %llu, batch_size: %d, "
588 					"index_offset+batch_size: %llu, but wanted less than index_size.\n",
589 					ctl-&gt;index_offset, ctl-&gt;index_size, ctl-&gt;data_size, batch_size,
590 					ctl-&gt;index_offset + batch_size * hdr_size);
591 			err = 0;
592 			goto err_out_check;
593 		}
594 		loc.index_offset = ctl-&gt;index_offset;
595 		loc.dc = dc;
596 		loc.pos = 0;
597 		loc.num = batch_size;
598 		ctl-&gt;index_offset += hdr_size * batch_size;
599 		err = eblob_local_ranges_check(ctl, current_range_index, &amp;loc);
600 		if (err &lt; 0)
601 			continue;
602 		if (err == 0)
603 			continue;
604 		eblob_bctl_hold(bctl);
605 		err = eblob_check_disk(&amp;loc);
606 		eblob_bctl_release(bctl);
607 		if (err)
608 			goto err_out_check;
609 	}
610 err_out_check:
611 	eblob_log(ctl-&gt;log, err &lt; 0 ? EBLOB_LOG_ERROR : EBLOB_LOG_INFO, "blob-0.%d: iterated: data_fd: %d, index_fd: %d, "
612 			"data_size: %llu, index_offset: %llu, err: %d\n",
613 			bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, ctl-&gt;data_size, ctl-&gt;index_offset, err);
614 	if (!(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL)) {
615 		pthread_mutex_lock(&amp;bctl-&gt;lock);
616 		bctl-&gt;data_ctl.offset = bctl-&gt;data_ctl.size;
617 		bctl-&gt;index_ctl.size = ctl-&gt;index_offset;
618 		if (err &amp;&amp; !ctl-&gt;err) {
619 			if (loc.last_valid_dc != NULL) {
620 				struct eblob_disk_control data_dc;
621 				struct eblob_disk_control idc;
622 				idc = *loc.last_valid_dc;
623 				bctl-&gt;index_ctl.size = ctl-&gt;index_offset = loc.last_valid_offset;
624 				eblob_convert_disk_control(&amp;idc);
625 				err = __eblob_read_ll(bctl-&gt;data_ctl.fd, &amp;data_dc, hdr_size, idc.position);
626 				if (err) {
627 					memset(&amp;data_dc, 0, hdr_size);
628 					eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
629 							"blob: read failed: fd: %d, err: %d\n", bctl-&gt;data_ctl.fd, -err);
630 					ctl-&gt;err = err;
631 				}
632 				eblob_convert_disk_control(&amp;data_dc);
633 				bctl-&gt;data_ctl.offset = idc.position + data_dc.disk_size;
634 				eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: i%d: truncating eblob to: data_fd: %d, index_fd: %d, "
635 						"data_size(was): %llu, data_offset: %" PRIu64 ", "
636 						"data_position: %" PRIu64 ", disk_size: %" PRIu64 ", index_offset: %llu\n",
637 						bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, ctl-&gt;data_size,
638 						bctl-&gt;data_ctl.offset, idc.position, idc.disk_size,
639 						ctl-&gt;index_offset);
640 				err = ftruncate(bctl-&gt;index_ctl.fd, ctl-&gt;index_offset);
641 				if (err == -1) {
642 					eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
643 							"blob: truncation failed: fd: %d, err: %d\n", bctl-&gt;index_ctl.fd, -errno);
644 					ctl-&gt;err = -errno;
645 				}
646 			}
647 		}
648 		pthread_mutex_unlock(&amp;bctl-&gt;lock);
649 	}
650 	if (ctl-&gt;err == 0 &amp;&amp; err != 0)
651 		ctl-&gt;err = err;
652 	return err;
653 }
654 int eblob_blob_iterate(struct eblob_iterate_control *ctl)
655 {
656 	int err;
657 	struct eblob_iterate_priv iter_priv;
658 	if (ctl-&gt;range_num) {
659 		qsort(ctl-&gt;range, ctl-&gt;range_num, sizeof(struct eblob_index_block), eblob_index_block_cmp);
660 	}
661 	eblob_base_wait_locked(ctl-&gt;base);
662 	err = eblob_base_setup_data(ctl-&gt;base, 0);
663 	if (err) {
664 		pthread_mutex_unlock(&amp;ctl-&gt;base-&gt;lock);
665 		ctl-&gt;err = err;
666 		goto err_out_exit;
667 	}
668 	ctl-&gt;index_offset = 0;
669 	ctl-&gt;data_size = ctl-&gt;base-&gt;data_ctl.size;
670 	ctl-&gt;index_size = ctl-&gt;base-&gt;index_ctl.size;
671 	pthread_mutex_unlock(&amp;ctl-&gt;base-&gt;lock);
672 	iter_priv.ctl = ctl;
673 	iter_priv.thread_priv = NULL;
674 	if (ctl-&gt;iterator_cb.iterator_init) {
675 		err = ctl-&gt;iterator_cb.iterator_init(ctl, &amp;iter_priv.thread_priv);
676 		if (err) {
677 			ctl-&gt;err = err;
678 			eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: failed to init iterator: %d.\n", err);
679 			goto err_out_exit;
680 		}
681 	}
682 	err = eblob_blob_iterator(&amp;iter_priv);
683 	if (err) {
684 		ctl-&gt;err = err;
685 		eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: iterator failed: %d.\n", err);
686 		goto err_out_exit;
687 	}
688 	if (ctl-&gt;iterator_cb.iterator_free)
689 		ctl-&gt;iterator_cb.iterator_free(ctl, &amp;iter_priv.thread_priv);
690 	if ((ctl-&gt;err == -ENOENT) &amp;&amp; eblob_total_elements(ctl-&gt;b))
691 		ctl-&gt;err = 0;
692 err_out_exit:
693 	return ctl-&gt;err;
694 }
695 int eblob_mark_index_removed(int fd, uint64_t offset)
696 {
697 	uint64_t flags = eblob_bswap64(BLOB_DISK_CTL_REMOVE);
698 	return __eblob_write_ll(fd, &amp;flags, sizeof(flags), offset + offsetof(struct eblob_disk_control, flags));
699 }
700 static int eblob_mark_entry_removed(struct eblob_backend *b,
701 		struct eblob_key *key, struct eblob_ram_control *old)
702 {
703 	int err;
704 	struct eblob_disk_control old_dc;
705 	int64_t record_size = 0;
706 	if (eblob_binlog_enabled(&amp;old-&gt;bctl-&gt;binlog)) {
707 		struct eblob_binlog_entry *entry;
708 		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: appending key to binlog",
709 				eblob_dump_id(key-&gt;id));
710 		entry = eblob_binlog_entry_new(key);
711 		if (entry == NULL) {
712 			err = -ENOMEM;
713 			goto err;
714 		}
715 		err = eblob_binlog_append(&amp;old-&gt;bctl-&gt;binlog, entry);
716 		if (err != 0) {
717 			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
718 					"%s: eblob_binlog_append: FAILED",
719 					eblob_dump_id(key-&gt;id));
720 			goto err;
721 		}
722 	}
723 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: index position: %" PRIu64 ", index_fd: %d, "
724 			"data position: %" PRIu64 ", data_fd: %d",
725 			eblob_dump_id(key-&gt;id), old-&gt;index_offset, old-&gt;bctl-&gt;index_ctl.fd,
726 			old-&gt;data_offset, old-&gt;bctl-&gt;data_ctl.fd);
727 	err = __eblob_read_ll(old-&gt;bctl-&gt;index_ctl.fd, &amp;old_dc, sizeof(old_dc), old-&gt;index_offset);
728 	if (err) {
729 		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: __eblob_read_ll: FAILED: index, fd: %d, err: %d",
730 				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;index_ctl.fd, err);
731 		goto err;
732 	}
733 	if (memcmp(&amp;old_dc.key, key, sizeof(key)) != 0) {
734 		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR, "keys mismatch: in-memory: %s, on-disk: %s",
735 				eblob_dump_id_len(key-&gt;id, EBLOB_ID_SIZE),
736 				eblob_dump_id_len(old_dc.key.id, EBLOB_ID_SIZE));
737 		err = -EINVAL;
738 		goto err;
739 	}
740 	eblob_convert_disk_control(&amp;old_dc);
741 	record_size = old_dc.disk_size + sizeof(struct eblob_disk_control);
742 	err = eblob_mark_index_removed(old-&gt;bctl-&gt;index_ctl.fd, old-&gt;index_offset);
743 	if (err != 0) {
744 		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
745 				"%s: eblob_mark_index_removed: FAILED: index, fd: %d, err: %d",
746 				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;index_ctl.fd, err);
747 		goto err;
748 	}
749 	err = eblob_mark_index_removed(old-&gt;bctl-&gt;data_ctl.fd, old-&gt;data_offset);
750 	if (err != 0) {
751 		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
752 				"%s: eblob_mark_index_removed: FAILED: data, fd: %d, err: %d",
753 				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;data_ctl.fd, err);
754 		goto err;
755 	}
756 	eblob_stat_inc(old-&gt;bctl-&gt;stat, EBLOB_LST_RECORDS_REMOVED);
757 	eblob_stat_add(old-&gt;bctl-&gt;stat, EBLOB_LST_REMOVED_SIZE, record_size);
758 	eblob_stat_inc(b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
759 	eblob_stat_add(b-&gt;stat_summary, EBLOB_LST_REMOVED_SIZE, record_size);
760 	if (!b-&gt;cfg.sync) {
761 		eblob_fdatasync(old-&gt;bctl-&gt;data_ctl.fd);
762 		eblob_fdatasync(old-&gt;bctl-&gt;index_ctl.fd);
763 	}
764 err:
765 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: finished: %d",
766 			eblob_dump_id(key-&gt;id), err);
767 	return err;
768 }
769 static int eblob_mark_entry_removed_purge(struct eblob_backend *b,
770 		struct eblob_key *key, struct eblob_ram_control *old)
771 {
772 	int err;
773 	assert(b != NULL);
774 	assert(key != NULL);
775 	assert(old != NULL);
776 	assert(old-&gt;bctl != NULL);
777 	pthread_mutex_lock(&amp;old-&gt;bctl-&gt;lock);
778 	err = eblob_mark_entry_removed(b, key, old);
779 	if (err)
780 		goto err;
781 	err = eblob_cache_remove(b, key);
782 	if (err != 0 &amp;&amp; err != -ENOENT) {
783 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_NOTICE, -err,
784 				"%s: eblob_cache_remove: FAILED: %d",
785 				eblob_dump_id(key-&gt;id), err);
786 		goto err;
787 	} else {
788 		err = 0;
789 	}
790 err:
791 	pthread_mutex_unlock(&amp;old-&gt;bctl-&gt;lock);
792 	return err;
793 }
794 static void eblob_wc_to_dc(const struct eblob_key *key, const struct eblob_write_control *wc,
795 		struct eblob_disk_control *dc)
796 {
797 	assert(key != NULL);
798 	assert(wc != NULL);
799 	assert(dc != NULL);
800 	memcpy(&amp;dc-&gt;key, key, sizeof(struct eblob_key));
801 	dc-&gt;flags = wc-&gt;flags;
802 	dc-&gt;data_size = wc-&gt;total_data_size;
803 	dc-&gt;disk_size = wc-&gt;total_size;
804 	dc-&gt;position = wc-&gt;ctl_data_offset;
805 	eblob_convert_disk_control(dc);
806 }
807 static int eblob_commit_disk(struct eblob_backend *b, struct eblob_key *key,
808 		struct eblob_write_control *wc, int remove)
809 {
810 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.commit.ll", b-&gt;cfg.stat_id));
811 	struct eblob_disk_control dc;
812 	int err;
813 	if (remove)
814 		wc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
815 	else
816 		wc-&gt;flags &amp;= ~BLOB_DISK_CTL_REMOVE;
817 	eblob_wc_to_dc(key, wc, &amp;dc);
818 	err = __eblob_write_ll(wc-&gt;index_fd, &amp;dc, sizeof(dc), wc-&gt;ctl_index_offset);
819 	if (err) {
820 		eblob_dump_wc(b, key, wc, "eblob_commit_disk: ERROR-write-index", err);
821 		goto err_out_exit;
822 	}
823 	err = __eblob_write_ll(wc-&gt;data_fd, &amp;dc, sizeof(dc), wc-&gt;ctl_data_offset);
824 	if (err) {
825 		eblob_dump_wc(b, key, wc, "eblob_commit_disk: ERROR-write-data", err);
826 		goto err_out_exit;
827 	}
828 	if (!b-&gt;cfg.sync)
829 		fsync(wc-&gt;index_fd);
830 	eblob_dump_wc(b, key, wc, "eblob_commit_disk", err);
831 err_out_exit:
832 	return err;
833 }
834 int __eblob_write_ll(int fd, const void *data, size_t size, off_t offset)
835 {
836 	int err = 0;
837 	ssize_t bytes;
838 	while (size) {
839 again:
840 		bytes = pwrite(fd, data, size, offset);
841 		if (bytes == -1) {
842 			if (errno == -EINTR)
843 				goto again;
844 			err = -errno;
845 			goto err_out_exit;
846 		}
847 		data += bytes;
848 		size -= bytes;
849 		offset += bytes;
850 	}
851 err_out_exit:
852 	return err;
853 }
854 int __eblob_read_ll(int fd, void *data, size_t size, off_t offset)
855 {
856 	ssize_t bytes;
857 	while (size) {
858 again:
859 		bytes = pread(fd, data, size, offset);
860 		if (bytes == -1) {
861 			if (errno == -EINTR)
862 				goto again;
863 			return -errno;
864 		} else if (bytes == 0)
865 			return -ESPIPE;
866 		data += bytes;
867 		size -= bytes;
868 		offset += bytes;
869 	}
870 	return 0;
871 }
872 static inline uint64_t eblob_calculate_size(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, uint64_t size)
873 {
874 	static const size_t hdr_size = sizeof(struct eblob_disk_control);
875 	const uint64_t data_size = size + offset;
876 	const uint64_t footer_size = eblob_calculate_footer_size(b, data_size);
877 	const uint64_t total_size = hdr_size + data_size + footer_size;
878 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: %s: %s: offset: %" PRIu64 ", size: %" PRIu64 ", "
879 	          "hdr_size: %zd, data_size: %" PRIu64 ", footer_size: %" PRIu64 ", total_size: %" PRIu64 "\n",
880 	          eblob_dump_id(key-&gt;id), __func__, offset, size, hdr_size, data_size, footer_size, total_size);
881 	return total_size;
882 }
883 static void eblob_wc_to_rctl(const struct eblob_write_control *wc,
884 		struct eblob_ram_control *rctl)
885 {
886 	assert(wc != NULL);
887 	assert(wc-&gt;bctl != NULL);
888 	assert(rctl != NULL);
889 	rctl-&gt;size = wc-&gt;total_data_size;
890 	rctl-&gt;data_offset = wc-&gt;ctl_data_offset;
891 	rctl-&gt;index_offset = wc-&gt;ctl_index_offset;
892 	rctl-&gt;bctl = wc-&gt;bctl;
893 }
894 static int eblob_commit_ram(struct eblob_backend *b, struct eblob_key *key, struct eblob_write_control *wc)
895 {
896 	struct eblob_ram_control ctl;
897 	int err;
898 	if (wc-&gt;on_disk)
899 		return 0;
900 	eblob_wc_to_rctl(wc, &amp;ctl);
901 	err = eblob_cache_insert(b, key, &amp;ctl);
902 	if (err) {
903 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
904 				"blob: %s: %s: eblob_cache_insert: fd: %d: FAILED: %d.\n",
905 				eblob_dump_id(key-&gt;id), __func__, ctl.bctl-&gt;index_ctl.fd, err);
906 		goto err_out_exit;
907 	}
908 err_out_exit:
909 	eblob_dump_wc(b, key, wc, "eblob_commit_ram: finished", err);
910 	return err;
911 }
912 int eblob_copy_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
913 {
914 	void *buf;
915 	ssize_t err;
916 	ssize_t alloc_size = len;
917 	ssize_t max_size = 10 * EBLOB_1_M;
918 	if (len &lt;= 0)
919 		return -EINVAL;
920 	if (alloc_size &gt; max_size)
921 		alloc_size = max_size;
922 	buf = malloc(alloc_size);
923 	if (!buf) {
924 		err = -ENOMEM;
925 		goto err_out_exit;
926 	}
927 	while (len &gt; 0) {
928 		ssize_t read_size = alloc_size;
929 		if (read_size &gt; len)
930 			read_size = len;
931 		err = pread(fd_in, buf, read_size, off_in);
932 		if (err == 0) {
933 			err = -ESPIPE;
934 			goto err_out_free;
935 		}
936 		if (err &lt; 0) {
937 			err = -errno;
938 			goto err_out_free;
939 		}
940 		read_size = err;
941 		err = pwrite(fd_out, buf, read_size, off_out);
942 		if (err == 0) {
943 			err = -EPIPE;
944 			goto err_out_free;
945 		}
946 		if (err &lt; 0) {
947 			err = -errno;
948 			goto err_out_free;
949 		}
950 		read_size = err;
951 		off_out += read_size;
952 		off_in += read_size;
953 		len -= read_size;
954 		err = 0;
955 	}
956 err_out_free:
957 	free(buf);
958 err_out_exit:
959 	return err;
960 }
961 #ifdef __linux__
962 static int eblob_splice_data_one(int *fds, int fd_in, uint64_t *off_in,
963 		int fd_out, uint64_t *off_out, ssize_t len)
964 {
965 	int err;
966 	size_t to_write = len;
967 	while (to_write &gt; 0) {
968 		err = splice(fd_in, (loff_t *)off_in, fds[1], NULL, to_write, 0);
969 		if (err == 0) {
970 			err = -ENOSPC;
971 			goto err_out_exit;
972 		}
973 		if (err &lt; 0) {
974 			err = -errno;
975 			perror("splice1");
976 			goto err_out_exit;
977 		}
978 		to_write -= err;
979 	}
980 	to_write = len;
981 	while (to_write &gt; 0) {
982 		err = splice(fds[0], NULL, fd_out, (loff_t *)off_out, to_write, 0);
983 		if (err == 0) {
984 			err = -ENOSPC;
985 			goto err_out_exit;
986 		}
987 		if (err &lt; 0) {
988 			err = -errno;
989 			perror("splice2");
990 			goto err_out_exit;
991 		}
992 		to_write -= err;
993 	}
994 	err = 0;
995 err_out_exit:
996 	return err;
997 }
998 int eblob_splice_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
999 {
1000 	int fds[2];
1001 	int err;
1002 	err = pipe(fds);
1003 	if (err &lt; 0) {
1004 		err = -errno;
1005 		goto err_out_exit;
1006 	}
1007 	while (len &gt; 0) {
1008 		ssize_t chunk_size = 4096;
1009 		if (chunk_size &gt; len)
1010 			chunk_size = len;
1011 		err = eblob_splice_data_one(fds, fd_in, &amp;off_in, fd_out, &amp;off_out, chunk_size);
1012 		if (err &lt; 0)
1013 			goto err_out_close;
1014 		len -= chunk_size;
1015 	}
1016 	err = 0;
1017 err_out_close:
1018 	close(fds[0]);
1019 	close(fds[1]);
1020 err_out_exit:
1021 	return err;
1022 }
1023 #else
1024 int eblob_splice_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
1025 {
1026 	return eblob_copy_data(fd_in, off_in, fd_out, off_out, len);
1027 }
1028 #endif
1029 static void eblob_write_control_cleanup(struct eblob_write_control *wc) {
1030 	assert(wc != NULL);
1031 	if (wc-&gt;bctl != NULL) {
1032 		eblob_bctl_release(wc-&gt;bctl);
1033 		wc-&gt;bctl = NULL;
1034 	}
1035 }
1036 static int eblob_fill_write_control_from_ram(struct eblob_backend *b, struct eblob_key *key,
1037 		struct eblob_write_control *wc, int for_write, struct eblob_ram_control *old)
1038 {
1039 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.lookup", b-&gt;cfg.stat_id));
1040 	struct eblob_ram_control ctl;
1041 	struct eblob_disk_control dc, data_dc;
1042 	uint64_t orig_offset = wc-&gt;offset;
1043 	uint64_t calculated_size;
1044 	int err;
1045 	err = eblob_cache_lookup(b, key, &amp;ctl, &amp;wc-&gt;on_disk);
1046 	if (err) {
1047 		int level = EBLOB_LOG_DEBUG;
1048 		if (err != -ENOENT)
1049 			level = EBLOB_LOG_ERROR;
1050 		eblob_log(b-&gt;cfg.log, level, "blob: %s: %s: eblob_cache_lookup: %d, on_disk: %d\n",
1051 				eblob_dump_id(key-&gt;id), __func__, err, wc-&gt;on_disk);
1052 		goto err_out_exit;
1053 	} else if(old) {
1054 		memcpy(old, &amp;ctl, sizeof(struct eblob_ram_control));
1055 	}
1056 	if (for_write &amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)) {
1057 		wc-&gt;offset = orig_offset + ctl.size;
1058 	}
1059 	eblob_rctl_to_wc(&amp;ctl, wc);
1060 	eblob_bctl_hold(wc-&gt;bctl);
1061 	err = __eblob_read_ll(wc-&gt;index_fd, &amp;dc, sizeof(dc), ctl.index_offset);
1062 	if (err) {
1063 		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: ERROR-pread-index", err);
1064 		goto err_out_cleanup_wc;
1065 	}
1066 	err = __eblob_read_ll(wc-&gt;data_fd, &amp;data_dc, sizeof(data_dc), ctl.data_offset);
1067 	if (err) {
1068 		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: ERROR-pread-data", err);
1069 		goto err_out_cleanup_wc;
1070 	}
1071 	eblob_convert_disk_control(&amp;dc);
1072 	eblob_convert_disk_control(&amp;data_dc);
1073 	eblob_dc_to_wc(&amp;dc, wc);
1074 	if (eblob_index_data_mismatch(wc-&gt;bctl, &amp;dc, &amp;data_dc)) {
1075 		err = -EINVAL;
1076 		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: index and data headers mismatch", err);
1077 		goto err_out_cleanup_wc;
1078 	}
1079 	calculated_size = eblob_calculate_size(b, key, wc-&gt;offset, wc-&gt;size);
1080 	if (for_write &amp;&amp; (dc.disk_size &lt; calculated_size)) {
1081 		err = -E2BIG;
1082 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
1083 		          "blob i%d: %s: %s: size check failed: disk-size: %" PRIu64 ", calculated: %" PRIu64 "\n",
1084 		          wc-&gt;index, eblob_dump_id(key-&gt;id), __func__, dc.disk_size, calculated_size);
1085 		eblob_dump_wc_raw(b, EBLOB_LOG_NOTICE, key, wc, "eblob_fill_write_control_from_ram: ERROR-size-check", err);
1086 		goto err_out_cleanup_wc;
1087 	}
1088 	eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram", err);
1089 	return err;
1090 err_out_cleanup_wc:
1091 	eblob_write_control_cleanup(wc);
1092 err_out_exit:
1093 	return err;
1094 }
1095 static int eblob_check_free_space(struct eblob_backend *b, uint64_t size)
1096 {
1097 	unsigned long long total, avail;
1098 	static int print_once;
1099 	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_NO_FREE_SPACE_CHECK)) {
1100 		avail = b-&gt;vfs_stat.f_bsize * b-&gt;vfs_stat.f_bavail;
1101 		total = b-&gt;vfs_stat.f_frsize * b-&gt;vfs_stat.f_blocks;
1102 		if (avail &lt; size)
1103 			return -ENOSPC;
1104 		if (b-&gt;cfg.blob_size_limit) {
1105 			if (eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE) + size &gt; b-&gt;cfg.blob_size_limit) {
1106 				if (!print_once) {
1107 					print_once = 1;
1108 					eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "OUT OF FREE SPACE: available: %llu Mb, "
1109 							"total: %llu Mb, current size: %" PRIu64 " Mb, limit: %" PRIu64 "Mb\n",
1110 							avail / EBLOB_1_M, total / EBLOB_1_M,
1111 							(eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE) + size) / EBLOB_1_M,
1112 							b-&gt;cfg.blob_size_limit / EBLOB_1_M);
1113 				}
1114 				return -ENOSPC;
1115 			}
1116 		} else if (((b-&gt;cfg.blob_flags &amp; EBLOB_RESERVE_10_PERCENTS) &amp;&amp; (avail &lt; total * 0.1)) ||
1117 				(!(b-&gt;cfg.blob_flags &amp; EBLOB_RESERVE_10_PERCENTS) &amp;&amp; (avail &lt; 2 * b-&gt;cfg.blob_size))) {
1118 			if (!print_once) {
1119 				print_once = 1;
1120 				eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "OUT OF FREE SPACE: available: %llu Mb, "
1121 						"total: %llu Mb, blob size: %" PRIu64 " Mb\n",
1122 						avail / EBLOB_1_M, total / EBLOB_1_M, b-&gt;cfg.blob_size / EBLOB_1_M);
1123 			}
1124 			return -ENOSPC;
1125 		}
1126 	}
1127 	return 0;
1128 }
1129 static int eblob_write_prepare_disk_ll(struct eblob_backend *b, struct eblob_key *key,
1130 		struct eblob_write_control *wc, uint64_t prepare_disk_size,
1131 		enum eblob_copy_flavour copy, uint64_t copy_offset,
1132 		struct eblob_ram_control *old)
1133 {
1134 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare.disk.ll", b-&gt;cfg.stat_id));
1135 	struct eblob_base_ctl *ctl = NULL;
1136 	ssize_t err = 0;
1137 	if (list_empty(&amp;b-&gt;bases)) {
1138 		err = eblob_add_new_base(b);
1139 		if (err)
1140 			goto err_out_exit;
1141 	}
1142 	ctl = list_last_entry(&amp;b-&gt;bases, struct eblob_base_ctl, base_entry);
1143 	if ((ctl-&gt;data_ctl.offset &gt;= b-&gt;cfg.blob_size) || ctl-&gt;index_ctl.sorted ||
1144 			(ctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control) &gt;= b-&gt;cfg.records_in_blob)) {
1145 		err = eblob_add_new_base(b);
1146 		if (err)
1147 			goto err_out_exit;
1148 		if (!ctl-&gt;index_ctl.sorted)
1149 			datasort_force_sort(b);
1150 		ctl = list_last_entry(&amp;b-&gt;bases, struct eblob_base_ctl, base_entry);
1151 	}
1152 	if (old != NULL) {
1153 		if (old-&gt;bctl-&gt;index_ctl.fd == -1) {
1154 			err = -EAGAIN;
1155 			goto err_out_exit;
1156 		}
1157 		if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)
1158 			wc-&gt;offset += old-&gt;size;
1159 	} else {
1160 		if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND) {
1161 			wc-&gt;flags &amp;= ~BLOB_DISK_CTL_APPEND;
1162 			prepare_disk_size += wc-&gt;size * 4;
1163 		}
1164 	}
1165 	assert(datasort_base_is_sorted(ctl) != 1);
1166 	wc-&gt;data_fd = ctl-&gt;data_ctl.fd;
1167 	wc-&gt;index_fd = ctl-&gt;index_ctl.fd;
1168 	wc-&gt;index = ctl-&gt;index;
1169 	wc-&gt;on_disk = 0;
1170 	wc-&gt;ctl_index_offset = ctl-&gt;index_ctl.size;
1171 	wc-&gt;ctl_data_offset = ctl-&gt;data_ctl.offset;
1172 	wc-&gt;data_offset = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control) + wc-&gt;offset;
1173 	wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
1174 	if (wc-&gt;bctl)
1175 		eblob_bctl_release(wc-&gt;bctl);
1176 	eblob_bctl_hold(ctl);
1177 	wc-&gt;bctl = ctl;
1178 	if (wc-&gt;total_data_size &lt; prepare_disk_size)
1179 		wc-&gt;total_size = eblob_calculate_size(b, key, 0, prepare_disk_size);
1180 	else
1181 		wc-&gt;total_size = eblob_calculate_size(b, key, 0, wc-&gt;total_data_size);
1182 	if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)
1183 		wc-&gt;total_size *= 2;
1184 	ctl-&gt;data_ctl.offset += wc-&gt;total_size;
1185 	ctl-&gt;index_ctl.size += sizeof(struct eblob_disk_control);
1186 	err = eblob_commit_disk(b, key, wc, 0);
1187 	if (err)
1188 		goto err_out_rollback;
1189 	if (prepare_disk_size ||
1190 	    copy == EBLOB_COPY_RECORD) {
1191 		err = eblob_preallocate(wc-&gt;data_fd, wc-&gt;ctl_data_offset, wc-&gt;total_size);
1192 		eblob_log(b-&gt;cfg.log, err == 0 ? EBLOB_LOG_DEBUG : EBLOB_LOG_ERROR,
1193 		          "blob i%d: %s: eblob_preallocate: fd: %d, size: %" PRIu64 ", err: %zu\n",
1194 		          wc-&gt;index, eblob_dump_id(key-&gt;id), wc-&gt;data_fd, wc-&gt;ctl_data_offset + wc-&gt;total_size, err);
1195 		if (err != 0)
1196 			goto err_out_rollback;
1197 	}
1198 	if (old != NULL &amp;&amp; copy == EBLOB_COPY_RECORD) {
1199 		struct eblob_disk_control old_dc;
1200 		uint64_t off_in = old-&gt;data_offset + sizeof(struct eblob_disk_control);
1201 		uint64_t off_out = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control);
1202 		uint64_t size;
1203 		if (copy_offset != 0) {
1204 			off_out += copy_offset;
1205 			if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND) {
1206 				wc-&gt;data_offset += copy_offset;
1207 				wc-&gt;total_data_size += copy_offset;
1208 			}
1209 		}
1210 		err = __eblob_read_ll(old-&gt;bctl-&gt;data_ctl.fd, &amp;old_dc,
1211 				sizeof(struct eblob_disk_control), old-&gt;data_offset);
1212 		if (err) {
1213 			eblob_dump_wc(b, key, wc, "copy: ERROR-pread-data", err);
1214 			goto err_out_rollback;
1215 		}
1216 		if (memcmp(&amp;old_dc.key, key, sizeof(struct eblob_key)) != 0) {
1217 			EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1218 					"keys mismatch: in-memory: %s, on-disk: %s",
1219 					eblob_dump_id_len(key-&gt;id, EBLOB_ID_SIZE),
1220 					eblob_dump_id_len(old_dc.key.id, EBLOB_ID_SIZE));
1221 			goto err_out_rollback;
1222 		}
1223 		eblob_convert_disk_control(&amp;old_dc);
1224 		size = old_dc.disk_size - sizeof(struct eblob_disk_control);
1225 		if (wc-&gt;data_fd != old-&gt;bctl-&gt;data_ctl.fd)
1226 			err = eblob_splice_data(old-&gt;bctl-&gt;data_ctl.fd, off_in, wc-&gt;data_fd, off_out, size);
1227 		else
1228 			err = eblob_copy_data(old-&gt;bctl-&gt;data_ctl.fd, off_in, wc-&gt;data_fd, off_out, size);
1229 		FORMATTED(HANDY_GAUGE_SET, ("eblob.%u.disk.write.move.size", b-&gt;cfg.stat_id), size);
1230 		if (err == 0)
1231 			eblob_stat_inc(b-&gt;stat, EBLOB_GST_READ_COPY_UPDATE);
1232 		EBLOB_WARNX(b-&gt;cfg.log, err &lt; 0 ? EBLOB_LOG_ERROR : EBLOB_LOG_NOTICE,
1233 				"copy: %s: src offset: %" PRIu64 ", dst offset: %" PRIu64
1234 				", size: %" PRIu64 ", src fd: %d: dst fd: %d: %zd",
1235 				eblob_dump_id(key-&gt;id), off_in, off_out,
1236 				size, old-&gt;bctl-&gt;data_ctl.fd, wc-&gt;data_fd, err);
1237 		if (err &lt; 0)
1238 			goto err_out_rollback;
1239 	}
1240 	if (old != NULL) {
1241 		err = eblob_mark_entry_removed_purge(b, key, old);
1242 		if (err != 0) {
1243 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1244 					"%s: %s: eblob_mark_entry_removed_purge: %zd\n",
1245 					__func__, eblob_dump_id(key-&gt;id), -err);
1246 			goto err_out_exit;
1247 		}
1248 	}
1249 	eblob_stat_inc(ctl-&gt;stat, EBLOB_LST_RECORDS_TOTAL);
1250 	eblob_stat_add(ctl-&gt;stat, EBLOB_LST_BASE_SIZE,
1251 			wc-&gt;total_size + sizeof(struct eblob_disk_control));
1252 	eblob_stat_add(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE,
1253 	               wc-&gt;total_size + sizeof(struct eblob_disk_control));
1254 	eblob_stat_inc(b-&gt;stat_summary, EBLOB_LST_RECORDS_TOTAL);
1255 	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk_ll: complete", 0);
1256 	return 0;
1257 err_out_rollback:
1258 	ctl-&gt;data_ctl.offset -= wc-&gt;total_size;
1259 	ctl-&gt;index_ctl.size -= sizeof(struct eblob_disk_control);
1260 err_out_exit:
1261 	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk_ll: error", err);
1262 	return err;
1263 }
1264 static int eblob_write_prepare_disk(struct eblob_backend *b, struct eblob_key *key,
1265 		struct eblob_write_control *wc, uint64_t prepare_disk_size,
1266 		enum eblob_copy_flavour copy, uint64_t copy_offset, struct eblob_ram_control *old,
1267 		size_t defrag_generation)
1268 {
1269 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare.disk", b-&gt;cfg.stat_id));
1270 	ssize_t err = 0;
1271 	uint64_t size;
1272 	struct eblob_ram_control upd_old;
1273 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
1274 			"blob: %s: eblob_write_prepare_disk: start: "
1275 			"size: %" PRIu64 ", offset: %" PRIu64 ", prepare: %" PRIu64 "\n",
1276 			eblob_dump_id(key-&gt;id), wc-&gt;size, wc-&gt;offset, prepare_disk_size);
1277 	pthread_mutex_lock(&amp;b-&gt;lock);
1278 	if (defrag_generation != b-&gt;defrag_generation) {
1279 		int disk;
1280 		err = eblob_cache_lookup(b, key, &amp;upd_old, &amp;disk);
1281 		switch (err) {
1282 		case -ENOENT:
1283 			old = NULL;
1284 			break;
1285 		case 0:
1286 			old = &amp;upd_old;
1287 			break;
1288 		default:
1289 			goto err_out_exit;
1290 		}
1291 	}
1292 	size = prepare_disk_size &gt; wc-&gt;size + wc-&gt;offset ? prepare_disk_size : wc-&gt;size + wc-&gt;offset;
1293 	err = eblob_check_free_space(b, eblob_calculate_size(b, key, 0, size));
1294 	if (err)
1295 		goto err_out_exit;
1296 	err = eblob_write_prepare_disk_ll(b, key, wc, prepare_disk_size,
1297 			copy, copy_offset, old);
1298 err_out_exit:
1299 	pthread_mutex_unlock(&amp;b-&gt;lock);
1300 	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk", err);
1301 	return err;
1302 }
1303 int eblob_write_prepare(struct eblob_backend *b, struct eblob_key *key,
1304 		uint64_t size, uint64_t flags)
1305 {
1306 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare", b-&gt;cfg.stat_id));
1307 	struct eblob_write_control wc = { .offset = 0 };
1308 	struct eblob_ram_control old;
1309 	int err;
1310 	size_t defrag_generation = 0;
1311 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
1312 			"key: %s, size: %" PRIu64 ", flags: %s",
1313 			eblob_dump_id(key-&gt;id), size, eblob_dump_dctl_flags(flags));
1314 	if (b == NULL || key == NULL) {
1315 		err = -EINVAL;
1316 		goto err_out_exit;
1317 	}
1318 	pthread_mutex_lock(&amp;b-&gt;lock);
1319 	defrag_generation = b-&gt;defrag_generation;
1320 	err = eblob_fill_write_control_from_ram(b, key, &amp;wc, 1, &amp;old);
1321 	pthread_mutex_unlock(&amp;b-&gt;lock);
1322 	if (err &amp;&amp; err != -ENOENT &amp;&amp; err != -E2BIG)
1323 		goto err_out_exit;
1324 	if (err == 0 &amp;&amp; (wc.total_size &gt;= eblob_calculate_size(b, key, 0, size))) {
1325 		uint64_t new_flags;
1326 		new_flags = eblob_validate_ctl_flags(b, flags);
1327 		new_flags |= BLOB_DISK_CTL_UNCOMMITTED;
1328 		if (wc.flags != new_flags) {
1329 			wc.flags = new_flags;
1330 			err = eblob_commit_disk(b, key, &amp;wc, 0);
1331 			if (err)
1332 				goto err_out_cleanup_wc;
1333 			err = eblob_commit_ram(b, key, &amp;wc);
1334 			if (err)
1335 				goto err_out_cleanup_wc;
1336 		}
1337 		eblob_stat_inc(b-&gt;stat, EBLOB_GST_PREPARE_REUSED);
1338 		goto err_out_cleanup_wc;
1339 	} else {
1340 		wc.flags = eblob_validate_ctl_flags(b, flags);
1341 		wc.flags |= BLOB_DISK_CTL_UNCOMMITTED;
1342 		err = eblob_write_prepare_disk(b, key, &amp;wc, size, EBLOB_COPY_RECORD, 0, err == -ENOENT ? NULL : &amp;old, defrag_generation);
1343 		if (err)
1344 			goto err_out_cleanup_wc;
1345 		err = eblob_commit_ram(b, key, &amp;wc);
1346 		if (err)
1347 			goto err_out_cleanup_wc;
1348 	}
1349 err_out_cleanup_wc:
1350 	eblob_write_control_cleanup(&amp;wc);
1351 err_out_exit:
1352 	eblob_dump_wc(b, key, &amp;wc, "eblob_write_prepare: finished", err);
1353 	return err;
1354 }
1355 int eblob_hash(struct eblob_backend *b, void *dst,
1356 		unsigned int dsize __attribute_unused__, const void *src, uint64_t size)
1357 {
1358 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.hash", b-&gt;cfg.stat_id));
1359 	sha512_buffer(src, size, dst);
1360 	return 0;
1361 }
1362 static int eblob_write_commit_ll(struct eblob_backend *b, struct eblob_key *key,
1363 		struct eblob_write_control *wc)
1364 {
1365 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.commit", b-&gt;cfg.stat_id));
1366 	int err;
1367 	err = eblob_commit_footer(b, key, wc);
1368 	if (err) {
1369 		eblob_dump_wc(b, key, wc, "eblob_commit_footer: ERROR", err);
1370 		goto err_out_exit;
1371 	}
1372 	err = eblob_commit_disk(b, key, wc, 0);
1373 	if (err)
1374 		goto err_out_exit;
1375 	err = eblob_commit_ram(b, key, wc);
1376 	if (err &lt; 0)
1377 		goto err_out_exit;
1378 err_out_exit:
1379 	eblob_dump_wc(b, key, wc, "eblob_write_commit_ll", err);
1380 	return err;
1381 }
1382 static int eblob_write_commit_prepare(struct eblob_backend *b, struct eblob_key *key, uint64_t size,
1383 				      uint64_t flags, struct eblob_write_control *wc)
1384 {
1385 	int err;
1386 	pthread_mutex_lock(&amp;b-&gt;lock);
1387 	err = eblob_fill_write_control_from_ram(b, key, wc, 1, NULL);
1388 	if (err &lt; 0)
1389 		goto err_out_unlock;
1390 	if (!(wc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
1391 		err = -EPERM;
1392 		goto err_out_cleanup_wc;
1393 	}
1394 	if (size &gt; wc-&gt;total_size) {
1395 		err = -ERANGE;
1396 		goto err_out_cleanup_wc;
1397 	}
1398 	if (size != ~0ULL)
1399 		wc-&gt;size = wc-&gt;total_data_size = size;
1400 	if (flags != ~0ULL)
1401 		wc-&gt;flags = flags;
1402 	wc-&gt;flags = eblob_validate_ctl_flags(b, wc-&gt;flags);
1403 	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
1404 		struct eblob_ram_control rctl;
1405 		err = eblob_cache_lookup(b, key, &amp;rctl, NULL);
1406 		if (err != 0)
1407 			goto err_out_cleanup_wc;
1408 		err = eblob_write_prepare_disk_ll(b, key, wc, size,
1409 				EBLOB_COPY_RECORD, 0, &amp;rctl);
1410 		if (err != 0)
1411 			goto err_out_cleanup_wc;
1412 	}
1413 	pthread_mutex_unlock(&amp;b-&gt;lock);
1414 	wc-&gt;flags &amp;= ~BLOB_DISK_CTL_UNCOMMITTED;
1415 	return err;
1416 err_out_cleanup_wc:
1417 	eblob_write_control_cleanup(wc);
1418 err_out_unlock:
1419 	pthread_mutex_unlock(&amp;b-&gt;lock);
1420 	return err;
1421 }
1422 int eblob_write_commit(struct eblob_backend *b, struct eblob_key *key,
1423 		uint64_t size, uint64_t flags)
1424 {
1425 	struct eblob_write_control wc = { .offset = 0, };
1426 	int err;
1427 	if (b == NULL || key == NULL) {
1428 		err = -EINVAL;
1429 		goto err_out_exit;
1430 	}
1431 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
1432 			"key: %s, size: %" PRIu64 ", flags: %s",
1433 			eblob_dump_id(key-&gt;id), size, eblob_dump_dctl_flags(flags));
1434 	err = eblob_write_commit_prepare(b, key, size, flags, &amp;wc);
1435 	if (err != 0)
1436 		goto err_out_exit;
1437 	err = eblob_write_commit_ll(b, key, &amp;wc);
1438 	if (err != 0)
1439 		goto err_out_cleanup_wc;
1440 err_out_cleanup_wc:
1441 	eblob_write_control_cleanup(&amp;wc);
1442 err_out_exit:
1443 	eblob_dump_wc(b, key, &amp;wc, "eblob_write_commit: finished", err);
1444 	return err;
1445 }
1446 static int eblob_try_overwritev(struct eblob_backend *b, struct eblob_key *key,
1447 		const struct eblob_iovec *iov, uint16_t iovcnt, struct eblob_write_control *wc, struct eblob_ram_control *old, size_t *defrag_generation)
1448 {
1449 	ssize_t err;
1450 	uint64_t flags = wc-&gt;flags;
1451 	const size_t size = wc-&gt;size;
1452 	pthread_mutex_lock(&amp;b-&gt;lock);
1453 	*defrag_generation = b-&gt;defrag_generation;
1454 	err = eblob_fill_write_control_from_ram(b, key, wc, 1, old);
1455 	if (err) {
1456 		pthread_mutex_unlock(&amp;b-&gt;lock);
1457 		goto err_out_exit;
1458 	}
1459 	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
1460 		err = -EROFS;
1461 	}
1462 	pthread_mutex_unlock(&amp;b-&gt;lock);
1463 	if (err)
1464 		goto err_out_cleanup_wc;
1465 	if ((flags &amp; BLOB_DISK_CTL_EXTHDR) != (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
1466 		err = -E2BIG;
1467 		goto err_out_cleanup_wc;
1468 	}
1469 	if ((flags &amp; BLOB_DISK_CTL_EXTHDR) &amp;&amp; (flags &amp; BLOB_DISK_CTL_APPEND))
1470 <a name="2"></a>		if (wc-&gt;offset == 0)
1471 			flags &amp;= ~BLOB_DISK_CTL_APPEND;
1472 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	wc-&gt;flags = flags;
1473 	wc-&gt;size = size;
1474 	wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
1475 	err = eblob_writev_raw(key, wc, iov, iovcnt);
1476 	if (err) {
1477 		eblob_dump_wc(b, key, wc, "eblob_try_overwrite: ERROR-eblob_writev_raw", err);
1478 		goto err_out_cleanup_wc;
1479 	}
1480 	eblob_stat_inc(b-&gt;stat, EBLOB_GST_WRITES_NUMBER);
1481 	eblob_stat_add(b-&gt;stat, EBLOB_GST_WRITES_SIZE, wc-&gt;size);
1482 	err = eblob_write_commit_ll(b, key, wc);
1483 	if (err) {
1484 		eblob_dump_wc(b, key, wc, "eblob_try_overwrite: ERROR-eblob_write_commit_ll", err);
1485 		goto err_out_cleanup_wc;
1486 	}</b></font>
1487 	eblob_dump_wc(b, key, wc, "eblob_try_overwrite", err);
1488 err_out_cleanup_wc:
1489 	eblob_write_control_cleanup(wc);
1490 err_out_exit:
1491 	return err;
1492 }
1493 int eblob_plain_write(struct eblob_backend *b, struct eblob_key *key,
1494 		void *data, uint64_t offset, uint64_t size, uint64_t flags)
1495 {
1496 	const struct eblob_iovec iov = {
1497 		.base = data,
1498 		.size = size,
1499 		.offset = offset,
1500 	};
1501 	return eblob_plain_writev(b, key, &amp;iov, 1, flags);
1502 }
1503 static int eblob_plain_writev_prepare(struct eblob_backend *b, struct eblob_key *key,
1504 				      const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags,
1505 				      struct eblob_write_control *wc, int *prepared)
1506 {
1507 	struct eblob_iovec_bounds bounds;
1508 	ssize_t err;
1509 	eblob_iovec_get_bounds(&amp;bounds, iov, iovcnt);
1510 	wc-&gt;size = bounds.max;
1511 	pthread_mutex_lock(&amp;b-&gt;lock);
1512 	err = eblob_fill_write_control_from_ram(b, key, wc, 1, NULL);
1513 	if (err)
1514 		goto err_out_unlock;
1515 	if (!(wc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
1516 		err = -EPERM;
1517 		goto err_out_cleanup_wc;
1518 	}
1519 	if ((flags &amp; BLOB_DISK_CTL_EXTHDR)
1520 			&amp;&amp; !(wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
1521 		err = -ENOTSUP;
1522 		goto err_out_cleanup_wc;
1523 	}
1524 	wc-&gt;flags = eblob_validate_ctl_flags(b, flags) | BLOB_DISK_CTL_UNCOMMITTED;
1525 	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
1526 		struct eblob_ram_control rctl;
1527 		err = eblob_cache_lookup(b, key, &amp;rctl, NULL);
1528 		if (err != 0)
1529 			goto err_out_cleanup_wc;
1530 		const uint64_t hdr_footer_size = sizeof(struct eblob_disk_control) + eblob_get_footer_size(b, wc);
1531 		if (wc-&gt;total_size &lt; hdr_footer_size) {
1532 			err = -EINVAL;
1533 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
1534 				  "blob i%d: %s: %s: size check failed: total-size: %" PRIu64 ", header-footer-size: %" PRIu64 "\n",
1535 				  wc-&gt;index, eblob_dump_id(key-&gt;id), __func__, wc-&gt;total_size, hdr_footer_size);
1536 			eblob_dump_wc(b, key, wc, "eblob_plain_writev_prepare: ERROR-size-check", err);
1537 			goto err_out_cleanup_wc;
1538 		}
1539 		const uint64_t prepare_disk_size = wc-&gt;total_size - hdr_footer_size;
1540 		err = eblob_write_prepare_disk_ll(b, key, wc,
1541 				prepare_disk_size,
1542 				EBLOB_COPY_RECORD, 0, &amp;rctl);
1543 		if (err != 0)
1544 			goto err_out_cleanup_wc;
1545 		*prepared = 1;
1546 	}
1547 	pthread_mutex_unlock(&amp;b-&gt;lock);
1548 	return err;
1549 err_out_cleanup_wc:
1550 	eblob_write_control_cleanup(wc);
1551 err_out_unlock:
1552 	pthread_mutex_unlock(&amp;b-&gt;lock);
1553 	return err;
1554 }
1555 int eblob_plain_writev(struct eblob_backend *b, struct eblob_key *key,
1556 		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags)
1557 {
1558 	struct eblob_write_control wc = { .offset = 0 };
1559 	ssize_t err;
1560 	int prepared = 0;
1561 	if (b == NULL || key == NULL || iov == NULL)
1562 		return -EINVAL;
1563 	if (iovcnt &lt; EBLOB_IOVCNT_MIN || iovcnt &gt; EBLOB_IOVCNT_MAX)
1564 		return -E2BIG;
1565 	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
1566 			"key: %s, iovcnt: %" PRIu16 ", flags: %s",
1567 			eblob_dump_id(key-&gt;id), iovcnt, eblob_dump_dctl_flags(flags));
1568 	err = eblob_plain_writev_prepare(b, key, iov, iovcnt, flags, &amp;wc, &amp;prepared);
1569 	if (err)
1570 		goto err_out_exit;
1571 	err = eblob_writev_raw(key, &amp;wc, iov, iovcnt);
1572 	if (err)
1573 		goto err_out_cleanup_wc;
1574 	if (prepared) {
1575 		err = eblob_commit_ram(b, key, &amp;wc);
1576 		if (err != 0)
1577 			goto err_out_cleanup_wc;
1578 	}
1579 err_out_cleanup_wc:
1580 	eblob_write_control_cleanup(&amp;wc);
1581 err_out_exit:
1582 	eblob_log(b-&gt;cfg.log, err ? EBLOB_LOG_ERROR : EBLOB_LOG_NOTICE,
1583 			"blob: %s: %s: eblob_writev_raw: fd: %d: "
1584 			"size: %" PRIu64 ", offset: %" PRIu64 ": %zd.\n",
1585 			eblob_dump_id(key-&gt;id), __func__, wc.data_fd, wc.size,
1586 			wc.data_offset + wc.offset, err);
1587 	if (err) {
1588 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.plain.errors.%zd", b-&gt;cfg.stat_id, -err), 1);
1589 	}
1590 	return err;
1591 }
1592 int eblob_write(struct eblob_backend *b, struct eblob_key *key,
1593 		void *data, uint64_t offset, uint64_t size,
1594 		uint64_t flags)
1595 {
1596 	const struct eblob_iovec iov = {
1597 		.base = data,
1598 		.size = size,
1599 		.offset = offset,
1600 	};
1601 	return eblob_writev(b, key, &amp;iov, 1, flags);
1602 }
1603 int eblob_write_return(struct eblob_backend *b, struct eblob_key *key,
1604 		void *data, uint64_t offset, uint64_t size, uint64_t flags,
1605 		struct eblob_write_control *wc)
1606 {
1607 	const struct eblob_iovec iov = {
1608 		.base = data,
1609 		.size = size,
1610 		.offset = offset,
1611 	};
1612 	return eblob_writev_return(b, key, &amp;iov, 1, flags, wc);
1613 }
1614 int eblob_writev(struct eblob_backend *b, struct eblob_key *key,
1615 		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags)
1616 {
1617 	struct eblob_write_control wc;
1618 	return eblob_writev_return(b, key, iov, iovcnt, flags, &amp;wc);
1619 }
1620 static int check_writev_return_flags(uint64_t flags, uint16_t iovcnt) {
1621 	if (flags &amp; BLOB_DISK_CTL_COMPRESS)
1622 		return -ENOTSUP;
1623 	if (flags &amp; BLOB_DISK_CTL_WRITE_RETURN)
1624 		return -ENOTSUP;
1625 	if (flags &amp; BLOB_DISK_CTL_REMOVE)
1626 		return -ENOTSUP;
1627 	if (iovcnt &lt; EBLOB_IOVCNT_MIN || iovcnt &gt; EBLOB_IOVCNT_MAX)
1628 		return -E2BIG;
1629 	return 0;
1630 }
1631 int eblob_writev_return(struct eblob_backend *b, struct eblob_key *key,
1632 		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags,
1633 		struct eblob_write_control *wc)
1634 {
1635 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write", b-&gt;cfg.stat_id));
1636 	struct eblob_iovec_bounds bounds;
1637 	struct eblob_ram_control old;
1638 	enum eblob_copy_flavour copy = EBLOB_DONT_COPY_RECORD;
1639 	uint64_t copy_offset = 0;
1640 	int err;
1641 	size_t defrag_generation = 0;
1642 	if (b == NULL || key == NULL || iov == NULL || wc == NULL)
1643 		return -EINVAL;
1644 	err = check_writev_return_flags(flags, iovcnt);
1645 	if (err) {
1646 		return err;
1647 	}
1648 	memset(wc, 0, sizeof(struct eblob_write_control));
1649 	eblob_iovec_get_bounds(&amp;bounds, iov, iovcnt);
1650 	wc-&gt;size = bounds.max;
1651 	wc-&gt;flags = eblob_validate_ctl_flags(b, flags);
1652 	wc-&gt;index = -1;
1653 	err = eblob_try_overwritev(b, key, iov, iovcnt, wc, &amp;old, &amp;defrag_generation);
1654 	if (err == 0) {
1655 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.rewrites", b-&gt;cfg.stat_id), 1);
1656 		goto err_out_exit;
1657 	} else if (!(err == -E2BIG || err == -ENOENT || err == -EROFS)) {
1658 		goto err_out_exit;
1659 	} else if (err == -E2BIG || err == -EROFS) {
1660 		if ((flags &amp; BLOB_DISK_CTL_APPEND)
1661 				|| bounds.min != 0
1662 				|| bounds.max &lt; wc-&gt;total_data_size
1663 				|| bounds.contiguous == 0)
1664 			copy = EBLOB_COPY_RECORD;
1665 		if ((flags &amp; BLOB_DISK_CTL_EXTHDR)
1666 				&amp;&amp; !(wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
1667 			copy = EBLOB_COPY_RECORD;
1668 			copy_offset = iov[0].size;
1669 		}
1670 		if (!(flags &amp; BLOB_DISK_CTL_EXTHDR)
1671 				&amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
1672 			err = -EINVAL;
1673 			goto err_out_exit;
1674 		}
1675 		wc-&gt;offset = 0;
1676 		wc-&gt;flags = eblob_validate_ctl_flags(b, flags);
1677 	}
1678 	err = eblob_write_prepare_disk(b, key, wc, 0, copy, copy_offset, err == -ENOENT ? NULL : &amp;old, defrag_generation);
1679 	if (err)
1680 		goto err_out_cleanup_wc;
1681 	err = eblob_writev_raw(key, wc, iov, iovcnt);
1682 	if (err) {
1683 		eblob_dump_wc(b, key, wc, "eblob_writev: eblob_writev_raw: FAILED", err);
1684 		goto err_out_cleanup_wc;
1685 	}
1686 	err = eblob_write_commit_ll(b, key, wc);
1687 	if (err) {
1688 		eblob_dump_wc(b, key, wc, "eblob_writev: eblob_write_commit_ll: FAILED", err);
1689 		goto err_out_cleanup_wc;
1690 	}
1691 err_out_cleanup_wc:
1692 	eblob_write_control_cleanup(wc);
1693 err_out_exit:
1694 	eblob_dump_wc(b, key, wc, "eblob_writev: finished", err);
1695 	if (err) {
1696 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.errors.%d", b-&gt;cfg.stat_id, -err), 1);
1697 	}
1698 	return err;
1699 }
1700 int eblob_remove(struct eblob_backend *b, struct eblob_key *key)
1701 {
1702 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.remove", b-&gt;cfg.stat_id));
1703 	struct eblob_ram_control ctl;
1704 	int err, disk;
1705 	pthread_mutex_lock(&amp;b-&gt;lock);
1706 	err = eblob_cache_lookup(b, key, &amp;ctl, &amp;disk);
1707 	if (err) {
1708 		pthread_mutex_unlock(&amp;b-&gt;lock);
1709 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: %s: %s: eblob_cache_lookup: %d.\n",
1710 				eblob_dump_id(key-&gt;id), __func__, err);
1711 		goto err_out_exit;
1712 	}
1713 	eblob_bctl_hold(ctl.bctl);
1714 	pthread_mutex_unlock(&amp;b-&gt;lock);
1715 	if ((err = eblob_mark_entry_removed_purge(b, key, &amp;ctl)) != 0) {
1716 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1717 				"%s: %s: eblob_mark_entry_removed_purge: %d\n",
1718 				__func__, eblob_dump_id(key-&gt;id), -err);
1719 		goto err_out_bctl_release;
1720 	}
1721 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
1722 		"blob: %s: eblob_remove: removed block at: %" PRIu64
1723 		", size: %" PRIu64 ".\n",
1724 		eblob_dump_id(key-&gt;id), ctl.data_offset, ctl.size);
1725 err_out_bctl_release:
1726 	eblob_bctl_release(ctl.bctl);
1727 err_out_exit:
1728 	if (err &amp;&amp; err != -ENOENT) {
1729 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.remove.errors.%d", b-&gt;cfg.stat_id, -err), 1);
1730 	}
1731 	return err;
1732 }
1733 static int _eblob_read_ll(struct eblob_backend *b, struct eblob_key *key,
1734 		enum eblob_read_flavour csum, struct eblob_write_control *wc)
1735 {
1736 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.read", b-&gt;cfg.stat_id));
1737 	int err;
1738 	struct timeval start, end;
1739 	long csum_time;
1740 	assert(b != NULL);
1741 	assert(key != NULL);
1742 	assert(wc != NULL);
1743 	eblob_stat_inc(b-&gt;stat, EBLOB_GST_LOOKUP_READS_NUMBER);
1744 	memset(wc, 0, sizeof(struct eblob_write_control));
1745 	pthread_mutex_lock(&amp;b-&gt;lock);
1746 	err = eblob_fill_write_control_from_ram(b, key, wc, 0, NULL);
1747 	pthread_mutex_unlock(&amp;b-&gt;lock);
1748 	if (err &lt; 0) {
1749 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1750 				"blob: %s: %s: eblob_fill_write_control_from_ram: %d.\n",
1751 				eblob_dump_id(key-&gt;id), __func__, err);
1752 		goto err_out_exit;
1753 	}
1754 	if (wc-&gt;flags &amp; BLOB_DISK_CTL_COMPRESS) {
1755 		err = -ENOTSUP;
1756 		goto err_out_cleanup_wc;
1757 	}
1758 	gettimeofday(&amp;start, NULL);
1759 	if (csum != EBLOB_READ_NOCSUM) {
1760 		err = eblob_verify_checksum(b, key, wc);
1761 		if (err) {
1762 			eblob_dump_wc(b, key, wc, "_eblob_read_ll: checksum verification failed", err);
1763 			goto err_out_cleanup_wc;
1764 		}
1765 	}
1766 	gettimeofday(&amp;end, NULL);
1767 	csum_time = DIFF(start, end);
1768 	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "blob: %s: eblob_read: Ok: data_fd: %d"
1769 			", ctl_data_offset: %" PRIu64 ", data_offset: %" PRIu64
1770 			", index_fd: %d, index_offset: %" PRIu64 ", size: %" PRIu64
1771 			", total(disk)_size: %" PRIu64 ", on_disk: %d, want-csum: %d, csum-time: %ld usecs, err: %d\n",
1772 			eblob_dump_id(key-&gt;id), wc-&gt;data_fd, wc-&gt;ctl_data_offset, wc-&gt;data_offset,
1773 			wc-&gt;index_fd, wc-&gt;ctl_index_offset, wc-&gt;size, wc-&gt;total_size, wc-&gt;on_disk,
1774 			csum, csum_time, err);
1775 err_out_cleanup_wc:
1776 	eblob_write_control_cleanup(wc);
1777 err_out_exit:
1778 	if (err &amp;&amp; err != -ENOENT) {
1779 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.read.errors.%d", b-&gt;cfg.stat_id, -err), 1);
1780 	}
1781 	return err;
1782 }
1783 static int eblob_read_ll(struct eblob_backend *b, struct eblob_key *key, int *fd,
1784 		uint64_t *offset, uint64_t *size, enum eblob_read_flavour csum)
1785 {
1786 	struct eblob_write_control wc = { .size = 0 };
1787 	int err;
1788 	if (b == NULL || key == NULL || fd == NULL || offset == NULL || size == NULL)
1789 		return -EINVAL;
1790 	err = _eblob_read_ll(b, key, csum, &amp;wc);
1791 	if (err &lt; 0)
1792 		goto err;
1793 	if (wc.flags &amp; BLOB_DISK_CTL_UNCOMMITTED) {
1794 		err = -ENOENT;
1795 		goto err;
1796 	}
1797 	*fd = wc.data_fd;
1798 	*size = wc.size;
1799 	*offset = wc.data_offset;
1800 err:
1801 	return err;
1802 }
1803 int eblob_read(struct eblob_backend *b, struct eblob_key *key, int *fd,
1804 		uint64_t *offset, uint64_t *size)
1805 {
1806 	return eblob_read_ll(b, key, fd, offset, size, EBLOB_READ_CSUM);
1807 }
1808 int eblob_read_nocsum(struct eblob_backend *b, struct eblob_key *key,
1809 		int *fd, uint64_t *offset, uint64_t *size)
1810 {
1811 	return eblob_read_ll(b, key, fd, offset, size, EBLOB_READ_NOCSUM);
1812 }
1813 int eblob_read_return(struct eblob_backend *b, struct eblob_key *key,
1814 		enum eblob_read_flavour csum, struct eblob_write_control *wc)
1815 {
1816 	if (b == NULL || key == NULL || wc == NULL)
1817 		return -EINVAL;
1818 	return _eblob_read_ll(b, key, csum, wc);
1819 }
1820 static int eblob_read_data_ll(struct eblob_backend *b, struct eblob_key *key,
1821 		uint64_t offset, char **dst, uint64_t *size, enum eblob_read_flavour csum)
1822 {
1823 	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.read_data", b-&gt;cfg.stat_id));
1824 	int err, fd;
1825 	void *data;
1826 	uint64_t record_offset, record_size;
1827 	err = eblob_read_ll(b, key, &amp;fd, &amp;record_offset, &amp;record_size, csum);
1828 	if (err &lt; 0)
1829 		goto err_out_exit;
1830 	if (offset &gt;= record_size) {
1831 		err = -E2BIG;
1832 		goto err_out_exit;
1833 	}
1834 	record_offset += offset;
1835 	record_size -= offset;
1836 	if (*size &amp;&amp; record_size &gt; *size)
1837 		record_size = *size;
1838 	data = malloc(record_size);
1839 	if (!data) {
1840 		err = -ENOMEM;
1841 		goto err_out_exit;
1842 	}
1843 	err = __eblob_read_ll(fd, data, record_size, record_offset);
1844 	if (err != 0)
1845 		goto err_out_free;
1846 	eblob_stat_inc(b-&gt;stat, EBLOB_GST_DATA_READS_NUMBER);
1847 	eblob_stat_add(b-&gt;stat, EBLOB_GST_READS_SIZE, record_size);
1848 	*size = record_size;
1849 	*dst = data;
1850 	return 0;
1851 err_out_free:
1852 	free(data);
1853 err_out_exit:
1854 	if (err &amp;&amp; err != -ENOENT) {
1855 		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.read_data.errors.%d", b-&gt;cfg.stat_id, -err), 1);
1856 	}
1857 	return err;
1858 }
1859 int eblob_read_data(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, char **dst, uint64_t *size)
1860 {
1861 	return eblob_read_data_ll(b, key, offset, dst, size, EBLOB_READ_CSUM);
1862 }
1863 int eblob_read_data_nocsum(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, char **dst, uint64_t *size)
1864 {
1865 	return eblob_read_data_ll(b, key, offset, dst, size, EBLOB_READ_NOCSUM);
1866 }
1867 static void *eblob_sync_thread(void *data)
1868 {
1869 	struct eblob_backend *b = data;
1870 	while (b-&gt;cfg.sync &amp;&amp; (eblob_event_wait(&amp;b-&gt;exit_event, b-&gt;cfg.sync) == -ETIMEDOUT)) {
1871 		eblob_sync(b);
1872 	}
1873 	return NULL;
1874 }
1875 int eblob_sync(struct eblob_backend *b)
1876 {
1877 	struct eblob_base_ctl *ctl;
1878 	pthread_mutex_lock(&amp;b-&gt;sync_lock);
1879 	list_for_each_entry(ctl, &amp;b-&gt;bases, base_entry) {
1880 		fsync(ctl-&gt;data_ctl.fd);
1881 		fsync(ctl-&gt;index_ctl.fd);
1882 	}
1883 	pthread_mutex_unlock(&amp;b-&gt;sync_lock);
1884 	return 0;
1885 }
1886 static int eblob_cache_statvfs(struct eblob_backend *b)
1887 {
1888 	if (statvfs(b-&gt;base_dir, &amp;b-&gt;vfs_stat) == -1)
1889 		return -errno;
1890 	return 0;
1891 }
1892 static void *eblob_periodic_thread(void *data)
1893 {
1894 	struct eblob_backend *b = data;
1895 	while (eblob_event_wait(&amp;b-&gt;exit_event, 1) == -ETIMEDOUT) {
1896 		eblob_periodic(b);
1897 	}
1898 	return NULL;
1899 }
1900 int eblob_periodic(struct eblob_backend *b)
1901 {
1902 	int err;
1903 	time_t t = time(NULL);
1904 	pthread_mutex_lock(&amp;b-&gt;periodic_lock);
1905 	if (t &gt; b-&gt;stat_file_time + (time_t)b-&gt;cfg.periodic_timeout) {
1906 		err = eblob_stat_commit(b);
1907 		if (err != 0) {
1908 			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
1909 				"eblob_stat_commit: FAILED");
1910 			FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.stat_commit.errors.%d", b-&gt;cfg.stat_id, -err), 1);
1911 		}
1912 		b-&gt;stat_file_time = t;
1913 	}
1914 	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_NO_FREE_SPACE_CHECK)) {
1915 		err = eblob_cache_statvfs(b);
1916 		if (err != 0) {
1917 			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
1918 				"eblob_cache_statvfs: FAILED");
1919 		}
1920 	}
1921 	err = eblob_json_commit(b);
1922 	if (err != 0) {
1923 		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
1924 			"eblob_json_coomit: FAILED");
1925 	}
1926 	pthread_mutex_unlock(&amp;b-&gt;periodic_lock);
1927 	return err;
1928 }
1929 void eblob_cleanup(struct eblob_backend *b)
1930 {
1931 	eblob_event_set(&amp;b-&gt;exit_event);
1932 	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_DISABLE_THREADS)) {
1933 		pthread_join(b-&gt;sync_tid, NULL);
1934 		pthread_join(b-&gt;defrag_tid, NULL);
1935 		pthread_join(b-&gt;periodic_tid, NULL);
1936 	}
1937 	eblob_json_stat_destroy(b);
1938 	eblob_bases_cleanup(b);
1939 	eblob_hash_destroy(&amp;b-&gt;hash);
1940 	eblob_l2hash_destroy(&amp;b-&gt;l2hash);
1941 	free(b-&gt;base_dir);
1942 	free(b-&gt;cfg.file);
1943 	free(b-&gt;cfg.chunks_dir);
1944 	eblob_stat_destroy(b-&gt;stat);
1945 	eblob_stat_destroy(b-&gt;stat_summary);
1946 	(void)lockf(b-&gt;lock_fd, F_ULOCK, 0);
1947 	(void)close(b-&gt;lock_fd);
1948 	free(b);
1949 }
1950 static int eblob_lock_blob(struct eblob_backend *b)
1951 {
1952 	char lock_file[PATH_MAX];
1953 	if (b == NULL)
1954 		return -EINVAL;
1955 	if (snprintf(lock_file, PATH_MAX, "%s.lock", b-&gt;cfg.file) &gt; PATH_MAX)
1956 		return -ENAMETOOLONG;
1957 	b-&gt;lock_fd = open(lock_file, O_RDWR | O_CLOEXEC | O_TRUNC | O_CREAT, 0644);
1958 	if (b-&gt;lock_fd == -1)
1959 		return -errno;
1960 	if (lockf(b-&gt;lock_fd, F_TLOCK, 0) == -1) {
1961 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1962 				"blob: lock file is busy: %d\n", -errno);
1963 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1964 				"blob: to find culprit use lsof/fuser: %s\n", lock_file);
1965 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1966 				"blob: EB0000: database is locked:\n");
1967 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
1968 				"blob: http://doc.reverbrain.com/kb:eblob:eb0000-database-is-locked\n");
1969 		(void)close(b-&gt;lock_fd);
1970 		return -errno;
1971 	}
1972 	return 0;
1973 }
1974 struct eblob_backend *eblob_init(struct eblob_config *c)
1975 {
1976 	struct eblob_backend *b;
1977 	char stat_file[PATH_MAX];
1978 	int err;
1979 	eblob_log(c-&gt;log, EBLOB_LOG_INFO, "blob: start\n");
1980 	b = calloc(1, sizeof(struct eblob_backend));
1981 	if (!b) {
1982 		err = -ENOMEM;
1983 		goto err_out_exit;
1984 	}
1985 	snprintf(stat_file, sizeof(stat_file), "%s.stat", c-&gt;file);
1986 	err = eblob_stat_init_backend(b, stat_file);
1987 	if (err) {
1988 		eblob_log(c-&gt;log, EBLOB_LOG_ERROR,
1989 				"blob: eblob_stat_init_global failed: %s: %s %d.\n",
1990 				stat_file, strerror(-err), err);
1991 		goto err_out_free;
1992 	}
1993 	err = eblob_stat_init_local(&amp;b-&gt;stat_summary);
1994 	if (err) {
1995 		eblob_log(c-&gt;log, EBLOB_LOG_ERROR,
1996 				"blob: eblob_stat_init_local failed: %s %d.\n",
1997 				strerror(-err), err);
1998 		goto err_out_stat_free;
1999 	}
2000 	if (!c-&gt;index_block_size)
2001 		c-&gt;index_block_size = EBLOB_INDEX_DEFAULT_BLOCK_SIZE;
2002 	if (!c-&gt;index_block_bloom_length)
2003 		c-&gt;index_block_bloom_length = EBLOB_INDEX_DEFAULT_BLOCK_BLOOM_LENGTH;
2004 	if (!c-&gt;blob_size)
2005 		c-&gt;blob_size = EBLOB_BLOB_DEFAULT_BLOB_SIZE;
2006 	if (!c-&gt;records_in_blob)
2007 		c-&gt;records_in_blob = EBLOB_BLOB_DEFAULT_RECORDS_IN_BLOB;
2008 	if (!c-&gt;defrag_timeout)
2009 		c-&gt;defrag_timeout = EBLOB_DEFAULT_DEFRAG_TIMEOUT;
2010 	if (!c-&gt;defrag_percentage || (c-&gt;defrag_percentage &lt; 0) || (c-&gt;defrag_percentage &gt; 100))
2011 		c-&gt;defrag_percentage = EBLOB_DEFAULT_DEFRAG_PERCENTAGE;
2012 	if ((c-&gt;defrag_time &lt; 0 || c-&gt;defrag_time &gt; 24)
2013 			|| (c-&gt;defrag_splay &lt; 0 || c-&gt;defrag_time &gt; 24)) {
2014 		c-&gt;defrag_time = EBLOB_DEFAULT_DEFRAG_TIME;
2015 		c-&gt;defrag_splay = EBLOB_DEFAULT_DEFRAG_SPLAY;
2016 	}
2017 	if (!c-&gt;periodic_timeout) {
2018 		c-&gt;periodic_timeout = EBLOB_DEFAULT_PERIODIC_THREAD_TIMEOUT;
2019 	}
2020 	memcpy(&amp;b-&gt;cfg, c, sizeof(struct eblob_config));
2021 	b-&gt;cfg.file = strdup(c-&gt;file);
2022 	if (!b-&gt;cfg.file) {
2023 		errno = -ENOMEM;
2024 		goto err_out_stat_free_local;
2025 	}
2026 	if (c-&gt;chunks_dir) {
2027 		b-&gt;cfg.chunks_dir = strdup(c-&gt;chunks_dir);
2028 		if (!b-&gt;cfg.chunks_dir) {
2029 			errno = -ENOMEM;
2030 			goto err_out_free_file;
2031 		}
2032 	}
2033 	b-&gt;base_dir = strdup(c-&gt;file);
2034 	if (!b-&gt;base_dir) {
2035 		errno = -ENOMEM;
2036 		goto err_out_free_file;
2037 	}
2038 	b-&gt;base_dir = dirname(b-&gt;base_dir);
2039 	err = eblob_lock_blob(b);
2040 	if (err != 0) {
2041 		eblob_log(c-&gt;log, EBLOB_LOG_ERROR, "blob: eblob_lock_blob: FAILED: %s: %d.\n", strerror(-err), err);
2042 		goto err_out_free_base_dir;
2043 	}
2044 	err = eblob_cache_statvfs(b);
2045 	if (err != 0) {
2046 		eblob_log(c-&gt;log, EBLOB_LOG_ERROR, "blob: eblob_cache_statvfs failed: %s: %d.\n", strerror(-err), err);
2047 		goto err_out_lockf;
2048 	}
2049 	err = eblob_mutex_init(&amp;b-&gt;lock);
2050 	if (err != 0)
2051 		goto err_out_lockf;
2052 	INIT_LIST_HEAD(&amp;b-&gt;bases);
2053 	b-&gt;max_index = -1;
2054 	err = eblob_l2hash_init(&amp;b-&gt;l2hash);
2055 	if (err) {
2056 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: l2hash initialization failed: %s %d.\n", strerror(-err), err);
2057 		goto err_out_lock_destroy;
2058 	}
2059 	err = eblob_hash_init(&amp;b-&gt;hash, sizeof(struct eblob_ram_control));
2060 	if (err) {
2061 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: hash initialization failed: %s %d.\n", strerror(-err), err);
2062 		goto err_out_l2hash_destroy;
2063 	}
2064 	err = eblob_load_data(b);
2065 	if (err) {
2066 		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: index iteration failed: %d.\n", err);
2067 		goto err_out_hash_destroy;
2068 	}
2069 	eblob_stat_summary_update(b);
2070 	err = eblob_event_init(&amp;b-&gt;exit_event);
2071 	if (err != 0)
2072 		goto err_out_cleanup;
2073 	err = eblob_mutex_init(&amp;b-&gt;defrag_lock);
2074 	if (err != 0)
2075 		goto err_out_exit_event_destroy;
2076 	err = eblob_mutex_init(&amp;b-&gt;sync_lock);
2077 	if (err != 0)
2078 		goto err_out_defrag_lock_destroy;
2079 	err = eblob_mutex_init(&amp;b-&gt;periodic_lock);
2080 	if (err != 0)
2081 		goto err_out_sync_lock_destroy;
2082 	err = eblob_json_stat_init(b);
2083 	if (err != 0)
2084 		goto err_out_periodic_lock_destroy;
2085 	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_DISABLE_THREADS)) {
2086 		err = pthread_create(&amp;b-&gt;sync_tid, NULL, eblob_sync_thread, b);
2087 		if (err) {
2088 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob sync thread creation failed: %d.\n", err);
2089 			goto err_out_json_stat_destroy;
2090 		}
2091 		err = pthread_create(&amp;b-&gt;defrag_tid, NULL, eblob_defrag_thread, b);
2092 		if (err) {
2093 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob defrag thread creation failed: %d.\n", err);
2094 			goto err_out_join_sync;
2095 		}
2096 		err = pthread_create(&amp;b-&gt;periodic_tid, NULL, eblob_periodic_thread, b);
2097 		if (err) {
2098 			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob periodic thread creation failed: %d.\n", err);
2099 			goto err_out_join_defrag;
2100 		}
2101 	}
2102 	return b;
2103 err_out_join_defrag:
2104 	eblob_event_set(&amp;b-&gt;exit_event);
2105 	pthread_join(b-&gt;defrag_tid, NULL);
2106 err_out_join_sync:
2107 	eblob_event_set(&amp;b-&gt;exit_event);
2108 	pthread_join(b-&gt;sync_tid, NULL);
2109 err_out_json_stat_destroy:
2110 	eblob_json_stat_destroy(b);
2111 err_out_periodic_lock_destroy:
2112 	pthread_mutex_destroy(&amp;b-&gt;periodic_lock);
2113 err_out_sync_lock_destroy:
2114 	pthread_mutex_destroy(&amp;b-&gt;sync_lock);
2115 err_out_defrag_lock_destroy:
2116 	pthread_mutex_destroy(&amp;b-&gt;defrag_lock);
2117 err_out_exit_event_destroy:
2118 	eblob_event_destroy(&amp;b-&gt;exit_event);
2119 err_out_cleanup:
2120 	eblob_bases_cleanup(b);
2121 err_out_l2hash_destroy:
2122 	eblob_l2hash_destroy(&amp;b-&gt;l2hash);
2123 err_out_hash_destroy:
2124 	eblob_hash_destroy(&amp;b-&gt;hash);
2125 err_out_lock_destroy:
2126 	pthread_mutex_destroy(&amp;b-&gt;lock);
2127 err_out_lockf:
2128 	(void)lockf(b-&gt;lock_fd, F_ULOCK, 0);
2129 	(void)close(b-&gt;lock_fd);
2130 err_out_free_base_dir:
2131 	free(b-&gt;base_dir);
2132 err_out_free_file:
2133 	free(b-&gt;cfg.file);
2134 	free(b-&gt;cfg.chunks_dir);
2135 err_out_stat_free_local:
2136 	eblob_stat_destroy(b-&gt;stat_summary);
2137 err_out_stat_free:
2138 	eblob_stat_destroy(b-&gt;stat);
2139 err_out_free:
2140 	free(b);
2141 err_out_exit:
2142 	errno = err;
2143 	return NULL;
2144 }
2145 unsigned long long eblob_total_elements(struct eblob_backend *b)
2146 {
2147 	return eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_RECORDS_TOTAL)
2148 		- eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
2149 }
2150 int eblob_write_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize,
2151 		const void *data, const uint64_t offset, const uint64_t dsize,
2152 		const uint64_t flags)
2153 {
2154 	struct eblob_key ekey;
2155 	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
2156 	return eblob_write(b, &amp;ekey, (void *)data, offset, dsize, flags);
2157 }
2158 int eblob_read_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize,
2159 		int *fd, uint64_t *offset, uint64_t *size)
2160 {
2161 	struct eblob_key ekey;
2162 	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
2163 	return eblob_read(b, &amp;ekey, fd, offset, size);
2164 }
2165 int eblob_remove_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize)
2166 {
2167 	struct eblob_key ekey;
2168 	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
2169 	return eblob_remove(b, &amp;ekey);
2170 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
