<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for index.c &amp; blob.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for index.c &amp; blob.c
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>index.c (8.5161295%)<th>blob.c (2.862099%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(83-89)<td><a href="#" name="0">(765-777)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(276-288)<td><a href="#" name="1">(879-889)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(830-849)<td><a href="#" name="2">(2260-2277)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(706-716)<td><a href="#" name="3">(148-158)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(415-431)<td><a href="#" name="4">(77-93)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>index.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "features.h"
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include "blob.h"
#include "measure_points.h"
int eblob_key_sort(const void *key1, const void *key2)
{
	return eblob_id_cmp(((struct eblob_key *)key1)-&gt;id, ((struct eblob_key *)key2)-&gt;id);
}
int eblob_disk_control_sort(const void *d1, const void *d2)
{
	const struct eblob_disk_control *dc1 = d1;
	const struct eblob_disk_control *dc2 = d2;
	return eblob_id_cmp(dc1-&gt;key.id, dc2-&gt;key.id);
}
int eblob_disk_control_sort_with_flags(const void *d1, const void *d2)
{
	const struct eblob_disk_control *dc1 = d1;
	const struct eblob_disk_control *dc2 = d2;
	int cmp = eblob_id_cmp(dc1-&gt;key.id, dc2-&gt;key.id);
	if (cmp == 0) {
		if ((dc1-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp; !(dc2-&gt;flags &amp; BLOB_DISK_CTL_REMOVE))
			cmp = -1;
		if (!(dc1-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp; (dc2-&gt;flags &amp; BLOB_DISK_CTL_REMOVE))
<a name="0"></a>			cmp = 1;
	}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return cmp;
}
static int eblob_key_range_cmp(const void *k1, const void *k2)
{
	const struct eblob_key *key = k1;
	const struct eblob_index_block *index = k2;</b></font>
	int cmp;
	cmp = eblob_id_cmp(key-&gt;id, index-&gt;start_key.id);
	if (cmp &lt; 0)
		return -1;
	if (cmp == 0)
		return 0;
	cmp = eblob_id_cmp(key-&gt;id, index-&gt;end_key.id);
	if (cmp &lt; 0)
		return 0;
	if (cmp == 0)
		return 0;
	return 1;
}
int eblob_index_block_cmp(const void *k1, const void *k2)
{
	const struct eblob_index_block *k = k1;
	return eblob_key_range_cmp(&amp;k-&gt;start_key, k2);
}
static int eblob_find_non_removed_callback(struct eblob_disk_control *sorted,
		struct eblob_disk_control *dc __attribute_unused__)
{
	uint64_t rem = eblob_bswap64(BLOB_DISK_CTL_REMOVE);
	return !(sorted-&gt;flags &amp; rem);
}
int eblob_index_blocks_destroy(struct eblob_base_ctl *bctl)
{
	pthread_rwlock_wrlock(&amp;bctl-&gt;index_blocks_lock);
	free(bctl-&gt;index_blocks);
	free(bctl-&gt;bloom);
	bctl-&gt;index_blocks = NULL;
	bctl-&gt;bloom = NULL;
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_BLOOM_SIZE, 0);
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE, 0);
	pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
	return 0;
}
struct eblob_index_block *eblob_index_blocks_search_nolock_bsearch_nobloom(struct eblob_base_ctl *bctl, struct eblob_disk_control *dc,
		struct eblob_disk_search_stat *st)
{
	struct eblob_index_block *t = NULL;
	t = bsearch(&amp;dc-&gt;key, bctl-&gt;index_blocks,
		eblob_stat_get(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE) / sizeof(struct eblob_index_block),
		sizeof(struct eblob_index_block), eblob_key_range_cmp);
	if (t)
		st-&gt;found_index_block++;
	return t;
}
struct eblob_index_block *eblob_index_blocks_search_nolock(struct eblob_base_ctl *bctl, struct eblob_disk_control *dc,
		struct eblob_disk_search_stat *st)
{
	struct eblob_index_block *t = NULL;
	if (!eblob_bloom_get(bctl, &amp;dc-&gt;key)) {
		st-&gt;bloom_null++;
		return NULL;
	}
	t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, dc, st);
	if (!t)
		st-&gt;no_block++;
	return t;
}
static uint64_t eblob_bloom_size(const struct eblob_base_ctl *bctl)
{
	uint64_t bloom_size = 0;
	bloom_size += bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control);
	bloom_size /= bctl-&gt;back-&gt;cfg.index_block_size;
	bloom_size += 1;
	bloom_size *= bctl-&gt;back-&gt;cfg.index_block_bloom_length;
	bloom_size /= 8;
	return bloom_size;
}
static uint8_t eblob_bloom_func_num(const struct eblob_base_ctl *bctl)
{
	uint64_t bits_per_key;
	uint8_t func_num = 0;
	bits_per_key = 8 * bctl-&gt;bloom_size /
		(bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control));
	func_num = bits_per_key * 0.69;
	if (func_num == 0)
		return 1;
	if (func_num &gt; 20)
		return 20;
	return func_num;
}
int eblob_index_blocks_fill(struct eblob_base_ctl *bctl)
{
	struct eblob_index_block *block = NULL;
	struct eblob_disk_control dc, prev;
	uint64_t block_count, block_id = 0, err_count = 0, offset = 0, prev_offset = 0;
	int64_t removed = 0;
	int64_t removed_size = 0;
	unsigned int i;
	int err = 0;
	int prev_filled = 0;
	bctl-&gt;bloom_size = eblob_bloom_size(bctl);
	EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_NOTICE,
			"index: bloom filter size: %" PRIu64, bctl-&gt;bloom_size);
	bctl-&gt;bloom_func_num = eblob_bloom_func_num(bctl);
	bctl-&gt;bloom = calloc(1, bctl-&gt;bloom_size);
	if (bctl-&gt;bloom == NULL) {
		err = -err;
		goto err_out_exit;
	}
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_BLOOM_SIZE, bctl-&gt;bloom_size);
	block_count = howmany(bctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control),
			bctl-&gt;back-&gt;cfg.index_block_size);
	bctl-&gt;index_blocks = calloc(block_count, sizeof(struct eblob_index_block));
	if (bctl-&gt;index_blocks == NULL) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_INDEX_BLOCKS_SIZE,
			block_count * sizeof(struct eblob_index_block));
	while (offset &lt; bctl-&gt;index_ctl.size) {
		block = &amp;bctl-&gt;index_blocks[block_id++];
		block-&gt;start_offset = offset;
		for (i = 0; i &lt; bctl-&gt;back-&gt;cfg.index_block_size &amp;&amp; offset &lt; bctl-&gt;index_ctl.size; ++i) {
			err = pread(bctl-&gt;index_ctl.fd, &amp;dc, sizeof(struct eblob_disk_control), offset);
			if (err != sizeof(struct eblob_disk_control)) {
				if (err &lt; 0)
					err = -errno;
				goto err_out_drop_tree;
<a name="1"></a>			}
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			err = eblob_check_record(bctl, &amp;dc);
			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: eblob_index_blocks_fill: %s: index: %d, "
				"index position: %llu, data position: %llu, "
				"data size: %llu, disk size: %llu, flags: %s, check-error: %d\n",
				eblob_dump_id_len(dc.key.id, EBLOB_ID_SIZE),
				bctl-&gt;index,
				(unsigned long long)offset, (unsigned long long)dc.position,
				(unsigned long long)dc.data_size, (unsigned long long)dc.disk_size,
				eblob_dump_dctl_flags(dc.flags), err);
			if (err != 0) {</b></font>
				eblob_stat_inc(bctl-&gt;stat, EBLOB_LST_INDEX_CORRUPTED_ENTRIES);
				if (err_count++ &gt; EBLOB_BLOB_INDEX_CORRUPT_MAX
						|| i == 0 || i == bctl-&gt;back-&gt;cfg.index_block_size - 1) {
					EBLOB_WARNC(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
							"EB0001: too many index corruptions: %" PRIu64
							", can not continue", err_count);
					EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
							"running `eblob_merge` on '%s' should help:", bctl-&gt;name);
					EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
							"http://doc.reverbrain.com/kb:eblob:eb0001-index-corruption");
					goto err_out_drop_tree;
				}
				offset += sizeof(struct eblob_disk_control);
				continue;
			}
			if (prev_filled) {
				int cmp = eblob_id_cmp(prev.key.id, dc.key.id);
				if (cmp &gt; 0) {
					char prev_str[256];
					char cur_str[256];
					err = -ECHRNG;
					eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob_index_blocks_fill: order mismatch: "
						"index: %d, "
						"prev: index position: %llu, %s, current index position: %llu, %s, check-error: %d: "
						"you have to remove sorted index and regenerate it from data using `eblob_to_index` tool "
						"on '%s'\n",
						bctl-&gt;index,
						(unsigned long long)prev_offset, eblob_dump_dc(&amp;prev, prev_str, sizeof(prev_str)),
						(unsigned long long)offset, eblob_dump_dc(&amp;dc, cur_str, sizeof(cur_str)),
						err, bctl-&gt;name);
					goto err_out_drop_tree;
				}
			}
			prev = dc;
			prev_offset = offset;
			prev_filled = 1;
			if (i == 0)
				block-&gt;start_key = dc.key;
			if (dc.flags &amp; eblob_bswap64(BLOB_DISK_CTL_REMOVE)) {
				removed++;
				removed_size += dc.disk_size + sizeof(struct eblob_disk_control);
			} else {
				eblob_bloom_set(bctl, &amp;dc.key);
			}
			offset += sizeof(struct eblob_disk_control);
		}
		block-&gt;end_offset = offset;
		block-&gt;end_key = dc.key;
	}
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_RECORDS_REMOVED, removed);
	eblob_stat_set(bctl-&gt;stat, EBLOB_LST_REMOVED_SIZE, removed_size);
	return 0;
err_out_drop_tree:
	eblob_index_blocks_destroy(bctl);
err_out_exit:
	return err;
}
static int eblob_find_on_disk(struct eblob_backend *b,
		struct eblob_base_ctl *bctl, struct eblob_disk_control *dc, uint64_t *hdr_offset,
		int (* callback)(struct eblob_disk_control *sorted, struct eblob_disk_control *dc),
		struct eblob_disk_search_stat *st)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.lookup.one", b-&gt;cfg.stat_id));
	struct eblob_disk_control *sorted, *end, *sorted_orig, *found = NULL;
	struct eblob_disk_control *hdr_block, *search_start, *search_end;
	struct eblob_index_block *block;
	size_t num;
	ssize_t hdr_block_size;
	uint64_t hdr_block_offset, saved_hdr_block_offset;
	const size_t hdr_size = sizeof(struct eblob_disk_control);
	int read_err, err = -ENOENT;
	st-&gt;search_on_disk++;
	pthread_rwlock_rdlock(&amp;bctl-&gt;index_blocks_lock);
	block = eblob_index_blocks_search_nolock(bctl, dc, st);
	if (block) {
		assert((bctl-&gt;index_ctl.size - block-&gt;start_offset) / hdr_size &gt; 0);
		assert((bctl-&gt;index_ctl.size - block-&gt;start_offset) % hdr_size == 0);
		num = (bctl-&gt;index_ctl.size - block-&gt;start_offset) / hdr_size;
		if (num &gt; b-&gt;cfg.index_block_size)
			num = b-&gt;cfg.index_block_size;
		hdr_block_size = num * hdr_size;
		saved_hdr_block_offset = hdr_block_offset = block-&gt;start_offset;
	} else {
		pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
		goto err_out_exit;
	}
	pthread_rwlock_unlock(&amp;bctl-&gt;index_blocks_lock);
<a name="4"></a>
	st-&gt;bsearch_reached++;
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	hdr_block = malloc(hdr_block_size);
	if (!hdr_block) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
	if (read_err &lt; 0) {
		err = read_err;
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
				", block_size: %zu, blob_size: %" PRIu64
				", num: %zu, FAILED: %s: %d.\n",
			  eblob_dump_id(dc-&gt;key.id),
			  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
			  bctl-&gt;index_ctl.size, num, strerror(-err), err);
		goto err_out_free_index;
	}</b></font>
	search_start = hdr_block;
	search_end = search_start + (num - 1);
	sorted_orig = bsearch(dc, search_start, num, sizeof(struct eblob_disk_control), eblob_disk_control_sort);
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_SPAM, "%s: position: %" PRIu64 ", block_size: %zd, index_size: %" PRIu64 ", num: %zu\n",
			eblob_dump_id(dc-&gt;key.id),
			hdr_block_offset, hdr_block_size, bctl-&gt;index_ctl.size, num);
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_SPAM, "%s: bsearch range: start: %s, end: %s, num: %zd\n",
			eblob_dump_id(dc-&gt;key.id),
			eblob_dump_id(search_start-&gt;key.id),
			eblob_dump_id(search_end-&gt;key.id), num);
	if (!sorted_orig)
		goto err_out_free_index;
	st-&gt;bsearch_found++;
	sorted = sorted_orig;
	end = search_end;
	while (eblob_disk_control_sort(sorted, dc) == 0) {
		if (callback(sorted, dc)) {
			found = sorted;
			break;
		}
		st-&gt;additional_reads++;
		if (++sorted &gt; end) {
			hdr_block_offset += hdr_block_size;
			if (hdr_block_offset &gt;= bctl-&gt;index_ctl.size)
				break;
			num = (bctl-&gt;index_ctl.size - hdr_block_offset) / hdr_size;
			if (num &gt; b-&gt;cfg.index_block_size)
				num = b-&gt;cfg.index_block_size;
			hdr_block_size = num * hdr_size;
			sorted = hdr_block;
			end = sorted + (num - 1);
			read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
			if (read_err &lt; 0) {
				err = read_err;
				eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
						", block_size: %zd, blob_size: %" PRIu64 ", num: %zu, FAILED: %s: %d.\n",
					  eblob_dump_id(dc-&gt;key.id),
					  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
					  bctl-&gt;index_ctl.size, num, strerror(-err), err);
				break;
			}
		}
	}
	if (found) {
		err = 0;
		memcpy(dc, found, hdr_size);
		*hdr_offset = hdr_block_offset + ((void *)found - (void *)hdr_block);
		goto err_out_free_index;
	}
	hdr_block_offset = saved_hdr_block_offset + hdr_block_size;
	sorted = hdr_block - 1;
	while (1) {
	    if (sorted &gt;= hdr_block) {
		st-&gt;additional_reads++;
		if (eblob_disk_control_sort(sorted, dc))
			break;
		if (callback(sorted, dc)) {
			found = sorted;
			break;
		}
		sorted--;
	    } else {
		if (!hdr_block_offset)
			break;
		if (hdr_block_offset &lt; (uint64_t)hdr_block_size) {
			hdr_block_size = hdr_block_offset;
			num = hdr_block_size / hdr_size;
			hdr_block_offset = 0;
		} else {
			hdr_block_offset -= hdr_block_size;
		}
		read_err = __eblob_read_ll(bctl-&gt;index_ctl.fd, hdr_block, hdr_block_size, hdr_block_offset);
		if (read_err &lt; 0) {
			err = read_err;
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: index: %d, position: %" PRIu64
					", block_size: %zd, blob_size: %" PRIu64 ", num: %zu, FAILED: %s: %d.\n",
				  eblob_dump_id(dc-&gt;key.id),
				  bctl-&gt;index_ctl.fd, hdr_block_offset, hdr_block_size,
				  bctl-&gt;index_ctl.size, num, strerror(-err), err);
			break;
		}
		if (hdr_block_offset == saved_hdr_block_offset) {
			sorted = sorted_orig - 1;
		} else {
			sorted = hdr_block + (num - 1);
		}
	    }
	}
	if (found) {
		err = 0;
		memcpy(dc, found, hdr_size);
		*hdr_offset = hdr_block_offset + ((void *)found - (void *)hdr_block);
		goto err_out_free_index;
	}
err_out_free_index:
	free(hdr_block);
err_out_exit:
	return err;
}
ssize_t eblob_get_actual_size(int fd)
{
	struct stat st;
	ssize_t err;
	err = fstat(fd, &amp;st);
	if (err &lt; 0)
		return err;
	return st.st_size;
}
static int indexsort_binlog_start(struct eblob_backend *b, struct eblob_base_ctl *bctl) {
	int err = 0;
	pthread_mutex_lock(&amp;b-&gt;lock);
	eblob_base_wait_locked(bctl);
	err = eblob_binlog_start(&amp;bctl-&gt;binlog);
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
	pthread_mutex_unlock(&amp;b-&gt;lock);
	return err;
}
static int indexsort_binlog_apply(struct eblob_base_ctl *bctl, void *sorted_index, ssize_t index_size) {
	const struct eblob_binlog_entry *it = NULL;
	const struct eblob_binlog_cfg * const bcfg = &amp;bctl-&gt;binlog;
	static const size_t hdr_size = sizeof(struct eblob_disk_control);
	struct eblob_disk_control *dc;
	int err = 0;
	while ((it = eblob_binlog_iterate(bcfg, it)) != NULL) {
		const uint64_t index = sorted_index_bsearch_raw(&amp;it-&gt;key,
				sorted_index,
				index_size / sizeof(struct eblob_disk_control));
		if (index == -1ULL) {
			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: skipped",
						eblob_dump_id(it-&gt;key.id));
			continue;
		}
		dc = sorted_index + index * hdr_size;
		while (((void*)dc &lt; sorted_index + index_size) &amp;&amp; (eblob_id_cmp(it-&gt;key.id, dc-&gt;key.id) == 0)) {
			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: indexsort: removing: dc: flags: %s, data_size: %" PRIu64,
			            eblob_dump_id(dc-&gt;key.id), eblob_dump_dctl_flags(dc-&gt;flags), dc-&gt;data_size);
			dc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
			EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: indexsort: removing: fd: %d, offset: %" PRIu64,
			            eblob_dump_id(it-&gt;key.id), bctl-&gt;data_ctl.fd, dc-&gt;position);
			err = eblob_mark_index_removed(bctl-&gt;data_ctl.fd, dc-&gt;position);
			if (err != 0) {
				EBLOB_WARNX(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
						"%s: indexsort: eblob_mark_index_removed: FAILED: data, fd: %d, err: %d",
						eblob_dump_id(it-&gt;key.id), bctl-&gt;data_ctl.fd, err);
				goto err_out_exit;
			}
			dc += 1;
		}
	}
err_out_exit:
	return err;
}
static int indexsort_flush_cache(struct eblob_backend *b, void *sorted_index, uint64_t index_size) {
	int err = 0;
	static const size_t hdr_size = sizeof(struct eblob_disk_control);
	uint64_t offset;
	if (b-&gt;cfg.blob_flags &amp; EBLOB_L2HASH) {
		err = eblob_l2hash_empty(&amp;b-&gt;l2hash);
	} else {
		err = eblob_hash_empty(&amp;b-&gt;hash);
	}
	if (err) {
		return 0;
	}
	for (offset = 0; offset &lt; index_size; offset += hdr_size) {
		struct eblob_disk_control *dc = sorted_index + offset;
		if (dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)
			continue;
		err = eblob_cache_remove_nolock(b, &amp;dc-&gt;key);
		if (err) {
			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_DEBUG, -err,
			            "indexsort: eblob_hash_remove_nolock: %s, offset: %" PRIu64,
			            eblob_dump_id(dc-&gt;key.id), offset);
		}
	}
	return 0;
}
int eblob_generate_sorted_index(struct eblob_backend *b, struct eblob_base_ctl *bctl) {
	int fd, old_fd, err, len;
	char *file, *dst_file;
	ssize_t index_size;
	void *sorted_index;
	if (b == NULL || bctl == NULL)
		return -EINVAL;
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "defrag: indexsort: sorting: %s, index: %d",
			bctl-&gt;name, bctl-&gt;index);
<a name="3"></a>
	len = strlen(b-&gt;cfg.file) + sizeof(".index") + sizeof(".sorted") + 256;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	file = malloc(len);
	if (!file) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	dst_file = malloc(len);
	if (!dst_file) {
		err = -ENOMEM;
		goto err_out_free_file;
	}</b></font>
	snprintf(file, len, "%s-0.%d.index.tmp", b-&gt;cfg.file, bctl-&gt;index);
	snprintf(dst_file, len, "%s-0.%d.index.sorted", b-&gt;cfg.file, bctl-&gt;index);
	err = access(dst_file, R_OK);
	if (!err) {
		err = 0;
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: %d: sorted index already exists\n",
				bctl-&gt;index);
		goto err_out_free_dst_file;
	}
	fd = open(file, O_RDWR | O_TRUNC | O_CREAT | O_CLOEXEC, 0644);
	if (fd &lt; 0) {
		err = -errno;
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: open: index: %d: %s",
				bctl-&gt;index, file);
		goto err_out_free_dst_file;
	}
	index_size = eblob_get_actual_size(bctl-&gt;index_ctl.fd);
	if (index_size &lt;= 0) {
		err = index_size ? -errno : 0;
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: actual-size: index: %d: %s",
				bctl-&gt;index, file);
		goto err_out_close;
	}
	err = eblob_preallocate(fd, 0, index_size);
	if (err) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: eblob_preallocate: index: %d, offset: %llu: %s",
				bctl-&gt;index, (unsigned long long)index_size, file);
		goto err_out_close;
	}
	sorted_index = malloc(index_size);
	if (!sorted_index) {
		err = -ENOMEM;
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: malloc: index: %d, size: %llu: %s",
				bctl-&gt;index, (unsigned long long)index_size, file);
		goto err_out_close;
	}
	err = indexsort_binlog_start(b, bctl);
	if (err != 0) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_binlog_start: index: %d",
			    bctl-&gt;index);
		goto err_out_free_index;
	}
	err = __eblob_read_ll(bctl-&gt;index_ctl.fd, sorted_index, index_size, 0);
	if (err) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: read: index: %d, size: %llu: %s",
					bctl-&gt;index, (unsigned long long)index_size, file);
		goto err_out_stop_binlog;
	}
	qsort(sorted_index, index_size / sizeof(struct eblob_disk_control), sizeof(struct eblob_disk_control),
			eblob_disk_control_sort_with_flags);
	pthread_mutex_lock(&amp;b-&gt;lock);
	eblob_base_wait_locked(bctl);
	old_fd = bctl-&gt;index_ctl.fd;
	if ((err = pthread_rwlock_wrlock(&amp;b-&gt;hash.root_lock)) != 0) {
		err = -err;
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: pthread_rwlock_wrlock: index: %d: FAILED",
				bctl-&gt;index);
		goto err_unlock_bctl;
	}
	err = indexsort_binlog_apply(bctl, sorted_index, index_size);
	if (err != 0) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_binlog_apply: index: %d: FAILED",
			    bctl-&gt;index);
		goto err_unlock_hash;
	}
	err = __eblob_write_ll(fd, sorted_index, index_size, 0);
	if (err) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: write after binlog apply: index: %d, size: %llu: %s",
			    bctl-&gt;index, (unsigned long long)index_size, file);
		goto err_unlock_hash;
	}
	err = fsync(fd);
	if (err == -1) {
		err = -errno;
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: fsync after binlog apply: index: %d, size: %llu: %s",
			    bctl-&gt;index, (unsigned long long)index_size, file);
		goto err_unlock_hash;
	}
	err = indexsort_flush_cache(b, sorted_index, index_size);
	if (err) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: indexsort_flush_cache: index: %d: FAILED",
			    bctl-&gt;index);
<a name="2"></a>		goto err_unlock_hash;
	}
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	bctl-&gt;index_ctl.fd = fd;
	bctl-&gt;index_ctl.offset = 0;
	bctl-&gt;index_ctl.size = index_size;
	err = eblob_index_blocks_fill(bctl);
	if (err) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: indexsort: eblob_index_blocks_fill: index: %d: FAILED",
				bctl-&gt;index);
		goto err_unlock_hash;
	}
	rename(file, dst_file);
	err = eblob_binlog_stop(&amp;bctl-&gt;binlog);
	if (err != 0) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err, "defrag: eblob_binlog_stop: index: %d: FAILED",
				bctl-&gt;index);
		goto err_unlock_hash;
	}</b></font>
	bctl-&gt;index_ctl.sorted = 1;
	b-&gt;defrag_generation += 1;
	pthread_rwlock_unlock(&amp;b-&gt;hash.root_lock);
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
	pthread_mutex_unlock(&amp;b-&gt;lock);
	snprintf(file, len, "%s-0.%d.index", b-&gt;cfg.file, bctl-&gt;index);
	unlink(file);
	close(old_fd);
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: generated sorted: index: %d, "
			"index-size: %llu, data-size: %" PRIu64 ", file: %s\n",
			bctl-&gt;index, (unsigned long long)index_size, bctl-&gt;data_ctl.offset, dst_file);
	free(sorted_index);
	free(file);
	free(dst_file);
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "defrag: indexsort: success\n");
	return 0;
err_unlock_hash:
	pthread_rwlock_unlock(&amp;b-&gt;hash.root_lock);
err_unlock_bctl:
	bctl-&gt;index_ctl.fd = old_fd;
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
	pthread_mutex_unlock(&amp;b-&gt;lock);
err_out_stop_binlog:
	(void)eblob_binlog_stop(&amp;bctl-&gt;binlog);
err_out_free_index:
	free(sorted_index);
err_out_close:
	unlink(file);
	close(fd);
err_out_free_dst_file:
	free(dst_file);
err_out_free_file:
	free(file);
err_out_exit:
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "defrag: indexsort: FAILED\n");
	return err;
}
static char *eblob_dump_search_stat(const struct eblob_disk_search_stat *st, int err)
{
	static __thread char ss[1024];
	snprintf(ss, sizeof(ss), "bctls: %d, no-sorted-index: %d, search-on-disk: %d, bloom-no-key: %d, "
			"found-index-block: %d, no-index-block: %d, bsearch-reached: %d, bsearch-found: %d, "
			"additional-reads: %d, err: %d",
			 st-&gt;loops, st-&gt;no_sort, st-&gt;search_on_disk, st-&gt;bloom_null,
			 st-&gt;found_index_block, st-&gt;no_block, st-&gt;bsearch_reached, st-&gt;bsearch_found,
			 st-&gt;additional_reads, err);
	return ss;
}
int eblob_disk_index_lookup(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_ram_control *rctl)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.lookup", b-&gt;cfg.stat_id));
	struct eblob_base_ctl *bctl;
	struct eblob_disk_control dc = { .key = *key, };
	struct eblob_disk_search_stat st = { .bloom_null = 0, };
	static const int max_tries = 10;
	int err = -ENOENT, tries = 0;
	uint64_t hdr_offset = 0;
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: %s: index: disk.\n", eblob_dump_id(key-&gt;id));
again:
	list_for_each_entry_reverse(bctl, &amp;b-&gt;bases, base_entry) {
		++st.loops;
		eblob_bctl_hold(bctl);
		if (bctl-&gt;index_ctl.fd &lt; 0) {
			eblob_bctl_release(bctl);
			if (tries++ &gt; max_tries)
				return -EDEADLK;
			goto again;
		}
		if (!bctl-&gt;index_ctl.sorted) {
			st.no_sort++;
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
					"blob: %s: index: disk: index: %d: no sorted index\n",
					eblob_dump_id(key-&gt;id), bctl-&gt;index);
			eblob_bctl_release(bctl);
			continue;
		}
		err = eblob_find_on_disk(b, bctl, &amp;dc, &amp;hdr_offset, eblob_find_non_removed_callback, &amp;st);
		if (err) {
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
					"blob: %s: index: disk: index: %d: NO DATA\n",
					eblob_dump_id(key-&gt;id), bctl-&gt;index);
			eblob_bctl_release(bctl);
			continue;
		}
		eblob_convert_disk_control(&amp;dc);
		memset(rctl, 0, sizeof(*rctl));
		rctl-&gt;data_offset = dc.position;
		rctl-&gt;index_offset = hdr_offset;
		rctl-&gt;size = dc.data_size;
		rctl-&gt;bctl = bctl;
		eblob_bctl_release(bctl);
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE, eblob_dump_id(key-&gt;id),
				"blob: %s: index: %d, position: %" PRIu64
				", data_size: %" PRIu64 ": %s\n", eblob_dump_id(key-&gt;id),
				rctl-&gt;bctl-&gt;index, rctl-&gt;data_offset, rctl-&gt;size, eblob_dump_search_stat(&amp;st, 0));
		break;
	}
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "blob: %s: stat: %s\n", eblob_dump_id(key-&gt;id), eblob_dump_search_stat(&amp;st, err));
	eblob_stat_add(b-&gt;stat, EBLOB_GST_INDEX_READS, st.loops);
	return err;
}
uint64_t sorted_index_bsearch_raw(const struct eblob_key *key,
                                  const struct eblob_disk_control *base, uint64_t nel) {
	const struct eblob_disk_control dc = { .key = *key };
	const struct eblob_disk_control * const found =
		bsearch(&amp;dc, base, nel, sizeof(dc), eblob_disk_control_sort);
	uint64_t index = -1;
	if (found != NULL)
		index = found - base;
	return index;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>blob.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "features.h"
#include "blob.h"
#include "crypto/sha512.h"
#include "footer.h"
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/statvfs.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;libgen.h&gt;
#include &lt;limits.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include "measure_points.h"
#define DIFF(s, e) ((e).tv_sec - (s).tv_sec) * 1000000 + ((e).tv_usec - (s).tv_usec)
struct eblob_iterate_priv {
	struct eblob_iterate_control *ctl;
	void *thread_priv;
};
struct eblob_iterate_local {
	struct eblob_iterate_priv	*iter_priv;
	struct eblob_disk_control	*dc, *last_valid_dc;
	int				num, pos;
	long long			index_offset, last_valid_offset;
};
int eblob_mutex_init(pthread_mutex_t *mutex)
{
<a name="4"></a>	pthread_mutexattr_t attr;
	int err;
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	err = pthread_mutexattr_init(&amp;attr);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
#ifdef PTHREAD_MUTEX_ADAPTIVE_NP
	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ADAPTIVE_NP);
#else
	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);
#endif
	err = pthread_mutex_init(mutex, &amp;attr);
	if (err) {
		err = -err;
		goto err_out_destroy;
	}</b></font>
err_out_destroy:
	pthread_mutexattr_destroy(&amp;attr);
err_out_exit:
	return err;
}
int eblob_cond_init(pthread_cond_t *cond)
{
	int err;
	err = pthread_cond_init(cond, NULL);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
err_out_exit:
	return err;
}
int eblob_event_init(struct eblob_event *event)
{
	int err;
	err = eblob_mutex_init(&amp;event-&gt;lock);
	if (err != 0)
		goto err_out_exit;
	err = eblob_cond_init(&amp;event-&gt;cond);
	if (err != 0)
		goto err_out_exit;
	err = eblob_event_reset(event);
	if (err != 0)
		goto err_out_exit;
err_out_exit:
	return err;
}
int eblob_event_destroy(struct eblob_event *event)
<a name="3"></a>{
	int err;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	err = pthread_cond_destroy(&amp;event-&gt;cond);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
	err = pthread_mutex_destroy(&amp;event-&gt;lock);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}</b></font>
err_out_exit:
	return err;
}
int eblob_event_get(struct eblob_event *event)
{
	return event-&gt;data;
}
int eblob_event_set(struct eblob_event *event)
{
	int err;
	err = pthread_mutex_lock(&amp;event-&gt;lock);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
	event-&gt;data = 1;
	err = pthread_cond_broadcast(&amp;event-&gt;cond);
	if (err != 0) {
		err = -err;
		goto err_out_unlock;
	}
err_out_unlock:
	pthread_mutex_unlock(&amp;event-&gt;lock);
err_out_exit:
	return err;
}
int eblob_event_reset(struct eblob_event *event)
{
	int err;
	err = pthread_mutex_lock(&amp;event-&gt;lock);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
	event-&gt;data = 0;
	pthread_mutex_unlock(&amp;event-&gt;lock);
err_out_exit:
	return err;
}
int eblob_event_wait(struct eblob_event *event, long timeout)
{
	int err;
	struct timespec end_time;
	clock_gettime(CLOCK_REALTIME, &amp;end_time);
	if (end_time.tv_sec + timeout &lt; end_time.tv_sec)
		end_time.tv_sec = LONG_MAX;
	else
		end_time.tv_sec += timeout;
	err = pthread_mutex_lock(&amp;event-&gt;lock);
	if (err != 0) {
		err = -err;
		goto err_out_exit;
	}
	while (event-&gt;data == 0) {
		err = pthread_cond_timedwait(&amp;event-&gt;cond, &amp;event-&gt;lock, &amp;end_time);
		if (err != 0) {
			err = -err;
			goto err_out_unlock;
		}
	}
err_out_unlock:
	pthread_mutex_unlock(&amp;event-&gt;lock);
err_out_exit:
	return err;
}
void eblob_base_wait_locked(struct eblob_base_ctl *bctl)
{
	assert(bctl != NULL);
	pthread_mutex_lock(&amp;bctl-&gt;lock);
	while (bctl-&gt;critness != 0) {
		pthread_cond_wait(&amp;bctl-&gt;critness_wait, &amp;bctl-&gt;lock);
	}
}
void eblob_base_wait(struct eblob_base_ctl *bctl)
{
	eblob_base_wait_locked(bctl);
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
}
void eblob_bctl_hold(struct eblob_base_ctl *bctl)
{
	assert(bctl != NULL);
	assert(bctl-&gt;critness &gt;= 0);
	pthread_mutex_lock(&amp;bctl-&gt;lock);
	bctl-&gt;critness++;
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
}
void eblob_bctl_release(struct eblob_base_ctl *bctl)
{
	assert(bctl != NULL);
	assert(bctl-&gt;critness &gt; 0);
	pthread_mutex_lock(&amp;bctl-&gt;lock);
	bctl-&gt;critness--;
	if (bctl-&gt;critness == 0)
		pthread_cond_broadcast(&amp;bctl-&gt;critness_wait);
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
}
inline static uint64_t eblob_validate_ctl_flags(struct eblob_backend *b, uint64_t flags) {
	if (b-&gt;cfg.blob_flags &amp; EBLOB_NO_FOOTER)
		flags |= BLOB_DISK_CTL_NOCSUM;
	flags |= BLOB_DISK_CTL_CHUNKED_CSUM;
	return flags;
}
static int eblob_writev_raw(struct eblob_key *key, struct eblob_write_control *wc,
		const struct eblob_iovec *iov, uint16_t iovcnt)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.raw", wc-&gt;bctl-&gt;back-&gt;cfg.stat_id));
	const uint64_t offset_min = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control);
	const uint64_t offset_max = wc-&gt;ctl_data_offset + wc-&gt;total_size;
	const struct eblob_iovec *tmp;
	int err = -EFAULT;
	assert(wc != NULL);
	assert(wc-&gt;bctl != NULL);
	assert(key != NULL);
	assert(iov != NULL);
	if ((wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)
			&amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)) {
		if (wc-&gt;total_data_size &lt; iov-&gt;size)
			return -ERANGE;
		wc-&gt;data_offset -= iov-&gt;size;
		wc-&gt;total_data_size -= iov-&gt;size;
	}
	for (tmp = iov; tmp &lt; iov + iovcnt; ++tmp) {
		uint64_t offset = wc-&gt;data_offset + tmp-&gt;offset;
		if ((tmp == iov) &amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR))
			offset = offset_min;
		EBLOB_WARNX(wc-&gt;bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_DEBUG, "%s: writev: fd: %d"
				", iov_size: %" PRIu64 ", iov_offset: %" PRIu64
				", offset: %" PRIu64, eblob_dump_id(key-&gt;id),
				wc-&gt;bctl-&gt;data_ctl.fd, tmp-&gt;size, tmp-&gt;offset, offset);
		if (offset + tmp-&gt;size &gt; offset_max || offset &lt; offset_min) {
			err = -ERANGE;
			goto err_exit;
		}
		err = __eblob_write_ll(wc-&gt;bctl-&gt;data_ctl.fd, tmp-&gt;base, tmp-&gt;size, offset);
		if (err != 0)
			goto err_exit;
	}
err_exit:
	return err;
}
char *eblob_dump_dc(const struct eblob_disk_control *dc, char *buffer, size_t size)
{
	char key_str[2 * EBLOB_ID_SIZE + 1];
	eblob_dump_id_len_raw(dc-&gt;key.id, EBLOB_ID_SIZE, key_str);
	snprintf(buffer, size, "key: %s, position: %llu, data size: %llu, disk size: %llu, flags: %s",
		key_str,
		(unsigned long long)dc-&gt;position,
		(unsigned long long)dc-&gt;data_size, (unsigned long long)dc-&gt;disk_size,
		eblob_dump_dctl_flags(dc-&gt;flags));
	return buffer;
}
static void eblob_dump_wc_raw(struct eblob_backend *b, int log_level, struct eblob_key *key, struct eblob_write_control *wc, const char *str, int err) {
	eblob_log(b-&gt;cfg.log, log_level, "blob: %s: i%d: %s: position: %" PRIu64 ", "
			"offset: %" PRIu64 ", size: %" PRIu64 ", flags: %s, "
			"total data size: %" PRIu64 ", disk-size: %" PRIu64 ", "
			"data_fd: %d, index_fd: %d, bctl: %p: %d\n",
			eblob_dump_id(key-&gt;id), wc-&gt;index, str, wc-&gt;ctl_data_offset,
			wc-&gt;offset, wc-&gt;size, eblob_dump_dctl_flags(wc-&gt;flags), wc-&gt;total_data_size, wc-&gt;total_size,
			wc-&gt;data_fd, wc-&gt;index_fd, wc-&gt;bctl, err);
}
static void eblob_dump_wc(struct eblob_backend *b, struct eblob_key *key, struct eblob_write_control *wc, const char *str, int err)
{
	int log_level = EBLOB_LOG_NOTICE;
	if (err &lt; 0)
		log_level = EBLOB_LOG_ERROR;
	eblob_dump_wc_raw(b, log_level, key, wc, str, err);
}
static void eblob_rctl_to_wc(const struct eblob_ram_control *rctl, struct eblob_write_control *wc)
{
	wc-&gt;data_fd = rctl-&gt;bctl-&gt;data_ctl.fd;
	wc-&gt;index_fd = rctl-&gt;bctl-&gt;index_ctl.fd;
	wc-&gt;index = rctl-&gt;bctl-&gt;index;
	wc-&gt;ctl_index_offset = rctl-&gt;index_offset;
	wc-&gt;ctl_data_offset = rctl-&gt;data_offset;
	wc-&gt;data_offset = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control) + wc-&gt;offset;
	wc-&gt;bctl = rctl-&gt;bctl;
}
static void eblob_dc_to_wc(const struct eblob_disk_control *dc, struct eblob_write_control *wc)
{
	wc-&gt;flags = dc-&gt;flags;
	wc-&gt;total_size = dc-&gt;disk_size;
	if (dc-&gt;data_size &lt; wc-&gt;offset + wc-&gt;size)
		wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
	else
		wc-&gt;total_data_size = dc-&gt;data_size;
	if (!wc-&gt;size)
		wc-&gt;size = dc-&gt;data_size;
}
static int eblob_index_data_mismatch(const struct eblob_base_ctl *bctl,
		const struct eblob_disk_control *index_dc,
		const struct eblob_disk_control *data_dc)
{
	if (memcmp(data_dc, index_dc, sizeof(struct eblob_disk_control))) {
		char data_str[512];
		char index_str[512];
		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR, "blob i%d: eblob_index_data_equal: index/data headers mismatch: "
			"data header: %s, index header: %s"
			" you have to remove sorted index and regenerate it from data using `eblob_to_index` tool on '%s'\n",
			bctl-&gt;index,
			eblob_dump_dc(data_dc, data_str, sizeof(data_str)),
			eblob_dump_dc(index_dc, index_str, sizeof(index_str)),
			bctl-&gt;name);
		return 1;
	}
	return 0;
}
int eblob_check_record(const struct eblob_base_ctl *bctl,
		const struct eblob_disk_control *dc)
{
	const uint64_t hdr_size = sizeof(struct eblob_disk_control);
	assert(dc != NULL);
	assert(bctl != NULL);
	assert(bctl-&gt;back != NULL);
	const uint64_t bctl_size = bctl-&gt;data_ctl.size &gt; bctl-&gt;data_ctl.offset ?
		bctl-&gt;data_ctl.size : bctl-&gt;data_ctl.offset;
	if (dc-&gt;disk_size &lt; dc-&gt;data_size + hdr_size) {
		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob i%d: %s: malformed entry: disk_size is less than data_size + hdr_size: "
				"pos: %" PRIu64 ", data_size: %" PRIu64 ", disk_size: %" PRIu64 "\n",
				bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), dc-&gt;position, dc-&gt;data_size, dc-&gt;disk_size);
		if (dc-&gt;disk_size == 0 &amp;&amp; dc-&gt;data_size == 0) {
			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
					"blob i%d: %s: zero-sized entry: key: %s, pos: %" PRIu64 "\n",
					bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), eblob_dump_id(dc-&gt;key.id), dc-&gt;position);
			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
					"blob i%d: %s: running `eblob_merge` on '%s' should help\n",
					bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), bctl-&gt;name);
		} else {
			return -ESPIPE;
		}
	}
	if (dc-&gt;position + dc-&gt;disk_size &gt; bctl_size) {
		eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob i%d: %s: malformed entry: position + disk_size is outside of blob: "
				"pos: %" PRIu64 ", disk_size: %" PRIu64 ", bctl_size: %" PRIu64 "\n",
				bctl-&gt;index, eblob_dump_id(dc-&gt;key.id), dc-&gt;position, dc-&gt;disk_size, bctl_size);
		return -ESPIPE;
	}
	if (!(dc-&gt;flags &amp; BLOB_DISK_CTL_NOCSUM)) {
		long footer_min_size = sizeof(struct eblob_disk_footer);
		if (dc-&gt;flags &amp; BLOB_DISK_CTL_CHUNKED_CSUM) {
			footer_min_size = 0;
			if (dc-&gt;data_size)
				footer_min_size = ((dc-&gt;data_size - 1) / EBLOB_CSUM_CHUNK_SIZE + 1) * sizeof(uint64_t);
		}
		if (dc-&gt;disk_size &lt; dc-&gt;data_size + footer_min_size) {
			char dc_str[256];
			eblob_log(bctl-&gt;back-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob i%d: malformed entry: disk_size is too small to fit data+checksum "
				"and there is no no-checksum bit: %s, min-footer-size: %ld\n",
				bctl-&gt;index, eblob_dump_dc(dc, dc_str, sizeof(dc_str)), footer_min_size);
			return -ESPIPE;
		}
	}
	return 0;
}
static int eblob_check_disk_one(struct eblob_iterate_local *loc)
{
	struct eblob_iterate_priv *iter_priv = loc-&gt;iter_priv;
	struct eblob_iterate_control *ctl = iter_priv-&gt;ctl;
	struct eblob_base_ctl *bc = ctl-&gt;base;
	struct eblob_disk_control *dc = &amp;loc-&gt;dc[loc-&gt;pos];
	struct eblob_disk_control dc_data;
	struct eblob_ram_control rc;
	int err;
	if (bc-&gt;data_ctl.size == 0)
		return -EAGAIN;
	memset(&amp;rc, 0, sizeof(rc));
	eblob_convert_disk_control(dc);
	err = eblob_check_record(bc, dc);
	if (err != 0) {
		eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
				"blob: eblob_check_record: offset: %llu\n",
				loc-&gt;index_offset);
		goto err_out_exit;
	}
	loc-&gt;last_valid_offset = loc-&gt;index_offset;
	loc-&gt;last_valid_dc = dc;
	rc.index_offset = loc-&gt;index_offset;
	rc.data_offset = dc-&gt;position;
	rc.size = dc-&gt;data_size;
	rc.bctl = bc;
	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL)
			&amp;&amp; !(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_READONLY)
			&amp;&amp; !(dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)) {
		err = __eblob_read_ll(bc-&gt;data_ctl.fd, &amp;dc_data, sizeof(struct eblob_disk_control), dc-&gt;position);
		if (err)
			goto err_out_exit;
		if (dc_data.flags &amp; BLOB_DISK_CTL_REMOVE) {
			eblob_log(ctl-&gt;log, EBLOB_LOG_INFO,
					"blob: %s: key removed(%s) in blob(%d), but not in index(%d), fixing\n",
					eblob_dump_id(dc-&gt;key.id), eblob_dump_dctl_flags(dc_data.flags), bc-&gt;data_ctl.fd, bc-&gt;index_ctl.fd);
			dc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
			err = __eblob_write_ll(bc-&gt;index_ctl.fd, dc,
					sizeof(struct eblob_disk_control), loc-&gt;index_offset);
			if (err)
				goto err_out_exit;
		}
	}
	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_VERIFY_CHECKSUM) &amp;&amp;
	    !(dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) &amp;&amp;
	    !(dc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
		struct eblob_write_control wc;
		memset(&amp;wc, 0, sizeof(wc));
		eblob_rctl_to_wc(&amp;rc, &amp;wc);
		eblob_dc_to_wc(dc, &amp;wc);
		err = eblob_verify_checksum(bc-&gt;back, &amp;dc-&gt;key, &amp;wc);
		if (err) {
			eblob_dump_wc(bc-&gt;back, &amp;dc-&gt;key, &amp;wc, "eblob_check_disk_one: checksum verification failed", err);
			err = 0;
			goto err_out_exit;
		}
	}
	eblob_log(ctl-&gt;log, EBLOB_LOG_DEBUG, "blob: %s: pos: %" PRIu64 ", disk_size: %" PRIu64
			", data_size: %" PRIu64 ", flags: %s\n",
			eblob_dump_id(dc-&gt;key.id), dc-&gt;position,
			dc-&gt;disk_size, dc-&gt;data_size, eblob_dump_dctl_flags(dc-&gt;flags));
	if ((ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_INITIAL_LOAD)
			&amp;&amp; (dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE)) {
		const int64_t record_size = dc-&gt;disk_size + sizeof(struct eblob_disk_control);
		eblob_stat_inc(bc-&gt;stat, EBLOB_LST_RECORDS_REMOVED);
		eblob_stat_add(bc-&gt;stat, EBLOB_LST_REMOVED_SIZE, record_size);
		eblob_stat_inc(ctl-&gt;b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
		eblob_stat_add(ctl-&gt;b-&gt;stat_summary, EBLOB_LST_REMOVED_SIZE, record_size);
	}
	if ((dc-&gt;flags &amp; BLOB_DISK_CTL_REMOVE) ||
			(bc-&gt;index_ctl.sorted &amp;&amp; !(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL))) {
		err = 0;
		goto err_out_exit;
	}
	err = ctl-&gt;iterator_cb.iterator(dc, &amp;rc, bc-&gt;data_ctl.fd, dc-&gt;position + sizeof(struct eblob_disk_control),
			ctl-&gt;priv, iter_priv-&gt;thread_priv);
err_out_exit:
	return err;
}
static int eblob_check_disk(struct eblob_iterate_local *loc)
{
	int err;
	for (loc-&gt;pos = 0; loc-&gt;pos &lt; loc-&gt;num; ++loc-&gt;pos) {
		err = eblob_check_disk_one(loc);
		if (err &lt; 0)
			return err;
		loc-&gt;index_offset += sizeof(struct eblob_disk_control);
	}
	return 0;
}
static int eblob_fill_range_offsets(struct eblob_base_ctl *bctl, struct eblob_iterate_control *ctl)
{
	int i;
	struct eblob_index_block *t;
	struct eblob_disk_search_stat st;
	struct eblob_disk_control local_dc;
	char start_key_str[2*EBLOB_ID_SIZE+1];
	char end_key_str[2*EBLOB_ID_SIZE+1];
	if (!bctl-&gt;index_ctl.sorted)
		return -1;
	if (ctl-&gt;range_num == 0)
		return -1;
	memset(&amp;st, 0, sizeof(struct eblob_disk_search_stat));
	memset(&amp;local_dc, 0, sizeof(struct eblob_disk_control));
	for (i = 0; i &lt; ctl-&gt;range_num; ++i) {
		struct eblob_index_block *range = &amp;ctl-&gt;range[i];
		local_dc.key = range-&gt;start_key;
		t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, &amp;local_dc, &amp;st);
		if (!t) {
			range-&gt;start_offset = 0;
		} else {
			range-&gt;start_offset = t-&gt;start_offset;
		}
		local_dc.key = range-&gt;end_key;
		t = eblob_index_blocks_search_nolock_bsearch_nobloom(bctl, &amp;local_dc, &amp;st);
		if (!t) {
			range-&gt;end_offset = ctl-&gt;index_size;
		} else {
			range-&gt;end_offset = t-&gt;end_offset;
		}
		eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "iterator-range: blob: index: %d, data-fd: %d, index-fd: %d, data-size: %" PRIu64
				", index-size: %" PRIu64 ", keys: %s..%s, index offsets: %llu..%llu\n",
				bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, bctl-&gt;data_ctl.size, bctl-&gt;index_ctl.size,
				eblob_dump_id_len_raw(range-&gt;start_key.id, EBLOB_ID_SIZE, start_key_str),
				eblob_dump_id_len_raw(range-&gt;end_key.id, EBLOB_ID_SIZE, end_key_str),
				(unsigned long long)range-&gt;start_offset,
				(unsigned long long)range-&gt;end_offset);
<a name="0"></a>	}
	ctl-&gt;index_offset = ctl-&gt;range[0].start_offset;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return 0;
}
static int eblob_key_range_compare(const void *k, const void *r) {
	const struct eblob_key *key = k;
	const struct eblob_index_block *range = r;</b></font>
	if (eblob_id_cmp(key-&gt;id, range-&gt;start_key.id) &lt; 0)
		return -1;
	if (eblob_id_cmp(key-&gt;id, range-&gt;end_key.id) &gt; 0)
		return 1;
	return 0;
}
static int eblob_local_ranges_check(struct eblob_iterate_control *ctl, int current_range_index, struct eblob_iterate_local *loc)
{
	int i, out_pos = 0, err, bases_num;
	struct eblob_disk_control *out;
	struct eblob_index_block *bases;
	if (current_range_index &lt; 0) {
		current_range_index = 0;
	}
	bases_num = ctl-&gt;range_num - current_range_index;
	if (bases_num &lt;= 0) {
		err = loc-&gt;num;
		goto err_out_exit;
	}
	bases = &amp;ctl-&gt;range[current_range_index];
	out = calloc(loc-&gt;num, sizeof(struct eblob_disk_control));
	if (!out) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	for (i = loc-&gt;pos; i &lt; loc-&gt;num; ++i) {
		struct eblob_disk_control *dc = &amp;loc-&gt;dc[i];
		if (bsearch(&amp;dc-&gt;key, bases, bases_num, sizeof(struct eblob_index_block), eblob_key_range_compare) != NULL) {
			out[out_pos++] = *dc;
		}
	}
	for (i = loc-&gt;pos; i &lt; out_pos; ++i) {
		loc-&gt;dc[i] = out[i];
	}
	loc-&gt;num = out_pos;
	free(out);
	err = out_pos;
err_out_exit:
	return err;
}
static int eblob_blob_iterator(struct eblob_iterate_priv *iter_priv)
{
	struct eblob_iterate_control *ctl = iter_priv-&gt;ctl;
	struct eblob_base_ctl *bctl = ctl-&gt;base;
	int batch_size = 1024;
	struct eblob_disk_control dc[batch_size];
	struct eblob_iterate_local loc;
	int err = 0;
	int current_range_index = -1;
	static const int hdr_size = sizeof(struct eblob_disk_control);
	memset(&amp;loc, 0, sizeof(loc));
	loc.iter_priv = iter_priv;
	pthread_mutex_lock(&amp;bctl-&gt;lock);
	current_range_index = eblob_fill_range_offsets(bctl, ctl);
	pthread_mutex_unlock(&amp;bctl-&gt;lock);
	while (ctl-&gt;index_offset &lt; ctl-&gt;index_size) {
		if (ctl-&gt;range_num &amp;&amp; current_range_index &gt;= 0) {
			struct eblob_index_block *range = &amp;ctl-&gt;range[current_range_index];
			if (ctl-&gt;index_offset &gt; range-&gt;end_offset) {
				while (1) {
					++current_range_index;
					if (current_range_index &gt;= ctl-&gt;range_num) {
						eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "blob: index: %d, iterator reached end of the requested range "
								"[%llu, %llu], index-offset: %llu: switching to the next blob\n",
								bctl-&gt;index, (unsigned long long)range-&gt;start_offset, (unsigned long long)range-&gt;end_offset,
								ctl-&gt;index_offset);
<a name="1"></a>						err = 0;
						goto err_out_check;
					} else {
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>						struct eblob_index_block *next = &amp;ctl-&gt;range[current_range_index];
						eblob_log(ctl-&gt;log, EBLOB_LOG_NOTICE, "blob: index: %d, iterator reached end of the requested ranges "
								"(last range: [%llu, %llu]), index-offset: %llu: switching to the next range [%llu, %llu]\n",
								bctl-&gt;index, (unsigned long long)range-&gt;start_offset, (unsigned long long)range-&gt;end_offset,
								ctl-&gt;index_offset, (unsigned long long)next-&gt;start_offset, (unsigned long long)next-&gt;end_offset);
						if (ctl-&gt;index_offset &gt; next-&gt;end_offset)</b></font>
							continue;
						ctl-&gt;index_offset = EBLOB_MAX(next-&gt;start_offset, ctl-&gt;index_offset);
						break;
					}
				}
			}
		}
		if (ctl-&gt;index_offset + hdr_size * batch_size &gt; ctl-&gt;index_size){
			batch_size = (ctl-&gt;index_size - ctl-&gt;index_offset) / hdr_size;
			if (batch_size == 0) {
				err = 0;
				goto err_out_check;
			}
		}
		pthread_mutex_lock(&amp;bctl-&gt;lock);
		err = __eblob_read_ll(bctl-&gt;index_ctl.fd, dc, batch_size * hdr_size, ctl-&gt;index_offset);
		if (err) {
			pthread_mutex_unlock(&amp;bctl-&gt;lock);
			goto err_out_check;
		}
		pthread_mutex_unlock(&amp;bctl-&gt;lock);
		if (ctl-&gt;index_offset + batch_size * hdr_size &gt; ctl-&gt;index_size) {
			eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: index grew under us, iteration stops: "
					"index_offset: %llu, index_size: %llu, eblob_data_size: %llu, batch_size: %d, "
					"index_offset+batch_size: %llu, but wanted less than index_size.\n",
					ctl-&gt;index_offset, ctl-&gt;index_size, ctl-&gt;data_size, batch_size,
					ctl-&gt;index_offset + batch_size * hdr_size);
			err = 0;
			goto err_out_check;
		}
		loc.index_offset = ctl-&gt;index_offset;
		loc.dc = dc;
		loc.pos = 0;
		loc.num = batch_size;
		ctl-&gt;index_offset += hdr_size * batch_size;
		err = eblob_local_ranges_check(ctl, current_range_index, &amp;loc);
		if (err &lt; 0)
			continue;
		if (err == 0)
			continue;
		eblob_bctl_hold(bctl);
		err = eblob_check_disk(&amp;loc);
		eblob_bctl_release(bctl);
		if (err)
			goto err_out_check;
	}
err_out_check:
	eblob_log(ctl-&gt;log, err &lt; 0 ? EBLOB_LOG_ERROR : EBLOB_LOG_INFO, "blob-0.%d: iterated: data_fd: %d, index_fd: %d, "
			"data_size: %llu, index_offset: %llu, err: %d\n",
			bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, ctl-&gt;data_size, ctl-&gt;index_offset, err);
	if (!(ctl-&gt;flags &amp; EBLOB_ITERATE_FLAGS_ALL)) {
		pthread_mutex_lock(&amp;bctl-&gt;lock);
		bctl-&gt;data_ctl.offset = bctl-&gt;data_ctl.size;
		bctl-&gt;index_ctl.size = ctl-&gt;index_offset;
		if (err &amp;&amp; !ctl-&gt;err) {
			if (loc.last_valid_dc != NULL) {
				struct eblob_disk_control data_dc;
				struct eblob_disk_control idc;
				idc = *loc.last_valid_dc;
				bctl-&gt;index_ctl.size = ctl-&gt;index_offset = loc.last_valid_offset;
				eblob_convert_disk_control(&amp;idc);
				err = __eblob_read_ll(bctl-&gt;data_ctl.fd, &amp;data_dc, hdr_size, idc.position);
				if (err) {
					memset(&amp;data_dc, 0, hdr_size);
					eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
							"blob: read failed: fd: %d, err: %d\n", bctl-&gt;data_ctl.fd, -err);
					ctl-&gt;err = err;
				}
				eblob_convert_disk_control(&amp;data_dc);
				bctl-&gt;data_ctl.offset = idc.position + data_dc.disk_size;
				eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: i%d: truncating eblob to: data_fd: %d, index_fd: %d, "
						"data_size(was): %llu, data_offset: %" PRIu64 ", "
						"data_position: %" PRIu64 ", disk_size: %" PRIu64 ", index_offset: %llu\n",
						bctl-&gt;index, bctl-&gt;data_ctl.fd, bctl-&gt;index_ctl.fd, ctl-&gt;data_size,
						bctl-&gt;data_ctl.offset, idc.position, idc.disk_size,
						ctl-&gt;index_offset);
				err = ftruncate(bctl-&gt;index_ctl.fd, ctl-&gt;index_offset);
				if (err == -1) {
					eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR,
							"blob: truncation failed: fd: %d, err: %d\n", bctl-&gt;index_ctl.fd, -errno);
					ctl-&gt;err = -errno;
				}
			}
		}
		pthread_mutex_unlock(&amp;bctl-&gt;lock);
	}
	if (ctl-&gt;err == 0 &amp;&amp; err != 0)
		ctl-&gt;err = err;
	return err;
}
int eblob_blob_iterate(struct eblob_iterate_control *ctl)
{
	int err;
	struct eblob_iterate_priv iter_priv;
	if (ctl-&gt;range_num) {
		qsort(ctl-&gt;range, ctl-&gt;range_num, sizeof(struct eblob_index_block), eblob_index_block_cmp);
	}
	eblob_base_wait_locked(ctl-&gt;base);
	err = eblob_base_setup_data(ctl-&gt;base, 0);
	if (err) {
		pthread_mutex_unlock(&amp;ctl-&gt;base-&gt;lock);
		ctl-&gt;err = err;
		goto err_out_exit;
	}
	ctl-&gt;index_offset = 0;
	ctl-&gt;data_size = ctl-&gt;base-&gt;data_ctl.size;
	ctl-&gt;index_size = ctl-&gt;base-&gt;index_ctl.size;
	pthread_mutex_unlock(&amp;ctl-&gt;base-&gt;lock);
	iter_priv.ctl = ctl;
	iter_priv.thread_priv = NULL;
	if (ctl-&gt;iterator_cb.iterator_init) {
		err = ctl-&gt;iterator_cb.iterator_init(ctl, &amp;iter_priv.thread_priv);
		if (err) {
			ctl-&gt;err = err;
			eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: failed to init iterator: %d.\n", err);
			goto err_out_exit;
		}
	}
	err = eblob_blob_iterator(&amp;iter_priv);
	if (err) {
		ctl-&gt;err = err;
		eblob_log(ctl-&gt;log, EBLOB_LOG_ERROR, "blob: iterator failed: %d.\n", err);
		goto err_out_exit;
	}
	if (ctl-&gt;iterator_cb.iterator_free)
		ctl-&gt;iterator_cb.iterator_free(ctl, &amp;iter_priv.thread_priv);
	if ((ctl-&gt;err == -ENOENT) &amp;&amp; eblob_total_elements(ctl-&gt;b))
		ctl-&gt;err = 0;
err_out_exit:
	return ctl-&gt;err;
}
int eblob_mark_index_removed(int fd, uint64_t offset)
{
	uint64_t flags = eblob_bswap64(BLOB_DISK_CTL_REMOVE);
	return __eblob_write_ll(fd, &amp;flags, sizeof(flags), offset + offsetof(struct eblob_disk_control, flags));
}
static int eblob_mark_entry_removed(struct eblob_backend *b,
		struct eblob_key *key, struct eblob_ram_control *old)
{
	int err;
	struct eblob_disk_control old_dc;
	int64_t record_size = 0;
	if (eblob_binlog_enabled(&amp;old-&gt;bctl-&gt;binlog)) {
		struct eblob_binlog_entry *entry;
		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: appending key to binlog",
				eblob_dump_id(key-&gt;id));
		entry = eblob_binlog_entry_new(key);
		if (entry == NULL) {
			err = -ENOMEM;
			goto err;
		}
		err = eblob_binlog_append(&amp;old-&gt;bctl-&gt;binlog, entry);
		if (err != 0) {
			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
					"%s: eblob_binlog_append: FAILED",
					eblob_dump_id(key-&gt;id));
			goto err;
		}
	}
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: index position: %" PRIu64 ", index_fd: %d, "
			"data position: %" PRIu64 ", data_fd: %d",
			eblob_dump_id(key-&gt;id), old-&gt;index_offset, old-&gt;bctl-&gt;index_ctl.fd,
			old-&gt;data_offset, old-&gt;bctl-&gt;data_ctl.fd);
	err = __eblob_read_ll(old-&gt;bctl-&gt;index_ctl.fd, &amp;old_dc, sizeof(old_dc), old-&gt;index_offset);
	if (err) {
		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR, "%s: __eblob_read_ll: FAILED: index, fd: %d, err: %d",
				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;index_ctl.fd, err);
		goto err;
	}
	if (memcmp(&amp;old_dc.key, key, sizeof(key)) != 0) {
		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR, "keys mismatch: in-memory: %s, on-disk: %s",
				eblob_dump_id_len(key-&gt;id, EBLOB_ID_SIZE),
				eblob_dump_id_len(old_dc.key.id, EBLOB_ID_SIZE));
		err = -EINVAL;
		goto err;
	}
	eblob_convert_disk_control(&amp;old_dc);
	record_size = old_dc.disk_size + sizeof(struct eblob_disk_control);
	err = eblob_mark_index_removed(old-&gt;bctl-&gt;index_ctl.fd, old-&gt;index_offset);
	if (err != 0) {
		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"%s: eblob_mark_index_removed: FAILED: index, fd: %d, err: %d",
				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;index_ctl.fd, err);
		goto err;
	}
	err = eblob_mark_index_removed(old-&gt;bctl-&gt;data_ctl.fd, old-&gt;data_offset);
	if (err != 0) {
		EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"%s: eblob_mark_index_removed: FAILED: data, fd: %d, err: %d",
				eblob_dump_id(key-&gt;id), old-&gt;bctl-&gt;data_ctl.fd, err);
		goto err;
	}
	eblob_stat_inc(old-&gt;bctl-&gt;stat, EBLOB_LST_RECORDS_REMOVED);
	eblob_stat_add(old-&gt;bctl-&gt;stat, EBLOB_LST_REMOVED_SIZE, record_size);
	eblob_stat_inc(b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
	eblob_stat_add(b-&gt;stat_summary, EBLOB_LST_REMOVED_SIZE, record_size);
	if (!b-&gt;cfg.sync) {
		eblob_fdatasync(old-&gt;bctl-&gt;data_ctl.fd);
		eblob_fdatasync(old-&gt;bctl-&gt;index_ctl.fd);
	}
err:
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_NOTICE, "%s: finished: %d",
			eblob_dump_id(key-&gt;id), err);
	return err;
}
static int eblob_mark_entry_removed_purge(struct eblob_backend *b,
		struct eblob_key *key, struct eblob_ram_control *old)
{
	int err;
	assert(b != NULL);
	assert(key != NULL);
	assert(old != NULL);
	assert(old-&gt;bctl != NULL);
	pthread_mutex_lock(&amp;old-&gt;bctl-&gt;lock);
	err = eblob_mark_entry_removed(b, key, old);
	if (err)
		goto err;
	err = eblob_cache_remove(b, key);
	if (err != 0 &amp;&amp; err != -ENOENT) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_NOTICE, -err,
				"%s: eblob_cache_remove: FAILED: %d",
				eblob_dump_id(key-&gt;id), err);
		goto err;
	} else {
		err = 0;
	}
err:
	pthread_mutex_unlock(&amp;old-&gt;bctl-&gt;lock);
	return err;
}
static void eblob_wc_to_dc(const struct eblob_key *key, const struct eblob_write_control *wc,
		struct eblob_disk_control *dc)
{
	assert(key != NULL);
	assert(wc != NULL);
	assert(dc != NULL);
	memcpy(&amp;dc-&gt;key, key, sizeof(struct eblob_key));
	dc-&gt;flags = wc-&gt;flags;
	dc-&gt;data_size = wc-&gt;total_data_size;
	dc-&gt;disk_size = wc-&gt;total_size;
	dc-&gt;position = wc-&gt;ctl_data_offset;
	eblob_convert_disk_control(dc);
}
static int eblob_commit_disk(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_write_control *wc, int remove)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.commit.ll", b-&gt;cfg.stat_id));
	struct eblob_disk_control dc;
	int err;
	if (remove)
		wc-&gt;flags |= BLOB_DISK_CTL_REMOVE;
	else
		wc-&gt;flags &amp;= ~BLOB_DISK_CTL_REMOVE;
	eblob_wc_to_dc(key, wc, &amp;dc);
	err = __eblob_write_ll(wc-&gt;index_fd, &amp;dc, sizeof(dc), wc-&gt;ctl_index_offset);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_commit_disk: ERROR-write-index", err);
		goto err_out_exit;
	}
	err = __eblob_write_ll(wc-&gt;data_fd, &amp;dc, sizeof(dc), wc-&gt;ctl_data_offset);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_commit_disk: ERROR-write-data", err);
		goto err_out_exit;
	}
	if (!b-&gt;cfg.sync)
		fsync(wc-&gt;index_fd);
	eblob_dump_wc(b, key, wc, "eblob_commit_disk", err);
err_out_exit:
	return err;
}
int __eblob_write_ll(int fd, const void *data, size_t size, off_t offset)
{
	int err = 0;
	ssize_t bytes;
	while (size) {
again:
		bytes = pwrite(fd, data, size, offset);
		if (bytes == -1) {
			if (errno == -EINTR)
				goto again;
			err = -errno;
			goto err_out_exit;
		}
		data += bytes;
		size -= bytes;
		offset += bytes;
	}
err_out_exit:
	return err;
}
int __eblob_read_ll(int fd, void *data, size_t size, off_t offset)
{
	ssize_t bytes;
	while (size) {
again:
		bytes = pread(fd, data, size, offset);
		if (bytes == -1) {
			if (errno == -EINTR)
				goto again;
			return -errno;
		} else if (bytes == 0)
			return -ESPIPE;
		data += bytes;
		size -= bytes;
		offset += bytes;
	}
	return 0;
}
static inline uint64_t eblob_calculate_size(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, uint64_t size)
{
	static const size_t hdr_size = sizeof(struct eblob_disk_control);
	const uint64_t data_size = size + offset;
	const uint64_t footer_size = eblob_calculate_footer_size(b, data_size);
	const uint64_t total_size = hdr_size + data_size + footer_size;
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_DEBUG, "blob: %s: %s: offset: %" PRIu64 ", size: %" PRIu64 ", "
	          "hdr_size: %zd, data_size: %" PRIu64 ", footer_size: %" PRIu64 ", total_size: %" PRIu64 "\n",
	          eblob_dump_id(key-&gt;id), __func__, offset, size, hdr_size, data_size, footer_size, total_size);
	return total_size;
}
static void eblob_wc_to_rctl(const struct eblob_write_control *wc,
		struct eblob_ram_control *rctl)
{
	assert(wc != NULL);
	assert(wc-&gt;bctl != NULL);
	assert(rctl != NULL);
	rctl-&gt;size = wc-&gt;total_data_size;
	rctl-&gt;data_offset = wc-&gt;ctl_data_offset;
	rctl-&gt;index_offset = wc-&gt;ctl_index_offset;
	rctl-&gt;bctl = wc-&gt;bctl;
}
static int eblob_commit_ram(struct eblob_backend *b, struct eblob_key *key, struct eblob_write_control *wc)
{
	struct eblob_ram_control ctl;
	int err;
	if (wc-&gt;on_disk)
		return 0;
	eblob_wc_to_rctl(wc, &amp;ctl);
	err = eblob_cache_insert(b, key, &amp;ctl);
	if (err) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: %s: %s: eblob_cache_insert: fd: %d: FAILED: %d.\n",
				eblob_dump_id(key-&gt;id), __func__, ctl.bctl-&gt;index_ctl.fd, err);
		goto err_out_exit;
	}
err_out_exit:
	eblob_dump_wc(b, key, wc, "eblob_commit_ram: finished", err);
	return err;
}
int eblob_copy_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
{
	void *buf;
	ssize_t err;
	ssize_t alloc_size = len;
	ssize_t max_size = 10 * EBLOB_1_M;
	if (len &lt;= 0)
		return -EINVAL;
	if (alloc_size &gt; max_size)
		alloc_size = max_size;
	buf = malloc(alloc_size);
	if (!buf) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	while (len &gt; 0) {
		ssize_t read_size = alloc_size;
		if (read_size &gt; len)
			read_size = len;
		err = pread(fd_in, buf, read_size, off_in);
		if (err == 0) {
			err = -ESPIPE;
			goto err_out_free;
		}
		if (err &lt; 0) {
			err = -errno;
			goto err_out_free;
		}
		read_size = err;
		err = pwrite(fd_out, buf, read_size, off_out);
		if (err == 0) {
			err = -EPIPE;
			goto err_out_free;
		}
		if (err &lt; 0) {
			err = -errno;
			goto err_out_free;
		}
		read_size = err;
		off_out += read_size;
		off_in += read_size;
		len -= read_size;
		err = 0;
	}
err_out_free:
	free(buf);
err_out_exit:
	return err;
}
#ifdef __linux__
static int eblob_splice_data_one(int *fds, int fd_in, uint64_t *off_in,
		int fd_out, uint64_t *off_out, ssize_t len)
{
	int err;
	size_t to_write = len;
	while (to_write &gt; 0) {
		err = splice(fd_in, (loff_t *)off_in, fds[1], NULL, to_write, 0);
		if (err == 0) {
			err = -ENOSPC;
			goto err_out_exit;
		}
		if (err &lt; 0) {
			err = -errno;
			perror("splice1");
			goto err_out_exit;
		}
		to_write -= err;
	}
	to_write = len;
	while (to_write &gt; 0) {
		err = splice(fds[0], NULL, fd_out, (loff_t *)off_out, to_write, 0);
		if (err == 0) {
			err = -ENOSPC;
			goto err_out_exit;
		}
		if (err &lt; 0) {
			err = -errno;
			perror("splice2");
			goto err_out_exit;
		}
		to_write -= err;
	}
	err = 0;
err_out_exit:
	return err;
}
int eblob_splice_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
{
	int fds[2];
	int err;
	err = pipe(fds);
	if (err &lt; 0) {
		err = -errno;
		goto err_out_exit;
	}
	while (len &gt; 0) {
		ssize_t chunk_size = 4096;
		if (chunk_size &gt; len)
			chunk_size = len;
		err = eblob_splice_data_one(fds, fd_in, &amp;off_in, fd_out, &amp;off_out, chunk_size);
		if (err &lt; 0)
			goto err_out_close;
		len -= chunk_size;
	}
	err = 0;
err_out_close:
	close(fds[0]);
	close(fds[1]);
err_out_exit:
	return err;
}
#else
int eblob_splice_data(int fd_in, uint64_t off_in, int fd_out, uint64_t off_out, ssize_t len)
{
	return eblob_copy_data(fd_in, off_in, fd_out, off_out, len);
}
#endif
static void eblob_write_control_cleanup(struct eblob_write_control *wc) {
	assert(wc != NULL);
	if (wc-&gt;bctl != NULL) {
		eblob_bctl_release(wc-&gt;bctl);
		wc-&gt;bctl = NULL;
	}
}
static int eblob_fill_write_control_from_ram(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_write_control *wc, int for_write, struct eblob_ram_control *old)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.lookup", b-&gt;cfg.stat_id));
	struct eblob_ram_control ctl;
	struct eblob_disk_control dc, data_dc;
	uint64_t orig_offset = wc-&gt;offset;
	uint64_t calculated_size;
	int err;
	err = eblob_cache_lookup(b, key, &amp;ctl, &amp;wc-&gt;on_disk);
	if (err) {
		int level = EBLOB_LOG_DEBUG;
		if (err != -ENOENT)
			level = EBLOB_LOG_ERROR;
		eblob_log(b-&gt;cfg.log, level, "blob: %s: %s: eblob_cache_lookup: %d, on_disk: %d\n",
				eblob_dump_id(key-&gt;id), __func__, err, wc-&gt;on_disk);
		goto err_out_exit;
	} else if(old) {
		memcpy(old, &amp;ctl, sizeof(struct eblob_ram_control));
	}
	if (for_write &amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)) {
		wc-&gt;offset = orig_offset + ctl.size;
	}
	eblob_rctl_to_wc(&amp;ctl, wc);
	eblob_bctl_hold(wc-&gt;bctl);
	err = __eblob_read_ll(wc-&gt;index_fd, &amp;dc, sizeof(dc), ctl.index_offset);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: ERROR-pread-index", err);
		goto err_out_cleanup_wc;
	}
	err = __eblob_read_ll(wc-&gt;data_fd, &amp;data_dc, sizeof(data_dc), ctl.data_offset);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: ERROR-pread-data", err);
		goto err_out_cleanup_wc;
	}
	eblob_convert_disk_control(&amp;dc);
	eblob_convert_disk_control(&amp;data_dc);
	eblob_dc_to_wc(&amp;dc, wc);
	if (eblob_index_data_mismatch(wc-&gt;bctl, &amp;dc, &amp;data_dc)) {
		err = -EINVAL;
		eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram: index and data headers mismatch", err);
		goto err_out_cleanup_wc;
	}
	calculated_size = eblob_calculate_size(b, key, wc-&gt;offset, wc-&gt;size);
	if (for_write &amp;&amp; (dc.disk_size &lt; calculated_size)) {
		err = -E2BIG;
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
		          "blob i%d: %s: %s: size check failed: disk-size: %" PRIu64 ", calculated: %" PRIu64 "\n",
		          wc-&gt;index, eblob_dump_id(key-&gt;id), __func__, dc.disk_size, calculated_size);
		eblob_dump_wc_raw(b, EBLOB_LOG_NOTICE, key, wc, "eblob_fill_write_control_from_ram: ERROR-size-check", err);
		goto err_out_cleanup_wc;
	}
	eblob_dump_wc(b, key, wc, "eblob_fill_write_control_from_ram", err);
	return err;
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_exit:
	return err;
}
static int eblob_check_free_space(struct eblob_backend *b, uint64_t size)
{
	unsigned long long total, avail;
	static int print_once;
	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_NO_FREE_SPACE_CHECK)) {
		avail = b-&gt;vfs_stat.f_bsize * b-&gt;vfs_stat.f_bavail;
		total = b-&gt;vfs_stat.f_frsize * b-&gt;vfs_stat.f_blocks;
		if (avail &lt; size)
			return -ENOSPC;
		if (b-&gt;cfg.blob_size_limit) {
			if (eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE) + size &gt; b-&gt;cfg.blob_size_limit) {
				if (!print_once) {
					print_once = 1;
					eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "OUT OF FREE SPACE: available: %llu Mb, "
							"total: %llu Mb, current size: %" PRIu64 " Mb, limit: %" PRIu64 "Mb\n",
							avail / EBLOB_1_M, total / EBLOB_1_M,
							(eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE) + size) / EBLOB_1_M,
							b-&gt;cfg.blob_size_limit / EBLOB_1_M);
				}
				return -ENOSPC;
			}
		} else if (((b-&gt;cfg.blob_flags &amp; EBLOB_RESERVE_10_PERCENTS) &amp;&amp; (avail &lt; total * 0.1)) ||
				(!(b-&gt;cfg.blob_flags &amp; EBLOB_RESERVE_10_PERCENTS) &amp;&amp; (avail &lt; 2 * b-&gt;cfg.blob_size))) {
			if (!print_once) {
				print_once = 1;
				eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "OUT OF FREE SPACE: available: %llu Mb, "
						"total: %llu Mb, blob size: %" PRIu64 " Mb\n",
						avail / EBLOB_1_M, total / EBLOB_1_M, b-&gt;cfg.blob_size / EBLOB_1_M);
			}
			return -ENOSPC;
		}
	}
	return 0;
}
static int eblob_write_prepare_disk_ll(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_write_control *wc, uint64_t prepare_disk_size,
		enum eblob_copy_flavour copy, uint64_t copy_offset,
		struct eblob_ram_control *old)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare.disk.ll", b-&gt;cfg.stat_id));
	struct eblob_base_ctl *ctl = NULL;
	ssize_t err = 0;
	if (list_empty(&amp;b-&gt;bases)) {
		err = eblob_add_new_base(b);
		if (err)
			goto err_out_exit;
	}
	ctl = list_last_entry(&amp;b-&gt;bases, struct eblob_base_ctl, base_entry);
	if ((ctl-&gt;data_ctl.offset &gt;= b-&gt;cfg.blob_size) || ctl-&gt;index_ctl.sorted ||
			(ctl-&gt;index_ctl.size / sizeof(struct eblob_disk_control) &gt;= b-&gt;cfg.records_in_blob)) {
		err = eblob_add_new_base(b);
		if (err)
			goto err_out_exit;
		if (!ctl-&gt;index_ctl.sorted)
			datasort_force_sort(b);
		ctl = list_last_entry(&amp;b-&gt;bases, struct eblob_base_ctl, base_entry);
	}
	if (old != NULL) {
		if (old-&gt;bctl-&gt;index_ctl.fd == -1) {
			err = -EAGAIN;
			goto err_out_exit;
		}
		if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)
			wc-&gt;offset += old-&gt;size;
	} else {
		if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND) {
			wc-&gt;flags &amp;= ~BLOB_DISK_CTL_APPEND;
			prepare_disk_size += wc-&gt;size * 4;
		}
	}
	assert(datasort_base_is_sorted(ctl) != 1);
	wc-&gt;data_fd = ctl-&gt;data_ctl.fd;
	wc-&gt;index_fd = ctl-&gt;index_ctl.fd;
	wc-&gt;index = ctl-&gt;index;
	wc-&gt;on_disk = 0;
	wc-&gt;ctl_index_offset = ctl-&gt;index_ctl.size;
	wc-&gt;ctl_data_offset = ctl-&gt;data_ctl.offset;
	wc-&gt;data_offset = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control) + wc-&gt;offset;
	wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
	if (wc-&gt;bctl)
		eblob_bctl_release(wc-&gt;bctl);
	eblob_bctl_hold(ctl);
	wc-&gt;bctl = ctl;
	if (wc-&gt;total_data_size &lt; prepare_disk_size)
		wc-&gt;total_size = eblob_calculate_size(b, key, 0, prepare_disk_size);
	else
		wc-&gt;total_size = eblob_calculate_size(b, key, 0, wc-&gt;total_data_size);
	if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND)
		wc-&gt;total_size *= 2;
	ctl-&gt;data_ctl.offset += wc-&gt;total_size;
	ctl-&gt;index_ctl.size += sizeof(struct eblob_disk_control);
	err = eblob_commit_disk(b, key, wc, 0);
	if (err)
		goto err_out_rollback;
	if (prepare_disk_size ||
	    copy == EBLOB_COPY_RECORD) {
		err = eblob_preallocate(wc-&gt;data_fd, wc-&gt;ctl_data_offset, wc-&gt;total_size);
		eblob_log(b-&gt;cfg.log, err == 0 ? EBLOB_LOG_DEBUG : EBLOB_LOG_ERROR,
		          "blob i%d: %s: eblob_preallocate: fd: %d, size: %" PRIu64 ", err: %zu\n",
		          wc-&gt;index, eblob_dump_id(key-&gt;id), wc-&gt;data_fd, wc-&gt;ctl_data_offset + wc-&gt;total_size, err);
		if (err != 0)
			goto err_out_rollback;
	}
	if (old != NULL &amp;&amp; copy == EBLOB_COPY_RECORD) {
		struct eblob_disk_control old_dc;
		uint64_t off_in = old-&gt;data_offset + sizeof(struct eblob_disk_control);
		uint64_t off_out = wc-&gt;ctl_data_offset + sizeof(struct eblob_disk_control);
		uint64_t size;
		if (copy_offset != 0) {
			off_out += copy_offset;
			if (wc-&gt;flags &amp; BLOB_DISK_CTL_APPEND) {
				wc-&gt;data_offset += copy_offset;
				wc-&gt;total_data_size += copy_offset;
			}
		}
		err = __eblob_read_ll(old-&gt;bctl-&gt;data_ctl.fd, &amp;old_dc,
				sizeof(struct eblob_disk_control), old-&gt;data_offset);
		if (err) {
			eblob_dump_wc(b, key, wc, "copy: ERROR-pread-data", err);
			goto err_out_rollback;
		}
		if (memcmp(&amp;old_dc.key, key, sizeof(struct eblob_key)) != 0) {
			EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_ERROR,
					"keys mismatch: in-memory: %s, on-disk: %s",
					eblob_dump_id_len(key-&gt;id, EBLOB_ID_SIZE),
					eblob_dump_id_len(old_dc.key.id, EBLOB_ID_SIZE));
			goto err_out_rollback;
		}
		eblob_convert_disk_control(&amp;old_dc);
		size = old_dc.disk_size - sizeof(struct eblob_disk_control);
		if (wc-&gt;data_fd != old-&gt;bctl-&gt;data_ctl.fd)
			err = eblob_splice_data(old-&gt;bctl-&gt;data_ctl.fd, off_in, wc-&gt;data_fd, off_out, size);
		else
			err = eblob_copy_data(old-&gt;bctl-&gt;data_ctl.fd, off_in, wc-&gt;data_fd, off_out, size);
		FORMATTED(HANDY_GAUGE_SET, ("eblob.%u.disk.write.move.size", b-&gt;cfg.stat_id), size);
		if (err == 0)
			eblob_stat_inc(b-&gt;stat, EBLOB_GST_READ_COPY_UPDATE);
		EBLOB_WARNX(b-&gt;cfg.log, err &lt; 0 ? EBLOB_LOG_ERROR : EBLOB_LOG_NOTICE,
				"copy: %s: src offset: %" PRIu64 ", dst offset: %" PRIu64
				", size: %" PRIu64 ", src fd: %d: dst fd: %d: %zd",
				eblob_dump_id(key-&gt;id), off_in, off_out,
				size, old-&gt;bctl-&gt;data_ctl.fd, wc-&gt;data_fd, err);
		if (err &lt; 0)
			goto err_out_rollback;
	}
	if (old != NULL) {
		err = eblob_mark_entry_removed_purge(b, key, old);
		if (err != 0) {
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
					"%s: %s: eblob_mark_entry_removed_purge: %zd\n",
					__func__, eblob_dump_id(key-&gt;id), -err);
			goto err_out_exit;
		}
	}
	eblob_stat_inc(ctl-&gt;stat, EBLOB_LST_RECORDS_TOTAL);
	eblob_stat_add(ctl-&gt;stat, EBLOB_LST_BASE_SIZE,
			wc-&gt;total_size + sizeof(struct eblob_disk_control));
	eblob_stat_add(b-&gt;stat_summary, EBLOB_LST_BASE_SIZE,
	               wc-&gt;total_size + sizeof(struct eblob_disk_control));
	eblob_stat_inc(b-&gt;stat_summary, EBLOB_LST_RECORDS_TOTAL);
	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk_ll: complete", 0);
	return 0;
err_out_rollback:
	ctl-&gt;data_ctl.offset -= wc-&gt;total_size;
	ctl-&gt;index_ctl.size -= sizeof(struct eblob_disk_control);
err_out_exit:
	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk_ll: error", err);
	return err;
}
static int eblob_write_prepare_disk(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_write_control *wc, uint64_t prepare_disk_size,
		enum eblob_copy_flavour copy, uint64_t copy_offset, struct eblob_ram_control *old,
		size_t defrag_generation)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare.disk", b-&gt;cfg.stat_id));
	ssize_t err = 0;
	uint64_t size;
	struct eblob_ram_control upd_old;
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
			"blob: %s: eblob_write_prepare_disk: start: "
			"size: %" PRIu64 ", offset: %" PRIu64 ", prepare: %" PRIu64 "\n",
			eblob_dump_id(key-&gt;id), wc-&gt;size, wc-&gt;offset, prepare_disk_size);
	pthread_mutex_lock(&amp;b-&gt;lock);
	if (defrag_generation != b-&gt;defrag_generation) {
		int disk;
		err = eblob_cache_lookup(b, key, &amp;upd_old, &amp;disk);
		switch (err) {
		case -ENOENT:
			old = NULL;
			break;
		case 0:
			old = &amp;upd_old;
			break;
		default:
			goto err_out_exit;
		}
	}
	size = prepare_disk_size &gt; wc-&gt;size + wc-&gt;offset ? prepare_disk_size : wc-&gt;size + wc-&gt;offset;
	err = eblob_check_free_space(b, eblob_calculate_size(b, key, 0, size));
	if (err)
		goto err_out_exit;
	err = eblob_write_prepare_disk_ll(b, key, wc, prepare_disk_size,
			copy, copy_offset, old);
err_out_exit:
	pthread_mutex_unlock(&amp;b-&gt;lock);
	eblob_dump_wc(b, key, wc, "eblob_write_prepare_disk", err);
	return err;
}
int eblob_write_prepare(struct eblob_backend *b, struct eblob_key *key,
		uint64_t size, uint64_t flags)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.prepare", b-&gt;cfg.stat_id));
	struct eblob_write_control wc = { .offset = 0 };
	struct eblob_ram_control old;
	int err;
	size_t defrag_generation = 0;
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
			"key: %s, size: %" PRIu64 ", flags: %s",
			eblob_dump_id(key-&gt;id), size, eblob_dump_dctl_flags(flags));
	if (b == NULL || key == NULL) {
		err = -EINVAL;
		goto err_out_exit;
	}
	pthread_mutex_lock(&amp;b-&gt;lock);
	defrag_generation = b-&gt;defrag_generation;
	err = eblob_fill_write_control_from_ram(b, key, &amp;wc, 1, &amp;old);
	pthread_mutex_unlock(&amp;b-&gt;lock);
	if (err &amp;&amp; err != -ENOENT &amp;&amp; err != -E2BIG)
		goto err_out_exit;
	if (err == 0 &amp;&amp; (wc.total_size &gt;= eblob_calculate_size(b, key, 0, size))) {
		uint64_t new_flags;
		new_flags = eblob_validate_ctl_flags(b, flags);
		new_flags |= BLOB_DISK_CTL_UNCOMMITTED;
		if (wc.flags != new_flags) {
			wc.flags = new_flags;
			err = eblob_commit_disk(b, key, &amp;wc, 0);
			if (err)
				goto err_out_cleanup_wc;
			err = eblob_commit_ram(b, key, &amp;wc);
			if (err)
				goto err_out_cleanup_wc;
		}
		eblob_stat_inc(b-&gt;stat, EBLOB_GST_PREPARE_REUSED);
		goto err_out_cleanup_wc;
	} else {
		wc.flags = eblob_validate_ctl_flags(b, flags);
		wc.flags |= BLOB_DISK_CTL_UNCOMMITTED;
		err = eblob_write_prepare_disk(b, key, &amp;wc, size, EBLOB_COPY_RECORD, 0, err == -ENOENT ? NULL : &amp;old, defrag_generation);
		if (err)
			goto err_out_cleanup_wc;
		err = eblob_commit_ram(b, key, &amp;wc);
		if (err)
			goto err_out_cleanup_wc;
	}
err_out_cleanup_wc:
	eblob_write_control_cleanup(&amp;wc);
err_out_exit:
	eblob_dump_wc(b, key, &amp;wc, "eblob_write_prepare: finished", err);
	return err;
}
int eblob_hash(struct eblob_backend *b, void *dst,
		unsigned int dsize __attribute_unused__, const void *src, uint64_t size)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.hash", b-&gt;cfg.stat_id));
	sha512_buffer(src, size, dst);
	return 0;
}
static int eblob_write_commit_ll(struct eblob_backend *b, struct eblob_key *key,
		struct eblob_write_control *wc)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write.commit", b-&gt;cfg.stat_id));
	int err;
	err = eblob_commit_footer(b, key, wc);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_commit_footer: ERROR", err);
		goto err_out_exit;
	}
	err = eblob_commit_disk(b, key, wc, 0);
	if (err)
		goto err_out_exit;
	err = eblob_commit_ram(b, key, wc);
	if (err &lt; 0)
		goto err_out_exit;
err_out_exit:
	eblob_dump_wc(b, key, wc, "eblob_write_commit_ll", err);
	return err;
}
static int eblob_write_commit_prepare(struct eblob_backend *b, struct eblob_key *key, uint64_t size,
				      uint64_t flags, struct eblob_write_control *wc)
{
	int err;
	pthread_mutex_lock(&amp;b-&gt;lock);
	err = eblob_fill_write_control_from_ram(b, key, wc, 1, NULL);
	if (err &lt; 0)
		goto err_out_unlock;
	if (!(wc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
		err = -EPERM;
		goto err_out_cleanup_wc;
	}
	if (size &gt; wc-&gt;total_size) {
		err = -ERANGE;
		goto err_out_cleanup_wc;
	}
	if (size != ~0ULL)
		wc-&gt;size = wc-&gt;total_data_size = size;
	if (flags != ~0ULL)
		wc-&gt;flags = flags;
	wc-&gt;flags = eblob_validate_ctl_flags(b, wc-&gt;flags);
	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
		struct eblob_ram_control rctl;
		err = eblob_cache_lookup(b, key, &amp;rctl, NULL);
		if (err != 0)
			goto err_out_cleanup_wc;
		err = eblob_write_prepare_disk_ll(b, key, wc, size,
				EBLOB_COPY_RECORD, 0, &amp;rctl);
		if (err != 0)
			goto err_out_cleanup_wc;
	}
	pthread_mutex_unlock(&amp;b-&gt;lock);
	wc-&gt;flags &amp;= ~BLOB_DISK_CTL_UNCOMMITTED;
	return err;
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_unlock:
	pthread_mutex_unlock(&amp;b-&gt;lock);
	return err;
}
int eblob_write_commit(struct eblob_backend *b, struct eblob_key *key,
		uint64_t size, uint64_t flags)
{
	struct eblob_write_control wc = { .offset = 0, };
	int err;
	if (b == NULL || key == NULL) {
		err = -EINVAL;
		goto err_out_exit;
	}
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
			"key: %s, size: %" PRIu64 ", flags: %s",
			eblob_dump_id(key-&gt;id), size, eblob_dump_dctl_flags(flags));
	err = eblob_write_commit_prepare(b, key, size, flags, &amp;wc);
	if (err != 0)
		goto err_out_exit;
	err = eblob_write_commit_ll(b, key, &amp;wc);
	if (err != 0)
		goto err_out_cleanup_wc;
err_out_cleanup_wc:
	eblob_write_control_cleanup(&amp;wc);
err_out_exit:
	eblob_dump_wc(b, key, &amp;wc, "eblob_write_commit: finished", err);
	return err;
}
static int eblob_try_overwritev(struct eblob_backend *b, struct eblob_key *key,
		const struct eblob_iovec *iov, uint16_t iovcnt, struct eblob_write_control *wc, struct eblob_ram_control *old, size_t *defrag_generation)
{
	ssize_t err;
	uint64_t flags = wc-&gt;flags;
	const size_t size = wc-&gt;size;
	pthread_mutex_lock(&amp;b-&gt;lock);
	*defrag_generation = b-&gt;defrag_generation;
	err = eblob_fill_write_control_from_ram(b, key, wc, 1, old);
	if (err) {
		pthread_mutex_unlock(&amp;b-&gt;lock);
		goto err_out_exit;
	}
	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
		err = -EROFS;
	}
	pthread_mutex_unlock(&amp;b-&gt;lock);
	if (err)
		goto err_out_cleanup_wc;
	if ((flags &amp; BLOB_DISK_CTL_EXTHDR) != (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
		err = -E2BIG;
		goto err_out_cleanup_wc;
	}
	if ((flags &amp; BLOB_DISK_CTL_EXTHDR) &amp;&amp; (flags &amp; BLOB_DISK_CTL_APPEND))
<a name="2"></a>		if (wc-&gt;offset == 0)
			flags &amp;= ~BLOB_DISK_CTL_APPEND;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	wc-&gt;flags = flags;
	wc-&gt;size = size;
	wc-&gt;total_data_size = wc-&gt;offset + wc-&gt;size;
	err = eblob_writev_raw(key, wc, iov, iovcnt);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_try_overwrite: ERROR-eblob_writev_raw", err);
		goto err_out_cleanup_wc;
	}
	eblob_stat_inc(b-&gt;stat, EBLOB_GST_WRITES_NUMBER);
	eblob_stat_add(b-&gt;stat, EBLOB_GST_WRITES_SIZE, wc-&gt;size);
	err = eblob_write_commit_ll(b, key, wc);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_try_overwrite: ERROR-eblob_write_commit_ll", err);
		goto err_out_cleanup_wc;
	}</b></font>
	eblob_dump_wc(b, key, wc, "eblob_try_overwrite", err);
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_exit:
	return err;
}
int eblob_plain_write(struct eblob_backend *b, struct eblob_key *key,
		void *data, uint64_t offset, uint64_t size, uint64_t flags)
{
	const struct eblob_iovec iov = {
		.base = data,
		.size = size,
		.offset = offset,
	};
	return eblob_plain_writev(b, key, &amp;iov, 1, flags);
}
static int eblob_plain_writev_prepare(struct eblob_backend *b, struct eblob_key *key,
				      const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags,
				      struct eblob_write_control *wc, int *prepared)
{
	struct eblob_iovec_bounds bounds;
	ssize_t err;
	eblob_iovec_get_bounds(&amp;bounds, iov, iovcnt);
	wc-&gt;size = bounds.max;
	pthread_mutex_lock(&amp;b-&gt;lock);
	err = eblob_fill_write_control_from_ram(b, key, wc, 1, NULL);
	if (err)
		goto err_out_unlock;
	if (!(wc-&gt;flags &amp; BLOB_DISK_CTL_UNCOMMITTED)) {
		err = -EPERM;
		goto err_out_cleanup_wc;
	}
	if ((flags &amp; BLOB_DISK_CTL_EXTHDR)
			&amp;&amp; !(wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
		err = -ENOTSUP;
		goto err_out_cleanup_wc;
	}
	wc-&gt;flags = eblob_validate_ctl_flags(b, flags) | BLOB_DISK_CTL_UNCOMMITTED;
	if (eblob_binlog_enabled(&amp;wc-&gt;bctl-&gt;binlog)) {
		struct eblob_ram_control rctl;
		err = eblob_cache_lookup(b, key, &amp;rctl, NULL);
		if (err != 0)
			goto err_out_cleanup_wc;
		const uint64_t hdr_footer_size = sizeof(struct eblob_disk_control) + eblob_get_footer_size(b, wc);
		if (wc-&gt;total_size &lt; hdr_footer_size) {
			err = -EINVAL;
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
				  "blob i%d: %s: %s: size check failed: total-size: %" PRIu64 ", header-footer-size: %" PRIu64 "\n",
				  wc-&gt;index, eblob_dump_id(key-&gt;id), __func__, wc-&gt;total_size, hdr_footer_size);
			eblob_dump_wc(b, key, wc, "eblob_plain_writev_prepare: ERROR-size-check", err);
			goto err_out_cleanup_wc;
		}
		const uint64_t prepare_disk_size = wc-&gt;total_size - hdr_footer_size;
		err = eblob_write_prepare_disk_ll(b, key, wc,
				prepare_disk_size,
				EBLOB_COPY_RECORD, 0, &amp;rctl);
		if (err != 0)
			goto err_out_cleanup_wc;
		*prepared = 1;
	}
	pthread_mutex_unlock(&amp;b-&gt;lock);
	return err;
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_unlock:
	pthread_mutex_unlock(&amp;b-&gt;lock);
	return err;
}
int eblob_plain_writev(struct eblob_backend *b, struct eblob_key *key,
		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags)
{
	struct eblob_write_control wc = { .offset = 0 };
	ssize_t err;
	int prepared = 0;
	if (b == NULL || key == NULL || iov == NULL)
		return -EINVAL;
	if (iovcnt &lt; EBLOB_IOVCNT_MIN || iovcnt &gt; EBLOB_IOVCNT_MAX)
		return -E2BIG;
	EBLOB_WARNX(b-&gt;cfg.log, EBLOB_LOG_DEBUG,
			"key: %s, iovcnt: %" PRIu16 ", flags: %s",
			eblob_dump_id(key-&gt;id), iovcnt, eblob_dump_dctl_flags(flags));
	err = eblob_plain_writev_prepare(b, key, iov, iovcnt, flags, &amp;wc, &amp;prepared);
	if (err)
		goto err_out_exit;
	err = eblob_writev_raw(key, &amp;wc, iov, iovcnt);
	if (err)
		goto err_out_cleanup_wc;
	if (prepared) {
		err = eblob_commit_ram(b, key, &amp;wc);
		if (err != 0)
			goto err_out_cleanup_wc;
	}
err_out_cleanup_wc:
	eblob_write_control_cleanup(&amp;wc);
err_out_exit:
	eblob_log(b-&gt;cfg.log, err ? EBLOB_LOG_ERROR : EBLOB_LOG_NOTICE,
			"blob: %s: %s: eblob_writev_raw: fd: %d: "
			"size: %" PRIu64 ", offset: %" PRIu64 ": %zd.\n",
			eblob_dump_id(key-&gt;id), __func__, wc.data_fd, wc.size,
			wc.data_offset + wc.offset, err);
	if (err) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.plain.errors.%zd", b-&gt;cfg.stat_id, -err), 1);
	}
	return err;
}
int eblob_write(struct eblob_backend *b, struct eblob_key *key,
		void *data, uint64_t offset, uint64_t size,
		uint64_t flags)
{
	const struct eblob_iovec iov = {
		.base = data,
		.size = size,
		.offset = offset,
	};
	return eblob_writev(b, key, &amp;iov, 1, flags);
}
int eblob_write_return(struct eblob_backend *b, struct eblob_key *key,
		void *data, uint64_t offset, uint64_t size, uint64_t flags,
		struct eblob_write_control *wc)
{
	const struct eblob_iovec iov = {
		.base = data,
		.size = size,
		.offset = offset,
	};
	return eblob_writev_return(b, key, &amp;iov, 1, flags, wc);
}
int eblob_writev(struct eblob_backend *b, struct eblob_key *key,
		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags)
{
	struct eblob_write_control wc;
	return eblob_writev_return(b, key, iov, iovcnt, flags, &amp;wc);
}
static int check_writev_return_flags(uint64_t flags, uint16_t iovcnt) {
	if (flags &amp; BLOB_DISK_CTL_COMPRESS)
		return -ENOTSUP;
	if (flags &amp; BLOB_DISK_CTL_WRITE_RETURN)
		return -ENOTSUP;
	if (flags &amp; BLOB_DISK_CTL_REMOVE)
		return -ENOTSUP;
	if (iovcnt &lt; EBLOB_IOVCNT_MIN || iovcnt &gt; EBLOB_IOVCNT_MAX)
		return -E2BIG;
	return 0;
}
int eblob_writev_return(struct eblob_backend *b, struct eblob_key *key,
		const struct eblob_iovec *iov, uint16_t iovcnt, uint64_t flags,
		struct eblob_write_control *wc)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.write", b-&gt;cfg.stat_id));
	struct eblob_iovec_bounds bounds;
	struct eblob_ram_control old;
	enum eblob_copy_flavour copy = EBLOB_DONT_COPY_RECORD;
	uint64_t copy_offset = 0;
	int err;
	size_t defrag_generation = 0;
	if (b == NULL || key == NULL || iov == NULL || wc == NULL)
		return -EINVAL;
	err = check_writev_return_flags(flags, iovcnt);
	if (err) {
		return err;
	}
	memset(wc, 0, sizeof(struct eblob_write_control));
	eblob_iovec_get_bounds(&amp;bounds, iov, iovcnt);
	wc-&gt;size = bounds.max;
	wc-&gt;flags = eblob_validate_ctl_flags(b, flags);
	wc-&gt;index = -1;
	err = eblob_try_overwritev(b, key, iov, iovcnt, wc, &amp;old, &amp;defrag_generation);
	if (err == 0) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.rewrites", b-&gt;cfg.stat_id), 1);
		goto err_out_exit;
	} else if (!(err == -E2BIG || err == -ENOENT || err == -EROFS)) {
		goto err_out_exit;
	} else if (err == -E2BIG || err == -EROFS) {
		if ((flags &amp; BLOB_DISK_CTL_APPEND)
				|| bounds.min != 0
				|| bounds.max &lt; wc-&gt;total_data_size
				|| bounds.contiguous == 0)
			copy = EBLOB_COPY_RECORD;
		if ((flags &amp; BLOB_DISK_CTL_EXTHDR)
				&amp;&amp; !(wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
			copy = EBLOB_COPY_RECORD;
			copy_offset = iov[0].size;
		}
		if (!(flags &amp; BLOB_DISK_CTL_EXTHDR)
				&amp;&amp; (wc-&gt;flags &amp; BLOB_DISK_CTL_EXTHDR)) {
			err = -EINVAL;
			goto err_out_exit;
		}
		wc-&gt;offset = 0;
		wc-&gt;flags = eblob_validate_ctl_flags(b, flags);
	}
	err = eblob_write_prepare_disk(b, key, wc, 0, copy, copy_offset, err == -ENOENT ? NULL : &amp;old, defrag_generation);
	if (err)
		goto err_out_cleanup_wc;
	err = eblob_writev_raw(key, wc, iov, iovcnt);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_writev: eblob_writev_raw: FAILED", err);
		goto err_out_cleanup_wc;
	}
	err = eblob_write_commit_ll(b, key, wc);
	if (err) {
		eblob_dump_wc(b, key, wc, "eblob_writev: eblob_write_commit_ll: FAILED", err);
		goto err_out_cleanup_wc;
	}
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_exit:
	eblob_dump_wc(b, key, wc, "eblob_writev: finished", err);
	if (err) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.write.errors.%d", b-&gt;cfg.stat_id, -err), 1);
	}
	return err;
}
int eblob_remove(struct eblob_backend *b, struct eblob_key *key)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.remove", b-&gt;cfg.stat_id));
	struct eblob_ram_control ctl;
	int err, disk;
	pthread_mutex_lock(&amp;b-&gt;lock);
	err = eblob_cache_lookup(b, key, &amp;ctl, &amp;disk);
	if (err) {
		pthread_mutex_unlock(&amp;b-&gt;lock);
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: %s: %s: eblob_cache_lookup: %d.\n",
				eblob_dump_id(key-&gt;id), __func__, err);
		goto err_out_exit;
	}
	eblob_bctl_hold(ctl.bctl);
	pthread_mutex_unlock(&amp;b-&gt;lock);
	if ((err = eblob_mark_entry_removed_purge(b, key, &amp;ctl)) != 0) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"%s: %s: eblob_mark_entry_removed_purge: %d\n",
				__func__, eblob_dump_id(key-&gt;id), -err);
		goto err_out_bctl_release;
	}
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_NOTICE,
		"blob: %s: eblob_remove: removed block at: %" PRIu64
		", size: %" PRIu64 ".\n",
		eblob_dump_id(key-&gt;id), ctl.data_offset, ctl.size);
err_out_bctl_release:
	eblob_bctl_release(ctl.bctl);
err_out_exit:
	if (err &amp;&amp; err != -ENOENT) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.remove.errors.%d", b-&gt;cfg.stat_id, -err), 1);
	}
	return err;
}
static int _eblob_read_ll(struct eblob_backend *b, struct eblob_key *key,
		enum eblob_read_flavour csum, struct eblob_write_control *wc)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.read", b-&gt;cfg.stat_id));
	int err;
	struct timeval start, end;
	long csum_time;
	assert(b != NULL);
	assert(key != NULL);
	assert(wc != NULL);
	eblob_stat_inc(b-&gt;stat, EBLOB_GST_LOOKUP_READS_NUMBER);
	memset(wc, 0, sizeof(struct eblob_write_control));
	pthread_mutex_lock(&amp;b-&gt;lock);
	err = eblob_fill_write_control_from_ram(b, key, wc, 0, NULL);
	pthread_mutex_unlock(&amp;b-&gt;lock);
	if (err &lt; 0) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: %s: %s: eblob_fill_write_control_from_ram: %d.\n",
				eblob_dump_id(key-&gt;id), __func__, err);
		goto err_out_exit;
	}
	if (wc-&gt;flags &amp; BLOB_DISK_CTL_COMPRESS) {
		err = -ENOTSUP;
		goto err_out_cleanup_wc;
	}
	gettimeofday(&amp;start, NULL);
	if (csum != EBLOB_READ_NOCSUM) {
		err = eblob_verify_checksum(b, key, wc);
		if (err) {
			eblob_dump_wc(b, key, wc, "_eblob_read_ll: checksum verification failed", err);
			goto err_out_cleanup_wc;
		}
	}
	gettimeofday(&amp;end, NULL);
	csum_time = DIFF(start, end);
	eblob_log(b-&gt;cfg.log, EBLOB_LOG_INFO, "blob: %s: eblob_read: Ok: data_fd: %d"
			", ctl_data_offset: %" PRIu64 ", data_offset: %" PRIu64
			", index_fd: %d, index_offset: %" PRIu64 ", size: %" PRIu64
			", total(disk)_size: %" PRIu64 ", on_disk: %d, want-csum: %d, csum-time: %ld usecs, err: %d\n",
			eblob_dump_id(key-&gt;id), wc-&gt;data_fd, wc-&gt;ctl_data_offset, wc-&gt;data_offset,
			wc-&gt;index_fd, wc-&gt;ctl_index_offset, wc-&gt;size, wc-&gt;total_size, wc-&gt;on_disk,
			csum, csum_time, err);
err_out_cleanup_wc:
	eblob_write_control_cleanup(wc);
err_out_exit:
	if (err &amp;&amp; err != -ENOENT) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.read.errors.%d", b-&gt;cfg.stat_id, -err), 1);
	}
	return err;
}
static int eblob_read_ll(struct eblob_backend *b, struct eblob_key *key, int *fd,
		uint64_t *offset, uint64_t *size, enum eblob_read_flavour csum)
{
	struct eblob_write_control wc = { .size = 0 };
	int err;
	if (b == NULL || key == NULL || fd == NULL || offset == NULL || size == NULL)
		return -EINVAL;
	err = _eblob_read_ll(b, key, csum, &amp;wc);
	if (err &lt; 0)
		goto err;
	if (wc.flags &amp; BLOB_DISK_CTL_UNCOMMITTED) {
		err = -ENOENT;
		goto err;
	}
	*fd = wc.data_fd;
	*size = wc.size;
	*offset = wc.data_offset;
err:
	return err;
}
int eblob_read(struct eblob_backend *b, struct eblob_key *key, int *fd,
		uint64_t *offset, uint64_t *size)
{
	return eblob_read_ll(b, key, fd, offset, size, EBLOB_READ_CSUM);
}
int eblob_read_nocsum(struct eblob_backend *b, struct eblob_key *key,
		int *fd, uint64_t *offset, uint64_t *size)
{
	return eblob_read_ll(b, key, fd, offset, size, EBLOB_READ_NOCSUM);
}
int eblob_read_return(struct eblob_backend *b, struct eblob_key *key,
		enum eblob_read_flavour csum, struct eblob_write_control *wc)
{
	if (b == NULL || key == NULL || wc == NULL)
		return -EINVAL;
	return _eblob_read_ll(b, key, csum, wc);
}
static int eblob_read_data_ll(struct eblob_backend *b, struct eblob_key *key,
		uint64_t offset, char **dst, uint64_t *size, enum eblob_read_flavour csum)
{
	FORMATTED(HANDY_TIMER_SCOPE, ("eblob.%u.disk.read_data", b-&gt;cfg.stat_id));
	int err, fd;
	void *data;
	uint64_t record_offset, record_size;
	err = eblob_read_ll(b, key, &amp;fd, &amp;record_offset, &amp;record_size, csum);
	if (err &lt; 0)
		goto err_out_exit;
	if (offset &gt;= record_size) {
		err = -E2BIG;
		goto err_out_exit;
	}
	record_offset += offset;
	record_size -= offset;
	if (*size &amp;&amp; record_size &gt; *size)
		record_size = *size;
	data = malloc(record_size);
	if (!data) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	err = __eblob_read_ll(fd, data, record_size, record_offset);
	if (err != 0)
		goto err_out_free;
	eblob_stat_inc(b-&gt;stat, EBLOB_GST_DATA_READS_NUMBER);
	eblob_stat_add(b-&gt;stat, EBLOB_GST_READS_SIZE, record_size);
	*size = record_size;
	*dst = data;
	return 0;
err_out_free:
	free(data);
err_out_exit:
	if (err &amp;&amp; err != -ENOENT) {
		FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.read_data.errors.%d", b-&gt;cfg.stat_id, -err), 1);
	}
	return err;
}
int eblob_read_data(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, char **dst, uint64_t *size)
{
	return eblob_read_data_ll(b, key, offset, dst, size, EBLOB_READ_CSUM);
}
int eblob_read_data_nocsum(struct eblob_backend *b, struct eblob_key *key, uint64_t offset, char **dst, uint64_t *size)
{
	return eblob_read_data_ll(b, key, offset, dst, size, EBLOB_READ_NOCSUM);
}
static void *eblob_sync_thread(void *data)
{
	struct eblob_backend *b = data;
	while (b-&gt;cfg.sync &amp;&amp; (eblob_event_wait(&amp;b-&gt;exit_event, b-&gt;cfg.sync) == -ETIMEDOUT)) {
		eblob_sync(b);
	}
	return NULL;
}
int eblob_sync(struct eblob_backend *b)
{
	struct eblob_base_ctl *ctl;
	pthread_mutex_lock(&amp;b-&gt;sync_lock);
	list_for_each_entry(ctl, &amp;b-&gt;bases, base_entry) {
		fsync(ctl-&gt;data_ctl.fd);
		fsync(ctl-&gt;index_ctl.fd);
	}
	pthread_mutex_unlock(&amp;b-&gt;sync_lock);
	return 0;
}
static int eblob_cache_statvfs(struct eblob_backend *b)
{
	if (statvfs(b-&gt;base_dir, &amp;b-&gt;vfs_stat) == -1)
		return -errno;
	return 0;
}
static void *eblob_periodic_thread(void *data)
{
	struct eblob_backend *b = data;
	while (eblob_event_wait(&amp;b-&gt;exit_event, 1) == -ETIMEDOUT) {
		eblob_periodic(b);
	}
	return NULL;
}
int eblob_periodic(struct eblob_backend *b)
{
	int err;
	time_t t = time(NULL);
	pthread_mutex_lock(&amp;b-&gt;periodic_lock);
	if (t &gt; b-&gt;stat_file_time + (time_t)b-&gt;cfg.periodic_timeout) {
		err = eblob_stat_commit(b);
		if (err != 0) {
			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
				"eblob_stat_commit: FAILED");
			FORMATTED(HANDY_COUNTER_INCREMENT, ("eblob.%u.disk.stat_commit.errors.%d", b-&gt;cfg.stat_id, -err), 1);
		}
		b-&gt;stat_file_time = t;
	}
	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_NO_FREE_SPACE_CHECK)) {
		err = eblob_cache_statvfs(b);
		if (err != 0) {
			EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
				"eblob_cache_statvfs: FAILED");
		}
	}
	err = eblob_json_commit(b);
	if (err != 0) {
		EBLOB_WARNC(b-&gt;cfg.log, EBLOB_LOG_ERROR, -err,
			"eblob_json_coomit: FAILED");
	}
	pthread_mutex_unlock(&amp;b-&gt;periodic_lock);
	return err;
}
void eblob_cleanup(struct eblob_backend *b)
{
	eblob_event_set(&amp;b-&gt;exit_event);
	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_DISABLE_THREADS)) {
		pthread_join(b-&gt;sync_tid, NULL);
		pthread_join(b-&gt;defrag_tid, NULL);
		pthread_join(b-&gt;periodic_tid, NULL);
	}
	eblob_json_stat_destroy(b);
	eblob_bases_cleanup(b);
	eblob_hash_destroy(&amp;b-&gt;hash);
	eblob_l2hash_destroy(&amp;b-&gt;l2hash);
	free(b-&gt;base_dir);
	free(b-&gt;cfg.file);
	free(b-&gt;cfg.chunks_dir);
	eblob_stat_destroy(b-&gt;stat);
	eblob_stat_destroy(b-&gt;stat_summary);
	(void)lockf(b-&gt;lock_fd, F_ULOCK, 0);
	(void)close(b-&gt;lock_fd);
	free(b);
}
static int eblob_lock_blob(struct eblob_backend *b)
{
	char lock_file[PATH_MAX];
	if (b == NULL)
		return -EINVAL;
	if (snprintf(lock_file, PATH_MAX, "%s.lock", b-&gt;cfg.file) &gt; PATH_MAX)
		return -ENAMETOOLONG;
	b-&gt;lock_fd = open(lock_file, O_RDWR | O_CLOEXEC | O_TRUNC | O_CREAT, 0644);
	if (b-&gt;lock_fd == -1)
		return -errno;
	if (lockf(b-&gt;lock_fd, F_TLOCK, 0) == -1) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: lock file is busy: %d\n", -errno);
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: to find culprit use lsof/fuser: %s\n", lock_file);
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: EB0000: database is locked:\n");
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR,
				"blob: http://doc.reverbrain.com/kb:eblob:eb0000-database-is-locked\n");
		(void)close(b-&gt;lock_fd);
		return -errno;
	}
	return 0;
}
struct eblob_backend *eblob_init(struct eblob_config *c)
{
	struct eblob_backend *b;
	char stat_file[PATH_MAX];
	int err;
	eblob_log(c-&gt;log, EBLOB_LOG_INFO, "blob: start\n");
	b = calloc(1, sizeof(struct eblob_backend));
	if (!b) {
		err = -ENOMEM;
		goto err_out_exit;
	}
	snprintf(stat_file, sizeof(stat_file), "%s.stat", c-&gt;file);
	err = eblob_stat_init_backend(b, stat_file);
	if (err) {
		eblob_log(c-&gt;log, EBLOB_LOG_ERROR,
				"blob: eblob_stat_init_global failed: %s: %s %d.\n",
				stat_file, strerror(-err), err);
		goto err_out_free;
	}
	err = eblob_stat_init_local(&amp;b-&gt;stat_summary);
	if (err) {
		eblob_log(c-&gt;log, EBLOB_LOG_ERROR,
				"blob: eblob_stat_init_local failed: %s %d.\n",
				strerror(-err), err);
		goto err_out_stat_free;
	}
	if (!c-&gt;index_block_size)
		c-&gt;index_block_size = EBLOB_INDEX_DEFAULT_BLOCK_SIZE;
	if (!c-&gt;index_block_bloom_length)
		c-&gt;index_block_bloom_length = EBLOB_INDEX_DEFAULT_BLOCK_BLOOM_LENGTH;
	if (!c-&gt;blob_size)
		c-&gt;blob_size = EBLOB_BLOB_DEFAULT_BLOB_SIZE;
	if (!c-&gt;records_in_blob)
		c-&gt;records_in_blob = EBLOB_BLOB_DEFAULT_RECORDS_IN_BLOB;
	if (!c-&gt;defrag_timeout)
		c-&gt;defrag_timeout = EBLOB_DEFAULT_DEFRAG_TIMEOUT;
	if (!c-&gt;defrag_percentage || (c-&gt;defrag_percentage &lt; 0) || (c-&gt;defrag_percentage &gt; 100))
		c-&gt;defrag_percentage = EBLOB_DEFAULT_DEFRAG_PERCENTAGE;
	if ((c-&gt;defrag_time &lt; 0 || c-&gt;defrag_time &gt; 24)
			|| (c-&gt;defrag_splay &lt; 0 || c-&gt;defrag_time &gt; 24)) {
		c-&gt;defrag_time = EBLOB_DEFAULT_DEFRAG_TIME;
		c-&gt;defrag_splay = EBLOB_DEFAULT_DEFRAG_SPLAY;
	}
	if (!c-&gt;periodic_timeout) {
		c-&gt;periodic_timeout = EBLOB_DEFAULT_PERIODIC_THREAD_TIMEOUT;
	}
	memcpy(&amp;b-&gt;cfg, c, sizeof(struct eblob_config));
	b-&gt;cfg.file = strdup(c-&gt;file);
	if (!b-&gt;cfg.file) {
		errno = -ENOMEM;
		goto err_out_stat_free_local;
	}
	if (c-&gt;chunks_dir) {
		b-&gt;cfg.chunks_dir = strdup(c-&gt;chunks_dir);
		if (!b-&gt;cfg.chunks_dir) {
			errno = -ENOMEM;
			goto err_out_free_file;
		}
	}
	b-&gt;base_dir = strdup(c-&gt;file);
	if (!b-&gt;base_dir) {
		errno = -ENOMEM;
		goto err_out_free_file;
	}
	b-&gt;base_dir = dirname(b-&gt;base_dir);
	err = eblob_lock_blob(b);
	if (err != 0) {
		eblob_log(c-&gt;log, EBLOB_LOG_ERROR, "blob: eblob_lock_blob: FAILED: %s: %d.\n", strerror(-err), err);
		goto err_out_free_base_dir;
	}
	err = eblob_cache_statvfs(b);
	if (err != 0) {
		eblob_log(c-&gt;log, EBLOB_LOG_ERROR, "blob: eblob_cache_statvfs failed: %s: %d.\n", strerror(-err), err);
		goto err_out_lockf;
	}
	err = eblob_mutex_init(&amp;b-&gt;lock);
	if (err != 0)
		goto err_out_lockf;
	INIT_LIST_HEAD(&amp;b-&gt;bases);
	b-&gt;max_index = -1;
	err = eblob_l2hash_init(&amp;b-&gt;l2hash);
	if (err) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: l2hash initialization failed: %s %d.\n", strerror(-err), err);
		goto err_out_lock_destroy;
	}
	err = eblob_hash_init(&amp;b-&gt;hash, sizeof(struct eblob_ram_control));
	if (err) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: hash initialization failed: %s %d.\n", strerror(-err), err);
		goto err_out_l2hash_destroy;
	}
	err = eblob_load_data(b);
	if (err) {
		eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: index iteration failed: %d.\n", err);
		goto err_out_hash_destroy;
	}
	eblob_stat_summary_update(b);
	err = eblob_event_init(&amp;b-&gt;exit_event);
	if (err != 0)
		goto err_out_cleanup;
	err = eblob_mutex_init(&amp;b-&gt;defrag_lock);
	if (err != 0)
		goto err_out_exit_event_destroy;
	err = eblob_mutex_init(&amp;b-&gt;sync_lock);
	if (err != 0)
		goto err_out_defrag_lock_destroy;
	err = eblob_mutex_init(&amp;b-&gt;periodic_lock);
	if (err != 0)
		goto err_out_sync_lock_destroy;
	err = eblob_json_stat_init(b);
	if (err != 0)
		goto err_out_periodic_lock_destroy;
	if (!(b-&gt;cfg.blob_flags &amp; EBLOB_DISABLE_THREADS)) {
		err = pthread_create(&amp;b-&gt;sync_tid, NULL, eblob_sync_thread, b);
		if (err) {
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob sync thread creation failed: %d.\n", err);
			goto err_out_json_stat_destroy;
		}
		err = pthread_create(&amp;b-&gt;defrag_tid, NULL, eblob_defrag_thread, b);
		if (err) {
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob defrag thread creation failed: %d.\n", err);
			goto err_out_join_sync;
		}
		err = pthread_create(&amp;b-&gt;periodic_tid, NULL, eblob_periodic_thread, b);
		if (err) {
			eblob_log(b-&gt;cfg.log, EBLOB_LOG_ERROR, "blob: eblob periodic thread creation failed: %d.\n", err);
			goto err_out_join_defrag;
		}
	}
	return b;
err_out_join_defrag:
	eblob_event_set(&amp;b-&gt;exit_event);
	pthread_join(b-&gt;defrag_tid, NULL);
err_out_join_sync:
	eblob_event_set(&amp;b-&gt;exit_event);
	pthread_join(b-&gt;sync_tid, NULL);
err_out_json_stat_destroy:
	eblob_json_stat_destroy(b);
err_out_periodic_lock_destroy:
	pthread_mutex_destroy(&amp;b-&gt;periodic_lock);
err_out_sync_lock_destroy:
	pthread_mutex_destroy(&amp;b-&gt;sync_lock);
err_out_defrag_lock_destroy:
	pthread_mutex_destroy(&amp;b-&gt;defrag_lock);
err_out_exit_event_destroy:
	eblob_event_destroy(&amp;b-&gt;exit_event);
err_out_cleanup:
	eblob_bases_cleanup(b);
err_out_l2hash_destroy:
	eblob_l2hash_destroy(&amp;b-&gt;l2hash);
err_out_hash_destroy:
	eblob_hash_destroy(&amp;b-&gt;hash);
err_out_lock_destroy:
	pthread_mutex_destroy(&amp;b-&gt;lock);
err_out_lockf:
	(void)lockf(b-&gt;lock_fd, F_ULOCK, 0);
	(void)close(b-&gt;lock_fd);
err_out_free_base_dir:
	free(b-&gt;base_dir);
err_out_free_file:
	free(b-&gt;cfg.file);
	free(b-&gt;cfg.chunks_dir);
err_out_stat_free_local:
	eblob_stat_destroy(b-&gt;stat_summary);
err_out_stat_free:
	eblob_stat_destroy(b-&gt;stat);
err_out_free:
	free(b);
err_out_exit:
	errno = err;
	return NULL;
}
unsigned long long eblob_total_elements(struct eblob_backend *b)
{
	return eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_RECORDS_TOTAL)
		- eblob_stat_get(b-&gt;stat_summary, EBLOB_LST_RECORDS_REMOVED);
}
int eblob_write_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize,
		const void *data, const uint64_t offset, const uint64_t dsize,
		const uint64_t flags)
{
	struct eblob_key ekey;
	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
	return eblob_write(b, &amp;ekey, (void *)data, offset, dsize, flags);
}
int eblob_read_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize,
		int *fd, uint64_t *offset, uint64_t *size)
{
	struct eblob_key ekey;
	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
	return eblob_read(b, &amp;ekey, fd, offset, size);
}
int eblob_remove_hashed(struct eblob_backend *b, const void *key, const uint64_t ksize)
{
	struct eblob_key ekey;
	eblob_hash(b, ekey.id, sizeof(ekey.id), key, ksize);
	return eblob_remove(b, &amp;ekey);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
