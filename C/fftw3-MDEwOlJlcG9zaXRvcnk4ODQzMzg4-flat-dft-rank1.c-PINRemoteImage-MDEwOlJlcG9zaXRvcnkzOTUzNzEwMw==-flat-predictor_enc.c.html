
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.617977528089887%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-rank1.c</h3>
            <pre><code>1  #include "mpi-dft.h"
2  #include "mpi-transpose.h"
3  #include "dft/dft.h"
4  typedef struct {
5       solver super;
6       rdftapply apply; &bsol;* apply_ddft_first or apply_ddft_last */
7       int preserve_input; &bsol;* preserve input even if DESTROY_INPUT was passed */
8  } S;
9  typedef struct {
10       plan_mpi_dft super;
11       triggen *t;
12       plan *cldt, *cld_ddft, *cld_dft;
13       INT roff, ioff;
14       int preserve_input;
15       INT vn, xmin, xmax, xs, m, r;
16  } P;
17  static void do_twiddle(triggen *t, INT ir, INT m, INT vn, R *xr, R *xi)
18  {
19       void (*rotate)(triggen *, INT, R, R, R *) = t->rotate;
20       INT im, iv;
21       for (im = 0; im < m; ++im)
22  	  for (iv = 0; iv < vn; ++iv) {
23  	       R c[2];
24  	       rotate(t, ir * im, *xr, *xi, c);
25  	       *xr = c[0]; *xi = c[1];
26  	       xr += 2; xi += 2;
27  	  }
28  }
29  static void apply_ddft_first(const plan *ego_, R *I, R *O)
30  {
31       const P *ego = (const P *) ego_;
32       plan_dft *cld_dft;
33       plan_rdft *cldt, *cld_ddft;
34       INT roff, ioff, im, mmax, ms, r, vn;
35       triggen *t;
36       R *dI, *dO;
37       cld_ddft = (plan_rdft *) ego->cld_ddft;
38       cld_ddft->apply(ego->cld_ddft, I, O);
39       cldt = (plan_rdft *) ego->cldt;
40       if (ego->preserve_input || !cldt) I = O;
41       cld_dft = (plan_dft *) ego->cld_dft;
42       roff = ego->roff; ioff = ego->ioff;
43       mmax = ego->xmax; ms = ego->xs;
44       t = ego->t; r = ego->r; vn = ego->vn;
45       dI = O; dO = I;
46       for (im = ego->xmin; im <= mmax; ++im) {
47  	  do_twiddle(t, im, r, vn, dI+roff, dI+ioff);
48  	  cld_dft->apply((plan *) cld_dft, dI+roff, dI+ioff, dO+roff, dO+ioff);
49  	  dI += ms; dO += ms;
50       }
51       if (cldt) 
52  	  cldt->apply((plan *) cldt, I, O);
53  }
54  static void apply_ddft_last(const plan *ego_, R *I, R *O)
55  {
56       const P *ego = (const P *) ego_;
57       plan_dft *cld_dft;
58       plan_rdft *cldt, *cld_ddft;
59       INT roff, ioff, ir, rmax, rs, m, vn;
60       triggen *t;
61       R *dI, *dO0, *dO;
62       cldt = (plan_rdft *) ego->cldt;
63       if (cldt) {
64  	  cldt->apply((plan *) cldt, I, O);
65  	  dI = O;
66       }
67       else 
68  	  dI = I;
69       if (ego->preserve_input) dO = O; else dO = I;
70       dO0 = dO;
71       cld_dft = (plan_dft *) ego->cld_dft;
72       roff = ego->roff; ioff = ego->ioff;
73       rmax = ego->xmax; rs = ego->xs;
74       t = ego->t; m = ego->m; vn = ego->vn;
75       for (ir = ego->xmin; ir <= rmax; ++ir) {
76  	  cld_dft->apply((plan *) cld_dft, dI+roff, dI+ioff, dO+roff, dO+ioff);
77  	  do_twiddle(t, ir, m, vn, dO+roff, dO+ioff);
78  	  dI += rs; dO += rs;
79       }
80       cld_ddft = (plan_rdft *) ego->cld_ddft;
81       cld_ddft->apply(ego->cld_ddft, dO0, O);
82  }
<span onclick='openModal()' class='match'>83  static int applicable(const S *ego, const problem *p_,
84  		      const planner *plnr,
85  		      INT *r, INT rblock[2], INT mblock[2])
86  {
87       const problem_mpi_dft *p = (const problem_mpi_dft *) p_;
</span>88       int n_pes;
89       MPI_Comm_size(p->comm, &n_pes);
90       return (1
91  	     && p->sz->rnk == 1
92  	     && ONLY_SCRAMBLEDP(p->flags)
93  	     && (!ego->preserve_input || (!NO_DESTROY_INPUTP(plnr)
94                                            && p->I != p->O))
95  	     && (!(p->flags & SCRAMBLED_IN) || ego->apply == apply_ddft_last)
96  	     && (!(p->flags & SCRAMBLED_OUT) || ego->apply == apply_ddft_first)
97  	     && (!NO_SLOWP(plnr) &bsol;* slow if dft-serial is applicable */
98                   || !XM(dft_serial_applicable)(p))
99  	     && (p->vn < n_pes || p->flags)
100  	     && (*r = XM(choose_radix)(p->sz->dims[0], n_pes,
101  				       p->flags, p->sign,
102  				       rblock, mblock))
103  	     && (!NO_UGLYP(plnr)
104  		 || !(*r == n_pes && ego->apply == apply_ddft_first)
105  		 || !(p->sz->dims[0].n / *r == n_pes 
106  		      && ego->apply == apply_ddft_last))
107  	  );
108  }
109  static void awake(plan *ego_, enum wakefulness wakefulness)
110  {
111       P *ego = (P *) ego_;
112       X(plan_awake)(ego->cldt, wakefulness);
113       X(plan_awake)(ego->cld_dft, wakefulness);
114       X(plan_awake)(ego->cld_ddft, wakefulness);
115       switch (wakefulness) {
116           case SLEEPY:
117                X(triggen_destroy)(ego->t); ego->t = 0;
118                break;
119           default:
120                ego->t = X(mktriggen)(AWAKE_SQRTN_TABLE, ego->r * ego->m);
121                break;
122       }
123  }
124  static void destroy(plan *ego_)
125  {
126       P *ego = (P *) ego_;
127       X(plan_destroy_internal)(ego->cldt);
128       X(plan_destroy_internal)(ego->cld_dft);
129       X(plan_destroy_internal)(ego->cld_ddft);
130  }
131  static void print(const plan *ego_, printer *p)
132  {
133       const P *ego = (const P *) ego_;
134       p->print(p, "(mpi-dft-rank1/%D%s%s%(%p%)%(%p%)%(%p%))",
135  	      ego->r,
136  	      ego->super.apply == apply_ddft_first ? "/first" : "/last",
137  	      ego->preserve_input==2 ?"/p":"",
138  	      ego->cld_ddft, ego->cld_dft, ego->cldt);
139  }
140  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
141  {
142       const S *ego = (const S *) ego_;
143       const problem_mpi_dft *p;
144       P *pln;
145       plan *cld_dft = 0, *cld_ddft = 0, *cldt = 0;
146       R *ri, *ii, *ro, *io, *I, *O;
147       INT r, rblock[2], m, mblock[2], rp, mp, mpblock[2], mpb;
148       int my_pe, n_pes, preserve_input, ddft_first;
149       dtensor *sz;
150       static const plan_adt padt = {
151            XM(dft_solve), awake, print, destroy
152       };
153       UNUSED(ego);
154       if (!applicable(ego, p_, plnr, &r, rblock, mblock))
155            return (plan *) 0;
156       p = (const problem_mpi_dft *) p_;
157       MPI_Comm_rank(p->comm, &my_pe);
158       MPI_Comm_size(p->comm, &n_pes);
159       m = p->sz->dims[0].n / r;
160       if ((ddft_first = (ego->apply == apply_ddft_first))) {
161  	  rp = r; mp = m;
162  	  mpblock[IB] = mblock[IB]; mpblock[OB] = mblock[OB];
163  	  mpb = XM(block)(mp, mpblock[OB], my_pe);
164       }
165       else {
166  	  rp = m; mp = r;
167  	  mpblock[IB] = rblock[IB]; mpblock[OB] = rblock[OB];
168  	  mpb = XM(block)(mp, mpblock[IB], my_pe);
169       }
170       preserve_input = ego->preserve_input ? 2 : NO_DESTROY_INPUTP(plnr);
171       sz = XM(mkdtensor)(1);
172       sz->dims[0].n = mp;
173       sz->dims[0].b[IB] = mpblock[IB];
174       sz->dims[0].b[OB] = mpblock[OB];
175       I = (ddft_first || !preserve_input) ? p->I : p->O;
176       O = p->O;
177       cld_ddft = X(mkplan_d)(plnr, XM(mkproblem_dft_d)(sz, rp * p->vn,
178  						      I, O, p->comm, p->sign,
179  						      RANK1_BIGVEC_ONLY));
180       if (XM(any_true)(!cld_ddft, p->comm)) goto nada;
181       I = TAINT((ddft_first || !p->flags) ? p->O : p->I, rp * p->vn * 2);
182       O = TAINT((preserve_input || (ddft_first && p->flags)) ? p->O : p->I, 
183  	       rp * p->vn * 2);
184       X(extract_reim)(p->sign, I, &ri, &ii);
185       X(extract_reim)(p->sign, O, &ro, &io);
186       cld_dft = X(mkplan_d)(plnr,
187  			X(mkproblem_dft_d)(X(mktensor_1d)(rp, p->vn*2,p->vn*2),
188  					   X(mktensor_1d)(p->vn, 2, 2),
189  					   ri, ii, ro, io));
190       if (XM(any_true)(!cld_dft, p->comm)) goto nada;
191       if (!p->flags) { &bsol;* !(SCRAMBLED_IN or SCRAMBLED_OUT) */
192  	  I = (ddft_first && preserve_input) ? p->O : p->I;
193  	  O = p->O;
194  	  cldt = X(mkplan_d)(plnr,
195  			     XM(mkproblem_transpose)(
196  				  m, r, p->vn * 2,
197  				  I, O,
198  				  ddft_first ? mblock[OB] : mblock[IB],
199  				  ddft_first ? rblock[OB] : rblock[IB],
200  				  p->comm, 0));
201  	  if (XM(any_true)(!cldt, p->comm)) goto nada;	  
202       }
203       pln = MKPLAN_MPI_DFT(P, &padt, ego->apply);
204       pln->cld_ddft = cld_ddft;
205       pln->cld_dft = cld_dft;
206       pln->cldt = cldt;
207       pln->preserve_input = preserve_input;
208       X(extract_reim)(p->sign, p->O, &ro, &io);
209       pln->roff = ro - p->O;
210       pln->ioff = io - p->O;
211       pln->vn = p->vn;
212       pln->m = m;
213       pln->r = r;
214       pln->xmin = (ddft_first ? mblock[OB] : rblock[IB]) * my_pe;
215       pln->xmax = pln->xmin + mpb - 1;
216       pln->xs = rp * p->vn * 2;
217       pln->t = 0;
218       X(ops_add)(&cld_ddft->ops, &cld_dft->ops, &pln->super.super.ops);
219       if (cldt) X(ops_add2)(&cldt->ops, &pln->super.super.ops);
220       {
221            double n0 = (1 + pln->xmax - pln->xmin) * (mp - 1) * pln->vn;
222            pln->super.super.ops.mul += 8 * n0;
223            pln->super.super.ops.add += 4 * n0;
224            pln->super.super.ops.other += 8 * n0;
225       }
226       return &(pln->super.super);
227   nada:
228       X(plan_destroy_internal)(cldt);
229       X(plan_destroy_internal)(cld_dft);
230       X(plan_destroy_internal)(cld_ddft);
231       return (plan *) 0;
232  }
233  static solver *mksolver(rdftapply apply, int preserve_input)
234  {
235       static const solver_adt sadt = { PROBLEM_MPI_DFT, mkplan, 0 };
236       S *slv = MKSOLVER(S, &sadt);
237       slv->apply = apply;
238       slv->preserve_input = preserve_input;
239       return &(slv->super);
240  }
241  void XM(dft_rank1_register)(planner *p)
242  {
243       rdftapply apply[] = { apply_ddft_first, apply_ddft_last };
244       unsigned int iapply;
245       int preserve_input;
246       for (iapply = 0; iapply < sizeof(apply) / sizeof(apply[0]); ++iapply)
247  	  for (preserve_input = 0; preserve_input <= 1; ++preserve_input)
248  	       REGISTER_SOLVER(p, mksolver(apply[iapply], preserve_input));
249  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-predictor_enc.c</h3>
            <pre><code>1  #include "src/dsp/lossless.h"
2  #include "src/dsp/lossless_common.h"
3  #include "src/enc/vp8li_enc.h"
4  #define MAX_DIFF_COST (1e30f)
5  static const float kSpatialPredictorBias = 15.f;
6  static const int kPredLowEffort = 11;
7  static const uint32_t kMaskAlpha = 0xff000000;
8  static WEBP_INLINE int GetMin(int a, int b) { return (a > b) ? b : a; }
9  static float PredictionCostSpatial(const int counts[256], int weight_0,
10                                     double exp_val) {
11    const int significant_symbols = 256 >> 4;
12    const double exp_decay_factor = 0.6;
13    double bits = weight_0 * counts[0];
14    int i;
15    for (i = 1; i < significant_symbols; ++i) {
16      bits += exp_val * (counts[i] + counts[256 - i]);
17      exp_val *= exp_decay_factor;
18    }
19    return (float)(-0.1 * bits);
20  }
21  static float PredictionCostSpatialHistogram(const int accumulated[4][256],
22                                              const int tile[4][256]) {
23    int i;
24    double retval = 0;
25    for (i = 0; i < 4; ++i) {
26      const double kExpValue = 0.94;
27      retval += PredictionCostSpatial(tile[i], 1, kExpValue);
28      retval += VP8LCombinedShannonEntropy(tile[i], accumulated[i]);
29    }
30    return (float)retval;
31  }
32  static WEBP_INLINE void UpdateHisto(int histo_argb[4][256], uint32_t argb) {
33    ++histo_argb[0][argb >> 24];
34    ++histo_argb[1][(argb >> 16) & 0xff];
35    ++histo_argb[2][(argb >> 8) & 0xff];
36    ++histo_argb[3][argb & 0xff];
37  }
38  static WEBP_INLINE void PredictBatch(int mode, int x_start, int y,
39                                       int num_pixels, const uint32_t* current,
40                                       const uint32_t* upper, uint32_t* out) {
41    if (x_start == 0) {
42      if (y == 0) {
43        VP8LPredictorsSub[0](current, NULL, 1, out);
44      } else {
45        VP8LPredictorsSub[2](current, upper, 1, out);
46      }
47      ++x_start;
48      ++out;
49      --num_pixels;
50    }
51    if (y == 0) {
52      VP8LPredictorsSub[1](current + x_start, NULL, num_pixels, out);
53    } else {
54      VP8LPredictorsSub[mode](current + x_start, upper + x_start, num_pixels,
55                              out);
56    }
57  }
58  #if (WEBP_NEAR_LOSSLESS == 1)
59  static WEBP_INLINE int GetMax(int a, int b) { return (a < b) ? b : a; }
60  static int MaxDiffBetweenPixels(uint32_t p1, uint32_t p2) {
61    const int diff_a = abs((int)(p1 >> 24) - (int)(p2 >> 24));
62    const int diff_r = abs((int)((p1 >> 16) & 0xff) - (int)((p2 >> 16) & 0xff));
63    const int diff_g = abs((int)((p1 >> 8) & 0xff) - (int)((p2 >> 8) & 0xff));
64    const int diff_b = abs((int)(p1 & 0xff) - (int)(p2 & 0xff));
65    return GetMax(GetMax(diff_a, diff_r), GetMax(diff_g, diff_b));
66  }
67  static int MaxDiffAroundPixel(uint32_t current, uint32_t up, uint32_t down,
68                                uint32_t left, uint32_t right) {
69    const int diff_up = MaxDiffBetweenPixels(current, up);
70    const int diff_down = MaxDiffBetweenPixels(current, down);
71    const int diff_left = MaxDiffBetweenPixels(current, left);
72    const int diff_right = MaxDiffBetweenPixels(current, right);
73    return GetMax(GetMax(diff_up, diff_down), GetMax(diff_left, diff_right));
74  }
75  static uint32_t AddGreenToBlueAndRed(uint32_t argb) {
76    const uint32_t green = (argb >> 8) & 0xff;
77    uint32_t red_blue = argb & 0x00ff00ffu;
78    red_blue += (green << 16) | green;
79    red_blue &= 0x00ff00ffu;
80    return (argb & 0xff00ff00u) | red_blue;
81  }
82  static void MaxDiffsForRow(int width, int stride, const uint32_t* const argb,
83                             uint8_t* const max_diffs, int used_subtract_green) {
84    uint32_t current, up, down, left, right;
85    int x;
86    if (width <= 2) return;
87    current = argb[0];
88    right = argb[1];
89    if (used_subtract_green) {
90      current = AddGreenToBlueAndRed(current);
91      right = AddGreenToBlueAndRed(right);
92    }
93    for (x = 1; x < width - 1; ++x) {
94      up = argb[-stride + x];
95      down = argb[stride + x];
96      left = current;
97      current = right;
98      right = argb[x + 1];
99      if (used_subtract_green) {
100        up = AddGreenToBlueAndRed(up);
101        down = AddGreenToBlueAndRed(down);
102        right = AddGreenToBlueAndRed(right);
103      }
104      max_diffs[x] = MaxDiffAroundPixel(current, up, down, left, right);
105    }
106  }
107  static uint8_t NearLosslessComponent(uint8_t value, uint8_t predict,
108                                       uint8_t boundary, int quantization) {
109    const int residual = (value - predict) & 0xff;
110    const int boundary_residual = (boundary - predict) & 0xff;
111    const int lower = residual & ~(quantization - 1);
112    const int upper = lower + quantization;
113    const int bias = ((boundary - value) & 0xff) < boundary_residual;
114    if (residual - lower < upper - residual + bias) {
115      if (residual > boundary_residual && lower <= boundary_residual) {
116        return lower + (quantization >> 1);
117      }
118      return lower;
119    } else {
120      if (residual <= boundary_residual && upper > boundary_residual) {
121        return lower + (quantization >> 1);
122      }
123      return upper & 0xff;
124    }
125  }
126  static WEBP_INLINE uint8_t NearLosslessDiff(uint8_t a, uint8_t b) {
127    return (uint8_t)((((int)(a) - (int)(b))) & 0xff);
128  }
129  static uint32_t NearLossless(uint32_t value, uint32_t predict,
130                               int max_quantization, int max_diff,
131                               int used_subtract_green) {
132    int quantization;
133    uint8_t new_green = 0;
134    uint8_t green_diff = 0;
135    uint8_t a, r, g, b;
136    if (max_diff <= 2) {
137      return VP8LSubPixels(value, predict);
138    }
139    quantization = max_quantization;
140    while (quantization >= max_diff) {
141      quantization >>= 1;
142    }
143    if ((value >> 24) == 0 || (value >> 24) == 0xff) {
144      a = NearLosslessDiff((value >> 24) & 0xff, (predict >> 24) & 0xff);
145    } else {
146      a = NearLosslessComponent(value >> 24, predict >> 24, 0xff, quantization);
147    }
148    g = NearLosslessComponent((value >> 8) & 0xff, (predict >> 8) & 0xff, 0xff,
149                              quantization);
150    if (used_subtract_green) {
151      new_green = ((predict >> 8) + g) & 0xff;
152      green_diff = NearLosslessDiff(new_green, (value >> 8) & 0xff);
153    }
154    r = NearLosslessComponent(NearLosslessDiff((value >> 16) & 0xff, green_diff),
155                              (predict >> 16) & 0xff, 0xff - new_green,
156                              quantization);
157    b = NearLosslessComponent(NearLosslessDiff(value & 0xff, green_diff),
158                              predict & 0xff, 0xff - new_green, quantization);
159    return ((uint32_t)a << 24) | ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;
160  }
161  #endif  
162  static WEBP_INLINE void GetResidual(
163      int width, int height, uint32_t* const upper_row,
164      uint32_t* const current_row, const uint8_t* const max_diffs, int mode,
165      int x_start, int x_end, int y, int max_quantization, int exact,
166      int used_subtract_green, uint32_t* const out) {
167    if (exact) {
168      PredictBatch(mode, x_start, y, x_end - x_start, current_row, upper_row,
169                   out);
170    } else {
171      const VP8LPredictorFunc pred_func = VP8LPredictors[mode];
172      int x;
173      for (x = x_start; x < x_end; ++x) {
174        uint32_t predict;
175        uint32_t residual;
176        if (y == 0) {
177          predict = (x == 0) ? ARGB_BLACK : current_row[x - 1];  
178        } else if (x == 0) {
179          predict = upper_row[x];  
180        } else {
181          predict = pred_func(current_row[x - 1], upper_row + x);
182        }
183  #if (WEBP_NEAR_LOSSLESS == 1)
184        if (max_quantization == 1 || mode == 0 || y == 0 || y == height - 1 ||
185            x == 0 || x == width - 1) {
186          residual = VP8LSubPixels(current_row[x], predict);
187        } else {
188          residual = NearLossless(current_row[x], predict, max_quantization,
189                                  max_diffs[x], used_subtract_green);
190          current_row[x] = VP8LAddPixels(predict, residual);
191        }
192  #else
193        (void)max_diffs;
194        (void)height;
195        (void)max_quantization;
196        (void)used_subtract_green;
197        residual = VP8LSubPixels(current_row[x], predict);
198  #endif
199        if ((current_row[x] & kMaskAlpha) == 0) {
200          residual &= kMaskAlpha;
201          current_row[x] = predict & ~kMaskAlpha;
202          if (x == 0 && y != 0) upper_row[width] = current_row[0];
203        }
204        out[x - x_start] = residual;
205      }
206    }
207  }
208  static int GetBestPredictorForTile(int width, int height,
209                                     int tile_x, int tile_y, int bits,
210                                     int accumulated[4][256],
211                                     uint32_t* const argb_scratch,
212                                     const uint32_t* const argb,
213                                     int max_quantization,
214                                     int exact, int used_subtract_green,
215                                     const uint32_t* const modes) {
216    const int kNumPredModes = 14;
217    const int start_x = tile_x << bits;
218    const int start_y = tile_y << bits;
219    const int tile_size = 1 << bits;
220    const int max_y = GetMin(tile_size, height - start_y);
221    const int max_x = GetMin(tile_size, width - start_x);
222    const int have_left = (start_x > 0);
223    const int context_start_x = start_x - have_left;
224  #if (WEBP_NEAR_LOSSLESS == 1)
225    const int context_width = max_x + have_left + (max_x < width - start_x);
226  #endif
227    const int tiles_per_row = VP8LSubSampleSize(width, bits);
228    const int left_mode = (tile_x > 0) ?
229        (modes[tile_y * tiles_per_row + tile_x - 1] >> 8) & 0xff : 0xff;
230    const int above_mode = (tile_y > 0) ?
231        (modes[(tile_y - 1) * tiles_per_row + tile_x] >> 8) & 0xff : 0xff;
232    uint32_t* upper_row = argb_scratch;
233    uint32_t* current_row = upper_row + width + 1;
234    uint8_t* const max_diffs = (uint8_t*)(current_row + width + 1);
235    float best_diff = MAX_DIFF_COST;
236    int best_mode = 0;
237    int mode;
238    int histo_stack_1[4][256];
239    int histo_stack_2[4][256];
240    int (*histo_argb)[256] = histo_stack_1;
241    int (*best_histo)[256] = histo_stack_2;
242    int i, j;
243    uint32_t residuals[1 << MAX_TRANSFORM_BITS];
244    assert(bits <= MAX_TRANSFORM_BITS);
245    assert(max_x <= (1 << MAX_TRANSFORM_BITS));
246    for (mode = 0; mode < kNumPredModes; ++mode) {
247      float cur_diff;
248      int relative_y;
249      memset(histo_argb, 0, sizeof(histo_stack_1));
250      if (start_y > 0) {
251        memcpy(current_row + context_start_x,
252               argb + (start_y - 1) * width + context_start_x,
253               sizeof(*argb) * (max_x + have_left + 1));
254      }
255      for (relative_y = 0; relative_y < max_y; ++relative_y) {
256        const int y = start_y + relative_y;
257        int relative_x;
258        uint32_t* tmp = upper_row;
259        upper_row = current_row;
260        current_row = tmp;
261        memcpy(current_row + context_start_x,
262               argb + y * width + context_start_x,
263               sizeof(*argb) * (max_x + have_left + (y + 1 < height)));
264  #if (WEBP_NEAR_LOSSLESS == 1)
265        if (max_quantization > 1 && y >= 1 && y + 1 < height) {
266          MaxDiffsForRow(context_width, width, argb + y * width + context_start_x,
267                         max_diffs + context_start_x, used_subtract_green);
268        }
269  #endif
270        GetResidual(width, height, upper_row, current_row, max_diffs, mode,
271                    start_x, start_x + max_x, y, max_quantization, exact,
272                    used_subtract_green, residuals);
273        for (relative_x = 0; relative_x < max_x; ++relative_x) {
274          UpdateHisto(histo_argb, residuals[relative_x]);
275        }
276      }
277      cur_diff = PredictionCostSpatialHistogram(
278          (const int (*)[256])accumulated, (const int (*)[256])histo_argb);
279      if (mode == left_mode) cur_diff -= kSpatialPredictorBias;
280      if (mode == above_mode) cur_diff -= kSpatialPredictorBias;
281      if (cur_diff < best_diff) {
282        int (*tmp)[256] = histo_argb;
283        histo_argb = best_histo;
284        best_histo = tmp;
285        best_diff = cur_diff;
286        best_mode = mode;
287      }
288    }
289    for (i = 0; i < 4; i++) {
290      for (j = 0; j < 256; j++) {
291        accumulated[i][j] += best_histo[i][j];
292      }
293    }
294    return best_mode;
295  }
296  static void CopyImageWithPrediction(int width, int height,
297                                      int bits, uint32_t* const modes,
298                                      uint32_t* const argb_scratch,
299                                      uint32_t* const argb,
300                                      int low_effort, int max_quantization,
301                                      int exact, int used_subtract_green) {
302    const int tiles_per_row = VP8LSubSampleSize(width, bits);
303    uint32_t* upper_row = argb_scratch;
304    uint32_t* current_row = upper_row + width + 1;
305    uint8_t* current_max_diffs = (uint8_t*)(current_row + width + 1);
306  #if (WEBP_NEAR_LOSSLESS == 1)
307    uint8_t* lower_max_diffs = current_max_diffs + width;
308  #endif
309    int y;
310    for (y = 0; y < height; ++y) {
311      int x;
312      uint32_t* const tmp32 = upper_row;
313      upper_row = current_row;
314      current_row = tmp32;
315      memcpy(current_row, argb + y * width,
316             sizeof(*argb) * (width + (y + 1 < height)));
317      if (low_effort) {
318        PredictBatch(kPredLowEffort, 0, y, width, current_row, upper_row,
319                     argb + y * width);
320      } else {
321  #if (WEBP_NEAR_LOSSLESS == 1)
322        if (max_quantization > 1) {
323          uint8_t* const tmp8 = current_max_diffs;
324          current_max_diffs = lower_max_diffs;
325          lower_max_diffs = tmp8;
326          if (y + 2 < height) {
327            MaxDiffsForRow(width, width, argb + (y + 1) * width, lower_max_diffs,
328                           used_subtract_green);
329          }
330        }
331  #endif
332        for (x = 0; x < width;) {
333          const int mode =
334              (modes[(y >> bits) * tiles_per_row + (x >> bits)] >> 8) & 0xff;
335          int x_end = x + (1 << bits);
336          if (x_end > width) x_end = width;
337          GetResidual(width, height, upper_row, current_row, current_max_diffs,
338                      mode, x, x_end, y, max_quantization, exact,
339                      used_subtract_green, argb + y * width + x);
340          x = x_end;
341        }
342      }
343    }
344  }
<span onclick='openModal()' class='match'>345  void VP8LResidualImage(int width, int height, int bits, int low_effort,
346                         uint32_t* const argb, uint32_t* const argb_scratch,
347                         uint32_t* const image, int near_lossless_quality,
348                         int exact, int used_subtract_green) {
349    const int tiles_per_row = VP8LSubSampleSize(width, bits);
</span>350    const int tiles_per_col = VP8LSubSampleSize(height, bits);
351    int tile_y;
352    int histo[4][256];
353    const int max_quantization = 1 << VP8LNearLosslessBits(near_lossless_quality);
354    if (low_effort) {
355      int i;
356      for (i = 0; i < tiles_per_row * tiles_per_col; ++i) {
357        image[i] = ARGB_BLACK | (kPredLowEffort << 8);
358      }
359    } else {
360      memset(histo, 0, sizeof(histo));
361      for (tile_y = 0; tile_y < tiles_per_col; ++tile_y) {
362        int tile_x;
363        for (tile_x = 0; tile_x < tiles_per_row; ++tile_x) {
364          const int pred = GetBestPredictorForTile(width, height, tile_x, tile_y,
365              bits, histo, argb_scratch, argb, max_quantization, exact,
366              used_subtract_green, image);
367          image[tile_y * tiles_per_row + tile_x] = ARGB_BLACK | (pred << 8);
368        }
369      }
370    }
371    CopyImageWithPrediction(width, height, bits, image, argb_scratch, argb,
372                            low_effort, max_quantization, exact,
373                            used_subtract_green);
374  }
375  static WEBP_INLINE void MultipliersClear(VP8LMultipliers* const m) {
376    m->green_to_red_ = 0;
377    m->green_to_blue_ = 0;
378    m->red_to_blue_ = 0;
379  }
380  static WEBP_INLINE void ColorCodeToMultipliers(uint32_t color_code,
381                                                 VP8LMultipliers* const m) {
382    m->green_to_red_  = (color_code >>  0) & 0xff;
383    m->green_to_blue_ = (color_code >>  8) & 0xff;
384    m->red_to_blue_   = (color_code >> 16) & 0xff;
385  }
386  static WEBP_INLINE uint32_t MultipliersToColorCode(
387      const VP8LMultipliers* const m) {
388    return 0xff000000u |
389           ((uint32_t)(m->red_to_blue_) << 16) |
390           ((uint32_t)(m->green_to_blue_) << 8) |
391           m->green_to_red_;
392  }
393  static float PredictionCostCrossColor(const int accumulated[256],
394                                        const int counts[256]) {
395    static const double kExpValue = 2.4;
396    return VP8LCombinedShannonEntropy(counts, accumulated) +
397           PredictionCostSpatial(counts, 3, kExpValue);
398  }
399  static float GetPredictionCostCrossColorRed(
400      const uint32_t* argb, int stride, int tile_width, int tile_height,
401      VP8LMultipliers prev_x, VP8LMultipliers prev_y, int green_to_red,
402      const int accumulated_red_histo[256]) {
403    int histo[256] = { 0 };
404    float cur_diff;
405    VP8LCollectColorRedTransforms(argb, stride, tile_width, tile_height,
406                                  green_to_red, histo);
407    cur_diff = PredictionCostCrossColor(accumulated_red_histo, histo);
408    if ((uint8_t)green_to_red == prev_x.green_to_red_) {
409      cur_diff -= 3;  
410    }
411    if ((uint8_t)green_to_red == prev_y.green_to_red_) {
412      cur_diff -= 3;  
413    }
414    if (green_to_red == 0) {
415      cur_diff -= 3;
416    }
417    return cur_diff;
418  }
419  static void GetBestGreenToRed(
420      const uint32_t* argb, int stride, int tile_width, int tile_height,
421      VP8LMultipliers prev_x, VP8LMultipliers prev_y, int quality,
422      const int accumulated_red_histo[256], VP8LMultipliers* const best_tx) {
423    const int kMaxIters = 4 + ((7 * quality) >> 8);  
424    int green_to_red_best = 0;
425    int iter, offset;
426    float best_diff = GetPredictionCostCrossColorRed(
427        argb, stride, tile_width, tile_height, prev_x, prev_y,
428        green_to_red_best, accumulated_red_histo);
429    for (iter = 0; iter < kMaxIters; ++iter) {
430      const int delta = 32 >> iter;
431      for (offset = -delta; offset <= delta; offset += 2 * delta) {
432        const int green_to_red_cur = offset + green_to_red_best;
433        const float cur_diff = GetPredictionCostCrossColorRed(
434            argb, stride, tile_width, tile_height, prev_x, prev_y,
435            green_to_red_cur, accumulated_red_histo);
436        if (cur_diff < best_diff) {
437          best_diff = cur_diff;
438          green_to_red_best = green_to_red_cur;
439        }
440      }
441    }
442    best_tx->green_to_red_ = (green_to_red_best & 0xff);
443  }
444  static float GetPredictionCostCrossColorBlue(
445      const uint32_t* argb, int stride, int tile_width, int tile_height,
446      VP8LMultipliers prev_x, VP8LMultipliers prev_y,
447      int green_to_blue, int red_to_blue, const int accumulated_blue_histo[256]) {
448    int histo[256] = { 0 };
449    float cur_diff;
450    VP8LCollectColorBlueTransforms(argb, stride, tile_width, tile_height,
451                                   green_to_blue, red_to_blue, histo);
452    cur_diff = PredictionCostCrossColor(accumulated_blue_histo, histo);
453    if ((uint8_t)green_to_blue == prev_x.green_to_blue_) {
454      cur_diff -= 3;  
455    }
456    if ((uint8_t)green_to_blue == prev_y.green_to_blue_) {
457      cur_diff -= 3;  
458    }
459    if ((uint8_t)red_to_blue == prev_x.red_to_blue_) {
460      cur_diff -= 3;  
461    }
462    if ((uint8_t)red_to_blue == prev_y.red_to_blue_) {
463      cur_diff -= 3;  
464    }
465    if (green_to_blue == 0) {
466      cur_diff -= 3;
467    }
468    if (red_to_blue == 0) {
469      cur_diff -= 3;
470    }
471    return cur_diff;
472  }
473  #define kGreenRedToBlueNumAxis 8
474  #define kGreenRedToBlueMaxIters 7
475  static void GetBestGreenRedToBlue(
476      const uint32_t* argb, int stride, int tile_width, int tile_height,
477      VP8LMultipliers prev_x, VP8LMultipliers prev_y, int quality,
478      const int accumulated_blue_histo[256],
479      VP8LMultipliers* const best_tx) {
480    const int8_t offset[kGreenRedToBlueNumAxis][2] =
481        {{0, -1}, {0, 1}, {-1, 0}, {1, 0}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
482    const int8_t delta_lut[kGreenRedToBlueMaxIters] = { 16, 16, 8, 4, 2, 2, 2 };
483    const int iters =
484        (quality < 25) ? 1 : (quality > 50) ? kGreenRedToBlueMaxIters : 4;
485    int green_to_blue_best = 0;
486    int red_to_blue_best = 0;
487    int iter;
488    float best_diff = GetPredictionCostCrossColorBlue(
489        argb, stride, tile_width, tile_height, prev_x, prev_y,
490        green_to_blue_best, red_to_blue_best, accumulated_blue_histo);
491    for (iter = 0; iter < iters; ++iter) {
492      const int delta = delta_lut[iter];
493      int axis;
494      for (axis = 0; axis < kGreenRedToBlueNumAxis; ++axis) {
495        const int green_to_blue_cur =
496            offset[axis][0] * delta + green_to_blue_best;
497        const int red_to_blue_cur = offset[axis][1] * delta + red_to_blue_best;
498        const float cur_diff = GetPredictionCostCrossColorBlue(
499            argb, stride, tile_width, tile_height, prev_x, prev_y,
500            green_to_blue_cur, red_to_blue_cur, accumulated_blue_histo);
501        if (cur_diff < best_diff) {
502          best_diff = cur_diff;
503          green_to_blue_best = green_to_blue_cur;
504          red_to_blue_best = red_to_blue_cur;
505        }
506        if (quality < 25 && iter == 4) {
507          break;  
508        }
509      }
510      if (delta == 2 && green_to_blue_best == 0 && red_to_blue_best == 0) {
511        break;  
512      }
513    }
514    best_tx->green_to_blue_ = green_to_blue_best & 0xff;
515    best_tx->red_to_blue_ = red_to_blue_best & 0xff;
516  }
517  #undef kGreenRedToBlueMaxIters
518  #undef kGreenRedToBlueNumAxis
519  static VP8LMultipliers GetBestColorTransformForTile(
520      int tile_x, int tile_y, int bits,
521      VP8LMultipliers prev_x,
522      VP8LMultipliers prev_y,
523      int quality, int xsize, int ysize,
524      const int accumulated_red_histo[256],
525      const int accumulated_blue_histo[256],
526      const uint32_t* const argb) {
527    const int max_tile_size = 1 << bits;
528    const int tile_y_offset = tile_y * max_tile_size;
529    const int tile_x_offset = tile_x * max_tile_size;
530    const int all_x_max = GetMin(tile_x_offset + max_tile_size, xsize);
531    const int all_y_max = GetMin(tile_y_offset + max_tile_size, ysize);
532    const int tile_width = all_x_max - tile_x_offset;
533    const int tile_height = all_y_max - tile_y_offset;
534    const uint32_t* const tile_argb = argb + tile_y_offset * xsize
535                                    + tile_x_offset;
536    VP8LMultipliers best_tx;
537    MultipliersClear(&best_tx);
538    GetBestGreenToRed(tile_argb, xsize, tile_width, tile_height,
539                      prev_x, prev_y, quality, accumulated_red_histo, &best_tx);
540    GetBestGreenRedToBlue(tile_argb, xsize, tile_width, tile_height,
541                          prev_x, prev_y, quality, accumulated_blue_histo,
542                          &best_tx);
543    return best_tx;
544  }
545  static void CopyTileWithColorTransform(int xsize, int ysize,
546                                         int tile_x, int tile_y,
547                                         int max_tile_size,
548                                         VP8LMultipliers color_transform,
549                                         uint32_t* argb) {
550    const int xscan = GetMin(max_tile_size, xsize - tile_x);
551    int yscan = GetMin(max_tile_size, ysize - tile_y);
552    argb += tile_y * xsize + tile_x;
553    while (yscan-- > 0) {
554      VP8LTransformColor(&color_transform, argb, xscan);
555      argb += xsize;
556    }
557  }
558  void VP8LColorSpaceTransform(int width, int height, int bits, int quality,
559                               uint32_t* const argb, uint32_t* image) {
560    const int max_tile_size = 1 << bits;
561    const int tile_xsize = VP8LSubSampleSize(width, bits);
562    const int tile_ysize = VP8LSubSampleSize(height, bits);
563    int accumulated_red_histo[256] = { 0 };
564    int accumulated_blue_histo[256] = { 0 };
565    int tile_x, tile_y;
566    VP8LMultipliers prev_x, prev_y;
567    MultipliersClear(&prev_y);
568    MultipliersClear(&prev_x);
569    for (tile_y = 0; tile_y < tile_ysize; ++tile_y) {
570      for (tile_x = 0; tile_x < tile_xsize; ++tile_x) {
571        int y;
572        const int tile_x_offset = tile_x * max_tile_size;
573        const int tile_y_offset = tile_y * max_tile_size;
574        const int all_x_max = GetMin(tile_x_offset + max_tile_size, width);
575        const int all_y_max = GetMin(tile_y_offset + max_tile_size, height);
576        const int offset = tile_y * tile_xsize + tile_x;
577        if (tile_y != 0) {
578          ColorCodeToMultipliers(image[offset - tile_xsize], &prev_y);
579        }
580        prev_x = GetBestColorTransformForTile(tile_x, tile_y, bits,
581                                              prev_x, prev_y,
582                                              quality, width, height,
583                                              accumulated_red_histo,
584                                              accumulated_blue_histo,
585                                              argb);
586        image[offset] = MultipliersToColorCode(&prev_x);
587        CopyTileWithColorTransform(width, height, tile_x_offset, tile_y_offset,
588                                   max_tile_size, prev_x, argb);
589        for (y = tile_y_offset; y < all_y_max; ++y) {
590          int ix = y * width + tile_x_offset;
591          const int ix_end = ix + all_x_max - tile_x_offset;
592          for (; ix < ix_end; ++ix) {
593            const uint32_t pix = argb[ix];
594            if (ix >= 2 &&
595                pix == argb[ix - 2] &&
596                pix == argb[ix - 1]) {
597              continue;  
598            }
599            if (ix >= width + 2 &&
600                argb[ix - 2] == argb[ix - width - 2] &&
601                argb[ix - 1] == argb[ix - width - 1] &&
602                pix == argb[ix - width]) {
603              continue;  
604            }
605            ++accumulated_red_histo[(pix >> 16) & 0xff];
606            ++accumulated_blue_histo[(pix >> 0) & 0xff];
607          }
608        }
609      }
610    }
611  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-rank1.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-predictor_enc.c</div>
                <div class="column column_space"><pre><code>83  static int applicable(const S *ego, const problem *p_,
84  		      const planner *plnr,
85  		      INT *r, INT rblock[2], INT mblock[2])
86  {
87       const problem_mpi_dft *p = (const problem_mpi_dft *) p_;
</pre></code></div>
                <div class="column column_space"><pre><code>345  void VP8LResidualImage(int width, int height, int bits, int low_effort,
346                         uint32_t* const argb, uint32_t* const argb_scratch,
347                         uint32_t* const image, int near_lossless_quality,
348                         int exact, int used_subtract_green) {
349    const int tiles_per_row = VP8LSubSampleSize(width, bits);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    