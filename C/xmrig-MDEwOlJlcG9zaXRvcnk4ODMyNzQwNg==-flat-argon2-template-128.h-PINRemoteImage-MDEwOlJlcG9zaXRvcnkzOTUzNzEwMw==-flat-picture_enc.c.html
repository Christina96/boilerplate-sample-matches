
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.740359897172237%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-template-128.h</h3>
            <pre><code>1  #include <string.h>
2  #ifdef __GNUC__
3  #   include <x86intrin.h>
4  #else
5  #   include <intrin.h>
6  #endif
7  #include "core.h"
8  static void fill_block(__m128i *s, const block *ref_block, block *next_block,
9                         int with_xor)
10  {
11      __m128i block_XY[ARGON2_OWORDS_IN_BLOCK];
12      unsigned int i;
13      if (with_xor) {
14          for (i = 0; i < ARGON2_OWORDS_IN_BLOCK; i++) {
15              s[i] = _mm_xor_si128(
16                          s[i], _mm_loadu_si128((const __m128i *)ref_block->v + i));
17              block_XY[i] = _mm_xor_si128(
18                          s[i], _mm_loadu_si128((const __m128i *)next_block->v + i));
19          }
20      } else {
21          for (i = 0; i < ARGON2_OWORDS_IN_BLOCK; i++) {
22              block_XY[i] = s[i] = _mm_xor_si128(
23                          s[i], _mm_loadu_si128((const __m128i *)ref_block->v + i));
24          }
25      }
26      for (i = 0; i < 8; ++i) {
27          BLAKE2_ROUND(
28              s[8 * i + 0], s[8 * i + 1], s[8 * i + 2], s[8 * i + 3],
29              s[8 * i + 4], s[8 * i + 5], s[8 * i + 6], s[8 * i + 7]);
30      }
31      for (i = 0; i < 8; ++i) {
32          BLAKE2_ROUND(
33              s[8 * 0 + i], s[8 * 1 + i], s[8 * 2 + i], s[8 * 3 + i],
34              s[8 * 4 + i], s[8 * 5 + i], s[8 * 6 + i], s[8 * 7 + i]);
35      }
36      for (i = 0; i < ARGON2_OWORDS_IN_BLOCK; i++) {
37          s[i] = _mm_xor_si128(s[i], block_XY[i]);
38          _mm_storeu_si128((__m128i *)next_block->v + i, s[i]);
39      }
40  }
41  static void next_addresses(block *address_block, block *input_block)
42  {
43      __m128i zero_block[ARGON2_OWORDS_IN_BLOCK];
44      __m128i zero2_block[ARGON2_OWORDS_IN_BLOCK];
45      memset(zero_block, 0, sizeof(zero_block));
46      memset(zero2_block, 0, sizeof(zero2_block));
<span onclick='openModal()' class='match'>47      input_block->v[6]++;
48      fill_block(zero_block, input_block, address_block, 0);
49      fill_block(zero2_block, address_block, address_block, 0);
50  }
51  static void fill_segment_128(const argon2_instance_t *instance,
52                               argon2_position_t position)
53  {
54      block *ref_block = NULL, *curr_block = NULL;
</span>55      block address_block, input_block;
56      uint64_t pseudo_rand, ref_index, ref_lane;
57      uint32_t prev_offset, curr_offset;
58      uint32_t starting_index, i;
59      __m128i state[ARGON2_OWORDS_IN_BLOCK];
60      int data_independent_addressing;
61      if (instance == NULL) {
62          return;
63      }
64      data_independent_addressing = (instance->type == Argon2_i) ||
65              (instance->type == Argon2_id && (position.pass == 0) &&
66               (position.slice < ARGON2_SYNC_POINTS / 2));
67      if (data_independent_addressing) {
68          init_block_value(&input_block, 0);
69          input_block.v[0] = position.pass;
70          input_block.v[1] = position.lane;
71          input_block.v[2] = position.slice;
72          input_block.v[3] = instance->memory_blocks;
73          input_block.v[4] = instance->passes;
74          input_block.v[5] = instance->type;
75      }
76      starting_index = 0;
77      if ((0 == position.pass) && (0 == position.slice)) {
78          starting_index = 2; &bsol;* we have already generated the first two blocks */
79          if (data_independent_addressing) {
80              next_addresses(&address_block, &input_block);
81          }
82      }
83      curr_offset = position.lane * instance->lane_length +
84                    position.slice * instance->segment_length + starting_index;
85      if (0 == curr_offset % instance->lane_length) {
86          prev_offset = curr_offset + instance->lane_length - 1;
87      } else {
88          prev_offset = curr_offset - 1;
89      }
90      memcpy(state, ((instance->memory + prev_offset)->v), ARGON2_BLOCK_SIZE);
91      for (i = starting_index; i < instance->segment_length;
92           ++i, ++curr_offset, ++prev_offset) {
93          if (curr_offset % instance->lane_length == 1) {
94              prev_offset = curr_offset - 1;
95          }
96          if (data_independent_addressing) {
97              if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {
98                  next_addresses(&address_block, &input_block);
99              }
100              pseudo_rand = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];
101          } else {
102              pseudo_rand = instance->memory[prev_offset].v[0];
103          }
104          ref_lane = ((pseudo_rand >> 32)) % instance->lanes;
105          if ((position.pass == 0) && (position.slice == 0)) {
106              ref_lane = position.lane;
107          }
108          position.index = i;
109          ref_index = xmrig_ar2_index_alpha(instance, &position, pseudo_rand & 0xFFFFFFFF, ref_lane == position.lane);
110          ref_block =
111              instance->memory + instance->lane_length * ref_lane + ref_index;
112          curr_block = instance->memory + curr_offset;
113          if (0 == position.pass || ARGON2_VERSION_10 == instance->version) {
114              fill_block(state, ref_block, curr_block, 0);
115          } else {
116              fill_block(state, ref_block, curr_block, 1);
117          }
118      }
119  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/vp8i_enc.h"
4  #include "src/dsp/dsp.h"
5  #include "src/utils/utils.h"
6  static int DummyWriter(const uint8_t* data, size_t data_size,
7                         const WebPPicture* const picture) {
8    (void)data;
9    (void)data_size;
10    (void)picture;
11    return 1;
12  }
13  int WebPPictureInitInternal(WebPPicture* picture, int version) {
14    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_ENCODER_ABI_VERSION)) {
15      return 0;   
16    }
17    if (picture != NULL) {
18      memset(picture, 0, sizeof(*picture));
19      picture->writer = DummyWriter;
20      WebPEncodingSetError(picture, VP8_ENC_OK);
21    }
22    return 1;
23  }
24  static void WebPPictureResetBufferARGB(WebPPicture* const picture) {
25    picture->memory_argb_ = NULL;
26    picture->argb = NULL;
<span onclick='openModal()' class='match'>27    picture->argb_stride = 0;
28  }
29  static void WebPPictureResetBufferYUVA(WebPPicture* const picture) {
30    picture->memory_ = NULL;
31    picture->y = picture->u = picture->v = picture->a = NULL;
</span>32    picture->y_stride = picture->uv_stride = 0;
33    picture->a_stride = 0;
34  }
35  void WebPPictureResetBuffers(WebPPicture* const picture) {
36    WebPPictureResetBufferARGB(picture);
37    WebPPictureResetBufferYUVA(picture);
38  }
39  int WebPPictureAllocARGB(WebPPicture* const picture, int width, int height) {
40    void* memory;
41    const uint64_t argb_size = (uint64_t)width * height;
42    assert(picture != NULL);
43    WebPSafeFree(picture->memory_argb_);
44    WebPPictureResetBufferARGB(picture);
45    if (width <= 0 || height <= 0) {
46      return WebPEncodingSetError(picture, VP8_ENC_ERROR_BAD_DIMENSION);
47    }
48    memory = WebPSafeMalloc(argb_size + WEBP_ALIGN_CST, sizeof(*picture->argb));
49    if (memory == NULL) {
50      return WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
51    }
52    picture->memory_argb_ = memory;
53    picture->argb = (uint32_t*)WEBP_ALIGN(memory);
54    picture->argb_stride = width;
55    return 1;
56  }
57  int WebPPictureAllocYUVA(WebPPicture* const picture, int width, int height) {
58    const WebPEncCSP uv_csp =
59        (WebPEncCSP)((int)picture->colorspace & WEBP_CSP_UV_MASK);
60    const int has_alpha = (int)picture->colorspace & WEBP_CSP_ALPHA_BIT;
61    const int y_stride = width;
62    const int uv_width = (int)(((int64_t)width + 1) >> 1);
63    const int uv_height = (int)(((int64_t)height + 1) >> 1);
64    const int uv_stride = uv_width;
65    int a_width, a_stride;
66    uint64_t y_size, uv_size, a_size, total_size;
67    uint8_t* mem;
68    assert(picture != NULL);
69    WebPSafeFree(picture->memory_);
70    WebPPictureResetBufferYUVA(picture);
71    if (uv_csp != WEBP_YUV420) {
72      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
73    }
74    a_width = has_alpha ? width : 0;
75    a_stride = a_width;
76    y_size = (uint64_t)y_stride * height;
77    uv_size = (uint64_t)uv_stride * uv_height;
78    a_size =  (uint64_t)a_stride * height;
79    total_size = y_size + a_size + 2 * uv_size;
80    if (width <= 0 || height <= 0 ||           
81        uv_width <= 0 || uv_height <= 0) {     
82      return WebPEncodingSetError(picture, VP8_ENC_ERROR_BAD_DIMENSION);
83    }
84    mem = (uint8_t*)WebPSafeMalloc(total_size, sizeof(*mem));
85    if (mem == NULL) {
86      return WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
87    }
88    picture->memory_ = (void*)mem;
89    picture->y_stride  = y_stride;
90    picture->uv_stride = uv_stride;
91    picture->a_stride  = a_stride;
92    picture->y = mem;
93    mem += y_size;
94    picture->u = mem;
95    mem += uv_size;
96    picture->v = mem;
97    mem += uv_size;
98    if (a_size > 0) {
99      picture->a = mem;
100      mem += a_size;
101    }
102    (void)mem;  
103    return 1;
104  }
105  int WebPPictureAlloc(WebPPicture* picture) {
106    if (picture != NULL) {
107      const int width = picture->width;
108      const int height = picture->height;
109      WebPPictureFree(picture);   
110      if (!picture->use_argb) {
111        return WebPPictureAllocYUVA(picture, width, height);
112      } else {
113        return WebPPictureAllocARGB(picture, width, height);
114      }
115    }
116    return 1;
117  }
118  void WebPPictureFree(WebPPicture* picture) {
119    if (picture != NULL) {
120      WebPSafeFree(picture->memory_);
121      WebPSafeFree(picture->memory_argb_);
122      WebPPictureResetBuffers(picture);
123    }
124  }
125  void WebPMemoryWriterInit(WebPMemoryWriter* writer) {
126    writer->mem = NULL;
127    writer->size = 0;
128    writer->max_size = 0;
129  }
130  int WebPMemoryWrite(const uint8_t* data, size_t data_size,
131                      const WebPPicture* picture) {
132    WebPMemoryWriter* const w = (WebPMemoryWriter*)picture->custom_ptr;
133    uint64_t next_size;
134    if (w == NULL) {
135      return 1;
136    }
137    next_size = (uint64_t)w->size + data_size;
138    if (next_size > w->max_size) {
139      uint8_t* new_mem;
140      uint64_t next_max_size = 2ULL * w->max_size;
141      if (next_max_size < next_size) next_max_size = next_size;
142      if (next_max_size < 8192ULL) next_max_size = 8192ULL;
143      new_mem = (uint8_t*)WebPSafeMalloc(next_max_size, 1);
144      if (new_mem == NULL) {
145        return 0;
146      }
147      if (w->size > 0) {
148        memcpy(new_mem, w->mem, w->size);
149      }
150      WebPSafeFree(w->mem);
151      w->mem = new_mem;
152      w->max_size = (size_t)next_max_size;
153    }
154    if (data_size > 0) {
155      memcpy(w->mem + w->size, data, data_size);
156      w->size += data_size;
157    }
158    return 1;
159  }
160  void WebPMemoryWriterClear(WebPMemoryWriter* writer) {
161    if (writer != NULL) {
162      WebPSafeFree(writer->mem);
163      writer->mem = NULL;
164      writer->size = 0;
165      writer->max_size = 0;
166    }
167  }
168  typedef int (*Importer)(WebPPicture* const, const uint8_t* const, int);
169  static size_t Encode(const uint8_t* rgba, int width, int height, int stride,
170                       Importer import, float quality_factor, int lossless,
171                       uint8_t** output) {
172    WebPPicture pic;
173    WebPConfig config;
174    WebPMemoryWriter wrt;
175    int ok;
176    if (output == NULL) return 0;
177    if (!WebPConfigPreset(&config, WEBP_PRESET_DEFAULT, quality_factor) ||
178        !WebPPictureInit(&pic)) {
179      return 0;  
180    }
181    config.lossless = !!lossless;
182    pic.use_argb = !!lossless;
183    pic.width = width;
184    pic.height = height;
185    pic.writer = WebPMemoryWrite;
186    pic.custom_ptr = &wrt;
187    WebPMemoryWriterInit(&wrt);
188    ok = import(&pic, rgba, stride) && WebPEncode(&config, &pic);
189    WebPPictureFree(&pic);
190    if (!ok) {
191      WebPMemoryWriterClear(&wrt);
192      *output = NULL;
193      return 0;
194    }
195    *output = wrt.mem;
196    return wrt.size;
197  }
198  #define ENCODE_FUNC(NAME, IMPORTER)                                     \
199  size_t NAME(const uint8_t* in, int w, int h, int bps, float q,          \
200              uint8_t** out) {                                            \
201    return Encode(in, w, h, bps, IMPORTER, q, 0, out);                    \
202  }
203  ENCODE_FUNC(WebPEncodeRGB, WebPPictureImportRGB)
204  ENCODE_FUNC(WebPEncodeRGBA, WebPPictureImportRGBA)
205  #if !defined(WEBP_REDUCE_CSP)
206  ENCODE_FUNC(WebPEncodeBGR, WebPPictureImportBGR)
207  ENCODE_FUNC(WebPEncodeBGRA, WebPPictureImportBGRA)
208  #endif  
209  #undef ENCODE_FUNC
210  #define LOSSLESS_DEFAULT_QUALITY 70.
211  #define LOSSLESS_ENCODE_FUNC(NAME, IMPORTER)                                 \
212  size_t NAME(const uint8_t* in, int w, int h, int bps, uint8_t** out) {       \
213    return Encode(in, w, h, bps, IMPORTER, LOSSLESS_DEFAULT_QUALITY, 1, out);  \
214  }
215  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessRGB, WebPPictureImportRGB)
216  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessRGBA, WebPPictureImportRGBA)
217  #if !defined(WEBP_REDUCE_CSP)
218  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessBGR, WebPPictureImportBGR)
219  LOSSLESS_ENCODE_FUNC(WebPEncodeLosslessBGRA, WebPPictureImportBGRA)
220  #endif  
221  #undef LOSSLESS_ENCODE_FUNC
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-argon2-template-128.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>47      input_block->v[6]++;
48      fill_block(zero_block, input_block, address_block, 0);
49      fill_block(zero2_block, address_block, address_block, 0);
50  }
51  static void fill_segment_128(const argon2_instance_t *instance,
52                               argon2_position_t position)
53  {
54      block *ref_block = NULL, *curr_block = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>27    picture->argb_stride = 0;
28  }
29  static void WebPPictureResetBufferYUVA(WebPPicture* const picture) {
30    picture->memory_ = NULL;
31    picture->y = picture->u = picture->v = picture->a = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    