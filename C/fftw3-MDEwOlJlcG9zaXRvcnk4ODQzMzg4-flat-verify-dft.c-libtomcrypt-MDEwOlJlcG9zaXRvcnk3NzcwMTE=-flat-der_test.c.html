
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6830631637786473%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-dft.c</h3>
            <pre><code>1  #include "verify.h"
2  typedef struct {
3       dotens2_closure k;
4       R *ra; R *ia;
5       R *rb; R *ib;
6       int scalea, scaleb;
7  } cpy_closure;
8  static void cpy0(dotens2_closure *k_, 
9  		 int indxa, int ondxa, int indxb, int ondxb)
10  {
11       cpy_closure *k = (cpy_closure *)k_;
12       k->rb[indxb * k->scaleb] = k->ra[ondxa * k->scalea];
13       k->ib[indxb * k->scaleb] = k->ia[ondxa * k->scalea];
14       UNUSED(indxa); UNUSED(ondxb);
15  }
16  static void cpy(R *ra, R *ia, const bench_tensor *sza, int scalea,
17  		R *rb, R *ib, const bench_tensor *szb, int scaleb)
18  {
19       cpy_closure k;
20       k.k.apply = cpy0;
21       k.ra = ra; k.ia = ia; k.rb = rb; k.ib = ib;
22       k.scalea = scalea; k.scaleb = scaleb;
23       bench_dotens2(sza, szb, &k.k);
24  }
25  typedef struct {
26       dofft_closure k;
27       bench_problem *p;
28  } dofft_dft_closure;
29  static void dft_apply(dofft_closure *k_, bench_complex *in, bench_complex *out)
30  {
31       dofft_dft_closure *k = (dofft_dft_closure *)k_;
32       bench_problem *p = k->p;
33       bench_tensor *totalsz, *pckdsz;
34       bench_tensor *totalsz_swap, *pckdsz_swap;
35       bench_real *ri, *ii, *ro, *io;
36       int totalscale;
37       totalsz = tensor_append(p->vecsz, p->sz);
38       pckdsz = verify_pack(totalsz, 2);
39       ri = (bench_real *) p->in;
40       ro = (bench_real *) p->out;
41       totalsz_swap = tensor_copy_swapio(totalsz);
42       pckdsz_swap = tensor_copy_swapio(pckdsz);
43       if (p->split) {
44  	  ii = p->ini ? (bench_real *) p->ini : ri + p->iphyssz;
45  	  io = p->outi ? (bench_real *) p->outi : ro + p->ophyssz;
46  	  totalscale = 1;
47       } else {
48  	  ii = p->ini ? (bench_real *) p->ini : ri + 1;
49  	  io = p->outi ? (bench_real *) p->outi : ro + 1;
50  	  totalscale = 2;
51       }
52       cpy(&c_re(in[0]), &c_im(in[0]), pckdsz, 1,
53  	    ri, ii, totalsz, totalscale);
54       after_problem_ccopy_from(p, ri, ii);
55       doit(1, p);
56       after_problem_ccopy_to(p, ro, io);
57       if (k->k.recopy_input)
58  	  cpy(ri, ii, totalsz_swap, totalscale,
59  	      &c_re(in[0]), &c_im(in[0]), pckdsz_swap, 1);
60       cpy(ro, io, totalsz, totalscale,
61  	 &c_re(out[0]), &c_im(out[0]), pckdsz, 1);
62       tensor_destroy(totalsz);
63       tensor_destroy(pckdsz);
64       tensor_destroy(totalsz_swap);
65       tensor_destroy(pckdsz_swap);
66  }
67  void verify_dft(bench_problem *p, int rounds, double tol, errors *e)
68  {
69       C *inA, *inB, *inC, *outA, *outB, *outC, *tmp;
70       int n, vecn, N;
71       dofft_dft_closure k;
72       BENCH_ASSERT(p->kind == PROBLEM_COMPLEX);
73       k.k.apply = dft_apply;
74       k.k.recopy_input = 0;
75       k.p = p;
76       if (rounds == 0)
77  	  rounds = 20;  &bsol;* default value */
78       n = tensor_sz(p->sz);
79       vecn = tensor_sz(p->vecsz);
80       N = n * vecn;
81       inA = (C *) bench_malloc(N * sizeof(C));
82       inB = (C *) bench_malloc(N * sizeof(C));
83       inC = (C *) bench_malloc(N * sizeof(C));
84       outA = (C *) bench_malloc(N * sizeof(C));
85       outB = (C *) bench_malloc(N * sizeof(C));
86       outC = (C *) bench_malloc(N * sizeof(C));
87       tmp = (C *) bench_malloc(N * sizeof(C));
88       e->i = impulse(&k.k, n, vecn, inA, inB, inC, outA, outB, outC, 
89  		    tmp, rounds, tol);
90       e->l = linear(&k.k, 0, N, inA, inB, inC, outA, outB, outC,
91  		   tmp, rounds, tol);
92       e->s = 0.0;
93       e->s = dmax(e->s, tf_shift(&k.k, 0, p->sz, n, vecn, p->sign,
94  				inA, inB, outA, outB, 
95  				tmp, rounds, tol, TIME_SHIFT));
96       e->s = dmax(e->s, tf_shift(&k.k, 0, p->sz, n, vecn, p->sign,
97  				inA, inB, outA, outB, 
98  				tmp, rounds, tol, FREQ_SHIFT));
99       if (!p->in_place && !p->destroy_input)
100  	  preserves_input(&k.k, 0, N, inA, inB, outB, rounds);
101       bench_free(tmp);
102       bench_free(outC);
103       bench_free(outB);
104       bench_free(outA);
105       bench_free(inC);
106       bench_free(inB);
107       bench_free(inA);
108  }
109  void accuracy_dft(bench_problem *p, int rounds, int impulse_rounds,
110  		  double t[6])
111  {
112       dofft_dft_closure k;
113       int n;
114       C *a, *b;
115       BENCH_ASSERT(p->kind == PROBLEM_COMPLEX);
116       BENCH_ASSERT(p->sz->rnk == 1);
117       BENCH_ASSERT(p->vecsz->rnk == 0);
118       k.k.apply = dft_apply;
<span onclick='openModal()' class='match'>119       k.k.recopy_input = 0;
120       k.p = p;
121       n = tensor_sz(p->sz);
122       a = (C *) bench_malloc(n * sizeof(C));
123       b = (C *) bench_malloc(n * sizeof(C));
124       accuracy_test(&k.k, 0, p->sign, n, a, b, rounds, impulse_rounds, t);
125       bench_free(b);
126       bench_free(a);
127  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</h3>
            <pre><code>1  #include <tomcrypt_test.h>
2  #if !defined(LTC_DER)
3  int der_test(void)
4  {
5     return CRYPT_NOP;
6  }
7  #else
8  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 2
9  #define LTC_DER_TESTS_PRINT_FLEXI
10  #endif
11  static const char s_der_tests_stinky_root_cert[] =
12     "MIIFETCCA/mgAwIBAgIQbv53JNmv518t5lkCHE272jANBgkqhkiG9w0BAQUFADCB"
13     "lTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug"
14     "Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho"
15     "dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHTAbBgNVBAMTFFVUTi1VU0VSRmlyc3Qt"
16     "T2JqZWN0MB4XDTA4MDQyOTAwMDAwMFoXDTEwMDQyOTIzNTk1OVowgbUxCzAJBgNV"
17     "BAYTAlVTMQ4wDAYDVQQRDAU0NDE0MzELMAkGA1UECAwCT0gxGTAXBgNVBAcMEE1h"
18     "eWZpZWxkIFZpbGxhZ2UxEDAOBgNVBAkMB1N1aXRlIEExFDASBgNVBAkMCzc2NyBC"
19     "ZXRhIERyMSIwIAYDVQQKDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMSIwIAYD"
20     "VQQDDBlQcmVlbXB0aXZlIFNvbHV0aW9ucywgTExDMIIBIjANBgkqhkiG9w0BAQEF"
21     "AAOCAQ8AMIIBCgKCAQEAzH7ZBkMcBuHx8d2f10RGTHAf7gzzVteGbOihJGH2BwlS"
22     "ZvNp6WEE4DfL+s1vp0wzk1XeLN5tRjg2qum9YqyCk7okh7pXGy46f5mWbLQiefGA"
23     "j5UXRcr6WJ3xeACdbXxKrYMV0REia+4Jb2UbFA8S81PjhRon6vcRz76ziUWwt8NC"
24     "igX+4ZC0skhhKzKszel6KGL7bJCtLG7ukw9DZCrvPCRcKFeM/GwQ6ACMgP88CSCL"
25     "t1fbIXDH1vd/x2XM3QlaSDN6hYDbef8m1T+9TCkXVKeqG1GYjSUrHzYnCZUmTRrR"
26     "38jgC3qXxiIpDKW105uM0nlXe2XF9c+ot2MdWvV4TwIDAQABo4IBOTCCATUwHwYD"
27     "VR0jBBgwFoAU2u1kdBScFDyr3ZmpvVsoTYs8ydgwHQYDVR0OBBYEFK+1HzZE4i28"
28     "oLIzuqlFR9SspiCIMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMBMGA1Ud"
29     "JQQMMAoGCCsGAQUFBwMDMBEGCWCGSAGG+EIBAQQEAwIEEDBGBgNVHSAEPzA9MDsG"
30     "DCsGAQQBsjEBAgEDAjArMCkGCCsGAQUFBwIBFh1odHRwczovL3NlY3VyZS5jb21v"
31     "ZG8ubmV0L0NQUzBCBgNVHR8EOzA5MDegNaAzhjFodHRwOi8vY3JsLnVzZXJ0cnVz"
32     "dC5jb20vVVROLVVTRVJGaXJzdC1PYmplY3QuY3JsMCEGA1UdEQQaMBiBFnN1cHBv"
33     "cnRAcHJlZW1wdGl2ZS5jb20wDQYJKoZIhvcNAQEFBQADggEBAC+JM26Dokvonudl"
34     "JXe/Yun7IBhimkagZUjbk9l/GQWN6i+v1o95UJ1wGJtBdm2+MxbSaPoNTDZR4B+2"
35     "lYL9MW57UVmePrnfUPXQKZZG+8gTRDz8+7ol/CEAKmS3MLKCRcH5oe+J5345sGxi"
36     "FC/KWNKedTNraW95xlg8NTlL2yRP7TMsjvBxgLmkbaFUoXzPTbQWmtovIagIT8GC"
37     "JeXwdFaRjbamiz3Irl+u7x/mhxdza6RvgBYylXRFMudANpeGsV7gDXlnfzpFDKHQ"
38     "niVwB7P5sbPFIlmIc+4/xRItkLIRjCVXaepgN9KYu3VOgiSDI6wXiTwP44/LUXQM"
39     "hetwa7s=";
40  const char ltc_der_tests_cacert_root_cert[] =
41     "MIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290"
42     "IENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB"
43     "IENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA"
44     "Y2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO"
45     "BgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi"
46     "MCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ"
47     "ARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC"
48     "CgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ"
49     "8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6"
50     "zWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y"
51     "fk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7"
52     "w2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc"
53     "G8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k"
54     "epKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q"
55     "laegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ"
56     "QUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU"
57     "fslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826"
58     "YreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w"
59     "ggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY"
60     "gBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe"
61     "MBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0"
62     "IFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy"
63     "dC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw"
64     "czovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0"
65     "dHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl"
66     "aHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC"
67     "AQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg"
68     "b3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB"
69     "ACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc"
70     "nWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg"
71     "18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c"
72     "gr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl"
73     "Jzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY"
74     "sONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T"
75     "SCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF"
76     "CpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum"
77     "GCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk"
78     "zk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW"
79     "omTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD";
80  const unsigned long ltc_der_tests_cacert_root_cert_size = sizeof(ltc_der_tests_cacert_root_cert);
81  #define ASN1_FMTSTRING_FMT "line: %d, type=%d, size=%lu, data=%p, self=%p, next=%p, prev=%p, parent=%p, child=%p"
82  #define ASN1_FMTSTRING_VAL(l)  __LINE__, (l)->type, (l)->size, (l)->data, (l), (l)->next, (l)->prev, (l)->parent, (l)->child
83  #define ASN1_ERR(l) fprintf(stderr, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l)); \
84      exit(EXIT_FAILURE)
85  #define CHECK_ASN1_HAS(l, w) do { if ((l)->w == NULL) { \
86      ASN1_ERR(l);\
87  } } while(0)
88  #define CHECK_ASN1_HAS_NO(l, w) do { if ((l)->w != NULL) { \
89      ASN1_ERR(l);\
90  } } while(0)
91  #define CHECK_ASN1_TYPE(l, t) do { if ((l)->type != (t)) { \
92      ASN1_ERR(l);\
93  } } while(0)
94  #define CHECK_ASN1_HAS_CHILD(l) CHECK_ASN1_HAS(l, child)
95  #define CHECK_ASN1_HAS_NO_CHILD(l) CHECK_ASN1_HAS_NO(l, child)
96  #define CHECK_ASN1_HAS_NEXT(l) CHECK_ASN1_HAS(l, next)
97  #define CHECK_ASN1_HAS_NO_NEXT(l) CHECK_ASN1_HAS_NO(l, next)
98  #define CHECK_ASN1_HAS_DATA(l) CHECK_ASN1_HAS(l, data)
99  #define CHECK_ASN1_HAS_NO_DATA(l) CHECK_ASN1_HAS_NO(l, data)
100  #ifdef LTC_DER_TESTS_PRINT_FLEXI
101  static void* s_xmalloc(int l)
102  {
103     void *r = XMALLOC(l);
104  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
105     fprintf(stderr, "ALLOC %9d to %p\n", l, r);
106  #endif
107     if (!r) {
108        fprintf(stderr, "Could not allocate %d bytes of memory\n", l);
109        exit(EXIT_FAILURE);
110     }
111     return r;
112  }
113  static void s_free(void *p)
114  {
115  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 3
116     fprintf(stderr, "FREE %p\n", p);
117  #endif
118     XFREE(p);
119  }
120  static void s_der_tests_print_flexi(ltc_asn1_list* l, unsigned int level)
121  {
122    char *buf = NULL;
123    const char* name = NULL;
124    const char* text = NULL;
125    ltc_asn1_list* ostring = NULL;
126    unsigned int n;
127    int slen;
128    switch (l->type)
129      {
130    case LTC_ASN1_EOL:
131      name = "EOL";
132      slen = snprintf(NULL, 0, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
133      buf = s_xmalloc(slen);
134      slen = snprintf(buf, slen, ASN1_FMTSTRING_FMT "\n", ASN1_FMTSTRING_VAL(l));
135      text = buf;
136      break;
137    case LTC_ASN1_BOOLEAN:
138      name = "BOOLEAN";
139      {
140        if (*(int*)l->data)
141          text = "true";
142        else
143          text = "false";
144      }
145      break;
146    case LTC_ASN1_INTEGER:
147      name = "INTEGER";
148      buf = s_xmalloc(((mp_get_digit_count(l->data) + 1) * ltc_mp.bits_per_digit) / 3);
149      mp_toradix(l->data, buf, 10);
150      text = buf;
151      break;
152    case LTC_ASN1_SHORT_INTEGER:
153      name = "SHORT INTEGER";
154      break;
155    case LTC_ASN1_BIT_STRING:
156      name = "BIT STRING";
157      break;
158    case LTC_ASN1_OCTET_STRING:
159      name = "OCTET STRING";
160      {
161        unsigned long ostring_l = l->size;
162        if (der_decode_sequence_flexi(l->data, &ostring_l, &ostring) == CRYPT_OK) {
163            text = "";
164        } else {
165            int r;
166            int sz = l->size * 2 + 1;
167            char* s = buf = s_xmalloc(sz);
168            for (n = 0; n < l->size; ++n) {
169                r = snprintf(s, sz, "%02X", ((unsigned char*)l->data)[n]);
170                if (r < 0 || r >= sz) {
171                    fprintf(stderr, "%s boom\n", name);
172                    exit(EXIT_FAILURE);
173                }
174                s += r;
175                sz -= r;
176            }
177            text = buf;
178        }
179      }
180      break;
181    case LTC_ASN1_NULL:
182      name = "NULL";
183      text = "";
184      break;
185    case LTC_ASN1_OBJECT_IDENTIFIER:
186      name = "OBJECT IDENTIFIER";
187      {
188        unsigned long len = 0;
189        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_BUFFER_OVERFLOW) {
190          fprintf(stderr, "%s WTF\n", name);
191          exit(EXIT_FAILURE);
192        }
193        buf = s_xmalloc(len);
194        if (pk_oid_num_to_str(l->data, l->size, buf, &len) != CRYPT_OK) {
195          fprintf(stderr, "%s boom\n", name);
196          exit(EXIT_FAILURE);
197        }
198        text = buf;
199      }
200      break;
201    case LTC_ASN1_IA5_STRING:
202      name = "IA5 STRING";
203      text = l->data;
204      break;
205    case LTC_ASN1_PRINTABLE_STRING:
206      name = "PRINTABLE STRING";
207      text = l->data;
208      break;
209    case LTC_ASN1_UTF8_STRING:
210      name = "UTF8 STRING";
211      break;
212    case LTC_ASN1_UTCTIME:
213      name = "UTCTIME";
214      {
215        ltc_utctime* ut = l->data;
216        slen = 32;
217        buf = s_xmalloc(slen);
218        snprintf(buf, slen, "%02d-%02d-%02d %02d:%02d:%02d %c%02d:%02d",
219            ut->YY, ut->MM, ut->DD, ut->hh, ut->mm, ut->ss,
220            ut->off_dir ? '-' : '+', ut->off_hh, ut->off_mm);
221        text = buf;
222      }
223      break;
224    case LTC_ASN1_GENERALIZEDTIME:
225      name = "GENERALIZED TIME";
226      {
227        ltc_generalizedtime* gt = l->data;
228        slen = 32;
229        buf = s_xmalloc(slen);
230        if(gt->fs)
231           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02d.%02dZ",
232            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss, gt->fs);
233        else
234           snprintf(buf, slen, "%04d-%02d-%02d %02d:%02d:%02dZ",
235            gt->YYYY, gt->MM, gt->DD, gt->hh, gt->mm, gt->ss);
236        text = buf;
237      }
238      break;
239    case LTC_ASN1_CHOICE:
240      name = "CHOICE";
241      break;
242    case LTC_ASN1_SEQUENCE:
243      name = "SEQUENCE";
244      text = "";
245      break;
246    case LTC_ASN1_SET:
247      name = "SET";
248      text = "";
249      break;
250    case LTC_ASN1_SETOF:
251      name = "SETOF";
252      text = "";
253      break;
254    case LTC_ASN1_RAW_BIT_STRING:
255      name = "RAW BIT STRING";
256      break;
257    case LTC_ASN1_TELETEX_STRING:
258      name = "TELETEX STRING";
259      text = l->data;
260      break;
261    case LTC_ASN1_CUSTOM_TYPE:
262      name = "NON STANDARD";
263      {
264         int r;
265         int sz = 128;
266         char* s = buf = s_xmalloc(sz);
267         r = snprintf(s, sz, "[%s %s %llu]", der_asn1_class_to_string_map[l->klass], der_asn1_pc_to_string_map[l->pc], l->tag);
268         if (r < 0 || r >= sz) {
269             fprintf(stderr, "%s boom\n", name);
270             exit(EXIT_FAILURE);
271         }
272         s += r;
273         sz -= r;
274         text = buf;
275      }
276      break;
277    }
278    for (n = 0; n < level; ++n) {
279       fprintf(stderr, "    ");
280    }
281    if (name) {
282        if (text)
283           fprintf(stderr, "%s %s\n", name, text);
284        else
285           fprintf(stderr, "%s <missing decoding>\n", name);
286    }
287    else
288       fprintf(stderr, "WTF type=%i\n", l->type);
289    if (buf) {
290       s_free(buf);
291       buf = NULL;
292    }
293    if (ostring) {
294        s_der_tests_print_flexi(ostring, level + 1);
295        der_free_sequence_flexi(ostring);
296    }
297    if (l->child)
298      s_der_tests_print_flexi(l->child, level + 1);
299    if (l->next)
300      s_der_tests_print_flexi(l->next, level);
301  }
302  #endif
303  static void der_cacert_test(void)
304  {
305    unsigned char buf[sizeof(ltc_der_tests_cacert_root_cert)];
306    unsigned long len1 = sizeof(buf), len2;
307    ltc_asn1_list *decoded_list, *l, *l1, *l2;
308    DO(base64_decode(s_der_tests_stinky_root_cert, sizeof(s_der_tests_stinky_root_cert), buf, &len1));
309    len2 = len1;
310    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
311    der_free_sequence_flexi(decoded_list);
312    len1 = sizeof(buf);
313    DO(base64_decode(ltc_der_tests_cacert_root_cert, sizeof(ltc_der_tests_cacert_root_cert), buf, &len1));
314    len2 = len1;
315    DO(der_decode_sequence_flexi(buf, &len2, &decoded_list));
316    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
317    CHECK_ASN1_HAS_DATA(decoded_list);
318    der_sequence_shrink(decoded_list);
319    CHECK_ASN1_TYPE(decoded_list, LTC_ASN1_SEQUENCE);
320    CHECK_ASN1_HAS_NO_DATA(decoded_list);
321  #ifdef LTC_DER_TESTS_PRINT_FLEXI
322    printf("\n\n--- test print start ---\n\n");
323    s_der_tests_print_flexi(decoded_list, 0);
324    printf("\n\n--- test print end ---\n\n");
325  #endif
326    l = decoded_list;
327    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
328    CHECK_ASN1_HAS_CHILD(l);
329    CHECK_ASN1_HAS_NO_NEXT(l);
330    l = l->child;
331    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
332    CHECK_ASN1_HAS_CHILD(l);
333    CHECK_ASN1_HAS_NEXT(l);
334    l1 = l->child;
335    CHECK_ASN1_TYPE(l1, LTC_ASN1_CUSTOM_TYPE);
336    CHECK_ASN1_HAS_CHILD(l1);
337    CHECK_ASN1_HAS_NEXT(l1);
338    l2 = l1->child;
339    CHECK_ASN1_TYPE(l2, LTC_ASN1_INTEGER);
340    CHECK_ASN1_HAS_NO_CHILD(l2);
341    CHECK_ASN1_HAS_NO_NEXT(l2);
342    l1 = l1->next;
343    CHECK_ASN1_TYPE(l1, LTC_ASN1_INTEGER);
344    CHECK_ASN1_HAS_NO_CHILD(l1);
345    CHECK_ASN1_HAS_NEXT(l1);
346    l1 = l1->next;
347    CHECK_ASN1_TYPE(l1, LTC_ASN1_SEQUENCE);
348    CHECK_ASN1_HAS_CHILD(l1);
349    CHECK_ASN1_HAS_NEXT(l1);
350    l2 = l1->child;
351    CHECK_ASN1_TYPE(l2, LTC_ASN1_OBJECT_IDENTIFIER);
352    CHECK_ASN1_HAS_NO_CHILD(l2);
353    CHECK_ASN1_HAS_NEXT(l2);
354    l2 = l2->next;
355    CHECK_ASN1_TYPE(l2, LTC_ASN1_NULL);
356    CHECK_ASN1_HAS_NO_CHILD(l2);
357    CHECK_ASN1_HAS_NO_NEXT(l2);
358    l = l->next;
359    CHECK_ASN1_TYPE(l, LTC_ASN1_SEQUENCE);
360    CHECK_ASN1_HAS_CHILD(l);
361    CHECK_ASN1_HAS_NEXT(l);
362    l1 = l->child;
363    CHECK_ASN1_TYPE(l1, LTC_ASN1_OBJECT_IDENTIFIER);
364    CHECK_ASN1_HAS_NO_CHILD(l1);
365    CHECK_ASN1_HAS_NEXT(l1);
366    l1 = l1->next;
367    CHECK_ASN1_TYPE(l1, LTC_ASN1_NULL);
368    CHECK_ASN1_HAS_NO_CHILD(l1);
369    CHECK_ASN1_HAS_NO_NEXT(l1);
370    l = l->next;
371    CHECK_ASN1_TYPE(l, LTC_ASN1_BIT_STRING);
372    CHECK_ASN1_HAS_NO_CHILD(l);
373    CHECK_ASN1_HAS_NO_NEXT(l);
374    der_free_sequence_flexi(decoded_list);
375  }
376  static void der_set_test(void)
377  {
378     ltc_asn1_list list[10];
379     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
380     static const unsigned char bin_str[] = { 1, 0, 0, 1 };
381     static const unsigned long int_val   = 12345678UL;
382     unsigned char strs[10][10], outbuf[128];
383     unsigned long x, val, outlen;
384     LTC_SET_ASN1(list, 0, LTC_ASN1_OCTET_STRING,  oct_str, sizeof(oct_str));
385     LTC_SET_ASN1(list, 1, LTC_ASN1_BIT_STRING,    bin_str, sizeof(bin_str));
386     LTC_SET_ASN1(list, 2, LTC_ASN1_SHORT_INTEGER, &int_val, 1);
387     outlen = sizeof(outbuf);
388     DO(der_encode_set(list, 3, outbuf, &outlen));
389     LTC_SET_ASN1(list, 0, LTC_ASN1_BIT_STRING,    strs[1], sizeof(strs[1]));
390     LTC_SET_ASN1(list, 1, LTC_ASN1_SHORT_INTEGER, &val, 1);
391     LTC_SET_ASN1(list, 2, LTC_ASN1_OCTET_STRING,  strs[0], sizeof(strs[0]));
392     DO(der_decode_set(outbuf, outlen, list, 3));
393     if (memcmp(strs[0], oct_str, sizeof(oct_str))) {
394        fprintf(stderr, "error decoding set using der_decode_set (oct_str is wrong):\n");
395        exit(EXIT_FAILURE);
396     }
397     if (memcmp(strs[1], bin_str, sizeof(bin_str))) {
398        fprintf(stderr, "error decoding set using der_decode_set (bin_str is wrong):\n");
399        exit(EXIT_FAILURE);
400     }
401     if (val != int_val) {
402        fprintf(stderr, "error decoding set using der_decode_set (int_val is wrong):\n");
403        exit(EXIT_FAILURE);
404     }
405     strcpy((char*)strs[0], "one");
406     strcpy((char*)strs[1], "one2");
407     strcpy((char*)strs[2], "two");
408     strcpy((char*)strs[3], "aaa");
409     strcpy((char*)strs[4], "aaaa");
410     strcpy((char*)strs[5], "aab");
411     strcpy((char*)strs[6], "aaab");
412     strcpy((char*)strs[7], "bbb");
413     strcpy((char*)strs[8], "bbba");
414     strcpy((char*)strs[9], "bbbb");
415     for (x = 0; x < 10; x++) {
416         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], XSTRLEN((char*)strs[x]));
417     }
418     outlen = sizeof(outbuf);
419     DO(der_encode_setof(list, 10, outbuf, &outlen));
420     for (x = 0; x < 10; x++) {
421         LTC_SET_ASN1(list, x, LTC_ASN1_PRINTABLE_STRING, strs[x], sizeof(strs[x]) - 1);
422     }
423     XMEMSET(strs, 0, sizeof(strs));
424     DO(der_decode_set(outbuf, outlen, list, 10));
425     for (x = 1; x < 10; x++) {
426        if (!(XSTRLEN((char*)strs[x-1]) <= XSTRLEN((char*)strs[x])) && strcmp((char*)strs[x-1], (char*)strs[x]) >= 0) {
427           fprintf(stderr, "error SET OF order at %lu is wrong\n", x);
428           exit(EXIT_FAILURE);
429        }
430     }
431  }
432  static void s_der_oid_test(void)
433  {
434     static const unsigned char oid_x690_8_19_5_example[] = { 0x06, 0x03, 0x88, 0x37, 0x03 };
435     unsigned long len, oid[3];
436     unsigned char buf[64];
437     ltc_asn1_list *decoded_list, static_list[1];
438     len = sizeof(oid_x690_8_19_5_example);
439     DO(der_decode_sequence_flexi(oid_x690_8_19_5_example, &len, &decoded_list));
440     LTC_SET_ASN1(static_list, 0, LTC_ASN1_OBJECT_IDENTIFIER, (void *)decoded_list->data, decoded_list->size);
441     len = sizeof(buf);
442     DO(der_encode_object_identifier(decoded_list->data, decoded_list->size, buf, &len));
443     der_sequence_free(decoded_list);
444     DO(do_compare_testvector(buf, len, oid_x690_8_19_5_example, sizeof(oid_x690_8_19_5_example), "OID X6.90 Ch. 8.19.5 Example", 0));
<span onclick='openModal()' class='match'>445     oid[0] = 3;
446     oid[1] = 4;
447     oid[2] = 5;
448     len = sizeof(buf);
449     SHOULD_FAIL(der_encode_object_identifier(oid, 3, buf, &len));
450     len = sizeof(buf);
451     SHOULD_FAIL(der_length_object_identifier(oid, 3, &len));
452  }
</span>453  static void der_flexi_test(void)
454  {
455     static const char printable_str[]    = "printable";
456     static const char set1_str[]         = "333";
457     static const char set2_str[]         = "222";
458     static const char ia5_str[]          = "ia5";
459     static const unsigned long int_val   = 12345678UL;
460     static const ltc_utctime   utctime   = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
461     static const ltc_generalizedtime gtime = { 2017, 03, 21, 10, 21, 12, 421, 1, 2, 0 };
462     static const unsigned char oct_str[] = { 1, 2, 3, 4 };
463     static const unsigned char bit_str[] = { 1, 0, 0, 1 };
464     static const unsigned long oid_str[] = { 1, 2, 840, 113549 };
465     unsigned char encode_buf[192];
466     unsigned long encode_buf_len, decode_len;
467     ltc_asn1_list static_list[5][4], *decoded_list, *l;
468     LTC_SET_ASN1(static_list[0], 0, LTC_ASN1_PRINTABLE_STRING, (void *)printable_str, XSTRLEN(printable_str));
469     LTC_SET_ASN1(static_list[0], 1, LTC_ASN1_IA5_STRING,       (void *)ia5_str,       XSTRLEN(ia5_str));
470     LTC_SET_ASN1(static_list[0], 2, LTC_ASN1_SEQUENCE,         static_list[1],   4);
471     LTC_SET_ASN1(static_list[1], 0, LTC_ASN1_SHORT_INTEGER,    (void *)&int_val,         1);
472     LTC_SET_ASN1(static_list[1], 1, LTC_ASN1_UTCTIME,          (void *)&utctime,         1);
473     LTC_SET_ASN1(static_list[1], 2, LTC_ASN1_GENERALIZEDTIME,  (void *)&gtime,           1);
474     LTC_SET_ASN1(static_list[1], 3, LTC_ASN1_SEQUENCE,         static_list[2],   3);
475     LTC_SET_ASN1(static_list[2], 0, LTC_ASN1_OCTET_STRING,     (void *)oct_str,          4);
476     LTC_SET_ASN1(static_list[2], 1, LTC_ASN1_BIT_STRING,       (void *)bit_str,          4);
477     LTC_SET_ASN1(static_list[2], 2, LTC_ASN1_SEQUENCE,         static_list[3],   3);
478     LTC_SET_ASN1(static_list[3], 0, LTC_ASN1_OBJECT_IDENTIFIER,(void *)oid_str,          4);
479     LTC_SET_ASN1(static_list[3], 1, LTC_ASN1_NULL,             NULL,             0);
480     LTC_SET_ASN1(static_list[3], 2, LTC_ASN1_SETOF,            static_list[4],   2);
481     LTC_SET_ASN1(static_list[4], 0, LTC_ASN1_PRINTABLE_STRING, set1_str, XSTRLEN(set1_str));
482     LTC_SET_ASN1(static_list[4], 1, LTC_ASN1_PRINTABLE_STRING, set2_str, XSTRLEN(set2_str));
483     encode_buf_len = sizeof(encode_buf);
484     DO(der_encode_sequence(&static_list[0][0], 3, encode_buf, &encode_buf_len));
485  #if 0
486     {
487       FILE *f;
488       f = fopen("t.bin", "wb");
489       fwrite(encode_buf, 1, encode_buf_len, f);
490       fclose(f);
491     }
492  #endif
493     decode_len = encode_buf_len;
494     DO(der_decode_sequence_flexi(encode_buf, &decode_len, &decoded_list));
495     if (decode_len != encode_buf_len) {
496        fprintf(stderr, "Decode len of %lu does not match encode len of %lu \n", decode_len, encode_buf_len);
497        exit(EXIT_FAILURE);
498     }
499     l = decoded_list;
500     if (l->next != NULL || l->child == NULL) {
501        fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
502        exit(EXIT_FAILURE);
503     }
504        if (l->type != LTC_ASN1_SEQUENCE) {
505           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
506           exit(EXIT_FAILURE);
507        }
508        l = l->child;
509        if (l->next == NULL || l->child != NULL) {
510           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
511           exit(EXIT_FAILURE);
512        }
513        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
514           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
515           exit(EXIT_FAILURE);
516        }
517        if (l->size != XSTRLEN(printable_str) || memcmp(printable_str, l->data, l->size)) {
518           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
519           exit(EXIT_FAILURE);
520        }
521        l = l->next;
522        if (l->next == NULL || l->child != NULL) {
523           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
524           exit(EXIT_FAILURE);
525        }
526        if (l->type != LTC_ASN1_IA5_STRING) {
527           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
528           exit(EXIT_FAILURE);
529        }
530        if (l->size != XSTRLEN(ia5_str) || memcmp(ia5_str, l->data, l->size)) {
531           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
532           exit(EXIT_FAILURE);
533        }
534        l = l->next;
535        if (l->next != NULL || l->child == NULL) {
536           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
537           exit(EXIT_FAILURE);
538        }
539        if (l->type != LTC_ASN1_SEQUENCE) {
540           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
541           exit(EXIT_FAILURE);
542        }
543        l = l->child;
544        if (l->next == NULL || l->child != NULL) {
545           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
546           exit(EXIT_FAILURE);
547        }
548        if (l->type != LTC_ASN1_INTEGER) {
549           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
550           exit(EXIT_FAILURE);
551        }
552        if (mp_cmp_d(l->data, 12345678UL) != LTC_MP_EQ) {
553           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
554           exit(EXIT_FAILURE);
555        }
556        l = l->next;
557        if (l->next == NULL || l->child != NULL) {
558           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
559           exit(EXIT_FAILURE);
560        }
561        if (l->type != LTC_ASN1_UTCTIME) {
562           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
563           exit(EXIT_FAILURE);
564        }
565        if (memcmp(l->data, &utctime, sizeof(utctime))) {
566           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
567           exit(EXIT_FAILURE);
568        }
569        l = l->next;
570        if (l->next == NULL || l->child != NULL) {
571           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
572           exit(EXIT_FAILURE);
573        }
574        if (l->type != LTC_ASN1_GENERALIZEDTIME) {
575           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
576           exit(EXIT_FAILURE);
577        }
578        if (memcmp(l->data, &gtime, sizeof(gtime))) {
579           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
580           exit(EXIT_FAILURE);
581        }
582        l = l->next;
583        if (l->next != NULL || l->child == NULL) {
584           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
585           exit(EXIT_FAILURE);
586        }
587        if (l->type != LTC_ASN1_SEQUENCE) {
588           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
589           exit(EXIT_FAILURE);
590        }
591        l = l->child;
592        if (l->next == NULL || l->child != NULL) {
593           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
594           exit(EXIT_FAILURE);
595        }
596        if (l->type != LTC_ASN1_OCTET_STRING) {
597           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
598           exit(EXIT_FAILURE);
599        }
600        if (l->size != sizeof(oct_str) || memcmp(oct_str, l->data, l->size)) {
601           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
602           exit(EXIT_FAILURE);
603        }
604        l = l->next;
605        if (l->next == NULL || l->child != NULL) {
606           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
607           exit(EXIT_FAILURE);
608        }
609        if (l->type != LTC_ASN1_BIT_STRING) {
610           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
611           exit(EXIT_FAILURE);
612        }
613        if (l->size != sizeof(bit_str) || memcmp(bit_str, l->data, l->size)) {
614           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
615           exit(EXIT_FAILURE);
616        }
617        l = l->next;
618        if (l->next != NULL || l->child == NULL) {
619           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
620           exit(EXIT_FAILURE);
621        }
622        if (l->type != LTC_ASN1_SEQUENCE) {
623           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
624           exit(EXIT_FAILURE);
625        }
626        l = l->child;
627        if (l->next == NULL || l->child != NULL) {
628           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
629           exit(EXIT_FAILURE);
630        }
631        if (l->type != LTC_ASN1_OBJECT_IDENTIFIER) {
632           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
633           exit(EXIT_FAILURE);
634        }
635        if (l->size != sizeof(oid_str)/sizeof(oid_str[0]) || memcmp(oid_str, l->data, l->size*sizeof(oid_str[0]))) {
636           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
637           exit(EXIT_FAILURE);
638        }
639        l = l->next;
640        if (l->type != LTC_ASN1_NULL) {
641           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
642           exit(EXIT_FAILURE);
643        }
644        l = l->next;
645        if (l->next != NULL || l->child == NULL) {
646           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
647           exit(EXIT_FAILURE);
648        }
649        if (l->type != LTC_ASN1_SET) {
650           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
651           exit(EXIT_FAILURE);
652        }
653        l = l->child;
654        if (l->next == NULL || l->child != NULL) {
655           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
656           exit(EXIT_FAILURE);
657        }
658        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
659           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
660           exit(EXIT_FAILURE);
661        }
662        if (l->size != XSTRLEN(set2_str) || memcmp(set2_str, l->data, l->size)) {
663           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
664           exit(EXIT_FAILURE);
665        }
666        l = l->next;
667        if (l->type != LTC_ASN1_PRINTABLE_STRING) {
668           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
669           exit(EXIT_FAILURE);
670        }
671        if (l->size != XSTRLEN(set1_str) || memcmp(set1_str, l->data, l->size)) {
672           fprintf(stderr, "(%d), %d, %lu, next=%p, prev=%p, parent=%p, child=%p\n", __LINE__, l->type, l->size, l->next, l->prev, l->parent, l->child);
673           exit(EXIT_FAILURE);
674        }
675     der_sequence_free(l);
676  }
677  static int der_choice_n_custom_test(void)
678  {
679     ltc_asn1_list types[10], host[1], custom[1], root[1], child[1];
680     int boolean[1];
681     unsigned char bitbuf[10], octetbuf[10], ia5buf[10], printbuf[10], outbuf[256], custbuf[256], x, y;
682     wchar_t utf8buf[10];
683     unsigned long integer, oidbuf[10], outlen, custlen, inlen, n;
684     void          *mpinteger;
685     ltc_utctime   utctime = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
686     ltc_generalizedtime gtime = { 2038, 01, 19, 3, 14, 8, 0, 0, 0, 0 };
687     for (x = 0; x < sizeof(bitbuf); x++)   { bitbuf[x]   = x & 1; }
688     for (x = 0; x < sizeof(octetbuf); x++) { octetbuf[x] = x;     }
689     for (x = 0; x < sizeof(ia5buf); x++)   { ia5buf[x]   = 'a';   }
690     for (x = 0; x < sizeof(printbuf); x++) { printbuf[x] = 'a';   }
691     for (x = 0; x < sizeof(utf8buf)/sizeof(utf8buf[0]); x++) { utf8buf[x] = L'a';   }
692     integer = 1;
693     boolean[0] = 1;
694     for (x = 0; x < sizeof(oidbuf)/sizeof(oidbuf[0]); x++)   { oidbuf[x] = x + 1;   }
695     DO(mp_init(&mpinteger));
696     n = sizeof(types)/sizeof(types[0]);
697     for (x = 0; x < n * 2; x++) {
698         y = 0;
699         LTC_SET_ASN1(types, y++, LTC_ASN1_PRINTABLE_STRING, printbuf, sizeof(printbuf));
700         if (x > n) {
701            LTC_SET_ASN1(types, y++, LTC_ASN1_BIT_STRING, bitbuf, sizeof(bitbuf));
702         } else {
703            LTC_SET_ASN1(types, y++, LTC_ASN1_RAW_BIT_STRING, bitbuf, sizeof(bitbuf));
704         }
705         LTC_SET_ASN1(types, y++, LTC_ASN1_OCTET_STRING, octetbuf, sizeof(octetbuf));
706         LTC_SET_ASN1(types, y++, LTC_ASN1_IA5_STRING, ia5buf, sizeof(ia5buf));
707         LTC_SET_ASN1(types, y++, LTC_ASN1_BOOLEAN, boolean, sizeof(boolean)/sizeof(boolean[0]));
708         if (x > n) {
709            LTC_SET_ASN1(types, y++, LTC_ASN1_SHORT_INTEGER, &integer, 1);
710         } else {
711            LTC_SET_ASN1(types, y++, LTC_ASN1_INTEGER, mpinteger, 1);
712         }
713         LTC_SET_ASN1(types, y++, LTC_ASN1_OBJECT_IDENTIFIER, oidbuf, sizeof(oidbuf)/sizeof(oidbuf[0]));
714         if (x > n) {
715            LTC_SET_ASN1(types, y++, LTC_ASN1_UTCTIME, &utctime, 1);
716         } else {
717            LTC_SET_ASN1(types, y++, LTC_ASN1_GENERALIZEDTIME, &gtime, 1);
718         }
719         LTC_SET_ASN1(custom, 0, LTC_ASN1_NULL, NULL, 0);
720         LTC_SET_ASN1_CUSTOM_CONSTRUCTED(types, y++, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0, custom);
721         LTC_SET_ASN1(types, y++, LTC_ASN1_UTF8_STRING, utf8buf, sizeof(utf8buf)/sizeof(utf8buf[0]));
722         LTC_SET_ASN1(host, 0, LTC_ASN1_CHOICE, types, n);
723         outlen = sizeof(outbuf);
724         DO(der_encode_sequence(&types[x % n], 1, outbuf, &outlen));
725         child[0] = types[x % n];
726         if (x < n) {
727            LTC_SET_ASN1_CUSTOM_CONSTRUCTED(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child);
728         } else {
729            LTC_SET_ASN1_CUSTOM_PRIMITIVE(root, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 1uLL << (x % n), child->type, child->data, child->size);
730         }
731         custlen = sizeof(custbuf);
732         if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
733            DO(der_encode_custom_type(root, custbuf, &custlen));
734         }
735         inlen = outlen;
736         DO(der_decode_sequence(outbuf, inlen, host, 1));
737         for (y = 0; y < n; y++) {
738             if (types[y].used && y != (x % n)) {
739                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to one\n", y, x);
740                 return 1;
741             }
742             if (!types[y].used && y == (x % n)) {
743                 fprintf(stderr, "CHOICE, flag %u in trial %u was incorrectly set to zero\n", y, x);
744                 return 1;
745             }
746        }
747        if (child[0].type != LTC_ASN1_CUSTOM_TYPE || root->pc != LTC_ASN1_PC_PRIMITIVE) {
748           DO(der_decode_custom_type(custbuf, custlen, root));
749        }
750    }
751    mp_clear(mpinteger);
752    return 0;
753  }
754  static void s_der_decode_print(const void* p, unsigned long* plen)
755  {
756     ltc_asn1_list *list;
757     DO(der_decode_sequence_flexi(p, plen, &list));
758  #ifdef LTC_DER_TESTS_PRINT_FLEXI
759     fprintf(stderr, "\n\n");
760     s_der_tests_print_flexi(list, 0);
761     fprintf(stderr, "\n\n");
762  #endif
763     der_sequence_free(list);
764  }
765  static const unsigned char eckey_privc_der[] = {
766    0x30, 0x81, 0xf0, 0x02, 0x01, 0x01, 0x04, 0x18, 0x96, 0x9d, 0x28, 0xf2, 0x40, 0x48, 0x19, 0x11,
767    0x79, 0xb0, 0x47, 0x8e, 0x8c, 0x6b, 0x3d, 0x9b, 0xf2, 0x31, 0x16, 0x10, 0x08, 0x72, 0xb1, 0x86,
768    0xa0, 0x81, 0xb2, 0x30, 0x81, 0xaf, 0x02, 0x01, 0x01, 0x30, 0x24, 0x06, 0x07, 0x2a, 0x86, 0x48,
769    0xce, 0x3d, 0x01, 0x01, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
770    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30,
771    0x4b, 0x04, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
772    0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x04, 0x18, 0x22, 0x12, 0x3d,
773    0xc2, 0x39, 0x5a, 0x05, 0xca, 0xa7, 0x42, 0x3d, 0xae, 0xcc, 0xc9, 0x47, 0x60, 0xa7, 0xd4, 0x62,
774    0x25, 0x6b, 0xd5, 0x69, 0x16, 0x03, 0x15, 0x00, 0xc4, 0x69, 0x68, 0x44, 0x35, 0xde, 0xb3, 0x78,
775    0xc4, 0xb6, 0x5c, 0xa9, 0x59, 0x1e, 0x2a, 0x57, 0x63, 0x05, 0x9a, 0x2e, 0x04, 0x19, 0x02, 0x7d,
776    0x29, 0x77, 0x81, 0x00, 0xc6, 0x5a, 0x1d, 0xa1, 0x78, 0x37, 0x16, 0x58, 0x8d, 0xce, 0x2b, 0x8b,
777    0x4a, 0xee, 0x8e, 0x22, 0x8f, 0x18, 0x96, 0x02, 0x19, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
778    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x62, 0xd0, 0x31, 0xc8, 0x3f, 0x42, 0x94, 0xf6, 0x40,
779    0xec, 0x13, 0x02, 0x01, 0x01, 0xa1, 0x1c, 0x03, 0x1a, 0x00, 0x02, 0x55, 0x2c, 0xb8, 0x73, 0x5c,
780    0x9d, 0x98, 0xe4, 0x57, 0xfe, 0xd5, 0x96, 0x0a, 0x73, 0x8d, 0x82, 0xd7, 0xce, 0x05, 0xa9, 0x79,
781    0x91, 0x5c, 0xf9
782  };
783  static const unsigned char eckey_privs_der[] = {
784    0x30, 0x50, 0x02, 0x01, 0x01, 0x04, 0x14, 0x82, 0xef, 0x42, 0x0b, 0xc7, 0xe2, 0x9f, 0x3a, 0x84,
785    0xe5, 0x74, 0xec, 0x9c, 0xc5, 0x10, 0x26, 0x63, 0x8d, 0xb5, 0x46, 0xa0, 0x07, 0x06, 0x05, 0x2b,
786    0x81, 0x04, 0x00, 0x09, 0xa1, 0x2c, 0x03, 0x2a, 0x00, 0x04, 0xb5, 0xb1, 0x5a, 0xb0, 0x2a, 0x10,
787    0xd1, 0xf5, 0x4d, 0x6a, 0x41, 0xde, 0xcd, 0x69, 0x09, 0xb3, 0x5f, 0x26, 0xb0, 0xa2, 0xaf, 0xd3,
788    0x02, 0x89, 0x5e, 0xd4, 0x96, 0x5c, 0xbc, 0x2a, 0x7e, 0x75, 0x85, 0x86, 0x29, 0xb3, 0x29, 0x13,
789    0x77, 0xc3
790  };
791  static void der_custom_test(void)
792  {
793     ltc_asn1_list bool_ean[1], seq1[1], custom[1];
794     int boolean;
795     unsigned long len;
796     unsigned char buf[1024];
797     unsigned char buf1[] = { 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
798     unsigned char buf2[] = { 0x30, 0x08, 0xbf, 0xa0, 0x00, 0x04, 0x30, 0x02, 0x05, 0x00 };
799     boolean = 0x1;
800     LTC_SET_ASN1(bool_ean, 0, LTC_ASN1_BOOLEAN, &boolean, 1);
801     LTC_SET_ASN1(seq1, 0, LTC_ASN1_SEQUENCE, bool_ean, 1);
802     LTC_SET_ASN1_CUSTOM_CONSTRUCTED(custom, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x1000, seq1);
803     DO(der_length_custom_type(custom, &len, NULL));
804     len = sizeof(buf);
805     DO(der_encode_custom_type(custom, buf, &len));
806     s_der_decode_print(buf, &len);
807     boolean = 0x0;
808     DO(der_decode_custom_type(buf, len, custom));
809     DO(der_length_sequence(custom, 1, &len));
810     len = sizeof(buf);
811     DO(der_encode_sequence(custom, 1, buf, &len));
812     s_der_decode_print(buf, &len);
813     boolean = 0x0;
814     DO(der_decode_sequence(buf, len, custom, 1));
815     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
816     DO(der_length_custom_type(bool_ean, &len, NULL));
817     len = sizeof(buf);
818     DO(der_encode_custom_type(bool_ean, buf, &len));
819     s_der_decode_print(buf, &len);
820     LTC_SET_ASN1_CUSTOM_PRIMITIVE(bool_ean, 0, LTC_ASN1_CL_CONTEXT_SPECIFIC, 0x8000, LTC_ASN1_BOOLEAN, &boolean, 1);
821     DO(der_decode_custom_type(buf, len, bool_ean));
822     len = sizeof(buf1);
823     s_der_decode_print(buf1, &len);
824     len = sizeof(buf2);
825     s_der_decode_print(buf2, &len);
826     len = sizeof(eckey_privc_der);
827     s_der_decode_print(eckey_privc_der, &len);
828     len = sizeof(eckey_privs_der);
829     s_der_decode_print(eckey_privs_der, &len);
830  }
831  typedef int (*s_der_Xcode)(const void*, unsigned long, void*, unsigned long*);
832  typedef struct {
833     s_der_Xcode encode;
834     s_der_Xcode decode;
835     const void* in;
836     size_t in_sz;
837     size_t factor;
838     size_t type_sz;
839     const char* what;
840  } der_Xcode_t;
841  static void der_Xcode_run(const der_Xcode_t* x)
842  {
843     unsigned long l1, l2, sz;
844     void *d1, *d2;
845     int err;
846     l1 = 1;
847     d1 = XMALLOC(l1 * x->type_sz);
848     sz = (x->in_sz * x->factor)/x->type_sz;
849     if ((err = x->encode(x->in, sz, d1, &l1)) == CRYPT_BUFFER_OVERFLOW) {
850        d1 = XREALLOC(d1, l1 * x->type_sz);
851     }
852     DO(x->encode(x->in, sz, d1, &l1));
853     l2 = 1;
854     d2 = XMALLOC(l2 * x->type_sz);
855     while ((err = x->decode(d1, l1, d2, &l2)) == CRYPT_BUFFER_OVERFLOW) {
856        d2 = XREALLOC(d2, l2 * x->type_sz);
857     }
858     DO(x->decode(d1, l1, d2, &l2));
859     DO(do_compare_testvector(d2, (l2/x->factor) * x->type_sz, x->in, x->in_sz, x->what, __LINE__));
860     XFREE(d2);
861     XFREE(d1);
862  }
863  #if defined(_MSC_VER)
864  #define typeof(x) x
865  #endif
866  #define DER_XCODE_X(n, b, x) {  \
867        (s_der_Xcode)der_encode_ ## n,    \
868        (s_der_Xcode)der_decode_ ## n,    \
869        b,                   \
870        sizeof(b),           \
871        x,                   \
872        sizeof(typeof(b[0])),\
873        #n                   \
874  }
875  #define DER_XCODE(n, b) DER_XCODE_X(n, b, 1)
876  static void der_Xcode_test(void)
877  {
878     unsigned long i;
879     ltc_asn1_list *list;
880     ltc_asn1_list ttex_neg_int[2];
881     unsigned char buf[128];
882     void* mpinteger;
883     const unsigned long oid[3] = { 1, 23, 42 };
884     const unsigned char bit_string[] = { 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1 };
885     const unsigned char multi_buf[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
886     const char multi_string[] = {'l','i','b','t','o','m','c','r','y','p','t'};
887     const wchar_t wchar_string[] = L"libtomcrypt";
888     const unsigned char teletex_neg_int[] = {   0x30, 0x11, 0x14, 0x0b, 0x6c, 0x69, 0x62, 0x74,
889                                                 0x6f, 0x6d, 0x63, 0x72, 0x79, 0x70, 0x74, 0x02,
890                                                 0x02, 0xfc, 0x19 };
891     const der_Xcode_t xcode_tests[] =
892     {
893      DER_XCODE(bit_string, bit_string),
894      DER_XCODE_X(raw_bit_string, multi_buf, 8),
895      DER_XCODE(octet_string, multi_buf),
896      DER_XCODE(object_identifier, oid),
897      DER_XCODE(ia5_string, multi_string),
898      DER_XCODE(printable_string, multi_string),
899      DER_XCODE(utf8_string, wchar_string),
900     };
901     for (i = 0; i < sizeof(xcode_tests)/sizeof(xcode_tests[0]); ++i) {
902        der_Xcode_run(&xcode_tests[i]);
903     }
904     i = sizeof(teletex_neg_int);
905     DO(der_decode_sequence_flexi(teletex_neg_int, &i, &list));
906  #ifdef LTC_DER_TESTS_PRINT_FLEXI
907     fprintf(stderr, "\n\n");
908     s_der_tests_print_flexi(list, 0);
909     fprintf(stderr, "\n\n");
910  #endif
911     if (list->child == NULL || list->child->next == NULL)
912        exit(EXIT_FAILURE);
913     ttex_neg_int[0] = *list->child->next;
914     i = sizeof(buf);
915     DO(der_encode_sequence(ttex_neg_int, 1, buf, &i));
916     der_sequence_free(list);
917     DO(mp_init(&mpinteger));
918     LTC_SET_ASN1(ttex_neg_int, 0, LTC_ASN1_TELETEX_STRING, buf, sizeof(buf));
919     LTC_SET_ASN1(ttex_neg_int, 1, LTC_ASN1_INTEGER, mpinteger, 1);
920     DO(der_decode_sequence(teletex_neg_int, sizeof(teletex_neg_int), ttex_neg_int, 2));
921     mp_clear(mpinteger);
922  }
923  #ifdef LTC_TEST_READDIR
924  static int s_der_decode_sequence_flexi(const void *in, unsigned long inlen, void* ctx)
925  {
926     ltc_asn1_list** list = ctx;
927     if (der_decode_sequence_flexi(in, &inlen, list) == CRYPT_OK) {
928  #ifdef LTC_DER_TESTS_PRINT_FLEXI
929        fprintf(stderr, "\n\n");
930        s_der_tests_print_flexi(*list, 0);
931        fprintf(stderr, "\n\n");
932  #endif
933        der_sequence_free(*list);
934     }
935     return CRYPT_OK;
936  }
937  #endif
938  static void s_der_regression_test(void)
939  {
940     static const unsigned char s_broken_sequence[] = {
941       0x30,0x41,0x02,0x84,0x7f,0xff,0xff,0xff,0x1e,0x41,0xb4,0x79,0xad,0x57,0x69,
942       0x05,0xb9,0x60,0xfe,0x14,0xea,0xdb,0x91,0xb0,0xcc,0xf3,0x48,0x43,0xda,0xb9,
943       0x16,0x17,0x3b,0xb8,0xc9,0xcd,0x02,0x1d,0x00,0xad,0xe6,0x59,0x88,0xd2,0x37,
944       0xd3,0x0f,0x9e,0xf4,0x1d,0xd4,0x24,0xa4,0xe1,0xc8,0xf1,0x69,0x67,0xcf,0x33,
945       0x65,0x81,0x3f,0xe8,0x78,0x62,0x36
946     };
947     static const unsigned char s_addtl_bytes[] = {
948       0x30,0x45,0x02,0x21,0x00,0xb7,0xba,0xba,0xe9,0x33,0x2b,0x54,0xb8,0xa3,0xa0,0x5b,0x70,0x04,0x57,
949       0x98,0x21,0xa8,0x87,0xa1,0xb2,0x14,0x65,0xf7,0xdb,0x8a,0x3d,0x49,0x1b,0x39,0xfd,0x2c,0x3f,0x02,
950       0x20,0x74,0x72,0x91,0xdd,0x2f,0x3f,0x44,0xaf,0x7a,0xce,0x68,0xea,0x33,0x43,0x1d,0x6f,0x94,0xe4,
951       0x18,0xc1,0x06,0xa6,0xe7,0x62,0x85,0xcd,0x59,0xf4,0x32,0x60,0xec,0xce,0x00,0x00
952     };
953     static const unsigned char issue_507[] = "\x30\x04"           &bsol;* Start DER-sequence of length 4 */
954                                              "\x0c\x02\xbf\xbf"   &bsol;* Start UTF8 string of actual length 2 and evaluated length 3 */
955                                              "\xaa"               &bsol;* One byte padding */
956                                              "\x04\x82\xff\xff";  &bsol;* Start OCTET sequence of length 0xffff */
957     unsigned long len;
958     void *x, *y;
959     ltc_asn1_list seq[2];
960     ltc_asn1_list *l;
961     mp_init_multi(&x, &y, LTC_NULL);
962     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
963     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
964     SHOULD_FAIL(der_decode_sequence(s_broken_sequence, sizeof(s_broken_sequence), seq, 2));
965     mp_cleanup_multi(&y, &x, LTC_NULL);
966     len = sizeof(s_broken_sequence);
967     mp_init_multi(&x, &y, LTC_NULL);
968     LTC_SET_ASN1(seq, 0, LTC_ASN1_INTEGER, x, 1UL);
969     LTC_SET_ASN1(seq, 1, LTC_ASN1_INTEGER, y, 1UL);
970     SHOULD_FAIL_WITH(der_decode_sequence(s_addtl_bytes, sizeof(s_addtl_bytes), seq, 2), CRYPT_INPUT_TOO_LONG);
971     mp_cleanup_multi(&y, &x, LTC_NULL);
972     len = sizeof(s_addtl_bytes);
973     s_der_decode_print(s_addtl_bytes, &len);
974     len = sizeof(issue_507);
975     SHOULD_FAIL(der_decode_sequence_flexi(issue_507, &len, &l));
976  }
977  static void der_toolong_test(void)
978  {
979     int n, err, failed = 0;
980     ltc_asn1_list *list;
981     unsigned long len, oid[16];
982     unsigned char buf5[5], buf12[12], buf32[32];
983     static const unsigned char invalid1[] = {
984           0x30,0x19, &bsol;* SEQUENCE len=25 bytes */
985                0x30,0x0a, &bsol;* SEQUENCE len=10 bytes (which is wrong, should be 9) */
986                     0x04,0x05, &bsol;* OCTET STRING len=5 */ 0x2b,0x0e,0x03,0x02,0x1a,
987                     0x05,0x00, &bsol;* NULL */
988                0x04,0x0c, &bsol;* OCTET STRING len=12 */ 0xf7,0xff,0x9e,0x8b,0x7b,0xb2,0xe0,0x9b,0x70,0x93,0x5a,0x5d,
989     };
990     static const unsigned char invalid2[] = {
991           0x30,0x0d, &bsol;* SEQUENCE len=13 bytes*/
992                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
993                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
994           0x00,0x00 &bsol;* garbage after the sequence, der_decode_sequence_flexi should ignore this */
995     };
996     static const unsigned char invalid3[] = {
997           0x30,0x0f, &bsol;* SEQUENCE len=15 bytes*/
998                0x02,0x05, &bsol;* INTEGER len=5 */ 0x00,0xb7,0xba,0xba,0xe9,
999                0x02,0x04, &bsol;* INTEGER len=4 */ 0x74,0x72,0x91,0xdd,
1000                0x00,0x00  &bsol;* garbage inside the sequence */
1001     };
1002     static const unsigned char invalid4[] = {
1003           0x30, 0x30,
1004                 0x30, 0x0d,
1005                       0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1006                       0x05, 0x00,
1007                 0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95, 0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc, 0x00, 0x83, 0x2c,
1008                             0x20, 0xa6, 0xec, 0x11, 0x3d, 0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f, 0x34, 0x5e, 0x25
1009     };
1010     static const unsigned char invalid5[] = {
1011            0x30, 0x31,
1012                  0x30, 0x0e,
1013                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1014                        0x05, 0x00,
1015                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1016                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1017     };
1018     static const unsigned char invalid6[] = {
1019            0x30, 0x31,
1020                  0x30, 0x0c,
1021                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
1022                        0x05, 0x00,
1023                  0x04, 0x20, 0x53, 0x2e, 0xaa, 0xbd, 0x95,0x74, 0x88, 0x0d, 0xbf, 0x76, 0xb9, 0xb8, 0xcc,0x00, 0x83, 0x2c,
1024                              0x20, 0xa6, 0xec, 0x11, 0x3d,0x68, 0x22, 0x99, 0x55, 0x0d, 0x7a, 0x6e, 0x0f,0x34, 0x5e, 0x25
1025     };
1026     ltc_asn1_list seqsub[2], seqoid[2], seqmain[2], seqint[2];
1027     void *int1, *int2;
1028     LTC_SET_ASN1(seqsub,  0, LTC_ASN1_OCTET_STRING, buf5,   5);
1029     LTC_SET_ASN1(seqsub,  1, LTC_ASN1_NULL,         NULL,   0);
1030     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,     seqsub, 2);
1031     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING, buf12,  12);
1032     n = 1;
1033     len = sizeof(invalid1);
1034     err = der_decode_sequence_strict(invalid1, len, seqmain, 2);
1035     if (err == CRYPT_OK) {
1036        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1037        failed = 1;
1038     }
1039     len = sizeof(invalid1);
1040     err = der_decode_sequence_flexi(invalid1, &len, &list);
1041     if (err == CRYPT_OK) {
1042        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1043        failed = 1;
1044        der_sequence_free(list);
1045     }
1046     mp_init_multi(&int1, &int2, LTC_NULL);
1047     LTC_SET_ASN1(seqint,  0, LTC_ASN1_INTEGER,      int1,   1);
1048     LTC_SET_ASN1(seqint,  1, LTC_ASN1_INTEGER,      int2,   1);
1049     n++;
1050     len = sizeof(invalid2);
1051     err = der_decode_sequence_strict(invalid2, len, seqint, 2);
1052     if (err == CRYPT_OK) {
1053        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1054        failed = 1;
1055     }
1056     len = sizeof(invalid2);
1057     err = der_decode_sequence_flexi(invalid2, &len, &list);
1058     if (err != CRYPT_OK || len != 15) {
1059        fprintf(stderr,"der_decode_sequence_flexi failed, err=%d (expected 0) len=%lu (expected 15)\n", err, len);
1060        failed = 1;
1061     }
1062     if (err == CRYPT_OK)
1063        der_sequence_free(list);
1064     n++;
1065     len = sizeof(invalid3);
1066     err = der_decode_sequence_strict(invalid3, len, seqint, 2);
1067     if (err == CRYPT_OK) {
1068        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1069        failed = 1;
1070     }
1071     len = sizeof(invalid3);
1072     err = der_decode_sequence_flexi(invalid3, &len, &list);
1073     if (err == CRYPT_OK) {
1074        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1075        failed = 1;
1076        der_sequence_free(list);
1077     }
1078     mp_clear_multi(int1, int2, LTC_NULL);
1079     LTC_SET_ASN1(seqoid,  0, LTC_ASN1_OBJECT_IDENTIFIER, oid, sizeof(oid)/sizeof(oid[0]));
1080     LTC_SET_ASN1(seqoid,  1, LTC_ASN1_NULL,              NULL,   0);
1081     LTC_SET_ASN1(seqmain, 0, LTC_ASN1_SEQUENCE,          seqoid, 2);
1082     LTC_SET_ASN1(seqmain, 1, LTC_ASN1_OCTET_STRING,      buf32,  32);
1083     n++;
1084     len = sizeof(invalid4);
1085     err = der_decode_sequence_strict(invalid4, len, seqmain, 2);
1086     if (err == CRYPT_OK) {
1087        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1088        failed = 1;
1089     }
1090     len = sizeof(invalid4);
1091     err = der_decode_sequence_flexi(invalid4, &len, &list);
1092     if (err == CRYPT_OK) {
1093        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1094        failed = 1;
1095        der_sequence_free(list);
1096     }
1097     n++;
1098     len = sizeof(invalid5);
1099     err = der_decode_sequence_strict(invalid5, len, seqmain, 2);
1100     if (err == CRYPT_OK) {
1101        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1102        failed = 1;
1103     }
1104     len = sizeof(invalid5);
1105     err = der_decode_sequence_flexi(invalid5, &len, &list);
1106     if (err == CRYPT_OK) {
1107        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1108        failed = 1;
1109        der_sequence_free(list);
1110     }
1111     n++;
1112     len = sizeof(invalid6);
1113     err = der_decode_sequence_strict(invalid6, len, seqmain, 2);
1114     if (err == CRYPT_OK) {
1115        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence\n", n);
1116        failed = 1;
1117     }
1118     len = sizeof(invalid6);
1119     err = der_decode_sequence_flexi(invalid6, &len, &list);
1120     if (err == CRYPT_OK) {
1121        fprintf(stderr,"Sequence invalid%d accepted by der_decode_sequence_flexi\n", n);
1122        failed = 1;
1123        der_sequence_free(list);
1124     }
1125     if (failed) exit(EXIT_FAILURE);
1126  }
1127  static void s_der_recursion_limit(void)
1128  {
1129     unsigned int n, m;
1130     unsigned long integer = 123, s;
1131     ltc_asn1_list seqs[LTC_DER_MAX_RECURSION + 2], dummy[1], *flexi;
1132     unsigned char buf[2048];
1133     for (m = 0; m < 3; ++m) {
1134        LTC_SET_ASN1(dummy, 0, LTC_ASN1_SHORT_INTEGER, &integer, 1);
1135        LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION + 1, LTC_ASN1_SEQUENCE, dummy, 1);
1136        for (n = m; n < LTC_DER_MAX_RECURSION + 1; ++n) {
1137           LTC_SET_ASN1(seqs, LTC_DER_MAX_RECURSION - n, LTC_ASN1_SEQUENCE, &seqs[LTC_DER_MAX_RECURSION - n + 1], 1);
1138        }
1139        s = sizeof(buf);
1140        DO(der_encode_sequence(&seqs[m], 1, buf, &s));
1141        DO(der_decode_sequence(buf, s, &seqs[m], 1));
1142        if (m < 2) {
1143           SHOULD_FAIL(der_decode_sequence_flexi(buf, &s, &flexi));
1144        }
1145        else {
1146           DO(der_decode_sequence_flexi(buf, &s, &flexi));
1147           der_free_sequence_flexi(flexi);
1148        }
1149     }
1150  }
1151  int der_test(void)
1152  {
1153     unsigned long x, y, z, zz, oid[2][32];
1154     unsigned char buf[3][2048];
1155     void *a, *b, *c, *d, *e, *f, *g;
1156     static const unsigned char rsa_oid_der[] = { 0x06, 0x06, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d };
1157     static const unsigned long rsa_oid[]     = { 1, 2, 840, 113549 };
1158     static const unsigned char rsa_ia5[]     = "test1@rsa.com";
1159     static const unsigned char rsa_ia5_der[] = { 0x16, 0x0d, 0x74, 0x65, 0x73, 0x74, 0x31,
1160                                                  0x40, 0x72, 0x73, 0x61, 0x2e, 0x63, 0x6f, 0x6d };
1161     static const unsigned char rsa_printable[] = "Test User 1";
1162     static const unsigned char rsa_printable_der[] = { 0x13, 0x0b, 0x54, 0x65, 0x73, 0x74, 0x20, 0x55,
1163                                                        0x73, 0x65, 0x72, 0x20, 0x31 };
1164     static const ltc_utctime   rsa_time1 = { 91, 5, 6, 16, 45, 40, 1, 7, 0 };
1165     static const ltc_utctime   rsa_time2 = { 91, 5, 6, 23, 45, 40, 0, 0, 0 };
1166     ltc_utctime                tmp_time;
1167     static const unsigned char rsa_time1_der[] = { 0x17, 0x11, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x31, 0x36, 0x34, 0x35, 0x34, 0x30, 0x2D, 0x30, 0x37, 0x30, 0x30 };
1168     static const unsigned char rsa_time2_der[] = { 0x17, 0x0d, 0x39, 0x31, 0x30, 0x35, 0x30, 0x36, 0x32, 0x33, 0x34, 0x35, 0x34, 0x30, 0x5a };
1169     static const wchar_t utf8_1[]           = { 0x0041, 0x2262, 0x0391, 0x002E };
1170     static const unsigned char utf8_1_der[] = { 0x0C, 0x07, 0x41, 0xE2, 0x89, 0xA2, 0xCE, 0x91, 0x2E };
1171     static const wchar_t utf8_2[]           = { 0xD55C, 0xAD6D, 0xC5B4 };
1172     static const unsigned char utf8_2_der[] = { 0x0C, 0x09, 0xED, 0x95, 0x9C, 0xEA, 0xB5, 0xAD, 0xEC, 0x96, 0xB4 };
1173     static const wchar_t utf8_3[]           = { 0x05E9, 0x05DC, 0x05D5, 0x05DD };
1174     static const unsigned char utf8_3_der[] = { 0x0C, 0x08, 0xD7, 0xA9, 0xD7, 0x9C, 0xD7, 0x95, 0xD7, 0x9D };
1175     unsigned char utf8_buf[32];
1176     wchar_t utf8_out[32];
1177  #ifdef LTC_TEST_READDIR
1178     ltc_asn1_list *list;
1179  #endif
1180     if (ltc_mp.name == NULL) return CRYPT_NOP;
1181     s_der_recursion_limit();
1182     der_Xcode_test();
1183  #ifdef LTC_TEST_READDIR
1184     DO(test_process_dir("tests/asn1", &list, s_der_decode_sequence_flexi, NULL, "DER ASN.1 special cases"));
1185  #endif
1186     der_custom_test();
1187     s_der_regression_test();
1188     der_toolong_test();
1189     der_cacert_test();
1190     s_der_oid_test();
1191     y = 0xffffff00;
1192  #if ULONG_MAX == ULLONG_MAX
1193     y <<= 32;
1194  #endif
1195     while (y != 0) {
1196        x = sizeof(buf[0]);
1197        DO(der_encode_asn1_length(y, buf[0], &x));
1198        x = y + x;
1199        DO(der_decode_asn1_length(buf[0], &x, &z));
1200        if (y != z) {
1201           fprintf(stderr, "Failed to en- or decode length correctly! %lu != %lu\n", y, z);
1202           return 1;
1203        }
1204        y >>= 3;
1205     }
1206     DO(mp_init_multi(&a, &b, &c, &d, &e, &f, &g, LTC_NULL));
1207     for (zz = 0; zz < 16; zz++) {
1208  #ifdef USE_TFM
1209        for (z = 0; z < 256; z++) {
1210  #else
1211        for (z = 0; z < 1024; z++) {
1212  #endif
1213           ENSURE(yarrow_read(buf[0], z, &yarrow_prng) == z);
1214           DO(mp_read_unsigned_bin(a, buf[0], z));
1215           x = sizeof(buf[0]);
1216           DO(der_encode_integer(a, buf[0], &x));
1217           DO(der_length_integer(a, &y));
1218           if (y != x) { fprintf(stderr, "DER INTEGER size mismatch %lu != %lu\n", y, x); return 1; }
1219           mp_set_int(b, 0);
1220           DO(der_decode_integer(buf[0], y, b));
1221           if (y != x || mp_cmp(a, b) != LTC_MP_EQ) {
1222              fprintf(stderr, "%lu: %lu vs %lu\n", z, x, y);
1223              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1224              return 1;
1225           }
1226        }
1227     }
1228     for (zz = 0; zz < 256; zz++) {
1229        for (z = 1; z < 4; z++) {
1230           ENSURE(yarrow_read(buf[2], z, &yarrow_prng) == z);
1231           DO(mp_read_unsigned_bin(a, buf[2], z));
1232           x = sizeof(buf[0]);
1233           DO(der_encode_integer(a, buf[0], &x));
1234           y = sizeof(buf[1]);
1235           DO(der_encode_short_integer(mp_get_int(a), buf[1], &y));
1236           if (x != y || memcmp(buf[0], buf[1], x)) {
1237              fprintf(stderr, "DER INTEGER short encoding failed, %lu, %lu, 0x%lX\n", x, y, mp_get_int(a));
1238              for (zz = 0; zz < z; zz++) fprintf(stderr, "%02x ", buf[2][zz]);
1239              fprintf(stderr, "\n");
1240              for (z = 0; z < x; z++) fprintf(stderr, "%02x ", buf[0][z]);
1241              fprintf(stderr, "\n");
1242              for (z = 0; z < y; z++) fprintf(stderr, "%02x ", buf[1][z]);
1243              fprintf(stderr, "\n");
1244              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1245              return 1;
1246           }
1247           x = 0;
1248           DO(der_decode_short_integer(buf[1], y, &x));
1249           if (x != mp_get_int(a)) {
1250              fprintf(stderr, "DER INTEGER short decoding failed, %lu, %lu\n", x, mp_get_int(a));
1251              mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1252              return 1;
1253           }
1254        }
1255     }
1256     mp_clear_multi(a, b, c, d, e, f, g, LTC_NULL);
1257     for (zz = 1; zz < 1536; zz++) {
1258         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1259         for (z = 0; z < zz; z++) {
1260             buf[0][z] &= 0x01;
1261         }
1262         x = sizeof(buf[1]);
1263         DO(der_encode_bit_string(buf[0], zz, buf[1], &x));
1264         DO(der_length_bit_string(zz, &y));
1265         if (y != x) {
1266            fprintf(stderr, "\nDER BIT STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1267            return 1;
1268         }
1269         y = sizeof(buf[2]);
1270         DO(der_decode_bit_string(buf[1], x, buf[2], &y));
1271         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1272            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1273            return 1;
1274         }
1275     }
1276     for (zz = 1; zz < 1536; zz++) {
1277         ENSURE(yarrow_read(buf[0], zz, &yarrow_prng) == zz);
1278         x = sizeof(buf[1]);
1279         DO(der_encode_octet_string(buf[0], zz, buf[1], &x));
1280         DO(der_length_octet_string(zz, &y));
1281         if (y != x) {
1282            fprintf(stderr, "\nDER OCTET STRING length of encoded not match expected : %lu, %lu, %lu\n", z, x, y);
1283            return 1;
1284         }
1285         y = sizeof(buf[2]);
1286         DO(der_decode_octet_string(buf[1], x, buf[2], &y));
1287         if (y != zz || memcmp(buf[0], buf[2], zz)) {
1288            fprintf(stderr, "%lu, %lu, %d\n", y, zz, memcmp(buf[0], buf[2], zz));
1289            return 1;
1290         }
1291     }
1292     x = sizeof(buf[0]);
1293     DO(der_encode_object_identifier((unsigned long*)rsa_oid, sizeof(rsa_oid)/sizeof(rsa_oid[0]), buf[0], &x));
1294     if (x != sizeof(rsa_oid_der) || memcmp(rsa_oid_der, buf[0], x)) {
1295        fprintf(stderr, "rsa_oid_der encode failed to match, %lu, ", x);
1296        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1297        fprintf(stderr, "\n");
1298        return 1;
1299     }
1300     y = sizeof(oid[0])/sizeof(oid[0][0]);
1301     DO(der_decode_object_identifier(buf[0], x, oid[0], &y));
1302     if (y != sizeof(rsa_oid)/sizeof(rsa_oid[0]) || memcmp(rsa_oid, oid[0], sizeof(rsa_oid))) {
1303        fprintf(stderr, "rsa_oid_der decode failed to match, %lu, ", y);
1304        for (z = 0; z < y; z++) fprintf(stderr, "%lu ", oid[0][z]);
1305        fprintf(stderr, "\n");
1306        return 1;
1307     }
1308     for (zz = 0; zz < 5000; zz++) {
1309         ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1310         LOAD32L(z, buf[0]);
1311         z = 2 + (z % ((sizeof(oid[0])/sizeof(oid[0][0])) - 2));
1312         oid[0][0] = buf[0][0] % 3;
1313         oid[0][1] = buf[0][1] % 40;
1314         for (y = 2; y < z; y++) {
1315            ENSURE(yarrow_read(buf[0], 4, &yarrow_prng) == 4);
1316            LOAD32L(oid[0][y], buf[0]);
1317         }
1318         x = sizeof(buf[0]);
1319         DO(der_encode_object_identifier(oid[0], z, buf[0], &x));
1320         DO(der_length_object_identifier(oid[0], z, &y));
1321         if (x != y) {
1322            fprintf(stderr, "Random OID %lu test failed, length mismatch: %lu, %lu\n", z, x, y);
1323            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1324            return 1;
1325         }
1326         y = sizeof(oid[0])/sizeof(oid[0][0]);
1327         DO(der_decode_object_identifier(buf[0], x, oid[1], &y));
1328         if (y != z) {
1329            fprintf(stderr, "Random OID %lu test failed, decode length mismatch: %lu, %lu\n", z, x, y);
1330            return 1;
1331         }
1332         if (memcmp(oid[0], oid[1], sizeof(oid[0][0]) * z)) {
1333            fprintf(stderr, "Random OID %lu test failed, decoded values wrong\n", z);
1334            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[0][x]);
1335            fprintf(stderr, "\n\n Got \n\n");
1336            for (x = 0; x < z; x++) fprintf(stderr, "%lu\n", oid[1][x]);
1337            return 1;
1338         }
1339     }
1340     x = sizeof(buf[0]);
1341     DO(der_encode_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), buf[0], &x));
1342     if (x != sizeof(rsa_ia5_der) || memcmp(buf[0], rsa_ia5_der, x)) {
1343        fprintf(stderr, "IA5 encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_ia5_der));
1344        return 1;
1345     }
1346     DO(der_length_ia5_string(rsa_ia5, XSTRLEN((char*)rsa_ia5), &y));
1347     if (y != x) {
1348        fprintf(stderr, "IA5 length failed to match: %lu, %lu\n", x, y);
1349        return 1;
1350     }
1351     y = sizeof(buf[1]);
1352     DO(der_decode_ia5_string(buf[0], x, buf[1], &y));
1353     if (y != XSTRLEN((char*)rsa_ia5) || memcmp(buf[1], rsa_ia5, XSTRLEN((char*)rsa_ia5))) {
1354         fprintf(stderr, "DER IA5 failed test vector\n");
1355         return 1;
1356     }
1357     x = sizeof(buf[0]);
1358     DO(der_encode_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), buf[0], &x));
1359     if (x != sizeof(rsa_printable_der) || memcmp(buf[0], rsa_printable_der, x)) {
1360        fprintf(stderr, "PRINTABLE encode failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_printable_der));
1361        return 1;
1362     }
1363     DO(der_length_printable_string(rsa_printable, XSTRLEN((char*)rsa_printable), &y));
1364     if (y != x) {
1365        fprintf(stderr, "printable length failed to match: %lu, %lu\n", x, y);
1366        return 1;
1367     }
1368     y = sizeof(buf[1]);
1369     DO(der_decode_printable_string(buf[0], x, buf[1], &y));
1370     if (y != XSTRLEN((char*)rsa_printable) || memcmp(buf[1], rsa_printable, XSTRLEN((char*)rsa_printable))) {
1371         fprintf(stderr, "DER printable failed test vector\n");
1372         return 1;
1373     }
1374     x = sizeof(buf[0]);
1375     DO(der_encode_utctime((ltc_utctime*)&rsa_time1, buf[0], &x));
1376     if (x != sizeof(rsa_time1_der) || memcmp(buf[0], rsa_time1_der, x)) {
1377        fprintf(stderr, "UTCTIME encode of rsa_time1 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1378        fprintf(stderr, "\n\n");
1379        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1380        fprintf(stderr, "\n");
1381        return 1;
1382     }
1383     DO(der_length_utctime((ltc_utctime*)&rsa_time1, &y));
1384     if (y != x) {
1385        fprintf(stderr, "UTCTIME length failed to match for rsa_time1: %lu, %lu\n", x, y);
1386        return 1;
1387     }
1388     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1389     if (y != x || memcmp(&rsa_time1, &tmp_time, sizeof(ltc_utctime))) {
1390        fprintf(stderr, "UTCTIME decode failed for rsa_time1: %lu %lu\n", x, y);
1391  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1392  tmp_time.YY,
1393  tmp_time.MM,
1394  tmp_time.DD,
1395  tmp_time.hh,
1396  tmp_time.mm,
1397  tmp_time.ss,
1398  tmp_time.off_dir,
1399  tmp_time.off_mm,
1400  tmp_time.off_hh);
1401        return 1;
1402     }
1403     x = sizeof(buf[0]);
1404     DO(der_encode_utctime((ltc_utctime*)&rsa_time2, buf[0], &x));
1405     if (x != sizeof(rsa_time2_der) || memcmp(buf[0], rsa_time2_der, x)) {
1406        fprintf(stderr, "UTCTIME encode of rsa_time2 failed: %lu, %lu\n", x, (unsigned long)sizeof(rsa_time1_der));
1407        fprintf(stderr, "\n\n");
1408        for (y = 0; y < x; y++) fprintf(stderr, "%02x ", buf[0][y]);
1409        fprintf(stderr, "\n");
1410        return 1;
1411     }
1412     DO(der_length_utctime((ltc_utctime*)&rsa_time2, &y));
1413     if (y != x) {
1414        fprintf(stderr, "UTCTIME length failed to match for rsa_time2: %lu, %lu\n", x, y);
1415        return 1;
1416     }
1417     DO(der_decode_utctime(buf[0], &y, &tmp_time));
1418     if (y != x || memcmp(&rsa_time2, &tmp_time, sizeof(ltc_utctime))) {
1419        fprintf(stderr, "UTCTIME decode failed for rsa_time2: %lu %lu\n", x, y);
1420  fprintf(stderr, "\n\n%u %u %u %u %u %u %u %u %u\n\n",
1421  tmp_time.YY,
1422  tmp_time.MM,
1423  tmp_time.DD,
1424  tmp_time.hh,
1425  tmp_time.mm,
1426  tmp_time.ss,
1427  tmp_time.off_dir,
1428  tmp_time.off_mm,
1429  tmp_time.off_hh);
1430        return 1;
1431     }
1432       x = sizeof(utf8_buf);
1433       DO(der_encode_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), utf8_buf, &x));
1434       DO(der_length_utf8_string(utf8_1, sizeof(utf8_1) / sizeof(utf8_1[0]), &y));
1435       if (x != sizeof(utf8_1_der) || memcmp(utf8_buf, utf8_1_der, x) || x != y) {
1436          fprintf(stderr, "DER UTF8_1 encoded to %lu bytes\n", x);
1437          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1438          fprintf(stderr, "\n");
1439          return 1;
1440       }
1441       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1442       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1443       if (y != (sizeof(utf8_1) / sizeof(utf8_1[0])) || memcmp(utf8_1, utf8_out, y * sizeof(wchar_t))) {
1444          fprintf(stderr, "DER UTF8_1 decoded to %lu wchar_t\n", y);
1445          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1446          fprintf(stderr, "\n");
1447          return 1;
1448       }
1449       x = sizeof(utf8_buf);
1450       DO(der_encode_utf8_string(utf8_2, sizeof(utf8_2) / sizeof(utf8_2[0]), utf8_buf, &x));
1451       if (x != sizeof(utf8_2_der) || memcmp(utf8_buf, utf8_2_der, x)) {
1452          fprintf(stderr, "DER UTF8_2 encoded to %lu bytes\n", x);
1453          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1454          fprintf(stderr, "\n");
1455          return 1;
1456       }
1457       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1458       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1459       if (y != (sizeof(utf8_2) / sizeof(utf8_2[0])) || memcmp(utf8_2, utf8_out, y * sizeof(wchar_t))) {
1460          fprintf(stderr, "DER UTF8_2 decoded to %lu wchar_t\n", y);
1461          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1462          fprintf(stderr, "\n");
1463          return 1;
1464       }
1465       x = sizeof(utf8_buf);
1466       DO(der_encode_utf8_string(utf8_3, sizeof(utf8_3) / sizeof(utf8_3[0]), utf8_buf, &x));
1467       if (x != sizeof(utf8_3_der) || memcmp(utf8_buf, utf8_3_der, x)) {
1468          fprintf(stderr, "DER UTF8_3 encoded to %lu bytes\n", x);
1469          for (y = 0; y < x; y++) fprintf(stderr, "%02x ", (unsigned)utf8_buf[y]);
1470          fprintf(stderr, "\n");
1471          return 1;
1472       }
1473       y = sizeof(utf8_out) / sizeof(utf8_out[0]);
1474       DO(der_decode_utf8_string(utf8_buf, x, utf8_out, &y));
1475       if (y != (sizeof(utf8_3) / sizeof(utf8_3[0])) || memcmp(utf8_3, utf8_out, y * sizeof(wchar_t))) {
1476          fprintf(stderr, "DER UTF8_3 decoded to %lu wchar_t\n", y);
1477          for (x = 0; x < y; x++) fprintf(stderr, "%04lx ", (unsigned long)utf8_out[x]);
1478          fprintf(stderr, "\n");
1479          return 1;
1480       }
1481     der_set_test();
1482     der_flexi_test();
1483     return der_choice_n_custom_test();
1484  }
1485  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-verify-dft.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_test.c</div>
                </div>
                <div class="column column_space"><pre><code>119       k.k.recopy_input = 0;
120       k.p = p;
121       n = tensor_sz(p->sz);
122       a = (C *) bench_malloc(n * sizeof(C));
123       b = (C *) bench_malloc(n * sizeof(C));
124       accuracy_test(&k.k, 0, p->sign, n, a, b, rounds, impulse_rounds, t);
125       bench_free(b);
126       bench_free(a);
127  }
</pre></code></div>
                <div class="column column_space"><pre><code>445     oid[0] = 3;
446     oid[1] = 4;
447     oid[2] = 5;
448     len = sizeof(buf);
449     SHOULD_FAIL(der_encode_object_identifier(oid, 3, buf, &len));
450     len = sizeof(buf);
451     SHOULD_FAIL(der_length_object_identifier(oid, 3, &len));
452  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    