<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mosaicing_dispatch.c &amp; conver_dispatch.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mosaicing_dispatch.c &amp; conver_dispatch.c
      </h3>
<h1 align="center">
        44.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mosaicing_dispatch.c (49.66555%)<th>conver_dispatch.c (40.35326%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(146-197)<td><a href="#" name="0">(199-239)</a><td align="center"><font color="#ff0000">40</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(435-489)<td><a href="#" name="1">(333-374)</a><td align="center"><font color="#df0000">35</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(384-429)<td><a href="#" name="2">(427-468)</a><td align="center"><font color="#d80000">34</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(660-708)<td><a href="#" name="3">(550-617)</a><td align="center"><font color="#bf0000">30</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(495-539)<td><a href="#" name="4">(1093-1126)</a><td align="center"><font color="#b20000">28</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(71-120)<td><a href="#" name="5">(1238-1272)</a><td align="center"><font color="#ac0000">27</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(337-375)<td><a href="#" name="6">(662-705)</a><td align="center"><font color="#990000">24</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(546-587)<td><a href="#" name="7">(269-299)</a><td align="center"><font color="#8c0000">22</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(220-251)<td><a href="#" name="8">(836-866)</a><td align="center"><font color="#790000">19</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(710-748)<td><a href="#" name="9">(127-153)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(597-624)<td><a href="#" name="10">(51-71)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(201-204)<td><a href="#" name="11">(160-163)</a><td align="center"><font color="#4c0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mosaicing_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/transform.h&gt;
static im_arg_desc merge_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "dx" ),
	IM_INPUT_INT( "dy" ),
	IM_INPUT_INT( "mwidth" )
};
static im_arg_desc merge1_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "xr1" ),
	IM_INPUT_INT( "yr1" ),
	IM_INPUT_INT( "xs1" ),
	IM_INPUT_INT( "ys1" ),
	IM_INPUT_INT( "xr2" ),
	IM_INPUT_INT( "yr2" ),
<a name="5"></a>	IM_INPUT_INT( "xs2" ),
	IM_INPUT_INT( "ys2" ),
	IM_INPUT_INT( "mwidth" )
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
static im_arg_desc mosaic_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "bandno" ),
	IM_INPUT_INT( "xr" ),
	IM_INPUT_INT( "yr" ),
	IM_INPUT_INT( "xs" ),
	IM_INPUT_INT( "ys" ),
	IM_INPUT_INT( "halfcorrelation" ),
	IM_INPUT_INT( "halfarea" ),
	IM_INPUT_INT( "balancetype" ),
	IM_INPUT_INT( "mwidth" )
};
static im_arg_desc mosaic1_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "bandno" ),
	IM_INPUT_INT( "xr1" ),
	IM_INPUT_INT( "yr1" ),
	IM_INPUT_INT( "xs1" ),
	IM_INPUT_INT( "ys1" ),
	IM_INPUT_INT( "xr2" ),
	IM_INPUT_INT( "yr2" ),
	IM_INPUT_INT( "xs2" ),
	IM_INPUT_INT( "ys2" ),
	IM_INPUT_INT( "halfcorrelation" ),
	IM_INPUT_INT( "halfarea" ),
	IM_INPUT_INT( "balancetype" ),
	IM_INPUT_INT( "mwidth" )
};
static int
lrmosaic_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr = *((int *) argv[4]);
	int yr = *((int *) argv[5]);
	int xs = *((int *) argv[6]);
	int ys = *((int *) argv[7]);</b></font>
	int halfcorrelation = *((int *) argv[8]);
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);
	return( vips__lrmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}
static int
lrmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
<a name="0"></a>	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int ys2 = *((int *) argv[11]);
	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
	int mwidth = *((int *) argv[15]);
	return( im_lrmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}
static im_function lrmosaic_desc = {
	"im_lrmosaic", 				"left-right mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmosaic_vec, 				IM_NUMBER( mosaic_args ), 			mosaic_args 			};
static im_arg_desc find_overlap_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_INPUT_INT( "bandno" ),
	IM_INPUT_INT( "xr" ),
	IM_INPUT_INT( "yr" ),
	IM_INPUT_INT( "xs" ),
	IM_INPUT_INT( "ys" ),
	IM_INPUT_INT( "halfcorrelation" ),
	IM_INPUT_INT( "halfarea" ),
	IM_OUTPUT_INT( "dx0" ),
	IM_OUTPUT_INT( "dy0" ),
	IM_OUTPUT_DOUBLE( "scale1" ),
	IM_OUTPUT_DOUBLE( "angle1" ),
	IM_OUTPUT_DOUBLE( "dx1" ),
	IM_OUTPUT_DOUBLE( "dy1" )
};
static int
find_lroverlap_vec( im_object *argv )
{
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);</b></font>
<a name="11"></a>	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];</b></font>
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];
	IMAGE *t;
	int result;
	if( !(t = im_open( "find_lroverlap_vec", "p" )) )
		return( -1 );
	result = vips__find_lroverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
<a name="8"></a>		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( result );
}
static im_function find_lroverlap_desc = {
	"im__find_lroverlap",			"search for left-right overlap of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		find_lroverlap_vec, 			IM_NUMBER( find_overlap_args ),		find_overlap_args 		};
static im_function lrmosaic1_desc = {
	"im_lrmosaic1",				"first-order left-right mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmosaic1_vec, 				IM_NUMBER( mosaic1_args ), 		mosaic1_args 			};
static int
tbmosaic_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int x1 = *((int *) argv[4]);</b></font>
	int y1 = *((int *) argv[5]);
	int x2 = *((int *) argv[6]);
	int y2 = *((int *) argv[7]);
	int halfcorrelation = *((int *) argv[8]);
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);
	return( vips__tbmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		x1, y1, x2, y2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}
static int
tbmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
	int ys2 = *((int *) argv[11]);
	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
	int mwidth = *((int *) argv[15]);
	return( im_tbmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}
static int
find_tboverlap_vec( im_object *argv )
{
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);
	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];
	IMAGE *t;
	int result;
	if( !(t = im_open( "find_tboverlap_vec", "p" )) )
		return( -1 );
	result = vips__find_tboverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );
	return( result );
}
static im_function find_tboverlap_desc = {
	"im__find_tboverlap",			"search for top-bottom overlap of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,	<a name="6"></a>	find_tboverlap_vec, 			IM_NUMBER( find_overlap_args ),		find_overlap_args 		<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
static im_function tbmosaic_desc = {
	"im_tbmosaic", 				"top-bottom mosaic of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmosaic_vec, 				IM_NUMBER( mosaic_args ), 			mosaic_args 			};
static im_function tbmosaic1_desc = {
	"im_tbmosaic1",				"first-order top-bottom mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmosaic1_vec, 				IM_NUMBER( mosaic1_args ), 		mosaic1_args 			};
static int
lrmerge_vec( im_object *argv )
{
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);
	return( im_lrmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}
static int</b></font>
lrmerge1_vec( im_object *argv )
{
	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
<a name="2"></a>	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int xs2 = *((int *) argv[9]);
	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);
	return( im_lrmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}
static im_function lrmerge_desc = {
	"im_lrmerge", 				"left-right merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmerge_vec, 				IM_NUMBER( merge_args ), 			merge_args 			};
static im_function lrmerge1_desc = {
	"im_lrmerge1", 				"first-order left-right merge of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmerge1_vec, 				IM_NUMBER( merge1_args ), 			merge1_args 			};
static int
tbmerge_vec( im_object *argv )
{
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);
	return( im_tbmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}
static int</b></font>
tbmerge1_vec( im_object *argv )
{
<a name="1"></a>	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
	int xs2 = *((int *) argv[9]);
	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);
	return( im_tbmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}
static im_function tbmerge_desc = {
	"im_tbmerge", 				"top-bottom merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmerge_vec, 				IM_NUMBER( merge_args ), 			merge_args 			};
static im_function tbmerge1_desc = {
	"im_tbmerge1", 				"first-order top-bottom merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmerge1_vec, 				IM_NUMBER( merge1_args ), 			merge1_args 			};
static im_arg_desc match_linear_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "xref1" ),
	IM_INPUT_INT( "yref1" ),
	IM_INPUT_INT( "xsec1" ),
	IM_INPUT_INT( "ysec1" ),
	IM_INPUT_INT( "xref2" ),
	IM_INPUT_INT( "yref2" ),
	IM_INPUT_INT( "xsec2" ),
	IM_INPUT_INT( "ysec2" )
};
static int
match_linear_vec( im_object *argv )
{</b></font>
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);
<a name="4"></a>	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int yref2 = *((int *) argv[8]);
	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);
	return( im_match_linear( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2 ) );
}
static im_function match_linear_desc = {
	"im_match_linear", 			"resample ref so that tie-points match",
	IM_FN_PIO,				match_linear_vec, 			IM_NUMBER( match_linear_args ), 		match_linear_args 		};
static im_arg_desc match_linear_search_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "xref1" ),
	IM_INPUT_INT( "yref1" ),
	IM_INPUT_INT( "xsec1" ),
	IM_INPUT_INT( "ysec1" ),
	IM_INPUT_INT( "xref2" ),
	IM_INPUT_INT( "yref2" ),
	IM_INPUT_INT( "xsec2" ),
	IM_INPUT_INT( "ysec2" ),
	IM_INPUT_INT( "hwindowsize" ),
	IM_INPUT_INT( "hsearchsize" )
};
static int
match_linear_search_vec( im_object *argv )
{
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);</b></font>
	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
<a name="7"></a>	int yref2 = *((int *) argv[8]);
	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int hwin = *((int *) argv[11]);
	int hsrch = *((int *) argv[12]);
	return( im_match_linear_search( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2,
		hwin, hsrch ) );
}
static im_function match_linear_search_desc = {
	"im_match_linear_search", 		"search sec, then resample so that tie-points match",
	IM_FN_PIO,				match_linear_search_vec, 		IM_NUMBER( match_linear_search_args ),	match_linear_search_args 	};
static im_arg_desc correl_args[] = {
	IM_INPUT_IMAGE( "ref" ),
	IM_INPUT_IMAGE( "sec" ),
	IM_INPUT_INT( "xref" ),
	IM_INPUT_INT( "yref" ),
	IM_INPUT_INT( "xsec" ),
	IM_INPUT_INT( "ysec" ),
	IM_INPUT_INT( "hwindowsize" ),
	IM_INPUT_INT( "hsearchsize" ),
	IM_OUTPUT_DOUBLE( "correlation" ),
	IM_OUTPUT_INT( "x" ),
	IM_OUTPUT_INT( "y" )
};
static int
correl_vec( im_object *argv )
{
	int xref = *((int *) argv[2]);</b></font>
	int yref = *((int *) argv[3]);
	int xsec = *((int *) argv[4]);
	int ysec = *((int *) argv[5]);
	int cor = *((int *) argv[6]);
	int area = *((int *) argv[7]);
	int *x = (int *) argv[8];
<a name="10"></a>	int *y = (int *) argv[9];
	double *correlation = (double *) argv[10];
<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( vips__correl( argv[0], argv[1], 
		xref, yref, xsec, ysec, cor, area, correlation, x, y ) );
}
static im_function correl_desc = {
	"im_correl", 				"search area around sec for match for area around ref",
	IM_FN_PIO,				correl_vec, 				IM_NUMBER( correl_args ), 			correl_args 			};
static im_arg_desc global_balance_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_DOUBLE( "gamma" )
};
static int
global_balance_vec( im_object *argv )
{</b></font>
	double gamma = *((double *) argv[2]);
	return( im_global_balance( argv[0], argv[1], gamma ) );
}
static im_function global_balance_desc = {
	"im_global_balance",			"automatically rebuild mosaic with balancing",
	IM_FN_TRANSFORM | IM_FN_PIO,		global_balance_vec, 			IM_NUMBER( global_balance_args ),		global_balance_args 		};
static int
global_balancef_vec( im_object *argv )
{
	double gamma = *((double *) argv[2]);
	return( im_global_balancef( argv[0], argv[1], gamma ) );
}
static im_function global_balancef_desc = {
	"im_global_balancef",			"automatically rebuild mosaic with balancing, float output",
	IM_FN_TRANSFORM | IM_FN_PIO,	<a name="3"></a>	global_balancef_vec, 			IM_NUMBER( global_balance_args ),		global_balance_args 		<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
static im_arg_desc remosaic_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_STRING( "old_str" ),
	IM_INPUT_STRING( "new_str" )
};
static int
remosaic_vec( im_object *argv )
{
	return( im_remosaic( argv[0], argv[1], argv[2], argv[3] ) );
}
static im_function remosaic_desc = {
	"im_remosaic",			"automatically rebuild mosaic with new files",
	IM_FN_TRANSFORM | IM_FN_PIO,		remosaic_vec, 			IM_NUMBER( remosaic_args ),	remosaic_args 		};
static int align_bands_vec( im_object *argv ){
  return im_align_bands( (IMAGE*)argv[0], (IMAGE*)argv[1] );
}
static im_arg_desc align_bands_arg_types[]= {
  IM_INPUT_IMAGE( "in" ),
  IM_OUTPUT_IMAGE( "out" )
};
static im_function align_bands_desc= {
  "im_align_bands",
  "align the bands of an image",
  0,
  align_bands_vec,
  IM_NUMBER( align_bands_arg_types ),
  align_bands_arg_types
};
<a name="9"></a>
static int maxpos_subpel_vec( im_object *argv ){</b></font>
  return im_maxpos_subpel( (IMAGE*)argv[0], (double*)argv[1], (double*)argv[2] );
<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static im_arg_desc maxpos_subpel_arg_types[]= {
  IM_INPUT_IMAGE( "im" ),
  IM_OUTPUT_DOUBLE( "x" ),
  IM_OUTPUT_DOUBLE( "y" )
};
static im_function maxpos_subpel_desc= {
  "im_maxpos_subpel",
  "subpixel position of maximum of (phase correlation) image",
  IM_FN_PIO,
  maxpos_subpel_vec,
  IM_NUMBER( maxpos_subpel_arg_types ),
  maxpos_subpel_arg_types
};
static im_function *mos_list[] = {
        &amp;align_bands_desc,
	&amp;correl_desc,
	&amp;find_lroverlap_desc,
	&amp;find_tboverlap_desc,
	&amp;global_balance_desc,
	&amp;global_balancef_desc,
	&amp;lrmerge_desc,
	&amp;lrmerge1_desc,
	&amp;lrmosaic_desc,
	&amp;lrmosaic1_desc,
	&amp;match_linear_desc,
	&amp;match_linear_search_desc,
        &amp;maxpos_subpel_desc,
	&amp;remosaic_desc,
	&amp;tbmerge_desc,
	&amp;tbmerge1_desc,
	&amp;tbmosaic_desc,
	&amp;tbmosaic1_desc
};</b></font>
im_package im__mosaicing = {
	"mosaicing",
	IM_NUMBER( mos_list ),
	mos_list
};
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>conver_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
static int
system_vec( im_object *argv )
{
	IMAGE *in = argv[0];
	char *cmd = argv[1];
	char **out = (char **) &amp;argv[2];
<a name="10"></a>	if( im_system( in, cmd, out ) )
		return( -1 );
<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}
static im_arg_desc system_args[] = {
	IM_INPUT_IMAGE( "im" ),
	IM_INPUT_STRING( "command" ),
	IM_OUTPUT_STRING( "output" )
};
static im_function system_desc = {
	"im_system",				"run command on image",			0,					system_vec, 				IM_NUMBER( system_args ),		system_args 			};
static int
system_image_vec( im_object *argv )
{</b></font>
	IMAGE *in = argv[0];
	IMAGE *out = argv[1];
	char *in_format = argv[2];
	char *out_format = argv[3];
	char *cmd = argv[4];
	char **log = (char **) &amp;argv[5];
	IMAGE *out_image;
	if( !(out_image = im_system_image( in, 
		in_format, out_format, cmd, log )) ) {
		im_error( "im_system_image", "%s", *log );
		return( -1 );
	}
	if( im_copy( out_image, out ) ||
		im_add_close_callback( out, 
			(im_callback_fn) im_close, out_image, NULL ) ) {
		im_close( out_image );
		return( -1 );
	}
	return( 0 );
}
static im_arg_desc system_image_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_STRING( "in_format" ),
	IM_INPUT_STRING( "out_format" ),
	IM_INPUT_STRING( "command" ),
	IM_OUTPUT_STRING( "log" )
};
static im_function system_image_desc = {
	"im_system_image",			"run command on image, with image output",	0,					system_image_vec, 			IM_NUMBER( system_image_args ),		system_image_args 		};
static int
subsample_vec( im_object *argv )
{
	IMAGE *in = argv[0];
	IMAGE *out = argv[1];
	int xsh = *((int *) argv[2]);
	int ysh = *((int *) argv[3]);
	if( im_subsample( in, out, xsh, ysh ) )
<a name="9"></a>		return( -1 );
	return( 0 );
<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static im_arg_desc subsample_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "xshrink" ),
	IM_INPUT_INT( "yshrink" )
};
static im_function subsample_desc = {
	"im_subsample",				"subsample image by integer factors",		IM_FN_PIO,				subsample_vec,				IM_NUMBER( subsample_args ), 		subsample_args 			};
static im_arg_desc gaussnoise_args[] = {
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "xsize" ),
	IM_INPUT_INT( "ysize" ),
	IM_INPUT_DOUBLE( "mean" ),
	IM_INPUT_DOUBLE( "sigma" )
};</b></font>
<a name="11"></a>static int
gaussnoise_vec( im_object *argv )
{
<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int xsize = *((int *) argv[1]);
	int ysize = *((int *) argv[2]);
	double mean = *((double *) argv[3]);
	double sigma = *((double *) argv[4]);</b></font>
	if( im_gaussnoise( argv[0], xsize, ysize, mean, sigma ) )
		return( -1 );
	return( 0 );
}
static im_function gaussnoise_desc = {
	"im_gaussnoise", 			"generate image of gaussian noise with specified statistics",
	IM_FN_PIO | IM_FN_NOCACHE,		gaussnoise_vec, 			IM_NUMBER( gaussnoise_args ), 		gaussnoise_args 		};
static im_arg_desc extract_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "left" ),
	IM_INPUT_INT( "top" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "height" ),
	IM_INPUT_INT( "band" )
};
<a name="0"></a>static int
extract_vec( im_object *argv )
{
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int left = *((int *) argv[2]);
	int top = *((int *) argv[3]);
	int width = *((int *) argv[4]);
	int height = *((int *) argv[5]);
	int band = *((int *) argv[6]);
	return( im_extract_areabands( argv[0], argv[1], 
		left, top, width, height, band, 1 ) );
}
static im_function extract_desc = {
	"im_extract", 				"extract area/band",			IM_FN_TRANSFORM | IM_FN_PIO,		extract_vec, 				IM_NUMBER( extract_args ), 		extract_args 			};
static im_arg_desc extract_area_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "left" ),
	IM_INPUT_INT( "top" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "height" )
};
static int
extract_area_vec( im_object *argv )
{
	int x = *((int *) argv[2]);
	int y = *((int *) argv[3]);
	int w = *((int *) argv[4]);
	int h = *((int *) argv[5]);</b></font>
	return( im_extract_area( argv[0], argv[1], x, y, w, h ) );
}
static im_function extract_area_desc = {
	"im_extract_area", 			"extract area",				IM_FN_TRANSFORM | IM_FN_PIO,		extract_area_vec, 			IM_NUMBER( extract_area_args ), 	extract_area_args 		};
static im_arg_desc extract_bands_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "band" ),
	IM_INPUT_INT( "nbands" ),
};
<a name="7"></a>static int
extract_bands_vec( im_object *argv )
{
<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int chsel = *((int *) argv[2]);
	int nbands = *((int *) argv[3]);
	return( im_extract_bands( argv[0], argv[1], chsel, nbands ) );
}
static im_function extract_bands_desc = {
	"im_extract_bands", 			"extract several bands",		IM_FN_PIO,				extract_bands_vec, 			IM_NUMBER( extract_bands_args ),	extract_bands_args 		};
static im_arg_desc extract_band_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "band" )
};
static int
extract_band_vec( im_object *argv )
{
	int chsel = *((int *) argv[2]);</b></font>
	return( im_extract_band( argv[0], argv[1], chsel ) );
}
static im_function extract_band_desc = {
	"im_extract_band", 			"extract band",				IM_FN_PIO,				extract_band_vec, 			IM_NUMBER( extract_band_args ), 	extract_band_args 		};
static im_arg_desc extract_areabands_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "left" ),
	IM_INPUT_INT( "top" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "height" ),
	IM_INPUT_INT( "band" ),
	IM_INPUT_INT( "nbands" )
};
<a name="1"></a>static int
extract_areabands_vec( im_object *argv )
{
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int left = *((int *) argv[2]);
	int top = *((int *) argv[3]);
	int width = *((int *) argv[4]);
	int height = *((int *) argv[5]);
	int band = *((int *) argv[6]);
	int nbands = *((int *) argv[7]);
	return( im_extract_areabands( argv[0], argv[1],
		left, top, width, height, band, nbands ) );
}
static im_function extract_areabands_desc = {
	"im_extract_areabands",         	"extract area and bands",       	IM_FN_TRANSFORM | IM_FN_PIO,		extract_areabands_vec,          	IM_NUMBER( extract_areabands_args ),	extract_areabands_args          };
static im_arg_desc one_in_one_out[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};
static im_arg_desc two_in_one_out[] = {
	IM_INPUT_IMAGE( "in1" ),
	IM_INPUT_IMAGE( "in2" ),
	IM_OUTPUT_IMAGE( "out" )
};
static int
bandjoin_vec( im_object *argv )
{</b></font>
	return( im_bandjoin( argv[0], argv[1], argv[2] ) );
}
static im_function bandjoin_desc = {
	"im_bandjoin", 				"bandwise join of two images",		IM_FN_PIO,				bandjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
static im_arg_desc gbandjoin_args[] = {
	IM_INPUT_IMAGEVEC( "in" ),
	IM_OUTPUT_IMAGE( "out" )
};
static int
gbandjoin_vec( im_object *argv )
{
	im_imagevec_object *iv = (im_imagevec_object *) argv[0];
	return( im_gbandjoin( iv-&gt;vec, argv[1], iv-&gt;n ) );
}
static im_function gbandjoin_desc = {
	"im_gbandjoin", 			"bandwise join of many images",		IM_FN_PIO,				gbandjoin_vec, 				IM_NUMBER( gbandjoin_args ), 		gbandjoin_args 			};
static im_arg_desc text_args[] = {
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_STRING( "text" ),
	IM_INPUT_STRING( "font" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "alignment" ),
	IM_INPUT_INT( "dpi" )
};
<a name="2"></a>static int
text_vec( im_object *argv )
{
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int width = *((int *) argv[3]);
	int alignment = *((int *) argv[4]);
	int dpi = *((int *) argv[5]);
	return( im_text( argv[0], argv[1], argv[2], width, alignment, dpi ) );
}
static im_function text_desc = {
	"im_text", 				"generate text image",			IM_FN_PIO,				text_vec, 				IM_NUMBER( text_args ), 		text_args 			};
static im_arg_desc black_args[] = {
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "x_size" ),
	IM_INPUT_INT( "y_size" ),
	IM_INPUT_INT( "bands" )
};
static int
black_vec( im_object *argv )
{
	int xs = *((int *) argv[1]);
	int ys = *((int *) argv[2]);
	int bands = *((int *) argv[3]);
	return( im_black( argv[0], xs, ys, bands ) );
}
static im_function black_desc = {</b></font>
	"im_black", 				"generate black image",			IM_FN_PIO,				black_vec, 				IM_NUMBER( black_args ), 		black_args 			};
static im_arg_desc clip2fmt_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "ofmt" )
};
static int
clip2fmt_vec( im_object *argv )
{
	int ofmt = *((int *) argv[2]);
	return( im_clip2fmt( argv[0], argv[1], ofmt ) );
}
static im_function clip2fmt_desc = {
	"im_clip2fmt", 				"convert image format to ofmt",		IM_FN_PIO | IM_FN_PTOP,			clip2fmt_vec, 				IM_NUMBER( clip2fmt_args ),		clip2fmt_args 			};
static int
c2rect_vec( im_object *argv )
{
	return( im_c2rect( argv[0], argv[1] ) );
}
static im_function c2rect_desc = {
	"im_c2rect", 				"convert phase and amplitude to real and imaginary",
	IM_FN_PTOP | IM_FN_PIO,			c2rect_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
c2amph_vec( im_object *argv )
{
	return( im_c2amph( argv[0], argv[1] ) );
}
static im_function c2amph_desc = {
	"im_c2amph", 				"convert real and imaginary to phase and amplitude",
	IM_FN_PTOP | IM_FN_PIO,			c2amph_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
<a name="3"></a>ri2c_vec( im_object *argv )
{
	return( im_ri2c( argv[0], argv[1], argv[2] ) );
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static im_function ri2c_desc = {
	"im_ri2c", 				"join two non-complex images to form complex",
	IM_FN_PTOP | IM_FN_PIO,			ri2c_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
static int
c2imag_vec( im_object *argv )
{
	return( im_c2imag( argv[0], argv[1] ) );
}
static im_function c2imag_desc = {
	"im_c2imag", 				"extract imaginary part of complex image",
	IM_FN_PTOP | IM_FN_PIO,			c2imag_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
c2real_vec( im_object *argv )
{
	return( im_c2real( argv[0], argv[1] ) );
}
static im_function c2real_desc = {
	"im_c2real", 				"extract real part of complex image",
	IM_FN_PTOP | IM_FN_PIO,			c2real_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static im_arg_desc copy_set_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "Type" ),
	IM_INPUT_DOUBLE( "Xres" ),
	IM_INPUT_DOUBLE( "Yres" ),
	IM_INPUT_INT( "Xoffset" ),
	IM_INPUT_INT( "Yoffset" )
};
static int
copy_set_vec( im_object *argv )
{</b></font>
	int Type = *((int *) argv[2]);
	float Xres = *((double *) argv[3]);
	float Yres = *((double *) argv[4]);
	int Xoffset = *((int *) argv[5]);
	int Yoffset = *((int *) argv[6]);
	return( im_copy_set( argv[0], argv[1],
		Type, Xres, Yres, Xoffset, Yoffset ) );
}
static im_function copy_set_desc = {
	"im_copy_set", 				"copy image, setting informational fields",
	IM_FN_PIO,			
	copy_set_vec, 				IM_NUMBER( copy_set_args ), 		copy_set_args 			};
static im_arg_desc copy_set_meta_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_STRING( "field" ),
	IM_INPUT_GVALUE( "value" )
};
static int
copy_set_meta_vec( im_object *argv )
{
	const char *field = argv[2];
<a name="6"></a>	GValue *value = argv[3];
	return( im_copy_set_meta( argv[0], argv[1], field, value ) ); 
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static im_function copy_set_meta_desc = {
	"im_copy_set_meta", 			"copy image, setting a meta field",
	IM_FN_PIO,			
	copy_set_meta_vec, 			IM_NUMBER( copy_set_meta_args ),	copy_set_meta_args 		};
static im_arg_desc copy_morph_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "Bands" ),
	IM_INPUT_INT( "BandFmt" ),
	IM_INPUT_INT( "Coding" )
};
static int
copy_morph_vec( im_object *argv )
{
	int Bands = *((int *) argv[2]);
	int BandFmt = *((int *) argv[3]);
	int Coding = *((int *) argv[4]);
	return( im_copy_morph( argv[0], argv[1],
		Bands, BandFmt, Coding ) );
}
static im_function copy_morph_desc = {</b></font>
	"im_copy_morph", 				"copy image, setting pixel layout",
	IM_FN_PIO,			
	copy_morph_vec, 			IM_NUMBER( copy_morph_args ), 		copy_morph_args 		};
static int
copy_vec( im_object *argv )
{
	return( im_copy( argv[0], argv[1] ) );
}
static im_function copy_desc = {
	"im_copy", 				"copy image",
	IM_FN_PIO | IM_FN_NOCACHE,
	copy_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
copy_file_vec( im_object *argv )
{
	return( im_copy_file( argv[0], argv[1] ) );
}
static im_function copy_file_desc = {
	"im_copy_file", 				"copy image to a file and return that",
	IM_FN_PIO,			
	copy_file_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
copy_swap_vec( im_object *argv )
{
	return( im_copy_swap( argv[0], argv[1] ) );
}
static im_function copy_swap_desc = {
	"im_copy_swap", 				"copy image, swapping byte order",
	IM_FN_PIO,			
	copy_swap_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
fliphor_vec( im_object *argv )
{
	return( im_fliphor( argv[0], argv[1] ) );
}
static im_function fliphor_desc = {
	"im_fliphor", 				"flip image left-right",
	IM_FN_PIO,				fliphor_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
flipver_vec( im_object *argv )
{
	return( im_flipver( argv[0], argv[1] ) );
}
static im_function flipver_desc = {
	"im_flipver", 				"flip image top-bottom",
	IM_FN_PIO,				flipver_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
<a name="8"></a>static int
falsecolour_vec( im_object *argv )
{
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_falsecolour( argv[0], argv[1] ) );
}
static im_function falsecolour_desc = {
	"im_falsecolour", 			"turn luminance changes into chrominance changes",
	IM_FN_PTOP | IM_FN_PIO,			falsecolour_vec, 			IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static im_arg_desc insert_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_INPUT_IMAGE( "sub" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "x" ),
	IM_INPUT_INT( "y" )
};
static int
insert_vec( im_object *argv )
{
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);</b></font>
	return( im_insert( argv[0], argv[1], argv[2], x, y ) );
}
static im_function insert_desc = {
	"im_insert", 				"insert sub-image into main image at position",
	IM_FN_PIO | IM_FN_TRANSFORM,		insert_vec, 				IM_NUMBER( insert_args ), 		insert_args 			};
static im_arg_desc insertset_args[] = {
	IM_INPUT_IMAGE( "main" ),
	IM_INPUT_IMAGE( "sub" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INTVEC( "x" ),
	IM_INPUT_INTVEC( "y" )
};
static int
insertset_vec( im_object *argv )
{
	im_intvec_object *xv = (im_intvec_object *) argv[3];
	im_intvec_object *yv = (im_intvec_object *) argv[4];
	if( xv-&gt;n != yv-&gt;n ) {
		im_error( "im_insertset", "%s", 
			_( "vectors not same length" ) );
		return( -1 );
	}
	if( im_insertset( argv[0], argv[1], argv[2], xv-&gt;n, xv-&gt;vec, yv-&gt;vec ) )
		return( -1 );
	return( 0 );
}
static im_function insertset_desc = {
	"im_insertset", 			"insert sub into main at every position in x, y",
	0,					insertset_vec, 				IM_NUMBER( insertset_args ), 		insertset_args 			};
static int
insert_noexpand_vec( im_object *argv )
{
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);
	return( im_insert_noexpand( argv[0], argv[1], argv[2], x, y ) );
}
static im_function insert_noexpand_desc = {
	"im_insert_noexpand", 			"insert sub-image into main image at position, no expansion",
	IM_FN_PIO | IM_FN_TRANSFORM,		insert_noexpand_vec, 			IM_NUMBER( insert_args ),		insert_args 			};
static int
rot180_vec( im_object *argv )
{
	return( im_rot180( argv[0], argv[1] ) );
}
static im_function rot180_desc = {
	"im_rot180", 				"rotate image 180 degrees",
	IM_FN_PIO | IM_FN_TRANSFORM,		rot180_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
rot90_vec( im_object *argv )
{
	return( im_rot90( argv[0], argv[1] ) );
}
static im_function rot90_desc = {
	"im_rot90", 				"rotate image 90 degrees clockwise",
	IM_FN_PIO | IM_FN_TRANSFORM,		rot90_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
rot270_vec( im_object *argv )
{
	return( im_rot270( argv[0], argv[1] ) );
}
static im_function rot270_desc = {
	"im_rot270", 				"rotate image 270 degrees clockwise",
	IM_FN_PIO | IM_FN_TRANSFORM,		rot270_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
lrjoin_vec( im_object *argv )
{
	return( im_lrjoin( argv[0], argv[1], argv[2] ) );
}
static im_function lrjoin_desc = {
	"im_lrjoin", 				"join two images left-right",
	IM_FN_PIO | IM_FN_TRANSFORM,		lrjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
static int
tbjoin_vec( im_object *argv )
{
	return( im_tbjoin( argv[0], argv[1], argv[2] ) );
}
static im_function tbjoin_desc = {
	"im_tbjoin", 				"join two images top-bottom",
	IM_FN_PIO | IM_FN_TRANSFORM,		tbjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
static int
scale_vec( im_object *argv )
{
	return( im_scale( argv[0], argv[1] ) );
}
static im_function scale_desc = {
	"im_scale", 				"scale image linearly to fit range 0-255",
	IM_FN_PIO,				scale_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static int
scaleps_vec( im_object *argv )
{
	return( im_scaleps( argv[0], argv[1] ) );
}
static im_function scaleps_desc = {
	"im_scaleps", 				"logarithmic scale of image to fit range 0-255",
	0,					scaleps_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
static im_arg_desc grid_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "tile_height" ),
	IM_INPUT_INT( "across" ),
	IM_INPUT_INT( "down" )
};
<a name="4"></a>static int
grid_vec( im_object *argv )
{
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int tile_height = *((int *) argv[2]);
	int across = *((int *) argv[3]);
	int down = *((int *) argv[4]);
	return( im_grid( argv[0], argv[1], tile_height, across, down ) );
}
static im_function grid_desc = {
	"im_grid", 				"chop a tall thin image into a grid of images",
	IM_FN_TRANSFORM | IM_FN_PIO,		grid_vec, 				IM_NUMBER( grid_args ), 		grid_args 			};
static im_arg_desc replicate_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "across" ),
	IM_INPUT_INT( "down" )
};
static int
replicate_vec( im_object *argv )
{
	int across = *((int *) argv[2]);
	int down = *((int *) argv[3]);</b></font>
	return( im_replicate( argv[0], argv[1], across, down ) );
}
static im_function replicate_desc = {
	"im_replicate", 			"replicate an image horizontally and vertically",
	IM_FN_TRANSFORM | IM_FN_PIO,		replicate_vec, 				IM_NUMBER( replicate_args ), 		replicate_args 			};
static im_arg_desc zoom_args[] = {
	IM_INPUT_IMAGE( "input" ),
	IM_OUTPUT_IMAGE( "output" ),
	IM_INPUT_INT( "xfac" ),
	IM_INPUT_INT( "yfac" )
};
static int
zoom_vec( im_object *argv )
{
	int xfac = *((int *) argv[2]);
	int yfac = *((int *) argv[3]);
	return( im_zoom( argv[0], argv[1], xfac, yfac ) );
}
static im_function zoom_desc = {
	"im_zoom", 				"simple zoom of an image by integer factors",
	IM_FN_TRANSFORM | IM_FN_PIO,		zoom_vec, 				IM_NUMBER( zoom_args ),			zoom_args 			};
static int
msb_vec (im_object * argv)
{
  return im_msb (argv[0], argv[1]);
}
static im_function msb_desc = {
  "im_msb",			  "convert to uchar by discarding bits",
  IM_FN_PIO | IM_FN_PTOP,	  msb_vec,			  IM_NUMBER (one_in_one_out),	  one_in_one_out		};
static im_arg_desc msb_band_args[] = {
  IM_INPUT_IMAGE ("in"),
  IM_OUTPUT_IMAGE ("out"),
  IM_INPUT_INT ("band")
};
static int
msb_band_vec (im_object * argv)
{
  IMAGE *in = (IMAGE *) argv[0];
  IMAGE *out = (IMAGE *) argv[1];
  int *band = (int *) argv[2];
  return im_msb_band (in, out, *band);
}
static im_function msb_band_desc = {
  "im_msb_band",		  "convert to single band uchar by discarding bits",
  IM_FN_PIO | IM_FN_PTOP,	  msb_band_vec,			  IM_NUMBER (msb_band_args),	  msb_band_args			};
static im_arg_desc wrap_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "x" ),
	IM_INPUT_INT( "y" )
};
static int
<a name="5"></a>wrap_vec (im_object * argv)
{
  return im_wrap( argv[0], argv[1], *(int*)argv[2], *(int*)argv[3] );
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static im_function wrap_desc = {
  "im_wrap",			  "shift image origin, wrapping at sides",
  IM_FN_PIO | IM_FN_TRANSFORM,	  wrap_vec,			  IM_NUMBER (wrap_args),	  wrap_args			};
static im_arg_desc embed_args[] = {
	IM_INPUT_IMAGE( "in" ),
	IM_OUTPUT_IMAGE( "out" ),
	IM_INPUT_INT( "type" ),
	IM_INPUT_INT( "x" ),
	IM_INPUT_INT( "y" ),
	IM_INPUT_INT( "width" ),
	IM_INPUT_INT( "height" )
};
static int
embed_vec( im_object *argv )
{
	int type = *((int *) argv[2]);
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);
	int width = *((int *) argv[5]);
	int height = *((int *) argv[6]);</b></font>
	return( im_embed( argv[0], argv[1], type, x, y, width, height ) );
}
static im_function embed_desc = {
	"im_embed",	 			"embed in within a set of borders", 
	IM_FN_PIO | IM_FN_TRANSFORM,		embed_vec, 				IM_NUMBER( embed_args ), 		embed_args 			};
static im_function *conv_list[] = {
	&amp;gaussnoise_desc,
	&amp;bandjoin_desc,
	&amp;black_desc,
	&amp;c2amph_desc,
	&amp;c2imag_desc,
	&amp;c2real_desc,
	&amp;c2rect_desc,
	&amp;clip2fmt_desc,
	&amp;copy_desc,
	&amp;copy_file_desc,
	&amp;copy_morph_desc,
	&amp;copy_swap_desc,
	&amp;copy_set_desc,
	&amp;copy_set_meta_desc,
	&amp;extract_area_desc,
	&amp;extract_areabands_desc,
	&amp;extract_band_desc,
	&amp;extract_bands_desc,
	&amp;extract_desc,
	&amp;falsecolour_desc,
	&amp;fliphor_desc,
	&amp;flipver_desc,
	&amp;gbandjoin_desc,
	&amp;grid_desc,
	&amp;insert_desc,
	&amp;insertset_desc,
	&amp;insert_noexpand_desc,
	&amp;embed_desc,
	&amp;lrjoin_desc,
        &amp;msb_desc,
        &amp;msb_band_desc,
	&amp;replicate_desc,
	&amp;ri2c_desc,
	&amp;rot180_desc,
	&amp;rot270_desc,
	&amp;rot90_desc,
	&amp;scale_desc,
	&amp;scaleps_desc,
	&amp;subsample_desc,
	&amp;system_desc,
	&amp;system_image_desc,
	&amp;tbjoin_desc,
	&amp;text_desc,
	&amp;wrap_desc,
	&amp;zoom_desc
};
im_package im__conversion = {
	"conversion",
	IM_NUMBER( conv_list ),
	conv_list
};
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
