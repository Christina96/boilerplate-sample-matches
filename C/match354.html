<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mosaicing_dispatch.c & conver_dispatch.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mosaicing_dispatch.c & conver_dispatch.c
      </h3>
      <h1 align="center">
        44.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mosaicing_dispatch.c (49.66555%)<TH>conver_dispatch.c (40.35326%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#0',2,'match354-1.html#0',3)" NAME="0">(146-197)<TD><A HREF="javascript:ZweiFrames('match354-0.html#0',2,'match354-1.html#0',3)" NAME="0">(199-239)</A><TD ALIGN=center><FONT COLOR="#ff0000">40</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#1',2,'match354-1.html#1',3)" NAME="1">(435-489)<TD><A HREF="javascript:ZweiFrames('match354-0.html#1',2,'match354-1.html#1',3)" NAME="1">(333-374)</A><TD ALIGN=center><FONT COLOR="#df0000">35</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#2',2,'match354-1.html#2',3)" NAME="2">(384-429)<TD><A HREF="javascript:ZweiFrames('match354-0.html#2',2,'match354-1.html#2',3)" NAME="2">(427-468)</A><TD ALIGN=center><FONT COLOR="#d80000">34</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#3',2,'match354-1.html#3',3)" NAME="3">(660-708)<TD><A HREF="javascript:ZweiFrames('match354-0.html#3',2,'match354-1.html#3',3)" NAME="3">(550-617)</A><TD ALIGN=center><FONT COLOR="#bf0000">30</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#4',2,'match354-1.html#4',3)" NAME="4">(495-539)<TD><A HREF="javascript:ZweiFrames('match354-0.html#4',2,'match354-1.html#4',3)" NAME="4">(1093-1126)</A><TD ALIGN=center><FONT COLOR="#b20000">28</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#5',2,'match354-1.html#5',3)" NAME="5">(71-120)<TD><A HREF="javascript:ZweiFrames('match354-0.html#5',2,'match354-1.html#5',3)" NAME="5">(1238-1272)</A><TD ALIGN=center><FONT COLOR="#ac0000">27</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#6',2,'match354-1.html#6',3)" NAME="6">(337-375)<TD><A HREF="javascript:ZweiFrames('match354-0.html#6',2,'match354-1.html#6',3)" NAME="6">(662-705)</A><TD ALIGN=center><FONT COLOR="#990000">24</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#7',2,'match354-1.html#7',3)" NAME="7">(546-587)<TD><A HREF="javascript:ZweiFrames('match354-0.html#7',2,'match354-1.html#7',3)" NAME="7">(269-299)</A><TD ALIGN=center><FONT COLOR="#8c0000">22</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#8',2,'match354-1.html#8',3)" NAME="8">(220-251)<TD><A HREF="javascript:ZweiFrames('match354-0.html#8',2,'match354-1.html#8',3)" NAME="8">(836-866)</A><TD ALIGN=center><FONT COLOR="#790000">19</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#9',2,'match354-1.html#9',3)" NAME="9">(710-748)<TD><A HREF="javascript:ZweiFrames('match354-0.html#9',2,'match354-1.html#9',3)" NAME="9">(127-153)</A><TD ALIGN=center><FONT COLOR="#520000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#10',2,'match354-1.html#10',3)" NAME="10">(597-624)<TD><A HREF="javascript:ZweiFrames('match354-0.html#10',2,'match354-1.html#10',3)" NAME="10">(51-71)</A><TD ALIGN=center><FONT COLOR="#520000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match354-0.html#11',2,'match354-1.html#11',3)" NAME="11">(201-204)<TD><A HREF="javascript:ZweiFrames('match354-0.html#11',2,'match354-1.html#11',3)" NAME="11">(160-163)</A><TD ALIGN=center><FONT COLOR="#4c0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mosaicing_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Function dispatch tables for mosaicing.
 *
 * J. Cupitt, 23/2/95
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/transform.h&gt;

/* Merge args.
 */
static im_arg_desc merge_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;dx&quot; ),
	IM_INPUT_INT( &quot;dy&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Merge1 args.
 */
static im_arg_desc merge1_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xr1&quot; ),
	IM_INPUT_INT( &quot;yr1&quot; ),
	IM_INPUT_INT( &quot;xs1&quot; ),
	IM_INPUT_INT( &quot;ys1&quot; ),
	IM_INPUT_INT( &quot;xr2&quot; ),
	IM_INPUT_INT( &quot;yr2&quot; ),
<A NAME="5"></A>	IM_INPUT_INT( &quot;xs2&quot; ),
	IM_INPUT_INT( &quot;ys2&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match354-1.html#5',3,'match354-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* Mosaic args.
 */
static im_arg_desc mosaic_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr&quot; ),
	IM_INPUT_INT( &quot;yr&quot; ),
	IM_INPUT_INT( &quot;xs&quot; ),
	IM_INPUT_INT( &quot;ys&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_INPUT_INT( &quot;balancetype&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Mosaic1 args.
 */
static im_arg_desc mosaic1_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr1&quot; ),
	IM_INPUT_INT( &quot;yr1&quot; ),
	IM_INPUT_INT( &quot;xs1&quot; ),
	IM_INPUT_INT( &quot;ys1&quot; ),
	IM_INPUT_INT( &quot;xr2&quot; ),
	IM_INPUT_INT( &quot;yr2&quot; ),
	IM_INPUT_INT( &quot;xs2&quot; ),
	IM_INPUT_INT( &quot;ys2&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_INPUT_INT( &quot;balancetype&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Call im_lrmosaic via arg vector.
 */
static int
lrmosaic_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr = *((int *) argv[4]);
	int yr = *((int *) argv[5]);
	int xs = *((int *) argv[6]);
	int ys = *((int *) argv[7]);</B></FONT>
	int halfcorrelation = *((int *) argv[8]);
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( vips__lrmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im_lrmosaic1 via arg vector.
 */
static int
lrmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
<A NAME="0"></A>	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match354-1.html#0',3,'match354-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int ys2 = *((int *) argv[11]);
	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
	int mwidth = *((int *) argv[15]);

	return( im_lrmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Description of im_lrmosaic.
 */ 
static im_function lrmosaic_desc = {
	&quot;im_lrmosaic&quot;, 			/* Name */
	&quot;left-right mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmosaic_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic_args ), 		/* Size of arg list */
	mosaic_args 			/* Arg list */
};

static im_arg_desc find_overlap_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr&quot; ),
	IM_INPUT_INT( &quot;yr&quot; ),
	IM_INPUT_INT( &quot;xs&quot; ),
	IM_INPUT_INT( &quot;ys&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_OUTPUT_INT( &quot;dx0&quot; ),
	IM_OUTPUT_INT( &quot;dy0&quot; ),
	IM_OUTPUT_DOUBLE( &quot;scale1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;angle1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;dx1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;dy1&quot; )
};

/* Call im__find_lroverlap via arg vector.
 */
static int
find_lroverlap_vec( im_object *argv )
{
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);</B></FONT>
<A NAME="11"></A>	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match354-1.html#11',3,'match354-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];</B></FONT>
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];

	IMAGE *t;
	int result;

	if( !(t = im_open( &quot;find_lroverlap_vec&quot;, &quot;p&quot; )) )
		return( -1 );
	result = vips__find_lroverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
<A NAME="8"></A>		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );

<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match354-1.html#8',3,'match354-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( result );
}

/* Description of im__find_lroverlap.
 */ 
static im_function find_lroverlap_desc = {
	&quot;im__find_lroverlap&quot;,		/* Name */
	&quot;search for left-right overlap of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	find_lroverlap_vec, 		/* Dispatch function */
	IM_NUMBER( find_overlap_args ),	/* Size of arg list */
	find_overlap_args 		/* Arg list */
};

/* Description of im_lrmosaic1.
 */ 
static im_function lrmosaic1_desc = {
	&quot;im_lrmosaic1&quot;,			/* Name */
	&quot;first-order left-right mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmosaic1_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic1_args ), 	/* Size of arg list */
	mosaic1_args 			/* Arg list */
};

/* Call im_tbmosaic via arg vector.
 */
static int
tbmosaic_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int x1 = *((int *) argv[4]);</B></FONT>
	int y1 = *((int *) argv[5]);
	int x2 = *((int *) argv[6]);
	int y2 = *((int *) argv[7]);
	int halfcorrelation = *((int *) argv[8]);
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( vips__tbmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		x1, y1, x2, y2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im_tbmosaic1 via arg vector.
 */
static int
tbmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
	int ys2 = *((int *) argv[11]);
	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
	int mwidth = *((int *) argv[15]);

	return( im_tbmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im__find_tboverlap via arg vector.
 */
static int
find_tboverlap_vec( im_object *argv )
{
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);
	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];

	IMAGE *t;
	int result;

	if( !(t = im_open( &quot;find_tboverlap_vec&quot;, &quot;p&quot; )) )
		return( -1 );
	result = vips__find_tboverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );

	return( result );
}

/* Description of im__find_tboverlap.
 */ 
static im_function find_tboverlap_desc = {
	&quot;im__find_tboverlap&quot;,		/* Name */
	&quot;search for top-bottom overlap of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
<A NAME="6"></A>	find_tboverlap_vec, 		/* Dispatch function */
	IM_NUMBER( find_overlap_args ),	/* Size of arg list */
	find_overlap_args 		/* Arg list */
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match354-1.html#6',3,'match354-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* Description of im_tbmosaic.
 */ 
static im_function tbmosaic_desc = {
	&quot;im_tbmosaic&quot;, 			/* Name */
	&quot;top-bottom mosaic of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmosaic_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic_args ), 		/* Size of arg list */
	mosaic_args 			/* Arg list */
};

/* Description of im_tbmosaic1.
 */ 
static im_function tbmosaic1_desc = {
	&quot;im_tbmosaic1&quot;,			/* Name */
	&quot;first-order top-bottom mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmosaic1_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic1_args ), 	/* Size of arg list */
	mosaic1_args 			/* Arg list */
};

/* Call im_lrmerge via arg vector.
 */
static int
lrmerge_vec( im_object *argv )
{
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);

	return( im_lrmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}

/* Call im_lrmerge1 via arg vector.
 */
static int</B></FONT>
lrmerge1_vec( im_object *argv )
{
	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
<A NAME="2"></A>	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match354-1.html#2',3,'match354-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int xs2 = *((int *) argv[9]);
	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( im_lrmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}

/* Description of im_lrmerge.
 */ 
static im_function lrmerge_desc = {
	&quot;im_lrmerge&quot;, 			/* Name */
	&quot;left-right merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmerge_vec, 			/* Dispatch function */
	IM_NUMBER( merge_args ), 		/* Size of arg list */
	merge_args 			/* Arg list */
};

/* Description of im_lrmerge1.
 */ 
static im_function lrmerge1_desc = {
	&quot;im_lrmerge1&quot;, 			/* Name */
	&quot;first-order left-right merge of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmerge1_vec, 			/* Dispatch function */
	IM_NUMBER( merge1_args ), 		/* Size of arg list */
	merge1_args 			/* Arg list */
};

/* Call im_tbmerge via arg vector.
 */
static int
tbmerge_vec( im_object *argv )
{
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);

	return( im_tbmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}

/* Call im_tbmerge1 via arg vector.
 */
static int</B></FONT>
tbmerge1_vec( im_object *argv )
{
<A NAME="1"></A>	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match354-1.html#1',3,'match354-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
	int xs2 = *((int *) argv[9]);
	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( im_tbmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}

/* Description of im_tbmerge.
 */ 
static im_function tbmerge_desc = {
	&quot;im_tbmerge&quot;, 			/* Name */
	&quot;top-bottom merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmerge_vec, 			/* Dispatch function */
	IM_NUMBER( merge_args ), 		/* Size of arg list */
	merge_args 			/* Arg list */
};

/* Description of im_tbmerge1.
 */ 
static im_function tbmerge1_desc = {
	&quot;im_tbmerge1&quot;, 			/* Name */
	&quot;first-order top-bottom merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmerge1_vec, 			/* Dispatch function */
	IM_NUMBER( merge1_args ), 		/* Size of arg list */
	merge1_args 			/* Arg list */
};

/* match_linear args
 */
static im_arg_desc match_linear_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xref1&quot; ),
	IM_INPUT_INT( &quot;yref1&quot; ),
	IM_INPUT_INT( &quot;xsec1&quot; ),
	IM_INPUT_INT( &quot;ysec1&quot; ),
	IM_INPUT_INT( &quot;xref2&quot; ),
	IM_INPUT_INT( &quot;yref2&quot; ),
	IM_INPUT_INT( &quot;xsec2&quot; ),
	IM_INPUT_INT( &quot;ysec2&quot; )
};

/* Call im_match_linear via arg vector.
 */
static int
match_linear_vec( im_object *argv )
{</B></FONT>
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);
<A NAME="4"></A>	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match354-1.html#4',3,'match354-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int yref2 = *((int *) argv[8]);
	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);

	return( im_match_linear( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2 ) );
}

/* Description of im_match_linear.
 */ 
static im_function match_linear_desc = {
	&quot;im_match_linear&quot;, 		/* Name */
	&quot;resample ref so that tie-points match&quot;,
	IM_FN_PIO,			/* Flags */
	match_linear_vec, 		/* Dispatch function */
	IM_NUMBER( match_linear_args ), 	/* Size of arg list */
	match_linear_args 		/* Arg list */
};

/* match_linear_search args
 */
static im_arg_desc match_linear_search_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xref1&quot; ),
	IM_INPUT_INT( &quot;yref1&quot; ),
	IM_INPUT_INT( &quot;xsec1&quot; ),
	IM_INPUT_INT( &quot;ysec1&quot; ),
	IM_INPUT_INT( &quot;xref2&quot; ),
	IM_INPUT_INT( &quot;yref2&quot; ),
	IM_INPUT_INT( &quot;xsec2&quot; ),
	IM_INPUT_INT( &quot;ysec2&quot; ),
	IM_INPUT_INT( &quot;hwindowsize&quot; ),
	IM_INPUT_INT( &quot;hsearchsize&quot; )
};

/* Call im_match_linear_search via arg vector.
 */
static int
match_linear_search_vec( im_object *argv )
{
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);</B></FONT>
	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
<A NAME="7"></A>	int yref2 = *((int *) argv[8]);
	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match354-1.html#7',3,'match354-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int hwin = *((int *) argv[11]);
	int hsrch = *((int *) argv[12]);

	return( im_match_linear_search( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2,
		hwin, hsrch ) );
}

/* Description of im_match_linear_search.
 */ 
static im_function match_linear_search_desc = {
	&quot;im_match_linear_search&quot;, 	/* Name */
	&quot;search sec, then resample so that tie-points match&quot;,
	IM_FN_PIO,			/* Flags */
	match_linear_search_vec, 	/* Dispatch function */
	IM_NUMBER( match_linear_search_args ),/* Size of arg list */
	match_linear_search_args 	/* Arg list */
};

/* correl args
 */
static im_arg_desc correl_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_INPUT_INT( &quot;xref&quot; ),
	IM_INPUT_INT( &quot;yref&quot; ),
	IM_INPUT_INT( &quot;xsec&quot; ),
	IM_INPUT_INT( &quot;ysec&quot; ),
	IM_INPUT_INT( &quot;hwindowsize&quot; ),
	IM_INPUT_INT( &quot;hsearchsize&quot; ),
	IM_OUTPUT_DOUBLE( &quot;correlation&quot; ),
	IM_OUTPUT_INT( &quot;x&quot; ),
	IM_OUTPUT_INT( &quot;y&quot; )
};

/* Call im_correl via arg vector.
 */
static int
correl_vec( im_object *argv )
{
	int xref = *((int *) argv[2]);</B></FONT>
	int yref = *((int *) argv[3]);
	int xsec = *((int *) argv[4]);
	int ysec = *((int *) argv[5]);
	int cor = *((int *) argv[6]);
	int area = *((int *) argv[7]);
	int *x = (int *) argv[8];
<A NAME="10"></A>	int *y = (int *) argv[9];
	double *correlation = (double *) argv[10];

<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match354-1.html#10',3,'match354-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( vips__correl( argv[0], argv[1], 
		xref, yref, xsec, ysec, cor, area, correlation, x, y ) );
}

/* Description of im_correl.
 */ 
static im_function correl_desc = {
	&quot;im_correl&quot;, 			/* Name */
	&quot;search area around sec for match for area around ref&quot;,
	IM_FN_PIO,			/* Flags */
	correl_vec, 			/* Dispatch function */
	IM_NUMBER( correl_args ), 		/* Size of arg list */
	correl_args 			/* Arg list */
};

/* global_balance args
 */
static im_arg_desc global_balance_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLE( &quot;gamma&quot; )
};

/* Call im_global_balance via arg vector.
 */
static int
global_balance_vec( im_object *argv )
{</B></FONT>
	double gamma = *((double *) argv[2]);

	return( im_global_balance( argv[0], argv[1], gamma ) );
}

/* Description of im_global_balance.
 */ 
static im_function global_balance_desc = {
	&quot;im_global_balance&quot;,		/* Name */
	&quot;automatically rebuild mosaic with balancing&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	global_balance_vec, 		/* Dispatch function */
	IM_NUMBER( global_balance_args ),	/* Size of arg list */
	global_balance_args 		/* Arg list */
};

/* Call im_global_balancef via arg vector.
 */
static int
global_balancef_vec( im_object *argv )
{
	double gamma = *((double *) argv[2]);

	return( im_global_balancef( argv[0], argv[1], gamma ) );
}

/* Description of im_global_balancef.
 */ 
static im_function global_balancef_desc = {
	&quot;im_global_balancef&quot;,		/* Name */
	&quot;automatically rebuild mosaic with balancing, float output&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
<A NAME="3"></A>	global_balancef_vec, 		/* Dispatch function */
	IM_NUMBER( global_balance_args ),	/* Size of arg list */
	global_balance_args 		/* Arg list */
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match354-1.html#3',3,'match354-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* remosaic args
 */
static im_arg_desc remosaic_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_STRING( &quot;old_str&quot; ),
	IM_INPUT_STRING( &quot;new_str&quot; )
};

/* Call im_remosaic via arg vector.
 */
static int
remosaic_vec( im_object *argv )
{
	return( im_remosaic( argv[0], argv[1], argv[2], argv[3] ) );
}

/* Description of im_remosaic.
 */ 
static im_function remosaic_desc = {
	&quot;im_remosaic&quot;,		/* Name */
	&quot;automatically rebuild mosaic with new files&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	remosaic_vec, 		/* Dispatch function */
	IM_NUMBER( remosaic_args ),/* Size of arg list */
	remosaic_args 		/* Arg list */
};

static int align_bands_vec( im_object *argv ){
  return im_align_bands( (IMAGE*)argv[0], (IMAGE*)argv[1] );
}

static im_arg_desc align_bands_arg_types[]= {
  IM_INPUT_IMAGE( &quot;in&quot; ),
  IM_OUTPUT_IMAGE( &quot;out&quot; )
};

static im_function align_bands_desc= {
  &quot;im_align_bands&quot;,
  &quot;align the bands of an image&quot;,
  0,
  align_bands_vec,
  IM_NUMBER( align_bands_arg_types ),
  align_bands_arg_types
};
<A NAME="9"></A>
static int maxpos_subpel_vec( im_object *argv ){</B></FONT>
  return im_maxpos_subpel( (IMAGE*)argv[0], (double*)argv[1], (double*)argv[2] );
<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match354-1.html#9',3,'match354-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static im_arg_desc maxpos_subpel_arg_types[]= {
  IM_INPUT_IMAGE( &quot;im&quot; ),
  IM_OUTPUT_DOUBLE( &quot;x&quot; ),
  IM_OUTPUT_DOUBLE( &quot;y&quot; )
};

static im_function maxpos_subpel_desc= {
  &quot;im_maxpos_subpel&quot;,
  &quot;subpixel position of maximum of (phase correlation) image&quot;,
  IM_FN_PIO,
  maxpos_subpel_vec,
  IM_NUMBER( maxpos_subpel_arg_types ),
  maxpos_subpel_arg_types
};

/* Package up all these functions.
 */
static im_function *mos_list[] = {
        &amp;align_bands_desc,
	&amp;correl_desc,
	&amp;find_lroverlap_desc,
	&amp;find_tboverlap_desc,
	&amp;global_balance_desc,
	&amp;global_balancef_desc,
	&amp;lrmerge_desc,
	&amp;lrmerge1_desc,
	&amp;lrmosaic_desc,
	&amp;lrmosaic1_desc,
	&amp;match_linear_desc,
	&amp;match_linear_search_desc,
        &amp;maxpos_subpel_desc,
	&amp;remosaic_desc,
	&amp;tbmerge_desc,
	&amp;tbmerge1_desc,
	&amp;tbmosaic_desc,
	&amp;tbmosaic1_desc
};</B></FONT>

/* Package of functions.
 */
im_package im__mosaicing = {
	&quot;mosaicing&quot;,
	IM_NUMBER( mos_list ),
	mos_list
};
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>conver_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* VIPS function dispatch tables for conversion.
 *
 * J. Cupitt, 8/4/93.
 */

/*

    This file is part of VIPS.

    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;

static int
system_vec( im_object *argv )
{
	IMAGE *in = argv[0];
	char *cmd = argv[1];
	char **out = (char **) &amp;argv[2];

<A NAME="10"></A>	if( im_system( in, cmd, out ) )
		return( -1 );

<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#10',2,'match354-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

static im_arg_desc system_args[] = {
	IM_INPUT_IMAGE( &quot;im&quot; ),
	IM_INPUT_STRING( &quot;command&quot; ),
	IM_OUTPUT_STRING( &quot;output&quot; )
};

static im_function system_desc = {
	&quot;im_system&quot;,			/* Name */
	&quot;run command on image&quot;,		/* Description */
	0,				/* Flags */
	system_vec, 			/* Dispatch function */
	IM_NUMBER( system_args ),	/* Size of arg list */
	system_args 			/* Arg list */
};

static int
system_image_vec( im_object *argv )
{</B></FONT>
	IMAGE *in = argv[0];
	IMAGE *out = argv[1];
	char *in_format = argv[2];
	char *out_format = argv[3];
	char *cmd = argv[4];
	char **log = (char **) &amp;argv[5];

	IMAGE *out_image;

	if( !(out_image = im_system_image( in, 
		in_format, out_format, cmd, log )) ) {
		im_error( &quot;im_system_image&quot;, &quot;%s&quot;, *log );
		return( -1 );
	}

	if( im_copy( out_image, out ) ||
		im_add_close_callback( out, 
			(im_callback_fn) im_close, out_image, NULL ) ) {
		im_close( out_image );
		return( -1 );
	}

	return( 0 );
}

static im_arg_desc system_image_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_STRING( &quot;in_format&quot; ),
	IM_INPUT_STRING( &quot;out_format&quot; ),
	IM_INPUT_STRING( &quot;command&quot; ),
	IM_OUTPUT_STRING( &quot;log&quot; )
};

static im_function system_image_desc = {
	&quot;im_system_image&quot;,		/* Name */
	&quot;run command on image, with image output&quot;,/* Description */
	0,				/* Flags */
	system_image_vec, 		/* Dispatch function */
	IM_NUMBER( system_image_args ),	/* Size of arg list */
	system_image_args 		/* Arg list */
};

static int
subsample_vec( im_object *argv )
{
	IMAGE *in = argv[0];
	IMAGE *out = argv[1];
	int xsh = *((int *) argv[2]);
	int ysh = *((int *) argv[3]);

	if( im_subsample( in, out, xsh, ysh ) )
<A NAME="9"></A>		return( -1 );

	return( 0 );
<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#9',2,'match354-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

static im_arg_desc subsample_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xshrink&quot; ),
	IM_INPUT_INT( &quot;yshrink&quot; )
};

static im_function subsample_desc = {
	&quot;im_subsample&quot;,			/* Name */
	&quot;subsample image by integer factors&quot;,	/* Description */
	IM_FN_PIO,			/* Flags */
	subsample_vec,			/* Dispatch function */
	IM_NUMBER( subsample_args ), 	/* Size of arg list */
	subsample_args 			/* Arg list */
};

/* Args for im_gaussnoise.
 */
static im_arg_desc gaussnoise_args[] = {
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xsize&quot; ),
	IM_INPUT_INT( &quot;ysize&quot; ),
	IM_INPUT_DOUBLE( &quot;mean&quot; ),
	IM_INPUT_DOUBLE( &quot;sigma&quot; )
};</B></FONT>

/* Call im_gaussnoise via arg vector.
 */
<A NAME="11"></A>static int
gaussnoise_vec( im_object *argv )
{
<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#11',2,'match354-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int xsize = *((int *) argv[1]);
	int ysize = *((int *) argv[2]);
	double mean = *((double *) argv[3]);
	double sigma = *((double *) argv[4]);</B></FONT>

	if( im_gaussnoise( argv[0], xsize, ysize, mean, sigma ) )
		return( -1 );
	
	return( 0 );
}

/* Description of im_gaussnoise.
 */ 
static im_function gaussnoise_desc = {
	&quot;im_gaussnoise&quot;, 		/* Name */
	&quot;generate image of gaussian noise with specified statistics&quot;,
	IM_FN_PIO | IM_FN_NOCACHE,	/* Flags */
	gaussnoise_vec, 		/* Dispatch function */
	IM_NUMBER( gaussnoise_args ), 	/* Size of arg list */
	gaussnoise_args 		/* Arg list */
};

/* Args to im_extract.
 */
static im_arg_desc extract_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;left&quot; ),
	IM_INPUT_INT( &quot;top&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;height&quot; ),
	IM_INPUT_INT( &quot;band&quot; )
};

/* Call im_extract via arg vector.
 */
<A NAME="0"></A>static int
extract_vec( im_object *argv )
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#0',2,'match354-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int left = *((int *) argv[2]);
	int top = *((int *) argv[3]);
	int width = *((int *) argv[4]);
	int height = *((int *) argv[5]);
	int band = *((int *) argv[6]);

	return( im_extract_areabands( argv[0], argv[1], 
		left, top, width, height, band, 1 ) );
}

/* Description of im_extract.
 */
static im_function extract_desc = {
	&quot;im_extract&quot;, 			/* Name */
	&quot;extract area/band&quot;,		/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	extract_vec, 			/* Dispatch function */
	IM_NUMBER( extract_args ), 	/* Size of arg list */
	extract_args 			/* Arg list */
};

/* Args to im_extract_area.
 */
static im_arg_desc extract_area_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;left&quot; ),
	IM_INPUT_INT( &quot;top&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;height&quot; )
};

/* Call im_extract_area via arg vector.
 */
static int
extract_area_vec( im_object *argv )
{
	int x = *((int *) argv[2]);
	int y = *((int *) argv[3]);
	int w = *((int *) argv[4]);
	int h = *((int *) argv[5]);</B></FONT>

	return( im_extract_area( argv[0], argv[1], x, y, w, h ) );
}

/* Description of im_extract_area.
 */
static im_function extract_area_desc = {
	&quot;im_extract_area&quot;, 		/* Name */
	&quot;extract area&quot;,			/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	extract_area_vec, 		/* Dispatch function */
	IM_NUMBER( extract_area_args ), /* Size of arg list */
	extract_area_args 		/* Arg list */
};

/* Args to im_extract_bands.
 */
static im_arg_desc extract_bands_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;band&quot; ),
	IM_INPUT_INT( &quot;nbands&quot; ),
};

/* Call im_extract_bands via arg vector.
 */
<A NAME="7"></A>static int
extract_bands_vec( im_object *argv )
{
<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#7',2,'match354-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int chsel = *((int *) argv[2]);
	int nbands = *((int *) argv[3]);

	return( im_extract_bands( argv[0], argv[1], chsel, nbands ) );
}

/* Description of im_extract_bands.
 */
static im_function extract_bands_desc = {
	&quot;im_extract_bands&quot;, 		/* Name */
	&quot;extract several bands&quot;,	/* Description */
	IM_FN_PIO,			/* Flags */
	extract_bands_vec, 		/* Dispatch function */
	IM_NUMBER( extract_bands_args ),/* Size of arg list */
	extract_bands_args 		/* Arg list */
};

/* Args to im_extract_band.
 */
static im_arg_desc extract_band_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;band&quot; )
};

/* Call im_extract_band via arg vector.
 */
static int
extract_band_vec( im_object *argv )
{
	int chsel = *((int *) argv[2]);</B></FONT>

	return( im_extract_band( argv[0], argv[1], chsel ) );
}

/* Description of im_extract_band.
 */
static im_function extract_band_desc = {
	&quot;im_extract_band&quot;, 		/* Name */
	&quot;extract band&quot;,			/* Description */
	IM_FN_PIO,			/* Flags */
	extract_band_vec, 		/* Dispatch function */
	IM_NUMBER( extract_band_args ), /* Size of arg list */
	extract_band_args 		/* Arg list */
};

/* Args to im_extract_areabands.
 */
static im_arg_desc extract_areabands_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;left&quot; ),
	IM_INPUT_INT( &quot;top&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;height&quot; ),
	IM_INPUT_INT( &quot;band&quot; ),
	IM_INPUT_INT( &quot;nbands&quot; )
};

/* Call im_extract_areabands via arg vector.
 */
<A NAME="1"></A>static int
extract_areabands_vec( im_object *argv )
{
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#1',2,'match354-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int left = *((int *) argv[2]);
	int top = *((int *) argv[3]);
	int width = *((int *) argv[4]);
	int height = *((int *) argv[5]);
	int band = *((int *) argv[6]);
	int nbands = *((int *) argv[7]);

	return( im_extract_areabands( argv[0], argv[1],
		left, top, width, height, band, nbands ) );
}

/* Description of im_extract_areabands.
 */
static im_function extract_areabands_desc = {
	&quot;im_extract_areabands&quot;,         /* Name */
	&quot;extract area and bands&quot;,       /* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	extract_areabands_vec,          /* Dispatch function */
	IM_NUMBER( extract_areabands_args ),/* Size of arg list */
	extract_areabands_args          /* Arg list */
};

/* One image in, one out.
 */
static im_arg_desc one_in_one_out[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Two images in, one out.
 */
static im_arg_desc two_in_one_out[] = {
	IM_INPUT_IMAGE( &quot;in1&quot; ),
	IM_INPUT_IMAGE( &quot;in2&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_bandjoin via arg vector.
 */
static int
bandjoin_vec( im_object *argv )
{</B></FONT>
	return( im_bandjoin( argv[0], argv[1], argv[2] ) );
}

/* Description of im_bandjoin.
 */
static im_function bandjoin_desc = {
	&quot;im_bandjoin&quot;, 			/* Name */
	&quot;bandwise join of two images&quot;,	/* Description */
	IM_FN_PIO,			/* Flags */
	bandjoin_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

static im_arg_desc gbandjoin_args[] = {
	IM_INPUT_IMAGEVEC( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

static int
gbandjoin_vec( im_object *argv )
{
	im_imagevec_object *iv = (im_imagevec_object *) argv[0];

	return( im_gbandjoin( iv-&gt;vec, argv[1], iv-&gt;n ) );
}

static im_function gbandjoin_desc = {
	&quot;im_gbandjoin&quot;, 		/* Name */
	&quot;bandwise join of many images&quot;,	/* Description */
	IM_FN_PIO,			/* Flags */
	gbandjoin_vec, 			/* Dispatch function */
	IM_NUMBER( gbandjoin_args ), 	/* Size of arg list */
	gbandjoin_args 			/* Arg list */
};

/* Args to im_text.
 */
static im_arg_desc text_args[] = {
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_STRING( &quot;text&quot; ),
	IM_INPUT_STRING( &quot;font&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;alignment&quot; ),
	IM_INPUT_INT( &quot;dpi&quot; )
};

/* Call im_text via arg vector.
 */
<A NAME="2"></A>static int
text_vec( im_object *argv )
{
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#2',2,'match354-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int width = *((int *) argv[3]);
	int alignment = *((int *) argv[4]);
	int dpi = *((int *) argv[5]);

	return( im_text( argv[0], argv[1], argv[2], width, alignment, dpi ) );
}

/* Description of im_text.
 */
static im_function text_desc = {
	&quot;im_text&quot;, 			/* Name */
	&quot;generate text image&quot;,		/* Description */
	IM_FN_PIO,			/* Flags */
	text_vec, 			/* Dispatch function */
	IM_NUMBER( text_args ), 	/* Size of arg list */
	text_args 			/* Arg list */
};

/* Args to im_black.
 */
static im_arg_desc black_args[] = {
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;x_size&quot; ),
	IM_INPUT_INT( &quot;y_size&quot; ),
	IM_INPUT_INT( &quot;bands&quot; )
};

/* Call im_black via arg vector.
 */
static int
black_vec( im_object *argv )
{
	int xs = *((int *) argv[1]);
	int ys = *((int *) argv[2]);
	int bands = *((int *) argv[3]);

	return( im_black( argv[0], xs, ys, bands ) );
}

/* Description of im_black.
 */
static im_function black_desc = {</B></FONT>
	&quot;im_black&quot;, 			/* Name */
	&quot;generate black image&quot;,		/* Description */
	IM_FN_PIO,			/* Flags */
	black_vec, 			/* Dispatch function */
	IM_NUMBER( black_args ), 	/* Size of arg list */
	black_args 			/* Arg list */
};

/* Args to im_clip2fmt.
 */
static im_arg_desc clip2fmt_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;ofmt&quot; )
};

/* Call im_clip2fmt via arg vector.
 */
static int
clip2fmt_vec( im_object *argv )
{
	int ofmt = *((int *) argv[2]);

	return( im_clip2fmt( argv[0], argv[1], ofmt ) );
}

/* Description of im_clip2fmt.
 */
static im_function clip2fmt_desc = {
	&quot;im_clip2fmt&quot;, 			/* Name */
	&quot;convert image format to ofmt&quot;,	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	clip2fmt_vec, 			/* Dispatch function */
	IM_NUMBER( clip2fmt_args ),	/* Size of arg list */
	clip2fmt_args 			/* Arg list */
};

/* Call im_c2rect via arg vector.
 */
static int
c2rect_vec( im_object *argv )
{
	return( im_c2rect( argv[0], argv[1] ) );
}

/* Description of im_c2rect.
 */
static im_function c2rect_desc = {
	&quot;im_c2rect&quot;, 			/* Name */
	&quot;convert phase and amplitude to real and imaginary&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	c2rect_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_c2amph via arg vector.
 */
static int
c2amph_vec( im_object *argv )
{
	return( im_c2amph( argv[0], argv[1] ) );
}

/* Description of im_c2amph.
 */
static im_function c2amph_desc = {
	&quot;im_c2amph&quot;, 			/* Name */
	&quot;convert real and imaginary to phase and amplitude&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	c2amph_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_ri2c via arg vector.
 */
static int
<A NAME="3"></A>ri2c_vec( im_object *argv )
{
	return( im_ri2c( argv[0], argv[1], argv[2] ) );
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#3',2,'match354-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_ri2c.
 */
static im_function ri2c_desc = {
	&quot;im_ri2c&quot;, 			/* Name */
	&quot;join two non-complex images to form complex&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	ri2c_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_c2imag via arg vector.
 */
static int
c2imag_vec( im_object *argv )
{
	return( im_c2imag( argv[0], argv[1] ) );
}

/* Description of im_c2imag.
 */
static im_function c2imag_desc = {
	&quot;im_c2imag&quot;, 			/* Name */
	&quot;extract imaginary part of complex image&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	c2imag_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_c2real via arg vector.
 */
static int
c2real_vec( im_object *argv )
{
	return( im_c2real( argv[0], argv[1] ) );
}

/* Description of im_c2real.
 */
static im_function c2real_desc = {
	&quot;im_c2real&quot;, 			/* Name */
	&quot;extract real part of complex image&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	c2real_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Args to im_copy_set.
 */
static im_arg_desc copy_set_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;Type&quot; ),
	IM_INPUT_DOUBLE( &quot;Xres&quot; ),
	IM_INPUT_DOUBLE( &quot;Yres&quot; ),
	IM_INPUT_INT( &quot;Xoffset&quot; ),
	IM_INPUT_INT( &quot;Yoffset&quot; )
};

/* Call im_copy_set via arg vector.
 */
static int
copy_set_vec( im_object *argv )
{</B></FONT>
	int Type = *((int *) argv[2]);
	float Xres = *((double *) argv[3]);
	float Yres = *((double *) argv[4]);
	int Xoffset = *((int *) argv[5]);
	int Yoffset = *((int *) argv[6]);

	return( im_copy_set( argv[0], argv[1],
		Type, Xres, Yres, Xoffset, Yoffset ) );
}

/* Description of im_copy_set.
 */
static im_function copy_set_desc = {
	&quot;im_copy_set&quot;, 			/* Name */
	&quot;copy image, setting informational fields&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 */
	IM_FN_PIO,			/* Flags */

	copy_set_vec, 			/* Dispatch function */
	IM_NUMBER( copy_set_args ), 	/* Size of arg list */
	copy_set_args 			/* Arg list */
};

/* Args to im_copy_set_meta.
 */
static im_arg_desc copy_set_meta_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_STRING( &quot;field&quot; ),
	IM_INPUT_GVALUE( &quot;value&quot; )
};

/* Call im_copy_set_meta via arg vector.
 */
static int
copy_set_meta_vec( im_object *argv )
{
	const char *field = argv[2];
<A NAME="6"></A>	GValue *value = argv[3];

	return( im_copy_set_meta( argv[0], argv[1], field, value ) ); 
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#6',2,'match354-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_copy_set_meta.
 */
static im_function copy_set_meta_desc = {
	&quot;im_copy_set_meta&quot;, 		/* Name */
	&quot;copy image, setting a meta field&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 */
	IM_FN_PIO,			/* Flags */

	copy_set_meta_vec, 		/* Dispatch function */
	IM_NUMBER( copy_set_meta_args ),/* Size of arg list */
	copy_set_meta_args 		/* Arg list */
};

/* Args to im_copy_morph.
 */
static im_arg_desc copy_morph_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;Bands&quot; ),
	IM_INPUT_INT( &quot;BandFmt&quot; ),
	IM_INPUT_INT( &quot;Coding&quot; )
};

/* Call im_copy_morph via arg vector.
 */
static int
copy_morph_vec( im_object *argv )
{
	int Bands = *((int *) argv[2]);
	int BandFmt = *((int *) argv[3]);
	int Coding = *((int *) argv[4]);

	return( im_copy_morph( argv[0], argv[1],
		Bands, BandFmt, Coding ) );
}

/* Description of im_copy_morph.
 */
static im_function copy_morph_desc = {</B></FONT>
	&quot;im_copy_morph&quot;, 			/* Name */
	&quot;copy image, setting pixel layout&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 */
	IM_FN_PIO,			/* Flags */

	copy_morph_vec, 		/* Dispatch function */
	IM_NUMBER( copy_morph_args ), 	/* Size of arg list */
	copy_morph_args 		/* Arg list */
};

/* Call im_copy via arg vector.
 */
static int
copy_vec( im_object *argv )
{
	return( im_copy( argv[0], argv[1] ) );
}

/* Description of im_copy.
 */
static im_function copy_desc = {
	&quot;im_copy&quot;, 			/* Name */
	&quot;copy image&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 *
	 * Don't cache, since we use copy to stop sharing.
	 */
	IM_FN_PIO | IM_FN_NOCACHE,

	copy_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_copy_file via arg vector.
 */
static int
copy_file_vec( im_object *argv )
{
	return( im_copy_file( argv[0], argv[1] ) );
}

/* Description of im_copy_file.
 */
static im_function copy_file_desc = {
	&quot;im_copy_file&quot;, 			/* Name */
	&quot;copy image to a file and return that&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 */
	IM_FN_PIO,			/* Flags */

	copy_file_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_copy_swap via arg vector.
 */
static int
copy_swap_vec( im_object *argv )
{
	return( im_copy_swap( argv[0], argv[1] ) );
}

/* Description of im_copy_swap.
 */
static im_function copy_swap_desc = {
	&quot;im_copy_swap&quot;, 			/* Name */
	&quot;copy image, swapping byte order&quot;,

	/* Can't set PTOP ... we don't want to zap the LUT, we want the real
	 * image.
	 */
	IM_FN_PIO,			/* Flags */

	copy_swap_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_fliphor via arg vector.
 */
static int
fliphor_vec( im_object *argv )
{
	return( im_fliphor( argv[0], argv[1] ) );
}

/* Description of im_fliphor.
 */
static im_function fliphor_desc = {
	&quot;im_fliphor&quot;, 			/* Name */
	&quot;flip image left-right&quot;,
	IM_FN_PIO,			/* Flags */
	fliphor_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_flipver via arg vector.
 */
static int
flipver_vec( im_object *argv )
{
	return( im_flipver( argv[0], argv[1] ) );
}

/* Description of im_flipver.
 */
static im_function flipver_desc = {
	&quot;im_flipver&quot;, 			/* Name */
	&quot;flip image top-bottom&quot;,
	IM_FN_PIO,			/* Flags */
	flipver_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_falsecolour via arg vector.
 */
<A NAME="8"></A>static int
falsecolour_vec( im_object *argv )
{
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#8',2,'match354-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( im_falsecolour( argv[0], argv[1] ) );
}

/* Description of im_falsecolour.
 */
static im_function falsecolour_desc = {
	&quot;im_falsecolour&quot;, 		/* Name */
	&quot;turn luminance changes into chrominance changes&quot;,
	IM_FN_PTOP | IM_FN_PIO,		/* Flags */
	falsecolour_vec, 		/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Args for im_insert.
 */
static im_arg_desc insert_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_IMAGE( &quot;sub&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;x&quot; ),
	IM_INPUT_INT( &quot;y&quot; )
};

/* Call im_insert via arg vector.
 */
static int
insert_vec( im_object *argv )
{
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);</B></FONT>

	return( im_insert( argv[0], argv[1], argv[2], x, y ) );
}

/* Description of im_insert.
 */
static im_function insert_desc = {
	&quot;im_insert&quot;, 			/* Name */
	&quot;insert sub-image into main image at position&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	insert_vec, 			/* Dispatch function */
	IM_NUMBER( insert_args ), 	/* Size of arg list */
	insert_args 			/* Arg list */
};

/* Args for im_insertset.
 */
static im_arg_desc insertset_args[] = {
	IM_INPUT_IMAGE( &quot;main&quot; ),
	IM_INPUT_IMAGE( &quot;sub&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INTVEC( &quot;x&quot; ),
	IM_INPUT_INTVEC( &quot;y&quot; )
};

/* Call im_insertplaceset via arg vector.
 */
static int
insertset_vec( im_object *argv )
{
	im_intvec_object *xv = (im_intvec_object *) argv[3];
	im_intvec_object *yv = (im_intvec_object *) argv[4];

	if( xv-&gt;n != yv-&gt;n ) {
		im_error( &quot;im_insertset&quot;, &quot;%s&quot;, 
			_( &quot;vectors not same length&quot; ) );
		return( -1 );
	}

	if( im_insertset( argv[0], argv[1], argv[2], xv-&gt;n, xv-&gt;vec, yv-&gt;vec ) )
		return( -1 );

	return( 0 );
}

/* Description of im_insertset.
 */ 
static im_function insertset_desc = {
	&quot;im_insertset&quot;, 		/* Name */
	&quot;insert sub into main at every position in x, y&quot;,
	0,				/* Flags */
	insertset_vec, 			/* Dispatch function */
	IM_NUMBER( insertset_args ), 	/* Size of arg list */
	insertset_args 			/* Arg list */
};

/* Call im_insert_noexpand via arg vector.
 */
static int
insert_noexpand_vec( im_object *argv )
{
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);

	return( im_insert_noexpand( argv[0], argv[1], argv[2], x, y ) );
}

/* Description of im_insert_noexpand.
 */
static im_function insert_noexpand_desc = {
	&quot;im_insert_noexpand&quot;, 		/* Name */
	&quot;insert sub-image into main image at position, no expansion&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	insert_noexpand_vec, 		/* Dispatch function */
	IM_NUMBER( insert_args ),	/* Size of arg list */
	insert_args 			/* Arg list */
};

/* Call im_rot180 via arg vector.
 */
static int
rot180_vec( im_object *argv )
{
	return( im_rot180( argv[0], argv[1] ) );
}

/* Description of im_rot180.
 */
static im_function rot180_desc = {
	&quot;im_rot180&quot;, 			/* Name */
	&quot;rotate image 180 degrees&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	rot180_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_rot90 via arg vector.
 */
static int
rot90_vec( im_object *argv )
{
	return( im_rot90( argv[0], argv[1] ) );
}

/* Description of im_rot90.
 */
static im_function rot90_desc = {
	&quot;im_rot90&quot;, 			/* Name */
	&quot;rotate image 90 degrees clockwise&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	rot90_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_rot270 via arg vector.
 */
static int
rot270_vec( im_object *argv )
{
	return( im_rot270( argv[0], argv[1] ) );
}

/* Description of im_rot270.
 */
static im_function rot270_desc = {
	&quot;im_rot270&quot;, 			/* Name */
	&quot;rotate image 270 degrees clockwise&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	rot270_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_lrjoin via arg vector.
 */
static int
lrjoin_vec( im_object *argv )
{
	return( im_lrjoin( argv[0], argv[1], argv[2] ) );
}

/* Description of im_lrjoin.
 */
static im_function lrjoin_desc = {
	&quot;im_lrjoin&quot;, 			/* Name */
	&quot;join two images left-right&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	lrjoin_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_tbjoin via arg vector.
 */
static int
tbjoin_vec( im_object *argv )
{
	return( im_tbjoin( argv[0], argv[1], argv[2] ) );
}

/* Description of im_tbjoin.
 */
static im_function tbjoin_desc = {
	&quot;im_tbjoin&quot;, 			/* Name */
	&quot;join two images top-bottom&quot;,
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	tbjoin_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_scale via arg vector.
 */
static int
scale_vec( im_object *argv )
{
	return( im_scale( argv[0], argv[1] ) );
}

/* Description of im_scale.
 */
static im_function scale_desc = {
	&quot;im_scale&quot;, 			/* Name */
	&quot;scale image linearly to fit range 0-255&quot;,
	IM_FN_PIO,			/* Flags */
	scale_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_scaleps via arg vector.
 */
static int
scaleps_vec( im_object *argv )
{
	return( im_scaleps( argv[0], argv[1] ) );
}

/* Description of im_scaleps.
 */
static im_function scaleps_desc = {
	&quot;im_scaleps&quot;, 			/* Name */
	&quot;logarithmic scale of image to fit range 0-255&quot;,
	0,				/* Flags */
	scaleps_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Args to im_grid.
 */
static im_arg_desc grid_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;tile_height&quot; ),
	IM_INPUT_INT( &quot;across&quot; ),
	IM_INPUT_INT( &quot;down&quot; )
};

/* Call im_grid via arg vector.
 */
<A NAME="4"></A>static int
grid_vec( im_object *argv )
{
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#4',2,'match354-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int tile_height = *((int *) argv[2]);
	int across = *((int *) argv[3]);
	int down = *((int *) argv[4]);

	return( im_grid( argv[0], argv[1], tile_height, across, down ) );
}

/* Description of im_grid.
 */
static im_function grid_desc = {
	&quot;im_grid&quot;, 			/* Name */
	&quot;chop a tall thin image into a grid of images&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	grid_vec, 			/* Dispatch function */
	IM_NUMBER( grid_args ), 	/* Size of arg list */
	grid_args 			/* Arg list */
};

/* Args to im_replicate.
 */
static im_arg_desc replicate_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;across&quot; ),
	IM_INPUT_INT( &quot;down&quot; )
};

/* Call im_replicate via arg vector.
 */
static int
replicate_vec( im_object *argv )
{
	int across = *((int *) argv[2]);
	int down = *((int *) argv[3]);</B></FONT>

	return( im_replicate( argv[0], argv[1], across, down ) );
}

/* Description of im_replicate.
 */
static im_function replicate_desc = {
	&quot;im_replicate&quot;, 		/* Name */
	&quot;replicate an image horizontally and vertically&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	replicate_vec, 			/* Dispatch function */
	IM_NUMBER( replicate_args ), 	/* Size of arg list */
	replicate_args 			/* Arg list */
};

/* Args to im_zoom.
 */
static im_arg_desc zoom_args[] = {
	IM_INPUT_IMAGE( &quot;input&quot; ),
	IM_OUTPUT_IMAGE( &quot;output&quot; ),
	IM_INPUT_INT( &quot;xfac&quot; ),
	IM_INPUT_INT( &quot;yfac&quot; )
};

/* Call im_zoom via arg vector.
 */
static int
zoom_vec( im_object *argv )
{
	int xfac = *((int *) argv[2]);
	int yfac = *((int *) argv[3]);

	return( im_zoom( argv[0], argv[1], xfac, yfac ) );
}

/* Description of im_zoom.
 */
static im_function zoom_desc = {
	&quot;im_zoom&quot;, 			/* Name */
	&quot;simple zoom of an image by integer factors&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	zoom_vec, 			/* Dispatch function */
	IM_NUMBER( zoom_args ),		/* Size of arg list */
	zoom_args 			/* Arg list */
};

/* Call im_msb via arg vector.
 */
static int
msb_vec (im_object * argv)
{
  return im_msb (argv[0], argv[1]);
}

/* Description of im_msb.
 */
static im_function msb_desc = {
  &quot;im_msb&quot;,			/* Name */
  &quot;convert to uchar by discarding bits&quot;,
  IM_FN_PIO | IM_FN_PTOP,	/* Flags */
  msb_vec,			/* Dispatch function */
  IM_NUMBER (one_in_one_out),	/* Size of arg list */
  one_in_one_out		/* Arg list */
};

/* Args to im_msb_band.
 */
static im_arg_desc msb_band_args[] = {
  IM_INPUT_IMAGE (&quot;in&quot;),
  IM_OUTPUT_IMAGE (&quot;out&quot;),
  IM_INPUT_INT (&quot;band&quot;)
};

/* Call im_msb_band via arg vector.
 */
static int
msb_band_vec (im_object * argv)
{
  IMAGE *in = (IMAGE *) argv[0];
  IMAGE *out = (IMAGE *) argv[1];
  int *band = (int *) argv[2];

  return im_msb_band (in, out, *band);
}

/* Description of im_msb_band.
 */
static im_function msb_band_desc = {
  &quot;im_msb_band&quot;,		/* Name */
  &quot;convert to single band uchar by discarding bits&quot;,
  IM_FN_PIO | IM_FN_PTOP,	/* Flags */
  msb_band_vec,			/* Dispatch function */
  IM_NUMBER (msb_band_args),	/* Size of arg list */
  msb_band_args			/* Arg list */
};

/* Args to im_wrap.
 */
static im_arg_desc wrap_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;x&quot; ),
	IM_INPUT_INT( &quot;y&quot; )
};

/* Call im_wrap via arg vector.
 */
static int
<A NAME="5"></A>wrap_vec (im_object * argv)
{
  return im_wrap( argv[0], argv[1], *(int*)argv[2], *(int*)argv[3] );
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match354-0.html#5',2,'match354-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_wrap.
 */
static im_function wrap_desc = {
  &quot;im_wrap&quot;,			/* Name */
  &quot;shift image origin, wrapping at sides&quot;,
  IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
  wrap_vec,			/* Dispatch function */
  IM_NUMBER (wrap_args),	/* Size of arg list */
  wrap_args			/* Arg list */
};

/* Args for im_embed.
 */
static im_arg_desc embed_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;type&quot; ),
	IM_INPUT_INT( &quot;x&quot; ),
	IM_INPUT_INT( &quot;y&quot; ),
	IM_INPUT_INT( &quot;width&quot; ),
	IM_INPUT_INT( &quot;height&quot; )
};

/* Call im_embed via arg vector.
 */
static int
embed_vec( im_object *argv )
{
	int type = *((int *) argv[2]);
	int x = *((int *) argv[3]);
	int y = *((int *) argv[4]);
	int width = *((int *) argv[5]);
	int height = *((int *) argv[6]);</B></FONT>

	return( im_embed( argv[0], argv[1], type, x, y, width, height ) );
}

/* Description of im_embed.
 */ 
static im_function embed_desc = {
	&quot;im_embed&quot;,	 		/* Name */
	&quot;embed in within a set of borders&quot;, 
	IM_FN_PIO | IM_FN_TRANSFORM,	/* Flags */
	embed_vec, 			/* Dispatch function */
	IM_NUMBER( embed_args ), 	/* Size of arg list */
	embed_args 			/* Arg list */
};

/* Package up all these functions.
 */
static im_function *conv_list[] = {
	&amp;gaussnoise_desc,
	&amp;bandjoin_desc,
	&amp;black_desc,
	&amp;c2amph_desc,
	&amp;c2imag_desc,
	&amp;c2real_desc,
	&amp;c2rect_desc,
	&amp;clip2fmt_desc,
	&amp;copy_desc,
	&amp;copy_file_desc,
	&amp;copy_morph_desc,
	&amp;copy_swap_desc,
	&amp;copy_set_desc,
	&amp;copy_set_meta_desc,
	&amp;extract_area_desc,
	&amp;extract_areabands_desc,
	&amp;extract_band_desc,
	&amp;extract_bands_desc,
	&amp;extract_desc,
	&amp;falsecolour_desc,
	&amp;fliphor_desc,
	&amp;flipver_desc,
	&amp;gbandjoin_desc,
	&amp;grid_desc,
	&amp;insert_desc,
	&amp;insertset_desc,
	&amp;insert_noexpand_desc,
	&amp;embed_desc,
	&amp;lrjoin_desc,
        &amp;msb_desc,
        &amp;msb_band_desc,
	&amp;replicate_desc,
	&amp;ri2c_desc,
	&amp;rot180_desc,
	&amp;rot270_desc,
	&amp;rot90_desc,
	&amp;scale_desc,
	&amp;scaleps_desc,
	&amp;subsample_desc,
	&amp;system_desc,
	&amp;system_image_desc,
	&amp;tbjoin_desc,
	&amp;text_desc,
	&amp;wrap_desc,
	&amp;zoom_desc
};

/* Package of functions.
 */
im_package im__conversion = {
	&quot;conversion&quot;,
	IM_NUMBER( conv_list ),
	conv_list
};
</PRE>
</div>
  </div>
</body>
</html>
