
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-haiku.c</h3>
            <pre><code>1  #include &quot;config.h&quot;
2  #include &quot;pcap-int.h&quot;
3  #include &lt;OS.h&gt;
4  #include &lt;sys/socket.h&gt;
5  #include &lt;sys/sockio.h&gt;
6  #include &lt;net/if.h&gt;
7  #include &lt;net/if_dl.h&gt;
8  #include &lt;net/if_types.h&gt;
9  #include &lt;errno.h&gt;
10  #include &lt;stdio.h&gt;
11  #include &lt;stdlib.h&gt;
12  #include &lt;string.h&gt;
13  struct pcap_haiku {
14  	struct pcap_stat	stat;
15  	char	*device;	&amp;bsol;* device name */
16  };
17  static int
18  prepare_request(struct ifreq *request, const char* name)
19  {
20  	if (strlen(name) &gt;= IF_NAMESIZE)
21  		return 0;
22  	strcpy(request-&gt;ifr_name, name);
23  	return 1;
24  }
25  static int
26  pcap_read_haiku(pcap_t* handle, int maxPackets _U_, pcap_handler callback,
27  	u_char* userdata)
28  {
29  	u_char* buffer = handle-&gt;buffer + handle-&gt;offset;
30  	struct sockaddr_dl from;
31  	ssize_t bytesReceived;
32  	do {
33  		if (handle-&gt;break_loop) {
34  			handle-&gt;break_loop = 0;
35  			return -2;
36  		}
37  		socklen_t fromLength = sizeof(from);
38  		bytesReceived = recvfrom(handle-&gt;fd, buffer, handle-&gt;bufsize, MSG_TRUNC,
39  			(struct sockaddr*)&amp;from, &amp;fromLength);
40  	} while (bytesReceived &lt; 0 &amp;&amp; errno == B_INTERRUPTED);
41  	if (bytesReceived &lt; 0) {
42  		if (errno == B_WOULD_BLOCK) {
43  			return 0;
44  		}
45  		snprintf(handle-&gt;errbuf, sizeof(handle-&gt;errbuf),
46  			&quot;recvfrom: %s&quot;, strerror(errno));
47  		return -1;
48  	}
49  	int32_t captureLength = bytesReceived;
50  	if (captureLength &gt; handle-&gt;snapshot)
51  		captureLength = handle-&gt;snapshot;
52  	if (handle-&gt;fcode.bf_insns) {
53  		if (pcap_filter(handle-&gt;fcode.bf_insns, buffer, bytesReceived,
54  				captureLength) == 0) {
55  			return 0;
56  		}
57  	}
58  	struct pcap_pkthdr header;
59  	header.caplen = captureLength;
60  	header.len = bytesReceived;
61  	header.ts.tv_usec = system_time() % 1000000;
62  	header.ts.tv_sec = system_time() / 1000000;
63  	callback(userdata, &amp;header, buffer);
64  	return 1;
65  }
66  static int
67  pcap_inject_haiku(pcap_t *handle, const void *buffer _U_, int size _U_)
68  {
69  	strlcpy(handle-&gt;errbuf, &quot;Sending packets isn&#x27;t supported yet&quot;,
70  		PCAP_ERRBUF_SIZE);
71  	return -1;
72  }
73  static int
74  pcap_stats_haiku(pcap_t *handle, struct pcap_stat *stats)
75  {
76  	struct pcap_haiku* handlep = (struct pcap_haiku*)handle-&gt;priv;
77  	struct ifreq request;
78  	int pcapSocket = socket(AF_INET, SOCK_DGRAM, 0);
79  	if (pcapSocket &lt; 0) {
80  		return -1;
81  	}
82  	prepare_request(&amp;request, handlep-&gt;device);
83  	if (ioctl(pcapSocket, SIOCGIFSTATS, &amp;request, sizeof(struct ifreq)) &lt; 0) {
84  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;pcap_stats: %s&quot;,
85  			strerror(errno));
86  		close(pcapSocket);
87  		return -1;
88  	}
89  	close(pcapSocket);
90  	handlep-&gt;stat.ps_recv += request.ifr_stats.receive.packets;
91  	handlep-&gt;stat.ps_drop += request.ifr_stats.receive.dropped;
92  	*stats = handlep-&gt;stat;
93  	return 0;
94  }
95  static int
96  pcap_activate_haiku(pcap_t *handle)
97  {
98  	struct pcap_haiku* handlep = (struct pcap_haiku*)handle-&gt;priv;
99  	const char* device = handle-&gt;opt.device;
100  	handle-&gt;read_op = pcap_read_haiku;
101  	handle-&gt;setfilter_op = pcap_install_bpf_program; &amp;bsol;* no kernel filtering */
102  	handle-&gt;inject_op = pcap_inject_haiku;
103  	handle-&gt;stats_op = pcap_stats_haiku;
104  	handle-&gt;getnonblock_op = pcap_getnonblock_fd;
105  	handle-&gt;setnonblock_op = pcap_setnonblock_fd;
106  	if (handle-&gt;snapshot &lt;= 0 || handle-&gt;snapshot &gt; MAXIMUM_SNAPLEN)
107  		handle-&gt;snapshot = MAXIMUM_SNAPLEN;
108  	handlep-&gt;device	= strdup(device);
109  	if (handlep-&gt;device == NULL) {
<span onclick='openModal()' class='match'>110  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
111  			errno, &quot;strdup&quot;);
112  		return PCAP_ERROR;
113  	}
114  	handle-&gt;bufsize = 65536;
</span>115  	handle-&gt;buffer = (u_char*)malloc(handle-&gt;bufsize);
116  	if (handle-&gt;buffer == NULL) {
117  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
118  			errno, &quot;buffer malloc&quot;);
119  		return PCAP_ERROR;
120  	}
121  	handle-&gt;offset = 0;
122  	handle-&gt;linktype = DLT_EN10MB;
123  	return 0;
124  }
125  pcap_t *
126  pcap_create_interface(const char *device, char *errorBuffer)
127  {
128  	int pcapSocket = socket(AF_INET, SOCK_DGRAM, 0);
129  	if (pcapSocket &lt; 0) {
130  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
131  			&quot;The networking stack doesn&#x27;t seem to be available.\n&quot;);
132  		return NULL;
133  	}
134  	struct ifreq request;
135  	if (!prepare_request(&amp;request, device)) {
136  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
137  			&quot;Interface name \&quot;%s\&quot; is too long.&quot;, device);
138  		close(pcapSocket);
139  		return NULL;
140  	}
141  	if (ioctl(pcapSocket, SIOCGIFINDEX, &amp;request, sizeof(request)) &lt; 0) {
142  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE,
143  			&quot;Interface \&quot;%s\&quot; does not exist.\n&quot;, device);
144  		close(pcapSocket);
145  		return NULL;
146  	}
147  	close(pcapSocket);
148  	pcapSocket = socket(AF_LINK, SOCK_DGRAM, 0);
149  	if (pcapSocket &lt; 0) {
150  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, &quot;No link level: %s\n&quot;,
151  			strerror(errno));
152  		return NULL;
153  	}
154  	if (ioctl(pcapSocket, SIOCSPACKETCAP, &amp;request, sizeof(struct ifreq)) &lt; 0) {
155  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, &quot;Cannot start monitoring: %s\n&quot;,
156  			strerror(errno));
157  		close(pcapSocket);
158  		return NULL;
159  	}
160  	pcap_t* handle = PCAP_CREATE_COMMON(errorBuffer, struct pcap_haiku);
161  	if (handle == NULL) {
162  		snprintf(errorBuffer, PCAP_ERRBUF_SIZE, &quot;malloc: %s&quot;, strerror(errno));
163  		close(pcapSocket);
164  		return NULL;
165  	}
166  	handle-&gt;selectable_fd = pcapSocket;
167  	handle-&gt;fd = pcapSocket;
168  	handle-&gt;activate_op = pcap_activate_haiku;
169  	return handle;
170  }
171  static int
172  can_be_bound(const char *name _U_)
173  {
174  	return 1;
175  }
176  static int
177  get_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)
178  {
179  	if (*flags &amp; PCAP_IF_LOOPBACK) {
180  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
181  		return (0);
182  	}
183  	return (0);
184  }
185  int
186  pcap_platform_finddevs(pcap_if_list_t* _allDevices, char* errorBuffer)
187  {
188  	return pcap_findalldevs_interfaces(_allDevices, errorBuffer, can_be_bound,
189  		get_if_flags);
190  }
191  const char *
192  pcap_lib_version(void)
193  {
194  	return (PCAP_VERSION_STRING);
195  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-linux.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #ifdef HAVE_CONFIG_H
3  #include &lt;config.h&gt;
4  #endif
5  #include &lt;errno.h&gt;
6  #include &lt;stdio.h&gt;
7  #include &lt;stdlib.h&gt;
8  #include &lt;unistd.h&gt;
9  #include &lt;fcntl.h&gt;
10  #include &lt;string.h&gt;
11  #include &lt;limits.h&gt;
12  #include &lt;sys/stat.h&gt;
13  #include &lt;sys/socket.h&gt;
14  #include &lt;sys/ioctl.h&gt;
15  #include &lt;sys/utsname.h&gt;
16  #include &lt;sys/mman.h&gt;
17  #include &lt;linux/if.h&gt;
18  #include &lt;linux/if_packet.h&gt;
19  #include &lt;linux/sockios.h&gt;
20  #include &lt;linux/ethtool.h&gt;
21  #include &lt;netinet/in.h&gt;
22  #include &lt;linux/if_ether.h&gt;
23  #include &lt;linux/if_arp.h&gt;
24  #include &lt;poll.h&gt;
25  #include &lt;dirent.h&gt;
26  #include &lt;sys/eventfd.h&gt;
27  #include &quot;pcap-int.h&quot;
28  #include &quot;pcap/sll.h&quot;
29  #include &quot;pcap/vlan.h&quot;
30  #include &quot;pcap/can_socketcan.h&quot;
31  #include &quot;diag-control.h&quot;
32  #ifndef TPACKET2_HDRLEN
33  #error &quot;Libpcap will only work if TPACKET_V2 is supported; you must build for a 2.6.27 or later kernel&quot;
34  #endif
35  #ifdef TPACKET3_HDRLEN
36  # define HAVE_TPACKET3
37  #endif &amp;bsol;* TPACKET3_HDRLEN */
38  #ifndef HAVE___ATOMIC_LOAD_N
39  #define __atomic_load_n(ptr, memory_model)		(*(ptr))
40  #endif
41  #ifndef HAVE___ATOMIC_STORE_N
42  #define __atomic_store_n(ptr, val, memory_model)	*(ptr) = (val)
43  #endif
44  #define packet_mmap_acquire(pkt) \
45  	(__atomic_load_n(&amp;pkt-&gt;tp_status, __ATOMIC_ACQUIRE) != TP_STATUS_KERNEL)
46  #define packet_mmap_release(pkt) \
47  	(__atomic_store_n(&amp;pkt-&gt;tp_status, TP_STATUS_KERNEL, __ATOMIC_RELEASE))
48  #define packet_mmap_v3_acquire(pkt) \
49  	(__atomic_load_n(&amp;pkt-&gt;hdr.bh1.block_status, __ATOMIC_ACQUIRE) != TP_STATUS_KERNEL)
50  #define packet_mmap_v3_release(pkt) \
51  	(__atomic_store_n(&amp;pkt-&gt;hdr.bh1.block_status, TP_STATUS_KERNEL, __ATOMIC_RELEASE))
52  #include &lt;linux/types.h&gt;
53  #include &lt;linux/filter.h&gt;
54  #ifdef HAVE_LINUX_NET_TSTAMP_H
55  #include &lt;linux/net_tstamp.h&gt;
56  #endif
57  #include &lt;linux/if_bonding.h&gt;
58  #ifdef HAVE_LIBNL
59  #include &lt;linux/nl80211.h&gt;
60  #include &lt;netlink/genl/genl.h&gt;
61  #include &lt;netlink/genl/family.h&gt;
62  #include &lt;netlink/genl/ctrl.h&gt;
63  #include &lt;netlink/msg.h&gt;
64  #include &lt;netlink/attr.h&gt;
65  #endif &amp;bsol;* HAVE_LIBNL */
66  #ifndef HAVE_SOCKLEN_T
67  typedef int		socklen_t;
68  #endif
69  #define MAX_LINKHEADER_SIZE	256
70  #define BIGGER_THAN_ALL_MTUS	(64*1024)
71  struct pcap_linux {
72  	long long sysfs_dropped; &amp;bsol;* packets reported dropped by /sys/class/net/{if_name}/statistics/rx_{missed,fifo}_errors */
73  	struct pcap_stat stat;
74  	char	*device;	&amp;bsol;* device name */
75  	int	filter_in_userland; &amp;bsol;* must filter in userland */
76  	int	blocks_to_filter_in_userland;
77  	int	must_do_on_close; &amp;bsol;* stuff we must do when we close */
78  	int	timeout;	&amp;bsol;* timeout for buffering */
79  	int	cooked;		&amp;bsol;* using SOCK_DGRAM rather than SOCK_RAW */
80  	int	ifindex;	&amp;bsol;* interface index of device we&#x27;re bound to */
81  	int	lo_ifindex;	&amp;bsol;* interface index of the loopback device */
82  	int	netdown;	&amp;bsol;* we got an ENETDOWN and haven&#x27;t resolved it */
83  	bpf_u_int32 oldmode;	&amp;bsol;* mode to restore when turning monitor mode off */
84  	char	*mondevice;	&amp;bsol;* mac80211 monitor device we created */
85  	u_char	*mmapbuf;	&amp;bsol;* memory-mapped region pointer */
86  	size_t	mmapbuflen;	&amp;bsol;* size of region */
87  	int	vlan_offset;	&amp;bsol;* offset at which to insert vlan tags; if -1, don&#x27;t insert */
88  	u_int	tp_version;	&amp;bsol;* version of tpacket_hdr for mmaped ring */
89  	u_int	tp_hdrlen;	&amp;bsol;* hdrlen of tpacket_hdr for mmaped ring */
90  	u_char	*oneshot_buffer; &amp;bsol;* buffer for copy of packet */
91  	int	poll_timeout;	&amp;bsol;* timeout to use in poll() */
92  #ifdef HAVE_TPACKET3
93  	unsigned char *current_packet; &amp;bsol;* Current packet within the TPACKET_V3 block. Move to next block if NULL. */
94  	int packets_left; &amp;bsol;* Unhandled packets left within the block from previous call to pcap_read_linux_mmap_v3 in case of TPACKET_V3. */
95  #endif
96  	int poll_breakloop_fd; &amp;bsol;* fd to an eventfd to break from blocking operations */
97  };
98  #define MUST_CLEAR_RFMON	0x00000001	&amp;bsol;* clear rfmon (monitor) mode */
99  #define MUST_DELETE_MONIF	0x00000002	&amp;bsol;* delete monitor-mode interface */
100  static int get_if_flags(const char *, bpf_u_int32 *, char *);
101  static int is_wifi(const char *);
102  static int map_arphrd_to_dlt(pcap_t *, int, const char *, int);
103  static int pcap_activate_linux(pcap_t *);
104  static int setup_socket(pcap_t *, int);
105  static int setup_mmapped(pcap_t *);
106  static int pcap_can_set_rfmon_linux(pcap_t *);
107  static int pcap_inject_linux(pcap_t *, const void *, int);
108  static int pcap_stats_linux(pcap_t *, struct pcap_stat *);
109  static int pcap_setfilter_linux(pcap_t *, struct bpf_program *);
110  static int pcap_setdirection_linux(pcap_t *, pcap_direction_t);
111  static int pcap_set_datalink_linux(pcap_t *, int);
112  static void pcap_cleanup_linux(pcap_t *);
113  union thdr {
114  	struct tpacket2_hdr		*h2;
115  #ifdef HAVE_TPACKET3
116  	struct tpacket_block_desc	*h3;
117  #endif
118  	u_char				*raw;
119  };
120  #define RING_GET_FRAME_AT(h, offset) (((u_char **)h-&gt;buffer)[(offset)])
121  #define RING_GET_CURRENT_FRAME(h) RING_GET_FRAME_AT(h, h-&gt;offset)
122  static void destroy_ring(pcap_t *handle);
123  static int create_ring(pcap_t *handle);
124  static int prepare_tpacket_socket(pcap_t *handle);
125  static int pcap_read_linux_mmap_v2(pcap_t *, int, pcap_handler , u_char *);
126  #ifdef HAVE_TPACKET3
127  static int pcap_read_linux_mmap_v3(pcap_t *, int, pcap_handler , u_char *);
128  #endif
129  static int pcap_setnonblock_linux(pcap_t *p, int nonblock);
130  static int pcap_getnonblock_linux(pcap_t *p);
131  static void pcap_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
132      const u_char *bytes);
133  #ifdef TP_STATUS_VLAN_VALID
134    #define VLAN_VALID(hdr, hv)	((hv)-&gt;tp_vlan_tci != 0 || ((hdr)-&gt;tp_status &amp; TP_STATUS_VLAN_VALID))
135  #else
136    #define VLAN_VALID(hdr, hv)	((hv)-&gt;tp_vlan_tci != 0 || ((hdr)-&gt;tp_status &amp; 0x10))
137  #endif
138  #ifdef TP_STATUS_VLAN_TPID_VALID
139  # define VLAN_TPID(hdr, hv)	(((hv)-&gt;tp_vlan_tpid || ((hdr)-&gt;tp_status &amp; TP_STATUS_VLAN_TPID_VALID)) ? (hv)-&gt;tp_vlan_tpid : ETH_P_8021Q)
140  #else
141  # define VLAN_TPID(hdr, hv)	ETH_P_8021Q
142  #endif
143  static const struct timeval netdown_timeout = {
144  	0, 1000		&amp;bsol;* 1000 microseconds = 1 millisecond */
145  };
146  static int	iface_get_id(int fd, const char *device, char *ebuf);
147  static int	iface_get_mtu(int fd, const char *device, char *ebuf);
148  static int	iface_get_arptype(int fd, const char *device, char *ebuf);
149  static int	iface_bind(int fd, int ifindex, char *ebuf, int protocol);
150  static int	enter_rfmon_mode(pcap_t *handle, int sock_fd,
151      const char *device);
152  static int	iface_get_ts_types(const char *device, pcap_t *handle,
153      char *ebuf);
154  static int	iface_get_offload(pcap_t *handle);
155  static int	fix_program(pcap_t *handle, struct sock_fprog *fcode);
156  static int	fix_offset(pcap_t *handle, struct bpf_insn *p);
157  static int	set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode);
158  static int	reset_kernel_filter(pcap_t *handle);
159  static struct sock_filter	total_insn
160  	= BPF_STMT(BPF_RET | BPF_K, 0);
161  static struct sock_fprog	total_fcode
162  	= { 1, &amp;total_insn };
163  static int	iface_dsa_get_proto_info(const char *device, pcap_t *handle);
164  pcap_t *
165  pcap_create_interface(const char *device, char *ebuf)
166  {
167  	pcap_t *handle;
168  	handle = PCAP_CREATE_COMMON(ebuf, struct pcap_linux);
169  	if (handle == NULL)
170  		return NULL;
171  	handle-&gt;activate_op = pcap_activate_linux;
172  	handle-&gt;can_set_rfmon_op = pcap_can_set_rfmon_linux;
173  	if (iface_get_ts_types(device, handle, ebuf) == -1) {
174  		pcap_close(handle);
175  		return NULL;
176  	}
177  	handle-&gt;tstamp_precision_list = malloc(2 * sizeof(u_int));
178  	if (handle-&gt;tstamp_precision_list == NULL) {
179  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
180  		    errno, &quot;malloc&quot;);
181  		pcap_close(handle);
182  		return NULL;
183  	}
184  	handle-&gt;tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;
185  	handle-&gt;tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
186  	handle-&gt;tstamp_precision_count = 2;
187  	struct pcap_linux *handlep = handle-&gt;priv;
188  	handlep-&gt;poll_breakloop_fd = eventfd(0, EFD_NONBLOCK);
189  	return handle;
190  }
191  #ifdef HAVE_LIBNL
192  static int
193  get_mac80211_phydev(pcap_t *handle, const char *device, char *phydev_path,
194      size_t phydev_max_pathlen)
195  {
196  	char *pathstr;
197  	ssize_t bytes_read;
198  	if (asprintf(&amp;pathstr, &quot;/sys/class/net/%s/phy80211&quot;, device) == -1) {
199  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
200  		    &quot;%s: Can&#x27;t generate path name string for /sys/class/net device&quot;,
201  		    device);
202  		return PCAP_ERROR;
203  	}
204  	bytes_read = readlink(pathstr, phydev_path, phydev_max_pathlen);
205  	if (bytes_read == -1) {
206  		if (errno == ENOENT || errno == EINVAL) {
207  			free(pathstr);
208  			return 0;
209  		}
210  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
211  		    errno, &quot;%s: Can&#x27;t readlink %s&quot;, device, pathstr);
212  		free(pathstr);
213  		return PCAP_ERROR;
214  	}
215  	free(pathstr);
216  	phydev_path[bytes_read] = &#x27;\0&#x27;;
217  	return 1;
218  }
219  struct nl80211_state {
220  	struct nl_sock *nl_sock;
221  	struct nl_cache *nl_cache;
222  	struct genl_family *nl80211;
223  };
224  static int
225  nl80211_init(pcap_t *handle, struct nl80211_state *state, const char *device)
226  {
227  	int err;
228  	state-&gt;nl_sock = nl_socket_alloc();
229  	if (!state-&gt;nl_sock) {
230  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
231  		    &quot;%s: failed to allocate netlink handle&quot;, device);
232  		return PCAP_ERROR;
233  	}
234  	if (genl_connect(state-&gt;nl_sock)) {
235  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
236  		    &quot;%s: failed to connect to generic netlink&quot;, device);
237  		goto out_handle_destroy;
238  	}
239  	err = genl_ctrl_alloc_cache(state-&gt;nl_sock, &amp;state-&gt;nl_cache);
240  	if (err &lt; 0) {
241  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
242  		    &quot;%s: failed to allocate generic netlink cache: %s&quot;,
243  		    device, nl_geterror(-err));
244  		goto out_handle_destroy;
245  	}
246  	state-&gt;nl80211 = genl_ctrl_search_by_name(state-&gt;nl_cache, &quot;nl80211&quot;);
247  	if (!state-&gt;nl80211) {
248  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
249  		    &quot;%s: nl80211 not found&quot;, device);
250  		goto out_cache_free;
251  	}
252  	return 0;
253  out_cache_free:
254  	nl_cache_free(state-&gt;nl_cache);
255  out_handle_destroy:
256  	nl_socket_free(state-&gt;nl_sock);
257  	return PCAP_ERROR;
258  }
259  static void
260  nl80211_cleanup(struct nl80211_state *state)
261  {
262  	genl_family_put(state-&gt;nl80211);
263  	nl_cache_free(state-&gt;nl_cache);
264  	nl_socket_free(state-&gt;nl_sock);
265  }
266  static int
267  del_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,
268      const char *device, const char *mondevice);
269  static int
270  add_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,
271      const char *device, const char *mondevice)
272  {
273  	struct pcap_linux *handlep = handle-&gt;priv;
274  	int ifindex;
275  	struct nl_msg *msg;
276  	int err;
277  	ifindex = iface_get_id(sock_fd, device, handle-&gt;errbuf);
278  	if (ifindex == -1)
279  		return PCAP_ERROR;
280  	msg = nlmsg_alloc();
281  	if (!msg) {
282  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
283  		    &quot;%s: failed to allocate netlink msg&quot;, device);
284  		return PCAP_ERROR;
285  	}
286  	genlmsg_put(msg, 0, 0, genl_family_get_id(state-&gt;nl80211), 0,
287  		    0, NL80211_CMD_NEW_INTERFACE, 0);
288  	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
289  DIAG_OFF_NARROWING
290  	NLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, mondevice);
291  DIAG_ON_NARROWING
292  	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
293  	err = nl_send_auto_complete(state-&gt;nl_sock, msg);
294  	if (err &lt; 0) {
295  		if (err == -NLE_FAILURE) {
296  			nlmsg_free(msg);
297  			return 0;
298  		} else {
299  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
300  			    &quot;%s: nl_send_auto_complete failed adding %s interface: %s&quot;,
301  			    device, mondevice, nl_geterror(-err));
302  			nlmsg_free(msg);
303  			return PCAP_ERROR;
304  		}
305  	}
306  	err = nl_wait_for_ack(state-&gt;nl_sock);
307  	if (err &lt; 0) {
308  		if (err == -NLE_FAILURE) {
309  			nlmsg_free(msg);
310  			return 0;
311  		} else {
312  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
313  			    &quot;%s: nl_wait_for_ack failed adding %s interface: %s&quot;,
314  			    device, mondevice, nl_geterror(-err));
315  			nlmsg_free(msg);
316  			return PCAP_ERROR;
317  		}
318  	}
319  	nlmsg_free(msg);
320  	handlep-&gt;mondevice = strdup(mondevice);
321  	if (handlep-&gt;mondevice == NULL) {
322  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
323  		    errno, &quot;strdup&quot;);
324  		del_mon_if(handle, sock_fd, state, device, mondevice);
325  		return PCAP_ERROR;
326  	}
327  	return 1;
328  nla_put_failure:
329  	snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
330  	    &quot;%s: nl_put failed adding %s interface&quot;,
331  	    device, mondevice);
332  	nlmsg_free(msg);
333  	return PCAP_ERROR;
334  }
335  static int
336  del_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,
337      const char *device, const char *mondevice)
338  {
339  	int ifindex;
340  	struct nl_msg *msg;
341  	int err;
342  	ifindex = iface_get_id(sock_fd, mondevice, handle-&gt;errbuf);
343  	if (ifindex == -1)
344  		return PCAP_ERROR;
345  	msg = nlmsg_alloc();
346  	if (!msg) {
347  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
348  		    &quot;%s: failed to allocate netlink msg&quot;, device);
349  		return PCAP_ERROR;
350  	}
351  	genlmsg_put(msg, 0, 0, genl_family_get_id(state-&gt;nl80211), 0,
352  		    0, NL80211_CMD_DEL_INTERFACE, 0);
353  	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);
354  	err = nl_send_auto_complete(state-&gt;nl_sock, msg);
355  	if (err &lt; 0) {
356  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
357  		    &quot;%s: nl_send_auto_complete failed deleting %s interface: %s&quot;,
358  		    device, mondevice, nl_geterror(-err));
359  		nlmsg_free(msg);
360  		return PCAP_ERROR;
361  	}
362  	err = nl_wait_for_ack(state-&gt;nl_sock);
363  	if (err &lt; 0) {
364  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
365  		    &quot;%s: nl_wait_for_ack failed adding %s interface: %s&quot;,
366  		    device, mondevice, nl_geterror(-err));
367  		nlmsg_free(msg);
368  		return PCAP_ERROR;
369  	}
370  	nlmsg_free(msg);
371  	return 1;
372  nla_put_failure:
373  	snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
374  	    &quot;%s: nl_put failed deleting %s interface&quot;,
375  	    device, mondevice);
376  	nlmsg_free(msg);
377  	return PCAP_ERROR;
378  }
379  #endif &amp;bsol;* HAVE_LIBNL */
380  static int pcap_protocol(pcap_t *handle)
381  {
382  	int protocol;
383  	protocol = handle-&gt;opt.protocol;
384  	if (protocol == 0)
385  		protocol = ETH_P_ALL;
386  	return htons(protocol);
387  }
388  static int
389  pcap_can_set_rfmon_linux(pcap_t *handle)
390  {
391  #ifdef HAVE_LIBNL
392  	char phydev_path[PATH_MAX+1];
393  	int ret;
394  #endif
395  	if (strcmp(handle-&gt;opt.device, &quot;any&quot;) == 0) {
396  		return 0;
397  	}
398  #ifdef HAVE_LIBNL
399  	ret = get_mac80211_phydev(handle, handle-&gt;opt.device, phydev_path,
400  	    PATH_MAX);
401  	if (ret &lt; 0)
402  		return ret;	&amp;bsol;* error */
403  	if (ret == 1)
404  		return 1;	&amp;bsol;* mac80211 device */
405  #endif
406  	return 0;
407  }
408  static long long int
409  linux_get_stat(const char * if_name, const char * stat) {
410  	ssize_t bytes_read;
411  	int fd;
412  	char buffer[PATH_MAX];
413  	snprintf(buffer, sizeof(buffer), &quot;/sys/class/net/%s/statistics/%s&quot;, if_name, stat);
414  	fd = open(buffer, O_RDONLY);
415  	if (fd == -1)
416  		return 0;
417  	bytes_read = read(fd, buffer, sizeof(buffer) - 1);
418  	close(fd);
419  	if (bytes_read == -1)
420  		return 0;
421  	buffer[bytes_read] = &#x27;\0&#x27;;
422  	return strtoll(buffer, NULL, 10);
423  }
424  static long long int
425  linux_if_drops(const char * if_name)
426  {
427  	long long int missed = linux_get_stat(if_name, &quot;rx_missed_errors&quot;);
428  	long long int fifo = linux_get_stat(if_name, &quot;rx_fifo_errors&quot;);
429  	return missed + fifo;
430  }
431  static void	pcap_cleanup_linux( pcap_t *handle )
432  {
433  	struct pcap_linux *handlep = handle-&gt;priv;
434  #ifdef HAVE_LIBNL
435  	struct nl80211_state nlstate;
436  	int ret;
437  #endif &amp;bsol;* HAVE_LIBNL */
438  	if (handlep-&gt;must_do_on_close != 0) {
439  #ifdef HAVE_LIBNL
440  		if (handlep-&gt;must_do_on_close &amp; MUST_DELETE_MONIF) {
441  			ret = nl80211_init(handle, &amp;nlstate, handlep-&gt;device);
442  			if (ret &gt;= 0) {
443  				ret = del_mon_if(handle, handle-&gt;fd, &amp;nlstate,
444  				    handlep-&gt;device, handlep-&gt;mondevice);
445  				nl80211_cleanup(&amp;nlstate);
446  			}
447  			if (ret &lt; 0) {
448  				fprintf(stderr,
449  				    &quot;Can&#x27;t delete monitor interface %s (%s).\n&quot;
450  				    &quot;Please delete manually.\n&quot;,
451  				    handlep-&gt;mondevice, handle-&gt;errbuf);
452  			}
453  		}
454  #endif &amp;bsol;* HAVE_LIBNL */
455  		pcap_remove_from_pcaps_to_close(handle);
456  	}
457  	if (handle-&gt;fd != -1) {
458  		destroy_ring(handle);
459  	}
460  	if (handlep-&gt;oneshot_buffer != NULL) {
461  		munmap(handlep-&gt;oneshot_buffer, handle-&gt;snapshot);
462  		handlep-&gt;oneshot_buffer = NULL;
463  	}
464  	if (handlep-&gt;mondevice != NULL) {
465  		free(handlep-&gt;mondevice);
466  		handlep-&gt;mondevice = NULL;
467  	}
468  	if (handlep-&gt;device != NULL) {
469  		free(handlep-&gt;device);
470  		handlep-&gt;device = NULL;
471  	}
472  	if (handlep-&gt;poll_breakloop_fd != -1) {
473  		close(handlep-&gt;poll_breakloop_fd);
474  		handlep-&gt;poll_breakloop_fd = -1;
475  	}
476  	pcap_cleanup_live_common(handle);
477  }
478  #ifdef HAVE_TPACKET3
479  static int has_broken_tpacket_v3(void)
480  {
481  	struct utsname utsname;
482  	const char *release;
483  	long major, minor;
484  	int matches, verlen;
485  	if (uname(&amp;utsname) == -1)
486  		return 1;
487  	release = utsname.release;
488  	matches = sscanf(release, &quot;%ld.%ld%n&quot;, &amp;major, &amp;minor, &amp;verlen);
489  	if (matches != 2)
490  		return 1;
491  	if (release[verlen] != &#x27;.&#x27; &amp;&amp; release[verlen] != &#x27;\0&#x27;)
492  		return 1;
493  	if (major &gt; 3 || (major == 3 &amp;&amp; minor &gt;= 19))
494  		return 0;
495  	return 1;
496  }
497  #endif
498  static void
499  set_poll_timeout(struct pcap_linux *handlep)
500  {
501  #ifdef HAVE_TPACKET3
502  	int broken_tpacket_v3 = has_broken_tpacket_v3();
503  #endif
504  	if (handlep-&gt;timeout == 0) {
505  #ifdef HAVE_TPACKET3
506  		if (handlep-&gt;tp_version == TPACKET_V3 &amp;&amp; broken_tpacket_v3)
507  			handlep-&gt;poll_timeout = 1;	&amp;bsol;* don&#x27;t block for very long */
508  		else
509  #endif
510  			handlep-&gt;poll_timeout = -1;	&amp;bsol;* block forever */
511  	} else if (handlep-&gt;timeout &gt; 0) {
512  #ifdef HAVE_TPACKET3
513  		if (handlep-&gt;tp_version == TPACKET_V3 &amp;&amp; !broken_tpacket_v3)
514  			handlep-&gt;poll_timeout = -1;	&amp;bsol;* block forever, let TPACKET_V3 wake us up */
515  		else
516  #endif
517  			handlep-&gt;poll_timeout = handlep-&gt;timeout;	&amp;bsol;* block for that amount of time */
518  	} else {
519  		handlep-&gt;poll_timeout = 0;
520  	}
521  }
522  static void pcap_breakloop_linux(pcap_t *handle)
523  {
524  	pcap_breakloop_common(handle);
525  	struct pcap_linux *handlep = handle-&gt;priv;
526  	uint64_t value = 1;
527  	if (handlep-&gt;poll_breakloop_fd != -1)
528  		(void)write(handlep-&gt;poll_breakloop_fd, &amp;value, sizeof(value));
529  }
530  static void
531  set_vlan_offset(pcap_t *handle)
532  {
533  	struct pcap_linux *handlep = handle-&gt;priv;
534  	switch (handle-&gt;linktype) {
535  	case DLT_EN10MB:
536  		handlep-&gt;vlan_offset = 2 * ETH_ALEN;
537  		break;
538  	case DLT_LINUX_SLL:
539  		handlep-&gt;vlan_offset = SLL_HDR_LEN - 2;
540  		break;
541  	default:
542  		handlep-&gt;vlan_offset = -1; &amp;bsol;* unknown */
543  		break;
544  	}
545  }
546  static int
547  pcap_activate_linux(pcap_t *handle)
548  {
549  	struct pcap_linux *handlep = handle-&gt;priv;
550  	const char	*device;
551  	int		is_any_device;
552  	struct ifreq	ifr;
553  	int		status;
554  	int		ret;
555  	device = handle-&gt;opt.device;
556  	status = 0;
557  	if (strlen(device) &gt;= sizeof(ifr.ifr_name)) {
558  		handle-&gt;errbuf[0] = &#x27;\0&#x27;;
559  		status = PCAP_ERROR_NO_SUCH_DEVICE;
560  		goto fail;
561  	}
562  	if (handle-&gt;snapshot &lt;= 0 || handle-&gt;snapshot &gt; MAXIMUM_SNAPLEN)
563  		handle-&gt;snapshot = MAXIMUM_SNAPLEN;
564  	handlep-&gt;device	= strdup(device);
565  	if (handlep-&gt;device == NULL) {
566  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
567  		    errno, &quot;strdup&quot;);
568  		status = PCAP_ERROR;
569  		goto fail;
570  	}
571  	is_any_device = (strcmp(device, &quot;any&quot;) == 0);
572  	if (is_any_device) {
573  		if (handle-&gt;opt.promisc) {
574  			handle-&gt;opt.promisc = 0;
575  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
576  			    &quot;Promiscuous mode not supported on the \&quot;any\&quot; device&quot;);
577  			status = PCAP_WARNING_PROMISC_NOTSUP;
578  		}
579  	}
580  	handlep-&gt;timeout = handle-&gt;opt.timeout;
581  	if (handle-&gt;opt.promisc)
582  		handlep-&gt;sysfs_dropped = linux_if_drops(handlep-&gt;device);
583  	ret = setup_socket(handle, is_any_device);
584  	if (ret &lt; 0) {
585  		status = ret;
586  		goto fail;
587  	}
588  	if (ret &gt; 0) {
589  		status = ret;
590  	}
591  	ret = setup_mmapped(handle);
592  	if (ret &lt; 0) {
593  		status = ret;
594  		goto fail;
595  	}
596  	if (ret &gt; 0) {
597  		status = ret;
598  	}
599  	if ((ret = iface_bind(handle-&gt;fd, handlep-&gt;ifindex,
600  	    handle-&gt;errbuf, pcap_protocol(handle))) != 0) {
601  		status = ret;
602  		goto fail;
603  	}
604  	handle-&gt;inject_op = pcap_inject_linux;
605  	handle-&gt;setfilter_op = pcap_setfilter_linux;
606  	handle-&gt;setdirection_op = pcap_setdirection_linux;
607  	handle-&gt;set_datalink_op = pcap_set_datalink_linux;
608  	handle-&gt;setnonblock_op = pcap_setnonblock_linux;
609  	handle-&gt;getnonblock_op = pcap_getnonblock_linux;
610  	handle-&gt;cleanup_op = pcap_cleanup_linux;
611  	handle-&gt;stats_op = pcap_stats_linux;
612  	handle-&gt;breakloop_op = pcap_breakloop_linux;
613  	switch (handlep-&gt;tp_version) {
614  	case TPACKET_V2:
615  		handle-&gt;read_op = pcap_read_linux_mmap_v2;
616  		break;
617  #ifdef HAVE_TPACKET3
618  	case TPACKET_V3:
619  		handle-&gt;read_op = pcap_read_linux_mmap_v3;
620  		break;
621  #endif
622  	}
623  	handle-&gt;oneshot_callback = pcap_oneshot_linux;
624  	handle-&gt;selectable_fd = handle-&gt;fd;
625  	return status;
626  fail:
627  	pcap_cleanup_linux(handle);
628  	return status;
629  }
630  static int
631  pcap_set_datalink_linux(pcap_t *handle, int dlt)
632  {
633  	handle-&gt;linktype = dlt;
634  	set_vlan_offset(handle);
635  	return 0;
636  }
637  static inline int
638  linux_check_direction(const pcap_t *handle, const struct sockaddr_ll *sll)
639  {
640  	struct pcap_linux	*handlep = handle-&gt;priv;
641  	if (sll-&gt;sll_pkttype == PACKET_OUTGOING) {
642  		if (sll-&gt;sll_ifindex == handlep-&gt;lo_ifindex)
643  			return 0;
644  		if (sll-&gt;sll_hatype == ARPHRD_CAN &amp;&amp;
645  		     handle-&gt;direction != PCAP_D_OUT)
646  			return 0;
647  		if (handle-&gt;direction == PCAP_D_IN)
648  			return 0;
649  	} else {
650  		if (handle-&gt;direction == PCAP_D_OUT)
651  			return 0;
652  	}
653  	return 1;
654  }
655  static int
656  device_still_exists(pcap_t *handle)
657  {
658  	struct pcap_linux *handlep = handle-&gt;priv;
659  	struct sockaddr_ll addr;
660  	socklen_t addr_len;
661  	if (handlep-&gt;ifindex == -1)
662  		return (1);	&amp;bsol;* it&#x27;s still here */
663  	addr_len = sizeof (addr);
664  	if (getsockname(handle-&gt;fd, (struct sockaddr *) &amp;addr, &amp;addr_len) == -1) {
665  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
666  		    errno, &quot;getsockname failed&quot;);
667  		return (-1);
668  	}
669  	if (addr.sll_ifindex == -1) {
670  		return (0);
671  	}
672  	return (1);
673  }
674  static int
675  pcap_inject_linux(pcap_t *handle, const void *buf, int size)
676  {
677  	struct pcap_linux *handlep = handle-&gt;priv;
678  	int ret;
679  	if (handlep-&gt;ifindex == -1) {
680  		pcap_strlcpy(handle-&gt;errbuf,
681  		    &quot;Sending packets isn&#x27;t supported on the \&quot;any\&quot; device&quot;,
682  		    PCAP_ERRBUF_SIZE);
683  		return (-1);
684  	}
685  	if (handlep-&gt;cooked) {
686  		pcap_strlcpy(handle-&gt;errbuf,
687  		    &quot;Sending packets isn&#x27;t supported in cooked mode&quot;,
688  		    PCAP_ERRBUF_SIZE);
689  		return (-1);
690  	}
691  	ret = (int)send(handle-&gt;fd, buf, size, 0);
692  	if (ret == -1) {
693  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
694  		    errno, &quot;send&quot;);
695  		return (-1);
696  	}
697  	return (ret);
698  }
699  static int
700  pcap_stats_linux(pcap_t *handle, struct pcap_stat *stats)
701  {
702  	struct pcap_linux *handlep = handle-&gt;priv;
703  #ifdef HAVE_TPACKET3
704  	struct tpacket_stats_v3 kstats;
705  #else &amp;bsol;* HAVE_TPACKET3 */
706  	struct tpacket_stats kstats;
707  #endif &amp;bsol;* HAVE_TPACKET3 */
708  	socklen_t len = sizeof (struct tpacket_stats);
709  	long long if_dropped = 0;
710  	if (handle-&gt;opt.promisc)
711  	{
712  		if_dropped = handlep-&gt;sysfs_dropped;
713  		handlep-&gt;sysfs_dropped = linux_if_drops(handlep-&gt;device);
714  		handlep-&gt;stat.ps_ifdrop += (u_int)(handlep-&gt;sysfs_dropped - if_dropped);
715  	}
716  	if (getsockopt(handle-&gt;fd, SOL_PACKET, PACKET_STATISTICS,
717  			&amp;kstats, &amp;len) &gt; -1) {
718  		handlep-&gt;stat.ps_recv += kstats.tp_packets;
719  		handlep-&gt;stat.ps_drop += kstats.tp_drops;
720  		*stats = handlep-&gt;stat;
721  		return 0;
722  	}
723  	pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE, errno,
724  	    &quot;failed to get statistics from socket&quot;);
725  	return -1;
726  }
727  static int
728  can_be_bound(const char *name _U_)
729  {
730  	return (1);
731  }
732  static int
733  get_if_ioctl_socket(void)
734  {
735  	int fd;
736  	fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
737  	if (fd != -1) {
738  		struct ifreq ifr;
739  		memset(&amp;ifr, 0, sizeof(ifr));
740  		if (ioctl(fd, SIOCGIFNAME, &amp;ifr) == 0 ||
741  		    errno != EOPNOTSUPP) {
742  			return (fd);
743  		}
744  		close(fd);
745  	}
746  	fd = socket(AF_UNIX, SOCK_RAW, 0);
747  	if (fd != -1) {
748  		return (fd);
749  	}
750  	fd = socket(AF_INET6, SOCK_DGRAM, 0);
751  	if (fd != -1) {
752  		return (fd);
753  	}
754  	return (socket(AF_INET, SOCK_DGRAM, 0));
755  }
756  static int
757  get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
758  {
759  	int sock;
760  	FILE *fh;
761  	unsigned int arptype;
762  	struct ifreq ifr;
763  	struct ethtool_value info;
764  	if (*flags &amp; PCAP_IF_LOOPBACK) {
765  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
766  		return 0;
767  	}
768  	sock = get_if_ioctl_socket();
769  	if (sock == -1) {
770  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
771  		    &quot;Can&#x27;t create socket to get ethtool information for %s&quot;,
772  		    name);
773  		return -1;
774  	}
775  	if (is_wifi(name)) {
776  		*flags |= PCAP_IF_WIRELESS;
777  	} else {
778  		char *pathstr;
779  		if (asprintf(&amp;pathstr, &quot;/sys/class/net/%s/type&quot;, name) == -1) {
780  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
781  			    &quot;%s: Can&#x27;t generate path name string for /sys/class/net device&quot;,
782  			    name);
783  			close(sock);
784  			return -1;
785  		}
786  		fh = fopen(pathstr, &quot;r&quot;);
787  		if (fh != NULL) {
788  			if (fscanf(fh, &quot;%u&quot;, &amp;arptype) == 1) {
789  				switch (arptype) {
790  				case ARPHRD_LOOPBACK:
791  					close(sock);
792  					fclose(fh);
793  					free(pathstr);
794  					return 0;
795  				case ARPHRD_IRDA:
796  				case ARPHRD_IEEE80211:
797  				case ARPHRD_IEEE80211_PRISM:
798  				case ARPHRD_IEEE80211_RADIOTAP:
799  #ifdef ARPHRD_IEEE802154
800  				case ARPHRD_IEEE802154:
801  #endif
802  #ifdef ARPHRD_IEEE802154_MONITOR
803  				case ARPHRD_IEEE802154_MONITOR:
804  #endif
805  #ifdef ARPHRD_6LOWPAN
806  				case ARPHRD_6LOWPAN:
807  #endif
808  					*flags |= PCAP_IF_WIRELESS;
809  					break;
810  				}
811  			}
812  			fclose(fh);
813  		}
814  		free(pathstr);
815  	}
816  #ifdef ETHTOOL_GLINK
817  	memset(&amp;ifr, 0, sizeof(ifr));
818  	pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
819  	info.cmd = ETHTOOL_GLINK;
820  	info.data = 0;
821  	ifr.ifr_data = (caddr_t)&amp;info;
822  	if (ioctl(sock, SIOCETHTOOL, &amp;ifr) == -1) {
823  		int save_errno = errno;
824  		switch (save_errno) {
825  		case EOPNOTSUPP:
826  		case EINVAL:
827  			*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
828  			close(sock);
829  			return 0;
830  		case ENODEV:
831  			close(sock);
832  			return 0;
833  		default:
834  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
835  			    save_errno,
836  			    &quot;%s: SIOCETHTOOL(ETHTOOL_GLINK) ioctl failed&quot;,
837  			    name);
838  			close(sock);
839  			return -1;
840  		}
841  	}
842  	if (info.data) {
843  		*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;
844  	} else {
845  		*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
846  	}
847  #endif
848  	close(sock);
849  	return 0;
850  }
851  int
852  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
853  {
854  	if (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,
855  	    get_if_flags) == -1)
856  		return (-1);	&amp;bsol;* failure */
857  	if (pcap_add_any_dev(devlistp, errbuf) == NULL)
858  		return (-1);
859  	return (0);
860  }
861  static int
862  pcap_setdirection_linux(pcap_t *handle, pcap_direction_t d)
863  {
864  	handle-&gt;direction = d;
865  	return 0;
866  }
867  static int
868  is_wifi(const char *device)
869  {
870  	char *pathstr;
871  	struct stat statb;
872  	if (asprintf(&amp;pathstr, &quot;/sys/class/net/%s/wireless&quot;, device) == -1) {
873  		return 0;
874  	}
875  	if (stat(pathstr, &amp;statb) == 0) {
876  		free(pathstr);
877  		return 1;
878  	}
879  	free(pathstr);
880  	return 0;
881  }
882  static int map_arphrd_to_dlt(pcap_t *handle, int arptype,
883  			     const char *device, int cooked_ok)
884  {
885  	static const char cdma_rmnet[] = &quot;cdma_rmnet&quot;;
886  	switch (arptype) {
887  	case ARPHRD_ETHER:
888  		if (strncmp(device, cdma_rmnet, sizeof cdma_rmnet - 1) == 0) {
889  			handle-&gt;linktype = DLT_RAW;
890  			return 0;
891  		}
892  		if (!is_wifi(device)) {
893  			int ret;
894  			ret = iface_dsa_get_proto_info(device, handle);
895  			if (ret &lt; 0)
896  				return ret;
897  			if (ret == 1) {
898  				handle-&gt;offset = 2;
899  				break;
900  			}
901  			handle-&gt;dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
902  			if (handle-&gt;dlt_list == NULL) {
903  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
904  				    PCAP_ERRBUF_SIZE, errno, &quot;malloc&quot;);
905  				return (PCAP_ERROR);
906  			}
907  			handle-&gt;dlt_list[0] = DLT_EN10MB;
908  			handle-&gt;dlt_list[1] = DLT_DOCSIS;
909  			handle-&gt;dlt_count = 2;
910  		}
911  	case ARPHRD_METRICOM:
912  	case ARPHRD_LOOPBACK:
913  		handle-&gt;linktype = DLT_EN10MB;
914  		handle-&gt;offset = 2;
915  		break;
916  	case ARPHRD_EETHER:
917  		handle-&gt;linktype = DLT_EN3MB;
918  		break;
919  	case ARPHRD_AX25:
920  		handle-&gt;linktype = DLT_AX25_KISS;
921  		break;
922  	case ARPHRD_PRONET:
923  		handle-&gt;linktype = DLT_PRONET;
924  		break;
925  	case ARPHRD_CHAOS:
926  		handle-&gt;linktype = DLT_CHAOS;
927  		break;
928  #ifndef ARPHRD_CAN
929  #define ARPHRD_CAN 280
930  #endif
931  	case ARPHRD_CAN:
932  		handle-&gt;linktype = DLT_CAN_SOCKETCAN;
933  		break;
934  #ifndef ARPHRD_IEEE802_TR
935  #define ARPHRD_IEEE802_TR 800	&amp;bsol;* From Linux 2.4 */
936  #endif
937  	case ARPHRD_IEEE802_TR:
938  	case ARPHRD_IEEE802:
939  		handle-&gt;linktype = DLT_IEEE802;
940  		handle-&gt;offset = 2;
941  		break;
942  	case ARPHRD_ARCNET:
943  		handle-&gt;linktype = DLT_ARCNET_LINUX;
944  		break;
945  #ifndef ARPHRD_FDDI	&amp;bsol;* From Linux 2.2.13 */
946  #define ARPHRD_FDDI	774
947  #endif
948  	case ARPHRD_FDDI:
949  		handle-&gt;linktype = DLT_FDDI;
950  		handle-&gt;offset = 3;
951  		break;
952  #ifndef ARPHRD_ATM  &amp;bsol;* FIXME: How to #include this? */
953  #define ARPHRD_ATM 19
954  #endif
955  	case ARPHRD_ATM:
956  		if (cooked_ok)
957  			handle-&gt;linktype = DLT_LINUX_SLL;
958  		else
959  			handle-&gt;linktype = -1;
960  		break;
961  #ifndef ARPHRD_IEEE80211  &amp;bsol;* From Linux 2.4.6 */
962  #define ARPHRD_IEEE80211 801
963  #endif
964  	case ARPHRD_IEEE80211:
965  		handle-&gt;linktype = DLT_IEEE802_11;
966  		break;
967  #ifndef ARPHRD_IEEE80211_PRISM  &amp;bsol;* From Linux 2.4.18 */
968  #define ARPHRD_IEEE80211_PRISM 802
969  #endif
970  	case ARPHRD_IEEE80211_PRISM:
971  		handle-&gt;linktype = DLT_PRISM_HEADER;
972  		break;
973  #ifndef ARPHRD_IEEE80211_RADIOTAP &amp;bsol;* new */
974  #define ARPHRD_IEEE80211_RADIOTAP 803
975  #endif
976  	case ARPHRD_IEEE80211_RADIOTAP:
977  		handle-&gt;linktype = DLT_IEEE802_11_RADIO;
978  		break;
979  	case ARPHRD_PPP:
980  		if (cooked_ok)
981  			handle-&gt;linktype = DLT_LINUX_SLL;
982  		else {
983  			handle-&gt;linktype = DLT_RAW;
984  		}
985  		break;
986  #ifndef ARPHRD_CISCO
987  #define ARPHRD_CISCO 513 &amp;bsol;* previously ARPHRD_HDLC */
988  #endif
989  	case ARPHRD_CISCO:
990  		handle-&gt;linktype = DLT_C_HDLC;
991  		break;
992  	case ARPHRD_TUNNEL:
993  #ifndef ARPHRD_SIT
994  #define ARPHRD_SIT 776	&amp;bsol;* From Linux 2.2.13 */
995  #endif
996  	case ARPHRD_SIT:
997  	case ARPHRD_CSLIP:
998  	case ARPHRD_SLIP6:
999  	case ARPHRD_CSLIP6:
1000  	case ARPHRD_ADAPT:
1001  	case ARPHRD_SLIP:
1002  #ifndef ARPHRD_RAWHDLC
1003  #define ARPHRD_RAWHDLC 518
1004  #endif
1005  	case ARPHRD_RAWHDLC:
1006  #ifndef ARPHRD_DLCI
1007  #define ARPHRD_DLCI 15
1008  #endif
1009  	case ARPHRD_DLCI:
1010  		handle-&gt;linktype = DLT_RAW;
1011  		break;
1012  #ifndef ARPHRD_FRAD
1013  #define ARPHRD_FRAD 770
1014  #endif
1015  	case ARPHRD_FRAD:
1016  		handle-&gt;linktype = DLT_FRELAY;
1017  		break;
1018  	case ARPHRD_LOCALTLK:
1019  		handle-&gt;linktype = DLT_LTALK;
1020  		break;
1021  	case 18:
1022  		handle-&gt;linktype = DLT_IP_OVER_FC;
1023  		break;
1024  #ifndef ARPHRD_FCPP
1025  #define ARPHRD_FCPP	784
1026  #endif
1027  	case ARPHRD_FCPP:
1028  #ifndef ARPHRD_FCAL
1029  #define ARPHRD_FCAL	785
1030  #endif
1031  	case ARPHRD_FCAL:
1032  #ifndef ARPHRD_FCPL
1033  #define ARPHRD_FCPL	786
1034  #endif
1035  	case ARPHRD_FCPL:
1036  #ifndef ARPHRD_FCFABRIC
1037  #define ARPHRD_FCFABRIC	787
1038  #endif
1039  	case ARPHRD_FCFABRIC:
1040  		handle-&gt;linktype = DLT_FC_2;
1041  		handle-&gt;dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
1042  		if (handle-&gt;dlt_list == NULL) {
1043  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1044  			    PCAP_ERRBUF_SIZE, errno, &quot;malloc&quot;);
1045  			return (PCAP_ERROR);
1046  		}
1047  		handle-&gt;dlt_list[0] = DLT_FC_2;
1048  		handle-&gt;dlt_list[1] = DLT_FC_2_WITH_FRAME_DELIMS;
1049  		handle-&gt;dlt_list[2] = DLT_IP_OVER_FC;
1050  		handle-&gt;dlt_count = 3;
1051  		break;
1052  #ifndef ARPHRD_IRDA
1053  #define ARPHRD_IRDA	783
1054  #endif
1055  	case ARPHRD_IRDA:
1056  		handle-&gt;linktype = DLT_LINUX_IRDA;
1057  		break;
1058  #ifndef ARPHRD_LAPD
1059  #define ARPHRD_LAPD	8445
1060  #endif
1061  	case ARPHRD_LAPD:
1062  		handle-&gt;linktype = DLT_LINUX_LAPD;
1063  		break;
1064  #ifndef ARPHRD_NONE
1065  #define ARPHRD_NONE	0xFFFE
1066  #endif
1067  	case ARPHRD_NONE:
1068  		handle-&gt;linktype = DLT_RAW;
1069  		break;
1070  #ifndef ARPHRD_IEEE802154
1071  #define ARPHRD_IEEE802154      804
1072  #endif
1073         case ARPHRD_IEEE802154:
1074                 handle-&gt;linktype =  DLT_IEEE802_15_4_NOFCS;
1075                 break;
1076  #ifndef ARPHRD_NETLINK
1077  #define ARPHRD_NETLINK	824
1078  #endif
1079  	case ARPHRD_NETLINK:
1080  		handle-&gt;linktype = DLT_NETLINK;
1081  		break;
1082  #ifndef ARPHRD_VSOCKMON
1083  #define ARPHRD_VSOCKMON	826
1084  #endif
1085  	case ARPHRD_VSOCKMON:
1086  		handle-&gt;linktype = DLT_VSOCK;
1087  		break;
1088  	default:
1089  		handle-&gt;linktype = -1;
1090  		break;
1091  	}
1092  	return (0);
1093  }
1094  static int
1095  setup_socket(pcap_t *handle, int is_any_device)
1096  {
1097  	struct pcap_linux *handlep = handle-&gt;priv;
1098  	const char		*device = handle-&gt;opt.device;
1099  	int			status = 0;
1100  	int			sock_fd, arptype;
1101  	int			val;
1102  	int			err = 0;
1103  	struct packet_mreq	mr;
1104  #if defined(SO_BPF_EXTENSIONS) &amp;&amp; defined(SKF_AD_VLAN_TAG_PRESENT)
1105  	int			bpf_extensions;
1106  	socklen_t		len = sizeof(bpf_extensions);
1107  #endif
1108  	sock_fd = is_any_device ?
1109  		socket(PF_PACKET, SOCK_DGRAM, 0) :
1110  		socket(PF_PACKET, SOCK_RAW, 0);
1111  	if (sock_fd == -1) {
1112  		if (errno == EPERM || errno == EACCES) {
1113  			status = PCAP_ERROR_PERM_DENIED;
1114  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1115  			    &quot;Attempt to create packet socket failed - CAP_NET_RAW may be required&quot;);
1116  		} else {
1117  			status = PCAP_ERROR;
1118  		}
1119  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1120  		    errno, &quot;socket&quot;);
1121  		return status;
1122  	}
1123  	handlep-&gt;lo_ifindex = iface_get_id(sock_fd, &quot;lo&quot;, handle-&gt;errbuf);
1124  	handle-&gt;offset	 = 0;
1125  	if (!is_any_device) {
1126  		handlep-&gt;cooked = 0;
1127  		if (handle-&gt;opt.rfmon) {
1128  			err = enter_rfmon_mode(handle, sock_fd, device);
1129  			if (err &lt; 0) {
1130  				close(sock_fd);
1131  				return err;
1132  			}
1133  			if (err == 0) {
1134  				close(sock_fd);
1135  				return PCAP_ERROR_RFMON_NOTSUP;
1136  			}
1137  			if (handlep-&gt;mondevice != NULL)
1138  				device = handlep-&gt;mondevice;
1139  		}
1140  		arptype	= iface_get_arptype(sock_fd, device, handle-&gt;errbuf);
1141  		if (arptype &lt; 0) {
1142  			close(sock_fd);
1143  			return arptype;
1144  		}
1145  		status = map_arphrd_to_dlt(handle, arptype, device, 1);
1146  		if (status &lt; 0)
1147  			return status;
1148  		if (handle-&gt;linktype == -1 ||
1149  		    handle-&gt;linktype == DLT_LINUX_SLL ||
1150  		    handle-&gt;linktype == DLT_LINUX_IRDA ||
1151  		    handle-&gt;linktype == DLT_LINUX_LAPD ||
1152  		    handle-&gt;linktype == DLT_NETLINK ||
1153  		    (handle-&gt;linktype == DLT_EN10MB &amp;&amp;
1154  		     (strncmp(&quot;isdn&quot;, device, 4) == 0 ||
1155  		      strncmp(&quot;isdY&quot;, device, 4) == 0))) {
1156  			if (close(sock_fd) == -1) {
1157  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1158  				    PCAP_ERRBUF_SIZE, errno, &quot;close&quot;);
1159  				return PCAP_ERROR;
1160  			}
1161  			sock_fd = socket(PF_PACKET, SOCK_DGRAM, 0);
1162  			if (sock_fd &lt; 0) {
<span onclick='openModal()' class='match'>1163  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1164  				    PCAP_ERRBUF_SIZE, errno, &quot;socket&quot;);
1165  				return PCAP_ERROR;
1166  			}
1167  			handlep-&gt;cooked = 1;
</span>1168  			if (handle-&gt;dlt_list != NULL) {
1169  				free(handle-&gt;dlt_list);
1170  				handle-&gt;dlt_list = NULL;
1171  				handle-&gt;dlt_count = 0;
1172  			}
1173  			if (handle-&gt;linktype == -1) {
1174  				snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1175  					&quot;arptype %d not &quot;
1176  					&quot;supported by libpcap - &quot;
1177  					&quot;falling back to cooked &quot;
1178  					&quot;socket&quot;,
1179  					arptype);
1180  				status = PCAP_WARNING;
1181  			}
1182  			if (handle-&gt;linktype != DLT_LINUX_IRDA &amp;&amp;
1183  			    handle-&gt;linktype != DLT_LINUX_LAPD &amp;&amp;
1184  			    handle-&gt;linktype != DLT_NETLINK)
1185  				handle-&gt;linktype = DLT_LINUX_SLL;
1186  		}
1187  		handlep-&gt;ifindex = iface_get_id(sock_fd, device,
1188  		    handle-&gt;errbuf);
1189  		if (handlep-&gt;ifindex == -1) {
1190  			close(sock_fd);
1191  			return PCAP_ERROR;
1192  		}
1193  		if ((err = iface_bind(sock_fd, handlep-&gt;ifindex,
1194  		    handle-&gt;errbuf, 0)) != 0) {
1195  			close(sock_fd);
1196  			return err;
1197  		}
1198  	} else {
1199  		if (handle-&gt;opt.rfmon) {
1200  			close(sock_fd);
1201  			return PCAP_ERROR_RFMON_NOTSUP;
1202  		}
1203  		handlep-&gt;cooked = 1;
1204  		handle-&gt;linktype = DLT_LINUX_SLL;
1205  		handle-&gt;dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
1206  		if (handle-&gt;dlt_list == NULL) {
1207  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1208  			    PCAP_ERRBUF_SIZE, errno, &quot;malloc&quot;);
1209  			return (PCAP_ERROR);
1210  		}
1211  		handle-&gt;dlt_list[0] = DLT_LINUX_SLL;
1212  		handle-&gt;dlt_list[1] = DLT_LINUX_SLL2;
1213  		handle-&gt;dlt_count = 2;
1214  		handlep-&gt;ifindex = -1;
1215  	}
1216  	if (!is_any_device &amp;&amp; handle-&gt;opt.promisc) {
1217  		memset(&amp;mr, 0, sizeof(mr));
1218  		mr.mr_ifindex = handlep-&gt;ifindex;
1219  		mr.mr_type    = PACKET_MR_PROMISC;
1220  		if (setsockopt(sock_fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,
1221  		    &amp;mr, sizeof(mr)) == -1) {
1222  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1223  			    PCAP_ERRBUF_SIZE, errno, &quot;setsockopt (PACKET_ADD_MEMBERSHIP)&quot;);
1224  			close(sock_fd);
1225  			return PCAP_ERROR;
1226  		}
1227  	}
1228  	val = 1;
1229  	if (setsockopt(sock_fd, SOL_PACKET, PACKET_AUXDATA, &amp;val,
1230  		       sizeof(val)) == -1 &amp;&amp; errno != ENOPROTOOPT) {
1231  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1232  		    errno, &quot;setsockopt (PACKET_AUXDATA)&quot;);
1233  		close(sock_fd);
1234  		return PCAP_ERROR;
1235  	}
1236  	handle-&gt;offset += VLAN_TAG_LEN;
1237  	if (handlep-&gt;cooked) {
1238  		if (handle-&gt;snapshot &lt; SLL2_HDR_LEN + 1)
1239  			handle-&gt;snapshot = SLL2_HDR_LEN + 1;
1240  	}
1241  	handle-&gt;bufsize = handle-&gt;snapshot;
1242  	set_vlan_offset(handle);
1243  	if (handle-&gt;opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {
1244  		int nsec_tstamps = 1;
1245  		if (setsockopt(sock_fd, SOL_SOCKET, SO_TIMESTAMPNS, &amp;nsec_tstamps, sizeof(nsec_tstamps)) &lt; 0) {
1246  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE, &quot;setsockopt: unable to set SO_TIMESTAMPNS&quot;);
1247  			close(sock_fd);
1248  			return PCAP_ERROR;
1249  		}
1250  	}
1251  	handle-&gt;fd = sock_fd;
1252  #if defined(SO_BPF_EXTENSIONS) &amp;&amp; defined(SKF_AD_VLAN_TAG_PRESENT)
1253  	if (getsockopt(sock_fd, SOL_SOCKET, SO_BPF_EXTENSIONS,
1254  	    &amp;bpf_extensions, &amp;len) == 0) {
1255  		if (bpf_extensions &gt;= SKF_AD_VLAN_TAG_PRESENT) {
1256  			handle-&gt;bpf_codegen_flags |= BPF_SPECIAL_VLAN_HANDLING;
1257  		}
1258  	}
1259  #endif &amp;bsol;* defined(SO_BPF_EXTENSIONS) &amp;&amp; defined(SKF_AD_VLAN_TAG_PRESENT) */
1260  	return status;
1261  }
1262  static int
1263  setup_mmapped(pcap_t *handle)
1264  {
1265  	struct pcap_linux *handlep = handle-&gt;priv;
1266  	int flags = MAP_ANONYMOUS | MAP_PRIVATE;
1267  	int status;
1268  #ifdef MAP_32BIT
1269  	if (pcap_mmap_32bit) flags |= MAP_32BIT;
1270  #endif
1271  	handlep-&gt;oneshot_buffer = mmap(0, handle-&gt;snapshot, PROT_READ | PROT_WRITE, flags, -1, 0);
1272  	if (handlep-&gt;oneshot_buffer == MAP_FAILED) {
1273  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1274  		    errno, &quot;can&#x27;t allocate oneshot buffer&quot;);
1275  		return PCAP_ERROR;
1276  	}
1277  	if (handle-&gt;opt.buffer_size == 0) {
1278  		handle-&gt;opt.buffer_size = 2*1024*1024;
1279  	}
1280  	status = prepare_tpacket_socket(handle);
1281  	if (status == -1) {
1282  		munmap(handlep-&gt;oneshot_buffer, handle-&gt;snapshot);
1283  		handlep-&gt;oneshot_buffer = NULL;
1284  		return PCAP_ERROR;
1285  	}
1286  	status = create_ring(handle);
1287  	if (status &lt; 0) {
1288  		munmap(handlep-&gt;oneshot_buffer, handle-&gt;snapshot);
1289  		handlep-&gt;oneshot_buffer = NULL;
1290  		return status;
1291  	}
1292  	set_poll_timeout(handlep);
1293  	return status;
1294  }
1295  static int
1296  init_tpacket(pcap_t *handle, int version, const char *version_str)
1297  {
1298  	struct pcap_linux *handlep = handle-&gt;priv;
1299  	int val = version;
1300  	socklen_t len = sizeof(val);
1301  	if (getsockopt(handle-&gt;fd, SOL_PACKET, PACKET_HDRLEN, &amp;val, &amp;len) &lt; 0) {
1302  		if (errno == EINVAL) {
1303  			return 1;
1304  		}
1305  		if (errno == ENOPROTOOPT) {
1306  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1307  			    &quot;Kernel doesn&#x27;t support memory-mapped capture; a 2.6.27 or later 2.x kernel is required, with CONFIG_PACKET_MMAP specified for 2.x kernels&quot;);
1308  		} else {
1309  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1310  			    errno, &quot;can&#x27;t get %s header len on packet socket&quot;,
1311  			    version_str);
1312  		}
1313  		return -1;
1314  	}
1315  	handlep-&gt;tp_hdrlen = val;
1316  	val = version;
1317  	if (setsockopt(handle-&gt;fd, SOL_PACKET, PACKET_VERSION, &amp;val,
1318  			   sizeof(val)) &lt; 0) {
1319  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1320  		    errno, &quot;can&#x27;t activate %s on packet socket&quot;, version_str);
1321  		return -1;
1322  	}
1323  	handlep-&gt;tp_version = version;
1324  	return 0;
1325  }
1326  static int
1327  prepare_tpacket_socket(pcap_t *handle)
1328  {
1329  	int ret;
1330  #ifdef HAVE_TPACKET3
1331  	if (!handle-&gt;opt.immediate) {
1332  		ret = init_tpacket(handle, TPACKET_V3, &quot;TPACKET_V3&quot;);
1333  		if (ret == 0) {
1334  			return 0;
1335  		}
1336  		if (ret == -1) {
1337  			return -1;
1338  		}
1339  	}
1340  #endif &amp;bsol;* HAVE_TPACKET3 */
1341  	ret = init_tpacket(handle, TPACKET_V2, &quot;TPACKET_V2&quot;);
1342  	if (ret == 0) {
1343  		return 0;
1344  	}
1345  	if (ret == 1) {
1346  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1347  		    &quot;Kernel doesn&#x27;t support TPACKET_V2; a 2.6.27 or later kernel is required&quot;);
1348  	}
1349  	return -1;
1350  }
1351  #define MAX(a,b) ((a)&gt;(b)?(a):(b))
1352  static int
1353  create_ring(pcap_t *handle)
1354  {
1355  	struct pcap_linux *handlep = handle-&gt;priv;
1356  	unsigned i, j, frames_per_block;
1357  	int flags = MAP_SHARED;
1358  #ifdef HAVE_TPACKET3
1359  	struct tpacket_req3 req;
1360  #else
1361  	struct tpacket_req req;
1362  #endif
1363  	socklen_t len;
1364  	unsigned int sk_type, tp_reserve, maclen, tp_hdrlen, netoff, macoff;
1365  	unsigned int frame_size;
1366  	int status;
1367  	status = 0;
1368  	tp_reserve = VLAN_TAG_LEN;
1369  	if (handlep-&gt;cooked)
1370  		tp_reserve += SLL2_HDR_LEN - 16;
1371  	len = sizeof(tp_reserve);
1372  	if (setsockopt(handle-&gt;fd, SOL_PACKET, PACKET_RESERVE,
1373  	    &amp;tp_reserve, len) &lt; 0) {
1374  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1375  		    PCAP_ERRBUF_SIZE, errno,
1376  		    &quot;setsockopt (PACKET_RESERVE)&quot;);
1377  		return PCAP_ERROR;
1378  	}
1379  	switch (handlep-&gt;tp_version) {
1380  	case TPACKET_V2:
1381  		frame_size = handle-&gt;snapshot;
1382  		if (handle-&gt;linktype == DLT_EN10MB) {
1383  			unsigned int max_frame_len;
1384  			int mtu;
1385  			int offload;
1386  			mtu = iface_get_mtu(handle-&gt;fd, handle-&gt;opt.device,
1387  			    handle-&gt;errbuf);
1388  			if (mtu == -1)
1389  				return PCAP_ERROR;
1390  			offload = iface_get_offload(handle);
1391  			if (offload == -1)
1392  				return PCAP_ERROR;
1393  			if (offload)
1394  				max_frame_len = MAX(mtu, 65535);
1395  			else
1396  				max_frame_len = mtu;
1397  			max_frame_len += 18;
1398  			if (frame_size &gt; max_frame_len)
1399  				frame_size = max_frame_len;
1400  		}
1401  		len = sizeof(sk_type);
1402  		if (getsockopt(handle-&gt;fd, SOL_SOCKET, SO_TYPE, &amp;sk_type,
1403  		    &amp;len) &lt; 0) {
1404  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1405  			    PCAP_ERRBUF_SIZE, errno, &quot;getsockopt (SO_TYPE)&quot;);
1406  			return PCAP_ERROR;
1407  		}
1408  		maclen = (sk_type == SOCK_DGRAM) ? 0 : MAX_LINKHEADER_SIZE;
1409  		tp_hdrlen = TPACKET_ALIGN(handlep-&gt;tp_hdrlen) + sizeof(struct sockaddr_ll) ;
1410  		netoff = TPACKET_ALIGN(tp_hdrlen + (maclen &lt; 16 ? 16 : maclen)) + tp_reserve;
1411  		macoff = netoff - maclen;
1412  		req.tp_frame_size = TPACKET_ALIGN(macoff + frame_size);
1413  		req.tp_frame_nr = (handle-&gt;opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;
1414  		break;
1415  #ifdef HAVE_TPACKET3
1416  	case TPACKET_V3:
1417  		req.tp_frame_size = MAXIMUM_SNAPLEN;
1418  		req.tp_frame_nr = (handle-&gt;opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;
1419  		break;
1420  #endif
1421  	default:
1422  		snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1423  		    &quot;Internal error: unknown TPACKET_ value %u&quot;,
1424  		    handlep-&gt;tp_version);
1425  		return PCAP_ERROR;
1426  	}
1427  	req.tp_block_size = getpagesize();
1428  	while (req.tp_block_size &lt; req.tp_frame_size)
1429  		req.tp_block_size &lt;&lt;= 1;
1430  	frames_per_block = req.tp_block_size/req.tp_frame_size;
1431  #if defined(HAVE_LINUX_NET_TSTAMP_H) &amp;&amp; defined(PACKET_TIMESTAMP)
1432  	if (handle-&gt;opt.tstamp_type == PCAP_TSTAMP_ADAPTER ||
1433  	    handle-&gt;opt.tstamp_type == PCAP_TSTAMP_ADAPTER_UNSYNCED) {
1434  		struct hwtstamp_config hwconfig;
1435  		struct ifreq ifr;
1436  		int timesource;
1437  		memset(&amp;hwconfig, 0, sizeof(hwconfig));
1438  		hwconfig.tx_type = HWTSTAMP_TX_ON;
1439  		hwconfig.rx_filter = HWTSTAMP_FILTER_ALL;
1440  		memset(&amp;ifr, 0, sizeof(ifr));
1441  		pcap_strlcpy(ifr.ifr_name, handle-&gt;opt.device, sizeof(ifr.ifr_name));
1442  		ifr.ifr_data = (void *)&amp;hwconfig;
1443  		if (ioctl(handle-&gt;fd, SIOCSHWTSTAMP, &amp;ifr) &lt; 0) {
1444  			switch (errno) {
1445  			case EPERM:
1446  				snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1447  				    &quot;Attempt to set hardware timestamp failed - CAP_NET_ADMIN may be required&quot;);
1448  				return PCAP_ERROR_PERM_DENIED;
1449  			case EOPNOTSUPP:
1450  			case ERANGE:
1451  				status = PCAP_WARNING_TSTAMP_TYPE_NOTSUP;
1452  				break;
1453  			default:
1454  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1455  				    PCAP_ERRBUF_SIZE, errno,
1456  				    &quot;SIOCSHWTSTAMP failed&quot;);
1457  				return PCAP_ERROR;
1458  			}
1459  		} else {
1460  			if (handle-&gt;opt.tstamp_type == PCAP_TSTAMP_ADAPTER) {
1461  				timesource = SOF_TIMESTAMPING_SYS_HARDWARE;
1462  			} else {
1463  				timesource = SOF_TIMESTAMPING_RAW_HARDWARE;
1464  			}
1465  			if (setsockopt(handle-&gt;fd, SOL_PACKET, PACKET_TIMESTAMP,
1466  				(void *)&amp;timesource, sizeof(timesource))) {
1467  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1468  				    PCAP_ERRBUF_SIZE, errno,
1469  				    &quot;can&#x27;t set PACKET_TIMESTAMP&quot;);
1470  				return PCAP_ERROR;
1471  			}
1472  		}
1473  	}
1474  #endif &amp;bsol;* HAVE_LINUX_NET_TSTAMP_H &amp;&amp; PACKET_TIMESTAMP */
1475  retry:
1476  	req.tp_block_nr = req.tp_frame_nr / frames_per_block;
1477  	req.tp_frame_nr = req.tp_block_nr * frames_per_block;
1478  #ifdef HAVE_TPACKET3
1479  	if (handlep-&gt;timeout &gt; 0) {
1480  		req.tp_retire_blk_tov = handlep-&gt;timeout;
1481  	} else if (handlep-&gt;timeout == 0) {
1482  		req.tp_retire_blk_tov = UINT_MAX;
1483  	} else {
1484  		req.tp_retire_blk_tov = 0;
1485  	}
1486  	req.tp_sizeof_priv = 0;
1487  	req.tp_feature_req_word = 0;
1488  #endif
1489  	if (setsockopt(handle-&gt;fd, SOL_PACKET, PACKET_RX_RING,
1490  					(void *) &amp;req, sizeof(req))) {
1491  		if ((errno == ENOMEM) &amp;&amp; (req.tp_block_nr &gt; 1)) {
1492  			if (req.tp_frame_nr &lt; 20)
1493  				req.tp_frame_nr -= 1;
1494  			else
1495  				req.tp_frame_nr -= req.tp_frame_nr/20;
1496  			goto retry;
1497  		}
1498  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1499  		    errno, &quot;can&#x27;t create rx ring on packet socket&quot;);
1500  		return PCAP_ERROR;
1501  	}
1502  	handlep-&gt;mmapbuflen = req.tp_block_nr * req.tp_block_size;
1503  #ifdef MAP_32BIT
1504  	if (pcap_mmap_32bit) flags |= MAP_32BIT;
1505  #endif
1506  	handlep-&gt;mmapbuf = mmap(0, handlep-&gt;mmapbuflen, PROT_READ | PROT_WRITE, flags, handle-&gt;fd, 0);
1507  	if (handlep-&gt;mmapbuf == MAP_FAILED) {
1508  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1509  		    errno, &quot;can&#x27;t mmap rx ring&quot;);
1510  		destroy_ring(handle);
1511  		return PCAP_ERROR;
1512  	}
1513  	handle-&gt;cc = req.tp_frame_nr;
1514  	handle-&gt;buffer = malloc(handle-&gt;cc * sizeof(union thdr *));
1515  	if (!handle-&gt;buffer) {
1516  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1517  		    errno, &quot;can&#x27;t allocate ring of frame headers&quot;);
1518  		destroy_ring(handle);
1519  		return PCAP_ERROR;
1520  	}
1521  	handle-&gt;offset = 0;
1522  	for (i=0; i&lt;req.tp_block_nr; ++i) {
1523  		u_char *base = &amp;handlep-&gt;mmapbuf[i*req.tp_block_size];
1524  		for (j=0; j&lt;frames_per_block; ++j, ++handle-&gt;offset) {
1525  			RING_GET_CURRENT_FRAME(handle) = base;
1526  			base += req.tp_frame_size;
1527  		}
1528  	}
1529  	handle-&gt;bufsize = req.tp_frame_size;
1530  	handle-&gt;offset = 0;
1531  	return status;
1532  }
1533  static void
1534  destroy_ring(pcap_t *handle)
1535  {
1536  	struct pcap_linux *handlep = handle-&gt;priv;
1537  	struct tpacket_req req;
1538  	memset(&amp;req, 0, sizeof(req));
1539  	(void)setsockopt(handle-&gt;fd, SOL_PACKET, PACKET_RX_RING,
1540  				(void *) &amp;req, sizeof(req));
1541  	if (handlep-&gt;mmapbuf) {
1542  		(void)munmap(handlep-&gt;mmapbuf, handlep-&gt;mmapbuflen);
1543  		handlep-&gt;mmapbuf = NULL;
1544  	}
1545  }
1546  static void
1547  pcap_oneshot_linux(u_char *user, const struct pcap_pkthdr *h,
1548      const u_char *bytes)
1549  {
1550  	struct oneshot_userdata *sp = (struct oneshot_userdata *)user;
1551  	pcap_t *handle = sp-&gt;pd;
1552  	struct pcap_linux *handlep = handle-&gt;priv;
1553  	*sp-&gt;hdr = *h;
1554  	memcpy(handlep-&gt;oneshot_buffer, bytes, h-&gt;caplen);
1555  	*sp-&gt;pkt = handlep-&gt;oneshot_buffer;
1556  }
1557  static int
1558  pcap_getnonblock_linux(pcap_t *handle)
1559  {
1560  	struct pcap_linux *handlep = handle-&gt;priv;
1561  	return (handlep-&gt;timeout&lt;0);
1562  }
1563  static int
1564  pcap_setnonblock_linux(pcap_t *handle, int nonblock)
1565  {
1566  	struct pcap_linux *handlep = handle-&gt;priv;
1567  	if (pcap_setnonblock_fd(handle, nonblock) == -1)
1568  		return -1;
1569  	if (nonblock) {
1570  		if (handlep-&gt;timeout &gt;= 0) {
1571  			handlep-&gt;timeout = ~handlep-&gt;timeout;
1572  		}
1573  		if (handlep-&gt;poll_breakloop_fd != -1) {
1574  			close(handlep-&gt;poll_breakloop_fd);
1575  			handlep-&gt;poll_breakloop_fd = -1;
1576  		}
1577  	} else {
1578  		if (handlep-&gt;poll_breakloop_fd == -1) {
1579  			if ( ( handlep-&gt;poll_breakloop_fd = eventfd(0, EFD_NONBLOCK) ) == -1 ) {
1580  				int save_errno = errno;
1581  				snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1582  						&quot;Could not open eventfd: %s&quot;,
1583  						strerror(errno));
1584  				errno = save_errno;
1585  				return -1;
1586  			}
1587  		}
1588  		if (handlep-&gt;timeout &lt; 0) {
1589  			handlep-&gt;timeout = ~handlep-&gt;timeout;
1590  		}
1591  	}
1592  	set_poll_timeout(handlep);
1593  	return 0;
1594  }
1595  static inline u_int
1596  pcap_get_ring_frame_status(pcap_t *handle, int offset)
1597  {
1598  	struct pcap_linux *handlep = handle-&gt;priv;
1599  	union thdr h;
1600  	h.raw = RING_GET_FRAME_AT(handle, offset);
1601  	switch (handlep-&gt;tp_version) {
1602  	case TPACKET_V2:
1603  		return __atomic_load_n(&amp;h.h2-&gt;tp_status, __ATOMIC_ACQUIRE);
1604  		break;
1605  #ifdef HAVE_TPACKET3
1606  	case TPACKET_V3:
1607  		return __atomic_load_n(&amp;h.h3-&gt;hdr.bh1.block_status, __ATOMIC_ACQUIRE);
1608  		break;
1609  #endif
1610  	}
1611  	return 0;
1612  }
1613  static int pcap_wait_for_frames_mmap(pcap_t *handle)
1614  {
1615  	struct pcap_linux *handlep = handle-&gt;priv;
1616  	int timeout;
1617  	struct ifreq ifr;
1618  	int ret;
1619  	struct pollfd pollinfo[2];
1620  	int numpollinfo;
1621  	pollinfo[0].fd = handle-&gt;fd;
1622  	pollinfo[0].events = POLLIN;
1623  	if ( handlep-&gt;poll_breakloop_fd == -1 ) {
1624  		numpollinfo = 1;
1625  		pollinfo[1].revents = 0;
1626  	} else {
1627  		pollinfo[1].fd = handlep-&gt;poll_breakloop_fd;
1628  		pollinfo[1].events = POLLIN;
1629  		numpollinfo = 2;
1630  	}
1631  	for (;;) {
1632  		timeout = handlep-&gt;poll_timeout;
1633  		if (handlep-&gt;netdown) {
1634  			if (timeout != 0)
1635  				timeout = 1;
1636  		}
1637  		ret = poll(pollinfo, numpollinfo, timeout);
1638  		if (ret &lt; 0) {
1639  			if (errno != EINTR) {
1640  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1641  				    PCAP_ERRBUF_SIZE, errno,
1642  				    &quot;can&#x27;t poll on packet socket&quot;);
1643  				return PCAP_ERROR;
1644  			}
1645  			if (handle-&gt;break_loop) {
1646  				handle-&gt;break_loop = 0;
1647  				return PCAP_ERROR_BREAK;
1648  			}
1649  		} else if (ret &gt; 0) {
1650  			if (pollinfo[0].revents == POLLIN) {
1651  				break;
1652  			}
1653  			if (pollinfo[0].revents != 0) {
1654  				if (pollinfo[0].revents &amp; POLLNVAL) {
1655  					snprintf(handle-&gt;errbuf,
1656  					    PCAP_ERRBUF_SIZE,
1657  					    &quot;Invalid polling request on packet socket&quot;);
1658  					return PCAP_ERROR;
1659  				}
1660  				if (pollinfo[0].revents &amp; (POLLHUP | POLLRDHUP)) {
1661  					snprintf(handle-&gt;errbuf,
1662  					    PCAP_ERRBUF_SIZE,
1663  					    &quot;Hangup on packet socket&quot;);
1664  					return PCAP_ERROR;
1665  				}
1666  				if (pollinfo[0].revents &amp; POLLERR) {
1667  					int err;
1668  					socklen_t errlen;
1669  					errlen = sizeof(err);
1670  					if (getsockopt(handle-&gt;fd, SOL_SOCKET,
1671  					    SO_ERROR, &amp;err, &amp;errlen) == -1) {
1672  						err = errno;
1673  					}
1674  					if (err == ENETDOWN) {
1675  						handlep-&gt;netdown = 1;
1676  						handle-&gt;required_select_timeout = &amp;netdown_timeout;
1677  					} else if (err == 0) {
1678  						snprintf(handle-&gt;errbuf,
1679  						    PCAP_ERRBUF_SIZE,
1680  						    &quot;Error condition on packet socket: Reported error was 0&quot;);
1681  						return PCAP_ERROR;
1682  					} else {
1683  						pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1684  						    PCAP_ERRBUF_SIZE,
1685  						    err,
1686  						    &quot;Error condition on packet socket&quot;);
1687  						return PCAP_ERROR;
1688  					}
1689  				}
1690  			}
1691  			if (pollinfo[1].revents &amp; POLLIN) {
1692  				ssize_t nread;
1693  				uint64_t value;
1694  				nread = read(handlep-&gt;poll_breakloop_fd, &amp;value,
1695  				    sizeof(value));
1696  				if (nread == -1) {
1697  					pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1698  					    PCAP_ERRBUF_SIZE,
1699  					    errno,
1700  					    &quot;Error reading from event FD&quot;);
1701  					return PCAP_ERROR;
1702  				}
1703  				if (nread != 0 &amp;&amp;
1704  				    (size_t)nread &lt; sizeof(value)) {
1705  					snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1706  					    &quot;Short read from event FD: expected %zu, got %zd&quot;,
1707  					    sizeof(value), nread);
1708  					return PCAP_ERROR;
1709  				}
1710  				if (handle-&gt;break_loop) {
1711  					handle-&gt;break_loop = 0;
1712  					return PCAP_ERROR_BREAK;
1713  				}
1714  			}
1715  		}
1716  		if (handlep-&gt;netdown) {
1717  			if (!device_still_exists(handle)) {
1718  				snprintf(handle-&gt;errbuf,  PCAP_ERRBUF_SIZE,
1719  				    &quot;The interface disappeared&quot;);
1720  				return PCAP_ERROR;
1721  			}
1722  			memset(&amp;ifr, 0, sizeof(ifr));
1723  			pcap_strlcpy(ifr.ifr_name, handlep-&gt;device,
1724  			    sizeof(ifr.ifr_name));
1725  			if (ioctl(handle-&gt;fd, SIOCGIFFLAGS, &amp;ifr) == -1) {
1726  				if (errno == ENXIO || errno == ENODEV) {
1727  					snprintf(handle-&gt;errbuf,
1728  					    PCAP_ERRBUF_SIZE,
1729  					    &quot;The interface disappeared&quot;);
1730  					return PCAP_ERROR;
1731  				} else {
1732  					pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1733  					    PCAP_ERRBUF_SIZE, errno,
1734  					    &quot;%s: Can&#x27;t get flags&quot;,
1735  					    handlep-&gt;device);
1736  					return PCAP_ERROR;
1737  				}
1738  			}
1739  			if (ifr.ifr_flags &amp; IFF_UP) {
1740  				handlep-&gt;netdown = 0;
1741  				handle-&gt;required_select_timeout = NULL;
1742  			}
1743  		}
1744  		if (handlep-&gt;poll_timeout == 0)
1745  			break;
1746  	}
1747  	return 0;
1748  }
1749  static int pcap_handle_packet_mmap(
1750  		pcap_t *handle,
1751  		pcap_handler callback,
1752  		u_char *user,
1753  		unsigned char *frame,
1754  		unsigned int tp_len,
1755  		unsigned int tp_mac,
1756  		unsigned int tp_snaplen,
1757  		unsigned int tp_sec,
1758  		unsigned int tp_usec,
1759  		int tp_vlan_tci_valid,
1760  		__u16 tp_vlan_tci,
1761  		__u16 tp_vlan_tpid)
1762  {
1763  	struct pcap_linux *handlep = handle-&gt;priv;
1764  	unsigned char *bp;
1765  	struct sockaddr_ll *sll;
1766  	struct pcap_pkthdr pcaphdr;
1767  	pcap_can_socketcan_hdr *canhdr;
1768  	unsigned int snaplen = tp_snaplen;
1769  	struct utsname utsname;
1770  	if (tp_mac + tp_snaplen &gt; handle-&gt;bufsize) {
1771  		if (uname(&amp;utsname) != -1) {
1772  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1773  				&quot;corrupted frame on kernel ring mac &quot;
1774  				&quot;offset %u + caplen %u &gt; frame len %d &quot;
1775  				&quot;(kernel %.32s version %s, machine %.16s)&quot;,
1776  				tp_mac, tp_snaplen, handle-&gt;bufsize,
1777  				utsname.release, utsname.version,
1778  				utsname.machine);
1779  		} else {
1780  			snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1781  				&quot;corrupted frame on kernel ring mac &quot;
1782  				&quot;offset %u + caplen %u &gt; frame len %d&quot;,
1783  				tp_mac, tp_snaplen, handle-&gt;bufsize);
1784  		}
1785  		return -1;
1786  	}
1787  	bp = frame + tp_mac;
1788  	sll = (void *)(frame + TPACKET_ALIGN(handlep-&gt;tp_hdrlen));
1789  	if (handlep-&gt;cooked) {
1790  		if (handle-&gt;linktype == DLT_LINUX_SLL2) {
1791  			struct sll2_header *hdrp;
1792  			bp -= SLL2_HDR_LEN;
1793  			if (bp &lt; (u_char *)frame +
1794  					   TPACKET_ALIGN(handlep-&gt;tp_hdrlen) +
1795  					   sizeof(struct sockaddr_ll)) {
1796  				snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1797  					&quot;cooked-mode frame doesn&#x27;t have room for sll header&quot;);
1798  				return -1;
1799  			}
1800  			hdrp = (struct sll2_header *)bp;
1801  			hdrp-&gt;sll2_protocol = sll-&gt;sll_protocol;
1802  			hdrp-&gt;sll2_reserved_mbz = 0;
1803  			hdrp-&gt;sll2_if_index = htonl(sll-&gt;sll_ifindex);
1804  			hdrp-&gt;sll2_hatype = htons(sll-&gt;sll_hatype);
1805  			hdrp-&gt;sll2_pkttype = sll-&gt;sll_pkttype;
1806  			hdrp-&gt;sll2_halen = sll-&gt;sll_halen;
1807  			memcpy(hdrp-&gt;sll2_addr, sll-&gt;sll_addr, SLL_ADDRLEN);
1808  			snaplen += sizeof(struct sll2_header);
1809  		} else {
1810  			struct sll_header *hdrp;
1811  			bp -= SLL_HDR_LEN;
1812  			if (bp &lt; (u_char *)frame +
1813  					   TPACKET_ALIGN(handlep-&gt;tp_hdrlen) +
1814  					   sizeof(struct sockaddr_ll)) {
1815  				snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
1816  					&quot;cooked-mode frame doesn&#x27;t have room for sll header&quot;);
1817  				return -1;
1818  			}
1819  			hdrp = (struct sll_header *)bp;
1820  			hdrp-&gt;sll_pkttype = htons(sll-&gt;sll_pkttype);
1821  			hdrp-&gt;sll_hatype = htons(sll-&gt;sll_hatype);
1822  			hdrp-&gt;sll_halen = htons(sll-&gt;sll_halen);
1823  			memcpy(hdrp-&gt;sll_addr, sll-&gt;sll_addr, SLL_ADDRLEN);
1824  			hdrp-&gt;sll_protocol = sll-&gt;sll_protocol;
1825  			snaplen += sizeof(struct sll_header);
1826  		}
1827  	} else {
1828  		if (sll-&gt;sll_hatype == ARPHRD_CAN) {
1829  			canhdr = (pcap_can_socketcan_hdr *)bp;
1830  			canhdr-&gt;can_id = htonl(canhdr-&gt;can_id);
1831  			uint16_t protocol = ntohs(sll-&gt;sll_protocol);
1832  			if (protocol == LINUX_SLL_P_CANFD) {
1833  				canhdr-&gt;fd_flags |= CANFD_FDF;
1834  				canhdr-&gt;fd_flags &amp;= ~(CANFD_FDF|CANFD_ESI|CANFD_BRS);
1835  				canhdr-&gt;reserved1 = 0;
1836  				canhdr-&gt;reserved2 = 0;
1837  			} else {
1838  				canhdr-&gt;fd_flags &amp;= ~CANFD_FDF;
1839  			}
1840  		}
1841  	}
1842  	if (handlep-&gt;filter_in_userland &amp;&amp; handle-&gt;fcode.bf_insns) {
1843  		struct pcap_bpf_aux_data aux_data;
1844  		aux_data.vlan_tag_present = tp_vlan_tci_valid;
1845  		aux_data.vlan_tag = tp_vlan_tci &amp; 0x0fff;
1846  		if (pcap_filter_with_aux_data(handle-&gt;fcode.bf_insns,
1847  					      bp,
1848  					      tp_len,
1849  					      snaplen,
1850  					      &amp;aux_data) == 0)
1851  			return 0;
1852  	}
1853  	if (!linux_check_direction(handle, sll))
1854  		return 0;
1855  	pcaphdr.ts.tv_sec = tp_sec;
1856  	pcaphdr.ts.tv_usec = tp_usec;
1857  	pcaphdr.caplen = tp_snaplen;
1858  	pcaphdr.len = tp_len;
1859  	if (handlep-&gt;cooked) {
1860  		if (handle-&gt;linktype == DLT_LINUX_SLL2) {
1861  			pcaphdr.caplen += SLL2_HDR_LEN;
1862  			pcaphdr.len += SLL2_HDR_LEN;
1863  		} else {
1864  			pcaphdr.caplen += SLL_HDR_LEN;
1865  			pcaphdr.len += SLL_HDR_LEN;
1866  		}
1867  	}
1868  	if (tp_vlan_tci_valid &amp;&amp;
1869  		handlep-&gt;vlan_offset != -1 &amp;&amp;
1870  		tp_snaplen &gt;= (unsigned int) handlep-&gt;vlan_offset)
1871  	{
1872  		struct vlan_tag *tag;
1873  		bp -= VLAN_TAG_LEN;
1874  		memmove(bp, bp + VLAN_TAG_LEN, handlep-&gt;vlan_offset);
1875  		tag = (struct vlan_tag *)(bp + handlep-&gt;vlan_offset);
1876  		tag-&gt;vlan_tpid = htons(tp_vlan_tpid);
1877  		tag-&gt;vlan_tci = htons(tp_vlan_tci);
1878  		pcaphdr.caplen += VLAN_TAG_LEN;
1879  		pcaphdr.len += VLAN_TAG_LEN;
1880  	}
1881  	if (pcaphdr.caplen &gt; (bpf_u_int32)handle-&gt;snapshot)
1882  		pcaphdr.caplen = handle-&gt;snapshot;
1883  	callback(user, &amp;pcaphdr, bp);
1884  	return 1;
1885  }
1886  static int
1887  pcap_read_linux_mmap_v2(pcap_t *handle, int max_packets, pcap_handler callback,
1888  		u_char *user)
1889  {
1890  	struct pcap_linux *handlep = handle-&gt;priv;
1891  	union thdr h;
1892  	int pkts = 0;
1893  	int ret;
1894  	h.raw = RING_GET_CURRENT_FRAME(handle);
1895  	if (!packet_mmap_acquire(h.h2)) {
1896  		ret = pcap_wait_for_frames_mmap(handle);
1897  		if (ret) {
1898  			return ret;
1899  		}
1900  	}
1901  	if (PACKET_COUNT_IS_UNLIMITED(max_packets))
1902  		max_packets = INT_MAX;
1903  	while (pkts &lt; max_packets) {
1904  		h.raw = RING_GET_CURRENT_FRAME(handle);
1905  		if (!packet_mmap_acquire(h.h2))
1906  			break;
1907  		ret = pcap_handle_packet_mmap(
1908  				handle,
1909  				callback,
1910  				user,
1911  				h.raw,
1912  				h.h2-&gt;tp_len,
1913  				h.h2-&gt;tp_mac,
1914  				h.h2-&gt;tp_snaplen,
1915  				h.h2-&gt;tp_sec,
1916  				handle-&gt;opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? h.h2-&gt;tp_nsec : h.h2-&gt;tp_nsec / 1000,
1917  				VLAN_VALID(h.h2, h.h2),
1918  				h.h2-&gt;tp_vlan_tci,
1919  				VLAN_TPID(h.h2, h.h2));
1920  		if (ret == 1) {
1921  			pkts++;
1922  		} else if (ret &lt; 0) {
1923  			return ret;
1924  		}
1925  		packet_mmap_release(h.h2);
1926  		if (handlep-&gt;blocks_to_filter_in_userland &gt; 0) {
1927  			handlep-&gt;blocks_to_filter_in_userland--;
1928  			if (handlep-&gt;blocks_to_filter_in_userland == 0) {
1929  				handlep-&gt;filter_in_userland = 0;
1930  			}
1931  		}
1932  		if (++handle-&gt;offset &gt;= handle-&gt;cc)
1933  			handle-&gt;offset = 0;
1934  		if (handle-&gt;break_loop) {
1935  			handle-&gt;break_loop = 0;
1936  			return PCAP_ERROR_BREAK;
1937  		}
1938  	}
1939  	return pkts;
1940  }
1941  #ifdef HAVE_TPACKET3
1942  static int
1943  pcap_read_linux_mmap_v3(pcap_t *handle, int max_packets, pcap_handler callback,
1944  		u_char *user)
1945  {
1946  	struct pcap_linux *handlep = handle-&gt;priv;
1947  	union thdr h;
1948  	int pkts = 0;
1949  	int ret;
1950  again:
1951  	if (handlep-&gt;current_packet == NULL) {
1952  		h.raw = RING_GET_CURRENT_FRAME(handle);
1953  		if (!packet_mmap_v3_acquire(h.h3)) {
1954  			ret = pcap_wait_for_frames_mmap(handle);
1955  			if (ret) {
1956  				return ret;
1957  			}
1958  		}
1959  	}
1960  	h.raw = RING_GET_CURRENT_FRAME(handle);
1961  	if (!packet_mmap_v3_acquire(h.h3)) {
1962  		if (pkts == 0 &amp;&amp; handlep-&gt;timeout == 0) {
1963  			goto again;
1964  		}
1965  		return pkts;
1966  	}
1967  	if (PACKET_COUNT_IS_UNLIMITED(max_packets))
1968  		max_packets = INT_MAX;
1969  	while (pkts &lt; max_packets) {
1970  		int packets_to_read;
1971  		if (handlep-&gt;current_packet == NULL) {
1972  			h.raw = RING_GET_CURRENT_FRAME(handle);
1973  			if (!packet_mmap_v3_acquire(h.h3))
1974  				break;
1975  			handlep-&gt;current_packet = h.raw + h.h3-&gt;hdr.bh1.offset_to_first_pkt;
1976  			handlep-&gt;packets_left = h.h3-&gt;hdr.bh1.num_pkts;
1977  		}
1978  		packets_to_read = handlep-&gt;packets_left;
1979  		if (packets_to_read &gt; (max_packets - pkts)) {
1980  			packets_to_read = max_packets - pkts;
1981  		}
1982  		while (packets_to_read-- &amp;&amp; !handle-&gt;break_loop) {
1983  			struct tpacket3_hdr* tp3_hdr = (struct tpacket3_hdr*) handlep-&gt;current_packet;
1984  			ret = pcap_handle_packet_mmap(
1985  					handle,
1986  					callback,
1987  					user,
1988  					handlep-&gt;current_packet,
1989  					tp3_hdr-&gt;tp_len,
1990  					tp3_hdr-&gt;tp_mac,
1991  					tp3_hdr-&gt;tp_snaplen,
1992  					tp3_hdr-&gt;tp_sec,
1993  					handle-&gt;opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? tp3_hdr-&gt;tp_nsec : tp3_hdr-&gt;tp_nsec / 1000,
1994  					VLAN_VALID(tp3_hdr, &amp;tp3_hdr-&gt;hv1),
1995  					tp3_hdr-&gt;hv1.tp_vlan_tci,
1996  					VLAN_TPID(tp3_hdr, &amp;tp3_hdr-&gt;hv1));
1997  			if (ret == 1) {
1998  				pkts++;
1999  			} else if (ret &lt; 0) {
2000  				handlep-&gt;current_packet = NULL;
2001  				return ret;
2002  			}
2003  			handlep-&gt;current_packet += tp3_hdr-&gt;tp_next_offset;
2004  			handlep-&gt;packets_left--;
2005  		}
2006  		if (handlep-&gt;packets_left &lt;= 0) {
2007  			packet_mmap_v3_release(h.h3);
2008  			if (handlep-&gt;blocks_to_filter_in_userland &gt; 0) {
2009  				handlep-&gt;blocks_to_filter_in_userland--;
2010  				if (handlep-&gt;blocks_to_filter_in_userland == 0) {
2011  					handlep-&gt;filter_in_userland = 0;
2012  				}
2013  			}
2014  			if (++handle-&gt;offset &gt;= handle-&gt;cc)
2015  				handle-&gt;offset = 0;
2016  			handlep-&gt;current_packet = NULL;
2017  		}
2018  		if (handle-&gt;break_loop) {
2019  			handle-&gt;break_loop = 0;
2020  			return PCAP_ERROR_BREAK;
2021  		}
2022  	}
2023  	if (pkts == 0 &amp;&amp; handlep-&gt;timeout == 0) {
2024  		goto again;
2025  	}
2026  	return pkts;
2027  }
2028  #endif &amp;bsol;* HAVE_TPACKET3 */
2029  static int
2030  pcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)
2031  {
2032  	struct pcap_linux *handlep;
2033  	struct sock_fprog	fcode;
2034  	int			can_filter_in_kernel;
2035  	int			err = 0;
2036  	int			n, offset;
2037  	if (!handle)
2038  		return -1;
2039  	if (!filter) {
2040  	        pcap_strlcpy(handle-&gt;errbuf, &quot;setfilter: No filter specified&quot;,
2041  			PCAP_ERRBUF_SIZE);
2042  		return -1;
2043  	}
2044  	handlep = handle-&gt;priv;
2045  	if (pcap_install_bpf_program(handle, filter) &lt; 0)
2046  		return -1;
2047  	handlep-&gt;filter_in_userland = 1;
2048  #ifdef USHRT_MAX
2049  	if (handle-&gt;fcode.bf_len &gt; USHRT_MAX) {
2050  		fprintf(stderr, &quot;Warning: Filter too complex for kernel\n&quot;);
2051  		fcode.len = 0;
2052  		fcode.filter = NULL;
2053  		can_filter_in_kernel = 0;
2054  	} else
2055  #endif &amp;bsol;* USHRT_MAX */
2056  	{
2057  		switch (fix_program(handle, &amp;fcode)) {
2058  		case -1:
2059  		default:
2060  			return -1;
2061  		case 0:
2062  			can_filter_in_kernel = 0;
2063  			break;
2064  		case 1:
2065  			can_filter_in_kernel = 1;
2066  			break;
2067  		}
2068  	}
2069  	if (can_filter_in_kernel) {
2070  		if ((err = set_kernel_filter(handle, &amp;fcode)) == 0)
2071  		{
2072  			handlep-&gt;filter_in_userland = 0;
2073  		}
2074  		else if (err == -1)	&amp;bsol;* Non-fatal error */
2075  		{
2076  			if (errno == ENOMEM) {
2077  				fprintf(stderr,
2078  				    &quot;Warning: Couldn&#x27;t allocate kernel memory for filter: try increasing net.core.optmem_max with sysctl\n&quot;);
2079  			} else if (errno != ENOPROTOOPT &amp;&amp; errno != EOPNOTSUPP) {
2080  				fprintf(stderr,
2081  				    &quot;Warning: Kernel filter failed: %s\n&quot;,
2082  					pcap_strerror(errno));
2083  			}
2084  		}
2085  	}
2086  	if (handlep-&gt;filter_in_userland) {
2087  		if (reset_kernel_filter(handle) == -1) {
2088  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2089  			    PCAP_ERRBUF_SIZE, errno,
2090  			    &quot;can&#x27;t remove kernel filter&quot;);
2091  			err = -2;	&amp;bsol;* fatal error */
2092  		}
2093  	}
2094  	if (fcode.filter != NULL)
2095  		free(fcode.filter);
2096  	if (err == -2)
2097  		return -1;
2098  	if (handlep-&gt;filter_in_userland)
2099  		return 0;
2100  	offset = handle-&gt;offset;
2101  	if (--offset &lt; 0)
2102  		offset = handle-&gt;cc - 1;
2103  	for (n=0; n &lt; handle-&gt;cc; ++n) {
2104  		if (--offset &lt; 0)
2105  			offset = handle-&gt;cc - 1;
2106  		if (pcap_get_ring_frame_status(handle, offset) != TP_STATUS_KERNEL)
2107  			break;
2108  	}
2109  	if (n != 0)
2110  		n--;
2111  	handlep-&gt;blocks_to_filter_in_userland = handle-&gt;cc - n;
2112  	handlep-&gt;filter_in_userland = 1;
2113  	return 0;
2114  }
2115  static int
2116  iface_get_id(int fd, const char *device, char *ebuf)
2117  {
2118  	struct ifreq	ifr;
2119  	memset(&amp;ifr, 0, sizeof(ifr));
2120  	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
2121  	if (ioctl(fd, SIOCGIFINDEX, &amp;ifr) == -1) {
2122  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2123  		    errno, &quot;SIOCGIFINDEX&quot;);
2124  		return -1;
2125  	}
2126  	return ifr.ifr_ifindex;
2127  }
2128  static int
2129  iface_bind(int fd, int ifindex, char *ebuf, int protocol)
2130  {
2131  	struct sockaddr_ll	sll;
2132  	int			ret, err;
2133  	socklen_t		errlen = sizeof(err);
2134  	memset(&amp;sll, 0, sizeof(sll));
2135  	sll.sll_family		= AF_PACKET;
2136  	sll.sll_ifindex		= ifindex &lt; 0 ? 0 : ifindex;
2137  	sll.sll_protocol	= protocol;
2138  	if (bind(fd, (struct sockaddr *) &amp;sll, sizeof(sll)) == -1) {
2139  		if (errno == ENETDOWN) {
2140  			return PCAP_ERROR_IFACE_NOT_UP;
2141  		}
2142  		if (errno == ENODEV) {
2143  			ebuf[0] = &#x27;\0&#x27;;
2144  			ret = PCAP_ERROR_NO_SUCH_DEVICE;
2145  		} else {
2146  			ret = PCAP_ERROR;
2147  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2148  			    errno, &quot;bind&quot;);
2149  		}
2150  		return ret;
2151  	}
2152  	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;errlen) == -1) {
2153  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2154  		    errno, &quot;getsockopt (SO_ERROR)&quot;);
2155  		return PCAP_ERROR;
2156  	}
2157  	if (err == ENETDOWN) {
2158  		return PCAP_ERROR_IFACE_NOT_UP;
2159  	} else if (err &gt; 0) {
2160  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2161  		    err, &quot;bind&quot;);
2162  		return PCAP_ERROR;
2163  	}
2164  	return 0;
2165  }
2166  #ifdef HAVE_LIBNL
2167  static int
2168  enter_rfmon_mode(pcap_t *handle, int sock_fd, const char *device)
2169  {
2170  	struct pcap_linux *handlep = handle-&gt;priv;
2171  	int ret;
2172  	char phydev_path[PATH_MAX+1];
2173  	struct nl80211_state nlstate;
2174  	struct ifreq ifr;
2175  	u_int n;
2176  	ret = get_mac80211_phydev(handle, device, phydev_path, PATH_MAX);
2177  	if (ret &lt; 0)
2178  		return ret;	&amp;bsol;* error */
2179  	if (ret == 0)
2180  		return 0;	&amp;bsol;* no error, but not mac80211 device */
2181  	ret = nl80211_init(handle, &amp;nlstate, device);
2182  	if (ret != 0)
2183  		return ret;
2184  	for (n = 0; n &lt; UINT_MAX; n++) {
2185  		char mondevice[3+10+1];	&amp;bsol;* mon{UINT_MAX}\0 */
2186  		snprintf(mondevice, sizeof mondevice, &quot;mon%u&quot;, n);
2187  		ret = add_mon_if(handle, sock_fd, &amp;nlstate, device, mondevice);
2188  		if (ret == 1) {
2189  			goto added;
2190  		}
2191  		if (ret &lt; 0) {
2192  			nl80211_cleanup(&amp;nlstate);
2193  			return ret;
2194  		}
2195  	}
2196  	snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2197  	    &quot;%s: No free monN interfaces&quot;, device);
2198  	nl80211_cleanup(&amp;nlstate);
2199  	return PCAP_ERROR;
2200  added:
2201  #if 0
2202  	delay.tv_sec = 0;
2203  	delay.tv_nsec = 500000000;
2204  	nanosleep(&amp;delay, NULL);
2205  #endif
2206  	if (!pcap_do_addexit(handle)) {
2207  		del_mon_if(handle, sock_fd, &amp;nlstate, device,
2208  		    handlep-&gt;mondevice);
2209  		nl80211_cleanup(&amp;nlstate);
2210  		return PCAP_ERROR;
2211  	}
2212  	memset(&amp;ifr, 0, sizeof(ifr));
2213  	pcap_strlcpy(ifr.ifr_name, handlep-&gt;mondevice, sizeof(ifr.ifr_name));
2214  	if (ioctl(sock_fd, SIOCGIFFLAGS, &amp;ifr) == -1) {
2215  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2216  		    errno, &quot;%s: Can&#x27;t get flags for %s&quot;, device,
2217  		    handlep-&gt;mondevice);
2218  		del_mon_if(handle, sock_fd, &amp;nlstate, device,
2219  		    handlep-&gt;mondevice);
2220  		nl80211_cleanup(&amp;nlstate);
2221  		return PCAP_ERROR;
2222  	}
2223  	ifr.ifr_flags |= IFF_UP|IFF_RUNNING;
2224  	if (ioctl(sock_fd, SIOCSIFFLAGS, &amp;ifr) == -1) {
2225  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2226  		    errno, &quot;%s: Can&#x27;t set flags for %s&quot;, device,
2227  		    handlep-&gt;mondevice);
2228  		del_mon_if(handle, sock_fd, &amp;nlstate, device,
2229  		    handlep-&gt;mondevice);
2230  		nl80211_cleanup(&amp;nlstate);
2231  		return PCAP_ERROR;
2232  	}
2233  	nl80211_cleanup(&amp;nlstate);
2234  	handlep-&gt;must_do_on_close |= MUST_DELETE_MONIF;
2235  	pcap_add_to_pcaps_to_close(handle);
2236  	return 1;
2237  }
2238  #else &amp;bsol;* HAVE_LIBNL */
2239  static int
2240  enter_rfmon_mode(pcap_t *handle _U_, int sock_fd _U_, const char *device _U_)
2241  {
2242  	return 0;
2243  }
2244  #endif &amp;bsol;* HAVE_LIBNL */
2245  #if defined(HAVE_LINUX_NET_TSTAMP_H) &amp;&amp; defined(PACKET_TIMESTAMP)
2246  static const struct {
2247  	int soft_timestamping_val;
2248  	int pcap_tstamp_val;
2249  } sof_ts_type_map[3] = {
2250  	{ SOF_TIMESTAMPING_SOFTWARE, PCAP_TSTAMP_HOST },
2251  	{ SOF_TIMESTAMPING_SYS_HARDWARE, PCAP_TSTAMP_ADAPTER },
2252  	{ SOF_TIMESTAMPING_RAW_HARDWARE, PCAP_TSTAMP_ADAPTER_UNSYNCED }
2253  };
2254  #define NUM_SOF_TIMESTAMPING_TYPES	(sizeof sof_ts_type_map / sizeof sof_ts_type_map[0])
2255  static int
2256  iface_set_all_ts_types(pcap_t *handle, char *ebuf)
2257  {
2258  	u_int i;
2259  	handle-&gt;tstamp_type_list = malloc(NUM_SOF_TIMESTAMPING_TYPES * sizeof(u_int));
2260  	if (handle-&gt;tstamp_type_list == NULL) {
2261  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2262  		    errno, &quot;malloc&quot;);
2263  		return -1;
2264  	}
2265  	for (i = 0; i &lt; NUM_SOF_TIMESTAMPING_TYPES; i++)
2266  		handle-&gt;tstamp_type_list[i] = sof_ts_type_map[i].pcap_tstamp_val;
2267  	handle-&gt;tstamp_type_count = NUM_SOF_TIMESTAMPING_TYPES;
2268  	return 0;
2269  }
2270  #ifdef ETHTOOL_GET_TS_INFO
2271  static int
2272  iface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)
2273  {
2274  	int fd;
2275  	struct ifreq ifr;
2276  	struct ethtool_ts_info info;
2277  	int num_ts_types;
2278  	u_int i, j;
2279  	if (strcmp(device, &quot;any&quot;) == 0) {
2280  		handle-&gt;tstamp_type_list = NULL;
2281  		return 0;
2282  	}
2283  	fd = get_if_ioctl_socket();
2284  	if (fd &lt; 0) {
2285  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2286  		    errno, &quot;socket for SIOCETHTOOL(ETHTOOL_GET_TS_INFO)&quot;);
2287  		return -1;
2288  	}
2289  	memset(&amp;ifr, 0, sizeof(ifr));
2290  	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
2291  	memset(&amp;info, 0, sizeof(info));
2292  	info.cmd = ETHTOOL_GET_TS_INFO;
2293  	ifr.ifr_data = (caddr_t)&amp;info;
2294  	if (ioctl(fd, SIOCETHTOOL, &amp;ifr) == -1) {
2295  		int save_errno = errno;
2296  		close(fd);
2297  		switch (save_errno) {
2298  		case EOPNOTSUPP:
2299  		case EINVAL:
2300  			if (iface_set_all_ts_types(handle, ebuf) == -1)
2301  				return -1;
2302  			return 0;
2303  		case ENODEV:
2304  			handle-&gt;tstamp_type_list = NULL;
2305  			return 0;
2306  		default:
2307  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2308  			    save_errno,
2309  			    &quot;%s: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed&quot;,
2310  			    device);
2311  			return -1;
2312  		}
2313  	}
2314  	close(fd);
2315  	if (!(info.rx_filters &amp; (1 &lt;&lt; HWTSTAMP_FILTER_ALL))) {
2316  		handle-&gt;tstamp_type_list = NULL;
2317  		return 0;
2318  	}
2319  	num_ts_types = 0;
2320  	for (i = 0; i &lt; NUM_SOF_TIMESTAMPING_TYPES; i++) {
2321  		if (info.so_timestamping &amp; sof_ts_type_map[i].soft_timestamping_val)
2322  			num_ts_types++;
2323  	}
2324  	if (num_ts_types != 0) {
2325  		handle-&gt;tstamp_type_list = malloc(num_ts_types * sizeof(u_int));
2326  		if (handle-&gt;tstamp_type_list == NULL) {
2327  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2328  			    errno, &quot;malloc&quot;);
2329  			return -1;
2330  		}
2331  		for (i = 0, j = 0; i &lt; NUM_SOF_TIMESTAMPING_TYPES; i++) {
2332  			if (info.so_timestamping &amp; sof_ts_type_map[i].soft_timestamping_val) {
2333  				handle-&gt;tstamp_type_list[j] = sof_ts_type_map[i].pcap_tstamp_val;
2334  				j++;
2335  			}
2336  		}
2337  		handle-&gt;tstamp_type_count = num_ts_types;
2338  	} else
2339  		handle-&gt;tstamp_type_list = NULL;
2340  	return 0;
2341  }
2342  #else &amp;bsol;* ETHTOOL_GET_TS_INFO */
2343  static int
2344  iface_get_ts_types(const char *device, pcap_t *handle, char *ebuf)
2345  {
2346  	if (strcmp(device, &quot;any&quot;) == 0) {
2347  		handle-&gt;tstamp_type_list = NULL;
2348  		return 0;
2349  	}
2350  	if (iface_set_all_ts_types(handle, ebuf) == -1)
2351  		return -1;
2352  	return 0;
2353  }
2354  #endif &amp;bsol;* ETHTOOL_GET_TS_INFO */
2355  #else  &amp;bsol;* defined(HAVE_LINUX_NET_TSTAMP_H) &amp;&amp; defined(PACKET_TIMESTAMP) */
2356  static int
2357  iface_get_ts_types(const char *device _U_, pcap_t *p _U_, char *ebuf _U_)
2358  {
2359  	return 0;
2360  }
2361  #endif &amp;bsol;* defined(HAVE_LINUX_NET_TSTAMP_H) &amp;&amp; defined(PACKET_TIMESTAMP) */
2362  #if defined(SIOCETHTOOL) &amp;&amp; (defined(ETHTOOL_GTSO) || defined(ETHTOOL_GUFO) || defined(ETHTOOL_GGSO) || defined(ETHTOOL_GFLAGS) || defined(ETHTOOL_GGRO))
2363  static int
2364  iface_ethtool_flag_ioctl(pcap_t *handle, int cmd, const char *cmdname,
2365      int eperm_ok)
2366  {
2367  	struct ifreq	ifr;
2368  	struct ethtool_value eval;
2369  	memset(&amp;ifr, 0, sizeof(ifr));
2370  	pcap_strlcpy(ifr.ifr_name, handle-&gt;opt.device, sizeof(ifr.ifr_name));
2371  	eval.cmd = cmd;
2372  	eval.data = 0;
2373  	ifr.ifr_data = (caddr_t)&amp;eval;
2374  	if (ioctl(handle-&gt;fd, SIOCETHTOOL, &amp;ifr) == -1) {
2375  		if (errno == EOPNOTSUPP || errno == EINVAL ||
2376  		    (errno == EPERM &amp;&amp; eperm_ok)) {
2377  			return 0;
2378  		}
2379  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2380  		    errno, &quot;%s: SIOCETHTOOL(%s) ioctl failed&quot;,
2381  		    handle-&gt;opt.device, cmdname);
2382  		return -1;
2383  	}
2384  	return eval.data;
2385  }
2386  static int
2387  iface_get_offload(pcap_t *handle)
2388  {
2389  	int ret;
2390  #ifdef ETHTOOL_GTSO
2391  	ret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GTSO, &quot;ETHTOOL_GTSO&quot;, 0);
2392  	if (ret == -1)
2393  		return -1;
2394  	if (ret)
2395  		return 1;	&amp;bsol;* TCP segmentation offloading on */
2396  #endif
2397  #ifdef ETHTOOL_GGSO
2398  	ret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGSO, &quot;ETHTOOL_GGSO&quot;, 0);
2399  	if (ret == -1)
2400  		return -1;
2401  	if (ret)
2402  		return 1;	&amp;bsol;* generic segmentation offloading on */
2403  #endif
2404  #ifdef ETHTOOL_GFLAGS
2405  	ret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GFLAGS, &quot;ETHTOOL_GFLAGS&quot;, 0);
2406  	if (ret == -1)
2407  		return -1;
2408  	if (ret &amp; ETH_FLAG_LRO)
2409  		return 1;	&amp;bsol;* large receive offloading on */
2410  #endif
2411  #ifdef ETHTOOL_GGRO
2412  	ret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGRO, &quot;ETHTOOL_GGRO&quot;, 0);
2413  	if (ret == -1)
2414  		return -1;
2415  	if (ret)
2416  		return 1;	&amp;bsol;* generic (large) receive offloading on */
2417  #endif
2418  #ifdef ETHTOOL_GUFO
2419  	ret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GUFO, &quot;ETHTOOL_GUFO&quot;, 1);
2420  	if (ret == -1)
2421  		return -1;
2422  	if (ret)
2423  		return 1;	&amp;bsol;* UDP fragmentation offloading on */
2424  #endif
2425  	return 0;
2426  }
2427  #else &amp;bsol;* SIOCETHTOOL */
2428  static int
2429  iface_get_offload(pcap_t *handle _U_)
2430  {
2431  	return 0;
2432  }
2433  #endif &amp;bsol;* SIOCETHTOOL */
2434  static struct dsa_proto {
2435  	const char *name;
2436  	bpf_u_int32 linktype;
2437  } dsa_protos[] = {
2438  	{ &quot;none&quot;, DLT_EN10MB },
2439  	{ &quot;brcm&quot;, DLT_DSA_TAG_BRCM },
2440  	{ &quot;brcm-prepend&quot;, DLT_DSA_TAG_BRCM_PREPEND },
2441  	{ &quot;dsa&quot;, DLT_DSA_TAG_DSA },
2442  	{ &quot;edsa&quot;, DLT_DSA_TAG_EDSA },
2443  };
2444  static int
2445  iface_dsa_get_proto_info(const char *device, pcap_t *handle)
2446  {
2447  	char *pathstr;
2448  	unsigned int i;
2449  	char buf[128];
2450  	ssize_t r;
2451  	int fd;
2452  	fd = asprintf(&amp;pathstr, &quot;/sys/class/net/%s/dsa/tagging&quot;, device);
2453  	if (fd &lt; 0) {
2454  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2455  					  fd, &quot;asprintf&quot;);
2456  		return PCAP_ERROR;
2457  	}
2458  	fd = open(pathstr, O_RDONLY);
2459  	free(pathstr);
2460  	if (fd &lt; 0)
2461  		return 0;
2462  	r = read(fd, buf, sizeof(buf) - 1);
2463  	if (r &lt;= 0) {
2464  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2465  					  errno, &quot;read&quot;);
2466  		close(fd);
2467  		return PCAP_ERROR;
2468  	}
2469  	close(fd);
2470  	if (buf[r - 1] == &#x27;\n&#x27;)
2471  		r--;
2472  	buf[r] = &#x27;\0&#x27;;
2473  	for (i = 0; i &lt; sizeof(dsa_protos) / sizeof(dsa_protos[0]); i++) {
2474  		if (strlen(dsa_protos[i].name) == (size_t)r &amp;&amp;
2475  		    strcmp(buf, dsa_protos[i].name) == 0) {
2476  			handle-&gt;linktype = dsa_protos[i].linktype;
2477  			switch (dsa_protos[i].linktype) {
2478  			case DLT_EN10MB:
2479  				return 0;
2480  			default:
2481  				return 1;
2482  			}
2483  		}
2484  	}
2485  	snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2486  		      &quot;unsupported DSA tag: %s&quot;, buf);
2487  	return PCAP_ERROR;
2488  }
2489  static int
2490  iface_get_mtu(int fd, const char *device, char *ebuf)
2491  {
2492  	struct ifreq	ifr;
2493  	if (!device)
2494  		return BIGGER_THAN_ALL_MTUS;
2495  	memset(&amp;ifr, 0, sizeof(ifr));
2496  	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
2497  	if (ioctl(fd, SIOCGIFMTU, &amp;ifr) == -1) {
2498  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2499  		    errno, &quot;SIOCGIFMTU&quot;);
2500  		return -1;
2501  	}
2502  	return ifr.ifr_mtu;
2503  }
2504  static int
2505  iface_get_arptype(int fd, const char *device, char *ebuf)
2506  {
2507  	struct ifreq	ifr;
2508  	int		ret;
2509  	memset(&amp;ifr, 0, sizeof(ifr));
2510  	pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
2511  	if (ioctl(fd, SIOCGIFHWADDR, &amp;ifr) == -1) {
2512  		if (errno == ENODEV) {
2513  			ret = PCAP_ERROR_NO_SUCH_DEVICE;
2514  			ebuf[0] = &#x27;\0&#x27;;
2515  		} else {
2516  			ret = PCAP_ERROR;
2517  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
2518  			    errno, &quot;SIOCGIFHWADDR&quot;);
2519  		}
2520  		return ret;
2521  	}
2522  	return ifr.ifr_hwaddr.sa_family;
2523  }
2524  static int
2525  fix_program(pcap_t *handle, struct sock_fprog *fcode)
2526  {
2527  	struct pcap_linux *handlep = handle-&gt;priv;
2528  	size_t prog_size;
2529  	register int i;
2530  	register struct bpf_insn *p;
2531  	struct bpf_insn *f;
2532  	int len;
2533  	prog_size = sizeof(*handle-&gt;fcode.bf_insns) * handle-&gt;fcode.bf_len;
2534  	len = handle-&gt;fcode.bf_len;
2535  	f = (struct bpf_insn *)malloc(prog_size);
2536  	if (f == NULL) {
2537  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
2538  		    errno, &quot;malloc&quot;);
2539  		return -1;
2540  	}
2541  	memcpy(f, handle-&gt;fcode.bf_insns, prog_size);
2542  	fcode-&gt;len = len;
2543  	fcode-&gt;filter = (struct sock_filter *) f;
2544  	for (i = 0; i &lt; len; ++i) {
2545  		p = &amp;f[i];
2546  		switch (BPF_CLASS(p-&gt;code)) {
2547  		case BPF_LD:
2548  		case BPF_LDX:
2549  			switch (BPF_MODE(p-&gt;code)) {
2550  			case BPF_ABS:
2551  			case BPF_IND:
2552  			case BPF_MSH:
2553  				if (handlep-&gt;cooked) {
2554  					if (fix_offset(handle, p) &lt; 0) {
2555  						return 0;
2556  					}
2557  				}
2558  				break;
2559  			}
2560  			break;
2561  		}
2562  	}
2563  	return 1;	&amp;bsol;* we succeeded */
2564  }
2565  static int
2566  fix_offset(pcap_t *handle, struct bpf_insn *p)
2567  {
2568  	if (p-&gt;k &gt;= (bpf_u_int32)SKF_AD_OFF)
2569  		return 0;
2570  	if (handle-&gt;linktype == DLT_LINUX_SLL2) {
2571  		if (p-&gt;k &gt;= SLL2_HDR_LEN) {
2572  			p-&gt;k -= SLL2_HDR_LEN;
2573  		} else if (p-&gt;k == 0) {
2574  			p-&gt;k = SKF_AD_OFF + SKF_AD_PROTOCOL;
2575  		} else if (p-&gt;k == 4) {
2576  			p-&gt;k = SKF_AD_OFF + SKF_AD_IFINDEX;
2577  		} else if (p-&gt;k == 10) {
2578  			p-&gt;k = SKF_AD_OFF + SKF_AD_PKTTYPE;
2579  		} else if ((bpf_int32)(p-&gt;k) &gt; 0) {
2580  			return -1;
2581  		}
2582  	} else {
2583  		if (p-&gt;k &gt;= SLL_HDR_LEN) {
2584  			p-&gt;k -= SLL_HDR_LEN;
2585  		} else if (p-&gt;k == 0) {
2586  			p-&gt;k = SKF_AD_OFF + SKF_AD_PKTTYPE;
2587  		} else if (p-&gt;k == 14) {
2588  			p-&gt;k = SKF_AD_OFF + SKF_AD_PROTOCOL;
2589  		} else if ((bpf_int32)(p-&gt;k) &gt; 0) {
2590  			return -1;
2591  		}
2592  	}
2593  	return 0;
2594  }
2595  static int
2596  set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)
2597  {
2598  	int total_filter_on = 0;
2599  	int save_mode;
2600  	int ret;
2601  	int save_errno;
2602  	if (setsockopt(handle-&gt;fd, SOL_SOCKET, SO_ATTACH_FILTER,
2603  		       &amp;total_fcode, sizeof(total_fcode)) == 0) {
2604  		char drain[1];
2605  		total_filter_on = 1;
2606  		save_mode = fcntl(handle-&gt;fd, F_GETFL, 0);
2607  		if (save_mode == -1) {
2608  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2609  			    PCAP_ERRBUF_SIZE, errno,
2610  			    &quot;can&#x27;t get FD flags when changing filter&quot;);
2611  			return -2;
2612  		}
2613  		if (fcntl(handle-&gt;fd, F_SETFL, save_mode | O_NONBLOCK) &lt; 0) {
2614  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2615  			    PCAP_ERRBUF_SIZE, errno,
2616  			    &quot;can&#x27;t set nonblocking mode when changing filter&quot;);
2617  			return -2;
2618  		}
2619  		while (recv(handle-&gt;fd, &amp;drain, sizeof drain, MSG_TRUNC) &gt;= 0)
2620  			;
2621  		save_errno = errno;
2622  		if (save_errno != EAGAIN) {
2623  			(void)fcntl(handle-&gt;fd, F_SETFL, save_mode);
2624  			(void)reset_kernel_filter(handle);
2625  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2626  			    PCAP_ERRBUF_SIZE, save_errno,
2627  			    &quot;recv failed when changing filter&quot;);
2628  			return -2;
2629  		}
2630  		if (fcntl(handle-&gt;fd, F_SETFL, save_mode) == -1) {
2631  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2632  			    PCAP_ERRBUF_SIZE, errno,
2633  			    &quot;can&#x27;t restore FD flags when changing filter&quot;);
2634  			return -2;
2635  		}
2636  	}
2637  	ret = setsockopt(handle-&gt;fd, SOL_SOCKET, SO_ATTACH_FILTER,
2638  			 fcode, sizeof(*fcode));
2639  	if (ret == -1 &amp;&amp; total_filter_on) {
2640  		save_errno = errno;
2641  		if (reset_kernel_filter(handle) == -1) {
2642  			pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
2643  			    PCAP_ERRBUF_SIZE, errno,
2644  			    &quot;can&#x27;t remove kernel total filter&quot;);
2645  			return -2;	&amp;bsol;* fatal error */
2646  		}
2647  		errno = save_errno;
2648  	}
2649  	return ret;
2650  }
2651  static int
2652  reset_kernel_filter(pcap_t *handle)
2653  {
2654  	int ret;
2655  	int dummy = 0;
2656  	ret = setsockopt(handle-&gt;fd, SOL_SOCKET, SO_DETACH_FILTER,
2657  				   &amp;dummy, sizeof(dummy));
2658  	if (ret == -1 &amp;&amp; errno != ENOENT &amp;&amp; errno != ENONET)
2659  		return -1;
2660  	return 0;
2661  }
2662  int
2663  pcap_set_protocol_linux(pcap_t *p, int protocol)
2664  {
2665  	if (pcap_check_activated(p))
2666  		return (PCAP_ERROR_ACTIVATED);
2667  	p-&gt;opt.protocol = protocol;
2668  	return (0);
2669  }
2670  const char *
2671  pcap_lib_version(void)
2672  {
2673  #if defined(HAVE_TPACKET3)
2674  	return (PCAP_VERSION_STRING &quot; (with TPACKET_V3)&quot;);
2675  #else
2676  	return (PCAP_VERSION_STRING &quot; (with TPACKET_V2)&quot;);
2677  #endif
2678  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-haiku.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-linux.c</div>
                </div>
                <div class="column column_space"><pre><code>110  		pcap_fmt_errmsg_for_errno(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
111  			errno, &quot;strdup&quot;);
112  		return PCAP_ERROR;
113  	}
114  	handle-&gt;bufsize = 65536;
</pre></code></div>
                <div class="column column_space"><pre><code>1163  				pcap_fmt_errmsg_for_errno(handle-&gt;errbuf,
1164  				    PCAP_ERRBUF_SIZE, errno, &quot;socket&quot;);
1165  				return PCAP_ERROR;
1166  			}
1167  			handlep-&gt;cooked = 1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    