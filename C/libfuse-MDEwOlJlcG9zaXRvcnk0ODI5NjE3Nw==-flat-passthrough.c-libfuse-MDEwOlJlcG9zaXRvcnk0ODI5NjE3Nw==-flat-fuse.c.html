
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.339917399892261%, Tokens: 9</h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #define _GNU_SOURCE
3  #ifdef linux
4  #define _XOPEN_SOURCE 700
5  #endif
6  #include <fuse.h>
7  #include <stdio.h>
8  #include <string.h>
9  #include <unistd.h>
10  #include <fcntl.h>
11  #include <sys/stat.h>
12  #include <dirent.h>
13  #include <errno.h>
14  #ifdef __FreeBSD__
15  #include <sys/socket.h>
16  #include <sys/un.h>
17  #endif
18  #include <sys/time.h>
19  #ifdef HAVE_SETXATTR
20  #include <sys/xattr.h>
21  #endif
22  #include "passthrough_helpers.h"
23  static int fill_dir_plus = 0;
24  static void *xmp_init(struct fuse_conn_info *conn,
25  		      struct fuse_config *cfg)
26  {
27  	(void) conn;
28  	cfg->use_ino = 1;
29  	cfg->entry_timeout = 0;
30  	cfg->attr_timeout = 0;
31  	cfg->negative_timeout = 0;
32  	return NULL;
33  }
34  static int xmp_getattr(const char *path, struct stat *stbuf,
35  		       struct fuse_file_info *fi)
36  {
37  	(void) fi;
38  	int res;
39  	res = lstat(path, stbuf);
40  	if (res == -1)
41  		return -errno;
42  	return 0;
43  }
44  static int xmp_access(const char *path, int mask)
45  {
46  	int res;
47  	res = access(path, mask);
48  	if (res == -1)
49  		return -errno;
50  	return 0;
51  }
52  static int xmp_readlink(const char *path, char *buf, size_t size)
53  {
54  	int res;
55  	res = readlink(path, buf, size - 1);
56  	if (res == -1)
57  		return -errno;
58  	buf[res] = '\0';
59  	return 0;
60  }
61  static int xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
62  		       off_t offset, struct fuse_file_info *fi,
63  		       enum fuse_readdir_flags flags)
64  {
65  	DIR *dp;
66  	struct dirent *de;
67  	(void) offset;
68  	(void) fi;
69  	(void) flags;
70  	dp = opendir(path);
71  	if (dp == NULL)
72  		return -errno;
73  	while ((de = readdir(dp)) != NULL) {
74  		struct stat st;
75  		memset(&st, 0, sizeof(st));
76  		st.st_ino = de->d_ino;
77  		st.st_mode = de->d_type << 12;
78  		if (filler(buf, de->d_name, &st, 0, fill_dir_plus))
79  			break;
80  	}
81  	closedir(dp);
82  	return 0;
<span onclick='openModal()' class='match'>83  }
84  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
85  {
86  	int res;
87  	res = mknod_wrapper(AT_FDCWD, path, NULL, mode, rdev);
</span>88  	if (res == -1)
89  		return -errno;
90  	return 0;
91  }
92  static int xmp_mkdir(const char *path, mode_t mode)
93  {
94  	int res;
95  	res = mkdir(path, mode);
96  	if (res == -1)
97  		return -errno;
98  	return 0;
99  }
100  static int xmp_unlink(const char *path)
101  {
102  	int res;
103  	res = unlink(path);
104  	if (res == -1)
105  		return -errno;
106  	return 0;
107  }
108  static int xmp_rmdir(const char *path)
109  {
110  	int res;
111  	res = rmdir(path);
112  	if (res == -1)
113  		return -errno;
114  	return 0;
115  }
116  static int xmp_symlink(const char *from, const char *to)
117  {
118  	int res;
119  	res = symlink(from, to);
120  	if (res == -1)
121  		return -errno;
122  	return 0;
123  }
124  static int xmp_rename(const char *from, const char *to, unsigned int flags)
125  {
126  	int res;
127  	if (flags)
128  		return -EINVAL;
129  	res = rename(from, to);
130  	if (res == -1)
131  		return -errno;
132  	return 0;
133  }
134  static int xmp_link(const char *from, const char *to)
135  {
136  	int res;
137  	res = link(from, to);
138  	if (res == -1)
139  		return -errno;
140  	return 0;
141  }
142  static int xmp_chmod(const char *path, mode_t mode,
143  		     struct fuse_file_info *fi)
144  {
145  	(void) fi;
146  	int res;
147  	res = chmod(path, mode);
148  	if (res == -1)
149  		return -errno;
150  	return 0;
151  }
152  static int xmp_chown(const char *path, uid_t uid, gid_t gid,
153  		     struct fuse_file_info *fi)
154  {
155  	(void) fi;
156  	int res;
157  	res = lchown(path, uid, gid);
158  	if (res == -1)
159  		return -errno;
160  	return 0;
161  }
162  static int xmp_truncate(const char *path, off_t size,
163  			struct fuse_file_info *fi)
164  {
165  	int res;
166  	if (fi != NULL)
167  		res = ftruncate(fi->fh, size);
168  	else
169  		res = truncate(path, size);
170  	if (res == -1)
171  		return -errno;
172  	return 0;
173  }
174  #ifdef HAVE_UTIMENSAT
175  static int xmp_utimens(const char *path, const struct timespec ts[2],
176  		       struct fuse_file_info *fi)
177  {
178  	(void) fi;
179  	int res;
180  	res = utimensat(0, path, ts, AT_SYMLINK_NOFOLLOW);
181  	if (res == -1)
182  		return -errno;
183  	return 0;
184  }
185  #endif
186  static int xmp_create(const char *path, mode_t mode,
187  		      struct fuse_file_info *fi)
188  {
189  	int res;
190  	res = open(path, fi->flags, mode);
191  	if (res == -1)
192  		return -errno;
193  	fi->fh = res;
194  	return 0;
195  }
196  static int xmp_open(const char *path, struct fuse_file_info *fi)
197  {
198  	int res;
199  	res = open(path, fi->flags);
200  	if (res == -1)
201  		return -errno;
202  	fi->fh = res;
203  	return 0;
204  }
205  static int xmp_read(const char *path, char *buf, size_t size, off_t offset,
206  		    struct fuse_file_info *fi)
207  {
208  	int fd;
209  	int res;
210  	if(fi == NULL)
211  		fd = open(path, O_RDONLY);
212  	else
213  		fd = fi->fh;
214  	if (fd == -1)
215  		return -errno;
216  	res = pread(fd, buf, size, offset);
217  	if (res == -1)
218  		res = -errno;
219  	if(fi == NULL)
220  		close(fd);
221  	return res;
222  }
223  static int xmp_write(const char *path, const char *buf, size_t size,
224  		     off_t offset, struct fuse_file_info *fi)
225  {
226  	int fd;
227  	int res;
228  	(void) fi;
229  	if(fi == NULL)
230  		fd = open(path, O_WRONLY);
231  	else
232  		fd = fi->fh;
233  	if (fd == -1)
234  		return -errno;
235  	res = pwrite(fd, buf, size, offset);
236  	if (res == -1)
237  		res = -errno;
238  	if(fi == NULL)
239  		close(fd);
240  	return res;
241  }
242  static int xmp_statfs(const char *path, struct statvfs *stbuf)
243  {
244  	int res;
245  	res = statvfs(path, stbuf);
246  	if (res == -1)
247  		return -errno;
248  	return 0;
249  }
250  static int xmp_release(const char *path, struct fuse_file_info *fi)
251  {
252  	(void) path;
253  	close(fi->fh);
254  	return 0;
255  }
256  static int xmp_fsync(const char *path, int isdatasync,
257  		     struct fuse_file_info *fi)
258  {
259  	(void) path;
260  	(void) isdatasync;
261  	(void) fi;
262  	return 0;
263  }
264  #ifdef HAVE_POSIX_FALLOCATE
265  static int xmp_fallocate(const char *path, int mode,
266  			off_t offset, off_t length, struct fuse_file_info *fi)
267  {
268  	int fd;
269  	int res;
270  	(void) fi;
271  	if (mode)
272  		return -EOPNOTSUPP;
273  	if(fi == NULL)
274  		fd = open(path, O_WRONLY);
275  	else
276  		fd = fi->fh;
277  	if (fd == -1)
278  		return -errno;
279  	res = -posix_fallocate(fd, offset, length);
280  	if(fi == NULL)
281  		close(fd);
282  	return res;
283  }
284  #endif
285  #ifdef HAVE_SETXATTR
286  static int xmp_setxattr(const char *path, const char *name, const char *value,
287  			size_t size, int flags)
288  {
289  	int res = lsetxattr(path, name, value, size, flags);
290  	if (res == -1)
291  		return -errno;
292  	return 0;
293  }
294  static int xmp_getxattr(const char *path, const char *name, char *value,
295  			size_t size)
296  {
297  	int res = lgetxattr(path, name, value, size);
298  	if (res == -1)
299  		return -errno;
300  	return res;
301  }
302  static int xmp_listxattr(const char *path, char *list, size_t size)
303  {
304  	int res = llistxattr(path, list, size);
305  	if (res == -1)
306  		return -errno;
307  	return res;
308  }
309  static int xmp_removexattr(const char *path, const char *name)
310  {
311  	int res = lremovexattr(path, name);
312  	if (res == -1)
313  		return -errno;
314  	return 0;
315  }
316  #endif &bsol;* HAVE_SETXATTR */
317  #ifdef HAVE_COPY_FILE_RANGE
318  static ssize_t xmp_copy_file_range(const char *path_in,
319  				   struct fuse_file_info *fi_in,
320  				   off_t offset_in, const char *path_out,
321  				   struct fuse_file_info *fi_out,
322  				   off_t offset_out, size_t len, int flags)
323  {
324  	int fd_in, fd_out;
325  	ssize_t res;
326  	if(fi_in == NULL)
327  		fd_in = open(path_in, O_RDONLY);
328  	else
329  		fd_in = fi_in->fh;
330  	if (fd_in == -1)
331  		return -errno;
332  	if(fi_out == NULL)
333  		fd_out = open(path_out, O_WRONLY);
334  	else
335  		fd_out = fi_out->fh;
336  	if (fd_out == -1) {
337  		close(fd_in);
338  		return -errno;
339  	}
340  	res = copy_file_range(fd_in, &offset_in, fd_out, &offset_out, len,
341  			      flags);
342  	if (res == -1)
343  		res = -errno;
344  	if (fi_out == NULL)
345  		close(fd_out);
346  	if (fi_in == NULL)
347  		close(fd_in);
348  	return res;
349  }
350  #endif
351  static off_t xmp_lseek(const char *path, off_t off, int whence, struct fuse_file_info *fi)
352  {
353  	int fd;
354  	off_t res;
355  	if (fi == NULL)
356  		fd = open(path, O_RDONLY);
357  	else
358  		fd = fi->fh;
359  	if (fd == -1)
360  		return -errno;
361  	res = lseek(fd, off, whence);
362  	if (res == -1)
363  		res = -errno;
364  	if (fi == NULL)
365  		close(fd);
366  	return res;
367  }
368  static const struct fuse_operations xmp_oper = {
369  	.init           = xmp_init,
370  	.getattr	= xmp_getattr,
371  	.access		= xmp_access,
372  	.readlink	= xmp_readlink,
373  	.readdir	= xmp_readdir,
374  	.mknod		= xmp_mknod,
375  	.mkdir		= xmp_mkdir,
376  	.symlink	= xmp_symlink,
377  	.unlink		= xmp_unlink,
378  	.rmdir		= xmp_rmdir,
379  	.rename		= xmp_rename,
380  	.link		= xmp_link,
381  	.chmod		= xmp_chmod,
382  	.chown		= xmp_chown,
383  	.truncate	= xmp_truncate,
384  #ifdef HAVE_UTIMENSAT
385  	.utimens	= xmp_utimens,
386  #endif
387  	.open		= xmp_open,
388  	.create 	= xmp_create,
389  	.read		= xmp_read,
390  	.write		= xmp_write,
391  	.statfs		= xmp_statfs,
392  	.release	= xmp_release,
393  	.fsync		= xmp_fsync,
394  #ifdef HAVE_POSIX_FALLOCATE
395  	.fallocate	= xmp_fallocate,
396  #endif
397  #ifdef HAVE_SETXATTR
398  	.setxattr	= xmp_setxattr,
399  	.getxattr	= xmp_getxattr,
400  	.listxattr	= xmp_listxattr,
401  	.removexattr	= xmp_removexattr,
402  #endif
403  #ifdef HAVE_COPY_FILE_RANGE
404  	.copy_file_range = xmp_copy_file_range,
405  #endif
406  	.lseek		= xmp_lseek,
407  };
408  int main(int argc, char *argv[])
409  {
410  	enum { MAX_ARGS = 10 };
411  	int i,new_argc;
412  	char *new_argv[MAX_ARGS];
413  	umask(0);
414  	for (i=0, new_argc=0; (i<argc) && (new_argc<MAX_ARGS); i++) {
415  		if (!strcmp(argv[i], "--plus")) {
416  			fill_dir_plus = FUSE_FILL_DIR_PLUS;
417  		} else {
418  			new_argv[new_argc++] = argv[i];
419  		}
420  	}
421  	return fuse_main(new_argc, new_argv, &xmp_oper, NULL);
422  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include "fuse_config.h"
3  #include "fuse_i.h"
4  #include "fuse_lowlevel.h"
5  #include "fuse_opt.h"
6  #include "fuse_misc.h"
7  #include "fuse_kernel.h"
8  #include <stdio.h>
9  #include <string.h>
10  #include <stdlib.h>
11  #include <stddef.h>
12  #include <stdbool.h>
13  #include <unistd.h>
14  #include <time.h>
15  #include <fcntl.h>
16  #include <limits.h>
17  #include <errno.h>
18  #include <signal.h>
19  #include <dlfcn.h>
20  #include <assert.h>
21  #include <poll.h>
22  #include <sys/param.h>
23  #include <sys/uio.h>
24  #include <sys/time.h>
25  #include <sys/mman.h>
26  #include <sys/file.h>
27  #define FUSE_NODE_SLAB 1
28  #ifndef MAP_ANONYMOUS
29  #undef FUSE_NODE_SLAB
30  #endif
31  #ifndef RENAME_EXCHANGE
32  #define RENAME_EXCHANGE		(1 << 1)	&bsol;* Exchange source and dest */
33  #endif
34  #define FUSE_DEFAULT_INTR_SIGNAL SIGUSR1
35  #define FUSE_UNKNOWN_INO 0xffffffff
36  #define OFFSET_MAX 0x7fffffffffffffffLL
37  #define NODE_TABLE_MIN_SIZE 8192
38  struct fuse_fs {
39  	struct fuse_operations op;
40  	void *user_data;
41  	int debug;
42  };
43  struct fusemod_so {
44  	void *handle;
45  	int ctr;
46  };
47  struct lock_queue_element {
48  	struct lock_queue_element *next;
49  	pthread_cond_t cond;
50  	fuse_ino_t nodeid1;
51  	const char *name1;
52  	char **path1;
53  	struct node **wnode1;
54  	fuse_ino_t nodeid2;
55  	const char *name2;
56  	char **path2;
57  	struct node **wnode2;
58  	int err;
59  	bool done : 1;
60  };
61  struct node_table {
62  	struct node **array;
63  	size_t use;
64  	size_t size;
65  	size_t split;
66  };
67  #define container_of(ptr, type, member) ({                              \
68  			const typeof( ((type *)0)->member ) *__mptr = (ptr); \
69  			(type *)( (char *)__mptr - offsetof(type,member) );})
70  #define list_entry(ptr, type, member)           \
71  	container_of(ptr, type, member)
72  struct list_head {
73  	struct list_head *next;
74  	struct list_head *prev;
75  };
76  struct node_slab {
77  	struct list_head list;  &bsol;* must be the first member */
78  	struct list_head freelist;
79  	int used;
80  };
81  struct fuse {
82  	struct fuse_session *se;
83  	struct node_table name_table;
84  	struct node_table id_table;
85  	struct list_head lru_table;
86  	fuse_ino_t ctr;
87  	unsigned int generation;
88  	unsigned int hidectr;
89  	pthread_mutex_t lock;
90  	struct fuse_config conf;
91  	int intr_installed;
92  	struct fuse_fs *fs;
93  	struct lock_queue_element *lockq;
94  	int pagesize;
95  	struct list_head partial_slabs;
96  	struct list_head full_slabs;
97  	pthread_t prune_thread;
98  };
99  struct lock {
100  	int type;
101  	off_t start;
102  	off_t end;
103  	pid_t pid;
104  	uint64_t owner;
105  	struct lock *next;
106  };
107  struct node {
108  	struct node *name_next;
109  	struct node *id_next;
110  	fuse_ino_t nodeid;
111  	unsigned int generation;
112  	int refctr;
113  	struct node *parent;
114  	char *name;
115  	uint64_t nlookup;
116  	int open_count;
117  	struct timespec stat_updated;
118  	struct timespec mtime;
119  	off_t size;
120  	struct lock *locks;
121  	unsigned int is_hidden : 1;
122  	unsigned int cache_valid : 1;
123  	int treelock;
124  	char inline_name[32];
125  };
126  #define TREELOCK_WRITE -1
127  #define TREELOCK_WAIT_OFFSET INT_MIN
128  struct node_lru {
129  	struct node node;
130  	struct list_head lru;
131  	struct timespec forget_time;
132  };
133  struct fuse_direntry {
134  	struct stat stat;
135  	char *name;
136  	struct fuse_direntry *next;
137  };
138  struct fuse_dh {
139  	pthread_mutex_t lock;
140  	struct fuse *fuse;
141  	fuse_req_t req;
142  	char *contents;
143  	struct fuse_direntry *first;
144  	struct fuse_direntry **last;
145  	unsigned len;
146  	unsigned size;
147  	unsigned needlen;
148  	int filled;
149  	uint64_t fh;
150  	int error;
151  	fuse_ino_t nodeid;
152  };
153  struct fuse_context_i {
154  	struct fuse_context ctx;
155  	fuse_req_t req;
156  };
157  extern fuse_module_factory_t fuse_module_subdir_factory;
158  #ifdef HAVE_ICONV
159  extern fuse_module_factory_t fuse_module_iconv_factory;
160  #endif
161  static pthread_key_t fuse_context_key;
162  static pthread_mutex_t fuse_context_lock = PTHREAD_MUTEX_INITIALIZER;
163  static int fuse_context_ref;
164  static struct fuse_module *fuse_modules = NULL;
165  static int fuse_register_module(const char *name,
166  				fuse_module_factory_t factory,
167  				struct fusemod_so *so)
168  {
169  	struct fuse_module *mod;
170  	mod = calloc(1, sizeof(struct fuse_module));
171  	if (!mod) {
172  		fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate module\n");
173  		return -1;
174  	}
175  	mod->name = strdup(name);
176  	if (!mod->name) {
177  		fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate module name\n");
178  		free(mod);
179  		return -1;
180  	}
181  	mod->factory = factory;
182  	mod->ctr = 0;
183  	mod->so = so;
184  	if (mod->so)
185  		mod->so->ctr++;
186  	mod->next = fuse_modules;
187  	fuse_modules = mod;
188  	return 0;
189  }
190  static void fuse_unregister_module(struct fuse_module *m)
191  {
192  	struct fuse_module **mp;
193  	for (mp = &fuse_modules; *mp; mp = &(*mp)->next) {
194  		if (*mp == m) {
195  			*mp = (*mp)->next;
196  			break;
197  		}
198  	}
199  	free(m->name);
200  	free(m);
<span onclick='openModal()' class='match'>201  }
202  static int fuse_load_so_module(const char *module)
203  {
204  	int ret = -1;
205  	char *tmp;
</span>206  	struct fusemod_so *so;
207  	fuse_module_factory_t *factory;
208  	tmp = malloc(strlen(module) + 64);
209  	if (!tmp) {
210  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
211  		return -1;
212  	}
213  	sprintf(tmp, "libfusemod_%s.so", module);
214  	so = calloc(1, sizeof(struct fusemod_so));
215  	if (!so) {
216  		fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate module so\n");
217  		goto out;
218  	}
219  	so->handle = dlopen(tmp, RTLD_NOW);
220  	if (so->handle == NULL) {
221  		fuse_log(FUSE_LOG_ERR, "fuse: dlopen(%s) failed: %s\n",
222  			tmp, dlerror());
223  		goto out_free_so;
224  	}
225  	sprintf(tmp, "fuse_module_%s_factory", module);
226  	factory = (fuse_module_factory_t*)dlsym(so->handle, tmp);
227  	if (factory == NULL) {
228  		fuse_log(FUSE_LOG_ERR, "fuse: symbol <%s> not found in module: %s\n",
229  			tmp, dlerror());
230  		goto out_dlclose;
231  	}
232  	ret = fuse_register_module(module, *factory, so);
233  	if (ret)
234  		goto out_dlclose;
235  out:
236  	free(tmp);
237  	return ret;
238  out_dlclose:
239  	dlclose(so->handle);
240  out_free_so:
241  	free(so);
242  	goto out;
243  }
244  static struct fuse_module *fuse_find_module(const char *module)
245  {
246  	struct fuse_module *m;
247  	for (m = fuse_modules; m; m = m->next) {
248  		if (strcmp(module, m->name) == 0) {
249  			m->ctr++;
250  			break;
251  		}
252  	}
253  	return m;
254  }
255  static struct fuse_module *fuse_get_module(const char *module)
256  {
257  	struct fuse_module *m;
258  	pthread_mutex_lock(&fuse_context_lock);
259  	m = fuse_find_module(module);
260  	if (!m) {
261  		int err = fuse_load_so_module(module);
262  		if (!err)
263  			m = fuse_find_module(module);
264  	}
265  	pthread_mutex_unlock(&fuse_context_lock);
266  	return m;
267  }
268  static void fuse_put_module(struct fuse_module *m)
269  {
270  	pthread_mutex_lock(&fuse_context_lock);
271  	if (m->so)
272  		assert(m->ctr > 0);
273  	if (m->ctr > 0)
274  		m->ctr--;
275  	if (!m->ctr && m->so) {
276  		struct fusemod_so *so = m->so;
277  		assert(so->ctr > 0);
278  		so->ctr--;
279  		if (!so->ctr) {
280  			struct fuse_module **mp;
281  			for (mp = &fuse_modules; *mp;) {
282  				if ((*mp)->so == so)
283  					fuse_unregister_module(*mp);
284  				else
285  					mp = &(*mp)->next;
286  			}
287  			dlclose(so->handle);
288  			free(so);
289  		}
290  	} else if (!m->ctr) {
291  		fuse_unregister_module(m);
292  	}
293  	pthread_mutex_unlock(&fuse_context_lock);
294  }
295  static void init_list_head(struct list_head *list)
296  {
297  	list->next = list;
298  	list->prev = list;
299  }
300  static int list_empty(const struct list_head *head)
301  {
302  	return head->next == head;
303  }
304  static void list_add(struct list_head *new, struct list_head *prev,
305  		     struct list_head *next)
306  {
307  	next->prev = new;
308  	new->next = next;
309  	new->prev = prev;
310  	prev->next = new;
311  }
312  static inline void list_add_head(struct list_head *new, struct list_head *head)
313  {
314  	list_add(new, head, head->next);
315  }
316  static inline void list_add_tail(struct list_head *new, struct list_head *head)
317  {
318  	list_add(new, head->prev, head);
319  }
320  static inline void list_del(struct list_head *entry)
321  {
322  	struct list_head *prev = entry->prev;
323  	struct list_head *next = entry->next;
324  	next->prev = prev;
325  	prev->next = next;
326  }
327  static inline int lru_enabled(struct fuse *f)
328  {
329  	return f->conf.remember > 0;
330  }
331  static struct node_lru *node_lru(struct node *node)
332  {
333  	return (struct node_lru *) node;
334  }
335  static size_t get_node_size(struct fuse *f)
336  {
337  	if (lru_enabled(f))
338  		return sizeof(struct node_lru);
339  	else
340  		return sizeof(struct node);
341  }
342  #ifdef FUSE_NODE_SLAB
343  static struct node_slab *list_to_slab(struct list_head *head)
344  {
345  	return (struct node_slab *) head;
346  }
347  static struct node_slab *node_to_slab(struct fuse *f, struct node *node)
348  {
349  	return (struct node_slab *) (((uintptr_t) node) & ~((uintptr_t) f->pagesize - 1));
350  }
351  static int alloc_slab(struct fuse *f)
352  {
353  	void *mem;
354  	struct node_slab *slab;
355  	char *start;
356  	size_t num;
357  	size_t i;
358  	size_t node_size = get_node_size(f);
359  	mem = mmap(NULL, f->pagesize, PROT_READ | PROT_WRITE,
360  		   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
361  	if (mem == MAP_FAILED)
362  		return -1;
363  	slab = mem;
364  	init_list_head(&slab->freelist);
365  	slab->used = 0;
366  	num = (f->pagesize - sizeof(struct node_slab)) / node_size;
367  	start = (char *) mem + f->pagesize - num * node_size;
368  	for (i = 0; i < num; i++) {
369  		struct list_head *n;
370  		n = (struct list_head *) (start + i * node_size);
371  		list_add_tail(n, &slab->freelist);
372  	}
373  	list_add_tail(&slab->list, &f->partial_slabs);
374  	return 0;
375  }
376  static struct node *alloc_node(struct fuse *f)
377  {
378  	struct node_slab *slab;
379  	struct list_head *node;
380  	if (list_empty(&f->partial_slabs)) {
381  		int res = alloc_slab(f);
382  		if (res != 0)
383  			return NULL;
384  	}
385  	slab = list_to_slab(f->partial_slabs.next);
386  	slab->used++;
387  	node = slab->freelist.next;
388  	list_del(node);
389  	if (list_empty(&slab->freelist)) {
390  		list_del(&slab->list);
391  		list_add_tail(&slab->list, &f->full_slabs);
392  	}
393  	memset(node, 0, sizeof(struct node));
394  	return (struct node *) node;
395  }
396  static void free_slab(struct fuse *f, struct node_slab *slab)
397  {
398  	int res;
399  	list_del(&slab->list);
400  	res = munmap(slab, f->pagesize);
401  	if (res == -1)
402  		fuse_log(FUSE_LOG_WARNING, "fuse warning: munmap(%p) failed\n",
403  			 slab);
404  }
405  static void free_node_mem(struct fuse *f, struct node *node)
406  {
407  	struct node_slab *slab = node_to_slab(f, node);
408  	struct list_head *n = (struct list_head *) node;
409  	slab->used--;
410  	if (slab->used) {
411  		if (list_empty(&slab->freelist)) {
412  			list_del(&slab->list);
413  			list_add_tail(&slab->list, &f->partial_slabs);
414  		}
415  		list_add_head(n, &slab->freelist);
416  	} else {
417  		free_slab(f, slab);
418  	}
419  }
420  #else
421  static struct node *alloc_node(struct fuse *f)
422  {
423  	return (struct node *) calloc(1, get_node_size(f));
424  }
425  static void free_node_mem(struct fuse *f, struct node *node)
426  {
427  	(void) f;
428  	free(node);
429  }
430  #endif
431  static size_t id_hash(struct fuse *f, fuse_ino_t ino)
432  {
433  	uint64_t hash = ((uint32_t) ino * 2654435761U) % f->id_table.size;
434  	uint64_t oldhash = hash % (f->id_table.size / 2);
435  	if (oldhash >= f->id_table.split)
436  		return oldhash;
437  	else
438  		return hash;
439  }
440  static struct node *get_node_nocheck(struct fuse *f, fuse_ino_t nodeid)
441  {
442  	size_t hash = id_hash(f, nodeid);
443  	struct node *node;
444  	for (node = f->id_table.array[hash]; node != NULL; node = node->id_next)
445  		if (node->nodeid == nodeid)
446  			return node;
447  	return NULL;
448  }
449  static struct node *get_node(struct fuse *f, fuse_ino_t nodeid)
450  {
451  	struct node *node = get_node_nocheck(f, nodeid);
452  	if (!node) {
453  		fuse_log(FUSE_LOG_ERR, "fuse internal error: node %llu not found\n",
454  			(unsigned long long) nodeid);
455  		abort();
456  	}
457  	return node;
458  }
459  static void curr_time(struct timespec *now);
460  static double diff_timespec(const struct timespec *t1,
461  			   const struct timespec *t2);
462  static void remove_node_lru(struct node *node)
463  {
464  	struct node_lru *lnode = node_lru(node);
465  	list_del(&lnode->lru);
466  	init_list_head(&lnode->lru);
467  }
468  static void set_forget_time(struct fuse *f, struct node *node)
469  {
470  	struct node_lru *lnode = node_lru(node);
471  	list_del(&lnode->lru);
472  	list_add_tail(&lnode->lru, &f->lru_table);
473  	curr_time(&lnode->forget_time);
474  }
475  static void free_node(struct fuse *f, struct node *node)
476  {
477  	if (node->name != node->inline_name)
478  		free(node->name);
479  	free_node_mem(f, node);
480  }
481  static void node_table_reduce(struct node_table *t)
482  {
483  	size_t newsize = t->size / 2;
484  	void *newarray;
485  	if (newsize < NODE_TABLE_MIN_SIZE)
486  		return;
487  	newarray = realloc(t->array, sizeof(struct node *) * newsize);
488  	if (newarray != NULL)
489  		t->array = newarray;
490  	t->size = newsize;
491  	t->split = t->size / 2;
492  }
493  static void remerge_id(struct fuse *f)
494  {
495  	struct node_table *t = &f->id_table;
496  	int iter;
497  	if (t->split == 0)
498  		node_table_reduce(t);
499  	for (iter = 8; t->split > 0 && iter; iter--) {
500  		struct node **upper;
501  		t->split--;
502  		upper = &t->array[t->split + t->size / 2];
503  		if (*upper) {
504  			struct node **nodep;
505  			for (nodep = &t->array[t->split]; *nodep;
506  			     nodep = &(*nodep)->id_next);
507  			*nodep = *upper;
508  			*upper = NULL;
509  			break;
510  		}
511  	}
512  }
513  static void unhash_id(struct fuse *f, struct node *node)
514  {
515  	struct node **nodep = &f->id_table.array[id_hash(f, node->nodeid)];
516  	for (; *nodep != NULL; nodep = &(*nodep)->id_next)
517  		if (*nodep == node) {
518  			*nodep = node->id_next;
519  			f->id_table.use--;
520  			if(f->id_table.use < f->id_table.size / 4)
521  				remerge_id(f);
522  			return;
523  		}
524  }
525  static int node_table_resize(struct node_table *t)
526  {
527  	size_t newsize = t->size * 2;
528  	void *newarray;
529  	newarray = realloc(t->array, sizeof(struct node *) * newsize);
530  	if (newarray == NULL)
531  		return -1;
532  	t->array = newarray;
533  	memset(t->array + t->size, 0, t->size * sizeof(struct node *));
534  	t->size = newsize;
535  	t->split = 0;
536  	return 0;
537  }
538  static void rehash_id(struct fuse *f)
539  {
540  	struct node_table *t = &f->id_table;
541  	struct node **nodep;
542  	struct node **next;
543  	size_t hash;
544  	if (t->split == t->size / 2)
545  		return;
546  	hash = t->split;
547  	t->split++;
548  	for (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {
549  		struct node *node = *nodep;
550  		size_t newhash = id_hash(f, node->nodeid);
551  		if (newhash != hash) {
552  			next = nodep;
553  			*nodep = node->id_next;
554  			node->id_next = t->array[newhash];
555  			t->array[newhash] = node;
556  		} else {
557  			next = &node->id_next;
558  		}
559  	}
560  	if (t->split == t->size / 2)
561  		node_table_resize(t);
562  }
563  static void hash_id(struct fuse *f, struct node *node)
564  {
565  	size_t hash = id_hash(f, node->nodeid);
566  	node->id_next = f->id_table.array[hash];
567  	f->id_table.array[hash] = node;
568  	f->id_table.use++;
569  	if (f->id_table.use >= f->id_table.size / 2)
570  		rehash_id(f);
571  }
572  static size_t name_hash(struct fuse *f, fuse_ino_t parent,
573  			const char *name)
574  {
575  	uint64_t hash = parent;
576  	uint64_t oldhash;
577  	for (; *name; name++)
578  		hash = hash * 31 + (unsigned char) *name;
579  	hash %= f->name_table.size;
580  	oldhash = hash % (f->name_table.size / 2);
581  	if (oldhash >= f->name_table.split)
582  		return oldhash;
583  	else
584  		return hash;
585  }
586  static void unref_node(struct fuse *f, struct node *node);
587  static void remerge_name(struct fuse *f)
588  {
589  	struct node_table *t = &f->name_table;
590  	int iter;
591  	if (t->split == 0)
592  		node_table_reduce(t);
593  	for (iter = 8; t->split > 0 && iter; iter--) {
594  		struct node **upper;
595  		t->split--;
596  		upper = &t->array[t->split + t->size / 2];
597  		if (*upper) {
598  			struct node **nodep;
599  			for (nodep = &t->array[t->split]; *nodep;
600  			     nodep = &(*nodep)->name_next);
601  			*nodep = *upper;
602  			*upper = NULL;
603  			break;
604  		}
605  	}
606  }
607  static void unhash_name(struct fuse *f, struct node *node)
608  {
609  	if (node->name) {
610  		size_t hash = name_hash(f, node->parent->nodeid, node->name);
611  		struct node **nodep = &f->name_table.array[hash];
612  		for (; *nodep != NULL; nodep = &(*nodep)->name_next)
613  			if (*nodep == node) {
614  				*nodep = node->name_next;
615  				node->name_next = NULL;
616  				unref_node(f, node->parent);
617  				if (node->name != node->inline_name)
618  					free(node->name);
619  				node->name = NULL;
620  				node->parent = NULL;
621  				f->name_table.use--;
622  				if (f->name_table.use < f->name_table.size / 4)
623  					remerge_name(f);
624  				return;
625  			}
626  		fuse_log(FUSE_LOG_ERR,
627  			"fuse internal error: unable to unhash node: %llu\n",
628  			(unsigned long long) node->nodeid);
629  		abort();
630  	}
631  }
632  static void rehash_name(struct fuse *f)
633  {
634  	struct node_table *t = &f->name_table;
635  	struct node **nodep;
636  	struct node **next;
637  	size_t hash;
638  	if (t->split == t->size / 2)
639  		return;
640  	hash = t->split;
641  	t->split++;
642  	for (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {
643  		struct node *node = *nodep;
644  		size_t newhash = name_hash(f, node->parent->nodeid, node->name);
645  		if (newhash != hash) {
646  			next = nodep;
647  			*nodep = node->name_next;
648  			node->name_next = t->array[newhash];
649  			t->array[newhash] = node;
650  		} else {
651  			next = &node->name_next;
652  		}
653  	}
654  	if (t->split == t->size / 2)
655  		node_table_resize(t);
656  }
657  static int hash_name(struct fuse *f, struct node *node, fuse_ino_t parentid,
658  		     const char *name)
659  {
660  	size_t hash = name_hash(f, parentid, name);
661  	struct node *parent = get_node(f, parentid);
662  	if (strlen(name) < sizeof(node->inline_name)) {
663  		strcpy(node->inline_name, name);
664  		node->name = node->inline_name;
665  	} else {
666  		node->name = strdup(name);
667  		if (node->name == NULL)
668  			return -1;
669  	}
670  	parent->refctr ++;
671  	node->parent = parent;
672  	node->name_next = f->name_table.array[hash];
673  	f->name_table.array[hash] = node;
674  	f->name_table.use++;
675  	if (f->name_table.use >= f->name_table.size / 2)
676  		rehash_name(f);
677  	return 0;
678  }
679  static void delete_node(struct fuse *f, struct node *node)
680  {
681  	if (f->conf.debug)
682  		fuse_log(FUSE_LOG_DEBUG, "DELETE: %llu\n",
683  			(unsigned long long) node->nodeid);
684  	assert(node->treelock == 0);
685  	unhash_name(f, node);
686  	if (lru_enabled(f))
687  		remove_node_lru(node);
688  	unhash_id(f, node);
689  	free_node(f, node);
690  }
691  static void unref_node(struct fuse *f, struct node *node)
692  {
693  	assert(node->refctr > 0);
694  	node->refctr --;
695  	if (!node->refctr)
696  		delete_node(f, node);
697  }
698  static fuse_ino_t next_id(struct fuse *f)
699  {
700  	do {
701  		f->ctr = (f->ctr + 1) & 0xffffffff;
702  		if (!f->ctr)
703  			f->generation ++;
704  	} while (f->ctr == 0 || f->ctr == FUSE_UNKNOWN_INO ||
705  		 get_node_nocheck(f, f->ctr) != NULL);
706  	return f->ctr;
707  }
708  static struct node *lookup_node(struct fuse *f, fuse_ino_t parent,
709  				const char *name)
710  {
711  	size_t hash = name_hash(f, parent, name);
712  	struct node *node;
713  	for (node = f->name_table.array[hash]; node != NULL; node = node->name_next)
714  		if (node->parent->nodeid == parent &&
715  		    strcmp(node->name, name) == 0)
716  			return node;
717  	return NULL;
718  }
719  static void inc_nlookup(struct node *node)
720  {
721  	if (!node->nlookup)
722  		node->refctr++;
723  	node->nlookup++;
724  }
725  static struct node *find_node(struct fuse *f, fuse_ino_t parent,
726  			      const char *name)
727  {
728  	struct node *node;
729  	pthread_mutex_lock(&f->lock);
730  	if (!name)
731  		node = get_node(f, parent);
732  	else
733  		node = lookup_node(f, parent, name);
734  	if (node == NULL) {
735  		node = alloc_node(f);
736  		if (node == NULL)
737  			goto out_err;
738  		node->nodeid = next_id(f);
739  		node->generation = f->generation;
740  		if (f->conf.remember)
741  			inc_nlookup(node);
742  		if (hash_name(f, node, parent, name) == -1) {
743  			free_node(f, node);
744  			node = NULL;
745  			goto out_err;
746  		}
747  		hash_id(f, node);
748  		if (lru_enabled(f)) {
749  			struct node_lru *lnode = node_lru(node);
750  			init_list_head(&lnode->lru);
751  		}
752  	} else if (lru_enabled(f) && node->nlookup == 1) {
753  		remove_node_lru(node);
754  	}
755  	inc_nlookup(node);
756  out_err:
757  	pthread_mutex_unlock(&f->lock);
758  	return node;
759  }
760  static int lookup_path_in_cache(struct fuse *f,
761  		const char *path, fuse_ino_t *inop)
762  {
763  	char *tmp = strdup(path);
764  	if (!tmp)
765  		return -ENOMEM;
766  	pthread_mutex_lock(&f->lock);
767  	fuse_ino_t ino = FUSE_ROOT_ID;
768  	int err = 0;
769  	char *save_ptr;
770  	char *path_element = strtok_r(tmp, "/", &save_ptr);
771  	while (path_element != NULL) {
772  		struct node *node = lookup_node(f, ino, path_element);
773  		if (node == NULL) {
774  			err = -ENOENT;
775  			break;
776  		}
777  		ino = node->nodeid;
778  		path_element = strtok_r(NULL, "/", &save_ptr);
779  	}
780  	pthread_mutex_unlock(&f->lock);
781  	free(tmp);
782  	if (!err)
783  		*inop = ino;
784  	return err;
785  }
786  static char *add_name(char **buf, unsigned *bufsize, char *s, const char *name)
787  {
788  	size_t len = strlen(name);
789  	if (s - len <= *buf) {
790  		unsigned pathlen = *bufsize - (s - *buf);
791  		unsigned newbufsize = *bufsize;
792  		char *newbuf;
793  		while (newbufsize < pathlen + len + 1) {
794  			if (newbufsize >= 0x80000000)
795  				newbufsize = 0xffffffff;
796  			else
797  				newbufsize *= 2;
798  		}
799  		newbuf = realloc(*buf, newbufsize);
800  		if (newbuf == NULL)
801  			return NULL;
802  		*buf = newbuf;
803  		s = newbuf + newbufsize - pathlen;
804  		memmove(s, newbuf + *bufsize - pathlen, pathlen);
805  		*bufsize = newbufsize;
806  	}
807  	s -= len;
808  	memcpy(s, name, len);
809  	s--;
810  	*s = '/';
811  	return s;
812  }
813  static void unlock_path(struct fuse *f, fuse_ino_t nodeid, struct node *wnode,
814  			struct node *end)
815  {
816  	struct node *node;
817  	if (wnode) {
818  		assert(wnode->treelock == TREELOCK_WRITE);
819  		wnode->treelock = 0;
820  	}
821  	for (node = get_node(f, nodeid);
822  	     node != end && node->nodeid != FUSE_ROOT_ID; node = node->parent) {
823  		assert(node->treelock != 0);
824  		assert(node->treelock != TREELOCK_WAIT_OFFSET);
825  		assert(node->treelock != TREELOCK_WRITE);
826  		node->treelock--;
827  		if (node->treelock == TREELOCK_WAIT_OFFSET)
828  			node->treelock = 0;
829  	}
830  }
831  static int try_get_path(struct fuse *f, fuse_ino_t nodeid, const char *name,
832  			char **path, struct node **wnodep, bool need_lock)
833  {
834  	unsigned bufsize = 256;
835  	char *buf;
836  	char *s;
837  	struct node *node;
838  	struct node *wnode = NULL;
839  	int err;
840  	*path = NULL;
841  	err = -ENOMEM;
842  	buf = malloc(bufsize);
843  	if (buf == NULL)
844  		goto out_err;
845  	s = buf + bufsize - 1;
846  	*s = '\0';
847  	if (name != NULL) {
848  		s = add_name(&buf, &bufsize, s, name);
849  		err = -ENOMEM;
850  		if (s == NULL)
851  			goto out_free;
852  	}
853  	if (wnodep) {
854  		assert(need_lock);
855  		wnode = lookup_node(f, nodeid, name);
856  		if (wnode) {
857  			if (wnode->treelock != 0) {
858  				if (wnode->treelock > 0)
859  					wnode->treelock += TREELOCK_WAIT_OFFSET;
860  				err = -EAGAIN;
861  				goto out_free;
862  			}
863  			wnode->treelock = TREELOCK_WRITE;
864  		}
865  	}
866  	for (node = get_node(f, nodeid); node->nodeid != FUSE_ROOT_ID;
867  	     node = node->parent) {
868  		err = -ESTALE;
869  		if (node->name == NULL || node->parent == NULL)
870  			goto out_unlock;
871  		err = -ENOMEM;
872  		s = add_name(&buf, &bufsize, s, node->name);
873  		if (s == NULL)
874  			goto out_unlock;
875  		if (need_lock) {
876  			err = -EAGAIN;
877  			if (node->treelock < 0)
878  				goto out_unlock;
879  			node->treelock++;
880  		}
881  	}
882  	if (s[0])
883  		memmove(buf, s, bufsize - (s - buf));
884  	else
885  		strcpy(buf, "/");
886  	*path = buf;
887  	if (wnodep)
888  		*wnodep = wnode;
889  	return 0;
890   out_unlock:
891  	if (need_lock)
892  		unlock_path(f, nodeid, wnode, node);
893   out_free:
894  	free(buf);
895   out_err:
896  	return err;
897  }
898  static int try_get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,
899  			 fuse_ino_t nodeid2, const char *name2,
900  			 char **path1, char **path2,
901  			 struct node **wnode1, struct node **wnode2)
902  {
903  	int err;
904  	err = try_get_path(f, nodeid1, name1, path1, wnode1, true);
905  	if (!err) {
906  		err = try_get_path(f, nodeid2, name2, path2, wnode2, true);
907  		if (err) {
908  			struct node *wn1 = wnode1 ? *wnode1 : NULL;
909  			unlock_path(f, nodeid1, wn1, NULL);
910  			free(*path1);
911  		}
912  	}
913  	return err;
914  }
915  static void queue_element_wakeup(struct fuse *f, struct lock_queue_element *qe)
916  {
917  	int err;
918  	if (!qe->path1) {
919  		if (get_node(f, qe->nodeid1)->treelock == 0)
920  			pthread_cond_signal(&qe->cond);
921  		return;
922  	}
923  	if (qe->done)
924  		return;  
925  	if (!qe->path2) {
926  		err = try_get_path(f, qe->nodeid1, qe->name1, qe->path1,
927  				   qe->wnode1, true);
928  	} else {
929  		err = try_get_path2(f, qe->nodeid1, qe->name1, qe->nodeid2,
930  				    qe->name2, qe->path1, qe->path2, qe->wnode1,
931  				    qe->wnode2);
932  	}
933  	if (err == -EAGAIN)
934  		return;  &bsol;* keep trying */
935  	qe->err = err;
936  	qe->done = true;
937  	pthread_cond_signal(&qe->cond);
938  }
939  static void wake_up_queued(struct fuse *f)
940  {
941  	struct lock_queue_element *qe;
942  	for (qe = f->lockq; qe != NULL; qe = qe->next)
943  		queue_element_wakeup(f, qe);
944  }
945  static void debug_path(struct fuse *f, const char *msg, fuse_ino_t nodeid,
946  		       const char *name, bool wr)
947  {
948  	if (f->conf.debug) {
949  		struct node *wnode = NULL;
950  		if (wr)
951  			wnode = lookup_node(f, nodeid, name);
952  		if (wnode) {
953  			fuse_log(FUSE_LOG_DEBUG, "%s %llu (w)\n",
954  				msg, (unsigned long long) wnode->nodeid);
955  		} else {
956  			fuse_log(FUSE_LOG_DEBUG, "%s %llu\n",
957  				msg, (unsigned long long) nodeid);
958  		}
959  	}
960  }
961  static void queue_path(struct fuse *f, struct lock_queue_element *qe)
962  {
963  	struct lock_queue_element **qp;
964  	qe->done = false;
965  	pthread_cond_init(&qe->cond, NULL);
966  	qe->next = NULL;
967  	for (qp = &f->lockq; *qp != NULL; qp = &(*qp)->next);
968  	*qp = qe;
969  }
970  static void dequeue_path(struct fuse *f, struct lock_queue_element *qe)
971  {
972  	struct lock_queue_element **qp;
973  	pthread_cond_destroy(&qe->cond);
974  	for (qp = &f->lockq; *qp != qe; qp = &(*qp)->next);
975  	*qp = qe->next;
976  }
977  static int wait_path(struct fuse *f, struct lock_queue_element *qe)
978  {
979  	queue_path(f, qe);
980  	do {
981  		pthread_cond_wait(&qe->cond, &f->lock);
982  	} while (!qe->done);
983  	dequeue_path(f, qe);
984  	return qe->err;
985  }
986  static int get_path_common(struct fuse *f, fuse_ino_t nodeid, const char *name,
987  			   char **path, struct node **wnode)
988  {
989  	int err;
990  	pthread_mutex_lock(&f->lock);
991  	err = try_get_path(f, nodeid, name, path, wnode, true);
992  	if (err == -EAGAIN) {
993  		struct lock_queue_element qe = {
994  			.nodeid1 = nodeid,
995  			.name1 = name,
996  			.path1 = path,
997  			.wnode1 = wnode,
998  		};
999  		debug_path(f, "QUEUE PATH", nodeid, name, !!wnode);
1000  		err = wait_path(f, &qe);
1001  		debug_path(f, "DEQUEUE PATH", nodeid, name, !!wnode);
1002  	}
1003  	pthread_mutex_unlock(&f->lock);
1004  	return err;
1005  }
1006  static int get_path(struct fuse *f, fuse_ino_t nodeid, char **path)
1007  {
1008  	return get_path_common(f, nodeid, NULL, path, NULL);
1009  }
1010  static int get_path_nullok(struct fuse *f, fuse_ino_t nodeid, char **path)
1011  {
1012  	int err = 0;
1013  	if (f->conf.nullpath_ok) {
1014  		*path = NULL;
1015  	} else {
1016  		err = get_path_common(f, nodeid, NULL, path, NULL);
1017  		if (err == -ESTALE)
1018  			err = 0;
1019  	}
1020  	return err;
1021  }
1022  static int get_path_name(struct fuse *f, fuse_ino_t nodeid, const char *name,
1023  			 char **path)
1024  {
1025  	return get_path_common(f, nodeid, name, path, NULL);
1026  }
1027  static int get_path_wrlock(struct fuse *f, fuse_ino_t nodeid, const char *name,
1028  			   char **path, struct node **wnode)
1029  {
1030  	return get_path_common(f, nodeid, name, path, wnode);
1031  }
1032  #if defined(__FreeBSD__)
1033  #define CHECK_DIR_LOOP
1034  #endif
1035  #if defined(CHECK_DIR_LOOP)
1036  static int check_dir_loop(struct fuse *f,
1037  			  fuse_ino_t nodeid1, const char *name1,
1038  			  fuse_ino_t nodeid2, const char *name2)
1039  {
1040  	struct node *node, *node1, *node2;
1041  	fuse_ino_t id1, id2;
1042  	node1 = lookup_node(f, nodeid1, name1);
1043  	id1 = node1 ? node1->nodeid : nodeid1;
1044  	node2 = lookup_node(f, nodeid2, name2);
1045  	id2 = node2 ? node2->nodeid : nodeid2;
1046  	for (node = get_node(f, id2); node->nodeid != FUSE_ROOT_ID;
1047  	     node = node->parent) {
1048  		if (node->name == NULL || node->parent == NULL)
1049  			break;
1050  		if (node->nodeid != id2 && node->nodeid == id1)
1051  			return -EINVAL;
1052  	}
1053  	if (node2)
1054  	{
1055  		for (node = get_node(f, id1); node->nodeid != FUSE_ROOT_ID;
1056  		     node = node->parent) {
1057  			if (node->name == NULL || node->parent == NULL)
1058  				break;
1059  			if (node->nodeid != id1 && node->nodeid == id2)
1060  				return -ENOTEMPTY;
1061  		}
1062  	}
1063  	return 0;
1064  }
1065  #endif
1066  static int get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,
1067  		     fuse_ino_t nodeid2, const char *name2,
1068  		     char **path1, char **path2,
1069  		     struct node **wnode1, struct node **wnode2)
1070  {
1071  	int err;
1072  	pthread_mutex_lock(&f->lock);
1073  #if defined(CHECK_DIR_LOOP)
1074  	if (name1)
1075  	{
1076  		err = check_dir_loop(f, nodeid1, name1, nodeid2, name2);
1077  		if (err)
1078  			goto out_unlock;
1079  	}
1080  #endif
1081  	err = try_get_path2(f, nodeid1, name1, nodeid2, name2,
1082  			    path1, path2, wnode1, wnode2);
1083  	if (err == -EAGAIN) {
1084  		struct lock_queue_element qe = {
1085  			.nodeid1 = nodeid1,
1086  			.name1 = name1,
1087  			.path1 = path1,
1088  			.wnode1 = wnode1,
1089  			.nodeid2 = nodeid2,
1090  			.name2 = name2,
1091  			.path2 = path2,
1092  			.wnode2 = wnode2,
1093  		};
1094  		debug_path(f, "QUEUE PATH1", nodeid1, name1, !!wnode1);
1095  		debug_path(f, "      PATH2", nodeid2, name2, !!wnode2);
1096  		err = wait_path(f, &qe);
1097  		debug_path(f, "DEQUEUE PATH1", nodeid1, name1, !!wnode1);
1098  		debug_path(f, "        PATH2", nodeid2, name2, !!wnode2);
1099  	}
1100  #if defined(CHECK_DIR_LOOP)
1101  out_unlock:
1102  #endif
1103  	pthread_mutex_unlock(&f->lock);
1104  	return err;
1105  }
1106  static void free_path_wrlock(struct fuse *f, fuse_ino_t nodeid,
1107  			     struct node *wnode, char *path)
1108  {
1109  	pthread_mutex_lock(&f->lock);
1110  	unlock_path(f, nodeid, wnode, NULL);
1111  	if (f->lockq)
1112  		wake_up_queued(f);
1113  	pthread_mutex_unlock(&f->lock);
1114  	free(path);
1115  }
1116  static void free_path(struct fuse *f, fuse_ino_t nodeid, char *path)
1117  {
1118  	if (path)
1119  		free_path_wrlock(f, nodeid, NULL, path);
1120  }
1121  static void free_path2(struct fuse *f, fuse_ino_t nodeid1, fuse_ino_t nodeid2,
1122  		       struct node *wnode1, struct node *wnode2,
1123  		       char *path1, char *path2)
1124  {
1125  	pthread_mutex_lock(&f->lock);
1126  	unlock_path(f, nodeid1, wnode1, NULL);
1127  	unlock_path(f, nodeid2, wnode2, NULL);
1128  	wake_up_queued(f);
1129  	pthread_mutex_unlock(&f->lock);
1130  	free(path1);
1131  	free(path2);
1132  }
1133  static void forget_node(struct fuse *f, fuse_ino_t nodeid, uint64_t nlookup)
1134  {
1135  	struct node *node;
1136  	if (nodeid == FUSE_ROOT_ID)
1137  		return;
1138  	pthread_mutex_lock(&f->lock);
1139  	node = get_node(f, nodeid);
1140  	while (node->nlookup == nlookup && node->treelock) {
1141  		struct lock_queue_element qe = {
1142  			.nodeid1 = nodeid,
1143  		};
1144  		debug_path(f, "QUEUE PATH (forget)", nodeid, NULL, false);
1145  		queue_path(f, &qe);
1146  		do {
1147  			pthread_cond_wait(&qe.cond, &f->lock);
1148  		} while (node->nlookup == nlookup && node->treelock);
1149  		dequeue_path(f, &qe);
1150  		debug_path(f, "DEQUEUE_PATH (forget)", nodeid, NULL, false);
1151  	}
1152  	assert(node->nlookup >= nlookup);
1153  	node->nlookup -= nlookup;
1154  	if (!node->nlookup) {
1155  		unref_node(f, node);
1156  	} else if (lru_enabled(f) && node->nlookup == 1) {
1157  		set_forget_time(f, node);
1158  	}
1159  	pthread_mutex_unlock(&f->lock);
1160  }
1161  static void unlink_node(struct fuse *f, struct node *node)
1162  {
1163  	if (f->conf.remember) {
1164  		assert(node->nlookup > 1);
1165  		node->nlookup--;
1166  	}
1167  	unhash_name(f, node);
1168  }
1169  static void remove_node(struct fuse *f, fuse_ino_t dir, const char *name)
1170  {
1171  	struct node *node;
1172  	pthread_mutex_lock(&f->lock);
1173  	node = lookup_node(f, dir, name);
1174  	if (node != NULL)
1175  		unlink_node(f, node);
1176  	pthread_mutex_unlock(&f->lock);
1177  }
1178  static int rename_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,
1179  		       fuse_ino_t newdir, const char *newname, int hide)
1180  {
1181  	struct node *node;
1182  	struct node *newnode;
1183  	int err = 0;
1184  	pthread_mutex_lock(&f->lock);
1185  	node  = lookup_node(f, olddir, oldname);
1186  	newnode	 = lookup_node(f, newdir, newname);
1187  	if (node == NULL)
1188  		goto out;
1189  	if (newnode != NULL) {
1190  		if (hide) {
1191  			fuse_log(FUSE_LOG_ERR, "fuse: hidden file got created during hiding\n");
1192  			err = -EBUSY;
1193  			goto out;
1194  		}
1195  		unlink_node(f, newnode);
1196  	}
1197  	unhash_name(f, node);
1198  	if (hash_name(f, node, newdir, newname) == -1) {
1199  		err = -ENOMEM;
1200  		goto out;
1201  	}
1202  	if (hide)
1203  		node->is_hidden = 1;
1204  out:
1205  	pthread_mutex_unlock(&f->lock);
1206  	return err;
1207  }
1208  static int exchange_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,
1209  			 fuse_ino_t newdir, const char *newname)
1210  {
1211  	struct node *oldnode;
1212  	struct node *newnode;
1213  	int err;
1214  	pthread_mutex_lock(&f->lock);
1215  	oldnode  = lookup_node(f, olddir, oldname);
1216  	newnode	 = lookup_node(f, newdir, newname);
1217  	if (oldnode)
1218  		unhash_name(f, oldnode);
1219  	if (newnode)
1220  		unhash_name(f, newnode);
1221  	err = -ENOMEM;
1222  	if (oldnode) {
1223  		if (hash_name(f, oldnode, newdir, newname) == -1)
1224  			goto out;
1225  	}
1226  	if (newnode) {
1227  		if (hash_name(f, newnode, olddir, oldname) == -1)
1228  			goto out;
1229  	}
1230  	err = 0;
1231  out:
1232  	pthread_mutex_unlock(&f->lock);
1233  	return err;
1234  }
1235  static void set_stat(struct fuse *f, fuse_ino_t nodeid, struct stat *stbuf)
1236  {
1237  	if (!f->conf.use_ino)
1238  		stbuf->st_ino = nodeid;
1239  	if (f->conf.set_mode)
1240  		stbuf->st_mode = (stbuf->st_mode & S_IFMT) |
1241  				 (0777 & ~f->conf.umask);
1242  	if (f->conf.set_uid)
1243  		stbuf->st_uid = f->conf.uid;
1244  	if (f->conf.set_gid)
1245  		stbuf->st_gid = f->conf.gid;
1246  }
1247  static struct fuse *req_fuse(fuse_req_t req)
1248  {
1249  	return (struct fuse *) fuse_req_userdata(req);
1250  }
1251  static void fuse_intr_sighandler(int sig)
1252  {
1253  	(void) sig;
1254  }
1255  struct fuse_intr_data {
1256  	pthread_t id;
1257  	pthread_cond_t cond;
1258  	int finished;
1259  };
1260  static void fuse_interrupt(fuse_req_t req, void *d_)
1261  {
1262  	struct fuse_intr_data *d = d_;
1263  	struct fuse *f = req_fuse(req);
1264  	if (d->id == pthread_self())
1265  		return;
1266  	pthread_mutex_lock(&f->lock);
1267  	while (!d->finished) {
1268  		struct timeval now;
1269  		struct timespec timeout;
1270  		pthread_kill(d->id, f->conf.intr_signal);
1271  		gettimeofday(&now, NULL);
1272  		timeout.tv_sec = now.tv_sec + 1;
1273  		timeout.tv_nsec = now.tv_usec * 1000;
1274  		pthread_cond_timedwait(&d->cond, &f->lock, &timeout);
1275  	}
1276  	pthread_mutex_unlock(&f->lock);
1277  }
1278  static void fuse_do_finish_interrupt(struct fuse *f, fuse_req_t req,
1279  				     struct fuse_intr_data *d)
1280  {
1281  	pthread_mutex_lock(&f->lock);
1282  	d->finished = 1;
1283  	pthread_cond_broadcast(&d->cond);
1284  	pthread_mutex_unlock(&f->lock);
1285  	fuse_req_interrupt_func(req, NULL, NULL);
1286  	pthread_cond_destroy(&d->cond);
1287  }
1288  static void fuse_do_prepare_interrupt(fuse_req_t req, struct fuse_intr_data *d)
1289  {
1290  	d->id = pthread_self();
1291  	pthread_cond_init(&d->cond, NULL);
1292  	d->finished = 0;
1293  	fuse_req_interrupt_func(req, fuse_interrupt, d);
1294  }
1295  static inline void fuse_finish_interrupt(struct fuse *f, fuse_req_t req,
1296  					 struct fuse_intr_data *d)
1297  {
1298  	if (f->conf.intr)
1299  		fuse_do_finish_interrupt(f, req, d);
1300  }
1301  static inline void fuse_prepare_interrupt(struct fuse *f, fuse_req_t req,
1302  					  struct fuse_intr_data *d)
1303  {
1304  	if (f->conf.intr)
1305  		fuse_do_prepare_interrupt(req, d);
1306  }
1307  static const char* file_info_string(struct fuse_file_info *fi,
1308  			      char* buf, size_t len)
1309  {
1310  	if(fi == NULL)
1311  		return "NULL";
1312  	snprintf(buf, len, "%llu", (unsigned long long) fi->fh);
1313  	return buf;
1314  }
1315  int fuse_fs_getattr(struct fuse_fs *fs, const char *path, struct stat *buf,
1316  		    struct fuse_file_info *fi)
1317  {
1318  	fuse_get_context()->private_data = fs->user_data;
1319  	if (fs->op.getattr) {
1320  		if (fs->debug) {
1321  			char buf[10];
1322  			fuse_log(FUSE_LOG_DEBUG, "getattr[%s] %s\n",
1323  				file_info_string(fi, buf, sizeof(buf)),
1324  				path);
1325  		}
1326  		return fs->op.getattr(path, buf, fi);
1327  	} else {
1328  		return -ENOSYS;
1329  	}
1330  }
1331  int fuse_fs_rename(struct fuse_fs *fs, const char *oldpath,
1332  		   const char *newpath, unsigned int flags)
1333  {
1334  	fuse_get_context()->private_data = fs->user_data;
1335  	if (fs->op.rename) {
1336  		if (fs->debug)
1337  			fuse_log(FUSE_LOG_DEBUG, "rename %s %s 0x%x\n", oldpath, newpath,
1338  				flags);
1339  		return fs->op.rename(oldpath, newpath, flags);
1340  	} else {
1341  		return -ENOSYS;
1342  	}
1343  }
1344  int fuse_fs_unlink(struct fuse_fs *fs, const char *path)
1345  {
1346  	fuse_get_context()->private_data = fs->user_data;
1347  	if (fs->op.unlink) {
1348  		if (fs->debug)
1349  			fuse_log(FUSE_LOG_DEBUG, "unlink %s\n", path);
1350  		return fs->op.unlink(path);
1351  	} else {
1352  		return -ENOSYS;
1353  	}
1354  }
1355  int fuse_fs_rmdir(struct fuse_fs *fs, const char *path)
1356  {
1357  	fuse_get_context()->private_data = fs->user_data;
1358  	if (fs->op.rmdir) {
1359  		if (fs->debug)
1360  			fuse_log(FUSE_LOG_DEBUG, "rmdir %s\n", path);
1361  		return fs->op.rmdir(path);
1362  	} else {
1363  		return -ENOSYS;
1364  	}
1365  }
1366  int fuse_fs_symlink(struct fuse_fs *fs, const char *linkname, const char *path)
1367  {
1368  	fuse_get_context()->private_data = fs->user_data;
1369  	if (fs->op.symlink) {
1370  		if (fs->debug)
1371  			fuse_log(FUSE_LOG_DEBUG, "symlink %s %s\n", linkname, path);
1372  		return fs->op.symlink(linkname, path);
1373  	} else {
1374  		return -ENOSYS;
1375  	}
1376  }
1377  int fuse_fs_link(struct fuse_fs *fs, const char *oldpath, const char *newpath)
1378  {
1379  	fuse_get_context()->private_data = fs->user_data;
1380  	if (fs->op.link) {
1381  		if (fs->debug)
1382  			fuse_log(FUSE_LOG_DEBUG, "link %s %s\n", oldpath, newpath);
1383  		return fs->op.link(oldpath, newpath);
1384  	} else {
1385  		return -ENOSYS;
1386  	}
1387  }
1388  int fuse_fs_release(struct fuse_fs *fs,	 const char *path,
1389  		    struct fuse_file_info *fi)
1390  {
1391  	fuse_get_context()->private_data = fs->user_data;
1392  	if (fs->op.release) {
1393  		if (fs->debug)
1394  			fuse_log(FUSE_LOG_DEBUG, "release%s[%llu] flags: 0x%x\n",
1395  				fi->flush ? "+flush" : "",
1396  				(unsigned long long) fi->fh, fi->flags);
1397  		return fs->op.release(path, fi);
1398  	} else {
1399  		return 0;
1400  	}
1401  }
1402  int fuse_fs_opendir(struct fuse_fs *fs, const char *path,
1403  		    struct fuse_file_info *fi)
1404  {
1405  	fuse_get_context()->private_data = fs->user_data;
1406  	if (fs->op.opendir) {
1407  		int err;
1408  		if (fs->debug)
1409  			fuse_log(FUSE_LOG_DEBUG, "opendir flags: 0x%x %s\n", fi->flags,
1410  				path);
1411  		err = fs->op.opendir(path, fi);
1412  		if (fs->debug && !err)
1413  			fuse_log(FUSE_LOG_DEBUG, "   opendir[%llu] flags: 0x%x %s\n",
1414  				(unsigned long long) fi->fh, fi->flags, path);
1415  		return err;
1416  	} else {
1417  		return 0;
1418  	}
1419  }
1420  int fuse_fs_open(struct fuse_fs *fs, const char *path,
1421  		 struct fuse_file_info *fi)
1422  {
1423  	fuse_get_context()->private_data = fs->user_data;
1424  	if (fs->op.open) {
1425  		int err;
1426  		if (fs->debug)
1427  			fuse_log(FUSE_LOG_DEBUG, "open flags: 0x%x %s\n", fi->flags,
1428  				path);
1429  		err = fs->op.open(path, fi);
1430  		if (fs->debug && !err)
1431  			fuse_log(FUSE_LOG_DEBUG, "   open[%llu] flags: 0x%x %s\n",
1432  				(unsigned long long) fi->fh, fi->flags, path);
1433  		return err;
1434  	} else {
1435  		return 0;
1436  	}
1437  }
1438  static void fuse_free_buf(struct fuse_bufvec *buf)
1439  {
1440  	if (buf != NULL) {
1441  		size_t i;
1442  		for (i = 0; i < buf->count; i++)
1443  			if (!(buf->buf[i].flags & FUSE_BUF_IS_FD))
1444  				free(buf->buf[i].mem);
1445  		free(buf);
1446  	}
1447  }
1448  int fuse_fs_read_buf(struct fuse_fs *fs, const char *path,
1449  		     struct fuse_bufvec **bufp, size_t size, off_t off,
1450  		     struct fuse_file_info *fi)
1451  {
1452  	fuse_get_context()->private_data = fs->user_data;
1453  	if (fs->op.read || fs->op.read_buf) {
1454  		int res;
1455  		if (fs->debug)
1456  			fuse_log(FUSE_LOG_DEBUG,
1457  				"read[%llu] %zu bytes from %llu flags: 0x%x\n",
1458  				(unsigned long long) fi->fh,
1459  				size, (unsigned long long) off, fi->flags);
1460  		if (fs->op.read_buf) {
1461  			res = fs->op.read_buf(path, bufp, size, off, fi);
1462  		} else {
1463  			struct fuse_bufvec *buf;
1464  			void *mem;
1465  			buf = malloc(sizeof(struct fuse_bufvec));
1466  			if (buf == NULL)
1467  				return -ENOMEM;
1468  			mem = malloc(size);
1469  			if (mem == NULL) {
1470  				free(buf);
1471  				return -ENOMEM;
1472  			}
1473  			*buf = FUSE_BUFVEC_INIT(size);
1474  			buf->buf[0].mem = mem;
1475  			*bufp = buf;
1476  			res = fs->op.read(path, mem, size, off, fi);
1477  			if (res >= 0)
1478  				buf->buf[0].size = res;
1479  		}
1480  		if (fs->debug && res >= 0)
1481  			fuse_log(FUSE_LOG_DEBUG, "   read[%llu] %zu bytes from %llu\n",
1482  				(unsigned long long) fi->fh,
1483  				fuse_buf_size(*bufp),
1484  				(unsigned long long) off);
1485  		if (res >= 0 && fuse_buf_size(*bufp) > size)
1486  			fuse_log(FUSE_LOG_ERR, "fuse: read too many bytes\n");
1487  		if (res < 0)
1488  			return res;
1489  		return 0;
1490  	} else {
1491  		return -ENOSYS;
1492  	}
1493  }
1494  int fuse_fs_read(struct fuse_fs *fs, const char *path, char *mem, size_t size,
1495  		 off_t off, struct fuse_file_info *fi)
1496  {
1497  	fuse_get_context()->private_data = fs->user_data;
1498  	if (fs->op.read || fs->op.read_buf) {
1499  		int res;
1500  		if (fs->debug)
1501  			fuse_log(FUSE_LOG_DEBUG,
1502  				"read[%llu] %zu bytes from %llu flags: 0x%x\n",
1503  				(unsigned long long) fi->fh,
1504  				size, (unsigned long long) off, fi->flags);
1505  		if (fs->op.read_buf) {
1506  			struct fuse_bufvec *buf = NULL;
1507  			res = fs->op.read_buf(path, &buf, size, off, fi);
1508  			if (res == 0) {
1509  				struct fuse_bufvec dst = FUSE_BUFVEC_INIT(size);
1510  				dst.buf[0].mem = mem;
1511  				res = fuse_buf_copy(&dst, buf, 0);
1512  			}
1513  			fuse_free_buf(buf);
1514  		} else {
1515  			res = fs->op.read(path, mem, size, off, fi);
1516  		}
1517  		if (fs->debug && res >= 0)
1518  			fuse_log(FUSE_LOG_DEBUG, "   read[%llu] %u bytes from %llu\n",
1519  				(unsigned long long) fi->fh,
1520  				res,
1521  				(unsigned long long) off);
1522  		if (res >= 0 && res > (int) size)
1523  			fuse_log(FUSE_LOG_ERR, "fuse: read too many bytes\n");
1524  		return res;
1525  	} else {
1526  		return -ENOSYS;
1527  	}
1528  }
1529  int fuse_fs_write_buf(struct fuse_fs *fs, const char *path,
1530  		      struct fuse_bufvec *buf, off_t off,
1531  		      struct fuse_file_info *fi)
1532  {
1533  	fuse_get_context()->private_data = fs->user_data;
1534  	if (fs->op.write_buf || fs->op.write) {
1535  		int res;
1536  		size_t size = fuse_buf_size(buf);
1537  		assert(buf->idx == 0 && buf->off == 0);
1538  		if (fs->debug)
1539  			fuse_log(FUSE_LOG_DEBUG,
1540  				"write%s[%llu] %zu bytes to %llu flags: 0x%x\n",
1541  				fi->writepage ? "page" : "",
1542  				(unsigned long long) fi->fh,
1543  				size,
1544  				(unsigned long long) off,
1545  				fi->flags);
1546  		if (fs->op.write_buf) {
1547  			res = fs->op.write_buf(path, buf, off, fi);
1548  		} else {
1549  			void *mem = NULL;
1550  			struct fuse_buf *flatbuf;
1551  			struct fuse_bufvec tmp = FUSE_BUFVEC_INIT(size);
1552  			if (buf->count == 1 &&
1553  			    !(buf->buf[0].flags & FUSE_BUF_IS_FD)) {
1554  				flatbuf = &buf->buf[0];
1555  			} else {
1556  				res = -ENOMEM;
1557  				mem = malloc(size);
1558  				if (mem == NULL)
1559  					goto out;
1560  				tmp.buf[0].mem = mem;
1561  				res = fuse_buf_copy(&tmp, buf, 0);
1562  				if (res <= 0)
1563  					goto out_free;
1564  				tmp.buf[0].size = res;
1565  				flatbuf = &tmp.buf[0];
1566  			}
1567  			res = fs->op.write(path, flatbuf->mem, flatbuf->size,
1568  					   off, fi);
1569  out_free:
1570  			free(mem);
1571  		}
1572  out:
1573  		if (fs->debug && res >= 0)
1574  			fuse_log(FUSE_LOG_DEBUG, "   write%s[%llu] %u bytes to %llu\n",
1575  				fi->writepage ? "page" : "",
1576  				(unsigned long long) fi->fh, res,
1577  				(unsigned long long) off);
1578  		if (res > (int) size)
1579  			fuse_log(FUSE_LOG_ERR, "fuse: wrote too many bytes\n");
1580  		return res;
1581  	} else {
1582  		return -ENOSYS;
1583  	}
1584  }
1585  int fuse_fs_write(struct fuse_fs *fs, const char *path, const char *mem,
1586  		  size_t size, off_t off, struct fuse_file_info *fi)
1587  {
1588  	struct fuse_bufvec bufv = FUSE_BUFVEC_INIT(size);
1589  	bufv.buf[0].mem = (void *) mem;
1590  	return fuse_fs_write_buf(fs, path, &bufv, off, fi);
1591  }
1592  int fuse_fs_fsync(struct fuse_fs *fs, const char *path, int datasync,
1593  		  struct fuse_file_info *fi)
1594  {
1595  	fuse_get_context()->private_data = fs->user_data;
1596  	if (fs->op.fsync) {
1597  		if (fs->debug)
1598  			fuse_log(FUSE_LOG_DEBUG, "fsync[%llu] datasync: %i\n",
1599  				(unsigned long long) fi->fh, datasync);
1600  		return fs->op.fsync(path, datasync, fi);
1601  	} else {
1602  		return -ENOSYS;
1603  	}
1604  }
1605  int fuse_fs_fsyncdir(struct fuse_fs *fs, const char *path, int datasync,
1606  		     struct fuse_file_info *fi)
1607  {
1608  	fuse_get_context()->private_data = fs->user_data;
1609  	if (fs->op.fsyncdir) {
1610  		if (fs->debug)
1611  			fuse_log(FUSE_LOG_DEBUG, "fsyncdir[%llu] datasync: %i\n",
1612  				(unsigned long long) fi->fh, datasync);
1613  		return fs->op.fsyncdir(path, datasync, fi);
1614  	} else {
1615  		return -ENOSYS;
1616  	}
1617  }
1618  int fuse_fs_flush(struct fuse_fs *fs, const char *path,
1619  		  struct fuse_file_info *fi)
1620  {
1621  	fuse_get_context()->private_data = fs->user_data;
1622  	if (fs->op.flush) {
1623  		if (fs->debug)
1624  			fuse_log(FUSE_LOG_DEBUG, "flush[%llu]\n",
1625  				(unsigned long long) fi->fh);
1626  		return fs->op.flush(path, fi);
1627  	} else {
1628  		return -ENOSYS;
1629  	}
1630  }
1631  int fuse_fs_statfs(struct fuse_fs *fs, const char *path, struct statvfs *buf)
1632  {
1633  	fuse_get_context()->private_data = fs->user_data;
1634  	if (fs->op.statfs) {
1635  		if (fs->debug)
1636  			fuse_log(FUSE_LOG_DEBUG, "statfs %s\n", path);
1637  		return fs->op.statfs(path, buf);
1638  	} else {
1639  		buf->f_namemax = 255;
1640  		buf->f_bsize = 512;
1641  		return 0;
1642  	}
1643  }
1644  int fuse_fs_releasedir(struct fuse_fs *fs, const char *path,
1645  		       struct fuse_file_info *fi)
1646  {
1647  	fuse_get_context()->private_data = fs->user_data;
1648  	if (fs->op.releasedir) {
1649  		if (fs->debug)
1650  			fuse_log(FUSE_LOG_DEBUG, "releasedir[%llu] flags: 0x%x\n",
1651  				(unsigned long long) fi->fh, fi->flags);
1652  		return fs->op.releasedir(path, fi);
1653  	} else {
1654  		return 0;
1655  	}
1656  }
1657  int fuse_fs_readdir(struct fuse_fs *fs, const char *path, void *buf,
1658  		    fuse_fill_dir_t filler, off_t off,
1659  		    struct fuse_file_info *fi,
1660  		    enum fuse_readdir_flags flags)
1661  {
1662  	fuse_get_context()->private_data = fs->user_data;
1663  	if (fs->op.readdir) {
1664  		if (fs->debug) {
1665  			fuse_log(FUSE_LOG_DEBUG, "readdir%s[%llu] from %llu\n",
1666  				(flags & FUSE_READDIR_PLUS) ? "plus" : "",
1667  				(unsigned long long) fi->fh,
1668  				(unsigned long long) off);
1669  		}
1670  		return fs->op.readdir(path, buf, filler, off, fi, flags);
1671  	} else {
1672  		return -ENOSYS;
1673  	}
1674  }
1675  int fuse_fs_create(struct fuse_fs *fs, const char *path, mode_t mode,
1676  		   struct fuse_file_info *fi)
1677  {
1678  	fuse_get_context()->private_data = fs->user_data;
1679  	if (fs->op.create) {
1680  		int err;
1681  		if (fs->debug)
1682  			fuse_log(FUSE_LOG_DEBUG,
1683  				"create flags: 0x%x %s 0%o umask=0%03o\n",
1684  				fi->flags, path, mode,
1685  				fuse_get_context()->umask);
1686  		err = fs->op.create(path, mode, fi);
1687  		if (fs->debug && !err)
1688  			fuse_log(FUSE_LOG_DEBUG, "   create[%llu] flags: 0x%x %s\n",
1689  				(unsigned long long) fi->fh, fi->flags, path);
1690  		return err;
1691  	} else {
1692  		return -ENOSYS;
1693  	}
1694  }
1695  int fuse_fs_lock(struct fuse_fs *fs, const char *path,
1696  		 struct fuse_file_info *fi, int cmd, struct flock *lock)
1697  {
1698  	fuse_get_context()->private_data = fs->user_data;
1699  	if (fs->op.lock) {
1700  		if (fs->debug)
1701  			fuse_log(FUSE_LOG_DEBUG, "lock[%llu] %s %s start: %llu len: %llu pid: %llu\n",
1702  				(unsigned long long) fi->fh,
1703  				(cmd == F_GETLK ? "F_GETLK" :
1704  				 (cmd == F_SETLK ? "F_SETLK" :
1705  				  (cmd == F_SETLKW ? "F_SETLKW" : "???"))),
1706  				(lock->l_type == F_RDLCK ? "F_RDLCK" :
1707  				 (lock->l_type == F_WRLCK ? "F_WRLCK" :
1708  				  (lock->l_type == F_UNLCK ? "F_UNLCK" :
1709  				   "???"))),
1710  				(unsigned long long) lock->l_start,
1711  				(unsigned long long) lock->l_len,
1712  				(unsigned long long) lock->l_pid);
1713  		return fs->op.lock(path, fi, cmd, lock);
1714  	} else {
1715  		return -ENOSYS;
1716  	}
1717  }
1718  int fuse_fs_flock(struct fuse_fs *fs, const char *path,
1719  		  struct fuse_file_info *fi, int op)
1720  {
1721  	fuse_get_context()->private_data = fs->user_data;
1722  	if (fs->op.flock) {
1723  		if (fs->debug) {
1724  			int xop = op & ~LOCK_NB;
1725  			fuse_log(FUSE_LOG_DEBUG, "lock[%llu] %s%s\n",
1726  				(unsigned long long) fi->fh,
1727  				xop == LOCK_SH ? "LOCK_SH" :
1728  				(xop == LOCK_EX ? "LOCK_EX" :
1729  				 (xop == LOCK_UN ? "LOCK_UN" : "???")),
1730  				(op & LOCK_NB) ? "|LOCK_NB" : "");
1731  		}
1732  		return fs->op.flock(path, fi, op);
1733  	} else {
1734  		return -ENOSYS;
1735  	}
1736  }
1737  int fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid,
1738  		  gid_t gid, struct fuse_file_info *fi)
1739  {
1740  	fuse_get_context()->private_data = fs->user_data;
1741  	if (fs->op.chown) {
1742  		if (fs->debug) {
1743  			char buf[10];
1744  			fuse_log(FUSE_LOG_DEBUG, "chown[%s] %s %lu %lu\n",
1745  				file_info_string(fi, buf, sizeof(buf)),
1746  				path, (unsigned long) uid, (unsigned long) gid);
1747  		}
1748  		return fs->op.chown(path, uid, gid, fi);
1749  	} else {
1750  		return -ENOSYS;
1751  	}
1752  }
1753  int fuse_fs_truncate(struct fuse_fs *fs, const char *path, off_t size,
1754  		      struct fuse_file_info *fi)
1755  {
1756  	fuse_get_context()->private_data = fs->user_data;
1757  	if (fs->op.truncate) {
1758  		if (fs->debug) {
1759  			char buf[10];
1760  			fuse_log(FUSE_LOG_DEBUG, "truncate[%s] %llu\n",
1761  				file_info_string(fi, buf, sizeof(buf)),
1762  				(unsigned long long) size);
1763  		}
1764  		return fs->op.truncate(path, size, fi);
1765  	} else {
1766  		return -ENOSYS;
1767  	}
1768  }
1769  int fuse_fs_utimens(struct fuse_fs *fs, const char *path,
1770  		    const struct timespec tv[2], struct fuse_file_info *fi)
1771  {
1772  	fuse_get_context()->private_data = fs->user_data;
1773  	if (fs->op.utimens) {
1774  		if (fs->debug) {
1775  			char buf[10];
1776  			fuse_log(FUSE_LOG_DEBUG, "utimens[%s] %s %li.%09lu %li.%09lu\n",
1777  				file_info_string(fi, buf, sizeof(buf)),
1778  				path, tv[0].tv_sec, tv[0].tv_nsec,
1779  				tv[1].tv_sec, tv[1].tv_nsec);
1780  		}
1781  		return fs->op.utimens(path, tv, fi);
1782  	} else {
1783  		return -ENOSYS;
1784  	}
1785  }
1786  int fuse_fs_access(struct fuse_fs *fs, const char *path, int mask)
1787  {
1788  	fuse_get_context()->private_data = fs->user_data;
1789  	if (fs->op.access) {
1790  		if (fs->debug)
1791  			fuse_log(FUSE_LOG_DEBUG, "access %s 0%o\n", path, mask);
1792  		return fs->op.access(path, mask);
1793  	} else {
1794  		return -ENOSYS;
1795  	}
1796  }
1797  int fuse_fs_readlink(struct fuse_fs *fs, const char *path, char *buf,
1798  		     size_t len)
1799  {
1800  	fuse_get_context()->private_data = fs->user_data;
1801  	if (fs->op.readlink) {
1802  		if (fs->debug)
1803  			fuse_log(FUSE_LOG_DEBUG, "readlink %s %lu\n", path,
1804  				(unsigned long) len);
1805  		return fs->op.readlink(path, buf, len);
1806  	} else {
1807  		return -ENOSYS;
1808  	}
1809  }
1810  int fuse_fs_mknod(struct fuse_fs *fs, const char *path, mode_t mode,
1811  		  dev_t rdev)
1812  {
1813  	fuse_get_context()->private_data = fs->user_data;
1814  	if (fs->op.mknod) {
1815  		if (fs->debug)
1816  			fuse_log(FUSE_LOG_DEBUG, "mknod %s 0%o 0x%llx umask=0%03o\n",
1817  				path, mode, (unsigned long long) rdev,
1818  				fuse_get_context()->umask);
1819  		return fs->op.mknod(path, mode, rdev);
1820  	} else {
1821  		return -ENOSYS;
1822  	}
1823  }
1824  int fuse_fs_mkdir(struct fuse_fs *fs, const char *path, mode_t mode)
1825  {
1826  	fuse_get_context()->private_data = fs->user_data;
1827  	if (fs->op.mkdir) {
1828  		if (fs->debug)
1829  			fuse_log(FUSE_LOG_DEBUG, "mkdir %s 0%o umask=0%03o\n",
1830  				path, mode, fuse_get_context()->umask);
1831  		return fs->op.mkdir(path, mode);
1832  	} else {
1833  		return -ENOSYS;
1834  	}
1835  }
1836  int fuse_fs_setxattr(struct fuse_fs *fs, const char *path, const char *name,
1837  		     const char *value, size_t size, int flags)
1838  {
1839  	fuse_get_context()->private_data = fs->user_data;
1840  	if (fs->op.setxattr) {
1841  		if (fs->debug)
1842  			fuse_log(FUSE_LOG_DEBUG, "setxattr %s %s %lu 0x%x\n",
1843  				path, name, (unsigned long) size, flags);
1844  		return fs->op.setxattr(path, name, value, size, flags);
1845  	} else {
1846  		return -ENOSYS;
1847  	}
1848  }
1849  int fuse_fs_getxattr(struct fuse_fs *fs, const char *path, const char *name,
1850  		     char *value, size_t size)
1851  {
1852  	fuse_get_context()->private_data = fs->user_data;
1853  	if (fs->op.getxattr) {
1854  		if (fs->debug)
1855  			fuse_log(FUSE_LOG_DEBUG, "getxattr %s %s %lu\n",
1856  				path, name, (unsigned long) size);
1857  		return fs->op.getxattr(path, name, value, size);
1858  	} else {
1859  		return -ENOSYS;
1860  	}
1861  }
1862  int fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,
1863  		      size_t size)
1864  {
1865  	fuse_get_context()->private_data = fs->user_data;
1866  	if (fs->op.listxattr) {
1867  		if (fs->debug)
1868  			fuse_log(FUSE_LOG_DEBUG, "listxattr %s %lu\n",
1869  				path, (unsigned long) size);
1870  		return fs->op.listxattr(path, list, size);
1871  	} else {
1872  		return -ENOSYS;
1873  	}
1874  }
1875  int fuse_fs_bmap(struct fuse_fs *fs, const char *path, size_t blocksize,
1876  		 uint64_t *idx)
1877  {
1878  	fuse_get_context()->private_data = fs->user_data;
1879  	if (fs->op.bmap) {
1880  		if (fs->debug)
1881  			fuse_log(FUSE_LOG_DEBUG, "bmap %s blocksize: %lu index: %llu\n",
1882  				path, (unsigned long) blocksize,
1883  				(unsigned long long) *idx);
1884  		return fs->op.bmap(path, blocksize, idx);
1885  	} else {
1886  		return -ENOSYS;
1887  	}
1888  }
1889  int fuse_fs_removexattr(struct fuse_fs *fs, const char *path, const char *name)
1890  {
1891  	fuse_get_context()->private_data = fs->user_data;
1892  	if (fs->op.removexattr) {
1893  		if (fs->debug)
1894  			fuse_log(FUSE_LOG_DEBUG, "removexattr %s %s\n", path, name);
1895  		return fs->op.removexattr(path, name);
1896  	} else {
1897  		return -ENOSYS;
1898  	}
1899  }
1900  int fuse_fs_ioctl(struct fuse_fs *fs, const char *path, unsigned int cmd,
1901  		  void *arg, struct fuse_file_info *fi, unsigned int flags,
1902  		  void *data)
1903  {
1904  	fuse_get_context()->private_data = fs->user_data;
1905  	if (fs->op.ioctl) {
1906  		if (fs->debug)
1907  			fuse_log(FUSE_LOG_DEBUG, "ioctl[%llu] 0x%x flags: 0x%x\n",
1908  				(unsigned long long) fi->fh, cmd, flags);
1909  		return fs->op.ioctl(path, cmd, arg, fi, flags, data);
1910  	} else
1911  		return -ENOSYS;
1912  }
1913  int fuse_fs_poll(struct fuse_fs *fs, const char *path,
1914  		 struct fuse_file_info *fi, struct fuse_pollhandle *ph,
1915  		 unsigned *reventsp)
1916  {
1917  	fuse_get_context()->private_data = fs->user_data;
1918  	if (fs->op.poll) {
1919  		int res;
1920  		if (fs->debug)
1921  			fuse_log(FUSE_LOG_DEBUG, "poll[%llu] ph: %p, events 0x%x\n",
1922  				(unsigned long long) fi->fh, ph,
1923  				fi->poll_events);
1924  		res = fs->op.poll(path, fi, ph, reventsp);
1925  		if (fs->debug && !res)
1926  			fuse_log(FUSE_LOG_DEBUG, "   poll[%llu] revents: 0x%x\n",
1927  				(unsigned long long) fi->fh, *reventsp);
1928  		return res;
1929  	} else
1930  		return -ENOSYS;
1931  }
1932  int fuse_fs_fallocate(struct fuse_fs *fs, const char *path, int mode,
1933  		off_t offset, off_t length, struct fuse_file_info *fi)
1934  {
1935  	fuse_get_context()->private_data = fs->user_data;
1936  	if (fs->op.fallocate) {
1937  		if (fs->debug)
1938  			fuse_log(FUSE_LOG_DEBUG, "fallocate %s mode %x, offset: %llu, length: %llu\n",
1939  				path,
1940  				mode,
1941  				(unsigned long long) offset,
1942  				(unsigned long long) length);
1943  		return fs->op.fallocate(path, mode, offset, length, fi);
1944  	} else
1945  		return -ENOSYS;
1946  }
1947  ssize_t fuse_fs_copy_file_range(struct fuse_fs *fs, const char *path_in,
1948  				struct fuse_file_info *fi_in, off_t off_in,
1949  				const char *path_out,
1950  				struct fuse_file_info *fi_out, off_t off_out,
1951  				size_t len, int flags)
1952  {
1953  	fuse_get_context()->private_data = fs->user_data;
1954  	if (fs->op.copy_file_range) {
1955  		if (fs->debug)
1956  			fuse_log(FUSE_LOG_DEBUG, "copy_file_range from %s:%llu to "
1957  			                "%s:%llu, length: %llu\n",
1958  				path_in,
1959  				(unsigned long long) off_in,
1960  				path_out,
1961  				(unsigned long long) off_out,
1962  				(unsigned long long) len);
1963  		return fs->op.copy_file_range(path_in, fi_in, off_in, path_out,
1964  					      fi_out, off_out, len, flags);
1965  	} else
1966  		return -ENOSYS;
1967  }
1968  off_t fuse_fs_lseek(struct fuse_fs *fs, const char *path, off_t off, int whence,
1969  		    struct fuse_file_info *fi)
1970  {
1971  	fuse_get_context()->private_data = fs->user_data;
1972  	if (fs->op.lseek) {
1973  		if (fs->debug) {
1974  			char buf[10];
1975  			fuse_log(FUSE_LOG_DEBUG, "lseek[%s] %llu %d\n",
1976  				file_info_string(fi, buf, sizeof(buf)),
1977  				(unsigned long long) off, whence);
1978  		}
1979  		return fs->op.lseek(path, off, whence, fi);
1980  	} else {
1981  		return -ENOSYS;
1982  	}
1983  }
1984  static int is_open(struct fuse *f, fuse_ino_t dir, const char *name)
1985  {
1986  	struct node *node;
1987  	int isopen = 0;
1988  	pthread_mutex_lock(&f->lock);
1989  	node = lookup_node(f, dir, name);
1990  	if (node && node->open_count > 0)
1991  		isopen = 1;
1992  	pthread_mutex_unlock(&f->lock);
1993  	return isopen;
1994  }
1995  static char *hidden_name(struct fuse *f, fuse_ino_t dir, const char *oldname,
1996  			 char *newname, size_t bufsize)
1997  {
1998  	struct stat buf;
1999  	struct node *node;
2000  	struct node *newnode;
2001  	char *newpath;
2002  	int res;
2003  	int failctr = 10;
2004  	do {
2005  		pthread_mutex_lock(&f->lock);
2006  		node = lookup_node(f, dir, oldname);
2007  		if (node == NULL) {
2008  			pthread_mutex_unlock(&f->lock);
2009  			return NULL;
2010  		}
2011  		do {
2012  			f->hidectr ++;
2013  			snprintf(newname, bufsize, ".fuse_hidden%08x%08x",
2014  				 (unsigned int) node->nodeid, f->hidectr);
2015  			newnode = lookup_node(f, dir, newname);
2016  		} while(newnode);
2017  		res = try_get_path(f, dir, newname, &newpath, NULL, false);
2018  		pthread_mutex_unlock(&f->lock);
2019  		if (res)
2020  			break;
2021  		memset(&buf, 0, sizeof(buf));
2022  		res = fuse_fs_getattr(f->fs, newpath, &buf, NULL);
2023  		if (res == -ENOENT)
2024  			break;
2025  		free(newpath);
2026  		newpath = NULL;
2027  	} while(res == 0 && --failctr);
2028  	return newpath;
2029  }
2030  static int hide_node(struct fuse *f, const char *oldpath,
2031  		     fuse_ino_t dir, const char *oldname)
2032  {
2033  	char newname[64];
2034  	char *newpath;
2035  	int err = -EBUSY;
2036  	newpath = hidden_name(f, dir, oldname, newname, sizeof(newname));
2037  	if (newpath) {
2038  		err = fuse_fs_rename(f->fs, oldpath, newpath, 0);
2039  		if (!err)
2040  			err = rename_node(f, dir, oldname, dir, newname, 1);
2041  		free(newpath);
2042  	}
2043  	return err;
2044  }
2045  static int mtime_eq(const struct stat *stbuf, const struct timespec *ts)
2046  {
2047  	return stbuf->st_mtime == ts->tv_sec &&
2048  		ST_MTIM_NSEC(stbuf) == ts->tv_nsec;
2049  }
2050  #ifndef CLOCK_MONOTONIC
2051  #define CLOCK_MONOTONIC CLOCK_REALTIME
2052  #endif
2053  static void curr_time(struct timespec *now)
2054  {
2055  	static clockid_t clockid = CLOCK_MONOTONIC;
2056  	int res = clock_gettime(clockid, now);
2057  	if (res == -1 && errno == EINVAL) {
2058  		clockid = CLOCK_REALTIME;
2059  		res = clock_gettime(clockid, now);
2060  	}
2061  	if (res == -1) {
2062  		perror("fuse: clock_gettime");
2063  		abort();
2064  	}
2065  }
2066  static void update_stat(struct node *node, const struct stat *stbuf)
2067  {
2068  	if (node->cache_valid && (!mtime_eq(stbuf, &node->mtime) ||
2069  				  stbuf->st_size != node->size))
2070  		node->cache_valid = 0;
2071  	node->mtime.tv_sec = stbuf->st_mtime;
2072  	node->mtime.tv_nsec = ST_MTIM_NSEC(stbuf);
2073  	node->size = stbuf->st_size;
2074  	curr_time(&node->stat_updated);
2075  }
2076  static int do_lookup(struct fuse *f, fuse_ino_t nodeid, const char *name,
2077  		     struct fuse_entry_param *e)
2078  {
2079  	struct node *node;
2080  	node = find_node(f, nodeid, name);
2081  	if (node == NULL)
2082  		return -ENOMEM;
2083  	e->ino = node->nodeid;
2084  	e->generation = node->generation;
2085  	e->entry_timeout = f->conf.entry_timeout;
2086  	e->attr_timeout = f->conf.attr_timeout;
2087  	if (f->conf.auto_cache) {
2088  		pthread_mutex_lock(&f->lock);
2089  		update_stat(node, &e->attr);
2090  		pthread_mutex_unlock(&f->lock);
2091  	}
2092  	set_stat(f, e->ino, &e->attr);
2093  	return 0;
2094  }
2095  static int lookup_path(struct fuse *f, fuse_ino_t nodeid,
2096  		       const char *name, const char *path,
2097  		       struct fuse_entry_param *e, struct fuse_file_info *fi)
2098  {
2099  	int res;
2100  	memset(e, 0, sizeof(struct fuse_entry_param));
2101  	res = fuse_fs_getattr(f->fs, path, &e->attr, fi);
2102  	if (res == 0) {
2103  		res = do_lookup(f, nodeid, name, e);
2104  		if (res == 0 && f->conf.debug) {
2105  			fuse_log(FUSE_LOG_DEBUG, "   NODEID: %llu\n",
2106  				(unsigned long long) e->ino);
2107  		}
2108  	}
2109  	return res;
2110  }
2111  static struct fuse_context_i *fuse_get_context_internal(void)
2112  {
2113  	return (struct fuse_context_i *) pthread_getspecific(fuse_context_key);
2114  }
2115  static struct fuse_context_i *fuse_create_context(struct fuse *f)
2116  {
2117  	struct fuse_context_i *c = fuse_get_context_internal();
2118  	if (c == NULL) {
2119  		c = (struct fuse_context_i *)
2120  			calloc(1, sizeof(struct fuse_context_i));
2121  		if (c == NULL) {
2122  			fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate thread specific data\n");
2123  			abort();
2124  		}
2125  		pthread_setspecific(fuse_context_key, c);
2126  	} else {
2127  		memset(c, 0, sizeof(*c));
2128  	}
2129  	c->ctx.fuse = f;
2130  	return c;
2131  }
2132  static void fuse_freecontext(void *data)
2133  {
2134  	free(data);
2135  }
2136  static int fuse_create_context_key(void)
2137  {
2138  	int err = 0;
2139  	pthread_mutex_lock(&fuse_context_lock);
2140  	if (!fuse_context_ref) {
2141  		err = pthread_key_create(&fuse_context_key, fuse_freecontext);
2142  		if (err) {
2143  			fuse_log(FUSE_LOG_ERR, "fuse: failed to create thread specific key: %s\n",
2144  				strerror(err));
2145  			pthread_mutex_unlock(&fuse_context_lock);
2146  			return -1;
2147  		}
2148  	}
2149  	fuse_context_ref++;
2150  	pthread_mutex_unlock(&fuse_context_lock);
2151  	return 0;
2152  }
2153  static void fuse_delete_context_key(void)
2154  {
2155  	pthread_mutex_lock(&fuse_context_lock);
2156  	fuse_context_ref--;
2157  	if (!fuse_context_ref) {
2158  		free(pthread_getspecific(fuse_context_key));
2159  		pthread_key_delete(fuse_context_key);
2160  	}
2161  	pthread_mutex_unlock(&fuse_context_lock);
2162  }
2163  static struct fuse *req_fuse_prepare(fuse_req_t req)
2164  {
2165  	struct fuse_context_i *c = fuse_create_context(req_fuse(req));
2166  	const struct fuse_ctx *ctx = fuse_req_ctx(req);
2167  	c->req = req;
2168  	c->ctx.uid = ctx->uid;
2169  	c->ctx.gid = ctx->gid;
2170  	c->ctx.pid = ctx->pid;
2171  	c->ctx.umask = ctx->umask;
2172  	return c->ctx.fuse;
2173  }
2174  static inline void reply_err(fuse_req_t req, int err)
2175  {
2176  	fuse_reply_err(req, -err);
2177  }
2178  static void reply_entry(fuse_req_t req, const struct fuse_entry_param *e,
2179  			int err)
2180  {
2181  	if (!err) {
2182  		struct fuse *f = req_fuse(req);
2183  		if (fuse_reply_entry(req, e) == -ENOENT) {
2184  			if  (e->ino != 0)
2185  				forget_node(f, e->ino, 1);
2186  		}
2187  	} else
2188  		reply_err(req, err);
2189  }
2190  void fuse_fs_init(struct fuse_fs *fs, struct fuse_conn_info *conn,
2191  		  struct fuse_config *cfg)
2192  {
2193  	fuse_get_context()->private_data = fs->user_data;
2194  	if (!fs->op.write_buf)
2195  		conn->want &= ~FUSE_CAP_SPLICE_READ;
2196  	if (!fs->op.lock)
2197  		conn->want &= ~FUSE_CAP_POSIX_LOCKS;
2198  	if (!fs->op.flock)
2199  		conn->want &= ~FUSE_CAP_FLOCK_LOCKS;
2200  	if (fs->op.init)
2201  		fs->user_data = fs->op.init(conn, cfg);
2202  }
2203  static void fuse_lib_init(void *data, struct fuse_conn_info *conn)
2204  {
2205  	struct fuse *f = (struct fuse *) data;
2206  	fuse_create_context(f);
2207  	if(conn->capable & FUSE_CAP_EXPORT_SUPPORT)
2208  		conn->want |= FUSE_CAP_EXPORT_SUPPORT;
2209  	fuse_fs_init(f->fs, conn, &f->conf);
2210  }
2211  void fuse_fs_destroy(struct fuse_fs *fs)
2212  {
2213  	fuse_get_context()->private_data = fs->user_data;
2214  	if (fs->op.destroy)
2215  		fs->op.destroy(fs->user_data);
2216  }
2217  static void fuse_lib_destroy(void *data)
2218  {
2219  	struct fuse *f = (struct fuse *) data;
2220  	fuse_create_context(f);
2221  	fuse_fs_destroy(f->fs);
2222  }
2223  static void fuse_lib_lookup(fuse_req_t req, fuse_ino_t parent,
2224  			    const char *name)
2225  {
2226  	struct fuse *f = req_fuse_prepare(req);
2227  	struct fuse_entry_param e;
2228  	char *path;
2229  	int err;
2230  	struct node *dot = NULL;
2231  	if (name[0] == '.') {
2232  		int len = strlen(name);
2233  		if (len == 1 || (name[1] == '.' && len == 2)) {
2234  			pthread_mutex_lock(&f->lock);
2235  			if (len == 1) {
2236  				if (f->conf.debug)
2237  					fuse_log(FUSE_LOG_DEBUG, "LOOKUP-DOT\n");
2238  				dot = get_node_nocheck(f, parent);
2239  				if (dot == NULL) {
2240  					pthread_mutex_unlock(&f->lock);
2241  					reply_entry(req, &e, -ESTALE);
2242  					return;
2243  				}
2244  				dot->refctr++;
2245  			} else {
2246  				if (f->conf.debug)
2247  					fuse_log(FUSE_LOG_DEBUG, "LOOKUP-DOTDOT\n");
2248  				parent = get_node(f, parent)->parent->nodeid;
2249  			}
2250  			pthread_mutex_unlock(&f->lock);
2251  			name = NULL;
2252  		}
2253  	}
2254  	err = get_path_name(f, parent, name, &path);
2255  	if (!err) {
2256  		struct fuse_intr_data d;
2257  		if (f->conf.debug)
2258  			fuse_log(FUSE_LOG_DEBUG, "LOOKUP %s\n", path);
2259  		fuse_prepare_interrupt(f, req, &d);
2260  		err = lookup_path(f, parent, name, path, &e, NULL);
2261  		if (err == -ENOENT && f->conf.negative_timeout != 0.0) {
2262  			e.ino = 0;
2263  			e.entry_timeout = f->conf.negative_timeout;
2264  			err = 0;
2265  		}
2266  		fuse_finish_interrupt(f, req, &d);
2267  		free_path(f, parent, path);
2268  	}
2269  	if (dot) {
2270  		pthread_mutex_lock(&f->lock);
2271  		unref_node(f, dot);
2272  		pthread_mutex_unlock(&f->lock);
2273  	}
2274  	reply_entry(req, &e, err);
2275  }
2276  static void do_forget(struct fuse *f, fuse_ino_t ino, uint64_t nlookup)
2277  {
2278  	if (f->conf.debug)
2279  		fuse_log(FUSE_LOG_DEBUG, "FORGET %llu/%llu\n", (unsigned long long)ino,
2280  			(unsigned long long) nlookup);
2281  	forget_node(f, ino, nlookup);
2282  }
2283  static void fuse_lib_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)
2284  {
2285  	do_forget(req_fuse(req), ino, nlookup);
2286  	fuse_reply_none(req);
2287  }
2288  static void fuse_lib_forget_multi(fuse_req_t req, size_t count,
2289  				  struct fuse_forget_data *forgets)
2290  {
2291  	struct fuse *f = req_fuse(req);
2292  	size_t i;
2293  	for (i = 0; i < count; i++)
2294  		do_forget(f, forgets[i].ino, forgets[i].nlookup);
2295  	fuse_reply_none(req);
2296  }
2297  static void fuse_lib_getattr(fuse_req_t req, fuse_ino_t ino,
2298  			     struct fuse_file_info *fi)
2299  {
2300  	struct fuse *f = req_fuse_prepare(req);
2301  	struct stat buf;
2302  	char *path;
2303  	int err;
2304  	memset(&buf, 0, sizeof(buf));
2305  	if (fi != NULL)
2306  		err = get_path_nullok(f, ino, &path);
2307  	else
2308  		err = get_path(f, ino, &path);
2309  	if (!err) {
2310  		struct fuse_intr_data d;
2311  		fuse_prepare_interrupt(f, req, &d);
2312  		err = fuse_fs_getattr(f->fs, path, &buf, fi);
2313  		fuse_finish_interrupt(f, req, &d);
2314  		free_path(f, ino, path);
2315  	}
2316  	if (!err) {
2317  		struct node *node;
2318  		pthread_mutex_lock(&f->lock);
2319  		node = get_node(f, ino);
2320  		if (node->is_hidden && buf.st_nlink > 0)
2321  			buf.st_nlink--;
2322  		if (f->conf.auto_cache)
2323  			update_stat(node, &buf);
2324  		pthread_mutex_unlock(&f->lock);
2325  		set_stat(f, ino, &buf);
2326  		fuse_reply_attr(req, &buf, f->conf.attr_timeout);
2327  	} else
2328  		reply_err(req, err);
2329  }
2330  int fuse_fs_chmod(struct fuse_fs *fs, const char *path, mode_t mode,
2331  		  struct fuse_file_info *fi)
2332  {
2333  	fuse_get_context()->private_data = fs->user_data;
2334  	if (fs->op.chmod) {
2335  		if (fs->debug) {
2336  			char buf[10];
2337  			fuse_log(FUSE_LOG_DEBUG, "chmod[%s] %s %llo\n",
2338  				file_info_string(fi, buf, sizeof(buf)),
2339  				path, (unsigned long long) mode);
2340  		}
2341  		return fs->op.chmod(path, mode, fi);
2342  	}
2343  	else
2344  		return -ENOSYS;
2345  }
2346  static void fuse_lib_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,
2347  			     int valid, struct fuse_file_info *fi)
2348  {
2349  	struct fuse *f = req_fuse_prepare(req);
2350  	struct stat buf;
2351  	char *path;
2352  	int err;
2353  	memset(&buf, 0, sizeof(buf));
2354  	if (fi != NULL)
2355  		err = get_path_nullok(f, ino, &path);
2356  	else
2357  		err = get_path(f, ino, &path);
2358  	if (!err) {
2359  		struct fuse_intr_data d;
2360  		fuse_prepare_interrupt(f, req, &d);
2361  		err = 0;
2362  		if (!err && (valid & FUSE_SET_ATTR_MODE))
2363  			err = fuse_fs_chmod(f->fs, path, attr->st_mode, fi);
2364  		if (!err && (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID))) {
2365  			uid_t uid = (valid & FUSE_SET_ATTR_UID) ?
2366  				attr->st_uid : (uid_t) -1;
2367  			gid_t gid = (valid & FUSE_SET_ATTR_GID) ?
2368  				attr->st_gid : (gid_t) -1;
2369  			err = fuse_fs_chown(f->fs, path, uid, gid, fi);
2370  		}
2371  		if (!err && (valid & FUSE_SET_ATTR_SIZE)) {
2372  			err = fuse_fs_truncate(f->fs, path,
2373  					       attr->st_size, fi);
2374  		}
2375  #ifdef HAVE_UTIMENSAT
2376  		if (!err &&
2377  		    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME))) {
2378  			struct timespec tv[2];
2379  			tv[0].tv_sec = 0;
2380  			tv[1].tv_sec = 0;
2381  			tv[0].tv_nsec = UTIME_OMIT;
2382  			tv[1].tv_nsec = UTIME_OMIT;
2383  			if (valid & FUSE_SET_ATTR_ATIME_NOW)
2384  				tv[0].tv_nsec = UTIME_NOW;
2385  			else if (valid & FUSE_SET_ATTR_ATIME)
2386  				tv[0] = attr->st_atim;
2387  			if (valid & FUSE_SET_ATTR_MTIME_NOW)
2388  				tv[1].tv_nsec = UTIME_NOW;
2389  			else if (valid & FUSE_SET_ATTR_MTIME)
2390  				tv[1] = attr->st_mtim;
2391  			err = fuse_fs_utimens(f->fs, path, tv, fi);
2392  		} else
2393  #endif
2394  		if (!err &&
2395  		    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) ==
2396  		    (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {
2397  			struct timespec tv[2];
2398  			tv[0].tv_sec = attr->st_atime;
2399  			tv[0].tv_nsec = ST_ATIM_NSEC(attr);
2400  			tv[1].tv_sec = attr->st_mtime;
2401  			tv[1].tv_nsec = ST_MTIM_NSEC(attr);
2402  			err = fuse_fs_utimens(f->fs, path, tv, fi);
2403  		}
2404  		if (!err) {
2405  			err = fuse_fs_getattr(f->fs, path, &buf, fi);
2406  		}
2407  		fuse_finish_interrupt(f, req, &d);
2408  		free_path(f, ino, path);
2409  	}
2410  	if (!err) {
2411  		if (f->conf.auto_cache) {
2412  			pthread_mutex_lock(&f->lock);
2413  			update_stat(get_node(f, ino), &buf);
2414  			pthread_mutex_unlock(&f->lock);
2415  		}
2416  		set_stat(f, ino, &buf);
2417  		fuse_reply_attr(req, &buf, f->conf.attr_timeout);
2418  	} else
2419  		reply_err(req, err);
2420  }
2421  static void fuse_lib_access(fuse_req_t req, fuse_ino_t ino, int mask)
2422  {
2423  	struct fuse *f = req_fuse_prepare(req);
2424  	char *path;
2425  	int err;
2426  	err = get_path(f, ino, &path);
2427  	if (!err) {
2428  		struct fuse_intr_data d;
2429  		fuse_prepare_interrupt(f, req, &d);
2430  		err = fuse_fs_access(f->fs, path, mask);
2431  		fuse_finish_interrupt(f, req, &d);
2432  		free_path(f, ino, path);
2433  	}
2434  	reply_err(req, err);
2435  }
2436  static void fuse_lib_readlink(fuse_req_t req, fuse_ino_t ino)
2437  {
2438  	struct fuse *f = req_fuse_prepare(req);
2439  	char linkname[PATH_MAX + 1];
2440  	char *path;
2441  	int err;
2442  	err = get_path(f, ino, &path);
2443  	if (!err) {
2444  		struct fuse_intr_data d;
2445  		fuse_prepare_interrupt(f, req, &d);
2446  		err = fuse_fs_readlink(f->fs, path, linkname, sizeof(linkname));
2447  		fuse_finish_interrupt(f, req, &d);
2448  		free_path(f, ino, path);
2449  	}
2450  	if (!err) {
2451  		linkname[PATH_MAX] = '\0';
2452  		fuse_reply_readlink(req, linkname);
2453  	} else
2454  		reply_err(req, err);
2455  }
2456  static void fuse_lib_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,
2457  			   mode_t mode, dev_t rdev)
2458  {
2459  	struct fuse *f = req_fuse_prepare(req);
2460  	struct fuse_entry_param e;
2461  	char *path;
2462  	int err;
2463  	err = get_path_name(f, parent, name, &path);
2464  	if (!err) {
2465  		struct fuse_intr_data d;
2466  		fuse_prepare_interrupt(f, req, &d);
2467  		err = -ENOSYS;
2468  		if (S_ISREG(mode)) {
2469  			struct fuse_file_info fi;
2470  			memset(&fi, 0, sizeof(fi));
2471  			fi.flags = O_CREAT | O_EXCL | O_WRONLY;
2472  			err = fuse_fs_create(f->fs, path, mode, &fi);
2473  			if (!err) {
2474  				err = lookup_path(f, parent, name, path, &e,
2475  						  &fi);
2476  				fuse_fs_release(f->fs, path, &fi);
2477  			}
2478  		}
2479  		if (err == -ENOSYS) {
2480  			err = fuse_fs_mknod(f->fs, path, mode, rdev);
2481  			if (!err)
2482  				err = lookup_path(f, parent, name, path, &e,
2483  						  NULL);
2484  		}
2485  		fuse_finish_interrupt(f, req, &d);
2486  		free_path(f, parent, path);
2487  	}
2488  	reply_entry(req, &e, err);
2489  }
2490  static void fuse_lib_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,
2491  			   mode_t mode)
2492  {
2493  	struct fuse *f = req_fuse_prepare(req);
2494  	struct fuse_entry_param e;
2495  	char *path;
2496  	int err;
2497  	err = get_path_name(f, parent, name, &path);
2498  	if (!err) {
2499  		struct fuse_intr_data d;
2500  		fuse_prepare_interrupt(f, req, &d);
2501  		err = fuse_fs_mkdir(f->fs, path, mode);
2502  		if (!err)
2503  			err = lookup_path(f, parent, name, path, &e, NULL);
2504  		fuse_finish_interrupt(f, req, &d);
2505  		free_path(f, parent, path);
2506  	}
2507  	reply_entry(req, &e, err);
2508  }
2509  static void fuse_lib_unlink(fuse_req_t req, fuse_ino_t parent,
2510  			    const char *name)
2511  {
2512  	struct fuse *f = req_fuse_prepare(req);
2513  	struct node *wnode;
2514  	char *path;
2515  	int err;
2516  	err = get_path_wrlock(f, parent, name, &path, &wnode);
2517  	if (!err) {
2518  		struct fuse_intr_data d;
2519  		fuse_prepare_interrupt(f, req, &d);
2520  		if (!f->conf.hard_remove && is_open(f, parent, name)) {
2521  			err = hide_node(f, path, parent, name);
2522  			if (!err) {
2523  				if (!is_open(f, parent, wnode->name)) {
2524  					char *unlinkpath;
2525  					if (try_get_path(f, wnode->nodeid, NULL, &unlinkpath, NULL, false) == 0) {
2526  						err = fuse_fs_unlink(f->fs, unlinkpath);
2527  						if (!err)
2528  							remove_node(f, parent, wnode->name);
2529  						free(unlinkpath);
2530  					}
2531  				}
2532  			}
2533  		} else {
2534  			err = fuse_fs_unlink(f->fs, path);
2535  			if (!err)
2536  				remove_node(f, parent, name);
2537  		}
2538  		fuse_finish_interrupt(f, req, &d);
2539  		free_path_wrlock(f, parent, wnode, path);
2540  	}
2541  	reply_err(req, err);
2542  }
2543  static void fuse_lib_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)
2544  {
2545  	struct fuse *f = req_fuse_prepare(req);
2546  	struct node *wnode;
2547  	char *path;
2548  	int err;
2549  	err = get_path_wrlock(f, parent, name, &path, &wnode);
2550  	if (!err) {
2551  		struct fuse_intr_data d;
2552  		fuse_prepare_interrupt(f, req, &d);
2553  		err = fuse_fs_rmdir(f->fs, path);
2554  		fuse_finish_interrupt(f, req, &d);
2555  		if (!err)
2556  			remove_node(f, parent, name);
2557  		free_path_wrlock(f, parent, wnode, path);
2558  	}
2559  	reply_err(req, err);
2560  }
2561  static void fuse_lib_symlink(fuse_req_t req, const char *linkname,
2562  			     fuse_ino_t parent, const char *name)
2563  {
2564  	struct fuse *f = req_fuse_prepare(req);
2565  	struct fuse_entry_param e;
2566  	char *path;
2567  	int err;
2568  	err = get_path_name(f, parent, name, &path);
2569  	if (!err) {
2570  		struct fuse_intr_data d;
2571  		fuse_prepare_interrupt(f, req, &d);
2572  		err = fuse_fs_symlink(f->fs, linkname, path);
2573  		if (!err)
2574  			err = lookup_path(f, parent, name, path, &e, NULL);
2575  		fuse_finish_interrupt(f, req, &d);
2576  		free_path(f, parent, path);
2577  	}
2578  	reply_entry(req, &e, err);
2579  }
2580  static void fuse_lib_rename(fuse_req_t req, fuse_ino_t olddir,
2581  			    const char *oldname, fuse_ino_t newdir,
2582  			    const char *newname, unsigned int flags)
2583  {
2584  	struct fuse *f = req_fuse_prepare(req);
2585  	char *oldpath;
2586  	char *newpath;
2587  	struct node *wnode1;
2588  	struct node *wnode2;
2589  	int err;
2590  	err = get_path2(f, olddir, oldname, newdir, newname,
2591  			&oldpath, &newpath, &wnode1, &wnode2);
2592  	if (!err) {
2593  		struct fuse_intr_data d;
2594  		err = 0;
2595  		fuse_prepare_interrupt(f, req, &d);
2596  		if (!f->conf.hard_remove && !(flags & RENAME_EXCHANGE) &&
2597  		    is_open(f, newdir, newname))
2598  			err = hide_node(f, newpath, newdir, newname);
2599  		if (!err) {
2600  			err = fuse_fs_rename(f->fs, oldpath, newpath, flags);
2601  			if (!err) {
2602  				if (flags & RENAME_EXCHANGE) {
2603  					err = exchange_node(f, olddir, oldname,
2604  							    newdir, newname);
2605  				} else {
2606  					err = rename_node(f, olddir, oldname,
2607  							  newdir, newname, 0);
2608  				}
2609  			}
2610  		}
2611  		fuse_finish_interrupt(f, req, &d);
2612  		free_path2(f, olddir, newdir, wnode1, wnode2, oldpath, newpath);
2613  	}
2614  	reply_err(req, err);
2615  }
2616  static void fuse_lib_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
2617  			  const char *newname)
2618  {
2619  	struct fuse *f = req_fuse_prepare(req);
2620  	struct fuse_entry_param e;
2621  	char *oldpath;
2622  	char *newpath;
2623  	int err;
2624  	err = get_path2(f, ino, NULL, newparent, newname,
2625  			&oldpath, &newpath, NULL, NULL);
2626  	if (!err) {
2627  		struct fuse_intr_data d;
2628  		fuse_prepare_interrupt(f, req, &d);
2629  		err = fuse_fs_link(f->fs, oldpath, newpath);
2630  		if (!err)
2631  			err = lookup_path(f, newparent, newname, newpath,
2632  					  &e, NULL);
2633  		fuse_finish_interrupt(f, req, &d);
2634  		free_path2(f, ino, newparent, NULL, NULL, oldpath, newpath);
2635  	}
2636  	reply_entry(req, &e, err);
2637  }
2638  static void fuse_do_release(struct fuse *f, fuse_ino_t ino, const char *path,
2639  			    struct fuse_file_info *fi)
2640  {
2641  	struct node *node;
2642  	int unlink_hidden = 0;
2643  	fuse_fs_release(f->fs, path, fi);
2644  	pthread_mutex_lock(&f->lock);
2645  	node = get_node(f, ino);
2646  	assert(node->open_count > 0);
2647  	--node->open_count;
2648  	if (node->is_hidden && !node->open_count) {
2649  		unlink_hidden = 1;
2650  		node->is_hidden = 0;
2651  	}
2652  	pthread_mutex_unlock(&f->lock);
2653  	if(unlink_hidden) {
2654  		if (path) {
2655  			fuse_fs_unlink(f->fs, path);
2656  		} else if (f->conf.nullpath_ok) {
2657  			char *unlinkpath;
2658  			if (get_path(f, ino, &unlinkpath) == 0)
2659  				fuse_fs_unlink(f->fs, unlinkpath);
2660  			free_path(f, ino, unlinkpath);
2661  		}
2662  	}
2663  }
2664  static void fuse_lib_create(fuse_req_t req, fuse_ino_t parent,
2665  			    const char *name, mode_t mode,
2666  			    struct fuse_file_info *fi)
2667  {
2668  	struct fuse *f = req_fuse_prepare(req);
2669  	struct fuse_intr_data d;
2670  	struct fuse_entry_param e;
2671  	char *path;
2672  	int err;
2673  	err = get_path_name(f, parent, name, &path);
2674  	if (!err) {
2675  		fuse_prepare_interrupt(f, req, &d);
2676  		err = fuse_fs_create(f->fs, path, mode, fi);
2677  		if (!err) {
2678  			err = lookup_path(f, parent, name, path, &e, fi);
2679  			if (err)
2680  				fuse_fs_release(f->fs, path, fi);
2681  			else if (!S_ISREG(e.attr.st_mode)) {
2682  				err = -EIO;
2683  				fuse_fs_release(f->fs, path, fi);
2684  				forget_node(f, e.ino, 1);
2685  			} else {
2686  				if (f->conf.direct_io)
2687  					fi->direct_io = 1;
2688  				if (f->conf.kernel_cache)
2689  					fi->keep_cache = 1;
2690  				if (fi->direct_io &&
2691  				    f->conf.parallel_direct_writes)
2692  					fi->parallel_direct_writes = 1;
2693  			}
2694  		}
2695  		fuse_finish_interrupt(f, req, &d);
2696  	}
2697  	if (!err) {
2698  		pthread_mutex_lock(&f->lock);
2699  		get_node(f, e.ino)->open_count++;
2700  		pthread_mutex_unlock(&f->lock);
2701  		if (fuse_reply_create(req, &e, fi) == -ENOENT) {
2702  			fuse_do_release(f, e.ino, path, fi);
2703  			forget_node(f, e.ino, 1);
2704  		}
2705  	} else {
2706  		reply_err(req, err);
2707  	}
2708  	free_path(f, parent, path);
2709  }
2710  static double diff_timespec(const struct timespec *t1,
2711  			    const struct timespec *t2)
2712  {
2713  	return (t1->tv_sec - t2->tv_sec) +
2714  		((double) t1->tv_nsec - (double) t2->tv_nsec) / 1000000000.0;
2715  }
2716  static void open_auto_cache(struct fuse *f, fuse_ino_t ino, const char *path,
2717  			    struct fuse_file_info *fi)
2718  {
2719  	struct node *node;
2720  	pthread_mutex_lock(&f->lock);
2721  	node = get_node(f, ino);
2722  	if (node->cache_valid) {
2723  		struct timespec now;
2724  		curr_time(&now);
2725  		if (diff_timespec(&now, &node->stat_updated) >
2726  		    f->conf.ac_attr_timeout) {
2727  			struct stat stbuf;
2728  			int err;
2729  			pthread_mutex_unlock(&f->lock);
2730  			err = fuse_fs_getattr(f->fs, path, &stbuf, fi);
2731  			pthread_mutex_lock(&f->lock);
2732  			if (!err)
2733  				update_stat(node, &stbuf);
2734  			else
2735  				node->cache_valid = 0;
2736  		}
2737  	}
2738  	if (node->cache_valid)
2739  		fi->keep_cache = 1;
2740  	node->cache_valid = 1;
2741  	pthread_mutex_unlock(&f->lock);
2742  }
2743  static void fuse_lib_open(fuse_req_t req, fuse_ino_t ino,
2744  			  struct fuse_file_info *fi)
2745  {
2746  	struct fuse *f = req_fuse_prepare(req);
2747  	struct fuse_intr_data d;
2748  	char *path;
2749  	int err;
2750  	err = get_path(f, ino, &path);
2751  	if (!err) {
2752  		fuse_prepare_interrupt(f, req, &d);
2753  		err = fuse_fs_open(f->fs, path, fi);
2754  		if (!err) {
2755  			if (f->conf.direct_io)
2756  				fi->direct_io = 1;
2757  			if (f->conf.kernel_cache)
2758  				fi->keep_cache = 1;
2759  			if (f->conf.auto_cache)
2760  				open_auto_cache(f, ino, path, fi);
2761  			if (f->conf.no_rofd_flush &&
2762  			    (fi->flags & O_ACCMODE) == O_RDONLY)
2763  				fi->noflush = 1;
2764  			if (fi->direct_io && f->conf.parallel_direct_writes)
2765  				fi->parallel_direct_writes = 1;
2766  		}
2767  		fuse_finish_interrupt(f, req, &d);
2768  	}
2769  	if (!err) {
2770  		pthread_mutex_lock(&f->lock);
2771  		get_node(f, ino)->open_count++;
2772  		pthread_mutex_unlock(&f->lock);
2773  		if (fuse_reply_open(req, fi) == -ENOENT) {
2774  			fuse_do_release(f, ino, path, fi);
2775  		}
2776  	} else
2777  		reply_err(req, err);
2778  	free_path(f, ino, path);
2779  }
2780  static void fuse_lib_read(fuse_req_t req, fuse_ino_t ino, size_t size,
2781  			  off_t off, struct fuse_file_info *fi)
2782  {
2783  	struct fuse *f = req_fuse_prepare(req);
2784  	struct fuse_bufvec *buf = NULL;
2785  	char *path;
2786  	int res;
2787  	res = get_path_nullok(f, ino, &path);
2788  	if (res == 0) {
2789  		struct fuse_intr_data d;
2790  		fuse_prepare_interrupt(f, req, &d);
2791  		res = fuse_fs_read_buf(f->fs, path, &buf, size, off, fi);
2792  		fuse_finish_interrupt(f, req, &d);
2793  		free_path(f, ino, path);
2794  	}
2795  	if (res == 0)
2796  		fuse_reply_data(req, buf, FUSE_BUF_SPLICE_MOVE);
2797  	else
2798  		reply_err(req, res);
2799  	fuse_free_buf(buf);
2800  }
2801  static void fuse_lib_write_buf(fuse_req_t req, fuse_ino_t ino,
2802  			       struct fuse_bufvec *buf, off_t off,
2803  			       struct fuse_file_info *fi)
2804  {
2805  	struct fuse *f = req_fuse_prepare(req);
2806  	char *path;
2807  	int res;
2808  	res = get_path_nullok(f, ino, &path);
2809  	if (res == 0) {
2810  		struct fuse_intr_data d;
2811  		fuse_prepare_interrupt(f, req, &d);
2812  		res = fuse_fs_write_buf(f->fs, path, buf, off, fi);
2813  		fuse_finish_interrupt(f, req, &d);
2814  		free_path(f, ino, path);
2815  	}
2816  	if (res >= 0)
2817  		fuse_reply_write(req, res);
2818  	else
2819  		reply_err(req, res);
2820  }
2821  static void fuse_lib_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,
2822  			   struct fuse_file_info *fi)
2823  {
2824  	struct fuse *f = req_fuse_prepare(req);
2825  	char *path;
2826  	int err;
2827  	err = get_path_nullok(f, ino, &path);
2828  	if (!err) {
2829  		struct fuse_intr_data d;
2830  		fuse_prepare_interrupt(f, req, &d);
2831  		err = fuse_fs_fsync(f->fs, path, datasync, fi);
2832  		fuse_finish_interrupt(f, req, &d);
2833  		free_path(f, ino, path);
2834  	}
2835  	reply_err(req, err);
2836  }
2837  static struct fuse_dh *get_dirhandle(const struct fuse_file_info *llfi,
2838  				     struct fuse_file_info *fi)
2839  {
2840  	struct fuse_dh *dh = (struct fuse_dh *) (uintptr_t) llfi->fh;
2841  	memset(fi, 0, sizeof(struct fuse_file_info));
2842  	fi->fh = dh->fh;
2843  	return dh;
2844  }
2845  static void fuse_lib_opendir(fuse_req_t req, fuse_ino_t ino,
2846  			     struct fuse_file_info *llfi)
2847  {
2848  	struct fuse *f = req_fuse_prepare(req);
2849  	struct fuse_intr_data d;
2850  	struct fuse_dh *dh;
2851  	struct fuse_file_info fi;
2852  	char *path;
2853  	int err;
2854  	dh = (struct fuse_dh *) malloc(sizeof(struct fuse_dh));
2855  	if (dh == NULL) {
2856  		reply_err(req, -ENOMEM);
2857  		return;
2858  	}
2859  	memset(dh, 0, sizeof(struct fuse_dh));
2860  	dh->fuse = f;
2861  	dh->contents = NULL;
2862  	dh->first = NULL;
2863  	dh->len = 0;
2864  	dh->filled = 0;
2865  	dh->nodeid = ino;
2866  	pthread_mutex_init(&dh->lock, NULL);
2867  	llfi->fh = (uintptr_t) dh;
2868  	memset(&fi, 0, sizeof(fi));
2869  	fi.flags = llfi->flags;
2870  	err = get_path(f, ino, &path);
2871  	if (!err) {
2872  		fuse_prepare_interrupt(f, req, &d);
2873  		err = fuse_fs_opendir(f->fs, path, &fi);
2874  		fuse_finish_interrupt(f, req, &d);
2875  		dh->fh = fi.fh;
2876  	}
2877  	if (!err) {
2878  		if (fuse_reply_open(req, llfi) == -ENOENT) {
2879  			fuse_fs_releasedir(f->fs, path, &fi);
2880  			pthread_mutex_destroy(&dh->lock);
2881  			free(dh);
2882  		}
2883  	} else {
2884  		reply_err(req, err);
2885  		pthread_mutex_destroy(&dh->lock);
2886  		free(dh);
2887  	}
2888  	free_path(f, ino, path);
2889  }
2890  static int extend_contents(struct fuse_dh *dh, unsigned minsize)
2891  {
2892  	if (minsize > dh->size) {
2893  		char *newptr;
2894  		unsigned newsize = dh->size;
2895  		if (!newsize)
2896  			newsize = 1024;
2897  		while (newsize < minsize) {
2898  			if (newsize >= 0x80000000)
2899  				newsize = 0xffffffff;
2900  			else
2901  				newsize *= 2;
2902  		}
2903  		newptr = (char *) realloc(dh->contents, newsize);
2904  		if (!newptr) {
2905  			dh->error = -ENOMEM;
2906  			return -1;
2907  		}
2908  		dh->contents = newptr;
2909  		dh->size = newsize;
2910  	}
2911  	return 0;
2912  }
2913  static int fuse_add_direntry_to_dh(struct fuse_dh *dh, const char *name,
2914  				   struct stat *st)
2915  {
2916  	struct fuse_direntry *de;
2917  	de = malloc(sizeof(struct fuse_direntry));
2918  	if (!de) {
2919  		dh->error = -ENOMEM;
2920  		return -1;
2921  	}
2922  	de->name = strdup(name);
2923  	if (!de->name) {
2924  		dh->error = -ENOMEM;
2925  		free(de);
2926  		return -1;
2927  	}
2928  	de->stat = *st;
2929  	de->next = NULL;
2930  	*dh->last = de;
2931  	dh->last = &de->next;
2932  	return 0;
2933  }
2934  static fuse_ino_t lookup_nodeid(struct fuse *f, fuse_ino_t parent,
2935  				const char *name)
2936  {
2937  	struct node *node;
2938  	fuse_ino_t res = FUSE_UNKNOWN_INO;
2939  	pthread_mutex_lock(&f->lock);
2940  	node = lookup_node(f, parent, name);
2941  	if (node)
2942  		res = node->nodeid;
2943  	pthread_mutex_unlock(&f->lock);
2944  	return res;
2945  }
2946  static int fill_dir(void *dh_, const char *name, const struct stat *statp,
2947  		    off_t off, enum fuse_fill_dir_flags flags)
2948  {
2949  	struct fuse_dh *dh = (struct fuse_dh *) dh_;
2950  	struct stat stbuf;
2951  	if ((flags & ~FUSE_FILL_DIR_PLUS) != 0) {
2952  		dh->error = -EIO;
2953  		return 1;
2954  	}
2955  	if (statp)
2956  		stbuf = *statp;
2957  	else {
2958  		memset(&stbuf, 0, sizeof(stbuf));
2959  		stbuf.st_ino = FUSE_UNKNOWN_INO;
2960  	}
2961  	if (!dh->fuse->conf.use_ino) {
2962  		stbuf.st_ino = FUSE_UNKNOWN_INO;
2963  		if (dh->fuse->conf.readdir_ino) {
2964  			stbuf.st_ino = (ino_t)
2965  				lookup_nodeid(dh->fuse, dh->nodeid, name);
2966  		}
2967  	}
2968  	if (off) {
2969  		size_t newlen;
2970  		if (dh->filled) {
2971  			dh->error = -EIO;
2972  			return 1;
2973  		}
2974  		if (dh->first) {
2975  			dh->error = -EIO;
2976  			return 1;
2977  		}
2978  		if (extend_contents(dh, dh->needlen) == -1)
2979  			return 1;
2980  		newlen = dh->len +
2981  			fuse_add_direntry(dh->req, dh->contents + dh->len,
2982  					  dh->needlen - dh->len, name,
2983  					  &stbuf, off);
2984  		if (newlen > dh->needlen)
2985  			return 1;
2986  		dh->len = newlen;
2987  	} else {
2988  		dh->filled = 1;
2989  		if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1)
2990  			return 1;
2991  	}
2992  	return 0;
2993  }
2994  static int is_dot_or_dotdot(const char *name)
2995  {
2996  	return name[0] == '.' && (name[1] == '\0' ||
2997  				  (name[1] == '.' && name[2] == '\0'));
2998  }
2999  static int fill_dir_plus(void *dh_, const char *name, const struct stat *statp,
3000  			 off_t off, enum fuse_fill_dir_flags flags)
3001  {
3002  	struct fuse_dh *dh = (struct fuse_dh *) dh_;
3003  	struct fuse_entry_param e = {
3004  		.ino = 0,
3005  	};
3006  	struct fuse *f = dh->fuse;
3007  	int res;
3008  	if ((flags & ~FUSE_FILL_DIR_PLUS) != 0) {
3009  		dh->error = -EIO;
3010  		return 1;
3011  	}
3012  	if (statp && (flags & FUSE_FILL_DIR_PLUS)) {
3013  		e.attr = *statp;
3014  		if (!is_dot_or_dotdot(name)) {
3015  			res = do_lookup(f, dh->nodeid, name, &e);
3016  			if (res) {
3017  				dh->error = res;
3018  				return 1;
3019  			}
3020  		}
3021  	} else {
3022  		e.attr.st_ino = FUSE_UNKNOWN_INO;
3023  		if (statp) {
3024  			e.attr.st_mode = statp->st_mode;
3025  			if (f->conf.use_ino)
3026  				e.attr.st_ino = statp->st_ino;
3027  		}
3028  		if (!f->conf.use_ino && f->conf.readdir_ino) {
3029  			e.attr.st_ino = (ino_t)
3030  				lookup_nodeid(f, dh->nodeid, name);
3031  		}
3032  	}
3033  	if (off) {
3034  		size_t newlen;
3035  		if (dh->filled) {
3036  			dh->error = -EIO;
3037  			return 1;
3038  		}
3039  		if (dh->first) {
3040  			dh->error = -EIO;
3041  			return 1;
3042  		}
3043  		if (extend_contents(dh, dh->needlen) == -1)
3044  			return 1;
3045  		newlen = dh->len +
3046  			fuse_add_direntry_plus(dh->req, dh->contents + dh->len,
3047  					       dh->needlen - dh->len, name,
3048  					       &e, off);
3049  		if (newlen > dh->needlen)
3050  			return 1;
3051  		dh->len = newlen;
3052  	} else {
3053  		dh->filled = 1;
3054  		if (fuse_add_direntry_to_dh(dh, name, &e.attr) == -1)
3055  			return 1;
3056  	}
3057  	return 0;
3058  }
3059  static void free_direntries(struct fuse_direntry *de)
3060  {
3061  	while (de) {
3062  		struct fuse_direntry *next = de->next;
3063  		free(de->name);
3064  		free(de);
3065  		de = next;
3066  	}
3067  }
3068  static int readdir_fill(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
3069  			size_t size, off_t off, struct fuse_dh *dh,
3070  			struct fuse_file_info *fi,
3071  			enum fuse_readdir_flags flags)
3072  {
3073  	char *path;
3074  	int err;
3075  	if (f->fs->op.readdir)
3076  		err = get_path_nullok(f, ino, &path);
3077  	else
3078  		err = get_path(f, ino, &path);
3079  	if (!err) {
3080  		struct fuse_intr_data d;
3081  		fuse_fill_dir_t filler = fill_dir;
3082  		if (flags & FUSE_READDIR_PLUS)
3083  			filler = fill_dir_plus;
3084  		free_direntries(dh->first);
3085  		dh->first = NULL;
3086  		dh->last = &dh->first;
3087  		dh->len = 0;
3088  		dh->error = 0;
3089  		dh->needlen = size;
3090  		dh->filled = 0;
3091  		dh->req = req;
3092  		fuse_prepare_interrupt(f, req, &d);
3093  		err = fuse_fs_readdir(f->fs, path, dh, filler, off, fi, flags);
3094  		fuse_finish_interrupt(f, req, &d);
3095  		dh->req = NULL;
3096  		if (!err)
3097  			err = dh->error;
3098  		if (err)
3099  			dh->filled = 0;
3100  		free_path(f, ino, path);
3101  	}
3102  	return err;
3103  }
3104  static int readdir_fill_from_list(fuse_req_t req, struct fuse_dh *dh,
3105  				  off_t off, enum fuse_readdir_flags flags)
3106  {
3107  	off_t pos;
3108  	struct fuse_direntry *de = dh->first;
3109  	dh->len = 0;
3110  	if (extend_contents(dh, dh->needlen) == -1)
3111  		return dh->error;
3112  	for (pos = 0; pos < off; pos++) {
3113  		if (!de)
3114  			break;
3115  		de = de->next;
3116  	}
3117  	while (de) {
3118  		char *p = dh->contents + dh->len;
3119  		unsigned rem = dh->needlen - dh->len;
3120  		unsigned thislen;
3121  		unsigned newlen;
3122  		pos++;
3123  		if (flags & FUSE_READDIR_PLUS) {
3124  			struct fuse_entry_param e = {
3125  				.ino = 0,
3126  				.attr = de->stat,
3127  			};
3128  			thislen = fuse_add_direntry_plus(req, p, rem,
3129  							 de->name, &e, pos);
3130  		} else {
3131  			thislen = fuse_add_direntry(req, p, rem,
3132  						    de->name, &de->stat, pos);
3133  		}
3134  		newlen = dh->len + thislen;
3135  		if (newlen > dh->needlen)
3136  			break;
3137  		dh->len = newlen;
3138  		de = de->next;
3139  	}
3140  	return 0;
3141  }
3142  static void fuse_readdir_common(fuse_req_t req, fuse_ino_t ino, size_t size,
3143  				off_t off, struct fuse_file_info *llfi,
3144  				enum fuse_readdir_flags flags)
3145  {
3146  	struct fuse *f = req_fuse_prepare(req);
3147  	struct fuse_file_info fi;
3148  	struct fuse_dh *dh = get_dirhandle(llfi, &fi);
3149  	int err;
3150  	pthread_mutex_lock(&dh->lock);
3151  	if (!off)
3152  		dh->filled = 0;
3153  	if (!dh->filled) {
3154  		err = readdir_fill(f, req, ino, size, off, dh, &fi, flags);
3155  		if (err) {
3156  			reply_err(req, err);
3157  			goto out;
3158  		}
3159  	}
3160  	if (dh->filled) {
3161  		dh->needlen = size;
3162  		err = readdir_fill_from_list(req, dh, off, flags);
3163  		if (err) {
3164  			reply_err(req, err);
3165  			goto out;
3166  		}
3167  	}
3168  	fuse_reply_buf(req, dh->contents, dh->len);
3169  out:
3170  	pthread_mutex_unlock(&dh->lock);
3171  }
3172  static void fuse_lib_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
3173  			     off_t off, struct fuse_file_info *llfi)
3174  {
3175  	fuse_readdir_common(req, ino, size, off, llfi, 0);
3176  }
3177  static void fuse_lib_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,
3178  				  off_t off, struct fuse_file_info *llfi)
3179  {
3180  	fuse_readdir_common(req, ino, size, off, llfi, FUSE_READDIR_PLUS);
3181  }
3182  static void fuse_lib_releasedir(fuse_req_t req, fuse_ino_t ino,
3183  				struct fuse_file_info *llfi)
3184  {
3185  	struct fuse *f = req_fuse_prepare(req);
3186  	struct fuse_intr_data d;
3187  	struct fuse_file_info fi;
3188  	struct fuse_dh *dh = get_dirhandle(llfi, &fi);
3189  	char *path;
3190  	get_path_nullok(f, ino, &path);
3191  	fuse_prepare_interrupt(f, req, &d);
3192  	fuse_fs_releasedir(f->fs, path, &fi);
3193  	fuse_finish_interrupt(f, req, &d);
3194  	free_path(f, ino, path);
3195  	pthread_mutex_lock(&dh->lock);
3196  	pthread_mutex_unlock(&dh->lock);
3197  	pthread_mutex_destroy(&dh->lock);
3198  	free_direntries(dh->first);
3199  	free(dh->contents);
3200  	free(dh);
3201  	reply_err(req, 0);
3202  }
3203  static void fuse_lib_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,
3204  			      struct fuse_file_info *llfi)
3205  {
3206  	struct fuse *f = req_fuse_prepare(req);
3207  	struct fuse_file_info fi;
3208  	char *path;
3209  	int err;
3210  	get_dirhandle(llfi, &fi);
3211  	err = get_path_nullok(f, ino, &path);
3212  	if (!err) {
3213  		struct fuse_intr_data d;
3214  		fuse_prepare_interrupt(f, req, &d);
3215  		err = fuse_fs_fsyncdir(f->fs, path, datasync, &fi);
3216  		fuse_finish_interrupt(f, req, &d);
3217  		free_path(f, ino, path);
3218  	}
3219  	reply_err(req, err);
3220  }
3221  static void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)
3222  {
3223  	struct fuse *f = req_fuse_prepare(req);
3224  	struct statvfs buf;
3225  	char *path = NULL;
3226  	int err = 0;
3227  	memset(&buf, 0, sizeof(buf));
3228  	if (ino)
3229  		err = get_path(f, ino, &path);
3230  	if (!err) {
3231  		struct fuse_intr_data d;
3232  		fuse_prepare_interrupt(f, req, &d);
3233  		err = fuse_fs_statfs(f->fs, path ? path : "/", &buf);
3234  		fuse_finish_interrupt(f, req, &d);
3235  		free_path(f, ino, path);
3236  	}
3237  	if (!err)
3238  		fuse_reply_statfs(req, &buf);
3239  	else
3240  		reply_err(req, err);
3241  }
3242  static void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
3243  			      const char *value, size_t size, int flags)
3244  {
3245  	struct fuse *f = req_fuse_prepare(req);
3246  	char *path;
3247  	int err;
3248  	err = get_path(f, ino, &path);
3249  	if (!err) {
3250  		struct fuse_intr_data d;
3251  		fuse_prepare_interrupt(f, req, &d);
3252  		err = fuse_fs_setxattr(f->fs, path, name, value, size, flags);
3253  		fuse_finish_interrupt(f, req, &d);
3254  		free_path(f, ino, path);
3255  	}
3256  	reply_err(req, err);
3257  }
3258  static int common_getxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
3259  			   const char *name, char *value, size_t size)
3260  {
3261  	int err;
3262  	char *path;
3263  	err = get_path(f, ino, &path);
3264  	if (!err) {
3265  		struct fuse_intr_data d;
3266  		fuse_prepare_interrupt(f, req, &d);
3267  		err = fuse_fs_getxattr(f->fs, path, name, value, size);
3268  		fuse_finish_interrupt(f, req, &d);
3269  		free_path(f, ino, path);
3270  	}
3271  	return err;
3272  }
3273  static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
3274  			      size_t size)
3275  {
3276  	struct fuse *f = req_fuse_prepare(req);
3277  	int res;
3278  	if (size) {
3279  		char *value = (char *) malloc(size);
3280  		if (value == NULL) {
3281  			reply_err(req, -ENOMEM);
3282  			return;
3283  		}
3284  		res = common_getxattr(f, req, ino, name, value, size);
3285  		if (res > 0)
3286  			fuse_reply_buf(req, value, res);
3287  		else
3288  			reply_err(req, res);
3289  		free(value);
3290  	} else {
3291  		res = common_getxattr(f, req, ino, name, NULL, 0);
3292  		if (res >= 0)
3293  			fuse_reply_xattr(req, res);
3294  		else
3295  			reply_err(req, res);
3296  	}
3297  }
3298  static int common_listxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
3299  			    char *list, size_t size)
3300  {
3301  	char *path;
3302  	int err;
3303  	err = get_path(f, ino, &path);
3304  	if (!err) {
3305  		struct fuse_intr_data d;
3306  		fuse_prepare_interrupt(f, req, &d);
3307  		err = fuse_fs_listxattr(f->fs, path, list, size);
3308  		fuse_finish_interrupt(f, req, &d);
3309  		free_path(f, ino, path);
3310  	}
3311  	return err;
3312  }
3313  static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)
3314  {
3315  	struct fuse *f = req_fuse_prepare(req);
3316  	int res;
3317  	if (size) {
3318  		char *list = (char *) malloc(size);
3319  		if (list == NULL) {
3320  			reply_err(req, -ENOMEM);
3321  			return;
3322  		}
3323  		res = common_listxattr(f, req, ino, list, size);
3324  		if (res > 0)
3325  			fuse_reply_buf(req, list, res);
3326  		else
3327  			reply_err(req, res);
3328  		free(list);
3329  	} else {
3330  		res = common_listxattr(f, req, ino, NULL, 0);
3331  		if (res >= 0)
3332  			fuse_reply_xattr(req, res);
3333  		else
3334  			reply_err(req, res);
3335  	}
3336  }
3337  static void fuse_lib_removexattr(fuse_req_t req, fuse_ino_t ino,
3338  				 const char *name)
3339  {
3340  	struct fuse *f = req_fuse_prepare(req);
3341  	char *path;
3342  	int err;
3343  	err = get_path(f, ino, &path);
3344  	if (!err) {
3345  		struct fuse_intr_data d;
3346  		fuse_prepare_interrupt(f, req, &d);
3347  		err = fuse_fs_removexattr(f->fs, path, name);
3348  		fuse_finish_interrupt(f, req, &d);
3349  		free_path(f, ino, path);
3350  	}
3351  	reply_err(req, err);
3352  }
3353  static struct lock *locks_conflict(struct node *node, const struct lock *lock)
3354  {
3355  	struct lock *l;
3356  	for (l = node->locks; l; l = l->next)
3357  		if (l->owner != lock->owner &&
3358  		    lock->start <= l->end && l->start <= lock->end &&
3359  		    (l->type == F_WRLCK || lock->type == F_WRLCK))
3360  			break;
3361  	return l;
3362  }
3363  static void delete_lock(struct lock **lockp)
3364  {
3365  	struct lock *l = *lockp;
3366  	*lockp = l->next;
3367  	free(l);
3368  }
3369  static void insert_lock(struct lock **pos, struct lock *lock)
3370  {
3371  	lock->next = *pos;
3372  	*pos = lock;
3373  }
3374  static int locks_insert(struct node *node, struct lock *lock)
3375  {
3376  	struct lock **lp;
3377  	struct lock *newl1 = NULL;
3378  	struct lock *newl2 = NULL;
3379  	if (lock->type != F_UNLCK || lock->start != 0 ||
3380  	    lock->end != OFFSET_MAX) {
3381  		newl1 = malloc(sizeof(struct lock));
3382  		newl2 = malloc(sizeof(struct lock));
3383  		if (!newl1 || !newl2) {
3384  			free(newl1);
3385  			free(newl2);
3386  			return -ENOLCK;
3387  		}
3388  	}
3389  	for (lp = &node->locks; *lp;) {
3390  		struct lock *l = *lp;
3391  		if (l->owner != lock->owner)
3392  			goto skip;
3393  		if (lock->type == l->type) {
3394  			if (l->end < lock->start - 1)
3395  				goto skip;
3396  			if (lock->end < l->start - 1)
3397  				break;
3398  			if (l->start <= lock->start && lock->end <= l->end)
3399  				goto out;
3400  			if (l->start < lock->start)
3401  				lock->start = l->start;
3402  			if (lock->end < l->end)
3403  				lock->end = l->end;
3404  			goto delete;
3405  		} else {
3406  			if (l->end < lock->start)
3407  				goto skip;
3408  			if (lock->end < l->start)
3409  				break;
3410  			if (lock->start <= l->start && l->end <= lock->end)
3411  				goto delete;
3412  			if (l->end <= lock->end) {
3413  				l->end = lock->start - 1;
3414  				goto skip;
3415  			}
3416  			if (lock->start <= l->start) {
3417  				l->start = lock->end + 1;
3418  				break;
3419  			}
3420  			*newl2 = *l;
3421  			newl2->start = lock->end + 1;
3422  			l->end = lock->start - 1;
3423  			insert_lock(&l->next, newl2);
3424  			newl2 = NULL;
3425  		}
3426  	skip:
3427  		lp = &l->next;
3428  		continue;
3429  	delete:
3430  		delete_lock(lp);
3431  	}
3432  	if (lock->type != F_UNLCK) {
3433  		*newl1 = *lock;
3434  		insert_lock(lp, newl1);
3435  		newl1 = NULL;
3436  	}
3437  out:
3438  	free(newl1);
3439  	free(newl2);
3440  	return 0;
3441  }
3442  static void flock_to_lock(struct flock *flock, struct lock *lock)
3443  {
3444  	memset(lock, 0, sizeof(struct lock));
3445  	lock->type = flock->l_type;
3446  	lock->start = flock->l_start;
3447  	lock->end =
3448  		flock->l_len ? flock->l_start + flock->l_len - 1 : OFFSET_MAX;
3449  	lock->pid = flock->l_pid;
3450  }
3451  static void lock_to_flock(struct lock *lock, struct flock *flock)
3452  {
3453  	flock->l_type = lock->type;
3454  	flock->l_start = lock->start;
3455  	flock->l_len =
3456  		(lock->end == OFFSET_MAX) ? 0 : lock->end - lock->start + 1;
3457  	flock->l_pid = lock->pid;
3458  }
3459  static int fuse_flush_common(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
3460  			     const char *path, struct fuse_file_info *fi)
3461  {
3462  	struct fuse_intr_data d;
3463  	struct flock lock;
3464  	struct lock l;
3465  	int err;
3466  	int errlock;
3467  	fuse_prepare_interrupt(f, req, &d);
3468  	memset(&lock, 0, sizeof(lock));
3469  	lock.l_type = F_UNLCK;
3470  	lock.l_whence = SEEK_SET;
3471  	err = fuse_fs_flush(f->fs, path, fi);
3472  	errlock = fuse_fs_lock(f->fs, path, fi, F_SETLK, &lock);
3473  	fuse_finish_interrupt(f, req, &d);
3474  	if (errlock != -ENOSYS) {
3475  		flock_to_lock(&lock, &l);
3476  		l.owner = fi->lock_owner;
3477  		pthread_mutex_lock(&f->lock);
3478  		locks_insert(get_node(f, ino), &l);
3479  		pthread_mutex_unlock(&f->lock);
3480  		if (err == -ENOSYS)
3481  			err = 0;
3482  	}
3483  	return err;
3484  }
3485  static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,
3486  			     struct fuse_file_info *fi)
3487  {
3488  	struct fuse *f = req_fuse_prepare(req);
3489  	struct fuse_intr_data d;
3490  	char *path;
3491  	int err = 0;
3492  	get_path_nullok(f, ino, &path);
3493  	if (fi->flush) {
3494  		err = fuse_flush_common(f, req, ino, path, fi);
3495  		if (err == -ENOSYS)
3496  			err = 0;
3497  	}
3498  	fuse_prepare_interrupt(f, req, &d);
3499  	fuse_do_release(f, ino, path, fi);
3500  	fuse_finish_interrupt(f, req, &d);
3501  	free_path(f, ino, path);
3502  	reply_err(req, err);
3503  }
3504  static void fuse_lib_flush(fuse_req_t req, fuse_ino_t ino,
3505  			   struct fuse_file_info *fi)
3506  {
3507  	struct fuse *f = req_fuse_prepare(req);
3508  	char *path;
3509  	int err;
3510  	get_path_nullok(f, ino, &path);
3511  	err = fuse_flush_common(f, req, ino, path, fi);
3512  	free_path(f, ino, path);
3513  	reply_err(req, err);
3514  }
3515  static int fuse_lock_common(fuse_req_t req, fuse_ino_t ino,
3516  			    struct fuse_file_info *fi, struct flock *lock,
3517  			    int cmd)
3518  {
3519  	struct fuse *f = req_fuse_prepare(req);
3520  	char *path;
3521  	int err;
3522  	err = get_path_nullok(f, ino, &path);
3523  	if (!err) {
3524  		struct fuse_intr_data d;
3525  		fuse_prepare_interrupt(f, req, &d);
3526  		err = fuse_fs_lock(f->fs, path, fi, cmd, lock);
3527  		fuse_finish_interrupt(f, req, &d);
3528  		free_path(f, ino, path);
3529  	}
3530  	return err;
3531  }
3532  static void fuse_lib_getlk(fuse_req_t req, fuse_ino_t ino,
3533  			   struct fuse_file_info *fi, struct flock *lock)
3534  {
3535  	int err;
3536  	struct lock l;
3537  	struct lock *conflict;
3538  	struct fuse *f = req_fuse(req);
3539  	flock_to_lock(lock, &l);
3540  	l.owner = fi->lock_owner;
3541  	pthread_mutex_lock(&f->lock);
3542  	conflict = locks_conflict(get_node(f, ino), &l);
3543  	if (conflict)
3544  		lock_to_flock(conflict, lock);
3545  	pthread_mutex_unlock(&f->lock);
3546  	if (!conflict)
3547  		err = fuse_lock_common(req, ino, fi, lock, F_GETLK);
3548  	else
3549  		err = 0;
3550  	if (!err)
3551  		fuse_reply_lock(req, lock);
3552  	else
3553  		reply_err(req, err);
3554  }
3555  static void fuse_lib_setlk(fuse_req_t req, fuse_ino_t ino,
3556  			   struct fuse_file_info *fi, struct flock *lock,
3557  			   int sleep)
3558  {
3559  	int err = fuse_lock_common(req, ino, fi, lock,
3560  				   sleep ? F_SETLKW : F_SETLK);
3561  	if (!err) {
3562  		struct fuse *f = req_fuse(req);
3563  		struct lock l;
3564  		flock_to_lock(lock, &l);
3565  		l.owner = fi->lock_owner;
3566  		pthread_mutex_lock(&f->lock);
3567  		locks_insert(get_node(f, ino), &l);
3568  		pthread_mutex_unlock(&f->lock);
3569  	}
3570  	reply_err(req, err);
3571  }
3572  static void fuse_lib_flock(fuse_req_t req, fuse_ino_t ino,
3573  			   struct fuse_file_info *fi, int op)
3574  {
3575  	struct fuse *f = req_fuse_prepare(req);
3576  	char *path;
3577  	int err;
3578  	err = get_path_nullok(f, ino, &path);
3579  	if (err == 0) {
3580  		struct fuse_intr_data d;
3581  		fuse_prepare_interrupt(f, req, &d);
3582  		err = fuse_fs_flock(f->fs, path, fi, op);
3583  		fuse_finish_interrupt(f, req, &d);
3584  		free_path(f, ino, path);
3585  	}
3586  	reply_err(req, err);
3587  }
3588  static void fuse_lib_bmap(fuse_req_t req, fuse_ino_t ino, size_t blocksize,
3589  			  uint64_t idx)
3590  {
3591  	struct fuse *f = req_fuse_prepare(req);
3592  	struct fuse_intr_data d;
3593  	char *path;
3594  	int err;
3595  	err = get_path(f, ino, &path);
3596  	if (!err) {
3597  		fuse_prepare_interrupt(f, req, &d);
3598  		err = fuse_fs_bmap(f->fs, path, blocksize, &idx);
3599  		fuse_finish_interrupt(f, req, &d);
3600  		free_path(f, ino, path);
3601  	}
3602  	if (!err)
3603  		fuse_reply_bmap(req, idx);
3604  	else
3605  		reply_err(req, err);
3606  }
3607  static void fuse_lib_ioctl(fuse_req_t req, fuse_ino_t ino, unsigned int cmd,
3608  			   void *arg, struct fuse_file_info *llfi,
3609  			   unsigned int flags, const void *in_buf,
3610  			   size_t in_bufsz, size_t out_bufsz)
3611  {
3612  	struct fuse *f = req_fuse_prepare(req);
3613  	struct fuse_intr_data d;
3614  	struct fuse_file_info fi;
3615  	char *path, *out_buf = NULL;
3616  	int err;
3617  	err = -EPERM;
3618  	if (flags & FUSE_IOCTL_UNRESTRICTED)
3619  		goto err;
3620  	if (flags & FUSE_IOCTL_DIR)
3621  		get_dirhandle(llfi, &fi);
3622  	else
3623  		fi = *llfi;
3624  	if (out_bufsz) {
3625  		err = -ENOMEM;
3626  		out_buf = malloc(out_bufsz);
3627  		if (!out_buf)
3628  			goto err;
3629  	}
3630  	assert(!in_bufsz || !out_bufsz || in_bufsz == out_bufsz);
3631  	if (out_buf && in_bufsz)
3632  		memcpy(out_buf, in_buf, in_bufsz);
3633  	err = get_path_nullok(f, ino, &path);
3634  	if (err)
3635  		goto err;
3636  	fuse_prepare_interrupt(f, req, &d);
3637  	err = fuse_fs_ioctl(f->fs, path, cmd, arg, &fi, flags,
3638  			    out_buf ? out_buf : (void *)in_buf);
3639  	fuse_finish_interrupt(f, req, &d);
3640  	free_path(f, ino, path);
3641  	if (err < 0)
3642  		goto err;
3643  	fuse_reply_ioctl(req, err, out_buf, out_bufsz);
3644  	goto out;
3645  err:
3646  	reply_err(req, err);
3647  out:
3648  	free(out_buf);
3649  }
3650  static void fuse_lib_poll(fuse_req_t req, fuse_ino_t ino,
3651  			  struct fuse_file_info *fi, struct fuse_pollhandle *ph)
3652  {
3653  	struct fuse *f = req_fuse_prepare(req);
3654  	struct fuse_intr_data d;
3655  	char *path;
3656  	int err;
3657  	unsigned revents = 0;
3658  	err = get_path_nullok(f, ino, &path);
3659  	if (!err) {
3660  		fuse_prepare_interrupt(f, req, &d);
3661  		err = fuse_fs_poll(f->fs, path, fi, ph, &revents);
3662  		fuse_finish_interrupt(f, req, &d);
3663  		free_path(f, ino, path);
3664  	}
3665  	if (!err)
3666  		fuse_reply_poll(req, revents);
3667  	else
3668  		reply_err(req, err);
3669  }
3670  static void fuse_lib_fallocate(fuse_req_t req, fuse_ino_t ino, int mode,
3671  		off_t offset, off_t length, struct fuse_file_info *fi)
3672  {
3673  	struct fuse *f = req_fuse_prepare(req);
3674  	struct fuse_intr_data d;
3675  	char *path;
3676  	int err;
3677  	err = get_path_nullok(f, ino, &path);
3678  	if (!err) {
3679  		fuse_prepare_interrupt(f, req, &d);
3680  		err = fuse_fs_fallocate(f->fs, path, mode, offset, length, fi);
3681  		fuse_finish_interrupt(f, req, &d);
3682  		free_path(f, ino, path);
3683  	}
3684  	reply_err(req, err);
3685  }
3686  static void fuse_lib_copy_file_range(fuse_req_t req, fuse_ino_t nodeid_in,
3687  				     off_t off_in, struct fuse_file_info *fi_in,
3688  				     fuse_ino_t nodeid_out, off_t off_out,
3689  				     struct fuse_file_info *fi_out, size_t len,
3690  				     int flags)
3691  {
3692  	struct fuse *f = req_fuse_prepare(req);
3693  	struct fuse_intr_data d;
3694  	char *path_in, *path_out;
3695  	int err;
3696  	ssize_t res;
3697  	err = get_path_nullok(f, nodeid_in, &path_in);
3698  	if (err) {
3699  		reply_err(req, err);
3700  		return;
3701  	}
3702  	err = get_path_nullok(f, nodeid_out, &path_out);
3703  	if (err) {
3704  		free_path(f, nodeid_in, path_in);
3705  		reply_err(req, err);
3706  		return;
3707  	}
3708  	fuse_prepare_interrupt(f, req, &d);
3709  	res = fuse_fs_copy_file_range(f->fs, path_in, fi_in, off_in, path_out,
3710  				      fi_out, off_out, len, flags);
3711  	fuse_finish_interrupt(f, req, &d);
3712  	if (res >= 0)
3713  		fuse_reply_write(req, res);
3714  	else
3715  		reply_err(req, res);
3716  	free_path(f, nodeid_in, path_in);
3717  	free_path(f, nodeid_out, path_out);
3718  }
3719  static void fuse_lib_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,
3720  			   struct fuse_file_info *fi)
3721  {
3722  	struct fuse *f = req_fuse_prepare(req);
3723  	struct fuse_intr_data d;
3724  	char *path;
3725  	int err;
3726  	off_t res;
3727  	err = get_path(f, ino, &path);
3728  	if (err) {
3729  		reply_err(req, err);
3730  		return;
3731  	}
3732  	fuse_prepare_interrupt(f, req, &d);
3733  	res = fuse_fs_lseek(f->fs, path, off, whence, fi);
3734  	fuse_finish_interrupt(f, req, &d);
3735  	free_path(f, ino, path);
3736  	if (res >= 0)
3737  		fuse_reply_lseek(req, res);
3738  	else
3739  		reply_err(req, res);
3740  }
3741  static int clean_delay(struct fuse *f)
3742  {
3743  	int min_sleep = 60;
3744  	int max_sleep = 3600;
3745  	int sleep_time = f->conf.remember / 10;
3746  	if (sleep_time > max_sleep)
3747  		return max_sleep;
3748  	if (sleep_time < min_sleep)
3749  		return min_sleep;
3750  	return sleep_time;
3751  }
3752  int fuse_clean_cache(struct fuse *f)
3753  {
3754  	struct node_lru *lnode;
3755  	struct list_head *curr, *next;
3756  	struct node *node;
3757  	struct timespec now;
3758  	pthread_mutex_lock(&f->lock);
3759  	curr_time(&now);
3760  	for (curr = f->lru_table.next; curr != &f->lru_table; curr = next) {
3761  		double age;
3762  		next = curr->next;
3763  		lnode = list_entry(curr, struct node_lru, lru);
3764  		node = &lnode->node;
3765  		age = diff_timespec(&now, &lnode->forget_time);
3766  		if (age <= f->conf.remember)
3767  			break;
3768  		assert(node->nlookup == 1);
3769  		if (node->refctr > 1)
3770  			continue;
3771  		node->nlookup = 0;
3772  		unhash_name(f, node);
3773  		unref_node(f, node);
3774  	}
3775  	pthread_mutex_unlock(&f->lock);
3776  	return clean_delay(f);
3777  }
3778  static struct fuse_lowlevel_ops fuse_path_ops = {
3779  	.init = fuse_lib_init,
3780  	.destroy = fuse_lib_destroy,
3781  	.lookup = fuse_lib_lookup,
3782  	.forget = fuse_lib_forget,
3783  	.forget_multi = fuse_lib_forget_multi,
3784  	.getattr = fuse_lib_getattr,
3785  	.setattr = fuse_lib_setattr,
3786  	.access = fuse_lib_access,
3787  	.readlink = fuse_lib_readlink,
3788  	.mknod = fuse_lib_mknod,
3789  	.mkdir = fuse_lib_mkdir,
3790  	.unlink = fuse_lib_unlink,
3791  	.rmdir = fuse_lib_rmdir,
3792  	.symlink = fuse_lib_symlink,
3793  	.rename = fuse_lib_rename,
3794  	.link = fuse_lib_link,
3795  	.create = fuse_lib_create,
3796  	.open = fuse_lib_open,
3797  	.read = fuse_lib_read,
3798  	.write_buf = fuse_lib_write_buf,
3799  	.flush = fuse_lib_flush,
3800  	.release = fuse_lib_release,
3801  	.fsync = fuse_lib_fsync,
3802  	.opendir = fuse_lib_opendir,
3803  	.readdir = fuse_lib_readdir,
3804  	.readdirplus = fuse_lib_readdirplus,
3805  	.releasedir = fuse_lib_releasedir,
3806  	.fsyncdir = fuse_lib_fsyncdir,
3807  	.statfs = fuse_lib_statfs,
3808  	.setxattr = fuse_lib_setxattr,
3809  	.getxattr = fuse_lib_getxattr,
3810  	.listxattr = fuse_lib_listxattr,
3811  	.removexattr = fuse_lib_removexattr,
3812  	.getlk = fuse_lib_getlk,
3813  	.setlk = fuse_lib_setlk,
3814  	.flock = fuse_lib_flock,
3815  	.bmap = fuse_lib_bmap,
3816  	.ioctl = fuse_lib_ioctl,
3817  	.poll = fuse_lib_poll,
3818  	.fallocate = fuse_lib_fallocate,
3819  	.copy_file_range = fuse_lib_copy_file_range,
3820  	.lseek = fuse_lib_lseek,
3821  };
3822  int fuse_notify_poll(struct fuse_pollhandle *ph)
3823  {
3824  	return fuse_lowlevel_notify_poll(ph);
3825  }
3826  struct fuse_session *fuse_get_session(struct fuse *f)
3827  {
3828  	return f->se;
3829  }
3830  static int fuse_session_loop_remember(struct fuse *f)
3831  {
3832  	struct fuse_session *se = f->se;
3833  	int res = 0;
3834  	struct timespec now;
3835  	time_t next_clean;
3836  	struct pollfd fds = {
3837  		.fd = se->fd,
3838  		.events = POLLIN
3839  	};
3840  	struct fuse_buf fbuf = {
3841  		.mem = NULL,
3842  	};
3843  	curr_time(&now);
3844  	next_clean = now.tv_sec;
3845  	while (!fuse_session_exited(se)) {
3846  		unsigned timeout;
3847  		curr_time(&now);
3848  		if (now.tv_sec < next_clean)
3849  			timeout = next_clean - now.tv_sec;
3850  		else
3851  			timeout = 0;
3852  		res = poll(&fds, 1, timeout * 1000);
3853  		if (res == -1) {
3854  			if (errno == EINTR)
3855  				continue;
3856  			else
3857  				break;
3858  		} else if (res > 0) {
3859  			res = fuse_session_receive_buf_int(se, &fbuf, NULL);
3860  			if (res == -EINTR)
3861  				continue;
3862  			if (res <= 0)
3863  				break;
3864  			fuse_session_process_buf_int(se, &fbuf, NULL);
3865  		} else {
3866  			timeout = fuse_clean_cache(f);
3867  			curr_time(&now);
3868  			next_clean = now.tv_sec + timeout;
3869  		}
3870  	}
3871  	free(fbuf.mem);
3872  	fuse_session_reset(se);
3873  	return res < 0 ? -1 : 0;
3874  }
3875  int fuse_loop(struct fuse *f)
3876  {
3877  	if (!f)
3878  		return -1;
3879  	if (lru_enabled(f))
3880  		return fuse_session_loop_remember(f);
3881  	return fuse_session_loop(f->se);
3882  }
3883  FUSE_SYMVER("fuse_loop_mt_312", "fuse_loop_mt@@FUSE_3.12")
3884  int fuse_loop_mt_312(struct fuse *f, struct fuse_loop_config *config)
3885  {
3886  	if (f == NULL)
3887  		return -1;
3888  	int res = fuse_start_cleanup_thread(f);
3889  	if (res)
3890  		return -1;
3891  	res = fuse_session_loop_mt_312(fuse_get_session(f), config);
3892  	fuse_stop_cleanup_thread(f);
3893  	return res;
3894  }
3895  int fuse_loop_mt_32(struct fuse *f, struct fuse_loop_config_v1 *config_v1);
3896  FUSE_SYMVER("fuse_loop_mt_32", "fuse_loop_mt@FUSE_3.2")
3897  int fuse_loop_mt_32(struct fuse *f, struct fuse_loop_config_v1 *config_v1)
3898  {
3899  	struct fuse_loop_config *config = fuse_loop_cfg_create();
3900  	if (config == NULL)
3901  		return ENOMEM;
3902  	fuse_loop_cfg_convert(config, config_v1);
3903  	int res = fuse_loop_mt_312(f, config);
3904  	fuse_loop_cfg_destroy(config);
3905  	return res;
3906  }
3907  int fuse_loop_mt_31(struct fuse *f, int clone_fd);
3908  FUSE_SYMVER("fuse_loop_mt_31", "fuse_loop_mt@FUSE_3.0")
3909  int fuse_loop_mt_31(struct fuse *f, int clone_fd)
3910  {
3911  	int err;
3912  	struct fuse_loop_config *config = fuse_loop_cfg_create();
3913  	if (config == NULL)
3914  		return ENOMEM;
3915  	fuse_loop_cfg_set_clone_fd(config, clone_fd);
3916  	err = fuse_loop_mt_312(f, config);
3917  	fuse_loop_cfg_destroy(config);
3918  	return err;
3919  }
3920  void fuse_exit(struct fuse *f)
3921  {
3922  	fuse_session_exit(f->se);
3923  }
3924  struct fuse_context *fuse_get_context(void)
3925  {
3926  	struct fuse_context_i *c = fuse_get_context_internal();
3927  	if (c)
3928  		return &c->ctx;
3929  	else
3930  		return NULL;
3931  }
3932  int fuse_getgroups(int size, gid_t list[])
3933  {
3934  	struct fuse_context_i *c = fuse_get_context_internal();
3935  	if (!c)
3936  		return -EINVAL;
3937  	return fuse_req_getgroups(c->req, size, list);
3938  }
3939  int fuse_interrupted(void)
3940  {
3941  	struct fuse_context_i *c = fuse_get_context_internal();
3942  	if (c)
3943  		return fuse_req_interrupted(c->req);
3944  	else
3945  		return 0;
3946  }
3947  int fuse_invalidate_path(struct fuse *f, const char *path) {
3948  	fuse_ino_t ino;
3949  	int err = lookup_path_in_cache(f, path, &ino);
3950  	if (err) {
3951  		return err;
3952  	}
3953  	return fuse_lowlevel_notify_inval_inode(f->se, ino, 0, 0);
3954  }
3955  #define FUSE_LIB_OPT(t, p, v) { t, offsetof(struct fuse_config, p), v }
3956  static const struct fuse_opt fuse_lib_opts[] = {
3957  	FUSE_OPT_KEY("debug",		      FUSE_OPT_KEY_KEEP),
3958  	FUSE_OPT_KEY("-d",		      FUSE_OPT_KEY_KEEP),
3959  	FUSE_LIB_OPT("debug",		      debug, 1),
3960  	FUSE_LIB_OPT("-d",		      debug, 1),
3961  	FUSE_LIB_OPT("kernel_cache",	      kernel_cache, 1),
3962  	FUSE_LIB_OPT("auto_cache",	      auto_cache, 1),
3963  	FUSE_LIB_OPT("noauto_cache",	      auto_cache, 0),
3964  	FUSE_LIB_OPT("no_rofd_flush",	      no_rofd_flush, 1),
3965  	FUSE_LIB_OPT("umask=",		      set_mode, 1),
3966  	FUSE_LIB_OPT("umask=%o",	      umask, 0),
3967  	FUSE_LIB_OPT("uid=",		      set_uid, 1),
3968  	FUSE_LIB_OPT("uid=%d",		      uid, 0),
3969  	FUSE_LIB_OPT("gid=",		      set_gid, 1),
3970  	FUSE_LIB_OPT("gid=%d",		      gid, 0),
3971  	FUSE_LIB_OPT("entry_timeout=%lf",     entry_timeout, 0),
3972  	FUSE_LIB_OPT("attr_timeout=%lf",      attr_timeout, 0),
3973  	FUSE_LIB_OPT("ac_attr_timeout=%lf",   ac_attr_timeout, 0),
3974  	FUSE_LIB_OPT("ac_attr_timeout=",      ac_attr_timeout_set, 1),
3975  	FUSE_LIB_OPT("negative_timeout=%lf",  negative_timeout, 0),
3976  	FUSE_LIB_OPT("noforget",              remember, -1),
3977  	FUSE_LIB_OPT("remember=%u",           remember, 0),
3978  	FUSE_LIB_OPT("modules=%s",	      modules, 0),
3979  	FUSE_LIB_OPT("parallel_direct_write=%d", parallel_direct_writes, 0),
3980  	FUSE_OPT_END
3981  };
3982  static int fuse_lib_opt_proc(void *data, const char *arg, int key,
3983  			     struct fuse_args *outargs)
3984  {
3985  	(void) arg; (void) outargs; (void) data; (void) key;
3986  	return 1;
3987  }
3988  static const struct fuse_opt fuse_help_opts[] = {
3989  	FUSE_LIB_OPT("modules=%s", modules, 1),
3990  	FUSE_OPT_KEY("modules=%s", FUSE_OPT_KEY_KEEP),
3991  	FUSE_OPT_END
3992  };
3993  static void print_module_help(const char *name,
3994  			      fuse_module_factory_t *fac)
3995  {
3996  	struct fuse_args a = FUSE_ARGS_INIT(0, NULL);
3997  	if (fuse_opt_add_arg(&a, "") == -1 ||
3998  	    fuse_opt_add_arg(&a, "-h") == -1)
3999  		return;
4000  	printf("\nOptions for %s module:\n", name);
4001  	(*fac)(&a, NULL);
4002  	fuse_opt_free_args(&a);
4003  }
4004  void fuse_lib_help(struct fuse_args *args)
4005  {
4006  	printf(
4007  "    -o kernel_cache        cache files in kernel\n"
4008  "    -o [no]auto_cache      enable caching based on modification times (off)\n"
4009  "    -o no_rofd_flush       disable flushing of read-only fd on close (off)\n"
4010  "    -o umask=M             set file permissions (octal)\n"
4011  "    -o uid=N               set file owner\n"
4012  "    -o gid=N               set file group\n"
4013  "    -o entry_timeout=T     cache timeout for names (1.0s)\n"
4014  "    -o negative_timeout=T  cache timeout for deleted names (0.0s)\n"
4015  "    -o attr_timeout=T      cache timeout for attributes (1.0s)\n"
4016  "    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)\n"
4017  "    -o noforget            never forget cached inodes\n"
4018  "    -o remember=T          remember cached inodes for T seconds (0s)\n"
4019  "    -o modules=M1[:M2...]  names of modules to push onto filesystem stack\n");
4020  	fuse_lowlevel_help();
4021  	print_module_help("subdir", &fuse_module_subdir_factory);
4022  #ifdef HAVE_ICONV
4023  	print_module_help("iconv", &fuse_module_iconv_factory);
4024  #endif
4025  	struct fuse_config conf = { .modules = NULL };
4026  	if (fuse_opt_parse(args, &conf, fuse_help_opts,
4027  			   fuse_lib_opt_proc) == -1
4028  	    || !conf.modules)
4029  		return;
4030  	char *module;
4031  	char *next;
4032  	struct fuse_module *m;
4033  	for (module = conf.modules; module; module = next) {
4034  		char *p;
4035  		for (p = module; *p && *p != ':'; p++);
4036  		next = *p ? p + 1 : NULL;
4037  		*p = '\0';
4038  		m = fuse_get_module(module);
4039  		if (m)
4040  			print_module_help(module, &m->factory);
4041  	}
4042  }
4043  static int fuse_init_intr_signal(int signum, int *installed)
4044  {
4045  	struct sigaction old_sa;
4046  	if (sigaction(signum, NULL, &old_sa) == -1) {
4047  		perror("fuse: cannot get old signal handler");
4048  		return -1;
4049  	}
4050  	if (old_sa.sa_handler == SIG_DFL) {
4051  		struct sigaction sa;
4052  		memset(&sa, 0, sizeof(struct sigaction));
4053  		sa.sa_handler = fuse_intr_sighandler;
4054  		sigemptyset(&sa.sa_mask);
4055  		if (sigaction(signum, &sa, NULL) == -1) {
4056  			perror("fuse: cannot set interrupt signal handler");
4057  			return -1;
4058  		}
4059  		*installed = 1;
4060  	}
4061  	return 0;
4062  }
4063  static void fuse_restore_intr_signal(int signum)
4064  {
4065  	struct sigaction sa;
4066  	memset(&sa, 0, sizeof(struct sigaction));
4067  	sa.sa_handler = SIG_DFL;
4068  	sigaction(signum, &sa, NULL);
4069  }
4070  static int fuse_push_module(struct fuse *f, const char *module,
4071  			    struct fuse_args *args)
4072  {
4073  	struct fuse_fs *fs[2] = { f->fs, NULL };
4074  	struct fuse_fs *newfs;
4075  	struct fuse_module *m = fuse_get_module(module);
4076  	if (!m)
4077  		return -1;
4078  	newfs = m->factory(args, fs);
4079  	if (!newfs) {
4080  		fuse_put_module(m);
4081  		return -1;
4082  	}
4083  	f->fs = newfs;
4084  	return 0;
4085  }
4086  struct fuse_fs *fuse_fs_new(const struct fuse_operations *op, size_t op_size,
4087  			    void *user_data)
4088  {
4089  	struct fuse_fs *fs;
4090  	if (sizeof(struct fuse_operations) < op_size) {
4091  		fuse_log(FUSE_LOG_ERR, "fuse: warning: library too old, some operations may not not work\n");
4092  		op_size = sizeof(struct fuse_operations);
4093  	}
4094  	fs = (struct fuse_fs *) calloc(1, sizeof(struct fuse_fs));
4095  	if (!fs) {
4096  		fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate fuse_fs object\n");
4097  		return NULL;
4098  	}
4099  	fs->user_data = user_data;
4100  	if (op)
4101  		memcpy(&fs->op, op, op_size);
4102  	return fs;
4103  }
4104  static int node_table_init(struct node_table *t)
4105  {
4106  	t->size = NODE_TABLE_MIN_SIZE;
4107  	t->array = (struct node **) calloc(1, sizeof(struct node *) * t->size);
4108  	if (t->array == NULL) {
4109  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
4110  		return -1;
4111  	}
4112  	t->use = 0;
4113  	t->split = 0;
4114  	return 0;
4115  }
4116  static void *fuse_prune_nodes(void *fuse)
4117  {
4118  	struct fuse *f = fuse;
4119  	int sleep_time;
4120  	while(1) {
4121  		sleep_time = fuse_clean_cache(f);
4122  		sleep(sleep_time);
4123  	}
4124  	return NULL;
4125  }
4126  int fuse_start_cleanup_thread(struct fuse *f)
4127  {
4128  	if (lru_enabled(f))
4129  		return fuse_start_thread(&f->prune_thread, fuse_prune_nodes, f);
4130  	return 0;
4131  }
4132  void fuse_stop_cleanup_thread(struct fuse *f)
4133  {
4134  	if (lru_enabled(f)) {
4135  		pthread_mutex_lock(&f->lock);
4136  		pthread_cancel(f->prune_thread);
4137  		pthread_mutex_unlock(&f->lock);
4138  		pthread_join(f->prune_thread, NULL);
4139  	}
4140  }
4141  FUSE_SYMVER("fuse_new_31", "fuse_new@@FUSE_3.1")
4142  struct fuse *fuse_new_31(struct fuse_args *args,
4143  		      const struct fuse_operations *op,
4144  		      size_t op_size, void *user_data)
4145  {
4146  	struct fuse *f;
4147  	struct node *root;
4148  	struct fuse_fs *fs;
4149  	struct fuse_lowlevel_ops llop = fuse_path_ops;
4150  	f = (struct fuse *) calloc(1, sizeof(struct fuse));
4151  	if (f == NULL) {
4152  		fuse_log(FUSE_LOG_ERR, "fuse: failed to allocate fuse object\n");
4153  		goto out;
4154  	}
4155  	f->conf.entry_timeout = 1.0;
4156  	f->conf.attr_timeout = 1.0;
4157  	f->conf.negative_timeout = 0.0;
4158  	f->conf.intr_signal = FUSE_DEFAULT_INTR_SIGNAL;
4159  	if (fuse_opt_parse(args, &f->conf, fuse_lib_opts,
4160  			   fuse_lib_opt_proc) == -1)
4161  		goto out_free;
4162  	pthread_mutex_lock(&fuse_context_lock);
4163  	static int builtin_modules_registered = 0;
4164  	if (builtin_modules_registered == 0) {
4165  		fuse_register_module("subdir", fuse_module_subdir_factory, NULL);
4166  #ifdef HAVE_ICONV
4167  		fuse_register_module("iconv", fuse_module_iconv_factory, NULL);
4168  #endif
4169  		builtin_modules_registered= 1;
4170  	}
4171  	pthread_mutex_unlock(&fuse_context_lock);
4172  	if (fuse_create_context_key() == -1)
4173  		goto out_free;
4174  	fs = fuse_fs_new(op, op_size, user_data);
4175  	if (!fs)
4176  		goto out_delete_context_key;
4177  	f->fs = fs;
4178  	if (!fs->op.lock) {
4179  		llop.getlk = NULL;
4180  		llop.setlk = NULL;
4181  	}
4182  	f->pagesize = getpagesize();
4183  	init_list_head(&f->partial_slabs);
4184  	init_list_head(&f->full_slabs);
4185  	init_list_head(&f->lru_table);
4186  	if (f->conf.modules) {
4187  		char *module;
4188  		char *next;
4189  		for (module = f->conf.modules; module; module = next) {
4190  			char *p;
4191  			for (p = module; *p && *p != ':'; p++);
4192  			next = *p ? p + 1 : NULL;
4193  			*p = '\0';
4194  			if (module[0] &&
4195  			    fuse_push_module(f, module, args) == -1)
4196  				goto out_free_fs;
4197  		}
4198  	}
4199  	if (!f->conf.ac_attr_timeout_set)
4200  		f->conf.ac_attr_timeout = f->conf.attr_timeout;
4201  #if defined(__FreeBSD__) || defined(__NetBSD__)
4202  	f->conf.readdir_ino = 1;
4203  #endif
4204  	f->se = fuse_session_new(args, &llop, sizeof(llop), f);
4205  	if (f->se == NULL)
4206  		goto out_free_fs;
4207  	if (f->conf.debug) {
4208  		fuse_log(FUSE_LOG_DEBUG, "nullpath_ok: %i\n", f->conf.nullpath_ok);
4209  	}
4210  	f->fs->debug = f->conf.debug;
4211  	f->ctr = 0;
4212  	f->generation = 0;
4213  	if (node_table_init(&f->name_table) == -1)
4214  		goto out_free_session;
4215  	if (node_table_init(&f->id_table) == -1)
4216  		goto out_free_name_table;
4217  	pthread_mutex_init(&f->lock, NULL);
4218  	root = alloc_node(f);
4219  	if (root == NULL) {
4220  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
4221  		goto out_free_id_table;
4222  	}
4223  	if (lru_enabled(f)) {
4224  		struct node_lru *lnode = node_lru(root);
4225  		init_list_head(&lnode->lru);
4226  	}
4227  	strcpy(root->inline_name, "/");
4228  	root->name = root->inline_name;
4229  	if (f->conf.intr &&
4230  	    fuse_init_intr_signal(f->conf.intr_signal,
4231  				  &f->intr_installed) == -1)
4232  		goto out_free_root;
4233  	root->parent = NULL;
4234  	root->nodeid = FUSE_ROOT_ID;
4235  	inc_nlookup(root);
4236  	hash_id(f, root);
4237  	return f;
4238  out_free_root:
4239  	free(root);
4240  out_free_id_table:
4241  	free(f->id_table.array);
4242  out_free_name_table:
4243  	free(f->name_table.array);
4244  out_free_session:
4245  	fuse_session_destroy(f->se);
4246  out_free_fs:
4247  	free(f->fs);
4248  	free(f->conf.modules);
4249  out_delete_context_key:
4250  	fuse_delete_context_key();
4251  out_free:
4252  	free(f);
4253  out:
4254  	return NULL;
4255  }
4256  struct fuse *fuse_new_30(struct fuse_args *args, const struct fuse_operations *op,
4257  			 size_t op_size, void *private_data);
4258  FUSE_SYMVER("fuse_new_30", "fuse_new@FUSE_3.0")
4259  struct fuse *fuse_new_30(struct fuse_args *args,
4260  			 const struct fuse_operations *op,
4261  			 size_t op_size, void *user_data)
4262  {
4263  	struct fuse_config conf;
4264  	memset(&conf, 0, sizeof(conf));
4265  	const struct fuse_opt opts[] = {
4266  		FUSE_LIB_OPT("-h", show_help, 1),
4267  		FUSE_LIB_OPT("--help", show_help, 1),
4268  		FUSE_OPT_END
4269  	};
4270  	if (fuse_opt_parse(args, &conf, opts,
4271  			   fuse_lib_opt_proc) == -1)
4272  		return NULL;
4273  	if (conf.show_help) {
4274  		fuse_lib_help(args);
4275  		return NULL;
4276  	} else
4277  		return fuse_new_31(args, op, op_size, user_data);
4278  }
4279  void fuse_destroy(struct fuse *f)
4280  {
4281  	size_t i;
4282  	if (f->conf.intr && f->intr_installed)
4283  		fuse_restore_intr_signal(f->conf.intr_signal);
4284  	if (f->fs) {
4285  		fuse_create_context(f);
4286  		for (i = 0; i < f->id_table.size; i++) {
4287  			struct node *node;
4288  			for (node = f->id_table.array[i]; node != NULL;
4289  			     node = node->id_next) {
4290  				if (node->is_hidden) {
4291  					char *path;
4292  					if (try_get_path(f, node->nodeid, NULL, &path, NULL, false) == 0) {
4293  						fuse_fs_unlink(f->fs, path);
4294  						free(path);
4295  					}
4296  				}
4297  			}
4298  		}
4299  	}
4300  	for (i = 0; i < f->id_table.size; i++) {
4301  		struct node *node;
4302  		struct node *next;
4303  		for (node = f->id_table.array[i]; node != NULL; node = next) {
4304  			next = node->id_next;
4305  			free_node(f, node);
4306  			f->id_table.use--;
4307  		}
4308  	}
4309  	assert(list_empty(&f->partial_slabs));
4310  	assert(list_empty(&f->full_slabs));
4311  	while (fuse_modules) {
4312  		fuse_put_module(fuse_modules);
4313  	}
4314  	free(f->id_table.array);
4315  	free(f->name_table.array);
4316  	pthread_mutex_destroy(&f->lock);
4317  	fuse_session_destroy(f->se);
4318  	free(f->fs);
4319  	free(f->conf.modules);
4320  	free(f);
4321  	fuse_delete_context_key();
4322  }
4323  int fuse_mount(struct fuse *f, const char *mountpoint) {
4324  	return fuse_session_mount(fuse_get_session(f), mountpoint);
4325  }
4326  void fuse_unmount(struct fuse *f) {
4327  	fuse_session_unmount(fuse_get_session(f));
4328  }
4329  int fuse_version(void)
4330  {
4331  	return FUSE_VERSION;
4332  }
4333  const char *fuse_pkgversion(void)
4334  {
4335  	return PACKAGE_VERSION;
4336  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-passthrough.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse.c</div>
                </div>
                <div class="column column_space"><pre><code>83  }
84  static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
85  {
86  	int res;
87  	res = mknod_wrapper(AT_FDCWD, path, NULL, mode, rdev);
</pre></code></div>
                <div class="column column_space"><pre><code>201  }
202  static int fuse_load_so_module(const char *module)
203  {
204  	int ret = -1;
205  	char *tmp;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    