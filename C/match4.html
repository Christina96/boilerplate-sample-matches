<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for config_1.h &amp; config-win.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for config_1.h &amp; config-win.h
      </h3>
<h1 align="center">
        93.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>config_1.h (93.74111%)<th>config-win.h (93.475174%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-417)<td><a href="#" name="0">(58-427)</a><td align="center"><font color="#ff0000">362</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(520-681)<td><a href="#" name="1">(554-716)</a><td align="center"><font color="#860000">191</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(420-512)<td><a href="#" name="2">(430-523)</a><td align="center"><font color="#4a0000">106</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>config_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef MCELL_CONFIG_WIN_H
2 #define MCELL_CONFIG_WIN_H
3 #ifndef MINGW_HAS_SECURE_API
4 #define MINGW_HAS_SECURE_API #endif
5 #undef __USE_MINGW_ANSI_STDIO
6 #define __USE_MINGW_ANSI_STDIO                                                 \
7   1 <a name="0"></a>#define PRINTF_FORMAT(arg)                                                     \
8   __attribute__((__format__(                                                   \
9 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                                     arguments this corrects warnings */
10 #define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
11 #define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
12 #define _WIN32_WINNT 0x0502
13 #define _CRT_SECURE_NO_WARNINGS
14 #include &lt;windows.h&gt;
15 #include &lt;stdlib.h&gt;
16 #include &lt;direct.h&gt; #include &lt;errno.h&gt;
17 #include &lt;stdio.h&gt; #include &lt;time.h&gt;
18 typedef unsigned short u_short;
19 typedef unsigned int u_int;
20 typedef unsigned long u_long;
21 #undef TRUE
22 #undef FALSE
23 #undef ERROR
24 #undef TRANSPARENT
25 #undef FILE_OVERWRITE
26 #undef FILE_CREATE
27 #ifdef _MSC_VER
28 #define inline __inline
29 #define getcwd _getcwd
30 #define strdup _strdup
31 #define va_copy(d, s) ((d) = (s))
32 #endif
33 #define UNUSED(p) ((void)(p))
34 #ifndef __GNUC__
35 #ifndef __attribute__
36 #define __attribute__(x) #define __restrict__
37 #endif
38 #endif
39 _CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
40 inline static int strerror_r(int errnum, char *buf, size_t buflen) {
41   errno_t err = strerror_s(buf, buflen, errnum);
42   if (err != 0) {
43     errno = err;
44     return -1;
45   }
46   return 0;
47 }
48 inline static char *_ctime_r_helper(const time_t *timep, char *buf,
49                                     size_t buflen) {
50 #if defined(_WIN64) || defined(_MSC_VER)
51   errno_t err = _ctime64_s(buf, buflen, timep);
52 #else
53   errno_t err = _ctime32_s(buf, buflen, timep);
54 #endif
55   if (err != 0) {
56     errno = err;
57     return NULL;
58   }
59   return buf;
60 }
61 #define ctime_r(timep, buf)                                                    \
62   _ctime_r_helper(timep, buf, sizeof(buf)) 
63 inline static int _is_leap_year(int y) {
64   return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
65 }
66 inline static int _iso8061_weeknum(const struct tm *timeptr) {
67   int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
68   int T = timeptr-&gt;tm_mday + 4 -
69           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
70     return 1;
71   }
72   if (M == 1 &amp;&amp; T &lt; 1) {
73     --Y;
74     M = 12;
75     T += 31;
76   }
77   int D = 275 * M / 9 + T - 31 +
78           (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
79 }
80 inline static int _iso8061_wn_year(const struct tm *timeptr) {
81   int T = timeptr-&gt;tm_mday + 4 -
82           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
83          ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
84               ? +1
85               : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
86 }
87 inline static void _strnlwr(char *str, size_t count) {
88   for (char *end = str + count; str &lt; end; ++str) {
89     *str = tolower(*str);
90   }
91 }
92 inline static void _strnupr(char *str, size_t count) {
93   for (char *end = str + count; str &lt; end; ++str) {
94     *str = toupper(*str);
95   }
96 }
97 inline static void _strnchcase(char *str, size_t count) {
98   for (char *end = str + count; str &lt; end; ++str) {
99     *str = isupper(*str) ? tolower(*str) : toupper(*str);
100   }
101 }
102 __attribute__((__format__(
103     gnu_strftime, 3,
104     0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
105                                             const char *format,
106                                             const struct tm *timeptr) {
107   struct tm t = *timeptr;
108   const char *f2, *f1 = format;
109   char *out = strDest, *out_end = strDest + maxsize;
110   char fbuf[3] = "%%", buf[64];
111   while ((f2 = strchr(f1, '%')) != NULL) {
112     if (f2 - f1 &gt; out_end - out) {
113       return 0;
114     }
115     strncpy(out, f1, f2 - f1);
116     out += f2 - f1;
117     ++f2;
118     char flag;
119     if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
120       flag = *(f2++);
121     } else {
122       flag = 0;
123     }
124     size_t width = 0;
125     while (isdigit(*f2)) {
126       width = 10 * (width - '0') + *(f2++);
127     }
128     if ((ptrdiff_t)width &gt; out_end - out) {
129       return 0;
130     }
131     if (*f2 == 'E') {
132       f2++;
133     } else if (*f2 == 'O') {
134       f2++;
135     }
136     size_t count;
137     int is_numeric = 0, is_num_space_padded = 0;
138     switch (*f2) {
139     case 0:
140       buf[0] = '%';
141       count = 1;
142       break;
143     case 'n':
144       buf[0] = '\n';
145       count = 1;
146       break;
147     case 't':
148       buf[0] = '\t';
149       count = 1;
150       break;
151     case 'h':
152       count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
153       break;
154     case 'D':
155       count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
156       break;
157     case 'F':
158       count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
159       break;
160     case 'r':
161       count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
162       break;     case 'R':
163       count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
164       break;
165     case 'T':
166       count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
167       break;
168     case '+':
169       count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
170       break;
171     case 'P':
172       _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
173       break;
174     case 'e':
175       count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
176       is_num_space_padded = 1;
177       is_numeric = 1;
178       break;
179     case 'k':
180       count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
181       is_num_space_padded = 1;
182       is_numeric = 1;
183       break;
184     case 'l':
185       count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
186       is_num_space_padded = 1;
187       is_numeric = 1;
188       break;
189     case 'C':
190       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
191                         (timeptr-&gt;tm_year + 1900) / 100);
192       is_numeric = 1;
193       break;
194     case 'u':
195       count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
196                         timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
197       is_numeric = 1;
198       break;
199 #if defined(_WIN64) || defined(_MSC_VER)
200     case 's':
201       count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
202       is_numeric = 1;
203       break;
204 #else
205     case 's':
206       count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
207       is_numeric = 1;
208       break;
209 #endif
210     case 'V':
211       count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
212       is_numeric = 1;
213       break;
214     case 'G':
215       count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
216       is_numeric = 1;
217       break;
218     case 'g':
219       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
220                         _iso8061_wn_year(timeptr) % 100);
221       is_numeric = 1;
222       break;
223     case 'd':
224     case 'H':
225     case 'I':
226     case 'j':
227     case 'm':
228     case 'M':
229     case 'S':
230     case 'U':
231     case 'w':
232     case 'W':
233     case 'y':
234     case 'Y':
235       is_numeric = 1;
236       fbuf[1] = *f2;
237       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
238       break;
239     default:
240       fbuf[1] = *f2;
241       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
242       break;
243     }
244     size_t trim = 0;
245     char padding =
246         (flag == '_')
247             ? ' '
248             : ((flag == '0')
249                    ? '0'
250                    : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
251     if (is_numeric) {
252       if (flag == '-') {
253         while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
254           ++trim;
255         }
256         count -= trim;
257       } else if (padding == ' ') {
258         for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
259           buf[i] = ' ';
260         }
261       }
262     } else if (flag == '^') {
263       _strnupr(buf, count);
264     }     else if (flag == '#') {
265       _strnchcase(buf, count);
266     }     if ((ptrdiff_t)count &gt; out_end - out) {
267       return 0;
268     }
269     if (count &lt; width) {
270       memset(out, padding, width - count);
271       out += width - count;
272     }
273     strncpy(out, buf + trim, count);
274     out += count;
275     f1 = f2 + 1;
276   }
277   size_t len = strlen(f1);
278   strncpy(out, f1, len);
279   out[len] = 0;
280   return out - strDest + len;
281 }
282 #define strftime _win_strftime
283 #define WSADESCRIPTION_LEN 256
284 #define WSASYS_STATUS_LEN 128
285 #define SOCKET_ERROR -1
286 typedef struct WSAData {
287   WORD wVersion;
288   WORD wHighVersion;
289 #ifdef _WIN64
290   unsigned short iMaxSockets;
291   unsigned short iMaxUdpDg;
292   char *lpVendorInfo;
293   char szDescription[WSADESCRIPTION_LEN + 1];
294   char szSystemStatus[WSASYS_STATUS_LEN + 1];
295 #else
296   char szDescription[WSADESCRIPTION_LEN + 1];
297   char szSystemStatus[WSASYS_STATUS_LEN + 1];
298   unsigned short iMaxSockets;
299   unsigned short iMaxUdpDg;
300   char *lpVendorInfo;
301 #endif
302 } WSADATA, *LPWSADATA;
303 <a name="2"></a>typedef int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,</b></font>
304                                      LPWSADATA lpWSAData);
305 typedef int(WINAPI *FUNC_WSAGetLastError)(void);
306 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef int(WINAPI *FUNC_gethostname)(char *name, int namelen);
307 static FUNC_WSAStartup WSAStartup = NULL;
308 static FUNC_WSAGetLastError WSAGetLastError = NULL;
309 static FUNC_gethostname win32gethostname = NULL;
310 inline static int gethostname(char *name, size_t len) {
311   if (len &gt; INT_MAX) {
312     errno = EINVAL;
313     return -1;
314   }
315   if (win32gethostname == NULL) {
316     HMODULE ws2 = LoadLibraryA("ws2_32");
317     WSADATA wsaData;
318     WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
319     WSAGetLastError =
320         (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
321     win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
322     if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
323         win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
324       if (ws2) {
325         FreeLibrary(ws2);
326       }
327       win32gethostname = NULL;
328       errno = EPERM;
329       return -1;
330     }
331   }
332   if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
333     switch (WSAGetLastError()) {
334     case WSAEFAULT:
335       errno = name ? ENAMETOOLONG : EFAULT;
336       break;
337     case WSANOTINITIALISED:
338     case WSAENETDOWN:
339     case WSAEINPROGRESS:
340       errno = EAGAIN;
341       break;
342     }
343     return -1;
344   }
345   return 0;
346 }
347 #ifndef _TIMEVAL_DEFINED
348 #define _TIMEVAL_DEFINED
349 struct timeval {
350   long tv_sec;
351   long tv_usec;
352 };
353 #endif
354 struct rusage {
355   struct timeval ru_utime;   struct timeval ru_stime; };
356 #define RUSAGE_SELF 0
357 inline static int getrusage(int who, struct rusage *usage) {
358   if (who != RUSAGE_SELF) {
359     errno = EINVAL;
360     return -1;
361   }
362   if (usage == NULL) {
363     errno = EFAULT;
364     return -1;
365   }
366   FILETIME ftCreation, ftExit, ftKernel, ftUser;
367   if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
368                       &amp;ftUser) == 0) {
369     return -1;
370   }
371   ULONGLONG user =
372       (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
373   ULONGLONG kernel =
374       (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
375   usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
376   usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
377   usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
378   usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
379   return 0;
380 }</b></font>
381 #define SYMBOLIC_LINK_FLAG_FILE 0x0
382 #define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
383 <a name="1"></a>typedef BOOLEAN(WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
384                                                  LPCSTR lpTargetFileName,
385                                                  DWORD dwFlags);
386 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
387 inline static int _win_is_dir(const char *path) {
388   DWORD attr = GetFileAttributesA(path);
389   return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
390          (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
391 }
392 inline static int symlink(const char *oldpath, const char *newpath) {
393   if (CreateSymbolicLink == NULL) {
394     CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
395         GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
396     if (CreateSymbolicLink == NULL) {
397       errno = EPERM;
398       return -1;
399     }
400   }
401   if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
402     char buf[MAX_PATH + 1];
403     switch (GetLastError()) {
404     case ERROR_INVALID_FUNCTION:
405       errno = EPERM;
406       break;
407     case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
408       errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
409                   ? ENAMETOOLONG
410                   : ENOENT;
411       break;     case ERROR_ACCESS_DENIED:
412       errno = _win_is_dir(newpath) ? EEXIST : EACCES;
413     case ERROR_NOT_ENOUGH_MEMORY:
414       errno = ENOMEM;
415       break;
416     case ERROR_WRITE_PROTECT:
417       errno = EROFS;
418       break;
419     case ERROR_INVALID_PARAMETER:
420       errno = EFAULT;
421       break;
422     case ERROR_DISK_FULL:
423       errno = ENOSPC;
424       break;
425     case ERROR_ALREADY_EXISTS:
426       errno = EEXIST;
427       break;
428     default:
429       errno = EIO;
430       break;
431     }
432     return -1;
433   }
434   return 0;
435 }
436 #include &lt;sys/stat.h&gt;
437 #ifndef FSCTL_GET_REPARSE_POINT
438 #define FSCTL_GET_REPARSE_POINT                                                \
439   (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
440       (0 &lt;&lt; 14) #endif
441 #define S_IFLNK 0120000
442 #define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
443 inline static int _is_symlink(const char *path) {
444   HANDLE hFile = CreateFileA(
445       path, GENERIC_READ,
446       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
447       OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
448       NULL);
449   if (hFile == INVALID_HANDLE_VALUE) {
450     return 0;
451   }
452   DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
453   if (data == NULL) {
454     CloseHandle(hFile);
455     return 0;
456   }
457   BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
458                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
459   DWORD tag = *data;
460   free(data);
461   CloseHandle(hFile);
462   return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
463 }
464 #ifdef stat
465 #undef stat
466 #undef fstat
467 #define stat _win_stat
468 #define fstat _win_fstat
469 struct stat {   _dev_t st_dev;
470   _ino_t st_ino;
471   unsigned short st_mode;
472   short st_nlink;
473   short st_uid;
474   short st_gid;
475   _dev_t st_rdev;
476   __MINGW_EXTENSION __int64 st_size;
477   __time64_t st_atime;
478   __time64_t st_mtime;
479   __time64_t st_ctime;
480 };
481 inline static int stat(const char *path, struct stat *buf) {
482   int retval = _stat64(path, (struct _stat64 *)buf);
483   if (retval == 0 &amp;&amp; _is_symlink(path)) {
484     buf-&gt;st_mode |= S_IFLNK;
485   }
486   return retval;
487 }
488 inline static int fstat(int fd, struct stat *buf) {
489   return _fstat64(fd, (struct _stat64 *)buf);
490 }
491 #else
492 inline static int _win_stat(const char *path, struct stat *buf) {
493   int retval = stat(path, buf);
494   if (retval == 0 &amp;&amp; _is_symlink(path)) {
495     buf-&gt;st_mode |= S_IFLNK;
496   }
497   return retval;
498 }
499 #define stat(path, buf) _win_stat(path, buf)
500 #endif
501 #define SIGALRM 14
502 typedef void(__cdecl *ALARM_CB)(int);
503 static ALARM_CB _alarm_cb = NULL;
504 static HANDLE _timer = NULL;
505 inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
506   _timer = NULL;
507   _alarm_cb(SIGALRM);
508 }
509 inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
510 inline static unsigned alarm(unsigned seconds) {
511   unsigned retval = 0;
512   if (_timer) {
513     retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
514     _timer = NULL;
515   }
516   if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
517                              NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
518     retval = (unsigned)-1;
519   }
520   return retval;
521 }</b></font>
522 inline static int _win_rename(const char *old, const char *new) {
523   DWORD dwAttrib = GetFileAttributes(new);
524   if (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
525       !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY)) {
526     if (ReplaceFile(new, old, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL)) {
527       return 0;
528     }
529     errno = EACCES;
530     return -1;
531   } else {
532     return rename(old, new);
533   }
534 }
535 #define rename _win_rename
536 inline static int _win_mkdir(const char *pathname, mode_t mode) {
537   UNUSED(mode);
538   return mkdir(pathname);
539 }
540 #define mkdir _win_mkdir
541 #endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>config-win.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef MCELL_CONFIG_WIN_H
2 #define MCELL_CONFIG_WIN_H
3 #ifdef _MSC_VER
4 typedef unsigned int mode_t;
5 #pragma warning( disable : 4996 )
6 #endif
7 #ifndef MINGW_HAS_SECURE_API
8 #define MINGW_HAS_SECURE_API #endif
9 #undef __USE_MINGW_ANSI_STDIO
10 #define __USE_MINGW_ANSI_STDIO                                                 \
11   1 <a name="0"></a>#define PRINTF_FORMAT(arg)                                                     \
12   __attribute__((__format__(                                                   \
13 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>                                     arguments this corrects warnings */
14 #define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
15 #define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
16 #define _WIN32_WINNT 0x0502
17 #define _CRT_SECURE_NO_WARNINGS
18 #include &lt;windows.h&gt;
19 #include &lt;stdlib.h&gt;
20 #include &lt;direct.h&gt; #include &lt;errno.h&gt;
21 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt;
22 #include &lt;time.h&gt;
23 typedef unsigned short u_short;
24 typedef unsigned int u_int;
25 typedef unsigned long u_long;
26 #undef TRUE
27 #undef FALSE
28 #undef ERROR
29 #undef TRANSPARENT
30 #undef FILE_OVERWRITE
31 #undef FILE_CREATE
32 #ifdef _MSC_VER
33 #define getcwd _getcwd
34 #define strdup _strdup
35 #define va_copy(d, s) ((d) = (s))
36 #endif
37 #define UNUSED(p) ((void)(p))
38 #ifndef __GNUC__
39 #ifndef __attribute__
40 #define __attribute__(x) #define __restrict__
41 #endif
42 #endif
43 _CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
44 inline static int strerror_r(int errnum, char *buf, size_t buflen) {
45   errno_t err = strerror_s(buf, buflen, errnum);
46   if (err != 0) {
47     errno = err;
48     return -1;
49   }
50   return 0;
51 }
52 inline static char *_ctime_r_helper(const time_t *timep, char *buf,
53                                     size_t buflen) {
54 #if defined(_WIN64) || defined(_MSC_VER)
55   errno_t err = _ctime64_s(buf, buflen, timep);
56 #else
57   errno_t err = _ctime32_s(buf, buflen, timep);
58 #endif
59   if (err != 0) {
60     errno = err;
61     return NULL;
62   }
63   return buf;
64 }
65 #define ctime_r(timep, buf)                                                    \
66   _ctime_r_helper(timep, buf, sizeof(buf)) 
67 inline static int _is_leap_year(int y) {
68   return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
69 }
70 inline static int _iso8061_weeknum(const struct tm *timeptr) {
71   int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
72   int T = timeptr-&gt;tm_mday + 4 -
73           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
74     return 1;
75   }
76   if (M == 1 &amp;&amp; T &lt; 1) {
77     --Y;
78     M = 12;
79     T += 31;
80   }
81   int D = 275 * M / 9 + T - 31 +
82           (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
83 }
84 inline static int _iso8061_wn_year(const struct tm *timeptr) {
85   int T = timeptr-&gt;tm_mday + 4 -
86           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
87          ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
88               ? +1
89               : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
90 }
91 inline static void _strnlwr(char *str, size_t count) {
92   for (char *end = str + count; str &lt; end; ++str) {
93     *str = tolower(*str);
94   }
95 }
96 inline static void _strnupr(char *str, size_t count) {
97   for (char *end = str + count; str &lt; end; ++str) {
98     *str = toupper(*str);
99   }
100 }
101 inline static void _strnchcase(char *str, size_t count) {
102   for (char *end = str + count; str &lt; end; ++str) {
103     *str = isupper(*str) ? tolower(*str) : toupper(*str);
104   }
105 }
106 __attribute__((__format__(
107     gnu_strftime, 3,
108     0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
109                                             const char *format,
110                                             const struct tm *timeptr) {
111   struct tm t = *timeptr;
112   const char *f2, *f1 = format;
113   char *out = strDest, *out_end = strDest + maxsize;
114   char fbuf[3] = "%%", buf[64];
115   while ((f2 = strchr(f1, '%')) != NULL) {
116     if (f2 - f1 &gt; out_end - out) {
117       return 0;
118     }
119     strncpy(out, f1, f2 - f1);
120     out += f2 - f1;
121     ++f2;
122     char flag;
123     if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
124       flag = *(f2++);
125     } else {
126       flag = 0;
127     }
128     size_t width = 0;
129     while (isdigit(*f2)) {
130       width = 10 * (width - '0') + *(f2++);
131     }
132     if ((ptrdiff_t)width &gt; out_end - out) {
133       return 0;
134     }
135     if (*f2 == 'E') {
136       f2++;
137     } else if (*f2 == 'O') {
138       f2++;
139     }
140     size_t count;
141     int is_numeric = 0, is_num_space_padded = 0;
142     switch (*f2) {
143     case 0:
144       buf[0] = '%';
145       count = 1;
146       break;
147     case 'n':
148       buf[0] = '\n';
149       count = 1;
150       break;
151     case 't':
152       buf[0] = '\t';
153       count = 1;
154       break;
155     case 'h':
156       count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
157       break;
158     case 'D':
159       count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
160       break;
161     case 'F':
162       count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
163       break;
164     case 'r':
165       count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
166       break;     case 'R':
167       count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
168       break;
169     case 'T':
170       count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
171       break;
172     case '+':
173       count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
174       break;
175     case 'P':
176       _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
177       break;
178     case 'e':
179       count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
180       is_num_space_padded = 1;
181       is_numeric = 1;
182       break;
183     case 'k':
184       count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
185       is_num_space_padded = 1;
186       is_numeric = 1;
187       break;
188     case 'l':
189       count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
190       is_num_space_padded = 1;
191       is_numeric = 1;
192       break;
193     case 'C':
194       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
195                         (timeptr-&gt;tm_year + 1900) / 100);
196       is_numeric = 1;
197       break;
198     case 'u':
199       count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
200                         timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
201       is_numeric = 1;
202       break;
203 #if defined(_WIN64) || defined(_MSC_VER)
204     case 's':
205       count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
206       is_numeric = 1;
207       break;
208 #else
209     case 's':
210       count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
211       is_numeric = 1;
212       break;
213 #endif
214     case 'V':
215       count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
216       is_numeric = 1;
217       break;
218     case 'G':
219       count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
220       is_numeric = 1;
221       break;
222     case 'g':
223       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
224                         _iso8061_wn_year(timeptr) % 100);
225       is_numeric = 1;
226       break;
227     case 'd':
228     case 'H':
229     case 'I':
230     case 'j':
231     case 'm':
232     case 'M':
233     case 'S':
234     case 'U':
235     case 'w':
236     case 'W':
237     case 'y':
238     case 'Y':
239       is_numeric = 1;
240       fbuf[1] = *f2;
241       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
242       break;
243     default:
244       fbuf[1] = *f2;
245       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
246       break;
247     }
248     size_t trim = 0;
249     char padding =
250         (flag == '_')
251             ? ' '
252             : ((flag == '0')
253                    ? '0'
254                    : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
255     if (is_numeric) {
256       if (flag == '-') {
257         while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
258           ++trim;
259         }
260         count -= trim;
261       } else if (padding == ' ') {
262         for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
263           buf[i] = ' ';
264         }
265       }
266     } else if (flag == '^') {
267       _strnupr(buf, count);
268     }     else if (flag == '#') {
269       _strnchcase(buf, count);
270     }     if ((ptrdiff_t)count &gt; out_end - out) {
271       return 0;
272     }
273     if (count &lt; width) {
274       memset(out, padding, width - count);
275       out += width - count;
276     }
277     strncpy(out, buf + trim, count);
278     out += count;
279     f1 = f2 + 1;
280   }
281   size_t len = strlen(f1);
282   strncpy(out, f1, len);
283   out[len] = 0;
284   return out - strDest + len;
285 }
286 #define strftime _win_strftime
287 #if 0
288 #define WSADESCRIPTION_LEN 256
289 #define WSASYS_STATUS_LEN 128
290 #define SOCKET_ERROR -1
291 typedef struct WSAData {
292   WORD wVersion;
293   WORD wHighVersion;
294 #ifdef _WIN64
295   unsigned short iMaxSockets;
296   unsigned short iMaxUdpDg;
297   char *lpVendorInfo;
298   char szDescription[WSADESCRIPTION_LEN + 1];
299   char szSystemStatus[WSASYS_STATUS_LEN + 1];
300 #else
301   char szDescription[WSADESCRIPTION_LEN + 1];
302   char szSystemStatus[WSASYS_STATUS_LEN + 1];
303   unsigned short iMaxSockets;
304   unsigned short iMaxUdpDg;
305   char *lpVendorInfo;
306 #endif
307 } WSADATA, *LPWSADATA;
308 #endif
309 #if 0
310 <a name="2"></a>typedef long long int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,</b></font>
311                                      LPWSADATA lpWSAData);
312 typedef long long int(WINAPI *FUNC_WSAGetLastError)(void);
313 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef long long int(WINAPI *FUNC_gethostname)(char *name, int namelen);
314 static FUNC_WSAStartup WSAStartup = NULL;
315 static FUNC_WSAGetLastError WSAGetLastError = NULL;
316 static FUNC_gethostname win32gethostname = NULL;
317 inline static int gethostname(char *name, size_t len) {
318   if (len &gt; INT_MAX) {
319     errno = EINVAL;
320     return -1;
321   }
322   if (win32gethostname == NULL) {
323     HMODULE ws2 = LoadLibraryA("ws2_32");
324     WSADATA wsaData;
325     WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
326     WSAGetLastError =
327         (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
328     win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
329     if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
330         win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
331       if (ws2) {
332         FreeLibrary(ws2);
333       }
334       win32gethostname = NULL;
335       errno = EPERM;
336       return -1;
337     }
338   }
339   if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
340     switch (WSAGetLastError()) {
341     case WSAEFAULT:
342       errno = name ? ENAMETOOLONG : EFAULT;
343       break;
344     case WSANOTINITIALISED:
345     case WSAENETDOWN:
346     case WSAEINPROGRESS:
347       errno = EAGAIN;
348       break;
349     }
350     return -1;
351   }
352   return 0;
353 }
354 #endif
355 #if !defined(_TIMEVAL_DEFINED) #define _TIMEVAL_DEFINED
356 struct timeval {
357   long tv_sec;
358   long tv_usec;
359 };
360 #endif
361 struct rusage {
362   struct timeval ru_utime;   struct timeval ru_stime; };
363 #define RUSAGE_SELF 0
364 inline static int getrusage(int who, struct rusage *usage) {
365   if (who != RUSAGE_SELF) {
366     errno = EINVAL;
367     return -1;
368   }
369   if (usage == NULL) {
370     errno = EFAULT;
371     return -1;
372   }
373   FILETIME ftCreation, ftExit, ftKernel, ftUser;
374   if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
375                       &amp;ftUser) == 0) {
376     return -1;
377   }
378   ULONGLONG user =
379       (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
380   ULONGLONG kernel =
381       (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
382   usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
383   usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
384   usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
385   usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
386   return 0;
387 }</b></font>
388 static int gettimeofday(struct timeval * tp, void*)
389 {
390     const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
391     SYSTEMTIME  system_time;
392     FILETIME    file_time;
393     uint64_t    time;
394     GetSystemTime( &amp;system_time );
395     SystemTimeToFileTime( &amp;system_time, &amp;file_time );
396     time =  ((uint64_t)file_time.dwLowDateTime )      ;
397     time += ((uint64_t)file_time.dwHighDateTime) &lt;&lt; 32;
398     tp-&gt;tv_sec  = (long) ((time - EPOCH) / 10000000L);
399     tp-&gt;tv_usec = (long) (system_time.wMilliseconds * 1000);
400     return 0;
401 }
402 #if 0
403 #define SYMBOLIC_LINK_FLAG_FILE 0x0
404 #define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
405 <a name="1"></a>typedef long long int (WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
406                                                  LPCSTR lpTargetFileName,
407                                                  DWORD dwFlags);
408 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
409 inline static int _win_is_dir(const char *path) {
410   DWORD attr = GetFileAttributesA(path);
411   return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
412          (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
413 }
414 inline static int symlink(const char *oldpath, const char *newpath) {
415   if (CreateSymbolicLink == NULL) {
416     CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
417         GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
418     if (CreateSymbolicLink == NULL) {
419       errno = EPERM;
420       return -1;
421     }
422   }
423   if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
424     char buf[MAX_PATH + 1];
425     switch (GetLastError()) {
426     case ERROR_INVALID_FUNCTION:
427       errno = EPERM;
428       break;
429     case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
430       errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
431                   ? ENAMETOOLONG
432                   : ENOENT;
433       break;     case ERROR_ACCESS_DENIED:
434       errno = _win_is_dir(newpath) ? EEXIST : EACCES;
435     case ERROR_NOT_ENOUGH_MEMORY:
436       errno = ENOMEM;
437       break;
438     case ERROR_WRITE_PROTECT:
439       errno = EROFS;
440       break;
441     case ERROR_INVALID_PARAMETER:
442       errno = EFAULT;
443       break;
444     case ERROR_DISK_FULL:
445       errno = ENOSPC;
446       break;
447     case ERROR_ALREADY_EXISTS:
448       errno = EEXIST;
449       break;
450     default:
451       errno = EIO;
452       break;
453     }
454     return -1;
455   }
456   return 0;
457 }
458 #endif
459 #include &lt;sys/stat.h&gt;
460 #ifndef FSCTL_GET_REPARSE_POINT
461 #define FSCTL_GET_REPARSE_POINT                                                \
462   (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
463       (0 &lt;&lt; 14) #endif
464 #define S_IFLNK 0120000
465 #define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
466 inline static int _is_symlink(const char *path) {
467   HANDLE hFile = CreateFileA(
468       path, GENERIC_READ,
469       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
470       OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
471       NULL);
472   if (hFile == INVALID_HANDLE_VALUE) {
473     return 0;
474   }
475   DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
476   if (data == NULL) {
477     CloseHandle(hFile);
478     return 0;
479   }
480   BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
481                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
482   DWORD tag = *data;
483   free(data);
484   CloseHandle(hFile);
485   return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
486 }
487 #ifdef stat
488 #undef stat
489 #undef fstat
490 #define stat _win_stat
491 #define fstat _win_fstat
492 struct stat {   _dev_t st_dev;
493   _ino_t st_ino;
494   unsigned short st_mode;
495   short st_nlink;
496   short st_uid;
497   short st_gid;
498   _dev_t st_rdev;
499   __MINGW_EXTENSION __int64 st_size;
500   __time64_t st_atime;
501   __time64_t st_mtime;
502   __time64_t st_ctime;
503 };
504 inline static int stat(const char *path, struct stat *buf) {
505   int retval = _stat64(path, (struct _stat64 *)buf);
506   if (retval == 0 &amp;&amp; _is_symlink(path)) {
507     buf-&gt;st_mode |= S_IFLNK;
508   }
509   return retval;
510 }
511 inline static int fstat(int fd, struct stat *buf) {
512   return _fstat64(fd, (struct _stat64 *)buf);
513 }
514 #else
515 inline static int _win_stat(const char *path, struct stat *buf) {
516   int retval = stat(path, buf);
517   if (retval == 0 &amp;&amp; _is_symlink(path)) {
518     buf-&gt;st_mode |= S_IFLNK;
519   }
520   return retval;
521 }
522 #define stat(path, buf) _win_stat(path, buf)
523 #endif
524 #define SIGALRM 14
525 typedef void(__cdecl *ALARM_CB)(int);
526 static ALARM_CB _alarm_cb = NULL;
527 static HANDLE _timer = NULL;
528 inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
529   _timer = NULL;
530   _alarm_cb(SIGALRM);
531 }
532 inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
533 inline static unsigned alarm(unsigned seconds) {
534   unsigned retval = 0;
535   if (_timer) {
536     retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
537     _timer = NULL;
538   }
539   if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
540                              NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
541     retval = (unsigned)-1;
542   }
543   return retval;
544 }</b></font>
545 int _win_rename(const char *old, const char *new_name);
546 inline static int _win_mkdir(const char *pathname, mode_t mode) {
547   UNUSED(mode);
548   return mkdir(pathname);
549 }
550 #define mkdir _win_mkdir
551 #undef IGNORE
552 #undef DIFFERENCE
553 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
