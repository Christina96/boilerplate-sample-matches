<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for config_1.h &amp; config-win.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for config_1.h &amp; config-win.h
      </h3>
<h1 align="center">
        93.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>config_1.h (93.74111%)<th>config-win.h (93.475174%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-417)<td><a href="#" name="0">(58-427)</a><td align="center"><font color="#ff0000">362</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(520-681)<td><a href="#" name="1">(554-716)</a><td align="center"><font color="#860000">191</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(420-512)<td><a href="#" name="2">(430-523)</a><td align="center"><font color="#4a0000">106</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>config_1.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef MCELL_CONFIG_WIN_H
#define MCELL_CONFIG_WIN_H
#ifndef MINGW_HAS_SECURE_API
#define MINGW_HAS_SECURE_API #endif
#undef __USE_MINGW_ANSI_STDIO
#define __USE_MINGW_ANSI_STDIO                                                 \
  1 <a name="0"></a>#define PRINTF_FORMAT(arg)                                                     \
  __attribute__((__format__(                                                   \
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                                     arguments this corrects warnings */
#define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
#define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#define _CRT_SECURE_NO_WARNINGS
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt; #include &lt;errno.h&gt;
#include &lt;stdio.h&gt; #include &lt;time.h&gt;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
#undef TRUE
#undef FALSE
#undef ERROR
#undef TRANSPARENT
#undef FILE_OVERWRITE
#undef FILE_CREATE
#ifdef _MSC_VER
#define inline __inline
#define getcwd _getcwd
#define strdup _strdup
#define va_copy(d, s) ((d) = (s))
#endif
#define UNUSED(p) ((void)(p))
#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(x) #define __restrict__
#endif
#endif
_CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
inline static int strerror_r(int errnum, char *buf, size_t buflen) {
  errno_t err = strerror_s(buf, buflen, errnum);
  if (err != 0) {
    errno = err;
    return -1;
  }
  return 0;
}
inline static char *_ctime_r_helper(const time_t *timep, char *buf,
                                    size_t buflen) {
#if defined(_WIN64) || defined(_MSC_VER)
  errno_t err = _ctime64_s(buf, buflen, timep);
#else
  errno_t err = _ctime32_s(buf, buflen, timep);
#endif
  if (err != 0) {
    errno = err;
    return NULL;
  }
  return buf;
}
#define ctime_r(timep, buf)                                                    \
  _ctime_r_helper(timep, buf, sizeof(buf)) 
inline static int _is_leap_year(int y) {
  return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
}
inline static int _iso8061_weeknum(const struct tm *timeptr) {
  int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
    return 1;
  }
  if (M == 1 &amp;&amp; T &lt; 1) {
    --Y;
    M = 12;
    T += 31;
  }
  int D = 275 * M / 9 + T - 31 +
          (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
}
inline static int _iso8061_wn_year(const struct tm *timeptr) {
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
         ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
              ? +1
              : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
}
inline static void _strnlwr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = tolower(*str);
  }
}
inline static void _strnupr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = toupper(*str);
  }
}
inline static void _strnchcase(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = isupper(*str) ? tolower(*str) : toupper(*str);
  }
}
__attribute__((__format__(
    gnu_strftime, 3,
    0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
                                            const char *format,
                                            const struct tm *timeptr) {
  struct tm t = *timeptr;
  const char *f2, *f1 = format;
  char *out = strDest, *out_end = strDest + maxsize;
  char fbuf[3] = "%%", buf[64];
  while ((f2 = strchr(f1, '%')) != NULL) {
    if (f2 - f1 &gt; out_end - out) {
      return 0;
    }
    strncpy(out, f1, f2 - f1);
    out += f2 - f1;
    ++f2;
    char flag;
    if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
      flag = *(f2++);
    } else {
      flag = 0;
    }
    size_t width = 0;
    while (isdigit(*f2)) {
      width = 10 * (width - '0') + *(f2++);
    }
    if ((ptrdiff_t)width &gt; out_end - out) {
      return 0;
    }
    if (*f2 == 'E') {
      f2++;
    } else if (*f2 == 'O') {
      f2++;
    }
    size_t count;
    int is_numeric = 0, is_num_space_padded = 0;
    switch (*f2) {
    case 0:
      buf[0] = '%';
      count = 1;
      break;
    case 'n':
      buf[0] = '\n';
      count = 1;
      break;
    case 't':
      buf[0] = '\t';
      count = 1;
      break;
    case 'h':
      count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
      break;
    case 'D':
      count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
      break;
    case 'F':
      count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
      break;
    case 'r':
      count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
      break;     case 'R':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
      break;
    case 'T':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
      break;
    case '+':
      count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
      break;
    case 'P':
      _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
      break;
    case 'e':
      count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'k':
      count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'l':
      count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'C':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        (timeptr-&gt;tm_year + 1900) / 100);
      is_numeric = 1;
      break;
    case 'u':
      count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
                        timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
      is_numeric = 1;
      break;
#if defined(_WIN64) || defined(_MSC_VER)
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#else
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#endif
    case 'V':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
      is_numeric = 1;
      break;
    case 'G':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
      is_numeric = 1;
      break;
    case 'g':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        _iso8061_wn_year(timeptr) % 100);
      is_numeric = 1;
      break;
    case 'd':
    case 'H':
    case 'I':
    case 'j':
    case 'm':
    case 'M':
    case 'S':
    case 'U':
    case 'w':
    case 'W':
    case 'y':
    case 'Y':
      is_numeric = 1;
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    default:
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    }
    size_t trim = 0;
    char padding =
        (flag == '_')
            ? ' '
            : ((flag == '0')
                   ? '0'
                   : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
    if (is_numeric) {
      if (flag == '-') {
        while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
          ++trim;
        }
        count -= trim;
      } else if (padding == ' ') {
        for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
          buf[i] = ' ';
        }
      }
    } else if (flag == '^') {
      _strnupr(buf, count);
    }     else if (flag == '#') {
      _strnchcase(buf, count);
    }     if ((ptrdiff_t)count &gt; out_end - out) {
      return 0;
    }
    if (count &lt; width) {
      memset(out, padding, width - count);
      out += width - count;
    }
    strncpy(out, buf + trim, count);
    out += count;
    f1 = f2 + 1;
  }
  size_t len = strlen(f1);
  strncpy(out, f1, len);
  out[len] = 0;
  return out - strDest + len;
}
#define strftime _win_strftime
#define WSADESCRIPTION_LEN 256
#define WSASYS_STATUS_LEN 128
#define SOCKET_ERROR -1
typedef struct WSAData {
  WORD wVersion;
  WORD wHighVersion;
#ifdef _WIN64
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
#else
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
#endif
} WSADATA, *LPWSADATA;
<a name="2"></a>typedef int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,</b></font>
                                     LPWSADATA lpWSAData);
typedef int(WINAPI *FUNC_WSAGetLastError)(void);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef int(WINAPI *FUNC_gethostname)(char *name, int namelen);
static FUNC_WSAStartup WSAStartup = NULL;
static FUNC_WSAGetLastError WSAGetLastError = NULL;
static FUNC_gethostname win32gethostname = NULL;
inline static int gethostname(char *name, size_t len) {
  if (len &gt; INT_MAX) {
    errno = EINVAL;
    return -1;
  }
  if (win32gethostname == NULL) {
    HMODULE ws2 = LoadLibraryA("ws2_32");
    WSADATA wsaData;
    WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
    WSAGetLastError =
        (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
    win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
    if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
        win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
      if (ws2) {
        FreeLibrary(ws2);
      }
      win32gethostname = NULL;
      errno = EPERM;
      return -1;
    }
  }
  if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
    switch (WSAGetLastError()) {
    case WSAEFAULT:
      errno = name ? ENAMETOOLONG : EFAULT;
      break;
    case WSANOTINITIALISED:
    case WSAENETDOWN:
    case WSAEINPROGRESS:
      errno = EAGAIN;
      break;
    }
    return -1;
  }
  return 0;
}
#ifndef _TIMEVAL_DEFINED
#define _TIMEVAL_DEFINED
struct timeval {
  long tv_sec;
  long tv_usec;
};
#endif
struct rusage {
  struct timeval ru_utime;   struct timeval ru_stime; };
#define RUSAGE_SELF 0
inline static int getrusage(int who, struct rusage *usage) {
  if (who != RUSAGE_SELF) {
    errno = EINVAL;
    return -1;
  }
  if (usage == NULL) {
    errno = EFAULT;
    return -1;
  }
  FILETIME ftCreation, ftExit, ftKernel, ftUser;
  if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
                      &amp;ftUser) == 0) {
    return -1;
  }
  ULONGLONG user =
      (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
  ULONGLONG kernel =
      (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
  usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
  usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
  usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
  usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
  return 0;
}</b></font>
#define SYMBOLIC_LINK_FLAG_FILE 0x0
#define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
<a name="1"></a>typedef BOOLEAN(WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
                                                 LPCSTR lpTargetFileName,
                                                 DWORD dwFlags);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
inline static int _win_is_dir(const char *path) {
  DWORD attr = GetFileAttributesA(path);
  return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
         (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
}
inline static int symlink(const char *oldpath, const char *newpath) {
  if (CreateSymbolicLink == NULL) {
    CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
        GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
    if (CreateSymbolicLink == NULL) {
      errno = EPERM;
      return -1;
    }
  }
  if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
    char buf[MAX_PATH + 1];
    switch (GetLastError()) {
    case ERROR_INVALID_FUNCTION:
      errno = EPERM;
      break;
    case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
      errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
                  ? ENAMETOOLONG
                  : ENOENT;
      break;     case ERROR_ACCESS_DENIED:
      errno = _win_is_dir(newpath) ? EEXIST : EACCES;
    case ERROR_NOT_ENOUGH_MEMORY:
      errno = ENOMEM;
      break;
    case ERROR_WRITE_PROTECT:
      errno = EROFS;
      break;
    case ERROR_INVALID_PARAMETER:
      errno = EFAULT;
      break;
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    default:
      errno = EIO;
      break;
    }
    return -1;
  }
  return 0;
}
#include &lt;sys/stat.h&gt;
#ifndef FSCTL_GET_REPARSE_POINT
#define FSCTL_GET_REPARSE_POINT                                                \
  (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
      (0 &lt;&lt; 14) #endif
#define S_IFLNK 0120000
#define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
inline static int _is_symlink(const char *path) {
  HANDLE hFile = CreateFileA(
      path, GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
      OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
      NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    return 0;
  }
  DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
  if (data == NULL) {
    CloseHandle(hFile);
    return 0;
  }
  BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
  DWORD tag = *data;
  free(data);
  CloseHandle(hFile);
  return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
}
#ifdef stat
#undef stat
#undef fstat
#define stat _win_stat
#define fstat _win_fstat
struct stat {   _dev_t st_dev;
  _ino_t st_ino;
  unsigned short st_mode;
  short st_nlink;
  short st_uid;
  short st_gid;
  _dev_t st_rdev;
  __MINGW_EXTENSION __int64 st_size;
  __time64_t st_atime;
  __time64_t st_mtime;
  __time64_t st_ctime;
};
inline static int stat(const char *path, struct stat *buf) {
  int retval = _stat64(path, (struct _stat64 *)buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
inline static int fstat(int fd, struct stat *buf) {
  return _fstat64(fd, (struct _stat64 *)buf);
}
#else
inline static int _win_stat(const char *path, struct stat *buf) {
  int retval = stat(path, buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
#define stat(path, buf) _win_stat(path, buf)
#endif
#define SIGALRM 14
typedef void(__cdecl *ALARM_CB)(int);
static ALARM_CB _alarm_cb = NULL;
static HANDLE _timer = NULL;
inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
  _timer = NULL;
  _alarm_cb(SIGALRM);
}
inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
inline static unsigned alarm(unsigned seconds) {
  unsigned retval = 0;
  if (_timer) {
    retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
    _timer = NULL;
  }
  if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
                             NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
    retval = (unsigned)-1;
  }
  return retval;
}</b></font>
inline static int _win_rename(const char *old, const char *new) {
  DWORD dwAttrib = GetFileAttributes(new);
  if (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
      !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY)) {
    if (ReplaceFile(new, old, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL)) {
      return 0;
    }
    errno = EACCES;
    return -1;
  } else {
    return rename(old, new);
  }
}
#define rename _win_rename
inline static int _win_mkdir(const char *pathname, mode_t mode) {
  UNUSED(mode);
  return mkdir(pathname);
}
#define mkdir _win_mkdir
#endif
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>config-win.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef MCELL_CONFIG_WIN_H
#define MCELL_CONFIG_WIN_H
#ifdef _MSC_VER
typedef unsigned int mode_t;
#pragma warning( disable : 4996 )
#endif
#ifndef MINGW_HAS_SECURE_API
#define MINGW_HAS_SECURE_API #endif
#undef __USE_MINGW_ANSI_STDIO
#define __USE_MINGW_ANSI_STDIO                                                 \
  1 <a name="0"></a>#define PRINTF_FORMAT(arg)                                                     \
  __attribute__((__format__(                                                   \
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>                                     arguments this corrects warnings */
#define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
#define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#define _CRT_SECURE_NO_WARNINGS
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt; #include &lt;errno.h&gt;
#include &lt;stdio.h&gt; #include &lt;stdint.h&gt;
#include &lt;time.h&gt;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
#undef TRUE
#undef FALSE
#undef ERROR
#undef TRANSPARENT
#undef FILE_OVERWRITE
#undef FILE_CREATE
#ifdef _MSC_VER
#define getcwd _getcwd
#define strdup _strdup
#define va_copy(d, s) ((d) = (s))
#endif
#define UNUSED(p) ((void)(p))
#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(x) #define __restrict__
#endif
#endif
_CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
inline static int strerror_r(int errnum, char *buf, size_t buflen) {
  errno_t err = strerror_s(buf, buflen, errnum);
  if (err != 0) {
    errno = err;
    return -1;
  }
  return 0;
}
inline static char *_ctime_r_helper(const time_t *timep, char *buf,
                                    size_t buflen) {
#if defined(_WIN64) || defined(_MSC_VER)
  errno_t err = _ctime64_s(buf, buflen, timep);
#else
  errno_t err = _ctime32_s(buf, buflen, timep);
#endif
  if (err != 0) {
    errno = err;
    return NULL;
  }
  return buf;
}
#define ctime_r(timep, buf)                                                    \
  _ctime_r_helper(timep, buf, sizeof(buf)) 
inline static int _is_leap_year(int y) {
  return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
}
inline static int _iso8061_weeknum(const struct tm *timeptr) {
  int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
    return 1;
  }
  if (M == 1 &amp;&amp; T &lt; 1) {
    --Y;
    M = 12;
    T += 31;
  }
  int D = 275 * M / 9 + T - 31 +
          (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
}
inline static int _iso8061_wn_year(const struct tm *timeptr) {
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
         ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
              ? +1
              : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
}
inline static void _strnlwr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = tolower(*str);
  }
}
inline static void _strnupr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = toupper(*str);
  }
}
inline static void _strnchcase(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = isupper(*str) ? tolower(*str) : toupper(*str);
  }
}
__attribute__((__format__(
    gnu_strftime, 3,
    0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
                                            const char *format,
                                            const struct tm *timeptr) {
  struct tm t = *timeptr;
  const char *f2, *f1 = format;
  char *out = strDest, *out_end = strDest + maxsize;
  char fbuf[3] = "%%", buf[64];
  while ((f2 = strchr(f1, '%')) != NULL) {
    if (f2 - f1 &gt; out_end - out) {
      return 0;
    }
    strncpy(out, f1, f2 - f1);
    out += f2 - f1;
    ++f2;
    char flag;
    if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
      flag = *(f2++);
    } else {
      flag = 0;
    }
    size_t width = 0;
    while (isdigit(*f2)) {
      width = 10 * (width - '0') + *(f2++);
    }
    if ((ptrdiff_t)width &gt; out_end - out) {
      return 0;
    }
    if (*f2 == 'E') {
      f2++;
    } else if (*f2 == 'O') {
      f2++;
    }
    size_t count;
    int is_numeric = 0, is_num_space_padded = 0;
    switch (*f2) {
    case 0:
      buf[0] = '%';
      count = 1;
      break;
    case 'n':
      buf[0] = '\n';
      count = 1;
      break;
    case 't':
      buf[0] = '\t';
      count = 1;
      break;
    case 'h':
      count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
      break;
    case 'D':
      count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
      break;
    case 'F':
      count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
      break;
    case 'r':
      count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
      break;     case 'R':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
      break;
    case 'T':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
      break;
    case '+':
      count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
      break;
    case 'P':
      _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
      break;
    case 'e':
      count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'k':
      count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'l':
      count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'C':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        (timeptr-&gt;tm_year + 1900) / 100);
      is_numeric = 1;
      break;
    case 'u':
      count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
                        timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
      is_numeric = 1;
      break;
#if defined(_WIN64) || defined(_MSC_VER)
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#else
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#endif
    case 'V':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
      is_numeric = 1;
      break;
    case 'G':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
      is_numeric = 1;
      break;
    case 'g':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        _iso8061_wn_year(timeptr) % 100);
      is_numeric = 1;
      break;
    case 'd':
    case 'H':
    case 'I':
    case 'j':
    case 'm':
    case 'M':
    case 'S':
    case 'U':
    case 'w':
    case 'W':
    case 'y':
    case 'Y':
      is_numeric = 1;
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    default:
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    }
    size_t trim = 0;
    char padding =
        (flag == '_')
            ? ' '
            : ((flag == '0')
                   ? '0'
                   : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
    if (is_numeric) {
      if (flag == '-') {
        while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
          ++trim;
        }
        count -= trim;
      } else if (padding == ' ') {
        for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
          buf[i] = ' ';
        }
      }
    } else if (flag == '^') {
      _strnupr(buf, count);
    }     else if (flag == '#') {
      _strnchcase(buf, count);
    }     if ((ptrdiff_t)count &gt; out_end - out) {
      return 0;
    }
    if (count &lt; width) {
      memset(out, padding, width - count);
      out += width - count;
    }
    strncpy(out, buf + trim, count);
    out += count;
    f1 = f2 + 1;
  }
  size_t len = strlen(f1);
  strncpy(out, f1, len);
  out[len] = 0;
  return out - strDest + len;
}
#define strftime _win_strftime
#if 0
#define WSADESCRIPTION_LEN 256
#define WSASYS_STATUS_LEN 128
#define SOCKET_ERROR -1
typedef struct WSAData {
  WORD wVersion;
  WORD wHighVersion;
#ifdef _WIN64
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
#else
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
#endif
} WSADATA, *LPWSADATA;
#endif
#if 0
<a name="2"></a>typedef long long int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,</b></font>
                                     LPWSADATA lpWSAData);
typedef long long int(WINAPI *FUNC_WSAGetLastError)(void);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef long long int(WINAPI *FUNC_gethostname)(char *name, int namelen);
static FUNC_WSAStartup WSAStartup = NULL;
static FUNC_WSAGetLastError WSAGetLastError = NULL;
static FUNC_gethostname win32gethostname = NULL;
inline static int gethostname(char *name, size_t len) {
  if (len &gt; INT_MAX) {
    errno = EINVAL;
    return -1;
  }
  if (win32gethostname == NULL) {
    HMODULE ws2 = LoadLibraryA("ws2_32");
    WSADATA wsaData;
    WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
    WSAGetLastError =
        (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
    win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
    if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
        win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
      if (ws2) {
        FreeLibrary(ws2);
      }
      win32gethostname = NULL;
      errno = EPERM;
      return -1;
    }
  }
  if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
    switch (WSAGetLastError()) {
    case WSAEFAULT:
      errno = name ? ENAMETOOLONG : EFAULT;
      break;
    case WSANOTINITIALISED:
    case WSAENETDOWN:
    case WSAEINPROGRESS:
      errno = EAGAIN;
      break;
    }
    return -1;
  }
  return 0;
}
#endif
#if !defined(_TIMEVAL_DEFINED) #define _TIMEVAL_DEFINED
struct timeval {
  long tv_sec;
  long tv_usec;
};
#endif
struct rusage {
  struct timeval ru_utime;   struct timeval ru_stime; };
#define RUSAGE_SELF 0
inline static int getrusage(int who, struct rusage *usage) {
  if (who != RUSAGE_SELF) {
    errno = EINVAL;
    return -1;
  }
  if (usage == NULL) {
    errno = EFAULT;
    return -1;
  }
  FILETIME ftCreation, ftExit, ftKernel, ftUser;
  if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
                      &amp;ftUser) == 0) {
    return -1;
  }
  ULONGLONG user =
      (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
  ULONGLONG kernel =
      (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
  usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
  usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
  usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
  usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
  return 0;
}</b></font>
static int gettimeofday(struct timeval * tp, void*)
{
    const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
    SYSTEMTIME  system_time;
    FILETIME    file_time;
    uint64_t    time;
    GetSystemTime( &amp;system_time );
    SystemTimeToFileTime( &amp;system_time, &amp;file_time );
    time =  ((uint64_t)file_time.dwLowDateTime )      ;
    time += ((uint64_t)file_time.dwHighDateTime) &lt;&lt; 32;
    tp-&gt;tv_sec  = (long) ((time - EPOCH) / 10000000L);
    tp-&gt;tv_usec = (long) (system_time.wMilliseconds * 1000);
    return 0;
}
#if 0
#define SYMBOLIC_LINK_FLAG_FILE 0x0
#define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
<a name="1"></a>typedef long long int (WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
                                                 LPCSTR lpTargetFileName,
                                                 DWORD dwFlags);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
inline static int _win_is_dir(const char *path) {
  DWORD attr = GetFileAttributesA(path);
  return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
         (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
}
inline static int symlink(const char *oldpath, const char *newpath) {
  if (CreateSymbolicLink == NULL) {
    CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
        GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
    if (CreateSymbolicLink == NULL) {
      errno = EPERM;
      return -1;
    }
  }
  if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
    char buf[MAX_PATH + 1];
    switch (GetLastError()) {
    case ERROR_INVALID_FUNCTION:
      errno = EPERM;
      break;
    case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
      errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
                  ? ENAMETOOLONG
                  : ENOENT;
      break;     case ERROR_ACCESS_DENIED:
      errno = _win_is_dir(newpath) ? EEXIST : EACCES;
    case ERROR_NOT_ENOUGH_MEMORY:
      errno = ENOMEM;
      break;
    case ERROR_WRITE_PROTECT:
      errno = EROFS;
      break;
    case ERROR_INVALID_PARAMETER:
      errno = EFAULT;
      break;
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    default:
      errno = EIO;
      break;
    }
    return -1;
  }
  return 0;
}
#endif
#include &lt;sys/stat.h&gt;
#ifndef FSCTL_GET_REPARSE_POINT
#define FSCTL_GET_REPARSE_POINT                                                \
  (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
      (0 &lt;&lt; 14) #endif
#define S_IFLNK 0120000
#define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
inline static int _is_symlink(const char *path) {
  HANDLE hFile = CreateFileA(
      path, GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
      OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
      NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    return 0;
  }
  DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
  if (data == NULL) {
    CloseHandle(hFile);
    return 0;
  }
  BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
  DWORD tag = *data;
  free(data);
  CloseHandle(hFile);
  return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
}
#ifdef stat
#undef stat
#undef fstat
#define stat _win_stat
#define fstat _win_fstat
struct stat {   _dev_t st_dev;
  _ino_t st_ino;
  unsigned short st_mode;
  short st_nlink;
  short st_uid;
  short st_gid;
  _dev_t st_rdev;
  __MINGW_EXTENSION __int64 st_size;
  __time64_t st_atime;
  __time64_t st_mtime;
  __time64_t st_ctime;
};
inline static int stat(const char *path, struct stat *buf) {
  int retval = _stat64(path, (struct _stat64 *)buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
inline static int fstat(int fd, struct stat *buf) {
  return _fstat64(fd, (struct _stat64 *)buf);
}
#else
inline static int _win_stat(const char *path, struct stat *buf) {
  int retval = stat(path, buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
#define stat(path, buf) _win_stat(path, buf)
#endif
#define SIGALRM 14
typedef void(__cdecl *ALARM_CB)(int);
static ALARM_CB _alarm_cb = NULL;
static HANDLE _timer = NULL;
inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
  _timer = NULL;
  _alarm_cb(SIGALRM);
}
inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
inline static unsigned alarm(unsigned seconds) {
  unsigned retval = 0;
  if (_timer) {
    retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
    _timer = NULL;
  }
  if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
                             NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
    retval = (unsigned)-1;
  }
  return retval;
}</b></font>
int _win_rename(const char *old, const char *new_name);
inline static int _win_mkdir(const char *pathname, mode_t mode) {
  UNUSED(mode);
  return mkdir(pathname);
}
#define mkdir _win_mkdir
#undef IGNORE
#undef DIFFERENCE
#endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
